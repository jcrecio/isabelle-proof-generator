{"file_name": "/home/qj213/afp-2021-10-22/thys/Presburger-Automata/Presburger_Automata.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Presburger-Automata", "problem_names": ["lemma reach_nil: \"reach tr p [] p\"", "lemma reach_snoc: \"reach tr p bs q \\<Longrightarrow> reach tr p (bs @ [b]) (tr q b)\"", "lemma reach_nil_iff: \"reach tr p [] q = (p = q)\"", "lemma reach_snoc_iff: \"reach tr p (bs @ [b]) k = (\\<exists>q. reach tr p bs q \\<and> k = tr q b)\"", "lemma reach_induct [consumes 1, case_names Nil snoc, induct set: reach]:\n  assumes \"reach tr p w q\"\n  and \"P [] p\"\n  and  \"\\<And>k x y. \\<lbrakk>reach tr p x k; P x k\\<rbrakk> \\<Longrightarrow> P (x @ [y]) (tr k y)\"\n  shows \"P w q\"", "lemma reach_trans: \"\\<lbrakk>reach tr p a r; reach tr r b q\\<rbrakk> \\<Longrightarrow> reach tr p (a @ b) q\"", "lemma reach_inj: \"\\<lbrakk>reach tr p a q; reach tr p a q'\\<rbrakk> \\<Longrightarrow> q = q'\"", "lemma steps_is_node:\n  assumes \"is_node q\"\n  and \"list_all is_alpha w\"\n  shows \"is_node (foldl trans q w)\"", "lemma reach_is_node: \"\\<lbrakk>reach trans p w q; is_node p; list_all is_alpha w\\<rbrakk> \\<Longrightarrow> is_node q\"", "lemma bddh_ge:\n  assumes \"m \\<ge> n\"\n  assumes \"bddh n bdd\"\n  shows \"bddh m bdd\"", "lemma bdd_all_bdd_lookup: \"\\<lbrakk>bddh (length ws) bdd; bdd_all P bdd\\<rbrakk> \\<Longrightarrow> P (bdd_lookup bdd ws)\"", "lemma bdd_all_bdd_lookup_iff: \"bddh n bdd \\<Longrightarrow> bdd_all P bdd = (\\<forall>ws. length ws = n \\<longrightarrow> P (bdd_lookup bdd ws))\"", "lemma bdd_all_bdd_map:\n  assumes \"bdd_all P bdd\"\n  and \"\\<And>a. P a \\<Longrightarrow> Q (f a)\"\n  shows \"bdd_all Q (bdd_map f bdd)\"", "lemma bddh_bdd_map:\n  shows \"bddh n (bdd_map f bdd) = bddh n bdd\"", "lemma bdd_map_bdd_lookup:\n  assumes \"bddh (length ws) bdd\"\n  shows \"bdd_lookup (bdd_map f bdd) ws = f (bdd_lookup bdd ws)\"", "lemma bddh_binop: \"bddh n (bdd_binop f l r) = (bddh n l \\<and> bddh n r)\"", "lemma bdd_lookup_binop: \"\\<lbrakk>bddh (length bs) l; bddh (length bs) r\\<rbrakk> \\<Longrightarrow>\n  bdd_lookup (bdd_binop f l r) bs = f (bdd_lookup l bs) (bdd_lookup r bs)\"", "lemma bdd_all_bdd_binop:\n  assumes \"bdd_all P bdd\"\n  and \"bdd_all Q bdd'\"\n  and \"\\<And>a b. \\<lbrakk>P a; Q b\\<rbrakk> \\<Longrightarrow> R (f a b)\"\n  shows \"bdd_all R (bdd_binop f bdd bdd')\"", "lemma insert_list_idemp[simp]:\n  \"List.insert x (List.insert x xs) = List.insert x xs\"", "lemma add_leaves_bdd_lookup:\n  \"bddh n b \\<Longrightarrow> (x \\<in> set (add_leaves b xs)) = ((\\<exists>bs. x = bdd_lookup b bs \\<and> is_alph n bs) \\<or> x \\<in> set xs)\"", "lemma add_leaves_bdd_all_eq:\n  \"list_all P (add_leaves tr xs) \\<longleftrightarrow> bdd_all P tr \\<and> list_all P xs\"", "lemmas add_leaves_bdd_all_eq' =\n  add_leaves_bdd_all_eq [where xs=\"[]\", simplified, symmetric]", "lemma add_leaves_mono:\n  \"set xs \\<subseteq> set ys \\<Longrightarrow> set (add_leaves tr xs) \\<subseteq> set (add_leaves tr ys)\"", "lemma add_leaves_binop_subset:\n  \"set (add_leaves (bdd_binop f b b') [f x y. x \\<leftarrow> xs, y \\<leftarrow> ys]) \\<subseteq>\n   (\\<Union>x\\<in>set (add_leaves b xs). \\<Union>y\\<in>set (add_leaves b' ys). {f x y})\" (is \"?A \\<subseteq> ?B\")", "lemmas trans_is_node = trans_is_node", "lemmas steps_is_node = steps_is_node", "lemmas reach_is_node = reach_is_node", "lemmas dfa_trans_is_node = aut_dfa.trans_is_node [OF aut_dfa.intro]", "lemmas dfa_steps_is_node = aut_dfa.steps_is_node [OF aut_dfa.intro]", "lemmas dfa_reach_is_node = aut_dfa.reach_is_node [OF aut_dfa.intro]", "lemma dfa_startnode_is_node: \"wf_dfa A n \\<Longrightarrow> dfa_is_node A 0\"", "lemma fold_map_idx_fst_snd_eq:\n  assumes f: \"\\<And>i c x. fst (f i c x) = (c \\<or> x \\<noteq> snd (f i c x))\"\n  shows \"fst (fold_map_idx f i c xs) = (c \\<or> xs \\<noteq> snd (fold_map_idx f i c xs))\"", "lemma foldl_mono:\n  assumes f: \"\\<And>x y y'. y < y' \\<Longrightarrow> f y x < f y' x\" and y: \"y < y'\"\n  shows \"foldl f y xs < foldl f y' xs\"", "lemma fold_map_idx_count:\n  assumes f: \"\\<And>i c x y. fst (f i c x) = (c \\<or> g y (snd (f i c x)) < (g y x::nat))\"\n  and f': \"\\<And>i c x y. g y (snd (f i c x)) \\<le> g y x\"\n  and g: \"\\<And>x y y'. y < y' \\<Longrightarrow> g y x < g y' x\"\n  shows \"fst (fold_map_idx f i c xs) =\n    (c \\<or> foldl g y (snd (fold_map_idx f i c xs)) < foldl g y xs)\"\n  and \"foldl g y (snd (fold_map_idx f i c xs)) \\<le> foldl g y xs\"", "lemma iter_count:\n  assumes eq: \"(b, T') = iter (bd, as) T\"\n  and b: \"b\"\n  shows \"count_tr T' < count_tr T\"", "lemma fixpt_True[simp]: \"fst (iter M T) \\<Longrightarrow> fixpt M T = fixpt M (snd (iter M T))\"", "lemma fixpt_False[simp]: \"\\<not> (fst (iter M T)) \\<Longrightarrow> fixpt M T = T\"", "lemma fixpt_induct:\n  assumes H: \"\\<And>M T. (fst (iter M T) \\<Longrightarrow> P M (snd (iter M T))) \\<Longrightarrow> P M T\"\n  shows \"P M T\"", "lemma make_tr_len: \"length (make_tr f n i) = n\"", "lemma make_tr_nth: \"j < n \\<Longrightarrow> make_tr f n i ! j = f (i + j)\"", "lemma init_tr_wf: \"wf_tr M (init_tr M)\"", "lemma fold_map_idx_len: \"length (snd (fold_map_idx f i y xs)) = length xs\"", "lemma fold_map_idx_nth: \"j < length xs \\<Longrightarrow>\n  snd (fold_map_idx f i y xs) ! j = snd (f (i + j) (fst (fold_map_idx f i y (take j xs))) (xs ! j))\"", "lemma init_tr_dist_nodes:\n  assumes \"dfa_is_node M q\" and \"p < q\"\n  shows \"tr_lookup (init_tr M) q p = dist_nodes M 0 v p q\"", "lemma dist_nodes_suc:\n  \"dist_nodes M (Suc n) v p q = (\\<exists>bs. is_alph v bs \\<and> dist_nodes M n v (dfa_trans M p bs) (dfa_trans M q bs))\"", "lemma bdd_lookup_append:\n  assumes \"bddh n B\" and \"length bs \\<ge> n\"\n  shows \"bdd_lookup B (bs @ w) = bdd_lookup B bs\"", "lemma bddh_exists: \"\\<exists>n. bddh n B\"", "lemma check_eq_dist_nodes:\n  assumes \"\\<forall>p q. dfa_is_node M q \\<and> p < q \\<longrightarrow> tr_lookup T q p = (\\<exists>n < m. dist_nodes M n v p q)\" and \"m > 0\"\n  and \"bdd_all (dfa_is_node M) l\" and \"bdd_all (dfa_is_node M) r\"\n  shows \"(\\<not> check_eq l r T) = (\\<exists>bs. bddh (length bs) l \\<and> bddh (length bs) r \\<and> (\\<exists>n < m. dist_nodes M n v (bdd_lookup l bs) (bdd_lookup r bs)))\"", "lemma iter_wf: \"wf_tr M T \\<Longrightarrow> wf_tr M (snd (iter M T))\"", "lemma fixpt_wf: \"wf_tr M T \\<Longrightarrow> wf_tr M (fixpt M T)\"", "lemma list_split:\n  assumes \"n \\<le> length bss\"\n  shows \"\\<exists>b bs. bss = b @ bs \\<and> length b = n\"", "lemma iter_dist_nodes:\n  assumes \"wf_tr M T\"\n  and \"wf_dfa M v\"\n  and \"\\<forall>p q. dfa_is_node M q \\<and> p < q \\<longrightarrow> tr_lookup T q p = (\\<exists>n < m. dist_nodes M n v p q)\" and \"m > 0\"\n  and \"dfa_is_node M q\" and \"p < q\"\n  shows \"tr_lookup (snd (iter M T)) q p = (\\<exists>n < Suc m. dist_nodes M n v p q)\"", "lemma fixpt_dist_nodes':\n  assumes \"wf_tr M T\" and \"wf_dfa M v\"\n  and \"\\<forall>p q. dfa_is_node M q \\<and> p < q \\<longrightarrow> tr_lookup T q p = (\\<exists>n < m. dist_nodes M n v p q)\" and \"m > 0\"\n  and \"dfa_is_node M q\" and \"p < q\"\n  shows \"tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)\"", "lemma fixpt_dist_nodes:\n  assumes \"wf_dfa M v\"\n  and \"dfa_is_node M p\" and \"dfa_is_node M q\"\n  shows \"tr_lookup (fixpt M (init_tr M)) p q = (\\<exists>n. dist_nodes M n v p q)\"", "lemma mk_eqcl'_len: \"length (mk_eqcl' xs i j l T) = length xs\"", "lemma mk_eqcl'_bound:\n  assumes \"\\<And>x k. \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk> \\<Longrightarrow> k < l\"\n  and \"x \\<in> set (mk_eqcl' xs i j l T)\" and \"x = Some k\"\n  shows \"k \\<le> l\"", "lemma mk_eqcl'_nth':\n  assumes \"\\<And>x k. \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk> \\<Longrightarrow> k < l\"\n  and \"\\<And>i'. \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + j) i\\<rbrakk> \\<Longrightarrow> xs ! i' = None\"\n  and \"i < j\" and \"j' < length xs\"\n  shows \"(mk_eqcl' xs i j l T ! j' = Some l) = (\\<not> tr_lookup T (j' + j) i)\"", "lemma mk_eqcl'_nth:\n  assumes \"\\<And>i' j' k. \\<lbrakk>i' < length xs; j' < length xs; xs ! i' = Some k\\<rbrakk> \\<Longrightarrow> (xs ! j' = Some k) = (\\<not> tr_lookup T (i' + jj) (j' + jj))\"\n  and \"\\<And>a b c. \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T; \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk> \\<Longrightarrow> \\<not> tr_lookup T a c\"\n  and \"length xs + jj = length T + 1\"\n  and \"\\<And>x k. \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk> \\<Longrightarrow> k < l\"\n  and \"\\<And>i'. \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + jj) ii\\<rbrakk> \\<Longrightarrow> xs ! i' = None\"\n  and \"ii < jj\"\n  and \"i < length xs\" and \"mk_eqcl' xs ii jj l T ! i = Some m\"\n  and \"j < length xs\"\n  shows \"(mk_eqcl' xs ii jj l T ! j = Some m) = (\\<not> tr_lookup T (i + jj) (j + jj))\"", "lemma mk_eqcl'_Some:\n  assumes \"i < length xs\" and \"xs ! i \\<noteq> None\"\n  shows \"mk_eqcl' xs ii j l T ! i = xs ! i\"", "lemma mk_eqcl'_Some2:\n  assumes \"i < length xs\"\n  and \"k < l\"\n  shows \"(mk_eqcl' xs ii j l T ! i = Some k) = (xs ! i = Some k)\"", "lemma mk_eqcl_fst_Some:\n  assumes \"i < length xs\" and \"k < length zs\"\n  shows \"(fst (mk_eqcl xs zs ii T) ! i = k) = (xs ! i = Some k)\"", "lemma mk_eqcl_len_snd:\n  \"length zs \\<le> length (snd (mk_eqcl xs zs i T))\"", "lemma mk_eqcl_len_fst:\n  \"length (fst (mk_eqcl xs zs i T)) = length xs\"", "lemma mk_eqcl_set_snd:\n  assumes \"i \\<notin> set zs\"\n  and \"j > i\"\n  shows \"i \\<notin> set (snd (mk_eqcl xs zs j T))\"", "lemma mk_eqcl_snd_mon:\n  assumes \"\\<And>j1 j2. \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk> \\<Longrightarrow> zs ! j1 < zs ! j2\"\n  and \"\\<And>x. x \\<in> set zs \\<Longrightarrow> x < i\"\n  and \"j1 < j2\" and \"j2 < length (snd (mk_eqcl xs zs i T))\"\n  shows \"snd (mk_eqcl xs zs i T) ! j1 < snd (mk_eqcl xs zs i T) ! j2\"", "lemma mk_eqcl_snd_nth:\n  assumes \"i < length zs\"\n  shows \"snd (mk_eqcl xs zs j T) ! i = zs ! i\"", "lemma mk_eqcl_bound:\n  assumes \"\\<And>x k. \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk> \\<Longrightarrow> k < length zs\"\n  and \"x \\<in> set (fst (mk_eqcl xs zs ii T))\"\n  shows \"x < length (snd (mk_eqcl xs zs ii T))\"", "lemma mk_eqcl_fst_snd:\n  assumes \"\\<And>i. i < length zs \\<Longrightarrow> zs ! i < length xs + ii \\<and> (zs ! i \\<ge> ii \\<longrightarrow> xs ! (zs ! i - ii) = Some i)\"\n  and \"\\<And>j1 j2. \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk> \\<Longrightarrow> zs ! j1 < zs ! j2\"\n  and \"\\<And>z. z \\<in> set zs \\<Longrightarrow> z < ii\"\n  and \"i < length (snd (mk_eqcl xs zs ii T))\"\n  and \"length xs + ii \\<le> length T + 1\"\n  shows \"snd (mk_eqcl xs zs ii T) ! i < length (fst (mk_eqcl xs zs ii T)) + ii \\<and> (snd (mk_eqcl xs zs ii T) ! i \\<ge> ii \\<longrightarrow>  fst (mk_eqcl xs zs ii T) ! (snd (mk_eqcl xs zs ii T) ! i - ii) = i)\"", "lemma mk_eqcl_fst_nth:\n  assumes \"\\<And>i j k. \\<lbrakk>i < length xs; j < length xs; xs ! i = Some k\\<rbrakk> \\<Longrightarrow> (xs ! j = Some k) = (\\<not> tr_lookup T (i + ii) (j + ii))\"\n  and \"\\<And>a b c. \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T; \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk> \\<Longrightarrow> \\<not> tr_lookup T a c\"\n  and \"\\<And>x k. \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk> \\<Longrightarrow> k < length zs\"\n  and \"length xs + ii = length T + 1\"\n  and \"i < length xs\" and \"j < length xs\"\n  shows \"(fst (mk_eqcl xs zs ii T) ! i = fst (mk_eqcl xs zs ii T) ! j) = (\\<not> tr_lookup T (i + ii) (j + ii))\"", "lemma mk_eqcl_fixpt_fst_bound:\n  assumes \"dfa_is_node M i\"\n  shows \"fst (mk_eqcl (replicate (length (fst M)) None) [] 0 (fixpt M (init_tr M))) ! i < length (snd (mk_eqcl (replicate (length (fst M)) None) [] 0 (fixpt M (init_tr M))))\"\n  (is \"fst ?M ! i < length (snd ?M)\")", "lemma mk_eqcl_fixpt_fst_nth:\n  assumes \"wf_dfa M v\"\n  and \"dfa_is_node M p\" and \"dfa_is_node M q\"\n  shows \"(fst (mk_eqcl (replicate (length (fst M)) None) [] 0 (fixpt M (init_tr M))) ! p = fst (mk_eqcl (replicate (length (fst M)) None) [] 0 (fixpt M (init_tr M))) ! q)\n          = eq_nodes M v p q\"\n  (is \"(fst ?M ! p = fst ?M ! q) = eq_nodes M v p q\")", "lemma mk_eqcl_fixpt_fst_snd_nth:\n  assumes \"i < length (snd (mk_eqcl (replicate (length (fst M)) None) [] 0 (fixpt M (init_tr M))))\"\n  and \"wf_dfa M v\"\n  shows \"snd (mk_eqcl (replicate (length (fst M)) None) [] 0 (fixpt M (init_tr M))) ! i < length (fst (mk_eqcl (replicate (length (fst M)) None) [] 0 (fixpt M (init_tr M)))) \\<and>\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0 (fixpt M (init_tr M))) ! (snd (mk_eqcl (replicate (length (fst M)) None) [] 0 (fixpt M (init_tr M))) ! i) = i\"\n  (is \"snd ?M ! i < length (fst ?M) \\<and> fst ?M ! (snd ?M ! i) = i\")", "lemma eq_nodes_dfa_trans:\n  assumes \"eq_nodes M v p q\"\n  and \"is_alph v bs\"\n  shows \"eq_nodes M v (dfa_trans M p bs) (dfa_trans M q bs)\"", "lemma mk_eqcl_fixpt_trans:\n  assumes \"wf_dfa M v\"\n  and \"dfa_is_node M p\"\n  and \"is_alph v bs\"\n  shows \"dfa_trans (min_dfa M) (fst (mk_eqcl (replicate (length (fst M)) None) [] 0 (fixpt M (init_tr M))) ! p) bs = \n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0 (fixpt M (init_tr M))) ! (dfa_trans M p bs)\"\n  (is \"dfa_trans (min_dfa M) (fst ?M ! p) bs = fst ?M ! (dfa_trans M p bs)\")", "lemma mk_eqcl_fixpt_steps:\n  assumes \"wf_dfa M v\"\n  and \"dfa_is_node M p\"\n  and \"list_all (is_alph v) w\"\n  shows \"dfa_steps (min_dfa M) (fst (mk_eqcl (replicate (length (fst M)) None) [] 0 (fixpt M (init_tr M))) ! p) w =\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0 (fixpt M (init_tr M))) ! (dfa_steps M p w)\"\n  (is \"dfa_steps (min_dfa M) (fst ?M ! p) w = fst ?M ! (dfa_steps M p w)\")", "lemma mk_eqcl_fixpt_startnode:\n  assumes \"length (fst M) > 0\"\n  shows \"length (snd (mk_eqcl (replicate (length (fst M)) None) [] 0 (fixpt M (init_tr M)))) > 0 \\<and> \n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0 (fixpt M (init_tr M))) ! 0 = 0 \\<and> snd (mk_eqcl (replicate (length (fst M)) None) [] 0 (fixpt M (init_tr M))) ! 0 = 0\"\n  (is \"length (snd ?M) > 0 \\<and> fst ?M ! 0 = 0 \\<and> snd ?M ! 0 = 0\")", "lemma min_dfa_wf:\n  \"wf_dfa M v \\<Longrightarrow> wf_dfa (min_dfa M) v\"", "lemma min_dfa_accept:\n  assumes \"wf_dfa M v\"\n  and \"list_all (is_alph v) w\"\n  shows \"dfa_accepts (min_dfa M) w = dfa_accepts M w\"", "lemma bv_or_nth:\n  assumes \"length l = length r\"\n  assumes \"i < length l\"\n  shows \"bv_or l r ! i = (l ! i \\<or> r ! i)\"", "lemma bv_or_length:\n  assumes \"length l = length r\"\n  shows \"length (bv_or l r) = length l\"", "lemma bv_or_set_of_bv:\n  assumes \"nfa_is_node A p\" and \"nfa_is_node A q\"\n  shows \"set_of_bv (bv_or p q) = set_of_bv p \\<union> set_of_bv q\"", "lemma bv_or_is_node: \"\\<lbrakk>nfa_is_node A p; nfa_is_node A q\\<rbrakk> \\<Longrightarrow> nfa_is_node A (bv_or p q)\"", "lemma bdd_all_is_node_subsetbdd:\n  assumes \"list_all (bdd_all (nfa_is_node A)) (fst A)\"\n  and \"nfa_is_node A q\"\n  shows \"bdd_all (nfa_is_node A) (subsetbdd (fst A) q (nfa_emptybdd (length q)))\"", "lemma bddh_subsetbdd:\n  assumes \"list_all (bddh l) (fst A)\"\n  and \"bddh l bdd'\"\n  and \"nfa_is_node A q\"\n  shows \"bddh l (subsetbdd (fst A) q bdd')\"", "lemma bdd_lookup_subsetbdd':\n  assumes \"length bdds = length q\"\n  and \"\\<forall>x \\<in> set bdds. bddh (length ws) x\"\n  and \"bddh (length ws) obdd\"\n  and \"\\<And>bs w. \\<lbrakk>bs \\<in> set bdds; length w = length ws\\<rbrakk> \\<Longrightarrow> length (bdd_lookup bs w) = c\"\n  and \"\\<And>w. length w = length ws \\<Longrightarrow> length (bdd_lookup obdd w) = c\"\n  and \"a < c\"\n  shows \"bdd_lookup (subsetbdd bdds q obdd) ws ! a = ((\\<exists>i < length q. q ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or> bdd_lookup obdd ws ! a)\"", "lemma bdd_lookup_subsetbdd:\n  assumes \"wf_nfa N (length ws)\"\n  and \"nfa_is_node N q\"\n  and \"a < length (fst N)\"\n  shows \"bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q))) ws ! a = (\\<exists>i< length q. q ! i \\<and> bdd_lookup (fst N ! i) ws ! a)\"", "lemma nfa_accepting'_set_of_bv: \"nfa_accepting' l r = (set_of_bv l \\<inter> set_of_bv r \\<noteq> {})\"", "lemma nfa_accepting_set_of_bv: \"nfa_accepting A q = (set_of_bv (snd A) \\<inter> set_of_bv q \\<noteq> {})\"", "lemmas trans_is_node = trans_is_node", "lemmas steps_is_node = steps_is_node", "lemmas reach_is_node = reach_is_node", "lemmas nfa_trans_is_node = aut_nfa.trans_is_node [OF aut_nfa.intro]", "lemmas nfa_steps_is_node = aut_nfa.steps_is_node [OF aut_nfa.intro]", "lemmas nfa_reach_is_node = aut_nfa.reach_is_node [OF aut_nfa.intro]", "lemma nfa_startnode_is_node: \"wf_nfa A n \\<Longrightarrow> nfa_is_node A (nfa_startnode A)\"", "lemma negate_wf_dfa: \"wf_dfa (negate_dfa A) l = wf_dfa A l\"", "lemma negate_negate_dfa: \"negate_dfa (negate_dfa A) = A\"", "lemma dfa_accepts_negate: \n  assumes \"wf_dfa A n\"\n  and \"list_all (is_alph n) bss\"\n  shows \"dfa_accepts (negate_dfa A) bss = (\\<not> dfa_accepts A bss)\"", "lemma prod_dfs_eq_rtrancl: \"prod_is_node A B x \\<Longrightarrow> prod_is_node A B y \\<Longrightarrow>\n  prod_memb y (prod_dfs A B x) = ((x, y) \\<in> (succsr (prod_succs A B))\\<^sup>*)\"", "lemma prod_dfs_bij:\n  assumes x: \"prod_is_node A B x\"\n  shows \"(fst (prod_dfs A B x) ! i ! j = Some k \\<and> dfa_is_node A i \\<and> dfa_is_node B j) =\n    (k < length (snd (prod_dfs A B x)) \\<and> (snd (prod_dfs A B x) ! k = (i, j)))\"", "lemma prod_dfs_mono:\n  assumes z: \"prod_invariant A B z\"\n  and xs: \"list_all (prod_is_node A B) xs\"\n  and H: \"fst z ! i ! j = Some k\"\n  shows \"fst (gen_dfs (prod_succs A B) prod_ins prod_memb z xs) ! i ! j = Some k\"", "lemma prod_dfs_start:\n  \"\\<lbrakk>dfa_is_node A i; dfa_is_node B j\\<rbrakk> \\<Longrightarrow> fst (prod_dfs A B (i, j)) ! i ! j = Some 0\"", "lemma prod_dfs_inj:\n  assumes x: \"prod_is_node A B x\" and i1: \"dfa_is_node A i1\" and i2: \"dfa_is_node B i2\"\n  and j1: \"dfa_is_node A j1\" and j2: \"dfa_is_node B j2\"\n  and i: \"fst (prod_dfs A B x) ! i1 ! i2 = Some k\"\n  and j: \"fst (prod_dfs A B x) ! j1 ! j2 = Some k\"\n  shows \"(i1, i2) = (j1, j2)\"", "lemma prod_dfs_statetrans:\n  assumes bs: \"length bs = n\"\n  and i: \"dfa_is_node A i\" and j: \"dfa_is_node B j\"\n  and s1: \"dfa_is_node A s1\" and s2: \"dfa_is_node B s2\"\n  and k: \"fst (prod_dfs A B (s1, s2)) ! i ! j = Some k\"\n  obtains k'\n  where \"fst (prod_dfs A B (s1, s2)) !\n    dfa_trans A i bs ! dfa_trans B j bs = Some k'\"\n  and \"dfa_is_node A (dfa_trans A i bs)\"\n  and \"dfa_is_node B (dfa_trans B j bs)\"\n  and \"k' < length (snd (prod_dfs A B (s1, s2)))\"", "lemma binop_wf_dfa: \"wf_dfa (binop_dfa f A B) n\"", "theorem binop_dfa_reachable:\n  assumes bss: \"list_all (is_alph n) bss\"\n  shows \"(\\<exists>m. dfa_reach (binop_dfa f A B) 0 bss m \\<and>\n    fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some m \\<and>\n    dfa_is_node A s\\<^sub>1 \\<and> dfa_is_node B s\\<^sub>2) =\n   (dfa_reach A 0 bss s\\<^sub>1 \\<and> dfa_reach B 0 bss s\\<^sub>2)\"", "lemma binop_dfa_steps:\n  assumes X: \"list_all (is_alph n) bs\"\n  shows \"snd (binop_dfa f A B) ! dfa_steps (binop_dfa f A B) 0 bs = f (snd A ! dfa_steps A 0 bs) (snd B ! dfa_steps B 0 bs)\"\n  (is \"?as3 ! dfa_steps ?A 0 bs = ?rhs\")", "lemma binop_wf_dfa:\n  assumes A: \"wf_dfa A n\" and B: \"wf_dfa B n\"\n  shows \"wf_dfa (binop_dfa f A B) n\"", "theorem binop_dfa_accepts:\n  assumes A: \"wf_dfa A n\"\n  and B: \"wf_dfa B n\"\n  and X: \"list_all (is_alph n) bss\"\n  shows \"dfa_accepts (binop_dfa f A B) bss = f (dfa_accepts A bss) (dfa_accepts B bss)\"", "lemma and_wf_dfa:\n  assumes \"wf_dfa M n\"\n  and \"wf_dfa N n\"\n  shows \"wf_dfa (and_dfa M N) n\"", "lemma and_dfa_accepts:\n  assumes \"wf_dfa M n\"\n  and \"wf_dfa N n\"\n  and \"list_all (is_alph n) bs\"\n  shows \"dfa_accepts (and_dfa M N) bs = (dfa_accepts M bs \\<and> dfa_accepts N bs)\"", "lemma or_wf_dfa:\n  assumes \"wf_dfa M n\" and \"wf_dfa N n\"\n  shows \"wf_dfa (or_dfa M N) n\"", "lemma or_dfa_accepts:\n  assumes \"wf_dfa M n\" and \"wf_dfa N n\"\n  and \"list_all (is_alph n) bs\"\n  shows \"dfa_accepts (or_dfa M N) bs = (dfa_accepts M bs \\<or> dfa_accepts N bs)\"", "lemma imp_wf_dfa:\n  assumes \"wf_dfa M n\" and \"wf_dfa N n\"\n  shows \"wf_dfa (imp_dfa M N) n\"", "lemma imp_dfa_accepts:\n  assumes \"wf_dfa M n\" and \"wf_dfa N n\"\n  and \"list_all (is_alph n) bs\"\n  shows \"dfa_accepts (imp_dfa M N) bs = (dfa_accepts M bs \\<longrightarrow> dfa_accepts N bs)\"", "lemma dfa2wf_nfa:\n  assumes \"wf_dfa M n\"\n  shows \"wf_nfa (nfa_of_dfa M) n\"", "lemma replicate_upd_inj: \"\\<lbrakk>q < n; (replicate n False)[q:=True] = (replicate n False)[p:=True]\\<rbrakk> \\<Longrightarrow> (q = p)\" (is \"\\<lbrakk>_ ;?lhs = ?rhs\\<rbrakk> \\<Longrightarrow>  _\")", "lemma nfa_of_dfa_reach':\n  assumes V: \"wf_dfa M l\"\n  and X: \"list_all (is_alph l) bss\"\n  and N: \"n1 = (replicate (length (fst M)) False)[q:=True]\"\n  and Q: \"dfa_is_node M q\"\n  and R: \"nfa_reach (nfa_of_dfa M) n1 bss n2\"\n  shows \"\\<exists>p. dfa_reach M q bss p \\<and> n2 = (replicate (length (fst M)) False)[p:=True]\"", "lemma nfa_of_dfa_reach:\n  assumes V: \"wf_dfa M l\"\n  and X: \"list_all (is_alph l) bss\"\n  and N1: \"n1 = (replicate (length (fst M)) False)[q:=True]\"\n  and N2: \"n2 = (replicate (length (fst M)) False)[p:=True]\"\n  and Q: \"dfa_is_node M q\"\n  shows \"nfa_reach (nfa_of_dfa M) n1 bss n2 = dfa_reach M q bss p\"", "lemma nfa_accepting_replicate:\n  assumes \"q < length (fst N)\"\n  and \"length (snd N) = length (fst N)\"\n  shows \"nfa_accepting N ((replicate (length (fst N)) False)[q:=True]) = snd N ! q\"", "lemma nfa_of_dfa_accepts:\n  assumes V: \"wf_dfa A n\"\n  and X: \"list_all (is_alph n) bss\"\n  shows \"nfa_accepts (nfa_of_dfa A) bss = dfa_accepts A bss\"", "lemma bddh_bddinsert:\n  assumes \"bddh x b\"\n  and \"length w \\<ge> x\"\n  shows \"bddh (length w) (bddinsert b w y)\"", "lemma bdd_lookup_bddinsert:\n  assumes \"bddh (length w) bd\"\n  and \"length w = length v\"\n  shows \"bdd_lookup (bddinsert bd w y) v = (if w = v then y else bdd_lookup bd v)\"", "lemma finite_list: \"finite {xs::('a::finite) list. length xs = k}\"", "lemmas dfs_eq_rtrancl[folded subset_dfs_def] = dfs_eq_rtrancl", "lemma  subset_dfs_bij:\n  assumes H1: \"nfa_is_node A q\"\n  and H2: \"nfa_is_node A q0\"\n  shows \"(bdd_lookup (fst (subset_dfs A q0)) q = Some v) = (v < length (snd (subset_dfs A q0)) \\<and> (snd (subset_dfs A q0)) ! v = q)\"", "lemma subset_dfs_start:\n  assumes H: \"nfa_is_node A q0\"\n  shows \"bdd_lookup (fst (subset_dfs A q0)) q0 = Some 0\"", "lemma subset_dfs_is_node:\n  assumes \"nfa_is_node A q0\"\n  shows \"list_all (nfa_is_node A) (snd (subset_dfs A q0))\"", "lemma det_wf_nfa:\n  shows \"wf_dfa (det_nfa A) n\"", "lemma nfa_reach_rtrancl:\n  assumes \"nfa_is_node A i\"\n  shows \"(\\<exists>bss. nfa_reach A i bss j \\<and> list_all (is_alph n) bss) = ((i, j) \\<in> (succsr (subset_succs A))\\<^sup>*)\"", "lemma nfa_reach_subset_memb:\n  assumes R: \"nfa_reach A q0 bss q\"\n  and Q0: \"nfa_is_node A q0\"\n  and X: \"list_all (is_alph n) bss\"\n  shows \"subset_memb q (subset_dfs A q0)\"", "lemma det_nfa_reach':\n  fixes bd :: \"nat option bdd\" and ls :: \"bool list list\"\n  assumes \"subset_dfs A (nfa_startnode A) = (bd, ls)\" (is \"?subset_dfs = _\")\n  and \"\\<exists>bs. nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\"\n  and \"q1 = ls ! i\" and \"q2 = ls ! j\" and \"i < length ls\" and \"j < length ls\"\n  and \"list_all (is_alph n) bss\"\n  shows \"nfa_reach A q1 bss q2 = (dfa_reach (det_nfa A) i bss j \\<and> nfa_is_node A q2)\"\n  (is \"_ = (dfa_reach ?M i bss j \\<and> _)\")", "lemma det_nfa_reach:\n  fixes bd :: \"nat option bdd\" and ls :: \"bool list list\"\n  assumes S: \"subset_dfs A (nfa_startnode A) = (bd, ls)\" (is \"?subset_dfs = _\")\n  and Q1: \"q1 = ls ! j\" and J: \"j < length ls\"\n  and X: \"list_all (is_alph n) bss\"\n  shows \"nfa_reach A (nfa_startnode A) bss q1 = dfa_reach (det_nfa A) 0 bss j\"", "lemma det_nfa_accepts:\n  assumes X: \"list_all (is_alph n) w\"\n  shows \"dfa_accepts (det_nfa A) w = nfa_accepts A w\"", "lemma det_wf_nfa:\n  assumes A: \"wf_nfa A n\"\n  shows \"wf_dfa (det_nfa A) n\"", "lemma det_nfa_accepts:\n  assumes A: \"wf_nfa A n\"\n  and w: \"list_all (is_alph n) bss\"\n  shows \"dfa_accepts (det_nfa A) bss = nfa_accepts A bss\"", "lemma bddh_quantify_bdd:\n  assumes \"bddh (Suc n) bdd\" and \"v \\<le> n\"\n  shows \"bddh n (quantify_bdd v bdd)\"", "lemma quantify_bdd_is_node:\n  assumes \"bdd_all (nfa_is_node N) bdd\"\n  shows \"bdd_all (nfa_is_node N) (quantify_bdd v bdd)\"", "lemma quantify_nfa_well_formed_aut:\n  assumes \"wf_nfa N (Suc n)\"\n  and \"v \\<le> n\"\n  shows \"wf_nfa (quantify_nfa v N) n\"", "lemma insertl_len: \n  \"length (insertl n x vs) = Suc (length vs)\"", "lemma insertl_0_eq: \"insertl 0 x xs = x # xs\"", "lemma bdd_lookup_quantify_bdd_set_of_bv: \n  assumes \"length w = n\"\n  and \"bddh (Suc n) bdd\"\n  and \"bdd_all (nfa_is_node N) bdd\"\n  and \"v \\<le> n\"\n  shows \"set_of_bv (bdd_lookup (quantify_bdd v bdd) w) = (\\<Union>b. set_of_bv (bdd_lookup bdd (insertl v b w)))\"", "lemma subsetbdd_set_of_bv:\n  assumes \"wf_nfa N (length ws)\"\n  and \"nfa_is_node N q\"\n  shows \"set_of_bv (bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q))) ws) = (\\<Union>i\\<in>set_of_bv q. set_of_bv (bdd_lookup (fst N ! i) ws))\"\n  (is \"set_of_bv ?q = _\")", "lemma nfa_trans_quantify_nfa:\n  assumes \"wf_nfa N (Suc n)\"\n  and \"v \\<le> n\"\n  and \"is_alph n w\"\n  and \"nfa_is_node N q\"\n  shows \"set_of_bv (nfa_trans (quantify_nfa v N) q w) = (\\<Union>b. set_of_bv (nfa_trans N q (insertl v b w)))\"", "lemma insertll_len2:\n  assumes \"list_all (is_alph n) vs\"\n  and \"length x = length vs\"\n  shows \"list_all (is_alph (Suc n)) (insertll k x vs)\"", "lemma insertll_append:\n  assumes \"length xs = length vs\"\n  shows \"insertll k (xs @ [x]) (vs @ [v]) = insertll k xs vs @ [insertl k x v]\"", "lemma UN_UN_lenset: \"(\\<Union>b. \\<Union>x\\<in>{x. length x = n}. M b x) = (\\<Union>bs\\<in>{x. length x = Suc n}. M (last bs) (butlast bs))\"", "lemma nfa_steps_quantify_nfa:\n  assumes \"wf_nfa N (Suc n)\"\n  and \"list_all (is_alph n) w\"\n  and \"nfa_is_node N q\"\n  and \"v \\<le> n\"\n  shows \"set_of_bv (nfa_steps (quantify_nfa v N) q w) = (\\<Union>xs \\<in> {x. length x = length w}. set_of_bv (nfa_steps N q (insertll v xs w)))\"", "lemma nfa_accepts_quantify_nfa:\n  assumes \"wf_nfa A (Suc n)\"\n  and \"i \\<le> n\"\n  and \"list_all (is_alph n) bss\"\n  shows \"nfa_accepts (quantify_nfa i A) bss = (\\<exists>bs. nfa_accepts A (insertll i bs bss) \\<and> length bs = length bss)\"", "lemma zeros_is_alpha: \"list_all (is_alph v) (zeros n v)\"", "lemma zeros_rone: \"zeros (Suc n) v = zeros n v @ zeros 1 v\"", "lemma zeros_len: \"length (zeros n v) = n\"", "lemma zeros_rtrancl: \"(\\<exists>n. dfa_reach M x (zeros n v) y) = ((x,y) \\<in> (succsr (rquot_succs M v))\\<^sup>*)\"", "lemma map_index_len:\n  \"length (map_index f ls n) = length ls\"", "lemma map_index_nth:\n  assumes \"i < length l\"\n  shows \"map_index f l n ! i = f (l ! i) (n + i)\"", "lemma rquot_well_formed_aut:\n  assumes \"wf_dfa M n\"\n  shows \"wf_dfa (rquot M n) n\"", "lemma rquot_node:\n  \"dfa_is_node (rquot M n) q = dfa_is_node M q\"", "lemma rquot_steps:\n  \"dfa_steps (rquot M n) x w = dfa_steps M x w\"", "lemma rquot_dfs_invariant:\n  assumes \"dfa_is_node A x\"\n  shows \"rquot_invariant A (rquot_dfs A n x)\"", "lemma dfa_reach_rquot:\n  assumes \"dfa_is_node A x\"\n  and \"dfa_is_node A y\"\n  shows \"rquot_memb y (rquot_dfs A n x) = (\\<exists>m. dfa_reach A x (zeros m n) y)\"", "lemma rquot_accepting:\n  assumes \"dfa_is_node (rquot A n) q\"\n  shows \"dfa_accepting (rquot A n) q = (\\<exists>m. dfa_accepting A (dfa_steps A q (zeros m n)))\"", "lemma rquot_accepts:\n  assumes A: \"wf_dfa A n\"\n  and \"list_all (is_alph n) bss\"\n  shows \"dfa_accepts (rquot A n) bss = (\\<exists>m. dfa_accepts A (bss @ zeros m n))\"", "lemma eval_dioph_mult:\n  \"eval_dioph ks xs * int n = eval_dioph ks (map (\\<lambda>x. x * n) xs)\"", "lemma eval_dioph_add_map:\n  \"eval_dioph ks (map f xs) + eval_dioph ks (map g xs) =\n   eval_dioph ks (map (\\<lambda>x. f x + g x) (xs::nat list))\"", "lemma eval_dioph_div_mult:\n  \"eval_dioph ks (map (\\<lambda>x. x div n) xs) * int n +\n   eval_dioph ks (map (\\<lambda>x. x mod n) xs) = eval_dioph ks xs\"", "lemma eval_dioph_mod:\n  \"eval_dioph ks xs mod int n = eval_dioph ks (map (\\<lambda>x. x mod n) xs) mod int n\"", "lemma eval_dioph_div_mod:\n  \"(eval_dioph ks xs = l) =\n   (eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2 \\<and>\n    eval_dioph ks (map (\\<lambda>x. x div 2) xs) =\n      (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2)\" (is \"?l = ?r\")", "lemma eval_dioph_ineq_div_mod:\n  \"(eval_dioph ks xs \\<le> l) =\n   (eval_dioph ks (map (\\<lambda>x. x div 2) xs) \\<le>\n      (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2)\" (is \"?l = ?r\")", "lemma sum_list_abs_ge_0: \"(0::int) \\<le> sum_list (map abs ks)\"", "lemma zmult_div_aux1:\n  assumes b: \"b \\<noteq> 0\"\n  shows \"(a - a mod b) div b = (a::int) div b\"", "lemma zmult_div_aux2:\n  assumes b: \"b \\<noteq> 0\"\n  shows \"((a::int) - a mod b) mod b = 0\"", "lemma div_abs_eq:\n  assumes mod: \"(a::int) mod b = 0\"\n  and b: \"0 < b\"\n  shows \"\\<bar>a div b\\<bar> = \\<bar>a\\<bar> div b\"", "lemma add_div_trivial: \"0 \\<le> c \\<Longrightarrow> c < b \\<Longrightarrow> ((a::int) * b + c) div b = a\"", "lemma dioph_rhs_bound:\n  \"\\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar> \\<le> max \\<bar>l\\<bar> (\\<Sum>k\\<leftarrow>ks. \\<bar>k\\<bar>)\"", "lemma dioph_rhs_invariant:\n  assumes m: \"\\<bar>m\\<bar> \\<le> max \\<bar>l\\<bar> (\\<Sum>k\\<leftarrow>ks. \\<bar>k\\<bar>)\"\n  shows \"\\<bar>(m - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar> \\<le> max \\<bar>l\\<bar> (\\<Sum>k\\<leftarrow>ks. \\<bar>k\\<bar>)\"", "lemma bounded_int_set_is_finite:\n  assumes S: \"\\<forall>(i::int)\\<in>S. \\<bar>i\\<bar> < j\"\n  shows \"finite S\"", "lemma mk_nat_vecs_bound: \"\\<forall>xs\\<in>set (mk_nat_vecs n). \\<forall>x\\<in>set xs. x < 2\"", "lemma mk_nat_vecs_mod_eq: \"xs \\<in> set (mk_nat_vecs n) \\<Longrightarrow> map (\\<lambda>x. x mod 2) xs = xs\"", "lemma int_encode_bound: \"dioph_is_node ks l m \\<Longrightarrow>\n  int_encode m < nat (2 * max \\<bar>l\\<bar> (\\<Sum>k\\<leftarrow>ks. \\<bar>k\\<bar>) + 1)\"", "lemma nat_of_bool_bound: \"nat_of_bool b < 2\"", "lemma nat_of_bool_mk_nat_vecs:\n  \"length bs = n \\<Longrightarrow> map nat_of_bool bs \\<in> set (mk_nat_vecs n)\"", "lemma bdd_lookup_make_bdd:\n  \"length bs = n \\<Longrightarrow> bdd_lookup (make_bdd f n xs) bs = f (xs @ map nat_of_bool bs)\"", "lemma nats_of_boolss_length:\n  \"list_all (is_alph n) bss \\<Longrightarrow> length (nats_of_boolss n bss) = n\"", "lemma nats_of_boolss_mod2:\n  assumes bs: \"length bs = n\" and bss: \"list_all (is_alph n) bss\"\n  shows \"map (\\<lambda>x. x mod 2) (nats_of_boolss n (bs # bss)) = map nat_of_bool bs\"", "lemma nats_of_boolss_div2:\n  assumes bs: \"length bs = n\" and bss: \"list_all (is_alph n) bss\"\n  shows \"map (\\<lambda>x. x div 2) (nats_of_boolss n (bs # bss)) = nats_of_boolss n bss\"", "lemma zip_insertl: \"length xs = length ys \\<Longrightarrow>\n  zip (insertl n x xs) (insertl n y ys) = insertl n (x, y) (zip xs ys)\"", "lemma map_insertl: \"map f (insertl i x xs) = insertl i (f x) (map f xs)\"", "lemma insertl_replicate: \"m \\<le> n \\<Longrightarrow>\n  insertl m x (replicate n x) = x # replicate n x\"", "lemma nats_of_boolss_insertll:\n  \"list_all (is_alph n) bss \\<Longrightarrow> length bs = length bss \\<Longrightarrow> i \\<le> n \\<Longrightarrow>\n   nats_of_boolss (Suc n) (insertll i bs bss) = insertl i (nat_of_bools bs) (nats_of_boolss n bss)\"", "lemma zip_replicate_map: \"length xs = n \\<Longrightarrow> zip (replicate n x) xs = map (Pair x) xs\"", "lemma zip_replicate_mapr: \"length xs = n \\<Longrightarrow> zip xs (replicate n x) = map (\\<lambda>y. (y, x)) xs\"", "lemma zip_assoc: \"map f (zip xs (zip ys zs)) = map (\\<lambda>((x, y), z). f (x, (y, z))) (zip (zip xs ys) zs)\"", "lemma nats_of_boolss_append:\n  \"list_all (is_alph n) bss \\<Longrightarrow> list_all (is_alph n) bss' \\<Longrightarrow>\n     nats_of_boolss n (bss @ bss') =\n     map (\\<lambda>(x, y). x + 2 ^ length bss * y) (zip (nats_of_boolss n bss) (nats_of_boolss n bss'))\"", "lemma nats_of_boolss_zeros: \"nats_of_boolss n (zeros m n) = replicate n 0\"", "lemma bools_of_nat_length: \"k \\<le> length (bools_of_nat k n)\"", "lemma nat_of_bool_mod_eq: \"nat_of_bool (n mod 2 = 1) = n mod 2\"", "lemma bools_of_nat_inverse: \"nat_of_bools (bools_of_nat k n) = n\"", "lemma eval_dioph_replicate_0: \"eval_dioph ks (replicate n 0) = 0\"", "lemma dioph_dfs_bij:\n  \"(fst (dioph_dfs n ks l) ! int_encode i = Some k \\<and> dioph_is_node ks l i) =\n    (k < length (snd (dioph_dfs n ks l)) \\<and> (snd (dioph_dfs n ks l) ! k = i))\"", "lemma dioph_dfs_mono:\n  assumes z: \"dioph_invariant ks l z\"\n  and xs: \"list_all (dioph_is_node ks l) xs\"\n  and H: \"fst z ! i = Some k\"\n  shows \"fst (gen_dfs (dioph_succs n ks) dioph_ins dioph_memb z xs) ! i = Some k\"", "lemma dioph_dfs_start:\n  \"fst (dioph_dfs n ks l) ! int_encode l = Some 0\"", "lemma eq_dfa_error: \"\\<not> dfa_accepting (eq_dfa n ks l) (dfa_steps (eq_dfa n ks l) (length (snd (dioph_dfs n ks l))) bss)\"", "lemma eq_dfa_accepting:\n  \"(l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>* \\<Longrightarrow> list_all (is_alph n) bss \\<Longrightarrow>\n  dfa_accepting (eq_dfa n ks l) (dfa_steps (eq_dfa n ks l) (the (fst (dioph_dfs n ks l) ! int_encode m)) bss) =\n  (eval_dioph ks (nats_of_boolss n bss) = m)\"", "lemma eq_dfa_accepts:\n  assumes bss: \"list_all (is_alph n) bss\"\n  shows \"dfa_accepts (eq_dfa n ks l) bss = (eval_dioph ks (nats_of_boolss n bss) = l)\"", "lemma bddh_make_bdd: \"bddh n (make_bdd f n xs)\"", "lemma bdd_all_make_bdd: \"bdd_all P (make_bdd f n xs) = (\\<forall>ys\\<in>set (mk_nat_vecs n). P (f (xs @ ys)))\"", "lemma eq_wf_dfa: \"wf_dfa (eq_dfa n ks l) n\"", "lemma dioph_ineq_dfs_bij:\n  \"(fst (dioph_ineq_dfs n ks l) ! int_encode i = Some k \\<and> dioph_is_node ks l i) =\n    (k < length (snd (dioph_ineq_dfs n ks l)) \\<and> (snd (dioph_ineq_dfs n ks l) ! k = i))\"", "lemma dioph_ineq_dfs_mono:\n  assumes z: \"dioph_invariant ks l z\"\n  and xs: \"list_all (dioph_is_node ks l) xs\"\n  and H: \"fst z ! i = Some k\"\n  shows \"fst (gen_dfs (dioph_ineq_succs n ks) dioph_ins dioph_memb z xs) ! i = Some k\"", "lemma dioph_ineq_dfs_start:\n  \"fst (dioph_ineq_dfs n ks l) ! int_encode l = Some 0\"", "lemma ineq_dfa_accepting:\n  \"(l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>* \\<Longrightarrow> list_all (is_alph n) bss \\<Longrightarrow>\n  dfa_accepting (ineq_dfa n ks l) (dfa_steps (ineq_dfa n ks l) (the (fst (dioph_ineq_dfs n ks l) ! int_encode m)) bss) =\n  (eval_dioph ks (nats_of_boolss n bss) \\<le> m)\"", "lemma ineq_dfa_accepts:\n  assumes bss: \"list_all (is_alph n) bss\"\n  shows \"dfa_accepts (ineq_dfa n ks l) bss = (eval_dioph ks (nats_of_boolss n bss) \\<le> l)\"", "lemma ineq_wf_dfa: \"wf_dfa (ineq_dfa n ks l) n\"", "lemmas dfa_of_pf_induct =\n  dfa_of_pf.induct [case_names Eq Le And Or Imp Exist Forall Neg]", "lemma dfa_of_pf_well_formed: \"wf_dfa (dfa_of_pf n p) n\"", "lemma dfa_of_pf_correctness:\n  \"list_all (is_alph n) bss \\<Longrightarrow>\n     dfa_accepts (dfa_of_pf n p) bss = eval_pf p (nats_of_boolss n bss)\"", "lemmas dfa_of_pf'_induct =\n  dfa_of_pf'.induct [case_names Eq Le And Or Imp Exist Forall Neg]", "lemma dfa_of_pf'_well_formed: \"wf_dfa (dfa_of_pf' n p) n\"", "lemma dfa_of_pf'_correctness:\n  \"list_all (is_alph n) bss \\<Longrightarrow>\n     dfa_accepts (dfa_of_pf' n p) bss = eval_pf p (nats_of_boolss n bss)\""], "translations": [["", "lemma reach_nil: \"reach tr p [] p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach tr p [] p", "by (simp add: reach_def)"], ["", "lemma reach_snoc: \"reach tr p bs q \\<Longrightarrow> reach tr p (bs @ [b]) (tr q b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach tr p bs q \\<Longrightarrow> reach tr p (bs @ [b]) (tr q b)", "by (simp add: reach_def)"], ["", "lemma reach_nil_iff: \"reach tr p [] q = (p = q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach tr p [] q = (p = q)", "by (auto simp add: reach_def)"], ["", "lemma reach_snoc_iff: \"reach tr p (bs @ [b]) k = (\\<exists>q. reach tr p bs q \\<and> k = tr q b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach tr p (bs @ [b]) k =\n    (\\<exists>q. reach tr p bs q \\<and> k = tr q b)", "by (auto simp add: reach_def)"], ["", "lemma reach_induct [consumes 1, case_names Nil snoc, induct set: reach]:\n  assumes \"reach tr p w q\"\n  and \"P [] p\"\n  and  \"\\<And>k x y. \\<lbrakk>reach tr p x k; P x k\\<rbrakk> \\<Longrightarrow> P (x @ [y]) (tr k y)\"\n  shows \"P w q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P w q", "using assms"], ["proof (prove)\nusing this:\n  reach tr p w q\n  P [] p\n  \\<lbrakk>reach tr p ?x ?k; P ?x ?k\\<rbrakk>\n  \\<Longrightarrow> P (?x @ [?y]) (tr ?k ?y)\n\ngoal (1 subgoal):\n 1. P w q", "by (induct w arbitrary: q rule: rev_induct) (simp add: reach_def)+"], ["", "lemma reach_trans: \"\\<lbrakk>reach tr p a r; reach tr r b q\\<rbrakk> \\<Longrightarrow> reach tr p (a @ b) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reach tr p a r; reach tr r b q\\<rbrakk>\n    \\<Longrightarrow> reach tr p (a @ b) q", "by (simp add: reach_def)"], ["", "lemma reach_inj: \"\\<lbrakk>reach tr p a q; reach tr p a q'\\<rbrakk> \\<Longrightarrow> q = q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reach tr p a q; reach tr p a q'\\<rbrakk>\n    \\<Longrightarrow> q = q'", "by (simp add: reach_def)"], ["", "definition\n  \"accepts tr P s as = P (foldl tr s as)\""], ["", "locale Automaton =\n  fixes trans :: \"'a \\<Rightarrow> 'b \\<Rightarrow> 'a\"\n  and is_node :: \"'a \\<Rightarrow> bool\"\n  and is_alpha :: \"'b \\<Rightarrow> bool\"\n  assumes trans_is_node: \"\\<And>q a. \\<lbrakk>is_node q; is_alpha a\\<rbrakk> \\<Longrightarrow> is_node (trans q a)\"\nbegin"], ["", "lemma steps_is_node:\n  assumes \"is_node q\"\n  and \"list_all is_alpha w\"\n  shows \"is_node (foldl trans q w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_node (foldl trans q w)", "using assms"], ["proof (prove)\nusing this:\n  is_node q\n  list_all is_alpha w\n\ngoal (1 subgoal):\n 1. is_node (foldl trans q w)", "by (induct w arbitrary: q) (simp add: trans_is_node)+"], ["", "lemma reach_is_node: \"\\<lbrakk>reach trans p w q; is_node p; list_all is_alpha w\\<rbrakk> \\<Longrightarrow> is_node q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reach trans p w q; is_node p; list_all is_alpha w\\<rbrakk>\n    \\<Longrightarrow> is_node q", "by (simp add: steps_is_node reach_def)"], ["", "end"], ["", "section \\<open>BDDs\\<close>"], ["", "definition\n  is_alph :: \"nat \\<Rightarrow> bool list \\<Rightarrow> bool\" where\n  \"is_alph n = (\\<lambda>w. length w = n)\""], ["", "datatype 'a bdd = Leaf 'a | Branch \"'a bdd\" \"'a bdd\" for map: bdd_map"], ["", "primrec bddh :: \"nat \\<Rightarrow> 'a bdd \\<Rightarrow> bool\"\nwhere\n  \"bddh n (Leaf x) = True\"\n| \"bddh n (Branch l r) = (case n of 0 \\<Rightarrow> False | Suc m \\<Rightarrow> bddh m l \\<and> bddh m r)\""], ["", "lemma bddh_ge:\n  assumes \"m \\<ge> n\"\n  assumes \"bddh n bdd\"\n  shows \"bddh m bdd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bddh m bdd", "using assms"], ["proof (prove)\nusing this:\n  n \\<le> m\n  bddh n bdd\n\ngoal (1 subgoal):\n 1. bddh m bdd", "proof (induct bdd arbitrary: n m)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x n m.\n       \\<lbrakk>n \\<le> m; bddh n (Leaf x)\\<rbrakk>\n       \\<Longrightarrow> bddh m (Leaf x)\n 2. \\<And>bdd1 bdd2 n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>n \\<le> m; bddh n bdd1\\<rbrakk>\n                   \\<Longrightarrow> bddh m bdd1;\n        \\<And>n m.\n           \\<lbrakk>n \\<le> m; bddh n bdd2\\<rbrakk>\n           \\<Longrightarrow> bddh m bdd2;\n        n \\<le> m; bddh n (Branch bdd1 bdd2)\\<rbrakk>\n       \\<Longrightarrow> bddh m (Branch bdd1 bdd2)", "case (Branch l r)"], ["proof (state)\nthis:\n  \\<lbrakk>?n \\<le> ?m; bddh ?n l\\<rbrakk> \\<Longrightarrow> bddh ?m l\n  \\<lbrakk>?n \\<le> ?m; bddh ?n r\\<rbrakk> \\<Longrightarrow> bddh ?m r\n  n \\<le> m\n  bddh n (Branch l r)\n\ngoal (2 subgoals):\n 1. \\<And>x n m.\n       \\<lbrakk>n \\<le> m; bddh n (Leaf x)\\<rbrakk>\n       \\<Longrightarrow> bddh m (Leaf x)\n 2. \\<And>bdd1 bdd2 n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>n \\<le> m; bddh n bdd1\\<rbrakk>\n                   \\<Longrightarrow> bddh m bdd1;\n        \\<And>n m.\n           \\<lbrakk>n \\<le> m; bddh n bdd2\\<rbrakk>\n           \\<Longrightarrow> bddh m bdd2;\n        n \\<le> m; bddh n (Branch bdd1 bdd2)\\<rbrakk>\n       \\<Longrightarrow> bddh m (Branch bdd1 bdd2)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?n \\<le> ?m; bddh ?n l\\<rbrakk> \\<Longrightarrow> bddh ?m l\n  \\<lbrakk>?n \\<le> ?m; bddh ?n r\\<rbrakk> \\<Longrightarrow> bddh ?m r\n  n \\<le> m\n  bddh n (Branch l r)", "obtain v where V: \"n = Suc v\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?n \\<le> ?m; bddh ?n l\\<rbrakk> \\<Longrightarrow> bddh ?m l\n  \\<lbrakk>?n \\<le> ?m; bddh ?n r\\<rbrakk> \\<Longrightarrow> bddh ?m r\n  n \\<le> m\n  bddh n (Branch l r)\n\ngoal (1 subgoal):\n 1. (\\<And>v. n = Suc v \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases n) simp+"], ["proof (state)\nthis:\n  n = Suc v\n\ngoal (2 subgoals):\n 1. \\<And>x n m.\n       \\<lbrakk>n \\<le> m; bddh n (Leaf x)\\<rbrakk>\n       \\<Longrightarrow> bddh m (Leaf x)\n 2. \\<And>bdd1 bdd2 n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>n \\<le> m; bddh n bdd1\\<rbrakk>\n                   \\<Longrightarrow> bddh m bdd1;\n        \\<And>n m.\n           \\<lbrakk>n \\<le> m; bddh n bdd2\\<rbrakk>\n           \\<Longrightarrow> bddh m bdd2;\n        n \\<le> m; bddh n (Branch bdd1 bdd2)\\<rbrakk>\n       \\<Longrightarrow> bddh m (Branch bdd1 bdd2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. bddh m (Branch l r)", "proof (cases \"n = m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = m \\<Longrightarrow> bddh m (Branch l r)\n 2. n \\<noteq> m \\<Longrightarrow> bddh m (Branch l r)", "case True"], ["proof (state)\nthis:\n  n = m\n\ngoal (2 subgoals):\n 1. n = m \\<Longrightarrow> bddh m (Branch l r)\n 2. n \\<noteq> m \\<Longrightarrow> bddh m (Branch l r)", "with Branch"], ["proof (chain)\npicking this:\n  \\<lbrakk>?n \\<le> ?m; bddh ?n l\\<rbrakk> \\<Longrightarrow> bddh ?m l\n  \\<lbrakk>?n \\<le> ?m; bddh ?n r\\<rbrakk> \\<Longrightarrow> bddh ?m r\n  n \\<le> m\n  bddh n (Branch l r)\n  n = m", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?n \\<le> ?m; bddh ?n l\\<rbrakk> \\<Longrightarrow> bddh ?m l\n  \\<lbrakk>?n \\<le> ?m; bddh ?n r\\<rbrakk> \\<Longrightarrow> bddh ?m r\n  n \\<le> m\n  bddh n (Branch l r)\n  n = m\n\ngoal (1 subgoal):\n 1. bddh m (Branch l r)", "by simp"], ["proof (state)\nthis:\n  bddh m (Branch l r)\n\ngoal (1 subgoal):\n 1. n \\<noteq> m \\<Longrightarrow> bddh m (Branch l r)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> m \\<Longrightarrow> bddh m (Branch l r)", "case False"], ["proof (state)\nthis:\n  n \\<noteq> m\n\ngoal (1 subgoal):\n 1. n \\<noteq> m \\<Longrightarrow> bddh m (Branch l r)", "with Branch"], ["proof (chain)\npicking this:\n  \\<lbrakk>?n \\<le> ?m; bddh ?n l\\<rbrakk> \\<Longrightarrow> bddh ?m l\n  \\<lbrakk>?n \\<le> ?m; bddh ?n r\\<rbrakk> \\<Longrightarrow> bddh ?m r\n  n \\<le> m\n  bddh n (Branch l r)\n  n \\<noteq> m", "have \"\\<exists>w. m = Suc w \\<and> n \\<le> w\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?n \\<le> ?m; bddh ?n l\\<rbrakk> \\<Longrightarrow> bddh ?m l\n  \\<lbrakk>?n \\<le> ?m; bddh ?n r\\<rbrakk> \\<Longrightarrow> bddh ?m r\n  n \\<le> m\n  bddh n (Branch l r)\n  n \\<noteq> m\n\ngoal (1 subgoal):\n 1. \\<exists>w. m = Suc w \\<and> n \\<le> w", "by (cases m) simp+"], ["proof (state)\nthis:\n  \\<exists>w. m = Suc w \\<and> n \\<le> w\n\ngoal (1 subgoal):\n 1. n \\<noteq> m \\<Longrightarrow> bddh m (Branch l r)", "then"], ["proof (chain)\npicking this:\n  \\<exists>w. m = Suc w \\<and> n \\<le> w", "obtain w where W: \"m = Suc w \\<and> n \\<le> w\""], ["proof (prove)\nusing this:\n  \\<exists>w. m = Suc w \\<and> n \\<le> w\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        m = Suc w \\<and> n \\<le> w \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  m = Suc w \\<and> n \\<le> w\n\ngoal (1 subgoal):\n 1. n \\<noteq> m \\<Longrightarrow> bddh m (Branch l r)", "with Branch V"], ["proof (chain)\npicking this:\n  \\<lbrakk>?n \\<le> ?m; bddh ?n l\\<rbrakk> \\<Longrightarrow> bddh ?m l\n  \\<lbrakk>?n \\<le> ?m; bddh ?n r\\<rbrakk> \\<Longrightarrow> bddh ?m r\n  n \\<le> m\n  bddh n (Branch l r)\n  n = Suc v\n  m = Suc w \\<and> n \\<le> w", "have \"v \\<le> w \\<and> bddh v l \\<and> bddh v r\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?n \\<le> ?m; bddh ?n l\\<rbrakk> \\<Longrightarrow> bddh ?m l\n  \\<lbrakk>?n \\<le> ?m; bddh ?n r\\<rbrakk> \\<Longrightarrow> bddh ?m r\n  n \\<le> m\n  bddh n (Branch l r)\n  n = Suc v\n  m = Suc w \\<and> n \\<le> w\n\ngoal (1 subgoal):\n 1. v \\<le> w \\<and> bddh v l \\<and> bddh v r", "by simp"], ["proof (state)\nthis:\n  v \\<le> w \\<and> bddh v l \\<and> bddh v r\n\ngoal (1 subgoal):\n 1. n \\<noteq> m \\<Longrightarrow> bddh m (Branch l r)", "with Branch"], ["proof (chain)\npicking this:\n  \\<lbrakk>?n \\<le> ?m; bddh ?n l\\<rbrakk> \\<Longrightarrow> bddh ?m l\n  \\<lbrakk>?n \\<le> ?m; bddh ?n r\\<rbrakk> \\<Longrightarrow> bddh ?m r\n  n \\<le> m\n  bddh n (Branch l r)\n  v \\<le> w \\<and> bddh v l \\<and> bddh v r", "have \"bddh w l \\<and> bddh w r\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?n \\<le> ?m; bddh ?n l\\<rbrakk> \\<Longrightarrow> bddh ?m l\n  \\<lbrakk>?n \\<le> ?m; bddh ?n r\\<rbrakk> \\<Longrightarrow> bddh ?m r\n  n \\<le> m\n  bddh n (Branch l r)\n  v \\<le> w \\<and> bddh v l \\<and> bddh v r\n\ngoal (1 subgoal):\n 1. bddh w l \\<and> bddh w r", "by blast"], ["proof (state)\nthis:\n  bddh w l \\<and> bddh w r\n\ngoal (1 subgoal):\n 1. n \\<noteq> m \\<Longrightarrow> bddh m (Branch l r)", "with W"], ["proof (chain)\npicking this:\n  m = Suc w \\<and> n \\<le> w\n  bddh w l \\<and> bddh w r", "show ?thesis"], ["proof (prove)\nusing this:\n  m = Suc w \\<and> n \\<le> w\n  bddh w l \\<and> bddh w r\n\ngoal (1 subgoal):\n 1. bddh m (Branch l r)", "by simp"], ["proof (state)\nthis:\n  bddh m (Branch l r)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bddh m (Branch l r)\n\ngoal (1 subgoal):\n 1. \\<And>x n m.\n       \\<lbrakk>n \\<le> m; bddh n (Leaf x)\\<rbrakk>\n       \\<Longrightarrow> bddh m (Leaf x)", "qed simp"], ["", "abbreviation \"bdd_all \\<equiv> pred_bdd\""], ["", "fun bdd_lookup :: \"'a bdd \\<Rightarrow> bool list \\<Rightarrow> 'a\"\nwhere\n  \"bdd_lookup (Leaf x) bs = x\"\n| \"bdd_lookup (Branch l r) (b#bs) = bdd_lookup (if b then r else l) bs\""], ["", "lemma bdd_all_bdd_lookup: \"\\<lbrakk>bddh (length ws) bdd; bdd_all P bdd\\<rbrakk> \\<Longrightarrow> P (bdd_lookup bdd ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bddh (length ws) bdd; bdd_all P bdd\\<rbrakk>\n    \\<Longrightarrow> P (bdd_lookup bdd ws)", "by (induct bdd ws rule: bdd_lookup.induct) simp+"], ["", "lemma bdd_all_bdd_lookup_iff: \"bddh n bdd \\<Longrightarrow> bdd_all P bdd = (\\<forall>ws. length ws = n \\<longrightarrow> P (bdd_lookup bdd ws))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bddh n bdd \\<Longrightarrow>\n    bdd_all P bdd =\n    (\\<forall>ws. length ws = n \\<longrightarrow> P (bdd_lookup bdd ws))", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>bddh n bdd; bdd_all P bdd\\<rbrakk>\n    \\<Longrightarrow> \\<forall>ws.\n                         length ws = n \\<longrightarrow>\n                         P (bdd_lookup bdd ws)\n 2. \\<lbrakk>bddh n bdd;\n     \\<forall>ws.\n        length ws = n \\<longrightarrow> P (bdd_lookup bdd ws)\\<rbrakk>\n    \\<Longrightarrow> bdd_all P bdd", "apply (simp add: bdd_all_bdd_lookup)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bddh n bdd;\n     \\<forall>ws.\n        length ws = n \\<longrightarrow> P (bdd_lookup bdd ws)\\<rbrakk>\n    \\<Longrightarrow> bdd_all P bdd", "proof (induct bdd arbitrary: n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x n.\n       \\<lbrakk>bddh n (Leaf x);\n        \\<forall>ws.\n           length ws = n \\<longrightarrow>\n           P (bdd_lookup (Leaf x) ws)\\<rbrakk>\n       \\<Longrightarrow> bdd_all P (Leaf x)\n 2. \\<And>bdd1 bdd2 n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>bddh n bdd1;\n                    \\<forall>ws.\n                       length ws = n \\<longrightarrow>\n                       P (bdd_lookup bdd1 ws)\\<rbrakk>\n                   \\<Longrightarrow> bdd_all P bdd1;\n        \\<And>n.\n           \\<lbrakk>bddh n bdd2;\n            \\<forall>ws.\n               length ws = n \\<longrightarrow>\n               P (bdd_lookup bdd2 ws)\\<rbrakk>\n           \\<Longrightarrow> bdd_all P bdd2;\n        bddh n (Branch bdd1 bdd2);\n        \\<forall>ws.\n           length ws = n \\<longrightarrow>\n           P (bdd_lookup (Branch bdd1 bdd2) ws)\\<rbrakk>\n       \\<Longrightarrow> bdd_all P (Branch bdd1 bdd2)", "case Leaf"], ["proof (state)\nthis:\n  bddh n (Leaf x_)\n  \\<forall>ws. length ws = n \\<longrightarrow> P (bdd_lookup (Leaf x_) ws)\n\ngoal (2 subgoals):\n 1. \\<And>x n.\n       \\<lbrakk>bddh n (Leaf x);\n        \\<forall>ws.\n           length ws = n \\<longrightarrow>\n           P (bdd_lookup (Leaf x) ws)\\<rbrakk>\n       \\<Longrightarrow> bdd_all P (Leaf x)\n 2. \\<And>bdd1 bdd2 n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>bddh n bdd1;\n                    \\<forall>ws.\n                       length ws = n \\<longrightarrow>\n                       P (bdd_lookup bdd1 ws)\\<rbrakk>\n                   \\<Longrightarrow> bdd_all P bdd1;\n        \\<And>n.\n           \\<lbrakk>bddh n bdd2;\n            \\<forall>ws.\n               length ws = n \\<longrightarrow>\n               P (bdd_lookup bdd2 ws)\\<rbrakk>\n           \\<Longrightarrow> bdd_all P bdd2;\n        bddh n (Branch bdd1 bdd2);\n        \\<forall>ws.\n           length ws = n \\<longrightarrow>\n           P (bdd_lookup (Branch bdd1 bdd2) ws)\\<rbrakk>\n       \\<Longrightarrow> bdd_all P (Branch bdd1 bdd2)", "thus ?case"], ["proof (prove)\nusing this:\n  bddh n (Leaf x_)\n  \\<forall>ws. length ws = n \\<longrightarrow> P (bdd_lookup (Leaf x_) ws)\n\ngoal (1 subgoal):\n 1. bdd_all P (Leaf x_)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>ws. length ws = n) \\<longrightarrow> P x_ \\<Longrightarrow>\n    P x_", "apply (erule mp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ws. length ws = n", "apply (rule_tac x=\"replicate n False\" in exI, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  bdd_all P (Leaf x_)\n\ngoal (1 subgoal):\n 1. \\<And>bdd1 bdd2 n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>bddh n bdd1;\n                    \\<forall>ws.\n                       length ws = n \\<longrightarrow>\n                       P (bdd_lookup bdd1 ws)\\<rbrakk>\n                   \\<Longrightarrow> bdd_all P bdd1;\n        \\<And>n.\n           \\<lbrakk>bddh n bdd2;\n            \\<forall>ws.\n               length ws = n \\<longrightarrow>\n               P (bdd_lookup bdd2 ws)\\<rbrakk>\n           \\<Longrightarrow> bdd_all P bdd2;\n        bddh n (Branch bdd1 bdd2);\n        \\<forall>ws.\n           length ws = n \\<longrightarrow>\n           P (bdd_lookup (Branch bdd1 bdd2) ws)\\<rbrakk>\n       \\<Longrightarrow> bdd_all P (Branch bdd1 bdd2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bdd1 bdd2 n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>bddh n bdd1;\n                    \\<forall>ws.\n                       length ws = n \\<longrightarrow>\n                       P (bdd_lookup bdd1 ws)\\<rbrakk>\n                   \\<Longrightarrow> bdd_all P bdd1;\n        \\<And>n.\n           \\<lbrakk>bddh n bdd2;\n            \\<forall>ws.\n               length ws = n \\<longrightarrow>\n               P (bdd_lookup bdd2 ws)\\<rbrakk>\n           \\<Longrightarrow> bdd_all P bdd2;\n        bddh n (Branch bdd1 bdd2);\n        \\<forall>ws.\n           length ws = n \\<longrightarrow>\n           P (bdd_lookup (Branch bdd1 bdd2) ws)\\<rbrakk>\n       \\<Longrightarrow> bdd_all P (Branch bdd1 bdd2)", "case (Branch l r n)"], ["proof (state)\nthis:\n  \\<lbrakk>bddh ?n l;\n   \\<forall>ws.\n      length ws = ?n \\<longrightarrow> P (bdd_lookup l ws)\\<rbrakk>\n  \\<Longrightarrow> bdd_all P l\n  \\<lbrakk>bddh ?n r;\n   \\<forall>ws.\n      length ws = ?n \\<longrightarrow> P (bdd_lookup r ws)\\<rbrakk>\n  \\<Longrightarrow> bdd_all P r\n  bddh n (Branch l r)\n  \\<forall>ws.\n     length ws = n \\<longrightarrow> P (bdd_lookup (Branch l r) ws)\n\ngoal (1 subgoal):\n 1. \\<And>bdd1 bdd2 n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>bddh n bdd1;\n                    \\<forall>ws.\n                       length ws = n \\<longrightarrow>\n                       P (bdd_lookup bdd1 ws)\\<rbrakk>\n                   \\<Longrightarrow> bdd_all P bdd1;\n        \\<And>n.\n           \\<lbrakk>bddh n bdd2;\n            \\<forall>ws.\n               length ws = n \\<longrightarrow>\n               P (bdd_lookup bdd2 ws)\\<rbrakk>\n           \\<Longrightarrow> bdd_all P bdd2;\n        bddh n (Branch bdd1 bdd2);\n        \\<forall>ws.\n           length ws = n \\<longrightarrow>\n           P (bdd_lookup (Branch bdd1 bdd2) ws)\\<rbrakk>\n       \\<Longrightarrow> bdd_all P (Branch bdd1 bdd2)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>bddh ?n l;\n   \\<forall>ws.\n      length ws = ?n \\<longrightarrow> P (bdd_lookup l ws)\\<rbrakk>\n  \\<Longrightarrow> bdd_all P l\n  \\<lbrakk>bddh ?n r;\n   \\<forall>ws.\n      length ws = ?n \\<longrightarrow> P (bdd_lookup r ws)\\<rbrakk>\n  \\<Longrightarrow> bdd_all P r\n  bddh n (Branch l r)\n  \\<forall>ws.\n     length ws = n \\<longrightarrow> P (bdd_lookup (Branch l r) ws)", "obtain k where k: \"n = Suc k\""], ["proof (prove)\nusing this:\n  \\<lbrakk>bddh ?n l;\n   \\<forall>ws.\n      length ws = ?n \\<longrightarrow> P (bdd_lookup l ws)\\<rbrakk>\n  \\<Longrightarrow> bdd_all P l\n  \\<lbrakk>bddh ?n r;\n   \\<forall>ws.\n      length ws = ?n \\<longrightarrow> P (bdd_lookup r ws)\\<rbrakk>\n  \\<Longrightarrow> bdd_all P r\n  bddh n (Branch l r)\n  \\<forall>ws.\n     length ws = n \\<longrightarrow> P (bdd_lookup (Branch l r) ws)\n\ngoal (1 subgoal):\n 1. (\\<And>k. n = Suc k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases n) simp+"], ["proof (state)\nthis:\n  n = Suc k\n\ngoal (1 subgoal):\n 1. \\<And>bdd1 bdd2 n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>bddh n bdd1;\n                    \\<forall>ws.\n                       length ws = n \\<longrightarrow>\n                       P (bdd_lookup bdd1 ws)\\<rbrakk>\n                   \\<Longrightarrow> bdd_all P bdd1;\n        \\<And>n.\n           \\<lbrakk>bddh n bdd2;\n            \\<forall>ws.\n               length ws = n \\<longrightarrow>\n               P (bdd_lookup bdd2 ws)\\<rbrakk>\n           \\<Longrightarrow> bdd_all P bdd2;\n        bddh n (Branch bdd1 bdd2);\n        \\<forall>ws.\n           length ws = n \\<longrightarrow>\n           P (bdd_lookup (Branch bdd1 bdd2) ws)\\<rbrakk>\n       \\<Longrightarrow> bdd_all P (Branch bdd1 bdd2)", "from Branch"], ["proof (chain)\npicking this:\n  \\<lbrakk>bddh ?n l;\n   \\<forall>ws.\n      length ws = ?n \\<longrightarrow> P (bdd_lookup l ws)\\<rbrakk>\n  \\<Longrightarrow> bdd_all P l\n  \\<lbrakk>bddh ?n r;\n   \\<forall>ws.\n      length ws = ?n \\<longrightarrow> P (bdd_lookup r ws)\\<rbrakk>\n  \\<Longrightarrow> bdd_all P r\n  bddh n (Branch l r)\n  \\<forall>ws.\n     length ws = n \\<longrightarrow> P (bdd_lookup (Branch l r) ws)", "have R: \"\\<And>ws. length ws = n \\<Longrightarrow> P (bdd_lookup (Branch l r) ws)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>bddh ?n l;\n   \\<forall>ws.\n      length ws = ?n \\<longrightarrow> P (bdd_lookup l ws)\\<rbrakk>\n  \\<Longrightarrow> bdd_all P l\n  \\<lbrakk>bddh ?n r;\n   \\<forall>ws.\n      length ws = ?n \\<longrightarrow> P (bdd_lookup r ws)\\<rbrakk>\n  \\<Longrightarrow> bdd_all P r\n  bddh n (Branch l r)\n  \\<forall>ws.\n     length ws = n \\<longrightarrow> P (bdd_lookup (Branch l r) ws)\n\ngoal (1 subgoal):\n 1. \\<And>ws. length ws = n \\<Longrightarrow> P (bdd_lookup (Branch l r) ws)", "by simp"], ["proof (state)\nthis:\n  length ?ws = n \\<Longrightarrow> P (bdd_lookup (Branch l r) ?ws)\n\ngoal (1 subgoal):\n 1. \\<And>bdd1 bdd2 n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>bddh n bdd1;\n                    \\<forall>ws.\n                       length ws = n \\<longrightarrow>\n                       P (bdd_lookup bdd1 ws)\\<rbrakk>\n                   \\<Longrightarrow> bdd_all P bdd1;\n        \\<And>n.\n           \\<lbrakk>bddh n bdd2;\n            \\<forall>ws.\n               length ws = n \\<longrightarrow>\n               P (bdd_lookup bdd2 ws)\\<rbrakk>\n           \\<Longrightarrow> bdd_all P bdd2;\n        bddh n (Branch bdd1 bdd2);\n        \\<forall>ws.\n           length ws = n \\<longrightarrow>\n           P (bdd_lookup (Branch bdd1 bdd2) ws)\\<rbrakk>\n       \\<Longrightarrow> bdd_all P (Branch bdd1 bdd2)", "have \"\\<And>ws. length ws = k \\<Longrightarrow> P (bdd_lookup l ws) \\<and> P (bdd_lookup r ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ws.\n       length ws = k \\<Longrightarrow>\n       P (bdd_lookup l ws) \\<and> P (bdd_lookup r ws)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ws.\n       length ws = k \\<Longrightarrow>\n       P (bdd_lookup l ws) \\<and> P (bdd_lookup r ws)", "fix ws :: \"bool list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ws.\n       length ws = k \\<Longrightarrow>\n       P (bdd_lookup l ws) \\<and> P (bdd_lookup r ws)", "assume H: \"length ws = k\""], ["proof (state)\nthis:\n  length ws = k\n\ngoal (1 subgoal):\n 1. \\<And>ws.\n       length ws = k \\<Longrightarrow>\n       P (bdd_lookup l ws) \\<and> P (bdd_lookup r ws)", "with k"], ["proof (chain)\npicking this:\n  n = Suc k\n  length ws = k", "have \"length (False#ws) = n\""], ["proof (prove)\nusing this:\n  n = Suc k\n  length ws = k\n\ngoal (1 subgoal):\n 1. length (False # ws) = n", "by simp"], ["proof (state)\nthis:\n  length (False # ws) = n\n\ngoal (1 subgoal):\n 1. \\<And>ws.\n       length ws = k \\<Longrightarrow>\n       P (bdd_lookup l ws) \\<and> P (bdd_lookup r ws)", "hence 1: \"P (bdd_lookup (Branch l r) (False#ws))\""], ["proof (prove)\nusing this:\n  length (False # ws) = n\n\ngoal (1 subgoal):\n 1. P (bdd_lookup (Branch l r) (False # ws))", "by (rule R)"], ["proof (state)\nthis:\n  P (bdd_lookup (Branch l r) (False # ws))\n\ngoal (1 subgoal):\n 1. \\<And>ws.\n       length ws = k \\<Longrightarrow>\n       P (bdd_lookup l ws) \\<and> P (bdd_lookup r ws)", "from H k"], ["proof (chain)\npicking this:\n  length ws = k\n  n = Suc k", "have \"length (True#ws) = n\""], ["proof (prove)\nusing this:\n  length ws = k\n  n = Suc k\n\ngoal (1 subgoal):\n 1. length (True # ws) = n", "by simp"], ["proof (state)\nthis:\n  length (True # ws) = n\n\ngoal (1 subgoal):\n 1. \\<And>ws.\n       length ws = k \\<Longrightarrow>\n       P (bdd_lookup l ws) \\<and> P (bdd_lookup r ws)", "hence \"P (bdd_lookup (Branch l r) (True#ws))\""], ["proof (prove)\nusing this:\n  length (True # ws) = n\n\ngoal (1 subgoal):\n 1. P (bdd_lookup (Branch l r) (True # ws))", "by (rule R)"], ["proof (state)\nthis:\n  P (bdd_lookup (Branch l r) (True # ws))\n\ngoal (1 subgoal):\n 1. \\<And>ws.\n       length ws = k \\<Longrightarrow>\n       P (bdd_lookup l ws) \\<and> P (bdd_lookup r ws)", "with 1"], ["proof (chain)\npicking this:\n  P (bdd_lookup (Branch l r) (False # ws))\n  P (bdd_lookup (Branch l r) (True # ws))", "show \"P (bdd_lookup l ws) \\<and> P (bdd_lookup r ws)\""], ["proof (prove)\nusing this:\n  P (bdd_lookup (Branch l r) (False # ws))\n  P (bdd_lookup (Branch l r) (True # ws))\n\ngoal (1 subgoal):\n 1. P (bdd_lookup l ws) \\<and> P (bdd_lookup r ws)", "by simp"], ["proof (state)\nthis:\n  P (bdd_lookup l ws) \\<and> P (bdd_lookup r ws)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length ?ws = k \\<Longrightarrow>\n  P (bdd_lookup l ?ws) \\<and> P (bdd_lookup r ?ws)\n\ngoal (1 subgoal):\n 1. \\<And>bdd1 bdd2 n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>bddh n bdd1;\n                    \\<forall>ws.\n                       length ws = n \\<longrightarrow>\n                       P (bdd_lookup bdd1 ws)\\<rbrakk>\n                   \\<Longrightarrow> bdd_all P bdd1;\n        \\<And>n.\n           \\<lbrakk>bddh n bdd2;\n            \\<forall>ws.\n               length ws = n \\<longrightarrow>\n               P (bdd_lookup bdd2 ws)\\<rbrakk>\n           \\<Longrightarrow> bdd_all P bdd2;\n        bddh n (Branch bdd1 bdd2);\n        \\<forall>ws.\n           length ws = n \\<longrightarrow>\n           P (bdd_lookup (Branch bdd1 bdd2) ws)\\<rbrakk>\n       \\<Longrightarrow> bdd_all P (Branch bdd1 bdd2)", "with Branch k"], ["proof (chain)\npicking this:\n  \\<lbrakk>bddh ?n l;\n   \\<forall>ws.\n      length ws = ?n \\<longrightarrow> P (bdd_lookup l ws)\\<rbrakk>\n  \\<Longrightarrow> bdd_all P l\n  \\<lbrakk>bddh ?n r;\n   \\<forall>ws.\n      length ws = ?n \\<longrightarrow> P (bdd_lookup r ws)\\<rbrakk>\n  \\<Longrightarrow> bdd_all P r\n  bddh n (Branch l r)\n  \\<forall>ws.\n     length ws = n \\<longrightarrow> P (bdd_lookup (Branch l r) ws)\n  n = Suc k\n  length ?ws = k \\<Longrightarrow>\n  P (bdd_lookup l ?ws) \\<and> P (bdd_lookup r ?ws)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>bddh ?n l;\n   \\<forall>ws.\n      length ws = ?n \\<longrightarrow> P (bdd_lookup l ws)\\<rbrakk>\n  \\<Longrightarrow> bdd_all P l\n  \\<lbrakk>bddh ?n r;\n   \\<forall>ws.\n      length ws = ?n \\<longrightarrow> P (bdd_lookup r ws)\\<rbrakk>\n  \\<Longrightarrow> bdd_all P r\n  bddh n (Branch l r)\n  \\<forall>ws.\n     length ws = n \\<longrightarrow> P (bdd_lookup (Branch l r) ws)\n  n = Suc k\n  length ?ws = k \\<Longrightarrow>\n  P (bdd_lookup l ?ws) \\<and> P (bdd_lookup r ?ws)\n\ngoal (1 subgoal):\n 1. bdd_all P (Branch l r)", "by auto"], ["proof (state)\nthis:\n  bdd_all P (Branch l r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bdd_all_bdd_map:\n  assumes \"bdd_all P bdd\"\n  and \"\\<And>a. P a \\<Longrightarrow> Q (f a)\"\n  shows \"bdd_all Q (bdd_map f bdd)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_all Q (bdd_map f bdd)", "using assms"], ["proof (prove)\nusing this:\n  bdd_all P bdd\n  P ?a \\<Longrightarrow> Q (f ?a)\n\ngoal (1 subgoal):\n 1. bdd_all Q (bdd_map f bdd)", "by (induct bdd) simp+"], ["", "lemma bddh_bdd_map:\n  shows \"bddh n (bdd_map f bdd) = bddh n bdd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bddh n (bdd_map f bdd) = bddh n bdd", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. bddh n (bdd_map f bdd) \\<Longrightarrow> bddh n bdd\n 2. bddh n bdd \\<Longrightarrow> bddh n (bdd_map f bdd)", "assume \"bddh n (bdd_map f bdd)\""], ["proof (state)\nthis:\n  bddh n (bdd_map f bdd)\n\ngoal (2 subgoals):\n 1. bddh n (bdd_map f bdd) \\<Longrightarrow> bddh n bdd\n 2. bddh n bdd \\<Longrightarrow> bddh n (bdd_map f bdd)", "thus \"bddh n bdd\""], ["proof (prove)\nusing this:\n  bddh n (bdd_map f bdd)\n\ngoal (1 subgoal):\n 1. bddh n bdd", "proof (induct bdd arbitrary: n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x n. bddh n (bdd_map f (Leaf x)) \\<Longrightarrow> bddh n (Leaf x)\n 2. \\<And>bdd1 bdd2 n.\n       \\<lbrakk>\\<And>n.\n                   bddh n (bdd_map f bdd1) \\<Longrightarrow> bddh n bdd1;\n        \\<And>n. bddh n (bdd_map f bdd2) \\<Longrightarrow> bddh n bdd2;\n        bddh n (bdd_map f (Branch bdd1 bdd2))\\<rbrakk>\n       \\<Longrightarrow> bddh n (Branch bdd1 bdd2)", "case (Branch l r n)"], ["proof (state)\nthis:\n  bddh ?n (bdd_map f l) \\<Longrightarrow> bddh ?n l\n  bddh ?n (bdd_map f r) \\<Longrightarrow> bddh ?n r\n  bddh n (bdd_map f (Branch l r))\n\ngoal (2 subgoals):\n 1. \\<And>x n. bddh n (bdd_map f (Leaf x)) \\<Longrightarrow> bddh n (Leaf x)\n 2. \\<And>bdd1 bdd2 n.\n       \\<lbrakk>\\<And>n.\n                   bddh n (bdd_map f bdd1) \\<Longrightarrow> bddh n bdd1;\n        \\<And>n. bddh n (bdd_map f bdd2) \\<Longrightarrow> bddh n bdd2;\n        bddh n (bdd_map f (Branch bdd1 bdd2))\\<rbrakk>\n       \\<Longrightarrow> bddh n (Branch bdd1 bdd2)", "then"], ["proof (chain)\npicking this:\n  bddh ?n (bdd_map f l) \\<Longrightarrow> bddh ?n l\n  bddh ?n (bdd_map f r) \\<Longrightarrow> bddh ?n r\n  bddh n (bdd_map f (Branch l r))", "obtain k where \"n = Suc k\""], ["proof (prove)\nusing this:\n  bddh ?n (bdd_map f l) \\<Longrightarrow> bddh ?n l\n  bddh ?n (bdd_map f r) \\<Longrightarrow> bddh ?n r\n  bddh n (bdd_map f (Branch l r))\n\ngoal (1 subgoal):\n 1. (\\<And>k. n = Suc k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases n) simp+"], ["proof (state)\nthis:\n  n = Suc k\n\ngoal (2 subgoals):\n 1. \\<And>x n. bddh n (bdd_map f (Leaf x)) \\<Longrightarrow> bddh n (Leaf x)\n 2. \\<And>bdd1 bdd2 n.\n       \\<lbrakk>\\<And>n.\n                   bddh n (bdd_map f bdd1) \\<Longrightarrow> bddh n bdd1;\n        \\<And>n. bddh n (bdd_map f bdd2) \\<Longrightarrow> bddh n bdd2;\n        bddh n (bdd_map f (Branch bdd1 bdd2))\\<rbrakk>\n       \\<Longrightarrow> bddh n (Branch bdd1 bdd2)", "with Branch"], ["proof (chain)\npicking this:\n  bddh ?n (bdd_map f l) \\<Longrightarrow> bddh ?n l\n  bddh ?n (bdd_map f r) \\<Longrightarrow> bddh ?n r\n  bddh n (bdd_map f (Branch l r))\n  n = Suc k", "show ?case"], ["proof (prove)\nusing this:\n  bddh ?n (bdd_map f l) \\<Longrightarrow> bddh ?n l\n  bddh ?n (bdd_map f r) \\<Longrightarrow> bddh ?n r\n  bddh n (bdd_map f (Branch l r))\n  n = Suc k\n\ngoal (1 subgoal):\n 1. bddh n (Branch l r)", "by simp"], ["proof (state)\nthis:\n  bddh n (Branch l r)\n\ngoal (1 subgoal):\n 1. \\<And>x n. bddh n (bdd_map f (Leaf x)) \\<Longrightarrow> bddh n (Leaf x)", "qed simp"], ["proof (state)\nthis:\n  bddh n bdd\n\ngoal (1 subgoal):\n 1. bddh n bdd \\<Longrightarrow> bddh n (bdd_map f bdd)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. bddh n bdd \\<Longrightarrow> bddh n (bdd_map f bdd)", "assume \"bddh n bdd\""], ["proof (state)\nthis:\n  bddh n bdd\n\ngoal (1 subgoal):\n 1. bddh n bdd \\<Longrightarrow> bddh n (bdd_map f bdd)", "thus \"bddh n (bdd_map f bdd)\""], ["proof (prove)\nusing this:\n  bddh n bdd\n\ngoal (1 subgoal):\n 1. bddh n (bdd_map f bdd)", "proof (induct bdd arbitrary: n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x n. bddh n (Leaf x) \\<Longrightarrow> bddh n (bdd_map f (Leaf x))\n 2. \\<And>bdd1 bdd2 n.\n       \\<lbrakk>\\<And>n.\n                   bddh n bdd1 \\<Longrightarrow> bddh n (bdd_map f bdd1);\n        \\<And>n. bddh n bdd2 \\<Longrightarrow> bddh n (bdd_map f bdd2);\n        bddh n (Branch bdd1 bdd2)\\<rbrakk>\n       \\<Longrightarrow> bddh n (bdd_map f (Branch bdd1 bdd2))", "case (Branch l r n)"], ["proof (state)\nthis:\n  bddh ?n l \\<Longrightarrow> bddh ?n (bdd_map f l)\n  bddh ?n r \\<Longrightarrow> bddh ?n (bdd_map f r)\n  bddh n (Branch l r)\n\ngoal (2 subgoals):\n 1. \\<And>x n. bddh n (Leaf x) \\<Longrightarrow> bddh n (bdd_map f (Leaf x))\n 2. \\<And>bdd1 bdd2 n.\n       \\<lbrakk>\\<And>n.\n                   bddh n bdd1 \\<Longrightarrow> bddh n (bdd_map f bdd1);\n        \\<And>n. bddh n bdd2 \\<Longrightarrow> bddh n (bdd_map f bdd2);\n        bddh n (Branch bdd1 bdd2)\\<rbrakk>\n       \\<Longrightarrow> bddh n (bdd_map f (Branch bdd1 bdd2))", "then"], ["proof (chain)\npicking this:\n  bddh ?n l \\<Longrightarrow> bddh ?n (bdd_map f l)\n  bddh ?n r \\<Longrightarrow> bddh ?n (bdd_map f r)\n  bddh n (Branch l r)", "obtain k where \"n = Suc k\""], ["proof (prove)\nusing this:\n  bddh ?n l \\<Longrightarrow> bddh ?n (bdd_map f l)\n  bddh ?n r \\<Longrightarrow> bddh ?n (bdd_map f r)\n  bddh n (Branch l r)\n\ngoal (1 subgoal):\n 1. (\\<And>k. n = Suc k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases n) simp+"], ["proof (state)\nthis:\n  n = Suc k\n\ngoal (2 subgoals):\n 1. \\<And>x n. bddh n (Leaf x) \\<Longrightarrow> bddh n (bdd_map f (Leaf x))\n 2. \\<And>bdd1 bdd2 n.\n       \\<lbrakk>\\<And>n.\n                   bddh n bdd1 \\<Longrightarrow> bddh n (bdd_map f bdd1);\n        \\<And>n. bddh n bdd2 \\<Longrightarrow> bddh n (bdd_map f bdd2);\n        bddh n (Branch bdd1 bdd2)\\<rbrakk>\n       \\<Longrightarrow> bddh n (bdd_map f (Branch bdd1 bdd2))", "with Branch"], ["proof (chain)\npicking this:\n  bddh ?n l \\<Longrightarrow> bddh ?n (bdd_map f l)\n  bddh ?n r \\<Longrightarrow> bddh ?n (bdd_map f r)\n  bddh n (Branch l r)\n  n = Suc k", "show ?case"], ["proof (prove)\nusing this:\n  bddh ?n l \\<Longrightarrow> bddh ?n (bdd_map f l)\n  bddh ?n r \\<Longrightarrow> bddh ?n (bdd_map f r)\n  bddh n (Branch l r)\n  n = Suc k\n\ngoal (1 subgoal):\n 1. bddh n (bdd_map f (Branch l r))", "by simp"], ["proof (state)\nthis:\n  bddh n (bdd_map f (Branch l r))\n\ngoal (1 subgoal):\n 1. \\<And>x n. bddh n (Leaf x) \\<Longrightarrow> bddh n (bdd_map f (Leaf x))", "qed simp"], ["proof (state)\nthis:\n  bddh n (bdd_map f bdd)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bdd_map_bdd_lookup:\n  assumes \"bddh (length ws) bdd\"\n  shows \"bdd_lookup (bdd_map f bdd) ws = f (bdd_lookup bdd ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_lookup (bdd_map f bdd) ws = f (bdd_lookup bdd ws)", "using assms"], ["proof (prove)\nusing this:\n  bddh (length ws) bdd\n\ngoal (1 subgoal):\n 1. bdd_lookup (bdd_map f bdd) ws = f (bdd_lookup bdd ws)", "by (induct bdd ws rule: bdd_lookup.induct) (auto simp add: bddh_bdd_map)+"], ["", "fun bdd_binop :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'c) \\<Rightarrow> 'a bdd \\<Rightarrow> 'b bdd \\<Rightarrow> 'c bdd\"\nwhere\n  \"bdd_binop f (Leaf x) (Leaf y) = Leaf (f x y)\"\n| \"bdd_binop f (Branch l r) (Leaf y) = Branch (bdd_binop f l (Leaf y)) (bdd_binop f r (Leaf y))\"\n| \"bdd_binop f (Leaf x) (Branch l r) = Branch (bdd_binop f (Leaf x) l) (bdd_binop f (Leaf x) r)\"\n| \"bdd_binop f (Branch l\\<^sub>1 r\\<^sub>1) (Branch l\\<^sub>2 r\\<^sub>2) = Branch (bdd_binop f l\\<^sub>1 l\\<^sub>2) (bdd_binop f r\\<^sub>1 r\\<^sub>2)\""], ["", "lemma bddh_binop: \"bddh n (bdd_binop f l r) = (bddh n l \\<and> bddh n r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bddh n (bdd_binop f l r) = (bddh n l \\<and> bddh n r)", "by (induct f l r arbitrary: n rule: bdd_binop.induct) (auto split: nat.split_asm)"], ["", "lemma bdd_lookup_binop: \"\\<lbrakk>bddh (length bs) l; bddh (length bs) r\\<rbrakk> \\<Longrightarrow>\n  bdd_lookup (bdd_binop f l r) bs = f (bdd_lookup l bs) (bdd_lookup r bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bddh (length bs) l; bddh (length bs) r\\<rbrakk>\n    \\<Longrightarrow> bdd_lookup (bdd_binop f l r) bs =\n                      f (bdd_lookup l bs) (bdd_lookup r bs)", "apply (induct f l r arbitrary: bs rule: bdd_binop.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>f x y bs.\n       \\<lbrakk>bddh (length bs) (Leaf x);\n        bddh (length bs) (Leaf y)\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bdd_binop f (Leaf x) (Leaf y)) bs =\n                         f (bdd_lookup (Leaf x) bs) (bdd_lookup (Leaf y) bs)\n 2. \\<And>f l r y bs.\n       \\<lbrakk>\\<And>bs.\n                   \\<lbrakk>bddh (length bs) l;\n                    bddh (length bs) (Leaf y)\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (bdd_binop f l (Leaf y))\nbs =\n                                     f (bdd_lookup l bs)\n(bdd_lookup (Leaf y) bs);\n        \\<And>bs.\n           \\<lbrakk>bddh (length bs) r; bddh (length bs) (Leaf y)\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bdd_binop f r (Leaf y)) bs =\n                             f (bdd_lookup r bs) (bdd_lookup (Leaf y) bs);\n        bddh (length bs) (Branch l r); bddh (length bs) (Leaf y)\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bdd_binop f (Branch l r) (Leaf y)) bs =\n                         f (bdd_lookup (Branch l r) bs)\n                          (bdd_lookup (Leaf y) bs)\n 3. \\<And>f x l r bs.\n       \\<lbrakk>\\<And>bs.\n                   \\<lbrakk>bddh (length bs) (Leaf x);\n                    bddh (length bs) l\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (bdd_binop f (Leaf x) l)\nbs =\n                                     f (bdd_lookup (Leaf x) bs)\n(bdd_lookup l bs);\n        \\<And>bs.\n           \\<lbrakk>bddh (length bs) (Leaf x); bddh (length bs) r\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bdd_binop f (Leaf x) r) bs =\n                             f (bdd_lookup (Leaf x) bs) (bdd_lookup r bs);\n        bddh (length bs) (Leaf x); bddh (length bs) (Branch l r)\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bdd_binop f (Leaf x) (Branch l r)) bs =\n                         f (bdd_lookup (Leaf x) bs)\n                          (bdd_lookup (Branch l r) bs)\n 4. \\<And>f l\\<^sub>1 r\\<^sub>1 l\\<^sub>2 r\\<^sub>2 bs.\n       \\<lbrakk>\\<And>bs.\n                   \\<lbrakk>bddh (length bs) l\\<^sub>1;\n                    bddh (length bs) l\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup\n(bdd_binop f l\\<^sub>1 l\\<^sub>2) bs =\n                                     f (bdd_lookup l\\<^sub>1 bs)\n(bdd_lookup l\\<^sub>2 bs);\n        \\<And>bs.\n           \\<lbrakk>bddh (length bs) r\\<^sub>1;\n            bddh (length bs) r\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bdd_binop f r\\<^sub>1 r\\<^sub>2)\n                              bs =\n                             f (bdd_lookup r\\<^sub>1 bs)\n                              (bdd_lookup r\\<^sub>2 bs);\n        bddh (length bs) (Branch l\\<^sub>1 r\\<^sub>1);\n        bddh (length bs) (Branch l\\<^sub>2 r\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup\n                          (bdd_binop f (Branch l\\<^sub>1 r\\<^sub>1)\n                            (Branch l\\<^sub>2 r\\<^sub>2))\n                          bs =\n                         f (bdd_lookup (Branch l\\<^sub>1 r\\<^sub>1) bs)\n                          (bdd_lookup (Branch l\\<^sub>2 r\\<^sub>2) bs)", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f l r y bs.\n       \\<lbrakk>\\<And>bs.\n                   \\<lbrakk>bddh (length bs) l;\n                    bddh (length bs) (Leaf y)\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (bdd_binop f l (Leaf y))\nbs =\n                                     f (bdd_lookup l bs)\n(bdd_lookup (Leaf y) bs);\n        \\<And>bs.\n           \\<lbrakk>bddh (length bs) r; bddh (length bs) (Leaf y)\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bdd_binop f r (Leaf y)) bs =\n                             f (bdd_lookup r bs) (bdd_lookup (Leaf y) bs);\n        bddh (length bs) (Branch l r); bddh (length bs) (Leaf y)\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bdd_binop f (Branch l r) (Leaf y)) bs =\n                         f (bdd_lookup (Branch l r) bs)\n                          (bdd_lookup (Leaf y) bs)\n 2. \\<And>f x l r bs.\n       \\<lbrakk>\\<And>bs.\n                   \\<lbrakk>bddh (length bs) (Leaf x);\n                    bddh (length bs) l\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (bdd_binop f (Leaf x) l)\nbs =\n                                     f (bdd_lookup (Leaf x) bs)\n(bdd_lookup l bs);\n        \\<And>bs.\n           \\<lbrakk>bddh (length bs) (Leaf x); bddh (length bs) r\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bdd_binop f (Leaf x) r) bs =\n                             f (bdd_lookup (Leaf x) bs) (bdd_lookup r bs);\n        bddh (length bs) (Leaf x); bddh (length bs) (Branch l r)\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bdd_binop f (Leaf x) (Branch l r)) bs =\n                         f (bdd_lookup (Leaf x) bs)\n                          (bdd_lookup (Branch l r) bs)\n 3. \\<And>f l\\<^sub>1 r\\<^sub>1 l\\<^sub>2 r\\<^sub>2 bs.\n       \\<lbrakk>\\<And>bs.\n                   \\<lbrakk>bddh (length bs) l\\<^sub>1;\n                    bddh (length bs) l\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup\n(bdd_binop f l\\<^sub>1 l\\<^sub>2) bs =\n                                     f (bdd_lookup l\\<^sub>1 bs)\n(bdd_lookup l\\<^sub>2 bs);\n        \\<And>bs.\n           \\<lbrakk>bddh (length bs) r\\<^sub>1;\n            bddh (length bs) r\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bdd_binop f r\\<^sub>1 r\\<^sub>2)\n                              bs =\n                             f (bdd_lookup r\\<^sub>1 bs)\n                              (bdd_lookup r\\<^sub>2 bs);\n        bddh (length bs) (Branch l\\<^sub>1 r\\<^sub>1);\n        bddh (length bs) (Branch l\\<^sub>2 r\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup\n                          (bdd_binop f (Branch l\\<^sub>1 r\\<^sub>1)\n                            (Branch l\\<^sub>2 r\\<^sub>2))\n                          bs =\n                         f (bdd_lookup (Branch l\\<^sub>1 r\\<^sub>1) bs)\n                          (bdd_lookup (Branch l\\<^sub>2 r\\<^sub>2) bs)", "apply (case_tac bs)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>f l r y bs.\n       \\<lbrakk>\\<And>bs.\n                   \\<lbrakk>bddh (length bs) l;\n                    bddh (length bs) (Leaf y)\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (bdd_binop f l (Leaf y))\nbs =\n                                     f (bdd_lookup l bs)\n(bdd_lookup (Leaf y) bs);\n        \\<And>bs.\n           \\<lbrakk>bddh (length bs) r; bddh (length bs) (Leaf y)\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bdd_binop f r (Leaf y)) bs =\n                             f (bdd_lookup r bs) (bdd_lookup (Leaf y) bs);\n        bddh (length bs) (Branch l r); bddh (length bs) (Leaf y);\n        bs = []\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bdd_binop f (Branch l r) (Leaf y)) bs =\n                         f (bdd_lookup (Branch l r) bs)\n                          (bdd_lookup (Leaf y) bs)\n 2. \\<And>f l r y bs a list.\n       \\<lbrakk>\\<And>bs.\n                   \\<lbrakk>bddh (length bs) l;\n                    bddh (length bs) (Leaf y)\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (bdd_binop f l (Leaf y))\nbs =\n                                     f (bdd_lookup l bs)\n(bdd_lookup (Leaf y) bs);\n        \\<And>bs.\n           \\<lbrakk>bddh (length bs) r; bddh (length bs) (Leaf y)\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bdd_binop f r (Leaf y)) bs =\n                             f (bdd_lookup r bs) (bdd_lookup (Leaf y) bs);\n        bddh (length bs) (Branch l r); bddh (length bs) (Leaf y);\n        bs = a # list\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bdd_binop f (Branch l r) (Leaf y)) bs =\n                         f (bdd_lookup (Branch l r) bs)\n                          (bdd_lookup (Leaf y) bs)\n 3. \\<And>f x l r bs.\n       \\<lbrakk>\\<And>bs.\n                   \\<lbrakk>bddh (length bs) (Leaf x);\n                    bddh (length bs) l\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (bdd_binop f (Leaf x) l)\nbs =\n                                     f (bdd_lookup (Leaf x) bs)\n(bdd_lookup l bs);\n        \\<And>bs.\n           \\<lbrakk>bddh (length bs) (Leaf x); bddh (length bs) r\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bdd_binop f (Leaf x) r) bs =\n                             f (bdd_lookup (Leaf x) bs) (bdd_lookup r bs);\n        bddh (length bs) (Leaf x); bddh (length bs) (Branch l r)\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bdd_binop f (Leaf x) (Branch l r)) bs =\n                         f (bdd_lookup (Leaf x) bs)\n                          (bdd_lookup (Branch l r) bs)\n 4. \\<And>f l\\<^sub>1 r\\<^sub>1 l\\<^sub>2 r\\<^sub>2 bs.\n       \\<lbrakk>\\<And>bs.\n                   \\<lbrakk>bddh (length bs) l\\<^sub>1;\n                    bddh (length bs) l\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup\n(bdd_binop f l\\<^sub>1 l\\<^sub>2) bs =\n                                     f (bdd_lookup l\\<^sub>1 bs)\n(bdd_lookup l\\<^sub>2 bs);\n        \\<And>bs.\n           \\<lbrakk>bddh (length bs) r\\<^sub>1;\n            bddh (length bs) r\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bdd_binop f r\\<^sub>1 r\\<^sub>2)\n                              bs =\n                             f (bdd_lookup r\\<^sub>1 bs)\n                              (bdd_lookup r\\<^sub>2 bs);\n        bddh (length bs) (Branch l\\<^sub>1 r\\<^sub>1);\n        bddh (length bs) (Branch l\\<^sub>2 r\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup\n                          (bdd_binop f (Branch l\\<^sub>1 r\\<^sub>1)\n                            (Branch l\\<^sub>2 r\\<^sub>2))\n                          bs =\n                         f (bdd_lookup (Branch l\\<^sub>1 r\\<^sub>1) bs)\n                          (bdd_lookup (Branch l\\<^sub>2 r\\<^sub>2) bs)", "apply simp+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f x l r bs.\n       \\<lbrakk>\\<And>bs.\n                   bddh (length bs) l \\<Longrightarrow>\n                   bdd_lookup (bdd_binop f (Leaf x) l) bs =\n                   f x (bdd_lookup l bs);\n        \\<And>bs.\n           bddh (length bs) r \\<Longrightarrow>\n           bdd_lookup (bdd_binop f (Leaf x) r) bs = f x (bdd_lookup r bs);\n        case length bs of 0 \\<Rightarrow> False\n        | Suc m \\<Rightarrow> bddh m l \\<and> bddh m r\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup\n                          (Branch (bdd_binop f (Leaf x) l)\n                            (bdd_binop f (Leaf x) r))\n                          bs =\n                         f x (bdd_lookup (Branch l r) bs)\n 2. \\<And>f l\\<^sub>1 r\\<^sub>1 l\\<^sub>2 r\\<^sub>2 bs.\n       \\<lbrakk>\\<And>bs.\n                   \\<lbrakk>bddh (length bs) l\\<^sub>1;\n                    bddh (length bs) l\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup\n(bdd_binop f l\\<^sub>1 l\\<^sub>2) bs =\n                                     f (bdd_lookup l\\<^sub>1 bs)\n(bdd_lookup l\\<^sub>2 bs);\n        \\<And>bs.\n           \\<lbrakk>bddh (length bs) r\\<^sub>1;\n            bddh (length bs) r\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bdd_binop f r\\<^sub>1 r\\<^sub>2)\n                              bs =\n                             f (bdd_lookup r\\<^sub>1 bs)\n                              (bdd_lookup r\\<^sub>2 bs);\n        bddh (length bs) (Branch l\\<^sub>1 r\\<^sub>1);\n        bddh (length bs) (Branch l\\<^sub>2 r\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup\n                          (bdd_binop f (Branch l\\<^sub>1 r\\<^sub>1)\n                            (Branch l\\<^sub>2 r\\<^sub>2))\n                          bs =\n                         f (bdd_lookup (Branch l\\<^sub>1 r\\<^sub>1) bs)\n                          (bdd_lookup (Branch l\\<^sub>2 r\\<^sub>2) bs)", "apply (case_tac bs)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f x l r bs.\n       \\<lbrakk>\\<And>bs.\n                   bddh (length bs) l \\<Longrightarrow>\n                   bdd_lookup (bdd_binop f (Leaf x) l) bs =\n                   f x (bdd_lookup l bs);\n        \\<And>bs.\n           bddh (length bs) r \\<Longrightarrow>\n           bdd_lookup (bdd_binop f (Leaf x) r) bs = f x (bdd_lookup r bs);\n        case length bs of 0 \\<Rightarrow> False\n        | Suc m \\<Rightarrow> bddh m l \\<and> bddh m r;\n        bs = []\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup\n                          (Branch (bdd_binop f (Leaf x) l)\n                            (bdd_binop f (Leaf x) r))\n                          bs =\n                         f x (bdd_lookup (Branch l r) bs)\n 2. \\<And>f x l r bs a list.\n       \\<lbrakk>\\<And>bs.\n                   bddh (length bs) l \\<Longrightarrow>\n                   bdd_lookup (bdd_binop f (Leaf x) l) bs =\n                   f x (bdd_lookup l bs);\n        \\<And>bs.\n           bddh (length bs) r \\<Longrightarrow>\n           bdd_lookup (bdd_binop f (Leaf x) r) bs = f x (bdd_lookup r bs);\n        case length bs of 0 \\<Rightarrow> False\n        | Suc m \\<Rightarrow> bddh m l \\<and> bddh m r;\n        bs = a # list\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup\n                          (Branch (bdd_binop f (Leaf x) l)\n                            (bdd_binop f (Leaf x) r))\n                          bs =\n                         f x (bdd_lookup (Branch l r) bs)\n 3. \\<And>f l\\<^sub>1 r\\<^sub>1 l\\<^sub>2 r\\<^sub>2 bs.\n       \\<lbrakk>\\<And>bs.\n                   \\<lbrakk>bddh (length bs) l\\<^sub>1;\n                    bddh (length bs) l\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup\n(bdd_binop f l\\<^sub>1 l\\<^sub>2) bs =\n                                     f (bdd_lookup l\\<^sub>1 bs)\n(bdd_lookup l\\<^sub>2 bs);\n        \\<And>bs.\n           \\<lbrakk>bddh (length bs) r\\<^sub>1;\n            bddh (length bs) r\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bdd_binop f r\\<^sub>1 r\\<^sub>2)\n                              bs =\n                             f (bdd_lookup r\\<^sub>1 bs)\n                              (bdd_lookup r\\<^sub>2 bs);\n        bddh (length bs) (Branch l\\<^sub>1 r\\<^sub>1);\n        bddh (length bs) (Branch l\\<^sub>2 r\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup\n                          (bdd_binop f (Branch l\\<^sub>1 r\\<^sub>1)\n                            (Branch l\\<^sub>2 r\\<^sub>2))\n                          bs =\n                         f (bdd_lookup (Branch l\\<^sub>1 r\\<^sub>1) bs)\n                          (bdd_lookup (Branch l\\<^sub>2 r\\<^sub>2) bs)", "apply simp+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f l\\<^sub>1 r\\<^sub>1 l\\<^sub>2 r\\<^sub>2 bs.\n       \\<lbrakk>\\<And>bs.\n                   \\<lbrakk>bddh (length bs) l\\<^sub>1;\n                    bddh (length bs) l\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup\n(bdd_binop f l\\<^sub>1 l\\<^sub>2) bs =\n                                     f (bdd_lookup l\\<^sub>1 bs)\n(bdd_lookup l\\<^sub>2 bs);\n        \\<And>bs.\n           \\<lbrakk>bddh (length bs) r\\<^sub>1;\n            bddh (length bs) r\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bdd_binop f r\\<^sub>1 r\\<^sub>2)\n                              bs =\n                             f (bdd_lookup r\\<^sub>1 bs)\n                              (bdd_lookup r\\<^sub>2 bs);\n        case length bs of 0 \\<Rightarrow> False\n        | Suc m \\<Rightarrow> bddh m l\\<^sub>1 \\<and> bddh m r\\<^sub>1;\n        case length bs of 0 \\<Rightarrow> False\n        | Suc m \\<Rightarrow>\n            bddh m l\\<^sub>2 \\<and> bddh m r\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup\n                          (Branch (bdd_binop f l\\<^sub>1 l\\<^sub>2)\n                            (bdd_binop f r\\<^sub>1 r\\<^sub>2))\n                          bs =\n                         f (bdd_lookup (Branch l\\<^sub>1 r\\<^sub>1) bs)\n                          (bdd_lookup (Branch l\\<^sub>2 r\\<^sub>2) bs)", "apply (case_tac bs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f l\\<^sub>1 r\\<^sub>1 l\\<^sub>2 r\\<^sub>2 bs.\n       \\<lbrakk>\\<And>bs.\n                   \\<lbrakk>bddh (length bs) l\\<^sub>1;\n                    bddh (length bs) l\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup\n(bdd_binop f l\\<^sub>1 l\\<^sub>2) bs =\n                                     f (bdd_lookup l\\<^sub>1 bs)\n(bdd_lookup l\\<^sub>2 bs);\n        \\<And>bs.\n           \\<lbrakk>bddh (length bs) r\\<^sub>1;\n            bddh (length bs) r\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bdd_binop f r\\<^sub>1 r\\<^sub>2)\n                              bs =\n                             f (bdd_lookup r\\<^sub>1 bs)\n                              (bdd_lookup r\\<^sub>2 bs);\n        case length bs of 0 \\<Rightarrow> False\n        | Suc m \\<Rightarrow> bddh m l\\<^sub>1 \\<and> bddh m r\\<^sub>1;\n        case length bs of 0 \\<Rightarrow> False\n        | Suc m \\<Rightarrow> bddh m l\\<^sub>2 \\<and> bddh m r\\<^sub>2;\n        bs = []\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup\n                          (Branch (bdd_binop f l\\<^sub>1 l\\<^sub>2)\n                            (bdd_binop f r\\<^sub>1 r\\<^sub>2))\n                          bs =\n                         f (bdd_lookup (Branch l\\<^sub>1 r\\<^sub>1) bs)\n                          (bdd_lookup (Branch l\\<^sub>2 r\\<^sub>2) bs)\n 2. \\<And>f l\\<^sub>1 r\\<^sub>1 l\\<^sub>2 r\\<^sub>2 bs a list.\n       \\<lbrakk>\\<And>bs.\n                   \\<lbrakk>bddh (length bs) l\\<^sub>1;\n                    bddh (length bs) l\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup\n(bdd_binop f l\\<^sub>1 l\\<^sub>2) bs =\n                                     f (bdd_lookup l\\<^sub>1 bs)\n(bdd_lookup l\\<^sub>2 bs);\n        \\<And>bs.\n           \\<lbrakk>bddh (length bs) r\\<^sub>1;\n            bddh (length bs) r\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bdd_binop f r\\<^sub>1 r\\<^sub>2)\n                              bs =\n                             f (bdd_lookup r\\<^sub>1 bs)\n                              (bdd_lookup r\\<^sub>2 bs);\n        case length bs of 0 \\<Rightarrow> False\n        | Suc m \\<Rightarrow> bddh m l\\<^sub>1 \\<and> bddh m r\\<^sub>1;\n        case length bs of 0 \\<Rightarrow> False\n        | Suc m \\<Rightarrow> bddh m l\\<^sub>2 \\<and> bddh m r\\<^sub>2;\n        bs = a # list\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup\n                          (Branch (bdd_binop f l\\<^sub>1 l\\<^sub>2)\n                            (bdd_binop f r\\<^sub>1 r\\<^sub>2))\n                          bs =\n                         f (bdd_lookup (Branch l\\<^sub>1 r\\<^sub>1) bs)\n                          (bdd_lookup (Branch l\\<^sub>2 r\\<^sub>2) bs)", "apply simp+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bdd_all_bdd_binop:\n  assumes \"bdd_all P bdd\"\n  and \"bdd_all Q bdd'\"\n  and \"\\<And>a b. \\<lbrakk>P a; Q b\\<rbrakk> \\<Longrightarrow> R (f a b)\"\n  shows \"bdd_all R (bdd_binop f bdd bdd')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_all R (bdd_binop f bdd bdd')", "using assms"], ["proof (prove)\nusing this:\n  bdd_all P bdd\n  bdd_all Q bdd'\n  \\<lbrakk>P ?a; Q ?b\\<rbrakk> \\<Longrightarrow> R (f ?a ?b)\n\ngoal (1 subgoal):\n 1. bdd_all R (bdd_binop f bdd bdd')", "by (induct f bdd bdd' rule: bdd_binop.induct) simp+"], ["", "lemma insert_list_idemp[simp]:\n  \"List.insert x (List.insert x xs) = List.insert x xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.insert x (List.insert x xs) = List.insert x xs", "by simp"], ["", "primrec add_leaves :: \"'a bdd \\<Rightarrow> 'a list \\<Rightarrow> 'a list\"\nwhere\n  \"add_leaves (Leaf x) xs = List.insert x xs\"\n| \"add_leaves (Branch b c) xs = add_leaves c (add_leaves b xs)\""], ["", "lemma add_leaves_bdd_lookup:\n  \"bddh n b \\<Longrightarrow> (x \\<in> set (add_leaves b xs)) = ((\\<exists>bs. x = bdd_lookup b bs \\<and> is_alph n bs) \\<or> x \\<in> set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bddh n b \\<Longrightarrow>\n    (x \\<in> set (add_leaves b xs)) =\n    ((\\<exists>bs. x = bdd_lookup b bs \\<and> is_alph n bs) \\<or>\n     x \\<in> set xs)", "apply (induct b arbitrary: xs n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa xs n.\n       bddh n (Leaf xa) \\<Longrightarrow>\n       (x \\<in> set (add_leaves (Leaf xa) xs)) =\n       ((\\<exists>bs. x = bdd_lookup (Leaf xa) bs \\<and> is_alph n bs) \\<or>\n        x \\<in> set xs)\n 2. \\<And>b1 b2 xs n.\n       \\<lbrakk>\\<And>xs n.\n                   bddh n b1 \\<Longrightarrow>\n                   (x \\<in> set (add_leaves b1 xs)) =\n                   ((\\<exists>bs.\n                        x = bdd_lookup b1 bs \\<and> is_alph n bs) \\<or>\n                    x \\<in> set xs);\n        \\<And>xs n.\n           bddh n b2 \\<Longrightarrow>\n           (x \\<in> set (add_leaves b2 xs)) =\n           ((\\<exists>bs. x = bdd_lookup b2 bs \\<and> is_alph n bs) \\<or>\n            x \\<in> set xs);\n        bddh n (Branch b1 b2)\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> set (add_leaves (Branch b1 b2) xs)) =\n                         ((\\<exists>bs.\n                              x = bdd_lookup (Branch b1 b2) bs \\<and>\n                              is_alph n bs) \\<or>\n                          x \\<in> set xs)", "apply (auto split: nat.split_asm)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xs n. x \\<notin> set xs \\<Longrightarrow> Ex (is_alph n)\n 2. \\<And>b1 b2 xs x2 bs.\n       \\<lbrakk>\\<And>xs n.\n                   bddh n b1 \\<Longrightarrow>\n                   (bdd_lookup b2 bs \\<in> set (add_leaves b1 xs)) =\n                   ((\\<exists>bsa.\n                        bdd_lookup b2 bs = bdd_lookup b1 bsa \\<and>\n                        is_alph n bsa) \\<or>\n                    bdd_lookup b2 bs \\<in> set xs);\n        \\<And>xs n.\n           bddh n b2 \\<Longrightarrow>\n           (bdd_lookup b2 bs \\<in> set (add_leaves b2 xs)) =\n           ((\\<exists>bsa.\n                bdd_lookup b2 bs = bdd_lookup b2 bsa \\<and>\n                is_alph n bsa) \\<or>\n            bdd_lookup b2 bs \\<in> set xs);\n        bddh x2 b1; bddh x2 b2; bdd_lookup b2 bs \\<notin> set xs;\n        is_alph x2 bs; x = bdd_lookup b2 bs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bsa.\n                            bdd_lookup b2 bs =\n                            bdd_lookup (Branch b1 b2) bsa \\<and>\n                            is_alph (Suc x2) bsa\n 3. \\<And>b1 b2 xs x2 bs.\n       \\<lbrakk>\\<And>xs n.\n                   bddh n b1 \\<Longrightarrow>\n                   (bdd_lookup b1 bs \\<in> set (add_leaves b1 xs)) =\n                   ((\\<exists>bsa.\n                        bdd_lookup b1 bs = bdd_lookup b1 bsa \\<and>\n                        is_alph n bsa) \\<or>\n                    bdd_lookup b1 bs \\<in> set xs);\n        \\<And>xs n.\n           bddh n b2 \\<Longrightarrow>\n           (bdd_lookup b1 bs \\<in> set (add_leaves b2 xs)) =\n           ((\\<exists>bsa.\n                bdd_lookup b1 bs = bdd_lookup b2 bsa \\<and>\n                is_alph n bsa) \\<or>\n            bdd_lookup b1 bs \\<in> set xs);\n        bddh x2 b1; bddh x2 b2; bdd_lookup b1 bs \\<notin> set xs;\n        is_alph x2 bs; x = bdd_lookup b1 bs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bsa.\n                            bdd_lookup b1 bs =\n                            bdd_lookup (Branch b1 b2) bsa \\<and>\n                            is_alph (Suc x2) bsa\n 4. \\<And>b1 b2 xs x2 bs.\n       \\<lbrakk>\\<And>xs n.\n                   bddh n b1 \\<Longrightarrow>\n                   (bdd_lookup (Branch b1 b2) bs\n                    \\<in> set (add_leaves b1 xs)) =\n                   ((\\<exists>bsa.\n                        bdd_lookup (Branch b1 b2) bs =\n                        bdd_lookup b1 bsa \\<and>\n                        is_alph n bsa) \\<or>\n                    bdd_lookup (Branch b1 b2) bs \\<in> set xs);\n        \\<And>xs n.\n           bddh n b2 \\<Longrightarrow>\n           (bdd_lookup (Branch b1 b2) bs \\<in> set (add_leaves b2 xs)) =\n           ((\\<exists>bsa.\n                bdd_lookup (Branch b1 b2) bs = bdd_lookup b2 bsa \\<and>\n                is_alph n bsa) \\<or>\n            bdd_lookup (Branch b1 b2) bs \\<in> set xs);\n        bddh x2 b1; bddh x2 b2; is_alph (Suc x2) bs;\n        x = bdd_lookup (Branch b1 b2) bs;\n        \\<forall>bsa.\n           bdd_lookup (Branch b1 b2) bs =\n           bdd_lookup b2 bsa \\<longrightarrow>\n           \\<not> is_alph x2 bsa;\n        bdd_lookup (Branch b1 b2) bs \\<notin> set xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bsa.\n                            bdd_lookup (Branch b1 b2) bs =\n                            bdd_lookup b1 bsa \\<and>\n                            is_alph x2 bsa", "apply (rule_tac x=\"replicate n arbitrary\" in exI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xs n.\n       x \\<notin> set xs \\<Longrightarrow> is_alph n (replicate n arbitrary)\n 2. \\<And>b1 b2 xs x2 bs.\n       \\<lbrakk>\\<And>xs n.\n                   bddh n b1 \\<Longrightarrow>\n                   (bdd_lookup b2 bs \\<in> set (add_leaves b1 xs)) =\n                   ((\\<exists>bsa.\n                        bdd_lookup b2 bs = bdd_lookup b1 bsa \\<and>\n                        is_alph n bsa) \\<or>\n                    bdd_lookup b2 bs \\<in> set xs);\n        \\<And>xs n.\n           bddh n b2 \\<Longrightarrow>\n           (bdd_lookup b2 bs \\<in> set (add_leaves b2 xs)) =\n           ((\\<exists>bsa.\n                bdd_lookup b2 bs = bdd_lookup b2 bsa \\<and>\n                is_alph n bsa) \\<or>\n            bdd_lookup b2 bs \\<in> set xs);\n        bddh x2 b1; bddh x2 b2; bdd_lookup b2 bs \\<notin> set xs;\n        is_alph x2 bs; x = bdd_lookup b2 bs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bsa.\n                            bdd_lookup b2 bs =\n                            bdd_lookup (Branch b1 b2) bsa \\<and>\n                            is_alph (Suc x2) bsa\n 3. \\<And>b1 b2 xs x2 bs.\n       \\<lbrakk>\\<And>xs n.\n                   bddh n b1 \\<Longrightarrow>\n                   (bdd_lookup b1 bs \\<in> set (add_leaves b1 xs)) =\n                   ((\\<exists>bsa.\n                        bdd_lookup b1 bs = bdd_lookup b1 bsa \\<and>\n                        is_alph n bsa) \\<or>\n                    bdd_lookup b1 bs \\<in> set xs);\n        \\<And>xs n.\n           bddh n b2 \\<Longrightarrow>\n           (bdd_lookup b1 bs \\<in> set (add_leaves b2 xs)) =\n           ((\\<exists>bsa.\n                bdd_lookup b1 bs = bdd_lookup b2 bsa \\<and>\n                is_alph n bsa) \\<or>\n            bdd_lookup b1 bs \\<in> set xs);\n        bddh x2 b1; bddh x2 b2; bdd_lookup b1 bs \\<notin> set xs;\n        is_alph x2 bs; x = bdd_lookup b1 bs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bsa.\n                            bdd_lookup b1 bs =\n                            bdd_lookup (Branch b1 b2) bsa \\<and>\n                            is_alph (Suc x2) bsa\n 4. \\<And>b1 b2 xs x2 bs.\n       \\<lbrakk>\\<And>xs n.\n                   bddh n b1 \\<Longrightarrow>\n                   (bdd_lookup (Branch b1 b2) bs\n                    \\<in> set (add_leaves b1 xs)) =\n                   ((\\<exists>bsa.\n                        bdd_lookup (Branch b1 b2) bs =\n                        bdd_lookup b1 bsa \\<and>\n                        is_alph n bsa) \\<or>\n                    bdd_lookup (Branch b1 b2) bs \\<in> set xs);\n        \\<And>xs n.\n           bddh n b2 \\<Longrightarrow>\n           (bdd_lookup (Branch b1 b2) bs \\<in> set (add_leaves b2 xs)) =\n           ((\\<exists>bsa.\n                bdd_lookup (Branch b1 b2) bs = bdd_lookup b2 bsa \\<and>\n                is_alph n bsa) \\<or>\n            bdd_lookup (Branch b1 b2) bs \\<in> set xs);\n        bddh x2 b1; bddh x2 b2; is_alph (Suc x2) bs;\n        x = bdd_lookup (Branch b1 b2) bs;\n        \\<forall>bsa.\n           bdd_lookup (Branch b1 b2) bs =\n           bdd_lookup b2 bsa \\<longrightarrow>\n           \\<not> is_alph x2 bsa;\n        bdd_lookup (Branch b1 b2) bs \\<notin> set xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bsa.\n                            bdd_lookup (Branch b1 b2) bs =\n                            bdd_lookup b1 bsa \\<and>\n                            is_alph x2 bsa", "apply (simp add: is_alph_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b1 b2 xs x2 bs.\n       \\<lbrakk>\\<And>xs n.\n                   bddh n b1 \\<Longrightarrow>\n                   (bdd_lookup b2 bs \\<in> set (add_leaves b1 xs)) =\n                   ((\\<exists>bsa.\n                        bdd_lookup b2 bs = bdd_lookup b1 bsa \\<and>\n                        is_alph n bsa) \\<or>\n                    bdd_lookup b2 bs \\<in> set xs);\n        \\<And>xs n.\n           bddh n b2 \\<Longrightarrow>\n           (bdd_lookup b2 bs \\<in> set (add_leaves b2 xs)) =\n           ((\\<exists>bsa.\n                bdd_lookup b2 bs = bdd_lookup b2 bsa \\<and>\n                is_alph n bsa) \\<or>\n            bdd_lookup b2 bs \\<in> set xs);\n        bddh x2 b1; bddh x2 b2; bdd_lookup b2 bs \\<notin> set xs;\n        is_alph x2 bs; x = bdd_lookup b2 bs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bsa.\n                            bdd_lookup b2 bs =\n                            bdd_lookup (Branch b1 b2) bsa \\<and>\n                            is_alph (Suc x2) bsa\n 2. \\<And>b1 b2 xs x2 bs.\n       \\<lbrakk>\\<And>xs n.\n                   bddh n b1 \\<Longrightarrow>\n                   (bdd_lookup b1 bs \\<in> set (add_leaves b1 xs)) =\n                   ((\\<exists>bsa.\n                        bdd_lookup b1 bs = bdd_lookup b1 bsa \\<and>\n                        is_alph n bsa) \\<or>\n                    bdd_lookup b1 bs \\<in> set xs);\n        \\<And>xs n.\n           bddh n b2 \\<Longrightarrow>\n           (bdd_lookup b1 bs \\<in> set (add_leaves b2 xs)) =\n           ((\\<exists>bsa.\n                bdd_lookup b1 bs = bdd_lookup b2 bsa \\<and>\n                is_alph n bsa) \\<or>\n            bdd_lookup b1 bs \\<in> set xs);\n        bddh x2 b1; bddh x2 b2; bdd_lookup b1 bs \\<notin> set xs;\n        is_alph x2 bs; x = bdd_lookup b1 bs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bsa.\n                            bdd_lookup b1 bs =\n                            bdd_lookup (Branch b1 b2) bsa \\<and>\n                            is_alph (Suc x2) bsa\n 3. \\<And>b1 b2 xs x2 bs.\n       \\<lbrakk>\\<And>xs n.\n                   bddh n b1 \\<Longrightarrow>\n                   (bdd_lookup (Branch b1 b2) bs\n                    \\<in> set (add_leaves b1 xs)) =\n                   ((\\<exists>bsa.\n                        bdd_lookup (Branch b1 b2) bs =\n                        bdd_lookup b1 bsa \\<and>\n                        is_alph n bsa) \\<or>\n                    bdd_lookup (Branch b1 b2) bs \\<in> set xs);\n        \\<And>xs n.\n           bddh n b2 \\<Longrightarrow>\n           (bdd_lookup (Branch b1 b2) bs \\<in> set (add_leaves b2 xs)) =\n           ((\\<exists>bsa.\n                bdd_lookup (Branch b1 b2) bs = bdd_lookup b2 bsa \\<and>\n                is_alph n bsa) \\<or>\n            bdd_lookup (Branch b1 b2) bs \\<in> set xs);\n        bddh x2 b1; bddh x2 b2; is_alph (Suc x2) bs;\n        x = bdd_lookup (Branch b1 b2) bs;\n        \\<forall>bsa.\n           bdd_lookup (Branch b1 b2) bs =\n           bdd_lookup b2 bsa \\<longrightarrow>\n           \\<not> is_alph x2 bsa;\n        bdd_lookup (Branch b1 b2) bs \\<notin> set xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bsa.\n                            bdd_lookup (Branch b1 b2) bs =\n                            bdd_lookup b1 bsa \\<and>\n                            is_alph x2 bsa", "apply (rule_tac x=\"True # bs\" in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b1 b2 xs x2 bs.\n       \\<lbrakk>\\<And>xs n.\n                   bddh n b1 \\<Longrightarrow>\n                   (bdd_lookup b2 bs \\<in> set (add_leaves b1 xs)) =\n                   ((\\<exists>bsa.\n                        bdd_lookup b2 bs = bdd_lookup b1 bsa \\<and>\n                        is_alph n bsa) \\<or>\n                    bdd_lookup b2 bs \\<in> set xs);\n        \\<And>xs n.\n           bddh n b2 \\<Longrightarrow>\n           (bdd_lookup b2 bs \\<in> set (add_leaves b2 xs)) =\n           ((\\<exists>bsa.\n                bdd_lookup b2 bs = bdd_lookup b2 bsa \\<and>\n                is_alph n bsa) \\<or>\n            bdd_lookup b2 bs \\<in> set xs);\n        bddh x2 b1; bddh x2 b2; bdd_lookup b2 bs \\<notin> set xs;\n        is_alph x2 bs; x = bdd_lookup b2 bs\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup b2 bs =\n                         bdd_lookup (Branch b1 b2) (True # bs) \\<and>\n                         is_alph (Suc x2) (True # bs)\n 2. \\<And>b1 b2 xs x2 bs.\n       \\<lbrakk>\\<And>xs n.\n                   bddh n b1 \\<Longrightarrow>\n                   (bdd_lookup b1 bs \\<in> set (add_leaves b1 xs)) =\n                   ((\\<exists>bsa.\n                        bdd_lookup b1 bs = bdd_lookup b1 bsa \\<and>\n                        is_alph n bsa) \\<or>\n                    bdd_lookup b1 bs \\<in> set xs);\n        \\<And>xs n.\n           bddh n b2 \\<Longrightarrow>\n           (bdd_lookup b1 bs \\<in> set (add_leaves b2 xs)) =\n           ((\\<exists>bsa.\n                bdd_lookup b1 bs = bdd_lookup b2 bsa \\<and>\n                is_alph n bsa) \\<or>\n            bdd_lookup b1 bs \\<in> set xs);\n        bddh x2 b1; bddh x2 b2; bdd_lookup b1 bs \\<notin> set xs;\n        is_alph x2 bs; x = bdd_lookup b1 bs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bsa.\n                            bdd_lookup b1 bs =\n                            bdd_lookup (Branch b1 b2) bsa \\<and>\n                            is_alph (Suc x2) bsa\n 3. \\<And>b1 b2 xs x2 bs.\n       \\<lbrakk>\\<And>xs n.\n                   bddh n b1 \\<Longrightarrow>\n                   (bdd_lookup (Branch b1 b2) bs\n                    \\<in> set (add_leaves b1 xs)) =\n                   ((\\<exists>bsa.\n                        bdd_lookup (Branch b1 b2) bs =\n                        bdd_lookup b1 bsa \\<and>\n                        is_alph n bsa) \\<or>\n                    bdd_lookup (Branch b1 b2) bs \\<in> set xs);\n        \\<And>xs n.\n           bddh n b2 \\<Longrightarrow>\n           (bdd_lookup (Branch b1 b2) bs \\<in> set (add_leaves b2 xs)) =\n           ((\\<exists>bsa.\n                bdd_lookup (Branch b1 b2) bs = bdd_lookup b2 bsa \\<and>\n                is_alph n bsa) \\<or>\n            bdd_lookup (Branch b1 b2) bs \\<in> set xs);\n        bddh x2 b1; bddh x2 b2; is_alph (Suc x2) bs;\n        x = bdd_lookup (Branch b1 b2) bs;\n        \\<forall>bsa.\n           bdd_lookup (Branch b1 b2) bs =\n           bdd_lookup b2 bsa \\<longrightarrow>\n           \\<not> is_alph x2 bsa;\n        bdd_lookup (Branch b1 b2) bs \\<notin> set xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bsa.\n                            bdd_lookup (Branch b1 b2) bs =\n                            bdd_lookup b1 bsa \\<and>\n                            is_alph x2 bsa", "apply (simp add: is_alph_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b1 b2 xs x2 bs.\n       \\<lbrakk>\\<And>xs n.\n                   bddh n b1 \\<Longrightarrow>\n                   (bdd_lookup b1 bs \\<in> set (add_leaves b1 xs)) =\n                   ((\\<exists>bsa.\n                        bdd_lookup b1 bs = bdd_lookup b1 bsa \\<and>\n                        is_alph n bsa) \\<or>\n                    bdd_lookup b1 bs \\<in> set xs);\n        \\<And>xs n.\n           bddh n b2 \\<Longrightarrow>\n           (bdd_lookup b1 bs \\<in> set (add_leaves b2 xs)) =\n           ((\\<exists>bsa.\n                bdd_lookup b1 bs = bdd_lookup b2 bsa \\<and>\n                is_alph n bsa) \\<or>\n            bdd_lookup b1 bs \\<in> set xs);\n        bddh x2 b1; bddh x2 b2; bdd_lookup b1 bs \\<notin> set xs;\n        is_alph x2 bs; x = bdd_lookup b1 bs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bsa.\n                            bdd_lookup b1 bs =\n                            bdd_lookup (Branch b1 b2) bsa \\<and>\n                            is_alph (Suc x2) bsa\n 2. \\<And>b1 b2 xs x2 bs.\n       \\<lbrakk>\\<And>xs n.\n                   bddh n b1 \\<Longrightarrow>\n                   (bdd_lookup (Branch b1 b2) bs\n                    \\<in> set (add_leaves b1 xs)) =\n                   ((\\<exists>bsa.\n                        bdd_lookup (Branch b1 b2) bs =\n                        bdd_lookup b1 bsa \\<and>\n                        is_alph n bsa) \\<or>\n                    bdd_lookup (Branch b1 b2) bs \\<in> set xs);\n        \\<And>xs n.\n           bddh n b2 \\<Longrightarrow>\n           (bdd_lookup (Branch b1 b2) bs \\<in> set (add_leaves b2 xs)) =\n           ((\\<exists>bsa.\n                bdd_lookup (Branch b1 b2) bs = bdd_lookup b2 bsa \\<and>\n                is_alph n bsa) \\<or>\n            bdd_lookup (Branch b1 b2) bs \\<in> set xs);\n        bddh x2 b1; bddh x2 b2; is_alph (Suc x2) bs;\n        x = bdd_lookup (Branch b1 b2) bs;\n        \\<forall>bsa.\n           bdd_lookup (Branch b1 b2) bs =\n           bdd_lookup b2 bsa \\<longrightarrow>\n           \\<not> is_alph x2 bsa;\n        bdd_lookup (Branch b1 b2) bs \\<notin> set xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bsa.\n                            bdd_lookup (Branch b1 b2) bs =\n                            bdd_lookup b1 bsa \\<and>\n                            is_alph x2 bsa", "apply (rule_tac x=\"False # bs\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b1 b2 xs x2 bs.\n       \\<lbrakk>\\<And>xs n.\n                   bddh n b1 \\<Longrightarrow>\n                   (bdd_lookup b1 bs \\<in> set (add_leaves b1 xs)) =\n                   ((\\<exists>bsa.\n                        bdd_lookup b1 bs = bdd_lookup b1 bsa \\<and>\n                        is_alph n bsa) \\<or>\n                    bdd_lookup b1 bs \\<in> set xs);\n        \\<And>xs n.\n           bddh n b2 \\<Longrightarrow>\n           (bdd_lookup b1 bs \\<in> set (add_leaves b2 xs)) =\n           ((\\<exists>bsa.\n                bdd_lookup b1 bs = bdd_lookup b2 bsa \\<and>\n                is_alph n bsa) \\<or>\n            bdd_lookup b1 bs \\<in> set xs);\n        bddh x2 b1; bddh x2 b2; bdd_lookup b1 bs \\<notin> set xs;\n        is_alph x2 bs; x = bdd_lookup b1 bs\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup b1 bs =\n                         bdd_lookup (Branch b1 b2) (False # bs) \\<and>\n                         is_alph (Suc x2) (False # bs)\n 2. \\<And>b1 b2 xs x2 bs.\n       \\<lbrakk>\\<And>xs n.\n                   bddh n b1 \\<Longrightarrow>\n                   (bdd_lookup (Branch b1 b2) bs\n                    \\<in> set (add_leaves b1 xs)) =\n                   ((\\<exists>bsa.\n                        bdd_lookup (Branch b1 b2) bs =\n                        bdd_lookup b1 bsa \\<and>\n                        is_alph n bsa) \\<or>\n                    bdd_lookup (Branch b1 b2) bs \\<in> set xs);\n        \\<And>xs n.\n           bddh n b2 \\<Longrightarrow>\n           (bdd_lookup (Branch b1 b2) bs \\<in> set (add_leaves b2 xs)) =\n           ((\\<exists>bsa.\n                bdd_lookup (Branch b1 b2) bs = bdd_lookup b2 bsa \\<and>\n                is_alph n bsa) \\<or>\n            bdd_lookup (Branch b1 b2) bs \\<in> set xs);\n        bddh x2 b1; bddh x2 b2; is_alph (Suc x2) bs;\n        x = bdd_lookup (Branch b1 b2) bs;\n        \\<forall>bsa.\n           bdd_lookup (Branch b1 b2) bs =\n           bdd_lookup b2 bsa \\<longrightarrow>\n           \\<not> is_alph x2 bsa;\n        bdd_lookup (Branch b1 b2) bs \\<notin> set xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bsa.\n                            bdd_lookup (Branch b1 b2) bs =\n                            bdd_lookup b1 bsa \\<and>\n                            is_alph x2 bsa", "apply (simp add: is_alph_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b1 b2 xs x2 bs.\n       \\<lbrakk>\\<And>xs n.\n                   bddh n b1 \\<Longrightarrow>\n                   (bdd_lookup (Branch b1 b2) bs\n                    \\<in> set (add_leaves b1 xs)) =\n                   ((\\<exists>bsa.\n                        bdd_lookup (Branch b1 b2) bs =\n                        bdd_lookup b1 bsa \\<and>\n                        is_alph n bsa) \\<or>\n                    bdd_lookup (Branch b1 b2) bs \\<in> set xs);\n        \\<And>xs n.\n           bddh n b2 \\<Longrightarrow>\n           (bdd_lookup (Branch b1 b2) bs \\<in> set (add_leaves b2 xs)) =\n           ((\\<exists>bsa.\n                bdd_lookup (Branch b1 b2) bs = bdd_lookup b2 bsa \\<and>\n                is_alph n bsa) \\<or>\n            bdd_lookup (Branch b1 b2) bs \\<in> set xs);\n        bddh x2 b1; bddh x2 b2; is_alph (Suc x2) bs;\n        x = bdd_lookup (Branch b1 b2) bs;\n        \\<forall>bsa.\n           bdd_lookup (Branch b1 b2) bs =\n           bdd_lookup b2 bsa \\<longrightarrow>\n           \\<not> is_alph x2 bsa;\n        bdd_lookup (Branch b1 b2) bs \\<notin> set xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bsa.\n                            bdd_lookup (Branch b1 b2) bs =\n                            bdd_lookup b1 bsa \\<and>\n                            is_alph x2 bsa", "apply (case_tac bs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b1 b2 xs x2 bs.\n       \\<lbrakk>\\<And>xs n.\n                   bddh n b1 \\<Longrightarrow>\n                   (bdd_lookup (Branch b1 b2) bs\n                    \\<in> set (add_leaves b1 xs)) =\n                   ((\\<exists>bsa.\n                        bdd_lookup (Branch b1 b2) bs =\n                        bdd_lookup b1 bsa \\<and>\n                        is_alph n bsa) \\<or>\n                    bdd_lookup (Branch b1 b2) bs \\<in> set xs);\n        \\<And>xs n.\n           bddh n b2 \\<Longrightarrow>\n           (bdd_lookup (Branch b1 b2) bs \\<in> set (add_leaves b2 xs)) =\n           ((\\<exists>bsa.\n                bdd_lookup (Branch b1 b2) bs = bdd_lookup b2 bsa \\<and>\n                is_alph n bsa) \\<or>\n            bdd_lookup (Branch b1 b2) bs \\<in> set xs);\n        bddh x2 b1; bddh x2 b2; is_alph (Suc x2) bs;\n        x = bdd_lookup (Branch b1 b2) bs;\n        \\<forall>bsa.\n           bdd_lookup (Branch b1 b2) bs =\n           bdd_lookup b2 bsa \\<longrightarrow>\n           \\<not> is_alph x2 bsa;\n        bdd_lookup (Branch b1 b2) bs \\<notin> set xs; bs = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bsa.\n                            bdd_lookup (Branch b1 b2) bs =\n                            bdd_lookup b1 bsa \\<and>\n                            is_alph x2 bsa\n 2. \\<And>b1 b2 xs x2 bs a list.\n       \\<lbrakk>\\<And>xs n.\n                   bddh n b1 \\<Longrightarrow>\n                   (bdd_lookup (Branch b1 b2) bs\n                    \\<in> set (add_leaves b1 xs)) =\n                   ((\\<exists>bsa.\n                        bdd_lookup (Branch b1 b2) bs =\n                        bdd_lookup b1 bsa \\<and>\n                        is_alph n bsa) \\<or>\n                    bdd_lookup (Branch b1 b2) bs \\<in> set xs);\n        \\<And>xs n.\n           bddh n b2 \\<Longrightarrow>\n           (bdd_lookup (Branch b1 b2) bs \\<in> set (add_leaves b2 xs)) =\n           ((\\<exists>bsa.\n                bdd_lookup (Branch b1 b2) bs = bdd_lookup b2 bsa \\<and>\n                is_alph n bsa) \\<or>\n            bdd_lookup (Branch b1 b2) bs \\<in> set xs);\n        bddh x2 b1; bddh x2 b2; is_alph (Suc x2) bs;\n        x = bdd_lookup (Branch b1 b2) bs;\n        \\<forall>bsa.\n           bdd_lookup (Branch b1 b2) bs =\n           bdd_lookup b2 bsa \\<longrightarrow>\n           \\<not> is_alph x2 bsa;\n        bdd_lookup (Branch b1 b2) bs \\<notin> set xs; bs = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bsa.\n                            bdd_lookup (Branch b1 b2) bs =\n                            bdd_lookup b1 bsa \\<and>\n                            is_alph x2 bsa", "apply (simp add: is_alph_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b1 b2 xs x2 bs a list.\n       \\<lbrakk>\\<And>xs n.\n                   bddh n b1 \\<Longrightarrow>\n                   (bdd_lookup (Branch b1 b2) bs\n                    \\<in> set (add_leaves b1 xs)) =\n                   ((\\<exists>bsa.\n                        bdd_lookup (Branch b1 b2) bs =\n                        bdd_lookup b1 bsa \\<and>\n                        is_alph n bsa) \\<or>\n                    bdd_lookup (Branch b1 b2) bs \\<in> set xs);\n        \\<And>xs n.\n           bddh n b2 \\<Longrightarrow>\n           (bdd_lookup (Branch b1 b2) bs \\<in> set (add_leaves b2 xs)) =\n           ((\\<exists>bsa.\n                bdd_lookup (Branch b1 b2) bs = bdd_lookup b2 bsa \\<and>\n                is_alph n bsa) \\<or>\n            bdd_lookup (Branch b1 b2) bs \\<in> set xs);\n        bddh x2 b1; bddh x2 b2; is_alph (Suc x2) bs;\n        x = bdd_lookup (Branch b1 b2) bs;\n        \\<forall>bsa.\n           bdd_lookup (Branch b1 b2) bs =\n           bdd_lookup b2 bsa \\<longrightarrow>\n           \\<not> is_alph x2 bsa;\n        bdd_lookup (Branch b1 b2) bs \\<notin> set xs; bs = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bsa.\n                            bdd_lookup (Branch b1 b2) bs =\n                            bdd_lookup b1 bsa \\<and>\n                            is_alph x2 bsa", "apply (simp add: is_alph_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b1 b2 xs x2 bs a list.\n       \\<lbrakk>\\<And>xs n.\n                   bddh n b1 \\<Longrightarrow>\n                   (bdd_lookup (if a then b2 else b1) list\n                    \\<in> set (add_leaves b1 xs)) =\n                   ((\\<exists>bs.\n                        bdd_lookup (if a then b2 else b1) list =\n                        bdd_lookup b1 bs \\<and>\n                        length bs = n) \\<or>\n                    bdd_lookup (if a then b2 else b1) list \\<in> set xs);\n        \\<And>xs n.\n           bddh n b2 \\<Longrightarrow>\n           (bdd_lookup (if a then b2 else b1) list\n            \\<in> set (add_leaves b2 xs)) =\n           ((\\<exists>bs.\n                bdd_lookup (if a then b2 else b1) list =\n                bdd_lookup b2 bs \\<and>\n                length bs = n) \\<or>\n            bdd_lookup (if a then b2 else b1) list \\<in> set xs);\n        bddh x2 b1; bddh x2 b2; length list = x2;\n        x = bdd_lookup (if a then b2 else b1) list;\n        \\<forall>bs.\n           bdd_lookup (if a then b2 else b1) list =\n           bdd_lookup b2 bs \\<longrightarrow>\n           length bs \\<noteq> x2;\n        bdd_lookup (if a then b2 else b1) list \\<notin> set xs;\n        bs = a # list\\<rbrakk>\n       \\<Longrightarrow> (a \\<longrightarrow>\n                          (\\<exists>bs.\n                              bdd_lookup b2 list = bdd_lookup b1 bs \\<and>\n                              length bs = x2)) \\<and>\n                         (\\<not> a \\<longrightarrow>\n                          (\\<exists>bs.\n                              bdd_lookup b1 list = bdd_lookup b1 bs \\<and>\n                              length bs = x2))", "apply (drule_tac x=list in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b1 b2 xs x2 bs a list.\n       \\<lbrakk>\\<And>xs n.\n                   bddh n b1 \\<Longrightarrow>\n                   (bdd_lookup (if a then b2 else b1) list\n                    \\<in> set (add_leaves b1 xs)) =\n                   ((\\<exists>bs.\n                        bdd_lookup (if a then b2 else b1) list =\n                        bdd_lookup b1 bs \\<and>\n                        length bs = n) \\<or>\n                    bdd_lookup (if a then b2 else b1) list \\<in> set xs);\n        \\<And>xs n.\n           bddh n b2 \\<Longrightarrow>\n           (bdd_lookup (if a then b2 else b1) list\n            \\<in> set (add_leaves b2 xs)) =\n           ((\\<exists>bs.\n                bdd_lookup (if a then b2 else b1) list =\n                bdd_lookup b2 bs \\<and>\n                length bs = n) \\<or>\n            bdd_lookup (if a then b2 else b1) list \\<in> set xs);\n        bddh x2 b1; bddh x2 b2; length list = x2;\n        x = bdd_lookup (if a then b2 else b1) list;\n        bdd_lookup (if a then b2 else b1) list \\<notin> set xs;\n        bs = a # list;\n        bdd_lookup (if a then b2 else b1) list =\n        bdd_lookup b2 list \\<longrightarrow>\n        length list \\<noteq> x2\\<rbrakk>\n       \\<Longrightarrow> (a \\<longrightarrow>\n                          (\\<exists>bs.\n                              bdd_lookup b2 list = bdd_lookup b1 bs \\<and>\n                              length bs = x2)) \\<and>\n                         (\\<not> a \\<longrightarrow>\n                          (\\<exists>bs.\n                              bdd_lookup b1 list = bdd_lookup b1 bs \\<and>\n                              length bs = x2))", "apply (case_tac a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b1 b2 xs x2 bs a list.\n       \\<lbrakk>\\<And>xs n.\n                   bddh n b1 \\<Longrightarrow>\n                   (bdd_lookup (if a then b2 else b1) list\n                    \\<in> set (add_leaves b1 xs)) =\n                   ((\\<exists>bs.\n                        bdd_lookup (if a then b2 else b1) list =\n                        bdd_lookup b1 bs \\<and>\n                        length bs = n) \\<or>\n                    bdd_lookup (if a then b2 else b1) list \\<in> set xs);\n        \\<And>xs n.\n           bddh n b2 \\<Longrightarrow>\n           (bdd_lookup (if a then b2 else b1) list\n            \\<in> set (add_leaves b2 xs)) =\n           ((\\<exists>bs.\n                bdd_lookup (if a then b2 else b1) list =\n                bdd_lookup b2 bs \\<and>\n                length bs = n) \\<or>\n            bdd_lookup (if a then b2 else b1) list \\<in> set xs);\n        bddh x2 b1; bddh x2 b2; length list = x2;\n        x = bdd_lookup (if a then b2 else b1) list;\n        bdd_lookup (if a then b2 else b1) list \\<notin> set xs;\n        bs = a # list;\n        bdd_lookup (if a then b2 else b1) list =\n        bdd_lookup b2 list \\<longrightarrow>\n        length list \\<noteq> x2;\n        a\\<rbrakk>\n       \\<Longrightarrow> (a \\<longrightarrow>\n                          (\\<exists>bs.\n                              bdd_lookup b2 list = bdd_lookup b1 bs \\<and>\n                              length bs = x2)) \\<and>\n                         (\\<not> a \\<longrightarrow>\n                          (\\<exists>bs.\n                              bdd_lookup b1 list = bdd_lookup b1 bs \\<and>\n                              length bs = x2))\n 2. \\<And>b1 b2 xs x2 bs a list.\n       \\<lbrakk>\\<And>xs n.\n                   bddh n b1 \\<Longrightarrow>\n                   (bdd_lookup (if a then b2 else b1) list\n                    \\<in> set (add_leaves b1 xs)) =\n                   ((\\<exists>bs.\n                        bdd_lookup (if a then b2 else b1) list =\n                        bdd_lookup b1 bs \\<and>\n                        length bs = n) \\<or>\n                    bdd_lookup (if a then b2 else b1) list \\<in> set xs);\n        \\<And>xs n.\n           bddh n b2 \\<Longrightarrow>\n           (bdd_lookup (if a then b2 else b1) list\n            \\<in> set (add_leaves b2 xs)) =\n           ((\\<exists>bs.\n                bdd_lookup (if a then b2 else b1) list =\n                bdd_lookup b2 bs \\<and>\n                length bs = n) \\<or>\n            bdd_lookup (if a then b2 else b1) list \\<in> set xs);\n        bddh x2 b1; bddh x2 b2; length list = x2;\n        x = bdd_lookup (if a then b2 else b1) list;\n        bdd_lookup (if a then b2 else b1) list \\<notin> set xs;\n        bs = a # list;\n        bdd_lookup (if a then b2 else b1) list =\n        bdd_lookup b2 list \\<longrightarrow>\n        length list \\<noteq> x2;\n        \\<not> a\\<rbrakk>\n       \\<Longrightarrow> (a \\<longrightarrow>\n                          (\\<exists>bs.\n                              bdd_lookup b2 list = bdd_lookup b1 bs \\<and>\n                              length bs = x2)) \\<and>\n                         (\\<not> a \\<longrightarrow>\n                          (\\<exists>bs.\n                              bdd_lookup b1 list = bdd_lookup b1 bs \\<and>\n                              length bs = x2))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b1 b2 xs x2 bs a list.\n       \\<lbrakk>\\<And>xs n.\n                   bddh n b1 \\<Longrightarrow>\n                   (bdd_lookup (if a then b2 else b1) list\n                    \\<in> set (add_leaves b1 xs)) =\n                   ((\\<exists>bs.\n                        bdd_lookup (if a then b2 else b1) list =\n                        bdd_lookup b1 bs \\<and>\n                        length bs = n) \\<or>\n                    bdd_lookup (if a then b2 else b1) list \\<in> set xs);\n        \\<And>xs n.\n           bddh n b2 \\<Longrightarrow>\n           (bdd_lookup (if a then b2 else b1) list\n            \\<in> set (add_leaves b2 xs)) =\n           ((\\<exists>bs.\n                bdd_lookup (if a then b2 else b1) list =\n                bdd_lookup b2 bs \\<and>\n                length bs = n) \\<or>\n            bdd_lookup (if a then b2 else b1) list \\<in> set xs);\n        bddh x2 b1; bddh x2 b2; length list = x2;\n        x = bdd_lookup (if a then b2 else b1) list;\n        bdd_lookup (if a then b2 else b1) list \\<notin> set xs;\n        bs = a # list;\n        bdd_lookup (if a then b2 else b1) list =\n        bdd_lookup b2 list \\<longrightarrow>\n        length list \\<noteq> x2;\n        \\<not> a\\<rbrakk>\n       \\<Longrightarrow> (a \\<longrightarrow>\n                          (\\<exists>bs.\n                              bdd_lookup b2 list = bdd_lookup b1 bs \\<and>\n                              length bs = x2)) \\<and>\n                         (\\<not> a \\<longrightarrow>\n                          (\\<exists>bs.\n                              bdd_lookup b1 list = bdd_lookup b1 bs \\<and>\n                              length bs = x2))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b1 b2 xs x2 bs a list.\n       \\<lbrakk>\\<And>xs n.\n                   bddh n b1 \\<Longrightarrow>\n                   (bdd_lookup b1 list \\<in> set (add_leaves b1 xs)) =\n                   ((\\<exists>bs.\n                        bdd_lookup b1 list = bdd_lookup b1 bs \\<and>\n                        length bs = n) \\<or>\n                    bdd_lookup b1 list \\<in> set xs);\n        \\<And>xs n.\n           bddh n b2 \\<Longrightarrow>\n           (bdd_lookup b1 list \\<in> set (add_leaves b2 xs)) =\n           ((\\<exists>bs.\n                bdd_lookup b1 list = bdd_lookup b2 bs \\<and>\n                length bs = n) \\<or>\n            bdd_lookup b1 list \\<in> set xs);\n        bddh x2 b1; bddh x2 b2; length list = x2; x = bdd_lookup b1 list;\n        bdd_lookup b1 list \\<notin> set xs; bs = False # list;\n        bdd_lookup b1 list \\<noteq> bdd_lookup b2 list; \\<not> a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs.\n                            bdd_lookup b1 list = bdd_lookup b1 bs \\<and>\n                            length bs = x2", "apply (rule_tac x=list in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b1 b2 xs x2 bs a list.\n       \\<lbrakk>\\<And>xs n.\n                   bddh n b1 \\<Longrightarrow>\n                   (bdd_lookup b1 list \\<in> set (add_leaves b1 xs)) =\n                   ((\\<exists>bs.\n                        bdd_lookup b1 list = bdd_lookup b1 bs \\<and>\n                        length bs = n) \\<or>\n                    bdd_lookup b1 list \\<in> set xs);\n        \\<And>xs n.\n           bddh n b2 \\<Longrightarrow>\n           (bdd_lookup b1 list \\<in> set (add_leaves b2 xs)) =\n           ((\\<exists>bs.\n                bdd_lookup b1 list = bdd_lookup b2 bs \\<and>\n                length bs = n) \\<or>\n            bdd_lookup b1 list \\<in> set xs);\n        bddh x2 b1; bddh x2 b2; length list = x2; x = bdd_lookup b1 list;\n        bdd_lookup b1 list \\<notin> set xs; bs = False # list;\n        bdd_lookup b1 list \\<noteq> bdd_lookup b2 list; \\<not> a\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup b1 list = bdd_lookup b1 list \\<and>\n                         length list = x2", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma add_leaves_bdd_all_eq:\n  \"list_all P (add_leaves tr xs) \\<longleftrightarrow> bdd_all P tr \\<and> list_all P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all P (add_leaves tr xs) = (bdd_all P tr \\<and> list_all P xs)", "by (induct tr arbitrary: xs) (auto simp add: list_all_iff)"], ["", "lemmas add_leaves_bdd_all_eq' =\n  add_leaves_bdd_all_eq [where xs=\"[]\", simplified, symmetric]"], ["", "lemma add_leaves_mono:\n  \"set xs \\<subseteq> set ys \\<Longrightarrow> set (add_leaves tr xs) \\<subseteq> set (add_leaves tr ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<subseteq> set ys \\<Longrightarrow>\n    set (add_leaves tr xs) \\<subseteq> set (add_leaves tr ys)", "by (induct tr arbitrary: xs ys) auto"], ["", "lemma add_leaves_binop_subset:\n  \"set (add_leaves (bdd_binop f b b') [f x y. x \\<leftarrow> xs, y \\<leftarrow> ys]) \\<subseteq>\n   (\\<Union>x\\<in>set (add_leaves b xs). \\<Union>y\\<in>set (add_leaves b' ys). {f x y})\" (is \"?A \\<subseteq> ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (add_leaves (bdd_binop f b b')\n          (concat (map (\\<lambda>x. map (f x) ys) xs)))\n    \\<subseteq> (\\<Union>x\\<in>set (add_leaves b xs).\n                    \\<Union>y\\<in>set (add_leaves b' ys). {f x y})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (add_leaves (bdd_binop f b b')\n          (concat (map (\\<lambda>x. map (f x) ys) xs)))\n    \\<subseteq> (\\<Union>x\\<in>set (add_leaves b xs).\n                    \\<Union>y\\<in>set (add_leaves b' ys). {f x y})", "have \"?A \\<subseteq> (\\<Union>x\\<in>set (add_leaves b xs). f x ` set (add_leaves b' ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (add_leaves (bdd_binop f b b')\n          (concat (map (\\<lambda>x. map (f x) ys) xs)))\n    \\<subseteq> (\\<Union>x\\<in>set (add_leaves b xs).\n                    f x ` set (add_leaves b' ys))", "proof (induct f b b' arbitrary: xs ys rule: bdd_binop.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>f x y xs ys.\n       set (add_leaves (bdd_binop f (Leaf x) (Leaf y))\n             (concat (map (\\<lambda>x. map (f x) ys) xs)))\n       \\<subseteq> (\\<Union>x\\<in>set (add_leaves (Leaf x) xs).\n                       f x ` set (add_leaves (Leaf y) ys))\n 2. \\<And>f l r y xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   set (add_leaves (bdd_binop f l (Leaf y))\n                         (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                   \\<subseteq> (\\<Union>x\\<in>set (add_leaves l xs).\n                                   f x ` set (add_leaves (Leaf y) ys));\n        \\<And>xs ys.\n           set (add_leaves (bdd_binop f r (Leaf y))\n                 (concat (map (\\<lambda>x. map (f x) ys) xs)))\n           \\<subseteq> (\\<Union>x\\<in>set (add_leaves r xs).\n                           f x ` set (add_leaves (Leaf y) ys))\\<rbrakk>\n       \\<Longrightarrow> set (add_leaves (bdd_binop f (Branch l r) (Leaf y))\n                               (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                         \\<subseteq> (\\<Union>x\\<in>set\n               (add_leaves (Branch l r) xs).\n   f x ` set (add_leaves (Leaf y) ys))\n 3. \\<And>f x l r xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   set (add_leaves (bdd_binop f (Leaf x) l)\n                         (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                   \\<subseteq> (\\<Union>x\\<in>set (add_leaves (Leaf x) xs).\n                                   f x ` set (add_leaves l ys));\n        \\<And>xs ys.\n           set (add_leaves (bdd_binop f (Leaf x) r)\n                 (concat (map (\\<lambda>x. map (f x) ys) xs)))\n           \\<subseteq> (\\<Union>x\\<in>set (add_leaves (Leaf x) xs).\n                           f x ` set (add_leaves r ys))\\<rbrakk>\n       \\<Longrightarrow> set (add_leaves (bdd_binop f (Leaf x) (Branch l r))\n                               (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                         \\<subseteq> (\\<Union>x\\<in>set\n               (add_leaves (Leaf x) xs).\n   f x ` set (add_leaves (Branch l r) ys))\n 4. \\<And>f l\\<^sub>1 r\\<^sub>1 l\\<^sub>2 r\\<^sub>2 xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   set (add_leaves (bdd_binop f l\\<^sub>1 l\\<^sub>2)\n                         (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                   \\<subseteq> (\\<Union>x\\<in>set (add_leaves l\\<^sub>1 xs).\n                                   f x ` set (add_leaves l\\<^sub>2 ys));\n        \\<And>xs ys.\n           set (add_leaves (bdd_binop f r\\<^sub>1 r\\<^sub>2)\n                 (concat (map (\\<lambda>x. map (f x) ys) xs)))\n           \\<subseteq> (\\<Union>x\\<in>set (add_leaves r\\<^sub>1 xs).\n                           f x ` set (add_leaves r\\<^sub>2 ys))\\<rbrakk>\n       \\<Longrightarrow> set (add_leaves\n                               (bdd_binop f (Branch l\\<^sub>1 r\\<^sub>1)\n                                 (Branch l\\<^sub>2 r\\<^sub>2))\n                               (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                         \\<subseteq> (\\<Union>x\\<in>set\n               (add_leaves (Branch l\\<^sub>1 r\\<^sub>1) xs).\n   f x ` set (add_leaves (Branch l\\<^sub>2 r\\<^sub>2) ys))", "case (1 f x y xs ys)"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>f x y xs ys.\n       set (add_leaves (bdd_binop f (Leaf x) (Leaf y))\n             (concat (map (\\<lambda>x. map (f x) ys) xs)))\n       \\<subseteq> (\\<Union>x\\<in>set (add_leaves (Leaf x) xs).\n                       f x ` set (add_leaves (Leaf y) ys))\n 2. \\<And>f l r y xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   set (add_leaves (bdd_binop f l (Leaf y))\n                         (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                   \\<subseteq> (\\<Union>x\\<in>set (add_leaves l xs).\n                                   f x ` set (add_leaves (Leaf y) ys));\n        \\<And>xs ys.\n           set (add_leaves (bdd_binop f r (Leaf y))\n                 (concat (map (\\<lambda>x. map (f x) ys) xs)))\n           \\<subseteq> (\\<Union>x\\<in>set (add_leaves r xs).\n                           f x ` set (add_leaves (Leaf y) ys))\\<rbrakk>\n       \\<Longrightarrow> set (add_leaves (bdd_binop f (Branch l r) (Leaf y))\n                               (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                         \\<subseteq> (\\<Union>x\\<in>set\n               (add_leaves (Branch l r) xs).\n   f x ` set (add_leaves (Leaf y) ys))\n 3. \\<And>f x l r xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   set (add_leaves (bdd_binop f (Leaf x) l)\n                         (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                   \\<subseteq> (\\<Union>x\\<in>set (add_leaves (Leaf x) xs).\n                                   f x ` set (add_leaves l ys));\n        \\<And>xs ys.\n           set (add_leaves (bdd_binop f (Leaf x) r)\n                 (concat (map (\\<lambda>x. map (f x) ys) xs)))\n           \\<subseteq> (\\<Union>x\\<in>set (add_leaves (Leaf x) xs).\n                           f x ` set (add_leaves r ys))\\<rbrakk>\n       \\<Longrightarrow> set (add_leaves (bdd_binop f (Leaf x) (Branch l r))\n                               (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                         \\<subseteq> (\\<Union>x\\<in>set\n               (add_leaves (Leaf x) xs).\n   f x ` set (add_leaves (Branch l r) ys))\n 4. \\<And>f l\\<^sub>1 r\\<^sub>1 l\\<^sub>2 r\\<^sub>2 xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   set (add_leaves (bdd_binop f l\\<^sub>1 l\\<^sub>2)\n                         (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                   \\<subseteq> (\\<Union>x\\<in>set (add_leaves l\\<^sub>1 xs).\n                                   f x ` set (add_leaves l\\<^sub>2 ys));\n        \\<And>xs ys.\n           set (add_leaves (bdd_binop f r\\<^sub>1 r\\<^sub>2)\n                 (concat (map (\\<lambda>x. map (f x) ys) xs)))\n           \\<subseteq> (\\<Union>x\\<in>set (add_leaves r\\<^sub>1 xs).\n                           f x ` set (add_leaves r\\<^sub>2 ys))\\<rbrakk>\n       \\<Longrightarrow> set (add_leaves\n                               (bdd_binop f (Branch l\\<^sub>1 r\\<^sub>1)\n                                 (Branch l\\<^sub>2 r\\<^sub>2))\n                               (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                         \\<subseteq> (\\<Union>x\\<in>set\n               (add_leaves (Branch l\\<^sub>1 r\\<^sub>1) xs).\n   f x ` set (add_leaves (Branch l\\<^sub>2 r\\<^sub>2) ys))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (add_leaves (bdd_binop f (Leaf x) (Leaf y))\n          (concat (map (\\<lambda>x. map (f x) ys) xs)))\n    \\<subseteq> (\\<Union>x\\<in>set (add_leaves (Leaf x) xs).\n                    f x ` set (add_leaves (Leaf y) ys))", "by auto"], ["proof (state)\nthis:\n  set (add_leaves (bdd_binop f (Leaf x) (Leaf y))\n        (concat (map (\\<lambda>x. map (f x) ys) xs)))\n  \\<subseteq> (\\<Union>x\\<in>set (add_leaves (Leaf x) xs).\n                  f x ` set (add_leaves (Leaf y) ys))\n\ngoal (3 subgoals):\n 1. \\<And>f l r y xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   set (add_leaves (bdd_binop f l (Leaf y))\n                         (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                   \\<subseteq> (\\<Union>x\\<in>set (add_leaves l xs).\n                                   f x ` set (add_leaves (Leaf y) ys));\n        \\<And>xs ys.\n           set (add_leaves (bdd_binop f r (Leaf y))\n                 (concat (map (\\<lambda>x. map (f x) ys) xs)))\n           \\<subseteq> (\\<Union>x\\<in>set (add_leaves r xs).\n                           f x ` set (add_leaves (Leaf y) ys))\\<rbrakk>\n       \\<Longrightarrow> set (add_leaves (bdd_binop f (Branch l r) (Leaf y))\n                               (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                         \\<subseteq> (\\<Union>x\\<in>set\n               (add_leaves (Branch l r) xs).\n   f x ` set (add_leaves (Leaf y) ys))\n 2. \\<And>f x l r xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   set (add_leaves (bdd_binop f (Leaf x) l)\n                         (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                   \\<subseteq> (\\<Union>x\\<in>set (add_leaves (Leaf x) xs).\n                                   f x ` set (add_leaves l ys));\n        \\<And>xs ys.\n           set (add_leaves (bdd_binop f (Leaf x) r)\n                 (concat (map (\\<lambda>x. map (f x) ys) xs)))\n           \\<subseteq> (\\<Union>x\\<in>set (add_leaves (Leaf x) xs).\n                           f x ` set (add_leaves r ys))\\<rbrakk>\n       \\<Longrightarrow> set (add_leaves (bdd_binop f (Leaf x) (Branch l r))\n                               (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                         \\<subseteq> (\\<Union>x\\<in>set\n               (add_leaves (Leaf x) xs).\n   f x ` set (add_leaves (Branch l r) ys))\n 3. \\<And>f l\\<^sub>1 r\\<^sub>1 l\\<^sub>2 r\\<^sub>2 xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   set (add_leaves (bdd_binop f l\\<^sub>1 l\\<^sub>2)\n                         (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                   \\<subseteq> (\\<Union>x\\<in>set (add_leaves l\\<^sub>1 xs).\n                                   f x ` set (add_leaves l\\<^sub>2 ys));\n        \\<And>xs ys.\n           set (add_leaves (bdd_binop f r\\<^sub>1 r\\<^sub>2)\n                 (concat (map (\\<lambda>x. map (f x) ys) xs)))\n           \\<subseteq> (\\<Union>x\\<in>set (add_leaves r\\<^sub>1 xs).\n                           f x ` set (add_leaves r\\<^sub>2 ys))\\<rbrakk>\n       \\<Longrightarrow> set (add_leaves\n                               (bdd_binop f (Branch l\\<^sub>1 r\\<^sub>1)\n                                 (Branch l\\<^sub>2 r\\<^sub>2))\n                               (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                         \\<subseteq> (\\<Union>x\\<in>set\n               (add_leaves (Branch l\\<^sub>1 r\\<^sub>1) xs).\n   f x ` set (add_leaves (Branch l\\<^sub>2 r\\<^sub>2) ys))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>f l r y xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   set (add_leaves (bdd_binop f l (Leaf y))\n                         (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                   \\<subseteq> (\\<Union>x\\<in>set (add_leaves l xs).\n                                   f x ` set (add_leaves (Leaf y) ys));\n        \\<And>xs ys.\n           set (add_leaves (bdd_binop f r (Leaf y))\n                 (concat (map (\\<lambda>x. map (f x) ys) xs)))\n           \\<subseteq> (\\<Union>x\\<in>set (add_leaves r xs).\n                           f x ` set (add_leaves (Leaf y) ys))\\<rbrakk>\n       \\<Longrightarrow> set (add_leaves (bdd_binop f (Branch l r) (Leaf y))\n                               (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                         \\<subseteq> (\\<Union>x\\<in>set\n               (add_leaves (Branch l r) xs).\n   f x ` set (add_leaves (Leaf y) ys))\n 2. \\<And>f x l r xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   set (add_leaves (bdd_binop f (Leaf x) l)\n                         (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                   \\<subseteq> (\\<Union>x\\<in>set (add_leaves (Leaf x) xs).\n                                   f x ` set (add_leaves l ys));\n        \\<And>xs ys.\n           set (add_leaves (bdd_binop f (Leaf x) r)\n                 (concat (map (\\<lambda>x. map (f x) ys) xs)))\n           \\<subseteq> (\\<Union>x\\<in>set (add_leaves (Leaf x) xs).\n                           f x ` set (add_leaves r ys))\\<rbrakk>\n       \\<Longrightarrow> set (add_leaves (bdd_binop f (Leaf x) (Branch l r))\n                               (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                         \\<subseteq> (\\<Union>x\\<in>set\n               (add_leaves (Leaf x) xs).\n   f x ` set (add_leaves (Branch l r) ys))\n 3. \\<And>f l\\<^sub>1 r\\<^sub>1 l\\<^sub>2 r\\<^sub>2 xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   set (add_leaves (bdd_binop f l\\<^sub>1 l\\<^sub>2)\n                         (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                   \\<subseteq> (\\<Union>x\\<in>set (add_leaves l\\<^sub>1 xs).\n                                   f x ` set (add_leaves l\\<^sub>2 ys));\n        \\<And>xs ys.\n           set (add_leaves (bdd_binop f r\\<^sub>1 r\\<^sub>2)\n                 (concat (map (\\<lambda>x. map (f x) ys) xs)))\n           \\<subseteq> (\\<Union>x\\<in>set (add_leaves r\\<^sub>1 xs).\n                           f x ` set (add_leaves r\\<^sub>2 ys))\\<rbrakk>\n       \\<Longrightarrow> set (add_leaves\n                               (bdd_binop f (Branch l\\<^sub>1 r\\<^sub>1)\n                                 (Branch l\\<^sub>2 r\\<^sub>2))\n                               (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                         \\<subseteq> (\\<Union>x\\<in>set\n               (add_leaves (Branch l\\<^sub>1 r\\<^sub>1) xs).\n   f x ` set (add_leaves (Branch l\\<^sub>2 r\\<^sub>2) ys))", "case (2 f l r y xs ys)"], ["proof (state)\nthis:\n  set (add_leaves (bdd_binop f l (Leaf y))\n        (concat (map (\\<lambda>x. map (f x) ?ys) ?xs)))\n  \\<subseteq> (\\<Union>x\\<in>set (add_leaves l ?xs).\n                  f x ` set (add_leaves (Leaf y) ?ys))\n  set (add_leaves (bdd_binop f r (Leaf y))\n        (concat (map (\\<lambda>x. map (f x) ?ys) ?xs)))\n  \\<subseteq> (\\<Union>x\\<in>set (add_leaves r ?xs).\n                  f x ` set (add_leaves (Leaf y) ?ys))\n\ngoal (3 subgoals):\n 1. \\<And>f l r y xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   set (add_leaves (bdd_binop f l (Leaf y))\n                         (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                   \\<subseteq> (\\<Union>x\\<in>set (add_leaves l xs).\n                                   f x ` set (add_leaves (Leaf y) ys));\n        \\<And>xs ys.\n           set (add_leaves (bdd_binop f r (Leaf y))\n                 (concat (map (\\<lambda>x. map (f x) ys) xs)))\n           \\<subseteq> (\\<Union>x\\<in>set (add_leaves r xs).\n                           f x ` set (add_leaves (Leaf y) ys))\\<rbrakk>\n       \\<Longrightarrow> set (add_leaves (bdd_binop f (Branch l r) (Leaf y))\n                               (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                         \\<subseteq> (\\<Union>x\\<in>set\n               (add_leaves (Branch l r) xs).\n   f x ` set (add_leaves (Leaf y) ys))\n 2. \\<And>f x l r xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   set (add_leaves (bdd_binop f (Leaf x) l)\n                         (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                   \\<subseteq> (\\<Union>x\\<in>set (add_leaves (Leaf x) xs).\n                                   f x ` set (add_leaves l ys));\n        \\<And>xs ys.\n           set (add_leaves (bdd_binop f (Leaf x) r)\n                 (concat (map (\\<lambda>x. map (f x) ys) xs)))\n           \\<subseteq> (\\<Union>x\\<in>set (add_leaves (Leaf x) xs).\n                           f x ` set (add_leaves r ys))\\<rbrakk>\n       \\<Longrightarrow> set (add_leaves (bdd_binop f (Leaf x) (Branch l r))\n                               (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                         \\<subseteq> (\\<Union>x\\<in>set\n               (add_leaves (Leaf x) xs).\n   f x ` set (add_leaves (Branch l r) ys))\n 3. \\<And>f l\\<^sub>1 r\\<^sub>1 l\\<^sub>2 r\\<^sub>2 xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   set (add_leaves (bdd_binop f l\\<^sub>1 l\\<^sub>2)\n                         (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                   \\<subseteq> (\\<Union>x\\<in>set (add_leaves l\\<^sub>1 xs).\n                                   f x ` set (add_leaves l\\<^sub>2 ys));\n        \\<And>xs ys.\n           set (add_leaves (bdd_binop f r\\<^sub>1 r\\<^sub>2)\n                 (concat (map (\\<lambda>x. map (f x) ys) xs)))\n           \\<subseteq> (\\<Union>x\\<in>set (add_leaves r\\<^sub>1 xs).\n                           f x ` set (add_leaves r\\<^sub>2 ys))\\<rbrakk>\n       \\<Longrightarrow> set (add_leaves\n                               (bdd_binop f (Branch l\\<^sub>1 r\\<^sub>1)\n                                 (Branch l\\<^sub>2 r\\<^sub>2))\n                               (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                         \\<subseteq> (\\<Union>x\\<in>set\n               (add_leaves (Branch l\\<^sub>1 r\\<^sub>1) xs).\n   f x ` set (add_leaves (Branch l\\<^sub>2 r\\<^sub>2) ys))", "then"], ["proof (chain)\npicking this:\n  set (add_leaves (bdd_binop f l (Leaf y))\n        (concat (map (\\<lambda>x. map (f x) ?ys) ?xs)))\n  \\<subseteq> (\\<Union>x\\<in>set (add_leaves l ?xs).\n                  f x ` set (add_leaves (Leaf y) ?ys))\n  set (add_leaves (bdd_binop f r (Leaf y))\n        (concat (map (\\<lambda>x. map (f x) ?ys) ?xs)))\n  \\<subseteq> (\\<Union>x\\<in>set (add_leaves r ?xs).\n                  f x ` set (add_leaves (Leaf y) ?ys))", "show ?case"], ["proof (prove)\nusing this:\n  set (add_leaves (bdd_binop f l (Leaf y))\n        (concat (map (\\<lambda>x. map (f x) ?ys) ?xs)))\n  \\<subseteq> (\\<Union>x\\<in>set (add_leaves l ?xs).\n                  f x ` set (add_leaves (Leaf y) ?ys))\n  set (add_leaves (bdd_binop f r (Leaf y))\n        (concat (map (\\<lambda>x. map (f x) ?ys) ?xs)))\n  \\<subseteq> (\\<Union>x\\<in>set (add_leaves r ?xs).\n                  f x ` set (add_leaves (Leaf y) ?ys))\n\ngoal (1 subgoal):\n 1. set (add_leaves (bdd_binop f (Branch l r) (Leaf y))\n          (concat (map (\\<lambda>x. map (f x) ys) xs)))\n    \\<subseteq> (\\<Union>x\\<in>set (add_leaves (Branch l r) xs).\n                    f x ` set (add_leaves (Leaf y) ys))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>ys xs.\n                   set (add_leaves (bdd_binop f l (Leaf y))\n                         (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                   \\<subseteq> (\\<Union>x\\<in>set (add_leaves l xs).\n                                   insert (f x y) (f x ` set ys));\n        \\<And>ys xs.\n           set (add_leaves (bdd_binop f r (Leaf y))\n                 (concat (map (\\<lambda>x. map (f x) ys) xs)))\n           \\<subseteq> (\\<Union>x\\<in>set (add_leaves r xs).\n                           insert (f x y) (f x ` set ys));\n        x \\<in> set (add_leaves (bdd_binop f r (Leaf y))\n                      (add_leaves (bdd_binop f l (Leaf y))\n                        (concat\n                          (map (\\<lambda>x. map (f x) ys) xs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>set\n    (add_leaves r (add_leaves l xs)).\n                            x = f xa y \\<or> x \\<in> f xa ` set ys", "apply (drule_tac ys1=\"[f x y. x \\<leftarrow> add_leaves l xs, y \\<leftarrow> List.insert y ys]\" in\n      rev_subsetD [OF _ add_leaves_mono])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>ys xs.\n                   set (add_leaves (bdd_binop f l (Leaf y))\n                         (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                   \\<subseteq> (\\<Union>x\\<in>set (add_leaves l xs).\n                                   insert (f x y) (f x ` set ys));\n        \\<And>ys xs.\n           set (add_leaves (bdd_binop f r (Leaf y))\n                 (concat (map (\\<lambda>x. map (f x) ys) xs)))\n           \\<subseteq> (\\<Union>x\\<in>set (add_leaves r xs).\n                           insert (f x y) (f x ` set ys))\\<rbrakk>\n       \\<Longrightarrow> set (add_leaves (bdd_binop f l (Leaf y))\n                               (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                         \\<subseteq> set\n(concat (map (\\<lambda>x. map (f x) (List.insert y ys)) (add_leaves l xs)))\n 2. \\<And>x.\n       \\<lbrakk>\\<And>ys xs.\n                   set (add_leaves (bdd_binop f l (Leaf y))\n                         (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                   \\<subseteq> (\\<Union>x\\<in>set (add_leaves l xs).\n                                   insert (f x y) (f x ` set ys));\n        \\<And>ys xs.\n           set (add_leaves (bdd_binop f r (Leaf y))\n                 (concat (map (\\<lambda>x. map (f x) ys) xs)))\n           \\<subseteq> (\\<Union>x\\<in>set (add_leaves r xs).\n                           insert (f x y) (f x ` set ys));\n        x \\<in> set (add_leaves (bdd_binop f r (Leaf y))\n                      (concat\n                        (map (\\<lambda>x. map (f x) (List.insert y ys))\n                          (add_leaves l xs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>set\n    (add_leaves r (add_leaves l xs)).\n                            x = f xa y \\<or> x \\<in> f xa ` set ys", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>ys xs.\n                   set (add_leaves (bdd_binop f l (Leaf y))\n                         (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                   \\<subseteq> (\\<Union>x\\<in>set (add_leaves l xs).\n                                   insert (f x y) (f x ` set ys));\n        \\<And>ys xs.\n           set (add_leaves (bdd_binop f r (Leaf y))\n                 (concat (map (\\<lambda>x. map (f x) ys) xs)))\n           \\<subseteq> (\\<Union>x\\<in>set (add_leaves r xs).\n                           insert (f x y) (f x ` set ys));\n        x \\<in> set (add_leaves (bdd_binop f r (Leaf y))\n                      (concat\n                        (map (\\<lambda>x. map (f x) (List.insert y ys))\n                          (add_leaves l xs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>set\n    (add_leaves r (add_leaves l xs)).\n                            x = f xa y \\<or> x \\<in> f xa ` set ys", "apply (drule meta_spec, drule meta_spec, drule subsetD, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>ys xs.\n                   set (add_leaves (bdd_binop f l (Leaf y))\n                         (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                   \\<subseteq> (\\<Union>x\\<in>set (add_leaves l xs).\n                                   insert (f x y) (f x ` set ys));\n        x \\<in> set (add_leaves (bdd_binop f r (Leaf y))\n                      (concat\n                        (map (\\<lambda>x. map (f x) (List.insert y ys))\n                          (add_leaves l xs))));\n        x \\<in> (\\<Union>x\\<in>set (add_leaves r (add_leaves l xs)).\n                    insert (f x y) (f x ` set (List.insert y ys)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>set\n    (add_leaves r (add_leaves l xs)).\n                            x = f xa y \\<or> x \\<in> f xa ` set ys", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  set (add_leaves (bdd_binop f (Branch l r) (Leaf y))\n        (concat (map (\\<lambda>x. map (f x) ys) xs)))\n  \\<subseteq> (\\<Union>x\\<in>set (add_leaves (Branch l r) xs).\n                  f x ` set (add_leaves (Leaf y) ys))\n\ngoal (2 subgoals):\n 1. \\<And>f x l r xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   set (add_leaves (bdd_binop f (Leaf x) l)\n                         (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                   \\<subseteq> (\\<Union>x\\<in>set (add_leaves (Leaf x) xs).\n                                   f x ` set (add_leaves l ys));\n        \\<And>xs ys.\n           set (add_leaves (bdd_binop f (Leaf x) r)\n                 (concat (map (\\<lambda>x. map (f x) ys) xs)))\n           \\<subseteq> (\\<Union>x\\<in>set (add_leaves (Leaf x) xs).\n                           f x ` set (add_leaves r ys))\\<rbrakk>\n       \\<Longrightarrow> set (add_leaves (bdd_binop f (Leaf x) (Branch l r))\n                               (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                         \\<subseteq> (\\<Union>x\\<in>set\n               (add_leaves (Leaf x) xs).\n   f x ` set (add_leaves (Branch l r) ys))\n 2. \\<And>f l\\<^sub>1 r\\<^sub>1 l\\<^sub>2 r\\<^sub>2 xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   set (add_leaves (bdd_binop f l\\<^sub>1 l\\<^sub>2)\n                         (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                   \\<subseteq> (\\<Union>x\\<in>set (add_leaves l\\<^sub>1 xs).\n                                   f x ` set (add_leaves l\\<^sub>2 ys));\n        \\<And>xs ys.\n           set (add_leaves (bdd_binop f r\\<^sub>1 r\\<^sub>2)\n                 (concat (map (\\<lambda>x. map (f x) ys) xs)))\n           \\<subseteq> (\\<Union>x\\<in>set (add_leaves r\\<^sub>1 xs).\n                           f x ` set (add_leaves r\\<^sub>2 ys))\\<rbrakk>\n       \\<Longrightarrow> set (add_leaves\n                               (bdd_binop f (Branch l\\<^sub>1 r\\<^sub>1)\n                                 (Branch l\\<^sub>2 r\\<^sub>2))\n                               (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                         \\<subseteq> (\\<Union>x\\<in>set\n               (add_leaves (Branch l\\<^sub>1 r\\<^sub>1) xs).\n   f x ` set (add_leaves (Branch l\\<^sub>2 r\\<^sub>2) ys))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f x l r xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   set (add_leaves (bdd_binop f (Leaf x) l)\n                         (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                   \\<subseteq> (\\<Union>x\\<in>set (add_leaves (Leaf x) xs).\n                                   f x ` set (add_leaves l ys));\n        \\<And>xs ys.\n           set (add_leaves (bdd_binop f (Leaf x) r)\n                 (concat (map (\\<lambda>x. map (f x) ys) xs)))\n           \\<subseteq> (\\<Union>x\\<in>set (add_leaves (Leaf x) xs).\n                           f x ` set (add_leaves r ys))\\<rbrakk>\n       \\<Longrightarrow> set (add_leaves (bdd_binop f (Leaf x) (Branch l r))\n                               (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                         \\<subseteq> (\\<Union>x\\<in>set\n               (add_leaves (Leaf x) xs).\n   f x ` set (add_leaves (Branch l r) ys))\n 2. \\<And>f l\\<^sub>1 r\\<^sub>1 l\\<^sub>2 r\\<^sub>2 xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   set (add_leaves (bdd_binop f l\\<^sub>1 l\\<^sub>2)\n                         (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                   \\<subseteq> (\\<Union>x\\<in>set (add_leaves l\\<^sub>1 xs).\n                                   f x ` set (add_leaves l\\<^sub>2 ys));\n        \\<And>xs ys.\n           set (add_leaves (bdd_binop f r\\<^sub>1 r\\<^sub>2)\n                 (concat (map (\\<lambda>x. map (f x) ys) xs)))\n           \\<subseteq> (\\<Union>x\\<in>set (add_leaves r\\<^sub>1 xs).\n                           f x ` set (add_leaves r\\<^sub>2 ys))\\<rbrakk>\n       \\<Longrightarrow> set (add_leaves\n                               (bdd_binop f (Branch l\\<^sub>1 r\\<^sub>1)\n                                 (Branch l\\<^sub>2 r\\<^sub>2))\n                               (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                         \\<subseteq> (\\<Union>x\\<in>set\n               (add_leaves (Branch l\\<^sub>1 r\\<^sub>1) xs).\n   f x ` set (add_leaves (Branch l\\<^sub>2 r\\<^sub>2) ys))", "case (3 f x l r xs ys)"], ["proof (state)\nthis:\n  set (add_leaves (bdd_binop f (Leaf x) l)\n        (concat (map (\\<lambda>x. map (f x) ?ys) ?xs)))\n  \\<subseteq> (\\<Union>x\\<in>set (add_leaves (Leaf x) ?xs).\n                  f x ` set (add_leaves l ?ys))\n  set (add_leaves (bdd_binop f (Leaf x) r)\n        (concat (map (\\<lambda>x. map (f x) ?ys) ?xs)))\n  \\<subseteq> (\\<Union>x\\<in>set (add_leaves (Leaf x) ?xs).\n                  f x ` set (add_leaves r ?ys))\n\ngoal (2 subgoals):\n 1. \\<And>f x l r xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   set (add_leaves (bdd_binop f (Leaf x) l)\n                         (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                   \\<subseteq> (\\<Union>x\\<in>set (add_leaves (Leaf x) xs).\n                                   f x ` set (add_leaves l ys));\n        \\<And>xs ys.\n           set (add_leaves (bdd_binop f (Leaf x) r)\n                 (concat (map (\\<lambda>x. map (f x) ys) xs)))\n           \\<subseteq> (\\<Union>x\\<in>set (add_leaves (Leaf x) xs).\n                           f x ` set (add_leaves r ys))\\<rbrakk>\n       \\<Longrightarrow> set (add_leaves (bdd_binop f (Leaf x) (Branch l r))\n                               (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                         \\<subseteq> (\\<Union>x\\<in>set\n               (add_leaves (Leaf x) xs).\n   f x ` set (add_leaves (Branch l r) ys))\n 2. \\<And>f l\\<^sub>1 r\\<^sub>1 l\\<^sub>2 r\\<^sub>2 xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   set (add_leaves (bdd_binop f l\\<^sub>1 l\\<^sub>2)\n                         (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                   \\<subseteq> (\\<Union>x\\<in>set (add_leaves l\\<^sub>1 xs).\n                                   f x ` set (add_leaves l\\<^sub>2 ys));\n        \\<And>xs ys.\n           set (add_leaves (bdd_binop f r\\<^sub>1 r\\<^sub>2)\n                 (concat (map (\\<lambda>x. map (f x) ys) xs)))\n           \\<subseteq> (\\<Union>x\\<in>set (add_leaves r\\<^sub>1 xs).\n                           f x ` set (add_leaves r\\<^sub>2 ys))\\<rbrakk>\n       \\<Longrightarrow> set (add_leaves\n                               (bdd_binop f (Branch l\\<^sub>1 r\\<^sub>1)\n                                 (Branch l\\<^sub>2 r\\<^sub>2))\n                               (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                         \\<subseteq> (\\<Union>x\\<in>set\n               (add_leaves (Branch l\\<^sub>1 r\\<^sub>1) xs).\n   f x ` set (add_leaves (Branch l\\<^sub>2 r\\<^sub>2) ys))", "then"], ["proof (chain)\npicking this:\n  set (add_leaves (bdd_binop f (Leaf x) l)\n        (concat (map (\\<lambda>x. map (f x) ?ys) ?xs)))\n  \\<subseteq> (\\<Union>x\\<in>set (add_leaves (Leaf x) ?xs).\n                  f x ` set (add_leaves l ?ys))\n  set (add_leaves (bdd_binop f (Leaf x) r)\n        (concat (map (\\<lambda>x. map (f x) ?ys) ?xs)))\n  \\<subseteq> (\\<Union>x\\<in>set (add_leaves (Leaf x) ?xs).\n                  f x ` set (add_leaves r ?ys))", "show ?case"], ["proof (prove)\nusing this:\n  set (add_leaves (bdd_binop f (Leaf x) l)\n        (concat (map (\\<lambda>x. map (f x) ?ys) ?xs)))\n  \\<subseteq> (\\<Union>x\\<in>set (add_leaves (Leaf x) ?xs).\n                  f x ` set (add_leaves l ?ys))\n  set (add_leaves (bdd_binop f (Leaf x) r)\n        (concat (map (\\<lambda>x. map (f x) ?ys) ?xs)))\n  \\<subseteq> (\\<Union>x\\<in>set (add_leaves (Leaf x) ?xs).\n                  f x ` set (add_leaves r ?ys))\n\ngoal (1 subgoal):\n 1. set (add_leaves (bdd_binop f (Leaf x) (Branch l r))\n          (concat (map (\\<lambda>x. map (f x) ys) xs)))\n    \\<subseteq> (\\<Union>x\\<in>set (add_leaves (Leaf x) xs).\n                    f x ` set (add_leaves (Branch l r) ys))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<And>ys xs.\n                   set (add_leaves (bdd_binop f (Leaf x) l)\n                         (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                   \\<subseteq> f x ` set (add_leaves l ys) \\<union>\n                               (\\<Union>x\\<in>set xs.\n                                   f x ` set (add_leaves l ys));\n        \\<And>ys xs.\n           set (add_leaves (bdd_binop f (Leaf x) r)\n                 (concat (map (\\<lambda>x. map (f x) ys) xs)))\n           \\<subseteq> f x ` set (add_leaves r ys) \\<union>\n                       (\\<Union>x\\<in>set xs. f x ` set (add_leaves r ys));\n        xa \\<in> set (add_leaves (bdd_binop f (Leaf x) r)\n                       (add_leaves (bdd_binop f (Leaf x) l)\n                         (concat (map (\\<lambda>x. map (f x) ys) xs))));\n        \\<forall>x\\<in>set xs.\n           xa \\<notin> f x ` set (add_leaves r (add_leaves l ys))\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> f x ` set (add_leaves r (add_leaves l ys))", "apply (drule_tac ys1=\"[f x y. x \\<leftarrow> List.insert x xs, y \\<leftarrow> add_leaves l ys]\" in\n      rev_subsetD [OF _ add_leaves_mono])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>\\<And>ys xs.\n                   set (add_leaves (bdd_binop f (Leaf x) l)\n                         (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                   \\<subseteq> f x ` set (add_leaves l ys) \\<union>\n                               (\\<Union>x\\<in>set xs.\n                                   f x ` set (add_leaves l ys));\n        \\<And>ys xs.\n           set (add_leaves (bdd_binop f (Leaf x) r)\n                 (concat (map (\\<lambda>x. map (f x) ys) xs)))\n           \\<subseteq> f x ` set (add_leaves r ys) \\<union>\n                       (\\<Union>x\\<in>set xs. f x ` set (add_leaves r ys));\n        \\<forall>x\\<in>set xs.\n           xa \\<notin> f x ` set (add_leaves r (add_leaves l ys))\\<rbrakk>\n       \\<Longrightarrow> set (add_leaves (bdd_binop f (Leaf x) l)\n                               (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                         \\<subseteq> set\n(concat (map (\\<lambda>x. map (f x) (add_leaves l ys)) (List.insert x xs)))\n 2. \\<And>xa.\n       \\<lbrakk>\\<And>ys xs.\n                   set (add_leaves (bdd_binop f (Leaf x) l)\n                         (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                   \\<subseteq> f x ` set (add_leaves l ys) \\<union>\n                               (\\<Union>x\\<in>set xs.\n                                   f x ` set (add_leaves l ys));\n        \\<And>ys xs.\n           set (add_leaves (bdd_binop f (Leaf x) r)\n                 (concat (map (\\<lambda>x. map (f x) ys) xs)))\n           \\<subseteq> f x ` set (add_leaves r ys) \\<union>\n                       (\\<Union>x\\<in>set xs. f x ` set (add_leaves r ys));\n        \\<forall>x\\<in>set xs.\n           xa \\<notin> f x ` set (add_leaves r (add_leaves l ys));\n        xa \\<in> set (add_leaves (bdd_binop f (Leaf x) r)\n                       (concat\n                         (map (\\<lambda>x. map (f x) (add_leaves l ys))\n                           (List.insert x xs))))\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> f x ` set (add_leaves r (add_leaves l ys))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<And>ys xs.\n                   set (add_leaves (bdd_binop f (Leaf x) l)\n                         (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                   \\<subseteq> f x ` set (add_leaves l ys) \\<union>\n                               (\\<Union>x\\<in>set xs.\n                                   f x ` set (add_leaves l ys));\n        \\<And>ys xs.\n           set (add_leaves (bdd_binop f (Leaf x) r)\n                 (concat (map (\\<lambda>x. map (f x) ys) xs)))\n           \\<subseteq> f x ` set (add_leaves r ys) \\<union>\n                       (\\<Union>x\\<in>set xs. f x ` set (add_leaves r ys));\n        \\<forall>x\\<in>set xs.\n           xa \\<notin> f x ` set (add_leaves r (add_leaves l ys));\n        xa \\<in> set (add_leaves (bdd_binop f (Leaf x) r)\n                       (concat\n                         (map (\\<lambda>x. map (f x) (add_leaves l ys))\n                           (List.insert x xs))))\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> f x ` set (add_leaves r (add_leaves l ys))", "apply (drule meta_spec, drule meta_spec, drule subsetD, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<And>ys xs.\n                   set (add_leaves (bdd_binop f (Leaf x) l)\n                         (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                   \\<subseteq> f x ` set (add_leaves l ys) \\<union>\n                               (\\<Union>x\\<in>set xs.\n                                   f x ` set (add_leaves l ys));\n        \\<forall>x\\<in>set xs.\n           xa \\<notin> f x ` set (add_leaves r (add_leaves l ys));\n        xa \\<in> set (add_leaves (bdd_binop f (Leaf x) r)\n                       (concat\n                         (map (\\<lambda>x. map (f x) (add_leaves l ys))\n                           (List.insert x xs))));\n        xa \\<in> f x ` set (add_leaves r (add_leaves l ys)) \\<union>\n                 (\\<Union>x\\<in>set (List.insert x xs).\n                     f x ` set (add_leaves r (add_leaves l ys)))\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> f x ` set (add_leaves r (add_leaves l ys))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  set (add_leaves (bdd_binop f (Leaf x) (Branch l r))\n        (concat (map (\\<lambda>x. map (f x) ys) xs)))\n  \\<subseteq> (\\<Union>x\\<in>set (add_leaves (Leaf x) xs).\n                  f x ` set (add_leaves (Branch l r) ys))\n\ngoal (1 subgoal):\n 1. \\<And>f l\\<^sub>1 r\\<^sub>1 l\\<^sub>2 r\\<^sub>2 xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   set (add_leaves (bdd_binop f l\\<^sub>1 l\\<^sub>2)\n                         (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                   \\<subseteq> (\\<Union>x\\<in>set (add_leaves l\\<^sub>1 xs).\n                                   f x ` set (add_leaves l\\<^sub>2 ys));\n        \\<And>xs ys.\n           set (add_leaves (bdd_binop f r\\<^sub>1 r\\<^sub>2)\n                 (concat (map (\\<lambda>x. map (f x) ys) xs)))\n           \\<subseteq> (\\<Union>x\\<in>set (add_leaves r\\<^sub>1 xs).\n                           f x ` set (add_leaves r\\<^sub>2 ys))\\<rbrakk>\n       \\<Longrightarrow> set (add_leaves\n                               (bdd_binop f (Branch l\\<^sub>1 r\\<^sub>1)\n                                 (Branch l\\<^sub>2 r\\<^sub>2))\n                               (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                         \\<subseteq> (\\<Union>x\\<in>set\n               (add_leaves (Branch l\\<^sub>1 r\\<^sub>1) xs).\n   f x ` set (add_leaves (Branch l\\<^sub>2 r\\<^sub>2) ys))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f l\\<^sub>1 r\\<^sub>1 l\\<^sub>2 r\\<^sub>2 xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   set (add_leaves (bdd_binop f l\\<^sub>1 l\\<^sub>2)\n                         (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                   \\<subseteq> (\\<Union>x\\<in>set (add_leaves l\\<^sub>1 xs).\n                                   f x ` set (add_leaves l\\<^sub>2 ys));\n        \\<And>xs ys.\n           set (add_leaves (bdd_binop f r\\<^sub>1 r\\<^sub>2)\n                 (concat (map (\\<lambda>x. map (f x) ys) xs)))\n           \\<subseteq> (\\<Union>x\\<in>set (add_leaves r\\<^sub>1 xs).\n                           f x ` set (add_leaves r\\<^sub>2 ys))\\<rbrakk>\n       \\<Longrightarrow> set (add_leaves\n                               (bdd_binop f (Branch l\\<^sub>1 r\\<^sub>1)\n                                 (Branch l\\<^sub>2 r\\<^sub>2))\n                               (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                         \\<subseteq> (\\<Union>x\\<in>set\n               (add_leaves (Branch l\\<^sub>1 r\\<^sub>1) xs).\n   f x ` set (add_leaves (Branch l\\<^sub>2 r\\<^sub>2) ys))", "case (4 f l\\<^sub>1 r\\<^sub>1 l\\<^sub>2 r\\<^sub>2 xs ys)"], ["proof (state)\nthis:\n  set (add_leaves (bdd_binop f l\\<^sub>1 l\\<^sub>2)\n        (concat (map (\\<lambda>x. map (f x) ?ys) ?xs)))\n  \\<subseteq> (\\<Union>x\\<in>set (add_leaves l\\<^sub>1 ?xs).\n                  f x ` set (add_leaves l\\<^sub>2 ?ys))\n  set (add_leaves (bdd_binop f r\\<^sub>1 r\\<^sub>2)\n        (concat (map (\\<lambda>x. map (f x) ?ys) ?xs)))\n  \\<subseteq> (\\<Union>x\\<in>set (add_leaves r\\<^sub>1 ?xs).\n                  f x ` set (add_leaves r\\<^sub>2 ?ys))\n\ngoal (1 subgoal):\n 1. \\<And>f l\\<^sub>1 r\\<^sub>1 l\\<^sub>2 r\\<^sub>2 xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   set (add_leaves (bdd_binop f l\\<^sub>1 l\\<^sub>2)\n                         (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                   \\<subseteq> (\\<Union>x\\<in>set (add_leaves l\\<^sub>1 xs).\n                                   f x ` set (add_leaves l\\<^sub>2 ys));\n        \\<And>xs ys.\n           set (add_leaves (bdd_binop f r\\<^sub>1 r\\<^sub>2)\n                 (concat (map (\\<lambda>x. map (f x) ys) xs)))\n           \\<subseteq> (\\<Union>x\\<in>set (add_leaves r\\<^sub>1 xs).\n                           f x ` set (add_leaves r\\<^sub>2 ys))\\<rbrakk>\n       \\<Longrightarrow> set (add_leaves\n                               (bdd_binop f (Branch l\\<^sub>1 r\\<^sub>1)\n                                 (Branch l\\<^sub>2 r\\<^sub>2))\n                               (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                         \\<subseteq> (\\<Union>x\\<in>set\n               (add_leaves (Branch l\\<^sub>1 r\\<^sub>1) xs).\n   f x ` set (add_leaves (Branch l\\<^sub>2 r\\<^sub>2) ys))", "then"], ["proof (chain)\npicking this:\n  set (add_leaves (bdd_binop f l\\<^sub>1 l\\<^sub>2)\n        (concat (map (\\<lambda>x. map (f x) ?ys) ?xs)))\n  \\<subseteq> (\\<Union>x\\<in>set (add_leaves l\\<^sub>1 ?xs).\n                  f x ` set (add_leaves l\\<^sub>2 ?ys))\n  set (add_leaves (bdd_binop f r\\<^sub>1 r\\<^sub>2)\n        (concat (map (\\<lambda>x. map (f x) ?ys) ?xs)))\n  \\<subseteq> (\\<Union>x\\<in>set (add_leaves r\\<^sub>1 ?xs).\n                  f x ` set (add_leaves r\\<^sub>2 ?ys))", "show ?case"], ["proof (prove)\nusing this:\n  set (add_leaves (bdd_binop f l\\<^sub>1 l\\<^sub>2)\n        (concat (map (\\<lambda>x. map (f x) ?ys) ?xs)))\n  \\<subseteq> (\\<Union>x\\<in>set (add_leaves l\\<^sub>1 ?xs).\n                  f x ` set (add_leaves l\\<^sub>2 ?ys))\n  set (add_leaves (bdd_binop f r\\<^sub>1 r\\<^sub>2)\n        (concat (map (\\<lambda>x. map (f x) ?ys) ?xs)))\n  \\<subseteq> (\\<Union>x\\<in>set (add_leaves r\\<^sub>1 ?xs).\n                  f x ` set (add_leaves r\\<^sub>2 ?ys))\n\ngoal (1 subgoal):\n 1. set (add_leaves\n          (bdd_binop f (Branch l\\<^sub>1 r\\<^sub>1)\n            (Branch l\\<^sub>2 r\\<^sub>2))\n          (concat (map (\\<lambda>x. map (f x) ys) xs)))\n    \\<subseteq> (\\<Union>x\\<in>set (add_leaves (Branch l\\<^sub>1 r\\<^sub>1)\n                                     xs).\n                    f x ` set (add_leaves (Branch l\\<^sub>2 r\\<^sub>2) ys))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>ys xs.\n                   set (add_leaves (bdd_binop f l\\<^sub>1 l\\<^sub>2)\n                         (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                   \\<subseteq> (\\<Union>x\\<in>set (add_leaves l\\<^sub>1 xs).\n                                   f x ` set (add_leaves l\\<^sub>2 ys));\n        \\<And>ys xs.\n           set (add_leaves (bdd_binop f r\\<^sub>1 r\\<^sub>2)\n                 (concat (map (\\<lambda>x. map (f x) ys) xs)))\n           \\<subseteq> (\\<Union>x\\<in>set (add_leaves r\\<^sub>1 xs).\n                           f x ` set (add_leaves r\\<^sub>2 ys));\n        x \\<in> set (add_leaves (bdd_binop f r\\<^sub>1 r\\<^sub>2)\n                      (add_leaves (bdd_binop f l\\<^sub>1 l\\<^sub>2)\n                        (concat\n                          (map (\\<lambda>x. map (f x) ys) xs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>set\n    (add_leaves r\\<^sub>1 (add_leaves l\\<^sub>1 xs)).\n                            x \\<in> f xa `\n                                    set (add_leaves r\\<^sub>2\n    (add_leaves l\\<^sub>2 ys))", "apply (drule_tac ys1=\"[f x y. x \\<leftarrow> add_leaves l\\<^sub>1 xs, y \\<leftarrow> add_leaves l\\<^sub>2 ys]\" in\n      rev_subsetD [OF _ add_leaves_mono])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>ys xs.\n                   set (add_leaves (bdd_binop f l\\<^sub>1 l\\<^sub>2)\n                         (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                   \\<subseteq> (\\<Union>x\\<in>set (add_leaves l\\<^sub>1 xs).\n                                   f x ` set (add_leaves l\\<^sub>2 ys));\n        \\<And>ys xs.\n           set (add_leaves (bdd_binop f r\\<^sub>1 r\\<^sub>2)\n                 (concat (map (\\<lambda>x. map (f x) ys) xs)))\n           \\<subseteq> (\\<Union>x\\<in>set (add_leaves r\\<^sub>1 xs).\n                           f x ` set (add_leaves r\\<^sub>2 ys))\\<rbrakk>\n       \\<Longrightarrow> set (add_leaves (bdd_binop f l\\<^sub>1 l\\<^sub>2)\n                               (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                         \\<subseteq> set\n(concat\n  (map (\\<lambda>x. map (f x) (add_leaves l\\<^sub>2 ys))\n    (add_leaves l\\<^sub>1 xs)))\n 2. \\<And>x.\n       \\<lbrakk>\\<And>ys xs.\n                   set (add_leaves (bdd_binop f l\\<^sub>1 l\\<^sub>2)\n                         (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                   \\<subseteq> (\\<Union>x\\<in>set (add_leaves l\\<^sub>1 xs).\n                                   f x ` set (add_leaves l\\<^sub>2 ys));\n        \\<And>ys xs.\n           set (add_leaves (bdd_binop f r\\<^sub>1 r\\<^sub>2)\n                 (concat (map (\\<lambda>x. map (f x) ys) xs)))\n           \\<subseteq> (\\<Union>x\\<in>set (add_leaves r\\<^sub>1 xs).\n                           f x ` set (add_leaves r\\<^sub>2 ys));\n        x \\<in> set (add_leaves (bdd_binop f r\\<^sub>1 r\\<^sub>2)\n                      (concat\n                        (map (\\<lambda>x.\n                                 map (f x) (add_leaves l\\<^sub>2 ys))\n                          (add_leaves l\\<^sub>1 xs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>set\n    (add_leaves r\\<^sub>1 (add_leaves l\\<^sub>1 xs)).\n                            x \\<in> f xa `\n                                    set (add_leaves r\\<^sub>2\n    (add_leaves l\\<^sub>2 ys))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>ys xs.\n                   set (add_leaves (bdd_binop f l\\<^sub>1 l\\<^sub>2)\n                         (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                   \\<subseteq> (\\<Union>x\\<in>set (add_leaves l\\<^sub>1 xs).\n                                   f x ` set (add_leaves l\\<^sub>2 ys));\n        \\<And>ys xs.\n           set (add_leaves (bdd_binop f r\\<^sub>1 r\\<^sub>2)\n                 (concat (map (\\<lambda>x. map (f x) ys) xs)))\n           \\<subseteq> (\\<Union>x\\<in>set (add_leaves r\\<^sub>1 xs).\n                           f x ` set (add_leaves r\\<^sub>2 ys));\n        x \\<in> set (add_leaves (bdd_binop f r\\<^sub>1 r\\<^sub>2)\n                      (concat\n                        (map (\\<lambda>x.\n                                 map (f x) (add_leaves l\\<^sub>2 ys))\n                          (add_leaves l\\<^sub>1 xs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>set\n    (add_leaves r\\<^sub>1 (add_leaves l\\<^sub>1 xs)).\n                            x \\<in> f xa `\n                                    set (add_leaves r\\<^sub>2\n    (add_leaves l\\<^sub>2 ys))", "apply (drule meta_spec, drule meta_spec, drule subsetD, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>ys xs.\n                   set (add_leaves (bdd_binop f l\\<^sub>1 l\\<^sub>2)\n                         (concat (map (\\<lambda>x. map (f x) ys) xs)))\n                   \\<subseteq> (\\<Union>x\\<in>set (add_leaves l\\<^sub>1 xs).\n                                   f x ` set (add_leaves l\\<^sub>2 ys));\n        x \\<in> set (add_leaves (bdd_binop f r\\<^sub>1 r\\<^sub>2)\n                      (concat\n                        (map (\\<lambda>x.\n                                 map (f x) (add_leaves l\\<^sub>2 ys))\n                          (add_leaves l\\<^sub>1 xs))));\n        x \\<in> (\\<Union>x\\<in>set (add_leaves r\\<^sub>1\n                                     (add_leaves l\\<^sub>1 xs)).\n                    f x `\n                    set (add_leaves r\\<^sub>2\n                          (add_leaves l\\<^sub>2 ys)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>set\n    (add_leaves r\\<^sub>1 (add_leaves l\\<^sub>1 xs)).\n                            x \\<in> f xa `\n                                    set (add_leaves r\\<^sub>2\n    (add_leaves l\\<^sub>2 ys))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  set (add_leaves\n        (bdd_binop f (Branch l\\<^sub>1 r\\<^sub>1)\n          (Branch l\\<^sub>2 r\\<^sub>2))\n        (concat (map (\\<lambda>x. map (f x) ys) xs)))\n  \\<subseteq> (\\<Union>x\\<in>set (add_leaves (Branch l\\<^sub>1 r\\<^sub>1)\n                                   xs).\n                  f x ` set (add_leaves (Branch l\\<^sub>2 r\\<^sub>2) ys))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (add_leaves (bdd_binop f b b')\n        (concat (map (\\<lambda>x. map (f x) ys) xs)))\n  \\<subseteq> (\\<Union>x\\<in>set (add_leaves b xs).\n                  f x ` set (add_leaves b' ys))\n\ngoal (1 subgoal):\n 1. set (add_leaves (bdd_binop f b b')\n          (concat (map (\\<lambda>x. map (f x) ys) xs)))\n    \\<subseteq> (\\<Union>x\\<in>set (add_leaves b xs).\n                    \\<Union>y\\<in>set (add_leaves b' ys). {f x y})", "also"], ["proof (state)\nthis:\n  set (add_leaves (bdd_binop f b b')\n        (concat (map (\\<lambda>x. map (f x) ys) xs)))\n  \\<subseteq> (\\<Union>x\\<in>set (add_leaves b xs).\n                  f x ` set (add_leaves b' ys))\n\ngoal (1 subgoal):\n 1. set (add_leaves (bdd_binop f b b')\n          (concat (map (\\<lambda>x. map (f x) ys) xs)))\n    \\<subseteq> (\\<Union>x\\<in>set (add_leaves b xs).\n                    \\<Union>y\\<in>set (add_leaves b' ys). {f x y})", "have \"(\\<Union>x\\<in>set (add_leaves b xs). f x ` set (add_leaves b' ys)) = ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>set (add_leaves b xs). f x ` set (add_leaves b' ys)) =\n    (\\<Union>x\\<in>set (add_leaves b xs).\n        \\<Union>y\\<in>set (add_leaves b' ys). {f x y})", "by auto"], ["proof (state)\nthis:\n  (\\<Union>x\\<in>set (add_leaves b xs). f x ` set (add_leaves b' ys)) =\n  (\\<Union>x\\<in>set (add_leaves b xs).\n      \\<Union>y\\<in>set (add_leaves b' ys). {f x y})\n\ngoal (1 subgoal):\n 1. set (add_leaves (bdd_binop f b b')\n          (concat (map (\\<lambda>x. map (f x) ys) xs)))\n    \\<subseteq> (\\<Union>x\\<in>set (add_leaves b xs).\n                    \\<Union>y\\<in>set (add_leaves b' ys). {f x y})", "finally"], ["proof (chain)\npicking this:\n  set (add_leaves (bdd_binop f b b')\n        (concat (map (\\<lambda>x. map (f x) ys) xs)))\n  \\<subseteq> (\\<Union>x\\<in>set (add_leaves b xs).\n                  \\<Union>y\\<in>set (add_leaves b' ys). {f x y})", "show ?thesis"], ["proof (prove)\nusing this:\n  set (add_leaves (bdd_binop f b b')\n        (concat (map (\\<lambda>x. map (f x) ys) xs)))\n  \\<subseteq> (\\<Union>x\\<in>set (add_leaves b xs).\n                  \\<Union>y\\<in>set (add_leaves b' ys). {f x y})\n\ngoal (1 subgoal):\n 1. set (add_leaves (bdd_binop f b b')\n          (concat (map (\\<lambda>x. map (f x) ys) xs)))\n    \\<subseteq> (\\<Union>x\\<in>set (add_leaves b xs).\n                    \\<Union>y\\<in>set (add_leaves b' ys). {f x y})", "."], ["proof (state)\nthis:\n  set (add_leaves (bdd_binop f b b')\n        (concat (map (\\<lambda>x. map (f x) ys) xs)))\n  \\<subseteq> (\\<Union>x\\<in>set (add_leaves b xs).\n                  \\<Union>y\\<in>set (add_leaves b' ys). {f x y})\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>DFAs\\<close>"], ["", "type_synonym bddtable = \"nat bdd list\""], ["", "type_synonym astate = \"bool list\""], ["", "type_synonym dfa = \"bddtable \\<times> astate\""], ["", "definition\n  dfa_is_node :: \"dfa \\<Rightarrow> nat \\<Rightarrow> bool\" where\n  \"dfa_is_node A = (\\<lambda>q. q < length (fst A))\""], ["", "definition\n  wf_dfa :: \"dfa \\<Rightarrow> nat \\<Rightarrow> bool\" where\n  \"wf_dfa A n =\n    (list_all (bddh n) (fst A) \\<and>\n     list_all (bdd_all (dfa_is_node A)) (fst A) \\<and>\n     length (snd A) = length (fst A) \\<and>\n     length (fst A) > 0)\""], ["", "definition\n  dfa_trans :: \"dfa \\<Rightarrow> nat \\<Rightarrow> bool list \\<Rightarrow> nat\" where\n  \"dfa_trans A q bs \\<equiv> bdd_lookup (fst A ! q) bs\""], ["", "definition\n  dfa_accepting :: \"dfa \\<Rightarrow> nat \\<Rightarrow> bool\" where\n  \"dfa_accepting A q = snd A ! q\""], ["", "locale aut_dfa =\n  fixes A n\n  assumes well_formed: \"wf_dfa A n\""], ["", "sublocale aut_dfa < Automaton \"dfa_trans A\" \"dfa_is_node A\" \"is_alph n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Automaton (dfa_trans A) (dfa_is_node A) (is_alph n)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q a.\n       \\<lbrakk>dfa_is_node A q; is_alph n a\\<rbrakk>\n       \\<Longrightarrow> dfa_is_node A (dfa_trans A q a)", "fix q a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q a.\n       \\<lbrakk>dfa_is_node A q; is_alph n a\\<rbrakk>\n       \\<Longrightarrow> dfa_is_node A (dfa_trans A q a)", "assume Q: \"dfa_is_node A q\" and A: \"is_alph n a\""], ["proof (state)\nthis:\n  dfa_is_node A q\n  is_alph n a\n\ngoal (1 subgoal):\n 1. \\<And>q a.\n       \\<lbrakk>dfa_is_node A q; is_alph n a\\<rbrakk>\n       \\<Longrightarrow> dfa_is_node A (dfa_trans A q a)", "hence QL: \"q < length (fst A)\""], ["proof (prove)\nusing this:\n  dfa_is_node A q\n  is_alph n a\n\ngoal (1 subgoal):\n 1. q < length (fst A)", "by (simp add: dfa_is_node_def)"], ["proof (state)\nthis:\n  q < length (fst A)\n\ngoal (1 subgoal):\n 1. \\<And>q a.\n       \\<lbrakk>dfa_is_node A q; is_alph n a\\<rbrakk>\n       \\<Longrightarrow> dfa_is_node A (dfa_trans A q a)", "with well_formed A"], ["proof (chain)\npicking this:\n  wf_dfa A n\n  is_alph n a\n  q < length (fst A)", "have H: \"bddh (length a) (fst A ! q)\""], ["proof (prove)\nusing this:\n  wf_dfa A n\n  is_alph n a\n  q < length (fst A)\n\ngoal (1 subgoal):\n 1. bddh (length a) (fst A ! q)", "by (simp add: wf_dfa_def list_all_iff is_alph_def)"], ["proof (state)\nthis:\n  bddh (length a) (fst A ! q)\n\ngoal (1 subgoal):\n 1. \\<And>q a.\n       \\<lbrakk>dfa_is_node A q; is_alph n a\\<rbrakk>\n       \\<Longrightarrow> dfa_is_node A (dfa_trans A q a)", "from QL well_formed"], ["proof (chain)\npicking this:\n  q < length (fst A)\n  wf_dfa A n", "have \"bdd_all (dfa_is_node A) (fst A ! q)\""], ["proof (prove)\nusing this:\n  q < length (fst A)\n  wf_dfa A n\n\ngoal (1 subgoal):\n 1. bdd_all (dfa_is_node A) (fst A ! q)", "by (simp add: wf_dfa_def list_all_iff)"], ["proof (state)\nthis:\n  bdd_all (dfa_is_node A) (fst A ! q)\n\ngoal (1 subgoal):\n 1. \\<And>q a.\n       \\<lbrakk>dfa_is_node A q; is_alph n a\\<rbrakk>\n       \\<Longrightarrow> dfa_is_node A (dfa_trans A q a)", "with H"], ["proof (chain)\npicking this:\n  bddh (length a) (fst A ! q)\n  bdd_all (dfa_is_node A) (fst A ! q)", "show \"dfa_is_node A (dfa_trans A q a)\""], ["proof (prove)\nusing this:\n  bddh (length a) (fst A ! q)\n  bdd_all (dfa_is_node A) (fst A ! q)\n\ngoal (1 subgoal):\n 1. dfa_is_node A (dfa_trans A q a)", "by (simp add: dfa_trans_def bdd_all_bdd_lookup)"], ["proof (state)\nthis:\n  dfa_is_node A (dfa_trans A q a)\n\ngoal:\nNo subgoals!", "qed"], ["", "context aut_dfa begin"], ["", "lemmas trans_is_node = trans_is_node"], ["", "lemmas steps_is_node = steps_is_node"], ["", "lemmas reach_is_node = reach_is_node"], ["", "end"], ["", "lemmas dfa_trans_is_node = aut_dfa.trans_is_node [OF aut_dfa.intro]"], ["", "lemmas dfa_steps_is_node = aut_dfa.steps_is_node [OF aut_dfa.intro]"], ["", "lemmas dfa_reach_is_node = aut_dfa.reach_is_node [OF aut_dfa.intro]"], ["", "abbreviation \"dfa_steps A \\<equiv> foldl (dfa_trans A)\""], ["", "abbreviation \"dfa_accepts A \\<equiv> accepts (dfa_trans A) (dfa_accepting A) 0\""], ["", "abbreviation \"dfa_reach A \\<equiv> reach (dfa_trans A)\""], ["", "lemma dfa_startnode_is_node: \"wf_dfa A n \\<Longrightarrow> dfa_is_node A 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_dfa A n \\<Longrightarrow> dfa_is_node A 0", "by (simp add: dfa_is_node_def wf_dfa_def)"], ["", "subsection \\<open>Minimization\\<close>"], ["", "primrec make_tr :: \"(nat \\<Rightarrow> 'a) \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 'a list\"\nwhere\n  \"make_tr f 0 i = []\"\n| \"make_tr f (Suc n) i = f i # make_tr f n (Suc i)\""], ["", "primrec fold_map_idx :: \"(nat \\<Rightarrow> 'c \\<Rightarrow> 'a \\<Rightarrow> 'c \\<times> 'b) \\<Rightarrow> nat \\<Rightarrow> 'c \\<Rightarrow> 'a list \\<Rightarrow> 'c \\<times> 'b list\"\nwhere\n  \"fold_map_idx f i y [] = (y, [])\"\n| \"fold_map_idx f i y (x # xs) =\n     (let (y', x') = f i y x in\n      let (y'', xs') = fold_map_idx f (Suc i) y' xs in (y'', x' # xs'))\""], ["", "definition init_tr :: \"dfa \\<Rightarrow> bool list list\" where\n  \"init_tr = (\\<lambda>(bd,as). make_tr (\\<lambda>i. make_tr (\\<lambda>j. as ! i \\<noteq> as ! j) i 0) (length bd - 1) 1)\""], ["", "definition tr_lookup :: \"bool list list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> bool\" where\n  \"tr_lookup = (\\<lambda>T i j. (if i = j then False else if i > j then T ! (i - 1) ! j else T ! (j - 1) ! i))\""], ["", "fun check_eq :: \"nat bdd \\<Rightarrow> nat bdd \\<Rightarrow> bool list list \\<Rightarrow> bool\" where\n  \"check_eq (Leaf i) (Leaf j) T = (\\<not> tr_lookup T i j)\" |\n  \"check_eq (Branch l r) (Leaf i) T = (check_eq l (Leaf i) T \\<and> check_eq r (Leaf i) T)\" |\n  \"check_eq (Leaf i) (Branch l r) T = (check_eq (Leaf i) l T \\<and> check_eq (Leaf i) r T)\" |\n  \"check_eq (Branch l1 r1) (Branch l2 r2) T = (check_eq l1 l2 T \\<and> check_eq r1 r2 T)\""], ["", "definition iter :: \"dfa \\<Rightarrow> bool list list \\<Rightarrow> bool \\<times> bool list list\" where\n  \"iter = (\\<lambda>(bd,as) T. fold_map_idx (\\<lambda>i. fold_map_idx (\\<lambda>j c b.\n     let b' = b \\<or> \\<not> check_eq (bd ! i) (bd ! j) T\n     in (c \\<or> b \\<noteq> b', b')) 0) 1 False T)\""], ["", "definition count_tr :: \"bool list list \\<Rightarrow> nat\" where\n  \"count_tr = foldl (foldl (\\<lambda>y x. if x then y else Suc y)) 0\""], ["", "lemma fold_map_idx_fst_snd_eq:\n  assumes f: \"\\<And>i c x. fst (f i c x) = (c \\<or> x \\<noteq> snd (f i c x))\"\n  shows \"fst (fold_map_idx f i c xs) = (c \\<or> xs \\<noteq> snd (fold_map_idx f i c xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (fold_map_idx f i c xs) =\n    (c \\<or> xs \\<noteq> snd (fold_map_idx f i c xs))", "by (induct xs arbitrary: i c) (simp_all add: split_beta f)"], ["", "lemma foldl_mono:\n  assumes f: \"\\<And>x y y'. y < y' \\<Longrightarrow> f y x < f y' x\" and y: \"y < y'\"\n  shows \"foldl f y xs < foldl f y' xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl f y xs < foldl f y' xs", "using y"], ["proof (prove)\nusing this:\n  y < y'\n\ngoal (1 subgoal):\n 1. foldl f y xs < foldl f y' xs", "by (induct xs arbitrary: y y') (simp_all add: f)"], ["", "lemma fold_map_idx_count:\n  assumes f: \"\\<And>i c x y. fst (f i c x) = (c \\<or> g y (snd (f i c x)) < (g y x::nat))\"\n  and f': \"\\<And>i c x y. g y (snd (f i c x)) \\<le> g y x\"\n  and g: \"\\<And>x y y'. y < y' \\<Longrightarrow> g y x < g y' x\"\n  shows \"fst (fold_map_idx f i c xs) =\n    (c \\<or> foldl g y (snd (fold_map_idx f i c xs)) < foldl g y xs)\"\n  and \"foldl g y (snd (fold_map_idx f i c xs)) \\<le> foldl g y xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (fold_map_idx f i c xs) =\n    (c \\<or> foldl g y (snd (fold_map_idx f i c xs)) < foldl g y xs) &&&\n    foldl g y (snd (fold_map_idx f i c xs)) \\<le> foldl g y xs", "proof (induct xs arbitrary: i c y)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>i c y.\n       fst (fold_map_idx f i c []) =\n       (c \\<or> foldl g y (snd (fold_map_idx f i c [])) < foldl g y [])\n 2. \\<And>i c y. foldl g y (snd (fold_map_idx f i c [])) \\<le> foldl g y []\n 3. \\<And>a xs i c y.\n       \\<lbrakk>\\<And>i c y.\n                   fst (fold_map_idx f i c xs) =\n                   (c \\<or>\n                    foldl g y (snd (fold_map_idx f i c xs)) < foldl g y xs);\n        \\<And>i c y.\n           foldl g y (snd (fold_map_idx f i c xs))\n           \\<le> foldl g y xs\\<rbrakk>\n       \\<Longrightarrow> fst (fold_map_idx f i c (a # xs)) =\n                         (c \\<or>\n                          foldl g y (snd (fold_map_idx f i c (a # xs)))\n                          < foldl g y (a # xs))\n 4. \\<And>a xs i c y.\n       \\<lbrakk>\\<And>i c y.\n                   fst (fold_map_idx f i c xs) =\n                   (c \\<or>\n                    foldl g y (snd (fold_map_idx f i c xs)) < foldl g y xs);\n        \\<And>i c y.\n           foldl g y (snd (fold_map_idx f i c xs))\n           \\<le> foldl g y xs\\<rbrakk>\n       \\<Longrightarrow> foldl g y (snd (fold_map_idx f i c (a # xs)))\n                         \\<le> foldl g y (a # xs)", "case (Cons x xs)"], ["proof (state)\nthis:\n  fst (fold_map_idx f ?i ?c xs) =\n  (?c \\<or> foldl g ?y (snd (fold_map_idx f ?i ?c xs)) < foldl g ?y xs)\n  foldl g ?y (snd (fold_map_idx f ?i ?c xs)) \\<le> foldl g ?y xs\n\ngoal (4 subgoals):\n 1. \\<And>i c y.\n       fst (fold_map_idx f i c []) =\n       (c \\<or> foldl g y (snd (fold_map_idx f i c [])) < foldl g y [])\n 2. \\<And>i c y. foldl g y (snd (fold_map_idx f i c [])) \\<le> foldl g y []\n 3. \\<And>a xs i c y.\n       \\<lbrakk>\\<And>i c y.\n                   fst (fold_map_idx f i c xs) =\n                   (c \\<or>\n                    foldl g y (snd (fold_map_idx f i c xs)) < foldl g y xs);\n        \\<And>i c y.\n           foldl g y (snd (fold_map_idx f i c xs))\n           \\<le> foldl g y xs\\<rbrakk>\n       \\<Longrightarrow> fst (fold_map_idx f i c (a # xs)) =\n                         (c \\<or>\n                          foldl g y (snd (fold_map_idx f i c (a # xs)))\n                          < foldl g y (a # xs))\n 4. \\<And>a xs i c y.\n       \\<lbrakk>\\<And>i c y.\n                   fst (fold_map_idx f i c xs) =\n                   (c \\<or>\n                    foldl g y (snd (fold_map_idx f i c xs)) < foldl g y xs);\n        \\<And>i c y.\n           foldl g y (snd (fold_map_idx f i c xs))\n           \\<le> foldl g y xs\\<rbrakk>\n       \\<Longrightarrow> foldl g y (snd (fold_map_idx f i c (a # xs)))\n                         \\<le> foldl g y (a # xs)", "{"], ["proof (state)\nthis:\n  fst (fold_map_idx f ?i ?c xs) =\n  (?c \\<or> foldl g ?y (snd (fold_map_idx f ?i ?c xs)) < foldl g ?y xs)\n  foldl g ?y (snd (fold_map_idx f ?i ?c xs)) \\<le> foldl g ?y xs\n\ngoal (4 subgoals):\n 1. \\<And>i c y.\n       fst (fold_map_idx f i c []) =\n       (c \\<or> foldl g y (snd (fold_map_idx f i c [])) < foldl g y [])\n 2. \\<And>i c y. foldl g y (snd (fold_map_idx f i c [])) \\<le> foldl g y []\n 3. \\<And>a xs i c y.\n       \\<lbrakk>\\<And>i c y.\n                   fst (fold_map_idx f i c xs) =\n                   (c \\<or>\n                    foldl g y (snd (fold_map_idx f i c xs)) < foldl g y xs);\n        \\<And>i c y.\n           foldl g y (snd (fold_map_idx f i c xs))\n           \\<le> foldl g y xs\\<rbrakk>\n       \\<Longrightarrow> fst (fold_map_idx f i c (a # xs)) =\n                         (c \\<or>\n                          foldl g y (snd (fold_map_idx f i c (a # xs)))\n                          < foldl g y (a # xs))\n 4. \\<And>a xs i c y.\n       \\<lbrakk>\\<And>i c y.\n                   fst (fold_map_idx f i c xs) =\n                   (c \\<or>\n                    foldl g y (snd (fold_map_idx f i c xs)) < foldl g y xs);\n        \\<And>i c y.\n           foldl g y (snd (fold_map_idx f i c xs))\n           \\<le> foldl g y xs\\<rbrakk>\n       \\<Longrightarrow> foldl g y (snd (fold_map_idx f i c (a # xs)))\n                         \\<le> foldl g y (a # xs)", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>i c y.\n       fst (fold_map_idx f i c []) =\n       (c \\<or> foldl g y (snd (fold_map_idx f i c [])) < foldl g y [])\n 2. \\<And>i c y. foldl g y (snd (fold_map_idx f i c [])) \\<le> foldl g y []\n 3. \\<And>a xs i c y.\n       \\<lbrakk>\\<And>i c y.\n                   fst (fold_map_idx f i c xs) =\n                   (c \\<or>\n                    foldl g y (snd (fold_map_idx f i c xs)) < foldl g y xs);\n        \\<And>i c y.\n           foldl g y (snd (fold_map_idx f i c xs))\n           \\<le> foldl g y xs\\<rbrakk>\n       \\<Longrightarrow> fst (fold_map_idx f i c (a # xs)) =\n                         (c \\<or>\n                          foldl g y (snd (fold_map_idx f i c (a # xs)))\n                          < foldl g y (a # xs))\n 4. \\<And>a xs i c y.\n       \\<lbrakk>\\<And>i c y.\n                   fst (fold_map_idx f i c xs) =\n                   (c \\<or>\n                    foldl g y (snd (fold_map_idx f i c xs)) < foldl g y xs);\n        \\<And>i c y.\n           foldl g y (snd (fold_map_idx f i c xs))\n           \\<le> foldl g y xs\\<rbrakk>\n       \\<Longrightarrow> foldl g y (snd (fold_map_idx f i c (a # xs)))\n                         \\<le> foldl g y (a # xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (fold_map_idx f i c (x # xs)) =\n    (c \\<or>\n     foldl g y (snd (fold_map_idx f i c (x # xs))) < foldl g y (x # xs))", "using f' [of y i c x, simplified le_eq_less_or_eq]"], ["proof (prove)\nusing this:\n  g y (snd (f i c x)) < g y x \\<or> g y (snd (f i c x)) = g y x\n\ngoal (1 subgoal):\n 1. fst (fold_map_idx f i c (x # xs)) =\n    (c \\<or>\n     foldl g y (snd (fold_map_idx f i c (x # xs))) < foldl g y (x # xs))", "by (auto simp add: split_beta Cons(1) [of _ _ \"g y (snd (f i c x))\"] f [of _ _ _ y]\n        intro: less_le_trans foldl_mono g Cons)"], ["proof (state)\nthis:\n  fst (fold_map_idx f i c (x # xs)) =\n  (c \\<or>\n   foldl g y (snd (fold_map_idx f i c (x # xs))) < foldl g y (x # xs))\n\ngoal (3 subgoals):\n 1. \\<And>i c y.\n       fst (fold_map_idx f i c []) =\n       (c \\<or> foldl g y (snd (fold_map_idx f i c [])) < foldl g y [])\n 2. \\<And>i c y. foldl g y (snd (fold_map_idx f i c [])) \\<le> foldl g y []\n 3. \\<And>a xs i c y.\n       \\<lbrakk>\\<And>i c y.\n                   fst (fold_map_idx f i c xs) =\n                   (c \\<or>\n                    foldl g y (snd (fold_map_idx f i c xs)) < foldl g y xs);\n        \\<And>i c y.\n           foldl g y (snd (fold_map_idx f i c xs))\n           \\<le> foldl g y xs\\<rbrakk>\n       \\<Longrightarrow> foldl g y (snd (fold_map_idx f i c (a # xs)))\n                         \\<le> foldl g y (a # xs)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i c y.\n       fst (fold_map_idx f i c []) =\n       (c \\<or> foldl g y (snd (fold_map_idx f i c [])) < foldl g y [])\n 2. \\<And>i c y. foldl g y (snd (fold_map_idx f i c [])) \\<le> foldl g y []\n 3. \\<And>a xs i c y.\n       \\<lbrakk>\\<And>i c y.\n                   fst (fold_map_idx f i c xs) =\n                   (c \\<or>\n                    foldl g y (snd (fold_map_idx f i c xs)) < foldl g y xs);\n        \\<And>i c y.\n           foldl g y (snd (fold_map_idx f i c xs))\n           \\<le> foldl g y xs\\<rbrakk>\n       \\<Longrightarrow> foldl g y (snd (fold_map_idx f i c (a # xs)))\n                         \\<le> foldl g y (a # xs)", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>i c y.\n       fst (fold_map_idx f i c []) =\n       (c \\<or> foldl g y (snd (fold_map_idx f i c [])) < foldl g y [])\n 2. \\<And>i c y. foldl g y (snd (fold_map_idx f i c [])) \\<le> foldl g y []\n 3. \\<And>a xs i c y.\n       \\<lbrakk>\\<And>i c y.\n                   fst (fold_map_idx f i c xs) =\n                   (c \\<or>\n                    foldl g y (snd (fold_map_idx f i c xs)) < foldl g y xs);\n        \\<And>i c y.\n           foldl g y (snd (fold_map_idx f i c xs))\n           \\<le> foldl g y xs\\<rbrakk>\n       \\<Longrightarrow> foldl g y (snd (fold_map_idx f i c (a # xs)))\n                         \\<le> foldl g y (a # xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl g y (snd (fold_map_idx f i c (x # xs))) \\<le> foldl g y (x # xs)", "using f' [of y i c x, simplified le_eq_less_or_eq]"], ["proof (prove)\nusing this:\n  g y (snd (f i c x)) < g y x \\<or> g y (snd (f i c x)) = g y x\n\ngoal (1 subgoal):\n 1. foldl g y (snd (fold_map_idx f i c (x # xs))) \\<le> foldl g y (x # xs)", "by (auto simp add: split_beta intro: order_trans less_imp_le\n        intro!: foldl_mono g Cons)"], ["proof (state)\nthis:\n  foldl g y (snd (fold_map_idx f i c (x # xs))) \\<le> foldl g y (x # xs)\n\ngoal (2 subgoals):\n 1. \\<And>i c y.\n       fst (fold_map_idx f i c []) =\n       (c \\<or> foldl g y (snd (fold_map_idx f i c [])) < foldl g y [])\n 2. \\<And>i c y. foldl g y (snd (fold_map_idx f i c [])) \\<le> foldl g y []", "}"], ["proof (state)\nthis:\n  foldl g ?ya2 (snd (fold_map_idx f ?ia2 ?ca2 (x # xs)))\n  \\<le> foldl g ?ya2 (x # xs)\n\ngoal (2 subgoals):\n 1. \\<And>i c y.\n       fst (fold_map_idx f i c []) =\n       (c \\<or> foldl g y (snd (fold_map_idx f i c [])) < foldl g y [])\n 2. \\<And>i c y. foldl g y (snd (fold_map_idx f i c [])) \\<le> foldl g y []", "qed simp_all"], ["", "lemma iter_count:\n  assumes eq: \"(b, T') = iter (bd, as) T\"\n  and b: \"b\"\n  shows \"count_tr T' < count_tr T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_tr T' < count_tr T", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. count_tr T' < count_tr T", "let ?f = \"fold_map_idx (\\<lambda>i. fold_map_idx (\\<lambda>j c b.\n    let b' = b \\<or> \\<not> check_eq (bd ! i) (bd ! j) T\n    in (c \\<or> b \\<noteq> b', b')) 0) (Suc 0) False T\""], ["proof (state)\ngoal (1 subgoal):\n 1. count_tr T' < count_tr T", "from eq [symmetric] b"], ["proof (chain)\npicking this:\n  iter (bd, as) T = (b, T')\n  b", "have \"fst ?f\""], ["proof (prove)\nusing this:\n  iter (bd, as) T = (b, T')\n  b\n\ngoal (1 subgoal):\n 1. fst (fold_map_idx\n          (\\<lambda>i.\n              fold_map_idx\n               (\\<lambda>j c b.\n                   let b' = b \\<or> \\<not> check_eq (bd ! i) (bd ! j) T\n                   in (c \\<or> b \\<noteq> b', b'))\n               0)\n          (Suc 0) False T)", "by (auto simp add: iter_def)"], ["proof (state)\nthis:\n  fst (fold_map_idx\n        (\\<lambda>i.\n            fold_map_idx\n             (\\<lambda>j c b.\n                 let b' = b \\<or> \\<not> check_eq (bd ! i) (bd ! j) T\n                 in (c \\<or> b \\<noteq> b', b'))\n             0)\n        (Suc 0) False T)\n\ngoal (1 subgoal):\n 1. count_tr T' < count_tr T", "also"], ["proof (state)\nthis:\n  fst (fold_map_idx\n        (\\<lambda>i.\n            fold_map_idx\n             (\\<lambda>j c b.\n                 let b' = b \\<or> \\<not> check_eq (bd ! i) (bd ! j) T\n                 in (c \\<or> b \\<noteq> b', b'))\n             0)\n        (Suc 0) False T)\n\ngoal (1 subgoal):\n 1. count_tr T' < count_tr T", "have \"fst ?f = (False \\<or> count_tr (snd ?f) < count_tr T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (fold_map_idx\n          (\\<lambda>i.\n              fold_map_idx\n               (\\<lambda>j c b.\n                   let b' = b \\<or> \\<not> check_eq (bd ! i) (bd ! j) T\n                   in (c \\<or> b \\<noteq> b', b'))\n               0)\n          (Suc 0) False T) =\n    (False \\<or>\n     count_tr\n      (snd (fold_map_idx\n             (\\<lambda>i.\n                 fold_map_idx\n                  (\\<lambda>j c b.\n                      let b' = b \\<or> \\<not> check_eq (bd ! i) (bd ! j) T\n                      in (c \\<or> b \\<noteq> b', b'))\n                  0)\n             (Suc 0) False T))\n     < count_tr T)", "unfolding count_tr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (fold_map_idx\n          (\\<lambda>i.\n              fold_map_idx\n               (\\<lambda>j c b.\n                   let b' = b \\<or> \\<not> check_eq (bd ! i) (bd ! j) T\n                   in (c \\<or> b \\<noteq> b', b'))\n               0)\n          (Suc 0) False T) =\n    (False \\<or>\n     foldl (foldl (\\<lambda>y x. if x then y else Suc y)) 0\n      (snd (fold_map_idx\n             (\\<lambda>i.\n                 fold_map_idx\n                  (\\<lambda>j c b.\n                      let b' = b \\<or> \\<not> check_eq (bd ! i) (bd ! j) T\n                      in (c \\<or> b \\<noteq> b', b'))\n                  0)\n             (Suc 0) False T))\n     < foldl (foldl (\\<lambda>y x. if x then y else Suc y)) 0 T)", "by (rule fold_map_idx_count foldl_mono | simp)+"], ["proof (state)\nthis:\n  fst (fold_map_idx\n        (\\<lambda>i.\n            fold_map_idx\n             (\\<lambda>j c b.\n                 let b' = b \\<or> \\<not> check_eq (bd ! i) (bd ! j) T\n                 in (c \\<or> b \\<noteq> b', b'))\n             0)\n        (Suc 0) False T) =\n  (False \\<or>\n   count_tr\n    (snd (fold_map_idx\n           (\\<lambda>i.\n               fold_map_idx\n                (\\<lambda>j c b.\n                    let b' = b \\<or> \\<not> check_eq (bd ! i) (bd ! j) T\n                    in (c \\<or> b \\<noteq> b', b'))\n                0)\n           (Suc 0) False T))\n   < count_tr T)\n\ngoal (1 subgoal):\n 1. count_tr T' < count_tr T", "finally"], ["proof (chain)\npicking this:\n  False \\<or>\n  count_tr\n   (snd (fold_map_idx\n          (\\<lambda>i.\n              fold_map_idx\n               (\\<lambda>j c b.\n                   let b' = b \\<or> \\<not> check_eq (bd ! i) (bd ! j) T\n                   in (c \\<or> b \\<noteq> b', b'))\n               0)\n          (Suc 0) False T))\n  < count_tr T", "show ?thesis"], ["proof (prove)\nusing this:\n  False \\<or>\n  count_tr\n   (snd (fold_map_idx\n          (\\<lambda>i.\n              fold_map_idx\n               (\\<lambda>j c b.\n                   let b' = b \\<or> \\<not> check_eq (bd ! i) (bd ! j) T\n                   in (c \\<or> b \\<noteq> b', b'))\n               0)\n          (Suc 0) False T))\n  < count_tr T\n\ngoal (1 subgoal):\n 1. count_tr T' < count_tr T", "by (simp add: eq [THEN arg_cong, of snd, simplified] iter_def)"], ["proof (state)\nthis:\n  count_tr T' < count_tr T\n\ngoal:\nNo subgoals!", "qed"], ["", "function fixpt :: \"dfa \\<Rightarrow> bool list list \\<Rightarrow> bool list list\" where\n  \"fixpt M T = (let (b, T2) = iter M T in if b then fixpt M T2 else T2)\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>M T. x = (M, T) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>M T Ma Ta.\n       (M, T) = (Ma, Ta) \\<Longrightarrow>\n       (let (b, T2) = iter M T in if b then fixpt_sumC (M, T2) else T2) =\n       (let (b, T2) = iter Ma Ta in if b then fixpt_sumC (Ma, T2) else T2)", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All fixpt_dom", "by (relation \"measure (\\<lambda>(M, T). count_tr T)\") (auto simp: iter_count)"], ["", "lemma fixpt_True[simp]: \"fst (iter M T) \\<Longrightarrow> fixpt M T = fixpt M (snd (iter M T))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (iter M T) \\<Longrightarrow> fixpt M T = fixpt M (snd (iter M T))", "by (simp add: split_beta)"], ["", "lemma fixpt_False[simp]: \"\\<not> (fst (iter M T)) \\<Longrightarrow> fixpt M T = T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> fst (iter M T) \\<Longrightarrow> fixpt M T = T", "by (simp add: split_beta iter_def fold_map_idx_fst_snd_eq)"], ["", "declare fixpt.simps [simp del]"], ["", "lemma fixpt_induct:\n  assumes H: \"\\<And>M T. (fst (iter M T) \\<Longrightarrow> P M (snd (iter M T))) \\<Longrightarrow> P M T\"\n  shows \"P M T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P M T", "proof (induct M T rule: fixpt.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M T.\n       (\\<And>x xa y.\n           \\<lbrakk>x = iter M T; (xa, y) = x; xa\\<rbrakk>\n           \\<Longrightarrow> P M y) \\<Longrightarrow>\n       P M T", "case (1 M T)"], ["proof (state)\nthis:\n  \\<lbrakk>?x = iter M T; (?xa, ?y) = ?x; ?xa\\<rbrakk>\n  \\<Longrightarrow> P M ?y\n\ngoal (1 subgoal):\n 1. \\<And>M T.\n       (\\<And>x xa y.\n           \\<lbrakk>x = iter M T; (xa, y) = x; xa\\<rbrakk>\n           \\<Longrightarrow> P M y) \\<Longrightarrow>\n       P M T", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P M T", "by (rule H) (rule 1 [OF refl prod.collapse])"], ["proof (state)\nthis:\n  P M T\n\ngoal:\nNo subgoals!", "qed"], ["", "definition dist_nodes :: \"dfa \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> bool\" where\n  \"dist_nodes = (\\<lambda>M n m p q. \\<exists>w. length w = n \\<and> list_all (is_alph m) w \\<and>\n     dfa_accepting M (dfa_steps M p w) \\<noteq> dfa_accepting M (dfa_steps M q w))\""], ["", "definition wf_tr :: \"dfa \\<Rightarrow> bool list list \\<Rightarrow> bool\" where\n  \"wf_tr = (\\<lambda>M T. length T = length (fst M) - 1 \\<and> (\\<forall>i < length T. length (T ! i) = i + 1))\""], ["", "lemma make_tr_len: \"length (make_tr f n i) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (make_tr f n i) = n", "by (induct n arbitrary: i) simp_all"], ["", "lemma make_tr_nth: \"j < n \\<Longrightarrow> make_tr f n i ! j = f (i + j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < n \\<Longrightarrow> make_tr f n i ! j = f (i + j)", "by (induct n arbitrary: i j) (auto simp add: nth_Cons')"], ["", "lemma init_tr_wf: \"wf_tr M (init_tr M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_tr M (init_tr M)", "by (simp add: init_tr_def wf_tr_def split_beta make_tr_len make_tr_nth)"], ["", "lemma fold_map_idx_len: \"length (snd (fold_map_idx f i y xs)) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (snd (fold_map_idx f i y xs)) = length xs", "by (induct xs arbitrary: i y) (simp_all add: split_beta)"], ["", "lemma fold_map_idx_nth: \"j < length xs \\<Longrightarrow>\n  snd (fold_map_idx f i y xs) ! j = snd (f (i + j) (fst (fold_map_idx f i y (take j xs))) (xs ! j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < length xs \\<Longrightarrow>\n    snd (fold_map_idx f i y xs) ! j =\n    snd (f (i + j) (fst (fold_map_idx f i y (take j xs))) (xs ! j))", "by (induct xs arbitrary: i j y) (simp_all add: split_beta nth_Cons' take_Cons')"], ["", "lemma init_tr_dist_nodes:\n  assumes \"dfa_is_node M q\" and \"p < q\"\n  shows \"tr_lookup (init_tr M) q p = dist_nodes M 0 v p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tr_lookup (init_tr M) q p = dist_nodes M 0 v p q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. tr_lookup (init_tr M) q p = dist_nodes M 0 v p q", "have 1: \"dist_nodes M 0 v p q = (snd M ! p \\<noteq> snd M ! q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist_nodes M 0 v p q = (snd M ! p \\<noteq> snd M ! q)", "by (simp add: dist_nodes_def dfa_accepting_def)"], ["proof (state)\nthis:\n  dist_nodes M 0 v p q = (snd M ! p \\<noteq> snd M ! q)\n\ngoal (1 subgoal):\n 1. tr_lookup (init_tr M) q p = dist_nodes M 0 v p q", "from assms"], ["proof (chain)\npicking this:\n  dfa_is_node M q\n  p < q", "have \"tr_lookup (init_tr M) q p = (snd M ! p \\<noteq> snd M ! q)\""], ["proof (prove)\nusing this:\n  dfa_is_node M q\n  p < q\n\ngoal (1 subgoal):\n 1. tr_lookup (init_tr M) q p = (snd M ! p \\<noteq> snd M ! q)", "by (auto simp add: dfa_is_node_def init_tr_def tr_lookup_def make_tr_nth split_beta)"], ["proof (state)\nthis:\n  tr_lookup (init_tr M) q p = (snd M ! p \\<noteq> snd M ! q)\n\ngoal (1 subgoal):\n 1. tr_lookup (init_tr M) q p = dist_nodes M 0 v p q", "with 1"], ["proof (chain)\npicking this:\n  dist_nodes M 0 v p q = (snd M ! p \\<noteq> snd M ! q)\n  tr_lookup (init_tr M) q p = (snd M ! p \\<noteq> snd M ! q)", "show ?thesis"], ["proof (prove)\nusing this:\n  dist_nodes M 0 v p q = (snd M ! p \\<noteq> snd M ! q)\n  tr_lookup (init_tr M) q p = (snd M ! p \\<noteq> snd M ! q)\n\ngoal (1 subgoal):\n 1. tr_lookup (init_tr M) q p = dist_nodes M 0 v p q", "by simp"], ["proof (state)\nthis:\n  tr_lookup (init_tr M) q p = dist_nodes M 0 v p q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dist_nodes_suc:\n  \"dist_nodes M (Suc n) v p q = (\\<exists>bs. is_alph v bs \\<and> dist_nodes M n v (dfa_trans M p bs) (dfa_trans M q bs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist_nodes M (Suc n) v p q =\n    (\\<exists>bs.\n        is_alph v bs \\<and>\n        dist_nodes M n v (dfa_trans M p bs) (dfa_trans M q bs))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. dist_nodes M (Suc n) v p q \\<Longrightarrow>\n    \\<exists>bs.\n       is_alph v bs \\<and>\n       dist_nodes M n v (dfa_trans M p bs) (dfa_trans M q bs)\n 2. \\<exists>bs.\n       is_alph v bs \\<and>\n       dist_nodes M n v (dfa_trans M p bs)\n        (dfa_trans M q bs) \\<Longrightarrow>\n    dist_nodes M (Suc n) v p q", "assume \"dist_nodes M (Suc n) v p q\""], ["proof (state)\nthis:\n  dist_nodes M (Suc n) v p q\n\ngoal (2 subgoals):\n 1. dist_nodes M (Suc n) v p q \\<Longrightarrow>\n    \\<exists>bs.\n       is_alph v bs \\<and>\n       dist_nodes M n v (dfa_trans M p bs) (dfa_trans M q bs)\n 2. \\<exists>bs.\n       is_alph v bs \\<and>\n       dist_nodes M n v (dfa_trans M p bs)\n        (dfa_trans M q bs) \\<Longrightarrow>\n    dist_nodes M (Suc n) v p q", "then"], ["proof (chain)\npicking this:\n  dist_nodes M (Suc n) v p q", "obtain w where W: \"length w = Suc n\" and L: \"list_all (is_alph v) w\" and A: \"dfa_accepting M (dfa_steps M p w) \\<noteq> dfa_accepting M (dfa_steps M q w)\""], ["proof (prove)\nusing this:\n  dist_nodes M (Suc n) v p q\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>length w = Suc n; list_all (is_alph v) w;\n         dfa_accepting M (dfa_steps M p w) \\<noteq>\n         dfa_accepting M (dfa_steps M q w)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding dist_nodes_def"], ["proof (prove)\nusing this:\n  \\<exists>w.\n     length w = Suc n \\<and>\n     list_all (is_alph v) w \\<and>\n     dfa_accepting M (dfa_steps M p w) \\<noteq>\n     dfa_accepting M (dfa_steps M q w)\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>length w = Suc n; list_all (is_alph v) w;\n         dfa_accepting M (dfa_steps M p w) \\<noteq>\n         dfa_accepting M (dfa_steps M q w)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  length w = Suc n\n  list_all (is_alph v) w\n  dfa_accepting M (dfa_steps M p w) \\<noteq>\n  dfa_accepting M (dfa_steps M q w)\n\ngoal (2 subgoals):\n 1. dist_nodes M (Suc n) v p q \\<Longrightarrow>\n    \\<exists>bs.\n       is_alph v bs \\<and>\n       dist_nodes M n v (dfa_trans M p bs) (dfa_trans M q bs)\n 2. \\<exists>bs.\n       is_alph v bs \\<and>\n       dist_nodes M n v (dfa_trans M p bs)\n        (dfa_trans M q bs) \\<Longrightarrow>\n    dist_nodes M (Suc n) v p q", "then"], ["proof (chain)\npicking this:\n  length w = Suc n\n  list_all (is_alph v) w\n  dfa_accepting M (dfa_steps M p w) \\<noteq>\n  dfa_accepting M (dfa_steps M q w)", "obtain b bs where B: \"w = b # bs\""], ["proof (prove)\nusing this:\n  length w = Suc n\n  list_all (is_alph v) w\n  dfa_accepting M (dfa_steps M p w) \\<noteq>\n  dfa_accepting M (dfa_steps M q w)\n\ngoal (1 subgoal):\n 1. (\\<And>b bs. w = b # bs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases w) auto"], ["proof (state)\nthis:\n  w = b # bs\n\ngoal (2 subgoals):\n 1. dist_nodes M (Suc n) v p q \\<Longrightarrow>\n    \\<exists>bs.\n       is_alph v bs \\<and>\n       dist_nodes M n v (dfa_trans M p bs) (dfa_trans M q bs)\n 2. \\<exists>bs.\n       is_alph v bs \\<and>\n       dist_nodes M n v (dfa_trans M p bs)\n        (dfa_trans M q bs) \\<Longrightarrow>\n    dist_nodes M (Suc n) v p q", "from A"], ["proof (chain)\npicking this:\n  dfa_accepting M (dfa_steps M p w) \\<noteq>\n  dfa_accepting M (dfa_steps M q w)", "have A2: \"dfa_accepting M (dfa_steps M (dfa_trans M p b) bs) \\<noteq> dfa_accepting M (dfa_steps M (dfa_trans M q b) bs)\""], ["proof (prove)\nusing this:\n  dfa_accepting M (dfa_steps M p w) \\<noteq>\n  dfa_accepting M (dfa_steps M q w)\n\ngoal (1 subgoal):\n 1. dfa_accepting M (dfa_steps M (dfa_trans M p b) bs) \\<noteq>\n    dfa_accepting M (dfa_steps M (dfa_trans M q b) bs)", "unfolding B"], ["proof (prove)\nusing this:\n  dfa_accepting M (dfa_steps M p (b # bs)) \\<noteq>\n  dfa_accepting M (dfa_steps M q (b # bs))\n\ngoal (1 subgoal):\n 1. dfa_accepting M (dfa_steps M (dfa_trans M p b) bs) \\<noteq>\n    dfa_accepting M (dfa_steps M (dfa_trans M q b) bs)", "by simp"], ["proof (state)\nthis:\n  dfa_accepting M (dfa_steps M (dfa_trans M p b) bs) \\<noteq>\n  dfa_accepting M (dfa_steps M (dfa_trans M q b) bs)\n\ngoal (2 subgoals):\n 1. dist_nodes M (Suc n) v p q \\<Longrightarrow>\n    \\<exists>bs.\n       is_alph v bs \\<and>\n       dist_nodes M n v (dfa_trans M p bs) (dfa_trans M q bs)\n 2. \\<exists>bs.\n       is_alph v bs \\<and>\n       dist_nodes M n v (dfa_trans M p bs)\n        (dfa_trans M q bs) \\<Longrightarrow>\n    dist_nodes M (Suc n) v p q", "with W B L"], ["proof (chain)\npicking this:\n  length w = Suc n\n  w = b # bs\n  list_all (is_alph v) w\n  dfa_accepting M (dfa_steps M (dfa_trans M p b) bs) \\<noteq>\n  dfa_accepting M (dfa_steps M (dfa_trans M q b) bs)", "show \"\\<exists>bs. is_alph v bs \\<and> dist_nodes M n v (dfa_trans M p bs) (dfa_trans M q bs)\""], ["proof (prove)\nusing this:\n  length w = Suc n\n  w = b # bs\n  list_all (is_alph v) w\n  dfa_accepting M (dfa_steps M (dfa_trans M p b) bs) \\<noteq>\n  dfa_accepting M (dfa_steps M (dfa_trans M q b) bs)\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       is_alph v bs \\<and>\n       dist_nodes M n v (dfa_trans M p bs) (dfa_trans M q bs)", "by (auto simp: dist_nodes_def)"], ["proof (state)\nthis:\n  \\<exists>bs.\n     is_alph v bs \\<and>\n     dist_nodes M n v (dfa_trans M p bs) (dfa_trans M q bs)\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       is_alph v bs \\<and>\n       dist_nodes M n v (dfa_trans M p bs)\n        (dfa_trans M q bs) \\<Longrightarrow>\n    dist_nodes M (Suc n) v p q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       is_alph v bs \\<and>\n       dist_nodes M n v (dfa_trans M p bs)\n        (dfa_trans M q bs) \\<Longrightarrow>\n    dist_nodes M (Suc n) v p q", "assume \"\\<exists>bs. is_alph v bs \\<and> dist_nodes M n v (dfa_trans M p bs) (dfa_trans M q bs)\""], ["proof (state)\nthis:\n  \\<exists>bs.\n     is_alph v bs \\<and>\n     dist_nodes M n v (dfa_trans M p bs) (dfa_trans M q bs)\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       is_alph v bs \\<and>\n       dist_nodes M n v (dfa_trans M p bs)\n        (dfa_trans M q bs) \\<Longrightarrow>\n    dist_nodes M (Suc n) v p q", "then"], ["proof (chain)\npicking this:\n  \\<exists>bs.\n     is_alph v bs \\<and>\n     dist_nodes M n v (dfa_trans M p bs) (dfa_trans M q bs)", "obtain b bs where W: \"length bs = n\" and V: \"is_alph v b\" and V': \"list_all (is_alph v) bs\"\n    and A: \"dfa_accepting M (dfa_steps M (dfa_trans M p b) bs) \\<noteq> dfa_accepting M (dfa_steps M (dfa_trans M q b) bs)\""], ["proof (prove)\nusing this:\n  \\<exists>bs.\n     is_alph v bs \\<and>\n     dist_nodes M n v (dfa_trans M p bs) (dfa_trans M q bs)\n\ngoal (1 subgoal):\n 1. (\\<And>bs b.\n        \\<lbrakk>length bs = n; is_alph v b; list_all (is_alph v) bs;\n         dfa_accepting M (dfa_steps M (dfa_trans M p b) bs) \\<noteq>\n         dfa_accepting M (dfa_steps M (dfa_trans M q b) bs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding dist_nodes_def"], ["proof (prove)\nusing this:\n  \\<exists>bs.\n     is_alph v bs \\<and>\n     (\\<exists>w.\n         length w = n \\<and>\n         list_all (is_alph v) w \\<and>\n         dfa_accepting M (dfa_steps M (dfa_trans M p bs) w) \\<noteq>\n         dfa_accepting M (dfa_steps M (dfa_trans M q bs) w))\n\ngoal (1 subgoal):\n 1. (\\<And>bs b.\n        \\<lbrakk>length bs = n; is_alph v b; list_all (is_alph v) bs;\n         dfa_accepting M (dfa_steps M (dfa_trans M p b) bs) \\<noteq>\n         dfa_accepting M (dfa_steps M (dfa_trans M q b) bs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  length bs = n\n  is_alph v b\n  list_all (is_alph v) bs\n  dfa_accepting M (dfa_steps M (dfa_trans M p b) bs) \\<noteq>\n  dfa_accepting M (dfa_steps M (dfa_trans M q b) bs)\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       is_alph v bs \\<and>\n       dist_nodes M n v (dfa_trans M p bs)\n        (dfa_trans M q bs) \\<Longrightarrow>\n    dist_nodes M (Suc n) v p q", "hence \"dfa_accepting M (dfa_steps M p (b # bs)) \\<noteq> dfa_accepting M (dfa_steps M q (b # bs))\""], ["proof (prove)\nusing this:\n  length bs = n\n  is_alph v b\n  list_all (is_alph v) bs\n  dfa_accepting M (dfa_steps M (dfa_trans M p b) bs) \\<noteq>\n  dfa_accepting M (dfa_steps M (dfa_trans M q b) bs)\n\ngoal (1 subgoal):\n 1. dfa_accepting M (dfa_steps M p (b # bs)) \\<noteq>\n    dfa_accepting M (dfa_steps M q (b # bs))", "by simp"], ["proof (state)\nthis:\n  dfa_accepting M (dfa_steps M p (b # bs)) \\<noteq>\n  dfa_accepting M (dfa_steps M q (b # bs))\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       is_alph v bs \\<and>\n       dist_nodes M n v (dfa_trans M p bs)\n        (dfa_trans M q bs) \\<Longrightarrow>\n    dist_nodes M (Suc n) v p q", "moreover"], ["proof (state)\nthis:\n  dfa_accepting M (dfa_steps M p (b # bs)) \\<noteq>\n  dfa_accepting M (dfa_steps M q (b # bs))\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       is_alph v bs \\<and>\n       dist_nodes M n v (dfa_trans M p bs)\n        (dfa_trans M q bs) \\<Longrightarrow>\n    dist_nodes M (Suc n) v p q", "from W"], ["proof (chain)\npicking this:\n  length bs = n", "have \"length (b # bs) = Suc n\""], ["proof (prove)\nusing this:\n  length bs = n\n\ngoal (1 subgoal):\n 1. length (b # bs) = Suc n", "by simp"], ["proof (state)\nthis:\n  length (b # bs) = Suc n\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       is_alph v bs \\<and>\n       dist_nodes M n v (dfa_trans M p bs)\n        (dfa_trans M q bs) \\<Longrightarrow>\n    dist_nodes M (Suc n) v p q", "moreover"], ["proof (state)\nthis:\n  length (b # bs) = Suc n\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       is_alph v bs \\<and>\n       dist_nodes M n v (dfa_trans M p bs)\n        (dfa_trans M q bs) \\<Longrightarrow>\n    dist_nodes M (Suc n) v p q", "from V V'"], ["proof (chain)\npicking this:\n  is_alph v b\n  list_all (is_alph v) bs", "have \"list_all (is_alph v) (b # bs)\""], ["proof (prove)\nusing this:\n  is_alph v b\n  list_all (is_alph v) bs\n\ngoal (1 subgoal):\n 1. list_all (is_alph v) (b # bs)", "by simp"], ["proof (state)\nthis:\n  list_all (is_alph v) (b # bs)\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       is_alph v bs \\<and>\n       dist_nodes M n v (dfa_trans M p bs)\n        (dfa_trans M q bs) \\<Longrightarrow>\n    dist_nodes M (Suc n) v p q", "ultimately"], ["proof (chain)\npicking this:\n  dfa_accepting M (dfa_steps M p (b # bs)) \\<noteq>\n  dfa_accepting M (dfa_steps M q (b # bs))\n  length (b # bs) = Suc n\n  list_all (is_alph v) (b # bs)", "show \"dist_nodes M (Suc n) v p q\""], ["proof (prove)\nusing this:\n  dfa_accepting M (dfa_steps M p (b # bs)) \\<noteq>\n  dfa_accepting M (dfa_steps M q (b # bs))\n  length (b # bs) = Suc n\n  list_all (is_alph v) (b # bs)\n\ngoal (1 subgoal):\n 1. dist_nodes M (Suc n) v p q", "unfolding dist_nodes_def"], ["proof (prove)\nusing this:\n  dfa_accepting M (dfa_steps M p (b # bs)) \\<noteq>\n  dfa_accepting M (dfa_steps M q (b # bs))\n  length (b # bs) = Suc n\n  list_all (is_alph v) (b # bs)\n\ngoal (1 subgoal):\n 1. \\<exists>w.\n       length w = Suc n \\<and>\n       list_all (is_alph v) w \\<and>\n       dfa_accepting M (dfa_steps M p w) \\<noteq>\n       dfa_accepting M (dfa_steps M q w)", "by blast"], ["proof (state)\nthis:\n  dist_nodes M (Suc n) v p q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bdd_lookup_append:\n  assumes \"bddh n B\" and \"length bs \\<ge> n\"\n  shows \"bdd_lookup B (bs @ w) = bdd_lookup B bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_lookup B (bs @ w) = bdd_lookup B bs", "using assms"], ["proof (prove)\nusing this:\n  bddh n B\n  n \\<le> length bs\n\ngoal (1 subgoal):\n 1. bdd_lookup B (bs @ w) = bdd_lookup B bs", "proof (induct B bs arbitrary: n rule: bdd_lookup.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x bs n.\n       \\<lbrakk>bddh n (Leaf x); n \\<le> length bs\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (Leaf x) (bs @ w) =\n                         bdd_lookup (Leaf x) bs\n 2. \\<And>l r b bs n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>bddh n (if b then r else l);\n                    n \\<le> length bs\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (if b then r else l)\n(bs @ w) =\n                                     bdd_lookup (if b then r else l) bs;\n        bddh n (Branch l r); n \\<le> length (b # bs)\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (Branch l r) ((b # bs) @ w) =\n                         bdd_lookup (Branch l r) (b # bs)\n 3. \\<And>v va n.\n       \\<lbrakk>bddh n (Branch v va); n \\<le> length []\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (Branch v va) ([] @ w) =\n                         bdd_lookup (Branch v va) []", "case (2 l r b bs n)"], ["proof (state)\nthis:\n  \\<lbrakk>bddh ?n (if b then r else l); ?n \\<le> length bs\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (if b then r else l) (bs @ w) =\n                    bdd_lookup (if b then r else l) bs\n  bddh n (Branch l r)\n  n \\<le> length (b # bs)\n\ngoal (3 subgoals):\n 1. \\<And>x bs n.\n       \\<lbrakk>bddh n (Leaf x); n \\<le> length bs\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (Leaf x) (bs @ w) =\n                         bdd_lookup (Leaf x) bs\n 2. \\<And>l r b bs n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>bddh n (if b then r else l);\n                    n \\<le> length bs\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (if b then r else l)\n(bs @ w) =\n                                     bdd_lookup (if b then r else l) bs;\n        bddh n (Branch l r); n \\<le> length (b # bs)\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (Branch l r) ((b # bs) @ w) =\n                         bdd_lookup (Branch l r) (b # bs)\n 3. \\<And>v va n.\n       \\<lbrakk>bddh n (Branch v va); n \\<le> length []\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (Branch v va) ([] @ w) =\n                         bdd_lookup (Branch v va) []", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>bddh ?n (if b then r else l); ?n \\<le> length bs\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (if b then r else l) (bs @ w) =\n                    bdd_lookup (if b then r else l) bs\n  bddh n (Branch l r)\n  n \\<le> length (b # bs)", "obtain n' where N: \"n = Suc n'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>bddh ?n (if b then r else l); ?n \\<le> length bs\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (if b then r else l) (bs @ w) =\n                    bdd_lookup (if b then r else l) bs\n  bddh n (Branch l r)\n  n \\<le> length (b # bs)\n\ngoal (1 subgoal):\n 1. (\\<And>n'. n = Suc n' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases n) simp+"], ["proof (state)\nthis:\n  n = Suc n'\n\ngoal (3 subgoals):\n 1. \\<And>x bs n.\n       \\<lbrakk>bddh n (Leaf x); n \\<le> length bs\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (Leaf x) (bs @ w) =\n                         bdd_lookup (Leaf x) bs\n 2. \\<And>l r b bs n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>bddh n (if b then r else l);\n                    n \\<le> length bs\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (if b then r else l)\n(bs @ w) =\n                                     bdd_lookup (if b then r else l) bs;\n        bddh n (Branch l r); n \\<le> length (b # bs)\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (Branch l r) ((b # bs) @ w) =\n                         bdd_lookup (Branch l r) (b # bs)\n 3. \\<And>v va n.\n       \\<lbrakk>bddh n (Branch v va); n \\<le> length []\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (Branch v va) ([] @ w) =\n                         bdd_lookup (Branch v va) []", "with 2"], ["proof (chain)\npicking this:\n  \\<lbrakk>bddh ?n (if b then r else l); ?n \\<le> length bs\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (if b then r else l) (bs @ w) =\n                    bdd_lookup (if b then r else l) bs\n  bddh n (Branch l r)\n  n \\<le> length (b # bs)\n  n = Suc n'", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>bddh ?n (if b then r else l); ?n \\<le> length bs\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (if b then r else l) (bs @ w) =\n                    bdd_lookup (if b then r else l) bs\n  bddh n (Branch l r)\n  n \\<le> length (b # bs)\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. bdd_lookup (Branch l r) ((b # bs) @ w) =\n    bdd_lookup (Branch l r) (b # bs)", "by (cases b) auto"], ["proof (state)\nthis:\n  bdd_lookup (Branch l r) ((b # bs) @ w) = bdd_lookup (Branch l r) (b # bs)\n\ngoal (2 subgoals):\n 1. \\<And>x bs n.\n       \\<lbrakk>bddh n (Leaf x); n \\<le> length bs\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (Leaf x) (bs @ w) =\n                         bdd_lookup (Leaf x) bs\n 2. \\<And>v va n.\n       \\<lbrakk>bddh n (Branch v va); n \\<le> length []\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (Branch v va) ([] @ w) =\n                         bdd_lookup (Branch v va) []", "qed simp+"], ["", "lemma bddh_exists: \"\\<exists>n. bddh n B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. bddh n B", "proof (induct B)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. \\<exists>n. bddh n (Leaf x)\n 2. \\<And>B1 B2.\n       \\<lbrakk>\\<exists>n. bddh n B1; \\<exists>n. bddh n B2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. bddh n (Branch B1 B2)", "case (Branch l r)"], ["proof (state)\nthis:\n  \\<exists>n. bddh n l\n  \\<exists>n. bddh n r\n\ngoal (2 subgoals):\n 1. \\<And>x. \\<exists>n. bddh n (Leaf x)\n 2. \\<And>B1 B2.\n       \\<lbrakk>\\<exists>n. bddh n B1; \\<exists>n. bddh n B2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. bddh n (Branch B1 B2)", "then"], ["proof (chain)\npicking this:\n  \\<exists>n. bddh n l\n  \\<exists>n. bddh n r", "obtain n m where L: \"bddh n l\" and R: \"bddh m r\""], ["proof (prove)\nusing this:\n  \\<exists>n. bddh n l\n  \\<exists>n. bddh n r\n\ngoal (1 subgoal):\n 1. (\\<And>n m.\n        \\<lbrakk>bddh n l; bddh m r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  bddh n l\n  bddh m r\n\ngoal (2 subgoals):\n 1. \\<And>x. \\<exists>n. bddh n (Leaf x)\n 2. \\<And>B1 B2.\n       \\<lbrakk>\\<exists>n. bddh n B1; \\<exists>n. bddh n B2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. bddh n (Branch B1 B2)", "with bddh_ge[of n \"max n m\" l] bddh_ge[of m \"max n m\" r]"], ["proof (chain)\npicking this:\n  \\<lbrakk>n \\<le> max n m; bddh n l\\<rbrakk>\n  \\<Longrightarrow> bddh (max n m) l\n  \\<lbrakk>m \\<le> max n m; bddh m r\\<rbrakk>\n  \\<Longrightarrow> bddh (max n m) r\n  bddh n l\n  bddh m r", "have \"bddh (Suc (max n m)) (Branch l r)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>n \\<le> max n m; bddh n l\\<rbrakk>\n  \\<Longrightarrow> bddh (max n m) l\n  \\<lbrakk>m \\<le> max n m; bddh m r\\<rbrakk>\n  \\<Longrightarrow> bddh (max n m) r\n  bddh n l\n  bddh m r\n\ngoal (1 subgoal):\n 1. bddh (Suc (max n m)) (Branch l r)", "by simp"], ["proof (state)\nthis:\n  bddh (Suc (max n m)) (Branch l r)\n\ngoal (2 subgoals):\n 1. \\<And>x. \\<exists>n. bddh n (Leaf x)\n 2. \\<And>B1 B2.\n       \\<lbrakk>\\<exists>n. bddh n B1; \\<exists>n. bddh n B2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. bddh n (Branch B1 B2)", "thus ?case"], ["proof (prove)\nusing this:\n  bddh (Suc (max n m)) (Branch l r)\n\ngoal (1 subgoal):\n 1. \\<exists>n. bddh n (Branch l r)", "by (rule exI)"], ["proof (state)\nthis:\n  \\<exists>n. bddh n (Branch l r)\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<exists>n. bddh n (Leaf x)", "qed simp"], ["", "lemma check_eq_dist_nodes:\n  assumes \"\\<forall>p q. dfa_is_node M q \\<and> p < q \\<longrightarrow> tr_lookup T q p = (\\<exists>n < m. dist_nodes M n v p q)\" and \"m > 0\"\n  and \"bdd_all (dfa_is_node M) l\" and \"bdd_all (dfa_is_node M) r\"\n  shows \"(\\<not> check_eq l r T) = (\\<exists>bs. bddh (length bs) l \\<and> bddh (length bs) r \\<and> (\\<exists>n < m. dist_nodes M n v (bdd_lookup l bs) (bdd_lookup r bs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> check_eq l r T) =\n    (\\<exists>bs.\n        bddh (length bs) l \\<and>\n        bddh (length bs) r \\<and>\n        (\\<exists>n<m.\n            dist_nodes M n v (bdd_lookup l bs) (bdd_lookup r bs)))", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n  bdd_all (dfa_is_node M) l\n  bdd_all (dfa_is_node M) r\n\ngoal (1 subgoal):\n 1. (\\<not> check_eq l r T) =\n    (\\<exists>bs.\n        bddh (length bs) l \\<and>\n        bddh (length bs) r \\<and>\n        (\\<exists>n<m.\n            dist_nodes M n v (bdd_lookup l bs) (bdd_lookup r bs)))", "proof (induct l r T rule: check_eq.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>i j T.\n       \\<lbrakk>\\<forall>p q.\n                   dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                   tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Leaf i);\n        bdd_all (dfa_is_node M) (Leaf j)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Leaf i) (Leaf j) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Leaf i) \\<and>\n                             bddh (length bs) (Leaf j) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                  (bdd_lookup (Leaf j) bs)))\n 2. \\<And>l r i T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) l;\n                 bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq l (Leaf i) T) =\n                                  (\\<exists>bs.\nbddh (length bs) l \\<and>\nbddh (length bs) (Leaf i) \\<and>\n(\\<exists>n<m.\n    dist_nodes M n v (bdd_lookup l bs) (bdd_lookup (Leaf i) bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) r;\n         bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq r (Leaf i) T) =\n                          (\\<exists>bs.\n                              bddh (length bs) r \\<and>\n                              bddh (length bs) (Leaf i) \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup r bs)\n                                   (bdd_lookup (Leaf i) bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Branch l r);\n        bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Branch l r) (Leaf i) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Branch l r) \\<and>\n                             bddh (length bs) (Leaf i) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v\n                                  (bdd_lookup (Branch l r) bs)\n                                  (bdd_lookup (Leaf i) bs)))\n 3. \\<And>i l r T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) (Leaf i);\n                 bdd_all (dfa_is_node M) l\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq (Leaf i) l T) =\n                                  (\\<exists>bs.\nbddh (length bs) (Leaf i) \\<and>\nbddh (length bs) l \\<and>\n(\\<exists>n<m.\n    dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup l bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) (Leaf i);\n         bdd_all (dfa_is_node M) r\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq (Leaf i) r T) =\n                          (\\<exists>bs.\n                              bddh (length bs) (Leaf i) \\<and>\n                              bddh (length bs) r \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                   (bdd_lookup r bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Leaf i);\n        bdd_all (dfa_is_node M) (Branch l r)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Leaf i) (Branch l r) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Leaf i) \\<and>\n                             bddh (length bs) (Branch l r) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                  (bdd_lookup (Branch l r) bs)))\n 4. \\<And>l1 r1 l2 r2 T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) l1;\n                 bdd_all (dfa_is_node M) l2\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq l1 l2 T) =\n                                  (\\<exists>bs.\nbddh (length bs) l1 \\<and>\nbddh (length bs) l2 \\<and>\n(\\<exists>n<m. dist_nodes M n v (bdd_lookup l1 bs) (bdd_lookup l2 bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) r1;\n         bdd_all (dfa_is_node M) r2\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq r1 r2 T) =\n                          (\\<exists>bs.\n                              bddh (length bs) r1 \\<and>\n                              bddh (length bs) r2 \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup r1 bs)\n                                   (bdd_lookup r2 bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Branch l1 r1);\n        bdd_all (dfa_is_node M) (Branch l2 r2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Branch l1 r1) (Branch l2 r2) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Branch l1 r1) \\<and>\n                             bddh (length bs) (Branch l2 r2) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v\n                                  (bdd_lookup (Branch l1 r1) bs)\n                                  (bdd_lookup (Branch l2 r2) bs)))", "case (1 i j T)"], ["proof (state)\nthis:\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n  bdd_all (dfa_is_node M) (Leaf i)\n  bdd_all (dfa_is_node M) (Leaf j)\n\ngoal (4 subgoals):\n 1. \\<And>i j T.\n       \\<lbrakk>\\<forall>p q.\n                   dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                   tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Leaf i);\n        bdd_all (dfa_is_node M) (Leaf j)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Leaf i) (Leaf j) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Leaf i) \\<and>\n                             bddh (length bs) (Leaf j) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                  (bdd_lookup (Leaf j) bs)))\n 2. \\<And>l r i T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) l;\n                 bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq l (Leaf i) T) =\n                                  (\\<exists>bs.\nbddh (length bs) l \\<and>\nbddh (length bs) (Leaf i) \\<and>\n(\\<exists>n<m.\n    dist_nodes M n v (bdd_lookup l bs) (bdd_lookup (Leaf i) bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) r;\n         bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq r (Leaf i) T) =\n                          (\\<exists>bs.\n                              bddh (length bs) r \\<and>\n                              bddh (length bs) (Leaf i) \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup r bs)\n                                   (bdd_lookup (Leaf i) bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Branch l r);\n        bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Branch l r) (Leaf i) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Branch l r) \\<and>\n                             bddh (length bs) (Leaf i) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v\n                                  (bdd_lookup (Branch l r) bs)\n                                  (bdd_lookup (Leaf i) bs)))\n 3. \\<And>i l r T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) (Leaf i);\n                 bdd_all (dfa_is_node M) l\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq (Leaf i) l T) =\n                                  (\\<exists>bs.\nbddh (length bs) (Leaf i) \\<and>\nbddh (length bs) l \\<and>\n(\\<exists>n<m.\n    dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup l bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) (Leaf i);\n         bdd_all (dfa_is_node M) r\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq (Leaf i) r T) =\n                          (\\<exists>bs.\n                              bddh (length bs) (Leaf i) \\<and>\n                              bddh (length bs) r \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                   (bdd_lookup r bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Leaf i);\n        bdd_all (dfa_is_node M) (Branch l r)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Leaf i) (Branch l r) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Leaf i) \\<and>\n                             bddh (length bs) (Branch l r) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                  (bdd_lookup (Branch l r) bs)))\n 4. \\<And>l1 r1 l2 r2 T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) l1;\n                 bdd_all (dfa_is_node M) l2\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq l1 l2 T) =\n                                  (\\<exists>bs.\nbddh (length bs) l1 \\<and>\nbddh (length bs) l2 \\<and>\n(\\<exists>n<m. dist_nodes M n v (bdd_lookup l1 bs) (bdd_lookup l2 bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) r1;\n         bdd_all (dfa_is_node M) r2\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq r1 r2 T) =\n                          (\\<exists>bs.\n                              bddh (length bs) r1 \\<and>\n                              bddh (length bs) r2 \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup r1 bs)\n                                   (bdd_lookup r2 bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Branch l1 r1);\n        bdd_all (dfa_is_node M) (Branch l2 r2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Branch l1 r1) (Branch l2 r2) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Branch l1 r1) \\<and>\n                             bddh (length bs) (Branch l2 r2) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v\n                                  (bdd_lookup (Branch l1 r1) bs)\n                                  (bdd_lookup (Branch l2 r2) bs)))", "have \"i < j \\<or> i = j \\<or> i > j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < j \\<or> i = j \\<or> j < i", "by auto"], ["proof (state)\nthis:\n  i < j \\<or> i = j \\<or> j < i\n\ngoal (4 subgoals):\n 1. \\<And>i j T.\n       \\<lbrakk>\\<forall>p q.\n                   dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                   tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Leaf i);\n        bdd_all (dfa_is_node M) (Leaf j)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Leaf i) (Leaf j) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Leaf i) \\<and>\n                             bddh (length bs) (Leaf j) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                  (bdd_lookup (Leaf j) bs)))\n 2. \\<And>l r i T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) l;\n                 bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq l (Leaf i) T) =\n                                  (\\<exists>bs.\nbddh (length bs) l \\<and>\nbddh (length bs) (Leaf i) \\<and>\n(\\<exists>n<m.\n    dist_nodes M n v (bdd_lookup l bs) (bdd_lookup (Leaf i) bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) r;\n         bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq r (Leaf i) T) =\n                          (\\<exists>bs.\n                              bddh (length bs) r \\<and>\n                              bddh (length bs) (Leaf i) \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup r bs)\n                                   (bdd_lookup (Leaf i) bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Branch l r);\n        bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Branch l r) (Leaf i) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Branch l r) \\<and>\n                             bddh (length bs) (Leaf i) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v\n                                  (bdd_lookup (Branch l r) bs)\n                                  (bdd_lookup (Leaf i) bs)))\n 3. \\<And>i l r T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) (Leaf i);\n                 bdd_all (dfa_is_node M) l\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq (Leaf i) l T) =\n                                  (\\<exists>bs.\nbddh (length bs) (Leaf i) \\<and>\nbddh (length bs) l \\<and>\n(\\<exists>n<m.\n    dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup l bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) (Leaf i);\n         bdd_all (dfa_is_node M) r\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq (Leaf i) r T) =\n                          (\\<exists>bs.\n                              bddh (length bs) (Leaf i) \\<and>\n                              bddh (length bs) r \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                   (bdd_lookup r bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Leaf i);\n        bdd_all (dfa_is_node M) (Branch l r)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Leaf i) (Branch l r) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Leaf i) \\<and>\n                             bddh (length bs) (Branch l r) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                  (bdd_lookup (Branch l r) bs)))\n 4. \\<And>l1 r1 l2 r2 T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) l1;\n                 bdd_all (dfa_is_node M) l2\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq l1 l2 T) =\n                                  (\\<exists>bs.\nbddh (length bs) l1 \\<and>\nbddh (length bs) l2 \\<and>\n(\\<exists>n<m. dist_nodes M n v (bdd_lookup l1 bs) (bdd_lookup l2 bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) r1;\n         bdd_all (dfa_is_node M) r2\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq r1 r2 T) =\n                          (\\<exists>bs.\n                              bddh (length bs) r1 \\<and>\n                              bddh (length bs) r2 \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup r1 bs)\n                                   (bdd_lookup r2 bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Branch l1 r1);\n        bdd_all (dfa_is_node M) (Branch l2 r2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Branch l1 r1) (Branch l2 r2) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Branch l1 r1) \\<and>\n                             bddh (length bs) (Branch l2 r2) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v\n                                  (bdd_lookup (Branch l1 r1) bs)\n                                  (bdd_lookup (Branch l2 r2) bs)))", "thus ?case"], ["proof (prove)\nusing this:\n  i < j \\<or> i = j \\<or> j < i\n\ngoal (1 subgoal):\n 1. (\\<not> check_eq (Leaf i) (Leaf j) T) =\n    (\\<exists>bs.\n        bddh (length bs) (Leaf i) \\<and>\n        bddh (length bs) (Leaf j) \\<and>\n        (\\<exists>n<m.\n            dist_nodes M n v (bdd_lookup (Leaf i) bs)\n             (bdd_lookup (Leaf j) bs)))", "by (elim disjE) (insert 1, auto simp: dist_nodes_def tr_lookup_def)"], ["proof (state)\nthis:\n  (\\<not> check_eq (Leaf i) (Leaf j) T) =\n  (\\<exists>bs.\n      bddh (length bs) (Leaf i) \\<and>\n      bddh (length bs) (Leaf j) \\<and>\n      (\\<exists>n<m.\n          dist_nodes M n v (bdd_lookup (Leaf i) bs)\n           (bdd_lookup (Leaf j) bs)))\n\ngoal (3 subgoals):\n 1. \\<And>l r i T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) l;\n                 bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq l (Leaf i) T) =\n                                  (\\<exists>bs.\nbddh (length bs) l \\<and>\nbddh (length bs) (Leaf i) \\<and>\n(\\<exists>n<m.\n    dist_nodes M n v (bdd_lookup l bs) (bdd_lookup (Leaf i) bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) r;\n         bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq r (Leaf i) T) =\n                          (\\<exists>bs.\n                              bddh (length bs) r \\<and>\n                              bddh (length bs) (Leaf i) \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup r bs)\n                                   (bdd_lookup (Leaf i) bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Branch l r);\n        bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Branch l r) (Leaf i) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Branch l r) \\<and>\n                             bddh (length bs) (Leaf i) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v\n                                  (bdd_lookup (Branch l r) bs)\n                                  (bdd_lookup (Leaf i) bs)))\n 2. \\<And>i l r T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) (Leaf i);\n                 bdd_all (dfa_is_node M) l\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq (Leaf i) l T) =\n                                  (\\<exists>bs.\nbddh (length bs) (Leaf i) \\<and>\nbddh (length bs) l \\<and>\n(\\<exists>n<m.\n    dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup l bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) (Leaf i);\n         bdd_all (dfa_is_node M) r\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq (Leaf i) r T) =\n                          (\\<exists>bs.\n                              bddh (length bs) (Leaf i) \\<and>\n                              bddh (length bs) r \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                   (bdd_lookup r bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Leaf i);\n        bdd_all (dfa_is_node M) (Branch l r)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Leaf i) (Branch l r) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Leaf i) \\<and>\n                             bddh (length bs) (Branch l r) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                  (bdd_lookup (Branch l r) bs)))\n 3. \\<And>l1 r1 l2 r2 T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) l1;\n                 bdd_all (dfa_is_node M) l2\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq l1 l2 T) =\n                                  (\\<exists>bs.\nbddh (length bs) l1 \\<and>\nbddh (length bs) l2 \\<and>\n(\\<exists>n<m. dist_nodes M n v (bdd_lookup l1 bs) (bdd_lookup l2 bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) r1;\n         bdd_all (dfa_is_node M) r2\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq r1 r2 T) =\n                          (\\<exists>bs.\n                              bddh (length bs) r1 \\<and>\n                              bddh (length bs) r2 \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup r1 bs)\n                                   (bdd_lookup r2 bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Branch l1 r1);\n        bdd_all (dfa_is_node M) (Branch l2 r2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Branch l1 r1) (Branch l2 r2) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Branch l1 r1) \\<and>\n                             bddh (length bs) (Branch l2 r2) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v\n                                  (bdd_lookup (Branch l1 r1) bs)\n                                  (bdd_lookup (Branch l2 r2) bs)))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>l r i T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) l;\n                 bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq l (Leaf i) T) =\n                                  (\\<exists>bs.\nbddh (length bs) l \\<and>\nbddh (length bs) (Leaf i) \\<and>\n(\\<exists>n<m.\n    dist_nodes M n v (bdd_lookup l bs) (bdd_lookup (Leaf i) bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) r;\n         bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq r (Leaf i) T) =\n                          (\\<exists>bs.\n                              bddh (length bs) r \\<and>\n                              bddh (length bs) (Leaf i) \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup r bs)\n                                   (bdd_lookup (Leaf i) bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Branch l r);\n        bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Branch l r) (Leaf i) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Branch l r) \\<and>\n                             bddh (length bs) (Leaf i) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v\n                                  (bdd_lookup (Branch l r) bs)\n                                  (bdd_lookup (Leaf i) bs)))\n 2. \\<And>i l r T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) (Leaf i);\n                 bdd_all (dfa_is_node M) l\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq (Leaf i) l T) =\n                                  (\\<exists>bs.\nbddh (length bs) (Leaf i) \\<and>\nbddh (length bs) l \\<and>\n(\\<exists>n<m.\n    dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup l bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) (Leaf i);\n         bdd_all (dfa_is_node M) r\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq (Leaf i) r T) =\n                          (\\<exists>bs.\n                              bddh (length bs) (Leaf i) \\<and>\n                              bddh (length bs) r \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                   (bdd_lookup r bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Leaf i);\n        bdd_all (dfa_is_node M) (Branch l r)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Leaf i) (Branch l r) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Leaf i) \\<and>\n                             bddh (length bs) (Branch l r) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                  (bdd_lookup (Branch l r) bs)))\n 3. \\<And>l1 r1 l2 r2 T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) l1;\n                 bdd_all (dfa_is_node M) l2\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq l1 l2 T) =\n                                  (\\<exists>bs.\nbddh (length bs) l1 \\<and>\nbddh (length bs) l2 \\<and>\n(\\<exists>n<m. dist_nodes M n v (bdd_lookup l1 bs) (bdd_lookup l2 bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) r1;\n         bdd_all (dfa_is_node M) r2\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq r1 r2 T) =\n                          (\\<exists>bs.\n                              bddh (length bs) r1 \\<and>\n                              bddh (length bs) r2 \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup r1 bs)\n                                   (bdd_lookup r2 bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Branch l1 r1);\n        bdd_all (dfa_is_node M) (Branch l2 r2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Branch l1 r1) (Branch l2 r2) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Branch l1 r1) \\<and>\n                             bddh (length bs) (Branch l2 r2) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v\n                                  (bdd_lookup (Branch l1 r1) bs)\n                                  (bdd_lookup (Branch l2 r2) bs)))", "case (2 l r i T)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>p q.\n              dfa_is_node M q \\<and> p < q \\<longrightarrow>\n              tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n   0 < m; bdd_all (dfa_is_node M) l;\n   bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n  \\<Longrightarrow> (\\<not> check_eq l (Leaf i) T) =\n                    (\\<exists>bs.\n                        bddh (length bs) l \\<and>\n                        bddh (length bs) (Leaf i) \\<and>\n                        (\\<exists>n<m.\n                            dist_nodes M n v (bdd_lookup l bs)\n                             (bdd_lookup (Leaf i) bs)))\n  \\<lbrakk>\\<forall>p q.\n              dfa_is_node M q \\<and> p < q \\<longrightarrow>\n              tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n   0 < m; bdd_all (dfa_is_node M) r;\n   bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n  \\<Longrightarrow> (\\<not> check_eq r (Leaf i) T) =\n                    (\\<exists>bs.\n                        bddh (length bs) r \\<and>\n                        bddh (length bs) (Leaf i) \\<and>\n                        (\\<exists>n<m.\n                            dist_nodes M n v (bdd_lookup r bs)\n                             (bdd_lookup (Leaf i) bs)))\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n  bdd_all (dfa_is_node M) (Branch l r)\n  bdd_all (dfa_is_node M) (Leaf i)\n\ngoal (3 subgoals):\n 1. \\<And>l r i T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) l;\n                 bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq l (Leaf i) T) =\n                                  (\\<exists>bs.\nbddh (length bs) l \\<and>\nbddh (length bs) (Leaf i) \\<and>\n(\\<exists>n<m.\n    dist_nodes M n v (bdd_lookup l bs) (bdd_lookup (Leaf i) bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) r;\n         bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq r (Leaf i) T) =\n                          (\\<exists>bs.\n                              bddh (length bs) r \\<and>\n                              bddh (length bs) (Leaf i) \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup r bs)\n                                   (bdd_lookup (Leaf i) bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Branch l r);\n        bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Branch l r) (Leaf i) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Branch l r) \\<and>\n                             bddh (length bs) (Leaf i) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v\n                                  (bdd_lookup (Branch l r) bs)\n                                  (bdd_lookup (Leaf i) bs)))\n 2. \\<And>i l r T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) (Leaf i);\n                 bdd_all (dfa_is_node M) l\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq (Leaf i) l T) =\n                                  (\\<exists>bs.\nbddh (length bs) (Leaf i) \\<and>\nbddh (length bs) l \\<and>\n(\\<exists>n<m.\n    dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup l bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) (Leaf i);\n         bdd_all (dfa_is_node M) r\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq (Leaf i) r T) =\n                          (\\<exists>bs.\n                              bddh (length bs) (Leaf i) \\<and>\n                              bddh (length bs) r \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                   (bdd_lookup r bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Leaf i);\n        bdd_all (dfa_is_node M) (Branch l r)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Leaf i) (Branch l r) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Leaf i) \\<and>\n                             bddh (length bs) (Branch l r) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                  (bdd_lookup (Branch l r) bs)))\n 3. \\<And>l1 r1 l2 r2 T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) l1;\n                 bdd_all (dfa_is_node M) l2\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq l1 l2 T) =\n                                  (\\<exists>bs.\nbddh (length bs) l1 \\<and>\nbddh (length bs) l2 \\<and>\n(\\<exists>n<m. dist_nodes M n v (bdd_lookup l1 bs) (bdd_lookup l2 bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) r1;\n         bdd_all (dfa_is_node M) r2\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq r1 r2 T) =\n                          (\\<exists>bs.\n                              bddh (length bs) r1 \\<and>\n                              bddh (length bs) r2 \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup r1 bs)\n                                   (bdd_lookup r2 bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Branch l1 r1);\n        bdd_all (dfa_is_node M) (Branch l2 r2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Branch l1 r1) (Branch l2 r2) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Branch l1 r1) \\<and>\n                             bddh (length bs) (Branch l2 r2) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v\n                                  (bdd_lookup (Branch l1 r1) bs)\n                                  (bdd_lookup (Branch l2 r2) bs)))", "hence IV1: \"(\\<not> check_eq l (Leaf i) T) = (\\<exists>bs. bddh (length bs) l \\<and> bddh (length bs) (Leaf i) \\<and> (\\<exists>n<m. dist_nodes M n v (bdd_lookup l bs) (bdd_lookup (Leaf i) bs)))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>p q.\n              dfa_is_node M q \\<and> p < q \\<longrightarrow>\n              tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n   0 < m; bdd_all (dfa_is_node M) l;\n   bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n  \\<Longrightarrow> (\\<not> check_eq l (Leaf i) T) =\n                    (\\<exists>bs.\n                        bddh (length bs) l \\<and>\n                        bddh (length bs) (Leaf i) \\<and>\n                        (\\<exists>n<m.\n                            dist_nodes M n v (bdd_lookup l bs)\n                             (bdd_lookup (Leaf i) bs)))\n  \\<lbrakk>\\<forall>p q.\n              dfa_is_node M q \\<and> p < q \\<longrightarrow>\n              tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n   0 < m; bdd_all (dfa_is_node M) r;\n   bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n  \\<Longrightarrow> (\\<not> check_eq r (Leaf i) T) =\n                    (\\<exists>bs.\n                        bddh (length bs) r \\<and>\n                        bddh (length bs) (Leaf i) \\<and>\n                        (\\<exists>n<m.\n                            dist_nodes M n v (bdd_lookup r bs)\n                             (bdd_lookup (Leaf i) bs)))\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n  bdd_all (dfa_is_node M) (Branch l r)\n  bdd_all (dfa_is_node M) (Leaf i)\n\ngoal (1 subgoal):\n 1. (\\<not> check_eq l (Leaf i) T) =\n    (\\<exists>bs.\n        bddh (length bs) l \\<and>\n        bddh (length bs) (Leaf i) \\<and>\n        (\\<exists>n<m.\n            dist_nodes M n v (bdd_lookup l bs) (bdd_lookup (Leaf i) bs)))", "by simp"], ["proof (state)\nthis:\n  (\\<not> check_eq l (Leaf i) T) =\n  (\\<exists>bs.\n      bddh (length bs) l \\<and>\n      bddh (length bs) (Leaf i) \\<and>\n      (\\<exists>n<m.\n          dist_nodes M n v (bdd_lookup l bs) (bdd_lookup (Leaf i) bs)))\n\ngoal (3 subgoals):\n 1. \\<And>l r i T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) l;\n                 bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq l (Leaf i) T) =\n                                  (\\<exists>bs.\nbddh (length bs) l \\<and>\nbddh (length bs) (Leaf i) \\<and>\n(\\<exists>n<m.\n    dist_nodes M n v (bdd_lookup l bs) (bdd_lookup (Leaf i) bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) r;\n         bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq r (Leaf i) T) =\n                          (\\<exists>bs.\n                              bddh (length bs) r \\<and>\n                              bddh (length bs) (Leaf i) \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup r bs)\n                                   (bdd_lookup (Leaf i) bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Branch l r);\n        bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Branch l r) (Leaf i) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Branch l r) \\<and>\n                             bddh (length bs) (Leaf i) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v\n                                  (bdd_lookup (Branch l r) bs)\n                                  (bdd_lookup (Leaf i) bs)))\n 2. \\<And>i l r T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) (Leaf i);\n                 bdd_all (dfa_is_node M) l\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq (Leaf i) l T) =\n                                  (\\<exists>bs.\nbddh (length bs) (Leaf i) \\<and>\nbddh (length bs) l \\<and>\n(\\<exists>n<m.\n    dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup l bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) (Leaf i);\n         bdd_all (dfa_is_node M) r\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq (Leaf i) r T) =\n                          (\\<exists>bs.\n                              bddh (length bs) (Leaf i) \\<and>\n                              bddh (length bs) r \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                   (bdd_lookup r bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Leaf i);\n        bdd_all (dfa_is_node M) (Branch l r)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Leaf i) (Branch l r) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Leaf i) \\<and>\n                             bddh (length bs) (Branch l r) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                  (bdd_lookup (Branch l r) bs)))\n 3. \\<And>l1 r1 l2 r2 T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) l1;\n                 bdd_all (dfa_is_node M) l2\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq l1 l2 T) =\n                                  (\\<exists>bs.\nbddh (length bs) l1 \\<and>\nbddh (length bs) l2 \\<and>\n(\\<exists>n<m. dist_nodes M n v (bdd_lookup l1 bs) (bdd_lookup l2 bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) r1;\n         bdd_all (dfa_is_node M) r2\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq r1 r2 T) =\n                          (\\<exists>bs.\n                              bddh (length bs) r1 \\<and>\n                              bddh (length bs) r2 \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup r1 bs)\n                                   (bdd_lookup r2 bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Branch l1 r1);\n        bdd_all (dfa_is_node M) (Branch l2 r2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Branch l1 r1) (Branch l2 r2) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Branch l1 r1) \\<and>\n                             bddh (length bs) (Branch l2 r2) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v\n                                  (bdd_lookup (Branch l1 r1) bs)\n                                  (bdd_lookup (Branch l2 r2) bs)))", "from 2"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>p q.\n              dfa_is_node M q \\<and> p < q \\<longrightarrow>\n              tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n   0 < m; bdd_all (dfa_is_node M) l;\n   bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n  \\<Longrightarrow> (\\<not> check_eq l (Leaf i) T) =\n                    (\\<exists>bs.\n                        bddh (length bs) l \\<and>\n                        bddh (length bs) (Leaf i) \\<and>\n                        (\\<exists>n<m.\n                            dist_nodes M n v (bdd_lookup l bs)\n                             (bdd_lookup (Leaf i) bs)))\n  \\<lbrakk>\\<forall>p q.\n              dfa_is_node M q \\<and> p < q \\<longrightarrow>\n              tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n   0 < m; bdd_all (dfa_is_node M) r;\n   bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n  \\<Longrightarrow> (\\<not> check_eq r (Leaf i) T) =\n                    (\\<exists>bs.\n                        bddh (length bs) r \\<and>\n                        bddh (length bs) (Leaf i) \\<and>\n                        (\\<exists>n<m.\n                            dist_nodes M n v (bdd_lookup r bs)\n                             (bdd_lookup (Leaf i) bs)))\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n  bdd_all (dfa_is_node M) (Branch l r)\n  bdd_all (dfa_is_node M) (Leaf i)", "have IV2: \"(\\<not> check_eq r (Leaf i) T) = (\\<exists>bs. bddh (length bs) r \\<and> bddh (length bs) (Leaf i) \\<and> (\\<exists>n<m. dist_nodes M n v (bdd_lookup r bs) (bdd_lookup (Leaf i) bs)))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>p q.\n              dfa_is_node M q \\<and> p < q \\<longrightarrow>\n              tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n   0 < m; bdd_all (dfa_is_node M) l;\n   bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n  \\<Longrightarrow> (\\<not> check_eq l (Leaf i) T) =\n                    (\\<exists>bs.\n                        bddh (length bs) l \\<and>\n                        bddh (length bs) (Leaf i) \\<and>\n                        (\\<exists>n<m.\n                            dist_nodes M n v (bdd_lookup l bs)\n                             (bdd_lookup (Leaf i) bs)))\n  \\<lbrakk>\\<forall>p q.\n              dfa_is_node M q \\<and> p < q \\<longrightarrow>\n              tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n   0 < m; bdd_all (dfa_is_node M) r;\n   bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n  \\<Longrightarrow> (\\<not> check_eq r (Leaf i) T) =\n                    (\\<exists>bs.\n                        bddh (length bs) r \\<and>\n                        bddh (length bs) (Leaf i) \\<and>\n                        (\\<exists>n<m.\n                            dist_nodes M n v (bdd_lookup r bs)\n                             (bdd_lookup (Leaf i) bs)))\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n  bdd_all (dfa_is_node M) (Branch l r)\n  bdd_all (dfa_is_node M) (Leaf i)\n\ngoal (1 subgoal):\n 1. (\\<not> check_eq r (Leaf i) T) =\n    (\\<exists>bs.\n        bddh (length bs) r \\<and>\n        bddh (length bs) (Leaf i) \\<and>\n        (\\<exists>n<m.\n            dist_nodes M n v (bdd_lookup r bs) (bdd_lookup (Leaf i) bs)))", "by simp"], ["proof (state)\nthis:\n  (\\<not> check_eq r (Leaf i) T) =\n  (\\<exists>bs.\n      bddh (length bs) r \\<and>\n      bddh (length bs) (Leaf i) \\<and>\n      (\\<exists>n<m.\n          dist_nodes M n v (bdd_lookup r bs) (bdd_lookup (Leaf i) bs)))\n\ngoal (3 subgoals):\n 1. \\<And>l r i T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) l;\n                 bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq l (Leaf i) T) =\n                                  (\\<exists>bs.\nbddh (length bs) l \\<and>\nbddh (length bs) (Leaf i) \\<and>\n(\\<exists>n<m.\n    dist_nodes M n v (bdd_lookup l bs) (bdd_lookup (Leaf i) bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) r;\n         bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq r (Leaf i) T) =\n                          (\\<exists>bs.\n                              bddh (length bs) r \\<and>\n                              bddh (length bs) (Leaf i) \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup r bs)\n                                   (bdd_lookup (Leaf i) bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Branch l r);\n        bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Branch l r) (Leaf i) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Branch l r) \\<and>\n                             bddh (length bs) (Leaf i) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v\n                                  (bdd_lookup (Branch l r) bs)\n                                  (bdd_lookup (Leaf i) bs)))\n 2. \\<And>i l r T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) (Leaf i);\n                 bdd_all (dfa_is_node M) l\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq (Leaf i) l T) =\n                                  (\\<exists>bs.\nbddh (length bs) (Leaf i) \\<and>\nbddh (length bs) l \\<and>\n(\\<exists>n<m.\n    dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup l bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) (Leaf i);\n         bdd_all (dfa_is_node M) r\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq (Leaf i) r T) =\n                          (\\<exists>bs.\n                              bddh (length bs) (Leaf i) \\<and>\n                              bddh (length bs) r \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                   (bdd_lookup r bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Leaf i);\n        bdd_all (dfa_is_node M) (Branch l r)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Leaf i) (Branch l r) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Leaf i) \\<and>\n                             bddh (length bs) (Branch l r) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                  (bdd_lookup (Branch l r) bs)))\n 3. \\<And>l1 r1 l2 r2 T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) l1;\n                 bdd_all (dfa_is_node M) l2\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq l1 l2 T) =\n                                  (\\<exists>bs.\nbddh (length bs) l1 \\<and>\nbddh (length bs) l2 \\<and>\n(\\<exists>n<m. dist_nodes M n v (bdd_lookup l1 bs) (bdd_lookup l2 bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) r1;\n         bdd_all (dfa_is_node M) r2\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq r1 r2 T) =\n                          (\\<exists>bs.\n                              bddh (length bs) r1 \\<and>\n                              bddh (length bs) r2 \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup r1 bs)\n                                   (bdd_lookup r2 bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Branch l1 r1);\n        bdd_all (dfa_is_node M) (Branch l2 r2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Branch l1 r1) (Branch l2 r2) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Branch l1 r1) \\<and>\n                             bddh (length bs) (Branch l2 r2) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v\n                                  (bdd_lookup (Branch l1 r1) bs)\n                                  (bdd_lookup (Branch l2 r2) bs)))", "have \"(\\<not> check_eq (Branch l r) (Leaf i) T) = (\\<not> check_eq l (Leaf i) T \\<or> \\<not> check_eq r (Leaf i) T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> check_eq (Branch l r) (Leaf i) T) =\n    (\\<not> check_eq l (Leaf i) T \\<or> \\<not> check_eq r (Leaf i) T)", "by simp"], ["proof (state)\nthis:\n  (\\<not> check_eq (Branch l r) (Leaf i) T) =\n  (\\<not> check_eq l (Leaf i) T \\<or> \\<not> check_eq r (Leaf i) T)\n\ngoal (3 subgoals):\n 1. \\<And>l r i T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) l;\n                 bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq l (Leaf i) T) =\n                                  (\\<exists>bs.\nbddh (length bs) l \\<and>\nbddh (length bs) (Leaf i) \\<and>\n(\\<exists>n<m.\n    dist_nodes M n v (bdd_lookup l bs) (bdd_lookup (Leaf i) bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) r;\n         bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq r (Leaf i) T) =\n                          (\\<exists>bs.\n                              bddh (length bs) r \\<and>\n                              bddh (length bs) (Leaf i) \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup r bs)\n                                   (bdd_lookup (Leaf i) bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Branch l r);\n        bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Branch l r) (Leaf i) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Branch l r) \\<and>\n                             bddh (length bs) (Leaf i) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v\n                                  (bdd_lookup (Branch l r) bs)\n                                  (bdd_lookup (Leaf i) bs)))\n 2. \\<And>i l r T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) (Leaf i);\n                 bdd_all (dfa_is_node M) l\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq (Leaf i) l T) =\n                                  (\\<exists>bs.\nbddh (length bs) (Leaf i) \\<and>\nbddh (length bs) l \\<and>\n(\\<exists>n<m.\n    dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup l bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) (Leaf i);\n         bdd_all (dfa_is_node M) r\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq (Leaf i) r T) =\n                          (\\<exists>bs.\n                              bddh (length bs) (Leaf i) \\<and>\n                              bddh (length bs) r \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                   (bdd_lookup r bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Leaf i);\n        bdd_all (dfa_is_node M) (Branch l r)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Leaf i) (Branch l r) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Leaf i) \\<and>\n                             bddh (length bs) (Branch l r) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                  (bdd_lookup (Branch l r) bs)))\n 3. \\<And>l1 r1 l2 r2 T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) l1;\n                 bdd_all (dfa_is_node M) l2\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq l1 l2 T) =\n                                  (\\<exists>bs.\nbddh (length bs) l1 \\<and>\nbddh (length bs) l2 \\<and>\n(\\<exists>n<m. dist_nodes M n v (bdd_lookup l1 bs) (bdd_lookup l2 bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) r1;\n         bdd_all (dfa_is_node M) r2\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq r1 r2 T) =\n                          (\\<exists>bs.\n                              bddh (length bs) r1 \\<and>\n                              bddh (length bs) r2 \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup r1 bs)\n                                   (bdd_lookup r2 bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Branch l1 r1);\n        bdd_all (dfa_is_node M) (Branch l2 r2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Branch l1 r1) (Branch l2 r2) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Branch l1 r1) \\<and>\n                             bddh (length bs) (Branch l2 r2) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v\n                                  (bdd_lookup (Branch l1 r1) bs)\n                                  (bdd_lookup (Branch l2 r2) bs)))", "also"], ["proof (state)\nthis:\n  (\\<not> check_eq (Branch l r) (Leaf i) T) =\n  (\\<not> check_eq l (Leaf i) T \\<or> \\<not> check_eq r (Leaf i) T)\n\ngoal (3 subgoals):\n 1. \\<And>l r i T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) l;\n                 bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq l (Leaf i) T) =\n                                  (\\<exists>bs.\nbddh (length bs) l \\<and>\nbddh (length bs) (Leaf i) \\<and>\n(\\<exists>n<m.\n    dist_nodes M n v (bdd_lookup l bs) (bdd_lookup (Leaf i) bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) r;\n         bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq r (Leaf i) T) =\n                          (\\<exists>bs.\n                              bddh (length bs) r \\<and>\n                              bddh (length bs) (Leaf i) \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup r bs)\n                                   (bdd_lookup (Leaf i) bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Branch l r);\n        bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Branch l r) (Leaf i) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Branch l r) \\<and>\n                             bddh (length bs) (Leaf i) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v\n                                  (bdd_lookup (Branch l r) bs)\n                                  (bdd_lookup (Leaf i) bs)))\n 2. \\<And>i l r T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) (Leaf i);\n                 bdd_all (dfa_is_node M) l\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq (Leaf i) l T) =\n                                  (\\<exists>bs.\nbddh (length bs) (Leaf i) \\<and>\nbddh (length bs) l \\<and>\n(\\<exists>n<m.\n    dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup l bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) (Leaf i);\n         bdd_all (dfa_is_node M) r\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq (Leaf i) r T) =\n                          (\\<exists>bs.\n                              bddh (length bs) (Leaf i) \\<and>\n                              bddh (length bs) r \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                   (bdd_lookup r bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Leaf i);\n        bdd_all (dfa_is_node M) (Branch l r)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Leaf i) (Branch l r) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Leaf i) \\<and>\n                             bddh (length bs) (Branch l r) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                  (bdd_lookup (Branch l r) bs)))\n 3. \\<And>l1 r1 l2 r2 T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) l1;\n                 bdd_all (dfa_is_node M) l2\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq l1 l2 T) =\n                                  (\\<exists>bs.\nbddh (length bs) l1 \\<and>\nbddh (length bs) l2 \\<and>\n(\\<exists>n<m. dist_nodes M n v (bdd_lookup l1 bs) (bdd_lookup l2 bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) r1;\n         bdd_all (dfa_is_node M) r2\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq r1 r2 T) =\n                          (\\<exists>bs.\n                              bddh (length bs) r1 \\<and>\n                              bddh (length bs) r2 \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup r1 bs)\n                                   (bdd_lookup r2 bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Branch l1 r1);\n        bdd_all (dfa_is_node M) (Branch l2 r2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Branch l1 r1) (Branch l2 r2) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Branch l1 r1) \\<and>\n                             bddh (length bs) (Branch l2 r2) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v\n                                  (bdd_lookup (Branch l1 r1) bs)\n                                  (bdd_lookup (Branch l2 r2) bs)))", "have \"\\<dots> = (\\<exists>bs. bddh (length bs) (Branch l r) \\<and> bddh (length bs) (Leaf i) \\<and> (\\<exists>n<m . dist_nodes M n v (bdd_lookup (Branch l r) bs) (bdd_lookup (Leaf i) bs)))\" (is \"(?L \\<or> ?R) = ?E\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> check_eq l (Leaf i) T \\<or> \\<not> check_eq r (Leaf i) T) =\n    (\\<exists>bs.\n        bddh (length bs) (Branch l r) \\<and>\n        bddh (length bs) (Leaf i) \\<and>\n        (\\<exists>n<m.\n            dist_nodes M n v (bdd_lookup (Branch l r) bs)\n             (bdd_lookup (Leaf i) bs)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> check_eq l (Leaf i) T \\<or>\n    \\<not> check_eq r (Leaf i) T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l r) bs)\n            (bdd_lookup (Leaf i) bs))\n 2. \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l r) bs)\n            (bdd_lookup (Leaf i) bs)) \\<Longrightarrow>\n    \\<not> check_eq l (Leaf i) T \\<or> \\<not> check_eq r (Leaf i) T", "assume \"?L \\<or> ?R\""], ["proof (state)\nthis:\n  \\<not> check_eq l (Leaf i) T \\<or> \\<not> check_eq r (Leaf i) T\n\ngoal (2 subgoals):\n 1. \\<not> check_eq l (Leaf i) T \\<or>\n    \\<not> check_eq r (Leaf i) T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l r) bs)\n            (bdd_lookup (Leaf i) bs))\n 2. \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l r) bs)\n            (bdd_lookup (Leaf i) bs)) \\<Longrightarrow>\n    \\<not> check_eq l (Leaf i) T \\<or> \\<not> check_eq r (Leaf i) T", "thus \"?E\""], ["proof (prove)\nusing this:\n  \\<not> check_eq l (Leaf i) T \\<or> \\<not> check_eq r (Leaf i) T\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l r) bs)\n            (bdd_lookup (Leaf i) bs))", "proof (elim disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> check_eq l (Leaf i) T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l r) bs)\n            (bdd_lookup (Leaf i) bs))\n 2. \\<not> check_eq r (Leaf i) T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l r) bs)\n            (bdd_lookup (Leaf i) bs))", "assume \"?L\""], ["proof (state)\nthis:\n  \\<not> check_eq l (Leaf i) T\n\ngoal (2 subgoals):\n 1. \\<not> check_eq l (Leaf i) T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l r) bs)\n            (bdd_lookup (Leaf i) bs))\n 2. \\<not> check_eq r (Leaf i) T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l r) bs)\n            (bdd_lookup (Leaf i) bs))", "then"], ["proof (chain)\npicking this:\n  \\<not> check_eq l (Leaf i) T", "obtain bs where O: \"bddh (length bs) l \\<and> bddh (length bs) (Leaf i) \\<and> (\\<exists>n<m. dist_nodes M n v (bdd_lookup l bs) (bdd_lookup (Leaf i) bs))\""], ["proof (prove)\nusing this:\n  \\<not> check_eq l (Leaf i) T\n\ngoal (1 subgoal):\n 1. (\\<And>bs.\n        bddh (length bs) l \\<and>\n        bddh (length bs) (Leaf i) \\<and>\n        (\\<exists>n<m.\n            dist_nodes M n v (bdd_lookup l bs)\n             (bdd_lookup (Leaf i) bs)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding IV1"], ["proof (prove)\nusing this:\n  \\<exists>bs.\n     bddh (length bs) l \\<and>\n     bddh (length bs) (Leaf i) \\<and>\n     (\\<exists>n<m.\n         dist_nodes M n v (bdd_lookup l bs) (bdd_lookup (Leaf i) bs))\n\ngoal (1 subgoal):\n 1. (\\<And>bs.\n        bddh (length bs) l \\<and>\n        bddh (length bs) (Leaf i) \\<and>\n        (\\<exists>n<m.\n            dist_nodes M n v (bdd_lookup l bs)\n             (bdd_lookup (Leaf i) bs)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  bddh (length bs) l \\<and>\n  bddh (length bs) (Leaf i) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup l bs) (bdd_lookup (Leaf i) bs))\n\ngoal (2 subgoals):\n 1. \\<not> check_eq l (Leaf i) T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l r) bs)\n            (bdd_lookup (Leaf i) bs))\n 2. \\<not> check_eq r (Leaf i) T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l r) bs)\n            (bdd_lookup (Leaf i) bs))", "from bddh_exists"], ["proof (chain)\npicking this:\n  \\<exists>n. bddh n ?B", "obtain k where B: \"bddh k r\""], ["proof (prove)\nusing this:\n  \\<exists>n. bddh n ?B\n\ngoal (1 subgoal):\n 1. (\\<And>k. bddh k r \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  bddh k r\n\ngoal (2 subgoals):\n 1. \\<not> check_eq l (Leaf i) T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l r) bs)\n            (bdd_lookup (Leaf i) bs))\n 2. \\<not> check_eq r (Leaf i) T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l r) bs)\n            (bdd_lookup (Leaf i) bs))", "with O"], ["proof (chain)\npicking this:\n  bddh (length bs) l \\<and>\n  bddh (length bs) (Leaf i) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup l bs) (bdd_lookup (Leaf i) bs))\n  bddh k r", "have \"bddh (length bs + k) r\" and \"bddh (length bs + k) l\" and \"bddh (length bs + k) (Leaf i)\""], ["proof (prove)\nusing this:\n  bddh (length bs) l \\<and>\n  bddh (length bs) (Leaf i) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup l bs) (bdd_lookup (Leaf i) bs))\n  bddh k r\n\ngoal (1 subgoal):\n 1. bddh (length bs + k) r &&&\n    bddh (length bs + k) l &&& bddh (length bs + k) (Leaf i)", "by (simp add: bddh_ge[of k \"length bs + k\"] bddh_ge[of \"length bs\" \"length bs + k\"])+"], ["proof (state)\nthis:\n  bddh (length bs + k) r\n  bddh (length bs + k) l\n  bddh (length bs + k) (Leaf i)\n\ngoal (2 subgoals):\n 1. \\<not> check_eq l (Leaf i) T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l r) bs)\n            (bdd_lookup (Leaf i) bs))\n 2. \\<not> check_eq r (Leaf i) T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l r) bs)\n            (bdd_lookup (Leaf i) bs))", "with O"], ["proof (chain)\npicking this:\n  bddh (length bs) l \\<and>\n  bddh (length bs) (Leaf i) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup l bs) (bdd_lookup (Leaf i) bs))\n  bddh (length bs + k) r\n  bddh (length bs + k) l\n  bddh (length bs + k) (Leaf i)", "have \"bddh (length (False # bs @ replicate k False)) (Branch l r) \\<and> bddh (length (False # bs @ replicate k False)) (Leaf i) \\<and> (\\<exists>n<m. dist_nodes M n v (bdd_lookup (Branch l r) (False # bs @ replicate k False)) (bdd_lookup (Leaf i) (False # bs @ replicate k False)))\""], ["proof (prove)\nusing this:\n  bddh (length bs) l \\<and>\n  bddh (length bs) (Leaf i) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup l bs) (bdd_lookup (Leaf i) bs))\n  bddh (length bs + k) r\n  bddh (length bs + k) l\n  bddh (length bs + k) (Leaf i)\n\ngoal (1 subgoal):\n 1. bddh (length (False # bs @ replicate k False)) (Branch l r) \\<and>\n    bddh (length (False # bs @ replicate k False)) (Leaf i) \\<and>\n    (\\<exists>n<m.\n        dist_nodes M n v\n         (bdd_lookup (Branch l r) (False # bs @ replicate k False))\n         (bdd_lookup (Leaf i) (False # bs @ replicate k False)))", "by (auto simp: bdd_lookup_append)"], ["proof (state)\nthis:\n  bddh (length (False # bs @ replicate k False)) (Branch l r) \\<and>\n  bddh (length (False # bs @ replicate k False)) (Leaf i) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v\n       (bdd_lookup (Branch l r) (False # bs @ replicate k False))\n       (bdd_lookup (Leaf i) (False # bs @ replicate k False)))\n\ngoal (2 subgoals):\n 1. \\<not> check_eq l (Leaf i) T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l r) bs)\n            (bdd_lookup (Leaf i) bs))\n 2. \\<not> check_eq r (Leaf i) T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l r) bs)\n            (bdd_lookup (Leaf i) bs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  bddh (length (False # bs @ replicate k False)) (Branch l r) \\<and>\n  bddh (length (False # bs @ replicate k False)) (Leaf i) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v\n       (bdd_lookup (Branch l r) (False # bs @ replicate k False))\n       (bdd_lookup (Leaf i) (False # bs @ replicate k False)))\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l r) bs)\n            (bdd_lookup (Leaf i) bs))", "by (rule exI)"], ["proof (state)\nthis:\n  \\<exists>bs.\n     bddh (length bs) (Branch l r) \\<and>\n     bddh (length bs) (Leaf i) \\<and>\n     (\\<exists>n<m.\n         dist_nodes M n v (bdd_lookup (Branch l r) bs)\n          (bdd_lookup (Leaf i) bs))\n\ngoal (1 subgoal):\n 1. \\<not> check_eq r (Leaf i) T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l r) bs)\n            (bdd_lookup (Leaf i) bs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> check_eq r (Leaf i) T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l r) bs)\n            (bdd_lookup (Leaf i) bs))", "assume \"?R\""], ["proof (state)\nthis:\n  \\<not> check_eq r (Leaf i) T\n\ngoal (1 subgoal):\n 1. \\<not> check_eq r (Leaf i) T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l r) bs)\n            (bdd_lookup (Leaf i) bs))", "then"], ["proof (chain)\npicking this:\n  \\<not> check_eq r (Leaf i) T", "obtain bs where O: \"bddh (length bs) r \\<and> bddh (length bs) (Leaf i) \\<and> (\\<exists>n<m. dist_nodes M n v (bdd_lookup r bs) (bdd_lookup (Leaf i) bs))\""], ["proof (prove)\nusing this:\n  \\<not> check_eq r (Leaf i) T\n\ngoal (1 subgoal):\n 1. (\\<And>bs.\n        bddh (length bs) r \\<and>\n        bddh (length bs) (Leaf i) \\<and>\n        (\\<exists>n<m.\n            dist_nodes M n v (bdd_lookup r bs)\n             (bdd_lookup (Leaf i) bs)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding IV2"], ["proof (prove)\nusing this:\n  \\<exists>bs.\n     bddh (length bs) r \\<and>\n     bddh (length bs) (Leaf i) \\<and>\n     (\\<exists>n<m.\n         dist_nodes M n v (bdd_lookup r bs) (bdd_lookup (Leaf i) bs))\n\ngoal (1 subgoal):\n 1. (\\<And>bs.\n        bddh (length bs) r \\<and>\n        bddh (length bs) (Leaf i) \\<and>\n        (\\<exists>n<m.\n            dist_nodes M n v (bdd_lookup r bs)\n             (bdd_lookup (Leaf i) bs)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  bddh (length bs) r \\<and>\n  bddh (length bs) (Leaf i) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup r bs) (bdd_lookup (Leaf i) bs))\n\ngoal (1 subgoal):\n 1. \\<not> check_eq r (Leaf i) T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l r) bs)\n            (bdd_lookup (Leaf i) bs))", "from bddh_exists"], ["proof (chain)\npicking this:\n  \\<exists>n. bddh n ?B", "obtain k where B: \"bddh k l\""], ["proof (prove)\nusing this:\n  \\<exists>n. bddh n ?B\n\ngoal (1 subgoal):\n 1. (\\<And>k. bddh k l \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  bddh k l\n\ngoal (1 subgoal):\n 1. \\<not> check_eq r (Leaf i) T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l r) bs)\n            (bdd_lookup (Leaf i) bs))", "with O"], ["proof (chain)\npicking this:\n  bddh (length bs) r \\<and>\n  bddh (length bs) (Leaf i) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup r bs) (bdd_lookup (Leaf i) bs))\n  bddh k l", "have \"bddh (length bs + k) l\" and \"bddh (length bs + k) r\" and \"bddh (length bs + k) (Leaf i)\""], ["proof (prove)\nusing this:\n  bddh (length bs) r \\<and>\n  bddh (length bs) (Leaf i) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup r bs) (bdd_lookup (Leaf i) bs))\n  bddh k l\n\ngoal (1 subgoal):\n 1. bddh (length bs + k) l &&&\n    bddh (length bs + k) r &&& bddh (length bs + k) (Leaf i)", "by (simp add: bddh_ge[of k \"length bs + k\"] bddh_ge[of \"length bs\" \"length bs + k\"])+"], ["proof (state)\nthis:\n  bddh (length bs + k) l\n  bddh (length bs + k) r\n  bddh (length bs + k) (Leaf i)\n\ngoal (1 subgoal):\n 1. \\<not> check_eq r (Leaf i) T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l r) bs)\n            (bdd_lookup (Leaf i) bs))", "with O"], ["proof (chain)\npicking this:\n  bddh (length bs) r \\<and>\n  bddh (length bs) (Leaf i) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup r bs) (bdd_lookup (Leaf i) bs))\n  bddh (length bs + k) l\n  bddh (length bs + k) r\n  bddh (length bs + k) (Leaf i)", "have \"bddh (length (True # bs @ replicate k False)) (Branch l r) \\<and> bddh (length (True # bs @ replicate k False)) (Leaf i) \\<and> (\\<exists>n<m. dist_nodes M n v (bdd_lookup (Branch l r) (True # bs @ replicate k False)) (bdd_lookup (Leaf i) (True # bs @ replicate k False)))\""], ["proof (prove)\nusing this:\n  bddh (length bs) r \\<and>\n  bddh (length bs) (Leaf i) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup r bs) (bdd_lookup (Leaf i) bs))\n  bddh (length bs + k) l\n  bddh (length bs + k) r\n  bddh (length bs + k) (Leaf i)\n\ngoal (1 subgoal):\n 1. bddh (length (True # bs @ replicate k False)) (Branch l r) \\<and>\n    bddh (length (True # bs @ replicate k False)) (Leaf i) \\<and>\n    (\\<exists>n<m.\n        dist_nodes M n v\n         (bdd_lookup (Branch l r) (True # bs @ replicate k False))\n         (bdd_lookup (Leaf i) (True # bs @ replicate k False)))", "by (auto simp: bdd_lookup_append)"], ["proof (state)\nthis:\n  bddh (length (True # bs @ replicate k False)) (Branch l r) \\<and>\n  bddh (length (True # bs @ replicate k False)) (Leaf i) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v\n       (bdd_lookup (Branch l r) (True # bs @ replicate k False))\n       (bdd_lookup (Leaf i) (True # bs @ replicate k False)))\n\ngoal (1 subgoal):\n 1. \\<not> check_eq r (Leaf i) T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l r) bs)\n            (bdd_lookup (Leaf i) bs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  bddh (length (True # bs @ replicate k False)) (Branch l r) \\<and>\n  bddh (length (True # bs @ replicate k False)) (Leaf i) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v\n       (bdd_lookup (Branch l r) (True # bs @ replicate k False))\n       (bdd_lookup (Leaf i) (True # bs @ replicate k False)))\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l r) bs)\n            (bdd_lookup (Leaf i) bs))", "by (rule exI)"], ["proof (state)\nthis:\n  \\<exists>bs.\n     bddh (length bs) (Branch l r) \\<and>\n     bddh (length bs) (Leaf i) \\<and>\n     (\\<exists>n<m.\n         dist_nodes M n v (bdd_lookup (Branch l r) bs)\n          (bdd_lookup (Leaf i) bs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>bs.\n     bddh (length bs) (Branch l r) \\<and>\n     bddh (length bs) (Leaf i) \\<and>\n     (\\<exists>n<m.\n         dist_nodes M n v (bdd_lookup (Branch l r) bs)\n          (bdd_lookup (Leaf i) bs))\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l r) bs)\n            (bdd_lookup (Leaf i) bs)) \\<Longrightarrow>\n    \\<not> check_eq l (Leaf i) T \\<or> \\<not> check_eq r (Leaf i) T", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l r) bs)\n            (bdd_lookup (Leaf i) bs)) \\<Longrightarrow>\n    \\<not> check_eq l (Leaf i) T \\<or> \\<not> check_eq r (Leaf i) T", "assume \"?E\""], ["proof (state)\nthis:\n  \\<exists>bs.\n     bddh (length bs) (Branch l r) \\<and>\n     bddh (length bs) (Leaf i) \\<and>\n     (\\<exists>n<m.\n         dist_nodes M n v (bdd_lookup (Branch l r) bs)\n          (bdd_lookup (Leaf i) bs))\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l r) bs)\n            (bdd_lookup (Leaf i) bs)) \\<Longrightarrow>\n    \\<not> check_eq l (Leaf i) T \\<or> \\<not> check_eq r (Leaf i) T", "then"], ["proof (chain)\npicking this:\n  \\<exists>bs.\n     bddh (length bs) (Branch l r) \\<and>\n     bddh (length bs) (Leaf i) \\<and>\n     (\\<exists>n<m.\n         dist_nodes M n v (bdd_lookup (Branch l r) bs)\n          (bdd_lookup (Leaf i) bs))", "obtain bs where O: \"bddh (length bs) (Branch l r) \\<and> bddh (length bs) (Leaf i) \\<and> (\\<exists>n<m. dist_nodes M n v (bdd_lookup (Branch l r) bs) (bdd_lookup (Leaf i) bs))\""], ["proof (prove)\nusing this:\n  \\<exists>bs.\n     bddh (length bs) (Branch l r) \\<and>\n     bddh (length bs) (Leaf i) \\<and>\n     (\\<exists>n<m.\n         dist_nodes M n v (bdd_lookup (Branch l r) bs)\n          (bdd_lookup (Leaf i) bs))\n\ngoal (1 subgoal):\n 1. (\\<And>bs.\n        bddh (length bs) (Branch l r) \\<and>\n        bddh (length bs) (Leaf i) \\<and>\n        (\\<exists>n<m.\n            dist_nodes M n v (bdd_lookup (Branch l r) bs)\n             (bdd_lookup (Leaf i) bs)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  bddh (length bs) (Branch l r) \\<and>\n  bddh (length bs) (Leaf i) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup (Branch l r) bs)\n       (bdd_lookup (Leaf i) bs))\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l r) bs)\n            (bdd_lookup (Leaf i) bs)) \\<Longrightarrow>\n    \\<not> check_eq l (Leaf i) T \\<or> \\<not> check_eq r (Leaf i) T", "then"], ["proof (chain)\npicking this:\n  bddh (length bs) (Branch l r) \\<and>\n  bddh (length bs) (Leaf i) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup (Branch l r) bs)\n       (bdd_lookup (Leaf i) bs))", "obtain b br where B: \"bs = b # br\""], ["proof (prove)\nusing this:\n  bddh (length bs) (Branch l r) \\<and>\n  bddh (length bs) (Leaf i) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup (Branch l r) bs)\n       (bdd_lookup (Leaf i) bs))\n\ngoal (1 subgoal):\n 1. (\\<And>b br. bs = b # br \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases bs) auto"], ["proof (state)\nthis:\n  bs = b # br\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l r) bs)\n            (bdd_lookup (Leaf i) bs)) \\<Longrightarrow>\n    \\<not> check_eq l (Leaf i) T \\<or> \\<not> check_eq r (Leaf i) T", "with O IV1 IV2"], ["proof (chain)\npicking this:\n  bddh (length bs) (Branch l r) \\<and>\n  bddh (length bs) (Leaf i) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup (Branch l r) bs)\n       (bdd_lookup (Leaf i) bs))\n  (\\<not> check_eq l (Leaf i) T) =\n  (\\<exists>bs.\n      bddh (length bs) l \\<and>\n      bddh (length bs) (Leaf i) \\<and>\n      (\\<exists>n<m.\n          dist_nodes M n v (bdd_lookup l bs) (bdd_lookup (Leaf i) bs)))\n  (\\<not> check_eq r (Leaf i) T) =\n  (\\<exists>bs.\n      bddh (length bs) r \\<and>\n      bddh (length bs) (Leaf i) \\<and>\n      (\\<exists>n<m.\n          dist_nodes M n v (bdd_lookup r bs) (bdd_lookup (Leaf i) bs)))\n  bs = b # br", "show \"?L \\<or> ?R\""], ["proof (prove)\nusing this:\n  bddh (length bs) (Branch l r) \\<and>\n  bddh (length bs) (Leaf i) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup (Branch l r) bs)\n       (bdd_lookup (Leaf i) bs))\n  (\\<not> check_eq l (Leaf i) T) =\n  (\\<exists>bs.\n      bddh (length bs) l \\<and>\n      bddh (length bs) (Leaf i) \\<and>\n      (\\<exists>n<m.\n          dist_nodes M n v (bdd_lookup l bs) (bdd_lookup (Leaf i) bs)))\n  (\\<not> check_eq r (Leaf i) T) =\n  (\\<exists>bs.\n      bddh (length bs) r \\<and>\n      bddh (length bs) (Leaf i) \\<and>\n      (\\<exists>n<m.\n          dist_nodes M n v (bdd_lookup r bs) (bdd_lookup (Leaf i) bs)))\n  bs = b # br\n\ngoal (1 subgoal):\n 1. \\<not> check_eq l (Leaf i) T \\<or> \\<not> check_eq r (Leaf i) T", "by (cases b) auto"], ["proof (state)\nthis:\n  \\<not> check_eq l (Leaf i) T \\<or> \\<not> check_eq r (Leaf i) T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<not> check_eq l (Leaf i) T \\<or> \\<not> check_eq r (Leaf i) T) =\n  (\\<exists>bs.\n      bddh (length bs) (Branch l r) \\<and>\n      bddh (length bs) (Leaf i) \\<and>\n      (\\<exists>n<m.\n          dist_nodes M n v (bdd_lookup (Branch l r) bs)\n           (bdd_lookup (Leaf i) bs)))\n\ngoal (3 subgoals):\n 1. \\<And>l r i T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) l;\n                 bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq l (Leaf i) T) =\n                                  (\\<exists>bs.\nbddh (length bs) l \\<and>\nbddh (length bs) (Leaf i) \\<and>\n(\\<exists>n<m.\n    dist_nodes M n v (bdd_lookup l bs) (bdd_lookup (Leaf i) bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) r;\n         bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq r (Leaf i) T) =\n                          (\\<exists>bs.\n                              bddh (length bs) r \\<and>\n                              bddh (length bs) (Leaf i) \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup r bs)\n                                   (bdd_lookup (Leaf i) bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Branch l r);\n        bdd_all (dfa_is_node M) (Leaf i)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Branch l r) (Leaf i) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Branch l r) \\<and>\n                             bddh (length bs) (Leaf i) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v\n                                  (bdd_lookup (Branch l r) bs)\n                                  (bdd_lookup (Leaf i) bs)))\n 2. \\<And>i l r T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) (Leaf i);\n                 bdd_all (dfa_is_node M) l\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq (Leaf i) l T) =\n                                  (\\<exists>bs.\nbddh (length bs) (Leaf i) \\<and>\nbddh (length bs) l \\<and>\n(\\<exists>n<m.\n    dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup l bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) (Leaf i);\n         bdd_all (dfa_is_node M) r\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq (Leaf i) r T) =\n                          (\\<exists>bs.\n                              bddh (length bs) (Leaf i) \\<and>\n                              bddh (length bs) r \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                   (bdd_lookup r bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Leaf i);\n        bdd_all (dfa_is_node M) (Branch l r)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Leaf i) (Branch l r) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Leaf i) \\<and>\n                             bddh (length bs) (Branch l r) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                  (bdd_lookup (Branch l r) bs)))\n 3. \\<And>l1 r1 l2 r2 T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) l1;\n                 bdd_all (dfa_is_node M) l2\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq l1 l2 T) =\n                                  (\\<exists>bs.\nbddh (length bs) l1 \\<and>\nbddh (length bs) l2 \\<and>\n(\\<exists>n<m. dist_nodes M n v (bdd_lookup l1 bs) (bdd_lookup l2 bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) r1;\n         bdd_all (dfa_is_node M) r2\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq r1 r2 T) =\n                          (\\<exists>bs.\n                              bddh (length bs) r1 \\<and>\n                              bddh (length bs) r2 \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup r1 bs)\n                                   (bdd_lookup r2 bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Branch l1 r1);\n        bdd_all (dfa_is_node M) (Branch l2 r2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Branch l1 r1) (Branch l2 r2) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Branch l1 r1) \\<and>\n                             bddh (length bs) (Branch l2 r2) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v\n                                  (bdd_lookup (Branch l1 r1) bs)\n                                  (bdd_lookup (Branch l2 r2) bs)))", "finally"], ["proof (chain)\npicking this:\n  (\\<not> check_eq (Branch l r) (Leaf i) T) =\n  (\\<exists>bs.\n      bddh (length bs) (Branch l r) \\<and>\n      bddh (length bs) (Leaf i) \\<and>\n      (\\<exists>n<m.\n          dist_nodes M n v (bdd_lookup (Branch l r) bs)\n           (bdd_lookup (Leaf i) bs)))", "show ?case"], ["proof (prove)\nusing this:\n  (\\<not> check_eq (Branch l r) (Leaf i) T) =\n  (\\<exists>bs.\n      bddh (length bs) (Branch l r) \\<and>\n      bddh (length bs) (Leaf i) \\<and>\n      (\\<exists>n<m.\n          dist_nodes M n v (bdd_lookup (Branch l r) bs)\n           (bdd_lookup (Leaf i) bs)))\n\ngoal (1 subgoal):\n 1. (\\<not> check_eq (Branch l r) (Leaf i) T) =\n    (\\<exists>bs.\n        bddh (length bs) (Branch l r) \\<and>\n        bddh (length bs) (Leaf i) \\<and>\n        (\\<exists>n<m.\n            dist_nodes M n v (bdd_lookup (Branch l r) bs)\n             (bdd_lookup (Leaf i) bs)))", "by simp"], ["proof (state)\nthis:\n  (\\<not> check_eq (Branch l r) (Leaf i) T) =\n  (\\<exists>bs.\n      bddh (length bs) (Branch l r) \\<and>\n      bddh (length bs) (Leaf i) \\<and>\n      (\\<exists>n<m.\n          dist_nodes M n v (bdd_lookup (Branch l r) bs)\n           (bdd_lookup (Leaf i) bs)))\n\ngoal (2 subgoals):\n 1. \\<And>i l r T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) (Leaf i);\n                 bdd_all (dfa_is_node M) l\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq (Leaf i) l T) =\n                                  (\\<exists>bs.\nbddh (length bs) (Leaf i) \\<and>\nbddh (length bs) l \\<and>\n(\\<exists>n<m.\n    dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup l bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) (Leaf i);\n         bdd_all (dfa_is_node M) r\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq (Leaf i) r T) =\n                          (\\<exists>bs.\n                              bddh (length bs) (Leaf i) \\<and>\n                              bddh (length bs) r \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                   (bdd_lookup r bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Leaf i);\n        bdd_all (dfa_is_node M) (Branch l r)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Leaf i) (Branch l r) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Leaf i) \\<and>\n                             bddh (length bs) (Branch l r) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                  (bdd_lookup (Branch l r) bs)))\n 2. \\<And>l1 r1 l2 r2 T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) l1;\n                 bdd_all (dfa_is_node M) l2\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq l1 l2 T) =\n                                  (\\<exists>bs.\nbddh (length bs) l1 \\<and>\nbddh (length bs) l2 \\<and>\n(\\<exists>n<m. dist_nodes M n v (bdd_lookup l1 bs) (bdd_lookup l2 bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) r1;\n         bdd_all (dfa_is_node M) r2\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq r1 r2 T) =\n                          (\\<exists>bs.\n                              bddh (length bs) r1 \\<and>\n                              bddh (length bs) r2 \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup r1 bs)\n                                   (bdd_lookup r2 bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Branch l1 r1);\n        bdd_all (dfa_is_node M) (Branch l2 r2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Branch l1 r1) (Branch l2 r2) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Branch l1 r1) \\<and>\n                             bddh (length bs) (Branch l2 r2) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v\n                                  (bdd_lookup (Branch l1 r1) bs)\n                                  (bdd_lookup (Branch l2 r2) bs)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i l r T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) (Leaf i);\n                 bdd_all (dfa_is_node M) l\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq (Leaf i) l T) =\n                                  (\\<exists>bs.\nbddh (length bs) (Leaf i) \\<and>\nbddh (length bs) l \\<and>\n(\\<exists>n<m.\n    dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup l bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) (Leaf i);\n         bdd_all (dfa_is_node M) r\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq (Leaf i) r T) =\n                          (\\<exists>bs.\n                              bddh (length bs) (Leaf i) \\<and>\n                              bddh (length bs) r \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                   (bdd_lookup r bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Leaf i);\n        bdd_all (dfa_is_node M) (Branch l r)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Leaf i) (Branch l r) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Leaf i) \\<and>\n                             bddh (length bs) (Branch l r) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                  (bdd_lookup (Branch l r) bs)))\n 2. \\<And>l1 r1 l2 r2 T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) l1;\n                 bdd_all (dfa_is_node M) l2\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq l1 l2 T) =\n                                  (\\<exists>bs.\nbddh (length bs) l1 \\<and>\nbddh (length bs) l2 \\<and>\n(\\<exists>n<m. dist_nodes M n v (bdd_lookup l1 bs) (bdd_lookup l2 bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) r1;\n         bdd_all (dfa_is_node M) r2\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq r1 r2 T) =\n                          (\\<exists>bs.\n                              bddh (length bs) r1 \\<and>\n                              bddh (length bs) r2 \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup r1 bs)\n                                   (bdd_lookup r2 bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Branch l1 r1);\n        bdd_all (dfa_is_node M) (Branch l2 r2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Branch l1 r1) (Branch l2 r2) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Branch l1 r1) \\<and>\n                             bddh (length bs) (Branch l2 r2) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v\n                                  (bdd_lookup (Branch l1 r1) bs)\n                                  (bdd_lookup (Branch l2 r2) bs)))", "case (3 i l r T)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>p q.\n              dfa_is_node M q \\<and> p < q \\<longrightarrow>\n              tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n   0 < m; bdd_all (dfa_is_node M) (Leaf i);\n   bdd_all (dfa_is_node M) l\\<rbrakk>\n  \\<Longrightarrow> (\\<not> check_eq (Leaf i) l T) =\n                    (\\<exists>bs.\n                        bddh (length bs) (Leaf i) \\<and>\n                        bddh (length bs) l \\<and>\n                        (\\<exists>n<m.\n                            dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                             (bdd_lookup l bs)))\n  \\<lbrakk>\\<forall>p q.\n              dfa_is_node M q \\<and> p < q \\<longrightarrow>\n              tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n   0 < m; bdd_all (dfa_is_node M) (Leaf i);\n   bdd_all (dfa_is_node M) r\\<rbrakk>\n  \\<Longrightarrow> (\\<not> check_eq (Leaf i) r T) =\n                    (\\<exists>bs.\n                        bddh (length bs) (Leaf i) \\<and>\n                        bddh (length bs) r \\<and>\n                        (\\<exists>n<m.\n                            dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                             (bdd_lookup r bs)))\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n  bdd_all (dfa_is_node M) (Leaf i)\n  bdd_all (dfa_is_node M) (Branch l r)\n\ngoal (2 subgoals):\n 1. \\<And>i l r T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) (Leaf i);\n                 bdd_all (dfa_is_node M) l\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq (Leaf i) l T) =\n                                  (\\<exists>bs.\nbddh (length bs) (Leaf i) \\<and>\nbddh (length bs) l \\<and>\n(\\<exists>n<m.\n    dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup l bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) (Leaf i);\n         bdd_all (dfa_is_node M) r\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq (Leaf i) r T) =\n                          (\\<exists>bs.\n                              bddh (length bs) (Leaf i) \\<and>\n                              bddh (length bs) r \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                   (bdd_lookup r bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Leaf i);\n        bdd_all (dfa_is_node M) (Branch l r)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Leaf i) (Branch l r) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Leaf i) \\<and>\n                             bddh (length bs) (Branch l r) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                  (bdd_lookup (Branch l r) bs)))\n 2. \\<And>l1 r1 l2 r2 T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) l1;\n                 bdd_all (dfa_is_node M) l2\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq l1 l2 T) =\n                                  (\\<exists>bs.\nbddh (length bs) l1 \\<and>\nbddh (length bs) l2 \\<and>\n(\\<exists>n<m. dist_nodes M n v (bdd_lookup l1 bs) (bdd_lookup l2 bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) r1;\n         bdd_all (dfa_is_node M) r2\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq r1 r2 T) =\n                          (\\<exists>bs.\n                              bddh (length bs) r1 \\<and>\n                              bddh (length bs) r2 \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup r1 bs)\n                                   (bdd_lookup r2 bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Branch l1 r1);\n        bdd_all (dfa_is_node M) (Branch l2 r2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Branch l1 r1) (Branch l2 r2) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Branch l1 r1) \\<and>\n                             bddh (length bs) (Branch l2 r2) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v\n                                  (bdd_lookup (Branch l1 r1) bs)\n                                  (bdd_lookup (Branch l2 r2) bs)))", "hence IV1: \"(\\<not> check_eq (Leaf i) l T) = (\\<exists>bs. bddh (length bs) l \\<and> bddh (length bs) (Leaf i) \\<and> (\\<exists>n<m. dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup l bs)))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>p q.\n              dfa_is_node M q \\<and> p < q \\<longrightarrow>\n              tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n   0 < m; bdd_all (dfa_is_node M) (Leaf i);\n   bdd_all (dfa_is_node M) l\\<rbrakk>\n  \\<Longrightarrow> (\\<not> check_eq (Leaf i) l T) =\n                    (\\<exists>bs.\n                        bddh (length bs) (Leaf i) \\<and>\n                        bddh (length bs) l \\<and>\n                        (\\<exists>n<m.\n                            dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                             (bdd_lookup l bs)))\n  \\<lbrakk>\\<forall>p q.\n              dfa_is_node M q \\<and> p < q \\<longrightarrow>\n              tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n   0 < m; bdd_all (dfa_is_node M) (Leaf i);\n   bdd_all (dfa_is_node M) r\\<rbrakk>\n  \\<Longrightarrow> (\\<not> check_eq (Leaf i) r T) =\n                    (\\<exists>bs.\n                        bddh (length bs) (Leaf i) \\<and>\n                        bddh (length bs) r \\<and>\n                        (\\<exists>n<m.\n                            dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                             (bdd_lookup r bs)))\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n  bdd_all (dfa_is_node M) (Leaf i)\n  bdd_all (dfa_is_node M) (Branch l r)\n\ngoal (1 subgoal):\n 1. (\\<not> check_eq (Leaf i) l T) =\n    (\\<exists>bs.\n        bddh (length bs) l \\<and>\n        bddh (length bs) (Leaf i) \\<and>\n        (\\<exists>n<m.\n            dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup l bs)))", "by simp"], ["proof (state)\nthis:\n  (\\<not> check_eq (Leaf i) l T) =\n  (\\<exists>bs.\n      bddh (length bs) l \\<and>\n      bddh (length bs) (Leaf i) \\<and>\n      (\\<exists>n<m.\n          dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup l bs)))\n\ngoal (2 subgoals):\n 1. \\<And>i l r T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) (Leaf i);\n                 bdd_all (dfa_is_node M) l\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq (Leaf i) l T) =\n                                  (\\<exists>bs.\nbddh (length bs) (Leaf i) \\<and>\nbddh (length bs) l \\<and>\n(\\<exists>n<m.\n    dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup l bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) (Leaf i);\n         bdd_all (dfa_is_node M) r\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq (Leaf i) r T) =\n                          (\\<exists>bs.\n                              bddh (length bs) (Leaf i) \\<and>\n                              bddh (length bs) r \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                   (bdd_lookup r bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Leaf i);\n        bdd_all (dfa_is_node M) (Branch l r)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Leaf i) (Branch l r) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Leaf i) \\<and>\n                             bddh (length bs) (Branch l r) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                  (bdd_lookup (Branch l r) bs)))\n 2. \\<And>l1 r1 l2 r2 T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) l1;\n                 bdd_all (dfa_is_node M) l2\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq l1 l2 T) =\n                                  (\\<exists>bs.\nbddh (length bs) l1 \\<and>\nbddh (length bs) l2 \\<and>\n(\\<exists>n<m. dist_nodes M n v (bdd_lookup l1 bs) (bdd_lookup l2 bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) r1;\n         bdd_all (dfa_is_node M) r2\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq r1 r2 T) =\n                          (\\<exists>bs.\n                              bddh (length bs) r1 \\<and>\n                              bddh (length bs) r2 \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup r1 bs)\n                                   (bdd_lookup r2 bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Branch l1 r1);\n        bdd_all (dfa_is_node M) (Branch l2 r2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Branch l1 r1) (Branch l2 r2) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Branch l1 r1) \\<and>\n                             bddh (length bs) (Branch l2 r2) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v\n                                  (bdd_lookup (Branch l1 r1) bs)\n                                  (bdd_lookup (Branch l2 r2) bs)))", "from 3"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>p q.\n              dfa_is_node M q \\<and> p < q \\<longrightarrow>\n              tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n   0 < m; bdd_all (dfa_is_node M) (Leaf i);\n   bdd_all (dfa_is_node M) l\\<rbrakk>\n  \\<Longrightarrow> (\\<not> check_eq (Leaf i) l T) =\n                    (\\<exists>bs.\n                        bddh (length bs) (Leaf i) \\<and>\n                        bddh (length bs) l \\<and>\n                        (\\<exists>n<m.\n                            dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                             (bdd_lookup l bs)))\n  \\<lbrakk>\\<forall>p q.\n              dfa_is_node M q \\<and> p < q \\<longrightarrow>\n              tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n   0 < m; bdd_all (dfa_is_node M) (Leaf i);\n   bdd_all (dfa_is_node M) r\\<rbrakk>\n  \\<Longrightarrow> (\\<not> check_eq (Leaf i) r T) =\n                    (\\<exists>bs.\n                        bddh (length bs) (Leaf i) \\<and>\n                        bddh (length bs) r \\<and>\n                        (\\<exists>n<m.\n                            dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                             (bdd_lookup r bs)))\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n  bdd_all (dfa_is_node M) (Leaf i)\n  bdd_all (dfa_is_node M) (Branch l r)", "have IV2: \"(\\<not> check_eq (Leaf i) r T) = (\\<exists>bs. bddh (length bs) r \\<and> bddh (length bs) (Leaf i) \\<and> (\\<exists>n<m. dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup r bs)))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>p q.\n              dfa_is_node M q \\<and> p < q \\<longrightarrow>\n              tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n   0 < m; bdd_all (dfa_is_node M) (Leaf i);\n   bdd_all (dfa_is_node M) l\\<rbrakk>\n  \\<Longrightarrow> (\\<not> check_eq (Leaf i) l T) =\n                    (\\<exists>bs.\n                        bddh (length bs) (Leaf i) \\<and>\n                        bddh (length bs) l \\<and>\n                        (\\<exists>n<m.\n                            dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                             (bdd_lookup l bs)))\n  \\<lbrakk>\\<forall>p q.\n              dfa_is_node M q \\<and> p < q \\<longrightarrow>\n              tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n   0 < m; bdd_all (dfa_is_node M) (Leaf i);\n   bdd_all (dfa_is_node M) r\\<rbrakk>\n  \\<Longrightarrow> (\\<not> check_eq (Leaf i) r T) =\n                    (\\<exists>bs.\n                        bddh (length bs) (Leaf i) \\<and>\n                        bddh (length bs) r \\<and>\n                        (\\<exists>n<m.\n                            dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                             (bdd_lookup r bs)))\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n  bdd_all (dfa_is_node M) (Leaf i)\n  bdd_all (dfa_is_node M) (Branch l r)\n\ngoal (1 subgoal):\n 1. (\\<not> check_eq (Leaf i) r T) =\n    (\\<exists>bs.\n        bddh (length bs) r \\<and>\n        bddh (length bs) (Leaf i) \\<and>\n        (\\<exists>n<m.\n            dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup r bs)))", "by simp"], ["proof (state)\nthis:\n  (\\<not> check_eq (Leaf i) r T) =\n  (\\<exists>bs.\n      bddh (length bs) r \\<and>\n      bddh (length bs) (Leaf i) \\<and>\n      (\\<exists>n<m.\n          dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup r bs)))\n\ngoal (2 subgoals):\n 1. \\<And>i l r T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) (Leaf i);\n                 bdd_all (dfa_is_node M) l\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq (Leaf i) l T) =\n                                  (\\<exists>bs.\nbddh (length bs) (Leaf i) \\<and>\nbddh (length bs) l \\<and>\n(\\<exists>n<m.\n    dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup l bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) (Leaf i);\n         bdd_all (dfa_is_node M) r\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq (Leaf i) r T) =\n                          (\\<exists>bs.\n                              bddh (length bs) (Leaf i) \\<and>\n                              bddh (length bs) r \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                   (bdd_lookup r bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Leaf i);\n        bdd_all (dfa_is_node M) (Branch l r)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Leaf i) (Branch l r) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Leaf i) \\<and>\n                             bddh (length bs) (Branch l r) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                  (bdd_lookup (Branch l r) bs)))\n 2. \\<And>l1 r1 l2 r2 T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) l1;\n                 bdd_all (dfa_is_node M) l2\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq l1 l2 T) =\n                                  (\\<exists>bs.\nbddh (length bs) l1 \\<and>\nbddh (length bs) l2 \\<and>\n(\\<exists>n<m. dist_nodes M n v (bdd_lookup l1 bs) (bdd_lookup l2 bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) r1;\n         bdd_all (dfa_is_node M) r2\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq r1 r2 T) =\n                          (\\<exists>bs.\n                              bddh (length bs) r1 \\<and>\n                              bddh (length bs) r2 \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup r1 bs)\n                                   (bdd_lookup r2 bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Branch l1 r1);\n        bdd_all (dfa_is_node M) (Branch l2 r2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Branch l1 r1) (Branch l2 r2) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Branch l1 r1) \\<and>\n                             bddh (length bs) (Branch l2 r2) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v\n                                  (bdd_lookup (Branch l1 r1) bs)\n                                  (bdd_lookup (Branch l2 r2) bs)))", "have \"(\\<not> check_eq (Leaf i) (Branch l r) T) = (\\<not> check_eq (Leaf i) l T \\<or> \\<not> check_eq (Leaf i) r T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> check_eq (Leaf i) (Branch l r) T) =\n    (\\<not> check_eq (Leaf i) l T \\<or> \\<not> check_eq (Leaf i) r T)", "by simp"], ["proof (state)\nthis:\n  (\\<not> check_eq (Leaf i) (Branch l r) T) =\n  (\\<not> check_eq (Leaf i) l T \\<or> \\<not> check_eq (Leaf i) r T)\n\ngoal (2 subgoals):\n 1. \\<And>i l r T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) (Leaf i);\n                 bdd_all (dfa_is_node M) l\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq (Leaf i) l T) =\n                                  (\\<exists>bs.\nbddh (length bs) (Leaf i) \\<and>\nbddh (length bs) l \\<and>\n(\\<exists>n<m.\n    dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup l bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) (Leaf i);\n         bdd_all (dfa_is_node M) r\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq (Leaf i) r T) =\n                          (\\<exists>bs.\n                              bddh (length bs) (Leaf i) \\<and>\n                              bddh (length bs) r \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                   (bdd_lookup r bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Leaf i);\n        bdd_all (dfa_is_node M) (Branch l r)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Leaf i) (Branch l r) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Leaf i) \\<and>\n                             bddh (length bs) (Branch l r) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                  (bdd_lookup (Branch l r) bs)))\n 2. \\<And>l1 r1 l2 r2 T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) l1;\n                 bdd_all (dfa_is_node M) l2\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq l1 l2 T) =\n                                  (\\<exists>bs.\nbddh (length bs) l1 \\<and>\nbddh (length bs) l2 \\<and>\n(\\<exists>n<m. dist_nodes M n v (bdd_lookup l1 bs) (bdd_lookup l2 bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) r1;\n         bdd_all (dfa_is_node M) r2\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq r1 r2 T) =\n                          (\\<exists>bs.\n                              bddh (length bs) r1 \\<and>\n                              bddh (length bs) r2 \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup r1 bs)\n                                   (bdd_lookup r2 bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Branch l1 r1);\n        bdd_all (dfa_is_node M) (Branch l2 r2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Branch l1 r1) (Branch l2 r2) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Branch l1 r1) \\<and>\n                             bddh (length bs) (Branch l2 r2) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v\n                                  (bdd_lookup (Branch l1 r1) bs)\n                                  (bdd_lookup (Branch l2 r2) bs)))", "also"], ["proof (state)\nthis:\n  (\\<not> check_eq (Leaf i) (Branch l r) T) =\n  (\\<not> check_eq (Leaf i) l T \\<or> \\<not> check_eq (Leaf i) r T)\n\ngoal (2 subgoals):\n 1. \\<And>i l r T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) (Leaf i);\n                 bdd_all (dfa_is_node M) l\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq (Leaf i) l T) =\n                                  (\\<exists>bs.\nbddh (length bs) (Leaf i) \\<and>\nbddh (length bs) l \\<and>\n(\\<exists>n<m.\n    dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup l bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) (Leaf i);\n         bdd_all (dfa_is_node M) r\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq (Leaf i) r T) =\n                          (\\<exists>bs.\n                              bddh (length bs) (Leaf i) \\<and>\n                              bddh (length bs) r \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                   (bdd_lookup r bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Leaf i);\n        bdd_all (dfa_is_node M) (Branch l r)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Leaf i) (Branch l r) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Leaf i) \\<and>\n                             bddh (length bs) (Branch l r) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                  (bdd_lookup (Branch l r) bs)))\n 2. \\<And>l1 r1 l2 r2 T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) l1;\n                 bdd_all (dfa_is_node M) l2\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq l1 l2 T) =\n                                  (\\<exists>bs.\nbddh (length bs) l1 \\<and>\nbddh (length bs) l2 \\<and>\n(\\<exists>n<m. dist_nodes M n v (bdd_lookup l1 bs) (bdd_lookup l2 bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) r1;\n         bdd_all (dfa_is_node M) r2\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq r1 r2 T) =\n                          (\\<exists>bs.\n                              bddh (length bs) r1 \\<and>\n                              bddh (length bs) r2 \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup r1 bs)\n                                   (bdd_lookup r2 bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Branch l1 r1);\n        bdd_all (dfa_is_node M) (Branch l2 r2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Branch l1 r1) (Branch l2 r2) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Branch l1 r1) \\<and>\n                             bddh (length bs) (Branch l2 r2) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v\n                                  (bdd_lookup (Branch l1 r1) bs)\n                                  (bdd_lookup (Branch l2 r2) bs)))", "have \"\\<dots> = (\\<exists>bs. bddh (length bs) (Branch l r) \\<and> bddh (length bs) (Leaf i) \\<and> (\\<exists>n<m . dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup (Branch l r) bs)))\" (is \"(?L \\<or> ?R) = ?E\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> check_eq (Leaf i) l T \\<or> \\<not> check_eq (Leaf i) r T) =\n    (\\<exists>bs.\n        bddh (length bs) (Branch l r) \\<and>\n        bddh (length bs) (Leaf i) \\<and>\n        (\\<exists>n<m.\n            dist_nodes M n v (bdd_lookup (Leaf i) bs)\n             (bdd_lookup (Branch l r) bs)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> check_eq (Leaf i) l T \\<or>\n    \\<not> check_eq (Leaf i) r T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Leaf i) bs)\n            (bdd_lookup (Branch l r) bs))\n 2. \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Leaf i) bs)\n            (bdd_lookup (Branch l r) bs)) \\<Longrightarrow>\n    \\<not> check_eq (Leaf i) l T \\<or> \\<not> check_eq (Leaf i) r T", "assume \"?L \\<or> ?R\""], ["proof (state)\nthis:\n  \\<not> check_eq (Leaf i) l T \\<or> \\<not> check_eq (Leaf i) r T\n\ngoal (2 subgoals):\n 1. \\<not> check_eq (Leaf i) l T \\<or>\n    \\<not> check_eq (Leaf i) r T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Leaf i) bs)\n            (bdd_lookup (Branch l r) bs))\n 2. \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Leaf i) bs)\n            (bdd_lookup (Branch l r) bs)) \\<Longrightarrow>\n    \\<not> check_eq (Leaf i) l T \\<or> \\<not> check_eq (Leaf i) r T", "thus \"?E\""], ["proof (prove)\nusing this:\n  \\<not> check_eq (Leaf i) l T \\<or> \\<not> check_eq (Leaf i) r T\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Leaf i) bs)\n            (bdd_lookup (Branch l r) bs))", "proof (elim disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> check_eq (Leaf i) l T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Leaf i) bs)\n            (bdd_lookup (Branch l r) bs))\n 2. \\<not> check_eq (Leaf i) r T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Leaf i) bs)\n            (bdd_lookup (Branch l r) bs))", "assume \"?L\""], ["proof (state)\nthis:\n  \\<not> check_eq (Leaf i) l T\n\ngoal (2 subgoals):\n 1. \\<not> check_eq (Leaf i) l T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Leaf i) bs)\n            (bdd_lookup (Branch l r) bs))\n 2. \\<not> check_eq (Leaf i) r T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Leaf i) bs)\n            (bdd_lookup (Branch l r) bs))", "then"], ["proof (chain)\npicking this:\n  \\<not> check_eq (Leaf i) l T", "obtain bs where O: \"bddh (length bs) l \\<and> bddh (length bs) (Leaf i) \\<and> (\\<exists>n<m. dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup l bs))\""], ["proof (prove)\nusing this:\n  \\<not> check_eq (Leaf i) l T\n\ngoal (1 subgoal):\n 1. (\\<And>bs.\n        bddh (length bs) l \\<and>\n        bddh (length bs) (Leaf i) \\<and>\n        (\\<exists>n<m.\n            dist_nodes M n v (bdd_lookup (Leaf i) bs)\n             (bdd_lookup l bs)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding IV1"], ["proof (prove)\nusing this:\n  \\<exists>bs.\n     bddh (length bs) l \\<and>\n     bddh (length bs) (Leaf i) \\<and>\n     (\\<exists>n<m.\n         dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup l bs))\n\ngoal (1 subgoal):\n 1. (\\<And>bs.\n        bddh (length bs) l \\<and>\n        bddh (length bs) (Leaf i) \\<and>\n        (\\<exists>n<m.\n            dist_nodes M n v (bdd_lookup (Leaf i) bs)\n             (bdd_lookup l bs)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  bddh (length bs) l \\<and>\n  bddh (length bs) (Leaf i) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup l bs))\n\ngoal (2 subgoals):\n 1. \\<not> check_eq (Leaf i) l T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Leaf i) bs)\n            (bdd_lookup (Branch l r) bs))\n 2. \\<not> check_eq (Leaf i) r T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Leaf i) bs)\n            (bdd_lookup (Branch l r) bs))", "from bddh_exists"], ["proof (chain)\npicking this:\n  \\<exists>n. bddh n ?B", "obtain k where B: \"bddh k r\""], ["proof (prove)\nusing this:\n  \\<exists>n. bddh n ?B\n\ngoal (1 subgoal):\n 1. (\\<And>k. bddh k r \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  bddh k r\n\ngoal (2 subgoals):\n 1. \\<not> check_eq (Leaf i) l T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Leaf i) bs)\n            (bdd_lookup (Branch l r) bs))\n 2. \\<not> check_eq (Leaf i) r T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Leaf i) bs)\n            (bdd_lookup (Branch l r) bs))", "with O"], ["proof (chain)\npicking this:\n  bddh (length bs) l \\<and>\n  bddh (length bs) (Leaf i) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup l bs))\n  bddh k r", "have \"bddh (length bs + k) r\" and \"bddh (length bs + k) l\" and \"bddh (length bs + k) (Leaf i)\""], ["proof (prove)\nusing this:\n  bddh (length bs) l \\<and>\n  bddh (length bs) (Leaf i) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup l bs))\n  bddh k r\n\ngoal (1 subgoal):\n 1. bddh (length bs + k) r &&&\n    bddh (length bs + k) l &&& bddh (length bs + k) (Leaf i)", "by (simp add: bddh_ge[of k \"length bs + k\"] bddh_ge[of \"length bs\" \"length bs + k\"])+"], ["proof (state)\nthis:\n  bddh (length bs + k) r\n  bddh (length bs + k) l\n  bddh (length bs + k) (Leaf i)\n\ngoal (2 subgoals):\n 1. \\<not> check_eq (Leaf i) l T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Leaf i) bs)\n            (bdd_lookup (Branch l r) bs))\n 2. \\<not> check_eq (Leaf i) r T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Leaf i) bs)\n            (bdd_lookup (Branch l r) bs))", "with O"], ["proof (chain)\npicking this:\n  bddh (length bs) l \\<and>\n  bddh (length bs) (Leaf i) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup l bs))\n  bddh (length bs + k) r\n  bddh (length bs + k) l\n  bddh (length bs + k) (Leaf i)", "have \"bddh (length (False # bs @ replicate k False)) (Branch l r) \\<and> bddh (length (False # bs @ replicate k False)) (Leaf i) \\<and> (\\<exists>n<m. dist_nodes M n v (bdd_lookup (Leaf i) (False # bs @ replicate k False)) (bdd_lookup (Branch l r) (False # bs @ replicate k False)))\""], ["proof (prove)\nusing this:\n  bddh (length bs) l \\<and>\n  bddh (length bs) (Leaf i) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup l bs))\n  bddh (length bs + k) r\n  bddh (length bs + k) l\n  bddh (length bs + k) (Leaf i)\n\ngoal (1 subgoal):\n 1. bddh (length (False # bs @ replicate k False)) (Branch l r) \\<and>\n    bddh (length (False # bs @ replicate k False)) (Leaf i) \\<and>\n    (\\<exists>n<m.\n        dist_nodes M n v\n         (bdd_lookup (Leaf i) (False # bs @ replicate k False))\n         (bdd_lookup (Branch l r) (False # bs @ replicate k False)))", "by (auto simp: bdd_lookup_append)"], ["proof (state)\nthis:\n  bddh (length (False # bs @ replicate k False)) (Branch l r) \\<and>\n  bddh (length (False # bs @ replicate k False)) (Leaf i) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v\n       (bdd_lookup (Leaf i) (False # bs @ replicate k False))\n       (bdd_lookup (Branch l r) (False # bs @ replicate k False)))\n\ngoal (2 subgoals):\n 1. \\<not> check_eq (Leaf i) l T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Leaf i) bs)\n            (bdd_lookup (Branch l r) bs))\n 2. \\<not> check_eq (Leaf i) r T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Leaf i) bs)\n            (bdd_lookup (Branch l r) bs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  bddh (length (False # bs @ replicate k False)) (Branch l r) \\<and>\n  bddh (length (False # bs @ replicate k False)) (Leaf i) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v\n       (bdd_lookup (Leaf i) (False # bs @ replicate k False))\n       (bdd_lookup (Branch l r) (False # bs @ replicate k False)))\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Leaf i) bs)\n            (bdd_lookup (Branch l r) bs))", "by (rule exI)"], ["proof (state)\nthis:\n  \\<exists>bs.\n     bddh (length bs) (Branch l r) \\<and>\n     bddh (length bs) (Leaf i) \\<and>\n     (\\<exists>n<m.\n         dist_nodes M n v (bdd_lookup (Leaf i) bs)\n          (bdd_lookup (Branch l r) bs))\n\ngoal (1 subgoal):\n 1. \\<not> check_eq (Leaf i) r T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Leaf i) bs)\n            (bdd_lookup (Branch l r) bs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> check_eq (Leaf i) r T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Leaf i) bs)\n            (bdd_lookup (Branch l r) bs))", "assume \"?R\""], ["proof (state)\nthis:\n  \\<not> check_eq (Leaf i) r T\n\ngoal (1 subgoal):\n 1. \\<not> check_eq (Leaf i) r T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Leaf i) bs)\n            (bdd_lookup (Branch l r) bs))", "then"], ["proof (chain)\npicking this:\n  \\<not> check_eq (Leaf i) r T", "obtain bs where O: \"bddh (length bs) r \\<and> bddh (length bs) (Leaf i) \\<and> (\\<exists>n<m. dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup r bs))\""], ["proof (prove)\nusing this:\n  \\<not> check_eq (Leaf i) r T\n\ngoal (1 subgoal):\n 1. (\\<And>bs.\n        bddh (length bs) r \\<and>\n        bddh (length bs) (Leaf i) \\<and>\n        (\\<exists>n<m.\n            dist_nodes M n v (bdd_lookup (Leaf i) bs)\n             (bdd_lookup r bs)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding IV2"], ["proof (prove)\nusing this:\n  \\<exists>bs.\n     bddh (length bs) r \\<and>\n     bddh (length bs) (Leaf i) \\<and>\n     (\\<exists>n<m.\n         dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup r bs))\n\ngoal (1 subgoal):\n 1. (\\<And>bs.\n        bddh (length bs) r \\<and>\n        bddh (length bs) (Leaf i) \\<and>\n        (\\<exists>n<m.\n            dist_nodes M n v (bdd_lookup (Leaf i) bs)\n             (bdd_lookup r bs)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  bddh (length bs) r \\<and>\n  bddh (length bs) (Leaf i) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup r bs))\n\ngoal (1 subgoal):\n 1. \\<not> check_eq (Leaf i) r T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Leaf i) bs)\n            (bdd_lookup (Branch l r) bs))", "from bddh_exists"], ["proof (chain)\npicking this:\n  \\<exists>n. bddh n ?B", "obtain k where B: \"bddh k l\""], ["proof (prove)\nusing this:\n  \\<exists>n. bddh n ?B\n\ngoal (1 subgoal):\n 1. (\\<And>k. bddh k l \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  bddh k l\n\ngoal (1 subgoal):\n 1. \\<not> check_eq (Leaf i) r T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Leaf i) bs)\n            (bdd_lookup (Branch l r) bs))", "with O"], ["proof (chain)\npicking this:\n  bddh (length bs) r \\<and>\n  bddh (length bs) (Leaf i) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup r bs))\n  bddh k l", "have \"bddh (length bs + k) l\" and \"bddh (length bs + k) r\" and \"bddh (length bs + k) (Leaf i)\""], ["proof (prove)\nusing this:\n  bddh (length bs) r \\<and>\n  bddh (length bs) (Leaf i) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup r bs))\n  bddh k l\n\ngoal (1 subgoal):\n 1. bddh (length bs + k) l &&&\n    bddh (length bs + k) r &&& bddh (length bs + k) (Leaf i)", "by (simp add: bddh_ge[of k \"length bs + k\"] bddh_ge[of \"length bs\" \"length bs + k\"])+"], ["proof (state)\nthis:\n  bddh (length bs + k) l\n  bddh (length bs + k) r\n  bddh (length bs + k) (Leaf i)\n\ngoal (1 subgoal):\n 1. \\<not> check_eq (Leaf i) r T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Leaf i) bs)\n            (bdd_lookup (Branch l r) bs))", "with O"], ["proof (chain)\npicking this:\n  bddh (length bs) r \\<and>\n  bddh (length bs) (Leaf i) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup r bs))\n  bddh (length bs + k) l\n  bddh (length bs + k) r\n  bddh (length bs + k) (Leaf i)", "have \"bddh (length (True # bs @ replicate k False)) (Branch l r) \\<and> bddh (length (True # bs @ replicate k False)) (Leaf i) \\<and> (\\<exists>n<m. dist_nodes M n v (bdd_lookup (Leaf i) (True # bs @ replicate k False)) (bdd_lookup (Branch l r) (True # bs @ replicate k False)))\""], ["proof (prove)\nusing this:\n  bddh (length bs) r \\<and>\n  bddh (length bs) (Leaf i) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup r bs))\n  bddh (length bs + k) l\n  bddh (length bs + k) r\n  bddh (length bs + k) (Leaf i)\n\ngoal (1 subgoal):\n 1. bddh (length (True # bs @ replicate k False)) (Branch l r) \\<and>\n    bddh (length (True # bs @ replicate k False)) (Leaf i) \\<and>\n    (\\<exists>n<m.\n        dist_nodes M n v\n         (bdd_lookup (Leaf i) (True # bs @ replicate k False))\n         (bdd_lookup (Branch l r) (True # bs @ replicate k False)))", "by (auto simp: bdd_lookup_append)"], ["proof (state)\nthis:\n  bddh (length (True # bs @ replicate k False)) (Branch l r) \\<and>\n  bddh (length (True # bs @ replicate k False)) (Leaf i) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup (Leaf i) (True # bs @ replicate k False))\n       (bdd_lookup (Branch l r) (True # bs @ replicate k False)))\n\ngoal (1 subgoal):\n 1. \\<not> check_eq (Leaf i) r T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Leaf i) bs)\n            (bdd_lookup (Branch l r) bs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  bddh (length (True # bs @ replicate k False)) (Branch l r) \\<and>\n  bddh (length (True # bs @ replicate k False)) (Leaf i) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup (Leaf i) (True # bs @ replicate k False))\n       (bdd_lookup (Branch l r) (True # bs @ replicate k False)))\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Leaf i) bs)\n            (bdd_lookup (Branch l r) bs))", "by (rule exI)"], ["proof (state)\nthis:\n  \\<exists>bs.\n     bddh (length bs) (Branch l r) \\<and>\n     bddh (length bs) (Leaf i) \\<and>\n     (\\<exists>n<m.\n         dist_nodes M n v (bdd_lookup (Leaf i) bs)\n          (bdd_lookup (Branch l r) bs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>bs.\n     bddh (length bs) (Branch l r) \\<and>\n     bddh (length bs) (Leaf i) \\<and>\n     (\\<exists>n<m.\n         dist_nodes M n v (bdd_lookup (Leaf i) bs)\n          (bdd_lookup (Branch l r) bs))\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Leaf i) bs)\n            (bdd_lookup (Branch l r) bs)) \\<Longrightarrow>\n    \\<not> check_eq (Leaf i) l T \\<or> \\<not> check_eq (Leaf i) r T", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Leaf i) bs)\n            (bdd_lookup (Branch l r) bs)) \\<Longrightarrow>\n    \\<not> check_eq (Leaf i) l T \\<or> \\<not> check_eq (Leaf i) r T", "assume \"?E\""], ["proof (state)\nthis:\n  \\<exists>bs.\n     bddh (length bs) (Branch l r) \\<and>\n     bddh (length bs) (Leaf i) \\<and>\n     (\\<exists>n<m.\n         dist_nodes M n v (bdd_lookup (Leaf i) bs)\n          (bdd_lookup (Branch l r) bs))\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Leaf i) bs)\n            (bdd_lookup (Branch l r) bs)) \\<Longrightarrow>\n    \\<not> check_eq (Leaf i) l T \\<or> \\<not> check_eq (Leaf i) r T", "then"], ["proof (chain)\npicking this:\n  \\<exists>bs.\n     bddh (length bs) (Branch l r) \\<and>\n     bddh (length bs) (Leaf i) \\<and>\n     (\\<exists>n<m.\n         dist_nodes M n v (bdd_lookup (Leaf i) bs)\n          (bdd_lookup (Branch l r) bs))", "obtain bs where O: \"bddh (length bs) (Branch l r) \\<and> bddh (length bs) (Leaf i) \\<and> (\\<exists>n<m. dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup (Branch l r) bs))\""], ["proof (prove)\nusing this:\n  \\<exists>bs.\n     bddh (length bs) (Branch l r) \\<and>\n     bddh (length bs) (Leaf i) \\<and>\n     (\\<exists>n<m.\n         dist_nodes M n v (bdd_lookup (Leaf i) bs)\n          (bdd_lookup (Branch l r) bs))\n\ngoal (1 subgoal):\n 1. (\\<And>bs.\n        bddh (length bs) (Branch l r) \\<and>\n        bddh (length bs) (Leaf i) \\<and>\n        (\\<exists>n<m.\n            dist_nodes M n v (bdd_lookup (Leaf i) bs)\n             (bdd_lookup (Branch l r) bs)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  bddh (length bs) (Branch l r) \\<and>\n  bddh (length bs) (Leaf i) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup (Leaf i) bs)\n       (bdd_lookup (Branch l r) bs))\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Leaf i) bs)\n            (bdd_lookup (Branch l r) bs)) \\<Longrightarrow>\n    \\<not> check_eq (Leaf i) l T \\<or> \\<not> check_eq (Leaf i) r T", "then"], ["proof (chain)\npicking this:\n  bddh (length bs) (Branch l r) \\<and>\n  bddh (length bs) (Leaf i) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup (Leaf i) bs)\n       (bdd_lookup (Branch l r) bs))", "obtain b br where B: \"bs = b # br\""], ["proof (prove)\nusing this:\n  bddh (length bs) (Branch l r) \\<and>\n  bddh (length bs) (Leaf i) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup (Leaf i) bs)\n       (bdd_lookup (Branch l r) bs))\n\ngoal (1 subgoal):\n 1. (\\<And>b br. bs = b # br \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases bs) auto"], ["proof (state)\nthis:\n  bs = b # br\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       bddh (length bs) (Branch l r) \\<and>\n       bddh (length bs) (Leaf i) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Leaf i) bs)\n            (bdd_lookup (Branch l r) bs)) \\<Longrightarrow>\n    \\<not> check_eq (Leaf i) l T \\<or> \\<not> check_eq (Leaf i) r T", "with O IV1 IV2"], ["proof (chain)\npicking this:\n  bddh (length bs) (Branch l r) \\<and>\n  bddh (length bs) (Leaf i) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup (Leaf i) bs)\n       (bdd_lookup (Branch l r) bs))\n  (\\<not> check_eq (Leaf i) l T) =\n  (\\<exists>bs.\n      bddh (length bs) l \\<and>\n      bddh (length bs) (Leaf i) \\<and>\n      (\\<exists>n<m.\n          dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup l bs)))\n  (\\<not> check_eq (Leaf i) r T) =\n  (\\<exists>bs.\n      bddh (length bs) r \\<and>\n      bddh (length bs) (Leaf i) \\<and>\n      (\\<exists>n<m.\n          dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup r bs)))\n  bs = b # br", "show \"?L \\<or> ?R\""], ["proof (prove)\nusing this:\n  bddh (length bs) (Branch l r) \\<and>\n  bddh (length bs) (Leaf i) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup (Leaf i) bs)\n       (bdd_lookup (Branch l r) bs))\n  (\\<not> check_eq (Leaf i) l T) =\n  (\\<exists>bs.\n      bddh (length bs) l \\<and>\n      bddh (length bs) (Leaf i) \\<and>\n      (\\<exists>n<m.\n          dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup l bs)))\n  (\\<not> check_eq (Leaf i) r T) =\n  (\\<exists>bs.\n      bddh (length bs) r \\<and>\n      bddh (length bs) (Leaf i) \\<and>\n      (\\<exists>n<m.\n          dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup r bs)))\n  bs = b # br\n\ngoal (1 subgoal):\n 1. \\<not> check_eq (Leaf i) l T \\<or> \\<not> check_eq (Leaf i) r T", "by (cases b) auto"], ["proof (state)\nthis:\n  \\<not> check_eq (Leaf i) l T \\<or> \\<not> check_eq (Leaf i) r T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<not> check_eq (Leaf i) l T \\<or> \\<not> check_eq (Leaf i) r T) =\n  (\\<exists>bs.\n      bddh (length bs) (Branch l r) \\<and>\n      bddh (length bs) (Leaf i) \\<and>\n      (\\<exists>n<m.\n          dist_nodes M n v (bdd_lookup (Leaf i) bs)\n           (bdd_lookup (Branch l r) bs)))\n\ngoal (2 subgoals):\n 1. \\<And>i l r T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) (Leaf i);\n                 bdd_all (dfa_is_node M) l\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq (Leaf i) l T) =\n                                  (\\<exists>bs.\nbddh (length bs) (Leaf i) \\<and>\nbddh (length bs) l \\<and>\n(\\<exists>n<m.\n    dist_nodes M n v (bdd_lookup (Leaf i) bs) (bdd_lookup l bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) (Leaf i);\n         bdd_all (dfa_is_node M) r\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq (Leaf i) r T) =\n                          (\\<exists>bs.\n                              bddh (length bs) (Leaf i) \\<and>\n                              bddh (length bs) r \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                   (bdd_lookup r bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Leaf i);\n        bdd_all (dfa_is_node M) (Branch l r)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Leaf i) (Branch l r) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Leaf i) \\<and>\n                             bddh (length bs) (Branch l r) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v (bdd_lookup (Leaf i) bs)\n                                  (bdd_lookup (Branch l r) bs)))\n 2. \\<And>l1 r1 l2 r2 T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) l1;\n                 bdd_all (dfa_is_node M) l2\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq l1 l2 T) =\n                                  (\\<exists>bs.\nbddh (length bs) l1 \\<and>\nbddh (length bs) l2 \\<and>\n(\\<exists>n<m. dist_nodes M n v (bdd_lookup l1 bs) (bdd_lookup l2 bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) r1;\n         bdd_all (dfa_is_node M) r2\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq r1 r2 T) =\n                          (\\<exists>bs.\n                              bddh (length bs) r1 \\<and>\n                              bddh (length bs) r2 \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup r1 bs)\n                                   (bdd_lookup r2 bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Branch l1 r1);\n        bdd_all (dfa_is_node M) (Branch l2 r2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Branch l1 r1) (Branch l2 r2) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Branch l1 r1) \\<and>\n                             bddh (length bs) (Branch l2 r2) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v\n                                  (bdd_lookup (Branch l1 r1) bs)\n                                  (bdd_lookup (Branch l2 r2) bs)))", "finally"], ["proof (chain)\npicking this:\n  (\\<not> check_eq (Leaf i) (Branch l r) T) =\n  (\\<exists>bs.\n      bddh (length bs) (Branch l r) \\<and>\n      bddh (length bs) (Leaf i) \\<and>\n      (\\<exists>n<m.\n          dist_nodes M n v (bdd_lookup (Leaf i) bs)\n           (bdd_lookup (Branch l r) bs)))", "show ?case"], ["proof (prove)\nusing this:\n  (\\<not> check_eq (Leaf i) (Branch l r) T) =\n  (\\<exists>bs.\n      bddh (length bs) (Branch l r) \\<and>\n      bddh (length bs) (Leaf i) \\<and>\n      (\\<exists>n<m.\n          dist_nodes M n v (bdd_lookup (Leaf i) bs)\n           (bdd_lookup (Branch l r) bs)))\n\ngoal (1 subgoal):\n 1. (\\<not> check_eq (Leaf i) (Branch l r) T) =\n    (\\<exists>bs.\n        bddh (length bs) (Leaf i) \\<and>\n        bddh (length bs) (Branch l r) \\<and>\n        (\\<exists>n<m.\n            dist_nodes M n v (bdd_lookup (Leaf i) bs)\n             (bdd_lookup (Branch l r) bs)))", "by simp"], ["proof (state)\nthis:\n  (\\<not> check_eq (Leaf i) (Branch l r) T) =\n  (\\<exists>bs.\n      bddh (length bs) (Leaf i) \\<and>\n      bddh (length bs) (Branch l r) \\<and>\n      (\\<exists>n<m.\n          dist_nodes M n v (bdd_lookup (Leaf i) bs)\n           (bdd_lookup (Branch l r) bs)))\n\ngoal (1 subgoal):\n 1. \\<And>l1 r1 l2 r2 T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) l1;\n                 bdd_all (dfa_is_node M) l2\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq l1 l2 T) =\n                                  (\\<exists>bs.\nbddh (length bs) l1 \\<and>\nbddh (length bs) l2 \\<and>\n(\\<exists>n<m. dist_nodes M n v (bdd_lookup l1 bs) (bdd_lookup l2 bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) r1;\n         bdd_all (dfa_is_node M) r2\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq r1 r2 T) =\n                          (\\<exists>bs.\n                              bddh (length bs) r1 \\<and>\n                              bddh (length bs) r2 \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup r1 bs)\n                                   (bdd_lookup r2 bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Branch l1 r1);\n        bdd_all (dfa_is_node M) (Branch l2 r2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Branch l1 r1) (Branch l2 r2) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Branch l1 r1) \\<and>\n                             bddh (length bs) (Branch l2 r2) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v\n                                  (bdd_lookup (Branch l1 r1) bs)\n                                  (bdd_lookup (Branch l2 r2) bs)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l1 r1 l2 r2 T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) l1;\n                 bdd_all (dfa_is_node M) l2\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq l1 l2 T) =\n                                  (\\<exists>bs.\nbddh (length bs) l1 \\<and>\nbddh (length bs) l2 \\<and>\n(\\<exists>n<m. dist_nodes M n v (bdd_lookup l1 bs) (bdd_lookup l2 bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) r1;\n         bdd_all (dfa_is_node M) r2\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq r1 r2 T) =\n                          (\\<exists>bs.\n                              bddh (length bs) r1 \\<and>\n                              bddh (length bs) r2 \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup r1 bs)\n                                   (bdd_lookup r2 bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Branch l1 r1);\n        bdd_all (dfa_is_node M) (Branch l2 r2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Branch l1 r1) (Branch l2 r2) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Branch l1 r1) \\<and>\n                             bddh (length bs) (Branch l2 r2) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v\n                                  (bdd_lookup (Branch l1 r1) bs)\n                                  (bdd_lookup (Branch l2 r2) bs)))", "case (4 l1 r1 l2 r2 T)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>p q.\n              dfa_is_node M q \\<and> p < q \\<longrightarrow>\n              tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n   0 < m; bdd_all (dfa_is_node M) l1; bdd_all (dfa_is_node M) l2\\<rbrakk>\n  \\<Longrightarrow> (\\<not> check_eq l1 l2 T) =\n                    (\\<exists>bs.\n                        bddh (length bs) l1 \\<and>\n                        bddh (length bs) l2 \\<and>\n                        (\\<exists>n<m.\n                            dist_nodes M n v (bdd_lookup l1 bs)\n                             (bdd_lookup l2 bs)))\n  \\<lbrakk>\\<forall>p q.\n              dfa_is_node M q \\<and> p < q \\<longrightarrow>\n              tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n   0 < m; bdd_all (dfa_is_node M) r1; bdd_all (dfa_is_node M) r2\\<rbrakk>\n  \\<Longrightarrow> (\\<not> check_eq r1 r2 T) =\n                    (\\<exists>bs.\n                        bddh (length bs) r1 \\<and>\n                        bddh (length bs) r2 \\<and>\n                        (\\<exists>n<m.\n                            dist_nodes M n v (bdd_lookup r1 bs)\n                             (bdd_lookup r2 bs)))\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n  bdd_all (dfa_is_node M) (Branch l1 r1)\n  bdd_all (dfa_is_node M) (Branch l2 r2)\n\ngoal (1 subgoal):\n 1. \\<And>l1 r1 l2 r2 T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) l1;\n                 bdd_all (dfa_is_node M) l2\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq l1 l2 T) =\n                                  (\\<exists>bs.\nbddh (length bs) l1 \\<and>\nbddh (length bs) l2 \\<and>\n(\\<exists>n<m. dist_nodes M n v (bdd_lookup l1 bs) (bdd_lookup l2 bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) r1;\n         bdd_all (dfa_is_node M) r2\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq r1 r2 T) =\n                          (\\<exists>bs.\n                              bddh (length bs) r1 \\<and>\n                              bddh (length bs) r2 \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup r1 bs)\n                                   (bdd_lookup r2 bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Branch l1 r1);\n        bdd_all (dfa_is_node M) (Branch l2 r2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Branch l1 r1) (Branch l2 r2) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Branch l1 r1) \\<and>\n                             bddh (length bs) (Branch l2 r2) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v\n                                  (bdd_lookup (Branch l1 r1) bs)\n                                  (bdd_lookup (Branch l2 r2) bs)))", "hence IV1: \"(\\<not> check_eq l1 l2 T) = (\\<exists>bs. bddh (length bs) l1 \\<and> bddh (length bs) l2 \\<and> (\\<exists>n<m. dist_nodes M n v (bdd_lookup l1 bs) (bdd_lookup l2 bs)))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>p q.\n              dfa_is_node M q \\<and> p < q \\<longrightarrow>\n              tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n   0 < m; bdd_all (dfa_is_node M) l1; bdd_all (dfa_is_node M) l2\\<rbrakk>\n  \\<Longrightarrow> (\\<not> check_eq l1 l2 T) =\n                    (\\<exists>bs.\n                        bddh (length bs) l1 \\<and>\n                        bddh (length bs) l2 \\<and>\n                        (\\<exists>n<m.\n                            dist_nodes M n v (bdd_lookup l1 bs)\n                             (bdd_lookup l2 bs)))\n  \\<lbrakk>\\<forall>p q.\n              dfa_is_node M q \\<and> p < q \\<longrightarrow>\n              tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n   0 < m; bdd_all (dfa_is_node M) r1; bdd_all (dfa_is_node M) r2\\<rbrakk>\n  \\<Longrightarrow> (\\<not> check_eq r1 r2 T) =\n                    (\\<exists>bs.\n                        bddh (length bs) r1 \\<and>\n                        bddh (length bs) r2 \\<and>\n                        (\\<exists>n<m.\n                            dist_nodes M n v (bdd_lookup r1 bs)\n                             (bdd_lookup r2 bs)))\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n  bdd_all (dfa_is_node M) (Branch l1 r1)\n  bdd_all (dfa_is_node M) (Branch l2 r2)\n\ngoal (1 subgoal):\n 1. (\\<not> check_eq l1 l2 T) =\n    (\\<exists>bs.\n        bddh (length bs) l1 \\<and>\n        bddh (length bs) l2 \\<and>\n        (\\<exists>n<m.\n            dist_nodes M n v (bdd_lookup l1 bs) (bdd_lookup l2 bs)))", "by simp"], ["proof (state)\nthis:\n  (\\<not> check_eq l1 l2 T) =\n  (\\<exists>bs.\n      bddh (length bs) l1 \\<and>\n      bddh (length bs) l2 \\<and>\n      (\\<exists>n<m.\n          dist_nodes M n v (bdd_lookup l1 bs) (bdd_lookup l2 bs)))\n\ngoal (1 subgoal):\n 1. \\<And>l1 r1 l2 r2 T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) l1;\n                 bdd_all (dfa_is_node M) l2\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq l1 l2 T) =\n                                  (\\<exists>bs.\nbddh (length bs) l1 \\<and>\nbddh (length bs) l2 \\<and>\n(\\<exists>n<m. dist_nodes M n v (bdd_lookup l1 bs) (bdd_lookup l2 bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) r1;\n         bdd_all (dfa_is_node M) r2\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq r1 r2 T) =\n                          (\\<exists>bs.\n                              bddh (length bs) r1 \\<and>\n                              bddh (length bs) r2 \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup r1 bs)\n                                   (bdd_lookup r2 bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Branch l1 r1);\n        bdd_all (dfa_is_node M) (Branch l2 r2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Branch l1 r1) (Branch l2 r2) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Branch l1 r1) \\<and>\n                             bddh (length bs) (Branch l2 r2) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v\n                                  (bdd_lookup (Branch l1 r1) bs)\n                                  (bdd_lookup (Branch l2 r2) bs)))", "from 4"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>p q.\n              dfa_is_node M q \\<and> p < q \\<longrightarrow>\n              tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n   0 < m; bdd_all (dfa_is_node M) l1; bdd_all (dfa_is_node M) l2\\<rbrakk>\n  \\<Longrightarrow> (\\<not> check_eq l1 l2 T) =\n                    (\\<exists>bs.\n                        bddh (length bs) l1 \\<and>\n                        bddh (length bs) l2 \\<and>\n                        (\\<exists>n<m.\n                            dist_nodes M n v (bdd_lookup l1 bs)\n                             (bdd_lookup l2 bs)))\n  \\<lbrakk>\\<forall>p q.\n              dfa_is_node M q \\<and> p < q \\<longrightarrow>\n              tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n   0 < m; bdd_all (dfa_is_node M) r1; bdd_all (dfa_is_node M) r2\\<rbrakk>\n  \\<Longrightarrow> (\\<not> check_eq r1 r2 T) =\n                    (\\<exists>bs.\n                        bddh (length bs) r1 \\<and>\n                        bddh (length bs) r2 \\<and>\n                        (\\<exists>n<m.\n                            dist_nodes M n v (bdd_lookup r1 bs)\n                             (bdd_lookup r2 bs)))\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n  bdd_all (dfa_is_node M) (Branch l1 r1)\n  bdd_all (dfa_is_node M) (Branch l2 r2)", "have IV2: \"(\\<not> check_eq r1 r2 T) = (\\<exists>bs. bddh (length bs) r1 \\<and> bddh (length bs) r2 \\<and> (\\<exists>n<m. dist_nodes M n v (bdd_lookup r1 bs) (bdd_lookup r2 bs)))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>p q.\n              dfa_is_node M q \\<and> p < q \\<longrightarrow>\n              tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n   0 < m; bdd_all (dfa_is_node M) l1; bdd_all (dfa_is_node M) l2\\<rbrakk>\n  \\<Longrightarrow> (\\<not> check_eq l1 l2 T) =\n                    (\\<exists>bs.\n                        bddh (length bs) l1 \\<and>\n                        bddh (length bs) l2 \\<and>\n                        (\\<exists>n<m.\n                            dist_nodes M n v (bdd_lookup l1 bs)\n                             (bdd_lookup l2 bs)))\n  \\<lbrakk>\\<forall>p q.\n              dfa_is_node M q \\<and> p < q \\<longrightarrow>\n              tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n   0 < m; bdd_all (dfa_is_node M) r1; bdd_all (dfa_is_node M) r2\\<rbrakk>\n  \\<Longrightarrow> (\\<not> check_eq r1 r2 T) =\n                    (\\<exists>bs.\n                        bddh (length bs) r1 \\<and>\n                        bddh (length bs) r2 \\<and>\n                        (\\<exists>n<m.\n                            dist_nodes M n v (bdd_lookup r1 bs)\n                             (bdd_lookup r2 bs)))\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n  bdd_all (dfa_is_node M) (Branch l1 r1)\n  bdd_all (dfa_is_node M) (Branch l2 r2)\n\ngoal (1 subgoal):\n 1. (\\<not> check_eq r1 r2 T) =\n    (\\<exists>bs.\n        bddh (length bs) r1 \\<and>\n        bddh (length bs) r2 \\<and>\n        (\\<exists>n<m.\n            dist_nodes M n v (bdd_lookup r1 bs) (bdd_lookup r2 bs)))", "by simp"], ["proof (state)\nthis:\n  (\\<not> check_eq r1 r2 T) =\n  (\\<exists>bs.\n      bddh (length bs) r1 \\<and>\n      bddh (length bs) r2 \\<and>\n      (\\<exists>n<m.\n          dist_nodes M n v (bdd_lookup r1 bs) (bdd_lookup r2 bs)))\n\ngoal (1 subgoal):\n 1. \\<And>l1 r1 l2 r2 T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) l1;\n                 bdd_all (dfa_is_node M) l2\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq l1 l2 T) =\n                                  (\\<exists>bs.\nbddh (length bs) l1 \\<and>\nbddh (length bs) l2 \\<and>\n(\\<exists>n<m. dist_nodes M n v (bdd_lookup l1 bs) (bdd_lookup l2 bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) r1;\n         bdd_all (dfa_is_node M) r2\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq r1 r2 T) =\n                          (\\<exists>bs.\n                              bddh (length bs) r1 \\<and>\n                              bddh (length bs) r2 \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup r1 bs)\n                                   (bdd_lookup r2 bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Branch l1 r1);\n        bdd_all (dfa_is_node M) (Branch l2 r2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Branch l1 r1) (Branch l2 r2) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Branch l1 r1) \\<and>\n                             bddh (length bs) (Branch l2 r2) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v\n                                  (bdd_lookup (Branch l1 r1) bs)\n                                  (bdd_lookup (Branch l2 r2) bs)))", "have \"(\\<not> check_eq (Branch l1 r1) (Branch l2 r2) T) = (\\<not> check_eq l1 l2 T \\<or> \\<not> check_eq r1 r2 T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> check_eq (Branch l1 r1) (Branch l2 r2) T) =\n    (\\<not> check_eq l1 l2 T \\<or> \\<not> check_eq r1 r2 T)", "by simp"], ["proof (state)\nthis:\n  (\\<not> check_eq (Branch l1 r1) (Branch l2 r2) T) =\n  (\\<not> check_eq l1 l2 T \\<or> \\<not> check_eq r1 r2 T)\n\ngoal (1 subgoal):\n 1. \\<And>l1 r1 l2 r2 T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) l1;\n                 bdd_all (dfa_is_node M) l2\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq l1 l2 T) =\n                                  (\\<exists>bs.\nbddh (length bs) l1 \\<and>\nbddh (length bs) l2 \\<and>\n(\\<exists>n<m. dist_nodes M n v (bdd_lookup l1 bs) (bdd_lookup l2 bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) r1;\n         bdd_all (dfa_is_node M) r2\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq r1 r2 T) =\n                          (\\<exists>bs.\n                              bddh (length bs) r1 \\<and>\n                              bddh (length bs) r2 \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup r1 bs)\n                                   (bdd_lookup r2 bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Branch l1 r1);\n        bdd_all (dfa_is_node M) (Branch l2 r2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Branch l1 r1) (Branch l2 r2) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Branch l1 r1) \\<and>\n                             bddh (length bs) (Branch l2 r2) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v\n                                  (bdd_lookup (Branch l1 r1) bs)\n                                  (bdd_lookup (Branch l2 r2) bs)))", "also"], ["proof (state)\nthis:\n  (\\<not> check_eq (Branch l1 r1) (Branch l2 r2) T) =\n  (\\<not> check_eq l1 l2 T \\<or> \\<not> check_eq r1 r2 T)\n\ngoal (1 subgoal):\n 1. \\<And>l1 r1 l2 r2 T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) l1;\n                 bdd_all (dfa_is_node M) l2\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq l1 l2 T) =\n                                  (\\<exists>bs.\nbddh (length bs) l1 \\<and>\nbddh (length bs) l2 \\<and>\n(\\<exists>n<m. dist_nodes M n v (bdd_lookup l1 bs) (bdd_lookup l2 bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) r1;\n         bdd_all (dfa_is_node M) r2\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq r1 r2 T) =\n                          (\\<exists>bs.\n                              bddh (length bs) r1 \\<and>\n                              bddh (length bs) r2 \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup r1 bs)\n                                   (bdd_lookup r2 bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Branch l1 r1);\n        bdd_all (dfa_is_node M) (Branch l2 r2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Branch l1 r1) (Branch l2 r2) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Branch l1 r1) \\<and>\n                             bddh (length bs) (Branch l2 r2) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v\n                                  (bdd_lookup (Branch l1 r1) bs)\n                                  (bdd_lookup (Branch l2 r2) bs)))", "have \"\\<dots> = (\\<exists>bs. bddh (length bs) (Branch l1 r1) \\<and> bddh (length bs) (Branch l2 r2) \\<and> (\\<exists>n<m. dist_nodes M n v (bdd_lookup (Branch l1 r1) bs) (bdd_lookup (Branch l2 r2) bs)))\"\n    (is \"(?L \\<or> ?R) = (\\<exists>bs. ?E bs)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> check_eq l1 l2 T \\<or> \\<not> check_eq r1 r2 T) =\n    (\\<exists>bs.\n        bddh (length bs) (Branch l1 r1) \\<and>\n        bddh (length bs) (Branch l2 r2) \\<and>\n        (\\<exists>n<m.\n            dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n             (bdd_lookup (Branch l2 r2) bs)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> check_eq l1 l2 T \\<or> \\<not> check_eq r1 r2 T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l1 r1) \\<and>\n       bddh (length bs) (Branch l2 r2) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n            (bdd_lookup (Branch l2 r2) bs))\n 2. \\<exists>bs.\n       bddh (length bs) (Branch l1 r1) \\<and>\n       bddh (length bs) (Branch l2 r2) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n            (bdd_lookup (Branch l2 r2) bs)) \\<Longrightarrow>\n    \\<not> check_eq l1 l2 T \\<or> \\<not> check_eq r1 r2 T", "assume \"?L \\<or> ?R\""], ["proof (state)\nthis:\n  \\<not> check_eq l1 l2 T \\<or> \\<not> check_eq r1 r2 T\n\ngoal (2 subgoals):\n 1. \\<not> check_eq l1 l2 T \\<or> \\<not> check_eq r1 r2 T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l1 r1) \\<and>\n       bddh (length bs) (Branch l2 r2) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n            (bdd_lookup (Branch l2 r2) bs))\n 2. \\<exists>bs.\n       bddh (length bs) (Branch l1 r1) \\<and>\n       bddh (length bs) (Branch l2 r2) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n            (bdd_lookup (Branch l2 r2) bs)) \\<Longrightarrow>\n    \\<not> check_eq l1 l2 T \\<or> \\<not> check_eq r1 r2 T", "thus \"\\<exists>bs. ?E bs\""], ["proof (prove)\nusing this:\n  \\<not> check_eq l1 l2 T \\<or> \\<not> check_eq r1 r2 T\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       bddh (length bs) (Branch l1 r1) \\<and>\n       bddh (length bs) (Branch l2 r2) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n            (bdd_lookup (Branch l2 r2) bs))", "proof (elim disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> check_eq l1 l2 T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l1 r1) \\<and>\n       bddh (length bs) (Branch l2 r2) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n            (bdd_lookup (Branch l2 r2) bs))\n 2. \\<not> check_eq r1 r2 T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l1 r1) \\<and>\n       bddh (length bs) (Branch l2 r2) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n            (bdd_lookup (Branch l2 r2) bs))", "assume \"?L\""], ["proof (state)\nthis:\n  \\<not> check_eq l1 l2 T\n\ngoal (2 subgoals):\n 1. \\<not> check_eq l1 l2 T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l1 r1) \\<and>\n       bddh (length bs) (Branch l2 r2) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n            (bdd_lookup (Branch l2 r2) bs))\n 2. \\<not> check_eq r1 r2 T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l1 r1) \\<and>\n       bddh (length bs) (Branch l2 r2) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n            (bdd_lookup (Branch l2 r2) bs))", "then"], ["proof (chain)\npicking this:\n  \\<not> check_eq l1 l2 T", "obtain bs where O: \"bddh (length bs) l1 \\<and> bddh (length bs) l2 \\<and> (\\<exists>n<m. dist_nodes M n v (bdd_lookup l1 bs) (bdd_lookup l2 bs))\""], ["proof (prove)\nusing this:\n  \\<not> check_eq l1 l2 T\n\ngoal (1 subgoal):\n 1. (\\<And>bs.\n        bddh (length bs) l1 \\<and>\n        bddh (length bs) l2 \\<and>\n        (\\<exists>n<m.\n            dist_nodes M n v (bdd_lookup l1 bs)\n             (bdd_lookup l2 bs)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding IV1"], ["proof (prove)\nusing this:\n  \\<exists>bs.\n     bddh (length bs) l1 \\<and>\n     bddh (length bs) l2 \\<and>\n     (\\<exists>n<m. dist_nodes M n v (bdd_lookup l1 bs) (bdd_lookup l2 bs))\n\ngoal (1 subgoal):\n 1. (\\<And>bs.\n        bddh (length bs) l1 \\<and>\n        bddh (length bs) l2 \\<and>\n        (\\<exists>n<m.\n            dist_nodes M n v (bdd_lookup l1 bs)\n             (bdd_lookup l2 bs)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  bddh (length bs) l1 \\<and>\n  bddh (length bs) l2 \\<and>\n  (\\<exists>n<m. dist_nodes M n v (bdd_lookup l1 bs) (bdd_lookup l2 bs))\n\ngoal (2 subgoals):\n 1. \\<not> check_eq l1 l2 T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l1 r1) \\<and>\n       bddh (length bs) (Branch l2 r2) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n            (bdd_lookup (Branch l2 r2) bs))\n 2. \\<not> check_eq r1 r2 T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l1 r1) \\<and>\n       bddh (length bs) (Branch l2 r2) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n            (bdd_lookup (Branch l2 r2) bs))", "from bddh_exists"], ["proof (chain)\npicking this:\n  \\<exists>n. bddh n ?B", "obtain k1 k2 where K1: \"bddh k1 r1\" and K2: \"bddh k2 r2\""], ["proof (prove)\nusing this:\n  \\<exists>n. bddh n ?B\n\ngoal (1 subgoal):\n 1. (\\<And>k1 k2.\n        \\<lbrakk>bddh k1 r1; bddh k2 r2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  bddh k1 r1\n  bddh k2 r2\n\ngoal (2 subgoals):\n 1. \\<not> check_eq l1 l2 T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l1 r1) \\<and>\n       bddh (length bs) (Branch l2 r2) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n            (bdd_lookup (Branch l2 r2) bs))\n 2. \\<not> check_eq r1 r2 T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l1 r1) \\<and>\n       bddh (length bs) (Branch l2 r2) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n            (bdd_lookup (Branch l2 r2) bs))", "with O"], ["proof (chain)\npicking this:\n  bddh (length bs) l1 \\<and>\n  bddh (length bs) l2 \\<and>\n  (\\<exists>n<m. dist_nodes M n v (bdd_lookup l1 bs) (bdd_lookup l2 bs))\n  bddh k1 r1\n  bddh k2 r2", "have \"bddh (length bs + max k1 k2) l1\" and \"bddh (length bs + max k1 k2) l2\" and \"bddh (length bs + max k1 k2) r1\" and \"bddh (length bs + max k1 k2) r2\""], ["proof (prove)\nusing this:\n  bddh (length bs) l1 \\<and>\n  bddh (length bs) l2 \\<and>\n  (\\<exists>n<m. dist_nodes M n v (bdd_lookup l1 bs) (bdd_lookup l2 bs))\n  bddh k1 r1\n  bddh k2 r2\n\ngoal (1 subgoal):\n 1. (bddh (length bs + max k1 k2) l1 &&&\n     bddh (length bs + max k1 k2) l2) &&&\n    bddh (length bs + max k1 k2) r1 &&& bddh (length bs + max k1 k2) r2", "by (simp add: bddh_ge[of \"length bs\" \"length bs + max k1 k2\"] bddh_ge[of k1 \"length bs + max k1 k2\"] bddh_ge[of k2 \"length bs + max k1 k2\"])+"], ["proof (state)\nthis:\n  bddh (length bs + max k1 k2) l1\n  bddh (length bs + max k1 k2) l2\n  bddh (length bs + max k1 k2) r1\n  bddh (length bs + max k1 k2) r2\n\ngoal (2 subgoals):\n 1. \\<not> check_eq l1 l2 T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l1 r1) \\<and>\n       bddh (length bs) (Branch l2 r2) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n            (bdd_lookup (Branch l2 r2) bs))\n 2. \\<not> check_eq r1 r2 T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l1 r1) \\<and>\n       bddh (length bs) (Branch l2 r2) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n            (bdd_lookup (Branch l2 r2) bs))", "with O"], ["proof (chain)\npicking this:\n  bddh (length bs) l1 \\<and>\n  bddh (length bs) l2 \\<and>\n  (\\<exists>n<m. dist_nodes M n v (bdd_lookup l1 bs) (bdd_lookup l2 bs))\n  bddh (length bs + max k1 k2) l1\n  bddh (length bs + max k1 k2) l2\n  bddh (length bs + max k1 k2) r1\n  bddh (length bs + max k1 k2) r2", "have \"bddh (length (False # bs @ replicate (max k1 k2) False)) (Branch l1 r1) \\<and> bddh (length (False # bs @ replicate (max k1 k2) False)) (Branch l2 r2) \\<and>\n        (\\<exists>n<m. dist_nodes M n v (bdd_lookup (Branch l1 r1) (False # bs @ replicate (max k1 k2) False)) (bdd_lookup (Branch l2 r2) (False # bs @ replicate (max k1 k2) False)))\""], ["proof (prove)\nusing this:\n  bddh (length bs) l1 \\<and>\n  bddh (length bs) l2 \\<and>\n  (\\<exists>n<m. dist_nodes M n v (bdd_lookup l1 bs) (bdd_lookup l2 bs))\n  bddh (length bs + max k1 k2) l1\n  bddh (length bs + max k1 k2) l2\n  bddh (length bs + max k1 k2) r1\n  bddh (length bs + max k1 k2) r2\n\ngoal (1 subgoal):\n 1. bddh (length (False # bs @ replicate (max k1 k2) False))\n     (Branch l1 r1) \\<and>\n    bddh (length (False # bs @ replicate (max k1 k2) False))\n     (Branch l2 r2) \\<and>\n    (\\<exists>n<m.\n        dist_nodes M n v\n         (bdd_lookup (Branch l1 r1)\n           (False # bs @ replicate (max k1 k2) False))\n         (bdd_lookup (Branch l2 r2)\n           (False # bs @ replicate (max k1 k2) False)))", "by (auto simp: bdd_lookup_append)"], ["proof (state)\nthis:\n  bddh (length (False # bs @ replicate (max k1 k2) False))\n   (Branch l1 r1) \\<and>\n  bddh (length (False # bs @ replicate (max k1 k2) False))\n   (Branch l2 r2) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v\n       (bdd_lookup (Branch l1 r1)\n         (False # bs @ replicate (max k1 k2) False))\n       (bdd_lookup (Branch l2 r2)\n         (False # bs @ replicate (max k1 k2) False)))\n\ngoal (2 subgoals):\n 1. \\<not> check_eq l1 l2 T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l1 r1) \\<and>\n       bddh (length bs) (Branch l2 r2) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n            (bdd_lookup (Branch l2 r2) bs))\n 2. \\<not> check_eq r1 r2 T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l1 r1) \\<and>\n       bddh (length bs) (Branch l2 r2) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n            (bdd_lookup (Branch l2 r2) bs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  bddh (length (False # bs @ replicate (max k1 k2) False))\n   (Branch l1 r1) \\<and>\n  bddh (length (False # bs @ replicate (max k1 k2) False))\n   (Branch l2 r2) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v\n       (bdd_lookup (Branch l1 r1)\n         (False # bs @ replicate (max k1 k2) False))\n       (bdd_lookup (Branch l2 r2)\n         (False # bs @ replicate (max k1 k2) False)))\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       bddh (length bs) (Branch l1 r1) \\<and>\n       bddh (length bs) (Branch l2 r2) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n            (bdd_lookup (Branch l2 r2) bs))", "by (rule exI)"], ["proof (state)\nthis:\n  \\<exists>bs.\n     bddh (length bs) (Branch l1 r1) \\<and>\n     bddh (length bs) (Branch l2 r2) \\<and>\n     (\\<exists>n<m.\n         dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n          (bdd_lookup (Branch l2 r2) bs))\n\ngoal (1 subgoal):\n 1. \\<not> check_eq r1 r2 T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l1 r1) \\<and>\n       bddh (length bs) (Branch l2 r2) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n            (bdd_lookup (Branch l2 r2) bs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> check_eq r1 r2 T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l1 r1) \\<and>\n       bddh (length bs) (Branch l2 r2) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n            (bdd_lookup (Branch l2 r2) bs))", "assume \"?R\""], ["proof (state)\nthis:\n  \\<not> check_eq r1 r2 T\n\ngoal (1 subgoal):\n 1. \\<not> check_eq r1 r2 T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l1 r1) \\<and>\n       bddh (length bs) (Branch l2 r2) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n            (bdd_lookup (Branch l2 r2) bs))", "then"], ["proof (chain)\npicking this:\n  \\<not> check_eq r1 r2 T", "obtain bs where O: \"bddh (length bs) r1 \\<and> bddh (length bs) r2 \\<and> (\\<exists>n<m. dist_nodes M n v (bdd_lookup r1 bs) (bdd_lookup r2 bs))\""], ["proof (prove)\nusing this:\n  \\<not> check_eq r1 r2 T\n\ngoal (1 subgoal):\n 1. (\\<And>bs.\n        bddh (length bs) r1 \\<and>\n        bddh (length bs) r2 \\<and>\n        (\\<exists>n<m.\n            dist_nodes M n v (bdd_lookup r1 bs)\n             (bdd_lookup r2 bs)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding IV2"], ["proof (prove)\nusing this:\n  \\<exists>bs.\n     bddh (length bs) r1 \\<and>\n     bddh (length bs) r2 \\<and>\n     (\\<exists>n<m. dist_nodes M n v (bdd_lookup r1 bs) (bdd_lookup r2 bs))\n\ngoal (1 subgoal):\n 1. (\\<And>bs.\n        bddh (length bs) r1 \\<and>\n        bddh (length bs) r2 \\<and>\n        (\\<exists>n<m.\n            dist_nodes M n v (bdd_lookup r1 bs)\n             (bdd_lookup r2 bs)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  bddh (length bs) r1 \\<and>\n  bddh (length bs) r2 \\<and>\n  (\\<exists>n<m. dist_nodes M n v (bdd_lookup r1 bs) (bdd_lookup r2 bs))\n\ngoal (1 subgoal):\n 1. \\<not> check_eq r1 r2 T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l1 r1) \\<and>\n       bddh (length bs) (Branch l2 r2) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n            (bdd_lookup (Branch l2 r2) bs))", "from bddh_exists"], ["proof (chain)\npicking this:\n  \\<exists>n. bddh n ?B", "obtain k1 k2 where K1: \"bddh k1 l1\" and K2: \"bddh k2 l2\""], ["proof (prove)\nusing this:\n  \\<exists>n. bddh n ?B\n\ngoal (1 subgoal):\n 1. (\\<And>k1 k2.\n        \\<lbrakk>bddh k1 l1; bddh k2 l2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  bddh k1 l1\n  bddh k2 l2\n\ngoal (1 subgoal):\n 1. \\<not> check_eq r1 r2 T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l1 r1) \\<and>\n       bddh (length bs) (Branch l2 r2) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n            (bdd_lookup (Branch l2 r2) bs))", "with O"], ["proof (chain)\npicking this:\n  bddh (length bs) r1 \\<and>\n  bddh (length bs) r2 \\<and>\n  (\\<exists>n<m. dist_nodes M n v (bdd_lookup r1 bs) (bdd_lookup r2 bs))\n  bddh k1 l1\n  bddh k2 l2", "have \"bddh (length bs + max k1 k2) l1\" and \"bddh (length bs + max k1 k2) l2\" and \"bddh (length bs + max k1 k2) r1\" and \"bddh (length bs + max k1 k2) r2\""], ["proof (prove)\nusing this:\n  bddh (length bs) r1 \\<and>\n  bddh (length bs) r2 \\<and>\n  (\\<exists>n<m. dist_nodes M n v (bdd_lookup r1 bs) (bdd_lookup r2 bs))\n  bddh k1 l1\n  bddh k2 l2\n\ngoal (1 subgoal):\n 1. (bddh (length bs + max k1 k2) l1 &&&\n     bddh (length bs + max k1 k2) l2) &&&\n    bddh (length bs + max k1 k2) r1 &&& bddh (length bs + max k1 k2) r2", "by (simp add: bddh_ge[of \"length bs\" \"length bs + max k1 k2\"] bddh_ge[of k1 \"length bs + max k1 k2\"] bddh_ge[of k2 \"length bs + max k1 k2\"])+"], ["proof (state)\nthis:\n  bddh (length bs + max k1 k2) l1\n  bddh (length bs + max k1 k2) l2\n  bddh (length bs + max k1 k2) r1\n  bddh (length bs + max k1 k2) r2\n\ngoal (1 subgoal):\n 1. \\<not> check_eq r1 r2 T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l1 r1) \\<and>\n       bddh (length bs) (Branch l2 r2) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n            (bdd_lookup (Branch l2 r2) bs))", "with O"], ["proof (chain)\npicking this:\n  bddh (length bs) r1 \\<and>\n  bddh (length bs) r2 \\<and>\n  (\\<exists>n<m. dist_nodes M n v (bdd_lookup r1 bs) (bdd_lookup r2 bs))\n  bddh (length bs + max k1 k2) l1\n  bddh (length bs + max k1 k2) l2\n  bddh (length bs + max k1 k2) r1\n  bddh (length bs + max k1 k2) r2", "have \"bddh (length (True # bs @ replicate (max k1 k2) False)) (Branch l1 r1) \\<and> bddh (length (True # bs @ replicate (max k1 k2) False)) (Branch l2 r2) \\<and>\n        (\\<exists>n<m. dist_nodes M n v (bdd_lookup (Branch l1 r1) (True # bs @ replicate (max k1 k2) False)) (bdd_lookup (Branch l2 r2) (True # bs @ replicate (max k1 k2) False)))\""], ["proof (prove)\nusing this:\n  bddh (length bs) r1 \\<and>\n  bddh (length bs) r2 \\<and>\n  (\\<exists>n<m. dist_nodes M n v (bdd_lookup r1 bs) (bdd_lookup r2 bs))\n  bddh (length bs + max k1 k2) l1\n  bddh (length bs + max k1 k2) l2\n  bddh (length bs + max k1 k2) r1\n  bddh (length bs + max k1 k2) r2\n\ngoal (1 subgoal):\n 1. bddh (length (True # bs @ replicate (max k1 k2) False))\n     (Branch l1 r1) \\<and>\n    bddh (length (True # bs @ replicate (max k1 k2) False))\n     (Branch l2 r2) \\<and>\n    (\\<exists>n<m.\n        dist_nodes M n v\n         (bdd_lookup (Branch l1 r1)\n           (True # bs @ replicate (max k1 k2) False))\n         (bdd_lookup (Branch l2 r2)\n           (True # bs @ replicate (max k1 k2) False)))", "by (auto simp: bdd_lookup_append)"], ["proof (state)\nthis:\n  bddh (length (True # bs @ replicate (max k1 k2) False))\n   (Branch l1 r1) \\<and>\n  bddh (length (True # bs @ replicate (max k1 k2) False))\n   (Branch l2 r2) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v\n       (bdd_lookup (Branch l1 r1) (True # bs @ replicate (max k1 k2) False))\n       (bdd_lookup (Branch l2 r2)\n         (True # bs @ replicate (max k1 k2) False)))\n\ngoal (1 subgoal):\n 1. \\<not> check_eq r1 r2 T \\<Longrightarrow>\n    \\<exists>bs.\n       bddh (length bs) (Branch l1 r1) \\<and>\n       bddh (length bs) (Branch l2 r2) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n            (bdd_lookup (Branch l2 r2) bs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  bddh (length (True # bs @ replicate (max k1 k2) False))\n   (Branch l1 r1) \\<and>\n  bddh (length (True # bs @ replicate (max k1 k2) False))\n   (Branch l2 r2) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v\n       (bdd_lookup (Branch l1 r1) (True # bs @ replicate (max k1 k2) False))\n       (bdd_lookup (Branch l2 r2)\n         (True # bs @ replicate (max k1 k2) False)))\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       bddh (length bs) (Branch l1 r1) \\<and>\n       bddh (length bs) (Branch l2 r2) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n            (bdd_lookup (Branch l2 r2) bs))", "by (rule exI)"], ["proof (state)\nthis:\n  \\<exists>bs.\n     bddh (length bs) (Branch l1 r1) \\<and>\n     bddh (length bs) (Branch l2 r2) \\<and>\n     (\\<exists>n<m.\n         dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n          (bdd_lookup (Branch l2 r2) bs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>bs.\n     bddh (length bs) (Branch l1 r1) \\<and>\n     bddh (length bs) (Branch l2 r2) \\<and>\n     (\\<exists>n<m.\n         dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n          (bdd_lookup (Branch l2 r2) bs))\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       bddh (length bs) (Branch l1 r1) \\<and>\n       bddh (length bs) (Branch l2 r2) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n            (bdd_lookup (Branch l2 r2) bs)) \\<Longrightarrow>\n    \\<not> check_eq l1 l2 T \\<or> \\<not> check_eq r1 r2 T", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       bddh (length bs) (Branch l1 r1) \\<and>\n       bddh (length bs) (Branch l2 r2) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n            (bdd_lookup (Branch l2 r2) bs)) \\<Longrightarrow>\n    \\<not> check_eq l1 l2 T \\<or> \\<not> check_eq r1 r2 T", "assume \"\\<exists>bs. ?E bs\""], ["proof (state)\nthis:\n  \\<exists>bs.\n     bddh (length bs) (Branch l1 r1) \\<and>\n     bddh (length bs) (Branch l2 r2) \\<and>\n     (\\<exists>n<m.\n         dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n          (bdd_lookup (Branch l2 r2) bs))\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       bddh (length bs) (Branch l1 r1) \\<and>\n       bddh (length bs) (Branch l2 r2) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n            (bdd_lookup (Branch l2 r2) bs)) \\<Longrightarrow>\n    \\<not> check_eq l1 l2 T \\<or> \\<not> check_eq r1 r2 T", "then"], ["proof (chain)\npicking this:\n  \\<exists>bs.\n     bddh (length bs) (Branch l1 r1) \\<and>\n     bddh (length bs) (Branch l2 r2) \\<and>\n     (\\<exists>n<m.\n         dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n          (bdd_lookup (Branch l2 r2) bs))", "obtain bs where O: \"?E bs\""], ["proof (prove)\nusing this:\n  \\<exists>bs.\n     bddh (length bs) (Branch l1 r1) \\<and>\n     bddh (length bs) (Branch l2 r2) \\<and>\n     (\\<exists>n<m.\n         dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n          (bdd_lookup (Branch l2 r2) bs))\n\ngoal (1 subgoal):\n 1. (\\<And>bs.\n        bddh (length bs) (Branch l1 r1) \\<and>\n        bddh (length bs) (Branch l2 r2) \\<and>\n        (\\<exists>n<m.\n            dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n             (bdd_lookup (Branch l2 r2) bs)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  bddh (length bs) (Branch l1 r1) \\<and>\n  bddh (length bs) (Branch l2 r2) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n       (bdd_lookup (Branch l2 r2) bs))\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       bddh (length bs) (Branch l1 r1) \\<and>\n       bddh (length bs) (Branch l2 r2) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n            (bdd_lookup (Branch l2 r2) bs)) \\<Longrightarrow>\n    \\<not> check_eq l1 l2 T \\<or> \\<not> check_eq r1 r2 T", "then"], ["proof (chain)\npicking this:\n  bddh (length bs) (Branch l1 r1) \\<and>\n  bddh (length bs) (Branch l2 r2) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n       (bdd_lookup (Branch l2 r2) bs))", "obtain b br where B: \"bs = b # br\""], ["proof (prove)\nusing this:\n  bddh (length bs) (Branch l1 r1) \\<and>\n  bddh (length bs) (Branch l2 r2) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n       (bdd_lookup (Branch l2 r2) bs))\n\ngoal (1 subgoal):\n 1. (\\<And>b br. bs = b # br \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases bs) auto"], ["proof (state)\nthis:\n  bs = b # br\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       bddh (length bs) (Branch l1 r1) \\<and>\n       bddh (length bs) (Branch l2 r2) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n            (bdd_lookup (Branch l2 r2) bs)) \\<Longrightarrow>\n    \\<not> check_eq l1 l2 T \\<or> \\<not> check_eq r1 r2 T", "with O IV1 IV2"], ["proof (chain)\npicking this:\n  bddh (length bs) (Branch l1 r1) \\<and>\n  bddh (length bs) (Branch l2 r2) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n       (bdd_lookup (Branch l2 r2) bs))\n  (\\<not> check_eq l1 l2 T) =\n  (\\<exists>bs.\n      bddh (length bs) l1 \\<and>\n      bddh (length bs) l2 \\<and>\n      (\\<exists>n<m.\n          dist_nodes M n v (bdd_lookup l1 bs) (bdd_lookup l2 bs)))\n  (\\<not> check_eq r1 r2 T) =\n  (\\<exists>bs.\n      bddh (length bs) r1 \\<and>\n      bddh (length bs) r2 \\<and>\n      (\\<exists>n<m.\n          dist_nodes M n v (bdd_lookup r1 bs) (bdd_lookup r2 bs)))\n  bs = b # br", "show \"?L \\<or> ?R\""], ["proof (prove)\nusing this:\n  bddh (length bs) (Branch l1 r1) \\<and>\n  bddh (length bs) (Branch l2 r2) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n       (bdd_lookup (Branch l2 r2) bs))\n  (\\<not> check_eq l1 l2 T) =\n  (\\<exists>bs.\n      bddh (length bs) l1 \\<and>\n      bddh (length bs) l2 \\<and>\n      (\\<exists>n<m.\n          dist_nodes M n v (bdd_lookup l1 bs) (bdd_lookup l2 bs)))\n  (\\<not> check_eq r1 r2 T) =\n  (\\<exists>bs.\n      bddh (length bs) r1 \\<and>\n      bddh (length bs) r2 \\<and>\n      (\\<exists>n<m.\n          dist_nodes M n v (bdd_lookup r1 bs) (bdd_lookup r2 bs)))\n  bs = b # br\n\ngoal (1 subgoal):\n 1. \\<not> check_eq l1 l2 T \\<or> \\<not> check_eq r1 r2 T", "by (cases b) auto"], ["proof (state)\nthis:\n  \\<not> check_eq l1 l2 T \\<or> \\<not> check_eq r1 r2 T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<not> check_eq l1 l2 T \\<or> \\<not> check_eq r1 r2 T) =\n  (\\<exists>bs.\n      bddh (length bs) (Branch l1 r1) \\<and>\n      bddh (length bs) (Branch l2 r2) \\<and>\n      (\\<exists>n<m.\n          dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n           (bdd_lookup (Branch l2 r2) bs)))\n\ngoal (1 subgoal):\n 1. \\<And>l1 r1 l2 r2 T.\n       \\<lbrakk>\\<lbrakk>\\<forall>p q.\n                            dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                            tr_lookup T q p =\n                            (\\<exists>n<m. dist_nodes M n v p q);\n                 0 < m; bdd_all (dfa_is_node M) l1;\n                 bdd_all (dfa_is_node M) l2\\<rbrakk>\n                \\<Longrightarrow> (\\<not> check_eq l1 l2 T) =\n                                  (\\<exists>bs.\nbddh (length bs) l1 \\<and>\nbddh (length bs) l2 \\<and>\n(\\<exists>n<m. dist_nodes M n v (bdd_lookup l1 bs) (bdd_lookup l2 bs)));\n        \\<lbrakk>\\<forall>p q.\n                    dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                    tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n         0 < m; bdd_all (dfa_is_node M) r1;\n         bdd_all (dfa_is_node M) r2\\<rbrakk>\n        \\<Longrightarrow> (\\<not> check_eq r1 r2 T) =\n                          (\\<exists>bs.\n                              bddh (length bs) r1 \\<and>\n                              bddh (length bs) r2 \\<and>\n                              (\\<exists>n<m.\n                                  dist_nodes M n v (bdd_lookup r1 bs)\n                                   (bdd_lookup r2 bs)));\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; bdd_all (dfa_is_node M) (Branch l1 r1);\n        bdd_all (dfa_is_node M) (Branch l2 r2)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> check_eq (Branch l1 r1) (Branch l2 r2) T) =\n                         (\\<exists>bs.\n                             bddh (length bs) (Branch l1 r1) \\<and>\n                             bddh (length bs) (Branch l2 r2) \\<and>\n                             (\\<exists>n<m.\n                                 dist_nodes M n v\n                                  (bdd_lookup (Branch l1 r1) bs)\n                                  (bdd_lookup (Branch l2 r2) bs)))", "finally"], ["proof (chain)\npicking this:\n  (\\<not> check_eq (Branch l1 r1) (Branch l2 r2) T) =\n  (\\<exists>bs.\n      bddh (length bs) (Branch l1 r1) \\<and>\n      bddh (length bs) (Branch l2 r2) \\<and>\n      (\\<exists>n<m.\n          dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n           (bdd_lookup (Branch l2 r2) bs)))", "show ?case"], ["proof (prove)\nusing this:\n  (\\<not> check_eq (Branch l1 r1) (Branch l2 r2) T) =\n  (\\<exists>bs.\n      bddh (length bs) (Branch l1 r1) \\<and>\n      bddh (length bs) (Branch l2 r2) \\<and>\n      (\\<exists>n<m.\n          dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n           (bdd_lookup (Branch l2 r2) bs)))\n\ngoal (1 subgoal):\n 1. (\\<not> check_eq (Branch l1 r1) (Branch l2 r2) T) =\n    (\\<exists>bs.\n        bddh (length bs) (Branch l1 r1) \\<and>\n        bddh (length bs) (Branch l2 r2) \\<and>\n        (\\<exists>n<m.\n            dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n             (bdd_lookup (Branch l2 r2) bs)))", "by simp"], ["proof (state)\nthis:\n  (\\<not> check_eq (Branch l1 r1) (Branch l2 r2) T) =\n  (\\<exists>bs.\n      bddh (length bs) (Branch l1 r1) \\<and>\n      bddh (length bs) (Branch l2 r2) \\<and>\n      (\\<exists>n<m.\n          dist_nodes M n v (bdd_lookup (Branch l1 r1) bs)\n           (bdd_lookup (Branch l2 r2) bs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma iter_wf: \"wf_tr M T \\<Longrightarrow> wf_tr M (snd (iter M T))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_tr M T \\<Longrightarrow> wf_tr M (snd (iter M T))", "by (simp add: wf_tr_def iter_def fold_map_idx_len fold_map_idx_nth split_beta)"], ["", "lemma fixpt_wf: \"wf_tr M T \\<Longrightarrow> wf_tr M (fixpt M T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_tr M T \\<Longrightarrow> wf_tr M (fixpt M T)", "proof (induct M T rule: fixpt_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M T.\n       \\<lbrakk>\\<lbrakk>fst (iter M T); wf_tr M (snd (iter M T))\\<rbrakk>\n                \\<Longrightarrow> wf_tr M (fixpt M (snd (iter M T)));\n        wf_tr M T\\<rbrakk>\n       \\<Longrightarrow> wf_tr M (fixpt M T)", "case (1 M T)"], ["proof (state)\nthis:\n  \\<lbrakk>fst (iter M T); wf_tr M (snd (iter M T))\\<rbrakk>\n  \\<Longrightarrow> wf_tr M (fixpt M (snd (iter M T)))\n  wf_tr M T\n\ngoal (1 subgoal):\n 1. \\<And>M T.\n       \\<lbrakk>\\<lbrakk>fst (iter M T); wf_tr M (snd (iter M T))\\<rbrakk>\n                \\<Longrightarrow> wf_tr M (fixpt M (snd (iter M T)));\n        wf_tr M T\\<rbrakk>\n       \\<Longrightarrow> wf_tr M (fixpt M T)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_tr M (fixpt M T)", "proof (cases \"fst (iter M T)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. fst (iter M T) \\<Longrightarrow> wf_tr M (fixpt M T)\n 2. \\<not> fst (iter M T) \\<Longrightarrow> wf_tr M (fixpt M T)", "case True"], ["proof (state)\nthis:\n  fst (iter M T)\n\ngoal (2 subgoals):\n 1. fst (iter M T) \\<Longrightarrow> wf_tr M (fixpt M T)\n 2. \\<not> fst (iter M T) \\<Longrightarrow> wf_tr M (fixpt M T)", "with 1"], ["proof (chain)\npicking this:\n  \\<lbrakk>fst (iter M T); wf_tr M (snd (iter M T))\\<rbrakk>\n  \\<Longrightarrow> wf_tr M (fixpt M (snd (iter M T)))\n  wf_tr M T\n  fst (iter M T)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>fst (iter M T); wf_tr M (snd (iter M T))\\<rbrakk>\n  \\<Longrightarrow> wf_tr M (fixpt M (snd (iter M T)))\n  wf_tr M T\n  fst (iter M T)\n\ngoal (1 subgoal):\n 1. wf_tr M (fixpt M T)", "by (simp add: iter_wf)"], ["proof (state)\nthis:\n  wf_tr M (fixpt M T)\n\ngoal (1 subgoal):\n 1. \\<not> fst (iter M T) \\<Longrightarrow> wf_tr M (fixpt M T)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> fst (iter M T) \\<Longrightarrow> wf_tr M (fixpt M T)", "case False"], ["proof (state)\nthis:\n  \\<not> fst (iter M T)\n\ngoal (1 subgoal):\n 1. \\<not> fst (iter M T) \\<Longrightarrow> wf_tr M (fixpt M T)", "with 1"], ["proof (chain)\npicking this:\n  \\<lbrakk>fst (iter M T); wf_tr M (snd (iter M T))\\<rbrakk>\n  \\<Longrightarrow> wf_tr M (fixpt M (snd (iter M T)))\n  wf_tr M T\n  \\<not> fst (iter M T)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>fst (iter M T); wf_tr M (snd (iter M T))\\<rbrakk>\n  \\<Longrightarrow> wf_tr M (fixpt M (snd (iter M T)))\n  wf_tr M T\n  \\<not> fst (iter M T)\n\ngoal (1 subgoal):\n 1. wf_tr M (fixpt M T)", "by simp"], ["proof (state)\nthis:\n  wf_tr M (fixpt M T)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wf_tr M (fixpt M T)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_split:\n  assumes \"n \\<le> length bss\"\n  shows \"\\<exists>b bs. bss = b @ bs \\<and> length b = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b bs. bss = b @ bs \\<and> length b = n", "using assms"], ["proof (prove)\nusing this:\n  n \\<le> length bss\n\ngoal (1 subgoal):\n 1. \\<exists>b bs. bss = b @ bs \\<and> length b = n", "proof (induct bss arbitrary: n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       n \\<le> length [] \\<Longrightarrow>\n       \\<exists>b bs. [] = b @ bs \\<and> length b = n\n 2. \\<And>a bss n.\n       \\<lbrakk>\\<And>n.\n                   n \\<le> length bss \\<Longrightarrow>\n                   \\<exists>b bs. bss = b @ bs \\<and> length b = n;\n        n \\<le> length (a # bss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b bs. a # bss = b @ bs \\<and> length b = n", "case (Cons a as)"], ["proof (state)\nthis:\n  ?n \\<le> length as \\<Longrightarrow>\n  \\<exists>b bs. as = b @ bs \\<and> length b = ?n\n  n \\<le> length (a # as)\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       n \\<le> length [] \\<Longrightarrow>\n       \\<exists>b bs. [] = b @ bs \\<and> length b = n\n 2. \\<And>a bss n.\n       \\<lbrakk>\\<And>n.\n                   n \\<le> length bss \\<Longrightarrow>\n                   \\<exists>b bs. bss = b @ bs \\<and> length b = n;\n        n \\<le> length (a # bss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b bs. a # bss = b @ bs \\<and> length b = n", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b bs. a # as = b @ bs \\<and> length b = n", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>b bs. a # as = b @ bs \\<and> length b = n\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>b bs. a # as = b @ bs \\<and> length b = n", "case (Suc n')"], ["proof (state)\nthis:\n  n = Suc n'\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>b bs. a # as = b @ bs \\<and> length b = n\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>b bs. a # as = b @ bs \\<and> length b = n", "with Cons"], ["proof (chain)\npicking this:\n  ?n \\<le> length as \\<Longrightarrow>\n  \\<exists>b bs. as = b @ bs \\<and> length b = ?n\n  n \\<le> length (a # as)\n  n = Suc n'", "have \"\\<exists>b bs. as = b @ bs \\<and> length b = n'\""], ["proof (prove)\nusing this:\n  ?n \\<le> length as \\<Longrightarrow>\n  \\<exists>b bs. as = b @ bs \\<and> length b = ?n\n  n \\<le> length (a # as)\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. \\<exists>b bs. as = b @ bs \\<and> length b = n'", "by simp"], ["proof (state)\nthis:\n  \\<exists>b bs. as = b @ bs \\<and> length b = n'\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>b bs. a # as = b @ bs \\<and> length b = n\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>b bs. a # as = b @ bs \\<and> length b = n", "then"], ["proof (chain)\npicking this:\n  \\<exists>b bs. as = b @ bs \\<and> length b = n'", "obtain b bs where B: \"as = b @ bs \\<and> length b = n'\""], ["proof (prove)\nusing this:\n  \\<exists>b bs. as = b @ bs \\<and> length b = n'\n\ngoal (1 subgoal):\n 1. (\\<And>b bs.\n        as = b @ bs \\<and> length b = n' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  as = b @ bs \\<and> length b = n'\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>b bs. a # as = b @ bs \\<and> length b = n\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>b bs. a # as = b @ bs \\<and> length b = n", "with Suc Cons"], ["proof (chain)\npicking this:\n  n = Suc n'\n  ?n \\<le> length as \\<Longrightarrow>\n  \\<exists>b bs. as = b @ bs \\<and> length b = ?n\n  n \\<le> length (a # as)\n  as = b @ bs \\<and> length b = n'", "have \"a # as = (a # b) @ bs \\<and> length (a # b) = n\""], ["proof (prove)\nusing this:\n  n = Suc n'\n  ?n \\<le> length as \\<Longrightarrow>\n  \\<exists>b bs. as = b @ bs \\<and> length b = ?n\n  n \\<le> length (a # as)\n  as = b @ bs \\<and> length b = n'\n\ngoal (1 subgoal):\n 1. a # as = (a # b) @ bs \\<and> length (a # b) = n", "by simp"], ["proof (state)\nthis:\n  a # as = (a # b) @ bs \\<and> length (a # b) = n\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>b bs. a # as = b @ bs \\<and> length b = n\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>b bs. a # as = b @ bs \\<and> length b = n", "thus ?thesis"], ["proof (prove)\nusing this:\n  a # as = (a # b) @ bs \\<and> length (a # b) = n\n\ngoal (1 subgoal):\n 1. \\<exists>b bs. a # as = b @ bs \\<and> length b = n", "by blast"], ["proof (state)\nthis:\n  \\<exists>b bs. a # as = b @ bs \\<and> length b = n\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>b bs. a # as = b @ bs \\<and> length b = n", "qed simp"], ["proof (state)\nthis:\n  \\<exists>b bs. a # as = b @ bs \\<and> length b = n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<le> length [] \\<Longrightarrow>\n       \\<exists>b bs. [] = b @ bs \\<and> length b = n", "qed simp"], ["", "lemma iter_dist_nodes:\n  assumes \"wf_tr M T\"\n  and \"wf_dfa M v\"\n  and \"\\<forall>p q. dfa_is_node M q \\<and> p < q \\<longrightarrow> tr_lookup T q p = (\\<exists>n < m. dist_nodes M n v p q)\" and \"m > 0\"\n  and \"dfa_is_node M q\" and \"p < q\"\n  shows \"tr_lookup (snd (iter M T)) q p = (\\<exists>n < Suc m. dist_nodes M n v p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tr_lookup (snd (iter M T)) q p =\n    (\\<exists>n<Suc m. dist_nodes M n v p q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. tr_lookup (snd (iter M T)) q p =\n    (\\<exists>n<Suc m. dist_nodes M n v p q)", "from assms"], ["proof (chain)\npicking this:\n  wf_tr M T\n  wf_dfa M v\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n  dfa_is_node M q\n  p < q", "obtain m' where M': \"m = Suc m'\""], ["proof (prove)\nusing this:\n  wf_tr M T\n  wf_dfa M v\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n  dfa_is_node M q\n  p < q\n\ngoal (1 subgoal):\n 1. (\\<And>m'. m = Suc m' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases m) simp+"], ["proof (state)\nthis:\n  m = Suc m'\n\ngoal (1 subgoal):\n 1. tr_lookup (snd (iter M T)) q p =\n    (\\<exists>n<Suc m. dist_nodes M n v p q)", "have C: \"(\\<not> check_eq (fst M ! q) (fst M ! p) T) = (\\<exists>n<m. dist_nodes M (Suc n) v p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> check_eq (fst M ! q) (fst M ! p) T) =\n    (\\<exists>n<m. dist_nodes M (Suc n) v p q)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> check_eq (fst M ! q) (fst M ! p) T \\<Longrightarrow>\n    \\<exists>n<m. dist_nodes M (Suc n) v p q\n 2. \\<exists>n<m. dist_nodes M (Suc n) v p q \\<Longrightarrow>\n    \\<not> check_eq (fst M ! q) (fst M ! p) T", "assume \"\\<not> check_eq (fst M ! q) (fst M ! p) T\""], ["proof (state)\nthis:\n  \\<not> check_eq (fst M ! q) (fst M ! p) T\n\ngoal (2 subgoals):\n 1. \\<not> check_eq (fst M ! q) (fst M ! p) T \\<Longrightarrow>\n    \\<exists>n<m. dist_nodes M (Suc n) v p q\n 2. \\<exists>n<m. dist_nodes M (Suc n) v p q \\<Longrightarrow>\n    \\<not> check_eq (fst M ! q) (fst M ! p) T", "with assms"], ["proof (chain)\npicking this:\n  wf_tr M T\n  wf_dfa M v\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n  dfa_is_node M q\n  p < q\n  \\<not> check_eq (fst M ! q) (fst M ! p) T", "have \"\\<exists>bs. bddh (length bs) (fst M ! q) \\<and> bddh (length bs) (fst M ! p) \\<and> (\\<exists>n < m. dist_nodes M n v (bdd_lookup (fst M ! q) bs) (bdd_lookup (fst M ! p) bs))\""], ["proof (prove)\nusing this:\n  wf_tr M T\n  wf_dfa M v\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n  dfa_is_node M q\n  p < q\n  \\<not> check_eq (fst M ! q) (fst M ! p) T\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       bddh (length bs) (fst M ! q) \\<and>\n       bddh (length bs) (fst M ! p) \\<and>\n       (\\<exists>n<m.\n           dist_nodes M n v (bdd_lookup (fst M ! q) bs)\n            (bdd_lookup (fst M ! p) bs))", "by (simp add: check_eq_dist_nodes wf_dfa_def list_all_iff dfa_is_node_def)"], ["proof (state)\nthis:\n  \\<exists>bs.\n     bddh (length bs) (fst M ! q) \\<and>\n     bddh (length bs) (fst M ! p) \\<and>\n     (\\<exists>n<m.\n         dist_nodes M n v (bdd_lookup (fst M ! q) bs)\n          (bdd_lookup (fst M ! p) bs))\n\ngoal (2 subgoals):\n 1. \\<not> check_eq (fst M ! q) (fst M ! p) T \\<Longrightarrow>\n    \\<exists>n<m. dist_nodes M (Suc n) v p q\n 2. \\<exists>n<m. dist_nodes M (Suc n) v p q \\<Longrightarrow>\n    \\<not> check_eq (fst M ! q) (fst M ! p) T", "then"], ["proof (chain)\npicking this:\n  \\<exists>bs.\n     bddh (length bs) (fst M ! q) \\<and>\n     bddh (length bs) (fst M ! p) \\<and>\n     (\\<exists>n<m.\n         dist_nodes M n v (bdd_lookup (fst M ! q) bs)\n          (bdd_lookup (fst M ! p) bs))", "obtain bs n bss where X: \"bddh (length bs) (fst M ! q) \\<and> bddh (length bs) (fst M ! p) \\<and> n < m \\<and>\n      length bss = n \\<and> list_all (is_alph v) bss \\<and> dfa_accepting M (dfa_steps M (bdd_lookup (fst M ! q) bs) bss) \\<noteq> dfa_accepting M (dfa_steps M (bdd_lookup (fst M ! p) bs) bss)\""], ["proof (prove)\nusing this:\n  \\<exists>bs.\n     bddh (length bs) (fst M ! q) \\<and>\n     bddh (length bs) (fst M ! p) \\<and>\n     (\\<exists>n<m.\n         dist_nodes M n v (bdd_lookup (fst M ! q) bs)\n          (bdd_lookup (fst M ! p) bs))\n\ngoal (1 subgoal):\n 1. (\\<And>bs n bss.\n        bddh (length bs) (fst M ! q) \\<and>\n        bddh (length bs) (fst M ! p) \\<and>\n        n < m \\<and>\n        length bss = n \\<and>\n        list_all (is_alph v) bss \\<and>\n        dfa_accepting M\n         (dfa_steps M (bdd_lookup (fst M ! q) bs) bss) \\<noteq>\n        dfa_accepting M\n         (dfa_steps M (bdd_lookup (fst M ! p) bs) bss) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding dist_nodes_def"], ["proof (prove)\nusing this:\n  \\<exists>bs.\n     bddh (length bs) (fst M ! q) \\<and>\n     bddh (length bs) (fst M ! p) \\<and>\n     (\\<exists>n<m.\n         \\<exists>w.\n            length w = n \\<and>\n            list_all (is_alph v) w \\<and>\n            dfa_accepting M\n             (dfa_steps M (bdd_lookup (fst M ! q) bs) w) \\<noteq>\n            dfa_accepting M (dfa_steps M (bdd_lookup (fst M ! p) bs) w))\n\ngoal (1 subgoal):\n 1. (\\<And>bs n bss.\n        bddh (length bs) (fst M ! q) \\<and>\n        bddh (length bs) (fst M ! p) \\<and>\n        n < m \\<and>\n        length bss = n \\<and>\n        list_all (is_alph v) bss \\<and>\n        dfa_accepting M\n         (dfa_steps M (bdd_lookup (fst M ! q) bs) bss) \\<noteq>\n        dfa_accepting M\n         (dfa_steps M (bdd_lookup (fst M ! p) bs) bss) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  bddh (length bs) (fst M ! q) \\<and>\n  bddh (length bs) (fst M ! p) \\<and>\n  n < m \\<and>\n  length bss = n \\<and>\n  list_all (is_alph v) bss \\<and>\n  dfa_accepting M (dfa_steps M (bdd_lookup (fst M ! q) bs) bss) \\<noteq>\n  dfa_accepting M (dfa_steps M (bdd_lookup (fst M ! p) bs) bss)\n\ngoal (2 subgoals):\n 1. \\<not> check_eq (fst M ! q) (fst M ! p) T \\<Longrightarrow>\n    \\<exists>n<m. dist_nodes M (Suc n) v p q\n 2. \\<exists>n<m. dist_nodes M (Suc n) v p q \\<Longrightarrow>\n    \\<not> check_eq (fst M ! q) (fst M ! p) T", "from list_split[of v \"bs @ replicate v False\"]"], ["proof (chain)\npicking this:\n  v \\<le> length (bs @ replicate v False) \\<Longrightarrow>\n  \\<exists>b bsa. bs @ replicate v False = b @ bsa \\<and> length b = v", "have \"\\<exists>b' bs'. bs @ replicate v False = b' @ bs' \\<and> length b' = v\""], ["proof (prove)\nusing this:\n  v \\<le> length (bs @ replicate v False) \\<Longrightarrow>\n  \\<exists>b bsa. bs @ replicate v False = b @ bsa \\<and> length b = v\n\ngoal (1 subgoal):\n 1. \\<exists>b' bs'. bs @ replicate v False = b' @ bs' \\<and> length b' = v", "by simp"], ["proof (state)\nthis:\n  \\<exists>b' bs'. bs @ replicate v False = b' @ bs' \\<and> length b' = v\n\ngoal (2 subgoals):\n 1. \\<not> check_eq (fst M ! q) (fst M ! p) T \\<Longrightarrow>\n    \\<exists>n<m. dist_nodes M (Suc n) v p q\n 2. \\<exists>n<m. dist_nodes M (Suc n) v p q \\<Longrightarrow>\n    \\<not> check_eq (fst M ! q) (fst M ! p) T", "then"], ["proof (chain)\npicking this:\n  \\<exists>b' bs'. bs @ replicate v False = b' @ bs' \\<and> length b' = v", "obtain b' bs' where V: \"bs @ replicate v False = b' @ bs' \\<and> length b' = v\""], ["proof (prove)\nusing this:\n  \\<exists>b' bs'. bs @ replicate v False = b' @ bs' \\<and> length b' = v\n\ngoal (1 subgoal):\n 1. (\\<And>b' bs'.\n        bs @ replicate v False = b' @ bs' \\<and>\n        length b' = v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  bs @ replicate v False = b' @ bs' \\<and> length b' = v\n\ngoal (2 subgoals):\n 1. \\<not> check_eq (fst M ! q) (fst M ! p) T \\<Longrightarrow>\n    \\<exists>n<m. dist_nodes M (Suc n) v p q\n 2. \\<exists>n<m. dist_nodes M (Suc n) v p q \\<Longrightarrow>\n    \\<not> check_eq (fst M ! q) (fst M ! p) T", "with X bdd_lookup_append[of \"length bs\" \"fst M ! q\" \"bs\" \"replicate v False\"] bdd_lookup_append[of \"length bs\" \"fst M ! p\" \"bs\" \"replicate v False\"]"], ["proof (chain)\npicking this:\n  bddh (length bs) (fst M ! q) \\<and>\n  bddh (length bs) (fst M ! p) \\<and>\n  n < m \\<and>\n  length bss = n \\<and>\n  list_all (is_alph v) bss \\<and>\n  dfa_accepting M (dfa_steps M (bdd_lookup (fst M ! q) bs) bss) \\<noteq>\n  dfa_accepting M (dfa_steps M (bdd_lookup (fst M ! p) bs) bss)\n  \\<lbrakk>bddh (length bs) (fst M ! q); length bs \\<le> length bs\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (fst M ! q) (bs @ replicate v False) =\n                    bdd_lookup (fst M ! q) bs\n  \\<lbrakk>bddh (length bs) (fst M ! p); length bs \\<le> length bs\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (fst M ! p) (bs @ replicate v False) =\n                    bdd_lookup (fst M ! p) bs\n  bs @ replicate v False = b' @ bs' \\<and> length b' = v", "have 1: \"dfa_accepting M (dfa_steps M (bdd_lookup (fst M ! q) (bs @ replicate v False)) bss) \\<noteq> dfa_accepting M (dfa_steps M (bdd_lookup (fst M ! p) (bs @ replicate v False)) bss)\""], ["proof (prove)\nusing this:\n  bddh (length bs) (fst M ! q) \\<and>\n  bddh (length bs) (fst M ! p) \\<and>\n  n < m \\<and>\n  length bss = n \\<and>\n  list_all (is_alph v) bss \\<and>\n  dfa_accepting M (dfa_steps M (bdd_lookup (fst M ! q) bs) bss) \\<noteq>\n  dfa_accepting M (dfa_steps M (bdd_lookup (fst M ! p) bs) bss)\n  \\<lbrakk>bddh (length bs) (fst M ! q); length bs \\<le> length bs\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (fst M ! q) (bs @ replicate v False) =\n                    bdd_lookup (fst M ! q) bs\n  \\<lbrakk>bddh (length bs) (fst M ! p); length bs \\<le> length bs\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (fst M ! p) (bs @ replicate v False) =\n                    bdd_lookup (fst M ! p) bs\n  bs @ replicate v False = b' @ bs' \\<and> length b' = v\n\ngoal (1 subgoal):\n 1. dfa_accepting M\n     (dfa_steps M (bdd_lookup (fst M ! q) (bs @ replicate v False))\n       bss) \\<noteq>\n    dfa_accepting M\n     (dfa_steps M (bdd_lookup (fst M ! p) (bs @ replicate v False)) bss)", "by simp"], ["proof (state)\nthis:\n  dfa_accepting M\n   (dfa_steps M (bdd_lookup (fst M ! q) (bs @ replicate v False))\n     bss) \\<noteq>\n  dfa_accepting M\n   (dfa_steps M (bdd_lookup (fst M ! p) (bs @ replicate v False)) bss)\n\ngoal (2 subgoals):\n 1. \\<not> check_eq (fst M ! q) (fst M ! p) T \\<Longrightarrow>\n    \\<exists>n<m. dist_nodes M (Suc n) v p q\n 2. \\<exists>n<m. dist_nodes M (Suc n) v p q \\<Longrightarrow>\n    \\<not> check_eq (fst M ! q) (fst M ! p) T", "from assms"], ["proof (chain)\npicking this:\n  wf_tr M T\n  wf_dfa M v\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n  dfa_is_node M q\n  p < q", "have \"bddh v (fst M ! q) \\<and> bddh v (fst M ! p)\""], ["proof (prove)\nusing this:\n  wf_tr M T\n  wf_dfa M v\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n  dfa_is_node M q\n  p < q\n\ngoal (1 subgoal):\n 1. bddh v (fst M ! q) \\<and> bddh v (fst M ! p)", "by (simp add: wf_dfa_def dfa_is_node_def list_all_iff)"], ["proof (state)\nthis:\n  bddh v (fst M ! q) \\<and> bddh v (fst M ! p)\n\ngoal (2 subgoals):\n 1. \\<not> check_eq (fst M ! q) (fst M ! p) T \\<Longrightarrow>\n    \\<exists>n<m. dist_nodes M (Suc n) v p q\n 2. \\<exists>n<m. dist_nodes M (Suc n) v p q \\<Longrightarrow>\n    \\<not> check_eq (fst M ! q) (fst M ! p) T", "with 1 V"], ["proof (chain)\npicking this:\n  dfa_accepting M\n   (dfa_steps M (bdd_lookup (fst M ! q) (bs @ replicate v False))\n     bss) \\<noteq>\n  dfa_accepting M\n   (dfa_steps M (bdd_lookup (fst M ! p) (bs @ replicate v False)) bss)\n  bs @ replicate v False = b' @ bs' \\<and> length b' = v\n  bddh v (fst M ! q) \\<and> bddh v (fst M ! p)", "have \"dfa_accepting M (dfa_steps M (dfa_trans M q b') bss) \\<noteq> dfa_accepting M (dfa_steps M (dfa_trans M p b') bss)\""], ["proof (prove)\nusing this:\n  dfa_accepting M\n   (dfa_steps M (bdd_lookup (fst M ! q) (bs @ replicate v False))\n     bss) \\<noteq>\n  dfa_accepting M\n   (dfa_steps M (bdd_lookup (fst M ! p) (bs @ replicate v False)) bss)\n  bs @ replicate v False = b' @ bs' \\<and> length b' = v\n  bddh v (fst M ! q) \\<and> bddh v (fst M ! p)\n\ngoal (1 subgoal):\n 1. dfa_accepting M (dfa_steps M (dfa_trans M q b') bss) \\<noteq>\n    dfa_accepting M (dfa_steps M (dfa_trans M p b') bss)", "by (auto simp: bdd_lookup_append dfa_trans_def)"], ["proof (state)\nthis:\n  dfa_accepting M (dfa_steps M (dfa_trans M q b') bss) \\<noteq>\n  dfa_accepting M (dfa_steps M (dfa_trans M p b') bss)\n\ngoal (2 subgoals):\n 1. \\<not> check_eq (fst M ! q) (fst M ! p) T \\<Longrightarrow>\n    \\<exists>n<m. dist_nodes M (Suc n) v p q\n 2. \\<exists>n<m. dist_nodes M (Suc n) v p q \\<Longrightarrow>\n    \\<not> check_eq (fst M ! q) (fst M ! p) T", "with X V"], ["proof (chain)\npicking this:\n  bddh (length bs) (fst M ! q) \\<and>\n  bddh (length bs) (fst M ! p) \\<and>\n  n < m \\<and>\n  length bss = n \\<and>\n  list_all (is_alph v) bss \\<and>\n  dfa_accepting M (dfa_steps M (bdd_lookup (fst M ! q) bs) bss) \\<noteq>\n  dfa_accepting M (dfa_steps M (bdd_lookup (fst M ! p) bs) bss)\n  bs @ replicate v False = b' @ bs' \\<and> length b' = v\n  dfa_accepting M (dfa_steps M (dfa_trans M q b') bss) \\<noteq>\n  dfa_accepting M (dfa_steps M (dfa_trans M p b') bss)", "have \"is_alph v b' \\<and> dist_nodes M n v (dfa_trans M p b') (dfa_trans M q b')\""], ["proof (prove)\nusing this:\n  bddh (length bs) (fst M ! q) \\<and>\n  bddh (length bs) (fst M ! p) \\<and>\n  n < m \\<and>\n  length bss = n \\<and>\n  list_all (is_alph v) bss \\<and>\n  dfa_accepting M (dfa_steps M (bdd_lookup (fst M ! q) bs) bss) \\<noteq>\n  dfa_accepting M (dfa_steps M (bdd_lookup (fst M ! p) bs) bss)\n  bs @ replicate v False = b' @ bs' \\<and> length b' = v\n  dfa_accepting M (dfa_steps M (dfa_trans M q b') bss) \\<noteq>\n  dfa_accepting M (dfa_steps M (dfa_trans M p b') bss)\n\ngoal (1 subgoal):\n 1. is_alph v b' \\<and>\n    dist_nodes M n v (dfa_trans M p b') (dfa_trans M q b')", "by (auto simp: dist_nodes_def is_alph_def)"], ["proof (state)\nthis:\n  is_alph v b' \\<and> dist_nodes M n v (dfa_trans M p b') (dfa_trans M q b')\n\ngoal (2 subgoals):\n 1. \\<not> check_eq (fst M ! q) (fst M ! p) T \\<Longrightarrow>\n    \\<exists>n<m. dist_nodes M (Suc n) v p q\n 2. \\<exists>n<m. dist_nodes M (Suc n) v p q \\<Longrightarrow>\n    \\<not> check_eq (fst M ! q) (fst M ! p) T", "hence \"dist_nodes M (Suc n) v p q\""], ["proof (prove)\nusing this:\n  is_alph v b' \\<and> dist_nodes M n v (dfa_trans M p b') (dfa_trans M q b')\n\ngoal (1 subgoal):\n 1. dist_nodes M (Suc n) v p q", "by (auto simp: dist_nodes_suc)"], ["proof (state)\nthis:\n  dist_nodes M (Suc n) v p q\n\ngoal (2 subgoals):\n 1. \\<not> check_eq (fst M ! q) (fst M ! p) T \\<Longrightarrow>\n    \\<exists>n<m. dist_nodes M (Suc n) v p q\n 2. \\<exists>n<m. dist_nodes M (Suc n) v p q \\<Longrightarrow>\n    \\<not> check_eq (fst M ! q) (fst M ! p) T", "with X"], ["proof (chain)\npicking this:\n  bddh (length bs) (fst M ! q) \\<and>\n  bddh (length bs) (fst M ! p) \\<and>\n  n < m \\<and>\n  length bss = n \\<and>\n  list_all (is_alph v) bss \\<and>\n  dfa_accepting M (dfa_steps M (bdd_lookup (fst M ! q) bs) bss) \\<noteq>\n  dfa_accepting M (dfa_steps M (bdd_lookup (fst M ! p) bs) bss)\n  dist_nodes M (Suc n) v p q", "show \"\\<exists>n<m. dist_nodes M (Suc n) v p q\""], ["proof (prove)\nusing this:\n  bddh (length bs) (fst M ! q) \\<and>\n  bddh (length bs) (fst M ! p) \\<and>\n  n < m \\<and>\n  length bss = n \\<and>\n  list_all (is_alph v) bss \\<and>\n  dfa_accepting M (dfa_steps M (bdd_lookup (fst M ! q) bs) bss) \\<noteq>\n  dfa_accepting M (dfa_steps M (bdd_lookup (fst M ! p) bs) bss)\n  dist_nodes M (Suc n) v p q\n\ngoal (1 subgoal):\n 1. \\<exists>n<m. dist_nodes M (Suc n) v p q", "by auto"], ["proof (state)\nthis:\n  \\<exists>n<m. dist_nodes M (Suc n) v p q\n\ngoal (1 subgoal):\n 1. \\<exists>n<m. dist_nodes M (Suc n) v p q \\<Longrightarrow>\n    \\<not> check_eq (fst M ! q) (fst M ! p) T", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n<m. dist_nodes M (Suc n) v p q \\<Longrightarrow>\n    \\<not> check_eq (fst M ! q) (fst M ! p) T", "assume \"\\<exists>n<m. dist_nodes M (Suc n) v p q\""], ["proof (state)\nthis:\n  \\<exists>n<m. dist_nodes M (Suc n) v p q\n\ngoal (1 subgoal):\n 1. \\<exists>n<m. dist_nodes M (Suc n) v p q \\<Longrightarrow>\n    \\<not> check_eq (fst M ! q) (fst M ! p) T", "hence \"\\<exists>bs. \\<exists>n<m. is_alph v bs \\<and> dist_nodes M n v (dfa_trans M p bs) (dfa_trans M q bs)\""], ["proof (prove)\nusing this:\n  \\<exists>n<m. dist_nodes M (Suc n) v p q\n\ngoal (1 subgoal):\n 1. \\<exists>bs n.\n       n < m \\<and>\n       is_alph v bs \\<and>\n       dist_nodes M n v (dfa_trans M p bs) (dfa_trans M q bs)", "by (auto simp: dist_nodes_suc)"], ["proof (state)\nthis:\n  \\<exists>bs n.\n     n < m \\<and>\n     is_alph v bs \\<and>\n     dist_nodes M n v (dfa_trans M p bs) (dfa_trans M q bs)\n\ngoal (1 subgoal):\n 1. \\<exists>n<m. dist_nodes M (Suc n) v p q \\<Longrightarrow>\n    \\<not> check_eq (fst M ! q) (fst M ! p) T", "then"], ["proof (chain)\npicking this:\n  \\<exists>bs n.\n     n < m \\<and>\n     is_alph v bs \\<and>\n     dist_nodes M n v (dfa_trans M p bs) (dfa_trans M q bs)", "obtain bs where X: \"\\<exists>n<m. is_alph v bs \\<and> dist_nodes M n v (dfa_trans M p bs) (dfa_trans M q bs)\""], ["proof (prove)\nusing this:\n  \\<exists>bs n.\n     n < m \\<and>\n     is_alph v bs \\<and>\n     dist_nodes M n v (dfa_trans M p bs) (dfa_trans M q bs)\n\ngoal (1 subgoal):\n 1. (\\<And>bs.\n        \\<exists>n<m.\n           is_alph v bs \\<and>\n           dist_nodes M n v (dfa_trans M p bs)\n            (dfa_trans M q bs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<exists>n<m.\n     is_alph v bs \\<and>\n     dist_nodes M n v (dfa_trans M p bs) (dfa_trans M q bs)\n\ngoal (1 subgoal):\n 1. \\<exists>n<m. dist_nodes M (Suc n) v p q \\<Longrightarrow>\n    \\<not> check_eq (fst M ! q) (fst M ! p) T", "hence BS: \"length bs = v\""], ["proof (prove)\nusing this:\n  \\<exists>n<m.\n     is_alph v bs \\<and>\n     dist_nodes M n v (dfa_trans M p bs) (dfa_trans M q bs)\n\ngoal (1 subgoal):\n 1. length bs = v", "by (auto simp: is_alph_def)"], ["proof (state)\nthis:\n  length bs = v\n\ngoal (1 subgoal):\n 1. \\<exists>n<m. dist_nodes M (Suc n) v p q \\<Longrightarrow>\n    \\<not> check_eq (fst M ! q) (fst M ! p) T", "with assms"], ["proof (chain)\npicking this:\n  wf_tr M T\n  wf_dfa M v\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n  dfa_is_node M q\n  p < q\n  length bs = v", "have \"bddh (length bs) (fst M ! p) \\<and> bddh (length bs) (fst M ! q)\""], ["proof (prove)\nusing this:\n  wf_tr M T\n  wf_dfa M v\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n  dfa_is_node M q\n  p < q\n  length bs = v\n\ngoal (1 subgoal):\n 1. bddh (length bs) (fst M ! p) \\<and> bddh (length bs) (fst M ! q)", "by (simp add: wf_dfa_def dfa_is_node_def list_all_iff)"], ["proof (state)\nthis:\n  bddh (length bs) (fst M ! p) \\<and> bddh (length bs) (fst M ! q)\n\ngoal (1 subgoal):\n 1. \\<exists>n<m. dist_nodes M (Suc n) v p q \\<Longrightarrow>\n    \\<not> check_eq (fst M ! q) (fst M ! p) T", "with X"], ["proof (chain)\npicking this:\n  \\<exists>n<m.\n     is_alph v bs \\<and>\n     dist_nodes M n v (dfa_trans M p bs) (dfa_trans M q bs)\n  bddh (length bs) (fst M ! p) \\<and> bddh (length bs) (fst M ! q)", "have \"bddh (length bs) (fst M ! p) \\<and> bddh (length bs) (fst M ! q) \\<and> (\\<exists>n<m. dist_nodes M n v (bdd_lookup (fst M ! q) bs) (bdd_lookup (fst M ! p) bs))\""], ["proof (prove)\nusing this:\n  \\<exists>n<m.\n     is_alph v bs \\<and>\n     dist_nodes M n v (dfa_trans M p bs) (dfa_trans M q bs)\n  bddh (length bs) (fst M ! p) \\<and> bddh (length bs) (fst M ! q)\n\ngoal (1 subgoal):\n 1. bddh (length bs) (fst M ! p) \\<and>\n    bddh (length bs) (fst M ! q) \\<and>\n    (\\<exists>n<m.\n        dist_nodes M n v (bdd_lookup (fst M ! q) bs)\n         (bdd_lookup (fst M ! p) bs))", "by (auto simp: dfa_trans_def dist_nodes_def)"], ["proof (state)\nthis:\n  bddh (length bs) (fst M ! p) \\<and>\n  bddh (length bs) (fst M ! q) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup (fst M ! q) bs)\n       (bdd_lookup (fst M ! p) bs))\n\ngoal (1 subgoal):\n 1. \\<exists>n<m. dist_nodes M (Suc n) v p q \\<Longrightarrow>\n    \\<not> check_eq (fst M ! q) (fst M ! p) T", "moreover"], ["proof (state)\nthis:\n  bddh (length bs) (fst M ! p) \\<and>\n  bddh (length bs) (fst M ! q) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup (fst M ! q) bs)\n       (bdd_lookup (fst M ! p) bs))\n\ngoal (1 subgoal):\n 1. \\<exists>n<m. dist_nodes M (Suc n) v p q \\<Longrightarrow>\n    \\<not> check_eq (fst M ! q) (fst M ! p) T", "from assms"], ["proof (chain)\npicking this:\n  wf_tr M T\n  wf_dfa M v\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n  dfa_is_node M q\n  p < q", "have \"bdd_all (dfa_is_node M) (fst M ! p) \\<and> bdd_all (dfa_is_node M) (fst M ! q)\""], ["proof (prove)\nusing this:\n  wf_tr M T\n  wf_dfa M v\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n  dfa_is_node M q\n  p < q\n\ngoal (1 subgoal):\n 1. bdd_all (dfa_is_node M) (fst M ! p) \\<and>\n    bdd_all (dfa_is_node M) (fst M ! q)", "by (simp add: wf_dfa_def dfa_is_node_def list_all_iff)"], ["proof (state)\nthis:\n  bdd_all (dfa_is_node M) (fst M ! p) \\<and>\n  bdd_all (dfa_is_node M) (fst M ! q)\n\ngoal (1 subgoal):\n 1. \\<exists>n<m. dist_nodes M (Suc n) v p q \\<Longrightarrow>\n    \\<not> check_eq (fst M ! q) (fst M ! p) T", "moreover"], ["proof (state)\nthis:\n  bdd_all (dfa_is_node M) (fst M ! p) \\<and>\n  bdd_all (dfa_is_node M) (fst M ! q)\n\ngoal (1 subgoal):\n 1. \\<exists>n<m. dist_nodes M (Suc n) v p q \\<Longrightarrow>\n    \\<not> check_eq (fst M ! q) (fst M ! p) T", "note assms(3,4)"], ["proof (state)\nthis:\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n\ngoal (1 subgoal):\n 1. \\<exists>n<m. dist_nodes M (Suc n) v p q \\<Longrightarrow>\n    \\<not> check_eq (fst M ! q) (fst M ! p) T", "ultimately"], ["proof (chain)\npicking this:\n  bddh (length bs) (fst M ! p) \\<and>\n  bddh (length bs) (fst M ! q) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup (fst M ! q) bs)\n       (bdd_lookup (fst M ! p) bs))\n  bdd_all (dfa_is_node M) (fst M ! p) \\<and>\n  bdd_all (dfa_is_node M) (fst M ! q)\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m", "show \"\\<not> check_eq (fst M ! q) (fst M ! p) T\""], ["proof (prove)\nusing this:\n  bddh (length bs) (fst M ! p) \\<and>\n  bddh (length bs) (fst M ! q) \\<and>\n  (\\<exists>n<m.\n      dist_nodes M n v (bdd_lookup (fst M ! q) bs)\n       (bdd_lookup (fst M ! p) bs))\n  bdd_all (dfa_is_node M) (fst M ! p) \\<and>\n  bdd_all (dfa_is_node M) (fst M ! q)\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n\ngoal (1 subgoal):\n 1. \\<not> check_eq (fst M ! q) (fst M ! p) T", "by (auto simp: check_eq_dist_nodes)"], ["proof (state)\nthis:\n  \\<not> check_eq (fst M ! q) (fst M ! p) T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<not> check_eq (fst M ! q) (fst M ! p) T) =\n  (\\<exists>n<m. dist_nodes M (Suc n) v p q)\n\ngoal (1 subgoal):\n 1. tr_lookup (snd (iter M T)) q p =\n    (\\<exists>n<Suc m. dist_nodes M n v p q)", "from assms"], ["proof (chain)\npicking this:\n  wf_tr M T\n  wf_dfa M v\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n  dfa_is_node M q\n  p < q", "have \"tr_lookup (snd (iter M T)) q p =\n    (if tr_lookup T q p then True else \\<not> check_eq (fst M ! q) (fst M ! p) T)\""], ["proof (prove)\nusing this:\n  wf_tr M T\n  wf_dfa M v\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n  dfa_is_node M q\n  p < q\n\ngoal (1 subgoal):\n 1. tr_lookup (snd (iter M T)) q p =\n    (if tr_lookup T q p then True\n     else \\<not> check_eq (fst M ! q) (fst M ! p) T)", "by (auto simp add: iter_def wf_tr_def split_beta fold_map_idx_nth tr_lookup_def dfa_is_node_def)"], ["proof (state)\nthis:\n  tr_lookup (snd (iter M T)) q p =\n  (if tr_lookup T q p then True\n   else \\<not> check_eq (fst M ! q) (fst M ! p) T)\n\ngoal (1 subgoal):\n 1. tr_lookup (snd (iter M T)) q p =\n    (\\<exists>n<Suc m. dist_nodes M n v p q)", "also"], ["proof (state)\nthis:\n  tr_lookup (snd (iter M T)) q p =\n  (if tr_lookup T q p then True\n   else \\<not> check_eq (fst M ! q) (fst M ! p) T)\n\ngoal (1 subgoal):\n 1. tr_lookup (snd (iter M T)) q p =\n    (\\<exists>n<Suc m. dist_nodes M n v p q)", "have \"\\<dots> = (tr_lookup T q p \\<or> \\<not> check_eq (fst M ! q) (fst M ! p) T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if tr_lookup T q p then True\n     else \\<not> check_eq (fst M ! q) (fst M ! p) T) =\n    (tr_lookup T q p \\<or> \\<not> check_eq (fst M ! q) (fst M ! p) T)", "by simp"], ["proof (state)\nthis:\n  (if tr_lookup T q p then True\n   else \\<not> check_eq (fst M ! q) (fst M ! p) T) =\n  (tr_lookup T q p \\<or> \\<not> check_eq (fst M ! q) (fst M ! p) T)\n\ngoal (1 subgoal):\n 1. tr_lookup (snd (iter M T)) q p =\n    (\\<exists>n<Suc m. dist_nodes M n v p q)", "also"], ["proof (state)\nthis:\n  (if tr_lookup T q p then True\n   else \\<not> check_eq (fst M ! q) (fst M ! p) T) =\n  (tr_lookup T q p \\<or> \\<not> check_eq (fst M ! q) (fst M ! p) T)\n\ngoal (1 subgoal):\n 1. tr_lookup (snd (iter M T)) q p =\n    (\\<exists>n<Suc m. dist_nodes M n v p q)", "from assms C"], ["proof (chain)\npicking this:\n  wf_tr M T\n  wf_dfa M v\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n  dfa_is_node M q\n  p < q\n  (\\<not> check_eq (fst M ! q) (fst M ! p) T) =\n  (\\<exists>n<m. dist_nodes M (Suc n) v p q)", "have \"\\<dots> = ((\\<exists>n<m. dist_nodes M n v p q) \\<or> (\\<exists>n<m. dist_nodes M (Suc n) v p q))\""], ["proof (prove)\nusing this:\n  wf_tr M T\n  wf_dfa M v\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n  dfa_is_node M q\n  p < q\n  (\\<not> check_eq (fst M ! q) (fst M ! p) T) =\n  (\\<exists>n<m. dist_nodes M (Suc n) v p q)\n\ngoal (1 subgoal):\n 1. (tr_lookup T q p \\<or> \\<not> check_eq (fst M ! q) (fst M ! p) T) =\n    ((\\<exists>n<m. dist_nodes M n v p q) \\<or>\n     (\\<exists>n<m. dist_nodes M (Suc n) v p q))", "by simp"], ["proof (state)\nthis:\n  (tr_lookup T q p \\<or> \\<not> check_eq (fst M ! q) (fst M ! p) T) =\n  ((\\<exists>n<m. dist_nodes M n v p q) \\<or>\n   (\\<exists>n<m. dist_nodes M (Suc n) v p q))\n\ngoal (1 subgoal):\n 1. tr_lookup (snd (iter M T)) q p =\n    (\\<exists>n<Suc m. dist_nodes M n v p q)", "also"], ["proof (state)\nthis:\n  (tr_lookup T q p \\<or> \\<not> check_eq (fst M ! q) (fst M ! p) T) =\n  ((\\<exists>n<m. dist_nodes M n v p q) \\<or>\n   (\\<exists>n<m. dist_nodes M (Suc n) v p q))\n\ngoal (1 subgoal):\n 1. tr_lookup (snd (iter M T)) q p =\n    (\\<exists>n<Suc m. dist_nodes M n v p q)", "have \"\\<dots> = (\\<exists>n < m. dist_nodes M n v p q \\<or> dist_nodes M (Suc n) v p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<exists>n<m. dist_nodes M n v p q) \\<or>\n     (\\<exists>n<m. dist_nodes M (Suc n) v p q)) =\n    (\\<exists>n<m. dist_nodes M n v p q \\<or> dist_nodes M (Suc n) v p q)", "by auto"], ["proof (state)\nthis:\n  ((\\<exists>n<m. dist_nodes M n v p q) \\<or>\n   (\\<exists>n<m. dist_nodes M (Suc n) v p q)) =\n  (\\<exists>n<m. dist_nodes M n v p q \\<or> dist_nodes M (Suc n) v p q)\n\ngoal (1 subgoal):\n 1. tr_lookup (snd (iter M T)) q p =\n    (\\<exists>n<Suc m. dist_nodes M n v p q)", "also"], ["proof (state)\nthis:\n  ((\\<exists>n<m. dist_nodes M n v p q) \\<or>\n   (\\<exists>n<m. dist_nodes M (Suc n) v p q)) =\n  (\\<exists>n<m. dist_nodes M n v p q \\<or> dist_nodes M (Suc n) v p q)\n\ngoal (1 subgoal):\n 1. tr_lookup (snd (iter M T)) q p =\n    (\\<exists>n<Suc m. dist_nodes M n v p q)", "have \"\\<dots> = (\\<exists>n < Suc m. dist_nodes M n v p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>n<m. dist_nodes M n v p q \\<or> dist_nodes M (Suc n) v p q) =\n    (\\<exists>n<Suc m. dist_nodes M n v p q)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>n<m.\n       dist_nodes M n v p q \\<or>\n       dist_nodes M (Suc n) v p q \\<Longrightarrow>\n    \\<exists>n<Suc m. dist_nodes M n v p q\n 2. \\<exists>n<Suc m. dist_nodes M n v p q \\<Longrightarrow>\n    \\<exists>n<m. dist_nodes M n v p q \\<or> dist_nodes M (Suc n) v p q", "assume \"\\<exists>n<m. dist_nodes M n v p q \\<or> dist_nodes M (Suc n) v p q\""], ["proof (state)\nthis:\n  \\<exists>n<m. dist_nodes M n v p q \\<or> dist_nodes M (Suc n) v p q\n\ngoal (2 subgoals):\n 1. \\<exists>n<m.\n       dist_nodes M n v p q \\<or>\n       dist_nodes M (Suc n) v p q \\<Longrightarrow>\n    \\<exists>n<Suc m. dist_nodes M n v p q\n 2. \\<exists>n<Suc m. dist_nodes M n v p q \\<Longrightarrow>\n    \\<exists>n<m. dist_nodes M n v p q \\<or> dist_nodes M (Suc n) v p q", "then"], ["proof (chain)\npicking this:\n  \\<exists>n<m. dist_nodes M n v p q \\<or> dist_nodes M (Suc n) v p q", "obtain n where D: \"dist_nodes M n v p q \\<or> dist_nodes M (Suc n) v p q\" and N: \"n < m\""], ["proof (prove)\nusing this:\n  \\<exists>n<m. dist_nodes M n v p q \\<or> dist_nodes M (Suc n) v p q\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>dist_nodes M n v p q \\<or> dist_nodes M (Suc n) v p q;\n         n < m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  dist_nodes M n v p q \\<or> dist_nodes M (Suc n) v p q\n  n < m\n\ngoal (2 subgoals):\n 1. \\<exists>n<m.\n       dist_nodes M n v p q \\<or>\n       dist_nodes M (Suc n) v p q \\<Longrightarrow>\n    \\<exists>n<Suc m. dist_nodes M n v p q\n 2. \\<exists>n<Suc m. dist_nodes M n v p q \\<Longrightarrow>\n    \\<exists>n<m. dist_nodes M n v p q \\<or> dist_nodes M (Suc n) v p q", "moreover"], ["proof (state)\nthis:\n  dist_nodes M n v p q \\<or> dist_nodes M (Suc n) v p q\n  n < m\n\ngoal (2 subgoals):\n 1. \\<exists>n<m.\n       dist_nodes M n v p q \\<or>\n       dist_nodes M (Suc n) v p q \\<Longrightarrow>\n    \\<exists>n<Suc m. dist_nodes M n v p q\n 2. \\<exists>n<Suc m. dist_nodes M n v p q \\<Longrightarrow>\n    \\<exists>n<m. dist_nodes M n v p q \\<or> dist_nodes M (Suc n) v p q", "from N"], ["proof (chain)\npicking this:\n  n < m", "have \"n < Suc m\""], ["proof (prove)\nusing this:\n  n < m\n\ngoal (1 subgoal):\n 1. n < Suc m", "by simp"], ["proof (state)\nthis:\n  n < Suc m\n\ngoal (2 subgoals):\n 1. \\<exists>n<m.\n       dist_nodes M n v p q \\<or>\n       dist_nodes M (Suc n) v p q \\<Longrightarrow>\n    \\<exists>n<Suc m. dist_nodes M n v p q\n 2. \\<exists>n<Suc m. dist_nodes M n v p q \\<Longrightarrow>\n    \\<exists>n<m. dist_nodes M n v p q \\<or> dist_nodes M (Suc n) v p q", "ultimately"], ["proof (chain)\npicking this:\n  dist_nodes M n v p q \\<or> dist_nodes M (Suc n) v p q\n  n < m\n  n < Suc m", "show \"\\<exists>n < Suc m. dist_nodes M n v p q\""], ["proof (prove)\nusing this:\n  dist_nodes M n v p q \\<or> dist_nodes M (Suc n) v p q\n  n < m\n  n < Suc m\n\ngoal (1 subgoal):\n 1. \\<exists>n<Suc m. dist_nodes M n v p q", "by (elim disjE) blast+"], ["proof (state)\nthis:\n  \\<exists>n<Suc m. dist_nodes M n v p q\n\ngoal (1 subgoal):\n 1. \\<exists>n<Suc m. dist_nodes M n v p q \\<Longrightarrow>\n    \\<exists>n<m. dist_nodes M n v p q \\<or> dist_nodes M (Suc n) v p q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n<Suc m. dist_nodes M n v p q \\<Longrightarrow>\n    \\<exists>n<m. dist_nodes M n v p q \\<or> dist_nodes M (Suc n) v p q", "assume \"\\<exists>n < Suc m. dist_nodes M n v p q\""], ["proof (state)\nthis:\n  \\<exists>n<Suc m. dist_nodes M n v p q\n\ngoal (1 subgoal):\n 1. \\<exists>n<Suc m. dist_nodes M n v p q \\<Longrightarrow>\n    \\<exists>n<m. dist_nodes M n v p q \\<or> dist_nodes M (Suc n) v p q", "then"], ["proof (chain)\npicking this:\n  \\<exists>n<Suc m. dist_nodes M n v p q", "obtain n where N: \"n < Suc m\" and D: \"dist_nodes M n v p q\""], ["proof (prove)\nusing this:\n  \\<exists>n<Suc m. dist_nodes M n v p q\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>n < Suc m; dist_nodes M n v p q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n < Suc m\n  dist_nodes M n v p q\n\ngoal (1 subgoal):\n 1. \\<exists>n<Suc m. dist_nodes M n v p q \\<Longrightarrow>\n    \\<exists>n<m. dist_nodes M n v p q \\<or> dist_nodes M (Suc n) v p q", "from N"], ["proof (chain)\npicking this:\n  n < Suc m", "have \"n < m \\<or> n = m\""], ["proof (prove)\nusing this:\n  n < Suc m\n\ngoal (1 subgoal):\n 1. n < m \\<or> n = m", "by auto"], ["proof (state)\nthis:\n  n < m \\<or> n = m\n\ngoal (1 subgoal):\n 1. \\<exists>n<Suc m. dist_nodes M n v p q \\<Longrightarrow>\n    \\<exists>n<m. dist_nodes M n v p q \\<or> dist_nodes M (Suc n) v p q", "from this D M'"], ["proof (chain)\npicking this:\n  n < m \\<or> n = m\n  dist_nodes M n v p q\n  m = Suc m'", "show \"\\<exists>n<m. dist_nodes M n v p q \\<or> dist_nodes M (Suc n) v p q\""], ["proof (prove)\nusing this:\n  n < m \\<or> n = m\n  dist_nodes M n v p q\n  m = Suc m'\n\ngoal (1 subgoal):\n 1. \\<exists>n<m. dist_nodes M n v p q \\<or> dist_nodes M (Suc n) v p q", "by auto"], ["proof (state)\nthis:\n  \\<exists>n<m. dist_nodes M n v p q \\<or> dist_nodes M (Suc n) v p q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>n<m. dist_nodes M n v p q \\<or> dist_nodes M (Suc n) v p q) =\n  (\\<exists>n<Suc m. dist_nodes M n v p q)\n\ngoal (1 subgoal):\n 1. tr_lookup (snd (iter M T)) q p =\n    (\\<exists>n<Suc m. dist_nodes M n v p q)", "finally"], ["proof (chain)\npicking this:\n  tr_lookup (snd (iter M T)) q p = (\\<exists>n<Suc m. dist_nodes M n v p q)", "show ?thesis"], ["proof (prove)\nusing this:\n  tr_lookup (snd (iter M T)) q p = (\\<exists>n<Suc m. dist_nodes M n v p q)\n\ngoal (1 subgoal):\n 1. tr_lookup (snd (iter M T)) q p =\n    (\\<exists>n<Suc m. dist_nodes M n v p q)", "by simp"], ["proof (state)\nthis:\n  tr_lookup (snd (iter M T)) q p = (\\<exists>n<Suc m. dist_nodes M n v p q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fixpt_dist_nodes':\n  assumes \"wf_tr M T\" and \"wf_dfa M v\"\n  and \"\\<forall>p q. dfa_is_node M q \\<and> p < q \\<longrightarrow> tr_lookup T q p = (\\<exists>n < m. dist_nodes M n v p q)\" and \"m > 0\"\n  and \"dfa_is_node M q\" and \"p < q\"\n  shows \"tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)", "using assms"], ["proof (prove)\nusing this:\n  wf_tr M T\n  wf_dfa M v\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n  dfa_is_node M q\n  p < q\n\ngoal (1 subgoal):\n 1. tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)", "proof (induct M T arbitrary: m rule: fixpt_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M T m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>fst (iter M T); wf_tr M (snd (iter M T));\n                    wf_dfa M v;\n                    \\<forall>p q.\n                       dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                       tr_lookup (snd (iter M T)) q p =\n                       (\\<exists>n<m. dist_nodes M n v p q);\n                    0 < m; dfa_is_node M q; p < q\\<rbrakk>\n                   \\<Longrightarrow> tr_lookup (fixpt M (snd (iter M T))) q\np =\n                                     (\\<exists>n. dist_nodes M n v p q);\n        wf_tr M T; wf_dfa M v;\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; dfa_is_node M q; p < q\\<rbrakk>\n       \\<Longrightarrow> tr_lookup (fixpt M T) q p =\n                         (\\<exists>n. dist_nodes M n v p q)", "case (1 M T m)"], ["proof (state)\nthis:\n  \\<lbrakk>fst (iter M T); wf_tr M (snd (iter M T)); wf_dfa M v;\n   \\<forall>p q.\n      dfa_is_node M q \\<and> p < q \\<longrightarrow>\n      tr_lookup (snd (iter M T)) q p =\n      (\\<exists>n<?m. dist_nodes M n v p q);\n   0 < ?m; dfa_is_node M q; p < q\\<rbrakk>\n  \\<Longrightarrow> tr_lookup (fixpt M (snd (iter M T))) q p =\n                    (\\<exists>n. dist_nodes M n v p q)\n  wf_tr M T\n  wf_dfa M v\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n  dfa_is_node M q\n  p < q\n\ngoal (1 subgoal):\n 1. \\<And>M T m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>fst (iter M T); wf_tr M (snd (iter M T));\n                    wf_dfa M v;\n                    \\<forall>p q.\n                       dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                       tr_lookup (snd (iter M T)) q p =\n                       (\\<exists>n<m. dist_nodes M n v p q);\n                    0 < m; dfa_is_node M q; p < q\\<rbrakk>\n                   \\<Longrightarrow> tr_lookup (fixpt M (snd (iter M T))) q\np =\n                                     (\\<exists>n. dist_nodes M n v p q);\n        wf_tr M T; wf_dfa M v;\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; dfa_is_node M q; p < q\\<rbrakk>\n       \\<Longrightarrow> tr_lookup (fixpt M T) q p =\n                         (\\<exists>n. dist_nodes M n v p q)", "let ?T = \"snd (iter M T)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M T m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>fst (iter M T); wf_tr M (snd (iter M T));\n                    wf_dfa M v;\n                    \\<forall>p q.\n                       dfa_is_node M q \\<and> p < q \\<longrightarrow>\n                       tr_lookup (snd (iter M T)) q p =\n                       (\\<exists>n<m. dist_nodes M n v p q);\n                    0 < m; dfa_is_node M q; p < q\\<rbrakk>\n                   \\<Longrightarrow> tr_lookup (fixpt M (snd (iter M T))) q\np =\n                                     (\\<exists>n. dist_nodes M n v p q);\n        wf_tr M T; wf_dfa M v;\n        \\<forall>p q.\n           dfa_is_node M q \\<and> p < q \\<longrightarrow>\n           tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q);\n        0 < m; dfa_is_node M q; p < q\\<rbrakk>\n       \\<Longrightarrow> tr_lookup (fixpt M T) q p =\n                         (\\<exists>n. dist_nodes M n v p q)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)", "proof (cases \"fst (iter M T)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. fst (iter M T) \\<Longrightarrow>\n    tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)\n 2. \\<not> fst (iter M T) \\<Longrightarrow>\n    tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)", "case True"], ["proof (state)\nthis:\n  fst (iter M T)\n\ngoal (2 subgoals):\n 1. fst (iter M T) \\<Longrightarrow>\n    tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)\n 2. \\<not> fst (iter M T) \\<Longrightarrow>\n    tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)", "{"], ["proof (state)\nthis:\n  fst (iter M T)\n\ngoal (2 subgoals):\n 1. fst (iter M T) \\<Longrightarrow>\n    tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)\n 2. \\<not> fst (iter M T) \\<Longrightarrow>\n    tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)", "fix p' q'"], ["proof (state)\ngoal (2 subgoals):\n 1. fst (iter M T) \\<Longrightarrow>\n    tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)\n 2. \\<not> fst (iter M T) \\<Longrightarrow>\n    tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)", "assume H: \"dfa_is_node M q' \\<and> p' < q'\""], ["proof (state)\nthis:\n  dfa_is_node M q' \\<and> p' < q'\n\ngoal (2 subgoals):\n 1. fst (iter M T) \\<Longrightarrow>\n    tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)\n 2. \\<not> fst (iter M T) \\<Longrightarrow>\n    tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)", "with 1"], ["proof (chain)\npicking this:\n  \\<lbrakk>fst (iter M T); wf_tr M (snd (iter M T)); wf_dfa M v;\n   \\<forall>p q.\n      dfa_is_node M q \\<and> p < q \\<longrightarrow>\n      tr_lookup (snd (iter M T)) q p =\n      (\\<exists>n<?m. dist_nodes M n v p q);\n   0 < ?m; dfa_is_node M q; p < q\\<rbrakk>\n  \\<Longrightarrow> tr_lookup (fixpt M (snd (iter M T))) q p =\n                    (\\<exists>n. dist_nodes M n v p q)\n  wf_tr M T\n  wf_dfa M v\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n  dfa_is_node M q\n  p < q\n  dfa_is_node M q' \\<and> p' < q'", "have \"tr_lookup ?T q' p' = (\\<exists>n < Suc m. dist_nodes M n v p' q')\""], ["proof (prove)\nusing this:\n  \\<lbrakk>fst (iter M T); wf_tr M (snd (iter M T)); wf_dfa M v;\n   \\<forall>p q.\n      dfa_is_node M q \\<and> p < q \\<longrightarrow>\n      tr_lookup (snd (iter M T)) q p =\n      (\\<exists>n<?m. dist_nodes M n v p q);\n   0 < ?m; dfa_is_node M q; p < q\\<rbrakk>\n  \\<Longrightarrow> tr_lookup (fixpt M (snd (iter M T))) q p =\n                    (\\<exists>n. dist_nodes M n v p q)\n  wf_tr M T\n  wf_dfa M v\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n  dfa_is_node M q\n  p < q\n  dfa_is_node M q' \\<and> p' < q'\n\ngoal (1 subgoal):\n 1. tr_lookup (snd (iter M T)) q' p' =\n    (\\<exists>n<Suc m. dist_nodes M n v p' q')", "by (simp only: iter_dist_nodes)"], ["proof (state)\nthis:\n  tr_lookup (snd (iter M T)) q' p' =\n  (\\<exists>n<Suc m. dist_nodes M n v p' q')\n\ngoal (2 subgoals):\n 1. fst (iter M T) \\<Longrightarrow>\n    tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)\n 2. \\<not> fst (iter M T) \\<Longrightarrow>\n    tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)", "}"], ["proof (state)\nthis:\n  dfa_is_node M ?q'2 \\<and> ?p'2 < ?q'2 \\<Longrightarrow>\n  tr_lookup (snd (iter M T)) ?q'2 ?p'2 =\n  (\\<exists>n<Suc m. dist_nodes M n v ?p'2 ?q'2)\n\ngoal (2 subgoals):\n 1. fst (iter M T) \\<Longrightarrow>\n    tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)\n 2. \\<not> fst (iter M T) \\<Longrightarrow>\n    tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)", "hence 2: \"\\<forall>p q. dfa_is_node M q \\<and> p < q \\<longrightarrow> tr_lookup ?T q p = (\\<exists>n < Suc m. dist_nodes M n v p q)\""], ["proof (prove)\nusing this:\n  dfa_is_node M ?q'2 \\<and> ?p'2 < ?q'2 \\<Longrightarrow>\n  tr_lookup (snd (iter M T)) ?q'2 ?p'2 =\n  (\\<exists>n<Suc m. dist_nodes M n v ?p'2 ?q'2)\n\ngoal (1 subgoal):\n 1. \\<forall>p q.\n       dfa_is_node M q \\<and> p < q \\<longrightarrow>\n       tr_lookup (snd (iter M T)) q p =\n       (\\<exists>n<Suc m. dist_nodes M n v p q)", "by simp"], ["proof (state)\nthis:\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup (snd (iter M T)) q p =\n     (\\<exists>n<Suc m. dist_nodes M n v p q)\n\ngoal (2 subgoals):\n 1. fst (iter M T) \\<Longrightarrow>\n    tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)\n 2. \\<not> fst (iter M T) \\<Longrightarrow>\n    tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)", "moreover"], ["proof (state)\nthis:\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup (snd (iter M T)) q p =\n     (\\<exists>n<Suc m. dist_nodes M n v p q)\n\ngoal (2 subgoals):\n 1. fst (iter M T) \\<Longrightarrow>\n    tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)\n 2. \\<not> fst (iter M T) \\<Longrightarrow>\n    tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)", "from 1"], ["proof (chain)\npicking this:\n  \\<lbrakk>fst (iter M T); wf_tr M (snd (iter M T)); wf_dfa M v;\n   \\<forall>p q.\n      dfa_is_node M q \\<and> p < q \\<longrightarrow>\n      tr_lookup (snd (iter M T)) q p =\n      (\\<exists>n<?m. dist_nodes M n v p q);\n   0 < ?m; dfa_is_node M q; p < q\\<rbrakk>\n  \\<Longrightarrow> tr_lookup (fixpt M (snd (iter M T))) q p =\n                    (\\<exists>n. dist_nodes M n v p q)\n  wf_tr M T\n  wf_dfa M v\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n  dfa_is_node M q\n  p < q", "have \"wf_tr M ?T\""], ["proof (prove)\nusing this:\n  \\<lbrakk>fst (iter M T); wf_tr M (snd (iter M T)); wf_dfa M v;\n   \\<forall>p q.\n      dfa_is_node M q \\<and> p < q \\<longrightarrow>\n      tr_lookup (snd (iter M T)) q p =\n      (\\<exists>n<?m. dist_nodes M n v p q);\n   0 < ?m; dfa_is_node M q; p < q\\<rbrakk>\n  \\<Longrightarrow> tr_lookup (fixpt M (snd (iter M T))) q p =\n                    (\\<exists>n. dist_nodes M n v p q)\n  wf_tr M T\n  wf_dfa M v\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n  dfa_is_node M q\n  p < q\n\ngoal (1 subgoal):\n 1. wf_tr M (snd (iter M T))", "by (simp add: iter_wf)"], ["proof (state)\nthis:\n  wf_tr M (snd (iter M T))\n\ngoal (2 subgoals):\n 1. fst (iter M T) \\<Longrightarrow>\n    tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)\n 2. \\<not> fst (iter M T) \\<Longrightarrow>\n    tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)", "moreover"], ["proof (state)\nthis:\n  wf_tr M (snd (iter M T))\n\ngoal (2 subgoals):\n 1. fst (iter M T) \\<Longrightarrow>\n    tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)\n 2. \\<not> fst (iter M T) \\<Longrightarrow>\n    tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)", "note 1(3,6,7) 1(1)[of \"Suc m\"] True"], ["proof (state)\nthis:\n  wf_dfa M v\n  dfa_is_node M q\n  p < q\n  \\<lbrakk>fst (iter M T); wf_tr M (snd (iter M T)); wf_dfa M v;\n   \\<forall>p q.\n      dfa_is_node M q \\<and> p < q \\<longrightarrow>\n      tr_lookup (snd (iter M T)) q p =\n      (\\<exists>n<Suc m. dist_nodes M n v p q);\n   0 < Suc m; dfa_is_node M q; p < q\\<rbrakk>\n  \\<Longrightarrow> tr_lookup (fixpt M (snd (iter M T))) q p =\n                    (\\<exists>n. dist_nodes M n v p q)\n  fst (iter M T)\n\ngoal (2 subgoals):\n 1. fst (iter M T) \\<Longrightarrow>\n    tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)\n 2. \\<not> fst (iter M T) \\<Longrightarrow>\n    tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup (snd (iter M T)) q p =\n     (\\<exists>n<Suc m. dist_nodes M n v p q)\n  wf_tr M (snd (iter M T))\n  wf_dfa M v\n  dfa_is_node M q\n  p < q\n  \\<lbrakk>fst (iter M T); wf_tr M (snd (iter M T)); wf_dfa M v;\n   \\<forall>p q.\n      dfa_is_node M q \\<and> p < q \\<longrightarrow>\n      tr_lookup (snd (iter M T)) q p =\n      (\\<exists>n<Suc m. dist_nodes M n v p q);\n   0 < Suc m; dfa_is_node M q; p < q\\<rbrakk>\n  \\<Longrightarrow> tr_lookup (fixpt M (snd (iter M T))) q p =\n                    (\\<exists>n. dist_nodes M n v p q)\n  fst (iter M T)", "have \"tr_lookup (fixpt M ?T) q p = (\\<exists>n. dist_nodes M n v p q)\""], ["proof (prove)\nusing this:\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup (snd (iter M T)) q p =\n     (\\<exists>n<Suc m. dist_nodes M n v p q)\n  wf_tr M (snd (iter M T))\n  wf_dfa M v\n  dfa_is_node M q\n  p < q\n  \\<lbrakk>fst (iter M T); wf_tr M (snd (iter M T)); wf_dfa M v;\n   \\<forall>p q.\n      dfa_is_node M q \\<and> p < q \\<longrightarrow>\n      tr_lookup (snd (iter M T)) q p =\n      (\\<exists>n<Suc m. dist_nodes M n v p q);\n   0 < Suc m; dfa_is_node M q; p < q\\<rbrakk>\n  \\<Longrightarrow> tr_lookup (fixpt M (snd (iter M T))) q p =\n                    (\\<exists>n. dist_nodes M n v p q)\n  fst (iter M T)\n\ngoal (1 subgoal):\n 1. tr_lookup (fixpt M (snd (iter M T))) q p =\n    (\\<exists>n. dist_nodes M n v p q)", "by simp"], ["proof (state)\nthis:\n  tr_lookup (fixpt M (snd (iter M T))) q p =\n  (\\<exists>n. dist_nodes M n v p q)\n\ngoal (2 subgoals):\n 1. fst (iter M T) \\<Longrightarrow>\n    tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)\n 2. \\<not> fst (iter M T) \\<Longrightarrow>\n    tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)", "with True"], ["proof (chain)\npicking this:\n  fst (iter M T)\n  tr_lookup (fixpt M (snd (iter M T))) q p =\n  (\\<exists>n. dist_nodes M n v p q)", "show ?thesis"], ["proof (prove)\nusing this:\n  fst (iter M T)\n  tr_lookup (fixpt M (snd (iter M T))) q p =\n  (\\<exists>n. dist_nodes M n v p q)\n\ngoal (1 subgoal):\n 1. tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)", "by (simp add: Let_def split_beta)"], ["proof (state)\nthis:\n  tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)\n\ngoal (1 subgoal):\n 1. \\<not> fst (iter M T) \\<Longrightarrow>\n    tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> fst (iter M T) \\<Longrightarrow>\n    tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)", "case False"], ["proof (state)\nthis:\n  \\<not> fst (iter M T)\n\ngoal (1 subgoal):\n 1. \\<not> fst (iter M T) \\<Longrightarrow>\n    tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)", "then"], ["proof (chain)\npicking this:\n  \\<not> fst (iter M T)", "have F: \"snd (iter M T) = T\""], ["proof (prove)\nusing this:\n  \\<not> fst (iter M T)\n\ngoal (1 subgoal):\n 1. snd (iter M T) = T", "by (simp add: iter_def fold_map_idx_fst_snd_eq split_beta)"], ["proof (state)\nthis:\n  snd (iter M T) = T\n\ngoal (1 subgoal):\n 1. \\<not> fst (iter M T) \\<Longrightarrow>\n    tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)", "have C: \"\\<And>m'. \\<forall>p q. dfa_is_node M q \\<and> p < q \\<longrightarrow> tr_lookup T q p = (\\<exists>n < m' + m. dist_nodes M n v p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m'.\n       \\<forall>p q.\n          dfa_is_node M q \\<and> p < q \\<longrightarrow>\n          tr_lookup T q p = (\\<exists>n<m' + m. dist_nodes M n v p q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m'.\n       \\<forall>p q.\n          dfa_is_node M q \\<and> p < q \\<longrightarrow>\n          tr_lookup T q p = (\\<exists>n<m' + m. dist_nodes M n v p q)", "fix m'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m'.\n       \\<forall>p q.\n          dfa_is_node M q \\<and> p < q \\<longrightarrow>\n          tr_lookup T q p = (\\<exists>n<m' + m. dist_nodes M n v p q)", "show \"\\<forall>p q. dfa_is_node M q \\<and> p < q \\<longrightarrow> tr_lookup T q p = (\\<exists>n < m' + m. dist_nodes M n v p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p q.\n       dfa_is_node M q \\<and> p < q \\<longrightarrow>\n       tr_lookup T q p = (\\<exists>n<m' + m. dist_nodes M n v p q)", "proof (induct m')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>p q.\n       dfa_is_node M q \\<and> p < q \\<longrightarrow>\n       tr_lookup T q p = (\\<exists>n<0 + m. dist_nodes M n v p q)\n 2. \\<And>m'.\n       \\<forall>p q.\n          dfa_is_node M q \\<and> p < q \\<longrightarrow>\n          tr_lookup T q p =\n          (\\<exists>n<m' + m. dist_nodes M n v p q) \\<Longrightarrow>\n       \\<forall>p q.\n          dfa_is_node M q \\<and> p < q \\<longrightarrow>\n          tr_lookup T q p = (\\<exists>n<Suc m' + m. dist_nodes M n v p q)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<forall>p q.\n       dfa_is_node M q \\<and> p < q \\<longrightarrow>\n       tr_lookup T q p = (\\<exists>n<0 + m. dist_nodes M n v p q)\n 2. \\<And>m'.\n       \\<forall>p q.\n          dfa_is_node M q \\<and> p < q \\<longrightarrow>\n          tr_lookup T q p =\n          (\\<exists>n<m' + m. dist_nodes M n v p q) \\<Longrightarrow>\n       \\<forall>p q.\n          dfa_is_node M q \\<and> p < q \\<longrightarrow>\n          tr_lookup T q p = (\\<exists>n<Suc m' + m. dist_nodes M n v p q)", "with 1"], ["proof (chain)\npicking this:\n  \\<lbrakk>fst (iter M T); wf_tr M (snd (iter M T)); wf_dfa M v;\n   \\<forall>p q.\n      dfa_is_node M q \\<and> p < q \\<longrightarrow>\n      tr_lookup (snd (iter M T)) q p =\n      (\\<exists>n<?m. dist_nodes M n v p q);\n   0 < ?m; dfa_is_node M q; p < q\\<rbrakk>\n  \\<Longrightarrow> tr_lookup (fixpt M (snd (iter M T))) q p =\n                    (\\<exists>n. dist_nodes M n v p q)\n  wf_tr M T\n  wf_dfa M v\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n  dfa_is_node M q\n  p < q", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>fst (iter M T); wf_tr M (snd (iter M T)); wf_dfa M v;\n   \\<forall>p q.\n      dfa_is_node M q \\<and> p < q \\<longrightarrow>\n      tr_lookup (snd (iter M T)) q p =\n      (\\<exists>n<?m. dist_nodes M n v p q);\n   0 < ?m; dfa_is_node M q; p < q\\<rbrakk>\n  \\<Longrightarrow> tr_lookup (fixpt M (snd (iter M T))) q p =\n                    (\\<exists>n. dist_nodes M n v p q)\n  wf_tr M T\n  wf_dfa M v\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n  dfa_is_node M q\n  p < q\n\ngoal (1 subgoal):\n 1. \\<forall>p q.\n       dfa_is_node M q \\<and> p < q \\<longrightarrow>\n       tr_lookup T q p = (\\<exists>n<0 + m. dist_nodes M n v p q)", "by simp"], ["proof (state)\nthis:\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<0 + m. dist_nodes M n v p q)\n\ngoal (1 subgoal):\n 1. \\<And>m'.\n       \\<forall>p q.\n          dfa_is_node M q \\<and> p < q \\<longrightarrow>\n          tr_lookup T q p =\n          (\\<exists>n<m' + m. dist_nodes M n v p q) \\<Longrightarrow>\n       \\<forall>p q.\n          dfa_is_node M q \\<and> p < q \\<longrightarrow>\n          tr_lookup T q p = (\\<exists>n<Suc m' + m. dist_nodes M n v p q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m'.\n       \\<forall>p q.\n          dfa_is_node M q \\<and> p < q \\<longrightarrow>\n          tr_lookup T q p =\n          (\\<exists>n<m' + m. dist_nodes M n v p q) \\<Longrightarrow>\n       \\<forall>p q.\n          dfa_is_node M q \\<and> p < q \\<longrightarrow>\n          tr_lookup T q p = (\\<exists>n<Suc m' + m. dist_nodes M n v p q)", "case (Suc m')"], ["proof (state)\nthis:\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m' + m. dist_nodes M n v p q)\n\ngoal (1 subgoal):\n 1. \\<And>m'.\n       \\<forall>p q.\n          dfa_is_node M q \\<and> p < q \\<longrightarrow>\n          tr_lookup T q p =\n          (\\<exists>n<m' + m. dist_nodes M n v p q) \\<Longrightarrow>\n       \\<forall>p q.\n          dfa_is_node M q \\<and> p < q \\<longrightarrow>\n          tr_lookup T q p = (\\<exists>n<Suc m' + m. dist_nodes M n v p q)", "{"], ["proof (state)\nthis:\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m' + m. dist_nodes M n v p q)\n\ngoal (1 subgoal):\n 1. \\<And>m'.\n       \\<forall>p q.\n          dfa_is_node M q \\<and> p < q \\<longrightarrow>\n          tr_lookup T q p =\n          (\\<exists>n<m' + m. dist_nodes M n v p q) \\<Longrightarrow>\n       \\<forall>p q.\n          dfa_is_node M q \\<and> p < q \\<longrightarrow>\n          tr_lookup T q p = (\\<exists>n<Suc m' + m. dist_nodes M n v p q)", "fix p' q'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m'.\n       \\<forall>p q.\n          dfa_is_node M q \\<and> p < q \\<longrightarrow>\n          tr_lookup T q p =\n          (\\<exists>n<m' + m. dist_nodes M n v p q) \\<Longrightarrow>\n       \\<forall>p q.\n          dfa_is_node M q \\<and> p < q \\<longrightarrow>\n          tr_lookup T q p = (\\<exists>n<Suc m' + m. dist_nodes M n v p q)", "assume H: \"dfa_is_node M q'\" and H2: \"p' < q'\""], ["proof (state)\nthis:\n  dfa_is_node M q'\n  p' < q'\n\ngoal (1 subgoal):\n 1. \\<And>m'.\n       \\<forall>p q.\n          dfa_is_node M q \\<and> p < q \\<longrightarrow>\n          tr_lookup T q p =\n          (\\<exists>n<m' + m. dist_nodes M n v p q) \\<Longrightarrow>\n       \\<forall>p q.\n          dfa_is_node M q \\<and> p < q \\<longrightarrow>\n          tr_lookup T q p = (\\<exists>n<Suc m' + m. dist_nodes M n v p q)", "note 1(2,3) Suc"], ["proof (state)\nthis:\n  wf_tr M T\n  wf_dfa M v\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m' + m. dist_nodes M n v p q)\n\ngoal (1 subgoal):\n 1. \\<And>m'.\n       \\<forall>p q.\n          dfa_is_node M q \\<and> p < q \\<longrightarrow>\n          tr_lookup T q p =\n          (\\<exists>n<m' + m. dist_nodes M n v p q) \\<Longrightarrow>\n       \\<forall>p q.\n          dfa_is_node M q \\<and> p < q \\<longrightarrow>\n          tr_lookup T q p = (\\<exists>n<Suc m' + m. dist_nodes M n v p q)", "moreover"], ["proof (state)\nthis:\n  wf_tr M T\n  wf_dfa M v\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m' + m. dist_nodes M n v p q)\n\ngoal (1 subgoal):\n 1. \\<And>m'.\n       \\<forall>p q.\n          dfa_is_node M q \\<and> p < q \\<longrightarrow>\n          tr_lookup T q p =\n          (\\<exists>n<m' + m. dist_nodes M n v p q) \\<Longrightarrow>\n       \\<forall>p q.\n          dfa_is_node M q \\<and> p < q \\<longrightarrow>\n          tr_lookup T q p = (\\<exists>n<Suc m' + m. dist_nodes M n v p q)", "from Suc 1"], ["proof (chain)\npicking this:\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m' + m. dist_nodes M n v p q)\n  \\<lbrakk>fst (iter M T); wf_tr M (snd (iter M T)); wf_dfa M v;\n   \\<forall>p q.\n      dfa_is_node M q \\<and> p < q \\<longrightarrow>\n      tr_lookup (snd (iter M T)) q p =\n      (\\<exists>n<?m. dist_nodes M n v p q);\n   0 < ?m; dfa_is_node M q; p < q\\<rbrakk>\n  \\<Longrightarrow> tr_lookup (fixpt M (snd (iter M T))) q p =\n                    (\\<exists>n. dist_nodes M n v p q)\n  wf_tr M T\n  wf_dfa M v\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n  dfa_is_node M q\n  p < q", "have \"0 < m' + m\""], ["proof (prove)\nusing this:\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m' + m. dist_nodes M n v p q)\n  \\<lbrakk>fst (iter M T); wf_tr M (snd (iter M T)); wf_dfa M v;\n   \\<forall>p q.\n      dfa_is_node M q \\<and> p < q \\<longrightarrow>\n      tr_lookup (snd (iter M T)) q p =\n      (\\<exists>n<?m. dist_nodes M n v p q);\n   0 < ?m; dfa_is_node M q; p < q\\<rbrakk>\n  \\<Longrightarrow> tr_lookup (fixpt M (snd (iter M T))) q p =\n                    (\\<exists>n. dist_nodes M n v p q)\n  wf_tr M T\n  wf_dfa M v\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m. dist_nodes M n v p q)\n  0 < m\n  dfa_is_node M q\n  p < q\n\ngoal (1 subgoal):\n 1. 0 < m' + m", "by simp"], ["proof (state)\nthis:\n  0 < m' + m\n\ngoal (1 subgoal):\n 1. \\<And>m'.\n       \\<forall>p q.\n          dfa_is_node M q \\<and> p < q \\<longrightarrow>\n          tr_lookup T q p =\n          (\\<exists>n<m' + m. dist_nodes M n v p q) \\<Longrightarrow>\n       \\<forall>p q.\n          dfa_is_node M q \\<and> p < q \\<longrightarrow>\n          tr_lookup T q p = (\\<exists>n<Suc m' + m. dist_nodes M n v p q)", "moreover"], ["proof (state)\nthis:\n  0 < m' + m\n\ngoal (1 subgoal):\n 1. \\<And>m'.\n       \\<forall>p q.\n          dfa_is_node M q \\<and> p < q \\<longrightarrow>\n          tr_lookup T q p =\n          (\\<exists>n<m' + m. dist_nodes M n v p q) \\<Longrightarrow>\n       \\<forall>p q.\n          dfa_is_node M q \\<and> p < q \\<longrightarrow>\n          tr_lookup T q p = (\\<exists>n<Suc m' + m. dist_nodes M n v p q)", "note H H2"], ["proof (state)\nthis:\n  dfa_is_node M q'\n  p' < q'\n\ngoal (1 subgoal):\n 1. \\<And>m'.\n       \\<forall>p q.\n          dfa_is_node M q \\<and> p < q \\<longrightarrow>\n          tr_lookup T q p =\n          (\\<exists>n<m' + m. dist_nodes M n v p q) \\<Longrightarrow>\n       \\<forall>p q.\n          dfa_is_node M q \\<and> p < q \\<longrightarrow>\n          tr_lookup T q p = (\\<exists>n<Suc m' + m. dist_nodes M n v p q)", "ultimately"], ["proof (chain)\npicking this:\n  wf_tr M T\n  wf_dfa M v\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m' + m. dist_nodes M n v p q)\n  0 < m' + m\n  dfa_is_node M q'\n  p' < q'", "have \"tr_lookup (snd (iter M T)) q' p' = (\\<exists>n < Suc (m' + m). dist_nodes M n v p' q')\""], ["proof (prove)\nusing this:\n  wf_tr M T\n  wf_dfa M v\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m' + m. dist_nodes M n v p q)\n  0 < m' + m\n  dfa_is_node M q'\n  p' < q'\n\ngoal (1 subgoal):\n 1. tr_lookup (snd (iter M T)) q' p' =\n    (\\<exists>n<Suc (m' + m). dist_nodes M n v p' q')", "by (rule iter_dist_nodes)"], ["proof (state)\nthis:\n  tr_lookup (snd (iter M T)) q' p' =\n  (\\<exists>n<Suc (m' + m). dist_nodes M n v p' q')\n\ngoal (1 subgoal):\n 1. \\<And>m'.\n       \\<forall>p q.\n          dfa_is_node M q \\<and> p < q \\<longrightarrow>\n          tr_lookup T q p =\n          (\\<exists>n<m' + m. dist_nodes M n v p q) \\<Longrightarrow>\n       \\<forall>p q.\n          dfa_is_node M q \\<and> p < q \\<longrightarrow>\n          tr_lookup T q p = (\\<exists>n<Suc m' + m. dist_nodes M n v p q)", "with F"], ["proof (chain)\npicking this:\n  snd (iter M T) = T\n  tr_lookup (snd (iter M T)) q' p' =\n  (\\<exists>n<Suc (m' + m). dist_nodes M n v p' q')", "have \"tr_lookup T q' p' = (\\<exists>n < Suc m' + m. dist_nodes M n v p' q')\""], ["proof (prove)\nusing this:\n  snd (iter M T) = T\n  tr_lookup (snd (iter M T)) q' p' =\n  (\\<exists>n<Suc (m' + m). dist_nodes M n v p' q')\n\ngoal (1 subgoal):\n 1. tr_lookup T q' p' = (\\<exists>n<Suc m' + m. dist_nodes M n v p' q')", "by simp"], ["proof (state)\nthis:\n  tr_lookup T q' p' = (\\<exists>n<Suc m' + m. dist_nodes M n v p' q')\n\ngoal (1 subgoal):\n 1. \\<And>m'.\n       \\<forall>p q.\n          dfa_is_node M q \\<and> p < q \\<longrightarrow>\n          tr_lookup T q p =\n          (\\<exists>n<m' + m. dist_nodes M n v p q) \\<Longrightarrow>\n       \\<forall>p q.\n          dfa_is_node M q \\<and> p < q \\<longrightarrow>\n          tr_lookup T q p = (\\<exists>n<Suc m' + m. dist_nodes M n v p q)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>dfa_is_node M ?q'2; ?p'2 < ?q'2\\<rbrakk>\n  \\<Longrightarrow> tr_lookup T ?q'2 ?p'2 =\n                    (\\<exists>n<Suc m' + m. dist_nodes M n v ?p'2 ?q'2)\n\ngoal (1 subgoal):\n 1. \\<And>m'.\n       \\<forall>p q.\n          dfa_is_node M q \\<and> p < q \\<longrightarrow>\n          tr_lookup T q p =\n          (\\<exists>n<m' + m. dist_nodes M n v p q) \\<Longrightarrow>\n       \\<forall>p q.\n          dfa_is_node M q \\<and> p < q \\<longrightarrow>\n          tr_lookup T q p = (\\<exists>n<Suc m' + m. dist_nodes M n v p q)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>dfa_is_node M ?q'2; ?p'2 < ?q'2\\<rbrakk>\n  \\<Longrightarrow> tr_lookup T ?q'2 ?p'2 =\n                    (\\<exists>n<Suc m' + m. dist_nodes M n v ?p'2 ?q'2)\n\ngoal (1 subgoal):\n 1. \\<forall>p q.\n       dfa_is_node M q \\<and> p < q \\<longrightarrow>\n       tr_lookup T q p = (\\<exists>n<Suc m' + m. dist_nodes M n v p q)", "by simp"], ["proof (state)\nthis:\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<Suc m' + m. dist_nodes M n v p q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<m' + m. dist_nodes M n v p q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<?m' + m. dist_nodes M n v p q)\n\ngoal (1 subgoal):\n 1. \\<not> fst (iter M T) \\<Longrightarrow>\n    tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)", "{"], ["proof (state)\nthis:\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<?m' + m. dist_nodes M n v p q)\n\ngoal (1 subgoal):\n 1. \\<not> fst (iter M T) \\<Longrightarrow>\n    tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)", "fix p' q'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> fst (iter M T) \\<Longrightarrow>\n    tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)", "assume H: \"dfa_is_node M q' \\<and> p' < q'\""], ["proof (state)\nthis:\n  dfa_is_node M q' \\<and> p' < q'\n\ngoal (1 subgoal):\n 1. \\<not> fst (iter M T) \\<Longrightarrow>\n    tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)", "have \"tr_lookup T q' p' = (\\<exists>n. dist_nodes M n v p' q')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tr_lookup T q' p' = (\\<exists>n. dist_nodes M n v p' q')", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. tr_lookup T q' p' \\<Longrightarrow> \\<exists>n. dist_nodes M n v p' q'\n 2. \\<exists>n. dist_nodes M n v p' q' \\<Longrightarrow> tr_lookup T q' p'", "assume \"tr_lookup T q' p'\""], ["proof (state)\nthis:\n  tr_lookup T q' p'\n\ngoal (2 subgoals):\n 1. tr_lookup T q' p' \\<Longrightarrow> \\<exists>n. dist_nodes M n v p' q'\n 2. \\<exists>n. dist_nodes M n v p' q' \\<Longrightarrow> tr_lookup T q' p'", "with H C[of 0]"], ["proof (chain)\npicking this:\n  dfa_is_node M q' \\<and> p' < q'\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<0 + m. dist_nodes M n v p q)\n  tr_lookup T q' p'", "show \"\\<exists>n. dist_nodes M n v p' q'\""], ["proof (prove)\nusing this:\n  dfa_is_node M q' \\<and> p' < q'\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n<0 + m. dist_nodes M n v p q)\n  tr_lookup T q' p'\n\ngoal (1 subgoal):\n 1. \\<exists>n. dist_nodes M n v p' q'", "by auto"], ["proof (state)\nthis:\n  \\<exists>n. dist_nodes M n v p' q'\n\ngoal (1 subgoal):\n 1. \\<exists>n. dist_nodes M n v p' q' \\<Longrightarrow> tr_lookup T q' p'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n. dist_nodes M n v p' q' \\<Longrightarrow> tr_lookup T q' p'", "assume H': \"\\<exists>n. dist_nodes M n v p' q'\""], ["proof (state)\nthis:\n  \\<exists>n. dist_nodes M n v p' q'\n\ngoal (1 subgoal):\n 1. \\<exists>n. dist_nodes M n v p' q' \\<Longrightarrow> tr_lookup T q' p'", "then"], ["proof (chain)\npicking this:\n  \\<exists>n. dist_nodes M n v p' q'", "obtain n where \"dist_nodes M n v p' q'\""], ["proof (prove)\nusing this:\n  \\<exists>n. dist_nodes M n v p' q'\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        dist_nodes M n v p' q' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  dist_nodes M n v p' q'\n\ngoal (1 subgoal):\n 1. \\<exists>n. dist_nodes M n v p' q' \\<Longrightarrow> tr_lookup T q' p'", "moreover"], ["proof (state)\nthis:\n  dist_nodes M n v p' q'\n\ngoal (1 subgoal):\n 1. \\<exists>n. dist_nodes M n v p' q' \\<Longrightarrow> tr_lookup T q' p'", "have \"n < Suc n + m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < Suc n + m", "by simp"], ["proof (state)\nthis:\n  n < Suc n + m\n\ngoal (1 subgoal):\n 1. \\<exists>n. dist_nodes M n v p' q' \\<Longrightarrow> tr_lookup T q' p'", "ultimately"], ["proof (chain)\npicking this:\n  dist_nodes M n v p' q'\n  n < Suc n + m", "have \"\\<exists>n' < Suc n + m. dist_nodes M n' v p' q'\""], ["proof (prove)\nusing this:\n  dist_nodes M n v p' q'\n  n < Suc n + m\n\ngoal (1 subgoal):\n 1. \\<exists>n'<Suc n + m. dist_nodes M n' v p' q'", "by blast"], ["proof (state)\nthis:\n  \\<exists>n'<Suc n + m. dist_nodes M n' v p' q'\n\ngoal (1 subgoal):\n 1. \\<exists>n. dist_nodes M n v p' q' \\<Longrightarrow> tr_lookup T q' p'", "with H C[of \"Suc n\"]"], ["proof (chain)\npicking this:\n  dfa_is_node M q' \\<and> p' < q'\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>na<Suc n + m. dist_nodes M na v p q)\n  \\<exists>n'<Suc n + m. dist_nodes M n' v p' q'", "show \"tr_lookup T q' p'\""], ["proof (prove)\nusing this:\n  dfa_is_node M q' \\<and> p' < q'\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>na<Suc n + m. dist_nodes M na v p q)\n  \\<exists>n'<Suc n + m. dist_nodes M n' v p' q'\n\ngoal (1 subgoal):\n 1. tr_lookup T q' p'", "by simp"], ["proof (state)\nthis:\n  tr_lookup T q' p'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  tr_lookup T q' p' = (\\<exists>n. dist_nodes M n v p' q')\n\ngoal (1 subgoal):\n 1. \\<not> fst (iter M T) \\<Longrightarrow>\n    tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)", "}"], ["proof (state)\nthis:\n  dfa_is_node M ?q'2 \\<and> ?p'2 < ?q'2 \\<Longrightarrow>\n  tr_lookup T ?q'2 ?p'2 = (\\<exists>n. dist_nodes M n v ?p'2 ?q'2)\n\ngoal (1 subgoal):\n 1. \\<not> fst (iter M T) \\<Longrightarrow>\n    tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)", "hence \"\\<forall>p q. dfa_is_node M q \\<and> p < q \\<longrightarrow> tr_lookup T q p = (\\<exists>n. dist_nodes M n v p q)\""], ["proof (prove)\nusing this:\n  dfa_is_node M ?q'2 \\<and> ?p'2 < ?q'2 \\<Longrightarrow>\n  tr_lookup T ?q'2 ?p'2 = (\\<exists>n. dist_nodes M n v ?p'2 ?q'2)\n\ngoal (1 subgoal):\n 1. \\<forall>p q.\n       dfa_is_node M q \\<and> p < q \\<longrightarrow>\n       tr_lookup T q p = (\\<exists>n. dist_nodes M n v p q)", "by simp"], ["proof (state)\nthis:\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n. dist_nodes M n v p q)\n\ngoal (1 subgoal):\n 1. \\<not> fst (iter M T) \\<Longrightarrow>\n    tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)", "with False \\<open>dfa_is_node M q\\<close> \\<open>p < q\\<close>"], ["proof (chain)\npicking this:\n  \\<not> fst (iter M T)\n  dfa_is_node M q\n  p < q\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n. dist_nodes M n v p q)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> fst (iter M T)\n  dfa_is_node M q\n  p < q\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup T q p = (\\<exists>n. dist_nodes M n v p q)\n\ngoal (1 subgoal):\n 1. tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)", "by simp"], ["proof (state)\nthis:\n  tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  tr_lookup (fixpt M T) q p = (\\<exists>n. dist_nodes M n v p q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fixpt_dist_nodes:\n  assumes \"wf_dfa M v\"\n  and \"dfa_is_node M p\" and \"dfa_is_node M q\"\n  shows \"tr_lookup (fixpt M (init_tr M)) p q = (\\<exists>n. dist_nodes M n v p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tr_lookup (fixpt M (init_tr M)) p q = (\\<exists>n. dist_nodes M n v p q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. tr_lookup (fixpt M (init_tr M)) p q = (\\<exists>n. dist_nodes M n v p q)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. tr_lookup (fixpt M (init_tr M)) p q = (\\<exists>n. dist_nodes M n v p q)", "fix p q"], ["proof (state)\ngoal (1 subgoal):\n 1. tr_lookup (fixpt M (init_tr M)) p q = (\\<exists>n. dist_nodes M n v p q)", "assume H1: \"p < q\" and H2: \"dfa_is_node M q\""], ["proof (state)\nthis:\n  p < q\n  dfa_is_node M q\n\ngoal (1 subgoal):\n 1. tr_lookup (fixpt M (init_tr M)) p q = (\\<exists>n. dist_nodes M n v p q)", "from init_tr_wf"], ["proof (chain)\npicking this:\n  wf_tr ?M (init_tr ?M)", "have \"wf_tr M (init_tr M)\""], ["proof (prove)\nusing this:\n  wf_tr ?M (init_tr ?M)\n\ngoal (1 subgoal):\n 1. wf_tr M (init_tr M)", "by simp"], ["proof (state)\nthis:\n  wf_tr M (init_tr M)\n\ngoal (1 subgoal):\n 1. tr_lookup (fixpt M (init_tr M)) p q = (\\<exists>n. dist_nodes M n v p q)", "moreover"], ["proof (state)\nthis:\n  wf_tr M (init_tr M)\n\ngoal (1 subgoal):\n 1. tr_lookup (fixpt M (init_tr M)) p q = (\\<exists>n. dist_nodes M n v p q)", "note assms(1)"], ["proof (state)\nthis:\n  wf_dfa M v\n\ngoal (1 subgoal):\n 1. tr_lookup (fixpt M (init_tr M)) p q = (\\<exists>n. dist_nodes M n v p q)", "moreover"], ["proof (state)\nthis:\n  wf_dfa M v\n\ngoal (1 subgoal):\n 1. tr_lookup (fixpt M (init_tr M)) p q = (\\<exists>n. dist_nodes M n v p q)", "{"], ["proof (state)\nthis:\n  wf_dfa M v\n\ngoal (1 subgoal):\n 1. tr_lookup (fixpt M (init_tr M)) p q = (\\<exists>n. dist_nodes M n v p q)", "fix p' q'"], ["proof (state)\ngoal (1 subgoal):\n 1. tr_lookup (fixpt M (init_tr M)) p q = (\\<exists>n. dist_nodes M n v p q)", "assume \"dfa_is_node M q'\" and \"p' < q'\""], ["proof (state)\nthis:\n  dfa_is_node M q'\n  p' < q'\n\ngoal (1 subgoal):\n 1. tr_lookup (fixpt M (init_tr M)) p q = (\\<exists>n. dist_nodes M n v p q)", "hence \"tr_lookup (init_tr M) q' p' = dist_nodes M 0 v p' q'\""], ["proof (prove)\nusing this:\n  dfa_is_node M q'\n  p' < q'\n\ngoal (1 subgoal):\n 1. tr_lookup (init_tr M) q' p' = dist_nodes M 0 v p' q'", "by (rule init_tr_dist_nodes)"], ["proof (state)\nthis:\n  tr_lookup (init_tr M) q' p' = dist_nodes M 0 v p' q'\n\ngoal (1 subgoal):\n 1. tr_lookup (fixpt M (init_tr M)) p q = (\\<exists>n. dist_nodes M n v p q)", "also"], ["proof (state)\nthis:\n  tr_lookup (init_tr M) q' p' = dist_nodes M 0 v p' q'\n\ngoal (1 subgoal):\n 1. tr_lookup (fixpt M (init_tr M)) p q = (\\<exists>n. dist_nodes M n v p q)", "have \"\\<dots> = (\\<exists>n < 1. dist_nodes M n v p' q')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist_nodes M 0 v p' q' = (\\<exists>n<1. dist_nodes M n v p' q')", "by auto"], ["proof (state)\nthis:\n  dist_nodes M 0 v p' q' = (\\<exists>n<1. dist_nodes M n v p' q')\n\ngoal (1 subgoal):\n 1. tr_lookup (fixpt M (init_tr M)) p q = (\\<exists>n. dist_nodes M n v p q)", "finally"], ["proof (chain)\npicking this:\n  tr_lookup (init_tr M) q' p' = (\\<exists>n<1. dist_nodes M n v p' q')", "have \"tr_lookup (init_tr M) q' p' = (\\<exists>n<1. dist_nodes M n v p' q')\""], ["proof (prove)\nusing this:\n  tr_lookup (init_tr M) q' p' = (\\<exists>n<1. dist_nodes M n v p' q')\n\ngoal (1 subgoal):\n 1. tr_lookup (init_tr M) q' p' = (\\<exists>n<1. dist_nodes M n v p' q')", "by simp"], ["proof (state)\nthis:\n  tr_lookup (init_tr M) q' p' = (\\<exists>n<1. dist_nodes M n v p' q')\n\ngoal (1 subgoal):\n 1. tr_lookup (fixpt M (init_tr M)) p q = (\\<exists>n. dist_nodes M n v p q)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>dfa_is_node M ?q'2; ?p'2 < ?q'2\\<rbrakk>\n  \\<Longrightarrow> tr_lookup (init_tr M) ?q'2 ?p'2 =\n                    (\\<exists>n<1. dist_nodes M n v ?p'2 ?q'2)\n\ngoal (1 subgoal):\n 1. tr_lookup (fixpt M (init_tr M)) p q = (\\<exists>n. dist_nodes M n v p q)", "hence \"\\<forall>p q. dfa_is_node M q \\<and> p < q \\<longrightarrow> tr_lookup (init_tr M) q p = (\\<exists>n<1. dist_nodes M n v p q)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>dfa_is_node M ?q'2; ?p'2 < ?q'2\\<rbrakk>\n  \\<Longrightarrow> tr_lookup (init_tr M) ?q'2 ?p'2 =\n                    (\\<exists>n<1. dist_nodes M n v ?p'2 ?q'2)\n\ngoal (1 subgoal):\n 1. \\<forall>p q.\n       dfa_is_node M q \\<and> p < q \\<longrightarrow>\n       tr_lookup (init_tr M) q p = (\\<exists>n<1. dist_nodes M n v p q)", "by simp"], ["proof (state)\nthis:\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup (init_tr M) q p = (\\<exists>n<1. dist_nodes M n v p q)\n\ngoal (1 subgoal):\n 1. tr_lookup (fixpt M (init_tr M)) p q = (\\<exists>n. dist_nodes M n v p q)", "moreover"], ["proof (state)\nthis:\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup (init_tr M) q p = (\\<exists>n<1. dist_nodes M n v p q)\n\ngoal (1 subgoal):\n 1. tr_lookup (fixpt M (init_tr M)) p q = (\\<exists>n. dist_nodes M n v p q)", "note H1 H2"], ["proof (state)\nthis:\n  p < q\n  dfa_is_node M q\n\ngoal (1 subgoal):\n 1. tr_lookup (fixpt M (init_tr M)) p q = (\\<exists>n. dist_nodes M n v p q)", "ultimately"], ["proof (chain)\npicking this:\n  wf_tr M (init_tr M)\n  wf_dfa M v\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup (init_tr M) q p = (\\<exists>n<1. dist_nodes M n v p q)\n  p < q\n  dfa_is_node M q", "have \"tr_lookup (fixpt M (init_tr M)) q p = (\\<exists>n. dist_nodes M n v p q)\""], ["proof (prove)\nusing this:\n  wf_tr M (init_tr M)\n  wf_dfa M v\n  \\<forall>p q.\n     dfa_is_node M q \\<and> p < q \\<longrightarrow>\n     tr_lookup (init_tr M) q p = (\\<exists>n<1. dist_nodes M n v p q)\n  p < q\n  dfa_is_node M q\n\ngoal (1 subgoal):\n 1. tr_lookup (fixpt M (init_tr M)) q p = (\\<exists>n. dist_nodes M n v p q)", "by (simp only: fixpt_dist_nodes'[of _ _ _ 1])"], ["proof (state)\nthis:\n  tr_lookup (fixpt M (init_tr M)) q p = (\\<exists>n. dist_nodes M n v p q)\n\ngoal (1 subgoal):\n 1. tr_lookup (fixpt M (init_tr M)) p q = (\\<exists>n. dist_nodes M n v p q)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?pa2 < ?qa2; dfa_is_node M ?qa2\\<rbrakk>\n  \\<Longrightarrow> tr_lookup (fixpt M (init_tr M)) ?qa2 ?pa2 =\n                    (\\<exists>n. dist_nodes M n v ?pa2 ?qa2)\n\ngoal (1 subgoal):\n 1. tr_lookup (fixpt M (init_tr M)) p q = (\\<exists>n. dist_nodes M n v p q)", "with assms(2,3)"], ["proof (chain)\npicking this:\n  dfa_is_node M p\n  dfa_is_node M q\n  \\<lbrakk>?pa2 < ?qa2; dfa_is_node M ?qa2\\<rbrakk>\n  \\<Longrightarrow> tr_lookup (fixpt M (init_tr M)) ?qa2 ?pa2 =\n                    (\\<exists>n. dist_nodes M n v ?pa2 ?qa2)", "show ?thesis"], ["proof (prove)\nusing this:\n  dfa_is_node M p\n  dfa_is_node M q\n  \\<lbrakk>?pa2 < ?qa2; dfa_is_node M ?qa2\\<rbrakk>\n  \\<Longrightarrow> tr_lookup (fixpt M (init_tr M)) ?qa2 ?pa2 =\n                    (\\<exists>n. dist_nodes M n v ?pa2 ?qa2)\n\ngoal (1 subgoal):\n 1. tr_lookup (fixpt M (init_tr M)) p q = (\\<exists>n. dist_nodes M n v p q)", "by (auto simp: tr_lookup_def dist_nodes_def)"], ["proof (state)\nthis:\n  tr_lookup (fixpt M (init_tr M)) p q = (\\<exists>n. dist_nodes M n v p q)\n\ngoal:\nNo subgoals!", "qed"], ["", "primrec mk_eqcl' :: \"nat option list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> bool list list \\<Rightarrow> nat option list\"\nwhere\n  \"mk_eqcl' [] i j l T = []\"\n| \"mk_eqcl' (x#xs) i j l T = (if tr_lookup T j i \\<or> x \\<noteq> None then x else Some l) # mk_eqcl' xs i (Suc j) l T\""], ["", "lemma mk_eqcl'_len: \"length (mk_eqcl' xs i j l T) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (mk_eqcl' xs i j l T) = length xs", "by (induct xs arbitrary: j) simp+"], ["", "function mk_eqcl  :: \"nat option list \\<Rightarrow> nat list \\<Rightarrow> nat \\<Rightarrow> bool list list \\<Rightarrow> nat list \\<times> nat list\" where\n  \"mk_eqcl [] zs i T = ([], zs)\" |\n  \"mk_eqcl (None # xs) zs i T = (let (xs',zs') = mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T in (length zs # xs', zs'))\" |\n  \"mk_eqcl (Some l # xs) zs i T = (let (xs',zs') = mk_eqcl xs zs (Suc i) T in (l # xs', zs'))\""], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>zs i T. x = ([], zs, i, T) \\<Longrightarrow> P;\n        \\<And>xs zs i T. x = (None # xs, zs, i, T) \\<Longrightarrow> P;\n        \\<And>l xs zs i T.\n           x = (Some l # xs, zs, i, T) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>zs i T zsa ia Ta.\n       ([], zs, i, T) = ([], zsa, ia, Ta) \\<Longrightarrow>\n       ([], zs) = ([], zsa)\n 3. \\<And>zs i T xs zsa ia Ta.\n       ([], zs, i, T) = (None # xs, zsa, ia, Ta) \\<Longrightarrow>\n       ([], zs) =\n       (let (xs', y) =\n              mk_eqcl_sumC\n               (mk_eqcl' xs ia (Suc ia) (length zsa) Ta, zsa @ [ia], Suc ia,\n                Ta)\n        in (length zsa # xs', y))\n 4. \\<And>zs i T l xs zsa ia Ta.\n       ([], zs, i, T) = (Some l # xs, zsa, ia, Ta) \\<Longrightarrow>\n       ([], zs) =\n       (let (xs', y) = mk_eqcl_sumC (xs, zsa, Suc ia, Ta) in (l # xs', y))\n 5. \\<And>xs zs i T xsa zsa ia Ta.\n       (None # xs, zs, i, T) = (None # xsa, zsa, ia, Ta) \\<Longrightarrow>\n       (let (xs', y) =\n              mk_eqcl_sumC\n               (mk_eqcl' xs i (Suc i) (length zs) T, zs @ [i], Suc i, T)\n        in (length zs # xs', y)) =\n       (let (xs', y) =\n              mk_eqcl_sumC\n               (mk_eqcl' xsa ia (Suc ia) (length zsa) Ta, zsa @ [ia],\n                Suc ia, Ta)\n        in (length zsa # xs', y))\n 6. \\<And>xs zs i T l xsa zsa ia Ta.\n       (None # xs, zs, i, T) = (Some l # xsa, zsa, ia, Ta) \\<Longrightarrow>\n       (let (xs', y) =\n              mk_eqcl_sumC\n               (mk_eqcl' xs i (Suc i) (length zs) T, zs @ [i], Suc i, T)\n        in (length zs # xs', y)) =\n       (let (xs', y) = mk_eqcl_sumC (xsa, zsa, Suc ia, Ta) in (l # xs', y))\n 7. \\<And>l xs zs i T la xsa zsa ia Ta.\n       (Some l # xs, zs, i, T) =\n       (Some la # xsa, zsa, ia, Ta) \\<Longrightarrow>\n       (let (xs', y) = mk_eqcl_sumC (xs, zs, Suc i, T) in (l # xs', y)) =\n       (let (xs', y) = mk_eqcl_sumC (xsa, zsa, Suc ia, Ta) in (la # xs', y))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All mk_eqcl_dom", "by (lexicographic_order simp: mk_eqcl'_len)"], ["", "lemma mk_eqcl'_bound:\n  assumes \"\\<And>x k. \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk> \\<Longrightarrow> k < l\"\n  and \"x \\<in> set (mk_eqcl' xs i j l T)\" and \"x = Some k\"\n  shows \"k \\<le> l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> l", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set xs; ?x = Some ?k\\<rbrakk> \\<Longrightarrow> ?k < l\n  x \\<in> set (mk_eqcl' xs i j l T)\n  x = Some k\n\ngoal (1 subgoal):\n 1. k \\<le> l", "proof (induct xs arbitrary: j)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>\\<And>x k.\n                   \\<lbrakk>x \\<in> set []; x = Some k\\<rbrakk>\n                   \\<Longrightarrow> k < l;\n        x \\<in> set (mk_eqcl' [] i j l T); x = Some k\\<rbrakk>\n       \\<Longrightarrow> k \\<le> l\n 2. \\<And>a xs j.\n       \\<lbrakk>\\<And>j.\n                   \\<lbrakk>\\<And>x k.\n                               \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                               \\<Longrightarrow> k < l;\n                    x \\<in> set (mk_eqcl' xs i j l T); x = Some k\\<rbrakk>\n                   \\<Longrightarrow> k \\<le> l;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (a # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < l;\n        x \\<in> set (mk_eqcl' (a # xs) i j l T); x = Some k\\<rbrakk>\n       \\<Longrightarrow> k \\<le> l", "case (Cons y xs j)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>x k.\n              \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n              \\<Longrightarrow> k < l;\n   x \\<in> set (mk_eqcl' xs i ?j l T); x = Some k\\<rbrakk>\n  \\<Longrightarrow> k \\<le> l\n  \\<lbrakk>?x \\<in> set (y # xs); ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < l\n  x \\<in> set (mk_eqcl' (y # xs) i j l T)\n  x = Some k\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>\\<And>x k.\n                   \\<lbrakk>x \\<in> set []; x = Some k\\<rbrakk>\n                   \\<Longrightarrow> k < l;\n        x \\<in> set (mk_eqcl' [] i j l T); x = Some k\\<rbrakk>\n       \\<Longrightarrow> k \\<le> l\n 2. \\<And>a xs j.\n       \\<lbrakk>\\<And>j.\n                   \\<lbrakk>\\<And>x k.\n                               \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                               \\<Longrightarrow> k < l;\n                    x \\<in> set (mk_eqcl' xs i j l T); x = Some k\\<rbrakk>\n                   \\<Longrightarrow> k \\<le> l;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (a # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < l;\n        x \\<in> set (mk_eqcl' (a # xs) i j l T); x = Some k\\<rbrakk>\n       \\<Longrightarrow> k \\<le> l", "hence \"x = y \\<or> x = Some l \\<or> x \\<in> set (mk_eqcl' xs i (Suc j) l T)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x k.\n              \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n              \\<Longrightarrow> k < l;\n   x \\<in> set (mk_eqcl' xs i ?j l T); x = Some k\\<rbrakk>\n  \\<Longrightarrow> k \\<le> l\n  \\<lbrakk>?x \\<in> set (y # xs); ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < l\n  x \\<in> set (mk_eqcl' (y # xs) i j l T)\n  x = Some k\n\ngoal (1 subgoal):\n 1. x = y \\<or> x = Some l \\<or> x \\<in> set (mk_eqcl' xs i (Suc j) l T)", "by (cases \"tr_lookup T j i \\<or> y \\<noteq> None\") auto"], ["proof (state)\nthis:\n  x = y \\<or> x = Some l \\<or> x \\<in> set (mk_eqcl' xs i (Suc j) l T)\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>\\<And>x k.\n                   \\<lbrakk>x \\<in> set []; x = Some k\\<rbrakk>\n                   \\<Longrightarrow> k < l;\n        x \\<in> set (mk_eqcl' [] i j l T); x = Some k\\<rbrakk>\n       \\<Longrightarrow> k \\<le> l\n 2. \\<And>a xs j.\n       \\<lbrakk>\\<And>j.\n                   \\<lbrakk>\\<And>x k.\n                               \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                               \\<Longrightarrow> k < l;\n                    x \\<in> set (mk_eqcl' xs i j l T); x = Some k\\<rbrakk>\n                   \\<Longrightarrow> k \\<le> l;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (a # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < l;\n        x \\<in> set (mk_eqcl' (a # xs) i j l T); x = Some k\\<rbrakk>\n       \\<Longrightarrow> k \\<le> l", "thus ?case"], ["proof (prove)\nusing this:\n  x = y \\<or> x = Some l \\<or> x \\<in> set (mk_eqcl' xs i (Suc j) l T)\n\ngoal (1 subgoal):\n 1. k \\<le> l", "proof (elim disjE)"], ["proof (state)\ngoal (3 subgoals):\n 1. x = y \\<Longrightarrow> k \\<le> l\n 2. x = Some l \\<Longrightarrow> k \\<le> l\n 3. x \\<in> set (mk_eqcl' xs i (Suc j) l T) \\<Longrightarrow> k \\<le> l", "assume \"x = y\""], ["proof (state)\nthis:\n  x = y\n\ngoal (3 subgoals):\n 1. x = y \\<Longrightarrow> k \\<le> l\n 2. x = Some l \\<Longrightarrow> k \\<le> l\n 3. x \\<in> set (mk_eqcl' xs i (Suc j) l T) \\<Longrightarrow> k \\<le> l", "hence \"x \\<in> set (y # xs)\""], ["proof (prove)\nusing this:\n  x = y\n\ngoal (1 subgoal):\n 1. x \\<in> set (y # xs)", "by simp"], ["proof (state)\nthis:\n  x \\<in> set (y # xs)\n\ngoal (3 subgoals):\n 1. x = y \\<Longrightarrow> k \\<le> l\n 2. x = Some l \\<Longrightarrow> k \\<le> l\n 3. x \\<in> set (mk_eqcl' xs i (Suc j) l T) \\<Longrightarrow> k \\<le> l", "with Cons(2)[of x k] Cons(4)"], ["proof (chain)\npicking this:\n  \\<lbrakk>x \\<in> set (y # xs); x = Some k\\<rbrakk> \\<Longrightarrow> k < l\n  x = Some k\n  x \\<in> set (y # xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<in> set (y # xs); x = Some k\\<rbrakk> \\<Longrightarrow> k < l\n  x = Some k\n  x \\<in> set (y # xs)\n\ngoal (1 subgoal):\n 1. k \\<le> l", "by simp"], ["proof (state)\nthis:\n  k \\<le> l\n\ngoal (2 subgoals):\n 1. x = Some l \\<Longrightarrow> k \\<le> l\n 2. x \\<in> set (mk_eqcl' xs i (Suc j) l T) \\<Longrightarrow> k \\<le> l", "qed (insert Cons, auto)"], ["proof (state)\nthis:\n  k \\<le> l\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>\\<And>x k.\n                   \\<lbrakk>x \\<in> set []; x = Some k\\<rbrakk>\n                   \\<Longrightarrow> k < l;\n        x \\<in> set (mk_eqcl' [] i j l T); x = Some k\\<rbrakk>\n       \\<Longrightarrow> k \\<le> l", "qed simp"], ["", "lemma mk_eqcl'_nth':\n  assumes \"\\<And>x k. \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk> \\<Longrightarrow> k < l\"\n  and \"\\<And>i'. \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + j) i\\<rbrakk> \\<Longrightarrow> xs ! i' = None\"\n  and \"i < j\" and \"j' < length xs\"\n  shows \"(mk_eqcl' xs i j l T ! j' = Some l) = (\\<not> tr_lookup T (j' + j) i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mk_eqcl' xs i j l T ! j' = Some l) = (\\<not> tr_lookup T (j' + j) i)", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set xs; ?x = Some ?k\\<rbrakk> \\<Longrightarrow> ?k < l\n  \\<lbrakk>?i' < length xs; \\<not> tr_lookup T (?i' + j) i\\<rbrakk>\n  \\<Longrightarrow> xs ! ?i' = None\n  i < j\n  j' < length xs\n\ngoal (1 subgoal):\n 1. (mk_eqcl' xs i j l T ! j' = Some l) = (\\<not> tr_lookup T (j' + j) i)", "proof (induct xs arbitrary: j j')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>j j'.\n       \\<lbrakk>\\<And>x k.\n                   \\<lbrakk>x \\<in> set []; x = Some k\\<rbrakk>\n                   \\<Longrightarrow> k < l;\n        \\<And>i'.\n           \\<lbrakk>i' < length []; \\<not> tr_lookup T (i' + j) i\\<rbrakk>\n           \\<Longrightarrow> [] ! i' = None;\n        i < j; j' < length []\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' [] i j l T ! j' = Some l) =\n                         (\\<not> tr_lookup T (j' + j) i)\n 2. \\<And>a xs j j'.\n       \\<lbrakk>\\<And>j j'.\n                   \\<lbrakk>\\<And>x k.\n                               \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                               \\<Longrightarrow> k < l;\n                    \\<And>i'.\n                       \\<lbrakk>i' < length xs;\n                        \\<not> tr_lookup T (i' + j) i\\<rbrakk>\n                       \\<Longrightarrow> xs ! i' = None;\n                    i < j; j' < length xs\\<rbrakk>\n                   \\<Longrightarrow> (mk_eqcl' xs i j l T ! j' = Some l) =\n                                     (\\<not> tr_lookup T (j' + j) i);\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (a # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < l;\n        \\<And>i'.\n           \\<lbrakk>i' < length (a # xs);\n            \\<not> tr_lookup T (i' + j) i\\<rbrakk>\n           \\<Longrightarrow> (a # xs) ! i' = None;\n        i < j; j' < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' (a # xs) i j l T ! j' = Some l) =\n                         (\\<not> tr_lookup T (j' + j) i)", "case (Cons x xs j)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>x k.\n              \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n              \\<Longrightarrow> k < l;\n   \\<And>i'.\n      \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + ?j) i\\<rbrakk>\n      \\<Longrightarrow> xs ! i' = None;\n   i < ?j; ?j' < length xs\\<rbrakk>\n  \\<Longrightarrow> (mk_eqcl' xs i ?j l T ! ?j' = Some l) =\n                    (\\<not> tr_lookup T (?j' + ?j) i)\n  \\<lbrakk>?x \\<in> set (x # xs); ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < l\n  \\<lbrakk>?i' < length (x # xs); \\<not> tr_lookup T (?i' + j) i\\<rbrakk>\n  \\<Longrightarrow> (x # xs) ! ?i' = None\n  i < j\n  j' < length (x # xs)\n\ngoal (2 subgoals):\n 1. \\<And>j j'.\n       \\<lbrakk>\\<And>x k.\n                   \\<lbrakk>x \\<in> set []; x = Some k\\<rbrakk>\n                   \\<Longrightarrow> k < l;\n        \\<And>i'.\n           \\<lbrakk>i' < length []; \\<not> tr_lookup T (i' + j) i\\<rbrakk>\n           \\<Longrightarrow> [] ! i' = None;\n        i < j; j' < length []\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' [] i j l T ! j' = Some l) =\n                         (\\<not> tr_lookup T (j' + j) i)\n 2. \\<And>a xs j j'.\n       \\<lbrakk>\\<And>j j'.\n                   \\<lbrakk>\\<And>x k.\n                               \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                               \\<Longrightarrow> k < l;\n                    \\<And>i'.\n                       \\<lbrakk>i' < length xs;\n                        \\<not> tr_lookup T (i' + j) i\\<rbrakk>\n                       \\<Longrightarrow> xs ! i' = None;\n                    i < j; j' < length xs\\<rbrakk>\n                   \\<Longrightarrow> (mk_eqcl' xs i j l T ! j' = Some l) =\n                                     (\\<not> tr_lookup T (j' + j) i);\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (a # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < l;\n        \\<And>i'.\n           \\<lbrakk>i' < length (a # xs);\n            \\<not> tr_lookup T (i' + j) i\\<rbrakk>\n           \\<Longrightarrow> (a # xs) ! i' = None;\n        i < j; j' < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' (a # xs) i j l T ! j' = Some l) =\n                         (\\<not> tr_lookup T (j' + j) i)", "have I1:\"\\<And>i'. \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc j) i\\<rbrakk> \\<Longrightarrow> xs ! i' = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i'.\n       \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc j) i\\<rbrakk>\n       \\<Longrightarrow> xs ! i' = None", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i'.\n       \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc j) i\\<rbrakk>\n       \\<Longrightarrow> xs ! i' = None", "fix i'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i'.\n       \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc j) i\\<rbrakk>\n       \\<Longrightarrow> xs ! i' = None", "assume H: \"i' < length xs\" \"\\<not> tr_lookup T (i' + Suc j) i\""], ["proof (state)\nthis:\n  i' < length xs\n  \\<not> tr_lookup T (i' + Suc j) i\n\ngoal (1 subgoal):\n 1. \\<And>i'.\n       \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc j) i\\<rbrakk>\n       \\<Longrightarrow> xs ! i' = None", "with Cons(3)[of \"Suc i'\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>Suc i' < length (x # xs);\n   \\<not> tr_lookup T (Suc i' + j) i\\<rbrakk>\n  \\<Longrightarrow> (x # xs) ! Suc i' = None\n  i' < length xs\n  \\<not> tr_lookup T (i' + Suc j) i", "show \"xs ! i' = None\""], ["proof (prove)\nusing this:\n  \\<lbrakk>Suc i' < length (x # xs);\n   \\<not> tr_lookup T (Suc i' + j) i\\<rbrakk>\n  \\<Longrightarrow> (x # xs) ! Suc i' = None\n  i' < length xs\n  \\<not> tr_lookup T (i' + Suc j) i\n\ngoal (1 subgoal):\n 1. xs ! i' = None", "by simp"], ["proof (state)\nthis:\n  xs ! i' = None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?i' < length xs; \\<not> tr_lookup T (?i' + Suc j) i\\<rbrakk>\n  \\<Longrightarrow> xs ! ?i' = None\n\ngoal (2 subgoals):\n 1. \\<And>j j'.\n       \\<lbrakk>\\<And>x k.\n                   \\<lbrakk>x \\<in> set []; x = Some k\\<rbrakk>\n                   \\<Longrightarrow> k < l;\n        \\<And>i'.\n           \\<lbrakk>i' < length []; \\<not> tr_lookup T (i' + j) i\\<rbrakk>\n           \\<Longrightarrow> [] ! i' = None;\n        i < j; j' < length []\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' [] i j l T ! j' = Some l) =\n                         (\\<not> tr_lookup T (j' + j) i)\n 2. \\<And>a xs j j'.\n       \\<lbrakk>\\<And>j j'.\n                   \\<lbrakk>\\<And>x k.\n                               \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                               \\<Longrightarrow> k < l;\n                    \\<And>i'.\n                       \\<lbrakk>i' < length xs;\n                        \\<not> tr_lookup T (i' + j) i\\<rbrakk>\n                       \\<Longrightarrow> xs ! i' = None;\n                    i < j; j' < length xs\\<rbrakk>\n                   \\<Longrightarrow> (mk_eqcl' xs i j l T ! j' = Some l) =\n                                     (\\<not> tr_lookup T (j' + j) i);\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (a # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < l;\n        \\<And>i'.\n           \\<lbrakk>i' < length (a # xs);\n            \\<not> tr_lookup T (i' + j) i\\<rbrakk>\n           \\<Longrightarrow> (a # xs) ! i' = None;\n        i < j; j' < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' (a # xs) i j l T ! j' = Some l) =\n                         (\\<not> tr_lookup T (j' + j) i)", "have \"j' = 0 \\<or> j' > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j' = 0 \\<or> 0 < j'", "by auto"], ["proof (state)\nthis:\n  j' = 0 \\<or> 0 < j'\n\ngoal (2 subgoals):\n 1. \\<And>j j'.\n       \\<lbrakk>\\<And>x k.\n                   \\<lbrakk>x \\<in> set []; x = Some k\\<rbrakk>\n                   \\<Longrightarrow> k < l;\n        \\<And>i'.\n           \\<lbrakk>i' < length []; \\<not> tr_lookup T (i' + j) i\\<rbrakk>\n           \\<Longrightarrow> [] ! i' = None;\n        i < j; j' < length []\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' [] i j l T ! j' = Some l) =\n                         (\\<not> tr_lookup T (j' + j) i)\n 2. \\<And>a xs j j'.\n       \\<lbrakk>\\<And>j j'.\n                   \\<lbrakk>\\<And>x k.\n                               \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                               \\<Longrightarrow> k < l;\n                    \\<And>i'.\n                       \\<lbrakk>i' < length xs;\n                        \\<not> tr_lookup T (i' + j) i\\<rbrakk>\n                       \\<Longrightarrow> xs ! i' = None;\n                    i < j; j' < length xs\\<rbrakk>\n                   \\<Longrightarrow> (mk_eqcl' xs i j l T ! j' = Some l) =\n                                     (\\<not> tr_lookup T (j' + j) i);\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (a # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < l;\n        \\<And>i'.\n           \\<lbrakk>i' < length (a # xs);\n            \\<not> tr_lookup T (i' + j) i\\<rbrakk>\n           \\<Longrightarrow> (a # xs) ! i' = None;\n        i < j; j' < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' (a # xs) i j l T ! j' = Some l) =\n                         (\\<not> tr_lookup T (j' + j) i)", "thus ?case"], ["proof (prove)\nusing this:\n  j' = 0 \\<or> 0 < j'\n\ngoal (1 subgoal):\n 1. (mk_eqcl' (x # xs) i j l T ! j' = Some l) =\n    (\\<not> tr_lookup T (j' + j) i)", "proof (elim disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. j' = 0 \\<Longrightarrow>\n    (mk_eqcl' (x # xs) i j l T ! j' = Some l) =\n    (\\<not> tr_lookup T (j' + j) i)\n 2. 0 < j' \\<Longrightarrow>\n    (mk_eqcl' (x # xs) i j l T ! j' = Some l) =\n    (\\<not> tr_lookup T (j' + j) i)", "assume \"j' > 0\""], ["proof (state)\nthis:\n  0 < j'\n\ngoal (2 subgoals):\n 1. j' = 0 \\<Longrightarrow>\n    (mk_eqcl' (x # xs) i j l T ! j' = Some l) =\n    (\\<not> tr_lookup T (j' + j) i)\n 2. 0 < j' \\<Longrightarrow>\n    (mk_eqcl' (x # xs) i j l T ! j' = Some l) =\n    (\\<not> tr_lookup T (j' + j) i)", "then"], ["proof (chain)\npicking this:\n  0 < j'", "obtain j'' where J: \"j' = Suc j''\""], ["proof (prove)\nusing this:\n  0 < j'\n\ngoal (1 subgoal):\n 1. (\\<And>j''. j' = Suc j'' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases j') simp+"], ["proof (state)\nthis:\n  j' = Suc j''\n\ngoal (2 subgoals):\n 1. j' = 0 \\<Longrightarrow>\n    (mk_eqcl' (x # xs) i j l T ! j' = Some l) =\n    (\\<not> tr_lookup T (j' + j) i)\n 2. 0 < j' \\<Longrightarrow>\n    (mk_eqcl' (x # xs) i j l T ! j' = Some l) =\n    (\\<not> tr_lookup T (j' + j) i)", "from Cons(1)[of \"Suc j\" j''] I1 Cons(2,4,5) J"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x k.\n              \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n              \\<Longrightarrow> k < l;\n   \\<And>i'.\n      \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc j) i\\<rbrakk>\n      \\<Longrightarrow> xs ! i' = None;\n   i < Suc j; j'' < length xs\\<rbrakk>\n  \\<Longrightarrow> (mk_eqcl' xs i (Suc j) l T ! j'' = Some l) =\n                    (\\<not> tr_lookup T (j'' + Suc j) i)\n  \\<lbrakk>?i' < length xs; \\<not> tr_lookup T (?i' + Suc j) i\\<rbrakk>\n  \\<Longrightarrow> xs ! ?i' = None\n  \\<lbrakk>?x \\<in> set (x # xs); ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < l\n  i < j\n  j' < length (x # xs)\n  j' = Suc j''", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x k.\n              \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n              \\<Longrightarrow> k < l;\n   \\<And>i'.\n      \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc j) i\\<rbrakk>\n      \\<Longrightarrow> xs ! i' = None;\n   i < Suc j; j'' < length xs\\<rbrakk>\n  \\<Longrightarrow> (mk_eqcl' xs i (Suc j) l T ! j'' = Some l) =\n                    (\\<not> tr_lookup T (j'' + Suc j) i)\n  \\<lbrakk>?i' < length xs; \\<not> tr_lookup T (?i' + Suc j) i\\<rbrakk>\n  \\<Longrightarrow> xs ! ?i' = None\n  \\<lbrakk>?x \\<in> set (x # xs); ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < l\n  i < j\n  j' < length (x # xs)\n  j' = Suc j''\n\ngoal (1 subgoal):\n 1. (mk_eqcl' (x # xs) i j l T ! j' = Some l) =\n    (\\<not> tr_lookup T (j' + j) i)", "by simp"], ["proof (state)\nthis:\n  (mk_eqcl' (x # xs) i j l T ! j' = Some l) =\n  (\\<not> tr_lookup T (j' + j) i)\n\ngoal (1 subgoal):\n 1. j' = 0 \\<Longrightarrow>\n    (mk_eqcl' (x # xs) i j l T ! j' = Some l) =\n    (\\<not> tr_lookup T (j' + j) i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j' = 0 \\<Longrightarrow>\n    (mk_eqcl' (x # xs) i j l T ! j' = Some l) =\n    (\\<not> tr_lookup T (j' + j) i)", "assume H: \"j' = 0\""], ["proof (state)\nthis:\n  j' = 0\n\ngoal (1 subgoal):\n 1. j' = 0 \\<Longrightarrow>\n    (mk_eqcl' (x # xs) i j l T ! j' = Some l) =\n    (\\<not> tr_lookup T (j' + j) i)", "with Cons(3)[of 0]"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < length (x # xs); \\<not> tr_lookup T (0 + j) i\\<rbrakk>\n  \\<Longrightarrow> (x # xs) ! 0 = None\n  j' = 0", "have \"\\<not> tr_lookup T j i \\<Longrightarrow> x = None\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < length (x # xs); \\<not> tr_lookup T (0 + j) i\\<rbrakk>\n  \\<Longrightarrow> (x # xs) ! 0 = None\n  j' = 0\n\ngoal (1 subgoal):\n 1. \\<not> tr_lookup T j i \\<Longrightarrow> x = None", "by simp"], ["proof (state)\nthis:\n  \\<not> tr_lookup T j i \\<Longrightarrow> x = None\n\ngoal (1 subgoal):\n 1. j' = 0 \\<Longrightarrow>\n    (mk_eqcl' (x # xs) i j l T ! j' = Some l) =\n    (\\<not> tr_lookup T (j' + j) i)", "with Cons H"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x k.\n              \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n              \\<Longrightarrow> k < l;\n   \\<And>i'.\n      \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + ?j) i\\<rbrakk>\n      \\<Longrightarrow> xs ! i' = None;\n   i < ?j; ?j' < length xs\\<rbrakk>\n  \\<Longrightarrow> (mk_eqcl' xs i ?j l T ! ?j' = Some l) =\n                    (\\<not> tr_lookup T (?j' + ?j) i)\n  \\<lbrakk>?x \\<in> set (x # xs); ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < l\n  \\<lbrakk>?i' < length (x # xs); \\<not> tr_lookup T (?i' + j) i\\<rbrakk>\n  \\<Longrightarrow> (x # xs) ! ?i' = None\n  i < j\n  j' < length (x # xs)\n  j' = 0\n  \\<not> tr_lookup T j i \\<Longrightarrow> x = None", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x k.\n              \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n              \\<Longrightarrow> k < l;\n   \\<And>i'.\n      \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + ?j) i\\<rbrakk>\n      \\<Longrightarrow> xs ! i' = None;\n   i < ?j; ?j' < length xs\\<rbrakk>\n  \\<Longrightarrow> (mk_eqcl' xs i ?j l T ! ?j' = Some l) =\n                    (\\<not> tr_lookup T (?j' + ?j) i)\n  \\<lbrakk>?x \\<in> set (x # xs); ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < l\n  \\<lbrakk>?i' < length (x # xs); \\<not> tr_lookup T (?i' + j) i\\<rbrakk>\n  \\<Longrightarrow> (x # xs) ! ?i' = None\n  i < j\n  j' < length (x # xs)\n  j' = 0\n  \\<not> tr_lookup T j i \\<Longrightarrow> x = None\n\ngoal (1 subgoal):\n 1. (mk_eqcl' (x # xs) i j l T ! j' = Some l) =\n    (\\<not> tr_lookup T (j' + j) i)", "by auto"], ["proof (state)\nthis:\n  (mk_eqcl' (x # xs) i j l T ! j' = Some l) =\n  (\\<not> tr_lookup T (j' + j) i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (mk_eqcl' (x # xs) i j l T ! j' = Some l) =\n  (\\<not> tr_lookup T (j' + j) i)\n\ngoal (1 subgoal):\n 1. \\<And>j j'.\n       \\<lbrakk>\\<And>x k.\n                   \\<lbrakk>x \\<in> set []; x = Some k\\<rbrakk>\n                   \\<Longrightarrow> k < l;\n        \\<And>i'.\n           \\<lbrakk>i' < length []; \\<not> tr_lookup T (i' + j) i\\<rbrakk>\n           \\<Longrightarrow> [] ! i' = None;\n        i < j; j' < length []\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' [] i j l T ! j' = Some l) =\n                         (\\<not> tr_lookup T (j' + j) i)", "qed simp"], ["", "lemma mk_eqcl'_nth:\n  assumes \"\\<And>i' j' k. \\<lbrakk>i' < length xs; j' < length xs; xs ! i' = Some k\\<rbrakk> \\<Longrightarrow> (xs ! j' = Some k) = (\\<not> tr_lookup T (i' + jj) (j' + jj))\"\n  and \"\\<And>a b c. \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T; \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk> \\<Longrightarrow> \\<not> tr_lookup T a c\"\n  and \"length xs + jj = length T + 1\"\n  and \"\\<And>x k. \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk> \\<Longrightarrow> k < l\"\n  and \"\\<And>i'. \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + jj) ii\\<rbrakk> \\<Longrightarrow> xs ! i' = None\"\n  and \"ii < jj\"\n  and \"i < length xs\" and \"mk_eqcl' xs ii jj l T ! i = Some m\"\n  and \"j < length xs\"\n  shows \"(mk_eqcl' xs ii jj l T ! j = Some m) = (\\<not> tr_lookup T (i + jj) (j + jj))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mk_eqcl' xs ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i' < length xs; ?j' < length xs; xs ! ?i' = Some ?k\\<rbrakk>\n  \\<Longrightarrow> (xs ! ?j' = Some ?k) =\n                    (\\<not> tr_lookup T (?i' + jj) (?j' + jj))\n  \\<lbrakk>?a \\<le> length T; ?b \\<le> length T; ?c \\<le> length T;\n   \\<not> tr_lookup T ?a ?b; \\<not> tr_lookup T ?b ?c\\<rbrakk>\n  \\<Longrightarrow> \\<not> tr_lookup T ?a ?c\n  length xs + jj = length T + 1\n  \\<lbrakk>?x \\<in> set xs; ?x = Some ?k\\<rbrakk> \\<Longrightarrow> ?k < l\n  \\<lbrakk>?i' < length xs; \\<not> tr_lookup T (?i' + jj) ii\\<rbrakk>\n  \\<Longrightarrow> xs ! ?i' = None\n  ii < jj\n  i < length xs\n  mk_eqcl' xs ii jj l T ! i = Some m\n  j < length xs\n\ngoal (1 subgoal):\n 1. (mk_eqcl' xs ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "proof (induct xs arbitrary: jj i j)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>jj i j.\n       \\<lbrakk>\\<And>i' j' k.\n                   \\<lbrakk>i' < length []; j' < length [];\n                    [] ! i' = Some k\\<rbrakk>\n                   \\<Longrightarrow> ([] ! j' = Some k) =\n                                     (\\<not> tr_lookup T (i' + jj)\n        (j' + jj));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        length [] + jj = length T + 1;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set []; x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < l;\n        \\<And>i'.\n           \\<lbrakk>i' < length []; \\<not> tr_lookup T (i' + jj) ii\\<rbrakk>\n           \\<Longrightarrow> [] ! i' = None;\n        ii < jj; i < length []; mk_eqcl' [] ii jj l T ! i = Some m;\n        j < length []\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' [] ii jj l T ! j = Some m) =\n                         (\\<not> tr_lookup T (i + jj) (j + jj))\n 2. \\<And>a xs jj i j.\n       \\<lbrakk>\\<And>jj i j.\n                   \\<lbrakk>\\<And>i' j' k.\n                               \\<lbrakk>i' < length xs; j' < length xs;\n                                xs ! i' = Some k\\<rbrakk>\n                               \\<Longrightarrow> (xs ! j' = Some k) =\n           (\\<not> tr_lookup T (i' + jj) (j' + jj));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    length xs + jj = length T + 1;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < l;\n                    \\<And>i'.\n                       \\<lbrakk>i' < length xs;\n                        \\<not> tr_lookup T (i' + jj) ii\\<rbrakk>\n                       \\<Longrightarrow> xs ! i' = None;\n                    ii < jj; i < length xs;\n                    mk_eqcl' xs ii jj l T ! i = Some m;\n                    j < length xs\\<rbrakk>\n                   \\<Longrightarrow> (mk_eqcl' xs ii jj l T ! j = Some m) =\n                                     (\\<not> tr_lookup T (i + jj) (j + jj));\n        \\<And>i' j' k.\n           \\<lbrakk>i' < length (a # xs); j' < length (a # xs);\n            (a # xs) ! i' = Some k\\<rbrakk>\n           \\<Longrightarrow> ((a # xs) ! j' = Some k) =\n                             (\\<not> tr_lookup T (i' + jj) (j' + jj));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        length (a # xs) + jj = length T + 1;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (a # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < l;\n        \\<And>i'.\n           \\<lbrakk>i' < length (a # xs);\n            \\<not> tr_lookup T (i' + jj) ii\\<rbrakk>\n           \\<Longrightarrow> (a # xs) ! i' = None;\n        ii < jj; i < length (a # xs);\n        mk_eqcl' (a # xs) ii jj l T ! i = Some m;\n        j < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' (a # xs) ii jj l T ! j = Some m) =\n                         (\\<not> tr_lookup T (i + jj) (j + jj))", "case Nil"], ["proof (state)\nthis:\n  \\<lbrakk>?i' < length []; ?j' < length []; [] ! ?i' = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ([] ! ?j' = Some ?k) =\n                    (\\<not> tr_lookup T (?i' + jj) (?j' + jj))\n  \\<lbrakk>?a \\<le> length T; ?b \\<le> length T; ?c \\<le> length T;\n   \\<not> tr_lookup T ?a ?b; \\<not> tr_lookup T ?b ?c\\<rbrakk>\n  \\<Longrightarrow> \\<not> tr_lookup T ?a ?c\n  length [] + jj = length T + 1\n  \\<lbrakk>?x \\<in> set []; ?x = Some ?k\\<rbrakk> \\<Longrightarrow> ?k < l\n  \\<lbrakk>?i' < length []; \\<not> tr_lookup T (?i' + jj) ii\\<rbrakk>\n  \\<Longrightarrow> [] ! ?i' = None\n  ii < jj\n  i < length []\n  mk_eqcl' [] ii jj l T ! i = Some m\n  j < length []\n\ngoal (2 subgoals):\n 1. \\<And>jj i j.\n       \\<lbrakk>\\<And>i' j' k.\n                   \\<lbrakk>i' < length []; j' < length [];\n                    [] ! i' = Some k\\<rbrakk>\n                   \\<Longrightarrow> ([] ! j' = Some k) =\n                                     (\\<not> tr_lookup T (i' + jj)\n        (j' + jj));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        length [] + jj = length T + 1;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set []; x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < l;\n        \\<And>i'.\n           \\<lbrakk>i' < length []; \\<not> tr_lookup T (i' + jj) ii\\<rbrakk>\n           \\<Longrightarrow> [] ! i' = None;\n        ii < jj; i < length []; mk_eqcl' [] ii jj l T ! i = Some m;\n        j < length []\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' [] ii jj l T ! j = Some m) =\n                         (\\<not> tr_lookup T (i + jj) (j + jj))\n 2. \\<And>a xs jj i j.\n       \\<lbrakk>\\<And>jj i j.\n                   \\<lbrakk>\\<And>i' j' k.\n                               \\<lbrakk>i' < length xs; j' < length xs;\n                                xs ! i' = Some k\\<rbrakk>\n                               \\<Longrightarrow> (xs ! j' = Some k) =\n           (\\<not> tr_lookup T (i' + jj) (j' + jj));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    length xs + jj = length T + 1;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < l;\n                    \\<And>i'.\n                       \\<lbrakk>i' < length xs;\n                        \\<not> tr_lookup T (i' + jj) ii\\<rbrakk>\n                       \\<Longrightarrow> xs ! i' = None;\n                    ii < jj; i < length xs;\n                    mk_eqcl' xs ii jj l T ! i = Some m;\n                    j < length xs\\<rbrakk>\n                   \\<Longrightarrow> (mk_eqcl' xs ii jj l T ! j = Some m) =\n                                     (\\<not> tr_lookup T (i + jj) (j + jj));\n        \\<And>i' j' k.\n           \\<lbrakk>i' < length (a # xs); j' < length (a # xs);\n            (a # xs) ! i' = Some k\\<rbrakk>\n           \\<Longrightarrow> ((a # xs) ! j' = Some k) =\n                             (\\<not> tr_lookup T (i' + jj) (j' + jj));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        length (a # xs) + jj = length T + 1;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (a # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < l;\n        \\<And>i'.\n           \\<lbrakk>i' < length (a # xs);\n            \\<not> tr_lookup T (i' + jj) ii\\<rbrakk>\n           \\<Longrightarrow> (a # xs) ! i' = None;\n        ii < jj; i < length (a # xs);\n        mk_eqcl' (a # xs) ii jj l T ! i = Some m;\n        j < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' (a # xs) ii jj l T ! j = Some m) =\n                         (\\<not> tr_lookup T (i + jj) (j + jj))", "from Nil(7)"], ["proof (chain)\npicking this:\n  i < length []", "have False"], ["proof (prove)\nusing this:\n  i < length []\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>jj i j.\n       \\<lbrakk>\\<And>i' j' k.\n                   \\<lbrakk>i' < length []; j' < length [];\n                    [] ! i' = Some k\\<rbrakk>\n                   \\<Longrightarrow> ([] ! j' = Some k) =\n                                     (\\<not> tr_lookup T (i' + jj)\n        (j' + jj));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        length [] + jj = length T + 1;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set []; x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < l;\n        \\<And>i'.\n           \\<lbrakk>i' < length []; \\<not> tr_lookup T (i' + jj) ii\\<rbrakk>\n           \\<Longrightarrow> [] ! i' = None;\n        ii < jj; i < length []; mk_eqcl' [] ii jj l T ! i = Some m;\n        j < length []\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' [] ii jj l T ! j = Some m) =\n                         (\\<not> tr_lookup T (i + jj) (j + jj))\n 2. \\<And>a xs jj i j.\n       \\<lbrakk>\\<And>jj i j.\n                   \\<lbrakk>\\<And>i' j' k.\n                               \\<lbrakk>i' < length xs; j' < length xs;\n                                xs ! i' = Some k\\<rbrakk>\n                               \\<Longrightarrow> (xs ! j' = Some k) =\n           (\\<not> tr_lookup T (i' + jj) (j' + jj));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    length xs + jj = length T + 1;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < l;\n                    \\<And>i'.\n                       \\<lbrakk>i' < length xs;\n                        \\<not> tr_lookup T (i' + jj) ii\\<rbrakk>\n                       \\<Longrightarrow> xs ! i' = None;\n                    ii < jj; i < length xs;\n                    mk_eqcl' xs ii jj l T ! i = Some m;\n                    j < length xs\\<rbrakk>\n                   \\<Longrightarrow> (mk_eqcl' xs ii jj l T ! j = Some m) =\n                                     (\\<not> tr_lookup T (i + jj) (j + jj));\n        \\<And>i' j' k.\n           \\<lbrakk>i' < length (a # xs); j' < length (a # xs);\n            (a # xs) ! i' = Some k\\<rbrakk>\n           \\<Longrightarrow> ((a # xs) ! j' = Some k) =\n                             (\\<not> tr_lookup T (i' + jj) (j' + jj));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        length (a # xs) + jj = length T + 1;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (a # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < l;\n        \\<And>i'.\n           \\<lbrakk>i' < length (a # xs);\n            \\<not> tr_lookup T (i' + jj) ii\\<rbrakk>\n           \\<Longrightarrow> (a # xs) ! i' = None;\n        ii < jj; i < length (a # xs);\n        mk_eqcl' (a # xs) ii jj l T ! i = Some m;\n        j < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' (a # xs) ii jj l T ! j = Some m) =\n                         (\\<not> tr_lookup T (i + jj) (j + jj))", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. (mk_eqcl' [] ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "by simp"], ["proof (state)\nthis:\n  (mk_eqcl' [] ii jj l T ! j = Some m) =\n  (\\<not> tr_lookup T (i + jj) (j + jj))\n\ngoal (1 subgoal):\n 1. \\<And>a xs jj i j.\n       \\<lbrakk>\\<And>jj i j.\n                   \\<lbrakk>\\<And>i' j' k.\n                               \\<lbrakk>i' < length xs; j' < length xs;\n                                xs ! i' = Some k\\<rbrakk>\n                               \\<Longrightarrow> (xs ! j' = Some k) =\n           (\\<not> tr_lookup T (i' + jj) (j' + jj));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    length xs + jj = length T + 1;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < l;\n                    \\<And>i'.\n                       \\<lbrakk>i' < length xs;\n                        \\<not> tr_lookup T (i' + jj) ii\\<rbrakk>\n                       \\<Longrightarrow> xs ! i' = None;\n                    ii < jj; i < length xs;\n                    mk_eqcl' xs ii jj l T ! i = Some m;\n                    j < length xs\\<rbrakk>\n                   \\<Longrightarrow> (mk_eqcl' xs ii jj l T ! j = Some m) =\n                                     (\\<not> tr_lookup T (i + jj) (j + jj));\n        \\<And>i' j' k.\n           \\<lbrakk>i' < length (a # xs); j' < length (a # xs);\n            (a # xs) ! i' = Some k\\<rbrakk>\n           \\<Longrightarrow> ((a # xs) ! j' = Some k) =\n                             (\\<not> tr_lookup T (i' + jj) (j' + jj));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        length (a # xs) + jj = length T + 1;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (a # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < l;\n        \\<And>i'.\n           \\<lbrakk>i' < length (a # xs);\n            \\<not> tr_lookup T (i' + jj) ii\\<rbrakk>\n           \\<Longrightarrow> (a # xs) ! i' = None;\n        ii < jj; i < length (a # xs);\n        mk_eqcl' (a # xs) ii jj l T ! i = Some m;\n        j < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' (a # xs) ii jj l T ! j = Some m) =\n                         (\\<not> tr_lookup T (i + jj) (j + jj))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs jj i j.\n       \\<lbrakk>\\<And>jj i j.\n                   \\<lbrakk>\\<And>i' j' k.\n                               \\<lbrakk>i' < length xs; j' < length xs;\n                                xs ! i' = Some k\\<rbrakk>\n                               \\<Longrightarrow> (xs ! j' = Some k) =\n           (\\<not> tr_lookup T (i' + jj) (j' + jj));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    length xs + jj = length T + 1;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < l;\n                    \\<And>i'.\n                       \\<lbrakk>i' < length xs;\n                        \\<not> tr_lookup T (i' + jj) ii\\<rbrakk>\n                       \\<Longrightarrow> xs ! i' = None;\n                    ii < jj; i < length xs;\n                    mk_eqcl' xs ii jj l T ! i = Some m;\n                    j < length xs\\<rbrakk>\n                   \\<Longrightarrow> (mk_eqcl' xs ii jj l T ! j = Some m) =\n                                     (\\<not> tr_lookup T (i + jj) (j + jj));\n        \\<And>i' j' k.\n           \\<lbrakk>i' < length (a # xs); j' < length (a # xs);\n            (a # xs) ! i' = Some k\\<rbrakk>\n           \\<Longrightarrow> ((a # xs) ! j' = Some k) =\n                             (\\<not> tr_lookup T (i' + jj) (j' + jj));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        length (a # xs) + jj = length T + 1;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (a # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < l;\n        \\<And>i'.\n           \\<lbrakk>i' < length (a # xs);\n            \\<not> tr_lookup T (i' + jj) ii\\<rbrakk>\n           \\<Longrightarrow> (a # xs) ! i' = None;\n        ii < jj; i < length (a # xs);\n        mk_eqcl' (a # xs) ii jj l T ! i = Some m;\n        j < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' (a # xs) ii jj l T ! j = Some m) =\n                         (\\<not> tr_lookup T (i + jj) (j + jj))", "case (Cons y xs jj i j)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>i' j' k.\n              \\<lbrakk>i' < length xs; j' < length xs;\n               xs ! i' = Some k\\<rbrakk>\n              \\<Longrightarrow> (xs ! j' = Some k) =\n                                (\\<not> tr_lookup T (i' + ?jj) (j' + ?jj));\n   \\<And>a b c.\n      \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n       \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n      \\<Longrightarrow> \\<not> tr_lookup T a c;\n   length xs + ?jj = length T + 1;\n   \\<And>x k.\n      \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk> \\<Longrightarrow> k < l;\n   \\<And>i'.\n      \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + ?jj) ii\\<rbrakk>\n      \\<Longrightarrow> xs ! i' = None;\n   ii < ?jj; ?i < length xs; mk_eqcl' xs ii ?jj l T ! ?i = Some m;\n   ?j < length xs\\<rbrakk>\n  \\<Longrightarrow> (mk_eqcl' xs ii ?jj l T ! ?j = Some m) =\n                    (\\<not> tr_lookup T (?i + ?jj) (?j + ?jj))\n  \\<lbrakk>?i' < length (y # xs); ?j' < length (y # xs);\n   (y # xs) ! ?i' = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ((y # xs) ! ?j' = Some ?k) =\n                    (\\<not> tr_lookup T (?i' + jj) (?j' + jj))\n  \\<lbrakk>?a \\<le> length T; ?b \\<le> length T; ?c \\<le> length T;\n   \\<not> tr_lookup T ?a ?b; \\<not> tr_lookup T ?b ?c\\<rbrakk>\n  \\<Longrightarrow> \\<not> tr_lookup T ?a ?c\n  length (y # xs) + jj = length T + 1\n  \\<lbrakk>?x \\<in> set (y # xs); ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < l\n  \\<lbrakk>?i' < length (y # xs); \\<not> tr_lookup T (?i' + jj) ii\\<rbrakk>\n  \\<Longrightarrow> (y # xs) ! ?i' = None\n  ii < jj\n  i < length (y # xs)\n  mk_eqcl' (y # xs) ii jj l T ! i = Some m\n  j < length (y # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs jj i j.\n       \\<lbrakk>\\<And>jj i j.\n                   \\<lbrakk>\\<And>i' j' k.\n                               \\<lbrakk>i' < length xs; j' < length xs;\n                                xs ! i' = Some k\\<rbrakk>\n                               \\<Longrightarrow> (xs ! j' = Some k) =\n           (\\<not> tr_lookup T (i' + jj) (j' + jj));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    length xs + jj = length T + 1;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < l;\n                    \\<And>i'.\n                       \\<lbrakk>i' < length xs;\n                        \\<not> tr_lookup T (i' + jj) ii\\<rbrakk>\n                       \\<Longrightarrow> xs ! i' = None;\n                    ii < jj; i < length xs;\n                    mk_eqcl' xs ii jj l T ! i = Some m;\n                    j < length xs\\<rbrakk>\n                   \\<Longrightarrow> (mk_eqcl' xs ii jj l T ! j = Some m) =\n                                     (\\<not> tr_lookup T (i + jj) (j + jj));\n        \\<And>i' j' k.\n           \\<lbrakk>i' < length (a # xs); j' < length (a # xs);\n            (a # xs) ! i' = Some k\\<rbrakk>\n           \\<Longrightarrow> ((a # xs) ! j' = Some k) =\n                             (\\<not> tr_lookup T (i' + jj) (j' + jj));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        length (a # xs) + jj = length T + 1;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (a # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < l;\n        \\<And>i'.\n           \\<lbrakk>i' < length (a # xs);\n            \\<not> tr_lookup T (i' + jj) ii\\<rbrakk>\n           \\<Longrightarrow> (a # xs) ! i' = None;\n        ii < jj; i < length (a # xs);\n        mk_eqcl' (a # xs) ii jj l T ! i = Some m;\n        j < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' (a # xs) ii jj l T ! j = Some m) =\n                         (\\<not> tr_lookup T (i + jj) (j + jj))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "proof (cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n       (\\<not> tr_lookup T (i + jj) (j + jj))", "case 0"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n       (\\<not> tr_lookup T (i + jj) (j + jj))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "proof (cases j)"], ["proof (state)\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))\n 2. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n       (\\<not> tr_lookup T (i + jj) (j + jj))", "case 0"], ["proof (state)\nthis:\n  j = 0\n\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))\n 2. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n       (\\<not> tr_lookup T (i + jj) (j + jj))", "with \\<open>i=0\\<close> Cons(9)"], ["proof (chain)\npicking this:\n  i = 0\n  mk_eqcl' (y # xs) ii jj l T ! i = Some m\n  j = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  i = 0\n  mk_eqcl' (y # xs) ii jj l T ! i = Some m\n  j = 0\n\ngoal (1 subgoal):\n 1. (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "by (simp add: tr_lookup_def)"], ["proof (state)\nthis:\n  (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n  (\\<not> tr_lookup T (i + jj) (j + jj))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n       (\\<not> tr_lookup T (i + jj) (j + jj))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n       (\\<not> tr_lookup T (i + jj) (j + jj))", "case (Suc j')"], ["proof (state)\nthis:\n  j = Suc j'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n       (\\<not> tr_lookup T (i + jj) (j + jj))", "from 0 Cons(5,9)"], ["proof (chain)\npicking this:\n  i = 0\n  \\<lbrakk>?x \\<in> set (y # xs); ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < l\n  mk_eqcl' (y # xs) ii jj l T ! i = Some m", "have 1: \"y = Some m \\<and> m < l \\<or> (y = None \\<and> \\<not> tr_lookup T jj ii \\<and> m = l)\""], ["proof (prove)\nusing this:\n  i = 0\n  \\<lbrakk>?x \\<in> set (y # xs); ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < l\n  mk_eqcl' (y # xs) ii jj l T ! i = Some m\n\ngoal (1 subgoal):\n 1. y = Some m \\<and> m < l \\<or>\n    y = None \\<and> \\<not> tr_lookup T jj ii \\<and> m = l", "by (cases y, cases \"tr_lookup T jj ii\", auto)"], ["proof (state)\nthis:\n  y = Some m \\<and> m < l \\<or>\n  y = None \\<and> \\<not> tr_lookup T jj ii \\<and> m = l\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n       (\\<not> tr_lookup T (i + jj) (j + jj))", "thus ?thesis"], ["proof (prove)\nusing this:\n  y = Some m \\<and> m < l \\<or>\n  y = None \\<and> \\<not> tr_lookup T jj ii \\<and> m = l\n\ngoal (1 subgoal):\n 1. (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "proof (elim disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. y = Some m \\<and> m < l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))\n 2. y = None \\<and> \\<not> tr_lookup T jj ii \\<and> m = l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "assume H: \"y = Some m \\<and> m < l\""], ["proof (state)\nthis:\n  y = Some m \\<and> m < l\n\ngoal (2 subgoals):\n 1. y = Some m \\<and> m < l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))\n 2. y = None \\<and> \\<not> tr_lookup T jj ii \\<and> m = l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "from Suc"], ["proof (chain)\npicking this:\n  j = Suc j'", "have \"(mk_eqcl' (y # xs) ii jj l T ! j = Some m) = (mk_eqcl' xs ii (Suc jj) l T ! j' = Some m)\""], ["proof (prove)\nusing this:\n  j = Suc j'\n\ngoal (1 subgoal):\n 1. (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (mk_eqcl' xs ii (Suc jj) l T ! j' = Some m)", "by simp"], ["proof (state)\nthis:\n  (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n  (mk_eqcl' xs ii (Suc jj) l T ! j' = Some m)\n\ngoal (2 subgoals):\n 1. y = Some m \\<and> m < l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))\n 2. y = None \\<and> \\<not> tr_lookup T jj ii \\<and> m = l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "also"], ["proof (state)\nthis:\n  (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n  (mk_eqcl' xs ii (Suc jj) l T ! j' = Some m)\n\ngoal (2 subgoals):\n 1. y = Some m \\<and> m < l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))\n 2. y = None \\<and> \\<not> tr_lookup T jj ii \\<and> m = l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "from H"], ["proof (chain)\npicking this:\n  y = Some m \\<and> m < l", "have \"\\<dots> = (xs ! j' = Some m)\""], ["proof (prove)\nusing this:\n  y = Some m \\<and> m < l\n\ngoal (1 subgoal):\n 1. (mk_eqcl' xs ii (Suc jj) l T ! j' = Some m) = (xs ! j' = Some m)", "proof (induct xs arbitrary: jj j')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>jj j'.\n       y = Some m \\<and> m < l \\<Longrightarrow>\n       (mk_eqcl' [] ii (Suc jj) l T ! j' = Some m) = ([] ! j' = Some m)\n 2. \\<And>a xs jj j'.\n       \\<lbrakk>\\<And>jj j'.\n                   y = Some m \\<and> m < l \\<Longrightarrow>\n                   (mk_eqcl' xs ii (Suc jj) l T ! j' = Some m) =\n                   (xs ! j' = Some m);\n        y = Some m \\<and> m < l\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' (a # xs) ii (Suc jj) l T ! j' = Some m) =\n                         ((a # xs) ! j' = Some m)", "case (Cons a xs jj j')"], ["proof (state)\nthis:\n  y = Some m \\<and> m < l \\<Longrightarrow>\n  (mk_eqcl' xs ii (Suc ?jj) l T ! ?j' = Some m) = (xs ! ?j' = Some m)\n  y = Some m \\<and> m < l\n\ngoal (2 subgoals):\n 1. \\<And>jj j'.\n       y = Some m \\<and> m < l \\<Longrightarrow>\n       (mk_eqcl' [] ii (Suc jj) l T ! j' = Some m) = ([] ! j' = Some m)\n 2. \\<And>a xs jj j'.\n       \\<lbrakk>\\<And>jj j'.\n                   y = Some m \\<and> m < l \\<Longrightarrow>\n                   (mk_eqcl' xs ii (Suc jj) l T ! j' = Some m) =\n                   (xs ! j' = Some m);\n        y = Some m \\<and> m < l\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' (a # xs) ii (Suc jj) l T ! j' = Some m) =\n                         ((a # xs) ! j' = Some m)", "thus ?case"], ["proof (prove)\nusing this:\n  y = Some m \\<and> m < l \\<Longrightarrow>\n  (mk_eqcl' xs ii (Suc ?jj) l T ! ?j' = Some m) = (xs ! ?j' = Some m)\n  y = Some m \\<and> m < l\n\ngoal (1 subgoal):\n 1. (mk_eqcl' (a # xs) ii (Suc jj) l T ! j' = Some m) =\n    ((a # xs) ! j' = Some m)", "by (cases j') simp+"], ["proof (state)\nthis:\n  (mk_eqcl' (a # xs) ii (Suc jj) l T ! j' = Some m) =\n  ((a # xs) ! j' = Some m)\n\ngoal (1 subgoal):\n 1. \\<And>jj j'.\n       y = Some m \\<and> m < l \\<Longrightarrow>\n       (mk_eqcl' [] ii (Suc jj) l T ! j' = Some m) = ([] ! j' = Some m)", "qed simp"], ["proof (state)\nthis:\n  (mk_eqcl' xs ii (Suc jj) l T ! j' = Some m) = (xs ! j' = Some m)\n\ngoal (2 subgoals):\n 1. y = Some m \\<and> m < l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))\n 2. y = None \\<and> \\<not> tr_lookup T jj ii \\<and> m = l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "also"], ["proof (state)\nthis:\n  (mk_eqcl' xs ii (Suc jj) l T ! j' = Some m) = (xs ! j' = Some m)\n\ngoal (2 subgoals):\n 1. y = Some m \\<and> m < l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))\n 2. y = None \\<and> \\<not> tr_lookup T jj ii \\<and> m = l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "from Suc"], ["proof (chain)\npicking this:\n  j = Suc j'", "have \"\\<dots> = ((y # xs) ! j = Some m)\""], ["proof (prove)\nusing this:\n  j = Suc j'\n\ngoal (1 subgoal):\n 1. (xs ! j' = Some m) = ((y # xs) ! j = Some m)", "by simp"], ["proof (state)\nthis:\n  (xs ! j' = Some m) = ((y # xs) ! j = Some m)\n\ngoal (2 subgoals):\n 1. y = Some m \\<and> m < l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))\n 2. y = None \\<and> \\<not> tr_lookup T jj ii \\<and> m = l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "also"], ["proof (state)\nthis:\n  (xs ! j' = Some m) = ((y # xs) ! j = Some m)\n\ngoal (2 subgoals):\n 1. y = Some m \\<and> m < l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))\n 2. y = None \\<and> \\<not> tr_lookup T jj ii \\<and> m = l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "from Cons(2)[of i j m] Cons(8,10) Suc 0 H"], ["proof (chain)\npicking this:\n  \\<lbrakk>i < length (y # xs); j < length (y # xs);\n   (y # xs) ! i = Some m\\<rbrakk>\n  \\<Longrightarrow> ((y # xs) ! j = Some m) =\n                    (\\<not> tr_lookup T (i + jj) (j + jj))\n  i < length (y # xs)\n  j < length (y # xs)\n  j = Suc j'\n  i = 0\n  y = Some m \\<and> m < l", "have \"\\<dots> = (\\<not> tr_lookup T (i + jj) (j + jj))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>i < length (y # xs); j < length (y # xs);\n   (y # xs) ! i = Some m\\<rbrakk>\n  \\<Longrightarrow> ((y # xs) ! j = Some m) =\n                    (\\<not> tr_lookup T (i + jj) (j + jj))\n  i < length (y # xs)\n  j < length (y # xs)\n  j = Suc j'\n  i = 0\n  y = Some m \\<and> m < l\n\ngoal (1 subgoal):\n 1. ((y # xs) ! j = Some m) = (\\<not> tr_lookup T (i + jj) (j + jj))", "by simp"], ["proof (state)\nthis:\n  ((y # xs) ! j = Some m) = (\\<not> tr_lookup T (i + jj) (j + jj))\n\ngoal (2 subgoals):\n 1. y = Some m \\<and> m < l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))\n 2. y = None \\<and> \\<not> tr_lookup T jj ii \\<and> m = l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "finally"], ["proof (chain)\npicking this:\n  (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n  (\\<not> tr_lookup T (i + jj) (j + jj))", "show ?thesis"], ["proof (prove)\nusing this:\n  (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n  (\\<not> tr_lookup T (i + jj) (j + jj))\n\ngoal (1 subgoal):\n 1. (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "by simp"], ["proof (state)\nthis:\n  (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n  (\\<not> tr_lookup T (i + jj) (j + jj))\n\ngoal (1 subgoal):\n 1. y = None \\<and> \\<not> tr_lookup T jj ii \\<and> m = l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y = None \\<and> \\<not> tr_lookup T jj ii \\<and> m = l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "assume H: \"y = None \\<and> \\<not> tr_lookup T jj ii \\<and> m = l\""], ["proof (state)\nthis:\n  y = None \\<and> \\<not> tr_lookup T jj ii \\<and> m = l\n\ngoal (1 subgoal):\n 1. y = None \\<and> \\<not> tr_lookup T jj ii \\<and> m = l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "with Suc"], ["proof (chain)\npicking this:\n  j = Suc j'\n  y = None \\<and> \\<not> tr_lookup T jj ii \\<and> m = l", "have \"(mk_eqcl' (y # xs) ii jj l T ! j = Some m) = (mk_eqcl' xs ii (Suc jj) l T ! j' = Some l)\""], ["proof (prove)\nusing this:\n  j = Suc j'\n  y = None \\<and> \\<not> tr_lookup T jj ii \\<and> m = l\n\ngoal (1 subgoal):\n 1. (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (mk_eqcl' xs ii (Suc jj) l T ! j' = Some l)", "by simp"], ["proof (state)\nthis:\n  (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n  (mk_eqcl' xs ii (Suc jj) l T ! j' = Some l)\n\ngoal (1 subgoal):\n 1. y = None \\<and> \\<not> tr_lookup T jj ii \\<and> m = l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "also"], ["proof (state)\nthis:\n  (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n  (mk_eqcl' xs ii (Suc jj) l T ! j' = Some l)\n\ngoal (1 subgoal):\n 1. y = None \\<and> \\<not> tr_lookup T jj ii \\<and> m = l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "have \"\\<dots> = (\\<not> tr_lookup T (j' + Suc jj) ii)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mk_eqcl' xs ii (Suc jj) l T ! j' = Some l) =\n    (\\<not> tr_lookup T (j' + Suc jj) ii)", "proof (rule mk_eqcl'_nth')"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x k.\n       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk> \\<Longrightarrow> k < l\n 2. \\<And>i'.\n       \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc jj) ii\\<rbrakk>\n       \\<Longrightarrow> xs ! i' = None\n 3. ii < Suc jj\n 4. j' < length xs", "from Cons(5)"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<in> set (y # xs); ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < l", "show \"\\<And>x k. \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk> \\<Longrightarrow> k < l\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set (y # xs); ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < l\n\ngoal (1 subgoal):\n 1. \\<And>x k.\n       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk> \\<Longrightarrow> k < l", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> set xs; ?x = Some ?k\\<rbrakk> \\<Longrightarrow> ?k < l\n\ngoal (3 subgoals):\n 1. \\<And>i'.\n       \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc jj) ii\\<rbrakk>\n       \\<Longrightarrow> xs ! i' = None\n 2. ii < Suc jj\n 3. j' < length xs", "show \"\\<And>i'. \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc jj) ii\\<rbrakk> \\<Longrightarrow> xs ! i' = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i'.\n       \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc jj) ii\\<rbrakk>\n       \\<Longrightarrow> xs ! i' = None", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i'.\n       \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc jj) ii\\<rbrakk>\n       \\<Longrightarrow> xs ! i' = None", "fix i'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i'.\n       \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc jj) ii\\<rbrakk>\n       \\<Longrightarrow> xs ! i' = None", "assume \"i' < length xs\" \"\\<not> tr_lookup T (i' + Suc jj) ii\""], ["proof (state)\nthis:\n  i' < length xs\n  \\<not> tr_lookup T (i' + Suc jj) ii\n\ngoal (1 subgoal):\n 1. \\<And>i'.\n       \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc jj) ii\\<rbrakk>\n       \\<Longrightarrow> xs ! i' = None", "with Cons(6)[of \"Suc i'\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>Suc i' < length (y # xs);\n   \\<not> tr_lookup T (Suc i' + jj) ii\\<rbrakk>\n  \\<Longrightarrow> (y # xs) ! Suc i' = None\n  i' < length xs\n  \\<not> tr_lookup T (i' + Suc jj) ii", "show \"xs ! i' = None\""], ["proof (prove)\nusing this:\n  \\<lbrakk>Suc i' < length (y # xs);\n   \\<not> tr_lookup T (Suc i' + jj) ii\\<rbrakk>\n  \\<Longrightarrow> (y # xs) ! Suc i' = None\n  i' < length xs\n  \\<not> tr_lookup T (i' + Suc jj) ii\n\ngoal (1 subgoal):\n 1. xs ! i' = None", "by simp"], ["proof (state)\nthis:\n  xs ! i' = None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?i' < length xs; \\<not> tr_lookup T (?i' + Suc jj) ii\\<rbrakk>\n  \\<Longrightarrow> xs ! ?i' = None\n\ngoal (2 subgoals):\n 1. ii < Suc jj\n 2. j' < length xs", "from Cons(7)"], ["proof (chain)\npicking this:\n  ii < jj", "show \"ii < Suc jj\""], ["proof (prove)\nusing this:\n  ii < jj\n\ngoal (1 subgoal):\n 1. ii < Suc jj", "by simp"], ["proof (state)\nthis:\n  ii < Suc jj\n\ngoal (1 subgoal):\n 1. j' < length xs", "from Cons(10) Suc"], ["proof (chain)\npicking this:\n  j < length (y # xs)\n  j = Suc j'", "show \"j' < length xs\""], ["proof (prove)\nusing this:\n  j < length (y # xs)\n  j = Suc j'\n\ngoal (1 subgoal):\n 1. j' < length xs", "by simp"], ["proof (state)\nthis:\n  j' < length xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (mk_eqcl' xs ii (Suc jj) l T ! j' = Some l) =\n  (\\<not> tr_lookup T (j' + Suc jj) ii)\n\ngoal (1 subgoal):\n 1. y = None \\<and> \\<not> tr_lookup T jj ii \\<and> m = l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "also"], ["proof (state)\nthis:\n  (mk_eqcl' xs ii (Suc jj) l T ! j' = Some l) =\n  (\\<not> tr_lookup T (j' + Suc jj) ii)\n\ngoal (1 subgoal):\n 1. y = None \\<and> \\<not> tr_lookup T jj ii \\<and> m = l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "from Suc H 0"], ["proof (chain)\npicking this:\n  j = Suc j'\n  y = None \\<and> \\<not> tr_lookup T jj ii \\<and> m = l\n  i = 0", "have \"\\<dots> = (\\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii)\""], ["proof (prove)\nusing this:\n  j = Suc j'\n  y = None \\<and> \\<not> tr_lookup T jj ii \\<and> m = l\n  i = 0\n\ngoal (1 subgoal):\n 1. (\\<not> tr_lookup T (j' + Suc jj) ii) =\n    (\\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii)", "by (simp add: add.commute)"], ["proof (state)\nthis:\n  (\\<not> tr_lookup T (j' + Suc jj) ii) =\n  (\\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii)\n\ngoal (1 subgoal):\n 1. y = None \\<and> \\<not> tr_lookup T jj ii \\<and> m = l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "also"], ["proof (state)\nthis:\n  (\\<not> tr_lookup T (j' + Suc jj) ii) =\n  (\\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii)\n\ngoal (1 subgoal):\n 1. y = None \\<and> \\<not> tr_lookup T jj ii \\<and> m = l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "have \"\\<dots> = (\\<not> tr_lookup T (i + jj) (j + jj) \\<and> \\<not> tr_lookup T (i + jj) ii)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii) =\n    (\\<not> tr_lookup T (i + jj) (j + jj) \\<and>\n     \\<not> tr_lookup T (i + jj) ii)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> tr_lookup T (j + jj) ii \\<and>\n    \\<not> tr_lookup T (i + jj) ii \\<Longrightarrow>\n    \\<not> tr_lookup T (i + jj) (j + jj) \\<and>\n    \\<not> tr_lookup T (i + jj) ii\n 2. \\<not> tr_lookup T (i + jj) (j + jj) \\<and>\n    \\<not> tr_lookup T (i + jj) ii \\<Longrightarrow>\n    \\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii", "assume H': \"\\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii\""], ["proof (state)\nthis:\n  \\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii\n\ngoal (2 subgoals):\n 1. \\<not> tr_lookup T (j + jj) ii \\<and>\n    \\<not> tr_lookup T (i + jj) ii \\<Longrightarrow>\n    \\<not> tr_lookup T (i + jj) (j + jj) \\<and>\n    \\<not> tr_lookup T (i + jj) ii\n 2. \\<not> tr_lookup T (i + jj) (j + jj) \\<and>\n    \\<not> tr_lookup T (i + jj) ii \\<Longrightarrow>\n    \\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii", "hence \"\\<not> tr_lookup T ii (j + jj)\""], ["proof (prove)\nusing this:\n  \\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii\n\ngoal (1 subgoal):\n 1. \\<not> tr_lookup T ii (j + jj)", "by (auto simp: tr_lookup_def)"], ["proof (state)\nthis:\n  \\<not> tr_lookup T ii (j + jj)\n\ngoal (2 subgoals):\n 1. \\<not> tr_lookup T (j + jj) ii \\<and>\n    \\<not> tr_lookup T (i + jj) ii \\<Longrightarrow>\n    \\<not> tr_lookup T (i + jj) (j + jj) \\<and>\n    \\<not> tr_lookup T (i + jj) ii\n 2. \\<not> tr_lookup T (i + jj) (j + jj) \\<and>\n    \\<not> tr_lookup T (i + jj) ii \\<Longrightarrow>\n    \\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii", "with H' Cons(3)[of \"i + jj\" ii \"j + jj\"] Cons(4,7,8,10)"], ["proof (chain)\npicking this:\n  \\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii\n  \\<lbrakk>i + jj \\<le> length T; ii \\<le> length T; j + jj \\<le> length T;\n   \\<not> tr_lookup T (i + jj) ii; \\<not> tr_lookup T ii (j + jj)\\<rbrakk>\n  \\<Longrightarrow> \\<not> tr_lookup T (i + jj) (j + jj)\n  length (y # xs) + jj = length T + 1\n  ii < jj\n  i < length (y # xs)\n  j < length (y # xs)\n  \\<not> tr_lookup T ii (j + jj)", "show \"\\<not> tr_lookup T (i + jj) (j + jj) \\<and> \\<not> tr_lookup T (i + jj) ii\""], ["proof (prove)\nusing this:\n  \\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii\n  \\<lbrakk>i + jj \\<le> length T; ii \\<le> length T; j + jj \\<le> length T;\n   \\<not> tr_lookup T (i + jj) ii; \\<not> tr_lookup T ii (j + jj)\\<rbrakk>\n  \\<Longrightarrow> \\<not> tr_lookup T (i + jj) (j + jj)\n  length (y # xs) + jj = length T + 1\n  ii < jj\n  i < length (y # xs)\n  j < length (y # xs)\n  \\<not> tr_lookup T ii (j + jj)\n\ngoal (1 subgoal):\n 1. \\<not> tr_lookup T (i + jj) (j + jj) \\<and>\n    \\<not> tr_lookup T (i + jj) ii", "by simp"], ["proof (state)\nthis:\n  \\<not> tr_lookup T (i + jj) (j + jj) \\<and> \\<not> tr_lookup T (i + jj) ii\n\ngoal (1 subgoal):\n 1. \\<not> tr_lookup T (i + jj) (j + jj) \\<and>\n    \\<not> tr_lookup T (i + jj) ii \\<Longrightarrow>\n    \\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> tr_lookup T (i + jj) (j + jj) \\<and>\n    \\<not> tr_lookup T (i + jj) ii \\<Longrightarrow>\n    \\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii", "assume H': \"\\<not> tr_lookup T (i + jj) (j + jj) \\<and> \\<not> tr_lookup T (i + jj) ii\""], ["proof (state)\nthis:\n  \\<not> tr_lookup T (i + jj) (j + jj) \\<and> \\<not> tr_lookup T (i + jj) ii\n\ngoal (1 subgoal):\n 1. \\<not> tr_lookup T (i + jj) (j + jj) \\<and>\n    \\<not> tr_lookup T (i + jj) ii \\<Longrightarrow>\n    \\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii", "hence \"\\<not> tr_lookup T (j + jj) (i + jj)\""], ["proof (prove)\nusing this:\n  \\<not> tr_lookup T (i + jj) (j + jj) \\<and> \\<not> tr_lookup T (i + jj) ii\n\ngoal (1 subgoal):\n 1. \\<not> tr_lookup T (j + jj) (i + jj)", "by (auto simp: tr_lookup_def)"], ["proof (state)\nthis:\n  \\<not> tr_lookup T (j + jj) (i + jj)\n\ngoal (1 subgoal):\n 1. \\<not> tr_lookup T (i + jj) (j + jj) \\<and>\n    \\<not> tr_lookup T (i + jj) ii \\<Longrightarrow>\n    \\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii", "with H' Cons(3)[of \"j + jj\" \"i + jj\" ii] Cons(4,7,8,10)"], ["proof (chain)\npicking this:\n  \\<not> tr_lookup T (i + jj) (j + jj) \\<and> \\<not> tr_lookup T (i + jj) ii\n  \\<lbrakk>j + jj \\<le> length T; i + jj \\<le> length T; ii \\<le> length T;\n   \\<not> tr_lookup T (j + jj) (i + jj);\n   \\<not> tr_lookup T (i + jj) ii\\<rbrakk>\n  \\<Longrightarrow> \\<not> tr_lookup T (j + jj) ii\n  length (y # xs) + jj = length T + 1\n  ii < jj\n  i < length (y # xs)\n  j < length (y # xs)\n  \\<not> tr_lookup T (j + jj) (i + jj)", "show \"\\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii\""], ["proof (prove)\nusing this:\n  \\<not> tr_lookup T (i + jj) (j + jj) \\<and> \\<not> tr_lookup T (i + jj) ii\n  \\<lbrakk>j + jj \\<le> length T; i + jj \\<le> length T; ii \\<le> length T;\n   \\<not> tr_lookup T (j + jj) (i + jj);\n   \\<not> tr_lookup T (i + jj) ii\\<rbrakk>\n  \\<Longrightarrow> \\<not> tr_lookup T (j + jj) ii\n  length (y # xs) + jj = length T + 1\n  ii < jj\n  i < length (y # xs)\n  j < length (y # xs)\n  \\<not> tr_lookup T (j + jj) (i + jj)\n\ngoal (1 subgoal):\n 1. \\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii", "by simp"], ["proof (state)\nthis:\n  \\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii) =\n  (\\<not> tr_lookup T (i + jj) (j + jj) \\<and>\n   \\<not> tr_lookup T (i + jj) ii)\n\ngoal (1 subgoal):\n 1. y = None \\<and> \\<not> tr_lookup T jj ii \\<and> m = l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "also"], ["proof (state)\nthis:\n  (\\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii) =\n  (\\<not> tr_lookup T (i + jj) (j + jj) \\<and>\n   \\<not> tr_lookup T (i + jj) ii)\n\ngoal (1 subgoal):\n 1. y = None \\<and> \\<not> tr_lookup T jj ii \\<and> m = l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "from 0 H"], ["proof (chain)\npicking this:\n  i = 0\n  y = None \\<and> \\<not> tr_lookup T jj ii \\<and> m = l", "have \"\\<dots> = (\\<not> tr_lookup T (i + jj) (j + jj))\""], ["proof (prove)\nusing this:\n  i = 0\n  y = None \\<and> \\<not> tr_lookup T jj ii \\<and> m = l\n\ngoal (1 subgoal):\n 1. (\\<not> tr_lookup T (i + jj) (j + jj) \\<and>\n     \\<not> tr_lookup T (i + jj) ii) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "by simp"], ["proof (state)\nthis:\n  (\\<not> tr_lookup T (i + jj) (j + jj) \\<and>\n   \\<not> tr_lookup T (i + jj) ii) =\n  (\\<not> tr_lookup T (i + jj) (j + jj))\n\ngoal (1 subgoal):\n 1. y = None \\<and> \\<not> tr_lookup T jj ii \\<and> m = l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "finally"], ["proof (chain)\npicking this:\n  (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n  (\\<not> tr_lookup T (i + jj) (j + jj))", "show ?thesis"], ["proof (prove)\nusing this:\n  (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n  (\\<not> tr_lookup T (i + jj) (j + jj))\n\ngoal (1 subgoal):\n 1. (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "by simp"], ["proof (state)\nthis:\n  (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n  (\\<not> tr_lookup T (i + jj) (j + jj))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n  (\\<not> tr_lookup T (i + jj) (j + jj))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n  (\\<not> tr_lookup T (i + jj) (j + jj))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n       (\\<not> tr_lookup T (i + jj) (j + jj))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n       (\\<not> tr_lookup T (i + jj) (j + jj))", "case (Suc i')"], ["proof (state)\nthis:\n  i = Suc i'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n       (\\<not> tr_lookup T (i + jj) (j + jj))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "proof (cases j)"], ["proof (state)\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))\n 2. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n       (\\<not> tr_lookup T (i + jj) (j + jj))", "case 0"], ["proof (state)\nthis:\n  j = 0\n\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))\n 2. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n       (\\<not> tr_lookup T (i + jj) (j + jj))", "have \"m \\<le> l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> l", "proof (rule mk_eqcl'_bound)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x k.\n       \\<lbrakk>x \\<in> set ?xs; x = Some k\\<rbrakk> \\<Longrightarrow> k < l\n 2. ?x \\<in> set (mk_eqcl' ?xs ?i ?j l ?T)\n 3. ?x = Some m", "from Cons(5)"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<in> set (y # xs); ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < l", "show \"\\<And>x k. \\<lbrakk>x \\<in> set (y # xs); x = Some k\\<rbrakk> \\<Longrightarrow> k < l\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set (y # xs); ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < l\n\ngoal (1 subgoal):\n 1. \\<And>x k.\n       \\<lbrakk>x \\<in> set (y # xs); x = Some k\\<rbrakk>\n       \\<Longrightarrow> k < l", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> set (y # xs); ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < l\n\ngoal (2 subgoals):\n 1. ?x \\<in> set (mk_eqcl' (y # xs) ?i ?j l ?T)\n 2. ?x = Some m", "from Cons(8)"], ["proof (chain)\npicking this:\n  i < length (y # xs)", "have \"i < length (mk_eqcl' (y # xs) ii jj l T)\""], ["proof (prove)\nusing this:\n  i < length (y # xs)\n\ngoal (1 subgoal):\n 1. i < length (mk_eqcl' (y # xs) ii jj l T)", "by (simp add: mk_eqcl'_len)"], ["proof (state)\nthis:\n  i < length (mk_eqcl' (y # xs) ii jj l T)\n\ngoal (2 subgoals):\n 1. ?x \\<in> set (mk_eqcl' (y # xs) ?i ?j l ?T)\n 2. ?x = Some m", "with Cons(9)"], ["proof (chain)\npicking this:\n  mk_eqcl' (y # xs) ii jj l T ! i = Some m\n  i < length (mk_eqcl' (y # xs) ii jj l T)", "have \"\\<exists>i < length (mk_eqcl' (y # xs) ii jj l T). mk_eqcl' (y # xs) ii jj l T ! i = Some m\""], ["proof (prove)\nusing this:\n  mk_eqcl' (y # xs) ii jj l T ! i = Some m\n  i < length (mk_eqcl' (y # xs) ii jj l T)\n\ngoal (1 subgoal):\n 1. \\<exists>i<length (mk_eqcl' (y # xs) ii jj l T).\n       mk_eqcl' (y # xs) ii jj l T ! i = Some m", "by blast"], ["proof (state)\nthis:\n  \\<exists>i<length (mk_eqcl' (y # xs) ii jj l T).\n     mk_eqcl' (y # xs) ii jj l T ! i = Some m\n\ngoal (2 subgoals):\n 1. ?x \\<in> set (mk_eqcl' (y # xs) ?i ?j l ?T)\n 2. ?x = Some m", "thus \"Some m \\<in> set (mk_eqcl' (y # xs) ii jj l T)\""], ["proof (prove)\nusing this:\n  \\<exists>i<length (mk_eqcl' (y # xs) ii jj l T).\n     mk_eqcl' (y # xs) ii jj l T ! i = Some m\n\ngoal (1 subgoal):\n 1. Some m \\<in> set (mk_eqcl' (y # xs) ii jj l T)", "by (simp only: in_set_conv_nth)"], ["proof (state)\nthis:\n  Some m \\<in> set (mk_eqcl' (y # xs) ii jj l T)\n\ngoal (1 subgoal):\n 1. Some m = Some m", "show \"Some m = Some m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Some m = Some m", "by simp"], ["proof (state)\nthis:\n  Some m = Some m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m \\<le> l\n\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))\n 2. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n       (\\<not> tr_lookup T (i + jj) (j + jj))", "hence \"m < l \\<or> m = l\""], ["proof (prove)\nusing this:\n  m \\<le> l\n\ngoal (1 subgoal):\n 1. m < l \\<or> m = l", "by auto"], ["proof (state)\nthis:\n  m < l \\<or> m = l\n\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))\n 2. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n       (\\<not> tr_lookup T (i + jj) (j + jj))", "thus ?thesis"], ["proof (prove)\nusing this:\n  m < l \\<or> m = l\n\ngoal (1 subgoal):\n 1. (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "proof (elim disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. m < l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))\n 2. m = l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "assume H: \"m < l\""], ["proof (state)\nthis:\n  m < l\n\ngoal (2 subgoals):\n 1. m < l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))\n 2. m = l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "with Cons(9)"], ["proof (chain)\npicking this:\n  mk_eqcl' (y # xs) ii jj l T ! i = Some m\n  m < l", "have I: \"(y # xs) ! i = Some m\""], ["proof (prove)\nusing this:\n  mk_eqcl' (y # xs) ii jj l T ! i = Some m\n  m < l\n\ngoal (1 subgoal):\n 1. (y # xs) ! i = Some m", "proof (induct (\"y # xs\") arbitrary: jj i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>jj i.\n       \\<lbrakk>mk_eqcl' [] ii jj l T ! i = Some m; m < l\\<rbrakk>\n       \\<Longrightarrow> [] ! i = Some m\n 2. \\<And>a list jj i.\n       \\<lbrakk>\\<And>jj i.\n                   \\<lbrakk>mk_eqcl' list ii jj l T ! i = Some m;\n                    m < l\\<rbrakk>\n                   \\<Longrightarrow> list ! i = Some m;\n        mk_eqcl' (a # list) ii jj l T ! i = Some m; m < l\\<rbrakk>\n       \\<Longrightarrow> (a # list) ! i = Some m", "case (Cons a l jj i)"], ["proof (state)\nthis:\n  \\<lbrakk>mk_eqcl' l ii ?jj l T ! ?i = Some m; m < l\\<rbrakk>\n  \\<Longrightarrow> l ! ?i = Some m\n  mk_eqcl' (a # l) ii jj l T ! i = Some m\n  m < l\n\ngoal (2 subgoals):\n 1. \\<And>jj i.\n       \\<lbrakk>mk_eqcl' [] ii jj l T ! i = Some m; m < l\\<rbrakk>\n       \\<Longrightarrow> [] ! i = Some m\n 2. \\<And>a list jj i.\n       \\<lbrakk>\\<And>jj i.\n                   \\<lbrakk>mk_eqcl' list ii jj l T ! i = Some m;\n                    m < l\\<rbrakk>\n                   \\<Longrightarrow> list ! i = Some m;\n        mk_eqcl' (a # list) ii jj l T ! i = Some m; m < l\\<rbrakk>\n       \\<Longrightarrow> (a # list) ! i = Some m", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>mk_eqcl' l ii ?jj l T ! ?i = Some m; m < l\\<rbrakk>\n  \\<Longrightarrow> l ! ?i = Some m\n  mk_eqcl' (a # l) ii jj l T ! i = Some m\n  m < l\n\ngoal (1 subgoal):\n 1. (a # l) ! i = Some m", "by (cases i) (auto, cases \"tr_lookup T jj ii \\<or> a \\<noteq> None\", simp+)"], ["proof (state)\nthis:\n  (a # l) ! i = Some m\n\ngoal (1 subgoal):\n 1. \\<And>jj i.\n       \\<lbrakk>mk_eqcl' [] ii jj l T ! i = Some m; m < l\\<rbrakk>\n       \\<Longrightarrow> [] ! i = Some m", "qed simp"], ["proof (state)\nthis:\n  (y # xs) ! i = Some m\n\ngoal (2 subgoals):\n 1. m < l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))\n 2. m = l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "from 0 H"], ["proof (chain)\npicking this:\n  j = 0\n  m < l", "have \"(mk_eqcl' (y # xs) ii jj l T ! j = Some m) = ((y#xs) ! j = Some m)\""], ["proof (prove)\nusing this:\n  j = 0\n  m < l\n\ngoal (1 subgoal):\n 1. (mk_eqcl' (y # xs) ii jj l T ! j = Some m) = ((y # xs) ! j = Some m)", "by (cases \"tr_lookup T jj ii \\<or> y \\<noteq> None\") simp+"], ["proof (state)\nthis:\n  (mk_eqcl' (y # xs) ii jj l T ! j = Some m) = ((y # xs) ! j = Some m)\n\ngoal (2 subgoals):\n 1. m < l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))\n 2. m = l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "also"], ["proof (state)\nthis:\n  (mk_eqcl' (y # xs) ii jj l T ! j = Some m) = ((y # xs) ! j = Some m)\n\ngoal (2 subgoals):\n 1. m < l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))\n 2. m = l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "from Cons(8,10) I"], ["proof (chain)\npicking this:\n  i < length (y # xs)\n  j < length (y # xs)\n  (y # xs) ! i = Some m", "have \"\\<dots> = (\\<not> tr_lookup T (i + jj) (j + jj))\""], ["proof (prove)\nusing this:\n  i < length (y # xs)\n  j < length (y # xs)\n  (y # xs) ! i = Some m\n\ngoal (1 subgoal):\n 1. ((y # xs) ! j = Some m) = (\\<not> tr_lookup T (i + jj) (j + jj))", "by (rule Cons(2))"], ["proof (state)\nthis:\n  ((y # xs) ! j = Some m) = (\\<not> tr_lookup T (i + jj) (j + jj))\n\ngoal (2 subgoals):\n 1. m < l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))\n 2. m = l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "finally"], ["proof (chain)\npicking this:\n  (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n  (\\<not> tr_lookup T (i + jj) (j + jj))", "show ?thesis"], ["proof (prove)\nusing this:\n  (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n  (\\<not> tr_lookup T (i + jj) (j + jj))\n\ngoal (1 subgoal):\n 1. (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "by simp"], ["proof (state)\nthis:\n  (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n  (\\<not> tr_lookup T (i + jj) (j + jj))\n\ngoal (1 subgoal):\n 1. m = l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. m = l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "assume H: \"m = l\""], ["proof (state)\nthis:\n  m = l\n\ngoal (1 subgoal):\n 1. m = l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "from Cons(5,6,7,8)"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<in> set (y # xs); ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < l\n  \\<lbrakk>?i' < length (y # xs); \\<not> tr_lookup T (?i' + jj) ii\\<rbrakk>\n  \\<Longrightarrow> (y # xs) ! ?i' = None\n  ii < jj\n  i < length (y # xs)", "have \"(mk_eqcl' (y # xs) ii jj l T ! i = Some l) = (\\<not> tr_lookup T (i + jj) ii)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set (y # xs); ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < l\n  \\<lbrakk>?i' < length (y # xs); \\<not> tr_lookup T (?i' + jj) ii\\<rbrakk>\n  \\<Longrightarrow> (y # xs) ! ?i' = None\n  ii < jj\n  i < length (y # xs)\n\ngoal (1 subgoal):\n 1. (mk_eqcl' (y # xs) ii jj l T ! i = Some l) =\n    (\\<not> tr_lookup T (i + jj) ii)", "by (rule mk_eqcl'_nth')"], ["proof (state)\nthis:\n  (mk_eqcl' (y # xs) ii jj l T ! i = Some l) =\n  (\\<not> tr_lookup T (i + jj) ii)\n\ngoal (1 subgoal):\n 1. m = l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "with H Cons(9)"], ["proof (chain)\npicking this:\n  m = l\n  mk_eqcl' (y # xs) ii jj l T ! i = Some m\n  (mk_eqcl' (y # xs) ii jj l T ! i = Some l) =\n  (\\<not> tr_lookup T (i + jj) ii)", "have I: \"\\<not> tr_lookup T (i + jj) ii\""], ["proof (prove)\nusing this:\n  m = l\n  mk_eqcl' (y # xs) ii jj l T ! i = Some m\n  (mk_eqcl' (y # xs) ii jj l T ! i = Some l) =\n  (\\<not> tr_lookup T (i + jj) ii)\n\ngoal (1 subgoal):\n 1. \\<not> tr_lookup T (i + jj) ii", "by simp"], ["proof (state)\nthis:\n  \\<not> tr_lookup T (i + jj) ii\n\ngoal (1 subgoal):\n 1. m = l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "with 0 H Cons(5)"], ["proof (chain)\npicking this:\n  j = 0\n  m = l\n  \\<lbrakk>?x \\<in> set (y # xs); ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < l\n  \\<not> tr_lookup T (i + jj) ii", "have \"(mk_eqcl' (y # xs) ii jj l T ! j = Some m) = (\\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii \\<and> y = None)\""], ["proof (prove)\nusing this:\n  j = 0\n  m = l\n  \\<lbrakk>?x \\<in> set (y # xs); ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < l\n  \\<not> tr_lookup T (i + jj) ii\n\ngoal (1 subgoal):\n 1. (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (j + jj) ii \\<and>\n     \\<not> tr_lookup T (i + jj) ii \\<and> y = None)", "by auto"], ["proof (state)\nthis:\n  (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n  (\\<not> tr_lookup T (j + jj) ii \\<and>\n   \\<not> tr_lookup T (i + jj) ii \\<and> y = None)\n\ngoal (1 subgoal):\n 1. m = l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "also"], ["proof (state)\nthis:\n  (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n  (\\<not> tr_lookup T (j + jj) ii \\<and>\n   \\<not> tr_lookup T (i + jj) ii \\<and> y = None)\n\ngoal (1 subgoal):\n 1. m = l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "from Cons(6)[of 0] 0"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < length (y # xs); \\<not> tr_lookup T (0 + jj) ii\\<rbrakk>\n  \\<Longrightarrow> (y # xs) ! 0 = None\n  j = 0", "have \"\\<dots> = (\\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < length (y # xs); \\<not> tr_lookup T (0 + jj) ii\\<rbrakk>\n  \\<Longrightarrow> (y # xs) ! 0 = None\n  j = 0\n\ngoal (1 subgoal):\n 1. (\\<not> tr_lookup T (j + jj) ii \\<and>\n     \\<not> tr_lookup T (i + jj) ii \\<and> y = None) =\n    (\\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii)", "by auto"], ["proof (state)\nthis:\n  (\\<not> tr_lookup T (j + jj) ii \\<and>\n   \\<not> tr_lookup T (i + jj) ii \\<and> y = None) =\n  (\\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii)\n\ngoal (1 subgoal):\n 1. m = l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "also"], ["proof (state)\nthis:\n  (\\<not> tr_lookup T (j + jj) ii \\<and>\n   \\<not> tr_lookup T (i + jj) ii \\<and> y = None) =\n  (\\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii)\n\ngoal (1 subgoal):\n 1. m = l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "have \"\\<dots> = (\\<not> tr_lookup T (i + jj) (j + jj) \\<and> \\<not> tr_lookup T (i + jj) ii)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii) =\n    (\\<not> tr_lookup T (i + jj) (j + jj) \\<and>\n     \\<not> tr_lookup T (i + jj) ii)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> tr_lookup T (j + jj) ii \\<and>\n    \\<not> tr_lookup T (i + jj) ii \\<Longrightarrow>\n    \\<not> tr_lookup T (i + jj) (j + jj) \\<and>\n    \\<not> tr_lookup T (i + jj) ii\n 2. \\<not> tr_lookup T (i + jj) (j + jj) \\<and>\n    \\<not> tr_lookup T (i + jj) ii \\<Longrightarrow>\n    \\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii", "assume H': \"\\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii\""], ["proof (state)\nthis:\n  \\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii\n\ngoal (2 subgoals):\n 1. \\<not> tr_lookup T (j + jj) ii \\<and>\n    \\<not> tr_lookup T (i + jj) ii \\<Longrightarrow>\n    \\<not> tr_lookup T (i + jj) (j + jj) \\<and>\n    \\<not> tr_lookup T (i + jj) ii\n 2. \\<not> tr_lookup T (i + jj) (j + jj) \\<and>\n    \\<not> tr_lookup T (i + jj) ii \\<Longrightarrow>\n    \\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii", "hence \"\\<not> tr_lookup T ii (j + jj)\""], ["proof (prove)\nusing this:\n  \\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii\n\ngoal (1 subgoal):\n 1. \\<not> tr_lookup T ii (j + jj)", "by (auto simp: tr_lookup_def)"], ["proof (state)\nthis:\n  \\<not> tr_lookup T ii (j + jj)\n\ngoal (2 subgoals):\n 1. \\<not> tr_lookup T (j + jj) ii \\<and>\n    \\<not> tr_lookup T (i + jj) ii \\<Longrightarrow>\n    \\<not> tr_lookup T (i + jj) (j + jj) \\<and>\n    \\<not> tr_lookup T (i + jj) ii\n 2. \\<not> tr_lookup T (i + jj) (j + jj) \\<and>\n    \\<not> tr_lookup T (i + jj) ii \\<Longrightarrow>\n    \\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii", "with H' Cons(3)[of \"i + jj\" ii \"j + jj\"] Cons(4,7,8,10)"], ["proof (chain)\npicking this:\n  \\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii\n  \\<lbrakk>i + jj \\<le> length T; ii \\<le> length T; j + jj \\<le> length T;\n   \\<not> tr_lookup T (i + jj) ii; \\<not> tr_lookup T ii (j + jj)\\<rbrakk>\n  \\<Longrightarrow> \\<not> tr_lookup T (i + jj) (j + jj)\n  length (y # xs) + jj = length T + 1\n  ii < jj\n  i < length (y # xs)\n  j < length (y # xs)\n  \\<not> tr_lookup T ii (j + jj)", "show \"\\<not> tr_lookup T (i + jj) (j + jj) \\<and> \\<not> tr_lookup T (i + jj) ii\""], ["proof (prove)\nusing this:\n  \\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii\n  \\<lbrakk>i + jj \\<le> length T; ii \\<le> length T; j + jj \\<le> length T;\n   \\<not> tr_lookup T (i + jj) ii; \\<not> tr_lookup T ii (j + jj)\\<rbrakk>\n  \\<Longrightarrow> \\<not> tr_lookup T (i + jj) (j + jj)\n  length (y # xs) + jj = length T + 1\n  ii < jj\n  i < length (y # xs)\n  j < length (y # xs)\n  \\<not> tr_lookup T ii (j + jj)\n\ngoal (1 subgoal):\n 1. \\<not> tr_lookup T (i + jj) (j + jj) \\<and>\n    \\<not> tr_lookup T (i + jj) ii", "by simp"], ["proof (state)\nthis:\n  \\<not> tr_lookup T (i + jj) (j + jj) \\<and> \\<not> tr_lookup T (i + jj) ii\n\ngoal (1 subgoal):\n 1. \\<not> tr_lookup T (i + jj) (j + jj) \\<and>\n    \\<not> tr_lookup T (i + jj) ii \\<Longrightarrow>\n    \\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> tr_lookup T (i + jj) (j + jj) \\<and>\n    \\<not> tr_lookup T (i + jj) ii \\<Longrightarrow>\n    \\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii", "assume H': \"\\<not> tr_lookup T (i + jj) (j + jj) \\<and> \\<not> tr_lookup T (i + jj) ii\""], ["proof (state)\nthis:\n  \\<not> tr_lookup T (i + jj) (j + jj) \\<and> \\<not> tr_lookup T (i + jj) ii\n\ngoal (1 subgoal):\n 1. \\<not> tr_lookup T (i + jj) (j + jj) \\<and>\n    \\<not> tr_lookup T (i + jj) ii \\<Longrightarrow>\n    \\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii", "hence \"\\<not> tr_lookup T (j + jj) (i + jj)\""], ["proof (prove)\nusing this:\n  \\<not> tr_lookup T (i + jj) (j + jj) \\<and> \\<not> tr_lookup T (i + jj) ii\n\ngoal (1 subgoal):\n 1. \\<not> tr_lookup T (j + jj) (i + jj)", "by (auto simp: tr_lookup_def)"], ["proof (state)\nthis:\n  \\<not> tr_lookup T (j + jj) (i + jj)\n\ngoal (1 subgoal):\n 1. \\<not> tr_lookup T (i + jj) (j + jj) \\<and>\n    \\<not> tr_lookup T (i + jj) ii \\<Longrightarrow>\n    \\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii", "with H' Cons(3)[of \"j + jj\" \"i + jj\" ii] Cons(4,7,8,10)"], ["proof (chain)\npicking this:\n  \\<not> tr_lookup T (i + jj) (j + jj) \\<and> \\<not> tr_lookup T (i + jj) ii\n  \\<lbrakk>j + jj \\<le> length T; i + jj \\<le> length T; ii \\<le> length T;\n   \\<not> tr_lookup T (j + jj) (i + jj);\n   \\<not> tr_lookup T (i + jj) ii\\<rbrakk>\n  \\<Longrightarrow> \\<not> tr_lookup T (j + jj) ii\n  length (y # xs) + jj = length T + 1\n  ii < jj\n  i < length (y # xs)\n  j < length (y # xs)\n  \\<not> tr_lookup T (j + jj) (i + jj)", "show \"\\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii\""], ["proof (prove)\nusing this:\n  \\<not> tr_lookup T (i + jj) (j + jj) \\<and> \\<not> tr_lookup T (i + jj) ii\n  \\<lbrakk>j + jj \\<le> length T; i + jj \\<le> length T; ii \\<le> length T;\n   \\<not> tr_lookup T (j + jj) (i + jj);\n   \\<not> tr_lookup T (i + jj) ii\\<rbrakk>\n  \\<Longrightarrow> \\<not> tr_lookup T (j + jj) ii\n  length (y # xs) + jj = length T + 1\n  ii < jj\n  i < length (y # xs)\n  j < length (y # xs)\n  \\<not> tr_lookup T (j + jj) (i + jj)\n\ngoal (1 subgoal):\n 1. \\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii", "by simp"], ["proof (state)\nthis:\n  \\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii) =\n  (\\<not> tr_lookup T (i + jj) (j + jj) \\<and>\n   \\<not> tr_lookup T (i + jj) ii)\n\ngoal (1 subgoal):\n 1. m = l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "also"], ["proof (state)\nthis:\n  (\\<not> tr_lookup T (j + jj) ii \\<and> \\<not> tr_lookup T (i + jj) ii) =\n  (\\<not> tr_lookup T (i + jj) (j + jj) \\<and>\n   \\<not> tr_lookup T (i + jj) ii)\n\ngoal (1 subgoal):\n 1. m = l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "from I"], ["proof (chain)\npicking this:\n  \\<not> tr_lookup T (i + jj) ii", "have \"\\<dots> = (\\<not> tr_lookup T (i + jj) (j + jj))\""], ["proof (prove)\nusing this:\n  \\<not> tr_lookup T (i + jj) ii\n\ngoal (1 subgoal):\n 1. (\\<not> tr_lookup T (i + jj) (j + jj) \\<and>\n     \\<not> tr_lookup T (i + jj) ii) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "by simp"], ["proof (state)\nthis:\n  (\\<not> tr_lookup T (i + jj) (j + jj) \\<and>\n   \\<not> tr_lookup T (i + jj) ii) =\n  (\\<not> tr_lookup T (i + jj) (j + jj))\n\ngoal (1 subgoal):\n 1. m = l \\<Longrightarrow>\n    (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "finally"], ["proof (chain)\npicking this:\n  (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n  (\\<not> tr_lookup T (i + jj) (j + jj))", "show ?thesis"], ["proof (prove)\nusing this:\n  (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n  (\\<not> tr_lookup T (i + jj) (j + jj))\n\ngoal (1 subgoal):\n 1. (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "by simp"], ["proof (state)\nthis:\n  (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n  (\\<not> tr_lookup T (i + jj) (j + jj))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n  (\\<not> tr_lookup T (i + jj) (j + jj))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n       (\\<not> tr_lookup T (i + jj) (j + jj))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n       (\\<not> tr_lookup T (i + jj) (j + jj))", "case (Suc j')"], ["proof (state)\nthis:\n  j = Suc j'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n       (\\<not> tr_lookup T (i + jj) (j + jj))", "hence \"(mk_eqcl' (y # xs) ii jj l T ! j = Some m) = (mk_eqcl' xs ii (Suc jj) l T ! j' = Some m)\""], ["proof (prove)\nusing this:\n  j = Suc j'\n\ngoal (1 subgoal):\n 1. (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (mk_eqcl' xs ii (Suc jj) l T ! j' = Some m)", "by simp"], ["proof (state)\nthis:\n  (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n  (mk_eqcl' xs ii (Suc jj) l T ! j' = Some m)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n       (\\<not> tr_lookup T (i + jj) (j + jj))", "also"], ["proof (state)\nthis:\n  (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n  (mk_eqcl' xs ii (Suc jj) l T ! j' = Some m)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n       (\\<not> tr_lookup T (i + jj) (j + jj))", "have \"\\<dots> = (\\<not> tr_lookup T (i' + Suc jj) (j' + Suc jj))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mk_eqcl' xs ii (Suc jj) l T ! j' = Some m) =\n    (\\<not> tr_lookup T (i' + Suc jj) (j' + Suc jj))", "proof (rule Cons(1))"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>i' j' k.\n       \\<lbrakk>i' < length xs; j' < length xs; xs ! i' = Some k\\<rbrakk>\n       \\<Longrightarrow> (xs ! j' = Some k) =\n                         (\\<not> tr_lookup T (i' + Suc jj) (j' + Suc jj))\n 2. \\<And>a b c.\n       \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n        \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n       \\<Longrightarrow> \\<not> tr_lookup T a c\n 3. length xs + Suc jj = length T + 1\n 4. \\<And>x k.\n       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk> \\<Longrightarrow> k < l\n 5. \\<And>i'.\n       \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc jj) ii\\<rbrakk>\n       \\<Longrightarrow> xs ! i' = None\n 6. ii < Suc jj\n 7. i' < length xs\n 8. mk_eqcl' xs ii (Suc jj) l T ! i' = Some m\n 9. j' < length xs", "show \"\\<And>i' j' k. \\<lbrakk>i' < length xs; j' < length xs; xs ! i' = Some k\\<rbrakk> \\<Longrightarrow> (xs ! j' = Some k) = (\\<not> tr_lookup T (i' + Suc jj) (j' + Suc jj))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i' j' k.\n       \\<lbrakk>i' < length xs; j' < length xs; xs ! i' = Some k\\<rbrakk>\n       \\<Longrightarrow> (xs ! j' = Some k) =\n                         (\\<not> tr_lookup T (i' + Suc jj) (j' + Suc jj))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i' j' k.\n       \\<lbrakk>i' < length xs; j' < length xs; xs ! i' = Some k\\<rbrakk>\n       \\<Longrightarrow> (xs ! j' = Some k) =\n                         (\\<not> tr_lookup T (i' + Suc jj) (j' + Suc jj))", "fix i' j' k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i' j' k.\n       \\<lbrakk>i' < length xs; j' < length xs; xs ! i' = Some k\\<rbrakk>\n       \\<Longrightarrow> (xs ! j' = Some k) =\n                         (\\<not> tr_lookup T (i' + Suc jj) (j' + Suc jj))", "assume \"i' < length xs\" \"j' < length xs\" \"xs ! i' = Some k\""], ["proof (state)\nthis:\n  i' < length xs\n  j' < length xs\n  xs ! i' = Some k\n\ngoal (1 subgoal):\n 1. \\<And>i' j' k.\n       \\<lbrakk>i' < length xs; j' < length xs; xs ! i' = Some k\\<rbrakk>\n       \\<Longrightarrow> (xs ! j' = Some k) =\n                         (\\<not> tr_lookup T (i' + Suc jj) (j' + Suc jj))", "with Cons(2)[of \"Suc i'\" \"Suc j'\" k]"], ["proof (chain)\npicking this:\n  \\<lbrakk>Suc i' < length (y # xs); Suc j' < length (y # xs);\n   (y # xs) ! Suc i' = Some k\\<rbrakk>\n  \\<Longrightarrow> ((y # xs) ! Suc j' = Some k) =\n                    (\\<not> tr_lookup T (Suc i' + jj) (Suc j' + jj))\n  i' < length xs\n  j' < length xs\n  xs ! i' = Some k", "show \"(xs ! j' = Some k) = (\\<not> tr_lookup T (i' + Suc jj) (j' + Suc jj))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>Suc i' < length (y # xs); Suc j' < length (y # xs);\n   (y # xs) ! Suc i' = Some k\\<rbrakk>\n  \\<Longrightarrow> ((y # xs) ! Suc j' = Some k) =\n                    (\\<not> tr_lookup T (Suc i' + jj) (Suc j' + jj))\n  i' < length xs\n  j' < length xs\n  xs ! i' = Some k\n\ngoal (1 subgoal):\n 1. (xs ! j' = Some k) = (\\<not> tr_lookup T (i' + Suc jj) (j' + Suc jj))", "by simp"], ["proof (state)\nthis:\n  (xs ! j' = Some k) = (\\<not> tr_lookup T (i' + Suc jj) (j' + Suc jj))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?i' < length xs; ?j' < length xs; xs ! ?i' = Some ?k\\<rbrakk>\n  \\<Longrightarrow> (xs ! ?j' = Some ?k) =\n                    (\\<not> tr_lookup T (?i' + Suc jj) (?j' + Suc jj))\n\ngoal (8 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n        \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n       \\<Longrightarrow> \\<not> tr_lookup T a c\n 2. length xs + Suc jj = length T + 1\n 3. \\<And>x k.\n       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk> \\<Longrightarrow> k < l\n 4. \\<And>i'.\n       \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc jj) ii\\<rbrakk>\n       \\<Longrightarrow> xs ! i' = None\n 5. ii < Suc jj\n 6. i' < length xs\n 7. mk_eqcl' xs ii (Suc jj) l T ! i' = Some m\n 8. j' < length xs", "from Cons(3)"], ["proof (chain)\npicking this:\n  \\<lbrakk>?a \\<le> length T; ?b \\<le> length T; ?c \\<le> length T;\n   \\<not> tr_lookup T ?a ?b; \\<not> tr_lookup T ?b ?c\\<rbrakk>\n  \\<Longrightarrow> \\<not> tr_lookup T ?a ?c", "show \"\\<And>a b c. \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T; \\<not> tr_lookup T a b; \\<not> tr_lookup T b c \\<rbrakk> \\<Longrightarrow> \\<not> tr_lookup T a c\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<le> length T; ?b \\<le> length T; ?c \\<le> length T;\n   \\<not> tr_lookup T ?a ?b; \\<not> tr_lookup T ?b ?c\\<rbrakk>\n  \\<Longrightarrow> \\<not> tr_lookup T ?a ?c\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n        \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n       \\<Longrightarrow> \\<not> tr_lookup T a c", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<le> length T; ?b \\<le> length T; ?c \\<le> length T;\n   \\<not> tr_lookup T ?a ?b; \\<not> tr_lookup T ?b ?c\\<rbrakk>\n  \\<Longrightarrow> \\<not> tr_lookup T ?a ?c\n\ngoal (7 subgoals):\n 1. length xs + Suc jj = length T + 1\n 2. \\<And>x k.\n       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk> \\<Longrightarrow> k < l\n 3. \\<And>i'.\n       \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc jj) ii\\<rbrakk>\n       \\<Longrightarrow> xs ! i' = None\n 4. ii < Suc jj\n 5. i' < length xs\n 6. mk_eqcl' xs ii (Suc jj) l T ! i' = Some m\n 7. j' < length xs", "from Cons(4)"], ["proof (chain)\npicking this:\n  length (y # xs) + jj = length T + 1", "show \"length xs + Suc jj = length T + 1\""], ["proof (prove)\nusing this:\n  length (y # xs) + jj = length T + 1\n\ngoal (1 subgoal):\n 1. length xs + Suc jj = length T + 1", "by simp"], ["proof (state)\nthis:\n  length xs + Suc jj = length T + 1\n\ngoal (6 subgoals):\n 1. \\<And>x k.\n       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk> \\<Longrightarrow> k < l\n 2. \\<And>i'.\n       \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc jj) ii\\<rbrakk>\n       \\<Longrightarrow> xs ! i' = None\n 3. ii < Suc jj\n 4. i' < length xs\n 5. mk_eqcl' xs ii (Suc jj) l T ! i' = Some m\n 6. j' < length xs", "from Cons(5)"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<in> set (y # xs); ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < l", "show \"\\<And>x k. \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk> \\<Longrightarrow> k < l\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set (y # xs); ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < l\n\ngoal (1 subgoal):\n 1. \\<And>x k.\n       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk> \\<Longrightarrow> k < l", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> set xs; ?x = Some ?k\\<rbrakk> \\<Longrightarrow> ?k < l\n\ngoal (5 subgoals):\n 1. \\<And>i'.\n       \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc jj) ii\\<rbrakk>\n       \\<Longrightarrow> xs ! i' = None\n 2. ii < Suc jj\n 3. i' < length xs\n 4. mk_eqcl' xs ii (Suc jj) l T ! i' = Some m\n 5. j' < length xs", "show \"\\<And>i'. \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc jj) ii\\<rbrakk> \\<Longrightarrow> xs ! i' = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i'.\n       \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc jj) ii\\<rbrakk>\n       \\<Longrightarrow> xs ! i' = None", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i'.\n       \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc jj) ii\\<rbrakk>\n       \\<Longrightarrow> xs ! i' = None", "fix i'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i'.\n       \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc jj) ii\\<rbrakk>\n       \\<Longrightarrow> xs ! i' = None", "assume \"i' < length xs\" \"\\<not> tr_lookup T (i' + Suc jj) ii\""], ["proof (state)\nthis:\n  i' < length xs\n  \\<not> tr_lookup T (i' + Suc jj) ii\n\ngoal (1 subgoal):\n 1. \\<And>i'.\n       \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc jj) ii\\<rbrakk>\n       \\<Longrightarrow> xs ! i' = None", "with Cons(6)[of \"Suc i'\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>Suc i' < length (y # xs);\n   \\<not> tr_lookup T (Suc i' + jj) ii\\<rbrakk>\n  \\<Longrightarrow> (y # xs) ! Suc i' = None\n  i' < length xs\n  \\<not> tr_lookup T (i' + Suc jj) ii", "show \"xs ! i' = None\""], ["proof (prove)\nusing this:\n  \\<lbrakk>Suc i' < length (y # xs);\n   \\<not> tr_lookup T (Suc i' + jj) ii\\<rbrakk>\n  \\<Longrightarrow> (y # xs) ! Suc i' = None\n  i' < length xs\n  \\<not> tr_lookup T (i' + Suc jj) ii\n\ngoal (1 subgoal):\n 1. xs ! i' = None", "by simp"], ["proof (state)\nthis:\n  xs ! i' = None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?i' < length xs; \\<not> tr_lookup T (?i' + Suc jj) ii\\<rbrakk>\n  \\<Longrightarrow> xs ! ?i' = None\n\ngoal (4 subgoals):\n 1. ii < Suc jj\n 2. i' < length xs\n 3. mk_eqcl' xs ii (Suc jj) l T ! i' = Some m\n 4. j' < length xs", "from Cons(7)"], ["proof (chain)\npicking this:\n  ii < jj", "show \"ii < Suc jj\""], ["proof (prove)\nusing this:\n  ii < jj\n\ngoal (1 subgoal):\n 1. ii < Suc jj", "by simp"], ["proof (state)\nthis:\n  ii < Suc jj\n\ngoal (3 subgoals):\n 1. i' < length xs\n 2. mk_eqcl' xs ii (Suc jj) l T ! i' = Some m\n 3. j' < length xs", "from Cons(8) \\<open>i=Suc i'\\<close>"], ["proof (chain)\npicking this:\n  i < length (y # xs)\n  i = Suc i'", "show \"i' < length xs\""], ["proof (prove)\nusing this:\n  i < length (y # xs)\n  i = Suc i'\n\ngoal (1 subgoal):\n 1. i' < length xs", "by simp"], ["proof (state)\nthis:\n  i' < length xs\n\ngoal (2 subgoals):\n 1. mk_eqcl' xs ii (Suc jj) l T ! i' = Some m\n 2. j' < length xs", "from Cons(9) \\<open>i=Suc i'\\<close>"], ["proof (chain)\npicking this:\n  mk_eqcl' (y # xs) ii jj l T ! i = Some m\n  i = Suc i'", "show \"mk_eqcl' xs ii (Suc jj) l T ! i' = Some m\""], ["proof (prove)\nusing this:\n  mk_eqcl' (y # xs) ii jj l T ! i = Some m\n  i = Suc i'\n\ngoal (1 subgoal):\n 1. mk_eqcl' xs ii (Suc jj) l T ! i' = Some m", "by simp"], ["proof (state)\nthis:\n  mk_eqcl' xs ii (Suc jj) l T ! i' = Some m\n\ngoal (1 subgoal):\n 1. j' < length xs", "from Cons(10) Suc"], ["proof (chain)\npicking this:\n  j < length (y # xs)\n  j = Suc j'", "show \"j' < length xs\""], ["proof (prove)\nusing this:\n  j < length (y # xs)\n  j = Suc j'\n\ngoal (1 subgoal):\n 1. j' < length xs", "by simp"], ["proof (state)\nthis:\n  j' < length xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (mk_eqcl' xs ii (Suc jj) l T ! j' = Some m) =\n  (\\<not> tr_lookup T (i' + Suc jj) (j' + Suc jj))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n       (\\<not> tr_lookup T (i + jj) (j + jj))", "also"], ["proof (state)\nthis:\n  (mk_eqcl' xs ii (Suc jj) l T ! j' = Some m) =\n  (\\<not> tr_lookup T (i' + Suc jj) (j' + Suc jj))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n       (\\<not> tr_lookup T (i + jj) (j + jj))", "from Suc \\<open>i=Suc i'\\<close>"], ["proof (chain)\npicking this:\n  j = Suc j'\n  i = Suc i'", "have \"\\<dots> = (\\<not> tr_lookup T (i + jj) (j + jj))\""], ["proof (prove)\nusing this:\n  j = Suc j'\n  i = Suc i'\n\ngoal (1 subgoal):\n 1. (\\<not> tr_lookup T (i' + Suc jj) (j' + Suc jj)) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "by simp"], ["proof (state)\nthis:\n  (\\<not> tr_lookup T (i' + Suc jj) (j' + Suc jj)) =\n  (\\<not> tr_lookup T (i + jj) (j + jj))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n       (\\<not> tr_lookup T (i + jj) (j + jj))", "finally"], ["proof (chain)\npicking this:\n  (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n  (\\<not> tr_lookup T (i + jj) (j + jj))", "show ?thesis"], ["proof (prove)\nusing this:\n  (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n  (\\<not> tr_lookup T (i + jj) (j + jj))\n\ngoal (1 subgoal):\n 1. (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n    (\\<not> tr_lookup T (i + jj) (j + jj))", "by simp"], ["proof (state)\nthis:\n  (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n  (\\<not> tr_lookup T (i + jj) (j + jj))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n  (\\<not> tr_lookup T (i + jj) (j + jj))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (mk_eqcl' (y # xs) ii jj l T ! j = Some m) =\n  (\\<not> tr_lookup T (i + jj) (j + jj))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mk_eqcl'_Some:\n  assumes \"i < length xs\" and \"xs ! i \\<noteq> None\"\n  shows \"mk_eqcl' xs ii j l T ! i = xs ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_eqcl' xs ii j l T ! i = xs ! i", "using assms"], ["proof (prove)\nusing this:\n  i < length xs\n  xs ! i \\<noteq> None\n\ngoal (1 subgoal):\n 1. mk_eqcl' xs ii j l T ! i = xs ! i", "proof (induct xs arbitrary: j i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>j i.\n       \\<lbrakk>i < length []; [] ! i \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> mk_eqcl' [] ii j l T ! i = [] ! i\n 2. \\<And>a xs j i.\n       \\<lbrakk>\\<And>j i.\n                   \\<lbrakk>i < length xs; xs ! i \\<noteq> None\\<rbrakk>\n                   \\<Longrightarrow> mk_eqcl' xs ii j l T ! i = xs ! i;\n        i < length (a # xs); (a # xs) ! i \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> mk_eqcl' (a # xs) ii j l T ! i = (a # xs) ! i", "case (Cons y xs j i)"], ["proof (state)\nthis:\n  \\<lbrakk>?i < length xs; xs ! ?i \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> mk_eqcl' xs ii ?j l T ! ?i = xs ! ?i\n  i < length (y # xs)\n  (y # xs) ! i \\<noteq> None\n\ngoal (2 subgoals):\n 1. \\<And>j i.\n       \\<lbrakk>i < length []; [] ! i \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> mk_eqcl' [] ii j l T ! i = [] ! i\n 2. \\<And>a xs j i.\n       \\<lbrakk>\\<And>j i.\n                   \\<lbrakk>i < length xs; xs ! i \\<noteq> None\\<rbrakk>\n                   \\<Longrightarrow> mk_eqcl' xs ii j l T ! i = xs ! i;\n        i < length (a # xs); (a # xs) ! i \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> mk_eqcl' (a # xs) ii j l T ! i = (a # xs) ! i", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < length xs; xs ! ?i \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> mk_eqcl' xs ii ?j l T ! ?i = xs ! ?i\n  i < length (y # xs)\n  (y # xs) ! i \\<noteq> None\n\ngoal (1 subgoal):\n 1. mk_eqcl' (y # xs) ii j l T ! i = (y # xs) ! i", "by (cases i) auto"], ["proof (state)\nthis:\n  mk_eqcl' (y # xs) ii j l T ! i = (y # xs) ! i\n\ngoal (1 subgoal):\n 1. \\<And>j i.\n       \\<lbrakk>i < length []; [] ! i \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> mk_eqcl' [] ii j l T ! i = [] ! i", "qed simp"], ["", "lemma mk_eqcl'_Some2:\n  assumes \"i < length xs\"\n  and \"k < l\"\n  shows \"(mk_eqcl' xs ii j l T ! i = Some k) = (xs ! i = Some k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mk_eqcl' xs ii j l T ! i = Some k) = (xs ! i = Some k)", "using assms"], ["proof (prove)\nusing this:\n  i < length xs\n  k < l\n\ngoal (1 subgoal):\n 1. (mk_eqcl' xs ii j l T ! i = Some k) = (xs ! i = Some k)", "proof (induct xs arbitrary: j i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>j i.\n       \\<lbrakk>i < length []; k < l\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' [] ii j l T ! i = Some k) =\n                         ([] ! i = Some k)\n 2. \\<And>a xs j i.\n       \\<lbrakk>\\<And>j i.\n                   \\<lbrakk>i < length xs; k < l\\<rbrakk>\n                   \\<Longrightarrow> (mk_eqcl' xs ii j l T ! i = Some k) =\n                                     (xs ! i = Some k);\n        i < length (a # xs); k < l\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' (a # xs) ii j l T ! i = Some k) =\n                         ((a # xs) ! i = Some k)", "case (Cons y xs j i)"], ["proof (state)\nthis:\n  \\<lbrakk>?i < length xs; k < l\\<rbrakk>\n  \\<Longrightarrow> (mk_eqcl' xs ii ?j l T ! ?i = Some k) =\n                    (xs ! ?i = Some k)\n  i < length (y # xs)\n  k < l\n\ngoal (2 subgoals):\n 1. \\<And>j i.\n       \\<lbrakk>i < length []; k < l\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' [] ii j l T ! i = Some k) =\n                         ([] ! i = Some k)\n 2. \\<And>a xs j i.\n       \\<lbrakk>\\<And>j i.\n                   \\<lbrakk>i < length xs; k < l\\<rbrakk>\n                   \\<Longrightarrow> (mk_eqcl' xs ii j l T ! i = Some k) =\n                                     (xs ! i = Some k);\n        i < length (a # xs); k < l\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' (a # xs) ii j l T ! i = Some k) =\n                         ((a # xs) ! i = Some k)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < length xs; k < l\\<rbrakk>\n  \\<Longrightarrow> (mk_eqcl' xs ii ?j l T ! ?i = Some k) =\n                    (xs ! ?i = Some k)\n  i < length (y # xs)\n  k < l\n\ngoal (1 subgoal):\n 1. (mk_eqcl' (y # xs) ii j l T ! i = Some k) = ((y # xs) ! i = Some k)", "by (cases i) auto"], ["proof (state)\nthis:\n  (mk_eqcl' (y # xs) ii j l T ! i = Some k) = ((y # xs) ! i = Some k)\n\ngoal (1 subgoal):\n 1. \\<And>j i.\n       \\<lbrakk>i < length []; k < l\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' [] ii j l T ! i = Some k) =\n                         ([] ! i = Some k)", "qed simp"], ["", "lemma mk_eqcl_fst_Some:\n  assumes \"i < length xs\" and \"k < length zs\"\n  shows \"(fst (mk_eqcl xs zs ii T) ! i = k) = (xs ! i = Some k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst (mk_eqcl xs zs ii T) ! i = k) = (xs ! i = Some k)", "using assms"], ["proof (prove)\nusing this:\n  i < length xs\n  k < length zs\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl xs zs ii T) ! i = k) = (xs ! i = Some k)", "proof (induct xs zs ii T arbitrary: i rule: mk_eqcl.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>zs i T ia.\n       \\<lbrakk>ia < length []; k < length zs\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl [] zs i T) ! ia = k) =\n                         ([] ! ia = Some k)\n 2. \\<And>xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>ia < length\n                                  (mk_eqcl' xs i (Suc i) (length zs) T);\n                    k < length (zs @ [i])\\<rbrakk>\n                   \\<Longrightarrow> (fst\n (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\nia =\nk) =\n                                     (mk_eqcl' xs i (Suc i) (length zs) T !\nia =\nSome k);\n        ia < length (None # xs); k < length zs\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (None # xs) zs i T) ! ia = k) =\n                         ((None # xs) ! ia = Some k)\n 3. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>ia < length xs; k < length zs\\<rbrakk>\n                   \\<Longrightarrow> (fst (mk_eqcl xs zs (Suc i) T) ! ia =\nk) =\n                                     (xs ! ia = Some k);\n        ia < length (Some l # xs); k < length zs\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (Some l # xs) zs i T) ! ia = k) =\n                         ((Some l # xs) ! ia = Some k)", "case (2 xs zs ii T i)"], ["proof (state)\nthis:\n  \\<lbrakk>?i < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n   k < length (zs @ [ii])\\<rbrakk>\n  \\<Longrightarrow> (fst (mk_eqcl (mk_eqcl' xs ii (Suc ii) (length zs) T)\n                           (zs @ [ii]) (Suc ii) T) !\n                     ?i =\n                     k) =\n                    (mk_eqcl' xs ii (Suc ii) (length zs) T ! ?i = Some k)\n  i < length (None # xs)\n  k < length zs\n\ngoal (3 subgoals):\n 1. \\<And>zs i T ia.\n       \\<lbrakk>ia < length []; k < length zs\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl [] zs i T) ! ia = k) =\n                         ([] ! ia = Some k)\n 2. \\<And>xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>ia < length\n                                  (mk_eqcl' xs i (Suc i) (length zs) T);\n                    k < length (zs @ [i])\\<rbrakk>\n                   \\<Longrightarrow> (fst\n (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\nia =\nk) =\n                                     (mk_eqcl' xs i (Suc i) (length zs) T !\nia =\nSome k);\n        ia < length (None # xs); k < length zs\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (None # xs) zs i T) ! ia = k) =\n                         ((None # xs) ! ia = Some k)\n 3. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>ia < length xs; k < length zs\\<rbrakk>\n                   \\<Longrightarrow> (fst (mk_eqcl xs zs (Suc i) T) ! ia =\nk) =\n                                     (xs ! ia = Some k);\n        ia < length (Some l # xs); k < length zs\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (Some l # xs) zs i T) ! ia = k) =\n                         ((Some l # xs) ! ia = Some k)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n   k < length (zs @ [ii])\\<rbrakk>\n  \\<Longrightarrow> (fst (mk_eqcl (mk_eqcl' xs ii (Suc ii) (length zs) T)\n                           (zs @ [ii]) (Suc ii) T) !\n                     ?i =\n                     k) =\n                    (mk_eqcl' xs ii (Suc ii) (length zs) T ! ?i = Some k)\n  i < length (None # xs)\n  k < length zs\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (None # xs) zs ii T) ! i = k) = ((None # xs) ! i = Some k)", "by (cases i) (simp add: split_beta mk_eqcl'_len mk_eqcl'_Some2)+"], ["proof (state)\nthis:\n  (fst (mk_eqcl (None # xs) zs ii T) ! i = k) = ((None # xs) ! i = Some k)\n\ngoal (2 subgoals):\n 1. \\<And>zs i T ia.\n       \\<lbrakk>ia < length []; k < length zs\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl [] zs i T) ! ia = k) =\n                         ([] ! ia = Some k)\n 2. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>ia < length xs; k < length zs\\<rbrakk>\n                   \\<Longrightarrow> (fst (mk_eqcl xs zs (Suc i) T) ! ia =\nk) =\n                                     (xs ! ia = Some k);\n        ia < length (Some l # xs); k < length zs\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (Some l # xs) zs i T) ! ia = k) =\n                         ((Some l # xs) ! ia = Some k)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>zs i T ia.\n       \\<lbrakk>ia < length []; k < length zs\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl [] zs i T) ! ia = k) =\n                         ([] ! ia = Some k)\n 2. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>ia < length xs; k < length zs\\<rbrakk>\n                   \\<Longrightarrow> (fst (mk_eqcl xs zs (Suc i) T) ! ia =\nk) =\n                                     (xs ! ia = Some k);\n        ia < length (Some l # xs); k < length zs\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (Some l # xs) zs i T) ! ia = k) =\n                         ((Some l # xs) ! ia = Some k)", "case (3 l xs zs ii T i)"], ["proof (state)\nthis:\n  \\<lbrakk>?i < length xs; k < length zs\\<rbrakk>\n  \\<Longrightarrow> (fst (mk_eqcl xs zs (Suc ii) T) ! ?i = k) =\n                    (xs ! ?i = Some k)\n  i < length (Some l # xs)\n  k < length zs\n\ngoal (2 subgoals):\n 1. \\<And>zs i T ia.\n       \\<lbrakk>ia < length []; k < length zs\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl [] zs i T) ! ia = k) =\n                         ([] ! ia = Some k)\n 2. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>ia < length xs; k < length zs\\<rbrakk>\n                   \\<Longrightarrow> (fst (mk_eqcl xs zs (Suc i) T) ! ia =\nk) =\n                                     (xs ! ia = Some k);\n        ia < length (Some l # xs); k < length zs\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (Some l # xs) zs i T) ! ia = k) =\n                         ((Some l # xs) ! ia = Some k)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < length xs; k < length zs\\<rbrakk>\n  \\<Longrightarrow> (fst (mk_eqcl xs zs (Suc ii) T) ! ?i = k) =\n                    (xs ! ?i = Some k)\n  i < length (Some l # xs)\n  k < length zs\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (Some l # xs) zs ii T) ! i = k) =\n    ((Some l # xs) ! i = Some k)", "by (cases i) (simp add: split_beta)+"], ["proof (state)\nthis:\n  (fst (mk_eqcl (Some l # xs) zs ii T) ! i = k) =\n  ((Some l # xs) ! i = Some k)\n\ngoal (1 subgoal):\n 1. \\<And>zs i T ia.\n       \\<lbrakk>ia < length []; k < length zs\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl [] zs i T) ! ia = k) =\n                         ([] ! ia = Some k)", "qed simp"], ["", "lemma mk_eqcl_len_snd:\n  \"length zs \\<le> length (snd (mk_eqcl xs zs i T))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length zs \\<le> length (snd (mk_eqcl xs zs i T))", "by (induct xs zs i T rule: mk_eqcl.induct) (simp add: split_beta)+"], ["", "lemma mk_eqcl_len_fst:\n  \"length (fst (mk_eqcl xs zs i T)) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (fst (mk_eqcl xs zs i T)) = length xs", "by (induct xs zs i T rule: mk_eqcl.induct) (simp add: split_beta mk_eqcl'_len)+"], ["", "lemma mk_eqcl_set_snd:\n  assumes \"i \\<notin> set zs\"\n  and \"j > i\"\n  shows \"i \\<notin> set (snd (mk_eqcl xs zs j T))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<notin> set (snd (mk_eqcl xs zs j T))", "using assms"], ["proof (prove)\nusing this:\n  i \\<notin> set zs\n  i < j\n\ngoal (1 subgoal):\n 1. i \\<notin> set (snd (mk_eqcl xs zs j T))", "by (induct xs zs j T rule: mk_eqcl.induct) (auto simp: split_beta)"], ["", "lemma mk_eqcl_snd_mon:\n  assumes \"\\<And>j1 j2. \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk> \\<Longrightarrow> zs ! j1 < zs ! j2\"\n  and \"\\<And>x. x \\<in> set zs \\<Longrightarrow> x < i\"\n  and \"j1 < j2\" and \"j2 < length (snd (mk_eqcl xs zs i T))\"\n  shows \"snd (mk_eqcl xs zs i T) ! j1 < snd (mk_eqcl xs zs i T) ! j2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (mk_eqcl xs zs i T) ! j1 < snd (mk_eqcl xs zs i T) ! j2", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?j1.0 < ?j2.0; ?j2.0 < length zs\\<rbrakk>\n  \\<Longrightarrow> zs ! ?j1.0 < zs ! ?j2.0\n  ?x \\<in> set zs \\<Longrightarrow> ?x < i\n  j1 < j2\n  j2 < length (snd (mk_eqcl xs zs i T))\n\ngoal (1 subgoal):\n 1. snd (mk_eqcl xs zs i T) ! j1 < snd (mk_eqcl xs zs i T) ! j2", "proof (induct xs zs i T rule: mk_eqcl.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>zs i T.\n       \\<lbrakk>\\<And>j1 j2.\n                   \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                   \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl [] zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl [] zs i T) ! j1\n                         < snd (mk_eqcl [] zs i T) ! j2\n 2. \\<And>xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>j1 j2.\n                            \\<lbrakk>j1 < j2;\n                             j2 < length (zs @ [i])\\<rbrakk>\n                            \\<Longrightarrow> (zs @ [i]) ! j1\n        < (zs @ [i]) ! j2;\n                 \\<And>x.\n                    x \\<in> set (zs @ [i]) \\<Longrightarrow> x < Suc i;\n                 j1 < j2;\n                 j2 < length\n                       (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                              (zs @ [i]) (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> snd (mk_eqcl\n  (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                  j1\n                                  < snd (mk_eqcl\n    (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                    j2;\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl (None # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! j1\n                         < snd (mk_eqcl (None # xs) zs i T) ! j2\n 3. \\<And>l xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>j1 j2.\n                            \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                            \\<Longrightarrow> zs ! j1 < zs ! j2;\n                 \\<And>x. x \\<in> set zs \\<Longrightarrow> x < Suc i;\n                 j1 < j2;\n                 j2 < length (snd (mk_eqcl xs zs (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! j1\n                                  < snd (mk_eqcl xs zs (Suc i) T) ! j2;\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl (Some l # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! j1\n                         < snd (mk_eqcl (Some l # xs) zs i T) ! j2", "case (2 xs zs i T)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>j1 j2.\n              \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk>\n              \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2;\n   \\<And>x. x \\<in> set (zs @ [i]) \\<Longrightarrow> x < Suc i; j1 < j2;\n   j2 < length\n         (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i])\n                (Suc i) T))\\<rbrakk>\n  \\<Longrightarrow> snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                          (zs @ [i]) (Suc i) T) !\n                    j1\n                    < snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                            (zs @ [i]) (Suc i) T) !\n                      j2\n  \\<lbrakk>?j1.0 < ?j2.0; ?j2.0 < length zs\\<rbrakk>\n  \\<Longrightarrow> zs ! ?j1.0 < zs ! ?j2.0\n  ?x \\<in> set zs \\<Longrightarrow> ?x < i\n  j1 < j2\n  j2 < length (snd (mk_eqcl (None # xs) zs i T))\n\ngoal (3 subgoals):\n 1. \\<And>zs i T.\n       \\<lbrakk>\\<And>j1 j2.\n                   \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                   \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl [] zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl [] zs i T) ! j1\n                         < snd (mk_eqcl [] zs i T) ! j2\n 2. \\<And>xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>j1 j2.\n                            \\<lbrakk>j1 < j2;\n                             j2 < length (zs @ [i])\\<rbrakk>\n                            \\<Longrightarrow> (zs @ [i]) ! j1\n        < (zs @ [i]) ! j2;\n                 \\<And>x.\n                    x \\<in> set (zs @ [i]) \\<Longrightarrow> x < Suc i;\n                 j1 < j2;\n                 j2 < length\n                       (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                              (zs @ [i]) (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> snd (mk_eqcl\n  (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                  j1\n                                  < snd (mk_eqcl\n    (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                    j2;\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl (None # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! j1\n                         < snd (mk_eqcl (None # xs) zs i T) ! j2\n 3. \\<And>l xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>j1 j2.\n                            \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                            \\<Longrightarrow> zs ! j1 < zs ! j2;\n                 \\<And>x. x \\<in> set zs \\<Longrightarrow> x < Suc i;\n                 j1 < j2;\n                 j2 < length (snd (mk_eqcl xs zs (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! j1\n                                  < snd (mk_eqcl xs zs (Suc i) T) ! j2;\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl (Some l # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! j1\n                         < snd (mk_eqcl (Some l # xs) zs i T) ! j2", "have \"\\<And>j1 j2. \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk> \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j1 j2.\n       \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk>\n       \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j1 j2.\n       \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk>\n       \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2", "fix j1 j2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j1 j2.\n       \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk>\n       \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2", "assume H: \"j1 < j2\" \"j2 < length (zs @ [i])\""], ["proof (state)\nthis:\n  j1 < j2\n  j2 < length (zs @ [i])\n\ngoal (1 subgoal):\n 1. \\<And>j1 j2.\n       \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk>\n       \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2", "hence \"j2 < length zs \\<or> j2 = length zs\""], ["proof (prove)\nusing this:\n  j1 < j2\n  j2 < length (zs @ [i])\n\ngoal (1 subgoal):\n 1. j2 < length zs \\<or> j2 = length zs", "by auto"], ["proof (state)\nthis:\n  j2 < length zs \\<or> j2 = length zs\n\ngoal (1 subgoal):\n 1. \\<And>j1 j2.\n       \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk>\n       \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2", "from this H 2"], ["proof (chain)\npicking this:\n  j2 < length zs \\<or> j2 = length zs\n  j1 < j2\n  j2 < length (zs @ [i])\n  \\<lbrakk>\\<And>j1 j2.\n              \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk>\n              \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2;\n   \\<And>x. x \\<in> set (zs @ [i]) \\<Longrightarrow> x < Suc i; j1 < j2;\n   j2 < length\n         (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i])\n                (Suc i) T))\\<rbrakk>\n  \\<Longrightarrow> snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                          (zs @ [i]) (Suc i) T) !\n                    j1\n                    < snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                            (zs @ [i]) (Suc i) T) !\n                      j2\n  \\<lbrakk>?j1.0 < ?j2.0; ?j2.0 < length zs\\<rbrakk>\n  \\<Longrightarrow> zs ! ?j1.0 < zs ! ?j2.0\n  ?x \\<in> set zs \\<Longrightarrow> ?x < i\n  j1 < j2\n  j2 < length (snd (mk_eqcl (None # xs) zs i T))", "show \"(zs @ [i]) ! j1 < (zs @ [i]) ! j2\""], ["proof (prove)\nusing this:\n  j2 < length zs \\<or> j2 = length zs\n  j1 < j2\n  j2 < length (zs @ [i])\n  \\<lbrakk>\\<And>j1 j2.\n              \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk>\n              \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2;\n   \\<And>x. x \\<in> set (zs @ [i]) \\<Longrightarrow> x < Suc i; j1 < j2;\n   j2 < length\n         (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i])\n                (Suc i) T))\\<rbrakk>\n  \\<Longrightarrow> snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                          (zs @ [i]) (Suc i) T) !\n                    j1\n                    < snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                            (zs @ [i]) (Suc i) T) !\n                      j2\n  \\<lbrakk>?j1.0 < ?j2.0; ?j2.0 < length zs\\<rbrakk>\n  \\<Longrightarrow> zs ! ?j1.0 < zs ! ?j2.0\n  ?x \\<in> set zs \\<Longrightarrow> ?x < i\n  j1 < j2\n  j2 < length (snd (mk_eqcl (None # xs) zs i T))\n\ngoal (1 subgoal):\n 1. (zs @ [i]) ! j1 < (zs @ [i]) ! j2", "by (elim disjE) (simp add: nth_append)+"], ["proof (state)\nthis:\n  (zs @ [i]) ! j1 < (zs @ [i]) ! j2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?j1.0 < ?j2.0; ?j2.0 < length (zs @ [i])\\<rbrakk>\n  \\<Longrightarrow> (zs @ [i]) ! ?j1.0 < (zs @ [i]) ! ?j2.0\n\ngoal (3 subgoals):\n 1. \\<And>zs i T.\n       \\<lbrakk>\\<And>j1 j2.\n                   \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                   \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl [] zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl [] zs i T) ! j1\n                         < snd (mk_eqcl [] zs i T) ! j2\n 2. \\<And>xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>j1 j2.\n                            \\<lbrakk>j1 < j2;\n                             j2 < length (zs @ [i])\\<rbrakk>\n                            \\<Longrightarrow> (zs @ [i]) ! j1\n        < (zs @ [i]) ! j2;\n                 \\<And>x.\n                    x \\<in> set (zs @ [i]) \\<Longrightarrow> x < Suc i;\n                 j1 < j2;\n                 j2 < length\n                       (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                              (zs @ [i]) (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> snd (mk_eqcl\n  (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                  j1\n                                  < snd (mk_eqcl\n    (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                    j2;\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl (None # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! j1\n                         < snd (mk_eqcl (None # xs) zs i T) ! j2\n 3. \\<And>l xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>j1 j2.\n                            \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                            \\<Longrightarrow> zs ! j1 < zs ! j2;\n                 \\<And>x. x \\<in> set zs \\<Longrightarrow> x < Suc i;\n                 j1 < j2;\n                 j2 < length (snd (mk_eqcl xs zs (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! j1\n                                  < snd (mk_eqcl xs zs (Suc i) T) ! j2;\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl (Some l # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! j1\n                         < snd (mk_eqcl (Some l # xs) zs i T) ! j2", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?j1.0 < ?j2.0; ?j2.0 < length (zs @ [i])\\<rbrakk>\n  \\<Longrightarrow> (zs @ [i]) ! ?j1.0 < (zs @ [i]) ! ?j2.0\n\ngoal (3 subgoals):\n 1. \\<And>zs i T.\n       \\<lbrakk>\\<And>j1 j2.\n                   \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                   \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl [] zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl [] zs i T) ! j1\n                         < snd (mk_eqcl [] zs i T) ! j2\n 2. \\<And>xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>j1 j2.\n                            \\<lbrakk>j1 < j2;\n                             j2 < length (zs @ [i])\\<rbrakk>\n                            \\<Longrightarrow> (zs @ [i]) ! j1\n        < (zs @ [i]) ! j2;\n                 \\<And>x.\n                    x \\<in> set (zs @ [i]) \\<Longrightarrow> x < Suc i;\n                 j1 < j2;\n                 j2 < length\n                       (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                              (zs @ [i]) (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> snd (mk_eqcl\n  (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                  j1\n                                  < snd (mk_eqcl\n    (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                    j2;\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl (None # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! j1\n                         < snd (mk_eqcl (None # xs) zs i T) ! j2\n 3. \\<And>l xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>j1 j2.\n                            \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                            \\<Longrightarrow> zs ! j1 < zs ! j2;\n                 \\<And>x. x \\<in> set zs \\<Longrightarrow> x < Suc i;\n                 j1 < j2;\n                 j2 < length (snd (mk_eqcl xs zs (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! j1\n                                  < snd (mk_eqcl xs zs (Suc i) T) ! j2;\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl (Some l # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! j1\n                         < snd (mk_eqcl (Some l # xs) zs i T) ! j2", "have \"\\<And>x. x \\<in> set (zs @ [i]) \\<Longrightarrow> x < Suc i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set (zs @ [i]) \\<Longrightarrow> x < Suc i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set (zs @ [i]) \\<Longrightarrow> x < Suc i", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set (zs @ [i]) \\<Longrightarrow> x < Suc i", "assume \"x \\<in> set (zs @ [i])\""], ["proof (state)\nthis:\n  x \\<in> set (zs @ [i])\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set (zs @ [i]) \\<Longrightarrow> x < Suc i", "hence \"x \\<in> set zs \\<or> x = i\""], ["proof (prove)\nusing this:\n  x \\<in> set (zs @ [i])\n\ngoal (1 subgoal):\n 1. x \\<in> set zs \\<or> x = i", "by auto"], ["proof (state)\nthis:\n  x \\<in> set zs \\<or> x = i\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set (zs @ [i]) \\<Longrightarrow> x < Suc i", "with 2(3)[of x]"], ["proof (chain)\npicking this:\n  x \\<in> set zs \\<Longrightarrow> x < i\n  x \\<in> set zs \\<or> x = i", "show \"x < Suc i\""], ["proof (prove)\nusing this:\n  x \\<in> set zs \\<Longrightarrow> x < i\n  x \\<in> set zs \\<or> x = i\n\ngoal (1 subgoal):\n 1. x < Suc i", "by auto"], ["proof (state)\nthis:\n  x < Suc i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> set (zs @ [i]) \\<Longrightarrow> ?x < Suc i\n\ngoal (3 subgoals):\n 1. \\<And>zs i T.\n       \\<lbrakk>\\<And>j1 j2.\n                   \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                   \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl [] zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl [] zs i T) ! j1\n                         < snd (mk_eqcl [] zs i T) ! j2\n 2. \\<And>xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>j1 j2.\n                            \\<lbrakk>j1 < j2;\n                             j2 < length (zs @ [i])\\<rbrakk>\n                            \\<Longrightarrow> (zs @ [i]) ! j1\n        < (zs @ [i]) ! j2;\n                 \\<And>x.\n                    x \\<in> set (zs @ [i]) \\<Longrightarrow> x < Suc i;\n                 j1 < j2;\n                 j2 < length\n                       (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                              (zs @ [i]) (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> snd (mk_eqcl\n  (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                  j1\n                                  < snd (mk_eqcl\n    (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                    j2;\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl (None # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! j1\n                         < snd (mk_eqcl (None # xs) zs i T) ! j2\n 3. \\<And>l xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>j1 j2.\n                            \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                            \\<Longrightarrow> zs ! j1 < zs ! j2;\n                 \\<And>x. x \\<in> set zs \\<Longrightarrow> x < Suc i;\n                 j1 < j2;\n                 j2 < length (snd (mk_eqcl xs zs (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! j1\n                                  < snd (mk_eqcl xs zs (Suc i) T) ! j2;\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl (Some l # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! j1\n                         < snd (mk_eqcl (Some l # xs) zs i T) ! j2", "moreover"], ["proof (state)\nthis:\n  ?x \\<in> set (zs @ [i]) \\<Longrightarrow> ?x < Suc i\n\ngoal (3 subgoals):\n 1. \\<And>zs i T.\n       \\<lbrakk>\\<And>j1 j2.\n                   \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                   \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl [] zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl [] zs i T) ! j1\n                         < snd (mk_eqcl [] zs i T) ! j2\n 2. \\<And>xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>j1 j2.\n                            \\<lbrakk>j1 < j2;\n                             j2 < length (zs @ [i])\\<rbrakk>\n                            \\<Longrightarrow> (zs @ [i]) ! j1\n        < (zs @ [i]) ! j2;\n                 \\<And>x.\n                    x \\<in> set (zs @ [i]) \\<Longrightarrow> x < Suc i;\n                 j1 < j2;\n                 j2 < length\n                       (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                              (zs @ [i]) (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> snd (mk_eqcl\n  (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                  j1\n                                  < snd (mk_eqcl\n    (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                    j2;\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl (None # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! j1\n                         < snd (mk_eqcl (None # xs) zs i T) ! j2\n 3. \\<And>l xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>j1 j2.\n                            \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                            \\<Longrightarrow> zs ! j1 < zs ! j2;\n                 \\<And>x. x \\<in> set zs \\<Longrightarrow> x < Suc i;\n                 j1 < j2;\n                 j2 < length (snd (mk_eqcl xs zs (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! j1\n                                  < snd (mk_eqcl xs zs (Suc i) T) ! j2;\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl (Some l # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! j1\n                         < snd (mk_eqcl (Some l # xs) zs i T) ! j2", "note 2(4)"], ["proof (state)\nthis:\n  j1 < j2\n\ngoal (3 subgoals):\n 1. \\<And>zs i T.\n       \\<lbrakk>\\<And>j1 j2.\n                   \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                   \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl [] zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl [] zs i T) ! j1\n                         < snd (mk_eqcl [] zs i T) ! j2\n 2. \\<And>xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>j1 j2.\n                            \\<lbrakk>j1 < j2;\n                             j2 < length (zs @ [i])\\<rbrakk>\n                            \\<Longrightarrow> (zs @ [i]) ! j1\n        < (zs @ [i]) ! j2;\n                 \\<And>x.\n                    x \\<in> set (zs @ [i]) \\<Longrightarrow> x < Suc i;\n                 j1 < j2;\n                 j2 < length\n                       (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                              (zs @ [i]) (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> snd (mk_eqcl\n  (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                  j1\n                                  < snd (mk_eqcl\n    (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                    j2;\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl (None # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! j1\n                         < snd (mk_eqcl (None # xs) zs i T) ! j2\n 3. \\<And>l xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>j1 j2.\n                            \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                            \\<Longrightarrow> zs ! j1 < zs ! j2;\n                 \\<And>x. x \\<in> set zs \\<Longrightarrow> x < Suc i;\n                 j1 < j2;\n                 j2 < length (snd (mk_eqcl xs zs (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! j1\n                                  < snd (mk_eqcl xs zs (Suc i) T) ! j2;\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl (Some l # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! j1\n                         < snd (mk_eqcl (Some l # xs) zs i T) ! j2", "moreover"], ["proof (state)\nthis:\n  j1 < j2\n\ngoal (3 subgoals):\n 1. \\<And>zs i T.\n       \\<lbrakk>\\<And>j1 j2.\n                   \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                   \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl [] zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl [] zs i T) ! j1\n                         < snd (mk_eqcl [] zs i T) ! j2\n 2. \\<And>xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>j1 j2.\n                            \\<lbrakk>j1 < j2;\n                             j2 < length (zs @ [i])\\<rbrakk>\n                            \\<Longrightarrow> (zs @ [i]) ! j1\n        < (zs @ [i]) ! j2;\n                 \\<And>x.\n                    x \\<in> set (zs @ [i]) \\<Longrightarrow> x < Suc i;\n                 j1 < j2;\n                 j2 < length\n                       (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                              (zs @ [i]) (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> snd (mk_eqcl\n  (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                  j1\n                                  < snd (mk_eqcl\n    (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                    j2;\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl (None # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! j1\n                         < snd (mk_eqcl (None # xs) zs i T) ! j2\n 3. \\<And>l xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>j1 j2.\n                            \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                            \\<Longrightarrow> zs ! j1 < zs ! j2;\n                 \\<And>x. x \\<in> set zs \\<Longrightarrow> x < Suc i;\n                 j1 < j2;\n                 j2 < length (snd (mk_eqcl xs zs (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! j1\n                                  < snd (mk_eqcl xs zs (Suc i) T) ! j2;\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl (Some l # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! j1\n                         < snd (mk_eqcl (Some l # xs) zs i T) ! j2", "from 2(5)"], ["proof (chain)\npicking this:\n  j2 < length (snd (mk_eqcl (None # xs) zs i T))", "have \"j2 < length (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T))\""], ["proof (prove)\nusing this:\n  j2 < length (snd (mk_eqcl (None # xs) zs i T))\n\ngoal (1 subgoal):\n 1. j2 < length\n          (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i])\n                 (Suc i) T))", "by (simp add: split_beta)"], ["proof (state)\nthis:\n  j2 < length\n        (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i])\n               (Suc i) T))\n\ngoal (3 subgoals):\n 1. \\<And>zs i T.\n       \\<lbrakk>\\<And>j1 j2.\n                   \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                   \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl [] zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl [] zs i T) ! j1\n                         < snd (mk_eqcl [] zs i T) ! j2\n 2. \\<And>xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>j1 j2.\n                            \\<lbrakk>j1 < j2;\n                             j2 < length (zs @ [i])\\<rbrakk>\n                            \\<Longrightarrow> (zs @ [i]) ! j1\n        < (zs @ [i]) ! j2;\n                 \\<And>x.\n                    x \\<in> set (zs @ [i]) \\<Longrightarrow> x < Suc i;\n                 j1 < j2;\n                 j2 < length\n                       (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                              (zs @ [i]) (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> snd (mk_eqcl\n  (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                  j1\n                                  < snd (mk_eqcl\n    (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                    j2;\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl (None # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! j1\n                         < snd (mk_eqcl (None # xs) zs i T) ! j2\n 3. \\<And>l xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>j1 j2.\n                            \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                            \\<Longrightarrow> zs ! j1 < zs ! j2;\n                 \\<And>x. x \\<in> set zs \\<Longrightarrow> x < Suc i;\n                 j1 < j2;\n                 j2 < length (snd (mk_eqcl xs zs (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! j1\n                                  < snd (mk_eqcl xs zs (Suc i) T) ! j2;\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl (Some l # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! j1\n                         < snd (mk_eqcl (Some l # xs) zs i T) ! j2", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>?j1.0 < ?j2.0; ?j2.0 < length (zs @ [i])\\<rbrakk>\n  \\<Longrightarrow> (zs @ [i]) ! ?j1.0 < (zs @ [i]) ! ?j2.0\n  ?x \\<in> set (zs @ [i]) \\<Longrightarrow> ?x < Suc i\n  j1 < j2\n  j2 < length\n        (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i])\n               (Suc i) T))", "have \"snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) ! j1 < snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) ! j2\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?j1.0 < ?j2.0; ?j2.0 < length (zs @ [i])\\<rbrakk>\n  \\<Longrightarrow> (zs @ [i]) ! ?j1.0 < (zs @ [i]) ! ?j2.0\n  ?x \\<in> set (zs @ [i]) \\<Longrightarrow> ?x < Suc i\n  j1 < j2\n  j2 < length\n        (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i])\n               (Suc i) T))\n\ngoal (1 subgoal):\n 1. snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n          T) !\n    j1\n    < snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n            T) !\n      j2", "by (rule 2(1))"], ["proof (state)\nthis:\n  snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n  j1\n  < snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n          T) !\n    j2\n\ngoal (3 subgoals):\n 1. \\<And>zs i T.\n       \\<lbrakk>\\<And>j1 j2.\n                   \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                   \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl [] zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl [] zs i T) ! j1\n                         < snd (mk_eqcl [] zs i T) ! j2\n 2. \\<And>xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>j1 j2.\n                            \\<lbrakk>j1 < j2;\n                             j2 < length (zs @ [i])\\<rbrakk>\n                            \\<Longrightarrow> (zs @ [i]) ! j1\n        < (zs @ [i]) ! j2;\n                 \\<And>x.\n                    x \\<in> set (zs @ [i]) \\<Longrightarrow> x < Suc i;\n                 j1 < j2;\n                 j2 < length\n                       (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                              (zs @ [i]) (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> snd (mk_eqcl\n  (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                  j1\n                                  < snd (mk_eqcl\n    (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                    j2;\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl (None # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! j1\n                         < snd (mk_eqcl (None # xs) zs i T) ! j2\n 3. \\<And>l xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>j1 j2.\n                            \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                            \\<Longrightarrow> zs ! j1 < zs ! j2;\n                 \\<And>x. x \\<in> set zs \\<Longrightarrow> x < Suc i;\n                 j1 < j2;\n                 j2 < length (snd (mk_eqcl xs zs (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! j1\n                                  < snd (mk_eqcl xs zs (Suc i) T) ! j2;\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl (Some l # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! j1\n                         < snd (mk_eqcl (Some l # xs) zs i T) ! j2", "thus ?case"], ["proof (prove)\nusing this:\n  snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n  j1\n  < snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n          T) !\n    j2\n\ngoal (1 subgoal):\n 1. snd (mk_eqcl (None # xs) zs i T) ! j1\n    < snd (mk_eqcl (None # xs) zs i T) ! j2", "by (simp add: split_beta)"], ["proof (state)\nthis:\n  snd (mk_eqcl (None # xs) zs i T) ! j1\n  < snd (mk_eqcl (None # xs) zs i T) ! j2\n\ngoal (2 subgoals):\n 1. \\<And>zs i T.\n       \\<lbrakk>\\<And>j1 j2.\n                   \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                   \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl [] zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl [] zs i T) ! j1\n                         < snd (mk_eqcl [] zs i T) ! j2\n 2. \\<And>l xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>j1 j2.\n                            \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                            \\<Longrightarrow> zs ! j1 < zs ! j2;\n                 \\<And>x. x \\<in> set zs \\<Longrightarrow> x < Suc i;\n                 j1 < j2;\n                 j2 < length (snd (mk_eqcl xs zs (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! j1\n                                  < snd (mk_eqcl xs zs (Suc i) T) ! j2;\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl (Some l # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! j1\n                         < snd (mk_eqcl (Some l # xs) zs i T) ! j2", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>zs i T.\n       \\<lbrakk>\\<And>j1 j2.\n                   \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                   \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl [] zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl [] zs i T) ! j1\n                         < snd (mk_eqcl [] zs i T) ! j2\n 2. \\<And>l xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>j1 j2.\n                            \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                            \\<Longrightarrow> zs ! j1 < zs ! j2;\n                 \\<And>x. x \\<in> set zs \\<Longrightarrow> x < Suc i;\n                 j1 < j2;\n                 j2 < length (snd (mk_eqcl xs zs (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! j1\n                                  < snd (mk_eqcl xs zs (Suc i) T) ! j2;\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl (Some l # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! j1\n                         < snd (mk_eqcl (Some l # xs) zs i T) ! j2", "case (3 l xs zs i T)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>j1 j2.\n              \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n              \\<Longrightarrow> zs ! j1 < zs ! j2;\n   \\<And>x. x \\<in> set zs \\<Longrightarrow> x < Suc i; j1 < j2;\n   j2 < length (snd (mk_eqcl xs zs (Suc i) T))\\<rbrakk>\n  \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! j1\n                    < snd (mk_eqcl xs zs (Suc i) T) ! j2\n  \\<lbrakk>?j1.0 < ?j2.0; ?j2.0 < length zs\\<rbrakk>\n  \\<Longrightarrow> zs ! ?j1.0 < zs ! ?j2.0\n  ?x \\<in> set zs \\<Longrightarrow> ?x < i\n  j1 < j2\n  j2 < length (snd (mk_eqcl (Some l # xs) zs i T))\n\ngoal (2 subgoals):\n 1. \\<And>zs i T.\n       \\<lbrakk>\\<And>j1 j2.\n                   \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                   \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl [] zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl [] zs i T) ! j1\n                         < snd (mk_eqcl [] zs i T) ! j2\n 2. \\<And>l xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>j1 j2.\n                            \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                            \\<Longrightarrow> zs ! j1 < zs ! j2;\n                 \\<And>x. x \\<in> set zs \\<Longrightarrow> x < Suc i;\n                 j1 < j2;\n                 j2 < length (snd (mk_eqcl xs zs (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! j1\n                                  < snd (mk_eqcl xs zs (Suc i) T) ! j2;\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl (Some l # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! j1\n                         < snd (mk_eqcl (Some l # xs) zs i T) ! j2", "note 3(2)"], ["proof (state)\nthis:\n  \\<lbrakk>?j1.0 < ?j2.0; ?j2.0 < length zs\\<rbrakk>\n  \\<Longrightarrow> zs ! ?j1.0 < zs ! ?j2.0\n\ngoal (2 subgoals):\n 1. \\<And>zs i T.\n       \\<lbrakk>\\<And>j1 j2.\n                   \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                   \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl [] zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl [] zs i T) ! j1\n                         < snd (mk_eqcl [] zs i T) ! j2\n 2. \\<And>l xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>j1 j2.\n                            \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                            \\<Longrightarrow> zs ! j1 < zs ! j2;\n                 \\<And>x. x \\<in> set zs \\<Longrightarrow> x < Suc i;\n                 j1 < j2;\n                 j2 < length (snd (mk_eqcl xs zs (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! j1\n                                  < snd (mk_eqcl xs zs (Suc i) T) ! j2;\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl (Some l # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! j1\n                         < snd (mk_eqcl (Some l # xs) zs i T) ! j2", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?j1.0 < ?j2.0; ?j2.0 < length zs\\<rbrakk>\n  \\<Longrightarrow> zs ! ?j1.0 < zs ! ?j2.0\n\ngoal (2 subgoals):\n 1. \\<And>zs i T.\n       \\<lbrakk>\\<And>j1 j2.\n                   \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                   \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl [] zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl [] zs i T) ! j1\n                         < snd (mk_eqcl [] zs i T) ! j2\n 2. \\<And>l xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>j1 j2.\n                            \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                            \\<Longrightarrow> zs ! j1 < zs ! j2;\n                 \\<And>x. x \\<in> set zs \\<Longrightarrow> x < Suc i;\n                 j1 < j2;\n                 j2 < length (snd (mk_eqcl xs zs (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! j1\n                                  < snd (mk_eqcl xs zs (Suc i) T) ! j2;\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl (Some l # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! j1\n                         < snd (mk_eqcl (Some l # xs) zs i T) ! j2", "have \"\\<And>x. x \\<in> set zs \\<Longrightarrow> x < Suc i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set zs \\<Longrightarrow> x < Suc i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set zs \\<Longrightarrow> x < Suc i", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set zs \\<Longrightarrow> x < Suc i", "assume \"x \\<in> set zs\""], ["proof (state)\nthis:\n  x \\<in> set zs\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set zs \\<Longrightarrow> x < Suc i", "with 3(3)[of x]"], ["proof (chain)\npicking this:\n  x \\<in> set zs \\<Longrightarrow> x < i\n  x \\<in> set zs", "show \"x < Suc i\""], ["proof (prove)\nusing this:\n  x \\<in> set zs \\<Longrightarrow> x < i\n  x \\<in> set zs\n\ngoal (1 subgoal):\n 1. x < Suc i", "by simp"], ["proof (state)\nthis:\n  x < Suc i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> set zs \\<Longrightarrow> ?x < Suc i\n\ngoal (2 subgoals):\n 1. \\<And>zs i T.\n       \\<lbrakk>\\<And>j1 j2.\n                   \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                   \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl [] zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl [] zs i T) ! j1\n                         < snd (mk_eqcl [] zs i T) ! j2\n 2. \\<And>l xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>j1 j2.\n                            \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                            \\<Longrightarrow> zs ! j1 < zs ! j2;\n                 \\<And>x. x \\<in> set zs \\<Longrightarrow> x < Suc i;\n                 j1 < j2;\n                 j2 < length (snd (mk_eqcl xs zs (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! j1\n                                  < snd (mk_eqcl xs zs (Suc i) T) ! j2;\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl (Some l # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! j1\n                         < snd (mk_eqcl (Some l # xs) zs i T) ! j2", "moreover"], ["proof (state)\nthis:\n  ?x \\<in> set zs \\<Longrightarrow> ?x < Suc i\n\ngoal (2 subgoals):\n 1. \\<And>zs i T.\n       \\<lbrakk>\\<And>j1 j2.\n                   \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                   \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl [] zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl [] zs i T) ! j1\n                         < snd (mk_eqcl [] zs i T) ! j2\n 2. \\<And>l xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>j1 j2.\n                            \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                            \\<Longrightarrow> zs ! j1 < zs ! j2;\n                 \\<And>x. x \\<in> set zs \\<Longrightarrow> x < Suc i;\n                 j1 < j2;\n                 j2 < length (snd (mk_eqcl xs zs (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! j1\n                                  < snd (mk_eqcl xs zs (Suc i) T) ! j2;\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl (Some l # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! j1\n                         < snd (mk_eqcl (Some l # xs) zs i T) ! j2", "note 3(4)"], ["proof (state)\nthis:\n  j1 < j2\n\ngoal (2 subgoals):\n 1. \\<And>zs i T.\n       \\<lbrakk>\\<And>j1 j2.\n                   \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                   \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl [] zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl [] zs i T) ! j1\n                         < snd (mk_eqcl [] zs i T) ! j2\n 2. \\<And>l xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>j1 j2.\n                            \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                            \\<Longrightarrow> zs ! j1 < zs ! j2;\n                 \\<And>x. x \\<in> set zs \\<Longrightarrow> x < Suc i;\n                 j1 < j2;\n                 j2 < length (snd (mk_eqcl xs zs (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! j1\n                                  < snd (mk_eqcl xs zs (Suc i) T) ! j2;\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl (Some l # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! j1\n                         < snd (mk_eqcl (Some l # xs) zs i T) ! j2", "moreover"], ["proof (state)\nthis:\n  j1 < j2\n\ngoal (2 subgoals):\n 1. \\<And>zs i T.\n       \\<lbrakk>\\<And>j1 j2.\n                   \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                   \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl [] zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl [] zs i T) ! j1\n                         < snd (mk_eqcl [] zs i T) ! j2\n 2. \\<And>l xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>j1 j2.\n                            \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                            \\<Longrightarrow> zs ! j1 < zs ! j2;\n                 \\<And>x. x \\<in> set zs \\<Longrightarrow> x < Suc i;\n                 j1 < j2;\n                 j2 < length (snd (mk_eqcl xs zs (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! j1\n                                  < snd (mk_eqcl xs zs (Suc i) T) ! j2;\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl (Some l # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! j1\n                         < snd (mk_eqcl (Some l # xs) zs i T) ! j2", "from 3(5)"], ["proof (chain)\npicking this:\n  j2 < length (snd (mk_eqcl (Some l # xs) zs i T))", "have \"j2 < length (snd (mk_eqcl xs zs (Suc i) T))\""], ["proof (prove)\nusing this:\n  j2 < length (snd (mk_eqcl (Some l # xs) zs i T))\n\ngoal (1 subgoal):\n 1. j2 < length (snd (mk_eqcl xs zs (Suc i) T))", "by (simp add: split_beta)"], ["proof (state)\nthis:\n  j2 < length (snd (mk_eqcl xs zs (Suc i) T))\n\ngoal (2 subgoals):\n 1. \\<And>zs i T.\n       \\<lbrakk>\\<And>j1 j2.\n                   \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                   \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl [] zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl [] zs i T) ! j1\n                         < snd (mk_eqcl [] zs i T) ! j2\n 2. \\<And>l xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>j1 j2.\n                            \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                            \\<Longrightarrow> zs ! j1 < zs ! j2;\n                 \\<And>x. x \\<in> set zs \\<Longrightarrow> x < Suc i;\n                 j1 < j2;\n                 j2 < length (snd (mk_eqcl xs zs (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! j1\n                                  < snd (mk_eqcl xs zs (Suc i) T) ! j2;\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl (Some l # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! j1\n                         < snd (mk_eqcl (Some l # xs) zs i T) ! j2", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>?j1.0 < ?j2.0; ?j2.0 < length zs\\<rbrakk>\n  \\<Longrightarrow> zs ! ?j1.0 < zs ! ?j2.0\n  ?x \\<in> set zs \\<Longrightarrow> ?x < Suc i\n  j1 < j2\n  j2 < length (snd (mk_eqcl xs zs (Suc i) T))", "have \"snd (mk_eqcl xs zs (Suc i) T) ! j1 < snd (mk_eqcl xs zs (Suc i) T) ! j2\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?j1.0 < ?j2.0; ?j2.0 < length zs\\<rbrakk>\n  \\<Longrightarrow> zs ! ?j1.0 < zs ! ?j2.0\n  ?x \\<in> set zs \\<Longrightarrow> ?x < Suc i\n  j1 < j2\n  j2 < length (snd (mk_eqcl xs zs (Suc i) T))\n\ngoal (1 subgoal):\n 1. snd (mk_eqcl xs zs (Suc i) T) ! j1 < snd (mk_eqcl xs zs (Suc i) T) ! j2", "by (rule 3(1))"], ["proof (state)\nthis:\n  snd (mk_eqcl xs zs (Suc i) T) ! j1 < snd (mk_eqcl xs zs (Suc i) T) ! j2\n\ngoal (2 subgoals):\n 1. \\<And>zs i T.\n       \\<lbrakk>\\<And>j1 j2.\n                   \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                   \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl [] zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl [] zs i T) ! j1\n                         < snd (mk_eqcl [] zs i T) ! j2\n 2. \\<And>l xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>j1 j2.\n                            \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                            \\<Longrightarrow> zs ! j1 < zs ! j2;\n                 \\<And>x. x \\<in> set zs \\<Longrightarrow> x < Suc i;\n                 j1 < j2;\n                 j2 < length (snd (mk_eqcl xs zs (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! j1\n                                  < snd (mk_eqcl xs zs (Suc i) T) ! j2;\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl (Some l # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! j1\n                         < snd (mk_eqcl (Some l # xs) zs i T) ! j2", "thus ?case"], ["proof (prove)\nusing this:\n  snd (mk_eqcl xs zs (Suc i) T) ! j1 < snd (mk_eqcl xs zs (Suc i) T) ! j2\n\ngoal (1 subgoal):\n 1. snd (mk_eqcl (Some l # xs) zs i T) ! j1\n    < snd (mk_eqcl (Some l # xs) zs i T) ! j2", "by (simp add: split_beta)"], ["proof (state)\nthis:\n  snd (mk_eqcl (Some l # xs) zs i T) ! j1\n  < snd (mk_eqcl (Some l # xs) zs i T) ! j2\n\ngoal (1 subgoal):\n 1. \\<And>zs i T.\n       \\<lbrakk>\\<And>j1 j2.\n                   \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                   \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>x. x \\<in> set zs \\<Longrightarrow> x < i; j1 < j2;\n        j2 < length (snd (mk_eqcl [] zs i T))\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl [] zs i T) ! j1\n                         < snd (mk_eqcl [] zs i T) ! j2", "qed simp"], ["", "lemma mk_eqcl_snd_nth:\n  assumes \"i < length zs\"\n  shows \"snd (mk_eqcl xs zs j T) ! i = zs ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (mk_eqcl xs zs j T) ! i = zs ! i", "using assms"], ["proof (prove)\nusing this:\n  i < length zs\n\ngoal (1 subgoal):\n 1. snd (mk_eqcl xs zs j T) ! i = zs ! i", "by (induct xs zs j T rule: mk_eqcl.induct) (simp add: split_beta nth_append)+"], ["", "lemma mk_eqcl_bound:\n  assumes \"\\<And>x k. \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk> \\<Longrightarrow> k < length zs\"\n  and \"x \\<in> set (fst (mk_eqcl xs zs ii T))\"\n  shows \"x < length (snd (mk_eqcl xs zs ii T))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < length (snd (mk_eqcl xs zs ii T))", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set xs; ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length zs\n  x \\<in> set (fst (mk_eqcl xs zs ii T))\n\ngoal (1 subgoal):\n 1. x < length (snd (mk_eqcl xs zs ii T))", "proof (induct xs zs ii T rule: mk_eqcl.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>zs i T.\n       \\<lbrakk>\\<And>x k.\n                   \\<lbrakk>x \\<in> set []; x = Some k\\<rbrakk>\n                   \\<Longrightarrow> k < length zs;\n        x \\<in> set (fst (mk_eqcl [] zs i T))\\<rbrakk>\n       \\<Longrightarrow> x < length (snd (mk_eqcl [] zs i T))\n 2. \\<And>xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>x k.\n                            \\<lbrakk>x \\<in> set\n        (mk_eqcl' xs i (Suc i) (length zs) T);\n                             x = Some k\\<rbrakk>\n                            \\<Longrightarrow> k < length (zs @ [i]);\n                 x \\<in> set (fst (mk_eqcl\n                                    (mk_eqcl' xs i (Suc i) (length zs) T)\n                                    (zs @ [i]) (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> x < length\n (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T));\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (None # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        x \\<in> set (fst (mk_eqcl (None # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> x < length (snd (mk_eqcl (None # xs) zs i T))\n 3. \\<And>l xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>x k.\n                            \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                            \\<Longrightarrow> k < length zs;\n                 x \\<in> set (fst (mk_eqcl xs zs (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> x < length\n (snd (mk_eqcl xs zs (Suc i) T));\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (Some l # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        x \\<in> set (fst (mk_eqcl (Some l # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> x < length (snd (mk_eqcl (Some l # xs) zs i T))", "case (2 xs zs i T)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>x k.\n              \\<lbrakk>x \\<in> set (mk_eqcl' xs i (Suc i) (length zs) T);\n               x = Some k\\<rbrakk>\n              \\<Longrightarrow> k < length (zs @ [i]);\n   x \\<in> set (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                      (zs @ [i]) (Suc i) T))\\<rbrakk>\n  \\<Longrightarrow> x < length\n                         (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                                (zs @ [i]) (Suc i) T))\n  \\<lbrakk>?x \\<in> set (None # xs); ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length zs\n  x \\<in> set (fst (mk_eqcl (None # xs) zs i T))\n\ngoal (3 subgoals):\n 1. \\<And>zs i T.\n       \\<lbrakk>\\<And>x k.\n                   \\<lbrakk>x \\<in> set []; x = Some k\\<rbrakk>\n                   \\<Longrightarrow> k < length zs;\n        x \\<in> set (fst (mk_eqcl [] zs i T))\\<rbrakk>\n       \\<Longrightarrow> x < length (snd (mk_eqcl [] zs i T))\n 2. \\<And>xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>x k.\n                            \\<lbrakk>x \\<in> set\n        (mk_eqcl' xs i (Suc i) (length zs) T);\n                             x = Some k\\<rbrakk>\n                            \\<Longrightarrow> k < length (zs @ [i]);\n                 x \\<in> set (fst (mk_eqcl\n                                    (mk_eqcl' xs i (Suc i) (length zs) T)\n                                    (zs @ [i]) (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> x < length\n (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T));\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (None # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        x \\<in> set (fst (mk_eqcl (None # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> x < length (snd (mk_eqcl (None # xs) zs i T))\n 3. \\<And>l xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>x k.\n                            \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                            \\<Longrightarrow> k < length zs;\n                 x \\<in> set (fst (mk_eqcl xs zs (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> x < length\n (snd (mk_eqcl xs zs (Suc i) T));\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (Some l # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        x \\<in> set (fst (mk_eqcl (Some l # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> x < length (snd (mk_eqcl (Some l # xs) zs i T))", "hence \"x = length zs \\<or> x \\<in> set (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x k.\n              \\<lbrakk>x \\<in> set (mk_eqcl' xs i (Suc i) (length zs) T);\n               x = Some k\\<rbrakk>\n              \\<Longrightarrow> k < length (zs @ [i]);\n   x \\<in> set (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                      (zs @ [i]) (Suc i) T))\\<rbrakk>\n  \\<Longrightarrow> x < length\n                         (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                                (zs @ [i]) (Suc i) T))\n  \\<lbrakk>?x \\<in> set (None # xs); ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length zs\n  x \\<in> set (fst (mk_eqcl (None # xs) zs i T))\n\ngoal (1 subgoal):\n 1. x = length zs \\<or>\n    x \\<in> set (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                       (zs @ [i]) (Suc i) T))", "by (auto simp: split_beta)"], ["proof (state)\nthis:\n  x = length zs \\<or>\n  x \\<in> set (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i])\n                     (Suc i) T))\n\ngoal (3 subgoals):\n 1. \\<And>zs i T.\n       \\<lbrakk>\\<And>x k.\n                   \\<lbrakk>x \\<in> set []; x = Some k\\<rbrakk>\n                   \\<Longrightarrow> k < length zs;\n        x \\<in> set (fst (mk_eqcl [] zs i T))\\<rbrakk>\n       \\<Longrightarrow> x < length (snd (mk_eqcl [] zs i T))\n 2. \\<And>xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>x k.\n                            \\<lbrakk>x \\<in> set\n        (mk_eqcl' xs i (Suc i) (length zs) T);\n                             x = Some k\\<rbrakk>\n                            \\<Longrightarrow> k < length (zs @ [i]);\n                 x \\<in> set (fst (mk_eqcl\n                                    (mk_eqcl' xs i (Suc i) (length zs) T)\n                                    (zs @ [i]) (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> x < length\n (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T));\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (None # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        x \\<in> set (fst (mk_eqcl (None # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> x < length (snd (mk_eqcl (None # xs) zs i T))\n 3. \\<And>l xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>x k.\n                            \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                            \\<Longrightarrow> k < length zs;\n                 x \\<in> set (fst (mk_eqcl xs zs (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> x < length\n (snd (mk_eqcl xs zs (Suc i) T));\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (Some l # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        x \\<in> set (fst (mk_eqcl (Some l # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> x < length (snd (mk_eqcl (Some l # xs) zs i T))", "thus ?case"], ["proof (prove)\nusing this:\n  x = length zs \\<or>\n  x \\<in> set (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i])\n                     (Suc i) T))\n\ngoal (1 subgoal):\n 1. x < length (snd (mk_eqcl (None # xs) zs i T))", "proof (elim disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. x = length zs \\<Longrightarrow>\n    x < length (snd (mk_eqcl (None # xs) zs i T))\n 2. x \\<in> set (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                       (zs @ [i]) (Suc i) T)) \\<Longrightarrow>\n    x < length (snd (mk_eqcl (None # xs) zs i T))", "assume \"x = length zs\""], ["proof (state)\nthis:\n  x = length zs\n\ngoal (2 subgoals):\n 1. x = length zs \\<Longrightarrow>\n    x < length (snd (mk_eqcl (None # xs) zs i T))\n 2. x \\<in> set (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                       (zs @ [i]) (Suc i) T)) \\<Longrightarrow>\n    x < length (snd (mk_eqcl (None # xs) zs i T))", "hence \"x < length (zs @ [i])\""], ["proof (prove)\nusing this:\n  x = length zs\n\ngoal (1 subgoal):\n 1. x < length (zs @ [i])", "by simp"], ["proof (state)\nthis:\n  x < length (zs @ [i])\n\ngoal (2 subgoals):\n 1. x = length zs \\<Longrightarrow>\n    x < length (snd (mk_eqcl (None # xs) zs i T))\n 2. x \\<in> set (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                       (zs @ [i]) (Suc i) T)) \\<Longrightarrow>\n    x < length (snd (mk_eqcl (None # xs) zs i T))", "also"], ["proof (state)\nthis:\n  x < length (zs @ [i])\n\ngoal (2 subgoals):\n 1. x = length zs \\<Longrightarrow>\n    x < length (snd (mk_eqcl (None # xs) zs i T))\n 2. x \\<in> set (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                       (zs @ [i]) (Suc i) T)) \\<Longrightarrow>\n    x < length (snd (mk_eqcl (None # xs) zs i T))", "have \"\\<dots> \\<le> length (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (zs @ [i])\n    \\<le> length\n           (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i])\n                  (Suc i) T))", "by (simp only: mk_eqcl_len_snd)"], ["proof (state)\nthis:\n  length (zs @ [i])\n  \\<le> length\n         (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i])\n                (Suc i) T))\n\ngoal (2 subgoals):\n 1. x = length zs \\<Longrightarrow>\n    x < length (snd (mk_eqcl (None # xs) zs i T))\n 2. x \\<in> set (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                       (zs @ [i]) (Suc i) T)) \\<Longrightarrow>\n    x < length (snd (mk_eqcl (None # xs) zs i T))", "finally"], ["proof (chain)\npicking this:\n  x < length\n       (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i])\n              (Suc i) T))", "show ?thesis"], ["proof (prove)\nusing this:\n  x < length\n       (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i])\n              (Suc i) T))\n\ngoal (1 subgoal):\n 1. x < length (snd (mk_eqcl (None # xs) zs i T))", "by (simp add: split_beta)"], ["proof (state)\nthis:\n  x < length (snd (mk_eqcl (None # xs) zs i T))\n\ngoal (1 subgoal):\n 1. x \\<in> set (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                       (zs @ [i]) (Suc i) T)) \\<Longrightarrow>\n    x < length (snd (mk_eqcl (None # xs) zs i T))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> set (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                       (zs @ [i]) (Suc i) T)) \\<Longrightarrow>\n    x < length (snd (mk_eqcl (None # xs) zs i T))", "assume H: \"x \\<in> set (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T))\""], ["proof (state)\nthis:\n  x \\<in> set (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i])\n                     (Suc i) T))\n\ngoal (1 subgoal):\n 1. x \\<in> set (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                       (zs @ [i]) (Suc i) T)) \\<Longrightarrow>\n    x < length (snd (mk_eqcl (None # xs) zs i T))", "have \"\\<And>x k. \\<lbrakk>x \\<in> set (mk_eqcl' xs i (Suc i) (length zs) T); x = Some k\\<rbrakk> \\<Longrightarrow> k < length (zs @ [i])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x k.\n       \\<lbrakk>x \\<in> set (mk_eqcl' xs i (Suc i) (length zs) T);\n        x = Some k\\<rbrakk>\n       \\<Longrightarrow> k < length (zs @ [i])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x k.\n       \\<lbrakk>x \\<in> set (mk_eqcl' xs i (Suc i) (length zs) T);\n        x = Some k\\<rbrakk>\n       \\<Longrightarrow> k < length (zs @ [i])", "fix x k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x k.\n       \\<lbrakk>x \\<in> set (mk_eqcl' xs i (Suc i) (length zs) T);\n        x = Some k\\<rbrakk>\n       \\<Longrightarrow> k < length (zs @ [i])", "assume H': \"x \\<in> set (mk_eqcl' xs i (Suc i) (length zs) T)\" \" x = Some k\""], ["proof (state)\nthis:\n  x \\<in> set (mk_eqcl' xs i (Suc i) (length zs) T)\n  x = Some k\n\ngoal (1 subgoal):\n 1. \\<And>x k.\n       \\<lbrakk>x \\<in> set (mk_eqcl' xs i (Suc i) (length zs) T);\n        x = Some k\\<rbrakk>\n       \\<Longrightarrow> k < length (zs @ [i])", "{"], ["proof (state)\nthis:\n  x \\<in> set (mk_eqcl' xs i (Suc i) (length zs) T)\n  x = Some k\n\ngoal (1 subgoal):\n 1. \\<And>x k.\n       \\<lbrakk>x \\<in> set (mk_eqcl' xs i (Suc i) (length zs) T);\n        x = Some k\\<rbrakk>\n       \\<Longrightarrow> k < length (zs @ [i])", "fix x' k'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x k.\n       \\<lbrakk>x \\<in> set (mk_eqcl' xs i (Suc i) (length zs) T);\n        x = Some k\\<rbrakk>\n       \\<Longrightarrow> k < length (zs @ [i])", "assume \"x' \\<in> set xs\" \"x' = Some k'\""], ["proof (state)\nthis:\n  x' \\<in> set xs\n  x' = Some k'\n\ngoal (1 subgoal):\n 1. \\<And>x k.\n       \\<lbrakk>x \\<in> set (mk_eqcl' xs i (Suc i) (length zs) T);\n        x = Some k\\<rbrakk>\n       \\<Longrightarrow> k < length (zs @ [i])", "with 2"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x k.\n              \\<lbrakk>x \\<in> set (mk_eqcl' xs i (Suc i) (length zs) T);\n               x = Some k\\<rbrakk>\n              \\<Longrightarrow> k < length (zs @ [i]);\n   x \\<in> set (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                      (zs @ [i]) (Suc i) T))\\<rbrakk>\n  \\<Longrightarrow> x < length\n                         (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                                (zs @ [i]) (Suc i) T))\n  \\<lbrakk>?x \\<in> set (None # xs); ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length zs\n  x \\<in> set (fst (mk_eqcl (None # xs) zs i T))\n  x' \\<in> set xs\n  x' = Some k'", "have \"k' < length zs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x k.\n              \\<lbrakk>x \\<in> set (mk_eqcl' xs i (Suc i) (length zs) T);\n               x = Some k\\<rbrakk>\n              \\<Longrightarrow> k < length (zs @ [i]);\n   x \\<in> set (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                      (zs @ [i]) (Suc i) T))\\<rbrakk>\n  \\<Longrightarrow> x < length\n                         (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                                (zs @ [i]) (Suc i) T))\n  \\<lbrakk>?x \\<in> set (None # xs); ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length zs\n  x \\<in> set (fst (mk_eqcl (None # xs) zs i T))\n  x' \\<in> set xs\n  x' = Some k'\n\ngoal (1 subgoal):\n 1. k' < length zs", "by simp"], ["proof (state)\nthis:\n  k' < length zs\n\ngoal (1 subgoal):\n 1. \\<And>x k.\n       \\<lbrakk>x \\<in> set (mk_eqcl' xs i (Suc i) (length zs) T);\n        x = Some k\\<rbrakk>\n       \\<Longrightarrow> k < length (zs @ [i])", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?x'2 \\<in> set xs; ?x'2 = Some ?k'2\\<rbrakk>\n  \\<Longrightarrow> ?k'2 < length zs\n\ngoal (1 subgoal):\n 1. \\<And>x k.\n       \\<lbrakk>x \\<in> set (mk_eqcl' xs i (Suc i) (length zs) T);\n        x = Some k\\<rbrakk>\n       \\<Longrightarrow> k < length (zs @ [i])", "from this H'"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x'2 \\<in> set xs; ?x'2 = Some ?k'2\\<rbrakk>\n  \\<Longrightarrow> ?k'2 < length zs\n  x \\<in> set (mk_eqcl' xs i (Suc i) (length zs) T)\n  x = Some k", "have \"k \\<le> length zs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x'2 \\<in> set xs; ?x'2 = Some ?k'2\\<rbrakk>\n  \\<Longrightarrow> ?k'2 < length zs\n  x \\<in> set (mk_eqcl' xs i (Suc i) (length zs) T)\n  x = Some k\n\ngoal (1 subgoal):\n 1. k \\<le> length zs", "by (rule mk_eqcl'_bound)"], ["proof (state)\nthis:\n  k \\<le> length zs\n\ngoal (1 subgoal):\n 1. \\<And>x k.\n       \\<lbrakk>x \\<in> set (mk_eqcl' xs i (Suc i) (length zs) T);\n        x = Some k\\<rbrakk>\n       \\<Longrightarrow> k < length (zs @ [i])", "thus \"k < length (zs @ [i])\""], ["proof (prove)\nusing this:\n  k \\<le> length zs\n\ngoal (1 subgoal):\n 1. k < length (zs @ [i])", "by simp"], ["proof (state)\nthis:\n  k < length (zs @ [i])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> set (mk_eqcl' xs i (Suc i) (length zs) T);\n   ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length (zs @ [i])\n\ngoal (1 subgoal):\n 1. x \\<in> set (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                       (zs @ [i]) (Suc i) T)) \\<Longrightarrow>\n    x < length (snd (mk_eqcl (None # xs) zs i T))", "with H 2"], ["proof (chain)\npicking this:\n  x \\<in> set (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i])\n                     (Suc i) T))\n  \\<lbrakk>\\<And>x k.\n              \\<lbrakk>x \\<in> set (mk_eqcl' xs i (Suc i) (length zs) T);\n               x = Some k\\<rbrakk>\n              \\<Longrightarrow> k < length (zs @ [i]);\n   x \\<in> set (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                      (zs @ [i]) (Suc i) T))\\<rbrakk>\n  \\<Longrightarrow> x < length\n                         (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                                (zs @ [i]) (Suc i) T))\n  \\<lbrakk>?x \\<in> set (None # xs); ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length zs\n  x \\<in> set (fst (mk_eqcl (None # xs) zs i T))\n  \\<lbrakk>?x \\<in> set (mk_eqcl' xs i (Suc i) (length zs) T);\n   ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length (zs @ [i])", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> set (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i])\n                     (Suc i) T))\n  \\<lbrakk>\\<And>x k.\n              \\<lbrakk>x \\<in> set (mk_eqcl' xs i (Suc i) (length zs) T);\n               x = Some k\\<rbrakk>\n              \\<Longrightarrow> k < length (zs @ [i]);\n   x \\<in> set (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                      (zs @ [i]) (Suc i) T))\\<rbrakk>\n  \\<Longrightarrow> x < length\n                         (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                                (zs @ [i]) (Suc i) T))\n  \\<lbrakk>?x \\<in> set (None # xs); ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length zs\n  x \\<in> set (fst (mk_eqcl (None # xs) zs i T))\n  \\<lbrakk>?x \\<in> set (mk_eqcl' xs i (Suc i) (length zs) T);\n   ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length (zs @ [i])\n\ngoal (1 subgoal):\n 1. x < length (snd (mk_eqcl (None # xs) zs i T))", "by (simp add: split_beta)"], ["proof (state)\nthis:\n  x < length (snd (mk_eqcl (None # xs) zs i T))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x < length (snd (mk_eqcl (None # xs) zs i T))\n\ngoal (2 subgoals):\n 1. \\<And>zs i T.\n       \\<lbrakk>\\<And>x k.\n                   \\<lbrakk>x \\<in> set []; x = Some k\\<rbrakk>\n                   \\<Longrightarrow> k < length zs;\n        x \\<in> set (fst (mk_eqcl [] zs i T))\\<rbrakk>\n       \\<Longrightarrow> x < length (snd (mk_eqcl [] zs i T))\n 2. \\<And>l xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>x k.\n                            \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                            \\<Longrightarrow> k < length zs;\n                 x \\<in> set (fst (mk_eqcl xs zs (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> x < length\n (snd (mk_eqcl xs zs (Suc i) T));\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (Some l # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        x \\<in> set (fst (mk_eqcl (Some l # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> x < length (snd (mk_eqcl (Some l # xs) zs i T))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>zs i T.\n       \\<lbrakk>\\<And>x k.\n                   \\<lbrakk>x \\<in> set []; x = Some k\\<rbrakk>\n                   \\<Longrightarrow> k < length zs;\n        x \\<in> set (fst (mk_eqcl [] zs i T))\\<rbrakk>\n       \\<Longrightarrow> x < length (snd (mk_eqcl [] zs i T))\n 2. \\<And>l xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>x k.\n                            \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                            \\<Longrightarrow> k < length zs;\n                 x \\<in> set (fst (mk_eqcl xs zs (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> x < length\n (snd (mk_eqcl xs zs (Suc i) T));\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (Some l # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        x \\<in> set (fst (mk_eqcl (Some l # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> x < length (snd (mk_eqcl (Some l # xs) zs i T))", "case (3 l xs zs i T)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>x k.\n              \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n              \\<Longrightarrow> k < length zs;\n   x \\<in> set (fst (mk_eqcl xs zs (Suc i) T))\\<rbrakk>\n  \\<Longrightarrow> x < length (snd (mk_eqcl xs zs (Suc i) T))\n  \\<lbrakk>?x \\<in> set (Some l # xs); ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length zs\n  x \\<in> set (fst (mk_eqcl (Some l # xs) zs i T))\n\ngoal (2 subgoals):\n 1. \\<And>zs i T.\n       \\<lbrakk>\\<And>x k.\n                   \\<lbrakk>x \\<in> set []; x = Some k\\<rbrakk>\n                   \\<Longrightarrow> k < length zs;\n        x \\<in> set (fst (mk_eqcl [] zs i T))\\<rbrakk>\n       \\<Longrightarrow> x < length (snd (mk_eqcl [] zs i T))\n 2. \\<And>l xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>x k.\n                            \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                            \\<Longrightarrow> k < length zs;\n                 x \\<in> set (fst (mk_eqcl xs zs (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> x < length\n (snd (mk_eqcl xs zs (Suc i) T));\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (Some l # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        x \\<in> set (fst (mk_eqcl (Some l # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> x < length (snd (mk_eqcl (Some l # xs) zs i T))", "hence \"x = l \\<or> x \\<in> set (fst (mk_eqcl xs zs (Suc i) T))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x k.\n              \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n              \\<Longrightarrow> k < length zs;\n   x \\<in> set (fst (mk_eqcl xs zs (Suc i) T))\\<rbrakk>\n  \\<Longrightarrow> x < length (snd (mk_eqcl xs zs (Suc i) T))\n  \\<lbrakk>?x \\<in> set (Some l # xs); ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length zs\n  x \\<in> set (fst (mk_eqcl (Some l # xs) zs i T))\n\ngoal (1 subgoal):\n 1. x = l \\<or> x \\<in> set (fst (mk_eqcl xs zs (Suc i) T))", "by (auto simp: split_beta)"], ["proof (state)\nthis:\n  x = l \\<or> x \\<in> set (fst (mk_eqcl xs zs (Suc i) T))\n\ngoal (2 subgoals):\n 1. \\<And>zs i T.\n       \\<lbrakk>\\<And>x k.\n                   \\<lbrakk>x \\<in> set []; x = Some k\\<rbrakk>\n                   \\<Longrightarrow> k < length zs;\n        x \\<in> set (fst (mk_eqcl [] zs i T))\\<rbrakk>\n       \\<Longrightarrow> x < length (snd (mk_eqcl [] zs i T))\n 2. \\<And>l xs zs i T.\n       \\<lbrakk>\\<lbrakk>\\<And>x k.\n                            \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                            \\<Longrightarrow> k < length zs;\n                 x \\<in> set (fst (mk_eqcl xs zs (Suc i) T))\\<rbrakk>\n                \\<Longrightarrow> x < length\n (snd (mk_eqcl xs zs (Suc i) T));\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (Some l # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        x \\<in> set (fst (mk_eqcl (Some l # xs) zs i T))\\<rbrakk>\n       \\<Longrightarrow> x < length (snd (mk_eqcl (Some l # xs) zs i T))", "thus ?case"], ["proof (prove)\nusing this:\n  x = l \\<or> x \\<in> set (fst (mk_eqcl xs zs (Suc i) T))\n\ngoal (1 subgoal):\n 1. x < length (snd (mk_eqcl (Some l # xs) zs i T))", "proof (elim disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. x = l \\<Longrightarrow> x < length (snd (mk_eqcl (Some l # xs) zs i T))\n 2. x \\<in> set (fst (mk_eqcl xs zs (Suc i) T)) \\<Longrightarrow>\n    x < length (snd (mk_eqcl (Some l # xs) zs i T))", "assume \"x = l\""], ["proof (state)\nthis:\n  x = l\n\ngoal (2 subgoals):\n 1. x = l \\<Longrightarrow> x < length (snd (mk_eqcl (Some l # xs) zs i T))\n 2. x \\<in> set (fst (mk_eqcl xs zs (Suc i) T)) \\<Longrightarrow>\n    x < length (snd (mk_eqcl (Some l # xs) zs i T))", "with 3"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x k.\n              \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n              \\<Longrightarrow> k < length zs;\n   x \\<in> set (fst (mk_eqcl xs zs (Suc i) T))\\<rbrakk>\n  \\<Longrightarrow> x < length (snd (mk_eqcl xs zs (Suc i) T))\n  \\<lbrakk>?x \\<in> set (Some l # xs); ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length zs\n  x \\<in> set (fst (mk_eqcl (Some l # xs) zs i T))\n  x = l", "have \"x < length zs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x k.\n              \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n              \\<Longrightarrow> k < length zs;\n   x \\<in> set (fst (mk_eqcl xs zs (Suc i) T))\\<rbrakk>\n  \\<Longrightarrow> x < length (snd (mk_eqcl xs zs (Suc i) T))\n  \\<lbrakk>?x \\<in> set (Some l # xs); ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length zs\n  x \\<in> set (fst (mk_eqcl (Some l # xs) zs i T))\n  x = l\n\ngoal (1 subgoal):\n 1. x < length zs", "by simp"], ["proof (state)\nthis:\n  x < length zs\n\ngoal (2 subgoals):\n 1. x = l \\<Longrightarrow> x < length (snd (mk_eqcl (Some l # xs) zs i T))\n 2. x \\<in> set (fst (mk_eqcl xs zs (Suc i) T)) \\<Longrightarrow>\n    x < length (snd (mk_eqcl (Some l # xs) zs i T))", "also"], ["proof (state)\nthis:\n  x < length zs\n\ngoal (2 subgoals):\n 1. x = l \\<Longrightarrow> x < length (snd (mk_eqcl (Some l # xs) zs i T))\n 2. x \\<in> set (fst (mk_eqcl xs zs (Suc i) T)) \\<Longrightarrow>\n    x < length (snd (mk_eqcl (Some l # xs) zs i T))", "from 3"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x k.\n              \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n              \\<Longrightarrow> k < length zs;\n   x \\<in> set (fst (mk_eqcl xs zs (Suc i) T))\\<rbrakk>\n  \\<Longrightarrow> x < length (snd (mk_eqcl xs zs (Suc i) T))\n  \\<lbrakk>?x \\<in> set (Some l # xs); ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length zs\n  x \\<in> set (fst (mk_eqcl (Some l # xs) zs i T))", "have \"\\<dots> \\<le> length (snd (mk_eqcl (Some l # xs) zs i T))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x k.\n              \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n              \\<Longrightarrow> k < length zs;\n   x \\<in> set (fst (mk_eqcl xs zs (Suc i) T))\\<rbrakk>\n  \\<Longrightarrow> x < length (snd (mk_eqcl xs zs (Suc i) T))\n  \\<lbrakk>?x \\<in> set (Some l # xs); ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length zs\n  x \\<in> set (fst (mk_eqcl (Some l # xs) zs i T))\n\ngoal (1 subgoal):\n 1. length zs \\<le> length (snd (mk_eqcl (Some l # xs) zs i T))", "by (simp only: mk_eqcl_len_snd)"], ["proof (state)\nthis:\n  length zs \\<le> length (snd (mk_eqcl (Some l # xs) zs i T))\n\ngoal (2 subgoals):\n 1. x = l \\<Longrightarrow> x < length (snd (mk_eqcl (Some l # xs) zs i T))\n 2. x \\<in> set (fst (mk_eqcl xs zs (Suc i) T)) \\<Longrightarrow>\n    x < length (snd (mk_eqcl (Some l # xs) zs i T))", "finally"], ["proof (chain)\npicking this:\n  x < length (snd (mk_eqcl (Some l # xs) zs i T))", "show ?thesis"], ["proof (prove)\nusing this:\n  x < length (snd (mk_eqcl (Some l # xs) zs i T))\n\ngoal (1 subgoal):\n 1. x < length (snd (mk_eqcl (Some l # xs) zs i T))", "by simp"], ["proof (state)\nthis:\n  x < length (snd (mk_eqcl (Some l # xs) zs i T))\n\ngoal (1 subgoal):\n 1. x \\<in> set (fst (mk_eqcl xs zs (Suc i) T)) \\<Longrightarrow>\n    x < length (snd (mk_eqcl (Some l # xs) zs i T))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> set (fst (mk_eqcl xs zs (Suc i) T)) \\<Longrightarrow>\n    x < length (snd (mk_eqcl (Some l # xs) zs i T))", "assume \"x \\<in> set (fst (mk_eqcl xs zs (Suc i) T))\""], ["proof (state)\nthis:\n  x \\<in> set (fst (mk_eqcl xs zs (Suc i) T))\n\ngoal (1 subgoal):\n 1. x \\<in> set (fst (mk_eqcl xs zs (Suc i) T)) \\<Longrightarrow>\n    x < length (snd (mk_eqcl (Some l # xs) zs i T))", "with 3"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x k.\n              \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n              \\<Longrightarrow> k < length zs;\n   x \\<in> set (fst (mk_eqcl xs zs (Suc i) T))\\<rbrakk>\n  \\<Longrightarrow> x < length (snd (mk_eqcl xs zs (Suc i) T))\n  \\<lbrakk>?x \\<in> set (Some l # xs); ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length zs\n  x \\<in> set (fst (mk_eqcl (Some l # xs) zs i T))\n  x \\<in> set (fst (mk_eqcl xs zs (Suc i) T))", "have \"x < length (snd (mk_eqcl xs zs (Suc i) T))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x k.\n              \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n              \\<Longrightarrow> k < length zs;\n   x \\<in> set (fst (mk_eqcl xs zs (Suc i) T))\\<rbrakk>\n  \\<Longrightarrow> x < length (snd (mk_eqcl xs zs (Suc i) T))\n  \\<lbrakk>?x \\<in> set (Some l # xs); ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length zs\n  x \\<in> set (fst (mk_eqcl (Some l # xs) zs i T))\n  x \\<in> set (fst (mk_eqcl xs zs (Suc i) T))\n\ngoal (1 subgoal):\n 1. x < length (snd (mk_eqcl xs zs (Suc i) T))", "by simp"], ["proof (state)\nthis:\n  x < length (snd (mk_eqcl xs zs (Suc i) T))\n\ngoal (1 subgoal):\n 1. x \\<in> set (fst (mk_eqcl xs zs (Suc i) T)) \\<Longrightarrow>\n    x < length (snd (mk_eqcl (Some l # xs) zs i T))", "thus ?thesis"], ["proof (prove)\nusing this:\n  x < length (snd (mk_eqcl xs zs (Suc i) T))\n\ngoal (1 subgoal):\n 1. x < length (snd (mk_eqcl (Some l # xs) zs i T))", "by (simp add: split_beta)"], ["proof (state)\nthis:\n  x < length (snd (mk_eqcl (Some l # xs) zs i T))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x < length (snd (mk_eqcl (Some l # xs) zs i T))\n\ngoal (1 subgoal):\n 1. \\<And>zs i T.\n       \\<lbrakk>\\<And>x k.\n                   \\<lbrakk>x \\<in> set []; x = Some k\\<rbrakk>\n                   \\<Longrightarrow> k < length zs;\n        x \\<in> set (fst (mk_eqcl [] zs i T))\\<rbrakk>\n       \\<Longrightarrow> x < length (snd (mk_eqcl [] zs i T))", "qed simp"], ["", "lemma mk_eqcl_fst_snd:\n  assumes \"\\<And>i. i < length zs \\<Longrightarrow> zs ! i < length xs + ii \\<and> (zs ! i \\<ge> ii \\<longrightarrow> xs ! (zs ! i - ii) = Some i)\"\n  and \"\\<And>j1 j2. \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk> \\<Longrightarrow> zs ! j1 < zs ! j2\"\n  and \"\\<And>z. z \\<in> set zs \\<Longrightarrow> z < ii\"\n  and \"i < length (snd (mk_eqcl xs zs ii T))\"\n  and \"length xs + ii \\<le> length T + 1\"\n  shows \"snd (mk_eqcl xs zs ii T) ! i < length (fst (mk_eqcl xs zs ii T)) + ii \\<and> (snd (mk_eqcl xs zs ii T) ! i \\<ge> ii \\<longrightarrow>  fst (mk_eqcl xs zs ii T) ! (snd (mk_eqcl xs zs ii T) ! i - ii) = i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (mk_eqcl xs zs ii T) ! i\n    < length (fst (mk_eqcl xs zs ii T)) + ii \\<and>\n    (ii \\<le> snd (mk_eqcl xs zs ii T) ! i \\<longrightarrow>\n     fst (mk_eqcl xs zs ii T) ! (snd (mk_eqcl xs zs ii T) ! i - ii) = i)", "using assms"], ["proof (prove)\nusing this:\n  ?i < length zs \\<Longrightarrow>\n  zs ! ?i < length xs + ii \\<and>\n  (ii \\<le> zs ! ?i \\<longrightarrow> xs ! (zs ! ?i - ii) = Some ?i)\n  \\<lbrakk>?j1.0 < ?j2.0; ?j2.0 < length zs\\<rbrakk>\n  \\<Longrightarrow> zs ! ?j1.0 < zs ! ?j2.0\n  ?z \\<in> set zs \\<Longrightarrow> ?z < ii\n  i < length (snd (mk_eqcl xs zs ii T))\n  length xs + ii \\<le> length T + 1\n\ngoal (1 subgoal):\n 1. snd (mk_eqcl xs zs ii T) ! i\n    < length (fst (mk_eqcl xs zs ii T)) + ii \\<and>\n    (ii \\<le> snd (mk_eqcl xs zs ii T) ! i \\<longrightarrow>\n     fst (mk_eqcl xs zs ii T) ! (snd (mk_eqcl xs zs ii T) ! i - ii) = i)", "proof (induct xs zs ii T arbitrary: i rule: mk_eqcl.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   ia < length zs \\<Longrightarrow>\n                   zs ! ia < length [] + i \\<and>\n                   (i \\<le> zs ! ia \\<longrightarrow>\n                    [] ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl [] zs i T));\n        length [] + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl [] zs i T) ! ia\n                         < length (fst (mk_eqcl [] zs i T)) + i \\<and>\n                         (i \\<le> snd (mk_eqcl [] zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl [] zs i T) !\n                          (snd (mk_eqcl [] zs i T) ! ia - i) =\n                          ia)\n 2. \\<And>xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length (zs @ [i]) \\<Longrightarrow>\n                               (zs @ [i]) ! ia\n                               < length\n                                  (mk_eqcl' xs i (Suc i) (length zs) T) +\n                                 Suc i \\<and>\n                               (Suc i\n                                \\<le> (zs @ [i]) ! ia \\<longrightarrow>\n                                mk_eqcl' xs i (Suc i) (length zs) T !\n                                ((zs @ [i]) ! ia - Suc i) =\n                                Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk>\n                       \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2;\n                    \\<And>z.\n                       z \\<in> set (zs @ [i]) \\<Longrightarrow> z < Suc i;\n                    ia < length\n                          (snd (mk_eqcl\n                                 (mk_eqcl' xs i (Suc i) (length zs) T)\n                                 (zs @ [i]) (Suc i) T));\n                    length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i\n                    \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd\n(mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                     ia\n                                     < length\n  (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n         T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n            T) !\n      ia \\<longrightarrow>\nfst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n(snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n ia -\n Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (None # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (None # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (None # xs) zs i T));\n        length (None # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (None # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (None # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (None # xs) zs i T) !\n                          (snd (mk_eqcl (None # xs) zs i T) ! ia - i) =\n                          ia)\n 3. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "case (1 zs ii T i)"], ["proof (state)\nthis:\n  ?i < length zs \\<Longrightarrow>\n  zs ! ?i < length [] + ii \\<and>\n  (ii \\<le> zs ! ?i \\<longrightarrow> [] ! (zs ! ?i - ii) = Some ?i)\n  \\<lbrakk>?j1.0 < ?j2.0; ?j2.0 < length zs\\<rbrakk>\n  \\<Longrightarrow> zs ! ?j1.0 < zs ! ?j2.0\n  ?z \\<in> set zs \\<Longrightarrow> ?z < ii\n  i < length (snd (mk_eqcl [] zs ii T))\n  length [] + ii \\<le> length T + 1\n\ngoal (3 subgoals):\n 1. \\<And>zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   ia < length zs \\<Longrightarrow>\n                   zs ! ia < length [] + i \\<and>\n                   (i \\<le> zs ! ia \\<longrightarrow>\n                    [] ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl [] zs i T));\n        length [] + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl [] zs i T) ! ia\n                         < length (fst (mk_eqcl [] zs i T)) + i \\<and>\n                         (i \\<le> snd (mk_eqcl [] zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl [] zs i T) !\n                          (snd (mk_eqcl [] zs i T) ! ia - i) =\n                          ia)\n 2. \\<And>xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length (zs @ [i]) \\<Longrightarrow>\n                               (zs @ [i]) ! ia\n                               < length\n                                  (mk_eqcl' xs i (Suc i) (length zs) T) +\n                                 Suc i \\<and>\n                               (Suc i\n                                \\<le> (zs @ [i]) ! ia \\<longrightarrow>\n                                mk_eqcl' xs i (Suc i) (length zs) T !\n                                ((zs @ [i]) ! ia - Suc i) =\n                                Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk>\n                       \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2;\n                    \\<And>z.\n                       z \\<in> set (zs @ [i]) \\<Longrightarrow> z < Suc i;\n                    ia < length\n                          (snd (mk_eqcl\n                                 (mk_eqcl' xs i (Suc i) (length zs) T)\n                                 (zs @ [i]) (Suc i) T));\n                    length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i\n                    \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd\n(mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                     ia\n                                     < length\n  (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n         T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n            T) !\n      ia \\<longrightarrow>\nfst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n(snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n ia -\n Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (None # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (None # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (None # xs) zs i T));\n        length (None # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (None # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (None # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (None # xs) zs i T) !\n                          (snd (mk_eqcl (None # xs) zs i T) ! ia - i) =\n                          ia)\n 3. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "from 1(1)[of i] 1(4,5)"], ["proof (chain)\npicking this:\n  i < length zs \\<Longrightarrow>\n  zs ! i < length [] + ii \\<and>\n  (ii \\<le> zs ! i \\<longrightarrow> [] ! (zs ! i - ii) = Some i)\n  i < length (snd (mk_eqcl [] zs ii T))\n  length [] + ii \\<le> length T + 1", "show ?case"], ["proof (prove)\nusing this:\n  i < length zs \\<Longrightarrow>\n  zs ! i < length [] + ii \\<and>\n  (ii \\<le> zs ! i \\<longrightarrow> [] ! (zs ! i - ii) = Some i)\n  i < length (snd (mk_eqcl [] zs ii T))\n  length [] + ii \\<le> length T + 1\n\ngoal (1 subgoal):\n 1. snd (mk_eqcl [] zs ii T) ! i\n    < length (fst (mk_eqcl [] zs ii T)) + ii \\<and>\n    (ii \\<le> snd (mk_eqcl [] zs ii T) ! i \\<longrightarrow>\n     fst (mk_eqcl [] zs ii T) ! (snd (mk_eqcl [] zs ii T) ! i - ii) = i)", "by simp"], ["proof (state)\nthis:\n  snd (mk_eqcl [] zs ii T) ! i\n  < length (fst (mk_eqcl [] zs ii T)) + ii \\<and>\n  (ii \\<le> snd (mk_eqcl [] zs ii T) ! i \\<longrightarrow>\n   fst (mk_eqcl [] zs ii T) ! (snd (mk_eqcl [] zs ii T) ! i - ii) = i)\n\ngoal (2 subgoals):\n 1. \\<And>xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length (zs @ [i]) \\<Longrightarrow>\n                               (zs @ [i]) ! ia\n                               < length\n                                  (mk_eqcl' xs i (Suc i) (length zs) T) +\n                                 Suc i \\<and>\n                               (Suc i\n                                \\<le> (zs @ [i]) ! ia \\<longrightarrow>\n                                mk_eqcl' xs i (Suc i) (length zs) T !\n                                ((zs @ [i]) ! ia - Suc i) =\n                                Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk>\n                       \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2;\n                    \\<And>z.\n                       z \\<in> set (zs @ [i]) \\<Longrightarrow> z < Suc i;\n                    ia < length\n                          (snd (mk_eqcl\n                                 (mk_eqcl' xs i (Suc i) (length zs) T)\n                                 (zs @ [i]) (Suc i) T));\n                    length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i\n                    \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd\n(mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                     ia\n                                     < length\n  (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n         T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n            T) !\n      ia \\<longrightarrow>\nfst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n(snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n ia -\n Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (None # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (None # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (None # xs) zs i T));\n        length (None # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (None # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (None # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (None # xs) zs i T) !\n                          (snd (mk_eqcl (None # xs) zs i T) ! ia - i) =\n                          ia)\n 2. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length (zs @ [i]) \\<Longrightarrow>\n                               (zs @ [i]) ! ia\n                               < length\n                                  (mk_eqcl' xs i (Suc i) (length zs) T) +\n                                 Suc i \\<and>\n                               (Suc i\n                                \\<le> (zs @ [i]) ! ia \\<longrightarrow>\n                                mk_eqcl' xs i (Suc i) (length zs) T !\n                                ((zs @ [i]) ! ia - Suc i) =\n                                Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk>\n                       \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2;\n                    \\<And>z.\n                       z \\<in> set (zs @ [i]) \\<Longrightarrow> z < Suc i;\n                    ia < length\n                          (snd (mk_eqcl\n                                 (mk_eqcl' xs i (Suc i) (length zs) T)\n                                 (zs @ [i]) (Suc i) T));\n                    length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i\n                    \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd\n(mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                     ia\n                                     < length\n  (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n         T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n            T) !\n      ia \\<longrightarrow>\nfst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n(snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n ia -\n Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (None # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (None # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (None # xs) zs i T));\n        length (None # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (None # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (None # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (None # xs) zs i T) !\n                          (snd (mk_eqcl (None # xs) zs i T) ! ia - i) =\n                          ia)\n 2. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "case (2 xs zs i T j)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>i.\n              i < length (zs @ [i]) \\<Longrightarrow>\n              (zs @ [i]) ! i\n              < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n              (Suc i \\<le> (zs @ [i]) ! i \\<longrightarrow>\n               mk_eqcl' xs i (Suc i) (length zs) T !\n               ((zs @ [i]) ! i - Suc i) =\n               Some i);\n   \\<And>j1 j2.\n      \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk>\n      \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2;\n   \\<And>z. z \\<in> set (zs @ [i]) \\<Longrightarrow> z < Suc i;\n   ?i < length\n         (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i])\n                (Suc i) T));\n   length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i\n   \\<le> length T + 1\\<rbrakk>\n  \\<Longrightarrow> snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                          (zs @ [i]) (Suc i) T) !\n                    ?i\n                    < length\n                       (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                              (zs @ [i]) (Suc i) T)) +\n                      Suc i \\<and>\n                    (Suc i\n                     \\<le> snd (mk_eqcl\n                                 (mk_eqcl' xs i (Suc i) (length zs) T)\n                                 (zs @ [i]) (Suc i) T) !\n                           ?i \\<longrightarrow>\n                     fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                           (zs @ [i]) (Suc i) T) !\n                     (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                            (zs @ [i]) (Suc i) T) !\n                      ?i -\n                      Suc i) =\n                     ?i)\n  ?i < length zs \\<Longrightarrow>\n  zs ! ?i < length (None # xs) + i \\<and>\n  (i \\<le> zs ! ?i \\<longrightarrow> (None # xs) ! (zs ! ?i - i) = Some ?i)\n  \\<lbrakk>?j1.0 < ?j2.0; ?j2.0 < length zs\\<rbrakk>\n  \\<Longrightarrow> zs ! ?j1.0 < zs ! ?j2.0\n  ?z \\<in> set zs \\<Longrightarrow> ?z < i\n  j < length (snd (mk_eqcl (None # xs) zs i T))\n  length (None # xs) + i \\<le> length T + 1\n\ngoal (2 subgoals):\n 1. \\<And>xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length (zs @ [i]) \\<Longrightarrow>\n                               (zs @ [i]) ! ia\n                               < length\n                                  (mk_eqcl' xs i (Suc i) (length zs) T) +\n                                 Suc i \\<and>\n                               (Suc i\n                                \\<le> (zs @ [i]) ! ia \\<longrightarrow>\n                                mk_eqcl' xs i (Suc i) (length zs) T !\n                                ((zs @ [i]) ! ia - Suc i) =\n                                Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk>\n                       \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2;\n                    \\<And>z.\n                       z \\<in> set (zs @ [i]) \\<Longrightarrow> z < Suc i;\n                    ia < length\n                          (snd (mk_eqcl\n                                 (mk_eqcl' xs i (Suc i) (length zs) T)\n                                 (zs @ [i]) (Suc i) T));\n                    length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i\n                    \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd\n(mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                     ia\n                                     < length\n  (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n         T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n            T) !\n      ia \\<longrightarrow>\nfst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n(snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n ia -\n Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (None # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (None # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (None # xs) zs i T));\n        length (None # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (None # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (None # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (None # xs) zs i T) !\n                          (snd (mk_eqcl (None # xs) zs i T) ! ia - i) =\n                          ia)\n 2. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "have \"\\<And>i'. i' < length (zs @ [i]) \\<Longrightarrow> (zs @ [i]) ! i' < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n    (Suc i \\<le> (zs @ [i]) ! i' \\<longrightarrow> mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) = Some i')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i'.\n       i' < length (zs @ [i]) \\<Longrightarrow>\n       (zs @ [i]) ! i'\n       < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n       (Suc i \\<le> (zs @ [i]) ! i' \\<longrightarrow>\n        mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) =\n        Some i')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i'.\n       i' < length (zs @ [i]) \\<Longrightarrow>\n       (zs @ [i]) ! i'\n       < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n       (Suc i \\<le> (zs @ [i]) ! i' \\<longrightarrow>\n        mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) =\n        Some i')", "fix i'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i'.\n       i' < length (zs @ [i]) \\<Longrightarrow>\n       (zs @ [i]) ! i'\n       < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n       (Suc i \\<le> (zs @ [i]) ! i' \\<longrightarrow>\n        mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) =\n        Some i')", "assume \"i' < length (zs @ [i])\""], ["proof (state)\nthis:\n  i' < length (zs @ [i])\n\ngoal (1 subgoal):\n 1. \\<And>i'.\n       i' < length (zs @ [i]) \\<Longrightarrow>\n       (zs @ [i]) ! i'\n       < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n       (Suc i \\<le> (zs @ [i]) ! i' \\<longrightarrow>\n        mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) =\n        Some i')", "hence \"i' < length zs \\<or> i' = length zs\""], ["proof (prove)\nusing this:\n  i' < length (zs @ [i])\n\ngoal (1 subgoal):\n 1. i' < length zs \\<or> i' = length zs", "by auto"], ["proof (state)\nthis:\n  i' < length zs \\<or> i' = length zs\n\ngoal (1 subgoal):\n 1. \\<And>i'.\n       i' < length (zs @ [i]) \\<Longrightarrow>\n       (zs @ [i]) ! i'\n       < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n       (Suc i \\<le> (zs @ [i]) ! i' \\<longrightarrow>\n        mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) =\n        Some i')", "thus \"(zs @ [i]) ! i' < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and> (Suc i \\<le> (zs @ [i]) ! i' \\<longrightarrow> mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) = Some i')\""], ["proof (prove)\nusing this:\n  i' < length zs \\<or> i' = length zs\n\ngoal (1 subgoal):\n 1. (zs @ [i]) ! i'\n    < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n    (Suc i \\<le> (zs @ [i]) ! i' \\<longrightarrow>\n     mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) =\n     Some i')", "proof (elim disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. i' < length zs \\<Longrightarrow>\n    (zs @ [i]) ! i'\n    < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n    (Suc i \\<le> (zs @ [i]) ! i' \\<longrightarrow>\n     mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) =\n     Some i')\n 2. i' = length zs \\<Longrightarrow>\n    (zs @ [i]) ! i'\n    < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n    (Suc i \\<le> (zs @ [i]) ! i' \\<longrightarrow>\n     mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) =\n     Some i')", "assume H: \"i' < length zs\""], ["proof (state)\nthis:\n  i' < length zs\n\ngoal (2 subgoals):\n 1. i' < length zs \\<Longrightarrow>\n    (zs @ [i]) ! i'\n    < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n    (Suc i \\<le> (zs @ [i]) ! i' \\<longrightarrow>\n     mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) =\n     Some i')\n 2. i' = length zs \\<Longrightarrow>\n    (zs @ [i]) ! i'\n    < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n    (Suc i \\<le> (zs @ [i]) ! i' \\<longrightarrow>\n     mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) =\n     Some i')", "with 2(2)"], ["proof (chain)\npicking this:\n  ?i < length zs \\<Longrightarrow>\n  zs ! ?i < length (None # xs) + i \\<and>\n  (i \\<le> zs ! ?i \\<longrightarrow> (None # xs) ! (zs ! ?i - i) = Some ?i)\n  i' < length zs", "have I: \"zs ! i' < length (None # xs) + i \\<and> (i \\<le> zs ! i' \\<longrightarrow> (None # xs) ! (zs ! i' - i) = Some i')\""], ["proof (prove)\nusing this:\n  ?i < length zs \\<Longrightarrow>\n  zs ! ?i < length (None # xs) + i \\<and>\n  (i \\<le> zs ! ?i \\<longrightarrow> (None # xs) ! (zs ! ?i - i) = Some ?i)\n  i' < length zs\n\ngoal (1 subgoal):\n 1. zs ! i' < length (None # xs) + i \\<and>\n    (i \\<le> zs ! i' \\<longrightarrow>\n     (None # xs) ! (zs ! i' - i) = Some i')", "by simp"], ["proof (state)\nthis:\n  zs ! i' < length (None # xs) + i \\<and>\n  (i \\<le> zs ! i' \\<longrightarrow> (None # xs) ! (zs ! i' - i) = Some i')\n\ngoal (2 subgoals):\n 1. i' < length zs \\<Longrightarrow>\n    (zs @ [i]) ! i'\n    < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n    (Suc i \\<le> (zs @ [i]) ! i' \\<longrightarrow>\n     mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) =\n     Some i')\n 2. i' = length zs \\<Longrightarrow>\n    (zs @ [i]) ! i'\n    < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n    (Suc i \\<le> (zs @ [i]) ! i' \\<longrightarrow>\n     mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) =\n     Some i')", "with H"], ["proof (chain)\npicking this:\n  i' < length zs\n  zs ! i' < length (None # xs) + i \\<and>\n  (i \\<le> zs ! i' \\<longrightarrow> (None # xs) ! (zs ! i' - i) = Some i')", "have G1: \"(zs @ [i]) ! i' < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i\""], ["proof (prove)\nusing this:\n  i' < length zs\n  zs ! i' < length (None # xs) + i \\<and>\n  (i \\<le> zs ! i' \\<longrightarrow> (None # xs) ! (zs ! i' - i) = Some i')\n\ngoal (1 subgoal):\n 1. (zs @ [i]) ! i' < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i", "by (auto simp: mk_eqcl'_len nth_append)"], ["proof (state)\nthis:\n  (zs @ [i]) ! i' < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i\n\ngoal (2 subgoals):\n 1. i' < length zs \\<Longrightarrow>\n    (zs @ [i]) ! i'\n    < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n    (Suc i \\<le> (zs @ [i]) ! i' \\<longrightarrow>\n     mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) =\n     Some i')\n 2. i' = length zs \\<Longrightarrow>\n    (zs @ [i]) ! i'\n    < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n    (Suc i \\<le> (zs @ [i]) ! i' \\<longrightarrow>\n     mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) =\n     Some i')", "{"], ["proof (state)\nthis:\n  (zs @ [i]) ! i' < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i\n\ngoal (2 subgoals):\n 1. i' < length zs \\<Longrightarrow>\n    (zs @ [i]) ! i'\n    < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n    (Suc i \\<le> (zs @ [i]) ! i' \\<longrightarrow>\n     mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) =\n     Some i')\n 2. i' = length zs \\<Longrightarrow>\n    (zs @ [i]) ! i'\n    < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n    (Suc i \\<le> (zs @ [i]) ! i' \\<longrightarrow>\n     mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) =\n     Some i')", "assume H': \"Suc i \\<le> (zs @ [i]) ! i'\""], ["proof (state)\nthis:\n  Suc i \\<le> (zs @ [i]) ! i'\n\ngoal (2 subgoals):\n 1. i' < length zs \\<Longrightarrow>\n    (zs @ [i]) ! i'\n    < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n    (Suc i \\<le> (zs @ [i]) ! i' \\<longrightarrow>\n     mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) =\n     Some i')\n 2. i' = length zs \\<Longrightarrow>\n    (zs @ [i]) ! i'\n    < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n    (Suc i \\<le> (zs @ [i]) ! i' \\<longrightarrow>\n     mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) =\n     Some i')", "then"], ["proof (chain)\npicking this:\n  Suc i \\<le> (zs @ [i]) ! i'", "obtain k where K: \"(zs @ [i]) ! i' - i = Suc k\""], ["proof (prove)\nusing this:\n  Suc i \\<le> (zs @ [i]) ! i'\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        (zs @ [i]) ! i' - i = Suc k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"(zs @ [i]) ! i' - i\") simp+"], ["proof (state)\nthis:\n  (zs @ [i]) ! i' - i = Suc k\n\ngoal (2 subgoals):\n 1. i' < length zs \\<Longrightarrow>\n    (zs @ [i]) ! i'\n    < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n    (Suc i \\<le> (zs @ [i]) ! i' \\<longrightarrow>\n     mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) =\n     Some i')\n 2. i' = length zs \\<Longrightarrow>\n    (zs @ [i]) ! i'\n    < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n    (Suc i \\<le> (zs @ [i]) ! i' \\<longrightarrow>\n     mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) =\n     Some i')", "hence K': \"k = (zs @ [i]) ! i' - Suc i\""], ["proof (prove)\nusing this:\n  (zs @ [i]) ! i' - i = Suc k\n\ngoal (1 subgoal):\n 1. k = (zs @ [i]) ! i' - Suc i", "by simp"], ["proof (state)\nthis:\n  k = (zs @ [i]) ! i' - Suc i\n\ngoal (2 subgoals):\n 1. i' < length zs \\<Longrightarrow>\n    (zs @ [i]) ! i'\n    < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n    (Suc i \\<le> (zs @ [i]) ! i' \\<longrightarrow>\n     mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) =\n     Some i')\n 2. i' = length zs \\<Longrightarrow>\n    (zs @ [i]) ! i'\n    < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n    (Suc i \\<le> (zs @ [i]) ! i' \\<longrightarrow>\n     mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) =\n     Some i')", "from K H' H I"], ["proof (chain)\npicking this:\n  (zs @ [i]) ! i' - i = Suc k\n  Suc i \\<le> (zs @ [i]) ! i'\n  i' < length zs\n  zs ! i' < length (None # xs) + i \\<and>\n  (i \\<le> zs ! i' \\<longrightarrow> (None # xs) ! (zs ! i' - i) = Some i')", "have \"xs ! k = Some i'\""], ["proof (prove)\nusing this:\n  (zs @ [i]) ! i' - i = Suc k\n  Suc i \\<le> (zs @ [i]) ! i'\n  i' < length zs\n  zs ! i' < length (None # xs) + i \\<and>\n  (i \\<le> zs ! i' \\<longrightarrow> (None # xs) ! (zs ! i' - i) = Some i')\n\ngoal (1 subgoal):\n 1. xs ! k = Some i'", "by (simp add: nth_append)"], ["proof (state)\nthis:\n  xs ! k = Some i'\n\ngoal (2 subgoals):\n 1. i' < length zs \\<Longrightarrow>\n    (zs @ [i]) ! i'\n    < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n    (Suc i \\<le> (zs @ [i]) ! i' \\<longrightarrow>\n     mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) =\n     Some i')\n 2. i' = length zs \\<Longrightarrow>\n    (zs @ [i]) ! i'\n    < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n    (Suc i \\<le> (zs @ [i]) ! i' \\<longrightarrow>\n     mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) =\n     Some i')", "with K I H"], ["proof (chain)\npicking this:\n  (zs @ [i]) ! i' - i = Suc k\n  zs ! i' < length (None # xs) + i \\<and>\n  (i \\<le> zs ! i' \\<longrightarrow> (None # xs) ! (zs ! i' - i) = Some i')\n  i' < length zs\n  xs ! k = Some i'", "have \"mk_eqcl' xs i (Suc i) (length zs) T ! k = Some i'\""], ["proof (prove)\nusing this:\n  (zs @ [i]) ! i' - i = Suc k\n  zs ! i' < length (None # xs) + i \\<and>\n  (i \\<le> zs ! i' \\<longrightarrow> (None # xs) ! (zs ! i' - i) = Some i')\n  i' < length zs\n  xs ! k = Some i'\n\ngoal (1 subgoal):\n 1. mk_eqcl' xs i (Suc i) (length zs) T ! k = Some i'", "by (auto simp add: mk_eqcl'_Some nth_append)"], ["proof (state)\nthis:\n  mk_eqcl' xs i (Suc i) (length zs) T ! k = Some i'\n\ngoal (2 subgoals):\n 1. i' < length zs \\<Longrightarrow>\n    (zs @ [i]) ! i'\n    < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n    (Suc i \\<le> (zs @ [i]) ! i' \\<longrightarrow>\n     mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) =\n     Some i')\n 2. i' = length zs \\<Longrightarrow>\n    (zs @ [i]) ! i'\n    < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n    (Suc i \\<le> (zs @ [i]) ! i' \\<longrightarrow>\n     mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) =\n     Some i')", "with K'"], ["proof (chain)\npicking this:\n  k = (zs @ [i]) ! i' - Suc i\n  mk_eqcl' xs i (Suc i) (length zs) T ! k = Some i'", "have \"mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) = Some i'\""], ["proof (prove)\nusing this:\n  k = (zs @ [i]) ! i' - Suc i\n  mk_eqcl' xs i (Suc i) (length zs) T ! k = Some i'\n\ngoal (1 subgoal):\n 1. mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) =\n    Some i'", "by simp"], ["proof (state)\nthis:\n  mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) = Some i'\n\ngoal (2 subgoals):\n 1. i' < length zs \\<Longrightarrow>\n    (zs @ [i]) ! i'\n    < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n    (Suc i \\<le> (zs @ [i]) ! i' \\<longrightarrow>\n     mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) =\n     Some i')\n 2. i' = length zs \\<Longrightarrow>\n    (zs @ [i]) ! i'\n    < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n    (Suc i \\<le> (zs @ [i]) ! i' \\<longrightarrow>\n     mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) =\n     Some i')", "}"], ["proof (state)\nthis:\n  Suc i \\<le> (zs @ [i]) ! i' \\<Longrightarrow>\n  mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) = Some i'\n\ngoal (2 subgoals):\n 1. i' < length zs \\<Longrightarrow>\n    (zs @ [i]) ! i'\n    < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n    (Suc i \\<le> (zs @ [i]) ! i' \\<longrightarrow>\n     mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) =\n     Some i')\n 2. i' = length zs \\<Longrightarrow>\n    (zs @ [i]) ! i'\n    < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n    (Suc i \\<le> (zs @ [i]) ! i' \\<longrightarrow>\n     mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) =\n     Some i')", "with G1"], ["proof (chain)\npicking this:\n  (zs @ [i]) ! i' < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i\n  Suc i \\<le> (zs @ [i]) ! i' \\<Longrightarrow>\n  mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) = Some i'", "show ?thesis"], ["proof (prove)\nusing this:\n  (zs @ [i]) ! i' < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i\n  Suc i \\<le> (zs @ [i]) ! i' \\<Longrightarrow>\n  mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) = Some i'\n\ngoal (1 subgoal):\n 1. (zs @ [i]) ! i'\n    < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n    (Suc i \\<le> (zs @ [i]) ! i' \\<longrightarrow>\n     mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) =\n     Some i')", "by simp"], ["proof (state)\nthis:\n  (zs @ [i]) ! i'\n  < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n  (Suc i \\<le> (zs @ [i]) ! i' \\<longrightarrow>\n   mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) =\n   Some i')\n\ngoal (1 subgoal):\n 1. i' = length zs \\<Longrightarrow>\n    (zs @ [i]) ! i'\n    < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n    (Suc i \\<le> (zs @ [i]) ! i' \\<longrightarrow>\n     mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) =\n     Some i')", "qed simp"], ["proof (state)\nthis:\n  (zs @ [i]) ! i'\n  < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n  (Suc i \\<le> (zs @ [i]) ! i' \\<longrightarrow>\n   mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! i' - Suc i) =\n   Some i')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i' < length (zs @ [i]) \\<Longrightarrow>\n  (zs @ [i]) ! ?i'\n  < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n  (Suc i \\<le> (zs @ [i]) ! ?i' \\<longrightarrow>\n   mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! ?i' - Suc i) =\n   Some ?i')\n\ngoal (2 subgoals):\n 1. \\<And>xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length (zs @ [i]) \\<Longrightarrow>\n                               (zs @ [i]) ! ia\n                               < length\n                                  (mk_eqcl' xs i (Suc i) (length zs) T) +\n                                 Suc i \\<and>\n                               (Suc i\n                                \\<le> (zs @ [i]) ! ia \\<longrightarrow>\n                                mk_eqcl' xs i (Suc i) (length zs) T !\n                                ((zs @ [i]) ! ia - Suc i) =\n                                Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk>\n                       \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2;\n                    \\<And>z.\n                       z \\<in> set (zs @ [i]) \\<Longrightarrow> z < Suc i;\n                    ia < length\n                          (snd (mk_eqcl\n                                 (mk_eqcl' xs i (Suc i) (length zs) T)\n                                 (zs @ [i]) (Suc i) T));\n                    length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i\n                    \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd\n(mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                     ia\n                                     < length\n  (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n         T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n            T) !\n      ia \\<longrightarrow>\nfst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n(snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n ia -\n Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (None # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (None # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (None # xs) zs i T));\n        length (None # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (None # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (None # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (None # xs) zs i T) !\n                          (snd (mk_eqcl (None # xs) zs i T) ! ia - i) =\n                          ia)\n 2. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "moreover"], ["proof (state)\nthis:\n  ?i' < length (zs @ [i]) \\<Longrightarrow>\n  (zs @ [i]) ! ?i'\n  < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n  (Suc i \\<le> (zs @ [i]) ! ?i' \\<longrightarrow>\n   mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! ?i' - Suc i) =\n   Some ?i')\n\ngoal (2 subgoals):\n 1. \\<And>xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length (zs @ [i]) \\<Longrightarrow>\n                               (zs @ [i]) ! ia\n                               < length\n                                  (mk_eqcl' xs i (Suc i) (length zs) T) +\n                                 Suc i \\<and>\n                               (Suc i\n                                \\<le> (zs @ [i]) ! ia \\<longrightarrow>\n                                mk_eqcl' xs i (Suc i) (length zs) T !\n                                ((zs @ [i]) ! ia - Suc i) =\n                                Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk>\n                       \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2;\n                    \\<And>z.\n                       z \\<in> set (zs @ [i]) \\<Longrightarrow> z < Suc i;\n                    ia < length\n                          (snd (mk_eqcl\n                                 (mk_eqcl' xs i (Suc i) (length zs) T)\n                                 (zs @ [i]) (Suc i) T));\n                    length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i\n                    \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd\n(mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                     ia\n                                     < length\n  (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n         T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n            T) !\n      ia \\<longrightarrow>\nfst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n(snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n ia -\n Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (None # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (None # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (None # xs) zs i T));\n        length (None # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (None # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (None # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (None # xs) zs i T) !\n                          (snd (mk_eqcl (None # xs) zs i T) ! ia - i) =\n                          ia)\n 2. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "have \"\\<And>j1 j2. \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk> \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j1 j2.\n       \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk>\n       \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j1 j2.\n       \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk>\n       \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2", "fix j1 j2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j1 j2.\n       \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk>\n       \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2", "assume H: \"j1 < j2\" \"j2 < length (zs @ [i])\""], ["proof (state)\nthis:\n  j1 < j2\n  j2 < length (zs @ [i])\n\ngoal (1 subgoal):\n 1. \\<And>j1 j2.\n       \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk>\n       \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2", "hence \"j2 < length zs \\<or> j2 = length zs\""], ["proof (prove)\nusing this:\n  j1 < j2\n  j2 < length (zs @ [i])\n\ngoal (1 subgoal):\n 1. j2 < length zs \\<or> j2 = length zs", "by auto"], ["proof (state)\nthis:\n  j2 < length zs \\<or> j2 = length zs\n\ngoal (1 subgoal):\n 1. \\<And>j1 j2.\n       \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk>\n       \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2", "from this H 2(3)[of j1 j2] 2(4)[of \"zs ! j1\"]"], ["proof (chain)\npicking this:\n  j2 < length zs \\<or> j2 = length zs\n  j1 < j2\n  j2 < length (zs @ [i])\n  \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n  \\<Longrightarrow> zs ! j1 < zs ! j2\n  zs ! j1 \\<in> set zs \\<Longrightarrow> zs ! j1 < i", "show \"(zs @ [i]) ! j1 < (zs @ [i]) ! j2\""], ["proof (prove)\nusing this:\n  j2 < length zs \\<or> j2 = length zs\n  j1 < j2\n  j2 < length (zs @ [i])\n  \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n  \\<Longrightarrow> zs ! j1 < zs ! j2\n  zs ! j1 \\<in> set zs \\<Longrightarrow> zs ! j1 < i\n\ngoal (1 subgoal):\n 1. (zs @ [i]) ! j1 < (zs @ [i]) ! j2", "by (elim disjE) (simp add: nth_append)+"], ["proof (state)\nthis:\n  (zs @ [i]) ! j1 < (zs @ [i]) ! j2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?j1.0 < ?j2.0; ?j2.0 < length (zs @ [i])\\<rbrakk>\n  \\<Longrightarrow> (zs @ [i]) ! ?j1.0 < (zs @ [i]) ! ?j2.0\n\ngoal (2 subgoals):\n 1. \\<And>xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length (zs @ [i]) \\<Longrightarrow>\n                               (zs @ [i]) ! ia\n                               < length\n                                  (mk_eqcl' xs i (Suc i) (length zs) T) +\n                                 Suc i \\<and>\n                               (Suc i\n                                \\<le> (zs @ [i]) ! ia \\<longrightarrow>\n                                mk_eqcl' xs i (Suc i) (length zs) T !\n                                ((zs @ [i]) ! ia - Suc i) =\n                                Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk>\n                       \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2;\n                    \\<And>z.\n                       z \\<in> set (zs @ [i]) \\<Longrightarrow> z < Suc i;\n                    ia < length\n                          (snd (mk_eqcl\n                                 (mk_eqcl' xs i (Suc i) (length zs) T)\n                                 (zs @ [i]) (Suc i) T));\n                    length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i\n                    \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd\n(mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                     ia\n                                     < length\n  (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n         T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n            T) !\n      ia \\<longrightarrow>\nfst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n(snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n ia -\n Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (None # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (None # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (None # xs) zs i T));\n        length (None # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (None # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (None # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (None # xs) zs i T) !\n                          (snd (mk_eqcl (None # xs) zs i T) ! ia - i) =\n                          ia)\n 2. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?j1.0 < ?j2.0; ?j2.0 < length (zs @ [i])\\<rbrakk>\n  \\<Longrightarrow> (zs @ [i]) ! ?j1.0 < (zs @ [i]) ! ?j2.0\n\ngoal (2 subgoals):\n 1. \\<And>xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length (zs @ [i]) \\<Longrightarrow>\n                               (zs @ [i]) ! ia\n                               < length\n                                  (mk_eqcl' xs i (Suc i) (length zs) T) +\n                                 Suc i \\<and>\n                               (Suc i\n                                \\<le> (zs @ [i]) ! ia \\<longrightarrow>\n                                mk_eqcl' xs i (Suc i) (length zs) T !\n                                ((zs @ [i]) ! ia - Suc i) =\n                                Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk>\n                       \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2;\n                    \\<And>z.\n                       z \\<in> set (zs @ [i]) \\<Longrightarrow> z < Suc i;\n                    ia < length\n                          (snd (mk_eqcl\n                                 (mk_eqcl' xs i (Suc i) (length zs) T)\n                                 (zs @ [i]) (Suc i) T));\n                    length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i\n                    \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd\n(mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                     ia\n                                     < length\n  (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n         T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n            T) !\n      ia \\<longrightarrow>\nfst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n(snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n ia -\n Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (None # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (None # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (None # xs) zs i T));\n        length (None # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (None # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (None # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (None # xs) zs i T) !\n                          (snd (mk_eqcl (None # xs) zs i T) ! ia - i) =\n                          ia)\n 2. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "have \"\\<And>z. z \\<in> set (zs @ [i]) \\<Longrightarrow> z < Suc i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z. z \\<in> set (zs @ [i]) \\<Longrightarrow> z < Suc i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z. z \\<in> set (zs @ [i]) \\<Longrightarrow> z < Suc i", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z. z \\<in> set (zs @ [i]) \\<Longrightarrow> z < Suc i", "assume \"z \\<in> set (zs @ [i])\""], ["proof (state)\nthis:\n  z \\<in> set (zs @ [i])\n\ngoal (1 subgoal):\n 1. \\<And>z. z \\<in> set (zs @ [i]) \\<Longrightarrow> z < Suc i", "hence \"z \\<in> set zs \\<or> z = i\""], ["proof (prove)\nusing this:\n  z \\<in> set (zs @ [i])\n\ngoal (1 subgoal):\n 1. z \\<in> set zs \\<or> z = i", "by auto"], ["proof (state)\nthis:\n  z \\<in> set zs \\<or> z = i\n\ngoal (1 subgoal):\n 1. \\<And>z. z \\<in> set (zs @ [i]) \\<Longrightarrow> z < Suc i", "with 2(4)[of z]"], ["proof (chain)\npicking this:\n  z \\<in> set zs \\<Longrightarrow> z < i\n  z \\<in> set zs \\<or> z = i", "show \"z < Suc i\""], ["proof (prove)\nusing this:\n  z \\<in> set zs \\<Longrightarrow> z < i\n  z \\<in> set zs \\<or> z = i\n\ngoal (1 subgoal):\n 1. z < Suc i", "by auto"], ["proof (state)\nthis:\n  z < Suc i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?z \\<in> set (zs @ [i]) \\<Longrightarrow> ?z < Suc i\n\ngoal (2 subgoals):\n 1. \\<And>xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length (zs @ [i]) \\<Longrightarrow>\n                               (zs @ [i]) ! ia\n                               < length\n                                  (mk_eqcl' xs i (Suc i) (length zs) T) +\n                                 Suc i \\<and>\n                               (Suc i\n                                \\<le> (zs @ [i]) ! ia \\<longrightarrow>\n                                mk_eqcl' xs i (Suc i) (length zs) T !\n                                ((zs @ [i]) ! ia - Suc i) =\n                                Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk>\n                       \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2;\n                    \\<And>z.\n                       z \\<in> set (zs @ [i]) \\<Longrightarrow> z < Suc i;\n                    ia < length\n                          (snd (mk_eqcl\n                                 (mk_eqcl' xs i (Suc i) (length zs) T)\n                                 (zs @ [i]) (Suc i) T));\n                    length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i\n                    \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd\n(mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                     ia\n                                     < length\n  (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n         T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n            T) !\n      ia \\<longrightarrow>\nfst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n(snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n ia -\n Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (None # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (None # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (None # xs) zs i T));\n        length (None # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (None # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (None # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (None # xs) zs i T) !\n                          (snd (mk_eqcl (None # xs) zs i T) ! ia - i) =\n                          ia)\n 2. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "moreover"], ["proof (state)\nthis:\n  ?z \\<in> set (zs @ [i]) \\<Longrightarrow> ?z < Suc i\n\ngoal (2 subgoals):\n 1. \\<And>xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length (zs @ [i]) \\<Longrightarrow>\n                               (zs @ [i]) ! ia\n                               < length\n                                  (mk_eqcl' xs i (Suc i) (length zs) T) +\n                                 Suc i \\<and>\n                               (Suc i\n                                \\<le> (zs @ [i]) ! ia \\<longrightarrow>\n                                mk_eqcl' xs i (Suc i) (length zs) T !\n                                ((zs @ [i]) ! ia - Suc i) =\n                                Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk>\n                       \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2;\n                    \\<And>z.\n                       z \\<in> set (zs @ [i]) \\<Longrightarrow> z < Suc i;\n                    ia < length\n                          (snd (mk_eqcl\n                                 (mk_eqcl' xs i (Suc i) (length zs) T)\n                                 (zs @ [i]) (Suc i) T));\n                    length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i\n                    \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd\n(mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                     ia\n                                     < length\n  (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n         T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n            T) !\n      ia \\<longrightarrow>\nfst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n(snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n ia -\n Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (None # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (None # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (None # xs) zs i T));\n        length (None # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (None # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (None # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (None # xs) zs i T) !\n                          (snd (mk_eqcl (None # xs) zs i T) ! ia - i) =\n                          ia)\n 2. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "from 2"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>i.\n              i < length (zs @ [i]) \\<Longrightarrow>\n              (zs @ [i]) ! i\n              < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n              (Suc i \\<le> (zs @ [i]) ! i \\<longrightarrow>\n               mk_eqcl' xs i (Suc i) (length zs) T !\n               ((zs @ [i]) ! i - Suc i) =\n               Some i);\n   \\<And>j1 j2.\n      \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk>\n      \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2;\n   \\<And>z. z \\<in> set (zs @ [i]) \\<Longrightarrow> z < Suc i;\n   ?i < length\n         (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i])\n                (Suc i) T));\n   length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i\n   \\<le> length T + 1\\<rbrakk>\n  \\<Longrightarrow> snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                          (zs @ [i]) (Suc i) T) !\n                    ?i\n                    < length\n                       (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                              (zs @ [i]) (Suc i) T)) +\n                      Suc i \\<and>\n                    (Suc i\n                     \\<le> snd (mk_eqcl\n                                 (mk_eqcl' xs i (Suc i) (length zs) T)\n                                 (zs @ [i]) (Suc i) T) !\n                           ?i \\<longrightarrow>\n                     fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                           (zs @ [i]) (Suc i) T) !\n                     (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                            (zs @ [i]) (Suc i) T) !\n                      ?i -\n                      Suc i) =\n                     ?i)\n  ?i < length zs \\<Longrightarrow>\n  zs ! ?i < length (None # xs) + i \\<and>\n  (i \\<le> zs ! ?i \\<longrightarrow> (None # xs) ! (zs ! ?i - i) = Some ?i)\n  \\<lbrakk>?j1.0 < ?j2.0; ?j2.0 < length zs\\<rbrakk>\n  \\<Longrightarrow> zs ! ?j1.0 < zs ! ?j2.0\n  ?z \\<in> set zs \\<Longrightarrow> ?z < i\n  j < length (snd (mk_eqcl (None # xs) zs i T))\n  length (None # xs) + i \\<le> length T + 1", "have \"j < length (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>i.\n              i < length (zs @ [i]) \\<Longrightarrow>\n              (zs @ [i]) ! i\n              < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n              (Suc i \\<le> (zs @ [i]) ! i \\<longrightarrow>\n               mk_eqcl' xs i (Suc i) (length zs) T !\n               ((zs @ [i]) ! i - Suc i) =\n               Some i);\n   \\<And>j1 j2.\n      \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk>\n      \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2;\n   \\<And>z. z \\<in> set (zs @ [i]) \\<Longrightarrow> z < Suc i;\n   ?i < length\n         (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i])\n                (Suc i) T));\n   length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i\n   \\<le> length T + 1\\<rbrakk>\n  \\<Longrightarrow> snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                          (zs @ [i]) (Suc i) T) !\n                    ?i\n                    < length\n                       (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                              (zs @ [i]) (Suc i) T)) +\n                      Suc i \\<and>\n                    (Suc i\n                     \\<le> snd (mk_eqcl\n                                 (mk_eqcl' xs i (Suc i) (length zs) T)\n                                 (zs @ [i]) (Suc i) T) !\n                           ?i \\<longrightarrow>\n                     fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                           (zs @ [i]) (Suc i) T) !\n                     (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                            (zs @ [i]) (Suc i) T) !\n                      ?i -\n                      Suc i) =\n                     ?i)\n  ?i < length zs \\<Longrightarrow>\n  zs ! ?i < length (None # xs) + i \\<and>\n  (i \\<le> zs ! ?i \\<longrightarrow> (None # xs) ! (zs ! ?i - i) = Some ?i)\n  \\<lbrakk>?j1.0 < ?j2.0; ?j2.0 < length zs\\<rbrakk>\n  \\<Longrightarrow> zs ! ?j1.0 < zs ! ?j2.0\n  ?z \\<in> set zs \\<Longrightarrow> ?z < i\n  j < length (snd (mk_eqcl (None # xs) zs i T))\n  length (None # xs) + i \\<le> length T + 1\n\ngoal (1 subgoal):\n 1. j < length\n         (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i])\n                (Suc i) T))", "by (simp add: split_beta)"], ["proof (state)\nthis:\n  j < length\n       (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i])\n              (Suc i) T))\n\ngoal (2 subgoals):\n 1. \\<And>xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length (zs @ [i]) \\<Longrightarrow>\n                               (zs @ [i]) ! ia\n                               < length\n                                  (mk_eqcl' xs i (Suc i) (length zs) T) +\n                                 Suc i \\<and>\n                               (Suc i\n                                \\<le> (zs @ [i]) ! ia \\<longrightarrow>\n                                mk_eqcl' xs i (Suc i) (length zs) T !\n                                ((zs @ [i]) ! ia - Suc i) =\n                                Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk>\n                       \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2;\n                    \\<And>z.\n                       z \\<in> set (zs @ [i]) \\<Longrightarrow> z < Suc i;\n                    ia < length\n                          (snd (mk_eqcl\n                                 (mk_eqcl' xs i (Suc i) (length zs) T)\n                                 (zs @ [i]) (Suc i) T));\n                    length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i\n                    \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd\n(mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                     ia\n                                     < length\n  (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n         T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n            T) !\n      ia \\<longrightarrow>\nfst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n(snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n ia -\n Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (None # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (None # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (None # xs) zs i T));\n        length (None # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (None # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (None # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (None # xs) zs i T) !\n                          (snd (mk_eqcl (None # xs) zs i T) ! ia - i) =\n                          ia)\n 2. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "moreover"], ["proof (state)\nthis:\n  j < length\n       (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i])\n              (Suc i) T))\n\ngoal (2 subgoals):\n 1. \\<And>xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length (zs @ [i]) \\<Longrightarrow>\n                               (zs @ [i]) ! ia\n                               < length\n                                  (mk_eqcl' xs i (Suc i) (length zs) T) +\n                                 Suc i \\<and>\n                               (Suc i\n                                \\<le> (zs @ [i]) ! ia \\<longrightarrow>\n                                mk_eqcl' xs i (Suc i) (length zs) T !\n                                ((zs @ [i]) ! ia - Suc i) =\n                                Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk>\n                       \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2;\n                    \\<And>z.\n                       z \\<in> set (zs @ [i]) \\<Longrightarrow> z < Suc i;\n                    ia < length\n                          (snd (mk_eqcl\n                                 (mk_eqcl' xs i (Suc i) (length zs) T)\n                                 (zs @ [i]) (Suc i) T));\n                    length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i\n                    \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd\n(mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                     ia\n                                     < length\n  (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n         T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n            T) !\n      ia \\<longrightarrow>\nfst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n(snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n ia -\n Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (None # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (None # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (None # xs) zs i T));\n        length (None # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (None # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (None # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (None # xs) zs i T) !\n                          (snd (mk_eqcl (None # xs) zs i T) ! ia - i) =\n                          ia)\n 2. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "from 2"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>i.\n              i < length (zs @ [i]) \\<Longrightarrow>\n              (zs @ [i]) ! i\n              < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n              (Suc i \\<le> (zs @ [i]) ! i \\<longrightarrow>\n               mk_eqcl' xs i (Suc i) (length zs) T !\n               ((zs @ [i]) ! i - Suc i) =\n               Some i);\n   \\<And>j1 j2.\n      \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk>\n      \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2;\n   \\<And>z. z \\<in> set (zs @ [i]) \\<Longrightarrow> z < Suc i;\n   ?i < length\n         (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i])\n                (Suc i) T));\n   length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i\n   \\<le> length T + 1\\<rbrakk>\n  \\<Longrightarrow> snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                          (zs @ [i]) (Suc i) T) !\n                    ?i\n                    < length\n                       (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                              (zs @ [i]) (Suc i) T)) +\n                      Suc i \\<and>\n                    (Suc i\n                     \\<le> snd (mk_eqcl\n                                 (mk_eqcl' xs i (Suc i) (length zs) T)\n                                 (zs @ [i]) (Suc i) T) !\n                           ?i \\<longrightarrow>\n                     fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                           (zs @ [i]) (Suc i) T) !\n                     (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                            (zs @ [i]) (Suc i) T) !\n                      ?i -\n                      Suc i) =\n                     ?i)\n  ?i < length zs \\<Longrightarrow>\n  zs ! ?i < length (None # xs) + i \\<and>\n  (i \\<le> zs ! ?i \\<longrightarrow> (None # xs) ! (zs ! ?i - i) = Some ?i)\n  \\<lbrakk>?j1.0 < ?j2.0; ?j2.0 < length zs\\<rbrakk>\n  \\<Longrightarrow> zs ! ?j1.0 < zs ! ?j2.0\n  ?z \\<in> set zs \\<Longrightarrow> ?z < i\n  j < length (snd (mk_eqcl (None # xs) zs i T))\n  length (None # xs) + i \\<le> length T + 1", "have \"length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<le> length T + 1\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>i.\n              i < length (zs @ [i]) \\<Longrightarrow>\n              (zs @ [i]) ! i\n              < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n              (Suc i \\<le> (zs @ [i]) ! i \\<longrightarrow>\n               mk_eqcl' xs i (Suc i) (length zs) T !\n               ((zs @ [i]) ! i - Suc i) =\n               Some i);\n   \\<And>j1 j2.\n      \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk>\n      \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2;\n   \\<And>z. z \\<in> set (zs @ [i]) \\<Longrightarrow> z < Suc i;\n   ?i < length\n         (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i])\n                (Suc i) T));\n   length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i\n   \\<le> length T + 1\\<rbrakk>\n  \\<Longrightarrow> snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                          (zs @ [i]) (Suc i) T) !\n                    ?i\n                    < length\n                       (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                              (zs @ [i]) (Suc i) T)) +\n                      Suc i \\<and>\n                    (Suc i\n                     \\<le> snd (mk_eqcl\n                                 (mk_eqcl' xs i (Suc i) (length zs) T)\n                                 (zs @ [i]) (Suc i) T) !\n                           ?i \\<longrightarrow>\n                     fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                           (zs @ [i]) (Suc i) T) !\n                     (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T)\n                            (zs @ [i]) (Suc i) T) !\n                      ?i -\n                      Suc i) =\n                     ?i)\n  ?i < length zs \\<Longrightarrow>\n  zs ! ?i < length (None # xs) + i \\<and>\n  (i \\<le> zs ! ?i \\<longrightarrow> (None # xs) ! (zs ! ?i - i) = Some ?i)\n  \\<lbrakk>?j1.0 < ?j2.0; ?j2.0 < length zs\\<rbrakk>\n  \\<Longrightarrow> zs ! ?j1.0 < zs ! ?j2.0\n  ?z \\<in> set zs \\<Longrightarrow> ?z < i\n  j < length (snd (mk_eqcl (None # xs) zs i T))\n  length (None # xs) + i \\<le> length T + 1\n\ngoal (1 subgoal):\n 1. length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<le> length T + 1", "by (simp add: mk_eqcl'_len)"], ["proof (state)\nthis:\n  length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<le> length T + 1\n\ngoal (2 subgoals):\n 1. \\<And>xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length (zs @ [i]) \\<Longrightarrow>\n                               (zs @ [i]) ! ia\n                               < length\n                                  (mk_eqcl' xs i (Suc i) (length zs) T) +\n                                 Suc i \\<and>\n                               (Suc i\n                                \\<le> (zs @ [i]) ! ia \\<longrightarrow>\n                                mk_eqcl' xs i (Suc i) (length zs) T !\n                                ((zs @ [i]) ! ia - Suc i) =\n                                Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk>\n                       \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2;\n                    \\<And>z.\n                       z \\<in> set (zs @ [i]) \\<Longrightarrow> z < Suc i;\n                    ia < length\n                          (snd (mk_eqcl\n                                 (mk_eqcl' xs i (Suc i) (length zs) T)\n                                 (zs @ [i]) (Suc i) T));\n                    length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i\n                    \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd\n(mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                     ia\n                                     < length\n  (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n         T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n            T) !\n      ia \\<longrightarrow>\nfst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n(snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n ia -\n Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (None # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (None # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (None # xs) zs i T));\n        length (None # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (None # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (None # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (None # xs) zs i T) !\n                          (snd (mk_eqcl (None # xs) zs i T) ! ia - i) =\n                          ia)\n 2. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "ultimately"], ["proof (chain)\npicking this:\n  ?i' < length (zs @ [i]) \\<Longrightarrow>\n  (zs @ [i]) ! ?i'\n  < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n  (Suc i \\<le> (zs @ [i]) ! ?i' \\<longrightarrow>\n   mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! ?i' - Suc i) =\n   Some ?i')\n  \\<lbrakk>?j1.0 < ?j2.0; ?j2.0 < length (zs @ [i])\\<rbrakk>\n  \\<Longrightarrow> (zs @ [i]) ! ?j1.0 < (zs @ [i]) ! ?j2.0\n  ?z \\<in> set (zs @ [i]) \\<Longrightarrow> ?z < Suc i\n  j < length\n       (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i])\n              (Suc i) T))\n  length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<le> length T + 1", "have IV: \"snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) ! j < length (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T)) + Suc i \\<and>\n   (Suc i \\<le> snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) ! j \\<longrightarrow>\n    fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) ! (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) ! j - Suc i) = j)\""], ["proof (prove)\nusing this:\n  ?i' < length (zs @ [i]) \\<Longrightarrow>\n  (zs @ [i]) ! ?i'\n  < length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<and>\n  (Suc i \\<le> (zs @ [i]) ! ?i' \\<longrightarrow>\n   mk_eqcl' xs i (Suc i) (length zs) T ! ((zs @ [i]) ! ?i' - Suc i) =\n   Some ?i')\n  \\<lbrakk>?j1.0 < ?j2.0; ?j2.0 < length (zs @ [i])\\<rbrakk>\n  \\<Longrightarrow> (zs @ [i]) ! ?j1.0 < (zs @ [i]) ! ?j2.0\n  ?z \\<in> set (zs @ [i]) \\<Longrightarrow> ?z < Suc i\n  j < length\n       (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i])\n              (Suc i) T))\n  length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i \\<le> length T + 1\n\ngoal (1 subgoal):\n 1. snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n          T) !\n    j\n    < length\n       (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i])\n              (Suc i) T)) +\n      Suc i \\<and>\n    (Suc i\n     \\<le> snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i])\n                 (Suc i) T) !\n           j \\<longrightarrow>\n     fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n           T) !\n     (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n            T) !\n      j -\n      Suc i) =\n     j)", "by (rule 2(1))"], ["proof (state)\nthis:\n  snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n  j\n  < length\n     (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n            T)) +\n    Suc i \\<and>\n  (Suc i\n   \\<le> snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i])\n               (Suc i) T) !\n         j \\<longrightarrow>\n   fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n         T) !\n   (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n          T) !\n    j -\n    Suc i) =\n   j)\n\ngoal (2 subgoals):\n 1. \\<And>xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length (zs @ [i]) \\<Longrightarrow>\n                               (zs @ [i]) ! ia\n                               < length\n                                  (mk_eqcl' xs i (Suc i) (length zs) T) +\n                                 Suc i \\<and>\n                               (Suc i\n                                \\<le> (zs @ [i]) ! ia \\<longrightarrow>\n                                mk_eqcl' xs i (Suc i) (length zs) T !\n                                ((zs @ [i]) ! ia - Suc i) =\n                                Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk>\n                       \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2;\n                    \\<And>z.\n                       z \\<in> set (zs @ [i]) \\<Longrightarrow> z < Suc i;\n                    ia < length\n                          (snd (mk_eqcl\n                                 (mk_eqcl' xs i (Suc i) (length zs) T)\n                                 (zs @ [i]) (Suc i) T));\n                    length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i\n                    \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd\n(mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                     ia\n                                     < length\n  (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n         T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n            T) !\n      ia \\<longrightarrow>\nfst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n(snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n ia -\n Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (None # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (None # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (None # xs) zs i T));\n        length (None # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (None # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (None # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (None # xs) zs i T) !\n                          (snd (mk_eqcl (None # xs) zs i T) ! ia - i) =\n                          ia)\n 2. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "hence G1: \"snd (mk_eqcl (None # xs) zs i T) ! j < length (fst (mk_eqcl (None # xs) zs i T)) + i\""], ["proof (prove)\nusing this:\n  snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n  j\n  < length\n     (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n            T)) +\n    Suc i \\<and>\n  (Suc i\n   \\<le> snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i])\n               (Suc i) T) !\n         j \\<longrightarrow>\n   fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n         T) !\n   (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n          T) !\n    j -\n    Suc i) =\n   j)\n\ngoal (1 subgoal):\n 1. snd (mk_eqcl (None # xs) zs i T) ! j\n    < length (fst (mk_eqcl (None # xs) zs i T)) + i", "by (auto simp: split_beta)"], ["proof (state)\nthis:\n  snd (mk_eqcl (None # xs) zs i T) ! j\n  < length (fst (mk_eqcl (None # xs) zs i T)) + i\n\ngoal (2 subgoals):\n 1. \\<And>xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length (zs @ [i]) \\<Longrightarrow>\n                               (zs @ [i]) ! ia\n                               < length\n                                  (mk_eqcl' xs i (Suc i) (length zs) T) +\n                                 Suc i \\<and>\n                               (Suc i\n                                \\<le> (zs @ [i]) ! ia \\<longrightarrow>\n                                mk_eqcl' xs i (Suc i) (length zs) T !\n                                ((zs @ [i]) ! ia - Suc i) =\n                                Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk>\n                       \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2;\n                    \\<And>z.\n                       z \\<in> set (zs @ [i]) \\<Longrightarrow> z < Suc i;\n                    ia < length\n                          (snd (mk_eqcl\n                                 (mk_eqcl' xs i (Suc i) (length zs) T)\n                                 (zs @ [i]) (Suc i) T));\n                    length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i\n                    \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd\n(mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                     ia\n                                     < length\n  (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n         T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n            T) !\n      ia \\<longrightarrow>\nfst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n(snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n ia -\n Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (None # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (None # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (None # xs) zs i T));\n        length (None # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (None # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (None # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (None # xs) zs i T) !\n                          (snd (mk_eqcl (None # xs) zs i T) ! ia - i) =\n                          ia)\n 2. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "{"], ["proof (state)\nthis:\n  snd (mk_eqcl (None # xs) zs i T) ! j\n  < length (fst (mk_eqcl (None # xs) zs i T)) + i\n\ngoal (2 subgoals):\n 1. \\<And>xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length (zs @ [i]) \\<Longrightarrow>\n                               (zs @ [i]) ! ia\n                               < length\n                                  (mk_eqcl' xs i (Suc i) (length zs) T) +\n                                 Suc i \\<and>\n                               (Suc i\n                                \\<le> (zs @ [i]) ! ia \\<longrightarrow>\n                                mk_eqcl' xs i (Suc i) (length zs) T !\n                                ((zs @ [i]) ! ia - Suc i) =\n                                Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk>\n                       \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2;\n                    \\<And>z.\n                       z \\<in> set (zs @ [i]) \\<Longrightarrow> z < Suc i;\n                    ia < length\n                          (snd (mk_eqcl\n                                 (mk_eqcl' xs i (Suc i) (length zs) T)\n                                 (zs @ [i]) (Suc i) T));\n                    length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i\n                    \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd\n(mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                     ia\n                                     < length\n  (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n         T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n            T) !\n      ia \\<longrightarrow>\nfst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n(snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n ia -\n Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (None # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (None # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (None # xs) zs i T));\n        length (None # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (None # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (None # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (None # xs) zs i T) !\n                          (snd (mk_eqcl (None # xs) zs i T) ! ia - i) =\n                          ia)\n 2. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "assume \"i \\<le> snd (mk_eqcl (None # xs) zs i T) ! j\""], ["proof (state)\nthis:\n  i \\<le> snd (mk_eqcl (None # xs) zs i T) ! j\n\ngoal (2 subgoals):\n 1. \\<And>xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length (zs @ [i]) \\<Longrightarrow>\n                               (zs @ [i]) ! ia\n                               < length\n                                  (mk_eqcl' xs i (Suc i) (length zs) T) +\n                                 Suc i \\<and>\n                               (Suc i\n                                \\<le> (zs @ [i]) ! ia \\<longrightarrow>\n                                mk_eqcl' xs i (Suc i) (length zs) T !\n                                ((zs @ [i]) ! ia - Suc i) =\n                                Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk>\n                       \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2;\n                    \\<And>z.\n                       z \\<in> set (zs @ [i]) \\<Longrightarrow> z < Suc i;\n                    ia < length\n                          (snd (mk_eqcl\n                                 (mk_eqcl' xs i (Suc i) (length zs) T)\n                                 (zs @ [i]) (Suc i) T));\n                    length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i\n                    \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd\n(mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                     ia\n                                     < length\n  (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n         T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n            T) !\n      ia \\<longrightarrow>\nfst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n(snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n ia -\n Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (None # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (None # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (None # xs) zs i T));\n        length (None # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (None # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (None # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (None # xs) zs i T) !\n                          (snd (mk_eqcl (None # xs) zs i T) ! ia - i) =\n                          ia)\n 2. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "hence \"i = snd (mk_eqcl (None # xs) zs i T) ! j \\<or> Suc i \\<le> snd (mk_eqcl (None # xs) zs i T) ! j\""], ["proof (prove)\nusing this:\n  i \\<le> snd (mk_eqcl (None # xs) zs i T) ! j\n\ngoal (1 subgoal):\n 1. i = snd (mk_eqcl (None # xs) zs i T) ! j \\<or>\n    Suc i \\<le> snd (mk_eqcl (None # xs) zs i T) ! j", "by auto"], ["proof (state)\nthis:\n  i = snd (mk_eqcl (None # xs) zs i T) ! j \\<or>\n  Suc i \\<le> snd (mk_eqcl (None # xs) zs i T) ! j\n\ngoal (2 subgoals):\n 1. \\<And>xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length (zs @ [i]) \\<Longrightarrow>\n                               (zs @ [i]) ! ia\n                               < length\n                                  (mk_eqcl' xs i (Suc i) (length zs) T) +\n                                 Suc i \\<and>\n                               (Suc i\n                                \\<le> (zs @ [i]) ! ia \\<longrightarrow>\n                                mk_eqcl' xs i (Suc i) (length zs) T !\n                                ((zs @ [i]) ! ia - Suc i) =\n                                Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk>\n                       \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2;\n                    \\<And>z.\n                       z \\<in> set (zs @ [i]) \\<Longrightarrow> z < Suc i;\n                    ia < length\n                          (snd (mk_eqcl\n                                 (mk_eqcl' xs i (Suc i) (length zs) T)\n                                 (zs @ [i]) (Suc i) T));\n                    length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i\n                    \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd\n(mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                     ia\n                                     < length\n  (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n         T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n            T) !\n      ia \\<longrightarrow>\nfst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n(snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n ia -\n Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (None # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (None # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (None # xs) zs i T));\n        length (None # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (None # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (None # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (None # xs) zs i T) !\n                          (snd (mk_eqcl (None # xs) zs i T) ! ia - i) =\n                          ia)\n 2. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "hence \"fst (mk_eqcl (None # xs) zs i T) ! (snd (mk_eqcl (None # xs) zs i T) ! j - i) = j\""], ["proof (prove)\nusing this:\n  i = snd (mk_eqcl (None # xs) zs i T) ! j \\<or>\n  Suc i \\<le> snd (mk_eqcl (None # xs) zs i T) ! j\n\ngoal (1 subgoal):\n 1. fst (mk_eqcl (None # xs) zs i T) !\n    (snd (mk_eqcl (None # xs) zs i T) ! j - i) =\n    j", "proof (elim disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = snd (mk_eqcl (None # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (None # xs) zs i T) !\n    (snd (mk_eqcl (None # xs) zs i T) ! j - i) =\n    j\n 2. Suc i \\<le> snd (mk_eqcl (None # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (None # xs) zs i T) !\n    (snd (mk_eqcl (None # xs) zs i T) ! j - i) =\n    j", "assume H: \"i = snd (mk_eqcl (None # xs) zs i T) ! j\""], ["proof (state)\nthis:\n  i = snd (mk_eqcl (None # xs) zs i T) ! j\n\ngoal (2 subgoals):\n 1. i = snd (mk_eqcl (None # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (None # xs) zs i T) !\n    (snd (mk_eqcl (None # xs) zs i T) ! j - i) =\n    j\n 2. Suc i \\<le> snd (mk_eqcl (None # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (None # xs) zs i T) !\n    (snd (mk_eqcl (None # xs) zs i T) ! j - i) =\n    j", "define k where \"k = length zs\""], ["proof (state)\nthis:\n  k = length zs\n\ngoal (2 subgoals):\n 1. i = snd (mk_eqcl (None # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (None # xs) zs i T) !\n    (snd (mk_eqcl (None # xs) zs i T) ! j - i) =\n    j\n 2. Suc i \\<le> snd (mk_eqcl (None # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (None # xs) zs i T) !\n    (snd (mk_eqcl (None # xs) zs i T) ! j - i) =\n    j", "hence K: \"snd (mk_eqcl (None # xs) zs i T) ! k = i\""], ["proof (prove)\nusing this:\n  k = length zs\n\ngoal (1 subgoal):\n 1. snd (mk_eqcl (None # xs) zs i T) ! k = i", "by (simp add: mk_eqcl_snd_nth split_beta)"], ["proof (state)\nthis:\n  snd (mk_eqcl (None # xs) zs i T) ! k = i\n\ngoal (2 subgoals):\n 1. i = snd (mk_eqcl (None # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (None # xs) zs i T) !\n    (snd (mk_eqcl (None # xs) zs i T) ! j - i) =\n    j\n 2. Suc i \\<le> snd (mk_eqcl (None # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (None # xs) zs i T) !\n    (snd (mk_eqcl (None # xs) zs i T) ! j - i) =\n    j", "{"], ["proof (state)\nthis:\n  snd (mk_eqcl (None # xs) zs i T) ! k = i\n\ngoal (2 subgoals):\n 1. i = snd (mk_eqcl (None # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (None # xs) zs i T) !\n    (snd (mk_eqcl (None # xs) zs i T) ! j - i) =\n    j\n 2. Suc i \\<le> snd (mk_eqcl (None # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (None # xs) zs i T) !\n    (snd (mk_eqcl (None # xs) zs i T) ! j - i) =\n    j", "assume \"j \\<noteq> k\""], ["proof (state)\nthis:\n  j \\<noteq> k\n\ngoal (2 subgoals):\n 1. i = snd (mk_eqcl (None # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (None # xs) zs i T) !\n    (snd (mk_eqcl (None # xs) zs i T) ! j - i) =\n    j\n 2. Suc i \\<le> snd (mk_eqcl (None # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (None # xs) zs i T) !\n    (snd (mk_eqcl (None # xs) zs i T) ! j - i) =\n    j", "hence \"j < k \\<or> j > k\""], ["proof (prove)\nusing this:\n  j \\<noteq> k\n\ngoal (1 subgoal):\n 1. j < k \\<or> k < j", "by auto"], ["proof (state)\nthis:\n  j < k \\<or> k < j\n\ngoal (2 subgoals):\n 1. i = snd (mk_eqcl (None # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (None # xs) zs i T) !\n    (snd (mk_eqcl (None # xs) zs i T) ! j - i) =\n    j\n 2. Suc i \\<le> snd (mk_eqcl (None # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (None # xs) zs i T) !\n    (snd (mk_eqcl (None # xs) zs i T) ! j - i) =\n    j", "hence \"snd (mk_eqcl (None # xs) zs i T) ! j \\<noteq> i\""], ["proof (prove)\nusing this:\n  j < k \\<or> k < j\n\ngoal (1 subgoal):\n 1. snd (mk_eqcl (None # xs) zs i T) ! j \\<noteq> i", "proof (elim disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. j < k \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! j \\<noteq> i\n 2. k < j \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! j \\<noteq> i", "assume H': \"j < k\""], ["proof (state)\nthis:\n  j < k\n\ngoal (2 subgoals):\n 1. j < k \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! j \\<noteq> i\n 2. k < j \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! j \\<noteq> i", "from k_def"], ["proof (chain)\npicking this:\n  k = length zs", "have \"k < length (zs @ [i])\""], ["proof (prove)\nusing this:\n  k = length zs\n\ngoal (1 subgoal):\n 1. k < length (zs @ [i])", "by simp"], ["proof (state)\nthis:\n  k < length (zs @ [i])\n\ngoal (2 subgoals):\n 1. j < k \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! j \\<noteq> i\n 2. k < j \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! j \\<noteq> i", "also"], ["proof (state)\nthis:\n  k < length (zs @ [i])\n\ngoal (2 subgoals):\n 1. j < k \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! j \\<noteq> i\n 2. k < j \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! j \\<noteq> i", "have \"\\<dots> \\<le> length (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (zs @ [i])\n    \\<le> length\n           (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i])\n                  (Suc i) T))", "by (simp only: mk_eqcl_len_snd)"], ["proof (state)\nthis:\n  length (zs @ [i])\n  \\<le> length\n         (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i])\n                (Suc i) T))\n\ngoal (2 subgoals):\n 1. j < k \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! j \\<noteq> i\n 2. k < j \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! j \\<noteq> i", "also"], ["proof (state)\nthis:\n  length (zs @ [i])\n  \\<le> length\n         (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i])\n                (Suc i) T))\n\ngoal (2 subgoals):\n 1. j < k \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! j \\<noteq> i\n 2. k < j \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! j \\<noteq> i", "have \"\\<dots> = length (snd (mk_eqcl (None # xs) zs i T))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n            T)) =\n    length (snd (mk_eqcl (None # xs) zs i T))", "by (simp add: split_beta)"], ["proof (state)\nthis:\n  length\n   (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n          T)) =\n  length (snd (mk_eqcl (None # xs) zs i T))\n\ngoal (2 subgoals):\n 1. j < k \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! j \\<noteq> i\n 2. k < j \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! j \\<noteq> i", "finally"], ["proof (chain)\npicking this:\n  k < length (snd (mk_eqcl (None # xs) zs i T))", "have K': \"k < length (snd (mk_eqcl (None # xs) zs i T))\""], ["proof (prove)\nusing this:\n  k < length (snd (mk_eqcl (None # xs) zs i T))\n\ngoal (1 subgoal):\n 1. k < length (snd (mk_eqcl (None # xs) zs i T))", "by simp"], ["proof (state)\nthis:\n  k < length (snd (mk_eqcl (None # xs) zs i T))\n\ngoal (2 subgoals):\n 1. j < k \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! j \\<noteq> i\n 2. k < j \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! j \\<noteq> i", "from 2(3,4) H' this"], ["proof (chain)\npicking this:\n  \\<lbrakk>?j1.0 < ?j2.0; ?j2.0 < length zs\\<rbrakk>\n  \\<Longrightarrow> zs ! ?j1.0 < zs ! ?j2.0\n  ?z \\<in> set zs \\<Longrightarrow> ?z < i\n  j < k\n  k < length (snd (mk_eqcl (None # xs) zs i T))", "have \"snd (mk_eqcl (None # xs) zs i T) ! j < snd (mk_eqcl (None # xs) zs i T) ! k\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?j1.0 < ?j2.0; ?j2.0 < length zs\\<rbrakk>\n  \\<Longrightarrow> zs ! ?j1.0 < zs ! ?j2.0\n  ?z \\<in> set zs \\<Longrightarrow> ?z < i\n  j < k\n  k < length (snd (mk_eqcl (None # xs) zs i T))\n\ngoal (1 subgoal):\n 1. snd (mk_eqcl (None # xs) zs i T) ! j\n    < snd (mk_eqcl (None # xs) zs i T) ! k", "by (rule mk_eqcl_snd_mon)"], ["proof (state)\nthis:\n  snd (mk_eqcl (None # xs) zs i T) ! j\n  < snd (mk_eqcl (None # xs) zs i T) ! k\n\ngoal (2 subgoals):\n 1. j < k \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! j \\<noteq> i\n 2. k < j \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! j \\<noteq> i", "with K"], ["proof (chain)\npicking this:\n  snd (mk_eqcl (None # xs) zs i T) ! k = i\n  snd (mk_eqcl (None # xs) zs i T) ! j\n  < snd (mk_eqcl (None # xs) zs i T) ! k", "show ?thesis"], ["proof (prove)\nusing this:\n  snd (mk_eqcl (None # xs) zs i T) ! k = i\n  snd (mk_eqcl (None # xs) zs i T) ! j\n  < snd (mk_eqcl (None # xs) zs i T) ! k\n\ngoal (1 subgoal):\n 1. snd (mk_eqcl (None # xs) zs i T) ! j \\<noteq> i", "by simp"], ["proof (state)\nthis:\n  snd (mk_eqcl (None # xs) zs i T) ! j \\<noteq> i\n\ngoal (1 subgoal):\n 1. k < j \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! j \\<noteq> i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k < j \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! j \\<noteq> i", "assume H': \"j > k\""], ["proof (state)\nthis:\n  k < j\n\ngoal (1 subgoal):\n 1. k < j \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! j \\<noteq> i", "from 2(3,4) H' 2(5)"], ["proof (chain)\npicking this:\n  \\<lbrakk>?j1.0 < ?j2.0; ?j2.0 < length zs\\<rbrakk>\n  \\<Longrightarrow> zs ! ?j1.0 < zs ! ?j2.0\n  ?z \\<in> set zs \\<Longrightarrow> ?z < i\n  k < j\n  j < length (snd (mk_eqcl (None # xs) zs i T))", "have \"snd (mk_eqcl (None # xs) zs i T) ! k < snd (mk_eqcl (None # xs) zs i T) ! j\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?j1.0 < ?j2.0; ?j2.0 < length zs\\<rbrakk>\n  \\<Longrightarrow> zs ! ?j1.0 < zs ! ?j2.0\n  ?z \\<in> set zs \\<Longrightarrow> ?z < i\n  k < j\n  j < length (snd (mk_eqcl (None # xs) zs i T))\n\ngoal (1 subgoal):\n 1. snd (mk_eqcl (None # xs) zs i T) ! k\n    < snd (mk_eqcl (None # xs) zs i T) ! j", "by (rule mk_eqcl_snd_mon)"], ["proof (state)\nthis:\n  snd (mk_eqcl (None # xs) zs i T) ! k\n  < snd (mk_eqcl (None # xs) zs i T) ! j\n\ngoal (1 subgoal):\n 1. k < j \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! j \\<noteq> i", "with K"], ["proof (chain)\npicking this:\n  snd (mk_eqcl (None # xs) zs i T) ! k = i\n  snd (mk_eqcl (None # xs) zs i T) ! k\n  < snd (mk_eqcl (None # xs) zs i T) ! j", "show ?thesis"], ["proof (prove)\nusing this:\n  snd (mk_eqcl (None # xs) zs i T) ! k = i\n  snd (mk_eqcl (None # xs) zs i T) ! k\n  < snd (mk_eqcl (None # xs) zs i T) ! j\n\ngoal (1 subgoal):\n 1. snd (mk_eqcl (None # xs) zs i T) ! j \\<noteq> i", "by simp"], ["proof (state)\nthis:\n  snd (mk_eqcl (None # xs) zs i T) ! j \\<noteq> i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  snd (mk_eqcl (None # xs) zs i T) ! j \\<noteq> i\n\ngoal (2 subgoals):\n 1. i = snd (mk_eqcl (None # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (None # xs) zs i T) !\n    (snd (mk_eqcl (None # xs) zs i T) ! j - i) =\n    j\n 2. Suc i \\<le> snd (mk_eqcl (None # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (None # xs) zs i T) !\n    (snd (mk_eqcl (None # xs) zs i T) ! j - i) =\n    j", "}"], ["proof (state)\nthis:\n  j \\<noteq> k \\<Longrightarrow>\n  snd (mk_eqcl (None # xs) zs i T) ! j \\<noteq> i\n\ngoal (2 subgoals):\n 1. i = snd (mk_eqcl (None # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (None # xs) zs i T) !\n    (snd (mk_eqcl (None # xs) zs i T) ! j - i) =\n    j\n 2. Suc i \\<le> snd (mk_eqcl (None # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (None # xs) zs i T) !\n    (snd (mk_eqcl (None # xs) zs i T) ! j - i) =\n    j", "with H k_def"], ["proof (chain)\npicking this:\n  i = snd (mk_eqcl (None # xs) zs i T) ! j\n  k = length zs\n  j \\<noteq> k \\<Longrightarrow>\n  snd (mk_eqcl (None # xs) zs i T) ! j \\<noteq> i", "have \"j = length zs\""], ["proof (prove)\nusing this:\n  i = snd (mk_eqcl (None # xs) zs i T) ! j\n  k = length zs\n  j \\<noteq> k \\<Longrightarrow>\n  snd (mk_eqcl (None # xs) zs i T) ! j \\<noteq> i\n\ngoal (1 subgoal):\n 1. j = length zs", "by auto"], ["proof (state)\nthis:\n  j = length zs\n\ngoal (2 subgoals):\n 1. i = snd (mk_eqcl (None # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (None # xs) zs i T) !\n    (snd (mk_eqcl (None # xs) zs i T) ! j - i) =\n    j\n 2. Suc i \\<le> snd (mk_eqcl (None # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (None # xs) zs i T) !\n    (snd (mk_eqcl (None # xs) zs i T) ! j - i) =\n    j", "with H"], ["proof (chain)\npicking this:\n  i = snd (mk_eqcl (None # xs) zs i T) ! j\n  j = length zs", "show ?thesis"], ["proof (prove)\nusing this:\n  i = snd (mk_eqcl (None # xs) zs i T) ! j\n  j = length zs\n\ngoal (1 subgoal):\n 1. fst (mk_eqcl (None # xs) zs i T) !\n    (snd (mk_eqcl (None # xs) zs i T) ! j - i) =\n    j", "by (simp add: split_beta)"], ["proof (state)\nthis:\n  fst (mk_eqcl (None # xs) zs i T) !\n  (snd (mk_eqcl (None # xs) zs i T) ! j - i) =\n  j\n\ngoal (1 subgoal):\n 1. Suc i \\<le> snd (mk_eqcl (None # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (None # xs) zs i T) !\n    (snd (mk_eqcl (None # xs) zs i T) ! j - i) =\n    j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc i \\<le> snd (mk_eqcl (None # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (None # xs) zs i T) !\n    (snd (mk_eqcl (None # xs) zs i T) ! j - i) =\n    j", "assume H: \"Suc i \\<le> snd (mk_eqcl (None # xs) zs i T) ! j\""], ["proof (state)\nthis:\n  Suc i \\<le> snd (mk_eqcl (None # xs) zs i T) ! j\n\ngoal (1 subgoal):\n 1. Suc i \\<le> snd (mk_eqcl (None # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (None # xs) zs i T) !\n    (snd (mk_eqcl (None # xs) zs i T) ! j - i) =\n    j", "then"], ["proof (chain)\npicking this:\n  Suc i \\<le> snd (mk_eqcl (None # xs) zs i T) ! j", "obtain k where K: \"snd (mk_eqcl (None # xs) zs i T) ! j - i = Suc k\""], ["proof (prove)\nusing this:\n  Suc i \\<le> snd (mk_eqcl (None # xs) zs i T) ! j\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        snd (mk_eqcl (None # xs) zs i T) ! j - i = Suc k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"snd (mk_eqcl (None # xs) zs i T) ! j - i\") simp+"], ["proof (state)\nthis:\n  snd (mk_eqcl (None # xs) zs i T) ! j - i = Suc k\n\ngoal (1 subgoal):\n 1. Suc i \\<le> snd (mk_eqcl (None # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (None # xs) zs i T) !\n    (snd (mk_eqcl (None # xs) zs i T) ! j - i) =\n    j", "hence K': \"k = snd (mk_eqcl (None # xs) zs i T) ! j - Suc i\""], ["proof (prove)\nusing this:\n  snd (mk_eqcl (None # xs) zs i T) ! j - i = Suc k\n\ngoal (1 subgoal):\n 1. k = snd (mk_eqcl (None # xs) zs i T) ! j - Suc i", "by simp"], ["proof (state)\nthis:\n  k = snd (mk_eqcl (None # xs) zs i T) ! j - Suc i\n\ngoal (1 subgoal):\n 1. Suc i \\<le> snd (mk_eqcl (None # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (None # xs) zs i T) !\n    (snd (mk_eqcl (None # xs) zs i T) ! j - i) =\n    j", "from H IV"], ["proof (chain)\npicking this:\n  Suc i \\<le> snd (mk_eqcl (None # xs) zs i T) ! j\n  snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n  j\n  < length\n     (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n            T)) +\n    Suc i \\<and>\n  (Suc i\n   \\<le> snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i])\n               (Suc i) T) !\n         j \\<longrightarrow>\n   fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n         T) !\n   (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n          T) !\n    j -\n    Suc i) =\n   j)", "have \"fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) ! (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) ! j - Suc i) = j\""], ["proof (prove)\nusing this:\n  Suc i \\<le> snd (mk_eqcl (None # xs) zs i T) ! j\n  snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n  j\n  < length\n     (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n            T)) +\n    Suc i \\<and>\n  (Suc i\n   \\<le> snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i])\n               (Suc i) T) !\n         j \\<longrightarrow>\n   fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n         T) !\n   (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n          T) !\n    j -\n    Suc i) =\n   j)\n\ngoal (1 subgoal):\n 1. fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n          T) !\n    (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n           T) !\n     j -\n     Suc i) =\n    j", "by (auto simp: split_beta)"], ["proof (state)\nthis:\n  fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n  (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n         T) !\n   j -\n   Suc i) =\n  j\n\ngoal (1 subgoal):\n 1. Suc i \\<le> snd (mk_eqcl (None # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (None # xs) zs i T) !\n    (snd (mk_eqcl (None # xs) zs i T) ! j - i) =\n    j", "with K'"], ["proof (chain)\npicking this:\n  k = snd (mk_eqcl (None # xs) zs i T) ! j - Suc i\n  fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n  (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n         T) !\n   j -\n   Suc i) =\n  j", "have \"fst (mk_eqcl (None # xs) zs i T) ! Suc k = j\""], ["proof (prove)\nusing this:\n  k = snd (mk_eqcl (None # xs) zs i T) ! j - Suc i\n  fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n  (snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n         T) !\n   j -\n   Suc i) =\n  j\n\ngoal (1 subgoal):\n 1. fst (mk_eqcl (None # xs) zs i T) ! Suc k = j", "by (simp add: split_beta)"], ["proof (state)\nthis:\n  fst (mk_eqcl (None # xs) zs i T) ! Suc k = j\n\ngoal (1 subgoal):\n 1. Suc i \\<le> snd (mk_eqcl (None # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (None # xs) zs i T) !\n    (snd (mk_eqcl (None # xs) zs i T) ! j - i) =\n    j", "with K"], ["proof (chain)\npicking this:\n  snd (mk_eqcl (None # xs) zs i T) ! j - i = Suc k\n  fst (mk_eqcl (None # xs) zs i T) ! Suc k = j", "show ?thesis"], ["proof (prove)\nusing this:\n  snd (mk_eqcl (None # xs) zs i T) ! j - i = Suc k\n  fst (mk_eqcl (None # xs) zs i T) ! Suc k = j\n\ngoal (1 subgoal):\n 1. fst (mk_eqcl (None # xs) zs i T) !\n    (snd (mk_eqcl (None # xs) zs i T) ! j - i) =\n    j", "by simp"], ["proof (state)\nthis:\n  fst (mk_eqcl (None # xs) zs i T) !\n  (snd (mk_eqcl (None # xs) zs i T) ! j - i) =\n  j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst (mk_eqcl (None # xs) zs i T) !\n  (snd (mk_eqcl (None # xs) zs i T) ! j - i) =\n  j\n\ngoal (2 subgoals):\n 1. \\<And>xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length (zs @ [i]) \\<Longrightarrow>\n                               (zs @ [i]) ! ia\n                               < length\n                                  (mk_eqcl' xs i (Suc i) (length zs) T) +\n                                 Suc i \\<and>\n                               (Suc i\n                                \\<le> (zs @ [i]) ! ia \\<longrightarrow>\n                                mk_eqcl' xs i (Suc i) (length zs) T !\n                                ((zs @ [i]) ! ia - Suc i) =\n                                Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk>\n                       \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2;\n                    \\<And>z.\n                       z \\<in> set (zs @ [i]) \\<Longrightarrow> z < Suc i;\n                    ia < length\n                          (snd (mk_eqcl\n                                 (mk_eqcl' xs i (Suc i) (length zs) T)\n                                 (zs @ [i]) (Suc i) T));\n                    length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i\n                    \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd\n(mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                     ia\n                                     < length\n  (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n         T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n            T) !\n      ia \\<longrightarrow>\nfst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n(snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n ia -\n Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (None # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (None # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (None # xs) zs i T));\n        length (None # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (None # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (None # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (None # xs) zs i T) !\n                          (snd (mk_eqcl (None # xs) zs i T) ! ia - i) =\n                          ia)\n 2. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "}"], ["proof (state)\nthis:\n  i \\<le> snd (mk_eqcl (None # xs) zs i T) ! j \\<Longrightarrow>\n  fst (mk_eqcl (None # xs) zs i T) !\n  (snd (mk_eqcl (None # xs) zs i T) ! j - i) =\n  j\n\ngoal (2 subgoals):\n 1. \\<And>xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length (zs @ [i]) \\<Longrightarrow>\n                               (zs @ [i]) ! ia\n                               < length\n                                  (mk_eqcl' xs i (Suc i) (length zs) T) +\n                                 Suc i \\<and>\n                               (Suc i\n                                \\<le> (zs @ [i]) ! ia \\<longrightarrow>\n                                mk_eqcl' xs i (Suc i) (length zs) T !\n                                ((zs @ [i]) ! ia - Suc i) =\n                                Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length (zs @ [i])\\<rbrakk>\n                       \\<Longrightarrow> (zs @ [i]) ! j1 < (zs @ [i]) ! j2;\n                    \\<And>z.\n                       z \\<in> set (zs @ [i]) \\<Longrightarrow> z < Suc i;\n                    ia < length\n                          (snd (mk_eqcl\n                                 (mk_eqcl' xs i (Suc i) (length zs) T)\n                                 (zs @ [i]) (Suc i) T));\n                    length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i\n                    \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd\n(mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n                                     ia\n                                     < length\n  (fst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n         T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i)\n            T) !\n      ia \\<longrightarrow>\nfst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n(snd (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\n ia -\n Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (None # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (None # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (None # xs) zs i T));\n        length (None # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (None # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (None # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (None # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (None # xs) zs i T) !\n                          (snd (mk_eqcl (None # xs) zs i T) ! ia - i) =\n                          ia)\n 2. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "with G1"], ["proof (chain)\npicking this:\n  snd (mk_eqcl (None # xs) zs i T) ! j\n  < length (fst (mk_eqcl (None # xs) zs i T)) + i\n  i \\<le> snd (mk_eqcl (None # xs) zs i T) ! j \\<Longrightarrow>\n  fst (mk_eqcl (None # xs) zs i T) !\n  (snd (mk_eqcl (None # xs) zs i T) ! j - i) =\n  j", "show ?case"], ["proof (prove)\nusing this:\n  snd (mk_eqcl (None # xs) zs i T) ! j\n  < length (fst (mk_eqcl (None # xs) zs i T)) + i\n  i \\<le> snd (mk_eqcl (None # xs) zs i T) ! j \\<Longrightarrow>\n  fst (mk_eqcl (None # xs) zs i T) !\n  (snd (mk_eqcl (None # xs) zs i T) ! j - i) =\n  j\n\ngoal (1 subgoal):\n 1. snd (mk_eqcl (None # xs) zs i T) ! j\n    < length (fst (mk_eqcl (None # xs) zs i T)) + i \\<and>\n    (i \\<le> snd (mk_eqcl (None # xs) zs i T) ! j \\<longrightarrow>\n     fst (mk_eqcl (None # xs) zs i T) !\n     (snd (mk_eqcl (None # xs) zs i T) ! j - i) =\n     j)", "by simp"], ["proof (state)\nthis:\n  snd (mk_eqcl (None # xs) zs i T) ! j\n  < length (fst (mk_eqcl (None # xs) zs i T)) + i \\<and>\n  (i \\<le> snd (mk_eqcl (None # xs) zs i T) ! j \\<longrightarrow>\n   fst (mk_eqcl (None # xs) zs i T) !\n   (snd (mk_eqcl (None # xs) zs i T) ! j - i) =\n   j)\n\ngoal (1 subgoal):\n 1. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "case (3 l xs zs i T j)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>i.\n              i < length zs \\<Longrightarrow>\n              zs ! i < length xs + Suc i \\<and>\n              (Suc i \\<le> zs ! i \\<longrightarrow>\n               xs ! (zs ! i - Suc i) = Some i);\n   \\<And>j1 j2.\n      \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n      \\<Longrightarrow> zs ! j1 < zs ! j2;\n   \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n   ?i < length (snd (mk_eqcl xs zs (Suc i) T));\n   length xs + Suc i \\<le> length T + 1\\<rbrakk>\n  \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ?i\n                    < length (fst (mk_eqcl xs zs (Suc i) T)) + Suc i \\<and>\n                    (Suc i\n                     \\<le> snd (mk_eqcl xs zs (Suc i) T) !\n                           ?i \\<longrightarrow>\n                     fst (mk_eqcl xs zs (Suc i) T) !\n                     (snd (mk_eqcl xs zs (Suc i) T) ! ?i - Suc i) =\n                     ?i)\n  ?i < length zs \\<Longrightarrow>\n  zs ! ?i < length (Some l # xs) + i \\<and>\n  (i \\<le> zs ! ?i \\<longrightarrow>\n   (Some l # xs) ! (zs ! ?i - i) = Some ?i)\n  \\<lbrakk>?j1.0 < ?j2.0; ?j2.0 < length zs\\<rbrakk>\n  \\<Longrightarrow> zs ! ?j1.0 < zs ! ?j2.0\n  ?z \\<in> set zs \\<Longrightarrow> ?z < i\n  j < length (snd (mk_eqcl (Some l # xs) zs i T))\n  length (Some l # xs) + i \\<le> length T + 1\n\ngoal (1 subgoal):\n 1. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "have 1: \"snd (mk_eqcl (Some l # xs) zs i T) = snd (mk_eqcl xs zs (Suc i) T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (mk_eqcl (Some l # xs) zs i T) = snd (mk_eqcl xs zs (Suc i) T)", "by (simp add: split_beta)"], ["proof (state)\nthis:\n  snd (mk_eqcl (Some l # xs) zs i T) = snd (mk_eqcl xs zs (Suc i) T)\n\ngoal (1 subgoal):\n 1. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "have 2: \"length (fst (mk_eqcl (Some l # xs) zs i T)) = length (Some l # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (fst (mk_eqcl (Some l # xs) zs i T)) = length (Some l # xs)", "by (simp add: split_beta mk_eqcl_len_fst)"], ["proof (state)\nthis:\n  length (fst (mk_eqcl (Some l # xs) zs i T)) = length (Some l # xs)\n\ngoal (1 subgoal):\n 1. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "have \"\\<And>j. j < length zs \\<Longrightarrow> zs ! j < length xs + Suc i \\<and> (Suc i \\<le> zs ! j \\<longrightarrow> xs ! (zs ! j - Suc i) = Some j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length zs \\<Longrightarrow>\n       zs ! j < length xs + Suc i \\<and>\n       (Suc i \\<le> zs ! j \\<longrightarrow> xs ! (zs ! j - Suc i) = Some j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length zs \\<Longrightarrow>\n       zs ! j < length xs + Suc i \\<and>\n       (Suc i \\<le> zs ! j \\<longrightarrow> xs ! (zs ! j - Suc i) = Some j)", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length zs \\<Longrightarrow>\n       zs ! j < length xs + Suc i \\<and>\n       (Suc i \\<le> zs ! j \\<longrightarrow> xs ! (zs ! j - Suc i) = Some j)", "assume H: \"j < length zs\""], ["proof (state)\nthis:\n  j < length zs\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length zs \\<Longrightarrow>\n       zs ! j < length xs + Suc i \\<and>\n       (Suc i \\<le> zs ! j \\<longrightarrow> xs ! (zs ! j - Suc i) = Some j)", "with 3(2)[of j]"], ["proof (chain)\npicking this:\n  j < length zs \\<Longrightarrow>\n  zs ! j < length (Some l # xs) + i \\<and>\n  (i \\<le> zs ! j \\<longrightarrow> (Some l # xs) ! (zs ! j - i) = Some j)\n  j < length zs", "have I: \"zs ! j < length (Some l # xs) + i \\<and> (i \\<le> zs ! j \\<longrightarrow> (Some l # xs) ! (zs ! j - i) = Some j)\""], ["proof (prove)\nusing this:\n  j < length zs \\<Longrightarrow>\n  zs ! j < length (Some l # xs) + i \\<and>\n  (i \\<le> zs ! j \\<longrightarrow> (Some l # xs) ! (zs ! j - i) = Some j)\n  j < length zs\n\ngoal (1 subgoal):\n 1. zs ! j < length (Some l # xs) + i \\<and>\n    (i \\<le> zs ! j \\<longrightarrow> (Some l # xs) ! (zs ! j - i) = Some j)", "by simp"], ["proof (state)\nthis:\n  zs ! j < length (Some l # xs) + i \\<and>\n  (i \\<le> zs ! j \\<longrightarrow> (Some l # xs) ! (zs ! j - i) = Some j)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length zs \\<Longrightarrow>\n       zs ! j < length xs + Suc i \\<and>\n       (Suc i \\<le> zs ! j \\<longrightarrow> xs ! (zs ! j - Suc i) = Some j)", "hence G1: \"zs ! j < length xs + Suc i\" and G2: \"i \\<le> zs ! j \\<longrightarrow> (Some l # xs) ! (zs ! j - i) = Some j\""], ["proof (prove)\nusing this:\n  zs ! j < length (Some l # xs) + i \\<and>\n  (i \\<le> zs ! j \\<longrightarrow> (Some l # xs) ! (zs ! j - i) = Some j)\n\ngoal (1 subgoal):\n 1. zs ! j < length xs + Suc i &&&\n    i \\<le> zs ! j \\<longrightarrow> (Some l # xs) ! (zs ! j - i) = Some j", "by simp+"], ["proof (state)\nthis:\n  zs ! j < length xs + Suc i\n  i \\<le> zs ! j \\<longrightarrow> (Some l # xs) ! (zs ! j - i) = Some j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length zs \\<Longrightarrow>\n       zs ! j < length xs + Suc i \\<and>\n       (Suc i \\<le> zs ! j \\<longrightarrow> xs ! (zs ! j - Suc i) = Some j)", "{"], ["proof (state)\nthis:\n  zs ! j < length xs + Suc i\n  i \\<le> zs ! j \\<longrightarrow> (Some l # xs) ! (zs ! j - i) = Some j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length zs \\<Longrightarrow>\n       zs ! j < length xs + Suc i \\<and>\n       (Suc i \\<le> zs ! j \\<longrightarrow> xs ! (zs ! j - Suc i) = Some j)", "assume H2: \"Suc i \\<le> zs ! j\""], ["proof (state)\nthis:\n  Suc i \\<le> zs ! j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length zs \\<Longrightarrow>\n       zs ! j < length xs + Suc i \\<and>\n       (Suc i \\<le> zs ! j \\<longrightarrow> xs ! (zs ! j - Suc i) = Some j)", "then"], ["proof (chain)\npicking this:\n  Suc i \\<le> zs ! j", "obtain k where K: \"zs ! j - i = Suc k\""], ["proof (prove)\nusing this:\n  Suc i \\<le> zs ! j\n\ngoal (1 subgoal):\n 1. (\\<And>k. zs ! j - i = Suc k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"zs ! j - i\") simp+"], ["proof (state)\nthis:\n  zs ! j - i = Suc k\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length zs \\<Longrightarrow>\n       zs ! j < length xs + Suc i \\<and>\n       (Suc i \\<le> zs ! j \\<longrightarrow> xs ! (zs ! j - Suc i) = Some j)", "with H2 G2"], ["proof (chain)\npicking this:\n  Suc i \\<le> zs ! j\n  i \\<le> zs ! j \\<longrightarrow> (Some l # xs) ! (zs ! j - i) = Some j\n  zs ! j - i = Suc k", "have \"xs ! k = Some j\""], ["proof (prove)\nusing this:\n  Suc i \\<le> zs ! j\n  i \\<le> zs ! j \\<longrightarrow> (Some l # xs) ! (zs ! j - i) = Some j\n  zs ! j - i = Suc k\n\ngoal (1 subgoal):\n 1. xs ! k = Some j", "by simp"], ["proof (state)\nthis:\n  xs ! k = Some j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length zs \\<Longrightarrow>\n       zs ! j < length xs + Suc i \\<and>\n       (Suc i \\<le> zs ! j \\<longrightarrow> xs ! (zs ! j - Suc i) = Some j)", "moreover"], ["proof (state)\nthis:\n  xs ! k = Some j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length zs \\<Longrightarrow>\n       zs ! j < length xs + Suc i \\<and>\n       (Suc i \\<le> zs ! j \\<longrightarrow> xs ! (zs ! j - Suc i) = Some j)", "from K"], ["proof (chain)\npicking this:\n  zs ! j - i = Suc k", "have \"k = zs ! j - Suc i\""], ["proof (prove)\nusing this:\n  zs ! j - i = Suc k\n\ngoal (1 subgoal):\n 1. k = zs ! j - Suc i", "by simp"], ["proof (state)\nthis:\n  k = zs ! j - Suc i\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length zs \\<Longrightarrow>\n       zs ! j < length xs + Suc i \\<and>\n       (Suc i \\<le> zs ! j \\<longrightarrow> xs ! (zs ! j - Suc i) = Some j)", "ultimately"], ["proof (chain)\npicking this:\n  xs ! k = Some j\n  k = zs ! j - Suc i", "have \"xs ! (zs ! j - Suc i) = Some j\""], ["proof (prove)\nusing this:\n  xs ! k = Some j\n  k = zs ! j - Suc i\n\ngoal (1 subgoal):\n 1. xs ! (zs ! j - Suc i) = Some j", "by simp"], ["proof (state)\nthis:\n  xs ! (zs ! j - Suc i) = Some j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length zs \\<Longrightarrow>\n       zs ! j < length xs + Suc i \\<and>\n       (Suc i \\<le> zs ! j \\<longrightarrow> xs ! (zs ! j - Suc i) = Some j)", "}"], ["proof (state)\nthis:\n  Suc i \\<le> zs ! j \\<Longrightarrow> xs ! (zs ! j - Suc i) = Some j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length zs \\<Longrightarrow>\n       zs ! j < length xs + Suc i \\<and>\n       (Suc i \\<le> zs ! j \\<longrightarrow> xs ! (zs ! j - Suc i) = Some j)", "with G1"], ["proof (chain)\npicking this:\n  zs ! j < length xs + Suc i\n  Suc i \\<le> zs ! j \\<Longrightarrow> xs ! (zs ! j - Suc i) = Some j", "show \"zs ! j < length xs + Suc i \\<and> (Suc i \\<le> zs ! j \\<longrightarrow> xs ! (zs ! j - Suc i) = Some j)\""], ["proof (prove)\nusing this:\n  zs ! j < length xs + Suc i\n  Suc i \\<le> zs ! j \\<Longrightarrow> xs ! (zs ! j - Suc i) = Some j\n\ngoal (1 subgoal):\n 1. zs ! j < length xs + Suc i \\<and>\n    (Suc i \\<le> zs ! j \\<longrightarrow> xs ! (zs ! j - Suc i) = Some j)", "by simp"], ["proof (state)\nthis:\n  zs ! j < length xs + Suc i \\<and>\n  (Suc i \\<le> zs ! j \\<longrightarrow> xs ! (zs ! j - Suc i) = Some j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?j < length zs \\<Longrightarrow>\n  zs ! ?j < length xs + Suc i \\<and>\n  (Suc i \\<le> zs ! ?j \\<longrightarrow> xs ! (zs ! ?j - Suc i) = Some ?j)\n\ngoal (1 subgoal):\n 1. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "moreover"], ["proof (state)\nthis:\n  ?j < length zs \\<Longrightarrow>\n  zs ! ?j < length xs + Suc i \\<and>\n  (Suc i \\<le> zs ! ?j \\<longrightarrow> xs ! (zs ! ?j - Suc i) = Some ?j)\n\ngoal (1 subgoal):\n 1. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "note 3(3)"], ["proof (state)\nthis:\n  \\<lbrakk>?j1.0 < ?j2.0; ?j2.0 < length zs\\<rbrakk>\n  \\<Longrightarrow> zs ! ?j1.0 < zs ! ?j2.0\n\ngoal (1 subgoal):\n 1. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?j1.0 < ?j2.0; ?j2.0 < length zs\\<rbrakk>\n  \\<Longrightarrow> zs ! ?j1.0 < zs ! ?j2.0\n\ngoal (1 subgoal):\n 1. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "have \"\\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i", "assume \"z \\<in> set zs\""], ["proof (state)\nthis:\n  z \\<in> set zs\n\ngoal (1 subgoal):\n 1. \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i", "with 3(4)[of z]"], ["proof (chain)\npicking this:\n  z \\<in> set zs \\<Longrightarrow> z < i\n  z \\<in> set zs", "show \"z < Suc i\""], ["proof (prove)\nusing this:\n  z \\<in> set zs \\<Longrightarrow> z < i\n  z \\<in> set zs\n\ngoal (1 subgoal):\n 1. z < Suc i", "by simp"], ["proof (state)\nthis:\n  z < Suc i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?z \\<in> set zs \\<Longrightarrow> ?z < Suc i\n\ngoal (1 subgoal):\n 1. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "moreover"], ["proof (state)\nthis:\n  ?z \\<in> set zs \\<Longrightarrow> ?z < Suc i\n\ngoal (1 subgoal):\n 1. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "from 3(5) 1"], ["proof (chain)\npicking this:\n  j < length (snd (mk_eqcl (Some l # xs) zs i T))\n  snd (mk_eqcl (Some l # xs) zs i T) = snd (mk_eqcl xs zs (Suc i) T)", "have \"j < length (snd (mk_eqcl xs zs (Suc i) T))\""], ["proof (prove)\nusing this:\n  j < length (snd (mk_eqcl (Some l # xs) zs i T))\n  snd (mk_eqcl (Some l # xs) zs i T) = snd (mk_eqcl xs zs (Suc i) T)\n\ngoal (1 subgoal):\n 1. j < length (snd (mk_eqcl xs zs (Suc i) T))", "by simp"], ["proof (state)\nthis:\n  j < length (snd (mk_eqcl xs zs (Suc i) T))\n\ngoal (1 subgoal):\n 1. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "moreover"], ["proof (state)\nthis:\n  j < length (snd (mk_eqcl xs zs (Suc i) T))\n\ngoal (1 subgoal):\n 1. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "from 3"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>i.\n              i < length zs \\<Longrightarrow>\n              zs ! i < length xs + Suc i \\<and>\n              (Suc i \\<le> zs ! i \\<longrightarrow>\n               xs ! (zs ! i - Suc i) = Some i);\n   \\<And>j1 j2.\n      \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n      \\<Longrightarrow> zs ! j1 < zs ! j2;\n   \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n   ?i < length (snd (mk_eqcl xs zs (Suc i) T));\n   length xs + Suc i \\<le> length T + 1\\<rbrakk>\n  \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ?i\n                    < length (fst (mk_eqcl xs zs (Suc i) T)) + Suc i \\<and>\n                    (Suc i\n                     \\<le> snd (mk_eqcl xs zs (Suc i) T) !\n                           ?i \\<longrightarrow>\n                     fst (mk_eqcl xs zs (Suc i) T) !\n                     (snd (mk_eqcl xs zs (Suc i) T) ! ?i - Suc i) =\n                     ?i)\n  ?i < length zs \\<Longrightarrow>\n  zs ! ?i < length (Some l # xs) + i \\<and>\n  (i \\<le> zs ! ?i \\<longrightarrow>\n   (Some l # xs) ! (zs ! ?i - i) = Some ?i)\n  \\<lbrakk>?j1.0 < ?j2.0; ?j2.0 < length zs\\<rbrakk>\n  \\<Longrightarrow> zs ! ?j1.0 < zs ! ?j2.0\n  ?z \\<in> set zs \\<Longrightarrow> ?z < i\n  j < length (snd (mk_eqcl (Some l # xs) zs i T))\n  length (Some l # xs) + i \\<le> length T + 1", "have \"length xs + Suc i \\<le> length T + 1\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>i.\n              i < length zs \\<Longrightarrow>\n              zs ! i < length xs + Suc i \\<and>\n              (Suc i \\<le> zs ! i \\<longrightarrow>\n               xs ! (zs ! i - Suc i) = Some i);\n   \\<And>j1 j2.\n      \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n      \\<Longrightarrow> zs ! j1 < zs ! j2;\n   \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n   ?i < length (snd (mk_eqcl xs zs (Suc i) T));\n   length xs + Suc i \\<le> length T + 1\\<rbrakk>\n  \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ?i\n                    < length (fst (mk_eqcl xs zs (Suc i) T)) + Suc i \\<and>\n                    (Suc i\n                     \\<le> snd (mk_eqcl xs zs (Suc i) T) !\n                           ?i \\<longrightarrow>\n                     fst (mk_eqcl xs zs (Suc i) T) !\n                     (snd (mk_eqcl xs zs (Suc i) T) ! ?i - Suc i) =\n                     ?i)\n  ?i < length zs \\<Longrightarrow>\n  zs ! ?i < length (Some l # xs) + i \\<and>\n  (i \\<le> zs ! ?i \\<longrightarrow>\n   (Some l # xs) ! (zs ! ?i - i) = Some ?i)\n  \\<lbrakk>?j1.0 < ?j2.0; ?j2.0 < length zs\\<rbrakk>\n  \\<Longrightarrow> zs ! ?j1.0 < zs ! ?j2.0\n  ?z \\<in> set zs \\<Longrightarrow> ?z < i\n  j < length (snd (mk_eqcl (Some l # xs) zs i T))\n  length (Some l # xs) + i \\<le> length T + 1\n\ngoal (1 subgoal):\n 1. length xs + Suc i \\<le> length T + 1", "by simp"], ["proof (state)\nthis:\n  length xs + Suc i \\<le> length T + 1\n\ngoal (1 subgoal):\n 1. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "ultimately"], ["proof (chain)\npicking this:\n  ?j < length zs \\<Longrightarrow>\n  zs ! ?j < length xs + Suc i \\<and>\n  (Suc i \\<le> zs ! ?j \\<longrightarrow> xs ! (zs ! ?j - Suc i) = Some ?j)\n  \\<lbrakk>?j1.0 < ?j2.0; ?j2.0 < length zs\\<rbrakk>\n  \\<Longrightarrow> zs ! ?j1.0 < zs ! ?j2.0\n  ?z \\<in> set zs \\<Longrightarrow> ?z < Suc i\n  j < length (snd (mk_eqcl xs zs (Suc i) T))\n  length xs + Suc i \\<le> length T + 1", "have IV: \"snd (mk_eqcl xs zs (Suc i) T) ! j < length (fst (mk_eqcl xs zs (Suc i) T)) + Suc i \\<and>\n    (Suc i \\<le> snd (mk_eqcl xs zs (Suc i) T) ! j \\<longrightarrow> fst (mk_eqcl xs zs (Suc i) T) ! (snd (mk_eqcl xs zs (Suc i) T) ! j - Suc i) = j)\""], ["proof (prove)\nusing this:\n  ?j < length zs \\<Longrightarrow>\n  zs ! ?j < length xs + Suc i \\<and>\n  (Suc i \\<le> zs ! ?j \\<longrightarrow> xs ! (zs ! ?j - Suc i) = Some ?j)\n  \\<lbrakk>?j1.0 < ?j2.0; ?j2.0 < length zs\\<rbrakk>\n  \\<Longrightarrow> zs ! ?j1.0 < zs ! ?j2.0\n  ?z \\<in> set zs \\<Longrightarrow> ?z < Suc i\n  j < length (snd (mk_eqcl xs zs (Suc i) T))\n  length xs + Suc i \\<le> length T + 1\n\ngoal (1 subgoal):\n 1. snd (mk_eqcl xs zs (Suc i) T) ! j\n    < length (fst (mk_eqcl xs zs (Suc i) T)) + Suc i \\<and>\n    (Suc i \\<le> snd (mk_eqcl xs zs (Suc i) T) ! j \\<longrightarrow>\n     fst (mk_eqcl xs zs (Suc i) T) !\n     (snd (mk_eqcl xs zs (Suc i) T) ! j - Suc i) =\n     j)", "by (rule 3(1))"], ["proof (state)\nthis:\n  snd (mk_eqcl xs zs (Suc i) T) ! j\n  < length (fst (mk_eqcl xs zs (Suc i) T)) + Suc i \\<and>\n  (Suc i \\<le> snd (mk_eqcl xs zs (Suc i) T) ! j \\<longrightarrow>\n   fst (mk_eqcl xs zs (Suc i) T) !\n   (snd (mk_eqcl xs zs (Suc i) T) ! j - Suc i) =\n   j)\n\ngoal (1 subgoal):\n 1. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "with 1"], ["proof (chain)\npicking this:\n  snd (mk_eqcl (Some l # xs) zs i T) = snd (mk_eqcl xs zs (Suc i) T)\n  snd (mk_eqcl xs zs (Suc i) T) ! j\n  < length (fst (mk_eqcl xs zs (Suc i) T)) + Suc i \\<and>\n  (Suc i \\<le> snd (mk_eqcl xs zs (Suc i) T) ! j \\<longrightarrow>\n   fst (mk_eqcl xs zs (Suc i) T) !\n   (snd (mk_eqcl xs zs (Suc i) T) ! j - Suc i) =\n   j)", "have G1: \"snd (mk_eqcl (Some l # xs) zs i T) ! j < length (fst (mk_eqcl (Some l # xs) zs i T)) + i\""], ["proof (prove)\nusing this:\n  snd (mk_eqcl (Some l # xs) zs i T) = snd (mk_eqcl xs zs (Suc i) T)\n  snd (mk_eqcl xs zs (Suc i) T) ! j\n  < length (fst (mk_eqcl xs zs (Suc i) T)) + Suc i \\<and>\n  (Suc i \\<le> snd (mk_eqcl xs zs (Suc i) T) ! j \\<longrightarrow>\n   fst (mk_eqcl xs zs (Suc i) T) !\n   (snd (mk_eqcl xs zs (Suc i) T) ! j - Suc i) =\n   j)\n\ngoal (1 subgoal):\n 1. snd (mk_eqcl (Some l # xs) zs i T) ! j\n    < length (fst (mk_eqcl (Some l # xs) zs i T)) + i", "by (simp add: split_beta mk_eqcl_len_fst)"], ["proof (state)\nthis:\n  snd (mk_eqcl (Some l # xs) zs i T) ! j\n  < length (fst (mk_eqcl (Some l # xs) zs i T)) + i\n\ngoal (1 subgoal):\n 1. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "{"], ["proof (state)\nthis:\n  snd (mk_eqcl (Some l # xs) zs i T) ! j\n  < length (fst (mk_eqcl (Some l # xs) zs i T)) + i\n\ngoal (1 subgoal):\n 1. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "assume \"i \\<le> snd (mk_eqcl (Some l # xs) zs i T) ! j\""], ["proof (state)\nthis:\n  i \\<le> snd (mk_eqcl (Some l # xs) zs i T) ! j\n\ngoal (1 subgoal):\n 1. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "hence \"i = snd (mk_eqcl (Some l # xs) zs i T) ! j \\<or> i < snd (mk_eqcl (Some l # xs) zs i T) ! j\""], ["proof (prove)\nusing this:\n  i \\<le> snd (mk_eqcl (Some l # xs) zs i T) ! j\n\ngoal (1 subgoal):\n 1. i = snd (mk_eqcl (Some l # xs) zs i T) ! j \\<or>\n    i < snd (mk_eqcl (Some l # xs) zs i T) ! j", "by auto"], ["proof (state)\nthis:\n  i = snd (mk_eqcl (Some l # xs) zs i T) ! j \\<or>\n  i < snd (mk_eqcl (Some l # xs) zs i T) ! j\n\ngoal (1 subgoal):\n 1. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "hence \"fst (mk_eqcl (Some l # xs) zs i T) ! (snd (mk_eqcl (Some l # xs) zs i T) ! j - i) = j\""], ["proof (prove)\nusing this:\n  i = snd (mk_eqcl (Some l # xs) zs i T) ! j \\<or>\n  i < snd (mk_eqcl (Some l # xs) zs i T) ! j\n\ngoal (1 subgoal):\n 1. fst (mk_eqcl (Some l # xs) zs i T) !\n    (snd (mk_eqcl (Some l # xs) zs i T) ! j - i) =\n    j", "proof (elim disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = snd (mk_eqcl (Some l # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (Some l # xs) zs i T) !\n    (snd (mk_eqcl (Some l # xs) zs i T) ! j - i) =\n    j\n 2. i < snd (mk_eqcl (Some l # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (Some l # xs) zs i T) !\n    (snd (mk_eqcl (Some l # xs) zs i T) ! j - i) =\n    j", "assume H: \"i = snd (mk_eqcl (Some l # xs) zs i T) ! j\""], ["proof (state)\nthis:\n  i = snd (mk_eqcl (Some l # xs) zs i T) ! j\n\ngoal (2 subgoals):\n 1. i = snd (mk_eqcl (Some l # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (Some l # xs) zs i T) !\n    (snd (mk_eqcl (Some l # xs) zs i T) ! j - i) =\n    j\n 2. i < snd (mk_eqcl (Some l # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (Some l # xs) zs i T) !\n    (snd (mk_eqcl (Some l # xs) zs i T) ! j - i) =\n    j", "with 3 1"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>i.\n              i < length zs \\<Longrightarrow>\n              zs ! i < length xs + Suc i \\<and>\n              (Suc i \\<le> zs ! i \\<longrightarrow>\n               xs ! (zs ! i - Suc i) = Some i);\n   \\<And>j1 j2.\n      \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n      \\<Longrightarrow> zs ! j1 < zs ! j2;\n   \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n   ?i < length (snd (mk_eqcl xs zs (Suc i) T));\n   length xs + Suc i \\<le> length T + 1\\<rbrakk>\n  \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ?i\n                    < length (fst (mk_eqcl xs zs (Suc i) T)) + Suc i \\<and>\n                    (Suc i\n                     \\<le> snd (mk_eqcl xs zs (Suc i) T) !\n                           ?i \\<longrightarrow>\n                     fst (mk_eqcl xs zs (Suc i) T) !\n                     (snd (mk_eqcl xs zs (Suc i) T) ! ?i - Suc i) =\n                     ?i)\n  ?i < length zs \\<Longrightarrow>\n  zs ! ?i < length (Some l # xs) + i \\<and>\n  (i \\<le> zs ! ?i \\<longrightarrow>\n   (Some l # xs) ! (zs ! ?i - i) = Some ?i)\n  \\<lbrakk>?j1.0 < ?j2.0; ?j2.0 < length zs\\<rbrakk>\n  \\<Longrightarrow> zs ! ?j1.0 < zs ! ?j2.0\n  ?z \\<in> set zs \\<Longrightarrow> ?z < i\n  j < length (snd (mk_eqcl (Some l # xs) zs i T))\n  length (Some l # xs) + i \\<le> length T + 1\n  snd (mk_eqcl (Some l # xs) zs i T) = snd (mk_eqcl xs zs (Suc i) T)\n  i = snd (mk_eqcl (Some l # xs) zs i T) ! j", "have \"\\<exists>j < length (snd (mk_eqcl xs zs (Suc i) T)). snd (mk_eqcl xs zs (Suc i) T) ! j = i\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>i.\n              i < length zs \\<Longrightarrow>\n              zs ! i < length xs + Suc i \\<and>\n              (Suc i \\<le> zs ! i \\<longrightarrow>\n               xs ! (zs ! i - Suc i) = Some i);\n   \\<And>j1 j2.\n      \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n      \\<Longrightarrow> zs ! j1 < zs ! j2;\n   \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n   ?i < length (snd (mk_eqcl xs zs (Suc i) T));\n   length xs + Suc i \\<le> length T + 1\\<rbrakk>\n  \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ?i\n                    < length (fst (mk_eqcl xs zs (Suc i) T)) + Suc i \\<and>\n                    (Suc i\n                     \\<le> snd (mk_eqcl xs zs (Suc i) T) !\n                           ?i \\<longrightarrow>\n                     fst (mk_eqcl xs zs (Suc i) T) !\n                     (snd (mk_eqcl xs zs (Suc i) T) ! ?i - Suc i) =\n                     ?i)\n  ?i < length zs \\<Longrightarrow>\n  zs ! ?i < length (Some l # xs) + i \\<and>\n  (i \\<le> zs ! ?i \\<longrightarrow>\n   (Some l # xs) ! (zs ! ?i - i) = Some ?i)\n  \\<lbrakk>?j1.0 < ?j2.0; ?j2.0 < length zs\\<rbrakk>\n  \\<Longrightarrow> zs ! ?j1.0 < zs ! ?j2.0\n  ?z \\<in> set zs \\<Longrightarrow> ?z < i\n  j < length (snd (mk_eqcl (Some l # xs) zs i T))\n  length (Some l # xs) + i \\<le> length T + 1\n  snd (mk_eqcl (Some l # xs) zs i T) = snd (mk_eqcl xs zs (Suc i) T)\n  i = snd (mk_eqcl (Some l # xs) zs i T) ! j\n\ngoal (1 subgoal):\n 1. \\<exists>j<length (snd (mk_eqcl xs zs (Suc i) T)).\n       snd (mk_eqcl xs zs (Suc i) T) ! j = i", "by auto"], ["proof (state)\nthis:\n  \\<exists>j<length (snd (mk_eqcl xs zs (Suc i) T)).\n     snd (mk_eqcl xs zs (Suc i) T) ! j = i\n\ngoal (2 subgoals):\n 1. i = snd (mk_eqcl (Some l # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (Some l # xs) zs i T) !\n    (snd (mk_eqcl (Some l # xs) zs i T) ! j - i) =\n    j\n 2. i < snd (mk_eqcl (Some l # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (Some l # xs) zs i T) !\n    (snd (mk_eqcl (Some l # xs) zs i T) ! j - i) =\n    j", "hence T1: \"i \\<in> set (snd (mk_eqcl xs zs (Suc i) T))\""], ["proof (prove)\nusing this:\n  \\<exists>j<length (snd (mk_eqcl xs zs (Suc i) T)).\n     snd (mk_eqcl xs zs (Suc i) T) ! j = i\n\ngoal (1 subgoal):\n 1. i \\<in> set (snd (mk_eqcl xs zs (Suc i) T))", "by (simp only: in_set_conv_nth)"], ["proof (state)\nthis:\n  i \\<in> set (snd (mk_eqcl xs zs (Suc i) T))\n\ngoal (2 subgoals):\n 1. i = snd (mk_eqcl (Some l # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (Some l # xs) zs i T) !\n    (snd (mk_eqcl (Some l # xs) zs i T) ! j - i) =\n    j\n 2. i < snd (mk_eqcl (Some l # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (Some l # xs) zs i T) !\n    (snd (mk_eqcl (Some l # xs) zs i T) ! j - i) =\n    j", "from 3(4)"], ["proof (chain)\npicking this:\n  ?z \\<in> set zs \\<Longrightarrow> ?z < i", "have \"i \\<notin> set zs\""], ["proof (prove)\nusing this:\n  ?z \\<in> set zs \\<Longrightarrow> ?z < i\n\ngoal (1 subgoal):\n 1. i \\<notin> set zs", "by auto"], ["proof (state)\nthis:\n  i \\<notin> set zs\n\ngoal (2 subgoals):\n 1. i = snd (mk_eqcl (Some l # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (Some l # xs) zs i T) !\n    (snd (mk_eqcl (Some l # xs) zs i T) ! j - i) =\n    j\n 2. i < snd (mk_eqcl (Some l # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (Some l # xs) zs i T) !\n    (snd (mk_eqcl (Some l # xs) zs i T) ! j - i) =\n    j", "hence \"i \\<notin> set (snd (mk_eqcl xs zs (Suc i) T))\""], ["proof (prove)\nusing this:\n  i \\<notin> set zs\n\ngoal (1 subgoal):\n 1. i \\<notin> set (snd (mk_eqcl xs zs (Suc i) T))", "by (simp add: mk_eqcl_set_snd)"], ["proof (state)\nthis:\n  i \\<notin> set (snd (mk_eqcl xs zs (Suc i) T))\n\ngoal (2 subgoals):\n 1. i = snd (mk_eqcl (Some l # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (Some l # xs) zs i T) !\n    (snd (mk_eqcl (Some l # xs) zs i T) ! j - i) =\n    j\n 2. i < snd (mk_eqcl (Some l # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (Some l # xs) zs i T) !\n    (snd (mk_eqcl (Some l # xs) zs i T) ! j - i) =\n    j", "with T1"], ["proof (chain)\npicking this:\n  i \\<in> set (snd (mk_eqcl xs zs (Suc i) T))\n  i \\<notin> set (snd (mk_eqcl xs zs (Suc i) T))", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<in> set (snd (mk_eqcl xs zs (Suc i) T))\n  i \\<notin> set (snd (mk_eqcl xs zs (Suc i) T))\n\ngoal (1 subgoal):\n 1. fst (mk_eqcl (Some l # xs) zs i T) !\n    (snd (mk_eqcl (Some l # xs) zs i T) ! j - i) =\n    j", "by simp"], ["proof (state)\nthis:\n  fst (mk_eqcl (Some l # xs) zs i T) !\n  (snd (mk_eqcl (Some l # xs) zs i T) ! j - i) =\n  j\n\ngoal (1 subgoal):\n 1. i < snd (mk_eqcl (Some l # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (Some l # xs) zs i T) !\n    (snd (mk_eqcl (Some l # xs) zs i T) ! j - i) =\n    j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i < snd (mk_eqcl (Some l # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (Some l # xs) zs i T) !\n    (snd (mk_eqcl (Some l # xs) zs i T) ! j - i) =\n    j", "assume H: \"i < snd (mk_eqcl (Some l # xs) zs i T) ! j\""], ["proof (state)\nthis:\n  i < snd (mk_eqcl (Some l # xs) zs i T) ! j\n\ngoal (1 subgoal):\n 1. i < snd (mk_eqcl (Some l # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (Some l # xs) zs i T) !\n    (snd (mk_eqcl (Some l # xs) zs i T) ! j - i) =\n    j", "from H"], ["proof (chain)\npicking this:\n  i < snd (mk_eqcl (Some l # xs) zs i T) ! j", "obtain k where K: \"snd (mk_eqcl (Some l # xs) zs i T) ! j - i = Suc k\""], ["proof (prove)\nusing this:\n  i < snd (mk_eqcl (Some l # xs) zs i T) ! j\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        snd (mk_eqcl (Some l # xs) zs i T) ! j - i = Suc k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"snd (mk_eqcl (Some l # xs) zs i T) ! j - i\") simp+"], ["proof (state)\nthis:\n  snd (mk_eqcl (Some l # xs) zs i T) ! j - i = Suc k\n\ngoal (1 subgoal):\n 1. i < snd (mk_eqcl (Some l # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (Some l # xs) zs i T) !\n    (snd (mk_eqcl (Some l # xs) zs i T) ! j - i) =\n    j", "hence K': \"snd (mk_eqcl (Some l # xs) zs i T) ! j - Suc i = k\""], ["proof (prove)\nusing this:\n  snd (mk_eqcl (Some l # xs) zs i T) ! j - i = Suc k\n\ngoal (1 subgoal):\n 1. snd (mk_eqcl (Some l # xs) zs i T) ! j - Suc i = k", "by simp"], ["proof (state)\nthis:\n  snd (mk_eqcl (Some l # xs) zs i T) ! j - Suc i = k\n\ngoal (1 subgoal):\n 1. i < snd (mk_eqcl (Some l # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (Some l # xs) zs i T) !\n    (snd (mk_eqcl (Some l # xs) zs i T) ! j - i) =\n    j", "from 1 H IV"], ["proof (chain)\npicking this:\n  snd (mk_eqcl (Some l # xs) zs i T) = snd (mk_eqcl xs zs (Suc i) T)\n  i < snd (mk_eqcl (Some l # xs) zs i T) ! j\n  snd (mk_eqcl xs zs (Suc i) T) ! j\n  < length (fst (mk_eqcl xs zs (Suc i) T)) + Suc i \\<and>\n  (Suc i \\<le> snd (mk_eqcl xs zs (Suc i) T) ! j \\<longrightarrow>\n   fst (mk_eqcl xs zs (Suc i) T) !\n   (snd (mk_eqcl xs zs (Suc i) T) ! j - Suc i) =\n   j)", "have \"fst (mk_eqcl xs zs (Suc i) T) ! (snd (mk_eqcl xs zs (Suc i) T) ! j - Suc i) = j\""], ["proof (prove)\nusing this:\n  snd (mk_eqcl (Some l # xs) zs i T) = snd (mk_eqcl xs zs (Suc i) T)\n  i < snd (mk_eqcl (Some l # xs) zs i T) ! j\n  snd (mk_eqcl xs zs (Suc i) T) ! j\n  < length (fst (mk_eqcl xs zs (Suc i) T)) + Suc i \\<and>\n  (Suc i \\<le> snd (mk_eqcl xs zs (Suc i) T) ! j \\<longrightarrow>\n   fst (mk_eqcl xs zs (Suc i) T) !\n   (snd (mk_eqcl xs zs (Suc i) T) ! j - Suc i) =\n   j)\n\ngoal (1 subgoal):\n 1. fst (mk_eqcl xs zs (Suc i) T) !\n    (snd (mk_eqcl xs zs (Suc i) T) ! j - Suc i) =\n    j", "by simp"], ["proof (state)\nthis:\n  fst (mk_eqcl xs zs (Suc i) T) !\n  (snd (mk_eqcl xs zs (Suc i) T) ! j - Suc i) =\n  j\n\ngoal (1 subgoal):\n 1. i < snd (mk_eqcl (Some l # xs) zs i T) ! j \\<Longrightarrow>\n    fst (mk_eqcl (Some l # xs) zs i T) !\n    (snd (mk_eqcl (Some l # xs) zs i T) ! j - i) =\n    j", "with K K'"], ["proof (chain)\npicking this:\n  snd (mk_eqcl (Some l # xs) zs i T) ! j - i = Suc k\n  snd (mk_eqcl (Some l # xs) zs i T) ! j - Suc i = k\n  fst (mk_eqcl xs zs (Suc i) T) !\n  (snd (mk_eqcl xs zs (Suc i) T) ! j - Suc i) =\n  j", "show ?thesis"], ["proof (prove)\nusing this:\n  snd (mk_eqcl (Some l # xs) zs i T) ! j - i = Suc k\n  snd (mk_eqcl (Some l # xs) zs i T) ! j - Suc i = k\n  fst (mk_eqcl xs zs (Suc i) T) !\n  (snd (mk_eqcl xs zs (Suc i) T) ! j - Suc i) =\n  j\n\ngoal (1 subgoal):\n 1. fst (mk_eqcl (Some l # xs) zs i T) !\n    (snd (mk_eqcl (Some l # xs) zs i T) ! j - i) =\n    j", "by (simp add: split_beta)"], ["proof (state)\nthis:\n  fst (mk_eqcl (Some l # xs) zs i T) !\n  (snd (mk_eqcl (Some l # xs) zs i T) ! j - i) =\n  j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst (mk_eqcl (Some l # xs) zs i T) !\n  (snd (mk_eqcl (Some l # xs) zs i T) ! j - i) =\n  j\n\ngoal (1 subgoal):\n 1. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "}"], ["proof (state)\nthis:\n  i \\<le> snd (mk_eqcl (Some l # xs) zs i T) ! j \\<Longrightarrow>\n  fst (mk_eqcl (Some l # xs) zs i T) !\n  (snd (mk_eqcl (Some l # xs) zs i T) ! j - i) =\n  j\n\ngoal (1 subgoal):\n 1. \\<And>l xs zs i T ia.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>\\<And>ia.\n                               ia < length zs \\<Longrightarrow>\n                               zs ! ia < length xs + Suc i \\<and>\n                               (Suc i \\<le> zs ! ia \\<longrightarrow>\n                                xs ! (zs ! ia - Suc i) = Some ia);\n                    \\<And>j1 j2.\n                       \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n                       \\<Longrightarrow> zs ! j1 < zs ! j2;\n                    \\<And>z. z \\<in> set zs \\<Longrightarrow> z < Suc i;\n                    ia < length (snd (mk_eqcl xs zs (Suc i) T));\n                    length xs + Suc i \\<le> length T + 1\\<rbrakk>\n                   \\<Longrightarrow> snd (mk_eqcl xs zs (Suc i) T) ! ia\n                                     < length\n  (fst (mk_eqcl xs zs (Suc i) T)) +\n Suc i \\<and>\n                                     (Suc i\n\\<le> snd (mk_eqcl xs zs (Suc i) T) ! ia \\<longrightarrow>\nfst (mk_eqcl xs zs (Suc i) T) !\n(snd (mk_eqcl xs zs (Suc i) T) ! ia - Suc i) =\nia);\n        \\<And>ia.\n           ia < length zs \\<Longrightarrow>\n           zs ! ia < length (Some l # xs) + i \\<and>\n           (i \\<le> zs ! ia \\<longrightarrow>\n            (Some l # xs) ! (zs ! ia - i) = Some ia);\n        \\<And>j1 j2.\n           \\<lbrakk>j1 < j2; j2 < length zs\\<rbrakk>\n           \\<Longrightarrow> zs ! j1 < zs ! j2;\n        \\<And>z. z \\<in> set zs \\<Longrightarrow> z < i;\n        ia < length (snd (mk_eqcl (Some l # xs) zs i T));\n        length (Some l # xs) + i \\<le> length T + 1\\<rbrakk>\n       \\<Longrightarrow> snd (mk_eqcl (Some l # xs) zs i T) ! ia\n                         < length (fst (mk_eqcl (Some l # xs) zs i T)) +\n                           i \\<and>\n                         (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) !\n                                  ia \\<longrightarrow>\n                          fst (mk_eqcl (Some l # xs) zs i T) !\n                          (snd (mk_eqcl (Some l # xs) zs i T) ! ia - i) =\n                          ia)", "with G1"], ["proof (chain)\npicking this:\n  snd (mk_eqcl (Some l # xs) zs i T) ! j\n  < length (fst (mk_eqcl (Some l # xs) zs i T)) + i\n  i \\<le> snd (mk_eqcl (Some l # xs) zs i T) ! j \\<Longrightarrow>\n  fst (mk_eqcl (Some l # xs) zs i T) !\n  (snd (mk_eqcl (Some l # xs) zs i T) ! j - i) =\n  j", "show ?case"], ["proof (prove)\nusing this:\n  snd (mk_eqcl (Some l # xs) zs i T) ! j\n  < length (fst (mk_eqcl (Some l # xs) zs i T)) + i\n  i \\<le> snd (mk_eqcl (Some l # xs) zs i T) ! j \\<Longrightarrow>\n  fst (mk_eqcl (Some l # xs) zs i T) !\n  (snd (mk_eqcl (Some l # xs) zs i T) ! j - i) =\n  j\n\ngoal (1 subgoal):\n 1. snd (mk_eqcl (Some l # xs) zs i T) ! j\n    < length (fst (mk_eqcl (Some l # xs) zs i T)) + i \\<and>\n    (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) ! j \\<longrightarrow>\n     fst (mk_eqcl (Some l # xs) zs i T) !\n     (snd (mk_eqcl (Some l # xs) zs i T) ! j - i) =\n     j)", "by simp"], ["proof (state)\nthis:\n  snd (mk_eqcl (Some l # xs) zs i T) ! j\n  < length (fst (mk_eqcl (Some l # xs) zs i T)) + i \\<and>\n  (i \\<le> snd (mk_eqcl (Some l # xs) zs i T) ! j \\<longrightarrow>\n   fst (mk_eqcl (Some l # xs) zs i T) !\n   (snd (mk_eqcl (Some l # xs) zs i T) ! j - i) =\n   j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mk_eqcl_fst_nth:\n  assumes \"\\<And>i j k. \\<lbrakk>i < length xs; j < length xs; xs ! i = Some k\\<rbrakk> \\<Longrightarrow> (xs ! j = Some k) = (\\<not> tr_lookup T (i + ii) (j + ii))\"\n  and \"\\<And>a b c. \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T; \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk> \\<Longrightarrow> \\<not> tr_lookup T a c\"\n  and \"\\<And>x k. \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk> \\<Longrightarrow> k < length zs\"\n  and \"length xs + ii = length T + 1\"\n  and \"i < length xs\" and \"j < length xs\"\n  shows \"(fst (mk_eqcl xs zs ii T) ! i = fst (mk_eqcl xs zs ii T) ! j) = (\\<not> tr_lookup T (i + ii) (j + ii))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst (mk_eqcl xs zs ii T) ! i = fst (mk_eqcl xs zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < length xs; ?j < length xs; xs ! ?i = Some ?k\\<rbrakk>\n  \\<Longrightarrow> (xs ! ?j = Some ?k) =\n                    (\\<not> tr_lookup T (?i + ii) (?j + ii))\n  \\<lbrakk>?a \\<le> length T; ?b \\<le> length T; ?c \\<le> length T;\n   \\<not> tr_lookup T ?a ?b; \\<not> tr_lookup T ?b ?c\\<rbrakk>\n  \\<Longrightarrow> \\<not> tr_lookup T ?a ?c\n  \\<lbrakk>?x \\<in> set xs; ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length zs\n  length xs + ii = length T + 1\n  i < length xs\n  j < length xs\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl xs zs ii T) ! i = fst (mk_eqcl xs zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))", "proof (induct xs zs ii T arbitrary: i j rule: mk_eqcl.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>zs i T ia j.\n       \\<lbrakk>\\<And>ia j k.\n                   \\<lbrakk>ia < length []; j < length [];\n                    [] ! ia = Some k\\<rbrakk>\n                   \\<Longrightarrow> ([] ! j = Some k) =\n                                     (\\<not> tr_lookup T (ia + i) (j + i));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set []; x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        length [] + i = length T + 1; ia < length []; j < length []\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl [] zs i T) ! ia =\n                          fst (mk_eqcl [] zs i T) ! j) =\n                         (\\<not> tr_lookup T (ia + i) (j + i))\n 2. \\<And>xs zs i T ia j.\n       \\<lbrakk>\\<And>ia j.\n                   \\<lbrakk>\\<And>ia j k.\n                               \\<lbrakk>ia\n  < length (mk_eqcl' xs i (Suc i) (length zs) T);\n                                j < length\n                                     (mk_eqcl' xs i (Suc i) (length zs) T);\n                                mk_eqcl' xs i (Suc i) (length zs) T ! ia =\n                                Some k\\<rbrakk>\n                               \\<Longrightarrow> (mk_eqcl' xs i (Suc i)\n             (length zs) T !\n            j =\n            Some k) =\n           (\\<not> tr_lookup T (ia + Suc i) (j + Suc i));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set\n   (mk_eqcl' xs i (Suc i) (length zs) T);\n                        x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < length (zs @ [i]);\n                    length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i =\n                    length T + 1;\n                    ia < length (mk_eqcl' xs i (Suc i) (length zs) T);\n                    j < length\n                         (mk_eqcl' xs i (Suc i) (length zs) T)\\<rbrakk>\n                   \\<Longrightarrow> (fst\n (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\nia =\nfst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\nj) =\n                                     (\\<not> tr_lookup T (ia + Suc i)\n        (j + Suc i));\n        \\<And>ia j k.\n           \\<lbrakk>ia < length (None # xs); j < length (None # xs);\n            (None # xs) ! ia = Some k\\<rbrakk>\n           \\<Longrightarrow> ((None # xs) ! j = Some k) =\n                             (\\<not> tr_lookup T (ia + i) (j + i));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (None # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        length (None # xs) + i = length T + 1; ia < length (None # xs);\n        j < length (None # xs)\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (None # xs) zs i T) ! ia =\n                          fst (mk_eqcl (None # xs) zs i T) ! j) =\n                         (\\<not> tr_lookup T (ia + i) (j + i))\n 3. \\<And>l xs zs i T ia j.\n       \\<lbrakk>\\<And>ia j.\n                   \\<lbrakk>\\<And>ia j k.\n                               \\<lbrakk>ia < length xs; j < length xs;\n                                xs ! ia = Some k\\<rbrakk>\n                               \\<Longrightarrow> (xs ! j = Some k) =\n           (\\<not> tr_lookup T (ia + Suc i) (j + Suc i));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < length zs;\n                    length xs + Suc i = length T + 1; ia < length xs;\n                    j < length xs\\<rbrakk>\n                   \\<Longrightarrow> (fst (mk_eqcl xs zs (Suc i) T) ! ia =\nfst (mk_eqcl xs zs (Suc i) T) ! j) =\n                                     (\\<not> tr_lookup T (ia + Suc i)\n        (j + Suc i));\n        \\<And>ia j k.\n           \\<lbrakk>ia < length (Some l # xs); j < length (Some l # xs);\n            (Some l # xs) ! ia = Some k\\<rbrakk>\n           \\<Longrightarrow> ((Some l # xs) ! j = Some k) =\n                             (\\<not> tr_lookup T (ia + i) (j + i));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (Some l # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        length (Some l # xs) + i = length T + 1; ia < length (Some l # xs);\n        j < length (Some l # xs)\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (Some l # xs) zs i T) ! ia =\n                          fst (mk_eqcl (Some l # xs) zs i T) ! j) =\n                         (\\<not> tr_lookup T (ia + i) (j + i))", "case (1 zs ii T)"], ["proof (state)\nthis:\n  \\<lbrakk>?i < length []; ?j < length []; [] ! ?i = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ([] ! ?j = Some ?k) =\n                    (\\<not> tr_lookup T (?i + ii) (?j + ii))\n  \\<lbrakk>?a \\<le> length T; ?b \\<le> length T; ?c \\<le> length T;\n   \\<not> tr_lookup T ?a ?b; \\<not> tr_lookup T ?b ?c\\<rbrakk>\n  \\<Longrightarrow> \\<not> tr_lookup T ?a ?c\n  \\<lbrakk>?x \\<in> set []; ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length zs\n  length [] + ii = length T + 1\n  i < length []\n  j < length []\n\ngoal (3 subgoals):\n 1. \\<And>zs i T ia j.\n       \\<lbrakk>\\<And>ia j k.\n                   \\<lbrakk>ia < length []; j < length [];\n                    [] ! ia = Some k\\<rbrakk>\n                   \\<Longrightarrow> ([] ! j = Some k) =\n                                     (\\<not> tr_lookup T (ia + i) (j + i));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set []; x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        length [] + i = length T + 1; ia < length []; j < length []\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl [] zs i T) ! ia =\n                          fst (mk_eqcl [] zs i T) ! j) =\n                         (\\<not> tr_lookup T (ia + i) (j + i))\n 2. \\<And>xs zs i T ia j.\n       \\<lbrakk>\\<And>ia j.\n                   \\<lbrakk>\\<And>ia j k.\n                               \\<lbrakk>ia\n  < length (mk_eqcl' xs i (Suc i) (length zs) T);\n                                j < length\n                                     (mk_eqcl' xs i (Suc i) (length zs) T);\n                                mk_eqcl' xs i (Suc i) (length zs) T ! ia =\n                                Some k\\<rbrakk>\n                               \\<Longrightarrow> (mk_eqcl' xs i (Suc i)\n             (length zs) T !\n            j =\n            Some k) =\n           (\\<not> tr_lookup T (ia + Suc i) (j + Suc i));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set\n   (mk_eqcl' xs i (Suc i) (length zs) T);\n                        x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < length (zs @ [i]);\n                    length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i =\n                    length T + 1;\n                    ia < length (mk_eqcl' xs i (Suc i) (length zs) T);\n                    j < length\n                         (mk_eqcl' xs i (Suc i) (length zs) T)\\<rbrakk>\n                   \\<Longrightarrow> (fst\n (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\nia =\nfst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\nj) =\n                                     (\\<not> tr_lookup T (ia + Suc i)\n        (j + Suc i));\n        \\<And>ia j k.\n           \\<lbrakk>ia < length (None # xs); j < length (None # xs);\n            (None # xs) ! ia = Some k\\<rbrakk>\n           \\<Longrightarrow> ((None # xs) ! j = Some k) =\n                             (\\<not> tr_lookup T (ia + i) (j + i));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (None # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        length (None # xs) + i = length T + 1; ia < length (None # xs);\n        j < length (None # xs)\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (None # xs) zs i T) ! ia =\n                          fst (mk_eqcl (None # xs) zs i T) ! j) =\n                         (\\<not> tr_lookup T (ia + i) (j + i))\n 3. \\<And>l xs zs i T ia j.\n       \\<lbrakk>\\<And>ia j.\n                   \\<lbrakk>\\<And>ia j k.\n                               \\<lbrakk>ia < length xs; j < length xs;\n                                xs ! ia = Some k\\<rbrakk>\n                               \\<Longrightarrow> (xs ! j = Some k) =\n           (\\<not> tr_lookup T (ia + Suc i) (j + Suc i));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < length zs;\n                    length xs + Suc i = length T + 1; ia < length xs;\n                    j < length xs\\<rbrakk>\n                   \\<Longrightarrow> (fst (mk_eqcl xs zs (Suc i) T) ! ia =\nfst (mk_eqcl xs zs (Suc i) T) ! j) =\n                                     (\\<not> tr_lookup T (ia + Suc i)\n        (j + Suc i));\n        \\<And>ia j k.\n           \\<lbrakk>ia < length (Some l # xs); j < length (Some l # xs);\n            (Some l # xs) ! ia = Some k\\<rbrakk>\n           \\<Longrightarrow> ((Some l # xs) ! j = Some k) =\n                             (\\<not> tr_lookup T (ia + i) (j + i));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (Some l # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        length (Some l # xs) + i = length T + 1; ia < length (Some l # xs);\n        j < length (Some l # xs)\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (Some l # xs) zs i T) ! ia =\n                          fst (mk_eqcl (Some l # xs) zs i T) ! j) =\n                         (\\<not> tr_lookup T (ia + i) (j + i))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < length []; ?j < length []; [] ! ?i = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ([] ! ?j = Some ?k) =\n                    (\\<not> tr_lookup T (?i + ii) (?j + ii))\n  \\<lbrakk>?a \\<le> length T; ?b \\<le> length T; ?c \\<le> length T;\n   \\<not> tr_lookup T ?a ?b; \\<not> tr_lookup T ?b ?c\\<rbrakk>\n  \\<Longrightarrow> \\<not> tr_lookup T ?a ?c\n  \\<lbrakk>?x \\<in> set []; ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length zs\n  length [] + ii = length T + 1\n  i < length []\n  j < length []\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl [] zs ii T) ! i = fst (mk_eqcl [] zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))", "by simp"], ["proof (state)\nthis:\n  (fst (mk_eqcl [] zs ii T) ! i = fst (mk_eqcl [] zs ii T) ! j) =\n  (\\<not> tr_lookup T (i + ii) (j + ii))\n\ngoal (2 subgoals):\n 1. \\<And>xs zs i T ia j.\n       \\<lbrakk>\\<And>ia j.\n                   \\<lbrakk>\\<And>ia j k.\n                               \\<lbrakk>ia\n  < length (mk_eqcl' xs i (Suc i) (length zs) T);\n                                j < length\n                                     (mk_eqcl' xs i (Suc i) (length zs) T);\n                                mk_eqcl' xs i (Suc i) (length zs) T ! ia =\n                                Some k\\<rbrakk>\n                               \\<Longrightarrow> (mk_eqcl' xs i (Suc i)\n             (length zs) T !\n            j =\n            Some k) =\n           (\\<not> tr_lookup T (ia + Suc i) (j + Suc i));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set\n   (mk_eqcl' xs i (Suc i) (length zs) T);\n                        x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < length (zs @ [i]);\n                    length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i =\n                    length T + 1;\n                    ia < length (mk_eqcl' xs i (Suc i) (length zs) T);\n                    j < length\n                         (mk_eqcl' xs i (Suc i) (length zs) T)\\<rbrakk>\n                   \\<Longrightarrow> (fst\n (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\nia =\nfst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\nj) =\n                                     (\\<not> tr_lookup T (ia + Suc i)\n        (j + Suc i));\n        \\<And>ia j k.\n           \\<lbrakk>ia < length (None # xs); j < length (None # xs);\n            (None # xs) ! ia = Some k\\<rbrakk>\n           \\<Longrightarrow> ((None # xs) ! j = Some k) =\n                             (\\<not> tr_lookup T (ia + i) (j + i));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (None # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        length (None # xs) + i = length T + 1; ia < length (None # xs);\n        j < length (None # xs)\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (None # xs) zs i T) ! ia =\n                          fst (mk_eqcl (None # xs) zs i T) ! j) =\n                         (\\<not> tr_lookup T (ia + i) (j + i))\n 2. \\<And>l xs zs i T ia j.\n       \\<lbrakk>\\<And>ia j.\n                   \\<lbrakk>\\<And>ia j k.\n                               \\<lbrakk>ia < length xs; j < length xs;\n                                xs ! ia = Some k\\<rbrakk>\n                               \\<Longrightarrow> (xs ! j = Some k) =\n           (\\<not> tr_lookup T (ia + Suc i) (j + Suc i));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < length zs;\n                    length xs + Suc i = length T + 1; ia < length xs;\n                    j < length xs\\<rbrakk>\n                   \\<Longrightarrow> (fst (mk_eqcl xs zs (Suc i) T) ! ia =\nfst (mk_eqcl xs zs (Suc i) T) ! j) =\n                                     (\\<not> tr_lookup T (ia + Suc i)\n        (j + Suc i));\n        \\<And>ia j k.\n           \\<lbrakk>ia < length (Some l # xs); j < length (Some l # xs);\n            (Some l # xs) ! ia = Some k\\<rbrakk>\n           \\<Longrightarrow> ((Some l # xs) ! j = Some k) =\n                             (\\<not> tr_lookup T (ia + i) (j + i));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (Some l # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        length (Some l # xs) + i = length T + 1; ia < length (Some l # xs);\n        j < length (Some l # xs)\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (Some l # xs) zs i T) ! ia =\n                          fst (mk_eqcl (Some l # xs) zs i T) ! j) =\n                         (\\<not> tr_lookup T (ia + i) (j + i))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs zs i T ia j.\n       \\<lbrakk>\\<And>ia j.\n                   \\<lbrakk>\\<And>ia j k.\n                               \\<lbrakk>ia\n  < length (mk_eqcl' xs i (Suc i) (length zs) T);\n                                j < length\n                                     (mk_eqcl' xs i (Suc i) (length zs) T);\n                                mk_eqcl' xs i (Suc i) (length zs) T ! ia =\n                                Some k\\<rbrakk>\n                               \\<Longrightarrow> (mk_eqcl' xs i (Suc i)\n             (length zs) T !\n            j =\n            Some k) =\n           (\\<not> tr_lookup T (ia + Suc i) (j + Suc i));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set\n   (mk_eqcl' xs i (Suc i) (length zs) T);\n                        x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < length (zs @ [i]);\n                    length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i =\n                    length T + 1;\n                    ia < length (mk_eqcl' xs i (Suc i) (length zs) T);\n                    j < length\n                         (mk_eqcl' xs i (Suc i) (length zs) T)\\<rbrakk>\n                   \\<Longrightarrow> (fst\n (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\nia =\nfst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\nj) =\n                                     (\\<not> tr_lookup T (ia + Suc i)\n        (j + Suc i));\n        \\<And>ia j k.\n           \\<lbrakk>ia < length (None # xs); j < length (None # xs);\n            (None # xs) ! ia = Some k\\<rbrakk>\n           \\<Longrightarrow> ((None # xs) ! j = Some k) =\n                             (\\<not> tr_lookup T (ia + i) (j + i));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (None # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        length (None # xs) + i = length T + 1; ia < length (None # xs);\n        j < length (None # xs)\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (None # xs) zs i T) ! ia =\n                          fst (mk_eqcl (None # xs) zs i T) ! j) =\n                         (\\<not> tr_lookup T (ia + i) (j + i))\n 2. \\<And>l xs zs i T ia j.\n       \\<lbrakk>\\<And>ia j.\n                   \\<lbrakk>\\<And>ia j k.\n                               \\<lbrakk>ia < length xs; j < length xs;\n                                xs ! ia = Some k\\<rbrakk>\n                               \\<Longrightarrow> (xs ! j = Some k) =\n           (\\<not> tr_lookup T (ia + Suc i) (j + Suc i));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < length zs;\n                    length xs + Suc i = length T + 1; ia < length xs;\n                    j < length xs\\<rbrakk>\n                   \\<Longrightarrow> (fst (mk_eqcl xs zs (Suc i) T) ! ia =\nfst (mk_eqcl xs zs (Suc i) T) ! j) =\n                                     (\\<not> tr_lookup T (ia + Suc i)\n        (j + Suc i));\n        \\<And>ia j k.\n           \\<lbrakk>ia < length (Some l # xs); j < length (Some l # xs);\n            (Some l # xs) ! ia = Some k\\<rbrakk>\n           \\<Longrightarrow> ((Some l # xs) ! j = Some k) =\n                             (\\<not> tr_lookup T (ia + i) (j + i));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (Some l # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        length (Some l # xs) + i = length T + 1; ia < length (Some l # xs);\n        j < length (Some l # xs)\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (Some l # xs) zs i T) ! ia =\n                          fst (mk_eqcl (Some l # xs) zs i T) ! j) =\n                         (\\<not> tr_lookup T (ia + i) (j + i))", "case (2 xs zs ii T)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>i j k.\n              \\<lbrakk>i < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n               j < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n               mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\\<rbrakk>\n              \\<Longrightarrow> (mk_eqcl' xs ii (Suc ii) (length zs) T ! j =\n                                 Some k) =\n                                (\\<not> tr_lookup T (i + Suc ii)\n   (j + Suc ii));\n   \\<And>a b c.\n      \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n       \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n      \\<Longrightarrow> \\<not> tr_lookup T a c;\n   \\<And>x k.\n      \\<lbrakk>x \\<in> set (mk_eqcl' xs ii (Suc ii) (length zs) T);\n       x = Some k\\<rbrakk>\n      \\<Longrightarrow> k < length (zs @ [ii]);\n   length (mk_eqcl' xs ii (Suc ii) (length zs) T) + Suc ii = length T + 1;\n   ?i < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n   ?j < length (mk_eqcl' xs ii (Suc ii) (length zs) T)\\<rbrakk>\n  \\<Longrightarrow> (fst (mk_eqcl (mk_eqcl' xs ii (Suc ii) (length zs) T)\n                           (zs @ [ii]) (Suc ii) T) !\n                     ?i =\n                     fst (mk_eqcl (mk_eqcl' xs ii (Suc ii) (length zs) T)\n                           (zs @ [ii]) (Suc ii) T) !\n                     ?j) =\n                    (\\<not> tr_lookup T (?i + Suc ii) (?j + Suc ii))\n  \\<lbrakk>?i < length (None # xs); ?j < length (None # xs);\n   (None # xs) ! ?i = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ((None # xs) ! ?j = Some ?k) =\n                    (\\<not> tr_lookup T (?i + ii) (?j + ii))\n  \\<lbrakk>?a \\<le> length T; ?b \\<le> length T; ?c \\<le> length T;\n   \\<not> tr_lookup T ?a ?b; \\<not> tr_lookup T ?b ?c\\<rbrakk>\n  \\<Longrightarrow> \\<not> tr_lookup T ?a ?c\n  \\<lbrakk>?x \\<in> set (None # xs); ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length zs\n  length (None # xs) + ii = length T + 1\n  i < length (None # xs)\n  j < length (None # xs)\n\ngoal (2 subgoals):\n 1. \\<And>xs zs i T ia j.\n       \\<lbrakk>\\<And>ia j.\n                   \\<lbrakk>\\<And>ia j k.\n                               \\<lbrakk>ia\n  < length (mk_eqcl' xs i (Suc i) (length zs) T);\n                                j < length\n                                     (mk_eqcl' xs i (Suc i) (length zs) T);\n                                mk_eqcl' xs i (Suc i) (length zs) T ! ia =\n                                Some k\\<rbrakk>\n                               \\<Longrightarrow> (mk_eqcl' xs i (Suc i)\n             (length zs) T !\n            j =\n            Some k) =\n           (\\<not> tr_lookup T (ia + Suc i) (j + Suc i));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set\n   (mk_eqcl' xs i (Suc i) (length zs) T);\n                        x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < length (zs @ [i]);\n                    length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i =\n                    length T + 1;\n                    ia < length (mk_eqcl' xs i (Suc i) (length zs) T);\n                    j < length\n                         (mk_eqcl' xs i (Suc i) (length zs) T)\\<rbrakk>\n                   \\<Longrightarrow> (fst\n (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\nia =\nfst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\nj) =\n                                     (\\<not> tr_lookup T (ia + Suc i)\n        (j + Suc i));\n        \\<And>ia j k.\n           \\<lbrakk>ia < length (None # xs); j < length (None # xs);\n            (None # xs) ! ia = Some k\\<rbrakk>\n           \\<Longrightarrow> ((None # xs) ! j = Some k) =\n                             (\\<not> tr_lookup T (ia + i) (j + i));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (None # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        length (None # xs) + i = length T + 1; ia < length (None # xs);\n        j < length (None # xs)\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (None # xs) zs i T) ! ia =\n                          fst (mk_eqcl (None # xs) zs i T) ! j) =\n                         (\\<not> tr_lookup T (ia + i) (j + i))\n 2. \\<And>l xs zs i T ia j.\n       \\<lbrakk>\\<And>ia j.\n                   \\<lbrakk>\\<And>ia j k.\n                               \\<lbrakk>ia < length xs; j < length xs;\n                                xs ! ia = Some k\\<rbrakk>\n                               \\<Longrightarrow> (xs ! j = Some k) =\n           (\\<not> tr_lookup T (ia + Suc i) (j + Suc i));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < length zs;\n                    length xs + Suc i = length T + 1; ia < length xs;\n                    j < length xs\\<rbrakk>\n                   \\<Longrightarrow> (fst (mk_eqcl xs zs (Suc i) T) ! ia =\nfst (mk_eqcl xs zs (Suc i) T) ! j) =\n                                     (\\<not> tr_lookup T (ia + Suc i)\n        (j + Suc i));\n        \\<And>ia j k.\n           \\<lbrakk>ia < length (Some l # xs); j < length (Some l # xs);\n            (Some l # xs) ! ia = Some k\\<rbrakk>\n           \\<Longrightarrow> ((Some l # xs) ! j = Some k) =\n                             (\\<not> tr_lookup T (ia + i) (j + i));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (Some l # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        length (Some l # xs) + i = length T + 1; ia < length (Some l # xs);\n        j < length (Some l # xs)\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (Some l # xs) zs i T) ! ia =\n                          fst (mk_eqcl (Some l # xs) zs i T) ! j) =\n                         (\\<not> tr_lookup T (ia + i) (j + i))", "{"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>i j k.\n              \\<lbrakk>i < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n               j < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n               mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\\<rbrakk>\n              \\<Longrightarrow> (mk_eqcl' xs ii (Suc ii) (length zs) T ! j =\n                                 Some k) =\n                                (\\<not> tr_lookup T (i + Suc ii)\n   (j + Suc ii));\n   \\<And>a b c.\n      \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n       \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n      \\<Longrightarrow> \\<not> tr_lookup T a c;\n   \\<And>x k.\n      \\<lbrakk>x \\<in> set (mk_eqcl' xs ii (Suc ii) (length zs) T);\n       x = Some k\\<rbrakk>\n      \\<Longrightarrow> k < length (zs @ [ii]);\n   length (mk_eqcl' xs ii (Suc ii) (length zs) T) + Suc ii = length T + 1;\n   ?i < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n   ?j < length (mk_eqcl' xs ii (Suc ii) (length zs) T)\\<rbrakk>\n  \\<Longrightarrow> (fst (mk_eqcl (mk_eqcl' xs ii (Suc ii) (length zs) T)\n                           (zs @ [ii]) (Suc ii) T) !\n                     ?i =\n                     fst (mk_eqcl (mk_eqcl' xs ii (Suc ii) (length zs) T)\n                           (zs @ [ii]) (Suc ii) T) !\n                     ?j) =\n                    (\\<not> tr_lookup T (?i + Suc ii) (?j + Suc ii))\n  \\<lbrakk>?i < length (None # xs); ?j < length (None # xs);\n   (None # xs) ! ?i = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ((None # xs) ! ?j = Some ?k) =\n                    (\\<not> tr_lookup T (?i + ii) (?j + ii))\n  \\<lbrakk>?a \\<le> length T; ?b \\<le> length T; ?c \\<le> length T;\n   \\<not> tr_lookup T ?a ?b; \\<not> tr_lookup T ?b ?c\\<rbrakk>\n  \\<Longrightarrow> \\<not> tr_lookup T ?a ?c\n  \\<lbrakk>?x \\<in> set (None # xs); ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length zs\n  length (None # xs) + ii = length T + 1\n  i < length (None # xs)\n  j < length (None # xs)\n\ngoal (2 subgoals):\n 1. \\<And>xs zs i T ia j.\n       \\<lbrakk>\\<And>ia j.\n                   \\<lbrakk>\\<And>ia j k.\n                               \\<lbrakk>ia\n  < length (mk_eqcl' xs i (Suc i) (length zs) T);\n                                j < length\n                                     (mk_eqcl' xs i (Suc i) (length zs) T);\n                                mk_eqcl' xs i (Suc i) (length zs) T ! ia =\n                                Some k\\<rbrakk>\n                               \\<Longrightarrow> (mk_eqcl' xs i (Suc i)\n             (length zs) T !\n            j =\n            Some k) =\n           (\\<not> tr_lookup T (ia + Suc i) (j + Suc i));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set\n   (mk_eqcl' xs i (Suc i) (length zs) T);\n                        x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < length (zs @ [i]);\n                    length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i =\n                    length T + 1;\n                    ia < length (mk_eqcl' xs i (Suc i) (length zs) T);\n                    j < length\n                         (mk_eqcl' xs i (Suc i) (length zs) T)\\<rbrakk>\n                   \\<Longrightarrow> (fst\n (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\nia =\nfst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\nj) =\n                                     (\\<not> tr_lookup T (ia + Suc i)\n        (j + Suc i));\n        \\<And>ia j k.\n           \\<lbrakk>ia < length (None # xs); j < length (None # xs);\n            (None # xs) ! ia = Some k\\<rbrakk>\n           \\<Longrightarrow> ((None # xs) ! j = Some k) =\n                             (\\<not> tr_lookup T (ia + i) (j + i));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (None # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        length (None # xs) + i = length T + 1; ia < length (None # xs);\n        j < length (None # xs)\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (None # xs) zs i T) ! ia =\n                          fst (mk_eqcl (None # xs) zs i T) ! j) =\n                         (\\<not> tr_lookup T (ia + i) (j + i))\n 2. \\<And>l xs zs i T ia j.\n       \\<lbrakk>\\<And>ia j.\n                   \\<lbrakk>\\<And>ia j k.\n                               \\<lbrakk>ia < length xs; j < length xs;\n                                xs ! ia = Some k\\<rbrakk>\n                               \\<Longrightarrow> (xs ! j = Some k) =\n           (\\<not> tr_lookup T (ia + Suc i) (j + Suc i));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < length zs;\n                    length xs + Suc i = length T + 1; ia < length xs;\n                    j < length xs\\<rbrakk>\n                   \\<Longrightarrow> (fst (mk_eqcl xs zs (Suc i) T) ! ia =\nfst (mk_eqcl xs zs (Suc i) T) ! j) =\n                                     (\\<not> tr_lookup T (ia + Suc i)\n        (j + Suc i));\n        \\<And>ia j k.\n           \\<lbrakk>ia < length (Some l # xs); j < length (Some l # xs);\n            (Some l # xs) ! ia = Some k\\<rbrakk>\n           \\<Longrightarrow> ((Some l # xs) ! j = Some k) =\n                             (\\<not> tr_lookup T (ia + i) (j + i));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (Some l # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        length (Some l # xs) + i = length T + 1; ia < length (Some l # xs);\n        j < length (Some l # xs)\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (Some l # xs) zs i T) ! ia =\n                          fst (mk_eqcl (Some l # xs) zs i T) ! j) =\n                         (\\<not> tr_lookup T (ia + i) (j + i))", "fix i j"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs zs i T ia j.\n       \\<lbrakk>\\<And>ia j.\n                   \\<lbrakk>\\<And>ia j k.\n                               \\<lbrakk>ia\n  < length (mk_eqcl' xs i (Suc i) (length zs) T);\n                                j < length\n                                     (mk_eqcl' xs i (Suc i) (length zs) T);\n                                mk_eqcl' xs i (Suc i) (length zs) T ! ia =\n                                Some k\\<rbrakk>\n                               \\<Longrightarrow> (mk_eqcl' xs i (Suc i)\n             (length zs) T !\n            j =\n            Some k) =\n           (\\<not> tr_lookup T (ia + Suc i) (j + Suc i));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set\n   (mk_eqcl' xs i (Suc i) (length zs) T);\n                        x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < length (zs @ [i]);\n                    length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i =\n                    length T + 1;\n                    ia < length (mk_eqcl' xs i (Suc i) (length zs) T);\n                    j < length\n                         (mk_eqcl' xs i (Suc i) (length zs) T)\\<rbrakk>\n                   \\<Longrightarrow> (fst\n (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\nia =\nfst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\nj) =\n                                     (\\<not> tr_lookup T (ia + Suc i)\n        (j + Suc i));\n        \\<And>ia j k.\n           \\<lbrakk>ia < length (None # xs); j < length (None # xs);\n            (None # xs) ! ia = Some k\\<rbrakk>\n           \\<Longrightarrow> ((None # xs) ! j = Some k) =\n                             (\\<not> tr_lookup T (ia + i) (j + i));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (None # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        length (None # xs) + i = length T + 1; ia < length (None # xs);\n        j < length (None # xs)\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (None # xs) zs i T) ! ia =\n                          fst (mk_eqcl (None # xs) zs i T) ! j) =\n                         (\\<not> tr_lookup T (ia + i) (j + i))\n 2. \\<And>l xs zs i T ia j.\n       \\<lbrakk>\\<And>ia j.\n                   \\<lbrakk>\\<And>ia j k.\n                               \\<lbrakk>ia < length xs; j < length xs;\n                                xs ! ia = Some k\\<rbrakk>\n                               \\<Longrightarrow> (xs ! j = Some k) =\n           (\\<not> tr_lookup T (ia + Suc i) (j + Suc i));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < length zs;\n                    length xs + Suc i = length T + 1; ia < length xs;\n                    j < length xs\\<rbrakk>\n                   \\<Longrightarrow> (fst (mk_eqcl xs zs (Suc i) T) ! ia =\nfst (mk_eqcl xs zs (Suc i) T) ! j) =\n                                     (\\<not> tr_lookup T (ia + Suc i)\n        (j + Suc i));\n        \\<And>ia j k.\n           \\<lbrakk>ia < length (Some l # xs); j < length (Some l # xs);\n            (Some l # xs) ! ia = Some k\\<rbrakk>\n           \\<Longrightarrow> ((Some l # xs) ! j = Some k) =\n                             (\\<not> tr_lookup T (ia + i) (j + i));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (Some l # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        length (Some l # xs) + i = length T + 1; ia < length (Some l # xs);\n        j < length (Some l # xs)\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (Some l # xs) zs i T) ! ia =\n                          fst (mk_eqcl (Some l # xs) zs i T) ! j) =\n                         (\\<not> tr_lookup T (ia + i) (j + i))", "assume H: \"i < j\" \"j < length (None # xs)\""], ["proof (state)\nthis:\n  i < j\n  j < length (None # xs)\n\ngoal (2 subgoals):\n 1. \\<And>xs zs i T ia j.\n       \\<lbrakk>\\<And>ia j.\n                   \\<lbrakk>\\<And>ia j k.\n                               \\<lbrakk>ia\n  < length (mk_eqcl' xs i (Suc i) (length zs) T);\n                                j < length\n                                     (mk_eqcl' xs i (Suc i) (length zs) T);\n                                mk_eqcl' xs i (Suc i) (length zs) T ! ia =\n                                Some k\\<rbrakk>\n                               \\<Longrightarrow> (mk_eqcl' xs i (Suc i)\n             (length zs) T !\n            j =\n            Some k) =\n           (\\<not> tr_lookup T (ia + Suc i) (j + Suc i));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set\n   (mk_eqcl' xs i (Suc i) (length zs) T);\n                        x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < length (zs @ [i]);\n                    length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i =\n                    length T + 1;\n                    ia < length (mk_eqcl' xs i (Suc i) (length zs) T);\n                    j < length\n                         (mk_eqcl' xs i (Suc i) (length zs) T)\\<rbrakk>\n                   \\<Longrightarrow> (fst\n (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\nia =\nfst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\nj) =\n                                     (\\<not> tr_lookup T (ia + Suc i)\n        (j + Suc i));\n        \\<And>ia j k.\n           \\<lbrakk>ia < length (None # xs); j < length (None # xs);\n            (None # xs) ! ia = Some k\\<rbrakk>\n           \\<Longrightarrow> ((None # xs) ! j = Some k) =\n                             (\\<not> tr_lookup T (ia + i) (j + i));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (None # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        length (None # xs) + i = length T + 1; ia < length (None # xs);\n        j < length (None # xs)\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (None # xs) zs i T) ! ia =\n                          fst (mk_eqcl (None # xs) zs i T) ! j) =\n                         (\\<not> tr_lookup T (ia + i) (j + i))\n 2. \\<And>l xs zs i T ia j.\n       \\<lbrakk>\\<And>ia j.\n                   \\<lbrakk>\\<And>ia j k.\n                               \\<lbrakk>ia < length xs; j < length xs;\n                                xs ! ia = Some k\\<rbrakk>\n                               \\<Longrightarrow> (xs ! j = Some k) =\n           (\\<not> tr_lookup T (ia + Suc i) (j + Suc i));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < length zs;\n                    length xs + Suc i = length T + 1; ia < length xs;\n                    j < length xs\\<rbrakk>\n                   \\<Longrightarrow> (fst (mk_eqcl xs zs (Suc i) T) ! ia =\nfst (mk_eqcl xs zs (Suc i) T) ! j) =\n                                     (\\<not> tr_lookup T (ia + Suc i)\n        (j + Suc i));\n        \\<And>ia j k.\n           \\<lbrakk>ia < length (Some l # xs); j < length (Some l # xs);\n            (Some l # xs) ! ia = Some k\\<rbrakk>\n           \\<Longrightarrow> ((Some l # xs) ! j = Some k) =\n                             (\\<not> tr_lookup T (ia + i) (j + i));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (Some l # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        length (Some l # xs) + i = length T + 1; ia < length (Some l # xs);\n        j < length (Some l # xs)\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (Some l # xs) zs i T) ! ia =\n                          fst (mk_eqcl (Some l # xs) zs i T) ! j) =\n                         (\\<not> tr_lookup T (ia + i) (j + i))", "then"], ["proof (chain)\npicking this:\n  i < j\n  j < length (None # xs)", "obtain j' where J: \"j = Suc j'\""], ["proof (prove)\nusing this:\n  i < j\n  j < length (None # xs)\n\ngoal (1 subgoal):\n 1. (\\<And>j'. j = Suc j' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases j) simp+"], ["proof (state)\nthis:\n  j = Suc j'\n\ngoal (2 subgoals):\n 1. \\<And>xs zs i T ia j.\n       \\<lbrakk>\\<And>ia j.\n                   \\<lbrakk>\\<And>ia j k.\n                               \\<lbrakk>ia\n  < length (mk_eqcl' xs i (Suc i) (length zs) T);\n                                j < length\n                                     (mk_eqcl' xs i (Suc i) (length zs) T);\n                                mk_eqcl' xs i (Suc i) (length zs) T ! ia =\n                                Some k\\<rbrakk>\n                               \\<Longrightarrow> (mk_eqcl' xs i (Suc i)\n             (length zs) T !\n            j =\n            Some k) =\n           (\\<not> tr_lookup T (ia + Suc i) (j + Suc i));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set\n   (mk_eqcl' xs i (Suc i) (length zs) T);\n                        x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < length (zs @ [i]);\n                    length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i =\n                    length T + 1;\n                    ia < length (mk_eqcl' xs i (Suc i) (length zs) T);\n                    j < length\n                         (mk_eqcl' xs i (Suc i) (length zs) T)\\<rbrakk>\n                   \\<Longrightarrow> (fst\n (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\nia =\nfst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\nj) =\n                                     (\\<not> tr_lookup T (ia + Suc i)\n        (j + Suc i));\n        \\<And>ia j k.\n           \\<lbrakk>ia < length (None # xs); j < length (None # xs);\n            (None # xs) ! ia = Some k\\<rbrakk>\n           \\<Longrightarrow> ((None # xs) ! j = Some k) =\n                             (\\<not> tr_lookup T (ia + i) (j + i));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (None # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        length (None # xs) + i = length T + 1; ia < length (None # xs);\n        j < length (None # xs)\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (None # xs) zs i T) ! ia =\n                          fst (mk_eqcl (None # xs) zs i T) ! j) =\n                         (\\<not> tr_lookup T (ia + i) (j + i))\n 2. \\<And>l xs zs i T ia j.\n       \\<lbrakk>\\<And>ia j.\n                   \\<lbrakk>\\<And>ia j k.\n                               \\<lbrakk>ia < length xs; j < length xs;\n                                xs ! ia = Some k\\<rbrakk>\n                               \\<Longrightarrow> (xs ! j = Some k) =\n           (\\<not> tr_lookup T (ia + Suc i) (j + Suc i));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < length zs;\n                    length xs + Suc i = length T + 1; ia < length xs;\n                    j < length xs\\<rbrakk>\n                   \\<Longrightarrow> (fst (mk_eqcl xs zs (Suc i) T) ! ia =\nfst (mk_eqcl xs zs (Suc i) T) ! j) =\n                                     (\\<not> tr_lookup T (ia + Suc i)\n        (j + Suc i));\n        \\<And>ia j k.\n           \\<lbrakk>ia < length (Some l # xs); j < length (Some l # xs);\n            (Some l # xs) ! ia = Some k\\<rbrakk>\n           \\<Longrightarrow> ((Some l # xs) ! j = Some k) =\n                             (\\<not> tr_lookup T (ia + i) (j + i));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (Some l # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        length (Some l # xs) + i = length T + 1; ia < length (Some l # xs);\n        j < length (Some l # xs)\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (Some l # xs) zs i T) ! ia =\n                          fst (mk_eqcl (Some l # xs) zs i T) ! j) =\n                         (\\<not> tr_lookup T (ia + i) (j + i))", "have \"(fst (mk_eqcl (None # xs) zs ii T) ! i = fst (mk_eqcl (None # xs) zs ii T) ! j) = (\\<not> tr_lookup T (i + ii) (j + ii))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (None # xs) zs ii T) ! i =\n     fst (mk_eqcl (None # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))", "proof (cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    (fst (mk_eqcl (None # xs) zs ii T) ! i =\n     fst (mk_eqcl (None # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (None # xs) zs ii T) ! i =\n        fst (mk_eqcl (None # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "case 0"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    (fst (mk_eqcl (None # xs) zs ii T) ! i =\n     fst (mk_eqcl (None # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (None # xs) zs ii T) ! i =\n        fst (mk_eqcl (None # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "with J"], ["proof (chain)\npicking this:\n  j = Suc j'\n  i = 0", "have \"(fst (mk_eqcl (None # xs) zs ii T) ! i = fst (mk_eqcl (None # xs) zs ii T) ! j) = (fst (mk_eqcl (mk_eqcl' xs ii (Suc ii) (length zs) T) (zs @ [ii]) (Suc ii) T) ! j' = length zs)\""], ["proof (prove)\nusing this:\n  j = Suc j'\n  i = 0\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (None # xs) zs ii T) ! i =\n     fst (mk_eqcl (None # xs) zs ii T) ! j) =\n    (fst (mk_eqcl (mk_eqcl' xs ii (Suc ii) (length zs) T) (zs @ [ii])\n           (Suc ii) T) !\n     j' =\n     length zs)", "by (auto simp add: split_beta)"], ["proof (state)\nthis:\n  (fst (mk_eqcl (None # xs) zs ii T) ! i =\n   fst (mk_eqcl (None # xs) zs ii T) ! j) =\n  (fst (mk_eqcl (mk_eqcl' xs ii (Suc ii) (length zs) T) (zs @ [ii]) (Suc ii)\n         T) !\n   j' =\n   length zs)\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    (fst (mk_eqcl (None # xs) zs ii T) ! i =\n     fst (mk_eqcl (None # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (None # xs) zs ii T) ! i =\n        fst (mk_eqcl (None # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "also"], ["proof (state)\nthis:\n  (fst (mk_eqcl (None # xs) zs ii T) ! i =\n   fst (mk_eqcl (None # xs) zs ii T) ! j) =\n  (fst (mk_eqcl (mk_eqcl' xs ii (Suc ii) (length zs) T) (zs @ [ii]) (Suc ii)\n         T) !\n   j' =\n   length zs)\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    (fst (mk_eqcl (None # xs) zs ii T) ! i =\n     fst (mk_eqcl (None # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (None # xs) zs ii T) ! i =\n        fst (mk_eqcl (None # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "from H J"], ["proof (chain)\npicking this:\n  i < j\n  j < length (None # xs)\n  j = Suc j'", "have \"\\<dots> = (mk_eqcl' xs ii (Suc ii) (length zs) T ! j' = Some (length zs))\""], ["proof (prove)\nusing this:\n  i < j\n  j < length (None # xs)\n  j = Suc j'\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (mk_eqcl' xs ii (Suc ii) (length zs) T) (zs @ [ii])\n           (Suc ii) T) !\n     j' =\n     length zs) =\n    (mk_eqcl' xs ii (Suc ii) (length zs) T ! j' = Some (length zs))", "by (simp add: mk_eqcl_fst_Some mk_eqcl'_len)"], ["proof (state)\nthis:\n  (fst (mk_eqcl (mk_eqcl' xs ii (Suc ii) (length zs) T) (zs @ [ii]) (Suc ii)\n         T) !\n   j' =\n   length zs) =\n  (mk_eqcl' xs ii (Suc ii) (length zs) T ! j' = Some (length zs))\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    (fst (mk_eqcl (None # xs) zs ii T) ! i =\n     fst (mk_eqcl (None # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (None # xs) zs ii T) ! i =\n        fst (mk_eqcl (None # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "also"], ["proof (state)\nthis:\n  (fst (mk_eqcl (mk_eqcl' xs ii (Suc ii) (length zs) T) (zs @ [ii]) (Suc ii)\n         T) !\n   j' =\n   length zs) =\n  (mk_eqcl' xs ii (Suc ii) (length zs) T ! j' = Some (length zs))\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    (fst (mk_eqcl (None # xs) zs ii T) ! i =\n     fst (mk_eqcl (None # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (None # xs) zs ii T) ! i =\n        fst (mk_eqcl (None # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "have \"\\<dots> = (\\<not> tr_lookup T (j' + Suc ii) ii)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mk_eqcl' xs ii (Suc ii) (length zs) T ! j' = Some (length zs)) =\n    (\\<not> tr_lookup T (j' + Suc ii) ii)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (mk_eqcl' xs ii (Suc ii) (length zs) T ! j' = Some (length zs)) =\n    (\\<not> tr_lookup T (j' + Suc ii) ii)", "have \"\\<And>x k. \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk> \\<Longrightarrow> k < length zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x k.\n       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n       \\<Longrightarrow> k < length zs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x k.\n       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n       \\<Longrightarrow> k < length zs", "fix x k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x k.\n       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n       \\<Longrightarrow> k < length zs", "assume \"x \\<in> set xs\" \"x = Some k\""], ["proof (state)\nthis:\n  x \\<in> set xs\n  x = Some k\n\ngoal (1 subgoal):\n 1. \\<And>x k.\n       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n       \\<Longrightarrow> k < length zs", "with 2(4)[of x k]"], ["proof (chain)\npicking this:\n  \\<lbrakk>x \\<in> set (None # xs); x = Some k\\<rbrakk>\n  \\<Longrightarrow> k < length zs\n  x \\<in> set xs\n  x = Some k", "show \"k < length zs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<in> set (None # xs); x = Some k\\<rbrakk>\n  \\<Longrightarrow> k < length zs\n  x \\<in> set xs\n  x = Some k\n\ngoal (1 subgoal):\n 1. k < length zs", "by simp"], ["proof (state)\nthis:\n  k < length zs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> set xs; ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length zs\n\ngoal (1 subgoal):\n 1. (mk_eqcl' xs ii (Suc ii) (length zs) T ! j' = Some (length zs)) =\n    (\\<not> tr_lookup T (j' + Suc ii) ii)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> set xs; ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length zs\n\ngoal (1 subgoal):\n 1. (mk_eqcl' xs ii (Suc ii) (length zs) T ! j' = Some (length zs)) =\n    (\\<not> tr_lookup T (j' + Suc ii) ii)", "have \"\\<And>i'. \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc ii) ii\\<rbrakk> \\<Longrightarrow> xs ! i' = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i'.\n       \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc ii) ii\\<rbrakk>\n       \\<Longrightarrow> xs ! i' = None", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i'.\n       \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc ii) ii\\<rbrakk>\n       \\<Longrightarrow> xs ! i' = None", "fix i'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i'.\n       \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc ii) ii\\<rbrakk>\n       \\<Longrightarrow> xs ! i' = None", "assume H: \"i' < length xs\" \"\\<not> tr_lookup T (i' + Suc ii) ii\""], ["proof (state)\nthis:\n  i' < length xs\n  \\<not> tr_lookup T (i' + Suc ii) ii\n\ngoal (1 subgoal):\n 1. \\<And>i'.\n       \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc ii) ii\\<rbrakk>\n       \\<Longrightarrow> xs ! i' = None", "{"], ["proof (state)\nthis:\n  i' < length xs\n  \\<not> tr_lookup T (i' + Suc ii) ii\n\ngoal (1 subgoal):\n 1. \\<And>i'.\n       \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc ii) ii\\<rbrakk>\n       \\<Longrightarrow> xs ! i' = None", "assume H': \"xs ! i' \\<noteq> None\""], ["proof (state)\nthis:\n  xs ! i' \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<And>i'.\n       \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc ii) ii\\<rbrakk>\n       \\<Longrightarrow> xs ! i' = None", "then"], ["proof (chain)\npicking this:\n  xs ! i' \\<noteq> None", "obtain k where \"xs ! i' = Some k\""], ["proof (prove)\nusing this:\n  xs ! i' \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>k. xs ! i' = Some k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"xs ! i'\") simp+"], ["proof (state)\nthis:\n  xs ! i' = Some k\n\ngoal (1 subgoal):\n 1. \\<And>i'.\n       \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc ii) ii\\<rbrakk>\n       \\<Longrightarrow> xs ! i' = None", "with 2(2)[of \"Suc i'\" 0 k] H"], ["proof (chain)\npicking this:\n  \\<lbrakk>Suc i' < length (None # xs); 0 < length (None # xs);\n   (None # xs) ! Suc i' = Some k\\<rbrakk>\n  \\<Longrightarrow> ((None # xs) ! 0 = Some k) =\n                    (\\<not> tr_lookup T (Suc i' + ii) (0 + ii))\n  i' < length xs\n  \\<not> tr_lookup T (i' + Suc ii) ii\n  xs ! i' = Some k", "have False"], ["proof (prove)\nusing this:\n  \\<lbrakk>Suc i' < length (None # xs); 0 < length (None # xs);\n   (None # xs) ! Suc i' = Some k\\<rbrakk>\n  \\<Longrightarrow> ((None # xs) ! 0 = Some k) =\n                    (\\<not> tr_lookup T (Suc i' + ii) (0 + ii))\n  i' < length xs\n  \\<not> tr_lookup T (i' + Suc ii) ii\n  xs ! i' = Some k\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>i'.\n       \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc ii) ii\\<rbrakk>\n       \\<Longrightarrow> xs ! i' = None", "}"], ["proof (state)\nthis:\n  xs ! i' \\<noteq> None \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>i'.\n       \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc ii) ii\\<rbrakk>\n       \\<Longrightarrow> xs ! i' = None", "thus \"xs ! i' = None\""], ["proof (prove)\nusing this:\n  xs ! i' \\<noteq> None \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. xs ! i' = None", "by (cases \"xs ! i'\") simp+"], ["proof (state)\nthis:\n  xs ! i' = None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?i' < length xs; \\<not> tr_lookup T (?i' + Suc ii) ii\\<rbrakk>\n  \\<Longrightarrow> xs ! ?i' = None\n\ngoal (1 subgoal):\n 1. (mk_eqcl' xs ii (Suc ii) (length zs) T ! j' = Some (length zs)) =\n    (\\<not> tr_lookup T (j' + Suc ii) ii)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?i' < length xs; \\<not> tr_lookup T (?i' + Suc ii) ii\\<rbrakk>\n  \\<Longrightarrow> xs ! ?i' = None\n\ngoal (1 subgoal):\n 1. (mk_eqcl' xs ii (Suc ii) (length zs) T ! j' = Some (length zs)) =\n    (\\<not> tr_lookup T (j' + Suc ii) ii)", "from H J"], ["proof (chain)\npicking this:\n  i < j\n  j < length (None # xs)\n  j = Suc j'", "have \"ii < Suc ii\" \"j' < length xs\""], ["proof (prove)\nusing this:\n  i < j\n  j < length (None # xs)\n  j = Suc j'\n\ngoal (1 subgoal):\n 1. ii < Suc ii &&& j' < length xs", "by simp+"], ["proof (state)\nthis:\n  ii < Suc ii\n  j' < length xs\n\ngoal (1 subgoal):\n 1. (mk_eqcl' xs ii (Suc ii) (length zs) T ! j' = Some (length zs)) =\n    (\\<not> tr_lookup T (j' + Suc ii) ii)", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<in> set xs; ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length zs\n  \\<lbrakk>?i' < length xs; \\<not> tr_lookup T (?i' + Suc ii) ii\\<rbrakk>\n  \\<Longrightarrow> xs ! ?i' = None\n  ii < Suc ii\n  j' < length xs", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set xs; ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length zs\n  \\<lbrakk>?i' < length xs; \\<not> tr_lookup T (?i' + Suc ii) ii\\<rbrakk>\n  \\<Longrightarrow> xs ! ?i' = None\n  ii < Suc ii\n  j' < length xs\n\ngoal (1 subgoal):\n 1. (mk_eqcl' xs ii (Suc ii) (length zs) T ! j' = Some (length zs)) =\n    (\\<not> tr_lookup T (j' + Suc ii) ii)", "by (rule mk_eqcl'_nth')"], ["proof (state)\nthis:\n  (mk_eqcl' xs ii (Suc ii) (length zs) T ! j' = Some (length zs)) =\n  (\\<not> tr_lookup T (j' + Suc ii) ii)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (mk_eqcl' xs ii (Suc ii) (length zs) T ! j' = Some (length zs)) =\n  (\\<not> tr_lookup T (j' + Suc ii) ii)\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    (fst (mk_eqcl (None # xs) zs ii T) ! i =\n     fst (mk_eqcl (None # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (None # xs) zs ii T) ! i =\n        fst (mk_eqcl (None # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "also"], ["proof (state)\nthis:\n  (mk_eqcl' xs ii (Suc ii) (length zs) T ! j' = Some (length zs)) =\n  (\\<not> tr_lookup T (j' + Suc ii) ii)\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    (fst (mk_eqcl (None # xs) zs ii T) ! i =\n     fst (mk_eqcl (None # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (None # xs) zs ii T) ! i =\n        fst (mk_eqcl (None # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "from J 0"], ["proof (chain)\npicking this:\n  j = Suc j'\n  i = 0", "have \"\\<dots> = (\\<not> tr_lookup T (i + ii) (j + ii))\""], ["proof (prove)\nusing this:\n  j = Suc j'\n  i = 0\n\ngoal (1 subgoal):\n 1. (\\<not> tr_lookup T (j' + Suc ii) ii) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))", "by (auto simp: tr_lookup_def)"], ["proof (state)\nthis:\n  (\\<not> tr_lookup T (j' + Suc ii) ii) =\n  (\\<not> tr_lookup T (i + ii) (j + ii))\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    (fst (mk_eqcl (None # xs) zs ii T) ! i =\n     fst (mk_eqcl (None # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (None # xs) zs ii T) ! i =\n        fst (mk_eqcl (None # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "finally"], ["proof (chain)\npicking this:\n  (fst (mk_eqcl (None # xs) zs ii T) ! i =\n   fst (mk_eqcl (None # xs) zs ii T) ! j) =\n  (\\<not> tr_lookup T (i + ii) (j + ii))", "show ?thesis"], ["proof (prove)\nusing this:\n  (fst (mk_eqcl (None # xs) zs ii T) ! i =\n   fst (mk_eqcl (None # xs) zs ii T) ! j) =\n  (\\<not> tr_lookup T (i + ii) (j + ii))\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (None # xs) zs ii T) ! i =\n     fst (mk_eqcl (None # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))", "by simp"], ["proof (state)\nthis:\n  (fst (mk_eqcl (None # xs) zs ii T) ! i =\n   fst (mk_eqcl (None # xs) zs ii T) ! j) =\n  (\\<not> tr_lookup T (i + ii) (j + ii))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (None # xs) zs ii T) ! i =\n        fst (mk_eqcl (None # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (None # xs) zs ii T) ! i =\n        fst (mk_eqcl (None # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "case (Suc i')"], ["proof (state)\nthis:\n  i = Suc i'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (None # xs) zs ii T) ! i =\n        fst (mk_eqcl (None # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "have \"\\<And>i j k. \\<lbrakk>i < length (mk_eqcl' xs ii (Suc ii) (length zs) T); j < length (mk_eqcl' xs ii (Suc ii) (length zs) T); mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\\<rbrakk>\n         \\<Longrightarrow> (mk_eqcl' xs ii (Suc ii) (length zs) T ! j = Some k) = (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        j < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' xs ii (Suc ii) (length zs) T ! j =\n                          Some k) =\n                         (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        j < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' xs ii (Suc ii) (length zs) T ! j =\n                          Some k) =\n                         (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))", "fix i j k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        j < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' xs ii (Suc ii) (length zs) T ! j =\n                          Some k) =\n                         (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))", "assume H: \"i < length (mk_eqcl' xs ii (Suc ii) (length zs) T)\" \"j < length (mk_eqcl' xs ii (Suc ii) (length zs) T)\" \"mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\""], ["proof (state)\nthis:\n  i < length (mk_eqcl' xs ii (Suc ii) (length zs) T)\n  j < length (mk_eqcl' xs ii (Suc ii) (length zs) T)\n  mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        j < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' xs ii (Suc ii) (length zs) T ! j =\n                          Some k) =\n                         (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))", "{"], ["proof (state)\nthis:\n  i < length (mk_eqcl' xs ii (Suc ii) (length zs) T)\n  j < length (mk_eqcl' xs ii (Suc ii) (length zs) T)\n  mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        j < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' xs ii (Suc ii) (length zs) T ! j =\n                          Some k) =\n                         (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))", "fix i' j' k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        j < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' xs ii (Suc ii) (length zs) T ! j =\n                          Some k) =\n                         (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))", "assume \"i' < length xs\" \"j' < length xs\" \"xs ! i' = Some k\""], ["proof (state)\nthis:\n  i' < length xs\n  j' < length xs\n  xs ! i' = Some k\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        j < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' xs ii (Suc ii) (length zs) T ! j =\n                          Some k) =\n                         (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))", "with 2(2)[of \"Suc i'\" \"Suc j'\" k]"], ["proof (chain)\npicking this:\n  \\<lbrakk>Suc i' < length (None # xs); Suc j' < length (None # xs);\n   (None # xs) ! Suc i' = Some k\\<rbrakk>\n  \\<Longrightarrow> ((None # xs) ! Suc j' = Some k) =\n                    (\\<not> tr_lookup T (Suc i' + ii) (Suc j' + ii))\n  i' < length xs\n  j' < length xs\n  xs ! i' = Some k", "have \"(xs ! j' = Some k) = (\\<not> tr_lookup T (i' + Suc ii) (j' + Suc ii))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>Suc i' < length (None # xs); Suc j' < length (None # xs);\n   (None # xs) ! Suc i' = Some k\\<rbrakk>\n  \\<Longrightarrow> ((None # xs) ! Suc j' = Some k) =\n                    (\\<not> tr_lookup T (Suc i' + ii) (Suc j' + ii))\n  i' < length xs\n  j' < length xs\n  xs ! i' = Some k\n\ngoal (1 subgoal):\n 1. (xs ! j' = Some k) = (\\<not> tr_lookup T (i' + Suc ii) (j' + Suc ii))", "by simp"], ["proof (state)\nthis:\n  (xs ! j' = Some k) = (\\<not> tr_lookup T (i' + Suc ii) (j' + Suc ii))\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        j < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' xs ii (Suc ii) (length zs) T ! j =\n                          Some k) =\n                         (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i'a2 < length xs; ?j'a2 < length xs;\n   xs ! ?i'a2 = Some ?ka2\\<rbrakk>\n  \\<Longrightarrow> (xs ! ?j'a2 = Some ?ka2) =\n                    (\\<not> tr_lookup T (?i'a2 + Suc ii) (?j'a2 + Suc ii))\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        j < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' xs ii (Suc ii) (length zs) T ! j =\n                          Some k) =\n                         (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?i'a2 < length xs; ?j'a2 < length xs;\n   xs ! ?i'a2 = Some ?ka2\\<rbrakk>\n  \\<Longrightarrow> (xs ! ?j'a2 = Some ?ka2) =\n                    (\\<not> tr_lookup T (?i'a2 + Suc ii) (?j'a2 + Suc ii))\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        j < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' xs ii (Suc ii) (length zs) T ! j =\n                          Some k) =\n                         (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))", "note 2(3)"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<le> length T; ?b \\<le> length T; ?c \\<le> length T;\n   \\<not> tr_lookup T ?a ?b; \\<not> tr_lookup T ?b ?c\\<rbrakk>\n  \\<Longrightarrow> \\<not> tr_lookup T ?a ?c\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        j < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' xs ii (Suc ii) (length zs) T ! j =\n                          Some k) =\n                         (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<le> length T; ?b \\<le> length T; ?c \\<le> length T;\n   \\<not> tr_lookup T ?a ?b; \\<not> tr_lookup T ?b ?c\\<rbrakk>\n  \\<Longrightarrow> \\<not> tr_lookup T ?a ?c\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        j < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' xs ii (Suc ii) (length zs) T ! j =\n                          Some k) =\n                         (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))", "from 2(5)"], ["proof (chain)\npicking this:\n  length (None # xs) + ii = length T + 1", "have \"length xs + Suc ii = length T + 1\""], ["proof (prove)\nusing this:\n  length (None # xs) + ii = length T + 1\n\ngoal (1 subgoal):\n 1. length xs + Suc ii = length T + 1", "by simp"], ["proof (state)\nthis:\n  length xs + Suc ii = length T + 1\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        j < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' xs ii (Suc ii) (length zs) T ! j =\n                          Some k) =\n                         (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))", "moreover"], ["proof (state)\nthis:\n  length xs + Suc ii = length T + 1\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        j < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' xs ii (Suc ii) (length zs) T ! j =\n                          Some k) =\n                         (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))", "{"], ["proof (state)\nthis:\n  length xs + Suc ii = length T + 1\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        j < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' xs ii (Suc ii) (length zs) T ! j =\n                          Some k) =\n                         (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))", "fix x k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        j < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' xs ii (Suc ii) (length zs) T ! j =\n                          Some k) =\n                         (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))", "assume \"x \\<in> set xs\" \"x = Some k\""], ["proof (state)\nthis:\n  x \\<in> set xs\n  x = Some k\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        j < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' xs ii (Suc ii) (length zs) T ! j =\n                          Some k) =\n                         (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))", "with 2(4)[of x k]"], ["proof (chain)\npicking this:\n  \\<lbrakk>x \\<in> set (None # xs); x = Some k\\<rbrakk>\n  \\<Longrightarrow> k < length zs\n  x \\<in> set xs\n  x = Some k", "have \"k < length zs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<in> set (None # xs); x = Some k\\<rbrakk>\n  \\<Longrightarrow> k < length zs\n  x \\<in> set xs\n  x = Some k\n\ngoal (1 subgoal):\n 1. k < length zs", "by simp"], ["proof (state)\nthis:\n  k < length zs\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        j < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' xs ii (Suc ii) (length zs) T ! j =\n                          Some k) =\n                         (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?x2 \\<in> set xs; ?x2 = Some ?ka2\\<rbrakk>\n  \\<Longrightarrow> ?ka2 < length zs\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        j < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' xs ii (Suc ii) (length zs) T ! j =\n                          Some k) =\n                         (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?x2 \\<in> set xs; ?x2 = Some ?ka2\\<rbrakk>\n  \\<Longrightarrow> ?ka2 < length zs\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        j < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' xs ii (Suc ii) (length zs) T ! j =\n                          Some k) =\n                         (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))", "have \"\\<And>i'. \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc ii) ii\\<rbrakk> \\<Longrightarrow> xs ! i' = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i'.\n       \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc ii) ii\\<rbrakk>\n       \\<Longrightarrow> xs ! i' = None", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i'.\n       \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc ii) ii\\<rbrakk>\n       \\<Longrightarrow> xs ! i' = None", "fix i'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i'.\n       \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc ii) ii\\<rbrakk>\n       \\<Longrightarrow> xs ! i' = None", "assume H': \"i' < length xs\" \"\\<not> tr_lookup T (i' + Suc ii) ii\""], ["proof (state)\nthis:\n  i' < length xs\n  \\<not> tr_lookup T (i' + Suc ii) ii\n\ngoal (1 subgoal):\n 1. \\<And>i'.\n       \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc ii) ii\\<rbrakk>\n       \\<Longrightarrow> xs ! i' = None", "{"], ["proof (state)\nthis:\n  i' < length xs\n  \\<not> tr_lookup T (i' + Suc ii) ii\n\ngoal (1 subgoal):\n 1. \\<And>i'.\n       \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc ii) ii\\<rbrakk>\n       \\<Longrightarrow> xs ! i' = None", "assume \"xs ! i' \\<noteq> None\""], ["proof (state)\nthis:\n  xs ! i' \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<And>i'.\n       \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc ii) ii\\<rbrakk>\n       \\<Longrightarrow> xs ! i' = None", "then"], ["proof (chain)\npicking this:\n  xs ! i' \\<noteq> None", "obtain k where K: \"xs ! i' = Some k\""], ["proof (prove)\nusing this:\n  xs ! i' \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>k. xs ! i' = Some k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"xs ! i'\") simp+"], ["proof (state)\nthis:\n  xs ! i' = Some k\n\ngoal (1 subgoal):\n 1. \\<And>i'.\n       \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc ii) ii\\<rbrakk>\n       \\<Longrightarrow> xs ! i' = None", "with H' 2(2)[of \"Suc i'\" 0 k]"], ["proof (chain)\npicking this:\n  i' < length xs\n  \\<not> tr_lookup T (i' + Suc ii) ii\n  \\<lbrakk>Suc i' < length (None # xs); 0 < length (None # xs);\n   (None # xs) ! Suc i' = Some k\\<rbrakk>\n  \\<Longrightarrow> ((None # xs) ! 0 = Some k) =\n                    (\\<not> tr_lookup T (Suc i' + ii) (0 + ii))\n  xs ! i' = Some k", "have False"], ["proof (prove)\nusing this:\n  i' < length xs\n  \\<not> tr_lookup T (i' + Suc ii) ii\n  \\<lbrakk>Suc i' < length (None # xs); 0 < length (None # xs);\n   (None # xs) ! Suc i' = Some k\\<rbrakk>\n  \\<Longrightarrow> ((None # xs) ! 0 = Some k) =\n                    (\\<not> tr_lookup T (Suc i' + ii) (0 + ii))\n  xs ! i' = Some k\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>i'.\n       \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc ii) ii\\<rbrakk>\n       \\<Longrightarrow> xs ! i' = None", "}"], ["proof (state)\nthis:\n  xs ! i' \\<noteq> None \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>i'.\n       \\<lbrakk>i' < length xs; \\<not> tr_lookup T (i' + Suc ii) ii\\<rbrakk>\n       \\<Longrightarrow> xs ! i' = None", "thus \"xs ! i' = None\""], ["proof (prove)\nusing this:\n  xs ! i' \\<noteq> None \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. xs ! i' = None", "by (cases \"xs ! i' = None\") simp+"], ["proof (state)\nthis:\n  xs ! i' = None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?i' < length xs; \\<not> tr_lookup T (?i' + Suc ii) ii\\<rbrakk>\n  \\<Longrightarrow> xs ! ?i' = None\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        j < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' xs ii (Suc ii) (length zs) T ! j =\n                          Some k) =\n                         (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?i' < length xs; \\<not> tr_lookup T (?i' + Suc ii) ii\\<rbrakk>\n  \\<Longrightarrow> xs ! ?i' = None\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        j < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' xs ii (Suc ii) (length zs) T ! j =\n                          Some k) =\n                         (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))", "have \"ii < Suc ii\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ii < Suc ii", "by simp"], ["proof (state)\nthis:\n  ii < Suc ii\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        j < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' xs ii (Suc ii) (length zs) T ! j =\n                          Some k) =\n                         (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))", "moreover"], ["proof (state)\nthis:\n  ii < Suc ii\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        j < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' xs ii (Suc ii) (length zs) T ! j =\n                          Some k) =\n                         (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))", "from H"], ["proof (chain)\npicking this:\n  i < length (mk_eqcl' xs ii (Suc ii) (length zs) T)\n  j < length (mk_eqcl' xs ii (Suc ii) (length zs) T)\n  mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k", "have \"i < length xs\""], ["proof (prove)\nusing this:\n  i < length (mk_eqcl' xs ii (Suc ii) (length zs) T)\n  j < length (mk_eqcl' xs ii (Suc ii) (length zs) T)\n  mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\n\ngoal (1 subgoal):\n 1. i < length xs", "by (simp add: mk_eqcl'_len)"], ["proof (state)\nthis:\n  i < length xs\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        j < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' xs ii (Suc ii) (length zs) T ! j =\n                          Some k) =\n                         (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))", "moreover"], ["proof (state)\nthis:\n  i < length xs\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        j < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' xs ii (Suc ii) (length zs) T ! j =\n                          Some k) =\n                         (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))", "note H(3)"], ["proof (state)\nthis:\n  mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        j < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' xs ii (Suc ii) (length zs) T ! j =\n                          Some k) =\n                         (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))", "moreover"], ["proof (state)\nthis:\n  mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        j < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' xs ii (Suc ii) (length zs) T ! j =\n                          Some k) =\n                         (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))", "from H"], ["proof (chain)\npicking this:\n  i < length (mk_eqcl' xs ii (Suc ii) (length zs) T)\n  j < length (mk_eqcl' xs ii (Suc ii) (length zs) T)\n  mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k", "have \"j < length xs\""], ["proof (prove)\nusing this:\n  i < length (mk_eqcl' xs ii (Suc ii) (length zs) T)\n  j < length (mk_eqcl' xs ii (Suc ii) (length zs) T)\n  mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\n\ngoal (1 subgoal):\n 1. j < length xs", "by (simp add: mk_eqcl'_len)"], ["proof (state)\nthis:\n  j < length xs\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        j < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\\<rbrakk>\n       \\<Longrightarrow> (mk_eqcl' xs ii (Suc ii) (length zs) T ! j =\n                          Some k) =\n                         (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i'a2 < length xs; ?j'a2 < length xs;\n   xs ! ?i'a2 = Some ?ka2\\<rbrakk>\n  \\<Longrightarrow> (xs ! ?j'a2 = Some ?ka2) =\n                    (\\<not> tr_lookup T (?i'a2 + Suc ii) (?j'a2 + Suc ii))\n  \\<lbrakk>?a \\<le> length T; ?b \\<le> length T; ?c \\<le> length T;\n   \\<not> tr_lookup T ?a ?b; \\<not> tr_lookup T ?b ?c\\<rbrakk>\n  \\<Longrightarrow> \\<not> tr_lookup T ?a ?c\n  length xs + Suc ii = length T + 1\n  \\<lbrakk>?x2 \\<in> set xs; ?x2 = Some ?ka2\\<rbrakk>\n  \\<Longrightarrow> ?ka2 < length zs\n  \\<lbrakk>?i' < length xs; \\<not> tr_lookup T (?i' + Suc ii) ii\\<rbrakk>\n  \\<Longrightarrow> xs ! ?i' = None\n  ii < Suc ii\n  i < length xs\n  mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\n  j < length xs", "show \"(mk_eqcl' xs ii (Suc ii) (length zs) T ! j = Some k) = (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i'a2 < length xs; ?j'a2 < length xs;\n   xs ! ?i'a2 = Some ?ka2\\<rbrakk>\n  \\<Longrightarrow> (xs ! ?j'a2 = Some ?ka2) =\n                    (\\<not> tr_lookup T (?i'a2 + Suc ii) (?j'a2 + Suc ii))\n  \\<lbrakk>?a \\<le> length T; ?b \\<le> length T; ?c \\<le> length T;\n   \\<not> tr_lookup T ?a ?b; \\<not> tr_lookup T ?b ?c\\<rbrakk>\n  \\<Longrightarrow> \\<not> tr_lookup T ?a ?c\n  length xs + Suc ii = length T + 1\n  \\<lbrakk>?x2 \\<in> set xs; ?x2 = Some ?ka2\\<rbrakk>\n  \\<Longrightarrow> ?ka2 < length zs\n  \\<lbrakk>?i' < length xs; \\<not> tr_lookup T (?i' + Suc ii) ii\\<rbrakk>\n  \\<Longrightarrow> xs ! ?i' = None\n  ii < Suc ii\n  i < length xs\n  mk_eqcl' xs ii (Suc ii) (length zs) T ! i = Some k\n  j < length xs\n\ngoal (1 subgoal):\n 1. (mk_eqcl' xs ii (Suc ii) (length zs) T ! j = Some k) =\n    (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))", "by (rule mk_eqcl'_nth)"], ["proof (state)\nthis:\n  (mk_eqcl' xs ii (Suc ii) (length zs) T ! j = Some k) =\n  (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?i < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n   ?j < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n   mk_eqcl' xs ii (Suc ii) (length zs) T ! ?i = Some ?k\\<rbrakk>\n  \\<Longrightarrow> (mk_eqcl' xs ii (Suc ii) (length zs) T ! ?j = Some ?k) =\n                    (\\<not> tr_lookup T (?i + Suc ii) (?j + Suc ii))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (None # xs) zs ii T) ! i =\n        fst (mk_eqcl (None # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?i < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n   ?j < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n   mk_eqcl' xs ii (Suc ii) (length zs) T ! ?i = Some ?k\\<rbrakk>\n  \\<Longrightarrow> (mk_eqcl' xs ii (Suc ii) (length zs) T ! ?j = Some ?k) =\n                    (\\<not> tr_lookup T (?i + Suc ii) (?j + Suc ii))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (None # xs) zs ii T) ! i =\n        fst (mk_eqcl (None # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "note 2(3)"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<le> length T; ?b \\<le> length T; ?c \\<le> length T;\n   \\<not> tr_lookup T ?a ?b; \\<not> tr_lookup T ?b ?c\\<rbrakk>\n  \\<Longrightarrow> \\<not> tr_lookup T ?a ?c\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (None # xs) zs ii T) ! i =\n        fst (mk_eqcl (None # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<le> length T; ?b \\<le> length T; ?c \\<le> length T;\n   \\<not> tr_lookup T ?a ?b; \\<not> tr_lookup T ?b ?c\\<rbrakk>\n  \\<Longrightarrow> \\<not> tr_lookup T ?a ?c\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (None # xs) zs ii T) ! i =\n        fst (mk_eqcl (None # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "have \"\\<And>x k. \\<lbrakk>x \\<in> set (mk_eqcl' xs ii (Suc ii) (length zs) T); x = Some k\\<rbrakk> \\<Longrightarrow> k < length (zs @ [ii])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x k.\n       \\<lbrakk>x \\<in> set (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        x = Some k\\<rbrakk>\n       \\<Longrightarrow> k < length (zs @ [ii])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x k.\n       \\<lbrakk>x \\<in> set (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        x = Some k\\<rbrakk>\n       \\<Longrightarrow> k < length (zs @ [ii])", "fix x k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x k.\n       \\<lbrakk>x \\<in> set (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        x = Some k\\<rbrakk>\n       \\<Longrightarrow> k < length (zs @ [ii])", "assume H: \"x \\<in> set (mk_eqcl' xs ii (Suc ii) (length zs) T)\" \"x = Some k\""], ["proof (state)\nthis:\n  x \\<in> set (mk_eqcl' xs ii (Suc ii) (length zs) T)\n  x = Some k\n\ngoal (1 subgoal):\n 1. \\<And>x k.\n       \\<lbrakk>x \\<in> set (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        x = Some k\\<rbrakk>\n       \\<Longrightarrow> k < length (zs @ [ii])", "{"], ["proof (state)\nthis:\n  x \\<in> set (mk_eqcl' xs ii (Suc ii) (length zs) T)\n  x = Some k\n\ngoal (1 subgoal):\n 1. \\<And>x k.\n       \\<lbrakk>x \\<in> set (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        x = Some k\\<rbrakk>\n       \\<Longrightarrow> k < length (zs @ [ii])", "fix x k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x k.\n       \\<lbrakk>x \\<in> set (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        x = Some k\\<rbrakk>\n       \\<Longrightarrow> k < length (zs @ [ii])", "assume \"x \\<in> set xs\" \"x = Some k\""], ["proof (state)\nthis:\n  x \\<in> set xs\n  x = Some k\n\ngoal (1 subgoal):\n 1. \\<And>x k.\n       \\<lbrakk>x \\<in> set (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        x = Some k\\<rbrakk>\n       \\<Longrightarrow> k < length (zs @ [ii])", "with 2(4)[of x k]"], ["proof (chain)\npicking this:\n  \\<lbrakk>x \\<in> set (None # xs); x = Some k\\<rbrakk>\n  \\<Longrightarrow> k < length zs\n  x \\<in> set xs\n  x = Some k", "have \"k < length zs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<in> set (None # xs); x = Some k\\<rbrakk>\n  \\<Longrightarrow> k < length zs\n  x \\<in> set xs\n  x = Some k\n\ngoal (1 subgoal):\n 1. k < length zs", "by simp"], ["proof (state)\nthis:\n  k < length zs\n\ngoal (1 subgoal):\n 1. \\<And>x k.\n       \\<lbrakk>x \\<in> set (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        x = Some k\\<rbrakk>\n       \\<Longrightarrow> k < length (zs @ [ii])", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?xa2 \\<in> set xs; ?xa2 = Some ?ka2\\<rbrakk>\n  \\<Longrightarrow> ?ka2 < length zs\n\ngoal (1 subgoal):\n 1. \\<And>x k.\n       \\<lbrakk>x \\<in> set (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        x = Some k\\<rbrakk>\n       \\<Longrightarrow> k < length (zs @ [ii])", "from this H"], ["proof (chain)\npicking this:\n  \\<lbrakk>?xa2 \\<in> set xs; ?xa2 = Some ?ka2\\<rbrakk>\n  \\<Longrightarrow> ?ka2 < length zs\n  x \\<in> set (mk_eqcl' xs ii (Suc ii) (length zs) T)\n  x = Some k", "have \"k \\<le> length zs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?xa2 \\<in> set xs; ?xa2 = Some ?ka2\\<rbrakk>\n  \\<Longrightarrow> ?ka2 < length zs\n  x \\<in> set (mk_eqcl' xs ii (Suc ii) (length zs) T)\n  x = Some k\n\ngoal (1 subgoal):\n 1. k \\<le> length zs", "by (rule mk_eqcl'_bound)"], ["proof (state)\nthis:\n  k \\<le> length zs\n\ngoal (1 subgoal):\n 1. \\<And>x k.\n       \\<lbrakk>x \\<in> set (mk_eqcl' xs ii (Suc ii) (length zs) T);\n        x = Some k\\<rbrakk>\n       \\<Longrightarrow> k < length (zs @ [ii])", "thus \"k < length (zs @ [ii])\""], ["proof (prove)\nusing this:\n  k \\<le> length zs\n\ngoal (1 subgoal):\n 1. k < length (zs @ [ii])", "by simp"], ["proof (state)\nthis:\n  k < length (zs @ [ii])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> set (mk_eqcl' xs ii (Suc ii) (length zs) T);\n   ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length (zs @ [ii])\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (None # xs) zs ii T) ! i =\n        fst (mk_eqcl (None # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> set (mk_eqcl' xs ii (Suc ii) (length zs) T);\n   ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length (zs @ [ii])\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (None # xs) zs ii T) ! i =\n        fst (mk_eqcl (None # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "from 2(5)"], ["proof (chain)\npicking this:\n  length (None # xs) + ii = length T + 1", "have \"length (mk_eqcl' xs ii (Suc ii) (length zs) T) + Suc ii = length T + 1\""], ["proof (prove)\nusing this:\n  length (None # xs) + ii = length T + 1\n\ngoal (1 subgoal):\n 1. length (mk_eqcl' xs ii (Suc ii) (length zs) T) + Suc ii = length T + 1", "by (simp add: mk_eqcl'_len)"], ["proof (state)\nthis:\n  length (mk_eqcl' xs ii (Suc ii) (length zs) T) + Suc ii = length T + 1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (None # xs) zs ii T) ! i =\n        fst (mk_eqcl (None # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "moreover"], ["proof (state)\nthis:\n  length (mk_eqcl' xs ii (Suc ii) (length zs) T) + Suc ii = length T + 1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (None # xs) zs ii T) ! i =\n        fst (mk_eqcl (None # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "from H Suc J"], ["proof (chain)\npicking this:\n  i < j\n  j < length (None # xs)\n  i = Suc i'\n  j = Suc j'", "have \"i' < length (mk_eqcl' xs ii (Suc ii) (length zs) T)\" \"j' < length (mk_eqcl' xs ii (Suc ii) (length zs) T)\""], ["proof (prove)\nusing this:\n  i < j\n  j < length (None # xs)\n  i = Suc i'\n  j = Suc j'\n\ngoal (1 subgoal):\n 1. i' < length (mk_eqcl' xs ii (Suc ii) (length zs) T) &&&\n    j' < length (mk_eqcl' xs ii (Suc ii) (length zs) T)", "by (simp add: mk_eqcl'_len)+"], ["proof (state)\nthis:\n  i' < length (mk_eqcl' xs ii (Suc ii) (length zs) T)\n  j' < length (mk_eqcl' xs ii (Suc ii) (length zs) T)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (None # xs) zs ii T) ! i =\n        fst (mk_eqcl (None # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n   ?j < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n   mk_eqcl' xs ii (Suc ii) (length zs) T ! ?i = Some ?k\\<rbrakk>\n  \\<Longrightarrow> (mk_eqcl' xs ii (Suc ii) (length zs) T ! ?j = Some ?k) =\n                    (\\<not> tr_lookup T (?i + Suc ii) (?j + Suc ii))\n  \\<lbrakk>?a \\<le> length T; ?b \\<le> length T; ?c \\<le> length T;\n   \\<not> tr_lookup T ?a ?b; \\<not> tr_lookup T ?b ?c\\<rbrakk>\n  \\<Longrightarrow> \\<not> tr_lookup T ?a ?c\n  \\<lbrakk>?x \\<in> set (mk_eqcl' xs ii (Suc ii) (length zs) T);\n   ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length (zs @ [ii])\n  length (mk_eqcl' xs ii (Suc ii) (length zs) T) + Suc ii = length T + 1\n  i' < length (mk_eqcl' xs ii (Suc ii) (length zs) T)\n  j' < length (mk_eqcl' xs ii (Suc ii) (length zs) T)", "have IV: \"(fst (mk_eqcl (mk_eqcl' xs ii (Suc ii) (length zs) T) (zs @ [ii]) (Suc ii) T) ! i' = fst (mk_eqcl (mk_eqcl' xs ii (Suc ii) (length zs) T) (zs @ [ii]) (Suc ii) T) ! j') =\n        (\\<not> tr_lookup T (i' + Suc ii) (j' + Suc ii))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n   ?j < length (mk_eqcl' xs ii (Suc ii) (length zs) T);\n   mk_eqcl' xs ii (Suc ii) (length zs) T ! ?i = Some ?k\\<rbrakk>\n  \\<Longrightarrow> (mk_eqcl' xs ii (Suc ii) (length zs) T ! ?j = Some ?k) =\n                    (\\<not> tr_lookup T (?i + Suc ii) (?j + Suc ii))\n  \\<lbrakk>?a \\<le> length T; ?b \\<le> length T; ?c \\<le> length T;\n   \\<not> tr_lookup T ?a ?b; \\<not> tr_lookup T ?b ?c\\<rbrakk>\n  \\<Longrightarrow> \\<not> tr_lookup T ?a ?c\n  \\<lbrakk>?x \\<in> set (mk_eqcl' xs ii (Suc ii) (length zs) T);\n   ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length (zs @ [ii])\n  length (mk_eqcl' xs ii (Suc ii) (length zs) T) + Suc ii = length T + 1\n  i' < length (mk_eqcl' xs ii (Suc ii) (length zs) T)\n  j' < length (mk_eqcl' xs ii (Suc ii) (length zs) T)\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (mk_eqcl' xs ii (Suc ii) (length zs) T) (zs @ [ii])\n           (Suc ii) T) !\n     i' =\n     fst (mk_eqcl (mk_eqcl' xs ii (Suc ii) (length zs) T) (zs @ [ii])\n           (Suc ii) T) !\n     j') =\n    (\\<not> tr_lookup T (i' + Suc ii) (j' + Suc ii))", "by (rule 2(1))"], ["proof (state)\nthis:\n  (fst (mk_eqcl (mk_eqcl' xs ii (Suc ii) (length zs) T) (zs @ [ii]) (Suc ii)\n         T) !\n   i' =\n   fst (mk_eqcl (mk_eqcl' xs ii (Suc ii) (length zs) T) (zs @ [ii]) (Suc ii)\n         T) !\n   j') =\n  (\\<not> tr_lookup T (i' + Suc ii) (j' + Suc ii))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (None # xs) zs ii T) ! i =\n        fst (mk_eqcl (None # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "with Suc J"], ["proof (chain)\npicking this:\n  i = Suc i'\n  j = Suc j'\n  (fst (mk_eqcl (mk_eqcl' xs ii (Suc ii) (length zs) T) (zs @ [ii]) (Suc ii)\n         T) !\n   i' =\n   fst (mk_eqcl (mk_eqcl' xs ii (Suc ii) (length zs) T) (zs @ [ii]) (Suc ii)\n         T) !\n   j') =\n  (\\<not> tr_lookup T (i' + Suc ii) (j' + Suc ii))", "show ?thesis"], ["proof (prove)\nusing this:\n  i = Suc i'\n  j = Suc j'\n  (fst (mk_eqcl (mk_eqcl' xs ii (Suc ii) (length zs) T) (zs @ [ii]) (Suc ii)\n         T) !\n   i' =\n   fst (mk_eqcl (mk_eqcl' xs ii (Suc ii) (length zs) T) (zs @ [ii]) (Suc ii)\n         T) !\n   j') =\n  (\\<not> tr_lookup T (i' + Suc ii) (j' + Suc ii))\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (None # xs) zs ii T) ! i =\n     fst (mk_eqcl (None # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))", "by (simp add: split_beta)"], ["proof (state)\nthis:\n  (fst (mk_eqcl (None # xs) zs ii T) ! i =\n   fst (mk_eqcl (None # xs) zs ii T) ! j) =\n  (\\<not> tr_lookup T (i + ii) (j + ii))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (fst (mk_eqcl (None # xs) zs ii T) ! i =\n   fst (mk_eqcl (None # xs) zs ii T) ! j) =\n  (\\<not> tr_lookup T (i + ii) (j + ii))\n\ngoal (2 subgoals):\n 1. \\<And>xs zs i T ia j.\n       \\<lbrakk>\\<And>ia j.\n                   \\<lbrakk>\\<And>ia j k.\n                               \\<lbrakk>ia\n  < length (mk_eqcl' xs i (Suc i) (length zs) T);\n                                j < length\n                                     (mk_eqcl' xs i (Suc i) (length zs) T);\n                                mk_eqcl' xs i (Suc i) (length zs) T ! ia =\n                                Some k\\<rbrakk>\n                               \\<Longrightarrow> (mk_eqcl' xs i (Suc i)\n             (length zs) T !\n            j =\n            Some k) =\n           (\\<not> tr_lookup T (ia + Suc i) (j + Suc i));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set\n   (mk_eqcl' xs i (Suc i) (length zs) T);\n                        x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < length (zs @ [i]);\n                    length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i =\n                    length T + 1;\n                    ia < length (mk_eqcl' xs i (Suc i) (length zs) T);\n                    j < length\n                         (mk_eqcl' xs i (Suc i) (length zs) T)\\<rbrakk>\n                   \\<Longrightarrow> (fst\n (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\nia =\nfst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\nj) =\n                                     (\\<not> tr_lookup T (ia + Suc i)\n        (j + Suc i));\n        \\<And>ia j k.\n           \\<lbrakk>ia < length (None # xs); j < length (None # xs);\n            (None # xs) ! ia = Some k\\<rbrakk>\n           \\<Longrightarrow> ((None # xs) ! j = Some k) =\n                             (\\<not> tr_lookup T (ia + i) (j + i));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (None # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        length (None # xs) + i = length T + 1; ia < length (None # xs);\n        j < length (None # xs)\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (None # xs) zs i T) ! ia =\n                          fst (mk_eqcl (None # xs) zs i T) ! j) =\n                         (\\<not> tr_lookup T (ia + i) (j + i))\n 2. \\<And>l xs zs i T ia j.\n       \\<lbrakk>\\<And>ia j.\n                   \\<lbrakk>\\<And>ia j k.\n                               \\<lbrakk>ia < length xs; j < length xs;\n                                xs ! ia = Some k\\<rbrakk>\n                               \\<Longrightarrow> (xs ! j = Some k) =\n           (\\<not> tr_lookup T (ia + Suc i) (j + Suc i));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < length zs;\n                    length xs + Suc i = length T + 1; ia < length xs;\n                    j < length xs\\<rbrakk>\n                   \\<Longrightarrow> (fst (mk_eqcl xs zs (Suc i) T) ! ia =\nfst (mk_eqcl xs zs (Suc i) T) ! j) =\n                                     (\\<not> tr_lookup T (ia + Suc i)\n        (j + Suc i));\n        \\<And>ia j k.\n           \\<lbrakk>ia < length (Some l # xs); j < length (Some l # xs);\n            (Some l # xs) ! ia = Some k\\<rbrakk>\n           \\<Longrightarrow> ((Some l # xs) ! j = Some k) =\n                             (\\<not> tr_lookup T (ia + i) (j + i));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (Some l # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        length (Some l # xs) + i = length T + 1; ia < length (Some l # xs);\n        j < length (Some l # xs)\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (Some l # xs) zs i T) ! ia =\n                          fst (mk_eqcl (Some l # xs) zs i T) ! j) =\n                         (\\<not> tr_lookup T (ia + i) (j + i))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?ib2 < ?jb2; ?jb2 < length (None # xs)\\<rbrakk>\n  \\<Longrightarrow> (fst (mk_eqcl (None # xs) zs ii T) ! ?ib2 =\n                     fst (mk_eqcl (None # xs) zs ii T) ! ?jb2) =\n                    (\\<not> tr_lookup T (?ib2 + ii) (?jb2 + ii))\n\ngoal (2 subgoals):\n 1. \\<And>xs zs i T ia j.\n       \\<lbrakk>\\<And>ia j.\n                   \\<lbrakk>\\<And>ia j k.\n                               \\<lbrakk>ia\n  < length (mk_eqcl' xs i (Suc i) (length zs) T);\n                                j < length\n                                     (mk_eqcl' xs i (Suc i) (length zs) T);\n                                mk_eqcl' xs i (Suc i) (length zs) T ! ia =\n                                Some k\\<rbrakk>\n                               \\<Longrightarrow> (mk_eqcl' xs i (Suc i)\n             (length zs) T !\n            j =\n            Some k) =\n           (\\<not> tr_lookup T (ia + Suc i) (j + Suc i));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set\n   (mk_eqcl' xs i (Suc i) (length zs) T);\n                        x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < length (zs @ [i]);\n                    length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i =\n                    length T + 1;\n                    ia < length (mk_eqcl' xs i (Suc i) (length zs) T);\n                    j < length\n                         (mk_eqcl' xs i (Suc i) (length zs) T)\\<rbrakk>\n                   \\<Longrightarrow> (fst\n (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\nia =\nfst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\nj) =\n                                     (\\<not> tr_lookup T (ia + Suc i)\n        (j + Suc i));\n        \\<And>ia j k.\n           \\<lbrakk>ia < length (None # xs); j < length (None # xs);\n            (None # xs) ! ia = Some k\\<rbrakk>\n           \\<Longrightarrow> ((None # xs) ! j = Some k) =\n                             (\\<not> tr_lookup T (ia + i) (j + i));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (None # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        length (None # xs) + i = length T + 1; ia < length (None # xs);\n        j < length (None # xs)\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (None # xs) zs i T) ! ia =\n                          fst (mk_eqcl (None # xs) zs i T) ! j) =\n                         (\\<not> tr_lookup T (ia + i) (j + i))\n 2. \\<And>l xs zs i T ia j.\n       \\<lbrakk>\\<And>ia j.\n                   \\<lbrakk>\\<And>ia j k.\n                               \\<lbrakk>ia < length xs; j < length xs;\n                                xs ! ia = Some k\\<rbrakk>\n                               \\<Longrightarrow> (xs ! j = Some k) =\n           (\\<not> tr_lookup T (ia + Suc i) (j + Suc i));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < length zs;\n                    length xs + Suc i = length T + 1; ia < length xs;\n                    j < length xs\\<rbrakk>\n                   \\<Longrightarrow> (fst (mk_eqcl xs zs (Suc i) T) ! ia =\nfst (mk_eqcl xs zs (Suc i) T) ! j) =\n                                     (\\<not> tr_lookup T (ia + Suc i)\n        (j + Suc i));\n        \\<And>ia j k.\n           \\<lbrakk>ia < length (Some l # xs); j < length (Some l # xs);\n            (Some l # xs) ! ia = Some k\\<rbrakk>\n           \\<Longrightarrow> ((Some l # xs) ! j = Some k) =\n                             (\\<not> tr_lookup T (ia + i) (j + i));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (Some l # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        length (Some l # xs) + i = length T + 1; ia < length (Some l # xs);\n        j < length (Some l # xs)\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (Some l # xs) zs i T) ! ia =\n                          fst (mk_eqcl (Some l # xs) zs i T) ! j) =\n                         (\\<not> tr_lookup T (ia + i) (j + i))", "note L = this"], ["proof (state)\nthis:\n  \\<lbrakk>?ib2 < ?jb2; ?jb2 < length (None # xs)\\<rbrakk>\n  \\<Longrightarrow> (fst (mk_eqcl (None # xs) zs ii T) ! ?ib2 =\n                     fst (mk_eqcl (None # xs) zs ii T) ! ?jb2) =\n                    (\\<not> tr_lookup T (?ib2 + ii) (?jb2 + ii))\n\ngoal (2 subgoals):\n 1. \\<And>xs zs i T ia j.\n       \\<lbrakk>\\<And>ia j.\n                   \\<lbrakk>\\<And>ia j k.\n                               \\<lbrakk>ia\n  < length (mk_eqcl' xs i (Suc i) (length zs) T);\n                                j < length\n                                     (mk_eqcl' xs i (Suc i) (length zs) T);\n                                mk_eqcl' xs i (Suc i) (length zs) T ! ia =\n                                Some k\\<rbrakk>\n                               \\<Longrightarrow> (mk_eqcl' xs i (Suc i)\n             (length zs) T !\n            j =\n            Some k) =\n           (\\<not> tr_lookup T (ia + Suc i) (j + Suc i));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set\n   (mk_eqcl' xs i (Suc i) (length zs) T);\n                        x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < length (zs @ [i]);\n                    length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i =\n                    length T + 1;\n                    ia < length (mk_eqcl' xs i (Suc i) (length zs) T);\n                    j < length\n                         (mk_eqcl' xs i (Suc i) (length zs) T)\\<rbrakk>\n                   \\<Longrightarrow> (fst\n (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\nia =\nfst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\nj) =\n                                     (\\<not> tr_lookup T (ia + Suc i)\n        (j + Suc i));\n        \\<And>ia j k.\n           \\<lbrakk>ia < length (None # xs); j < length (None # xs);\n            (None # xs) ! ia = Some k\\<rbrakk>\n           \\<Longrightarrow> ((None # xs) ! j = Some k) =\n                             (\\<not> tr_lookup T (ia + i) (j + i));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (None # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        length (None # xs) + i = length T + 1; ia < length (None # xs);\n        j < length (None # xs)\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (None # xs) zs i T) ! ia =\n                          fst (mk_eqcl (None # xs) zs i T) ! j) =\n                         (\\<not> tr_lookup T (ia + i) (j + i))\n 2. \\<And>l xs zs i T ia j.\n       \\<lbrakk>\\<And>ia j.\n                   \\<lbrakk>\\<And>ia j k.\n                               \\<lbrakk>ia < length xs; j < length xs;\n                                xs ! ia = Some k\\<rbrakk>\n                               \\<Longrightarrow> (xs ! j = Some k) =\n           (\\<not> tr_lookup T (ia + Suc i) (j + Suc i));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < length zs;\n                    length xs + Suc i = length T + 1; ia < length xs;\n                    j < length xs\\<rbrakk>\n                   \\<Longrightarrow> (fst (mk_eqcl xs zs (Suc i) T) ! ia =\nfst (mk_eqcl xs zs (Suc i) T) ! j) =\n                                     (\\<not> tr_lookup T (ia + Suc i)\n        (j + Suc i));\n        \\<And>ia j k.\n           \\<lbrakk>ia < length (Some l # xs); j < length (Some l # xs);\n            (Some l # xs) ! ia = Some k\\<rbrakk>\n           \\<Longrightarrow> ((Some l # xs) ! j = Some k) =\n                             (\\<not> tr_lookup T (ia + i) (j + i));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (Some l # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        length (Some l # xs) + i = length T + 1; ia < length (Some l # xs);\n        j < length (Some l # xs)\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (Some l # xs) zs i T) ! ia =\n                          fst (mk_eqcl (Some l # xs) zs i T) ! j) =\n                         (\\<not> tr_lookup T (ia + i) (j + i))", "have \"i < j \\<or> i = j \\<or> i > j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < j \\<or> i = j \\<or> j < i", "by auto"], ["proof (state)\nthis:\n  i < j \\<or> i = j \\<or> j < i\n\ngoal (2 subgoals):\n 1. \\<And>xs zs i T ia j.\n       \\<lbrakk>\\<And>ia j.\n                   \\<lbrakk>\\<And>ia j k.\n                               \\<lbrakk>ia\n  < length (mk_eqcl' xs i (Suc i) (length zs) T);\n                                j < length\n                                     (mk_eqcl' xs i (Suc i) (length zs) T);\n                                mk_eqcl' xs i (Suc i) (length zs) T ! ia =\n                                Some k\\<rbrakk>\n                               \\<Longrightarrow> (mk_eqcl' xs i (Suc i)\n             (length zs) T !\n            j =\n            Some k) =\n           (\\<not> tr_lookup T (ia + Suc i) (j + Suc i));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set\n   (mk_eqcl' xs i (Suc i) (length zs) T);\n                        x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < length (zs @ [i]);\n                    length (mk_eqcl' xs i (Suc i) (length zs) T) + Suc i =\n                    length T + 1;\n                    ia < length (mk_eqcl' xs i (Suc i) (length zs) T);\n                    j < length\n                         (mk_eqcl' xs i (Suc i) (length zs) T)\\<rbrakk>\n                   \\<Longrightarrow> (fst\n (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\nia =\nfst (mk_eqcl (mk_eqcl' xs i (Suc i) (length zs) T) (zs @ [i]) (Suc i) T) !\nj) =\n                                     (\\<not> tr_lookup T (ia + Suc i)\n        (j + Suc i));\n        \\<And>ia j k.\n           \\<lbrakk>ia < length (None # xs); j < length (None # xs);\n            (None # xs) ! ia = Some k\\<rbrakk>\n           \\<Longrightarrow> ((None # xs) ! j = Some k) =\n                             (\\<not> tr_lookup T (ia + i) (j + i));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (None # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        length (None # xs) + i = length T + 1; ia < length (None # xs);\n        j < length (None # xs)\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (None # xs) zs i T) ! ia =\n                          fst (mk_eqcl (None # xs) zs i T) ! j) =\n                         (\\<not> tr_lookup T (ia + i) (j + i))\n 2. \\<And>l xs zs i T ia j.\n       \\<lbrakk>\\<And>ia j.\n                   \\<lbrakk>\\<And>ia j k.\n                               \\<lbrakk>ia < length xs; j < length xs;\n                                xs ! ia = Some k\\<rbrakk>\n                               \\<Longrightarrow> (xs ! j = Some k) =\n           (\\<not> tr_lookup T (ia + Suc i) (j + Suc i));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < length zs;\n                    length xs + Suc i = length T + 1; ia < length xs;\n                    j < length xs\\<rbrakk>\n                   \\<Longrightarrow> (fst (mk_eqcl xs zs (Suc i) T) ! ia =\nfst (mk_eqcl xs zs (Suc i) T) ! j) =\n                                     (\\<not> tr_lookup T (ia + Suc i)\n        (j + Suc i));\n        \\<And>ia j k.\n           \\<lbrakk>ia < length (Some l # xs); j < length (Some l # xs);\n            (Some l # xs) ! ia = Some k\\<rbrakk>\n           \\<Longrightarrow> ((Some l # xs) ! j = Some k) =\n                             (\\<not> tr_lookup T (ia + i) (j + i));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (Some l # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        length (Some l # xs) + i = length T + 1; ia < length (Some l # xs);\n        j < length (Some l # xs)\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (Some l # xs) zs i T) ! ia =\n                          fst (mk_eqcl (Some l # xs) zs i T) ! j) =\n                         (\\<not> tr_lookup T (ia + i) (j + i))", "thus ?case"], ["proof (prove)\nusing this:\n  i < j \\<or> i = j \\<or> j < i\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (None # xs) zs ii T) ! i =\n     fst (mk_eqcl (None # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))", "proof (elim disjE)"], ["proof (state)\ngoal (3 subgoals):\n 1. i < j \\<Longrightarrow>\n    (fst (mk_eqcl (None # xs) zs ii T) ! i =\n     fst (mk_eqcl (None # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))\n 2. i = j \\<Longrightarrow>\n    (fst (mk_eqcl (None # xs) zs ii T) ! i =\n     fst (mk_eqcl (None # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))\n 3. j < i \\<Longrightarrow>\n    (fst (mk_eqcl (None # xs) zs ii T) ! i =\n     fst (mk_eqcl (None # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))", "assume \"i > j\""], ["proof (state)\nthis:\n  j < i\n\ngoal (3 subgoals):\n 1. i < j \\<Longrightarrow>\n    (fst (mk_eqcl (None # xs) zs ii T) ! i =\n     fst (mk_eqcl (None # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))\n 2. i = j \\<Longrightarrow>\n    (fst (mk_eqcl (None # xs) zs ii T) ! i =\n     fst (mk_eqcl (None # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))\n 3. j < i \\<Longrightarrow>\n    (fst (mk_eqcl (None # xs) zs ii T) ! i =\n     fst (mk_eqcl (None # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))", "with 2(6) L"], ["proof (chain)\npicking this:\n  i < length (None # xs)\n  \\<lbrakk>?ib2 < ?jb2; ?jb2 < length (None # xs)\\<rbrakk>\n  \\<Longrightarrow> (fst (mk_eqcl (None # xs) zs ii T) ! ?ib2 =\n                     fst (mk_eqcl (None # xs) zs ii T) ! ?jb2) =\n                    (\\<not> tr_lookup T (?ib2 + ii) (?jb2 + ii))\n  j < i", "have \"(fst (mk_eqcl (None # xs) zs ii T) ! j = fst (mk_eqcl (None # xs) zs ii T) ! i) = (\\<not> tr_lookup T (i + ii) (j + ii))\""], ["proof (prove)\nusing this:\n  i < length (None # xs)\n  \\<lbrakk>?ib2 < ?jb2; ?jb2 < length (None # xs)\\<rbrakk>\n  \\<Longrightarrow> (fst (mk_eqcl (None # xs) zs ii T) ! ?ib2 =\n                     fst (mk_eqcl (None # xs) zs ii T) ! ?jb2) =\n                    (\\<not> tr_lookup T (?ib2 + ii) (?jb2 + ii))\n  j < i\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (None # xs) zs ii T) ! j =\n     fst (mk_eqcl (None # xs) zs ii T) ! i) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))", "by (auto simp: tr_lookup_def)"], ["proof (state)\nthis:\n  (fst (mk_eqcl (None # xs) zs ii T) ! j =\n   fst (mk_eqcl (None # xs) zs ii T) ! i) =\n  (\\<not> tr_lookup T (i + ii) (j + ii))\n\ngoal (3 subgoals):\n 1. i < j \\<Longrightarrow>\n    (fst (mk_eqcl (None # xs) zs ii T) ! i =\n     fst (mk_eqcl (None # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))\n 2. i = j \\<Longrightarrow>\n    (fst (mk_eqcl (None # xs) zs ii T) ! i =\n     fst (mk_eqcl (None # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))\n 3. j < i \\<Longrightarrow>\n    (fst (mk_eqcl (None # xs) zs ii T) ! i =\n     fst (mk_eqcl (None # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (fst (mk_eqcl (None # xs) zs ii T) ! j =\n   fst (mk_eqcl (None # xs) zs ii T) ! i) =\n  (\\<not> tr_lookup T (i + ii) (j + ii))\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (None # xs) zs ii T) ! i =\n     fst (mk_eqcl (None # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))", "by auto"], ["proof (state)\nthis:\n  (fst (mk_eqcl (None # xs) zs ii T) ! i =\n   fst (mk_eqcl (None # xs) zs ii T) ! j) =\n  (\\<not> tr_lookup T (i + ii) (j + ii))\n\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow>\n    (fst (mk_eqcl (None # xs) zs ii T) ! i =\n     fst (mk_eqcl (None # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))\n 2. i = j \\<Longrightarrow>\n    (fst (mk_eqcl (None # xs) zs ii T) ! i =\n     fst (mk_eqcl (None # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))", "qed (insert 2(7) L, simp add: tr_lookup_def)+"], ["proof (state)\nthis:\n  (fst (mk_eqcl (None # xs) zs ii T) ! i =\n   fst (mk_eqcl (None # xs) zs ii T) ! j) =\n  (\\<not> tr_lookup T (i + ii) (j + ii))\n\ngoal (1 subgoal):\n 1. \\<And>l xs zs i T ia j.\n       \\<lbrakk>\\<And>ia j.\n                   \\<lbrakk>\\<And>ia j k.\n                               \\<lbrakk>ia < length xs; j < length xs;\n                                xs ! ia = Some k\\<rbrakk>\n                               \\<Longrightarrow> (xs ! j = Some k) =\n           (\\<not> tr_lookup T (ia + Suc i) (j + Suc i));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < length zs;\n                    length xs + Suc i = length T + 1; ia < length xs;\n                    j < length xs\\<rbrakk>\n                   \\<Longrightarrow> (fst (mk_eqcl xs zs (Suc i) T) ! ia =\nfst (mk_eqcl xs zs (Suc i) T) ! j) =\n                                     (\\<not> tr_lookup T (ia + Suc i)\n        (j + Suc i));\n        \\<And>ia j k.\n           \\<lbrakk>ia < length (Some l # xs); j < length (Some l # xs);\n            (Some l # xs) ! ia = Some k\\<rbrakk>\n           \\<Longrightarrow> ((Some l # xs) ! j = Some k) =\n                             (\\<not> tr_lookup T (ia + i) (j + i));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (Some l # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        length (Some l # xs) + i = length T + 1; ia < length (Some l # xs);\n        j < length (Some l # xs)\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (Some l # xs) zs i T) ! ia =\n                          fst (mk_eqcl (Some l # xs) zs i T) ! j) =\n                         (\\<not> tr_lookup T (ia + i) (j + i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l xs zs i T ia j.\n       \\<lbrakk>\\<And>ia j.\n                   \\<lbrakk>\\<And>ia j k.\n                               \\<lbrakk>ia < length xs; j < length xs;\n                                xs ! ia = Some k\\<rbrakk>\n                               \\<Longrightarrow> (xs ! j = Some k) =\n           (\\<not> tr_lookup T (ia + Suc i) (j + Suc i));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < length zs;\n                    length xs + Suc i = length T + 1; ia < length xs;\n                    j < length xs\\<rbrakk>\n                   \\<Longrightarrow> (fst (mk_eqcl xs zs (Suc i) T) ! ia =\nfst (mk_eqcl xs zs (Suc i) T) ! j) =\n                                     (\\<not> tr_lookup T (ia + Suc i)\n        (j + Suc i));\n        \\<And>ia j k.\n           \\<lbrakk>ia < length (Some l # xs); j < length (Some l # xs);\n            (Some l # xs) ! ia = Some k\\<rbrakk>\n           \\<Longrightarrow> ((Some l # xs) ! j = Some k) =\n                             (\\<not> tr_lookup T (ia + i) (j + i));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (Some l # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        length (Some l # xs) + i = length T + 1; ia < length (Some l # xs);\n        j < length (Some l # xs)\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (Some l # xs) zs i T) ! ia =\n                          fst (mk_eqcl (Some l # xs) zs i T) ! j) =\n                         (\\<not> tr_lookup T (ia + i) (j + i))", "case (3 l xs zs ii T i j)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>i j k.\n              \\<lbrakk>i < length xs; j < length xs;\n               xs ! i = Some k\\<rbrakk>\n              \\<Longrightarrow> (xs ! j = Some k) =\n                                (\\<not> tr_lookup T (i + Suc ii)\n   (j + Suc ii));\n   \\<And>a b c.\n      \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n       \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n      \\<Longrightarrow> \\<not> tr_lookup T a c;\n   \\<And>x k.\n      \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n      \\<Longrightarrow> k < length zs;\n   length xs + Suc ii = length T + 1; ?i < length xs;\n   ?j < length xs\\<rbrakk>\n  \\<Longrightarrow> (fst (mk_eqcl xs zs (Suc ii) T) ! ?i =\n                     fst (mk_eqcl xs zs (Suc ii) T) ! ?j) =\n                    (\\<not> tr_lookup T (?i + Suc ii) (?j + Suc ii))\n  \\<lbrakk>?i < length (Some l # xs); ?j < length (Some l # xs);\n   (Some l # xs) ! ?i = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ((Some l # xs) ! ?j = Some ?k) =\n                    (\\<not> tr_lookup T (?i + ii) (?j + ii))\n  \\<lbrakk>?a \\<le> length T; ?b \\<le> length T; ?c \\<le> length T;\n   \\<not> tr_lookup T ?a ?b; \\<not> tr_lookup T ?b ?c\\<rbrakk>\n  \\<Longrightarrow> \\<not> tr_lookup T ?a ?c\n  \\<lbrakk>?x \\<in> set (Some l # xs); ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length zs\n  length (Some l # xs) + ii = length T + 1\n  i < length (Some l # xs)\n  j < length (Some l # xs)\n\ngoal (1 subgoal):\n 1. \\<And>l xs zs i T ia j.\n       \\<lbrakk>\\<And>ia j.\n                   \\<lbrakk>\\<And>ia j k.\n                               \\<lbrakk>ia < length xs; j < length xs;\n                                xs ! ia = Some k\\<rbrakk>\n                               \\<Longrightarrow> (xs ! j = Some k) =\n           (\\<not> tr_lookup T (ia + Suc i) (j + Suc i));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < length zs;\n                    length xs + Suc i = length T + 1; ia < length xs;\n                    j < length xs\\<rbrakk>\n                   \\<Longrightarrow> (fst (mk_eqcl xs zs (Suc i) T) ! ia =\nfst (mk_eqcl xs zs (Suc i) T) ! j) =\n                                     (\\<not> tr_lookup T (ia + Suc i)\n        (j + Suc i));\n        \\<And>ia j k.\n           \\<lbrakk>ia < length (Some l # xs); j < length (Some l # xs);\n            (Some l # xs) ! ia = Some k\\<rbrakk>\n           \\<Longrightarrow> ((Some l # xs) ! j = Some k) =\n                             (\\<not> tr_lookup T (ia + i) (j + i));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (Some l # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        length (Some l # xs) + i = length T + 1; ia < length (Some l # xs);\n        j < length (Some l # xs)\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (Some l # xs) zs i T) ! ia =\n                          fst (mk_eqcl (Some l # xs) zs i T) ! j) =\n                         (\\<not> tr_lookup T (ia + i) (j + i))", "{"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>i j k.\n              \\<lbrakk>i < length xs; j < length xs;\n               xs ! i = Some k\\<rbrakk>\n              \\<Longrightarrow> (xs ! j = Some k) =\n                                (\\<not> tr_lookup T (i + Suc ii)\n   (j + Suc ii));\n   \\<And>a b c.\n      \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n       \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n      \\<Longrightarrow> \\<not> tr_lookup T a c;\n   \\<And>x k.\n      \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n      \\<Longrightarrow> k < length zs;\n   length xs + Suc ii = length T + 1; ?i < length xs;\n   ?j < length xs\\<rbrakk>\n  \\<Longrightarrow> (fst (mk_eqcl xs zs (Suc ii) T) ! ?i =\n                     fst (mk_eqcl xs zs (Suc ii) T) ! ?j) =\n                    (\\<not> tr_lookup T (?i + Suc ii) (?j + Suc ii))\n  \\<lbrakk>?i < length (Some l # xs); ?j < length (Some l # xs);\n   (Some l # xs) ! ?i = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ((Some l # xs) ! ?j = Some ?k) =\n                    (\\<not> tr_lookup T (?i + ii) (?j + ii))\n  \\<lbrakk>?a \\<le> length T; ?b \\<le> length T; ?c \\<le> length T;\n   \\<not> tr_lookup T ?a ?b; \\<not> tr_lookup T ?b ?c\\<rbrakk>\n  \\<Longrightarrow> \\<not> tr_lookup T ?a ?c\n  \\<lbrakk>?x \\<in> set (Some l # xs); ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length zs\n  length (Some l # xs) + ii = length T + 1\n  i < length (Some l # xs)\n  j < length (Some l # xs)\n\ngoal (1 subgoal):\n 1. \\<And>l xs zs i T ia j.\n       \\<lbrakk>\\<And>ia j.\n                   \\<lbrakk>\\<And>ia j k.\n                               \\<lbrakk>ia < length xs; j < length xs;\n                                xs ! ia = Some k\\<rbrakk>\n                               \\<Longrightarrow> (xs ! j = Some k) =\n           (\\<not> tr_lookup T (ia + Suc i) (j + Suc i));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < length zs;\n                    length xs + Suc i = length T + 1; ia < length xs;\n                    j < length xs\\<rbrakk>\n                   \\<Longrightarrow> (fst (mk_eqcl xs zs (Suc i) T) ! ia =\nfst (mk_eqcl xs zs (Suc i) T) ! j) =\n                                     (\\<not> tr_lookup T (ia + Suc i)\n        (j + Suc i));\n        \\<And>ia j k.\n           \\<lbrakk>ia < length (Some l # xs); j < length (Some l # xs);\n            (Some l # xs) ! ia = Some k\\<rbrakk>\n           \\<Longrightarrow> ((Some l # xs) ! j = Some k) =\n                             (\\<not> tr_lookup T (ia + i) (j + i));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (Some l # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        length (Some l # xs) + i = length T + 1; ia < length (Some l # xs);\n        j < length (Some l # xs)\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (Some l # xs) zs i T) ! ia =\n                          fst (mk_eqcl (Some l # xs) zs i T) ! j) =\n                         (\\<not> tr_lookup T (ia + i) (j + i))", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l xs zs i T ia j.\n       \\<lbrakk>\\<And>ia j.\n                   \\<lbrakk>\\<And>ia j k.\n                               \\<lbrakk>ia < length xs; j < length xs;\n                                xs ! ia = Some k\\<rbrakk>\n                               \\<Longrightarrow> (xs ! j = Some k) =\n           (\\<not> tr_lookup T (ia + Suc i) (j + Suc i));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < length zs;\n                    length xs + Suc i = length T + 1; ia < length xs;\n                    j < length xs\\<rbrakk>\n                   \\<Longrightarrow> (fst (mk_eqcl xs zs (Suc i) T) ! ia =\nfst (mk_eqcl xs zs (Suc i) T) ! j) =\n                                     (\\<not> tr_lookup T (ia + Suc i)\n        (j + Suc i));\n        \\<And>ia j k.\n           \\<lbrakk>ia < length (Some l # xs); j < length (Some l # xs);\n            (Some l # xs) ! ia = Some k\\<rbrakk>\n           \\<Longrightarrow> ((Some l # xs) ! j = Some k) =\n                             (\\<not> tr_lookup T (ia + i) (j + i));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (Some l # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        length (Some l # xs) + i = length T + 1; ia < length (Some l # xs);\n        j < length (Some l # xs)\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (Some l # xs) zs i T) ! ia =\n                          fst (mk_eqcl (Some l # xs) zs i T) ! j) =\n                         (\\<not> tr_lookup T (ia + i) (j + i))", "assume H: \"i < j\" \"j < length (Some l # xs)\""], ["proof (state)\nthis:\n  i < j\n  j < length (Some l # xs)\n\ngoal (1 subgoal):\n 1. \\<And>l xs zs i T ia j.\n       \\<lbrakk>\\<And>ia j.\n                   \\<lbrakk>\\<And>ia j k.\n                               \\<lbrakk>ia < length xs; j < length xs;\n                                xs ! ia = Some k\\<rbrakk>\n                               \\<Longrightarrow> (xs ! j = Some k) =\n           (\\<not> tr_lookup T (ia + Suc i) (j + Suc i));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < length zs;\n                    length xs + Suc i = length T + 1; ia < length xs;\n                    j < length xs\\<rbrakk>\n                   \\<Longrightarrow> (fst (mk_eqcl xs zs (Suc i) T) ! ia =\nfst (mk_eqcl xs zs (Suc i) T) ! j) =\n                                     (\\<not> tr_lookup T (ia + Suc i)\n        (j + Suc i));\n        \\<And>ia j k.\n           \\<lbrakk>ia < length (Some l # xs); j < length (Some l # xs);\n            (Some l # xs) ! ia = Some k\\<rbrakk>\n           \\<Longrightarrow> ((Some l # xs) ! j = Some k) =\n                             (\\<not> tr_lookup T (ia + i) (j + i));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (Some l # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        length (Some l # xs) + i = length T + 1; ia < length (Some l # xs);\n        j < length (Some l # xs)\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (Some l # xs) zs i T) ! ia =\n                          fst (mk_eqcl (Some l # xs) zs i T) ! j) =\n                         (\\<not> tr_lookup T (ia + i) (j + i))", "then"], ["proof (chain)\npicking this:\n  i < j\n  j < length (Some l # xs)", "obtain j' where J: \"j = Suc j'\""], ["proof (prove)\nusing this:\n  i < j\n  j < length (Some l # xs)\n\ngoal (1 subgoal):\n 1. (\\<And>j'. j = Suc j' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases j) simp+"], ["proof (state)\nthis:\n  j = Suc j'\n\ngoal (1 subgoal):\n 1. \\<And>l xs zs i T ia j.\n       \\<lbrakk>\\<And>ia j.\n                   \\<lbrakk>\\<And>ia j k.\n                               \\<lbrakk>ia < length xs; j < length xs;\n                                xs ! ia = Some k\\<rbrakk>\n                               \\<Longrightarrow> (xs ! j = Some k) =\n           (\\<not> tr_lookup T (ia + Suc i) (j + Suc i));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < length zs;\n                    length xs + Suc i = length T + 1; ia < length xs;\n                    j < length xs\\<rbrakk>\n                   \\<Longrightarrow> (fst (mk_eqcl xs zs (Suc i) T) ! ia =\nfst (mk_eqcl xs zs (Suc i) T) ! j) =\n                                     (\\<not> tr_lookup T (ia + Suc i)\n        (j + Suc i));\n        \\<And>ia j k.\n           \\<lbrakk>ia < length (Some l # xs); j < length (Some l # xs);\n            (Some l # xs) ! ia = Some k\\<rbrakk>\n           \\<Longrightarrow> ((Some l # xs) ! j = Some k) =\n                             (\\<not> tr_lookup T (ia + i) (j + i));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (Some l # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        length (Some l # xs) + i = length T + 1; ia < length (Some l # xs);\n        j < length (Some l # xs)\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (Some l # xs) zs i T) ! ia =\n                          fst (mk_eqcl (Some l # xs) zs i T) ! j) =\n                         (\\<not> tr_lookup T (ia + i) (j + i))", "have \"(fst (mk_eqcl (Some l # xs) zs ii T) ! i = fst (mk_eqcl (Some l # xs) zs ii T) ! j) = (\\<not> tr_lookup T (i + ii) (j + ii))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n     fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))", "proof (cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n     fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n        fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "case 0"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n     fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n        fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "with J"], ["proof (chain)\npicking this:\n  j = Suc j'\n  i = 0", "have \"(fst (mk_eqcl (Some l # xs) zs ii T) ! i = fst (mk_eqcl (Some l # xs) zs ii T) ! j) = (fst (mk_eqcl xs zs (Suc ii) T) ! j' = l)\""], ["proof (prove)\nusing this:\n  j = Suc j'\n  i = 0\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n     fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n    (fst (mk_eqcl xs zs (Suc ii) T) ! j' = l)", "by (auto simp add: split_beta)"], ["proof (state)\nthis:\n  (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n   fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n  (fst (mk_eqcl xs zs (Suc ii) T) ! j' = l)\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n     fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n        fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "also"], ["proof (state)\nthis:\n  (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n   fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n  (fst (mk_eqcl xs zs (Suc ii) T) ! j' = l)\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n     fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n        fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "from 3(4)[of \"Some l\" l] H J"], ["proof (chain)\npicking this:\n  \\<lbrakk>Some l \\<in> set (Some l # xs); Some l = Some l\\<rbrakk>\n  \\<Longrightarrow> l < length zs\n  i < j\n  j < length (Some l # xs)\n  j = Suc j'", "have \"\\<dots> = (xs ! j' = Some l)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>Some l \\<in> set (Some l # xs); Some l = Some l\\<rbrakk>\n  \\<Longrightarrow> l < length zs\n  i < j\n  j < length (Some l # xs)\n  j = Suc j'\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl xs zs (Suc ii) T) ! j' = l) = (xs ! j' = Some l)", "by (simp add: mk_eqcl_fst_Some)"], ["proof (state)\nthis:\n  (fst (mk_eqcl xs zs (Suc ii) T) ! j' = l) = (xs ! j' = Some l)\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n     fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n        fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "also"], ["proof (state)\nthis:\n  (fst (mk_eqcl xs zs (Suc ii) T) ! j' = l) = (xs ! j' = Some l)\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n     fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n        fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "from J"], ["proof (chain)\npicking this:\n  j = Suc j'", "have \"\\<dots> = ((Some l # xs) ! j = Some l)\""], ["proof (prove)\nusing this:\n  j = Suc j'\n\ngoal (1 subgoal):\n 1. (xs ! j' = Some l) = ((Some l # xs) ! j = Some l)", "by simp"], ["proof (state)\nthis:\n  (xs ! j' = Some l) = ((Some l # xs) ! j = Some l)\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n     fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n        fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "also"], ["proof (state)\nthis:\n  (xs ! j' = Some l) = ((Some l # xs) ! j = Some l)\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n     fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n        fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "from H 0 3(2)[of i j l]"], ["proof (chain)\npicking this:\n  i < j\n  j < length (Some l # xs)\n  i = 0\n  \\<lbrakk>i < length (Some l # xs); j < length (Some l # xs);\n   (Some l # xs) ! i = Some l\\<rbrakk>\n  \\<Longrightarrow> ((Some l # xs) ! j = Some l) =\n                    (\\<not> tr_lookup T (i + ii) (j + ii))", "have \"\\<dots> = (\\<not> tr_lookup T (i + ii) (j + ii))\""], ["proof (prove)\nusing this:\n  i < j\n  j < length (Some l # xs)\n  i = 0\n  \\<lbrakk>i < length (Some l # xs); j < length (Some l # xs);\n   (Some l # xs) ! i = Some l\\<rbrakk>\n  \\<Longrightarrow> ((Some l # xs) ! j = Some l) =\n                    (\\<not> tr_lookup T (i + ii) (j + ii))\n\ngoal (1 subgoal):\n 1. ((Some l # xs) ! j = Some l) = (\\<not> tr_lookup T (i + ii) (j + ii))", "by simp"], ["proof (state)\nthis:\n  ((Some l # xs) ! j = Some l) = (\\<not> tr_lookup T (i + ii) (j + ii))\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n     fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n        fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "finally"], ["proof (chain)\npicking this:\n  (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n   fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n  (\\<not> tr_lookup T (i + ii) (j + ii))", "show ?thesis"], ["proof (prove)\nusing this:\n  (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n   fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n  (\\<not> tr_lookup T (i + ii) (j + ii))\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n     fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))", "by simp"], ["proof (state)\nthis:\n  (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n   fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n  (\\<not> tr_lookup T (i + ii) (j + ii))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n        fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n        fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "case (Suc i')"], ["proof (state)\nthis:\n  i = Suc i'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n        fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "have \"\\<And>i j k. \\<lbrakk>i < length xs; j < length xs; xs ! i = Some k\\<rbrakk> \\<Longrightarrow> (xs ! j = Some k) = (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length xs; j < length xs; xs ! i = Some k\\<rbrakk>\n       \\<Longrightarrow> (xs ! j = Some k) =\n                         (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length xs; j < length xs; xs ! i = Some k\\<rbrakk>\n       \\<Longrightarrow> (xs ! j = Some k) =\n                         (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))", "fix i j k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length xs; j < length xs; xs ! i = Some k\\<rbrakk>\n       \\<Longrightarrow> (xs ! j = Some k) =\n                         (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))", "assume \"i < length xs\" \"j < length xs\" \"xs ! i = Some k\""], ["proof (state)\nthis:\n  i < length xs\n  j < length xs\n  xs ! i = Some k\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < length xs; j < length xs; xs ! i = Some k\\<rbrakk>\n       \\<Longrightarrow> (xs ! j = Some k) =\n                         (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))", "with 3(2)[of \"Suc i\" \"Suc j\" k]"], ["proof (chain)\npicking this:\n  \\<lbrakk>Suc i < length (Some l # xs); Suc j < length (Some l # xs);\n   (Some l # xs) ! Suc i = Some k\\<rbrakk>\n  \\<Longrightarrow> ((Some l # xs) ! Suc j = Some k) =\n                    (\\<not> tr_lookup T (Suc i + ii) (Suc j + ii))\n  i < length xs\n  j < length xs\n  xs ! i = Some k", "show \"(xs ! j = Some k) = (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>Suc i < length (Some l # xs); Suc j < length (Some l # xs);\n   (Some l # xs) ! Suc i = Some k\\<rbrakk>\n  \\<Longrightarrow> ((Some l # xs) ! Suc j = Some k) =\n                    (\\<not> tr_lookup T (Suc i + ii) (Suc j + ii))\n  i < length xs\n  j < length xs\n  xs ! i = Some k\n\ngoal (1 subgoal):\n 1. (xs ! j = Some k) = (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))", "by simp"], ["proof (state)\nthis:\n  (xs ! j = Some k) = (\\<not> tr_lookup T (i + Suc ii) (j + Suc ii))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?i < length xs; ?j < length xs; xs ! ?i = Some ?k\\<rbrakk>\n  \\<Longrightarrow> (xs ! ?j = Some ?k) =\n                    (\\<not> tr_lookup T (?i + Suc ii) (?j + Suc ii))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n        fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?i < length xs; ?j < length xs; xs ! ?i = Some ?k\\<rbrakk>\n  \\<Longrightarrow> (xs ! ?j = Some ?k) =\n                    (\\<not> tr_lookup T (?i + Suc ii) (?j + Suc ii))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n        fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "note 3(3)"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<le> length T; ?b \\<le> length T; ?c \\<le> length T;\n   \\<not> tr_lookup T ?a ?b; \\<not> tr_lookup T ?b ?c\\<rbrakk>\n  \\<Longrightarrow> \\<not> tr_lookup T ?a ?c\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n        fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<le> length T; ?b \\<le> length T; ?c \\<le> length T;\n   \\<not> tr_lookup T ?a ?b; \\<not> tr_lookup T ?b ?c\\<rbrakk>\n  \\<Longrightarrow> \\<not> tr_lookup T ?a ?c\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n        fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "have \"\\<And>x k. \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk> \\<Longrightarrow> k < length zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x k.\n       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n       \\<Longrightarrow> k < length zs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x k.\n       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n       \\<Longrightarrow> k < length zs", "fix x k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x k.\n       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n       \\<Longrightarrow> k < length zs", "assume \"x \\<in> set xs\" \"x = Some k\""], ["proof (state)\nthis:\n  x \\<in> set xs\n  x = Some k\n\ngoal (1 subgoal):\n 1. \\<And>x k.\n       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n       \\<Longrightarrow> k < length zs", "with 3(4)[of x k]"], ["proof (chain)\npicking this:\n  \\<lbrakk>x \\<in> set (Some l # xs); x = Some k\\<rbrakk>\n  \\<Longrightarrow> k < length zs\n  x \\<in> set xs\n  x = Some k", "show \"k < length zs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<in> set (Some l # xs); x = Some k\\<rbrakk>\n  \\<Longrightarrow> k < length zs\n  x \\<in> set xs\n  x = Some k\n\ngoal (1 subgoal):\n 1. k < length zs", "by simp"], ["proof (state)\nthis:\n  k < length zs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> set xs; ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length zs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n        fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> set xs; ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length zs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n        fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "from 3(5) H Suc J"], ["proof (chain)\npicking this:\n  length (Some l # xs) + ii = length T + 1\n  i < j\n  j < length (Some l # xs)\n  i = Suc i'\n  j = Suc j'", "have \"length xs + Suc ii = length T + 1\" \"i' < length xs\" \"j' < length xs\""], ["proof (prove)\nusing this:\n  length (Some l # xs) + ii = length T + 1\n  i < j\n  j < length (Some l # xs)\n  i = Suc i'\n  j = Suc j'\n\ngoal (1 subgoal):\n 1. length xs + Suc ii = length T + 1 &&& i' < length xs &&& j' < length xs", "by simp+"], ["proof (state)\nthis:\n  length xs + Suc ii = length T + 1\n  i' < length xs\n  j' < length xs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n        fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i < length xs; ?j < length xs; xs ! ?i = Some ?k\\<rbrakk>\n  \\<Longrightarrow> (xs ! ?j = Some ?k) =\n                    (\\<not> tr_lookup T (?i + Suc ii) (?j + Suc ii))\n  \\<lbrakk>?a \\<le> length T; ?b \\<le> length T; ?c \\<le> length T;\n   \\<not> tr_lookup T ?a ?b; \\<not> tr_lookup T ?b ?c\\<rbrakk>\n  \\<Longrightarrow> \\<not> tr_lookup T ?a ?c\n  \\<lbrakk>?x \\<in> set xs; ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length zs\n  length xs + Suc ii = length T + 1\n  i' < length xs\n  j' < length xs", "have \"(fst (mk_eqcl xs zs (Suc ii) T) ! i' = fst (mk_eqcl xs zs (Suc ii) T) ! j') = (\\<not> tr_lookup T (i' + Suc ii) (j' + Suc ii))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < length xs; ?j < length xs; xs ! ?i = Some ?k\\<rbrakk>\n  \\<Longrightarrow> (xs ! ?j = Some ?k) =\n                    (\\<not> tr_lookup T (?i + Suc ii) (?j + Suc ii))\n  \\<lbrakk>?a \\<le> length T; ?b \\<le> length T; ?c \\<le> length T;\n   \\<not> tr_lookup T ?a ?b; \\<not> tr_lookup T ?b ?c\\<rbrakk>\n  \\<Longrightarrow> \\<not> tr_lookup T ?a ?c\n  \\<lbrakk>?x \\<in> set xs; ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length zs\n  length xs + Suc ii = length T + 1\n  i' < length xs\n  j' < length xs\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl xs zs (Suc ii) T) ! i' =\n     fst (mk_eqcl xs zs (Suc ii) T) ! j') =\n    (\\<not> tr_lookup T (i' + Suc ii) (j' + Suc ii))", "by (rule 3(1))"], ["proof (state)\nthis:\n  (fst (mk_eqcl xs zs (Suc ii) T) ! i' =\n   fst (mk_eqcl xs zs (Suc ii) T) ! j') =\n  (\\<not> tr_lookup T (i' + Suc ii) (j' + Suc ii))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n        fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n       (\\<not> tr_lookup T (i + ii) (j + ii))", "with J Suc"], ["proof (chain)\npicking this:\n  j = Suc j'\n  i = Suc i'\n  (fst (mk_eqcl xs zs (Suc ii) T) ! i' =\n   fst (mk_eqcl xs zs (Suc ii) T) ! j') =\n  (\\<not> tr_lookup T (i' + Suc ii) (j' + Suc ii))", "show ?thesis"], ["proof (prove)\nusing this:\n  j = Suc j'\n  i = Suc i'\n  (fst (mk_eqcl xs zs (Suc ii) T) ! i' =\n   fst (mk_eqcl xs zs (Suc ii) T) ! j') =\n  (\\<not> tr_lookup T (i' + Suc ii) (j' + Suc ii))\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n     fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))", "by (simp add: split_beta)"], ["proof (state)\nthis:\n  (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n   fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n  (\\<not> tr_lookup T (i + ii) (j + ii))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n   fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n  (\\<not> tr_lookup T (i + ii) (j + ii))\n\ngoal (1 subgoal):\n 1. \\<And>l xs zs i T ia j.\n       \\<lbrakk>\\<And>ia j.\n                   \\<lbrakk>\\<And>ia j k.\n                               \\<lbrakk>ia < length xs; j < length xs;\n                                xs ! ia = Some k\\<rbrakk>\n                               \\<Longrightarrow> (xs ! j = Some k) =\n           (\\<not> tr_lookup T (ia + Suc i) (j + Suc i));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < length zs;\n                    length xs + Suc i = length T + 1; ia < length xs;\n                    j < length xs\\<rbrakk>\n                   \\<Longrightarrow> (fst (mk_eqcl xs zs (Suc i) T) ! ia =\nfst (mk_eqcl xs zs (Suc i) T) ! j) =\n                                     (\\<not> tr_lookup T (ia + Suc i)\n        (j + Suc i));\n        \\<And>ia j k.\n           \\<lbrakk>ia < length (Some l # xs); j < length (Some l # xs);\n            (Some l # xs) ! ia = Some k\\<rbrakk>\n           \\<Longrightarrow> ((Some l # xs) ! j = Some k) =\n                             (\\<not> tr_lookup T (ia + i) (j + i));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (Some l # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        length (Some l # xs) + i = length T + 1; ia < length (Some l # xs);\n        j < length (Some l # xs)\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (Some l # xs) zs i T) ! ia =\n                          fst (mk_eqcl (Some l # xs) zs i T) ! j) =\n                         (\\<not> tr_lookup T (ia + i) (j + i))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?ib2 < ?jb2; ?jb2 < length (Some l # xs)\\<rbrakk>\n  \\<Longrightarrow> (fst (mk_eqcl (Some l # xs) zs ii T) ! ?ib2 =\n                     fst (mk_eqcl (Some l # xs) zs ii T) ! ?jb2) =\n                    (\\<not> tr_lookup T (?ib2 + ii) (?jb2 + ii))\n\ngoal (1 subgoal):\n 1. \\<And>l xs zs i T ia j.\n       \\<lbrakk>\\<And>ia j.\n                   \\<lbrakk>\\<And>ia j k.\n                               \\<lbrakk>ia < length xs; j < length xs;\n                                xs ! ia = Some k\\<rbrakk>\n                               \\<Longrightarrow> (xs ! j = Some k) =\n           (\\<not> tr_lookup T (ia + Suc i) (j + Suc i));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < length zs;\n                    length xs + Suc i = length T + 1; ia < length xs;\n                    j < length xs\\<rbrakk>\n                   \\<Longrightarrow> (fst (mk_eqcl xs zs (Suc i) T) ! ia =\nfst (mk_eqcl xs zs (Suc i) T) ! j) =\n                                     (\\<not> tr_lookup T (ia + Suc i)\n        (j + Suc i));\n        \\<And>ia j k.\n           \\<lbrakk>ia < length (Some l # xs); j < length (Some l # xs);\n            (Some l # xs) ! ia = Some k\\<rbrakk>\n           \\<Longrightarrow> ((Some l # xs) ! j = Some k) =\n                             (\\<not> tr_lookup T (ia + i) (j + i));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (Some l # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        length (Some l # xs) + i = length T + 1; ia < length (Some l # xs);\n        j < length (Some l # xs)\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (Some l # xs) zs i T) ! ia =\n                          fst (mk_eqcl (Some l # xs) zs i T) ! j) =\n                         (\\<not> tr_lookup T (ia + i) (j + i))", "note L = this"], ["proof (state)\nthis:\n  \\<lbrakk>?ib2 < ?jb2; ?jb2 < length (Some l # xs)\\<rbrakk>\n  \\<Longrightarrow> (fst (mk_eqcl (Some l # xs) zs ii T) ! ?ib2 =\n                     fst (mk_eqcl (Some l # xs) zs ii T) ! ?jb2) =\n                    (\\<not> tr_lookup T (?ib2 + ii) (?jb2 + ii))\n\ngoal (1 subgoal):\n 1. \\<And>l xs zs i T ia j.\n       \\<lbrakk>\\<And>ia j.\n                   \\<lbrakk>\\<And>ia j k.\n                               \\<lbrakk>ia < length xs; j < length xs;\n                                xs ! ia = Some k\\<rbrakk>\n                               \\<Longrightarrow> (xs ! j = Some k) =\n           (\\<not> tr_lookup T (ia + Suc i) (j + Suc i));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < length zs;\n                    length xs + Suc i = length T + 1; ia < length xs;\n                    j < length xs\\<rbrakk>\n                   \\<Longrightarrow> (fst (mk_eqcl xs zs (Suc i) T) ! ia =\nfst (mk_eqcl xs zs (Suc i) T) ! j) =\n                                     (\\<not> tr_lookup T (ia + Suc i)\n        (j + Suc i));\n        \\<And>ia j k.\n           \\<lbrakk>ia < length (Some l # xs); j < length (Some l # xs);\n            (Some l # xs) ! ia = Some k\\<rbrakk>\n           \\<Longrightarrow> ((Some l # xs) ! j = Some k) =\n                             (\\<not> tr_lookup T (ia + i) (j + i));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (Some l # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        length (Some l # xs) + i = length T + 1; ia < length (Some l # xs);\n        j < length (Some l # xs)\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (Some l # xs) zs i T) ! ia =\n                          fst (mk_eqcl (Some l # xs) zs i T) ! j) =\n                         (\\<not> tr_lookup T (ia + i) (j + i))", "have \"i < j \\<or> i = j \\<or> i > j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < j \\<or> i = j \\<or> j < i", "by auto"], ["proof (state)\nthis:\n  i < j \\<or> i = j \\<or> j < i\n\ngoal (1 subgoal):\n 1. \\<And>l xs zs i T ia j.\n       \\<lbrakk>\\<And>ia j.\n                   \\<lbrakk>\\<And>ia j k.\n                               \\<lbrakk>ia < length xs; j < length xs;\n                                xs ! ia = Some k\\<rbrakk>\n                               \\<Longrightarrow> (xs ! j = Some k) =\n           (\\<not> tr_lookup T (ia + Suc i) (j + Suc i));\n                    \\<And>a b c.\n                       \\<lbrakk>a \\<le> length T; b \\<le> length T;\n                        c \\<le> length T; \\<not> tr_lookup T a b;\n                        \\<not> tr_lookup T b c\\<rbrakk>\n                       \\<Longrightarrow> \\<not> tr_lookup T a c;\n                    \\<And>x k.\n                       \\<lbrakk>x \\<in> set xs; x = Some k\\<rbrakk>\n                       \\<Longrightarrow> k < length zs;\n                    length xs + Suc i = length T + 1; ia < length xs;\n                    j < length xs\\<rbrakk>\n                   \\<Longrightarrow> (fst (mk_eqcl xs zs (Suc i) T) ! ia =\nfst (mk_eqcl xs zs (Suc i) T) ! j) =\n                                     (\\<not> tr_lookup T (ia + Suc i)\n        (j + Suc i));\n        \\<And>ia j k.\n           \\<lbrakk>ia < length (Some l # xs); j < length (Some l # xs);\n            (Some l # xs) ! ia = Some k\\<rbrakk>\n           \\<Longrightarrow> ((Some l # xs) ! j = Some k) =\n                             (\\<not> tr_lookup T (ia + i) (j + i));\n        \\<And>a b c.\n           \\<lbrakk>a \\<le> length T; b \\<le> length T; c \\<le> length T;\n            \\<not> tr_lookup T a b; \\<not> tr_lookup T b c\\<rbrakk>\n           \\<Longrightarrow> \\<not> tr_lookup T a c;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set (Some l # xs); x = Some k\\<rbrakk>\n           \\<Longrightarrow> k < length zs;\n        length (Some l # xs) + i = length T + 1; ia < length (Some l # xs);\n        j < length (Some l # xs)\\<rbrakk>\n       \\<Longrightarrow> (fst (mk_eqcl (Some l # xs) zs i T) ! ia =\n                          fst (mk_eqcl (Some l # xs) zs i T) ! j) =\n                         (\\<not> tr_lookup T (ia + i) (j + i))", "thus ?case"], ["proof (prove)\nusing this:\n  i < j \\<or> i = j \\<or> j < i\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n     fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))", "proof (elim disjE)"], ["proof (state)\ngoal (3 subgoals):\n 1. i < j \\<Longrightarrow>\n    (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n     fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))\n 2. i = j \\<Longrightarrow>\n    (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n     fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))\n 3. j < i \\<Longrightarrow>\n    (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n     fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))", "assume \"i > j\""], ["proof (state)\nthis:\n  j < i\n\ngoal (3 subgoals):\n 1. i < j \\<Longrightarrow>\n    (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n     fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))\n 2. i = j \\<Longrightarrow>\n    (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n     fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))\n 3. j < i \\<Longrightarrow>\n    (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n     fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))", "with 3(6) L"], ["proof (chain)\npicking this:\n  i < length (Some l # xs)\n  \\<lbrakk>?ib2 < ?jb2; ?jb2 < length (Some l # xs)\\<rbrakk>\n  \\<Longrightarrow> (fst (mk_eqcl (Some l # xs) zs ii T) ! ?ib2 =\n                     fst (mk_eqcl (Some l # xs) zs ii T) ! ?jb2) =\n                    (\\<not> tr_lookup T (?ib2 + ii) (?jb2 + ii))\n  j < i", "have \"(fst (mk_eqcl (Some l # xs) zs ii T) ! j = fst (mk_eqcl (Some l # xs) zs ii T) ! i) = (\\<not> tr_lookup T (j + ii) (i + ii))\""], ["proof (prove)\nusing this:\n  i < length (Some l # xs)\n  \\<lbrakk>?ib2 < ?jb2; ?jb2 < length (Some l # xs)\\<rbrakk>\n  \\<Longrightarrow> (fst (mk_eqcl (Some l # xs) zs ii T) ! ?ib2 =\n                     fst (mk_eqcl (Some l # xs) zs ii T) ! ?jb2) =\n                    (\\<not> tr_lookup T (?ib2 + ii) (?jb2 + ii))\n  j < i\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (Some l # xs) zs ii T) ! j =\n     fst (mk_eqcl (Some l # xs) zs ii T) ! i) =\n    (\\<not> tr_lookup T (j + ii) (i + ii))", "by simp"], ["proof (state)\nthis:\n  (fst (mk_eqcl (Some l # xs) zs ii T) ! j =\n   fst (mk_eqcl (Some l # xs) zs ii T) ! i) =\n  (\\<not> tr_lookup T (j + ii) (i + ii))\n\ngoal (3 subgoals):\n 1. i < j \\<Longrightarrow>\n    (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n     fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))\n 2. i = j \\<Longrightarrow>\n    (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n     fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))\n 3. j < i \\<Longrightarrow>\n    (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n     fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (fst (mk_eqcl (Some l # xs) zs ii T) ! j =\n   fst (mk_eqcl (Some l # xs) zs ii T) ! i) =\n  (\\<not> tr_lookup T (j + ii) (i + ii))\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n     fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))", "by (auto simp: tr_lookup_def)"], ["proof (state)\nthis:\n  (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n   fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n  (\\<not> tr_lookup T (i + ii) (j + ii))\n\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow>\n    (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n     fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))\n 2. i = j \\<Longrightarrow>\n    (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n     fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n    (\\<not> tr_lookup T (i + ii) (j + ii))", "qed (insert 3(7) L, simp add: tr_lookup_def)+"], ["proof (state)\nthis:\n  (fst (mk_eqcl (Some l # xs) zs ii T) ! i =\n   fst (mk_eqcl (Some l # xs) zs ii T) ! j) =\n  (\\<not> tr_lookup T (i + ii) (j + ii))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition min_dfa :: \"dfa \\<Rightarrow> dfa\" where\n  \"min_dfa = (\\<lambda>(bd, as). let (os, ns) = mk_eqcl (replicate (length bd) None) [] 0 (fixpt (bd, as) (init_tr (bd, as))) in\n      (map (\\<lambda>p. bdd_map (\\<lambda>q. os ! q) (bd ! p)) ns, map (\\<lambda>p. as ! p) ns))\""], ["", "definition eq_nodes :: \"dfa \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> bool\" where\n  \"eq_nodes = (\\<lambda>M v p q. \\<not> (\\<exists>n. dist_nodes M n v p q))\""], ["", "lemma mk_eqcl_fixpt_fst_bound:\n  assumes \"dfa_is_node M i\"\n  shows \"fst (mk_eqcl (replicate (length (fst M)) None) [] 0 (fixpt M (init_tr M))) ! i < length (snd (mk_eqcl (replicate (length (fst M)) None) [] 0 (fixpt M (init_tr M))))\"\n  (is \"fst ?M ! i < length (snd ?M)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    i\n    < length\n       (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    i\n    < length\n       (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M))))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    i\n    < length\n       (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M))))", "fix x k"], ["proof (state)\ngoal (1 subgoal):\n 1. fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    i\n    < length\n       (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M))))", "assume H: \"x \\<in> set (replicate (length (fst M)) (None::nat option))\" \"x = Some k\""], ["proof (state)\nthis:\n  x \\<in> set (replicate (length (fst M)) None)\n  x = Some k\n\ngoal (1 subgoal):\n 1. fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    i\n    < length\n       (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M))))", "hence \"k < length []\""], ["proof (prove)\nusing this:\n  x \\<in> set (replicate (length (fst M)) None)\n  x = Some k\n\ngoal (1 subgoal):\n 1. k < length []", "by (cases \"length (fst M) = 0\") simp+"], ["proof (state)\nthis:\n  k < length []\n\ngoal (1 subgoal):\n 1. fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    i\n    < length\n       (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M))))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?x4 \\<in> set (replicate (length (fst M)) None);\n   ?x4 = Some ?k4\\<rbrakk>\n  \\<Longrightarrow> ?k4 < length []\n\ngoal (1 subgoal):\n 1. fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    i\n    < length\n       (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M))))", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?x4 \\<in> set (replicate (length (fst M)) None);\n   ?x4 = Some ?k4\\<rbrakk>\n  \\<Longrightarrow> ?k4 < length []\n\ngoal (1 subgoal):\n 1. fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    i\n    < length\n       (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M))))", "from assms"], ["proof (chain)\npicking this:\n  dfa_is_node M i", "have \"fst ?M ! i \\<in> set (fst ?M)\""], ["proof (prove)\nusing this:\n  dfa_is_node M i\n\ngoal (1 subgoal):\n 1. fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    i\n    \\<in> set (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n                     (fixpt M (init_tr M))))", "by (simp add: dfa_is_node_def mk_eqcl_len_fst)"], ["proof (state)\nthis:\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  i\n  \\<in> set (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n                   (fixpt M (init_tr M))))\n\ngoal (1 subgoal):\n 1. fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    i\n    < length\n       (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M))))", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x4 \\<in> set (replicate (length (fst M)) None);\n   ?x4 = Some ?k4\\<rbrakk>\n  \\<Longrightarrow> ?k4 < length []\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  i\n  \\<in> set (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n                   (fixpt M (init_tr M))))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x4 \\<in> set (replicate (length (fst M)) None);\n   ?x4 = Some ?k4\\<rbrakk>\n  \\<Longrightarrow> ?k4 < length []\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  i\n  \\<in> set (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n                   (fixpt M (init_tr M))))\n\ngoal (1 subgoal):\n 1. fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    i\n    < length\n       (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M))))", "by (rule mk_eqcl_bound)"], ["proof (state)\nthis:\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  i\n  < length\n     (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mk_eqcl_fixpt_fst_nth:\n  assumes \"wf_dfa M v\"\n  and \"dfa_is_node M p\" and \"dfa_is_node M q\"\n  shows \"(fst (mk_eqcl (replicate (length (fst M)) None) [] 0 (fixpt M (init_tr M))) ! p = fst (mk_eqcl (replicate (length (fst M)) None) [] 0 (fixpt M (init_tr M))) ! q)\n          = eq_nodes M v p q\"\n  (is \"(fst ?M ! p = fst ?M ! q) = eq_nodes M v p q\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     p =\n     fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     q) =\n    eq_nodes M v p q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     p =\n     fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     q) =\n    eq_nodes M v p q", "have WF: \"wf_tr M (fixpt M (init_tr M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_tr M (fixpt M (init_tr M))", "by (simp only: fixpt_wf init_tr_wf)"], ["proof (state)\nthis:\n  wf_tr M (fixpt M (init_tr M))\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     p =\n     fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     q) =\n    eq_nodes M v p q", "have \"(fst ?M ! p = fst ?M ! q) = (\\<not> tr_lookup (fixpt M (init_tr M)) p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     p =\n     fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     q) =\n    (\\<not> tr_lookup (fixpt M (init_tr M)) p q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     p =\n     fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     q) =\n    (\\<not> tr_lookup (fixpt M (init_tr M)) p q)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     p =\n     fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     q) =\n    (\\<not> tr_lookup (fixpt M (init_tr M)) p q)", "fix i j k"], ["proof (state)\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     p =\n     fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     q) =\n    (\\<not> tr_lookup (fixpt M (init_tr M)) p q)", "assume H: \"i < length (replicate (length (fst M)) None)\" \"j < length (replicate (length (fst M)) None)\" \"replicate (length (fst M)) None ! i = Some k\""], ["proof (state)\nthis:\n  i < length (replicate (length (fst M)) None)\n  j < length (replicate (length (fst M)) None)\n  replicate (length (fst M)) None ! i = Some k\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     p =\n     fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     q) =\n    (\\<not> tr_lookup (fixpt M (init_tr M)) p q)", "hence \"(replicate (length (fst M)) None ! j = Some k) = (\\<not> tr_lookup (fixpt M (init_tr M)) (i + 0) (j + 0))\""], ["proof (prove)\nusing this:\n  i < length (replicate (length (fst M)) None)\n  j < length (replicate (length (fst M)) None)\n  replicate (length (fst M)) None ! i = Some k\n\ngoal (1 subgoal):\n 1. (replicate (length (fst M)) None ! j = Some k) =\n    (\\<not> tr_lookup (fixpt M (init_tr M)) (i + 0) (j + 0))", "by simp"], ["proof (state)\nthis:\n  (replicate (length (fst M)) None ! j = Some k) =\n  (\\<not> tr_lookup (fixpt M (init_tr M)) (i + 0) (j + 0))\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     p =\n     fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     q) =\n    (\\<not> tr_lookup (fixpt M (init_tr M)) p q)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < length (replicate (length (fst M)) None);\n   ?j2 < length (replicate (length (fst M)) None);\n   replicate (length (fst M)) None ! ?i2 = Some ?k2\\<rbrakk>\n  \\<Longrightarrow> (replicate (length (fst M)) None ! ?j2 = Some ?k2) =\n                    (\\<not> tr_lookup (fixpt M (init_tr M)) (?i2 + 0)\n                             (?j2 + 0))\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     p =\n     fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     q) =\n    (\\<not> tr_lookup (fixpt M (init_tr M)) p q)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < length (replicate (length (fst M)) None);\n   ?j2 < length (replicate (length (fst M)) None);\n   replicate (length (fst M)) None ! ?i2 = Some ?k2\\<rbrakk>\n  \\<Longrightarrow> (replicate (length (fst M)) None ! ?j2 = Some ?k2) =\n                    (\\<not> tr_lookup (fixpt M (init_tr M)) (?i2 + 0)\n                             (?j2 + 0))\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     p =\n     fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     q) =\n    (\\<not> tr_lookup (fixpt M (init_tr M)) p q)", "have \"\\<And>a b c. \\<lbrakk>a \\<le> length (fixpt M (init_tr M)); b \\<le> length (fixpt M (init_tr M)); c \\<le> length (fixpt M (init_tr M)); \\<not> tr_lookup (fixpt M (init_tr M)) a b; \\<not> tr_lookup (fixpt M (init_tr M)) b c\\<rbrakk>\n      \\<Longrightarrow> \\<not> tr_lookup (fixpt M (init_tr M)) a c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<le> length (fixpt M (init_tr M));\n        b \\<le> length (fixpt M (init_tr M));\n        c \\<le> length (fixpt M (init_tr M));\n        \\<not> tr_lookup (fixpt M (init_tr M)) a b;\n        \\<not> tr_lookup (fixpt M (init_tr M)) b c\\<rbrakk>\n       \\<Longrightarrow> \\<not> tr_lookup (fixpt M (init_tr M)) a c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<le> length (fixpt M (init_tr M));\n        b \\<le> length (fixpt M (init_tr M));\n        c \\<le> length (fixpt M (init_tr M));\n        \\<not> tr_lookup (fixpt M (init_tr M)) a b;\n        \\<not> tr_lookup (fixpt M (init_tr M)) b c\\<rbrakk>\n       \\<Longrightarrow> \\<not> tr_lookup (fixpt M (init_tr M)) a c", "fix a b c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<le> length (fixpt M (init_tr M));\n        b \\<le> length (fixpt M (init_tr M));\n        c \\<le> length (fixpt M (init_tr M));\n        \\<not> tr_lookup (fixpt M (init_tr M)) a b;\n        \\<not> tr_lookup (fixpt M (init_tr M)) b c\\<rbrakk>\n       \\<Longrightarrow> \\<not> tr_lookup (fixpt M (init_tr M)) a c", "assume H': \"a \\<le> length (fixpt M (init_tr M))\" \"b \\<le> length (fixpt M (init_tr M))\" \"c \\<le> length (fixpt M (init_tr M))\" \"\\<not> tr_lookup (fixpt M (init_tr M)) a b\"\n        \"\\<not> tr_lookup (fixpt M (init_tr M)) b c\""], ["proof (state)\nthis:\n  a \\<le> length (fixpt M (init_tr M))\n  b \\<le> length (fixpt M (init_tr M))\n  c \\<le> length (fixpt M (init_tr M))\n  \\<not> tr_lookup (fixpt M (init_tr M)) a b\n  \\<not> tr_lookup (fixpt M (init_tr M)) b c\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<le> length (fixpt M (init_tr M));\n        b \\<le> length (fixpt M (init_tr M));\n        c \\<le> length (fixpt M (init_tr M));\n        \\<not> tr_lookup (fixpt M (init_tr M)) a b;\n        \\<not> tr_lookup (fixpt M (init_tr M)) b c\\<rbrakk>\n       \\<Longrightarrow> \\<not> tr_lookup (fixpt M (init_tr M)) a c", "{"], ["proof (state)\nthis:\n  a \\<le> length (fixpt M (init_tr M))\n  b \\<le> length (fixpt M (init_tr M))\n  c \\<le> length (fixpt M (init_tr M))\n  \\<not> tr_lookup (fixpt M (init_tr M)) a b\n  \\<not> tr_lookup (fixpt M (init_tr M)) b c\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<le> length (fixpt M (init_tr M));\n        b \\<le> length (fixpt M (init_tr M));\n        c \\<le> length (fixpt M (init_tr M));\n        \\<not> tr_lookup (fixpt M (init_tr M)) a b;\n        \\<not> tr_lookup (fixpt M (init_tr M)) b c\\<rbrakk>\n       \\<Longrightarrow> \\<not> tr_lookup (fixpt M (init_tr M)) a c", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<le> length (fixpt M (init_tr M));\n        b \\<le> length (fixpt M (init_tr M));\n        c \\<le> length (fixpt M (init_tr M));\n        \\<not> tr_lookup (fixpt M (init_tr M)) a b;\n        \\<not> tr_lookup (fixpt M (init_tr M)) b c\\<rbrakk>\n       \\<Longrightarrow> \\<not> tr_lookup (fixpt M (init_tr M)) a c", "assume H'': \"q \\<le> length (fixpt M (init_tr M))\""], ["proof (state)\nthis:\n  q \\<le> length (fixpt M (init_tr M))\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<le> length (fixpt M (init_tr M));\n        b \\<le> length (fixpt M (init_tr M));\n        c \\<le> length (fixpt M (init_tr M));\n        \\<not> tr_lookup (fixpt M (init_tr M)) a b;\n        \\<not> tr_lookup (fixpt M (init_tr M)) b c\\<rbrakk>\n       \\<Longrightarrow> \\<not> tr_lookup (fixpt M (init_tr M)) a c", "from assms"], ["proof (chain)\npicking this:\n  wf_dfa M v\n  dfa_is_node M p\n  dfa_is_node M q", "have \"length (fst M) > 0\""], ["proof (prove)\nusing this:\n  wf_dfa M v\n  dfa_is_node M p\n  dfa_is_node M q\n\ngoal (1 subgoal):\n 1. 0 < length (fst M)", "by (simp add: wf_dfa_def)"], ["proof (state)\nthis:\n  0 < length (fst M)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<le> length (fixpt M (init_tr M));\n        b \\<le> length (fixpt M (init_tr M));\n        c \\<le> length (fixpt M (init_tr M));\n        \\<not> tr_lookup (fixpt M (init_tr M)) a b;\n        \\<not> tr_lookup (fixpt M (init_tr M)) b c\\<rbrakk>\n       \\<Longrightarrow> \\<not> tr_lookup (fixpt M (init_tr M)) a c", "then"], ["proof (chain)\npicking this:\n  0 < length (fst M)", "obtain m where M: \"length (fst M) = Suc m\""], ["proof (prove)\nusing this:\n  0 < length (fst M)\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        length (fst M) = Suc m \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"length (fst M)\") simp+"], ["proof (state)\nthis:\n  length (fst M) = Suc m\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<le> length (fixpt M (init_tr M));\n        b \\<le> length (fixpt M (init_tr M));\n        c \\<le> length (fixpt M (init_tr M));\n        \\<not> tr_lookup (fixpt M (init_tr M)) a b;\n        \\<not> tr_lookup (fixpt M (init_tr M)) b c\\<rbrakk>\n       \\<Longrightarrow> \\<not> tr_lookup (fixpt M (init_tr M)) a c", "hence M': \"m = length (fst M) - 1\""], ["proof (prove)\nusing this:\n  length (fst M) = Suc m\n\ngoal (1 subgoal):\n 1. m = length (fst M) - 1", "by simp"], ["proof (state)\nthis:\n  m = length (fst M) - 1\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<le> length (fixpt M (init_tr M));\n        b \\<le> length (fixpt M (init_tr M));\n        c \\<le> length (fixpt M (init_tr M));\n        \\<not> tr_lookup (fixpt M (init_tr M)) a b;\n        \\<not> tr_lookup (fixpt M (init_tr M)) b c\\<rbrakk>\n       \\<Longrightarrow> \\<not> tr_lookup (fixpt M (init_tr M)) a c", "with H'' WF"], ["proof (chain)\npicking this:\n  q \\<le> length (fixpt M (init_tr M))\n  wf_tr M (fixpt M (init_tr M))\n  m = length (fst M) - 1", "have \"q \\<le> m\""], ["proof (prove)\nusing this:\n  q \\<le> length (fixpt M (init_tr M))\n  wf_tr M (fixpt M (init_tr M))\n  m = length (fst M) - 1\n\ngoal (1 subgoal):\n 1. q \\<le> m", "by (simp add: wf_tr_def)"], ["proof (state)\nthis:\n  q \\<le> m\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<le> length (fixpt M (init_tr M));\n        b \\<le> length (fixpt M (init_tr M));\n        c \\<le> length (fixpt M (init_tr M));\n        \\<not> tr_lookup (fixpt M (init_tr M)) a b;\n        \\<not> tr_lookup (fixpt M (init_tr M)) b c\\<rbrakk>\n       \\<Longrightarrow> \\<not> tr_lookup (fixpt M (init_tr M)) a c", "with M"], ["proof (chain)\npicking this:\n  length (fst M) = Suc m\n  q \\<le> m", "have \"q < length (fst M)\""], ["proof (prove)\nusing this:\n  length (fst M) = Suc m\n  q \\<le> m\n\ngoal (1 subgoal):\n 1. q < length (fst M)", "by simp"], ["proof (state)\nthis:\n  q < length (fst M)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<le> length (fixpt M (init_tr M));\n        b \\<le> length (fixpt M (init_tr M));\n        c \\<le> length (fixpt M (init_tr M));\n        \\<not> tr_lookup (fixpt M (init_tr M)) a b;\n        \\<not> tr_lookup (fixpt M (init_tr M)) b c\\<rbrakk>\n       \\<Longrightarrow> \\<not> tr_lookup (fixpt M (init_tr M)) a c", "}"], ["proof (state)\nthis:\n  ?qa2 \\<le> length (fixpt M (init_tr M)) \\<Longrightarrow>\n  ?qa2 < length (fst M)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<le> length (fixpt M (init_tr M));\n        b \\<le> length (fixpt M (init_tr M));\n        c \\<le> length (fixpt M (init_tr M));\n        \\<not> tr_lookup (fixpt M (init_tr M)) a b;\n        \\<not> tr_lookup (fixpt M (init_tr M)) b c\\<rbrakk>\n       \\<Longrightarrow> \\<not> tr_lookup (fixpt M (init_tr M)) a c", "with H'"], ["proof (chain)\npicking this:\n  a \\<le> length (fixpt M (init_tr M))\n  b \\<le> length (fixpt M (init_tr M))\n  c \\<le> length (fixpt M (init_tr M))\n  \\<not> tr_lookup (fixpt M (init_tr M)) a b\n  \\<not> tr_lookup (fixpt M (init_tr M)) b c\n  ?qa2 \\<le> length (fixpt M (init_tr M)) \\<Longrightarrow>\n  ?qa2 < length (fst M)", "have D: \"dfa_is_node M a\" \"dfa_is_node M b\" \"dfa_is_node M c\""], ["proof (prove)\nusing this:\n  a \\<le> length (fixpt M (init_tr M))\n  b \\<le> length (fixpt M (init_tr M))\n  c \\<le> length (fixpt M (init_tr M))\n  \\<not> tr_lookup (fixpt M (init_tr M)) a b\n  \\<not> tr_lookup (fixpt M (init_tr M)) b c\n  ?qa2 \\<le> length (fixpt M (init_tr M)) \\<Longrightarrow>\n  ?qa2 < length (fst M)\n\ngoal (1 subgoal):\n 1. dfa_is_node M a &&& dfa_is_node M b &&& dfa_is_node M c", "by (auto simp: dfa_is_node_def)"], ["proof (state)\nthis:\n  dfa_is_node M a\n  dfa_is_node M b\n  dfa_is_node M c\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<le> length (fixpt M (init_tr M));\n        b \\<le> length (fixpt M (init_tr M));\n        c \\<le> length (fixpt M (init_tr M));\n        \\<not> tr_lookup (fixpt M (init_tr M)) a b;\n        \\<not> tr_lookup (fixpt M (init_tr M)) b c\\<rbrakk>\n       \\<Longrightarrow> \\<not> tr_lookup (fixpt M (init_tr M)) a c", "with H'(4,5) assms(1)"], ["proof (chain)\npicking this:\n  \\<not> tr_lookup (fixpt M (init_tr M)) a b\n  \\<not> tr_lookup (fixpt M (init_tr M)) b c\n  wf_dfa M v\n  dfa_is_node M a\n  dfa_is_node M b\n  dfa_is_node M c", "have \"\\<not> (\\<exists>n. dist_nodes M n v a b)\" \"\\<not> (\\<exists>n. dist_nodes M n v b c)\""], ["proof (prove)\nusing this:\n  \\<not> tr_lookup (fixpt M (init_tr M)) a b\n  \\<not> tr_lookup (fixpt M (init_tr M)) b c\n  wf_dfa M v\n  dfa_is_node M a\n  dfa_is_node M b\n  dfa_is_node M c\n\ngoal (1 subgoal):\n 1. \\<nexists>n. dist_nodes M n v a b &&& \\<nexists>n. dist_nodes M n v b c", "by (simp add: fixpt_dist_nodes[symmetric])+"], ["proof (state)\nthis:\n  \\<nexists>n. dist_nodes M n v a b\n  \\<nexists>n. dist_nodes M n v b c\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<le> length (fixpt M (init_tr M));\n        b \\<le> length (fixpt M (init_tr M));\n        c \\<le> length (fixpt M (init_tr M));\n        \\<not> tr_lookup (fixpt M (init_tr M)) a b;\n        \\<not> tr_lookup (fixpt M (init_tr M)) b c\\<rbrakk>\n       \\<Longrightarrow> \\<not> tr_lookup (fixpt M (init_tr M)) a c", "hence \"\\<not> (\\<exists>n. dist_nodes M n v a c)\""], ["proof (prove)\nusing this:\n  \\<nexists>n. dist_nodes M n v a b\n  \\<nexists>n. dist_nodes M n v b c\n\ngoal (1 subgoal):\n 1. \\<nexists>n. dist_nodes M n v a c", "by (auto simp: dist_nodes_def)"], ["proof (state)\nthis:\n  \\<nexists>n. dist_nodes M n v a c\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<le> length (fixpt M (init_tr M));\n        b \\<le> length (fixpt M (init_tr M));\n        c \\<le> length (fixpt M (init_tr M));\n        \\<not> tr_lookup (fixpt M (init_tr M)) a b;\n        \\<not> tr_lookup (fixpt M (init_tr M)) b c\\<rbrakk>\n       \\<Longrightarrow> \\<not> tr_lookup (fixpt M (init_tr M)) a c", "with H' assms D"], ["proof (chain)\npicking this:\n  a \\<le> length (fixpt M (init_tr M))\n  b \\<le> length (fixpt M (init_tr M))\n  c \\<le> length (fixpt M (init_tr M))\n  \\<not> tr_lookup (fixpt M (init_tr M)) a b\n  \\<not> tr_lookup (fixpt M (init_tr M)) b c\n  wf_dfa M v\n  dfa_is_node M p\n  dfa_is_node M q\n  dfa_is_node M a\n  dfa_is_node M b\n  dfa_is_node M c\n  \\<nexists>n. dist_nodes M n v a c", "show \"\\<not> tr_lookup (fixpt M (init_tr M)) a c\""], ["proof (prove)\nusing this:\n  a \\<le> length (fixpt M (init_tr M))\n  b \\<le> length (fixpt M (init_tr M))\n  c \\<le> length (fixpt M (init_tr M))\n  \\<not> tr_lookup (fixpt M (init_tr M)) a b\n  \\<not> tr_lookup (fixpt M (init_tr M)) b c\n  wf_dfa M v\n  dfa_is_node M p\n  dfa_is_node M q\n  dfa_is_node M a\n  dfa_is_node M b\n  dfa_is_node M c\n  \\<nexists>n. dist_nodes M n v a c\n\ngoal (1 subgoal):\n 1. \\<not> tr_lookup (fixpt M (init_tr M)) a c", "by (simp add: fixpt_dist_nodes[symmetric])"], ["proof (state)\nthis:\n  \\<not> tr_lookup (fixpt M (init_tr M)) a c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<le> length (fixpt M (init_tr M));\n   ?b \\<le> length (fixpt M (init_tr M));\n   ?c \\<le> length (fixpt M (init_tr M));\n   \\<not> tr_lookup (fixpt M (init_tr M)) ?a ?b;\n   \\<not> tr_lookup (fixpt M (init_tr M)) ?b ?c\\<rbrakk>\n  \\<Longrightarrow> \\<not> tr_lookup (fixpt M (init_tr M)) ?a ?c\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     p =\n     fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     q) =\n    (\\<not> tr_lookup (fixpt M (init_tr M)) p q)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<le> length (fixpt M (init_tr M));\n   ?b \\<le> length (fixpt M (init_tr M));\n   ?c \\<le> length (fixpt M (init_tr M));\n   \\<not> tr_lookup (fixpt M (init_tr M)) ?a ?b;\n   \\<not> tr_lookup (fixpt M (init_tr M)) ?b ?c\\<rbrakk>\n  \\<Longrightarrow> \\<not> tr_lookup (fixpt M (init_tr M)) ?a ?c\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     p =\n     fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     q) =\n    (\\<not> tr_lookup (fixpt M (init_tr M)) p q)", "have \"\\<And>x k. \\<lbrakk>x \\<in> set (replicate (length (fst M)) None); x = Some k\\<rbrakk> \\<Longrightarrow> k < length []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x k.\n       \\<lbrakk>x \\<in> set (replicate (length (fst M)) None);\n        x = Some k\\<rbrakk>\n       \\<Longrightarrow> k < length []", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x k.\n       \\<lbrakk>x \\<in> set (replicate (length (fst M)) None);\n        x = Some k\\<rbrakk>\n       \\<Longrightarrow> k < length []", "fix x k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x k.\n       \\<lbrakk>x \\<in> set (replicate (length (fst M)) None);\n        x = Some k\\<rbrakk>\n       \\<Longrightarrow> k < length []", "assume \"x \\<in> set (replicate (length (fst M)) (None::nat option))\" \"x = Some k\""], ["proof (state)\nthis:\n  x \\<in> set (replicate (length (fst M)) None)\n  x = Some k\n\ngoal (1 subgoal):\n 1. \\<And>x k.\n       \\<lbrakk>x \\<in> set (replicate (length (fst M)) None);\n        x = Some k\\<rbrakk>\n       \\<Longrightarrow> k < length []", "thus \"k < length []\""], ["proof (prove)\nusing this:\n  x \\<in> set (replicate (length (fst M)) None)\n  x = Some k\n\ngoal (1 subgoal):\n 1. k < length []", "by (cases \"length (fst M) = 0\") simp+"], ["proof (state)\nthis:\n  k < length []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> set (replicate (length (fst M)) None);\n   ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length []\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     p =\n     fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     q) =\n    (\\<not> tr_lookup (fixpt M (init_tr M)) p q)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> set (replicate (length (fst M)) None);\n   ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length []\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     p =\n     fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     q) =\n    (\\<not> tr_lookup (fixpt M (init_tr M)) p q)", "from WF assms"], ["proof (chain)\npicking this:\n  wf_tr M (fixpt M (init_tr M))\n  wf_dfa M v\n  dfa_is_node M p\n  dfa_is_node M q", "have \"length (replicate (length (fst M)) None) + 0 = length (fixpt M (init_tr M)) + 1\""], ["proof (prove)\nusing this:\n  wf_tr M (fixpt M (init_tr M))\n  wf_dfa M v\n  dfa_is_node M p\n  dfa_is_node M q\n\ngoal (1 subgoal):\n 1. length (replicate (length (fst M)) None) + 0 =\n    length (fixpt M (init_tr M)) + 1", "by (simp add: wf_tr_def wf_dfa_def)"], ["proof (state)\nthis:\n  length (replicate (length (fst M)) None) + 0 =\n  length (fixpt M (init_tr M)) + 1\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     p =\n     fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     q) =\n    (\\<not> tr_lookup (fixpt M (init_tr M)) p q)", "moreover"], ["proof (state)\nthis:\n  length (replicate (length (fst M)) None) + 0 =\n  length (fixpt M (init_tr M)) + 1\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     p =\n     fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     q) =\n    (\\<not> tr_lookup (fixpt M (init_tr M)) p q)", "from assms"], ["proof (chain)\npicking this:\n  wf_dfa M v\n  dfa_is_node M p\n  dfa_is_node M q", "have \"p < length (replicate (length (fst M)) None)\" \"q < length (replicate (length (fst M)) None)\""], ["proof (prove)\nusing this:\n  wf_dfa M v\n  dfa_is_node M p\n  dfa_is_node M q\n\ngoal (1 subgoal):\n 1. p < length (replicate (length (fst M)) None) &&&\n    q < length (replicate (length (fst M)) None)", "by (simp add: dfa_is_node_def)+"], ["proof (state)\nthis:\n  p < length (replicate (length (fst M)) None)\n  q < length (replicate (length (fst M)) None)\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     p =\n     fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     q) =\n    (\\<not> tr_lookup (fixpt M (init_tr M)) p q)", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i2 < length (replicate (length (fst M)) None);\n   ?j2 < length (replicate (length (fst M)) None);\n   replicate (length (fst M)) None ! ?i2 = Some ?k2\\<rbrakk>\n  \\<Longrightarrow> (replicate (length (fst M)) None ! ?j2 = Some ?k2) =\n                    (\\<not> tr_lookup (fixpt M (init_tr M)) (?i2 + 0)\n                             (?j2 + 0))\n  \\<lbrakk>?a \\<le> length (fixpt M (init_tr M));\n   ?b \\<le> length (fixpt M (init_tr M));\n   ?c \\<le> length (fixpt M (init_tr M));\n   \\<not> tr_lookup (fixpt M (init_tr M)) ?a ?b;\n   \\<not> tr_lookup (fixpt M (init_tr M)) ?b ?c\\<rbrakk>\n  \\<Longrightarrow> \\<not> tr_lookup (fixpt M (init_tr M)) ?a ?c\n  \\<lbrakk>?x \\<in> set (replicate (length (fst M)) None);\n   ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length []\n  length (replicate (length (fst M)) None) + 0 =\n  length (fixpt M (init_tr M)) + 1\n  p < length (replicate (length (fst M)) None)\n  q < length (replicate (length (fst M)) None)", "have \"(fst ?M ! p = fst ?M ! q) = (\\<not> tr_lookup (fixpt M (init_tr M)) (p+0) (q+0))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i2 < length (replicate (length (fst M)) None);\n   ?j2 < length (replicate (length (fst M)) None);\n   replicate (length (fst M)) None ! ?i2 = Some ?k2\\<rbrakk>\n  \\<Longrightarrow> (replicate (length (fst M)) None ! ?j2 = Some ?k2) =\n                    (\\<not> tr_lookup (fixpt M (init_tr M)) (?i2 + 0)\n                             (?j2 + 0))\n  \\<lbrakk>?a \\<le> length (fixpt M (init_tr M));\n   ?b \\<le> length (fixpt M (init_tr M));\n   ?c \\<le> length (fixpt M (init_tr M));\n   \\<not> tr_lookup (fixpt M (init_tr M)) ?a ?b;\n   \\<not> tr_lookup (fixpt M (init_tr M)) ?b ?c\\<rbrakk>\n  \\<Longrightarrow> \\<not> tr_lookup (fixpt M (init_tr M)) ?a ?c\n  \\<lbrakk>?x \\<in> set (replicate (length (fst M)) None);\n   ?x = Some ?k\\<rbrakk>\n  \\<Longrightarrow> ?k < length []\n  length (replicate (length (fst M)) None) + 0 =\n  length (fixpt M (init_tr M)) + 1\n  p < length (replicate (length (fst M)) None)\n  q < length (replicate (length (fst M)) None)\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     p =\n     fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     q) =\n    (\\<not> tr_lookup (fixpt M (init_tr M)) (p + 0) (q + 0))", "by (rule mk_eqcl_fst_nth)"], ["proof (state)\nthis:\n  (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   p =\n   fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   q) =\n  (\\<not> tr_lookup (fixpt M (init_tr M)) (p + 0) (q + 0))\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     p =\n     fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     q) =\n    (\\<not> tr_lookup (fixpt M (init_tr M)) p q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   p =\n   fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   q) =\n  (\\<not> tr_lookup (fixpt M (init_tr M)) (p + 0) (q + 0))\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     p =\n     fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     q) =\n    (\\<not> tr_lookup (fixpt M (init_tr M)) p q)", "by simp"], ["proof (state)\nthis:\n  (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   p =\n   fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   q) =\n  (\\<not> tr_lookup (fixpt M (init_tr M)) p q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   p =\n   fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   q) =\n  (\\<not> tr_lookup (fixpt M (init_tr M)) p q)\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     p =\n     fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     q) =\n    eq_nodes M v p q", "also"], ["proof (state)\nthis:\n  (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   p =\n   fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   q) =\n  (\\<not> tr_lookup (fixpt M (init_tr M)) p q)\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     p =\n     fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     q) =\n    eq_nodes M v p q", "from assms"], ["proof (chain)\npicking this:\n  wf_dfa M v\n  dfa_is_node M p\n  dfa_is_node M q", "have \"\\<dots> = eq_nodes M v p q\""], ["proof (prove)\nusing this:\n  wf_dfa M v\n  dfa_is_node M p\n  dfa_is_node M q\n\ngoal (1 subgoal):\n 1. (\\<not> tr_lookup (fixpt M (init_tr M)) p q) = eq_nodes M v p q", "by (simp only: fixpt_dist_nodes eq_nodes_def)"], ["proof (state)\nthis:\n  (\\<not> tr_lookup (fixpt M (init_tr M)) p q) = eq_nodes M v p q\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     p =\n     fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     q) =\n    eq_nodes M v p q", "finally"], ["proof (chain)\npicking this:\n  (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   p =\n   fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   q) =\n  eq_nodes M v p q", "show ?thesis"], ["proof (prove)\nusing this:\n  (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   p =\n   fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   q) =\n  eq_nodes M v p q\n\ngoal (1 subgoal):\n 1. (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     p =\n     fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     q) =\n    eq_nodes M v p q", "by simp"], ["proof (state)\nthis:\n  (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   p =\n   fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   q) =\n  eq_nodes M v p q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mk_eqcl_fixpt_fst_snd_nth:\n  assumes \"i < length (snd (mk_eqcl (replicate (length (fst M)) None) [] 0 (fixpt M (init_tr M))))\"\n  and \"wf_dfa M v\"\n  shows \"snd (mk_eqcl (replicate (length (fst M)) None) [] 0 (fixpt M (init_tr M))) ! i < length (fst (mk_eqcl (replicate (length (fst M)) None) [] 0 (fixpt M (init_tr M)))) \\<and>\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0 (fixpt M (init_tr M))) ! (snd (mk_eqcl (replicate (length (fst M)) None) [] 0 (fixpt M (init_tr M))) ! i) = i\"\n  (is \"snd ?M ! i < length (fst ?M) \\<and> fst ?M ! (snd ?M ! i) = i\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    i\n    < length\n       (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M)))) \\<and>\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     i) =\n    i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    i\n    < length\n       (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M)))) \\<and>\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     i) =\n    i", "have \"\\<And>i. i < length [] \\<Longrightarrow> [] ! i < length (replicate (length (fst M)) None) + 0 \\<and> (0 \\<le> [] ! i \\<longrightarrow> replicate (length (fst M)) None ! ([] ! i - 0) = Some i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length [] \\<Longrightarrow>\n       [] ! i < length (replicate (length (fst M)) None) + 0 \\<and>\n       ((0::'c) \\<le> [] ! i \\<longrightarrow>\n        replicate (length (fst M)) None ! ([] ! i - 0) = Some i)", "by simp"], ["proof (state)\nthis:\n  ?i < length [] \\<Longrightarrow>\n  [] ! ?i < length (replicate (length (fst M)) None) + 0 \\<and>\n  ((0::?'c1) \\<le> [] ! ?i \\<longrightarrow>\n   replicate (length (fst M)) None ! ([] ! ?i - 0) = Some ?i)\n\ngoal (1 subgoal):\n 1. snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    i\n    < length\n       (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M)))) \\<and>\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     i) =\n    i", "moreover"], ["proof (state)\nthis:\n  ?i < length [] \\<Longrightarrow>\n  [] ! ?i < length (replicate (length (fst M)) None) + 0 \\<and>\n  ((0::?'c1) \\<le> [] ! ?i \\<longrightarrow>\n   replicate (length (fst M)) None ! ([] ! ?i - 0) = Some ?i)\n\ngoal (1 subgoal):\n 1. snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    i\n    < length\n       (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M)))) \\<and>\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     i) =\n    i", "have \"\\<And>j1 j2. \\<lbrakk>j1 < j2; j2 < length []\\<rbrakk> \\<Longrightarrow> [] ! j1 < [] ! j2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j1 j2.\n       \\<lbrakk>j1 < j2; j2 < length []\\<rbrakk>\n       \\<Longrightarrow> [] ! j1 < [] ! j2", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>?j1.1 < ?j2.1; ?j2.1 < length []\\<rbrakk>\n  \\<Longrightarrow> [] ! ?j1.1 < [] ! ?j2.1\n\ngoal (1 subgoal):\n 1. snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    i\n    < length\n       (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M)))) \\<and>\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     i) =\n    i", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?j1.1 < ?j2.1; ?j2.1 < length []\\<rbrakk>\n  \\<Longrightarrow> [] ! ?j1.1 < [] ! ?j2.1\n\ngoal (1 subgoal):\n 1. snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    i\n    < length\n       (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M)))) \\<and>\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     i) =\n    i", "have \"\\<And>z. z \\<in> set [] \\<Longrightarrow> z < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z. z \\<in> set [] \\<Longrightarrow> z < (0::'a)", "by simp"], ["proof (state)\nthis:\n  ?z2 \\<in> set [] \\<Longrightarrow> ?z2 < (0::?'a3)\n\ngoal (1 subgoal):\n 1. snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    i\n    < length\n       (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M)))) \\<and>\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     i) =\n    i", "moreover"], ["proof (state)\nthis:\n  ?z2 \\<in> set [] \\<Longrightarrow> ?z2 < (0::?'a3)\n\ngoal (1 subgoal):\n 1. snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    i\n    < length\n       (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M)))) \\<and>\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     i) =\n    i", "note assms(1)"], ["proof (state)\nthis:\n  i < length\n       (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M))))\n\ngoal (1 subgoal):\n 1. snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    i\n    < length\n       (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M)))) \\<and>\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     i) =\n    i", "moreover"], ["proof (state)\nthis:\n  i < length\n       (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M))))\n\ngoal (1 subgoal):\n 1. snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    i\n    < length\n       (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M)))) \\<and>\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     i) =\n    i", "have \"length (replicate (length (fst M)) None) + 0 \\<le> length (fixpt M (init_tr M)) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (replicate (length (fst M)) None) + 0\n    \\<le> length (fixpt M (init_tr M)) + 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length (replicate (length (fst M)) None) + 0\n    \\<le> length (fixpt M (init_tr M)) + 1", "have WF: \"wf_tr M (fixpt M (init_tr M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_tr M (fixpt M (init_tr M))", "by (simp only: init_tr_wf fixpt_wf)"], ["proof (state)\nthis:\n  wf_tr M (fixpt M (init_tr M))\n\ngoal (1 subgoal):\n 1. length (replicate (length (fst M)) None) + 0\n    \\<le> length (fixpt M (init_tr M)) + 1", "from assms"], ["proof (chain)\npicking this:\n  i < length\n       (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M))))\n  wf_dfa M v", "have \"length (fst M) > 0\""], ["proof (prove)\nusing this:\n  i < length\n       (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M))))\n  wf_dfa M v\n\ngoal (1 subgoal):\n 1. 0 < length (fst M)", "by (simp add: wf_dfa_def)"], ["proof (state)\nthis:\n  0 < length (fst M)\n\ngoal (1 subgoal):\n 1. length (replicate (length (fst M)) None) + 0\n    \\<le> length (fixpt M (init_tr M)) + 1", "then"], ["proof (chain)\npicking this:\n  0 < length (fst M)", "obtain m where M:\"length (fst M) = Suc m\""], ["proof (prove)\nusing this:\n  0 < length (fst M)\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        length (fst M) = Suc m \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"length (fst M)\") simp+"], ["proof (state)\nthis:\n  length (fst M) = Suc m\n\ngoal (1 subgoal):\n 1. length (replicate (length (fst M)) None) + 0\n    \\<le> length (fixpt M (init_tr M)) + 1", "hence M': \"m = length (fst M) - 1\""], ["proof (prove)\nusing this:\n  length (fst M) = Suc m\n\ngoal (1 subgoal):\n 1. m = length (fst M) - 1", "by simp"], ["proof (state)\nthis:\n  m = length (fst M) - 1\n\ngoal (1 subgoal):\n 1. length (replicate (length (fst M)) None) + 0\n    \\<le> length (fixpt M (init_tr M)) + 1", "with WF"], ["proof (chain)\npicking this:\n  wf_tr M (fixpt M (init_tr M))\n  m = length (fst M) - 1", "have \"length (fixpt M (init_tr M)) = m\""], ["proof (prove)\nusing this:\n  wf_tr M (fixpt M (init_tr M))\n  m = length (fst M) - 1\n\ngoal (1 subgoal):\n 1. length (fixpt M (init_tr M)) = m", "by (simp add: wf_tr_def)"], ["proof (state)\nthis:\n  length (fixpt M (init_tr M)) = m\n\ngoal (1 subgoal):\n 1. length (replicate (length (fst M)) None) + 0\n    \\<le> length (fixpt M (init_tr M)) + 1", "with M"], ["proof (chain)\npicking this:\n  length (fst M) = Suc m\n  length (fixpt M (init_tr M)) = m", "show ?thesis"], ["proof (prove)\nusing this:\n  length (fst M) = Suc m\n  length (fixpt M (init_tr M)) = m\n\ngoal (1 subgoal):\n 1. length (replicate (length (fst M)) None) + 0\n    \\<le> length (fixpt M (init_tr M)) + 1", "by simp"], ["proof (state)\nthis:\n  length (replicate (length (fst M)) None) + 0\n  \\<le> length (fixpt M (init_tr M)) + 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (replicate (length (fst M)) None) + 0\n  \\<le> length (fixpt M (init_tr M)) + 1\n\ngoal (1 subgoal):\n 1. snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    i\n    < length\n       (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M)))) \\<and>\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     i) =\n    i", "ultimately"], ["proof (chain)\npicking this:\n  ?i < length [] \\<Longrightarrow>\n  [] ! ?i < length (replicate (length (fst M)) None) + 0 \\<and>\n  ((0::?'c1) \\<le> [] ! ?i \\<longrightarrow>\n   replicate (length (fst M)) None ! ([] ! ?i - 0) = Some ?i)\n  \\<lbrakk>?j1.1 < ?j2.1; ?j2.1 < length []\\<rbrakk>\n  \\<Longrightarrow> [] ! ?j1.1 < [] ! ?j2.1\n  ?z2 \\<in> set [] \\<Longrightarrow> ?z2 < (0::?'a3)\n  i < length\n       (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M))))\n  length (replicate (length (fst M)) None) + 0\n  \\<le> length (fixpt M (init_tr M)) + 1", "have \"snd ?M ! i < length (fst ?M) + 0 \\<and> (0 \\<le> snd ?M ! i \\<longrightarrow> fst ?M ! (snd ?M ! i - 0) = i)\""], ["proof (prove)\nusing this:\n  ?i < length [] \\<Longrightarrow>\n  [] ! ?i < length (replicate (length (fst M)) None) + 0 \\<and>\n  ((0::?'c1) \\<le> [] ! ?i \\<longrightarrow>\n   replicate (length (fst M)) None ! ([] ! ?i - 0) = Some ?i)\n  \\<lbrakk>?j1.1 < ?j2.1; ?j2.1 < length []\\<rbrakk>\n  \\<Longrightarrow> [] ! ?j1.1 < [] ! ?j2.1\n  ?z2 \\<in> set [] \\<Longrightarrow> ?z2 < (0::?'a3)\n  i < length\n       (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M))))\n  length (replicate (length (fst M)) None) + 0\n  \\<le> length (fixpt M (init_tr M)) + 1\n\ngoal (1 subgoal):\n 1. snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    i\n    < length\n       (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M)))) +\n      0 \\<and>\n    (0 \\<le> snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n                   (fixpt M (init_tr M))) !\n             i \\<longrightarrow>\n     fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))) !\n      i -\n      0) =\n     i)", "by (rule mk_eqcl_fst_snd)"], ["proof (state)\nthis:\n  snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  i\n  < length\n     (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M)))) +\n    0 \\<and>\n  (0 \\<le> snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n                 (fixpt M (init_tr M))) !\n           i \\<longrightarrow>\n   fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    i -\n    0) =\n   i)\n\ngoal (1 subgoal):\n 1. snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    i\n    < length\n       (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M)))) \\<and>\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     i) =\n    i", "thus ?thesis"], ["proof (prove)\nusing this:\n  snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  i\n  < length\n     (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M)))) +\n    0 \\<and>\n  (0 \\<le> snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n                 (fixpt M (init_tr M))) !\n           i \\<longrightarrow>\n   fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    i -\n    0) =\n   i)\n\ngoal (1 subgoal):\n 1. snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    i\n    < length\n       (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M)))) \\<and>\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     i) =\n    i", "by simp"], ["proof (state)\nthis:\n  snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  i\n  < length\n     (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M)))) \\<and>\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   i) =\n  i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eq_nodes_dfa_trans:\n  assumes \"eq_nodes M v p q\"\n  and \"is_alph v bs\"\n  shows \"eq_nodes M v (dfa_trans M p bs) (dfa_trans M q bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_nodes M v (dfa_trans M p bs) (dfa_trans M q bs)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> eq_nodes M v (dfa_trans M p bs)\n            (dfa_trans M q bs) \\<Longrightarrow>\n    False", "assume H: \"\\<not> eq_nodes M v (dfa_trans M p bs) (dfa_trans M q bs)\""], ["proof (state)\nthis:\n  \\<not> eq_nodes M v (dfa_trans M p bs) (dfa_trans M q bs)\n\ngoal (1 subgoal):\n 1. \\<not> eq_nodes M v (dfa_trans M p bs)\n            (dfa_trans M q bs) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> eq_nodes M v (dfa_trans M p bs) (dfa_trans M q bs)", "obtain n w where \"length w = n\" \"list_all (is_alph v) w\" \"dfa_accepting M (dfa_steps M (dfa_trans M p bs) w) \\<noteq> dfa_accepting M (dfa_steps M (dfa_trans M q bs) w)\""], ["proof (prove)\nusing this:\n  \\<not> eq_nodes M v (dfa_trans M p bs) (dfa_trans M q bs)\n\ngoal (1 subgoal):\n 1. (\\<And>w n.\n        \\<lbrakk>length w = n; list_all (is_alph v) w;\n         dfa_accepting M (dfa_steps M (dfa_trans M p bs) w) \\<noteq>\n         dfa_accepting M (dfa_steps M (dfa_trans M q bs) w)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding eq_nodes_def dist_nodes_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<nexists>n w.\n             length w = n \\<and>\n             list_all (is_alph v) w \\<and>\n             dfa_accepting M (dfa_steps M (dfa_trans M p bs) w) \\<noteq>\n             dfa_accepting M (dfa_steps M (dfa_trans M q bs) w))\n\ngoal (1 subgoal):\n 1. (\\<And>w n.\n        \\<lbrakk>length w = n; list_all (is_alph v) w;\n         dfa_accepting M (dfa_steps M (dfa_trans M p bs) w) \\<noteq>\n         dfa_accepting M (dfa_steps M (dfa_trans M q bs) w)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  length w = n\n  list_all (is_alph v) w\n  dfa_accepting M (dfa_steps M (dfa_trans M p bs) w) \\<noteq>\n  dfa_accepting M (dfa_steps M (dfa_trans M q bs) w)\n\ngoal (1 subgoal):\n 1. \\<not> eq_nodes M v (dfa_trans M p bs)\n            (dfa_trans M q bs) \\<Longrightarrow>\n    False", "with assms"], ["proof (chain)\npicking this:\n  eq_nodes M v p q\n  is_alph v bs\n  length w = n\n  list_all (is_alph v) w\n  dfa_accepting M (dfa_steps M (dfa_trans M p bs) w) \\<noteq>\n  dfa_accepting M (dfa_steps M (dfa_trans M q bs) w)", "have \"length (bs # w) = Suc n\" \"list_all (is_alph v) (bs # w)\" \"dfa_accepting M (dfa_steps M p (bs # w)) \\<noteq> dfa_accepting M (dfa_steps M q (bs # w))\""], ["proof (prove)\nusing this:\n  eq_nodes M v p q\n  is_alph v bs\n  length w = n\n  list_all (is_alph v) w\n  dfa_accepting M (dfa_steps M (dfa_trans M p bs) w) \\<noteq>\n  dfa_accepting M (dfa_steps M (dfa_trans M q bs) w)\n\ngoal (1 subgoal):\n 1. length (bs # w) = Suc n &&&\n    list_all (is_alph v) (bs # w) &&&\n    dfa_accepting M (dfa_steps M p (bs # w)) \\<noteq>\n    dfa_accepting M (dfa_steps M q (bs # w))", "by simp+"], ["proof (state)\nthis:\n  length (bs # w) = Suc n\n  list_all (is_alph v) (bs # w)\n  dfa_accepting M (dfa_steps M p (bs # w)) \\<noteq>\n  dfa_accepting M (dfa_steps M q (bs # w))\n\ngoal (1 subgoal):\n 1. \\<not> eq_nodes M v (dfa_trans M p bs)\n            (dfa_trans M q bs) \\<Longrightarrow>\n    False", "hence \"\\<not> eq_nodes M v p q\""], ["proof (prove)\nusing this:\n  length (bs # w) = Suc n\n  list_all (is_alph v) (bs # w)\n  dfa_accepting M (dfa_steps M p (bs # w)) \\<noteq>\n  dfa_accepting M (dfa_steps M q (bs # w))\n\ngoal (1 subgoal):\n 1. \\<not> eq_nodes M v p q", "unfolding eq_nodes_def dist_nodes_def"], ["proof (prove)\nusing this:\n  length (bs # w) = Suc n\n  list_all (is_alph v) (bs # w)\n  dfa_accepting M (dfa_steps M p (bs # w)) \\<noteq>\n  dfa_accepting M (dfa_steps M q (bs # w))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<nexists>n w.\n               length w = n \\<and>\n               list_all (is_alph v) w \\<and>\n               dfa_accepting M (dfa_steps M p w) \\<noteq>\n               dfa_accepting M (dfa_steps M q w))", "by blast"], ["proof (state)\nthis:\n  \\<not> eq_nodes M v p q\n\ngoal (1 subgoal):\n 1. \\<not> eq_nodes M v (dfa_trans M p bs)\n            (dfa_trans M q bs) \\<Longrightarrow>\n    False", "with assms"], ["proof (chain)\npicking this:\n  eq_nodes M v p q\n  is_alph v bs\n  \\<not> eq_nodes M v p q", "show False"], ["proof (prove)\nusing this:\n  eq_nodes M v p q\n  is_alph v bs\n  \\<not> eq_nodes M v p q\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mk_eqcl_fixpt_trans:\n  assumes \"wf_dfa M v\"\n  and \"dfa_is_node M p\"\n  and \"is_alph v bs\"\n  shows \"dfa_trans (min_dfa M) (fst (mk_eqcl (replicate (length (fst M)) None) [] 0 (fixpt M (init_tr M))) ! p) bs = \n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0 (fixpt M (init_tr M))) ! (dfa_trans M p bs)\"\n  (is \"dfa_trans (min_dfa M) (fst ?M ! p) bs = fst ?M ! (dfa_trans M p bs)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa_trans (min_dfa M)\n     (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))) !\n      p)\n     bs =\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    dfa_trans M p bs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dfa_trans (min_dfa M)\n     (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))) !\n      p)\n     bs =\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    dfa_trans M p bs", "let ?q = \"snd ?M ! (fst ?M ! p)\""], ["proof (state)\ngoal (1 subgoal):\n 1. dfa_trans (min_dfa M)\n     (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))) !\n      p)\n     bs =\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    dfa_trans M p bs", "from assms"], ["proof (chain)\npicking this:\n  wf_dfa M v\n  dfa_is_node M p\n  is_alph v bs", "have I1: \"?q < length (fst ?M)\" \"fst ?M ! ?q = fst ?M ! p\""], ["proof (prove)\nusing this:\n  wf_dfa M v\n  dfa_is_node M p\n  is_alph v bs\n\ngoal (1 subgoal):\n 1. snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     p)\n    < length\n       (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M)))) &&&\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))) !\n      p)) =\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    p", "by (simp add: mk_eqcl_fixpt_fst_bound mk_eqcl_fixpt_fst_snd_nth)+"], ["proof (state)\nthis:\n  snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   p)\n  < length\n     (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))))\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    p)) =\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  p\n\ngoal (1 subgoal):\n 1. dfa_trans (min_dfa M)\n     (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))) !\n      p)\n     bs =\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    dfa_trans M p bs", "with assms"], ["proof (chain)\npicking this:\n  wf_dfa M v\n  dfa_is_node M p\n  is_alph v bs\n  snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   p)\n  < length\n     (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))))\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    p)) =\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  p", "have I2: \"bddh (length bs) (fst M ! ?q)\""], ["proof (prove)\nusing this:\n  wf_dfa M v\n  dfa_is_node M p\n  is_alph v bs\n  snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   p)\n  < length\n     (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))))\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    p)) =\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  p\n\ngoal (1 subgoal):\n 1. bddh (length bs)\n     (fst M !\n      (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n             (fixpt M (init_tr M))) !\n       (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M))) !\n        p)))", "by (simp add: mk_eqcl_len_fst wf_dfa_def list_all_iff is_alph_def)"], ["proof (state)\nthis:\n  bddh (length bs)\n   (fst M !\n    (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))) !\n      p)))\n\ngoal (1 subgoal):\n 1. dfa_trans (min_dfa M)\n     (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))) !\n      p)\n     bs =\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    dfa_trans M p bs", "from I1"], ["proof (chain)\npicking this:\n  snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   p)\n  < length\n     (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))))\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    p)) =\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  p", "have I3: \"dfa_is_node M ?q\""], ["proof (prove)\nusing this:\n  snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   p)\n  < length\n     (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))))\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    p)) =\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  p\n\ngoal (1 subgoal):\n 1. dfa_is_node M\n     (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))) !\n      (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n             (fixpt M (init_tr M))) !\n       p))", "by (simp add: mk_eqcl_len_fst dfa_is_node_def)"], ["proof (state)\nthis:\n  dfa_is_node M\n   (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     p))\n\ngoal (1 subgoal):\n 1. dfa_trans (min_dfa M)\n     (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))) !\n      p)\n     bs =\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    dfa_trans M p bs", "with assms I1"], ["proof (chain)\npicking this:\n  wf_dfa M v\n  dfa_is_node M p\n  is_alph v bs\n  snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   p)\n  < length\n     (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))))\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    p)) =\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  p\n  dfa_is_node M\n   (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     p))", "have \"eq_nodes M v p ?q\""], ["proof (prove)\nusing this:\n  wf_dfa M v\n  dfa_is_node M p\n  is_alph v bs\n  snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   p)\n  < length\n     (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))))\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    p)) =\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  p\n  dfa_is_node M\n   (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     p))\n\ngoal (1 subgoal):\n 1. eq_nodes M v p\n     (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))) !\n      (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n             (fixpt M (init_tr M))) !\n       p))", "by (simp add: mk_eqcl_fixpt_fst_nth[symmetric])"], ["proof (state)\nthis:\n  eq_nodes M v p\n   (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     p))\n\ngoal (1 subgoal):\n 1. dfa_trans (min_dfa M)\n     (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))) !\n      p)\n     bs =\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    dfa_trans M p bs", "with assms"], ["proof (chain)\npicking this:\n  wf_dfa M v\n  dfa_is_node M p\n  is_alph v bs\n  eq_nodes M v p\n   (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     p))", "have \"eq_nodes M v (dfa_trans M p bs) (dfa_trans M ?q bs)\""], ["proof (prove)\nusing this:\n  wf_dfa M v\n  dfa_is_node M p\n  is_alph v bs\n  eq_nodes M v p\n   (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     p))\n\ngoal (1 subgoal):\n 1. eq_nodes M v (dfa_trans M p bs)\n     (dfa_trans M\n       (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M))) !\n        (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n               (fixpt M (init_tr M))) !\n         p))\n       bs)", "by (simp add: eq_nodes_dfa_trans)"], ["proof (state)\nthis:\n  eq_nodes M v (dfa_trans M p bs)\n   (dfa_trans M\n     (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))) !\n      (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n             (fixpt M (init_tr M))) !\n       p))\n     bs)\n\ngoal (1 subgoal):\n 1. dfa_trans (min_dfa M)\n     (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))) !\n      p)\n     bs =\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    dfa_trans M p bs", "with assms I3"], ["proof (chain)\npicking this:\n  wf_dfa M v\n  dfa_is_node M p\n  is_alph v bs\n  dfa_is_node M\n   (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     p))\n  eq_nodes M v (dfa_trans M p bs)\n   (dfa_trans M\n     (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))) !\n      (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n             (fixpt M (init_tr M))) !\n       p))\n     bs)", "have \"fst ?M ! (dfa_trans M p bs) = fst ?M ! (dfa_trans M ?q bs)\""], ["proof (prove)\nusing this:\n  wf_dfa M v\n  dfa_is_node M p\n  is_alph v bs\n  dfa_is_node M\n   (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     p))\n  eq_nodes M v (dfa_trans M p bs)\n   (dfa_trans M\n     (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))) !\n      (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n             (fixpt M (init_tr M))) !\n       p))\n     bs)\n\ngoal (1 subgoal):\n 1. fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    dfa_trans M p bs =\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    dfa_trans M\n     (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))) !\n      (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n             (fixpt M (init_tr M))) !\n       p))\n     bs", "by (simp add: dfa_trans_is_node mk_eqcl_fixpt_fst_nth)"], ["proof (state)\nthis:\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  dfa_trans M p bs =\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  dfa_trans M\n   (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     p))\n   bs\n\ngoal (1 subgoal):\n 1. dfa_trans (min_dfa M)\n     (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))) !\n      p)\n     bs =\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    dfa_trans M p bs", "with assms I2"], ["proof (chain)\npicking this:\n  wf_dfa M v\n  dfa_is_node M p\n  is_alph v bs\n  bddh (length bs)\n   (fst M !\n    (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))) !\n      p)))\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  dfa_trans M p bs =\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  dfa_trans M\n   (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     p))\n   bs", "show ?thesis"], ["proof (prove)\nusing this:\n  wf_dfa M v\n  dfa_is_node M p\n  is_alph v bs\n  bddh (length bs)\n   (fst M !\n    (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))) !\n      p)))\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  dfa_trans M p bs =\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  dfa_trans M\n   (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     p))\n   bs\n\ngoal (1 subgoal):\n 1. dfa_trans (min_dfa M)\n     (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))) !\n      p)\n     bs =\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    dfa_trans M p bs", "by (simp add: dfa_trans_def min_dfa_def split_beta mk_eqcl_fixpt_fst_bound bdd_map_bdd_lookup)"], ["proof (state)\nthis:\n  dfa_trans (min_dfa M)\n   (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    p)\n   bs =\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  dfa_trans M p bs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mk_eqcl_fixpt_steps:\n  assumes \"wf_dfa M v\"\n  and \"dfa_is_node M p\"\n  and \"list_all (is_alph v) w\"\n  shows \"dfa_steps (min_dfa M) (fst (mk_eqcl (replicate (length (fst M)) None) [] 0 (fixpt M (init_tr M))) ! p) w =\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0 (fixpt M (init_tr M))) ! (dfa_steps M p w)\"\n  (is \"dfa_steps (min_dfa M) (fst ?M ! p) w = fst ?M ! (dfa_steps M p w)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa_steps (min_dfa M)\n     (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))) !\n      p)\n     w =\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    dfa_steps M p w", "using assms"], ["proof (prove)\nusing this:\n  wf_dfa M v\n  dfa_is_node M p\n  list_all (is_alph v) w\n\ngoal (1 subgoal):\n 1. dfa_steps (min_dfa M)\n     (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))) !\n      p)\n     w =\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    dfa_steps M p w", "by (induct w arbitrary: p) (simp add: mk_eqcl_fixpt_trans dfa_trans_is_node)+"], ["", "lemma mk_eqcl_fixpt_startnode:\n  assumes \"length (fst M) > 0\"\n  shows \"length (snd (mk_eqcl (replicate (length (fst M)) None) [] 0 (fixpt M (init_tr M)))) > 0 \\<and> \n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0 (fixpt M (init_tr M))) ! 0 = 0 \\<and> snd (mk_eqcl (replicate (length (fst M)) None) [] 0 (fixpt M (init_tr M))) ! 0 = 0\"\n  (is \"length (snd ?M) > 0 \\<and> fst ?M ! 0 = 0 \\<and> snd ?M ! 0 = 0\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length\n         (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n                (fixpt M (init_tr M)))) \\<and>\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    0 =\n    0 \\<and>\n    snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    0 =\n    0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < length\n         (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n                (fixpt M (init_tr M)))) \\<and>\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    0 =\n    0 \\<and>\n    snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    0 =\n    0", "from assms"], ["proof (chain)\npicking this:\n  0 < length (fst M)", "obtain k where K: \"length (fst M) = Suc k\""], ["proof (prove)\nusing this:\n  0 < length (fst M)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        length (fst M) = Suc k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"length (fst M)\") simp+"], ["proof (state)\nthis:\n  length (fst M) = Suc k\n\ngoal (1 subgoal):\n 1. 0 < length\n         (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n                (fixpt M (init_tr M)))) \\<and>\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    0 =\n    0 \\<and>\n    snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    0 =\n    0", "from K"], ["proof (chain)\npicking this:\n  length (fst M) = Suc k", "have \"length (snd ?M) = length (snd (mk_eqcl (mk_eqcl' (replicate k None) 0 (Suc 0) 0 (fixpt M (init_tr M))) [0] (Suc 0) (fixpt M (init_tr M))))\""], ["proof (prove)\nusing this:\n  length (fst M) = Suc k\n\ngoal (1 subgoal):\n 1. length\n     (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M)))) =\n    length\n     (snd (mk_eqcl\n            (mk_eqcl' (replicate k None) 0 (Suc 0) 0 (fixpt M (init_tr M)))\n            [0] (Suc 0) (fixpt M (init_tr M))))", "by (simp add: split_beta)"], ["proof (state)\nthis:\n  length\n   (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M)))) =\n  length\n   (snd (mk_eqcl\n          (mk_eqcl' (replicate k None) 0 (Suc 0) 0 (fixpt M (init_tr M)))\n          [0] (Suc 0) (fixpt M (init_tr M))))\n\ngoal (1 subgoal):\n 1. 0 < length\n         (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n                (fixpt M (init_tr M)))) \\<and>\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    0 =\n    0 \\<and>\n    snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    0 =\n    0", "also"], ["proof (state)\nthis:\n  length\n   (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M)))) =\n  length\n   (snd (mk_eqcl\n          (mk_eqcl' (replicate k None) 0 (Suc 0) 0 (fixpt M (init_tr M)))\n          [0] (Suc 0) (fixpt M (init_tr M))))\n\ngoal (1 subgoal):\n 1. 0 < length\n         (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n                (fixpt M (init_tr M)))) \\<and>\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    0 =\n    0 \\<and>\n    snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    0 =\n    0", "have \"\\<dots> \\<ge> length [0::nat]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length [0]\n    \\<le> length\n           (snd (mk_eqcl\n                  (mk_eqcl' (replicate k None) 0 (Suc 0) 0\n                    (fixpt M (init_tr M)))\n                  [0] (Suc 0) (fixpt M (init_tr M))))", "by (simp only: mk_eqcl_len_snd)"], ["proof (state)\nthis:\n  length [0]\n  \\<le> length\n         (snd (mk_eqcl\n                (mk_eqcl' (replicate k None) 0 (Suc 0) 0\n                  (fixpt M (init_tr M)))\n                [0] (Suc 0) (fixpt M (init_tr M))))\n\ngoal (1 subgoal):\n 1. 0 < length\n         (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n                (fixpt M (init_tr M)))) \\<and>\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    0 =\n    0 \\<and>\n    snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    0 =\n    0", "finally"], ["proof (chain)\npicking this:\n  length [0]\n  \\<le> length\n         (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n                (fixpt M (init_tr M))))", "have \"length (snd ?M) > 0\""], ["proof (prove)\nusing this:\n  length [0]\n  \\<le> length\n         (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n                (fixpt M (init_tr M))))\n\ngoal (1 subgoal):\n 1. 0 < length\n         (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n                (fixpt M (init_tr M))))", "by auto"], ["proof (state)\nthis:\n  0 < length\n       (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M))))\n\ngoal (1 subgoal):\n 1. 0 < length\n         (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n                (fixpt M (init_tr M)))) \\<and>\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    0 =\n    0 \\<and>\n    snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    0 =\n    0", "with K"], ["proof (chain)\npicking this:\n  length (fst M) = Suc k\n  0 < length\n       (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M))))", "show ?thesis"], ["proof (prove)\nusing this:\n  length (fst M) = Suc k\n  0 < length\n       (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M))))\n\ngoal (1 subgoal):\n 1. 0 < length\n         (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n                (fixpt M (init_tr M)))) \\<and>\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    0 =\n    0 \\<and>\n    snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    0 =\n    0", "by (simp add: split_beta mk_eqcl_snd_nth)"], ["proof (state)\nthis:\n  0 < length\n       (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M)))) \\<and>\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  0 =\n  0 \\<and>\n  snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  0 =\n  0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma min_dfa_wf:\n  \"wf_dfa M v \\<Longrightarrow> wf_dfa (min_dfa M) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_dfa M v \\<Longrightarrow> wf_dfa (min_dfa M) v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_dfa M v \\<Longrightarrow> wf_dfa (min_dfa M) v", "assume H: \"wf_dfa M v\""], ["proof (state)\nthis:\n  wf_dfa M v\n\ngoal (1 subgoal):\n 1. wf_dfa M v \\<Longrightarrow> wf_dfa (min_dfa M) v", "obtain bd as where \"min_dfa M = (bd, as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>bd as.\n        min_dfa M = (bd, as) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"min_dfa M\") auto"], ["proof (state)\nthis:\n  min_dfa M = (bd, as)\n\ngoal (1 subgoal):\n 1. wf_dfa M v \\<Longrightarrow> wf_dfa (min_dfa M) v", "hence M: \"bd = fst (min_dfa M)\" \"as = snd (min_dfa M)\""], ["proof (prove)\nusing this:\n  min_dfa M = (bd, as)\n\ngoal (1 subgoal):\n 1. bd = fst (min_dfa M) &&& as = snd (min_dfa M)", "by simp+"], ["proof (state)\nthis:\n  bd = fst (min_dfa M)\n  as = snd (min_dfa M)\n\ngoal (1 subgoal):\n 1. wf_dfa M v \\<Longrightarrow> wf_dfa (min_dfa M) v", "let ?M = \"mk_eqcl (replicate (length (fst M)) None) [] 0 (fixpt M (init_tr M))\""], ["proof (state)\ngoal (1 subgoal):\n 1. wf_dfa M v \\<Longrightarrow> wf_dfa (min_dfa M) v", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_dfa M v \\<Longrightarrow> wf_dfa (min_dfa M) v", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_dfa M v \\<Longrightarrow> wf_dfa (min_dfa M) v", "assume \"x \\<in> set bd\""], ["proof (state)\nthis:\n  x \\<in> set bd\n\ngoal (1 subgoal):\n 1. wf_dfa M v \\<Longrightarrow> wf_dfa (min_dfa M) v", "then"], ["proof (chain)\npicking this:\n  x \\<in> set bd", "obtain i where I: \"i < length bd\" \"x = bd ! i\""], ["proof (prove)\nusing this:\n  x \\<in> set bd\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length bd; x = bd ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: in_set_conv_nth)"], ["proof (state)\nthis:\n  i < length bd\n  x = bd ! i\n\ngoal (1 subgoal):\n 1. wf_dfa M v \\<Longrightarrow> wf_dfa (min_dfa M) v", "with M H"], ["proof (chain)\npicking this:\n  bd = fst (min_dfa M)\n  as = snd (min_dfa M)\n  wf_dfa M v\n  i < length bd\n  x = bd ! i", "have \"snd ?M ! i < length (fst ?M)\""], ["proof (prove)\nusing this:\n  bd = fst (min_dfa M)\n  as = snd (min_dfa M)\n  wf_dfa M v\n  i < length bd\n  x = bd ! i\n\ngoal (1 subgoal):\n 1. snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    i\n    < length\n       (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M))))", "by (simp add: min_dfa_def split_beta mk_eqcl_fixpt_fst_snd_nth)"], ["proof (state)\nthis:\n  snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  i\n  < length\n     (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))))\n\ngoal (1 subgoal):\n 1. wf_dfa M v \\<Longrightarrow> wf_dfa (min_dfa M) v", "hence N: \"dfa_is_node M (snd ?M ! i)\""], ["proof (prove)\nusing this:\n  snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  i\n  < length\n     (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))))\n\ngoal (1 subgoal):\n 1. dfa_is_node M\n     (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))) !\n      i)", "by (simp add: mk_eqcl_len_fst dfa_is_node_def)"], ["proof (state)\nthis:\n  dfa_is_node M\n   (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    i)\n\ngoal (1 subgoal):\n 1. wf_dfa M v \\<Longrightarrow> wf_dfa (min_dfa M) v", "with H"], ["proof (chain)\npicking this:\n  wf_dfa M v\n  dfa_is_node M\n   (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    i)", "have BH: \"bddh v (fst M ! (snd ?M ! i))\""], ["proof (prove)\nusing this:\n  wf_dfa M v\n  dfa_is_node M\n   (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    i)\n\ngoal (1 subgoal):\n 1. bddh v\n     (fst M !\n      (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n             (fixpt M (init_tr M))) !\n       i))", "by (simp add: wf_dfa_def list_all_iff dfa_is_node_def)"], ["proof (state)\nthis:\n  bddh v\n   (fst M !\n    (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     i))\n\ngoal (1 subgoal):\n 1. wf_dfa M v \\<Longrightarrow> wf_dfa (min_dfa M) v", "from I M"], ["proof (chain)\npicking this:\n  i < length bd\n  x = bd ! i\n  bd = fst (min_dfa M)\n  as = snd (min_dfa M)", "have BI: \"bd ! i = bdd_map (\\<lambda>q. fst ?M ! q) (fst M ! (snd ?M ! i))\""], ["proof (prove)\nusing this:\n  i < length bd\n  x = bd ! i\n  bd = fst (min_dfa M)\n  as = snd (min_dfa M)\n\ngoal (1 subgoal):\n 1. bd ! i =\n    bdd_map\n     ((!) (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n                 (fixpt M (init_tr M)))))\n     (fst M !\n      (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n             (fixpt M (init_tr M))) !\n       i))", "by (simp add: split_beta min_dfa_def)"], ["proof (state)\nthis:\n  bd ! i =\n  bdd_map\n   ((!) (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n               (fixpt M (init_tr M)))))\n   (fst M !\n    (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     i))\n\ngoal (1 subgoal):\n 1. wf_dfa M v \\<Longrightarrow> wf_dfa (min_dfa M) v", "with BH"], ["proof (chain)\npicking this:\n  bddh v\n   (fst M !\n    (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     i))\n  bd ! i =\n  bdd_map\n   ((!) (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n               (fixpt M (init_tr M)))))\n   (fst M !\n    (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     i))", "have G1: \"bddh v (bd ! i)\""], ["proof (prove)\nusing this:\n  bddh v\n   (fst M !\n    (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     i))\n  bd ! i =\n  bdd_map\n   ((!) (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n               (fixpt M (init_tr M)))))\n   (fst M !\n    (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     i))\n\ngoal (1 subgoal):\n 1. bddh v (bd ! i)", "by (simp add: bddh_bdd_map)"], ["proof (state)\nthis:\n  bddh v (bd ! i)\n\ngoal (1 subgoal):\n 1. wf_dfa M v \\<Longrightarrow> wf_dfa (min_dfa M) v", "from H N"], ["proof (chain)\npicking this:\n  wf_dfa M v\n  dfa_is_node M\n   (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    i)", "have \"bdd_all (dfa_is_node M) (fst M ! (snd ?M ! i))\""], ["proof (prove)\nusing this:\n  wf_dfa M v\n  dfa_is_node M\n   (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    i)\n\ngoal (1 subgoal):\n 1. bdd_all (dfa_is_node M)\n     (fst M !\n      (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n             (fixpt M (init_tr M))) !\n       i))", "by (simp add: wf_dfa_def list_all_iff dfa_is_node_def)"], ["proof (state)\nthis:\n  bdd_all (dfa_is_node M)\n   (fst M !\n    (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     i))\n\ngoal (1 subgoal):\n 1. wf_dfa M v \\<Longrightarrow> wf_dfa (min_dfa M) v", "moreover"], ["proof (state)\nthis:\n  bdd_all (dfa_is_node M)\n   (fst M !\n    (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     i))\n\ngoal (1 subgoal):\n 1. wf_dfa M v \\<Longrightarrow> wf_dfa (min_dfa M) v", "{"], ["proof (state)\nthis:\n  bdd_all (dfa_is_node M)\n   (fst M !\n    (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     i))\n\ngoal (1 subgoal):\n 1. wf_dfa M v \\<Longrightarrow> wf_dfa (min_dfa M) v", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_dfa M v \\<Longrightarrow> wf_dfa (min_dfa M) v", "assume \"dfa_is_node M q\""], ["proof (state)\nthis:\n  dfa_is_node M q\n\ngoal (1 subgoal):\n 1. wf_dfa M v \\<Longrightarrow> wf_dfa (min_dfa M) v", "hence \"fst ?M ! q < length (snd ?M)\""], ["proof (prove)\nusing this:\n  dfa_is_node M q\n\ngoal (1 subgoal):\n 1. fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    q\n    < length\n       (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M))))", "by (simp add: mk_eqcl_fixpt_fst_bound)"], ["proof (state)\nthis:\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  q\n  < length\n     (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))))\n\ngoal (1 subgoal):\n 1. wf_dfa M v \\<Longrightarrow> wf_dfa (min_dfa M) v", "hence \"dfa_is_node (min_dfa M) (fst ?M ! q)\""], ["proof (prove)\nusing this:\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  q\n  < length\n     (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))))\n\ngoal (1 subgoal):\n 1. dfa_is_node (min_dfa M)\n     (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))) !\n      q)", "by (simp add: dfa_is_node_def min_dfa_def split_beta)"], ["proof (state)\nthis:\n  dfa_is_node (min_dfa M)\n   (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    q)\n\ngoal (1 subgoal):\n 1. wf_dfa M v \\<Longrightarrow> wf_dfa (min_dfa M) v", "}"], ["proof (state)\nthis:\n  dfa_is_node M ?q2 \\<Longrightarrow>\n  dfa_is_node (min_dfa M)\n   (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    ?q2)\n\ngoal (1 subgoal):\n 1. wf_dfa M v \\<Longrightarrow> wf_dfa (min_dfa M) v", "ultimately"], ["proof (chain)\npicking this:\n  bdd_all (dfa_is_node M)\n   (fst M !\n    (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     i))\n  dfa_is_node M ?q2 \\<Longrightarrow>\n  dfa_is_node (min_dfa M)\n   (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    ?q2)", "have \"bdd_all (dfa_is_node (min_dfa M)) (bdd_map (\\<lambda>q. fst ?M ! q) (fst M ! (snd ?M ! i)))\""], ["proof (prove)\nusing this:\n  bdd_all (dfa_is_node M)\n   (fst M !\n    (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     i))\n  dfa_is_node M ?q2 \\<Longrightarrow>\n  dfa_is_node (min_dfa M)\n   (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    ?q2)\n\ngoal (1 subgoal):\n 1. bdd_all (dfa_is_node (min_dfa M))\n     (bdd_map\n       ((!) (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n                   (fixpt M (init_tr M)))))\n       (fst M !\n        (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n               (fixpt M (init_tr M))) !\n         i)))", "by (simp add: bdd_all_bdd_map)"], ["proof (state)\nthis:\n  bdd_all (dfa_is_node (min_dfa M))\n   (bdd_map\n     ((!) (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n                 (fixpt M (init_tr M)))))\n     (fst M !\n      (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n             (fixpt M (init_tr M))) !\n       i)))\n\ngoal (1 subgoal):\n 1. wf_dfa M v \\<Longrightarrow> wf_dfa (min_dfa M) v", "with G1 BI I"], ["proof (chain)\npicking this:\n  bddh v (bd ! i)\n  bd ! i =\n  bdd_map\n   ((!) (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n               (fixpt M (init_tr M)))))\n   (fst M !\n    (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     i))\n  i < length bd\n  x = bd ! i\n  bdd_all (dfa_is_node (min_dfa M))\n   (bdd_map\n     ((!) (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n                 (fixpt M (init_tr M)))))\n     (fst M !\n      (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n             (fixpt M (init_tr M))) !\n       i)))", "have \"bddh v x \\<and> bdd_all (dfa_is_node (min_dfa M)) x\""], ["proof (prove)\nusing this:\n  bddh v (bd ! i)\n  bd ! i =\n  bdd_map\n   ((!) (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n               (fixpt M (init_tr M)))))\n   (fst M !\n    (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     i))\n  i < length bd\n  x = bd ! i\n  bdd_all (dfa_is_node (min_dfa M))\n   (bdd_map\n     ((!) (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n                 (fixpt M (init_tr M)))))\n     (fst M !\n      (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n             (fixpt M (init_tr M))) !\n       i)))\n\ngoal (1 subgoal):\n 1. bddh v x \\<and> bdd_all (dfa_is_node (min_dfa M)) x", "by simp"], ["proof (state)\nthis:\n  bddh v x \\<and> bdd_all (dfa_is_node (min_dfa M)) x\n\ngoal (1 subgoal):\n 1. wf_dfa M v \\<Longrightarrow> wf_dfa (min_dfa M) v", "}"], ["proof (state)\nthis:\n  ?x2 \\<in> set bd \\<Longrightarrow>\n  bddh v ?x2 \\<and> bdd_all (dfa_is_node (min_dfa M)) ?x2\n\ngoal (1 subgoal):\n 1. wf_dfa M v \\<Longrightarrow> wf_dfa (min_dfa M) v", "hence G: \"list_all (bddh v) bd \\<and> list_all (bdd_all (dfa_is_node (min_dfa M))) bd\""], ["proof (prove)\nusing this:\n  ?x2 \\<in> set bd \\<Longrightarrow>\n  bddh v ?x2 \\<and> bdd_all (dfa_is_node (min_dfa M)) ?x2\n\ngoal (1 subgoal):\n 1. list_all (bddh v) bd \\<and>\n    list_all (bdd_all (dfa_is_node (min_dfa M))) bd", "by (simp add: list_all_iff)"], ["proof (state)\nthis:\n  list_all (bddh v) bd \\<and>\n  list_all (bdd_all (dfa_is_node (min_dfa M))) bd\n\ngoal (1 subgoal):\n 1. wf_dfa M v \\<Longrightarrow> wf_dfa (min_dfa M) v", "from H"], ["proof (chain)\npicking this:\n  wf_dfa M v", "have \"length (fst M) > 0\""], ["proof (prove)\nusing this:\n  wf_dfa M v\n\ngoal (1 subgoal):\n 1. 0 < length (fst M)", "by (simp add: wf_dfa_def)"], ["proof (state)\nthis:\n  0 < length (fst M)\n\ngoal (1 subgoal):\n 1. wf_dfa M v \\<Longrightarrow> wf_dfa (min_dfa M) v", "hence \"length (snd ?M) > 0\""], ["proof (prove)\nusing this:\n  0 < length (fst M)\n\ngoal (1 subgoal):\n 1. 0 < length\n         (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n                (fixpt M (init_tr M))))", "by (auto simp only: mk_eqcl_fixpt_startnode)"], ["proof (state)\nthis:\n  0 < length\n       (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M))))\n\ngoal (1 subgoal):\n 1. wf_dfa M v \\<Longrightarrow> wf_dfa (min_dfa M) v", "with G M"], ["proof (chain)\npicking this:\n  list_all (bddh v) bd \\<and>\n  list_all (bdd_all (dfa_is_node (min_dfa M))) bd\n  bd = fst (min_dfa M)\n  as = snd (min_dfa M)\n  0 < length\n       (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M))))", "show \"wf_dfa (min_dfa M) v\""], ["proof (prove)\nusing this:\n  list_all (bddh v) bd \\<and>\n  list_all (bdd_all (dfa_is_node (min_dfa M))) bd\n  bd = fst (min_dfa M)\n  as = snd (min_dfa M)\n  0 < length\n       (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M))))\n\ngoal (1 subgoal):\n 1. wf_dfa (min_dfa M) v", "by (simp add: wf_dfa_def min_dfa_def split_beta)"], ["proof (state)\nthis:\n  wf_dfa (min_dfa M) v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma min_dfa_accept:\n  assumes \"wf_dfa M v\"\n  and \"list_all (is_alph v) w\"\n  shows \"dfa_accepts (min_dfa M) w = dfa_accepts M w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa_accepts (min_dfa M) w = dfa_accepts M w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dfa_accepts (min_dfa M) w = dfa_accepts M w", "let ?M = \"mk_eqcl (replicate (length (fst M)) None) [] 0 (fixpt M (init_tr M))\""], ["proof (state)\ngoal (1 subgoal):\n 1. dfa_accepts (min_dfa M) w = dfa_accepts M w", "from assms"], ["proof (chain)\npicking this:\n  wf_dfa M v\n  list_all (is_alph v) w", "have \"length (fst M) > 0\""], ["proof (prove)\nusing this:\n  wf_dfa M v\n  list_all (is_alph v) w\n\ngoal (1 subgoal):\n 1. 0 < length (fst M)", "by (simp add: wf_dfa_def)"], ["proof (state)\nthis:\n  0 < length (fst M)\n\ngoal (1 subgoal):\n 1. dfa_accepts (min_dfa M) w = dfa_accepts M w", "hence SN: \"length (snd ?M) > 0 \\<and> fst ?M ! 0 = 0 \\<and> snd ?M ! 0 = 0\""], ["proof (prove)\nusing this:\n  0 < length (fst M)\n\ngoal (1 subgoal):\n 1. 0 < length\n         (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n                (fixpt M (init_tr M)))) \\<and>\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    0 =\n    0 \\<and>\n    snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    0 =\n    0", "by (auto simp only: mk_eqcl_fixpt_startnode)"], ["proof (state)\nthis:\n  0 < length\n       (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M)))) \\<and>\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  0 =\n  0 \\<and>\n  snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  0 =\n  0\n\ngoal (1 subgoal):\n 1. dfa_accepts (min_dfa M) w = dfa_accepts M w", "have D: \"dfa_steps (min_dfa M) 0 w = fst ?M ! dfa_steps M 0 w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa_steps (min_dfa M) 0 w =\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    dfa_steps M 0 w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dfa_steps (min_dfa M) 0 w =\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    dfa_steps M 0 w", "from assms"], ["proof (chain)\npicking this:\n  wf_dfa M v\n  list_all (is_alph v) w", "have \"dfa_is_node M 0\""], ["proof (prove)\nusing this:\n  wf_dfa M v\n  list_all (is_alph v) w\n\ngoal (1 subgoal):\n 1. dfa_is_node M 0", "by (simp add: wf_dfa_def dfa_is_node_def)"], ["proof (state)\nthis:\n  dfa_is_node M 0\n\ngoal (1 subgoal):\n 1. dfa_steps (min_dfa M) 0 w =\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    dfa_steps M 0 w", "moreover"], ["proof (state)\nthis:\n  dfa_is_node M 0\n\ngoal (1 subgoal):\n 1. dfa_steps (min_dfa M) 0 w =\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    dfa_steps M 0 w", "from SN"], ["proof (chain)\npicking this:\n  0 < length\n       (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M)))) \\<and>\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  0 =\n  0 \\<and>\n  snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  0 =\n  0", "have \"dfa_steps (min_dfa M) 0 w = dfa_steps (min_dfa M) (fst ?M ! 0) w\""], ["proof (prove)\nusing this:\n  0 < length\n       (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M)))) \\<and>\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  0 =\n  0 \\<and>\n  snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  0 =\n  0\n\ngoal (1 subgoal):\n 1. dfa_steps (min_dfa M) 0 w =\n    dfa_steps (min_dfa M)\n     (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))) !\n      0)\n     w", "by simp"], ["proof (state)\nthis:\n  dfa_steps (min_dfa M) 0 w =\n  dfa_steps (min_dfa M)\n   (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    0)\n   w\n\ngoal (1 subgoal):\n 1. dfa_steps (min_dfa M) 0 w =\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    dfa_steps M 0 w", "moreover"], ["proof (state)\nthis:\n  dfa_steps (min_dfa M) 0 w =\n  dfa_steps (min_dfa M)\n   (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    0)\n   w\n\ngoal (1 subgoal):\n 1. dfa_steps (min_dfa M) 0 w =\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    dfa_steps M 0 w", "note assms"], ["proof (state)\nthis:\n  wf_dfa M v\n  list_all (is_alph v) w\n\ngoal (1 subgoal):\n 1. dfa_steps (min_dfa M) 0 w =\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    dfa_steps M 0 w", "ultimately"], ["proof (chain)\npicking this:\n  dfa_is_node M 0\n  dfa_steps (min_dfa M) 0 w =\n  dfa_steps (min_dfa M)\n   (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    0)\n   w\n  wf_dfa M v\n  list_all (is_alph v) w", "show ?thesis"], ["proof (prove)\nusing this:\n  dfa_is_node M 0\n  dfa_steps (min_dfa M) 0 w =\n  dfa_steps (min_dfa M)\n   (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    0)\n   w\n  wf_dfa M v\n  list_all (is_alph v) w\n\ngoal (1 subgoal):\n 1. dfa_steps (min_dfa M) 0 w =\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    dfa_steps M 0 w", "by (simp add: mk_eqcl_fixpt_steps)"], ["proof (state)\nthis:\n  dfa_steps (min_dfa M) 0 w =\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  dfa_steps M 0 w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dfa_steps (min_dfa M) 0 w =\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  dfa_steps M 0 w\n\ngoal (1 subgoal):\n 1. dfa_accepts (min_dfa M) w = dfa_accepts M w", "from assms"], ["proof (chain)\npicking this:\n  wf_dfa M v\n  list_all (is_alph v) w", "have WF: \"wf_dfa (min_dfa M) v\""], ["proof (prove)\nusing this:\n  wf_dfa M v\n  list_all (is_alph v) w\n\ngoal (1 subgoal):\n 1. wf_dfa (min_dfa M) v", "by (simp add: min_dfa_wf)"], ["proof (state)\nthis:\n  wf_dfa (min_dfa M) v\n\ngoal (1 subgoal):\n 1. dfa_accepts (min_dfa M) w = dfa_accepts M w", "hence \"dfa_is_node (min_dfa M) 0\""], ["proof (prove)\nusing this:\n  wf_dfa (min_dfa M) v\n\ngoal (1 subgoal):\n 1. dfa_is_node (min_dfa M) 0", "by (simp add: dfa_startnode_is_node)"], ["proof (state)\nthis:\n  dfa_is_node (min_dfa M) 0\n\ngoal (1 subgoal):\n 1. dfa_accepts (min_dfa M) w = dfa_accepts M w", "with WF assms"], ["proof (chain)\npicking this:\n  wf_dfa (min_dfa M) v\n  wf_dfa M v\n  list_all (is_alph v) w\n  dfa_is_node (min_dfa M) 0", "have \"dfa_is_node (min_dfa M) (dfa_steps (min_dfa M) 0 w)\""], ["proof (prove)\nusing this:\n  wf_dfa (min_dfa M) v\n  wf_dfa M v\n  list_all (is_alph v) w\n  dfa_is_node (min_dfa M) 0\n\ngoal (1 subgoal):\n 1. dfa_is_node (min_dfa M) (dfa_steps (min_dfa M) 0 w)", "by (simp add: dfa_steps_is_node)"], ["proof (state)\nthis:\n  dfa_is_node (min_dfa M) (dfa_steps (min_dfa M) 0 w)\n\ngoal (1 subgoal):\n 1. dfa_accepts (min_dfa M) w = dfa_accepts M w", "with D"], ["proof (chain)\npicking this:\n  dfa_steps (min_dfa M) 0 w =\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  dfa_steps M 0 w\n  dfa_is_node (min_dfa M) (dfa_steps (min_dfa M) 0 w)", "have DN: \"dfa_is_node (min_dfa M) (fst ?M ! dfa_steps M 0 w)\""], ["proof (prove)\nusing this:\n  dfa_steps (min_dfa M) 0 w =\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  dfa_steps M 0 w\n  dfa_is_node (min_dfa M) (dfa_steps (min_dfa M) 0 w)\n\ngoal (1 subgoal):\n 1. dfa_is_node (min_dfa M)\n     (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))) !\n      dfa_steps M 0 w)", "by simp"], ["proof (state)\nthis:\n  dfa_is_node (min_dfa M)\n   (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    dfa_steps M 0 w)\n\ngoal (1 subgoal):\n 1. dfa_accepts (min_dfa M) w = dfa_accepts M w", "let ?q = \"snd ?M ! (fst ?M ! dfa_steps M 0 w)\""], ["proof (state)\ngoal (1 subgoal):\n 1. dfa_accepts (min_dfa M) w = dfa_accepts M w", "from assms"], ["proof (chain)\npicking this:\n  wf_dfa M v\n  list_all (is_alph v) w", "have N: \"dfa_is_node M (dfa_steps M 0 w)\""], ["proof (prove)\nusing this:\n  wf_dfa M v\n  list_all (is_alph v) w\n\ngoal (1 subgoal):\n 1. dfa_is_node M (dfa_steps M 0 w)", "by (simp add: dfa_steps_is_node dfa_startnode_is_node)"], ["proof (state)\nthis:\n  dfa_is_node M (dfa_steps M 0 w)\n\ngoal (1 subgoal):\n 1. dfa_accepts (min_dfa M) w = dfa_accepts M w", "with assms"], ["proof (chain)\npicking this:\n  wf_dfa M v\n  list_all (is_alph v) w\n  dfa_is_node M (dfa_steps M 0 w)", "have I: \"?q < length (fst ?M)\" \"fst ?M ! ?q = fst ?M ! dfa_steps M 0 w\""], ["proof (prove)\nusing this:\n  wf_dfa M v\n  list_all (is_alph v) w\n  dfa_is_node M (dfa_steps M 0 w)\n\ngoal (1 subgoal):\n 1. snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     dfa_steps M 0 w)\n    < length\n       (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n              (fixpt M (init_tr M)))) &&&\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))) !\n      dfa_steps M 0 w)) =\n    fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    dfa_steps M 0 w", "by (simp add: mk_eqcl_fixpt_fst_bound mk_eqcl_fixpt_fst_snd_nth)+"], ["proof (state)\nthis:\n  snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   dfa_steps M 0 w)\n  < length\n     (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))))\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    dfa_steps M 0 w)) =\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  dfa_steps M 0 w\n\ngoal (1 subgoal):\n 1. dfa_accepts (min_dfa M) w = dfa_accepts M w", "hence \"dfa_is_node M ?q\""], ["proof (prove)\nusing this:\n  snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   dfa_steps M 0 w)\n  < length\n     (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))))\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    dfa_steps M 0 w)) =\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  dfa_steps M 0 w\n\ngoal (1 subgoal):\n 1. dfa_is_node M\n     (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))) !\n      (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n             (fixpt M (init_tr M))) !\n       dfa_steps M 0 w))", "by (simp add: mk_eqcl_len_fst dfa_is_node_def)"], ["proof (state)\nthis:\n  dfa_is_node M\n   (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     dfa_steps M 0 w))\n\ngoal (1 subgoal):\n 1. dfa_accepts (min_dfa M) w = dfa_accepts M w", "with assms N I"], ["proof (chain)\npicking this:\n  wf_dfa M v\n  list_all (is_alph v) w\n  dfa_is_node M (dfa_steps M 0 w)\n  snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   dfa_steps M 0 w)\n  < length\n     (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))))\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    dfa_steps M 0 w)) =\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  dfa_steps M 0 w\n  dfa_is_node M\n   (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     dfa_steps M 0 w))", "have EQ: \"eq_nodes M v (dfa_steps M 0 w) ?q\""], ["proof (prove)\nusing this:\n  wf_dfa M v\n  list_all (is_alph v) w\n  dfa_is_node M (dfa_steps M 0 w)\n  snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   dfa_steps M 0 w)\n  < length\n     (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))))\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    dfa_steps M 0 w)) =\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  dfa_steps M 0 w\n  dfa_is_node M\n   (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     dfa_steps M 0 w))\n\ngoal (1 subgoal):\n 1. eq_nodes M v (dfa_steps M 0 w)\n     (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))) !\n      (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n             (fixpt M (init_tr M))) !\n       dfa_steps M 0 w))", "by (simp add: mk_eqcl_fixpt_fst_nth[symmetric])"], ["proof (state)\nthis:\n  eq_nodes M v (dfa_steps M 0 w)\n   (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     dfa_steps M 0 w))\n\ngoal (1 subgoal):\n 1. dfa_accepts (min_dfa M) w = dfa_accepts M w", "have A: \"dfa_accepting M (dfa_steps M 0 w) = dfa_accepting M ?q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa_accepting M (dfa_steps M 0 w) =\n    dfa_accepting M\n     (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))) !\n      (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n             (fixpt M (init_tr M))) !\n       dfa_steps M 0 w))", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. dfa_accepting M (dfa_steps M 0 w) \\<noteq>\n    dfa_accepting M\n     (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))) !\n      (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n             (fixpt M (init_tr M))) !\n       dfa_steps M 0 w)) \\<Longrightarrow>\n    False", "assume H: \"dfa_accepting M (dfa_steps M 0 w) \\<noteq> dfa_accepting M ?q\""], ["proof (state)\nthis:\n  dfa_accepting M (dfa_steps M 0 w) \\<noteq>\n  dfa_accepting M\n   (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     dfa_steps M 0 w))\n\ngoal (1 subgoal):\n 1. dfa_accepting M (dfa_steps M 0 w) \\<noteq>\n    dfa_accepting M\n     (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))) !\n      (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n             (fixpt M (init_tr M))) !\n       dfa_steps M 0 w)) \\<Longrightarrow>\n    False", "hence \"dist_nodes M 0 v (dfa_steps M 0 w) ?q\""], ["proof (prove)\nusing this:\n  dfa_accepting M (dfa_steps M 0 w) \\<noteq>\n  dfa_accepting M\n   (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     dfa_steps M 0 w))\n\ngoal (1 subgoal):\n 1. dist_nodes M 0 v (dfa_steps M 0 w)\n     (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))) !\n      (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n             (fixpt M (init_tr M))) !\n       dfa_steps M 0 w))", "by (auto simp: dist_nodes_def)"], ["proof (state)\nthis:\n  dist_nodes M 0 v (dfa_steps M 0 w)\n   (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     dfa_steps M 0 w))\n\ngoal (1 subgoal):\n 1. dfa_accepting M (dfa_steps M 0 w) \\<noteq>\n    dfa_accepting M\n     (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))) !\n      (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n             (fixpt M (init_tr M))) !\n       dfa_steps M 0 w)) \\<Longrightarrow>\n    False", "with EQ"], ["proof (chain)\npicking this:\n  eq_nodes M v (dfa_steps M 0 w)\n   (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     dfa_steps M 0 w))\n  dist_nodes M 0 v (dfa_steps M 0 w)\n   (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     dfa_steps M 0 w))", "show False"], ["proof (prove)\nusing this:\n  eq_nodes M v (dfa_steps M 0 w)\n   (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     dfa_steps M 0 w))\n  dist_nodes M 0 v (dfa_steps M 0 w)\n   (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     dfa_steps M 0 w))\n\ngoal (1 subgoal):\n 1. False", "by (simp add: eq_nodes_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dfa_accepting M (dfa_steps M 0 w) =\n  dfa_accepting M\n   (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     dfa_steps M 0 w))\n\ngoal (1 subgoal):\n 1. dfa_accepts (min_dfa M) w = dfa_accepts M w", "from D"], ["proof (chain)\npicking this:\n  dfa_steps (min_dfa M) 0 w =\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  dfa_steps M 0 w", "have \"dfa_accepts (min_dfa M) w = snd (min_dfa M) ! (fst ?M ! dfa_steps M 0 w)\""], ["proof (prove)\nusing this:\n  dfa_steps (min_dfa M) 0 w =\n  fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n        (fixpt M (init_tr M))) !\n  dfa_steps M 0 w\n\ngoal (1 subgoal):\n 1. dfa_accepts (min_dfa M) w =\n    snd (min_dfa M) !\n    (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     dfa_steps M 0 w)", "by (simp add: accepts_def dfa_accepting_def)"], ["proof (state)\nthis:\n  dfa_accepts (min_dfa M) w =\n  snd (min_dfa M) !\n  (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   dfa_steps M 0 w)\n\ngoal (1 subgoal):\n 1. dfa_accepts (min_dfa M) w = dfa_accepts M w", "also"], ["proof (state)\nthis:\n  dfa_accepts (min_dfa M) w =\n  snd (min_dfa M) !\n  (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   dfa_steps M 0 w)\n\ngoal (1 subgoal):\n 1. dfa_accepts (min_dfa M) w = dfa_accepts M w", "from WF DN"], ["proof (chain)\npicking this:\n  wf_dfa (min_dfa M) v\n  dfa_is_node (min_dfa M)\n   (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    dfa_steps M 0 w)", "have \"\\<dots> = dfa_accepting M ?q\""], ["proof (prove)\nusing this:\n  wf_dfa (min_dfa M) v\n  dfa_is_node (min_dfa M)\n   (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    dfa_steps M 0 w)\n\ngoal (1 subgoal):\n 1. snd (min_dfa M) !\n    (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     dfa_steps M 0 w) =\n    dfa_accepting M\n     (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))) !\n      (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n             (fixpt M (init_tr M))) !\n       dfa_steps M 0 w))", "by (simp add: dfa_is_node_def wf_dfa_def min_dfa_def split_beta dfa_accepting_def)"], ["proof (state)\nthis:\n  snd (min_dfa M) !\n  (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   dfa_steps M 0 w) =\n  dfa_accepting M\n   (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     dfa_steps M 0 w))\n\ngoal (1 subgoal):\n 1. dfa_accepts (min_dfa M) w = dfa_accepts M w", "also"], ["proof (state)\nthis:\n  snd (min_dfa M) !\n  (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n         (fixpt M (init_tr M))) !\n   dfa_steps M 0 w) =\n  dfa_accepting M\n   (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     dfa_steps M 0 w))\n\ngoal (1 subgoal):\n 1. dfa_accepts (min_dfa M) w = dfa_accepts M w", "from A"], ["proof (chain)\npicking this:\n  dfa_accepting M (dfa_steps M 0 w) =\n  dfa_accepting M\n   (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     dfa_steps M 0 w))", "have \"\\<dots> = dfa_accepts M w\""], ["proof (prove)\nusing this:\n  dfa_accepting M (dfa_steps M 0 w) =\n  dfa_accepting M\n   (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     dfa_steps M 0 w))\n\ngoal (1 subgoal):\n 1. dfa_accepting M\n     (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n            (fixpt M (init_tr M))) !\n      (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n             (fixpt M (init_tr M))) !\n       dfa_steps M 0 w)) =\n    dfa_accepts M w", "by (simp add: accepts_def)"], ["proof (state)\nthis:\n  dfa_accepting M\n   (snd (mk_eqcl (replicate (length (fst M)) None) [] 0\n          (fixpt M (init_tr M))) !\n    (fst (mk_eqcl (replicate (length (fst M)) None) [] 0\n           (fixpt M (init_tr M))) !\n     dfa_steps M 0 w)) =\n  dfa_accepts M w\n\ngoal (1 subgoal):\n 1. dfa_accepts (min_dfa M) w = dfa_accepts M w", "finally"], ["proof (chain)\npicking this:\n  dfa_accepts (min_dfa M) w = dfa_accepts M w", "show ?thesis"], ["proof (prove)\nusing this:\n  dfa_accepts (min_dfa M) w = dfa_accepts M w\n\ngoal (1 subgoal):\n 1. dfa_accepts (min_dfa M) w = dfa_accepts M w", "by simp"], ["proof (state)\nthis:\n  dfa_accepts (min_dfa M) w = dfa_accepts M w\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>NFAs\\<close>"], ["", "type_synonym nbddtable = \"bool list bdd list\""], ["", "type_synonym nfa = \"nbddtable \\<times> astate\""], ["", "definition\n  nfa_is_node :: \"nfa \\<Rightarrow> bool list \\<Rightarrow> bool\" where\n  \"nfa_is_node A = (\\<lambda>qs. length qs = length (fst A))\""], ["", "definition\n  wf_nfa :: \"nfa \\<Rightarrow> nat \\<Rightarrow> bool\" where\n  \"wf_nfa A n =\n    (list_all (bddh n) (fst A) \\<and>\n     list_all (bdd_all (nfa_is_node A)) (fst A) \\<and>\n     length (snd A) = length (fst A) \\<and>\n     length (fst A) > 0)\""], ["", "definition\n  set_of_bv :: \"bool list \\<Rightarrow> nat set\" where\n  \"set_of_bv bs = {i. i < length bs \\<and> bs ! i}\""], ["", "fun\n  bv_or :: \"bool list \\<Rightarrow> bool list \\<Rightarrow> bool list\"\nwhere\n  \"bv_or [] [] = []\" |\n  \"bv_or (x # xs) (y # ys) = (x \\<or> y) # (bv_or xs ys)\""], ["", "lemma bv_or_nth:\n  assumes \"length l = length r\"\n  assumes \"i < length l\"\n  shows \"bv_or l r ! i = (l ! i \\<or> r ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_or l r ! i = (l ! i \\<or> r ! i)", "using assms"], ["proof (prove)\nusing this:\n  length l = length r\n  i < length l\n\ngoal (1 subgoal):\n 1. bv_or l r ! i = (l ! i \\<or> r ! i)", "proof (induct l r arbitrary: i rule: bv_or.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>length [] = length []; i < length []\\<rbrakk>\n       \\<Longrightarrow> bv_or [] [] ! i = ([] ! i \\<or> [] ! i)\n 2. \\<And>x xs y ys i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>length xs = length ys; i < length xs\\<rbrakk>\n                   \\<Longrightarrow> bv_or xs ys ! i =\n                                     (xs ! i \\<or> ys ! i);\n        length (x # xs) = length (y # ys); i < length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> bv_or (x # xs) (y # ys) ! i =\n                         ((x # xs) ! i \\<or> (y # ys) ! i)\n 3. \\<And>v va i.\n       \\<lbrakk>length (v # va) = length []; i < length (v # va)\\<rbrakk>\n       \\<Longrightarrow> bv_or (v # va) [] ! i = ((v # va) ! i \\<or> [] ! i)\n 4. \\<And>v va i.\n       \\<lbrakk>length [] = length (v # va); i < length []\\<rbrakk>\n       \\<Longrightarrow> bv_or [] (v # va) ! i = ([] ! i \\<or> (v # va) ! i)", "case (2 xx xss yy yss ii)"], ["proof (state)\nthis:\n  \\<lbrakk>length xss = length yss; ?i < length xss\\<rbrakk>\n  \\<Longrightarrow> bv_or xss yss ! ?i = (xss ! ?i \\<or> yss ! ?i)\n  length (xx # xss) = length (yy # yss)\n  ii < length (xx # xss)\n\ngoal (4 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>length [] = length []; i < length []\\<rbrakk>\n       \\<Longrightarrow> bv_or [] [] ! i = ([] ! i \\<or> [] ! i)\n 2. \\<And>x xs y ys i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>length xs = length ys; i < length xs\\<rbrakk>\n                   \\<Longrightarrow> bv_or xs ys ! i =\n                                     (xs ! i \\<or> ys ! i);\n        length (x # xs) = length (y # ys); i < length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> bv_or (x # xs) (y # ys) ! i =\n                         ((x # xs) ! i \\<or> (y # ys) ! i)\n 3. \\<And>v va i.\n       \\<lbrakk>length (v # va) = length []; i < length (v # va)\\<rbrakk>\n       \\<Longrightarrow> bv_or (v # va) [] ! i = ((v # va) ! i \\<or> [] ! i)\n 4. \\<And>v va i.\n       \\<lbrakk>length [] = length (v # va); i < length []\\<rbrakk>\n       \\<Longrightarrow> bv_or [] (v # va) ! i = ([] ! i \\<or> (v # va) ! i)", "have \"ii = 0 \\<or> ii > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ii = 0 \\<or> 0 < ii", "by auto"], ["proof (state)\nthis:\n  ii = 0 \\<or> 0 < ii\n\ngoal (4 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>length [] = length []; i < length []\\<rbrakk>\n       \\<Longrightarrow> bv_or [] [] ! i = ([] ! i \\<or> [] ! i)\n 2. \\<And>x xs y ys i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>length xs = length ys; i < length xs\\<rbrakk>\n                   \\<Longrightarrow> bv_or xs ys ! i =\n                                     (xs ! i \\<or> ys ! i);\n        length (x # xs) = length (y # ys); i < length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> bv_or (x # xs) (y # ys) ! i =\n                         ((x # xs) ! i \\<or> (y # ys) ! i)\n 3. \\<And>v va i.\n       \\<lbrakk>length (v # va) = length []; i < length (v # va)\\<rbrakk>\n       \\<Longrightarrow> bv_or (v # va) [] ! i = ((v # va) ! i \\<or> [] ! i)\n 4. \\<And>v va i.\n       \\<lbrakk>length [] = length (v # va); i < length []\\<rbrakk>\n       \\<Longrightarrow> bv_or [] (v # va) ! i = ([] ! i \\<or> (v # va) ! i)", "thus ?case"], ["proof (prove)\nusing this:\n  ii = 0 \\<or> 0 < ii\n\ngoal (1 subgoal):\n 1. bv_or (xx # xss) (yy # yss) ! ii =\n    ((xx # xss) ! ii \\<or> (yy # yss) ! ii)", "proof (elim disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. ii = 0 \\<Longrightarrow>\n    bv_or (xx # xss) (yy # yss) ! ii =\n    ((xx # xss) ! ii \\<or> (yy # yss) ! ii)\n 2. 0 < ii \\<Longrightarrow>\n    bv_or (xx # xss) (yy # yss) ! ii =\n    ((xx # xss) ! ii \\<or> (yy # yss) ! ii)", "assume \"ii > 0\""], ["proof (state)\nthis:\n  0 < ii\n\ngoal (2 subgoals):\n 1. ii = 0 \\<Longrightarrow>\n    bv_or (xx # xss) (yy # yss) ! ii =\n    ((xx # xss) ! ii \\<or> (yy # yss) ! ii)\n 2. 0 < ii \\<Longrightarrow>\n    bv_or (xx # xss) (yy # yss) ! ii =\n    ((xx # xss) ! ii \\<or> (yy # yss) ! ii)", "then"], ["proof (chain)\npicking this:\n  0 < ii", "obtain j where J: \"ii = Suc j\""], ["proof (prove)\nusing this:\n  0 < ii\n\ngoal (1 subgoal):\n 1. (\\<And>j. ii = Suc j \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (induct ii) simp+"], ["proof (state)\nthis:\n  ii = Suc j\n\ngoal (2 subgoals):\n 1. ii = 0 \\<Longrightarrow>\n    bv_or (xx # xss) (yy # yss) ! ii =\n    ((xx # xss) ! ii \\<or> (yy # yss) ! ii)\n 2. 0 < ii \\<Longrightarrow>\n    bv_or (xx # xss) (yy # yss) ! ii =\n    ((xx # xss) ! ii \\<or> (yy # yss) ! ii)", "with 2"], ["proof (chain)\npicking this:\n  \\<lbrakk>length xss = length yss; ?i < length xss\\<rbrakk>\n  \\<Longrightarrow> bv_or xss yss ! ?i = (xss ! ?i \\<or> yss ! ?i)\n  length (xx # xss) = length (yy # yss)\n  ii < length (xx # xss)\n  ii = Suc j", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>length xss = length yss; ?i < length xss\\<rbrakk>\n  \\<Longrightarrow> bv_or xss yss ! ?i = (xss ! ?i \\<or> yss ! ?i)\n  length (xx # xss) = length (yy # yss)\n  ii < length (xx # xss)\n  ii = Suc j\n\ngoal (1 subgoal):\n 1. bv_or (xx # xss) (yy # yss) ! ii =\n    ((xx # xss) ! ii \\<or> (yy # yss) ! ii)", "by simp"], ["proof (state)\nthis:\n  bv_or (xx # xss) (yy # yss) ! ii = ((xx # xss) ! ii \\<or> (yy # yss) ! ii)\n\ngoal (1 subgoal):\n 1. ii = 0 \\<Longrightarrow>\n    bv_or (xx # xss) (yy # yss) ! ii =\n    ((xx # xss) ! ii \\<or> (yy # yss) ! ii)", "qed simp"], ["proof (state)\nthis:\n  bv_or (xx # xss) (yy # yss) ! ii = ((xx # xss) ! ii \\<or> (yy # yss) ! ii)\n\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>length [] = length []; i < length []\\<rbrakk>\n       \\<Longrightarrow> bv_or [] [] ! i = ([] ! i \\<or> [] ! i)\n 2. \\<And>v va i.\n       \\<lbrakk>length (v # va) = length []; i < length (v # va)\\<rbrakk>\n       \\<Longrightarrow> bv_or (v # va) [] ! i = ((v # va) ! i \\<or> [] ! i)\n 3. \\<And>v va i.\n       \\<lbrakk>length [] = length (v # va); i < length []\\<rbrakk>\n       \\<Longrightarrow> bv_or [] (v # va) ! i = ([] ! i \\<or> (v # va) ! i)", "qed simp+"], ["", "lemma bv_or_length:\n  assumes \"length l = length r\"\n  shows \"length (bv_or l r) = length l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (bv_or l r) = length l", "using assms"], ["proof (prove)\nusing this:\n  length l = length r\n\ngoal (1 subgoal):\n 1. length (bv_or l r) = length l", "by (induct l r rule: bv_or.induct) simp+"], ["", "lemma bv_or_set_of_bv:\n  assumes \"nfa_is_node A p\" and \"nfa_is_node A q\"\n  shows \"set_of_bv (bv_or p q) = set_of_bv p \\<union> set_of_bv q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_of_bv (bv_or p q) = set_of_bv p \\<union> set_of_bv q", "using assms"], ["proof (prove)\nusing this:\n  nfa_is_node A p\n  nfa_is_node A q\n\ngoal (1 subgoal):\n 1. set_of_bv (bv_or p q) = set_of_bv p \\<union> set_of_bv q", "by (auto simp: nfa_is_node_def set_of_bv_def bv_or_length bv_or_nth)"], ["", "lemma bv_or_is_node: \"\\<lbrakk>nfa_is_node A p; nfa_is_node A q\\<rbrakk> \\<Longrightarrow> nfa_is_node A (bv_or p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nfa_is_node A p; nfa_is_node A q\\<rbrakk>\n    \\<Longrightarrow> nfa_is_node A (bv_or p q)", "by (simp add: bv_or_length nfa_is_node_def)"], ["", "fun subsetbdd\nwhere\n  \"subsetbdd [] [] bdd = bdd\"\n| \"subsetbdd (bdd' # bdds) (b # bs) bdd =\n     (if b then subsetbdd bdds bs (bdd_binop bv_or bdd bdd') else subsetbdd bdds bs bdd)\""], ["", "definition\n  nfa_emptybdd :: \"nat \\<Rightarrow> bool list bdd\" where\n  \"nfa_emptybdd n = Leaf (replicate n False)\""], ["", "lemma bdd_all_is_node_subsetbdd:\n  assumes \"list_all (bdd_all (nfa_is_node A)) (fst A)\"\n  and \"nfa_is_node A q\"\n  shows \"bdd_all (nfa_is_node A) (subsetbdd (fst A) q (nfa_emptybdd (length q)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_all (nfa_is_node A) (subsetbdd (fst A) q (nfa_emptybdd (length q)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bdd_all (nfa_is_node A) (subsetbdd (fst A) q (nfa_emptybdd (length q)))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. bdd_all (nfa_is_node A) (subsetbdd (fst A) q (nfa_emptybdd (length q)))", "fix bdds :: \"bool list bdd list\" and q :: \"bool list\" and bd :: \"bool list bdd\" and n"], ["proof (state)\ngoal (1 subgoal):\n 1. bdd_all (nfa_is_node A) (subsetbdd (fst A) q (nfa_emptybdd (length q)))", "assume \"list_all (bdd_all (\\<lambda>l. length l = n)) bdds\" and \"bdd_all (\\<lambda>l. length l = n) bd\" and \"length bdds = length q\""], ["proof (state)\nthis:\n  list_all (bdd_all (\\<lambda>l. length l = n)) bdds\n  bdd_all (\\<lambda>l. length l = n) bd\n  length bdds = length q\n\ngoal (1 subgoal):\n 1. bdd_all (nfa_is_node A) (subsetbdd (fst A) q (nfa_emptybdd (length q)))", "hence \"bdd_all (\\<lambda>l. length l = n) (subsetbdd bdds q bd)\""], ["proof (prove)\nusing this:\n  list_all (bdd_all (\\<lambda>l. length l = n)) bdds\n  bdd_all (\\<lambda>l. length l = n) bd\n  length bdds = length q\n\ngoal (1 subgoal):\n 1. bdd_all (\\<lambda>l. length l = n) (subsetbdd bdds q bd)", "by (induct bdds q bd rule: subsetbdd.induct) (simp add: bdd_all_bdd_binop[of \"\\<lambda>l. length l =n\" _ \"\\<lambda>l. length l = n\"] bv_or_length)+"], ["proof (state)\nthis:\n  bdd_all (\\<lambda>l. length l = n) (subsetbdd bdds q bd)\n\ngoal (1 subgoal):\n 1. bdd_all (nfa_is_node A) (subsetbdd (fst A) q (nfa_emptybdd (length q)))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>list_all (bdd_all (\\<lambda>l. length l = ?n2)) ?bdds2;\n   bdd_all (\\<lambda>l. length l = ?n2) ?bd2;\n   length ?bdds2 = length ?qa2\\<rbrakk>\n  \\<Longrightarrow> bdd_all (\\<lambda>l. length l = ?n2)\n                     (subsetbdd ?bdds2 ?qa2 ?bd2)\n\ngoal (1 subgoal):\n 1. bdd_all (nfa_is_node A) (subsetbdd (fst A) q (nfa_emptybdd (length q)))", "with assms"], ["proof (chain)\npicking this:\n  list_all (bdd_all (nfa_is_node A)) (fst A)\n  nfa_is_node A q\n  \\<lbrakk>list_all (bdd_all (\\<lambda>l. length l = ?n2)) ?bdds2;\n   bdd_all (\\<lambda>l. length l = ?n2) ?bd2;\n   length ?bdds2 = length ?qa2\\<rbrakk>\n  \\<Longrightarrow> bdd_all (\\<lambda>l. length l = ?n2)\n                     (subsetbdd ?bdds2 ?qa2 ?bd2)", "show ?thesis"], ["proof (prove)\nusing this:\n  list_all (bdd_all (nfa_is_node A)) (fst A)\n  nfa_is_node A q\n  \\<lbrakk>list_all (bdd_all (\\<lambda>l. length l = ?n2)) ?bdds2;\n   bdd_all (\\<lambda>l. length l = ?n2) ?bd2;\n   length ?bdds2 = length ?qa2\\<rbrakk>\n  \\<Longrightarrow> bdd_all (\\<lambda>l. length l = ?n2)\n                     (subsetbdd ?bdds2 ?qa2 ?bd2)\n\ngoal (1 subgoal):\n 1. bdd_all (nfa_is_node A) (subsetbdd (fst A) q (nfa_emptybdd (length q)))", "by (simp add: nfa_is_node_def nfa_emptybdd_def)"], ["proof (state)\nthis:\n  bdd_all (nfa_is_node A) (subsetbdd (fst A) q (nfa_emptybdd (length q)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bddh_subsetbdd:\n  assumes \"list_all (bddh l) (fst A)\"\n  and \"bddh l bdd'\"\n  and \"nfa_is_node A q\"\n  shows \"bddh l (subsetbdd (fst A) q bdd')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bddh l (subsetbdd (fst A) q bdd')", "using assms"], ["proof (prove)\nusing this:\n  list_all (bddh l) (fst A)\n  bddh l bdd'\n  nfa_is_node A q\n\ngoal (1 subgoal):\n 1. bddh l (subsetbdd (fst A) q bdd')", "unfolding nfa_is_node_def"], ["proof (prove)\nusing this:\n  list_all (bddh l) (fst A)\n  bddh l bdd'\n  length q = length (fst A)\n\ngoal (1 subgoal):\n 1. bddh l (subsetbdd (fst A) q bdd')", "by (induct (\"fst A\") q bdd' rule: subsetbdd.induct) (simp add: bddh_binop)+"], ["", "lemma bdd_lookup_subsetbdd':\n  assumes \"length bdds = length q\"\n  and \"\\<forall>x \\<in> set bdds. bddh (length ws) x\"\n  and \"bddh (length ws) obdd\"\n  and \"\\<And>bs w. \\<lbrakk>bs \\<in> set bdds; length w = length ws\\<rbrakk> \\<Longrightarrow> length (bdd_lookup bs w) = c\"\n  and \"\\<And>w. length w = length ws \\<Longrightarrow> length (bdd_lookup obdd w) = c\"\n  and \"a < c\"\n  shows \"bdd_lookup (subsetbdd bdds q obdd) ws ! a = ((\\<exists>i < length q. q ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or> bdd_lookup obdd ws ! a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_lookup (subsetbdd bdds q obdd) ws ! a =\n    ((\\<exists>i<length q. q ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n     bdd_lookup obdd ws ! a)", "using assms"], ["proof (prove)\nusing this:\n  length bdds = length q\n  \\<forall>x\\<in>set bdds. bddh (length ws) x\n  bddh (length ws) obdd\n  \\<lbrakk>?bs \\<in> set bdds; length ?w = length ws\\<rbrakk>\n  \\<Longrightarrow> length (bdd_lookup ?bs ?w) = c\n  length ?w = length ws \\<Longrightarrow> length (bdd_lookup obdd ?w) = c\n  a < c\n\ngoal (1 subgoal):\n 1. bdd_lookup (subsetbdd bdds q obdd) ws ! a =\n    ((\\<exists>i<length q. q ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n     bdd_lookup obdd ws ! a)", "proof (induct bdds q obdd rule: subsetbdd.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>bdd.\n       \\<lbrakk>length [] = length []; Ball (set []) (bddh (length ws));\n        bddh (length ws) bdd;\n        \\<And>bs w.\n           \\<lbrakk>bs \\<in> set []; length w = length ws\\<rbrakk>\n           \\<Longrightarrow> length (bdd_lookup bs w) = c;\n        \\<And>w.\n           length w = length ws \\<Longrightarrow>\n           length (bdd_lookup bdd w) = c;\n        a < c\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (subsetbdd [] [] bdd) ws ! a =\n                         ((\\<exists>i<length [].\n                              [] ! i \\<and>\n                              bdd_lookup ([] ! i) ws ! a) \\<or>\n                          bdd_lookup bdd ws ! a)\n 2. \\<And>bdd' bdds b bs bdd.\n       \\<lbrakk>\\<lbrakk>b; length bdds = length bs;\n                 Ball (set bdds) (bddh (length ws));\n                 bddh (length ws) (bdd_binop bv_or bdd bdd');\n                 \\<And>bs w.\n                    \\<lbrakk>bs \\<in> set bdds;\n                     length w = length ws\\<rbrakk>\n                    \\<Longrightarrow> length (bdd_lookup bs w) = c;\n                 \\<And>w.\n                    length w = length ws \\<Longrightarrow>\n                    length (bdd_lookup (bdd_binop bv_or bdd bdd') w) = c;\n                 a < c\\<rbrakk>\n                \\<Longrightarrow> bdd_lookup\n                                   (subsetbdd bdds bs\n                                     (bdd_binop bv_or bdd bdd'))\n                                   ws !\n                                  a =\n                                  ((\\<exists>i<length bs.\n bs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n                                   bdd_lookup (bdd_binop bv_or bdd bdd')\n                                    ws !\n                                   a);\n        \\<lbrakk>\\<not> b; length bdds = length bs;\n         Ball (set bdds) (bddh (length ws)); bddh (length ws) bdd;\n         \\<And>bs w.\n            \\<lbrakk>bs \\<in> set bdds; length w = length ws\\<rbrakk>\n            \\<Longrightarrow> length (bdd_lookup bs w) = c;\n         \\<And>w.\n            length w = length ws \\<Longrightarrow>\n            length (bdd_lookup bdd w) = c;\n         a < c\\<rbrakk>\n        \\<Longrightarrow> bdd_lookup (subsetbdd bdds bs bdd) ws ! a =\n                          ((\\<exists>i<length bs.\n                               bs ! i \\<and>\n                               bdd_lookup (bdds ! i) ws ! a) \\<or>\n                           bdd_lookup bdd ws ! a);\n        length (bdd' # bdds) = length (b # bs);\n        Ball (set (bdd' # bdds)) (bddh (length ws)); bddh (length ws) bdd;\n        \\<And>bs w.\n           \\<lbrakk>bs \\<in> set (bdd' # bdds);\n            length w = length ws\\<rbrakk>\n           \\<Longrightarrow> length (bdd_lookup bs w) = c;\n        \\<And>w.\n           length w = length ws \\<Longrightarrow>\n           length (bdd_lookup bdd w) = c;\n        a < c\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (subsetbdd (bdd' # bdds) (b # bs) bdd)\n                          ws !\n                         a =\n                         ((\\<exists>i<length (b # bs).\n                              (b # bs) ! i \\<and>\n                              bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n                          bdd_lookup bdd ws ! a)\n 3. \\<And>v va ca.\n       \\<lbrakk>length (v # va) = length [];\n        Ball (set (v # va)) (bddh (length ws)); bddh (length ws) ca;\n        \\<And>bs w.\n           \\<lbrakk>bs \\<in> set (v # va); length w = length ws\\<rbrakk>\n           \\<Longrightarrow> length (bdd_lookup bs w) = c;\n        \\<And>w.\n           length w = length ws \\<Longrightarrow>\n           length (bdd_lookup ca w) = c;\n        a < c\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (subsetbdd (v # va) [] ca) ws ! a =\n                         ((\\<exists>i<length [].\n                              [] ! i \\<and>\n                              bdd_lookup ((v # va) ! i) ws ! a) \\<or>\n                          bdd_lookup ca ws ! a)\n 4. \\<And>v va ca.\n       \\<lbrakk>length [] = length (v # va);\n        Ball (set []) (bddh (length ws)); bddh (length ws) ca;\n        \\<And>bs w.\n           \\<lbrakk>bs \\<in> set []; length w = length ws\\<rbrakk>\n           \\<Longrightarrow> length (bdd_lookup bs w) = c;\n        \\<And>w.\n           length w = length ws \\<Longrightarrow>\n           length (bdd_lookup ca w) = c;\n        a < c\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (subsetbdd [] (v # va) ca) ws ! a =\n                         ((\\<exists>i<length (v # va).\n                              (v # va) ! i \\<and>\n                              bdd_lookup ([] ! i) ws ! a) \\<or>\n                          bdd_lookup ca ws ! a)", "case (2 bdd' bdds x xs bdd)"], ["proof (state)\nthis:\n  \\<lbrakk>x; length bdds = length xs;\n   \\<forall>a\\<in>set bdds. bddh (length ws) a;\n   bddh (length ws) (bdd_binop bv_or bdd bdd');\n   \\<And>bs w.\n      \\<lbrakk>bs \\<in> set bdds; length w = length ws\\<rbrakk>\n      \\<Longrightarrow> length (bdd_lookup bs w) = c;\n   \\<And>w.\n      length w = length ws \\<Longrightarrow>\n      length (bdd_lookup (bdd_binop bv_or bdd bdd') w) = c;\n   a < c\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup\n                     (subsetbdd bdds xs (bdd_binop bv_or bdd bdd')) ws !\n                    a =\n                    ((\\<exists>i<length xs.\n                         xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n                     bdd_lookup (bdd_binop bv_or bdd bdd') ws ! a)\n  \\<lbrakk>\\<not> x; length bdds = length xs;\n   \\<forall>a\\<in>set bdds. bddh (length ws) a; bddh (length ws) bdd;\n   \\<And>bs w.\n      \\<lbrakk>bs \\<in> set bdds; length w = length ws\\<rbrakk>\n      \\<Longrightarrow> length (bdd_lookup bs w) = c;\n   \\<And>w.\n      length w = length ws \\<Longrightarrow> length (bdd_lookup bdd w) = c;\n   a < c\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (subsetbdd bdds xs bdd) ws ! a =\n                    ((\\<exists>i<length xs.\n                         xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n                     bdd_lookup bdd ws ! a)\n  length (bdd' # bdds) = length (x # xs)\n  \\<forall>a\\<in>set (bdd' # bdds). bddh (length ws) a\n  bddh (length ws) bdd\n  \\<lbrakk>?bs \\<in> set (bdd' # bdds); length ?w = length ws\\<rbrakk>\n  \\<Longrightarrow> length (bdd_lookup ?bs ?w) = c\n  length ?w = length ws \\<Longrightarrow> length (bdd_lookup bdd ?w) = c\n  a < c\n\ngoal (4 subgoals):\n 1. \\<And>bdd.\n       \\<lbrakk>length [] = length []; Ball (set []) (bddh (length ws));\n        bddh (length ws) bdd;\n        \\<And>bs w.\n           \\<lbrakk>bs \\<in> set []; length w = length ws\\<rbrakk>\n           \\<Longrightarrow> length (bdd_lookup bs w) = c;\n        \\<And>w.\n           length w = length ws \\<Longrightarrow>\n           length (bdd_lookup bdd w) = c;\n        a < c\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (subsetbdd [] [] bdd) ws ! a =\n                         ((\\<exists>i<length [].\n                              [] ! i \\<and>\n                              bdd_lookup ([] ! i) ws ! a) \\<or>\n                          bdd_lookup bdd ws ! a)\n 2. \\<And>bdd' bdds b bs bdd.\n       \\<lbrakk>\\<lbrakk>b; length bdds = length bs;\n                 Ball (set bdds) (bddh (length ws));\n                 bddh (length ws) (bdd_binop bv_or bdd bdd');\n                 \\<And>bs w.\n                    \\<lbrakk>bs \\<in> set bdds;\n                     length w = length ws\\<rbrakk>\n                    \\<Longrightarrow> length (bdd_lookup bs w) = c;\n                 \\<And>w.\n                    length w = length ws \\<Longrightarrow>\n                    length (bdd_lookup (bdd_binop bv_or bdd bdd') w) = c;\n                 a < c\\<rbrakk>\n                \\<Longrightarrow> bdd_lookup\n                                   (subsetbdd bdds bs\n                                     (bdd_binop bv_or bdd bdd'))\n                                   ws !\n                                  a =\n                                  ((\\<exists>i<length bs.\n bs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n                                   bdd_lookup (bdd_binop bv_or bdd bdd')\n                                    ws !\n                                   a);\n        \\<lbrakk>\\<not> b; length bdds = length bs;\n         Ball (set bdds) (bddh (length ws)); bddh (length ws) bdd;\n         \\<And>bs w.\n            \\<lbrakk>bs \\<in> set bdds; length w = length ws\\<rbrakk>\n            \\<Longrightarrow> length (bdd_lookup bs w) = c;\n         \\<And>w.\n            length w = length ws \\<Longrightarrow>\n            length (bdd_lookup bdd w) = c;\n         a < c\\<rbrakk>\n        \\<Longrightarrow> bdd_lookup (subsetbdd bdds bs bdd) ws ! a =\n                          ((\\<exists>i<length bs.\n                               bs ! i \\<and>\n                               bdd_lookup (bdds ! i) ws ! a) \\<or>\n                           bdd_lookup bdd ws ! a);\n        length (bdd' # bdds) = length (b # bs);\n        Ball (set (bdd' # bdds)) (bddh (length ws)); bddh (length ws) bdd;\n        \\<And>bs w.\n           \\<lbrakk>bs \\<in> set (bdd' # bdds);\n            length w = length ws\\<rbrakk>\n           \\<Longrightarrow> length (bdd_lookup bs w) = c;\n        \\<And>w.\n           length w = length ws \\<Longrightarrow>\n           length (bdd_lookup bdd w) = c;\n        a < c\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (subsetbdd (bdd' # bdds) (b # bs) bdd)\n                          ws !\n                         a =\n                         ((\\<exists>i<length (b # bs).\n                              (b # bs) ! i \\<and>\n                              bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n                          bdd_lookup bdd ws ! a)\n 3. \\<And>v va ca.\n       \\<lbrakk>length (v # va) = length [];\n        Ball (set (v # va)) (bddh (length ws)); bddh (length ws) ca;\n        \\<And>bs w.\n           \\<lbrakk>bs \\<in> set (v # va); length w = length ws\\<rbrakk>\n           \\<Longrightarrow> length (bdd_lookup bs w) = c;\n        \\<And>w.\n           length w = length ws \\<Longrightarrow>\n           length (bdd_lookup ca w) = c;\n        a < c\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (subsetbdd (v # va) [] ca) ws ! a =\n                         ((\\<exists>i<length [].\n                              [] ! i \\<and>\n                              bdd_lookup ((v # va) ! i) ws ! a) \\<or>\n                          bdd_lookup ca ws ! a)\n 4. \\<And>v va ca.\n       \\<lbrakk>length [] = length (v # va);\n        Ball (set []) (bddh (length ws)); bddh (length ws) ca;\n        \\<And>bs w.\n           \\<lbrakk>bs \\<in> set []; length w = length ws\\<rbrakk>\n           \\<Longrightarrow> length (bdd_lookup bs w) = c;\n        \\<And>w.\n           length w = length ws \\<Longrightarrow>\n           length (bdd_lookup ca w) = c;\n        a < c\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (subsetbdd [] (v # va) ca) ws ! a =\n                         ((\\<exists>i<length (v # va).\n                              (v # va) ! i \\<and>\n                              bdd_lookup ([] ! i) ws ! a) \\<or>\n                          bdd_lookup ca ws ! a)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_lookup (subsetbdd (bdd' # bdds) (x # xs) bdd) ws ! a =\n    ((\\<exists>i<length (x # xs).\n         (x # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n     bdd_lookup bdd ws ! a)", "proof (cases x)"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<Longrightarrow>\n    bdd_lookup (subsetbdd (bdd' # bdds) (x # xs) bdd) ws ! a =\n    ((\\<exists>i<length (x # xs).\n         (x # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n     bdd_lookup bdd ws ! a)\n 2. \\<not> x \\<Longrightarrow>\n    bdd_lookup (subsetbdd (bdd' # bdds) (x # xs) bdd) ws ! a =\n    ((\\<exists>i<length (x # xs).\n         (x # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n     bdd_lookup bdd ws ! a)", "case True"], ["proof (state)\nthis:\n  x\n\ngoal (2 subgoals):\n 1. x \\<Longrightarrow>\n    bdd_lookup (subsetbdd (bdd' # bdds) (x # xs) bdd) ws ! a =\n    ((\\<exists>i<length (x # xs).\n         (x # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n     bdd_lookup bdd ws ! a)\n 2. \\<not> x \\<Longrightarrow>\n    bdd_lookup (subsetbdd (bdd' # bdds) (x # xs) bdd) ws ! a =\n    ((\\<exists>i<length (x # xs).\n         (x # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n     bdd_lookup bdd ws ! a)", "with 2"], ["proof (chain)\npicking this:\n  \\<lbrakk>x; length bdds = length xs;\n   \\<forall>a\\<in>set bdds. bddh (length ws) a;\n   bddh (length ws) (bdd_binop bv_or bdd bdd');\n   \\<And>bs w.\n      \\<lbrakk>bs \\<in> set bdds; length w = length ws\\<rbrakk>\n      \\<Longrightarrow> length (bdd_lookup bs w) = c;\n   \\<And>w.\n      length w = length ws \\<Longrightarrow>\n      length (bdd_lookup (bdd_binop bv_or bdd bdd') w) = c;\n   a < c\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup\n                     (subsetbdd bdds xs (bdd_binop bv_or bdd bdd')) ws !\n                    a =\n                    ((\\<exists>i<length xs.\n                         xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n                     bdd_lookup (bdd_binop bv_or bdd bdd') ws ! a)\n  \\<lbrakk>\\<not> x; length bdds = length xs;\n   \\<forall>a\\<in>set bdds. bddh (length ws) a; bddh (length ws) bdd;\n   \\<And>bs w.\n      \\<lbrakk>bs \\<in> set bdds; length w = length ws\\<rbrakk>\n      \\<Longrightarrow> length (bdd_lookup bs w) = c;\n   \\<And>w.\n      length w = length ws \\<Longrightarrow> length (bdd_lookup bdd w) = c;\n   a < c\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (subsetbdd bdds xs bdd) ws ! a =\n                    ((\\<exists>i<length xs.\n                         xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n                     bdd_lookup bdd ws ! a)\n  length (bdd' # bdds) = length (x # xs)\n  \\<forall>a\\<in>set (bdd' # bdds). bddh (length ws) a\n  bddh (length ws) bdd\n  \\<lbrakk>?bs \\<in> set (bdd' # bdds); length ?w = length ws\\<rbrakk>\n  \\<Longrightarrow> length (bdd_lookup ?bs ?w) = c\n  length ?w = length ws \\<Longrightarrow> length (bdd_lookup bdd ?w) = c\n  a < c\n  x", "have H: \"bdd_lookup (subsetbdd bdds xs (bdd_binop bv_or bdd bdd')) ws ! a =\n     ((\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or> bdd_lookup (bdd_binop bv_or bdd bdd') ws ! a)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>x; length bdds = length xs;\n   \\<forall>a\\<in>set bdds. bddh (length ws) a;\n   bddh (length ws) (bdd_binop bv_or bdd bdd');\n   \\<And>bs w.\n      \\<lbrakk>bs \\<in> set bdds; length w = length ws\\<rbrakk>\n      \\<Longrightarrow> length (bdd_lookup bs w) = c;\n   \\<And>w.\n      length w = length ws \\<Longrightarrow>\n      length (bdd_lookup (bdd_binop bv_or bdd bdd') w) = c;\n   a < c\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup\n                     (subsetbdd bdds xs (bdd_binop bv_or bdd bdd')) ws !\n                    a =\n                    ((\\<exists>i<length xs.\n                         xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n                     bdd_lookup (bdd_binop bv_or bdd bdd') ws ! a)\n  \\<lbrakk>\\<not> x; length bdds = length xs;\n   \\<forall>a\\<in>set bdds. bddh (length ws) a; bddh (length ws) bdd;\n   \\<And>bs w.\n      \\<lbrakk>bs \\<in> set bdds; length w = length ws\\<rbrakk>\n      \\<Longrightarrow> length (bdd_lookup bs w) = c;\n   \\<And>w.\n      length w = length ws \\<Longrightarrow> length (bdd_lookup bdd w) = c;\n   a < c\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (subsetbdd bdds xs bdd) ws ! a =\n                    ((\\<exists>i<length xs.\n                         xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n                     bdd_lookup bdd ws ! a)\n  length (bdd' # bdds) = length (x # xs)\n  \\<forall>a\\<in>set (bdd' # bdds). bddh (length ws) a\n  bddh (length ws) bdd\n  \\<lbrakk>?bs \\<in> set (bdd' # bdds); length ?w = length ws\\<rbrakk>\n  \\<Longrightarrow> length (bdd_lookup ?bs ?w) = c\n  length ?w = length ws \\<Longrightarrow> length (bdd_lookup bdd ?w) = c\n  a < c\n  x\n\ngoal (1 subgoal):\n 1. bdd_lookup (subsetbdd bdds xs (bdd_binop bv_or bdd bdd')) ws ! a =\n    ((\\<exists>i<length xs.\n         xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n     bdd_lookup (bdd_binop bv_or bdd bdd') ws ! a)", "by (simp add: bddh_binop bdd_lookup_binop bv_or_length)"], ["proof (state)\nthis:\n  bdd_lookup (subsetbdd bdds xs (bdd_binop bv_or bdd bdd')) ws ! a =\n  ((\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n   bdd_lookup (bdd_binop bv_or bdd bdd') ws ! a)\n\ngoal (2 subgoals):\n 1. x \\<Longrightarrow>\n    bdd_lookup (subsetbdd (bdd' # bdds) (x # xs) bdd) ws ! a =\n    ((\\<exists>i<length (x # xs).\n         (x # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n     bdd_lookup bdd ws ! a)\n 2. \\<not> x \\<Longrightarrow>\n    bdd_lookup (subsetbdd (bdd' # bdds) (x # xs) bdd) ws ! a =\n    ((\\<exists>i<length (x # xs).\n         (x # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n     bdd_lookup bdd ws ! a)", "from 2"], ["proof (chain)\npicking this:\n  \\<lbrakk>x; length bdds = length xs;\n   \\<forall>a\\<in>set bdds. bddh (length ws) a;\n   bddh (length ws) (bdd_binop bv_or bdd bdd');\n   \\<And>bs w.\n      \\<lbrakk>bs \\<in> set bdds; length w = length ws\\<rbrakk>\n      \\<Longrightarrow> length (bdd_lookup bs w) = c;\n   \\<And>w.\n      length w = length ws \\<Longrightarrow>\n      length (bdd_lookup (bdd_binop bv_or bdd bdd') w) = c;\n   a < c\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup\n                     (subsetbdd bdds xs (bdd_binop bv_or bdd bdd')) ws !\n                    a =\n                    ((\\<exists>i<length xs.\n                         xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n                     bdd_lookup (bdd_binop bv_or bdd bdd') ws ! a)\n  \\<lbrakk>\\<not> x; length bdds = length xs;\n   \\<forall>a\\<in>set bdds. bddh (length ws) a; bddh (length ws) bdd;\n   \\<And>bs w.\n      \\<lbrakk>bs \\<in> set bdds; length w = length ws\\<rbrakk>\n      \\<Longrightarrow> length (bdd_lookup bs w) = c;\n   \\<And>w.\n      length w = length ws \\<Longrightarrow> length (bdd_lookup bdd w) = c;\n   a < c\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (subsetbdd bdds xs bdd) ws ! a =\n                    ((\\<exists>i<length xs.\n                         xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n                     bdd_lookup bdd ws ! a)\n  length (bdd' # bdds) = length (x # xs)\n  \\<forall>a\\<in>set (bdd' # bdds). bddh (length ws) a\n  bddh (length ws) bdd\n  \\<lbrakk>?bs \\<in> set (bdd' # bdds); length ?w = length ws\\<rbrakk>\n  \\<Longrightarrow> length (bdd_lookup ?bs ?w) = c\n  length ?w = length ws \\<Longrightarrow> length (bdd_lookup bdd ?w) = c\n  a < c", "have \"((\\<exists>i < length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or> bdd_lookup (bdd_binop bv_or bdd bdd') ws ! a) = \n      ((\\<exists>i < length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or> (bdd_lookup bdd' ws) ! a \\<or> (bdd_lookup bdd ws) ! a)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>x; length bdds = length xs;\n   \\<forall>a\\<in>set bdds. bddh (length ws) a;\n   bddh (length ws) (bdd_binop bv_or bdd bdd');\n   \\<And>bs w.\n      \\<lbrakk>bs \\<in> set bdds; length w = length ws\\<rbrakk>\n      \\<Longrightarrow> length (bdd_lookup bs w) = c;\n   \\<And>w.\n      length w = length ws \\<Longrightarrow>\n      length (bdd_lookup (bdd_binop bv_or bdd bdd') w) = c;\n   a < c\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup\n                     (subsetbdd bdds xs (bdd_binop bv_or bdd bdd')) ws !\n                    a =\n                    ((\\<exists>i<length xs.\n                         xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n                     bdd_lookup (bdd_binop bv_or bdd bdd') ws ! a)\n  \\<lbrakk>\\<not> x; length bdds = length xs;\n   \\<forall>a\\<in>set bdds. bddh (length ws) a; bddh (length ws) bdd;\n   \\<And>bs w.\n      \\<lbrakk>bs \\<in> set bdds; length w = length ws\\<rbrakk>\n      \\<Longrightarrow> length (bdd_lookup bs w) = c;\n   \\<And>w.\n      length w = length ws \\<Longrightarrow> length (bdd_lookup bdd w) = c;\n   a < c\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (subsetbdd bdds xs bdd) ws ! a =\n                    ((\\<exists>i<length xs.\n                         xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n                     bdd_lookup bdd ws ! a)\n  length (bdd' # bdds) = length (x # xs)\n  \\<forall>a\\<in>set (bdd' # bdds). bddh (length ws) a\n  bddh (length ws) bdd\n  \\<lbrakk>?bs \\<in> set (bdd' # bdds); length ?w = length ws\\<rbrakk>\n  \\<Longrightarrow> length (bdd_lookup ?bs ?w) = c\n  length ?w = length ws \\<Longrightarrow> length (bdd_lookup bdd ?w) = c\n  a < c\n\ngoal (1 subgoal):\n 1. ((\\<exists>i<length xs.\n         xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n     bdd_lookup (bdd_binop bv_or bdd bdd') ws ! a) =\n    ((\\<exists>i<length xs.\n         xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n     bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a)", "by (auto simp: bdd_lookup_binop bv_or_nth)"], ["proof (state)\nthis:\n  ((\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n   bdd_lookup (bdd_binop bv_or bdd bdd') ws ! a) =\n  ((\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n   bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a)\n\ngoal (2 subgoals):\n 1. x \\<Longrightarrow>\n    bdd_lookup (subsetbdd (bdd' # bdds) (x # xs) bdd) ws ! a =\n    ((\\<exists>i<length (x # xs).\n         (x # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n     bdd_lookup bdd ws ! a)\n 2. \\<not> x \\<Longrightarrow>\n    bdd_lookup (subsetbdd (bdd' # bdds) (x # xs) bdd) ws ! a =\n    ((\\<exists>i<length (x # xs).\n         (x # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n     bdd_lookup bdd ws ! a)", "also"], ["proof (state)\nthis:\n  ((\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n   bdd_lookup (bdd_binop bv_or bdd bdd') ws ! a) =\n  ((\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n   bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a)\n\ngoal (2 subgoals):\n 1. x \\<Longrightarrow>\n    bdd_lookup (subsetbdd (bdd' # bdds) (x # xs) bdd) ws ! a =\n    ((\\<exists>i<length (x # xs).\n         (x # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n     bdd_lookup bdd ws ! a)\n 2. \\<not> x \\<Longrightarrow>\n    bdd_lookup (subsetbdd (bdd' # bdds) (x # xs) bdd) ws ! a =\n    ((\\<exists>i<length (x # xs).\n         (x # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n     bdd_lookup bdd ws ! a)", "have \"\\<dots> = ((\\<exists>i < Suc (length xs). (True # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or> bdd_lookup bdd ws ! a)\"\n      (is \"((\\<exists>i. ?P i) \\<or> ?Q \\<or> ?R) = ((\\<exists>i. ?S i) \\<or> ?R)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<exists>i<length xs.\n         xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n     bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a) =\n    ((\\<exists>i<Suc (length xs).\n         (True # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n     bdd_lookup bdd ws ! a)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a \\<Longrightarrow>\n    (\\<exists>i<Suc (length xs).\n        (True # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n    bdd_lookup bdd ws ! a\n 2. (\\<exists>i<Suc (length xs).\n        (True # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n    bdd_lookup bdd ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a", "assume \"(\\<exists>i. ?P i) \\<or> ?Q \\<or> ?R\""], ["proof (state)\nthis:\n  (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n  bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a\n\ngoal (2 subgoals):\n 1. (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a \\<Longrightarrow>\n    (\\<exists>i<Suc (length xs).\n        (True # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n    bdd_lookup bdd ws ! a\n 2. (\\<exists>i<Suc (length xs).\n        (True # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n    bdd_lookup bdd ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a", "thus \"(\\<exists>i. ?S i) \\<or> ?R\""], ["proof (prove)\nusing this:\n  (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n  bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a\n\ngoal (1 subgoal):\n 1. (\\<exists>i<Suc (length xs).\n        (True # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n    bdd_lookup bdd ws ! a", "by (elim disjE) auto"], ["proof (state)\nthis:\n  (\\<exists>i<Suc (length xs).\n      (True # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n  bdd_lookup bdd ws ! a\n\ngoal (1 subgoal):\n 1. (\\<exists>i<Suc (length xs).\n        (True # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n    bdd_lookup bdd ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<exists>i<Suc (length xs).\n        (True # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n    bdd_lookup bdd ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a", "assume \"(\\<exists>i. ?S i) \\<or> ?R\""], ["proof (state)\nthis:\n  (\\<exists>i<Suc (length xs).\n      (True # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n  bdd_lookup bdd ws ! a\n\ngoal (1 subgoal):\n 1. (\\<exists>i<Suc (length xs).\n        (True # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n    bdd_lookup bdd ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a", "thus \"(\\<exists>i. ?P i) \\<or> ?Q \\<or> ?R\""], ["proof (prove)\nusing this:\n  (\\<exists>i<Suc (length xs).\n      (True # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n  bdd_lookup bdd ws ! a\n\ngoal (1 subgoal):\n 1. (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a", "proof (elim disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>i<Suc (length xs).\n       (True # xs) ! i \\<and>\n       bdd_lookup ((bdd' # bdds) ! i) ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a\n 2. bdd_lookup bdd ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a", "assume \"\\<exists>i. ?S i\""], ["proof (state)\nthis:\n  \\<exists>i<Suc (length xs).\n     (True # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a\n\ngoal (2 subgoals):\n 1. \\<exists>i<Suc (length xs).\n       (True # xs) ! i \\<and>\n       bdd_lookup ((bdd' # bdds) ! i) ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a\n 2. bdd_lookup bdd ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a", "then"], ["proof (chain)\npicking this:\n  \\<exists>i<Suc (length xs).\n     (True # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a", "obtain i where I: \"?S i\""], ["proof (prove)\nusing this:\n  \\<exists>i<Suc (length xs).\n     (True # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        i < Suc (length xs) \\<and>\n        (True # xs) ! i \\<and>\n        bdd_lookup ((bdd' # bdds) ! i) ws ! a \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  i < Suc (length xs) \\<and>\n  (True # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a\n\ngoal (2 subgoals):\n 1. \\<exists>i<Suc (length xs).\n       (True # xs) ! i \\<and>\n       bdd_lookup ((bdd' # bdds) ! i) ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a\n 2. bdd_lookup bdd ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a", "{"], ["proof (state)\nthis:\n  i < Suc (length xs) \\<and>\n  (True # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a\n\ngoal (2 subgoals):\n 1. \\<exists>i<Suc (length xs).\n       (True # xs) ! i \\<and>\n       bdd_lookup ((bdd' # bdds) ! i) ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a\n 2. bdd_lookup bdd ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a", "assume \"i = 0\""], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. \\<exists>i<Suc (length xs).\n       (True # xs) ! i \\<and>\n       bdd_lookup ((bdd' # bdds) ! i) ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a\n 2. bdd_lookup bdd ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a", "with I"], ["proof (chain)\npicking this:\n  i < Suc (length xs) \\<and>\n  (True # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a\n  i = 0", "have \"?Q\""], ["proof (prove)\nusing this:\n  i < Suc (length xs) \\<and>\n  (True # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a\n  i = 0\n\ngoal (1 subgoal):\n 1. bdd_lookup bdd' ws ! a", "by simp"], ["proof (state)\nthis:\n  bdd_lookup bdd' ws ! a\n\ngoal (2 subgoals):\n 1. \\<exists>i<Suc (length xs).\n       (True # xs) ! i \\<and>\n       bdd_lookup ((bdd' # bdds) ! i) ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a\n 2. bdd_lookup bdd ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a", "}"], ["proof (state)\nthis:\n  i = 0 \\<Longrightarrow> bdd_lookup bdd' ws ! a\n\ngoal (2 subgoals):\n 1. \\<exists>i<Suc (length xs).\n       (True # xs) ! i \\<and>\n       bdd_lookup ((bdd' # bdds) ! i) ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a\n 2. bdd_lookup bdd ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a", "{"], ["proof (state)\nthis:\n  i = 0 \\<Longrightarrow> bdd_lookup bdd' ws ! a\n\ngoal (2 subgoals):\n 1. \\<exists>i<Suc (length xs).\n       (True # xs) ! i \\<and>\n       bdd_lookup ((bdd' # bdds) ! i) ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a\n 2. bdd_lookup bdd ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a", "assume \"i \\<noteq> 0\""], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<exists>i<Suc (length xs).\n       (True # xs) ! i \\<and>\n       bdd_lookup ((bdd' # bdds) ! i) ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a\n 2. bdd_lookup bdd ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a", "then"], ["proof (chain)\npicking this:\n  i \\<noteq> 0", "obtain j where \"i = Suc j\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>j. i = Suc j \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases i) simp+"], ["proof (state)\nthis:\n  i = Suc j\n\ngoal (2 subgoals):\n 1. \\<exists>i<Suc (length xs).\n       (True # xs) ! i \\<and>\n       bdd_lookup ((bdd' # bdds) ! i) ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a\n 2. bdd_lookup bdd ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a", "with I"], ["proof (chain)\npicking this:\n  i < Suc (length xs) \\<and>\n  (True # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a\n  i = Suc j", "have \"\\<exists>j. ?P j\""], ["proof (prove)\nusing this:\n  i < Suc (length xs) \\<and>\n  (True # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a\n  i = Suc j\n\ngoal (1 subgoal):\n 1. \\<exists>j<length xs. xs ! j \\<and> bdd_lookup (bdds ! j) ws ! a", "by auto"], ["proof (state)\nthis:\n  \\<exists>j<length xs. xs ! j \\<and> bdd_lookup (bdds ! j) ws ! a\n\ngoal (2 subgoals):\n 1. \\<exists>i<Suc (length xs).\n       (True # xs) ! i \\<and>\n       bdd_lookup ((bdd' # bdds) ! i) ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a\n 2. bdd_lookup bdd ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a", "}"], ["proof (state)\nthis:\n  i \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>j<length xs. xs ! j \\<and> bdd_lookup (bdds ! j) ws ! a\n\ngoal (2 subgoals):\n 1. \\<exists>i<Suc (length xs).\n       (True # xs) ! i \\<and>\n       bdd_lookup ((bdd' # bdds) ! i) ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a\n 2. bdd_lookup bdd ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a", "with \\<open>i=0 \\<Longrightarrow> ?Q\\<close>"], ["proof (chain)\npicking this:\n  i = 0 \\<Longrightarrow> bdd_lookup bdd' ws ! a\n  i \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>j<length xs. xs ! j \\<and> bdd_lookup (bdds ! j) ws ! a", "show ?thesis"], ["proof (prove)\nusing this:\n  i = 0 \\<Longrightarrow> bdd_lookup bdd' ws ! a\n  i \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>j<length xs. xs ! j \\<and> bdd_lookup (bdds ! j) ws ! a\n\ngoal (1 subgoal):\n 1. (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a", "by (cases \"i=0\") simp+"], ["proof (state)\nthis:\n  (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n  bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a\n\ngoal (1 subgoal):\n 1. bdd_lookup bdd ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a", "qed simp"], ["proof (state)\nthis:\n  (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n  bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n   bdd_lookup bdd' ws ! a \\<or> bdd_lookup bdd ws ! a) =\n  ((\\<exists>i<Suc (length xs).\n       (True # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n   bdd_lookup bdd ws ! a)\n\ngoal (2 subgoals):\n 1. x \\<Longrightarrow>\n    bdd_lookup (subsetbdd (bdd' # bdds) (x # xs) bdd) ws ! a =\n    ((\\<exists>i<length (x # xs).\n         (x # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n     bdd_lookup bdd ws ! a)\n 2. \\<not> x \\<Longrightarrow>\n    bdd_lookup (subsetbdd (bdd' # bdds) (x # xs) bdd) ws ! a =\n    ((\\<exists>i<length (x # xs).\n         (x # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n     bdd_lookup bdd ws ! a)", "finally"], ["proof (chain)\npicking this:\n  ((\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n   bdd_lookup (bdd_binop bv_or bdd bdd') ws ! a) =\n  ((\\<exists>i<Suc (length xs).\n       (True # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n   bdd_lookup bdd ws ! a)", "have \"((\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or> bdd_lookup (bdd_binop bv_or bdd bdd') ws ! a) =\n       ((\\<exists>i<Suc (length xs). (True # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or> bdd_lookup bdd ws ! a)\""], ["proof (prove)\nusing this:\n  ((\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n   bdd_lookup (bdd_binop bv_or bdd bdd') ws ! a) =\n  ((\\<exists>i<Suc (length xs).\n       (True # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n   bdd_lookup bdd ws ! a)\n\ngoal (1 subgoal):\n 1. ((\\<exists>i<length xs.\n         xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n     bdd_lookup (bdd_binop bv_or bdd bdd') ws ! a) =\n    ((\\<exists>i<Suc (length xs).\n         (True # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n     bdd_lookup bdd ws ! a)", "by simp"], ["proof (state)\nthis:\n  ((\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n   bdd_lookup (bdd_binop bv_or bdd bdd') ws ! a) =\n  ((\\<exists>i<Suc (length xs).\n       (True # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n   bdd_lookup bdd ws ! a)\n\ngoal (2 subgoals):\n 1. x \\<Longrightarrow>\n    bdd_lookup (subsetbdd (bdd' # bdds) (x # xs) bdd) ws ! a =\n    ((\\<exists>i<length (x # xs).\n         (x # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n     bdd_lookup bdd ws ! a)\n 2. \\<not> x \\<Longrightarrow>\n    bdd_lookup (subsetbdd (bdd' # bdds) (x # xs) bdd) ws ! a =\n    ((\\<exists>i<length (x # xs).\n         (x # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n     bdd_lookup bdd ws ! a)", "with True H"], ["proof (chain)\npicking this:\n  x\n  bdd_lookup (subsetbdd bdds xs (bdd_binop bv_or bdd bdd')) ws ! a =\n  ((\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n   bdd_lookup (bdd_binop bv_or bdd bdd') ws ! a)\n  ((\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n   bdd_lookup (bdd_binop bv_or bdd bdd') ws ! a) =\n  ((\\<exists>i<Suc (length xs).\n       (True # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n   bdd_lookup bdd ws ! a)", "show ?thesis"], ["proof (prove)\nusing this:\n  x\n  bdd_lookup (subsetbdd bdds xs (bdd_binop bv_or bdd bdd')) ws ! a =\n  ((\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n   bdd_lookup (bdd_binop bv_or bdd bdd') ws ! a)\n  ((\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n   bdd_lookup (bdd_binop bv_or bdd bdd') ws ! a) =\n  ((\\<exists>i<Suc (length xs).\n       (True # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n   bdd_lookup bdd ws ! a)\n\ngoal (1 subgoal):\n 1. bdd_lookup (subsetbdd (bdd' # bdds) (x # xs) bdd) ws ! a =\n    ((\\<exists>i<length (x # xs).\n         (x # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n     bdd_lookup bdd ws ! a)", "by simp"], ["proof (state)\nthis:\n  bdd_lookup (subsetbdd (bdd' # bdds) (x # xs) bdd) ws ! a =\n  ((\\<exists>i<length (x # xs).\n       (x # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n   bdd_lookup bdd ws ! a)\n\ngoal (1 subgoal):\n 1. \\<not> x \\<Longrightarrow>\n    bdd_lookup (subsetbdd (bdd' # bdds) (x # xs) bdd) ws ! a =\n    ((\\<exists>i<length (x # xs).\n         (x # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n     bdd_lookup bdd ws ! a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x \\<Longrightarrow>\n    bdd_lookup (subsetbdd (bdd' # bdds) (x # xs) bdd) ws ! a =\n    ((\\<exists>i<length (x # xs).\n         (x # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n     bdd_lookup bdd ws ! a)", "case False"], ["proof (state)\nthis:\n  \\<not> x\n\ngoal (1 subgoal):\n 1. \\<not> x \\<Longrightarrow>\n    bdd_lookup (subsetbdd (bdd' # bdds) (x # xs) bdd) ws ! a =\n    ((\\<exists>i<length (x # xs).\n         (x # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n     bdd_lookup bdd ws ! a)", "with 2"], ["proof (chain)\npicking this:\n  \\<lbrakk>x; length bdds = length xs;\n   \\<forall>a\\<in>set bdds. bddh (length ws) a;\n   bddh (length ws) (bdd_binop bv_or bdd bdd');\n   \\<And>bs w.\n      \\<lbrakk>bs \\<in> set bdds; length w = length ws\\<rbrakk>\n      \\<Longrightarrow> length (bdd_lookup bs w) = c;\n   \\<And>w.\n      length w = length ws \\<Longrightarrow>\n      length (bdd_lookup (bdd_binop bv_or bdd bdd') w) = c;\n   a < c\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup\n                     (subsetbdd bdds xs (bdd_binop bv_or bdd bdd')) ws !\n                    a =\n                    ((\\<exists>i<length xs.\n                         xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n                     bdd_lookup (bdd_binop bv_or bdd bdd') ws ! a)\n  \\<lbrakk>\\<not> x; length bdds = length xs;\n   \\<forall>a\\<in>set bdds. bddh (length ws) a; bddh (length ws) bdd;\n   \\<And>bs w.\n      \\<lbrakk>bs \\<in> set bdds; length w = length ws\\<rbrakk>\n      \\<Longrightarrow> length (bdd_lookup bs w) = c;\n   \\<And>w.\n      length w = length ws \\<Longrightarrow> length (bdd_lookup bdd w) = c;\n   a < c\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (subsetbdd bdds xs bdd) ws ! a =\n                    ((\\<exists>i<length xs.\n                         xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n                     bdd_lookup bdd ws ! a)\n  length (bdd' # bdds) = length (x # xs)\n  \\<forall>a\\<in>set (bdd' # bdds). bddh (length ws) a\n  bddh (length ws) bdd\n  \\<lbrakk>?bs \\<in> set (bdd' # bdds); length ?w = length ws\\<rbrakk>\n  \\<Longrightarrow> length (bdd_lookup ?bs ?w) = c\n  length ?w = length ws \\<Longrightarrow> length (bdd_lookup bdd ?w) = c\n  a < c\n  \\<not> x", "have H: \"bdd_lookup (subsetbdd bdds xs bdd) ws ! a = ((\\<exists>i < length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or> bdd_lookup bdd ws ! a)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>x; length bdds = length xs;\n   \\<forall>a\\<in>set bdds. bddh (length ws) a;\n   bddh (length ws) (bdd_binop bv_or bdd bdd');\n   \\<And>bs w.\n      \\<lbrakk>bs \\<in> set bdds; length w = length ws\\<rbrakk>\n      \\<Longrightarrow> length (bdd_lookup bs w) = c;\n   \\<And>w.\n      length w = length ws \\<Longrightarrow>\n      length (bdd_lookup (bdd_binop bv_or bdd bdd') w) = c;\n   a < c\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup\n                     (subsetbdd bdds xs (bdd_binop bv_or bdd bdd')) ws !\n                    a =\n                    ((\\<exists>i<length xs.\n                         xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n                     bdd_lookup (bdd_binop bv_or bdd bdd') ws ! a)\n  \\<lbrakk>\\<not> x; length bdds = length xs;\n   \\<forall>a\\<in>set bdds. bddh (length ws) a; bddh (length ws) bdd;\n   \\<And>bs w.\n      \\<lbrakk>bs \\<in> set bdds; length w = length ws\\<rbrakk>\n      \\<Longrightarrow> length (bdd_lookup bs w) = c;\n   \\<And>w.\n      length w = length ws \\<Longrightarrow> length (bdd_lookup bdd w) = c;\n   a < c\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (subsetbdd bdds xs bdd) ws ! a =\n                    ((\\<exists>i<length xs.\n                         xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n                     bdd_lookup bdd ws ! a)\n  length (bdd' # bdds) = length (x # xs)\n  \\<forall>a\\<in>set (bdd' # bdds). bddh (length ws) a\n  bddh (length ws) bdd\n  \\<lbrakk>?bs \\<in> set (bdd' # bdds); length ?w = length ws\\<rbrakk>\n  \\<Longrightarrow> length (bdd_lookup ?bs ?w) = c\n  length ?w = length ws \\<Longrightarrow> length (bdd_lookup bdd ?w) = c\n  a < c\n  \\<not> x\n\ngoal (1 subgoal):\n 1. bdd_lookup (subsetbdd bdds xs bdd) ws ! a =\n    ((\\<exists>i<length xs.\n         xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n     bdd_lookup bdd ws ! a)", "by simp"], ["proof (state)\nthis:\n  bdd_lookup (subsetbdd bdds xs bdd) ws ! a =\n  ((\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n   bdd_lookup bdd ws ! a)\n\ngoal (1 subgoal):\n 1. \\<not> x \\<Longrightarrow>\n    bdd_lookup (subsetbdd (bdd' # bdds) (x # xs) bdd) ws ! a =\n    ((\\<exists>i<length (x # xs).\n         (x # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n     bdd_lookup bdd ws ! a)", "have \"((\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or> bdd_lookup bdd ws ! a) =\n       ((\\<exists>i<Suc (length xs). (False # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or> bdd_lookup bdd ws ! a)\"\n      (is \"((\\<exists>i. ?S i) \\<or> ?R) = ((\\<exists>i. ?P i) \\<or> ?R)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<exists>i<length xs.\n         xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n     bdd_lookup bdd ws ! a) =\n    ((\\<exists>i<Suc (length xs).\n         (False # xs) ! i \\<and>\n         bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n     bdd_lookup bdd ws ! a)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd ws ! a \\<Longrightarrow>\n    (\\<exists>i<Suc (length xs).\n        (False # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n    bdd_lookup bdd ws ! a\n 2. (\\<exists>i<Suc (length xs).\n        (False # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n    bdd_lookup bdd ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd ws ! a", "assume \"(\\<exists>i. ?S i) \\<or> ?R\""], ["proof (state)\nthis:\n  (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n  bdd_lookup bdd ws ! a\n\ngoal (2 subgoals):\n 1. (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd ws ! a \\<Longrightarrow>\n    (\\<exists>i<Suc (length xs).\n        (False # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n    bdd_lookup bdd ws ! a\n 2. (\\<exists>i<Suc (length xs).\n        (False # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n    bdd_lookup bdd ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd ws ! a", "thus \"(\\<exists>i. ?P i) \\<or> ?R\""], ["proof (prove)\nusing this:\n  (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n  bdd_lookup bdd ws ! a\n\ngoal (1 subgoal):\n 1. (\\<exists>i<Suc (length xs).\n        (False # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n    bdd_lookup bdd ws ! a", "by (elim disjE) auto"], ["proof (state)\nthis:\n  (\\<exists>i<Suc (length xs).\n      (False # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n  bdd_lookup bdd ws ! a\n\ngoal (1 subgoal):\n 1. (\\<exists>i<Suc (length xs).\n        (False # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n    bdd_lookup bdd ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd ws ! a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<exists>i<Suc (length xs).\n        (False # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n    bdd_lookup bdd ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd ws ! a", "assume \"(\\<exists>i. ?P i) \\<or> ?R\""], ["proof (state)\nthis:\n  (\\<exists>i<Suc (length xs).\n      (False # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n  bdd_lookup bdd ws ! a\n\ngoal (1 subgoal):\n 1. (\\<exists>i<Suc (length xs).\n        (False # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n    bdd_lookup bdd ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd ws ! a", "thus \"(\\<exists>i. ?S i) \\<or> ?R\""], ["proof (prove)\nusing this:\n  (\\<exists>i<Suc (length xs).\n      (False # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n  bdd_lookup bdd ws ! a\n\ngoal (1 subgoal):\n 1. (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd ws ! a", "proof (elim disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>i<Suc (length xs).\n       (False # xs) ! i \\<and>\n       bdd_lookup ((bdd' # bdds) ! i) ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd ws ! a\n 2. bdd_lookup bdd ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd ws ! a", "assume \"\\<exists>i. ?P i\""], ["proof (state)\nthis:\n  \\<exists>i<Suc (length xs).\n     (False # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a\n\ngoal (2 subgoals):\n 1. \\<exists>i<Suc (length xs).\n       (False # xs) ! i \\<and>\n       bdd_lookup ((bdd' # bdds) ! i) ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd ws ! a\n 2. bdd_lookup bdd ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd ws ! a", "then"], ["proof (chain)\npicking this:\n  \\<exists>i<Suc (length xs).\n     (False # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a", "obtain i where \"?P i\""], ["proof (prove)\nusing this:\n  \\<exists>i<Suc (length xs).\n     (False # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        i < Suc (length xs) \\<and>\n        (False # xs) ! i \\<and>\n        bdd_lookup ((bdd' # bdds) ! i) ws ! a \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  i < Suc (length xs) \\<and>\n  (False # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a\n\ngoal (2 subgoals):\n 1. \\<exists>i<Suc (length xs).\n       (False # xs) ! i \\<and>\n       bdd_lookup ((bdd' # bdds) ! i) ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd ws ! a\n 2. bdd_lookup bdd ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd ws ! a", "then"], ["proof (chain)\npicking this:\n  i < Suc (length xs) \\<and>\n  (False # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a", "obtain j where \"i = Suc j\""], ["proof (prove)\nusing this:\n  i < Suc (length xs) \\<and>\n  (False # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a\n\ngoal (1 subgoal):\n 1. (\\<And>j. i = Suc j \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases i) simp+"], ["proof (state)\nthis:\n  i = Suc j\n\ngoal (2 subgoals):\n 1. \\<exists>i<Suc (length xs).\n       (False # xs) ! i \\<and>\n       bdd_lookup ((bdd' # bdds) ! i) ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd ws ! a\n 2. bdd_lookup bdd ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd ws ! a", "with \\<open>?P i\\<close>"], ["proof (chain)\npicking this:\n  i < Suc (length xs) \\<and>\n  (False # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a\n  i = Suc j", "show ?thesis"], ["proof (prove)\nusing this:\n  i < Suc (length xs) \\<and>\n  (False # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a\n  i = Suc j\n\ngoal (1 subgoal):\n 1. (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd ws ! a", "by auto"], ["proof (state)\nthis:\n  (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n  bdd_lookup bdd ws ! a\n\ngoal (1 subgoal):\n 1. bdd_lookup bdd ws ! a \\<Longrightarrow>\n    (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n    bdd_lookup bdd ws ! a", "qed simp"], ["proof (state)\nthis:\n  (\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n  bdd_lookup bdd ws ! a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n   bdd_lookup bdd ws ! a) =\n  ((\\<exists>i<Suc (length xs).\n       (False # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n   bdd_lookup bdd ws ! a)\n\ngoal (1 subgoal):\n 1. \\<not> x \\<Longrightarrow>\n    bdd_lookup (subsetbdd (bdd' # bdds) (x # xs) bdd) ws ! a =\n    ((\\<exists>i<length (x # xs).\n         (x # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n     bdd_lookup bdd ws ! a)", "with False H"], ["proof (chain)\npicking this:\n  \\<not> x\n  bdd_lookup (subsetbdd bdds xs bdd) ws ! a =\n  ((\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n   bdd_lookup bdd ws ! a)\n  ((\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n   bdd_lookup bdd ws ! a) =\n  ((\\<exists>i<Suc (length xs).\n       (False # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n   bdd_lookup bdd ws ! a)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> x\n  bdd_lookup (subsetbdd bdds xs bdd) ws ! a =\n  ((\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n   bdd_lookup bdd ws ! a)\n  ((\\<exists>i<length xs. xs ! i \\<and> bdd_lookup (bdds ! i) ws ! a) \\<or>\n   bdd_lookup bdd ws ! a) =\n  ((\\<exists>i<Suc (length xs).\n       (False # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n   bdd_lookup bdd ws ! a)\n\ngoal (1 subgoal):\n 1. bdd_lookup (subsetbdd (bdd' # bdds) (x # xs) bdd) ws ! a =\n    ((\\<exists>i<length (x # xs).\n         (x # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n     bdd_lookup bdd ws ! a)", "by simp"], ["proof (state)\nthis:\n  bdd_lookup (subsetbdd (bdd' # bdds) (x # xs) bdd) ws ! a =\n  ((\\<exists>i<length (x # xs).\n       (x # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n   bdd_lookup bdd ws ! a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bdd_lookup (subsetbdd (bdd' # bdds) (x # xs) bdd) ws ! a =\n  ((\\<exists>i<length (x # xs).\n       (x # xs) ! i \\<and> bdd_lookup ((bdd' # bdds) ! i) ws ! a) \\<or>\n   bdd_lookup bdd ws ! a)\n\ngoal (3 subgoals):\n 1. \\<And>bdd.\n       \\<lbrakk>length [] = length []; Ball (set []) (bddh (length ws));\n        bddh (length ws) bdd;\n        \\<And>bs w.\n           \\<lbrakk>bs \\<in> set []; length w = length ws\\<rbrakk>\n           \\<Longrightarrow> length (bdd_lookup bs w) = c;\n        \\<And>w.\n           length w = length ws \\<Longrightarrow>\n           length (bdd_lookup bdd w) = c;\n        a < c\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (subsetbdd [] [] bdd) ws ! a =\n                         ((\\<exists>i<length [].\n                              [] ! i \\<and>\n                              bdd_lookup ([] ! i) ws ! a) \\<or>\n                          bdd_lookup bdd ws ! a)\n 2. \\<And>v va ca.\n       \\<lbrakk>length (v # va) = length [];\n        Ball (set (v # va)) (bddh (length ws)); bddh (length ws) ca;\n        \\<And>bs w.\n           \\<lbrakk>bs \\<in> set (v # va); length w = length ws\\<rbrakk>\n           \\<Longrightarrow> length (bdd_lookup bs w) = c;\n        \\<And>w.\n           length w = length ws \\<Longrightarrow>\n           length (bdd_lookup ca w) = c;\n        a < c\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (subsetbdd (v # va) [] ca) ws ! a =\n                         ((\\<exists>i<length [].\n                              [] ! i \\<and>\n                              bdd_lookup ((v # va) ! i) ws ! a) \\<or>\n                          bdd_lookup ca ws ! a)\n 3. \\<And>v va ca.\n       \\<lbrakk>length [] = length (v # va);\n        Ball (set []) (bddh (length ws)); bddh (length ws) ca;\n        \\<And>bs w.\n           \\<lbrakk>bs \\<in> set []; length w = length ws\\<rbrakk>\n           \\<Longrightarrow> length (bdd_lookup bs w) = c;\n        \\<And>w.\n           length w = length ws \\<Longrightarrow>\n           length (bdd_lookup ca w) = c;\n        a < c\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (subsetbdd [] (v # va) ca) ws ! a =\n                         ((\\<exists>i<length (v # va).\n                              (v # va) ! i \\<and>\n                              bdd_lookup ([] ! i) ws ! a) \\<or>\n                          bdd_lookup ca ws ! a)", "qed simp+"], ["", "lemma bdd_lookup_subsetbdd:\n  assumes \"wf_nfa N (length ws)\"\n  and \"nfa_is_node N q\"\n  and \"a < length (fst N)\"\n  shows \"bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q))) ws ! a = (\\<exists>i< length q. q ! i \\<and> bdd_lookup (fst N ! i) ws ! a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q))) ws ! a =\n    (\\<exists>i<length q. q ! i \\<and> bdd_lookup (fst N ! i) ws ! a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q))) ws ! a =\n    (\\<exists>i<length q. q ! i \\<and> bdd_lookup (fst N ! i) ws ! a)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q))) ws ! a =\n    (\\<exists>i<length q. q ! i \\<and> bdd_lookup (fst N ! i) ws ! a)", "fix w :: \"bool list\""], ["proof (state)\ngoal (1 subgoal):\n 1. bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q))) ws ! a =\n    (\\<exists>i<length q. q ! i \\<and> bdd_lookup (fst N ! i) ws ! a)", "assume H: \"length w = length ws\""], ["proof (state)\nthis:\n  length w = length ws\n\ngoal (1 subgoal):\n 1. bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q))) ws ! a =\n    (\\<exists>i<length q. q ! i \\<and> bdd_lookup (fst N ! i) ws ! a)", "from assms"], ["proof (chain)\npicking this:\n  wf_nfa N (length ws)\n  nfa_is_node N q\n  a < length (fst N)", "have \"\\<forall>bd \\<in> set (fst N). bdd_all (nfa_is_node N) bd\""], ["proof (prove)\nusing this:\n  wf_nfa N (length ws)\n  nfa_is_node N q\n  a < length (fst N)\n\ngoal (1 subgoal):\n 1. \\<forall>bd\\<in>set (fst N). bdd_all (nfa_is_node N) bd", "by (simp add: wf_nfa_def list_all_iff)"], ["proof (state)\nthis:\n  \\<forall>bd\\<in>set (fst N). bdd_all (nfa_is_node N) bd\n\ngoal (1 subgoal):\n 1. bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q))) ws ! a =\n    (\\<exists>i<length q. q ! i \\<and> bdd_lookup (fst N ! i) ws ! a)", "moreover"], ["proof (state)\nthis:\n  \\<forall>bd\\<in>set (fst N). bdd_all (nfa_is_node N) bd\n\ngoal (1 subgoal):\n 1. bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q))) ws ! a =\n    (\\<exists>i<length q. q ! i \\<and> bdd_lookup (fst N ! i) ws ! a)", "from assms"], ["proof (chain)\npicking this:\n  wf_nfa N (length ws)\n  nfa_is_node N q\n  a < length (fst N)", "have \"\\<forall>bd \\<in> set (fst N). bddh (length ws) bd\""], ["proof (prove)\nusing this:\n  wf_nfa N (length ws)\n  nfa_is_node N q\n  a < length (fst N)\n\ngoal (1 subgoal):\n 1. \\<forall>bd\\<in>set (fst N). bddh (length ws) bd", "by (simp add: wf_nfa_def list_all_iff)"], ["proof (state)\nthis:\n  \\<forall>bd\\<in>set (fst N). bddh (length ws) bd\n\ngoal (1 subgoal):\n 1. bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q))) ws ! a =\n    (\\<exists>i<length q. q ! i \\<and> bdd_lookup (fst N ! i) ws ! a)", "moreover"], ["proof (state)\nthis:\n  \\<forall>bd\\<in>set (fst N). bddh (length ws) bd\n\ngoal (1 subgoal):\n 1. bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q))) ws ! a =\n    (\\<exists>i<length q. q ! i \\<and> bdd_lookup (fst N ! i) ws ! a)", "note H"], ["proof (state)\nthis:\n  length w = length ws\n\ngoal (1 subgoal):\n 1. bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q))) ws ! a =\n    (\\<exists>i<length q. q ! i \\<and> bdd_lookup (fst N ! i) ws ! a)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>bd\\<in>set (fst N). bdd_all (nfa_is_node N) bd\n  \\<forall>bd\\<in>set (fst N). bddh (length ws) bd\n  length w = length ws", "have \"\\<forall>bd \\<in> set (fst N). nfa_is_node N (bdd_lookup bd w)\""], ["proof (prove)\nusing this:\n  \\<forall>bd\\<in>set (fst N). bdd_all (nfa_is_node N) bd\n  \\<forall>bd\\<in>set (fst N). bddh (length ws) bd\n  length w = length ws\n\ngoal (1 subgoal):\n 1. \\<forall>bd\\<in>set (fst N). nfa_is_node N (bdd_lookup bd w)", "by (simp add: bdd_all_bdd_lookup)"], ["proof (state)\nthis:\n  \\<forall>bd\\<in>set (fst N). nfa_is_node N (bdd_lookup bd w)\n\ngoal (1 subgoal):\n 1. bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q))) ws ! a =\n    (\\<exists>i<length q. q ! i \\<and> bdd_lookup (fst N ! i) ws ! a)", "}"], ["proof (state)\nthis:\n  length ?w2 = length ws \\<Longrightarrow>\n  \\<forall>bd\\<in>set (fst N). nfa_is_node N (bdd_lookup bd ?w2)\n\ngoal (1 subgoal):\n 1. bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q))) ws ! a =\n    (\\<exists>i<length q. q ! i \\<and> bdd_lookup (fst N ! i) ws ! a)", "with assms"], ["proof (chain)\npicking this:\n  wf_nfa N (length ws)\n  nfa_is_node N q\n  a < length (fst N)\n  length ?w2 = length ws \\<Longrightarrow>\n  \\<forall>bd\\<in>set (fst N). nfa_is_node N (bdd_lookup bd ?w2)", "have \"bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q))) ws ! a = ((\\<exists>i < length q. q ! i \\<and> bdd_lookup (fst N ! i) ws ! a) \\<or> bdd_lookup (nfa_emptybdd (length q)) ws ! a)\""], ["proof (prove)\nusing this:\n  wf_nfa N (length ws)\n  nfa_is_node N q\n  a < length (fst N)\n  length ?w2 = length ws \\<Longrightarrow>\n  \\<forall>bd\\<in>set (fst N). nfa_is_node N (bdd_lookup bd ?w2)\n\ngoal (1 subgoal):\n 1. bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q))) ws ! a =\n    ((\\<exists>i<length q. q ! i \\<and> bdd_lookup (fst N ! i) ws ! a) \\<or>\n     bdd_lookup (nfa_emptybdd (length q)) ws ! a)", "by (simp add: bdd_lookup_subsetbdd' nfa_is_node_def wf_nfa_def list_all_iff nfa_emptybdd_def)"], ["proof (state)\nthis:\n  bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q))) ws ! a =\n  ((\\<exists>i<length q. q ! i \\<and> bdd_lookup (fst N ! i) ws ! a) \\<or>\n   bdd_lookup (nfa_emptybdd (length q)) ws ! a)\n\ngoal (1 subgoal):\n 1. bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q))) ws ! a =\n    (\\<exists>i<length q. q ! i \\<and> bdd_lookup (fst N ! i) ws ! a)", "with assms"], ["proof (chain)\npicking this:\n  wf_nfa N (length ws)\n  nfa_is_node N q\n  a < length (fst N)\n  bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q))) ws ! a =\n  ((\\<exists>i<length q. q ! i \\<and> bdd_lookup (fst N ! i) ws ! a) \\<or>\n   bdd_lookup (nfa_emptybdd (length q)) ws ! a)", "show ?thesis"], ["proof (prove)\nusing this:\n  wf_nfa N (length ws)\n  nfa_is_node N q\n  a < length (fst N)\n  bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q))) ws ! a =\n  ((\\<exists>i<length q. q ! i \\<and> bdd_lookup (fst N ! i) ws ! a) \\<or>\n   bdd_lookup (nfa_emptybdd (length q)) ws ! a)\n\ngoal (1 subgoal):\n 1. bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q))) ws ! a =\n    (\\<exists>i<length q. q ! i \\<and> bdd_lookup (fst N ! i) ws ! a)", "by (auto simp: nfa_emptybdd_def nfa_is_node_def)"], ["proof (state)\nthis:\n  bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q))) ws ! a =\n  (\\<exists>i<length q. q ! i \\<and> bdd_lookup (fst N ! i) ws ! a)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  nfa_trans :: \"nfa \\<Rightarrow> bool list \\<Rightarrow> bool list \\<Rightarrow> bool list\" where\n  \"nfa_trans A qs bs = bdd_lookup (subsetbdd (fst A) qs (nfa_emptybdd (length qs))) bs\""], ["", "fun nfa_accepting' :: \"bool list \\<Rightarrow> bool list \\<Rightarrow> bool\" where\n  \"nfa_accepting' [] bs = False\"\n| \"nfa_accepting' as [] = False\"\n| \"nfa_accepting' (a # as) (b # bs) = (a \\<and> b \\<or> nfa_accepting' as bs)\""], ["", "definition nfa_accepting :: \"nfa \\<Rightarrow> bool list \\<Rightarrow> bool\" where\n  \"nfa_accepting A = nfa_accepting' (snd A)\""], ["", "lemma nfa_accepting'_set_of_bv: \"nfa_accepting' l r = (set_of_bv l \\<inter> set_of_bv r \\<noteq> {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfa_accepting' l r = (set_of_bv l \\<inter> set_of_bv r \\<noteq> {})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nfa_accepting' l r = (set_of_bv l \\<inter> set_of_bv r \\<noteq> {})", "have nfa_accepting_help: \"\\<And>as q. nfa_accepting' as q = (\\<exists>i. i < length as \\<and> i < length q \\<and> as ! i \\<and> q ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as q.\n       nfa_accepting' as q =\n       (\\<exists>i<length as. i < length q \\<and> as ! i \\<and> q ! i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>as q.\n       nfa_accepting' as q =\n       (\\<exists>i<length as. i < length q \\<and> as ! i \\<and> q ! i)", "fix as q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>as q.\n       nfa_accepting' as q =\n       (\\<exists>i<length as. i < length q \\<and> as ! i \\<and> q ! i)", "show \"nfa_accepting' as q = (\\<exists>i < length as. i < length q \\<and> as ! i \\<and> q ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfa_accepting' as q =\n    (\\<exists>i<length as. i < length q \\<and> as ! i \\<and> q ! i)", "proof (induct as q rule: nfa_accepting'.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>bs.\n       nfa_accepting' [] bs =\n       (\\<exists>i<length []. i < length bs \\<and> [] ! i \\<and> bs ! i)\n 2. \\<And>v va.\n       nfa_accepting' (v # va) [] =\n       (\\<exists>i<length (v # va).\n           i < length [] \\<and> (v # va) ! i \\<and> [] ! i)\n 3. \\<And>a as b bs.\n       nfa_accepting' as bs =\n       (\\<exists>i<length as.\n           i < length bs \\<and> as ! i \\<and> bs ! i) \\<Longrightarrow>\n       nfa_accepting' (a # as) (b # bs) =\n       (\\<exists>i<length (a # as).\n           i < length (b # bs) \\<and> (a # as) ! i \\<and> (b # bs) ! i)", "case (3 a as q qs)"], ["proof (state)\nthis:\n  nfa_accepting' as qs =\n  (\\<exists>i<length as. i < length qs \\<and> as ! i \\<and> qs ! i)\n\ngoal (3 subgoals):\n 1. \\<And>bs.\n       nfa_accepting' [] bs =\n       (\\<exists>i<length []. i < length bs \\<and> [] ! i \\<and> bs ! i)\n 2. \\<And>v va.\n       nfa_accepting' (v # va) [] =\n       (\\<exists>i<length (v # va).\n           i < length [] \\<and> (v # va) ! i \\<and> [] ! i)\n 3. \\<And>a as b bs.\n       nfa_accepting' as bs =\n       (\\<exists>i<length as.\n           i < length bs \\<and> as ! i \\<and> bs ! i) \\<Longrightarrow>\n       nfa_accepting' (a # as) (b # bs) =\n       (\\<exists>i<length (a # as).\n           i < length (b # bs) \\<and> (a # as) ! i \\<and> (b # bs) ! i)", "thus ?case"], ["proof (prove)\nusing this:\n  nfa_accepting' as qs =\n  (\\<exists>i<length as. i < length qs \\<and> as ! i \\<and> qs ! i)\n\ngoal (1 subgoal):\n 1. nfa_accepting' (a # as) (q # qs) =\n    (\\<exists>i<length (a # as).\n        i < length (q # qs) \\<and> (a # as) ! i \\<and> (q # qs) ! i)", "proof (cases \"a\\<and>q\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>nfa_accepting' as qs =\n             (\\<exists>i<length as.\n                 i < length qs \\<and> as ! i \\<and> qs ! i);\n     a \\<and> q\\<rbrakk>\n    \\<Longrightarrow> nfa_accepting' (a # as) (q # qs) =\n                      (\\<exists>i<length (a # as).\n                          i < length (q # qs) \\<and>\n                          (a # as) ! i \\<and> (q # qs) ! i)\n 2. \\<lbrakk>nfa_accepting' as qs =\n             (\\<exists>i<length as.\n                 i < length qs \\<and> as ! i \\<and> qs ! i);\n     \\<not> (a \\<and> q)\\<rbrakk>\n    \\<Longrightarrow> nfa_accepting' (a # as) (q # qs) =\n                      (\\<exists>i<length (a # as).\n                          i < length (q # qs) \\<and>\n                          (a # as) ! i \\<and> (q # qs) ! i)", "case False"], ["proof (state)\nthis:\n  \\<not> (a \\<and> q)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>nfa_accepting' as qs =\n             (\\<exists>i<length as.\n                 i < length qs \\<and> as ! i \\<and> qs ! i);\n     a \\<and> q\\<rbrakk>\n    \\<Longrightarrow> nfa_accepting' (a # as) (q # qs) =\n                      (\\<exists>i<length (a # as).\n                          i < length (q # qs) \\<and>\n                          (a # as) ! i \\<and> (q # qs) ! i)\n 2. \\<lbrakk>nfa_accepting' as qs =\n             (\\<exists>i<length as.\n                 i < length qs \\<and> as ! i \\<and> qs ! i);\n     \\<not> (a \\<and> q)\\<rbrakk>\n    \\<Longrightarrow> nfa_accepting' (a # as) (q # qs) =\n                      (\\<exists>i<length (a # as).\n                          i < length (q # qs) \\<and>\n                          (a # as) ! i \\<and> (q # qs) ! i)", "with 3"], ["proof (chain)\npicking this:\n  nfa_accepting' as qs =\n  (\\<exists>i<length as. i < length qs \\<and> as ! i \\<and> qs ! i)\n  \\<not> (a \\<and> q)", "have \"nfa_accepting' as qs = (\\<exists>i < length as. i < length qs \\<and> as ! i \\<and> qs ! i)\" (is \"?T = _\")"], ["proof (prove)\nusing this:\n  nfa_accepting' as qs =\n  (\\<exists>i<length as. i < length qs \\<and> as ! i \\<and> qs ! i)\n  \\<not> (a \\<and> q)\n\ngoal (1 subgoal):\n 1. nfa_accepting' as qs =\n    (\\<exists>i<length as. i < length qs \\<and> as ! i \\<and> qs ! i)", "by simp"], ["proof (state)\nthis:\n  nfa_accepting' as qs =\n  (\\<exists>i<length as. i < length qs \\<and> as ! i \\<and> qs ! i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>nfa_accepting' as qs =\n             (\\<exists>i<length as.\n                 i < length qs \\<and> as ! i \\<and> qs ! i);\n     a \\<and> q\\<rbrakk>\n    \\<Longrightarrow> nfa_accepting' (a # as) (q # qs) =\n                      (\\<exists>i<length (a # as).\n                          i < length (q # qs) \\<and>\n                          (a # as) ! i \\<and> (q # qs) ! i)\n 2. \\<lbrakk>nfa_accepting' as qs =\n             (\\<exists>i<length as.\n                 i < length qs \\<and> as ! i \\<and> qs ! i);\n     \\<not> (a \\<and> q)\\<rbrakk>\n    \\<Longrightarrow> nfa_accepting' (a # as) (q # qs) =\n                      (\\<exists>i<length (a # as).\n                          i < length (q # qs) \\<and>\n                          (a # as) ! i \\<and> (q # qs) ! i)", "also"], ["proof (state)\nthis:\n  nfa_accepting' as qs =\n  (\\<exists>i<length as. i < length qs \\<and> as ! i \\<and> qs ! i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>nfa_accepting' as qs =\n             (\\<exists>i<length as.\n                 i < length qs \\<and> as ! i \\<and> qs ! i);\n     a \\<and> q\\<rbrakk>\n    \\<Longrightarrow> nfa_accepting' (a # as) (q # qs) =\n                      (\\<exists>i<length (a # as).\n                          i < length (q # qs) \\<and>\n                          (a # as) ! i \\<and> (q # qs) ! i)\n 2. \\<lbrakk>nfa_accepting' as qs =\n             (\\<exists>i<length as.\n                 i < length qs \\<and> as ! i \\<and> qs ! i);\n     \\<not> (a \\<and> q)\\<rbrakk>\n    \\<Longrightarrow> nfa_accepting' (a # as) (q # qs) =\n                      (\\<exists>i<length (a # as).\n                          i < length (q # qs) \\<and>\n                          (a # as) ! i \\<and> (q # qs) ! i)", "have \"\\<dots> = (\\<exists>j < length as. j < length qs \\<and> (a#as) ! Suc j \\<and> (q#qs) ! Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>i<length as. i < length qs \\<and> as ! i \\<and> qs ! i) =\n    (\\<exists>j<length as.\n        j < length qs \\<and> (a # as) ! Suc j \\<and> (q # qs) ! Suc j)", "by simp"], ["proof (state)\nthis:\n  (\\<exists>i<length as. i < length qs \\<and> as ! i \\<and> qs ! i) =\n  (\\<exists>j<length as.\n      j < length qs \\<and> (a # as) ! Suc j \\<and> (q # qs) ! Suc j)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>nfa_accepting' as qs =\n             (\\<exists>i<length as.\n                 i < length qs \\<and> as ! i \\<and> qs ! i);\n     a \\<and> q\\<rbrakk>\n    \\<Longrightarrow> nfa_accepting' (a # as) (q # qs) =\n                      (\\<exists>i<length (a # as).\n                          i < length (q # qs) \\<and>\n                          (a # as) ! i \\<and> (q # qs) ! i)\n 2. \\<lbrakk>nfa_accepting' as qs =\n             (\\<exists>i<length as.\n                 i < length qs \\<and> as ! i \\<and> qs ! i);\n     \\<not> (a \\<and> q)\\<rbrakk>\n    \\<Longrightarrow> nfa_accepting' (a # as) (q # qs) =\n                      (\\<exists>i<length (a # as).\n                          i < length (q # qs) \\<and>\n                          (a # as) ! i \\<and> (q # qs) ! i)", "also"], ["proof (state)\nthis:\n  (\\<exists>i<length as. i < length qs \\<and> as ! i \\<and> qs ! i) =\n  (\\<exists>j<length as.\n      j < length qs \\<and> (a # as) ! Suc j \\<and> (q # qs) ! Suc j)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>nfa_accepting' as qs =\n             (\\<exists>i<length as.\n                 i < length qs \\<and> as ! i \\<and> qs ! i);\n     a \\<and> q\\<rbrakk>\n    \\<Longrightarrow> nfa_accepting' (a # as) (q # qs) =\n                      (\\<exists>i<length (a # as).\n                          i < length (q # qs) \\<and>\n                          (a # as) ! i \\<and> (q # qs) ! i)\n 2. \\<lbrakk>nfa_accepting' as qs =\n             (\\<exists>i<length as.\n                 i < length qs \\<and> as ! i \\<and> qs ! i);\n     \\<not> (a \\<and> q)\\<rbrakk>\n    \\<Longrightarrow> nfa_accepting' (a # as) (q # qs) =\n                      (\\<exists>i<length (a # as).\n                          i < length (q # qs) \\<and>\n                          (a # as) ! i \\<and> (q # qs) ! i)", "have \"\\<dots> = (\\<exists>j < length (a#as). j < length (q#qs) \\<and> (a#as) ! j \\<and> (q#qs) ! j)\" (is \"(\\<exists>j. ?P j) = (\\<exists>j. ?Q j)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>j<length as.\n        j < length qs \\<and> (a # as) ! Suc j \\<and> (q # qs) ! Suc j) =\n    (\\<exists>j<length (a # as).\n        j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>j<length as.\n       j < length qs \\<and>\n       (a # as) ! Suc j \\<and> (q # qs) ! Suc j \\<Longrightarrow>\n    \\<exists>j<length (a # as).\n       j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j\n 2. \\<exists>j<length (a # as).\n       j < length (q # qs) \\<and>\n       (a # as) ! j \\<and> (q # qs) ! j \\<Longrightarrow>\n    \\<exists>j<length as.\n       j < length qs \\<and> (a # as) ! Suc j \\<and> (q # qs) ! Suc j", "assume \"\\<exists>j. ?P j\""], ["proof (state)\nthis:\n  \\<exists>j<length as.\n     j < length qs \\<and> (a # as) ! Suc j \\<and> (q # qs) ! Suc j\n\ngoal (2 subgoals):\n 1. \\<exists>j<length as.\n       j < length qs \\<and>\n       (a # as) ! Suc j \\<and> (q # qs) ! Suc j \\<Longrightarrow>\n    \\<exists>j<length (a # as).\n       j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j\n 2. \\<exists>j<length (a # as).\n       j < length (q # qs) \\<and>\n       (a # as) ! j \\<and> (q # qs) ! j \\<Longrightarrow>\n    \\<exists>j<length as.\n       j < length qs \\<and> (a # as) ! Suc j \\<and> (q # qs) ! Suc j", "then"], ["proof (chain)\npicking this:\n  \\<exists>j<length as.\n     j < length qs \\<and> (a # as) ! Suc j \\<and> (q # qs) ! Suc j", "obtain j where \"?P j\""], ["proof (prove)\nusing this:\n  \\<exists>j<length as.\n     j < length qs \\<and> (a # as) ! Suc j \\<and> (q # qs) ! Suc j\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        j < length as \\<and>\n        j < length qs \\<and>\n        (a # as) ! Suc j \\<and> (q # qs) ! Suc j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  j < length as \\<and>\n  j < length qs \\<and> (a # as) ! Suc j \\<and> (q # qs) ! Suc j\n\ngoal (2 subgoals):\n 1. \\<exists>j<length as.\n       j < length qs \\<and>\n       (a # as) ! Suc j \\<and> (q # qs) ! Suc j \\<Longrightarrow>\n    \\<exists>j<length (a # as).\n       j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j\n 2. \\<exists>j<length (a # as).\n       j < length (q # qs) \\<and>\n       (a # as) ! j \\<and> (q # qs) ! j \\<Longrightarrow>\n    \\<exists>j<length as.\n       j < length qs \\<and> (a # as) ! Suc j \\<and> (q # qs) ! Suc j", "hence \"?Q (Suc j)\""], ["proof (prove)\nusing this:\n  j < length as \\<and>\n  j < length qs \\<and> (a # as) ! Suc j \\<and> (q # qs) ! Suc j\n\ngoal (1 subgoal):\n 1. Suc j < length (a # as) \\<and>\n    Suc j < length (q # qs) \\<and> (a # as) ! Suc j \\<and> (q # qs) ! Suc j", "by simp"], ["proof (state)\nthis:\n  Suc j < length (a # as) \\<and>\n  Suc j < length (q # qs) \\<and> (a # as) ! Suc j \\<and> (q # qs) ! Suc j\n\ngoal (2 subgoals):\n 1. \\<exists>j<length as.\n       j < length qs \\<and>\n       (a # as) ! Suc j \\<and> (q # qs) ! Suc j \\<Longrightarrow>\n    \\<exists>j<length (a # as).\n       j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j\n 2. \\<exists>j<length (a # as).\n       j < length (q # qs) \\<and>\n       (a # as) ! j \\<and> (q # qs) ! j \\<Longrightarrow>\n    \\<exists>j<length as.\n       j < length qs \\<and> (a # as) ! Suc j \\<and> (q # qs) ! Suc j", "thus \"\\<exists>j. ?Q j\""], ["proof (prove)\nusing this:\n  Suc j < length (a # as) \\<and>\n  Suc j < length (q # qs) \\<and> (a # as) ! Suc j \\<and> (q # qs) ! Suc j\n\ngoal (1 subgoal):\n 1. \\<exists>j<length (a # as).\n       j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j", "by (rule exI)"], ["proof (state)\nthis:\n  \\<exists>j<length (a # as).\n     j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j\n\ngoal (1 subgoal):\n 1. \\<exists>j<length (a # as).\n       j < length (q # qs) \\<and>\n       (a # as) ! j \\<and> (q # qs) ! j \\<Longrightarrow>\n    \\<exists>j<length as.\n       j < length qs \\<and> (a # as) ! Suc j \\<and> (q # qs) ! Suc j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>j<length (a # as).\n       j < length (q # qs) \\<and>\n       (a # as) ! j \\<and> (q # qs) ! j \\<Longrightarrow>\n    \\<exists>j<length as.\n       j < length qs \\<and> (a # as) ! Suc j \\<and> (q # qs) ! Suc j", "assume \"\\<exists>j. ?Q j\""], ["proof (state)\nthis:\n  \\<exists>j<length (a # as).\n     j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j\n\ngoal (1 subgoal):\n 1. \\<exists>j<length (a # as).\n       j < length (q # qs) \\<and>\n       (a # as) ! j \\<and> (q # qs) ! j \\<Longrightarrow>\n    \\<exists>j<length as.\n       j < length qs \\<and> (a # as) ! Suc j \\<and> (q # qs) ! Suc j", "then"], ["proof (chain)\npicking this:\n  \\<exists>j<length (a # as).\n     j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j", "obtain j where J: \"?Q j\""], ["proof (prove)\nusing this:\n  \\<exists>j<length (a # as).\n     j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        j < length (a # as) \\<and>\n        j < length (q # qs) \\<and>\n        (a # as) ! j \\<and> (q # qs) ! j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  j < length (a # as) \\<and>\n  j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j\n\ngoal (1 subgoal):\n 1. \\<exists>j<length (a # as).\n       j < length (q # qs) \\<and>\n       (a # as) ! j \\<and> (q # qs) ! j \\<Longrightarrow>\n    \\<exists>j<length as.\n       j < length qs \\<and> (a # as) ! Suc j \\<and> (q # qs) ! Suc j", "with False"], ["proof (chain)\npicking this:\n  \\<not> (a \\<and> q)\n  j < length (a # as) \\<and>\n  j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j", "obtain i where \"j = Suc i\""], ["proof (prove)\nusing this:\n  \\<not> (a \\<and> q)\n  j < length (a # as) \\<and>\n  j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j\n\ngoal (1 subgoal):\n 1. (\\<And>i. j = Suc i \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases j) simp+"], ["proof (state)\nthis:\n  j = Suc i\n\ngoal (1 subgoal):\n 1. \\<exists>j<length (a # as).\n       j < length (q # qs) \\<and>\n       (a # as) ! j \\<and> (q # qs) ! j \\<Longrightarrow>\n    \\<exists>j<length as.\n       j < length qs \\<and> (a # as) ! Suc j \\<and> (q # qs) ! Suc j", "with J"], ["proof (chain)\npicking this:\n  j < length (a # as) \\<and>\n  j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j\n  j = Suc i", "have \"?P i\""], ["proof (prove)\nusing this:\n  j < length (a # as) \\<and>\n  j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j\n  j = Suc i\n\ngoal (1 subgoal):\n 1. i < length as \\<and>\n    i < length qs \\<and> (a # as) ! Suc i \\<and> (q # qs) ! Suc i", "by simp"], ["proof (state)\nthis:\n  i < length as \\<and>\n  i < length qs \\<and> (a # as) ! Suc i \\<and> (q # qs) ! Suc i\n\ngoal (1 subgoal):\n 1. \\<exists>j<length (a # as).\n       j < length (q # qs) \\<and>\n       (a # as) ! j \\<and> (q # qs) ! j \\<Longrightarrow>\n    \\<exists>j<length as.\n       j < length qs \\<and> (a # as) ! Suc j \\<and> (q # qs) ! Suc j", "thus \"\\<exists>i. ?P i\""], ["proof (prove)\nusing this:\n  i < length as \\<and>\n  i < length qs \\<and> (a # as) ! Suc i \\<and> (q # qs) ! Suc i\n\ngoal (1 subgoal):\n 1. \\<exists>i<length as.\n       i < length qs \\<and> (a # as) ! Suc i \\<and> (q # qs) ! Suc i", "by (rule exI)"], ["proof (state)\nthis:\n  \\<exists>i<length as.\n     i < length qs \\<and> (a # as) ! Suc i \\<and> (q # qs) ! Suc i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>j<length as.\n      j < length qs \\<and> (a # as) ! Suc j \\<and> (q # qs) ! Suc j) =\n  (\\<exists>j<length (a # as).\n      j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>nfa_accepting' as qs =\n             (\\<exists>i<length as.\n                 i < length qs \\<and> as ! i \\<and> qs ! i);\n     a \\<and> q\\<rbrakk>\n    \\<Longrightarrow> nfa_accepting' (a # as) (q # qs) =\n                      (\\<exists>i<length (a # as).\n                          i < length (q # qs) \\<and>\n                          (a # as) ! i \\<and> (q # qs) ! i)\n 2. \\<lbrakk>nfa_accepting' as qs =\n             (\\<exists>i<length as.\n                 i < length qs \\<and> as ! i \\<and> qs ! i);\n     \\<not> (a \\<and> q)\\<rbrakk>\n    \\<Longrightarrow> nfa_accepting' (a # as) (q # qs) =\n                      (\\<exists>i<length (a # as).\n                          i < length (q # qs) \\<and>\n                          (a # as) ! i \\<and> (q # qs) ! i)", "also"], ["proof (state)\nthis:\n  (\\<exists>j<length as.\n      j < length qs \\<and> (a # as) ! Suc j \\<and> (q # qs) ! Suc j) =\n  (\\<exists>j<length (a # as).\n      j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>nfa_accepting' as qs =\n             (\\<exists>i<length as.\n                 i < length qs \\<and> as ! i \\<and> qs ! i);\n     a \\<and> q\\<rbrakk>\n    \\<Longrightarrow> nfa_accepting' (a # as) (q # qs) =\n                      (\\<exists>i<length (a # as).\n                          i < length (q # qs) \\<and>\n                          (a # as) ! i \\<and> (q # qs) ! i)\n 2. \\<lbrakk>nfa_accepting' as qs =\n             (\\<exists>i<length as.\n                 i < length qs \\<and> as ! i \\<and> qs ! i);\n     \\<not> (a \\<and> q)\\<rbrakk>\n    \\<Longrightarrow> nfa_accepting' (a # as) (q # qs) =\n                      (\\<exists>i<length (a # as).\n                          i < length (q # qs) \\<and>\n                          (a # as) ! i \\<and> (q # qs) ! i)", "from False"], ["proof (chain)\npicking this:\n  \\<not> (a \\<and> q)", "have \"\\<dots> = ((a\\<and>q \\<and> ?Q 0) \\<or> (\\<not> (a\\<and>q) \\<and> (\\<exists>j. ?Q j)))\""], ["proof (prove)\nusing this:\n  \\<not> (a \\<and> q)\n\ngoal (1 subgoal):\n 1. (\\<exists>j<length (a # as).\n        j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j) =\n    (a \\<and>\n     q \\<and>\n     0 < length (a # as) \\<and>\n     0 < length (q # qs) \\<and> (a # as) ! 0 \\<and> (q # qs) ! 0 \\<or>\n     \\<not> (a \\<and> q) \\<and>\n     (\\<exists>j<length (a # as).\n         j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j))", "by auto"], ["proof (state)\nthis:\n  (\\<exists>j<length (a # as).\n      j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j) =\n  (a \\<and>\n   q \\<and>\n   0 < length (a # as) \\<and>\n   0 < length (q # qs) \\<and> (a # as) ! 0 \\<and> (q # qs) ! 0 \\<or>\n   \\<not> (a \\<and> q) \\<and>\n   (\\<exists>j<length (a # as).\n       j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>nfa_accepting' as qs =\n             (\\<exists>i<length as.\n                 i < length qs \\<and> as ! i \\<and> qs ! i);\n     a \\<and> q\\<rbrakk>\n    \\<Longrightarrow> nfa_accepting' (a # as) (q # qs) =\n                      (\\<exists>i<length (a # as).\n                          i < length (q # qs) \\<and>\n                          (a # as) ! i \\<and> (q # qs) ! i)\n 2. \\<lbrakk>nfa_accepting' as qs =\n             (\\<exists>i<length as.\n                 i < length qs \\<and> as ! i \\<and> qs ! i);\n     \\<not> (a \\<and> q)\\<rbrakk>\n    \\<Longrightarrow> nfa_accepting' (a # as) (q # qs) =\n                      (\\<exists>i<length (a # as).\n                          i < length (q # qs) \\<and>\n                          (a # as) ! i \\<and> (q # qs) ! i)", "also"], ["proof (state)\nthis:\n  (\\<exists>j<length (a # as).\n      j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j) =\n  (a \\<and>\n   q \\<and>\n   0 < length (a # as) \\<and>\n   0 < length (q # qs) \\<and> (a # as) ! 0 \\<and> (q # qs) ! 0 \\<or>\n   \\<not> (a \\<and> q) \\<and>\n   (\\<exists>j<length (a # as).\n       j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>nfa_accepting' as qs =\n             (\\<exists>i<length as.\n                 i < length qs \\<and> as ! i \\<and> qs ! i);\n     a \\<and> q\\<rbrakk>\n    \\<Longrightarrow> nfa_accepting' (a # as) (q # qs) =\n                      (\\<exists>i<length (a # as).\n                          i < length (q # qs) \\<and>\n                          (a # as) ! i \\<and> (q # qs) ! i)\n 2. \\<lbrakk>nfa_accepting' as qs =\n             (\\<exists>i<length as.\n                 i < length qs \\<and> as ! i \\<and> qs ! i);\n     \\<not> (a \\<and> q)\\<rbrakk>\n    \\<Longrightarrow> nfa_accepting' (a # as) (q # qs) =\n                      (\\<exists>i<length (a # as).\n                          i < length (q # qs) \\<and>\n                          (a # as) ! i \\<and> (q # qs) ! i)", "have \"\\<dots> = ((a \\<and> q \\<and> (\\<exists>j. ?Q j)) \\<or> (\\<not>(a\\<and>q) \\<and> (\\<exists>j. ?Q j)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<and>\n     q \\<and>\n     0 < length (a # as) \\<and>\n     0 < length (q # qs) \\<and> (a # as) ! 0 \\<and> (q # qs) ! 0 \\<or>\n     \\<not> (a \\<and> q) \\<and>\n     (\\<exists>j<length (a # as).\n         j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j)) =\n    (a \\<and>\n     q \\<and>\n     (\\<exists>j<length (a # as).\n         j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j) \\<or>\n     \\<not> (a \\<and> q) \\<and>\n     (\\<exists>j<length (a # as).\n         j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j))", "by auto"], ["proof (state)\nthis:\n  (a \\<and>\n   q \\<and>\n   0 < length (a # as) \\<and>\n   0 < length (q # qs) \\<and> (a # as) ! 0 \\<and> (q # qs) ! 0 \\<or>\n   \\<not> (a \\<and> q) \\<and>\n   (\\<exists>j<length (a # as).\n       j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j)) =\n  (a \\<and>\n   q \\<and>\n   (\\<exists>j<length (a # as).\n       j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j) \\<or>\n   \\<not> (a \\<and> q) \\<and>\n   (\\<exists>j<length (a # as).\n       j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>nfa_accepting' as qs =\n             (\\<exists>i<length as.\n                 i < length qs \\<and> as ! i \\<and> qs ! i);\n     a \\<and> q\\<rbrakk>\n    \\<Longrightarrow> nfa_accepting' (a # as) (q # qs) =\n                      (\\<exists>i<length (a # as).\n                          i < length (q # qs) \\<and>\n                          (a # as) ! i \\<and> (q # qs) ! i)\n 2. \\<lbrakk>nfa_accepting' as qs =\n             (\\<exists>i<length as.\n                 i < length qs \\<and> as ! i \\<and> qs ! i);\n     \\<not> (a \\<and> q)\\<rbrakk>\n    \\<Longrightarrow> nfa_accepting' (a # as) (q # qs) =\n                      (\\<exists>i<length (a # as).\n                          i < length (q # qs) \\<and>\n                          (a # as) ! i \\<and> (q # qs) ! i)", "also"], ["proof (state)\nthis:\n  (a \\<and>\n   q \\<and>\n   0 < length (a # as) \\<and>\n   0 < length (q # qs) \\<and> (a # as) ! 0 \\<and> (q # qs) ! 0 \\<or>\n   \\<not> (a \\<and> q) \\<and>\n   (\\<exists>j<length (a # as).\n       j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j)) =\n  (a \\<and>\n   q \\<and>\n   (\\<exists>j<length (a # as).\n       j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j) \\<or>\n   \\<not> (a \\<and> q) \\<and>\n   (\\<exists>j<length (a # as).\n       j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>nfa_accepting' as qs =\n             (\\<exists>i<length as.\n                 i < length qs \\<and> as ! i \\<and> qs ! i);\n     a \\<and> q\\<rbrakk>\n    \\<Longrightarrow> nfa_accepting' (a # as) (q # qs) =\n                      (\\<exists>i<length (a # as).\n                          i < length (q # qs) \\<and>\n                          (a # as) ! i \\<and> (q # qs) ! i)\n 2. \\<lbrakk>nfa_accepting' as qs =\n             (\\<exists>i<length as.\n                 i < length qs \\<and> as ! i \\<and> qs ! i);\n     \\<not> (a \\<and> q)\\<rbrakk>\n    \\<Longrightarrow> nfa_accepting' (a # as) (q # qs) =\n                      (\\<exists>i<length (a # as).\n                          i < length (q # qs) \\<and>\n                          (a # as) ! i \\<and> (q # qs) ! i)", "have \"\\<dots> = (\\<exists>j. ?Q j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<and>\n     q \\<and>\n     (\\<exists>j<length (a # as).\n         j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j) \\<or>\n     \\<not> (a \\<and> q) \\<and>\n     (\\<exists>j<length (a # as).\n         j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j)) =\n    (\\<exists>j<length (a # as).\n        j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j)", "by auto"], ["proof (state)\nthis:\n  (a \\<and>\n   q \\<and>\n   (\\<exists>j<length (a # as).\n       j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j) \\<or>\n   \\<not> (a \\<and> q) \\<and>\n   (\\<exists>j<length (a # as).\n       j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j)) =\n  (\\<exists>j<length (a # as).\n      j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>nfa_accepting' as qs =\n             (\\<exists>i<length as.\n                 i < length qs \\<and> as ! i \\<and> qs ! i);\n     a \\<and> q\\<rbrakk>\n    \\<Longrightarrow> nfa_accepting' (a # as) (q # qs) =\n                      (\\<exists>i<length (a # as).\n                          i < length (q # qs) \\<and>\n                          (a # as) ! i \\<and> (q # qs) ! i)\n 2. \\<lbrakk>nfa_accepting' as qs =\n             (\\<exists>i<length as.\n                 i < length qs \\<and> as ! i \\<and> qs ! i);\n     \\<not> (a \\<and> q)\\<rbrakk>\n    \\<Longrightarrow> nfa_accepting' (a # as) (q # qs) =\n                      (\\<exists>i<length (a # as).\n                          i < length (q # qs) \\<and>\n                          (a # as) ! i \\<and> (q # qs) ! i)", "finally"], ["proof (chain)\npicking this:\n  nfa_accepting' as qs =\n  (\\<exists>j<length (a # as).\n      j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j)", "have \"?T = (\\<exists>j. ?Q j)\""], ["proof (prove)\nusing this:\n  nfa_accepting' as qs =\n  (\\<exists>j<length (a # as).\n      j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j)\n\ngoal (1 subgoal):\n 1. nfa_accepting' as qs =\n    (\\<exists>j<length (a # as).\n        j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j)", "."], ["proof (state)\nthis:\n  nfa_accepting' as qs =\n  (\\<exists>j<length (a # as).\n      j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>nfa_accepting' as qs =\n             (\\<exists>i<length as.\n                 i < length qs \\<and> as ! i \\<and> qs ! i);\n     a \\<and> q\\<rbrakk>\n    \\<Longrightarrow> nfa_accepting' (a # as) (q # qs) =\n                      (\\<exists>i<length (a # as).\n                          i < length (q # qs) \\<and>\n                          (a # as) ! i \\<and> (q # qs) ! i)\n 2. \\<lbrakk>nfa_accepting' as qs =\n             (\\<exists>i<length as.\n                 i < length qs \\<and> as ! i \\<and> qs ! i);\n     \\<not> (a \\<and> q)\\<rbrakk>\n    \\<Longrightarrow> nfa_accepting' (a # as) (q # qs) =\n                      (\\<exists>i<length (a # as).\n                          i < length (q # qs) \\<and>\n                          (a # as) ! i \\<and> (q # qs) ! i)", "with False"], ["proof (chain)\npicking this:\n  \\<not> (a \\<and> q)\n  nfa_accepting' as qs =\n  (\\<exists>j<length (a # as).\n      j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (a \\<and> q)\n  nfa_accepting' as qs =\n  (\\<exists>j<length (a # as).\n      j < length (q # qs) \\<and> (a # as) ! j \\<and> (q # qs) ! j)\n\ngoal (1 subgoal):\n 1. nfa_accepting' (a # as) (q # qs) =\n    (\\<exists>i<length (a # as).\n        i < length (q # qs) \\<and> (a # as) ! i \\<and> (q # qs) ! i)", "by auto"], ["proof (state)\nthis:\n  nfa_accepting' (a # as) (q # qs) =\n  (\\<exists>i<length (a # as).\n      i < length (q # qs) \\<and> (a # as) ! i \\<and> (q # qs) ! i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nfa_accepting' as qs =\n             (\\<exists>i<length as.\n                 i < length qs \\<and> as ! i \\<and> qs ! i);\n     a \\<and> q\\<rbrakk>\n    \\<Longrightarrow> nfa_accepting' (a # as) (q # qs) =\n                      (\\<exists>i<length (a # as).\n                          i < length (q # qs) \\<and>\n                          (a # as) ! i \\<and> (q # qs) ! i)", "qed (auto simp: 3)"], ["proof (state)\nthis:\n  nfa_accepting' (a # as) (q # qs) =\n  (\\<exists>i<length (a # as).\n      i < length (q # qs) \\<and> (a # as) ! i \\<and> (q # qs) ! i)\n\ngoal (2 subgoals):\n 1. \\<And>bs.\n       nfa_accepting' [] bs =\n       (\\<exists>i<length []. i < length bs \\<and> [] ! i \\<and> bs ! i)\n 2. \\<And>v va.\n       nfa_accepting' (v # va) [] =\n       (\\<exists>i<length (v # va).\n           i < length [] \\<and> (v # va) ! i \\<and> [] ! i)", "qed simp+"], ["proof (state)\nthis:\n  nfa_accepting' as q =\n  (\\<exists>i<length as. i < length q \\<and> as ! i \\<and> q ! i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nfa_accepting' ?as ?q =\n  (\\<exists>i<length ?as. i < length ?q \\<and> ?as ! i \\<and> ?q ! i)\n\ngoal (1 subgoal):\n 1. nfa_accepting' l r = (set_of_bv l \\<inter> set_of_bv r \\<noteq> {})", "hence \"nfa_accepting' l r = (\\<exists>i. i < length l \\<and> i < length r \\<and> l ! i \\<and> r ! i)\""], ["proof (prove)\nusing this:\n  nfa_accepting' ?as ?q =\n  (\\<exists>i<length ?as. i < length ?q \\<and> ?as ! i \\<and> ?q ! i)\n\ngoal (1 subgoal):\n 1. nfa_accepting' l r =\n    (\\<exists>i<length l. i < length r \\<and> l ! i \\<and> r ! i)", "by simp"], ["proof (state)\nthis:\n  nfa_accepting' l r =\n  (\\<exists>i<length l. i < length r \\<and> l ! i \\<and> r ! i)\n\ngoal (1 subgoal):\n 1. nfa_accepting' l r = (set_of_bv l \\<inter> set_of_bv r \\<noteq> {})", "also"], ["proof (state)\nthis:\n  nfa_accepting' l r =\n  (\\<exists>i<length l. i < length r \\<and> l ! i \\<and> r ! i)\n\ngoal (1 subgoal):\n 1. nfa_accepting' l r = (set_of_bv l \\<inter> set_of_bv r \\<noteq> {})", "have \"\\<dots> = (\\<exists>i. i \\<in> set_of_bv l \\<and> i \\<in> set_of_bv r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>i<length l. i < length r \\<and> l ! i \\<and> r ! i) =\n    (\\<exists>i. i \\<in> set_of_bv l \\<and> i \\<in> set_of_bv r)", "by (auto simp: set_of_bv_def)"], ["proof (state)\nthis:\n  (\\<exists>i<length l. i < length r \\<and> l ! i \\<and> r ! i) =\n  (\\<exists>i. i \\<in> set_of_bv l \\<and> i \\<in> set_of_bv r)\n\ngoal (1 subgoal):\n 1. nfa_accepting' l r = (set_of_bv l \\<inter> set_of_bv r \\<noteq> {})", "also"], ["proof (state)\nthis:\n  (\\<exists>i<length l. i < length r \\<and> l ! i \\<and> r ! i) =\n  (\\<exists>i. i \\<in> set_of_bv l \\<and> i \\<in> set_of_bv r)\n\ngoal (1 subgoal):\n 1. nfa_accepting' l r = (set_of_bv l \\<inter> set_of_bv r \\<noteq> {})", "have \"\\<dots> = (set_of_bv l \\<inter> set_of_bv r \\<noteq> {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>i. i \\<in> set_of_bv l \\<and> i \\<in> set_of_bv r) =\n    (set_of_bv l \\<inter> set_of_bv r \\<noteq> {})", "by auto"], ["proof (state)\nthis:\n  (\\<exists>i. i \\<in> set_of_bv l \\<and> i \\<in> set_of_bv r) =\n  (set_of_bv l \\<inter> set_of_bv r \\<noteq> {})\n\ngoal (1 subgoal):\n 1. nfa_accepting' l r = (set_of_bv l \\<inter> set_of_bv r \\<noteq> {})", "finally"], ["proof (chain)\npicking this:\n  nfa_accepting' l r = (set_of_bv l \\<inter> set_of_bv r \\<noteq> {})", "show ?thesis"], ["proof (prove)\nusing this:\n  nfa_accepting' l r = (set_of_bv l \\<inter> set_of_bv r \\<noteq> {})\n\ngoal (1 subgoal):\n 1. nfa_accepting' l r = (set_of_bv l \\<inter> set_of_bv r \\<noteq> {})", "."], ["proof (state)\nthis:\n  nfa_accepting' l r = (set_of_bv l \\<inter> set_of_bv r \\<noteq> {})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nfa_accepting_set_of_bv: \"nfa_accepting A q = (set_of_bv (snd A) \\<inter> set_of_bv q \\<noteq> {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfa_accepting A q = (set_of_bv (snd A) \\<inter> set_of_bv q \\<noteq> {})", "by (simp add: nfa_accepting'_set_of_bv nfa_accepting_def)"], ["", "definition\n  nfa_startnode :: \"nfa \\<Rightarrow> bool list\" where\n  \"nfa_startnode A = (replicate (length (fst A)) False)[0:=True]\""], ["", "locale aut_nfa =\n  fixes A n\n  assumes well_formed: \"wf_nfa A n\""], ["", "sublocale aut_nfa < Automaton \"nfa_trans A\" \"nfa_is_node A\" \"is_alph n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Automaton (nfa_trans A) (nfa_is_node A) (is_alph n)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q a.\n       \\<lbrakk>nfa_is_node A q; is_alph n a\\<rbrakk>\n       \\<Longrightarrow> nfa_is_node A (nfa_trans A q a)", "fix q a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q a.\n       \\<lbrakk>nfa_is_node A q; is_alph n a\\<rbrakk>\n       \\<Longrightarrow> nfa_is_node A (nfa_trans A q a)", "assume Q: \"nfa_is_node A q\" and A: \"is_alph n a\""], ["proof (state)\nthis:\n  nfa_is_node A q\n  is_alph n a\n\ngoal (1 subgoal):\n 1. \\<And>q a.\n       \\<lbrakk>nfa_is_node A q; is_alph n a\\<rbrakk>\n       \\<Longrightarrow> nfa_is_node A (nfa_trans A q a)", "with well_formed"], ["proof (chain)\npicking this:\n  wf_nfa A n\n  nfa_is_node A q\n  is_alph n a", "have \"bdd_all (nfa_is_node A) (subsetbdd (fst A) q (nfa_emptybdd (length q)))\""], ["proof (prove)\nusing this:\n  wf_nfa A n\n  nfa_is_node A q\n  is_alph n a\n\ngoal (1 subgoal):\n 1. bdd_all (nfa_is_node A) (subsetbdd (fst A) q (nfa_emptybdd (length q)))", "by (simp add: wf_nfa_def bdd_all_is_node_subsetbdd)"], ["proof (state)\nthis:\n  bdd_all (nfa_is_node A) (subsetbdd (fst A) q (nfa_emptybdd (length q)))\n\ngoal (1 subgoal):\n 1. \\<And>q a.\n       \\<lbrakk>nfa_is_node A q; is_alph n a\\<rbrakk>\n       \\<Longrightarrow> nfa_is_node A (nfa_trans A q a)", "moreover"], ["proof (state)\nthis:\n  bdd_all (nfa_is_node A) (subsetbdd (fst A) q (nfa_emptybdd (length q)))\n\ngoal (1 subgoal):\n 1. \\<And>q a.\n       \\<lbrakk>nfa_is_node A q; is_alph n a\\<rbrakk>\n       \\<Longrightarrow> nfa_is_node A (nfa_trans A q a)", "from well_formed Q"], ["proof (chain)\npicking this:\n  wf_nfa A n\n  nfa_is_node A q", "have \"bddh n (subsetbdd (fst A) q (nfa_emptybdd (length q)))\""], ["proof (prove)\nusing this:\n  wf_nfa A n\n  nfa_is_node A q\n\ngoal (1 subgoal):\n 1. bddh n (subsetbdd (fst A) q (nfa_emptybdd (length q)))", "by (simp add: wf_nfa_def nfa_emptybdd_def bddh_subsetbdd)"], ["proof (state)\nthis:\n  bddh n (subsetbdd (fst A) q (nfa_emptybdd (length q)))\n\ngoal (1 subgoal):\n 1. \\<And>q a.\n       \\<lbrakk>nfa_is_node A q; is_alph n a\\<rbrakk>\n       \\<Longrightarrow> nfa_is_node A (nfa_trans A q a)", "with A"], ["proof (chain)\npicking this:\n  is_alph n a\n  bddh n (subsetbdd (fst A) q (nfa_emptybdd (length q)))", "have \"bddh (length a) (subsetbdd (fst A) q (nfa_emptybdd (length q)))\""], ["proof (prove)\nusing this:\n  is_alph n a\n  bddh n (subsetbdd (fst A) q (nfa_emptybdd (length q)))\n\ngoal (1 subgoal):\n 1. bddh (length a) (subsetbdd (fst A) q (nfa_emptybdd (length q)))", "by (simp add: is_alph_def)"], ["proof (state)\nthis:\n  bddh (length a) (subsetbdd (fst A) q (nfa_emptybdd (length q)))\n\ngoal (1 subgoal):\n 1. \\<And>q a.\n       \\<lbrakk>nfa_is_node A q; is_alph n a\\<rbrakk>\n       \\<Longrightarrow> nfa_is_node A (nfa_trans A q a)", "ultimately"], ["proof (chain)\npicking this:\n  bdd_all (nfa_is_node A) (subsetbdd (fst A) q (nfa_emptybdd (length q)))\n  bddh (length a) (subsetbdd (fst A) q (nfa_emptybdd (length q)))", "have \"nfa_is_node A (bdd_lookup (subsetbdd (fst A) q (nfa_emptybdd (length q))) a)\""], ["proof (prove)\nusing this:\n  bdd_all (nfa_is_node A) (subsetbdd (fst A) q (nfa_emptybdd (length q)))\n  bddh (length a) (subsetbdd (fst A) q (nfa_emptybdd (length q)))\n\ngoal (1 subgoal):\n 1. nfa_is_node A\n     (bdd_lookup (subsetbdd (fst A) q (nfa_emptybdd (length q))) a)", "by (simp add: bdd_all_bdd_lookup)"], ["proof (state)\nthis:\n  nfa_is_node A\n   (bdd_lookup (subsetbdd (fst A) q (nfa_emptybdd (length q))) a)\n\ngoal (1 subgoal):\n 1. \\<And>q a.\n       \\<lbrakk>nfa_is_node A q; is_alph n a\\<rbrakk>\n       \\<Longrightarrow> nfa_is_node A (nfa_trans A q a)", "then"], ["proof (chain)\npicking this:\n  nfa_is_node A\n   (bdd_lookup (subsetbdd (fst A) q (nfa_emptybdd (length q))) a)", "show \"nfa_is_node A (nfa_trans A q a)\""], ["proof (prove)\nusing this:\n  nfa_is_node A\n   (bdd_lookup (subsetbdd (fst A) q (nfa_emptybdd (length q))) a)\n\ngoal (1 subgoal):\n 1. nfa_is_node A (nfa_trans A q a)", "by (simp add: nfa_trans_def)"], ["proof (state)\nthis:\n  nfa_is_node A (nfa_trans A q a)\n\ngoal:\nNo subgoals!", "qed"], ["", "context aut_nfa begin"], ["", "lemmas trans_is_node = trans_is_node"], ["", "lemmas steps_is_node = steps_is_node"], ["", "lemmas reach_is_node = reach_is_node"], ["", "end"], ["", "lemmas nfa_trans_is_node = aut_nfa.trans_is_node [OF aut_nfa.intro]"], ["", "lemmas nfa_steps_is_node = aut_nfa.steps_is_node [OF aut_nfa.intro]"], ["", "lemmas nfa_reach_is_node = aut_nfa.reach_is_node [OF aut_nfa.intro]"], ["", "abbreviation \"nfa_steps A \\<equiv> foldl (nfa_trans A)\""], ["", "abbreviation \"nfa_accepts A \\<equiv> accepts (nfa_trans A) (nfa_accepting A) (nfa_startnode A)\""], ["", "abbreviation \"nfa_reach A \\<equiv> reach (nfa_trans A)\""], ["", "lemma nfa_startnode_is_node: \"wf_nfa A n \\<Longrightarrow> nfa_is_node A (nfa_startnode A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_nfa A n \\<Longrightarrow> nfa_is_node A (nfa_startnode A)", "by (simp add: nfa_is_node_def wf_nfa_def nfa_startnode_def)"], ["", "section \\<open>Automata Constructions\\<close>"], ["", "subsection \\<open>Negation\\<close>"], ["", "definition\n  negate_dfa :: \"dfa \\<Rightarrow> dfa\" where\n  \"negate_dfa = (\\<lambda>(t,a). (t, map Not a))\""], ["", "lemma negate_wf_dfa: \"wf_dfa (negate_dfa A) l = wf_dfa A l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_dfa (negate_dfa A) l = wf_dfa A l", "by (simp add: negate_dfa_def wf_dfa_def dfa_is_node_def split_beta)"], ["", "lemma negate_negate_dfa: \"negate_dfa (negate_dfa A) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. negate_dfa (negate_dfa A) = A", "proof (induct A)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. negate_dfa (negate_dfa (a, b)) = (a, b)", "case (Pair t a)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>a b. negate_dfa (negate_dfa (a, b)) = (a, b)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. negate_dfa (negate_dfa (t, a)) = (t, a)", "by (induct a) (simp add: negate_dfa_def)+"], ["proof (state)\nthis:\n  negate_dfa (negate_dfa (t, a)) = (t, a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dfa_accepts_negate: \n  assumes \"wf_dfa A n\"\n  and \"list_all (is_alph n) bss\"\n  shows \"dfa_accepts (negate_dfa A) bss = (\\<not> dfa_accepts A bss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa_accepts (negate_dfa A) bss = (\\<not> dfa_accepts A bss)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dfa_accepts (negate_dfa A) bss = (\\<not> dfa_accepts A bss)", "have \"dfa_steps (negate_dfa A) 0 bss = dfa_steps A 0 bss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa_steps (negate_dfa A) 0 bss = dfa_steps A 0 bss", "by (simp add: negate_dfa_def dfa_trans_def [abs_def] split_beta)"], ["proof (state)\nthis:\n  dfa_steps (negate_dfa A) 0 bss = dfa_steps A 0 bss\n\ngoal (1 subgoal):\n 1. dfa_accepts (negate_dfa A) bss = (\\<not> dfa_accepts A bss)", "moreover"], ["proof (state)\nthis:\n  dfa_steps (negate_dfa A) 0 bss = dfa_steps A 0 bss\n\ngoal (1 subgoal):\n 1. dfa_accepts (negate_dfa A) bss = (\\<not> dfa_accepts A bss)", "from assms"], ["proof (chain)\npicking this:\n  wf_dfa A n\n  list_all (is_alph n) bss", "have \"dfa_is_node A (dfa_steps A 0 bss)\""], ["proof (prove)\nusing this:\n  wf_dfa A n\n  list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. dfa_is_node A (dfa_steps A 0 bss)", "by (simp add: dfa_steps_is_node dfa_startnode_is_node)"], ["proof (state)\nthis:\n  dfa_is_node A (dfa_steps A 0 bss)\n\ngoal (1 subgoal):\n 1. dfa_accepts (negate_dfa A) bss = (\\<not> dfa_accepts A bss)", "ultimately"], ["proof (chain)\npicking this:\n  dfa_steps (negate_dfa A) 0 bss = dfa_steps A 0 bss\n  dfa_is_node A (dfa_steps A 0 bss)", "show ?thesis"], ["proof (prove)\nusing this:\n  dfa_steps (negate_dfa A) 0 bss = dfa_steps A 0 bss\n  dfa_is_node A (dfa_steps A 0 bss)\n\ngoal (1 subgoal):\n 1. dfa_accepts (negate_dfa A) bss = (\\<not> dfa_accepts A bss)", "using assms"], ["proof (prove)\nusing this:\n  dfa_steps (negate_dfa A) 0 bss = dfa_steps A 0 bss\n  dfa_is_node A (dfa_steps A 0 bss)\n  wf_dfa A n\n  list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. dfa_accepts (negate_dfa A) bss = (\\<not> dfa_accepts A bss)", "by (simp add: accepts_def dfa_accepting_def wf_dfa_def dfa_is_node_def negate_dfa_def split_beta)"], ["proof (state)\nthis:\n  dfa_accepts (negate_dfa A) bss = (\\<not> dfa_accepts A bss)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Product Automaton\\<close>"], ["", "definition\n  prod_succs :: \"dfa \\<Rightarrow> dfa \\<Rightarrow> nat \\<times> nat \\<Rightarrow> (nat \\<times> nat) list\" where\n  \"prod_succs A B = (\\<lambda>(i, j). add_leaves (bdd_binop Pair (fst A ! i) (fst B ! j)) [])\""], ["", "definition\n  \"prod_is_node A B = (\\<lambda>(i, j). dfa_is_node A i \\<and> dfa_is_node B j)\""], ["", "definition\n  prod_invariant :: \"dfa \\<Rightarrow> dfa \\<Rightarrow> nat option list list \\<times> (nat \\<times> nat) list \\<Rightarrow> bool\" where\n  \"prod_invariant A B = (\\<lambda>(tab, ps).\n     length tab = length (fst A) \\<and> (\\<forall>tab'\\<in>set tab. length tab' = length (fst B)))\""], ["", "definition\n  \"prod_ins = (\\<lambda>(i, j). \\<lambda>(tab, ps).\n     (tab[i := (tab ! i)[j := Some (length ps)]],\n      ps @ [(i, j)]))\""], ["", "definition\n  prod_memb :: \"nat \\<times> nat \\<Rightarrow> nat option list list \\<times> (nat \\<times> nat) list \\<Rightarrow> bool\" where\n  \"prod_memb = (\\<lambda>(i, j). \\<lambda>(tab, ps). tab ! i ! j \\<noteq> None)\""], ["", "definition\n  prod_empt :: \"dfa \\<Rightarrow> dfa \\<Rightarrow> nat option list list \\<times> (nat \\<times> nat) list\" where\n  \"prod_empt A B = (replicate (length (fst A)) (replicate (length (fst B)) None), [])\""], ["", "definition\n  prod_dfs :: \"dfa \\<Rightarrow> dfa \\<Rightarrow> nat \\<times> nat \\<Rightarrow> nat option list list \\<times> (nat \\<times> nat) list\" where\n  \"prod_dfs A B x = gen_dfs (prod_succs A B) prod_ins prod_memb (prod_empt A B) [x]\""], ["", "definition\n  binop_dfa :: \"(bool \\<Rightarrow> bool \\<Rightarrow> bool) \\<Rightarrow> dfa \\<Rightarrow> dfa \\<Rightarrow> dfa\" where\n  \"binop_dfa f A B =\n    (let (tab, ps) = prod_dfs A B (0, 0)\n     in\n       (map (\\<lambda>(i, j). bdd_binop (\\<lambda>k l. the (tab ! k ! l)) (fst A ! i) (fst B ! j)) ps,\n        map (\\<lambda>(i, j). f (snd A ! i) (snd B ! j)) ps))\""], ["", "locale prod_DFS =\n  fixes A B n\n  assumes well_formed1: \"wf_dfa A n\"\n  and well_formed2: \"wf_dfa B n\""], ["", "sublocale prod_DFS < DFS \"prod_succs A B\" \"prod_is_node A B\" \"prod_invariant A B\" prod_ins prod_memb \"prod_empt A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DFS (prod_succs A B) (prod_is_node A B) (prod_invariant A B) prod_ins\n     prod_memb (prod_empt A B)", "apply unfold_locales"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x y S.\n       \\<lbrakk>prod_is_node A B x; prod_is_node A B y;\n        prod_invariant A B S; \\<not> prod_memb y S\\<rbrakk>\n       \\<Longrightarrow> prod_memb x (prod_ins y S) =\n                         (x = y \\<or> prod_memb x S)\n 2. \\<And>x.\n       prod_is_node A B x \\<Longrightarrow>\n       \\<not> prod_memb x (prod_empt A B)\n 3. \\<And>x.\n       prod_is_node A B x \\<Longrightarrow>\n       list_all (prod_is_node A B) (prod_succs A B x)\n 4. prod_invariant A B (prod_empt A B)\n 5. \\<And>x S.\n       \\<lbrakk>prod_is_node A B x; prod_invariant A B S;\n        \\<not> prod_memb x S\\<rbrakk>\n       \\<Longrightarrow> prod_invariant A B (prod_ins x S)\n 6. finite {x. prod_is_node A B x}", "apply (simp add: prod_memb_def prod_ins_def prod_invariant_def\n    prod_is_node_def split_paired_all dfa_is_node_def)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a < length (fst A) \\<and> b < length (fst B);\n        aa < length (fst A) \\<and> ba < length (fst B);\n        length ab = length (fst A) \\<and>\n        (\\<forall>tab'\\<in>set ab. length tab' = length (fst B));\n        ab ! aa ! ba = None\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y.\n                             ab[aa := (ab ! aa)[ba := Some (length bb)]] !\n                             a !\n                             b =\n                             Some y) =\n                         (a = aa \\<and> b = ba \\<or>\n                          (\\<exists>y. ab ! a ! b = Some y))\n 2. \\<And>x.\n       prod_is_node A B x \\<Longrightarrow>\n       \\<not> prod_memb x (prod_empt A B)\n 3. \\<And>x.\n       prod_is_node A B x \\<Longrightarrow>\n       list_all (prod_is_node A B) (prod_succs A B x)\n 4. prod_invariant A B (prod_empt A B)\n 5. \\<And>x S.\n       \\<lbrakk>prod_is_node A B x; prod_invariant A B S;\n        \\<not> prod_memb x S\\<rbrakk>\n       \\<Longrightarrow> prod_invariant A B (prod_ins x S)\n 6. finite {x. prod_is_node A B x}", "apply (case_tac \"a = aa\")"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a < length (fst A) \\<and> b < length (fst B);\n        aa < length (fst A) \\<and> ba < length (fst B);\n        length ab = length (fst A) \\<and>\n        (\\<forall>tab'\\<in>set ab. length tab' = length (fst B));\n        ab ! aa ! ba = None; a = aa\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y.\n                             ab[aa := (ab ! aa)[ba := Some (length bb)]] !\n                             a !\n                             b =\n                             Some y) =\n                         (a = aa \\<and> b = ba \\<or>\n                          (\\<exists>y. ab ! a ! b = Some y))\n 2. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a < length (fst A) \\<and> b < length (fst B);\n        aa < length (fst A) \\<and> ba < length (fst B);\n        length ab = length (fst A) \\<and>\n        (\\<forall>tab'\\<in>set ab. length tab' = length (fst B));\n        ab ! aa ! ba = None; a \\<noteq> aa\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y.\n                             ab[aa := (ab ! aa)[ba := Some (length bb)]] !\n                             a !\n                             b =\n                             Some y) =\n                         (a = aa \\<and> b = ba \\<or>\n                          (\\<exists>y. ab ! a ! b = Some y))\n 3. \\<And>x.\n       prod_is_node A B x \\<Longrightarrow>\n       \\<not> prod_memb x (prod_empt A B)\n 4. \\<And>x.\n       prod_is_node A B x \\<Longrightarrow>\n       list_all (prod_is_node A B) (prod_succs A B x)\n 5. prod_invariant A B (prod_empt A B)\n 6. \\<And>x S.\n       \\<lbrakk>prod_is_node A B x; prod_invariant A B S;\n        \\<not> prod_memb x S\\<rbrakk>\n       \\<Longrightarrow> prod_invariant A B (prod_ins x S)\n 7. finite {x. prod_is_node A B x}", "apply (case_tac \"b = ba\")"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a < length (fst A) \\<and> b < length (fst B);\n        aa < length (fst A) \\<and> ba < length (fst B);\n        length ab = length (fst A) \\<and>\n        (\\<forall>tab'\\<in>set ab. length tab' = length (fst B));\n        ab ! aa ! ba = None; a = aa; b = ba\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y.\n                             ab[aa := (ab ! aa)[ba := Some (length bb)]] !\n                             a !\n                             b =\n                             Some y) =\n                         (a = aa \\<and> b = ba \\<or>\n                          (\\<exists>y. ab ! a ! b = Some y))\n 2. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a < length (fst A) \\<and> b < length (fst B);\n        aa < length (fst A) \\<and> ba < length (fst B);\n        length ab = length (fst A) \\<and>\n        (\\<forall>tab'\\<in>set ab. length tab' = length (fst B));\n        ab ! aa ! ba = None; a = aa; b \\<noteq> ba\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y.\n                             ab[aa := (ab ! aa)[ba := Some (length bb)]] !\n                             a !\n                             b =\n                             Some y) =\n                         (a = aa \\<and> b = ba \\<or>\n                          (\\<exists>y. ab ! a ! b = Some y))\n 3. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a < length (fst A) \\<and> b < length (fst B);\n        aa < length (fst A) \\<and> ba < length (fst B);\n        length ab = length (fst A) \\<and>\n        (\\<forall>tab'\\<in>set ab. length tab' = length (fst B));\n        ab ! aa ! ba = None; a \\<noteq> aa\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y.\n                             ab[aa := (ab ! aa)[ba := Some (length bb)]] !\n                             a !\n                             b =\n                             Some y) =\n                         (a = aa \\<and> b = ba \\<or>\n                          (\\<exists>y. ab ! a ! b = Some y))\n 4. \\<And>x.\n       prod_is_node A B x \\<Longrightarrow>\n       \\<not> prod_memb x (prod_empt A B)\n 5. \\<And>x.\n       prod_is_node A B x \\<Longrightarrow>\n       list_all (prod_is_node A B) (prod_succs A B x)\n 6. prod_invariant A B (prod_empt A B)\n 7. \\<And>x S.\n       \\<lbrakk>prod_is_node A B x; prod_invariant A B S;\n        \\<not> prod_memb x S\\<rbrakk>\n       \\<Longrightarrow> prod_invariant A B (prod_ins x S)\n 8. finite {x. prod_is_node A B x}", "apply auto[3]"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       prod_is_node A B x \\<Longrightarrow>\n       \\<not> prod_memb x (prod_empt A B)\n 2. \\<And>x.\n       prod_is_node A B x \\<Longrightarrow>\n       list_all (prod_is_node A B) (prod_succs A B x)\n 3. prod_invariant A B (prod_empt A B)\n 4. \\<And>x S.\n       \\<lbrakk>prod_is_node A B x; prod_invariant A B S;\n        \\<not> prod_memb x S\\<rbrakk>\n       \\<Longrightarrow> prod_invariant A B (prod_ins x S)\n 5. finite {x. prod_is_node A B x}", "apply (simp add: prod_memb_def prod_empt_def prod_is_node_def split_paired_all dfa_is_node_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       prod_is_node A B x \\<Longrightarrow>\n       list_all (prod_is_node A B) (prod_succs A B x)\n 2. prod_invariant A B (prod_empt A B)\n 3. \\<And>x S.\n       \\<lbrakk>prod_is_node A B x; prod_invariant A B S;\n        \\<not> prod_memb x S\\<rbrakk>\n       \\<Longrightarrow> prod_invariant A B (prod_ins x S)\n 4. finite {x. prod_is_node A B x}", "apply (insert well_formed1 well_formed2)[]"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>prod_is_node A B x; wf_dfa A n; wf_dfa B n\\<rbrakk>\n       \\<Longrightarrow> list_all (prod_is_node A B) (prod_succs A B x)\n 2. prod_invariant A B (prod_empt A B)\n 3. \\<And>x S.\n       \\<lbrakk>prod_is_node A B x; prod_invariant A B S;\n        \\<not> prod_memb x S\\<rbrakk>\n       \\<Longrightarrow> prod_invariant A B (prod_ins x S)\n 4. finite {x. prod_is_node A B x}", "apply (simp add: prod_is_node_def prod_succs_def split_paired_all dfa_is_node_def wf_dfa_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>a < length (fst A) \\<and> b < length (fst B);\n        list_all (bddh n) (fst A) \\<and>\n        list_all (bdd_all (\\<lambda>q. q < length (fst A))) (fst A) \\<and>\n        length (snd A) = length (fst A) \\<and> fst A \\<noteq> [];\n        list_all (bddh n) (fst B) \\<and>\n        list_all (bdd_all (\\<lambda>q. q < length (fst B))) (fst B) \\<and>\n        length (snd B) = length (fst B) \\<and> fst B \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(i, j).\n                              i < length (fst A) \\<and> j < length (fst B))\n                          (add_leaves\n                            (bdd_binop Pair (fst A ! a) (fst B ! b)) [])\n 2. prod_invariant A B (prod_empt A B)\n 3. \\<And>x S.\n       \\<lbrakk>prod_is_node A B x; prod_invariant A B S;\n        \\<not> prod_memb x S\\<rbrakk>\n       \\<Longrightarrow> prod_invariant A B (prod_ins x S)\n 4. finite {x. prod_is_node A B x}", "apply (drule conjunct1 [OF conjunct2])+"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>a < length (fst A) \\<and> b < length (fst B);\n        list_all (bdd_all (\\<lambda>q. q < length (fst A))) (fst A);\n        list_all (bdd_all (\\<lambda>q. q < length (fst B))) (fst B)\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(i, j).\n                              i < length (fst A) \\<and> j < length (fst B))\n                          (add_leaves\n                            (bdd_binop Pair (fst A ! a) (fst B ! b)) [])\n 2. prod_invariant A B (prod_empt A B)\n 3. \\<And>x S.\n       \\<lbrakk>prod_is_node A B x; prod_invariant A B S;\n        \\<not> prod_memb x S\\<rbrakk>\n       \\<Longrightarrow> prod_invariant A B (prod_ins x S)\n 4. finite {x. prod_is_node A B x}", "apply (simp add: list_all_iff)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>a < length (fst A) \\<and> b < length (fst B);\n        \\<forall>x\\<in>set (fst A).\n           bdd_all (\\<lambda>q. q < length (fst A)) x;\n        \\<forall>x\\<in>set (fst B).\n           bdd_all (\\<lambda>q. q < length (fst B)) x\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set\n   (add_leaves (bdd_binop Pair (fst A ! a) (fst B ! b)) []).\n                            case x of\n                            (i, j) \\<Rightarrow>\n                              i < length (fst A) \\<and> j < length (fst B)\n 2. prod_invariant A B (prod_empt A B)\n 3. \\<And>x S.\n       \\<lbrakk>prod_is_node A B x; prod_invariant A B S;\n        \\<not> prod_memb x S\\<rbrakk>\n       \\<Longrightarrow> prod_invariant A B (prod_ins x S)\n 4. finite {x. prod_is_node A B x}", "apply (rule ballI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>a < length (fst A) \\<and> b < length (fst B);\n        \\<forall>x\\<in>set (fst A).\n           bdd_all (\\<lambda>q. q < length (fst A)) x;\n        \\<forall>x\\<in>set (fst B).\n           bdd_all (\\<lambda>q. q < length (fst B)) x;\n        x \\<in> set (add_leaves (bdd_binop Pair (fst A ! a) (fst B ! b))\n                      [])\\<rbrakk>\n       \\<Longrightarrow> case x of\n                         (i, j) \\<Rightarrow>\n                           i < length (fst A) \\<and> j < length (fst B)\n 2. prod_invariant A B (prod_empt A B)\n 3. \\<And>x S.\n       \\<lbrakk>prod_is_node A B x; prod_invariant A B S;\n        \\<not> prod_memb x S\\<rbrakk>\n       \\<Longrightarrow> prod_invariant A B (prod_ins x S)\n 4. finite {x. prod_is_node A B x}", "apply (simp add: split_paired_all)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>a < length (fst A) \\<and> b < length (fst B);\n        \\<forall>x\\<in>set (fst A).\n           bdd_all (\\<lambda>q. q < length (fst A)) x;\n        \\<forall>x\\<in>set (fst B).\n           bdd_all (\\<lambda>q. q < length (fst B)) x;\n        (aa, ba)\n        \\<in> set (add_leaves (bdd_binop Pair (fst A ! a) (fst B ! b))\n                    [])\\<rbrakk>\n       \\<Longrightarrow> aa < length (fst A) \\<and> ba < length (fst B)\n 2. prod_invariant A B (prod_empt A B)\n 3. \\<And>x S.\n       \\<lbrakk>prod_is_node A B x; prod_invariant A B S;\n        \\<not> prod_memb x S\\<rbrakk>\n       \\<Longrightarrow> prod_invariant A B (prod_ins x S)\n 4. finite {x. prod_is_node A B x}", "apply (drule subsetD [OF add_leaves_binop_subset [where xs=\"[]\" and ys=\"[]\", simplified]])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>a < length (fst A) \\<and> b < length (fst B);\n        \\<forall>x\\<in>set (fst A).\n           bdd_all (\\<lambda>q. q < length (fst A)) x;\n        \\<forall>x\\<in>set (fst B).\n           bdd_all (\\<lambda>q. q < length (fst B)) x;\n        (aa, ba)\n        \\<in> (\\<Union>x\\<in>set (add_leaves (fst A ! a) []).\n                  \\<Union>y\\<in>set (add_leaves (fst B ! b) []).\n                     {(x, y)})\\<rbrakk>\n       \\<Longrightarrow> aa < length (fst A) \\<and> ba < length (fst B)\n 2. prod_invariant A B (prod_empt A B)\n 3. \\<And>x S.\n       \\<lbrakk>prod_is_node A B x; prod_invariant A B S;\n        \\<not> prod_memb x S\\<rbrakk>\n       \\<Longrightarrow> prod_invariant A B (prod_ins x S)\n 4. finite {x. prod_is_node A B x}", "apply clarify"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa ba x y.\n       \\<lbrakk>\\<forall>x\\<in>set (fst A).\n                   bdd_all (\\<lambda>q. q < length (fst A)) x;\n        \\<forall>x\\<in>set (fst B).\n           bdd_all (\\<lambda>q. q < length (fst B)) x;\n        x \\<in> set (add_leaves (fst A ! a) []);\n        y \\<in> set (add_leaves (fst B ! b) []); a < length (fst A);\n        b < length (fst B)\\<rbrakk>\n       \\<Longrightarrow> x < length (fst A) \\<and> y < length (fst B)\n 2. prod_invariant A B (prod_empt A B)\n 3. \\<And>x S.\n       \\<lbrakk>prod_is_node A B x; prod_invariant A B S;\n        \\<not> prod_memb x S\\<rbrakk>\n       \\<Longrightarrow> prod_invariant A B (prod_ins x S)\n 4. finite {x. prod_is_node A B x}", "apply (drule_tac x=\"fst A ! a\" in bspec)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b aa ba x y.\n       \\<lbrakk>\\<forall>x\\<in>set (fst B).\n                   bdd_all (\\<lambda>q. q < length (fst B)) x;\n        x \\<in> set (add_leaves (fst A ! a) []);\n        y \\<in> set (add_leaves (fst B ! b) []); a < length (fst A);\n        b < length (fst B)\\<rbrakk>\n       \\<Longrightarrow> fst A ! a \\<in> set (fst A)\n 2. \\<And>a b aa ba x y.\n       \\<lbrakk>\\<forall>x\\<in>set (fst B).\n                   bdd_all (\\<lambda>q. q < length (fst B)) x;\n        x \\<in> set (add_leaves (fst A ! a) []);\n        y \\<in> set (add_leaves (fst B ! b) []); a < length (fst A);\n        b < length (fst B);\n        bdd_all (\\<lambda>q. q < length (fst A)) (fst A ! a)\\<rbrakk>\n       \\<Longrightarrow> x < length (fst A) \\<and> y < length (fst B)\n 3. prod_invariant A B (prod_empt A B)\n 4. \\<And>x S.\n       \\<lbrakk>prod_is_node A B x; prod_invariant A B S;\n        \\<not> prod_memb x S\\<rbrakk>\n       \\<Longrightarrow> prod_invariant A B (prod_ins x S)\n 5. finite {x. prod_is_node A B x}", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa ba x y.\n       \\<lbrakk>\\<forall>x\\<in>set (fst B).\n                   bdd_all (\\<lambda>q. q < length (fst B)) x;\n        x \\<in> set (add_leaves (fst A ! a) []);\n        y \\<in> set (add_leaves (fst B ! b) []); a < length (fst A);\n        b < length (fst B);\n        bdd_all (\\<lambda>q. q < length (fst A)) (fst A ! a)\\<rbrakk>\n       \\<Longrightarrow> x < length (fst A) \\<and> y < length (fst B)\n 2. prod_invariant A B (prod_empt A B)\n 3. \\<And>x S.\n       \\<lbrakk>prod_is_node A B x; prod_invariant A B S;\n        \\<not> prod_memb x S\\<rbrakk>\n       \\<Longrightarrow> prod_invariant A B (prod_ins x S)\n 4. finite {x. prod_is_node A B x}", "apply (drule_tac x=\"fst B ! b\" in bspec)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b aa ba x y.\n       \\<lbrakk>x \\<in> set (add_leaves (fst A ! a) []);\n        y \\<in> set (add_leaves (fst B ! b) []); a < length (fst A);\n        b < length (fst B);\n        bdd_all (\\<lambda>q. q < length (fst A)) (fst A ! a)\\<rbrakk>\n       \\<Longrightarrow> fst B ! b \\<in> set (fst B)\n 2. \\<And>a b aa ba x y.\n       \\<lbrakk>x \\<in> set (add_leaves (fst A ! a) []);\n        y \\<in> set (add_leaves (fst B ! b) []); a < length (fst A);\n        b < length (fst B);\n        bdd_all (\\<lambda>q. q < length (fst A)) (fst A ! a);\n        bdd_all (\\<lambda>q. q < length (fst B)) (fst B ! b)\\<rbrakk>\n       \\<Longrightarrow> x < length (fst A) \\<and> y < length (fst B)\n 3. prod_invariant A B (prod_empt A B)\n 4. \\<And>x S.\n       \\<lbrakk>prod_is_node A B x; prod_invariant A B S;\n        \\<not> prod_memb x S\\<rbrakk>\n       \\<Longrightarrow> prod_invariant A B (prod_ins x S)\n 5. finite {x. prod_is_node A B x}", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa ba x y.\n       \\<lbrakk>x \\<in> set (add_leaves (fst A ! a) []);\n        y \\<in> set (add_leaves (fst B ! b) []); a < length (fst A);\n        b < length (fst B);\n        bdd_all (\\<lambda>q. q < length (fst A)) (fst A ! a);\n        bdd_all (\\<lambda>q. q < length (fst B)) (fst B ! b)\\<rbrakk>\n       \\<Longrightarrow> x < length (fst A) \\<and> y < length (fst B)\n 2. prod_invariant A B (prod_empt A B)\n 3. \\<And>x S.\n       \\<lbrakk>prod_is_node A B x; prod_invariant A B S;\n        \\<not> prod_memb x S\\<rbrakk>\n       \\<Longrightarrow> prod_invariant A B (prod_ins x S)\n 4. finite {x. prod_is_node A B x}", "apply (simp add: add_leaves_bdd_all_eq' list_all_iff)"], ["proof (prove)\ngoal (3 subgoals):\n 1. prod_invariant A B (prod_empt A B)\n 2. \\<And>x S.\n       \\<lbrakk>prod_is_node A B x; prod_invariant A B S;\n        \\<not> prod_memb x S\\<rbrakk>\n       \\<Longrightarrow> prod_invariant A B (prod_ins x S)\n 3. finite {x. prod_is_node A B x}", "apply (simp add: prod_invariant_def prod_empt_def set_replicate_conv_if)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x S.\n       \\<lbrakk>prod_is_node A B x; prod_invariant A B S;\n        \\<not> prod_memb x S\\<rbrakk>\n       \\<Longrightarrow> prod_invariant A B (prod_ins x S)\n 2. finite {x. prod_is_node A B x}", "apply (simp add: prod_is_node_def prod_invariant_def\n    prod_memb_def prod_ins_def split_paired_all dfa_is_node_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>a < length (fst A) \\<and> b < length (fst B);\n        length aa = length (fst A) \\<and>\n        (\\<forall>tab'\\<in>set aa. length tab' = length (fst B));\n        aa ! a ! b = None\\<rbrakk>\n       \\<Longrightarrow> \\<forall>tab'\n                                  \\<in>set\n  (aa[a := (aa ! a)[b := Some (length ba)]]).\n                            length tab' = length (fst B)\n 2. finite {x. prod_is_node A B x}", "apply (rule ballI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba tab'.\n       \\<lbrakk>a < length (fst A) \\<and> b < length (fst B);\n        length aa = length (fst A) \\<and>\n        (\\<forall>tab'\\<in>set aa. length tab' = length (fst B));\n        aa ! a ! b = None;\n        tab' \\<in> set (aa[a := (aa ! a)[b := Some (length ba)]])\\<rbrakk>\n       \\<Longrightarrow> length tab' = length (fst B)\n 2. finite {x. prod_is_node A B x}", "apply (drule subsetD [OF set_update_subset_insert])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba tab'.\n       \\<lbrakk>a < length (fst A) \\<and> b < length (fst B);\n        length aa = length (fst A) \\<and>\n        (\\<forall>tab'\\<in>set aa. length tab' = length (fst B));\n        aa ! a ! b = None;\n        tab'\n        \\<in> insert ((aa ! a)[b := Some (length ba)]) (set aa)\\<rbrakk>\n       \\<Longrightarrow> length tab' = length (fst B)\n 2. finite {x. prod_is_node A B x}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. prod_is_node A B x}", "apply (simp add: prod_is_node_def dfa_is_node_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context prod_DFS\nbegin"], ["", "lemma prod_dfs_eq_rtrancl: \"prod_is_node A B x \\<Longrightarrow> prod_is_node A B y \\<Longrightarrow>\n  prod_memb y (prod_dfs A B x) = ((x, y) \\<in> (succsr (prod_succs A B))\\<^sup>*)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prod_is_node A B x; prod_is_node A B y\\<rbrakk>\n    \\<Longrightarrow> prod_memb y (prod_dfs A B x) =\n                      ((x, y) \\<in> (succsr (prod_succs A B))\\<^sup>*)", "by (unfold prod_dfs_def) (rule dfs_eq_rtrancl)"], ["", "lemma prod_dfs_bij:\n  assumes x: \"prod_is_node A B x\"\n  shows \"(fst (prod_dfs A B x) ! i ! j = Some k \\<and> dfa_is_node A i \\<and> dfa_is_node B j) =\n    (k < length (snd (prod_dfs A B x)) \\<and> (snd (prod_dfs A B x) ! k = (i, j)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst (prod_dfs A B x) ! i ! j = Some k \\<and>\n     dfa_is_node A i \\<and> dfa_is_node B j) =\n    (k < length (snd (prod_dfs A B x)) \\<and>\n     snd (prod_dfs A B x) ! k = (i, j))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (fst (prod_dfs A B x) ! i ! j = Some k \\<and>\n     dfa_is_node A i \\<and> dfa_is_node B j) =\n    (k < length (snd (prod_dfs A B x)) \\<and>\n     snd (prod_dfs A B x) ! k = (i, j))", "from x"], ["proof (chain)\npicking this:\n  prod_is_node A B x", "have \"list_all (prod_is_node A B) [x]\""], ["proof (prove)\nusing this:\n  prod_is_node A B x\n\ngoal (1 subgoal):\n 1. list_all (prod_is_node A B) [x]", "by simp"], ["proof (state)\nthis:\n  list_all (prod_is_node A B) [x]\n\ngoal (1 subgoal):\n 1. (fst (prod_dfs A B x) ! i ! j = Some k \\<and>\n     dfa_is_node A i \\<and> dfa_is_node B j) =\n    (k < length (snd (prod_dfs A B x)) \\<and>\n     snd (prod_dfs A B x) ! k = (i, j))", "with empt_invariant"], ["proof (chain)\npicking this:\n  prod_invariant A B (prod_empt A B)\n  list_all (prod_is_node A B) [x]", "have \"(fst (dfs (prod_empt A B) [x]) ! i ! j = Some k \\<and> dfa_is_node A i \\<and> dfa_is_node B j) =\n    (k < length (snd (dfs (prod_empt A B) [x])) \\<and> (snd (dfs (prod_empt A B) [x]) ! k = (i, j)))\""], ["proof (prove)\nusing this:\n  prod_invariant A B (prod_empt A B)\n  list_all (prod_is_node A B) [x]\n\ngoal (1 subgoal):\n 1. (fst (dfs (prod_empt A B) [x]) ! i ! j = Some k \\<and>\n     dfa_is_node A i \\<and> dfa_is_node B j) =\n    (k < length (snd (dfs (prod_empt A B) [x])) \\<and>\n     snd (dfs (prod_empt A B) [x]) ! k = (i, j))", "proof (induct rule: dfs_invariant)"], ["proof (state)\ngoal (2 subgoals):\n 1. (fst (prod_empt A B) ! i ! j = Some k \\<and>\n     dfa_is_node A i \\<and> dfa_is_node B j) =\n    (k < length (snd (prod_empt A B)) \\<and>\n     snd (prod_empt A B) ! k = (i, j))\n 2. \\<And>S x.\n       \\<lbrakk>\\<not> prod_memb x S; prod_is_node A B x;\n        prod_invariant A B S;\n        (fst S ! i ! j = Some k \\<and>\n         dfa_is_node A i \\<and> dfa_is_node B j) =\n        (k < length (snd S) \\<and> snd S ! k = (i, j))\\<rbrakk>\n       \\<Longrightarrow> (fst (prod_ins x S) ! i ! j = Some k \\<and>\n                          dfa_is_node A i \\<and> dfa_is_node B j) =\n                         (k < length (snd (prod_ins x S)) \\<and>\n                          snd (prod_ins x S) ! k = (i, j))", "case base"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (fst (prod_empt A B) ! i ! j = Some k \\<and>\n     dfa_is_node A i \\<and> dfa_is_node B j) =\n    (k < length (snd (prod_empt A B)) \\<and>\n     snd (prod_empt A B) ! k = (i, j))\n 2. \\<And>S x.\n       \\<lbrakk>\\<not> prod_memb x S; prod_is_node A B x;\n        prod_invariant A B S;\n        (fst S ! i ! j = Some k \\<and>\n         dfa_is_node A i \\<and> dfa_is_node B j) =\n        (k < length (snd S) \\<and> snd S ! k = (i, j))\\<rbrakk>\n       \\<Longrightarrow> (fst (prod_ins x S) ! i ! j = Some k \\<and>\n                          dfa_is_node A i \\<and> dfa_is_node B j) =\n                         (k < length (snd (prod_ins x S)) \\<and>\n                          snd (prod_ins x S) ! k = (i, j))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst (prod_empt A B) ! i ! j = Some k \\<and>\n     dfa_is_node A i \\<and> dfa_is_node B j) =\n    (k < length (snd (prod_empt A B)) \\<and>\n     snd (prod_empt A B) ! k = (i, j))", "by (auto simp add: prod_empt_def dfa_is_node_def)"], ["proof (state)\nthis:\n  (fst (prod_empt A B) ! i ! j = Some k \\<and>\n   dfa_is_node A i \\<and> dfa_is_node B j) =\n  (k < length (snd (prod_empt A B)) \\<and> snd (prod_empt A B) ! k = (i, j))\n\ngoal (1 subgoal):\n 1. \\<And>S x.\n       \\<lbrakk>\\<not> prod_memb x S; prod_is_node A B x;\n        prod_invariant A B S;\n        (fst S ! i ! j = Some k \\<and>\n         dfa_is_node A i \\<and> dfa_is_node B j) =\n        (k < length (snd S) \\<and> snd S ! k = (i, j))\\<rbrakk>\n       \\<Longrightarrow> (fst (prod_ins x S) ! i ! j = Some k \\<and>\n                          dfa_is_node A i \\<and> dfa_is_node B j) =\n                         (k < length (snd (prod_ins x S)) \\<and>\n                          snd (prod_ins x S) ! k = (i, j))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S x.\n       \\<lbrakk>\\<not> prod_memb x S; prod_is_node A B x;\n        prod_invariant A B S;\n        (fst S ! i ! j = Some k \\<and>\n         dfa_is_node A i \\<and> dfa_is_node B j) =\n        (k < length (snd S) \\<and> snd S ! k = (i, j))\\<rbrakk>\n       \\<Longrightarrow> (fst (prod_ins x S) ! i ! j = Some k \\<and>\n                          dfa_is_node A i \\<and> dfa_is_node B j) =\n                         (k < length (snd (prod_ins x S)) \\<and>\n                          snd (prod_ins x S) ! k = (i, j))", "case (step S y)"], ["proof (state)\nthis:\n  \\<not> prod_memb y S\n  prod_is_node A B y\n  prod_invariant A B S\n  (fst S ! i ! j = Some k \\<and> dfa_is_node A i \\<and> dfa_is_node B j) =\n  (k < length (snd S) \\<and> snd S ! k = (i, j))\n\ngoal (1 subgoal):\n 1. \\<And>S x.\n       \\<lbrakk>\\<not> prod_memb x S; prod_is_node A B x;\n        prod_invariant A B S;\n        (fst S ! i ! j = Some k \\<and>\n         dfa_is_node A i \\<and> dfa_is_node B j) =\n        (k < length (snd S) \\<and> snd S ! k = (i, j))\\<rbrakk>\n       \\<Longrightarrow> (fst (prod_ins x S) ! i ! j = Some k \\<and>\n                          dfa_is_node A i \\<and> dfa_is_node B j) =\n                         (k < length (snd (prod_ins x S)) \\<and>\n                          snd (prod_ins x S) ! k = (i, j))", "obtain y1 y2 where y: \"y = (y1, y2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y1 y2. y = (y1, y2) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases y)"], ["proof (state)\nthis:\n  y = (y1, y2)\n\ngoal (1 subgoal):\n 1. \\<And>S x.\n       \\<lbrakk>\\<not> prod_memb x S; prod_is_node A B x;\n        prod_invariant A B S;\n        (fst S ! i ! j = Some k \\<and>\n         dfa_is_node A i \\<and> dfa_is_node B j) =\n        (k < length (snd S) \\<and> snd S ! k = (i, j))\\<rbrakk>\n       \\<Longrightarrow> (fst (prod_ins x S) ! i ! j = Some k \\<and>\n                          dfa_is_node A i \\<and> dfa_is_node B j) =\n                         (k < length (snd (prod_ins x S)) \\<and>\n                          snd (prod_ins x S) ! k = (i, j))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst (prod_ins y S) ! i ! j = Some k \\<and>\n     dfa_is_node A i \\<and> dfa_is_node B j) =\n    (k < length (snd (prod_ins y S)) \\<and> snd (prod_ins y S) ! k = (i, j))", "proof (cases \"y1 = i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y1 = i \\<Longrightarrow>\n    (fst (prod_ins y S) ! i ! j = Some k \\<and>\n     dfa_is_node A i \\<and> dfa_is_node B j) =\n    (k < length (snd (prod_ins y S)) \\<and> snd (prod_ins y S) ! k = (i, j))\n 2. y1 \\<noteq> i \\<Longrightarrow>\n    (fst (prod_ins y S) ! i ! j = Some k \\<and>\n     dfa_is_node A i \\<and> dfa_is_node B j) =\n    (k < length (snd (prod_ins y S)) \\<and> snd (prod_ins y S) ! k = (i, j))", "case True"], ["proof (state)\nthis:\n  y1 = i\n\ngoal (2 subgoals):\n 1. y1 = i \\<Longrightarrow>\n    (fst (prod_ins y S) ! i ! j = Some k \\<and>\n     dfa_is_node A i \\<and> dfa_is_node B j) =\n    (k < length (snd (prod_ins y S)) \\<and> snd (prod_ins y S) ! k = (i, j))\n 2. y1 \\<noteq> i \\<Longrightarrow>\n    (fst (prod_ins y S) ! i ! j = Some k \\<and>\n     dfa_is_node A i \\<and> dfa_is_node B j) =\n    (k < length (snd (prod_ins y S)) \\<and> snd (prod_ins y S) ! k = (i, j))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst (prod_ins y S) ! i ! j = Some k \\<and>\n     dfa_is_node A i \\<and> dfa_is_node B j) =\n    (k < length (snd (prod_ins y S)) \\<and> snd (prod_ins y S) ! k = (i, j))", "proof (cases \"y2 = j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y2 = j \\<Longrightarrow>\n    (fst (prod_ins y S) ! i ! j = Some k \\<and>\n     dfa_is_node A i \\<and> dfa_is_node B j) =\n    (k < length (snd (prod_ins y S)) \\<and> snd (prod_ins y S) ! k = (i, j))\n 2. y2 \\<noteq> j \\<Longrightarrow>\n    (fst (prod_ins y S) ! i ! j = Some k \\<and>\n     dfa_is_node A i \\<and> dfa_is_node B j) =\n    (k < length (snd (prod_ins y S)) \\<and> snd (prod_ins y S) ! k = (i, j))", "case True"], ["proof (state)\nthis:\n  y2 = j\n\ngoal (2 subgoals):\n 1. y2 = j \\<Longrightarrow>\n    (fst (prod_ins y S) ! i ! j = Some k \\<and>\n     dfa_is_node A i \\<and> dfa_is_node B j) =\n    (k < length (snd (prod_ins y S)) \\<and> snd (prod_ins y S) ! k = (i, j))\n 2. y2 \\<noteq> j \\<Longrightarrow>\n    (fst (prod_ins y S) ! i ! j = Some k \\<and>\n     dfa_is_node A i \\<and> dfa_is_node B j) =\n    (k < length (snd (prod_ins y S)) \\<and> snd (prod_ins y S) ! k = (i, j))", "with step y \\<open>y1 = i\\<close>"], ["proof (chain)\npicking this:\n  \\<not> prod_memb y S\n  prod_is_node A B y\n  prod_invariant A B S\n  (fst S ! i ! j = Some k \\<and> dfa_is_node A i \\<and> dfa_is_node B j) =\n  (k < length (snd S) \\<and> snd S ! k = (i, j))\n  y = (y1, y2)\n  y1 = i\n  y2 = j", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> prod_memb y S\n  prod_is_node A B y\n  prod_invariant A B S\n  (fst S ! i ! j = Some k \\<and> dfa_is_node A i \\<and> dfa_is_node B j) =\n  (k < length (snd S) \\<and> snd S ! k = (i, j))\n  y = (y1, y2)\n  y1 = i\n  y2 = j\n\ngoal (1 subgoal):\n 1. (fst (prod_ins y S) ! i ! j = Some k \\<and>\n     dfa_is_node A i \\<and> dfa_is_node B j) =\n    (k < length (snd (prod_ins y S)) \\<and> snd (prod_ins y S) ! k = (i, j))", "by (auto simp add: prod_ins_def prod_memb_def split_beta nth_append\n            prod_invariant_def prod_is_node_def dfa_is_node_def)"], ["proof (state)\nthis:\n  (fst (prod_ins y S) ! i ! j = Some k \\<and>\n   dfa_is_node A i \\<and> dfa_is_node B j) =\n  (k < length (snd (prod_ins y S)) \\<and> snd (prod_ins y S) ! k = (i, j))\n\ngoal (1 subgoal):\n 1. y2 \\<noteq> j \\<Longrightarrow>\n    (fst (prod_ins y S) ! i ! j = Some k \\<and>\n     dfa_is_node A i \\<and> dfa_is_node B j) =\n    (k < length (snd (prod_ins y S)) \\<and> snd (prod_ins y S) ! k = (i, j))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y2 \\<noteq> j \\<Longrightarrow>\n    (fst (prod_ins y S) ! i ! j = Some k \\<and>\n     dfa_is_node A i \\<and> dfa_is_node B j) =\n    (k < length (snd (prod_ins y S)) \\<and> snd (prod_ins y S) ! k = (i, j))", "case False"], ["proof (state)\nthis:\n  y2 \\<noteq> j\n\ngoal (1 subgoal):\n 1. y2 \\<noteq> j \\<Longrightarrow>\n    (fst (prod_ins y S) ! i ! j = Some k \\<and>\n     dfa_is_node A i \\<and> dfa_is_node B j) =\n    (k < length (snd (prod_ins y S)) \\<and> snd (prod_ins y S) ! k = (i, j))", "with step y \\<open>y1 = i\\<close>"], ["proof (chain)\npicking this:\n  \\<not> prod_memb y S\n  prod_is_node A B y\n  prod_invariant A B S\n  (fst S ! i ! j = Some k \\<and> dfa_is_node A i \\<and> dfa_is_node B j) =\n  (k < length (snd S) \\<and> snd S ! k = (i, j))\n  y = (y1, y2)\n  y1 = i\n  y2 \\<noteq> j", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> prod_memb y S\n  prod_is_node A B y\n  prod_invariant A B S\n  (fst S ! i ! j = Some k \\<and> dfa_is_node A i \\<and> dfa_is_node B j) =\n  (k < length (snd S) \\<and> snd S ! k = (i, j))\n  y = (y1, y2)\n  y1 = i\n  y2 \\<noteq> j\n\ngoal (1 subgoal):\n 1. (fst (prod_ins y S) ! i ! j = Some k \\<and>\n     dfa_is_node A i \\<and> dfa_is_node B j) =\n    (k < length (snd (prod_ins y S)) \\<and> snd (prod_ins y S) ! k = (i, j))", "by (auto simp add: prod_ins_def prod_memb_def split_beta nth_append\n            prod_invariant_def prod_is_node_def dfa_is_node_def)"], ["proof (state)\nthis:\n  (fst (prod_ins y S) ! i ! j = Some k \\<and>\n   dfa_is_node A i \\<and> dfa_is_node B j) =\n  (k < length (snd (prod_ins y S)) \\<and> snd (prod_ins y S) ! k = (i, j))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (fst (prod_ins y S) ! i ! j = Some k \\<and>\n   dfa_is_node A i \\<and> dfa_is_node B j) =\n  (k < length (snd (prod_ins y S)) \\<and> snd (prod_ins y S) ! k = (i, j))\n\ngoal (1 subgoal):\n 1. y1 \\<noteq> i \\<Longrightarrow>\n    (fst (prod_ins y S) ! i ! j = Some k \\<and>\n     dfa_is_node A i \\<and> dfa_is_node B j) =\n    (k < length (snd (prod_ins y S)) \\<and> snd (prod_ins y S) ! k = (i, j))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y1 \\<noteq> i \\<Longrightarrow>\n    (fst (prod_ins y S) ! i ! j = Some k \\<and>\n     dfa_is_node A i \\<and> dfa_is_node B j) =\n    (k < length (snd (prod_ins y S)) \\<and> snd (prod_ins y S) ! k = (i, j))", "case False"], ["proof (state)\nthis:\n  y1 \\<noteq> i\n\ngoal (1 subgoal):\n 1. y1 \\<noteq> i \\<Longrightarrow>\n    (fst (prod_ins y S) ! i ! j = Some k \\<and>\n     dfa_is_node A i \\<and> dfa_is_node B j) =\n    (k < length (snd (prod_ins y S)) \\<and> snd (prod_ins y S) ! k = (i, j))", "with step y"], ["proof (chain)\npicking this:\n  \\<not> prod_memb y S\n  prod_is_node A B y\n  prod_invariant A B S\n  (fst S ! i ! j = Some k \\<and> dfa_is_node A i \\<and> dfa_is_node B j) =\n  (k < length (snd S) \\<and> snd S ! k = (i, j))\n  y = (y1, y2)\n  y1 \\<noteq> i", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> prod_memb y S\n  prod_is_node A B y\n  prod_invariant A B S\n  (fst S ! i ! j = Some k \\<and> dfa_is_node A i \\<and> dfa_is_node B j) =\n  (k < length (snd S) \\<and> snd S ! k = (i, j))\n  y = (y1, y2)\n  y1 \\<noteq> i\n\ngoal (1 subgoal):\n 1. (fst (prod_ins y S) ! i ! j = Some k \\<and>\n     dfa_is_node A i \\<and> dfa_is_node B j) =\n    (k < length (snd (prod_ins y S)) \\<and> snd (prod_ins y S) ! k = (i, j))", "by (auto simp add: prod_ins_def prod_memb_def split_beta nth_append)"], ["proof (state)\nthis:\n  (fst (prod_ins y S) ! i ! j = Some k \\<and>\n   dfa_is_node A i \\<and> dfa_is_node B j) =\n  (k < length (snd (prod_ins y S)) \\<and> snd (prod_ins y S) ! k = (i, j))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (fst (prod_ins y S) ! i ! j = Some k \\<and>\n   dfa_is_node A i \\<and> dfa_is_node B j) =\n  (k < length (snd (prod_ins y S)) \\<and> snd (prod_ins y S) ! k = (i, j))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (fst (dfs (prod_empt A B) [x]) ! i ! j = Some k \\<and>\n   dfa_is_node A i \\<and> dfa_is_node B j) =\n  (k < length (snd (dfs (prod_empt A B) [x])) \\<and>\n   snd (dfs (prod_empt A B) [x]) ! k = (i, j))\n\ngoal (1 subgoal):\n 1. (fst (prod_dfs A B x) ! i ! j = Some k \\<and>\n     dfa_is_node A i \\<and> dfa_is_node B j) =\n    (k < length (snd (prod_dfs A B x)) \\<and>\n     snd (prod_dfs A B x) ! k = (i, j))", "then"], ["proof (chain)\npicking this:\n  (fst (dfs (prod_empt A B) [x]) ! i ! j = Some k \\<and>\n   dfa_is_node A i \\<and> dfa_is_node B j) =\n  (k < length (snd (dfs (prod_empt A B) [x])) \\<and>\n   snd (dfs (prod_empt A B) [x]) ! k = (i, j))", "show ?thesis"], ["proof (prove)\nusing this:\n  (fst (dfs (prod_empt A B) [x]) ! i ! j = Some k \\<and>\n   dfa_is_node A i \\<and> dfa_is_node B j) =\n  (k < length (snd (dfs (prod_empt A B) [x])) \\<and>\n   snd (dfs (prod_empt A B) [x]) ! k = (i, j))\n\ngoal (1 subgoal):\n 1. (fst (prod_dfs A B x) ! i ! j = Some k \\<and>\n     dfa_is_node A i \\<and> dfa_is_node B j) =\n    (k < length (snd (prod_dfs A B x)) \\<and>\n     snd (prod_dfs A B x) ! k = (i, j))", "by (simp add: prod_dfs_def)"], ["proof (state)\nthis:\n  (fst (prod_dfs A B x) ! i ! j = Some k \\<and>\n   dfa_is_node A i \\<and> dfa_is_node B j) =\n  (k < length (snd (prod_dfs A B x)) \\<and>\n   snd (prod_dfs A B x) ! k = (i, j))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prod_dfs_mono:\n  assumes z: \"prod_invariant A B z\"\n  and xs: \"list_all (prod_is_node A B) xs\"\n  and H: \"fst z ! i ! j = Some k\"\n  shows \"fst (gen_dfs (prod_succs A B) prod_ins prod_memb z xs) ! i ! j = Some k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (dfs z xs) ! i ! j = Some k", "using z xs"], ["proof (prove)\nusing this:\n  prod_invariant A B z\n  list_all (prod_is_node A B) xs\n\ngoal (1 subgoal):\n 1. fst (dfs z xs) ! i ! j = Some k", "apply (rule dfs_invariant)"], ["proof (prove)\ngoal (2 subgoals):\n 1. fst z ! i ! j = Some k\n 2. \\<And>S x.\n       \\<lbrakk>\\<not> prod_memb x S; prod_is_node A B x;\n        prod_invariant A B S; fst S ! i ! j = Some k\\<rbrakk>\n       \\<Longrightarrow> fst (prod_ins x S) ! i ! j = Some k", "apply (rule H)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S x.\n       \\<lbrakk>\\<not> prod_memb x S; prod_is_node A B x;\n        prod_invariant A B S; fst S ! i ! j = Some k\\<rbrakk>\n       \\<Longrightarrow> fst (prod_ins x S) ! i ! j = Some k", "apply (simp add: prod_ins_def prod_memb_def split_paired_all prod_is_node_def prod_invariant_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>a ! aa ! ba = None;\n        dfa_is_node A aa \\<and> dfa_is_node B ba;\n        length a = length (fst A) \\<and>\n        (\\<forall>tab'\\<in>set a. length tab' = length (fst B));\n        a ! i ! j = Some k\\<rbrakk>\n       \\<Longrightarrow> a[aa := (a ! aa)[ba := Some (length b)]] ! i ! j =\n                         Some k", "apply (case_tac \"aa = i\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>a ! aa ! ba = None;\n        dfa_is_node A aa \\<and> dfa_is_node B ba;\n        length a = length (fst A) \\<and>\n        (\\<forall>tab'\\<in>set a. length tab' = length (fst B));\n        a ! i ! j = Some k; aa = i\\<rbrakk>\n       \\<Longrightarrow> a[aa := (a ! aa)[ba := Some (length b)]] ! i ! j =\n                         Some k\n 2. \\<And>a b aa ba.\n       \\<lbrakk>a ! aa ! ba = None;\n        dfa_is_node A aa \\<and> dfa_is_node B ba;\n        length a = length (fst A) \\<and>\n        (\\<forall>tab'\\<in>set a. length tab' = length (fst B));\n        a ! i ! j = Some k; aa \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> a[aa := (a ! aa)[ba := Some (length b)]] ! i ! j =\n                         Some k", "apply (case_tac \"ba = j\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>a ! aa ! ba = None;\n        dfa_is_node A aa \\<and> dfa_is_node B ba;\n        length a = length (fst A) \\<and>\n        (\\<forall>tab'\\<in>set a. length tab' = length (fst B));\n        a ! i ! j = Some k; aa = i; ba = j\\<rbrakk>\n       \\<Longrightarrow> a[aa := (a ! aa)[ba := Some (length b)]] ! i ! j =\n                         Some k\n 2. \\<And>a b aa ba.\n       \\<lbrakk>a ! aa ! ba = None;\n        dfa_is_node A aa \\<and> dfa_is_node B ba;\n        length a = length (fst A) \\<and>\n        (\\<forall>tab'\\<in>set a. length tab' = length (fst B));\n        a ! i ! j = Some k; aa = i; ba \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> a[aa := (a ! aa)[ba := Some (length b)]] ! i ! j =\n                         Some k\n 3. \\<And>a b aa ba.\n       \\<lbrakk>a ! aa ! ba = None;\n        dfa_is_node A aa \\<and> dfa_is_node B ba;\n        length a = length (fst A) \\<and>\n        (\\<forall>tab'\\<in>set a. length tab' = length (fst B));\n        a ! i ! j = Some k; aa \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> a[aa := (a ! aa)[ba := Some (length b)]] ! i ! j =\n                         Some k", "apply (simp add: dfa_is_node_def)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma prod_dfs_start:\n  \"\\<lbrakk>dfa_is_node A i; dfa_is_node B j\\<rbrakk> \\<Longrightarrow> fst (prod_dfs A B (i, j)) ! i ! j = Some 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dfa_is_node A i; dfa_is_node B j\\<rbrakk>\n    \\<Longrightarrow> fst (prod_dfs A B (i, j)) ! i ! j = Some 0", "apply (simp add: prod_dfs_def empt prod_is_node_def gen_dfs_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dfa_is_node A i; dfa_is_node B j\\<rbrakk>\n    \\<Longrightarrow> fst (dfs (prod_ins (i, j) (prod_empt A B))\n                            (prod_succs A B (i, j))) !\n                      i !\n                      j =\n                      Some 0", "apply (rule prod_dfs_mono)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>dfa_is_node A i; dfa_is_node B j\\<rbrakk>\n    \\<Longrightarrow> prod_invariant A B (prod_ins (i, j) (prod_empt A B))\n 2. \\<lbrakk>dfa_is_node A i; dfa_is_node B j\\<rbrakk>\n    \\<Longrightarrow> list_all (prod_is_node A B) (prod_succs A B (i, j))\n 3. \\<lbrakk>dfa_is_node A i; dfa_is_node B j\\<rbrakk>\n    \\<Longrightarrow> fst (prod_ins (i, j) (prod_empt A B)) ! i ! j = Some 0", "apply (rule ins_invariant)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>dfa_is_node A i; dfa_is_node B j\\<rbrakk>\n    \\<Longrightarrow> prod_is_node A B (i, j)\n 2. \\<lbrakk>dfa_is_node A i; dfa_is_node B j\\<rbrakk>\n    \\<Longrightarrow> prod_invariant A B (prod_empt A B)\n 3. \\<lbrakk>dfa_is_node A i; dfa_is_node B j\\<rbrakk>\n    \\<Longrightarrow> \\<not> prod_memb (i, j) (prod_empt A B)\n 4. \\<lbrakk>dfa_is_node A i; dfa_is_node B j\\<rbrakk>\n    \\<Longrightarrow> list_all (prod_is_node A B) (prod_succs A B (i, j))\n 5. \\<lbrakk>dfa_is_node A i; dfa_is_node B j\\<rbrakk>\n    \\<Longrightarrow> fst (prod_ins (i, j) (prod_empt A B)) ! i ! j = Some 0", "apply (simp add: prod_is_node_def dfa_is_node_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>dfa_is_node A i; dfa_is_node B j\\<rbrakk>\n    \\<Longrightarrow> prod_invariant A B (prod_empt A B)\n 2. \\<lbrakk>dfa_is_node A i; dfa_is_node B j\\<rbrakk>\n    \\<Longrightarrow> \\<not> prod_memb (i, j) (prod_empt A B)\n 3. \\<lbrakk>dfa_is_node A i; dfa_is_node B j\\<rbrakk>\n    \\<Longrightarrow> list_all (prod_is_node A B) (prod_succs A B (i, j))\n 4. \\<lbrakk>dfa_is_node A i; dfa_is_node B j\\<rbrakk>\n    \\<Longrightarrow> fst (prod_ins (i, j) (prod_empt A B)) ! i ! j = Some 0", "apply (rule empt_invariant)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>dfa_is_node A i; dfa_is_node B j\\<rbrakk>\n    \\<Longrightarrow> \\<not> prod_memb (i, j) (prod_empt A B)\n 2. \\<lbrakk>dfa_is_node A i; dfa_is_node B j\\<rbrakk>\n    \\<Longrightarrow> list_all (prod_is_node A B) (prod_succs A B (i, j))\n 3. \\<lbrakk>dfa_is_node A i; dfa_is_node B j\\<rbrakk>\n    \\<Longrightarrow> fst (prod_ins (i, j) (prod_empt A B)) ! i ! j = Some 0", "apply (rule empt)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>dfa_is_node A i; dfa_is_node B j\\<rbrakk>\n    \\<Longrightarrow> prod_is_node A B (i, j)\n 2. \\<lbrakk>dfa_is_node A i; dfa_is_node B j\\<rbrakk>\n    \\<Longrightarrow> list_all (prod_is_node A B) (prod_succs A B (i, j))\n 3. \\<lbrakk>dfa_is_node A i; dfa_is_node B j\\<rbrakk>\n    \\<Longrightarrow> fst (prod_ins (i, j) (prod_empt A B)) ! i ! j = Some 0", "apply (simp add: prod_is_node_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>dfa_is_node A i; dfa_is_node B j\\<rbrakk>\n    \\<Longrightarrow> list_all (prod_is_node A B) (prod_succs A B (i, j))\n 2. \\<lbrakk>dfa_is_node A i; dfa_is_node B j\\<rbrakk>\n    \\<Longrightarrow> fst (prod_ins (i, j) (prod_empt A B)) ! i ! j = Some 0", "apply (rule succs_is_node)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>dfa_is_node A i; dfa_is_node B j\\<rbrakk>\n    \\<Longrightarrow> prod_is_node A B (i, j)\n 2. \\<lbrakk>dfa_is_node A i; dfa_is_node B j\\<rbrakk>\n    \\<Longrightarrow> fst (prod_ins (i, j) (prod_empt A B)) ! i ! j = Some 0", "apply (simp add: prod_is_node_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dfa_is_node A i; dfa_is_node B j\\<rbrakk>\n    \\<Longrightarrow> fst (prod_ins (i, j) (prod_empt A B)) ! i ! j = Some 0", "apply (simp add: prod_ins_def prod_empt_def dfa_is_node_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma prod_dfs_inj:\n  assumes x: \"prod_is_node A B x\" and i1: \"dfa_is_node A i1\" and i2: \"dfa_is_node B i2\"\n  and j1: \"dfa_is_node A j1\" and j2: \"dfa_is_node B j2\"\n  and i: \"fst (prod_dfs A B x) ! i1 ! i2 = Some k\"\n  and j: \"fst (prod_dfs A B x) ! j1 ! j2 = Some k\"\n  shows \"(i1, i2) = (j1, j2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i1, i2) = (j1, j2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (i1, i2) = (j1, j2)", "from x i1 i2 i"], ["proof (chain)\npicking this:\n  prod_is_node A B x\n  dfa_is_node A i1\n  dfa_is_node B i2\n  fst (prod_dfs A B x) ! i1 ! i2 = Some k", "have \"k < length (snd (prod_dfs A B x)) \\<and> snd (prod_dfs A B x) ! k = (i1, i2)\""], ["proof (prove)\nusing this:\n  prod_is_node A B x\n  dfa_is_node A i1\n  dfa_is_node B i2\n  fst (prod_dfs A B x) ! i1 ! i2 = Some k\n\ngoal (1 subgoal):\n 1. k < length (snd (prod_dfs A B x)) \\<and>\n    snd (prod_dfs A B x) ! k = (i1, i2)", "by (simp add: prod_dfs_bij [symmetric])"], ["proof (state)\nthis:\n  k < length (snd (prod_dfs A B x)) \\<and>\n  snd (prod_dfs A B x) ! k = (i1, i2)\n\ngoal (1 subgoal):\n 1. (i1, i2) = (j1, j2)", "moreover"], ["proof (state)\nthis:\n  k < length (snd (prod_dfs A B x)) \\<and>\n  snd (prod_dfs A B x) ! k = (i1, i2)\n\ngoal (1 subgoal):\n 1. (i1, i2) = (j1, j2)", "from x j1 j2 j"], ["proof (chain)\npicking this:\n  prod_is_node A B x\n  dfa_is_node A j1\n  dfa_is_node B j2\n  fst (prod_dfs A B x) ! j1 ! j2 = Some k", "have \"k < length (snd (prod_dfs A B x)) \\<and> snd (prod_dfs A B x) ! k = (j1, j2)\""], ["proof (prove)\nusing this:\n  prod_is_node A B x\n  dfa_is_node A j1\n  dfa_is_node B j2\n  fst (prod_dfs A B x) ! j1 ! j2 = Some k\n\ngoal (1 subgoal):\n 1. k < length (snd (prod_dfs A B x)) \\<and>\n    snd (prod_dfs A B x) ! k = (j1, j2)", "by (simp add: prod_dfs_bij [symmetric])"], ["proof (state)\nthis:\n  k < length (snd (prod_dfs A B x)) \\<and>\n  snd (prod_dfs A B x) ! k = (j1, j2)\n\ngoal (1 subgoal):\n 1. (i1, i2) = (j1, j2)", "ultimately"], ["proof (chain)\npicking this:\n  k < length (snd (prod_dfs A B x)) \\<and>\n  snd (prod_dfs A B x) ! k = (i1, i2)\n  k < length (snd (prod_dfs A B x)) \\<and>\n  snd (prod_dfs A B x) ! k = (j1, j2)", "show ?thesis"], ["proof (prove)\nusing this:\n  k < length (snd (prod_dfs A B x)) \\<and>\n  snd (prod_dfs A B x) ! k = (i1, i2)\n  k < length (snd (prod_dfs A B x)) \\<and>\n  snd (prod_dfs A B x) ! k = (j1, j2)\n\ngoal (1 subgoal):\n 1. (i1, i2) = (j1, j2)", "by simp"], ["proof (state)\nthis:\n  (i1, i2) = (j1, j2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prod_dfs_statetrans:\n  assumes bs: \"length bs = n\"\n  and i: \"dfa_is_node A i\" and j: \"dfa_is_node B j\"\n  and s1: \"dfa_is_node A s1\" and s2: \"dfa_is_node B s2\"\n  and k: \"fst (prod_dfs A B (s1, s2)) ! i ! j = Some k\"\n  obtains k'\n  where \"fst (prod_dfs A B (s1, s2)) !\n    dfa_trans A i bs ! dfa_trans B j bs = Some k'\"\n  and \"dfa_is_node A (dfa_trans A i bs)\"\n  and \"dfa_is_node B (dfa_trans B j bs)\"\n  and \"k' < length (snd (prod_dfs A B (s1, s2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        \\<lbrakk>fst (prod_dfs A B (s1, s2)) ! dfa_trans A i bs !\n                 dfa_trans B j bs =\n                 Some k';\n         dfa_is_node A (dfa_trans A i bs); dfa_is_node B (dfa_trans B j bs);\n         k' < length (snd (prod_dfs A B (s1, s2)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        \\<lbrakk>fst (prod_dfs A B (s1, s2)) ! dfa_trans A i bs !\n                 dfa_trans B j bs =\n                 Some k';\n         dfa_is_node A (dfa_trans A i bs); dfa_is_node B (dfa_trans B j bs);\n         k' < length (snd (prod_dfs A B (s1, s2)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from i well_formed1 bs"], ["proof (chain)\npicking this:\n  dfa_is_node A i\n  wf_dfa A n\n  length bs = n", "have h_tr1: \"bddh (length bs) (fst A ! i)\""], ["proof (prove)\nusing this:\n  dfa_is_node A i\n  wf_dfa A n\n  length bs = n\n\ngoal (1 subgoal):\n 1. bddh (length bs) (fst A ! i)", "by (simp add: wf_dfa_def dfa_is_node_def list_all_iff)"], ["proof (state)\nthis:\n  bddh (length bs) (fst A ! i)\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        \\<lbrakk>fst (prod_dfs A B (s1, s2)) ! dfa_trans A i bs !\n                 dfa_trans B j bs =\n                 Some k';\n         dfa_is_node A (dfa_trans A i bs); dfa_is_node B (dfa_trans B j bs);\n         k' < length (snd (prod_dfs A B (s1, s2)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from j well_formed2 bs"], ["proof (chain)\npicking this:\n  dfa_is_node B j\n  wf_dfa B n\n  length bs = n", "have h_tr2: \"bddh (length bs) (fst B ! j)\""], ["proof (prove)\nusing this:\n  dfa_is_node B j\n  wf_dfa B n\n  length bs = n\n\ngoal (1 subgoal):\n 1. bddh (length bs) (fst B ! j)", "by (simp add: wf_dfa_def dfa_is_node_def list_all_iff)"], ["proof (state)\nthis:\n  bddh (length bs) (fst B ! j)\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        \\<lbrakk>fst (prod_dfs A B (s1, s2)) ! dfa_trans A i bs !\n                 dfa_trans B j bs =\n                 Some k';\n         dfa_is_node A (dfa_trans A i bs); dfa_is_node B (dfa_trans B j bs);\n         k' < length (snd (prod_dfs A B (s1, s2)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from i j k"], ["proof (chain)\npicking this:\n  dfa_is_node A i\n  dfa_is_node B j\n  fst (prod_dfs A B (s1, s2)) ! i ! j = Some k", "have \"prod_memb (i, j) (prod_dfs A B (s1, s2))\""], ["proof (prove)\nusing this:\n  dfa_is_node A i\n  dfa_is_node B j\n  fst (prod_dfs A B (s1, s2)) ! i ! j = Some k\n\ngoal (1 subgoal):\n 1. prod_memb (i, j) (prod_dfs A B (s1, s2))", "by (simp add: prod_memb_def split_beta)"], ["proof (state)\nthis:\n  prod_memb (i, j) (prod_dfs A B (s1, s2))\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        \\<lbrakk>fst (prod_dfs A B (s1, s2)) ! dfa_trans A i bs !\n                 dfa_trans B j bs =\n                 Some k';\n         dfa_is_node A (dfa_trans A i bs); dfa_is_node B (dfa_trans B j bs);\n         k' < length (snd (prod_dfs A B (s1, s2)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  prod_memb (i, j) (prod_dfs A B (s1, s2))", "have \"((s1, s2), (i, j)) \\<in> (succsr (prod_succs A B))\\<^sup>*\""], ["proof (prove)\nusing this:\n  prod_memb (i, j) (prod_dfs A B (s1, s2))\n\ngoal (1 subgoal):\n 1. ((s1, s2), i, j) \\<in> (succsr (prod_succs A B))\\<^sup>*", "using i j s1 s2"], ["proof (prove)\nusing this:\n  prod_memb (i, j) (prod_dfs A B (s1, s2))\n  dfa_is_node A i\n  dfa_is_node B j\n  dfa_is_node A s1\n  dfa_is_node B s2\n\ngoal (1 subgoal):\n 1. ((s1, s2), i, j) \\<in> (succsr (prod_succs A B))\\<^sup>*", "by (simp add: prod_dfs_eq_rtrancl prod_is_node_def)"], ["proof (state)\nthis:\n  ((s1, s2), i, j) \\<in> (succsr (prod_succs A B))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        \\<lbrakk>fst (prod_dfs A B (s1, s2)) ! dfa_trans A i bs !\n                 dfa_trans B j bs =\n                 Some k';\n         dfa_is_node A (dfa_trans A i bs); dfa_is_node B (dfa_trans B j bs);\n         k' < length (snd (prod_dfs A B (s1, s2)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  ((s1, s2), i, j) \\<in> (succsr (prod_succs A B))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        \\<lbrakk>fst (prod_dfs A B (s1, s2)) ! dfa_trans A i bs !\n                 dfa_trans B j bs =\n                 Some k';\n         dfa_is_node A (dfa_trans A i bs); dfa_is_node B (dfa_trans B j bs);\n         k' < length (snd (prod_dfs A B (s1, s2)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from h_tr1 h_tr2"], ["proof (chain)\npicking this:\n  bddh (length bs) (fst A ! i)\n  bddh (length bs) (fst B ! j)", "have \"(bdd_lookup (fst A ! i) bs, bdd_lookup (fst B ! j) bs) =\n    bdd_lookup (bdd_binop Pair (fst A ! i) (fst B ! j)) bs\""], ["proof (prove)\nusing this:\n  bddh (length bs) (fst A ! i)\n  bddh (length bs) (fst B ! j)\n\ngoal (1 subgoal):\n 1. (bdd_lookup (fst A ! i) bs, bdd_lookup (fst B ! j) bs) =\n    bdd_lookup (bdd_binop Pair (fst A ! i) (fst B ! j)) bs", "by (simp add: bdd_lookup_binop)"], ["proof (state)\nthis:\n  (bdd_lookup (fst A ! i) bs, bdd_lookup (fst B ! j) bs) =\n  bdd_lookup (bdd_binop Pair (fst A ! i) (fst B ! j)) bs\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        \\<lbrakk>fst (prod_dfs A B (s1, s2)) ! dfa_trans A i bs !\n                 dfa_trans B j bs =\n                 Some k';\n         dfa_is_node A (dfa_trans A i bs); dfa_is_node B (dfa_trans B j bs);\n         k' < length (snd (prod_dfs A B (s1, s2)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with i j h_tr1 h_tr2"], ["proof (chain)\npicking this:\n  dfa_is_node A i\n  dfa_is_node B j\n  bddh (length bs) (fst A ! i)\n  bddh (length bs) (fst B ! j)\n  (bdd_lookup (fst A ! i) bs, bdd_lookup (fst B ! j) bs) =\n  bdd_lookup (bdd_binop Pair (fst A ! i) (fst B ! j)) bs", "have \"((i, j), (bdd_lookup (fst A ! i) bs, bdd_lookup (fst B ! j) bs)) \\<in>\n    succsr (prod_succs A B)\""], ["proof (prove)\nusing this:\n  dfa_is_node A i\n  dfa_is_node B j\n  bddh (length bs) (fst A ! i)\n  bddh (length bs) (fst B ! j)\n  (bdd_lookup (fst A ! i) bs, bdd_lookup (fst B ! j) bs) =\n  bdd_lookup (bdd_binop Pair (fst A ! i) (fst B ! j)) bs\n\ngoal (1 subgoal):\n 1. ((i, j), bdd_lookup (fst A ! i) bs, bdd_lookup (fst B ! j) bs)\n    \\<in> succsr (prod_succs A B)", "by (auto simp add: succsr_def prod_succs_def\n      add_leaves_bdd_lookup [of \"length bs\"] bddh_binop is_alph_def)"], ["proof (state)\nthis:\n  ((i, j), bdd_lookup (fst A ! i) bs, bdd_lookup (fst B ! j) bs)\n  \\<in> succsr (prod_succs A B)\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        \\<lbrakk>fst (prod_dfs A B (s1, s2)) ! dfa_trans A i bs !\n                 dfa_trans B j bs =\n                 Some k';\n         dfa_is_node A (dfa_trans A i bs); dfa_is_node B (dfa_trans B j bs);\n         k' < length (snd (prod_dfs A B (s1, s2)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  ((s1, s2), i, j) \\<in> (succsr (prod_succs A B))\\<^sup>*\n  ((i, j), bdd_lookup (fst A ! i) bs, bdd_lookup (fst B ! j) bs)\n  \\<in> succsr (prod_succs A B)", "have \"((s1, s2), (bdd_lookup (fst A ! i) bs, bdd_lookup (fst B ! j) bs)) \\<in>\n    (succsr (prod_succs A B))\\<^sup>*\""], ["proof (prove)\nusing this:\n  ((s1, s2), i, j) \\<in> (succsr (prod_succs A B))\\<^sup>*\n  ((i, j), bdd_lookup (fst A ! i) bs, bdd_lookup (fst B ! j) bs)\n  \\<in> succsr (prod_succs A B)\n\ngoal (1 subgoal):\n 1. ((s1, s2), bdd_lookup (fst A ! i) bs, bdd_lookup (fst B ! j) bs)\n    \\<in> (succsr (prod_succs A B))\\<^sup>*", ".."], ["proof (state)\nthis:\n  ((s1, s2), bdd_lookup (fst A ! i) bs, bdd_lookup (fst B ! j) bs)\n  \\<in> (succsr (prod_succs A B))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        \\<lbrakk>fst (prod_dfs A B (s1, s2)) ! dfa_trans A i bs !\n                 dfa_trans B j bs =\n                 Some k';\n         dfa_is_node A (dfa_trans A i bs); dfa_is_node B (dfa_trans B j bs);\n         k' < length (snd (prod_dfs A B (s1, s2)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  ((s1, s2), bdd_lookup (fst A ! i) bs, bdd_lookup (fst B ! j) bs)\n  \\<in> (succsr (prod_succs A B))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        \\<lbrakk>fst (prod_dfs A B (s1, s2)) ! dfa_trans A i bs !\n                 dfa_trans B j bs =\n                 Some k';\n         dfa_is_node A (dfa_trans A i bs); dfa_is_node B (dfa_trans B j bs);\n         k' < length (snd (prod_dfs A B (s1, s2)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from well_formed1 well_formed2 bs i j"], ["proof (chain)\npicking this:\n  wf_dfa A n\n  wf_dfa B n\n  length bs = n\n  dfa_is_node A i\n  dfa_is_node B j", "have \"prod_is_node A B (bdd_lookup (fst A ! i) bs, bdd_lookup (fst B ! j) bs)\""], ["proof (prove)\nusing this:\n  wf_dfa A n\n  wf_dfa B n\n  length bs = n\n  dfa_is_node A i\n  dfa_is_node B j\n\ngoal (1 subgoal):\n 1. prod_is_node A B (bdd_lookup (fst A ! i) bs, bdd_lookup (fst B ! j) bs)", "by (auto simp: prod_is_node_def bdd_all_bdd_lookup is_alph_def dfa_trans_is_node dfa_trans_def[symmetric])"], ["proof (state)\nthis:\n  prod_is_node A B (bdd_lookup (fst A ! i) bs, bdd_lookup (fst B ! j) bs)\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        \\<lbrakk>fst (prod_dfs A B (s1, s2)) ! dfa_trans A i bs !\n                 dfa_trans B j bs =\n                 Some k';\n         dfa_is_node A (dfa_trans A i bs); dfa_is_node B (dfa_trans B j bs);\n         k' < length (snd (prod_dfs A B (s1, s2)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  prod_is_node A B (bdd_lookup (fst A ! i) bs, bdd_lookup (fst B ! j) bs)\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        \\<lbrakk>fst (prod_dfs A B (s1, s2)) ! dfa_trans A i bs !\n                 dfa_trans B j bs =\n                 Some k';\n         dfa_is_node A (dfa_trans A i bs); dfa_is_node B (dfa_trans B j bs);\n         k' < length (snd (prod_dfs A B (s1, s2)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from i well_formed1 bs"], ["proof (chain)\npicking this:\n  dfa_is_node A i\n  wf_dfa A n\n  length bs = n", "have s_tr1: \"dfa_is_node A (dfa_trans A i bs)\""], ["proof (prove)\nusing this:\n  dfa_is_node A i\n  wf_dfa A n\n  length bs = n\n\ngoal (1 subgoal):\n 1. dfa_is_node A (dfa_trans A i bs)", "by (simp add: is_alph_def dfa_trans_is_node)"], ["proof (state)\nthis:\n  dfa_is_node A (dfa_trans A i bs)\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        \\<lbrakk>fst (prod_dfs A B (s1, s2)) ! dfa_trans A i bs !\n                 dfa_trans B j bs =\n                 Some k';\n         dfa_is_node A (dfa_trans A i bs); dfa_is_node B (dfa_trans B j bs);\n         k' < length (snd (prod_dfs A B (s1, s2)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  dfa_is_node A (dfa_trans A i bs)\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        \\<lbrakk>fst (prod_dfs A B (s1, s2)) ! dfa_trans A i bs !\n                 dfa_trans B j bs =\n                 Some k';\n         dfa_is_node A (dfa_trans A i bs); dfa_is_node B (dfa_trans B j bs);\n         k' < length (snd (prod_dfs A B (s1, s2)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from j well_formed2 bs"], ["proof (chain)\npicking this:\n  dfa_is_node B j\n  wf_dfa B n\n  length bs = n", "have s_tr2: \"dfa_is_node B (dfa_trans B j bs)\""], ["proof (prove)\nusing this:\n  dfa_is_node B j\n  wf_dfa B n\n  length bs = n\n\ngoal (1 subgoal):\n 1. dfa_is_node B (dfa_trans B j bs)", "by (simp add: is_alph_def dfa_trans_is_node)"], ["proof (state)\nthis:\n  dfa_is_node B (dfa_trans B j bs)\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        \\<lbrakk>fst (prod_dfs A B (s1, s2)) ! dfa_trans A i bs !\n                 dfa_trans B j bs =\n                 Some k';\n         dfa_is_node A (dfa_trans A i bs); dfa_is_node B (dfa_trans B j bs);\n         k' < length (snd (prod_dfs A B (s1, s2)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  ((s1, s2), bdd_lookup (fst A ! i) bs, bdd_lookup (fst B ! j) bs)\n  \\<in> (succsr (prod_succs A B))\\<^sup>*\n  prod_is_node A B (bdd_lookup (fst A ! i) bs, bdd_lookup (fst B ! j) bs)\n  dfa_is_node A (dfa_trans A i bs)\n  dfa_is_node B (dfa_trans B j bs)", "have \"\\<exists>k'. fst (prod_dfs A B (s1, s2)) ! \n    dfa_trans A i bs ! dfa_trans B j bs = Some k'\""], ["proof (prove)\nusing this:\n  ((s1, s2), bdd_lookup (fst A ! i) bs, bdd_lookup (fst B ! j) bs)\n  \\<in> (succsr (prod_succs A B))\\<^sup>*\n  prod_is_node A B (bdd_lookup (fst A ! i) bs, bdd_lookup (fst B ! j) bs)\n  dfa_is_node A (dfa_trans A i bs)\n  dfa_is_node B (dfa_trans B j bs)\n\ngoal (1 subgoal):\n 1. \\<exists>k'.\n       fst (prod_dfs A B (s1, s2)) ! dfa_trans A i bs ! dfa_trans B j bs =\n       Some k'", "using s1 s2"], ["proof (prove)\nusing this:\n  ((s1, s2), bdd_lookup (fst A ! i) bs, bdd_lookup (fst B ! j) bs)\n  \\<in> (succsr (prod_succs A B))\\<^sup>*\n  prod_is_node A B (bdd_lookup (fst A ! i) bs, bdd_lookup (fst B ! j) bs)\n  dfa_is_node A (dfa_trans A i bs)\n  dfa_is_node B (dfa_trans B j bs)\n  dfa_is_node A s1\n  dfa_is_node B s2\n\ngoal (1 subgoal):\n 1. \\<exists>k'.\n       fst (prod_dfs A B (s1, s2)) ! dfa_trans A i bs ! dfa_trans B j bs =\n       Some k'", "by (simp add: prod_dfs_eq_rtrancl [symmetric] prod_memb_def split_beta prod_is_node_def dfa_trans_def)"], ["proof (state)\nthis:\n  \\<exists>k'.\n     fst (prod_dfs A B (s1, s2)) ! dfa_trans A i bs ! dfa_trans B j bs =\n     Some k'\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        \\<lbrakk>fst (prod_dfs A B (s1, s2)) ! dfa_trans A i bs !\n                 dfa_trans B j bs =\n                 Some k';\n         dfa_is_node A (dfa_trans A i bs); dfa_is_node B (dfa_trans B j bs);\n         k' < length (snd (prod_dfs A B (s1, s2)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<exists>k'.\n     fst (prod_dfs A B (s1, s2)) ! dfa_trans A i bs ! dfa_trans B j bs =\n     Some k'", "obtain k' where k': \"fst (prod_dfs A B (s1, s2)) ! \n    dfa_trans A i bs ! dfa_trans B j bs = Some k'\""], ["proof (prove)\nusing this:\n  \\<exists>k'.\n     fst (prod_dfs A B (s1, s2)) ! dfa_trans A i bs ! dfa_trans B j bs =\n     Some k'\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        fst (prod_dfs A B (s1, s2)) ! dfa_trans A i bs ! dfa_trans B j bs =\n        Some k' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  fst (prod_dfs A B (s1, s2)) ! dfa_trans A i bs ! dfa_trans B j bs =\n  Some k'\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        \\<lbrakk>fst (prod_dfs A B (s1, s2)) ! dfa_trans A i bs !\n                 dfa_trans B j bs =\n                 Some k';\n         dfa_is_node A (dfa_trans A i bs); dfa_is_node B (dfa_trans B j bs);\n         k' < length (snd (prod_dfs A B (s1, s2)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from k' s_tr1 s_tr2 s1 s2"], ["proof (chain)\npicking this:\n  fst (prod_dfs A B (s1, s2)) ! dfa_trans A i bs ! dfa_trans B j bs =\n  Some k'\n  dfa_is_node A (dfa_trans A i bs)\n  dfa_is_node B (dfa_trans B j bs)\n  dfa_is_node A s1\n  dfa_is_node B s2", "have \"k' < length (snd (prod_dfs A B (s1, s2))) \\<and>\n    snd (prod_dfs A B (s1, s2)) ! k' = (dfa_trans A i bs, dfa_trans B j bs)\""], ["proof (prove)\nusing this:\n  fst (prod_dfs A B (s1, s2)) ! dfa_trans A i bs ! dfa_trans B j bs =\n  Some k'\n  dfa_is_node A (dfa_trans A i bs)\n  dfa_is_node B (dfa_trans B j bs)\n  dfa_is_node A s1\n  dfa_is_node B s2\n\ngoal (1 subgoal):\n 1. k' < length (snd (prod_dfs A B (s1, s2))) \\<and>\n    snd (prod_dfs A B (s1, s2)) ! k' = (dfa_trans A i bs, dfa_trans B j bs)", "by (simp add: prod_dfs_bij [symmetric] prod_is_node_def)"], ["proof (state)\nthis:\n  k' < length (snd (prod_dfs A B (s1, s2))) \\<and>\n  snd (prod_dfs A B (s1, s2)) ! k' = (dfa_trans A i bs, dfa_trans B j bs)\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        \\<lbrakk>fst (prod_dfs A B (s1, s2)) ! dfa_trans A i bs !\n                 dfa_trans B j bs =\n                 Some k';\n         dfa_is_node A (dfa_trans A i bs); dfa_is_node B (dfa_trans B j bs);\n         k' < length (snd (prod_dfs A B (s1, s2)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  k' < length (snd (prod_dfs A B (s1, s2))) \\<and>\n  snd (prod_dfs A B (s1, s2)) ! k' = (dfa_trans A i bs, dfa_trans B j bs)", "have \"k' < length (snd (prod_dfs A B (s1, s2)))\""], ["proof (prove)\nusing this:\n  k' < length (snd (prod_dfs A B (s1, s2))) \\<and>\n  snd (prod_dfs A B (s1, s2)) ! k' = (dfa_trans A i bs, dfa_trans B j bs)\n\ngoal (1 subgoal):\n 1. k' < length (snd (prod_dfs A B (s1, s2)))", "by simp"], ["proof (state)\nthis:\n  k' < length (snd (prod_dfs A B (s1, s2)))\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        \\<lbrakk>fst (prod_dfs A B (s1, s2)) ! dfa_trans A i bs !\n                 dfa_trans B j bs =\n                 Some k';\n         dfa_is_node A (dfa_trans A i bs); dfa_is_node B (dfa_trans B j bs);\n         k' < length (snd (prod_dfs A B (s1, s2)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with k' s_tr1 s_tr2"], ["proof (chain)\npicking this:\n  fst (prod_dfs A B (s1, s2)) ! dfa_trans A i bs ! dfa_trans B j bs =\n  Some k'\n  dfa_is_node A (dfa_trans A i bs)\n  dfa_is_node B (dfa_trans B j bs)\n  k' < length (snd (prod_dfs A B (s1, s2)))", "show ?thesis"], ["proof (prove)\nusing this:\n  fst (prod_dfs A B (s1, s2)) ! dfa_trans A i bs ! dfa_trans B j bs =\n  Some k'\n  dfa_is_node A (dfa_trans A i bs)\n  dfa_is_node B (dfa_trans B j bs)\n  k' < length (snd (prod_dfs A B (s1, s2)))\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma binop_wf_dfa: \"wf_dfa (binop_dfa f A B) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_dfa (binop_dfa f A B) n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_dfa (binop_dfa f A B) n", "let ?dfa = \"binop_dfa f A B\""], ["proof (state)\ngoal (1 subgoal):\n 1. wf_dfa (binop_dfa f A B) n", "from well_formed1 well_formed2"], ["proof (chain)\npicking this:\n  wf_dfa A n\n  wf_dfa B n", "have is_node_s1_s2: \"prod_is_node A B (0, 0)\""], ["proof (prove)\nusing this:\n  wf_dfa A n\n  wf_dfa B n\n\ngoal (1 subgoal):\n 1. prod_is_node A B (0, 0)", "by (simp add: prod_is_node_def wf_dfa_def dfa_is_node_def)"], ["proof (state)\nthis:\n  prod_is_node A B (0, 0)\n\ngoal (1 subgoal):\n 1. wf_dfa (binop_dfa f A B) n", "let ?tr = \"map (\\<lambda>(i,j). bdd_binop (\\<lambda>k l. the (fst (prod_dfs A B (0, 0)) ! k ! l)) (fst A ! i) (fst B ! j)) (snd (prod_dfs A B (0,0)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. wf_dfa (binop_dfa f A B) n", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_dfa (binop_dfa f A B) n", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_dfa (binop_dfa f A B) n", "assume ij: \"(i, j) \\<in> set (snd (prod_dfs A B (0, 0)))\""], ["proof (state)\nthis:\n  (i, j) \\<in> set (snd (prod_dfs A B (0, 0)))\n\ngoal (1 subgoal):\n 1. wf_dfa (binop_dfa f A B) n", "then"], ["proof (chain)\npicking this:\n  (i, j) \\<in> set (snd (prod_dfs A B (0, 0)))", "obtain k where k: \"k < length (snd (prod_dfs A B (0, 0)))\"\n      \"snd (prod_dfs A B (0, 0)) ! k = (i, j)\""], ["proof (prove)\nusing this:\n  (i, j) \\<in> set (snd (prod_dfs A B (0, 0)))\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k < length (snd (prod_dfs A B (0, 0)));\n         snd (prod_dfs A B (0, 0)) ! k = (i, j)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: in_set_conv_nth)"], ["proof (state)\nthis:\n  k < length (snd (prod_dfs A B (0, 0)))\n  snd (prod_dfs A B (0, 0)) ! k = (i, j)\n\ngoal (1 subgoal):\n 1. wf_dfa (binop_dfa f A B) n", "from conjI [OF k]"], ["proof (chain)\npicking this:\n  k < length (snd (prod_dfs A B (0, 0))) \\<and>\n  snd (prod_dfs A B (0, 0)) ! k = (i, j)", "obtain ij_k: \"fst (prod_dfs A B (0,0)) ! i ! j = Some k\"\n      and i: \"dfa_is_node A i\" and j: \"dfa_is_node B j\""], ["proof (prove)\nusing this:\n  k < length (snd (prod_dfs A B (0, 0))) \\<and>\n  snd (prod_dfs A B (0, 0)) ! k = (i, j)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>fst (prod_dfs A B (0, 0)) ! i ! j = Some k; dfa_is_node A i;\n      dfa_is_node B j\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: prod_dfs_bij [OF is_node_s1_s2, symmetric])"], ["proof (state)\nthis:\n  fst (prod_dfs A B (0, 0)) ! i ! j = Some k\n  dfa_is_node A i\n  dfa_is_node B j\n\ngoal (1 subgoal):\n 1. wf_dfa (binop_dfa f A B) n", "from well_formed1 i"], ["proof (chain)\npicking this:\n  wf_dfa A n\n  dfa_is_node A i", "have bddh_tr1: \"bddh n (fst A ! i)\"\n      and less_tr1: \"bdd_all (dfa_is_node A) (fst A ! i)\""], ["proof (prove)\nusing this:\n  wf_dfa A n\n  dfa_is_node A i\n\ngoal (1 subgoal):\n 1. bddh n (fst A ! i) &&& bdd_all (dfa_is_node A) (fst A ! i)", "by (simp add: wf_dfa_def list_all_iff dfa_is_node_def)+"], ["proof (state)\nthis:\n  bddh n (fst A ! i)\n  bdd_all (dfa_is_node A) (fst A ! i)\n\ngoal (1 subgoal):\n 1. wf_dfa (binop_dfa f A B) n", "from well_formed2 j"], ["proof (chain)\npicking this:\n  wf_dfa B n\n  dfa_is_node B j", "have bddh_tr2: \"bddh n (fst B ! j)\"\n      and less_tr2: \"bdd_all (dfa_is_node B) (fst B ! j)\""], ["proof (prove)\nusing this:\n  wf_dfa B n\n  dfa_is_node B j\n\ngoal (1 subgoal):\n 1. bddh n (fst B ! j) &&& bdd_all (dfa_is_node B) (fst B ! j)", "by (simp add: wf_dfa_def list_all_iff dfa_is_node_def)+"], ["proof (state)\nthis:\n  bddh n (fst B ! j)\n  bdd_all (dfa_is_node B) (fst B ! j)\n\ngoal (1 subgoal):\n 1. wf_dfa (binop_dfa f A B) n", "from bddh_tr1 bddh_tr2"], ["proof (chain)\npicking this:\n  bddh n (fst A ! i)\n  bddh n (fst B ! j)", "have 1: \"bddh n (bdd_binop (\\<lambda>k l. the (fst (prod_dfs A B (0, 0)) ! k ! l)) (fst A ! i) (fst B ! j))\""], ["proof (prove)\nusing this:\n  bddh n (fst A ! i)\n  bddh n (fst B ! j)\n\ngoal (1 subgoal):\n 1. bddh n\n     (bdd_binop (\\<lambda>k l. the (fst (prod_dfs A B (0, 0)) ! k ! l))\n       (fst A ! i) (fst B ! j))", "by (simp add: bddh_binop)"], ["proof (state)\nthis:\n  bddh n\n   (bdd_binop (\\<lambda>k l. the (fst (prod_dfs A B (0, 0)) ! k ! l))\n     (fst A ! i) (fst B ! j))\n\ngoal (1 subgoal):\n 1. wf_dfa (binop_dfa f A B) n", "have \"\\<forall>bs. length bs = n \\<longrightarrow> the (fst (prod_dfs A B (0, 0)) ! dfa_trans A i bs ! dfa_trans B j bs)\n      < length (snd (prod_dfs A B (0, 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>bs.\n       length bs = n \\<longrightarrow>\n       the (fst (prod_dfs A B (0, 0)) ! dfa_trans A i bs ! dfa_trans B j bs)\n       < length (snd (prod_dfs A B (0, 0)))", "proof (intro strip)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       length bs = n \\<Longrightarrow>\n       the (fst (prod_dfs A B (0, 0)) ! dfa_trans A i bs ! dfa_trans B j bs)\n       < length (snd (prod_dfs A B (0, 0)))", "fix bs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       length bs = n \\<Longrightarrow>\n       the (fst (prod_dfs A B (0, 0)) ! dfa_trans A i bs ! dfa_trans B j bs)\n       < length (snd (prod_dfs A B (0, 0)))", "assume bs: \"length (bs::bool list) = n\""], ["proof (state)\nthis:\n  length bs = n\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       length bs = n \\<Longrightarrow>\n       the (fst (prod_dfs A B (0, 0)) ! dfa_trans A i bs ! dfa_trans B j bs)\n       < length (snd (prod_dfs A B (0, 0)))", "moreover"], ["proof (state)\nthis:\n  length bs = n\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       length bs = n \\<Longrightarrow>\n       the (fst (prod_dfs A B (0, 0)) ! dfa_trans A i bs ! dfa_trans B j bs)\n       < length (snd (prod_dfs A B (0, 0)))", "note i j"], ["proof (state)\nthis:\n  dfa_is_node A i\n  dfa_is_node B j\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       length bs = n \\<Longrightarrow>\n       the (fst (prod_dfs A B (0, 0)) ! dfa_trans A i bs ! dfa_trans B j bs)\n       < length (snd (prod_dfs A B (0, 0)))", "moreover"], ["proof (state)\nthis:\n  dfa_is_node A i\n  dfa_is_node B j\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       length bs = n \\<Longrightarrow>\n       the (fst (prod_dfs A B (0, 0)) ! dfa_trans A i bs ! dfa_trans B j bs)\n       < length (snd (prod_dfs A B (0, 0)))", "from well_formed1 well_formed2"], ["proof (chain)\npicking this:\n  wf_dfa A n\n  wf_dfa B n", "have \"dfa_is_node A 0\" and \"dfa_is_node B 0\""], ["proof (prove)\nusing this:\n  wf_dfa A n\n  wf_dfa B n\n\ngoal (1 subgoal):\n 1. dfa_is_node A 0 &&& dfa_is_node B 0", "by (simp add: dfa_is_node_def wf_dfa_def)+"], ["proof (state)\nthis:\n  dfa_is_node A 0\n  dfa_is_node B 0\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       length bs = n \\<Longrightarrow>\n       the (fst (prod_dfs A B (0, 0)) ! dfa_trans A i bs ! dfa_trans B j bs)\n       < length (snd (prod_dfs A B (0, 0)))", "moreover"], ["proof (state)\nthis:\n  dfa_is_node A 0\n  dfa_is_node B 0\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       length bs = n \\<Longrightarrow>\n       the (fst (prod_dfs A B (0, 0)) ! dfa_trans A i bs ! dfa_trans B j bs)\n       < length (snd (prod_dfs A B (0, 0)))", "note ij_k"], ["proof (state)\nthis:\n  fst (prod_dfs A B (0, 0)) ! i ! j = Some k\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       length bs = n \\<Longrightarrow>\n       the (fst (prod_dfs A B (0, 0)) ! dfa_trans A i bs ! dfa_trans B j bs)\n       < length (snd (prod_dfs A B (0, 0)))", "ultimately"], ["proof (chain)\npicking this:\n  length bs = n\n  dfa_is_node A i\n  dfa_is_node B j\n  dfa_is_node A 0\n  dfa_is_node B 0\n  fst (prod_dfs A B (0, 0)) ! i ! j = Some k", "obtain m where \"fst (prod_dfs A B (0, 0)) ! dfa_trans A i bs ! dfa_trans B j bs = Some m\"\n        and \"m < length (snd (prod_dfs A B (0, 0)))\""], ["proof (prove)\nusing this:\n  length bs = n\n  dfa_is_node A i\n  dfa_is_node B j\n  dfa_is_node A 0\n  dfa_is_node B 0\n  fst (prod_dfs A B (0, 0)) ! i ! j = Some k\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>fst (prod_dfs A B (0, 0)) ! dfa_trans A i bs !\n                 dfa_trans B j bs =\n                 Some m;\n         m < length (snd (prod_dfs A B (0, 0)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule prod_dfs_statetrans)"], ["proof (state)\nthis:\n  fst (prod_dfs A B (0, 0)) ! dfa_trans A i bs ! dfa_trans B j bs = Some m\n  m < length (snd (prod_dfs A B (0, 0)))\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       length bs = n \\<Longrightarrow>\n       the (fst (prod_dfs A B (0, 0)) ! dfa_trans A i bs ! dfa_trans B j bs)\n       < length (snd (prod_dfs A B (0, 0)))", "then"], ["proof (chain)\npicking this:\n  fst (prod_dfs A B (0, 0)) ! dfa_trans A i bs ! dfa_trans B j bs = Some m\n  m < length (snd (prod_dfs A B (0, 0)))", "show \"the (fst (prod_dfs A B (0,0)) ! dfa_trans A i bs ! dfa_trans B j bs) < length (snd (prod_dfs A B (0,0)))\""], ["proof (prove)\nusing this:\n  fst (prod_dfs A B (0, 0)) ! dfa_trans A i bs ! dfa_trans B j bs = Some m\n  m < length (snd (prod_dfs A B (0, 0)))\n\ngoal (1 subgoal):\n 1. the (fst (prod_dfs A B (0, 0)) ! dfa_trans A i bs ! dfa_trans B j bs)\n    < length (snd (prod_dfs A B (0, 0)))", "by simp"], ["proof (state)\nthis:\n  the (fst (prod_dfs A B (0, 0)) ! dfa_trans A i bs ! dfa_trans B j bs)\n  < length (snd (prod_dfs A B (0, 0)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>bs.\n     length bs = n \\<longrightarrow>\n     the (fst (prod_dfs A B (0, 0)) ! dfa_trans A i bs ! dfa_trans B j bs)\n     < length (snd (prod_dfs A B (0, 0)))\n\ngoal (1 subgoal):\n 1. wf_dfa (binop_dfa f A B) n", "with bddh_tr1 bddh_tr2"], ["proof (chain)\npicking this:\n  bddh n (fst A ! i)\n  bddh n (fst B ! j)\n  \\<forall>bs.\n     length bs = n \\<longrightarrow>\n     the (fst (prod_dfs A B (0, 0)) ! dfa_trans A i bs ! dfa_trans B j bs)\n     < length (snd (prod_dfs A B (0, 0)))", "have 2: \"bdd_all (\\<lambda>q. q < length (snd (prod_dfs A B (0, 0)))) (bdd_binop (\\<lambda>k l. the (fst (prod_dfs A B (0,0)) ! k ! l)) (fst A ! i) (fst B ! j))\""], ["proof (prove)\nusing this:\n  bddh n (fst A ! i)\n  bddh n (fst B ! j)\n  \\<forall>bs.\n     length bs = n \\<longrightarrow>\n     the (fst (prod_dfs A B (0, 0)) ! dfa_trans A i bs ! dfa_trans B j bs)\n     < length (snd (prod_dfs A B (0, 0)))\n\ngoal (1 subgoal):\n 1. bdd_all (\\<lambda>q. q < length (snd (prod_dfs A B (0, 0))))\n     (bdd_binop (\\<lambda>k l. the (fst (prod_dfs A B (0, 0)) ! k ! l))\n       (fst A ! i) (fst B ! j))", "by (simp add: bddh_binop bdd_lookup_binop bdd_all_bdd_lookup_iff[of n _ \"\\<lambda>x. x < length (snd (prod_dfs A B (0,0)))\"] dfa_trans_def)"], ["proof (state)\nthis:\n  bdd_all (\\<lambda>q. q < length (snd (prod_dfs A B (0, 0))))\n   (bdd_binop (\\<lambda>k l. the (fst (prod_dfs A B (0, 0)) ! k ! l))\n     (fst A ! i) (fst B ! j))\n\ngoal (1 subgoal):\n 1. wf_dfa (binop_dfa f A B) n", "note this 1"], ["proof (state)\nthis:\n  bdd_all (\\<lambda>q. q < length (snd (prod_dfs A B (0, 0))))\n   (bdd_binop (\\<lambda>k l. the (fst (prod_dfs A B (0, 0)) ! k ! l))\n     (fst A ! i) (fst B ! j))\n  bddh n\n   (bdd_binop (\\<lambda>k l. the (fst (prod_dfs A B (0, 0)) ! k ! l))\n     (fst A ! i) (fst B ! j))\n\ngoal (1 subgoal):\n 1. wf_dfa (binop_dfa f A B) n", "}"], ["proof (state)\nthis:\n  (?i2, ?j2) \\<in> set (snd (prod_dfs A B (0, 0))) \\<Longrightarrow>\n  bdd_all (\\<lambda>q. q < length (snd (prod_dfs A B (0, 0))))\n   (bdd_binop (\\<lambda>k l. the (fst (prod_dfs A B (0, 0)) ! k ! l))\n     (fst A ! ?i2) (fst B ! ?j2))\n  (?i2, ?j2) \\<in> set (snd (prod_dfs A B (0, 0))) \\<Longrightarrow>\n  bddh n\n   (bdd_binop (\\<lambda>k l. the (fst (prod_dfs A B (0, 0)) ! k ! l))\n     (fst A ! ?i2) (fst B ! ?j2))\n\ngoal (1 subgoal):\n 1. wf_dfa (binop_dfa f A B) n", "hence 1: \"list_all (bddh n) ?tr\" and 2: \"list_all (bdd_all (\\<lambda>q. q < length ?tr)) ?tr\""], ["proof (prove)\nusing this:\n  (?i2, ?j2) \\<in> set (snd (prod_dfs A B (0, 0))) \\<Longrightarrow>\n  bdd_all (\\<lambda>q. q < length (snd (prod_dfs A B (0, 0))))\n   (bdd_binop (\\<lambda>k l. the (fst (prod_dfs A B (0, 0)) ! k ! l))\n     (fst A ! ?i2) (fst B ! ?j2))\n  (?i2, ?j2) \\<in> set (snd (prod_dfs A B (0, 0))) \\<Longrightarrow>\n  bddh n\n   (bdd_binop (\\<lambda>k l. the (fst (prod_dfs A B (0, 0)) ! k ! l))\n     (fst A ! ?i2) (fst B ! ?j2))\n\ngoal (1 subgoal):\n 1. list_all (bddh n)\n     (map (\\<lambda>(i, j).\n              bdd_binop\n               (\\<lambda>k l. the (fst (prod_dfs A B (0, 0)) ! k ! l))\n               (fst A ! i) (fst B ! j))\n       (snd (prod_dfs A B (0, 0)))) &&&\n    list_all\n     (bdd_all\n       (\\<lambda>q.\n           q < length\n                (map (\\<lambda>(i, j).\n                         bdd_binop\n                          (\\<lambda>k l.\n                              the (fst (prod_dfs A B (0, 0)) ! k ! l))\n                          (fst A ! i) (fst B ! j))\n                  (snd (prod_dfs A B (0, 0))))))\n     (map (\\<lambda>(i, j).\n              bdd_binop\n               (\\<lambda>k l. the (fst (prod_dfs A B (0, 0)) ! k ! l))\n               (fst A ! i) (fst B ! j))\n       (snd (prod_dfs A B (0, 0))))", "by (auto simp: split_paired_all list_all_iff)"], ["proof (state)\nthis:\n  list_all (bddh n)\n   (map (\\<lambda>(i, j).\n            bdd_binop\n             (\\<lambda>k l. the (fst (prod_dfs A B (0, 0)) ! k ! l))\n             (fst A ! i) (fst B ! j))\n     (snd (prod_dfs A B (0, 0))))\n  list_all\n   (bdd_all\n     (\\<lambda>q.\n         q < length\n              (map (\\<lambda>(i, j).\n                       bdd_binop\n                        (\\<lambda>k l.\n                            the (fst (prod_dfs A B (0, 0)) ! k ! l))\n                        (fst A ! i) (fst B ! j))\n                (snd (prod_dfs A B (0, 0))))))\n   (map (\\<lambda>(i, j).\n            bdd_binop\n             (\\<lambda>k l. the (fst (prod_dfs A B (0, 0)) ! k ! l))\n             (fst A ! i) (fst B ! j))\n     (snd (prod_dfs A B (0, 0))))\n\ngoal (1 subgoal):\n 1. wf_dfa (binop_dfa f A B) n", "from well_formed1 well_formed2"], ["proof (chain)\npicking this:\n  wf_dfa A n\n  wf_dfa B n", "have 3: \"fst (prod_dfs A B (0, 0)) ! 0 ! 0 = Some 0\""], ["proof (prove)\nusing this:\n  wf_dfa A n\n  wf_dfa B n\n\ngoal (1 subgoal):\n 1. fst (prod_dfs A B (0, 0)) ! 0 ! 0 = Some 0", "by (simp add: wf_dfa_def dfa_is_node_def prod_dfs_start)"], ["proof (state)\nthis:\n  fst (prod_dfs A B (0, 0)) ! 0 ! 0 = Some 0\n\ngoal (1 subgoal):\n 1. wf_dfa (binop_dfa f A B) n", "from is_node_s1_s2"], ["proof (chain)\npicking this:\n  prod_is_node A B (0, 0)", "have \"(fst (prod_dfs A B (0,0)) ! 0 ! 0 = Some 0 \\<and> dfa_is_node A 0 \\<and> dfa_is_node B 0) =\n    (0 < length (snd (prod_dfs A B (0,0))) \\<and> snd (prod_dfs A B (0,0)) ! 0 = (0,0))\""], ["proof (prove)\nusing this:\n  prod_is_node A B (0, 0)\n\ngoal (1 subgoal):\n 1. (fst (prod_dfs A B (0, 0)) ! 0 ! 0 = Some 0 \\<and>\n     dfa_is_node A 0 \\<and> dfa_is_node B 0) =\n    (0 < length (snd (prod_dfs A B (0, 0))) \\<and>\n     snd (prod_dfs A B (0, 0)) ! 0 = (0, 0))", "by (rule prod_dfs_bij)"], ["proof (state)\nthis:\n  (fst (prod_dfs A B (0, 0)) ! 0 ! 0 = Some 0 \\<and>\n   dfa_is_node A 0 \\<and> dfa_is_node B 0) =\n  (0 < length (snd (prod_dfs A B (0, 0))) \\<and>\n   snd (prod_dfs A B (0, 0)) ! 0 = (0, 0))\n\ngoal (1 subgoal):\n 1. wf_dfa (binop_dfa f A B) n", "with 3 well_formed1 well_formed2"], ["proof (chain)\npicking this:\n  fst (prod_dfs A B (0, 0)) ! 0 ! 0 = Some 0\n  wf_dfa A n\n  wf_dfa B n\n  (fst (prod_dfs A B (0, 0)) ! 0 ! 0 = Some 0 \\<and>\n   dfa_is_node A 0 \\<and> dfa_is_node B 0) =\n  (0 < length (snd (prod_dfs A B (0, 0))) \\<and>\n   snd (prod_dfs A B (0, 0)) ! 0 = (0, 0))", "have \"0 < length (snd (prod_dfs A B (0,0)))\""], ["proof (prove)\nusing this:\n  fst (prod_dfs A B (0, 0)) ! 0 ! 0 = Some 0\n  wf_dfa A n\n  wf_dfa B n\n  (fst (prod_dfs A B (0, 0)) ! 0 ! 0 = Some 0 \\<and>\n   dfa_is_node A 0 \\<and> dfa_is_node B 0) =\n  (0 < length (snd (prod_dfs A B (0, 0))) \\<and>\n   snd (prod_dfs A B (0, 0)) ! 0 = (0, 0))\n\ngoal (1 subgoal):\n 1. 0 < length (snd (prod_dfs A B (0, 0)))", "by (simp add: wf_dfa_def dfa_is_node_def)"], ["proof (state)\nthis:\n  0 < length (snd (prod_dfs A B (0, 0)))\n\ngoal (1 subgoal):\n 1. wf_dfa (binop_dfa f A B) n", "with 1 2 3"], ["proof (chain)\npicking this:\n  list_all (bddh n)\n   (map (\\<lambda>(i, j).\n            bdd_binop\n             (\\<lambda>k l. the (fst (prod_dfs A B (0, 0)) ! k ! l))\n             (fst A ! i) (fst B ! j))\n     (snd (prod_dfs A B (0, 0))))\n  list_all\n   (bdd_all\n     (\\<lambda>q.\n         q < length\n              (map (\\<lambda>(i, j).\n                       bdd_binop\n                        (\\<lambda>k l.\n                            the (fst (prod_dfs A B (0, 0)) ! k ! l))\n                        (fst A ! i) (fst B ! j))\n                (snd (prod_dfs A B (0, 0))))))\n   (map (\\<lambda>(i, j).\n            bdd_binop\n             (\\<lambda>k l. the (fst (prod_dfs A B (0, 0)) ! k ! l))\n             (fst A ! i) (fst B ! j))\n     (snd (prod_dfs A B (0, 0))))\n  fst (prod_dfs A B (0, 0)) ! 0 ! 0 = Some 0\n  0 < length (snd (prod_dfs A B (0, 0)))", "show \"wf_dfa (binop_dfa f A B) n\""], ["proof (prove)\nusing this:\n  list_all (bddh n)\n   (map (\\<lambda>(i, j).\n            bdd_binop\n             (\\<lambda>k l. the (fst (prod_dfs A B (0, 0)) ! k ! l))\n             (fst A ! i) (fst B ! j))\n     (snd (prod_dfs A B (0, 0))))\n  list_all\n   (bdd_all\n     (\\<lambda>q.\n         q < length\n              (map (\\<lambda>(i, j).\n                       bdd_binop\n                        (\\<lambda>k l.\n                            the (fst (prod_dfs A B (0, 0)) ! k ! l))\n                        (fst A ! i) (fst B ! j))\n                (snd (prod_dfs A B (0, 0))))))\n   (map (\\<lambda>(i, j).\n            bdd_binop\n             (\\<lambda>k l. the (fst (prod_dfs A B (0, 0)) ! k ! l))\n             (fst A ! i) (fst B ! j))\n     (snd (prod_dfs A B (0, 0))))\n  fst (prod_dfs A B (0, 0)) ! 0 ! 0 = Some 0\n  0 < length (snd (prod_dfs A B (0, 0)))\n\ngoal (1 subgoal):\n 1. wf_dfa (binop_dfa f A B) n", "by (simp add: binop_dfa_def wf_dfa_def split_beta dfa_is_node_def)"], ["proof (state)\nthis:\n  wf_dfa (binop_dfa f A B) n\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem binop_dfa_reachable:\n  assumes bss: \"list_all (is_alph n) bss\"\n  shows \"(\\<exists>m. dfa_reach (binop_dfa f A B) 0 bss m \\<and>\n    fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some m \\<and>\n    dfa_is_node A s\\<^sub>1 \\<and> dfa_is_node B s\\<^sub>2) =\n   (dfa_reach A 0 bss s\\<^sub>1 \\<and> dfa_reach B 0 bss s\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>m.\n        dfa_reach (binop_dfa f A B) 0 bss m \\<and>\n        fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some m \\<and>\n        dfa_is_node A s\\<^sub>1 \\<and> dfa_is_node B s\\<^sub>2) =\n    (dfa_reach A 0 bss s\\<^sub>1 \\<and> dfa_reach B 0 bss s\\<^sub>2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<exists>m.\n        dfa_reach (binop_dfa f A B) 0 bss m \\<and>\n        fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some m \\<and>\n        dfa_is_node A s\\<^sub>1 \\<and> dfa_is_node B s\\<^sub>2) =\n    (dfa_reach A 0 bss s\\<^sub>1 \\<and> dfa_reach B 0 bss s\\<^sub>2)", "let ?tr = \"map (\\<lambda>(i, j).\n    bdd_binop (\\<lambda>k l. the (fst (prod_dfs A B (0,0)) ! k ! l)) (fst A ! i) (fst B ! j))\n      (snd (prod_dfs A B (0,0)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<exists>m.\n        dfa_reach (binop_dfa f A B) 0 bss m \\<and>\n        fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some m \\<and>\n        dfa_is_node A s\\<^sub>1 \\<and> dfa_is_node B s\\<^sub>2) =\n    (dfa_reach A 0 bss s\\<^sub>1 \\<and> dfa_reach B 0 bss s\\<^sub>2)", "have T: \"?tr = fst (binop_dfa f A B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>(i, j).\n            bdd_binop\n             (\\<lambda>k l. the (fst (prod_dfs A B (0, 0)) ! k ! l))\n             (fst A ! i) (fst B ! j))\n     (snd (prod_dfs A B (0, 0))) =\n    fst (binop_dfa f A B)", "by (simp add: binop_dfa_def split_beta)"], ["proof (state)\nthis:\n  map (\\<lambda>(i, j).\n          bdd_binop (\\<lambda>k l. the (fst (prod_dfs A B (0, 0)) ! k ! l))\n           (fst A ! i) (fst B ! j))\n   (snd (prod_dfs A B (0, 0))) =\n  fst (binop_dfa f A B)\n\ngoal (1 subgoal):\n 1. (\\<exists>m.\n        dfa_reach (binop_dfa f A B) 0 bss m \\<and>\n        fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some m \\<and>\n        dfa_is_node A s\\<^sub>1 \\<and> dfa_is_node B s\\<^sub>2) =\n    (dfa_reach A 0 bss s\\<^sub>1 \\<and> dfa_reach B 0 bss s\\<^sub>2)", "from well_formed1 well_formed2"], ["proof (chain)\npicking this:\n  wf_dfa A n\n  wf_dfa B n", "have is_node_s1_s2: \"prod_is_node A B (0, 0)\""], ["proof (prove)\nusing this:\n  wf_dfa A n\n  wf_dfa B n\n\ngoal (1 subgoal):\n 1. prod_is_node A B (0, 0)", "by (simp add: prod_is_node_def wf_dfa_def dfa_is_node_def)"], ["proof (state)\nthis:\n  prod_is_node A B (0, 0)\n\ngoal (1 subgoal):\n 1. (\\<exists>m.\n        dfa_reach (binop_dfa f A B) 0 bss m \\<and>\n        fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some m \\<and>\n        dfa_is_node A s\\<^sub>1 \\<and> dfa_is_node B s\\<^sub>2) =\n    (dfa_reach A 0 bss s\\<^sub>1 \\<and> dfa_reach B 0 bss s\\<^sub>2)", "from well_formed1 well_formed2"], ["proof (chain)\npicking this:\n  wf_dfa A n\n  wf_dfa B n", "have s1: \"dfa_is_node A 0\" and s2: \"dfa_is_node B 0\""], ["proof (prove)\nusing this:\n  wf_dfa A n\n  wf_dfa B n\n\ngoal (1 subgoal):\n 1. dfa_is_node A 0 &&& dfa_is_node B 0", "by (simp add: dfa_is_node_def wf_dfa_def)+"], ["proof (state)\nthis:\n  dfa_is_node A 0\n  dfa_is_node B 0\n\ngoal (1 subgoal):\n 1. (\\<exists>m.\n        dfa_reach (binop_dfa f A B) 0 bss m \\<and>\n        fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some m \\<and>\n        dfa_is_node A s\\<^sub>1 \\<and> dfa_is_node B s\\<^sub>2) =\n    (dfa_reach A 0 bss s\\<^sub>1 \\<and> dfa_reach B 0 bss s\\<^sub>2)", "from s1 s2"], ["proof (chain)\npicking this:\n  dfa_is_node A 0\n  dfa_is_node B 0", "have start: \"fst (prod_dfs A B (0,0)) ! 0 ! 0 = Some 0\""], ["proof (prove)\nusing this:\n  dfa_is_node A 0\n  dfa_is_node B 0\n\ngoal (1 subgoal):\n 1. fst (prod_dfs A B (0, 0)) ! 0 ! 0 = Some 0", "by (rule prod_dfs_start)"], ["proof (state)\nthis:\n  fst (prod_dfs A B (0, 0)) ! 0 ! 0 = Some 0\n\ngoal (1 subgoal):\n 1. (\\<exists>m.\n        dfa_reach (binop_dfa f A B) 0 bss m \\<and>\n        fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some m \\<and>\n        dfa_is_node A s\\<^sub>1 \\<and> dfa_is_node B s\\<^sub>2) =\n    (dfa_reach A 0 bss s\\<^sub>1 \\<and> dfa_reach B 0 bss s\\<^sub>2)", "show \"(\\<exists>m. dfa_reach (binop_dfa f A B) 0 bss m \\<and>\n     fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some m \\<and>\n     dfa_is_node A s\\<^sub>1 \\<and> dfa_is_node B s\\<^sub>2) =\n    (dfa_reach A 0 bss s\\<^sub>1 \\<and> dfa_reach B 0 bss s\\<^sub>2)\"\n    (is \"(\\<exists>m. ?lhs1 m \\<and> ?lhs2 m \\<and> ?lhs3 \\<and> ?lhs4) = ?rhs\"\n     is \"?lhs = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>m.\n        dfa_reach (binop_dfa f A B) 0 bss m \\<and>\n        fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some m \\<and>\n        dfa_is_node A s\\<^sub>1 \\<and> dfa_is_node B s\\<^sub>2) =\n    (dfa_reach A 0 bss s\\<^sub>1 \\<and> dfa_reach B 0 bss s\\<^sub>2)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>m.\n       dfa_reach (binop_dfa f A B) 0 bss m \\<and>\n       fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some m \\<and>\n       dfa_is_node A s\\<^sub>1 \\<and>\n       dfa_is_node B s\\<^sub>2 \\<Longrightarrow>\n    dfa_reach A 0 bss s\\<^sub>1 \\<and> dfa_reach B 0 bss s\\<^sub>2\n 2. dfa_reach A 0 bss s\\<^sub>1 \\<and>\n    dfa_reach B 0 bss s\\<^sub>2 \\<Longrightarrow>\n    \\<exists>m.\n       dfa_reach (binop_dfa f A B) 0 bss m \\<and>\n       fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some m \\<and>\n       dfa_is_node A s\\<^sub>1 \\<and> dfa_is_node B s\\<^sub>2", "assume \"\\<exists>m. ?lhs1 m \\<and> ?lhs2 m \\<and> ?lhs3 \\<and> ?lhs4\""], ["proof (state)\nthis:\n  \\<exists>m.\n     dfa_reach (binop_dfa f A B) 0 bss m \\<and>\n     fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some m \\<and>\n     dfa_is_node A s\\<^sub>1 \\<and> dfa_is_node B s\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<exists>m.\n       dfa_reach (binop_dfa f A B) 0 bss m \\<and>\n       fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some m \\<and>\n       dfa_is_node A s\\<^sub>1 \\<and>\n       dfa_is_node B s\\<^sub>2 \\<Longrightarrow>\n    dfa_reach A 0 bss s\\<^sub>1 \\<and> dfa_reach B 0 bss s\\<^sub>2\n 2. dfa_reach A 0 bss s\\<^sub>1 \\<and>\n    dfa_reach B 0 bss s\\<^sub>2 \\<Longrightarrow>\n    \\<exists>m.\n       dfa_reach (binop_dfa f A B) 0 bss m \\<and>\n       fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some m \\<and>\n       dfa_is_node A s\\<^sub>1 \\<and> dfa_is_node B s\\<^sub>2", "then"], ["proof (chain)\npicking this:\n  \\<exists>m.\n     dfa_reach (binop_dfa f A B) 0 bss m \\<and>\n     fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some m \\<and>\n     dfa_is_node A s\\<^sub>1 \\<and> dfa_is_node B s\\<^sub>2", "obtain m where lhs: \"?lhs1 m\" \"?lhs2 m\" \"?lhs3\" \"?lhs4\""], ["proof (prove)\nusing this:\n  \\<exists>m.\n     dfa_reach (binop_dfa f A B) 0 bss m \\<and>\n     fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some m \\<and>\n     dfa_is_node A s\\<^sub>1 \\<and> dfa_is_node B s\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>dfa_reach (binop_dfa f A B) 0 bss m;\n         fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some m;\n         dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  dfa_reach (binop_dfa f A B) 0 bss m\n  fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some m\n  dfa_is_node A s\\<^sub>1\n  dfa_is_node B s\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<exists>m.\n       dfa_reach (binop_dfa f A B) 0 bss m \\<and>\n       fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some m \\<and>\n       dfa_is_node A s\\<^sub>1 \\<and>\n       dfa_is_node B s\\<^sub>2 \\<Longrightarrow>\n    dfa_reach A 0 bss s\\<^sub>1 \\<and> dfa_reach B 0 bss s\\<^sub>2\n 2. dfa_reach A 0 bss s\\<^sub>1 \\<and>\n    dfa_reach B 0 bss s\\<^sub>2 \\<Longrightarrow>\n    \\<exists>m.\n       dfa_reach (binop_dfa f A B) 0 bss m \\<and>\n       fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some m \\<and>\n       dfa_is_node A s\\<^sub>1 \\<and> dfa_is_node B s\\<^sub>2", "from lhs bss"], ["proof (chain)\npicking this:\n  dfa_reach (binop_dfa f A B) 0 bss m\n  fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some m\n  dfa_is_node A s\\<^sub>1\n  dfa_is_node B s\\<^sub>2\n  list_all (is_alph n) bss", "show ?rhs"], ["proof (prove)\nusing this:\n  dfa_reach (binop_dfa f A B) 0 bss m\n  fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some m\n  dfa_is_node A s\\<^sub>1\n  dfa_is_node B s\\<^sub>2\n  list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. dfa_reach A 0 bss s\\<^sub>1 \\<and> dfa_reach B 0 bss s\\<^sub>2", "proof (induct arbitrary: s\\<^sub>1 s\\<^sub>2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2.\n       \\<lbrakk>fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some 0;\n        dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> dfa_reach A 0 [] s\\<^sub>1 \\<and>\n                         dfa_reach B 0 [] s\\<^sub>2\n 2. \\<And>k x y s\\<^sub>1 s\\<^sub>2.\n       \\<lbrakk>dfa_reach (binop_dfa f A B) 0 x k;\n        \\<And>s\\<^sub>1 s\\<^sub>2.\n           \\<lbrakk>fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n                    Some k;\n            dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach A 0 x s\\<^sub>1 \\<and>\n                             dfa_reach B 0 x s\\<^sub>2;\n        fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n        Some (dfa_trans (binop_dfa f A B) k y);\n        dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach A 0 (x @ [y]) s\\<^sub>1 \\<and>\n                         dfa_reach B 0 (x @ [y]) s\\<^sub>2", "case Nil"], ["proof (state)\nthis:\n  fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some 0\n  dfa_is_node A s\\<^sub>1\n  dfa_is_node B s\\<^sub>2\n  list_all (is_alph n) []\n\ngoal (2 subgoals):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2.\n       \\<lbrakk>fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some 0;\n        dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> dfa_reach A 0 [] s\\<^sub>1 \\<and>\n                         dfa_reach B 0 [] s\\<^sub>2\n 2. \\<And>k x y s\\<^sub>1 s\\<^sub>2.\n       \\<lbrakk>dfa_reach (binop_dfa f A B) 0 x k;\n        \\<And>s\\<^sub>1 s\\<^sub>2.\n           \\<lbrakk>fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n                    Some k;\n            dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach A 0 x s\\<^sub>1 \\<and>\n                             dfa_reach B 0 x s\\<^sub>2;\n        fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n        Some (dfa_trans (binop_dfa f A B) k y);\n        dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach A 0 (x @ [y]) s\\<^sub>1 \\<and>\n                         dfa_reach B 0 (x @ [y]) s\\<^sub>2", "from is_node_s1_s2\n        s1 s2 \\<open>dfa_is_node A s\\<^sub>1\\<close> \\<open>dfa_is_node B s\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  prod_is_node A B (0, 0)\n  dfa_is_node A 0\n  dfa_is_node B 0\n  dfa_is_node A s\\<^sub>1\n  dfa_is_node B s\\<^sub>2", "have \"(0, 0) = (s\\<^sub>1, s\\<^sub>2)\""], ["proof (prove)\nusing this:\n  prod_is_node A B (0, 0)\n  dfa_is_node A 0\n  dfa_is_node B 0\n  dfa_is_node A s\\<^sub>1\n  dfa_is_node B s\\<^sub>2\n\ngoal (1 subgoal):\n 1. (0, 0) = (s\\<^sub>1, s\\<^sub>2)", "using start \\<open>fst (prod_dfs A B (0,0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some 0\\<close>"], ["proof (prove)\nusing this:\n  prod_is_node A B (0, 0)\n  dfa_is_node A 0\n  dfa_is_node B 0\n  dfa_is_node A s\\<^sub>1\n  dfa_is_node B s\\<^sub>2\n  fst (prod_dfs A B (0, 0)) ! 0 ! 0 = Some 0\n  fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some 0\n\ngoal (1 subgoal):\n 1. (0, 0) = (s\\<^sub>1, s\\<^sub>2)", "by (rule prod_dfs_inj)"], ["proof (state)\nthis:\n  (0, 0) = (s\\<^sub>1, s\\<^sub>2)\n\ngoal (2 subgoals):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2.\n       \\<lbrakk>fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some 0;\n        dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> dfa_reach A 0 [] s\\<^sub>1 \\<and>\n                         dfa_reach B 0 [] s\\<^sub>2\n 2. \\<And>k x y s\\<^sub>1 s\\<^sub>2.\n       \\<lbrakk>dfa_reach (binop_dfa f A B) 0 x k;\n        \\<And>s\\<^sub>1 s\\<^sub>2.\n           \\<lbrakk>fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n                    Some k;\n            dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach A 0 x s\\<^sub>1 \\<and>\n                             dfa_reach B 0 x s\\<^sub>2;\n        fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n        Some (dfa_trans (binop_dfa f A B) k y);\n        dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach A 0 (x @ [y]) s\\<^sub>1 \\<and>\n                         dfa_reach B 0 (x @ [y]) s\\<^sub>2", "moreover"], ["proof (state)\nthis:\n  (0, 0) = (s\\<^sub>1, s\\<^sub>2)\n\ngoal (2 subgoals):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2.\n       \\<lbrakk>fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some 0;\n        dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> dfa_reach A 0 [] s\\<^sub>1 \\<and>\n                         dfa_reach B 0 [] s\\<^sub>2\n 2. \\<And>k x y s\\<^sub>1 s\\<^sub>2.\n       \\<lbrakk>dfa_reach (binop_dfa f A B) 0 x k;\n        \\<And>s\\<^sub>1 s\\<^sub>2.\n           \\<lbrakk>fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n                    Some k;\n            dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach A 0 x s\\<^sub>1 \\<and>\n                             dfa_reach B 0 x s\\<^sub>2;\n        fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n        Some (dfa_trans (binop_dfa f A B) k y);\n        dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach A 0 (x @ [y]) s\\<^sub>1 \\<and>\n                         dfa_reach B 0 (x @ [y]) s\\<^sub>2", "have \"dfa_reach A 0 [] 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa_reach A 0 [] 0", "by (rule reach_nil)"], ["proof (state)\nthis:\n  dfa_reach A 0 [] 0\n\ngoal (2 subgoals):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2.\n       \\<lbrakk>fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some 0;\n        dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> dfa_reach A 0 [] s\\<^sub>1 \\<and>\n                         dfa_reach B 0 [] s\\<^sub>2\n 2. \\<And>k x y s\\<^sub>1 s\\<^sub>2.\n       \\<lbrakk>dfa_reach (binop_dfa f A B) 0 x k;\n        \\<And>s\\<^sub>1 s\\<^sub>2.\n           \\<lbrakk>fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n                    Some k;\n            dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach A 0 x s\\<^sub>1 \\<and>\n                             dfa_reach B 0 x s\\<^sub>2;\n        fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n        Some (dfa_trans (binop_dfa f A B) k y);\n        dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach A 0 (x @ [y]) s\\<^sub>1 \\<and>\n                         dfa_reach B 0 (x @ [y]) s\\<^sub>2", "moreover"], ["proof (state)\nthis:\n  dfa_reach A 0 [] 0\n\ngoal (2 subgoals):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2.\n       \\<lbrakk>fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some 0;\n        dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> dfa_reach A 0 [] s\\<^sub>1 \\<and>\n                         dfa_reach B 0 [] s\\<^sub>2\n 2. \\<And>k x y s\\<^sub>1 s\\<^sub>2.\n       \\<lbrakk>dfa_reach (binop_dfa f A B) 0 x k;\n        \\<And>s\\<^sub>1 s\\<^sub>2.\n           \\<lbrakk>fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n                    Some k;\n            dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach A 0 x s\\<^sub>1 \\<and>\n                             dfa_reach B 0 x s\\<^sub>2;\n        fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n        Some (dfa_trans (binop_dfa f A B) k y);\n        dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach A 0 (x @ [y]) s\\<^sub>1 \\<and>\n                         dfa_reach B 0 (x @ [y]) s\\<^sub>2", "have \"dfa_reach B 0 [] 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa_reach B 0 [] 0", "by (rule reach_nil)"], ["proof (state)\nthis:\n  dfa_reach B 0 [] 0\n\ngoal (2 subgoals):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2.\n       \\<lbrakk>fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some 0;\n        dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> dfa_reach A 0 [] s\\<^sub>1 \\<and>\n                         dfa_reach B 0 [] s\\<^sub>2\n 2. \\<And>k x y s\\<^sub>1 s\\<^sub>2.\n       \\<lbrakk>dfa_reach (binop_dfa f A B) 0 x k;\n        \\<And>s\\<^sub>1 s\\<^sub>2.\n           \\<lbrakk>fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n                    Some k;\n            dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach A 0 x s\\<^sub>1 \\<and>\n                             dfa_reach B 0 x s\\<^sub>2;\n        fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n        Some (dfa_trans (binop_dfa f A B) k y);\n        dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach A 0 (x @ [y]) s\\<^sub>1 \\<and>\n                         dfa_reach B 0 (x @ [y]) s\\<^sub>2", "ultimately"], ["proof (chain)\npicking this:\n  (0, 0) = (s\\<^sub>1, s\\<^sub>2)\n  dfa_reach A 0 [] 0\n  dfa_reach B 0 [] 0", "show ?case"], ["proof (prove)\nusing this:\n  (0, 0) = (s\\<^sub>1, s\\<^sub>2)\n  dfa_reach A 0 [] 0\n  dfa_reach B 0 [] 0\n\ngoal (1 subgoal):\n 1. dfa_reach A 0 [] s\\<^sub>1 \\<and> dfa_reach B 0 [] s\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  dfa_reach A 0 [] s\\<^sub>1 \\<and> dfa_reach B 0 [] s\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>k x y s\\<^sub>1 s\\<^sub>2.\n       \\<lbrakk>dfa_reach (binop_dfa f A B) 0 x k;\n        \\<And>s\\<^sub>1 s\\<^sub>2.\n           \\<lbrakk>fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n                    Some k;\n            dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach A 0 x s\\<^sub>1 \\<and>\n                             dfa_reach B 0 x s\\<^sub>2;\n        fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n        Some (dfa_trans (binop_dfa f A B) k y);\n        dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach A 0 (x @ [y]) s\\<^sub>1 \\<and>\n                         dfa_reach B 0 (x @ [y]) s\\<^sub>2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k x y s\\<^sub>1 s\\<^sub>2.\n       \\<lbrakk>dfa_reach (binop_dfa f A B) 0 x k;\n        \\<And>s\\<^sub>1 s\\<^sub>2.\n           \\<lbrakk>fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n                    Some k;\n            dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach A 0 x s\\<^sub>1 \\<and>\n                             dfa_reach B 0 x s\\<^sub>2;\n        fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n        Some (dfa_trans (binop_dfa f A B) k y);\n        dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach A 0 (x @ [y]) s\\<^sub>1 \\<and>\n                         dfa_reach B 0 (x @ [y]) s\\<^sub>2", "case (snoc j bss bs s\\<^sub>1 s\\<^sub>2)"], ["proof (state)\nthis:\n  dfa_reach (binop_dfa f A B) 0 bss j\n  \\<lbrakk>fst (prod_dfs A B (0, 0)) ! ?s\\<^sub>1 ! ?s\\<^sub>2 = Some j;\n   dfa_is_node A ?s\\<^sub>1; dfa_is_node B ?s\\<^sub>2;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_reach A 0 bss ?s\\<^sub>1 \\<and>\n                    dfa_reach B 0 bss ?s\\<^sub>2\n  fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n  Some (dfa_trans (binop_dfa f A B) j bs)\n  dfa_is_node A s\\<^sub>1\n  dfa_is_node B s\\<^sub>2\n  list_all (is_alph n) (bss @ [bs])\n\ngoal (1 subgoal):\n 1. \\<And>k x y s\\<^sub>1 s\\<^sub>2.\n       \\<lbrakk>dfa_reach (binop_dfa f A B) 0 x k;\n        \\<And>s\\<^sub>1 s\\<^sub>2.\n           \\<lbrakk>fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n                    Some k;\n            dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach A 0 x s\\<^sub>1 \\<and>\n                             dfa_reach B 0 x s\\<^sub>2;\n        fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n        Some (dfa_trans (binop_dfa f A B) k y);\n        dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach A 0 (x @ [y]) s\\<^sub>1 \\<and>\n                         dfa_reach B 0 (x @ [y]) s\\<^sub>2", "then"], ["proof (chain)\npicking this:\n  dfa_reach (binop_dfa f A B) 0 bss j\n  \\<lbrakk>fst (prod_dfs A B (0, 0)) ! ?s\\<^sub>1 ! ?s\\<^sub>2 = Some j;\n   dfa_is_node A ?s\\<^sub>1; dfa_is_node B ?s\\<^sub>2;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_reach A 0 bss ?s\\<^sub>1 \\<and>\n                    dfa_reach B 0 bss ?s\\<^sub>2\n  fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n  Some (dfa_trans (binop_dfa f A B) j bs)\n  dfa_is_node A s\\<^sub>1\n  dfa_is_node B s\\<^sub>2\n  list_all (is_alph n) (bss @ [bs])", "have \"length bs = n\""], ["proof (prove)\nusing this:\n  dfa_reach (binop_dfa f A B) 0 bss j\n  \\<lbrakk>fst (prod_dfs A B (0, 0)) ! ?s\\<^sub>1 ! ?s\\<^sub>2 = Some j;\n   dfa_is_node A ?s\\<^sub>1; dfa_is_node B ?s\\<^sub>2;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_reach A 0 bss ?s\\<^sub>1 \\<and>\n                    dfa_reach B 0 bss ?s\\<^sub>2\n  fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n  Some (dfa_trans (binop_dfa f A B) j bs)\n  dfa_is_node A s\\<^sub>1\n  dfa_is_node B s\\<^sub>2\n  list_all (is_alph n) (bss @ [bs])\n\ngoal (1 subgoal):\n 1. length bs = n", "by (simp add: is_alph_def)"], ["proof (state)\nthis:\n  length bs = n\n\ngoal (1 subgoal):\n 1. \\<And>k x y s\\<^sub>1 s\\<^sub>2.\n       \\<lbrakk>dfa_reach (binop_dfa f A B) 0 x k;\n        \\<And>s\\<^sub>1 s\\<^sub>2.\n           \\<lbrakk>fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n                    Some k;\n            dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach A 0 x s\\<^sub>1 \\<and>\n                             dfa_reach B 0 x s\\<^sub>2;\n        fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n        Some (dfa_trans (binop_dfa f A B) k y);\n        dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach A 0 (x @ [y]) s\\<^sub>1 \\<and>\n                         dfa_reach B 0 (x @ [y]) s\\<^sub>2", "moreover"], ["proof (state)\nthis:\n  length bs = n\n\ngoal (1 subgoal):\n 1. \\<And>k x y s\\<^sub>1 s\\<^sub>2.\n       \\<lbrakk>dfa_reach (binop_dfa f A B) 0 x k;\n        \\<And>s\\<^sub>1 s\\<^sub>2.\n           \\<lbrakk>fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n                    Some k;\n            dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach A 0 x s\\<^sub>1 \\<and>\n                             dfa_reach B 0 x s\\<^sub>2;\n        fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n        Some (dfa_trans (binop_dfa f A B) k y);\n        dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach A 0 (x @ [y]) s\\<^sub>1 \\<and>\n                         dfa_reach B 0 (x @ [y]) s\\<^sub>2", "from binop_wf_dfa"], ["proof (chain)\npicking this:\n  wf_dfa (binop_dfa ?f A B) n", "have \"dfa_is_node (binop_dfa f A B) 0\""], ["proof (prove)\nusing this:\n  wf_dfa (binop_dfa ?f A B) n\n\ngoal (1 subgoal):\n 1. dfa_is_node (binop_dfa f A B) 0", "by (simp add: dfa_is_node_def wf_dfa_def)"], ["proof (state)\nthis:\n  dfa_is_node (binop_dfa f A B) 0\n\ngoal (1 subgoal):\n 1. \\<And>k x y s\\<^sub>1 s\\<^sub>2.\n       \\<lbrakk>dfa_reach (binop_dfa f A B) 0 x k;\n        \\<And>s\\<^sub>1 s\\<^sub>2.\n           \\<lbrakk>fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n                    Some k;\n            dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach A 0 x s\\<^sub>1 \\<and>\n                             dfa_reach B 0 x s\\<^sub>2;\n        fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n        Some (dfa_trans (binop_dfa f A B) k y);\n        dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach A 0 (x @ [y]) s\\<^sub>1 \\<and>\n                         dfa_reach B 0 (x @ [y]) s\\<^sub>2", "with snoc binop_wf_dfa [of f]"], ["proof (chain)\npicking this:\n  dfa_reach (binop_dfa f A B) 0 bss j\n  \\<lbrakk>fst (prod_dfs A B (0, 0)) ! ?s\\<^sub>1 ! ?s\\<^sub>2 = Some j;\n   dfa_is_node A ?s\\<^sub>1; dfa_is_node B ?s\\<^sub>2;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_reach A 0 bss ?s\\<^sub>1 \\<and>\n                    dfa_reach B 0 bss ?s\\<^sub>2\n  fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n  Some (dfa_trans (binop_dfa f A B) j bs)\n  dfa_is_node A s\\<^sub>1\n  dfa_is_node B s\\<^sub>2\n  list_all (is_alph n) (bss @ [bs])\n  wf_dfa (binop_dfa f A B) n\n  dfa_is_node (binop_dfa f A B) 0", "have \"dfa_is_node (binop_dfa f A B) j\""], ["proof (prove)\nusing this:\n  dfa_reach (binop_dfa f A B) 0 bss j\n  \\<lbrakk>fst (prod_dfs A B (0, 0)) ! ?s\\<^sub>1 ! ?s\\<^sub>2 = Some j;\n   dfa_is_node A ?s\\<^sub>1; dfa_is_node B ?s\\<^sub>2;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_reach A 0 bss ?s\\<^sub>1 \\<and>\n                    dfa_reach B 0 bss ?s\\<^sub>2\n  fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n  Some (dfa_trans (binop_dfa f A B) j bs)\n  dfa_is_node A s\\<^sub>1\n  dfa_is_node B s\\<^sub>2\n  list_all (is_alph n) (bss @ [bs])\n  wf_dfa (binop_dfa f A B) n\n  dfa_is_node (binop_dfa f A B) 0\n\ngoal (1 subgoal):\n 1. dfa_is_node (binop_dfa f A B) j", "by (simp add: dfa_reach_is_node)"], ["proof (state)\nthis:\n  dfa_is_node (binop_dfa f A B) j\n\ngoal (1 subgoal):\n 1. \\<And>k x y s\\<^sub>1 s\\<^sub>2.\n       \\<lbrakk>dfa_reach (binop_dfa f A B) 0 x k;\n        \\<And>s\\<^sub>1 s\\<^sub>2.\n           \\<lbrakk>fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n                    Some k;\n            dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach A 0 x s\\<^sub>1 \\<and>\n                             dfa_reach B 0 x s\\<^sub>2;\n        fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n        Some (dfa_trans (binop_dfa f A B) k y);\n        dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach A 0 (x @ [y]) s\\<^sub>1 \\<and>\n                         dfa_reach B 0 (x @ [y]) s\\<^sub>2", "then"], ["proof (chain)\npicking this:\n  dfa_is_node (binop_dfa f A B) j", "have j: \"j < length (snd (prod_dfs A B (0,0)))\""], ["proof (prove)\nusing this:\n  dfa_is_node (binop_dfa f A B) j\n\ngoal (1 subgoal):\n 1. j < length (snd (prod_dfs A B (0, 0)))", "by (simp add: binop_dfa_def dfa_is_node_def split_beta)"], ["proof (state)\nthis:\n  j < length (snd (prod_dfs A B (0, 0)))\n\ngoal (1 subgoal):\n 1. \\<And>k x y s\\<^sub>1 s\\<^sub>2.\n       \\<lbrakk>dfa_reach (binop_dfa f A B) 0 x k;\n        \\<And>s\\<^sub>1 s\\<^sub>2.\n           \\<lbrakk>fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n                    Some k;\n            dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach A 0 x s\\<^sub>1 \\<and>\n                             dfa_reach B 0 x s\\<^sub>2;\n        fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n        Some (dfa_trans (binop_dfa f A B) k y);\n        dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach A 0 (x @ [y]) s\\<^sub>1 \\<and>\n                         dfa_reach B 0 (x @ [y]) s\\<^sub>2", "with prod_dfs_bij [OF is_node_s1_s2,\n        of \"fst (snd (prod_dfs A B (0,0)) ! j)\" \"snd (snd (prod_dfs A B (0,0)) ! j)\"]"], ["proof (chain)\npicking this:\n  (fst (prod_dfs A B (0, 0)) ! fst (snd (prod_dfs A B (0, 0)) ! j) !\n   snd (snd (prod_dfs A B (0, 0)) ! j) =\n   Some ?k \\<and>\n   dfa_is_node A (fst (snd (prod_dfs A B (0, 0)) ! j)) \\<and>\n   dfa_is_node B (snd (snd (prod_dfs A B (0, 0)) ! j))) =\n  (?k < length (snd (prod_dfs A B (0, 0))) \\<and>\n   snd (prod_dfs A B (0, 0)) ! ?k =\n   (fst (snd (prod_dfs A B (0, 0)) ! j),\n    snd (snd (prod_dfs A B (0, 0)) ! j)))\n  j < length (snd (prod_dfs A B (0, 0)))", "have j_tr1: \"dfa_is_node A (fst (snd (prod_dfs A B (0,0)) ! j))\"\n        and j_tr2: \"dfa_is_node B (snd (snd (prod_dfs A B (0,0)) ! j))\"\n        and Some_j: \"fst (prod_dfs A B (0,0)) ! fst (snd (prod_dfs A B (0,0)) ! j) ! snd (snd (prod_dfs A B (0,0)) ! j) = Some j\""], ["proof (prove)\nusing this:\n  (fst (prod_dfs A B (0, 0)) ! fst (snd (prod_dfs A B (0, 0)) ! j) !\n   snd (snd (prod_dfs A B (0, 0)) ! j) =\n   Some ?k \\<and>\n   dfa_is_node A (fst (snd (prod_dfs A B (0, 0)) ! j)) \\<and>\n   dfa_is_node B (snd (snd (prod_dfs A B (0, 0)) ! j))) =\n  (?k < length (snd (prod_dfs A B (0, 0))) \\<and>\n   snd (prod_dfs A B (0, 0)) ! ?k =\n   (fst (snd (prod_dfs A B (0, 0)) ! j),\n    snd (snd (prod_dfs A B (0, 0)) ! j)))\n  j < length (snd (prod_dfs A B (0, 0)))\n\ngoal (1 subgoal):\n 1. dfa_is_node A (fst (snd (prod_dfs A B (0, 0)) ! j)) &&&\n    dfa_is_node B (snd (snd (prod_dfs A B (0, 0)) ! j)) &&&\n    fst (prod_dfs A B (0, 0)) ! fst (snd (prod_dfs A B (0, 0)) ! j) !\n    snd (snd (prod_dfs A B (0, 0)) ! j) =\n    Some j", "by auto"], ["proof (state)\nthis:\n  dfa_is_node A (fst (snd (prod_dfs A B (0, 0)) ! j))\n  dfa_is_node B (snd (snd (prod_dfs A B (0, 0)) ! j))\n  fst (prod_dfs A B (0, 0)) ! fst (snd (prod_dfs A B (0, 0)) ! j) !\n  snd (snd (prod_dfs A B (0, 0)) ! j) =\n  Some j\n\ngoal (1 subgoal):\n 1. \\<And>k x y s\\<^sub>1 s\\<^sub>2.\n       \\<lbrakk>dfa_reach (binop_dfa f A B) 0 x k;\n        \\<And>s\\<^sub>1 s\\<^sub>2.\n           \\<lbrakk>fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n                    Some k;\n            dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach A 0 x s\\<^sub>1 \\<and>\n                             dfa_reach B 0 x s\\<^sub>2;\n        fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n        Some (dfa_trans (binop_dfa f A B) k y);\n        dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach A 0 (x @ [y]) s\\<^sub>1 \\<and>\n                         dfa_reach B 0 (x @ [y]) s\\<^sub>2", "note j_tr1 j_tr2 s1 s2 Some_j"], ["proof (state)\nthis:\n  dfa_is_node A (fst (snd (prod_dfs A B (0, 0)) ! j))\n  dfa_is_node B (snd (snd (prod_dfs A B (0, 0)) ! j))\n  dfa_is_node A 0\n  dfa_is_node B 0\n  fst (prod_dfs A B (0, 0)) ! fst (snd (prod_dfs A B (0, 0)) ! j) !\n  snd (snd (prod_dfs A B (0, 0)) ! j) =\n  Some j\n\ngoal (1 subgoal):\n 1. \\<And>k x y s\\<^sub>1 s\\<^sub>2.\n       \\<lbrakk>dfa_reach (binop_dfa f A B) 0 x k;\n        \\<And>s\\<^sub>1 s\\<^sub>2.\n           \\<lbrakk>fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n                    Some k;\n            dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach A 0 x s\\<^sub>1 \\<and>\n                             dfa_reach B 0 x s\\<^sub>2;\n        fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n        Some (dfa_trans (binop_dfa f A B) k y);\n        dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach A 0 (x @ [y]) s\\<^sub>1 \\<and>\n                         dfa_reach B 0 (x @ [y]) s\\<^sub>2", "ultimately"], ["proof (chain)\npicking this:\n  length bs = n\n  dfa_is_node A (fst (snd (prod_dfs A B (0, 0)) ! j))\n  dfa_is_node B (snd (snd (prod_dfs A B (0, 0)) ! j))\n  dfa_is_node A 0\n  dfa_is_node B 0\n  fst (prod_dfs A B (0, 0)) ! fst (snd (prod_dfs A B (0, 0)) ! j) !\n  snd (snd (prod_dfs A B (0, 0)) ! j) =\n  Some j", "obtain k\n        where k: \"fst (prod_dfs A B (0,0)) ! \n          dfa_trans A (fst (snd (prod_dfs A B (0, 0)) ! j)) bs !\n          dfa_trans B (snd (snd (prod_dfs A B (0, 0)) ! j)) bs = Some k\"\n        and s_tr1': \"dfa_is_node A (dfa_trans A (fst (snd (prod_dfs A B (0,0)) ! j)) bs)\"\n        and s_tr2': \"dfa_is_node B (dfa_trans B (snd (snd (prod_dfs A B (0,0)) ! j)) bs)\""], ["proof (prove)\nusing this:\n  length bs = n\n  dfa_is_node A (fst (snd (prod_dfs A B (0, 0)) ! j))\n  dfa_is_node B (snd (snd (prod_dfs A B (0, 0)) ! j))\n  dfa_is_node A 0\n  dfa_is_node B 0\n  fst (prod_dfs A B (0, 0)) ! fst (snd (prod_dfs A B (0, 0)) ! j) !\n  snd (snd (prod_dfs A B (0, 0)) ! j) =\n  Some j\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>fst (prod_dfs A B (0, 0)) !\n                 dfa_trans A (fst (snd (prod_dfs A B (0, 0)) ! j)) bs !\n                 dfa_trans B (snd (snd (prod_dfs A B (0, 0)) ! j)) bs =\n                 Some k;\n         dfa_is_node A\n          (dfa_trans A (fst (snd (prod_dfs A B (0, 0)) ! j)) bs);\n         dfa_is_node B\n          (dfa_trans B (snd (snd (prod_dfs A B (0, 0)) ! j)) bs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule prod_dfs_statetrans)"], ["proof (state)\nthis:\n  fst (prod_dfs A B (0, 0)) !\n  dfa_trans A (fst (snd (prod_dfs A B (0, 0)) ! j)) bs !\n  dfa_trans B (snd (snd (prod_dfs A B (0, 0)) ! j)) bs =\n  Some k\n  dfa_is_node A (dfa_trans A (fst (snd (prod_dfs A B (0, 0)) ! j)) bs)\n  dfa_is_node B (dfa_trans B (snd (snd (prod_dfs A B (0, 0)) ! j)) bs)\n\ngoal (1 subgoal):\n 1. \\<And>k x y s\\<^sub>1 s\\<^sub>2.\n       \\<lbrakk>dfa_reach (binop_dfa f A B) 0 x k;\n        \\<And>s\\<^sub>1 s\\<^sub>2.\n           \\<lbrakk>fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n                    Some k;\n            dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach A 0 x s\\<^sub>1 \\<and>\n                             dfa_reach B 0 x s\\<^sub>2;\n        fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n        Some (dfa_trans (binop_dfa f A B) k y);\n        dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach A 0 (x @ [y]) s\\<^sub>1 \\<and>\n                         dfa_reach B 0 (x @ [y]) s\\<^sub>2", "from well_formed1 well_formed2 j_tr1 j_tr2 snoc"], ["proof (chain)\npicking this:\n  wf_dfa A n\n  wf_dfa B n\n  dfa_is_node A (fst (snd (prod_dfs A B (0, 0)) ! j))\n  dfa_is_node B (snd (snd (prod_dfs A B (0, 0)) ! j))\n  dfa_reach (binop_dfa f A B) 0 bss j\n  \\<lbrakk>fst (prod_dfs A B (0, 0)) ! ?s\\<^sub>1 ! ?s\\<^sub>2 = Some j;\n   dfa_is_node A ?s\\<^sub>1; dfa_is_node B ?s\\<^sub>2;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_reach A 0 bss ?s\\<^sub>1 \\<and>\n                    dfa_reach B 0 bss ?s\\<^sub>2\n  fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n  Some (dfa_trans (binop_dfa f A B) j bs)\n  dfa_is_node A s\\<^sub>1\n  dfa_is_node B s\\<^sub>2\n  list_all (is_alph n) (bss @ [bs])", "have lh: \"bddh (length bs) (fst A ! fst (snd (prod_dfs A B (0,0)) ! j))\"\n        and rh: \"bddh (length bs) (fst B ! snd (snd (prod_dfs A B (0,0)) ! j))\""], ["proof (prove)\nusing this:\n  wf_dfa A n\n  wf_dfa B n\n  dfa_is_node A (fst (snd (prod_dfs A B (0, 0)) ! j))\n  dfa_is_node B (snd (snd (prod_dfs A B (0, 0)) ! j))\n  dfa_reach (binop_dfa f A B) 0 bss j\n  \\<lbrakk>fst (prod_dfs A B (0, 0)) ! ?s\\<^sub>1 ! ?s\\<^sub>2 = Some j;\n   dfa_is_node A ?s\\<^sub>1; dfa_is_node B ?s\\<^sub>2;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_reach A 0 bss ?s\\<^sub>1 \\<and>\n                    dfa_reach B 0 bss ?s\\<^sub>2\n  fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n  Some (dfa_trans (binop_dfa f A B) j bs)\n  dfa_is_node A s\\<^sub>1\n  dfa_is_node B s\\<^sub>2\n  list_all (is_alph n) (bss @ [bs])\n\ngoal (1 subgoal):\n 1. bddh (length bs) (fst A ! fst (snd (prod_dfs A B (0, 0)) ! j)) &&&\n    bddh (length bs) (fst B ! snd (snd (prod_dfs A B (0, 0)) ! j))", "by (auto simp: wf_dfa_def dfa_is_node_def list_all_iff is_alph_def)"], ["proof (state)\nthis:\n  bddh (length bs) (fst A ! fst (snd (prod_dfs A B (0, 0)) ! j))\n  bddh (length bs) (fst B ! snd (snd (prod_dfs A B (0, 0)) ! j))\n\ngoal (1 subgoal):\n 1. \\<And>k x y s\\<^sub>1 s\\<^sub>2.\n       \\<lbrakk>dfa_reach (binop_dfa f A B) 0 x k;\n        \\<And>s\\<^sub>1 s\\<^sub>2.\n           \\<lbrakk>fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n                    Some k;\n            dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach A 0 x s\\<^sub>1 \\<and>\n                             dfa_reach B 0 x s\\<^sub>2;\n        fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n        Some (dfa_trans (binop_dfa f A B) k y);\n        dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach A 0 (x @ [y]) s\\<^sub>1 \\<and>\n                         dfa_reach B 0 (x @ [y]) s\\<^sub>2", "from snoc(3)[unfolded dfa_trans_def binop_dfa_def Let_def split_beta fst_conv nth_map[OF j] bdd_lookup_binop[OF lh,OF rh], folded dfa_trans_def] k"], ["proof (chain)\npicking this:\n  fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n  Some\n   (the (fst (prod_dfs A B (0, 0)) !\n         dfa_trans A (fst (snd (prod_dfs A B (0, 0)) ! j)) bs !\n         dfa_trans B (snd (snd (prod_dfs A B (0, 0)) ! j)) bs))\n  fst (prod_dfs A B (0, 0)) !\n  dfa_trans A (fst (snd (prod_dfs A B (0, 0)) ! j)) bs !\n  dfa_trans B (snd (snd (prod_dfs A B (0, 0)) ! j)) bs =\n  Some k", "have \"fst (prod_dfs A B (0,0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some k\""], ["proof (prove)\nusing this:\n  fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n  Some\n   (the (fst (prod_dfs A B (0, 0)) !\n         dfa_trans A (fst (snd (prod_dfs A B (0, 0)) ! j)) bs !\n         dfa_trans B (snd (snd (prod_dfs A B (0, 0)) ! j)) bs))\n  fst (prod_dfs A B (0, 0)) !\n  dfa_trans A (fst (snd (prod_dfs A B (0, 0)) ! j)) bs !\n  dfa_trans B (snd (snd (prod_dfs A B (0, 0)) ! j)) bs =\n  Some k\n\ngoal (1 subgoal):\n 1. fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some k", "by simp"], ["proof (state)\nthis:\n  fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some k\n\ngoal (1 subgoal):\n 1. \\<And>k x y s\\<^sub>1 s\\<^sub>2.\n       \\<lbrakk>dfa_reach (binop_dfa f A B) 0 x k;\n        \\<And>s\\<^sub>1 s\\<^sub>2.\n           \\<lbrakk>fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n                    Some k;\n            dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach A 0 x s\\<^sub>1 \\<and>\n                             dfa_reach B 0 x s\\<^sub>2;\n        fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n        Some (dfa_trans (binop_dfa f A B) k y);\n        dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach A 0 (x @ [y]) s\\<^sub>1 \\<and>\n                         dfa_reach B 0 (x @ [y]) s\\<^sub>2", "with is_node_s1_s2 \\<open>dfa_is_node A s\\<^sub>1\\<close> \\<open>dfa_is_node B s\\<^sub>2\\<close> s_tr1' s_tr2'"], ["proof (chain)\npicking this:\n  prod_is_node A B (0, 0)\n  dfa_is_node A s\\<^sub>1\n  dfa_is_node B s\\<^sub>2\n  dfa_is_node A (dfa_trans A (fst (snd (prod_dfs A B (0, 0)) ! j)) bs)\n  dfa_is_node B (dfa_trans B (snd (snd (prod_dfs A B (0, 0)) ! j)) bs)\n  fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some k", "have \"(s\\<^sub>1, s\\<^sub>2) = (dfa_trans A (fst (snd (prod_dfs A B (0,0)) ! j)) bs, dfa_trans B (snd (snd (prod_dfs A B (0,0)) ! j)) bs)\""], ["proof (prove)\nusing this:\n  prod_is_node A B (0, 0)\n  dfa_is_node A s\\<^sub>1\n  dfa_is_node B s\\<^sub>2\n  dfa_is_node A (dfa_trans A (fst (snd (prod_dfs A B (0, 0)) ! j)) bs)\n  dfa_is_node B (dfa_trans B (snd (snd (prod_dfs A B (0, 0)) ! j)) bs)\n  fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some k\n\ngoal (1 subgoal):\n 1. (s\\<^sub>1, s\\<^sub>2) =\n    (dfa_trans A (fst (snd (prod_dfs A B (0, 0)) ! j)) bs,\n     dfa_trans B (snd (snd (prod_dfs A B (0, 0)) ! j)) bs)", "using k"], ["proof (prove)\nusing this:\n  prod_is_node A B (0, 0)\n  dfa_is_node A s\\<^sub>1\n  dfa_is_node B s\\<^sub>2\n  dfa_is_node A (dfa_trans A (fst (snd (prod_dfs A B (0, 0)) ! j)) bs)\n  dfa_is_node B (dfa_trans B (snd (snd (prod_dfs A B (0, 0)) ! j)) bs)\n  fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some k\n  fst (prod_dfs A B (0, 0)) !\n  dfa_trans A (fst (snd (prod_dfs A B (0, 0)) ! j)) bs !\n  dfa_trans B (snd (snd (prod_dfs A B (0, 0)) ! j)) bs =\n  Some k\n\ngoal (1 subgoal):\n 1. (s\\<^sub>1, s\\<^sub>2) =\n    (dfa_trans A (fst (snd (prod_dfs A B (0, 0)) ! j)) bs,\n     dfa_trans B (snd (snd (prod_dfs A B (0, 0)) ! j)) bs)", "by (rule prod_dfs_inj)"], ["proof (state)\nthis:\n  (s\\<^sub>1, s\\<^sub>2) =\n  (dfa_trans A (fst (snd (prod_dfs A B (0, 0)) ! j)) bs,\n   dfa_trans B (snd (snd (prod_dfs A B (0, 0)) ! j)) bs)\n\ngoal (1 subgoal):\n 1. \\<And>k x y s\\<^sub>1 s\\<^sub>2.\n       \\<lbrakk>dfa_reach (binop_dfa f A B) 0 x k;\n        \\<And>s\\<^sub>1 s\\<^sub>2.\n           \\<lbrakk>fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n                    Some k;\n            dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach A 0 x s\\<^sub>1 \\<and>\n                             dfa_reach B 0 x s\\<^sub>2;\n        fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n        Some (dfa_trans (binop_dfa f A B) k y);\n        dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach A 0 (x @ [y]) s\\<^sub>1 \\<and>\n                         dfa_reach B 0 (x @ [y]) s\\<^sub>2", "moreover"], ["proof (state)\nthis:\n  (s\\<^sub>1, s\\<^sub>2) =\n  (dfa_trans A (fst (snd (prod_dfs A B (0, 0)) ! j)) bs,\n   dfa_trans B (snd (snd (prod_dfs A B (0, 0)) ! j)) bs)\n\ngoal (1 subgoal):\n 1. \\<And>k x y s\\<^sub>1 s\\<^sub>2.\n       \\<lbrakk>dfa_reach (binop_dfa f A B) 0 x k;\n        \\<And>s\\<^sub>1 s\\<^sub>2.\n           \\<lbrakk>fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n                    Some k;\n            dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach A 0 x s\\<^sub>1 \\<and>\n                             dfa_reach B 0 x s\\<^sub>2;\n        fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n        Some (dfa_trans (binop_dfa f A B) k y);\n        dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach A 0 (x @ [y]) s\\<^sub>1 \\<and>\n                         dfa_reach B 0 (x @ [y]) s\\<^sub>2", "from snoc Some_j j_tr1 j_tr2"], ["proof (chain)\npicking this:\n  dfa_reach (binop_dfa f A B) 0 bss j\n  \\<lbrakk>fst (prod_dfs A B (0, 0)) ! ?s\\<^sub>1 ! ?s\\<^sub>2 = Some j;\n   dfa_is_node A ?s\\<^sub>1; dfa_is_node B ?s\\<^sub>2;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_reach A 0 bss ?s\\<^sub>1 \\<and>\n                    dfa_reach B 0 bss ?s\\<^sub>2\n  fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n  Some (dfa_trans (binop_dfa f A B) j bs)\n  dfa_is_node A s\\<^sub>1\n  dfa_is_node B s\\<^sub>2\n  list_all (is_alph n) (bss @ [bs])\n  fst (prod_dfs A B (0, 0)) ! fst (snd (prod_dfs A B (0, 0)) ! j) !\n  snd (snd (prod_dfs A B (0, 0)) ! j) =\n  Some j\n  dfa_is_node A (fst (snd (prod_dfs A B (0, 0)) ! j))\n  dfa_is_node B (snd (snd (prod_dfs A B (0, 0)) ! j))", "have \"dfa_reach A 0 bss (fst (snd (prod_dfs A B (0,0)) ! j))\""], ["proof (prove)\nusing this:\n  dfa_reach (binop_dfa f A B) 0 bss j\n  \\<lbrakk>fst (prod_dfs A B (0, 0)) ! ?s\\<^sub>1 ! ?s\\<^sub>2 = Some j;\n   dfa_is_node A ?s\\<^sub>1; dfa_is_node B ?s\\<^sub>2;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_reach A 0 bss ?s\\<^sub>1 \\<and>\n                    dfa_reach B 0 bss ?s\\<^sub>2\n  fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n  Some (dfa_trans (binop_dfa f A B) j bs)\n  dfa_is_node A s\\<^sub>1\n  dfa_is_node B s\\<^sub>2\n  list_all (is_alph n) (bss @ [bs])\n  fst (prod_dfs A B (0, 0)) ! fst (snd (prod_dfs A B (0, 0)) ! j) !\n  snd (snd (prod_dfs A B (0, 0)) ! j) =\n  Some j\n  dfa_is_node A (fst (snd (prod_dfs A B (0, 0)) ! j))\n  dfa_is_node B (snd (snd (prod_dfs A B (0, 0)) ! j))\n\ngoal (1 subgoal):\n 1. dfa_reach A 0 bss (fst (snd (prod_dfs A B (0, 0)) ! j))", "by simp"], ["proof (state)\nthis:\n  dfa_reach A 0 bss (fst (snd (prod_dfs A B (0, 0)) ! j))\n\ngoal (1 subgoal):\n 1. \\<And>k x y s\\<^sub>1 s\\<^sub>2.\n       \\<lbrakk>dfa_reach (binop_dfa f A B) 0 x k;\n        \\<And>s\\<^sub>1 s\\<^sub>2.\n           \\<lbrakk>fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n                    Some k;\n            dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach A 0 x s\\<^sub>1 \\<and>\n                             dfa_reach B 0 x s\\<^sub>2;\n        fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n        Some (dfa_trans (binop_dfa f A B) k y);\n        dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach A 0 (x @ [y]) s\\<^sub>1 \\<and>\n                         dfa_reach B 0 (x @ [y]) s\\<^sub>2", "hence \"dfa_reach A 0 (bss @ [bs]) (dfa_trans A (fst (snd (prod_dfs A B (0,0)) ! j)) bs)\""], ["proof (prove)\nusing this:\n  dfa_reach A 0 bss (fst (snd (prod_dfs A B (0, 0)) ! j))\n\ngoal (1 subgoal):\n 1. dfa_reach A 0 (bss @ [bs])\n     (dfa_trans A (fst (snd (prod_dfs A B (0, 0)) ! j)) bs)", "by (rule reach_snoc)"], ["proof (state)\nthis:\n  dfa_reach A 0 (bss @ [bs])\n   (dfa_trans A (fst (snd (prod_dfs A B (0, 0)) ! j)) bs)\n\ngoal (1 subgoal):\n 1. \\<And>k x y s\\<^sub>1 s\\<^sub>2.\n       \\<lbrakk>dfa_reach (binop_dfa f A B) 0 x k;\n        \\<And>s\\<^sub>1 s\\<^sub>2.\n           \\<lbrakk>fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n                    Some k;\n            dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach A 0 x s\\<^sub>1 \\<and>\n                             dfa_reach B 0 x s\\<^sub>2;\n        fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n        Some (dfa_trans (binop_dfa f A B) k y);\n        dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach A 0 (x @ [y]) s\\<^sub>1 \\<and>\n                         dfa_reach B 0 (x @ [y]) s\\<^sub>2", "moreover"], ["proof (state)\nthis:\n  dfa_reach A 0 (bss @ [bs])\n   (dfa_trans A (fst (snd (prod_dfs A B (0, 0)) ! j)) bs)\n\ngoal (1 subgoal):\n 1. \\<And>k x y s\\<^sub>1 s\\<^sub>2.\n       \\<lbrakk>dfa_reach (binop_dfa f A B) 0 x k;\n        \\<And>s\\<^sub>1 s\\<^sub>2.\n           \\<lbrakk>fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n                    Some k;\n            dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach A 0 x s\\<^sub>1 \\<and>\n                             dfa_reach B 0 x s\\<^sub>2;\n        fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n        Some (dfa_trans (binop_dfa f A B) k y);\n        dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach A 0 (x @ [y]) s\\<^sub>1 \\<and>\n                         dfa_reach B 0 (x @ [y]) s\\<^sub>2", "from snoc Some_j j_tr1 j_tr2"], ["proof (chain)\npicking this:\n  dfa_reach (binop_dfa f A B) 0 bss j\n  \\<lbrakk>fst (prod_dfs A B (0, 0)) ! ?s\\<^sub>1 ! ?s\\<^sub>2 = Some j;\n   dfa_is_node A ?s\\<^sub>1; dfa_is_node B ?s\\<^sub>2;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_reach A 0 bss ?s\\<^sub>1 \\<and>\n                    dfa_reach B 0 bss ?s\\<^sub>2\n  fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n  Some (dfa_trans (binop_dfa f A B) j bs)\n  dfa_is_node A s\\<^sub>1\n  dfa_is_node B s\\<^sub>2\n  list_all (is_alph n) (bss @ [bs])\n  fst (prod_dfs A B (0, 0)) ! fst (snd (prod_dfs A B (0, 0)) ! j) !\n  snd (snd (prod_dfs A B (0, 0)) ! j) =\n  Some j\n  dfa_is_node A (fst (snd (prod_dfs A B (0, 0)) ! j))\n  dfa_is_node B (snd (snd (prod_dfs A B (0, 0)) ! j))", "have \"dfa_reach B 0 bss (snd (snd (prod_dfs A B (0,0)) ! j))\""], ["proof (prove)\nusing this:\n  dfa_reach (binop_dfa f A B) 0 bss j\n  \\<lbrakk>fst (prod_dfs A B (0, 0)) ! ?s\\<^sub>1 ! ?s\\<^sub>2 = Some j;\n   dfa_is_node A ?s\\<^sub>1; dfa_is_node B ?s\\<^sub>2;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_reach A 0 bss ?s\\<^sub>1 \\<and>\n                    dfa_reach B 0 bss ?s\\<^sub>2\n  fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n  Some (dfa_trans (binop_dfa f A B) j bs)\n  dfa_is_node A s\\<^sub>1\n  dfa_is_node B s\\<^sub>2\n  list_all (is_alph n) (bss @ [bs])\n  fst (prod_dfs A B (0, 0)) ! fst (snd (prod_dfs A B (0, 0)) ! j) !\n  snd (snd (prod_dfs A B (0, 0)) ! j) =\n  Some j\n  dfa_is_node A (fst (snd (prod_dfs A B (0, 0)) ! j))\n  dfa_is_node B (snd (snd (prod_dfs A B (0, 0)) ! j))\n\ngoal (1 subgoal):\n 1. dfa_reach B 0 bss (snd (snd (prod_dfs A B (0, 0)) ! j))", "by simp"], ["proof (state)\nthis:\n  dfa_reach B 0 bss (snd (snd (prod_dfs A B (0, 0)) ! j))\n\ngoal (1 subgoal):\n 1. \\<And>k x y s\\<^sub>1 s\\<^sub>2.\n       \\<lbrakk>dfa_reach (binop_dfa f A B) 0 x k;\n        \\<And>s\\<^sub>1 s\\<^sub>2.\n           \\<lbrakk>fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n                    Some k;\n            dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach A 0 x s\\<^sub>1 \\<and>\n                             dfa_reach B 0 x s\\<^sub>2;\n        fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n        Some (dfa_trans (binop_dfa f A B) k y);\n        dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach A 0 (x @ [y]) s\\<^sub>1 \\<and>\n                         dfa_reach B 0 (x @ [y]) s\\<^sub>2", "hence \"dfa_reach B 0 (bss @ [bs]) (dfa_trans B (snd (snd (prod_dfs A B (0,0)) ! j)) bs)\""], ["proof (prove)\nusing this:\n  dfa_reach B 0 bss (snd (snd (prod_dfs A B (0, 0)) ! j))\n\ngoal (1 subgoal):\n 1. dfa_reach B 0 (bss @ [bs])\n     (dfa_trans B (snd (snd (prod_dfs A B (0, 0)) ! j)) bs)", "by (rule reach_snoc)"], ["proof (state)\nthis:\n  dfa_reach B 0 (bss @ [bs])\n   (dfa_trans B (snd (snd (prod_dfs A B (0, 0)) ! j)) bs)\n\ngoal (1 subgoal):\n 1. \\<And>k x y s\\<^sub>1 s\\<^sub>2.\n       \\<lbrakk>dfa_reach (binop_dfa f A B) 0 x k;\n        \\<And>s\\<^sub>1 s\\<^sub>2.\n           \\<lbrakk>fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n                    Some k;\n            dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach A 0 x s\\<^sub>1 \\<and>\n                             dfa_reach B 0 x s\\<^sub>2;\n        fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 =\n        Some (dfa_trans (binop_dfa f A B) k y);\n        dfa_is_node A s\\<^sub>1; dfa_is_node B s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach A 0 (x @ [y]) s\\<^sub>1 \\<and>\n                         dfa_reach B 0 (x @ [y]) s\\<^sub>2", "ultimately"], ["proof (chain)\npicking this:\n  (s\\<^sub>1, s\\<^sub>2) =\n  (dfa_trans A (fst (snd (prod_dfs A B (0, 0)) ! j)) bs,\n   dfa_trans B (snd (snd (prod_dfs A B (0, 0)) ! j)) bs)\n  dfa_reach A 0 (bss @ [bs])\n   (dfa_trans A (fst (snd (prod_dfs A B (0, 0)) ! j)) bs)\n  dfa_reach B 0 (bss @ [bs])\n   (dfa_trans B (snd (snd (prod_dfs A B (0, 0)) ! j)) bs)", "show \"dfa_reach A 0 (bss @ [bs]) s\\<^sub>1 \\<and> dfa_reach B 0 (bss @ [bs]) s\\<^sub>2\""], ["proof (prove)\nusing this:\n  (s\\<^sub>1, s\\<^sub>2) =\n  (dfa_trans A (fst (snd (prod_dfs A B (0, 0)) ! j)) bs,\n   dfa_trans B (snd (snd (prod_dfs A B (0, 0)) ! j)) bs)\n  dfa_reach A 0 (bss @ [bs])\n   (dfa_trans A (fst (snd (prod_dfs A B (0, 0)) ! j)) bs)\n  dfa_reach B 0 (bss @ [bs])\n   (dfa_trans B (snd (snd (prod_dfs A B (0, 0)) ! j)) bs)\n\ngoal (1 subgoal):\n 1. dfa_reach A 0 (bss @ [bs]) s\\<^sub>1 \\<and>\n    dfa_reach B 0 (bss @ [bs]) s\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  dfa_reach A 0 (bss @ [bs]) s\\<^sub>1 \\<and>\n  dfa_reach B 0 (bss @ [bs]) s\\<^sub>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dfa_reach A 0 bss s\\<^sub>1 \\<and> dfa_reach B 0 bss s\\<^sub>2\n\ngoal (1 subgoal):\n 1. dfa_reach A 0 bss s\\<^sub>1 \\<and>\n    dfa_reach B 0 bss s\\<^sub>2 \\<Longrightarrow>\n    \\<exists>m.\n       dfa_reach (binop_dfa f A B) 0 bss m \\<and>\n       fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some m \\<and>\n       dfa_is_node A s\\<^sub>1 \\<and> dfa_is_node B s\\<^sub>2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. dfa_reach A 0 bss s\\<^sub>1 \\<and>\n    dfa_reach B 0 bss s\\<^sub>2 \\<Longrightarrow>\n    \\<exists>m.\n       dfa_reach (binop_dfa f A B) 0 bss m \\<and>\n       fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some m \\<and>\n       dfa_is_node A s\\<^sub>1 \\<and> dfa_is_node B s\\<^sub>2", "assume ?rhs"], ["proof (state)\nthis:\n  dfa_reach A 0 bss s\\<^sub>1 \\<and> dfa_reach B 0 bss s\\<^sub>2\n\ngoal (1 subgoal):\n 1. dfa_reach A 0 bss s\\<^sub>1 \\<and>\n    dfa_reach B 0 bss s\\<^sub>2 \\<Longrightarrow>\n    \\<exists>m.\n       dfa_reach (binop_dfa f A B) 0 bss m \\<and>\n       fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some m \\<and>\n       dfa_is_node A s\\<^sub>1 \\<and> dfa_is_node B s\\<^sub>2", "hence reach: \"dfa_reach A 0 bss s\\<^sub>1\" \"dfa_reach B 0 bss s\\<^sub>2\""], ["proof (prove)\nusing this:\n  dfa_reach A 0 bss s\\<^sub>1 \\<and> dfa_reach B 0 bss s\\<^sub>2\n\ngoal (1 subgoal):\n 1. dfa_reach A 0 bss s\\<^sub>1 &&& dfa_reach B 0 bss s\\<^sub>2", "by simp_all"], ["proof (state)\nthis:\n  dfa_reach A 0 bss s\\<^sub>1\n  dfa_reach B 0 bss s\\<^sub>2\n\ngoal (1 subgoal):\n 1. dfa_reach A 0 bss s\\<^sub>1 \\<and>\n    dfa_reach B 0 bss s\\<^sub>2 \\<Longrightarrow>\n    \\<exists>m.\n       dfa_reach (binop_dfa f A B) 0 bss m \\<and>\n       fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some m \\<and>\n       dfa_is_node A s\\<^sub>1 \\<and> dfa_is_node B s\\<^sub>2", "then"], ["proof (chain)\npicking this:\n  dfa_reach A 0 bss s\\<^sub>1\n  dfa_reach B 0 bss s\\<^sub>2", "show ?lhs"], ["proof (prove)\nusing this:\n  dfa_reach A 0 bss s\\<^sub>1\n  dfa_reach B 0 bss s\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       dfa_reach (binop_dfa f A B) 0 bss m \\<and>\n       fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some m \\<and>\n       dfa_is_node A s\\<^sub>1 \\<and> dfa_is_node B s\\<^sub>2", "using bss"], ["proof (prove)\nusing this:\n  dfa_reach A 0 bss s\\<^sub>1\n  dfa_reach B 0 bss s\\<^sub>2\n  list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       dfa_reach (binop_dfa f A B) 0 bss m \\<and>\n       fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some m \\<and>\n       dfa_is_node A s\\<^sub>1 \\<and> dfa_is_node B s\\<^sub>2", "proof (induct arbitrary: s\\<^sub>2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s\\<^sub>2.\n       \\<lbrakk>dfa_reach B 0 [] s\\<^sub>2; list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            dfa_reach (binop_dfa f A B) 0 [] m \\<and>\n                            fst (prod_dfs A B (0, 0)) ! 0 ! s\\<^sub>2 =\n                            Some m \\<and>\n                            dfa_is_node A 0 \\<and> dfa_is_node B s\\<^sub>2\n 2. \\<And>k x y s\\<^sub>2.\n       \\<lbrakk>dfa_reach A 0 x k;\n        \\<And>s\\<^sub>2.\n           \\<lbrakk>dfa_reach B 0 x s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> \\<exists>m.\n                                dfa_reach (binop_dfa f A B) 0 x m \\<and>\n                                fst (prod_dfs A B (0, 0)) ! k ! s\\<^sub>2 =\n                                Some m \\<and>\n                                dfa_is_node A k \\<and>\n                                dfa_is_node B s\\<^sub>2;\n        dfa_reach B 0 (x @ [y]) s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            dfa_reach (binop_dfa f A B) 0 (x @ [y]) m \\<and>\n                            fst (prod_dfs A B (0, 0)) ! dfa_trans A k y !\n                            s\\<^sub>2 =\n                            Some m \\<and>\n                            dfa_is_node A (dfa_trans A k y) \\<and>\n                            dfa_is_node B s\\<^sub>2", "case Nil"], ["proof (state)\nthis:\n  dfa_reach B 0 [] s\\<^sub>2\n  list_all (is_alph n) []\n\ngoal (2 subgoals):\n 1. \\<And>s\\<^sub>2.\n       \\<lbrakk>dfa_reach B 0 [] s\\<^sub>2; list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            dfa_reach (binop_dfa f A B) 0 [] m \\<and>\n                            fst (prod_dfs A B (0, 0)) ! 0 ! s\\<^sub>2 =\n                            Some m \\<and>\n                            dfa_is_node A 0 \\<and> dfa_is_node B s\\<^sub>2\n 2. \\<And>k x y s\\<^sub>2.\n       \\<lbrakk>dfa_reach A 0 x k;\n        \\<And>s\\<^sub>2.\n           \\<lbrakk>dfa_reach B 0 x s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> \\<exists>m.\n                                dfa_reach (binop_dfa f A B) 0 x m \\<and>\n                                fst (prod_dfs A B (0, 0)) ! k ! s\\<^sub>2 =\n                                Some m \\<and>\n                                dfa_is_node A k \\<and>\n                                dfa_is_node B s\\<^sub>2;\n        dfa_reach B 0 (x @ [y]) s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            dfa_reach (binop_dfa f A B) 0 (x @ [y]) m \\<and>\n                            fst (prod_dfs A B (0, 0)) ! dfa_trans A k y !\n                            s\\<^sub>2 =\n                            Some m \\<and>\n                            dfa_is_node A (dfa_trans A k y) \\<and>\n                            dfa_is_node B s\\<^sub>2", "with start s1 s2"], ["proof (chain)\npicking this:\n  fst (prod_dfs A B (0, 0)) ! 0 ! 0 = Some 0\n  dfa_is_node A 0\n  dfa_is_node B 0\n  dfa_reach B 0 [] s\\<^sub>2\n  list_all (is_alph n) []", "show ?case"], ["proof (prove)\nusing this:\n  fst (prod_dfs A B (0, 0)) ! 0 ! 0 = Some 0\n  dfa_is_node A 0\n  dfa_is_node B 0\n  dfa_reach B 0 [] s\\<^sub>2\n  list_all (is_alph n) []\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       dfa_reach (binop_dfa f A B) 0 [] m \\<and>\n       fst (prod_dfs A B (0, 0)) ! 0 ! s\\<^sub>2 = Some m \\<and>\n       dfa_is_node A 0 \\<and> dfa_is_node B s\\<^sub>2", "by (auto intro: reach_nil simp: reach_nil_iff)"], ["proof (state)\nthis:\n  \\<exists>m.\n     dfa_reach (binop_dfa f A B) 0 [] m \\<and>\n     fst (prod_dfs A B (0, 0)) ! 0 ! s\\<^sub>2 = Some m \\<and>\n     dfa_is_node A 0 \\<and> dfa_is_node B s\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>k x y s\\<^sub>2.\n       \\<lbrakk>dfa_reach A 0 x k;\n        \\<And>s\\<^sub>2.\n           \\<lbrakk>dfa_reach B 0 x s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> \\<exists>m.\n                                dfa_reach (binop_dfa f A B) 0 x m \\<and>\n                                fst (prod_dfs A B (0, 0)) ! k ! s\\<^sub>2 =\n                                Some m \\<and>\n                                dfa_is_node A k \\<and>\n                                dfa_is_node B s\\<^sub>2;\n        dfa_reach B 0 (x @ [y]) s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            dfa_reach (binop_dfa f A B) 0 (x @ [y]) m \\<and>\n                            fst (prod_dfs A B (0, 0)) ! dfa_trans A k y !\n                            s\\<^sub>2 =\n                            Some m \\<and>\n                            dfa_is_node A (dfa_trans A k y) \\<and>\n                            dfa_is_node B s\\<^sub>2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k x y s\\<^sub>2.\n       \\<lbrakk>dfa_reach A 0 x k;\n        \\<And>s\\<^sub>2.\n           \\<lbrakk>dfa_reach B 0 x s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> \\<exists>m.\n                                dfa_reach (binop_dfa f A B) 0 x m \\<and>\n                                fst (prod_dfs A B (0, 0)) ! k ! s\\<^sub>2 =\n                                Some m \\<and>\n                                dfa_is_node A k \\<and>\n                                dfa_is_node B s\\<^sub>2;\n        dfa_reach B 0 (x @ [y]) s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            dfa_reach (binop_dfa f A B) 0 (x @ [y]) m \\<and>\n                            fst (prod_dfs A B (0, 0)) ! dfa_trans A k y !\n                            s\\<^sub>2 =\n                            Some m \\<and>\n                            dfa_is_node A (dfa_trans A k y) \\<and>\n                            dfa_is_node B s\\<^sub>2", "case (snoc j bss bs s\\<^sub>2)"], ["proof (state)\nthis:\n  dfa_reach A 0 bss j\n  \\<lbrakk>dfa_reach B 0 bss ?s\\<^sub>2; list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m.\n                       dfa_reach (binop_dfa f A B) 0 bss m \\<and>\n                       fst (prod_dfs A B (0, 0)) ! j ! ?s\\<^sub>2 =\n                       Some m \\<and>\n                       dfa_is_node A j \\<and> dfa_is_node B ?s\\<^sub>2\n  dfa_reach B 0 (bss @ [bs]) s\\<^sub>2\n  list_all (is_alph n) (bss @ [bs])\n\ngoal (1 subgoal):\n 1. \\<And>k x y s\\<^sub>2.\n       \\<lbrakk>dfa_reach A 0 x k;\n        \\<And>s\\<^sub>2.\n           \\<lbrakk>dfa_reach B 0 x s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> \\<exists>m.\n                                dfa_reach (binop_dfa f A B) 0 x m \\<and>\n                                fst (prod_dfs A B (0, 0)) ! k ! s\\<^sub>2 =\n                                Some m \\<and>\n                                dfa_is_node A k \\<and>\n                                dfa_is_node B s\\<^sub>2;\n        dfa_reach B 0 (x @ [y]) s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            dfa_reach (binop_dfa f A B) 0 (x @ [y]) m \\<and>\n                            fst (prod_dfs A B (0, 0)) ! dfa_trans A k y !\n                            s\\<^sub>2 =\n                            Some m \\<and>\n                            dfa_is_node A (dfa_trans A k y) \\<and>\n                            dfa_is_node B s\\<^sub>2", "from snoc(3)"], ["proof (chain)\npicking this:\n  dfa_reach B 0 (bss @ [bs]) s\\<^sub>2", "obtain s\\<^sub>2' where reach_s2': \"dfa_reach B 0 bss s\\<^sub>2'\" and s2': \"s\\<^sub>2 = dfa_trans B s\\<^sub>2' bs\""], ["proof (prove)\nusing this:\n  dfa_reach B 0 (bss @ [bs]) s\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>s\\<^sub>2''.\n        \\<lbrakk>dfa_reach B 0 bss s\\<^sub>2'';\n         s\\<^sub>2 = dfa_trans B s\\<^sub>2'' bs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: reach_snoc_iff)"], ["proof (state)\nthis:\n  dfa_reach B 0 bss s\\<^sub>2'\n  s\\<^sub>2 = dfa_trans B s\\<^sub>2' bs\n\ngoal (1 subgoal):\n 1. \\<And>k x y s\\<^sub>2.\n       \\<lbrakk>dfa_reach A 0 x k;\n        \\<And>s\\<^sub>2.\n           \\<lbrakk>dfa_reach B 0 x s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> \\<exists>m.\n                                dfa_reach (binop_dfa f A B) 0 x m \\<and>\n                                fst (prod_dfs A B (0, 0)) ! k ! s\\<^sub>2 =\n                                Some m \\<and>\n                                dfa_is_node A k \\<and>\n                                dfa_is_node B s\\<^sub>2;\n        dfa_reach B 0 (x @ [y]) s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            dfa_reach (binop_dfa f A B) 0 (x @ [y]) m \\<and>\n                            fst (prod_dfs A B (0, 0)) ! dfa_trans A k y !\n                            s\\<^sub>2 =\n                            Some m \\<and>\n                            dfa_is_node A (dfa_trans A k y) \\<and>\n                            dfa_is_node B s\\<^sub>2", "from snoc(2) [OF reach_s2'] snoc(4)"], ["proof (chain)\npicking this:\n  list_all (is_alph n) bss \\<Longrightarrow>\n  \\<exists>m.\n     dfa_reach (binop_dfa f A B) 0 bss m \\<and>\n     fst (prod_dfs A B (0, 0)) ! j ! s\\<^sub>2' = Some m \\<and>\n     dfa_is_node A j \\<and> dfa_is_node B s\\<^sub>2'\n  list_all (is_alph n) (bss @ [bs])", "obtain m where reach_m: \"dfa_reach (binop_dfa f A B) 0 bss m\"\n        and m: \"fst (prod_dfs A B (0,0)) ! j ! s\\<^sub>2' = Some m\"\n        and j: \"dfa_is_node A j\" and s2'': \"dfa_is_node B s\\<^sub>2'\""], ["proof (prove)\nusing this:\n  list_all (is_alph n) bss \\<Longrightarrow>\n  \\<exists>m.\n     dfa_reach (binop_dfa f A B) 0 bss m \\<and>\n     fst (prod_dfs A B (0, 0)) ! j ! s\\<^sub>2' = Some m \\<and>\n     dfa_is_node A j \\<and> dfa_is_node B s\\<^sub>2'\n  list_all (is_alph n) (bss @ [bs])\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>dfa_reach (binop_dfa f A B) 0 bss m;\n         fst (prod_dfs A B (0, 0)) ! j ! s\\<^sub>2' = Some m;\n         dfa_is_node A j; dfa_is_node B s\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  dfa_reach (binop_dfa f A B) 0 bss m\n  fst (prod_dfs A B (0, 0)) ! j ! s\\<^sub>2' = Some m\n  dfa_is_node A j\n  dfa_is_node B s\\<^sub>2'\n\ngoal (1 subgoal):\n 1. \\<And>k x y s\\<^sub>2.\n       \\<lbrakk>dfa_reach A 0 x k;\n        \\<And>s\\<^sub>2.\n           \\<lbrakk>dfa_reach B 0 x s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> \\<exists>m.\n                                dfa_reach (binop_dfa f A B) 0 x m \\<and>\n                                fst (prod_dfs A B (0, 0)) ! k ! s\\<^sub>2 =\n                                Some m \\<and>\n                                dfa_is_node A k \\<and>\n                                dfa_is_node B s\\<^sub>2;\n        dfa_reach B 0 (x @ [y]) s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            dfa_reach (binop_dfa f A B) 0 (x @ [y]) m \\<and>\n                            fst (prod_dfs A B (0, 0)) ! dfa_trans A k y !\n                            s\\<^sub>2 =\n                            Some m \\<and>\n                            dfa_is_node A (dfa_trans A k y) \\<and>\n                            dfa_is_node B s\\<^sub>2", "from snoc"], ["proof (chain)\npicking this:\n  dfa_reach A 0 bss j\n  \\<lbrakk>dfa_reach B 0 bss ?s\\<^sub>2; list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m.\n                       dfa_reach (binop_dfa f A B) 0 bss m \\<and>\n                       fst (prod_dfs A B (0, 0)) ! j ! ?s\\<^sub>2 =\n                       Some m \\<and>\n                       dfa_is_node A j \\<and> dfa_is_node B ?s\\<^sub>2\n  dfa_reach B 0 (bss @ [bs]) s\\<^sub>2\n  list_all (is_alph n) (bss @ [bs])", "have \"list_all (is_alph n) bss\""], ["proof (prove)\nusing this:\n  dfa_reach A 0 bss j\n  \\<lbrakk>dfa_reach B 0 bss ?s\\<^sub>2; list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m.\n                       dfa_reach (binop_dfa f A B) 0 bss m \\<and>\n                       fst (prod_dfs A B (0, 0)) ! j ! ?s\\<^sub>2 =\n                       Some m \\<and>\n                       dfa_is_node A j \\<and> dfa_is_node B ?s\\<^sub>2\n  dfa_reach B 0 (bss @ [bs]) s\\<^sub>2\n  list_all (is_alph n) (bss @ [bs])\n\ngoal (1 subgoal):\n 1. list_all (is_alph n) bss", "by simp"], ["proof (state)\nthis:\n  list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. \\<And>k x y s\\<^sub>2.\n       \\<lbrakk>dfa_reach A 0 x k;\n        \\<And>s\\<^sub>2.\n           \\<lbrakk>dfa_reach B 0 x s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> \\<exists>m.\n                                dfa_reach (binop_dfa f A B) 0 x m \\<and>\n                                fst (prod_dfs A B (0, 0)) ! k ! s\\<^sub>2 =\n                                Some m \\<and>\n                                dfa_is_node A k \\<and>\n                                dfa_is_node B s\\<^sub>2;\n        dfa_reach B 0 (x @ [y]) s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            dfa_reach (binop_dfa f A B) 0 (x @ [y]) m \\<and>\n                            fst (prod_dfs A B (0, 0)) ! dfa_trans A k y !\n                            s\\<^sub>2 =\n                            Some m \\<and>\n                            dfa_is_node A (dfa_trans A k y) \\<and>\n                            dfa_is_node B s\\<^sub>2", "with binop_wf_dfa reach_m dfa_startnode_is_node[OF binop_wf_dfa]"], ["proof (chain)\npicking this:\n  wf_dfa (binop_dfa ?f A B) n\n  dfa_reach (binop_dfa f A B) 0 bss m\n  dfa_is_node (binop_dfa ?f1 A B) 0\n  list_all (is_alph n) bss", "have m_less: \"dfa_is_node (binop_dfa f A B) m\""], ["proof (prove)\nusing this:\n  wf_dfa (binop_dfa ?f A B) n\n  dfa_reach (binop_dfa f A B) 0 bss m\n  dfa_is_node (binop_dfa ?f1 A B) 0\n  list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. dfa_is_node (binop_dfa f A B) m", "by (rule dfa_reach_is_node)"], ["proof (state)\nthis:\n  dfa_is_node (binop_dfa f A B) m\n\ngoal (1 subgoal):\n 1. \\<And>k x y s\\<^sub>2.\n       \\<lbrakk>dfa_reach A 0 x k;\n        \\<And>s\\<^sub>2.\n           \\<lbrakk>dfa_reach B 0 x s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> \\<exists>m.\n                                dfa_reach (binop_dfa f A B) 0 x m \\<and>\n                                fst (prod_dfs A B (0, 0)) ! k ! s\\<^sub>2 =\n                                Some m \\<and>\n                                dfa_is_node A k \\<and>\n                                dfa_is_node B s\\<^sub>2;\n        dfa_reach B 0 (x @ [y]) s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            dfa_reach (binop_dfa f A B) 0 (x @ [y]) m \\<and>\n                            fst (prod_dfs A B (0, 0)) ! dfa_trans A k y !\n                            s\\<^sub>2 =\n                            Some m \\<and>\n                            dfa_is_node A (dfa_trans A k y) \\<and>\n                            dfa_is_node B s\\<^sub>2", "from is_node_s1_s2 m j s2''"], ["proof (chain)\npicking this:\n  prod_is_node A B (0, 0)\n  fst (prod_dfs A B (0, 0)) ! j ! s\\<^sub>2' = Some m\n  dfa_is_node A j\n  dfa_is_node B s\\<^sub>2'", "have m': \"(m < length (snd (prod_dfs A B (0,0))) \\<and>\n        snd (prod_dfs A B (0,0)) ! m = (j, s\\<^sub>2'))\""], ["proof (prove)\nusing this:\n  prod_is_node A B (0, 0)\n  fst (prod_dfs A B (0, 0)) ! j ! s\\<^sub>2' = Some m\n  dfa_is_node A j\n  dfa_is_node B s\\<^sub>2'\n\ngoal (1 subgoal):\n 1. m < length (snd (prod_dfs A B (0, 0))) \\<and>\n    snd (prod_dfs A B (0, 0)) ! m = (j, s\\<^sub>2')", "by (simp add: prod_dfs_bij [symmetric])"], ["proof (state)\nthis:\n  m < length (snd (prod_dfs A B (0, 0))) \\<and>\n  snd (prod_dfs A B (0, 0)) ! m = (j, s\\<^sub>2')\n\ngoal (1 subgoal):\n 1. \\<And>k x y s\\<^sub>2.\n       \\<lbrakk>dfa_reach A 0 x k;\n        \\<And>s\\<^sub>2.\n           \\<lbrakk>dfa_reach B 0 x s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> \\<exists>m.\n                                dfa_reach (binop_dfa f A B) 0 x m \\<and>\n                                fst (prod_dfs A B (0, 0)) ! k ! s\\<^sub>2 =\n                                Some m \\<and>\n                                dfa_is_node A k \\<and>\n                                dfa_is_node B s\\<^sub>2;\n        dfa_reach B 0 (x @ [y]) s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            dfa_reach (binop_dfa f A B) 0 (x @ [y]) m \\<and>\n                            fst (prod_dfs A B (0, 0)) ! dfa_trans A k y !\n                            s\\<^sub>2 =\n                            Some m \\<and>\n                            dfa_is_node A (dfa_trans A k y) \\<and>\n                            dfa_is_node B s\\<^sub>2", "with j s2''"], ["proof (chain)\npicking this:\n  dfa_is_node A j\n  dfa_is_node B s\\<^sub>2'\n  m < length (snd (prod_dfs A B (0, 0))) \\<and>\n  snd (prod_dfs A B (0, 0)) ! m = (j, s\\<^sub>2')", "have \"dfa_is_node A (fst (snd (prod_dfs A B (0,0)) ! m))\"\n        \"dfa_is_node B (snd (snd (prod_dfs A B (0,0)) ! m))\""], ["proof (prove)\nusing this:\n  dfa_is_node A j\n  dfa_is_node B s\\<^sub>2'\n  m < length (snd (prod_dfs A B (0, 0))) \\<and>\n  snd (prod_dfs A B (0, 0)) ! m = (j, s\\<^sub>2')\n\ngoal (1 subgoal):\n 1. dfa_is_node A (fst (snd (prod_dfs A B (0, 0)) ! m)) &&&\n    dfa_is_node B (snd (snd (prod_dfs A B (0, 0)) ! m))", "by simp_all"], ["proof (state)\nthis:\n  dfa_is_node A (fst (snd (prod_dfs A B (0, 0)) ! m))\n  dfa_is_node B (snd (snd (prod_dfs A B (0, 0)) ! m))\n\ngoal (1 subgoal):\n 1. \\<And>k x y s\\<^sub>2.\n       \\<lbrakk>dfa_reach A 0 x k;\n        \\<And>s\\<^sub>2.\n           \\<lbrakk>dfa_reach B 0 x s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> \\<exists>m.\n                                dfa_reach (binop_dfa f A B) 0 x m \\<and>\n                                fst (prod_dfs A B (0, 0)) ! k ! s\\<^sub>2 =\n                                Some m \\<and>\n                                dfa_is_node A k \\<and>\n                                dfa_is_node B s\\<^sub>2;\n        dfa_reach B 0 (x @ [y]) s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            dfa_reach (binop_dfa f A B) 0 (x @ [y]) m \\<and>\n                            fst (prod_dfs A B (0, 0)) ! dfa_trans A k y !\n                            s\\<^sub>2 =\n                            Some m \\<and>\n                            dfa_is_node A (dfa_trans A k y) \\<and>\n                            dfa_is_node B s\\<^sub>2", "with well_formed1 well_formed2 snoc"], ["proof (chain)\npicking this:\n  wf_dfa A n\n  wf_dfa B n\n  dfa_reach A 0 bss j\n  \\<lbrakk>dfa_reach B 0 bss ?s\\<^sub>2; list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m.\n                       dfa_reach (binop_dfa f A B) 0 bss m \\<and>\n                       fst (prod_dfs A B (0, 0)) ! j ! ?s\\<^sub>2 =\n                       Some m \\<and>\n                       dfa_is_node A j \\<and> dfa_is_node B ?s\\<^sub>2\n  dfa_reach B 0 (bss @ [bs]) s\\<^sub>2\n  list_all (is_alph n) (bss @ [bs])\n  dfa_is_node A (fst (snd (prod_dfs A B (0, 0)) ! m))\n  dfa_is_node B (snd (snd (prod_dfs A B (0, 0)) ! m))", "have bddh: \"bddh (length bs) (fst A ! fst (snd (prod_dfs A B (0,0)) ! m))\"\n        \"bddh (length bs) (fst B ! snd (snd (prod_dfs A B (0,0)) ! m))\""], ["proof (prove)\nusing this:\n  wf_dfa A n\n  wf_dfa B n\n  dfa_reach A 0 bss j\n  \\<lbrakk>dfa_reach B 0 bss ?s\\<^sub>2; list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m.\n                       dfa_reach (binop_dfa f A B) 0 bss m \\<and>\n                       fst (prod_dfs A B (0, 0)) ! j ! ?s\\<^sub>2 =\n                       Some m \\<and>\n                       dfa_is_node A j \\<and> dfa_is_node B ?s\\<^sub>2\n  dfa_reach B 0 (bss @ [bs]) s\\<^sub>2\n  list_all (is_alph n) (bss @ [bs])\n  dfa_is_node A (fst (snd (prod_dfs A B (0, 0)) ! m))\n  dfa_is_node B (snd (snd (prod_dfs A B (0, 0)) ! m))\n\ngoal (1 subgoal):\n 1. bddh (length bs) (fst A ! fst (snd (prod_dfs A B (0, 0)) ! m)) &&&\n    bddh (length bs) (fst B ! snd (snd (prod_dfs A B (0, 0)) ! m))", "by (simp add: wf_dfa_def is_alph_def dfa_is_node_def list_all_iff)+"], ["proof (state)\nthis:\n  bddh (length bs) (fst A ! fst (snd (prod_dfs A B (0, 0)) ! m))\n  bddh (length bs) (fst B ! snd (snd (prod_dfs A B (0, 0)) ! m))\n\ngoal (1 subgoal):\n 1. \\<And>k x y s\\<^sub>2.\n       \\<lbrakk>dfa_reach A 0 x k;\n        \\<And>s\\<^sub>2.\n           \\<lbrakk>dfa_reach B 0 x s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> \\<exists>m.\n                                dfa_reach (binop_dfa f A B) 0 x m \\<and>\n                                fst (prod_dfs A B (0, 0)) ! k ! s\\<^sub>2 =\n                                Some m \\<and>\n                                dfa_is_node A k \\<and>\n                                dfa_is_node B s\\<^sub>2;\n        dfa_reach B 0 (x @ [y]) s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            dfa_reach (binop_dfa f A B) 0 (x @ [y]) m \\<and>\n                            fst (prod_dfs A B (0, 0)) ! dfa_trans A k y !\n                            s\\<^sub>2 =\n                            Some m \\<and>\n                            dfa_is_node A (dfa_trans A k y) \\<and>\n                            dfa_is_node B s\\<^sub>2", "from snoc"], ["proof (chain)\npicking this:\n  dfa_reach A 0 bss j\n  \\<lbrakk>dfa_reach B 0 bss ?s\\<^sub>2; list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m.\n                       dfa_reach (binop_dfa f A B) 0 bss m \\<and>\n                       fst (prod_dfs A B (0, 0)) ! j ! ?s\\<^sub>2 =\n                       Some m \\<and>\n                       dfa_is_node A j \\<and> dfa_is_node B ?s\\<^sub>2\n  dfa_reach B 0 (bss @ [bs]) s\\<^sub>2\n  list_all (is_alph n) (bss @ [bs])", "have \"length bs = n\""], ["proof (prove)\nusing this:\n  dfa_reach A 0 bss j\n  \\<lbrakk>dfa_reach B 0 bss ?s\\<^sub>2; list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m.\n                       dfa_reach (binop_dfa f A B) 0 bss m \\<and>\n                       fst (prod_dfs A B (0, 0)) ! j ! ?s\\<^sub>2 =\n                       Some m \\<and>\n                       dfa_is_node A j \\<and> dfa_is_node B ?s\\<^sub>2\n  dfa_reach B 0 (bss @ [bs]) s\\<^sub>2\n  list_all (is_alph n) (bss @ [bs])\n\ngoal (1 subgoal):\n 1. length bs = n", "by (simp add: is_alph_def)"], ["proof (state)\nthis:\n  length bs = n\n\ngoal (1 subgoal):\n 1. \\<And>k x y s\\<^sub>2.\n       \\<lbrakk>dfa_reach A 0 x k;\n        \\<And>s\\<^sub>2.\n           \\<lbrakk>dfa_reach B 0 x s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> \\<exists>m.\n                                dfa_reach (binop_dfa f A B) 0 x m \\<and>\n                                fst (prod_dfs A B (0, 0)) ! k ! s\\<^sub>2 =\n                                Some m \\<and>\n                                dfa_is_node A k \\<and>\n                                dfa_is_node B s\\<^sub>2;\n        dfa_reach B 0 (x @ [y]) s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            dfa_reach (binop_dfa f A B) 0 (x @ [y]) m \\<and>\n                            fst (prod_dfs A B (0, 0)) ! dfa_trans A k y !\n                            s\\<^sub>2 =\n                            Some m \\<and>\n                            dfa_is_node A (dfa_trans A k y) \\<and>\n                            dfa_is_node B s\\<^sub>2", "then"], ["proof (chain)\npicking this:\n  length bs = n", "obtain k where k: \"fst (prod_dfs A B (0,0)) !\n          dfa_trans A j bs ! dfa_trans B s\\<^sub>2' bs = Some k\"\n        and s_tr1: \"dfa_is_node A (dfa_trans A j bs)\"\n        and s_tr2: \"dfa_is_node B (dfa_trans B s\\<^sub>2' bs)\""], ["proof (prove)\nusing this:\n  length bs = n\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>fst (prod_dfs A B (0, 0)) ! dfa_trans A j bs !\n                 dfa_trans B s\\<^sub>2' bs =\n                 Some k;\n         dfa_is_node A (dfa_trans A j bs);\n         dfa_is_node B (dfa_trans B s\\<^sub>2' bs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using j s2'' s1 s2 m"], ["proof (prove)\nusing this:\n  length bs = n\n  dfa_is_node A j\n  dfa_is_node B s\\<^sub>2'\n  dfa_is_node A 0\n  dfa_is_node B 0\n  fst (prod_dfs A B (0, 0)) ! j ! s\\<^sub>2' = Some m\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>fst (prod_dfs A B (0, 0)) ! dfa_trans A j bs !\n                 dfa_trans B s\\<^sub>2' bs =\n                 Some k;\n         dfa_is_node A (dfa_trans A j bs);\n         dfa_is_node B (dfa_trans B s\\<^sub>2' bs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule prod_dfs_statetrans)"], ["proof (state)\nthis:\n  fst (prod_dfs A B (0, 0)) ! dfa_trans A j bs ! dfa_trans B s\\<^sub>2' bs =\n  Some k\n  dfa_is_node A (dfa_trans A j bs)\n  dfa_is_node B (dfa_trans B s\\<^sub>2' bs)\n\ngoal (1 subgoal):\n 1. \\<And>k x y s\\<^sub>2.\n       \\<lbrakk>dfa_reach A 0 x k;\n        \\<And>s\\<^sub>2.\n           \\<lbrakk>dfa_reach B 0 x s\\<^sub>2;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> \\<exists>m.\n                                dfa_reach (binop_dfa f A B) 0 x m \\<and>\n                                fst (prod_dfs A B (0, 0)) ! k ! s\\<^sub>2 =\n                                Some m \\<and>\n                                dfa_is_node A k \\<and>\n                                dfa_is_node B s\\<^sub>2;\n        dfa_reach B 0 (x @ [y]) s\\<^sub>2;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            dfa_reach (binop_dfa f A B) 0 (x @ [y]) m \\<and>\n                            fst (prod_dfs A B (0, 0)) ! dfa_trans A k y !\n                            s\\<^sub>2 =\n                            Some m \\<and>\n                            dfa_is_node A (dfa_trans A k y) \\<and>\n                            dfa_is_node B s\\<^sub>2", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m.\n       dfa_reach (binop_dfa f A B) 0 (bss @ [bs]) m \\<and>\n       fst (prod_dfs A B (0, 0)) ! dfa_trans A j bs ! s\\<^sub>2 =\n       Some m \\<and>\n       dfa_is_node A (dfa_trans A j bs) \\<and> dfa_is_node B s\\<^sub>2", "apply (rule exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa_reach (binop_dfa f A B) 0 (bss @ [bs]) ?m \\<and>\n    fst (prod_dfs A B (0, 0)) ! dfa_trans A j bs ! s\\<^sub>2 =\n    Some ?m \\<and>\n    dfa_is_node A (dfa_trans A j bs) \\<and> dfa_is_node B s\\<^sub>2", "apply (simp add: s2')"], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa_reach (binop_dfa f A B) 0 (bss @ [bs]) ?m \\<and>\n    fst (prod_dfs A B (0, 0)) ! dfa_trans A j bs !\n    dfa_trans B s\\<^sub>2' bs =\n    Some ?m \\<and>\n    dfa_is_node A (dfa_trans A j bs) \\<and>\n    dfa_is_node B (dfa_trans B s\\<^sub>2' bs)", "apply (intro conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. dfa_reach (binop_dfa f A B) 0 (bss @ [bs]) ?m\n 2. fst (prod_dfs A B (0, 0)) ! dfa_trans A j bs !\n    dfa_trans B s\\<^sub>2' bs =\n    Some ?m\n 3. dfa_is_node A (dfa_trans A j bs)\n 4. dfa_is_node B (dfa_trans B s\\<^sub>2' bs)", "apply (rule reach_snoc)"], ["proof (prove)\ngoal (4 subgoals):\n 1. dfa_reach (binop_dfa f A B) 0 bss ?q5\n 2. fst (prod_dfs A B (0, 0)) ! dfa_trans A j bs !\n    dfa_trans B s\\<^sub>2' bs =\n    Some (dfa_trans (binop_dfa f A B) ?q5 bs)\n 3. dfa_is_node A (dfa_trans A j bs)\n 4. dfa_is_node B (dfa_trans B s\\<^sub>2' bs)", "apply (rule reach_m)"], ["proof (prove)\ngoal (3 subgoals):\n 1. fst (prod_dfs A B (0, 0)) ! dfa_trans A j bs !\n    dfa_trans B s\\<^sub>2' bs =\n    Some (dfa_trans (binop_dfa f A B) m bs)\n 2. dfa_is_node A (dfa_trans A j bs)\n 3. dfa_is_node B (dfa_trans B s\\<^sub>2' bs)", "apply (cut_tac m_less)"], ["proof (prove)\ngoal (3 subgoals):\n 1. dfa_is_node (binop_dfa f A B) m \\<Longrightarrow>\n    fst (prod_dfs A B (0, 0)) ! dfa_trans A j bs !\n    dfa_trans B s\\<^sub>2' bs =\n    Some (dfa_trans (binop_dfa f A B) m bs)\n 2. dfa_is_node A (dfa_trans A j bs)\n 3. dfa_is_node B (dfa_trans B s\\<^sub>2' bs)", "apply (simp add: dfa_trans_def binop_dfa_def split_beta dfa_is_node_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. m < length (snd (prod_dfs A B (0, 0))) \\<Longrightarrow>\n    fst (prod_dfs A B (0, 0)) ! bdd_lookup (fst A ! j) bs !\n    bdd_lookup (fst B ! s\\<^sub>2') bs =\n    Some\n     (bdd_lookup\n       (bdd_binop (\\<lambda>k l. the (fst (prod_dfs A B (0, 0)) ! k ! l))\n         (fst A ! fst (snd (prod_dfs A B (0, 0)) ! m))\n         (fst B ! snd (snd (prod_dfs A B (0, 0)) ! m)))\n       bs)\n 2. dfa_is_node A (dfa_trans A j bs)\n 3. dfa_is_node B (dfa_trans B s\\<^sub>2' bs)", "apply (simp add: bddh bdd_lookup_binop split_beta)"], ["proof (prove)\ngoal (3 subgoals):\n 1. m < length (snd (prod_dfs A B (0, 0))) \\<Longrightarrow>\n    fst (prod_dfs A B (0, 0)) ! bdd_lookup (fst A ! j) bs !\n    bdd_lookup (fst B ! s\\<^sub>2') bs =\n    Some\n     (the (fst (prod_dfs A B (0, 0)) !\n           bdd_lookup (fst A ! fst (snd (prod_dfs A B (0, 0)) ! m)) bs !\n           bdd_lookup (fst B ! snd (snd (prod_dfs A B (0, 0)) ! m)) bs))\n 2. dfa_is_node A (dfa_trans A j bs)\n 3. dfa_is_node B (dfa_trans B s\\<^sub>2' bs)", "apply (simp add: dfa_trans_def[symmetric] m' k)"], ["proof (prove)\ngoal (2 subgoals):\n 1. dfa_is_node A (dfa_trans A j bs)\n 2. dfa_is_node B (dfa_trans B s\\<^sub>2' bs)", "apply (rule s_tr1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa_is_node B (dfa_trans B s\\<^sub>2' bs)", "apply (rule s_tr2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>m.\n     dfa_reach (binop_dfa f A B) 0 (bss @ [bs]) m \\<and>\n     fst (prod_dfs A B (0, 0)) ! dfa_trans A j bs ! s\\<^sub>2 =\n     Some m \\<and>\n     dfa_is_node A (dfa_trans A j bs) \\<and> dfa_is_node B s\\<^sub>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>m.\n     dfa_reach (binop_dfa f A B) 0 bss m \\<and>\n     fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some m \\<and>\n     dfa_is_node A s\\<^sub>1 \\<and> dfa_is_node B s\\<^sub>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>m.\n      dfa_reach (binop_dfa f A B) 0 bss m \\<and>\n      fst (prod_dfs A B (0, 0)) ! s\\<^sub>1 ! s\\<^sub>2 = Some m \\<and>\n      dfa_is_node A s\\<^sub>1 \\<and> dfa_is_node B s\\<^sub>2) =\n  (dfa_reach A 0 bss s\\<^sub>1 \\<and> dfa_reach B 0 bss s\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma binop_dfa_steps:\n  assumes X: \"list_all (is_alph n) bs\"\n  shows \"snd (binop_dfa f A B) ! dfa_steps (binop_dfa f A B) 0 bs = f (snd A ! dfa_steps A 0 bs) (snd B ! dfa_steps B 0 bs)\"\n  (is \"?as3 ! dfa_steps ?A 0 bs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (binop_dfa f A B) ! dfa_steps (binop_dfa f A B) 0 bs =\n    f (snd A ! dfa_steps A 0 bs) (snd B ! dfa_steps B 0 bs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. snd (binop_dfa f A B) ! dfa_steps (binop_dfa f A B) 0 bs =\n    f (snd A ! dfa_steps A 0 bs) (snd B ! dfa_steps B 0 bs)", "note 2 = dfa_startnode_is_node[OF well_formed1]"], ["proof (state)\nthis:\n  dfa_is_node A 0\n\ngoal (1 subgoal):\n 1. snd (binop_dfa f A B) ! dfa_steps (binop_dfa f A B) 0 bs =\n    f (snd A ! dfa_steps A 0 bs) (snd B ! dfa_steps B 0 bs)", "note 5 = dfa_startnode_is_node[OF well_formed2]"], ["proof (state)\nthis:\n  dfa_is_node B 0\n\ngoal (1 subgoal):\n 1. snd (binop_dfa f A B) ! dfa_steps (binop_dfa f A B) 0 bs =\n    f (snd A ! dfa_steps A 0 bs) (snd B ! dfa_steps B 0 bs)", "note B = dfa_startnode_is_node[OF binop_wf_dfa]"], ["proof (state)\nthis:\n  dfa_is_node (binop_dfa ?f1 A B) 0\n\ngoal (1 subgoal):\n 1. snd (binop_dfa f A B) ! dfa_steps (binop_dfa f A B) 0 bs =\n    f (snd A ! dfa_steps A 0 bs) (snd B ! dfa_steps B 0 bs)", "define tab where \"tab = fst (prod_dfs A B (0,0))\""], ["proof (state)\nthis:\n  tab = fst (prod_dfs A B (0, 0))\n\ngoal (1 subgoal):\n 1. snd (binop_dfa f A B) ! dfa_steps (binop_dfa f A B) 0 bs =\n    f (snd A ! dfa_steps A 0 bs) (snd B ! dfa_steps B 0 bs)", "define ps where \"ps = snd (prod_dfs A B (0,0))\""], ["proof (state)\nthis:\n  ps = snd (prod_dfs A B (0, 0))\n\ngoal (1 subgoal):\n 1. snd (binop_dfa f A B) ! dfa_steps (binop_dfa f A B) 0 bs =\n    f (snd A ! dfa_steps A 0 bs) (snd B ! dfa_steps B 0 bs)", "from tab_def ps_def"], ["proof (chain)\npicking this:\n  tab = fst (prod_dfs A B (0, 0))\n  ps = snd (prod_dfs A B (0, 0))", "have prod: \"prod_dfs A B (0,0) = (tab, ps)\""], ["proof (prove)\nusing this:\n  tab = fst (prod_dfs A B (0, 0))\n  ps = snd (prod_dfs A B (0, 0))\n\ngoal (1 subgoal):\n 1. prod_dfs A B (0, 0) = (tab, ps)", "by simp"], ["proof (state)\nthis:\n  prod_dfs A B (0, 0) = (tab, ps)\n\ngoal (1 subgoal):\n 1. snd (binop_dfa f A B) ! dfa_steps (binop_dfa f A B) 0 bs =\n    f (snd A ! dfa_steps A 0 bs) (snd B ! dfa_steps B 0 bs)", "define s1 where \"s1 = dfa_steps A 0 bs\""], ["proof (state)\nthis:\n  s1 = dfa_steps A 0 bs\n\ngoal (1 subgoal):\n 1. snd (binop_dfa f A B) ! dfa_steps (binop_dfa f A B) 0 bs =\n    f (snd A ! dfa_steps A 0 bs) (snd B ! dfa_steps B 0 bs)", "define s2 where \"s2 = dfa_steps B 0 bs\""], ["proof (state)\nthis:\n  s2 = dfa_steps B 0 bs\n\ngoal (1 subgoal):\n 1. snd (binop_dfa f A B) ! dfa_steps (binop_dfa f A B) 0 bs =\n    f (snd A ! dfa_steps A 0 bs) (snd B ! dfa_steps B 0 bs)", "with s1_def"], ["proof (chain)\npicking this:\n  s1 = dfa_steps A 0 bs\n  s2 = dfa_steps B 0 bs", "have \"dfa_reach A 0 bs s1\" and \"dfa_reach B 0 bs s2\""], ["proof (prove)\nusing this:\n  s1 = dfa_steps A 0 bs\n  s2 = dfa_steps B 0 bs\n\ngoal (1 subgoal):\n 1. dfa_reach A 0 bs s1 &&& dfa_reach B 0 bs s2", "by (simp add: reach_def)+"], ["proof (state)\nthis:\n  dfa_reach A 0 bs s1\n  dfa_reach B 0 bs s2\n\ngoal (1 subgoal):\n 1. snd (binop_dfa f A B) ! dfa_steps (binop_dfa f A B) 0 bs =\n    f (snd A ! dfa_steps A 0 bs) (snd B ! dfa_steps B 0 bs)", "with X"], ["proof (chain)\npicking this:\n  list_all (is_alph n) bs\n  dfa_reach A 0 bs s1\n  dfa_reach B 0 bs s2", "have \"\\<exists>m. dfa_reach ?A 0 bs m \\<and> fst (prod_dfs A B (0, 0)) ! s1 ! s2 = Some m \\<and> dfa_is_node A s1 \\<and> dfa_is_node B s2\""], ["proof (prove)\nusing this:\n  list_all (is_alph n) bs\n  dfa_reach A 0 bs s1\n  dfa_reach B 0 bs s2\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       dfa_reach (binop_dfa f A B) 0 bs m \\<and>\n       fst (prod_dfs A B (0, 0)) ! s1 ! s2 = Some m \\<and>\n       dfa_is_node A s1 \\<and> dfa_is_node B s2", "by (simp add: binop_dfa_reachable)"], ["proof (state)\nthis:\n  \\<exists>m.\n     dfa_reach (binop_dfa f A B) 0 bs m \\<and>\n     fst (prod_dfs A B (0, 0)) ! s1 ! s2 = Some m \\<and>\n     dfa_is_node A s1 \\<and> dfa_is_node B s2\n\ngoal (1 subgoal):\n 1. snd (binop_dfa f A B) ! dfa_steps (binop_dfa f A B) 0 bs =\n    f (snd A ! dfa_steps A 0 bs) (snd B ! dfa_steps B 0 bs)", "with tab_def"], ["proof (chain)\npicking this:\n  tab = fst (prod_dfs A B (0, 0))\n  \\<exists>m.\n     dfa_reach (binop_dfa f A B) 0 bs m \\<and>\n     fst (prod_dfs A B (0, 0)) ! s1 ! s2 = Some m \\<and>\n     dfa_is_node A s1 \\<and> dfa_is_node B s2", "have \"\\<exists>m. dfa_reach ?A 0 bs m \\<and> tab ! s1 ! s2 = Some m \\<and> dfa_is_node A s1 \\<and> dfa_is_node B s2\""], ["proof (prove)\nusing this:\n  tab = fst (prod_dfs A B (0, 0))\n  \\<exists>m.\n     dfa_reach (binop_dfa f A B) 0 bs m \\<and>\n     fst (prod_dfs A B (0, 0)) ! s1 ! s2 = Some m \\<and>\n     dfa_is_node A s1 \\<and> dfa_is_node B s2\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       dfa_reach (binop_dfa f A B) 0 bs m \\<and>\n       tab ! s1 ! s2 = Some m \\<and>\n       dfa_is_node A s1 \\<and> dfa_is_node B s2", "by simp"], ["proof (state)\nthis:\n  \\<exists>m.\n     dfa_reach (binop_dfa f A B) 0 bs m \\<and>\n     tab ! s1 ! s2 = Some m \\<and> dfa_is_node A s1 \\<and> dfa_is_node B s2\n\ngoal (1 subgoal):\n 1. snd (binop_dfa f A B) ! dfa_steps (binop_dfa f A B) 0 bs =\n    f (snd A ! dfa_steps A 0 bs) (snd B ! dfa_steps B 0 bs)", "then"], ["proof (chain)\npicking this:\n  \\<exists>m.\n     dfa_reach (binop_dfa f A B) 0 bs m \\<and>\n     tab ! s1 ! s2 = Some m \\<and> dfa_is_node A s1 \\<and> dfa_is_node B s2", "obtain m where R: \"dfa_reach ?A 0 bs m\" and M: \"tab ! s1 ! s2 = Some m\" and s1: \"dfa_is_node A s1\" and s2: \"dfa_is_node B s2\""], ["proof (prove)\nusing this:\n  \\<exists>m.\n     dfa_reach (binop_dfa f A B) 0 bs m \\<and>\n     tab ! s1 ! s2 = Some m \\<and> dfa_is_node A s1 \\<and> dfa_is_node B s2\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>dfa_reach (binop_dfa f A B) 0 bs m; tab ! s1 ! s2 = Some m;\n         dfa_is_node A s1; dfa_is_node B s2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  dfa_reach (binop_dfa f A B) 0 bs m\n  tab ! s1 ! s2 = Some m\n  dfa_is_node A s1\n  dfa_is_node B s2\n\ngoal (1 subgoal):\n 1. snd (binop_dfa f A B) ! dfa_steps (binop_dfa f A B) 0 bs =\n    f (snd A ! dfa_steps A 0 bs) (snd B ! dfa_steps B 0 bs)", "hence M': \"m = dfa_steps ?A 0 bs\""], ["proof (prove)\nusing this:\n  dfa_reach (binop_dfa f A B) 0 bs m\n  tab ! s1 ! s2 = Some m\n  dfa_is_node A s1\n  dfa_is_node B s2\n\ngoal (1 subgoal):\n 1. m = dfa_steps (binop_dfa f A B) 0 bs", "by (simp add: reach_def)"], ["proof (state)\nthis:\n  m = dfa_steps (binop_dfa f A B) 0 bs\n\ngoal (1 subgoal):\n 1. snd (binop_dfa f A B) ! dfa_steps (binop_dfa f A B) 0 bs =\n    f (snd A ! dfa_steps A 0 bs) (snd B ! dfa_steps B 0 bs)", "from B X R binop_wf_dfa [of f]"], ["proof (chain)\npicking this:\n  dfa_is_node (binop_dfa ?f1 A B) 0\n  list_all (is_alph n) bs\n  dfa_reach (binop_dfa f A B) 0 bs m\n  wf_dfa (binop_dfa f A B) n", "have mL: \"dfa_is_node ?A m\""], ["proof (prove)\nusing this:\n  dfa_is_node (binop_dfa ?f1 A B) 0\n  list_all (is_alph n) bs\n  dfa_reach (binop_dfa f A B) 0 bs m\n  wf_dfa (binop_dfa f A B) n\n\ngoal (1 subgoal):\n 1. dfa_is_node (binop_dfa f A B) m", "by (simp add: dfa_reach_is_node)"], ["proof (state)\nthis:\n  dfa_is_node (binop_dfa f A B) m\n\ngoal (1 subgoal):\n 1. snd (binop_dfa f A B) ! dfa_steps (binop_dfa f A B) 0 bs =\n    f (snd A ! dfa_steps A 0 bs) (snd B ! dfa_steps B 0 bs)", "from 2 5 M s1 s2"], ["proof (chain)\npicking this:\n  dfa_is_node A 0\n  dfa_is_node B 0\n  tab ! s1 ! s2 = Some m\n  dfa_is_node A s1\n  dfa_is_node B s2", "have bij: \"m < length (snd (prod_dfs A B (0, 0))) \\<and> snd (prod_dfs A B (0, 0)) ! m = (s1, s2)\""], ["proof (prove)\nusing this:\n  dfa_is_node A 0\n  dfa_is_node B 0\n  tab ! s1 ! s2 = Some m\n  dfa_is_node A s1\n  dfa_is_node B s2\n\ngoal (1 subgoal):\n 1. m < length (snd (prod_dfs A B (0, 0))) \\<and>\n    snd (prod_dfs A B (0, 0)) ! m = (s1, s2)", "unfolding tab_def"], ["proof (prove)\nusing this:\n  dfa_is_node A 0\n  dfa_is_node B 0\n  fst (prod_dfs A B (0, 0)) ! s1 ! s2 = Some m\n  dfa_is_node A s1\n  dfa_is_node B s2\n\ngoal (1 subgoal):\n 1. m < length (snd (prod_dfs A B (0, 0))) \\<and>\n    snd (prod_dfs A B (0, 0)) ! m = (s1, s2)", "by (simp add: prod_dfs_bij[symmetric] prod_is_node_def)"], ["proof (state)\nthis:\n  m < length (snd (prod_dfs A B (0, 0))) \\<and>\n  snd (prod_dfs A B (0, 0)) ! m = (s1, s2)\n\ngoal (1 subgoal):\n 1. snd (binop_dfa f A B) ! dfa_steps (binop_dfa f A B) 0 bs =\n    f (snd A ! dfa_steps A 0 bs) (snd B ! dfa_steps B 0 bs)", "with mL"], ["proof (chain)\npicking this:\n  dfa_is_node (binop_dfa f A B) m\n  m < length (snd (prod_dfs A B (0, 0))) \\<and>\n  snd (prod_dfs A B (0, 0)) ! m = (s1, s2)", "have \"snd (binop_dfa f A B) ! m = f (snd A ! s1) (snd B ! s2)\""], ["proof (prove)\nusing this:\n  dfa_is_node (binop_dfa f A B) m\n  m < length (snd (prod_dfs A B (0, 0))) \\<and>\n  snd (prod_dfs A B (0, 0)) ! m = (s1, s2)\n\ngoal (1 subgoal):\n 1. snd (binop_dfa f A B) ! m = f (snd A ! s1) (snd B ! s2)", "by (simp add: binop_dfa_def split_beta dfa_is_node_def)"], ["proof (state)\nthis:\n  snd (binop_dfa f A B) ! m = f (snd A ! s1) (snd B ! s2)\n\ngoal (1 subgoal):\n 1. snd (binop_dfa f A B) ! dfa_steps (binop_dfa f A B) 0 bs =\n    f (snd A ! dfa_steps A 0 bs) (snd B ! dfa_steps B 0 bs)", "with M' s1_def s2_def"], ["proof (chain)\npicking this:\n  m = dfa_steps (binop_dfa f A B) 0 bs\n  s1 = dfa_steps A 0 bs\n  s2 = dfa_steps B 0 bs\n  snd (binop_dfa f A B) ! m = f (snd A ! s1) (snd B ! s2)", "show \"snd ?A ! dfa_steps ?A 0 bs = f (snd A ! dfa_steps A 0 bs) (snd B ! dfa_steps B 0 bs)\""], ["proof (prove)\nusing this:\n  m = dfa_steps (binop_dfa f A B) 0 bs\n  s1 = dfa_steps A 0 bs\n  s2 = dfa_steps B 0 bs\n  snd (binop_dfa f A B) ! m = f (snd A ! s1) (snd B ! s2)\n\ngoal (1 subgoal):\n 1. snd (binop_dfa f A B) ! dfa_steps (binop_dfa f A B) 0 bs =\n    f (snd A ! dfa_steps A 0 bs) (snd B ! dfa_steps B 0 bs)", "by simp"], ["proof (state)\nthis:\n  snd (binop_dfa f A B) ! dfa_steps (binop_dfa f A B) 0 bs =\n  f (snd A ! dfa_steps A 0 bs) (snd B ! dfa_steps B 0 bs)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma binop_wf_dfa:\n  assumes A: \"wf_dfa A n\" and B: \"wf_dfa B n\"\n  shows \"wf_dfa (binop_dfa f A B) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_dfa (binop_dfa f A B) n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_dfa (binop_dfa f A B) n", "from A B"], ["proof (chain)\npicking this:\n  wf_dfa A n\n  wf_dfa B n", "interpret prod_DFS A B n"], ["proof (prove)\nusing this:\n  wf_dfa A n\n  wf_dfa B n\n\ngoal (1 subgoal):\n 1. prod_DFS A B n", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_dfa (binop_dfa f A B) n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_dfa (binop_dfa f A B) n", "by (rule binop_wf_dfa)"], ["proof (state)\nthis:\n  wf_dfa (binop_dfa f A B) n\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem binop_dfa_accepts:\n  assumes A: \"wf_dfa A n\"\n  and B: \"wf_dfa B n\"\n  and X: \"list_all (is_alph n) bss\"\n  shows \"dfa_accepts (binop_dfa f A B) bss = f (dfa_accepts A bss) (dfa_accepts B bss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa_accepts (binop_dfa f A B) bss =\n    f (dfa_accepts A bss) (dfa_accepts B bss)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dfa_accepts (binop_dfa f A B) bss =\n    f (dfa_accepts A bss) (dfa_accepts B bss)", "from A B"], ["proof (chain)\npicking this:\n  wf_dfa A n\n  wf_dfa B n", "interpret prod_DFS A B n"], ["proof (prove)\nusing this:\n  wf_dfa A n\n  wf_dfa B n\n\ngoal (1 subgoal):\n 1. prod_DFS A B n", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. dfa_accepts (binop_dfa f A B) bss =\n    f (dfa_accepts A bss) (dfa_accepts B bss)", "from X"], ["proof (chain)\npicking this:\n  list_all (is_alph n) bss", "show ?thesis"], ["proof (prove)\nusing this:\n  list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. dfa_accepts (binop_dfa f A B) bss =\n    f (dfa_accepts A bss) (dfa_accepts B bss)", "by (simp add: accepts_def dfa_accepting_def binop_dfa_steps)"], ["proof (state)\nthis:\n  dfa_accepts (binop_dfa f A B) bss =\n  f (dfa_accepts A bss) (dfa_accepts B bss)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  and_dfa :: \"dfa \\<Rightarrow> dfa \\<Rightarrow> dfa\" where\n  \"and_dfa = binop_dfa (\\<and>)\""], ["", "lemma and_wf_dfa:\n  assumes \"wf_dfa M n\"\n  and \"wf_dfa N n\"\n  shows \"wf_dfa (and_dfa M N) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_dfa (and_dfa M N) n", "using assms"], ["proof (prove)\nusing this:\n  wf_dfa M n\n  wf_dfa N n\n\ngoal (1 subgoal):\n 1. wf_dfa (and_dfa M N) n", "by (simp add: and_dfa_def binop_wf_dfa)"], ["", "lemma and_dfa_accepts:\n  assumes \"wf_dfa M n\"\n  and \"wf_dfa N n\"\n  and \"list_all (is_alph n) bs\"\n  shows \"dfa_accepts (and_dfa M N) bs = (dfa_accepts M bs \\<and> dfa_accepts N bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa_accepts (and_dfa M N) bs =\n    (dfa_accepts M bs \\<and> dfa_accepts N bs)", "using assms"], ["proof (prove)\nusing this:\n  wf_dfa M n\n  wf_dfa N n\n  list_all (is_alph n) bs\n\ngoal (1 subgoal):\n 1. dfa_accepts (and_dfa M N) bs =\n    (dfa_accepts M bs \\<and> dfa_accepts N bs)", "by (simp add: binop_dfa_accepts and_dfa_def)"], ["", "definition\n  or_dfa :: \"dfa \\<Rightarrow> dfa \\<Rightarrow> dfa\" where\n  \"or_dfa = binop_dfa (\\<or>)\""], ["", "lemma or_wf_dfa:\n  assumes \"wf_dfa M n\" and \"wf_dfa N n\"\n  shows \"wf_dfa (or_dfa M N) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_dfa (or_dfa M N) n", "using assms"], ["proof (prove)\nusing this:\n  wf_dfa M n\n  wf_dfa N n\n\ngoal (1 subgoal):\n 1. wf_dfa (or_dfa M N) n", "by (simp add: or_dfa_def binop_wf_dfa)"], ["", "lemma or_dfa_accepts:\n  assumes \"wf_dfa M n\" and \"wf_dfa N n\"\n  and \"list_all (is_alph n) bs\"\n  shows \"dfa_accepts (or_dfa M N) bs = (dfa_accepts M bs \\<or> dfa_accepts N bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa_accepts (or_dfa M N) bs = (dfa_accepts M bs \\<or> dfa_accepts N bs)", "using assms"], ["proof (prove)\nusing this:\n  wf_dfa M n\n  wf_dfa N n\n  list_all (is_alph n) bs\n\ngoal (1 subgoal):\n 1. dfa_accepts (or_dfa M N) bs = (dfa_accepts M bs \\<or> dfa_accepts N bs)", "by (simp add: binop_dfa_accepts or_dfa_def)"], ["", "definition\n  imp_dfa :: \"dfa \\<Rightarrow> dfa \\<Rightarrow> dfa\" where\n  \"imp_dfa = binop_dfa (\\<longrightarrow>)\""], ["", "lemma imp_wf_dfa:\n  assumes \"wf_dfa M n\" and \"wf_dfa N n\"\n  shows \"wf_dfa (imp_dfa M N) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_dfa (imp_dfa M N) n", "using assms"], ["proof (prove)\nusing this:\n  wf_dfa M n\n  wf_dfa N n\n\ngoal (1 subgoal):\n 1. wf_dfa (imp_dfa M N) n", "by (simp add: binop_wf_dfa imp_dfa_def)"], ["", "lemma imp_dfa_accepts:\n  assumes \"wf_dfa M n\" and \"wf_dfa N n\"\n  and \"list_all (is_alph n) bs\"\n  shows \"dfa_accepts (imp_dfa M N) bs = (dfa_accepts M bs \\<longrightarrow> dfa_accepts N bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa_accepts (imp_dfa M N) bs =\n    (dfa_accepts M bs \\<longrightarrow> dfa_accepts N bs)", "using assms"], ["proof (prove)\nusing this:\n  wf_dfa M n\n  wf_dfa N n\n  list_all (is_alph n) bs\n\ngoal (1 subgoal):\n 1. dfa_accepts (imp_dfa M N) bs =\n    (dfa_accepts M bs \\<longrightarrow> dfa_accepts N bs)", "by (auto simp add: binop_dfa_accepts imp_dfa_def)"], ["", "subsection \\<open>Transforming DFAs to NFAs\\<close>"], ["", "definition\n  nfa_of_dfa :: \"dfa \\<Rightarrow> nfa\" where\n  \"nfa_of_dfa = (\\<lambda>(bdd,as). (map (bdd_map (\\<lambda>q. (replicate (length bdd) False)[q:=True])) bdd, as))\""], ["", "lemma dfa2wf_nfa:\n  assumes \"wf_dfa M n\"\n  shows \"wf_nfa (nfa_of_dfa M) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_nfa (nfa_of_dfa M) n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_nfa (nfa_of_dfa M) n", "have \"\\<And>a. dfa_is_node M a \\<Longrightarrow> nfa_is_node (nfa_of_dfa M) ((replicate (length (fst M)) False)[a:=True])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       dfa_is_node M a \\<Longrightarrow>\n       nfa_is_node (nfa_of_dfa M)\n        ((replicate (length (fst M)) False)[a := True])", "by (simp add: dfa_is_node_def nfa_is_node_def nfa_of_dfa_def split_beta)"], ["proof (state)\nthis:\n  dfa_is_node M ?a \\<Longrightarrow>\n  nfa_is_node (nfa_of_dfa M)\n   ((replicate (length (fst M)) False)[?a := True])\n\ngoal (1 subgoal):\n 1. wf_nfa (nfa_of_dfa M) n", "hence \"\\<And>bdd. bdd_all (dfa_is_node M) bdd \\<Longrightarrow> bdd_all (nfa_is_node (nfa_of_dfa M)) (bdd_map (\\<lambda>q. (replicate (length (fst M)) False)[q:=True]) bdd)\""], ["proof (prove)\nusing this:\n  dfa_is_node M ?a \\<Longrightarrow>\n  nfa_is_node (nfa_of_dfa M)\n   ((replicate (length (fst M)) False)[?a := True])\n\ngoal (1 subgoal):\n 1. \\<And>bdd.\n       bdd_all (dfa_is_node M) bdd \\<Longrightarrow>\n       bdd_all (nfa_is_node (nfa_of_dfa M))\n        (bdd_map (\\<lambda>q. (replicate (length (fst M)) False)[q := True])\n          bdd)", "by (simp add: bdd_all_bdd_map)"], ["proof (state)\nthis:\n  bdd_all (dfa_is_node M) ?bdd \\<Longrightarrow>\n  bdd_all (nfa_is_node (nfa_of_dfa M))\n   (bdd_map (\\<lambda>q. (replicate (length (fst M)) False)[q := True])\n     ?bdd)\n\ngoal (1 subgoal):\n 1. wf_nfa (nfa_of_dfa M) n", "with assms"], ["proof (chain)\npicking this:\n  wf_dfa M n\n  bdd_all (dfa_is_node M) ?bdd \\<Longrightarrow>\n  bdd_all (nfa_is_node (nfa_of_dfa M))\n   (bdd_map (\\<lambda>q. (replicate (length (fst M)) False)[q := True])\n     ?bdd)", "have \"list_all (bdd_all (nfa_is_node (nfa_of_dfa M))) (fst (nfa_of_dfa M))\""], ["proof (prove)\nusing this:\n  wf_dfa M n\n  bdd_all (dfa_is_node M) ?bdd \\<Longrightarrow>\n  bdd_all (nfa_is_node (nfa_of_dfa M))\n   (bdd_map (\\<lambda>q. (replicate (length (fst M)) False)[q := True])\n     ?bdd)\n\ngoal (1 subgoal):\n 1. list_all (bdd_all (nfa_is_node (nfa_of_dfa M))) (fst (nfa_of_dfa M))", "by (simp add: list_all_iff split_beta nfa_of_dfa_def wf_dfa_def)"], ["proof (state)\nthis:\n  list_all (bdd_all (nfa_is_node (nfa_of_dfa M))) (fst (nfa_of_dfa M))\n\ngoal (1 subgoal):\n 1. wf_nfa (nfa_of_dfa M) n", "with assms"], ["proof (chain)\npicking this:\n  wf_dfa M n\n  list_all (bdd_all (nfa_is_node (nfa_of_dfa M))) (fst (nfa_of_dfa M))", "show ?thesis"], ["proof (prove)\nusing this:\n  wf_dfa M n\n  list_all (bdd_all (nfa_is_node (nfa_of_dfa M))) (fst (nfa_of_dfa M))\n\ngoal (1 subgoal):\n 1. wf_nfa (nfa_of_dfa M) n", "by (simp add: wf_nfa_def wf_dfa_def nfa_of_dfa_def split_beta list_all_iff bddh_bdd_map)"], ["proof (state)\nthis:\n  wf_nfa (nfa_of_dfa M) n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma replicate_upd_inj: \"\\<lbrakk>q < n; (replicate n False)[q:=True] = (replicate n False)[p:=True]\\<rbrakk> \\<Longrightarrow> (q = p)\" (is \"\\<lbrakk>_ ;?lhs = ?rhs\\<rbrakk> \\<Longrightarrow>  _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q < n;\n     (replicate n False)[q := True] = (replicate n False)\n     [p := True]\\<rbrakk>\n    \\<Longrightarrow> q = p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>q < n;\n     (replicate n False)[q := True] = (replicate n False)\n     [p := True]\\<rbrakk>\n    \\<Longrightarrow> q = p", "assume q: \"q < n\" and r: \"?lhs = ?rhs\""], ["proof (state)\nthis:\n  q < n\n  (replicate n False)[q := True] = (replicate n False)[p := True]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q < n;\n     (replicate n False)[q := True] = (replicate n False)\n     [p := True]\\<rbrakk>\n    \\<Longrightarrow> q = p", "{"], ["proof (state)\nthis:\n  q < n\n  (replicate n False)[q := True] = (replicate n False)[p := True]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q < n;\n     (replicate n False)[q := True] = (replicate n False)\n     [p := True]\\<rbrakk>\n    \\<Longrightarrow> q = p", "assume \"p \\<noteq> q\""], ["proof (state)\nthis:\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q < n;\n     (replicate n False)[q := True] = (replicate n False)\n     [p := True]\\<rbrakk>\n    \\<Longrightarrow> q = p", "with q"], ["proof (chain)\npicking this:\n  q < n\n  p \\<noteq> q", "have \"?lhs ! q = True\""], ["proof (prove)\nusing this:\n  q < n\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. (replicate n False)[q := True] ! q = True", "by simp"], ["proof (state)\nthis:\n  (replicate n False)[q := True] ! q = True\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q < n;\n     (replicate n False)[q := True] = (replicate n False)\n     [p := True]\\<rbrakk>\n    \\<Longrightarrow> q = p", "moreover"], ["proof (state)\nthis:\n  (replicate n False)[q := True] ! q = True\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q < n;\n     (replicate n False)[q := True] = (replicate n False)\n     [p := True]\\<rbrakk>\n    \\<Longrightarrow> q = p", "from \\<open>p \\<noteq> q\\<close> q"], ["proof (chain)\npicking this:\n  p \\<noteq> q\n  q < n", "have \"?rhs ! q = False\""], ["proof (prove)\nusing this:\n  p \\<noteq> q\n  q < n\n\ngoal (1 subgoal):\n 1. (replicate n False)[p := True] ! q = False", "by simp"], ["proof (state)\nthis:\n  (replicate n False)[p := True] ! q = False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q < n;\n     (replicate n False)[q := True] = (replicate n False)\n     [p := True]\\<rbrakk>\n    \\<Longrightarrow> q = p", "ultimately"], ["proof (chain)\npicking this:\n  (replicate n False)[q := True] ! q = True\n  (replicate n False)[p := True] ! q = False", "have \"?lhs \\<noteq> ?rhs\""], ["proof (prove)\nusing this:\n  (replicate n False)[q := True] ! q = True\n  (replicate n False)[p := True] ! q = False\n\ngoal (1 subgoal):\n 1. (replicate n False)[q := True] \\<noteq> (replicate n False)[p := True]", "by auto"], ["proof (state)\nthis:\n  (replicate n False)[q := True] \\<noteq> (replicate n False)[p := True]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q < n;\n     (replicate n False)[q := True] = (replicate n False)\n     [p := True]\\<rbrakk>\n    \\<Longrightarrow> q = p", "}"], ["proof (state)\nthis:\n  p \\<noteq> q \\<Longrightarrow>\n  (replicate n False)[q := True] \\<noteq> (replicate n False)[p := True]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q < n;\n     (replicate n False)[q := True] = (replicate n False)\n     [p := True]\\<rbrakk>\n    \\<Longrightarrow> q = p", "with r"], ["proof (chain)\npicking this:\n  (replicate n False)[q := True] = (replicate n False)[p := True]\n  p \\<noteq> q \\<Longrightarrow>\n  (replicate n False)[q := True] \\<noteq> (replicate n False)[p := True]", "show \"q = p\""], ["proof (prove)\nusing this:\n  (replicate n False)[q := True] = (replicate n False)[p := True]\n  p \\<noteq> q \\<Longrightarrow>\n  (replicate n False)[q := True] \\<noteq> (replicate n False)[p := True]\n\ngoal (1 subgoal):\n 1. q = p", "by auto"], ["proof (state)\nthis:\n  q = p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nfa_of_dfa_reach':\n  assumes V: \"wf_dfa M l\"\n  and X: \"list_all (is_alph l) bss\"\n  and N: \"n1 = (replicate (length (fst M)) False)[q:=True]\"\n  and Q: \"dfa_is_node M q\"\n  and R: \"nfa_reach (nfa_of_dfa M) n1 bss n2\"\n  shows \"\\<exists>p. dfa_reach M q bss p \\<and> n2 = (replicate (length (fst M)) False)[p:=True]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p.\n       dfa_reach M q bss p \\<and>\n       n2 = (replicate (length (fst M)) False)[p := True]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p.\n       dfa_reach M q bss p \\<and>\n       n2 = (replicate (length (fst M)) False)[p := True]", "from R V X N Q"], ["proof (chain)\npicking this:\n  nfa_reach (nfa_of_dfa M) n1 bss n2\n  wf_dfa M l\n  list_all (is_alph l) bss\n  n1 = (replicate (length (fst M)) False)[q := True]\n  dfa_is_node M q", "show ?thesis"], ["proof (prove)\nusing this:\n  nfa_reach (nfa_of_dfa M) n1 bss n2\n  wf_dfa M l\n  list_all (is_alph l) bss\n  n1 = (replicate (length (fst M)) False)[q := True]\n  dfa_is_node M q\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       dfa_reach M q bss p \\<and>\n       n2 = (replicate (length (fst M)) False)[p := True]", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_dfa M l; list_all (is_alph l) [];\n     n1 = (replicate (length (fst M)) False)[q := True];\n     dfa_is_node M q\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p.\n                         dfa_reach M q [] p \\<and>\n                         n1 = (replicate (length (fst M)) False)[p := True]\n 2. \\<And>k x y.\n       \\<lbrakk>nfa_reach (nfa_of_dfa M) n1 x k;\n        \\<lbrakk>wf_dfa M l; list_all (is_alph l) x;\n         n1 = (replicate (length (fst M)) False)[q := True];\n         dfa_is_node M q\\<rbrakk>\n        \\<Longrightarrow> \\<exists>p.\n                             dfa_reach M q x p \\<and>\n                             k = (replicate (length (fst M)) False)\n                             [p := True];\n        wf_dfa M l; list_all (is_alph l) (x @ [y]);\n        n1 = (replicate (length (fst M)) False)[q := True];\n        dfa_is_node M q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            dfa_reach M q (x @ [y]) p \\<and>\n                            nfa_trans (nfa_of_dfa M) k y =\n                            (replicate (length (fst M)) False)[p := True]", "case Nil"], ["proof (state)\nthis:\n  wf_dfa M l\n  list_all (is_alph l) []\n  n1 = (replicate (length (fst M)) False)[q := True]\n  dfa_is_node M q\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_dfa M l; list_all (is_alph l) [];\n     n1 = (replicate (length (fst M)) False)[q := True];\n     dfa_is_node M q\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p.\n                         dfa_reach M q [] p \\<and>\n                         n1 = (replicate (length (fst M)) False)[p := True]\n 2. \\<And>k x y.\n       \\<lbrakk>nfa_reach (nfa_of_dfa M) n1 x k;\n        \\<lbrakk>wf_dfa M l; list_all (is_alph l) x;\n         n1 = (replicate (length (fst M)) False)[q := True];\n         dfa_is_node M q\\<rbrakk>\n        \\<Longrightarrow> \\<exists>p.\n                             dfa_reach M q x p \\<and>\n                             k = (replicate (length (fst M)) False)\n                             [p := True];\n        wf_dfa M l; list_all (is_alph l) (x @ [y]);\n        n1 = (replicate (length (fst M)) False)[q := True];\n        dfa_is_node M q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            dfa_reach M q (x @ [y]) p \\<and>\n                            nfa_trans (nfa_of_dfa M) k y =\n                            (replicate (length (fst M)) False)[p := True]", "hence \"dfa_reach M q [] q\""], ["proof (prove)\nusing this:\n  wf_dfa M l\n  list_all (is_alph l) []\n  n1 = (replicate (length (fst M)) False)[q := True]\n  dfa_is_node M q\n\ngoal (1 subgoal):\n 1. dfa_reach M q [] q", "by (simp add: reach_nil)"], ["proof (state)\nthis:\n  dfa_reach M q [] q\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_dfa M l; list_all (is_alph l) [];\n     n1 = (replicate (length (fst M)) False)[q := True];\n     dfa_is_node M q\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p.\n                         dfa_reach M q [] p \\<and>\n                         n1 = (replicate (length (fst M)) False)[p := True]\n 2. \\<And>k x y.\n       \\<lbrakk>nfa_reach (nfa_of_dfa M) n1 x k;\n        \\<lbrakk>wf_dfa M l; list_all (is_alph l) x;\n         n1 = (replicate (length (fst M)) False)[q := True];\n         dfa_is_node M q\\<rbrakk>\n        \\<Longrightarrow> \\<exists>p.\n                             dfa_reach M q x p \\<and>\n                             k = (replicate (length (fst M)) False)\n                             [p := True];\n        wf_dfa M l; list_all (is_alph l) (x @ [y]);\n        n1 = (replicate (length (fst M)) False)[q := True];\n        dfa_is_node M q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            dfa_reach M q (x @ [y]) p \\<and>\n                            nfa_trans (nfa_of_dfa M) k y =\n                            (replicate (length (fst M)) False)[p := True]", "with Nil"], ["proof (chain)\npicking this:\n  wf_dfa M l\n  list_all (is_alph l) []\n  n1 = (replicate (length (fst M)) False)[q := True]\n  dfa_is_node M q\n  dfa_reach M q [] q", "show ?case"], ["proof (prove)\nusing this:\n  wf_dfa M l\n  list_all (is_alph l) []\n  n1 = (replicate (length (fst M)) False)[q := True]\n  dfa_is_node M q\n  dfa_reach M q [] q\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       dfa_reach M q [] p \\<and>\n       n1 = (replicate (length (fst M)) False)[p := True]", "by auto"], ["proof (state)\nthis:\n  \\<exists>p.\n     dfa_reach M q [] p \\<and>\n     n1 = (replicate (length (fst M)) False)[p := True]\n\ngoal (1 subgoal):\n 1. \\<And>k x y.\n       \\<lbrakk>nfa_reach (nfa_of_dfa M) n1 x k;\n        \\<lbrakk>wf_dfa M l; list_all (is_alph l) x;\n         n1 = (replicate (length (fst M)) False)[q := True];\n         dfa_is_node M q\\<rbrakk>\n        \\<Longrightarrow> \\<exists>p.\n                             dfa_reach M q x p \\<and>\n                             k = (replicate (length (fst M)) False)\n                             [p := True];\n        wf_dfa M l; list_all (is_alph l) (x @ [y]);\n        n1 = (replicate (length (fst M)) False)[q := True];\n        dfa_is_node M q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            dfa_reach M q (x @ [y]) p \\<and>\n                            nfa_trans (nfa_of_dfa M) k y =\n                            (replicate (length (fst M)) False)[p := True]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k x y.\n       \\<lbrakk>nfa_reach (nfa_of_dfa M) n1 x k;\n        \\<lbrakk>wf_dfa M l; list_all (is_alph l) x;\n         n1 = (replicate (length (fst M)) False)[q := True];\n         dfa_is_node M q\\<rbrakk>\n        \\<Longrightarrow> \\<exists>p.\n                             dfa_reach M q x p \\<and>\n                             k = (replicate (length (fst M)) False)\n                             [p := True];\n        wf_dfa M l; list_all (is_alph l) (x @ [y]);\n        n1 = (replicate (length (fst M)) False)[q := True];\n        dfa_is_node M q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            dfa_reach M q (x @ [y]) p \\<and>\n                            nfa_trans (nfa_of_dfa M) k y =\n                            (replicate (length (fst M)) False)[p := True]", "case (snoc j bss bs)"], ["proof (state)\nthis:\n  nfa_reach (nfa_of_dfa M) n1 bss j\n  \\<lbrakk>wf_dfa M l; list_all (is_alph l) bss;\n   n1 = (replicate (length (fst M)) False)[q := True];\n   dfa_is_node M q\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       dfa_reach M q bss p \\<and>\n                       j = (replicate (length (fst M)) False)[p := True]\n  wf_dfa M l\n  list_all (is_alph l) (bss @ [bs])\n  n1 = (replicate (length (fst M)) False)[q := True]\n  dfa_is_node M q\n\ngoal (1 subgoal):\n 1. \\<And>k x y.\n       \\<lbrakk>nfa_reach (nfa_of_dfa M) n1 x k;\n        \\<lbrakk>wf_dfa M l; list_all (is_alph l) x;\n         n1 = (replicate (length (fst M)) False)[q := True];\n         dfa_is_node M q\\<rbrakk>\n        \\<Longrightarrow> \\<exists>p.\n                             dfa_reach M q x p \\<and>\n                             k = (replicate (length (fst M)) False)\n                             [p := True];\n        wf_dfa M l; list_all (is_alph l) (x @ [y]);\n        n1 = (replicate (length (fst M)) False)[q := True];\n        dfa_is_node M q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            dfa_reach M q (x @ [y]) p \\<and>\n                            nfa_trans (nfa_of_dfa M) k y =\n                            (replicate (length (fst M)) False)[p := True]", "hence N1: \"nfa_is_node (nfa_of_dfa M) n1\""], ["proof (prove)\nusing this:\n  nfa_reach (nfa_of_dfa M) n1 bss j\n  \\<lbrakk>wf_dfa M l; list_all (is_alph l) bss;\n   n1 = (replicate (length (fst M)) False)[q := True];\n   dfa_is_node M q\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       dfa_reach M q bss p \\<and>\n                       j = (replicate (length (fst M)) False)[p := True]\n  wf_dfa M l\n  list_all (is_alph l) (bss @ [bs])\n  n1 = (replicate (length (fst M)) False)[q := True]\n  dfa_is_node M q\n\ngoal (1 subgoal):\n 1. nfa_is_node (nfa_of_dfa M) n1", "by (simp add: nfa_is_node_def nfa_of_dfa_def split_beta)"], ["proof (state)\nthis:\n  nfa_is_node (nfa_of_dfa M) n1\n\ngoal (1 subgoal):\n 1. \\<And>k x y.\n       \\<lbrakk>nfa_reach (nfa_of_dfa M) n1 x k;\n        \\<lbrakk>wf_dfa M l; list_all (is_alph l) x;\n         n1 = (replicate (length (fst M)) False)[q := True];\n         dfa_is_node M q\\<rbrakk>\n        \\<Longrightarrow> \\<exists>p.\n                             dfa_reach M q x p \\<and>\n                             k = (replicate (length (fst M)) False)\n                             [p := True];\n        wf_dfa M l; list_all (is_alph l) (x @ [y]);\n        n1 = (replicate (length (fst M)) False)[q := True];\n        dfa_is_node M q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            dfa_reach M q (x @ [y]) p \\<and>\n                            nfa_trans (nfa_of_dfa M) k y =\n                            (replicate (length (fst M)) False)[p := True]", "from snoc"], ["proof (chain)\npicking this:\n  nfa_reach (nfa_of_dfa M) n1 bss j\n  \\<lbrakk>wf_dfa M l; list_all (is_alph l) bss;\n   n1 = (replicate (length (fst M)) False)[q := True];\n   dfa_is_node M q\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       dfa_reach M q bss p \\<and>\n                       j = (replicate (length (fst M)) False)[p := True]\n  wf_dfa M l\n  list_all (is_alph l) (bss @ [bs])\n  n1 = (replicate (length (fst M)) False)[q := True]\n  dfa_is_node M q", "have V2: \"wf_nfa (nfa_of_dfa M) l\""], ["proof (prove)\nusing this:\n  nfa_reach (nfa_of_dfa M) n1 bss j\n  \\<lbrakk>wf_dfa M l; list_all (is_alph l) bss;\n   n1 = (replicate (length (fst M)) False)[q := True];\n   dfa_is_node M q\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       dfa_reach M q bss p \\<and>\n                       j = (replicate (length (fst M)) False)[p := True]\n  wf_dfa M l\n  list_all (is_alph l) (bss @ [bs])\n  n1 = (replicate (length (fst M)) False)[q := True]\n  dfa_is_node M q\n\ngoal (1 subgoal):\n 1. wf_nfa (nfa_of_dfa M) l", "by (simp add: dfa2wf_nfa)"], ["proof (state)\nthis:\n  wf_nfa (nfa_of_dfa M) l\n\ngoal (1 subgoal):\n 1. \\<And>k x y.\n       \\<lbrakk>nfa_reach (nfa_of_dfa M) n1 x k;\n        \\<lbrakk>wf_dfa M l; list_all (is_alph l) x;\n         n1 = (replicate (length (fst M)) False)[q := True];\n         dfa_is_node M q\\<rbrakk>\n        \\<Longrightarrow> \\<exists>p.\n                             dfa_reach M q x p \\<and>\n                             k = (replicate (length (fst M)) False)\n                             [p := True];\n        wf_dfa M l; list_all (is_alph l) (x @ [y]);\n        n1 = (replicate (length (fst M)) False)[q := True];\n        dfa_is_node M q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            dfa_reach M q (x @ [y]) p \\<and>\n                            nfa_trans (nfa_of_dfa M) k y =\n                            (replicate (length (fst M)) False)[p := True]", "from snoc"], ["proof (chain)\npicking this:\n  nfa_reach (nfa_of_dfa M) n1 bss j\n  \\<lbrakk>wf_dfa M l; list_all (is_alph l) bss;\n   n1 = (replicate (length (fst M)) False)[q := True];\n   dfa_is_node M q\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       dfa_reach M q bss p \\<and>\n                       j = (replicate (length (fst M)) False)[p := True]\n  wf_dfa M l\n  list_all (is_alph l) (bss @ [bs])\n  n1 = (replicate (length (fst M)) False)[q := True]\n  dfa_is_node M q", "have \"\\<exists>p. dfa_reach M q bss p \\<and> j = (replicate (length (fst M)) False)[p := True]\""], ["proof (prove)\nusing this:\n  nfa_reach (nfa_of_dfa M) n1 bss j\n  \\<lbrakk>wf_dfa M l; list_all (is_alph l) bss;\n   n1 = (replicate (length (fst M)) False)[q := True];\n   dfa_is_node M q\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       dfa_reach M q bss p \\<and>\n                       j = (replicate (length (fst M)) False)[p := True]\n  wf_dfa M l\n  list_all (is_alph l) (bss @ [bs])\n  n1 = (replicate (length (fst M)) False)[q := True]\n  dfa_is_node M q\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       dfa_reach M q bss p \\<and>\n       j = (replicate (length (fst M)) False)[p := True]", "by simp"], ["proof (state)\nthis:\n  \\<exists>p.\n     dfa_reach M q bss p \\<and>\n     j = (replicate (length (fst M)) False)[p := True]\n\ngoal (1 subgoal):\n 1. \\<And>k x y.\n       \\<lbrakk>nfa_reach (nfa_of_dfa M) n1 x k;\n        \\<lbrakk>wf_dfa M l; list_all (is_alph l) x;\n         n1 = (replicate (length (fst M)) False)[q := True];\n         dfa_is_node M q\\<rbrakk>\n        \\<Longrightarrow> \\<exists>p.\n                             dfa_reach M q x p \\<and>\n                             k = (replicate (length (fst M)) False)\n                             [p := True];\n        wf_dfa M l; list_all (is_alph l) (x @ [y]);\n        n1 = (replicate (length (fst M)) False)[q := True];\n        dfa_is_node M q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            dfa_reach M q (x @ [y]) p \\<and>\n                            nfa_trans (nfa_of_dfa M) k y =\n                            (replicate (length (fst M)) False)[p := True]", "then"], ["proof (chain)\npicking this:\n  \\<exists>p.\n     dfa_reach M q bss p \\<and>\n     j = (replicate (length (fst M)) False)[p := True]", "obtain p where PR: \"dfa_reach M q bss p\" and J: \"j = (replicate (length (fst M)) False)[p:=True]\""], ["proof (prove)\nusing this:\n  \\<exists>p.\n     dfa_reach M q bss p \\<and>\n     j = (replicate (length (fst M)) False)[p := True]\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>dfa_reach M q bss p;\n         j = (replicate (length (fst M)) False)[p := True]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  dfa_reach M q bss p\n  j = (replicate (length (fst M)) False)[p := True]\n\ngoal (1 subgoal):\n 1. \\<And>k x y.\n       \\<lbrakk>nfa_reach (nfa_of_dfa M) n1 x k;\n        \\<lbrakk>wf_dfa M l; list_all (is_alph l) x;\n         n1 = (replicate (length (fst M)) False)[q := True];\n         dfa_is_node M q\\<rbrakk>\n        \\<Longrightarrow> \\<exists>p.\n                             dfa_reach M q x p \\<and>\n                             k = (replicate (length (fst M)) False)\n                             [p := True];\n        wf_dfa M l; list_all (is_alph l) (x @ [y]);\n        n1 = (replicate (length (fst M)) False)[q := True];\n        dfa_is_node M q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            dfa_reach M q (x @ [y]) p \\<and>\n                            nfa_trans (nfa_of_dfa M) k y =\n                            (replicate (length (fst M)) False)[p := True]", "hence JL: \"nfa_is_node (nfa_of_dfa M) j\""], ["proof (prove)\nusing this:\n  dfa_reach M q bss p\n  j = (replicate (length (fst M)) False)[p := True]\n\ngoal (1 subgoal):\n 1. nfa_is_node (nfa_of_dfa M) j", "by (simp add: nfa_is_node_def nfa_of_dfa_def split_beta)"], ["proof (state)\nthis:\n  nfa_is_node (nfa_of_dfa M) j\n\ngoal (1 subgoal):\n 1. \\<And>k x y.\n       \\<lbrakk>nfa_reach (nfa_of_dfa M) n1 x k;\n        \\<lbrakk>wf_dfa M l; list_all (is_alph l) x;\n         n1 = (replicate (length (fst M)) False)[q := True];\n         dfa_is_node M q\\<rbrakk>\n        \\<Longrightarrow> \\<exists>p.\n                             dfa_reach M q x p \\<and>\n                             k = (replicate (length (fst M)) False)\n                             [p := True];\n        wf_dfa M l; list_all (is_alph l) (x @ [y]);\n        n1 = (replicate (length (fst M)) False)[q := True];\n        dfa_is_node M q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            dfa_reach M q (x @ [y]) p \\<and>\n                            nfa_trans (nfa_of_dfa M) k y =\n                            (replicate (length (fst M)) False)[p := True]", "from snoc PR"], ["proof (chain)\npicking this:\n  nfa_reach (nfa_of_dfa M) n1 bss j\n  \\<lbrakk>wf_dfa M l; list_all (is_alph l) bss;\n   n1 = (replicate (length (fst M)) False)[q := True];\n   dfa_is_node M q\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       dfa_reach M q bss p \\<and>\n                       j = (replicate (length (fst M)) False)[p := True]\n  wf_dfa M l\n  list_all (is_alph l) (bss @ [bs])\n  n1 = (replicate (length (fst M)) False)[q := True]\n  dfa_is_node M q\n  dfa_reach M q bss p", "have PL: \"dfa_is_node M p\""], ["proof (prove)\nusing this:\n  nfa_reach (nfa_of_dfa M) n1 bss j\n  \\<lbrakk>wf_dfa M l; list_all (is_alph l) bss;\n   n1 = (replicate (length (fst M)) False)[q := True];\n   dfa_is_node M q\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       dfa_reach M q bss p \\<and>\n                       j = (replicate (length (fst M)) False)[p := True]\n  wf_dfa M l\n  list_all (is_alph l) (bss @ [bs])\n  n1 = (replicate (length (fst M)) False)[q := True]\n  dfa_is_node M q\n  dfa_reach M q bss p\n\ngoal (1 subgoal):\n 1. dfa_is_node M p", "by (simp add: dfa_reach_is_node)"], ["proof (state)\nthis:\n  dfa_is_node M p\n\ngoal (1 subgoal):\n 1. \\<And>k x y.\n       \\<lbrakk>nfa_reach (nfa_of_dfa M) n1 x k;\n        \\<lbrakk>wf_dfa M l; list_all (is_alph l) x;\n         n1 = (replicate (length (fst M)) False)[q := True];\n         dfa_is_node M q\\<rbrakk>\n        \\<Longrightarrow> \\<exists>p.\n                             dfa_reach M q x p \\<and>\n                             k = (replicate (length (fst M)) False)\n                             [p := True];\n        wf_dfa M l; list_all (is_alph l) (x @ [y]);\n        n1 = (replicate (length (fst M)) False)[q := True];\n        dfa_is_node M q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            dfa_reach M q (x @ [y]) p \\<and>\n                            nfa_trans (nfa_of_dfa M) k y =\n                            (replicate (length (fst M)) False)[p := True]", "with snoc JL"], ["proof (chain)\npicking this:\n  nfa_reach (nfa_of_dfa M) n1 bss j\n  \\<lbrakk>wf_dfa M l; list_all (is_alph l) bss;\n   n1 = (replicate (length (fst M)) False)[q := True];\n   dfa_is_node M q\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       dfa_reach M q bss p \\<and>\n                       j = (replicate (length (fst M)) False)[p := True]\n  wf_dfa M l\n  list_all (is_alph l) (bss @ [bs])\n  n1 = (replicate (length (fst M)) False)[q := True]\n  dfa_is_node M q\n  nfa_is_node (nfa_of_dfa M) j\n  dfa_is_node M p", "have PL': \"p < length j\""], ["proof (prove)\nusing this:\n  nfa_reach (nfa_of_dfa M) n1 bss j\n  \\<lbrakk>wf_dfa M l; list_all (is_alph l) bss;\n   n1 = (replicate (length (fst M)) False)[q := True];\n   dfa_is_node M q\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       dfa_reach M q bss p \\<and>\n                       j = (replicate (length (fst M)) False)[p := True]\n  wf_dfa M l\n  list_all (is_alph l) (bss @ [bs])\n  n1 = (replicate (length (fst M)) False)[q := True]\n  dfa_is_node M q\n  nfa_is_node (nfa_of_dfa M) j\n  dfa_is_node M p\n\ngoal (1 subgoal):\n 1. p < length j", "by (simp add: nfa_is_node_def dfa_is_node_def nfa_of_dfa_def split_beta)"], ["proof (state)\nthis:\n  p < length j\n\ngoal (1 subgoal):\n 1. \\<And>k x y.\n       \\<lbrakk>nfa_reach (nfa_of_dfa M) n1 x k;\n        \\<lbrakk>wf_dfa M l; list_all (is_alph l) x;\n         n1 = (replicate (length (fst M)) False)[q := True];\n         dfa_is_node M q\\<rbrakk>\n        \\<Longrightarrow> \\<exists>p.\n                             dfa_reach M q x p \\<and>\n                             k = (replicate (length (fst M)) False)\n                             [p := True];\n        wf_dfa M l; list_all (is_alph l) (x @ [y]);\n        n1 = (replicate (length (fst M)) False)[q := True];\n        dfa_is_node M q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            dfa_reach M q (x @ [y]) p \\<and>\n                            nfa_trans (nfa_of_dfa M) k y =\n                            (replicate (length (fst M)) False)[p := True]", "define m where \"m = dfa_trans M p bs\""], ["proof (state)\nthis:\n  m = dfa_trans M p bs\n\ngoal (1 subgoal):\n 1. \\<And>k x y.\n       \\<lbrakk>nfa_reach (nfa_of_dfa M) n1 x k;\n        \\<lbrakk>wf_dfa M l; list_all (is_alph l) x;\n         n1 = (replicate (length (fst M)) False)[q := True];\n         dfa_is_node M q\\<rbrakk>\n        \\<Longrightarrow> \\<exists>p.\n                             dfa_reach M q x p \\<and>\n                             k = (replicate (length (fst M)) False)\n                             [p := True];\n        wf_dfa M l; list_all (is_alph l) (x @ [y]);\n        n1 = (replicate (length (fst M)) False)[q := True];\n        dfa_is_node M q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            dfa_reach M q (x @ [y]) p \\<and>\n                            nfa_trans (nfa_of_dfa M) k y =\n                            (replicate (length (fst M)) False)[p := True]", "with snoc PR"], ["proof (chain)\npicking this:\n  nfa_reach (nfa_of_dfa M) n1 bss j\n  \\<lbrakk>wf_dfa M l; list_all (is_alph l) bss;\n   n1 = (replicate (length (fst M)) False)[q := True];\n   dfa_is_node M q\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       dfa_reach M q bss p \\<and>\n                       j = (replicate (length (fst M)) False)[p := True]\n  wf_dfa M l\n  list_all (is_alph l) (bss @ [bs])\n  n1 = (replicate (length (fst M)) False)[q := True]\n  dfa_is_node M q\n  dfa_reach M q bss p\n  m = dfa_trans M p bs", "have MR: \"dfa_reach M q (bss @ [bs]) m\""], ["proof (prove)\nusing this:\n  nfa_reach (nfa_of_dfa M) n1 bss j\n  \\<lbrakk>wf_dfa M l; list_all (is_alph l) bss;\n   n1 = (replicate (length (fst M)) False)[q := True];\n   dfa_is_node M q\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       dfa_reach M q bss p \\<and>\n                       j = (replicate (length (fst M)) False)[p := True]\n  wf_dfa M l\n  list_all (is_alph l) (bss @ [bs])\n  n1 = (replicate (length (fst M)) False)[q := True]\n  dfa_is_node M q\n  dfa_reach M q bss p\n  m = dfa_trans M p bs\n\ngoal (1 subgoal):\n 1. dfa_reach M q (bss @ [bs]) m", "by (simp add: reach_snoc)"], ["proof (state)\nthis:\n  dfa_reach M q (bss @ [bs]) m\n\ngoal (1 subgoal):\n 1. \\<And>k x y.\n       \\<lbrakk>nfa_reach (nfa_of_dfa M) n1 x k;\n        \\<lbrakk>wf_dfa M l; list_all (is_alph l) x;\n         n1 = (replicate (length (fst M)) False)[q := True];\n         dfa_is_node M q\\<rbrakk>\n        \\<Longrightarrow> \\<exists>p.\n                             dfa_reach M q x p \\<and>\n                             k = (replicate (length (fst M)) False)\n                             [p := True];\n        wf_dfa M l; list_all (is_alph l) (x @ [y]);\n        n1 = (replicate (length (fst M)) False)[q := True];\n        dfa_is_node M q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            dfa_reach M q (x @ [y]) p \\<and>\n                            nfa_trans (nfa_of_dfa M) k y =\n                            (replicate (length (fst M)) False)[p := True]", "with snoc"], ["proof (chain)\npicking this:\n  nfa_reach (nfa_of_dfa M) n1 bss j\n  \\<lbrakk>wf_dfa M l; list_all (is_alph l) bss;\n   n1 = (replicate (length (fst M)) False)[q := True];\n   dfa_is_node M q\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       dfa_reach M q bss p \\<and>\n                       j = (replicate (length (fst M)) False)[p := True]\n  wf_dfa M l\n  list_all (is_alph l) (bss @ [bs])\n  n1 = (replicate (length (fst M)) False)[q := True]\n  dfa_is_node M q\n  dfa_reach M q (bss @ [bs]) m", "have mL: \"dfa_is_node M m\""], ["proof (prove)\nusing this:\n  nfa_reach (nfa_of_dfa M) n1 bss j\n  \\<lbrakk>wf_dfa M l; list_all (is_alph l) bss;\n   n1 = (replicate (length (fst M)) False)[q := True];\n   dfa_is_node M q\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       dfa_reach M q bss p \\<and>\n                       j = (replicate (length (fst M)) False)[p := True]\n  wf_dfa M l\n  list_all (is_alph l) (bss @ [bs])\n  n1 = (replicate (length (fst M)) False)[q := True]\n  dfa_is_node M q\n  dfa_reach M q (bss @ [bs]) m\n\ngoal (1 subgoal):\n 1. dfa_is_node M m", "by (simp add: dfa_reach_is_node)"], ["proof (state)\nthis:\n  dfa_is_node M m\n\ngoal (1 subgoal):\n 1. \\<And>k x y.\n       \\<lbrakk>nfa_reach (nfa_of_dfa M) n1 x k;\n        \\<lbrakk>wf_dfa M l; list_all (is_alph l) x;\n         n1 = (replicate (length (fst M)) False)[q := True];\n         dfa_is_node M q\\<rbrakk>\n        \\<Longrightarrow> \\<exists>p.\n                             dfa_reach M q x p \\<and>\n                             k = (replicate (length (fst M)) False)\n                             [p := True];\n        wf_dfa M l; list_all (is_alph l) (x @ [y]);\n        n1 = (replicate (length (fst M)) False)[q := True];\n        dfa_is_node M q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            dfa_reach M q (x @ [y]) p \\<and>\n                            nfa_trans (nfa_of_dfa M) k y =\n                            (replicate (length (fst M)) False)[p := True]", "from V2 JL snoc"], ["proof (chain)\npicking this:\n  wf_nfa (nfa_of_dfa M) l\n  nfa_is_node (nfa_of_dfa M) j\n  nfa_reach (nfa_of_dfa M) n1 bss j\n  \\<lbrakk>wf_dfa M l; list_all (is_alph l) bss;\n   n1 = (replicate (length (fst M)) False)[q := True];\n   dfa_is_node M q\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       dfa_reach M q bss p \\<and>\n                       j = (replicate (length (fst M)) False)[p := True]\n  wf_dfa M l\n  list_all (is_alph l) (bss @ [bs])\n  n1 = (replicate (length (fst M)) False)[q := True]\n  dfa_is_node M q", "have \"nfa_is_node (nfa_of_dfa M) (nfa_trans (nfa_of_dfa M) j bs)\""], ["proof (prove)\nusing this:\n  wf_nfa (nfa_of_dfa M) l\n  nfa_is_node (nfa_of_dfa M) j\n  nfa_reach (nfa_of_dfa M) n1 bss j\n  \\<lbrakk>wf_dfa M l; list_all (is_alph l) bss;\n   n1 = (replicate (length (fst M)) False)[q := True];\n   dfa_is_node M q\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       dfa_reach M q bss p \\<and>\n                       j = (replicate (length (fst M)) False)[p := True]\n  wf_dfa M l\n  list_all (is_alph l) (bss @ [bs])\n  n1 = (replicate (length (fst M)) False)[q := True]\n  dfa_is_node M q\n\ngoal (1 subgoal):\n 1. nfa_is_node (nfa_of_dfa M) (nfa_trans (nfa_of_dfa M) j bs)", "by (simp add: nfa_trans_is_node)"], ["proof (state)\nthis:\n  nfa_is_node (nfa_of_dfa M) (nfa_trans (nfa_of_dfa M) j bs)\n\ngoal (1 subgoal):\n 1. \\<And>k x y.\n       \\<lbrakk>nfa_reach (nfa_of_dfa M) n1 x k;\n        \\<lbrakk>wf_dfa M l; list_all (is_alph l) x;\n         n1 = (replicate (length (fst M)) False)[q := True];\n         dfa_is_node M q\\<rbrakk>\n        \\<Longrightarrow> \\<exists>p.\n                             dfa_reach M q x p \\<and>\n                             k = (replicate (length (fst M)) False)\n                             [p := True];\n        wf_dfa M l; list_all (is_alph l) (x @ [y]);\n        n1 = (replicate (length (fst M)) False)[q := True];\n        dfa_is_node M q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            dfa_reach M q (x @ [y]) p \\<and>\n                            nfa_trans (nfa_of_dfa M) k y =\n                            (replicate (length (fst M)) False)[p := True]", "hence L: \"length (nfa_trans (nfa_of_dfa M) j bs) = length (fst M)\""], ["proof (prove)\nusing this:\n  nfa_is_node (nfa_of_dfa M) (nfa_trans (nfa_of_dfa M) j bs)\n\ngoal (1 subgoal):\n 1. length (nfa_trans (nfa_of_dfa M) j bs) = length (fst M)", "by (simp add: nfa_is_node_def nfa_of_dfa_def split_beta)"], ["proof (state)\nthis:\n  length (nfa_trans (nfa_of_dfa M) j bs) = length (fst M)\n\ngoal (1 subgoal):\n 1. \\<And>k x y.\n       \\<lbrakk>nfa_reach (nfa_of_dfa M) n1 x k;\n        \\<lbrakk>wf_dfa M l; list_all (is_alph l) x;\n         n1 = (replicate (length (fst M)) False)[q := True];\n         dfa_is_node M q\\<rbrakk>\n        \\<Longrightarrow> \\<exists>p.\n                             dfa_reach M q x p \\<and>\n                             k = (replicate (length (fst M)) False)\n                             [p := True];\n        wf_dfa M l; list_all (is_alph l) (x @ [y]);\n        n1 = (replicate (length (fst M)) False)[q := True];\n        dfa_is_node M q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            dfa_reach M q (x @ [y]) p \\<and>\n                            nfa_trans (nfa_of_dfa M) k y =\n                            (replicate (length (fst M)) False)[p := True]", "have \"nfa_trans (nfa_of_dfa M) j bs = (replicate (length (fst M)) False)[m := True]\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. nfa_trans (nfa_of_dfa M) j bs = (replicate (length (fst M)) False)\n    [m := True]", "proof (simp add: list_eq_iff_nth_eq L, intro strip)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (fst M) \\<Longrightarrow>\n       nfa_trans (nfa_of_dfa M) j bs ! i =\n       (replicate (length (fst M)) False)[m := True] ! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (fst M) \\<Longrightarrow>\n       nfa_trans (nfa_of_dfa M) j bs ! i =\n       (replicate (length (fst M)) False)[m := True] ! i", "assume H: \"i < length (fst M)\""], ["proof (state)\nthis:\n  i < length (fst M)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (fst M) \\<Longrightarrow>\n       nfa_trans (nfa_of_dfa M) j bs ! i =\n       (replicate (length (fst M)) False)[m := True] ! i", "show \"nfa_trans (nfa_of_dfa M) j bs ! i = (replicate (length (fst M)) False)[m := True] ! i\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. nfa_trans (nfa_of_dfa M) j bs ! i =\n    (replicate (length (fst M)) False)[m := True] ! i", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. nfa_trans (nfa_of_dfa M) j bs ! i \\<Longrightarrow>\n    (replicate (length (fst M)) False)[m := True] ! i\n 2. (replicate (length (fst M)) False)[m := True] ! i \\<Longrightarrow>\n    nfa_trans (nfa_of_dfa M) j bs ! i", "assume lhs: \"?lhs\""], ["proof (state)\nthis:\n  nfa_trans (nfa_of_dfa M) j bs ! i\n\ngoal (2 subgoals):\n 1. nfa_trans (nfa_of_dfa M) j bs ! i \\<Longrightarrow>\n    (replicate (length (fst M)) False)[m := True] ! i\n 2. (replicate (length (fst M)) False)[m := True] ! i \\<Longrightarrow>\n    nfa_trans (nfa_of_dfa M) j bs ! i", "from V2 snoc"], ["proof (chain)\npicking this:\n  wf_nfa (nfa_of_dfa M) l\n  nfa_reach (nfa_of_dfa M) n1 bss j\n  \\<lbrakk>wf_dfa M l; list_all (is_alph l) bss;\n   n1 = (replicate (length (fst M)) False)[q := True];\n   dfa_is_node M q\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       dfa_reach M q bss p \\<and>\n                       j = (replicate (length (fst M)) False)[p := True]\n  wf_dfa M l\n  list_all (is_alph l) (bss @ [bs])\n  n1 = (replicate (length (fst M)) False)[q := True]\n  dfa_is_node M q", "have \"wf_nfa (nfa_of_dfa M) (length bs)\""], ["proof (prove)\nusing this:\n  wf_nfa (nfa_of_dfa M) l\n  nfa_reach (nfa_of_dfa M) n1 bss j\n  \\<lbrakk>wf_dfa M l; list_all (is_alph l) bss;\n   n1 = (replicate (length (fst M)) False)[q := True];\n   dfa_is_node M q\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       dfa_reach M q bss p \\<and>\n                       j = (replicate (length (fst M)) False)[p := True]\n  wf_dfa M l\n  list_all (is_alph l) (bss @ [bs])\n  n1 = (replicate (length (fst M)) False)[q := True]\n  dfa_is_node M q\n\ngoal (1 subgoal):\n 1. wf_nfa (nfa_of_dfa M) (length bs)", "by (simp add: is_alph_def)"], ["proof (state)\nthis:\n  wf_nfa (nfa_of_dfa M) (length bs)\n\ngoal (2 subgoals):\n 1. nfa_trans (nfa_of_dfa M) j bs ! i \\<Longrightarrow>\n    (replicate (length (fst M)) False)[m := True] ! i\n 2. (replicate (length (fst M)) False)[m := True] ! i \\<Longrightarrow>\n    nfa_trans (nfa_of_dfa M) j bs ! i", "moreover"], ["proof (state)\nthis:\n  wf_nfa (nfa_of_dfa M) (length bs)\n\ngoal (2 subgoals):\n 1. nfa_trans (nfa_of_dfa M) j bs ! i \\<Longrightarrow>\n    (replicate (length (fst M)) False)[m := True] ! i\n 2. (replicate (length (fst M)) False)[m := True] ! i \\<Longrightarrow>\n    nfa_trans (nfa_of_dfa M) j bs ! i", "note JL"], ["proof (state)\nthis:\n  nfa_is_node (nfa_of_dfa M) j\n\ngoal (2 subgoals):\n 1. nfa_trans (nfa_of_dfa M) j bs ! i \\<Longrightarrow>\n    (replicate (length (fst M)) False)[m := True] ! i\n 2. (replicate (length (fst M)) False)[m := True] ! i \\<Longrightarrow>\n    nfa_trans (nfa_of_dfa M) j bs ! i", "moreover"], ["proof (state)\nthis:\n  nfa_is_node (nfa_of_dfa M) j\n\ngoal (2 subgoals):\n 1. nfa_trans (nfa_of_dfa M) j bs ! i \\<Longrightarrow>\n    (replicate (length (fst M)) False)[m := True] ! i\n 2. (replicate (length (fst M)) False)[m := True] ! i \\<Longrightarrow>\n    nfa_trans (nfa_of_dfa M) j bs ! i", "from H"], ["proof (chain)\npicking this:\n  i < length (fst M)", "have IL: \"i < length (fst (nfa_of_dfa M))\""], ["proof (prove)\nusing this:\n  i < length (fst M)\n\ngoal (1 subgoal):\n 1. i < length (fst (nfa_of_dfa M))", "by (simp add: nfa_of_dfa_def split_beta)"], ["proof (state)\nthis:\n  i < length (fst (nfa_of_dfa M))\n\ngoal (2 subgoals):\n 1. nfa_trans (nfa_of_dfa M) j bs ! i \\<Longrightarrow>\n    (replicate (length (fst M)) False)[m := True] ! i\n 2. (replicate (length (fst M)) False)[m := True] ! i \\<Longrightarrow>\n    nfa_trans (nfa_of_dfa M) j bs ! i", "moreover"], ["proof (state)\nthis:\n  i < length (fst (nfa_of_dfa M))\n\ngoal (2 subgoals):\n 1. nfa_trans (nfa_of_dfa M) j bs ! i \\<Longrightarrow>\n    (replicate (length (fst M)) False)[m := True] ! i\n 2. (replicate (length (fst M)) False)[m := True] ! i \\<Longrightarrow>\n    nfa_trans (nfa_of_dfa M) j bs ! i", "from \\<open>?lhs\\<close>"], ["proof (chain)\npicking this:\n  nfa_trans (nfa_of_dfa M) j bs ! i", "have \"bdd_lookup (subsetbdd (fst (nfa_of_dfa M)) j (nfa_emptybdd (length j))) bs ! i\""], ["proof (prove)\nusing this:\n  nfa_trans (nfa_of_dfa M) j bs ! i\n\ngoal (1 subgoal):\n 1. bdd_lookup (subsetbdd (fst (nfa_of_dfa M)) j (nfa_emptybdd (length j)))\n     bs !\n    i", "by (simp add: nfa_trans_def)"], ["proof (state)\nthis:\n  bdd_lookup (subsetbdd (fst (nfa_of_dfa M)) j (nfa_emptybdd (length j)))\n   bs !\n  i\n\ngoal (2 subgoals):\n 1. nfa_trans (nfa_of_dfa M) j bs ! i \\<Longrightarrow>\n    (replicate (length (fst M)) False)[m := True] ! i\n 2. (replicate (length (fst M)) False)[m := True] ! i \\<Longrightarrow>\n    nfa_trans (nfa_of_dfa M) j bs ! i", "ultimately"], ["proof (chain)\npicking this:\n  wf_nfa (nfa_of_dfa M) (length bs)\n  nfa_is_node (nfa_of_dfa M) j\n  i < length (fst (nfa_of_dfa M))\n  bdd_lookup (subsetbdd (fst (nfa_of_dfa M)) j (nfa_emptybdd (length j)))\n   bs !\n  i", "have \"\\<exists>x < length j. j ! x \\<and> bdd_lookup (fst (nfa_of_dfa M) ! x) bs ! i\""], ["proof (prove)\nusing this:\n  wf_nfa (nfa_of_dfa M) (length bs)\n  nfa_is_node (nfa_of_dfa M) j\n  i < length (fst (nfa_of_dfa M))\n  bdd_lookup (subsetbdd (fst (nfa_of_dfa M)) j (nfa_emptybdd (length j)))\n   bs !\n  i\n\ngoal (1 subgoal):\n 1. \\<exists>x<length j.\n       j ! x \\<and> bdd_lookup (fst (nfa_of_dfa M) ! x) bs ! i", "by (simp add: bdd_lookup_subsetbdd)"], ["proof (state)\nthis:\n  \\<exists>x<length j.\n     j ! x \\<and> bdd_lookup (fst (nfa_of_dfa M) ! x) bs ! i\n\ngoal (2 subgoals):\n 1. nfa_trans (nfa_of_dfa M) j bs ! i \\<Longrightarrow>\n    (replicate (length (fst M)) False)[m := True] ! i\n 2. (replicate (length (fst M)) False)[m := True] ! i \\<Longrightarrow>\n    nfa_trans (nfa_of_dfa M) j bs ! i", "then"], ["proof (chain)\npicking this:\n  \\<exists>x<length j.\n     j ! x \\<and> bdd_lookup (fst (nfa_of_dfa M) ! x) bs ! i", "obtain x where xl: \"x < length j\" and xj: \"j ! x\" and xs: \"bdd_lookup (fst (nfa_of_dfa M) ! x) bs ! i\""], ["proof (prove)\nusing this:\n  \\<exists>x<length j.\n     j ! x \\<and> bdd_lookup (fst (nfa_of_dfa M) ! x) bs ! i\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x < length j; j ! x;\n         bdd_lookup (fst (nfa_of_dfa M) ! x) bs ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x < length j\n  j ! x\n  bdd_lookup (fst (nfa_of_dfa M) ! x) bs ! i\n\ngoal (2 subgoals):\n 1. nfa_trans (nfa_of_dfa M) j bs ! i \\<Longrightarrow>\n    (replicate (length (fst M)) False)[m := True] ! i\n 2. (replicate (length (fst M)) False)[m := True] ! i \\<Longrightarrow>\n    nfa_trans (nfa_of_dfa M) j bs ! i", "with snoc J PL'"], ["proof (chain)\npicking this:\n  nfa_reach (nfa_of_dfa M) n1 bss j\n  \\<lbrakk>wf_dfa M l; list_all (is_alph l) bss;\n   n1 = (replicate (length (fst M)) False)[q := True];\n   dfa_is_node M q\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       dfa_reach M q bss p \\<and>\n                       j = (replicate (length (fst M)) False)[p := True]\n  wf_dfa M l\n  list_all (is_alph l) (bss @ [bs])\n  n1 = (replicate (length (fst M)) False)[q := True]\n  dfa_is_node M q\n  j = (replicate (length (fst M)) False)[p := True]\n  p < length j\n  x < length j\n  j ! x\n  bdd_lookup (fst (nfa_of_dfa M) ! x) bs ! i", "have \"x = p\""], ["proof (prove)\nusing this:\n  nfa_reach (nfa_of_dfa M) n1 bss j\n  \\<lbrakk>wf_dfa M l; list_all (is_alph l) bss;\n   n1 = (replicate (length (fst M)) False)[q := True];\n   dfa_is_node M q\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       dfa_reach M q bss p \\<and>\n                       j = (replicate (length (fst M)) False)[p := True]\n  wf_dfa M l\n  list_all (is_alph l) (bss @ [bs])\n  n1 = (replicate (length (fst M)) False)[q := True]\n  dfa_is_node M q\n  j = (replicate (length (fst M)) False)[p := True]\n  p < length j\n  x < length j\n  j ! x\n  bdd_lookup (fst (nfa_of_dfa M) ! x) bs ! i\n\ngoal (1 subgoal):\n 1. x = p", "by (cases \"p = x\") simp+"], ["proof (state)\nthis:\n  x = p\n\ngoal (2 subgoals):\n 1. nfa_trans (nfa_of_dfa M) j bs ! i \\<Longrightarrow>\n    (replicate (length (fst M)) False)[m := True] ! i\n 2. (replicate (length (fst M)) False)[m := True] ! i \\<Longrightarrow>\n    nfa_trans (nfa_of_dfa M) j bs ! i", "with xs PL snoc(3,4) m_def"], ["proof (chain)\npicking this:\n  bdd_lookup (fst (nfa_of_dfa M) ! x) bs ! i\n  dfa_is_node M p\n  wf_dfa M l\n  list_all (is_alph l) (bss @ [bs])\n  m = dfa_trans M p bs\n  x = p", "show \"(replicate (length (fst M)) False)[m := True] ! i\""], ["proof (prove)\nusing this:\n  bdd_lookup (fst (nfa_of_dfa M) ! x) bs ! i\n  dfa_is_node M p\n  wf_dfa M l\n  list_all (is_alph l) (bss @ [bs])\n  m = dfa_trans M p bs\n  x = p\n\ngoal (1 subgoal):\n 1. (replicate (length (fst M)) False)[m := True] ! i", "by (simp add: nfa_of_dfa_def split_beta dfa_trans_def dfa_is_node_def wf_dfa_def is_alph_def bdd_map_bdd_lookup list_all_iff)"], ["proof (state)\nthis:\n  (replicate (length (fst M)) False)[m := True] ! i\n\ngoal (1 subgoal):\n 1. (replicate (length (fst M)) False)[m := True] ! i \\<Longrightarrow>\n    nfa_trans (nfa_of_dfa M) j bs ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (replicate (length (fst M)) False)[m := True] ! i \\<Longrightarrow>\n    nfa_trans (nfa_of_dfa M) j bs ! i", "assume rhs: \"?rhs\""], ["proof (state)\nthis:\n  (replicate (length (fst M)) False)[m := True] ! i\n\ngoal (1 subgoal):\n 1. (replicate (length (fst M)) False)[m := True] ! i \\<Longrightarrow>\n    nfa_trans (nfa_of_dfa M) j bs ! i", "with H mL"], ["proof (chain)\npicking this:\n  i < length (fst M)\n  dfa_is_node M m\n  (replicate (length (fst M)) False)[m := True] ! i", "have \"m = i\""], ["proof (prove)\nusing this:\n  i < length (fst M)\n  dfa_is_node M m\n  (replicate (length (fst M)) False)[m := True] ! i\n\ngoal (1 subgoal):\n 1. m = i", "by (cases \"m = i\") (simp add: dfa_is_node_def)+"], ["proof (state)\nthis:\n  m = i\n\ngoal (1 subgoal):\n 1. (replicate (length (fst M)) False)[m := True] ! i \\<Longrightarrow>\n    nfa_trans (nfa_of_dfa M) j bs ! i", "from PL snoc(3,4) m_def \\<open>m = i\\<close> H"], ["proof (chain)\npicking this:\n  dfa_is_node M p\n  wf_dfa M l\n  list_all (is_alph l) (bss @ [bs])\n  m = dfa_trans M p bs\n  m = i\n  i < length (fst M)", "have \"bdd_lookup (fst (nfa_of_dfa M) ! p) bs ! i\""], ["proof (prove)\nusing this:\n  dfa_is_node M p\n  wf_dfa M l\n  list_all (is_alph l) (bss @ [bs])\n  m = dfa_trans M p bs\n  m = i\n  i < length (fst M)\n\ngoal (1 subgoal):\n 1. bdd_lookup (fst (nfa_of_dfa M) ! p) bs ! i", "by (simp add: nfa_of_dfa_def split_beta dfa_is_node_def wf_dfa_def is_alph_def list_all_iff bdd_map_bdd_lookup dfa_trans_def)"], ["proof (state)\nthis:\n  bdd_lookup (fst (nfa_of_dfa M) ! p) bs ! i\n\ngoal (1 subgoal):\n 1. (replicate (length (fst M)) False)[m := True] ! i \\<Longrightarrow>\n    nfa_trans (nfa_of_dfa M) j bs ! i", "with PL' J"], ["proof (chain)\npicking this:\n  p < length j\n  j = (replicate (length (fst M)) False)[p := True]\n  bdd_lookup (fst (nfa_of_dfa M) ! p) bs ! i", "have E: \"\\<exists>p < length j. j ! p \\<and> bdd_lookup( fst (nfa_of_dfa M) ! p) bs ! i\""], ["proof (prove)\nusing this:\n  p < length j\n  j = (replicate (length (fst M)) False)[p := True]\n  bdd_lookup (fst (nfa_of_dfa M) ! p) bs ! i\n\ngoal (1 subgoal):\n 1. \\<exists>p<length j.\n       j ! p \\<and> bdd_lookup (fst (nfa_of_dfa M) ! p) bs ! i", "by auto"], ["proof (state)\nthis:\n  \\<exists>p<length j.\n     j ! p \\<and> bdd_lookup (fst (nfa_of_dfa M) ! p) bs ! i\n\ngoal (1 subgoal):\n 1. (replicate (length (fst M)) False)[m := True] ! i \\<Longrightarrow>\n    nfa_trans (nfa_of_dfa M) j bs ! i", "from snoc(4) V2"], ["proof (chain)\npicking this:\n  list_all (is_alph l) (bss @ [bs])\n  wf_nfa (nfa_of_dfa M) l", "have V': \"wf_nfa (nfa_of_dfa M) (length bs)\""], ["proof (prove)\nusing this:\n  list_all (is_alph l) (bss @ [bs])\n  wf_nfa (nfa_of_dfa M) l\n\ngoal (1 subgoal):\n 1. wf_nfa (nfa_of_dfa M) (length bs)", "by (simp add: is_alph_def)"], ["proof (state)\nthis:\n  wf_nfa (nfa_of_dfa M) (length bs)\n\ngoal (1 subgoal):\n 1. (replicate (length (fst M)) False)[m := True] ! i \\<Longrightarrow>\n    nfa_trans (nfa_of_dfa M) j bs ! i", "from H"], ["proof (chain)\npicking this:\n  i < length (fst M)", "have H': \"i < length (fst (nfa_of_dfa M))\""], ["proof (prove)\nusing this:\n  i < length (fst M)\n\ngoal (1 subgoal):\n 1. i < length (fst (nfa_of_dfa M))", "by (simp add: nfa_of_dfa_def split_beta)"], ["proof (state)\nthis:\n  i < length (fst (nfa_of_dfa M))\n\ngoal (1 subgoal):\n 1. (replicate (length (fst M)) False)[m := True] ! i \\<Longrightarrow>\n    nfa_trans (nfa_of_dfa M) j bs ! i", "from H' V' E JL"], ["proof (chain)\npicking this:\n  i < length (fst (nfa_of_dfa M))\n  wf_nfa (nfa_of_dfa M) (length bs)\n  \\<exists>p<length j.\n     j ! p \\<and> bdd_lookup (fst (nfa_of_dfa M) ! p) bs ! i\n  nfa_is_node (nfa_of_dfa M) j", "have \"bdd_lookup (subsetbdd (fst (nfa_of_dfa M)) j (nfa_emptybdd (length j))) bs ! i\""], ["proof (prove)\nusing this:\n  i < length (fst (nfa_of_dfa M))\n  wf_nfa (nfa_of_dfa M) (length bs)\n  \\<exists>p<length j.\n     j ! p \\<and> bdd_lookup (fst (nfa_of_dfa M) ! p) bs ! i\n  nfa_is_node (nfa_of_dfa M) j\n\ngoal (1 subgoal):\n 1. bdd_lookup (subsetbdd (fst (nfa_of_dfa M)) j (nfa_emptybdd (length j)))\n     bs !\n    i", "by (simp add: bdd_lookup_subsetbdd)"], ["proof (state)\nthis:\n  bdd_lookup (subsetbdd (fst (nfa_of_dfa M)) j (nfa_emptybdd (length j)))\n   bs !\n  i\n\ngoal (1 subgoal):\n 1. (replicate (length (fst M)) False)[m := True] ! i \\<Longrightarrow>\n    nfa_trans (nfa_of_dfa M) j bs ! i", "thus \"?lhs\""], ["proof (prove)\nusing this:\n  bdd_lookup (subsetbdd (fst (nfa_of_dfa M)) j (nfa_emptybdd (length j)))\n   bs !\n  i\n\ngoal (1 subgoal):\n 1. nfa_trans (nfa_of_dfa M) j bs ! i", "by (simp add: nfa_trans_def)"], ["proof (state)\nthis:\n  nfa_trans (nfa_of_dfa M) j bs ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nfa_trans (nfa_of_dfa M) j bs ! i =\n  (replicate (length (fst M)) False)[m := True] ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nfa_trans (nfa_of_dfa M) j bs = (replicate (length (fst M)) False)\n  [m := True]\n\ngoal (1 subgoal):\n 1. \\<And>k x y.\n       \\<lbrakk>nfa_reach (nfa_of_dfa M) n1 x k;\n        \\<lbrakk>wf_dfa M l; list_all (is_alph l) x;\n         n1 = (replicate (length (fst M)) False)[q := True];\n         dfa_is_node M q\\<rbrakk>\n        \\<Longrightarrow> \\<exists>p.\n                             dfa_reach M q x p \\<and>\n                             k = (replicate (length (fst M)) False)\n                             [p := True];\n        wf_dfa M l; list_all (is_alph l) (x @ [y]);\n        n1 = (replicate (length (fst M)) False)[q := True];\n        dfa_is_node M q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            dfa_reach M q (x @ [y]) p \\<and>\n                            nfa_trans (nfa_of_dfa M) k y =\n                            (replicate (length (fst M)) False)[p := True]", "with MR"], ["proof (chain)\npicking this:\n  dfa_reach M q (bss @ [bs]) m\n  nfa_trans (nfa_of_dfa M) j bs = (replicate (length (fst M)) False)\n  [m := True]", "show ?case"], ["proof (prove)\nusing this:\n  dfa_reach M q (bss @ [bs]) m\n  nfa_trans (nfa_of_dfa M) j bs = (replicate (length (fst M)) False)\n  [m := True]\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       dfa_reach M q (bss @ [bs]) p \\<and>\n       nfa_trans (nfa_of_dfa M) j bs = (replicate (length (fst M)) False)\n       [p := True]", "by auto"], ["proof (state)\nthis:\n  \\<exists>p.\n     dfa_reach M q (bss @ [bs]) p \\<and>\n     nfa_trans (nfa_of_dfa M) j bs = (replicate (length (fst M)) False)\n     [p := True]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>p.\n     dfa_reach M q bss p \\<and>\n     n2 = (replicate (length (fst M)) False)[p := True]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nfa_of_dfa_reach:\n  assumes V: \"wf_dfa M l\"\n  and X: \"list_all (is_alph l) bss\"\n  and N1: \"n1 = (replicate (length (fst M)) False)[q:=True]\"\n  and N2: \"n2 = (replicate (length (fst M)) False)[p:=True]\"\n  and Q: \"dfa_is_node M q\"\n  shows \"nfa_reach (nfa_of_dfa M) n1 bss n2 = dfa_reach M q bss p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfa_reach (nfa_of_dfa M) n1 bss n2 = dfa_reach M q bss p", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. nfa_reach (nfa_of_dfa M) n1 bss n2 \\<Longrightarrow> dfa_reach M q bss p\n 2. dfa_reach M q bss p \\<Longrightarrow> nfa_reach (nfa_of_dfa M) n1 bss n2", "assume \"nfa_reach (nfa_of_dfa M) n1 bss n2\""], ["proof (state)\nthis:\n  nfa_reach (nfa_of_dfa M) n1 bss n2\n\ngoal (2 subgoals):\n 1. nfa_reach (nfa_of_dfa M) n1 bss n2 \\<Longrightarrow> dfa_reach M q bss p\n 2. dfa_reach M q bss p \\<Longrightarrow> nfa_reach (nfa_of_dfa M) n1 bss n2", "with assms"], ["proof (chain)\npicking this:\n  wf_dfa M l\n  list_all (is_alph l) bss\n  n1 = (replicate (length (fst M)) False)[q := True]\n  n2 = (replicate (length (fst M)) False)[p := True]\n  dfa_is_node M q\n  nfa_reach (nfa_of_dfa M) n1 bss n2", "have \"\\<exists>p. dfa_reach M q bss p \\<and> n2 = (replicate (length (fst M)) False)[p := True]\""], ["proof (prove)\nusing this:\n  wf_dfa M l\n  list_all (is_alph l) bss\n  n1 = (replicate (length (fst M)) False)[q := True]\n  n2 = (replicate (length (fst M)) False)[p := True]\n  dfa_is_node M q\n  nfa_reach (nfa_of_dfa M) n1 bss n2\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       dfa_reach M q bss p \\<and>\n       n2 = (replicate (length (fst M)) False)[p := True]", "by (simp add: nfa_of_dfa_reach')"], ["proof (state)\nthis:\n  \\<exists>p.\n     dfa_reach M q bss p \\<and>\n     n2 = (replicate (length (fst M)) False)[p := True]\n\ngoal (2 subgoals):\n 1. nfa_reach (nfa_of_dfa M) n1 bss n2 \\<Longrightarrow> dfa_reach M q bss p\n 2. dfa_reach M q bss p \\<Longrightarrow> nfa_reach (nfa_of_dfa M) n1 bss n2", "then"], ["proof (chain)\npicking this:\n  \\<exists>p.\n     dfa_reach M q bss p \\<and>\n     n2 = (replicate (length (fst M)) False)[p := True]", "obtain p' where R: \"dfa_reach M q bss p'\" and N2': \"n2 = (replicate (length (fst M)) False)[p' := True]\""], ["proof (prove)\nusing this:\n  \\<exists>p.\n     dfa_reach M q bss p \\<and>\n     n2 = (replicate (length (fst M)) False)[p := True]\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>dfa_reach M q bss p';\n         n2 = (replicate (length (fst M)) False)[p' := True]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  dfa_reach M q bss p'\n  n2 = (replicate (length (fst M)) False)[p' := True]\n\ngoal (2 subgoals):\n 1. nfa_reach (nfa_of_dfa M) n1 bss n2 \\<Longrightarrow> dfa_reach M q bss p\n 2. dfa_reach M q bss p \\<Longrightarrow> nfa_reach (nfa_of_dfa M) n1 bss n2", "from V R Q X"], ["proof (chain)\npicking this:\n  wf_dfa M l\n  dfa_reach M q bss p'\n  dfa_is_node M q\n  list_all (is_alph l) bss", "have \"dfa_is_node M p'\""], ["proof (prove)\nusing this:\n  wf_dfa M l\n  dfa_reach M q bss p'\n  dfa_is_node M q\n  list_all (is_alph l) bss\n\ngoal (1 subgoal):\n 1. dfa_is_node M p'", "by (simp add: dfa_reach_is_node)"], ["proof (state)\nthis:\n  dfa_is_node M p'\n\ngoal (2 subgoals):\n 1. nfa_reach (nfa_of_dfa M) n1 bss n2 \\<Longrightarrow> dfa_reach M q bss p\n 2. dfa_reach M q bss p \\<Longrightarrow> nfa_reach (nfa_of_dfa M) n1 bss n2", "with N2 N2'"], ["proof (chain)\npicking this:\n  n2 = (replicate (length (fst M)) False)[p := True]\n  n2 = (replicate (length (fst M)) False)[p' := True]\n  dfa_is_node M p'", "have \"p' = p\""], ["proof (prove)\nusing this:\n  n2 = (replicate (length (fst M)) False)[p := True]\n  n2 = (replicate (length (fst M)) False)[p' := True]\n  dfa_is_node M p'\n\ngoal (1 subgoal):\n 1. p' = p", "by (simp add: dfa_is_node_def replicate_upd_inj)"], ["proof (state)\nthis:\n  p' = p\n\ngoal (2 subgoals):\n 1. nfa_reach (nfa_of_dfa M) n1 bss n2 \\<Longrightarrow> dfa_reach M q bss p\n 2. dfa_reach M q bss p \\<Longrightarrow> nfa_reach (nfa_of_dfa M) n1 bss n2", "with R"], ["proof (chain)\npicking this:\n  dfa_reach M q bss p'\n  p' = p", "show \"dfa_reach M q bss p\""], ["proof (prove)\nusing this:\n  dfa_reach M q bss p'\n  p' = p\n\ngoal (1 subgoal):\n 1. dfa_reach M q bss p", "by simp"], ["proof (state)\nthis:\n  dfa_reach M q bss p\n\ngoal (1 subgoal):\n 1. dfa_reach M q bss p \\<Longrightarrow> nfa_reach (nfa_of_dfa M) n1 bss n2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. dfa_reach M q bss p \\<Longrightarrow> nfa_reach (nfa_of_dfa M) n1 bss n2", "assume H: \"dfa_reach M q bss p\""], ["proof (state)\nthis:\n  dfa_reach M q bss p\n\ngoal (1 subgoal):\n 1. dfa_reach M q bss p \\<Longrightarrow> nfa_reach (nfa_of_dfa M) n1 bss n2", "define n2' where \"n2' = nfa_steps (nfa_of_dfa M) n1 bss\""], ["proof (state)\nthis:\n  n2' = nfa_steps (nfa_of_dfa M) n1 bss\n\ngoal (1 subgoal):\n 1. dfa_reach M q bss p \\<Longrightarrow> nfa_reach (nfa_of_dfa M) n1 bss n2", "hence R': \"nfa_reach (nfa_of_dfa M) n1 bss n2'\""], ["proof (prove)\nusing this:\n  n2' = nfa_steps (nfa_of_dfa M) n1 bss\n\ngoal (1 subgoal):\n 1. nfa_reach (nfa_of_dfa M) n1 bss n2'", "by (simp add: reach_def)"], ["proof (state)\nthis:\n  nfa_reach (nfa_of_dfa M) n1 bss n2'\n\ngoal (1 subgoal):\n 1. dfa_reach M q bss p \\<Longrightarrow> nfa_reach (nfa_of_dfa M) n1 bss n2", "with assms"], ["proof (chain)\npicking this:\n  wf_dfa M l\n  list_all (is_alph l) bss\n  n1 = (replicate (length (fst M)) False)[q := True]\n  n2 = (replicate (length (fst M)) False)[p := True]\n  dfa_is_node M q\n  nfa_reach (nfa_of_dfa M) n1 bss n2'", "have \"\\<exists>p. dfa_reach M q bss p \\<and> n2' = (replicate (length (fst M)) False)[p := True]\""], ["proof (prove)\nusing this:\n  wf_dfa M l\n  list_all (is_alph l) bss\n  n1 = (replicate (length (fst M)) False)[q := True]\n  n2 = (replicate (length (fst M)) False)[p := True]\n  dfa_is_node M q\n  nfa_reach (nfa_of_dfa M) n1 bss n2'\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       dfa_reach M q bss p \\<and>\n       n2' = (replicate (length (fst M)) False)[p := True]", "by (simp add: nfa_of_dfa_reach')"], ["proof (state)\nthis:\n  \\<exists>p.\n     dfa_reach M q bss p \\<and>\n     n2' = (replicate (length (fst M)) False)[p := True]\n\ngoal (1 subgoal):\n 1. dfa_reach M q bss p \\<Longrightarrow> nfa_reach (nfa_of_dfa M) n1 bss n2", "then"], ["proof (chain)\npicking this:\n  \\<exists>p.\n     dfa_reach M q bss p \\<and>\n     n2' = (replicate (length (fst M)) False)[p := True]", "obtain p' where R: \"dfa_reach M q bss p'\" and N2': \"n2' = (replicate (length (fst M)) False)[p' := True]\""], ["proof (prove)\nusing this:\n  \\<exists>p.\n     dfa_reach M q bss p \\<and>\n     n2' = (replicate (length (fst M)) False)[p := True]\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>dfa_reach M q bss p';\n         n2' = (replicate (length (fst M)) False)[p' := True]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  dfa_reach M q bss p'\n  n2' = (replicate (length (fst M)) False)[p' := True]\n\ngoal (1 subgoal):\n 1. dfa_reach M q bss p \\<Longrightarrow> nfa_reach (nfa_of_dfa M) n1 bss n2", "with H"], ["proof (chain)\npicking this:\n  dfa_reach M q bss p\n  dfa_reach M q bss p'\n  n2' = (replicate (length (fst M)) False)[p' := True]", "have \"p = p'\""], ["proof (prove)\nusing this:\n  dfa_reach M q bss p\n  dfa_reach M q bss p'\n  n2' = (replicate (length (fst M)) False)[p' := True]\n\ngoal (1 subgoal):\n 1. p = p'", "by (simp add: reach_inj)"], ["proof (state)\nthis:\n  p = p'\n\ngoal (1 subgoal):\n 1. dfa_reach M q bss p \\<Longrightarrow> nfa_reach (nfa_of_dfa M) n1 bss n2", "with N2' N2"], ["proof (chain)\npicking this:\n  n2' = (replicate (length (fst M)) False)[p' := True]\n  n2 = (replicate (length (fst M)) False)[p := True]\n  p = p'", "have \"n2 = n2'\""], ["proof (prove)\nusing this:\n  n2' = (replicate (length (fst M)) False)[p' := True]\n  n2 = (replicate (length (fst M)) False)[p := True]\n  p = p'\n\ngoal (1 subgoal):\n 1. n2 = n2'", "by simp"], ["proof (state)\nthis:\n  n2 = n2'\n\ngoal (1 subgoal):\n 1. dfa_reach M q bss p \\<Longrightarrow> nfa_reach (nfa_of_dfa M) n1 bss n2", "with R'"], ["proof (chain)\npicking this:\n  nfa_reach (nfa_of_dfa M) n1 bss n2'\n  n2 = n2'", "show \"nfa_reach (nfa_of_dfa M) n1 bss n2\""], ["proof (prove)\nusing this:\n  nfa_reach (nfa_of_dfa M) n1 bss n2'\n  n2 = n2'\n\ngoal (1 subgoal):\n 1. nfa_reach (nfa_of_dfa M) n1 bss n2", "by simp"], ["proof (state)\nthis:\n  nfa_reach (nfa_of_dfa M) n1 bss n2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nfa_accepting_replicate:\n  assumes \"q < length (fst N)\"\n  and \"length (snd N) = length (fst N)\"\n  shows \"nfa_accepting N ((replicate (length (fst N)) False)[q:=True]) = snd N ! q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfa_accepting N ((replicate (length (fst N)) False)[q := True]) =\n    snd N ! q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nfa_accepting N ((replicate (length (fst N)) False)[q := True]) =\n    snd N ! q", "from assms"], ["proof (chain)\npicking this:\n  q < length (fst N)\n  length (snd N) = length (fst N)", "have \"set_of_bv ((replicate (length (fst N)) False)[q:=True]) = {q}\""], ["proof (prove)\nusing this:\n  q < length (fst N)\n  length (snd N) = length (fst N)\n\ngoal (1 subgoal):\n 1. set_of_bv ((replicate (length (fst N)) False)[q := True]) = {q}", "proof (auto simp: set_of_bv_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>q < length (fst N); length (snd N) = length (fst N);\n        x < length (fst N);\n        (replicate (length (fst N)) False)[q := True] ! x\\<rbrakk>\n       \\<Longrightarrow> x = q", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>q < length (fst N); length (snd N) = length (fst N);\n        x < length (fst N);\n        (replicate (length (fst N)) False)[q := True] ! x\\<rbrakk>\n       \\<Longrightarrow> x = q", "assume \"x < length (fst N)\" and \"(replicate (length (fst N)) False)[q := True] ! x\""], ["proof (state)\nthis:\n  x < length (fst N)\n  (replicate (length (fst N)) False)[q := True] ! x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>q < length (fst N); length (snd N) = length (fst N);\n        x < length (fst N);\n        (replicate (length (fst N)) False)[q := True] ! x\\<rbrakk>\n       \\<Longrightarrow> x = q", "with assms"], ["proof (chain)\npicking this:\n  q < length (fst N)\n  length (snd N) = length (fst N)\n  x < length (fst N)\n  (replicate (length (fst N)) False)[q := True] ! x", "show \"x = q\""], ["proof (prove)\nusing this:\n  q < length (fst N)\n  length (snd N) = length (fst N)\n  x < length (fst N)\n  (replicate (length (fst N)) False)[q := True] ! x\n\ngoal (1 subgoal):\n 1. x = q", "by (cases \"x = q\") simp+"], ["proof (state)\nthis:\n  x = q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set_of_bv ((replicate (length (fst N)) False)[q := True]) = {q}\n\ngoal (1 subgoal):\n 1. nfa_accepting N ((replicate (length (fst N)) False)[q := True]) =\n    snd N ! q", "hence \"nfa_accepting N ((replicate (length (fst N)) False)[q:=True]) = (set_of_bv (snd N) \\<inter> {q} \\<noteq> {})\""], ["proof (prove)\nusing this:\n  set_of_bv ((replicate (length (fst N)) False)[q := True]) = {q}\n\ngoal (1 subgoal):\n 1. nfa_accepting N ((replicate (length (fst N)) False)[q := True]) =\n    (set_of_bv (snd N) \\<inter> {q} \\<noteq> {})", "by (simp add: nfa_accepting_set_of_bv)"], ["proof (state)\nthis:\n  nfa_accepting N ((replicate (length (fst N)) False)[q := True]) =\n  (set_of_bv (snd N) \\<inter> {q} \\<noteq> {})\n\ngoal (1 subgoal):\n 1. nfa_accepting N ((replicate (length (fst N)) False)[q := True]) =\n    snd N ! q", "also"], ["proof (state)\nthis:\n  nfa_accepting N ((replicate (length (fst N)) False)[q := True]) =\n  (set_of_bv (snd N) \\<inter> {q} \\<noteq> {})\n\ngoal (1 subgoal):\n 1. nfa_accepting N ((replicate (length (fst N)) False)[q := True]) =\n    snd N ! q", "have \"\\<dots> = (q \\<in> set_of_bv (snd N))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set_of_bv (snd N) \\<inter> {q} \\<noteq> {}) =\n    (q \\<in> set_of_bv (snd N))", "by auto"], ["proof (state)\nthis:\n  (set_of_bv (snd N) \\<inter> {q} \\<noteq> {}) = (q \\<in> set_of_bv (snd N))\n\ngoal (1 subgoal):\n 1. nfa_accepting N ((replicate (length (fst N)) False)[q := True]) =\n    snd N ! q", "also"], ["proof (state)\nthis:\n  (set_of_bv (snd N) \\<inter> {q} \\<noteq> {}) = (q \\<in> set_of_bv (snd N))\n\ngoal (1 subgoal):\n 1. nfa_accepting N ((replicate (length (fst N)) False)[q := True]) =\n    snd N ! q", "from assms"], ["proof (chain)\npicking this:\n  q < length (fst N)\n  length (snd N) = length (fst N)", "have \"\\<dots> = snd N ! q\""], ["proof (prove)\nusing this:\n  q < length (fst N)\n  length (snd N) = length (fst N)\n\ngoal (1 subgoal):\n 1. (q \\<in> set_of_bv (snd N)) = snd N ! q", "by (auto simp: set_of_bv_def)"], ["proof (state)\nthis:\n  (q \\<in> set_of_bv (snd N)) = snd N ! q\n\ngoal (1 subgoal):\n 1. nfa_accepting N ((replicate (length (fst N)) False)[q := True]) =\n    snd N ! q", "finally"], ["proof (chain)\npicking this:\n  nfa_accepting N ((replicate (length (fst N)) False)[q := True]) =\n  snd N ! q", "show ?thesis"], ["proof (prove)\nusing this:\n  nfa_accepting N ((replicate (length (fst N)) False)[q := True]) =\n  snd N ! q\n\ngoal (1 subgoal):\n 1. nfa_accepting N ((replicate (length (fst N)) False)[q := True]) =\n    snd N ! q", "."], ["proof (state)\nthis:\n  nfa_accepting N ((replicate (length (fst N)) False)[q := True]) =\n  snd N ! q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nfa_of_dfa_accepts:\n  assumes V: \"wf_dfa A n\"\n  and X: \"list_all (is_alph n) bss\"\n  shows \"nfa_accepts (nfa_of_dfa A) bss = dfa_accepts A bss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfa_accepts (nfa_of_dfa A) bss = dfa_accepts A bss", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nfa_accepts (nfa_of_dfa A) bss = dfa_accepts A bss", "from V"], ["proof (chain)\npicking this:\n  wf_dfa A n", "have Q: \"dfa_is_node A 0\""], ["proof (prove)\nusing this:\n  wf_dfa A n\n\ngoal (1 subgoal):\n 1. dfa_is_node A 0", "by (simp add: dfa_startnode_is_node)"], ["proof (state)\nthis:\n  dfa_is_node A 0\n\ngoal (1 subgoal):\n 1. nfa_accepts (nfa_of_dfa A) bss = dfa_accepts A bss", "have S: \"nfa_startnode (nfa_of_dfa A) = (replicate (length (fst A)) False)[0:= True]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfa_startnode (nfa_of_dfa A) = (replicate (length (fst A)) False)\n    [0 := True]", "by (simp add: nfa_startnode_def nfa_of_dfa_def split_beta)"], ["proof (state)\nthis:\n  nfa_startnode (nfa_of_dfa A) = (replicate (length (fst A)) False)\n  [0 := True]\n\ngoal (1 subgoal):\n 1. nfa_accepts (nfa_of_dfa A) bss = dfa_accepts A bss", "define p where \"p = dfa_steps A 0 bss\""], ["proof (state)\nthis:\n  p = dfa_steps A 0 bss\n\ngoal (1 subgoal):\n 1. nfa_accepts (nfa_of_dfa A) bss = dfa_accepts A bss", "define n2 where \"n2 = (replicate (length (fst A)) False)[p := True]\""], ["proof (state)\nthis:\n  n2 = (replicate (length (fst A)) False)[p := True]\n\ngoal (1 subgoal):\n 1. nfa_accepts (nfa_of_dfa A) bss = dfa_accepts A bss", "from p_def"], ["proof (chain)\npicking this:\n  p = dfa_steps A 0 bss", "have PR: \"dfa_reach A 0 bss p\""], ["proof (prove)\nusing this:\n  p = dfa_steps A 0 bss\n\ngoal (1 subgoal):\n 1. dfa_reach A 0 bss p", "by (simp add: reach_def)"], ["proof (state)\nthis:\n  dfa_reach A 0 bss p\n\ngoal (1 subgoal):\n 1. nfa_accepts (nfa_of_dfa A) bss = dfa_accepts A bss", "with p_def n2_def Q S X V"], ["proof (chain)\npicking this:\n  p = dfa_steps A 0 bss\n  n2 = (replicate (length (fst A)) False)[p := True]\n  dfa_is_node A 0\n  nfa_startnode (nfa_of_dfa A) = (replicate (length (fst A)) False)\n  [0 := True]\n  list_all (is_alph n) bss\n  wf_dfa A n\n  dfa_reach A 0 bss p", "have \"nfa_reach (nfa_of_dfa A) (nfa_startnode (nfa_of_dfa A)) bss n2\""], ["proof (prove)\nusing this:\n  p = dfa_steps A 0 bss\n  n2 = (replicate (length (fst A)) False)[p := True]\n  dfa_is_node A 0\n  nfa_startnode (nfa_of_dfa A) = (replicate (length (fst A)) False)\n  [0 := True]\n  list_all (is_alph n) bss\n  wf_dfa A n\n  dfa_reach A 0 bss p\n\ngoal (1 subgoal):\n 1. nfa_reach (nfa_of_dfa A) (nfa_startnode (nfa_of_dfa A)) bss n2", "by (simp add: nfa_of_dfa_reach)"], ["proof (state)\nthis:\n  nfa_reach (nfa_of_dfa A) (nfa_startnode (nfa_of_dfa A)) bss n2\n\ngoal (1 subgoal):\n 1. nfa_accepts (nfa_of_dfa A) bss = dfa_accepts A bss", "hence N2: \"n2 = nfa_steps (nfa_of_dfa A) (nfa_startnode (nfa_of_dfa A)) bss\""], ["proof (prove)\nusing this:\n  nfa_reach (nfa_of_dfa A) (nfa_startnode (nfa_of_dfa A)) bss n2\n\ngoal (1 subgoal):\n 1. n2 = nfa_steps (nfa_of_dfa A) (nfa_startnode (nfa_of_dfa A)) bss", "by (simp add: reach_def)"], ["proof (state)\nthis:\n  n2 = nfa_steps (nfa_of_dfa A) (nfa_startnode (nfa_of_dfa A)) bss\n\ngoal (1 subgoal):\n 1. nfa_accepts (nfa_of_dfa A) bss = dfa_accepts A bss", "from PR Q X V"], ["proof (chain)\npicking this:\n  dfa_reach A 0 bss p\n  dfa_is_node A 0\n  list_all (is_alph n) bss\n  wf_dfa A n", "have \"dfa_is_node A p\""], ["proof (prove)\nusing this:\n  dfa_reach A 0 bss p\n  dfa_is_node A 0\n  list_all (is_alph n) bss\n  wf_dfa A n\n\ngoal (1 subgoal):\n 1. dfa_is_node A p", "by (simp add: dfa_reach_is_node)"], ["proof (state)\nthis:\n  dfa_is_node A p\n\ngoal (1 subgoal):\n 1. nfa_accepts (nfa_of_dfa A) bss = dfa_accepts A bss", "hence \"p < length (fst (nfa_of_dfa A))\""], ["proof (prove)\nusing this:\n  dfa_is_node A p\n\ngoal (1 subgoal):\n 1. p < length (fst (nfa_of_dfa A))", "by (simp add: dfa_is_node_def nfa_of_dfa_def split_beta)"], ["proof (state)\nthis:\n  p < length (fst (nfa_of_dfa A))\n\ngoal (1 subgoal):\n 1. nfa_accepts (nfa_of_dfa A) bss = dfa_accepts A bss", "moreover"], ["proof (state)\nthis:\n  p < length (fst (nfa_of_dfa A))\n\ngoal (1 subgoal):\n 1. nfa_accepts (nfa_of_dfa A) bss = dfa_accepts A bss", "from dfa2wf_nfa[OF V]"], ["proof (chain)\npicking this:\n  wf_nfa (nfa_of_dfa A) n", "have \"length (snd (nfa_of_dfa A)) = length (fst (nfa_of_dfa A))\""], ["proof (prove)\nusing this:\n  wf_nfa (nfa_of_dfa A) n\n\ngoal (1 subgoal):\n 1. length (snd (nfa_of_dfa A)) = length (fst (nfa_of_dfa A))", "by (auto simp add: wf_nfa_def)"], ["proof (state)\nthis:\n  length (snd (nfa_of_dfa A)) = length (fst (nfa_of_dfa A))\n\ngoal (1 subgoal):\n 1. nfa_accepts (nfa_of_dfa A) bss = dfa_accepts A bss", "moreover"], ["proof (state)\nthis:\n  length (snd (nfa_of_dfa A)) = length (fst (nfa_of_dfa A))\n\ngoal (1 subgoal):\n 1. nfa_accepts (nfa_of_dfa A) bss = dfa_accepts A bss", "from n2_def"], ["proof (chain)\npicking this:\n  n2 = (replicate (length (fst A)) False)[p := True]", "have \"n2 = (replicate (length (fst (nfa_of_dfa A))) False)[p := True]\""], ["proof (prove)\nusing this:\n  n2 = (replicate (length (fst A)) False)[p := True]\n\ngoal (1 subgoal):\n 1. n2 = (replicate (length (fst (nfa_of_dfa A))) False)[p := True]", "by (simp add: nfa_of_dfa_def split_beta)"], ["proof (state)\nthis:\n  n2 = (replicate (length (fst (nfa_of_dfa A))) False)[p := True]\n\ngoal (1 subgoal):\n 1. nfa_accepts (nfa_of_dfa A) bss = dfa_accepts A bss", "ultimately"], ["proof (chain)\npicking this:\n  p < length (fst (nfa_of_dfa A))\n  length (snd (nfa_of_dfa A)) = length (fst (nfa_of_dfa A))\n  n2 = (replicate (length (fst (nfa_of_dfa A))) False)[p := True]", "have \"nfa_accepting (nfa_of_dfa A) n2 = snd (nfa_of_dfa A) ! p\""], ["proof (prove)\nusing this:\n  p < length (fst (nfa_of_dfa A))\n  length (snd (nfa_of_dfa A)) = length (fst (nfa_of_dfa A))\n  n2 = (replicate (length (fst (nfa_of_dfa A))) False)[p := True]\n\ngoal (1 subgoal):\n 1. nfa_accepting (nfa_of_dfa A) n2 = snd (nfa_of_dfa A) ! p", "by (simp add: nfa_accepting_replicate)"], ["proof (state)\nthis:\n  nfa_accepting (nfa_of_dfa A) n2 = snd (nfa_of_dfa A) ! p\n\ngoal (1 subgoal):\n 1. nfa_accepts (nfa_of_dfa A) bss = dfa_accepts A bss", "with N2 p_def"], ["proof (chain)\npicking this:\n  n2 = nfa_steps (nfa_of_dfa A) (nfa_startnode (nfa_of_dfa A)) bss\n  p = dfa_steps A 0 bss\n  nfa_accepting (nfa_of_dfa A) n2 = snd (nfa_of_dfa A) ! p", "show ?thesis"], ["proof (prove)\nusing this:\n  n2 = nfa_steps (nfa_of_dfa A) (nfa_startnode (nfa_of_dfa A)) bss\n  p = dfa_steps A 0 bss\n  nfa_accepting (nfa_of_dfa A) n2 = snd (nfa_of_dfa A) ! p\n\ngoal (1 subgoal):\n 1. nfa_accepts (nfa_of_dfa A) bss = dfa_accepts A bss", "by (simp add: accepts_def accepts_def dfa_accepting_def nfa_of_dfa_def split_beta)"], ["proof (state)\nthis:\n  nfa_accepts (nfa_of_dfa A) bss = dfa_accepts A bss\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Transforming NFAs to DFAs\\<close>"], ["", "fun\n  bddinsert :: \"'a bdd \\<Rightarrow> bool list \\<Rightarrow> 'a \\<Rightarrow> 'a bdd\"\nwhere\n  \"bddinsert (Leaf a) [] x = Leaf x\" \n| \"bddinsert (Leaf a) (w#ws) x = (if w then Branch (Leaf a) (bddinsert (Leaf a) ws x) else Branch (bddinsert (Leaf a) ws x) (Leaf a))\"\n| \"bddinsert (Branch l r) (w#ws) x = (if w then Branch l (bddinsert r ws x) else Branch (bddinsert l ws x) r)\""], ["", "lemma bddh_bddinsert:\n  assumes \"bddh x b\"\n  and \"length w \\<ge> x\"\n  shows \"bddh (length w) (bddinsert b w y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bddh (length w) (bddinsert b w y)", "using assms"], ["proof (prove)\nusing this:\n  bddh x b\n  x \\<le> length w\n\ngoal (1 subgoal):\n 1. bddh (length w) (bddinsert b w y)", "proof (induct b w y arbitrary: x rule: bddinsert.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a x xa.\n       \\<lbrakk>bddh xa (Leaf a); xa \\<le> length []\\<rbrakk>\n       \\<Longrightarrow> bddh (length []) (bddinsert (Leaf a) [] x)\n 2. \\<And>a w ws x xa.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>w; bddh xa (Leaf a); xa \\<le> length ws\\<rbrakk>\n                   \\<Longrightarrow> bddh (length ws)\n(bddinsert (Leaf a) ws x);\n        \\<And>xa.\n           \\<lbrakk>\\<not> w; bddh xa (Leaf a); xa \\<le> length ws\\<rbrakk>\n           \\<Longrightarrow> bddh (length ws) (bddinsert (Leaf a) ws x);\n        bddh xa (Leaf a); xa \\<le> length (w # ws)\\<rbrakk>\n       \\<Longrightarrow> bddh (length (w # ws))\n                          (bddinsert (Leaf a) (w # ws) x)\n 3. \\<And>l r w ws x xa.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>w; bddh xa r; xa \\<le> length ws\\<rbrakk>\n                   \\<Longrightarrow> bddh (length ws) (bddinsert r ws x);\n        \\<And>xa.\n           \\<lbrakk>\\<not> w; bddh xa l; xa \\<le> length ws\\<rbrakk>\n           \\<Longrightarrow> bddh (length ws) (bddinsert l ws x);\n        bddh xa (Branch l r); xa \\<le> length (w # ws)\\<rbrakk>\n       \\<Longrightarrow> bddh (length (w # ws))\n                          (bddinsert (Branch l r) (w # ws) x)\n 4. \\<And>v va c x.\n       \\<lbrakk>bddh x (Branch v va); x \\<le> length []\\<rbrakk>\n       \\<Longrightarrow> bddh (length []) (bddinsert (Branch v va) [] c)", "case (2 aa ww wss yy xaa)"], ["proof (state)\nthis:\n  \\<lbrakk>ww; bddh ?x (Leaf aa); ?x \\<le> length wss\\<rbrakk>\n  \\<Longrightarrow> bddh (length wss) (bddinsert (Leaf aa) wss yy)\n  \\<lbrakk>\\<not> ww; bddh ?x (Leaf aa); ?x \\<le> length wss\\<rbrakk>\n  \\<Longrightarrow> bddh (length wss) (bddinsert (Leaf aa) wss yy)\n  bddh xaa (Leaf aa)\n  xaa \\<le> length (ww # wss)\n\ngoal (4 subgoals):\n 1. \\<And>a x xa.\n       \\<lbrakk>bddh xa (Leaf a); xa \\<le> length []\\<rbrakk>\n       \\<Longrightarrow> bddh (length []) (bddinsert (Leaf a) [] x)\n 2. \\<And>a w ws x xa.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>w; bddh xa (Leaf a); xa \\<le> length ws\\<rbrakk>\n                   \\<Longrightarrow> bddh (length ws)\n(bddinsert (Leaf a) ws x);\n        \\<And>xa.\n           \\<lbrakk>\\<not> w; bddh xa (Leaf a); xa \\<le> length ws\\<rbrakk>\n           \\<Longrightarrow> bddh (length ws) (bddinsert (Leaf a) ws x);\n        bddh xa (Leaf a); xa \\<le> length (w # ws)\\<rbrakk>\n       \\<Longrightarrow> bddh (length (w # ws))\n                          (bddinsert (Leaf a) (w # ws) x)\n 3. \\<And>l r w ws x xa.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>w; bddh xa r; xa \\<le> length ws\\<rbrakk>\n                   \\<Longrightarrow> bddh (length ws) (bddinsert r ws x);\n        \\<And>xa.\n           \\<lbrakk>\\<not> w; bddh xa l; xa \\<le> length ws\\<rbrakk>\n           \\<Longrightarrow> bddh (length ws) (bddinsert l ws x);\n        bddh xa (Branch l r); xa \\<le> length (w # ws)\\<rbrakk>\n       \\<Longrightarrow> bddh (length (w # ws))\n                          (bddinsert (Branch l r) (w # ws) x)\n 4. \\<And>v va c x.\n       \\<lbrakk>bddh x (Branch v va); x \\<le> length []\\<rbrakk>\n       \\<Longrightarrow> bddh (length []) (bddinsert (Branch v va) [] c)", "have \"bddh 0 (Leaf aa) \\<and> 0 \\<le> length wss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bddh 0 (Leaf aa) \\<and> 0 \\<le> length wss", "by simp"], ["proof (state)\nthis:\n  bddh 0 (Leaf aa) \\<and> 0 \\<le> length wss\n\ngoal (4 subgoals):\n 1. \\<And>a x xa.\n       \\<lbrakk>bddh xa (Leaf a); xa \\<le> length []\\<rbrakk>\n       \\<Longrightarrow> bddh (length []) (bddinsert (Leaf a) [] x)\n 2. \\<And>a w ws x xa.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>w; bddh xa (Leaf a); xa \\<le> length ws\\<rbrakk>\n                   \\<Longrightarrow> bddh (length ws)\n(bddinsert (Leaf a) ws x);\n        \\<And>xa.\n           \\<lbrakk>\\<not> w; bddh xa (Leaf a); xa \\<le> length ws\\<rbrakk>\n           \\<Longrightarrow> bddh (length ws) (bddinsert (Leaf a) ws x);\n        bddh xa (Leaf a); xa \\<le> length (w # ws)\\<rbrakk>\n       \\<Longrightarrow> bddh (length (w # ws))\n                          (bddinsert (Leaf a) (w # ws) x)\n 3. \\<And>l r w ws x xa.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>w; bddh xa r; xa \\<le> length ws\\<rbrakk>\n                   \\<Longrightarrow> bddh (length ws) (bddinsert r ws x);\n        \\<And>xa.\n           \\<lbrakk>\\<not> w; bddh xa l; xa \\<le> length ws\\<rbrakk>\n           \\<Longrightarrow> bddh (length ws) (bddinsert l ws x);\n        bddh xa (Branch l r); xa \\<le> length (w # ws)\\<rbrakk>\n       \\<Longrightarrow> bddh (length (w # ws))\n                          (bddinsert (Branch l r) (w # ws) x)\n 4. \\<And>v va c x.\n       \\<lbrakk>bddh x (Branch v va); x \\<le> length []\\<rbrakk>\n       \\<Longrightarrow> bddh (length []) (bddinsert (Branch v va) [] c)", "with 2(1) 2(2)"], ["proof (chain)\npicking this:\n  \\<lbrakk>ww; bddh ?x (Leaf aa); ?x \\<le> length wss\\<rbrakk>\n  \\<Longrightarrow> bddh (length wss) (bddinsert (Leaf aa) wss yy)\n  \\<lbrakk>\\<not> ww; bddh ?x (Leaf aa); ?x \\<le> length wss\\<rbrakk>\n  \\<Longrightarrow> bddh (length wss) (bddinsert (Leaf aa) wss yy)\n  bddh 0 (Leaf aa) \\<and> 0 \\<le> length wss", "have \"bddh (length wss) (bddinsert (Leaf aa) wss yy)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>ww; bddh ?x (Leaf aa); ?x \\<le> length wss\\<rbrakk>\n  \\<Longrightarrow> bddh (length wss) (bddinsert (Leaf aa) wss yy)\n  \\<lbrakk>\\<not> ww; bddh ?x (Leaf aa); ?x \\<le> length wss\\<rbrakk>\n  \\<Longrightarrow> bddh (length wss) (bddinsert (Leaf aa) wss yy)\n  bddh 0 (Leaf aa) \\<and> 0 \\<le> length wss\n\ngoal (1 subgoal):\n 1. bddh (length wss) (bddinsert (Leaf aa) wss yy)", "by (cases ww) blast+"], ["proof (state)\nthis:\n  bddh (length wss) (bddinsert (Leaf aa) wss yy)\n\ngoal (4 subgoals):\n 1. \\<And>a x xa.\n       \\<lbrakk>bddh xa (Leaf a); xa \\<le> length []\\<rbrakk>\n       \\<Longrightarrow> bddh (length []) (bddinsert (Leaf a) [] x)\n 2. \\<And>a w ws x xa.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>w; bddh xa (Leaf a); xa \\<le> length ws\\<rbrakk>\n                   \\<Longrightarrow> bddh (length ws)\n(bddinsert (Leaf a) ws x);\n        \\<And>xa.\n           \\<lbrakk>\\<not> w; bddh xa (Leaf a); xa \\<le> length ws\\<rbrakk>\n           \\<Longrightarrow> bddh (length ws) (bddinsert (Leaf a) ws x);\n        bddh xa (Leaf a); xa \\<le> length (w # ws)\\<rbrakk>\n       \\<Longrightarrow> bddh (length (w # ws))\n                          (bddinsert (Leaf a) (w # ws) x)\n 3. \\<And>l r w ws x xa.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>w; bddh xa r; xa \\<le> length ws\\<rbrakk>\n                   \\<Longrightarrow> bddh (length ws) (bddinsert r ws x);\n        \\<And>xa.\n           \\<lbrakk>\\<not> w; bddh xa l; xa \\<le> length ws\\<rbrakk>\n           \\<Longrightarrow> bddh (length ws) (bddinsert l ws x);\n        bddh xa (Branch l r); xa \\<le> length (w # ws)\\<rbrakk>\n       \\<Longrightarrow> bddh (length (w # ws))\n                          (bddinsert (Branch l r) (w # ws) x)\n 4. \\<And>v va c x.\n       \\<lbrakk>bddh x (Branch v va); x \\<le> length []\\<rbrakk>\n       \\<Longrightarrow> bddh (length []) (bddinsert (Branch v va) [] c)", "with 2"], ["proof (chain)\npicking this:\n  \\<lbrakk>ww; bddh ?x (Leaf aa); ?x \\<le> length wss\\<rbrakk>\n  \\<Longrightarrow> bddh (length wss) (bddinsert (Leaf aa) wss yy)\n  \\<lbrakk>\\<not> ww; bddh ?x (Leaf aa); ?x \\<le> length wss\\<rbrakk>\n  \\<Longrightarrow> bddh (length wss) (bddinsert (Leaf aa) wss yy)\n  bddh xaa (Leaf aa)\n  xaa \\<le> length (ww # wss)\n  bddh (length wss) (bddinsert (Leaf aa) wss yy)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>ww; bddh ?x (Leaf aa); ?x \\<le> length wss\\<rbrakk>\n  \\<Longrightarrow> bddh (length wss) (bddinsert (Leaf aa) wss yy)\n  \\<lbrakk>\\<not> ww; bddh ?x (Leaf aa); ?x \\<le> length wss\\<rbrakk>\n  \\<Longrightarrow> bddh (length wss) (bddinsert (Leaf aa) wss yy)\n  bddh xaa (Leaf aa)\n  xaa \\<le> length (ww # wss)\n  bddh (length wss) (bddinsert (Leaf aa) wss yy)\n\ngoal (1 subgoal):\n 1. bddh (length (ww # wss)) (bddinsert (Leaf aa) (ww # wss) yy)", "by simp"], ["proof (state)\nthis:\n  bddh (length (ww # wss)) (bddinsert (Leaf aa) (ww # wss) yy)\n\ngoal (3 subgoals):\n 1. \\<And>a x xa.\n       \\<lbrakk>bddh xa (Leaf a); xa \\<le> length []\\<rbrakk>\n       \\<Longrightarrow> bddh (length []) (bddinsert (Leaf a) [] x)\n 2. \\<And>l r w ws x xa.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>w; bddh xa r; xa \\<le> length ws\\<rbrakk>\n                   \\<Longrightarrow> bddh (length ws) (bddinsert r ws x);\n        \\<And>xa.\n           \\<lbrakk>\\<not> w; bddh xa l; xa \\<le> length ws\\<rbrakk>\n           \\<Longrightarrow> bddh (length ws) (bddinsert l ws x);\n        bddh xa (Branch l r); xa \\<le> length (w # ws)\\<rbrakk>\n       \\<Longrightarrow> bddh (length (w # ws))\n                          (bddinsert (Branch l r) (w # ws) x)\n 3. \\<And>v va c x.\n       \\<lbrakk>bddh x (Branch v va); x \\<le> length []\\<rbrakk>\n       \\<Longrightarrow> bddh (length []) (bddinsert (Branch v va) [] c)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a x xa.\n       \\<lbrakk>bddh xa (Leaf a); xa \\<le> length []\\<rbrakk>\n       \\<Longrightarrow> bddh (length []) (bddinsert (Leaf a) [] x)\n 2. \\<And>l r w ws x xa.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>w; bddh xa r; xa \\<le> length ws\\<rbrakk>\n                   \\<Longrightarrow> bddh (length ws) (bddinsert r ws x);\n        \\<And>xa.\n           \\<lbrakk>\\<not> w; bddh xa l; xa \\<le> length ws\\<rbrakk>\n           \\<Longrightarrow> bddh (length ws) (bddinsert l ws x);\n        bddh xa (Branch l r); xa \\<le> length (w # ws)\\<rbrakk>\n       \\<Longrightarrow> bddh (length (w # ws))\n                          (bddinsert (Branch l r) (w # ws) x)\n 3. \\<And>v va c x.\n       \\<lbrakk>bddh x (Branch v va); x \\<le> length []\\<rbrakk>\n       \\<Longrightarrow> bddh (length []) (bddinsert (Branch v va) [] c)", "case (3 ll rr ww wss yy xx)"], ["proof (state)\nthis:\n  \\<lbrakk>ww; bddh ?x rr; ?x \\<le> length wss\\<rbrakk>\n  \\<Longrightarrow> bddh (length wss) (bddinsert rr wss yy)\n  \\<lbrakk>\\<not> ww; bddh ?x ll; ?x \\<le> length wss\\<rbrakk>\n  \\<Longrightarrow> bddh (length wss) (bddinsert ll wss yy)\n  bddh xx (Branch ll rr)\n  xx \\<le> length (ww # wss)\n\ngoal (3 subgoals):\n 1. \\<And>a x xa.\n       \\<lbrakk>bddh xa (Leaf a); xa \\<le> length []\\<rbrakk>\n       \\<Longrightarrow> bddh (length []) (bddinsert (Leaf a) [] x)\n 2. \\<And>l r w ws x xa.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>w; bddh xa r; xa \\<le> length ws\\<rbrakk>\n                   \\<Longrightarrow> bddh (length ws) (bddinsert r ws x);\n        \\<And>xa.\n           \\<lbrakk>\\<not> w; bddh xa l; xa \\<le> length ws\\<rbrakk>\n           \\<Longrightarrow> bddh (length ws) (bddinsert l ws x);\n        bddh xa (Branch l r); xa \\<le> length (w # ws)\\<rbrakk>\n       \\<Longrightarrow> bddh (length (w # ws))\n                          (bddinsert (Branch l r) (w # ws) x)\n 3. \\<And>v va c x.\n       \\<lbrakk>bddh x (Branch v va); x \\<le> length []\\<rbrakk>\n       \\<Longrightarrow> bddh (length []) (bddinsert (Branch v va) [] c)", "from 3(3)"], ["proof (chain)\npicking this:\n  bddh xx (Branch ll rr)", "obtain y where Y: \"Suc y = xx\""], ["proof (prove)\nusing this:\n  bddh xx (Branch ll rr)\n\ngoal (1 subgoal):\n 1. (\\<And>y. Suc y = xx \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases xx) simp+"], ["proof (state)\nthis:\n  Suc y = xx\n\ngoal (3 subgoals):\n 1. \\<And>a x xa.\n       \\<lbrakk>bddh xa (Leaf a); xa \\<le> length []\\<rbrakk>\n       \\<Longrightarrow> bddh (length []) (bddinsert (Leaf a) [] x)\n 2. \\<And>l r w ws x xa.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>w; bddh xa r; xa \\<le> length ws\\<rbrakk>\n                   \\<Longrightarrow> bddh (length ws) (bddinsert r ws x);\n        \\<And>xa.\n           \\<lbrakk>\\<not> w; bddh xa l; xa \\<le> length ws\\<rbrakk>\n           \\<Longrightarrow> bddh (length ws) (bddinsert l ws x);\n        bddh xa (Branch l r); xa \\<le> length (w # ws)\\<rbrakk>\n       \\<Longrightarrow> bddh (length (w # ws))\n                          (bddinsert (Branch l r) (w # ws) x)\n 3. \\<And>v va c x.\n       \\<lbrakk>bddh x (Branch v va); x \\<le> length []\\<rbrakk>\n       \\<Longrightarrow> bddh (length []) (bddinsert (Branch v va) [] c)", "with 3"], ["proof (chain)\npicking this:\n  \\<lbrakk>ww; bddh ?x rr; ?x \\<le> length wss\\<rbrakk>\n  \\<Longrightarrow> bddh (length wss) (bddinsert rr wss yy)\n  \\<lbrakk>\\<not> ww; bddh ?x ll; ?x \\<le> length wss\\<rbrakk>\n  \\<Longrightarrow> bddh (length wss) (bddinsert ll wss yy)\n  bddh xx (Branch ll rr)\n  xx \\<le> length (ww # wss)\n  Suc y = xx", "have 1: \"bddh y rr \\<and> bddh y ll \\<and> y \\<le> length wss\""], ["proof (prove)\nusing this:\n  \\<lbrakk>ww; bddh ?x rr; ?x \\<le> length wss\\<rbrakk>\n  \\<Longrightarrow> bddh (length wss) (bddinsert rr wss yy)\n  \\<lbrakk>\\<not> ww; bddh ?x ll; ?x \\<le> length wss\\<rbrakk>\n  \\<Longrightarrow> bddh (length wss) (bddinsert ll wss yy)\n  bddh xx (Branch ll rr)\n  xx \\<le> length (ww # wss)\n  Suc y = xx\n\ngoal (1 subgoal):\n 1. bddh y rr \\<and> bddh y ll \\<and> y \\<le> length wss", "by auto"], ["proof (state)\nthis:\n  bddh y rr \\<and> bddh y ll \\<and> y \\<le> length wss\n\ngoal (3 subgoals):\n 1. \\<And>a x xa.\n       \\<lbrakk>bddh xa (Leaf a); xa \\<le> length []\\<rbrakk>\n       \\<Longrightarrow> bddh (length []) (bddinsert (Leaf a) [] x)\n 2. \\<And>l r w ws x xa.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>w; bddh xa r; xa \\<le> length ws\\<rbrakk>\n                   \\<Longrightarrow> bddh (length ws) (bddinsert r ws x);\n        \\<And>xa.\n           \\<lbrakk>\\<not> w; bddh xa l; xa \\<le> length ws\\<rbrakk>\n           \\<Longrightarrow> bddh (length ws) (bddinsert l ws x);\n        bddh xa (Branch l r); xa \\<le> length (w # ws)\\<rbrakk>\n       \\<Longrightarrow> bddh (length (w # ws))\n                          (bddinsert (Branch l r) (w # ws) x)\n 3. \\<And>v va c x.\n       \\<lbrakk>bddh x (Branch v va); x \\<le> length []\\<rbrakk>\n       \\<Longrightarrow> bddh (length []) (bddinsert (Branch v va) [] c)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. bddh (length (ww # wss)) (bddinsert (Branch ll rr) (ww # wss) yy)", "proof (cases ww)"], ["proof (state)\ngoal (2 subgoals):\n 1. ww \\<Longrightarrow>\n    bddh (length (ww # wss)) (bddinsert (Branch ll rr) (ww # wss) yy)\n 2. \\<not> ww \\<Longrightarrow>\n    bddh (length (ww # wss)) (bddinsert (Branch ll rr) (ww # wss) yy)", "case True"], ["proof (state)\nthis:\n  ww\n\ngoal (2 subgoals):\n 1. ww \\<Longrightarrow>\n    bddh (length (ww # wss)) (bddinsert (Branch ll rr) (ww # wss) yy)\n 2. \\<not> ww \\<Longrightarrow>\n    bddh (length (ww # wss)) (bddinsert (Branch ll rr) (ww # wss) yy)", "with 1 3(1)"], ["proof (chain)\npicking this:\n  bddh y rr \\<and> bddh y ll \\<and> y \\<le> length wss\n  \\<lbrakk>ww; bddh ?x rr; ?x \\<le> length wss\\<rbrakk>\n  \\<Longrightarrow> bddh (length wss) (bddinsert rr wss yy)\n  ww", "have IV: \"bddh (length wss) (bddinsert rr wss yy)\""], ["proof (prove)\nusing this:\n  bddh y rr \\<and> bddh y ll \\<and> y \\<le> length wss\n  \\<lbrakk>ww; bddh ?x rr; ?x \\<le> length wss\\<rbrakk>\n  \\<Longrightarrow> bddh (length wss) (bddinsert rr wss yy)\n  ww\n\ngoal (1 subgoal):\n 1. bddh (length wss) (bddinsert rr wss yy)", "by blast"], ["proof (state)\nthis:\n  bddh (length wss) (bddinsert rr wss yy)\n\ngoal (2 subgoals):\n 1. ww \\<Longrightarrow>\n    bddh (length (ww # wss)) (bddinsert (Branch ll rr) (ww # wss) yy)\n 2. \\<not> ww \\<Longrightarrow>\n    bddh (length (ww # wss)) (bddinsert (Branch ll rr) (ww # wss) yy)", "with Y 3"], ["proof (chain)\npicking this:\n  Suc y = xx\n  \\<lbrakk>ww; bddh ?x rr; ?x \\<le> length wss\\<rbrakk>\n  \\<Longrightarrow> bddh (length wss) (bddinsert rr wss yy)\n  \\<lbrakk>\\<not> ww; bddh ?x ll; ?x \\<le> length wss\\<rbrakk>\n  \\<Longrightarrow> bddh (length wss) (bddinsert ll wss yy)\n  bddh xx (Branch ll rr)\n  xx \\<le> length (ww # wss)\n  bddh (length wss) (bddinsert rr wss yy)", "have \"y \\<le> length wss\" and \"bddh y ll\""], ["proof (prove)\nusing this:\n  Suc y = xx\n  \\<lbrakk>ww; bddh ?x rr; ?x \\<le> length wss\\<rbrakk>\n  \\<Longrightarrow> bddh (length wss) (bddinsert rr wss yy)\n  \\<lbrakk>\\<not> ww; bddh ?x ll; ?x \\<le> length wss\\<rbrakk>\n  \\<Longrightarrow> bddh (length wss) (bddinsert ll wss yy)\n  bddh xx (Branch ll rr)\n  xx \\<le> length (ww # wss)\n  bddh (length wss) (bddinsert rr wss yy)\n\ngoal (1 subgoal):\n 1. y \\<le> length wss &&& bddh y ll", "by auto"], ["proof (state)\nthis:\n  y \\<le> length wss\n  bddh y ll\n\ngoal (2 subgoals):\n 1. ww \\<Longrightarrow>\n    bddh (length (ww # wss)) (bddinsert (Branch ll rr) (ww # wss) yy)\n 2. \\<not> ww \\<Longrightarrow>\n    bddh (length (ww # wss)) (bddinsert (Branch ll rr) (ww # wss) yy)", "hence \"bddh (length wss) ll\""], ["proof (prove)\nusing this:\n  y \\<le> length wss\n  bddh y ll\n\ngoal (1 subgoal):\n 1. bddh (length wss) ll", "by (rule bddh_ge)"], ["proof (state)\nthis:\n  bddh (length wss) ll\n\ngoal (2 subgoals):\n 1. ww \\<Longrightarrow>\n    bddh (length (ww # wss)) (bddinsert (Branch ll rr) (ww # wss) yy)\n 2. \\<not> ww \\<Longrightarrow>\n    bddh (length (ww # wss)) (bddinsert (Branch ll rr) (ww # wss) yy)", "with IV True"], ["proof (chain)\npicking this:\n  bddh (length wss) (bddinsert rr wss yy)\n  ww\n  bddh (length wss) ll", "show ?thesis"], ["proof (prove)\nusing this:\n  bddh (length wss) (bddinsert rr wss yy)\n  ww\n  bddh (length wss) ll\n\ngoal (1 subgoal):\n 1. bddh (length (ww # wss)) (bddinsert (Branch ll rr) (ww # wss) yy)", "by simp"], ["proof (state)\nthis:\n  bddh (length (ww # wss)) (bddinsert (Branch ll rr) (ww # wss) yy)\n\ngoal (1 subgoal):\n 1. \\<not> ww \\<Longrightarrow>\n    bddh (length (ww # wss)) (bddinsert (Branch ll rr) (ww # wss) yy)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ww \\<Longrightarrow>\n    bddh (length (ww # wss)) (bddinsert (Branch ll rr) (ww # wss) yy)", "case False"], ["proof (state)\nthis:\n  \\<not> ww\n\ngoal (1 subgoal):\n 1. \\<not> ww \\<Longrightarrow>\n    bddh (length (ww # wss)) (bddinsert (Branch ll rr) (ww # wss) yy)", "with 1 3(2)"], ["proof (chain)\npicking this:\n  bddh y rr \\<and> bddh y ll \\<and> y \\<le> length wss\n  \\<lbrakk>\\<not> ww; bddh ?x ll; ?x \\<le> length wss\\<rbrakk>\n  \\<Longrightarrow> bddh (length wss) (bddinsert ll wss yy)\n  \\<not> ww", "have IV: \"bddh (length wss) (bddinsert ll wss yy)\""], ["proof (prove)\nusing this:\n  bddh y rr \\<and> bddh y ll \\<and> y \\<le> length wss\n  \\<lbrakk>\\<not> ww; bddh ?x ll; ?x \\<le> length wss\\<rbrakk>\n  \\<Longrightarrow> bddh (length wss) (bddinsert ll wss yy)\n  \\<not> ww\n\ngoal (1 subgoal):\n 1. bddh (length wss) (bddinsert ll wss yy)", "by blast"], ["proof (state)\nthis:\n  bddh (length wss) (bddinsert ll wss yy)\n\ngoal (1 subgoal):\n 1. \\<not> ww \\<Longrightarrow>\n    bddh (length (ww # wss)) (bddinsert (Branch ll rr) (ww # wss) yy)", "with Y 3"], ["proof (chain)\npicking this:\n  Suc y = xx\n  \\<lbrakk>ww; bddh ?x rr; ?x \\<le> length wss\\<rbrakk>\n  \\<Longrightarrow> bddh (length wss) (bddinsert rr wss yy)\n  \\<lbrakk>\\<not> ww; bddh ?x ll; ?x \\<le> length wss\\<rbrakk>\n  \\<Longrightarrow> bddh (length wss) (bddinsert ll wss yy)\n  bddh xx (Branch ll rr)\n  xx \\<le> length (ww # wss)\n  bddh (length wss) (bddinsert ll wss yy)", "have \"y \\<le> length wss\" and \"bddh y rr\""], ["proof (prove)\nusing this:\n  Suc y = xx\n  \\<lbrakk>ww; bddh ?x rr; ?x \\<le> length wss\\<rbrakk>\n  \\<Longrightarrow> bddh (length wss) (bddinsert rr wss yy)\n  \\<lbrakk>\\<not> ww; bddh ?x ll; ?x \\<le> length wss\\<rbrakk>\n  \\<Longrightarrow> bddh (length wss) (bddinsert ll wss yy)\n  bddh xx (Branch ll rr)\n  xx \\<le> length (ww # wss)\n  bddh (length wss) (bddinsert ll wss yy)\n\ngoal (1 subgoal):\n 1. y \\<le> length wss &&& bddh y rr", "by auto"], ["proof (state)\nthis:\n  y \\<le> length wss\n  bddh y rr\n\ngoal (1 subgoal):\n 1. \\<not> ww \\<Longrightarrow>\n    bddh (length (ww # wss)) (bddinsert (Branch ll rr) (ww # wss) yy)", "hence \"bddh (length wss) rr\""], ["proof (prove)\nusing this:\n  y \\<le> length wss\n  bddh y rr\n\ngoal (1 subgoal):\n 1. bddh (length wss) rr", "by (rule bddh_ge)"], ["proof (state)\nthis:\n  bddh (length wss) rr\n\ngoal (1 subgoal):\n 1. \\<not> ww \\<Longrightarrow>\n    bddh (length (ww # wss)) (bddinsert (Branch ll rr) (ww # wss) yy)", "with IV False"], ["proof (chain)\npicking this:\n  bddh (length wss) (bddinsert ll wss yy)\n  \\<not> ww\n  bddh (length wss) rr", "show ?thesis"], ["proof (prove)\nusing this:\n  bddh (length wss) (bddinsert ll wss yy)\n  \\<not> ww\n  bddh (length wss) rr\n\ngoal (1 subgoal):\n 1. bddh (length (ww # wss)) (bddinsert (Branch ll rr) (ww # wss) yy)", "by simp"], ["proof (state)\nthis:\n  bddh (length (ww # wss)) (bddinsert (Branch ll rr) (ww # wss) yy)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bddh (length (ww # wss)) (bddinsert (Branch ll rr) (ww # wss) yy)\n\ngoal (2 subgoals):\n 1. \\<And>a x xa.\n       \\<lbrakk>bddh xa (Leaf a); xa \\<le> length []\\<rbrakk>\n       \\<Longrightarrow> bddh (length []) (bddinsert (Leaf a) [] x)\n 2. \\<And>v va c x.\n       \\<lbrakk>bddh x (Branch v va); x \\<le> length []\\<rbrakk>\n       \\<Longrightarrow> bddh (length []) (bddinsert (Branch v va) [] c)", "qed simp+"], ["", "lemma bdd_lookup_bddinsert:\n  assumes \"bddh (length w) bd\"\n  and \"length w = length v\"\n  shows \"bdd_lookup (bddinsert bd w y) v = (if w = v then y else bdd_lookup bd v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_lookup (bddinsert bd w y) v = (if w = v then y else bdd_lookup bd v)", "using assms"], ["proof (prove)\nusing this:\n  bddh (length w) bd\n  length w = length v\n\ngoal (1 subgoal):\n 1. bdd_lookup (bddinsert bd w y) v = (if w = v then y else bdd_lookup bd v)", "proof (induct bd w y arbitrary: v rule: bddinsert.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a x v.\n       \\<lbrakk>bddh (length []) (Leaf a); length [] = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) [] x) v =\n                         (if [] = v then x else bdd_lookup (Leaf a) v)\n 2. \\<And>a w ws x v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>w; bddh (length ws) (Leaf a);\n                    length ws = length v\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) ws x)\nv =\n                                     (if ws = v then x\nelse bdd_lookup (Leaf a) v);\n        \\<And>v.\n           \\<lbrakk>\\<not> w; bddh (length ws) (Leaf a);\n            length ws = length v\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) ws x) v =\n                             (if ws = v then x else bdd_lookup (Leaf a) v);\n        bddh (length (w # ws)) (Leaf a); length (w # ws) = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) (w # ws) x) v =\n                         (if w # ws = v then x else bdd_lookup (Leaf a) v)\n 3. \\<And>l r w ws x v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>w; bddh (length ws) r;\n                    length ws = length v\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (bddinsert r ws x) v =\n                                     (if ws = v then x else bdd_lookup r v);\n        \\<And>v.\n           \\<lbrakk>\\<not> w; bddh (length ws) l;\n            length ws = length v\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bddinsert l ws x) v =\n                             (if ws = v then x else bdd_lookup l v);\n        bddh (length (w # ws)) (Branch l r);\n        length (w # ws) = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Branch l r) (w # ws) x) v =\n                         (if w # ws = v then x\n                          else bdd_lookup (Branch l r) v)\n 4. \\<And>v va c vb.\n       \\<lbrakk>bddh (length []) (Branch v va);\n        length [] = length vb\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Branch v va) [] c) vb =\n                         (if [] = vb then c\n                          else bdd_lookup (Branch v va) vb)", "case (2 aa ww wss xx vv)"], ["proof (state)\nthis:\n  \\<lbrakk>ww; bddh (length wss) (Leaf aa); length wss = length ?v\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (bddinsert (Leaf aa) wss xx) ?v =\n                    (if wss = ?v then xx else bdd_lookup (Leaf aa) ?v)\n  \\<lbrakk>\\<not> ww; bddh (length wss) (Leaf aa);\n   length wss = length ?v\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (bddinsert (Leaf aa) wss xx) ?v =\n                    (if wss = ?v then xx else bdd_lookup (Leaf aa) ?v)\n  bddh (length (ww # wss)) (Leaf aa)\n  length (ww # wss) = length vv\n\ngoal (4 subgoals):\n 1. \\<And>a x v.\n       \\<lbrakk>bddh (length []) (Leaf a); length [] = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) [] x) v =\n                         (if [] = v then x else bdd_lookup (Leaf a) v)\n 2. \\<And>a w ws x v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>w; bddh (length ws) (Leaf a);\n                    length ws = length v\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) ws x)\nv =\n                                     (if ws = v then x\nelse bdd_lookup (Leaf a) v);\n        \\<And>v.\n           \\<lbrakk>\\<not> w; bddh (length ws) (Leaf a);\n            length ws = length v\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) ws x) v =\n                             (if ws = v then x else bdd_lookup (Leaf a) v);\n        bddh (length (w # ws)) (Leaf a); length (w # ws) = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) (w # ws) x) v =\n                         (if w # ws = v then x else bdd_lookup (Leaf a) v)\n 3. \\<And>l r w ws x v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>w; bddh (length ws) r;\n                    length ws = length v\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (bddinsert r ws x) v =\n                                     (if ws = v then x else bdd_lookup r v);\n        \\<And>v.\n           \\<lbrakk>\\<not> w; bddh (length ws) l;\n            length ws = length v\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bddinsert l ws x) v =\n                             (if ws = v then x else bdd_lookup l v);\n        bddh (length (w # ws)) (Branch l r);\n        length (w # ws) = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Branch l r) (w # ws) x) v =\n                         (if w # ws = v then x\n                          else bdd_lookup (Branch l r) v)\n 4. \\<And>v va c vb.\n       \\<lbrakk>bddh (length []) (Branch v va);\n        length [] = length vb\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Branch v va) [] c) vb =\n                         (if [] = vb then c\n                          else bdd_lookup (Branch v va) vb)", "hence \"\\<exists>v vs. vv = v # vs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>ww; bddh (length wss) (Leaf aa); length wss = length ?v\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (bddinsert (Leaf aa) wss xx) ?v =\n                    (if wss = ?v then xx else bdd_lookup (Leaf aa) ?v)\n  \\<lbrakk>\\<not> ww; bddh (length wss) (Leaf aa);\n   length wss = length ?v\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (bddinsert (Leaf aa) wss xx) ?v =\n                    (if wss = ?v then xx else bdd_lookup (Leaf aa) ?v)\n  bddh (length (ww # wss)) (Leaf aa)\n  length (ww # wss) = length vv\n\ngoal (1 subgoal):\n 1. \\<exists>v vs. vv = v # vs", "by (cases vv) simp+"], ["proof (state)\nthis:\n  \\<exists>v vs. vv = v # vs\n\ngoal (4 subgoals):\n 1. \\<And>a x v.\n       \\<lbrakk>bddh (length []) (Leaf a); length [] = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) [] x) v =\n                         (if [] = v then x else bdd_lookup (Leaf a) v)\n 2. \\<And>a w ws x v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>w; bddh (length ws) (Leaf a);\n                    length ws = length v\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) ws x)\nv =\n                                     (if ws = v then x\nelse bdd_lookup (Leaf a) v);\n        \\<And>v.\n           \\<lbrakk>\\<not> w; bddh (length ws) (Leaf a);\n            length ws = length v\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) ws x) v =\n                             (if ws = v then x else bdd_lookup (Leaf a) v);\n        bddh (length (w # ws)) (Leaf a); length (w # ws) = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) (w # ws) x) v =\n                         (if w # ws = v then x else bdd_lookup (Leaf a) v)\n 3. \\<And>l r w ws x v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>w; bddh (length ws) r;\n                    length ws = length v\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (bddinsert r ws x) v =\n                                     (if ws = v then x else bdd_lookup r v);\n        \\<And>v.\n           \\<lbrakk>\\<not> w; bddh (length ws) l;\n            length ws = length v\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bddinsert l ws x) v =\n                             (if ws = v then x else bdd_lookup l v);\n        bddh (length (w # ws)) (Branch l r);\n        length (w # ws) = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Branch l r) (w # ws) x) v =\n                         (if w # ws = v then x\n                          else bdd_lookup (Branch l r) v)\n 4. \\<And>v va c vb.\n       \\<lbrakk>bddh (length []) (Branch v va);\n        length [] = length vb\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Branch v va) [] c) vb =\n                         (if [] = vb then c\n                          else bdd_lookup (Branch v va) vb)", "then"], ["proof (chain)\npicking this:\n  \\<exists>v vs. vv = v # vs", "obtain v vs where V: \"vv = v # vs\""], ["proof (prove)\nusing this:\n  \\<exists>v vs. vv = v # vs\n\ngoal (1 subgoal):\n 1. (\\<And>v vs. vv = v # vs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  vv = v # vs\n\ngoal (4 subgoals):\n 1. \\<And>a x v.\n       \\<lbrakk>bddh (length []) (Leaf a); length [] = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) [] x) v =\n                         (if [] = v then x else bdd_lookup (Leaf a) v)\n 2. \\<And>a w ws x v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>w; bddh (length ws) (Leaf a);\n                    length ws = length v\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) ws x)\nv =\n                                     (if ws = v then x\nelse bdd_lookup (Leaf a) v);\n        \\<And>v.\n           \\<lbrakk>\\<not> w; bddh (length ws) (Leaf a);\n            length ws = length v\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) ws x) v =\n                             (if ws = v then x else bdd_lookup (Leaf a) v);\n        bddh (length (w # ws)) (Leaf a); length (w # ws) = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) (w # ws) x) v =\n                         (if w # ws = v then x else bdd_lookup (Leaf a) v)\n 3. \\<And>l r w ws x v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>w; bddh (length ws) r;\n                    length ws = length v\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (bddinsert r ws x) v =\n                                     (if ws = v then x else bdd_lookup r v);\n        \\<And>v.\n           \\<lbrakk>\\<not> w; bddh (length ws) l;\n            length ws = length v\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bddinsert l ws x) v =\n                             (if ws = v then x else bdd_lookup l v);\n        bddh (length (w # ws)) (Branch l r);\n        length (w # ws) = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Branch l r) (w # ws) x) v =\n                         (if w # ws = v then x\n                          else bdd_lookup (Branch l r) v)\n 4. \\<And>v va c vb.\n       \\<lbrakk>bddh (length []) (Branch v va);\n        length [] = length vb\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Branch v va) [] c) vb =\n                         (if [] = vb then c\n                          else bdd_lookup (Branch v va) vb)", "with 2"], ["proof (chain)\npicking this:\n  \\<lbrakk>ww; bddh (length wss) (Leaf aa); length wss = length ?v\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (bddinsert (Leaf aa) wss xx) ?v =\n                    (if wss = ?v then xx else bdd_lookup (Leaf aa) ?v)\n  \\<lbrakk>\\<not> ww; bddh (length wss) (Leaf aa);\n   length wss = length ?v\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (bddinsert (Leaf aa) wss xx) ?v =\n                    (if wss = ?v then xx else bdd_lookup (Leaf aa) ?v)\n  bddh (length (ww # wss)) (Leaf aa)\n  length (ww # wss) = length vv\n  vv = v # vs", "have \"length wss = length vs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>ww; bddh (length wss) (Leaf aa); length wss = length ?v\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (bddinsert (Leaf aa) wss xx) ?v =\n                    (if wss = ?v then xx else bdd_lookup (Leaf aa) ?v)\n  \\<lbrakk>\\<not> ww; bddh (length wss) (Leaf aa);\n   length wss = length ?v\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (bddinsert (Leaf aa) wss xx) ?v =\n                    (if wss = ?v then xx else bdd_lookup (Leaf aa) ?v)\n  bddh (length (ww # wss)) (Leaf aa)\n  length (ww # wss) = length vv\n  vv = v # vs\n\ngoal (1 subgoal):\n 1. length wss = length vs", "by simp"], ["proof (state)\nthis:\n  length wss = length vs\n\ngoal (4 subgoals):\n 1. \\<And>a x v.\n       \\<lbrakk>bddh (length []) (Leaf a); length [] = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) [] x) v =\n                         (if [] = v then x else bdd_lookup (Leaf a) v)\n 2. \\<And>a w ws x v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>w; bddh (length ws) (Leaf a);\n                    length ws = length v\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) ws x)\nv =\n                                     (if ws = v then x\nelse bdd_lookup (Leaf a) v);\n        \\<And>v.\n           \\<lbrakk>\\<not> w; bddh (length ws) (Leaf a);\n            length ws = length v\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) ws x) v =\n                             (if ws = v then x else bdd_lookup (Leaf a) v);\n        bddh (length (w # ws)) (Leaf a); length (w # ws) = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) (w # ws) x) v =\n                         (if w # ws = v then x else bdd_lookup (Leaf a) v)\n 3. \\<And>l r w ws x v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>w; bddh (length ws) r;\n                    length ws = length v\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (bddinsert r ws x) v =\n                                     (if ws = v then x else bdd_lookup r v);\n        \\<And>v.\n           \\<lbrakk>\\<not> w; bddh (length ws) l;\n            length ws = length v\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bddinsert l ws x) v =\n                             (if ws = v then x else bdd_lookup l v);\n        bddh (length (w # ws)) (Branch l r);\n        length (w # ws) = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Branch l r) (w # ws) x) v =\n                         (if w # ws = v then x\n                          else bdd_lookup (Branch l r) v)\n 4. \\<And>v va c vb.\n       \\<lbrakk>bddh (length []) (Branch v va);\n        length [] = length vb\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Branch v va) [] c) vb =\n                         (if [] = vb then c\n                          else bdd_lookup (Branch v va) vb)", "with 2"], ["proof (chain)\npicking this:\n  \\<lbrakk>ww; bddh (length wss) (Leaf aa); length wss = length ?v\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (bddinsert (Leaf aa) wss xx) ?v =\n                    (if wss = ?v then xx else bdd_lookup (Leaf aa) ?v)\n  \\<lbrakk>\\<not> ww; bddh (length wss) (Leaf aa);\n   length wss = length ?v\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (bddinsert (Leaf aa) wss xx) ?v =\n                    (if wss = ?v then xx else bdd_lookup (Leaf aa) ?v)\n  bddh (length (ww # wss)) (Leaf aa)\n  length (ww # wss) = length vv\n  length wss = length vs", "have IV: \"bdd_lookup (bddinsert (Leaf aa) wss xx) vs = (if wss = vs then xx else bdd_lookup (Leaf aa) vs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>ww; bddh (length wss) (Leaf aa); length wss = length ?v\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (bddinsert (Leaf aa) wss xx) ?v =\n                    (if wss = ?v then xx else bdd_lookup (Leaf aa) ?v)\n  \\<lbrakk>\\<not> ww; bddh (length wss) (Leaf aa);\n   length wss = length ?v\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (bddinsert (Leaf aa) wss xx) ?v =\n                    (if wss = ?v then xx else bdd_lookup (Leaf aa) ?v)\n  bddh (length (ww # wss)) (Leaf aa)\n  length (ww # wss) = length vv\n  length wss = length vs\n\ngoal (1 subgoal):\n 1. bdd_lookup (bddinsert (Leaf aa) wss xx) vs =\n    (if wss = vs then xx else bdd_lookup (Leaf aa) vs)", "by (cases ww) simp+"], ["proof (state)\nthis:\n  bdd_lookup (bddinsert (Leaf aa) wss xx) vs =\n  (if wss = vs then xx else bdd_lookup (Leaf aa) vs)\n\ngoal (4 subgoals):\n 1. \\<And>a x v.\n       \\<lbrakk>bddh (length []) (Leaf a); length [] = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) [] x) v =\n                         (if [] = v then x else bdd_lookup (Leaf a) v)\n 2. \\<And>a w ws x v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>w; bddh (length ws) (Leaf a);\n                    length ws = length v\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) ws x)\nv =\n                                     (if ws = v then x\nelse bdd_lookup (Leaf a) v);\n        \\<And>v.\n           \\<lbrakk>\\<not> w; bddh (length ws) (Leaf a);\n            length ws = length v\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) ws x) v =\n                             (if ws = v then x else bdd_lookup (Leaf a) v);\n        bddh (length (w # ws)) (Leaf a); length (w # ws) = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) (w # ws) x) v =\n                         (if w # ws = v then x else bdd_lookup (Leaf a) v)\n 3. \\<And>l r w ws x v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>w; bddh (length ws) r;\n                    length ws = length v\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (bddinsert r ws x) v =\n                                     (if ws = v then x else bdd_lookup r v);\n        \\<And>v.\n           \\<lbrakk>\\<not> w; bddh (length ws) l;\n            length ws = length v\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bddinsert l ws x) v =\n                             (if ws = v then x else bdd_lookup l v);\n        bddh (length (w # ws)) (Branch l r);\n        length (w # ws) = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Branch l r) (w # ws) x) v =\n                         (if w # ws = v then x\n                          else bdd_lookup (Branch l r) v)\n 4. \\<And>v va c vb.\n       \\<lbrakk>bddh (length []) (Branch v va);\n        length [] = length vb\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Branch v va) [] c) vb =\n                         (if [] = vb then c\n                          else bdd_lookup (Branch v va) vb)", "have \"bdd_lookup (bddinsert (Leaf aa) (ww # wss) xx) vv = bdd_lookup (if ww then (Branch (Leaf aa) (bddinsert (Leaf aa) wss xx)) else Branch (bddinsert (Leaf aa) wss xx) (Leaf aa)) vv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_lookup (bddinsert (Leaf aa) (ww # wss) xx) vv =\n    bdd_lookup\n     (if ww then Branch (Leaf aa) (bddinsert (Leaf aa) wss xx)\n      else Branch (bddinsert (Leaf aa) wss xx) (Leaf aa))\n     vv", "by simp"], ["proof (state)\nthis:\n  bdd_lookup (bddinsert (Leaf aa) (ww # wss) xx) vv =\n  bdd_lookup\n   (if ww then Branch (Leaf aa) (bddinsert (Leaf aa) wss xx)\n    else Branch (bddinsert (Leaf aa) wss xx) (Leaf aa))\n   vv\n\ngoal (4 subgoals):\n 1. \\<And>a x v.\n       \\<lbrakk>bddh (length []) (Leaf a); length [] = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) [] x) v =\n                         (if [] = v then x else bdd_lookup (Leaf a) v)\n 2. \\<And>a w ws x v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>w; bddh (length ws) (Leaf a);\n                    length ws = length v\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) ws x)\nv =\n                                     (if ws = v then x\nelse bdd_lookup (Leaf a) v);\n        \\<And>v.\n           \\<lbrakk>\\<not> w; bddh (length ws) (Leaf a);\n            length ws = length v\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) ws x) v =\n                             (if ws = v then x else bdd_lookup (Leaf a) v);\n        bddh (length (w # ws)) (Leaf a); length (w # ws) = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) (w # ws) x) v =\n                         (if w # ws = v then x else bdd_lookup (Leaf a) v)\n 3. \\<And>l r w ws x v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>w; bddh (length ws) r;\n                    length ws = length v\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (bddinsert r ws x) v =\n                                     (if ws = v then x else bdd_lookup r v);\n        \\<And>v.\n           \\<lbrakk>\\<not> w; bddh (length ws) l;\n            length ws = length v\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bddinsert l ws x) v =\n                             (if ws = v then x else bdd_lookup l v);\n        bddh (length (w # ws)) (Branch l r);\n        length (w # ws) = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Branch l r) (w # ws) x) v =\n                         (if w # ws = v then x\n                          else bdd_lookup (Branch l r) v)\n 4. \\<And>v va c vb.\n       \\<lbrakk>bddh (length []) (Branch v va);\n        length [] = length vb\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Branch v va) [] c) vb =\n                         (if [] = vb then c\n                          else bdd_lookup (Branch v va) vb)", "also"], ["proof (state)\nthis:\n  bdd_lookup (bddinsert (Leaf aa) (ww # wss) xx) vv =\n  bdd_lookup\n   (if ww then Branch (Leaf aa) (bddinsert (Leaf aa) wss xx)\n    else Branch (bddinsert (Leaf aa) wss xx) (Leaf aa))\n   vv\n\ngoal (4 subgoals):\n 1. \\<And>a x v.\n       \\<lbrakk>bddh (length []) (Leaf a); length [] = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) [] x) v =\n                         (if [] = v then x else bdd_lookup (Leaf a) v)\n 2. \\<And>a w ws x v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>w; bddh (length ws) (Leaf a);\n                    length ws = length v\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) ws x)\nv =\n                                     (if ws = v then x\nelse bdd_lookup (Leaf a) v);\n        \\<And>v.\n           \\<lbrakk>\\<not> w; bddh (length ws) (Leaf a);\n            length ws = length v\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) ws x) v =\n                             (if ws = v then x else bdd_lookup (Leaf a) v);\n        bddh (length (w # ws)) (Leaf a); length (w # ws) = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) (w # ws) x) v =\n                         (if w # ws = v then x else bdd_lookup (Leaf a) v)\n 3. \\<And>l r w ws x v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>w; bddh (length ws) r;\n                    length ws = length v\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (bddinsert r ws x) v =\n                                     (if ws = v then x else bdd_lookup r v);\n        \\<And>v.\n           \\<lbrakk>\\<not> w; bddh (length ws) l;\n            length ws = length v\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bddinsert l ws x) v =\n                             (if ws = v then x else bdd_lookup l v);\n        bddh (length (w # ws)) (Branch l r);\n        length (w # ws) = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Branch l r) (w # ws) x) v =\n                         (if w # ws = v then x\n                          else bdd_lookup (Branch l r) v)\n 4. \\<And>v va c vb.\n       \\<lbrakk>bddh (length []) (Branch v va);\n        length [] = length vb\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Branch v va) [] c) vb =\n                         (if [] = vb then c\n                          else bdd_lookup (Branch v va) vb)", "have \"\\<dots> = (if ww then bdd_lookup (Branch (Leaf aa) (bddinsert (Leaf aa) wss xx)) vv else bdd_lookup (Branch (bddinsert (Leaf aa) wss xx) (Leaf aa)) vv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_lookup\n     (if ww then Branch (Leaf aa) (bddinsert (Leaf aa) wss xx)\n      else Branch (bddinsert (Leaf aa) wss xx) (Leaf aa))\n     vv =\n    (if ww\n     then bdd_lookup (Branch (Leaf aa) (bddinsert (Leaf aa) wss xx)) vv\n     else bdd_lookup (Branch (bddinsert (Leaf aa) wss xx) (Leaf aa)) vv)", "by simp"], ["proof (state)\nthis:\n  bdd_lookup\n   (if ww then Branch (Leaf aa) (bddinsert (Leaf aa) wss xx)\n    else Branch (bddinsert (Leaf aa) wss xx) (Leaf aa))\n   vv =\n  (if ww then bdd_lookup (Branch (Leaf aa) (bddinsert (Leaf aa) wss xx)) vv\n   else bdd_lookup (Branch (bddinsert (Leaf aa) wss xx) (Leaf aa)) vv)\n\ngoal (4 subgoals):\n 1. \\<And>a x v.\n       \\<lbrakk>bddh (length []) (Leaf a); length [] = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) [] x) v =\n                         (if [] = v then x else bdd_lookup (Leaf a) v)\n 2. \\<And>a w ws x v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>w; bddh (length ws) (Leaf a);\n                    length ws = length v\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) ws x)\nv =\n                                     (if ws = v then x\nelse bdd_lookup (Leaf a) v);\n        \\<And>v.\n           \\<lbrakk>\\<not> w; bddh (length ws) (Leaf a);\n            length ws = length v\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) ws x) v =\n                             (if ws = v then x else bdd_lookup (Leaf a) v);\n        bddh (length (w # ws)) (Leaf a); length (w # ws) = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) (w # ws) x) v =\n                         (if w # ws = v then x else bdd_lookup (Leaf a) v)\n 3. \\<And>l r w ws x v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>w; bddh (length ws) r;\n                    length ws = length v\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (bddinsert r ws x) v =\n                                     (if ws = v then x else bdd_lookup r v);\n        \\<And>v.\n           \\<lbrakk>\\<not> w; bddh (length ws) l;\n            length ws = length v\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bddinsert l ws x) v =\n                             (if ws = v then x else bdd_lookup l v);\n        bddh (length (w # ws)) (Branch l r);\n        length (w # ws) = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Branch l r) (w # ws) x) v =\n                         (if w # ws = v then x\n                          else bdd_lookup (Branch l r) v)\n 4. \\<And>v va c vb.\n       \\<lbrakk>bddh (length []) (Branch v va);\n        length [] = length vb\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Branch v va) [] c) vb =\n                         (if [] = vb then c\n                          else bdd_lookup (Branch v va) vb)", "also"], ["proof (state)\nthis:\n  bdd_lookup\n   (if ww then Branch (Leaf aa) (bddinsert (Leaf aa) wss xx)\n    else Branch (bddinsert (Leaf aa) wss xx) (Leaf aa))\n   vv =\n  (if ww then bdd_lookup (Branch (Leaf aa) (bddinsert (Leaf aa) wss xx)) vv\n   else bdd_lookup (Branch (bddinsert (Leaf aa) wss xx) (Leaf aa)) vv)\n\ngoal (4 subgoals):\n 1. \\<And>a x v.\n       \\<lbrakk>bddh (length []) (Leaf a); length [] = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) [] x) v =\n                         (if [] = v then x else bdd_lookup (Leaf a) v)\n 2. \\<And>a w ws x v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>w; bddh (length ws) (Leaf a);\n                    length ws = length v\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) ws x)\nv =\n                                     (if ws = v then x\nelse bdd_lookup (Leaf a) v);\n        \\<And>v.\n           \\<lbrakk>\\<not> w; bddh (length ws) (Leaf a);\n            length ws = length v\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) ws x) v =\n                             (if ws = v then x else bdd_lookup (Leaf a) v);\n        bddh (length (w # ws)) (Leaf a); length (w # ws) = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) (w # ws) x) v =\n                         (if w # ws = v then x else bdd_lookup (Leaf a) v)\n 3. \\<And>l r w ws x v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>w; bddh (length ws) r;\n                    length ws = length v\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (bddinsert r ws x) v =\n                                     (if ws = v then x else bdd_lookup r v);\n        \\<And>v.\n           \\<lbrakk>\\<not> w; bddh (length ws) l;\n            length ws = length v\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bddinsert l ws x) v =\n                             (if ws = v then x else bdd_lookup l v);\n        bddh (length (w # ws)) (Branch l r);\n        length (w # ws) = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Branch l r) (w # ws) x) v =\n                         (if w # ws = v then x\n                          else bdd_lookup (Branch l r) v)\n 4. \\<And>v va c vb.\n       \\<lbrakk>bddh (length []) (Branch v va);\n        length [] = length vb\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Branch v va) [] c) vb =\n                         (if [] = vb then c\n                          else bdd_lookup (Branch v va) vb)", "from V IV"], ["proof (chain)\npicking this:\n  vv = v # vs\n  bdd_lookup (bddinsert (Leaf aa) wss xx) vs =\n  (if wss = vs then xx else bdd_lookup (Leaf aa) vs)", "have \"\\<dots> = (if ww # wss = v # vs then bdd_lookup (bddinsert (Leaf aa) wss xx) vs else bdd_lookup (Leaf aa) vs)\""], ["proof (prove)\nusing this:\n  vv = v # vs\n  bdd_lookup (bddinsert (Leaf aa) wss xx) vs =\n  (if wss = vs then xx else bdd_lookup (Leaf aa) vs)\n\ngoal (1 subgoal):\n 1. (if ww\n     then bdd_lookup (Branch (Leaf aa) (bddinsert (Leaf aa) wss xx)) vv\n     else bdd_lookup (Branch (bddinsert (Leaf aa) wss xx) (Leaf aa)) vv) =\n    (if ww # wss = v # vs then bdd_lookup (bddinsert (Leaf aa) wss xx) vs\n     else bdd_lookup (Leaf aa) vs)", "by (cases ww) auto"], ["proof (state)\nthis:\n  (if ww then bdd_lookup (Branch (Leaf aa) (bddinsert (Leaf aa) wss xx)) vv\n   else bdd_lookup (Branch (bddinsert (Leaf aa) wss xx) (Leaf aa)) vv) =\n  (if ww # wss = v # vs then bdd_lookup (bddinsert (Leaf aa) wss xx) vs\n   else bdd_lookup (Leaf aa) vs)\n\ngoal (4 subgoals):\n 1. \\<And>a x v.\n       \\<lbrakk>bddh (length []) (Leaf a); length [] = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) [] x) v =\n                         (if [] = v then x else bdd_lookup (Leaf a) v)\n 2. \\<And>a w ws x v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>w; bddh (length ws) (Leaf a);\n                    length ws = length v\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) ws x)\nv =\n                                     (if ws = v then x\nelse bdd_lookup (Leaf a) v);\n        \\<And>v.\n           \\<lbrakk>\\<not> w; bddh (length ws) (Leaf a);\n            length ws = length v\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) ws x) v =\n                             (if ws = v then x else bdd_lookup (Leaf a) v);\n        bddh (length (w # ws)) (Leaf a); length (w # ws) = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) (w # ws) x) v =\n                         (if w # ws = v then x else bdd_lookup (Leaf a) v)\n 3. \\<And>l r w ws x v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>w; bddh (length ws) r;\n                    length ws = length v\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (bddinsert r ws x) v =\n                                     (if ws = v then x else bdd_lookup r v);\n        \\<And>v.\n           \\<lbrakk>\\<not> w; bddh (length ws) l;\n            length ws = length v\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bddinsert l ws x) v =\n                             (if ws = v then x else bdd_lookup l v);\n        bddh (length (w # ws)) (Branch l r);\n        length (w # ws) = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Branch l r) (w # ws) x) v =\n                         (if w # ws = v then x\n                          else bdd_lookup (Branch l r) v)\n 4. \\<And>v va c vb.\n       \\<lbrakk>bddh (length []) (Branch v va);\n        length [] = length vb\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Branch v va) [] c) vb =\n                         (if [] = vb then c\n                          else bdd_lookup (Branch v va) vb)", "also"], ["proof (state)\nthis:\n  (if ww then bdd_lookup (Branch (Leaf aa) (bddinsert (Leaf aa) wss xx)) vv\n   else bdd_lookup (Branch (bddinsert (Leaf aa) wss xx) (Leaf aa)) vv) =\n  (if ww # wss = v # vs then bdd_lookup (bddinsert (Leaf aa) wss xx) vs\n   else bdd_lookup (Leaf aa) vs)\n\ngoal (4 subgoals):\n 1. \\<And>a x v.\n       \\<lbrakk>bddh (length []) (Leaf a); length [] = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) [] x) v =\n                         (if [] = v then x else bdd_lookup (Leaf a) v)\n 2. \\<And>a w ws x v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>w; bddh (length ws) (Leaf a);\n                    length ws = length v\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) ws x)\nv =\n                                     (if ws = v then x\nelse bdd_lookup (Leaf a) v);\n        \\<And>v.\n           \\<lbrakk>\\<not> w; bddh (length ws) (Leaf a);\n            length ws = length v\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) ws x) v =\n                             (if ws = v then x else bdd_lookup (Leaf a) v);\n        bddh (length (w # ws)) (Leaf a); length (w # ws) = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) (w # ws) x) v =\n                         (if w # ws = v then x else bdd_lookup (Leaf a) v)\n 3. \\<And>l r w ws x v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>w; bddh (length ws) r;\n                    length ws = length v\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (bddinsert r ws x) v =\n                                     (if ws = v then x else bdd_lookup r v);\n        \\<And>v.\n           \\<lbrakk>\\<not> w; bddh (length ws) l;\n            length ws = length v\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bddinsert l ws x) v =\n                             (if ws = v then x else bdd_lookup l v);\n        bddh (length (w # ws)) (Branch l r);\n        length (w # ws) = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Branch l r) (w # ws) x) v =\n                         (if w # ws = v then x\n                          else bdd_lookup (Branch l r) v)\n 4. \\<And>v va c vb.\n       \\<lbrakk>bddh (length []) (Branch v va);\n        length [] = length vb\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Branch v va) [] c) vb =\n                         (if [] = vb then c\n                          else bdd_lookup (Branch v va) vb)", "from V IV"], ["proof (chain)\npicking this:\n  vv = v # vs\n  bdd_lookup (bddinsert (Leaf aa) wss xx) vs =\n  (if wss = vs then xx else bdd_lookup (Leaf aa) vs)", "have \"\\<dots> = (if ww # wss = vv then xx else bdd_lookup (Leaf aa) vs)\""], ["proof (prove)\nusing this:\n  vv = v # vs\n  bdd_lookup (bddinsert (Leaf aa) wss xx) vs =\n  (if wss = vs then xx else bdd_lookup (Leaf aa) vs)\n\ngoal (1 subgoal):\n 1. (if ww # wss = v # vs then bdd_lookup (bddinsert (Leaf aa) wss xx) vs\n     else bdd_lookup (Leaf aa) vs) =\n    (if ww # wss = vv then xx else bdd_lookup (Leaf aa) vs)", "by auto"], ["proof (state)\nthis:\n  (if ww # wss = v # vs then bdd_lookup (bddinsert (Leaf aa) wss xx) vs\n   else bdd_lookup (Leaf aa) vs) =\n  (if ww # wss = vv then xx else bdd_lookup (Leaf aa) vs)\n\ngoal (4 subgoals):\n 1. \\<And>a x v.\n       \\<lbrakk>bddh (length []) (Leaf a); length [] = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) [] x) v =\n                         (if [] = v then x else bdd_lookup (Leaf a) v)\n 2. \\<And>a w ws x v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>w; bddh (length ws) (Leaf a);\n                    length ws = length v\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) ws x)\nv =\n                                     (if ws = v then x\nelse bdd_lookup (Leaf a) v);\n        \\<And>v.\n           \\<lbrakk>\\<not> w; bddh (length ws) (Leaf a);\n            length ws = length v\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) ws x) v =\n                             (if ws = v then x else bdd_lookup (Leaf a) v);\n        bddh (length (w # ws)) (Leaf a); length (w # ws) = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) (w # ws) x) v =\n                         (if w # ws = v then x else bdd_lookup (Leaf a) v)\n 3. \\<And>l r w ws x v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>w; bddh (length ws) r;\n                    length ws = length v\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (bddinsert r ws x) v =\n                                     (if ws = v then x else bdd_lookup r v);\n        \\<And>v.\n           \\<lbrakk>\\<not> w; bddh (length ws) l;\n            length ws = length v\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bddinsert l ws x) v =\n                             (if ws = v then x else bdd_lookup l v);\n        bddh (length (w # ws)) (Branch l r);\n        length (w # ws) = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Branch l r) (w # ws) x) v =\n                         (if w # ws = v then x\n                          else bdd_lookup (Branch l r) v)\n 4. \\<And>v va c vb.\n       \\<lbrakk>bddh (length []) (Branch v va);\n        length [] = length vb\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Branch v va) [] c) vb =\n                         (if [] = vb then c\n                          else bdd_lookup (Branch v va) vb)", "finally"], ["proof (chain)\npicking this:\n  bdd_lookup (bddinsert (Leaf aa) (ww # wss) xx) vv =\n  (if ww # wss = vv then xx else bdd_lookup (Leaf aa) vs)", "show ?case"], ["proof (prove)\nusing this:\n  bdd_lookup (bddinsert (Leaf aa) (ww # wss) xx) vv =\n  (if ww # wss = vv then xx else bdd_lookup (Leaf aa) vs)\n\ngoal (1 subgoal):\n 1. bdd_lookup (bddinsert (Leaf aa) (ww # wss) xx) vv =\n    (if ww # wss = vv then xx else bdd_lookup (Leaf aa) vv)", "by simp"], ["proof (state)\nthis:\n  bdd_lookup (bddinsert (Leaf aa) (ww # wss) xx) vv =\n  (if ww # wss = vv then xx else bdd_lookup (Leaf aa) vv)\n\ngoal (3 subgoals):\n 1. \\<And>a x v.\n       \\<lbrakk>bddh (length []) (Leaf a); length [] = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) [] x) v =\n                         (if [] = v then x else bdd_lookup (Leaf a) v)\n 2. \\<And>l r w ws x v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>w; bddh (length ws) r;\n                    length ws = length v\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (bddinsert r ws x) v =\n                                     (if ws = v then x else bdd_lookup r v);\n        \\<And>v.\n           \\<lbrakk>\\<not> w; bddh (length ws) l;\n            length ws = length v\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bddinsert l ws x) v =\n                             (if ws = v then x else bdd_lookup l v);\n        bddh (length (w # ws)) (Branch l r);\n        length (w # ws) = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Branch l r) (w # ws) x) v =\n                         (if w # ws = v then x\n                          else bdd_lookup (Branch l r) v)\n 3. \\<And>v va c vb.\n       \\<lbrakk>bddh (length []) (Branch v va);\n        length [] = length vb\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Branch v va) [] c) vb =\n                         (if [] = vb then c\n                          else bdd_lookup (Branch v va) vb)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a x v.\n       \\<lbrakk>bddh (length []) (Leaf a); length [] = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) [] x) v =\n                         (if [] = v then x else bdd_lookup (Leaf a) v)\n 2. \\<And>l r w ws x v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>w; bddh (length ws) r;\n                    length ws = length v\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (bddinsert r ws x) v =\n                                     (if ws = v then x else bdd_lookup r v);\n        \\<And>v.\n           \\<lbrakk>\\<not> w; bddh (length ws) l;\n            length ws = length v\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bddinsert l ws x) v =\n                             (if ws = v then x else bdd_lookup l v);\n        bddh (length (w # ws)) (Branch l r);\n        length (w # ws) = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Branch l r) (w # ws) x) v =\n                         (if w # ws = v then x\n                          else bdd_lookup (Branch l r) v)\n 3. \\<And>v va c vb.\n       \\<lbrakk>bddh (length []) (Branch v va);\n        length [] = length vb\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Branch v va) [] c) vb =\n                         (if [] = vb then c\n                          else bdd_lookup (Branch v va) vb)", "case (3 ll rr ww wss xx vv)"], ["proof (state)\nthis:\n  \\<lbrakk>ww; bddh (length wss) rr; length wss = length ?v\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (bddinsert rr wss xx) ?v =\n                    (if wss = ?v then xx else bdd_lookup rr ?v)\n  \\<lbrakk>\\<not> ww; bddh (length wss) ll; length wss = length ?v\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (bddinsert ll wss xx) ?v =\n                    (if wss = ?v then xx else bdd_lookup ll ?v)\n  bddh (length (ww # wss)) (Branch ll rr)\n  length (ww # wss) = length vv\n\ngoal (3 subgoals):\n 1. \\<And>a x v.\n       \\<lbrakk>bddh (length []) (Leaf a); length [] = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) [] x) v =\n                         (if [] = v then x else bdd_lookup (Leaf a) v)\n 2. \\<And>l r w ws x v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>w; bddh (length ws) r;\n                    length ws = length v\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (bddinsert r ws x) v =\n                                     (if ws = v then x else bdd_lookup r v);\n        \\<And>v.\n           \\<lbrakk>\\<not> w; bddh (length ws) l;\n            length ws = length v\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bddinsert l ws x) v =\n                             (if ws = v then x else bdd_lookup l v);\n        bddh (length (w # ws)) (Branch l r);\n        length (w # ws) = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Branch l r) (w # ws) x) v =\n                         (if w # ws = v then x\n                          else bdd_lookup (Branch l r) v)\n 3. \\<And>v va c vb.\n       \\<lbrakk>bddh (length []) (Branch v va);\n        length [] = length vb\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Branch v va) [] c) vb =\n                         (if [] = vb then c\n                          else bdd_lookup (Branch v va) vb)", "hence \"\\<exists>v vs. vv = v # vs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>ww; bddh (length wss) rr; length wss = length ?v\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (bddinsert rr wss xx) ?v =\n                    (if wss = ?v then xx else bdd_lookup rr ?v)\n  \\<lbrakk>\\<not> ww; bddh (length wss) ll; length wss = length ?v\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (bddinsert ll wss xx) ?v =\n                    (if wss = ?v then xx else bdd_lookup ll ?v)\n  bddh (length (ww # wss)) (Branch ll rr)\n  length (ww # wss) = length vv\n\ngoal (1 subgoal):\n 1. \\<exists>v vs. vv = v # vs", "by (cases vv) simp+"], ["proof (state)\nthis:\n  \\<exists>v vs. vv = v # vs\n\ngoal (3 subgoals):\n 1. \\<And>a x v.\n       \\<lbrakk>bddh (length []) (Leaf a); length [] = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) [] x) v =\n                         (if [] = v then x else bdd_lookup (Leaf a) v)\n 2. \\<And>l r w ws x v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>w; bddh (length ws) r;\n                    length ws = length v\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (bddinsert r ws x) v =\n                                     (if ws = v then x else bdd_lookup r v);\n        \\<And>v.\n           \\<lbrakk>\\<not> w; bddh (length ws) l;\n            length ws = length v\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bddinsert l ws x) v =\n                             (if ws = v then x else bdd_lookup l v);\n        bddh (length (w # ws)) (Branch l r);\n        length (w # ws) = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Branch l r) (w # ws) x) v =\n                         (if w # ws = v then x\n                          else bdd_lookup (Branch l r) v)\n 3. \\<And>v va c vb.\n       \\<lbrakk>bddh (length []) (Branch v va);\n        length [] = length vb\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Branch v va) [] c) vb =\n                         (if [] = vb then c\n                          else bdd_lookup (Branch v va) vb)", "then"], ["proof (chain)\npicking this:\n  \\<exists>v vs. vv = v # vs", "obtain v vs where V: \"vv = v # vs\""], ["proof (prove)\nusing this:\n  \\<exists>v vs. vv = v # vs\n\ngoal (1 subgoal):\n 1. (\\<And>v vs. vv = v # vs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  vv = v # vs\n\ngoal (3 subgoals):\n 1. \\<And>a x v.\n       \\<lbrakk>bddh (length []) (Leaf a); length [] = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) [] x) v =\n                         (if [] = v then x else bdd_lookup (Leaf a) v)\n 2. \\<And>l r w ws x v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>w; bddh (length ws) r;\n                    length ws = length v\\<rbrakk>\n                   \\<Longrightarrow> bdd_lookup (bddinsert r ws x) v =\n                                     (if ws = v then x else bdd_lookup r v);\n        \\<And>v.\n           \\<lbrakk>\\<not> w; bddh (length ws) l;\n            length ws = length v\\<rbrakk>\n           \\<Longrightarrow> bdd_lookup (bddinsert l ws x) v =\n                             (if ws = v then x else bdd_lookup l v);\n        bddh (length (w # ws)) (Branch l r);\n        length (w # ws) = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Branch l r) (w # ws) x) v =\n                         (if w # ws = v then x\n                          else bdd_lookup (Branch l r) v)\n 3. \\<And>v va c vb.\n       \\<lbrakk>bddh (length []) (Branch v va);\n        length [] = length vb\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Branch v va) [] c) vb =\n                         (if [] = vb then c\n                          else bdd_lookup (Branch v va) vb)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_lookup (bddinsert (Branch ll rr) (ww # wss) xx) vv =\n    (if ww # wss = vv then xx else bdd_lookup (Branch ll rr) vv)", "proof (cases ww)"], ["proof (state)\ngoal (2 subgoals):\n 1. ww \\<Longrightarrow>\n    bdd_lookup (bddinsert (Branch ll rr) (ww # wss) xx) vv =\n    (if ww # wss = vv then xx else bdd_lookup (Branch ll rr) vv)\n 2. \\<not> ww \\<Longrightarrow>\n    bdd_lookup (bddinsert (Branch ll rr) (ww # wss) xx) vv =\n    (if ww # wss = vv then xx else bdd_lookup (Branch ll rr) vv)", "case True"], ["proof (state)\nthis:\n  ww\n\ngoal (2 subgoals):\n 1. ww \\<Longrightarrow>\n    bdd_lookup (bddinsert (Branch ll rr) (ww # wss) xx) vv =\n    (if ww # wss = vv then xx else bdd_lookup (Branch ll rr) vv)\n 2. \\<not> ww \\<Longrightarrow>\n    bdd_lookup (bddinsert (Branch ll rr) (ww # wss) xx) vv =\n    (if ww # wss = vv then xx else bdd_lookup (Branch ll rr) vv)", "with 3 V"], ["proof (chain)\npicking this:\n  \\<lbrakk>ww; bddh (length wss) rr; length wss = length ?v\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (bddinsert rr wss xx) ?v =\n                    (if wss = ?v then xx else bdd_lookup rr ?v)\n  \\<lbrakk>\\<not> ww; bddh (length wss) ll; length wss = length ?v\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (bddinsert ll wss xx) ?v =\n                    (if wss = ?v then xx else bdd_lookup ll ?v)\n  bddh (length (ww # wss)) (Branch ll rr)\n  length (ww # wss) = length vv\n  vv = v # vs\n  ww", "have IV: \"bdd_lookup (bddinsert rr wss xx) vs = (if wss = vs then xx else bdd_lookup rr vs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>ww; bddh (length wss) rr; length wss = length ?v\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (bddinsert rr wss xx) ?v =\n                    (if wss = ?v then xx else bdd_lookup rr ?v)\n  \\<lbrakk>\\<not> ww; bddh (length wss) ll; length wss = length ?v\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (bddinsert ll wss xx) ?v =\n                    (if wss = ?v then xx else bdd_lookup ll ?v)\n  bddh (length (ww # wss)) (Branch ll rr)\n  length (ww # wss) = length vv\n  vv = v # vs\n  ww\n\ngoal (1 subgoal):\n 1. bdd_lookup (bddinsert rr wss xx) vs =\n    (if wss = vs then xx else bdd_lookup rr vs)", "by simp"], ["proof (state)\nthis:\n  bdd_lookup (bddinsert rr wss xx) vs =\n  (if wss = vs then xx else bdd_lookup rr vs)\n\ngoal (2 subgoals):\n 1. ww \\<Longrightarrow>\n    bdd_lookup (bddinsert (Branch ll rr) (ww # wss) xx) vv =\n    (if ww # wss = vv then xx else bdd_lookup (Branch ll rr) vv)\n 2. \\<not> ww \\<Longrightarrow>\n    bdd_lookup (bddinsert (Branch ll rr) (ww # wss) xx) vv =\n    (if ww # wss = vv then xx else bdd_lookup (Branch ll rr) vv)", "with True 3 V"], ["proof (chain)\npicking this:\n  ww\n  \\<lbrakk>ww; bddh (length wss) rr; length wss = length ?v\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (bddinsert rr wss xx) ?v =\n                    (if wss = ?v then xx else bdd_lookup rr ?v)\n  \\<lbrakk>\\<not> ww; bddh (length wss) ll; length wss = length ?v\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (bddinsert ll wss xx) ?v =\n                    (if wss = ?v then xx else bdd_lookup ll ?v)\n  bddh (length (ww # wss)) (Branch ll rr)\n  length (ww # wss) = length vv\n  vv = v # vs\n  bdd_lookup (bddinsert rr wss xx) vs =\n  (if wss = vs then xx else bdd_lookup rr vs)", "show ?thesis"], ["proof (prove)\nusing this:\n  ww\n  \\<lbrakk>ww; bddh (length wss) rr; length wss = length ?v\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (bddinsert rr wss xx) ?v =\n                    (if wss = ?v then xx else bdd_lookup rr ?v)\n  \\<lbrakk>\\<not> ww; bddh (length wss) ll; length wss = length ?v\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (bddinsert ll wss xx) ?v =\n                    (if wss = ?v then xx else bdd_lookup ll ?v)\n  bddh (length (ww # wss)) (Branch ll rr)\n  length (ww # wss) = length vv\n  vv = v # vs\n  bdd_lookup (bddinsert rr wss xx) vs =\n  (if wss = vs then xx else bdd_lookup rr vs)\n\ngoal (1 subgoal):\n 1. bdd_lookup (bddinsert (Branch ll rr) (ww # wss) xx) vv =\n    (if ww # wss = vv then xx else bdd_lookup (Branch ll rr) vv)", "by auto"], ["proof (state)\nthis:\n  bdd_lookup (bddinsert (Branch ll rr) (ww # wss) xx) vv =\n  (if ww # wss = vv then xx else bdd_lookup (Branch ll rr) vv)\n\ngoal (1 subgoal):\n 1. \\<not> ww \\<Longrightarrow>\n    bdd_lookup (bddinsert (Branch ll rr) (ww # wss) xx) vv =\n    (if ww # wss = vv then xx else bdd_lookup (Branch ll rr) vv)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ww \\<Longrightarrow>\n    bdd_lookup (bddinsert (Branch ll rr) (ww # wss) xx) vv =\n    (if ww # wss = vv then xx else bdd_lookup (Branch ll rr) vv)", "case False"], ["proof (state)\nthis:\n  \\<not> ww\n\ngoal (1 subgoal):\n 1. \\<not> ww \\<Longrightarrow>\n    bdd_lookup (bddinsert (Branch ll rr) (ww # wss) xx) vv =\n    (if ww # wss = vv then xx else bdd_lookup (Branch ll rr) vv)", "with 3 V"], ["proof (chain)\npicking this:\n  \\<lbrakk>ww; bddh (length wss) rr; length wss = length ?v\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (bddinsert rr wss xx) ?v =\n                    (if wss = ?v then xx else bdd_lookup rr ?v)\n  \\<lbrakk>\\<not> ww; bddh (length wss) ll; length wss = length ?v\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (bddinsert ll wss xx) ?v =\n                    (if wss = ?v then xx else bdd_lookup ll ?v)\n  bddh (length (ww # wss)) (Branch ll rr)\n  length (ww # wss) = length vv\n  vv = v # vs\n  \\<not> ww", "have IV: \"bdd_lookup (bddinsert ll wss xx) vs = (if wss = vs then xx else bdd_lookup ll vs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>ww; bddh (length wss) rr; length wss = length ?v\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (bddinsert rr wss xx) ?v =\n                    (if wss = ?v then xx else bdd_lookup rr ?v)\n  \\<lbrakk>\\<not> ww; bddh (length wss) ll; length wss = length ?v\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (bddinsert ll wss xx) ?v =\n                    (if wss = ?v then xx else bdd_lookup ll ?v)\n  bddh (length (ww # wss)) (Branch ll rr)\n  length (ww # wss) = length vv\n  vv = v # vs\n  \\<not> ww\n\ngoal (1 subgoal):\n 1. bdd_lookup (bddinsert ll wss xx) vs =\n    (if wss = vs then xx else bdd_lookup ll vs)", "by simp"], ["proof (state)\nthis:\n  bdd_lookup (bddinsert ll wss xx) vs =\n  (if wss = vs then xx else bdd_lookup ll vs)\n\ngoal (1 subgoal):\n 1. \\<not> ww \\<Longrightarrow>\n    bdd_lookup (bddinsert (Branch ll rr) (ww # wss) xx) vv =\n    (if ww # wss = vv then xx else bdd_lookup (Branch ll rr) vv)", "with False 3 V"], ["proof (chain)\npicking this:\n  \\<not> ww\n  \\<lbrakk>ww; bddh (length wss) rr; length wss = length ?v\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (bddinsert rr wss xx) ?v =\n                    (if wss = ?v then xx else bdd_lookup rr ?v)\n  \\<lbrakk>\\<not> ww; bddh (length wss) ll; length wss = length ?v\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (bddinsert ll wss xx) ?v =\n                    (if wss = ?v then xx else bdd_lookup ll ?v)\n  bddh (length (ww # wss)) (Branch ll rr)\n  length (ww # wss) = length vv\n  vv = v # vs\n  bdd_lookup (bddinsert ll wss xx) vs =\n  (if wss = vs then xx else bdd_lookup ll vs)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> ww\n  \\<lbrakk>ww; bddh (length wss) rr; length wss = length ?v\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (bddinsert rr wss xx) ?v =\n                    (if wss = ?v then xx else bdd_lookup rr ?v)\n  \\<lbrakk>\\<not> ww; bddh (length wss) ll; length wss = length ?v\\<rbrakk>\n  \\<Longrightarrow> bdd_lookup (bddinsert ll wss xx) ?v =\n                    (if wss = ?v then xx else bdd_lookup ll ?v)\n  bddh (length (ww # wss)) (Branch ll rr)\n  length (ww # wss) = length vv\n  vv = v # vs\n  bdd_lookup (bddinsert ll wss xx) vs =\n  (if wss = vs then xx else bdd_lookup ll vs)\n\ngoal (1 subgoal):\n 1. bdd_lookup (bddinsert (Branch ll rr) (ww # wss) xx) vv =\n    (if ww # wss = vv then xx else bdd_lookup (Branch ll rr) vv)", "by auto"], ["proof (state)\nthis:\n  bdd_lookup (bddinsert (Branch ll rr) (ww # wss) xx) vv =\n  (if ww # wss = vv then xx else bdd_lookup (Branch ll rr) vv)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bdd_lookup (bddinsert (Branch ll rr) (ww # wss) xx) vv =\n  (if ww # wss = vv then xx else bdd_lookup (Branch ll rr) vv)\n\ngoal (2 subgoals):\n 1. \\<And>a x v.\n       \\<lbrakk>bddh (length []) (Leaf a); length [] = length v\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Leaf a) [] x) v =\n                         (if [] = v then x else bdd_lookup (Leaf a) v)\n 2. \\<And>v va c vb.\n       \\<lbrakk>bddh (length []) (Branch v va);\n        length [] = length vb\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (bddinsert (Branch v va) [] c) vb =\n                         (if [] = vb then c\n                          else bdd_lookup (Branch v va) vb)", "qed simp+"], ["", "definition\n  subset_succs :: \"nfa \\<Rightarrow> bool list \\<Rightarrow> bool list list\" where\n  \"subset_succs A qs = add_leaves (subsetbdd (fst A) qs (nfa_emptybdd (length qs))) []\""], ["", "definition\n  subset_invariant :: \"nfa \\<Rightarrow> nat option bdd \\<times> bool list list \\<Rightarrow> bool\" where\n  \"subset_invariant A = (\\<lambda>(bdd, qss). bddh (length (fst A)) bdd)\""], ["", "definition\n  \"subset_ins qs = (\\<lambda>(bdd, qss). (bddinsert bdd qs (Some (length qss)), qss @ [qs]))\""], ["", "definition\n  subset_memb :: \"bool list \\<Rightarrow> nat option bdd \\<times> bool list list \\<Rightarrow> bool\" where\n  \"subset_memb qs = (\\<lambda>(bdd, qss). bdd_lookup bdd qs \\<noteq> None)\""], ["", "definition\n  subset_empt :: \"nat option bdd \\<times> bool list list\" where\n  \"subset_empt = (Leaf None, [])\""], ["", "definition\n  subset_dfs :: \"nfa \\<Rightarrow> bool list \\<Rightarrow> nat option bdd \\<times> bool list list\" where\n  \"subset_dfs A x = gen_dfs (subset_succs A) subset_ins subset_memb subset_empt [x]\""], ["", "definition\n  det_nfa :: \"nfa \\<Rightarrow> dfa\" where\n  \"det_nfa A = (let (bdd, qss) = subset_dfs A (nfa_startnode A) in\n             (map (\\<lambda>qs. bdd_map (\\<lambda>qs. the (bdd_lookup bdd qs)) (subsetbdd (fst A) qs (nfa_emptybdd (length qs)))) qss,\n              map (\\<lambda>qs. nfa_accepting A qs) qss))\""], ["", "locale subset_DFS =\n  fixes A n\n  assumes well_formed: \"wf_nfa A n\""], ["", "lemma finite_list: \"finite {xs::('a::finite) list. length xs = k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {xs. length xs = k}", "apply (induct k)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite {xs. length xs = 0}\n 2. \\<And>k.\n       finite {xs. length xs = k} \\<Longrightarrow>\n       finite {xs. length xs = Suc k}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       finite {xs. length xs = k} \\<Longrightarrow>\n       finite {xs. length xs = Suc k}", "apply (subgoal_tac \"{xs::('a::finite) list. length xs = Suc k} = (\\<Union>x. Cons x ` {xs. length xs = k})\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>finite {xs. length xs = k};\n        {xs. length xs = Suc k} =\n        (\\<Union>x. (#) x ` {xs. length xs = k})\\<rbrakk>\n       \\<Longrightarrow> finite {xs. length xs = Suc k}\n 2. \\<And>k.\n       finite {xs. length xs = k} \\<Longrightarrow>\n       {xs. length xs = Suc k} = (\\<Union>x. (#) x ` {xs. length xs = k})", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k x.\n       \\<lbrakk>finite {xs. length xs = k}; length x = Suc k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa. x \\<in> (#) xa ` {xs. length xs = k}", "apply (case_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k x.\n       \\<lbrakk>finite {xs. length xs = k}; length x = Suc k;\n        x = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa. x \\<in> (#) xa ` {xs. length xs = k}\n 2. \\<And>k x a list.\n       \\<lbrakk>finite {xs. length xs = k}; length x = Suc k;\n        x = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa. x \\<in> (#) xa ` {xs. length xs = k}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sublocale subset_DFS < DFS \"subset_succs A\" \"nfa_is_node A\" \"subset_invariant A\" subset_ins subset_memb subset_empt"], ["proof (prove)\ngoal (1 subgoal):\n 1. DFS (subset_succs A) (nfa_is_node A) (subset_invariant A) subset_ins\n     subset_memb subset_empt", "apply (unfold_locales)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x y S.\n       \\<lbrakk>nfa_is_node A x; nfa_is_node A y; subset_invariant A S;\n        \\<not> subset_memb y S\\<rbrakk>\n       \\<Longrightarrow> subset_memb x (subset_ins y S) =\n                         (x = y \\<or> subset_memb x S)\n 2. \\<And>x.\n       nfa_is_node A x \\<Longrightarrow> \\<not> subset_memb x subset_empt\n 3. \\<And>x.\n       nfa_is_node A x \\<Longrightarrow>\n       list_all (nfa_is_node A) (subset_succs A x)\n 4. subset_invariant A subset_empt\n 5. \\<And>x S.\n       \\<lbrakk>nfa_is_node A x; subset_invariant A S;\n        \\<not> subset_memb x S\\<rbrakk>\n       \\<Longrightarrow> subset_invariant A (subset_ins x S)\n 6. finite {x. nfa_is_node A x}", "apply (simp add: nfa_is_node_def subset_invariant_def subset_memb_def subset_ins_def bdd_lookup_bddinsert split_beta)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       nfa_is_node A x \\<Longrightarrow> \\<not> subset_memb x subset_empt\n 2. \\<And>x.\n       nfa_is_node A x \\<Longrightarrow>\n       list_all (nfa_is_node A) (subset_succs A x)\n 3. subset_invariant A subset_empt\n 4. \\<And>x S.\n       \\<lbrakk>nfa_is_node A x; subset_invariant A S;\n        \\<not> subset_memb x S\\<rbrakk>\n       \\<Longrightarrow> subset_invariant A (subset_ins x S)\n 5. finite {x. nfa_is_node A x}", "apply (simp add: nfa_is_node_def subset_memb_def subset_empt_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       nfa_is_node A x \\<Longrightarrow>\n       list_all (nfa_is_node A) (subset_succs A x)\n 2. subset_invariant A subset_empt\n 3. \\<And>x S.\n       \\<lbrakk>nfa_is_node A x; subset_invariant A S;\n        \\<not> subset_memb x S\\<rbrakk>\n       \\<Longrightarrow> subset_invariant A (subset_ins x S)\n 4. finite {x. nfa_is_node A x}", "apply (insert well_formed)[]"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>nfa_is_node A x; wf_nfa A n\\<rbrakk>\n       \\<Longrightarrow> list_all (nfa_is_node A) (subset_succs A x)\n 2. subset_invariant A subset_empt\n 3. \\<And>x S.\n       \\<lbrakk>nfa_is_node A x; subset_invariant A S;\n        \\<not> subset_memb x S\\<rbrakk>\n       \\<Longrightarrow> subset_invariant A (subset_ins x S)\n 4. finite {x. nfa_is_node A x}", "apply (simp add: subset_succs_def add_leaves_bdd_all_eq bdd_all_is_node_subsetbdd wf_nfa_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. subset_invariant A subset_empt\n 2. \\<And>x S.\n       \\<lbrakk>nfa_is_node A x; subset_invariant A S;\n        \\<not> subset_memb x S\\<rbrakk>\n       \\<Longrightarrow> subset_invariant A (subset_ins x S)\n 3. finite {x. nfa_is_node A x}", "apply (simp add: subset_invariant_def subset_empt_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x S.\n       \\<lbrakk>nfa_is_node A x; subset_invariant A S;\n        \\<not> subset_memb x S\\<rbrakk>\n       \\<Longrightarrow> subset_invariant A (subset_ins x S)\n 2. finite {x. nfa_is_node A x}", "apply (simp add: nfa_is_node_def subset_invariant_def subset_memb_def subset_ins_def split_paired_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a b.\n       \\<lbrakk>length x = length (fst A); bddh (length (fst A)) a;\n        bdd_lookup a x = None\\<rbrakk>\n       \\<Longrightarrow> bddh (length (fst A))\n                          (bddinsert a x (Some (length b)))\n 2. finite {x. nfa_is_node A x}", "apply (subgoal_tac \"length (fst A) = length x\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x a b.\n       \\<lbrakk>length x = length (fst A); bddh (length (fst A)) a;\n        bdd_lookup a x = None; length (fst A) = length x\\<rbrakk>\n       \\<Longrightarrow> bddh (length (fst A))\n                          (bddinsert a x (Some (length b)))\n 2. \\<And>x a b.\n       \\<lbrakk>length x = length (fst A); bddh (length (fst A)) a;\n        bdd_lookup a x = None\\<rbrakk>\n       \\<Longrightarrow> length (fst A) = length x\n 3. finite {x. nfa_is_node A x}", "apply (auto simp: bddh_bddinsert)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. nfa_is_node A x}", "apply (simp add: nfa_is_node_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. length x = length (fst A)}", "apply (rule finite_list)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context subset_DFS\nbegin"], ["", "lemmas dfs_eq_rtrancl[folded subset_dfs_def] = dfs_eq_rtrancl"], ["", "lemma  subset_dfs_bij:\n  assumes H1: \"nfa_is_node A q\"\n  and H2: \"nfa_is_node A q0\"\n  shows \"(bdd_lookup (fst (subset_dfs A q0)) q = Some v) = (v < length (snd (subset_dfs A q0)) \\<and> (snd (subset_dfs A q0)) ! v = q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bdd_lookup (fst (subset_dfs A q0)) q = Some v) =\n    (v < length (snd (subset_dfs A q0)) \\<and>\n     snd (subset_dfs A q0) ! v = q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (bdd_lookup (fst (subset_dfs A q0)) q = Some v) =\n    (v < length (snd (subset_dfs A q0)) \\<and>\n     snd (subset_dfs A q0) ! v = q)", "from assms"], ["proof (chain)\npicking this:\n  nfa_is_node A q\n  nfa_is_node A q0", "have \"list_all (nfa_is_node A) [q0]\""], ["proof (prove)\nusing this:\n  nfa_is_node A q\n  nfa_is_node A q0\n\ngoal (1 subgoal):\n 1. list_all (nfa_is_node A) [q0]", "by simp"], ["proof (state)\nthis:\n  list_all (nfa_is_node A) [q0]\n\ngoal (1 subgoal):\n 1. (bdd_lookup (fst (subset_dfs A q0)) q = Some v) =\n    (v < length (snd (subset_dfs A q0)) \\<and>\n     snd (subset_dfs A q0) ! v = q)", "with empt_invariant"], ["proof (chain)\npicking this:\n  subset_invariant A subset_empt\n  list_all (nfa_is_node A) [q0]", "show ?thesis"], ["proof (prove)\nusing this:\n  subset_invariant A subset_empt\n  list_all (nfa_is_node A) [q0]\n\ngoal (1 subgoal):\n 1. (bdd_lookup (fst (subset_dfs A q0)) q = Some v) =\n    (v < length (snd (subset_dfs A q0)) \\<and>\n     snd (subset_dfs A q0) ! v = q)", "using H1"], ["proof (prove)\nusing this:\n  subset_invariant A subset_empt\n  list_all (nfa_is_node A) [q0]\n  nfa_is_node A q\n\ngoal (1 subgoal):\n 1. (bdd_lookup (fst (subset_dfs A q0)) q = Some v) =\n    (v < length (snd (subset_dfs A q0)) \\<and>\n     snd (subset_dfs A q0) ! v = q)", "unfolding subset_dfs_def"], ["proof (prove)\nusing this:\n  subset_invariant A subset_empt\n  list_all (nfa_is_node A) [q0]\n  nfa_is_node A q\n\ngoal (1 subgoal):\n 1. (bdd_lookup (fst (dfs subset_empt [q0])) q = Some v) =\n    (v < length (snd (dfs subset_empt [q0])) \\<and>\n     snd (dfs subset_empt [q0]) ! v = q)", "proof (induct arbitrary: v q rule: dfs_invariant)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v q.\n       nfa_is_node A q \\<Longrightarrow>\n       (bdd_lookup (fst subset_empt) q = Some v) =\n       (v < length (snd subset_empt) \\<and> snd subset_empt ! v = q)\n 2. \\<And>S x v q.\n       \\<lbrakk>\\<not> subset_memb x S; nfa_is_node A x;\n        subset_invariant A S;\n        \\<And>v q.\n           nfa_is_node A q \\<Longrightarrow>\n           (bdd_lookup (fst S) q = Some v) =\n           (v < length (snd S) \\<and> snd S ! v = q);\n        nfa_is_node A q\\<rbrakk>\n       \\<Longrightarrow> (bdd_lookup (fst (subset_ins x S)) q = Some v) =\n                         (v < length (snd (subset_ins x S)) \\<and>\n                          snd (subset_ins x S) ! v = q)", "case (step S x vv qq)"], ["proof (state)\nthis:\n  \\<not> subset_memb x S\n  nfa_is_node A x\n  subset_invariant A S\n  nfa_is_node A ?q \\<Longrightarrow>\n  (bdd_lookup (fst S) ?q = Some ?v) =\n  (?v < length (snd S) \\<and> snd S ! ?v = ?q)\n  nfa_is_node A qq\n\ngoal (2 subgoals):\n 1. \\<And>v q.\n       nfa_is_node A q \\<Longrightarrow>\n       (bdd_lookup (fst subset_empt) q = Some v) =\n       (v < length (snd subset_empt) \\<and> snd subset_empt ! v = q)\n 2. \\<And>S x v q.\n       \\<lbrakk>\\<not> subset_memb x S; nfa_is_node A x;\n        subset_invariant A S;\n        \\<And>v q.\n           nfa_is_node A q \\<Longrightarrow>\n           (bdd_lookup (fst S) q = Some v) =\n           (v < length (snd S) \\<and> snd S ! v = q);\n        nfa_is_node A q\\<rbrakk>\n       \\<Longrightarrow> (bdd_lookup (fst (subset_ins x S)) q = Some v) =\n                         (v < length (snd (subset_ins x S)) \\<and>\n                          snd (subset_ins x S) ! v = q)", "obtain bd1 l1 where S: \"S = (bd1, l1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>bd1 l1. S = (bd1, l1) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases S) blast+"], ["proof (state)\nthis:\n  S = (bd1, l1)\n\ngoal (2 subgoals):\n 1. \\<And>v q.\n       nfa_is_node A q \\<Longrightarrow>\n       (bdd_lookup (fst subset_empt) q = Some v) =\n       (v < length (snd subset_empt) \\<and> snd subset_empt ! v = q)\n 2. \\<And>S x v q.\n       \\<lbrakk>\\<not> subset_memb x S; nfa_is_node A x;\n        subset_invariant A S;\n        \\<And>v q.\n           nfa_is_node A q \\<Longrightarrow>\n           (bdd_lookup (fst S) q = Some v) =\n           (v < length (snd S) \\<and> snd S ! v = q);\n        nfa_is_node A q\\<rbrakk>\n       \\<Longrightarrow> (bdd_lookup (fst (subset_ins x S)) q = Some v) =\n                         (v < length (snd (subset_ins x S)) \\<and>\n                          snd (subset_ins x S) ! v = q)", "{"], ["proof (state)\nthis:\n  S = (bd1, l1)\n\ngoal (2 subgoals):\n 1. \\<And>v q.\n       nfa_is_node A q \\<Longrightarrow>\n       (bdd_lookup (fst subset_empt) q = Some v) =\n       (v < length (snd subset_empt) \\<and> snd subset_empt ! v = q)\n 2. \\<And>S x v q.\n       \\<lbrakk>\\<not> subset_memb x S; nfa_is_node A x;\n        subset_invariant A S;\n        \\<And>v q.\n           nfa_is_node A q \\<Longrightarrow>\n           (bdd_lookup (fst S) q = Some v) =\n           (v < length (snd S) \\<and> snd S ! v = q);\n        nfa_is_node A q\\<rbrakk>\n       \\<Longrightarrow> (bdd_lookup (fst (subset_ins x S)) q = Some v) =\n                         (v < length (snd (subset_ins x S)) \\<and>\n                          snd (subset_ins x S) ! v = q)", "assume \"x \\<in> set l1\""], ["proof (state)\nthis:\n  x \\<in> set l1\n\ngoal (2 subgoals):\n 1. \\<And>v q.\n       nfa_is_node A q \\<Longrightarrow>\n       (bdd_lookup (fst subset_empt) q = Some v) =\n       (v < length (snd subset_empt) \\<and> snd subset_empt ! v = q)\n 2. \\<And>S x v q.\n       \\<lbrakk>\\<not> subset_memb x S; nfa_is_node A x;\n        subset_invariant A S;\n        \\<And>v q.\n           nfa_is_node A q \\<Longrightarrow>\n           (bdd_lookup (fst S) q = Some v) =\n           (v < length (snd S) \\<and> snd S ! v = q);\n        nfa_is_node A q\\<rbrakk>\n       \\<Longrightarrow> (bdd_lookup (fst (subset_ins x S)) q = Some v) =\n                         (v < length (snd (subset_ins x S)) \\<and>\n                          snd (subset_ins x S) ! v = q)", "hence \"list_ex (\\<lambda>l. l = x) l1\""], ["proof (prove)\nusing this:\n  x \\<in> set l1\n\ngoal (1 subgoal):\n 1. list_ex (\\<lambda>l. l = x) l1", "by (simp add: list_ex_iff)"], ["proof (state)\nthis:\n  list_ex (\\<lambda>l. l = x) l1\n\ngoal (2 subgoals):\n 1. \\<And>v q.\n       nfa_is_node A q \\<Longrightarrow>\n       (bdd_lookup (fst subset_empt) q = Some v) =\n       (v < length (snd subset_empt) \\<and> snd subset_empt ! v = q)\n 2. \\<And>S x v q.\n       \\<lbrakk>\\<not> subset_memb x S; nfa_is_node A x;\n        subset_invariant A S;\n        \\<And>v q.\n           nfa_is_node A q \\<Longrightarrow>\n           (bdd_lookup (fst S) q = Some v) =\n           (v < length (snd S) \\<and> snd S ! v = q);\n        nfa_is_node A q\\<rbrakk>\n       \\<Longrightarrow> (bdd_lookup (fst (subset_ins x S)) q = Some v) =\n                         (v < length (snd (subset_ins x S)) \\<and>\n                          snd (subset_ins x S) ! v = q)", "hence \"\\<exists>i < length l1. l1 ! i = x\""], ["proof (prove)\nusing this:\n  list_ex (\\<lambda>l. l = x) l1\n\ngoal (1 subgoal):\n 1. \\<exists>i<length l1. l1 ! i = x", "by (simp add: list_ex_length)"], ["proof (state)\nthis:\n  \\<exists>i<length l1. l1 ! i = x\n\ngoal (2 subgoals):\n 1. \\<And>v q.\n       nfa_is_node A q \\<Longrightarrow>\n       (bdd_lookup (fst subset_empt) q = Some v) =\n       (v < length (snd subset_empt) \\<and> snd subset_empt ! v = q)\n 2. \\<And>S x v q.\n       \\<lbrakk>\\<not> subset_memb x S; nfa_is_node A x;\n        subset_invariant A S;\n        \\<And>v q.\n           nfa_is_node A q \\<Longrightarrow>\n           (bdd_lookup (fst S) q = Some v) =\n           (v < length (snd S) \\<and> snd S ! v = q);\n        nfa_is_node A q\\<rbrakk>\n       \\<Longrightarrow> (bdd_lookup (fst (subset_ins x S)) q = Some v) =\n                         (v < length (snd (subset_ins x S)) \\<and>\n                          snd (subset_ins x S) ! v = q)", "then"], ["proof (chain)\npicking this:\n  \\<exists>i<length l1. l1 ! i = x", "obtain i where \"i < length l1 \\<and> l1 ! i = x\""], ["proof (prove)\nusing this:\n  \\<exists>i<length l1. l1 ! i = x\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        i < length l1 \\<and> l1 ! i = x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  i < length l1 \\<and> l1 ! i = x\n\ngoal (2 subgoals):\n 1. \\<And>v q.\n       nfa_is_node A q \\<Longrightarrow>\n       (bdd_lookup (fst subset_empt) q = Some v) =\n       (v < length (snd subset_empt) \\<and> snd subset_empt ! v = q)\n 2. \\<And>S x v q.\n       \\<lbrakk>\\<not> subset_memb x S; nfa_is_node A x;\n        subset_invariant A S;\n        \\<And>v q.\n           nfa_is_node A q \\<Longrightarrow>\n           (bdd_lookup (fst S) q = Some v) =\n           (v < length (snd S) \\<and> snd S ! v = q);\n        nfa_is_node A q\\<rbrakk>\n       \\<Longrightarrow> (bdd_lookup (fst (subset_ins x S)) q = Some v) =\n                         (v < length (snd (subset_ins x S)) \\<and>\n                          snd (subset_ins x S) ! v = q)", "with step S"], ["proof (chain)\npicking this:\n  \\<not> subset_memb x S\n  nfa_is_node A x\n  subset_invariant A S\n  nfa_is_node A ?q \\<Longrightarrow>\n  (bdd_lookup (fst S) ?q = Some ?v) =\n  (?v < length (snd S) \\<and> snd S ! ?v = ?q)\n  nfa_is_node A qq\n  S = (bd1, l1)\n  i < length l1 \\<and> l1 ! i = x", "have \"bdd_lookup bd1 x = Some i\""], ["proof (prove)\nusing this:\n  \\<not> subset_memb x S\n  nfa_is_node A x\n  subset_invariant A S\n  nfa_is_node A ?q \\<Longrightarrow>\n  (bdd_lookup (fst S) ?q = Some ?v) =\n  (?v < length (snd S) \\<and> snd S ! ?v = ?q)\n  nfa_is_node A qq\n  S = (bd1, l1)\n  i < length l1 \\<and> l1 ! i = x\n\ngoal (1 subgoal):\n 1. bdd_lookup bd1 x = Some i", "by (simp add: nfa_is_node_def)"], ["proof (state)\nthis:\n  bdd_lookup bd1 x = Some i\n\ngoal (2 subgoals):\n 1. \\<And>v q.\n       nfa_is_node A q \\<Longrightarrow>\n       (bdd_lookup (fst subset_empt) q = Some v) =\n       (v < length (snd subset_empt) \\<and> snd subset_empt ! v = q)\n 2. \\<And>S x v q.\n       \\<lbrakk>\\<not> subset_memb x S; nfa_is_node A x;\n        subset_invariant A S;\n        \\<And>v q.\n           nfa_is_node A q \\<Longrightarrow>\n           (bdd_lookup (fst S) q = Some v) =\n           (v < length (snd S) \\<and> snd S ! v = q);\n        nfa_is_node A q\\<rbrakk>\n       \\<Longrightarrow> (bdd_lookup (fst (subset_ins x S)) q = Some v) =\n                         (v < length (snd (subset_ins x S)) \\<and>\n                          snd (subset_ins x S) ! v = q)", "with step S"], ["proof (chain)\npicking this:\n  \\<not> subset_memb x S\n  nfa_is_node A x\n  subset_invariant A S\n  nfa_is_node A ?q \\<Longrightarrow>\n  (bdd_lookup (fst S) ?q = Some ?v) =\n  (?v < length (snd S) \\<and> snd S ! ?v = ?q)\n  nfa_is_node A qq\n  S = (bd1, l1)\n  bdd_lookup bd1 x = Some i", "have \"False\""], ["proof (prove)\nusing this:\n  \\<not> subset_memb x S\n  nfa_is_node A x\n  subset_invariant A S\n  nfa_is_node A ?q \\<Longrightarrow>\n  (bdd_lookup (fst S) ?q = Some ?v) =\n  (?v < length (snd S) \\<and> snd S ! ?v = ?q)\n  nfa_is_node A qq\n  S = (bd1, l1)\n  bdd_lookup bd1 x = Some i\n\ngoal (1 subgoal):\n 1. False", "by (simp add: subset_memb_def)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>v q.\n       nfa_is_node A q \\<Longrightarrow>\n       (bdd_lookup (fst subset_empt) q = Some v) =\n       (v < length (snd subset_empt) \\<and> snd subset_empt ! v = q)\n 2. \\<And>S x v q.\n       \\<lbrakk>\\<not> subset_memb x S; nfa_is_node A x;\n        subset_invariant A S;\n        \\<And>v q.\n           nfa_is_node A q \\<Longrightarrow>\n           (bdd_lookup (fst S) q = Some v) =\n           (v < length (snd S) \\<and> snd S ! v = q);\n        nfa_is_node A q\\<rbrakk>\n       \\<Longrightarrow> (bdd_lookup (fst (subset_ins x S)) q = Some v) =\n                         (v < length (snd (subset_ins x S)) \\<and>\n                          snd (subset_ins x S) ! v = q)", "}"], ["proof (state)\nthis:\n  x \\<in> set l1 \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. \\<And>v q.\n       nfa_is_node A q \\<Longrightarrow>\n       (bdd_lookup (fst subset_empt) q = Some v) =\n       (v < length (snd subset_empt) \\<and> snd subset_empt ! v = q)\n 2. \\<And>S x v q.\n       \\<lbrakk>\\<not> subset_memb x S; nfa_is_node A x;\n        subset_invariant A S;\n        \\<And>v q.\n           nfa_is_node A q \\<Longrightarrow>\n           (bdd_lookup (fst S) q = Some v) =\n           (v < length (snd S) \\<and> snd S ! v = q);\n        nfa_is_node A q\\<rbrakk>\n       \\<Longrightarrow> (bdd_lookup (fst (subset_ins x S)) q = Some v) =\n                         (v < length (snd (subset_ins x S)) \\<and>\n                          snd (subset_ins x S) ! v = q)", "hence X: \"\\<forall>i < length l1. l1 ! i \\<noteq> x\""], ["proof (prove)\nusing this:\n  x \\<in> set l1 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<forall>i<length l1. l1 ! i \\<noteq> x", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<length l1. l1 ! i \\<noteq> x\n\ngoal (2 subgoals):\n 1. \\<And>v q.\n       nfa_is_node A q \\<Longrightarrow>\n       (bdd_lookup (fst subset_empt) q = Some v) =\n       (v < length (snd subset_empt) \\<and> snd subset_empt ! v = q)\n 2. \\<And>S x v q.\n       \\<lbrakk>\\<not> subset_memb x S; nfa_is_node A x;\n        subset_invariant A S;\n        \\<And>v q.\n           nfa_is_node A q \\<Longrightarrow>\n           (bdd_lookup (fst S) q = Some v) =\n           (v < length (snd S) \\<and> snd S ! v = q);\n        nfa_is_node A q\\<rbrakk>\n       \\<Longrightarrow> (bdd_lookup (fst (subset_ins x S)) q = Some v) =\n                         (v < length (snd (subset_ins x S)) \\<and>\n                          snd (subset_ins x S) ! v = q)", "obtain bd2 l2 where S2: \"subset_ins x S = (bd2, l2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>bd2 l2.\n        subset_ins x S = (bd2, l2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"subset_ins x S\") blast+"], ["proof (state)\nthis:\n  subset_ins x S = (bd2, l2)\n\ngoal (2 subgoals):\n 1. \\<And>v q.\n       nfa_is_node A q \\<Longrightarrow>\n       (bdd_lookup (fst subset_empt) q = Some v) =\n       (v < length (snd subset_empt) \\<and> snd subset_empt ! v = q)\n 2. \\<And>S x v q.\n       \\<lbrakk>\\<not> subset_memb x S; nfa_is_node A x;\n        subset_invariant A S;\n        \\<And>v q.\n           nfa_is_node A q \\<Longrightarrow>\n           (bdd_lookup (fst S) q = Some v) =\n           (v < length (snd S) \\<and> snd S ! v = q);\n        nfa_is_node A q\\<rbrakk>\n       \\<Longrightarrow> (bdd_lookup (fst (subset_ins x S)) q = Some v) =\n                         (v < length (snd (subset_ins x S)) \\<and>\n                          snd (subset_ins x S) ! v = q)", "with S"], ["proof (chain)\npicking this:\n  S = (bd1, l1)\n  subset_ins x S = (bd2, l2)", "have SS: \"bd2 = bddinsert bd1 x (Some (length l1))\" \"l2 = l1 @ [x]\""], ["proof (prove)\nusing this:\n  S = (bd1, l1)\n  subset_ins x S = (bd2, l2)\n\ngoal (1 subgoal):\n 1. bd2 = bddinsert bd1 x (Some (length l1)) &&& l2 = l1 @ [x]", "by (simp add: subset_ins_def)+"], ["proof (state)\nthis:\n  bd2 = bddinsert bd1 x (Some (length l1))\n  l2 = l1 @ [x]\n\ngoal (2 subgoals):\n 1. \\<And>v q.\n       nfa_is_node A q \\<Longrightarrow>\n       (bdd_lookup (fst subset_empt) q = Some v) =\n       (v < length (snd subset_empt) \\<and> snd subset_empt ! v = q)\n 2. \\<And>S x v q.\n       \\<lbrakk>\\<not> subset_memb x S; nfa_is_node A x;\n        subset_invariant A S;\n        \\<And>v q.\n           nfa_is_node A q \\<Longrightarrow>\n           (bdd_lookup (fst S) q = Some v) =\n           (v < length (snd S) \\<and> snd S ! v = q);\n        nfa_is_node A q\\<rbrakk>\n       \\<Longrightarrow> (bdd_lookup (fst (subset_ins x S)) q = Some v) =\n                         (v < length (snd (subset_ins x S)) \\<and>\n                          snd (subset_ins x S) ! v = q)", "from step S H1"], ["proof (chain)\npicking this:\n  \\<not> subset_memb x S\n  nfa_is_node A x\n  subset_invariant A S\n  nfa_is_node A ?q \\<Longrightarrow>\n  (bdd_lookup (fst S) ?q = Some ?v) =\n  (?v < length (snd S) \\<and> snd S ! ?v = ?q)\n  nfa_is_node A qq\n  S = (bd1, l1)\n  nfa_is_node A q", "have \"bdd_lookup (bddinsert bd1 x (Some (length l1))) qq = (if x = qq then Some (length l1) else bdd_lookup bd1 qq)\""], ["proof (prove)\nusing this:\n  \\<not> subset_memb x S\n  nfa_is_node A x\n  subset_invariant A S\n  nfa_is_node A ?q \\<Longrightarrow>\n  (bdd_lookup (fst S) ?q = Some ?v) =\n  (?v < length (snd S) \\<and> snd S ! ?v = ?q)\n  nfa_is_node A qq\n  S = (bd1, l1)\n  nfa_is_node A q\n\ngoal (1 subgoal):\n 1. bdd_lookup (bddinsert bd1 x (Some (length l1))) qq =\n    (if x = qq then Some (length l1) else bdd_lookup bd1 qq)", "by (simp add: bdd_lookup_bddinsert subset_invariant_def nfa_is_node_def)"], ["proof (state)\nthis:\n  bdd_lookup (bddinsert bd1 x (Some (length l1))) qq =\n  (if x = qq then Some (length l1) else bdd_lookup bd1 qq)\n\ngoal (2 subgoals):\n 1. \\<And>v q.\n       nfa_is_node A q \\<Longrightarrow>\n       (bdd_lookup (fst subset_empt) q = Some v) =\n       (v < length (snd subset_empt) \\<and> snd subset_empt ! v = q)\n 2. \\<And>S x v q.\n       \\<lbrakk>\\<not> subset_memb x S; nfa_is_node A x;\n        subset_invariant A S;\n        \\<And>v q.\n           nfa_is_node A q \\<Longrightarrow>\n           (bdd_lookup (fst S) q = Some v) =\n           (v < length (snd S) \\<and> snd S ! v = q);\n        nfa_is_node A q\\<rbrakk>\n       \\<Longrightarrow> (bdd_lookup (fst (subset_ins x S)) q = Some v) =\n                         (v < length (snd (subset_ins x S)) \\<and>\n                          snd (subset_ins x S) ! v = q)", "with SS"], ["proof (chain)\npicking this:\n  bd2 = bddinsert bd1 x (Some (length l1))\n  l2 = l1 @ [x]\n  bdd_lookup (bddinsert bd1 x (Some (length l1))) qq =\n  (if x = qq then Some (length l1) else bdd_lookup bd1 qq)", "have \"(bdd_lookup bd2 qq = Some vv) = (if x = qq then length l1 = vv else bdd_lookup bd1 qq = Some vv)\""], ["proof (prove)\nusing this:\n  bd2 = bddinsert bd1 x (Some (length l1))\n  l2 = l1 @ [x]\n  bdd_lookup (bddinsert bd1 x (Some (length l1))) qq =\n  (if x = qq then Some (length l1) else bdd_lookup bd1 qq)\n\ngoal (1 subgoal):\n 1. (bdd_lookup bd2 qq = Some vv) =\n    (if x = qq then length l1 = vv else bdd_lookup bd1 qq = Some vv)", "by simp"], ["proof (state)\nthis:\n  (bdd_lookup bd2 qq = Some vv) =\n  (if x = qq then length l1 = vv else bdd_lookup bd1 qq = Some vv)\n\ngoal (2 subgoals):\n 1. \\<And>v q.\n       nfa_is_node A q \\<Longrightarrow>\n       (bdd_lookup (fst subset_empt) q = Some v) =\n       (v < length (snd subset_empt) \\<and> snd subset_empt ! v = q)\n 2. \\<And>S x v q.\n       \\<lbrakk>\\<not> subset_memb x S; nfa_is_node A x;\n        subset_invariant A S;\n        \\<And>v q.\n           nfa_is_node A q \\<Longrightarrow>\n           (bdd_lookup (fst S) q = Some v) =\n           (v < length (snd S) \\<and> snd S ! v = q);\n        nfa_is_node A q\\<rbrakk>\n       \\<Longrightarrow> (bdd_lookup (fst (subset_ins x S)) q = Some v) =\n                         (v < length (snd (subset_ins x S)) \\<and>\n                          snd (subset_ins x S) ! v = q)", "also"], ["proof (state)\nthis:\n  (bdd_lookup bd2 qq = Some vv) =\n  (if x = qq then length l1 = vv else bdd_lookup bd1 qq = Some vv)\n\ngoal (2 subgoals):\n 1. \\<And>v q.\n       nfa_is_node A q \\<Longrightarrow>\n       (bdd_lookup (fst subset_empt) q = Some v) =\n       (v < length (snd subset_empt) \\<and> snd subset_empt ! v = q)\n 2. \\<And>S x v q.\n       \\<lbrakk>\\<not> subset_memb x S; nfa_is_node A x;\n        subset_invariant A S;\n        \\<And>v q.\n           nfa_is_node A q \\<Longrightarrow>\n           (bdd_lookup (fst S) q = Some v) =\n           (v < length (snd S) \\<and> snd S ! v = q);\n        nfa_is_node A q\\<rbrakk>\n       \\<Longrightarrow> (bdd_lookup (fst (subset_ins x S)) q = Some v) =\n                         (v < length (snd (subset_ins x S)) \\<and>\n                          snd (subset_ins x S) ! v = q)", "have \"\\<dots> = (x = qq \\<and> length l1 = vv \\<or> x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x = qq then length l1 = vv else bdd_lookup bd1 qq = Some vv) =\n    (x = qq \\<and> length l1 = vv \\<or>\n     x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv)", "by auto"], ["proof (state)\nthis:\n  (if x = qq then length l1 = vv else bdd_lookup bd1 qq = Some vv) =\n  (x = qq \\<and> length l1 = vv \\<or>\n   x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv)\n\ngoal (2 subgoals):\n 1. \\<And>v q.\n       nfa_is_node A q \\<Longrightarrow>\n       (bdd_lookup (fst subset_empt) q = Some v) =\n       (v < length (snd subset_empt) \\<and> snd subset_empt ! v = q)\n 2. \\<And>S x v q.\n       \\<lbrakk>\\<not> subset_memb x S; nfa_is_node A x;\n        subset_invariant A S;\n        \\<And>v q.\n           nfa_is_node A q \\<Longrightarrow>\n           (bdd_lookup (fst S) q = Some v) =\n           (v < length (snd S) \\<and> snd S ! v = q);\n        nfa_is_node A q\\<rbrakk>\n       \\<Longrightarrow> (bdd_lookup (fst (subset_ins x S)) q = Some v) =\n                         (v < length (snd (subset_ins x S)) \\<and>\n                          snd (subset_ins x S) ! v = q)", "also"], ["proof (state)\nthis:\n  (if x = qq then length l1 = vv else bdd_lookup bd1 qq = Some vv) =\n  (x = qq \\<and> length l1 = vv \\<or>\n   x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv)\n\ngoal (2 subgoals):\n 1. \\<And>v q.\n       nfa_is_node A q \\<Longrightarrow>\n       (bdd_lookup (fst subset_empt) q = Some v) =\n       (v < length (snd subset_empt) \\<and> snd subset_empt ! v = q)\n 2. \\<And>S x v q.\n       \\<lbrakk>\\<not> subset_memb x S; nfa_is_node A x;\n        subset_invariant A S;\n        \\<And>v q.\n           nfa_is_node A q \\<Longrightarrow>\n           (bdd_lookup (fst S) q = Some v) =\n           (v < length (snd S) \\<and> snd S ! v = q);\n        nfa_is_node A q\\<rbrakk>\n       \\<Longrightarrow> (bdd_lookup (fst (subset_ins x S)) q = Some v) =\n                         (v < length (snd (subset_ins x S)) \\<and>\n                          snd (subset_ins x S) ! v = q)", "have \"\\<dots> = (vv < length l2 \\<and> l2 ! vv = qq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = qq \\<and> length l1 = vv \\<or>\n     x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv) =\n    (vv < length l2 \\<and> l2 ! vv = qq)", "proof (cases \"x = qq\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = qq \\<Longrightarrow>\n    (x = qq \\<and> length l1 = vv \\<or>\n     x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv) =\n    (vv < length l2 \\<and> l2 ! vv = qq)\n 2. x \\<noteq> qq \\<Longrightarrow>\n    (x = qq \\<and> length l1 = vv \\<or>\n     x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv) =\n    (vv < length l2 \\<and> l2 ! vv = qq)", "case True"], ["proof (state)\nthis:\n  x = qq\n\ngoal (2 subgoals):\n 1. x = qq \\<Longrightarrow>\n    (x = qq \\<and> length l1 = vv \\<or>\n     x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv) =\n    (vv < length l2 \\<and> l2 ! vv = qq)\n 2. x \\<noteq> qq \\<Longrightarrow>\n    (x = qq \\<and> length l1 = vv \\<or>\n     x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv) =\n    (vv < length l2 \\<and> l2 ! vv = qq)", "hence \"(x = qq \\<and> length l1 = vv \\<or> x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv) = (x = qq \\<and> length l1 = vv)\""], ["proof (prove)\nusing this:\n  x = qq\n\ngoal (1 subgoal):\n 1. (x = qq \\<and> length l1 = vv \\<or>\n     x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv) =\n    (x = qq \\<and> length l1 = vv)", "by simp"], ["proof (state)\nthis:\n  (x = qq \\<and> length l1 = vv \\<or>\n   x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv) =\n  (x = qq \\<and> length l1 = vv)\n\ngoal (2 subgoals):\n 1. x = qq \\<Longrightarrow>\n    (x = qq \\<and> length l1 = vv \\<or>\n     x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv) =\n    (vv < length l2 \\<and> l2 ! vv = qq)\n 2. x \\<noteq> qq \\<Longrightarrow>\n    (x = qq \\<and> length l1 = vv \\<or>\n     x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv) =\n    (vv < length l2 \\<and> l2 ! vv = qq)", "also"], ["proof (state)\nthis:\n  (x = qq \\<and> length l1 = vv \\<or>\n   x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv) =\n  (x = qq \\<and> length l1 = vv)\n\ngoal (2 subgoals):\n 1. x = qq \\<Longrightarrow>\n    (x = qq \\<and> length l1 = vv \\<or>\n     x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv) =\n    (vv < length l2 \\<and> l2 ! vv = qq)\n 2. x \\<noteq> qq \\<Longrightarrow>\n    (x = qq \\<and> length l1 = vv \\<or>\n     x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv) =\n    (vv < length l2 \\<and> l2 ! vv = qq)", "have \"\\<dots> = (vv < length l2 \\<and> l2 ! vv = qq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = qq \\<and> length l1 = vv) = (vv < length l2 \\<and> l2 ! vv = qq)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x = qq \\<and> length l1 = vv \\<Longrightarrow>\n    vv < length l2 \\<and> l2 ! vv = qq\n 2. vv < length l2 \\<and> l2 ! vv = qq \\<Longrightarrow>\n    x = qq \\<and> length l1 = vv", "assume H: \"vv < length l2 \\<and> l2 ! vv = qq\""], ["proof (state)\nthis:\n  vv < length l2 \\<and> l2 ! vv = qq\n\ngoal (2 subgoals):\n 1. x = qq \\<and> length l1 = vv \\<Longrightarrow>\n    vv < length l2 \\<and> l2 ! vv = qq\n 2. vv < length l2 \\<and> l2 ! vv = qq \\<Longrightarrow>\n    x = qq \\<and> length l1 = vv", "show \"x = qq \\<and> length l1 = vv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = qq \\<and> length l1 = vv", "proof (cases \"vv = length l1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. vv = length l1 \\<Longrightarrow> x = qq \\<and> length l1 = vv\n 2. vv \\<noteq> length l1 \\<Longrightarrow> x = qq \\<and> length l1 = vv", "case False"], ["proof (state)\nthis:\n  vv \\<noteq> length l1\n\ngoal (2 subgoals):\n 1. vv = length l1 \\<Longrightarrow> x = qq \\<and> length l1 = vv\n 2. vv \\<noteq> length l1 \\<Longrightarrow> x = qq \\<and> length l1 = vv", "with H SS"], ["proof (chain)\npicking this:\n  vv < length l2 \\<and> l2 ! vv = qq\n  bd2 = bddinsert bd1 x (Some (length l1))\n  l2 = l1 @ [x]\n  vv \\<noteq> length l1", "have \"vv < length l1\""], ["proof (prove)\nusing this:\n  vv < length l2 \\<and> l2 ! vv = qq\n  bd2 = bddinsert bd1 x (Some (length l1))\n  l2 = l1 @ [x]\n  vv \\<noteq> length l1\n\ngoal (1 subgoal):\n 1. vv < length l1", "by simp"], ["proof (state)\nthis:\n  vv < length l1\n\ngoal (2 subgoals):\n 1. vv = length l1 \\<Longrightarrow> x = qq \\<and> length l1 = vv\n 2. vv \\<noteq> length l1 \\<Longrightarrow> x = qq \\<and> length l1 = vv", "with SS"], ["proof (chain)\npicking this:\n  bd2 = bddinsert bd1 x (Some (length l1))\n  l2 = l1 @ [x]\n  vv < length l1", "have \"l2 ! vv = l1 ! vv\""], ["proof (prove)\nusing this:\n  bd2 = bddinsert bd1 x (Some (length l1))\n  l2 = l1 @ [x]\n  vv < length l1\n\ngoal (1 subgoal):\n 1. l2 ! vv = l1 ! vv", "by (simp add: nth_append)"], ["proof (state)\nthis:\n  l2 ! vv = l1 ! vv\n\ngoal (2 subgoals):\n 1. vv = length l1 \\<Longrightarrow> x = qq \\<and> length l1 = vv\n 2. vv \\<noteq> length l1 \\<Longrightarrow> x = qq \\<and> length l1 = vv", "with False H SS \\<open>x = qq\\<close>"], ["proof (chain)\npicking this:\n  vv \\<noteq> length l1\n  vv < length l2 \\<and> l2 ! vv = qq\n  bd2 = bddinsert bd1 x (Some (length l1))\n  l2 = l1 @ [x]\n  x = qq\n  l2 ! vv = l1 ! vv", "have \"vv < length l1 \\<and> l1 ! vv = x\""], ["proof (prove)\nusing this:\n  vv \\<noteq> length l1\n  vv < length l2 \\<and> l2 ! vv = qq\n  bd2 = bddinsert bd1 x (Some (length l1))\n  l2 = l1 @ [x]\n  x = qq\n  l2 ! vv = l1 ! vv\n\ngoal (1 subgoal):\n 1. vv < length l1 \\<and> l1 ! vv = x", "by auto"], ["proof (state)\nthis:\n  vv < length l1 \\<and> l1 ! vv = x\n\ngoal (2 subgoals):\n 1. vv = length l1 \\<Longrightarrow> x = qq \\<and> length l1 = vv\n 2. vv \\<noteq> length l1 \\<Longrightarrow> x = qq \\<and> length l1 = vv", "with X"], ["proof (chain)\npicking this:\n  \\<forall>i<length l1. l1 ! i \\<noteq> x\n  vv < length l1 \\<and> l1 ! vv = x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i<length l1. l1 ! i \\<noteq> x\n  vv < length l1 \\<and> l1 ! vv = x\n\ngoal (1 subgoal):\n 1. x = qq \\<and> length l1 = vv", "by auto"], ["proof (state)\nthis:\n  x = qq \\<and> length l1 = vv\n\ngoal (1 subgoal):\n 1. vv = length l1 \\<Longrightarrow> x = qq \\<and> length l1 = vv", "qed (simp add: True)"], ["proof (state)\nthis:\n  x = qq \\<and> length l1 = vv\n\ngoal (1 subgoal):\n 1. x = qq \\<and> length l1 = vv \\<Longrightarrow>\n    vv < length l2 \\<and> l2 ! vv = qq", "qed (auto simp: SS)"], ["proof (state)\nthis:\n  (x = qq \\<and> length l1 = vv) = (vv < length l2 \\<and> l2 ! vv = qq)\n\ngoal (2 subgoals):\n 1. x = qq \\<Longrightarrow>\n    (x = qq \\<and> length l1 = vv \\<or>\n     x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv) =\n    (vv < length l2 \\<and> l2 ! vv = qq)\n 2. x \\<noteq> qq \\<Longrightarrow>\n    (x = qq \\<and> length l1 = vv \\<or>\n     x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv) =\n    (vv < length l2 \\<and> l2 ! vv = qq)", "finally"], ["proof (chain)\npicking this:\n  (x = qq \\<and> length l1 = vv \\<or>\n   x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv) =\n  (vv < length l2 \\<and> l2 ! vv = qq)", "show ?thesis"], ["proof (prove)\nusing this:\n  (x = qq \\<and> length l1 = vv \\<or>\n   x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv) =\n  (vv < length l2 \\<and> l2 ! vv = qq)\n\ngoal (1 subgoal):\n 1. (x = qq \\<and> length l1 = vv \\<or>\n     x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv) =\n    (vv < length l2 \\<and> l2 ! vv = qq)", "."], ["proof (state)\nthis:\n  (x = qq \\<and> length l1 = vv \\<or>\n   x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv) =\n  (vv < length l2 \\<and> l2 ! vv = qq)\n\ngoal (1 subgoal):\n 1. x \\<noteq> qq \\<Longrightarrow>\n    (x = qq \\<and> length l1 = vv \\<or>\n     x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv) =\n    (vv < length l2 \\<and> l2 ! vv = qq)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> qq \\<Longrightarrow>\n    (x = qq \\<and> length l1 = vv \\<or>\n     x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv) =\n    (vv < length l2 \\<and> l2 ! vv = qq)", "case False"], ["proof (state)\nthis:\n  x \\<noteq> qq\n\ngoal (1 subgoal):\n 1. x \\<noteq> qq \\<Longrightarrow>\n    (x = qq \\<and> length l1 = vv \\<or>\n     x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv) =\n    (vv < length l2 \\<and> l2 ! vv = qq)", "hence \"(x = qq \\<and> length l1 = vv \\<or> x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv) = (x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv)\""], ["proof (prove)\nusing this:\n  x \\<noteq> qq\n\ngoal (1 subgoal):\n 1. (x = qq \\<and> length l1 = vv \\<or>\n     x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv) =\n    (x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv)", "by simp"], ["proof (state)\nthis:\n  (x = qq \\<and> length l1 = vv \\<or>\n   x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv) =\n  (x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv)\n\ngoal (1 subgoal):\n 1. x \\<noteq> qq \\<Longrightarrow>\n    (x = qq \\<and> length l1 = vv \\<or>\n     x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv) =\n    (vv < length l2 \\<and> l2 ! vv = qq)", "also"], ["proof (state)\nthis:\n  (x = qq \\<and> length l1 = vv \\<or>\n   x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv) =\n  (x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv)\n\ngoal (1 subgoal):\n 1. x \\<noteq> qq \\<Longrightarrow>\n    (x = qq \\<and> length l1 = vv \\<or>\n     x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv) =\n    (vv < length l2 \\<and> l2 ! vv = qq)", "from step(4,5) S \\<open>x\\<noteq>qq\\<close>"], ["proof (chain)\npicking this:\n  nfa_is_node A ?q \\<Longrightarrow>\n  (bdd_lookup (fst S) ?q = Some ?v) =\n  (?v < length (snd S) \\<and> snd S ! ?v = ?q)\n  nfa_is_node A qq\n  S = (bd1, l1)\n  x \\<noteq> qq", "have \"\\<dots> = (vv < length l1 \\<and> l1 ! vv = qq)\""], ["proof (prove)\nusing this:\n  nfa_is_node A ?q \\<Longrightarrow>\n  (bdd_lookup (fst S) ?q = Some ?v) =\n  (?v < length (snd S) \\<and> snd S ! ?v = ?q)\n  nfa_is_node A qq\n  S = (bd1, l1)\n  x \\<noteq> qq\n\ngoal (1 subgoal):\n 1. (x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv) =\n    (vv < length l1 \\<and> l1 ! vv = qq)", "by simp"], ["proof (state)\nthis:\n  (x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv) =\n  (vv < length l1 \\<and> l1 ! vv = qq)\n\ngoal (1 subgoal):\n 1. x \\<noteq> qq \\<Longrightarrow>\n    (x = qq \\<and> length l1 = vv \\<or>\n     x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv) =\n    (vv < length l2 \\<and> l2 ! vv = qq)", "also"], ["proof (state)\nthis:\n  (x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv) =\n  (vv < length l1 \\<and> l1 ! vv = qq)\n\ngoal (1 subgoal):\n 1. x \\<noteq> qq \\<Longrightarrow>\n    (x = qq \\<and> length l1 = vv \\<or>\n     x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv) =\n    (vv < length l2 \\<and> l2 ! vv = qq)", "from SS \\<open>x\\<noteq>qq\\<close>"], ["proof (chain)\npicking this:\n  bd2 = bddinsert bd1 x (Some (length l1))\n  l2 = l1 @ [x]\n  x \\<noteq> qq", "have \"\\<dots> = (vv < length l2 \\<and> l2 ! vv = qq)\""], ["proof (prove)\nusing this:\n  bd2 = bddinsert bd1 x (Some (length l1))\n  l2 = l1 @ [x]\n  x \\<noteq> qq\n\ngoal (1 subgoal):\n 1. (vv < length l1 \\<and> l1 ! vv = qq) =\n    (vv < length l2 \\<and> l2 ! vv = qq)", "by (simp add: nth_append)"], ["proof (state)\nthis:\n  (vv < length l1 \\<and> l1 ! vv = qq) =\n  (vv < length l2 \\<and> l2 ! vv = qq)\n\ngoal (1 subgoal):\n 1. x \\<noteq> qq \\<Longrightarrow>\n    (x = qq \\<and> length l1 = vv \\<or>\n     x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv) =\n    (vv < length l2 \\<and> l2 ! vv = qq)", "finally"], ["proof (chain)\npicking this:\n  (x = qq \\<and> length l1 = vv \\<or>\n   x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv) =\n  (vv < length l2 \\<and> l2 ! vv = qq)", "show ?thesis"], ["proof (prove)\nusing this:\n  (x = qq \\<and> length l1 = vv \\<or>\n   x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv) =\n  (vv < length l2 \\<and> l2 ! vv = qq)\n\ngoal (1 subgoal):\n 1. (x = qq \\<and> length l1 = vv \\<or>\n     x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv) =\n    (vv < length l2 \\<and> l2 ! vv = qq)", "."], ["proof (state)\nthis:\n  (x = qq \\<and> length l1 = vv \\<or>\n   x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv) =\n  (vv < length l2 \\<and> l2 ! vv = qq)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x = qq \\<and> length l1 = vv \\<or>\n   x \\<noteq> qq \\<and> bdd_lookup bd1 qq = Some vv) =\n  (vv < length l2 \\<and> l2 ! vv = qq)\n\ngoal (2 subgoals):\n 1. \\<And>v q.\n       nfa_is_node A q \\<Longrightarrow>\n       (bdd_lookup (fst subset_empt) q = Some v) =\n       (v < length (snd subset_empt) \\<and> snd subset_empt ! v = q)\n 2. \\<And>S x v q.\n       \\<lbrakk>\\<not> subset_memb x S; nfa_is_node A x;\n        subset_invariant A S;\n        \\<And>v q.\n           nfa_is_node A q \\<Longrightarrow>\n           (bdd_lookup (fst S) q = Some v) =\n           (v < length (snd S) \\<and> snd S ! v = q);\n        nfa_is_node A q\\<rbrakk>\n       \\<Longrightarrow> (bdd_lookup (fst (subset_ins x S)) q = Some v) =\n                         (v < length (snd (subset_ins x S)) \\<and>\n                          snd (subset_ins x S) ! v = q)", "finally"], ["proof (chain)\npicking this:\n  (bdd_lookup bd2 qq = Some vv) = (vv < length l2 \\<and> l2 ! vv = qq)", "show ?case"], ["proof (prove)\nusing this:\n  (bdd_lookup bd2 qq = Some vv) = (vv < length l2 \\<and> l2 ! vv = qq)\n\ngoal (1 subgoal):\n 1. (bdd_lookup (fst (subset_ins x S)) qq = Some vv) =\n    (vv < length (snd (subset_ins x S)) \\<and>\n     snd (subset_ins x S) ! vv = qq)", "by (simp add: S2)"], ["proof (state)\nthis:\n  (bdd_lookup (fst (subset_ins x S)) qq = Some vv) =\n  (vv < length (snd (subset_ins x S)) \\<and> snd (subset_ins x S) ! vv = qq)\n\ngoal (1 subgoal):\n 1. \\<And>v q.\n       nfa_is_node A q \\<Longrightarrow>\n       (bdd_lookup (fst subset_empt) q = Some v) =\n       (v < length (snd subset_empt) \\<and> snd subset_empt ! v = q)", "qed (simp add: subset_empt_def)"], ["proof (state)\nthis:\n  (bdd_lookup (fst (subset_dfs A q0)) q = Some v) =\n  (v < length (snd (subset_dfs A q0)) \\<and> snd (subset_dfs A q0) ! v = q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subset_dfs_start:\n  assumes H: \"nfa_is_node A q0\"\n  shows \"bdd_lookup (fst (subset_dfs A q0)) q0 = Some 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_lookup (fst (subset_dfs A q0)) q0 = Some 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bdd_lookup (fst (subset_dfs A q0)) q0 = Some 0", "obtain bd l where S: \"subset_ins q0 subset_empt = (bd, l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>bd l.\n        subset_ins q0 subset_empt = (bd, l) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"subset_ins q0 subset_empt\") blast+"], ["proof (state)\nthis:\n  subset_ins q0 subset_empt = (bd, l)\n\ngoal (1 subgoal):\n 1. bdd_lookup (fst (subset_dfs A q0)) q0 = Some 0", "from H"], ["proof (chain)\npicking this:\n  nfa_is_node A q0", "have \"\\<not> subset_memb q0 subset_empt\""], ["proof (prove)\nusing this:\n  nfa_is_node A q0\n\ngoal (1 subgoal):\n 1. \\<not> subset_memb q0 subset_empt", "by (simp add: empt)"], ["proof (state)\nthis:\n  \\<not> subset_memb q0 subset_empt\n\ngoal (1 subgoal):\n 1. bdd_lookup (fst (subset_dfs A q0)) q0 = Some 0", "with H empt_invariant"], ["proof (chain)\npicking this:\n  nfa_is_node A q0\n  subset_invariant A subset_empt\n  \\<not> subset_memb q0 subset_empt", "have I: \"subset_invariant A (subset_ins q0 subset_empt)\""], ["proof (prove)\nusing this:\n  nfa_is_node A q0\n  subset_invariant A subset_empt\n  \\<not> subset_memb q0 subset_empt\n\ngoal (1 subgoal):\n 1. subset_invariant A (subset_ins q0 subset_empt)", "by (simp add: ins_invariant)"], ["proof (state)\nthis:\n  subset_invariant A (subset_ins q0 subset_empt)\n\ngoal (1 subgoal):\n 1. bdd_lookup (fst (subset_dfs A q0)) q0 = Some 0", "from H"], ["proof (chain)\npicking this:\n  nfa_is_node A q0", "have \"list_all (nfa_is_node A) (subset_succs A q0)\""], ["proof (prove)\nusing this:\n  nfa_is_node A q0\n\ngoal (1 subgoal):\n 1. list_all (nfa_is_node A) (subset_succs A q0)", "by (simp add: succs_is_node)"], ["proof (state)\nthis:\n  list_all (nfa_is_node A) (subset_succs A q0)\n\ngoal (1 subgoal):\n 1. bdd_lookup (fst (subset_dfs A q0)) q0 = Some 0", "with I"], ["proof (chain)\npicking this:\n  subset_invariant A (subset_ins q0 subset_empt)\n  list_all (nfa_is_node A) (subset_succs A q0)", "have \"bdd_lookup (fst (gen_dfs (subset_succs A) subset_ins subset_memb (subset_ins q0 subset_empt) (subset_succs A q0))) q0 = Some 0\""], ["proof (prove)\nusing this:\n  subset_invariant A (subset_ins q0 subset_empt)\n  list_all (nfa_is_node A) (subset_succs A q0)\n\ngoal (1 subgoal):\n 1. bdd_lookup (fst (dfs (subset_ins q0 subset_empt) (subset_succs A q0)))\n     q0 =\n    Some 0", "proof (induct rule: dfs_invariant)"], ["proof (state)\ngoal (2 subgoals):\n 1. bdd_lookup (fst (subset_ins q0 subset_empt)) q0 = Some 0\n 2. \\<And>S x.\n       \\<lbrakk>\\<not> subset_memb x S; nfa_is_node A x;\n        subset_invariant A S; bdd_lookup (fst S) q0 = Some 0\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (fst (subset_ins x S)) q0 = Some 0", "case base"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. bdd_lookup (fst (subset_ins q0 subset_empt)) q0 = Some 0\n 2. \\<And>S x.\n       \\<lbrakk>\\<not> subset_memb x S; nfa_is_node A x;\n        subset_invariant A S; bdd_lookup (fst S) q0 = Some 0\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (fst (subset_ins x S)) q0 = Some 0", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_lookup (fst (subset_ins q0 subset_empt)) q0 = Some 0", "unfolding subset_ins_def subset_empt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_lookup\n     (fst (case (Leaf None, []) of\n           (bdd, qss) \\<Rightarrow>\n             (bddinsert bdd q0 (Some (length qss)), qss @ [q0])))\n     q0 =\n    Some 0", "by (induct q0) simp+"], ["proof (state)\nthis:\n  bdd_lookup (fst (subset_ins q0 subset_empt)) q0 = Some 0\n\ngoal (1 subgoal):\n 1. \\<And>S x.\n       \\<lbrakk>\\<not> subset_memb x S; nfa_is_node A x;\n        subset_invariant A S; bdd_lookup (fst S) q0 = Some 0\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (fst (subset_ins x S)) q0 = Some 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S x.\n       \\<lbrakk>\\<not> subset_memb x S; nfa_is_node A x;\n        subset_invariant A S; bdd_lookup (fst S) q0 = Some 0\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (fst (subset_ins x S)) q0 = Some 0", "case (step S x)"], ["proof (state)\nthis:\n  \\<not> subset_memb x S\n  nfa_is_node A x\n  subset_invariant A S\n  bdd_lookup (fst S) q0 = Some 0\n\ngoal (1 subgoal):\n 1. \\<And>S x.\n       \\<lbrakk>\\<not> subset_memb x S; nfa_is_node A x;\n        subset_invariant A S; bdd_lookup (fst S) q0 = Some 0\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (fst (subset_ins x S)) q0 = Some 0", "hence Q: \"subset_memb q0 S\""], ["proof (prove)\nusing this:\n  \\<not> subset_memb x S\n  nfa_is_node A x\n  subset_invariant A S\n  bdd_lookup (fst S) q0 = Some 0\n\ngoal (1 subgoal):\n 1. subset_memb q0 S", "by (simp add: subset_memb_def split_beta)"], ["proof (state)\nthis:\n  subset_memb q0 S\n\ngoal (1 subgoal):\n 1. \\<And>S x.\n       \\<lbrakk>\\<not> subset_memb x S; nfa_is_node A x;\n        subset_invariant A S; bdd_lookup (fst S) q0 = Some 0\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (fst (subset_ins x S)) q0 = Some 0", "with step"], ["proof (chain)\npicking this:\n  \\<not> subset_memb x S\n  nfa_is_node A x\n  subset_invariant A S\n  bdd_lookup (fst S) q0 = Some 0\n  subset_memb q0 S", "have \"q0 \\<noteq> x\""], ["proof (prove)\nusing this:\n  \\<not> subset_memb x S\n  nfa_is_node A x\n  subset_invariant A S\n  bdd_lookup (fst S) q0 = Some 0\n  subset_memb q0 S\n\ngoal (1 subgoal):\n 1. q0 \\<noteq> x", "by auto"], ["proof (state)\nthis:\n  q0 \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>S x.\n       \\<lbrakk>\\<not> subset_memb x S; nfa_is_node A x;\n        subset_invariant A S; bdd_lookup (fst S) q0 = Some 0\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (fst (subset_ins x S)) q0 = Some 0", "from step"], ["proof (chain)\npicking this:\n  \\<not> subset_memb x S\n  nfa_is_node A x\n  subset_invariant A S\n  bdd_lookup (fst S) q0 = Some 0", "have I: \"bddh (length (fst A)) (fst S)\""], ["proof (prove)\nusing this:\n  \\<not> subset_memb x S\n  nfa_is_node A x\n  subset_invariant A S\n  bdd_lookup (fst S) q0 = Some 0\n\ngoal (1 subgoal):\n 1. bddh (length (fst A)) (fst S)", "by (simp add: subset_invariant_def split_beta)"], ["proof (state)\nthis:\n  bddh (length (fst A)) (fst S)\n\ngoal (1 subgoal):\n 1. \\<And>S x.\n       \\<lbrakk>\\<not> subset_memb x S; nfa_is_node A x;\n        subset_invariant A S; bdd_lookup (fst S) q0 = Some 0\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (fst (subset_ins x S)) q0 = Some 0", "with H step \\<open>q0\\<noteq>x\\<close>"], ["proof (chain)\npicking this:\n  nfa_is_node A q0\n  \\<not> subset_memb x S\n  nfa_is_node A x\n  subset_invariant A S\n  bdd_lookup (fst S) q0 = Some 0\n  q0 \\<noteq> x\n  bddh (length (fst A)) (fst S)", "have V: \"\\<And>v. bdd_lookup (bddinsert (fst S) x v) q0 = bdd_lookup (fst S) q0\""], ["proof (prove)\nusing this:\n  nfa_is_node A q0\n  \\<not> subset_memb x S\n  nfa_is_node A x\n  subset_invariant A S\n  bdd_lookup (fst S) q0 = Some 0\n  q0 \\<noteq> x\n  bddh (length (fst A)) (fst S)\n\ngoal (1 subgoal):\n 1. \\<And>v. bdd_lookup (bddinsert (fst S) x v) q0 = bdd_lookup (fst S) q0", "by (simp add: bdd_lookup_bddinsert nfa_is_node_def)"], ["proof (state)\nthis:\n  bdd_lookup (bddinsert (fst S) x ?v) q0 = bdd_lookup (fst S) q0\n\ngoal (1 subgoal):\n 1. \\<And>S x.\n       \\<lbrakk>\\<not> subset_memb x S; nfa_is_node A x;\n        subset_invariant A S; bdd_lookup (fst S) q0 = Some 0\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (fst (subset_ins x S)) q0 = Some 0", "with step"], ["proof (chain)\npicking this:\n  \\<not> subset_memb x S\n  nfa_is_node A x\n  subset_invariant A S\n  bdd_lookup (fst S) q0 = Some 0\n  bdd_lookup (bddinsert (fst S) x ?v) q0 = bdd_lookup (fst S) q0", "show \"bdd_lookup (fst (subset_ins x S)) q0 = Some 0\""], ["proof (prove)\nusing this:\n  \\<not> subset_memb x S\n  nfa_is_node A x\n  subset_invariant A S\n  bdd_lookup (fst S) q0 = Some 0\n  bdd_lookup (bddinsert (fst S) x ?v) q0 = bdd_lookup (fst S) q0\n\ngoal (1 subgoal):\n 1. bdd_lookup (fst (subset_ins x S)) q0 = Some 0", "by (auto simp: subset_ins_def split_beta)"], ["proof (state)\nthis:\n  bdd_lookup (fst (subset_ins x S)) q0 = Some 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bdd_lookup (fst (dfs (subset_ins q0 subset_empt) (subset_succs A q0)))\n   q0 =\n  Some 0\n\ngoal (1 subgoal):\n 1. bdd_lookup (fst (subset_dfs A q0)) q0 = Some 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  bdd_lookup (fst (dfs (subset_ins q0 subset_empt) (subset_succs A q0)))\n   q0 =\n  Some 0\n\ngoal (1 subgoal):\n 1. bdd_lookup (fst (subset_dfs A q0)) q0 = Some 0", "unfolding subset_dfs_def"], ["proof (prove)\nusing this:\n  bdd_lookup (fst (dfs (subset_ins q0 subset_empt) (subset_succs A q0)))\n   q0 =\n  Some 0\n\ngoal (1 subgoal):\n 1. bdd_lookup (fst (dfs subset_empt [q0])) q0 = Some 0", "by (auto simp: nfa_is_node_def gen_dfs_simps subset_memb_def subset_empt_def)"], ["proof (state)\nthis:\n  bdd_lookup (fst (subset_dfs A q0)) q0 = Some 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subset_dfs_is_node:\n  assumes \"nfa_is_node A q0\"\n  shows \"list_all (nfa_is_node A) (snd (subset_dfs A q0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (nfa_is_node A) (snd (subset_dfs A q0))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all (nfa_is_node A) (snd (subset_dfs A q0))", "from assms"], ["proof (chain)\npicking this:\n  nfa_is_node A q0", "have \"list_all (nfa_is_node A) [q0]\""], ["proof (prove)\nusing this:\n  nfa_is_node A q0\n\ngoal (1 subgoal):\n 1. list_all (nfa_is_node A) [q0]", "by simp"], ["proof (state)\nthis:\n  list_all (nfa_is_node A) [q0]\n\ngoal (1 subgoal):\n 1. list_all (nfa_is_node A) (snd (subset_dfs A q0))", "with empt_invariant"], ["proof (chain)\npicking this:\n  subset_invariant A subset_empt\n  list_all (nfa_is_node A) [q0]", "show ?thesis"], ["proof (prove)\nusing this:\n  subset_invariant A subset_empt\n  list_all (nfa_is_node A) [q0]\n\ngoal (1 subgoal):\n 1. list_all (nfa_is_node A) (snd (subset_dfs A q0))", "unfolding subset_dfs_def"], ["proof (prove)\nusing this:\n  subset_invariant A subset_empt\n  list_all (nfa_is_node A) [q0]\n\ngoal (1 subgoal):\n 1. list_all (nfa_is_node A) (snd (dfs subset_empt [q0]))", "proof (induct rule: dfs_invariant)"], ["proof (state)\ngoal (2 subgoals):\n 1. list_all (nfa_is_node A) (snd subset_empt)\n 2. \\<And>S x.\n       \\<lbrakk>\\<not> subset_memb x S; nfa_is_node A x;\n        subset_invariant A S; list_all (nfa_is_node A) (snd S)\\<rbrakk>\n       \\<Longrightarrow> list_all (nfa_is_node A) (snd (subset_ins x S))", "case base"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. list_all (nfa_is_node A) (snd subset_empt)\n 2. \\<And>S x.\n       \\<lbrakk>\\<not> subset_memb x S; nfa_is_node A x;\n        subset_invariant A S; list_all (nfa_is_node A) (snd S)\\<rbrakk>\n       \\<Longrightarrow> list_all (nfa_is_node A) (snd (subset_ins x S))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (nfa_is_node A) (snd subset_empt)", "by (simp add: subset_empt_def)"], ["proof (state)\nthis:\n  list_all (nfa_is_node A) (snd subset_empt)\n\ngoal (1 subgoal):\n 1. \\<And>S x.\n       \\<lbrakk>\\<not> subset_memb x S; nfa_is_node A x;\n        subset_invariant A S; list_all (nfa_is_node A) (snd S)\\<rbrakk>\n       \\<Longrightarrow> list_all (nfa_is_node A) (snd (subset_ins x S))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S x.\n       \\<lbrakk>\\<not> subset_memb x S; nfa_is_node A x;\n        subset_invariant A S; list_all (nfa_is_node A) (snd S)\\<rbrakk>\n       \\<Longrightarrow> list_all (nfa_is_node A) (snd (subset_ins x S))", "case (step S x)"], ["proof (state)\nthis:\n  \\<not> subset_memb x S\n  nfa_is_node A x\n  subset_invariant A S\n  list_all (nfa_is_node A) (snd S)\n\ngoal (1 subgoal):\n 1. \\<And>S x.\n       \\<lbrakk>\\<not> subset_memb x S; nfa_is_node A x;\n        subset_invariant A S; list_all (nfa_is_node A) (snd S)\\<rbrakk>\n       \\<Longrightarrow> list_all (nfa_is_node A) (snd (subset_ins x S))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<not> subset_memb x S\n  nfa_is_node A x\n  subset_invariant A S\n  list_all (nfa_is_node A) (snd S)\n\ngoal (1 subgoal):\n 1. list_all (nfa_is_node A) (snd (subset_ins x S))", "by (simp add: subset_ins_def split_beta)"], ["proof (state)\nthis:\n  list_all (nfa_is_node A) (snd (subset_ins x S))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_all (nfa_is_node A) (snd (subset_dfs A q0))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_wf_nfa:\n  shows \"wf_dfa (det_nfa A) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "obtain bt ls where BT: \"subset_dfs A (nfa_startnode A) = (bt, ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>bt ls.\n        subset_dfs A (nfa_startnode A) = (bt, ls) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"subset_dfs A (nfa_startnode A)\") auto"], ["proof (state)\nthis:\n  subset_dfs A (nfa_startnode A) = (bt, ls)\n\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "note Q = nfa_startnode_is_node[OF well_formed]"], ["proof (state)\nthis:\n  nfa_is_node A (nfa_startnode A)\n\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "from Q"], ["proof (chain)\npicking this:\n  nfa_is_node A (nfa_startnode A)", "have N:\"list_all (nfa_is_node A) (snd (subset_dfs A (nfa_startnode A)))\""], ["proof (prove)\nusing this:\n  nfa_is_node A (nfa_startnode A)\n\ngoal (1 subgoal):\n 1. list_all (nfa_is_node A) (snd (subset_dfs A (nfa_startnode A)))", "by (simp add: subset_dfs_is_node)"], ["proof (state)\nthis:\n  list_all (nfa_is_node A) (snd (subset_dfs A (nfa_startnode A)))\n\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "with BT"], ["proof (chain)\npicking this:\n  subset_dfs A (nfa_startnode A) = (bt, ls)\n  list_all (nfa_is_node A) (snd (subset_dfs A (nfa_startnode A)))", "have L: \"list_all (nfa_is_node A) ls\""], ["proof (prove)\nusing this:\n  subset_dfs A (nfa_startnode A) = (bt, ls)\n  list_all (nfa_is_node A) (snd (subset_dfs A (nfa_startnode A)))\n\ngoal (1 subgoal):\n 1. list_all (nfa_is_node A) ls", "by simp"], ["proof (state)\nthis:\n  list_all (nfa_is_node A) ls\n\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "have D: \"det_nfa A = (map (\\<lambda>q. bdd_map (\\<lambda>q. the (bdd_lookup bt q)) (subsetbdd (fst A) q (nfa_emptybdd (length q)))) ls, map (\\<lambda>q. nfa_accepting A q) ls)\"\n    (is \"_ = (?bdt, ?atbl)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. det_nfa A =\n    (map (\\<lambda>q.\n             bdd_map (\\<lambda>q. the (bdd_lookup bt q))\n              (subsetbdd (fst A) q (nfa_emptybdd (length q))))\n      ls,\n     map (nfa_accepting A) ls)", "unfolding det_nfa_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let (bdd, qss) = subset_dfs A (nfa_startnode A)\n     in (map (\\<lambda>qs.\n                 bdd_map (\\<lambda>qs. the (bdd_lookup bdd qs))\n                  (subsetbdd (fst A) qs (nfa_emptybdd (length qs))))\n          qss,\n         map (nfa_accepting A) qss)) =\n    (map (\\<lambda>q.\n             bdd_map (\\<lambda>q. the (bdd_lookup bt q))\n              (subsetbdd (fst A) q (nfa_emptybdd (length q))))\n      ls,\n     map (nfa_accepting A) ls)", "by (simp add: BT)"], ["proof (state)\nthis:\n  det_nfa A =\n  (map (\\<lambda>q.\n           bdd_map (\\<lambda>q. the (bdd_lookup bt q))\n            (subsetbdd (fst A) q (nfa_emptybdd (length q))))\n    ls,\n   map (nfa_accepting A) ls)\n\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "from well_formed L"], ["proof (chain)\npicking this:\n  wf_nfa A n\n  list_all (nfa_is_node A) ls", "have \"list_all (\\<lambda>q. bddh n (subsetbdd (fst A) q (nfa_emptybdd (length q)))) ls\""], ["proof (prove)\nusing this:\n  wf_nfa A n\n  list_all (nfa_is_node A) ls\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>q. bddh n (subsetbdd (fst A) q (nfa_emptybdd (length q)))) ls", "by (induct ls) (simp add: bddh_subsetbdd wf_nfa_def nfa_emptybdd_def)+"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>q. bddh n (subsetbdd (fst A) q (nfa_emptybdd (length q)))) ls\n\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "hence \"list_all (\\<lambda>q. bddh n (bdd_map (\\<lambda>q. the (bdd_lookup bt q)) (subsetbdd (fst A) q (nfa_emptybdd (length q))))) ls\""], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>q. bddh n (subsetbdd (fst A) q (nfa_emptybdd (length q)))) ls\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>q.\n         bddh n\n          (bdd_map (\\<lambda>q. the (bdd_lookup bt q))\n            (subsetbdd (fst A) q (nfa_emptybdd (length q)))))\n     ls", "by (simp add: bddh_bdd_map)"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>q.\n       bddh n\n        (bdd_map (\\<lambda>q. the (bdd_lookup bt q))\n          (subsetbdd (fst A) q (nfa_emptybdd (length q)))))\n   ls\n\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "hence A: \"list_all (bddh n) ?bdt\""], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>q.\n       bddh n\n        (bdd_map (\\<lambda>q. the (bdd_lookup bt q))\n          (subsetbdd (fst A) q (nfa_emptybdd (length q)))))\n   ls\n\ngoal (1 subgoal):\n 1. list_all (bddh n)\n     (map (\\<lambda>q.\n              bdd_map (\\<lambda>q. the (bdd_lookup bt q))\n               (subsetbdd (fst A) q (nfa_emptybdd (length q))))\n       ls)", "by (simp add: list_all_iff)"], ["proof (state)\nthis:\n  list_all (bddh n)\n   (map (\\<lambda>q.\n            bdd_map (\\<lambda>q. the (bdd_lookup bt q))\n             (subsetbdd (fst A) q (nfa_emptybdd (length q))))\n     ls)\n\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "{"], ["proof (state)\nthis:\n  list_all (bddh n)\n   (map (\\<lambda>q.\n            bdd_map (\\<lambda>q. the (bdd_lookup bt q))\n             (subsetbdd (fst A) q (nfa_emptybdd (length q))))\n     ls)\n\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "assume \"\\<exists>i < length ls. ls ! i = q\""], ["proof (state)\nthis:\n  \\<exists>i<length ls. ls ! i = q\n\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "then"], ["proof (chain)\npicking this:\n  \\<exists>i<length ls. ls ! i = q", "obtain i where len_i: \"i < length ls\" and i: \"q = ls ! i\""], ["proof (prove)\nusing this:\n  \\<exists>i<length ls. ls ! i = q\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length ls; q = ls ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  i < length ls\n  q = ls ! i\n\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "from len_i i L"], ["proof (chain)\npicking this:\n  i < length ls\n  q = ls ! i\n  list_all (nfa_is_node A) ls", "have Q': \"nfa_is_node A q\""], ["proof (prove)\nusing this:\n  i < length ls\n  q = ls ! i\n  list_all (nfa_is_node A) ls\n\ngoal (1 subgoal):\n 1. nfa_is_node A q", "by (simp add: list_all_iff)"], ["proof (state)\nthis:\n  nfa_is_node A q\n\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "then"], ["proof (chain)\npicking this:\n  nfa_is_node A q", "have \"(bdd_lookup (fst (subset_dfs A (nfa_startnode A))) q = Some i) =\n      (i < length (snd (subset_dfs A (nfa_startnode A))) \\<and> snd (subset_dfs A (nfa_startnode A)) ! i = q)\""], ["proof (prove)\nusing this:\n  nfa_is_node A q\n\ngoal (1 subgoal):\n 1. (bdd_lookup (fst (subset_dfs A (nfa_startnode A))) q = Some i) =\n    (i < length (snd (subset_dfs A (nfa_startnode A))) \\<and>\n     snd (subset_dfs A (nfa_startnode A)) ! i = q)", "using Q"], ["proof (prove)\nusing this:\n  nfa_is_node A q\n  nfa_is_node A (nfa_startnode A)\n\ngoal (1 subgoal):\n 1. (bdd_lookup (fst (subset_dfs A (nfa_startnode A))) q = Some i) =\n    (i < length (snd (subset_dfs A (nfa_startnode A))) \\<and>\n     snd (subset_dfs A (nfa_startnode A)) ! i = q)", "by (rule subset_dfs_bij)"], ["proof (state)\nthis:\n  (bdd_lookup (fst (subset_dfs A (nfa_startnode A))) q = Some i) =\n  (i < length (snd (subset_dfs A (nfa_startnode A))) \\<and>\n   snd (subset_dfs A (nfa_startnode A)) ! i = q)\n\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "with BT len_i i"], ["proof (chain)\npicking this:\n  subset_dfs A (nfa_startnode A) = (bt, ls)\n  i < length ls\n  q = ls ! i\n  (bdd_lookup (fst (subset_dfs A (nfa_startnode A))) q = Some i) =\n  (i < length (snd (subset_dfs A (nfa_startnode A))) \\<and>\n   snd (subset_dfs A (nfa_startnode A)) ! i = q)", "have \"bdd_lookup bt q = Some i\""], ["proof (prove)\nusing this:\n  subset_dfs A (nfa_startnode A) = (bt, ls)\n  i < length ls\n  q = ls ! i\n  (bdd_lookup (fst (subset_dfs A (nfa_startnode A))) q = Some i) =\n  (i < length (snd (subset_dfs A (nfa_startnode A))) \\<and>\n   snd (subset_dfs A (nfa_startnode A)) ! i = q)\n\ngoal (1 subgoal):\n 1. bdd_lookup bt q = Some i", "by simp"], ["proof (state)\nthis:\n  bdd_lookup bt q = Some i\n\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "with BT"], ["proof (chain)\npicking this:\n  subset_dfs A (nfa_startnode A) = (bt, ls)\n  bdd_lookup bt q = Some i", "have \"subset_memb q (subset_dfs A (nfa_startnode A))\""], ["proof (prove)\nusing this:\n  subset_dfs A (nfa_startnode A) = (bt, ls)\n  bdd_lookup bt q = Some i\n\ngoal (1 subgoal):\n 1. subset_memb q (subset_dfs A (nfa_startnode A))", "by (simp add: subset_memb_def)"], ["proof (state)\nthis:\n  subset_memb q (subset_dfs A (nfa_startnode A))\n\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "with Q' Q"], ["proof (chain)\npicking this:\n  nfa_is_node A q\n  nfa_is_node A (nfa_startnode A)\n  subset_memb q (subset_dfs A (nfa_startnode A))", "have TR: \"(nfa_startnode A,q) \\<in> (succsr (subset_succs A))\\<^sup>*\""], ["proof (prove)\nusing this:\n  nfa_is_node A q\n  nfa_is_node A (nfa_startnode A)\n  subset_memb q (subset_dfs A (nfa_startnode A))\n\ngoal (1 subgoal):\n 1. (nfa_startnode A, q) \\<in> (succsr (subset_succs A))\\<^sup>*", "by (simp add: dfs_eq_rtrancl)"], ["proof (state)\nthis:\n  (nfa_startnode A, q) \\<in> (succsr (subset_succs A))\\<^sup>*\n\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "{"], ["proof (state)\nthis:\n  (nfa_startnode A, q) \\<in> (succsr (subset_succs A))\\<^sup>*\n\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "assume P: \"p \\<in> set (subset_succs A q)\""], ["proof (state)\nthis:\n  p \\<in> set (subset_succs A q)\n\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "with TR"], ["proof (chain)\npicking this:\n  (nfa_startnode A, q) \\<in> (succsr (subset_succs A))\\<^sup>*\n  p \\<in> set (subset_succs A q)", "have 3: \"(nfa_startnode A,p) \\<in> (succsr (subset_succs A))\\<^sup>*\""], ["proof (prove)\nusing this:\n  (nfa_startnode A, q) \\<in> (succsr (subset_succs A))\\<^sup>*\n  p \\<in> set (subset_succs A q)\n\ngoal (1 subgoal):\n 1. (nfa_startnode A, p) \\<in> (succsr (subset_succs A))\\<^sup>*", "by (simp add: succsr_def rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  (nfa_startnode A, p) \\<in> (succsr (subset_succs A))\\<^sup>*\n\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "from Q'"], ["proof (chain)\npicking this:\n  nfa_is_node A q", "have \"list_all (nfa_is_node A) (subset_succs A q)\""], ["proof (prove)\nusing this:\n  nfa_is_node A q\n\ngoal (1 subgoal):\n 1. list_all (nfa_is_node A) (subset_succs A q)", "by (rule succs_is_node)"], ["proof (state)\nthis:\n  list_all (nfa_is_node A) (subset_succs A q)\n\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "with P"], ["proof (chain)\npicking this:\n  p \\<in> set (subset_succs A q)\n  list_all (nfa_is_node A) (subset_succs A q)", "have 4: \"nfa_is_node A p\""], ["proof (prove)\nusing this:\n  p \\<in> set (subset_succs A q)\n  list_all (nfa_is_node A) (subset_succs A q)\n\ngoal (1 subgoal):\n 1. nfa_is_node A p", "by (simp add: list_all_iff)"], ["proof (state)\nthis:\n  nfa_is_node A p\n\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "with Q 3"], ["proof (chain)\npicking this:\n  nfa_is_node A (nfa_startnode A)\n  (nfa_startnode A, p) \\<in> (succsr (subset_succs A))\\<^sup>*\n  nfa_is_node A p", "have \"subset_memb p (subset_dfs A (nfa_startnode A))\""], ["proof (prove)\nusing this:\n  nfa_is_node A (nfa_startnode A)\n  (nfa_startnode A, p) \\<in> (succsr (subset_succs A))\\<^sup>*\n  nfa_is_node A p\n\ngoal (1 subgoal):\n 1. subset_memb p (subset_dfs A (nfa_startnode A))", "by (simp add: dfs_eq_rtrancl)"], ["proof (state)\nthis:\n  subset_memb p (subset_dfs A (nfa_startnode A))\n\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "with BT"], ["proof (chain)\npicking this:\n  subset_dfs A (nfa_startnode A) = (bt, ls)\n  subset_memb p (subset_dfs A (nfa_startnode A))", "have \"bdd_lookup bt p \\<noteq> None\""], ["proof (prove)\nusing this:\n  subset_dfs A (nfa_startnode A) = (bt, ls)\n  subset_memb p (subset_dfs A (nfa_startnode A))\n\ngoal (1 subgoal):\n 1. bdd_lookup bt p \\<noteq> None", "by (simp add: subset_memb_def)"], ["proof (state)\nthis:\n  bdd_lookup bt p \\<noteq> None\n\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "with BT"], ["proof (chain)\npicking this:\n  subset_dfs A (nfa_startnode A) = (bt, ls)\n  bdd_lookup bt p \\<noteq> None", "obtain j where j: \"bdd_lookup (fst (subset_dfs A (nfa_startnode A))) p = Some j\""], ["proof (prove)\nusing this:\n  subset_dfs A (nfa_startnode A) = (bt, ls)\n  bdd_lookup bt p \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        bdd_lookup (fst (subset_dfs A (nfa_startnode A))) p =\n        Some j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"bdd_lookup bt p\") simp+"], ["proof (state)\nthis:\n  bdd_lookup (fst (subset_dfs A (nfa_startnode A))) p = Some j\n\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "from 4 Q j"], ["proof (chain)\npicking this:\n  nfa_is_node A p\n  nfa_is_node A (nfa_startnode A)\n  bdd_lookup (fst (subset_dfs A (nfa_startnode A))) p = Some j", "have \"j < length (snd (subset_dfs A (nfa_startnode A))) \\<and> (snd (subset_dfs A (nfa_startnode A))) ! j = p\""], ["proof (prove)\nusing this:\n  nfa_is_node A p\n  nfa_is_node A (nfa_startnode A)\n  bdd_lookup (fst (subset_dfs A (nfa_startnode A))) p = Some j\n\ngoal (1 subgoal):\n 1. j < length (snd (subset_dfs A (nfa_startnode A))) \\<and>\n    snd (subset_dfs A (nfa_startnode A)) ! j = p", "by (auto simp add: subset_dfs_bij)"], ["proof (state)\nthis:\n  j < length (snd (subset_dfs A (nfa_startnode A))) \\<and>\n  snd (subset_dfs A (nfa_startnode A)) ! j = p\n\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "with j BT 4"], ["proof (chain)\npicking this:\n  bdd_lookup (fst (subset_dfs A (nfa_startnode A))) p = Some j\n  subset_dfs A (nfa_startnode A) = (bt, ls)\n  nfa_is_node A p\n  j < length (snd (subset_dfs A (nfa_startnode A))) \\<and>\n  snd (subset_dfs A (nfa_startnode A)) ! j = p", "have \"\\<exists>j. bdd_lookup bt p = Some j \\<and> j < length ls\""], ["proof (prove)\nusing this:\n  bdd_lookup (fst (subset_dfs A (nfa_startnode A))) p = Some j\n  subset_dfs A (nfa_startnode A) = (bt, ls)\n  nfa_is_node A p\n  j < length (snd (subset_dfs A (nfa_startnode A))) \\<and>\n  snd (subset_dfs A (nfa_startnode A)) ! j = p\n\ngoal (1 subgoal):\n 1. \\<exists>j. bdd_lookup bt p = Some j \\<and> j < length ls", "by auto"], ["proof (state)\nthis:\n  \\<exists>j. bdd_lookup bt p = Some j \\<and> j < length ls\n\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "}"], ["proof (state)\nthis:\n  ?p2 \\<in> set (subset_succs A q) \\<Longrightarrow>\n  \\<exists>j. bdd_lookup bt ?p2 = Some j \\<and> j < length ls\n\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "hence \"\\<forall>p \\<in> set (subset_succs A q). \\<exists>j. bdd_lookup bt p = Some j \\<and> j < length ls\""], ["proof (prove)\nusing this:\n  ?p2 \\<in> set (subset_succs A q) \\<Longrightarrow>\n  \\<exists>j. bdd_lookup bt ?p2 = Some j \\<and> j < length ls\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set (subset_succs A q).\n       \\<exists>j. bdd_lookup bt p = Some j \\<and> j < length ls", "by auto"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set (subset_succs A q).\n     \\<exists>j. bdd_lookup bt p = Some j \\<and> j < length ls\n\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "hence \"list_all (\\<lambda>p. \\<exists>j. bdd_lookup bt p = Some j \\<and> j < length ls) (add_leaves (subsetbdd (fst A) q (nfa_emptybdd (length q))) [])\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set (subset_succs A q).\n     \\<exists>j. bdd_lookup bt p = Some j \\<and> j < length ls\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>p. \\<exists>j. bdd_lookup bt p = Some j \\<and> j < length ls)\n     (add_leaves (subsetbdd (fst A) q (nfa_emptybdd (length q))) [])", "by (simp add: list_all_iff subset_succs_def)"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>p. \\<exists>j. bdd_lookup bt p = Some j \\<and> j < length ls)\n   (add_leaves (subsetbdd (fst A) q (nfa_emptybdd (length q))) [])\n\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "hence \"bdd_all (\\<lambda>p. \\<exists>j. bdd_lookup bt p = Some j \\<and> j < length ls) (subsetbdd (fst A) q (nfa_emptybdd (length q)))\""], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>p. \\<exists>j. bdd_lookup bt p = Some j \\<and> j < length ls)\n   (add_leaves (subsetbdd (fst A) q (nfa_emptybdd (length q))) [])\n\ngoal (1 subgoal):\n 1. bdd_all\n     (\\<lambda>p. \\<exists>j. bdd_lookup bt p = Some j \\<and> j < length ls)\n     (subsetbdd (fst A) q (nfa_emptybdd (length q)))", "by (simp add: add_leaves_bdd_all_eq)"], ["proof (state)\nthis:\n  bdd_all\n   (\\<lambda>p. \\<exists>j. bdd_lookup bt p = Some j \\<and> j < length ls)\n   (subsetbdd (fst A) q (nfa_emptybdd (length q)))\n\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "hence \"bdd_all (\\<lambda>l. l < length ls) (bdd_map (\\<lambda>q. the (bdd_lookup bt q)) (subsetbdd (fst A) q (nfa_emptybdd (length q))))\""], ["proof (prove)\nusing this:\n  bdd_all\n   (\\<lambda>p. \\<exists>j. bdd_lookup bt p = Some j \\<and> j < length ls)\n   (subsetbdd (fst A) q (nfa_emptybdd (length q)))\n\ngoal (1 subgoal):\n 1. bdd_all (\\<lambda>l. l < length ls)\n     (bdd_map (\\<lambda>q. the (bdd_lookup bt q))\n       (subsetbdd (fst A) q (nfa_emptybdd (length q))))", "by (induct (\"subsetbdd (fst A) q (nfa_emptybdd (length q))\")) auto"], ["proof (state)\nthis:\n  bdd_all (\\<lambda>l. l < length ls)\n   (bdd_map (\\<lambda>q. the (bdd_lookup bt q))\n     (subsetbdd (fst A) q (nfa_emptybdd (length q))))\n\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "}"], ["proof (state)\nthis:\n  \\<exists>i<length ls. ls ! i = ?q2 \\<Longrightarrow>\n  bdd_all (\\<lambda>l. l < length ls)\n   (bdd_map (\\<lambda>q. the (bdd_lookup bt q))\n     (subsetbdd (fst A) ?q2 (nfa_emptybdd (length ?q2))))\n\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "then"], ["proof (chain)\npicking this:\n  \\<exists>i<length ls. ls ! i = ?q2 \\<Longrightarrow>\n  bdd_all (\\<lambda>l. l < length ls)\n   (bdd_map (\\<lambda>q. the (bdd_lookup bt q))\n     (subsetbdd (fst A) ?q2 (nfa_emptybdd (length ?q2))))", "have \"\\<forall>x \\<in> set ls. bdd_all (\\<lambda>l. l < length ls) (bdd_map (\\<lambda>q. the (bdd_lookup bt q)) (subsetbdd (fst A) x (nfa_emptybdd (length x))))\""], ["proof (prove)\nusing this:\n  \\<exists>i<length ls. ls ! i = ?q2 \\<Longrightarrow>\n  bdd_all (\\<lambda>l. l < length ls)\n   (bdd_map (\\<lambda>q. the (bdd_lookup bt q))\n     (subsetbdd (fst A) ?q2 (nfa_emptybdd (length ?q2))))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set ls.\n       bdd_all (\\<lambda>l. l < length ls)\n        (bdd_map (\\<lambda>q. the (bdd_lookup bt q))\n          (subsetbdd (fst A) x (nfa_emptybdd (length x))))", "by (simp add: in_set_conv_nth)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set ls.\n     bdd_all (\\<lambda>l. l < length ls)\n      (bdd_map (\\<lambda>q. the (bdd_lookup bt q))\n        (subsetbdd (fst A) x (nfa_emptybdd (length x))))\n\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "hence \"list_all (\\<lambda>x. bdd_all (\\<lambda>l. l < length ls) (bdd_map (\\<lambda>q. the (bdd_lookup bt q)) (subsetbdd (fst A) x (nfa_emptybdd (length x))))) ls\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set ls.\n     bdd_all (\\<lambda>l. l < length ls)\n      (bdd_map (\\<lambda>q. the (bdd_lookup bt q))\n        (subsetbdd (fst A) x (nfa_emptybdd (length x))))\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>x.\n         bdd_all (\\<lambda>l. l < length ls)\n          (bdd_map (\\<lambda>q. the (bdd_lookup bt q))\n            (subsetbdd (fst A) x (nfa_emptybdd (length x)))))\n     ls", "by (simp add: list_all_iff)"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>x.\n       bdd_all (\\<lambda>l. l < length ls)\n        (bdd_map (\\<lambda>q. the (bdd_lookup bt q))\n          (subsetbdd (fst A) x (nfa_emptybdd (length x)))))\n   ls\n\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "hence B: \"list_all (bdd_all (\\<lambda>l. l < length ls)) (map (\\<lambda>x. bdd_map (\\<lambda>q. the (bdd_lookup bt q)) (subsetbdd (fst A) x (nfa_emptybdd (length x)))) ls)\""], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>x.\n       bdd_all (\\<lambda>l. l < length ls)\n        (bdd_map (\\<lambda>q. the (bdd_lookup bt q))\n          (subsetbdd (fst A) x (nfa_emptybdd (length x)))))\n   ls\n\ngoal (1 subgoal):\n 1. list_all (bdd_all (\\<lambda>l. l < length ls))\n     (map (\\<lambda>x.\n              bdd_map (\\<lambda>q. the (bdd_lookup bt q))\n               (subsetbdd (fst A) x (nfa_emptybdd (length x))))\n       ls)", "by (simp add: list_all_iff)"], ["proof (state)\nthis:\n  list_all (bdd_all (\\<lambda>l. l < length ls))\n   (map (\\<lambda>x.\n            bdd_map (\\<lambda>q. the (bdd_lookup bt q))\n             (subsetbdd (fst A) x (nfa_emptybdd (length x))))\n     ls)\n\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "from well_formed"], ["proof (chain)\npicking this:\n  wf_nfa A n", "have \"bdd_lookup (fst (subset_dfs A (nfa_startnode A))) (nfa_startnode A) = Some 0\""], ["proof (prove)\nusing this:\n  wf_nfa A n\n\ngoal (1 subgoal):\n 1. bdd_lookup (fst (subset_dfs A (nfa_startnode A))) (nfa_startnode A) =\n    Some 0", "by (simp add: subset_dfs_start nfa_startnode_is_node)"], ["proof (state)\nthis:\n  bdd_lookup (fst (subset_dfs A (nfa_startnode A))) (nfa_startnode A) =\n  Some 0\n\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "with well_formed"], ["proof (chain)\npicking this:\n  wf_nfa A n\n  bdd_lookup (fst (subset_dfs A (nfa_startnode A))) (nfa_startnode A) =\n  Some 0", "have \"0 < length (snd (subset_dfs A (nfa_startnode A)))\""], ["proof (prove)\nusing this:\n  wf_nfa A n\n  bdd_lookup (fst (subset_dfs A (nfa_startnode A))) (nfa_startnode A) =\n  Some 0\n\ngoal (1 subgoal):\n 1. 0 < length (snd (subset_dfs A (nfa_startnode A)))", "by (simp add: subset_dfs_bij nfa_startnode_is_node)"], ["proof (state)\nthis:\n  0 < length (snd (subset_dfs A (nfa_startnode A)))\n\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "with A B D BT"], ["proof (chain)\npicking this:\n  list_all (bddh n)\n   (map (\\<lambda>q.\n            bdd_map (\\<lambda>q. the (bdd_lookup bt q))\n             (subsetbdd (fst A) q (nfa_emptybdd (length q))))\n     ls)\n  list_all (bdd_all (\\<lambda>l. l < length ls))\n   (map (\\<lambda>x.\n            bdd_map (\\<lambda>q. the (bdd_lookup bt q))\n             (subsetbdd (fst A) x (nfa_emptybdd (length x))))\n     ls)\n  det_nfa A =\n  (map (\\<lambda>q.\n           bdd_map (\\<lambda>q. the (bdd_lookup bt q))\n            (subsetbdd (fst A) q (nfa_emptybdd (length q))))\n    ls,\n   map (nfa_accepting A) ls)\n  subset_dfs A (nfa_startnode A) = (bt, ls)\n  0 < length (snd (subset_dfs A (nfa_startnode A)))", "show ?thesis"], ["proof (prove)\nusing this:\n  list_all (bddh n)\n   (map (\\<lambda>q.\n            bdd_map (\\<lambda>q. the (bdd_lookup bt q))\n             (subsetbdd (fst A) q (nfa_emptybdd (length q))))\n     ls)\n  list_all (bdd_all (\\<lambda>l. l < length ls))\n   (map (\\<lambda>x.\n            bdd_map (\\<lambda>q. the (bdd_lookup bt q))\n             (subsetbdd (fst A) x (nfa_emptybdd (length x))))\n     ls)\n  det_nfa A =\n  (map (\\<lambda>q.\n           bdd_map (\\<lambda>q. the (bdd_lookup bt q))\n            (subsetbdd (fst A) q (nfa_emptybdd (length q))))\n    ls,\n   map (nfa_accepting A) ls)\n  subset_dfs A (nfa_startnode A) = (bt, ls)\n  0 < length (snd (subset_dfs A (nfa_startnode A)))\n\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "by (simp add: wf_dfa_def det_nfa_def dfa_is_node_def)"], ["proof (state)\nthis:\n  wf_dfa (det_nfa A) n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nfa_reach_rtrancl:\n  assumes \"nfa_is_node A i\"\n  shows \"(\\<exists>bss. nfa_reach A i bss j \\<and> list_all (is_alph n) bss) = ((i, j) \\<in> (succsr (subset_succs A))\\<^sup>*)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>bss. nfa_reach A i bss j \\<and> list_all (is_alph n) bss) =\n    ((i, j) \\<in> (succsr (subset_succs A))\\<^sup>*)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>bss.\n       nfa_reach A i bss j \\<and> list_all (is_alph n) bss \\<Longrightarrow>\n    (i, j) \\<in> (succsr (subset_succs A))\\<^sup>*\n 2. (i, j) \\<in> (succsr (subset_succs A))\\<^sup>* \\<Longrightarrow>\n    \\<exists>bss. nfa_reach A i bss j \\<and> list_all (is_alph n) bss", "assume \"\\<exists>bss. nfa_reach A i bss j \\<and> list_all (is_alph n) bss\""], ["proof (state)\nthis:\n  \\<exists>bss. nfa_reach A i bss j \\<and> list_all (is_alph n) bss\n\ngoal (2 subgoals):\n 1. \\<exists>bss.\n       nfa_reach A i bss j \\<and> list_all (is_alph n) bss \\<Longrightarrow>\n    (i, j) \\<in> (succsr (subset_succs A))\\<^sup>*\n 2. (i, j) \\<in> (succsr (subset_succs A))\\<^sup>* \\<Longrightarrow>\n    \\<exists>bss. nfa_reach A i bss j \\<and> list_all (is_alph n) bss", "then"], ["proof (chain)\npicking this:\n  \\<exists>bss. nfa_reach A i bss j \\<and> list_all (is_alph n) bss", "obtain bss where BS: \"nfa_reach A i bss j\" \"list_all (is_alph n) bss\""], ["proof (prove)\nusing this:\n  \\<exists>bss. nfa_reach A i bss j \\<and> list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. (\\<And>bss.\n        \\<lbrakk>nfa_reach A i bss j; list_all (is_alph n) bss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  nfa_reach A i bss j\n  list_all (is_alph n) bss\n\ngoal (2 subgoals):\n 1. \\<exists>bss.\n       nfa_reach A i bss j \\<and> list_all (is_alph n) bss \\<Longrightarrow>\n    (i, j) \\<in> (succsr (subset_succs A))\\<^sup>*\n 2. (i, j) \\<in> (succsr (subset_succs A))\\<^sup>* \\<Longrightarrow>\n    \\<exists>bss. nfa_reach A i bss j \\<and> list_all (is_alph n) bss", "show \"(i,j) \\<in> (succsr (subset_succs A))\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i, j) \\<in> (succsr (subset_succs A))\\<^sup>*", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (i, j) \\<in> (succsr (subset_succs A))\\<^sup>*", "from BS"], ["proof (chain)\npicking this:\n  nfa_reach A i bss j\n  list_all (is_alph n) bss", "show \"(i,j) \\<in> (succsr (subset_succs A))\\<^sup>*\""], ["proof (prove)\nusing this:\n  nfa_reach A i bss j\n  list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. (i, j) \\<in> (succsr (subset_succs A))\\<^sup>*", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. list_all (is_alph n) [] \\<Longrightarrow>\n    (i, i) \\<in> (succsr (subset_succs A))\\<^sup>*\n 2. \\<And>k x y.\n       \\<lbrakk>nfa_reach A i x k;\n        list_all (is_alph n) x \\<Longrightarrow>\n        (i, k) \\<in> (succsr (subset_succs A))\\<^sup>*;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> (i, nfa_trans A k y)\n                         \\<in> (succsr (subset_succs A))\\<^sup>*", "case (snoc j bss bs)"], ["proof (state)\nthis:\n  nfa_reach A i bss j\n  list_all (is_alph n) bss \\<Longrightarrow>\n  (i, j) \\<in> (succsr (subset_succs A))\\<^sup>*\n  list_all (is_alph n) (bss @ [bs])\n\ngoal (2 subgoals):\n 1. list_all (is_alph n) [] \\<Longrightarrow>\n    (i, i) \\<in> (succsr (subset_succs A))\\<^sup>*\n 2. \\<And>k x y.\n       \\<lbrakk>nfa_reach A i x k;\n        list_all (is_alph n) x \\<Longrightarrow>\n        (i, k) \\<in> (succsr (subset_succs A))\\<^sup>*;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> (i, nfa_trans A k y)\n                         \\<in> (succsr (subset_succs A))\\<^sup>*", "with assms well_formed"], ["proof (chain)\npicking this:\n  nfa_is_node A i\n  wf_nfa A n\n  nfa_reach A i bss j\n  list_all (is_alph n) bss \\<Longrightarrow>\n  (i, j) \\<in> (succsr (subset_succs A))\\<^sup>*\n  list_all (is_alph n) (bss @ [bs])", "have J: \"nfa_is_node A j\""], ["proof (prove)\nusing this:\n  nfa_is_node A i\n  wf_nfa A n\n  nfa_reach A i bss j\n  list_all (is_alph n) bss \\<Longrightarrow>\n  (i, j) \\<in> (succsr (subset_succs A))\\<^sup>*\n  list_all (is_alph n) (bss @ [bs])\n\ngoal (1 subgoal):\n 1. nfa_is_node A j", "by (simp add: nfa_reach_is_node)"], ["proof (state)\nthis:\n  nfa_is_node A j\n\ngoal (2 subgoals):\n 1. list_all (is_alph n) [] \\<Longrightarrow>\n    (i, i) \\<in> (succsr (subset_succs A))\\<^sup>*\n 2. \\<And>k x y.\n       \\<lbrakk>nfa_reach A i x k;\n        list_all (is_alph n) x \\<Longrightarrow>\n        (i, k) \\<in> (succsr (subset_succs A))\\<^sup>*;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> (i, nfa_trans A k y)\n                         \\<in> (succsr (subset_succs A))\\<^sup>*", "with snoc well_formed"], ["proof (chain)\npicking this:\n  nfa_reach A i bss j\n  list_all (is_alph n) bss \\<Longrightarrow>\n  (i, j) \\<in> (succsr (subset_succs A))\\<^sup>*\n  list_all (is_alph n) (bss @ [bs])\n  wf_nfa A n\n  nfa_is_node A j", "have \"bddh n (subsetbdd (fst A) j (nfa_emptybdd (length j)))\""], ["proof (prove)\nusing this:\n  nfa_reach A i bss j\n  list_all (is_alph n) bss \\<Longrightarrow>\n  (i, j) \\<in> (succsr (subset_succs A))\\<^sup>*\n  list_all (is_alph n) (bss @ [bs])\n  wf_nfa A n\n  nfa_is_node A j\n\ngoal (1 subgoal):\n 1. bddh n (subsetbdd (fst A) j (nfa_emptybdd (length j)))", "by (simp add: wf_nfa_def bddh_subsetbdd nfa_emptybdd_def)"], ["proof (state)\nthis:\n  bddh n (subsetbdd (fst A) j (nfa_emptybdd (length j)))\n\ngoal (2 subgoals):\n 1. list_all (is_alph n) [] \\<Longrightarrow>\n    (i, i) \\<in> (succsr (subset_succs A))\\<^sup>*\n 2. \\<And>k x y.\n       \\<lbrakk>nfa_reach A i x k;\n        list_all (is_alph n) x \\<Longrightarrow>\n        (i, k) \\<in> (succsr (subset_succs A))\\<^sup>*;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> (i, nfa_trans A k y)\n                         \\<in> (succsr (subset_succs A))\\<^sup>*", "with snoc(3)"], ["proof (chain)\npicking this:\n  list_all (is_alph n) (bss @ [bs])\n  bddh n (subsetbdd (fst A) j (nfa_emptybdd (length j)))", "have \"bdd_lookup (subsetbdd (fst A) j (nfa_emptybdd (length j))) bs \\<in> set (add_leaves (subsetbdd (fst A) j (nfa_emptybdd (length j))) [])\""], ["proof (prove)\nusing this:\n  list_all (is_alph n) (bss @ [bs])\n  bddh n (subsetbdd (fst A) j (nfa_emptybdd (length j)))\n\ngoal (1 subgoal):\n 1. bdd_lookup (subsetbdd (fst A) j (nfa_emptybdd (length j))) bs\n    \\<in> set (add_leaves (subsetbdd (fst A) j (nfa_emptybdd (length j)))\n                [])", "by (auto simp: add_leaves_bdd_lookup)"], ["proof (state)\nthis:\n  bdd_lookup (subsetbdd (fst A) j (nfa_emptybdd (length j))) bs\n  \\<in> set (add_leaves (subsetbdd (fst A) j (nfa_emptybdd (length j))) [])\n\ngoal (2 subgoals):\n 1. list_all (is_alph n) [] \\<Longrightarrow>\n    (i, i) \\<in> (succsr (subset_succs A))\\<^sup>*\n 2. \\<And>k x y.\n       \\<lbrakk>nfa_reach A i x k;\n        list_all (is_alph n) x \\<Longrightarrow>\n        (i, k) \\<in> (succsr (subset_succs A))\\<^sup>*;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> (i, nfa_trans A k y)\n                         \\<in> (succsr (subset_succs A))\\<^sup>*", "hence \"(j, bdd_lookup (subsetbdd (fst A) j (nfa_emptybdd (length j))) bs) \\<in> (succsr (subset_succs A))\\<^sup>*\""], ["proof (prove)\nusing this:\n  bdd_lookup (subsetbdd (fst A) j (nfa_emptybdd (length j))) bs\n  \\<in> set (add_leaves (subsetbdd (fst A) j (nfa_emptybdd (length j))) [])\n\ngoal (1 subgoal):\n 1. (j, bdd_lookup (subsetbdd (fst A) j (nfa_emptybdd (length j))) bs)\n    \\<in> (succsr (subset_succs A))\\<^sup>*", "by (auto simp:  succsr_def subset_succs_def)"], ["proof (state)\nthis:\n  (j, bdd_lookup (subsetbdd (fst A) j (nfa_emptybdd (length j))) bs)\n  \\<in> (succsr (subset_succs A))\\<^sup>*\n\ngoal (2 subgoals):\n 1. list_all (is_alph n) [] \\<Longrightarrow>\n    (i, i) \\<in> (succsr (subset_succs A))\\<^sup>*\n 2. \\<And>k x y.\n       \\<lbrakk>nfa_reach A i x k;\n        list_all (is_alph n) x \\<Longrightarrow>\n        (i, k) \\<in> (succsr (subset_succs A))\\<^sup>*;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> (i, nfa_trans A k y)\n                         \\<in> (succsr (subset_succs A))\\<^sup>*", "with snoc"], ["proof (chain)\npicking this:\n  nfa_reach A i bss j\n  list_all (is_alph n) bss \\<Longrightarrow>\n  (i, j) \\<in> (succsr (subset_succs A))\\<^sup>*\n  list_all (is_alph n) (bss @ [bs])\n  (j, bdd_lookup (subsetbdd (fst A) j (nfa_emptybdd (length j))) bs)\n  \\<in> (succsr (subset_succs A))\\<^sup>*", "show ?case"], ["proof (prove)\nusing this:\n  nfa_reach A i bss j\n  list_all (is_alph n) bss \\<Longrightarrow>\n  (i, j) \\<in> (succsr (subset_succs A))\\<^sup>*\n  list_all (is_alph n) (bss @ [bs])\n  (j, bdd_lookup (subsetbdd (fst A) j (nfa_emptybdd (length j))) bs)\n  \\<in> (succsr (subset_succs A))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (i, nfa_trans A j bs) \\<in> (succsr (subset_succs A))\\<^sup>*", "by (simp add: nfa_trans_def)"], ["proof (state)\nthis:\n  (i, nfa_trans A j bs) \\<in> (succsr (subset_succs A))\\<^sup>*\n\ngoal (1 subgoal):\n 1. list_all (is_alph n) [] \\<Longrightarrow>\n    (i, i) \\<in> (succsr (subset_succs A))\\<^sup>*", "qed simp"], ["proof (state)\nthis:\n  (i, j) \\<in> (succsr (subset_succs A))\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (i, j) \\<in> (succsr (subset_succs A))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (i, j) \\<in> (succsr (subset_succs A))\\<^sup>* \\<Longrightarrow>\n    \\<exists>bss. nfa_reach A i bss j \\<and> list_all (is_alph n) bss", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (i, j) \\<in> (succsr (subset_succs A))\\<^sup>* \\<Longrightarrow>\n    \\<exists>bss. nfa_reach A i bss j \\<and> list_all (is_alph n) bss", "assume ij: \"(i,j) \\<in> (succsr (subset_succs A))\\<^sup>*\""], ["proof (state)\nthis:\n  (i, j) \\<in> (succsr (subset_succs A))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (i, j) \\<in> (succsr (subset_succs A))\\<^sup>* \\<Longrightarrow>\n    \\<exists>bss. nfa_reach A i bss j \\<and> list_all (is_alph n) bss", "from ij"], ["proof (chain)\npicking this:\n  (i, j) \\<in> (succsr (subset_succs A))\\<^sup>*", "show \"\\<exists>bss. nfa_reach A i bss j \\<and> list_all (is_alph n) bss\""], ["proof (prove)\nusing this:\n  (i, j) \\<in> (succsr (subset_succs A))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<exists>bss. nfa_reach A i bss j \\<and> list_all (is_alph n) bss", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>bss. nfa_reach A i bss i \\<and> list_all (is_alph n) bss\n 2. \\<And>y z.\n       \\<lbrakk>(i, y) \\<in> (succsr (subset_succs A))\\<^sup>*;\n        (y, z) \\<in> succsr (subset_succs A);\n        \\<exists>bss.\n           nfa_reach A i bss y \\<and> list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bss.\n                            nfa_reach A i bss z \\<and>\n                            list_all (is_alph n) bss", "case base"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<exists>bss. nfa_reach A i bss i \\<and> list_all (is_alph n) bss\n 2. \\<And>y z.\n       \\<lbrakk>(i, y) \\<in> (succsr (subset_succs A))\\<^sup>*;\n        (y, z) \\<in> succsr (subset_succs A);\n        \\<exists>bss.\n           nfa_reach A i bss y \\<and> list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bss.\n                            nfa_reach A i bss z \\<and>\n                            list_all (is_alph n) bss", "from reach_nil[of \"nfa_trans A\" i]"], ["proof (chain)\npicking this:\n  nfa_reach A i [] i", "show ?case"], ["proof (prove)\nusing this:\n  nfa_reach A i [] i\n\ngoal (1 subgoal):\n 1. \\<exists>bss. nfa_reach A i bss i \\<and> list_all (is_alph n) bss", "by auto"], ["proof (state)\nthis:\n  \\<exists>bss. nfa_reach A i bss i \\<and> list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(i, y) \\<in> (succsr (subset_succs A))\\<^sup>*;\n        (y, z) \\<in> succsr (subset_succs A);\n        \\<exists>bss.\n           nfa_reach A i bss y \\<and> list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bss.\n                            nfa_reach A i bss z \\<and>\n                            list_all (is_alph n) bss", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(i, y) \\<in> (succsr (subset_succs A))\\<^sup>*;\n        (y, z) \\<in> succsr (subset_succs A);\n        \\<exists>bss.\n           nfa_reach A i bss y \\<and> list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bss.\n                            nfa_reach A i bss z \\<and>\n                            list_all (is_alph n) bss", "case (step y z)"], ["proof (state)\nthis:\n  (i, y) \\<in> (succsr (subset_succs A))\\<^sup>*\n  (y, z) \\<in> succsr (subset_succs A)\n  \\<exists>bss. nfa_reach A i bss y \\<and> list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(i, y) \\<in> (succsr (subset_succs A))\\<^sup>*;\n        (y, z) \\<in> succsr (subset_succs A);\n        \\<exists>bss.\n           nfa_reach A i bss y \\<and> list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bss.\n                            nfa_reach A i bss z \\<and>\n                            list_all (is_alph n) bss", "then"], ["proof (chain)\npicking this:\n  (i, y) \\<in> (succsr (subset_succs A))\\<^sup>*\n  (y, z) \\<in> succsr (subset_succs A)\n  \\<exists>bss. nfa_reach A i bss y \\<and> list_all (is_alph n) bss", "obtain bss where BS: \"nfa_reach A i bss y\" \"list_all (is_alph n) bss\""], ["proof (prove)\nusing this:\n  (i, y) \\<in> (succsr (subset_succs A))\\<^sup>*\n  (y, z) \\<in> succsr (subset_succs A)\n  \\<exists>bss. nfa_reach A i bss y \\<and> list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. (\\<And>bss.\n        \\<lbrakk>nfa_reach A i bss y; list_all (is_alph n) bss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  nfa_reach A i bss y\n  list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(i, y) \\<in> (succsr (subset_succs A))\\<^sup>*;\n        (y, z) \\<in> succsr (subset_succs A);\n        \\<exists>bss.\n           nfa_reach A i bss y \\<and> list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bss.\n                            nfa_reach A i bss z \\<and>\n                            list_all (is_alph n) bss", "from assms well_formed BS"], ["proof (chain)\npicking this:\n  nfa_is_node A i\n  wf_nfa A n\n  nfa_reach A i bss y\n  list_all (is_alph n) bss", "have \"nfa_is_node A y\""], ["proof (prove)\nusing this:\n  nfa_is_node A i\n  wf_nfa A n\n  nfa_reach A i bss y\n  list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. nfa_is_node A y", "by (simp add: nfa_reach_is_node)"], ["proof (state)\nthis:\n  nfa_is_node A y\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(i, y) \\<in> (succsr (subset_succs A))\\<^sup>*;\n        (y, z) \\<in> succsr (subset_succs A);\n        \\<exists>bss.\n           nfa_reach A i bss y \\<and> list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bss.\n                            nfa_reach A i bss z \\<and>\n                            list_all (is_alph n) bss", "with well_formed BS"], ["proof (chain)\npicking this:\n  wf_nfa A n\n  nfa_reach A i bss y\n  list_all (is_alph n) bss\n  nfa_is_node A y", "have B: \"bddh n (subsetbdd (fst A) y (nfa_emptybdd (length y)))\""], ["proof (prove)\nusing this:\n  wf_nfa A n\n  nfa_reach A i bss y\n  list_all (is_alph n) bss\n  nfa_is_node A y\n\ngoal (1 subgoal):\n 1. bddh n (subsetbdd (fst A) y (nfa_emptybdd (length y)))", "by (simp add: wf_nfa_def bddh_subsetbdd nfa_emptybdd_def)"], ["proof (state)\nthis:\n  bddh n (subsetbdd (fst A) y (nfa_emptybdd (length y)))\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(i, y) \\<in> (succsr (subset_succs A))\\<^sup>*;\n        (y, z) \\<in> succsr (subset_succs A);\n        \\<exists>bss.\n           nfa_reach A i bss y \\<and> list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bss.\n                            nfa_reach A i bss z \\<and>\n                            list_all (is_alph n) bss", "from step"], ["proof (chain)\npicking this:\n  (i, y) \\<in> (succsr (subset_succs A))\\<^sup>*\n  (y, z) \\<in> succsr (subset_succs A)\n  \\<exists>bss. nfa_reach A i bss y \\<and> list_all (is_alph n) bss", "have \"z \\<in> set (add_leaves (subsetbdd (fst A) y (nfa_emptybdd (length y))) [])\""], ["proof (prove)\nusing this:\n  (i, y) \\<in> (succsr (subset_succs A))\\<^sup>*\n  (y, z) \\<in> succsr (subset_succs A)\n  \\<exists>bss. nfa_reach A i bss y \\<and> list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. z \\<in> set (add_leaves (subsetbdd (fst A) y (nfa_emptybdd (length y)))\n                  [])", "by (simp add: succsr_def subset_succs_def)"], ["proof (state)\nthis:\n  z \\<in> set (add_leaves (subsetbdd (fst A) y (nfa_emptybdd (length y)))\n                [])\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(i, y) \\<in> (succsr (subset_succs A))\\<^sup>*;\n        (y, z) \\<in> succsr (subset_succs A);\n        \\<exists>bss.\n           nfa_reach A i bss y \\<and> list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bss.\n                            nfa_reach A i bss z \\<and>\n                            list_all (is_alph n) bss", "with B"], ["proof (chain)\npicking this:\n  bddh n (subsetbdd (fst A) y (nfa_emptybdd (length y)))\n  z \\<in> set (add_leaves (subsetbdd (fst A) y (nfa_emptybdd (length y)))\n                [])", "have \"\\<exists>bs. z = bdd_lookup (subsetbdd (fst A) y (nfa_emptybdd (length y))) bs \\<and> is_alph n bs\""], ["proof (prove)\nusing this:\n  bddh n (subsetbdd (fst A) y (nfa_emptybdd (length y)))\n  z \\<in> set (add_leaves (subsetbdd (fst A) y (nfa_emptybdd (length y)))\n                [])\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       z =\n       bdd_lookup (subsetbdd (fst A) y (nfa_emptybdd (length y))) bs \\<and>\n       is_alph n bs", "by (simp add: add_leaves_bdd_lookup)"], ["proof (state)\nthis:\n  \\<exists>bs.\n     z =\n     bdd_lookup (subsetbdd (fst A) y (nfa_emptybdd (length y))) bs \\<and>\n     is_alph n bs\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(i, y) \\<in> (succsr (subset_succs A))\\<^sup>*;\n        (y, z) \\<in> succsr (subset_succs A);\n        \\<exists>bss.\n           nfa_reach A i bss y \\<and> list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bss.\n                            nfa_reach A i bss z \\<and>\n                            list_all (is_alph n) bss", "then"], ["proof (chain)\npicking this:\n  \\<exists>bs.\n     z =\n     bdd_lookup (subsetbdd (fst A) y (nfa_emptybdd (length y))) bs \\<and>\n     is_alph n bs", "obtain bs where Z:\"z = bdd_lookup (subsetbdd (fst A) y (nfa_emptybdd (length y))) bs\" and L: \"is_alph n bs\""], ["proof (prove)\nusing this:\n  \\<exists>bs.\n     z =\n     bdd_lookup (subsetbdd (fst A) y (nfa_emptybdd (length y))) bs \\<and>\n     is_alph n bs\n\ngoal (1 subgoal):\n 1. (\\<And>bs.\n        \\<lbrakk>z =\n                 bdd_lookup (subsetbdd (fst A) y (nfa_emptybdd (length y)))\n                  bs;\n         is_alph n bs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  z = bdd_lookup (subsetbdd (fst A) y (nfa_emptybdd (length y))) bs\n  is_alph n bs\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(i, y) \\<in> (succsr (subset_succs A))\\<^sup>*;\n        (y, z) \\<in> succsr (subset_succs A);\n        \\<exists>bss.\n           nfa_reach A i bss y \\<and> list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bss.\n                            nfa_reach A i bss z \\<and>\n                            list_all (is_alph n) bss", "from BS(1) L"], ["proof (chain)\npicking this:\n  nfa_reach A i bss y\n  is_alph n bs", "have \"nfa_reach A i (bss @ [bs]) (nfa_trans A y bs)\""], ["proof (prove)\nusing this:\n  nfa_reach A i bss y\n  is_alph n bs\n\ngoal (1 subgoal):\n 1. nfa_reach A i (bss @ [bs]) (nfa_trans A y bs)", "by (simp add: reach_snoc)"], ["proof (state)\nthis:\n  nfa_reach A i (bss @ [bs]) (nfa_trans A y bs)\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(i, y) \\<in> (succsr (subset_succs A))\\<^sup>*;\n        (y, z) \\<in> succsr (subset_succs A);\n        \\<exists>bss.\n           nfa_reach A i bss y \\<and> list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bss.\n                            nfa_reach A i bss z \\<and>\n                            list_all (is_alph n) bss", "with Z"], ["proof (chain)\npicking this:\n  z = bdd_lookup (subsetbdd (fst A) y (nfa_emptybdd (length y))) bs\n  nfa_reach A i (bss @ [bs]) (nfa_trans A y bs)", "have \"nfa_reach A i (bss @ [bs]) z\""], ["proof (prove)\nusing this:\n  z = bdd_lookup (subsetbdd (fst A) y (nfa_emptybdd (length y))) bs\n  nfa_reach A i (bss @ [bs]) (nfa_trans A y bs)\n\ngoal (1 subgoal):\n 1. nfa_reach A i (bss @ [bs]) z", "by (simp add: nfa_trans_def)"], ["proof (state)\nthis:\n  nfa_reach A i (bss @ [bs]) z\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(i, y) \\<in> (succsr (subset_succs A))\\<^sup>*;\n        (y, z) \\<in> succsr (subset_succs A);\n        \\<exists>bss.\n           nfa_reach A i bss y \\<and> list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bss.\n                            nfa_reach A i bss z \\<and>\n                            list_all (is_alph n) bss", "moreover"], ["proof (state)\nthis:\n  nfa_reach A i (bss @ [bs]) z\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(i, y) \\<in> (succsr (subset_succs A))\\<^sup>*;\n        (y, z) \\<in> succsr (subset_succs A);\n        \\<exists>bss.\n           nfa_reach A i bss y \\<and> list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bss.\n                            nfa_reach A i bss z \\<and>\n                            list_all (is_alph n) bss", "from BS L"], ["proof (chain)\npicking this:\n  nfa_reach A i bss y\n  list_all (is_alph n) bss\n  is_alph n bs", "have \"list_all (is_alph n) (bss @ [bs])\""], ["proof (prove)\nusing this:\n  nfa_reach A i bss y\n  list_all (is_alph n) bss\n  is_alph n bs\n\ngoal (1 subgoal):\n 1. list_all (is_alph n) (bss @ [bs])", "by simp"], ["proof (state)\nthis:\n  list_all (is_alph n) (bss @ [bs])\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(i, y) \\<in> (succsr (subset_succs A))\\<^sup>*;\n        (y, z) \\<in> succsr (subset_succs A);\n        \\<exists>bss.\n           nfa_reach A i bss y \\<and> list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bss.\n                            nfa_reach A i bss z \\<and>\n                            list_all (is_alph n) bss", "moreover"], ["proof (state)\nthis:\n  list_all (is_alph n) (bss @ [bs])\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(i, y) \\<in> (succsr (subset_succs A))\\<^sup>*;\n        (y, z) \\<in> succsr (subset_succs A);\n        \\<exists>bss.\n           nfa_reach A i bss y \\<and> list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bss.\n                            nfa_reach A i bss z \\<and>\n                            list_all (is_alph n) bss", "note BS(2) L"], ["proof (state)\nthis:\n  list_all (is_alph n) bss\n  is_alph n bs\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(i, y) \\<in> (succsr (subset_succs A))\\<^sup>*;\n        (y, z) \\<in> succsr (subset_succs A);\n        \\<exists>bss.\n           nfa_reach A i bss y \\<and> list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bss.\n                            nfa_reach A i bss z \\<and>\n                            list_all (is_alph n) bss", "ultimately"], ["proof (chain)\npicking this:\n  nfa_reach A i (bss @ [bs]) z\n  list_all (is_alph n) (bss @ [bs])\n  list_all (is_alph n) bss\n  is_alph n bs", "show ?case"], ["proof (prove)\nusing this:\n  nfa_reach A i (bss @ [bs]) z\n  list_all (is_alph n) (bss @ [bs])\n  list_all (is_alph n) bss\n  is_alph n bs\n\ngoal (1 subgoal):\n 1. \\<exists>bss. nfa_reach A i bss z \\<and> list_all (is_alph n) bss", "by auto"], ["proof (state)\nthis:\n  \\<exists>bss. nfa_reach A i bss z \\<and> list_all (is_alph n) bss\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>bss. nfa_reach A i bss j \\<and> list_all (is_alph n) bss\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nfa_reach_subset_memb:\n  assumes R: \"nfa_reach A q0 bss q\"\n  and Q0: \"nfa_is_node A q0\"\n  and X: \"list_all (is_alph n) bss\"\n  shows \"subset_memb q (subset_dfs A q0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subset_memb q (subset_dfs A q0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. subset_memb q (subset_dfs A q0)", "from assms well_formed"], ["proof (chain)\npicking this:\n  nfa_reach A q0 bss q\n  nfa_is_node A q0\n  list_all (is_alph n) bss\n  wf_nfa A n", "have Q: \"nfa_is_node A q\""], ["proof (prove)\nusing this:\n  nfa_reach A q0 bss q\n  nfa_is_node A q0\n  list_all (is_alph n) bss\n  wf_nfa A n\n\ngoal (1 subgoal):\n 1. nfa_is_node A q", "by (simp add: nfa_reach_is_node)"], ["proof (state)\nthis:\n  nfa_is_node A q\n\ngoal (1 subgoal):\n 1. subset_memb q (subset_dfs A q0)", "from R X"], ["proof (chain)\npicking this:\n  nfa_reach A q0 bss q\n  list_all (is_alph n) bss", "have \"\\<exists>bs. nfa_reach A q0 bs q \\<and> list_all (is_alph n) bs\""], ["proof (prove)\nusing this:\n  nfa_reach A q0 bss q\n  list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. \\<exists>bs. nfa_reach A q0 bs q \\<and> list_all (is_alph n) bs", "by auto"], ["proof (state)\nthis:\n  \\<exists>bs. nfa_reach A q0 bs q \\<and> list_all (is_alph n) bs\n\ngoal (1 subgoal):\n 1. subset_memb q (subset_dfs A q0)", "with Q0"], ["proof (chain)\npicking this:\n  nfa_is_node A q0\n  \\<exists>bs. nfa_reach A q0 bs q \\<and> list_all (is_alph n) bs", "have \"(q0,q) \\<in> (succsr (subset_succs A))\\<^sup>*\""], ["proof (prove)\nusing this:\n  nfa_is_node A q0\n  \\<exists>bs. nfa_reach A q0 bs q \\<and> list_all (is_alph n) bs\n\ngoal (1 subgoal):\n 1. (q0, q) \\<in> (succsr (subset_succs A))\\<^sup>*", "by (simp add: nfa_reach_rtrancl)"], ["proof (state)\nthis:\n  (q0, q) \\<in> (succsr (subset_succs A))\\<^sup>*\n\ngoal (1 subgoal):\n 1. subset_memb q (subset_dfs A q0)", "with Q0 Q"], ["proof (chain)\npicking this:\n  nfa_is_node A q0\n  nfa_is_node A q\n  (q0, q) \\<in> (succsr (subset_succs A))\\<^sup>*", "show ?thesis"], ["proof (prove)\nusing this:\n  nfa_is_node A q0\n  nfa_is_node A q\n  (q0, q) \\<in> (succsr (subset_succs A))\\<^sup>*\n\ngoal (1 subgoal):\n 1. subset_memb q (subset_dfs A q0)", "by (simp add: dfs_eq_rtrancl)"], ["proof (state)\nthis:\n  subset_memb q (subset_dfs A q0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_nfa_reach':\n  fixes bd :: \"nat option bdd\" and ls :: \"bool list list\"\n  assumes \"subset_dfs A (nfa_startnode A) = (bd, ls)\" (is \"?subset_dfs = _\")\n  and \"\\<exists>bs. nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\"\n  and \"q1 = ls ! i\" and \"q2 = ls ! j\" and \"i < length ls\" and \"j < length ls\"\n  and \"list_all (is_alph n) bss\"\n  shows \"nfa_reach A q1 bss q2 = (dfa_reach (det_nfa A) i bss j \\<and> nfa_is_node A q2)\"\n  (is \"_ = (dfa_reach ?M i bss j \\<and> _)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. nfa_reach A q1 bss q2 =\n    (dfa_reach (det_nfa A) i bss j \\<and> nfa_is_node A q2)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. nfa_reach A q1 bss q2 \\<Longrightarrow>\n    dfa_reach (det_nfa A) i bss j \\<and> nfa_is_node A q2\n 2. dfa_reach (det_nfa A) i bss j \\<and> nfa_is_node A q2 \\<Longrightarrow>\n    nfa_reach A q1 bss q2", "assume \"nfa_reach A q1 bss q2\""], ["proof (state)\nthis:\n  nfa_reach A q1 bss q2\n\ngoal (2 subgoals):\n 1. nfa_reach A q1 bss q2 \\<Longrightarrow>\n    dfa_reach (det_nfa A) i bss j \\<and> nfa_is_node A q2\n 2. dfa_reach (det_nfa A) i bss j \\<and> nfa_is_node A q2 \\<Longrightarrow>\n    nfa_reach A q1 bss q2", "from this assms"], ["proof (chain)\npicking this:\n  nfa_reach A q1 bss q2\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  q2 = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) bss", "show \"dfa_reach ?M i bss j \\<and> nfa_is_node A q2\""], ["proof (prove)\nusing this:\n  nfa_reach A q1 bss q2\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  q2 = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. dfa_reach (det_nfa A) i bss j \\<and> nfa_is_node A q2", "proof (induct arbitrary: j)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q1 = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i [] j \\<and>\n                         nfa_is_node A q1\n 2. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "case (Nil j)"], ["proof (state)\nthis:\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  q1 = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) []\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q1 = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i [] j \\<and>\n                         nfa_is_node A q1\n 2. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "with well_formed"], ["proof (chain)\npicking this:\n  wf_nfa A n\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  q1 = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) []", "have Q0: \"nfa_is_node A (nfa_startnode A)\""], ["proof (prove)\nusing this:\n  wf_nfa A n\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  q1 = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) []\n\ngoal (1 subgoal):\n 1. nfa_is_node A (nfa_startnode A)", "by (simp add: nfa_startnode_is_node)"], ["proof (state)\nthis:\n  nfa_is_node A (nfa_startnode A)\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q1 = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i [] j \\<and>\n                         nfa_is_node A q1\n 2. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "from Nil"], ["proof (chain)\npicking this:\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  q1 = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) []", "obtain bs where \"nfa_reach A (nfa_startnode A) bs q1\" and \"list_all (is_alph n) bs\""], ["proof (prove)\nusing this:\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  q1 = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) []\n\ngoal (1 subgoal):\n 1. (\\<And>bs.\n        \\<lbrakk>nfa_reach A (nfa_startnode A) bs q1;\n         list_all (is_alph n) bs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  nfa_reach A (nfa_startnode A) bs q1\n  list_all (is_alph n) bs\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q1 = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i [] j \\<and>\n                         nfa_is_node A q1\n 2. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "with well_formed Q0 Nil"], ["proof (chain)\npicking this:\n  wf_nfa A n\n  nfa_is_node A (nfa_startnode A)\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  q1 = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) []\n  nfa_reach A (nfa_startnode A) bs q1\n  list_all (is_alph n) bs", "have Q1: \"nfa_is_node A q1\""], ["proof (prove)\nusing this:\n  wf_nfa A n\n  nfa_is_node A (nfa_startnode A)\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  q1 = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) []\n  nfa_reach A (nfa_startnode A) bs q1\n  list_all (is_alph n) bs\n\ngoal (1 subgoal):\n 1. nfa_is_node A q1", "by (simp add: nfa_reach_is_node)"], ["proof (state)\nthis:\n  nfa_is_node A q1\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q1 = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i [] j \\<and>\n                         nfa_is_node A q1\n 2. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "with Q0"], ["proof (chain)\npicking this:\n  nfa_is_node A (nfa_startnode A)\n  nfa_is_node A q1", "have \"\\<And>v. (bdd_lookup (fst (?subset_dfs)) q1 = Some v) = (v < length (snd (?subset_dfs)) \\<and> snd (?subset_dfs) ! v = q1)\""], ["proof (prove)\nusing this:\n  nfa_is_node A (nfa_startnode A)\n  nfa_is_node A q1\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       (bdd_lookup (fst (subset_dfs A (nfa_startnode A))) q1 = Some v) =\n       (v < length (snd (subset_dfs A (nfa_startnode A))) \\<and>\n        snd (subset_dfs A (nfa_startnode A)) ! v = q1)", "by (simp add: subset_dfs_bij)"], ["proof (state)\nthis:\n  (bdd_lookup (fst (subset_dfs A (nfa_startnode A))) q1 = Some ?v) =\n  (?v < length (snd (subset_dfs A (nfa_startnode A))) \\<and>\n   snd (subset_dfs A (nfa_startnode A)) ! ?v = q1)\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q1 = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i [] j \\<and>\n                         nfa_is_node A q1\n 2. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "with Nil(1)"], ["proof (chain)\npicking this:\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  (bdd_lookup (fst (subset_dfs A (nfa_startnode A))) q1 = Some ?v) =\n  (?v < length (snd (subset_dfs A (nfa_startnode A))) \\<and>\n   snd (subset_dfs A (nfa_startnode A)) ! ?v = q1)", "have 1: \"\\<And>v. (bdd_lookup bd q1 = Some v) = (v < length ls \\<and> ls ! v = q1)\""], ["proof (prove)\nusing this:\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  (bdd_lookup (fst (subset_dfs A (nfa_startnode A))) q1 = Some ?v) =\n  (?v < length (snd (subset_dfs A (nfa_startnode A))) \\<and>\n   snd (subset_dfs A (nfa_startnode A)) ! ?v = q1)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       (bdd_lookup bd q1 = Some v) = (v < length ls \\<and> ls ! v = q1)", "by simp"], ["proof (state)\nthis:\n  (bdd_lookup bd q1 = Some ?v) = (?v < length ls \\<and> ls ! ?v = q1)\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q1 = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i [] j \\<and>\n                         nfa_is_node A q1\n 2. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "from Nil 1"], ["proof (chain)\npicking this:\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  q1 = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) []\n  (bdd_lookup bd q1 = Some ?v) = (?v < length ls \\<and> ls ! ?v = q1)", "have \"bdd_lookup bd q1 = Some i\""], ["proof (prove)\nusing this:\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  q1 = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) []\n  (bdd_lookup bd q1 = Some ?v) = (?v < length ls \\<and> ls ! ?v = q1)\n\ngoal (1 subgoal):\n 1. bdd_lookup bd q1 = Some i", "by simp"], ["proof (state)\nthis:\n  bdd_lookup bd q1 = Some i\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q1 = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i [] j \\<and>\n                         nfa_is_node A q1\n 2. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "moreover"], ["proof (state)\nthis:\n  bdd_lookup bd q1 = Some i\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q1 = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i [] j \\<and>\n                         nfa_is_node A q1\n 2. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "from Nil 1"], ["proof (chain)\npicking this:\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  q1 = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) []\n  (bdd_lookup bd q1 = Some ?v) = (?v < length ls \\<and> ls ! ?v = q1)", "have \"bdd_lookup bd q1 = Some j\""], ["proof (prove)\nusing this:\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  q1 = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) []\n  (bdd_lookup bd q1 = Some ?v) = (?v < length ls \\<and> ls ! ?v = q1)\n\ngoal (1 subgoal):\n 1. bdd_lookup bd q1 = Some j", "by simp"], ["proof (state)\nthis:\n  bdd_lookup bd q1 = Some j\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q1 = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i [] j \\<and>\n                         nfa_is_node A q1\n 2. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "ultimately"], ["proof (chain)\npicking this:\n  bdd_lookup bd q1 = Some i\n  bdd_lookup bd q1 = Some j", "have \"i = j\""], ["proof (prove)\nusing this:\n  bdd_lookup bd q1 = Some i\n  bdd_lookup bd q1 = Some j\n\ngoal (1 subgoal):\n 1. i = j", "by simp"], ["proof (state)\nthis:\n  i = j\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q1 = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i [] j \\<and>\n                         nfa_is_node A q1\n 2. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "have \"dfa_reach ?M i [] i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa_reach (det_nfa A) i [] i", "by (simp add: reach_nil)"], ["proof (state)\nthis:\n  dfa_reach (det_nfa A) i [] i\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q1 = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i [] j \\<and>\n                         nfa_is_node A q1\n 2. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "with \\<open>i=j\\<close> Q1"], ["proof (chain)\npicking this:\n  i = j\n  nfa_is_node A q1\n  dfa_reach (det_nfa A) i [] i", "show ?case"], ["proof (prove)\nusing this:\n  i = j\n  nfa_is_node A q1\n  dfa_reach (det_nfa A) i [] i\n\ngoal (1 subgoal):\n 1. dfa_reach (det_nfa A) i [] j \\<and> nfa_is_node A q1", "by simp"], ["proof (state)\nthis:\n  dfa_reach (det_nfa A) i [] j \\<and> nfa_is_node A q1\n\ngoal (1 subgoal):\n 1. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "case (snoc p bss bs j)"], ["proof (state)\nthis:\n  nfa_reach A q1 bss p\n  \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; p = ls ! ?j; i < length ls; ?j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_reach (det_nfa A) i bss ?j \\<and> nfa_is_node A p\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  nfa_trans A p bs = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) (bss @ [bs])\n\ngoal (1 subgoal):\n 1. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "note S_len = nfa_startnode_is_node[OF well_formed]"], ["proof (state)\nthis:\n  nfa_is_node A (nfa_startnode A)\n\ngoal (1 subgoal):\n 1. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "from snoc"], ["proof (chain)\npicking this:\n  nfa_reach A q1 bss p\n  \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; p = ls ! ?j; i < length ls; ?j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_reach (det_nfa A) i bss ?j \\<and> nfa_is_node A p\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  nfa_trans A p bs = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) (bss @ [bs])", "obtain bss' where BSS':\"nfa_reach A (nfa_startnode A) bss' q1\" and BSS'L: \"list_all (is_alph n) bss'\""], ["proof (prove)\nusing this:\n  nfa_reach A q1 bss p\n  \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; p = ls ! ?j; i < length ls; ?j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_reach (det_nfa A) i bss ?j \\<and> nfa_is_node A p\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  nfa_trans A p bs = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) (bss @ [bs])\n\ngoal (1 subgoal):\n 1. (\\<And>bss'.\n        \\<lbrakk>nfa_reach A (nfa_startnode A) bss' q1;\n         list_all (is_alph n) bss'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  nfa_reach A (nfa_startnode A) bss' q1\n  list_all (is_alph n) bss'\n\ngoal (1 subgoal):\n 1. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "with well_formed S_len"], ["proof (chain)\npicking this:\n  wf_nfa A n\n  nfa_is_node A (nfa_startnode A)\n  nfa_reach A (nfa_startnode A) bss' q1\n  list_all (is_alph n) bss'", "have Q_len: \"nfa_is_node A q1\""], ["proof (prove)\nusing this:\n  wf_nfa A n\n  nfa_is_node A (nfa_startnode A)\n  nfa_reach A (nfa_startnode A) bss' q1\n  list_all (is_alph n) bss'\n\ngoal (1 subgoal):\n 1. nfa_is_node A q1", "by (simp add: nfa_reach_is_node)"], ["proof (state)\nthis:\n  nfa_is_node A q1\n\ngoal (1 subgoal):\n 1. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "with well_formed snoc"], ["proof (chain)\npicking this:\n  wf_nfa A n\n  nfa_reach A q1 bss p\n  \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; p = ls ! ?j; i < length ls; ?j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_reach (det_nfa A) i bss ?j \\<and> nfa_is_node A p\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  nfa_trans A p bs = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) (bss @ [bs])\n  nfa_is_node A q1", "have P_len: \"nfa_is_node A p\""], ["proof (prove)\nusing this:\n  wf_nfa A n\n  nfa_reach A q1 bss p\n  \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; p = ls ! ?j; i < length ls; ?j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_reach (det_nfa A) i bss ?j \\<and> nfa_is_node A p\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  nfa_trans A p bs = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) (bss @ [bs])\n  nfa_is_node A q1\n\ngoal (1 subgoal):\n 1. nfa_is_node A p", "by (simp add: nfa_reach_is_node)"], ["proof (state)\nthis:\n  nfa_is_node A p\n\ngoal (1 subgoal):\n 1. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "from BSS' snoc"], ["proof (chain)\npicking this:\n  nfa_reach A (nfa_startnode A) bss' q1\n  nfa_reach A q1 bss p\n  \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; p = ls ! ?j; i < length ls; ?j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_reach (det_nfa A) i bss ?j \\<and> nfa_is_node A p\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  nfa_trans A p bs = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) (bss @ [bs])", "have \"nfa_reach A (nfa_startnode A) (bss' @ bss) p\""], ["proof (prove)\nusing this:\n  nfa_reach A (nfa_startnode A) bss' q1\n  nfa_reach A q1 bss p\n  \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; p = ls ! ?j; i < length ls; ?j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_reach (det_nfa A) i bss ?j \\<and> nfa_is_node A p\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  nfa_trans A p bs = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) (bss @ [bs])\n\ngoal (1 subgoal):\n 1. nfa_reach A (nfa_startnode A) (bss' @ bss) p", "by (simp add: reach_trans)"], ["proof (state)\nthis:\n  nfa_reach A (nfa_startnode A) (bss' @ bss) p\n\ngoal (1 subgoal):\n 1. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "moreover"], ["proof (state)\nthis:\n  nfa_reach A (nfa_startnode A) (bss' @ bss) p\n\ngoal (1 subgoal):\n 1. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "note S_len"], ["proof (state)\nthis:\n  nfa_is_node A (nfa_startnode A)\n\ngoal (1 subgoal):\n 1. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "moreover"], ["proof (state)\nthis:\n  nfa_is_node A (nfa_startnode A)\n\ngoal (1 subgoal):\n 1. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "from snoc BSS'L"], ["proof (chain)\npicking this:\n  nfa_reach A q1 bss p\n  \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; p = ls ! ?j; i < length ls; ?j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_reach (det_nfa A) i bss ?j \\<and> nfa_is_node A p\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  nfa_trans A p bs = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) (bss @ [bs])\n  list_all (is_alph n) bss'", "have \"list_all (is_alph n) (bss' @ bss)\""], ["proof (prove)\nusing this:\n  nfa_reach A q1 bss p\n  \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; p = ls ! ?j; i < length ls; ?j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_reach (det_nfa A) i bss ?j \\<and> nfa_is_node A p\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  nfa_trans A p bs = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) (bss @ [bs])\n  list_all (is_alph n) bss'\n\ngoal (1 subgoal):\n 1. list_all (is_alph n) (bss' @ bss)", "by simp"], ["proof (state)\nthis:\n  list_all (is_alph n) (bss' @ bss)\n\ngoal (1 subgoal):\n 1. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "ultimately"], ["proof (chain)\npicking this:\n  nfa_reach A (nfa_startnode A) (bss' @ bss) p\n  nfa_is_node A (nfa_startnode A)\n  list_all (is_alph n) (bss' @ bss)", "have \"subset_memb p ?subset_dfs\""], ["proof (prove)\nusing this:\n  nfa_reach A (nfa_startnode A) (bss' @ bss) p\n  nfa_is_node A (nfa_startnode A)\n  list_all (is_alph n) (bss' @ bss)\n\ngoal (1 subgoal):\n 1. subset_memb p (subset_dfs A (nfa_startnode A))", "by (rule nfa_reach_subset_memb)"], ["proof (state)\nthis:\n  subset_memb p (subset_dfs A (nfa_startnode A))\n\ngoal (1 subgoal):\n 1. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "hence \"bdd_lookup (fst ?subset_dfs) p \\<noteq> None\""], ["proof (prove)\nusing this:\n  subset_memb p (subset_dfs A (nfa_startnode A))\n\ngoal (1 subgoal):\n 1. bdd_lookup (fst (subset_dfs A (nfa_startnode A))) p \\<noteq> None", "by (simp add: subset_memb_def split_beta)"], ["proof (state)\nthis:\n  bdd_lookup (fst (subset_dfs A (nfa_startnode A))) p \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "then"], ["proof (chain)\npicking this:\n  bdd_lookup (fst (subset_dfs A (nfa_startnode A))) p \\<noteq> None", "obtain v where P: \"bdd_lookup (fst ?subset_dfs) p = Some v\""], ["proof (prove)\nusing this:\n  bdd_lookup (fst (subset_dfs A (nfa_startnode A))) p \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        bdd_lookup (fst (subset_dfs A (nfa_startnode A))) p =\n        Some v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"bdd_lookup (fst ?subset_dfs) p\") simp+"], ["proof (state)\nthis:\n  bdd_lookup (fst (subset_dfs A (nfa_startnode A))) p = Some v\n\ngoal (1 subgoal):\n 1. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "with P_len S_len"], ["proof (chain)\npicking this:\n  nfa_is_node A p\n  nfa_is_node A (nfa_startnode A)\n  bdd_lookup (fst (subset_dfs A (nfa_startnode A))) p = Some v", "have \"v < length (snd (?subset_dfs)) \\<and> snd ?subset_dfs ! v = p\""], ["proof (prove)\nusing this:\n  nfa_is_node A p\n  nfa_is_node A (nfa_startnode A)\n  bdd_lookup (fst (subset_dfs A (nfa_startnode A))) p = Some v\n\ngoal (1 subgoal):\n 1. v < length (snd (subset_dfs A (nfa_startnode A))) \\<and>\n    snd (subset_dfs A (nfa_startnode A)) ! v = p", "by (simp add: subset_dfs_bij)"], ["proof (state)\nthis:\n  v < length (snd (subset_dfs A (nfa_startnode A))) \\<and>\n  snd (subset_dfs A (nfa_startnode A)) ! v = p\n\ngoal (1 subgoal):\n 1. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "with snoc"], ["proof (chain)\npicking this:\n  nfa_reach A q1 bss p\n  \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; p = ls ! ?j; i < length ls; ?j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_reach (det_nfa A) i bss ?j \\<and> nfa_is_node A p\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  nfa_trans A p bs = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) (bss @ [bs])\n  v < length (snd (subset_dfs A (nfa_startnode A))) \\<and>\n  snd (subset_dfs A (nfa_startnode A)) ! v = p", "have V: \"v < length ls \\<and> ls ! v = p\""], ["proof (prove)\nusing this:\n  nfa_reach A q1 bss p\n  \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; p = ls ! ?j; i < length ls; ?j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_reach (det_nfa A) i bss ?j \\<and> nfa_is_node A p\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  nfa_trans A p bs = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) (bss @ [bs])\n  v < length (snd (subset_dfs A (nfa_startnode A))) \\<and>\n  snd (subset_dfs A (nfa_startnode A)) ! v = p\n\ngoal (1 subgoal):\n 1. v < length ls \\<and> ls ! v = p", "by simp"], ["proof (state)\nthis:\n  v < length ls \\<and> ls ! v = p\n\ngoal (1 subgoal):\n 1. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "with snoc P_len"], ["proof (chain)\npicking this:\n  nfa_reach A q1 bss p\n  \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; p = ls ! ?j; i < length ls; ?j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_reach (det_nfa A) i bss ?j \\<and> nfa_is_node A p\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  nfa_trans A p bs = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) (bss @ [bs])\n  nfa_is_node A p\n  v < length ls \\<and> ls ! v = p", "have R: \"dfa_reach ?M i bss v \\<and> nfa_is_node A p\""], ["proof (prove)\nusing this:\n  nfa_reach A q1 bss p\n  \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; p = ls ! ?j; i < length ls; ?j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_reach (det_nfa A) i bss ?j \\<and> nfa_is_node A p\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  nfa_trans A p bs = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) (bss @ [bs])\n  nfa_is_node A p\n  v < length ls \\<and> ls ! v = p\n\ngoal (1 subgoal):\n 1. dfa_reach (det_nfa A) i bss v \\<and> nfa_is_node A p", "by simp"], ["proof (state)\nthis:\n  dfa_reach (det_nfa A) i bss v \\<and> nfa_is_node A p\n\ngoal (1 subgoal):\n 1. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "from snoc"], ["proof (chain)\npicking this:\n  nfa_reach A q1 bss p\n  \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; p = ls ! ?j; i < length ls; ?j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_reach (det_nfa A) i bss ?j \\<and> nfa_is_node A p\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  nfa_trans A p bs = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) (bss @ [bs])", "have BS: \"is_alph n bs\""], ["proof (prove)\nusing this:\n  nfa_reach A q1 bss p\n  \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; p = ls ! ?j; i < length ls; ?j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_reach (det_nfa A) i bss ?j \\<and> nfa_is_node A p\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  nfa_trans A p bs = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) (bss @ [bs])\n\ngoal (1 subgoal):\n 1. is_alph n bs", "by simp"], ["proof (state)\nthis:\n  is_alph n bs\n\ngoal (1 subgoal):\n 1. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "with well_formed P_len"], ["proof (chain)\npicking this:\n  wf_nfa A n\n  nfa_is_node A p\n  is_alph n bs", "have Z: \"nfa_is_node A (nfa_trans A p bs)\""], ["proof (prove)\nusing this:\n  wf_nfa A n\n  nfa_is_node A p\n  is_alph n bs\n\ngoal (1 subgoal):\n 1. nfa_is_node A (nfa_trans A p bs)", "by (simp add: nfa_trans_is_node)"], ["proof (state)\nthis:\n  nfa_is_node A (nfa_trans A p bs)\n\ngoal (1 subgoal):\n 1. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "with snoc"], ["proof (chain)\npicking this:\n  nfa_reach A q1 bss p\n  \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; p = ls ! ?j; i < length ls; ?j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_reach (det_nfa A) i bss ?j \\<and> nfa_is_node A p\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  nfa_trans A p bs = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) (bss @ [bs])\n  nfa_is_node A (nfa_trans A p bs)", "have N: \"nfa_is_node A (ls ! j)\""], ["proof (prove)\nusing this:\n  nfa_reach A q1 bss p\n  \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; p = ls ! ?j; i < length ls; ?j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_reach (det_nfa A) i bss ?j \\<and> nfa_is_node A p\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  nfa_trans A p bs = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) (bss @ [bs])\n  nfa_is_node A (nfa_trans A p bs)\n\ngoal (1 subgoal):\n 1. nfa_is_node A (ls ! j)", "by simp"], ["proof (state)\nthis:\n  nfa_is_node A (ls ! j)\n\ngoal (1 subgoal):\n 1. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "from snoc"], ["proof (chain)\npicking this:\n  nfa_reach A q1 bss p\n  \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; p = ls ! ?j; i < length ls; ?j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_reach (det_nfa A) i bss ?j \\<and> nfa_is_node A p\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  nfa_trans A p bs = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) (bss @ [bs])", "have \"j < length (snd ?subset_dfs) \\<and> snd ?subset_dfs ! j = ls ! j\""], ["proof (prove)\nusing this:\n  nfa_reach A q1 bss p\n  \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; p = ls ! ?j; i < length ls; ?j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_reach (det_nfa A) i bss ?j \\<and> nfa_is_node A p\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  nfa_trans A p bs = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) (bss @ [bs])\n\ngoal (1 subgoal):\n 1. j < length (snd (subset_dfs A (nfa_startnode A))) \\<and>\n    snd (subset_dfs A (nfa_startnode A)) ! j = ls ! j", "by simp"], ["proof (state)\nthis:\n  j < length (snd (subset_dfs A (nfa_startnode A))) \\<and>\n  snd (subset_dfs A (nfa_startnode A)) ! j = ls ! j\n\ngoal (1 subgoal):\n 1. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "with N S_len"], ["proof (chain)\npicking this:\n  nfa_is_node A (ls ! j)\n  nfa_is_node A (nfa_startnode A)\n  j < length (snd (subset_dfs A (nfa_startnode A))) \\<and>\n  snd (subset_dfs A (nfa_startnode A)) ! j = ls ! j", "have \"bdd_lookup (fst ?subset_dfs) (ls ! j) = Some j\""], ["proof (prove)\nusing this:\n  nfa_is_node A (ls ! j)\n  nfa_is_node A (nfa_startnode A)\n  j < length (snd (subset_dfs A (nfa_startnode A))) \\<and>\n  snd (subset_dfs A (nfa_startnode A)) ! j = ls ! j\n\ngoal (1 subgoal):\n 1. bdd_lookup (fst (subset_dfs A (nfa_startnode A))) (ls ! j) = Some j", "by (simp add: subset_dfs_bij)"], ["proof (state)\nthis:\n  bdd_lookup (fst (subset_dfs A (nfa_startnode A))) (ls ! j) = Some j\n\ngoal (1 subgoal):\n 1. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "with snoc"], ["proof (chain)\npicking this:\n  nfa_reach A q1 bss p\n  \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; p = ls ! ?j; i < length ls; ?j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_reach (det_nfa A) i bss ?j \\<and> nfa_is_node A p\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  nfa_trans A p bs = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) (bss @ [bs])\n  bdd_lookup (fst (subset_dfs A (nfa_startnode A))) (ls ! j) = Some j", "have J: \"bdd_lookup bd (ls ! j) = Some j\""], ["proof (prove)\nusing this:\n  nfa_reach A q1 bss p\n  \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; p = ls ! ?j; i < length ls; ?j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_reach (det_nfa A) i bss ?j \\<and> nfa_is_node A p\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  nfa_trans A p bs = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) (bss @ [bs])\n  bdd_lookup (fst (subset_dfs A (nfa_startnode A))) (ls ! j) = Some j\n\ngoal (1 subgoal):\n 1. bdd_lookup bd (ls ! j) = Some j", "by simp"], ["proof (state)\nthis:\n  bdd_lookup bd (ls ! j) = Some j\n\ngoal (1 subgoal):\n 1. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "from snoc"], ["proof (chain)\npicking this:\n  nfa_reach A q1 bss p\n  \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; p = ls ! ?j; i < length ls; ?j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_reach (det_nfa A) i bss ?j \\<and> nfa_is_node A p\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  nfa_trans A p bs = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) (bss @ [bs])", "have BD: \"fst ?M = map (\\<lambda>q. bdd_map (\\<lambda>q. the (bdd_lookup bd q)) (subsetbdd (fst A) q (nfa_emptybdd (length q)))) ls\""], ["proof (prove)\nusing this:\n  nfa_reach A q1 bss p\n  \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; p = ls ! ?j; i < length ls; ?j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_reach (det_nfa A) i bss ?j \\<and> nfa_is_node A p\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  nfa_trans A p bs = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) (bss @ [bs])\n\ngoal (1 subgoal):\n 1. fst (det_nfa A) =\n    map (\\<lambda>q.\n            bdd_map (\\<lambda>q. the (bdd_lookup bd q))\n             (subsetbdd (fst A) q (nfa_emptybdd (length q))))\n     ls", "by (simp add: det_nfa_def)"], ["proof (state)\nthis:\n  fst (det_nfa A) =\n  map (\\<lambda>q.\n          bdd_map (\\<lambda>q. the (bdd_lookup bd q))\n           (subsetbdd (fst A) q (nfa_emptybdd (length q))))\n   ls\n\ngoal (1 subgoal):\n 1. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "with V"], ["proof (chain)\npicking this:\n  v < length ls \\<and> ls ! v = p\n  fst (det_nfa A) =\n  map (\\<lambda>q.\n          bdd_map (\\<lambda>q. the (bdd_lookup bd q))\n           (subsetbdd (fst A) q (nfa_emptybdd (length q))))\n   ls", "have \"fst ?M ! v = bdd_map (\\<lambda>q. the (bdd_lookup bd q)) (subsetbdd (fst A) p (nfa_emptybdd (length p)))\""], ["proof (prove)\nusing this:\n  v < length ls \\<and> ls ! v = p\n  fst (det_nfa A) =\n  map (\\<lambda>q.\n          bdd_map (\\<lambda>q. the (bdd_lookup bd q))\n           (subsetbdd (fst A) q (nfa_emptybdd (length q))))\n   ls\n\ngoal (1 subgoal):\n 1. fst (det_nfa A) ! v =\n    bdd_map (\\<lambda>q. the (bdd_lookup bd q))\n     (subsetbdd (fst A) p (nfa_emptybdd (length p)))", "by simp"], ["proof (state)\nthis:\n  fst (det_nfa A) ! v =\n  bdd_map (\\<lambda>q. the (bdd_lookup bd q))\n   (subsetbdd (fst A) p (nfa_emptybdd (length p)))\n\ngoal (1 subgoal):\n 1. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "with well_formed BS P_len"], ["proof (chain)\npicking this:\n  wf_nfa A n\n  is_alph n bs\n  nfa_is_node A p\n  fst (det_nfa A) ! v =\n  bdd_map (\\<lambda>q. the (bdd_lookup bd q))\n   (subsetbdd (fst A) p (nfa_emptybdd (length p)))", "have \"bdd_lookup (fst ?M ! v) bs = the (bdd_lookup bd (bdd_lookup (subsetbdd (fst A) p (nfa_emptybdd (length p))) bs))\""], ["proof (prove)\nusing this:\n  wf_nfa A n\n  is_alph n bs\n  nfa_is_node A p\n  fst (det_nfa A) ! v =\n  bdd_map (\\<lambda>q. the (bdd_lookup bd q))\n   (subsetbdd (fst A) p (nfa_emptybdd (length p)))\n\ngoal (1 subgoal):\n 1. bdd_lookup (fst (det_nfa A) ! v) bs =\n    the (bdd_lookup bd\n          (bdd_lookup (subsetbdd (fst A) p (nfa_emptybdd (length p))) bs))", "by (auto simp add: bdd_map_bdd_lookup bddh_subsetbdd wf_nfa_def is_alph_def nfa_emptybdd_def)"], ["proof (state)\nthis:\n  bdd_lookup (fst (det_nfa A) ! v) bs =\n  the (bdd_lookup bd\n        (bdd_lookup (subsetbdd (fst A) p (nfa_emptybdd (length p))) bs))\n\ngoal (1 subgoal):\n 1. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "also"], ["proof (state)\nthis:\n  bdd_lookup (fst (det_nfa A) ! v) bs =\n  the (bdd_lookup bd\n        (bdd_lookup (subsetbdd (fst A) p (nfa_emptybdd (length p))) bs))\n\ngoal (1 subgoal):\n 1. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "from snoc J"], ["proof (chain)\npicking this:\n  nfa_reach A q1 bss p\n  \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; p = ls ! ?j; i < length ls; ?j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_reach (det_nfa A) i bss ?j \\<and> nfa_is_node A p\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  nfa_trans A p bs = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) (bss @ [bs])\n  bdd_lookup bd (ls ! j) = Some j", "have \"\\<dots> = j\""], ["proof (prove)\nusing this:\n  nfa_reach A q1 bss p\n  \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; p = ls ! ?j; i < length ls; ?j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_reach (det_nfa A) i bss ?j \\<and> nfa_is_node A p\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  nfa_trans A p bs = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) (bss @ [bs])\n  bdd_lookup bd (ls ! j) = Some j\n\ngoal (1 subgoal):\n 1. the (bdd_lookup bd\n          (bdd_lookup (subsetbdd (fst A) p (nfa_emptybdd (length p))) bs)) =\n    j", "by (simp add: nfa_trans_def)"], ["proof (state)\nthis:\n  the (bdd_lookup bd\n        (bdd_lookup (subsetbdd (fst A) p (nfa_emptybdd (length p))) bs)) =\n  j\n\ngoal (1 subgoal):\n 1. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "finally"], ["proof (chain)\npicking this:\n  bdd_lookup (fst (det_nfa A) ! v) bs = j", "have JJ: \"bdd_lookup (fst ?M ! v) bs = j\""], ["proof (prove)\nusing this:\n  bdd_lookup (fst (det_nfa A) ! v) bs = j\n\ngoal (1 subgoal):\n 1. bdd_lookup (fst (det_nfa A) ! v) bs = j", "."], ["proof (state)\nthis:\n  bdd_lookup (fst (det_nfa A) ! v) bs = j\n\ngoal (1 subgoal):\n 1. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "from R BS JJ"], ["proof (chain)\npicking this:\n  dfa_reach (det_nfa A) i bss v \\<and> nfa_is_node A p\n  is_alph n bs\n  bdd_lookup (fst (det_nfa A) ! v) bs = j", "have RR: \"dfa_reach ?M i (bss @ [bs]) j\""], ["proof (prove)\nusing this:\n  dfa_reach (det_nfa A) i bss v \\<and> nfa_is_node A p\n  is_alph n bs\n  bdd_lookup (fst (det_nfa A) ! v) bs = j\n\ngoal (1 subgoal):\n 1. dfa_reach (det_nfa A) i (bss @ [bs]) j", "by (auto simp add: reach_snoc dfa_trans_def[symmetric])"], ["proof (state)\nthis:\n  dfa_reach (det_nfa A) i (bss @ [bs]) j\n\ngoal (1 subgoal):\n 1. \\<And>k x y j.\n       \\<lbrakk>nfa_reach A q1 x k;\n        \\<And>j.\n           \\<lbrakk>subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; k = ls ! j; i < length ls; j < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> dfa_reach (det_nfa A) i x j \\<and>\n                             nfa_is_node A k;\n        subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; nfa_trans A k y = ls ! j; i < length ls; j < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> dfa_reach (det_nfa A) i (x @ [y]) j \\<and>\n                         nfa_is_node A (nfa_trans A k y)", "with Z"], ["proof (chain)\npicking this:\n  nfa_is_node A (nfa_trans A p bs)\n  dfa_reach (det_nfa A) i (bss @ [bs]) j", "show ?case"], ["proof (prove)\nusing this:\n  nfa_is_node A (nfa_trans A p bs)\n  dfa_reach (det_nfa A) i (bss @ [bs]) j\n\ngoal (1 subgoal):\n 1. dfa_reach (det_nfa A) i (bss @ [bs]) j \\<and>\n    nfa_is_node A (nfa_trans A p bs)", "by simp"], ["proof (state)\nthis:\n  dfa_reach (det_nfa A) i (bss @ [bs]) j \\<and>\n  nfa_is_node A (nfa_trans A p bs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dfa_reach (det_nfa A) i bss j \\<and> nfa_is_node A q2\n\ngoal (1 subgoal):\n 1. dfa_reach (det_nfa A) i bss j \\<and> nfa_is_node A q2 \\<Longrightarrow>\n    nfa_reach A q1 bss q2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. dfa_reach (det_nfa A) i bss j \\<and> nfa_is_node A q2 \\<Longrightarrow>\n    nfa_reach A q1 bss q2", "assume \"dfa_reach ?M i bss j \\<and> nfa_is_node A q2\""], ["proof (state)\nthis:\n  dfa_reach (det_nfa A) i bss j \\<and> nfa_is_node A q2\n\ngoal (1 subgoal):\n 1. dfa_reach (det_nfa A) i bss j \\<and> nfa_is_node A q2 \\<Longrightarrow>\n    nfa_reach A q1 bss q2", "hence \"dfa_reach ?M i bss j\" and \"nfa_is_node A q2\""], ["proof (prove)\nusing this:\n  dfa_reach (det_nfa A) i bss j \\<and> nfa_is_node A q2\n\ngoal (1 subgoal):\n 1. dfa_reach (det_nfa A) i bss j &&& nfa_is_node A q2", "by simp+"], ["proof (state)\nthis:\n  dfa_reach (det_nfa A) i bss j\n  nfa_is_node A q2\n\ngoal (1 subgoal):\n 1. dfa_reach (det_nfa A) i bss j \\<and> nfa_is_node A q2 \\<Longrightarrow>\n    nfa_reach A q1 bss q2", "from this assms"], ["proof (chain)\npicking this:\n  dfa_reach (det_nfa A) i bss j\n  nfa_is_node A q2\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  q2 = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) bss", "show \"nfa_reach A q1 bss q2\""], ["proof (prove)\nusing this:\n  dfa_reach (det_nfa A) i bss j\n  nfa_is_node A q2\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  q2 = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. nfa_reach A q1 bss q2", "proof (induct arbitrary: q2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "case (snoc j bss bs q2)"], ["proof (state)\nthis:\n  dfa_reach (det_nfa A) i bss j\n  \\<lbrakk>nfa_is_node A ?q2.0; subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; ?q2.0 = ls ! j; i < length ls; j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> nfa_reach A q1 bss ?q2.0\n  nfa_is_node A q2\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  q2 = ls ! dfa_trans (det_nfa A) j bs\n  i < length ls\n  dfa_trans (det_nfa A) j bs < length ls\n  list_all (is_alph n) (bss @ [bs])\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "define v where \"v = bdd_lookup (fst ?M ! j) bs\""], ["proof (state)\nthis:\n  v = bdd_lookup (fst (det_nfa A) ! j) bs\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "define qq where \"qq = nfa_trans A (ls ! j) bs\""], ["proof (state)\nthis:\n  qq = nfa_trans A (ls ! j) bs\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "from well_formed"], ["proof (chain)\npicking this:\n  wf_nfa A n", "have Q0: \"nfa_is_node A (nfa_startnode A)\""], ["proof (prove)\nusing this:\n  wf_nfa A n\n\ngoal (1 subgoal):\n 1. nfa_is_node A (nfa_startnode A)", "by (simp add: nfa_startnode_is_node)"], ["proof (state)\nthis:\n  nfa_is_node A (nfa_startnode A)\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "from snoc"], ["proof (chain)\npicking this:\n  dfa_reach (det_nfa A) i bss j\n  \\<lbrakk>nfa_is_node A ?q2.0; subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; ?q2.0 = ls ! j; i < length ls; j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> nfa_reach A q1 bss ?q2.0\n  nfa_is_node A q2\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  q2 = ls ! dfa_trans (det_nfa A) j bs\n  i < length ls\n  dfa_trans (det_nfa A) j bs < length ls\n  list_all (is_alph n) (bss @ [bs])", "have L: \"length (fst ?M) = length ls\""], ["proof (prove)\nusing this:\n  dfa_reach (det_nfa A) i bss j\n  \\<lbrakk>nfa_is_node A ?q2.0; subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; ?q2.0 = ls ! j; i < length ls; j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> nfa_reach A q1 bss ?q2.0\n  nfa_is_node A q2\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  q2 = ls ! dfa_trans (det_nfa A) j bs\n  i < length ls\n  dfa_trans (det_nfa A) j bs < length ls\n  list_all (is_alph n) (bss @ [bs])\n\ngoal (1 subgoal):\n 1. length (fst (det_nfa A)) = length ls", "by (simp add: det_nfa_def)"], ["proof (state)\nthis:\n  length (fst (det_nfa A)) = length ls\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "with snoc"], ["proof (chain)\npicking this:\n  dfa_reach (det_nfa A) i bss j\n  \\<lbrakk>nfa_is_node A ?q2.0; subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; ?q2.0 = ls ! j; i < length ls; j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> nfa_reach A q1 bss ?q2.0\n  nfa_is_node A q2\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  q2 = ls ! dfa_trans (det_nfa A) j bs\n  i < length ls\n  dfa_trans (det_nfa A) j bs < length ls\n  list_all (is_alph n) (bss @ [bs])\n  length (fst (det_nfa A)) = length ls", "have \"dfa_is_node ?M i\""], ["proof (prove)\nusing this:\n  dfa_reach (det_nfa A) i bss j\n  \\<lbrakk>nfa_is_node A ?q2.0; subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; ?q2.0 = ls ! j; i < length ls; j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> nfa_reach A q1 bss ?q2.0\n  nfa_is_node A q2\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  q2 = ls ! dfa_trans (det_nfa A) j bs\n  i < length ls\n  dfa_trans (det_nfa A) j bs < length ls\n  list_all (is_alph n) (bss @ [bs])\n  length (fst (det_nfa A)) = length ls\n\ngoal (1 subgoal):\n 1. dfa_is_node (det_nfa A) i", "by (simp add: dfa_is_node_def)"], ["proof (state)\nthis:\n  dfa_is_node (det_nfa A) i\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "moreover"], ["proof (state)\nthis:\n  dfa_is_node (det_nfa A) i\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "note \\<open>dfa_reach ?M i bss j\\<close>"], ["proof (state)\nthis:\n  dfa_reach (det_nfa A) i bss j\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "moreover"], ["proof (state)\nthis:\n  dfa_reach (det_nfa A) i bss j\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "from snoc"], ["proof (chain)\npicking this:\n  dfa_reach (det_nfa A) i bss j\n  \\<lbrakk>nfa_is_node A ?q2.0; subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; ?q2.0 = ls ! j; i < length ls; j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> nfa_reach A q1 bss ?q2.0\n  nfa_is_node A q2\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  q2 = ls ! dfa_trans (det_nfa A) j bs\n  i < length ls\n  dfa_trans (det_nfa A) j bs < length ls\n  list_all (is_alph n) (bss @ [bs])", "have \"wf_dfa ?M n\""], ["proof (prove)\nusing this:\n  dfa_reach (det_nfa A) i bss j\n  \\<lbrakk>nfa_is_node A ?q2.0; subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; ?q2.0 = ls ! j; i < length ls; j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> nfa_reach A q1 bss ?q2.0\n  nfa_is_node A q2\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  q2 = ls ! dfa_trans (det_nfa A) j bs\n  i < length ls\n  dfa_trans (det_nfa A) j bs < length ls\n  list_all (is_alph n) (bss @ [bs])\n\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "by (simp add: det_wf_nfa)"], ["proof (state)\nthis:\n  wf_dfa (det_nfa A) n\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "moreover"], ["proof (state)\nthis:\n  wf_dfa (det_nfa A) n\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "from snoc"], ["proof (chain)\npicking this:\n  dfa_reach (det_nfa A) i bss j\n  \\<lbrakk>nfa_is_node A ?q2.0; subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; ?q2.0 = ls ! j; i < length ls; j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> nfa_reach A q1 bss ?q2.0\n  nfa_is_node A q2\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  q2 = ls ! dfa_trans (det_nfa A) j bs\n  i < length ls\n  dfa_trans (det_nfa A) j bs < length ls\n  list_all (is_alph n) (bss @ [bs])", "have \"list_all (is_alph n) bss\""], ["proof (prove)\nusing this:\n  dfa_reach (det_nfa A) i bss j\n  \\<lbrakk>nfa_is_node A ?q2.0; subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; ?q2.0 = ls ! j; i < length ls; j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> nfa_reach A q1 bss ?q2.0\n  nfa_is_node A q2\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  q2 = ls ! dfa_trans (det_nfa A) j bs\n  i < length ls\n  dfa_trans (det_nfa A) j bs < length ls\n  list_all (is_alph n) (bss @ [bs])\n\ngoal (1 subgoal):\n 1. list_all (is_alph n) bss", "by simp"], ["proof (state)\nthis:\n  list_all (is_alph n) bss\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "ultimately"], ["proof (chain)\npicking this:\n  dfa_is_node (det_nfa A) i\n  dfa_reach (det_nfa A) i bss j\n  wf_dfa (det_nfa A) n\n  list_all (is_alph n) bss", "have \"dfa_is_node ?M j\""], ["proof (prove)\nusing this:\n  dfa_is_node (det_nfa A) i\n  dfa_reach (det_nfa A) i bss j\n  wf_dfa (det_nfa A) n\n  list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. dfa_is_node (det_nfa A) j", "by (simp add: dfa_reach_is_node)"], ["proof (state)\nthis:\n  dfa_is_node (det_nfa A) j\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "with L"], ["proof (chain)\npicking this:\n  length (fst (det_nfa A)) = length ls\n  dfa_is_node (det_nfa A) j", "have J_len: \"j < length ls\""], ["proof (prove)\nusing this:\n  length (fst (det_nfa A)) = length ls\n  dfa_is_node (det_nfa A) j\n\ngoal (1 subgoal):\n 1. j < length ls", "by (simp add: dfa_is_node_def)"], ["proof (state)\nthis:\n  j < length ls\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "from Q0"], ["proof (chain)\npicking this:\n  nfa_is_node A (nfa_startnode A)", "have \"list_all (nfa_is_node A) (snd ?subset_dfs)\""], ["proof (prove)\nusing this:\n  nfa_is_node A (nfa_startnode A)\n\ngoal (1 subgoal):\n 1. list_all (nfa_is_node A) (snd (subset_dfs A (nfa_startnode A)))", "by (rule subset_dfs_is_node)"], ["proof (state)\nthis:\n  list_all (nfa_is_node A) (snd (subset_dfs A (nfa_startnode A)))\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "with snoc J_len"], ["proof (chain)\npicking this:\n  dfa_reach (det_nfa A) i bss j\n  \\<lbrakk>nfa_is_node A ?q2.0; subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; ?q2.0 = ls ! j; i < length ls; j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> nfa_reach A q1 bss ?q2.0\n  nfa_is_node A q2\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  q2 = ls ! dfa_trans (det_nfa A) j bs\n  i < length ls\n  dfa_trans (det_nfa A) j bs < length ls\n  list_all (is_alph n) (bss @ [bs])\n  j < length ls\n  list_all (nfa_is_node A) (snd (subset_dfs A (nfa_startnode A)))", "have J: \"nfa_is_node A (ls ! j)\""], ["proof (prove)\nusing this:\n  dfa_reach (det_nfa A) i bss j\n  \\<lbrakk>nfa_is_node A ?q2.0; subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; ?q2.0 = ls ! j; i < length ls; j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> nfa_reach A q1 bss ?q2.0\n  nfa_is_node A q2\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  q2 = ls ! dfa_trans (det_nfa A) j bs\n  i < length ls\n  dfa_trans (det_nfa A) j bs < length ls\n  list_all (is_alph n) (bss @ [bs])\n  j < length ls\n  list_all (nfa_is_node A) (snd (subset_dfs A (nfa_startnode A)))\n\ngoal (1 subgoal):\n 1. nfa_is_node A (ls ! j)", "by (simp add: list_all_iff)"], ["proof (state)\nthis:\n  nfa_is_node A (ls ! j)\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "moreover"], ["proof (state)\nthis:\n  nfa_is_node A (ls ! j)\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "note snoc(4,5,6) refl[of \"ls!j\"] snoc(8) J_len"], ["proof (state)\nthis:\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  ls ! j = ls ! j\n  i < length ls\n  j < length ls\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "moreover"], ["proof (state)\nthis:\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  ls ! j = ls ! j\n  i < length ls\n  j < length ls\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "from snoc"], ["proof (chain)\npicking this:\n  dfa_reach (det_nfa A) i bss j\n  \\<lbrakk>nfa_is_node A ?q2.0; subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; ?q2.0 = ls ! j; i < length ls; j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> nfa_reach A q1 bss ?q2.0\n  nfa_is_node A q2\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  q2 = ls ! dfa_trans (det_nfa A) j bs\n  i < length ls\n  dfa_trans (det_nfa A) j bs < length ls\n  list_all (is_alph n) (bss @ [bs])", "have \"list_all (is_alph n) bss\""], ["proof (prove)\nusing this:\n  dfa_reach (det_nfa A) i bss j\n  \\<lbrakk>nfa_is_node A ?q2.0; subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; ?q2.0 = ls ! j; i < length ls; j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> nfa_reach A q1 bss ?q2.0\n  nfa_is_node A q2\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  q2 = ls ! dfa_trans (det_nfa A) j bs\n  i < length ls\n  dfa_trans (det_nfa A) j bs < length ls\n  list_all (is_alph n) (bss @ [bs])\n\ngoal (1 subgoal):\n 1. list_all (is_alph n) bss", "by simp"], ["proof (state)\nthis:\n  list_all (is_alph n) bss\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "ultimately"], ["proof (chain)\npicking this:\n  nfa_is_node A (ls ! j)\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  ls ! j = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) bss", "have R: \"nfa_reach A q1 bss (ls ! j)\""], ["proof (prove)\nusing this:\n  nfa_is_node A (ls ! j)\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  ls ! j = ls ! j\n  i < length ls\n  j < length ls\n  list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. nfa_reach A q1 bss (ls ! j)", "by (rule snoc(2))"], ["proof (state)\nthis:\n  nfa_reach A q1 bss (ls ! j)\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "from snoc"], ["proof (chain)\npicking this:\n  dfa_reach (det_nfa A) i bss j\n  \\<lbrakk>nfa_is_node A ?q2.0; subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; ?q2.0 = ls ! j; i < length ls; j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> nfa_reach A q1 bss ?q2.0\n  nfa_is_node A q2\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  q2 = ls ! dfa_trans (det_nfa A) j bs\n  i < length ls\n  dfa_trans (det_nfa A) j bs < length ls\n  list_all (is_alph n) (bss @ [bs])", "obtain bs' where R': \"nfa_reach A (nfa_startnode A) bs' q1\" and BS': \"list_all (is_alph n) bs'\""], ["proof (prove)\nusing this:\n  dfa_reach (det_nfa A) i bss j\n  \\<lbrakk>nfa_is_node A ?q2.0; subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; ?q2.0 = ls ! j; i < length ls; j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> nfa_reach A q1 bss ?q2.0\n  nfa_is_node A q2\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  q2 = ls ! dfa_trans (det_nfa A) j bs\n  i < length ls\n  dfa_trans (det_nfa A) j bs < length ls\n  list_all (is_alph n) (bss @ [bs])\n\ngoal (1 subgoal):\n 1. (\\<And>bs'.\n        \\<lbrakk>nfa_reach A (nfa_startnode A) bs' q1;\n         list_all (is_alph n) bs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  nfa_reach A (nfa_startnode A) bs' q1\n  list_all (is_alph n) bs'\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "with R"], ["proof (chain)\npicking this:\n  nfa_reach A q1 bss (ls ! j)\n  nfa_reach A (nfa_startnode A) bs' q1\n  list_all (is_alph n) bs'", "have lsj: \"nfa_reach A (nfa_startnode A) (bs' @ bss) (ls ! j)\""], ["proof (prove)\nusing this:\n  nfa_reach A q1 bss (ls ! j)\n  nfa_reach A (nfa_startnode A) bs' q1\n  list_all (is_alph n) bs'\n\ngoal (1 subgoal):\n 1. nfa_reach A (nfa_startnode A) (bs' @ bss) (ls ! j)", "by (simp add: reach_trans)"], ["proof (state)\nthis:\n  nfa_reach A (nfa_startnode A) (bs' @ bss) (ls ! j)\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "hence \"nfa_reach A (nfa_startnode A) ((bs' @ bss) @ [bs]) qq\""], ["proof (prove)\nusing this:\n  nfa_reach A (nfa_startnode A) (bs' @ bss) (ls ! j)\n\ngoal (1 subgoal):\n 1. nfa_reach A (nfa_startnode A) ((bs' @ bss) @ [bs]) qq", "unfolding qq_def"], ["proof (prove)\nusing this:\n  nfa_reach A (nfa_startnode A) (bs' @ bss) (ls ! j)\n\ngoal (1 subgoal):\n 1. nfa_reach A (nfa_startnode A) ((bs' @ bss) @ [bs])\n     (nfa_trans A (ls ! j) bs)", "by (rule reach_snoc)"], ["proof (state)\nthis:\n  nfa_reach A (nfa_startnode A) ((bs' @ bss) @ [bs]) qq\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "with well_formed snoc(10) Q0 BS'"], ["proof (chain)\npicking this:\n  wf_nfa A n\n  list_all (is_alph n) (bss @ [bs])\n  nfa_is_node A (nfa_startnode A)\n  list_all (is_alph n) bs'\n  nfa_reach A (nfa_startnode A) ((bs' @ bss) @ [bs]) qq", "have M: \"subset_memb qq ?subset_dfs\" and QQ_len: \"nfa_is_node A qq\""], ["proof (prove)\nusing this:\n  wf_nfa A n\n  list_all (is_alph n) (bss @ [bs])\n  nfa_is_node A (nfa_startnode A)\n  list_all (is_alph n) bs'\n  nfa_reach A (nfa_startnode A) ((bs' @ bss) @ [bs]) qq\n\ngoal (1 subgoal):\n 1. subset_memb qq (subset_dfs A (nfa_startnode A)) &&& nfa_is_node A qq", "by (simp add: nfa_reach_subset_memb nfa_reach_is_node)+"], ["proof (state)\nthis:\n  subset_memb qq (subset_dfs A (nfa_startnode A))\n  nfa_is_node A qq\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "with snoc(4)"], ["proof (chain)\npicking this:\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  subset_memb qq (subset_dfs A (nfa_startnode A))\n  nfa_is_node A qq", "have QQ: \"bdd_lookup bd qq \\<noteq> None\""], ["proof (prove)\nusing this:\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  subset_memb qq (subset_dfs A (nfa_startnode A))\n  nfa_is_node A qq\n\ngoal (1 subgoal):\n 1. bdd_lookup bd qq \\<noteq> None", "by (simp add: subset_memb_def)"], ["proof (state)\nthis:\n  bdd_lookup bd qq \\<noteq> None\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "from well_formed snoc J"], ["proof (chain)\npicking this:\n  wf_nfa A n\n  dfa_reach (det_nfa A) i bss j\n  \\<lbrakk>nfa_is_node A ?q2.0; subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; ?q2.0 = ls ! j; i < length ls; j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> nfa_reach A q1 bss ?q2.0\n  nfa_is_node A q2\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  q2 = ls ! dfa_trans (det_nfa A) j bs\n  i < length ls\n  dfa_trans (det_nfa A) j bs < length ls\n  list_all (is_alph n) (bss @ [bs])\n  nfa_is_node A (ls ! j)", "have H: \"bddh (length bs) (subsetbdd (fst A) (ls ! j) (nfa_emptybdd (length (ls ! j))))\""], ["proof (prove)\nusing this:\n  wf_nfa A n\n  dfa_reach (det_nfa A) i bss j\n  \\<lbrakk>nfa_is_node A ?q2.0; subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; ?q2.0 = ls ! j; i < length ls; j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> nfa_reach A q1 bss ?q2.0\n  nfa_is_node A q2\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  q2 = ls ! dfa_trans (det_nfa A) j bs\n  i < length ls\n  dfa_trans (det_nfa A) j bs < length ls\n  list_all (is_alph n) (bss @ [bs])\n  nfa_is_node A (ls ! j)\n\ngoal (1 subgoal):\n 1. bddh (length bs)\n     (subsetbdd (fst A) (ls ! j) (nfa_emptybdd (length (ls ! j))))", "by (simp add: bddh_subsetbdd wf_nfa_def nfa_emptybdd_def is_alph_def)"], ["proof (state)\nthis:\n  bddh (length bs)\n   (subsetbdd (fst A) (ls ! j) (nfa_emptybdd (length (ls ! j))))\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "from v_def"], ["proof (chain)\npicking this:\n  v = bdd_lookup (fst (det_nfa A) ! j) bs", "have \"v = bdd_lookup (fst ?M ! j) bs\""], ["proof (prove)\nusing this:\n  v = bdd_lookup (fst (det_nfa A) ! j) bs\n\ngoal (1 subgoal):\n 1. v = bdd_lookup (fst (det_nfa A) ! j) bs", "by simp"], ["proof (state)\nthis:\n  v = bdd_lookup (fst (det_nfa A) ! j) bs\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "also"], ["proof (state)\nthis:\n  v = bdd_lookup (fst (det_nfa A) ! j) bs\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "from snoc(4)"], ["proof (chain)\npicking this:\n  subset_dfs A (nfa_startnode A) = (bd, ls)", "have \"\\<dots> = bdd_lookup (map (\\<lambda>q. bdd_map (\\<lambda>q. the (bdd_lookup bd q)) (subsetbdd (fst A) q (nfa_emptybdd (length q)))) ls ! j) bs\""], ["proof (prove)\nusing this:\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n\ngoal (1 subgoal):\n 1. bdd_lookup (fst (det_nfa A) ! j) bs =\n    bdd_lookup\n     (map (\\<lambda>q.\n              bdd_map (\\<lambda>q. the (bdd_lookup bd q))\n               (subsetbdd (fst A) q (nfa_emptybdd (length q))))\n       ls !\n      j)\n     bs", "by (simp add: det_nfa_def)"], ["proof (state)\nthis:\n  bdd_lookup (fst (det_nfa A) ! j) bs =\n  bdd_lookup\n   (map (\\<lambda>q.\n            bdd_map (\\<lambda>q. the (bdd_lookup bd q))\n             (subsetbdd (fst A) q (nfa_emptybdd (length q))))\n     ls !\n    j)\n   bs\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "also"], ["proof (state)\nthis:\n  bdd_lookup (fst (det_nfa A) ! j) bs =\n  bdd_lookup\n   (map (\\<lambda>q.\n            bdd_map (\\<lambda>q. the (bdd_lookup bd q))\n             (subsetbdd (fst A) q (nfa_emptybdd (length q))))\n     ls !\n    j)\n   bs\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "from J_len"], ["proof (chain)\npicking this:\n  j < length ls", "have \"\\<dots> = bdd_lookup (bdd_map (\\<lambda>q. the (bdd_lookup bd q)) (subsetbdd (fst A) (ls ! j) (nfa_emptybdd (length (ls ! j))))) bs\""], ["proof (prove)\nusing this:\n  j < length ls\n\ngoal (1 subgoal):\n 1. bdd_lookup\n     (map (\\<lambda>q.\n              bdd_map (\\<lambda>q. the (bdd_lookup bd q))\n               (subsetbdd (fst A) q (nfa_emptybdd (length q))))\n       ls !\n      j)\n     bs =\n    bdd_lookup\n     (bdd_map (\\<lambda>q. the (bdd_lookup bd q))\n       (subsetbdd (fst A) (ls ! j) (nfa_emptybdd (length (ls ! j)))))\n     bs", "by simp"], ["proof (state)\nthis:\n  bdd_lookup\n   (map (\\<lambda>q.\n            bdd_map (\\<lambda>q. the (bdd_lookup bd q))\n             (subsetbdd (fst A) q (nfa_emptybdd (length q))))\n     ls !\n    j)\n   bs =\n  bdd_lookup\n   (bdd_map (\\<lambda>q. the (bdd_lookup bd q))\n     (subsetbdd (fst A) (ls ! j) (nfa_emptybdd (length (ls ! j)))))\n   bs\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "also"], ["proof (state)\nthis:\n  bdd_lookup\n   (map (\\<lambda>q.\n            bdd_map (\\<lambda>q. the (bdd_lookup bd q))\n             (subsetbdd (fst A) q (nfa_emptybdd (length q))))\n     ls !\n    j)\n   bs =\n  bdd_lookup\n   (bdd_map (\\<lambda>q. the (bdd_lookup bd q))\n     (subsetbdd (fst A) (ls ! j) (nfa_emptybdd (length (ls ! j)))))\n   bs\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "from H"], ["proof (chain)\npicking this:\n  bddh (length bs)\n   (subsetbdd (fst A) (ls ! j) (nfa_emptybdd (length (ls ! j))))", "have \"\\<dots> = the (bdd_lookup bd (bdd_lookup (subsetbdd (fst A) (ls ! j) (nfa_emptybdd (length (ls ! j)))) bs))\""], ["proof (prove)\nusing this:\n  bddh (length bs)\n   (subsetbdd (fst A) (ls ! j) (nfa_emptybdd (length (ls ! j))))\n\ngoal (1 subgoal):\n 1. bdd_lookup\n     (bdd_map (\\<lambda>q. the (bdd_lookup bd q))\n       (subsetbdd (fst A) (ls ! j) (nfa_emptybdd (length (ls ! j)))))\n     bs =\n    the (bdd_lookup bd\n          (bdd_lookup\n            (subsetbdd (fst A) (ls ! j) (nfa_emptybdd (length (ls ! j))))\n            bs))", "by (simp add: bdd_map_bdd_lookup)"], ["proof (state)\nthis:\n  bdd_lookup\n   (bdd_map (\\<lambda>q. the (bdd_lookup bd q))\n     (subsetbdd (fst A) (ls ! j) (nfa_emptybdd (length (ls ! j)))))\n   bs =\n  the (bdd_lookup bd\n        (bdd_lookup\n          (subsetbdd (fst A) (ls ! j) (nfa_emptybdd (length (ls ! j)))) bs))\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "also"], ["proof (state)\nthis:\n  bdd_lookup\n   (bdd_map (\\<lambda>q. the (bdd_lookup bd q))\n     (subsetbdd (fst A) (ls ! j) (nfa_emptybdd (length (ls ! j)))))\n   bs =\n  the (bdd_lookup bd\n        (bdd_lookup\n          (subsetbdd (fst A) (ls ! j) (nfa_emptybdd (length (ls ! j)))) bs))\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "from qq_def"], ["proof (chain)\npicking this:\n  qq = nfa_trans A (ls ! j) bs", "have \"\\<dots> = the (bdd_lookup bd qq)\""], ["proof (prove)\nusing this:\n  qq = nfa_trans A (ls ! j) bs\n\ngoal (1 subgoal):\n 1. the (bdd_lookup bd\n          (bdd_lookup\n            (subsetbdd (fst A) (ls ! j) (nfa_emptybdd (length (ls ! j))))\n            bs)) =\n    the (bdd_lookup bd qq)", "by (simp add: nfa_trans_def)"], ["proof (state)\nthis:\n  the (bdd_lookup bd\n        (bdd_lookup\n          (subsetbdd (fst A) (ls ! j) (nfa_emptybdd (length (ls ! j))))\n          bs)) =\n  the (bdd_lookup bd qq)\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "finally"], ["proof (chain)\npicking this:\n  v = the (bdd_lookup bd qq)", "have \"v = the (bdd_lookup bd qq)\""], ["proof (prove)\nusing this:\n  v = the (bdd_lookup bd qq)\n\ngoal (1 subgoal):\n 1. v = the (bdd_lookup bd qq)", "."], ["proof (state)\nthis:\n  v = the (bdd_lookup bd qq)\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "with QQ"], ["proof (chain)\npicking this:\n  bdd_lookup bd qq \\<noteq> None\n  v = the (bdd_lookup bd qq)", "have QQ': \"bdd_lookup bd qq = Some v\""], ["proof (prove)\nusing this:\n  bdd_lookup bd qq \\<noteq> None\n  v = the (bdd_lookup bd qq)\n\ngoal (1 subgoal):\n 1. bdd_lookup bd qq = Some v", "by (cases \"bdd_lookup bd qq\") simp+"], ["proof (state)\nthis:\n  bdd_lookup bd qq = Some v\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "with snoc(4)"], ["proof (chain)\npicking this:\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  bdd_lookup bd qq = Some v", "have \"bdd_lookup (fst ?subset_dfs) qq = Some v\""], ["proof (prove)\nusing this:\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  bdd_lookup bd qq = Some v\n\ngoal (1 subgoal):\n 1. bdd_lookup (fst (subset_dfs A (nfa_startnode A))) qq = Some v", "by simp"], ["proof (state)\nthis:\n  bdd_lookup (fst (subset_dfs A (nfa_startnode A))) qq = Some v\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "with QQ_len Q0"], ["proof (chain)\npicking this:\n  nfa_is_node A qq\n  nfa_is_node A (nfa_startnode A)\n  bdd_lookup (fst (subset_dfs A (nfa_startnode A))) qq = Some v", "have \"v < length (snd ?subset_dfs) \\<and> (snd ?subset_dfs) ! v = qq\""], ["proof (prove)\nusing this:\n  nfa_is_node A qq\n  nfa_is_node A (nfa_startnode A)\n  bdd_lookup (fst (subset_dfs A (nfa_startnode A))) qq = Some v\n\ngoal (1 subgoal):\n 1. v < length (snd (subset_dfs A (nfa_startnode A))) \\<and>\n    snd (subset_dfs A (nfa_startnode A)) ! v = qq", "by (simp add: subset_dfs_bij)"], ["proof (state)\nthis:\n  v < length (snd (subset_dfs A (nfa_startnode A))) \\<and>\n  snd (subset_dfs A (nfa_startnode A)) ! v = qq\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "with snoc v_def"], ["proof (chain)\npicking this:\n  dfa_reach (det_nfa A) i bss j\n  \\<lbrakk>nfa_is_node A ?q2.0; subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; ?q2.0 = ls ! j; i < length ls; j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> nfa_reach A q1 bss ?q2.0\n  nfa_is_node A q2\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  q2 = ls ! dfa_trans (det_nfa A) j bs\n  i < length ls\n  dfa_trans (det_nfa A) j bs < length ls\n  list_all (is_alph n) (bss @ [bs])\n  v = bdd_lookup (fst (det_nfa A) ! j) bs\n  v < length (snd (subset_dfs A (nfa_startnode A))) \\<and>\n  snd (subset_dfs A (nfa_startnode A)) ! v = qq", "have Q2: \"qq = q2\""], ["proof (prove)\nusing this:\n  dfa_reach (det_nfa A) i bss j\n  \\<lbrakk>nfa_is_node A ?q2.0; subset_dfs A (nfa_startnode A) = (bd, ls);\n   \\<exists>bs.\n      nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs;\n   q1 = ls ! i; ?q2.0 = ls ! j; i < length ls; j < length ls;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> nfa_reach A q1 bss ?q2.0\n  nfa_is_node A q2\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs q1 \\<and> list_all (is_alph n) bs\n  q1 = ls ! i\n  q2 = ls ! dfa_trans (det_nfa A) j bs\n  i < length ls\n  dfa_trans (det_nfa A) j bs < length ls\n  list_all (is_alph n) (bss @ [bs])\n  v = bdd_lookup (fst (det_nfa A) ! j) bs\n  v < length (snd (subset_dfs A (nfa_startnode A))) \\<and>\n  snd (subset_dfs A (nfa_startnode A)) ! v = qq\n\ngoal (1 subgoal):\n 1. qq = q2", "by (simp add: dfa_trans_def)"], ["proof (state)\nthis:\n  qq = q2\n\ngoal (2 subgoals):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2\n 2. \\<And>k x y q2.\n       \\<lbrakk>dfa_reach (det_nfa A) i x k;\n        \\<And>q2.\n           \\<lbrakk>nfa_is_node A q2;\n            subset_dfs A (nfa_startnode A) = (bd, ls);\n            \\<exists>bs.\n               nfa_reach A (nfa_startnode A) bs q1 \\<and>\n               list_all (is_alph n) bs;\n            q1 = ls ! i; q2 = ls ! k; i < length ls; k < length ls;\n            list_all (is_alph n) x\\<rbrakk>\n           \\<Longrightarrow> nfa_reach A q1 x q2;\n        nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! dfa_trans (det_nfa A) k y; i < length ls;\n        dfa_trans (det_nfa A) k y < length ls;\n        list_all (is_alph n) (x @ [y])\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 (x @ [y]) q2", "with R qq_def"], ["proof (chain)\npicking this:\n  nfa_reach A q1 bss (ls ! j)\n  qq = nfa_trans A (ls ! j) bs\n  qq = q2", "show \"nfa_reach A q1 (bss @ [bs]) q2\""], ["proof (prove)\nusing this:\n  nfa_reach A q1 bss (ls ! j)\n  qq = nfa_trans A (ls ! j) bs\n  qq = q2\n\ngoal (1 subgoal):\n 1. nfa_reach A q1 (bss @ [bs]) q2", "by (simp add: reach_snoc)"], ["proof (state)\nthis:\n  nfa_reach A q1 (bss @ [bs]) q2\n\ngoal (1 subgoal):\n 1. \\<And>q2.\n       \\<lbrakk>nfa_is_node A q2; subset_dfs A (nfa_startnode A) = (bd, ls);\n        \\<exists>bs.\n           nfa_reach A (nfa_startnode A) bs q1 \\<and>\n           list_all (is_alph n) bs;\n        q1 = ls ! i; q2 = ls ! i; i < length ls; i < length ls;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> nfa_reach A q1 [] q2", "qed (simp add: reach_nil)"], ["proof (state)\nthis:\n  nfa_reach A q1 bss q2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_nfa_reach:\n  fixes bd :: \"nat option bdd\" and ls :: \"bool list list\"\n  assumes S: \"subset_dfs A (nfa_startnode A) = (bd, ls)\" (is \"?subset_dfs = _\")\n  and Q1: \"q1 = ls ! j\" and J: \"j < length ls\"\n  and X: \"list_all (is_alph n) bss\"\n  shows \"nfa_reach A (nfa_startnode A) bss q1 = dfa_reach (det_nfa A) 0 bss j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfa_reach A (nfa_startnode A) bss q1 = dfa_reach (det_nfa A) 0 bss j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nfa_reach A (nfa_startnode A) bss q1 = dfa_reach (det_nfa A) 0 bss j", "note SL = nfa_startnode_is_node[OF well_formed]"], ["proof (state)\nthis:\n  nfa_is_node A (nfa_startnode A)\n\ngoal (1 subgoal):\n 1. nfa_reach A (nfa_startnode A) bss q1 = dfa_reach (det_nfa A) 0 bss j", "have \"nfa_reach A (nfa_startnode A) [] (nfa_startnode A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfa_reach A (nfa_startnode A) [] (nfa_startnode A)", "by (rule reach_nil)"], ["proof (state)\nthis:\n  nfa_reach A (nfa_startnode A) [] (nfa_startnode A)\n\ngoal (1 subgoal):\n 1. nfa_reach A (nfa_startnode A) bss q1 = dfa_reach (det_nfa A) 0 bss j", "hence 1: \"\\<exists>b. nfa_reach A (nfa_startnode A) b (nfa_startnode A) \\<and> list_all (is_alph n) b\""], ["proof (prove)\nusing this:\n  nfa_reach A (nfa_startnode A) [] (nfa_startnode A)\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       nfa_reach A (nfa_startnode A) b (nfa_startnode A) \\<and>\n       list_all (is_alph n) b", "by auto"], ["proof (state)\nthis:\n  \\<exists>b.\n     nfa_reach A (nfa_startnode A) b (nfa_startnode A) \\<and>\n     list_all (is_alph n) b\n\ngoal (1 subgoal):\n 1. nfa_reach A (nfa_startnode A) bss q1 = dfa_reach (det_nfa A) 0 bss j", "from SL"], ["proof (chain)\npicking this:\n  nfa_is_node A (nfa_startnode A)", "have \"bdd_lookup (fst ?subset_dfs) (nfa_startnode A) = Some 0\""], ["proof (prove)\nusing this:\n  nfa_is_node A (nfa_startnode A)\n\ngoal (1 subgoal):\n 1. bdd_lookup (fst (subset_dfs A (nfa_startnode A))) (nfa_startnode A) =\n    Some 0", "by (simp add: subset_dfs_start)"], ["proof (state)\nthis:\n  bdd_lookup (fst (subset_dfs A (nfa_startnode A))) (nfa_startnode A) =\n  Some 0\n\ngoal (1 subgoal):\n 1. nfa_reach A (nfa_startnode A) bss q1 = dfa_reach (det_nfa A) 0 bss j", "with SL"], ["proof (chain)\npicking this:\n  nfa_is_node A (nfa_startnode A)\n  bdd_lookup (fst (subset_dfs A (nfa_startnode A))) (nfa_startnode A) =\n  Some 0", "have \"0 < length (snd ?subset_dfs) \\<and> snd ?subset_dfs ! 0 = nfa_startnode A\""], ["proof (prove)\nusing this:\n  nfa_is_node A (nfa_startnode A)\n  bdd_lookup (fst (subset_dfs A (nfa_startnode A))) (nfa_startnode A) =\n  Some 0\n\ngoal (1 subgoal):\n 1. 0 < length (snd (subset_dfs A (nfa_startnode A))) \\<and>\n    snd (subset_dfs A (nfa_startnode A)) ! 0 = nfa_startnode A", "by (simp add: subset_dfs_bij)"], ["proof (state)\nthis:\n  0 < length (snd (subset_dfs A (nfa_startnode A))) \\<and>\n  snd (subset_dfs A (nfa_startnode A)) ! 0 = nfa_startnode A\n\ngoal (1 subgoal):\n 1. nfa_reach A (nfa_startnode A) bss q1 = dfa_reach (det_nfa A) 0 bss j", "with S"], ["proof (chain)\npicking this:\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  0 < length (snd (subset_dfs A (nfa_startnode A))) \\<and>\n  snd (subset_dfs A (nfa_startnode A)) ! 0 = nfa_startnode A", "have 2: \"0 < length ls \\<and> ls ! 0 = nfa_startnode A\""], ["proof (prove)\nusing this:\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  0 < length (snd (subset_dfs A (nfa_startnode A))) \\<and>\n  snd (subset_dfs A (nfa_startnode A)) ! 0 = nfa_startnode A\n\ngoal (1 subgoal):\n 1. 0 < length ls \\<and> ls ! 0 = nfa_startnode A", "by simp"], ["proof (state)\nthis:\n  0 < length ls \\<and> ls ! 0 = nfa_startnode A\n\ngoal (1 subgoal):\n 1. nfa_reach A (nfa_startnode A) bss q1 = dfa_reach (det_nfa A) 0 bss j", "from S 1 Q1 J 2 X"], ["proof (chain)\npicking this:\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>b.\n     nfa_reach A (nfa_startnode A) b (nfa_startnode A) \\<and>\n     list_all (is_alph n) b\n  q1 = ls ! j\n  j < length ls\n  0 < length ls \\<and> ls ! 0 = nfa_startnode A\n  list_all (is_alph n) bss", "have T: \"nfa_reach A (nfa_startnode A) bss q1 = (dfa_reach (det_nfa A) 0 bss j \\<and> nfa_is_node A q1)\""], ["proof (prove)\nusing this:\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  \\<exists>b.\n     nfa_reach A (nfa_startnode A) b (nfa_startnode A) \\<and>\n     list_all (is_alph n) b\n  q1 = ls ! j\n  j < length ls\n  0 < length ls \\<and> ls ! 0 = nfa_startnode A\n  list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. nfa_reach A (nfa_startnode A) bss q1 =\n    (dfa_reach (det_nfa A) 0 bss j \\<and> nfa_is_node A q1)", "by (simp only: det_nfa_reach')"], ["proof (state)\nthis:\n  nfa_reach A (nfa_startnode A) bss q1 =\n  (dfa_reach (det_nfa A) 0 bss j \\<and> nfa_is_node A q1)\n\ngoal (1 subgoal):\n 1. nfa_reach A (nfa_startnode A) bss q1 = dfa_reach (det_nfa A) 0 bss j", "from SL"], ["proof (chain)\npicking this:\n  nfa_is_node A (nfa_startnode A)", "have \"list_all (nfa_is_node A) (snd ?subset_dfs)\""], ["proof (prove)\nusing this:\n  nfa_is_node A (nfa_startnode A)\n\ngoal (1 subgoal):\n 1. list_all (nfa_is_node A) (snd (subset_dfs A (nfa_startnode A)))", "by (simp add: subset_dfs_is_node)"], ["proof (state)\nthis:\n  list_all (nfa_is_node A) (snd (subset_dfs A (nfa_startnode A)))\n\ngoal (1 subgoal):\n 1. nfa_reach A (nfa_startnode A) bss q1 = dfa_reach (det_nfa A) 0 bss j", "with Q1 J S"], ["proof (chain)\npicking this:\n  q1 = ls ! j\n  j < length ls\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  list_all (nfa_is_node A) (snd (subset_dfs A (nfa_startnode A)))", "have \"nfa_is_node A q1\""], ["proof (prove)\nusing this:\n  q1 = ls ! j\n  j < length ls\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  list_all (nfa_is_node A) (snd (subset_dfs A (nfa_startnode A)))\n\ngoal (1 subgoal):\n 1. nfa_is_node A q1", "by (simp add: list_all_iff)"], ["proof (state)\nthis:\n  nfa_is_node A q1\n\ngoal (1 subgoal):\n 1. nfa_reach A (nfa_startnode A) bss q1 = dfa_reach (det_nfa A) 0 bss j", "with T"], ["proof (chain)\npicking this:\n  nfa_reach A (nfa_startnode A) bss q1 =\n  (dfa_reach (det_nfa A) 0 bss j \\<and> nfa_is_node A q1)\n  nfa_is_node A q1", "show ?thesis"], ["proof (prove)\nusing this:\n  nfa_reach A (nfa_startnode A) bss q1 =\n  (dfa_reach (det_nfa A) 0 bss j \\<and> nfa_is_node A q1)\n  nfa_is_node A q1\n\ngoal (1 subgoal):\n 1. nfa_reach A (nfa_startnode A) bss q1 = dfa_reach (det_nfa A) 0 bss j", "by simp"], ["proof (state)\nthis:\n  nfa_reach A (nfa_startnode A) bss q1 = dfa_reach (det_nfa A) 0 bss j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_nfa_accepts:\n  assumes X: \"list_all (is_alph n) w\"\n  shows \"dfa_accepts (det_nfa A) w = nfa_accepts A w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa_accepts (det_nfa A) w = nfa_accepts A w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dfa_accepts (det_nfa A) w = nfa_accepts A w", "note SL = nfa_startnode_is_node[OF well_formed]"], ["proof (state)\nthis:\n  nfa_is_node A (nfa_startnode A)\n\ngoal (1 subgoal):\n 1. dfa_accepts (det_nfa A) w = nfa_accepts A w", "let ?q = \"nfa_startnode A\""], ["proof (state)\ngoal (1 subgoal):\n 1. dfa_accepts (det_nfa A) w = nfa_accepts A w", "let ?subset_dfs = \"subset_dfs A (nfa_startnode A)\""], ["proof (state)\ngoal (1 subgoal):\n 1. dfa_accepts (det_nfa A) w = nfa_accepts A w", "define bd where \"bd = fst ?subset_dfs\""], ["proof (state)\nthis:\n  bd = fst (subset_dfs A (nfa_startnode A))\n\ngoal (1 subgoal):\n 1. dfa_accepts (det_nfa A) w = nfa_accepts A w", "define ls where \"ls = snd ?subset_dfs\""], ["proof (state)\nthis:\n  ls = snd (subset_dfs A (nfa_startnode A))\n\ngoal (1 subgoal):\n 1. dfa_accepts (det_nfa A) w = nfa_accepts A w", "with bd_def"], ["proof (chain)\npicking this:\n  bd = fst (subset_dfs A (nfa_startnode A))\n  ls = snd (subset_dfs A (nfa_startnode A))", "have BD: \"?subset_dfs = (bd,ls)\""], ["proof (prove)\nusing this:\n  bd = fst (subset_dfs A (nfa_startnode A))\n  ls = snd (subset_dfs A (nfa_startnode A))\n\ngoal (1 subgoal):\n 1. subset_dfs A (nfa_startnode A) = (bd, ls)", "by simp"], ["proof (state)\nthis:\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n\ngoal (1 subgoal):\n 1. dfa_accepts (det_nfa A) w = nfa_accepts A w", "define p where \"p = nfa_steps A (nfa_startnode A) w\""], ["proof (state)\nthis:\n  p = nfa_steps A (nfa_startnode A) w\n\ngoal (1 subgoal):\n 1. dfa_accepts (det_nfa A) w = nfa_accepts A w", "with well_formed X SL"], ["proof (chain)\npicking this:\n  wf_nfa A n\n  list_all (is_alph n) w\n  nfa_is_node A (nfa_startnode A)\n  p = nfa_steps A (nfa_startnode A) w", "have P: \"nfa_is_node A p\""], ["proof (prove)\nusing this:\n  wf_nfa A n\n  list_all (is_alph n) w\n  nfa_is_node A (nfa_startnode A)\n  p = nfa_steps A (nfa_startnode A) w\n\ngoal (1 subgoal):\n 1. nfa_is_node A p", "by (simp add: nfa_steps_is_node)"], ["proof (state)\nthis:\n  nfa_is_node A p\n\ngoal (1 subgoal):\n 1. dfa_accepts (det_nfa A) w = nfa_accepts A w", "from p_def"], ["proof (chain)\npicking this:\n  p = nfa_steps A (nfa_startnode A) w", "have R: \"nfa_reach A ?q w p\""], ["proof (prove)\nusing this:\n  p = nfa_steps A (nfa_startnode A) w\n\ngoal (1 subgoal):\n 1. nfa_reach A (nfa_startnode A) w p", "by (simp add: reach_def)"], ["proof (state)\nthis:\n  nfa_reach A (nfa_startnode A) w p\n\ngoal (1 subgoal):\n 1. dfa_accepts (det_nfa A) w = nfa_accepts A w", "with assms"], ["proof (chain)\npicking this:\n  list_all (is_alph n) w\n  nfa_reach A (nfa_startnode A) w p", "have \"\\<exists>bs. nfa_reach A ?q bs p \\<and> list_all (is_alph n) bs\""], ["proof (prove)\nusing this:\n  list_all (is_alph n) w\n  nfa_reach A (nfa_startnode A) w p\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       nfa_reach A (nfa_startnode A) bs p \\<and> list_all (is_alph n) bs", "by auto"], ["proof (state)\nthis:\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs p \\<and> list_all (is_alph n) bs\n\ngoal (1 subgoal):\n 1. dfa_accepts (det_nfa A) w = nfa_accepts A w", "with SL"], ["proof (chain)\npicking this:\n  nfa_is_node A (nfa_startnode A)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs p \\<and> list_all (is_alph n) bs", "have \"(?q, p) \\<in> (succsr (subset_succs A))\\<^sup>*\""], ["proof (prove)\nusing this:\n  nfa_is_node A (nfa_startnode A)\n  \\<exists>bs.\n     nfa_reach A (nfa_startnode A) bs p \\<and> list_all (is_alph n) bs\n\ngoal (1 subgoal):\n 1. (nfa_startnode A, p) \\<in> (succsr (subset_succs A))\\<^sup>*", "by (simp add: nfa_reach_rtrancl)"], ["proof (state)\nthis:\n  (nfa_startnode A, p) \\<in> (succsr (subset_succs A))\\<^sup>*\n\ngoal (1 subgoal):\n 1. dfa_accepts (det_nfa A) w = nfa_accepts A w", "with SL P"], ["proof (chain)\npicking this:\n  nfa_is_node A (nfa_startnode A)\n  nfa_is_node A p\n  (nfa_startnode A, p) \\<in> (succsr (subset_succs A))\\<^sup>*", "have \"subset_memb p ?subset_dfs\""], ["proof (prove)\nusing this:\n  nfa_is_node A (nfa_startnode A)\n  nfa_is_node A p\n  (nfa_startnode A, p) \\<in> (succsr (subset_succs A))\\<^sup>*\n\ngoal (1 subgoal):\n 1. subset_memb p (subset_dfs A (nfa_startnode A))", "by (simp add: dfs_eq_rtrancl)"], ["proof (state)\nthis:\n  subset_memb p (subset_dfs A (nfa_startnode A))\n\ngoal (1 subgoal):\n 1. dfa_accepts (det_nfa A) w = nfa_accepts A w", "with BD"], ["proof (chain)\npicking this:\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  subset_memb p (subset_dfs A (nfa_startnode A))", "have \"bdd_lookup bd p \\<noteq> None\""], ["proof (prove)\nusing this:\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  subset_memb p (subset_dfs A (nfa_startnode A))\n\ngoal (1 subgoal):\n 1. bdd_lookup bd p \\<noteq> None", "by (simp add: subset_memb_def)"], ["proof (state)\nthis:\n  bdd_lookup bd p \\<noteq> None\n\ngoal (1 subgoal):\n 1. dfa_accepts (det_nfa A) w = nfa_accepts A w", "then"], ["proof (chain)\npicking this:\n  bdd_lookup bd p \\<noteq> None", "obtain k where K: \"bdd_lookup bd p = Some k\""], ["proof (prove)\nusing this:\n  bdd_lookup bd p \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        bdd_lookup bd p = Some k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"bdd_lookup bd p\") simp+"], ["proof (state)\nthis:\n  bdd_lookup bd p = Some k\n\ngoal (1 subgoal):\n 1. dfa_accepts (det_nfa A) w = nfa_accepts A w", "with SL P"], ["proof (chain)\npicking this:\n  nfa_is_node A (nfa_startnode A)\n  nfa_is_node A p\n  bdd_lookup bd p = Some k", "have K_len: \"k < length ls \\<and> ls ! k = p\""], ["proof (prove)\nusing this:\n  nfa_is_node A (nfa_startnode A)\n  nfa_is_node A p\n  bdd_lookup bd p = Some k\n\ngoal (1 subgoal):\n 1. k < length ls \\<and> ls ! k = p", "unfolding bd_def ls_def"], ["proof (prove)\nusing this:\n  nfa_is_node A (nfa_startnode A)\n  nfa_is_node A p\n  bdd_lookup (fst (subset_dfs A (nfa_startnode A))) p = Some k\n\ngoal (1 subgoal):\n 1. k < length (snd (subset_dfs A (nfa_startnode A))) \\<and>\n    snd (subset_dfs A (nfa_startnode A)) ! k = p", "by (simp add: subset_dfs_bij)"], ["proof (state)\nthis:\n  k < length ls \\<and> ls ! k = p\n\ngoal (1 subgoal):\n 1. dfa_accepts (det_nfa A) w = nfa_accepts A w", "with BD X R"], ["proof (chain)\npicking this:\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  list_all (is_alph n) w\n  nfa_reach A (nfa_startnode A) w p\n  k < length ls \\<and> ls ! k = p", "have \"dfa_reach (det_nfa A) 0 w k\""], ["proof (prove)\nusing this:\n  subset_dfs A (nfa_startnode A) = (bd, ls)\n  list_all (is_alph n) w\n  nfa_reach A (nfa_startnode A) w p\n  k < length ls \\<and> ls ! k = p\n\ngoal (1 subgoal):\n 1. dfa_reach (det_nfa A) 0 w k", "by (blast dest: det_nfa_reach)"], ["proof (state)\nthis:\n  dfa_reach (det_nfa A) 0 w k\n\ngoal (1 subgoal):\n 1. dfa_accepts (det_nfa A) w = nfa_accepts A w", "hence \"k = dfa_steps (det_nfa A) 0 w\""], ["proof (prove)\nusing this:\n  dfa_reach (det_nfa A) 0 w k\n\ngoal (1 subgoal):\n 1. k = dfa_steps (det_nfa A) 0 w", "by (simp add: reach_def)"], ["proof (state)\nthis:\n  k = dfa_steps (det_nfa A) 0 w\n\ngoal (1 subgoal):\n 1. dfa_accepts (det_nfa A) w = nfa_accepts A w", "hence \"dfa_accepts (det_nfa A) w = snd (det_nfa A) ! k\""], ["proof (prove)\nusing this:\n  k = dfa_steps (det_nfa A) 0 w\n\ngoal (1 subgoal):\n 1. dfa_accepts (det_nfa A) w = snd (det_nfa A) ! k", "by (simp add: accepts_def dfa_accepting_def)"], ["proof (state)\nthis:\n  dfa_accepts (det_nfa A) w = snd (det_nfa A) ! k\n\ngoal (1 subgoal):\n 1. dfa_accepts (det_nfa A) w = nfa_accepts A w", "also"], ["proof (state)\nthis:\n  dfa_accepts (det_nfa A) w = snd (det_nfa A) ! k\n\ngoal (1 subgoal):\n 1. dfa_accepts (det_nfa A) w = nfa_accepts A w", "from ls_def"], ["proof (chain)\npicking this:\n  ls = snd (subset_dfs A (nfa_startnode A))", "have \"\\<dots> = map (nfa_accepting A) ls ! k\""], ["proof (prove)\nusing this:\n  ls = snd (subset_dfs A (nfa_startnode A))\n\ngoal (1 subgoal):\n 1. snd (det_nfa A) ! k = map (nfa_accepting A) ls ! k", "by (simp add: det_nfa_def split_beta)"], ["proof (state)\nthis:\n  snd (det_nfa A) ! k = map (nfa_accepting A) ls ! k\n\ngoal (1 subgoal):\n 1. dfa_accepts (det_nfa A) w = nfa_accepts A w", "also"], ["proof (state)\nthis:\n  snd (det_nfa A) ! k = map (nfa_accepting A) ls ! k\n\ngoal (1 subgoal):\n 1. dfa_accepts (det_nfa A) w = nfa_accepts A w", "from K_len p_def"], ["proof (chain)\npicking this:\n  k < length ls \\<and> ls ! k = p\n  p = nfa_steps A (nfa_startnode A) w", "have \"\\<dots> = nfa_accepts A w\""], ["proof (prove)\nusing this:\n  k < length ls \\<and> ls ! k = p\n  p = nfa_steps A (nfa_startnode A) w\n\ngoal (1 subgoal):\n 1. map (nfa_accepting A) ls ! k = nfa_accepts A w", "by (simp add: accepts_def)"], ["proof (state)\nthis:\n  map (nfa_accepting A) ls ! k = nfa_accepts A w\n\ngoal (1 subgoal):\n 1. dfa_accepts (det_nfa A) w = nfa_accepts A w", "finally"], ["proof (chain)\npicking this:\n  dfa_accepts (det_nfa A) w = nfa_accepts A w", "show \"dfa_accepts (det_nfa A) w = nfa_accepts A w\""], ["proof (prove)\nusing this:\n  dfa_accepts (det_nfa A) w = nfa_accepts A w\n\ngoal (1 subgoal):\n 1. dfa_accepts (det_nfa A) w = nfa_accepts A w", "."], ["proof (state)\nthis:\n  dfa_accepts (det_nfa A) w = nfa_accepts A w\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma det_wf_nfa:\n  assumes A: \"wf_nfa A n\"\n  shows \"wf_dfa (det_nfa A) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "from A"], ["proof (chain)\npicking this:\n  wf_nfa A n", "interpret subset_DFS A n"], ["proof (prove)\nusing this:\n  wf_nfa A n\n\ngoal (1 subgoal):\n 1. subset_DFS A n", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_dfa (det_nfa A) n", "by (rule det_wf_nfa)"], ["proof (state)\nthis:\n  wf_dfa (det_nfa A) n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_nfa_accepts:\n  assumes A: \"wf_nfa A n\"\n  and w: \"list_all (is_alph n) bss\"\n  shows \"dfa_accepts (det_nfa A) bss = nfa_accepts A bss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa_accepts (det_nfa A) bss = nfa_accepts A bss", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dfa_accepts (det_nfa A) bss = nfa_accepts A bss", "from A"], ["proof (chain)\npicking this:\n  wf_nfa A n", "interpret subset_DFS A n"], ["proof (prove)\nusing this:\n  wf_nfa A n\n\ngoal (1 subgoal):\n 1. subset_DFS A n", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. dfa_accepts (det_nfa A) bss = nfa_accepts A bss", "from w"], ["proof (chain)\npicking this:\n  list_all (is_alph n) bss", "show ?thesis"], ["proof (prove)\nusing this:\n  list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. dfa_accepts (det_nfa A) bss = nfa_accepts A bss", "by (rule det_nfa_accepts)"], ["proof (state)\nthis:\n  dfa_accepts (det_nfa A) bss = nfa_accepts A bss\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Quantifiers\\<close>"], ["", "fun quantify_bdd :: \"nat \\<Rightarrow> bool list bdd \\<Rightarrow> bool list bdd\" where\n  \"quantify_bdd i (Leaf q) = Leaf q\"\n| \"quantify_bdd 0 (Branch l r) = (bdd_binop bv_or l r)\"\n| \"quantify_bdd (Suc i) (Branch l r) = Branch (quantify_bdd i l) (quantify_bdd i r)\""], ["", "lemma bddh_quantify_bdd:\n  assumes \"bddh (Suc n) bdd\" and \"v \\<le> n\"\n  shows \"bddh n (quantify_bdd v bdd)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bddh n (quantify_bdd v bdd)", "using assms"], ["proof (prove)\nusing this:\n  bddh (Suc n) bdd\n  v \\<le> n\n\ngoal (1 subgoal):\n 1. bddh n (quantify_bdd v bdd)", "by (induct v bdd arbitrary: n rule: quantify_bdd.induct) (auto simp: bddh_binop split: nat.splits)"], ["", "lemma quantify_bdd_is_node:\n  assumes \"bdd_all (nfa_is_node N) bdd\"\n  shows \"bdd_all (nfa_is_node N) (quantify_bdd v bdd)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_all (nfa_is_node N) (quantify_bdd v bdd)", "using assms"], ["proof (prove)\nusing this:\n  bdd_all (nfa_is_node N) bdd\n\ngoal (1 subgoal):\n 1. bdd_all (nfa_is_node N) (quantify_bdd v bdd)", "by (induct v bdd rule: quantify_bdd.induct) (simp add: bdd_all_bdd_binop[of \"nfa_is_node N\" _ \"nfa_is_node N\" _ \"nfa_is_node N\" bv_or, OF _ _ bv_or_is_node])+"], ["", "definition\n  quantify_nfa :: \"nat \\<Rightarrow> nfa \\<Rightarrow> nfa\" where\n  \"quantify_nfa i = (\\<lambda>(bdds, as). (map (quantify_bdd i) bdds, as))\""], ["", "lemma quantify_nfa_well_formed_aut:\n  assumes \"wf_nfa N (Suc n)\"\n  and \"v \\<le> n\"\n  shows \"wf_nfa (quantify_nfa v N) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_nfa (quantify_nfa v N) n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_nfa (quantify_nfa v N) n", "from assms"], ["proof (chain)\npicking this:\n  wf_nfa N (Suc n)\n  v \\<le> n", "have 1: \"list_all (bddh (Suc n)) (fst N)\" and 2: \"list_all (bdd_all (nfa_is_node N)) (fst N)\""], ["proof (prove)\nusing this:\n  wf_nfa N (Suc n)\n  v \\<le> n\n\ngoal (1 subgoal):\n 1. list_all (bddh (Suc n)) (fst N) &&&\n    list_all (bdd_all (nfa_is_node N)) (fst N)", "by (simp add: wf_nfa_def)+"], ["proof (state)\nthis:\n  list_all (bddh (Suc n)) (fst N)\n  list_all (bdd_all (nfa_is_node N)) (fst N)\n\ngoal (1 subgoal):\n 1. wf_nfa (quantify_nfa v N) n", "from 1 assms"], ["proof (chain)\npicking this:\n  list_all (bddh (Suc n)) (fst N)\n  wf_nfa N (Suc n)\n  v \\<le> n", "have 3: \"list_all (bddh n) (fst (quantify_nfa v N))\""], ["proof (prove)\nusing this:\n  list_all (bddh (Suc n)) (fst N)\n  wf_nfa N (Suc n)\n  v \\<le> n\n\ngoal (1 subgoal):\n 1. list_all (bddh n) (fst (quantify_nfa v N))", "by (simp add: quantify_nfa_def bddh_quantify_bdd list_all_iff split_beta)"], ["proof (state)\nthis:\n  list_all (bddh n) (fst (quantify_nfa v N))\n\ngoal (1 subgoal):\n 1. wf_nfa (quantify_nfa v N) n", "from 2"], ["proof (chain)\npicking this:\n  list_all (bdd_all (nfa_is_node N)) (fst N)", "have \"list_all (bdd_all (nfa_is_node N)) (fst (quantify_nfa v N))\""], ["proof (prove)\nusing this:\n  list_all (bdd_all (nfa_is_node N)) (fst N)\n\ngoal (1 subgoal):\n 1. list_all (bdd_all (nfa_is_node N)) (fst (quantify_nfa v N))", "by (simp add: quantify_bdd_is_node list_all_iff split_beta quantify_nfa_def)"], ["proof (state)\nthis:\n  list_all (bdd_all (nfa_is_node N)) (fst (quantify_nfa v N))\n\ngoal (1 subgoal):\n 1. wf_nfa (quantify_nfa v N) n", "hence \"list_all (bdd_all (nfa_is_node (quantify_nfa v N))) (fst (quantify_nfa v N))\""], ["proof (prove)\nusing this:\n  list_all (bdd_all (nfa_is_node N)) (fst (quantify_nfa v N))\n\ngoal (1 subgoal):\n 1. list_all (bdd_all (nfa_is_node (quantify_nfa v N)))\n     (fst (quantify_nfa v N))", "by (simp add: quantify_nfa_def split_beta nfa_is_node_def)"], ["proof (state)\nthis:\n  list_all (bdd_all (nfa_is_node (quantify_nfa v N)))\n   (fst (quantify_nfa v N))\n\ngoal (1 subgoal):\n 1. wf_nfa (quantify_nfa v N) n", "with 3 assms"], ["proof (chain)\npicking this:\n  list_all (bddh n) (fst (quantify_nfa v N))\n  wf_nfa N (Suc n)\n  v \\<le> n\n  list_all (bdd_all (nfa_is_node (quantify_nfa v N)))\n   (fst (quantify_nfa v N))", "show ?thesis"], ["proof (prove)\nusing this:\n  list_all (bddh n) (fst (quantify_nfa v N))\n  wf_nfa N (Suc n)\n  v \\<le> n\n  list_all (bdd_all (nfa_is_node (quantify_nfa v N)))\n   (fst (quantify_nfa v N))\n\ngoal (1 subgoal):\n 1. wf_nfa (quantify_nfa v N) n", "by (simp add: wf_nfa_def quantify_nfa_def split_beta)"], ["proof (state)\nthis:\n  wf_nfa (quantify_nfa v N) n\n\ngoal:\nNo subgoals!", "qed"], ["", "fun insertl :: \"nat \\<Rightarrow> 'a \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n  \"insertl i a [] = [a]\"\n| \"insertl 0 a bs = a # bs\"\n| \"insertl (Suc i) a (b # bs) = b # (insertl i a bs)\""], ["", "lemma insertl_len: \n  \"length (insertl n x vs) = Suc (length vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (insertl n x vs) = Suc (length vs)", "by (induct n x vs rule: insertl.induct) simp+"], ["", "lemma insertl_0_eq: \"insertl 0 x xs = x # xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertl 0 x xs = x # xs", "by (cases xs) simp_all"], ["", "lemma bdd_lookup_quantify_bdd_set_of_bv: \n  assumes \"length w = n\"\n  and \"bddh (Suc n) bdd\"\n  and \"bdd_all (nfa_is_node N) bdd\"\n  and \"v \\<le> n\"\n  shows \"set_of_bv (bdd_lookup (quantify_bdd v bdd) w) = (\\<Union>b. set_of_bv (bdd_lookup bdd (insertl v b w)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_of_bv (bdd_lookup (quantify_bdd v bdd) w) =\n    (\\<Union>b. set_of_bv (bdd_lookup bdd (insertl v b w)))", "using assms"], ["proof (prove)\nusing this:\n  length w = n\n  bddh (Suc n) bdd\n  bdd_all (nfa_is_node N) bdd\n  v \\<le> n\n\ngoal (1 subgoal):\n 1. set_of_bv (bdd_lookup (quantify_bdd v bdd) w) =\n    (\\<Union>b. set_of_bv (bdd_lookup bdd (insertl v b w)))", "proof (induct v bdd arbitrary: n w rule: quantify_bdd.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i q n w.\n       \\<lbrakk>length w = n; bddh (Suc n) (Leaf q);\n        bdd_all (nfa_is_node N) (Leaf q); i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd i (Leaf q)) w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Leaf q) (insertl i b w)))\n 2. \\<And>l r n w.\n       \\<lbrakk>length w = n; bddh (Suc n) (Branch l r);\n        bdd_all (nfa_is_node N) (Branch l r); 0 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd 0 (Branch l r)) w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Branch l r) (insertl 0 b w)))\n 3. \\<And>i l r n w.\n       \\<lbrakk>\\<And>n w.\n                   \\<lbrakk>length w = n; bddh (Suc n) l;\n                    bdd_all (nfa_is_node N) l; i \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> set_of_bv\n(bdd_lookup (quantify_bdd i l) w) =\n                                     (\\<Union>b.\n   set_of_bv (bdd_lookup l (insertl i b w)));\n        \\<And>n w.\n           \\<lbrakk>length w = n; bddh (Suc n) r; bdd_all (nfa_is_node N) r;\n            i \\<le> n\\<rbrakk>\n           \\<Longrightarrow> set_of_bv (bdd_lookup (quantify_bdd i r) w) =\n                             (\\<Union>b.\n                                 set_of_bv (bdd_lookup r (insertl i b w)));\n        length w = n; bddh (Suc n) (Branch l r);\n        bdd_all (nfa_is_node N) (Branch l r); Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd (Suc i) (Branch l r))\n                            w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Branch l r)\n                                (insertl (Suc i) b w)))", "case (2 l r w)"], ["proof (state)\nthis:\n  length w = wa__\n  bddh (Suc wa__) (Branch l r)\n  bdd_all (nfa_is_node N) (Branch l r)\n  0 \\<le> wa__\n\ngoal (3 subgoals):\n 1. \\<And>i q n w.\n       \\<lbrakk>length w = n; bddh (Suc n) (Leaf q);\n        bdd_all (nfa_is_node N) (Leaf q); i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd i (Leaf q)) w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Leaf q) (insertl i b w)))\n 2. \\<And>l r n w.\n       \\<lbrakk>length w = n; bddh (Suc n) (Branch l r);\n        bdd_all (nfa_is_node N) (Branch l r); 0 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd 0 (Branch l r)) w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Branch l r) (insertl 0 b w)))\n 3. \\<And>i l r n w.\n       \\<lbrakk>\\<And>n w.\n                   \\<lbrakk>length w = n; bddh (Suc n) l;\n                    bdd_all (nfa_is_node N) l; i \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> set_of_bv\n(bdd_lookup (quantify_bdd i l) w) =\n                                     (\\<Union>b.\n   set_of_bv (bdd_lookup l (insertl i b w)));\n        \\<And>n w.\n           \\<lbrakk>length w = n; bddh (Suc n) r; bdd_all (nfa_is_node N) r;\n            i \\<le> n\\<rbrakk>\n           \\<Longrightarrow> set_of_bv (bdd_lookup (quantify_bdd i r) w) =\n                             (\\<Union>b.\n                                 set_of_bv (bdd_lookup r (insertl i b w)));\n        length w = n; bddh (Suc n) (Branch l r);\n        bdd_all (nfa_is_node N) (Branch l r); Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd (Suc i) (Branch l r))\n                            w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Branch l r)\n                                (insertl (Suc i) b w)))", "hence N: \"nfa_is_node N (bdd_lookup l w)\" \"nfa_is_node N (bdd_lookup r w)\""], ["proof (prove)\nusing this:\n  length w = wa__\n  bddh (Suc wa__) (Branch l r)\n  bdd_all (nfa_is_node N) (Branch l r)\n  0 \\<le> wa__\n\ngoal (1 subgoal):\n 1. nfa_is_node N (bdd_lookup l w) &&& nfa_is_node N (bdd_lookup r w)", "by (simp add: bdd_all_bdd_lookup)+"], ["proof (state)\nthis:\n  nfa_is_node N (bdd_lookup l w)\n  nfa_is_node N (bdd_lookup r w)\n\ngoal (3 subgoals):\n 1. \\<And>i q n w.\n       \\<lbrakk>length w = n; bddh (Suc n) (Leaf q);\n        bdd_all (nfa_is_node N) (Leaf q); i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd i (Leaf q)) w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Leaf q) (insertl i b w)))\n 2. \\<And>l r n w.\n       \\<lbrakk>length w = n; bddh (Suc n) (Branch l r);\n        bdd_all (nfa_is_node N) (Branch l r); 0 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd 0 (Branch l r)) w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Branch l r) (insertl 0 b w)))\n 3. \\<And>i l r n w.\n       \\<lbrakk>\\<And>n w.\n                   \\<lbrakk>length w = n; bddh (Suc n) l;\n                    bdd_all (nfa_is_node N) l; i \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> set_of_bv\n(bdd_lookup (quantify_bdd i l) w) =\n                                     (\\<Union>b.\n   set_of_bv (bdd_lookup l (insertl i b w)));\n        \\<And>n w.\n           \\<lbrakk>length w = n; bddh (Suc n) r; bdd_all (nfa_is_node N) r;\n            i \\<le> n\\<rbrakk>\n           \\<Longrightarrow> set_of_bv (bdd_lookup (quantify_bdd i r) w) =\n                             (\\<Union>b.\n                                 set_of_bv (bdd_lookup r (insertl i b w)));\n        length w = n; bddh (Suc n) (Branch l r);\n        bdd_all (nfa_is_node N) (Branch l r); Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd (Suc i) (Branch l r))\n                            w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Branch l r)\n                                (insertl (Suc i) b w)))", "have \"set_of_bv (bdd_lookup (quantify_bdd 0 (Branch l r)) w) = set_of_bv (bdd_lookup (bdd_binop bv_or l r) w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_of_bv (bdd_lookup (quantify_bdd 0 (Branch l r)) w) =\n    set_of_bv (bdd_lookup (bdd_binop bv_or l r) w)", "by simp"], ["proof (state)\nthis:\n  set_of_bv (bdd_lookup (quantify_bdd 0 (Branch l r)) w) =\n  set_of_bv (bdd_lookup (bdd_binop bv_or l r) w)\n\ngoal (3 subgoals):\n 1. \\<And>i q n w.\n       \\<lbrakk>length w = n; bddh (Suc n) (Leaf q);\n        bdd_all (nfa_is_node N) (Leaf q); i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd i (Leaf q)) w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Leaf q) (insertl i b w)))\n 2. \\<And>l r n w.\n       \\<lbrakk>length w = n; bddh (Suc n) (Branch l r);\n        bdd_all (nfa_is_node N) (Branch l r); 0 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd 0 (Branch l r)) w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Branch l r) (insertl 0 b w)))\n 3. \\<And>i l r n w.\n       \\<lbrakk>\\<And>n w.\n                   \\<lbrakk>length w = n; bddh (Suc n) l;\n                    bdd_all (nfa_is_node N) l; i \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> set_of_bv\n(bdd_lookup (quantify_bdd i l) w) =\n                                     (\\<Union>b.\n   set_of_bv (bdd_lookup l (insertl i b w)));\n        \\<And>n w.\n           \\<lbrakk>length w = n; bddh (Suc n) r; bdd_all (nfa_is_node N) r;\n            i \\<le> n\\<rbrakk>\n           \\<Longrightarrow> set_of_bv (bdd_lookup (quantify_bdd i r) w) =\n                             (\\<Union>b.\n                                 set_of_bv (bdd_lookup r (insertl i b w)));\n        length w = n; bddh (Suc n) (Branch l r);\n        bdd_all (nfa_is_node N) (Branch l r); Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd (Suc i) (Branch l r))\n                            w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Branch l r)\n                                (insertl (Suc i) b w)))", "also"], ["proof (state)\nthis:\n  set_of_bv (bdd_lookup (quantify_bdd 0 (Branch l r)) w) =\n  set_of_bv (bdd_lookup (bdd_binop bv_or l r) w)\n\ngoal (3 subgoals):\n 1. \\<And>i q n w.\n       \\<lbrakk>length w = n; bddh (Suc n) (Leaf q);\n        bdd_all (nfa_is_node N) (Leaf q); i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd i (Leaf q)) w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Leaf q) (insertl i b w)))\n 2. \\<And>l r n w.\n       \\<lbrakk>length w = n; bddh (Suc n) (Branch l r);\n        bdd_all (nfa_is_node N) (Branch l r); 0 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd 0 (Branch l r)) w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Branch l r) (insertl 0 b w)))\n 3. \\<And>i l r n w.\n       \\<lbrakk>\\<And>n w.\n                   \\<lbrakk>length w = n; bddh (Suc n) l;\n                    bdd_all (nfa_is_node N) l; i \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> set_of_bv\n(bdd_lookup (quantify_bdd i l) w) =\n                                     (\\<Union>b.\n   set_of_bv (bdd_lookup l (insertl i b w)));\n        \\<And>n w.\n           \\<lbrakk>length w = n; bddh (Suc n) r; bdd_all (nfa_is_node N) r;\n            i \\<le> n\\<rbrakk>\n           \\<Longrightarrow> set_of_bv (bdd_lookup (quantify_bdd i r) w) =\n                             (\\<Union>b.\n                                 set_of_bv (bdd_lookup r (insertl i b w)));\n        length w = n; bddh (Suc n) (Branch l r);\n        bdd_all (nfa_is_node N) (Branch l r); Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd (Suc i) (Branch l r))\n                            w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Branch l r)\n                                (insertl (Suc i) b w)))", "from 2"], ["proof (chain)\npicking this:\n  length w = wa__\n  bddh (Suc wa__) (Branch l r)\n  bdd_all (nfa_is_node N) (Branch l r)\n  0 \\<le> wa__", "have \"\\<dots> = set_of_bv (bv_or (bdd_lookup l w) (bdd_lookup r w))\""], ["proof (prove)\nusing this:\n  length w = wa__\n  bddh (Suc wa__) (Branch l r)\n  bdd_all (nfa_is_node N) (Branch l r)\n  0 \\<le> wa__\n\ngoal (1 subgoal):\n 1. set_of_bv (bdd_lookup (bdd_binop bv_or l r) w) =\n    set_of_bv (bv_or (bdd_lookup l w) (bdd_lookup r w))", "by (simp add: bdd_lookup_binop)"], ["proof (state)\nthis:\n  set_of_bv (bdd_lookup (bdd_binop bv_or l r) w) =\n  set_of_bv (bv_or (bdd_lookup l w) (bdd_lookup r w))\n\ngoal (3 subgoals):\n 1. \\<And>i q n w.\n       \\<lbrakk>length w = n; bddh (Suc n) (Leaf q);\n        bdd_all (nfa_is_node N) (Leaf q); i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd i (Leaf q)) w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Leaf q) (insertl i b w)))\n 2. \\<And>l r n w.\n       \\<lbrakk>length w = n; bddh (Suc n) (Branch l r);\n        bdd_all (nfa_is_node N) (Branch l r); 0 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd 0 (Branch l r)) w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Branch l r) (insertl 0 b w)))\n 3. \\<And>i l r n w.\n       \\<lbrakk>\\<And>n w.\n                   \\<lbrakk>length w = n; bddh (Suc n) l;\n                    bdd_all (nfa_is_node N) l; i \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> set_of_bv\n(bdd_lookup (quantify_bdd i l) w) =\n                                     (\\<Union>b.\n   set_of_bv (bdd_lookup l (insertl i b w)));\n        \\<And>n w.\n           \\<lbrakk>length w = n; bddh (Suc n) r; bdd_all (nfa_is_node N) r;\n            i \\<le> n\\<rbrakk>\n           \\<Longrightarrow> set_of_bv (bdd_lookup (quantify_bdd i r) w) =\n                             (\\<Union>b.\n                                 set_of_bv (bdd_lookup r (insertl i b w)));\n        length w = n; bddh (Suc n) (Branch l r);\n        bdd_all (nfa_is_node N) (Branch l r); Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd (Suc i) (Branch l r))\n                            w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Branch l r)\n                                (insertl (Suc i) b w)))", "also"], ["proof (state)\nthis:\n  set_of_bv (bdd_lookup (bdd_binop bv_or l r) w) =\n  set_of_bv (bv_or (bdd_lookup l w) (bdd_lookup r w))\n\ngoal (3 subgoals):\n 1. \\<And>i q n w.\n       \\<lbrakk>length w = n; bddh (Suc n) (Leaf q);\n        bdd_all (nfa_is_node N) (Leaf q); i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd i (Leaf q)) w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Leaf q) (insertl i b w)))\n 2. \\<And>l r n w.\n       \\<lbrakk>length w = n; bddh (Suc n) (Branch l r);\n        bdd_all (nfa_is_node N) (Branch l r); 0 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd 0 (Branch l r)) w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Branch l r) (insertl 0 b w)))\n 3. \\<And>i l r n w.\n       \\<lbrakk>\\<And>n w.\n                   \\<lbrakk>length w = n; bddh (Suc n) l;\n                    bdd_all (nfa_is_node N) l; i \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> set_of_bv\n(bdd_lookup (quantify_bdd i l) w) =\n                                     (\\<Union>b.\n   set_of_bv (bdd_lookup l (insertl i b w)));\n        \\<And>n w.\n           \\<lbrakk>length w = n; bddh (Suc n) r; bdd_all (nfa_is_node N) r;\n            i \\<le> n\\<rbrakk>\n           \\<Longrightarrow> set_of_bv (bdd_lookup (quantify_bdd i r) w) =\n                             (\\<Union>b.\n                                 set_of_bv (bdd_lookup r (insertl i b w)));\n        length w = n; bddh (Suc n) (Branch l r);\n        bdd_all (nfa_is_node N) (Branch l r); Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd (Suc i) (Branch l r))\n                            w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Branch l r)\n                                (insertl (Suc i) b w)))", "from N"], ["proof (chain)\npicking this:\n  nfa_is_node N (bdd_lookup l w)\n  nfa_is_node N (bdd_lookup r w)", "have \"\\<dots> = set_of_bv (bdd_lookup l w) \\<union> set_of_bv (bdd_lookup r w)\""], ["proof (prove)\nusing this:\n  nfa_is_node N (bdd_lookup l w)\n  nfa_is_node N (bdd_lookup r w)\n\ngoal (1 subgoal):\n 1. set_of_bv (bv_or (bdd_lookup l w) (bdd_lookup r w)) =\n    set_of_bv (bdd_lookup l w) \\<union> set_of_bv (bdd_lookup r w)", "by (simp add: bv_or_set_of_bv)"], ["proof (state)\nthis:\n  set_of_bv (bv_or (bdd_lookup l w) (bdd_lookup r w)) =\n  set_of_bv (bdd_lookup l w) \\<union> set_of_bv (bdd_lookup r w)\n\ngoal (3 subgoals):\n 1. \\<And>i q n w.\n       \\<lbrakk>length w = n; bddh (Suc n) (Leaf q);\n        bdd_all (nfa_is_node N) (Leaf q); i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd i (Leaf q)) w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Leaf q) (insertl i b w)))\n 2. \\<And>l r n w.\n       \\<lbrakk>length w = n; bddh (Suc n) (Branch l r);\n        bdd_all (nfa_is_node N) (Branch l r); 0 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd 0 (Branch l r)) w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Branch l r) (insertl 0 b w)))\n 3. \\<And>i l r n w.\n       \\<lbrakk>\\<And>n w.\n                   \\<lbrakk>length w = n; bddh (Suc n) l;\n                    bdd_all (nfa_is_node N) l; i \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> set_of_bv\n(bdd_lookup (quantify_bdd i l) w) =\n                                     (\\<Union>b.\n   set_of_bv (bdd_lookup l (insertl i b w)));\n        \\<And>n w.\n           \\<lbrakk>length w = n; bddh (Suc n) r; bdd_all (nfa_is_node N) r;\n            i \\<le> n\\<rbrakk>\n           \\<Longrightarrow> set_of_bv (bdd_lookup (quantify_bdd i r) w) =\n                             (\\<Union>b.\n                                 set_of_bv (bdd_lookup r (insertl i b w)));\n        length w = n; bddh (Suc n) (Branch l r);\n        bdd_all (nfa_is_node N) (Branch l r); Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd (Suc i) (Branch l r))\n                            w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Branch l r)\n                                (insertl (Suc i) b w)))", "also"], ["proof (state)\nthis:\n  set_of_bv (bv_or (bdd_lookup l w) (bdd_lookup r w)) =\n  set_of_bv (bdd_lookup l w) \\<union> set_of_bv (bdd_lookup r w)\n\ngoal (3 subgoals):\n 1. \\<And>i q n w.\n       \\<lbrakk>length w = n; bddh (Suc n) (Leaf q);\n        bdd_all (nfa_is_node N) (Leaf q); i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd i (Leaf q)) w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Leaf q) (insertl i b w)))\n 2. \\<And>l r n w.\n       \\<lbrakk>length w = n; bddh (Suc n) (Branch l r);\n        bdd_all (nfa_is_node N) (Branch l r); 0 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd 0 (Branch l r)) w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Branch l r) (insertl 0 b w)))\n 3. \\<And>i l r n w.\n       \\<lbrakk>\\<And>n w.\n                   \\<lbrakk>length w = n; bddh (Suc n) l;\n                    bdd_all (nfa_is_node N) l; i \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> set_of_bv\n(bdd_lookup (quantify_bdd i l) w) =\n                                     (\\<Union>b.\n   set_of_bv (bdd_lookup l (insertl i b w)));\n        \\<And>n w.\n           \\<lbrakk>length w = n; bddh (Suc n) r; bdd_all (nfa_is_node N) r;\n            i \\<le> n\\<rbrakk>\n           \\<Longrightarrow> set_of_bv (bdd_lookup (quantify_bdd i r) w) =\n                             (\\<Union>b.\n                                 set_of_bv (bdd_lookup r (insertl i b w)));\n        length w = n; bddh (Suc n) (Branch l r);\n        bdd_all (nfa_is_node N) (Branch l r); Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd (Suc i) (Branch l r))\n                            w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Branch l r)\n                                (insertl (Suc i) b w)))", "have \"\\<dots> = set_of_bv (bdd_lookup (Branch l r) (insertl 0 False w)) \\<union> set_of_bv (bdd_lookup (Branch l r) (insertl 0 True w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_of_bv (bdd_lookup l w) \\<union> set_of_bv (bdd_lookup r w) =\n    set_of_bv (bdd_lookup (Branch l r) (insertl 0 False w)) \\<union>\n    set_of_bv (bdd_lookup (Branch l r) (insertl 0 True w))", "by (cases w) simp+"], ["proof (state)\nthis:\n  set_of_bv (bdd_lookup l w) \\<union> set_of_bv (bdd_lookup r w) =\n  set_of_bv (bdd_lookup (Branch l r) (insertl 0 False w)) \\<union>\n  set_of_bv (bdd_lookup (Branch l r) (insertl 0 True w))\n\ngoal (3 subgoals):\n 1. \\<And>i q n w.\n       \\<lbrakk>length w = n; bddh (Suc n) (Leaf q);\n        bdd_all (nfa_is_node N) (Leaf q); i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd i (Leaf q)) w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Leaf q) (insertl i b w)))\n 2. \\<And>l r n w.\n       \\<lbrakk>length w = n; bddh (Suc n) (Branch l r);\n        bdd_all (nfa_is_node N) (Branch l r); 0 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd 0 (Branch l r)) w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Branch l r) (insertl 0 b w)))\n 3. \\<And>i l r n w.\n       \\<lbrakk>\\<And>n w.\n                   \\<lbrakk>length w = n; bddh (Suc n) l;\n                    bdd_all (nfa_is_node N) l; i \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> set_of_bv\n(bdd_lookup (quantify_bdd i l) w) =\n                                     (\\<Union>b.\n   set_of_bv (bdd_lookup l (insertl i b w)));\n        \\<And>n w.\n           \\<lbrakk>length w = n; bddh (Suc n) r; bdd_all (nfa_is_node N) r;\n            i \\<le> n\\<rbrakk>\n           \\<Longrightarrow> set_of_bv (bdd_lookup (quantify_bdd i r) w) =\n                             (\\<Union>b.\n                                 set_of_bv (bdd_lookup r (insertl i b w)));\n        length w = n; bddh (Suc n) (Branch l r);\n        bdd_all (nfa_is_node N) (Branch l r); Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd (Suc i) (Branch l r))\n                            w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Branch l r)\n                                (insertl (Suc i) b w)))", "also"], ["proof (state)\nthis:\n  set_of_bv (bdd_lookup l w) \\<union> set_of_bv (bdd_lookup r w) =\n  set_of_bv (bdd_lookup (Branch l r) (insertl 0 False w)) \\<union>\n  set_of_bv (bdd_lookup (Branch l r) (insertl 0 True w))\n\ngoal (3 subgoals):\n 1. \\<And>i q n w.\n       \\<lbrakk>length w = n; bddh (Suc n) (Leaf q);\n        bdd_all (nfa_is_node N) (Leaf q); i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd i (Leaf q)) w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Leaf q) (insertl i b w)))\n 2. \\<And>l r n w.\n       \\<lbrakk>length w = n; bddh (Suc n) (Branch l r);\n        bdd_all (nfa_is_node N) (Branch l r); 0 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd 0 (Branch l r)) w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Branch l r) (insertl 0 b w)))\n 3. \\<And>i l r n w.\n       \\<lbrakk>\\<And>n w.\n                   \\<lbrakk>length w = n; bddh (Suc n) l;\n                    bdd_all (nfa_is_node N) l; i \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> set_of_bv\n(bdd_lookup (quantify_bdd i l) w) =\n                                     (\\<Union>b.\n   set_of_bv (bdd_lookup l (insertl i b w)));\n        \\<And>n w.\n           \\<lbrakk>length w = n; bddh (Suc n) r; bdd_all (nfa_is_node N) r;\n            i \\<le> n\\<rbrakk>\n           \\<Longrightarrow> set_of_bv (bdd_lookup (quantify_bdd i r) w) =\n                             (\\<Union>b.\n                                 set_of_bv (bdd_lookup r (insertl i b w)));\n        length w = n; bddh (Suc n) (Branch l r);\n        bdd_all (nfa_is_node N) (Branch l r); Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd (Suc i) (Branch l r))\n                            w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Branch l r)\n                                (insertl (Suc i) b w)))", "have \"\\<dots> = (\\<Union>b \\<in> {True, False}. set_of_bv (bdd_lookup (Branch l r) (insertl 0 b w)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_of_bv (bdd_lookup (Branch l r) (insertl 0 False w)) \\<union>\n    set_of_bv (bdd_lookup (Branch l r) (insertl 0 True w)) =\n    (\\<Union>b\\<in>{True, False}.\n        set_of_bv (bdd_lookup (Branch l r) (insertl 0 b w)))", "by auto"], ["proof (state)\nthis:\n  set_of_bv (bdd_lookup (Branch l r) (insertl 0 False w)) \\<union>\n  set_of_bv (bdd_lookup (Branch l r) (insertl 0 True w)) =\n  (\\<Union>b\\<in>{True, False}.\n      set_of_bv (bdd_lookup (Branch l r) (insertl 0 b w)))\n\ngoal (3 subgoals):\n 1. \\<And>i q n w.\n       \\<lbrakk>length w = n; bddh (Suc n) (Leaf q);\n        bdd_all (nfa_is_node N) (Leaf q); i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd i (Leaf q)) w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Leaf q) (insertl i b w)))\n 2. \\<And>l r n w.\n       \\<lbrakk>length w = n; bddh (Suc n) (Branch l r);\n        bdd_all (nfa_is_node N) (Branch l r); 0 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd 0 (Branch l r)) w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Branch l r) (insertl 0 b w)))\n 3. \\<And>i l r n w.\n       \\<lbrakk>\\<And>n w.\n                   \\<lbrakk>length w = n; bddh (Suc n) l;\n                    bdd_all (nfa_is_node N) l; i \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> set_of_bv\n(bdd_lookup (quantify_bdd i l) w) =\n                                     (\\<Union>b.\n   set_of_bv (bdd_lookup l (insertl i b w)));\n        \\<And>n w.\n           \\<lbrakk>length w = n; bddh (Suc n) r; bdd_all (nfa_is_node N) r;\n            i \\<le> n\\<rbrakk>\n           \\<Longrightarrow> set_of_bv (bdd_lookup (quantify_bdd i r) w) =\n                             (\\<Union>b.\n                                 set_of_bv (bdd_lookup r (insertl i b w)));\n        length w = n; bddh (Suc n) (Branch l r);\n        bdd_all (nfa_is_node N) (Branch l r); Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd (Suc i) (Branch l r))\n                            w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Branch l r)\n                                (insertl (Suc i) b w)))", "also"], ["proof (state)\nthis:\n  set_of_bv (bdd_lookup (Branch l r) (insertl 0 False w)) \\<union>\n  set_of_bv (bdd_lookup (Branch l r) (insertl 0 True w)) =\n  (\\<Union>b\\<in>{True, False}.\n      set_of_bv (bdd_lookup (Branch l r) (insertl 0 b w)))\n\ngoal (3 subgoals):\n 1. \\<And>i q n w.\n       \\<lbrakk>length w = n; bddh (Suc n) (Leaf q);\n        bdd_all (nfa_is_node N) (Leaf q); i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd i (Leaf q)) w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Leaf q) (insertl i b w)))\n 2. \\<And>l r n w.\n       \\<lbrakk>length w = n; bddh (Suc n) (Branch l r);\n        bdd_all (nfa_is_node N) (Branch l r); 0 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd 0 (Branch l r)) w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Branch l r) (insertl 0 b w)))\n 3. \\<And>i l r n w.\n       \\<lbrakk>\\<And>n w.\n                   \\<lbrakk>length w = n; bddh (Suc n) l;\n                    bdd_all (nfa_is_node N) l; i \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> set_of_bv\n(bdd_lookup (quantify_bdd i l) w) =\n                                     (\\<Union>b.\n   set_of_bv (bdd_lookup l (insertl i b w)));\n        \\<And>n w.\n           \\<lbrakk>length w = n; bddh (Suc n) r; bdd_all (nfa_is_node N) r;\n            i \\<le> n\\<rbrakk>\n           \\<Longrightarrow> set_of_bv (bdd_lookup (quantify_bdd i r) w) =\n                             (\\<Union>b.\n                                 set_of_bv (bdd_lookup r (insertl i b w)));\n        length w = n; bddh (Suc n) (Branch l r);\n        bdd_all (nfa_is_node N) (Branch l r); Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd (Suc i) (Branch l r))\n                            w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Branch l r)\n                                (insertl (Suc i) b w)))", "have \"\\<dots> = (\\<Union>b. set_of_bv (bdd_lookup (Branch l r) (insertl 0 b w)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>b\\<in>{True, False}.\n        set_of_bv (bdd_lookup (Branch l r) (insertl 0 b w))) =\n    (\\<Union>b. set_of_bv (bdd_lookup (Branch l r) (insertl 0 b w)))", "by blast"], ["proof (state)\nthis:\n  (\\<Union>b\\<in>{True, False}.\n      set_of_bv (bdd_lookup (Branch l r) (insertl 0 b w))) =\n  (\\<Union>b. set_of_bv (bdd_lookup (Branch l r) (insertl 0 b w)))\n\ngoal (3 subgoals):\n 1. \\<And>i q n w.\n       \\<lbrakk>length w = n; bddh (Suc n) (Leaf q);\n        bdd_all (nfa_is_node N) (Leaf q); i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd i (Leaf q)) w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Leaf q) (insertl i b w)))\n 2. \\<And>l r n w.\n       \\<lbrakk>length w = n; bddh (Suc n) (Branch l r);\n        bdd_all (nfa_is_node N) (Branch l r); 0 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd 0 (Branch l r)) w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Branch l r) (insertl 0 b w)))\n 3. \\<And>i l r n w.\n       \\<lbrakk>\\<And>n w.\n                   \\<lbrakk>length w = n; bddh (Suc n) l;\n                    bdd_all (nfa_is_node N) l; i \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> set_of_bv\n(bdd_lookup (quantify_bdd i l) w) =\n                                     (\\<Union>b.\n   set_of_bv (bdd_lookup l (insertl i b w)));\n        \\<And>n w.\n           \\<lbrakk>length w = n; bddh (Suc n) r; bdd_all (nfa_is_node N) r;\n            i \\<le> n\\<rbrakk>\n           \\<Longrightarrow> set_of_bv (bdd_lookup (quantify_bdd i r) w) =\n                             (\\<Union>b.\n                                 set_of_bv (bdd_lookup r (insertl i b w)));\n        length w = n; bddh (Suc n) (Branch l r);\n        bdd_all (nfa_is_node N) (Branch l r); Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd (Suc i) (Branch l r))\n                            w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Branch l r)\n                                (insertl (Suc i) b w)))", "finally"], ["proof (chain)\npicking this:\n  set_of_bv (bdd_lookup (quantify_bdd 0 (Branch l r)) w) =\n  (\\<Union>b. set_of_bv (bdd_lookup (Branch l r) (insertl 0 b w)))", "show ?case"], ["proof (prove)\nusing this:\n  set_of_bv (bdd_lookup (quantify_bdd 0 (Branch l r)) w) =\n  (\\<Union>b. set_of_bv (bdd_lookup (Branch l r) (insertl 0 b w)))\n\ngoal (1 subgoal):\n 1. set_of_bv (bdd_lookup (quantify_bdd 0 (Branch l r)) w) =\n    (\\<Union>b. set_of_bv (bdd_lookup (Branch l r) (insertl 0 b w)))", "."], ["proof (state)\nthis:\n  set_of_bv (bdd_lookup (quantify_bdd 0 (Branch l r)) w) =\n  (\\<Union>b. set_of_bv (bdd_lookup (Branch l r) (insertl 0 b w)))\n\ngoal (2 subgoals):\n 1. \\<And>i q n w.\n       \\<lbrakk>length w = n; bddh (Suc n) (Leaf q);\n        bdd_all (nfa_is_node N) (Leaf q); i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd i (Leaf q)) w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Leaf q) (insertl i b w)))\n 2. \\<And>i l r n w.\n       \\<lbrakk>\\<And>n w.\n                   \\<lbrakk>length w = n; bddh (Suc n) l;\n                    bdd_all (nfa_is_node N) l; i \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> set_of_bv\n(bdd_lookup (quantify_bdd i l) w) =\n                                     (\\<Union>b.\n   set_of_bv (bdd_lookup l (insertl i b w)));\n        \\<And>n w.\n           \\<lbrakk>length w = n; bddh (Suc n) r; bdd_all (nfa_is_node N) r;\n            i \\<le> n\\<rbrakk>\n           \\<Longrightarrow> set_of_bv (bdd_lookup (quantify_bdd i r) w) =\n                             (\\<Union>b.\n                                 set_of_bv (bdd_lookup r (insertl i b w)));\n        length w = n; bddh (Suc n) (Branch l r);\n        bdd_all (nfa_is_node N) (Branch l r); Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd (Suc i) (Branch l r))\n                            w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Branch l r)\n                                (insertl (Suc i) b w)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i q n w.\n       \\<lbrakk>length w = n; bddh (Suc n) (Leaf q);\n        bdd_all (nfa_is_node N) (Leaf q); i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd i (Leaf q)) w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Leaf q) (insertl i b w)))\n 2. \\<And>i l r n w.\n       \\<lbrakk>\\<And>n w.\n                   \\<lbrakk>length w = n; bddh (Suc n) l;\n                    bdd_all (nfa_is_node N) l; i \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> set_of_bv\n(bdd_lookup (quantify_bdd i l) w) =\n                                     (\\<Union>b.\n   set_of_bv (bdd_lookup l (insertl i b w)));\n        \\<And>n w.\n           \\<lbrakk>length w = n; bddh (Suc n) r; bdd_all (nfa_is_node N) r;\n            i \\<le> n\\<rbrakk>\n           \\<Longrightarrow> set_of_bv (bdd_lookup (quantify_bdd i r) w) =\n                             (\\<Union>b.\n                                 set_of_bv (bdd_lookup r (insertl i b w)));\n        length w = n; bddh (Suc n) (Branch l r);\n        bdd_all (nfa_is_node N) (Branch l r); Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd (Suc i) (Branch l r))\n                            w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Branch l r)\n                                (insertl (Suc i) b w)))", "case (3 n l r k w)"], ["proof (state)\nthis:\n  \\<lbrakk>length ?w = ?n; bddh (Suc ?n) l; bdd_all (nfa_is_node N) l;\n   n \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> set_of_bv (bdd_lookup (quantify_bdd n l) ?w) =\n                    (\\<Union>b. set_of_bv (bdd_lookup l (insertl n b ?w)))\n  \\<lbrakk>length ?w = ?n; bddh (Suc ?n) r; bdd_all (nfa_is_node N) r;\n   n \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> set_of_bv (bdd_lookup (quantify_bdd n r) ?w) =\n                    (\\<Union>b. set_of_bv (bdd_lookup r (insertl n b ?w)))\n  length w = k\n  bddh (Suc k) (Branch l r)\n  bdd_all (nfa_is_node N) (Branch l r)\n  Suc n \\<le> k\n\ngoal (2 subgoals):\n 1. \\<And>i q n w.\n       \\<lbrakk>length w = n; bddh (Suc n) (Leaf q);\n        bdd_all (nfa_is_node N) (Leaf q); i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd i (Leaf q)) w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Leaf q) (insertl i b w)))\n 2. \\<And>i l r n w.\n       \\<lbrakk>\\<And>n w.\n                   \\<lbrakk>length w = n; bddh (Suc n) l;\n                    bdd_all (nfa_is_node N) l; i \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> set_of_bv\n(bdd_lookup (quantify_bdd i l) w) =\n                                     (\\<Union>b.\n   set_of_bv (bdd_lookup l (insertl i b w)));\n        \\<And>n w.\n           \\<lbrakk>length w = n; bddh (Suc n) r; bdd_all (nfa_is_node N) r;\n            i \\<le> n\\<rbrakk>\n           \\<Longrightarrow> set_of_bv (bdd_lookup (quantify_bdd i r) w) =\n                             (\\<Union>b.\n                                 set_of_bv (bdd_lookup r (insertl i b w)));\n        length w = n; bddh (Suc n) (Branch l r);\n        bdd_all (nfa_is_node N) (Branch l r); Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd (Suc i) (Branch l r))\n                            w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Branch l r)\n                                (insertl (Suc i) b w)))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?w = ?n; bddh (Suc ?n) l; bdd_all (nfa_is_node N) l;\n   n \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> set_of_bv (bdd_lookup (quantify_bdd n l) ?w) =\n                    (\\<Union>b. set_of_bv (bdd_lookup l (insertl n b ?w)))\n  \\<lbrakk>length ?w = ?n; bddh (Suc ?n) r; bdd_all (nfa_is_node N) r;\n   n \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> set_of_bv (bdd_lookup (quantify_bdd n r) ?w) =\n                    (\\<Union>b. set_of_bv (bdd_lookup r (insertl n b ?w)))\n  length w = k\n  bddh (Suc k) (Branch l r)\n  bdd_all (nfa_is_node N) (Branch l r)\n  Suc n \\<le> k", "obtain j where J: \"k = Suc j\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?w = ?n; bddh (Suc ?n) l; bdd_all (nfa_is_node N) l;\n   n \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> set_of_bv (bdd_lookup (quantify_bdd n l) ?w) =\n                    (\\<Union>b. set_of_bv (bdd_lookup l (insertl n b ?w)))\n  \\<lbrakk>length ?w = ?n; bddh (Suc ?n) r; bdd_all (nfa_is_node N) r;\n   n \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> set_of_bv (bdd_lookup (quantify_bdd n r) ?w) =\n                    (\\<Union>b. set_of_bv (bdd_lookup r (insertl n b ?w)))\n  length w = k\n  bddh (Suc k) (Branch l r)\n  bdd_all (nfa_is_node N) (Branch l r)\n  Suc n \\<le> k\n\ngoal (1 subgoal):\n 1. (\\<And>j. k = Suc j \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases k) simp+"], ["proof (state)\nthis:\n  k = Suc j\n\ngoal (2 subgoals):\n 1. \\<And>i q n w.\n       \\<lbrakk>length w = n; bddh (Suc n) (Leaf q);\n        bdd_all (nfa_is_node N) (Leaf q); i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd i (Leaf q)) w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Leaf q) (insertl i b w)))\n 2. \\<And>i l r n w.\n       \\<lbrakk>\\<And>n w.\n                   \\<lbrakk>length w = n; bddh (Suc n) l;\n                    bdd_all (nfa_is_node N) l; i \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> set_of_bv\n(bdd_lookup (quantify_bdd i l) w) =\n                                     (\\<Union>b.\n   set_of_bv (bdd_lookup l (insertl i b w)));\n        \\<And>n w.\n           \\<lbrakk>length w = n; bddh (Suc n) r; bdd_all (nfa_is_node N) r;\n            i \\<le> n\\<rbrakk>\n           \\<Longrightarrow> set_of_bv (bdd_lookup (quantify_bdd i r) w) =\n                             (\\<Union>b.\n                                 set_of_bv (bdd_lookup r (insertl i b w)));\n        length w = n; bddh (Suc n) (Branch l r);\n        bdd_all (nfa_is_node N) (Branch l r); Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd (Suc i) (Branch l r))\n                            w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Branch l r)\n                                (insertl (Suc i) b w)))", "with 3"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?w = ?n; bddh (Suc ?n) l; bdd_all (nfa_is_node N) l;\n   n \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> set_of_bv (bdd_lookup (quantify_bdd n l) ?w) =\n                    (\\<Union>b. set_of_bv (bdd_lookup l (insertl n b ?w)))\n  \\<lbrakk>length ?w = ?n; bddh (Suc ?n) r; bdd_all (nfa_is_node N) r;\n   n \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> set_of_bv (bdd_lookup (quantify_bdd n r) ?w) =\n                    (\\<Union>b. set_of_bv (bdd_lookup r (insertl n b ?w)))\n  length w = k\n  bddh (Suc k) (Branch l r)\n  bdd_all (nfa_is_node N) (Branch l r)\n  Suc n \\<le> k\n  k = Suc j", "obtain a as where W: \"w = a # as\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?w = ?n; bddh (Suc ?n) l; bdd_all (nfa_is_node N) l;\n   n \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> set_of_bv (bdd_lookup (quantify_bdd n l) ?w) =\n                    (\\<Union>b. set_of_bv (bdd_lookup l (insertl n b ?w)))\n  \\<lbrakk>length ?w = ?n; bddh (Suc ?n) r; bdd_all (nfa_is_node N) r;\n   n \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> set_of_bv (bdd_lookup (quantify_bdd n r) ?w) =\n                    (\\<Union>b. set_of_bv (bdd_lookup r (insertl n b ?w)))\n  length w = k\n  bddh (Suc k) (Branch l r)\n  bdd_all (nfa_is_node N) (Branch l r)\n  Suc n \\<le> k\n  k = Suc j\n\ngoal (1 subgoal):\n 1. (\\<And>a as. w = a # as \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases w) auto"], ["proof (state)\nthis:\n  w = a # as\n\ngoal (2 subgoals):\n 1. \\<And>i q n w.\n       \\<lbrakk>length w = n; bddh (Suc n) (Leaf q);\n        bdd_all (nfa_is_node N) (Leaf q); i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd i (Leaf q)) w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Leaf q) (insertl i b w)))\n 2. \\<And>i l r n w.\n       \\<lbrakk>\\<And>n w.\n                   \\<lbrakk>length w = n; bddh (Suc n) l;\n                    bdd_all (nfa_is_node N) l; i \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> set_of_bv\n(bdd_lookup (quantify_bdd i l) w) =\n                                     (\\<Union>b.\n   set_of_bv (bdd_lookup l (insertl i b w)));\n        \\<And>n w.\n           \\<lbrakk>length w = n; bddh (Suc n) r; bdd_all (nfa_is_node N) r;\n            i \\<le> n\\<rbrakk>\n           \\<Longrightarrow> set_of_bv (bdd_lookup (quantify_bdd i r) w) =\n                             (\\<Union>b.\n                                 set_of_bv (bdd_lookup r (insertl i b w)));\n        length w = n; bddh (Suc n) (Branch l r);\n        bdd_all (nfa_is_node N) (Branch l r); Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd (Suc i) (Branch l r))\n                            w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Branch l r)\n                                (insertl (Suc i) b w)))", "with 3 J"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?w = ?n; bddh (Suc ?n) l; bdd_all (nfa_is_node N) l;\n   n \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> set_of_bv (bdd_lookup (quantify_bdd n l) ?w) =\n                    (\\<Union>b. set_of_bv (bdd_lookup l (insertl n b ?w)))\n  \\<lbrakk>length ?w = ?n; bddh (Suc ?n) r; bdd_all (nfa_is_node N) r;\n   n \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> set_of_bv (bdd_lookup (quantify_bdd n r) ?w) =\n                    (\\<Union>b. set_of_bv (bdd_lookup r (insertl n b ?w)))\n  length w = k\n  bddh (Suc k) (Branch l r)\n  bdd_all (nfa_is_node N) (Branch l r)\n  Suc n \\<le> k\n  k = Suc j\n  w = a # as", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?w = ?n; bddh (Suc ?n) l; bdd_all (nfa_is_node N) l;\n   n \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> set_of_bv (bdd_lookup (quantify_bdd n l) ?w) =\n                    (\\<Union>b. set_of_bv (bdd_lookup l (insertl n b ?w)))\n  \\<lbrakk>length ?w = ?n; bddh (Suc ?n) r; bdd_all (nfa_is_node N) r;\n   n \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> set_of_bv (bdd_lookup (quantify_bdd n r) ?w) =\n                    (\\<Union>b. set_of_bv (bdd_lookup r (insertl n b ?w)))\n  length w = k\n  bddh (Suc k) (Branch l r)\n  bdd_all (nfa_is_node N) (Branch l r)\n  Suc n \\<le> k\n  k = Suc j\n  w = a # as\n\ngoal (1 subgoal):\n 1. set_of_bv (bdd_lookup (quantify_bdd (Suc n) (Branch l r)) w) =\n    (\\<Union>b. set_of_bv (bdd_lookup (Branch l r) (insertl (Suc n) b w)))", "by (cases a) simp+"], ["proof (state)\nthis:\n  set_of_bv (bdd_lookup (quantify_bdd (Suc n) (Branch l r)) w) =\n  (\\<Union>b. set_of_bv (bdd_lookup (Branch l r) (insertl (Suc n) b w)))\n\ngoal (1 subgoal):\n 1. \\<And>i q n w.\n       \\<lbrakk>length w = n; bddh (Suc n) (Leaf q);\n        bdd_all (nfa_is_node N) (Leaf q); i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (bdd_lookup (quantify_bdd i (Leaf q)) w) =\n                         (\\<Union>b.\n                             set_of_bv\n                              (bdd_lookup (Leaf q) (insertl i b w)))", "qed simp"], ["", "lemma subsetbdd_set_of_bv:\n  assumes \"wf_nfa N (length ws)\"\n  and \"nfa_is_node N q\"\n  shows \"set_of_bv (bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q))) ws) = (\\<Union>i\\<in>set_of_bv q. set_of_bv (bdd_lookup (fst N ! i) ws))\"\n  (is \"set_of_bv ?q = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_of_bv\n     (bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q))) ws) =\n    (\\<Union>i\\<in>set_of_bv q. set_of_bv (bdd_lookup (fst N ! i) ws))", "proof (simp only: set_eq_iff, rule allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> set_of_bv\n                 (bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q)))\n                   ws)) =\n       (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                    set_of_bv (bdd_lookup (fst N ! i) ws)))", "fix x :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> set_of_bv\n                 (bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q)))\n                   ws)) =\n       (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                    set_of_bv (bdd_lookup (fst N ! i) ws)))", "from assms"], ["proof (chain)\npicking this:\n  wf_nfa N (length ws)\n  nfa_is_node N q", "have \"bdd_all (nfa_is_node N) (subsetbdd (fst N) q (nfa_emptybdd (length q)))\""], ["proof (prove)\nusing this:\n  wf_nfa N (length ws)\n  nfa_is_node N q\n\ngoal (1 subgoal):\n 1. bdd_all (nfa_is_node N) (subsetbdd (fst N) q (nfa_emptybdd (length q)))", "by (simp add: wf_nfa_def bdd_all_is_node_subsetbdd)"], ["proof (state)\nthis:\n  bdd_all (nfa_is_node N) (subsetbdd (fst N) q (nfa_emptybdd (length q)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> set_of_bv\n                 (bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q)))\n                   ws)) =\n       (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                    set_of_bv (bdd_lookup (fst N ! i) ws)))", "with assms"], ["proof (chain)\npicking this:\n  wf_nfa N (length ws)\n  nfa_is_node N q\n  bdd_all (nfa_is_node N) (subsetbdd (fst N) q (nfa_emptybdd (length q)))", "have \"nfa_is_node N ?q\""], ["proof (prove)\nusing this:\n  wf_nfa N (length ws)\n  nfa_is_node N q\n  bdd_all (nfa_is_node N) (subsetbdd (fst N) q (nfa_emptybdd (length q)))\n\ngoal (1 subgoal):\n 1. nfa_is_node N\n     (bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q))) ws)", "by (simp add: wf_nfa_def bdd_all_bdd_lookup bddh_subsetbdd nfa_emptybdd_def)"], ["proof (state)\nthis:\n  nfa_is_node N\n   (bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q))) ws)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> set_of_bv\n                 (bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q)))\n                   ws)) =\n       (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                    set_of_bv (bdd_lookup (fst N ! i) ws)))", "hence L: \"length ?q = length (fst N)\""], ["proof (prove)\nusing this:\n  nfa_is_node N\n   (bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q))) ws)\n\ngoal (1 subgoal):\n 1. length (bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q))) ws) =\n    length (fst N)", "by (simp add: nfa_is_node_def)"], ["proof (state)\nthis:\n  length (bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q))) ws) =\n  length (fst N)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> set_of_bv\n                 (bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q)))\n                   ws)) =\n       (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                    set_of_bv (bdd_lookup (fst N ! i) ws)))", "{"], ["proof (state)\nthis:\n  length (bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q))) ws) =\n  length (fst N)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> set_of_bv\n                 (bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q)))\n                   ws)) =\n       (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                    set_of_bv (bdd_lookup (fst N ! i) ws)))", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> set_of_bv\n                 (bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q)))\n                   ws)) =\n       (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                    set_of_bv (bdd_lookup (fst N ! i) ws)))", "assume H: \"i < length (fst N)\""], ["proof (state)\nthis:\n  i < length (fst N)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> set_of_bv\n                 (bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q)))\n                   ws)) =\n       (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                    set_of_bv (bdd_lookup (fst N ! i) ws)))", "with assms"], ["proof (chain)\npicking this:\n  wf_nfa N (length ws)\n  nfa_is_node N q\n  i < length (fst N)", "have \"nfa_is_node N (bdd_lookup (fst N ! i) ws)\""], ["proof (prove)\nusing this:\n  wf_nfa N (length ws)\n  nfa_is_node N q\n  i < length (fst N)\n\ngoal (1 subgoal):\n 1. nfa_is_node N (bdd_lookup (fst N ! i) ws)", "by (simp add: wf_nfa_def list_all_iff bdd_all_bdd_lookup)"], ["proof (state)\nthis:\n  nfa_is_node N (bdd_lookup (fst N ! i) ws)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> set_of_bv\n                 (bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q)))\n                   ws)) =\n       (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                    set_of_bv (bdd_lookup (fst N ! i) ws)))", "}"], ["proof (state)\nthis:\n  ?i2 < length (fst N) \\<Longrightarrow>\n  nfa_is_node N (bdd_lookup (fst N ! ?i2) ws)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> set_of_bv\n                 (bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q)))\n                   ws)) =\n       (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                    set_of_bv (bdd_lookup (fst N ! i) ws)))", "with assms"], ["proof (chain)\npicking this:\n  wf_nfa N (length ws)\n  nfa_is_node N q\n  ?i2 < length (fst N) \\<Longrightarrow>\n  nfa_is_node N (bdd_lookup (fst N ! ?i2) ws)", "have I: \"\\<And>i. i < length q \\<Longrightarrow> nfa_is_node N (bdd_lookup (fst N ! i) ws)\""], ["proof (prove)\nusing this:\n  wf_nfa N (length ws)\n  nfa_is_node N q\n  ?i2 < length (fst N) \\<Longrightarrow>\n  nfa_is_node N (bdd_lookup (fst N ! ?i2) ws)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length q \\<Longrightarrow>\n       nfa_is_node N (bdd_lookup (fst N ! i) ws)", "by (simp add: nfa_is_node_def)"], ["proof (state)\nthis:\n  ?i < length q \\<Longrightarrow> nfa_is_node N (bdd_lookup (fst N ! ?i) ws)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> set_of_bv\n                 (bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q)))\n                   ws)) =\n       (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                    set_of_bv (bdd_lookup (fst N ! i) ws)))", "from L assms"], ["proof (chain)\npicking this:\n  length (bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q))) ws) =\n  length (fst N)\n  wf_nfa N (length ws)\n  nfa_is_node N q", "have \"x \\<in> set_of_bv ?q = (x < length (fst N) \\<and> (\\<exists>i \\<in> set_of_bv q. bdd_lookup (fst N ! i) ws ! x \\<and> i < length q))\""], ["proof (prove)\nusing this:\n  length (bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q))) ws) =\n  length (fst N)\n  wf_nfa N (length ws)\n  nfa_is_node N q\n\ngoal (1 subgoal):\n 1. (x \\<in> set_of_bv\n              (bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q)))\n                ws)) =\n    (x < length (fst N) \\<and>\n     (\\<exists>i\\<in>set_of_bv q.\n         bdd_lookup (fst N ! i) ws ! x \\<and> i < length q))", "by (auto simp add: set_of_bv_def bdd_lookup_subsetbdd)"], ["proof (state)\nthis:\n  (x \\<in> set_of_bv\n            (bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q)))\n              ws)) =\n  (x < length (fst N) \\<and>\n   (\\<exists>i\\<in>set_of_bv q.\n       bdd_lookup (fst N ! i) ws ! x \\<and> i < length q))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> set_of_bv\n                 (bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q)))\n                   ws)) =\n       (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                    set_of_bv (bdd_lookup (fst N ! i) ws)))", "also"], ["proof (state)\nthis:\n  (x \\<in> set_of_bv\n            (bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q)))\n              ws)) =\n  (x < length (fst N) \\<and>\n   (\\<exists>i\\<in>set_of_bv q.\n       bdd_lookup (fst N ! i) ws ! x \\<and> i < length q))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> set_of_bv\n                 (bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q)))\n                   ws)) =\n       (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                    set_of_bv (bdd_lookup (fst N ! i) ws)))", "from I"], ["proof (chain)\npicking this:\n  ?i < length q \\<Longrightarrow> nfa_is_node N (bdd_lookup (fst N ! ?i) ws)", "have \"\\<dots> = (x \\<in> (\\<Union>i \\<in> set_of_bv q. set_of_bv (bdd_lookup (fst N ! i) ws)))\""], ["proof (prove)\nusing this:\n  ?i < length q \\<Longrightarrow> nfa_is_node N (bdd_lookup (fst N ! ?i) ws)\n\ngoal (1 subgoal):\n 1. (x < length (fst N) \\<and>\n     (\\<exists>i\\<in>set_of_bv q.\n         bdd_lookup (fst N ! i) ws ! x \\<and> i < length q)) =\n    (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                 set_of_bv (bdd_lookup (fst N ! i) ws)))", "by (auto simp: nfa_is_node_def set_of_bv_def)"], ["proof (state)\nthis:\n  (x < length (fst N) \\<and>\n   (\\<exists>i\\<in>set_of_bv q.\n       bdd_lookup (fst N ! i) ws ! x \\<and> i < length q)) =\n  (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n               set_of_bv (bdd_lookup (fst N ! i) ws)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> set_of_bv\n                 (bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q)))\n                   ws)) =\n       (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                    set_of_bv (bdd_lookup (fst N ! i) ws)))", "finally"], ["proof (chain)\npicking this:\n  (x \\<in> set_of_bv\n            (bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q)))\n              ws)) =\n  (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n               set_of_bv (bdd_lookup (fst N ! i) ws)))", "show \"x \\<in> set_of_bv ?q = (x \\<in> (\\<Union>i \\<in> set_of_bv q. set_of_bv (bdd_lookup (fst N ! i) ws)))\""], ["proof (prove)\nusing this:\n  (x \\<in> set_of_bv\n            (bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q)))\n              ws)) =\n  (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n               set_of_bv (bdd_lookup (fst N ! i) ws)))\n\ngoal (1 subgoal):\n 1. (x \\<in> set_of_bv\n              (bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q)))\n                ws)) =\n    (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                 set_of_bv (bdd_lookup (fst N ! i) ws)))", "."], ["proof (state)\nthis:\n  (x \\<in> set_of_bv\n            (bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q)))\n              ws)) =\n  (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n               set_of_bv (bdd_lookup (fst N ! i) ws)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nfa_trans_quantify_nfa:\n  assumes \"wf_nfa N (Suc n)\"\n  and \"v \\<le> n\"\n  and \"is_alph n w\"\n  and \"nfa_is_node N q\"\n  shows \"set_of_bv (nfa_trans (quantify_nfa v N) q w) = (\\<Union>b. set_of_bv (nfa_trans N q (insertl v b w)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_of_bv (nfa_trans (quantify_nfa v N) q w) =\n    (\\<Union>b. set_of_bv (nfa_trans N q (insertl v b w)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_of_bv (nfa_trans (quantify_nfa v N) q w) =\n    (\\<Union>b. set_of_bv (nfa_trans N q (insertl v b w)))", "from assms"], ["proof (chain)\npicking this:\n  wf_nfa N (Suc n)\n  v \\<le> n\n  is_alph n w\n  nfa_is_node N q", "have V1: \"wf_nfa (quantify_nfa v N) n\""], ["proof (prove)\nusing this:\n  wf_nfa N (Suc n)\n  v \\<le> n\n  is_alph n w\n  nfa_is_node N q\n\ngoal (1 subgoal):\n 1. wf_nfa (quantify_nfa v N) n", "by (simp add: quantify_nfa_well_formed_aut)"], ["proof (state)\nthis:\n  wf_nfa (quantify_nfa v N) n\n\ngoal (1 subgoal):\n 1. set_of_bv (nfa_trans (quantify_nfa v N) q w) =\n    (\\<Union>b. set_of_bv (nfa_trans N q (insertl v b w)))", "with assms"], ["proof (chain)\npicking this:\n  wf_nfa N (Suc n)\n  v \\<le> n\n  is_alph n w\n  nfa_is_node N q\n  wf_nfa (quantify_nfa v N) n", "have V2: \"wf_nfa (quantify_nfa v N) (length w)\""], ["proof (prove)\nusing this:\n  wf_nfa N (Suc n)\n  v \\<le> n\n  is_alph n w\n  nfa_is_node N q\n  wf_nfa (quantify_nfa v N) n\n\ngoal (1 subgoal):\n 1. wf_nfa (quantify_nfa v N) (length w)", "by (simp add: wf_nfa_def is_alph_def)"], ["proof (state)\nthis:\n  wf_nfa (quantify_nfa v N) (length w)\n\ngoal (1 subgoal):\n 1. set_of_bv (nfa_trans (quantify_nfa v N) q w) =\n    (\\<Union>b. set_of_bv (nfa_trans N q (insertl v b w)))", "from assms"], ["proof (chain)\npicking this:\n  wf_nfa N (Suc n)\n  v \\<le> n\n  is_alph n w\n  nfa_is_node N q", "have N: \"nfa_is_node (quantify_nfa v N) q\""], ["proof (prove)\nusing this:\n  wf_nfa N (Suc n)\n  v \\<le> n\n  is_alph n w\n  nfa_is_node N q\n\ngoal (1 subgoal):\n 1. nfa_is_node (quantify_nfa v N) q", "by (simp add: quantify_nfa_def wf_nfa_def split_beta nfa_is_node_def)"], ["proof (state)\nthis:\n  nfa_is_node (quantify_nfa v N) q\n\ngoal (1 subgoal):\n 1. set_of_bv (nfa_trans (quantify_nfa v N) q w) =\n    (\\<Union>b. set_of_bv (nfa_trans N q (insertl v b w)))", "{"], ["proof (state)\nthis:\n  nfa_is_node (quantify_nfa v N) q\n\ngoal (1 subgoal):\n 1. set_of_bv (nfa_trans (quantify_nfa v N) q w) =\n    (\\<Union>b. set_of_bv (nfa_trans N q (insertl v b w)))", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. set_of_bv (nfa_trans (quantify_nfa v N) q w) =\n    (\\<Union>b. set_of_bv (nfa_trans N q (insertl v b w)))", "assume H: \"i \\<in> set_of_bv q\""], ["proof (state)\nthis:\n  i \\<in> set_of_bv q\n\ngoal (1 subgoal):\n 1. set_of_bv (nfa_trans (quantify_nfa v N) q w) =\n    (\\<Union>b. set_of_bv (nfa_trans N q (insertl v b w)))", "with assms"], ["proof (chain)\npicking this:\n  wf_nfa N (Suc n)\n  v \\<le> n\n  is_alph n w\n  nfa_is_node N q\n  i \\<in> set_of_bv q", "have \"i < length (fst N)\""], ["proof (prove)\nusing this:\n  wf_nfa N (Suc n)\n  v \\<le> n\n  is_alph n w\n  nfa_is_node N q\n  i \\<in> set_of_bv q\n\ngoal (1 subgoal):\n 1. i < length (fst N)", "by (simp add: nfa_is_node_def set_of_bv_def)"], ["proof (state)\nthis:\n  i < length (fst N)\n\ngoal (1 subgoal):\n 1. set_of_bv (nfa_trans (quantify_nfa v N) q w) =\n    (\\<Union>b. set_of_bv (nfa_trans N q (insertl v b w)))", "with assms"], ["proof (chain)\npicking this:\n  wf_nfa N (Suc n)\n  v \\<le> n\n  is_alph n w\n  nfa_is_node N q\n  i < length (fst N)", "have \"bddh (Suc n) (fst N ! i)\" \"bdd_all (nfa_is_node N) (fst N ! i)\""], ["proof (prove)\nusing this:\n  wf_nfa N (Suc n)\n  v \\<le> n\n  is_alph n w\n  nfa_is_node N q\n  i < length (fst N)\n\ngoal (1 subgoal):\n 1. bddh (Suc n) (fst N ! i) &&& bdd_all (nfa_is_node N) (fst N ! i)", "by (simp add: wf_nfa_def list_all_iff)+"], ["proof (state)\nthis:\n  bddh (Suc n) (fst N ! i)\n  bdd_all (nfa_is_node N) (fst N ! i)\n\ngoal (1 subgoal):\n 1. set_of_bv (nfa_trans (quantify_nfa v N) q w) =\n    (\\<Union>b. set_of_bv (nfa_trans N q (insertl v b w)))", "}"], ["proof (state)\nthis:\n  ?i2 \\<in> set_of_bv q \\<Longrightarrow> bddh (Suc n) (fst N ! ?i2)\n  ?i2 \\<in> set_of_bv q \\<Longrightarrow>\n  bdd_all (nfa_is_node N) (fst N ! ?i2)\n\ngoal (1 subgoal):\n 1. set_of_bv (nfa_trans (quantify_nfa v N) q w) =\n    (\\<Union>b. set_of_bv (nfa_trans N q (insertl v b w)))", "with assms"], ["proof (chain)\npicking this:\n  wf_nfa N (Suc n)\n  v \\<le> n\n  is_alph n w\n  nfa_is_node N q\n  ?i2 \\<in> set_of_bv q \\<Longrightarrow> bddh (Suc n) (fst N ! ?i2)\n  ?i2 \\<in> set_of_bv q \\<Longrightarrow>\n  bdd_all (nfa_is_node N) (fst N ! ?i2)", "have I: \"\\<And>i. i \\<in> set_of_bv q \\<Longrightarrow> length w = n \\<and> bddh (Suc n) (fst N ! i) \\<and> bdd_all (nfa_is_node N) (fst N ! i) \\<and> v \\<le> n\""], ["proof (prove)\nusing this:\n  wf_nfa N (Suc n)\n  v \\<le> n\n  is_alph n w\n  nfa_is_node N q\n  ?i2 \\<in> set_of_bv q \\<Longrightarrow> bddh (Suc n) (fst N ! ?i2)\n  ?i2 \\<in> set_of_bv q \\<Longrightarrow>\n  bdd_all (nfa_is_node N) (fst N ! ?i2)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> set_of_bv q \\<Longrightarrow>\n       length w = n \\<and>\n       bddh (Suc n) (fst N ! i) \\<and>\n       bdd_all (nfa_is_node N) (fst N ! i) \\<and> v \\<le> n", "by (simp add: is_alph_def)"], ["proof (state)\nthis:\n  ?i \\<in> set_of_bv q \\<Longrightarrow>\n  length w = n \\<and>\n  bddh (Suc n) (fst N ! ?i) \\<and>\n  bdd_all (nfa_is_node N) (fst N ! ?i) \\<and> v \\<le> n\n\ngoal (1 subgoal):\n 1. set_of_bv (nfa_trans (quantify_nfa v N) q w) =\n    (\\<Union>b. set_of_bv (nfa_trans N q (insertl v b w)))", "from assms"], ["proof (chain)\npicking this:\n  wf_nfa N (Suc n)\n  v \\<le> n\n  is_alph n w\n  nfa_is_node N q", "have V3: \"\\<And>b. wf_nfa N (length (insertl v b w))\""], ["proof (prove)\nusing this:\n  wf_nfa N (Suc n)\n  v \\<le> n\n  is_alph n w\n  nfa_is_node N q\n\ngoal (1 subgoal):\n 1. \\<And>b. wf_nfa N (length (insertl v b w))", "by (simp add: wf_nfa_def is_alph_def insertl_len)"], ["proof (state)\nthis:\n  wf_nfa N (length (insertl v ?b w))\n\ngoal (1 subgoal):\n 1. set_of_bv (nfa_trans (quantify_nfa v N) q w) =\n    (\\<Union>b. set_of_bv (nfa_trans N q (insertl v b w)))", "from N V2"], ["proof (chain)\npicking this:\n  nfa_is_node (quantify_nfa v N) q\n  wf_nfa (quantify_nfa v N) (length w)", "have \"set_of_bv (bdd_lookup (subsetbdd (fst (quantify_nfa v N)) q (nfa_emptybdd (length q))) w) = (\\<Union>i\\<in>set_of_bv q. set_of_bv (bdd_lookup (fst (quantify_nfa v N) ! i) w))\""], ["proof (prove)\nusing this:\n  nfa_is_node (quantify_nfa v N) q\n  wf_nfa (quantify_nfa v N) (length w)\n\ngoal (1 subgoal):\n 1. set_of_bv\n     (bdd_lookup\n       (subsetbdd (fst (quantify_nfa v N)) q (nfa_emptybdd (length q))) w) =\n    (\\<Union>i\\<in>set_of_bv q.\n        set_of_bv (bdd_lookup (fst (quantify_nfa v N) ! i) w))", "by (simp add: subsetbdd_set_of_bv)"], ["proof (state)\nthis:\n  set_of_bv\n   (bdd_lookup\n     (subsetbdd (fst (quantify_nfa v N)) q (nfa_emptybdd (length q))) w) =\n  (\\<Union>i\\<in>set_of_bv q.\n      set_of_bv (bdd_lookup (fst (quantify_nfa v N) ! i) w))\n\ngoal (1 subgoal):\n 1. set_of_bv (nfa_trans (quantify_nfa v N) q w) =\n    (\\<Union>b. set_of_bv (nfa_trans N q (insertl v b w)))", "also"], ["proof (state)\nthis:\n  set_of_bv\n   (bdd_lookup\n     (subsetbdd (fst (quantify_nfa v N)) q (nfa_emptybdd (length q))) w) =\n  (\\<Union>i\\<in>set_of_bv q.\n      set_of_bv (bdd_lookup (fst (quantify_nfa v N) ! i) w))\n\ngoal (1 subgoal):\n 1. set_of_bv (nfa_trans (quantify_nfa v N) q w) =\n    (\\<Union>b. set_of_bv (nfa_trans N q (insertl v b w)))", "from assms"], ["proof (chain)\npicking this:\n  wf_nfa N (Suc n)\n  v \\<le> n\n  is_alph n w\n  nfa_is_node N q", "have \"\\<dots> = (\\<Union>i\\<in>set_of_bv q.  set_of_bv (bdd_lookup (quantify_bdd v (fst N ! i)) w))\""], ["proof (prove)\nusing this:\n  wf_nfa N (Suc n)\n  v \\<le> n\n  is_alph n w\n  nfa_is_node N q\n\ngoal (1 subgoal):\n 1. (\\<Union>i\\<in>set_of_bv q.\n        set_of_bv (bdd_lookup (fst (quantify_nfa v N) ! i) w)) =\n    (\\<Union>i\\<in>set_of_bv q.\n        set_of_bv (bdd_lookup (quantify_bdd v (fst N ! i)) w))", "by (auto simp: quantify_nfa_def split_beta nfa_is_node_def set_of_bv_def)"], ["proof (state)\nthis:\n  (\\<Union>i\\<in>set_of_bv q.\n      set_of_bv (bdd_lookup (fst (quantify_nfa v N) ! i) w)) =\n  (\\<Union>i\\<in>set_of_bv q.\n      set_of_bv (bdd_lookup (quantify_bdd v (fst N ! i)) w))\n\ngoal (1 subgoal):\n 1. set_of_bv (nfa_trans (quantify_nfa v N) q w) =\n    (\\<Union>b. set_of_bv (nfa_trans N q (insertl v b w)))", "also"], ["proof (state)\nthis:\n  (\\<Union>i\\<in>set_of_bv q.\n      set_of_bv (bdd_lookup (fst (quantify_nfa v N) ! i) w)) =\n  (\\<Union>i\\<in>set_of_bv q.\n      set_of_bv (bdd_lookup (quantify_bdd v (fst N ! i)) w))\n\ngoal (1 subgoal):\n 1. set_of_bv (nfa_trans (quantify_nfa v N) q w) =\n    (\\<Union>b. set_of_bv (nfa_trans N q (insertl v b w)))", "have \"\\<dots> = (\\<Union>i\\<in>set_of_bv q. \\<Union>b. set_of_bv (bdd_lookup (fst N ! i) (insertl v b w)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>i\\<in>set_of_bv q.\n        set_of_bv (bdd_lookup (quantify_bdd v (fst N ! i)) w)) =\n    (\\<Union>i\\<in>set_of_bv q.\n        \\<Union>b. set_of_bv (bdd_lookup (fst N ! i) (insertl v b w)))", "proof (simp only: set_eq_iff, rule allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                    set_of_bv\n                     (bdd_lookup (quantify_bdd v (fst N ! i)) w))) =\n       (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                    \\<Union>b.\n                       set_of_bv (bdd_lookup (fst N ! i) (insertl v b w))))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                    set_of_bv\n                     (bdd_lookup (quantify_bdd v (fst N ! i)) w))) =\n       (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                    \\<Union>b.\n                       set_of_bv (bdd_lookup (fst N ! i) (insertl v b w))))", "have \"x \\<in> (\\<Union>i\\<in>set_of_bv q. set_of_bv (bdd_lookup (quantify_bdd v (fst N ! i)) w)) = (\\<exists>i\\<in>set_of_bv q. x \\<in> set_of_bv (bdd_lookup (quantify_bdd v (fst N ! i)) w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                 set_of_bv (bdd_lookup (quantify_bdd v (fst N ! i)) w))) =\n    (\\<exists>i\\<in>set_of_bv q.\n        x \\<in> set_of_bv (bdd_lookup (quantify_bdd v (fst N ! i)) w))", "by simp"], ["proof (state)\nthis:\n  (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n               set_of_bv (bdd_lookup (quantify_bdd v (fst N ! i)) w))) =\n  (\\<exists>i\\<in>set_of_bv q.\n      x \\<in> set_of_bv (bdd_lookup (quantify_bdd v (fst N ! i)) w))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                    set_of_bv\n                     (bdd_lookup (quantify_bdd v (fst N ! i)) w))) =\n       (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                    \\<Union>b.\n                       set_of_bv (bdd_lookup (fst N ! i) (insertl v b w))))", "also"], ["proof (state)\nthis:\n  (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n               set_of_bv (bdd_lookup (quantify_bdd v (fst N ! i)) w))) =\n  (\\<exists>i\\<in>set_of_bv q.\n      x \\<in> set_of_bv (bdd_lookup (quantify_bdd v (fst N ! i)) w))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                    set_of_bv\n                     (bdd_lookup (quantify_bdd v (fst N ! i)) w))) =\n       (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                    \\<Union>b.\n                       set_of_bv (bdd_lookup (fst N ! i) (insertl v b w))))", "have \"\\<dots> = ({i. i \\<in> set_of_bv q \\<and> x \\<in> set_of_bv (bdd_lookup (quantify_bdd v (fst N ! i)) w)} \\<noteq> {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>i\\<in>set_of_bv q.\n        x \\<in> set_of_bv (bdd_lookup (quantify_bdd v (fst N ! i)) w)) =\n    ({i \\<in> set_of_bv q.\n      x \\<in> set_of_bv\n               (bdd_lookup (quantify_bdd v (fst N ! i)) w)} \\<noteq>\n     {})", "by auto"], ["proof (state)\nthis:\n  (\\<exists>i\\<in>set_of_bv q.\n      x \\<in> set_of_bv (bdd_lookup (quantify_bdd v (fst N ! i)) w)) =\n  ({i \\<in> set_of_bv q.\n    x \\<in> set_of_bv (bdd_lookup (quantify_bdd v (fst N ! i)) w)} \\<noteq>\n   {})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                    set_of_bv\n                     (bdd_lookup (quantify_bdd v (fst N ! i)) w))) =\n       (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                    \\<Union>b.\n                       set_of_bv (bdd_lookup (fst N ! i) (insertl v b w))))", "also"], ["proof (state)\nthis:\n  (\\<exists>i\\<in>set_of_bv q.\n      x \\<in> set_of_bv (bdd_lookup (quantify_bdd v (fst N ! i)) w)) =\n  ({i \\<in> set_of_bv q.\n    x \\<in> set_of_bv (bdd_lookup (quantify_bdd v (fst N ! i)) w)} \\<noteq>\n   {})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                    set_of_bv\n                     (bdd_lookup (quantify_bdd v (fst N ! i)) w))) =\n       (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                    \\<Union>b.\n                       set_of_bv (bdd_lookup (fst N ! i) (insertl v b w))))", "from I"], ["proof (chain)\npicking this:\n  ?i \\<in> set_of_bv q \\<Longrightarrow>\n  length w = n \\<and>\n  bddh (Suc n) (fst N ! ?i) \\<and>\n  bdd_all (nfa_is_node N) (fst N ! ?i) \\<and> v \\<le> n", "have \"\\<dots> = ({i. i \\<in> set_of_bv q \\<and> x \\<in> (\\<Union>b. set_of_bv (bdd_lookup (fst N ! i) (insertl v b w)))} \\<noteq> {})\""], ["proof (prove)\nusing this:\n  ?i \\<in> set_of_bv q \\<Longrightarrow>\n  length w = n \\<and>\n  bddh (Suc n) (fst N ! ?i) \\<and>\n  bdd_all (nfa_is_node N) (fst N ! ?i) \\<and> v \\<le> n\n\ngoal (1 subgoal):\n 1. ({i \\<in> set_of_bv q.\n      x \\<in> set_of_bv\n               (bdd_lookup (quantify_bdd v (fst N ! i)) w)} \\<noteq>\n     {}) =\n    ({i \\<in> set_of_bv q.\n      x \\<in> (\\<Union>b.\n                  set_of_bv\n                   (bdd_lookup (fst N ! i) (insertl v b w)))} \\<noteq>\n     {})", "by (auto simp: bdd_lookup_quantify_bdd_set_of_bv[of w n _ N])"], ["proof (state)\nthis:\n  ({i \\<in> set_of_bv q.\n    x \\<in> set_of_bv (bdd_lookup (quantify_bdd v (fst N ! i)) w)} \\<noteq>\n   {}) =\n  ({i \\<in> set_of_bv q.\n    x \\<in> (\\<Union>b.\n                set_of_bv\n                 (bdd_lookup (fst N ! i) (insertl v b w)))} \\<noteq>\n   {})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                    set_of_bv\n                     (bdd_lookup (quantify_bdd v (fst N ! i)) w))) =\n       (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                    \\<Union>b.\n                       set_of_bv (bdd_lookup (fst N ! i) (insertl v b w))))", "also"], ["proof (state)\nthis:\n  ({i \\<in> set_of_bv q.\n    x \\<in> set_of_bv (bdd_lookup (quantify_bdd v (fst N ! i)) w)} \\<noteq>\n   {}) =\n  ({i \\<in> set_of_bv q.\n    x \\<in> (\\<Union>b.\n                set_of_bv\n                 (bdd_lookup (fst N ! i) (insertl v b w)))} \\<noteq>\n   {})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                    set_of_bv\n                     (bdd_lookup (quantify_bdd v (fst N ! i)) w))) =\n       (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                    \\<Union>b.\n                       set_of_bv (bdd_lookup (fst N ! i) (insertl v b w))))", "have \"\\<dots> = (\\<exists>i\\<in>set_of_bv q. x \\<in> (\\<Union>b. set_of_bv (bdd_lookup (fst N ! i) (insertl v b w))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({i \\<in> set_of_bv q.\n      x \\<in> (\\<Union>b.\n                  set_of_bv\n                   (bdd_lookup (fst N ! i) (insertl v b w)))} \\<noteq>\n     {}) =\n    (\\<exists>i\\<in>set_of_bv q.\n        x \\<in> (\\<Union>b.\n                    set_of_bv (bdd_lookup (fst N ! i) (insertl v b w))))", "by auto"], ["proof (state)\nthis:\n  ({i \\<in> set_of_bv q.\n    x \\<in> (\\<Union>b.\n                set_of_bv\n                 (bdd_lookup (fst N ! i) (insertl v b w)))} \\<noteq>\n   {}) =\n  (\\<exists>i\\<in>set_of_bv q.\n      x \\<in> (\\<Union>b.\n                  set_of_bv (bdd_lookup (fst N ! i) (insertl v b w))))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                    set_of_bv\n                     (bdd_lookup (quantify_bdd v (fst N ! i)) w))) =\n       (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                    \\<Union>b.\n                       set_of_bv (bdd_lookup (fst N ! i) (insertl v b w))))", "also"], ["proof (state)\nthis:\n  ({i \\<in> set_of_bv q.\n    x \\<in> (\\<Union>b.\n                set_of_bv\n                 (bdd_lookup (fst N ! i) (insertl v b w)))} \\<noteq>\n   {}) =\n  (\\<exists>i\\<in>set_of_bv q.\n      x \\<in> (\\<Union>b.\n                  set_of_bv (bdd_lookup (fst N ! i) (insertl v b w))))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                    set_of_bv\n                     (bdd_lookup (quantify_bdd v (fst N ! i)) w))) =\n       (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                    \\<Union>b.\n                       set_of_bv (bdd_lookup (fst N ! i) (insertl v b w))))", "have \"\\<dots> = (x \\<in> (\\<Union>i\\<in>set_of_bv q. \\<Union>b. set_of_bv (bdd_lookup (fst N ! i) (insertl v b w))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>i\\<in>set_of_bv q.\n        x \\<in> (\\<Union>b.\n                    set_of_bv (bdd_lookup (fst N ! i) (insertl v b w)))) =\n    (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                 \\<Union>b.\n                    set_of_bv (bdd_lookup (fst N ! i) (insertl v b w))))", "by simp"], ["proof (state)\nthis:\n  (\\<exists>i\\<in>set_of_bv q.\n      x \\<in> (\\<Union>b.\n                  set_of_bv (bdd_lookup (fst N ! i) (insertl v b w)))) =\n  (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n               \\<Union>b.\n                  set_of_bv (bdd_lookup (fst N ! i) (insertl v b w))))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                    set_of_bv\n                     (bdd_lookup (quantify_bdd v (fst N ! i)) w))) =\n       (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                    \\<Union>b.\n                       set_of_bv (bdd_lookup (fst N ! i) (insertl v b w))))", "finally"], ["proof (chain)\npicking this:\n  (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n               set_of_bv (bdd_lookup (quantify_bdd v (fst N ! i)) w))) =\n  (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n               \\<Union>b.\n                  set_of_bv (bdd_lookup (fst N ! i) (insertl v b w))))", "show \"(x \\<in> (\\<Union>i\\<in>set_of_bv q. set_of_bv (bdd_lookup (quantify_bdd v (fst N ! i)) w))) = (x \\<in> (\\<Union>i \\<in> set_of_bv q. \\<Union>b. set_of_bv (bdd_lookup (fst N ! i) (insertl v b w))))\""], ["proof (prove)\nusing this:\n  (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n               set_of_bv (bdd_lookup (quantify_bdd v (fst N ! i)) w))) =\n  (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n               \\<Union>b.\n                  set_of_bv (bdd_lookup (fst N ! i) (insertl v b w))))\n\ngoal (1 subgoal):\n 1. (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                 set_of_bv (bdd_lookup (quantify_bdd v (fst N ! i)) w))) =\n    (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n                 \\<Union>b.\n                    set_of_bv (bdd_lookup (fst N ! i) (insertl v b w))))", "."], ["proof (state)\nthis:\n  (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n               set_of_bv (bdd_lookup (quantify_bdd v (fst N ! i)) w))) =\n  (x \\<in> (\\<Union>i\\<in>set_of_bv q.\n               \\<Union>b.\n                  set_of_bv (bdd_lookup (fst N ! i) (insertl v b w))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Union>i\\<in>set_of_bv q.\n      set_of_bv (bdd_lookup (quantify_bdd v (fst N ! i)) w)) =\n  (\\<Union>i\\<in>set_of_bv q.\n      \\<Union>b. set_of_bv (bdd_lookup (fst N ! i) (insertl v b w)))\n\ngoal (1 subgoal):\n 1. set_of_bv (nfa_trans (quantify_nfa v N) q w) =\n    (\\<Union>b. set_of_bv (nfa_trans N q (insertl v b w)))", "also"], ["proof (state)\nthis:\n  (\\<Union>i\\<in>set_of_bv q.\n      set_of_bv (bdd_lookup (quantify_bdd v (fst N ! i)) w)) =\n  (\\<Union>i\\<in>set_of_bv q.\n      \\<Union>b. set_of_bv (bdd_lookup (fst N ! i) (insertl v b w)))\n\ngoal (1 subgoal):\n 1. set_of_bv (nfa_trans (quantify_nfa v N) q w) =\n    (\\<Union>b. set_of_bv (nfa_trans N q (insertl v b w)))", "have \"\\<dots> = (\\<Union>b. \\<Union>i\\<in>set_of_bv q. set_of_bv (bdd_lookup (fst N ! i) (insertl v b w)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>i\\<in>set_of_bv q.\n        \\<Union>b. set_of_bv (bdd_lookup (fst N ! i) (insertl v b w))) =\n    (\\<Union>b.\n        \\<Union>i\\<in>set_of_bv q.\n           set_of_bv (bdd_lookup (fst N ! i) (insertl v b w)))", "by auto"], ["proof (state)\nthis:\n  (\\<Union>i\\<in>set_of_bv q.\n      \\<Union>b. set_of_bv (bdd_lookup (fst N ! i) (insertl v b w))) =\n  (\\<Union>b.\n      \\<Union>i\\<in>set_of_bv q.\n         set_of_bv (bdd_lookup (fst N ! i) (insertl v b w)))\n\ngoal (1 subgoal):\n 1. set_of_bv (nfa_trans (quantify_nfa v N) q w) =\n    (\\<Union>b. set_of_bv (nfa_trans N q (insertl v b w)))", "also"], ["proof (state)\nthis:\n  (\\<Union>i\\<in>set_of_bv q.\n      \\<Union>b. set_of_bv (bdd_lookup (fst N ! i) (insertl v b w))) =\n  (\\<Union>b.\n      \\<Union>i\\<in>set_of_bv q.\n         set_of_bv (bdd_lookup (fst N ! i) (insertl v b w)))\n\ngoal (1 subgoal):\n 1. set_of_bv (nfa_trans (quantify_nfa v N) q w) =\n    (\\<Union>b. set_of_bv (nfa_trans N q (insertl v b w)))", "from V3 assms"], ["proof (chain)\npicking this:\n  wf_nfa N (length (insertl v ?b w))\n  wf_nfa N (Suc n)\n  v \\<le> n\n  is_alph n w\n  nfa_is_node N q", "have \"\\<dots> = (\\<Union>b. set_of_bv (bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q))) (insertl v b w)))\""], ["proof (prove)\nusing this:\n  wf_nfa N (length (insertl v ?b w))\n  wf_nfa N (Suc n)\n  v \\<le> n\n  is_alph n w\n  nfa_is_node N q\n\ngoal (1 subgoal):\n 1. (\\<Union>b.\n        \\<Union>i\\<in>set_of_bv q.\n           set_of_bv (bdd_lookup (fst N ! i) (insertl v b w))) =\n    (\\<Union>b.\n        set_of_bv\n         (bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q)))\n           (insertl v b w)))", "by (simp add: subsetbdd_set_of_bv)"], ["proof (state)\nthis:\n  (\\<Union>b.\n      \\<Union>i\\<in>set_of_bv q.\n         set_of_bv (bdd_lookup (fst N ! i) (insertl v b w))) =\n  (\\<Union>b.\n      set_of_bv\n       (bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q)))\n         (insertl v b w)))\n\ngoal (1 subgoal):\n 1. set_of_bv (nfa_trans (quantify_nfa v N) q w) =\n    (\\<Union>b. set_of_bv (nfa_trans N q (insertl v b w)))", "finally"], ["proof (chain)\npicking this:\n  set_of_bv\n   (bdd_lookup\n     (subsetbdd (fst (quantify_nfa v N)) q (nfa_emptybdd (length q))) w) =\n  (\\<Union>b.\n      set_of_bv\n       (bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q)))\n         (insertl v b w)))", "show ?thesis"], ["proof (prove)\nusing this:\n  set_of_bv\n   (bdd_lookup\n     (subsetbdd (fst (quantify_nfa v N)) q (nfa_emptybdd (length q))) w) =\n  (\\<Union>b.\n      set_of_bv\n       (bdd_lookup (subsetbdd (fst N) q (nfa_emptybdd (length q)))\n         (insertl v b w)))\n\ngoal (1 subgoal):\n 1. set_of_bv (nfa_trans (quantify_nfa v N) q w) =\n    (\\<Union>b. set_of_bv (nfa_trans N q (insertl v b w)))", "by (simp add: nfa_trans_def)"], ["proof (state)\nthis:\n  set_of_bv (nfa_trans (quantify_nfa v N) q w) =\n  (\\<Union>b. set_of_bv (nfa_trans N q (insertl v b w)))\n\ngoal:\nNo subgoals!", "qed"], ["", "fun insertll :: \"nat \\<Rightarrow> 'a list \\<Rightarrow> 'a list list \\<Rightarrow> 'a list list\"\nwhere\n  \"insertll i [] [] = []\"\n| \"insertll i (a # as) (bs # bss) = insertl i a bs # insertll i as bss\""], ["", "lemma insertll_len2:\n  assumes \"list_all (is_alph n) vs\"\n  and \"length x = length vs\"\n  shows \"list_all (is_alph (Suc n)) (insertll k x vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (is_alph (Suc n)) (insertll k x vs)", "using assms"], ["proof (prove)\nusing this:\n  list_all (is_alph n) vs\n  length x = length vs\n\ngoal (1 subgoal):\n 1. list_all (is_alph (Suc n)) (insertll k x vs)", "by (induct k x vs rule: insertll.induct) (auto simp: insertl_len is_alph_def)+"], ["", "lemma insertll_append:\n  assumes \"length xs = length vs\"\n  shows \"insertll k (xs @ [x]) (vs @ [v]) = insertll k xs vs @ [insertl k x v]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertll k (xs @ [x]) (vs @ [v]) = insertll k xs vs @ [insertl k x v]", "using assms"], ["proof (prove)\nusing this:\n  length xs = length vs\n\ngoal (1 subgoal):\n 1. insertll k (xs @ [x]) (vs @ [v]) = insertll k xs vs @ [insertl k x v]", "by (induct k xs vs rule: insertll.induct) simp+"], ["", "lemma UN_UN_lenset: \"(\\<Union>b. \\<Union>x\\<in>{x. length x = n}. M b x) = (\\<Union>bs\\<in>{x. length x = Suc n}. M (last bs) (butlast bs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>b. \\<Union> (M b ` {x. length x = n})) =\n    (\\<Union>bs\\<in>{x. length x = Suc n}. M (last bs) (butlast bs))", "proof auto"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       \\<lbrakk>x \\<in> M xa xb; n = length xb\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            length xa = Suc (length xb) \\<and>\n                            x \\<in> M (last xa) (butlast xa)\n 2. \\<And>x bs.\n       \\<lbrakk>x \\<in> M (last bs) (butlast bs); length bs = Suc n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa xb.\n                            length xb = n \\<and> x \\<in> M xa xb", "fix x b xa"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       \\<lbrakk>x \\<in> M xa xb; n = length xb\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            length xa = Suc (length xb) \\<and>\n                            x \\<in> M (last xa) (butlast xa)\n 2. \\<And>x bs.\n       \\<lbrakk>x \\<in> M (last bs) (butlast bs); length bs = Suc n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa xb.\n                            length xb = n \\<and> x \\<in> M xa xb", "assume \"x \\<in> M b xa\""], ["proof (state)\nthis:\n  x \\<in> M b xa\n\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       \\<lbrakk>x \\<in> M xa xb; n = length xb\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            length xa = Suc (length xb) \\<and>\n                            x \\<in> M (last xa) (butlast xa)\n 2. \\<And>x bs.\n       \\<lbrakk>x \\<in> M (last bs) (butlast bs); length bs = Suc n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa xb.\n                            length xb = n \\<and> x \\<in> M xa xb", "hence \"length (xa @ [b]) = Suc (length xa) \\<and> x \\<in> M (last (xa @ [b])) (butlast (xa @ [b]))\""], ["proof (prove)\nusing this:\n  x \\<in> M b xa\n\ngoal (1 subgoal):\n 1. length (xa @ [b]) = Suc (length xa) \\<and>\n    x \\<in> M (last (xa @ [b])) (butlast (xa @ [b]))", "by simp"], ["proof (state)\nthis:\n  length (xa @ [b]) = Suc (length xa) \\<and>\n  x \\<in> M (last (xa @ [b])) (butlast (xa @ [b]))\n\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       \\<lbrakk>x \\<in> M xa xb; n = length xb\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            length xa = Suc (length xb) \\<and>\n                            x \\<in> M (last xa) (butlast xa)\n 2. \\<And>x bs.\n       \\<lbrakk>x \\<in> M (last bs) (butlast bs); length bs = Suc n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa xb.\n                            length xb = n \\<and> x \\<in> M xa xb", "thus \"\\<exists>bs. length bs = Suc (length xa) \\<and> x \\<in> M (last bs) (butlast bs)\""], ["proof (prove)\nusing this:\n  length (xa @ [b]) = Suc (length xa) \\<and>\n  x \\<in> M (last (xa @ [b])) (butlast (xa @ [b]))\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       length bs = Suc (length xa) \\<and> x \\<in> M (last bs) (butlast bs)", ".."], ["proof (state)\nthis:\n  \\<exists>bs.\n     length bs = Suc (length xa) \\<and> x \\<in> M (last bs) (butlast bs)\n\ngoal (1 subgoal):\n 1. \\<And>x bs.\n       \\<lbrakk>x \\<in> M (last bs) (butlast bs); length bs = Suc n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa xb.\n                            length xb = n \\<and> x \\<in> M xa xb", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x bs.\n       \\<lbrakk>x \\<in> M (last bs) (butlast bs); length bs = Suc n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa xb.\n                            length xb = n \\<and> x \\<in> M xa xb", "fix x bs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x bs.\n       \\<lbrakk>x \\<in> M (last bs) (butlast bs); length bs = Suc n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa xb.\n                            length xb = n \\<and> x \\<in> M xa xb", "assume \"x \\<in> M (last bs) (butlast bs)\" and \"length bs = Suc n\""], ["proof (state)\nthis:\n  x \\<in> M (last bs) (butlast bs)\n  length bs = Suc n\n\ngoal (1 subgoal):\n 1. \\<And>x bs.\n       \\<lbrakk>x \\<in> M (last bs) (butlast bs); length bs = Suc n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa xb.\n                            length xb = n \\<and> x \\<in> M xa xb", "hence \"length (butlast bs) = n \\<and> x \\<in> M (last bs) (butlast bs)\""], ["proof (prove)\nusing this:\n  x \\<in> M (last bs) (butlast bs)\n  length bs = Suc n\n\ngoal (1 subgoal):\n 1. length (butlast bs) = n \\<and> x \\<in> M (last bs) (butlast bs)", "by simp"], ["proof (state)\nthis:\n  length (butlast bs) = n \\<and> x \\<in> M (last bs) (butlast bs)\n\ngoal (1 subgoal):\n 1. \\<And>x bs.\n       \\<lbrakk>x \\<in> M (last bs) (butlast bs); length bs = Suc n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa xb.\n                            length xb = n \\<and> x \\<in> M xa xb", "thus \"\\<exists>b xa. length xa = n \\<and> x \\<in> M b xa\""], ["proof (prove)\nusing this:\n  length (butlast bs) = n \\<and> x \\<in> M (last bs) (butlast bs)\n\ngoal (1 subgoal):\n 1. \\<exists>b xa. length xa = n \\<and> x \\<in> M b xa", "by blast"], ["proof (state)\nthis:\n  \\<exists>b xa. length xa = n \\<and> x \\<in> M b xa\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nfa_steps_quantify_nfa:\n  assumes \"wf_nfa N (Suc n)\"\n  and \"list_all (is_alph n) w\"\n  and \"nfa_is_node N q\"\n  and \"v \\<le> n\"\n  shows \"set_of_bv (nfa_steps (quantify_nfa v N) q w) = (\\<Union>xs \\<in> {x. length x = length w}. set_of_bv (nfa_steps N q (insertll v xs w)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_of_bv (nfa_steps (quantify_nfa v N) q w) =\n    (\\<Union>xs\\<in>{x. length x = length w}.\n        set_of_bv (nfa_steps N q (insertll v xs w)))", "using assms"], ["proof (prove)\nusing this:\n  wf_nfa N (Suc n)\n  list_all (is_alph n) w\n  nfa_is_node N q\n  v \\<le> n\n\ngoal (1 subgoal):\n 1. set_of_bv (nfa_steps (quantify_nfa v N) q w) =\n    (\\<Union>xs\\<in>{x. length x = length w}.\n        set_of_bv (nfa_steps N q (insertll v xs w)))", "proof (induct w rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) []; nfa_is_node N q;\n     v \\<le> n\\<rbrakk>\n    \\<Longrightarrow> set_of_bv (nfa_steps (quantify_nfa v N) q []) =\n                      (\\<Union>xs\\<in>{x. length x = length []}.\n                          set_of_bv (nfa_steps N q (insertll v xs [])))\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "case Nil"], ["proof (state)\nthis:\n  wf_nfa N (Suc n)\n  list_all (is_alph n) []\n  nfa_is_node N q\n  v \\<le> n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) []; nfa_is_node N q;\n     v \\<le> n\\<rbrakk>\n    \\<Longrightarrow> set_of_bv (nfa_steps (quantify_nfa v N) q []) =\n                      (\\<Union>xs\\<in>{x. length x = length []}.\n                          set_of_bv (nfa_steps N q (insertll v xs [])))\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "thus ?case"], ["proof (prove)\nusing this:\n  wf_nfa N (Suc n)\n  list_all (is_alph n) []\n  nfa_is_node N q\n  v \\<le> n\n\ngoal (1 subgoal):\n 1. set_of_bv (nfa_steps (quantify_nfa v N) q []) =\n    (\\<Union>xs\\<in>{x. length x = length []}.\n        set_of_bv (nfa_steps N q (insertll v xs [])))", "by simp"], ["proof (state)\nthis:\n  set_of_bv (nfa_steps (quantify_nfa v N) q []) =\n  (\\<Union>xs\\<in>{x. length x = length []}.\n      set_of_bv (nfa_steps N q (insertll v xs [])))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "case (snoc x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs; nfa_is_node N q;\n   v \\<le> n\\<rbrakk>\n  \\<Longrightarrow> set_of_bv (nfa_steps (quantify_nfa v N) q xs) =\n                    (\\<Union>xsa\\<in>{x. length x = length xs}.\n                        set_of_bv (nfa_steps N q (insertll v xsa xs)))\n  wf_nfa N (Suc n)\n  list_all (is_alph n) (xs @ [x])\n  nfa_is_node N q\n  v \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "hence \"wf_nfa (quantify_nfa v N) n\""], ["proof (prove)\nusing this:\n  \\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs; nfa_is_node N q;\n   v \\<le> n\\<rbrakk>\n  \\<Longrightarrow> set_of_bv (nfa_steps (quantify_nfa v N) q xs) =\n                    (\\<Union>xsa\\<in>{x. length x = length xs}.\n                        set_of_bv (nfa_steps N q (insertll v xsa xs)))\n  wf_nfa N (Suc n)\n  list_all (is_alph n) (xs @ [x])\n  nfa_is_node N q\n  v \\<le> n\n\ngoal (1 subgoal):\n 1. wf_nfa (quantify_nfa v N) n", "by (simp add: quantify_nfa_well_formed_aut)"], ["proof (state)\nthis:\n  wf_nfa (quantify_nfa v N) n\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "moreover"], ["proof (state)\nthis:\n  wf_nfa (quantify_nfa v N) n\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "from snoc"], ["proof (chain)\npicking this:\n  \\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs; nfa_is_node N q;\n   v \\<le> n\\<rbrakk>\n  \\<Longrightarrow> set_of_bv (nfa_steps (quantify_nfa v N) q xs) =\n                    (\\<Union>xsa\\<in>{x. length x = length xs}.\n                        set_of_bv (nfa_steps N q (insertll v xsa xs)))\n  wf_nfa N (Suc n)\n  list_all (is_alph n) (xs @ [x])\n  nfa_is_node N q\n  v \\<le> n", "have \"nfa_is_node (quantify_nfa v N) q\""], ["proof (prove)\nusing this:\n  \\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs; nfa_is_node N q;\n   v \\<le> n\\<rbrakk>\n  \\<Longrightarrow> set_of_bv (nfa_steps (quantify_nfa v N) q xs) =\n                    (\\<Union>xsa\\<in>{x. length x = length xs}.\n                        set_of_bv (nfa_steps N q (insertll v xsa xs)))\n  wf_nfa N (Suc n)\n  list_all (is_alph n) (xs @ [x])\n  nfa_is_node N q\n  v \\<le> n\n\ngoal (1 subgoal):\n 1. nfa_is_node (quantify_nfa v N) q", "by (simp add: nfa_is_node_def quantify_nfa_def split_beta)"], ["proof (state)\nthis:\n  nfa_is_node (quantify_nfa v N) q\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "moreover"], ["proof (state)\nthis:\n  nfa_is_node (quantify_nfa v N) q\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "note snoc"], ["proof (state)\nthis:\n  \\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs; nfa_is_node N q;\n   v \\<le> n\\<rbrakk>\n  \\<Longrightarrow> set_of_bv (nfa_steps (quantify_nfa v N) q xs) =\n                    (\\<Union>xsa\\<in>{x. length x = length xs}.\n                        set_of_bv (nfa_steps N q (insertll v xsa xs)))\n  wf_nfa N (Suc n)\n  list_all (is_alph n) (xs @ [x])\n  nfa_is_node N q\n  v \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "ultimately"], ["proof (chain)\npicking this:\n  wf_nfa (quantify_nfa v N) n\n  nfa_is_node (quantify_nfa v N) q\n  \\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs; nfa_is_node N q;\n   v \\<le> n\\<rbrakk>\n  \\<Longrightarrow> set_of_bv (nfa_steps (quantify_nfa v N) q xs) =\n                    (\\<Union>xsa\\<in>{x. length x = length xs}.\n                        set_of_bv (nfa_steps N q (insertll v xsa xs)))\n  wf_nfa N (Suc n)\n  list_all (is_alph n) (xs @ [x])\n  nfa_is_node N q\n  v \\<le> n", "have \"nfa_is_node (quantify_nfa v N) (nfa_steps (quantify_nfa v N) q xs)\""], ["proof (prove)\nusing this:\n  wf_nfa (quantify_nfa v N) n\n  nfa_is_node (quantify_nfa v N) q\n  \\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs; nfa_is_node N q;\n   v \\<le> n\\<rbrakk>\n  \\<Longrightarrow> set_of_bv (nfa_steps (quantify_nfa v N) q xs) =\n                    (\\<Union>xsa\\<in>{x. length x = length xs}.\n                        set_of_bv (nfa_steps N q (insertll v xsa xs)))\n  wf_nfa N (Suc n)\n  list_all (is_alph n) (xs @ [x])\n  nfa_is_node N q\n  v \\<le> n\n\ngoal (1 subgoal):\n 1. nfa_is_node (quantify_nfa v N) (nfa_steps (quantify_nfa v N) q xs)", "by (simp add: nfa_steps_is_node[of _ n])"], ["proof (state)\nthis:\n  nfa_is_node (quantify_nfa v N) (nfa_steps (quantify_nfa v N) q xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "hence N: \"nfa_is_node N (nfa_steps (quantify_nfa v N) q xs)\" (is \"nfa_is_node N ?q\")"], ["proof (prove)\nusing this:\n  nfa_is_node (quantify_nfa v N) (nfa_steps (quantify_nfa v N) q xs)\n\ngoal (1 subgoal):\n 1. nfa_is_node N (nfa_steps (quantify_nfa v N) q xs)", "by (simp add: nfa_is_node_def quantify_nfa_def split_beta)"], ["proof (state)\nthis:\n  nfa_is_node N (nfa_steps (quantify_nfa v N) q xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "from snoc"], ["proof (chain)\npicking this:\n  \\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs; nfa_is_node N q;\n   v \\<le> n\\<rbrakk>\n  \\<Longrightarrow> set_of_bv (nfa_steps (quantify_nfa v N) q xs) =\n                    (\\<Union>xsa\\<in>{x. length x = length xs}.\n                        set_of_bv (nfa_steps N q (insertll v xsa xs)))\n  wf_nfa N (Suc n)\n  list_all (is_alph n) (xs @ [x])\n  nfa_is_node N q\n  v \\<le> n", "have \"\\<And>b. length (insertl v b x) = Suc n\""], ["proof (prove)\nusing this:\n  \\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs; nfa_is_node N q;\n   v \\<le> n\\<rbrakk>\n  \\<Longrightarrow> set_of_bv (nfa_steps (quantify_nfa v N) q xs) =\n                    (\\<Union>xsa\\<in>{x. length x = length xs}.\n                        set_of_bv (nfa_steps N q (insertll v xsa xs)))\n  wf_nfa N (Suc n)\n  list_all (is_alph n) (xs @ [x])\n  nfa_is_node N q\n  v \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>b. length (insertl v b x) = Suc n", "by (simp add: insertl_len is_alph_def)"], ["proof (state)\nthis:\n  length (insertl v ?b x) = Suc n\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "with snoc"], ["proof (chain)\npicking this:\n  \\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs; nfa_is_node N q;\n   v \\<le> n\\<rbrakk>\n  \\<Longrightarrow> set_of_bv (nfa_steps (quantify_nfa v N) q xs) =\n                    (\\<Union>xsa\\<in>{x. length x = length xs}.\n                        set_of_bv (nfa_steps N q (insertll v xsa xs)))\n  wf_nfa N (Suc n)\n  list_all (is_alph n) (xs @ [x])\n  nfa_is_node N q\n  v \\<le> n\n  length (insertl v ?b x) = Suc n", "have B: \"\\<And>b. wf_nfa N (length (insertl v b x))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs; nfa_is_node N q;\n   v \\<le> n\\<rbrakk>\n  \\<Longrightarrow> set_of_bv (nfa_steps (quantify_nfa v N) q xs) =\n                    (\\<Union>xsa\\<in>{x. length x = length xs}.\n                        set_of_bv (nfa_steps N q (insertll v xsa xs)))\n  wf_nfa N (Suc n)\n  list_all (is_alph n) (xs @ [x])\n  nfa_is_node N q\n  v \\<le> n\n  length (insertl v ?b x) = Suc n\n\ngoal (1 subgoal):\n 1. \\<And>b. wf_nfa N (length (insertl v b x))", "by simp"], ["proof (state)\nthis:\n  wf_nfa N (length (insertl v ?b x))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "from snoc"], ["proof (chain)\npicking this:\n  \\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs; nfa_is_node N q;\n   v \\<le> n\\<rbrakk>\n  \\<Longrightarrow> set_of_bv (nfa_steps (quantify_nfa v N) q xs) =\n                    (\\<Union>xsa\\<in>{x. length x = length xs}.\n                        set_of_bv (nfa_steps N q (insertll v xsa xs)))\n  wf_nfa N (Suc n)\n  list_all (is_alph n) (xs @ [x])\n  nfa_is_node N q\n  v \\<le> n", "have IV: \"set_of_bv (nfa_steps (quantify_nfa v N) q xs) = (\\<Union>x \\<in>{x. length x = length xs}. set_of_bv (nfa_steps N q (insertll v x xs)))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs; nfa_is_node N q;\n   v \\<le> n\\<rbrakk>\n  \\<Longrightarrow> set_of_bv (nfa_steps (quantify_nfa v N) q xs) =\n                    (\\<Union>xsa\\<in>{x. length x = length xs}.\n                        set_of_bv (nfa_steps N q (insertll v xsa xs)))\n  wf_nfa N (Suc n)\n  list_all (is_alph n) (xs @ [x])\n  nfa_is_node N q\n  v \\<le> n\n\ngoal (1 subgoal):\n 1. set_of_bv (nfa_steps (quantify_nfa v N) q xs) =\n    (\\<Union>x\\<in>{x. length x = length xs}.\n        set_of_bv (nfa_steps N q (insertll v x xs)))", "by simp"], ["proof (state)\nthis:\n  set_of_bv (nfa_steps (quantify_nfa v N) q xs) =\n  (\\<Union>x\\<in>{x. length x = length xs}.\n      set_of_bv (nfa_steps N q (insertll v x xs)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "{"], ["proof (state)\nthis:\n  set_of_bv (nfa_steps (quantify_nfa v N) q xs) =\n  (\\<Union>x\\<in>{x. length x = length xs}.\n      set_of_bv (nfa_steps N q (insertll v x xs)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "fix bs :: \"bool list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "assume H: \"length bs = length xs\""], ["proof (state)\nthis:\n  length bs = length xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "with snoc"], ["proof (chain)\npicking this:\n  \\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs; nfa_is_node N q;\n   v \\<le> n\\<rbrakk>\n  \\<Longrightarrow> set_of_bv (nfa_steps (quantify_nfa v N) q xs) =\n                    (\\<Union>xsa\\<in>{x. length x = length xs}.\n                        set_of_bv (nfa_steps N q (insertll v xsa xs)))\n  wf_nfa N (Suc n)\n  list_all (is_alph n) (xs @ [x])\n  nfa_is_node N q\n  v \\<le> n\n  length bs = length xs", "have \"list_all (is_alph (Suc n)) (insertll v bs xs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs; nfa_is_node N q;\n   v \\<le> n\\<rbrakk>\n  \\<Longrightarrow> set_of_bv (nfa_steps (quantify_nfa v N) q xs) =\n                    (\\<Union>xsa\\<in>{x. length x = length xs}.\n                        set_of_bv (nfa_steps N q (insertll v xsa xs)))\n  wf_nfa N (Suc n)\n  list_all (is_alph n) (xs @ [x])\n  nfa_is_node N q\n  v \\<le> n\n  length bs = length xs\n\ngoal (1 subgoal):\n 1. list_all (is_alph (Suc n)) (insertll v bs xs)", "by (simp add: insertll_len2)"], ["proof (state)\nthis:\n  list_all (is_alph (Suc n)) (insertll v bs xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "with snoc"], ["proof (chain)\npicking this:\n  \\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs; nfa_is_node N q;\n   v \\<le> n\\<rbrakk>\n  \\<Longrightarrow> set_of_bv (nfa_steps (quantify_nfa v N) q xs) =\n                    (\\<Union>xsa\\<in>{x. length x = length xs}.\n                        set_of_bv (nfa_steps N q (insertll v xsa xs)))\n  wf_nfa N (Suc n)\n  list_all (is_alph n) (xs @ [x])\n  nfa_is_node N q\n  v \\<le> n\n  list_all (is_alph (Suc n)) (insertll v bs xs)", "have \"nfa_is_node N (nfa_steps N q (insertll v bs xs))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs; nfa_is_node N q;\n   v \\<le> n\\<rbrakk>\n  \\<Longrightarrow> set_of_bv (nfa_steps (quantify_nfa v N) q xs) =\n                    (\\<Union>xsa\\<in>{x. length x = length xs}.\n                        set_of_bv (nfa_steps N q (insertll v xsa xs)))\n  wf_nfa N (Suc n)\n  list_all (is_alph n) (xs @ [x])\n  nfa_is_node N q\n  v \\<le> n\n  list_all (is_alph (Suc n)) (insertll v bs xs)\n\ngoal (1 subgoal):\n 1. nfa_is_node N (nfa_steps N q (insertll v bs xs))", "by (simp add: nfa_steps_is_node)"], ["proof (state)\nthis:\n  nfa_is_node N (nfa_steps N q (insertll v bs xs))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "}"], ["proof (state)\nthis:\n  length ?bs2 = length xs \\<Longrightarrow>\n  nfa_is_node N (nfa_steps N q (insertll v ?bs2 xs))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "note N2 = this"], ["proof (state)\nthis:\n  length ?bs2 = length xs \\<Longrightarrow>\n  nfa_is_node N (nfa_steps N q (insertll v ?bs2 xs))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "have \"set_of_bv (nfa_steps (quantify_nfa v N) q (xs @ [x])) = set_of_bv (nfa_steps (quantify_nfa v N) ?q [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_of_bv (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n    set_of_bv\n     (nfa_steps (quantify_nfa v N) (nfa_steps (quantify_nfa v N) q xs) [x])", "by simp"], ["proof (state)\nthis:\n  set_of_bv (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n  set_of_bv\n   (nfa_steps (quantify_nfa v N) (nfa_steps (quantify_nfa v N) q xs) [x])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "also"], ["proof (state)\nthis:\n  set_of_bv (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n  set_of_bv\n   (nfa_steps (quantify_nfa v N) (nfa_steps (quantify_nfa v N) q xs) [x])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "have \"\\<dots> = set_of_bv (nfa_trans (quantify_nfa v N) ?q x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_of_bv\n     (nfa_steps (quantify_nfa v N) (nfa_steps (quantify_nfa v N) q xs)\n       [x]) =\n    set_of_bv\n     (nfa_trans (quantify_nfa v N) (nfa_steps (quantify_nfa v N) q xs) x)", "by simp"], ["proof (state)\nthis:\n  set_of_bv\n   (nfa_steps (quantify_nfa v N) (nfa_steps (quantify_nfa v N) q xs) [x]) =\n  set_of_bv\n   (nfa_trans (quantify_nfa v N) (nfa_steps (quantify_nfa v N) q xs) x)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "also"], ["proof (state)\nthis:\n  set_of_bv\n   (nfa_steps (quantify_nfa v N) (nfa_steps (quantify_nfa v N) q xs) [x]) =\n  set_of_bv\n   (nfa_trans (quantify_nfa v N) (nfa_steps (quantify_nfa v N) q xs) x)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "from snoc N"], ["proof (chain)\npicking this:\n  \\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs; nfa_is_node N q;\n   v \\<le> n\\<rbrakk>\n  \\<Longrightarrow> set_of_bv (nfa_steps (quantify_nfa v N) q xs) =\n                    (\\<Union>xsa\\<in>{x. length x = length xs}.\n                        set_of_bv (nfa_steps N q (insertll v xsa xs)))\n  wf_nfa N (Suc n)\n  list_all (is_alph n) (xs @ [x])\n  nfa_is_node N q\n  v \\<le> n\n  nfa_is_node N (nfa_steps (quantify_nfa v N) q xs)", "have \"\\<dots> = (\\<Union>b. set_of_bv (nfa_trans N ?q (insertl v b x)))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs; nfa_is_node N q;\n   v \\<le> n\\<rbrakk>\n  \\<Longrightarrow> set_of_bv (nfa_steps (quantify_nfa v N) q xs) =\n                    (\\<Union>xsa\\<in>{x. length x = length xs}.\n                        set_of_bv (nfa_steps N q (insertll v xsa xs)))\n  wf_nfa N (Suc n)\n  list_all (is_alph n) (xs @ [x])\n  nfa_is_node N q\n  v \\<le> n\n  nfa_is_node N (nfa_steps (quantify_nfa v N) q xs)\n\ngoal (1 subgoal):\n 1. set_of_bv\n     (nfa_trans (quantify_nfa v N) (nfa_steps (quantify_nfa v N) q xs) x) =\n    (\\<Union>b.\n        set_of_bv\n         (nfa_trans N (nfa_steps (quantify_nfa v N) q xs) (insertl v b x)))", "by (simp add: nfa_trans_quantify_nfa)"], ["proof (state)\nthis:\n  set_of_bv\n   (nfa_trans (quantify_nfa v N) (nfa_steps (quantify_nfa v N) q xs) x) =\n  (\\<Union>b.\n      set_of_bv\n       (nfa_trans N (nfa_steps (quantify_nfa v N) q xs) (insertl v b x)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "also"], ["proof (state)\nthis:\n  set_of_bv\n   (nfa_trans (quantify_nfa v N) (nfa_steps (quantify_nfa v N) q xs) x) =\n  (\\<Union>b.\n      set_of_bv\n       (nfa_trans N (nfa_steps (quantify_nfa v N) q xs) (insertl v b x)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "have \"\\<dots> = (\\<Union>b. set_of_bv (bdd_lookup (subsetbdd (fst N) ?q (nfa_emptybdd (length ?q))) (insertl v b x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>b.\n        set_of_bv\n         (nfa_trans N (nfa_steps (quantify_nfa v N) q xs)\n           (insertl v b x))) =\n    (\\<Union>b.\n        set_of_bv\n         (bdd_lookup\n           (subsetbdd (fst N) (nfa_steps (quantify_nfa v N) q xs)\n             (nfa_emptybdd (length (nfa_steps (quantify_nfa v N) q xs))))\n           (insertl v b x)))", "by (simp add: nfa_trans_def)"], ["proof (state)\nthis:\n  (\\<Union>b.\n      set_of_bv\n       (nfa_trans N (nfa_steps (quantify_nfa v N) q xs) (insertl v b x))) =\n  (\\<Union>b.\n      set_of_bv\n       (bdd_lookup\n         (subsetbdd (fst N) (nfa_steps (quantify_nfa v N) q xs)\n           (nfa_emptybdd (length (nfa_steps (quantify_nfa v N) q xs))))\n         (insertl v b x)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "also"], ["proof (state)\nthis:\n  (\\<Union>b.\n      set_of_bv\n       (nfa_trans N (nfa_steps (quantify_nfa v N) q xs) (insertl v b x))) =\n  (\\<Union>b.\n      set_of_bv\n       (bdd_lookup\n         (subsetbdd (fst N) (nfa_steps (quantify_nfa v N) q xs)\n           (nfa_emptybdd (length (nfa_steps (quantify_nfa v N) q xs))))\n         (insertl v b x)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "from N B"], ["proof (chain)\npicking this:\n  nfa_is_node N (nfa_steps (quantify_nfa v N) q xs)\n  wf_nfa N (length (insertl v ?b x))", "have \"\\<dots> = (\\<Union>b. \\<Union>i\\<in>set_of_bv ?q. set_of_bv (bdd_lookup (fst N ! i) (insertl v b x)))\""], ["proof (prove)\nusing this:\n  nfa_is_node N (nfa_steps (quantify_nfa v N) q xs)\n  wf_nfa N (length (insertl v ?b x))\n\ngoal (1 subgoal):\n 1. (\\<Union>b.\n        set_of_bv\n         (bdd_lookup\n           (subsetbdd (fst N) (nfa_steps (quantify_nfa v N) q xs)\n             (nfa_emptybdd (length (nfa_steps (quantify_nfa v N) q xs))))\n           (insertl v b x))) =\n    (\\<Union>b.\n        \\<Union>i\\<in>set_of_bv (nfa_steps (quantify_nfa v N) q xs).\n           set_of_bv (bdd_lookup (fst N ! i) (insertl v b x)))", "by (simp add: subsetbdd_set_of_bv)"], ["proof (state)\nthis:\n  (\\<Union>b.\n      set_of_bv\n       (bdd_lookup\n         (subsetbdd (fst N) (nfa_steps (quantify_nfa v N) q xs)\n           (nfa_emptybdd (length (nfa_steps (quantify_nfa v N) q xs))))\n         (insertl v b x))) =\n  (\\<Union>b.\n      \\<Union>i\\<in>set_of_bv (nfa_steps (quantify_nfa v N) q xs).\n         set_of_bv (bdd_lookup (fst N ! i) (insertl v b x)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "also"], ["proof (state)\nthis:\n  (\\<Union>b.\n      set_of_bv\n       (bdd_lookup\n         (subsetbdd (fst N) (nfa_steps (quantify_nfa v N) q xs)\n           (nfa_emptybdd (length (nfa_steps (quantify_nfa v N) q xs))))\n         (insertl v b x))) =\n  (\\<Union>b.\n      \\<Union>i\\<in>set_of_bv (nfa_steps (quantify_nfa v N) q xs).\n         set_of_bv (bdd_lookup (fst N ! i) (insertl v b x)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "from IV"], ["proof (chain)\npicking this:\n  set_of_bv (nfa_steps (quantify_nfa v N) q xs) =\n  (\\<Union>x\\<in>{x. length x = length xs}.\n      set_of_bv (nfa_steps N q (insertll v x xs)))", "have \"\\<dots> = (\\<Union>b. \\<Union>i\\<in>(\\<Union>x\\<in>{x. length x = length xs}. set_of_bv (nfa_steps N q (insertll v x xs))). set_of_bv (bdd_lookup (fst N ! i) (insertl v b x)))\""], ["proof (prove)\nusing this:\n  set_of_bv (nfa_steps (quantify_nfa v N) q xs) =\n  (\\<Union>x\\<in>{x. length x = length xs}.\n      set_of_bv (nfa_steps N q (insertll v x xs)))\n\ngoal (1 subgoal):\n 1. (\\<Union>b.\n        \\<Union>i\\<in>set_of_bv (nfa_steps (quantify_nfa v N) q xs).\n           set_of_bv (bdd_lookup (fst N ! i) (insertl v b x))) =\n    (\\<Union>b.\n        \\<Union>i\\<in>\\<Union>x\\<in>{x. length x = length xs}.\n                         set_of_bv (nfa_steps N q (insertll v x xs)).\n           set_of_bv (bdd_lookup (fst N ! i) (insertl v b x)))", "by simp"], ["proof (state)\nthis:\n  (\\<Union>b.\n      \\<Union>i\\<in>set_of_bv (nfa_steps (quantify_nfa v N) q xs).\n         set_of_bv (bdd_lookup (fst N ! i) (insertl v b x))) =\n  (\\<Union>b.\n      \\<Union>i\\<in>\\<Union>x\\<in>{x. length x = length xs}.\n                       set_of_bv (nfa_steps N q (insertll v x xs)).\n         set_of_bv (bdd_lookup (fst N ! i) (insertl v b x)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "also"], ["proof (state)\nthis:\n  (\\<Union>b.\n      \\<Union>i\\<in>set_of_bv (nfa_steps (quantify_nfa v N) q xs).\n         set_of_bv (bdd_lookup (fst N ! i) (insertl v b x))) =\n  (\\<Union>b.\n      \\<Union>i\\<in>\\<Union>x\\<in>{x. length x = length xs}.\n                       set_of_bv (nfa_steps N q (insertll v x xs)).\n         set_of_bv (bdd_lookup (fst N ! i) (insertl v b x)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "have \"\\<dots> = (\\<Union>b. \\<Union>y\\<in>{x. length x = length xs}. \\<Union>i\\<in>set_of_bv (nfa_steps N q (insertll v y xs)). set_of_bv (bdd_lookup (fst N ! i) (insertl v b x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>b.\n        \\<Union>i\\<in>\\<Union>x\\<in>{x. length x = length xs}.\n                         set_of_bv (nfa_steps N q (insertll v x xs)).\n           set_of_bv (bdd_lookup (fst N ! i) (insertl v b x))) =\n    (\\<Union>b.\n        \\<Union>y\\<in>{x. length x = length xs}.\n           \\<Union>i\\<in>set_of_bv (nfa_steps N q (insertll v y xs)).\n              set_of_bv (bdd_lookup (fst N ! i) (insertl v b x)))", "by simp"], ["proof (state)\nthis:\n  (\\<Union>b.\n      \\<Union>i\\<in>\\<Union>x\\<in>{x. length x = length xs}.\n                       set_of_bv (nfa_steps N q (insertll v x xs)).\n         set_of_bv (bdd_lookup (fst N ! i) (insertl v b x))) =\n  (\\<Union>b.\n      \\<Union>y\\<in>{x. length x = length xs}.\n         \\<Union>i\\<in>set_of_bv (nfa_steps N q (insertll v y xs)).\n            set_of_bv (bdd_lookup (fst N ! i) (insertl v b x)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "also"], ["proof (state)\nthis:\n  (\\<Union>b.\n      \\<Union>i\\<in>\\<Union>x\\<in>{x. length x = length xs}.\n                       set_of_bv (nfa_steps N q (insertll v x xs)).\n         set_of_bv (bdd_lookup (fst N ! i) (insertl v b x))) =\n  (\\<Union>b.\n      \\<Union>y\\<in>{x. length x = length xs}.\n         \\<Union>i\\<in>set_of_bv (nfa_steps N q (insertll v y xs)).\n            set_of_bv (bdd_lookup (fst N ! i) (insertl v b x)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "have \"\\<dots> = (\\<Union>bs\\<in>{x. length x = Suc (length xs)}. \\<Union>i\\<in>set_of_bv (nfa_steps N q (insertll v (butlast bs) xs)). set_of_bv (bdd_lookup (fst N ! i) (insertl v (last bs) x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>b.\n        \\<Union>y\\<in>{x. length x = length xs}.\n           \\<Union>i\\<in>set_of_bv (nfa_steps N q (insertll v y xs)).\n              set_of_bv (bdd_lookup (fst N ! i) (insertl v b x))) =\n    (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n        \\<Union>i\\<in>set_of_bv\n                       (nfa_steps N q (insertll v (butlast bs) xs)).\n           set_of_bv (bdd_lookup (fst N ! i) (insertl v (last bs) x)))", "by (simp add: UN_UN_lenset)"], ["proof (state)\nthis:\n  (\\<Union>b.\n      \\<Union>y\\<in>{x. length x = length xs}.\n         \\<Union>i\\<in>set_of_bv (nfa_steps N q (insertll v y xs)).\n            set_of_bv (bdd_lookup (fst N ! i) (insertl v b x))) =\n  (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n      \\<Union>i\\<in>set_of_bv (nfa_steps N q (insertll v (butlast bs) xs)).\n         set_of_bv (bdd_lookup (fst N ! i) (insertl v (last bs) x)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "also"], ["proof (state)\nthis:\n  (\\<Union>b.\n      \\<Union>y\\<in>{x. length x = length xs}.\n         \\<Union>i\\<in>set_of_bv (nfa_steps N q (insertll v y xs)).\n            set_of_bv (bdd_lookup (fst N ! i) (insertl v b x))) =\n  (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n      \\<Union>i\\<in>set_of_bv (nfa_steps N q (insertll v (butlast bs) xs)).\n         set_of_bv (bdd_lookup (fst N ! i) (insertl v (last bs) x)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "from N2 B"], ["proof (chain)\npicking this:\n  length ?bs2 = length xs \\<Longrightarrow>\n  nfa_is_node N (nfa_steps N q (insertll v ?bs2 xs))\n  wf_nfa N (length (insertl v ?b x))", "have \"\\<dots> = (\\<Union>bs\\<in>{x. length x = Suc (length xs)}. set_of_bv (nfa_trans N (nfa_steps N q (insertll v (butlast bs) xs)) (insertl v (last bs) x)))\" (is \"?L = ?R\")"], ["proof (prove)\nusing this:\n  length ?bs2 = length xs \\<Longrightarrow>\n  nfa_is_node N (nfa_steps N q (insertll v ?bs2 xs))\n  wf_nfa N (length (insertl v ?b x))\n\ngoal (1 subgoal):\n 1. (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n        \\<Union>i\\<in>set_of_bv\n                       (nfa_steps N q (insertll v (butlast bs) xs)).\n           set_of_bv (bdd_lookup (fst N ! i) (insertl v (last bs) x))) =\n    (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n        set_of_bv\n         (nfa_trans N (nfa_steps N q (insertll v (butlast bs) xs))\n           (insertl v (last bs) x)))", "by (simp add: subsetbdd_set_of_bv[folded nfa_trans_def])"], ["proof (state)\nthis:\n  (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n      \\<Union>i\\<in>set_of_bv (nfa_steps N q (insertll v (butlast bs) xs)).\n         set_of_bv (bdd_lookup (fst N ! i) (insertl v (last bs) x))) =\n  (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n      set_of_bv\n       (nfa_trans N (nfa_steps N q (insertll v (butlast bs) xs))\n         (insertl v (last bs) x)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "also"], ["proof (state)\nthis:\n  (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n      \\<Union>i\\<in>set_of_bv (nfa_steps N q (insertll v (butlast bs) xs)).\n         set_of_bv (bdd_lookup (fst N ! i) (insertl v (last bs) x))) =\n  (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n      set_of_bv\n       (nfa_trans N (nfa_steps N q (insertll v (butlast bs) xs))\n         (insertl v (last bs) x)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "have \"\\<dots> = (\\<Union>bs\\<in>{x. length x = Suc (length xs)}. set_of_bv (nfa_steps N q (insertll v (butlast bs) xs @ [insertl v (last bs) x])))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n        set_of_bv\n         (nfa_trans N (nfa_steps N q (insertll v (butlast bs) xs))\n           (insertl v (last bs) x))) =\n    (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n        set_of_bv\n         (nfa_steps N q\n           (insertll v (butlast bs) xs @ [insertl v (last bs) x])))", "by simp"], ["proof (state)\nthis:\n  (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n      set_of_bv\n       (nfa_trans N (nfa_steps N q (insertll v (butlast bs) xs))\n         (insertl v (last bs) x))) =\n  (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n      set_of_bv\n       (nfa_steps N q\n         (insertll v (butlast bs) xs @ [insertl v (last bs) x])))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "also"], ["proof (state)\nthis:\n  (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n      set_of_bv\n       (nfa_trans N (nfa_steps N q (insertll v (butlast bs) xs))\n         (insertl v (last bs) x))) =\n  (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n      set_of_bv\n       (nfa_steps N q\n         (insertll v (butlast bs) xs @ [insertl v (last bs) x])))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "have \"\\<dots> = (\\<Union>bs\\<in>{x. length x = Suc (length xs)}. set_of_bv (nfa_steps N q (insertll v (butlast bs @ [last bs]) (xs @ [x]))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n        set_of_bv\n         (nfa_steps N q\n           (insertll v (butlast bs) xs @ [insertl v (last bs) x]))) =\n    (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n        set_of_bv\n         (nfa_steps N q (insertll v (butlast bs @ [last bs]) (xs @ [x]))))", "by (auto simp: insertll_append)"], ["proof (state)\nthis:\n  (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n      set_of_bv\n       (nfa_steps N q\n         (insertll v (butlast bs) xs @ [insertl v (last bs) x]))) =\n  (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n      set_of_bv\n       (nfa_steps N q (insertll v (butlast bs @ [last bs]) (xs @ [x]))))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "also"], ["proof (state)\nthis:\n  (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n      set_of_bv\n       (nfa_steps N q\n         (insertll v (butlast bs) xs @ [insertl v (last bs) x]))) =\n  (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n      set_of_bv\n       (nfa_steps N q (insertll v (butlast bs @ [last bs]) (xs @ [x]))))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "have \"\\<dots> = (\\<Union>bs\\<in>{x. length x = Suc (length xs)}. set_of_bv (nfa_steps N q (insertll v bs (xs @ [x]))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n        set_of_bv\n         (nfa_steps N q (insertll v (butlast bs @ [last bs]) (xs @ [x])))) =\n    (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n        set_of_bv (nfa_steps N q (insertll v bs (xs @ [x]))))", "proof (rule set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (xa \\<in> (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n                     set_of_bv\n                      (nfa_steps N q\n                        (insertll v (butlast bs @ [last bs])\n                          (xs @ [x]))))) =\n       (xa \\<in> (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n                     set_of_bv (nfa_steps N q (insertll v bs (xs @ [x])))))", "fix xa"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (xa \\<in> (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n                     set_of_bv\n                      (nfa_steps N q\n                        (insertll v (butlast bs @ [last bs])\n                          (xs @ [x]))))) =\n       (xa \\<in> (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n                     set_of_bv (nfa_steps N q (insertll v bs (xs @ [x])))))", "have \"(xa \\<in> (\\<Union>bs\\<in>{x. length x = Suc (length xs)}. set_of_bv (nfa_steps N q (insertll v (butlast bs @ [last bs]) (xs @ [x]))))) =\n      (\\<exists>bs \\<in> {x. length x = Suc (length xs)}. bs \\<noteq> [] \\<and> xa \\<in> set_of_bv (nfa_steps N q (insertll v (butlast bs @ [last bs]) (xs @ [x]))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xa \\<in> (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n                  set_of_bv\n                   (nfa_steps N q\n                     (insertll v (butlast bs @ [last bs]) (xs @ [x]))))) =\n    (\\<exists>bs\\<in>{x. length x = Suc (length xs)}.\n        bs \\<noteq> [] \\<and>\n        xa \\<in> set_of_bv\n                  (nfa_steps N q\n                    (insertll v (butlast bs @ [last bs]) (xs @ [x]))))", "by auto"], ["proof (state)\nthis:\n  (xa \\<in> (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n                set_of_bv\n                 (nfa_steps N q\n                   (insertll v (butlast bs @ [last bs]) (xs @ [x]))))) =\n  (\\<exists>bs\\<in>{x. length x = Suc (length xs)}.\n      bs \\<noteq> [] \\<and>\n      xa \\<in> set_of_bv\n                (nfa_steps N q\n                  (insertll v (butlast bs @ [last bs]) (xs @ [x]))))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (xa \\<in> (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n                     set_of_bv\n                      (nfa_steps N q\n                        (insertll v (butlast bs @ [last bs])\n                          (xs @ [x]))))) =\n       (xa \\<in> (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n                     set_of_bv (nfa_steps N q (insertll v bs (xs @ [x])))))", "also"], ["proof (state)\nthis:\n  (xa \\<in> (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n                set_of_bv\n                 (nfa_steps N q\n                   (insertll v (butlast bs @ [last bs]) (xs @ [x]))))) =\n  (\\<exists>bs\\<in>{x. length x = Suc (length xs)}.\n      bs \\<noteq> [] \\<and>\n      xa \\<in> set_of_bv\n                (nfa_steps N q\n                  (insertll v (butlast bs @ [last bs]) (xs @ [x]))))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (xa \\<in> (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n                     set_of_bv\n                      (nfa_steps N q\n                        (insertll v (butlast bs @ [last bs])\n                          (xs @ [x]))))) =\n       (xa \\<in> (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n                     set_of_bv (nfa_steps N q (insertll v bs (xs @ [x])))))", "have \"\\<dots> = (\\<exists>bs \\<in> {x. length x = Suc (length xs)}. bs \\<noteq> [] \\<and> xa \\<in> set_of_bv (nfa_steps N q (insertll v bs (xs @ [x]))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>bs\\<in>{x. length x = Suc (length xs)}.\n        bs \\<noteq> [] \\<and>\n        xa \\<in> set_of_bv\n                  (nfa_steps N q\n                    (insertll v (butlast bs @ [last bs]) (xs @ [x])))) =\n    (\\<exists>bs\\<in>{x. length x = Suc (length xs)}.\n        bs \\<noteq> [] \\<and>\n        xa \\<in> set_of_bv (nfa_steps N q (insertll v bs (xs @ [x]))))", "by auto"], ["proof (state)\nthis:\n  (\\<exists>bs\\<in>{x. length x = Suc (length xs)}.\n      bs \\<noteq> [] \\<and>\n      xa \\<in> set_of_bv\n                (nfa_steps N q\n                  (insertll v (butlast bs @ [last bs]) (xs @ [x])))) =\n  (\\<exists>bs\\<in>{x. length x = Suc (length xs)}.\n      bs \\<noteq> [] \\<and>\n      xa \\<in> set_of_bv (nfa_steps N q (insertll v bs (xs @ [x]))))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (xa \\<in> (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n                     set_of_bv\n                      (nfa_steps N q\n                        (insertll v (butlast bs @ [last bs])\n                          (xs @ [x]))))) =\n       (xa \\<in> (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n                     set_of_bv (nfa_steps N q (insertll v bs (xs @ [x])))))", "also"], ["proof (state)\nthis:\n  (\\<exists>bs\\<in>{x. length x = Suc (length xs)}.\n      bs \\<noteq> [] \\<and>\n      xa \\<in> set_of_bv\n                (nfa_steps N q\n                  (insertll v (butlast bs @ [last bs]) (xs @ [x])))) =\n  (\\<exists>bs\\<in>{x. length x = Suc (length xs)}.\n      bs \\<noteq> [] \\<and>\n      xa \\<in> set_of_bv (nfa_steps N q (insertll v bs (xs @ [x]))))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (xa \\<in> (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n                     set_of_bv\n                      (nfa_steps N q\n                        (insertll v (butlast bs @ [last bs])\n                          (xs @ [x]))))) =\n       (xa \\<in> (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n                     set_of_bv (nfa_steps N q (insertll v bs (xs @ [x])))))", "have \"\\<dots> = (xa \\<in> (\\<Union>bs\\<in>{x. length x = Suc (length xs)}. set_of_bv (nfa_steps N q (insertll v bs (xs @ [x])))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>bs\\<in>{x. length x = Suc (length xs)}.\n        bs \\<noteq> [] \\<and>\n        xa \\<in> set_of_bv (nfa_steps N q (insertll v bs (xs @ [x])))) =\n    (xa \\<in> (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n                  set_of_bv (nfa_steps N q (insertll v bs (xs @ [x])))))", "by auto"], ["proof (state)\nthis:\n  (\\<exists>bs\\<in>{x. length x = Suc (length xs)}.\n      bs \\<noteq> [] \\<and>\n      xa \\<in> set_of_bv (nfa_steps N q (insertll v bs (xs @ [x])))) =\n  (xa \\<in> (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n                set_of_bv (nfa_steps N q (insertll v bs (xs @ [x])))))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (xa \\<in> (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n                     set_of_bv\n                      (nfa_steps N q\n                        (insertll v (butlast bs @ [last bs])\n                          (xs @ [x]))))) =\n       (xa \\<in> (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n                     set_of_bv (nfa_steps N q (insertll v bs (xs @ [x])))))", "finally"], ["proof (chain)\npicking this:\n  (xa \\<in> (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n                set_of_bv\n                 (nfa_steps N q\n                   (insertll v (butlast bs @ [last bs]) (xs @ [x]))))) =\n  (xa \\<in> (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n                set_of_bv (nfa_steps N q (insertll v bs (xs @ [x])))))", "show \"(xa \\<in> (\\<Union>bs\\<in>{x. length x = Suc (length xs)}. set_of_bv (nfa_steps N q (insertll v (butlast bs @ [last bs]) (xs @ [x]))))) =\n  (xa \\<in> (\\<Union>bs\\<in>{x. length x = Suc (length xs)}. set_of_bv (nfa_steps N q (insertll v bs (xs @ [x])))))\""], ["proof (prove)\nusing this:\n  (xa \\<in> (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n                set_of_bv\n                 (nfa_steps N q\n                   (insertll v (butlast bs @ [last bs]) (xs @ [x]))))) =\n  (xa \\<in> (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n                set_of_bv (nfa_steps N q (insertll v bs (xs @ [x])))))\n\ngoal (1 subgoal):\n 1. (xa \\<in> (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n                  set_of_bv\n                   (nfa_steps N q\n                     (insertll v (butlast bs @ [last bs]) (xs @ [x]))))) =\n    (xa \\<in> (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n                  set_of_bv (nfa_steps N q (insertll v bs (xs @ [x])))))", "."], ["proof (state)\nthis:\n  (xa \\<in> (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n                set_of_bv\n                 (nfa_steps N q\n                   (insertll v (butlast bs @ [last bs]) (xs @ [x]))))) =\n  (xa \\<in> (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n                set_of_bv (nfa_steps N q (insertll v bs (xs @ [x])))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n      set_of_bv\n       (nfa_steps N q (insertll v (butlast bs @ [last bs]) (xs @ [x])))) =\n  (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n      set_of_bv (nfa_steps N q (insertll v bs (xs @ [x]))))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_nfa N (Suc n); list_all (is_alph n) xs;\n                 nfa_is_node N q; v \\<le> n\\<rbrakk>\n                \\<Longrightarrow> set_of_bv\n                                   (nfa_steps (quantify_nfa v N) q xs) =\n                                  (\\<Union>xsa\\<in>{x.\n              length x = length xs}.\nset_of_bv (nfa_steps N q (insertll v xsa xs)));\n        wf_nfa N (Suc n); list_all (is_alph n) (xs @ [x]); nfa_is_node N q;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> set_of_bv\n                          (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n                         (\\<Union>xsa\\<in>{xa.\n     length xa = length (xs @ [x])}.\n                             set_of_bv\n                              (nfa_steps N q (insertll v xsa (xs @ [x]))))", "finally"], ["proof (chain)\npicking this:\n  set_of_bv (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n  (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n      set_of_bv (nfa_steps N q (insertll v bs (xs @ [x]))))", "show ?case"], ["proof (prove)\nusing this:\n  set_of_bv (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n  (\\<Union>bs\\<in>{x. length x = Suc (length xs)}.\n      set_of_bv (nfa_steps N q (insertll v bs (xs @ [x]))))\n\ngoal (1 subgoal):\n 1. set_of_bv (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n    (\\<Union>xsa\\<in>{xa. length xa = length (xs @ [x])}.\n        set_of_bv (nfa_steps N q (insertll v xsa (xs @ [x]))))", "by simp"], ["proof (state)\nthis:\n  set_of_bv (nfa_steps (quantify_nfa v N) q (xs @ [x])) =\n  (\\<Union>xsa\\<in>{xa. length xa = length (xs @ [x])}.\n      set_of_bv (nfa_steps N q (insertll v xsa (xs @ [x]))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nfa_accepts_quantify_nfa:\n  assumes \"wf_nfa A (Suc n)\"\n  and \"i \\<le> n\"\n  and \"list_all (is_alph n) bss\"\n  shows \"nfa_accepts (quantify_nfa i A) bss = (\\<exists>bs. nfa_accepts A (insertll i bs bss) \\<and> length bs = length bss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfa_accepts (quantify_nfa i A) bss =\n    (\\<exists>bs.\n        nfa_accepts A (insertll i bs bss) \\<and> length bs = length bss)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nfa_accepts (quantify_nfa i A) bss =\n    (\\<exists>bs.\n        nfa_accepts A (insertll i bs bss) \\<and> length bs = length bss)", "note Q0 = nfa_startnode_is_node[OF assms(1)]"], ["proof (state)\nthis:\n  nfa_is_node A (nfa_startnode A)\n\ngoal (1 subgoal):\n 1. nfa_accepts (quantify_nfa i A) bss =\n    (\\<exists>bs.\n        nfa_accepts A (insertll i bs bss) \\<and> length bs = length bss)", "hence \"nfa_is_node A (nfa_startnode (quantify_nfa i A))\""], ["proof (prove)\nusing this:\n  nfa_is_node A (nfa_startnode A)\n\ngoal (1 subgoal):\n 1. nfa_is_node A (nfa_startnode (quantify_nfa i A))", "by (simp add: nfa_startnode_def quantify_nfa_def split_beta)"], ["proof (state)\nthis:\n  nfa_is_node A (nfa_startnode (quantify_nfa i A))\n\ngoal (1 subgoal):\n 1. nfa_accepts (quantify_nfa i A) bss =\n    (\\<exists>bs.\n        nfa_accepts A (insertll i bs bss) \\<and> length bs = length bss)", "with assms"], ["proof (chain)\npicking this:\n  wf_nfa A (Suc n)\n  i \\<le> n\n  list_all (is_alph n) bss\n  nfa_is_node A (nfa_startnode (quantify_nfa i A))", "have I: \"set_of_bv (nfa_steps (quantify_nfa i A) (nfa_startnode (quantify_nfa i A)) bss) =\n    (\\<Union>bs \\<in> {bs. length bs = length bss}. set_of_bv (nfa_steps A (nfa_startnode (quantify_nfa i A)) (insertll i bs bss)))\""], ["proof (prove)\nusing this:\n  wf_nfa A (Suc n)\n  i \\<le> n\n  list_all (is_alph n) bss\n  nfa_is_node A (nfa_startnode (quantify_nfa i A))\n\ngoal (1 subgoal):\n 1. set_of_bv\n     (nfa_steps (quantify_nfa i A) (nfa_startnode (quantify_nfa i A)) bss) =\n    (\\<Union>bs\\<in>{bs. length bs = length bss}.\n        set_of_bv\n         (nfa_steps A (nfa_startnode (quantify_nfa i A))\n           (insertll i bs bss)))", "by (simp add: nfa_steps_quantify_nfa)"], ["proof (state)\nthis:\n  set_of_bv\n   (nfa_steps (quantify_nfa i A) (nfa_startnode (quantify_nfa i A)) bss) =\n  (\\<Union>bs\\<in>{bs. length bs = length bss}.\n      set_of_bv\n       (nfa_steps A (nfa_startnode (quantify_nfa i A)) (insertll i bs bss)))\n\ngoal (1 subgoal):\n 1. nfa_accepts (quantify_nfa i A) bss =\n    (\\<exists>bs.\n        nfa_accepts A (insertll i bs bss) \\<and> length bs = length bss)", "have \"nfa_accepts (quantify_nfa i A) bss = nfa_accepting (quantify_nfa i A) (nfa_steps (quantify_nfa i A) (nfa_startnode (quantify_nfa i A)) bss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfa_accepts (quantify_nfa i A) bss =\n    nfa_accepting (quantify_nfa i A)\n     (nfa_steps (quantify_nfa i A) (nfa_startnode (quantify_nfa i A)) bss)", "by (simp add: accepts_def)"], ["proof (state)\nthis:\n  nfa_accepts (quantify_nfa i A) bss =\n  nfa_accepting (quantify_nfa i A)\n   (nfa_steps (quantify_nfa i A) (nfa_startnode (quantify_nfa i A)) bss)\n\ngoal (1 subgoal):\n 1. nfa_accepts (quantify_nfa i A) bss =\n    (\\<exists>bs.\n        nfa_accepts A (insertll i bs bss) \\<and> length bs = length bss)", "also"], ["proof (state)\nthis:\n  nfa_accepts (quantify_nfa i A) bss =\n  nfa_accepting (quantify_nfa i A)\n   (nfa_steps (quantify_nfa i A) (nfa_startnode (quantify_nfa i A)) bss)\n\ngoal (1 subgoal):\n 1. nfa_accepts (quantify_nfa i A) bss =\n    (\\<exists>bs.\n        nfa_accepts A (insertll i bs bss) \\<and> length bs = length bss)", "have \"\\<dots> = (set_of_bv (snd (quantify_nfa i A)) \\<inter> set_of_bv (nfa_steps (quantify_nfa i A) (nfa_startnode (quantify_nfa i A)) bss) \\<noteq> {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfa_accepting (quantify_nfa i A)\n     (nfa_steps (quantify_nfa i A) (nfa_startnode (quantify_nfa i A)) bss) =\n    (set_of_bv (snd (quantify_nfa i A)) \\<inter>\n     set_of_bv\n      (nfa_steps (quantify_nfa i A) (nfa_startnode (quantify_nfa i A))\n        bss) \\<noteq>\n     {})", "by (simp add: nfa_accepting_set_of_bv)"], ["proof (state)\nthis:\n  nfa_accepting (quantify_nfa i A)\n   (nfa_steps (quantify_nfa i A) (nfa_startnode (quantify_nfa i A)) bss) =\n  (set_of_bv (snd (quantify_nfa i A)) \\<inter>\n   set_of_bv\n    (nfa_steps (quantify_nfa i A) (nfa_startnode (quantify_nfa i A))\n      bss) \\<noteq>\n   {})\n\ngoal (1 subgoal):\n 1. nfa_accepts (quantify_nfa i A) bss =\n    (\\<exists>bs.\n        nfa_accepts A (insertll i bs bss) \\<and> length bs = length bss)", "also"], ["proof (state)\nthis:\n  nfa_accepting (quantify_nfa i A)\n   (nfa_steps (quantify_nfa i A) (nfa_startnode (quantify_nfa i A)) bss) =\n  (set_of_bv (snd (quantify_nfa i A)) \\<inter>\n   set_of_bv\n    (nfa_steps (quantify_nfa i A) (nfa_startnode (quantify_nfa i A))\n      bss) \\<noteq>\n   {})\n\ngoal (1 subgoal):\n 1. nfa_accepts (quantify_nfa i A) bss =\n    (\\<exists>bs.\n        nfa_accepts A (insertll i bs bss) \\<and> length bs = length bss)", "from I"], ["proof (chain)\npicking this:\n  set_of_bv\n   (nfa_steps (quantify_nfa i A) (nfa_startnode (quantify_nfa i A)) bss) =\n  (\\<Union>bs\\<in>{bs. length bs = length bss}.\n      set_of_bv\n       (nfa_steps A (nfa_startnode (quantify_nfa i A)) (insertll i bs bss)))", "have \"\\<dots> = (set_of_bv (snd A) \\<inter> (\\<Union>bs \\<in> {bs. length bs = length bss}. set_of_bv (nfa_steps A (nfa_startnode (quantify_nfa i A)) (insertll i bs bss))) \\<noteq> {})\""], ["proof (prove)\nusing this:\n  set_of_bv\n   (nfa_steps (quantify_nfa i A) (nfa_startnode (quantify_nfa i A)) bss) =\n  (\\<Union>bs\\<in>{bs. length bs = length bss}.\n      set_of_bv\n       (nfa_steps A (nfa_startnode (quantify_nfa i A)) (insertll i bs bss)))\n\ngoal (1 subgoal):\n 1. (set_of_bv (snd (quantify_nfa i A)) \\<inter>\n     set_of_bv\n      (nfa_steps (quantify_nfa i A) (nfa_startnode (quantify_nfa i A))\n        bss) \\<noteq>\n     {}) =\n    (set_of_bv (snd A) \\<inter>\n     (\\<Union>bs\\<in>{bs. length bs = length bss}.\n         set_of_bv\n          (nfa_steps A (nfa_startnode (quantify_nfa i A))\n            (insertll i bs bss))) \\<noteq>\n     {})", "by (simp add: quantify_nfa_def split_beta)"], ["proof (state)\nthis:\n  (set_of_bv (snd (quantify_nfa i A)) \\<inter>\n   set_of_bv\n    (nfa_steps (quantify_nfa i A) (nfa_startnode (quantify_nfa i A))\n      bss) \\<noteq>\n   {}) =\n  (set_of_bv (snd A) \\<inter>\n   (\\<Union>bs\\<in>{bs. length bs = length bss}.\n       set_of_bv\n        (nfa_steps A (nfa_startnode (quantify_nfa i A))\n          (insertll i bs bss))) \\<noteq>\n   {})\n\ngoal (1 subgoal):\n 1. nfa_accepts (quantify_nfa i A) bss =\n    (\\<exists>bs.\n        nfa_accepts A (insertll i bs bss) \\<and> length bs = length bss)", "also"], ["proof (state)\nthis:\n  (set_of_bv (snd (quantify_nfa i A)) \\<inter>\n   set_of_bv\n    (nfa_steps (quantify_nfa i A) (nfa_startnode (quantify_nfa i A))\n      bss) \\<noteq>\n   {}) =\n  (set_of_bv (snd A) \\<inter>\n   (\\<Union>bs\\<in>{bs. length bs = length bss}.\n       set_of_bv\n        (nfa_steps A (nfa_startnode (quantify_nfa i A))\n          (insertll i bs bss))) \\<noteq>\n   {})\n\ngoal (1 subgoal):\n 1. nfa_accepts (quantify_nfa i A) bss =\n    (\\<exists>bs.\n        nfa_accepts A (insertll i bs bss) \\<and> length bs = length bss)", "have \"\\<dots> = ((\\<Union>bs \\<in> {bs. length bs = length bss}. set_of_bv (snd A) \\<inter> set_of_bv (nfa_steps A (nfa_startnode (quantify_nfa i A)) (insertll i bs bss))) \\<noteq> {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set_of_bv (snd A) \\<inter>\n     (\\<Union>bs\\<in>{bs. length bs = length bss}.\n         set_of_bv\n          (nfa_steps A (nfa_startnode (quantify_nfa i A))\n            (insertll i bs bss))) \\<noteq>\n     {}) =\n    ((\\<Union>bs\\<in>{bs. length bs = length bss}.\n         set_of_bv (snd A) \\<inter>\n         set_of_bv\n          (nfa_steps A (nfa_startnode (quantify_nfa i A))\n            (insertll i bs bss))) \\<noteq>\n     {})", "by simp"], ["proof (state)\nthis:\n  (set_of_bv (snd A) \\<inter>\n   (\\<Union>bs\\<in>{bs. length bs = length bss}.\n       set_of_bv\n        (nfa_steps A (nfa_startnode (quantify_nfa i A))\n          (insertll i bs bss))) \\<noteq>\n   {}) =\n  ((\\<Union>bs\\<in>{bs. length bs = length bss}.\n       set_of_bv (snd A) \\<inter>\n       set_of_bv\n        (nfa_steps A (nfa_startnode (quantify_nfa i A))\n          (insertll i bs bss))) \\<noteq>\n   {})\n\ngoal (1 subgoal):\n 1. nfa_accepts (quantify_nfa i A) bss =\n    (\\<exists>bs.\n        nfa_accepts A (insertll i bs bss) \\<and> length bs = length bss)", "also"], ["proof (state)\nthis:\n  (set_of_bv (snd A) \\<inter>\n   (\\<Union>bs\\<in>{bs. length bs = length bss}.\n       set_of_bv\n        (nfa_steps A (nfa_startnode (quantify_nfa i A))\n          (insertll i bs bss))) \\<noteq>\n   {}) =\n  ((\\<Union>bs\\<in>{bs. length bs = length bss}.\n       set_of_bv (snd A) \\<inter>\n       set_of_bv\n        (nfa_steps A (nfa_startnode (quantify_nfa i A))\n          (insertll i bs bss))) \\<noteq>\n   {})\n\ngoal (1 subgoal):\n 1. nfa_accepts (quantify_nfa i A) bss =\n    (\\<exists>bs.\n        nfa_accepts A (insertll i bs bss) \\<and> length bs = length bss)", "have \"\\<dots> = (\\<exists>bs \\<in> {bs. length bs = length bss}. set_of_bv (snd A) \\<inter> set_of_bv (nfa_steps A (nfa_startnode A) (insertll i bs bss)) \\<noteq> {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Union>bs\\<in>{bs. length bs = length bss}.\n         set_of_bv (snd A) \\<inter>\n         set_of_bv\n          (nfa_steps A (nfa_startnode (quantify_nfa i A))\n            (insertll i bs bss))) \\<noteq>\n     {}) =\n    (\\<exists>bs\\<in>{bs. length bs = length bss}.\n        set_of_bv (snd A) \\<inter>\n        set_of_bv\n         (nfa_steps A (nfa_startnode A) (insertll i bs bss)) \\<noteq>\n        {})", "by (auto simp: nfa_startnode_def quantify_nfa_def split_beta)"], ["proof (state)\nthis:\n  ((\\<Union>bs\\<in>{bs. length bs = length bss}.\n       set_of_bv (snd A) \\<inter>\n       set_of_bv\n        (nfa_steps A (nfa_startnode (quantify_nfa i A))\n          (insertll i bs bss))) \\<noteq>\n   {}) =\n  (\\<exists>bs\\<in>{bs. length bs = length bss}.\n      set_of_bv (snd A) \\<inter>\n      set_of_bv (nfa_steps A (nfa_startnode A) (insertll i bs bss)) \\<noteq>\n      {})\n\ngoal (1 subgoal):\n 1. nfa_accepts (quantify_nfa i A) bss =\n    (\\<exists>bs.\n        nfa_accepts A (insertll i bs bss) \\<and> length bs = length bss)", "also"], ["proof (state)\nthis:\n  ((\\<Union>bs\\<in>{bs. length bs = length bss}.\n       set_of_bv (snd A) \\<inter>\n       set_of_bv\n        (nfa_steps A (nfa_startnode (quantify_nfa i A))\n          (insertll i bs bss))) \\<noteq>\n   {}) =\n  (\\<exists>bs\\<in>{bs. length bs = length bss}.\n      set_of_bv (snd A) \\<inter>\n      set_of_bv (nfa_steps A (nfa_startnode A) (insertll i bs bss)) \\<noteq>\n      {})\n\ngoal (1 subgoal):\n 1. nfa_accepts (quantify_nfa i A) bss =\n    (\\<exists>bs.\n        nfa_accepts A (insertll i bs bss) \\<and> length bs = length bss)", "have \"\\<dots> = (\\<exists>bs. nfa_accepts A (insertll i bs bss) \\<and> length bs = length bss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>bs\\<in>{bs. length bs = length bss}.\n        set_of_bv (snd A) \\<inter>\n        set_of_bv\n         (nfa_steps A (nfa_startnode A) (insertll i bs bss)) \\<noteq>\n        {}) =\n    (\\<exists>bs.\n        nfa_accepts A (insertll i bs bss) \\<and> length bs = length bss)", "by (auto simp: accepts_def nfa_accepting_set_of_bv)"], ["proof (state)\nthis:\n  (\\<exists>bs\\<in>{bs. length bs = length bss}.\n      set_of_bv (snd A) \\<inter>\n      set_of_bv (nfa_steps A (nfa_startnode A) (insertll i bs bss)) \\<noteq>\n      {}) =\n  (\\<exists>bs.\n      nfa_accepts A (insertll i bs bss) \\<and> length bs = length bss)\n\ngoal (1 subgoal):\n 1. nfa_accepts (quantify_nfa i A) bss =\n    (\\<exists>bs.\n        nfa_accepts A (insertll i bs bss) \\<and> length bs = length bss)", "finally"], ["proof (chain)\npicking this:\n  nfa_accepts (quantify_nfa i A) bss =\n  (\\<exists>bs.\n      nfa_accepts A (insertll i bs bss) \\<and> length bs = length bss)", "show ?thesis"], ["proof (prove)\nusing this:\n  nfa_accepts (quantify_nfa i A) bss =\n  (\\<exists>bs.\n      nfa_accepts A (insertll i bs bss) \\<and> length bs = length bss)\n\ngoal (1 subgoal):\n 1. nfa_accepts (quantify_nfa i A) bss =\n    (\\<exists>bs.\n        nfa_accepts A (insertll i bs bss) \\<and> length bs = length bss)", "."], ["proof (state)\nthis:\n  nfa_accepts (quantify_nfa i A) bss =\n  (\\<exists>bs.\n      nfa_accepts A (insertll i bs bss) \\<and> length bs = length bss)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Right Quotient\\<close>"], ["", "definition\n  rquot_succs :: \"nat bdd list \\<times> bool list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat list\" where\n  \"rquot_succs M = (\\<lambda>n x. [bdd_lookup (fst M ! x) (replicate n False)])\""], ["", "definition\n  rquot_invariant :: \"nat bdd list \\<times> bool list \\<Rightarrow> bool list \\<Rightarrow> bool\" where\n  \"rquot_invariant M = (\\<lambda>l. length l = length (fst M))\""], ["", "definition\n  \"rquot_ins = (\\<lambda>x l. l[x:=True])\""], ["", "definition\n  rquot_memb :: \"nat \\<Rightarrow> bool list \\<Rightarrow> bool\" where\n  \"rquot_memb = (\\<lambda>x l. l ! x)\""], ["", "definition\n  rquot_empt :: \"nat bdd list \\<times> bool list \\<Rightarrow> bool list\" where\n  \"rquot_empt M = replicate (length (fst M)) False\""], ["", "definition \n  \"rquot_dfs M n x = gen_dfs (rquot_succs M n) rquot_ins rquot_memb (rquot_empt M) [x]\""], ["", "definition\n  zeros :: \"nat \\<Rightarrow> nat \\<Rightarrow> bool list list\" where\n  \"zeros m n = replicate m (replicate n False)\""], ["", "lemma zeros_is_alpha: \"list_all (is_alph v) (zeros n v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (is_alph v) (zeros n v)", "by (induct n) (simp add: zeros_def is_alph_def)+"], ["", "lemma zeros_rone: \"zeros (Suc n) v = zeros n v @ zeros 1 v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zeros (Suc n) v = zeros n v @ zeros 1 v", "by (simp add: zeros_def replicate_append_same)"], ["", "lemma zeros_len: \"length (zeros n v) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (zeros n v) = n", "by (simp add: zeros_def)"], ["", "lemma zeros_rtrancl: \"(\\<exists>n. dfa_reach M x (zeros n v) y) = ((x,y) \\<in> (succsr (rquot_succs M v))\\<^sup>*)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>n. dfa_reach M x (zeros n v) y) =\n    ((x, y) \\<in> (succsr (rquot_succs M v))\\<^sup>*)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>n. dfa_reach M x (zeros n v) y \\<Longrightarrow>\n    (x, y) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n 2. (x, y) \\<in> (succsr (rquot_succs M v))\\<^sup>* \\<Longrightarrow>\n    \\<exists>n. dfa_reach M x (zeros n v) y", "assume \"\\<exists>n. dfa_reach M x (zeros n v) y\""], ["proof (state)\nthis:\n  \\<exists>n. dfa_reach M x (zeros n v) y\n\ngoal (2 subgoals):\n 1. \\<exists>n. dfa_reach M x (zeros n v) y \\<Longrightarrow>\n    (x, y) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n 2. (x, y) \\<in> (succsr (rquot_succs M v))\\<^sup>* \\<Longrightarrow>\n    \\<exists>n. dfa_reach M x (zeros n v) y", "then"], ["proof (chain)\npicking this:\n  \\<exists>n. dfa_reach M x (zeros n v) y", "obtain n where N: \"dfa_reach M x (zeros n v) y\""], ["proof (prove)\nusing this:\n  \\<exists>n. dfa_reach M x (zeros n v) y\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        dfa_reach M x (zeros n v) y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  dfa_reach M x (zeros n v) y\n\ngoal (2 subgoals):\n 1. \\<exists>n. dfa_reach M x (zeros n v) y \\<Longrightarrow>\n    (x, y) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n 2. (x, y) \\<in> (succsr (rquot_succs M v))\\<^sup>* \\<Longrightarrow>\n    \\<exists>n. dfa_reach M x (zeros n v) y", "define w where \"w = zeros n v\""], ["proof (state)\nthis:\n  w = zeros n v\n\ngoal (2 subgoals):\n 1. \\<exists>n. dfa_reach M x (zeros n v) y \\<Longrightarrow>\n    (x, y) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n 2. (x, y) \\<in> (succsr (rquot_succs M v))\\<^sup>* \\<Longrightarrow>\n    \\<exists>n. dfa_reach M x (zeros n v) y", "hence W: \"\\<exists>n. w = zeros n v\""], ["proof (prove)\nusing this:\n  w = zeros n v\n\ngoal (1 subgoal):\n 1. \\<exists>n. w = zeros n v", "by auto"], ["proof (state)\nthis:\n  \\<exists>n. w = zeros n v\n\ngoal (2 subgoals):\n 1. \\<exists>n. dfa_reach M x (zeros n v) y \\<Longrightarrow>\n    (x, y) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n 2. (x, y) \\<in> (succsr (rquot_succs M v))\\<^sup>* \\<Longrightarrow>\n    \\<exists>n. dfa_reach M x (zeros n v) y", "from w_def N"], ["proof (chain)\npicking this:\n  w = zeros n v\n  dfa_reach M x (zeros n v) y", "have \"dfa_reach M x w y\""], ["proof (prove)\nusing this:\n  w = zeros n v\n  dfa_reach M x (zeros n v) y\n\ngoal (1 subgoal):\n 1. dfa_reach M x w y", "by simp"], ["proof (state)\nthis:\n  dfa_reach M x w y\n\ngoal (2 subgoals):\n 1. \\<exists>n. dfa_reach M x (zeros n v) y \\<Longrightarrow>\n    (x, y) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n 2. (x, y) \\<in> (succsr (rquot_succs M v))\\<^sup>* \\<Longrightarrow>\n    \\<exists>n. dfa_reach M x (zeros n v) y", "from this W"], ["proof (chain)\npicking this:\n  dfa_reach M x w y\n  \\<exists>n. w = zeros n v", "show \"(x,y) \\<in> (succsr (rquot_succs M v))\\<^sup>*\""], ["proof (prove)\nusing this:\n  dfa_reach M x w y\n  \\<exists>n. w = zeros n v\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (succsr (rquot_succs M v))\\<^sup>*", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>n. [] = zeros n v \\<Longrightarrow>\n    (x, x) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n 2. \\<And>k xa y.\n       \\<lbrakk>dfa_reach M x xa k;\n        \\<exists>n. xa = zeros n v \\<Longrightarrow>\n        (x, k) \\<in> (succsr (rquot_succs M v))\\<^sup>*;\n        \\<exists>n. xa @ [y] = zeros n v\\<rbrakk>\n       \\<Longrightarrow> (x, dfa_trans M k y)\n                         \\<in> (succsr (rquot_succs M v))\\<^sup>*", "case (snoc k ws y)"], ["proof (state)\nthis:\n  dfa_reach M x ws k\n  \\<exists>n. ws = zeros n v \\<Longrightarrow>\n  (x, k) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n  \\<exists>n. ws @ [y] = zeros n v\n\ngoal (2 subgoals):\n 1. \\<exists>n. [] = zeros n v \\<Longrightarrow>\n    (x, x) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n 2. \\<And>k xa y.\n       \\<lbrakk>dfa_reach M x xa k;\n        \\<exists>n. xa = zeros n v \\<Longrightarrow>\n        (x, k) \\<in> (succsr (rquot_succs M v))\\<^sup>*;\n        \\<exists>n. xa @ [y] = zeros n v\\<rbrakk>\n       \\<Longrightarrow> (x, dfa_trans M k y)\n                         \\<in> (succsr (rquot_succs M v))\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  dfa_reach M x ws k\n  \\<exists>n. ws = zeros n v \\<Longrightarrow>\n  (x, k) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n  \\<exists>n. ws @ [y] = zeros n v", "obtain n' where N': \"ws @ [y] = zeros n' v\""], ["proof (prove)\nusing this:\n  dfa_reach M x ws k\n  \\<exists>n. ws = zeros n v \\<Longrightarrow>\n  (x, k) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n  \\<exists>n. ws @ [y] = zeros n v\n\ngoal (1 subgoal):\n 1. (\\<And>n'.\n        ws @ [y] = zeros n' v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ws @ [y] = zeros n' v\n\ngoal (2 subgoals):\n 1. \\<exists>n. [] = zeros n v \\<Longrightarrow>\n    (x, x) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n 2. \\<And>k xa y.\n       \\<lbrakk>dfa_reach M x xa k;\n        \\<exists>n. xa = zeros n v \\<Longrightarrow>\n        (x, k) \\<in> (succsr (rquot_succs M v))\\<^sup>*;\n        \\<exists>n. xa @ [y] = zeros n v\\<rbrakk>\n       \\<Longrightarrow> (x, dfa_trans M k y)\n                         \\<in> (succsr (rquot_succs M v))\\<^sup>*", "have \"length (ws @ [y]) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length (ws @ [y])", "by simp"], ["proof (state)\nthis:\n  0 < length (ws @ [y])\n\ngoal (2 subgoals):\n 1. \\<exists>n. [] = zeros n v \\<Longrightarrow>\n    (x, x) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n 2. \\<And>k xa y.\n       \\<lbrakk>dfa_reach M x xa k;\n        \\<exists>n. xa = zeros n v \\<Longrightarrow>\n        (x, k) \\<in> (succsr (rquot_succs M v))\\<^sup>*;\n        \\<exists>n. xa @ [y] = zeros n v\\<rbrakk>\n       \\<Longrightarrow> (x, dfa_trans M k y)\n                         \\<in> (succsr (rquot_succs M v))\\<^sup>*", "with N'"], ["proof (chain)\npicking this:\n  ws @ [y] = zeros n' v\n  0 < length (ws @ [y])", "have \"n' > 0\""], ["proof (prove)\nusing this:\n  ws @ [y] = zeros n' v\n  0 < length (ws @ [y])\n\ngoal (1 subgoal):\n 1. 0 < n'", "by (simp add: zeros_len)"], ["proof (state)\nthis:\n  0 < n'\n\ngoal (2 subgoals):\n 1. \\<exists>n. [] = zeros n v \\<Longrightarrow>\n    (x, x) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n 2. \\<And>k xa y.\n       \\<lbrakk>dfa_reach M x xa k;\n        \\<exists>n. xa = zeros n v \\<Longrightarrow>\n        (x, k) \\<in> (succsr (rquot_succs M v))\\<^sup>*;\n        \\<exists>n. xa @ [y] = zeros n v\\<rbrakk>\n       \\<Longrightarrow> (x, dfa_trans M k y)\n                         \\<in> (succsr (rquot_succs M v))\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  0 < n'", "obtain n where NL: \"n' = Suc n\""], ["proof (prove)\nusing this:\n  0 < n'\n\ngoal (1 subgoal):\n 1. (\\<And>n. n' = Suc n \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases n') simp+"], ["proof (state)\nthis:\n  n' = Suc n\n\ngoal (2 subgoals):\n 1. \\<exists>n. [] = zeros n v \\<Longrightarrow>\n    (x, x) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n 2. \\<And>k xa y.\n       \\<lbrakk>dfa_reach M x xa k;\n        \\<exists>n. xa = zeros n v \\<Longrightarrow>\n        (x, k) \\<in> (succsr (rquot_succs M v))\\<^sup>*;\n        \\<exists>n. xa @ [y] = zeros n v\\<rbrakk>\n       \\<Longrightarrow> (x, dfa_trans M k y)\n                         \\<in> (succsr (rquot_succs M v))\\<^sup>*", "hence \"zeros n' v = zeros n v @ zeros 1 v\""], ["proof (prove)\nusing this:\n  n' = Suc n\n\ngoal (1 subgoal):\n 1. zeros n' v = zeros n v @ zeros 1 v", "by (simp only: zeros_rone)"], ["proof (state)\nthis:\n  zeros n' v = zeros n v @ zeros 1 v\n\ngoal (2 subgoals):\n 1. \\<exists>n. [] = zeros n v \\<Longrightarrow>\n    (x, x) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n 2. \\<And>k xa y.\n       \\<lbrakk>dfa_reach M x xa k;\n        \\<exists>n. xa = zeros n v \\<Longrightarrow>\n        (x, k) \\<in> (succsr (rquot_succs M v))\\<^sup>*;\n        \\<exists>n. xa @ [y] = zeros n v\\<rbrakk>\n       \\<Longrightarrow> (x, dfa_trans M k y)\n                         \\<in> (succsr (rquot_succs M v))\\<^sup>*", "also"], ["proof (state)\nthis:\n  zeros n' v = zeros n v @ zeros 1 v\n\ngoal (2 subgoals):\n 1. \\<exists>n. [] = zeros n v \\<Longrightarrow>\n    (x, x) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n 2. \\<And>k xa y.\n       \\<lbrakk>dfa_reach M x xa k;\n        \\<exists>n. xa = zeros n v \\<Longrightarrow>\n        (x, k) \\<in> (succsr (rquot_succs M v))\\<^sup>*;\n        \\<exists>n. xa @ [y] = zeros n v\\<rbrakk>\n       \\<Longrightarrow> (x, dfa_trans M k y)\n                         \\<in> (succsr (rquot_succs M v))\\<^sup>*", "have \"\\<dots> = zeros n v @ [replicate v False]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zeros n v @ zeros 1 v = zeros n v @ [replicate v False]", "by (simp add: zeros_def)"], ["proof (state)\nthis:\n  zeros n v @ zeros 1 v = zeros n v @ [replicate v False]\n\ngoal (2 subgoals):\n 1. \\<exists>n. [] = zeros n v \\<Longrightarrow>\n    (x, x) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n 2. \\<And>k xa y.\n       \\<lbrakk>dfa_reach M x xa k;\n        \\<exists>n. xa = zeros n v \\<Longrightarrow>\n        (x, k) \\<in> (succsr (rquot_succs M v))\\<^sup>*;\n        \\<exists>n. xa @ [y] = zeros n v\\<rbrakk>\n       \\<Longrightarrow> (x, dfa_trans M k y)\n                         \\<in> (succsr (rquot_succs M v))\\<^sup>*", "finally"], ["proof (chain)\npicking this:\n  zeros n' v = zeros n v @ [replicate v False]", "have \"zeros n' v = zeros n v @ [replicate v False]\""], ["proof (prove)\nusing this:\n  zeros n' v = zeros n v @ [replicate v False]\n\ngoal (1 subgoal):\n 1. zeros n' v = zeros n v @ [replicate v False]", "."], ["proof (state)\nthis:\n  zeros n' v = zeros n v @ [replicate v False]\n\ngoal (2 subgoals):\n 1. \\<exists>n. [] = zeros n v \\<Longrightarrow>\n    (x, x) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n 2. \\<And>k xa y.\n       \\<lbrakk>dfa_reach M x xa k;\n        \\<exists>n. xa = zeros n v \\<Longrightarrow>\n        (x, k) \\<in> (succsr (rquot_succs M v))\\<^sup>*;\n        \\<exists>n. xa @ [y] = zeros n v\\<rbrakk>\n       \\<Longrightarrow> (x, dfa_trans M k y)\n                         \\<in> (succsr (rquot_succs M v))\\<^sup>*", "with N'"], ["proof (chain)\npicking this:\n  ws @ [y] = zeros n' v\n  zeros n' v = zeros n v @ [replicate v False]", "have WS: \"ws = zeros n v\" \"y = replicate v False\""], ["proof (prove)\nusing this:\n  ws @ [y] = zeros n' v\n  zeros n' v = zeros n v @ [replicate v False]\n\ngoal (1 subgoal):\n 1. ws = zeros n v &&& y = replicate v False", "by auto"], ["proof (state)\nthis:\n  ws = zeros n v\n  y = replicate v False\n\ngoal (2 subgoals):\n 1. \\<exists>n. [] = zeros n v \\<Longrightarrow>\n    (x, x) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n 2. \\<And>k xa y.\n       \\<lbrakk>dfa_reach M x xa k;\n        \\<exists>n. xa = zeros n v \\<Longrightarrow>\n        (x, k) \\<in> (succsr (rquot_succs M v))\\<^sup>*;\n        \\<exists>n. xa @ [y] = zeros n v\\<rbrakk>\n       \\<Longrightarrow> (x, dfa_trans M k y)\n                         \\<in> (succsr (rquot_succs M v))\\<^sup>*", "hence \"\\<exists>n. ws = zeros n v\""], ["proof (prove)\nusing this:\n  ws = zeros n v\n  y = replicate v False\n\ngoal (1 subgoal):\n 1. \\<exists>n. ws = zeros n v", "by auto"], ["proof (state)\nthis:\n  \\<exists>n. ws = zeros n v\n\ngoal (2 subgoals):\n 1. \\<exists>n. [] = zeros n v \\<Longrightarrow>\n    (x, x) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n 2. \\<And>k xa y.\n       \\<lbrakk>dfa_reach M x xa k;\n        \\<exists>n. xa = zeros n v \\<Longrightarrow>\n        (x, k) \\<in> (succsr (rquot_succs M v))\\<^sup>*;\n        \\<exists>n. xa @ [y] = zeros n v\\<rbrakk>\n       \\<Longrightarrow> (x, dfa_trans M k y)\n                         \\<in> (succsr (rquot_succs M v))\\<^sup>*", "with snoc"], ["proof (chain)\npicking this:\n  dfa_reach M x ws k\n  \\<exists>n. ws = zeros n v \\<Longrightarrow>\n  (x, k) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n  \\<exists>n. ws @ [y] = zeros n v\n  \\<exists>n. ws = zeros n v", "have IV: \"(x,k) \\<in> (succsr (rquot_succs M v))\\<^sup>*\""], ["proof (prove)\nusing this:\n  dfa_reach M x ws k\n  \\<exists>n. ws = zeros n v \\<Longrightarrow>\n  (x, k) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n  \\<exists>n. ws @ [y] = zeros n v\n  \\<exists>n. ws = zeros n v\n\ngoal (1 subgoal):\n 1. (x, k) \\<in> (succsr (rquot_succs M v))\\<^sup>*", "by simp"], ["proof (state)\nthis:\n  (x, k) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n\ngoal (2 subgoals):\n 1. \\<exists>n. [] = zeros n v \\<Longrightarrow>\n    (x, x) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n 2. \\<And>k xa y.\n       \\<lbrakk>dfa_reach M x xa k;\n        \\<exists>n. xa = zeros n v \\<Longrightarrow>\n        (x, k) \\<in> (succsr (rquot_succs M v))\\<^sup>*;\n        \\<exists>n. xa @ [y] = zeros n v\\<rbrakk>\n       \\<Longrightarrow> (x, dfa_trans M k y)\n                         \\<in> (succsr (rquot_succs M v))\\<^sup>*", "from WS"], ["proof (chain)\npicking this:\n  ws = zeros n v\n  y = replicate v False", "have \"dfa_trans M k y \\<in> set (rquot_succs M v k)\""], ["proof (prove)\nusing this:\n  ws = zeros n v\n  y = replicate v False\n\ngoal (1 subgoal):\n 1. dfa_trans M k y \\<in> set (rquot_succs M v k)", "by (simp add: rquot_succs_def dfa_trans_def)"], ["proof (state)\nthis:\n  dfa_trans M k y \\<in> set (rquot_succs M v k)\n\ngoal (2 subgoals):\n 1. \\<exists>n. [] = zeros n v \\<Longrightarrow>\n    (x, x) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n 2. \\<And>k xa y.\n       \\<lbrakk>dfa_reach M x xa k;\n        \\<exists>n. xa = zeros n v \\<Longrightarrow>\n        (x, k) \\<in> (succsr (rquot_succs M v))\\<^sup>*;\n        \\<exists>n. xa @ [y] = zeros n v\\<rbrakk>\n       \\<Longrightarrow> (x, dfa_trans M k y)\n                         \\<in> (succsr (rquot_succs M v))\\<^sup>*", "hence \"(k, dfa_trans M k y) \\<in> (succsr (rquot_succs M v))\\<^sup>*\""], ["proof (prove)\nusing this:\n  dfa_trans M k y \\<in> set (rquot_succs M v k)\n\ngoal (1 subgoal):\n 1. (k, dfa_trans M k y) \\<in> (succsr (rquot_succs M v))\\<^sup>*", "by (auto simp: succsr_def)"], ["proof (state)\nthis:\n  (k, dfa_trans M k y) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n\ngoal (2 subgoals):\n 1. \\<exists>n. [] = zeros n v \\<Longrightarrow>\n    (x, x) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n 2. \\<And>k xa y.\n       \\<lbrakk>dfa_reach M x xa k;\n        \\<exists>n. xa = zeros n v \\<Longrightarrow>\n        (x, k) \\<in> (succsr (rquot_succs M v))\\<^sup>*;\n        \\<exists>n. xa @ [y] = zeros n v\\<rbrakk>\n       \\<Longrightarrow> (x, dfa_trans M k y)\n                         \\<in> (succsr (rquot_succs M v))\\<^sup>*", "with IV"], ["proof (chain)\npicking this:\n  (x, k) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n  (k, dfa_trans M k y) \\<in> (succsr (rquot_succs M v))\\<^sup>*", "show ?case"], ["proof (prove)\nusing this:\n  (x, k) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n  (k, dfa_trans M k y) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (x, dfa_trans M k y) \\<in> (succsr (rquot_succs M v))\\<^sup>*", "by simp"], ["proof (state)\nthis:\n  (x, dfa_trans M k y) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<exists>n. [] = zeros n v \\<Longrightarrow>\n    (x, x) \\<in> (succsr (rquot_succs M v))\\<^sup>*", "qed simp"], ["proof (state)\nthis:\n  (x, y) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (succsr (rquot_succs M v))\\<^sup>* \\<Longrightarrow>\n    \\<exists>n. dfa_reach M x (zeros n v) y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (x, y) \\<in> (succsr (rquot_succs M v))\\<^sup>* \\<Longrightarrow>\n    \\<exists>n. dfa_reach M x (zeros n v) y", "assume \"(x,y) \\<in> (succsr (rquot_succs M v))\\<^sup>*\""], ["proof (state)\nthis:\n  (x, y) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (succsr (rquot_succs M v))\\<^sup>* \\<Longrightarrow>\n    \\<exists>n. dfa_reach M x (zeros n v) y", "thus \"\\<exists>n. dfa_reach M x (zeros n v) y\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<exists>n. dfa_reach M x (zeros n v) y", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>n. dfa_reach M x (zeros n v) x\n 2. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> (succsr (rquot_succs M v))\\<^sup>*;\n        (y, z) \\<in> succsr (rquot_succs M v);\n        \\<exists>n. dfa_reach M x (zeros n v) y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. dfa_reach M x (zeros n v) z", "case base"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<exists>n. dfa_reach M x (zeros n v) x\n 2. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> (succsr (rquot_succs M v))\\<^sup>*;\n        (y, z) \\<in> succsr (rquot_succs M v);\n        \\<exists>n. dfa_reach M x (zeros n v) y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. dfa_reach M x (zeros n v) z", "have \"dfa_reach M x (zeros 0 v) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa_reach M x (zeros 0 v) x", "by (simp add: reach_nil zeros_def)"], ["proof (state)\nthis:\n  dfa_reach M x (zeros 0 v) x\n\ngoal (2 subgoals):\n 1. \\<exists>n. dfa_reach M x (zeros n v) x\n 2. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> (succsr (rquot_succs M v))\\<^sup>*;\n        (y, z) \\<in> succsr (rquot_succs M v);\n        \\<exists>n. dfa_reach M x (zeros n v) y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. dfa_reach M x (zeros n v) z", "thus \"\\<exists>n. dfa_reach M x (zeros n v) x\""], ["proof (prove)\nusing this:\n  dfa_reach M x (zeros 0 v) x\n\ngoal (1 subgoal):\n 1. \\<exists>n. dfa_reach M x (zeros n v) x", "by (rule exI)"], ["proof (state)\nthis:\n  \\<exists>n. dfa_reach M x (zeros n v) x\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> (succsr (rquot_succs M v))\\<^sup>*;\n        (y, z) \\<in> succsr (rquot_succs M v);\n        \\<exists>n. dfa_reach M x (zeros n v) y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. dfa_reach M x (zeros n v) z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> (succsr (rquot_succs M v))\\<^sup>*;\n        (y, z) \\<in> succsr (rquot_succs M v);\n        \\<exists>n. dfa_reach M x (zeros n v) y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. dfa_reach M x (zeros n v) z", "case (step y z)"], ["proof (state)\nthis:\n  (x, y) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n  (y, z) \\<in> succsr (rquot_succs M v)\n  \\<exists>n. dfa_reach M x (zeros n v) y\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> (succsr (rquot_succs M v))\\<^sup>*;\n        (y, z) \\<in> succsr (rquot_succs M v);\n        \\<exists>n. dfa_reach M x (zeros n v) y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. dfa_reach M x (zeros n v) z", "then"], ["proof (chain)\npicking this:\n  (x, y) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n  (y, z) \\<in> succsr (rquot_succs M v)\n  \\<exists>n. dfa_reach M x (zeros n v) y", "obtain n where N: \"dfa_reach M x (zeros n v) y\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n  (y, z) \\<in> succsr (rquot_succs M v)\n  \\<exists>n. dfa_reach M x (zeros n v) y\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        dfa_reach M x (zeros n v) y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  dfa_reach M x (zeros n v) y\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> (succsr (rquot_succs M v))\\<^sup>*;\n        (y, z) \\<in> succsr (rquot_succs M v);\n        \\<exists>n. dfa_reach M x (zeros n v) y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. dfa_reach M x (zeros n v) z", "with step"], ["proof (chain)\npicking this:\n  (x, y) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n  (y, z) \\<in> succsr (rquot_succs M v)\n  \\<exists>n. dfa_reach M x (zeros n v) y\n  dfa_reach M x (zeros n v) y", "have Z: \"z = dfa_trans M y (replicate v False)\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> (succsr (rquot_succs M v))\\<^sup>*\n  (y, z) \\<in> succsr (rquot_succs M v)\n  \\<exists>n. dfa_reach M x (zeros n v) y\n  dfa_reach M x (zeros n v) y\n\ngoal (1 subgoal):\n 1. z = dfa_trans M y (replicate v False)", "by (simp add: succsr_def rquot_succs_def dfa_trans_def)"], ["proof (state)\nthis:\n  z = dfa_trans M y (replicate v False)\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> (succsr (rquot_succs M v))\\<^sup>*;\n        (y, z) \\<in> succsr (rquot_succs M v);\n        \\<exists>n. dfa_reach M x (zeros n v) y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. dfa_reach M x (zeros n v) z", "from N Z"], ["proof (chain)\npicking this:\n  dfa_reach M x (zeros n v) y\n  z = dfa_trans M y (replicate v False)", "have \"dfa_reach M x (zeros n v @ zeros 1 v) z\""], ["proof (prove)\nusing this:\n  dfa_reach M x (zeros n v) y\n  z = dfa_trans M y (replicate v False)\n\ngoal (1 subgoal):\n 1. dfa_reach M x (zeros n v @ zeros 1 v) z", "by (simp add: reach_snoc zeros_def)"], ["proof (state)\nthis:\n  dfa_reach M x (zeros n v @ zeros 1 v) z\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> (succsr (rquot_succs M v))\\<^sup>*;\n        (y, z) \\<in> succsr (rquot_succs M v);\n        \\<exists>n. dfa_reach M x (zeros n v) y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. dfa_reach M x (zeros n v) z", "hence \"dfa_reach M x (zeros (Suc n) v) z\""], ["proof (prove)\nusing this:\n  dfa_reach M x (zeros n v @ zeros 1 v) z\n\ngoal (1 subgoal):\n 1. dfa_reach M x (zeros (Suc n) v) z", "by (simp only: zeros_rone)"], ["proof (state)\nthis:\n  dfa_reach M x (zeros (Suc n) v) z\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> (succsr (rquot_succs M v))\\<^sup>*;\n        (y, z) \\<in> succsr (rquot_succs M v);\n        \\<exists>n. dfa_reach M x (zeros n v) y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. dfa_reach M x (zeros n v) z", "thus ?case"], ["proof (prove)\nusing this:\n  dfa_reach M x (zeros (Suc n) v) z\n\ngoal (1 subgoal):\n 1. \\<exists>n. dfa_reach M x (zeros n v) z", "by (rule exI)"], ["proof (state)\nthis:\n  \\<exists>n. dfa_reach M x (zeros n v) z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>n. dfa_reach M x (zeros n v) y\n\ngoal:\nNo subgoals!", "qed"], ["", "primrec map_index :: \"('a \\<Rightarrow> nat \\<Rightarrow> 'b) \\<Rightarrow> 'a list \\<Rightarrow> nat \\<Rightarrow> 'b list\"\nwhere\n  \"map_index f [] n = []\"\n| \"map_index f (x#xs) n = f x n # map_index f xs (Suc n)\""], ["", "lemma map_index_len:\n  \"length (map_index f ls n) = length ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map_index f ls n) = length ls", "by (induct ls arbitrary: n) simp+"], ["", "lemma map_index_nth:\n  assumes \"i < length l\"\n  shows \"map_index f l n ! i = f (l ! i) (n + i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_index f l n ! i = f (l ! i) (n + i)", "using assms"], ["proof (prove)\nusing this:\n  i < length l\n\ngoal (1 subgoal):\n 1. map_index f l n ! i = f (l ! i) (n + i)", "proof (induct l arbitrary: n i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n i.\n       i < length [] \\<Longrightarrow>\n       map_index f [] n ! i = f ([] ! i) (n + i)\n 2. \\<And>a l n i.\n       \\<lbrakk>\\<And>n i.\n                   i < length l \\<Longrightarrow>\n                   map_index f l n ! i = f (l ! i) (n + i);\n        i < length (a # l)\\<rbrakk>\n       \\<Longrightarrow> map_index f (a # l) n ! i = f ((a # l) ! i) (n + i)", "case (Cons a l n i)"], ["proof (state)\nthis:\n  ?i < length l \\<Longrightarrow>\n  map_index f l ?n ! ?i = f (l ! ?i) (?n + ?i)\n  i < length (a # l)\n\ngoal (2 subgoals):\n 1. \\<And>n i.\n       i < length [] \\<Longrightarrow>\n       map_index f [] n ! i = f ([] ! i) (n + i)\n 2. \\<And>a l n i.\n       \\<lbrakk>\\<And>n i.\n                   i < length l \\<Longrightarrow>\n                   map_index f l n ! i = f (l ! i) (n + i);\n        i < length (a # l)\\<rbrakk>\n       \\<Longrightarrow> map_index f (a # l) n ! i = f ((a # l) ! i) (n + i)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_index f (a # l) n ! i = f ((a # l) ! i) (n + i)", "proof (cases \"i = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    map_index f (a # l) n ! i = f ((a # l) ! i) (n + i)\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    map_index f (a # l) n ! i = f ((a # l) ! i) (n + i)", "case False"], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    map_index f (a # l) n ! i = f ((a # l) ! i) (n + i)\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    map_index f (a # l) n ! i = f ((a # l) ! i) (n + i)", "then"], ["proof (chain)\npicking this:\n  i \\<noteq> 0", "obtain j where J: \"i = Suc j\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>j. i = Suc j \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases i) simp+"], ["proof (state)\nthis:\n  i = Suc j\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    map_index f (a # l) n ! i = f ((a # l) ! i) (n + i)\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    map_index f (a # l) n ! i = f ((a # l) ! i) (n + i)", "with Cons"], ["proof (chain)\npicking this:\n  ?i < length l \\<Longrightarrow>\n  map_index f l ?n ! ?i = f (l ! ?i) (?n + ?i)\n  i < length (a # l)\n  i = Suc j", "show ?thesis"], ["proof (prove)\nusing this:\n  ?i < length l \\<Longrightarrow>\n  map_index f l ?n ! ?i = f (l ! ?i) (?n + ?i)\n  i < length (a # l)\n  i = Suc j\n\ngoal (1 subgoal):\n 1. map_index f (a # l) n ! i = f ((a # l) ! i) (n + i)", "by simp"], ["proof (state)\nthis:\n  map_index f (a # l) n ! i = f ((a # l) ! i) (n + i)\n\ngoal (1 subgoal):\n 1. i = 0 \\<Longrightarrow>\n    map_index f (a # l) n ! i = f ((a # l) ! i) (n + i)", "qed simp"], ["proof (state)\nthis:\n  map_index f (a # l) n ! i = f ((a # l) ! i) (n + i)\n\ngoal (1 subgoal):\n 1. \\<And>n i.\n       i < length [] \\<Longrightarrow>\n       map_index f [] n ! i = f ([] ! i) (n + i)", "qed simp"], ["", "definition\n  rquot :: \"dfa \\<Rightarrow> nat \\<Rightarrow> dfa\" where\n  \"rquot = (\\<lambda>(bd, as) v. (bd, map_index (\\<lambda>x n. nfa_accepting' as (rquot_dfs (bd, as) v n)) as 0))\""], ["", "lemma rquot_well_formed_aut:\n  assumes \"wf_dfa M n\"\n  shows \"wf_dfa (rquot M n) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_dfa (rquot M n) n", "using assms"], ["proof (prove)\nusing this:\n  wf_dfa M n\n\ngoal (1 subgoal):\n 1. wf_dfa (rquot M n) n", "by (simp add: rquot_def split_beta wf_dfa_def map_index_len dfa_is_node_def)"], ["", "lemma rquot_node:\n  \"dfa_is_node (rquot M n) q = dfa_is_node M q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa_is_node (rquot M n) q = dfa_is_node M q", "by (simp add: rquot_def dfa_is_node_def split_beta)"], ["", "lemma rquot_steps:\n  \"dfa_steps (rquot M n) x w = dfa_steps M x w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa_steps (rquot M n) x w = dfa_steps M x w", "by (simp add: rquot_def dfa_trans_def [abs_def] split_beta)"], ["", "locale rquot_DFS =\n  fixes A :: dfa and n :: nat\n  assumes well_formed: \"wf_dfa A n\""], ["", "sublocale rquot_DFS < DFS \"rquot_succs A n\" \"dfa_is_node A\"\n  \"rquot_invariant A\" rquot_ins rquot_memb \"rquot_empt A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DFS (rquot_succs A n) (dfa_is_node A) (rquot_invariant A) rquot_ins\n     rquot_memb (rquot_empt A)", "proof (insert well_formed, unfold_locales)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x y S.\n       \\<lbrakk>wf_dfa A n; dfa_is_node A x; dfa_is_node A y;\n        rquot_invariant A S; \\<not> rquot_memb y S\\<rbrakk>\n       \\<Longrightarrow> rquot_memb x (rquot_ins y S) =\n                         (x = y \\<or> rquot_memb x S)\n 2. \\<And>x.\n       \\<lbrakk>wf_dfa A n; dfa_is_node A x\\<rbrakk>\n       \\<Longrightarrow> \\<not> rquot_memb x (rquot_empt A)\n 3. \\<And>x.\n       \\<lbrakk>wf_dfa A n; dfa_is_node A x\\<rbrakk>\n       \\<Longrightarrow> list_all (dfa_is_node A) (rquot_succs A n x)\n 4. wf_dfa A n \\<Longrightarrow> rquot_invariant A (rquot_empt A)\n 5. \\<And>x S.\n       \\<lbrakk>wf_dfa A n; dfa_is_node A x; rquot_invariant A S;\n        \\<not> rquot_memb x S\\<rbrakk>\n       \\<Longrightarrow> rquot_invariant A (rquot_ins x S)\n 6. wf_dfa A n \\<Longrightarrow> finite {x. dfa_is_node A x}", "fix x y S"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x y S.\n       \\<lbrakk>wf_dfa A n; dfa_is_node A x; dfa_is_node A y;\n        rquot_invariant A S; \\<not> rquot_memb y S\\<rbrakk>\n       \\<Longrightarrow> rquot_memb x (rquot_ins y S) =\n                         (x = y \\<or> rquot_memb x S)\n 2. \\<And>x.\n       \\<lbrakk>wf_dfa A n; dfa_is_node A x\\<rbrakk>\n       \\<Longrightarrow> \\<not> rquot_memb x (rquot_empt A)\n 3. \\<And>x.\n       \\<lbrakk>wf_dfa A n; dfa_is_node A x\\<rbrakk>\n       \\<Longrightarrow> list_all (dfa_is_node A) (rquot_succs A n x)\n 4. wf_dfa A n \\<Longrightarrow> rquot_invariant A (rquot_empt A)\n 5. \\<And>x S.\n       \\<lbrakk>wf_dfa A n; dfa_is_node A x; rquot_invariant A S;\n        \\<not> rquot_memb x S\\<rbrakk>\n       \\<Longrightarrow> rquot_invariant A (rquot_ins x S)\n 6. wf_dfa A n \\<Longrightarrow> finite {x. dfa_is_node A x}", "assume \"dfa_is_node A x\" and \"dfa_is_node A y\" and \"rquot_invariant A S\" and \"\\<not> rquot_memb y S\""], ["proof (state)\nthis:\n  dfa_is_node A x\n  dfa_is_node A y\n  rquot_invariant A S\n  \\<not> rquot_memb y S\n\ngoal (6 subgoals):\n 1. \\<And>x y S.\n       \\<lbrakk>wf_dfa A n; dfa_is_node A x; dfa_is_node A y;\n        rquot_invariant A S; \\<not> rquot_memb y S\\<rbrakk>\n       \\<Longrightarrow> rquot_memb x (rquot_ins y S) =\n                         (x = y \\<or> rquot_memb x S)\n 2. \\<And>x.\n       \\<lbrakk>wf_dfa A n; dfa_is_node A x\\<rbrakk>\n       \\<Longrightarrow> \\<not> rquot_memb x (rquot_empt A)\n 3. \\<And>x.\n       \\<lbrakk>wf_dfa A n; dfa_is_node A x\\<rbrakk>\n       \\<Longrightarrow> list_all (dfa_is_node A) (rquot_succs A n x)\n 4. wf_dfa A n \\<Longrightarrow> rquot_invariant A (rquot_empt A)\n 5. \\<And>x S.\n       \\<lbrakk>wf_dfa A n; dfa_is_node A x; rquot_invariant A S;\n        \\<not> rquot_memb x S\\<rbrakk>\n       \\<Longrightarrow> rquot_invariant A (rquot_ins x S)\n 6. wf_dfa A n \\<Longrightarrow> finite {x. dfa_is_node A x}", "thus \"rquot_memb x (rquot_ins y S) = (x = y \\<or> rquot_memb x S)\""], ["proof (prove)\nusing this:\n  dfa_is_node A x\n  dfa_is_node A y\n  rquot_invariant A S\n  \\<not> rquot_memb y S\n\ngoal (1 subgoal):\n 1. rquot_memb x (rquot_ins y S) = (x = y \\<or> rquot_memb x S)", "by (cases \"x=y\") (simp add: dfa_is_node_def rquot_invariant_def rquot_memb_def rquot_ins_def)+"], ["proof (state)\nthis:\n  rquot_memb x (rquot_ins y S) = (x = y \\<or> rquot_memb x S)\n\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>wf_dfa A n; dfa_is_node A x\\<rbrakk>\n       \\<Longrightarrow> \\<not> rquot_memb x (rquot_empt A)\n 2. \\<And>x.\n       \\<lbrakk>wf_dfa A n; dfa_is_node A x\\<rbrakk>\n       \\<Longrightarrow> list_all (dfa_is_node A) (rquot_succs A n x)\n 3. wf_dfa A n \\<Longrightarrow> rquot_invariant A (rquot_empt A)\n 4. \\<And>x S.\n       \\<lbrakk>wf_dfa A n; dfa_is_node A x; rquot_invariant A S;\n        \\<not> rquot_memb x S\\<rbrakk>\n       \\<Longrightarrow> rquot_invariant A (rquot_ins x S)\n 5. wf_dfa A n \\<Longrightarrow> finite {x. dfa_is_node A x}", "qed (simp add: dfa_is_node_def rquot_memb_def rquot_empt_def\n     rquot_succs_def rquot_invariant_def rquot_ins_def\n     bounded_nat_set_is_finite[of _ \"length (fst A)\"]\n     dfa_trans_is_node[unfolded dfa_trans_def dfa_is_node_def is_alph_def])+"], ["", "context rquot_DFS\nbegin"], ["", "lemma rquot_dfs_invariant:\n  assumes \"dfa_is_node A x\"\n  shows \"rquot_invariant A (rquot_dfs A n x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rquot_invariant A (rquot_dfs A n x)", "using assms well_formed"], ["proof (prove)\nusing this:\n  dfa_is_node A x\n  wf_dfa A n\n\ngoal (1 subgoal):\n 1. rquot_invariant A (rquot_dfs A n x)", "unfolding rquot_dfs_def"], ["proof (prove)\nusing this:\n  dfa_is_node A x\n  wf_dfa A n\n\ngoal (1 subgoal):\n 1. rquot_invariant A (dfs (rquot_empt A) [x])", "by (auto simp: dfs_invariant' empt_invariant)"], ["", "lemma dfa_reach_rquot:\n  assumes \"dfa_is_node A x\"\n  and \"dfa_is_node A y\"\n  shows \"rquot_memb y (rquot_dfs A n x) = (\\<exists>m. dfa_reach A x (zeros m n) y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rquot_memb y (rquot_dfs A n x) =\n    (\\<exists>m. dfa_reach A x (zeros m n) y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rquot_memb y (rquot_dfs A n x) =\n    (\\<exists>m. dfa_reach A x (zeros m n) y)", "from assms"], ["proof (chain)\npicking this:\n  dfa_is_node A x\n  dfa_is_node A y", "have \"rquot_memb y (rquot_dfs A n x) = ((x,y) \\<in> (succsr (rquot_succs A n))\\<^sup>*)\""], ["proof (prove)\nusing this:\n  dfa_is_node A x\n  dfa_is_node A y\n\ngoal (1 subgoal):\n 1. rquot_memb y (rquot_dfs A n x) =\n    ((x, y) \\<in> (succsr (rquot_succs A n))\\<^sup>*)", "by (simp add: dfs_eq_rtrancl rquot_dfs_def)"], ["proof (state)\nthis:\n  rquot_memb y (rquot_dfs A n x) =\n  ((x, y) \\<in> (succsr (rquot_succs A n))\\<^sup>*)\n\ngoal (1 subgoal):\n 1. rquot_memb y (rquot_dfs A n x) =\n    (\\<exists>m. dfa_reach A x (zeros m n) y)", "also"], ["proof (state)\nthis:\n  rquot_memb y (rquot_dfs A n x) =\n  ((x, y) \\<in> (succsr (rquot_succs A n))\\<^sup>*)\n\ngoal (1 subgoal):\n 1. rquot_memb y (rquot_dfs A n x) =\n    (\\<exists>m. dfa_reach A x (zeros m n) y)", "have \"\\<dots> = (\\<exists>m. dfa_reach A x (zeros m n) y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x, y) \\<in> (succsr (rquot_succs A n))\\<^sup>*) =\n    (\\<exists>m. dfa_reach A x (zeros m n) y)", "by (simp add: zeros_rtrancl)"], ["proof (state)\nthis:\n  ((x, y) \\<in> (succsr (rquot_succs A n))\\<^sup>*) =\n  (\\<exists>m. dfa_reach A x (zeros m n) y)\n\ngoal (1 subgoal):\n 1. rquot_memb y (rquot_dfs A n x) =\n    (\\<exists>m. dfa_reach A x (zeros m n) y)", "finally"], ["proof (chain)\npicking this:\n  rquot_memb y (rquot_dfs A n x) = (\\<exists>m. dfa_reach A x (zeros m n) y)", "show ?thesis"], ["proof (prove)\nusing this:\n  rquot_memb y (rquot_dfs A n x) = (\\<exists>m. dfa_reach A x (zeros m n) y)\n\ngoal (1 subgoal):\n 1. rquot_memb y (rquot_dfs A n x) =\n    (\\<exists>m. dfa_reach A x (zeros m n) y)", "."], ["proof (state)\nthis:\n  rquot_memb y (rquot_dfs A n x) = (\\<exists>m. dfa_reach A x (zeros m n) y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rquot_accepting:\n  assumes \"dfa_is_node (rquot A n) q\"\n  shows \"dfa_accepting (rquot A n) q = (\\<exists>m. dfa_accepting A (dfa_steps A q (zeros m n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa_accepting (rquot A n) q =\n    (\\<exists>m. dfa_accepting A (dfa_steps A q (zeros m n)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dfa_accepting (rquot A n) q =\n    (\\<exists>m. dfa_accepting A (dfa_steps A q (zeros m n)))", "from assms"], ["proof (chain)\npicking this:\n  dfa_is_node (rquot A n) q", "have Q: \"dfa_is_node A q\""], ["proof (prove)\nusing this:\n  dfa_is_node (rquot A n) q\n\ngoal (1 subgoal):\n 1. dfa_is_node A q", "by (simp add: rquot_node)"], ["proof (state)\nthis:\n  dfa_is_node A q\n\ngoal (1 subgoal):\n 1. dfa_accepting (rquot A n) q =\n    (\\<exists>m. dfa_accepting A (dfa_steps A q (zeros m n)))", "with assms"], ["proof (chain)\npicking this:\n  dfa_is_node (rquot A n) q\n  dfa_is_node A q", "have \"rquot_invariant A (rquot_dfs A n q)\""], ["proof (prove)\nusing this:\n  dfa_is_node (rquot A n) q\n  dfa_is_node A q\n\ngoal (1 subgoal):\n 1. rquot_invariant A (rquot_dfs A n q)", "by (simp add: rquot_dfs_invariant)"], ["proof (state)\nthis:\n  rquot_invariant A (rquot_dfs A n q)\n\ngoal (1 subgoal):\n 1. dfa_accepting (rquot A n) q =\n    (\\<exists>m. dfa_accepting A (dfa_steps A q (zeros m n)))", "hence L: \"length (rquot_dfs A n q) = length (fst A)\""], ["proof (prove)\nusing this:\n  rquot_invariant A (rquot_dfs A n q)\n\ngoal (1 subgoal):\n 1. length (rquot_dfs A n q) = length (fst A)", "by (simp add: rquot_invariant_def)"], ["proof (state)\nthis:\n  length (rquot_dfs A n q) = length (fst A)\n\ngoal (1 subgoal):\n 1. dfa_accepting (rquot A n) q =\n    (\\<exists>m. dfa_accepting A (dfa_steps A q (zeros m n)))", "have \"nfa_accepting' (snd A) (rquot_dfs A n q) = (set_of_bv (snd A) \\<inter> set_of_bv (rquot_dfs A n q) \\<noteq> {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfa_accepting' (snd A) (rquot_dfs A n q) =\n    (set_of_bv (snd A) \\<inter> set_of_bv (rquot_dfs A n q) \\<noteq> {})", "by (simp add: nfa_accepting'_set_of_bv)"], ["proof (state)\nthis:\n  nfa_accepting' (snd A) (rquot_dfs A n q) =\n  (set_of_bv (snd A) \\<inter> set_of_bv (rquot_dfs A n q) \\<noteq> {})\n\ngoal (1 subgoal):\n 1. dfa_accepting (rquot A n) q =\n    (\\<exists>m. dfa_accepting A (dfa_steps A q (zeros m n)))", "also"], ["proof (state)\nthis:\n  nfa_accepting' (snd A) (rquot_dfs A n q) =\n  (set_of_bv (snd A) \\<inter> set_of_bv (rquot_dfs A n q) \\<noteq> {})\n\ngoal (1 subgoal):\n 1. dfa_accepting (rquot A n) q =\n    (\\<exists>m. dfa_accepting A (dfa_steps A q (zeros m n)))", "have \"\\<dots> = (\\<exists>i. i < length (snd A) \\<and> snd A ! i \\<and> i < length (rquot_dfs A n q) \\<and> rquot_dfs A n q ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set_of_bv (snd A) \\<inter> set_of_bv (rquot_dfs A n q) \\<noteq> {}) =\n    (\\<exists>i<length (snd A).\n        snd A ! i \\<and>\n        i < length (rquot_dfs A n q) \\<and> rquot_dfs A n q ! i)", "by (auto simp: set_of_bv_def)"], ["proof (state)\nthis:\n  (set_of_bv (snd A) \\<inter> set_of_bv (rquot_dfs A n q) \\<noteq> {}) =\n  (\\<exists>i<length (snd A).\n      snd A ! i \\<and>\n      i < length (rquot_dfs A n q) \\<and> rquot_dfs A n q ! i)\n\ngoal (1 subgoal):\n 1. dfa_accepting (rquot A n) q =\n    (\\<exists>m. dfa_accepting A (dfa_steps A q (zeros m n)))", "also"], ["proof (state)\nthis:\n  (set_of_bv (snd A) \\<inter> set_of_bv (rquot_dfs A n q) \\<noteq> {}) =\n  (\\<exists>i<length (snd A).\n      snd A ! i \\<and>\n      i < length (rquot_dfs A n q) \\<and> rquot_dfs A n q ! i)\n\ngoal (1 subgoal):\n 1. dfa_accepting (rquot A n) q =\n    (\\<exists>m. dfa_accepting A (dfa_steps A q (zeros m n)))", "from well_formed L"], ["proof (chain)\npicking this:\n  wf_dfa A n\n  length (rquot_dfs A n q) = length (fst A)", "have \"\\<dots> = (\\<exists>i. dfa_is_node A i \\<and> snd A ! i \\<and> rquot_memb i (rquot_dfs A n q))\""], ["proof (prove)\nusing this:\n  wf_dfa A n\n  length (rquot_dfs A n q) = length (fst A)\n\ngoal (1 subgoal):\n 1. (\\<exists>i<length (snd A).\n        snd A ! i \\<and>\n        i < length (rquot_dfs A n q) \\<and> rquot_dfs A n q ! i) =\n    (\\<exists>i.\n        dfa_is_node A i \\<and>\n        snd A ! i \\<and> rquot_memb i (rquot_dfs A n q))", "by (auto simp add: wf_dfa_def dfa_is_node_def rquot_memb_def)"], ["proof (state)\nthis:\n  (\\<exists>i<length (snd A).\n      snd A ! i \\<and>\n      i < length (rquot_dfs A n q) \\<and> rquot_dfs A n q ! i) =\n  (\\<exists>i.\n      dfa_is_node A i \\<and>\n      snd A ! i \\<and> rquot_memb i (rquot_dfs A n q))\n\ngoal (1 subgoal):\n 1. dfa_accepting (rquot A n) q =\n    (\\<exists>m. dfa_accepting A (dfa_steps A q (zeros m n)))", "also"], ["proof (state)\nthis:\n  (\\<exists>i<length (snd A).\n      snd A ! i \\<and>\n      i < length (rquot_dfs A n q) \\<and> rquot_dfs A n q ! i) =\n  (\\<exists>i.\n      dfa_is_node A i \\<and>\n      snd A ! i \\<and> rquot_memb i (rquot_dfs A n q))\n\ngoal (1 subgoal):\n 1. dfa_accepting (rquot A n) q =\n    (\\<exists>m. dfa_accepting A (dfa_steps A q (zeros m n)))", "have \"\\<dots> = ({i. dfa_is_node A i \\<and> snd A ! i \\<and> rquot_memb i (rquot_dfs A n q)} \\<noteq> {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>i.\n        dfa_is_node A i \\<and>\n        snd A ! i \\<and> rquot_memb i (rquot_dfs A n q)) =\n    ({i. dfa_is_node A i \\<and>\n         snd A ! i \\<and> rquot_memb i (rquot_dfs A n q)} \\<noteq>\n     {})", "by auto"], ["proof (state)\nthis:\n  (\\<exists>i.\n      dfa_is_node A i \\<and>\n      snd A ! i \\<and> rquot_memb i (rquot_dfs A n q)) =\n  ({i. dfa_is_node A i \\<and>\n       snd A ! i \\<and> rquot_memb i (rquot_dfs A n q)} \\<noteq>\n   {})\n\ngoal (1 subgoal):\n 1. dfa_accepting (rquot A n) q =\n    (\\<exists>m. dfa_accepting A (dfa_steps A q (zeros m n)))", "also"], ["proof (state)\nthis:\n  (\\<exists>i.\n      dfa_is_node A i \\<and>\n      snd A ! i \\<and> rquot_memb i (rquot_dfs A n q)) =\n  ({i. dfa_is_node A i \\<and>\n       snd A ! i \\<and> rquot_memb i (rquot_dfs A n q)} \\<noteq>\n   {})\n\ngoal (1 subgoal):\n 1. dfa_accepting (rquot A n) q =\n    (\\<exists>m. dfa_accepting A (dfa_steps A q (zeros m n)))", "from assms Q"], ["proof (chain)\npicking this:\n  dfa_is_node (rquot A n) q\n  dfa_is_node A q", "have \"\\<dots> = ({i. dfa_is_node A i \\<and> snd A ! i \\<and> (\\<exists>m. dfa_reach A q (zeros m n) i)} \\<noteq> {})\""], ["proof (prove)\nusing this:\n  dfa_is_node (rquot A n) q\n  dfa_is_node A q\n\ngoal (1 subgoal):\n 1. ({i. dfa_is_node A i \\<and>\n         snd A ! i \\<and> rquot_memb i (rquot_dfs A n q)} \\<noteq>\n     {}) =\n    ({i. dfa_is_node A i \\<and>\n         snd A ! i \\<and>\n         (\\<exists>m. dfa_reach A q (zeros m n) i)} \\<noteq>\n     {})", "by (auto simp: dfa_reach_rquot)"], ["proof (state)\nthis:\n  ({i. dfa_is_node A i \\<and>\n       snd A ! i \\<and> rquot_memb i (rquot_dfs A n q)} \\<noteq>\n   {}) =\n  ({i. dfa_is_node A i \\<and>\n       snd A ! i \\<and> (\\<exists>m. dfa_reach A q (zeros m n) i)} \\<noteq>\n   {})\n\ngoal (1 subgoal):\n 1. dfa_accepting (rquot A n) q =\n    (\\<exists>m. dfa_accepting A (dfa_steps A q (zeros m n)))", "also"], ["proof (state)\nthis:\n  ({i. dfa_is_node A i \\<and>\n       snd A ! i \\<and> rquot_memb i (rquot_dfs A n q)} \\<noteq>\n   {}) =\n  ({i. dfa_is_node A i \\<and>\n       snd A ! i \\<and> (\\<exists>m. dfa_reach A q (zeros m n) i)} \\<noteq>\n   {})\n\ngoal (1 subgoal):\n 1. dfa_accepting (rquot A n) q =\n    (\\<exists>m. dfa_accepting A (dfa_steps A q (zeros m n)))", "have \"\\<dots> = ({i. \\<exists>m. dfa_is_node A i \\<and> snd A ! i \\<and> i = dfa_steps A q (zeros m n)} \\<noteq> {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({i. dfa_is_node A i \\<and>\n         snd A ! i \\<and>\n         (\\<exists>m. dfa_reach A q (zeros m n) i)} \\<noteq>\n     {}) =\n    ({i. \\<exists>m.\n            dfa_is_node A i \\<and>\n            snd A ! i \\<and> i = dfa_steps A q (zeros m n)} \\<noteq>\n     {})", "by (simp add: reach_def)"], ["proof (state)\nthis:\n  ({i. dfa_is_node A i \\<and>\n       snd A ! i \\<and> (\\<exists>m. dfa_reach A q (zeros m n) i)} \\<noteq>\n   {}) =\n  ({i. \\<exists>m.\n          dfa_is_node A i \\<and>\n          snd A ! i \\<and> i = dfa_steps A q (zeros m n)} \\<noteq>\n   {})\n\ngoal (1 subgoal):\n 1. dfa_accepting (rquot A n) q =\n    (\\<exists>m. dfa_accepting A (dfa_steps A q (zeros m n)))", "also"], ["proof (state)\nthis:\n  ({i. dfa_is_node A i \\<and>\n       snd A ! i \\<and> (\\<exists>m. dfa_reach A q (zeros m n) i)} \\<noteq>\n   {}) =\n  ({i. \\<exists>m.\n          dfa_is_node A i \\<and>\n          snd A ! i \\<and> i = dfa_steps A q (zeros m n)} \\<noteq>\n   {})\n\ngoal (1 subgoal):\n 1. dfa_accepting (rquot A n) q =\n    (\\<exists>m. dfa_accepting A (dfa_steps A q (zeros m n)))", "have \"\\<dots> = (\\<exists>i m. dfa_is_node A i \\<and> snd A ! i \\<and> i = dfa_steps A q (zeros m n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({i. \\<exists>m.\n            dfa_is_node A i \\<and>\n            snd A ! i \\<and> i = dfa_steps A q (zeros m n)} \\<noteq>\n     {}) =\n    (\\<exists>i m.\n        dfa_is_node A i \\<and>\n        snd A ! i \\<and> i = dfa_steps A q (zeros m n))", "by auto"], ["proof (state)\nthis:\n  ({i. \\<exists>m.\n          dfa_is_node A i \\<and>\n          snd A ! i \\<and> i = dfa_steps A q (zeros m n)} \\<noteq>\n   {}) =\n  (\\<exists>i m.\n      dfa_is_node A i \\<and> snd A ! i \\<and> i = dfa_steps A q (zeros m n))\n\ngoal (1 subgoal):\n 1. dfa_accepting (rquot A n) q =\n    (\\<exists>m. dfa_accepting A (dfa_steps A q (zeros m n)))", "also"], ["proof (state)\nthis:\n  ({i. \\<exists>m.\n          dfa_is_node A i \\<and>\n          snd A ! i \\<and> i = dfa_steps A q (zeros m n)} \\<noteq>\n   {}) =\n  (\\<exists>i m.\n      dfa_is_node A i \\<and> snd A ! i \\<and> i = dfa_steps A q (zeros m n))\n\ngoal (1 subgoal):\n 1. dfa_accepting (rquot A n) q =\n    (\\<exists>m. dfa_accepting A (dfa_steps A q (zeros m n)))", "have \"\\<dots> = (\\<exists>m. snd A ! dfa_steps A q (zeros m n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>i m.\n        dfa_is_node A i \\<and>\n        snd A ! i \\<and> i = dfa_steps A q (zeros m n)) =\n    (\\<exists>m. snd A ! dfa_steps A q (zeros m n))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>i m.\n       dfa_is_node A i \\<and>\n       snd A ! i \\<and> i = dfa_steps A q (zeros m n) \\<Longrightarrow>\n    \\<exists>m. snd A ! dfa_steps A q (zeros m n)\n 2. \\<exists>m. snd A ! dfa_steps A q (zeros m n) \\<Longrightarrow>\n    \\<exists>i m.\n       dfa_is_node A i \\<and> snd A ! i \\<and> i = dfa_steps A q (zeros m n)", "assume \"\\<exists>m. snd A ! dfa_steps A q (zeros m n)\""], ["proof (state)\nthis:\n  \\<exists>m. snd A ! dfa_steps A q (zeros m n)\n\ngoal (2 subgoals):\n 1. \\<exists>i m.\n       dfa_is_node A i \\<and>\n       snd A ! i \\<and> i = dfa_steps A q (zeros m n) \\<Longrightarrow>\n    \\<exists>m. snd A ! dfa_steps A q (zeros m n)\n 2. \\<exists>m. snd A ! dfa_steps A q (zeros m n) \\<Longrightarrow>\n    \\<exists>i m.\n       dfa_is_node A i \\<and> snd A ! i \\<and> i = dfa_steps A q (zeros m n)", "then"], ["proof (chain)\npicking this:\n  \\<exists>m. snd A ! dfa_steps A q (zeros m n)", "obtain m where N: \"snd A ! dfa_steps A q (zeros m n)\""], ["proof (prove)\nusing this:\n  \\<exists>m. snd A ! dfa_steps A q (zeros m n)\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        snd A ! dfa_steps A q (zeros m n) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  snd A ! dfa_steps A q (zeros m n)\n\ngoal (2 subgoals):\n 1. \\<exists>i m.\n       dfa_is_node A i \\<and>\n       snd A ! i \\<and> i = dfa_steps A q (zeros m n) \\<Longrightarrow>\n    \\<exists>m. snd A ! dfa_steps A q (zeros m n)\n 2. \\<exists>m. snd A ! dfa_steps A q (zeros m n) \\<Longrightarrow>\n    \\<exists>i m.\n       dfa_is_node A i \\<and> snd A ! i \\<and> i = dfa_steps A q (zeros m n)", "from well_formed Q zeros_is_alpha[of n m]"], ["proof (chain)\npicking this:\n  wf_dfa A n\n  dfa_is_node A q\n  list_all (is_alph n) (zeros m n)", "have \"dfa_is_node A (dfa_steps A q (zeros m n))\""], ["proof (prove)\nusing this:\n  wf_dfa A n\n  dfa_is_node A q\n  list_all (is_alph n) (zeros m n)\n\ngoal (1 subgoal):\n 1. dfa_is_node A (dfa_steps A q (zeros m n))", "by (simp add: dfa_steps_is_node)"], ["proof (state)\nthis:\n  dfa_is_node A (dfa_steps A q (zeros m n))\n\ngoal (2 subgoals):\n 1. \\<exists>i m.\n       dfa_is_node A i \\<and>\n       snd A ! i \\<and> i = dfa_steps A q (zeros m n) \\<Longrightarrow>\n    \\<exists>m. snd A ! dfa_steps A q (zeros m n)\n 2. \\<exists>m. snd A ! dfa_steps A q (zeros m n) \\<Longrightarrow>\n    \\<exists>i m.\n       dfa_is_node A i \\<and> snd A ! i \\<and> i = dfa_steps A q (zeros m n)", "with N"], ["proof (chain)\npicking this:\n  snd A ! dfa_steps A q (zeros m n)\n  dfa_is_node A (dfa_steps A q (zeros m n))", "show \"\\<exists>i m. dfa_is_node A i \\<and> snd A ! i \\<and> i = dfa_steps A q (zeros m n)\""], ["proof (prove)\nusing this:\n  snd A ! dfa_steps A q (zeros m n)\n  dfa_is_node A (dfa_steps A q (zeros m n))\n\ngoal (1 subgoal):\n 1. \\<exists>i m.\n       dfa_is_node A i \\<and> snd A ! i \\<and> i = dfa_steps A q (zeros m n)", "by auto"], ["proof (state)\nthis:\n  \\<exists>i m.\n     dfa_is_node A i \\<and> snd A ! i \\<and> i = dfa_steps A q (zeros m n)\n\ngoal (1 subgoal):\n 1. \\<exists>i m.\n       dfa_is_node A i \\<and>\n       snd A ! i \\<and> i = dfa_steps A q (zeros m n) \\<Longrightarrow>\n    \\<exists>m. snd A ! dfa_steps A q (zeros m n)", "qed auto"], ["proof (state)\nthis:\n  (\\<exists>i m.\n      dfa_is_node A i \\<and>\n      snd A ! i \\<and> i = dfa_steps A q (zeros m n)) =\n  (\\<exists>m. snd A ! dfa_steps A q (zeros m n))\n\ngoal (1 subgoal):\n 1. dfa_accepting (rquot A n) q =\n    (\\<exists>m. dfa_accepting A (dfa_steps A q (zeros m n)))", "finally"], ["proof (chain)\npicking this:\n  nfa_accepting' (snd A) (rquot_dfs A n q) =\n  (\\<exists>m. snd A ! dfa_steps A q (zeros m n))", "have \"nfa_accepting' (snd A) (rquot_dfs A n q) = (\\<exists>m. snd A ! dfa_steps A q (zeros m n))\""], ["proof (prove)\nusing this:\n  nfa_accepting' (snd A) (rquot_dfs A n q) =\n  (\\<exists>m. snd A ! dfa_steps A q (zeros m n))\n\ngoal (1 subgoal):\n 1. nfa_accepting' (snd A) (rquot_dfs A n q) =\n    (\\<exists>m. snd A ! dfa_steps A q (zeros m n))", "."], ["proof (state)\nthis:\n  nfa_accepting' (snd A) (rquot_dfs A n q) =\n  (\\<exists>m. snd A ! dfa_steps A q (zeros m n))\n\ngoal (1 subgoal):\n 1. dfa_accepting (rquot A n) q =\n    (\\<exists>m. dfa_accepting A (dfa_steps A q (zeros m n)))", "with well_formed assms"], ["proof (chain)\npicking this:\n  wf_dfa A n\n  dfa_is_node (rquot A n) q\n  nfa_accepting' (snd A) (rquot_dfs A n q) =\n  (\\<exists>m. snd A ! dfa_steps A q (zeros m n))", "show ?thesis"], ["proof (prove)\nusing this:\n  wf_dfa A n\n  dfa_is_node (rquot A n) q\n  nfa_accepting' (snd A) (rquot_dfs A n q) =\n  (\\<exists>m. snd A ! dfa_steps A q (zeros m n))\n\ngoal (1 subgoal):\n 1. dfa_accepting (rquot A n) q =\n    (\\<exists>m. dfa_accepting A (dfa_steps A q (zeros m n)))", "by (simp add: dfa_accepting_def rquot_def split_beta dfa_is_node_def map_index_nth wf_dfa_def)"], ["proof (state)\nthis:\n  dfa_accepting (rquot A n) q =\n  (\\<exists>m. dfa_accepting A (dfa_steps A q (zeros m n)))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma rquot_accepts:\n  assumes A: \"wf_dfa A n\"\n  and \"list_all (is_alph n) bss\"\n  shows \"dfa_accepts (rquot A n) bss = (\\<exists>m. dfa_accepts A (bss @ zeros m n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa_accepts (rquot A n) bss =\n    (\\<exists>m. dfa_accepts A (bss @ zeros m n))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dfa_accepts (rquot A n) bss =\n    (\\<exists>m. dfa_accepts A (bss @ zeros m n))", "from A"], ["proof (chain)\npicking this:\n  wf_dfa A n", "interpret rquot_DFS A n"], ["proof (prove)\nusing this:\n  wf_dfa A n\n\ngoal (1 subgoal):\n 1. rquot_DFS A n", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. dfa_accepts (rquot A n) bss =\n    (\\<exists>m. dfa_accepts A (bss @ zeros m n))", "from assms"], ["proof (chain)\npicking this:\n  wf_dfa A n\n  list_all (is_alph n) bss", "have V: \"wf_dfa (rquot A n) n\""], ["proof (prove)\nusing this:\n  wf_dfa A n\n  list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. wf_dfa (rquot A n) n", "by (simp add: rquot_well_formed_aut)"], ["proof (state)\nthis:\n  wf_dfa (rquot A n) n\n\ngoal (1 subgoal):\n 1. dfa_accepts (rquot A n) bss =\n    (\\<exists>m. dfa_accepts A (bss @ zeros m n))", "hence \"dfa_is_node (rquot A n) 0\""], ["proof (prove)\nusing this:\n  wf_dfa (rquot A n) n\n\ngoal (1 subgoal):\n 1. dfa_is_node (rquot A n) 0", "by (simp add: dfa_startnode_is_node)"], ["proof (state)\nthis:\n  dfa_is_node (rquot A n) 0\n\ngoal (1 subgoal):\n 1. dfa_accepts (rquot A n) bss =\n    (\\<exists>m. dfa_accepts A (bss @ zeros m n))", "with assms V"], ["proof (chain)\npicking this:\n  wf_dfa A n\n  list_all (is_alph n) bss\n  wf_dfa (rquot A n) n\n  dfa_is_node (rquot A n) 0", "have q: \"dfa_is_node (rquot A n) (dfa_steps (rquot A n) 0 bss)\""], ["proof (prove)\nusing this:\n  wf_dfa A n\n  list_all (is_alph n) bss\n  wf_dfa (rquot A n) n\n  dfa_is_node (rquot A n) 0\n\ngoal (1 subgoal):\n 1. dfa_is_node (rquot A n) (dfa_steps (rquot A n) 0 bss)", "by (simp add: dfa_steps_is_node)"], ["proof (state)\nthis:\n  dfa_is_node (rquot A n) (dfa_steps (rquot A n) 0 bss)\n\ngoal (1 subgoal):\n 1. dfa_accepts (rquot A n) bss =\n    (\\<exists>m. dfa_accepts A (bss @ zeros m n))", "have \"dfa_accepts (rquot A n) bss = dfa_accepting (rquot A n) (dfa_steps (rquot A n) 0 bss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa_accepts (rquot A n) bss =\n    dfa_accepting (rquot A n) (dfa_steps (rquot A n) 0 bss)", "by (simp add: accepts_def)"], ["proof (state)\nthis:\n  dfa_accepts (rquot A n) bss =\n  dfa_accepting (rquot A n) (dfa_steps (rquot A n) 0 bss)\n\ngoal (1 subgoal):\n 1. dfa_accepts (rquot A n) bss =\n    (\\<exists>m. dfa_accepts A (bss @ zeros m n))", "also"], ["proof (state)\nthis:\n  dfa_accepts (rquot A n) bss =\n  dfa_accepting (rquot A n) (dfa_steps (rquot A n) 0 bss)\n\ngoal (1 subgoal):\n 1. dfa_accepts (rquot A n) bss =\n    (\\<exists>m. dfa_accepts A (bss @ zeros m n))", "from assms q"], ["proof (chain)\npicking this:\n  wf_dfa A n\n  list_all (is_alph n) bss\n  dfa_is_node (rquot A n) (dfa_steps (rquot A n) 0 bss)", "have \"\\<dots> = (\\<exists>m. dfa_accepting A (dfa_steps A (dfa_steps A 0 bss) (zeros m n)))\""], ["proof (prove)\nusing this:\n  wf_dfa A n\n  list_all (is_alph n) bss\n  dfa_is_node (rquot A n) (dfa_steps (rquot A n) 0 bss)\n\ngoal (1 subgoal):\n 1. dfa_accepting (rquot A n) (dfa_steps (rquot A n) 0 bss) =\n    (\\<exists>m.\n        dfa_accepting A (dfa_steps A (dfa_steps A 0 bss) (zeros m n)))", "by (simp add: rquot_accepting rquot_steps)"], ["proof (state)\nthis:\n  dfa_accepting (rquot A n) (dfa_steps (rquot A n) 0 bss) =\n  (\\<exists>m.\n      dfa_accepting A (dfa_steps A (dfa_steps A 0 bss) (zeros m n)))\n\ngoal (1 subgoal):\n 1. dfa_accepts (rquot A n) bss =\n    (\\<exists>m. dfa_accepts A (bss @ zeros m n))", "also"], ["proof (state)\nthis:\n  dfa_accepting (rquot A n) (dfa_steps (rquot A n) 0 bss) =\n  (\\<exists>m.\n      dfa_accepting A (dfa_steps A (dfa_steps A 0 bss) (zeros m n)))\n\ngoal (1 subgoal):\n 1. dfa_accepts (rquot A n) bss =\n    (\\<exists>m. dfa_accepts A (bss @ zeros m n))", "have \"\\<dots> = (\\<exists>m. dfa_accepting A (dfa_steps A 0 (bss @ zeros m n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>m.\n        dfa_accepting A (dfa_steps A (dfa_steps A 0 bss) (zeros m n))) =\n    (\\<exists>m. dfa_accepting A (dfa_steps A 0 (bss @ zeros m n)))", "by simp"], ["proof (state)\nthis:\n  (\\<exists>m.\n      dfa_accepting A (dfa_steps A (dfa_steps A 0 bss) (zeros m n))) =\n  (\\<exists>m. dfa_accepting A (dfa_steps A 0 (bss @ zeros m n)))\n\ngoal (1 subgoal):\n 1. dfa_accepts (rquot A n) bss =\n    (\\<exists>m. dfa_accepts A (bss @ zeros m n))", "also"], ["proof (state)\nthis:\n  (\\<exists>m.\n      dfa_accepting A (dfa_steps A (dfa_steps A 0 bss) (zeros m n))) =\n  (\\<exists>m. dfa_accepting A (dfa_steps A 0 (bss @ zeros m n)))\n\ngoal (1 subgoal):\n 1. dfa_accepts (rquot A n) bss =\n    (\\<exists>m. dfa_accepts A (bss @ zeros m n))", "have \"\\<dots> = (\\<exists>m. dfa_accepts A (bss @ zeros m n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>m. dfa_accepting A (dfa_steps A 0 (bss @ zeros m n))) =\n    (\\<exists>m. dfa_accepts A (bss @ zeros m n))", "by (simp add: accepts_def)"], ["proof (state)\nthis:\n  (\\<exists>m. dfa_accepting A (dfa_steps A 0 (bss @ zeros m n))) =\n  (\\<exists>m. dfa_accepts A (bss @ zeros m n))\n\ngoal (1 subgoal):\n 1. dfa_accepts (rquot A n) bss =\n    (\\<exists>m. dfa_accepts A (bss @ zeros m n))", "finally"], ["proof (chain)\npicking this:\n  dfa_accepts (rquot A n) bss =\n  (\\<exists>m. dfa_accepts A (bss @ zeros m n))", "show ?thesis"], ["proof (prove)\nusing this:\n  dfa_accepts (rquot A n) bss =\n  (\\<exists>m. dfa_accepts A (bss @ zeros m n))\n\ngoal (1 subgoal):\n 1. dfa_accepts (rquot A n) bss =\n    (\\<exists>m. dfa_accepts A (bss @ zeros m n))", "."], ["proof (state)\nthis:\n  dfa_accepts (rquot A n) bss =\n  (\\<exists>m. dfa_accepts A (bss @ zeros m n))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Diophantine Equations\\<close>"], ["", "fun eval_dioph :: \"int list \\<Rightarrow> nat list \\<Rightarrow> int\"\nwhere\n  \"eval_dioph (k # ks) (x # xs) = k * int x + eval_dioph ks xs\"\n| \"eval_dioph ks xs = 0\""], ["", "lemma eval_dioph_mult:\n  \"eval_dioph ks xs * int n = eval_dioph ks (map (\\<lambda>x. x * n) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_dioph ks xs * int n = eval_dioph ks (map (\\<lambda>x. x * n) xs)", "by(induct ks xs rule: eval_dioph.induct) (simp_all add: distrib_right)"], ["", "lemma eval_dioph_add_map:\n  \"eval_dioph ks (map f xs) + eval_dioph ks (map g xs) =\n   eval_dioph ks (map (\\<lambda>x. f x + g x) (xs::nat list))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_dioph ks (map f xs) + eval_dioph ks (map g xs) =\n    eval_dioph ks (map (\\<lambda>x. f x + g x) xs)", "proof (induct ks xs rule: eval_dioph.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>k ks x xs.\n       eval_dioph ks (map f xs) + eval_dioph ks (map g xs) =\n       eval_dioph ks (map (\\<lambda>x. f x + g x) xs) \\<Longrightarrow>\n       eval_dioph (k # ks) (map f (x # xs)) +\n       eval_dioph (k # ks) (map g (x # xs)) =\n       eval_dioph (k # ks) (map (\\<lambda>x. f x + g x) (x # xs))\n 2. \\<And>xs.\n       eval_dioph [] (map f xs) + eval_dioph [] (map g xs) =\n       eval_dioph [] (map (\\<lambda>x. f x + g x) xs)\n 3. \\<And>ks.\n       eval_dioph ks (map f []) + eval_dioph ks (map g []) =\n       eval_dioph ks (map (\\<lambda>x. f x + g x) [])", "case (1 k ks x xs)"], ["proof (state)\nthis:\n  eval_dioph ks (map f xs) + eval_dioph ks (map g xs) =\n  eval_dioph ks (map (\\<lambda>x. f x + g x) xs)\n\ngoal (3 subgoals):\n 1. \\<And>k ks x xs.\n       eval_dioph ks (map f xs) + eval_dioph ks (map g xs) =\n       eval_dioph ks (map (\\<lambda>x. f x + g x) xs) \\<Longrightarrow>\n       eval_dioph (k # ks) (map f (x # xs)) +\n       eval_dioph (k # ks) (map g (x # xs)) =\n       eval_dioph (k # ks) (map (\\<lambda>x. f x + g x) (x # xs))\n 2. \\<And>xs.\n       eval_dioph [] (map f xs) + eval_dioph [] (map g xs) =\n       eval_dioph [] (map (\\<lambda>x. f x + g x) xs)\n 3. \\<And>ks.\n       eval_dioph ks (map f []) + eval_dioph ks (map g []) =\n       eval_dioph ks (map (\\<lambda>x. f x + g x) [])", "have \"eval_dioph (k # ks) (map f (x # xs)) + eval_dioph (k # ks) (map g (x # xs)) =\n    (k * int (f x) + k * int (g x)) + (eval_dioph ks (map f xs) + eval_dioph ks (map g xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_dioph (k # ks) (map f (x # xs)) +\n    eval_dioph (k # ks) (map g (x # xs)) =\n    k * int (f x) + k * int (g x) +\n    (eval_dioph ks (map f xs) + eval_dioph ks (map g xs))", "by simp"], ["proof (state)\nthis:\n  eval_dioph (k # ks) (map f (x # xs)) +\n  eval_dioph (k # ks) (map g (x # xs)) =\n  k * int (f x) + k * int (g x) +\n  (eval_dioph ks (map f xs) + eval_dioph ks (map g xs))\n\ngoal (3 subgoals):\n 1. \\<And>k ks x xs.\n       eval_dioph ks (map f xs) + eval_dioph ks (map g xs) =\n       eval_dioph ks (map (\\<lambda>x. f x + g x) xs) \\<Longrightarrow>\n       eval_dioph (k # ks) (map f (x # xs)) +\n       eval_dioph (k # ks) (map g (x # xs)) =\n       eval_dioph (k # ks) (map (\\<lambda>x. f x + g x) (x # xs))\n 2. \\<And>xs.\n       eval_dioph [] (map f xs) + eval_dioph [] (map g xs) =\n       eval_dioph [] (map (\\<lambda>x. f x + g x) xs)\n 3. \\<And>ks.\n       eval_dioph ks (map f []) + eval_dioph ks (map g []) =\n       eval_dioph ks (map (\\<lambda>x. f x + g x) [])", "also"], ["proof (state)\nthis:\n  eval_dioph (k # ks) (map f (x # xs)) +\n  eval_dioph (k # ks) (map g (x # xs)) =\n  k * int (f x) + k * int (g x) +\n  (eval_dioph ks (map f xs) + eval_dioph ks (map g xs))\n\ngoal (3 subgoals):\n 1. \\<And>k ks x xs.\n       eval_dioph ks (map f xs) + eval_dioph ks (map g xs) =\n       eval_dioph ks (map (\\<lambda>x. f x + g x) xs) \\<Longrightarrow>\n       eval_dioph (k # ks) (map f (x # xs)) +\n       eval_dioph (k # ks) (map g (x # xs)) =\n       eval_dioph (k # ks) (map (\\<lambda>x. f x + g x) (x # xs))\n 2. \\<And>xs.\n       eval_dioph [] (map f xs) + eval_dioph [] (map g xs) =\n       eval_dioph [] (map (\\<lambda>x. f x + g x) xs)\n 3. \\<And>ks.\n       eval_dioph ks (map f []) + eval_dioph ks (map g []) =\n       eval_dioph ks (map (\\<lambda>x. f x + g x) [])", "have \"\\<dots> = (k * int (f x) + k * int (g x)) + eval_dioph ks (map (\\<lambda>x. f x + g x) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k * int (f x) + k * int (g x) +\n    (eval_dioph ks (map f xs) + eval_dioph ks (map g xs)) =\n    k * int (f x) + k * int (g x) +\n    eval_dioph ks (map (\\<lambda>x. f x + g x) xs)", "by (simp add: 1)"], ["proof (state)\nthis:\n  k * int (f x) + k * int (g x) +\n  (eval_dioph ks (map f xs) + eval_dioph ks (map g xs)) =\n  k * int (f x) + k * int (g x) +\n  eval_dioph ks (map (\\<lambda>x. f x + g x) xs)\n\ngoal (3 subgoals):\n 1. \\<And>k ks x xs.\n       eval_dioph ks (map f xs) + eval_dioph ks (map g xs) =\n       eval_dioph ks (map (\\<lambda>x. f x + g x) xs) \\<Longrightarrow>\n       eval_dioph (k # ks) (map f (x # xs)) +\n       eval_dioph (k # ks) (map g (x # xs)) =\n       eval_dioph (k # ks) (map (\\<lambda>x. f x + g x) (x # xs))\n 2. \\<And>xs.\n       eval_dioph [] (map f xs) + eval_dioph [] (map g xs) =\n       eval_dioph [] (map (\\<lambda>x. f x + g x) xs)\n 3. \\<And>ks.\n       eval_dioph ks (map f []) + eval_dioph ks (map g []) =\n       eval_dioph ks (map (\\<lambda>x. f x + g x) [])", "finally"], ["proof (chain)\npicking this:\n  eval_dioph (k # ks) (map f (x # xs)) +\n  eval_dioph (k # ks) (map g (x # xs)) =\n  k * int (f x) + k * int (g x) +\n  eval_dioph ks (map (\\<lambda>x. f x + g x) xs)", "show ?case"], ["proof (prove)\nusing this:\n  eval_dioph (k # ks) (map f (x # xs)) +\n  eval_dioph (k # ks) (map g (x # xs)) =\n  k * int (f x) + k * int (g x) +\n  eval_dioph ks (map (\\<lambda>x. f x + g x) xs)\n\ngoal (1 subgoal):\n 1. eval_dioph (k # ks) (map f (x # xs)) +\n    eval_dioph (k # ks) (map g (x # xs)) =\n    eval_dioph (k # ks) (map (\\<lambda>x. f x + g x) (x # xs))", "by (simp add: ac_simps distrib_left)"], ["proof (state)\nthis:\n  eval_dioph (k # ks) (map f (x # xs)) +\n  eval_dioph (k # ks) (map g (x # xs)) =\n  eval_dioph (k # ks) (map (\\<lambda>x. f x + g x) (x # xs))\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       eval_dioph [] (map f xs) + eval_dioph [] (map g xs) =\n       eval_dioph [] (map (\\<lambda>x. f x + g x) xs)\n 2. \\<And>ks.\n       eval_dioph ks (map f []) + eval_dioph ks (map g []) =\n       eval_dioph ks (map (\\<lambda>x. f x + g x) [])", "qed simp_all"], ["", "lemma eval_dioph_div_mult:\n  \"eval_dioph ks (map (\\<lambda>x. x div n) xs) * int n +\n   eval_dioph ks (map (\\<lambda>x. x mod n) xs) = eval_dioph ks xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_dioph ks (map (\\<lambda>x. x div n) xs) * int n +\n    eval_dioph ks (map (\\<lambda>x. x mod n) xs) =\n    eval_dioph ks xs", "by (simp add: eval_dioph_mult o_def eval_dioph_add_map)"], ["", "lemma eval_dioph_mod:\n  \"eval_dioph ks xs mod int n = eval_dioph ks (map (\\<lambda>x. x mod n) xs) mod int n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_dioph ks xs mod int n =\n    eval_dioph ks (map (\\<lambda>x. x mod n) xs) mod int n", "proof (induct ks xs rule: eval_dioph.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>k ks x xs.\n       eval_dioph ks xs mod int n =\n       eval_dioph ks (map (\\<lambda>x. x mod n) xs) mod\n       int n \\<Longrightarrow>\n       eval_dioph (k # ks) (x # xs) mod int n =\n       eval_dioph (k # ks) (map (\\<lambda>x. x mod n) (x # xs)) mod int n\n 2. \\<And>xs.\n       eval_dioph [] xs mod int n =\n       eval_dioph [] (map (\\<lambda>x. x mod n) xs) mod int n\n 3. \\<And>ks.\n       eval_dioph ks [] mod int n =\n       eval_dioph ks (map (\\<lambda>x. x mod n) []) mod int n", "case (1 k ks x xs)"], ["proof (state)\nthis:\n  eval_dioph ks xs mod int n =\n  eval_dioph ks (map (\\<lambda>x. x mod n) xs) mod int n\n\ngoal (3 subgoals):\n 1. \\<And>k ks x xs.\n       eval_dioph ks xs mod int n =\n       eval_dioph ks (map (\\<lambda>x. x mod n) xs) mod\n       int n \\<Longrightarrow>\n       eval_dioph (k # ks) (x # xs) mod int n =\n       eval_dioph (k # ks) (map (\\<lambda>x. x mod n) (x # xs)) mod int n\n 2. \\<And>xs.\n       eval_dioph [] xs mod int n =\n       eval_dioph [] (map (\\<lambda>x. x mod n) xs) mod int n\n 3. \\<And>ks.\n       eval_dioph ks [] mod int n =\n       eval_dioph ks (map (\\<lambda>x. x mod n) []) mod int n", "have \"eval_dioph (k # ks) (x # xs) mod int n =\n    ((k * int x) mod int n + eval_dioph ks xs mod int n) mod int n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_dioph (k # ks) (x # xs) mod int n =\n    (k * int x mod int n + eval_dioph ks xs mod int n) mod int n", "by (simp add: mod_add_eq)"], ["proof (state)\nthis:\n  eval_dioph (k # ks) (x # xs) mod int n =\n  (k * int x mod int n + eval_dioph ks xs mod int n) mod int n\n\ngoal (3 subgoals):\n 1. \\<And>k ks x xs.\n       eval_dioph ks xs mod int n =\n       eval_dioph ks (map (\\<lambda>x. x mod n) xs) mod\n       int n \\<Longrightarrow>\n       eval_dioph (k # ks) (x # xs) mod int n =\n       eval_dioph (k # ks) (map (\\<lambda>x. x mod n) (x # xs)) mod int n\n 2. \\<And>xs.\n       eval_dioph [] xs mod int n =\n       eval_dioph [] (map (\\<lambda>x. x mod n) xs) mod int n\n 3. \\<And>ks.\n       eval_dioph ks [] mod int n =\n       eval_dioph ks (map (\\<lambda>x. x mod n) []) mod int n", "also"], ["proof (state)\nthis:\n  eval_dioph (k # ks) (x # xs) mod int n =\n  (k * int x mod int n + eval_dioph ks xs mod int n) mod int n\n\ngoal (3 subgoals):\n 1. \\<And>k ks x xs.\n       eval_dioph ks xs mod int n =\n       eval_dioph ks (map (\\<lambda>x. x mod n) xs) mod\n       int n \\<Longrightarrow>\n       eval_dioph (k # ks) (x # xs) mod int n =\n       eval_dioph (k # ks) (map (\\<lambda>x. x mod n) (x # xs)) mod int n\n 2. \\<And>xs.\n       eval_dioph [] xs mod int n =\n       eval_dioph [] (map (\\<lambda>x. x mod n) xs) mod int n\n 3. \\<And>ks.\n       eval_dioph ks [] mod int n =\n       eval_dioph ks (map (\\<lambda>x. x mod n) []) mod int n", "have \"\\<dots> = ((k * (int x mod int n)) mod int n +\n    eval_dioph ks (map (\\<lambda>x. x mod n) xs) mod int n) mod int n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k * int x mod int n + eval_dioph ks xs mod int n) mod int n =\n    (k * (int x mod int n) mod int n +\n     eval_dioph ks (map (\\<lambda>x. x mod n) xs) mod int n) mod\n    int n", "by (simp add: 1 mod_mult_right_eq)"], ["proof (state)\nthis:\n  (k * int x mod int n + eval_dioph ks xs mod int n) mod int n =\n  (k * (int x mod int n) mod int n +\n   eval_dioph ks (map (\\<lambda>x. x mod n) xs) mod int n) mod\n  int n\n\ngoal (3 subgoals):\n 1. \\<And>k ks x xs.\n       eval_dioph ks xs mod int n =\n       eval_dioph ks (map (\\<lambda>x. x mod n) xs) mod\n       int n \\<Longrightarrow>\n       eval_dioph (k # ks) (x # xs) mod int n =\n       eval_dioph (k # ks) (map (\\<lambda>x. x mod n) (x # xs)) mod int n\n 2. \\<And>xs.\n       eval_dioph [] xs mod int n =\n       eval_dioph [] (map (\\<lambda>x. x mod n) xs) mod int n\n 3. \\<And>ks.\n       eval_dioph ks [] mod int n =\n       eval_dioph ks (map (\\<lambda>x. x mod n) []) mod int n", "finally"], ["proof (chain)\npicking this:\n  eval_dioph (k # ks) (x # xs) mod int n =\n  (k * (int x mod int n) mod int n +\n   eval_dioph ks (map (\\<lambda>x. x mod n) xs) mod int n) mod\n  int n", "show ?case"], ["proof (prove)\nusing this:\n  eval_dioph (k # ks) (x # xs) mod int n =\n  (k * (int x mod int n) mod int n +\n   eval_dioph ks (map (\\<lambda>x. x mod n) xs) mod int n) mod\n  int n\n\ngoal (1 subgoal):\n 1. eval_dioph (k # ks) (x # xs) mod int n =\n    eval_dioph (k # ks) (map (\\<lambda>x. x mod n) (x # xs)) mod int n", "by (simp add: zmod_int mod_add_eq)"], ["proof (state)\nthis:\n  eval_dioph (k # ks) (x # xs) mod int n =\n  eval_dioph (k # ks) (map (\\<lambda>x. x mod n) (x # xs)) mod int n\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       eval_dioph [] xs mod int n =\n       eval_dioph [] (map (\\<lambda>x. x mod n) xs) mod int n\n 2. \\<And>ks.\n       eval_dioph ks [] mod int n =\n       eval_dioph ks (map (\\<lambda>x. x mod n) []) mod int n", "qed simp_all"], ["", "lemma eval_dioph_div_mod:\n  \"(eval_dioph ks xs = l) =\n   (eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2 \\<and>\n    eval_dioph ks (map (\\<lambda>x. x div 2) xs) =\n      (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2)\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (eval_dioph ks xs = l) =\n    (eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2 \\<and>\n     eval_dioph ks (map (\\<lambda>x. x div 2) xs) =\n     (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. eval_dioph ks xs = l \\<Longrightarrow>\n    eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2 \\<and>\n    eval_dioph ks (map (\\<lambda>x. x div 2) xs) =\n    (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\n 2. eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2 \\<and>\n    eval_dioph ks (map (\\<lambda>x. x div 2) xs) =\n    (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div\n    2 \\<Longrightarrow>\n    eval_dioph ks xs = l", "assume eq: ?l"], ["proof (state)\nthis:\n  eval_dioph ks xs = l\n\ngoal (2 subgoals):\n 1. eval_dioph ks xs = l \\<Longrightarrow>\n    eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2 \\<and>\n    eval_dioph ks (map (\\<lambda>x. x div 2) xs) =\n    (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\n 2. eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2 \\<and>\n    eval_dioph ks (map (\\<lambda>x. x div 2) xs) =\n    (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div\n    2 \\<Longrightarrow>\n    eval_dioph ks xs = l", "then"], ["proof (chain)\npicking this:\n  eval_dioph ks xs = l", "have \"eval_dioph ks xs mod 2 = l mod 2\""], ["proof (prove)\nusing this:\n  eval_dioph ks xs = l\n\ngoal (1 subgoal):\n 1. eval_dioph ks xs mod 2 = l mod 2", "by simp"], ["proof (state)\nthis:\n  eval_dioph ks xs mod 2 = l mod 2\n\ngoal (2 subgoals):\n 1. eval_dioph ks xs = l \\<Longrightarrow>\n    eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2 \\<and>\n    eval_dioph ks (map (\\<lambda>x. x div 2) xs) =\n    (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\n 2. eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2 \\<and>\n    eval_dioph ks (map (\\<lambda>x. x div 2) xs) =\n    (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div\n    2 \\<Longrightarrow>\n    eval_dioph ks xs = l", "with eval_dioph_mod [of _ _ 2]"], ["proof (chain)\npicking this:\n  eval_dioph ?ks ?xs mod int 2 =\n  eval_dioph ?ks (map (\\<lambda>x. x mod 2) ?xs) mod int 2\n  eval_dioph ks xs mod 2 = l mod 2", "have eq': \"eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2\""], ["proof (prove)\nusing this:\n  eval_dioph ?ks ?xs mod int 2 =\n  eval_dioph ?ks (map (\\<lambda>x. x mod 2) ?xs) mod int 2\n  eval_dioph ks xs mod 2 = l mod 2\n\ngoal (1 subgoal):\n 1. eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2", "by simp"], ["proof (state)\nthis:\n  eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2\n\ngoal (2 subgoals):\n 1. eval_dioph ks xs = l \\<Longrightarrow>\n    eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2 \\<and>\n    eval_dioph ks (map (\\<lambda>x. x div 2) xs) =\n    (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\n 2. eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2 \\<and>\n    eval_dioph ks (map (\\<lambda>x. x div 2) xs) =\n    (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div\n    2 \\<Longrightarrow>\n    eval_dioph ks xs = l", "from eval_dioph_div_mult [symmetric, of ks xs 2] eq"], ["proof (chain)\npicking this:\n  eval_dioph ks xs =\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) * int 2 +\n  eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\n  eval_dioph ks xs = l", "have \"eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 + eval_dioph ks (map (\\<lambda>x. x mod 2) xs) = l\""], ["proof (prove)\nusing this:\n  eval_dioph ks xs =\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) * int 2 +\n  eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\n  eval_dioph ks xs = l\n\ngoal (1 subgoal):\n 1. eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 +\n    eval_dioph ks (map (\\<lambda>x. x mod 2) xs) =\n    l", "by simp"], ["proof (state)\nthis:\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 +\n  eval_dioph ks (map (\\<lambda>x. x mod 2) xs) =\n  l\n\ngoal (2 subgoals):\n 1. eval_dioph ks xs = l \\<Longrightarrow>\n    eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2 \\<and>\n    eval_dioph ks (map (\\<lambda>x. x div 2) xs) =\n    (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\n 2. eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2 \\<and>\n    eval_dioph ks (map (\\<lambda>x. x div 2) xs) =\n    (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div\n    2 \\<Longrightarrow>\n    eval_dioph ks xs = l", "then"], ["proof (chain)\npicking this:\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 +\n  eval_dioph ks (map (\\<lambda>x. x mod 2) xs) =\n  l", "have \"eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 = l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\""], ["proof (prove)\nusing this:\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 +\n  eval_dioph ks (map (\\<lambda>x. x mod 2) xs) =\n  l\n\ngoal (1 subgoal):\n 1. eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 =\n    l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)", "by (simp add: eq_diff_eq)"], ["proof (state)\nthis:\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 =\n  l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\n\ngoal (2 subgoals):\n 1. eval_dioph ks xs = l \\<Longrightarrow>\n    eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2 \\<and>\n    eval_dioph ks (map (\\<lambda>x. x div 2) xs) =\n    (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\n 2. eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2 \\<and>\n    eval_dioph ks (map (\\<lambda>x. x div 2) xs) =\n    (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div\n    2 \\<Longrightarrow>\n    eval_dioph ks xs = l", "then"], ["proof (chain)\npicking this:\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 =\n  l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)", "have \"(eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2) div 2 =\n    (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\""], ["proof (prove)\nusing this:\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 =\n  l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\n\ngoal (1 subgoal):\n 1. eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 div 2 =\n    (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2", "by simp"], ["proof (state)\nthis:\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 div 2 =\n  (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\n\ngoal (2 subgoals):\n 1. eval_dioph ks xs = l \\<Longrightarrow>\n    eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2 \\<and>\n    eval_dioph ks (map (\\<lambda>x. x div 2) xs) =\n    (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\n 2. eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2 \\<and>\n    eval_dioph ks (map (\\<lambda>x. x div 2) xs) =\n    (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div\n    2 \\<Longrightarrow>\n    eval_dioph ks xs = l", "with eq'"], ["proof (chain)\npicking this:\n  eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 div 2 =\n  (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2", "show ?r"], ["proof (prove)\nusing this:\n  eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 div 2 =\n  (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\n\ngoal (1 subgoal):\n 1. eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2 \\<and>\n    eval_dioph ks (map (\\<lambda>x. x div 2) xs) =\n    (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2", "by simp"], ["proof (state)\nthis:\n  eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2 \\<and>\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) =\n  (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\n\ngoal (1 subgoal):\n 1. eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2 \\<and>\n    eval_dioph ks (map (\\<lambda>x. x div 2) xs) =\n    (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div\n    2 \\<Longrightarrow>\n    eval_dioph ks xs = l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2 \\<and>\n    eval_dioph ks (map (\\<lambda>x. x div 2) xs) =\n    (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div\n    2 \\<Longrightarrow>\n    eval_dioph ks xs = l", "assume ?r (is \"?r1 \\<and> ?r2\")"], ["proof (state)\nthis:\n  eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2 \\<and>\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) =\n  (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\n\ngoal (1 subgoal):\n 1. eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2 \\<and>\n    eval_dioph ks (map (\\<lambda>x. x div 2) xs) =\n    (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div\n    2 \\<Longrightarrow>\n    eval_dioph ks xs = l", "then"], ["proof (chain)\npicking this:\n  eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2 \\<and>\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) =\n  (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2", "obtain eq1: ?r1 and eq2: ?r2"], ["proof (prove)\nusing this:\n  eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2 \\<and>\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) =\n  (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2;\n      eval_dioph ks (map (\\<lambda>x. x div 2) xs) =\n      (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) =\n  (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\n\ngoal (1 subgoal):\n 1. eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2 \\<and>\n    eval_dioph ks (map (\\<lambda>x. x div 2) xs) =\n    (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div\n    2 \\<Longrightarrow>\n    eval_dioph ks xs = l", "from eq1"], ["proof (chain)\npicking this:\n  eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2", "have \"(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2) mod 2 =\n    (l - l mod 2) mod 2\""], ["proof (prove)\nusing this:\n  eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2\n\ngoal (1 subgoal):\n 1. (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2) mod 2 =\n    (l - l mod 2) mod 2", "by simp"], ["proof (state)\nthis:\n  (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2) mod 2 =\n  (l - l mod 2) mod 2\n\ngoal (1 subgoal):\n 1. eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2 \\<and>\n    eval_dioph ks (map (\\<lambda>x. x div 2) xs) =\n    (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div\n    2 \\<Longrightarrow>\n    eval_dioph ks xs = l", "then"], ["proof (chain)\npicking this:\n  (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2) mod 2 =\n  (l - l mod 2) mod 2", "have \"(l mod 2 - eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 mod 2) mod 2 =\n    (l mod 2 - l mod 2 mod 2) mod 2\""], ["proof (prove)\nusing this:\n  (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2) mod 2 =\n  (l - l mod 2) mod 2\n\ngoal (1 subgoal):\n 1. (l mod 2 - eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 mod 2) mod\n    2 =\n    (l mod 2 - l mod 2 mod 2) mod 2", "by (simp only: mod_diff_eq)"], ["proof (state)\nthis:\n  (l mod 2 - eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 mod 2) mod\n  2 =\n  (l mod 2 - l mod 2 mod 2) mod 2\n\ngoal (1 subgoal):\n 1. eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2 \\<and>\n    eval_dioph ks (map (\\<lambda>x. x div 2) xs) =\n    (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div\n    2 \\<Longrightarrow>\n    eval_dioph ks xs = l", "then"], ["proof (chain)\npicking this:\n  (l mod 2 - eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 mod 2) mod\n  2 =\n  (l mod 2 - l mod 2 mod 2) mod 2", "have eq1': \"(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2 = 0\""], ["proof (prove)\nusing this:\n  (l mod 2 - eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 mod 2) mod\n  2 =\n  (l mod 2 - l mod 2 mod 2) mod 2\n\ngoal (1 subgoal):\n 1. (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2 = 0", "by (simp add: mod_diff_eq)"], ["proof (state)\nthis:\n  (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2 = 0\n\ngoal (1 subgoal):\n 1. eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2 \\<and>\n    eval_dioph ks (map (\\<lambda>x. x div 2) xs) =\n    (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div\n    2 \\<Longrightarrow>\n    eval_dioph ks xs = l", "from eq2"], ["proof (chain)\npicking this:\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) =\n  (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2", "have\n    \"eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 +\n     (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2 =\n     (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2 * 2 +\n     (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2\""], ["proof (prove)\nusing this:\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) =\n  (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\n\ngoal (1 subgoal):\n 1. eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 +\n    (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2 =\n    (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2 * 2 +\n    (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2", "by simp"], ["proof (state)\nthis:\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 +\n  (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2 =\n  (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2 * 2 +\n  (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2\n\ngoal (1 subgoal):\n 1. eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2 \\<and>\n    eval_dioph ks (map (\\<lambda>x. x div 2) xs) =\n    (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div\n    2 \\<Longrightarrow>\n    eval_dioph ks xs = l", "then"], ["proof (chain)\npicking this:\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 +\n  (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2 =\n  (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2 * 2 +\n  (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2", "have\n    \"eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 +\n     (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2 =\n     l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\""], ["proof (prove)\nusing this:\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 +\n  (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2 =\n  (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2 * 2 +\n  (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2\n\ngoal (1 subgoal):\n 1. eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 +\n    (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2 =\n    l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)", "by simp"], ["proof (state)\nthis:\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 +\n  (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2 =\n  l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\n\ngoal (1 subgoal):\n 1. eval_dioph ks (map (\\<lambda>x. x mod 2) xs) mod 2 = l mod 2 \\<and>\n    eval_dioph ks (map (\\<lambda>x. x div 2) xs) =\n    (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div\n    2 \\<Longrightarrow>\n    eval_dioph ks xs = l", "with eq1' eval_dioph_div_mult [of _ 2]"], ["proof (chain)\npicking this:\n  (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2 = 0\n  eval_dioph ?ks (map (\\<lambda>x. x div 2) ?xs) * int 2 +\n  eval_dioph ?ks (map (\\<lambda>x. x mod 2) ?xs) =\n  eval_dioph ?ks ?xs\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 +\n  (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2 =\n  l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)", "show ?l"], ["proof (prove)\nusing this:\n  (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2 = 0\n  eval_dioph ?ks (map (\\<lambda>x. x div 2) ?xs) * int 2 +\n  eval_dioph ?ks (map (\\<lambda>x. x mod 2) ?xs) =\n  eval_dioph ?ks ?xs\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 +\n  (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2 =\n  l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\n\ngoal (1 subgoal):\n 1. eval_dioph ks xs = l", "by (simp add: eq_diff_eq)"], ["proof (state)\nthis:\n  eval_dioph ks xs = l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eval_dioph_ineq_div_mod:\n  \"(eval_dioph ks xs \\<le> l) =\n   (eval_dioph ks (map (\\<lambda>x. x div 2) xs) \\<le>\n      (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2)\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (eval_dioph ks xs \\<le> l) =\n    (eval_dioph ks (map (\\<lambda>x. x div 2) xs)\n     \\<le> (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. eval_dioph ks xs \\<le> l \\<Longrightarrow>\n    eval_dioph ks (map (\\<lambda>x. x div 2) xs)\n    \\<le> (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\n 2. eval_dioph ks (map (\\<lambda>x. x div 2) xs)\n    \\<le> (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div\n          2 \\<Longrightarrow>\n    eval_dioph ks xs \\<le> l", "assume ?l"], ["proof (state)\nthis:\n  eval_dioph ks xs \\<le> l\n\ngoal (2 subgoals):\n 1. eval_dioph ks xs \\<le> l \\<Longrightarrow>\n    eval_dioph ks (map (\\<lambda>x. x div 2) xs)\n    \\<le> (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\n 2. eval_dioph ks (map (\\<lambda>x. x div 2) xs)\n    \\<le> (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div\n          2 \\<Longrightarrow>\n    eval_dioph ks xs \\<le> l", "with eval_dioph_div_mult [symmetric, of ks xs 2]"], ["proof (chain)\npicking this:\n  eval_dioph ks xs =\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) * int 2 +\n  eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\n  eval_dioph ks xs \\<le> l", "have \"eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 + eval_dioph ks (map (\\<lambda>x. x mod 2) xs) \\<le> l\""], ["proof (prove)\nusing this:\n  eval_dioph ks xs =\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) * int 2 +\n  eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\n  eval_dioph ks xs \\<le> l\n\ngoal (1 subgoal):\n 1. eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 +\n    eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\n    \\<le> l", "by simp"], ["proof (state)\nthis:\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 +\n  eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\n  \\<le> l\n\ngoal (2 subgoals):\n 1. eval_dioph ks xs \\<le> l \\<Longrightarrow>\n    eval_dioph ks (map (\\<lambda>x. x div 2) xs)\n    \\<le> (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\n 2. eval_dioph ks (map (\\<lambda>x. x div 2) xs)\n    \\<le> (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div\n          2 \\<Longrightarrow>\n    eval_dioph ks xs \\<le> l", "then"], ["proof (chain)\npicking this:\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 +\n  eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\n  \\<le> l", "have \"eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 \\<le> l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\""], ["proof (prove)\nusing this:\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 +\n  eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\n  \\<le> l\n\ngoal (1 subgoal):\n 1. eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2\n    \\<le> l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)", "by (simp add: le_diff_eq)"], ["proof (state)\nthis:\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2\n  \\<le> l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\n\ngoal (2 subgoals):\n 1. eval_dioph ks xs \\<le> l \\<Longrightarrow>\n    eval_dioph ks (map (\\<lambda>x. x div 2) xs)\n    \\<le> (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\n 2. eval_dioph ks (map (\\<lambda>x. x div 2) xs)\n    \\<le> (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div\n          2 \\<Longrightarrow>\n    eval_dioph ks xs \\<le> l", "then"], ["proof (chain)\npicking this:\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2\n  \\<le> l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)", "have \"(eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2) div 2 \\<le>\n    (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\""], ["proof (prove)\nusing this:\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2\n  \\<le> l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\n\ngoal (1 subgoal):\n 1. eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 div 2\n    \\<le> (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2", "by (rule zdiv_mono1) simp"], ["proof (state)\nthis:\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 div 2\n  \\<le> (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\n\ngoal (2 subgoals):\n 1. eval_dioph ks xs \\<le> l \\<Longrightarrow>\n    eval_dioph ks (map (\\<lambda>x. x div 2) xs)\n    \\<le> (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\n 2. eval_dioph ks (map (\\<lambda>x. x div 2) xs)\n    \\<le> (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div\n          2 \\<Longrightarrow>\n    eval_dioph ks xs \\<le> l", "then"], ["proof (chain)\npicking this:\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 div 2\n  \\<le> (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2", "show ?r"], ["proof (prove)\nusing this:\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 div 2\n  \\<le> (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\n\ngoal (1 subgoal):\n 1. eval_dioph ks (map (\\<lambda>x. x div 2) xs)\n    \\<le> (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2", "by simp"], ["proof (state)\nthis:\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs)\n  \\<le> (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\n\ngoal (1 subgoal):\n 1. eval_dioph ks (map (\\<lambda>x. x div 2) xs)\n    \\<le> (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div\n          2 \\<Longrightarrow>\n    eval_dioph ks xs \\<le> l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. eval_dioph ks (map (\\<lambda>x. x div 2) xs)\n    \\<le> (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div\n          2 \\<Longrightarrow>\n    eval_dioph ks xs \\<le> l", "assume ?r"], ["proof (state)\nthis:\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs)\n  \\<le> (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\n\ngoal (1 subgoal):\n 1. eval_dioph ks (map (\\<lambda>x. x div 2) xs)\n    \\<le> (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div\n          2 \\<Longrightarrow>\n    eval_dioph ks xs \\<le> l", "have \"eval_dioph ks xs \\<le> eval_dioph ks xs +\n    (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_dioph ks xs\n    \\<le> eval_dioph ks xs +\n          (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2", "by simp"], ["proof (state)\nthis:\n  eval_dioph ks xs\n  \\<le> eval_dioph ks xs +\n        (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2\n\ngoal (1 subgoal):\n 1. eval_dioph ks (map (\\<lambda>x. x div 2) xs)\n    \\<le> (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div\n          2 \\<Longrightarrow>\n    eval_dioph ks xs \\<le> l", "also"], ["proof (state)\nthis:\n  eval_dioph ks xs\n  \\<le> eval_dioph ks xs +\n        (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2\n\ngoal (1 subgoal):\n 1. eval_dioph ks (map (\\<lambda>x. x div 2) xs)\n    \\<le> (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div\n          2 \\<Longrightarrow>\n    eval_dioph ks xs \\<le> l", "{"], ["proof (state)\nthis:\n  eval_dioph ks xs\n  \\<le> eval_dioph ks xs +\n        (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2\n\ngoal (1 subgoal):\n 1. eval_dioph ks (map (\\<lambda>x. x div 2) xs)\n    \\<le> (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div\n          2 \\<Longrightarrow>\n    eval_dioph ks xs \\<le> l", "from \\<open>?r\\<close>"], ["proof (chain)\npicking this:\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs)\n  \\<le> (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2", "have \"eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 \\<le>\n    (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2 * 2\""], ["proof (prove)\nusing this:\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs)\n  \\<le> (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\n\ngoal (1 subgoal):\n 1. eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2\n    \\<le> (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2 * 2", "by simp"], ["proof (state)\nthis:\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2\n  \\<le> (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2 * 2\n\ngoal (1 subgoal):\n 1. eval_dioph ks (map (\\<lambda>x. x div 2) xs)\n    \\<le> (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div\n          2 \\<Longrightarrow>\n    eval_dioph ks xs \\<le> l", "also"], ["proof (state)\nthis:\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2\n  \\<le> (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2 * 2\n\ngoal (1 subgoal):\n 1. eval_dioph ks (map (\\<lambda>x. x div 2) xs)\n    \\<le> (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div\n          2 \\<Longrightarrow>\n    eval_dioph ks xs \\<le> l", "have \"\\<dots> = l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs) -\n    (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2 * 2 =\n    l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs) -\n    (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2", "by (simp add: eq_diff_eq)"], ["proof (state)\nthis:\n  (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2 * 2 =\n  l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs) -\n  (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2\n\ngoal (1 subgoal):\n 1. eval_dioph ks (map (\\<lambda>x. x div 2) xs)\n    \\<le> (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div\n          2 \\<Longrightarrow>\n    eval_dioph ks xs \\<le> l", "finally"], ["proof (chain)\npicking this:\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2\n  \\<le> l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs) -\n        (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2", "have \"(eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 +\n    eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) +\n    (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2 \\<le> l\""], ["proof (prove)\nusing this:\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2\n  \\<le> l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs) -\n        (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2\n\ngoal (1 subgoal):\n 1. eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 +\n    eval_dioph ks (map (\\<lambda>x. x mod 2) xs) +\n    (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2\n    \\<le> l", "by simp"], ["proof (state)\nthis:\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 +\n  eval_dioph ks (map (\\<lambda>x. x mod 2) xs) +\n  (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2\n  \\<le> l\n\ngoal (1 subgoal):\n 1. eval_dioph ks (map (\\<lambda>x. x div 2) xs)\n    \\<le> (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div\n          2 \\<Longrightarrow>\n    eval_dioph ks xs \\<le> l", "with eval_dioph_div_mult [of _ 2]"], ["proof (chain)\npicking this:\n  eval_dioph ?ks (map (\\<lambda>x. x div 2) ?xs) * int 2 +\n  eval_dioph ?ks (map (\\<lambda>x. x mod 2) ?xs) =\n  eval_dioph ?ks ?xs\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 +\n  eval_dioph ks (map (\\<lambda>x. x mod 2) xs) +\n  (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2\n  \\<le> l", "have \"eval_dioph ks xs +\n    (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2 \\<le> l\""], ["proof (prove)\nusing this:\n  eval_dioph ?ks (map (\\<lambda>x. x div 2) ?xs) * int 2 +\n  eval_dioph ?ks (map (\\<lambda>x. x mod 2) ?xs) =\n  eval_dioph ?ks ?xs\n  eval_dioph ks (map (\\<lambda>x. x div 2) xs) * 2 +\n  eval_dioph ks (map (\\<lambda>x. x mod 2) xs) +\n  (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2\n  \\<le> l\n\ngoal (1 subgoal):\n 1. eval_dioph ks xs +\n    (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2\n    \\<le> l", "by simp"], ["proof (state)\nthis:\n  eval_dioph ks xs +\n  (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2\n  \\<le> l\n\ngoal (1 subgoal):\n 1. eval_dioph ks (map (\\<lambda>x. x div 2) xs)\n    \\<le> (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div\n          2 \\<Longrightarrow>\n    eval_dioph ks xs \\<le> l", "}"], ["proof (state)\nthis:\n  eval_dioph ks xs +\n  (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2\n  \\<le> l\n\ngoal (1 subgoal):\n 1. eval_dioph ks (map (\\<lambda>x. x div 2) xs)\n    \\<le> (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div\n          2 \\<Longrightarrow>\n    eval_dioph ks xs \\<le> l", "finally"], ["proof (chain)\npicking this:\n  eval_dioph ks xs \\<le> l", "show ?l"], ["proof (prove)\nusing this:\n  eval_dioph ks xs \\<le> l\n\ngoal (1 subgoal):\n 1. eval_dioph ks xs \\<le> l", "."], ["proof (state)\nthis:\n  eval_dioph ks xs \\<le> l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_list_abs_ge_0: \"(0::int) \\<le> sum_list (map abs ks)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> sum_list (map abs ks)", "by (induct ks) simp_all"], ["", "lemma zmult_div_aux1:\n  assumes b: \"b \\<noteq> 0\"\n  shows \"(a - a mod b) div b = (a::int) div b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a - a mod b) div b = a div b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (a - a mod b) div b = a div b", "from minus_mod_eq_mult_div [symmetric, of b a]"], ["proof (chain)\npicking this:\n  b * (a div b) = a - a mod b", "have \"(b * (a div b)) div b = (a - a mod b) div b\""], ["proof (prove)\nusing this:\n  b * (a div b) = a - a mod b\n\ngoal (1 subgoal):\n 1. b * (a div b) div b = (a - a mod b) div b", "by simp"], ["proof (state)\nthis:\n  b * (a div b) div b = (a - a mod b) div b\n\ngoal (1 subgoal):\n 1. (a - a mod b) div b = a div b", "with b"], ["proof (chain)\npicking this:\n  b \\<noteq> 0\n  b * (a div b) div b = (a - a mod b) div b", "show ?thesis"], ["proof (prove)\nusing this:\n  b \\<noteq> 0\n  b * (a div b) div b = (a - a mod b) div b\n\ngoal (1 subgoal):\n 1. (a - a mod b) div b = a div b", "by simp"], ["proof (state)\nthis:\n  (a - a mod b) div b = a div b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zmult_div_aux2:\n  assumes b: \"b \\<noteq> 0\"\n  shows \"((a::int) - a mod b) mod b = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a - a mod b) mod b = 0", "using b minus_mod_eq_mult_div [symmetric, of b a, symmetric]"], ["proof (prove)\nusing this:\n  b \\<noteq> 0\n  a - a mod b = b * (a div b)\n\ngoal (1 subgoal):\n 1. (a - a mod b) mod b = 0", "by simp"], ["", "lemma div_abs_eq:\n  assumes mod: \"(a::int) mod b = 0\"\n  and b: \"0 < b\"\n  shows \"\\<bar>a div b\\<bar> = \\<bar>a\\<bar> div b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>a div b\\<bar> = \\<bar>a\\<bar> div b", "proof (cases \"0 \\<le> a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> a \\<Longrightarrow> \\<bar>a div b\\<bar> = \\<bar>a\\<bar> div b\n 2. \\<not> 0 \\<le> a \\<Longrightarrow>\n    \\<bar>a div b\\<bar> = \\<bar>a\\<bar> div b", "case True"], ["proof (state)\nthis:\n  0 \\<le> a\n\ngoal (2 subgoals):\n 1. 0 \\<le> a \\<Longrightarrow> \\<bar>a div b\\<bar> = \\<bar>a\\<bar> div b\n 2. \\<not> 0 \\<le> a \\<Longrightarrow>\n    \\<bar>a div b\\<bar> = \\<bar>a\\<bar> div b", "with pos_imp_zdiv_nonneg_iff [OF b]"], ["proof (chain)\npicking this:\n  (0 \\<le> ?a div b) = (0 \\<le> ?a)\n  0 \\<le> a", "show ?thesis"], ["proof (prove)\nusing this:\n  (0 \\<le> ?a div b) = (0 \\<le> ?a)\n  0 \\<le> a\n\ngoal (1 subgoal):\n 1. \\<bar>a div b\\<bar> = \\<bar>a\\<bar> div b", "by auto"], ["proof (state)\nthis:\n  \\<bar>a div b\\<bar> = \\<bar>a\\<bar> div b\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> a \\<Longrightarrow>\n    \\<bar>a div b\\<bar> = \\<bar>a\\<bar> div b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> a \\<Longrightarrow>\n    \\<bar>a div b\\<bar> = \\<bar>a\\<bar> div b", "from b"], ["proof (chain)\npicking this:\n  0 < b", "have \"b \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < b\n\ngoal (1 subgoal):\n 1. b \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> a \\<Longrightarrow>\n    \\<bar>a div b\\<bar> = \\<bar>a\\<bar> div b", "case False"], ["proof (state)\nthis:\n  \\<not> 0 \\<le> a\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> a \\<Longrightarrow>\n    \\<bar>a div b\\<bar> = \\<bar>a\\<bar> div b", "then"], ["proof (chain)\npicking this:\n  \\<not> 0 \\<le> a", "have \"a < 0\""], ["proof (prove)\nusing this:\n  \\<not> 0 \\<le> a\n\ngoal (1 subgoal):\n 1. a < 0", "by auto"], ["proof (state)\nthis:\n  a < 0\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> a \\<Longrightarrow>\n    \\<bar>a div b\\<bar> = \\<bar>a\\<bar> div b", "have \"\\<bar>a div b\\<bar> = - (a div b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>a div b\\<bar> = - (a div b)", "by (simp add: div_neg_pos_less0 [OF \\<open>a < 0\\<close> b] zabs_def)"], ["proof (state)\nthis:\n  \\<bar>a div b\\<bar> = - (a div b)\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> a \\<Longrightarrow>\n    \\<bar>a div b\\<bar> = \\<bar>a\\<bar> div b", "with abs_of_neg [OF \\<open>a < 0\\<close>] zdiv_zminus1_eq_if [OF \\<open>b \\<noteq> 0\\<close>] mod"], ["proof (chain)\npicking this:\n  \\<bar>a\\<bar> = - a\n  - ?a div b = (if ?a mod b = 0 then - (?a div b) else - (?a div b) - 1)\n  a mod b = 0\n  \\<bar>a div b\\<bar> = - (a div b)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>a\\<bar> = - a\n  - ?a div b = (if ?a mod b = 0 then - (?a div b) else - (?a div b) - 1)\n  a mod b = 0\n  \\<bar>a div b\\<bar> = - (a div b)\n\ngoal (1 subgoal):\n 1. \\<bar>a div b\\<bar> = \\<bar>a\\<bar> div b", "by simp"], ["proof (state)\nthis:\n  \\<bar>a div b\\<bar> = \\<bar>a\\<bar> div b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma add_div_trivial: \"0 \\<le> c \\<Longrightarrow> c < b \\<Longrightarrow> ((a::int) * b + c) div b = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> c; c < b\\<rbrakk>\n    \\<Longrightarrow> (a * b + c) div b = a", "by (simp add: div_add1_eq div_pos_pos_trivial)"], ["", "lemma dioph_rhs_bound:\n  \"\\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar> \\<le> max \\<bar>l\\<bar> (\\<Sum>k\\<leftarrow>ks. \\<bar>k\\<bar>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "have \"\\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar> =\n    \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs) -\n     (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2) div 2\\<bar>\"\n    (is \"_ = \\<bar>(_ - ?r) div 2\\<bar>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar> =\n    \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs) -\n           (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2) div\n          2\\<bar>", "by (simp add: zmult_div_aux1)"], ["proof (state)\nthis:\n  \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar> =\n  \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs) -\n         (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2) div\n        2\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "also"], ["proof (state)\nthis:\n  \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar> =\n  \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs) -\n         (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2) div\n        2\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "have \"\\<dots> = \\<bar>l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs) - ?r\\<bar> div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs) -\n           (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2) div\n          2\\<bar> =\n    \\<bar>l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs) -\n          (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2\\<bar> div\n    2", "by (simp add: zmult_div_aux2 div_abs_eq)"], ["proof (state)\nthis:\n  \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs) -\n         (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2) div\n        2\\<bar> =\n  \\<bar>l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs) -\n        (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2\\<bar> div\n  2\n\ngoal (1 subgoal):\n 1. \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "also"], ["proof (state)\nthis:\n  \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs) -\n         (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2) div\n        2\\<bar> =\n  \\<bar>l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs) -\n        (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2\\<bar> div\n  2\n\ngoal (1 subgoal):\n 1. \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "have \"\\<bar>l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs) - ?r\\<bar> \\<le>\n    \\<bar>l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar> + \\<bar>?r\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs) -\n          (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2\\<bar>\n    \\<le> \\<bar>l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar> +\n          \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod\n                2\\<bar>", "by (rule abs_triangle_ineq4)"], ["proof (state)\nthis:\n  \\<bar>l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs) -\n        (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2\\<bar>\n  \\<le> \\<bar>l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar> +\n        \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "also"], ["proof (state)\nthis:\n  \\<bar>l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs) -\n        (l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2\\<bar>\n  \\<le> \\<bar>l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar> +\n        \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "have \"\\<bar>l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar> \\<le>\n    \\<bar>l\\<bar> + \\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>\n    \\<le> \\<bar>l\\<bar> +\n          \\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>", "by (rule abs_triangle_ineq4)"], ["proof (state)\nthis:\n  \\<bar>l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>\n  \\<le> \\<bar>l\\<bar> +\n        \\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "also"], ["proof (state)\nthis:\n  \\<bar>l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>\n  \\<le> \\<bar>l\\<bar> +\n        \\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "have \"\\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar> \\<le> (\\<Sum>k\\<leftarrow>ks. \\<bar>k\\<bar>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>\n    \\<le> sum_list (map abs ks)", "proof (induct ks xs rule: eval_dioph.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>k ks x xs.\n       \\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>\n       \\<le> sum_list (map abs ks) \\<Longrightarrow>\n       \\<bar>eval_dioph (k # ks) (map (\\<lambda>x. x mod 2) (x # xs))\\<bar>\n       \\<le> sum_list (map abs (k # ks))\n 2. \\<And>xs.\n       \\<bar>eval_dioph [] (map (\\<lambda>x. x mod 2) xs)\\<bar>\n       \\<le> sum_list (map abs [])\n 3. \\<And>ks.\n       \\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) [])\\<bar>\n       \\<le> sum_list (map abs ks)", "case (1 k ks x xs)"], ["proof (state)\nthis:\n  \\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>\n  \\<le> sum_list (map abs ks)\n\ngoal (3 subgoals):\n 1. \\<And>k ks x xs.\n       \\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>\n       \\<le> sum_list (map abs ks) \\<Longrightarrow>\n       \\<bar>eval_dioph (k # ks) (map (\\<lambda>x. x mod 2) (x # xs))\\<bar>\n       \\<le> sum_list (map abs (k # ks))\n 2. \\<And>xs.\n       \\<bar>eval_dioph [] (map (\\<lambda>x. x mod 2) xs)\\<bar>\n       \\<le> sum_list (map abs [])\n 3. \\<And>ks.\n       \\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) [])\\<bar>\n       \\<le> sum_list (map abs ks)", "have \"\\<bar>k * int (x mod 2) + eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar> \\<le>\n      \\<bar>k * int (x mod 2)\\<bar> + \\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>k * int (x mod 2) +\n          eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>\n    \\<le> \\<bar>k * int (x mod 2)\\<bar> +\n          \\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>", "by (rule abs_triangle_ineq)"], ["proof (state)\nthis:\n  \\<bar>k * int (x mod 2) +\n        eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>\n  \\<le> \\<bar>k * int (x mod 2)\\<bar> +\n        \\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>\n\ngoal (3 subgoals):\n 1. \\<And>k ks x xs.\n       \\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>\n       \\<le> sum_list (map abs ks) \\<Longrightarrow>\n       \\<bar>eval_dioph (k # ks) (map (\\<lambda>x. x mod 2) (x # xs))\\<bar>\n       \\<le> sum_list (map abs (k # ks))\n 2. \\<And>xs.\n       \\<bar>eval_dioph [] (map (\\<lambda>x. x mod 2) xs)\\<bar>\n       \\<le> sum_list (map abs [])\n 3. \\<And>ks.\n       \\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) [])\\<bar>\n       \\<le> sum_list (map abs ks)", "also"], ["proof (state)\nthis:\n  \\<bar>k * int (x mod 2) +\n        eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>\n  \\<le> \\<bar>k * int (x mod 2)\\<bar> +\n        \\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>\n\ngoal (3 subgoals):\n 1. \\<And>k ks x xs.\n       \\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>\n       \\<le> sum_list (map abs ks) \\<Longrightarrow>\n       \\<bar>eval_dioph (k # ks) (map (\\<lambda>x. x mod 2) (x # xs))\\<bar>\n       \\<le> sum_list (map abs (k # ks))\n 2. \\<And>xs.\n       \\<bar>eval_dioph [] (map (\\<lambda>x. x mod 2) xs)\\<bar>\n       \\<le> sum_list (map abs [])\n 3. \\<And>ks.\n       \\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) [])\\<bar>\n       \\<le> sum_list (map abs ks)", "have \"\\<bar>k * int (x mod 2)\\<bar> \\<le> \\<bar>k\\<bar> * \\<bar>int (x mod 2)\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>k * int (x mod 2)\\<bar>\n    \\<le> \\<bar>k\\<bar> * \\<bar>int (x mod 2)\\<bar>", "by (simp add: abs_mult)"], ["proof (state)\nthis:\n  \\<bar>k * int (x mod 2)\\<bar>\n  \\<le> \\<bar>k\\<bar> * \\<bar>int (x mod 2)\\<bar>\n\ngoal (3 subgoals):\n 1. \\<And>k ks x xs.\n       \\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>\n       \\<le> sum_list (map abs ks) \\<Longrightarrow>\n       \\<bar>eval_dioph (k # ks) (map (\\<lambda>x. x mod 2) (x # xs))\\<bar>\n       \\<le> sum_list (map abs (k # ks))\n 2. \\<And>xs.\n       \\<bar>eval_dioph [] (map (\\<lambda>x. x mod 2) xs)\\<bar>\n       \\<le> sum_list (map abs [])\n 3. \\<And>ks.\n       \\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) [])\\<bar>\n       \\<le> sum_list (map abs ks)", "also"], ["proof (state)\nthis:\n  \\<bar>k * int (x mod 2)\\<bar>\n  \\<le> \\<bar>k\\<bar> * \\<bar>int (x mod 2)\\<bar>\n\ngoal (3 subgoals):\n 1. \\<And>k ks x xs.\n       \\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>\n       \\<le> sum_list (map abs ks) \\<Longrightarrow>\n       \\<bar>eval_dioph (k # ks) (map (\\<lambda>x. x mod 2) (x # xs))\\<bar>\n       \\<le> sum_list (map abs (k # ks))\n 2. \\<And>xs.\n       \\<bar>eval_dioph [] (map (\\<lambda>x. x mod 2) xs)\\<bar>\n       \\<le> sum_list (map abs [])\n 3. \\<And>ks.\n       \\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) [])\\<bar>\n       \\<le> sum_list (map abs ks)", "have \"\\<bar>int (x mod 2)\\<bar> \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>int (x mod 2)\\<bar> \\<le> 1", "by simp"], ["proof (state)\nthis:\n  \\<bar>int (x mod 2)\\<bar> \\<le> 1\n\ngoal (3 subgoals):\n 1. \\<And>k ks x xs.\n       \\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>\n       \\<le> sum_list (map abs ks) \\<Longrightarrow>\n       \\<bar>eval_dioph (k # ks) (map (\\<lambda>x. x mod 2) (x # xs))\\<bar>\n       \\<le> sum_list (map abs (k # ks))\n 2. \\<And>xs.\n       \\<bar>eval_dioph [] (map (\\<lambda>x. x mod 2) xs)\\<bar>\n       \\<le> sum_list (map abs [])\n 3. \\<And>ks.\n       \\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) [])\\<bar>\n       \\<le> sum_list (map abs ks)", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              x + \\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>\n              \\<le> y +\n                    \\<bar>eval_dioph ks\n                           (map (\\<lambda>x. x mod 2) xs)\\<bar>;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      \\<bar>k\\<bar> * x +\n      \\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>\n      \\<le> \\<bar>k\\<bar> * y +\n            \\<bar>eval_dioph ks\n                   (map (\\<lambda>x. x mod 2) xs)\\<bar>\\<rbrakk>\n  \\<Longrightarrow> \\<bar>k * int (x mod 2) +\n                          eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>\n                    \\<le> \\<bar>k\\<bar> * 1 +\n                          \\<bar>eval_dioph ks\n                                 (map (\\<lambda>x. x mod 2) xs)\\<bar>", "have \"\\<bar>k * int (x mod 2) + eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar> \\<le>\n      \\<bar>k\\<bar> + \\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              x + \\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>\n              \\<le> y +\n                    \\<bar>eval_dioph ks\n                           (map (\\<lambda>x. x mod 2) xs)\\<bar>;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      \\<bar>k\\<bar> * x +\n      \\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>\n      \\<le> \\<bar>k\\<bar> * y +\n            \\<bar>eval_dioph ks\n                   (map (\\<lambda>x. x mod 2) xs)\\<bar>\\<rbrakk>\n  \\<Longrightarrow> \\<bar>k * int (x mod 2) +\n                          eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>\n                    \\<le> \\<bar>k\\<bar> * 1 +\n                          \\<bar>eval_dioph ks\n                                 (map (\\<lambda>x. x mod 2) xs)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>k * int (x mod 2) +\n          eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>\n    \\<le> \\<bar>k\\<bar> +\n          \\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>", "by (auto simp add: mult_left_mono)"], ["proof (state)\nthis:\n  \\<bar>k * int (x mod 2) +\n        eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>\n  \\<le> \\<bar>k\\<bar> +\n        \\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>\n\ngoal (3 subgoals):\n 1. \\<And>k ks x xs.\n       \\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>\n       \\<le> sum_list (map abs ks) \\<Longrightarrow>\n       \\<bar>eval_dioph (k # ks) (map (\\<lambda>x. x mod 2) (x # xs))\\<bar>\n       \\<le> sum_list (map abs (k # ks))\n 2. \\<And>xs.\n       \\<bar>eval_dioph [] (map (\\<lambda>x. x mod 2) xs)\\<bar>\n       \\<le> sum_list (map abs [])\n 3. \\<And>ks.\n       \\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) [])\\<bar>\n       \\<le> sum_list (map abs ks)", "with 1"], ["proof (chain)\npicking this:\n  \\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>\n  \\<le> sum_list (map abs ks)\n  \\<bar>k * int (x mod 2) +\n        eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>\n  \\<le> \\<bar>k\\<bar> +\n        \\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>", "show ?case"], ["proof (prove)\nusing this:\n  \\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>\n  \\<le> sum_list (map abs ks)\n  \\<bar>k * int (x mod 2) +\n        eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>\n  \\<le> \\<bar>k\\<bar> +\n        \\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>eval_dioph (k # ks) (map (\\<lambda>x. x mod 2) (x # xs))\\<bar>\n    \\<le> sum_list (map abs (k # ks))", "by simp"], ["proof (state)\nthis:\n  \\<bar>eval_dioph (k # ks) (map (\\<lambda>x. x mod 2) (x # xs))\\<bar>\n  \\<le> sum_list (map abs (k # ks))\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<bar>eval_dioph [] (map (\\<lambda>x. x mod 2) xs)\\<bar>\n       \\<le> sum_list (map abs [])\n 2. \\<And>ks.\n       \\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) [])\\<bar>\n       \\<le> sum_list (map abs ks)", "qed (simp_all add: sum_list_abs_ge_0)"], ["proof (state)\nthis:\n  \\<bar>eval_dioph ks (map (\\<lambda>x. x mod 2) xs)\\<bar>\n  \\<le> sum_list (map abs ks)\n\ngoal (1 subgoal):\n 1. \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y. x \\<le> y \\<Longrightarrow> x div 2 \\<le> y div 2;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      (x +\n       \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod\n             2\\<bar>) div\n      2\n      \\<le> (y +\n             \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod\n                   2\\<bar>) div\n            2;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      (\\<bar>l\\<bar> + x +\n       \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod\n             2\\<bar>) div\n      2\n      \\<le> (\\<bar>l\\<bar> + y +\n             \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod\n                   2\\<bar>) div\n            2\\<rbrakk>\n  \\<Longrightarrow> \\<bar>(l -\n                           eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div\n                          2\\<bar>\n                    \\<le> (\\<bar>l\\<bar> + sum_list (map abs ks) +\n                           \\<bar>(l -\n                                  eval_dioph ks\n                                   (map (\\<lambda>x. x mod 2) xs)) mod\n                                 2\\<bar>) div\n                          2", "have ineq: \"\\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar> \\<le>\n    (\\<bar>l\\<bar> + (\\<Sum>k\\<leftarrow>ks. \\<bar>k\\<bar>) + \\<bar>?r\\<bar>) div 2\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y. x \\<le> y \\<Longrightarrow> x div 2 \\<le> y div 2;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      (x +\n       \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod\n             2\\<bar>) div\n      2\n      \\<le> (y +\n             \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod\n                   2\\<bar>) div\n            2;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      (\\<bar>l\\<bar> + x +\n       \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod\n             2\\<bar>) div\n      2\n      \\<le> (\\<bar>l\\<bar> + y +\n             \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod\n                   2\\<bar>) div\n            2\\<rbrakk>\n  \\<Longrightarrow> \\<bar>(l -\n                           eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div\n                          2\\<bar>\n                    \\<le> (\\<bar>l\\<bar> + sum_list (map abs ks) +\n                           \\<bar>(l -\n                                  eval_dioph ks\n                                   (map (\\<lambda>x. x mod 2) xs)) mod\n                                 2\\<bar>) div\n                          2\n\ngoal (1 subgoal):\n 1. \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> (\\<bar>l\\<bar> + sum_list (map abs ks) +\n           \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod\n                 2\\<bar>) div\n          2", "by (simp add: zdiv_mono1)"], ["proof (state)\nthis:\n  \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n  \\<le> (\\<bar>l\\<bar> + sum_list (map abs ks) +\n         \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod\n               2\\<bar>) div\n        2\n\ngoal (1 subgoal):\n 1. \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "proof (cases \"(\\<Sum>k\\<leftarrow>ks. \\<bar>k\\<bar>) \\<le> \\<bar>l\\<bar>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))\n 2. \\<not> sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "case True"], ["proof (state)\nthis:\n  sum_list (map abs ks) \\<le> \\<bar>l\\<bar>\n\ngoal (2 subgoals):\n 1. sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))\n 2. \\<not> sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "note ineq"], ["proof (state)\nthis:\n  \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n  \\<le> (\\<bar>l\\<bar> + sum_list (map abs ks) +\n         \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod\n               2\\<bar>) div\n        2\n\ngoal (2 subgoals):\n 1. sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))\n 2. \\<not> sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "also"], ["proof (state)\nthis:\n  \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n  \\<le> (\\<bar>l\\<bar> + sum_list (map abs ks) +\n         \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod\n               2\\<bar>) div\n        2\n\ngoal (2 subgoals):\n 1. sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))\n 2. \\<not> sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "from True"], ["proof (chain)\npicking this:\n  sum_list (map abs ks) \\<le> \\<bar>l\\<bar>", "have \"(\\<bar>l\\<bar> + (\\<Sum>k\\<leftarrow>ks. \\<bar>k\\<bar>) + \\<bar>?r\\<bar>) div 2 \\<le> (\\<bar>l\\<bar> * 2 + \\<bar>?r\\<bar>) div 2\""], ["proof (prove)\nusing this:\n  sum_list (map abs ks) \\<le> \\<bar>l\\<bar>\n\ngoal (1 subgoal):\n 1. (\\<bar>l\\<bar> + sum_list (map abs ks) +\n     \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod\n           2\\<bar>) div\n    2\n    \\<le> (\\<bar>l\\<bar> * 2 +\n           \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod\n                 2\\<bar>) div\n          2", "by (simp add: zdiv_mono1)"], ["proof (state)\nthis:\n  (\\<bar>l\\<bar> + sum_list (map abs ks) +\n   \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2\\<bar>) div\n  2\n  \\<le> (\\<bar>l\\<bar> * 2 +\n         \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod\n               2\\<bar>) div\n        2\n\ngoal (2 subgoals):\n 1. sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))\n 2. \\<not> sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "also"], ["proof (state)\nthis:\n  (\\<bar>l\\<bar> + sum_list (map abs ks) +\n   \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2\\<bar>) div\n  2\n  \\<le> (\\<bar>l\\<bar> * 2 +\n         \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod\n               2\\<bar>) div\n        2\n\ngoal (2 subgoals):\n 1. sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))\n 2. \\<not> sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "have \"\\<dots> = \\<bar>l\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<bar>l\\<bar> * 2 +\n     \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod\n           2\\<bar>) div\n    2 =\n    \\<bar>l\\<bar>", "by (simp add: add_div_trivial)"], ["proof (state)\nthis:\n  (\\<bar>l\\<bar> * 2 +\n   \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2\\<bar>) div\n  2 =\n  \\<bar>l\\<bar>\n\ngoal (2 subgoals):\n 1. sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))\n 2. \\<not> sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "finally"], ["proof (chain)\npicking this:\n  \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n  \\<le> \\<bar>l\\<bar>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n  \\<le> \\<bar>l\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "by simp"], ["proof (state)\nthis:\n  \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n  \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))\n\ngoal (1 subgoal):\n 1. \\<not> sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "case False"], ["proof (state)\nthis:\n  \\<not> sum_list (map abs ks) \\<le> \\<bar>l\\<bar>\n\ngoal (1 subgoal):\n 1. \\<not> sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "note ineq"], ["proof (state)\nthis:\n  \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n  \\<le> (\\<bar>l\\<bar> + sum_list (map abs ks) +\n         \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod\n               2\\<bar>) div\n        2\n\ngoal (1 subgoal):\n 1. \\<not> sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "also"], ["proof (state)\nthis:\n  \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n  \\<le> (\\<bar>l\\<bar> + sum_list (map abs ks) +\n         \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod\n               2\\<bar>) div\n        2\n\ngoal (1 subgoal):\n 1. \\<not> sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "from False"], ["proof (chain)\npicking this:\n  \\<not> sum_list (map abs ks) \\<le> \\<bar>l\\<bar>", "have \"(\\<bar>l\\<bar> + (\\<Sum>k\\<leftarrow>ks. \\<bar>k\\<bar>) + \\<bar>?r\\<bar>) div 2 \\<le> ((\\<Sum>k\\<leftarrow>ks. \\<bar>k\\<bar>) * 2 + \\<bar>?r\\<bar>) div 2\""], ["proof (prove)\nusing this:\n  \\<not> sum_list (map abs ks) \\<le> \\<bar>l\\<bar>\n\ngoal (1 subgoal):\n 1. (\\<bar>l\\<bar> + sum_list (map abs ks) +\n     \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod\n           2\\<bar>) div\n    2\n    \\<le> (sum_list (map abs ks) * 2 +\n           \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod\n                 2\\<bar>) div\n          2", "by (simp add: zdiv_mono1)"], ["proof (state)\nthis:\n  (\\<bar>l\\<bar> + sum_list (map abs ks) +\n   \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2\\<bar>) div\n  2\n  \\<le> (sum_list (map abs ks) * 2 +\n         \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod\n               2\\<bar>) div\n        2\n\ngoal (1 subgoal):\n 1. \\<not> sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "also"], ["proof (state)\nthis:\n  (\\<bar>l\\<bar> + sum_list (map abs ks) +\n   \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2\\<bar>) div\n  2\n  \\<le> (sum_list (map abs ks) * 2 +\n         \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod\n               2\\<bar>) div\n        2\n\ngoal (1 subgoal):\n 1. \\<not> sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "have \"\\<dots> = (\\<Sum>k\\<leftarrow>ks. \\<bar>k\\<bar>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sum_list (map abs ks) * 2 +\n     \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod\n           2\\<bar>) div\n    2 =\n    sum_list (map abs ks)", "by (simp add: add_div_trivial)"], ["proof (state)\nthis:\n  (sum_list (map abs ks) * 2 +\n   \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) mod 2\\<bar>) div\n  2 =\n  sum_list (map abs ks)\n\ngoal (1 subgoal):\n 1. \\<not> sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "finally"], ["proof (chain)\npicking this:\n  \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n  \\<le> sum_list (map abs ks)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n  \\<le> sum_list (map abs ks)\n\ngoal (1 subgoal):\n 1. \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "by simp"], ["proof (state)\nthis:\n  \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n  \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<bar>(l - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n  \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dioph_rhs_invariant:\n  assumes m: \"\\<bar>m\\<bar> \\<le> max \\<bar>l\\<bar> (\\<Sum>k\\<leftarrow>ks. \\<bar>k\\<bar>)\"\n  shows \"\\<bar>(m - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar> \\<le> max \\<bar>l\\<bar> (\\<Sum>k\\<leftarrow>ks. \\<bar>k\\<bar>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>(m - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "proof (cases \"(\\<Sum>k\\<leftarrow>ks. \\<bar>k\\<bar>) \\<le> \\<bar>l\\<bar>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(m - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))\n 2. \\<not> sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(m - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "case True"], ["proof (state)\nthis:\n  sum_list (map abs ks) \\<le> \\<bar>l\\<bar>\n\ngoal (2 subgoals):\n 1. sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(m - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))\n 2. \\<not> sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(m - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "have \"\\<bar>(m - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar> \\<le> max \\<bar>m\\<bar> (\\<Sum>k\\<leftarrow>ks. \\<bar>k\\<bar>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>(m - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>m\\<bar> (sum_list (map abs ks))", "by (rule dioph_rhs_bound)"], ["proof (state)\nthis:\n  \\<bar>(m - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n  \\<le> max \\<bar>m\\<bar> (sum_list (map abs ks))\n\ngoal (2 subgoals):\n 1. sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(m - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))\n 2. \\<not> sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(m - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "also"], ["proof (state)\nthis:\n  \\<bar>(m - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n  \\<le> max \\<bar>m\\<bar> (sum_list (map abs ks))\n\ngoal (2 subgoals):\n 1. sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(m - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))\n 2. \\<not> sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(m - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "from True m"], ["proof (chain)\npicking this:\n  sum_list (map abs ks) \\<le> \\<bar>l\\<bar>\n  \\<bar>m\\<bar> \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "have \"\\<bar>m\\<bar> \\<le> \\<bar>l\\<bar>\""], ["proof (prove)\nusing this:\n  sum_list (map abs ks) \\<le> \\<bar>l\\<bar>\n  \\<bar>m\\<bar> \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))\n\ngoal (1 subgoal):\n 1. \\<bar>m\\<bar> \\<le> \\<bar>l\\<bar>", "by simp"], ["proof (state)\nthis:\n  \\<bar>m\\<bar> \\<le> \\<bar>l\\<bar>\n\ngoal (2 subgoals):\n 1. sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(m - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))\n 2. \\<not> sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(m - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      max x (sum_list (map abs ks))\n      \\<le> max y (sum_list (map abs ks))) \\<Longrightarrow>\n  \\<bar>(m - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n  \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      max x (sum_list (map abs ks))\n      \\<le> max y (sum_list (map abs ks))) \\<Longrightarrow>\n  \\<bar>(m - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n  \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))\n\ngoal (1 subgoal):\n 1. \\<bar>(m - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "by simp"], ["proof (state)\nthis:\n  \\<bar>(m - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n  \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))\n\ngoal (1 subgoal):\n 1. \\<not> sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(m - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(m - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "case False"], ["proof (state)\nthis:\n  \\<not> sum_list (map abs ks) \\<le> \\<bar>l\\<bar>\n\ngoal (1 subgoal):\n 1. \\<not> sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(m - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "have \"\\<bar>(m - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar> \\<le> max \\<bar>m\\<bar> (\\<Sum>k\\<leftarrow>ks. \\<bar>k\\<bar>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>(m - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>m\\<bar> (sum_list (map abs ks))", "by (rule dioph_rhs_bound)"], ["proof (state)\nthis:\n  \\<bar>(m - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n  \\<le> max \\<bar>m\\<bar> (sum_list (map abs ks))\n\ngoal (1 subgoal):\n 1. \\<not> sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(m - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "also"], ["proof (state)\nthis:\n  \\<bar>(m - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n  \\<le> max \\<bar>m\\<bar> (sum_list (map abs ks))\n\ngoal (1 subgoal):\n 1. \\<not> sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(m - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "from False m"], ["proof (chain)\npicking this:\n  \\<not> sum_list (map abs ks) \\<le> \\<bar>l\\<bar>\n  \\<bar>m\\<bar> \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "have \"\\<bar>m\\<bar> \\<le> (\\<Sum>k\\<leftarrow>ks. \\<bar>k\\<bar>)\""], ["proof (prove)\nusing this:\n  \\<not> sum_list (map abs ks) \\<le> \\<bar>l\\<bar>\n  \\<bar>m\\<bar> \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))\n\ngoal (1 subgoal):\n 1. \\<bar>m\\<bar> \\<le> sum_list (map abs ks)", "by simp"], ["proof (state)\nthis:\n  \\<bar>m\\<bar> \\<le> sum_list (map abs ks)\n\ngoal (1 subgoal):\n 1. \\<not> sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(m - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "also"], ["proof (state)\nthis:\n  \\<bar>m\\<bar> \\<le> sum_list (map abs ks)\n\ngoal (1 subgoal):\n 1. \\<not> sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(m - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "have \"max (\\<Sum>k\\<leftarrow>ks. \\<bar>k\\<bar>) (\\<Sum>k\\<leftarrow>ks. \\<bar>k\\<bar>) \\<le> max \\<bar>l\\<bar> (\\<Sum>k\\<leftarrow>ks. \\<bar>k\\<bar>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max (sum_list (map abs ks)) (sum_list (map abs ks))\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "by simp"], ["proof (state)\nthis:\n  max (sum_list (map abs ks)) (sum_list (map abs ks))\n  \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))\n\ngoal (1 subgoal):\n 1. \\<not> sum_list (map abs ks) \\<le> \\<bar>l\\<bar> \\<Longrightarrow>\n    \\<bar>(m - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      max x (sum_list (map abs ks))\n      \\<le> max y (sum_list (map abs ks))) \\<Longrightarrow>\n  \\<bar>(m - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n  \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      max x (sum_list (map abs ks))\n      \\<le> max y (sum_list (map abs ks))) \\<Longrightarrow>\n  \\<bar>(m - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n  \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))\n\ngoal (1 subgoal):\n 1. \\<bar>(m - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "by simp"], ["proof (state)\nthis:\n  \\<bar>(m - eval_dioph ks (map (\\<lambda>x. x mod 2) xs)) div 2\\<bar>\n  \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bounded_int_set_is_finite:\n  assumes S: \"\\<forall>(i::int)\\<in>S. \\<bar>i\\<bar> < j\"\n  shows \"finite S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite S", "proof (rule finite_subset)"], ["proof (state)\ngoal (2 subgoals):\n 1. S \\<subseteq> ?B\n 2. finite ?B", "have \"finite (int ` {n. n < nat j})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (int ` {n. n < nat j})", "by (rule nat_seg_image_imp_finite [OF refl])"], ["proof (state)\nthis:\n  finite (int ` {n. n < nat j})\n\ngoal (2 subgoals):\n 1. S \\<subseteq> ?B\n 2. finite ?B", "moreover"], ["proof (state)\nthis:\n  finite (int ` {n. n < nat j})\n\ngoal (2 subgoals):\n 1. S \\<subseteq> ?B\n 2. finite ?B", "have \"finite ((\\<lambda>n. - int n) ` {n. n < nat j})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ((\\<lambda>n. - int n) ` {n. n < nat j})", "by (rule nat_seg_image_imp_finite [OF refl])"], ["proof (state)\nthis:\n  finite ((\\<lambda>n. - int n) ` {n. n < nat j})\n\ngoal (2 subgoals):\n 1. S \\<subseteq> ?B\n 2. finite ?B", "ultimately"], ["proof (chain)\npicking this:\n  finite (int ` {n. n < nat j})\n  finite ((\\<lambda>n. - int n) ` {n. n < nat j})", "show \"finite (int ` {n. n < nat j} \\<union> (\\<lambda>n. - int n) ` {n. n < nat j})\""], ["proof (prove)\nusing this:\n  finite (int ` {n. n < nat j})\n  finite ((\\<lambda>n. - int n) ` {n. n < nat j})\n\ngoal (1 subgoal):\n 1. finite\n     (int ` {n. n < nat j} \\<union> (\\<lambda>n. - int n) ` {n. n < nat j})", "by (rule finite_UnI)"], ["proof (state)\nthis:\n  finite\n   (int ` {n. n < nat j} \\<union> (\\<lambda>n. - int n) ` {n. n < nat j})\n\ngoal (1 subgoal):\n 1. S \\<subseteq> int ` {n. n < nat j} \\<union>\n                  (\\<lambda>n. - int n) ` {n. n < nat j}", "show \"S \\<subseteq> int ` {n. n < nat j} \\<union> (\\<lambda>n. - int n) ` {n. n < nat j}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<subseteq> int ` {n. n < nat j} \\<union>\n                  (\\<lambda>n. - int n) ` {n. n < nat j}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> S \\<Longrightarrow>\n       x \\<in> int ` {n. n < nat j} \\<union>\n               (\\<lambda>n. - int n) ` {n. n < nat j}", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> S \\<Longrightarrow>\n       x \\<in> int ` {n. n < nat j} \\<union>\n               (\\<lambda>n. - int n) ` {n. n < nat j}", "assume i: \"i \\<in> S\""], ["proof (state)\nthis:\n  i \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> S \\<Longrightarrow>\n       x \\<in> int ` {n. n < nat j} \\<union>\n               (\\<lambda>n. - int n) ` {n. n < nat j}", "show \"i \\<in> int ` {n. n < nat j} \\<union> (\\<lambda>n. - int n) ` {n. n < nat j}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> int ` {n. n < nat j} \\<union>\n            (\\<lambda>n. - int n) ` {n. n < nat j}", "proof (cases \"0 \\<le> i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> i \\<Longrightarrow>\n    i \\<in> int ` {n. n < nat j} \\<union>\n            (\\<lambda>n. - int n) ` {n. n < nat j}\n 2. \\<not> 0 \\<le> i \\<Longrightarrow>\n    i \\<in> int ` {n. n < nat j} \\<union>\n            (\\<lambda>n. - int n) ` {n. n < nat j}", "case True"], ["proof (state)\nthis:\n  0 \\<le> i\n\ngoal (2 subgoals):\n 1. 0 \\<le> i \\<Longrightarrow>\n    i \\<in> int ` {n. n < nat j} \\<union>\n            (\\<lambda>n. - int n) ` {n. n < nat j}\n 2. \\<not> 0 \\<le> i \\<Longrightarrow>\n    i \\<in> int ` {n. n < nat j} \\<union>\n            (\\<lambda>n. - int n) ` {n. n < nat j}", "then"], ["proof (chain)\npicking this:\n  0 \\<le> i", "have \"i = int (nat i)\""], ["proof (prove)\nusing this:\n  0 \\<le> i\n\ngoal (1 subgoal):\n 1. i = int (nat i)", "by simp"], ["proof (state)\nthis:\n  i = int (nat i)\n\ngoal (2 subgoals):\n 1. 0 \\<le> i \\<Longrightarrow>\n    i \\<in> int ` {n. n < nat j} \\<union>\n            (\\<lambda>n. - int n) ` {n. n < nat j}\n 2. \\<not> 0 \\<le> i \\<Longrightarrow>\n    i \\<in> int ` {n. n < nat j} \\<union>\n            (\\<lambda>n. - int n) ` {n. n < nat j}", "moreover"], ["proof (state)\nthis:\n  i = int (nat i)\n\ngoal (2 subgoals):\n 1. 0 \\<le> i \\<Longrightarrow>\n    i \\<in> int ` {n. n < nat j} \\<union>\n            (\\<lambda>n. - int n) ` {n. n < nat j}\n 2. \\<not> 0 \\<le> i \\<Longrightarrow>\n    i \\<in> int ` {n. n < nat j} \\<union>\n            (\\<lambda>n. - int n) ` {n. n < nat j}", "from i S"], ["proof (chain)\npicking this:\n  i \\<in> S\n  \\<forall>i\\<in>S. \\<bar>i\\<bar> < j", "have \"nat i \\<in> {n. n < nat j}\""], ["proof (prove)\nusing this:\n  i \\<in> S\n  \\<forall>i\\<in>S. \\<bar>i\\<bar> < j\n\ngoal (1 subgoal):\n 1. nat i \\<in> {n. n < nat j}", "by auto"], ["proof (state)\nthis:\n  nat i \\<in> {n. n < nat j}\n\ngoal (2 subgoals):\n 1. 0 \\<le> i \\<Longrightarrow>\n    i \\<in> int ` {n. n < nat j} \\<union>\n            (\\<lambda>n. - int n) ` {n. n < nat j}\n 2. \\<not> 0 \\<le> i \\<Longrightarrow>\n    i \\<in> int ` {n. n < nat j} \\<union>\n            (\\<lambda>n. - int n) ` {n. n < nat j}", "ultimately"], ["proof (chain)\npicking this:\n  i = int (nat i)\n  nat i \\<in> {n. n < nat j}", "have \"i \\<in> int ` {n. n < nat j}\""], ["proof (prove)\nusing this:\n  i = int (nat i)\n  nat i \\<in> {n. n < nat j}\n\ngoal (1 subgoal):\n 1. i \\<in> int ` {n. n < nat j}", "by (rule image_eqI)"], ["proof (state)\nthis:\n  i \\<in> int ` {n. n < nat j}\n\ngoal (2 subgoals):\n 1. 0 \\<le> i \\<Longrightarrow>\n    i \\<in> int ` {n. n < nat j} \\<union>\n            (\\<lambda>n. - int n) ` {n. n < nat j}\n 2. \\<not> 0 \\<le> i \\<Longrightarrow>\n    i \\<in> int ` {n. n < nat j} \\<union>\n            (\\<lambda>n. - int n) ` {n. n < nat j}", "then"], ["proof (chain)\npicking this:\n  i \\<in> int ` {n. n < nat j}", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<in> int ` {n. n < nat j}\n\ngoal (1 subgoal):\n 1. i \\<in> int ` {n. n < nat j} \\<union>\n            (\\<lambda>n. - int n) ` {n. n < nat j}", ".."], ["proof (state)\nthis:\n  i \\<in> int ` {n. n < nat j} \\<union>\n          (\\<lambda>n. - int n) ` {n. n < nat j}\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> i \\<Longrightarrow>\n    i \\<in> int ` {n. n < nat j} \\<union>\n            (\\<lambda>n. - int n) ` {n. n < nat j}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> i \\<Longrightarrow>\n    i \\<in> int ` {n. n < nat j} \\<union>\n            (\\<lambda>n. - int n) ` {n. n < nat j}", "case False"], ["proof (state)\nthis:\n  \\<not> 0 \\<le> i\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> i \\<Longrightarrow>\n    i \\<in> int ` {n. n < nat j} \\<union>\n            (\\<lambda>n. - int n) ` {n. n < nat j}", "then"], ["proof (chain)\npicking this:\n  \\<not> 0 \\<le> i", "have \"i = - int (nat (- i))\""], ["proof (prove)\nusing this:\n  \\<not> 0 \\<le> i\n\ngoal (1 subgoal):\n 1. i = - int (nat (- i))", "by simp"], ["proof (state)\nthis:\n  i = - int (nat (- i))\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> i \\<Longrightarrow>\n    i \\<in> int ` {n. n < nat j} \\<union>\n            (\\<lambda>n. - int n) ` {n. n < nat j}", "moreover"], ["proof (state)\nthis:\n  i = - int (nat (- i))\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> i \\<Longrightarrow>\n    i \\<in> int ` {n. n < nat j} \\<union>\n            (\\<lambda>n. - int n) ` {n. n < nat j}", "from i S"], ["proof (chain)\npicking this:\n  i \\<in> S\n  \\<forall>i\\<in>S. \\<bar>i\\<bar> < j", "have \"nat (- i) \\<in> {n. n < nat j}\""], ["proof (prove)\nusing this:\n  i \\<in> S\n  \\<forall>i\\<in>S. \\<bar>i\\<bar> < j\n\ngoal (1 subgoal):\n 1. nat (- i) \\<in> {n. n < nat j}", "by auto"], ["proof (state)\nthis:\n  nat (- i) \\<in> {n. n < nat j}\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> i \\<Longrightarrow>\n    i \\<in> int ` {n. n < nat j} \\<union>\n            (\\<lambda>n. - int n) ` {n. n < nat j}", "ultimately"], ["proof (chain)\npicking this:\n  i = - int (nat (- i))\n  nat (- i) \\<in> {n. n < nat j}", "have \"i \\<in> (\\<lambda>n. - int n) ` {n. n < nat j}\""], ["proof (prove)\nusing this:\n  i = - int (nat (- i))\n  nat (- i) \\<in> {n. n < nat j}\n\ngoal (1 subgoal):\n 1. i \\<in> (\\<lambda>n. - int n) ` {n. n < nat j}", "by (rule image_eqI)"], ["proof (state)\nthis:\n  i \\<in> (\\<lambda>n. - int n) ` {n. n < nat j}\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> i \\<Longrightarrow>\n    i \\<in> int ` {n. n < nat j} \\<union>\n            (\\<lambda>n. - int n) ` {n. n < nat j}", "then"], ["proof (chain)\npicking this:\n  i \\<in> (\\<lambda>n. - int n) ` {n. n < nat j}", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<in> (\\<lambda>n. - int n) ` {n. n < nat j}\n\ngoal (1 subgoal):\n 1. i \\<in> int ` {n. n < nat j} \\<union>\n            (\\<lambda>n. - int n) ` {n. n < nat j}", ".."], ["proof (state)\nthis:\n  i \\<in> int ` {n. n < nat j} \\<union>\n          (\\<lambda>n. - int n) ` {n. n < nat j}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i \\<in> int ` {n. n < nat j} \\<union>\n          (\\<lambda>n. - int n) ` {n. n < nat j}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S \\<subseteq> int ` {n. n < nat j} \\<union>\n                (\\<lambda>n. - int n) ` {n. n < nat j}\n\ngoal:\nNo subgoals!", "qed"], ["", "primrec mk_nat_vecs :: \"nat \\<Rightarrow> nat list list\" where\n  \"mk_nat_vecs 0 = [[]]\"\n| \"mk_nat_vecs (Suc n) =\n     (let yss = mk_nat_vecs n\n      in map (Cons 0) yss @ map (Cons 1) yss)\""], ["", "lemma mk_nat_vecs_bound: \"\\<forall>xs\\<in>set (mk_nat_vecs n). \\<forall>x\\<in>set xs. x < 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs\\<in>set (mk_nat_vecs n). \\<forall>x\\<in>set xs. x < 2", "by (induct n) (auto simp add: Let_def)"], ["", "lemma mk_nat_vecs_mod_eq: \"xs \\<in> set (mk_nat_vecs n) \\<Longrightarrow> map (\\<lambda>x. x mod 2) xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> set (mk_nat_vecs n) \\<Longrightarrow>\n    map (\\<lambda>x. x mod 2) xs = xs", "apply (drule bspec [OF mk_nat_vecs_bound])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs. x < 2 \\<Longrightarrow>\n    map (\\<lambda>x. x mod 2) xs = xs", "apply (induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set []. x < 2 \\<Longrightarrow>\n    map (\\<lambda>x. x mod 2) [] = []\n 2. \\<And>a xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs. x < 2 \\<Longrightarrow>\n                map (\\<lambda>x. x mod 2) xs = xs;\n        \\<forall>x\\<in>set (a # xs). x < 2\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>x. x mod 2) (a # xs) = a # xs", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition\n  \"dioph_succs n ks m = List.map_filter (\\<lambda>xs.\n     if eval_dioph ks xs mod 2 = m mod 2\n     then Some ((m - eval_dioph ks xs) div 2)\n     else None) (mk_nat_vecs n)\""], ["", "definition\n  dioph_is_node :: \"int list \\<Rightarrow> int \\<Rightarrow> int \\<Rightarrow> bool\" where\n  \"dioph_is_node ks l m = (\\<bar>m\\<bar> \\<le> max \\<bar>l\\<bar> (\\<Sum>k\\<leftarrow>ks. \\<bar>k\\<bar>))\""], ["", "definition\n  dioph_invariant :: \"int list \\<Rightarrow> int \\<Rightarrow> nat option list \\<times> int list \\<Rightarrow> bool\" where\n  \"dioph_invariant ks l = (\\<lambda>(is, js). length is = nat (2 * max \\<bar>l\\<bar> (\\<Sum>k\\<leftarrow>ks. \\<bar>k\\<bar>) + 1))\""], ["", "definition\n  \"dioph_ins m = (\\<lambda>(is, js). (is[int_encode m := Some (length js)], js @ [m]))\""], ["", "definition\n  dioph_memb :: \"int \\<Rightarrow> nat option list \\<times> int list \\<Rightarrow> bool\" where\n  \"dioph_memb m = (\\<lambda>(is, js). is ! int_encode m \\<noteq> None)\""], ["", "definition\n  dioph_empt :: \"int list \\<Rightarrow> int \\<Rightarrow> nat option list \\<times> int list\" where\n  \"dioph_empt ks l = (replicate (nat (2 * max \\<bar>l\\<bar> (\\<Sum>k\\<leftarrow>ks. \\<bar>k\\<bar>) + 1)) None, [])\""], ["", "lemma int_encode_bound: \"dioph_is_node ks l m \\<Longrightarrow>\n  int_encode m < nat (2 * max \\<bar>l\\<bar> (\\<Sum>k\\<leftarrow>ks. \\<bar>k\\<bar>) + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dioph_is_node ks l m \\<Longrightarrow>\n    int_encode m < nat (2 * max \\<bar>l\\<bar> (sum_list (map abs ks)) + 1)", "by (simp add: dioph_is_node_def int_encode_def sum_encode_def) arith"], ["", "interpretation dioph_dfs: DFS \"dioph_succs n ks\" \"dioph_is_node ks l\"\n  \"dioph_invariant ks l\" dioph_ins dioph_memb \"dioph_empt ks l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DFS (dioph_succs n ks) (dioph_is_node ks l) (dioph_invariant ks l)\n     dioph_ins dioph_memb (dioph_empt ks l)", "proof (standard, goal_cases)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x y S.\n       \\<lbrakk>dioph_is_node ks l x; dioph_is_node ks l y;\n        dioph_invariant ks l S; \\<not> dioph_memb y S\\<rbrakk>\n       \\<Longrightarrow> dioph_memb x (dioph_ins y S) =\n                         (x = y \\<or> dioph_memb x S)\n 2. \\<And>x.\n       dioph_is_node ks l x \\<Longrightarrow>\n       \\<not> dioph_memb x (dioph_empt ks l)\n 3. \\<And>x.\n       dioph_is_node ks l x \\<Longrightarrow>\n       list_all (dioph_is_node ks l) (dioph_succs n ks x)\n 4. dioph_invariant ks l (dioph_empt ks l)\n 5. \\<And>x S.\n       \\<lbrakk>dioph_is_node ks l x; dioph_invariant ks l S;\n        \\<not> dioph_memb x S\\<rbrakk>\n       \\<Longrightarrow> dioph_invariant ks l (dioph_ins x S)\n 6. finite {x. dioph_is_node ks l x}", "case (1 x y)"], ["proof (state)\nthis:\n  dioph_is_node ks l x\n  dioph_is_node ks l y\n  dioph_invariant ks l S_\n  \\<not> dioph_memb y S_\n\ngoal (6 subgoals):\n 1. \\<And>x y S.\n       \\<lbrakk>dioph_is_node ks l x; dioph_is_node ks l y;\n        dioph_invariant ks l S; \\<not> dioph_memb y S\\<rbrakk>\n       \\<Longrightarrow> dioph_memb x (dioph_ins y S) =\n                         (x = y \\<or> dioph_memb x S)\n 2. \\<And>x.\n       dioph_is_node ks l x \\<Longrightarrow>\n       \\<not> dioph_memb x (dioph_empt ks l)\n 3. \\<And>x.\n       dioph_is_node ks l x \\<Longrightarrow>\n       list_all (dioph_is_node ks l) (dioph_succs n ks x)\n 4. dioph_invariant ks l (dioph_empt ks l)\n 5. \\<And>x S.\n       \\<lbrakk>dioph_is_node ks l x; dioph_invariant ks l S;\n        \\<not> dioph_memb x S\\<rbrakk>\n       \\<Longrightarrow> dioph_invariant ks l (dioph_ins x S)\n 6. finite {x. dioph_is_node ks l x}", "then"], ["proof (chain)\npicking this:\n  dioph_is_node ks l x\n  dioph_is_node ks l y\n  dioph_invariant ks l S_\n  \\<not> dioph_memb y S_", "show ?case"], ["proof (prove)\nusing this:\n  dioph_is_node ks l x\n  dioph_is_node ks l y\n  dioph_invariant ks l S_\n  \\<not> dioph_memb y S_\n\ngoal (1 subgoal):\n 1. dioph_memb x (dioph_ins y S_) = (x = y \\<or> dioph_memb x S_)", "apply (simp add: dioph_memb_def dioph_ins_def split_beta dioph_invariant_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dioph_is_node ks l x; dioph_is_node ks l y;\n     length (fst S_) =\n     nat (2 * max \\<bar>l\\<bar> (sum_list (map abs ks)) + 1);\n     fst S_ ! int_encode y = None\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>ya.\n                          (fst S_)[int_encode y := Some (length (snd S_))] !\n                          int_encode x =\n                          Some ya) =\n                      (x = y \\<or>\n                       (\\<exists>y. fst S_ ! int_encode x = Some y))", "apply (cases \"x = y\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>dioph_is_node ks l x; dioph_is_node ks l y;\n     length (fst S_) =\n     nat (2 * max \\<bar>l\\<bar> (sum_list (map abs ks)) + 1);\n     fst S_ ! int_encode y = None; x = y\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>ya.\n                          (fst S_)[int_encode y := Some (length (snd S_))] !\n                          int_encode x =\n                          Some ya) =\n                      (x = y \\<or>\n                       (\\<exists>y. fst S_ ! int_encode x = Some y))\n 2. \\<lbrakk>dioph_is_node ks l x; dioph_is_node ks l y;\n     length (fst S_) =\n     nat (2 * max \\<bar>l\\<bar> (sum_list (map abs ks)) + 1);\n     fst S_ ! int_encode y = None; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>ya.\n                          (fst S_)[int_encode y := Some (length (snd S_))] !\n                          int_encode x =\n                          Some ya) =\n                      (x = y \\<or>\n                       (\\<exists>y. fst S_ ! int_encode x = Some y))", "apply (simp add: int_encode_bound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dioph_is_node ks l x; dioph_is_node ks l y;\n     length (fst S_) =\n     nat (2 * max \\<bar>l\\<bar> (sum_list (map abs ks)) + 1);\n     fst S_ ! int_encode y = None; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>ya.\n                          (fst S_)[int_encode y := Some (length (snd S_))] !\n                          int_encode x =\n                          Some ya) =\n                      (x = y \\<or>\n                       (\\<exists>y. fst S_ ! int_encode x = Some y))", "apply (simp add: inj_eq [OF inj_int_encode])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  dioph_memb x (dioph_ins y S_) = (x = y \\<or> dioph_memb x S_)\n\ngoal (5 subgoals):\n 1. \\<And>x.\n       dioph_is_node ks l x \\<Longrightarrow>\n       \\<not> dioph_memb x (dioph_empt ks l)\n 2. \\<And>x.\n       dioph_is_node ks l x \\<Longrightarrow>\n       list_all (dioph_is_node ks l) (dioph_succs n ks x)\n 3. dioph_invariant ks l (dioph_empt ks l)\n 4. \\<And>x S.\n       \\<lbrakk>dioph_is_node ks l x; dioph_invariant ks l S;\n        \\<not> dioph_memb x S\\<rbrakk>\n       \\<Longrightarrow> dioph_invariant ks l (dioph_ins x S)\n 5. finite {x. dioph_is_node ks l x}", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x.\n       dioph_is_node ks l x \\<Longrightarrow>\n       \\<not> dioph_memb x (dioph_empt ks l)\n 2. \\<And>x.\n       dioph_is_node ks l x \\<Longrightarrow>\n       list_all (dioph_is_node ks l) (dioph_succs n ks x)\n 3. dioph_invariant ks l (dioph_empt ks l)\n 4. \\<And>x S.\n       \\<lbrakk>dioph_is_node ks l x; dioph_invariant ks l S;\n        \\<not> dioph_memb x S\\<rbrakk>\n       \\<Longrightarrow> dioph_invariant ks l (dioph_ins x S)\n 5. finite {x. dioph_is_node ks l x}", "case 2"], ["proof (state)\nthis:\n  dioph_is_node ks l x_\n\ngoal (5 subgoals):\n 1. \\<And>x.\n       dioph_is_node ks l x \\<Longrightarrow>\n       \\<not> dioph_memb x (dioph_empt ks l)\n 2. \\<And>x.\n       dioph_is_node ks l x \\<Longrightarrow>\n       list_all (dioph_is_node ks l) (dioph_succs n ks x)\n 3. dioph_invariant ks l (dioph_empt ks l)\n 4. \\<And>x S.\n       \\<lbrakk>dioph_is_node ks l x; dioph_invariant ks l S;\n        \\<not> dioph_memb x S\\<rbrakk>\n       \\<Longrightarrow> dioph_invariant ks l (dioph_ins x S)\n 5. finite {x. dioph_is_node ks l x}", "then"], ["proof (chain)\npicking this:\n  dioph_is_node ks l x_", "show ?case"], ["proof (prove)\nusing this:\n  dioph_is_node ks l x_\n\ngoal (1 subgoal):\n 1. \\<not> dioph_memb x_ (dioph_empt ks l)", "by (simp add: dioph_memb_def dioph_empt_def int_encode_bound)"], ["proof (state)\nthis:\n  \\<not> dioph_memb x_ (dioph_empt ks l)\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       dioph_is_node ks l x \\<Longrightarrow>\n       list_all (dioph_is_node ks l) (dioph_succs n ks x)\n 2. dioph_invariant ks l (dioph_empt ks l)\n 3. \\<And>x S.\n       \\<lbrakk>dioph_is_node ks l x; dioph_invariant ks l S;\n        \\<not> dioph_memb x S\\<rbrakk>\n       \\<Longrightarrow> dioph_invariant ks l (dioph_ins x S)\n 4. finite {x. dioph_is_node ks l x}", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x.\n       dioph_is_node ks l x \\<Longrightarrow>\n       list_all (dioph_is_node ks l) (dioph_succs n ks x)\n 2. dioph_invariant ks l (dioph_empt ks l)\n 3. \\<And>x S.\n       \\<lbrakk>dioph_is_node ks l x; dioph_invariant ks l S;\n        \\<not> dioph_memb x S\\<rbrakk>\n       \\<Longrightarrow> dioph_invariant ks l (dioph_ins x S)\n 4. finite {x. dioph_is_node ks l x}", "case 3"], ["proof (state)\nthis:\n  dioph_is_node ks l x_\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       dioph_is_node ks l x \\<Longrightarrow>\n       list_all (dioph_is_node ks l) (dioph_succs n ks x)\n 2. dioph_invariant ks l (dioph_empt ks l)\n 3. \\<And>x S.\n       \\<lbrakk>dioph_is_node ks l x; dioph_invariant ks l S;\n        \\<not> dioph_memb x S\\<rbrakk>\n       \\<Longrightarrow> dioph_invariant ks l (dioph_ins x S)\n 4. finite {x. dioph_is_node ks l x}", "then"], ["proof (chain)\npicking this:\n  dioph_is_node ks l x_", "show ?case"], ["proof (prove)\nusing this:\n  dioph_is_node ks l x_\n\ngoal (1 subgoal):\n 1. list_all (dioph_is_node ks l) (dioph_succs n ks x_)", "apply (simp add: dioph_succs_def map_filter_def list_all_iff dioph_is_node_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x_\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks)) \\<Longrightarrow>\n    \\<forall>xa.\n       eval_dioph ks xa mod 2 = x_ mod 2 \\<longrightarrow>\n       xa \\<in> set (mk_nat_vecs n) \\<longrightarrow>\n       \\<bar>(x_ - eval_dioph ks xa) div 2\\<bar>\n       \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "apply (rule allI impI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<bar>x_\\<bar>\n                \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks));\n        eval_dioph ks xa mod 2 = x_ mod 2;\n        xa \\<in> set (mk_nat_vecs n)\\<rbrakk>\n       \\<Longrightarrow> \\<bar>(x_ - eval_dioph ks xa) div 2\\<bar>\n                         \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "apply (erule subst [OF mk_nat_vecs_mod_eq])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<bar>x_\\<bar>\n                \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks));\n        eval_dioph ks xa mod 2 = x_ mod 2\\<rbrakk>\n       \\<Longrightarrow> \\<bar>(x_ -\n                                eval_dioph ks\n                                 (map (\\<lambda>x. x mod 2) xa)) div\n                               2\\<bar>\n                         \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "apply (drule dioph_rhs_invariant)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>eval_dioph ks xa mod 2 = x_ mod 2;\n        \\<bar>(x_ -\n               eval_dioph ks (map (\\<lambda>x. x mod 2) (?xs31 xa))) div\n              2\\<bar>\n        \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))\\<rbrakk>\n       \\<Longrightarrow> \\<bar>(x_ -\n                                eval_dioph ks\n                                 (map (\\<lambda>x. x mod 2) xa)) div\n                               2\\<bar>\n                         \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  list_all (dioph_is_node ks l) (dioph_succs n ks x_)\n\ngoal (3 subgoals):\n 1. dioph_invariant ks l (dioph_empt ks l)\n 2. \\<And>x S.\n       \\<lbrakk>dioph_is_node ks l x; dioph_invariant ks l S;\n        \\<not> dioph_memb x S\\<rbrakk>\n       \\<Longrightarrow> dioph_invariant ks l (dioph_ins x S)\n 3. finite {x. dioph_is_node ks l x}", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. dioph_invariant ks l (dioph_empt ks l)\n 2. \\<And>x S.\n       \\<lbrakk>dioph_is_node ks l x; dioph_invariant ks l S;\n        \\<not> dioph_memb x S\\<rbrakk>\n       \\<Longrightarrow> dioph_invariant ks l (dioph_ins x S)\n 3. finite {x. dioph_is_node ks l x}", "case 4"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. dioph_invariant ks l (dioph_empt ks l)\n 2. \\<And>x S.\n       \\<lbrakk>dioph_is_node ks l x; dioph_invariant ks l S;\n        \\<not> dioph_memb x S\\<rbrakk>\n       \\<Longrightarrow> dioph_invariant ks l (dioph_ins x S)\n 3. finite {x. dioph_is_node ks l x}", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. dioph_invariant ks l (dioph_empt ks l)", "by (simp add: dioph_invariant_def dioph_empt_def)"], ["proof (state)\nthis:\n  dioph_invariant ks l (dioph_empt ks l)\n\ngoal (2 subgoals):\n 1. \\<And>x S.\n       \\<lbrakk>dioph_is_node ks l x; dioph_invariant ks l S;\n        \\<not> dioph_memb x S\\<rbrakk>\n       \\<Longrightarrow> dioph_invariant ks l (dioph_ins x S)\n 2. finite {x. dioph_is_node ks l x}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x S.\n       \\<lbrakk>dioph_is_node ks l x; dioph_invariant ks l S;\n        \\<not> dioph_memb x S\\<rbrakk>\n       \\<Longrightarrow> dioph_invariant ks l (dioph_ins x S)\n 2. finite {x. dioph_is_node ks l x}", "case 5"], ["proof (state)\nthis:\n  dioph_is_node ks l x_\n  dioph_invariant ks l S_\n  \\<not> dioph_memb x_ S_\n\ngoal (2 subgoals):\n 1. \\<And>x S.\n       \\<lbrakk>dioph_is_node ks l x; dioph_invariant ks l S;\n        \\<not> dioph_memb x S\\<rbrakk>\n       \\<Longrightarrow> dioph_invariant ks l (dioph_ins x S)\n 2. finite {x. dioph_is_node ks l x}", "then"], ["proof (chain)\npicking this:\n  dioph_is_node ks l x_\n  dioph_invariant ks l S_\n  \\<not> dioph_memb x_ S_", "show ?case"], ["proof (prove)\nusing this:\n  dioph_is_node ks l x_\n  dioph_invariant ks l S_\n  \\<not> dioph_memb x_ S_\n\ngoal (1 subgoal):\n 1. dioph_invariant ks l (dioph_ins x_ S_)", "by (simp add: dioph_invariant_def dioph_ins_def split_beta)"], ["proof (state)\nthis:\n  dioph_invariant ks l (dioph_ins x_ S_)\n\ngoal (1 subgoal):\n 1. finite {x. dioph_is_node ks l x}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {x. dioph_is_node ks l x}", "case 6"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. finite {x. dioph_is_node ks l x}", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. dioph_is_node ks l x}", "apply (rule bounded_int_set_is_finite [of _ \"max \\<bar>l\\<bar> (\\<Sum>k\\<leftarrow>ks. \\<bar>k\\<bar>) + 1\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{x. dioph_is_node ks l x}.\n       \\<bar>i\\<bar> < max \\<bar>l\\<bar> (sum_list (map abs ks)) + 1", "apply (rule ballI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {x. dioph_is_node ks l x} \\<Longrightarrow>\n       \\<bar>i\\<bar> < max \\<bar>l\\<bar> (sum_list (map abs ks)) + 1", "apply (simp add: dioph_is_node_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  finite {x. dioph_is_node ks l x}\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  \"dioph_dfs n ks l = gen_dfs (dioph_succs n ks) dioph_ins dioph_memb (dioph_empt ks l) [l]\""], ["", "primrec make_bdd :: \"(nat list \\<Rightarrow> 'a) \\<Rightarrow> nat \\<Rightarrow> nat list \\<Rightarrow> 'a bdd\"\nwhere\n  \"make_bdd f 0 xs = Leaf (f xs)\"\n| \"make_bdd f (Suc n) xs = Branch (make_bdd f n (xs @ [0])) (make_bdd f n (xs @ [1]))\""], ["", "definition\n  \"eq_dfa n ks l =\n    (let (is, js) = dioph_dfs n ks l\n     in\n       (map (\\<lambda>j. make_bdd (\\<lambda>xs.\n          if eval_dioph ks xs mod 2 = j mod 2\n          then the (is ! int_encode ((j - eval_dioph ks xs) div 2))\n          else length js) n []) js @ [Leaf (length js)],\n        map (\\<lambda>j. j = 0) js @ [False]))\""], ["", "abbreviation (input) nat_of_bool :: \"bool \\<Rightarrow> nat\"\nwhere\n  \"nat_of_bool \\<equiv> of_bool\""], ["", "lemma nat_of_bool_bound: \"nat_of_bool b < 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_bool b < 2", "by (cases b) simp_all"], ["", "lemma nat_of_bool_mk_nat_vecs:\n  \"length bs = n \\<Longrightarrow> map nat_of_bool bs \\<in> set (mk_nat_vecs n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length bs = n \\<Longrightarrow> map of_bool bs \\<in> set (mk_nat_vecs n)", "apply (induct n arbitrary: bs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>bs.\n       length bs = 0 \\<Longrightarrow>\n       map of_bool bs \\<in> set (mk_nat_vecs 0)\n 2. \\<And>n bs.\n       \\<lbrakk>\\<And>bs.\n                   length bs = n \\<Longrightarrow>\n                   map of_bool bs \\<in> set (mk_nat_vecs n);\n        length bs = Suc n\\<rbrakk>\n       \\<Longrightarrow> map of_bool bs \\<in> set (mk_nat_vecs (Suc n))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n bs.\n       \\<lbrakk>\\<And>bs.\n                   length bs = n \\<Longrightarrow>\n                   map of_bool bs \\<in> set (mk_nat_vecs n);\n        length bs = Suc n\\<rbrakk>\n       \\<Longrightarrow> map of_bool bs \\<in> set (mk_nat_vecs (Suc n))", "apply (case_tac bs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n bs.\n       \\<lbrakk>\\<And>bs.\n                   length bs = n \\<Longrightarrow>\n                   map of_bool bs \\<in> set (mk_nat_vecs n);\n        length bs = Suc n; bs = []\\<rbrakk>\n       \\<Longrightarrow> map of_bool bs \\<in> set (mk_nat_vecs (Suc n))\n 2. \\<And>n bs a list.\n       \\<lbrakk>\\<And>bs.\n                   length bs = n \\<Longrightarrow>\n                   map of_bool bs \\<in> set (mk_nat_vecs n);\n        length bs = Suc n; bs = a # list\\<rbrakk>\n       \\<Longrightarrow> map of_bool bs \\<in> set (mk_nat_vecs (Suc n))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n bs a list.\n       \\<lbrakk>\\<And>bs.\n                   length bs = n \\<Longrightarrow>\n                   map of_bool bs \\<in> set (mk_nat_vecs n);\n        length bs = Suc n; bs = a # list\\<rbrakk>\n       \\<Longrightarrow> map of_bool bs \\<in> set (mk_nat_vecs (Suc n))", "apply (case_tac a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n bs a list.\n       \\<lbrakk>\\<And>bs.\n                   length bs = n \\<Longrightarrow>\n                   map of_bool bs \\<in> set (mk_nat_vecs n);\n        length bs = Suc n; bs = a # list; a\\<rbrakk>\n       \\<Longrightarrow> map of_bool bs \\<in> set (mk_nat_vecs (Suc n))\n 2. \\<And>n bs a list.\n       \\<lbrakk>\\<And>bs.\n                   length bs = n \\<Longrightarrow>\n                   map of_bool bs \\<in> set (mk_nat_vecs n);\n        length bs = Suc n; bs = a # list; \\<not> a\\<rbrakk>\n       \\<Longrightarrow> map of_bool bs \\<in> set (mk_nat_vecs (Suc n))", "apply (simp_all add: Let_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bdd_lookup_make_bdd:\n  \"length bs = n \\<Longrightarrow> bdd_lookup (make_bdd f n xs) bs = f (xs @ map nat_of_bool bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length bs = n \\<Longrightarrow>\n    bdd_lookup (make_bdd f n xs) bs = f (xs @ map of_bool bs)", "apply (induct n arbitrary: bs xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>bs xs.\n       length bs = 0 \\<Longrightarrow>\n       bdd_lookup (make_bdd f 0 xs) bs = f (xs @ map of_bool bs)\n 2. \\<And>n bs xs.\n       \\<lbrakk>\\<And>bs xs.\n                   length bs = n \\<Longrightarrow>\n                   bdd_lookup (make_bdd f n xs) bs =\n                   f (xs @ map of_bool bs);\n        length bs = Suc n\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (make_bdd f (Suc n) xs) bs =\n                         f (xs @ map of_bool bs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n bs xs.\n       \\<lbrakk>\\<And>bs xs.\n                   length bs = n \\<Longrightarrow>\n                   bdd_lookup (make_bdd f n xs) bs =\n                   f (xs @ map of_bool bs);\n        length bs = Suc n\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (make_bdd f (Suc n) xs) bs =\n                         f (xs @ map of_bool bs)", "apply (case_tac bs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n bs xs.\n       \\<lbrakk>\\<And>bs xs.\n                   length bs = n \\<Longrightarrow>\n                   bdd_lookup (make_bdd f n xs) bs =\n                   f (xs @ map of_bool bs);\n        length bs = Suc n; bs = []\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (make_bdd f (Suc n) xs) bs =\n                         f (xs @ map of_bool bs)\n 2. \\<And>n bs xs a list.\n       \\<lbrakk>\\<And>bs xs.\n                   length bs = n \\<Longrightarrow>\n                   bdd_lookup (make_bdd f n xs) bs =\n                   f (xs @ map of_bool bs);\n        length bs = Suc n; bs = a # list\\<rbrakk>\n       \\<Longrightarrow> bdd_lookup (make_bdd f (Suc n) xs) bs =\n                         f (xs @ map of_bool bs)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "primrec nat_of_bools :: \"bool list \\<Rightarrow> nat\"\nwhere\n  \"nat_of_bools [] = 0\"\n| \"nat_of_bools (b # bs) = nat_of_bool b + 2 * nat_of_bools bs\""], ["", "primrec nats_of_boolss :: \"nat \\<Rightarrow> bool list list \\<Rightarrow> nat list\"\nwhere\n  Nil: \"nats_of_boolss n [] = replicate n 0\"\n| Cons: \"nats_of_boolss n (bs # bss) =\n     map (\\<lambda>(b, x). nat_of_bool b + 2 * x) (zip bs (nats_of_boolss n bss))\""], ["", "lemma nats_of_boolss_length:\n  \"list_all (is_alph n) bss \\<Longrightarrow> length (nats_of_boolss n bss) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (is_alph n) bss \\<Longrightarrow>\n    length (nats_of_boolss n bss) = n", "by (induct bss) (simp_all add: is_alph_def)"], ["", "lemma nats_of_boolss_mod2:\n  assumes bs: \"length bs = n\" and bss: \"list_all (is_alph n) bss\"\n  shows \"map (\\<lambda>x. x mod 2) (nats_of_boolss n (bs # bss)) = map nat_of_bool bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>x. x mod 2) (nats_of_boolss n (bs # bss)) = map of_bool bs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map (\\<lambda>x. x mod 2) (nats_of_boolss n (bs # bss)) = map of_bool bs", "from bs bss"], ["proof (chain)\npicking this:\n  length bs = n\n  list_all (is_alph n) bss", "have \"map nat_of_bool (map fst (zip bs (nats_of_boolss n bss))) = map nat_of_bool bs\""], ["proof (prove)\nusing this:\n  length bs = n\n  list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. map of_bool (map fst (zip bs (nats_of_boolss n bss))) = map of_bool bs", "by (simp add: nats_of_boolss_length)"], ["proof (state)\nthis:\n  map of_bool (map fst (zip bs (nats_of_boolss n bss))) = map of_bool bs\n\ngoal (1 subgoal):\n 1. map (\\<lambda>x. x mod 2) (nats_of_boolss n (bs # bss)) = map of_bool bs", "then"], ["proof (chain)\npicking this:\n  map of_bool (map fst (zip bs (nats_of_boolss n bss))) = map of_bool bs", "show ?thesis"], ["proof (prove)\nusing this:\n  map of_bool (map fst (zip bs (nats_of_boolss n bss))) = map of_bool bs\n\ngoal (1 subgoal):\n 1. map (\\<lambda>x. x mod 2) (nats_of_boolss n (bs # bss)) = map of_bool bs", "by (simp add: split_def o_def nat_of_bool_bound)"], ["proof (state)\nthis:\n  map (\\<lambda>x. x mod 2) (nats_of_boolss n (bs # bss)) = map of_bool bs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nats_of_boolss_div2:\n  assumes bs: \"length bs = n\" and bss: \"list_all (is_alph n) bss\"\n  shows \"map (\\<lambda>x. x div 2) (nats_of_boolss n (bs # bss)) = nats_of_boolss n bss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>x. x div 2) (nats_of_boolss n (bs # bss)) =\n    nats_of_boolss n bss", "using bs bss"], ["proof (prove)\nusing this:\n  length bs = n\n  list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. map (\\<lambda>x. x div 2) (nats_of_boolss n (bs # bss)) =\n    nats_of_boolss n bss", "by (simp add: split_def o_def nat_of_bool_bound nats_of_boolss_length)"], ["", "lemma zip_insertl: \"length xs = length ys \\<Longrightarrow>\n  zip (insertl n x xs) (insertl n y ys) = insertl n (x, y) (zip xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = length ys \\<Longrightarrow>\n    zip (insertl n x xs) (insertl n y ys) = insertl n (x, y) (zip xs ys)", "by (induct n x xs arbitrary: ys rule: insertl.induct)\n    (auto simp add: Suc_length_conv)"], ["", "lemma map_insertl: \"map f (insertl i x xs) = insertl i (f x) (map f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f (insertl i x xs) = insertl i (f x) (map f xs)", "by (induct i x xs rule: insertl.induct) simp_all"], ["", "lemma insertl_replicate: \"m \\<le> n \\<Longrightarrow>\n  insertl m x (replicate n x) = x # replicate n x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow>\n    insertl m x (replicate n x) = x # replicate n x", "apply (induct n arbitrary: m)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m.\n       m \\<le> 0 \\<Longrightarrow>\n       insertl m x (replicate 0 x) = x # replicate 0 x\n 2. \\<And>n m.\n       \\<lbrakk>\\<And>m.\n                   m \\<le> n \\<Longrightarrow>\n                   insertl m x (replicate n x) = x # replicate n x;\n        m \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> insertl m x (replicate (Suc n) x) =\n                         x # replicate (Suc n) x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m.\n       \\<lbrakk>\\<And>m.\n                   m \\<le> n \\<Longrightarrow>\n                   insertl m x (replicate n x) = x # replicate n x;\n        m \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> insertl m x (replicate (Suc n) x) =\n                         x # replicate (Suc n) x", "apply (case_tac m)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n m.\n       \\<lbrakk>\\<And>m.\n                   m \\<le> n \\<Longrightarrow>\n                   insertl m x (replicate n x) = x # replicate n x;\n        m \\<le> Suc n; m = 0\\<rbrakk>\n       \\<Longrightarrow> insertl m x (replicate (Suc n) x) =\n                         x # replicate (Suc n) x\n 2. \\<And>n m nat.\n       \\<lbrakk>\\<And>m.\n                   m \\<le> n \\<Longrightarrow>\n                   insertl m x (replicate n x) = x # replicate n x;\n        m \\<le> Suc n; m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> insertl m x (replicate (Suc n) x) =\n                         x # replicate (Suc n) x", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nats_of_boolss_insertll:\n  \"list_all (is_alph n) bss \\<Longrightarrow> length bs = length bss \\<Longrightarrow> i \\<le> n \\<Longrightarrow>\n   nats_of_boolss (Suc n) (insertll i bs bss) = insertl i (nat_of_bools bs) (nats_of_boolss n bss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all (is_alph n) bss; length bs = length bss;\n     i \\<le> n\\<rbrakk>\n    \\<Longrightarrow> nats_of_boolss (Suc n) (insertll i bs bss) =\n                      insertl i (nat_of_bools bs) (nats_of_boolss n bss)", "by (induct i bs bss rule: insertll.induct)\n    (simp_all add: zip_insertl nats_of_boolss_length insertll_len2 is_alph_def\n     map_insertl insertl_replicate cong: conj_cong)"], ["", "lemma zip_replicate_map: \"length xs = n \\<Longrightarrow> zip (replicate n x) xs = map (Pair x) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = n \\<Longrightarrow> zip (replicate n x) xs = map (Pair x) xs", "apply (induct n arbitrary: xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       length xs = 0 \\<Longrightarrow>\n       zip (replicate 0 x) xs = map (Pair x) xs\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs = n \\<Longrightarrow>\n                   zip (replicate n x) xs = map (Pair x) xs;\n        length xs = Suc n\\<rbrakk>\n       \\<Longrightarrow> zip (replicate (Suc n) x) xs = map (Pair x) xs", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs = n \\<Longrightarrow>\n                   zip (replicate n x) xs = map (Pair x) xs;\n        length xs = Suc n\\<rbrakk>\n       \\<Longrightarrow> zip (replicate (Suc n) x) xs = map (Pair x) xs", "apply (case_tac xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs = n \\<Longrightarrow>\n                   zip (replicate n x) xs = map (Pair x) xs;\n        length xs = Suc n; xs = []\\<rbrakk>\n       \\<Longrightarrow> zip (replicate (Suc n) x) xs = map (Pair x) xs\n 2. \\<And>n xs a list.\n       \\<lbrakk>\\<And>xs.\n                   length xs = n \\<Longrightarrow>\n                   zip (replicate n x) xs = map (Pair x) xs;\n        length xs = Suc n; xs = a # list\\<rbrakk>\n       \\<Longrightarrow> zip (replicate (Suc n) x) xs = map (Pair x) xs", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma zip_replicate_mapr: \"length xs = n \\<Longrightarrow> zip xs (replicate n x) = map (\\<lambda>y. (y, x)) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = n \\<Longrightarrow>\n    zip xs (replicate n x) = map (\\<lambda>y. (y, x)) xs", "apply (induct n arbitrary: xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       length xs = 0 \\<Longrightarrow>\n       zip xs (replicate 0 x) = map (\\<lambda>y. (y, x)) xs\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs = n \\<Longrightarrow>\n                   zip xs (replicate n x) = map (\\<lambda>y. (y, x)) xs;\n        length xs = Suc n\\<rbrakk>\n       \\<Longrightarrow> zip xs (replicate (Suc n) x) =\n                         map (\\<lambda>y. (y, x)) xs", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs = n \\<Longrightarrow>\n                   zip xs (replicate n x) = map (\\<lambda>y. (y, x)) xs;\n        length xs = Suc n\\<rbrakk>\n       \\<Longrightarrow> zip xs (replicate (Suc n) x) =\n                         map (\\<lambda>y. (y, x)) xs", "apply (case_tac xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs = n \\<Longrightarrow>\n                   zip xs (replicate n x) = map (\\<lambda>y. (y, x)) xs;\n        length xs = Suc n; xs = []\\<rbrakk>\n       \\<Longrightarrow> zip xs (replicate (Suc n) x) =\n                         map (\\<lambda>y. (y, x)) xs\n 2. \\<And>n xs a list.\n       \\<lbrakk>\\<And>xs.\n                   length xs = n \\<Longrightarrow>\n                   zip xs (replicate n x) = map (\\<lambda>y. (y, x)) xs;\n        length xs = Suc n; xs = a # list\\<rbrakk>\n       \\<Longrightarrow> zip xs (replicate (Suc n) x) =\n                         map (\\<lambda>y. (y, x)) xs", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma zip_assoc: \"map f (zip xs (zip ys zs)) = map (\\<lambda>((x, y), z). f (x, (y, z))) (zip (zip xs ys) zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f (zip xs (zip ys zs)) =\n    map2 (\\<lambda>(x, y) z. f (x, y, z)) (zip xs ys) zs", "apply (induct xs arbitrary: ys zs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys zs.\n       map f (zip [] (zip ys zs)) =\n       map2 (\\<lambda>(x, y) z. f (x, y, z)) (zip [] ys) zs\n 2. \\<And>a xs ys zs.\n       (\\<And>ys zs.\n           map f (zip xs (zip ys zs)) =\n           map2 (\\<lambda>(x, y) z. f (x, y, z)) (zip xs ys)\n            zs) \\<Longrightarrow>\n       map f (zip (a # xs) (zip ys zs)) =\n       map2 (\\<lambda>(x, y) z. f (x, y, z)) (zip (a # xs) ys) zs", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs ys zs.\n       (\\<And>ys zs.\n           map f (zip xs (zip ys zs)) =\n           map2 (\\<lambda>(x, y) z. f (x, y, z)) (zip xs ys)\n            zs) \\<Longrightarrow>\n       map f (zip (a # xs) (zip ys zs)) =\n       map2 (\\<lambda>(x, y) z. f (x, y, z)) (zip (a # xs) ys) zs", "apply (case_tac ys)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xs ys zs.\n       \\<lbrakk>\\<And>ys zs.\n                   map f (zip xs (zip ys zs)) =\n                   map2 (\\<lambda>(x, y) z. f (x, y, z)) (zip xs ys) zs;\n        ys = []\\<rbrakk>\n       \\<Longrightarrow> map f (zip (a # xs) (zip ys zs)) =\n                         map2 (\\<lambda>(x, y) z. f (x, y, z))\n                          (zip (a # xs) ys) zs\n 2. \\<And>a xs ys zs aa list.\n       \\<lbrakk>\\<And>ys zs.\n                   map f (zip xs (zip ys zs)) =\n                   map2 (\\<lambda>(x, y) z. f (x, y, z)) (zip xs ys) zs;\n        ys = aa # list\\<rbrakk>\n       \\<Longrightarrow> map f (zip (a # xs) (zip ys zs)) =\n                         map2 (\\<lambda>(x, y) z. f (x, y, z))\n                          (zip (a # xs) ys) zs", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs ys zs aa list.\n       \\<lbrakk>\\<And>ys zs.\n                   map f (zip xs (zip ys zs)) =\n                   map2 (\\<lambda>(x, y) z. f (x, y, z)) (zip xs ys) zs;\n        ys = aa # list\\<rbrakk>\n       \\<Longrightarrow> map f (zip (a # xs) (zip ys zs)) =\n                         map2 (\\<lambda>(x, y) z. f (x, y, z))\n                          (zip (a # xs) ys) zs", "apply (case_tac zs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xs ys zs aa list.\n       \\<lbrakk>\\<And>ys zs.\n                   map f (zip xs (zip ys zs)) =\n                   map2 (\\<lambda>(x, y) z. f (x, y, z)) (zip xs ys) zs;\n        ys = aa # list; zs = []\\<rbrakk>\n       \\<Longrightarrow> map f (zip (a # xs) (zip ys zs)) =\n                         map2 (\\<lambda>(x, y) z. f (x, y, z))\n                          (zip (a # xs) ys) zs\n 2. \\<And>a xs ys zs aa list ab lista.\n       \\<lbrakk>\\<And>ys zs.\n                   map f (zip xs (zip ys zs)) =\n                   map2 (\\<lambda>(x, y) z. f (x, y, z)) (zip xs ys) zs;\n        ys = aa # list; zs = ab # lista\\<rbrakk>\n       \\<Longrightarrow> map f (zip (a # xs) (zip ys zs)) =\n                         map2 (\\<lambda>(x, y) z. f (x, y, z))\n                          (zip (a # xs) ys) zs", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nats_of_boolss_append:\n  \"list_all (is_alph n) bss \\<Longrightarrow> list_all (is_alph n) bss' \\<Longrightarrow>\n     nats_of_boolss n (bss @ bss') =\n     map (\\<lambda>(x, y). x + 2 ^ length bss * y) (zip (nats_of_boolss n bss) (nats_of_boolss n bss'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all (is_alph n) bss; list_all (is_alph n) bss'\\<rbrakk>\n    \\<Longrightarrow> nats_of_boolss n (bss @ bss') =\n                      map2 (\\<lambda>x y. x + 2 ^ length bss * y)\n                       (nats_of_boolss n bss) (nats_of_boolss n bss')", "by (induct bss)\n    (auto simp add: nats_of_boolss_length zip_replicate_map o_def\n     map_zip_map map_zip_map2 zip_assoc is_alph_def)"], ["", "lemma nats_of_boolss_zeros: \"nats_of_boolss n (zeros m n) = replicate n 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nats_of_boolss n (zeros m n) = replicate n 0", "by (induct m) (simp_all add: zeros_def)"], ["", "declare nats_of_boolss.Cons [simp del]"], ["", "fun bools_of_nat :: \"nat \\<Rightarrow> nat \\<Rightarrow> bool list\"\nwhere\n  \"bools_of_nat k n =\n     (if n = 0 then\n        (if k = 0 then [] else False # bools_of_nat (k - 1) n)\n      else (n mod 2 = 1) # bools_of_nat (k - 1) (n div 2))\""], ["", "lemma bools_of_nat_length: \"k \\<le> length (bools_of_nat k n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> length (bools_of_nat k n)", "apply (induct k n rule: bools_of_nat.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k n.\n       \\<lbrakk>\\<lbrakk>n = 0; k \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> k - 1\n                                  \\<le> length (bools_of_nat (k - 1) n);\n        n \\<noteq> 0 \\<Longrightarrow>\n        k - 1 \\<le> length (bools_of_nat (k - 1) (n div 2))\\<rbrakk>\n       \\<Longrightarrow> k \\<le> length (bools_of_nat k n)", "apply (case_tac \"n = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k n.\n       \\<lbrakk>\\<lbrakk>n = 0; k \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> k - 1\n                                  \\<le> length (bools_of_nat (k - 1) n);\n        n \\<noteq> 0 \\<Longrightarrow>\n        k - 1 \\<le> length (bools_of_nat (k - 1) (n div 2));\n        n = 0\\<rbrakk>\n       \\<Longrightarrow> k \\<le> length (bools_of_nat k n)\n 2. \\<And>k n.\n       \\<lbrakk>\\<lbrakk>n = 0; k \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> k - 1\n                                  \\<le> length (bools_of_nat (k - 1) n);\n        n \\<noteq> 0 \\<Longrightarrow>\n        k - 1 \\<le> length (bools_of_nat (k - 1) (n div 2));\n        n \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> k \\<le> length (bools_of_nat k n)", "apply (case_tac \"k = 0\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>k n.\n       \\<lbrakk>\\<lbrakk>n = 0; k \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> k - 1\n                                  \\<le> length (bools_of_nat (k - 1) n);\n        n \\<noteq> 0 \\<Longrightarrow>\n        k - 1 \\<le> length (bools_of_nat (k - 1) (n div 2));\n        n = 0; k = 0\\<rbrakk>\n       \\<Longrightarrow> k \\<le> length (bools_of_nat k n)\n 2. \\<And>k n.\n       \\<lbrakk>\\<lbrakk>n = 0; k \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> k - 1\n                                  \\<le> length (bools_of_nat (k - 1) n);\n        n \\<noteq> 0 \\<Longrightarrow>\n        k - 1 \\<le> length (bools_of_nat (k - 1) (n div 2));\n        n = 0; k \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> k \\<le> length (bools_of_nat k n)\n 3. \\<And>k n.\n       \\<lbrakk>\\<lbrakk>n = 0; k \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> k - 1\n                                  \\<le> length (bools_of_nat (k - 1) n);\n        n \\<noteq> 0 \\<Longrightarrow>\n        k - 1 \\<le> length (bools_of_nat (k - 1) (n div 2));\n        n \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> k \\<le> length (bools_of_nat k n)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k n.\n       \\<lbrakk>\\<lbrakk>n = 0; k \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> k - 1\n                                  \\<le> length (bools_of_nat (k - 1) n);\n        n \\<noteq> 0 \\<Longrightarrow>\n        k - 1 \\<le> length (bools_of_nat (k - 1) (n div 2));\n        n = 0; k \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> k \\<le> length (bools_of_nat k n)\n 2. \\<And>k n.\n       \\<lbrakk>\\<lbrakk>n = 0; k \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> k - 1\n                                  \\<le> length (bools_of_nat (k - 1) n);\n        n \\<noteq> 0 \\<Longrightarrow>\n        k - 1 \\<le> length (bools_of_nat (k - 1) (n div 2));\n        n \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> k \\<le> length (bools_of_nat k n)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k n.\n       \\<lbrakk>\\<lbrakk>n = 0; k \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> k - 1\n                                  \\<le> length (bools_of_nat (k - 1) n);\n        n \\<noteq> 0 \\<Longrightarrow>\n        k - 1 \\<le> length (bools_of_nat (k - 1) (n div 2));\n        n \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> k \\<le> length (bools_of_nat k n)", "apply (subst bools_of_nat.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k n.\n       \\<lbrakk>\\<lbrakk>n = 0; k \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> k - 1\n                                  \\<le> length (bools_of_nat (k - 1) n);\n        n \\<noteq> 0 \\<Longrightarrow>\n        k - 1 \\<le> length (bools_of_nat (k - 1) (n div 2));\n        n \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> k \\<le> length\n                                  (if n = 0\n                                   then if k = 0 then []\n  else False # bools_of_nat (k - 1) n\n                                   else (n mod 2 = 1) #\n  bools_of_nat (k - 1) (n div 2))", "apply (simp del: bools_of_nat.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nat_of_bool_mod_eq: \"nat_of_bool (n mod 2 = 1) = n mod 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_bool (n mod 2 = 1) = n mod 2", "by (cases \"n mod 2 = 1\") simp_all"], ["", "lemma bools_of_nat_inverse: \"nat_of_bools (bools_of_nat k n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_of_bools (bools_of_nat k n) = n", "apply (induct k n rule: bools_of_nat.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k n.\n       \\<lbrakk>\\<lbrakk>n = 0; k \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> nat_of_bools (bools_of_nat (k - 1) n) = n;\n        n \\<noteq> 0 \\<Longrightarrow>\n        nat_of_bools (bools_of_nat (k - 1) (n div 2)) = n div 2\\<rbrakk>\n       \\<Longrightarrow> nat_of_bools (bools_of_nat k n) = n", "apply (case_tac \"n = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k n.\n       \\<lbrakk>\\<lbrakk>n = 0; k \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> nat_of_bools (bools_of_nat (k - 1) n) = n;\n        n \\<noteq> 0 \\<Longrightarrow>\n        nat_of_bools (bools_of_nat (k - 1) (n div 2)) = n div 2;\n        n = 0\\<rbrakk>\n       \\<Longrightarrow> nat_of_bools (bools_of_nat k n) = n\n 2. \\<And>k n.\n       \\<lbrakk>\\<lbrakk>n = 0; k \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> nat_of_bools (bools_of_nat (k - 1) n) = n;\n        n \\<noteq> 0 \\<Longrightarrow>\n        nat_of_bools (bools_of_nat (k - 1) (n div 2)) = n div 2;\n        n \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> nat_of_bools (bools_of_nat k n) = n", "apply (case_tac \"k = 0\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>k n.\n       \\<lbrakk>\\<lbrakk>n = 0; k \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> nat_of_bools (bools_of_nat (k - 1) n) = n;\n        n \\<noteq> 0 \\<Longrightarrow>\n        nat_of_bools (bools_of_nat (k - 1) (n div 2)) = n div 2;\n        n = 0; k = 0\\<rbrakk>\n       \\<Longrightarrow> nat_of_bools (bools_of_nat k n) = n\n 2. \\<And>k n.\n       \\<lbrakk>\\<lbrakk>n = 0; k \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> nat_of_bools (bools_of_nat (k - 1) n) = n;\n        n \\<noteq> 0 \\<Longrightarrow>\n        nat_of_bools (bools_of_nat (k - 1) (n div 2)) = n div 2;\n        n = 0; k \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> nat_of_bools (bools_of_nat k n) = n\n 3. \\<And>k n.\n       \\<lbrakk>\\<lbrakk>n = 0; k \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> nat_of_bools (bools_of_nat (k - 1) n) = n;\n        n \\<noteq> 0 \\<Longrightarrow>\n        nat_of_bools (bools_of_nat (k - 1) (n div 2)) = n div 2;\n        n \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> nat_of_bools (bools_of_nat k n) = n", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k n.\n       \\<lbrakk>\\<lbrakk>n = 0; k \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> nat_of_bools (bools_of_nat (k - 1) n) = n;\n        n \\<noteq> 0 \\<Longrightarrow>\n        nat_of_bools (bools_of_nat (k - 1) (n div 2)) = n div 2;\n        n = 0; k \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> nat_of_bools (bools_of_nat k n) = n\n 2. \\<And>k n.\n       \\<lbrakk>\\<lbrakk>n = 0; k \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> nat_of_bools (bools_of_nat (k - 1) n) = n;\n        n \\<noteq> 0 \\<Longrightarrow>\n        nat_of_bools (bools_of_nat (k - 1) (n div 2)) = n div 2;\n        n \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> nat_of_bools (bools_of_nat k n) = n", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k n.\n       \\<lbrakk>\\<lbrakk>n = 0; k \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> nat_of_bools (bools_of_nat (k - 1) n) = n;\n        n \\<noteq> 0 \\<Longrightarrow>\n        nat_of_bools (bools_of_nat (k - 1) (n div 2)) = n div 2;\n        n \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> nat_of_bools (bools_of_nat k n) = n", "apply (subst bools_of_nat.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k n.\n       \\<lbrakk>\\<lbrakk>n = 0; k \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> nat_of_bools (bools_of_nat (k - 1) n) = n;\n        n \\<noteq> 0 \\<Longrightarrow>\n        nat_of_bools (bools_of_nat (k - 1) (n div 2)) = n div 2;\n        n \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> nat_of_bools\n                          (if n = 0\n                           then if k = 0 then []\n                                else False # bools_of_nat (k - 1) n\n                           else (n mod 2 = 1) #\n                                bools_of_nat (k - 1) (n div 2)) =\n                         n", "apply (simp add: nat_of_bool_mod_eq [simplified] del: bools_of_nat.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare bools_of_nat.simps [simp del]"], ["", "lemma eval_dioph_replicate_0: \"eval_dioph ks (replicate n 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_dioph ks (replicate n 0) = 0", "apply (induct n arbitrary: ks)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ks. eval_dioph ks (replicate 0 0) = 0\n 2. \\<And>n ks.\n       (\\<And>ks. eval_dioph ks (replicate n 0) = 0) \\<Longrightarrow>\n       eval_dioph ks (replicate (Suc n) 0) = 0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n ks.\n       (\\<And>ks. eval_dioph ks (replicate n 0) = 0) \\<Longrightarrow>\n       eval_dioph ks (replicate (Suc n) 0) = 0", "apply (case_tac ks)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n ks.\n       \\<lbrakk>\\<And>ks. eval_dioph ks (replicate n 0) = 0;\n        ks = []\\<rbrakk>\n       \\<Longrightarrow> eval_dioph ks (replicate (Suc n) 0) = 0\n 2. \\<And>n ks a list.\n       \\<lbrakk>\\<And>ks. eval_dioph ks (replicate n 0) = 0;\n        ks = a # list\\<rbrakk>\n       \\<Longrightarrow> eval_dioph ks (replicate (Suc n) 0) = 0", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dioph_dfs_bij:\n  \"(fst (dioph_dfs n ks l) ! int_encode i = Some k \\<and> dioph_is_node ks l i) =\n    (k < length (snd (dioph_dfs n ks l)) \\<and> (snd (dioph_dfs n ks l) ! k = i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst (dioph_dfs n ks l) ! int_encode i = Some k \\<and>\n     dioph_is_node ks l i) =\n    (k < length (snd (dioph_dfs n ks l)) \\<and>\n     snd (dioph_dfs n ks l) ! k = i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (fst (dioph_dfs n ks l) ! int_encode i = Some k \\<and>\n     dioph_is_node ks l i) =\n    (k < length (snd (dioph_dfs n ks l)) \\<and>\n     snd (dioph_dfs n ks l) ! k = i)", "let ?dfs = \"gen_dfs (dioph_succs n ks) dioph_ins dioph_memb (dioph_empt ks l) [l]\""], ["proof (state)\ngoal (1 subgoal):\n 1. (fst (dioph_dfs n ks l) ! int_encode i = Some k \\<and>\n     dioph_is_node ks l i) =\n    (k < length (snd (dioph_dfs n ks l)) \\<and>\n     snd (dioph_dfs n ks l) ! k = i)", "have \"list_all (dioph_is_node ks l) [l]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (dioph_is_node ks l) [l]", "by (simp add: dioph_is_node_def)"], ["proof (state)\nthis:\n  list_all (dioph_is_node ks l) [l]\n\ngoal (1 subgoal):\n 1. (fst (dioph_dfs n ks l) ! int_encode i = Some k \\<and>\n     dioph_is_node ks l i) =\n    (k < length (snd (dioph_dfs n ks l)) \\<and>\n     snd (dioph_dfs n ks l) ! k = i)", "with dioph_dfs.empt_invariant [of ks l]"], ["proof (chain)\npicking this:\n  dioph_invariant ks l (dioph_empt ks l)\n  list_all (dioph_is_node ks l) [l]", "have \"(fst ?dfs ! int_encode i = Some k \\<and> dioph_is_node ks l i) =\n    (k < length (snd ?dfs) \\<and> (snd ?dfs ! k = i))\""], ["proof (prove)\nusing this:\n  dioph_invariant ks l (dioph_empt ks l)\n  list_all (dioph_is_node ks l) [l]\n\ngoal (1 subgoal):\n 1. (fst (dioph_dfs.dfs n ks (dioph_empt ks l) [l]) ! int_encode i =\n     Some k \\<and>\n     dioph_is_node ks l i) =\n    (k < length (snd (dioph_dfs.dfs n ks (dioph_empt ks l) [l])) \\<and>\n     snd (dioph_dfs.dfs n ks (dioph_empt ks l) [l]) ! k = i)", "proof (induct rule: dioph_dfs.dfs_invariant)"], ["proof (state)\ngoal (2 subgoals):\n 1. (fst (dioph_empt ks l) ! int_encode i = Some k \\<and>\n     dioph_is_node ks l i) =\n    (k < length (snd (dioph_empt ks l)) \\<and>\n     snd (dioph_empt ks l) ! k = i)\n 2. \\<And>S x.\n       \\<lbrakk>\\<not> dioph_memb x S; dioph_is_node ks l x;\n        dioph_invariant ks l S;\n        (fst S ! int_encode i = Some k \\<and> dioph_is_node ks l i) =\n        (k < length (snd S) \\<and> snd S ! k = i)\\<rbrakk>\n       \\<Longrightarrow> (fst (dioph_ins x S) ! int_encode i = Some k \\<and>\n                          dioph_is_node ks l i) =\n                         (k < length (snd (dioph_ins x S)) \\<and>\n                          snd (dioph_ins x S) ! k = i)", "case base"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (fst (dioph_empt ks l) ! int_encode i = Some k \\<and>\n     dioph_is_node ks l i) =\n    (k < length (snd (dioph_empt ks l)) \\<and>\n     snd (dioph_empt ks l) ! k = i)\n 2. \\<And>S x.\n       \\<lbrakk>\\<not> dioph_memb x S; dioph_is_node ks l x;\n        dioph_invariant ks l S;\n        (fst S ! int_encode i = Some k \\<and> dioph_is_node ks l i) =\n        (k < length (snd S) \\<and> snd S ! k = i)\\<rbrakk>\n       \\<Longrightarrow> (fst (dioph_ins x S) ! int_encode i = Some k \\<and>\n                          dioph_is_node ks l i) =\n                         (k < length (snd (dioph_ins x S)) \\<and>\n                          snd (dioph_ins x S) ! k = i)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst (dioph_empt ks l) ! int_encode i = Some k \\<and>\n     dioph_is_node ks l i) =\n    (k < length (snd (dioph_empt ks l)) \\<and>\n     snd (dioph_empt ks l) ! k = i)", "by (auto simp add: dioph_empt_def dioph_is_node_def int_encode_bound)"], ["proof (state)\nthis:\n  (fst (dioph_empt ks l) ! int_encode i = Some k \\<and>\n   dioph_is_node ks l i) =\n  (k < length (snd (dioph_empt ks l)) \\<and> snd (dioph_empt ks l) ! k = i)\n\ngoal (1 subgoal):\n 1. \\<And>S x.\n       \\<lbrakk>\\<not> dioph_memb x S; dioph_is_node ks l x;\n        dioph_invariant ks l S;\n        (fst S ! int_encode i = Some k \\<and> dioph_is_node ks l i) =\n        (k < length (snd S) \\<and> snd S ! k = i)\\<rbrakk>\n       \\<Longrightarrow> (fst (dioph_ins x S) ! int_encode i = Some k \\<and>\n                          dioph_is_node ks l i) =\n                         (k < length (snd (dioph_ins x S)) \\<and>\n                          snd (dioph_ins x S) ! k = i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S x.\n       \\<lbrakk>\\<not> dioph_memb x S; dioph_is_node ks l x;\n        dioph_invariant ks l S;\n        (fst S ! int_encode i = Some k \\<and> dioph_is_node ks l i) =\n        (k < length (snd S) \\<and> snd S ! k = i)\\<rbrakk>\n       \\<Longrightarrow> (fst (dioph_ins x S) ! int_encode i = Some k \\<and>\n                          dioph_is_node ks l i) =\n                         (k < length (snd (dioph_ins x S)) \\<and>\n                          snd (dioph_ins x S) ! k = i)", "case (step S y)"], ["proof (state)\nthis:\n  \\<not> dioph_memb y S\n  dioph_is_node ks l y\n  dioph_invariant ks l S\n  (fst S ! int_encode i = Some k \\<and> dioph_is_node ks l i) =\n  (k < length (snd S) \\<and> snd S ! k = i)\n\ngoal (1 subgoal):\n 1. \\<And>S x.\n       \\<lbrakk>\\<not> dioph_memb x S; dioph_is_node ks l x;\n        dioph_invariant ks l S;\n        (fst S ! int_encode i = Some k \\<and> dioph_is_node ks l i) =\n        (k < length (snd S) \\<and> snd S ! k = i)\\<rbrakk>\n       \\<Longrightarrow> (fst (dioph_ins x S) ! int_encode i = Some k \\<and>\n                          dioph_is_node ks l i) =\n                         (k < length (snd (dioph_ins x S)) \\<and>\n                          snd (dioph_ins x S) ! k = i)", "then"], ["proof (chain)\npicking this:\n  \\<not> dioph_memb y S\n  dioph_is_node ks l y\n  dioph_invariant ks l S\n  (fst S ! int_encode i = Some k \\<and> dioph_is_node ks l i) =\n  (k < length (snd S) \\<and> snd S ! k = i)", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> dioph_memb y S\n  dioph_is_node ks l y\n  dioph_invariant ks l S\n  (fst S ! int_encode i = Some k \\<and> dioph_is_node ks l i) =\n  (k < length (snd S) \\<and> snd S ! k = i)\n\ngoal (1 subgoal):\n 1. (fst (dioph_ins y S) ! int_encode i = Some k \\<and>\n     dioph_is_node ks l i) =\n    (k < length (snd (dioph_ins y S)) \\<and> snd (dioph_ins y S) ! k = i)", "by (cases \"y = i\")\n        (auto simp add: dioph_ins_def dioph_memb_def dioph_is_node_def split_beta dioph_invariant_def\n          int_encode_bound nth_append inj_eq [OF inj_int_encode])"], ["proof (state)\nthis:\n  (fst (dioph_ins y S) ! int_encode i = Some k \\<and>\n   dioph_is_node ks l i) =\n  (k < length (snd (dioph_ins y S)) \\<and> snd (dioph_ins y S) ! k = i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (fst (dioph_dfs.dfs n ks (dioph_empt ks l) [l]) ! int_encode i =\n   Some k \\<and>\n   dioph_is_node ks l i) =\n  (k < length (snd (dioph_dfs.dfs n ks (dioph_empt ks l) [l])) \\<and>\n   snd (dioph_dfs.dfs n ks (dioph_empt ks l) [l]) ! k = i)\n\ngoal (1 subgoal):\n 1. (fst (dioph_dfs n ks l) ! int_encode i = Some k \\<and>\n     dioph_is_node ks l i) =\n    (k < length (snd (dioph_dfs n ks l)) \\<and>\n     snd (dioph_dfs n ks l) ! k = i)", "then"], ["proof (chain)\npicking this:\n  (fst (dioph_dfs.dfs n ks (dioph_empt ks l) [l]) ! int_encode i =\n   Some k \\<and>\n   dioph_is_node ks l i) =\n  (k < length (snd (dioph_dfs.dfs n ks (dioph_empt ks l) [l])) \\<and>\n   snd (dioph_dfs.dfs n ks (dioph_empt ks l) [l]) ! k = i)", "show ?thesis"], ["proof (prove)\nusing this:\n  (fst (dioph_dfs.dfs n ks (dioph_empt ks l) [l]) ! int_encode i =\n   Some k \\<and>\n   dioph_is_node ks l i) =\n  (k < length (snd (dioph_dfs.dfs n ks (dioph_empt ks l) [l])) \\<and>\n   snd (dioph_dfs.dfs n ks (dioph_empt ks l) [l]) ! k = i)\n\ngoal (1 subgoal):\n 1. (fst (dioph_dfs n ks l) ! int_encode i = Some k \\<and>\n     dioph_is_node ks l i) =\n    (k < length (snd (dioph_dfs n ks l)) \\<and>\n     snd (dioph_dfs n ks l) ! k = i)", "by (simp add: dioph_dfs_def)"], ["proof (state)\nthis:\n  (fst (dioph_dfs n ks l) ! int_encode i = Some k \\<and>\n   dioph_is_node ks l i) =\n  (k < length (snd (dioph_dfs n ks l)) \\<and>\n   snd (dioph_dfs n ks l) ! k = i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dioph_dfs_mono:\n  assumes z: \"dioph_invariant ks l z\"\n  and xs: \"list_all (dioph_is_node ks l) xs\"\n  and H: \"fst z ! i = Some k\"\n  shows \"fst (gen_dfs (dioph_succs n ks) dioph_ins dioph_memb z xs) ! i = Some k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (dioph_dfs.dfs n ks z xs) ! i = Some k", "using z xs H"], ["proof (prove)\nusing this:\n  dioph_invariant ks l z\n  list_all (dioph_is_node ks l) xs\n  fst z ! i = Some k\n\ngoal (1 subgoal):\n 1. fst (dioph_dfs.dfs n ks z xs) ! i = Some k", "apply (rule dioph_dfs.dfs_invariant)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S x.\n       \\<lbrakk>\\<not> dioph_memb x S; dioph_is_node ks l x;\n        dioph_invariant ks l S; fst S ! i = Some k\\<rbrakk>\n       \\<Longrightarrow> fst (dioph_ins x S) ! i = Some k", "apply (simp add: dioph_ins_def dioph_memb_def split_paired_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x.\n       \\<lbrakk>a ! int_encode x = None; dioph_is_node ks l x;\n        dioph_invariant ks l (a, b); a ! i = Some k\\<rbrakk>\n       \\<Longrightarrow> a[int_encode x := Some (length b)] ! i = Some k", "apply (case_tac \"i = int_encode x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>a ! int_encode x = None; dioph_is_node ks l x;\n        dioph_invariant ks l (a, b); a ! i = Some k;\n        i = int_encode x\\<rbrakk>\n       \\<Longrightarrow> a[int_encode x := Some (length b)] ! i = Some k\n 2. \\<And>a b x.\n       \\<lbrakk>a ! int_encode x = None; dioph_is_node ks l x;\n        dioph_invariant ks l (a, b); a ! i = Some k;\n        i \\<noteq> int_encode x\\<rbrakk>\n       \\<Longrightarrow> a[int_encode x := Some (length b)] ! i = Some k", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dioph_dfs_start:\n  \"fst (dioph_dfs n ks l) ! int_encode l = Some 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (dioph_dfs n ks l) ! int_encode l = Some 0", "apply (simp add: dioph_dfs_def gen_dfs_simps dioph_dfs.empt dioph_is_node_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (dioph_dfs.dfs n ks (dioph_ins l (dioph_empt ks l))\n          (dioph_succs n ks l)) !\n    int_encode l =\n    Some 0", "apply (rule dioph_dfs_mono [of _ l])"], ["proof (prove)\ngoal (3 subgoals):\n 1. dioph_invariant ks l (dioph_ins l (dioph_empt ks l))\n 2. list_all (dioph_is_node ks l) (dioph_succs n ks l)\n 3. fst (dioph_ins l (dioph_empt ks l)) ! int_encode l = Some 0", "apply (rule dioph_dfs.ins_invariant)"], ["proof (prove)\ngoal (5 subgoals):\n 1. dioph_is_node ks l l\n 2. dioph_invariant ks l (dioph_empt ks l)\n 3. \\<not> dioph_memb l (dioph_empt ks l)\n 4. list_all (dioph_is_node ks l) (dioph_succs n ks l)\n 5. fst (dioph_ins l (dioph_empt ks l)) ! int_encode l = Some 0", "apply (simp add: dioph_is_node_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. dioph_invariant ks l (dioph_empt ks l)\n 2. \\<not> dioph_memb l (dioph_empt ks l)\n 3. list_all (dioph_is_node ks l) (dioph_succs n ks l)\n 4. fst (dioph_ins l (dioph_empt ks l)) ! int_encode l = Some 0", "apply (rule dioph_dfs.empt_invariant)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<not> dioph_memb l (dioph_empt ks l)\n 2. list_all (dioph_is_node ks l) (dioph_succs n ks l)\n 3. fst (dioph_ins l (dioph_empt ks l)) ! int_encode l = Some 0", "apply (simp add: dioph_dfs.empt dioph_is_node_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. list_all (dioph_is_node ks l) (dioph_succs n ks l)\n 2. fst (dioph_ins l (dioph_empt ks l)) ! int_encode l = Some 0", "apply (simp add: dioph_dfs.succs_is_node dioph_is_node_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (dioph_ins l (dioph_empt ks l)) ! int_encode l = Some 0", "apply (simp add: dioph_ins_def dioph_empt_def int_encode_bound dioph_is_node_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma eq_dfa_error: \"\\<not> dfa_accepting (eq_dfa n ks l) (dfa_steps (eq_dfa n ks l) (length (snd (dioph_dfs n ks l))) bss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> dfa_accepting (eq_dfa n ks l)\n            (dfa_steps (eq_dfa n ks l) (length (snd (dioph_dfs n ks l)))\n              bss)", "apply (induct bss)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<not> dfa_accepting (eq_dfa n ks l)\n            (dfa_steps (eq_dfa n ks l) (length (snd (dioph_dfs n ks l))) [])\n 2. \\<And>a bss.\n       \\<not> dfa_accepting (eq_dfa n ks l)\n               (dfa_steps (eq_dfa n ks l) (length (snd (dioph_dfs n ks l)))\n                 bss) \\<Longrightarrow>\n       \\<not> dfa_accepting (eq_dfa n ks l)\n               (dfa_steps (eq_dfa n ks l) (length (snd (dioph_dfs n ks l)))\n                 (a # bss))", "apply (simp add: eq_dfa_def split_beta dfa_accepting_def nth_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a bss.\n       \\<not> dfa_accepting (eq_dfa n ks l)\n               (dfa_steps (eq_dfa n ks l) (length (snd (dioph_dfs n ks l)))\n                 bss) \\<Longrightarrow>\n       \\<not> dfa_accepting (eq_dfa n ks l)\n               (dfa_steps (eq_dfa n ks l) (length (snd (dioph_dfs n ks l)))\n                 (a # bss))", "apply (simp add: eq_dfa_def split_beta nth_append dfa_trans_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma eq_dfa_accepting:\n  \"(l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>* \\<Longrightarrow> list_all (is_alph n) bss \\<Longrightarrow>\n  dfa_accepting (eq_dfa n ks l) (dfa_steps (eq_dfa n ks l) (the (fst (dioph_dfs n ks l) ! int_encode m)) bss) =\n  (eval_dioph ks (nats_of_boolss n bss) = m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n     list_all (is_alph n) bss\\<rbrakk>\n    \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n                       (dfa_steps (eq_dfa n ks l)\n                         (the (fst (dioph_dfs n ks l) ! int_encode m))\n                         bss) =\n                      (eval_dioph ks (nats_of_boolss n bss) = m)", "proof (induct bss arbitrary: m)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>(l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n                          (dfa_steps (eq_dfa n ks l)\n                            (the (fst (dioph_dfs n ks l) ! int_encode m))\n                            []) =\n                         (eval_dioph ks (nats_of_boolss n []) = m)\n 2. \\<And>a bss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>(l, m)\n                            \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n                    list_all (is_alph n) bss\\<rbrakk>\n                   \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n(dfa_steps (eq_dfa n ks l) (the (fst (dioph_dfs n ks l) ! int_encode m))\n  bss) =\n                                     (eval_dioph ks (nats_of_boolss n bss) =\nm);\n        (l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n        list_all (is_alph n) (a # bss)\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n                          (dfa_steps (eq_dfa n ks l)\n                            (the (fst (dioph_dfs n ks l) ! int_encode m))\n                            (a # bss)) =\n                         (eval_dioph ks (nats_of_boolss n (a # bss)) = m)", "case Nil"], ["proof (state)\nthis:\n  (l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*\n  list_all (is_alph n) []\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>(l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n                          (dfa_steps (eq_dfa n ks l)\n                            (the (fst (dioph_dfs n ks l) ! int_encode m))\n                            []) =\n                         (eval_dioph ks (nats_of_boolss n []) = m)\n 2. \\<And>a bss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>(l, m)\n                            \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n                    list_all (is_alph n) bss\\<rbrakk>\n                   \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n(dfa_steps (eq_dfa n ks l) (the (fst (dioph_dfs n ks l) ! int_encode m))\n  bss) =\n                                     (eval_dioph ks (nats_of_boolss n bss) =\nm);\n        (l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n        list_all (is_alph n) (a # bss)\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n                          (dfa_steps (eq_dfa n ks l)\n                            (the (fst (dioph_dfs n ks l) ! int_encode m))\n                            (a # bss)) =\n                         (eval_dioph ks (nats_of_boolss n (a # bss)) = m)", "have l: \"dioph_is_node ks l l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dioph_is_node ks l l", "by (simp add: dioph_is_node_def)"], ["proof (state)\nthis:\n  dioph_is_node ks l l\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>(l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n                          (dfa_steps (eq_dfa n ks l)\n                            (the (fst (dioph_dfs n ks l) ! int_encode m))\n                            []) =\n                         (eval_dioph ks (nats_of_boolss n []) = m)\n 2. \\<And>a bss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>(l, m)\n                            \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n                    list_all (is_alph n) bss\\<rbrakk>\n                   \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n(dfa_steps (eq_dfa n ks l) (the (fst (dioph_dfs n ks l) ! int_encode m))\n  bss) =\n                                     (eval_dioph ks (nats_of_boolss n bss) =\nm);\n        (l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n        list_all (is_alph n) (a # bss)\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n                          (dfa_steps (eq_dfa n ks l)\n                            (the (fst (dioph_dfs n ks l) ! int_encode m))\n                            (a # bss)) =\n                         (eval_dioph ks (nats_of_boolss n (a # bss)) = m)", "with \\<open>(l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*\\<close>"], ["proof (chain)\npicking this:\n  (l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*\n  dioph_is_node ks l l", "have m: \"dioph_is_node ks l m\""], ["proof (prove)\nusing this:\n  (l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*\n  dioph_is_node ks l l\n\ngoal (1 subgoal):\n 1. dioph_is_node ks l m", "by (rule dioph_dfs.succsr_is_node)"], ["proof (state)\nthis:\n  dioph_is_node ks l m\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>(l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n                          (dfa_steps (eq_dfa n ks l)\n                            (the (fst (dioph_dfs n ks l) ! int_encode m))\n                            []) =\n                         (eval_dioph ks (nats_of_boolss n []) = m)\n 2. \\<And>a bss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>(l, m)\n                            \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n                    list_all (is_alph n) bss\\<rbrakk>\n                   \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n(dfa_steps (eq_dfa n ks l) (the (fst (dioph_dfs n ks l) ! int_encode m))\n  bss) =\n                                     (eval_dioph ks (nats_of_boolss n bss) =\nm);\n        (l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n        list_all (is_alph n) (a # bss)\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n                          (dfa_steps (eq_dfa n ks l)\n                            (the (fst (dioph_dfs n ks l) ! int_encode m))\n                            (a # bss)) =\n                         (eval_dioph ks (nats_of_boolss n (a # bss)) = m)", "with l Nil"], ["proof (chain)\npicking this:\n  dioph_is_node ks l l\n  (l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*\n  list_all (is_alph n) []\n  dioph_is_node ks l m", "have \"dioph_memb m (dioph_dfs n ks l)\""], ["proof (prove)\nusing this:\n  dioph_is_node ks l l\n  (l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*\n  list_all (is_alph n) []\n  dioph_is_node ks l m\n\ngoal (1 subgoal):\n 1. dioph_memb m (dioph_dfs n ks l)", "by (simp add: dioph_dfs.dfs_eq_rtrancl dioph_dfs_def)"], ["proof (state)\nthis:\n  dioph_memb m (dioph_dfs n ks l)\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>(l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n                          (dfa_steps (eq_dfa n ks l)\n                            (the (fst (dioph_dfs n ks l) ! int_encode m))\n                            []) =\n                         (eval_dioph ks (nats_of_boolss n []) = m)\n 2. \\<And>a bss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>(l, m)\n                            \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n                    list_all (is_alph n) bss\\<rbrakk>\n                   \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n(dfa_steps (eq_dfa n ks l) (the (fst (dioph_dfs n ks l) ! int_encode m))\n  bss) =\n                                     (eval_dioph ks (nats_of_boolss n bss) =\nm);\n        (l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n        list_all (is_alph n) (a # bss)\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n                          (dfa_steps (eq_dfa n ks l)\n                            (the (fst (dioph_dfs n ks l) ! int_encode m))\n                            (a # bss)) =\n                         (eval_dioph ks (nats_of_boolss n (a # bss)) = m)", "then"], ["proof (chain)\npicking this:\n  dioph_memb m (dioph_dfs n ks l)", "obtain k where k: \"fst (dioph_dfs n ks l) ! int_encode m = Some k\""], ["proof (prove)\nusing this:\n  dioph_memb m (dioph_dfs n ks l)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        fst (dioph_dfs n ks l) ! int_encode m = Some k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: dioph_memb_def)"], ["proof (state)\nthis:\n  fst (dioph_dfs n ks l) ! int_encode m = Some k\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>(l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n                          (dfa_steps (eq_dfa n ks l)\n                            (the (fst (dioph_dfs n ks l) ! int_encode m))\n                            []) =\n                         (eval_dioph ks (nats_of_boolss n []) = m)\n 2. \\<And>a bss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>(l, m)\n                            \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n                    list_all (is_alph n) bss\\<rbrakk>\n                   \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n(dfa_steps (eq_dfa n ks l) (the (fst (dioph_dfs n ks l) ! int_encode m))\n  bss) =\n                                     (eval_dioph ks (nats_of_boolss n bss) =\nm);\n        (l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n        list_all (is_alph n) (a # bss)\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n                          (dfa_steps (eq_dfa n ks l)\n                            (the (fst (dioph_dfs n ks l) ! int_encode m))\n                            (a # bss)) =\n                         (eval_dioph ks (nats_of_boolss n (a # bss)) = m)", "with m"], ["proof (chain)\npicking this:\n  dioph_is_node ks l m\n  fst (dioph_dfs n ks l) ! int_encode m = Some k", "have \"k < length (snd (dioph_dfs n ks l)) \\<and> (snd (dioph_dfs n ks l) ! k = m)\""], ["proof (prove)\nusing this:\n  dioph_is_node ks l m\n  fst (dioph_dfs n ks l) ! int_encode m = Some k\n\ngoal (1 subgoal):\n 1. k < length (snd (dioph_dfs n ks l)) \\<and>\n    snd (dioph_dfs n ks l) ! k = m", "by (simp add: dioph_dfs_bij [symmetric])"], ["proof (state)\nthis:\n  k < length (snd (dioph_dfs n ks l)) \\<and> snd (dioph_dfs n ks l) ! k = m\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>(l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n                          (dfa_steps (eq_dfa n ks l)\n                            (the (fst (dioph_dfs n ks l) ! int_encode m))\n                            []) =\n                         (eval_dioph ks (nats_of_boolss n []) = m)\n 2. \\<And>a bss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>(l, m)\n                            \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n                    list_all (is_alph n) bss\\<rbrakk>\n                   \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n(dfa_steps (eq_dfa n ks l) (the (fst (dioph_dfs n ks l) ! int_encode m))\n  bss) =\n                                     (eval_dioph ks (nats_of_boolss n bss) =\nm);\n        (l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n        list_all (is_alph n) (a # bss)\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n                          (dfa_steps (eq_dfa n ks l)\n                            (the (fst (dioph_dfs n ks l) ! int_encode m))\n                            (a # bss)) =\n                         (eval_dioph ks (nats_of_boolss n (a # bss)) = m)", "with k"], ["proof (chain)\npicking this:\n  fst (dioph_dfs n ks l) ! int_encode m = Some k\n  k < length (snd (dioph_dfs n ks l)) \\<and> snd (dioph_dfs n ks l) ! k = m", "show ?case"], ["proof (prove)\nusing this:\n  fst (dioph_dfs n ks l) ! int_encode m = Some k\n  k < length (snd (dioph_dfs n ks l)) \\<and> snd (dioph_dfs n ks l) ! k = m\n\ngoal (1 subgoal):\n 1. dfa_accepting (eq_dfa n ks l)\n     (dfa_steps (eq_dfa n ks l)\n       (the (fst (dioph_dfs n ks l) ! int_encode m)) []) =\n    (eval_dioph ks (nats_of_boolss n []) = m)", "by (simp add: eval_dioph_replicate_0 dfa_accepting_def eq_dfa_def split_beta nth_append)"], ["proof (state)\nthis:\n  dfa_accepting (eq_dfa n ks l)\n   (dfa_steps (eq_dfa n ks l) (the (fst (dioph_dfs n ks l) ! int_encode m))\n     []) =\n  (eval_dioph ks (nats_of_boolss n []) = m)\n\ngoal (1 subgoal):\n 1. \\<And>a bss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>(l, m)\n                            \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n                    list_all (is_alph n) bss\\<rbrakk>\n                   \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n(dfa_steps (eq_dfa n ks l) (the (fst (dioph_dfs n ks l) ! int_encode m))\n  bss) =\n                                     (eval_dioph ks (nats_of_boolss n bss) =\nm);\n        (l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n        list_all (is_alph n) (a # bss)\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n                          (dfa_steps (eq_dfa n ks l)\n                            (the (fst (dioph_dfs n ks l) ! int_encode m))\n                            (a # bss)) =\n                         (eval_dioph ks (nats_of_boolss n (a # bss)) = m)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a bss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>(l, m)\n                            \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n                    list_all (is_alph n) bss\\<rbrakk>\n                   \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n(dfa_steps (eq_dfa n ks l) (the (fst (dioph_dfs n ks l) ! int_encode m))\n  bss) =\n                                     (eval_dioph ks (nats_of_boolss n bss) =\nm);\n        (l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n        list_all (is_alph n) (a # bss)\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n                          (dfa_steps (eq_dfa n ks l)\n                            (the (fst (dioph_dfs n ks l) ! int_encode m))\n                            (a # bss)) =\n                         (eval_dioph ks (nats_of_boolss n (a # bss)) = m)", "case (Cons bs bss)"], ["proof (state)\nthis:\n  \\<lbrakk>(l, ?m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n                     (dfa_steps (eq_dfa n ks l)\n                       (the (fst (dioph_dfs n ks l) ! int_encode ?m)) bss) =\n                    (eval_dioph ks (nats_of_boolss n bss) = ?m)\n  (l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*\n  list_all (is_alph n) (bs # bss)\n\ngoal (1 subgoal):\n 1. \\<And>a bss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>(l, m)\n                            \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n                    list_all (is_alph n) bss\\<rbrakk>\n                   \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n(dfa_steps (eq_dfa n ks l) (the (fst (dioph_dfs n ks l) ! int_encode m))\n  bss) =\n                                     (eval_dioph ks (nats_of_boolss n bss) =\nm);\n        (l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n        list_all (is_alph n) (a # bss)\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n                          (dfa_steps (eq_dfa n ks l)\n                            (the (fst (dioph_dfs n ks l) ! int_encode m))\n                            (a # bss)) =\n                         (eval_dioph ks (nats_of_boolss n (a # bss)) = m)", "have l: \"dioph_is_node ks l l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dioph_is_node ks l l", "by (simp add: dioph_is_node_def)"], ["proof (state)\nthis:\n  dioph_is_node ks l l\n\ngoal (1 subgoal):\n 1. \\<And>a bss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>(l, m)\n                            \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n                    list_all (is_alph n) bss\\<rbrakk>\n                   \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n(dfa_steps (eq_dfa n ks l) (the (fst (dioph_dfs n ks l) ! int_encode m))\n  bss) =\n                                     (eval_dioph ks (nats_of_boolss n bss) =\nm);\n        (l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n        list_all (is_alph n) (a # bss)\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n                          (dfa_steps (eq_dfa n ks l)\n                            (the (fst (dioph_dfs n ks l) ! int_encode m))\n                            (a # bss)) =\n                         (eval_dioph ks (nats_of_boolss n (a # bss)) = m)", "with \\<open>(l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*\\<close>"], ["proof (chain)\npicking this:\n  (l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*\n  dioph_is_node ks l l", "have m: \"dioph_is_node ks l m\""], ["proof (prove)\nusing this:\n  (l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*\n  dioph_is_node ks l l\n\ngoal (1 subgoal):\n 1. dioph_is_node ks l m", "by (rule dioph_dfs.succsr_is_node)"], ["proof (state)\nthis:\n  dioph_is_node ks l m\n\ngoal (1 subgoal):\n 1. \\<And>a bss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>(l, m)\n                            \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n                    list_all (is_alph n) bss\\<rbrakk>\n                   \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n(dfa_steps (eq_dfa n ks l) (the (fst (dioph_dfs n ks l) ! int_encode m))\n  bss) =\n                                     (eval_dioph ks (nats_of_boolss n bss) =\nm);\n        (l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n        list_all (is_alph n) (a # bss)\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n                          (dfa_steps (eq_dfa n ks l)\n                            (the (fst (dioph_dfs n ks l) ! int_encode m))\n                            (a # bss)) =\n                         (eval_dioph ks (nats_of_boolss n (a # bss)) = m)", "with l Cons"], ["proof (chain)\npicking this:\n  dioph_is_node ks l l\n  \\<lbrakk>(l, ?m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n                     (dfa_steps (eq_dfa n ks l)\n                       (the (fst (dioph_dfs n ks l) ! int_encode ?m)) bss) =\n                    (eval_dioph ks (nats_of_boolss n bss) = ?m)\n  (l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*\n  list_all (is_alph n) (bs # bss)\n  dioph_is_node ks l m", "have \"dioph_memb m (dioph_dfs n ks l)\""], ["proof (prove)\nusing this:\n  dioph_is_node ks l l\n  \\<lbrakk>(l, ?m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n                     (dfa_steps (eq_dfa n ks l)\n                       (the (fst (dioph_dfs n ks l) ! int_encode ?m)) bss) =\n                    (eval_dioph ks (nats_of_boolss n bss) = ?m)\n  (l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*\n  list_all (is_alph n) (bs # bss)\n  dioph_is_node ks l m\n\ngoal (1 subgoal):\n 1. dioph_memb m (dioph_dfs n ks l)", "by (simp add: dioph_dfs.dfs_eq_rtrancl dioph_dfs_def)"], ["proof (state)\nthis:\n  dioph_memb m (dioph_dfs n ks l)\n\ngoal (1 subgoal):\n 1. \\<And>a bss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>(l, m)\n                            \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n                    list_all (is_alph n) bss\\<rbrakk>\n                   \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n(dfa_steps (eq_dfa n ks l) (the (fst (dioph_dfs n ks l) ! int_encode m))\n  bss) =\n                                     (eval_dioph ks (nats_of_boolss n bss) =\nm);\n        (l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n        list_all (is_alph n) (a # bss)\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n                          (dfa_steps (eq_dfa n ks l)\n                            (the (fst (dioph_dfs n ks l) ! int_encode m))\n                            (a # bss)) =\n                         (eval_dioph ks (nats_of_boolss n (a # bss)) = m)", "then"], ["proof (chain)\npicking this:\n  dioph_memb m (dioph_dfs n ks l)", "obtain k where k: \"fst (dioph_dfs n ks l) ! int_encode m = Some k\""], ["proof (prove)\nusing this:\n  dioph_memb m (dioph_dfs n ks l)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        fst (dioph_dfs n ks l) ! int_encode m = Some k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: dioph_memb_def)"], ["proof (state)\nthis:\n  fst (dioph_dfs n ks l) ! int_encode m = Some k\n\ngoal (1 subgoal):\n 1. \\<And>a bss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>(l, m)\n                            \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n                    list_all (is_alph n) bss\\<rbrakk>\n                   \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n(dfa_steps (eq_dfa n ks l) (the (fst (dioph_dfs n ks l) ! int_encode m))\n  bss) =\n                                     (eval_dioph ks (nats_of_boolss n bss) =\nm);\n        (l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n        list_all (is_alph n) (a # bss)\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n                          (dfa_steps (eq_dfa n ks l)\n                            (the (fst (dioph_dfs n ks l) ! int_encode m))\n                            (a # bss)) =\n                         (eval_dioph ks (nats_of_boolss n (a # bss)) = m)", "with m"], ["proof (chain)\npicking this:\n  dioph_is_node ks l m\n  fst (dioph_dfs n ks l) ! int_encode m = Some k", "have k': \"k < length (snd (dioph_dfs n ks l)) \\<and> (snd (dioph_dfs n ks l) ! k = m)\""], ["proof (prove)\nusing this:\n  dioph_is_node ks l m\n  fst (dioph_dfs n ks l) ! int_encode m = Some k\n\ngoal (1 subgoal):\n 1. k < length (snd (dioph_dfs n ks l)) \\<and>\n    snd (dioph_dfs n ks l) ! k = m", "by (simp add: dioph_dfs_bij [symmetric])"], ["proof (state)\nthis:\n  k < length (snd (dioph_dfs n ks l)) \\<and> snd (dioph_dfs n ks l) ! k = m\n\ngoal (1 subgoal):\n 1. \\<And>a bss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>(l, m)\n                            \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n                    list_all (is_alph n) bss\\<rbrakk>\n                   \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n(dfa_steps (eq_dfa n ks l) (the (fst (dioph_dfs n ks l) ! int_encode m))\n  bss) =\n                                     (eval_dioph ks (nats_of_boolss n bss) =\nm);\n        (l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n        list_all (is_alph n) (a # bss)\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n                          (dfa_steps (eq_dfa n ks l)\n                            (the (fst (dioph_dfs n ks l) ! int_encode m))\n                            (a # bss)) =\n                         (eval_dioph ks (nats_of_boolss n (a # bss)) = m)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa_accepting (eq_dfa n ks l)\n     (dfa_steps (eq_dfa n ks l)\n       (the (fst (dioph_dfs n ks l) ! int_encode m)) (bs # bss)) =\n    (eval_dioph ks (nats_of_boolss n (bs # bss)) = m)", "proof (cases \"eval_dioph ks (map nat_of_bool bs) mod 2 = m mod 2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. eval_dioph ks (map of_bool bs) mod 2 = m mod 2 \\<Longrightarrow>\n    dfa_accepting (eq_dfa n ks l)\n     (dfa_steps (eq_dfa n ks l)\n       (the (fst (dioph_dfs n ks l) ! int_encode m)) (bs # bss)) =\n    (eval_dioph ks (nats_of_boolss n (bs # bss)) = m)\n 2. eval_dioph ks (map of_bool bs) mod 2 \\<noteq> m mod 2 \\<Longrightarrow>\n    dfa_accepting (eq_dfa n ks l)\n     (dfa_steps (eq_dfa n ks l)\n       (the (fst (dioph_dfs n ks l) ! int_encode m)) (bs # bss)) =\n    (eval_dioph ks (nats_of_boolss n (bs # bss)) = m)", "case True"], ["proof (state)\nthis:\n  eval_dioph ks (map of_bool bs) mod 2 = m mod 2\n\ngoal (2 subgoals):\n 1. eval_dioph ks (map of_bool bs) mod 2 = m mod 2 \\<Longrightarrow>\n    dfa_accepting (eq_dfa n ks l)\n     (dfa_steps (eq_dfa n ks l)\n       (the (fst (dioph_dfs n ks l) ! int_encode m)) (bs # bss)) =\n    (eval_dioph ks (nats_of_boolss n (bs # bss)) = m)\n 2. eval_dioph ks (map of_bool bs) mod 2 \\<noteq> m mod 2 \\<Longrightarrow>\n    dfa_accepting (eq_dfa n ks l)\n     (dfa_steps (eq_dfa n ks l)\n       (the (fst (dioph_dfs n ks l) ! int_encode m)) (bs # bss)) =\n    (eval_dioph ks (nats_of_boolss n (bs # bss)) = m)", "with k' Cons"], ["proof (chain)\npicking this:\n  k < length (snd (dioph_dfs n ks l)) \\<and> snd (dioph_dfs n ks l) ! k = m\n  \\<lbrakk>(l, ?m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n                     (dfa_steps (eq_dfa n ks l)\n                       (the (fst (dioph_dfs n ks l) ! int_encode ?m)) bss) =\n                    (eval_dioph ks (nats_of_boolss n bss) = ?m)\n  (l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*\n  list_all (is_alph n) (bs # bss)\n  eval_dioph ks (map of_bool bs) mod 2 = m mod 2", "have \"bdd_lookup (fst (eq_dfa n ks l) ! k) bs =\n      the (fst (dioph_dfs n ks l) ! int_encode ((m - eval_dioph ks (map nat_of_bool bs)) div 2))\""], ["proof (prove)\nusing this:\n  k < length (snd (dioph_dfs n ks l)) \\<and> snd (dioph_dfs n ks l) ! k = m\n  \\<lbrakk>(l, ?m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n                     (dfa_steps (eq_dfa n ks l)\n                       (the (fst (dioph_dfs n ks l) ! int_encode ?m)) bss) =\n                    (eval_dioph ks (nats_of_boolss n bss) = ?m)\n  (l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*\n  list_all (is_alph n) (bs # bss)\n  eval_dioph ks (map of_bool bs) mod 2 = m mod 2\n\ngoal (1 subgoal):\n 1. bdd_lookup (fst (eq_dfa n ks l) ! k) bs =\n    the (fst (dioph_dfs n ks l) !\n         int_encode ((m - eval_dioph ks (map of_bool bs)) div 2))", "by (simp add: eq_dfa_def split_beta nth_append bdd_lookup_make_bdd is_alph_def)"], ["proof (state)\nthis:\n  bdd_lookup (fst (eq_dfa n ks l) ! k) bs =\n  the (fst (dioph_dfs n ks l) !\n       int_encode ((m - eval_dioph ks (map of_bool bs)) div 2))\n\ngoal (2 subgoals):\n 1. eval_dioph ks (map of_bool bs) mod 2 = m mod 2 \\<Longrightarrow>\n    dfa_accepting (eq_dfa n ks l)\n     (dfa_steps (eq_dfa n ks l)\n       (the (fst (dioph_dfs n ks l) ! int_encode m)) (bs # bss)) =\n    (eval_dioph ks (nats_of_boolss n (bs # bss)) = m)\n 2. eval_dioph ks (map of_bool bs) mod 2 \\<noteq> m mod 2 \\<Longrightarrow>\n    dfa_accepting (eq_dfa n ks l)\n     (dfa_steps (eq_dfa n ks l)\n       (the (fst (dioph_dfs n ks l) ! int_encode m)) (bs # bss)) =\n    (eval_dioph ks (nats_of_boolss n (bs # bss)) = m)", "moreover"], ["proof (state)\nthis:\n  bdd_lookup (fst (eq_dfa n ks l) ! k) bs =\n  the (fst (dioph_dfs n ks l) !\n       int_encode ((m - eval_dioph ks (map of_bool bs)) div 2))\n\ngoal (2 subgoals):\n 1. eval_dioph ks (map of_bool bs) mod 2 = m mod 2 \\<Longrightarrow>\n    dfa_accepting (eq_dfa n ks l)\n     (dfa_steps (eq_dfa n ks l)\n       (the (fst (dioph_dfs n ks l) ! int_encode m)) (bs # bss)) =\n    (eval_dioph ks (nats_of_boolss n (bs # bss)) = m)\n 2. eval_dioph ks (map of_bool bs) mod 2 \\<noteq> m mod 2 \\<Longrightarrow>\n    dfa_accepting (eq_dfa n ks l)\n     (dfa_steps (eq_dfa n ks l)\n       (the (fst (dioph_dfs n ks l) ! int_encode m)) (bs # bss)) =\n    (eval_dioph ks (nats_of_boolss n (bs # bss)) = m)", "have \"(l, (m - eval_dioph ks (map nat_of_bool bs)) div 2) \\<in> (succsr (dioph_succs n ks))\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l, (m - eval_dioph ks (map of_bool bs)) div 2)\n    \\<in> (succsr (dioph_succs n ks))\\<^sup>*", "apply (rule rtrancl_into_rtrancl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (l, ?b) \\<in> (succsr (dioph_succs n ks))\\<^sup>*\n 2. (?b, (m - eval_dioph ks (map of_bool bs)) div 2)\n    \\<in> succsr (dioph_succs n ks)", "apply (rule Cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (m, (m - eval_dioph ks (map of_bool bs)) div 2)\n    \\<in> succsr (dioph_succs n ks)", "apply (simp add: dioph_succs_def succsr_def map_filter_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (m - eval_dioph ks (map of_bool bs)) div 2\n    \\<in> (\\<lambda>x. (m - eval_dioph ks x) div 2) `\n          {x. (eval_dioph ks x mod 2 = m mod 2 \\<longrightarrow>\n               x \\<in> set (mk_nat_vecs n)) \\<and>\n              eval_dioph ks x mod 2 = m mod 2}", "apply (rule image_eqI [of _ _ \"map nat_of_bool bs\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (m - eval_dioph ks (map of_bool bs)) div 2 =\n    (m - eval_dioph ks (map of_bool bs)) div 2\n 2. map of_bool bs\n    \\<in> {x. (eval_dioph ks x mod 2 = m mod 2 \\<longrightarrow>\n               x \\<in> set (mk_nat_vecs n)) \\<and>\n              eval_dioph ks x mod 2 = m mod 2}", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>(l, ?m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n                     (dfa_steps (eq_dfa n ks l)\n                       (the (fst (dioph_dfs n ks l) ! int_encode ?m)) bss) =\n                    (eval_dioph ks (nats_of_boolss n bss) = ?m)\n  (l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*\n  list_all (is_alph n) (bs # bss)\n\ngoal (2 subgoals):\n 1. (m - eval_dioph ks (map of_bool bs)) div 2 =\n    (m - eval_dioph ks (map of_bool bs)) div 2\n 2. map of_bool bs\n    \\<in> {x. (eval_dioph ks x mod 2 = m mod 2 \\<longrightarrow>\n               x \\<in> set (mk_nat_vecs n)) \\<and>\n              eval_dioph ks x mod 2 = m mod 2}", "apply (simp_all add: True nat_of_bool_mk_nat_vecs is_alph_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (l, (m - eval_dioph ks (map of_bool bs)) div 2)\n  \\<in> (succsr (dioph_succs n ks))\\<^sup>*\n\ngoal (2 subgoals):\n 1. eval_dioph ks (map of_bool bs) mod 2 = m mod 2 \\<Longrightarrow>\n    dfa_accepting (eq_dfa n ks l)\n     (dfa_steps (eq_dfa n ks l)\n       (the (fst (dioph_dfs n ks l) ! int_encode m)) (bs # bss)) =\n    (eval_dioph ks (nats_of_boolss n (bs # bss)) = m)\n 2. eval_dioph ks (map of_bool bs) mod 2 \\<noteq> m mod 2 \\<Longrightarrow>\n    dfa_accepting (eq_dfa n ks l)\n     (dfa_steps (eq_dfa n ks l)\n       (the (fst (dioph_dfs n ks l) ! int_encode m)) (bs # bss)) =\n    (eval_dioph ks (nats_of_boolss n (bs # bss)) = m)", "ultimately"], ["proof (chain)\npicking this:\n  bdd_lookup (fst (eq_dfa n ks l) ! k) bs =\n  the (fst (dioph_dfs n ks l) !\n       int_encode ((m - eval_dioph ks (map of_bool bs)) div 2))\n  (l, (m - eval_dioph ks (map of_bool bs)) div 2)\n  \\<in> (succsr (dioph_succs n ks))\\<^sup>*", "show ?thesis"], ["proof (prove)\nusing this:\n  bdd_lookup (fst (eq_dfa n ks l) ! k) bs =\n  the (fst (dioph_dfs n ks l) !\n       int_encode ((m - eval_dioph ks (map of_bool bs)) div 2))\n  (l, (m - eval_dioph ks (map of_bool bs)) div 2)\n  \\<in> (succsr (dioph_succs n ks))\\<^sup>*\n\ngoal (1 subgoal):\n 1. dfa_accepting (eq_dfa n ks l)\n     (dfa_steps (eq_dfa n ks l)\n       (the (fst (dioph_dfs n ks l) ! int_encode m)) (bs # bss)) =\n    (eval_dioph ks (nats_of_boolss n (bs # bss)) = m)", "using True k k' Cons"], ["proof (prove)\nusing this:\n  bdd_lookup (fst (eq_dfa n ks l) ! k) bs =\n  the (fst (dioph_dfs n ks l) !\n       int_encode ((m - eval_dioph ks (map of_bool bs)) div 2))\n  (l, (m - eval_dioph ks (map of_bool bs)) div 2)\n  \\<in> (succsr (dioph_succs n ks))\\<^sup>*\n  eval_dioph ks (map of_bool bs) mod 2 = m mod 2\n  fst (dioph_dfs n ks l) ! int_encode m = Some k\n  k < length (snd (dioph_dfs n ks l)) \\<and> snd (dioph_dfs n ks l) ! k = m\n  \\<lbrakk>(l, ?m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n                     (dfa_steps (eq_dfa n ks l)\n                       (the (fst (dioph_dfs n ks l) ! int_encode ?m)) bss) =\n                    (eval_dioph ks (nats_of_boolss n bss) = ?m)\n  (l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*\n  list_all (is_alph n) (bs # bss)\n\ngoal (1 subgoal):\n 1. dfa_accepting (eq_dfa n ks l)\n     (dfa_steps (eq_dfa n ks l)\n       (the (fst (dioph_dfs n ks l) ! int_encode m)) (bs # bss)) =\n    (eval_dioph ks (nats_of_boolss n (bs # bss)) = m)", "by (subst eval_dioph_div_mod)\n        (simp add: nats_of_boolss_div2 nats_of_boolss_mod2 is_alph_def dfa_trans_def [abs_def])"], ["proof (state)\nthis:\n  dfa_accepting (eq_dfa n ks l)\n   (dfa_steps (eq_dfa n ks l) (the (fst (dioph_dfs n ks l) ! int_encode m))\n     (bs # bss)) =\n  (eval_dioph ks (nats_of_boolss n (bs # bss)) = m)\n\ngoal (1 subgoal):\n 1. eval_dioph ks (map of_bool bs) mod 2 \\<noteq> m mod 2 \\<Longrightarrow>\n    dfa_accepting (eq_dfa n ks l)\n     (dfa_steps (eq_dfa n ks l)\n       (the (fst (dioph_dfs n ks l) ! int_encode m)) (bs # bss)) =\n    (eval_dioph ks (nats_of_boolss n (bs # bss)) = m)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. eval_dioph ks (map of_bool bs) mod 2 \\<noteq> m mod 2 \\<Longrightarrow>\n    dfa_accepting (eq_dfa n ks l)\n     (dfa_steps (eq_dfa n ks l)\n       (the (fst (dioph_dfs n ks l) ! int_encode m)) (bs # bss)) =\n    (eval_dioph ks (nats_of_boolss n (bs # bss)) = m)", "case False"], ["proof (state)\nthis:\n  eval_dioph ks (map of_bool bs) mod 2 \\<noteq> m mod 2\n\ngoal (1 subgoal):\n 1. eval_dioph ks (map of_bool bs) mod 2 \\<noteq> m mod 2 \\<Longrightarrow>\n    dfa_accepting (eq_dfa n ks l)\n     (dfa_steps (eq_dfa n ks l)\n       (the (fst (dioph_dfs n ks l) ! int_encode m)) (bs # bss)) =\n    (eval_dioph ks (nats_of_boolss n (bs # bss)) = m)", "with k' Cons"], ["proof (chain)\npicking this:\n  k < length (snd (dioph_dfs n ks l)) \\<and> snd (dioph_dfs n ks l) ! k = m\n  \\<lbrakk>(l, ?m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n                     (dfa_steps (eq_dfa n ks l)\n                       (the (fst (dioph_dfs n ks l) ! int_encode ?m)) bss) =\n                    (eval_dioph ks (nats_of_boolss n bss) = ?m)\n  (l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*\n  list_all (is_alph n) (bs # bss)\n  eval_dioph ks (map of_bool bs) mod 2 \\<noteq> m mod 2", "have \"bdd_lookup (fst (eq_dfa n ks l) ! k) bs = length (snd (dioph_dfs n ks l))\""], ["proof (prove)\nusing this:\n  k < length (snd (dioph_dfs n ks l)) \\<and> snd (dioph_dfs n ks l) ! k = m\n  \\<lbrakk>(l, ?m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n                     (dfa_steps (eq_dfa n ks l)\n                       (the (fst (dioph_dfs n ks l) ! int_encode ?m)) bss) =\n                    (eval_dioph ks (nats_of_boolss n bss) = ?m)\n  (l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*\n  list_all (is_alph n) (bs # bss)\n  eval_dioph ks (map of_bool bs) mod 2 \\<noteq> m mod 2\n\ngoal (1 subgoal):\n 1. bdd_lookup (fst (eq_dfa n ks l) ! k) bs =\n    length (snd (dioph_dfs n ks l))", "by (simp add: eq_dfa_def split_beta nth_append bdd_lookup_make_bdd is_alph_def)"], ["proof (state)\nthis:\n  bdd_lookup (fst (eq_dfa n ks l) ! k) bs = length (snd (dioph_dfs n ks l))\n\ngoal (1 subgoal):\n 1. eval_dioph ks (map of_bool bs) mod 2 \\<noteq> m mod 2 \\<Longrightarrow>\n    dfa_accepting (eq_dfa n ks l)\n     (dfa_steps (eq_dfa n ks l)\n       (the (fst (dioph_dfs n ks l) ! int_encode m)) (bs # bss)) =\n    (eval_dioph ks (nats_of_boolss n (bs # bss)) = m)", "with False k k' Cons"], ["proof (chain)\npicking this:\n  eval_dioph ks (map of_bool bs) mod 2 \\<noteq> m mod 2\n  fst (dioph_dfs n ks l) ! int_encode m = Some k\n  k < length (snd (dioph_dfs n ks l)) \\<and> snd (dioph_dfs n ks l) ! k = m\n  \\<lbrakk>(l, ?m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n                     (dfa_steps (eq_dfa n ks l)\n                       (the (fst (dioph_dfs n ks l) ! int_encode ?m)) bss) =\n                    (eval_dioph ks (nats_of_boolss n bss) = ?m)\n  (l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*\n  list_all (is_alph n) (bs # bss)\n  bdd_lookup (fst (eq_dfa n ks l) ! k) bs = length (snd (dioph_dfs n ks l))", "show ?thesis"], ["proof (prove)\nusing this:\n  eval_dioph ks (map of_bool bs) mod 2 \\<noteq> m mod 2\n  fst (dioph_dfs n ks l) ! int_encode m = Some k\n  k < length (snd (dioph_dfs n ks l)) \\<and> snd (dioph_dfs n ks l) ! k = m\n  \\<lbrakk>(l, ?m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_accepting (eq_dfa n ks l)\n                     (dfa_steps (eq_dfa n ks l)\n                       (the (fst (dioph_dfs n ks l) ! int_encode ?m)) bss) =\n                    (eval_dioph ks (nats_of_boolss n bss) = ?m)\n  (l, m) \\<in> (succsr (dioph_succs n ks))\\<^sup>*\n  list_all (is_alph n) (bs # bss)\n  bdd_lookup (fst (eq_dfa n ks l) ! k) bs = length (snd (dioph_dfs n ks l))\n\ngoal (1 subgoal):\n 1. dfa_accepting (eq_dfa n ks l)\n     (dfa_steps (eq_dfa n ks l)\n       (the (fst (dioph_dfs n ks l) ! int_encode m)) (bs # bss)) =\n    (eval_dioph ks (nats_of_boolss n (bs # bss)) = m)", "by (subst eval_dioph_div_mod)\n        (simp add: nats_of_boolss_div2 nats_of_boolss_mod2 is_alph_def\n         dfa_trans_def eq_dfa_error)"], ["proof (state)\nthis:\n  dfa_accepting (eq_dfa n ks l)\n   (dfa_steps (eq_dfa n ks l) (the (fst (dioph_dfs n ks l) ! int_encode m))\n     (bs # bss)) =\n  (eval_dioph ks (nats_of_boolss n (bs # bss)) = m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dfa_accepting (eq_dfa n ks l)\n   (dfa_steps (eq_dfa n ks l) (the (fst (dioph_dfs n ks l) ! int_encode m))\n     (bs # bss)) =\n  (eval_dioph ks (nats_of_boolss n (bs # bss)) = m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eq_dfa_accepts:\n  assumes bss: \"list_all (is_alph n) bss\"\n  shows \"dfa_accepts (eq_dfa n ks l) bss = (eval_dioph ks (nats_of_boolss n bss) = l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa_accepts (eq_dfa n ks l) bss =\n    (eval_dioph ks (nats_of_boolss n bss) = l)", "by (simp add: accepts_def)\n    (rule eq_dfa_accepting [of l l n ks, OF _ bss, simplified dioph_dfs_start, simplified])"], ["", "lemma bddh_make_bdd: \"bddh n (make_bdd f n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bddh n (make_bdd f n xs)", "by (induct n arbitrary: xs) simp_all"], ["", "lemma bdd_all_make_bdd: \"bdd_all P (make_bdd f n xs) = (\\<forall>ys\\<in>set (mk_nat_vecs n). P (f (xs @ ys)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_all P (make_bdd f n xs) =\n    (\\<forall>ys\\<in>set (mk_nat_vecs n). P (f (xs @ ys)))", "by (induct n arbitrary: xs) (auto simp add: Let_def)"], ["", "lemma eq_wf_dfa: \"wf_dfa (eq_dfa n ks l) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_dfa (eq_dfa n ks l) n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_dfa (eq_dfa n ks l) n", "have \"\\<forall>x\\<in>set (snd (dioph_dfs n ks l)). \\<forall>ys\\<in>set (mk_nat_vecs n).\n    eval_dioph ks ys mod 2 = x mod 2 \\<longrightarrow>\n      the (fst (dioph_dfs n ks l) ! int_encode ((x - eval_dioph ks ys) div 2)) <\n        Suc (length (snd (dioph_dfs n ks l)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (snd (dioph_dfs n ks l)).\n       \\<forall>ys\\<in>set (mk_nat_vecs n).\n          eval_dioph ks ys mod 2 = x mod 2 \\<longrightarrow>\n          the (fst (dioph_dfs n ks l) !\n               int_encode ((x - eval_dioph ks ys) div 2))\n          < Suc (length (snd (dioph_dfs n ks l)))", "proof (intro ballI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ys.\n       \\<lbrakk>x \\<in> set (snd (dioph_dfs n ks l));\n        ys \\<in> set (mk_nat_vecs n);\n        eval_dioph ks ys mod 2 = x mod 2\\<rbrakk>\n       \\<Longrightarrow> the (fst (dioph_dfs n ks l) !\n                              int_encode ((x - eval_dioph ks ys) div 2))\n                         < Suc (length (snd (dioph_dfs n ks l)))", "fix x ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ys.\n       \\<lbrakk>x \\<in> set (snd (dioph_dfs n ks l));\n        ys \\<in> set (mk_nat_vecs n);\n        eval_dioph ks ys mod 2 = x mod 2\\<rbrakk>\n       \\<Longrightarrow> the (fst (dioph_dfs n ks l) !\n                              int_encode ((x - eval_dioph ks ys) div 2))\n                         < Suc (length (snd (dioph_dfs n ks l)))", "assume x: \"x \\<in> set (snd (dioph_dfs n ks l))\"\n    and ys: \"ys \\<in> set (mk_nat_vecs n)\"\n    and ys': \"eval_dioph ks ys mod 2 = x mod 2\""], ["proof (state)\nthis:\n  x \\<in> set (snd (dioph_dfs n ks l))\n  ys \\<in> set (mk_nat_vecs n)\n  eval_dioph ks ys mod 2 = x mod 2\n\ngoal (1 subgoal):\n 1. \\<And>x ys.\n       \\<lbrakk>x \\<in> set (snd (dioph_dfs n ks l));\n        ys \\<in> set (mk_nat_vecs n);\n        eval_dioph ks ys mod 2 = x mod 2\\<rbrakk>\n       \\<Longrightarrow> the (fst (dioph_dfs n ks l) !\n                              int_encode ((x - eval_dioph ks ys) div 2))\n                         < Suc (length (snd (dioph_dfs n ks l)))", "from x"], ["proof (chain)\npicking this:\n  x \\<in> set (snd (dioph_dfs n ks l))", "obtain k where k: \"fst (dioph_dfs n ks l) ! int_encode x = Some k\"\n      and k': \"dioph_is_node ks l x\""], ["proof (prove)\nusing this:\n  x \\<in> set (snd (dioph_dfs n ks l))\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>fst (dioph_dfs n ks l) ! int_encode x = Some k;\n         dioph_is_node ks l x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: in_set_conv_nth dioph_dfs_bij [symmetric])"], ["proof (state)\nthis:\n  fst (dioph_dfs n ks l) ! int_encode x = Some k\n  dioph_is_node ks l x\n\ngoal (1 subgoal):\n 1. \\<And>x ys.\n       \\<lbrakk>x \\<in> set (snd (dioph_dfs n ks l));\n        ys \\<in> set (mk_nat_vecs n);\n        eval_dioph ks ys mod 2 = x mod 2\\<rbrakk>\n       \\<Longrightarrow> the (fst (dioph_dfs n ks l) !\n                              int_encode ((x - eval_dioph ks ys) div 2))\n                         < Suc (length (snd (dioph_dfs n ks l)))", "from k"], ["proof (chain)\npicking this:\n  fst (dioph_dfs n ks l) ! int_encode x = Some k", "have \"dioph_memb x (dioph_dfs n ks l)\""], ["proof (prove)\nusing this:\n  fst (dioph_dfs n ks l) ! int_encode x = Some k\n\ngoal (1 subgoal):\n 1. dioph_memb x (dioph_dfs n ks l)", "by (simp add: dioph_memb_def split_beta)"], ["proof (state)\nthis:\n  dioph_memb x (dioph_dfs n ks l)\n\ngoal (1 subgoal):\n 1. \\<And>x ys.\n       \\<lbrakk>x \\<in> set (snd (dioph_dfs n ks l));\n        ys \\<in> set (mk_nat_vecs n);\n        eval_dioph ks ys mod 2 = x mod 2\\<rbrakk>\n       \\<Longrightarrow> the (fst (dioph_dfs n ks l) !\n                              int_encode ((x - eval_dioph ks ys) div 2))\n                         < Suc (length (snd (dioph_dfs n ks l)))", "moreover"], ["proof (state)\nthis:\n  dioph_memb x (dioph_dfs n ks l)\n\ngoal (1 subgoal):\n 1. \\<And>x ys.\n       \\<lbrakk>x \\<in> set (snd (dioph_dfs n ks l));\n        ys \\<in> set (mk_nat_vecs n);\n        eval_dioph ks ys mod 2 = x mod 2\\<rbrakk>\n       \\<Longrightarrow> the (fst (dioph_dfs n ks l) !\n                              int_encode ((x - eval_dioph ks ys) div 2))\n                         < Suc (length (snd (dioph_dfs n ks l)))", "have ll: \"dioph_is_node ks l l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dioph_is_node ks l l", "by (simp add: dioph_is_node_def)"], ["proof (state)\nthis:\n  dioph_is_node ks l l\n\ngoal (1 subgoal):\n 1. \\<And>x ys.\n       \\<lbrakk>x \\<in> set (snd (dioph_dfs n ks l));\n        ys \\<in> set (mk_nat_vecs n);\n        eval_dioph ks ys mod 2 = x mod 2\\<rbrakk>\n       \\<Longrightarrow> the (fst (dioph_dfs n ks l) !\n                              int_encode ((x - eval_dioph ks ys) div 2))\n                         < Suc (length (snd (dioph_dfs n ks l)))", "ultimately"], ["proof (chain)\npicking this:\n  dioph_memb x (dioph_dfs n ks l)\n  dioph_is_node ks l l", "have \"(l, x) \\<in> (succsr (dioph_succs n ks))\\<^sup>*\""], ["proof (prove)\nusing this:\n  dioph_memb x (dioph_dfs n ks l)\n  dioph_is_node ks l l\n\ngoal (1 subgoal):\n 1. (l, x) \\<in> (succsr (dioph_succs n ks))\\<^sup>*", "using k'"], ["proof (prove)\nusing this:\n  dioph_memb x (dioph_dfs n ks l)\n  dioph_is_node ks l l\n  dioph_is_node ks l x\n\ngoal (1 subgoal):\n 1. (l, x) \\<in> (succsr (dioph_succs n ks))\\<^sup>*", "by (simp add: dioph_dfs.dfs_eq_rtrancl dioph_dfs_def)"], ["proof (state)\nthis:\n  (l, x) \\<in> (succsr (dioph_succs n ks))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>x ys.\n       \\<lbrakk>x \\<in> set (snd (dioph_dfs n ks l));\n        ys \\<in> set (mk_nat_vecs n);\n        eval_dioph ks ys mod 2 = x mod 2\\<rbrakk>\n       \\<Longrightarrow> the (fst (dioph_dfs n ks l) !\n                              int_encode ((x - eval_dioph ks ys) div 2))\n                         < Suc (length (snd (dioph_dfs n ks l)))", "then"], ["proof (chain)\npicking this:\n  (l, x) \\<in> (succsr (dioph_succs n ks))\\<^sup>*", "have \"(l, (x - eval_dioph ks ys) div 2) \\<in> (succsr (dioph_succs n ks))\\<^sup>*\""], ["proof (prove)\nusing this:\n  (l, x) \\<in> (succsr (dioph_succs n ks))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (l, (x - eval_dioph ks ys) div 2)\n    \\<in> (succsr (dioph_succs n ks))\\<^sup>*", "apply (rule rtrancl_into_rtrancl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, (x - eval_dioph ks ys) div 2) \\<in> succsr (dioph_succs n ks)", "apply (simp add: succsr_def dioph_succs_def map_filter_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x - eval_dioph ks ys) div 2\n    \\<in> (\\<lambda>xa. (x - eval_dioph ks xa) div 2) `\n          {xa.\n           (eval_dioph ks xa mod 2 = x mod 2 \\<longrightarrow>\n            xa \\<in> set (mk_nat_vecs n)) \\<and>\n           eval_dioph ks xa mod 2 = x mod 2}", "apply (rule image_eqI [of _ _ ys])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (x - eval_dioph ks ys) div 2 = (x - eval_dioph ks ys) div 2\n 2. ys \\<in> {xa.\n              (eval_dioph ks xa mod 2 = x mod 2 \\<longrightarrow>\n               xa \\<in> set (mk_nat_vecs n)) \\<and>\n              eval_dioph ks xa mod 2 = x mod 2}", "apply (simp_all add: ys ys')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (l, (x - eval_dioph ks ys) div 2)\n  \\<in> (succsr (dioph_succs n ks))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>x ys.\n       \\<lbrakk>x \\<in> set (snd (dioph_dfs n ks l));\n        ys \\<in> set (mk_nat_vecs n);\n        eval_dioph ks ys mod 2 = x mod 2\\<rbrakk>\n       \\<Longrightarrow> the (fst (dioph_dfs n ks l) !\n                              int_encode ((x - eval_dioph ks ys) div 2))\n                         < Suc (length (snd (dioph_dfs n ks l)))", "moreover"], ["proof (state)\nthis:\n  (l, (x - eval_dioph ks ys) div 2)\n  \\<in> (succsr (dioph_succs n ks))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>x ys.\n       \\<lbrakk>x \\<in> set (snd (dioph_dfs n ks l));\n        ys \\<in> set (mk_nat_vecs n);\n        eval_dioph ks ys mod 2 = x mod 2\\<rbrakk>\n       \\<Longrightarrow> the (fst (dioph_dfs n ks l) !\n                              int_encode ((x - eval_dioph ks ys) div 2))\n                         < Suc (length (snd (dioph_dfs n ks l)))", "from dioph_dfs.succs_is_node [OF k', of n] ys ys'"], ["proof (chain)\npicking this:\n  list_all (dioph_is_node ks l) (dioph_succs n ks x)\n  ys \\<in> set (mk_nat_vecs n)\n  eval_dioph ks ys mod 2 = x mod 2", "have x': \"dioph_is_node ks l ((x - eval_dioph ks ys) div 2)\""], ["proof (prove)\nusing this:\n  list_all (dioph_is_node ks l) (dioph_succs n ks x)\n  ys \\<in> set (mk_nat_vecs n)\n  eval_dioph ks ys mod 2 = x mod 2\n\ngoal (1 subgoal):\n 1. dioph_is_node ks l ((x - eval_dioph ks ys) div 2)", "by (auto simp add: dioph_succs_def map_filter_def list_all_iff)"], ["proof (state)\nthis:\n  dioph_is_node ks l ((x - eval_dioph ks ys) div 2)\n\ngoal (1 subgoal):\n 1. \\<And>x ys.\n       \\<lbrakk>x \\<in> set (snd (dioph_dfs n ks l));\n        ys \\<in> set (mk_nat_vecs n);\n        eval_dioph ks ys mod 2 = x mod 2\\<rbrakk>\n       \\<Longrightarrow> the (fst (dioph_dfs n ks l) !\n                              int_encode ((x - eval_dioph ks ys) div 2))\n                         < Suc (length (snd (dioph_dfs n ks l)))", "ultimately"], ["proof (chain)\npicking this:\n  (l, (x - eval_dioph ks ys) div 2)\n  \\<in> (succsr (dioph_succs n ks))\\<^sup>*\n  dioph_is_node ks l ((x - eval_dioph ks ys) div 2)", "have \"dioph_memb ((x - eval_dioph ks ys) div 2) (dioph_dfs n ks l)\""], ["proof (prove)\nusing this:\n  (l, (x - eval_dioph ks ys) div 2)\n  \\<in> (succsr (dioph_succs n ks))\\<^sup>*\n  dioph_is_node ks l ((x - eval_dioph ks ys) div 2)\n\ngoal (1 subgoal):\n 1. dioph_memb ((x - eval_dioph ks ys) div 2) (dioph_dfs n ks l)", "by (simp add: dioph_dfs.dfs_eq_rtrancl dioph_dfs_def ll)"], ["proof (state)\nthis:\n  dioph_memb ((x - eval_dioph ks ys) div 2) (dioph_dfs n ks l)\n\ngoal (1 subgoal):\n 1. \\<And>x ys.\n       \\<lbrakk>x \\<in> set (snd (dioph_dfs n ks l));\n        ys \\<in> set (mk_nat_vecs n);\n        eval_dioph ks ys mod 2 = x mod 2\\<rbrakk>\n       \\<Longrightarrow> the (fst (dioph_dfs n ks l) !\n                              int_encode ((x - eval_dioph ks ys) div 2))\n                         < Suc (length (snd (dioph_dfs n ks l)))", "then"], ["proof (chain)\npicking this:\n  dioph_memb ((x - eval_dioph ks ys) div 2) (dioph_dfs n ks l)", "obtain k' where k': \"fst (dioph_dfs n ks l) !\n      int_encode ((x - eval_dioph ks ys) div 2) = Some k'\""], ["proof (prove)\nusing this:\n  dioph_memb ((x - eval_dioph ks ys) div 2) (dioph_dfs n ks l)\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        fst (dioph_dfs n ks l) ! int_encode ((x - eval_dioph ks ys) div 2) =\n        Some k' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: dioph_memb_def)"], ["proof (state)\nthis:\n  fst (dioph_dfs n ks l) ! int_encode ((x - eval_dioph ks ys) div 2) =\n  Some k'\n\ngoal (1 subgoal):\n 1. \\<And>x ys.\n       \\<lbrakk>x \\<in> set (snd (dioph_dfs n ks l));\n        ys \\<in> set (mk_nat_vecs n);\n        eval_dioph ks ys mod 2 = x mod 2\\<rbrakk>\n       \\<Longrightarrow> the (fst (dioph_dfs n ks l) !\n                              int_encode ((x - eval_dioph ks ys) div 2))\n                         < Suc (length (snd (dioph_dfs n ks l)))", "with x'"], ["proof (chain)\npicking this:\n  dioph_is_node ks l ((x - eval_dioph ks ys) div 2)\n  fst (dioph_dfs n ks l) ! int_encode ((x - eval_dioph ks ys) div 2) =\n  Some k'", "have \"k' < length (snd (dioph_dfs n ks l)) \\<and>\n      snd (dioph_dfs n ks l) ! k' = ((x - eval_dioph ks ys) div 2)\""], ["proof (prove)\nusing this:\n  dioph_is_node ks l ((x - eval_dioph ks ys) div 2)\n  fst (dioph_dfs n ks l) ! int_encode ((x - eval_dioph ks ys) div 2) =\n  Some k'\n\ngoal (1 subgoal):\n 1. k' < length (snd (dioph_dfs n ks l)) \\<and>\n    snd (dioph_dfs n ks l) ! k' = (x - eval_dioph ks ys) div 2", "by (simp add: dioph_dfs_bij [symmetric])"], ["proof (state)\nthis:\n  k' < length (snd (dioph_dfs n ks l)) \\<and>\n  snd (dioph_dfs n ks l) ! k' = (x - eval_dioph ks ys) div 2\n\ngoal (1 subgoal):\n 1. \\<And>x ys.\n       \\<lbrakk>x \\<in> set (snd (dioph_dfs n ks l));\n        ys \\<in> set (mk_nat_vecs n);\n        eval_dioph ks ys mod 2 = x mod 2\\<rbrakk>\n       \\<Longrightarrow> the (fst (dioph_dfs n ks l) !\n                              int_encode ((x - eval_dioph ks ys) div 2))\n                         < Suc (length (snd (dioph_dfs n ks l)))", "with k'"], ["proof (chain)\npicking this:\n  fst (dioph_dfs n ks l) ! int_encode ((x - eval_dioph ks ys) div 2) =\n  Some k'\n  k' < length (snd (dioph_dfs n ks l)) \\<and>\n  snd (dioph_dfs n ks l) ! k' = (x - eval_dioph ks ys) div 2", "show \"the (fst (dioph_dfs n ks l) ! int_encode ((x - eval_dioph ks ys) div 2)) <\n      Suc (length (snd (dioph_dfs n ks l)))\""], ["proof (prove)\nusing this:\n  fst (dioph_dfs n ks l) ! int_encode ((x - eval_dioph ks ys) div 2) =\n  Some k'\n  k' < length (snd (dioph_dfs n ks l)) \\<and>\n  snd (dioph_dfs n ks l) ! k' = (x - eval_dioph ks ys) div 2\n\ngoal (1 subgoal):\n 1. the (fst (dioph_dfs n ks l) ! int_encode ((x - eval_dioph ks ys) div 2))\n    < Suc (length (snd (dioph_dfs n ks l)))", "by simp"], ["proof (state)\nthis:\n  the (fst (dioph_dfs n ks l) ! int_encode ((x - eval_dioph ks ys) div 2))\n  < Suc (length (snd (dioph_dfs n ks l)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (snd (dioph_dfs n ks l)).\n     \\<forall>ys\\<in>set (mk_nat_vecs n).\n        eval_dioph ks ys mod 2 = x mod 2 \\<longrightarrow>\n        the (fst (dioph_dfs n ks l) !\n             int_encode ((x - eval_dioph ks ys) div 2))\n        < Suc (length (snd (dioph_dfs n ks l)))\n\ngoal (1 subgoal):\n 1. wf_dfa (eq_dfa n ks l) n", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set (snd (dioph_dfs n ks l)).\n     \\<forall>ys\\<in>set (mk_nat_vecs n).\n        eval_dioph ks ys mod 2 = x mod 2 \\<longrightarrow>\n        the (fst (dioph_dfs n ks l) !\n             int_encode ((x - eval_dioph ks ys) div 2))\n        < Suc (length (snd (dioph_dfs n ks l)))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (snd (dioph_dfs n ks l)).\n     \\<forall>ys\\<in>set (mk_nat_vecs n).\n        eval_dioph ks ys mod 2 = x mod 2 \\<longrightarrow>\n        the (fst (dioph_dfs n ks l) !\n             int_encode ((x - eval_dioph ks ys) div 2))\n        < Suc (length (snd (dioph_dfs n ks l)))\n\ngoal (1 subgoal):\n 1. wf_dfa (eq_dfa n ks l) n", "by (simp add: eq_dfa_def split_beta wf_dfa_def dfa_is_node_def list_all_iff\n      bddh_make_bdd bdd_all_make_bdd)"], ["proof (state)\nthis:\n  wf_dfa (eq_dfa n ks l) n\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Diophantine Inequations\\<close>"], ["", "definition\n  \"dioph_ineq_succs n ks m = map (\\<lambda>xs.\n     (m - eval_dioph ks xs) div 2) (mk_nat_vecs n)\""], ["", "interpretation dioph_ineq_dfs: DFS \"dioph_ineq_succs n ks\" \"dioph_is_node ks l\"\n  \"dioph_invariant ks l\" dioph_ins dioph_memb \"dioph_empt ks l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DFS (dioph_ineq_succs n ks) (dioph_is_node ks l) (dioph_invariant ks l)\n     dioph_ins dioph_memb (dioph_empt ks l)", "proof (standard, goal_cases)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x y S.\n       \\<lbrakk>dioph_is_node ks l x; dioph_is_node ks l y;\n        dioph_invariant ks l S; \\<not> dioph_memb y S\\<rbrakk>\n       \\<Longrightarrow> dioph_memb x (dioph_ins y S) =\n                         (x = y \\<or> dioph_memb x S)\n 2. \\<And>x.\n       dioph_is_node ks l x \\<Longrightarrow>\n       \\<not> dioph_memb x (dioph_empt ks l)\n 3. \\<And>x.\n       dioph_is_node ks l x \\<Longrightarrow>\n       list_all (dioph_is_node ks l) (dioph_ineq_succs n ks x)\n 4. dioph_invariant ks l (dioph_empt ks l)\n 5. \\<And>x S.\n       \\<lbrakk>dioph_is_node ks l x; dioph_invariant ks l S;\n        \\<not> dioph_memb x S\\<rbrakk>\n       \\<Longrightarrow> dioph_invariant ks l (dioph_ins x S)\n 6. finite {x. dioph_is_node ks l x}", "case (1 x y)"], ["proof (state)\nthis:\n  dioph_is_node ks l x\n  dioph_is_node ks l y\n  dioph_invariant ks l S_\n  \\<not> dioph_memb y S_\n\ngoal (6 subgoals):\n 1. \\<And>x y S.\n       \\<lbrakk>dioph_is_node ks l x; dioph_is_node ks l y;\n        dioph_invariant ks l S; \\<not> dioph_memb y S\\<rbrakk>\n       \\<Longrightarrow> dioph_memb x (dioph_ins y S) =\n                         (x = y \\<or> dioph_memb x S)\n 2. \\<And>x.\n       dioph_is_node ks l x \\<Longrightarrow>\n       \\<not> dioph_memb x (dioph_empt ks l)\n 3. \\<And>x.\n       dioph_is_node ks l x \\<Longrightarrow>\n       list_all (dioph_is_node ks l) (dioph_ineq_succs n ks x)\n 4. dioph_invariant ks l (dioph_empt ks l)\n 5. \\<And>x S.\n       \\<lbrakk>dioph_is_node ks l x; dioph_invariant ks l S;\n        \\<not> dioph_memb x S\\<rbrakk>\n       \\<Longrightarrow> dioph_invariant ks l (dioph_ins x S)\n 6. finite {x. dioph_is_node ks l x}", "then"], ["proof (chain)\npicking this:\n  dioph_is_node ks l x\n  dioph_is_node ks l y\n  dioph_invariant ks l S_\n  \\<not> dioph_memb y S_", "show ?case"], ["proof (prove)\nusing this:\n  dioph_is_node ks l x\n  dioph_is_node ks l y\n  dioph_invariant ks l S_\n  \\<not> dioph_memb y S_\n\ngoal (1 subgoal):\n 1. dioph_memb x (dioph_ins y S_) = (x = y \\<or> dioph_memb x S_)", "apply (simp add: dioph_memb_def dioph_ins_def split_beta dioph_invariant_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dioph_is_node ks l x; dioph_is_node ks l y;\n     length (fst S_) =\n     nat (2 * max \\<bar>l\\<bar> (sum_list (map abs ks)) + 1);\n     fst S_ ! int_encode y = None\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>ya.\n                          (fst S_)[int_encode y := Some (length (snd S_))] !\n                          int_encode x =\n                          Some ya) =\n                      (x = y \\<or>\n                       (\\<exists>y. fst S_ ! int_encode x = Some y))", "apply (cases \"x = y\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>dioph_is_node ks l x; dioph_is_node ks l y;\n     length (fst S_) =\n     nat (2 * max \\<bar>l\\<bar> (sum_list (map abs ks)) + 1);\n     fst S_ ! int_encode y = None; x = y\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>ya.\n                          (fst S_)[int_encode y := Some (length (snd S_))] !\n                          int_encode x =\n                          Some ya) =\n                      (x = y \\<or>\n                       (\\<exists>y. fst S_ ! int_encode x = Some y))\n 2. \\<lbrakk>dioph_is_node ks l x; dioph_is_node ks l y;\n     length (fst S_) =\n     nat (2 * max \\<bar>l\\<bar> (sum_list (map abs ks)) + 1);\n     fst S_ ! int_encode y = None; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>ya.\n                          (fst S_)[int_encode y := Some (length (snd S_))] !\n                          int_encode x =\n                          Some ya) =\n                      (x = y \\<or>\n                       (\\<exists>y. fst S_ ! int_encode x = Some y))", "apply (simp add: int_encode_bound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dioph_is_node ks l x; dioph_is_node ks l y;\n     length (fst S_) =\n     nat (2 * max \\<bar>l\\<bar> (sum_list (map abs ks)) + 1);\n     fst S_ ! int_encode y = None; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>ya.\n                          (fst S_)[int_encode y := Some (length (snd S_))] !\n                          int_encode x =\n                          Some ya) =\n                      (x = y \\<or>\n                       (\\<exists>y. fst S_ ! int_encode x = Some y))", "apply (simp add: inj_eq [OF inj_int_encode])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  dioph_memb x (dioph_ins y S_) = (x = y \\<or> dioph_memb x S_)\n\ngoal (5 subgoals):\n 1. \\<And>x.\n       dioph_is_node ks l x \\<Longrightarrow>\n       \\<not> dioph_memb x (dioph_empt ks l)\n 2. \\<And>x.\n       dioph_is_node ks l x \\<Longrightarrow>\n       list_all (dioph_is_node ks l) (dioph_ineq_succs n ks x)\n 3. dioph_invariant ks l (dioph_empt ks l)\n 4. \\<And>x S.\n       \\<lbrakk>dioph_is_node ks l x; dioph_invariant ks l S;\n        \\<not> dioph_memb x S\\<rbrakk>\n       \\<Longrightarrow> dioph_invariant ks l (dioph_ins x S)\n 5. finite {x. dioph_is_node ks l x}", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x.\n       dioph_is_node ks l x \\<Longrightarrow>\n       \\<not> dioph_memb x (dioph_empt ks l)\n 2. \\<And>x.\n       dioph_is_node ks l x \\<Longrightarrow>\n       list_all (dioph_is_node ks l) (dioph_ineq_succs n ks x)\n 3. dioph_invariant ks l (dioph_empt ks l)\n 4. \\<And>x S.\n       \\<lbrakk>dioph_is_node ks l x; dioph_invariant ks l S;\n        \\<not> dioph_memb x S\\<rbrakk>\n       \\<Longrightarrow> dioph_invariant ks l (dioph_ins x S)\n 5. finite {x. dioph_is_node ks l x}", "case 2"], ["proof (state)\nthis:\n  dioph_is_node ks l x_\n\ngoal (5 subgoals):\n 1. \\<And>x.\n       dioph_is_node ks l x \\<Longrightarrow>\n       \\<not> dioph_memb x (dioph_empt ks l)\n 2. \\<And>x.\n       dioph_is_node ks l x \\<Longrightarrow>\n       list_all (dioph_is_node ks l) (dioph_ineq_succs n ks x)\n 3. dioph_invariant ks l (dioph_empt ks l)\n 4. \\<And>x S.\n       \\<lbrakk>dioph_is_node ks l x; dioph_invariant ks l S;\n        \\<not> dioph_memb x S\\<rbrakk>\n       \\<Longrightarrow> dioph_invariant ks l (dioph_ins x S)\n 5. finite {x. dioph_is_node ks l x}", "then"], ["proof (chain)\npicking this:\n  dioph_is_node ks l x_", "show ?case"], ["proof (prove)\nusing this:\n  dioph_is_node ks l x_\n\ngoal (1 subgoal):\n 1. \\<not> dioph_memb x_ (dioph_empt ks l)", "by (simp add: dioph_memb_def dioph_empt_def int_encode_bound)"], ["proof (state)\nthis:\n  \\<not> dioph_memb x_ (dioph_empt ks l)\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       dioph_is_node ks l x \\<Longrightarrow>\n       list_all (dioph_is_node ks l) (dioph_ineq_succs n ks x)\n 2. dioph_invariant ks l (dioph_empt ks l)\n 3. \\<And>x S.\n       \\<lbrakk>dioph_is_node ks l x; dioph_invariant ks l S;\n        \\<not> dioph_memb x S\\<rbrakk>\n       \\<Longrightarrow> dioph_invariant ks l (dioph_ins x S)\n 4. finite {x. dioph_is_node ks l x}", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x.\n       dioph_is_node ks l x \\<Longrightarrow>\n       list_all (dioph_is_node ks l) (dioph_ineq_succs n ks x)\n 2. dioph_invariant ks l (dioph_empt ks l)\n 3. \\<And>x S.\n       \\<lbrakk>dioph_is_node ks l x; dioph_invariant ks l S;\n        \\<not> dioph_memb x S\\<rbrakk>\n       \\<Longrightarrow> dioph_invariant ks l (dioph_ins x S)\n 4. finite {x. dioph_is_node ks l x}", "case 3"], ["proof (state)\nthis:\n  dioph_is_node ks l x_\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       dioph_is_node ks l x \\<Longrightarrow>\n       list_all (dioph_is_node ks l) (dioph_ineq_succs n ks x)\n 2. dioph_invariant ks l (dioph_empt ks l)\n 3. \\<And>x S.\n       \\<lbrakk>dioph_is_node ks l x; dioph_invariant ks l S;\n        \\<not> dioph_memb x S\\<rbrakk>\n       \\<Longrightarrow> dioph_invariant ks l (dioph_ins x S)\n 4. finite {x. dioph_is_node ks l x}", "then"], ["proof (chain)\npicking this:\n  dioph_is_node ks l x_", "show ?case"], ["proof (prove)\nusing this:\n  dioph_is_node ks l x_\n\ngoal (1 subgoal):\n 1. list_all (dioph_is_node ks l) (dioph_ineq_succs n ks x_)", "apply (simp add: dioph_ineq_succs_def map_filter_def list_all_iff dioph_is_node_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x_\\<bar>\n    \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks)) \\<Longrightarrow>\n    \\<forall>xa\\<in>set (mk_nat_vecs n).\n       \\<bar>(x_ - eval_dioph ks xa) div 2\\<bar>\n       \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "apply (rule ballI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<bar>x_\\<bar>\n                \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks));\n        xa \\<in> set (mk_nat_vecs n)\\<rbrakk>\n       \\<Longrightarrow> \\<bar>(x_ - eval_dioph ks xa) div 2\\<bar>\n                         \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "apply (erule subst [OF mk_nat_vecs_mod_eq])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<bar>x_\\<bar>\n       \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks)) \\<Longrightarrow>\n       \\<bar>(x_ - eval_dioph ks (map (\\<lambda>x. x mod 2) xa)) div 2\\<bar>\n       \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "apply (drule dioph_rhs_invariant)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<bar>(x_ - eval_dioph ks (map (\\<lambda>x. x mod 2) (?xs14 xa))) div\n             2\\<bar>\n       \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks)) \\<Longrightarrow>\n       \\<bar>(x_ - eval_dioph ks (map (\\<lambda>x. x mod 2) xa)) div 2\\<bar>\n       \\<le> max \\<bar>l\\<bar> (sum_list (map abs ks))", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  list_all (dioph_is_node ks l) (dioph_ineq_succs n ks x_)\n\ngoal (3 subgoals):\n 1. dioph_invariant ks l (dioph_empt ks l)\n 2. \\<And>x S.\n       \\<lbrakk>dioph_is_node ks l x; dioph_invariant ks l S;\n        \\<not> dioph_memb x S\\<rbrakk>\n       \\<Longrightarrow> dioph_invariant ks l (dioph_ins x S)\n 3. finite {x. dioph_is_node ks l x}", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. dioph_invariant ks l (dioph_empt ks l)\n 2. \\<And>x S.\n       \\<lbrakk>dioph_is_node ks l x; dioph_invariant ks l S;\n        \\<not> dioph_memb x S\\<rbrakk>\n       \\<Longrightarrow> dioph_invariant ks l (dioph_ins x S)\n 3. finite {x. dioph_is_node ks l x}", "case 4"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. dioph_invariant ks l (dioph_empt ks l)\n 2. \\<And>x S.\n       \\<lbrakk>dioph_is_node ks l x; dioph_invariant ks l S;\n        \\<not> dioph_memb x S\\<rbrakk>\n       \\<Longrightarrow> dioph_invariant ks l (dioph_ins x S)\n 3. finite {x. dioph_is_node ks l x}", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. dioph_invariant ks l (dioph_empt ks l)", "by (simp add: dioph_invariant_def dioph_empt_def)"], ["proof (state)\nthis:\n  dioph_invariant ks l (dioph_empt ks l)\n\ngoal (2 subgoals):\n 1. \\<And>x S.\n       \\<lbrakk>dioph_is_node ks l x; dioph_invariant ks l S;\n        \\<not> dioph_memb x S\\<rbrakk>\n       \\<Longrightarrow> dioph_invariant ks l (dioph_ins x S)\n 2. finite {x. dioph_is_node ks l x}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x S.\n       \\<lbrakk>dioph_is_node ks l x; dioph_invariant ks l S;\n        \\<not> dioph_memb x S\\<rbrakk>\n       \\<Longrightarrow> dioph_invariant ks l (dioph_ins x S)\n 2. finite {x. dioph_is_node ks l x}", "case 5"], ["proof (state)\nthis:\n  dioph_is_node ks l x_\n  dioph_invariant ks l S_\n  \\<not> dioph_memb x_ S_\n\ngoal (2 subgoals):\n 1. \\<And>x S.\n       \\<lbrakk>dioph_is_node ks l x; dioph_invariant ks l S;\n        \\<not> dioph_memb x S\\<rbrakk>\n       \\<Longrightarrow> dioph_invariant ks l (dioph_ins x S)\n 2. finite {x. dioph_is_node ks l x}", "then"], ["proof (chain)\npicking this:\n  dioph_is_node ks l x_\n  dioph_invariant ks l S_\n  \\<not> dioph_memb x_ S_", "show ?case"], ["proof (prove)\nusing this:\n  dioph_is_node ks l x_\n  dioph_invariant ks l S_\n  \\<not> dioph_memb x_ S_\n\ngoal (1 subgoal):\n 1. dioph_invariant ks l (dioph_ins x_ S_)", "by (simp add: dioph_invariant_def dioph_ins_def split_beta)"], ["proof (state)\nthis:\n  dioph_invariant ks l (dioph_ins x_ S_)\n\ngoal (1 subgoal):\n 1. finite {x. dioph_is_node ks l x}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {x. dioph_is_node ks l x}", "case 6"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. finite {x. dioph_is_node ks l x}", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. dioph_is_node ks l x}", "apply (rule bounded_int_set_is_finite [of _ \"max \\<bar>l\\<bar> (\\<Sum>k\\<leftarrow>ks. \\<bar>k\\<bar>) + 1\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{x. dioph_is_node ks l x}.\n       \\<bar>i\\<bar> < max \\<bar>l\\<bar> (sum_list (map abs ks)) + 1", "apply (rule ballI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {x. dioph_is_node ks l x} \\<Longrightarrow>\n       \\<bar>i\\<bar> < max \\<bar>l\\<bar> (sum_list (map abs ks)) + 1", "apply (simp add: dioph_is_node_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  finite {x. dioph_is_node ks l x}\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  \"dioph_ineq_dfs n ks l = gen_dfs (dioph_ineq_succs n ks) dioph_ins dioph_memb (dioph_empt ks l) [l]\""], ["", "definition\n  \"ineq_dfa n ks l =\n    (let (is, js) = dioph_ineq_dfs n ks l\n     in\n       (map (\\<lambda>j. make_bdd (\\<lambda>xs.\n          the (is ! int_encode ((j - eval_dioph ks xs) div 2))) n []) js,\n        map (\\<lambda>j. 0 \\<le> j) js))\""], ["", "lemma dioph_ineq_dfs_bij:\n  \"(fst (dioph_ineq_dfs n ks l) ! int_encode i = Some k \\<and> dioph_is_node ks l i) =\n    (k < length (snd (dioph_ineq_dfs n ks l)) \\<and> (snd (dioph_ineq_dfs n ks l) ! k = i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst (dioph_ineq_dfs n ks l) ! int_encode i = Some k \\<and>\n     dioph_is_node ks l i) =\n    (k < length (snd (dioph_ineq_dfs n ks l)) \\<and>\n     snd (dioph_ineq_dfs n ks l) ! k = i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (fst (dioph_ineq_dfs n ks l) ! int_encode i = Some k \\<and>\n     dioph_is_node ks l i) =\n    (k < length (snd (dioph_ineq_dfs n ks l)) \\<and>\n     snd (dioph_ineq_dfs n ks l) ! k = i)", "let ?dfs = \"gen_dfs (dioph_ineq_succs n ks) dioph_ins dioph_memb (dioph_empt ks l) [l]\""], ["proof (state)\ngoal (1 subgoal):\n 1. (fst (dioph_ineq_dfs n ks l) ! int_encode i = Some k \\<and>\n     dioph_is_node ks l i) =\n    (k < length (snd (dioph_ineq_dfs n ks l)) \\<and>\n     snd (dioph_ineq_dfs n ks l) ! k = i)", "have \"list_all (dioph_is_node ks l) [l]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (dioph_is_node ks l) [l]", "by (simp add: dioph_is_node_def)"], ["proof (state)\nthis:\n  list_all (dioph_is_node ks l) [l]\n\ngoal (1 subgoal):\n 1. (fst (dioph_ineq_dfs n ks l) ! int_encode i = Some k \\<and>\n     dioph_is_node ks l i) =\n    (k < length (snd (dioph_ineq_dfs n ks l)) \\<and>\n     snd (dioph_ineq_dfs n ks l) ! k = i)", "with dioph_dfs.empt_invariant [of ks l]"], ["proof (chain)\npicking this:\n  dioph_invariant ks l (dioph_empt ks l)\n  list_all (dioph_is_node ks l) [l]", "have \"(fst ?dfs ! int_encode i = Some k \\<and> dioph_is_node ks l i) =\n    (k < length (snd ?dfs) \\<and> (snd ?dfs ! k = i))\""], ["proof (prove)\nusing this:\n  dioph_invariant ks l (dioph_empt ks l)\n  list_all (dioph_is_node ks l) [l]\n\ngoal (1 subgoal):\n 1. (fst (dioph_ineq_dfs.dfs n ks (dioph_empt ks l) [l]) ! int_encode i =\n     Some k \\<and>\n     dioph_is_node ks l i) =\n    (k < length (snd (dioph_ineq_dfs.dfs n ks (dioph_empt ks l) [l])) \\<and>\n     snd (dioph_ineq_dfs.dfs n ks (dioph_empt ks l) [l]) ! k = i)", "proof (induct rule: dioph_ineq_dfs.dfs_invariant)"], ["proof (state)\ngoal (2 subgoals):\n 1. (fst (dioph_empt ks l) ! int_encode i = Some k \\<and>\n     dioph_is_node ks l i) =\n    (k < length (snd (dioph_empt ks l)) \\<and>\n     snd (dioph_empt ks l) ! k = i)\n 2. \\<And>S x.\n       \\<lbrakk>\\<not> dioph_memb x S; dioph_is_node ks l x;\n        dioph_invariant ks l S;\n        (fst S ! int_encode i = Some k \\<and> dioph_is_node ks l i) =\n        (k < length (snd S) \\<and> snd S ! k = i)\\<rbrakk>\n       \\<Longrightarrow> (fst (dioph_ins x S) ! int_encode i = Some k \\<and>\n                          dioph_is_node ks l i) =\n                         (k < length (snd (dioph_ins x S)) \\<and>\n                          snd (dioph_ins x S) ! k = i)", "case base"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (fst (dioph_empt ks l) ! int_encode i = Some k \\<and>\n     dioph_is_node ks l i) =\n    (k < length (snd (dioph_empt ks l)) \\<and>\n     snd (dioph_empt ks l) ! k = i)\n 2. \\<And>S x.\n       \\<lbrakk>\\<not> dioph_memb x S; dioph_is_node ks l x;\n        dioph_invariant ks l S;\n        (fst S ! int_encode i = Some k \\<and> dioph_is_node ks l i) =\n        (k < length (snd S) \\<and> snd S ! k = i)\\<rbrakk>\n       \\<Longrightarrow> (fst (dioph_ins x S) ! int_encode i = Some k \\<and>\n                          dioph_is_node ks l i) =\n                         (k < length (snd (dioph_ins x S)) \\<and>\n                          snd (dioph_ins x S) ! k = i)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst (dioph_empt ks l) ! int_encode i = Some k \\<and>\n     dioph_is_node ks l i) =\n    (k < length (snd (dioph_empt ks l)) \\<and>\n     snd (dioph_empt ks l) ! k = i)", "by (auto simp add: dioph_empt_def dioph_is_node_def int_encode_bound)"], ["proof (state)\nthis:\n  (fst (dioph_empt ks l) ! int_encode i = Some k \\<and>\n   dioph_is_node ks l i) =\n  (k < length (snd (dioph_empt ks l)) \\<and> snd (dioph_empt ks l) ! k = i)\n\ngoal (1 subgoal):\n 1. \\<And>S x.\n       \\<lbrakk>\\<not> dioph_memb x S; dioph_is_node ks l x;\n        dioph_invariant ks l S;\n        (fst S ! int_encode i = Some k \\<and> dioph_is_node ks l i) =\n        (k < length (snd S) \\<and> snd S ! k = i)\\<rbrakk>\n       \\<Longrightarrow> (fst (dioph_ins x S) ! int_encode i = Some k \\<and>\n                          dioph_is_node ks l i) =\n                         (k < length (snd (dioph_ins x S)) \\<and>\n                          snd (dioph_ins x S) ! k = i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S x.\n       \\<lbrakk>\\<not> dioph_memb x S; dioph_is_node ks l x;\n        dioph_invariant ks l S;\n        (fst S ! int_encode i = Some k \\<and> dioph_is_node ks l i) =\n        (k < length (snd S) \\<and> snd S ! k = i)\\<rbrakk>\n       \\<Longrightarrow> (fst (dioph_ins x S) ! int_encode i = Some k \\<and>\n                          dioph_is_node ks l i) =\n                         (k < length (snd (dioph_ins x S)) \\<and>\n                          snd (dioph_ins x S) ! k = i)", "case (step S y)"], ["proof (state)\nthis:\n  \\<not> dioph_memb y S\n  dioph_is_node ks l y\n  dioph_invariant ks l S\n  (fst S ! int_encode i = Some k \\<and> dioph_is_node ks l i) =\n  (k < length (snd S) \\<and> snd S ! k = i)\n\ngoal (1 subgoal):\n 1. \\<And>S x.\n       \\<lbrakk>\\<not> dioph_memb x S; dioph_is_node ks l x;\n        dioph_invariant ks l S;\n        (fst S ! int_encode i = Some k \\<and> dioph_is_node ks l i) =\n        (k < length (snd S) \\<and> snd S ! k = i)\\<rbrakk>\n       \\<Longrightarrow> (fst (dioph_ins x S) ! int_encode i = Some k \\<and>\n                          dioph_is_node ks l i) =\n                         (k < length (snd (dioph_ins x S)) \\<and>\n                          snd (dioph_ins x S) ! k = i)", "then"], ["proof (chain)\npicking this:\n  \\<not> dioph_memb y S\n  dioph_is_node ks l y\n  dioph_invariant ks l S\n  (fst S ! int_encode i = Some k \\<and> dioph_is_node ks l i) =\n  (k < length (snd S) \\<and> snd S ! k = i)", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> dioph_memb y S\n  dioph_is_node ks l y\n  dioph_invariant ks l S\n  (fst S ! int_encode i = Some k \\<and> dioph_is_node ks l i) =\n  (k < length (snd S) \\<and> snd S ! k = i)\n\ngoal (1 subgoal):\n 1. (fst (dioph_ins y S) ! int_encode i = Some k \\<and>\n     dioph_is_node ks l i) =\n    (k < length (snd (dioph_ins y S)) \\<and> snd (dioph_ins y S) ! k = i)", "by (cases \"y = i\")\n        (auto simp add: dioph_ins_def dioph_memb_def dioph_is_node_def split_beta dioph_invariant_def\n          int_encode_bound nth_append inj_eq [OF inj_int_encode])"], ["proof (state)\nthis:\n  (fst (dioph_ins y S) ! int_encode i = Some k \\<and>\n   dioph_is_node ks l i) =\n  (k < length (snd (dioph_ins y S)) \\<and> snd (dioph_ins y S) ! k = i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (fst (dioph_ineq_dfs.dfs n ks (dioph_empt ks l) [l]) ! int_encode i =\n   Some k \\<and>\n   dioph_is_node ks l i) =\n  (k < length (snd (dioph_ineq_dfs.dfs n ks (dioph_empt ks l) [l])) \\<and>\n   snd (dioph_ineq_dfs.dfs n ks (dioph_empt ks l) [l]) ! k = i)\n\ngoal (1 subgoal):\n 1. (fst (dioph_ineq_dfs n ks l) ! int_encode i = Some k \\<and>\n     dioph_is_node ks l i) =\n    (k < length (snd (dioph_ineq_dfs n ks l)) \\<and>\n     snd (dioph_ineq_dfs n ks l) ! k = i)", "then"], ["proof (chain)\npicking this:\n  (fst (dioph_ineq_dfs.dfs n ks (dioph_empt ks l) [l]) ! int_encode i =\n   Some k \\<and>\n   dioph_is_node ks l i) =\n  (k < length (snd (dioph_ineq_dfs.dfs n ks (dioph_empt ks l) [l])) \\<and>\n   snd (dioph_ineq_dfs.dfs n ks (dioph_empt ks l) [l]) ! k = i)", "show ?thesis"], ["proof (prove)\nusing this:\n  (fst (dioph_ineq_dfs.dfs n ks (dioph_empt ks l) [l]) ! int_encode i =\n   Some k \\<and>\n   dioph_is_node ks l i) =\n  (k < length (snd (dioph_ineq_dfs.dfs n ks (dioph_empt ks l) [l])) \\<and>\n   snd (dioph_ineq_dfs.dfs n ks (dioph_empt ks l) [l]) ! k = i)\n\ngoal (1 subgoal):\n 1. (fst (dioph_ineq_dfs n ks l) ! int_encode i = Some k \\<and>\n     dioph_is_node ks l i) =\n    (k < length (snd (dioph_ineq_dfs n ks l)) \\<and>\n     snd (dioph_ineq_dfs n ks l) ! k = i)", "by (simp add: dioph_ineq_dfs_def)"], ["proof (state)\nthis:\n  (fst (dioph_ineq_dfs n ks l) ! int_encode i = Some k \\<and>\n   dioph_is_node ks l i) =\n  (k < length (snd (dioph_ineq_dfs n ks l)) \\<and>\n   snd (dioph_ineq_dfs n ks l) ! k = i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dioph_ineq_dfs_mono:\n  assumes z: \"dioph_invariant ks l z\"\n  and xs: \"list_all (dioph_is_node ks l) xs\"\n  and H: \"fst z ! i = Some k\"\n  shows \"fst (gen_dfs (dioph_ineq_succs n ks) dioph_ins dioph_memb z xs) ! i = Some k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (dioph_ineq_dfs.dfs n ks z xs) ! i = Some k", "using z xs H"], ["proof (prove)\nusing this:\n  dioph_invariant ks l z\n  list_all (dioph_is_node ks l) xs\n  fst z ! i = Some k\n\ngoal (1 subgoal):\n 1. fst (dioph_ineq_dfs.dfs n ks z xs) ! i = Some k", "apply (rule dioph_ineq_dfs.dfs_invariant)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S x.\n       \\<lbrakk>\\<not> dioph_memb x S; dioph_is_node ks l x;\n        dioph_invariant ks l S; fst S ! i = Some k\\<rbrakk>\n       \\<Longrightarrow> fst (dioph_ins x S) ! i = Some k", "apply (simp add: dioph_ins_def dioph_memb_def split_paired_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x.\n       \\<lbrakk>a ! int_encode x = None; dioph_is_node ks l x;\n        dioph_invariant ks l (a, b); a ! i = Some k\\<rbrakk>\n       \\<Longrightarrow> a[int_encode x := Some (length b)] ! i = Some k", "apply (case_tac \"i = int_encode x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>a ! int_encode x = None; dioph_is_node ks l x;\n        dioph_invariant ks l (a, b); a ! i = Some k;\n        i = int_encode x\\<rbrakk>\n       \\<Longrightarrow> a[int_encode x := Some (length b)] ! i = Some k\n 2. \\<And>a b x.\n       \\<lbrakk>a ! int_encode x = None; dioph_is_node ks l x;\n        dioph_invariant ks l (a, b); a ! i = Some k;\n        i \\<noteq> int_encode x\\<rbrakk>\n       \\<Longrightarrow> a[int_encode x := Some (length b)] ! i = Some k", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dioph_ineq_dfs_start:\n  \"fst (dioph_ineq_dfs n ks l) ! int_encode l = Some 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (dioph_ineq_dfs n ks l) ! int_encode l = Some 0", "apply (simp add: dioph_ineq_dfs_def gen_dfs_simps dioph_ineq_dfs.empt dioph_is_node_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (dioph_ineq_dfs.dfs n ks (dioph_ins l (dioph_empt ks l))\n          (dioph_ineq_succs n ks l)) !\n    int_encode l =\n    Some 0", "apply (rule dioph_ineq_dfs_mono [of _ l])"], ["proof (prove)\ngoal (3 subgoals):\n 1. dioph_invariant ks l (dioph_ins l (dioph_empt ks l))\n 2. list_all (dioph_is_node ks l) (dioph_ineq_succs n ks l)\n 3. fst (dioph_ins l (dioph_empt ks l)) ! int_encode l = Some 0", "apply (rule dioph_ineq_dfs.ins_invariant)"], ["proof (prove)\ngoal (5 subgoals):\n 1. dioph_is_node ks l l\n 2. dioph_invariant ks l (dioph_empt ks l)\n 3. \\<not> dioph_memb l (dioph_empt ks l)\n 4. list_all (dioph_is_node ks l) (dioph_ineq_succs n ks l)\n 5. fst (dioph_ins l (dioph_empt ks l)) ! int_encode l = Some 0", "apply (simp add: dioph_is_node_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. dioph_invariant ks l (dioph_empt ks l)\n 2. \\<not> dioph_memb l (dioph_empt ks l)\n 3. list_all (dioph_is_node ks l) (dioph_ineq_succs n ks l)\n 4. fst (dioph_ins l (dioph_empt ks l)) ! int_encode l = Some 0", "apply (rule dioph_ineq_dfs.empt_invariant)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<not> dioph_memb l (dioph_empt ks l)\n 2. list_all (dioph_is_node ks l) (dioph_ineq_succs n ks l)\n 3. fst (dioph_ins l (dioph_empt ks l)) ! int_encode l = Some 0", "apply (simp add: dioph_ineq_dfs.empt dioph_is_node_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. list_all (dioph_is_node ks l) (dioph_ineq_succs n ks l)\n 2. fst (dioph_ins l (dioph_empt ks l)) ! int_encode l = Some 0", "apply (simp add: dioph_ineq_dfs.succs_is_node dioph_is_node_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (dioph_ins l (dioph_empt ks l)) ! int_encode l = Some 0", "apply (simp add: dioph_ins_def dioph_empt_def int_encode_bound dioph_is_node_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ineq_dfa_accepting:\n  \"(l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>* \\<Longrightarrow> list_all (is_alph n) bss \\<Longrightarrow>\n  dfa_accepting (ineq_dfa n ks l) (dfa_steps (ineq_dfa n ks l) (the (fst (dioph_ineq_dfs n ks l) ! int_encode m)) bss) =\n  (eval_dioph ks (nats_of_boolss n bss) \\<le> m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n     list_all (is_alph n) bss\\<rbrakk>\n    \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n                       (dfa_steps (ineq_dfa n ks l)\n                         (the (fst (dioph_ineq_dfs n ks l) ! int_encode m))\n                         bss) =\n                      (eval_dioph ks (nats_of_boolss n bss) \\<le> m)", "proof (induct bss arbitrary: m)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>(l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n                          (dfa_steps (ineq_dfa n ks l)\n                            (the (fst (dioph_ineq_dfs n ks l) !\n                                  int_encode m))\n                            []) =\n                         (eval_dioph ks (nats_of_boolss n []) \\<le> m)\n 2. \\<And>a bss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>(l, m)\n                            \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n                    list_all (is_alph n) bss\\<rbrakk>\n                   \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n(dfa_steps (ineq_dfa n ks l)\n  (the (fst (dioph_ineq_dfs n ks l) ! int_encode m)) bss) =\n                                     (eval_dioph ks (nats_of_boolss n bss)\n\\<le> m);\n        (l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n        list_all (is_alph n) (a # bss)\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n                          (dfa_steps (ineq_dfa n ks l)\n                            (the (fst (dioph_ineq_dfs n ks l) !\n                                  int_encode m))\n                            (a # bss)) =\n                         (eval_dioph ks (nats_of_boolss n (a # bss))\n                          \\<le> m)", "case Nil"], ["proof (state)\nthis:\n  (l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*\n  list_all (is_alph n) []\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>(l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n                          (dfa_steps (ineq_dfa n ks l)\n                            (the (fst (dioph_ineq_dfs n ks l) !\n                                  int_encode m))\n                            []) =\n                         (eval_dioph ks (nats_of_boolss n []) \\<le> m)\n 2. \\<And>a bss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>(l, m)\n                            \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n                    list_all (is_alph n) bss\\<rbrakk>\n                   \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n(dfa_steps (ineq_dfa n ks l)\n  (the (fst (dioph_ineq_dfs n ks l) ! int_encode m)) bss) =\n                                     (eval_dioph ks (nats_of_boolss n bss)\n\\<le> m);\n        (l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n        list_all (is_alph n) (a # bss)\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n                          (dfa_steps (ineq_dfa n ks l)\n                            (the (fst (dioph_ineq_dfs n ks l) !\n                                  int_encode m))\n                            (a # bss)) =\n                         (eval_dioph ks (nats_of_boolss n (a # bss))\n                          \\<le> m)", "have l: \"dioph_is_node ks l l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dioph_is_node ks l l", "by (simp add: dioph_is_node_def)"], ["proof (state)\nthis:\n  dioph_is_node ks l l\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>(l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n                          (dfa_steps (ineq_dfa n ks l)\n                            (the (fst (dioph_ineq_dfs n ks l) !\n                                  int_encode m))\n                            []) =\n                         (eval_dioph ks (nats_of_boolss n []) \\<le> m)\n 2. \\<And>a bss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>(l, m)\n                            \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n                    list_all (is_alph n) bss\\<rbrakk>\n                   \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n(dfa_steps (ineq_dfa n ks l)\n  (the (fst (dioph_ineq_dfs n ks l) ! int_encode m)) bss) =\n                                     (eval_dioph ks (nats_of_boolss n bss)\n\\<le> m);\n        (l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n        list_all (is_alph n) (a # bss)\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n                          (dfa_steps (ineq_dfa n ks l)\n                            (the (fst (dioph_ineq_dfs n ks l) !\n                                  int_encode m))\n                            (a # bss)) =\n                         (eval_dioph ks (nats_of_boolss n (a # bss))\n                          \\<le> m)", "with \\<open>(l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*\\<close>"], ["proof (chain)\npicking this:\n  (l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*\n  dioph_is_node ks l l", "have m: \"dioph_is_node ks l m\""], ["proof (prove)\nusing this:\n  (l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*\n  dioph_is_node ks l l\n\ngoal (1 subgoal):\n 1. dioph_is_node ks l m", "by (rule dioph_ineq_dfs.succsr_is_node)"], ["proof (state)\nthis:\n  dioph_is_node ks l m\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>(l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n                          (dfa_steps (ineq_dfa n ks l)\n                            (the (fst (dioph_ineq_dfs n ks l) !\n                                  int_encode m))\n                            []) =\n                         (eval_dioph ks (nats_of_boolss n []) \\<le> m)\n 2. \\<And>a bss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>(l, m)\n                            \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n                    list_all (is_alph n) bss\\<rbrakk>\n                   \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n(dfa_steps (ineq_dfa n ks l)\n  (the (fst (dioph_ineq_dfs n ks l) ! int_encode m)) bss) =\n                                     (eval_dioph ks (nats_of_boolss n bss)\n\\<le> m);\n        (l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n        list_all (is_alph n) (a # bss)\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n                          (dfa_steps (ineq_dfa n ks l)\n                            (the (fst (dioph_ineq_dfs n ks l) !\n                                  int_encode m))\n                            (a # bss)) =\n                         (eval_dioph ks (nats_of_boolss n (a # bss))\n                          \\<le> m)", "with l Nil"], ["proof (chain)\npicking this:\n  dioph_is_node ks l l\n  (l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*\n  list_all (is_alph n) []\n  dioph_is_node ks l m", "have \"dioph_memb m (dioph_ineq_dfs n ks l)\""], ["proof (prove)\nusing this:\n  dioph_is_node ks l l\n  (l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*\n  list_all (is_alph n) []\n  dioph_is_node ks l m\n\ngoal (1 subgoal):\n 1. dioph_memb m (dioph_ineq_dfs n ks l)", "by (simp add: dioph_ineq_dfs.dfs_eq_rtrancl dioph_ineq_dfs_def)"], ["proof (state)\nthis:\n  dioph_memb m (dioph_ineq_dfs n ks l)\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>(l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n                          (dfa_steps (ineq_dfa n ks l)\n                            (the (fst (dioph_ineq_dfs n ks l) !\n                                  int_encode m))\n                            []) =\n                         (eval_dioph ks (nats_of_boolss n []) \\<le> m)\n 2. \\<And>a bss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>(l, m)\n                            \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n                    list_all (is_alph n) bss\\<rbrakk>\n                   \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n(dfa_steps (ineq_dfa n ks l)\n  (the (fst (dioph_ineq_dfs n ks l) ! int_encode m)) bss) =\n                                     (eval_dioph ks (nats_of_boolss n bss)\n\\<le> m);\n        (l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n        list_all (is_alph n) (a # bss)\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n                          (dfa_steps (ineq_dfa n ks l)\n                            (the (fst (dioph_ineq_dfs n ks l) !\n                                  int_encode m))\n                            (a # bss)) =\n                         (eval_dioph ks (nats_of_boolss n (a # bss))\n                          \\<le> m)", "then"], ["proof (chain)\npicking this:\n  dioph_memb m (dioph_ineq_dfs n ks l)", "obtain k where k: \"fst (dioph_ineq_dfs n ks l) ! int_encode m = Some k\""], ["proof (prove)\nusing this:\n  dioph_memb m (dioph_ineq_dfs n ks l)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        fst (dioph_ineq_dfs n ks l) ! int_encode m =\n        Some k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: dioph_memb_def)"], ["proof (state)\nthis:\n  fst (dioph_ineq_dfs n ks l) ! int_encode m = Some k\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>(l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n                          (dfa_steps (ineq_dfa n ks l)\n                            (the (fst (dioph_ineq_dfs n ks l) !\n                                  int_encode m))\n                            []) =\n                         (eval_dioph ks (nats_of_boolss n []) \\<le> m)\n 2. \\<And>a bss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>(l, m)\n                            \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n                    list_all (is_alph n) bss\\<rbrakk>\n                   \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n(dfa_steps (ineq_dfa n ks l)\n  (the (fst (dioph_ineq_dfs n ks l) ! int_encode m)) bss) =\n                                     (eval_dioph ks (nats_of_boolss n bss)\n\\<le> m);\n        (l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n        list_all (is_alph n) (a # bss)\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n                          (dfa_steps (ineq_dfa n ks l)\n                            (the (fst (dioph_ineq_dfs n ks l) !\n                                  int_encode m))\n                            (a # bss)) =\n                         (eval_dioph ks (nats_of_boolss n (a # bss))\n                          \\<le> m)", "with m"], ["proof (chain)\npicking this:\n  dioph_is_node ks l m\n  fst (dioph_ineq_dfs n ks l) ! int_encode m = Some k", "have \"k < length (snd (dioph_ineq_dfs n ks l)) \\<and> (snd (dioph_ineq_dfs n ks l) ! k = m)\""], ["proof (prove)\nusing this:\n  dioph_is_node ks l m\n  fst (dioph_ineq_dfs n ks l) ! int_encode m = Some k\n\ngoal (1 subgoal):\n 1. k < length (snd (dioph_ineq_dfs n ks l)) \\<and>\n    snd (dioph_ineq_dfs n ks l) ! k = m", "by (simp add: dioph_ineq_dfs_bij [symmetric])"], ["proof (state)\nthis:\n  k < length (snd (dioph_ineq_dfs n ks l)) \\<and>\n  snd (dioph_ineq_dfs n ks l) ! k = m\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>(l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n        list_all (is_alph n) []\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n                          (dfa_steps (ineq_dfa n ks l)\n                            (the (fst (dioph_ineq_dfs n ks l) !\n                                  int_encode m))\n                            []) =\n                         (eval_dioph ks (nats_of_boolss n []) \\<le> m)\n 2. \\<And>a bss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>(l, m)\n                            \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n                    list_all (is_alph n) bss\\<rbrakk>\n                   \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n(dfa_steps (ineq_dfa n ks l)\n  (the (fst (dioph_ineq_dfs n ks l) ! int_encode m)) bss) =\n                                     (eval_dioph ks (nats_of_boolss n bss)\n\\<le> m);\n        (l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n        list_all (is_alph n) (a # bss)\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n                          (dfa_steps (ineq_dfa n ks l)\n                            (the (fst (dioph_ineq_dfs n ks l) !\n                                  int_encode m))\n                            (a # bss)) =\n                         (eval_dioph ks (nats_of_boolss n (a # bss))\n                          \\<le> m)", "with k"], ["proof (chain)\npicking this:\n  fst (dioph_ineq_dfs n ks l) ! int_encode m = Some k\n  k < length (snd (dioph_ineq_dfs n ks l)) \\<and>\n  snd (dioph_ineq_dfs n ks l) ! k = m", "show ?case"], ["proof (prove)\nusing this:\n  fst (dioph_ineq_dfs n ks l) ! int_encode m = Some k\n  k < length (snd (dioph_ineq_dfs n ks l)) \\<and>\n  snd (dioph_ineq_dfs n ks l) ! k = m\n\ngoal (1 subgoal):\n 1. dfa_accepting (ineq_dfa n ks l)\n     (dfa_steps (ineq_dfa n ks l)\n       (the (fst (dioph_ineq_dfs n ks l) ! int_encode m)) []) =\n    (eval_dioph ks (nats_of_boolss n []) \\<le> m)", "by (simp add: eval_dioph_replicate_0 dfa_accepting_def ineq_dfa_def split_beta nth_append)"], ["proof (state)\nthis:\n  dfa_accepting (ineq_dfa n ks l)\n   (dfa_steps (ineq_dfa n ks l)\n     (the (fst (dioph_ineq_dfs n ks l) ! int_encode m)) []) =\n  (eval_dioph ks (nats_of_boolss n []) \\<le> m)\n\ngoal (1 subgoal):\n 1. \\<And>a bss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>(l, m)\n                            \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n                    list_all (is_alph n) bss\\<rbrakk>\n                   \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n(dfa_steps (ineq_dfa n ks l)\n  (the (fst (dioph_ineq_dfs n ks l) ! int_encode m)) bss) =\n                                     (eval_dioph ks (nats_of_boolss n bss)\n\\<le> m);\n        (l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n        list_all (is_alph n) (a # bss)\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n                          (dfa_steps (ineq_dfa n ks l)\n                            (the (fst (dioph_ineq_dfs n ks l) !\n                                  int_encode m))\n                            (a # bss)) =\n                         (eval_dioph ks (nats_of_boolss n (a # bss))\n                          \\<le> m)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a bss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>(l, m)\n                            \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n                    list_all (is_alph n) bss\\<rbrakk>\n                   \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n(dfa_steps (ineq_dfa n ks l)\n  (the (fst (dioph_ineq_dfs n ks l) ! int_encode m)) bss) =\n                                     (eval_dioph ks (nats_of_boolss n bss)\n\\<le> m);\n        (l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n        list_all (is_alph n) (a # bss)\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n                          (dfa_steps (ineq_dfa n ks l)\n                            (the (fst (dioph_ineq_dfs n ks l) !\n                                  int_encode m))\n                            (a # bss)) =\n                         (eval_dioph ks (nats_of_boolss n (a # bss))\n                          \\<le> m)", "case (Cons bs bss)"], ["proof (state)\nthis:\n  \\<lbrakk>(l, ?m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n                     (dfa_steps (ineq_dfa n ks l)\n                       (the (fst (dioph_ineq_dfs n ks l) ! int_encode ?m))\n                       bss) =\n                    (eval_dioph ks (nats_of_boolss n bss) \\<le> ?m)\n  (l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*\n  list_all (is_alph n) (bs # bss)\n\ngoal (1 subgoal):\n 1. \\<And>a bss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>(l, m)\n                            \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n                    list_all (is_alph n) bss\\<rbrakk>\n                   \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n(dfa_steps (ineq_dfa n ks l)\n  (the (fst (dioph_ineq_dfs n ks l) ! int_encode m)) bss) =\n                                     (eval_dioph ks (nats_of_boolss n bss)\n\\<le> m);\n        (l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n        list_all (is_alph n) (a # bss)\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n                          (dfa_steps (ineq_dfa n ks l)\n                            (the (fst (dioph_ineq_dfs n ks l) !\n                                  int_encode m))\n                            (a # bss)) =\n                         (eval_dioph ks (nats_of_boolss n (a # bss))\n                          \\<le> m)", "have l: \"dioph_is_node ks l l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dioph_is_node ks l l", "by (simp add: dioph_is_node_def)"], ["proof (state)\nthis:\n  dioph_is_node ks l l\n\ngoal (1 subgoal):\n 1. \\<And>a bss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>(l, m)\n                            \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n                    list_all (is_alph n) bss\\<rbrakk>\n                   \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n(dfa_steps (ineq_dfa n ks l)\n  (the (fst (dioph_ineq_dfs n ks l) ! int_encode m)) bss) =\n                                     (eval_dioph ks (nats_of_boolss n bss)\n\\<le> m);\n        (l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n        list_all (is_alph n) (a # bss)\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n                          (dfa_steps (ineq_dfa n ks l)\n                            (the (fst (dioph_ineq_dfs n ks l) !\n                                  int_encode m))\n                            (a # bss)) =\n                         (eval_dioph ks (nats_of_boolss n (a # bss))\n                          \\<le> m)", "with \\<open>(l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*\\<close>"], ["proof (chain)\npicking this:\n  (l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*\n  dioph_is_node ks l l", "have m: \"dioph_is_node ks l m\""], ["proof (prove)\nusing this:\n  (l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*\n  dioph_is_node ks l l\n\ngoal (1 subgoal):\n 1. dioph_is_node ks l m", "by (rule dioph_ineq_dfs.succsr_is_node)"], ["proof (state)\nthis:\n  dioph_is_node ks l m\n\ngoal (1 subgoal):\n 1. \\<And>a bss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>(l, m)\n                            \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n                    list_all (is_alph n) bss\\<rbrakk>\n                   \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n(dfa_steps (ineq_dfa n ks l)\n  (the (fst (dioph_ineq_dfs n ks l) ! int_encode m)) bss) =\n                                     (eval_dioph ks (nats_of_boolss n bss)\n\\<le> m);\n        (l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n        list_all (is_alph n) (a # bss)\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n                          (dfa_steps (ineq_dfa n ks l)\n                            (the (fst (dioph_ineq_dfs n ks l) !\n                                  int_encode m))\n                            (a # bss)) =\n                         (eval_dioph ks (nats_of_boolss n (a # bss))\n                          \\<le> m)", "with l Cons"], ["proof (chain)\npicking this:\n  dioph_is_node ks l l\n  \\<lbrakk>(l, ?m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n                     (dfa_steps (ineq_dfa n ks l)\n                       (the (fst (dioph_ineq_dfs n ks l) ! int_encode ?m))\n                       bss) =\n                    (eval_dioph ks (nats_of_boolss n bss) \\<le> ?m)\n  (l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*\n  list_all (is_alph n) (bs # bss)\n  dioph_is_node ks l m", "have \"dioph_memb m (dioph_ineq_dfs n ks l)\""], ["proof (prove)\nusing this:\n  dioph_is_node ks l l\n  \\<lbrakk>(l, ?m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n                     (dfa_steps (ineq_dfa n ks l)\n                       (the (fst (dioph_ineq_dfs n ks l) ! int_encode ?m))\n                       bss) =\n                    (eval_dioph ks (nats_of_boolss n bss) \\<le> ?m)\n  (l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*\n  list_all (is_alph n) (bs # bss)\n  dioph_is_node ks l m\n\ngoal (1 subgoal):\n 1. dioph_memb m (dioph_ineq_dfs n ks l)", "by (simp add: dioph_ineq_dfs.dfs_eq_rtrancl dioph_ineq_dfs_def)"], ["proof (state)\nthis:\n  dioph_memb m (dioph_ineq_dfs n ks l)\n\ngoal (1 subgoal):\n 1. \\<And>a bss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>(l, m)\n                            \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n                    list_all (is_alph n) bss\\<rbrakk>\n                   \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n(dfa_steps (ineq_dfa n ks l)\n  (the (fst (dioph_ineq_dfs n ks l) ! int_encode m)) bss) =\n                                     (eval_dioph ks (nats_of_boolss n bss)\n\\<le> m);\n        (l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n        list_all (is_alph n) (a # bss)\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n                          (dfa_steps (ineq_dfa n ks l)\n                            (the (fst (dioph_ineq_dfs n ks l) !\n                                  int_encode m))\n                            (a # bss)) =\n                         (eval_dioph ks (nats_of_boolss n (a # bss))\n                          \\<le> m)", "then"], ["proof (chain)\npicking this:\n  dioph_memb m (dioph_ineq_dfs n ks l)", "obtain k where k: \"fst (dioph_ineq_dfs n ks l) ! int_encode m = Some k\""], ["proof (prove)\nusing this:\n  dioph_memb m (dioph_ineq_dfs n ks l)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        fst (dioph_ineq_dfs n ks l) ! int_encode m =\n        Some k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: dioph_memb_def)"], ["proof (state)\nthis:\n  fst (dioph_ineq_dfs n ks l) ! int_encode m = Some k\n\ngoal (1 subgoal):\n 1. \\<And>a bss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>(l, m)\n                            \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n                    list_all (is_alph n) bss\\<rbrakk>\n                   \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n(dfa_steps (ineq_dfa n ks l)\n  (the (fst (dioph_ineq_dfs n ks l) ! int_encode m)) bss) =\n                                     (eval_dioph ks (nats_of_boolss n bss)\n\\<le> m);\n        (l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n        list_all (is_alph n) (a # bss)\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n                          (dfa_steps (ineq_dfa n ks l)\n                            (the (fst (dioph_ineq_dfs n ks l) !\n                                  int_encode m))\n                            (a # bss)) =\n                         (eval_dioph ks (nats_of_boolss n (a # bss))\n                          \\<le> m)", "with m"], ["proof (chain)\npicking this:\n  dioph_is_node ks l m\n  fst (dioph_ineq_dfs n ks l) ! int_encode m = Some k", "have k': \"k < length (snd (dioph_ineq_dfs n ks l)) \\<and> (snd (dioph_ineq_dfs n ks l) ! k = m)\""], ["proof (prove)\nusing this:\n  dioph_is_node ks l m\n  fst (dioph_ineq_dfs n ks l) ! int_encode m = Some k\n\ngoal (1 subgoal):\n 1. k < length (snd (dioph_ineq_dfs n ks l)) \\<and>\n    snd (dioph_ineq_dfs n ks l) ! k = m", "by (simp add: dioph_ineq_dfs_bij [symmetric])"], ["proof (state)\nthis:\n  k < length (snd (dioph_ineq_dfs n ks l)) \\<and>\n  snd (dioph_ineq_dfs n ks l) ! k = m\n\ngoal (1 subgoal):\n 1. \\<And>a bss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>(l, m)\n                            \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n                    list_all (is_alph n) bss\\<rbrakk>\n                   \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n(dfa_steps (ineq_dfa n ks l)\n  (the (fst (dioph_ineq_dfs n ks l) ! int_encode m)) bss) =\n                                     (eval_dioph ks (nats_of_boolss n bss)\n\\<le> m);\n        (l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n        list_all (is_alph n) (a # bss)\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n                          (dfa_steps (ineq_dfa n ks l)\n                            (the (fst (dioph_ineq_dfs n ks l) !\n                                  int_encode m))\n                            (a # bss)) =\n                         (eval_dioph ks (nats_of_boolss n (a # bss))\n                          \\<le> m)", "moreover"], ["proof (state)\nthis:\n  k < length (snd (dioph_ineq_dfs n ks l)) \\<and>\n  snd (dioph_ineq_dfs n ks l) ! k = m\n\ngoal (1 subgoal):\n 1. \\<And>a bss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>(l, m)\n                            \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n                    list_all (is_alph n) bss\\<rbrakk>\n                   \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n(dfa_steps (ineq_dfa n ks l)\n  (the (fst (dioph_ineq_dfs n ks l) ! int_encode m)) bss) =\n                                     (eval_dioph ks (nats_of_boolss n bss)\n\\<le> m);\n        (l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n        list_all (is_alph n) (a # bss)\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n                          (dfa_steps (ineq_dfa n ks l)\n                            (the (fst (dioph_ineq_dfs n ks l) !\n                                  int_encode m))\n                            (a # bss)) =\n                         (eval_dioph ks (nats_of_boolss n (a # bss))\n                          \\<le> m)", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>(l, ?m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n                     (dfa_steps (ineq_dfa n ks l)\n                       (the (fst (dioph_ineq_dfs n ks l) ! int_encode ?m))\n                       bss) =\n                    (eval_dioph ks (nats_of_boolss n bss) \\<le> ?m)\n  (l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*\n  list_all (is_alph n) (bs # bss)\n  k < length (snd (dioph_ineq_dfs n ks l)) \\<and>\n  snd (dioph_ineq_dfs n ks l) ! k = m", "have \"bdd_lookup (fst (ineq_dfa n ks l) ! k) bs =\n    the (fst (dioph_ineq_dfs n ks l) ! int_encode ((m - eval_dioph ks (map nat_of_bool bs)) div 2))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(l, ?m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n                     (dfa_steps (ineq_dfa n ks l)\n                       (the (fst (dioph_ineq_dfs n ks l) ! int_encode ?m))\n                       bss) =\n                    (eval_dioph ks (nats_of_boolss n bss) \\<le> ?m)\n  (l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*\n  list_all (is_alph n) (bs # bss)\n  k < length (snd (dioph_ineq_dfs n ks l)) \\<and>\n  snd (dioph_ineq_dfs n ks l) ! k = m\n\ngoal (1 subgoal):\n 1. bdd_lookup (fst (ineq_dfa n ks l) ! k) bs =\n    the (fst (dioph_ineq_dfs n ks l) !\n         int_encode ((m - eval_dioph ks (map of_bool bs)) div 2))", "by (simp add: ineq_dfa_def split_beta nth_append bdd_lookup_make_bdd is_alph_def)"], ["proof (state)\nthis:\n  bdd_lookup (fst (ineq_dfa n ks l) ! k) bs =\n  the (fst (dioph_ineq_dfs n ks l) !\n       int_encode ((m - eval_dioph ks (map of_bool bs)) div 2))\n\ngoal (1 subgoal):\n 1. \\<And>a bss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>(l, m)\n                            \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n                    list_all (is_alph n) bss\\<rbrakk>\n                   \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n(dfa_steps (ineq_dfa n ks l)\n  (the (fst (dioph_ineq_dfs n ks l) ! int_encode m)) bss) =\n                                     (eval_dioph ks (nats_of_boolss n bss)\n\\<le> m);\n        (l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n        list_all (is_alph n) (a # bss)\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n                          (dfa_steps (ineq_dfa n ks l)\n                            (the (fst (dioph_ineq_dfs n ks l) !\n                                  int_encode m))\n                            (a # bss)) =\n                         (eval_dioph ks (nats_of_boolss n (a # bss))\n                          \\<le> m)", "moreover"], ["proof (state)\nthis:\n  bdd_lookup (fst (ineq_dfa n ks l) ! k) bs =\n  the (fst (dioph_ineq_dfs n ks l) !\n       int_encode ((m - eval_dioph ks (map of_bool bs)) div 2))\n\ngoal (1 subgoal):\n 1. \\<And>a bss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>(l, m)\n                            \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n                    list_all (is_alph n) bss\\<rbrakk>\n                   \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n(dfa_steps (ineq_dfa n ks l)\n  (the (fst (dioph_ineq_dfs n ks l) ! int_encode m)) bss) =\n                                     (eval_dioph ks (nats_of_boolss n bss)\n\\<le> m);\n        (l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n        list_all (is_alph n) (a # bss)\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n                          (dfa_steps (ineq_dfa n ks l)\n                            (the (fst (dioph_ineq_dfs n ks l) !\n                                  int_encode m))\n                            (a # bss)) =\n                         (eval_dioph ks (nats_of_boolss n (a # bss))\n                          \\<le> m)", "have \"(l, (m - eval_dioph ks (map nat_of_bool bs)) div 2) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l, (m - eval_dioph ks (map of_bool bs)) div 2)\n    \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*", "apply (rule rtrancl_into_rtrancl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (l, ?b) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*\n 2. (?b, (m - eval_dioph ks (map of_bool bs)) div 2)\n    \\<in> succsr (dioph_ineq_succs n ks)", "apply (rule Cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (m, (m - eval_dioph ks (map of_bool bs)) div 2)\n    \\<in> succsr (dioph_ineq_succs n ks)", "apply (simp add: dioph_ineq_succs_def succsr_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (m - eval_dioph ks (map of_bool bs)) div 2\n    \\<in> (\\<lambda>xs. (m - eval_dioph ks xs) div 2) ` set (mk_nat_vecs n)", "apply (rule image_eqI [of _ _ \"map nat_of_bool bs\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (m - eval_dioph ks (map of_bool bs)) div 2 =\n    (m - eval_dioph ks (map of_bool bs)) div 2\n 2. map of_bool bs \\<in> set (mk_nat_vecs n)", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>(l, ?m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n                     (dfa_steps (ineq_dfa n ks l)\n                       (the (fst (dioph_ineq_dfs n ks l) ! int_encode ?m))\n                       bss) =\n                    (eval_dioph ks (nats_of_boolss n bss) \\<le> ?m)\n  (l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*\n  list_all (is_alph n) (bs # bss)\n\ngoal (2 subgoals):\n 1. (m - eval_dioph ks (map of_bool bs)) div 2 =\n    (m - eval_dioph ks (map of_bool bs)) div 2\n 2. map of_bool bs \\<in> set (mk_nat_vecs n)", "apply (simp_all add: nat_of_bool_mk_nat_vecs is_alph_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (l, (m - eval_dioph ks (map of_bool bs)) div 2)\n  \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>a bss m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>(l, m)\n                            \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n                    list_all (is_alph n) bss\\<rbrakk>\n                   \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n(dfa_steps (ineq_dfa n ks l)\n  (the (fst (dioph_ineq_dfs n ks l) ! int_encode m)) bss) =\n                                     (eval_dioph ks (nats_of_boolss n bss)\n\\<le> m);\n        (l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n        list_all (is_alph n) (a # bss)\\<rbrakk>\n       \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n                          (dfa_steps (ineq_dfa n ks l)\n                            (the (fst (dioph_ineq_dfs n ks l) !\n                                  int_encode m))\n                            (a # bss)) =\n                         (eval_dioph ks (nats_of_boolss n (a # bss))\n                          \\<le> m)", "ultimately"], ["proof (chain)\npicking this:\n  k < length (snd (dioph_ineq_dfs n ks l)) \\<and>\n  snd (dioph_ineq_dfs n ks l) ! k = m\n  bdd_lookup (fst (ineq_dfa n ks l) ! k) bs =\n  the (fst (dioph_ineq_dfs n ks l) !\n       int_encode ((m - eval_dioph ks (map of_bool bs)) div 2))\n  (l, (m - eval_dioph ks (map of_bool bs)) div 2)\n  \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*", "show ?case"], ["proof (prove)\nusing this:\n  k < length (snd (dioph_ineq_dfs n ks l)) \\<and>\n  snd (dioph_ineq_dfs n ks l) ! k = m\n  bdd_lookup (fst (ineq_dfa n ks l) ! k) bs =\n  the (fst (dioph_ineq_dfs n ks l) !\n       int_encode ((m - eval_dioph ks (map of_bool bs)) div 2))\n  (l, (m - eval_dioph ks (map of_bool bs)) div 2)\n  \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*\n\ngoal (1 subgoal):\n 1. dfa_accepting (ineq_dfa n ks l)\n     (dfa_steps (ineq_dfa n ks l)\n       (the (fst (dioph_ineq_dfs n ks l) ! int_encode m)) (bs # bss)) =\n    (eval_dioph ks (nats_of_boolss n (bs # bss)) \\<le> m)", "using k Cons"], ["proof (prove)\nusing this:\n  k < length (snd (dioph_ineq_dfs n ks l)) \\<and>\n  snd (dioph_ineq_dfs n ks l) ! k = m\n  bdd_lookup (fst (ineq_dfa n ks l) ! k) bs =\n  the (fst (dioph_ineq_dfs n ks l) !\n       int_encode ((m - eval_dioph ks (map of_bool bs)) div 2))\n  (l, (m - eval_dioph ks (map of_bool bs)) div 2)\n  \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*\n  fst (dioph_ineq_dfs n ks l) ! int_encode m = Some k\n  \\<lbrakk>(l, ?m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*;\n   list_all (is_alph n) bss\\<rbrakk>\n  \\<Longrightarrow> dfa_accepting (ineq_dfa n ks l)\n                     (dfa_steps (ineq_dfa n ks l)\n                       (the (fst (dioph_ineq_dfs n ks l) ! int_encode ?m))\n                       bss) =\n                    (eval_dioph ks (nats_of_boolss n bss) \\<le> ?m)\n  (l, m) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*\n  list_all (is_alph n) (bs # bss)\n\ngoal (1 subgoal):\n 1. dfa_accepting (ineq_dfa n ks l)\n     (dfa_steps (ineq_dfa n ks l)\n       (the (fst (dioph_ineq_dfs n ks l) ! int_encode m)) (bs # bss)) =\n    (eval_dioph ks (nats_of_boolss n (bs # bss)) \\<le> m)", "by (subst eval_dioph_ineq_div_mod)\n      (simp add: nats_of_boolss_div2 nats_of_boolss_mod2 is_alph_def dfa_trans_def [abs_def])"], ["proof (state)\nthis:\n  dfa_accepting (ineq_dfa n ks l)\n   (dfa_steps (ineq_dfa n ks l)\n     (the (fst (dioph_ineq_dfs n ks l) ! int_encode m)) (bs # bss)) =\n  (eval_dioph ks (nats_of_boolss n (bs # bss)) \\<le> m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ineq_dfa_accepts:\n  assumes bss: \"list_all (is_alph n) bss\"\n  shows \"dfa_accepts (ineq_dfa n ks l) bss = (eval_dioph ks (nats_of_boolss n bss) \\<le> l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa_accepts (ineq_dfa n ks l) bss =\n    (eval_dioph ks (nats_of_boolss n bss) \\<le> l)", "by (simp add: accepts_def)\n    (rule ineq_dfa_accepting [of l l n ks, OF _ bss, simplified dioph_ineq_dfs_start, simplified])"], ["", "lemma ineq_wf_dfa: \"wf_dfa (ineq_dfa n ks l) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_dfa (ineq_dfa n ks l) n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_dfa (ineq_dfa n ks l) n", "have \"\\<forall>x\\<in>set (snd (dioph_ineq_dfs n ks l)). \\<forall>ys\\<in>set (mk_nat_vecs n).\n    the (fst (dioph_ineq_dfs n ks l) ! int_encode ((x - eval_dioph ks ys) div 2)) <\n      length (snd (dioph_ineq_dfs n ks l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (snd (dioph_ineq_dfs n ks l)).\n       \\<forall>ys\\<in>set (mk_nat_vecs n).\n          the (fst (dioph_ineq_dfs n ks l) !\n               int_encode ((x - eval_dioph ks ys) div 2))\n          < length (snd (dioph_ineq_dfs n ks l))", "proof (intro ballI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ys.\n       \\<lbrakk>x \\<in> set (snd (dioph_ineq_dfs n ks l));\n        ys \\<in> set (mk_nat_vecs n)\\<rbrakk>\n       \\<Longrightarrow> the (fst (dioph_ineq_dfs n ks l) !\n                              int_encode ((x - eval_dioph ks ys) div 2))\n                         < length (snd (dioph_ineq_dfs n ks l))", "fix x ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ys.\n       \\<lbrakk>x \\<in> set (snd (dioph_ineq_dfs n ks l));\n        ys \\<in> set (mk_nat_vecs n)\\<rbrakk>\n       \\<Longrightarrow> the (fst (dioph_ineq_dfs n ks l) !\n                              int_encode ((x - eval_dioph ks ys) div 2))\n                         < length (snd (dioph_ineq_dfs n ks l))", "assume x: \"x \\<in> set (snd (dioph_ineq_dfs n ks l))\"\n    and ys: \"ys \\<in> set (mk_nat_vecs n)\""], ["proof (state)\nthis:\n  x \\<in> set (snd (dioph_ineq_dfs n ks l))\n  ys \\<in> set (mk_nat_vecs n)\n\ngoal (1 subgoal):\n 1. \\<And>x ys.\n       \\<lbrakk>x \\<in> set (snd (dioph_ineq_dfs n ks l));\n        ys \\<in> set (mk_nat_vecs n)\\<rbrakk>\n       \\<Longrightarrow> the (fst (dioph_ineq_dfs n ks l) !\n                              int_encode ((x - eval_dioph ks ys) div 2))\n                         < length (snd (dioph_ineq_dfs n ks l))", "from x"], ["proof (chain)\npicking this:\n  x \\<in> set (snd (dioph_ineq_dfs n ks l))", "obtain k where k: \"fst (dioph_ineq_dfs n ks l) ! int_encode x = Some k\"\n      and k': \"dioph_is_node ks l x\""], ["proof (prove)\nusing this:\n  x \\<in> set (snd (dioph_ineq_dfs n ks l))\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>fst (dioph_ineq_dfs n ks l) ! int_encode x = Some k;\n         dioph_is_node ks l x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: in_set_conv_nth dioph_ineq_dfs_bij [symmetric])"], ["proof (state)\nthis:\n  fst (dioph_ineq_dfs n ks l) ! int_encode x = Some k\n  dioph_is_node ks l x\n\ngoal (1 subgoal):\n 1. \\<And>x ys.\n       \\<lbrakk>x \\<in> set (snd (dioph_ineq_dfs n ks l));\n        ys \\<in> set (mk_nat_vecs n)\\<rbrakk>\n       \\<Longrightarrow> the (fst (dioph_ineq_dfs n ks l) !\n                              int_encode ((x - eval_dioph ks ys) div 2))\n                         < length (snd (dioph_ineq_dfs n ks l))", "from k"], ["proof (chain)\npicking this:\n  fst (dioph_ineq_dfs n ks l) ! int_encode x = Some k", "have \"dioph_memb x (dioph_ineq_dfs n ks l)\""], ["proof (prove)\nusing this:\n  fst (dioph_ineq_dfs n ks l) ! int_encode x = Some k\n\ngoal (1 subgoal):\n 1. dioph_memb x (dioph_ineq_dfs n ks l)", "by (simp add: dioph_memb_def split_beta)"], ["proof (state)\nthis:\n  dioph_memb x (dioph_ineq_dfs n ks l)\n\ngoal (1 subgoal):\n 1. \\<And>x ys.\n       \\<lbrakk>x \\<in> set (snd (dioph_ineq_dfs n ks l));\n        ys \\<in> set (mk_nat_vecs n)\\<rbrakk>\n       \\<Longrightarrow> the (fst (dioph_ineq_dfs n ks l) !\n                              int_encode ((x - eval_dioph ks ys) div 2))\n                         < length (snd (dioph_ineq_dfs n ks l))", "moreover"], ["proof (state)\nthis:\n  dioph_memb x (dioph_ineq_dfs n ks l)\n\ngoal (1 subgoal):\n 1. \\<And>x ys.\n       \\<lbrakk>x \\<in> set (snd (dioph_ineq_dfs n ks l));\n        ys \\<in> set (mk_nat_vecs n)\\<rbrakk>\n       \\<Longrightarrow> the (fst (dioph_ineq_dfs n ks l) !\n                              int_encode ((x - eval_dioph ks ys) div 2))\n                         < length (snd (dioph_ineq_dfs n ks l))", "have ll: \"dioph_is_node ks l l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dioph_is_node ks l l", "by (simp add: dioph_is_node_def)"], ["proof (state)\nthis:\n  dioph_is_node ks l l\n\ngoal (1 subgoal):\n 1. \\<And>x ys.\n       \\<lbrakk>x \\<in> set (snd (dioph_ineq_dfs n ks l));\n        ys \\<in> set (mk_nat_vecs n)\\<rbrakk>\n       \\<Longrightarrow> the (fst (dioph_ineq_dfs n ks l) !\n                              int_encode ((x - eval_dioph ks ys) div 2))\n                         < length (snd (dioph_ineq_dfs n ks l))", "ultimately"], ["proof (chain)\npicking this:\n  dioph_memb x (dioph_ineq_dfs n ks l)\n  dioph_is_node ks l l", "have \"(l, x) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*\""], ["proof (prove)\nusing this:\n  dioph_memb x (dioph_ineq_dfs n ks l)\n  dioph_is_node ks l l\n\ngoal (1 subgoal):\n 1. (l, x) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*", "using k'"], ["proof (prove)\nusing this:\n  dioph_memb x (dioph_ineq_dfs n ks l)\n  dioph_is_node ks l l\n  dioph_is_node ks l x\n\ngoal (1 subgoal):\n 1. (l, x) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*", "by (simp add: dioph_ineq_dfs.dfs_eq_rtrancl dioph_ineq_dfs_def)"], ["proof (state)\nthis:\n  (l, x) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>x ys.\n       \\<lbrakk>x \\<in> set (snd (dioph_ineq_dfs n ks l));\n        ys \\<in> set (mk_nat_vecs n)\\<rbrakk>\n       \\<Longrightarrow> the (fst (dioph_ineq_dfs n ks l) !\n                              int_encode ((x - eval_dioph ks ys) div 2))\n                         < length (snd (dioph_ineq_dfs n ks l))", "then"], ["proof (chain)\npicking this:\n  (l, x) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*", "have \"(l, (x - eval_dioph ks ys) div 2) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*\""], ["proof (prove)\nusing this:\n  (l, x) \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (l, (x - eval_dioph ks ys) div 2)\n    \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*", "apply (rule rtrancl_into_rtrancl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, (x - eval_dioph ks ys) div 2) \\<in> succsr (dioph_ineq_succs n ks)", "apply (simp add: succsr_def dioph_ineq_succs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x - eval_dioph ks ys) div 2\n    \\<in> (\\<lambda>xs. (x - eval_dioph ks xs) div 2) ` set (mk_nat_vecs n)", "apply (rule image_eqI [of _ _ ys])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (x - eval_dioph ks ys) div 2 = (x - eval_dioph ks ys) div 2\n 2. ys \\<in> set (mk_nat_vecs n)", "apply (simp_all add: ys)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (l, (x - eval_dioph ks ys) div 2)\n  \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>x ys.\n       \\<lbrakk>x \\<in> set (snd (dioph_ineq_dfs n ks l));\n        ys \\<in> set (mk_nat_vecs n)\\<rbrakk>\n       \\<Longrightarrow> the (fst (dioph_ineq_dfs n ks l) !\n                              int_encode ((x - eval_dioph ks ys) div 2))\n                         < length (snd (dioph_ineq_dfs n ks l))", "moreover"], ["proof (state)\nthis:\n  (l, (x - eval_dioph ks ys) div 2)\n  \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>x ys.\n       \\<lbrakk>x \\<in> set (snd (dioph_ineq_dfs n ks l));\n        ys \\<in> set (mk_nat_vecs n)\\<rbrakk>\n       \\<Longrightarrow> the (fst (dioph_ineq_dfs n ks l) !\n                              int_encode ((x - eval_dioph ks ys) div 2))\n                         < length (snd (dioph_ineq_dfs n ks l))", "from dioph_ineq_dfs.succs_is_node [OF k', of n] ys"], ["proof (chain)\npicking this:\n  list_all (dioph_is_node ks l) (dioph_ineq_succs n ks x)\n  ys \\<in> set (mk_nat_vecs n)", "have x': \"dioph_is_node ks l ((x - eval_dioph ks ys) div 2)\""], ["proof (prove)\nusing this:\n  list_all (dioph_is_node ks l) (dioph_ineq_succs n ks x)\n  ys \\<in> set (mk_nat_vecs n)\n\ngoal (1 subgoal):\n 1. dioph_is_node ks l ((x - eval_dioph ks ys) div 2)", "by (simp add: dioph_ineq_succs_def list_all_iff)"], ["proof (state)\nthis:\n  dioph_is_node ks l ((x - eval_dioph ks ys) div 2)\n\ngoal (1 subgoal):\n 1. \\<And>x ys.\n       \\<lbrakk>x \\<in> set (snd (dioph_ineq_dfs n ks l));\n        ys \\<in> set (mk_nat_vecs n)\\<rbrakk>\n       \\<Longrightarrow> the (fst (dioph_ineq_dfs n ks l) !\n                              int_encode ((x - eval_dioph ks ys) div 2))\n                         < length (snd (dioph_ineq_dfs n ks l))", "ultimately"], ["proof (chain)\npicking this:\n  (l, (x - eval_dioph ks ys) div 2)\n  \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*\n  dioph_is_node ks l ((x - eval_dioph ks ys) div 2)", "have \"dioph_memb ((x - eval_dioph ks ys) div 2) (dioph_ineq_dfs n ks l)\""], ["proof (prove)\nusing this:\n  (l, (x - eval_dioph ks ys) div 2)\n  \\<in> (succsr (dioph_ineq_succs n ks))\\<^sup>*\n  dioph_is_node ks l ((x - eval_dioph ks ys) div 2)\n\ngoal (1 subgoal):\n 1. dioph_memb ((x - eval_dioph ks ys) div 2) (dioph_ineq_dfs n ks l)", "by (simp add: dioph_ineq_dfs.dfs_eq_rtrancl dioph_ineq_dfs_def ll)"], ["proof (state)\nthis:\n  dioph_memb ((x - eval_dioph ks ys) div 2) (dioph_ineq_dfs n ks l)\n\ngoal (1 subgoal):\n 1. \\<And>x ys.\n       \\<lbrakk>x \\<in> set (snd (dioph_ineq_dfs n ks l));\n        ys \\<in> set (mk_nat_vecs n)\\<rbrakk>\n       \\<Longrightarrow> the (fst (dioph_ineq_dfs n ks l) !\n                              int_encode ((x - eval_dioph ks ys) div 2))\n                         < length (snd (dioph_ineq_dfs n ks l))", "then"], ["proof (chain)\npicking this:\n  dioph_memb ((x - eval_dioph ks ys) div 2) (dioph_ineq_dfs n ks l)", "obtain k' where k': \"fst (dioph_ineq_dfs n ks l) !\n      int_encode ((x - eval_dioph ks ys) div 2) = Some k'\""], ["proof (prove)\nusing this:\n  dioph_memb ((x - eval_dioph ks ys) div 2) (dioph_ineq_dfs n ks l)\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        fst (dioph_ineq_dfs n ks l) !\n        int_encode ((x - eval_dioph ks ys) div 2) =\n        Some k' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: dioph_memb_def)"], ["proof (state)\nthis:\n  fst (dioph_ineq_dfs n ks l) ! int_encode ((x - eval_dioph ks ys) div 2) =\n  Some k'\n\ngoal (1 subgoal):\n 1. \\<And>x ys.\n       \\<lbrakk>x \\<in> set (snd (dioph_ineq_dfs n ks l));\n        ys \\<in> set (mk_nat_vecs n)\\<rbrakk>\n       \\<Longrightarrow> the (fst (dioph_ineq_dfs n ks l) !\n                              int_encode ((x - eval_dioph ks ys) div 2))\n                         < length (snd (dioph_ineq_dfs n ks l))", "with x'"], ["proof (chain)\npicking this:\n  dioph_is_node ks l ((x - eval_dioph ks ys) div 2)\n  fst (dioph_ineq_dfs n ks l) ! int_encode ((x - eval_dioph ks ys) div 2) =\n  Some k'", "have \"k' < length (snd (dioph_ineq_dfs n ks l)) \\<and>\n      snd (dioph_ineq_dfs n ks l) ! k' = ((x - eval_dioph ks ys) div 2)\""], ["proof (prove)\nusing this:\n  dioph_is_node ks l ((x - eval_dioph ks ys) div 2)\n  fst (dioph_ineq_dfs n ks l) ! int_encode ((x - eval_dioph ks ys) div 2) =\n  Some k'\n\ngoal (1 subgoal):\n 1. k' < length (snd (dioph_ineq_dfs n ks l)) \\<and>\n    snd (dioph_ineq_dfs n ks l) ! k' = (x - eval_dioph ks ys) div 2", "by (simp add: dioph_ineq_dfs_bij [symmetric])"], ["proof (state)\nthis:\n  k' < length (snd (dioph_ineq_dfs n ks l)) \\<and>\n  snd (dioph_ineq_dfs n ks l) ! k' = (x - eval_dioph ks ys) div 2\n\ngoal (1 subgoal):\n 1. \\<And>x ys.\n       \\<lbrakk>x \\<in> set (snd (dioph_ineq_dfs n ks l));\n        ys \\<in> set (mk_nat_vecs n)\\<rbrakk>\n       \\<Longrightarrow> the (fst (dioph_ineq_dfs n ks l) !\n                              int_encode ((x - eval_dioph ks ys) div 2))\n                         < length (snd (dioph_ineq_dfs n ks l))", "with k'"], ["proof (chain)\npicking this:\n  fst (dioph_ineq_dfs n ks l) ! int_encode ((x - eval_dioph ks ys) div 2) =\n  Some k'\n  k' < length (snd (dioph_ineq_dfs n ks l)) \\<and>\n  snd (dioph_ineq_dfs n ks l) ! k' = (x - eval_dioph ks ys) div 2", "show \"the (fst (dioph_ineq_dfs n ks l) ! int_encode ((x - eval_dioph ks ys) div 2)) <\n      length (snd (dioph_ineq_dfs n ks l))\""], ["proof (prove)\nusing this:\n  fst (dioph_ineq_dfs n ks l) ! int_encode ((x - eval_dioph ks ys) div 2) =\n  Some k'\n  k' < length (snd (dioph_ineq_dfs n ks l)) \\<and>\n  snd (dioph_ineq_dfs n ks l) ! k' = (x - eval_dioph ks ys) div 2\n\ngoal (1 subgoal):\n 1. the (fst (dioph_ineq_dfs n ks l) !\n         int_encode ((x - eval_dioph ks ys) div 2))\n    < length (snd (dioph_ineq_dfs n ks l))", "by simp"], ["proof (state)\nthis:\n  the (fst (dioph_ineq_dfs n ks l) !\n       int_encode ((x - eval_dioph ks ys) div 2))\n  < length (snd (dioph_ineq_dfs n ks l))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (snd (dioph_ineq_dfs n ks l)).\n     \\<forall>ys\\<in>set (mk_nat_vecs n).\n        the (fst (dioph_ineq_dfs n ks l) !\n             int_encode ((x - eval_dioph ks ys) div 2))\n        < length (snd (dioph_ineq_dfs n ks l))\n\ngoal (1 subgoal):\n 1. wf_dfa (ineq_dfa n ks l) n", "moreover"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (snd (dioph_ineq_dfs n ks l)).\n     \\<forall>ys\\<in>set (mk_nat_vecs n).\n        the (fst (dioph_ineq_dfs n ks l) !\n             int_encode ((x - eval_dioph ks ys) div 2))\n        < length (snd (dioph_ineq_dfs n ks l))\n\ngoal (1 subgoal):\n 1. wf_dfa (ineq_dfa n ks l) n", "have \"fst (dioph_ineq_dfs n ks l) ! int_encode l = Some 0 \\<and> dioph_is_node ks l l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (dioph_ineq_dfs n ks l) ! int_encode l = Some 0 \\<and>\n    dioph_is_node ks l l", "by (simp add: dioph_ineq_dfs_start dioph_is_node_def)"], ["proof (state)\nthis:\n  fst (dioph_ineq_dfs n ks l) ! int_encode l = Some 0 \\<and>\n  dioph_is_node ks l l\n\ngoal (1 subgoal):\n 1. wf_dfa (ineq_dfa n ks l) n", "then"], ["proof (chain)\npicking this:\n  fst (dioph_ineq_dfs n ks l) ! int_encode l = Some 0 \\<and>\n  dioph_is_node ks l l", "have \"snd (dioph_ineq_dfs n ks l) \\<noteq> []\""], ["proof (prove)\nusing this:\n  fst (dioph_ineq_dfs n ks l) ! int_encode l = Some 0 \\<and>\n  dioph_is_node ks l l\n\ngoal (1 subgoal):\n 1. snd (dioph_ineq_dfs n ks l) \\<noteq> []", "by (simp add: dioph_ineq_dfs_bij)"], ["proof (state)\nthis:\n  snd (dioph_ineq_dfs n ks l) \\<noteq> []\n\ngoal (1 subgoal):\n 1. wf_dfa (ineq_dfa n ks l) n", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set (snd (dioph_ineq_dfs n ks l)).\n     \\<forall>ys\\<in>set (mk_nat_vecs n).\n        the (fst (dioph_ineq_dfs n ks l) !\n             int_encode ((x - eval_dioph ks ys) div 2))\n        < length (snd (dioph_ineq_dfs n ks l))\n  snd (dioph_ineq_dfs n ks l) \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (snd (dioph_ineq_dfs n ks l)).\n     \\<forall>ys\\<in>set (mk_nat_vecs n).\n        the (fst (dioph_ineq_dfs n ks l) !\n             int_encode ((x - eval_dioph ks ys) div 2))\n        < length (snd (dioph_ineq_dfs n ks l))\n  snd (dioph_ineq_dfs n ks l) \\<noteq> []\n\ngoal (1 subgoal):\n 1. wf_dfa (ineq_dfa n ks l) n", "by (simp add: ineq_dfa_def split_beta wf_dfa_def dfa_is_node_def list_all_iff\n      bddh_make_bdd bdd_all_make_bdd)"], ["proof (state)\nthis:\n  wf_dfa (ineq_dfa n ks l) n\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Presburger Arithmetic\\<close>"], ["", "datatype pf =\n    Eq \"int list\" int\n  | Le \"int list\" int\n  | And pf pf\n  | Or pf pf\n  | Imp pf pf\n  | Forall pf\n  | Exist pf\n  | Neg pf"], ["", "type_synonym passign = \"nat list\""], ["", "primrec eval_pf :: \"pf \\<Rightarrow> passign \\<Rightarrow> bool\"\nwhere\n  \"eval_pf (Eq ks l) xs = (eval_dioph ks xs = l)\"\n| \"eval_pf (Le ks l) xs = (eval_dioph ks xs \\<le> l)\"\n| \"eval_pf (And p q) xs = (eval_pf p xs \\<and> eval_pf q xs)\"\n| \"eval_pf (Or p q) xs = (eval_pf p xs \\<or> eval_pf q xs)\"\n| \"eval_pf (Imp p q) xs = (eval_pf p xs \\<longrightarrow> eval_pf q xs)\"\n| \"eval_pf (Forall p) xs = (\\<forall>x. eval_pf p (x # xs))\"\n| \"eval_pf (Exist p) xs = (\\<exists>x. eval_pf p (x # xs))\"\n| \"eval_pf (Neg p) xs = (\\<not> eval_pf p xs)\""], ["", "function dfa_of_pf :: \"nat \\<Rightarrow> pf \\<Rightarrow> dfa\"\nwhere\n  Eq: \"dfa_of_pf n (Eq ks l) = eq_dfa n ks l\"\n| Le: \"dfa_of_pf n (Le ks l) = ineq_dfa n ks l\"\n| And: \"dfa_of_pf n (And p q) = and_dfa (dfa_of_pf n p) (dfa_of_pf n q)\"\n| Or: \"dfa_of_pf n (Or p q) = or_dfa (dfa_of_pf n p) (dfa_of_pf n q)\"\n| Imp: \"dfa_of_pf n (Imp p q) = imp_dfa (dfa_of_pf n p) (dfa_of_pf n q)\"\n| Exist: \"dfa_of_pf n (Exist p) = rquot (det_nfa (quantify_nfa 0 (nfa_of_dfa (dfa_of_pf (Suc n) p)))) n\"\n| Forall: \"dfa_of_pf n (Forall p) = dfa_of_pf n (Neg (Exist (Neg p)))\"\n| Neg: \"dfa_of_pf n (Neg p) = negate_dfa (dfa_of_pf n p)\""], ["proof (prove)\ngoal (37 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>n ks l. x = (n, Eq ks l) \\<Longrightarrow> P;\n        \\<And>n ks l. x = (n, Le ks l) \\<Longrightarrow> P;\n        \\<And>n p q. x = (n, And p q) \\<Longrightarrow> P;\n        \\<And>n p q. x = (n, Or p q) \\<Longrightarrow> P;\n        \\<And>n p q. x = (n, Imp p q) \\<Longrightarrow> P;\n        \\<And>n p. x = (n, Exist p) \\<Longrightarrow> P;\n        \\<And>n p. x = (n, Forall p) \\<Longrightarrow> P;\n        \\<And>n p. x = (n, Neg p) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>n ks l na ksa la.\n       (n, Eq ks l) = (na, Eq ksa la) \\<Longrightarrow>\n       eq_dfa n ks l = eq_dfa na ksa la\n 3. \\<And>n ks l na ksa la.\n       (n, Eq ks l) = (na, Le ksa la) \\<Longrightarrow>\n       eq_dfa n ks l = ineq_dfa na ksa la\n 4. \\<And>n ks l na p q.\n       (n, Eq ks l) = (na, And p q) \\<Longrightarrow>\n       eq_dfa n ks l =\n       and_dfa (dfa_of_pf_sumC (na, p)) (dfa_of_pf_sumC (na, q))\n 5. \\<And>n ks l na p q.\n       (n, Eq ks l) = (na, Or p q) \\<Longrightarrow>\n       eq_dfa n ks l =\n       or_dfa (dfa_of_pf_sumC (na, p)) (dfa_of_pf_sumC (na, q))\n 6. \\<And>n ks l na p q.\n       (n, Eq ks l) = (na, Imp p q) \\<Longrightarrow>\n       eq_dfa n ks l =\n       imp_dfa (dfa_of_pf_sumC (na, p)) (dfa_of_pf_sumC (na, q))\n 7. \\<And>n ks l na p.\n       (n, Eq ks l) = (na, Exist p) \\<Longrightarrow>\n       eq_dfa n ks l =\n       rquot\n        (det_nfa (quantify_nfa 0 (nfa_of_dfa (dfa_of_pf_sumC (Suc na, p)))))\n        na\n 8. \\<And>n ks l na p.\n       (n, Eq ks l) = (na, Forall p) \\<Longrightarrow>\n       eq_dfa n ks l = dfa_of_pf_sumC (na, Neg (Exist (Neg p)))\n 9. \\<And>n ks l na p.\n       (n, Eq ks l) = (na, Neg p) \\<Longrightarrow>\n       eq_dfa n ks l = negate_dfa (dfa_of_pf_sumC (na, p))\n 10. \\<And>n ks l na ksa la.\n        (n, Le ks l) = (na, Le ksa la) \\<Longrightarrow>\n        ineq_dfa n ks l = ineq_dfa na ksa la\nA total of 37 subgoals...", "by pat_completeness auto"], ["", "text \\<open>Auxiliary measure function for termination proof\\<close>"], ["", "primrec count_forall :: \"pf \\<Rightarrow> nat\"\nwhere\n  \"count_forall (Eq ks l) = 0\"\n| \"count_forall (Le ks l) = 0\"\n| \"count_forall (And p q) = count_forall p + count_forall q\"\n| \"count_forall (Or p q) = count_forall p + count_forall q\"\n| \"count_forall (Imp p q) = count_forall p + count_forall q\"\n| \"count_forall (Exist p) = count_forall p\"\n| \"count_forall (Forall p) = 1 + count_forall p\"\n| \"count_forall (Neg p) = count_forall p\""], ["", "termination dfa_of_pf"], ["proof (prove)\ngoal (1 subgoal):\n 1. All dfa_of_pf_dom", "by (relation \"measures [\\<lambda>(n, pf). count_forall pf, \\<lambda>(n, pf). size pf]\") auto"], ["", "lemmas dfa_of_pf_induct =\n  dfa_of_pf.induct [case_names Eq Le And Or Imp Exist Forall Neg]"], ["", "lemma dfa_of_pf_well_formed: \"wf_dfa (dfa_of_pf n p) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_dfa (dfa_of_pf n p) n", "proof (induct n p rule: dfa_of_pf_induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>n ks l. wf_dfa (dfa_of_pf n (Eq ks l)) n\n 2. \\<And>n ks l. wf_dfa (dfa_of_pf n (Le ks l)) n\n 3. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf n p) n; wf_dfa (dfa_of_pf n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf n (And p q)) n\n 4. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf n p) n; wf_dfa (dfa_of_pf n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf n (Or p q)) n\n 5. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf n p) n; wf_dfa (dfa_of_pf n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf n (Imp p q)) n\n 6. \\<And>n p.\n       wf_dfa (dfa_of_pf (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Exist p)) n\n 7. \\<And>n p.\n       wf_dfa (dfa_of_pf n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Forall p)) n\n 8. \\<And>n p.\n       wf_dfa (dfa_of_pf n p) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Neg p)) n", "case (Eq n ks l)"], ["proof (state)\nthis:\n  \n\ngoal (8 subgoals):\n 1. \\<And>n ks l. wf_dfa (dfa_of_pf n (Eq ks l)) n\n 2. \\<And>n ks l. wf_dfa (dfa_of_pf n (Le ks l)) n\n 3. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf n p) n; wf_dfa (dfa_of_pf n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf n (And p q)) n\n 4. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf n p) n; wf_dfa (dfa_of_pf n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf n (Or p q)) n\n 5. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf n p) n; wf_dfa (dfa_of_pf n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf n (Imp p q)) n\n 6. \\<And>n p.\n       wf_dfa (dfa_of_pf (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Exist p)) n\n 7. \\<And>n p.\n       wf_dfa (dfa_of_pf n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Forall p)) n\n 8. \\<And>n p.\n       wf_dfa (dfa_of_pf n p) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Neg p)) n", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_dfa (dfa_of_pf n (Eq ks l)) n", "by (simp add: eq_wf_dfa)"], ["proof (state)\nthis:\n  wf_dfa (dfa_of_pf n (Eq ks l)) n\n\ngoal (7 subgoals):\n 1. \\<And>n ks l. wf_dfa (dfa_of_pf n (Le ks l)) n\n 2. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf n p) n; wf_dfa (dfa_of_pf n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf n (And p q)) n\n 3. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf n p) n; wf_dfa (dfa_of_pf n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf n (Or p q)) n\n 4. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf n p) n; wf_dfa (dfa_of_pf n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf n (Imp p q)) n\n 5. \\<And>n p.\n       wf_dfa (dfa_of_pf (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Exist p)) n\n 6. \\<And>n p.\n       wf_dfa (dfa_of_pf n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Forall p)) n\n 7. \\<And>n p.\n       wf_dfa (dfa_of_pf n p) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Neg p)) n", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>n ks l. wf_dfa (dfa_of_pf n (Le ks l)) n\n 2. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf n p) n; wf_dfa (dfa_of_pf n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf n (And p q)) n\n 3. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf n p) n; wf_dfa (dfa_of_pf n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf n (Or p q)) n\n 4. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf n p) n; wf_dfa (dfa_of_pf n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf n (Imp p q)) n\n 5. \\<And>n p.\n       wf_dfa (dfa_of_pf (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Exist p)) n\n 6. \\<And>n p.\n       wf_dfa (dfa_of_pf n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Forall p)) n\n 7. \\<And>n p.\n       wf_dfa (dfa_of_pf n p) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Neg p)) n", "case (Le n ks l)"], ["proof (state)\nthis:\n  \n\ngoal (7 subgoals):\n 1. \\<And>n ks l. wf_dfa (dfa_of_pf n (Le ks l)) n\n 2. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf n p) n; wf_dfa (dfa_of_pf n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf n (And p q)) n\n 3. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf n p) n; wf_dfa (dfa_of_pf n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf n (Or p q)) n\n 4. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf n p) n; wf_dfa (dfa_of_pf n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf n (Imp p q)) n\n 5. \\<And>n p.\n       wf_dfa (dfa_of_pf (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Exist p)) n\n 6. \\<And>n p.\n       wf_dfa (dfa_of_pf n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Forall p)) n\n 7. \\<And>n p.\n       wf_dfa (dfa_of_pf n p) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Neg p)) n", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_dfa (dfa_of_pf n (Le ks l)) n", "by (simp add: ineq_wf_dfa)"], ["proof (state)\nthis:\n  wf_dfa (dfa_of_pf n (Le ks l)) n\n\ngoal (6 subgoals):\n 1. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf n p) n; wf_dfa (dfa_of_pf n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf n (And p q)) n\n 2. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf n p) n; wf_dfa (dfa_of_pf n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf n (Or p q)) n\n 3. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf n p) n; wf_dfa (dfa_of_pf n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf n (Imp p q)) n\n 4. \\<And>n p.\n       wf_dfa (dfa_of_pf (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Exist p)) n\n 5. \\<And>n p.\n       wf_dfa (dfa_of_pf n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Forall p)) n\n 6. \\<And>n p.\n       wf_dfa (dfa_of_pf n p) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Neg p)) n", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf n p) n; wf_dfa (dfa_of_pf n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf n (And p q)) n\n 2. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf n p) n; wf_dfa (dfa_of_pf n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf n (Or p q)) n\n 3. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf n p) n; wf_dfa (dfa_of_pf n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf n (Imp p q)) n\n 4. \\<And>n p.\n       wf_dfa (dfa_of_pf (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Exist p)) n\n 5. \\<And>n p.\n       wf_dfa (dfa_of_pf n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Forall p)) n\n 6. \\<And>n p.\n       wf_dfa (dfa_of_pf n p) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Neg p)) n", "case (And n p q)"], ["proof (state)\nthis:\n  wf_dfa (dfa_of_pf n p) n\n  wf_dfa (dfa_of_pf n q) n\n\ngoal (6 subgoals):\n 1. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf n p) n; wf_dfa (dfa_of_pf n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf n (And p q)) n\n 2. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf n p) n; wf_dfa (dfa_of_pf n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf n (Or p q)) n\n 3. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf n p) n; wf_dfa (dfa_of_pf n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf n (Imp p q)) n\n 4. \\<And>n p.\n       wf_dfa (dfa_of_pf (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Exist p)) n\n 5. \\<And>n p.\n       wf_dfa (dfa_of_pf n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Forall p)) n\n 6. \\<And>n p.\n       wf_dfa (dfa_of_pf n p) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Neg p)) n", "then"], ["proof (chain)\npicking this:\n  wf_dfa (dfa_of_pf n p) n\n  wf_dfa (dfa_of_pf n q) n", "show ?case"], ["proof (prove)\nusing this:\n  wf_dfa (dfa_of_pf n p) n\n  wf_dfa (dfa_of_pf n q) n\n\ngoal (1 subgoal):\n 1. wf_dfa (dfa_of_pf n (And p q)) n", "by (simp add: and_wf_dfa)"], ["proof (state)\nthis:\n  wf_dfa (dfa_of_pf n (And p q)) n\n\ngoal (5 subgoals):\n 1. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf n p) n; wf_dfa (dfa_of_pf n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf n (Or p q)) n\n 2. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf n p) n; wf_dfa (dfa_of_pf n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf n (Imp p q)) n\n 3. \\<And>n p.\n       wf_dfa (dfa_of_pf (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Exist p)) n\n 4. \\<And>n p.\n       wf_dfa (dfa_of_pf n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Forall p)) n\n 5. \\<And>n p.\n       wf_dfa (dfa_of_pf n p) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Neg p)) n", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf n p) n; wf_dfa (dfa_of_pf n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf n (Or p q)) n\n 2. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf n p) n; wf_dfa (dfa_of_pf n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf n (Imp p q)) n\n 3. \\<And>n p.\n       wf_dfa (dfa_of_pf (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Exist p)) n\n 4. \\<And>n p.\n       wf_dfa (dfa_of_pf n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Forall p)) n\n 5. \\<And>n p.\n       wf_dfa (dfa_of_pf n p) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Neg p)) n", "case (Or n p q)"], ["proof (state)\nthis:\n  wf_dfa (dfa_of_pf n p) n\n  wf_dfa (dfa_of_pf n q) n\n\ngoal (5 subgoals):\n 1. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf n p) n; wf_dfa (dfa_of_pf n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf n (Or p q)) n\n 2. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf n p) n; wf_dfa (dfa_of_pf n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf n (Imp p q)) n\n 3. \\<And>n p.\n       wf_dfa (dfa_of_pf (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Exist p)) n\n 4. \\<And>n p.\n       wf_dfa (dfa_of_pf n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Forall p)) n\n 5. \\<And>n p.\n       wf_dfa (dfa_of_pf n p) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Neg p)) n", "then"], ["proof (chain)\npicking this:\n  wf_dfa (dfa_of_pf n p) n\n  wf_dfa (dfa_of_pf n q) n", "show ?case"], ["proof (prove)\nusing this:\n  wf_dfa (dfa_of_pf n p) n\n  wf_dfa (dfa_of_pf n q) n\n\ngoal (1 subgoal):\n 1. wf_dfa (dfa_of_pf n (Or p q)) n", "by (simp add: or_wf_dfa)"], ["proof (state)\nthis:\n  wf_dfa (dfa_of_pf n (Or p q)) n\n\ngoal (4 subgoals):\n 1. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf n p) n; wf_dfa (dfa_of_pf n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf n (Imp p q)) n\n 2. \\<And>n p.\n       wf_dfa (dfa_of_pf (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Exist p)) n\n 3. \\<And>n p.\n       wf_dfa (dfa_of_pf n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Forall p)) n\n 4. \\<And>n p.\n       wf_dfa (dfa_of_pf n p) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Neg p)) n", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf n p) n; wf_dfa (dfa_of_pf n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf n (Imp p q)) n\n 2. \\<And>n p.\n       wf_dfa (dfa_of_pf (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Exist p)) n\n 3. \\<And>n p.\n       wf_dfa (dfa_of_pf n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Forall p)) n\n 4. \\<And>n p.\n       wf_dfa (dfa_of_pf n p) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Neg p)) n", "case (Imp n p q)"], ["proof (state)\nthis:\n  wf_dfa (dfa_of_pf n p) n\n  wf_dfa (dfa_of_pf n q) n\n\ngoal (4 subgoals):\n 1. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf n p) n; wf_dfa (dfa_of_pf n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf n (Imp p q)) n\n 2. \\<And>n p.\n       wf_dfa (dfa_of_pf (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Exist p)) n\n 3. \\<And>n p.\n       wf_dfa (dfa_of_pf n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Forall p)) n\n 4. \\<And>n p.\n       wf_dfa (dfa_of_pf n p) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Neg p)) n", "then"], ["proof (chain)\npicking this:\n  wf_dfa (dfa_of_pf n p) n\n  wf_dfa (dfa_of_pf n q) n", "show ?case"], ["proof (prove)\nusing this:\n  wf_dfa (dfa_of_pf n p) n\n  wf_dfa (dfa_of_pf n q) n\n\ngoal (1 subgoal):\n 1. wf_dfa (dfa_of_pf n (Imp p q)) n", "by (simp add: imp_wf_dfa)"], ["proof (state)\nthis:\n  wf_dfa (dfa_of_pf n (Imp p q)) n\n\ngoal (3 subgoals):\n 1. \\<And>n p.\n       wf_dfa (dfa_of_pf (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Exist p)) n\n 2. \\<And>n p.\n       wf_dfa (dfa_of_pf n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Forall p)) n\n 3. \\<And>n p.\n       wf_dfa (dfa_of_pf n p) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Neg p)) n", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n p.\n       wf_dfa (dfa_of_pf (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Exist p)) n\n 2. \\<And>n p.\n       wf_dfa (dfa_of_pf n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Forall p)) n\n 3. \\<And>n p.\n       wf_dfa (dfa_of_pf n p) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Neg p)) n", "case (Neg n p)"], ["proof (state)\nthis:\n  wf_dfa (dfa_of_pf n p) n\n\ngoal (3 subgoals):\n 1. \\<And>n p.\n       wf_dfa (dfa_of_pf (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Exist p)) n\n 2. \\<And>n p.\n       wf_dfa (dfa_of_pf n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Forall p)) n\n 3. \\<And>n p.\n       wf_dfa (dfa_of_pf n p) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Neg p)) n", "then"], ["proof (chain)\npicking this:\n  wf_dfa (dfa_of_pf n p) n", "show ?case"], ["proof (prove)\nusing this:\n  wf_dfa (dfa_of_pf n p) n\n\ngoal (1 subgoal):\n 1. wf_dfa (dfa_of_pf n (Neg p)) n", "by (simp add: negate_wf_dfa)"], ["proof (state)\nthis:\n  wf_dfa (dfa_of_pf n (Neg p)) n\n\ngoal (2 subgoals):\n 1. \\<And>n p.\n       wf_dfa (dfa_of_pf (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Exist p)) n\n 2. \\<And>n p.\n       wf_dfa (dfa_of_pf n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Forall p)) n", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n p.\n       wf_dfa (dfa_of_pf (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Exist p)) n\n 2. \\<And>n p.\n       wf_dfa (dfa_of_pf n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Forall p)) n", "case (Exist n p)"], ["proof (state)\nthis:\n  wf_dfa (dfa_of_pf (Suc n) p) (Suc n)\n\ngoal (2 subgoals):\n 1. \\<And>n p.\n       wf_dfa (dfa_of_pf (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Exist p)) n\n 2. \\<And>n p.\n       wf_dfa (dfa_of_pf n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Forall p)) n", "then"], ["proof (chain)\npicking this:\n  wf_dfa (dfa_of_pf (Suc n) p) (Suc n)", "show ?case"], ["proof (prove)\nusing this:\n  wf_dfa (dfa_of_pf (Suc n) p) (Suc n)\n\ngoal (1 subgoal):\n 1. wf_dfa (dfa_of_pf n (Exist p)) n", "by (simp add: rquot_well_formed_aut det_wf_nfa quantify_nfa_well_formed_aut dfa2wf_nfa)"], ["proof (state)\nthis:\n  wf_dfa (dfa_of_pf n (Exist p)) n\n\ngoal (1 subgoal):\n 1. \\<And>n p.\n       wf_dfa (dfa_of_pf n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Forall p)) n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n p.\n       wf_dfa (dfa_of_pf n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Forall p)) n", "case (Forall n p)"], ["proof (state)\nthis:\n  wf_dfa (dfa_of_pf n (Neg (Exist (Neg p)))) n\n\ngoal (1 subgoal):\n 1. \\<And>n p.\n       wf_dfa (dfa_of_pf n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf n (Forall p)) n", "then"], ["proof (chain)\npicking this:\n  wf_dfa (dfa_of_pf n (Neg (Exist (Neg p)))) n", "show ?case"], ["proof (prove)\nusing this:\n  wf_dfa (dfa_of_pf n (Neg (Exist (Neg p)))) n\n\ngoal (1 subgoal):\n 1. wf_dfa (dfa_of_pf n (Forall p)) n", "by simp"], ["proof (state)\nthis:\n  wf_dfa (dfa_of_pf n (Forall p)) n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dfa_of_pf_correctness:\n  \"list_all (is_alph n) bss \\<Longrightarrow>\n     dfa_accepts (dfa_of_pf n p) bss = eval_pf p (nats_of_boolss n bss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (is_alph n) bss \\<Longrightarrow>\n    dfa_accepts (dfa_of_pf n p) bss = eval_pf p (nats_of_boolss n bss)", "proof (induct n p arbitrary: bss rule: dfa_of_pf_induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>n ks l bss.\n       list_all (is_alph n) bss \\<Longrightarrow>\n       dfa_accepts (dfa_of_pf n (Eq ks l)) bss =\n       eval_pf (Eq ks l) (nats_of_boolss n bss)\n 2. \\<And>n ks l bss.\n       list_all (is_alph n) bss \\<Longrightarrow>\n       dfa_accepts (dfa_of_pf n (Le ks l)) bss =\n       eval_pf (Le ks l) (nats_of_boolss n bss)\n 3. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (And p q)) bss =\n                         eval_pf (And p q) (nats_of_boolss n bss)\n 4. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Or p q)) bss =\n                         eval_pf (Or p q) (nats_of_boolss n bss)\n 5. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Imp p q)) bss =\n                         eval_pf (Imp p q) (nats_of_boolss n bss)\n 6. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 7. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)\n 8. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Neg p)) bss =\n                         eval_pf (Neg p) (nats_of_boolss n bss)", "case (Eq n ks l)"], ["proof (state)\nthis:\n  list_all (is_alph n) bss\n\ngoal (8 subgoals):\n 1. \\<And>n ks l bss.\n       list_all (is_alph n) bss \\<Longrightarrow>\n       dfa_accepts (dfa_of_pf n (Eq ks l)) bss =\n       eval_pf (Eq ks l) (nats_of_boolss n bss)\n 2. \\<And>n ks l bss.\n       list_all (is_alph n) bss \\<Longrightarrow>\n       dfa_accepts (dfa_of_pf n (Le ks l)) bss =\n       eval_pf (Le ks l) (nats_of_boolss n bss)\n 3. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (And p q)) bss =\n                         eval_pf (And p q) (nats_of_boolss n bss)\n 4. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Or p q)) bss =\n                         eval_pf (Or p q) (nats_of_boolss n bss)\n 5. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Imp p q)) bss =\n                         eval_pf (Imp p q) (nats_of_boolss n bss)\n 6. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 7. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)\n 8. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Neg p)) bss =\n                         eval_pf (Neg p) (nats_of_boolss n bss)", "then"], ["proof (chain)\npicking this:\n  list_all (is_alph n) bss", "show ?case"], ["proof (prove)\nusing this:\n  list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. dfa_accepts (dfa_of_pf n (Eq ks l)) bss =\n    eval_pf (Eq ks l) (nats_of_boolss n bss)", "by (simp add: eq_dfa_accepts)"], ["proof (state)\nthis:\n  dfa_accepts (dfa_of_pf n (Eq ks l)) bss =\n  eval_pf (Eq ks l) (nats_of_boolss n bss)\n\ngoal (7 subgoals):\n 1. \\<And>n ks l bss.\n       list_all (is_alph n) bss \\<Longrightarrow>\n       dfa_accepts (dfa_of_pf n (Le ks l)) bss =\n       eval_pf (Le ks l) (nats_of_boolss n bss)\n 2. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (And p q)) bss =\n                         eval_pf (And p q) (nats_of_boolss n bss)\n 3. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Or p q)) bss =\n                         eval_pf (Or p q) (nats_of_boolss n bss)\n 4. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Imp p q)) bss =\n                         eval_pf (Imp p q) (nats_of_boolss n bss)\n 5. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 6. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)\n 7. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Neg p)) bss =\n                         eval_pf (Neg p) (nats_of_boolss n bss)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>n ks l bss.\n       list_all (is_alph n) bss \\<Longrightarrow>\n       dfa_accepts (dfa_of_pf n (Le ks l)) bss =\n       eval_pf (Le ks l) (nats_of_boolss n bss)\n 2. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (And p q)) bss =\n                         eval_pf (And p q) (nats_of_boolss n bss)\n 3. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Or p q)) bss =\n                         eval_pf (Or p q) (nats_of_boolss n bss)\n 4. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Imp p q)) bss =\n                         eval_pf (Imp p q) (nats_of_boolss n bss)\n 5. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 6. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)\n 7. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Neg p)) bss =\n                         eval_pf (Neg p) (nats_of_boolss n bss)", "case (Le n ks l)"], ["proof (state)\nthis:\n  list_all (is_alph n) bss\n\ngoal (7 subgoals):\n 1. \\<And>n ks l bss.\n       list_all (is_alph n) bss \\<Longrightarrow>\n       dfa_accepts (dfa_of_pf n (Le ks l)) bss =\n       eval_pf (Le ks l) (nats_of_boolss n bss)\n 2. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (And p q)) bss =\n                         eval_pf (And p q) (nats_of_boolss n bss)\n 3. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Or p q)) bss =\n                         eval_pf (Or p q) (nats_of_boolss n bss)\n 4. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Imp p q)) bss =\n                         eval_pf (Imp p q) (nats_of_boolss n bss)\n 5. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 6. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)\n 7. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Neg p)) bss =\n                         eval_pf (Neg p) (nats_of_boolss n bss)", "then"], ["proof (chain)\npicking this:\n  list_all (is_alph n) bss", "show ?case"], ["proof (prove)\nusing this:\n  list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. dfa_accepts (dfa_of_pf n (Le ks l)) bss =\n    eval_pf (Le ks l) (nats_of_boolss n bss)", "by (simp add: ineq_dfa_accepts)"], ["proof (state)\nthis:\n  dfa_accepts (dfa_of_pf n (Le ks l)) bss =\n  eval_pf (Le ks l) (nats_of_boolss n bss)\n\ngoal (6 subgoals):\n 1. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (And p q)) bss =\n                         eval_pf (And p q) (nats_of_boolss n bss)\n 2. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Or p q)) bss =\n                         eval_pf (Or p q) (nats_of_boolss n bss)\n 3. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Imp p q)) bss =\n                         eval_pf (Imp p q) (nats_of_boolss n bss)\n 4. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 5. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)\n 6. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Neg p)) bss =\n                         eval_pf (Neg p) (nats_of_boolss n bss)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (And p q)) bss =\n                         eval_pf (And p q) (nats_of_boolss n bss)\n 2. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Or p q)) bss =\n                         eval_pf (Or p q) (nats_of_boolss n bss)\n 3. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Imp p q)) bss =\n                         eval_pf (Imp p q) (nats_of_boolss n bss)\n 4. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 5. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)\n 6. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Neg p)) bss =\n                         eval_pf (Neg p) (nats_of_boolss n bss)", "case (And n p q)"], ["proof (state)\nthis:\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf n p) ?bss = eval_pf p (nats_of_boolss n ?bss)\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf n q) ?bss = eval_pf q (nats_of_boolss n ?bss)\n  list_all (is_alph n) bss\n\ngoal (6 subgoals):\n 1. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (And p q)) bss =\n                         eval_pf (And p q) (nats_of_boolss n bss)\n 2. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Or p q)) bss =\n                         eval_pf (Or p q) (nats_of_boolss n bss)\n 3. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Imp p q)) bss =\n                         eval_pf (Imp p q) (nats_of_boolss n bss)\n 4. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 5. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)\n 6. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Neg p)) bss =\n                         eval_pf (Neg p) (nats_of_boolss n bss)", "then"], ["proof (chain)\npicking this:\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf n p) ?bss = eval_pf p (nats_of_boolss n ?bss)\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf n q) ?bss = eval_pf q (nats_of_boolss n ?bss)\n  list_all (is_alph n) bss", "show ?case"], ["proof (prove)\nusing this:\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf n p) ?bss = eval_pf p (nats_of_boolss n ?bss)\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf n q) ?bss = eval_pf q (nats_of_boolss n ?bss)\n  list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. dfa_accepts (dfa_of_pf n (And p q)) bss =\n    eval_pf (And p q) (nats_of_boolss n bss)", "by (simp add: and_dfa_accepts [of _ n] dfa_of_pf_well_formed)"], ["proof (state)\nthis:\n  dfa_accepts (dfa_of_pf n (And p q)) bss =\n  eval_pf (And p q) (nats_of_boolss n bss)\n\ngoal (5 subgoals):\n 1. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Or p q)) bss =\n                         eval_pf (Or p q) (nats_of_boolss n bss)\n 2. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Imp p q)) bss =\n                         eval_pf (Imp p q) (nats_of_boolss n bss)\n 3. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 4. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)\n 5. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Neg p)) bss =\n                         eval_pf (Neg p) (nats_of_boolss n bss)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Or p q)) bss =\n                         eval_pf (Or p q) (nats_of_boolss n bss)\n 2. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Imp p q)) bss =\n                         eval_pf (Imp p q) (nats_of_boolss n bss)\n 3. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 4. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)\n 5. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Neg p)) bss =\n                         eval_pf (Neg p) (nats_of_boolss n bss)", "case (Or n p q)"], ["proof (state)\nthis:\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf n p) ?bss = eval_pf p (nats_of_boolss n ?bss)\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf n q) ?bss = eval_pf q (nats_of_boolss n ?bss)\n  list_all (is_alph n) bss\n\ngoal (5 subgoals):\n 1. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Or p q)) bss =\n                         eval_pf (Or p q) (nats_of_boolss n bss)\n 2. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Imp p q)) bss =\n                         eval_pf (Imp p q) (nats_of_boolss n bss)\n 3. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 4. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)\n 5. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Neg p)) bss =\n                         eval_pf (Neg p) (nats_of_boolss n bss)", "then"], ["proof (chain)\npicking this:\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf n p) ?bss = eval_pf p (nats_of_boolss n ?bss)\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf n q) ?bss = eval_pf q (nats_of_boolss n ?bss)\n  list_all (is_alph n) bss", "show ?case"], ["proof (prove)\nusing this:\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf n p) ?bss = eval_pf p (nats_of_boolss n ?bss)\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf n q) ?bss = eval_pf q (nats_of_boolss n ?bss)\n  list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. dfa_accepts (dfa_of_pf n (Or p q)) bss =\n    eval_pf (Or p q) (nats_of_boolss n bss)", "by (simp add: or_dfa_accepts [of _ n] dfa_of_pf_well_formed)"], ["proof (state)\nthis:\n  dfa_accepts (dfa_of_pf n (Or p q)) bss =\n  eval_pf (Or p q) (nats_of_boolss n bss)\n\ngoal (4 subgoals):\n 1. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Imp p q)) bss =\n                         eval_pf (Imp p q) (nats_of_boolss n bss)\n 2. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 3. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)\n 4. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Neg p)) bss =\n                         eval_pf (Neg p) (nats_of_boolss n bss)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Imp p q)) bss =\n                         eval_pf (Imp p q) (nats_of_boolss n bss)\n 2. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 3. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)\n 4. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Neg p)) bss =\n                         eval_pf (Neg p) (nats_of_boolss n bss)", "case (Imp n p q)"], ["proof (state)\nthis:\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf n p) ?bss = eval_pf p (nats_of_boolss n ?bss)\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf n q) ?bss = eval_pf q (nats_of_boolss n ?bss)\n  list_all (is_alph n) bss\n\ngoal (4 subgoals):\n 1. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Imp p q)) bss =\n                         eval_pf (Imp p q) (nats_of_boolss n bss)\n 2. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 3. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)\n 4. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Neg p)) bss =\n                         eval_pf (Neg p) (nats_of_boolss n bss)", "then"], ["proof (chain)\npicking this:\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf n p) ?bss = eval_pf p (nats_of_boolss n ?bss)\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf n q) ?bss = eval_pf q (nats_of_boolss n ?bss)\n  list_all (is_alph n) bss", "show ?case"], ["proof (prove)\nusing this:\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf n p) ?bss = eval_pf p (nats_of_boolss n ?bss)\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf n q) ?bss = eval_pf q (nats_of_boolss n ?bss)\n  list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. dfa_accepts (dfa_of_pf n (Imp p q)) bss =\n    eval_pf (Imp p q) (nats_of_boolss n bss)", "by (simp add: imp_dfa_accepts [of _ n] dfa_of_pf_well_formed)"], ["proof (state)\nthis:\n  dfa_accepts (dfa_of_pf n (Imp p q)) bss =\n  eval_pf (Imp p q) (nats_of_boolss n bss)\n\ngoal (3 subgoals):\n 1. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 2. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)\n 3. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Neg p)) bss =\n                         eval_pf (Neg p) (nats_of_boolss n bss)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 2. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)\n 3. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Neg p)) bss =\n                         eval_pf (Neg p) (nats_of_boolss n bss)", "case (Neg n p)"], ["proof (state)\nthis:\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf n p) ?bss = eval_pf p (nats_of_boolss n ?bss)\n  list_all (is_alph n) bss\n\ngoal (3 subgoals):\n 1. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 2. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)\n 3. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Neg p)) bss =\n                         eval_pf (Neg p) (nats_of_boolss n bss)", "then"], ["proof (chain)\npicking this:\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf n p) ?bss = eval_pf p (nats_of_boolss n ?bss)\n  list_all (is_alph n) bss", "show ?case"], ["proof (prove)\nusing this:\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf n p) ?bss = eval_pf p (nats_of_boolss n ?bss)\n  list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. dfa_accepts (dfa_of_pf n (Neg p)) bss =\n    eval_pf (Neg p) (nats_of_boolss n bss)", "by (simp add: dfa_accepts_negate [of _ n] dfa_of_pf_well_formed)"], ["proof (state)\nthis:\n  dfa_accepts (dfa_of_pf n (Neg p)) bss =\n  eval_pf (Neg p) (nats_of_boolss n bss)\n\ngoal (2 subgoals):\n 1. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 2. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 2. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)", "case (Exist n p)"], ["proof (state)\nthis:\n  list_all (is_alph (Suc n)) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf (Suc n) p) ?bss =\n  eval_pf p (nats_of_boolss (Suc n) ?bss)\n  list_all (is_alph n) bss\n\ngoal (2 subgoals):\n 1. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 2. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)", "have \"(\\<exists>k bs. eval_pf p (nat_of_bools bs # nats_of_boolss n bss) \\<and> length bs = length bss + k) =\n    (\\<exists>x. eval_pf p (x # nats_of_boolss n bss))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>k bs.\n        eval_pf p (nat_of_bools bs # nats_of_boolss n bss) \\<and>\n        length bs = length bss + k) =\n    (\\<exists>x. eval_pf p (x # nats_of_boolss n bss))", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>k bs.\n       eval_pf p (nat_of_bools bs # nats_of_boolss n bss) \\<and>\n       length bs = length bss + k \\<Longrightarrow>\n    \\<exists>x. eval_pf p (x # nats_of_boolss n bss)\n 2. \\<exists>x. eval_pf p (x # nats_of_boolss n bss) \\<Longrightarrow>\n    \\<exists>k bs.\n       eval_pf p (nat_of_bools bs # nats_of_boolss n bss) \\<and>\n       length bs = length bss + k", "apply (erule exE conjE)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k bs.\n       \\<lbrakk>eval_pf p (nat_of_bools bs # nats_of_boolss n bss);\n        length bs = length bss + k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x. eval_pf p (x # nats_of_boolss n bss)\n 2. \\<exists>x. eval_pf p (x # nats_of_boolss n bss) \\<Longrightarrow>\n    \\<exists>k bs.\n       eval_pf p (nat_of_bools bs # nats_of_boolss n bss) \\<and>\n       length bs = length bss + k", "apply (erule exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. eval_pf p (x # nats_of_boolss n bss) \\<Longrightarrow>\n    \\<exists>k bs.\n       eval_pf p (nat_of_bools bs # nats_of_boolss n bss) \\<and>\n       length bs = length bss + k", "apply (erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       eval_pf p (x # nats_of_boolss n bss) \\<Longrightarrow>\n       \\<exists>k bs.\n          eval_pf p (nat_of_bools bs # nats_of_boolss n bss) \\<and>\n          length bs = length bss + k", "apply (rule_tac x=\"length (bools_of_nat (length bss) x) - length bss\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       eval_pf p (x # nats_of_boolss n bss) \\<Longrightarrow>\n       \\<exists>bs.\n          eval_pf p (nat_of_bools bs # nats_of_boolss n bss) \\<and>\n          length bs =\n          length bss + (length (bools_of_nat (length bss) x) - length bss)", "apply (rule_tac x=\"bools_of_nat (length bss) x\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       eval_pf p (x # nats_of_boolss n bss) \\<Longrightarrow>\n       eval_pf p\n        (nat_of_bools (bools_of_nat (length bss) x) #\n         nats_of_boolss n bss) \\<and>\n       length (bools_of_nat (length bss) x) =\n       length bss + (length (bools_of_nat (length bss) x) - length bss)", "apply (simp add: bools_of_nat_inverse bools_of_nat_length)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<exists>k bs.\n      eval_pf p (nat_of_bools bs # nats_of_boolss n bss) \\<and>\n      length bs = length bss + k) =\n  (\\<exists>x. eval_pf p (x # nats_of_boolss n bss))\n\ngoal (2 subgoals):\n 1. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 2. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)", "with Exist"], ["proof (chain)\npicking this:\n  list_all (is_alph (Suc n)) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf (Suc n) p) ?bss =\n  eval_pf p (nats_of_boolss (Suc n) ?bss)\n  list_all (is_alph n) bss\n  (\\<exists>k bs.\n      eval_pf p (nat_of_bools bs # nats_of_boolss n bss) \\<and>\n      length bs = length bss + k) =\n  (\\<exists>x. eval_pf p (x # nats_of_boolss n bss))", "show ?case"], ["proof (prove)\nusing this:\n  list_all (is_alph (Suc n)) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf (Suc n) p) ?bss =\n  eval_pf p (nats_of_boolss (Suc n) ?bss)\n  list_all (is_alph n) bss\n  (\\<exists>k bs.\n      eval_pf p (nat_of_bools bs # nats_of_boolss n bss) \\<and>\n      length bs = length bss + k) =\n  (\\<exists>x. eval_pf p (x # nats_of_boolss n bss))\n\ngoal (1 subgoal):\n 1. dfa_accepts (dfa_of_pf n (Exist p)) bss =\n    eval_pf (Exist p) (nats_of_boolss n bss)", "by (simp add:\n    rquot_accepts det_wf_nfa quantify_nfa_well_formed_aut dfa2wf_nfa\n    det_nfa_accepts [of _ n] zeros_is_alpha nfa_accepts_quantify_nfa [of _ n]\n    nfa_of_dfa_accepts [of _ \"Suc n\"] insertll_len2 nats_of_boolss_insertll\n    zeros_len nats_of_boolss_append nats_of_boolss_zeros zip_replicate_mapr\n    nats_of_boolss_length o_def insertl_0_eq\n    dfa_of_pf_well_formed cong: rev_conj_cong)"], ["proof (state)\nthis:\n  dfa_accepts (dfa_of_pf n (Exist p)) bss =\n  eval_pf (Exist p) (nats_of_boolss n bss)\n\ngoal (1 subgoal):\n 1. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)", "case (Forall n p)"], ["proof (state)\nthis:\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf n (Neg (Exist (Neg p)))) ?bss =\n  eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n ?bss)\n  list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)", "then"], ["proof (chain)\npicking this:\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf n (Neg (Exist (Neg p)))) ?bss =\n  eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n ?bss)\n  list_all (is_alph n) bss", "show ?case"], ["proof (prove)\nusing this:\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf n (Neg (Exist (Neg p)))) ?bss =\n  eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n ?bss)\n  list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. dfa_accepts (dfa_of_pf n (Forall p)) bss =\n    eval_pf (Forall p) (nats_of_boolss n bss)", "by simp"], ["proof (state)\nthis:\n  dfa_accepts (dfa_of_pf n (Forall p)) bss =\n  eval_pf (Forall p) (nats_of_boolss n bss)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The same with minimization after quantification.\\<close>"], ["", "function dfa_of_pf' :: \"nat \\<Rightarrow> pf \\<Rightarrow> dfa\"\nwhere\n  \"dfa_of_pf' n (Eq ks l) = eq_dfa n ks l\"\n| \"dfa_of_pf' n (Le ks l) = ineq_dfa n ks l\"\n| \"dfa_of_pf' n (And p q) = and_dfa (dfa_of_pf' n p) (dfa_of_pf' n q)\"\n| \"dfa_of_pf' n (Or p q) = or_dfa (dfa_of_pf' n p) (dfa_of_pf' n q)\"\n| \"dfa_of_pf' n (Imp p q) = imp_dfa (dfa_of_pf' n p) (dfa_of_pf' n q)\"\n| \"dfa_of_pf' n (Exist p) = min_dfa (rquot (det_nfa (quantify_nfa 0 (nfa_of_dfa (dfa_of_pf' (Suc n) p)))) n)\"\n| \"dfa_of_pf' n (Forall p) = dfa_of_pf' n (Neg (Exist (Neg p)))\"\n| \"dfa_of_pf' n (Neg p) = negate_dfa (dfa_of_pf' n p)\""], ["proof (prove)\ngoal (37 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>n ks l. x = (n, Eq ks l) \\<Longrightarrow> P;\n        \\<And>n ks l. x = (n, Le ks l) \\<Longrightarrow> P;\n        \\<And>n p q. x = (n, And p q) \\<Longrightarrow> P;\n        \\<And>n p q. x = (n, Or p q) \\<Longrightarrow> P;\n        \\<And>n p q. x = (n, Imp p q) \\<Longrightarrow> P;\n        \\<And>n p. x = (n, Exist p) \\<Longrightarrow> P;\n        \\<And>n p. x = (n, Forall p) \\<Longrightarrow> P;\n        \\<And>n p. x = (n, Neg p) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>n ks l na ksa la.\n       (n, Eq ks l) = (na, Eq ksa la) \\<Longrightarrow>\n       eq_dfa n ks l = eq_dfa na ksa la\n 3. \\<And>n ks l na ksa la.\n       (n, Eq ks l) = (na, Le ksa la) \\<Longrightarrow>\n       eq_dfa n ks l = ineq_dfa na ksa la\n 4. \\<And>n ks l na p q.\n       (n, Eq ks l) = (na, And p q) \\<Longrightarrow>\n       eq_dfa n ks l =\n       and_dfa (dfa_of_pf'_sumC (na, p)) (dfa_of_pf'_sumC (na, q))\n 5. \\<And>n ks l na p q.\n       (n, Eq ks l) = (na, Or p q) \\<Longrightarrow>\n       eq_dfa n ks l =\n       or_dfa (dfa_of_pf'_sumC (na, p)) (dfa_of_pf'_sumC (na, q))\n 6. \\<And>n ks l na p q.\n       (n, Eq ks l) = (na, Imp p q) \\<Longrightarrow>\n       eq_dfa n ks l =\n       imp_dfa (dfa_of_pf'_sumC (na, p)) (dfa_of_pf'_sumC (na, q))\n 7. \\<And>n ks l na p.\n       (n, Eq ks l) = (na, Exist p) \\<Longrightarrow>\n       eq_dfa n ks l =\n       min_dfa\n        (rquot\n          (det_nfa\n            (quantify_nfa 0 (nfa_of_dfa (dfa_of_pf'_sumC (Suc na, p)))))\n          na)\n 8. \\<And>n ks l na p.\n       (n, Eq ks l) = (na, Forall p) \\<Longrightarrow>\n       eq_dfa n ks l = dfa_of_pf'_sumC (na, Neg (Exist (Neg p)))\n 9. \\<And>n ks l na p.\n       (n, Eq ks l) = (na, Neg p) \\<Longrightarrow>\n       eq_dfa n ks l = negate_dfa (dfa_of_pf'_sumC (na, p))\n 10. \\<And>n ks l na ksa la.\n        (n, Le ks l) = (na, Le ksa la) \\<Longrightarrow>\n        ineq_dfa n ks l = ineq_dfa na ksa la\nA total of 37 subgoals...", "by pat_completeness auto"], ["", "termination dfa_of_pf'"], ["proof (prove)\ngoal (1 subgoal):\n 1. All dfa_of_pf'_dom", "by (relation \"measures [\\<lambda>(n, pf). count_forall pf, \\<lambda>(n, pf). size pf]\") auto"], ["", "lemmas dfa_of_pf'_induct =\n  dfa_of_pf'.induct [case_names Eq Le And Or Imp Exist Forall Neg]"], ["", "lemma dfa_of_pf'_well_formed: \"wf_dfa (dfa_of_pf' n p) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_dfa (dfa_of_pf' n p) n", "proof (induct n p rule: dfa_of_pf'_induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>n ks l. wf_dfa (dfa_of_pf' n (Eq ks l)) n\n 2. \\<And>n ks l. wf_dfa (dfa_of_pf' n (Le ks l)) n\n 3. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf' n p) n;\n        wf_dfa (dfa_of_pf' n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf' n (And p q)) n\n 4. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf' n p) n;\n        wf_dfa (dfa_of_pf' n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf' n (Or p q)) n\n 5. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf' n p) n;\n        wf_dfa (dfa_of_pf' n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf' n (Imp p q)) n\n 6. \\<And>n p.\n       wf_dfa (dfa_of_pf' (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Exist p)) n\n 7. \\<And>n p.\n       wf_dfa (dfa_of_pf' n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Forall p)) n\n 8. \\<And>n p.\n       wf_dfa (dfa_of_pf' n p) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Neg p)) n", "case (Eq n ks l)"], ["proof (state)\nthis:\n  \n\ngoal (8 subgoals):\n 1. \\<And>n ks l. wf_dfa (dfa_of_pf' n (Eq ks l)) n\n 2. \\<And>n ks l. wf_dfa (dfa_of_pf' n (Le ks l)) n\n 3. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf' n p) n;\n        wf_dfa (dfa_of_pf' n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf' n (And p q)) n\n 4. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf' n p) n;\n        wf_dfa (dfa_of_pf' n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf' n (Or p q)) n\n 5. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf' n p) n;\n        wf_dfa (dfa_of_pf' n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf' n (Imp p q)) n\n 6. \\<And>n p.\n       wf_dfa (dfa_of_pf' (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Exist p)) n\n 7. \\<And>n p.\n       wf_dfa (dfa_of_pf' n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Forall p)) n\n 8. \\<And>n p.\n       wf_dfa (dfa_of_pf' n p) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Neg p)) n", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_dfa (dfa_of_pf' n (Eq ks l)) n", "by (simp add: eq_wf_dfa)"], ["proof (state)\nthis:\n  wf_dfa (dfa_of_pf' n (Eq ks l)) n\n\ngoal (7 subgoals):\n 1. \\<And>n ks l. wf_dfa (dfa_of_pf' n (Le ks l)) n\n 2. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf' n p) n;\n        wf_dfa (dfa_of_pf' n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf' n (And p q)) n\n 3. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf' n p) n;\n        wf_dfa (dfa_of_pf' n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf' n (Or p q)) n\n 4. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf' n p) n;\n        wf_dfa (dfa_of_pf' n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf' n (Imp p q)) n\n 5. \\<And>n p.\n       wf_dfa (dfa_of_pf' (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Exist p)) n\n 6. \\<And>n p.\n       wf_dfa (dfa_of_pf' n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Forall p)) n\n 7. \\<And>n p.\n       wf_dfa (dfa_of_pf' n p) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Neg p)) n", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>n ks l. wf_dfa (dfa_of_pf' n (Le ks l)) n\n 2. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf' n p) n;\n        wf_dfa (dfa_of_pf' n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf' n (And p q)) n\n 3. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf' n p) n;\n        wf_dfa (dfa_of_pf' n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf' n (Or p q)) n\n 4. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf' n p) n;\n        wf_dfa (dfa_of_pf' n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf' n (Imp p q)) n\n 5. \\<And>n p.\n       wf_dfa (dfa_of_pf' (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Exist p)) n\n 6. \\<And>n p.\n       wf_dfa (dfa_of_pf' n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Forall p)) n\n 7. \\<And>n p.\n       wf_dfa (dfa_of_pf' n p) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Neg p)) n", "case (Le n ks l)"], ["proof (state)\nthis:\n  \n\ngoal (7 subgoals):\n 1. \\<And>n ks l. wf_dfa (dfa_of_pf' n (Le ks l)) n\n 2. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf' n p) n;\n        wf_dfa (dfa_of_pf' n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf' n (And p q)) n\n 3. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf' n p) n;\n        wf_dfa (dfa_of_pf' n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf' n (Or p q)) n\n 4. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf' n p) n;\n        wf_dfa (dfa_of_pf' n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf' n (Imp p q)) n\n 5. \\<And>n p.\n       wf_dfa (dfa_of_pf' (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Exist p)) n\n 6. \\<And>n p.\n       wf_dfa (dfa_of_pf' n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Forall p)) n\n 7. \\<And>n p.\n       wf_dfa (dfa_of_pf' n p) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Neg p)) n", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_dfa (dfa_of_pf' n (Le ks l)) n", "by (simp add: ineq_wf_dfa)"], ["proof (state)\nthis:\n  wf_dfa (dfa_of_pf' n (Le ks l)) n\n\ngoal (6 subgoals):\n 1. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf' n p) n;\n        wf_dfa (dfa_of_pf' n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf' n (And p q)) n\n 2. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf' n p) n;\n        wf_dfa (dfa_of_pf' n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf' n (Or p q)) n\n 3. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf' n p) n;\n        wf_dfa (dfa_of_pf' n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf' n (Imp p q)) n\n 4. \\<And>n p.\n       wf_dfa (dfa_of_pf' (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Exist p)) n\n 5. \\<And>n p.\n       wf_dfa (dfa_of_pf' n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Forall p)) n\n 6. \\<And>n p.\n       wf_dfa (dfa_of_pf' n p) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Neg p)) n", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf' n p) n;\n        wf_dfa (dfa_of_pf' n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf' n (And p q)) n\n 2. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf' n p) n;\n        wf_dfa (dfa_of_pf' n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf' n (Or p q)) n\n 3. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf' n p) n;\n        wf_dfa (dfa_of_pf' n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf' n (Imp p q)) n\n 4. \\<And>n p.\n       wf_dfa (dfa_of_pf' (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Exist p)) n\n 5. \\<And>n p.\n       wf_dfa (dfa_of_pf' n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Forall p)) n\n 6. \\<And>n p.\n       wf_dfa (dfa_of_pf' n p) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Neg p)) n", "case (And n p q)"], ["proof (state)\nthis:\n  wf_dfa (dfa_of_pf' n p) n\n  wf_dfa (dfa_of_pf' n q) n\n\ngoal (6 subgoals):\n 1. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf' n p) n;\n        wf_dfa (dfa_of_pf' n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf' n (And p q)) n\n 2. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf' n p) n;\n        wf_dfa (dfa_of_pf' n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf' n (Or p q)) n\n 3. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf' n p) n;\n        wf_dfa (dfa_of_pf' n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf' n (Imp p q)) n\n 4. \\<And>n p.\n       wf_dfa (dfa_of_pf' (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Exist p)) n\n 5. \\<And>n p.\n       wf_dfa (dfa_of_pf' n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Forall p)) n\n 6. \\<And>n p.\n       wf_dfa (dfa_of_pf' n p) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Neg p)) n", "then"], ["proof (chain)\npicking this:\n  wf_dfa (dfa_of_pf' n p) n\n  wf_dfa (dfa_of_pf' n q) n", "show ?case"], ["proof (prove)\nusing this:\n  wf_dfa (dfa_of_pf' n p) n\n  wf_dfa (dfa_of_pf' n q) n\n\ngoal (1 subgoal):\n 1. wf_dfa (dfa_of_pf' n (And p q)) n", "by (simp add: and_wf_dfa)"], ["proof (state)\nthis:\n  wf_dfa (dfa_of_pf' n (And p q)) n\n\ngoal (5 subgoals):\n 1. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf' n p) n;\n        wf_dfa (dfa_of_pf' n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf' n (Or p q)) n\n 2. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf' n p) n;\n        wf_dfa (dfa_of_pf' n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf' n (Imp p q)) n\n 3. \\<And>n p.\n       wf_dfa (dfa_of_pf' (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Exist p)) n\n 4. \\<And>n p.\n       wf_dfa (dfa_of_pf' n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Forall p)) n\n 5. \\<And>n p.\n       wf_dfa (dfa_of_pf' n p) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Neg p)) n", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf' n p) n;\n        wf_dfa (dfa_of_pf' n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf' n (Or p q)) n\n 2. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf' n p) n;\n        wf_dfa (dfa_of_pf' n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf' n (Imp p q)) n\n 3. \\<And>n p.\n       wf_dfa (dfa_of_pf' (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Exist p)) n\n 4. \\<And>n p.\n       wf_dfa (dfa_of_pf' n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Forall p)) n\n 5. \\<And>n p.\n       wf_dfa (dfa_of_pf' n p) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Neg p)) n", "case (Or n p q)"], ["proof (state)\nthis:\n  wf_dfa (dfa_of_pf' n p) n\n  wf_dfa (dfa_of_pf' n q) n\n\ngoal (5 subgoals):\n 1. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf' n p) n;\n        wf_dfa (dfa_of_pf' n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf' n (Or p q)) n\n 2. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf' n p) n;\n        wf_dfa (dfa_of_pf' n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf' n (Imp p q)) n\n 3. \\<And>n p.\n       wf_dfa (dfa_of_pf' (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Exist p)) n\n 4. \\<And>n p.\n       wf_dfa (dfa_of_pf' n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Forall p)) n\n 5. \\<And>n p.\n       wf_dfa (dfa_of_pf' n p) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Neg p)) n", "then"], ["proof (chain)\npicking this:\n  wf_dfa (dfa_of_pf' n p) n\n  wf_dfa (dfa_of_pf' n q) n", "show ?case"], ["proof (prove)\nusing this:\n  wf_dfa (dfa_of_pf' n p) n\n  wf_dfa (dfa_of_pf' n q) n\n\ngoal (1 subgoal):\n 1. wf_dfa (dfa_of_pf' n (Or p q)) n", "by (simp add: or_wf_dfa)"], ["proof (state)\nthis:\n  wf_dfa (dfa_of_pf' n (Or p q)) n\n\ngoal (4 subgoals):\n 1. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf' n p) n;\n        wf_dfa (dfa_of_pf' n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf' n (Imp p q)) n\n 2. \\<And>n p.\n       wf_dfa (dfa_of_pf' (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Exist p)) n\n 3. \\<And>n p.\n       wf_dfa (dfa_of_pf' n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Forall p)) n\n 4. \\<And>n p.\n       wf_dfa (dfa_of_pf' n p) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Neg p)) n", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf' n p) n;\n        wf_dfa (dfa_of_pf' n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf' n (Imp p q)) n\n 2. \\<And>n p.\n       wf_dfa (dfa_of_pf' (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Exist p)) n\n 3. \\<And>n p.\n       wf_dfa (dfa_of_pf' n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Forall p)) n\n 4. \\<And>n p.\n       wf_dfa (dfa_of_pf' n p) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Neg p)) n", "case (Imp n p q)"], ["proof (state)\nthis:\n  wf_dfa (dfa_of_pf' n p) n\n  wf_dfa (dfa_of_pf' n q) n\n\ngoal (4 subgoals):\n 1. \\<And>n p q.\n       \\<lbrakk>wf_dfa (dfa_of_pf' n p) n;\n        wf_dfa (dfa_of_pf' n q) n\\<rbrakk>\n       \\<Longrightarrow> wf_dfa (dfa_of_pf' n (Imp p q)) n\n 2. \\<And>n p.\n       wf_dfa (dfa_of_pf' (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Exist p)) n\n 3. \\<And>n p.\n       wf_dfa (dfa_of_pf' n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Forall p)) n\n 4. \\<And>n p.\n       wf_dfa (dfa_of_pf' n p) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Neg p)) n", "then"], ["proof (chain)\npicking this:\n  wf_dfa (dfa_of_pf' n p) n\n  wf_dfa (dfa_of_pf' n q) n", "show ?case"], ["proof (prove)\nusing this:\n  wf_dfa (dfa_of_pf' n p) n\n  wf_dfa (dfa_of_pf' n q) n\n\ngoal (1 subgoal):\n 1. wf_dfa (dfa_of_pf' n (Imp p q)) n", "by (simp add: imp_wf_dfa)"], ["proof (state)\nthis:\n  wf_dfa (dfa_of_pf' n (Imp p q)) n\n\ngoal (3 subgoals):\n 1. \\<And>n p.\n       wf_dfa (dfa_of_pf' (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Exist p)) n\n 2. \\<And>n p.\n       wf_dfa (dfa_of_pf' n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Forall p)) n\n 3. \\<And>n p.\n       wf_dfa (dfa_of_pf' n p) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Neg p)) n", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n p.\n       wf_dfa (dfa_of_pf' (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Exist p)) n\n 2. \\<And>n p.\n       wf_dfa (dfa_of_pf' n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Forall p)) n\n 3. \\<And>n p.\n       wf_dfa (dfa_of_pf' n p) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Neg p)) n", "case (Neg n p)"], ["proof (state)\nthis:\n  wf_dfa (dfa_of_pf' n p) n\n\ngoal (3 subgoals):\n 1. \\<And>n p.\n       wf_dfa (dfa_of_pf' (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Exist p)) n\n 2. \\<And>n p.\n       wf_dfa (dfa_of_pf' n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Forall p)) n\n 3. \\<And>n p.\n       wf_dfa (dfa_of_pf' n p) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Neg p)) n", "then"], ["proof (chain)\npicking this:\n  wf_dfa (dfa_of_pf' n p) n", "show ?case"], ["proof (prove)\nusing this:\n  wf_dfa (dfa_of_pf' n p) n\n\ngoal (1 subgoal):\n 1. wf_dfa (dfa_of_pf' n (Neg p)) n", "by (simp add: negate_wf_dfa)"], ["proof (state)\nthis:\n  wf_dfa (dfa_of_pf' n (Neg p)) n\n\ngoal (2 subgoals):\n 1. \\<And>n p.\n       wf_dfa (dfa_of_pf' (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Exist p)) n\n 2. \\<And>n p.\n       wf_dfa (dfa_of_pf' n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Forall p)) n", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n p.\n       wf_dfa (dfa_of_pf' (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Exist p)) n\n 2. \\<And>n p.\n       wf_dfa (dfa_of_pf' n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Forall p)) n", "case (Exist n p)"], ["proof (state)\nthis:\n  wf_dfa (dfa_of_pf' (Suc n) p) (Suc n)\n\ngoal (2 subgoals):\n 1. \\<And>n p.\n       wf_dfa (dfa_of_pf' (Suc n) p) (Suc n) \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Exist p)) n\n 2. \\<And>n p.\n       wf_dfa (dfa_of_pf' n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Forall p)) n", "then"], ["proof (chain)\npicking this:\n  wf_dfa (dfa_of_pf' (Suc n) p) (Suc n)", "show ?case"], ["proof (prove)\nusing this:\n  wf_dfa (dfa_of_pf' (Suc n) p) (Suc n)\n\ngoal (1 subgoal):\n 1. wf_dfa (dfa_of_pf' n (Exist p)) n", "by (simp add: rquot_well_formed_aut det_wf_nfa quantify_nfa_well_formed_aut dfa2wf_nfa min_dfa_wf)"], ["proof (state)\nthis:\n  wf_dfa (dfa_of_pf' n (Exist p)) n\n\ngoal (1 subgoal):\n 1. \\<And>n p.\n       wf_dfa (dfa_of_pf' n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Forall p)) n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n p.\n       wf_dfa (dfa_of_pf' n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Forall p)) n", "case (Forall n p)"], ["proof (state)\nthis:\n  wf_dfa (dfa_of_pf' n (Neg (Exist (Neg p)))) n\n\ngoal (1 subgoal):\n 1. \\<And>n p.\n       wf_dfa (dfa_of_pf' n (Neg (Exist (Neg p)))) n \\<Longrightarrow>\n       wf_dfa (dfa_of_pf' n (Forall p)) n", "then"], ["proof (chain)\npicking this:\n  wf_dfa (dfa_of_pf' n (Neg (Exist (Neg p)))) n", "show ?case"], ["proof (prove)\nusing this:\n  wf_dfa (dfa_of_pf' n (Neg (Exist (Neg p)))) n\n\ngoal (1 subgoal):\n 1. wf_dfa (dfa_of_pf' n (Forall p)) n", "by simp"], ["proof (state)\nthis:\n  wf_dfa (dfa_of_pf' n (Forall p)) n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dfa_of_pf'_correctness:\n  \"list_all (is_alph n) bss \\<Longrightarrow>\n     dfa_accepts (dfa_of_pf' n p) bss = eval_pf p (nats_of_boolss n bss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (is_alph n) bss \\<Longrightarrow>\n    dfa_accepts (dfa_of_pf' n p) bss = eval_pf p (nats_of_boolss n bss)", "proof (induct n p arbitrary: bss rule: dfa_of_pf'_induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>n ks l bss.\n       list_all (is_alph n) bss \\<Longrightarrow>\n       dfa_accepts (dfa_of_pf' n (Eq ks l)) bss =\n       eval_pf (Eq ks l) (nats_of_boolss n bss)\n 2. \\<And>n ks l bss.\n       list_all (is_alph n) bss \\<Longrightarrow>\n       dfa_accepts (dfa_of_pf' n (Le ks l)) bss =\n       eval_pf (Le ks l) (nats_of_boolss n bss)\n 3. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf' n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (And p q)) bss =\n                         eval_pf (And p q) (nats_of_boolss n bss)\n 4. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf' n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Or p q)) bss =\n                         eval_pf (Or p q) (nats_of_boolss n bss)\n 5. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf' n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Imp p q)) bss =\n                         eval_pf (Imp p q) (nats_of_boolss n bss)\n 6. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 7. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)\n 8. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Neg p)) bss =\n                         eval_pf (Neg p) (nats_of_boolss n bss)", "case (Eq n ks l)"], ["proof (state)\nthis:\n  list_all (is_alph n) bss\n\ngoal (8 subgoals):\n 1. \\<And>n ks l bss.\n       list_all (is_alph n) bss \\<Longrightarrow>\n       dfa_accepts (dfa_of_pf' n (Eq ks l)) bss =\n       eval_pf (Eq ks l) (nats_of_boolss n bss)\n 2. \\<And>n ks l bss.\n       list_all (is_alph n) bss \\<Longrightarrow>\n       dfa_accepts (dfa_of_pf' n (Le ks l)) bss =\n       eval_pf (Le ks l) (nats_of_boolss n bss)\n 3. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf' n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (And p q)) bss =\n                         eval_pf (And p q) (nats_of_boolss n bss)\n 4. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf' n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Or p q)) bss =\n                         eval_pf (Or p q) (nats_of_boolss n bss)\n 5. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf' n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Imp p q)) bss =\n                         eval_pf (Imp p q) (nats_of_boolss n bss)\n 6. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 7. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)\n 8. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Neg p)) bss =\n                         eval_pf (Neg p) (nats_of_boolss n bss)", "then"], ["proof (chain)\npicking this:\n  list_all (is_alph n) bss", "show ?case"], ["proof (prove)\nusing this:\n  list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. dfa_accepts (dfa_of_pf' n (Eq ks l)) bss =\n    eval_pf (Eq ks l) (nats_of_boolss n bss)", "by (simp add: eq_dfa_accepts)"], ["proof (state)\nthis:\n  dfa_accepts (dfa_of_pf' n (Eq ks l)) bss =\n  eval_pf (Eq ks l) (nats_of_boolss n bss)\n\ngoal (7 subgoals):\n 1. \\<And>n ks l bss.\n       list_all (is_alph n) bss \\<Longrightarrow>\n       dfa_accepts (dfa_of_pf' n (Le ks l)) bss =\n       eval_pf (Le ks l) (nats_of_boolss n bss)\n 2. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf' n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (And p q)) bss =\n                         eval_pf (And p q) (nats_of_boolss n bss)\n 3. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf' n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Or p q)) bss =\n                         eval_pf (Or p q) (nats_of_boolss n bss)\n 4. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf' n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Imp p q)) bss =\n                         eval_pf (Imp p q) (nats_of_boolss n bss)\n 5. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 6. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)\n 7. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Neg p)) bss =\n                         eval_pf (Neg p) (nats_of_boolss n bss)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>n ks l bss.\n       list_all (is_alph n) bss \\<Longrightarrow>\n       dfa_accepts (dfa_of_pf' n (Le ks l)) bss =\n       eval_pf (Le ks l) (nats_of_boolss n bss)\n 2. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf' n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (And p q)) bss =\n                         eval_pf (And p q) (nats_of_boolss n bss)\n 3. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf' n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Or p q)) bss =\n                         eval_pf (Or p q) (nats_of_boolss n bss)\n 4. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf' n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Imp p q)) bss =\n                         eval_pf (Imp p q) (nats_of_boolss n bss)\n 5. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 6. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)\n 7. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Neg p)) bss =\n                         eval_pf (Neg p) (nats_of_boolss n bss)", "case (Le n ks l)"], ["proof (state)\nthis:\n  list_all (is_alph n) bss\n\ngoal (7 subgoals):\n 1. \\<And>n ks l bss.\n       list_all (is_alph n) bss \\<Longrightarrow>\n       dfa_accepts (dfa_of_pf' n (Le ks l)) bss =\n       eval_pf (Le ks l) (nats_of_boolss n bss)\n 2. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf' n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (And p q)) bss =\n                         eval_pf (And p q) (nats_of_boolss n bss)\n 3. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf' n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Or p q)) bss =\n                         eval_pf (Or p q) (nats_of_boolss n bss)\n 4. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf' n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Imp p q)) bss =\n                         eval_pf (Imp p q) (nats_of_boolss n bss)\n 5. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 6. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)\n 7. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Neg p)) bss =\n                         eval_pf (Neg p) (nats_of_boolss n bss)", "then"], ["proof (chain)\npicking this:\n  list_all (is_alph n) bss", "show ?case"], ["proof (prove)\nusing this:\n  list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. dfa_accepts (dfa_of_pf' n (Le ks l)) bss =\n    eval_pf (Le ks l) (nats_of_boolss n bss)", "by (simp add: ineq_dfa_accepts)"], ["proof (state)\nthis:\n  dfa_accepts (dfa_of_pf' n (Le ks l)) bss =\n  eval_pf (Le ks l) (nats_of_boolss n bss)\n\ngoal (6 subgoals):\n 1. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf' n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (And p q)) bss =\n                         eval_pf (And p q) (nats_of_boolss n bss)\n 2. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf' n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Or p q)) bss =\n                         eval_pf (Or p q) (nats_of_boolss n bss)\n 3. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf' n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Imp p q)) bss =\n                         eval_pf (Imp p q) (nats_of_boolss n bss)\n 4. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 5. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)\n 6. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Neg p)) bss =\n                         eval_pf (Neg p) (nats_of_boolss n bss)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf' n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (And p q)) bss =\n                         eval_pf (And p q) (nats_of_boolss n bss)\n 2. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf' n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Or p q)) bss =\n                         eval_pf (Or p q) (nats_of_boolss n bss)\n 3. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf' n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Imp p q)) bss =\n                         eval_pf (Imp p q) (nats_of_boolss n bss)\n 4. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 5. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)\n 6. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Neg p)) bss =\n                         eval_pf (Neg p) (nats_of_boolss n bss)", "case (And n p q)"], ["proof (state)\nthis:\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf' n p) ?bss = eval_pf p (nats_of_boolss n ?bss)\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf' n q) ?bss = eval_pf q (nats_of_boolss n ?bss)\n  list_all (is_alph n) bss\n\ngoal (6 subgoals):\n 1. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf' n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (And p q)) bss =\n                         eval_pf (And p q) (nats_of_boolss n bss)\n 2. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf' n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Or p q)) bss =\n                         eval_pf (Or p q) (nats_of_boolss n bss)\n 3. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf' n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Imp p q)) bss =\n                         eval_pf (Imp p q) (nats_of_boolss n bss)\n 4. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 5. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)\n 6. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Neg p)) bss =\n                         eval_pf (Neg p) (nats_of_boolss n bss)", "then"], ["proof (chain)\npicking this:\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf' n p) ?bss = eval_pf p (nats_of_boolss n ?bss)\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf' n q) ?bss = eval_pf q (nats_of_boolss n ?bss)\n  list_all (is_alph n) bss", "show ?case"], ["proof (prove)\nusing this:\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf' n p) ?bss = eval_pf p (nats_of_boolss n ?bss)\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf' n q) ?bss = eval_pf q (nats_of_boolss n ?bss)\n  list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. dfa_accepts (dfa_of_pf' n (And p q)) bss =\n    eval_pf (And p q) (nats_of_boolss n bss)", "by (simp add: and_dfa_accepts [of _ n] dfa_of_pf'_well_formed)"], ["proof (state)\nthis:\n  dfa_accepts (dfa_of_pf' n (And p q)) bss =\n  eval_pf (And p q) (nats_of_boolss n bss)\n\ngoal (5 subgoals):\n 1. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf' n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Or p q)) bss =\n                         eval_pf (Or p q) (nats_of_boolss n bss)\n 2. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf' n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Imp p q)) bss =\n                         eval_pf (Imp p q) (nats_of_boolss n bss)\n 3. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 4. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)\n 5. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Neg p)) bss =\n                         eval_pf (Neg p) (nats_of_boolss n bss)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf' n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Or p q)) bss =\n                         eval_pf (Or p q) (nats_of_boolss n bss)\n 2. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf' n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Imp p q)) bss =\n                         eval_pf (Imp p q) (nats_of_boolss n bss)\n 3. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 4. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)\n 5. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Neg p)) bss =\n                         eval_pf (Neg p) (nats_of_boolss n bss)", "case (Or n p q)"], ["proof (state)\nthis:\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf' n p) ?bss = eval_pf p (nats_of_boolss n ?bss)\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf' n q) ?bss = eval_pf q (nats_of_boolss n ?bss)\n  list_all (is_alph n) bss\n\ngoal (5 subgoals):\n 1. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf' n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Or p q)) bss =\n                         eval_pf (Or p q) (nats_of_boolss n bss)\n 2. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf' n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Imp p q)) bss =\n                         eval_pf (Imp p q) (nats_of_boolss n bss)\n 3. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 4. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)\n 5. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Neg p)) bss =\n                         eval_pf (Neg p) (nats_of_boolss n bss)", "then"], ["proof (chain)\npicking this:\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf' n p) ?bss = eval_pf p (nats_of_boolss n ?bss)\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf' n q) ?bss = eval_pf q (nats_of_boolss n ?bss)\n  list_all (is_alph n) bss", "show ?case"], ["proof (prove)\nusing this:\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf' n p) ?bss = eval_pf p (nats_of_boolss n ?bss)\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf' n q) ?bss = eval_pf q (nats_of_boolss n ?bss)\n  list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. dfa_accepts (dfa_of_pf' n (Or p q)) bss =\n    eval_pf (Or p q) (nats_of_boolss n bss)", "by (simp add: or_dfa_accepts [of _ n] dfa_of_pf'_well_formed)"], ["proof (state)\nthis:\n  dfa_accepts (dfa_of_pf' n (Or p q)) bss =\n  eval_pf (Or p q) (nats_of_boolss n bss)\n\ngoal (4 subgoals):\n 1. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf' n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Imp p q)) bss =\n                         eval_pf (Imp p q) (nats_of_boolss n bss)\n 2. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 3. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)\n 4. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Neg p)) bss =\n                         eval_pf (Neg p) (nats_of_boolss n bss)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf' n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Imp p q)) bss =\n                         eval_pf (Imp p q) (nats_of_boolss n bss)\n 2. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 3. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)\n 4. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Neg p)) bss =\n                         eval_pf (Neg p) (nats_of_boolss n bss)", "case (Imp n p q)"], ["proof (state)\nthis:\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf' n p) ?bss = eval_pf p (nats_of_boolss n ?bss)\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf' n q) ?bss = eval_pf q (nats_of_boolss n ?bss)\n  list_all (is_alph n) bss\n\ngoal (4 subgoals):\n 1. \\<And>n p q bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        \\<And>bss.\n           list_all (is_alph n) bss \\<Longrightarrow>\n           dfa_accepts (dfa_of_pf' n q) bss =\n           eval_pf q (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Imp p q)) bss =\n                         eval_pf (Imp p q) (nats_of_boolss n bss)\n 2. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 3. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)\n 4. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Neg p)) bss =\n                         eval_pf (Neg p) (nats_of_boolss n bss)", "then"], ["proof (chain)\npicking this:\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf' n p) ?bss = eval_pf p (nats_of_boolss n ?bss)\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf' n q) ?bss = eval_pf q (nats_of_boolss n ?bss)\n  list_all (is_alph n) bss", "show ?case"], ["proof (prove)\nusing this:\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf' n p) ?bss = eval_pf p (nats_of_boolss n ?bss)\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf' n q) ?bss = eval_pf q (nats_of_boolss n ?bss)\n  list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. dfa_accepts (dfa_of_pf' n (Imp p q)) bss =\n    eval_pf (Imp p q) (nats_of_boolss n bss)", "by (simp add: imp_dfa_accepts [of _ n] dfa_of_pf'_well_formed)"], ["proof (state)\nthis:\n  dfa_accepts (dfa_of_pf' n (Imp p q)) bss =\n  eval_pf (Imp p q) (nats_of_boolss n bss)\n\ngoal (3 subgoals):\n 1. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 2. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)\n 3. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Neg p)) bss =\n                         eval_pf (Neg p) (nats_of_boolss n bss)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 2. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)\n 3. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Neg p)) bss =\n                         eval_pf (Neg p) (nats_of_boolss n bss)", "case (Neg n p)"], ["proof (state)\nthis:\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf' n p) ?bss = eval_pf p (nats_of_boolss n ?bss)\n  list_all (is_alph n) bss\n\ngoal (3 subgoals):\n 1. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 2. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)\n 3. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n p) bss =\n                   eval_pf p (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Neg p)) bss =\n                         eval_pf (Neg p) (nats_of_boolss n bss)", "then"], ["proof (chain)\npicking this:\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf' n p) ?bss = eval_pf p (nats_of_boolss n ?bss)\n  list_all (is_alph n) bss", "show ?case"], ["proof (prove)\nusing this:\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf' n p) ?bss = eval_pf p (nats_of_boolss n ?bss)\n  list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. dfa_accepts (dfa_of_pf' n (Neg p)) bss =\n    eval_pf (Neg p) (nats_of_boolss n bss)", "by (simp add: dfa_accepts_negate [of _ n] dfa_of_pf'_well_formed)"], ["proof (state)\nthis:\n  dfa_accepts (dfa_of_pf' n (Neg p)) bss =\n  eval_pf (Neg p) (nats_of_boolss n bss)\n\ngoal (2 subgoals):\n 1. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 2. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 2. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)", "case (Exist n p)"], ["proof (state)\nthis:\n  list_all (is_alph (Suc n)) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf' (Suc n) p) ?bss =\n  eval_pf p (nats_of_boolss (Suc n) ?bss)\n  list_all (is_alph n) bss\n\ngoal (2 subgoals):\n 1. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 2. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)", "have \"(\\<exists>k bs. eval_pf p (nat_of_bools bs # nats_of_boolss n bss) \\<and> length bs = length bss + k) =\n    (\\<exists>x. eval_pf p (x # nats_of_boolss n bss))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>k bs.\n        eval_pf p (nat_of_bools bs # nats_of_boolss n bss) \\<and>\n        length bs = length bss + k) =\n    (\\<exists>x. eval_pf p (x # nats_of_boolss n bss))", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>k bs.\n       eval_pf p (nat_of_bools bs # nats_of_boolss n bss) \\<and>\n       length bs = length bss + k \\<Longrightarrow>\n    \\<exists>x. eval_pf p (x # nats_of_boolss n bss)\n 2. \\<exists>x. eval_pf p (x # nats_of_boolss n bss) \\<Longrightarrow>\n    \\<exists>k bs.\n       eval_pf p (nat_of_bools bs # nats_of_boolss n bss) \\<and>\n       length bs = length bss + k", "apply (erule exE conjE)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k bs.\n       \\<lbrakk>eval_pf p (nat_of_bools bs # nats_of_boolss n bss);\n        length bs = length bss + k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x. eval_pf p (x # nats_of_boolss n bss)\n 2. \\<exists>x. eval_pf p (x # nats_of_boolss n bss) \\<Longrightarrow>\n    \\<exists>k bs.\n       eval_pf p (nat_of_bools bs # nats_of_boolss n bss) \\<and>\n       length bs = length bss + k", "apply (erule exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. eval_pf p (x # nats_of_boolss n bss) \\<Longrightarrow>\n    \\<exists>k bs.\n       eval_pf p (nat_of_bools bs # nats_of_boolss n bss) \\<and>\n       length bs = length bss + k", "apply (erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       eval_pf p (x # nats_of_boolss n bss) \\<Longrightarrow>\n       \\<exists>k bs.\n          eval_pf p (nat_of_bools bs # nats_of_boolss n bss) \\<and>\n          length bs = length bss + k", "apply (rule_tac x=\"length (bools_of_nat (length bss) x) - length bss\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       eval_pf p (x # nats_of_boolss n bss) \\<Longrightarrow>\n       \\<exists>bs.\n          eval_pf p (nat_of_bools bs # nats_of_boolss n bss) \\<and>\n          length bs =\n          length bss + (length (bools_of_nat (length bss) x) - length bss)", "apply (rule_tac x=\"bools_of_nat (length bss) x\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       eval_pf p (x # nats_of_boolss n bss) \\<Longrightarrow>\n       eval_pf p\n        (nat_of_bools (bools_of_nat (length bss) x) #\n         nats_of_boolss n bss) \\<and>\n       length (bools_of_nat (length bss) x) =\n       length bss + (length (bools_of_nat (length bss) x) - length bss)", "apply (simp add: bools_of_nat_inverse bools_of_nat_length)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<exists>k bs.\n      eval_pf p (nat_of_bools bs # nats_of_boolss n bss) \\<and>\n      length bs = length bss + k) =\n  (\\<exists>x. eval_pf p (x # nats_of_boolss n bss))\n\ngoal (2 subgoals):\n 1. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph (Suc n)) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' (Suc n) p) bss =\n                   eval_pf p (nats_of_boolss (Suc n) bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Exist p)) bss =\n                         eval_pf (Exist p) (nats_of_boolss n bss)\n 2. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)", "with Exist"], ["proof (chain)\npicking this:\n  list_all (is_alph (Suc n)) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf' (Suc n) p) ?bss =\n  eval_pf p (nats_of_boolss (Suc n) ?bss)\n  list_all (is_alph n) bss\n  (\\<exists>k bs.\n      eval_pf p (nat_of_bools bs # nats_of_boolss n bss) \\<and>\n      length bs = length bss + k) =\n  (\\<exists>x. eval_pf p (x # nats_of_boolss n bss))", "show ?case"], ["proof (prove)\nusing this:\n  list_all (is_alph (Suc n)) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf' (Suc n) p) ?bss =\n  eval_pf p (nats_of_boolss (Suc n) ?bss)\n  list_all (is_alph n) bss\n  (\\<exists>k bs.\n      eval_pf p (nat_of_bools bs # nats_of_boolss n bss) \\<and>\n      length bs = length bss + k) =\n  (\\<exists>x. eval_pf p (x # nats_of_boolss n bss))\n\ngoal (1 subgoal):\n 1. dfa_accepts (dfa_of_pf' n (Exist p)) bss =\n    eval_pf (Exist p) (nats_of_boolss n bss)", "by (simp add:\n    rquot_accepts det_wf_nfa quantify_nfa_well_formed_aut dfa2wf_nfa\n    det_nfa_accepts [of _ n] zeros_is_alpha nfa_accepts_quantify_nfa [of _ n]\n    nfa_of_dfa_accepts [of _ \"Suc n\"] insertll_len2 nats_of_boolss_insertll\n    zeros_len nats_of_boolss_append nats_of_boolss_zeros zip_replicate_mapr\n    nats_of_boolss_length o_def insertl_0_eq\n    dfa_of_pf'_well_formed min_dfa_accept [of _ n] min_dfa_wf rquot_well_formed_aut\n    cong: rev_conj_cong)"], ["proof (state)\nthis:\n  dfa_accepts (dfa_of_pf' n (Exist p)) bss =\n  eval_pf (Exist p) (nats_of_boolss n bss)\n\ngoal (1 subgoal):\n 1. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)", "case (Forall n p)"], ["proof (state)\nthis:\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf' n (Neg (Exist (Neg p)))) ?bss =\n  eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n ?bss)\n  list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. \\<And>n p bss.\n       \\<lbrakk>\\<And>bss.\n                   list_all (is_alph n) bss \\<Longrightarrow>\n                   dfa_accepts (dfa_of_pf' n (Neg (Exist (Neg p)))) bss =\n                   eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n bss);\n        list_all (is_alph n) bss\\<rbrakk>\n       \\<Longrightarrow> dfa_accepts (dfa_of_pf' n (Forall p)) bss =\n                         eval_pf (Forall p) (nats_of_boolss n bss)", "then"], ["proof (chain)\npicking this:\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf' n (Neg (Exist (Neg p)))) ?bss =\n  eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n ?bss)\n  list_all (is_alph n) bss", "show ?case"], ["proof (prove)\nusing this:\n  list_all (is_alph n) ?bss \\<Longrightarrow>\n  dfa_accepts (dfa_of_pf' n (Neg (Exist (Neg p)))) ?bss =\n  eval_pf (Neg (Exist (Neg p))) (nats_of_boolss n ?bss)\n  list_all (is_alph n) bss\n\ngoal (1 subgoal):\n 1. dfa_accepts (dfa_of_pf' n (Forall p)) bss =\n    eval_pf (Forall p) (nats_of_boolss n bss)", "by simp"], ["proof (state)\nthis:\n  dfa_accepts (dfa_of_pf' n (Forall p)) bss =\n  eval_pf (Forall p) (nats_of_boolss n bss)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}