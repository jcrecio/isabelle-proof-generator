{"file_name": "/home/qj213/afp-2021-10-22/thys/Presburger-Automata/DFS.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Presburger-Automata", "problem_names": ["lemma gen_dfs_simps[simp]:\n  \"gen_dfs succs ins memb S [] = S\"\n  \"gen_dfs succs ins memb S (x # xs) =\n    (if memb x S then gen_dfs succs ins memb S xs\n     else gen_dfs succs ins memb (ins x S) (succs x @ xs))\"", "lemma dfs_induct [consumes 2, case_names base step]:\n  assumes S: \"invariant S\"\n    and xs: \"list_all is_node xs\"\n    and I1: \"\\<And>S. invariant S \\<Longrightarrow> P S []\"\n    and I2: \"\\<And>S x xs. invariant S \\<Longrightarrow> is_node x \\<Longrightarrow> list_all is_node xs \\<Longrightarrow>\n      (memb x S \\<Longrightarrow> P S xs) \\<Longrightarrow> (\\<not> memb x S \\<Longrightarrow> P (ins x S) (succs x @ xs)) \\<Longrightarrow> P S (x # xs)\"\n  shows \"P S xs\"", "lemma visit_subset_dfs: \"invariant S \\<Longrightarrow> list_all is_node xs \\<Longrightarrow>\n    is_node y \\<Longrightarrow> memb y S \\<Longrightarrow> memb y (dfs S xs)\"", "lemma next_subset_dfs: \"invariant S \\<Longrightarrow> list_all is_node xs \\<Longrightarrow>\n    x \\<in> set xs \\<Longrightarrow> memb x (dfs S xs)\"", "lemma succss_closed_dfs':\n  \"invariant ys \\<Longrightarrow> list_all is_node xs \\<Longrightarrow>\n    succss (set_of ys) \\<subseteq> set xs \\<union> set_of ys \\<Longrightarrow>\n    succss (set_of (dfs ys xs)) \\<subseteq> set_of (dfs ys xs)\"", "lemma succss_closed_dfs: \"list_all is_node xs \\<Longrightarrow>\n    succss (set_of (dfs empt xs)) \\<subseteq> set_of (dfs empt xs)\"", "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\"", "lemma reachable_closed_dfs:\n  assumes \"list_all is_node xs\"\n  shows \"reachable (set xs) \\<subseteq> set_of (dfs empt xs)\"", "lemma reachable_succs: \"reachable (set (succs x)) \\<subseteq> reachable {x}\"", "lemma dfs_subset_reachable_visit_nodes:\n  \"invariant ys \\<Longrightarrow> list_all is_node xs \\<Longrightarrow>\n     set_of (dfs ys xs) \\<subseteq> reachable (set xs) \\<union> set_of ys\"", "theorem dfs_eq_reachable:\n  assumes y: \"is_node y\"\n    and xs: \"list_all is_node xs\"\n  shows \"memb y (dfs empt xs) = (y \\<in> reachable (set xs))\"", "theorem dfs_eq_rtrancl:\n  assumes y: \"is_node y\"\n    and x: \"is_node x\"\n  shows \"memb y (dfs empt [x]) = ((x,y) \\<in> (succsr succs)\\<^sup>*)\"", "theorem dfs_invariant [consumes 2, case_names base step]:\n  assumes S: \"invariant S\"\n    and xs: \"list_all is_node xs\"\n    and H: \"I S\"\n    and I: \"\\<And>S x. \\<not> memb x S \\<Longrightarrow> is_node x \\<Longrightarrow> invariant S \\<Longrightarrow> I S \\<Longrightarrow> I (ins x S)\"\n  shows \"I (dfs S xs)\"", "theorem dfs_invariant': \"invariant S \\<Longrightarrow> list_all is_node xs \\<Longrightarrow> invariant (dfs S xs)\"", "theorem succsr_is_node:\n  assumes \"(x, y) \\<in> (succsr succs)\\<^sup>*\"\n  shows \"is_node x \\<Longrightarrow> is_node y\""], "translations": [["", "lemma gen_dfs_simps[simp]:\n  \"gen_dfs succs ins memb S [] = S\"\n  \"gen_dfs succs ins memb S (x # xs) =\n    (if memb x S then gen_dfs succs ins memb S xs\n     else gen_dfs succs ins memb (ins x S) (succs x @ xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_dfs succs ins memb S [] = S &&&\n    gen_dfs succs ins memb S (x # xs) =\n    (if memb x S then gen_dfs succs ins memb S xs\n     else gen_dfs succs ins memb (ins x S) (succs x @ xs))", "by (simp_all add: gen_dfs.simps)"], ["", "locale DFS =\n  fixes succs :: \"'a \\<Rightarrow> 'a list\"\n    and is_node :: \"'a \\<Rightarrow> bool\"\n    and invariant :: \"'b \\<Rightarrow> bool\"\n    and ins :: \"'a \\<Rightarrow> 'b \\<Rightarrow> 'b\"\n    and memb :: \"'a \\<Rightarrow> 'b \\<Rightarrow> bool\"\n    and empt :: 'b\n  assumes ins_eq: \"\\<And>x y S. is_node x \\<Longrightarrow> is_node y \\<Longrightarrow> invariant S \\<Longrightarrow> \\<not> memb y S \\<Longrightarrow>\n      memb x (ins y S) = ((x = y) \\<or> memb x S)\"\n    and empt: \"\\<And>x. is_node x \\<Longrightarrow> \\<not> memb x empt\"\n    and succs_is_node: \"\\<And>x. is_node x \\<Longrightarrow> list_all is_node (succs x)\"\n    and empt_invariant: \"invariant empt\"\n    and ins_invariant: \"\\<And>x S. is_node x \\<Longrightarrow> invariant S \\<Longrightarrow> \\<not> memb x S \\<Longrightarrow> invariant (ins x S)\"\n    and graph_finite: \"finite {x. is_node x}\"\nbegin"], ["", "definition rel where\n  \"rel = inv_image finite_psubset (\\<lambda>S. {n. is_node n \\<and> \\<not> memb n S})\""], ["", "abbreviation \"dfs \\<equiv> gen_dfs succs ins memb\""], ["", "lemma dfs_induct [consumes 2, case_names base step]:\n  assumes S: \"invariant S\"\n    and xs: \"list_all is_node xs\"\n    and I1: \"\\<And>S. invariant S \\<Longrightarrow> P S []\"\n    and I2: \"\\<And>S x xs. invariant S \\<Longrightarrow> is_node x \\<Longrightarrow> list_all is_node xs \\<Longrightarrow>\n      (memb x S \\<Longrightarrow> P S xs) \\<Longrightarrow> (\\<not> memb x S \\<Longrightarrow> P (ins x S) (succs x @ xs)) \\<Longrightarrow> P S (x # xs)\"\n  shows \"P S xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P S xs", "using I1 I2 S xs"], ["proof (prove)\nusing this:\n  invariant ?S \\<Longrightarrow> P ?S []\n  \\<lbrakk>invariant ?S; is_node ?x; list_all is_node ?xs;\n   memb ?x ?S \\<Longrightarrow> P ?S ?xs;\n   \\<not> memb ?x ?S \\<Longrightarrow>\n   P (ins ?x ?S) (succs ?x @ ?xs)\\<rbrakk>\n  \\<Longrightarrow> P ?S (?x # ?xs)\n  invariant S\n  list_all is_node xs\n\ngoal (1 subgoal):\n 1. P S xs", "apply induction_schema"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>P S xs.\n       \\<lbrakk>invariant S; list_all is_node xs;\n        \\<And>Sa__.\n           \\<lbrakk>invariant Sa__; S = Sa__; xs = []\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>Sa__ x__ xsa__.\n           \\<lbrakk>invariant Sa__; is_node x__; list_all is_node xsa__;\n            S = Sa__; xs = x__ # xsa__\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>thesis__ Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; is_node x__; list_all is_node xsa__;\n        \\<not> memb x__ Sa__;\n        \\<lbrakk>invariant (ins x__ Sa__);\n         list_all is_node (succs x__ @ xsa__)\\<rbrakk>\n        \\<Longrightarrow> thesis__\\<rbrakk>\n       \\<Longrightarrow> thesis__\n 3. wf ?R2\n 4. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; is_node x__; list_all is_node xsa__;\n        memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> ((Sa__, xsa__), Sa__, x__ # xsa__) \\<in> ?R2\n 5. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; is_node x__; list_all is_node xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> ((ins x__ Sa__, succs x__ @ xsa__), Sa__,\n                          x__ # xsa__)\n                         \\<in> ?R2", "apply atomize_elim"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>S xs.\n       \\<lbrakk>invariant S; list_all is_node xs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>Sa__.\n                             invariant Sa__ \\<and>\n                             S = Sa__ \\<and> xs = []) \\<or>\n                         (\\<exists>Sa__ x__ xsa__.\n                             invariant Sa__ \\<and>\n                             is_node x__ \\<and>\n                             list_all is_node xsa__ \\<and>\n                             S = Sa__ \\<and> xs = x__ # xsa__)\n 2. \\<And>thesis__ Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; is_node x__; list_all is_node xsa__;\n        \\<not> memb x__ Sa__;\n        \\<lbrakk>invariant (ins x__ Sa__);\n         list_all is_node (succs x__ @ xsa__)\\<rbrakk>\n        \\<Longrightarrow> thesis__\\<rbrakk>\n       \\<Longrightarrow> thesis__\n 3. wf ?R2\n 4. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; is_node x__; list_all is_node xsa__;\n        memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> ((Sa__, xsa__), Sa__, x__ # xsa__) \\<in> ?R2\n 5. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; is_node x__; list_all is_node xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> ((ins x__ Sa__, succs x__ @ xsa__), Sa__,\n                          x__ # xsa__)\n                         \\<in> ?R2", "apply (case_tac xs, simp+)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>thesis__ Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; is_node x__; list_all is_node xsa__;\n        \\<not> memb x__ Sa__;\n        \\<lbrakk>invariant (ins x__ Sa__);\n         list_all is_node (succs x__)\\<rbrakk>\n        \\<Longrightarrow> thesis__\\<rbrakk>\n       \\<Longrightarrow> thesis__\n 2. wf ?R2\n 3. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; is_node x__; list_all is_node xsa__;\n        memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> ((Sa__, xsa__), Sa__, x__ # xsa__) \\<in> ?R2\n 4. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; is_node x__; list_all is_node xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> ((ins x__ Sa__, succs x__ @ xsa__), Sa__,\n                          x__ # xsa__)\n                         \\<in> ?R2", "apply atomize_elim"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; is_node x__; list_all is_node xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> invariant (ins x__ Sa__) \\<and>\n                         list_all is_node (succs x__)\n 2. wf ?R2\n 3. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; is_node x__; list_all is_node xsa__;\n        memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> ((Sa__, xsa__), Sa__, x__ # xsa__) \\<in> ?R2\n 4. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; is_node x__; list_all is_node xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> ((ins x__ Sa__, succs x__ @ xsa__), Sa__,\n                          x__ # xsa__)\n                         \\<in> ?R2", "apply (rule conjI)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; is_node x__; list_all is_node xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> invariant (ins x__ Sa__)\n 2. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; is_node x__; list_all is_node xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> list_all is_node (succs x__)\n 3. wf ?R2\n 4. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; is_node x__; list_all is_node xsa__;\n        memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> ((Sa__, xsa__), Sa__, x__ # xsa__) \\<in> ?R2\n 5. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; is_node x__; list_all is_node xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> ((ins x__ Sa__, succs x__ @ xsa__), Sa__,\n                          x__ # xsa__)\n                         \\<in> ?R2", "apply (rule ins_invariant, assumption+)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; is_node x__; list_all is_node xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> list_all is_node (succs x__)\n 2. wf ?R2\n 3. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; is_node x__; list_all is_node xsa__;\n        memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> ((Sa__, xsa__), Sa__, x__ # xsa__) \\<in> ?R2\n 4. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; is_node x__; list_all is_node xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> ((ins x__ Sa__, succs x__ @ xsa__), Sa__,\n                          x__ # xsa__)\n                         \\<in> ?R2", "apply (rule succs_is_node, assumption)"], ["proof (prove)\ngoal (3 subgoals):\n 1. wf ?R2\n 2. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; is_node x__; list_all is_node xsa__;\n        memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> ((Sa__, xsa__), Sa__, x__ # xsa__) \\<in> ?R2\n 3. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; is_node x__; list_all is_node xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> ((ins x__ Sa__, succs x__ @ xsa__), Sa__,\n                          x__ # xsa__)\n                         \\<in> ?R2", "apply (relation \"rel <*lex*> measure length\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. wf (rel <*lex*> measure length)\n 2. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; is_node x__; list_all is_node xsa__;\n        memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> ((Sa__, xsa__), Sa__, x__ # xsa__)\n                         \\<in> rel <*lex*> measure length\n 3. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; is_node x__; list_all is_node xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> ((ins x__ Sa__, succs x__ @ xsa__), Sa__,\n                          x__ # xsa__)\n                         \\<in> rel <*lex*> measure length", "apply (simp add: wf_lex_prod rel_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; is_node x__; list_all is_node xsa__;\n        memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> ((Sa__, xsa__), Sa__, x__ # xsa__)\n                         \\<in> rel <*lex*> measure length\n 2. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; is_node x__; list_all is_node xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> ((ins x__ Sa__, succs x__ @ xsa__), Sa__,\n                          x__ # xsa__)\n                         \\<in> rel <*lex*> measure length", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; is_node x__; list_all is_node xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> ((ins x__ Sa__, succs x__ @ xsa__), Sa__,\n                          x__ # xsa__)\n                         \\<in> rel <*lex*> measure length", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; is_node x__; list_all is_node xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> (ins x__ Sa__, Sa__) \\<in> rel \\<or>\n                         ins x__ Sa__ = Sa__ \\<and> succs x__ = []", "apply (rule disjI1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; is_node x__; list_all is_node xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> (ins x__ Sa__, Sa__) \\<in> rel", "apply (simp add: rel_def finite_psubset_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; is_node x__; list_all is_node xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> {n. is_node n \\<and> \\<not> memb n (ins x__ Sa__)}\n                         \\<subset> {n. is_node n \\<and>\n \\<not> memb n Sa__} \\<and>\n                         finite {n. is_node n \\<and> \\<not> memb n Sa__}", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; is_node x__; list_all is_node xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> {n. is_node n \\<and> \\<not> memb n (ins x__ Sa__)}\n                         \\<subset> {n. is_node n \\<and> \\<not> memb n Sa__}\n 2. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; is_node x__; list_all is_node xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> finite {n. is_node n \\<and> \\<not> memb n Sa__}", "apply (auto simp add: ins_eq graph_finite cong: conj_cong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"succss xs = (\\<Union>x\\<in>xs. set (succs x))\""], ["", "definition \"set_of S = {x. is_node x \\<and> memb x S}\""], ["", "definition \"reachable xs = {(x, y). y \\<in> set (succs x)}\\<^sup>* `` xs\""], ["", "lemma visit_subset_dfs: \"invariant S \\<Longrightarrow> list_all is_node xs \\<Longrightarrow>\n    is_node y \\<Longrightarrow> memb y S \\<Longrightarrow> memb y (dfs S xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant S; list_all is_node xs; is_node y; memb y S\\<rbrakk>\n    \\<Longrightarrow> memb y (dfs S xs)", "by (induct S xs rule: dfs_induct) (simp_all add: ins_eq)"], ["", "lemma next_subset_dfs: \"invariant S \\<Longrightarrow> list_all is_node xs \\<Longrightarrow>\n    x \\<in> set xs \\<Longrightarrow> memb x (dfs S xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant S; list_all is_node xs; x \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> memb x (dfs S xs)", "proof (induct S xs rule: dfs_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>invariant S; x \\<in> set []\\<rbrakk>\n       \\<Longrightarrow> memb x (dfs S [])\n 2. \\<And>S xa xs.\n       \\<lbrakk>invariant S; is_node xa; list_all is_node xs;\n        \\<lbrakk>memb xa S; x \\<in> set xs\\<rbrakk>\n        \\<Longrightarrow> memb x (dfs S xs);\n        \\<lbrakk>\\<not> memb xa S; x \\<in> set (succs xa @ xs)\\<rbrakk>\n        \\<Longrightarrow> memb x (dfs (ins xa S) (succs xa @ xs));\n        x \\<in> set (xa # xs)\\<rbrakk>\n       \\<Longrightarrow> memb x (dfs S (xa # xs))", "case base"], ["proof (state)\nthis:\n  invariant S_\n  x \\<in> set []\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>invariant S; x \\<in> set []\\<rbrakk>\n       \\<Longrightarrow> memb x (dfs S [])\n 2. \\<And>S xa xs.\n       \\<lbrakk>invariant S; is_node xa; list_all is_node xs;\n        \\<lbrakk>memb xa S; x \\<in> set xs\\<rbrakk>\n        \\<Longrightarrow> memb x (dfs S xs);\n        \\<lbrakk>\\<not> memb xa S; x \\<in> set (succs xa @ xs)\\<rbrakk>\n        \\<Longrightarrow> memb x (dfs (ins xa S) (succs xa @ xs));\n        x \\<in> set (xa # xs)\\<rbrakk>\n       \\<Longrightarrow> memb x (dfs S (xa # xs))", "then"], ["proof (chain)\npicking this:\n  invariant S_\n  x \\<in> set []", "show ?case"], ["proof (prove)\nusing this:\n  invariant S_\n  x \\<in> set []\n\ngoal (1 subgoal):\n 1. memb x (dfs S_ [])", "by simp"], ["proof (state)\nthis:\n  memb x (dfs S_ [])\n\ngoal (1 subgoal):\n 1. \\<And>S xa xs.\n       \\<lbrakk>invariant S; is_node xa; list_all is_node xs;\n        \\<lbrakk>memb xa S; x \\<in> set xs\\<rbrakk>\n        \\<Longrightarrow> memb x (dfs S xs);\n        \\<lbrakk>\\<not> memb xa S; x \\<in> set (succs xa @ xs)\\<rbrakk>\n        \\<Longrightarrow> memb x (dfs (ins xa S) (succs xa @ xs));\n        x \\<in> set (xa # xs)\\<rbrakk>\n       \\<Longrightarrow> memb x (dfs S (xa # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S xa xs.\n       \\<lbrakk>invariant S; is_node xa; list_all is_node xs;\n        \\<lbrakk>memb xa S; x \\<in> set xs\\<rbrakk>\n        \\<Longrightarrow> memb x (dfs S xs);\n        \\<lbrakk>\\<not> memb xa S; x \\<in> set (succs xa @ xs)\\<rbrakk>\n        \\<Longrightarrow> memb x (dfs (ins xa S) (succs xa @ xs));\n        x \\<in> set (xa # xs)\\<rbrakk>\n       \\<Longrightarrow> memb x (dfs S (xa # xs))", "case (step S y xs)"], ["proof (state)\nthis:\n  invariant S\n  is_node y\n  list_all is_node xs\n  \\<lbrakk>memb y S; x \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> memb x (dfs S xs)\n  \\<lbrakk>\\<not> memb y S; x \\<in> set (succs y @ xs)\\<rbrakk>\n  \\<Longrightarrow> memb x (dfs (ins y S) (succs y @ xs))\n  x \\<in> set (y # xs)\n\ngoal (1 subgoal):\n 1. \\<And>S xa xs.\n       \\<lbrakk>invariant S; is_node xa; list_all is_node xs;\n        \\<lbrakk>memb xa S; x \\<in> set xs\\<rbrakk>\n        \\<Longrightarrow> memb x (dfs S xs);\n        \\<lbrakk>\\<not> memb xa S; x \\<in> set (succs xa @ xs)\\<rbrakk>\n        \\<Longrightarrow> memb x (dfs (ins xa S) (succs xa @ xs));\n        x \\<in> set (xa # xs)\\<rbrakk>\n       \\<Longrightarrow> memb x (dfs S (xa # xs))", "then"], ["proof (chain)\npicking this:\n  invariant S\n  is_node y\n  list_all is_node xs\n  \\<lbrakk>memb y S; x \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> memb x (dfs S xs)\n  \\<lbrakk>\\<not> memb y S; x \\<in> set (succs y @ xs)\\<rbrakk>\n  \\<Longrightarrow> memb x (dfs (ins y S) (succs y @ xs))\n  x \\<in> set (y # xs)", "show ?case"], ["proof (prove)\nusing this:\n  invariant S\n  is_node y\n  list_all is_node xs\n  \\<lbrakk>memb y S; x \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> memb x (dfs S xs)\n  \\<lbrakk>\\<not> memb y S; x \\<in> set (succs y @ xs)\\<rbrakk>\n  \\<Longrightarrow> memb x (dfs (ins y S) (succs y @ xs))\n  x \\<in> set (y # xs)\n\ngoal (1 subgoal):\n 1. memb x (dfs S (y # xs))", "by (auto simp add: visit_subset_dfs ins_eq ins_invariant succs_is_node)"], ["proof (state)\nthis:\n  memb x (dfs S (y # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma succss_closed_dfs':\n  \"invariant ys \\<Longrightarrow> list_all is_node xs \\<Longrightarrow>\n    succss (set_of ys) \\<subseteq> set xs \\<union> set_of ys \\<Longrightarrow>\n    succss (set_of (dfs ys xs)) \\<subseteq> set_of (dfs ys xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant ys; list_all is_node xs;\n     succss (set_of ys) \\<subseteq> set xs \\<union> set_of ys\\<rbrakk>\n    \\<Longrightarrow> succss (set_of (dfs ys xs))\n                      \\<subseteq> set_of (dfs ys xs)", "by (induct ys xs rule: dfs_induct)\n    (auto simp add: ins_eq succss_def set_of_def cong: conj_cong)"], ["", "lemma succss_closed_dfs: \"list_all is_node xs \\<Longrightarrow>\n    succss (set_of (dfs empt xs)) \\<subseteq> set_of (dfs empt xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all is_node xs \\<Longrightarrow>\n    succss (set_of (dfs empt xs)) \\<subseteq> set_of (dfs empt xs)", "apply (rule succss_closed_dfs')"], ["proof (prove)\ngoal (3 subgoals):\n 1. list_all is_node xs \\<Longrightarrow> invariant empt\n 2. list_all is_node xs \\<Longrightarrow> list_all is_node xs\n 3. list_all is_node xs \\<Longrightarrow>\n    succss (set_of empt) \\<subseteq> set xs \\<union> set_of empt", "apply (rule empt_invariant)"], ["proof (prove)\ngoal (2 subgoals):\n 1. list_all is_node xs \\<Longrightarrow> list_all is_node xs\n 2. list_all is_node xs \\<Longrightarrow>\n    succss (set_of empt) \\<subseteq> set xs \\<union> set_of empt", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all is_node xs \\<Longrightarrow>\n    succss (set_of empt) \\<subseteq> set xs \\<union> set_of empt", "apply (simp add: succss_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all is_node xs \\<Longrightarrow>\n    (\\<Union>x\\<in>set_of empt. set (succs x))\n    \\<subseteq> set xs \\<union> set_of empt", "apply (rule subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>list_all is_node xs;\n        x \\<in> (\\<Union>x\\<in>set_of empt. set (succs x))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set xs \\<union> set_of empt", "apply (erule UN_E)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>list_all is_node xs; xa \\<in> set_of empt;\n        x \\<in> set (succs xa)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set xs \\<union> set_of empt", "apply (simp add: set_of_def empt cong: conj_cong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r\\<^sup>* `` X = X", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. r\\<^sup>* `` X \\<subseteq> X\n 2. X \\<subseteq> r\\<^sup>* `` X", "show \"X \\<subseteq> r\\<^sup>* `` X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<subseteq> r\\<^sup>* `` X", "by auto"], ["proof (state)\nthis:\n  X \\<subseteq> r\\<^sup>* `` X\n\ngoal (1 subgoal):\n 1. r\\<^sup>* `` X \\<subseteq> X", "show \"r\\<^sup>* `` X \\<subseteq> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r\\<^sup>* `` X \\<subseteq> X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. r\\<^sup>* `` X \\<subseteq> X", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. r\\<^sup>* `` X \\<subseteq> X", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. r\\<^sup>* `` X \\<subseteq> X", "assume y: \"y \\<in> X\""], ["proof (state)\nthis:\n  y \\<in> X\n\ngoal (1 subgoal):\n 1. r\\<^sup>* `` X \\<subseteq> X", "assume \"(y,x) \\<in> r\\<^sup>*\""], ["proof (state)\nthis:\n  (y, x) \\<in> r\\<^sup>*\n\ngoal (1 subgoal):\n 1. r\\<^sup>* `` X \\<subseteq> X", "then"], ["proof (chain)\npicking this:\n  (y, x) \\<in> r\\<^sup>*", "have \"x \\<in> X\""], ["proof (prove)\nusing this:\n  (y, x) \\<in> r\\<^sup>*\n\ngoal (1 subgoal):\n 1. x \\<in> X", "using assms y"], ["proof (prove)\nusing this:\n  (y, x) \\<in> r\\<^sup>*\n  r `` X \\<subseteq> X\n  y \\<in> X\n\ngoal (1 subgoal):\n 1. x \\<in> X", "by induct (auto simp add: Image_def)"], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. r\\<^sup>* `` X \\<subseteq> X", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?y2 \\<in> X; (?y2, ?x2) \\<in> r\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> ?x2 \\<in> X\n\ngoal (1 subgoal):\n 1. r\\<^sup>* `` X \\<subseteq> X", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?y2 \\<in> X; (?y2, ?x2) \\<in> r\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> ?x2 \\<in> X", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y2 \\<in> X; (?y2, ?x2) \\<in> r\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> ?x2 \\<in> X\n\ngoal (1 subgoal):\n 1. r\\<^sup>* `` X \\<subseteq> X", "by auto"], ["proof (state)\nthis:\n  r\\<^sup>* `` X \\<subseteq> X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r\\<^sup>* `` X \\<subseteq> X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reachable_closed_dfs:\n  assumes \"list_all is_node xs\"\n  shows \"reachable (set xs) \\<subseteq> set_of (dfs empt xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable (set xs) \\<subseteq> set_of (dfs empt xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. reachable (set xs) \\<subseteq> set_of (dfs empt xs)", "from assms"], ["proof (chain)\npicking this:\n  list_all is_node xs", "have \"reachable (set xs) \\<subseteq> reachable (set_of (dfs empt xs))\""], ["proof (prove)\nusing this:\n  list_all is_node xs\n\ngoal (1 subgoal):\n 1. reachable (set xs) \\<subseteq> reachable (set_of (dfs empt xs))", "apply (unfold reachable_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all is_node xs \\<Longrightarrow>\n    {(x, y). y \\<in> set (succs x)}\\<^sup>* `` set xs\n    \\<subseteq> {(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                set_of (dfs empt xs)", "apply (rule Image_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. list_all is_node xs \\<Longrightarrow>\n    {(x, y). y \\<in> set (succs x)}\\<^sup>*\n    \\<subseteq> {(x, y). y \\<in> set (succs x)}\\<^sup>*\n 2. list_all is_node xs \\<Longrightarrow>\n    set xs \\<subseteq> set_of (dfs empt xs)", "apply (auto simp add: set_of_def next_subset_dfs empt_invariant list_all_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  reachable (set xs) \\<subseteq> reachable (set_of (dfs empt xs))\n\ngoal (1 subgoal):\n 1. reachable (set xs) \\<subseteq> set_of (dfs empt xs)", "also"], ["proof (state)\nthis:\n  reachable (set xs) \\<subseteq> reachable (set_of (dfs empt xs))\n\ngoal (1 subgoal):\n 1. reachable (set xs) \\<subseteq> set_of (dfs empt xs)", "from succss_closed_dfs assms"], ["proof (chain)\npicking this:\n  list_all is_node ?xs \\<Longrightarrow>\n  succss (set_of (dfs empt ?xs)) \\<subseteq> set_of (dfs empt ?xs)\n  list_all is_node xs", "have \"\\<dots> = set_of (dfs empt xs)\""], ["proof (prove)\nusing this:\n  list_all is_node ?xs \\<Longrightarrow>\n  succss (set_of (dfs empt ?xs)) \\<subseteq> set_of (dfs empt ?xs)\n  list_all is_node xs\n\ngoal (1 subgoal):\n 1. reachable (set_of (dfs empt xs)) = set_of (dfs empt xs)", "apply (unfold reachable_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs.\n                list_all is_node xs \\<Longrightarrow>\n                succss (set_of (dfs empt xs))\n                \\<subseteq> set_of (dfs empt xs);\n     list_all is_node xs\\<rbrakk>\n    \\<Longrightarrow> {(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                      set_of (dfs empt xs) =\n                      set_of (dfs empt xs)", "apply (rule Image_closed_trancl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs.\n                list_all is_node xs \\<Longrightarrow>\n                succss (set_of (dfs empt xs))\n                \\<subseteq> set_of (dfs empt xs);\n     list_all is_node xs\\<rbrakk>\n    \\<Longrightarrow> {(x, y). y \\<in> set (succs x)} ``\n                      set_of (dfs empt xs)\n                      \\<subseteq> set_of (dfs empt xs)", "apply (auto simp add: succss_def set_of_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  reachable (set_of (dfs empt xs)) = set_of (dfs empt xs)\n\ngoal (1 subgoal):\n 1. reachable (set xs) \\<subseteq> set_of (dfs empt xs)", "finally"], ["proof (chain)\npicking this:\n  reachable (set xs) \\<subseteq> set_of (dfs empt xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  reachable (set xs) \\<subseteq> set_of (dfs empt xs)\n\ngoal (1 subgoal):\n 1. reachable (set xs) \\<subseteq> set_of (dfs empt xs)", "."], ["proof (state)\nthis:\n  reachable (set xs) \\<subseteq> set_of (dfs empt xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reachable_succs: \"reachable (set (succs x)) \\<subseteq> reachable {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable (set (succs x)) \\<subseteq> reachable {x}", "by (auto simp add: reachable_def intro: converse_rtrancl_into_rtrancl)"], ["", "lemma dfs_subset_reachable_visit_nodes:\n  \"invariant ys \\<Longrightarrow> list_all is_node xs \\<Longrightarrow>\n     set_of (dfs ys xs) \\<subseteq> reachable (set xs) \\<union> set_of ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant ys; list_all is_node xs\\<rbrakk>\n    \\<Longrightarrow> set_of (dfs ys xs)\n                      \\<subseteq> reachable (set xs) \\<union> set_of ys", "proof (induct ys xs rule: dfs_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>S.\n       invariant S \\<Longrightarrow>\n       set_of (dfs S []) \\<subseteq> reachable (set []) \\<union> set_of S\n 2. \\<And>S x xs.\n       \\<lbrakk>invariant S; is_node x; list_all is_node xs;\n        memb x S \\<Longrightarrow>\n        set_of (dfs S xs) \\<subseteq> reachable (set xs) \\<union> set_of S;\n        \\<not> memb x S \\<Longrightarrow>\n        set_of (dfs (ins x S) (succs x @ xs))\n        \\<subseteq> reachable (set (succs x @ xs)) \\<union>\n                    set_of (ins x S)\\<rbrakk>\n       \\<Longrightarrow> set_of (dfs S (x # xs))\n                         \\<subseteq> reachable (set (x # xs)) \\<union>\n                                     set_of S", "case base"], ["proof (state)\nthis:\n  invariant S_\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       invariant S \\<Longrightarrow>\n       set_of (dfs S []) \\<subseteq> reachable (set []) \\<union> set_of S\n 2. \\<And>S x xs.\n       \\<lbrakk>invariant S; is_node x; list_all is_node xs;\n        memb x S \\<Longrightarrow>\n        set_of (dfs S xs) \\<subseteq> reachable (set xs) \\<union> set_of S;\n        \\<not> memb x S \\<Longrightarrow>\n        set_of (dfs (ins x S) (succs x @ xs))\n        \\<subseteq> reachable (set (succs x @ xs)) \\<union>\n                    set_of (ins x S)\\<rbrakk>\n       \\<Longrightarrow> set_of (dfs S (x # xs))\n                         \\<subseteq> reachable (set (x # xs)) \\<union>\n                                     set_of S", "then"], ["proof (chain)\npicking this:\n  invariant S_", "show ?case"], ["proof (prove)\nusing this:\n  invariant S_\n\ngoal (1 subgoal):\n 1. set_of (dfs S_ []) \\<subseteq> reachable (set []) \\<union> set_of S_", "by (simp add: reachable_def)"], ["proof (state)\nthis:\n  set_of (dfs S_ []) \\<subseteq> reachable (set []) \\<union> set_of S_\n\ngoal (1 subgoal):\n 1. \\<And>S x xs.\n       \\<lbrakk>invariant S; is_node x; list_all is_node xs;\n        memb x S \\<Longrightarrow>\n        set_of (dfs S xs) \\<subseteq> reachable (set xs) \\<union> set_of S;\n        \\<not> memb x S \\<Longrightarrow>\n        set_of (dfs (ins x S) (succs x @ xs))\n        \\<subseteq> reachable (set (succs x @ xs)) \\<union>\n                    set_of (ins x S)\\<rbrakk>\n       \\<Longrightarrow> set_of (dfs S (x # xs))\n                         \\<subseteq> reachable (set (x # xs)) \\<union>\n                                     set_of S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S x xs.\n       \\<lbrakk>invariant S; is_node x; list_all is_node xs;\n        memb x S \\<Longrightarrow>\n        set_of (dfs S xs) \\<subseteq> reachable (set xs) \\<union> set_of S;\n        \\<not> memb x S \\<Longrightarrow>\n        set_of (dfs (ins x S) (succs x @ xs))\n        \\<subseteq> reachable (set (succs x @ xs)) \\<union>\n                    set_of (ins x S)\\<rbrakk>\n       \\<Longrightarrow> set_of (dfs S (x # xs))\n                         \\<subseteq> reachable (set (x # xs)) \\<union>\n                                     set_of S", "case (step S x xs)"], ["proof (state)\nthis:\n  invariant S\n  is_node x\n  list_all is_node xs\n  memb x S \\<Longrightarrow>\n  set_of (dfs S xs) \\<subseteq> reachable (set xs) \\<union> set_of S\n  \\<not> memb x S \\<Longrightarrow>\n  set_of (dfs (ins x S) (succs x @ xs))\n  \\<subseteq> reachable (set (succs x @ xs)) \\<union> set_of (ins x S)\n\ngoal (1 subgoal):\n 1. \\<And>S x xs.\n       \\<lbrakk>invariant S; is_node x; list_all is_node xs;\n        memb x S \\<Longrightarrow>\n        set_of (dfs S xs) \\<subseteq> reachable (set xs) \\<union> set_of S;\n        \\<not> memb x S \\<Longrightarrow>\n        set_of (dfs (ins x S) (succs x @ xs))\n        \\<subseteq> reachable (set (succs x @ xs)) \\<union>\n                    set_of (ins x S)\\<rbrakk>\n       \\<Longrightarrow> set_of (dfs S (x # xs))\n                         \\<subseteq> reachable (set (x # xs)) \\<union>\n                                     set_of S", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_of (dfs S (x # xs))\n    \\<subseteq> reachable (set (x # xs)) \\<union> set_of S", "proof (cases \"memb x S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. memb x S \\<Longrightarrow>\n    set_of (dfs S (x # xs))\n    \\<subseteq> reachable (set (x # xs)) \\<union> set_of S\n 2. \\<not> memb x S \\<Longrightarrow>\n    set_of (dfs S (x # xs))\n    \\<subseteq> reachable (set (x # xs)) \\<union> set_of S", "case True"], ["proof (state)\nthis:\n  memb x S\n\ngoal (2 subgoals):\n 1. memb x S \\<Longrightarrow>\n    set_of (dfs S (x # xs))\n    \\<subseteq> reachable (set (x # xs)) \\<union> set_of S\n 2. \\<not> memb x S \\<Longrightarrow>\n    set_of (dfs S (x # xs))\n    \\<subseteq> reachable (set (x # xs)) \\<union> set_of S", "with step"], ["proof (chain)\npicking this:\n  invariant S\n  is_node x\n  list_all is_node xs\n  memb x S \\<Longrightarrow>\n  set_of (dfs S xs) \\<subseteq> reachable (set xs) \\<union> set_of S\n  \\<not> memb x S \\<Longrightarrow>\n  set_of (dfs (ins x S) (succs x @ xs))\n  \\<subseteq> reachable (set (succs x @ xs)) \\<union> set_of (ins x S)\n  memb x S", "show ?thesis"], ["proof (prove)\nusing this:\n  invariant S\n  is_node x\n  list_all is_node xs\n  memb x S \\<Longrightarrow>\n  set_of (dfs S xs) \\<subseteq> reachable (set xs) \\<union> set_of S\n  \\<not> memb x S \\<Longrightarrow>\n  set_of (dfs (ins x S) (succs x @ xs))\n  \\<subseteq> reachable (set (succs x @ xs)) \\<union> set_of (ins x S)\n  memb x S\n\ngoal (1 subgoal):\n 1. set_of (dfs S (x # xs))\n    \\<subseteq> reachable (set (x # xs)) \\<union> set_of S", "by (auto simp add: reachable_def)"], ["proof (state)\nthis:\n  set_of (dfs S (x # xs))\n  \\<subseteq> reachable (set (x # xs)) \\<union> set_of S\n\ngoal (1 subgoal):\n 1. \\<not> memb x S \\<Longrightarrow>\n    set_of (dfs S (x # xs))\n    \\<subseteq> reachable (set (x # xs)) \\<union> set_of S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> memb x S \\<Longrightarrow>\n    set_of (dfs S (x # xs))\n    \\<subseteq> reachable (set (x # xs)) \\<union> set_of S", "case False"], ["proof (state)\nthis:\n  \\<not> memb x S\n\ngoal (1 subgoal):\n 1. \\<not> memb x S \\<Longrightarrow>\n    set_of (dfs S (x # xs))\n    \\<subseteq> reachable (set (x # xs)) \\<union> set_of S", "have \"reachable (set (succs x)) \\<subseteq> reachable {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable (set (succs x)) \\<subseteq> reachable {x}", "by (rule reachable_succs)"], ["proof (state)\nthis:\n  reachable (set (succs x)) \\<subseteq> reachable {x}\n\ngoal (1 subgoal):\n 1. \\<not> memb x S \\<Longrightarrow>\n    set_of (dfs S (x # xs))\n    \\<subseteq> reachable (set (x # xs)) \\<union> set_of S", "then"], ["proof (chain)\npicking this:\n  reachable (set (succs x)) \\<subseteq> reachable {x}", "have \"reachable (set (succs x @ xs)) \\<subseteq> reachable (set (x # xs))\""], ["proof (prove)\nusing this:\n  reachable (set (succs x)) \\<subseteq> reachable {x}\n\ngoal (1 subgoal):\n 1. reachable (set (succs x @ xs)) \\<subseteq> reachable (set (x # xs))", "by (auto simp add: reachable_def)"], ["proof (state)\nthis:\n  reachable (set (succs x @ xs)) \\<subseteq> reachable (set (x # xs))\n\ngoal (1 subgoal):\n 1. \\<not> memb x S \\<Longrightarrow>\n    set_of (dfs S (x # xs))\n    \\<subseteq> reachable (set (x # xs)) \\<union> set_of S", "then"], ["proof (chain)\npicking this:\n  reachable (set (succs x @ xs)) \\<subseteq> reachable (set (x # xs))", "show ?thesis"], ["proof (prove)\nusing this:\n  reachable (set (succs x @ xs)) \\<subseteq> reachable (set (x # xs))\n\ngoal (1 subgoal):\n 1. set_of (dfs S (x # xs))\n    \\<subseteq> reachable (set (x # xs)) \\<union> set_of S", "using step"], ["proof (prove)\nusing this:\n  reachable (set (succs x @ xs)) \\<subseteq> reachable (set (x # xs))\n  invariant S\n  is_node x\n  list_all is_node xs\n  memb x S \\<Longrightarrow>\n  set_of (dfs S xs) \\<subseteq> reachable (set xs) \\<union> set_of S\n  \\<not> memb x S \\<Longrightarrow>\n  set_of (dfs (ins x S) (succs x @ xs))\n  \\<subseteq> reachable (set (succs x @ xs)) \\<union> set_of (ins x S)\n\ngoal (1 subgoal):\n 1. set_of (dfs S (x # xs))\n    \\<subseteq> reachable (set (x # xs)) \\<union> set_of S", "by (auto simp add: reachable_def ins_eq set_of_def cong: conj_cong)"], ["proof (state)\nthis:\n  set_of (dfs S (x # xs))\n  \\<subseteq> reachable (set (x # xs)) \\<union> set_of S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set_of (dfs S (x # xs))\n  \\<subseteq> reachable (set (x # xs)) \\<union> set_of S\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem dfs_eq_reachable:\n  assumes y: \"is_node y\"\n    and xs: \"list_all is_node xs\"\n  shows \"memb y (dfs empt xs) = (y \\<in> reachable (set xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. memb y (dfs empt xs) = (y \\<in> reachable (set xs))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. memb y (dfs empt xs) \\<Longrightarrow> y \\<in> reachable (set xs)\n 2. y \\<in> reachable (set xs) \\<Longrightarrow> memb y (dfs empt xs)", "assume \"memb y (dfs empt xs)\""], ["proof (state)\nthis:\n  memb y (dfs empt xs)\n\ngoal (2 subgoals):\n 1. memb y (dfs empt xs) \\<Longrightarrow> y \\<in> reachable (set xs)\n 2. y \\<in> reachable (set xs) \\<Longrightarrow> memb y (dfs empt xs)", "with dfs_subset_reachable_visit_nodes [OF empt_invariant xs] y"], ["proof (chain)\npicking this:\n  set_of (dfs empt xs) \\<subseteq> reachable (set xs) \\<union> set_of empt\n  is_node y\n  memb y (dfs empt xs)", "show \"y \\<in> reachable (set xs)\""], ["proof (prove)\nusing this:\n  set_of (dfs empt xs) \\<subseteq> reachable (set xs) \\<union> set_of empt\n  is_node y\n  memb y (dfs empt xs)\n\ngoal (1 subgoal):\n 1. y \\<in> reachable (set xs)", "by (auto simp add: empt set_of_def)"], ["proof (state)\nthis:\n  y \\<in> reachable (set xs)\n\ngoal (1 subgoal):\n 1. y \\<in> reachable (set xs) \\<Longrightarrow> memb y (dfs empt xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<in> reachable (set xs) \\<Longrightarrow> memb y (dfs empt xs)", "assume \"y \\<in> reachable (set xs)\""], ["proof (state)\nthis:\n  y \\<in> reachable (set xs)\n\ngoal (1 subgoal):\n 1. y \\<in> reachable (set xs) \\<Longrightarrow> memb y (dfs empt xs)", "with reachable_closed_dfs [OF xs]"], ["proof (chain)\npicking this:\n  reachable (set xs) \\<subseteq> set_of (dfs empt xs)\n  y \\<in> reachable (set xs)", "show \"memb y (dfs empt xs)\""], ["proof (prove)\nusing this:\n  reachable (set xs) \\<subseteq> set_of (dfs empt xs)\n  y \\<in> reachable (set xs)\n\ngoal (1 subgoal):\n 1. memb y (dfs empt xs)", "by (auto simp add: set_of_def)"], ["proof (state)\nthis:\n  memb y (dfs empt xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem dfs_eq_rtrancl:\n  assumes y: \"is_node y\"\n    and x: \"is_node x\"\n  shows \"memb y (dfs empt [x]) = ((x,y) \\<in> (succsr succs)\\<^sup>*)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. memb y (dfs empt [x]) = ((x, y) \\<in> (succsr succs)\\<^sup>*)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. memb y (dfs empt [x]) = ((x, y) \\<in> (succsr succs)\\<^sup>*)", "from x"], ["proof (chain)\npicking this:\n  is_node x", "have x': \"list_all is_node [x]\""], ["proof (prove)\nusing this:\n  is_node x\n\ngoal (1 subgoal):\n 1. list_all is_node [x]", "by simp"], ["proof (state)\nthis:\n  list_all is_node [x]\n\ngoal (1 subgoal):\n 1. memb y (dfs empt [x]) = ((x, y) \\<in> (succsr succs)\\<^sup>*)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. memb y (dfs empt [x]) = ((x, y) \\<in> (succsr succs)\\<^sup>*)", "by (simp only: dfs_eq_reachable [OF y x'] reachable_def succsr_def) (auto simp add: empt)"], ["proof (state)\nthis:\n  memb y (dfs empt [x]) = ((x, y) \\<in> (succsr succs)\\<^sup>*)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem dfs_invariant [consumes 2, case_names base step]:\n  assumes S: \"invariant S\"\n    and xs: \"list_all is_node xs\"\n    and H: \"I S\"\n    and I: \"\\<And>S x. \\<not> memb x S \\<Longrightarrow> is_node x \\<Longrightarrow> invariant S \\<Longrightarrow> I S \\<Longrightarrow> I (ins x S)\"\n  shows \"I (dfs S xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I (dfs S xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. I (dfs S xs)", "from S xs H"], ["proof (chain)\npicking this:\n  invariant S\n  list_all is_node xs\n  I S", "have \"I (dfs S xs) \\<and> invariant (dfs S xs)\""], ["proof (prove)\nusing this:\n  invariant S\n  list_all is_node xs\n  I S\n\ngoal (1 subgoal):\n 1. I (dfs S xs) \\<and> invariant (dfs S xs)", "proof (induct S xs rule: dfs_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>invariant S; I S\\<rbrakk>\n       \\<Longrightarrow> I (dfs S []) \\<and> invariant (dfs S [])\n 2. \\<And>S x xs.\n       \\<lbrakk>invariant S; is_node x; list_all is_node xs;\n        \\<lbrakk>memb x S; I S\\<rbrakk>\n        \\<Longrightarrow> I (dfs S xs) \\<and> invariant (dfs S xs);\n        \\<lbrakk>\\<not> memb x S; I (ins x S)\\<rbrakk>\n        \\<Longrightarrow> I (dfs (ins x S) (succs x @ xs)) \\<and>\n                          invariant (dfs (ins x S) (succs x @ xs));\n        I S\\<rbrakk>\n       \\<Longrightarrow> I (dfs S (x # xs)) \\<and>\n                         invariant (dfs S (x # xs))", "case base"], ["proof (state)\nthis:\n  invariant S_\n  I S_\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>invariant S; I S\\<rbrakk>\n       \\<Longrightarrow> I (dfs S []) \\<and> invariant (dfs S [])\n 2. \\<And>S x xs.\n       \\<lbrakk>invariant S; is_node x; list_all is_node xs;\n        \\<lbrakk>memb x S; I S\\<rbrakk>\n        \\<Longrightarrow> I (dfs S xs) \\<and> invariant (dfs S xs);\n        \\<lbrakk>\\<not> memb x S; I (ins x S)\\<rbrakk>\n        \\<Longrightarrow> I (dfs (ins x S) (succs x @ xs)) \\<and>\n                          invariant (dfs (ins x S) (succs x @ xs));\n        I S\\<rbrakk>\n       \\<Longrightarrow> I (dfs S (x # xs)) \\<and>\n                         invariant (dfs S (x # xs))", "then"], ["proof (chain)\npicking this:\n  invariant S_\n  I S_", "show ?case"], ["proof (prove)\nusing this:\n  invariant S_\n  I S_\n\ngoal (1 subgoal):\n 1. I (dfs S_ []) \\<and> invariant (dfs S_ [])", "by simp"], ["proof (state)\nthis:\n  I (dfs S_ []) \\<and> invariant (dfs S_ [])\n\ngoal (1 subgoal):\n 1. \\<And>S x xs.\n       \\<lbrakk>invariant S; is_node x; list_all is_node xs;\n        \\<lbrakk>memb x S; I S\\<rbrakk>\n        \\<Longrightarrow> I (dfs S xs) \\<and> invariant (dfs S xs);\n        \\<lbrakk>\\<not> memb x S; I (ins x S)\\<rbrakk>\n        \\<Longrightarrow> I (dfs (ins x S) (succs x @ xs)) \\<and>\n                          invariant (dfs (ins x S) (succs x @ xs));\n        I S\\<rbrakk>\n       \\<Longrightarrow> I (dfs S (x # xs)) \\<and>\n                         invariant (dfs S (x # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S x xs.\n       \\<lbrakk>invariant S; is_node x; list_all is_node xs;\n        \\<lbrakk>memb x S; I S\\<rbrakk>\n        \\<Longrightarrow> I (dfs S xs) \\<and> invariant (dfs S xs);\n        \\<lbrakk>\\<not> memb x S; I (ins x S)\\<rbrakk>\n        \\<Longrightarrow> I (dfs (ins x S) (succs x @ xs)) \\<and>\n                          invariant (dfs (ins x S) (succs x @ xs));\n        I S\\<rbrakk>\n       \\<Longrightarrow> I (dfs S (x # xs)) \\<and>\n                         invariant (dfs S (x # xs))", "case (step S x xs)"], ["proof (state)\nthis:\n  invariant S\n  is_node x\n  list_all is_node xs\n  \\<lbrakk>memb x S; I S\\<rbrakk>\n  \\<Longrightarrow> I (dfs S xs) \\<and> invariant (dfs S xs)\n  \\<lbrakk>\\<not> memb x S; I (ins x S)\\<rbrakk>\n  \\<Longrightarrow> I (dfs (ins x S) (succs x @ xs)) \\<and>\n                    invariant (dfs (ins x S) (succs x @ xs))\n  I S\n\ngoal (1 subgoal):\n 1. \\<And>S x xs.\n       \\<lbrakk>invariant S; is_node x; list_all is_node xs;\n        \\<lbrakk>memb x S; I S\\<rbrakk>\n        \\<Longrightarrow> I (dfs S xs) \\<and> invariant (dfs S xs);\n        \\<lbrakk>\\<not> memb x S; I (ins x S)\\<rbrakk>\n        \\<Longrightarrow> I (dfs (ins x S) (succs x @ xs)) \\<and>\n                          invariant (dfs (ins x S) (succs x @ xs));\n        I S\\<rbrakk>\n       \\<Longrightarrow> I (dfs S (x # xs)) \\<and>\n                         invariant (dfs S (x # xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. I (dfs S (x # xs)) \\<and> invariant (dfs S (x # xs))", "proof (cases \"memb x S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. memb x S \\<Longrightarrow>\n    I (dfs S (x # xs)) \\<and> invariant (dfs S (x # xs))\n 2. \\<not> memb x S \\<Longrightarrow>\n    I (dfs S (x # xs)) \\<and> invariant (dfs S (x # xs))", "case True"], ["proof (state)\nthis:\n  memb x S\n\ngoal (2 subgoals):\n 1. memb x S \\<Longrightarrow>\n    I (dfs S (x # xs)) \\<and> invariant (dfs S (x # xs))\n 2. \\<not> memb x S \\<Longrightarrow>\n    I (dfs S (x # xs)) \\<and> invariant (dfs S (x # xs))", "then"], ["proof (chain)\npicking this:\n  memb x S", "show ?thesis"], ["proof (prove)\nusing this:\n  memb x S\n\ngoal (1 subgoal):\n 1. I (dfs S (x # xs)) \\<and> invariant (dfs S (x # xs))", "by (simp add: step)"], ["proof (state)\nthis:\n  I (dfs S (x # xs)) \\<and> invariant (dfs S (x # xs))\n\ngoal (1 subgoal):\n 1. \\<not> memb x S \\<Longrightarrow>\n    I (dfs S (x # xs)) \\<and> invariant (dfs S (x # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> memb x S \\<Longrightarrow>\n    I (dfs S (x # xs)) \\<and> invariant (dfs S (x # xs))", "case False"], ["proof (state)\nthis:\n  \\<not> memb x S\n\ngoal (1 subgoal):\n 1. \\<not> memb x S \\<Longrightarrow>\n    I (dfs S (x # xs)) \\<and> invariant (dfs S (x # xs))", "then"], ["proof (chain)\npicking this:\n  \\<not> memb x S", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> memb x S\n\ngoal (1 subgoal):\n 1. I (dfs S (x # xs)) \\<and> invariant (dfs S (x # xs))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> memb x S \\<Longrightarrow>\n    I (dfs (ins x S) (succs x @ xs)) \\<and>\n    invariant (dfs (ins x S) (succs x @ xs))", "apply (rule step)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<not> memb x S \\<Longrightarrow> \\<not> memb x S\n 2. \\<not> memb x S \\<Longrightarrow> I (ins x S)", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> memb x S \\<Longrightarrow> I (ins x S)", "apply (rule I)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<not> memb x S \\<Longrightarrow> \\<not> memb x S\n 2. \\<not> memb x S \\<Longrightarrow> is_node x\n 3. \\<not> memb x S \\<Longrightarrow> invariant S\n 4. \\<not> memb x S \\<Longrightarrow> I S", "apply assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<not> memb x S \\<Longrightarrow> is_node x\n 2. \\<not> memb x S \\<Longrightarrow> invariant S\n 3. \\<not> memb x S \\<Longrightarrow> I S", "apply (rule step)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  I (dfs S (x # xs)) \\<and> invariant (dfs S (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  I (dfs S (x # xs)) \\<and> invariant (dfs S (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  I (dfs S xs) \\<and> invariant (dfs S xs)\n\ngoal (1 subgoal):\n 1. I (dfs S xs)", "then"], ["proof (chain)\npicking this:\n  I (dfs S xs) \\<and> invariant (dfs S xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  I (dfs S xs) \\<and> invariant (dfs S xs)\n\ngoal (1 subgoal):\n 1. I (dfs S xs)", ".."], ["proof (state)\nthis:\n  I (dfs S xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem dfs_invariant': \"invariant S \\<Longrightarrow> list_all is_node xs \\<Longrightarrow> invariant (dfs S xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant S; list_all is_node xs\\<rbrakk>\n    \\<Longrightarrow> invariant (dfs S xs)", "by (induct S xs rule: dfs_induct) auto"], ["", "theorem succsr_is_node:\n  assumes \"(x, y) \\<in> (succsr succs)\\<^sup>*\"\n  shows \"is_node x \\<Longrightarrow> is_node y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_node x \\<Longrightarrow> is_node y", "using assms"], ["proof (prove)\nusing this:\n  (x, y) \\<in> (succsr succs)\\<^sup>*\n\ngoal (1 subgoal):\n 1. is_node x \\<Longrightarrow> is_node y", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. is_node x \\<Longrightarrow> is_node x\n 2. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> (succsr succs)\\<^sup>*;\n        (y, z) \\<in> succsr succs; is_node x \\<Longrightarrow> is_node y;\n        is_node x\\<rbrakk>\n       \\<Longrightarrow> is_node z", "case base"], ["proof (state)\nthis:\n  is_node x\n\ngoal (2 subgoals):\n 1. is_node x \\<Longrightarrow> is_node x\n 2. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> (succsr succs)\\<^sup>*;\n        (y, z) \\<in> succsr succs; is_node x \\<Longrightarrow> is_node y;\n        is_node x\\<rbrakk>\n       \\<Longrightarrow> is_node z", "then"], ["proof (chain)\npicking this:\n  is_node x", "show ?case"], ["proof (prove)\nusing this:\n  is_node x\n\ngoal (1 subgoal):\n 1. is_node x", "."], ["proof (state)\nthis:\n  is_node x\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> (succsr succs)\\<^sup>*;\n        (y, z) \\<in> succsr succs; is_node x \\<Longrightarrow> is_node y;\n        is_node x\\<rbrakk>\n       \\<Longrightarrow> is_node z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> (succsr succs)\\<^sup>*;\n        (y, z) \\<in> succsr succs; is_node x \\<Longrightarrow> is_node y;\n        is_node x\\<rbrakk>\n       \\<Longrightarrow> is_node z", "case (step y z)"], ["proof (state)\nthis:\n  (x, y) \\<in> (succsr succs)\\<^sup>*\n  (y, z) \\<in> succsr succs\n  is_node x \\<Longrightarrow> is_node y\n  is_node x\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> (succsr succs)\\<^sup>*;\n        (y, z) \\<in> succsr succs; is_node x \\<Longrightarrow> is_node y;\n        is_node x\\<rbrakk>\n       \\<Longrightarrow> is_node z", "then"], ["proof (chain)\npicking this:\n  (x, y) \\<in> (succsr succs)\\<^sup>*\n  (y, z) \\<in> succsr succs\n  is_node x \\<Longrightarrow> is_node y\n  is_node x", "have \"is_node y\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> (succsr succs)\\<^sup>*\n  (y, z) \\<in> succsr succs\n  is_node x \\<Longrightarrow> is_node y\n  is_node x\n\ngoal (1 subgoal):\n 1. is_node y", "by simp"], ["proof (state)\nthis:\n  is_node y\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> (succsr succs)\\<^sup>*;\n        (y, z) \\<in> succsr succs; is_node x \\<Longrightarrow> is_node y;\n        is_node x\\<rbrakk>\n       \\<Longrightarrow> is_node z", "then"], ["proof (chain)\npicking this:\n  is_node y", "have \"list_all is_node (succs y)\""], ["proof (prove)\nusing this:\n  is_node y\n\ngoal (1 subgoal):\n 1. list_all is_node (succs y)", "by (rule succs_is_node)"], ["proof (state)\nthis:\n  list_all is_node (succs y)\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> (succsr succs)\\<^sup>*;\n        (y, z) \\<in> succsr succs; is_node x \\<Longrightarrow> is_node y;\n        is_node x\\<rbrakk>\n       \\<Longrightarrow> is_node z", "with step"], ["proof (chain)\npicking this:\n  (x, y) \\<in> (succsr succs)\\<^sup>*\n  (y, z) \\<in> succsr succs\n  is_node x \\<Longrightarrow> is_node y\n  is_node x\n  list_all is_node (succs y)", "show ?case"], ["proof (prove)\nusing this:\n  (x, y) \\<in> (succsr succs)\\<^sup>*\n  (y, z) \\<in> succsr succs\n  is_node x \\<Longrightarrow> is_node y\n  is_node x\n  list_all is_node (succs y)\n\ngoal (1 subgoal):\n 1. is_node z", "by (simp add: succsr_def list_all_iff)"], ["proof (state)\nthis:\n  is_node z\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "declare gen_dfs_simps [simp del]"], ["", "end"]]}