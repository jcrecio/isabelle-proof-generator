{"file_name": "/home/qj213/afp-2021-10-22/thys/Partial_Order_Reduction/Extensions/Coinductive_List_Extensions.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Partial_Order_Reduction", "problem_names": ["lemma lprefix_lSup_revert: \"lSup = Sup\" \"lprefix = less_eq\"", "lemma admissible_lprefixI[cont_intro]:\n    assumes \"mcont lub ord lSup lprefix f\"\n    assumes \"mcont lub ord lSup lprefix g\"\n    shows \"ccpo.admissible lub ord (\\<lambda> x. lprefix (f x) (g x))\"", "lemma llist_lift_admissible:\n    assumes \"ccpo.admissible lSup lprefix P\"\n    assumes \"\\<And> u. u \\<le> v \\<Longrightarrow> lfinite u \\<Longrightarrow> P u\"\n    shows \"P v\"", "lemma eq_LNil_conv_lnull[simp]: \"w = <> \\<longleftrightarrow> lnull w\"", "lemma Collect_lnull[simp]: \"{w. lnull w} = {<>}\"", "lemma inj_on_ltake: \"inj_on (\\<lambda> k. ltake k w) {.. llength w}\"", "lemma lnth_inf_llist'[simp]: \"lnth (inf_llist f) = f\"", "lemma not_lnull_lappend_startE[elim]:\n    assumes \"\\<not> lnull w\"\n    obtains a v\n    where \"w = <a> $ v\"", "lemma not_lnull_lappend_endE[elim]:\n    assumes \"\\<not> lnull w\"\n    obtains a v\n    where \"w = v $ <a>\"", "lemma llength_lappend_startE[elim]:\n    assumes \"llength w \\<ge> eSuc n\"\n    obtains a v\n    where \"w = <a> $ v\" \"llength v \\<ge> n\"", "lemma llength_lappend_endE[elim]:\n    assumes \"llength w \\<ge> eSuc n\"\n    obtains a v\n    where \"w = v $ <a>\" \"llength v \\<ge> n\"", "lemma llength_lappend_start'E[elim]:\n    assumes \"llength w = enat (Suc n)\"\n    obtains a v\n    where \"w = <a> $ v\" \"llength v = enat n\"", "lemma llength_lappend_end'E[elim]:\n    assumes \"llength w = enat (Suc n)\"\n    obtains a v\n    where \"w = v $ <a>\" \"llength v = enat n\"", "lemma ltake_llast[simp]:\n    assumes \"enat k < llength w\"\n    shows \"llast (ltake (enat (Suc k)) w) = w ?! k\"", "lemma linfinite_llength[dest, simp]:\n    assumes \"linfinite w\"\n    shows \"enat k < llength w\"", "lemma llist_nth_eqI[intro]:\n    assumes \"llength u = llength v\"\n    assumes \"\\<And> i. enat i < llength u \\<Longrightarrow> enat i < llength v \\<Longrightarrow> u ?! i = v ?! i\"\n    shows \"u = v\"", "lemma lscan_simps[simp]:\n    \"lscan f <> a = <a>\"\n    \"lscan f (x % xs) a = a % lscan f xs (f x a)\"", "lemma lscan_lfinite[iff]: \"lfinite (lscan f w a) \\<longleftrightarrow> lfinite w\"", "lemma lscan_llength[simp]: \"llength (lscan f w a) = eSuc (llength w)\"", "lemma lfold_llist_of[simp]: \"lfold f (llist_of xs) = fold f xs\"", "lemma finite_UNIV_llength_eq:\n    assumes \"finite (UNIV :: 'a set)\"\n    shows \"finite {w :: 'a llist. llength w = enat n}\"", "lemma finite_UNIV_llength_le:\n    assumes \"finite (UNIV :: 'a set)\"\n    shows \"finite {w :: 'a llist. llength w \\<le> enat n}\"", "lemma lprefix_ltake[dest]: \"u \\<le> v \\<Longrightarrow> u = ltake (llength u) v\"", "lemma prefixes_set: \"{v. v \\<le> w} = {ltake k w |k. k \\<le> llength w}\"", "lemma esize_prefixes[simp]: \"esize {v. v \\<le> w} = eSuc (llength w)\"", "lemma prefix_subsume: \"v \\<le> w \\<Longrightarrow> u \\<le> w \\<Longrightarrow> llength v \\<le> llength u \\<Longrightarrow> v \\<le> u\"", "lemma ltake_infinite[simp]: \"ltake \\<infinity> w = w\"", "lemma lprefix_infinite:\n    assumes \"u \\<le> v\" \"linfinite u\"\n    shows \"u = v\"", "lemma lisetI[intro]:\n      assumes \"enat i < llength w\" \"w ?! i \\<in> A\"\n      shows \"i \\<in> liset A w\"", "lemma lisetD[dest]:\n      assumes \"i \\<in> liset A w\"\n      shows \"enat i < llength w\" \"w ?! i \\<in> A\"", "lemma liset_finite:\n      assumes \"lfinite w\"\n      shows \"finite (liset A w)\"", "lemma liset_nil[simp]: \"liset A <> = {}\"", "lemma liset_cons_not_member[simp]:\n      assumes \"a \\<notin> A\"\n      shows \"liset A (a % w) = Suc ` liset A w\"", "lemma liset_cons_member[simp]:\n      assumes \"a \\<in> A\"\n      shows \"liset A (a % w) = {0} \\<union> Suc ` liset A w\"", "lemma liset_prefix:\n      assumes \"i \\<in> liset A v\" \"u \\<le> v\" \"enat i < llength u\"\n      shows \"i \\<in> liset A u\"", "lemma liset_suffix:\n      assumes \"i \\<in> liset A u\" \"u \\<le> v\"\n      shows \"i \\<in> liset A v\"", "lemma liset_ltake[simp]: \"liset A (ltake (enat k) w) = liset A w \\<inter> {..< k}\"", "lemma liset_mono[dest]: \"u \\<le> v \\<Longrightarrow> liset A u \\<subseteq> liset A v\"", "lemma liset_cont[dest]:\n      assumes \"Complete_Partial_Order.chain less_eq C\" \"C \\<noteq> {}\"\n      shows \"liset A (\\<Squnion> C) = (\\<Union> w \\<in> C. liset A w)\"", "lemma liset_mcont: \"Complete_Partial_Order2.mcont lSup lprefix Sup less_eq (liset A)\"", "lemmas mcont2mcont_liset = liset_mcont[THEN lfp.mcont2mcont, simp, cont_intro]", "lemma lselect_to_lproject: \"lselect s w = lmap fst (lproject (UNIV \\<times> s) (w \\<bar>\\<bar> iterates Suc 0))\"", "lemma lproject_to_lselect: \"lproject A w = lselect (liset A w) w\"", "lemma lproject_llength[simp]: \"llength (lproject A w) = esize (liset A w)\"", "lemma lproject_lfinite[simp]: \"lfinite (lproject A w) \\<longleftrightarrow> finite (liset A w)\"", "lemma lselect_restrict_indices[simp]: \"lselect {i \\<in> s. enat i < llength w} w = lselect s w\"", "lemma lselect_llength: \"llength (lselect s w) = esize {i \\<in> s. enat i < llength w}\"", "lemma lselect_llength_le[simp]: \"llength (lselect s w) \\<le> esize s\"", "lemma least_lselect_llength:\n      assumes \"\\<not> lnull (lselect s w)\"\n      shows \"enat (least s) < llength w\"", "lemma lselect_lnull: \"lnull (lselect s w) \\<longleftrightarrow> (\\<forall> i \\<in> s. enat i \\<ge> llength w)\"", "lemma lselect_discard_start:\n      assumes \"\\<And> i. i \\<in> s \\<Longrightarrow> k \\<le> i\"\n      shows \"lselect {i. k + i \\<in> s} (ldropn k w) = lselect s w\"", "lemma lselect_discard_end:\n      assumes \"\\<And> i. i \\<in> s \\<Longrightarrow> i < k\"\n      shows \"lselect s (ltake (enat k) w) = lselect s w\"", "lemma lselect_least:\n      assumes \"\\<not> lnull (lselect s w)\"\n      shows \"lselect s w = w ?! least s % lselect (s - {least s}) w\"", "lemma lselect_lnth[simp]:\n      assumes \"enat i < llength (lselect s w)\"\n      shows \"lselect s w ?! i = w ?! nth_least s i\"", "lemma lproject_lnth[simp]:\n      assumes \"enat i < llength (lproject A w)\"\n      shows \"lproject A w ?! i = w ?! nth_least (liset A w) i\"", "lemma lproject_ltake[simp]:\n      assumes \"enat k \\<le> llength (lproject A w)\"\n      shows \"lproject A (ltake (enat (nth_least (lift (liset A w)) k)) w) =\n        ltake (enat k) (lproject A w)\"", "lemma llength_less_llength_lselect_less:\n      \"enat i < esize s \\<and> enat (nth_least s i) < llength w \\<longleftrightarrow> enat i < llength (lselect s w)\"", "lemma lselect_lselect'':\n      assumes \"\\<And> i. i \\<in> s \\<Longrightarrow> enat i < llength w\"\n      assumes \"\\<And> i. i \\<in> t \\<Longrightarrow> enat i < llength (lselect s w)\"\n      shows \"lselect t (lselect s w) = lselect (nth_least s ` t) w\"", "lemma lselect_lselect'[simp]:\n      assumes \"\\<And> i. i \\<in> t \\<Longrightarrow> enat i < esize s\"\n      shows \"lselect t (lselect s w) = lselect (nth_least s ` t) w\"", "lemma lselect_lselect:\n      \"lselect t (lselect s w) = lselect (nth_least s ` {i \\<in> t. enat i < esize s}) w\"", "lemma lselect_lproject':\n      assumes \"\\<And> i. i \\<in> s \\<Longrightarrow> enat i < llength w\"\n      shows \"lproject A (lselect s w) = lselect (s \\<inter> liset A w) w\"", "lemma lselect_lproject[simp]: \"lproject A (lselect s w) = lselect (s \\<inter> liset A w) w\"", "lemma lproject_lselect_subset[simp]:\n      assumes \"liset A w \\<subseteq> s\"\n      shows \"lproject A (lselect s w) = lproject A w\"", "lemma lselect_prefix[intro]:\n      assumes \"u \\<le> v\"\n      shows \"lselect s u \\<le> lselect s v\"", "lemma lproject_prefix[intro]:\n      assumes \"u \\<le> v\"\n      shows \"lproject A u \\<le> lproject A v\"", "lemma lproject_prefix_limit[intro?]:\n      assumes \"\\<And> v. v \\<le> w \\<Longrightarrow> lfinite v \\<Longrightarrow> lproject A v \\<le> x\"\n      shows \"lproject A w \\<le> x\"", "lemma lproject_prefix_limit':\n      assumes \"\\<And> k. \\<exists> v. v \\<le> w \\<and> enat k < llength v \\<and> lproject A v \\<le> x\"\n      shows \"lproject A w \\<le> x\""], "translations": [["", "lemma lprefix_lSup_revert: \"lSup = Sup\" \"lprefix = less_eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lSup = Sup &&& lprefix = (\\<le>)", "by auto"], ["", "lemma admissible_lprefixI[cont_intro]:\n    assumes \"mcont lub ord lSup lprefix f\"\n    assumes \"mcont lub ord lSup lprefix g\"\n    shows \"ccpo.admissible lub ord (\\<lambda> x. lprefix (f x) (g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible lub ord (\\<lambda>x. lprefix (f x) (g x))", "using ccpo_class.admissible_leI assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>mcont ?luba ?orda Sup (\\<le>) ?f;\n   mcont ?luba ?orda Sup (\\<le>) ?g\\<rbrakk>\n  \\<Longrightarrow> ccpo.admissible ?luba ?orda\n                     (\\<lambda>x. ?f x \\<le> ?g x)\n  mcont lub ord lSup lprefix f\n  mcont lub ord lSup lprefix g\n\ngoal (1 subgoal):\n 1. ccpo.admissible lub ord (\\<lambda>x. lprefix (f x) (g x))", "unfolding lprefix_lSup_revert"], ["proof (prove)\nusing this:\n  \\<lbrakk>mcont ?luba ?orda Sup (\\<le>) ?f;\n   mcont ?luba ?orda Sup (\\<le>) ?g\\<rbrakk>\n  \\<Longrightarrow> ccpo.admissible ?luba ?orda\n                     (\\<lambda>x. ?f x \\<le> ?g x)\n  mcont lub ord Sup (\\<le>) f\n  mcont lub ord Sup (\\<le>) g\n\ngoal (1 subgoal):\n 1. ccpo.admissible lub ord (\\<lambda>x. f x \\<le> g x)", "by this"], ["", "lemma llist_lift_admissible:\n    assumes \"ccpo.admissible lSup lprefix P\"\n    assumes \"\\<And> u. u \\<le> v \\<Longrightarrow> lfinite u \\<Longrightarrow> P u\"\n    shows \"P v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P v", "using assms"], ["proof (prove)\nusing this:\n  ccpo.admissible lSup lprefix P\n  \\<lbrakk>?u \\<le> v; lfinite ?u\\<rbrakk> \\<Longrightarrow> P ?u\n\ngoal (1 subgoal):\n 1. P v", "by (metis LNil_lprefix le_llist_conv_lprefix lfinite.simps llist_gen_induct)"], ["", "abbreviation \"linfinite w \\<equiv> \\<not> lfinite w\""], ["", "notation LNil (\"<>\")"], ["", "notation LCons (infixr \"%\" 65)"], ["", "notation lzip (infixr \"\\<bar>\\<bar>\" 51)"], ["", "notation lappend (infixr \"$\" 65)"], ["", "notation lnth (infixl \"?!\" 100)"], ["", "syntax \"_llist\" :: \"args \\<Rightarrow> 'a llist\" (\"<_>\")"], ["", "translations\n    \"<a, x>\" \\<rightleftharpoons> \"a % <x>\"\n    \"<a>\" \\<rightleftharpoons> \"a % <>\""], ["", "lemma eq_LNil_conv_lnull[simp]: \"w = <> \\<longleftrightarrow> lnull w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w = <>) = lnull w", "by auto"], ["", "lemma Collect_lnull[simp]: \"{w. lnull w} = {<>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {w. lnull w} = {<>}", "by auto"], ["", "lemma inj_on_ltake: \"inj_on (\\<lambda> k. ltake k w) {.. llength w}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>k. ltake k w) {..llength w}", "by (rule inj_onI, auto, metis llength_ltake min_def)"], ["", "lemma lnth_inf_llist'[simp]: \"lnth (inf_llist f) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?!) (inf_llist f) = f", "by auto"], ["", "lemma not_lnull_lappend_startE[elim]:\n    assumes \"\\<not> lnull w\"\n    obtains a v\n    where \"w = <a> $ v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a v. w = <a> $ v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using not_lnull_conv assms"], ["proof (prove)\nusing this:\n  (\\<not> lnull ?xs) = (\\<exists>x xs'. ?xs = x % xs')\n  \\<not> lnull w\n\ngoal (1 subgoal):\n 1. (\\<And>a v. w = <a> $ v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp, metis)"], ["", "lemma not_lnull_lappend_endE[elim]:\n    assumes \"\\<not> lnull w\"\n    obtains a v\n    where \"w = v $ <a>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v a. w = v $ <a> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (cases \"lfinite w\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>v a. w = v $ <a> \\<Longrightarrow> thesis;\n     lfinite w\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>v a. w = v $ <a> \\<Longrightarrow> thesis;\n     linfinite w\\<rbrakk>\n    \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  linfinite w\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>v a. w = v $ <a> \\<Longrightarrow> thesis;\n     lfinite w\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>v a. w = v $ <a> \\<Longrightarrow> thesis;\n     linfinite w\\<rbrakk>\n    \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. w = ?v $ <?a>", "show \"w = w $ <a>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w = w $ <a>", "using lappend_inf False"], ["proof (prove)\nusing this:\n  linfinite ?xs \\<Longrightarrow> ?xs $ ?ys = ?xs\n  linfinite w\n\ngoal (1 subgoal):\n 1. w = w $ <a>", "by force"], ["proof (state)\nthis:\n  w = w $ <a>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v a. w = v $ <a> \\<Longrightarrow> thesis;\n     lfinite w\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v a. w = v $ <a> \\<Longrightarrow> thesis;\n     lfinite w\\<rbrakk>\n    \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  lfinite w\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v a. w = v $ <a> \\<Longrightarrow> thesis;\n     lfinite w\\<rbrakk>\n    \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using True assms that"], ["proof (prove)\nusing this:\n  lfinite w\n  \\<not> lnull w\n  w = ?v $ <?a> \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "proof (induct arbitrary: thesis)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       \\<lbrakk>\\<not> lnull <>;\n        \\<And>v a. <> = v $ <a> \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>xs x thesis.\n       \\<lbrakk>lfinite xs;\n        \\<And>thesis.\n           \\<lbrakk>\\<not> lnull xs;\n            \\<And>v a. xs = v $ <a> \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> lnull (x % xs);\n        \\<And>v a. x % xs = v $ <a> \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (lfinite_LNil)"], ["proof (state)\nthis:\n  \\<not> lnull <>\n  <> = ?v $ <?a> \\<Longrightarrow> thesis\n\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       \\<lbrakk>\\<not> lnull <>;\n        \\<And>v a. <> = v $ <a> \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>xs x thesis.\n       \\<lbrakk>lfinite xs;\n        \\<And>thesis.\n           \\<lbrakk>\\<not> lnull xs;\n            \\<And>v a. xs = v $ <a> \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> lnull (x % xs);\n        \\<And>v a. x % xs = v $ <a> \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using lfinite_LNil"], ["proof (prove)\nusing this:\n  \\<not> lnull <>\n  <> = ?v $ <?a> \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>xs x thesis.\n       \\<lbrakk>lfinite xs;\n        \\<And>thesis.\n           \\<lbrakk>\\<not> lnull xs;\n            \\<And>v a. xs = v $ <a> \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> lnull (x % xs);\n        \\<And>v a. x % xs = v $ <a> \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x thesis.\n       \\<lbrakk>lfinite xs;\n        \\<And>thesis.\n           \\<lbrakk>\\<not> lnull xs;\n            \\<And>v a. xs = v $ <a> \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> lnull (x % xs);\n        \\<And>v a. x % xs = v $ <a> \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (lfinite_LConsI w a)"], ["proof (state)\nthis:\n  lfinite w\n  \\<lbrakk>\\<not> lnull w;\n   \\<And>v a. w = v $ <a> \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<not> lnull (a % w)\n  a % w = ?v $ <?a> \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. \\<And>xs x thesis.\n       \\<lbrakk>lfinite xs;\n        \\<And>thesis.\n           \\<lbrakk>\\<not> lnull xs;\n            \\<And>v a. xs = v $ <a> \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> lnull (x % xs);\n        \\<And>v a. x % xs = v $ <a> \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (cases \"lnull w\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lnull w \\<Longrightarrow> thesis\n 2. \\<not> lnull w \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  \\<not> lnull w\n\ngoal (2 subgoals):\n 1. lnull w \\<Longrightarrow> thesis\n 2. \\<not> lnull w \\<Longrightarrow> thesis", "obtain b v where 1: \"w = v $ <b>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v b. w = v $ <b> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using lfinite_LConsI(2) False"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> lnull w;\n   \\<And>v a. w = v $ <a> \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<not> lnull w\n\ngoal (1 subgoal):\n 1. (\\<And>v b. w = v $ <b> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by this"], ["proof (state)\nthis:\n  w = v $ <b>\n\ngoal (2 subgoals):\n 1. lnull w \\<Longrightarrow> thesis\n 2. \\<not> lnull w \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule lfinite_LConsI(4))"], ["proof (state)\ngoal (1 subgoal):\n 1. a % w = ?v $ <?a>", "show \"a % w = (a % v) $ <b>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a % w = (a % v) $ <b>", "unfolding 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. a % v $ <b> = (a % v) $ <b>", "by simp"], ["proof (state)\nthis:\n  a % w = (a % v) $ <b>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. lnull w \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. lnull w \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  lnull w\n\ngoal (1 subgoal):\n 1. lnull w \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule lfinite_LConsI(4))"], ["proof (state)\ngoal (1 subgoal):\n 1. a % w = ?v $ <?a>", "show \"a % w = <> $ <a>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a % w = <> $ <a>", "using True"], ["proof (prove)\nusing this:\n  lnull w\n\ngoal (1 subgoal):\n 1. a % w = <> $ <a>", "by simp"], ["proof (state)\nthis:\n  a % w = <> $ <a>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma llength_lappend_startE[elim]:\n    assumes \"llength w \\<ge> eSuc n\"\n    obtains a v\n    where \"w = <a> $ v\" \"llength v \\<ge> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a v.\n        \\<lbrakk>w = <a> $ v; n \\<le> llength v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>a v.\n        \\<lbrakk>w = <a> $ v; n \\<le> llength v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have 1: \"\\<not> lnull w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lnull w", "using assms"], ["proof (prove)\nusing this:\n  eSuc n \\<le> llength w\n\ngoal (1 subgoal):\n 1. \\<not> lnull w", "by auto"], ["proof (state)\nthis:\n  \\<not> lnull w\n\ngoal (1 subgoal):\n 1. (\\<And>a v.\n        \\<lbrakk>w = <a> $ v; n \\<le> llength v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using assms 1 that"], ["proof (prove)\nusing this:\n  eSuc n \\<le> llength w\n  \\<not> lnull w\n  \\<lbrakk>w = <?a> $ ?v; n \\<le> llength ?v\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma llength_lappend_endE[elim]:\n    assumes \"llength w \\<ge> eSuc n\"\n    obtains a v\n    where \"w = v $ <a>\" \"llength v \\<ge> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v a.\n        \\<lbrakk>w = v $ <a>; n \\<le> llength v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>v a.\n        \\<lbrakk>w = v $ <a>; n \\<le> llength v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have 1: \"\\<not> lnull w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lnull w", "using assms"], ["proof (prove)\nusing this:\n  eSuc n \\<le> llength w\n\ngoal (1 subgoal):\n 1. \\<not> lnull w", "by auto"], ["proof (state)\nthis:\n  \\<not> lnull w\n\ngoal (1 subgoal):\n 1. (\\<And>v a.\n        \\<lbrakk>w = v $ <a>; n \\<le> llength v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using assms 1 that"], ["proof (prove)\nusing this:\n  eSuc n \\<le> llength w\n  \\<not> lnull w\n  \\<lbrakk>w = ?v $ <?a>; n \\<le> llength ?v\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma llength_lappend_start'E[elim]:\n    assumes \"llength w = enat (Suc n)\"\n    obtains a v\n    where \"w = <a> $ v\" \"llength v = enat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a v.\n        \\<lbrakk>w = <a> $ v; llength v = enat n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>a v.\n        \\<lbrakk>w = <a> $ v; llength v = enat n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have 1: \"llength w \\<ge> eSuc (enat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eSuc (enat n) \\<le> llength w", "using assms"], ["proof (prove)\nusing this:\n  llength w = enat (Suc n)\n\ngoal (1 subgoal):\n 1. eSuc (enat n) \\<le> llength w", "by simp"], ["proof (state)\nthis:\n  eSuc (enat n) \\<le> llength w\n\ngoal (1 subgoal):\n 1. (\\<And>a v.\n        \\<lbrakk>w = <a> $ v; llength v = enat n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain a v where 2: \"w = <a> $ v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a v. w = <a> $ v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 1"], ["proof (prove)\nusing this:\n  eSuc (enat n) \\<le> llength w\n\ngoal (1 subgoal):\n 1. (\\<And>a v. w = <a> $ v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  w = <a> $ v\n\ngoal (1 subgoal):\n 1. (\\<And>a v.\n        \\<lbrakk>w = <a> $ v; llength v = enat n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. w = <?a> $ ?v\n 2. llength ?v = enat n", "show \"w = <a> $ v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w = <a> $ v", "using 2(1)"], ["proof (prove)\nusing this:\n  w = <a> $ v\n\ngoal (1 subgoal):\n 1. w = <a> $ v", "by this"], ["proof (state)\nthis:\n  w = <a> $ v\n\ngoal (1 subgoal):\n 1. llength v = enat n", "show \"llength v = enat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength v = enat n", "using assms"], ["proof (prove)\nusing this:\n  llength w = enat (Suc n)\n\ngoal (1 subgoal):\n 1. llength v = enat n", "unfolding 2(1)"], ["proof (prove)\nusing this:\n  llength (<a> $ v) = enat (Suc n)\n\ngoal (1 subgoal):\n 1. llength v = enat n", "by (simp, metis eSuc_enat eSuc_inject)"], ["proof (state)\nthis:\n  llength v = enat n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma llength_lappend_end'E[elim]:\n    assumes \"llength w = enat (Suc n)\"\n    obtains a v\n    where \"w = v $ <a>\" \"llength v = enat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v a.\n        \\<lbrakk>w = v $ <a>; llength v = enat n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>v a.\n        \\<lbrakk>w = v $ <a>; llength v = enat n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have 1: \"llength w \\<ge> eSuc (enat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eSuc (enat n) \\<le> llength w", "using assms"], ["proof (prove)\nusing this:\n  llength w = enat (Suc n)\n\ngoal (1 subgoal):\n 1. eSuc (enat n) \\<le> llength w", "by simp"], ["proof (state)\nthis:\n  eSuc (enat n) \\<le> llength w\n\ngoal (1 subgoal):\n 1. (\\<And>v a.\n        \\<lbrakk>w = v $ <a>; llength v = enat n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain a v where 2: \"w = v $ <a>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v a. w = v $ <a> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 1"], ["proof (prove)\nusing this:\n  eSuc (enat n) \\<le> llength w\n\ngoal (1 subgoal):\n 1. (\\<And>v a. w = v $ <a> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  w = v $ <a>\n\ngoal (1 subgoal):\n 1. (\\<And>v a.\n        \\<lbrakk>w = v $ <a>; llength v = enat n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. w = ?v $ <?a>\n 2. llength ?v = enat n", "show \"w = v $ <a>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w = v $ <a>", "using 2(1)"], ["proof (prove)\nusing this:\n  w = v $ <a>\n\ngoal (1 subgoal):\n 1. w = v $ <a>", "by this"], ["proof (state)\nthis:\n  w = v $ <a>\n\ngoal (1 subgoal):\n 1. llength v = enat n", "show \"llength v = enat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength v = enat n", "using assms"], ["proof (prove)\nusing this:\n  llength w = enat (Suc n)\n\ngoal (1 subgoal):\n 1. llength v = enat n", "unfolding 2(1)"], ["proof (prove)\nusing this:\n  llength (v $ <a>) = enat (Suc n)\n\ngoal (1 subgoal):\n 1. llength v = enat n", "by (simp, metis eSuc_enat eSuc_inject)"], ["proof (state)\nthis:\n  llength v = enat n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ltake_llast[simp]:\n    assumes \"enat k < llength w\"\n    shows \"llast (ltake (enat (Suc k)) w) = w ?! k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llast (ltake (enat (Suc k)) w) = w ?! k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. llast (ltake (enat (Suc k)) w) = w ?! k", "have 1: \"llength (ltake (enat (Suc k)) w) = eSuc (enat k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (ltake (enat (Suc k)) w) = eSuc (enat k)", "using min.absorb_iff1 assms"], ["proof (prove)\nusing this:\n  (?a \\<le> ?b) = (min ?a ?b = ?a)\n  enat k < llength w\n\ngoal (1 subgoal):\n 1. llength (ltake (enat (Suc k)) w) = eSuc (enat k)", "by auto"], ["proof (state)\nthis:\n  llength (ltake (enat (Suc k)) w) = eSuc (enat k)\n\ngoal (1 subgoal):\n 1. llast (ltake (enat (Suc k)) w) = w ?! k", "have \"llast (ltake (enat (Suc k)) w) = ltake (enat (Suc k)) w ?! k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llast (ltake (enat (Suc k)) w) = ltake (enat (Suc k)) w ?! k", "using llast_conv_lnth 1"], ["proof (prove)\nusing this:\n  llength ?xs = eSuc (enat ?n) \\<Longrightarrow> llast ?xs = ?xs ?! ?n\n  llength (ltake (enat (Suc k)) w) = eSuc (enat k)\n\ngoal (1 subgoal):\n 1. llast (ltake (enat (Suc k)) w) = ltake (enat (Suc k)) w ?! k", "by this"], ["proof (state)\nthis:\n  llast (ltake (enat (Suc k)) w) = ltake (enat (Suc k)) w ?! k\n\ngoal (1 subgoal):\n 1. llast (ltake (enat (Suc k)) w) = w ?! k", "also"], ["proof (state)\nthis:\n  llast (ltake (enat (Suc k)) w) = ltake (enat (Suc k)) w ?! k\n\ngoal (1 subgoal):\n 1. llast (ltake (enat (Suc k)) w) = w ?! k", "have \"\\<dots> = w ?! k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake (enat (Suc k)) w ?! k = w ?! k", "by (rule lnth_ltake, simp)"], ["proof (state)\nthis:\n  ltake (enat (Suc k)) w ?! k = w ?! k\n\ngoal (1 subgoal):\n 1. llast (ltake (enat (Suc k)) w) = w ?! k", "finally"], ["proof (chain)\npicking this:\n  llast (ltake (enat (Suc k)) w) = w ?! k", "show ?thesis"], ["proof (prove)\nusing this:\n  llast (ltake (enat (Suc k)) w) = w ?! k\n\ngoal (1 subgoal):\n 1. llast (ltake (enat (Suc k)) w) = w ?! k", "by this"], ["proof (state)\nthis:\n  llast (ltake (enat (Suc k)) w) = w ?! k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma linfinite_llength[dest, simp]:\n    assumes \"linfinite w\"\n    shows \"enat k < llength w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat k < llength w", "using assms not_lfinite_llength"], ["proof (prove)\nusing this:\n  linfinite w\n  linfinite ?xs \\<Longrightarrow> llength ?xs = \\<infinity>\n\ngoal (1 subgoal):\n 1. enat k < llength w", "by force"], ["", "lemma llist_nth_eqI[intro]:\n    assumes \"llength u = llength v\"\n    assumes \"\\<And> i. enat i < llength u \\<Longrightarrow> enat i < llength v \\<Longrightarrow> u ?! i = v ?! i\"\n    shows \"u = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u = v", "using assms"], ["proof (prove)\nusing this:\n  llength u = llength v\n  \\<lbrakk>enat ?i < llength u; enat ?i < llength v\\<rbrakk>\n  \\<Longrightarrow> u ?! ?i = v ?! ?i\n\ngoal (1 subgoal):\n 1. u = v", "proof (coinduction arbitrary: u v)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>llength u = llength v;\n        \\<forall>i.\n           enat i < llength u \\<longrightarrow>\n           enat i < llength v \\<longrightarrow> u ?! i = v ?! i\\<rbrakk>\n       \\<Longrightarrow> lnull u = lnull v \\<and>\n                         (\\<not> lnull u \\<longrightarrow>\n                          \\<not> lnull v \\<longrightarrow>\n                          lhd u = lhd v \\<and>\n                          (\\<exists>ua va.\n                              ltl u = ua \\<and>\n                              ltl v = va \\<and>\n                              llength ua = llength va \\<and>\n                              (\\<forall>i.\n                                  enat i < llength ua \\<longrightarrow>\n                                  enat i < llength va \\<longrightarrow>\n                                  ua ?! i = va ?! i)))", "case Eq_llist"], ["proof (state)\nthis:\n  llength u = llength v\n  \\<forall>i.\n     enat i < llength u \\<longrightarrow>\n     enat i < llength v \\<longrightarrow> u ?! i = v ?! i\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>llength u = llength v;\n        \\<forall>i.\n           enat i < llength u \\<longrightarrow>\n           enat i < llength v \\<longrightarrow> u ?! i = v ?! i\\<rbrakk>\n       \\<Longrightarrow> lnull u = lnull v \\<and>\n                         (\\<not> lnull u \\<longrightarrow>\n                          \\<not> lnull v \\<longrightarrow>\n                          lhd u = lhd v \\<and>\n                          (\\<exists>ua va.\n                              ltl u = ua \\<and>\n                              ltl v = va \\<and>\n                              llength ua = llength va \\<and>\n                              (\\<forall>i.\n                                  enat i < llength ua \\<longrightarrow>\n                                  enat i < llength va \\<longrightarrow>\n                                  ua ?! i = va ?! i)))", "have 10: \"llength u = llength v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength u = llength v", "using Eq_llist"], ["proof (prove)\nusing this:\n  llength u = llength v\n  \\<forall>i.\n     enat i < llength u \\<longrightarrow>\n     enat i < llength v \\<longrightarrow> u ?! i = v ?! i\n\ngoal (1 subgoal):\n 1. llength u = llength v", "by auto"], ["proof (state)\nthis:\n  llength u = llength v\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>llength u = llength v;\n        \\<forall>i.\n           enat i < llength u \\<longrightarrow>\n           enat i < llength v \\<longrightarrow> u ?! i = v ?! i\\<rbrakk>\n       \\<Longrightarrow> lnull u = lnull v \\<and>\n                         (\\<not> lnull u \\<longrightarrow>\n                          \\<not> lnull v \\<longrightarrow>\n                          lhd u = lhd v \\<and>\n                          (\\<exists>ua va.\n                              ltl u = ua \\<and>\n                              ltl v = va \\<and>\n                              llength ua = llength va \\<and>\n                              (\\<forall>i.\n                                  enat i < llength ua \\<longrightarrow>\n                                  enat i < llength va \\<longrightarrow>\n                                  ua ?! i = va ?! i)))", "have 11: \"\\<And> i. enat i < llength u \\<Longrightarrow>  enat i < llength v \\<Longrightarrow> u ?! i = v ?! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>enat i < llength u; enat i < llength v\\<rbrakk>\n       \\<Longrightarrow> u ?! i = v ?! i", "using Eq_llist"], ["proof (prove)\nusing this:\n  llength u = llength v\n  \\<forall>i.\n     enat i < llength u \\<longrightarrow>\n     enat i < llength v \\<longrightarrow> u ?! i = v ?! i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>enat i < llength u; enat i < llength v\\<rbrakk>\n       \\<Longrightarrow> u ?! i = v ?! i", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>enat ?i < llength u; enat ?i < llength v\\<rbrakk>\n  \\<Longrightarrow> u ?! ?i = v ?! ?i\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>llength u = llength v;\n        \\<forall>i.\n           enat i < llength u \\<longrightarrow>\n           enat i < llength v \\<longrightarrow> u ?! i = v ?! i\\<rbrakk>\n       \\<Longrightarrow> lnull u = lnull v \\<and>\n                         (\\<not> lnull u \\<longrightarrow>\n                          \\<not> lnull v \\<longrightarrow>\n                          lhd u = lhd v \\<and>\n                          (\\<exists>ua va.\n                              ltl u = ua \\<and>\n                              ltl v = va \\<and>\n                              llength ua = llength va \\<and>\n                              (\\<forall>i.\n                                  enat i < llength ua \\<longrightarrow>\n                                  enat i < llength va \\<longrightarrow>\n                                  ua ?! i = va ?! i)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull u = lnull v \\<and>\n    (\\<not> lnull u \\<longrightarrow>\n     \\<not> lnull v \\<longrightarrow>\n     lhd u = lhd v \\<and>\n     (\\<exists>u v.\n         ltl u = u \\<and>\n         ltl v = v \\<and>\n         llength u = llength v \\<and>\n         (\\<forall>i.\n             enat i < llength u \\<longrightarrow>\n             enat i < llength v \\<longrightarrow> u ?! i = v ?! i)))", "proof (intro conjI impI exI allI)"], ["proof (state)\ngoal (6 subgoals):\n 1. lnull u = lnull v\n 2. \\<lbrakk>\\<not> lnull u; \\<not> lnull v\\<rbrakk>\n    \\<Longrightarrow> lhd u = lhd v\n 3. \\<lbrakk>\\<not> lnull u; \\<not> lnull v\\<rbrakk>\n    \\<Longrightarrow> ltl u = ?u4\n 4. \\<lbrakk>\\<not> lnull u; \\<not> lnull v\\<rbrakk>\n    \\<Longrightarrow> ltl v = ?v5\n 5. \\<lbrakk>\\<not> lnull u; \\<not> lnull v\\<rbrakk>\n    \\<Longrightarrow> llength ?u4 = llength ?v5\n 6. \\<And>i.\n       \\<lbrakk>\\<not> lnull u; \\<not> lnull v; enat i < llength ?u4;\n        enat i < llength ?v5\\<rbrakk>\n       \\<Longrightarrow> ?u4 ?! i = ?v5 ?! i", "show \"lnull u \\<longleftrightarrow> lnull v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull u = lnull v", "using 10"], ["proof (prove)\nusing this:\n  llength u = llength v\n\ngoal (1 subgoal):\n 1. lnull u = lnull v", "by auto"], ["proof (state)\nthis:\n  lnull u = lnull v\n\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<not> lnull u; \\<not> lnull v\\<rbrakk>\n    \\<Longrightarrow> lhd u = lhd v\n 2. \\<lbrakk>\\<not> lnull u; \\<not> lnull v\\<rbrakk>\n    \\<Longrightarrow> ltl u = ?u4\n 3. \\<lbrakk>\\<not> lnull u; \\<not> lnull v\\<rbrakk>\n    \\<Longrightarrow> ltl v = ?v5\n 4. \\<lbrakk>\\<not> lnull u; \\<not> lnull v\\<rbrakk>\n    \\<Longrightarrow> llength ?u4 = llength ?v5\n 5. \\<And>i.\n       \\<lbrakk>\\<not> lnull u; \\<not> lnull v; enat i < llength ?u4;\n        enat i < llength ?v5\\<rbrakk>\n       \\<Longrightarrow> ?u4 ?! i = ?v5 ?! i", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<not> lnull u; \\<not> lnull v\\<rbrakk>\n    \\<Longrightarrow> lhd u = lhd v\n 2. \\<lbrakk>\\<not> lnull u; \\<not> lnull v\\<rbrakk>\n    \\<Longrightarrow> ltl u = ?u4\n 3. \\<lbrakk>\\<not> lnull u; \\<not> lnull v\\<rbrakk>\n    \\<Longrightarrow> ltl v = ?v5\n 4. \\<lbrakk>\\<not> lnull u; \\<not> lnull v\\<rbrakk>\n    \\<Longrightarrow> llength ?u4 = llength ?v5\n 5. \\<And>i.\n       \\<lbrakk>\\<not> lnull u; \\<not> lnull v; enat i < llength ?u4;\n        enat i < llength ?v5\\<rbrakk>\n       \\<Longrightarrow> ?u4 ?! i = ?v5 ?! i", "assume 20: \"\\<not> lnull u\" \"\\<not> lnull v\""], ["proof (state)\nthis:\n  \\<not> lnull u\n  \\<not> lnull v\n\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<not> lnull u; \\<not> lnull v\\<rbrakk>\n    \\<Longrightarrow> lhd u = lhd v\n 2. \\<lbrakk>\\<not> lnull u; \\<not> lnull v\\<rbrakk>\n    \\<Longrightarrow> ltl u = ?u4\n 3. \\<lbrakk>\\<not> lnull u; \\<not> lnull v\\<rbrakk>\n    \\<Longrightarrow> ltl v = ?v5\n 4. \\<lbrakk>\\<not> lnull u; \\<not> lnull v\\<rbrakk>\n    \\<Longrightarrow> llength ?u4 = llength ?v5\n 5. \\<And>i.\n       \\<lbrakk>\\<not> lnull u; \\<not> lnull v; enat i < llength ?u4;\n        enat i < llength ?v5\\<rbrakk>\n       \\<Longrightarrow> ?u4 ?! i = ?v5 ?! i", "show \"lhd u = lhd v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhd u = lhd v", "using lhd_conv_lnth enat_0 11 20"], ["proof (prove)\nusing this:\n  \\<not> lnull ?xs \\<Longrightarrow> lhd ?xs = ?xs ?! 0\n  enat 0 = 0\n  \\<lbrakk>enat ?i < llength u; enat ?i < llength v\\<rbrakk>\n  \\<Longrightarrow> u ?! ?i = v ?! ?i\n  \\<not> lnull u\n  \\<not> lnull v\n\ngoal (1 subgoal):\n 1. lhd u = lhd v", "by force"], ["proof (state)\nthis:\n  lhd u = lhd v\n\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<not> lnull u; \\<not> lnull v\\<rbrakk>\n    \\<Longrightarrow> ltl u = ?u4\n 2. \\<lbrakk>\\<not> lnull u; \\<not> lnull v\\<rbrakk>\n    \\<Longrightarrow> ltl v = ?v5\n 3. \\<lbrakk>\\<not> lnull u; \\<not> lnull v\\<rbrakk>\n    \\<Longrightarrow> llength ?u4 = llength ?v5\n 4. \\<And>i.\n       \\<lbrakk>\\<not> lnull u; \\<not> lnull v; enat i < llength ?u4;\n        enat i < llength ?v5\\<rbrakk>\n       \\<Longrightarrow> ?u4 ?! i = ?v5 ?! i", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<not> lnull u; \\<not> lnull v\\<rbrakk>\n    \\<Longrightarrow> ltl u = ?u4\n 2. \\<lbrakk>\\<not> lnull u; \\<not> lnull v\\<rbrakk>\n    \\<Longrightarrow> ltl v = ?v5\n 3. \\<lbrakk>\\<not> lnull u; \\<not> lnull v\\<rbrakk>\n    \\<Longrightarrow> llength ?u4 = llength ?v5\n 4. \\<And>i.\n       \\<lbrakk>\\<not> lnull u; \\<not> lnull v; enat i < llength ?u4;\n        enat i < llength ?v5\\<rbrakk>\n       \\<Longrightarrow> ?u4 ?! i = ?v5 ?! i", "show \"ltl u = ltl u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl u = ltl u", "by rule"], ["proof (state)\nthis:\n  ltl u = ltl u\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<not> lnull u; \\<not> lnull v\\<rbrakk>\n    \\<Longrightarrow> ltl v = ?v5\n 2. \\<lbrakk>\\<not> lnull u; \\<not> lnull v\\<rbrakk>\n    \\<Longrightarrow> llength (ltl u) = llength ?v5\n 3. \\<And>i.\n       \\<lbrakk>\\<not> lnull u; \\<not> lnull v; enat i < llength (ltl u);\n        enat i < llength ?v5\\<rbrakk>\n       \\<Longrightarrow> ltl u ?! i = ?v5 ?! i", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<not> lnull u; \\<not> lnull v\\<rbrakk>\n    \\<Longrightarrow> ltl v = ?v5\n 2. \\<lbrakk>\\<not> lnull u; \\<not> lnull v\\<rbrakk>\n    \\<Longrightarrow> llength (ltl u) = llength ?v5\n 3. \\<And>i.\n       \\<lbrakk>\\<not> lnull u; \\<not> lnull v; enat i < llength (ltl u);\n        enat i < llength ?v5\\<rbrakk>\n       \\<Longrightarrow> ltl u ?! i = ?v5 ?! i", "show \"ltl v = ltl v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl v = ltl v", "by rule"], ["proof (state)\nthis:\n  ltl v = ltl v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> lnull u; \\<not> lnull v\\<rbrakk>\n    \\<Longrightarrow> llength (ltl u) = llength (ltl v)\n 2. \\<And>i.\n       \\<lbrakk>\\<not> lnull u; \\<not> lnull v; enat i < llength (ltl u);\n        enat i < llength (ltl v)\\<rbrakk>\n       \\<Longrightarrow> ltl u ?! i = ltl v ?! i", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> lnull u; \\<not> lnull v\\<rbrakk>\n    \\<Longrightarrow> llength (ltl u) = llength (ltl v)\n 2. \\<And>i.\n       \\<lbrakk>\\<not> lnull u; \\<not> lnull v; enat i < llength (ltl u);\n        enat i < llength (ltl v)\\<rbrakk>\n       \\<Longrightarrow> ltl u ?! i = ltl v ?! i", "assume 30: \"\\<not> lnull u\" \"\\<not> lnull v\""], ["proof (state)\nthis:\n  \\<not> lnull u\n  \\<not> lnull v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> lnull u; \\<not> lnull v\\<rbrakk>\n    \\<Longrightarrow> llength (ltl u) = llength (ltl v)\n 2. \\<And>i.\n       \\<lbrakk>\\<not> lnull u; \\<not> lnull v; enat i < llength (ltl u);\n        enat i < llength (ltl v)\\<rbrakk>\n       \\<Longrightarrow> ltl u ?! i = ltl v ?! i", "show \"llength (ltl u) = llength (ltl v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (ltl u) = llength (ltl v)", "using 10 30"], ["proof (prove)\nusing this:\n  llength u = llength v\n  \\<not> lnull u\n  \\<not> lnull v\n\ngoal (1 subgoal):\n 1. llength (ltl u) = llength (ltl v)", "by force"], ["proof (state)\nthis:\n  llength (ltl u) = llength (ltl v)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<not> lnull u; \\<not> lnull v; enat i < llength (ltl u);\n        enat i < llength (ltl v)\\<rbrakk>\n       \\<Longrightarrow> ltl u ?! i = ltl v ?! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<not> lnull u; \\<not> lnull v; enat i < llength (ltl u);\n        enat i < llength (ltl v)\\<rbrakk>\n       \\<Longrightarrow> ltl u ?! i = ltl v ?! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<not> lnull u; \\<not> lnull v; enat i < llength (ltl u);\n        enat i < llength (ltl v)\\<rbrakk>\n       \\<Longrightarrow> ltl u ?! i = ltl v ?! i", "assume 40: \"\\<not> lnull u\" \"\\<not> lnull v\" \"enat i < llength (ltl u)\" \"enat i < llength (ltl v)\""], ["proof (state)\nthis:\n  \\<not> lnull u\n  \\<not> lnull v\n  enat i < llength (ltl u)\n  enat i < llength (ltl v)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<not> lnull u; \\<not> lnull v; enat i < llength (ltl u);\n        enat i < llength (ltl v)\\<rbrakk>\n       \\<Longrightarrow> ltl u ?! i = ltl v ?! i", "have 41: \"u ?! Suc i = v ?! Suc i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u ?! Suc i = v ?! Suc i", "proof (rule 11)"], ["proof (state)\ngoal (2 subgoals):\n 1. enat (Suc i) < llength u\n 2. enat (Suc i) < llength v", "show \"enat (Suc i) < llength u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat (Suc i) < llength u", "using Suc_ile_eq 40(1) 40(3)"], ["proof (prove)\nusing this:\n  (enat (Suc ?m) \\<le> ?n) = (enat ?m < ?n)\n  \\<not> lnull u\n  enat i < llength (ltl u)\n\ngoal (1 subgoal):\n 1. enat (Suc i) < llength u", "by auto"], ["proof (state)\nthis:\n  enat (Suc i) < llength u\n\ngoal (1 subgoal):\n 1. enat (Suc i) < llength v", "show \"enat (Suc i) < llength v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat (Suc i) < llength v", "using Suc_ile_eq 40(2) 40(4)"], ["proof (prove)\nusing this:\n  (enat (Suc ?m) \\<le> ?n) = (enat ?m < ?n)\n  \\<not> lnull v\n  enat i < llength (ltl v)\n\ngoal (1 subgoal):\n 1. enat (Suc i) < llength v", "by auto"], ["proof (state)\nthis:\n  enat (Suc i) < llength v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u ?! Suc i = v ?! Suc i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<not> lnull u; \\<not> lnull v; enat i < llength (ltl u);\n        enat i < llength (ltl v)\\<rbrakk>\n       \\<Longrightarrow> ltl u ?! i = ltl v ?! i", "show \"ltl u ?! i = ltl v ?! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl u ?! i = ltl v ?! i", "using lnth_ltl 40(1-2) 41"], ["proof (prove)\nusing this:\n  \\<not> lnull ?xs \\<Longrightarrow> ltl ?xs ?! ?n = ?xs ?! Suc ?n\n  \\<not> lnull u\n  \\<not> lnull v\n  u ?! Suc i = v ?! Suc i\n\ngoal (1 subgoal):\n 1. ltl u ?! i = ltl v ?! i", "by metis"], ["proof (state)\nthis:\n  ltl u ?! i = ltl v ?! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lnull u = lnull v \\<and>\n  (\\<not> lnull u \\<longrightarrow>\n   \\<not> lnull v \\<longrightarrow>\n   lhd u = lhd v \\<and>\n   (\\<exists>u v.\n       ltl u = u \\<and>\n       ltl v = v \\<and>\n       llength u = llength v \\<and>\n       (\\<forall>i.\n           enat i < llength u \\<longrightarrow>\n           enat i < llength v \\<longrightarrow> u ?! i = v ?! i)))\n\ngoal:\nNo subgoals!", "qed"], ["", "primcorec lscan :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'b) \\<Rightarrow> 'a llist \\<Rightarrow> 'b \\<Rightarrow> 'b llist\"\n    where \"lscan f w a = (case w of <> \\<Rightarrow> <a> | x % xs \\<Rightarrow> a % lscan f xs (f x a))\""], ["", "lemma lscan_simps[simp]:\n    \"lscan f <> a = <a>\"\n    \"lscan f (x % xs) a = a % lscan f xs (f x a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lscan f <> a = <a> &&& lscan f (x % xs) a = a % lscan f xs (f x a)", "by (metis llist.simps(4) lscan.code, metis llist.simps(5) lscan.code)"], ["", "lemma lscan_lfinite[iff]: \"lfinite (lscan f w a) \\<longleftrightarrow> lfinite w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite (lscan f w a) = lfinite w", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. lfinite (lscan f w a) \\<Longrightarrow> lfinite w\n 2. lfinite w \\<Longrightarrow> lfinite (lscan f w a)", "assume \"lfinite (lscan f w a)\""], ["proof (state)\nthis:\n  lfinite (lscan f w a)\n\ngoal (2 subgoals):\n 1. lfinite (lscan f w a) \\<Longrightarrow> lfinite w\n 2. lfinite w \\<Longrightarrow> lfinite (lscan f w a)", "thus \"lfinite w\""], ["proof (prove)\nusing this:\n  lfinite (lscan f w a)\n\ngoal (1 subgoal):\n 1. lfinite w", "proof (induct \"lscan f w a\" arbitrary: w a rule: lfinite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>w a. lnull (lscan f w a) \\<Longrightarrow> lfinite w\n 2. \\<And>w a.\n       \\<lbrakk>lfinite (lscan f w a); \\<not> lnull (lscan f w a);\n        \\<And>wa aa.\n           ltl (lscan f w a) = lscan f wa aa \\<Longrightarrow>\n           lfinite wa\\<rbrakk>\n       \\<Longrightarrow> lfinite w", "case LNil"], ["proof (state)\nthis:\n  lnull (lscan f w a)\n\ngoal (2 subgoals):\n 1. \\<And>w a. lnull (lscan f w a) \\<Longrightarrow> lfinite w\n 2. \\<And>w a.\n       \\<lbrakk>lfinite (lscan f w a); \\<not> lnull (lscan f w a);\n        \\<And>wa aa.\n           ltl (lscan f w a) = lscan f wa aa \\<Longrightarrow>\n           lfinite wa\\<rbrakk>\n       \\<Longrightarrow> lfinite w", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite w", "using LNil"], ["proof (prove)\nusing this:\n  lnull (lscan f w a)\n\ngoal (1 subgoal):\n 1. lfinite w", "by simp"], ["proof (state)\nthis:\n  lfinite w\n\ngoal (1 subgoal):\n 1. \\<And>w a.\n       \\<lbrakk>lfinite (lscan f w a); \\<not> lnull (lscan f w a);\n        \\<And>wa aa.\n           ltl (lscan f w a) = lscan f wa aa \\<Longrightarrow>\n           lfinite wa\\<rbrakk>\n       \\<Longrightarrow> lfinite w", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w a.\n       \\<lbrakk>lfinite (lscan f w a); \\<not> lnull (lscan f w a);\n        \\<And>wa aa.\n           ltl (lscan f w a) = lscan f wa aa \\<Longrightarrow>\n           lfinite wa\\<rbrakk>\n       \\<Longrightarrow> lfinite w", "case LCons"], ["proof (state)\nthis:\n  lfinite (lscan f w a)\n  \\<not> lnull (lscan f w a)\n  ltl (lscan f w a) = lscan f ?w ?a \\<Longrightarrow> lfinite ?w\n\ngoal (1 subgoal):\n 1. \\<And>w a.\n       \\<lbrakk>lfinite (lscan f w a); \\<not> lnull (lscan f w a);\n        \\<And>wa aa.\n           ltl (lscan f w a) = lscan f wa aa \\<Longrightarrow>\n           lfinite wa\\<rbrakk>\n       \\<Longrightarrow> lfinite w", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite w", "by (cases w, simp, simp add: LCons(3))"], ["proof (state)\nthis:\n  lfinite w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lfinite w\n\ngoal (1 subgoal):\n 1. lfinite w \\<Longrightarrow> lfinite (lscan f w a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. lfinite w \\<Longrightarrow> lfinite (lscan f w a)", "assume \"lfinite w\""], ["proof (state)\nthis:\n  lfinite w\n\ngoal (1 subgoal):\n 1. lfinite w \\<Longrightarrow> lfinite (lscan f w a)", "thus \"lfinite (lscan f w a)\""], ["proof (prove)\nusing this:\n  lfinite w\n\ngoal (1 subgoal):\n 1. lfinite (lscan f w a)", "by (induct arbitrary: a, auto)"], ["proof (state)\nthis:\n  lfinite (lscan f w a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lscan_llength[simp]: \"llength (lscan f w a) = eSuc (llength w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (lscan f w a) = eSuc (llength w)", "proof (cases \"lfinite w\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lfinite w \\<Longrightarrow> llength (lscan f w a) = eSuc (llength w)\n 2. linfinite w \\<Longrightarrow> llength (lscan f w a) = eSuc (llength w)", "case False"], ["proof (state)\nthis:\n  linfinite w\n\ngoal (2 subgoals):\n 1. lfinite w \\<Longrightarrow> llength (lscan f w a) = eSuc (llength w)\n 2. linfinite w \\<Longrightarrow> llength (lscan f w a) = eSuc (llength w)", "have 1: \"llength (lscan f w a) = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (lscan f w a) = \\<infinity>", "using not_lfinite_llength False"], ["proof (prove)\nusing this:\n  linfinite ?xs \\<Longrightarrow> llength ?xs = \\<infinity>\n  linfinite w\n\ngoal (1 subgoal):\n 1. llength (lscan f w a) = \\<infinity>", "by auto"], ["proof (state)\nthis:\n  llength (lscan f w a) = \\<infinity>\n\ngoal (2 subgoals):\n 1. lfinite w \\<Longrightarrow> llength (lscan f w a) = eSuc (llength w)\n 2. linfinite w \\<Longrightarrow> llength (lscan f w a) = eSuc (llength w)", "have 2: \"llength w = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength w = \\<infinity>", "using not_lfinite_llength False"], ["proof (prove)\nusing this:\n  linfinite ?xs \\<Longrightarrow> llength ?xs = \\<infinity>\n  linfinite w\n\ngoal (1 subgoal):\n 1. llength w = \\<infinity>", "by auto"], ["proof (state)\nthis:\n  llength w = \\<infinity>\n\ngoal (2 subgoals):\n 1. lfinite w \\<Longrightarrow> llength (lscan f w a) = eSuc (llength w)\n 2. linfinite w \\<Longrightarrow> llength (lscan f w a) = eSuc (llength w)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (lscan f w a) = eSuc (llength w)", "using 1 2"], ["proof (prove)\nusing this:\n  llength (lscan f w a) = \\<infinity>\n  llength w = \\<infinity>\n\ngoal (1 subgoal):\n 1. llength (lscan f w a) = eSuc (llength w)", "by simp"], ["proof (state)\nthis:\n  llength (lscan f w a) = eSuc (llength w)\n\ngoal (1 subgoal):\n 1. lfinite w \\<Longrightarrow> llength (lscan f w a) = eSuc (llength w)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. lfinite w \\<Longrightarrow> llength (lscan f w a) = eSuc (llength w)", "case True"], ["proof (state)\nthis:\n  lfinite w\n\ngoal (1 subgoal):\n 1. lfinite w \\<Longrightarrow> llength (lscan f w a) = eSuc (llength w)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (lscan f w a) = eSuc (llength w)", "using True"], ["proof (prove)\nusing this:\n  lfinite w\n\ngoal (1 subgoal):\n 1. llength (lscan f w a) = eSuc (llength w)", "by (induct arbitrary: a, auto)"], ["proof (state)\nthis:\n  llength (lscan f w a) = eSuc (llength w)\n\ngoal:\nNo subgoals!", "qed"], ["", "function lfold :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'b) \\<Rightarrow> 'a llist \\<Rightarrow> 'b \\<Rightarrow> 'b\"\n    where \"lfinite w \\<Longrightarrow> lfold f w = fold f (list_of w)\" | \"linfinite w \\<Longrightarrow> lfold f w = id\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>w f.\n                   \\<lbrakk>lfinite w; x = (f, w)\\<rbrakk>\n                   \\<Longrightarrow> P;\n        \\<And>w f.\n           \\<lbrakk>linfinite w; x = (f, w)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>w f wa fa.\n       \\<lbrakk>lfinite w; lfinite wa; (f, w) = (fa, wa)\\<rbrakk>\n       \\<Longrightarrow> fold f (list_of w) = fold fa (list_of wa)\n 3. \\<And>w f wa fa.\n       \\<lbrakk>lfinite w; linfinite wa; (f, w) = (fa, wa)\\<rbrakk>\n       \\<Longrightarrow> fold f (list_of w) = id\n 4. \\<And>w f wa fa.\n       \\<lbrakk>linfinite w; linfinite wa; (f, w) = (fa, wa)\\<rbrakk>\n       \\<Longrightarrow> id = id", "by (auto, metis)"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All lfold_dom", "by lexicographic_order"], ["", "lemma lfold_llist_of[simp]: \"lfold f (llist_of xs) = fold f xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfold f (llist_of xs) = fold f xs", "by simp"], ["", "lemma finite_UNIV_llength_eq:\n    assumes \"finite (UNIV :: 'a set)\"\n    shows \"finite {w :: 'a llist. llength w = enat n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {w. llength w = enat n}", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite {w. llength w = enat 0}\n 2. \\<And>n.\n       finite {w. llength w = enat n} \\<Longrightarrow>\n       finite {w. llength w = enat (Suc n)}", "case (0)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. finite {w. llength w = enat 0}\n 2. \\<And>n.\n       finite {w. llength w = enat n} \\<Longrightarrow>\n       finite {w. llength w = enat (Suc n)}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {w. llength w = enat 0}", "by simp"], ["proof (state)\nthis:\n  finite {w. llength w = enat 0}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       finite {w. llength w = enat n} \\<Longrightarrow>\n       finite {w. llength w = enat (Suc n)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       finite {w. llength w = enat n} \\<Longrightarrow>\n       finite {w. llength w = enat (Suc n)}", "case (Suc n)"], ["proof (state)\nthis:\n  finite {w. llength w = enat n}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       finite {w. llength w = enat n} \\<Longrightarrow>\n       finite {w. llength w = enat (Suc n)}", "have 1: \"finite ({v. llength v = enat n} \\<times> UNIV :: ('a llist \\<times> 'a) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ({v. llength v = enat n} \\<times> UNIV)", "using Suc assms"], ["proof (prove)\nusing this:\n  finite {w. llength w = enat n}\n  finite UNIV\n\ngoal (1 subgoal):\n 1. finite ({v. llength v = enat n} \\<times> UNIV)", "by simp"], ["proof (state)\nthis:\n  finite ({v. llength v = enat n} \\<times> UNIV)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       finite {w. llength w = enat n} \\<Longrightarrow>\n       finite {w. llength w = enat (Suc n)}", "have 2: \"finite ((\\<lambda> (v, a). v $ <a> :: 'a llist ) ` ({v. llength v = enat n} \\<times> UNIV))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     ((\\<lambda>(v, a). v $ <a>) ` ({v. llength v = enat n} \\<times> UNIV))", "using 1"], ["proof (prove)\nusing this:\n  finite ({v. llength v = enat n} \\<times> UNIV)\n\ngoal (1 subgoal):\n 1. finite\n     ((\\<lambda>(v, a). v $ <a>) ` ({v. llength v = enat n} \\<times> UNIV))", "by auto"], ["proof (state)\nthis:\n  finite\n   ((\\<lambda>(v, a). v $ <a>) ` ({v. llength v = enat n} \\<times> UNIV))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       finite {w. llength w = enat n} \\<Longrightarrow>\n       finite {w. llength w = enat (Suc n)}", "have 3: \"finite {v $ <a> :: 'a llist |v a. llength v = enat n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {v $ <a> |v a. llength v = enat n}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {v $ <a> |v a. llength v = enat n}", "have 0: \"{v $ <a> :: 'a llist  |v a. llength v = enat n} =\n        (\\<lambda> (v, a). v $ <a> :: 'a llist ) ` ({v. llength v = enat n} \\<times> UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {v $ <a> |v a. llength v = enat n} =\n    (\\<lambda>(v, a). v $ <a>) ` ({v. llength v = enat n} \\<times> UNIV)", "by auto"], ["proof (state)\nthis:\n  {v $ <a> |v a. llength v = enat n} =\n  (\\<lambda>(v, a). v $ <a>) ` ({v. llength v = enat n} \\<times> UNIV)\n\ngoal (1 subgoal):\n 1. finite {v $ <a> |v a. llength v = enat n}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {v $ <a> |v a. llength v = enat n}", "using 2"], ["proof (prove)\nusing this:\n  finite\n   ((\\<lambda>(v, a). v $ <a>) ` ({v. llength v = enat n} \\<times> UNIV))\n\ngoal (1 subgoal):\n 1. finite {v $ <a> |v a. llength v = enat n}", "unfolding 0"], ["proof (prove)\nusing this:\n  finite\n   ((\\<lambda>(v, a). v $ <a>) ` ({v. llength v = enat n} \\<times> UNIV))\n\ngoal (1 subgoal):\n 1. finite\n     ((\\<lambda>(v, a). v $ <a>) ` ({v. llength v = enat n} \\<times> UNIV))", "by this"], ["proof (state)\nthis:\n  finite {v $ <a> |v a. llength v = enat n}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite {v $ <a> |v a. llength v = enat n}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       finite {w. llength w = enat n} \\<Longrightarrow>\n       finite {w. llength w = enat (Suc n)}", "have 4: \"finite {w :: 'a llist . llength w = enat (Suc n)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {w. llength w = enat (Suc n)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {w. llength w = enat (Suc n)}", "have 0: \"{w :: 'a llist . llength w = enat (Suc n)} =\n        {v $ <a> :: 'a llist  |v a. llength v = enat n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {w. llength w = enat (Suc n)} = {v $ <a> |v a. llength v = enat n}", "by force"], ["proof (state)\nthis:\n  {w. llength w = enat (Suc n)} = {v $ <a> |v a. llength v = enat n}\n\ngoal (1 subgoal):\n 1. finite {w. llength w = enat (Suc n)}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {w. llength w = enat (Suc n)}", "using 3"], ["proof (prove)\nusing this:\n  finite {v $ <a> |v a. llength v = enat n}\n\ngoal (1 subgoal):\n 1. finite {w. llength w = enat (Suc n)}", "unfolding 0"], ["proof (prove)\nusing this:\n  finite {v $ <a> |v a. llength v = enat n}\n\ngoal (1 subgoal):\n 1. finite {v $ <a> |v a. llength v = enat n}", "by this"], ["proof (state)\nthis:\n  finite {w. llength w = enat (Suc n)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite {w. llength w = enat (Suc n)}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       finite {w. llength w = enat n} \\<Longrightarrow>\n       finite {w. llength w = enat (Suc n)}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {w. llength w = enat (Suc n)}", "using 4"], ["proof (prove)\nusing this:\n  finite {w. llength w = enat (Suc n)}\n\ngoal (1 subgoal):\n 1. finite {w. llength w = enat (Suc n)}", "by this"], ["proof (state)\nthis:\n  finite {w. llength w = enat (Suc n)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_UNIV_llength_le:\n    assumes \"finite (UNIV :: 'a set)\"\n    shows \"finite {w :: 'a llist. llength w \\<le> enat n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {w. llength w \\<le> enat n}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {w. llength w \\<le> enat n}", "have 1: \"{w. llength w \\<le> enat n} = (\\<Union> k \\<le> n. {w. llength w = enat k})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {w. llength w \\<le> enat n} = (\\<Union>k\\<le>n. {w. llength w = enat k})", "by (auto, metis atMost_iff enat_ile enat_ord_simps(1))"], ["proof (state)\nthis:\n  {w. llength w \\<le> enat n} = (\\<Union>k\\<le>n. {w. llength w = enat k})\n\ngoal (1 subgoal):\n 1. finite {w. llength w \\<le> enat n}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {w. llength w \\<le> enat n}", "unfolding 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union>k\\<le>n. {w. llength w = enat k})", "using finite_UNIV_llength_eq assms"], ["proof (prove)\nusing this:\n  finite UNIV \\<Longrightarrow> finite {w. llength w = enat ?n}\n  finite UNIV\n\ngoal (1 subgoal):\n 1. finite (\\<Union>k\\<le>n. {w. llength w = enat k})", "by auto"], ["proof (state)\nthis:\n  finite {w. llength w \\<le> enat n}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lprefix_ltake[dest]: \"u \\<le> v \\<Longrightarrow> u = ltake (llength u) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<le> v \\<Longrightarrow> u = ltake (llength u) v", "by (metis le_llist_conv_lprefix lprefix_conv_lappend ltake_all ltake_lappend1 order_refl)"], ["", "lemma prefixes_set: \"{v. v \\<le> w} = {ltake k w |k. k \\<le> llength w}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {v. v \\<le> w} = {ltake k w |k. k \\<le> llength w}", "by fastforce"], ["", "lemma esize_prefixes[simp]: \"esize {v. v \\<le> w} = eSuc (llength w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. esize {v. v \\<le> w} = eSuc (llength w)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. esize {v. v \\<le> w} = eSuc (llength w)", "have \"esize {v. v \\<le> w} = esize {ltake k w |k. k \\<le> llength w}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. esize {v. v \\<le> w} = esize {ltake k w |k. k \\<le> llength w}", "unfolding prefixes_set"], ["proof (prove)\ngoal (1 subgoal):\n 1. esize {ltake k w |k. k \\<le> llength w} =\n    esize {ltake k w |k. k \\<le> llength w}", "by rule"], ["proof (state)\nthis:\n  esize {v. v \\<le> w} = esize {ltake k w |k. k \\<le> llength w}\n\ngoal (1 subgoal):\n 1. esize {v. v \\<le> w} = eSuc (llength w)", "also"], ["proof (state)\nthis:\n  esize {v. v \\<le> w} = esize {ltake k w |k. k \\<le> llength w}\n\ngoal (1 subgoal):\n 1. esize {v. v \\<le> w} = eSuc (llength w)", "have \"\\<dots> = esize ((\\<lambda> k. ltake k w) ` {.. llength w})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. esize {ltake k w |k. k \\<le> llength w} =\n    esize ((\\<lambda>k. ltake k w) ` {..llength w})", "unfolding atMost_def image_Collect"], ["proof (prove)\ngoal (1 subgoal):\n 1. esize {ltake k w |k. k \\<le> llength w} =\n    esize {ltake x w |x. x \\<le> llength w}", "by rule"], ["proof (state)\nthis:\n  esize {ltake k w |k. k \\<le> llength w} =\n  esize ((\\<lambda>k. ltake k w) ` {..llength w})\n\ngoal (1 subgoal):\n 1. esize {v. v \\<le> w} = eSuc (llength w)", "also"], ["proof (state)\nthis:\n  esize {ltake k w |k. k \\<le> llength w} =\n  esize ((\\<lambda>k. ltake k w) ` {..llength w})\n\ngoal (1 subgoal):\n 1. esize {v. v \\<le> w} = eSuc (llength w)", "have \"\\<dots> = esize {.. llength w}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. esize ((\\<lambda>k. ltake k w) ` {..llength w}) = esize {..llength w}", "using inj_on_ltake esize_image"], ["proof (prove)\nusing this:\n  inj_on (\\<lambda>k. ltake k ?w) {..llength ?w}\n  inj_on ?f ?A \\<Longrightarrow> esize (?f ` ?A) = esize ?A\n\ngoal (1 subgoal):\n 1. esize ((\\<lambda>k. ltake k w) ` {..llength w}) = esize {..llength w}", "by blast"], ["proof (state)\nthis:\n  esize ((\\<lambda>k. ltake k w) ` {..llength w}) = esize {..llength w}\n\ngoal (1 subgoal):\n 1. esize {v. v \\<le> w} = eSuc (llength w)", "also"], ["proof (state)\nthis:\n  esize ((\\<lambda>k. ltake k w) ` {..llength w}) = esize {..llength w}\n\ngoal (1 subgoal):\n 1. esize {v. v \\<le> w} = eSuc (llength w)", "have \"\\<dots> = eSuc (llength w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. esize {..llength w} = eSuc (llength w)", "by simp"], ["proof (state)\nthis:\n  esize {..llength w} = eSuc (llength w)\n\ngoal (1 subgoal):\n 1. esize {v. v \\<le> w} = eSuc (llength w)", "finally"], ["proof (chain)\npicking this:\n  esize {v. v \\<le> w} = eSuc (llength w)", "show ?thesis"], ["proof (prove)\nusing this:\n  esize {v. v \\<le> w} = eSuc (llength w)\n\ngoal (1 subgoal):\n 1. esize {v. v \\<le> w} = eSuc (llength w)", "by this"], ["proof (state)\nthis:\n  esize {v. v \\<le> w} = eSuc (llength w)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prefix_subsume: \"v \\<le> w \\<Longrightarrow> u \\<le> w \\<Longrightarrow> llength v \\<le> llength u \\<Longrightarrow> v \\<le> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<le> w; u \\<le> w; llength v \\<le> llength u\\<rbrakk>\n    \\<Longrightarrow> v \\<le> u", "by (metis le_llist_conv_lprefix lprefix_conv_lappend\n      lprefix_ltake ltake_is_lprefix ltake_lappend1)"], ["", "lemma ltake_infinite[simp]: \"ltake \\<infinity> w = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake \\<infinity> w = w", "by (metis enat_ord_code(3) ltake_all)"], ["", "lemma lprefix_infinite:\n    assumes \"u \\<le> v\" \"linfinite u\"\n    shows \"u = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u = v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u = v", "have 1: \"llength u = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength u = \\<infinity>", "using not_lfinite_llength assms(2)"], ["proof (prove)\nusing this:\n  linfinite ?xs \\<Longrightarrow> llength ?xs = \\<infinity>\n  linfinite u\n\ngoal (1 subgoal):\n 1. llength u = \\<infinity>", "by this"], ["proof (state)\nthis:\n  llength u = \\<infinity>\n\ngoal (1 subgoal):\n 1. u = v", "have \"u = ltake (llength u) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u = ltake (llength u) v", "using lprefix_ltake assms(1)"], ["proof (prove)\nusing this:\n  ?u \\<le> ?v \\<Longrightarrow> ?u = ltake (llength ?u) ?v\n  u \\<le> v\n\ngoal (1 subgoal):\n 1. u = ltake (llength u) v", "by this"], ["proof (state)\nthis:\n  u = ltake (llength u) v\n\ngoal (1 subgoal):\n 1. u = v", "also"], ["proof (state)\nthis:\n  u = ltake (llength u) v\n\ngoal (1 subgoal):\n 1. u = v", "have \"\\<dots> = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake (llength u) v = v", "using 1"], ["proof (prove)\nusing this:\n  llength u = \\<infinity>\n\ngoal (1 subgoal):\n 1. ltake (llength u) v = v", "by simp"], ["proof (state)\nthis:\n  ltake (llength u) v = v\n\ngoal (1 subgoal):\n 1. u = v", "finally"], ["proof (chain)\npicking this:\n  u = v", "show ?thesis"], ["proof (prove)\nusing this:\n  u = v\n\ngoal (1 subgoal):\n 1. u = v", "by this"], ["proof (state)\nthis:\n  u = v\n\ngoal:\nNo subgoals!", "qed"], ["", "instantiation llist :: (type) esize_order\n  begin"], ["", "definition [simp]: \"esize \\<equiv> llength\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a llist, esize_order_class)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       esize x \\<noteq> \\<infinity> \\<Longrightarrow> finite {y. y \\<le> x}\n 2. \\<And>x y. x \\<le> y \\<Longrightarrow> esize x \\<le> esize y\n 3. \\<And>x y.\n       \\<lbrakk>esize x \\<noteq> \\<infinity>; x < y\\<rbrakk>\n       \\<Longrightarrow> esize x < esize y", "fix w :: \"'a llist\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       esize x \\<noteq> \\<infinity> \\<Longrightarrow> finite {y. y \\<le> x}\n 2. \\<And>x y. x \\<le> y \\<Longrightarrow> esize x \\<le> esize y\n 3. \\<And>x y.\n       \\<lbrakk>esize x \\<noteq> \\<infinity>; x < y\\<rbrakk>\n       \\<Longrightarrow> esize x < esize y", "assume 1: \"esize w \\<noteq> \\<infinity>\""], ["proof (state)\nthis:\n  esize w \\<noteq> \\<infinity>\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       esize x \\<noteq> \\<infinity> \\<Longrightarrow> finite {y. y \\<le> x}\n 2. \\<And>x y. x \\<le> y \\<Longrightarrow> esize x \\<le> esize y\n 3. \\<And>x y.\n       \\<lbrakk>esize x \\<noteq> \\<infinity>; x < y\\<rbrakk>\n       \\<Longrightarrow> esize x < esize y", "show \"finite {v. v \\<le> w}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {v. v \\<le> w}", "using esize_prefixes 1"], ["proof (prove)\nusing this:\n  esize {v. v \\<le> ?w} = eSuc (llength ?w)\n  esize w \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. finite {v. v \\<le> w}", "by (metis eSuc_eq_infinity_iff esize_set.simps(2) esize_llist_def)"], ["proof (state)\nthis:\n  finite {v. v \\<le> w}\n\ngoal (2 subgoals):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> esize x \\<le> esize y\n 2. \\<And>x y.\n       \\<lbrakk>esize x \\<noteq> \\<infinity>; x < y\\<rbrakk>\n       \\<Longrightarrow> esize x < esize y", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> esize x \\<le> esize y\n 2. \\<And>x y.\n       \\<lbrakk>esize x \\<noteq> \\<infinity>; x < y\\<rbrakk>\n       \\<Longrightarrow> esize x < esize y", "fix u v :: \"'a llist\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> esize x \\<le> esize y\n 2. \\<And>x y.\n       \\<lbrakk>esize x \\<noteq> \\<infinity>; x < y\\<rbrakk>\n       \\<Longrightarrow> esize x < esize y", "assume 1: \"u \\<le> v\""], ["proof (state)\nthis:\n  u \\<le> v\n\ngoal (2 subgoals):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> esize x \\<le> esize y\n 2. \\<And>x y.\n       \\<lbrakk>esize x \\<noteq> \\<infinity>; x < y\\<rbrakk>\n       \\<Longrightarrow> esize x < esize y", "show \"esize u \\<le> esize v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. esize u \\<le> esize v", "using lprefix_llength_le 1"], ["proof (prove)\nusing this:\n  lprefix ?xs ?ys \\<Longrightarrow> llength ?xs \\<le> llength ?ys\n  u \\<le> v\n\ngoal (1 subgoal):\n 1. esize u \\<le> esize v", "by auto"], ["proof (state)\nthis:\n  esize u \\<le> esize v\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>esize x \\<noteq> \\<infinity>; x < y\\<rbrakk>\n       \\<Longrightarrow> esize x < esize y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>esize x \\<noteq> \\<infinity>; x < y\\<rbrakk>\n       \\<Longrightarrow> esize x < esize y", "fix u v :: \"'a llist\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>esize x \\<noteq> \\<infinity>; x < y\\<rbrakk>\n       \\<Longrightarrow> esize x < esize y", "assume 1: \"u < v\""], ["proof (state)\nthis:\n  u < v\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>esize x \\<noteq> \\<infinity>; x < y\\<rbrakk>\n       \\<Longrightarrow> esize x < esize y", "show \"esize u < esize v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. esize u < esize v", "using lstrict_prefix_llength_less 1"], ["proof (prove)\nusing this:\n  lstrict_prefix ?xs ?ys \\<Longrightarrow> llength ?xs < llength ?ys\n  u < v\n\ngoal (1 subgoal):\n 1. esize u < esize v", "by auto"], ["proof (state)\nthis:\n  esize u < esize v\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Index Sets\\<close>"], ["", "definition liset :: \"'a set \\<Rightarrow> 'a llist \\<Rightarrow> nat set\"\n      where \"liset A w \\<equiv> {i. enat i < llength w \\<and> w ?! i \\<in> A}\""], ["", "lemma lisetI[intro]:\n      assumes \"enat i < llength w\" \"w ?! i \\<in> A\"\n      shows \"i \\<in> liset A w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> liset A w", "using assms"], ["proof (prove)\nusing this:\n  enat i < llength w\n  w ?! i \\<in> A\n\ngoal (1 subgoal):\n 1. i \\<in> liset A w", "unfolding liset_def"], ["proof (prove)\nusing this:\n  enat i < llength w\n  w ?! i \\<in> A\n\ngoal (1 subgoal):\n 1. i \\<in> {i. enat i < llength w \\<and> w ?! i \\<in> A}", "by auto"], ["", "lemma lisetD[dest]:\n      assumes \"i \\<in> liset A w\"\n      shows \"enat i < llength w\" \"w ?! i \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat i < llength w &&& w ?! i \\<in> A", "using assms"], ["proof (prove)\nusing this:\n  i \\<in> liset A w\n\ngoal (1 subgoal):\n 1. enat i < llength w &&& w ?! i \\<in> A", "unfolding liset_def"], ["proof (prove)\nusing this:\n  i \\<in> {i. enat i < llength w \\<and> w ?! i \\<in> A}\n\ngoal (1 subgoal):\n 1. enat i < llength w &&& w ?! i \\<in> A", "by auto"], ["", "lemma liset_finite:\n      assumes \"lfinite w\"\n      shows \"finite (liset A w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (liset A w)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. liset A w \\<subseteq> ?B\n 2. finite ?B", "show \"liset A w \\<subseteq> {i. enat i < llength w}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liset A w \\<subseteq> {i. enat i < llength w}", "by auto"], ["proof (state)\nthis:\n  liset A w \\<subseteq> {i. enat i < llength w}\n\ngoal (1 subgoal):\n 1. finite {i. enat i < llength w}", "show \"finite {i. enat i < llength w}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {i. enat i < llength w}", "using lfinite_finite_index assms"], ["proof (prove)\nusing this:\n  lfinite ?xs \\<Longrightarrow> finite {n. enat n < llength ?xs}\n  lfinite w\n\ngoal (1 subgoal):\n 1. finite {i. enat i < llength w}", "by this"], ["proof (state)\nthis:\n  finite {i. enat i < llength w}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma liset_nil[simp]: \"liset A <> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liset A <> = {}", "by auto"], ["", "lemma liset_cons_not_member[simp]:\n      assumes \"a \\<notin> A\"\n      shows \"liset A (a % w) = Suc ` liset A w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liset A (a % w) = Suc ` liset A w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. liset A (a % w) = Suc ` liset A w", "have \"liset A (a % w) = {i. enat i < llength (a % w) \\<and> (a % w) ?! i \\<in> A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liset A (a % w) =\n    {i. enat i < llength (a % w) \\<and> (a % w) ?! i \\<in> A}", "by auto"], ["proof (state)\nthis:\n  liset A (a % w) =\n  {i. enat i < llength (a % w) \\<and> (a % w) ?! i \\<in> A}\n\ngoal (1 subgoal):\n 1. liset A (a % w) = Suc ` liset A w", "also"], ["proof (state)\nthis:\n  liset A (a % w) =\n  {i. enat i < llength (a % w) \\<and> (a % w) ?! i \\<in> A}\n\ngoal (1 subgoal):\n 1. liset A (a % w) = Suc ` liset A w", "have \"\\<dots> = Suc ` {i. enat (Suc i) < llength (a % w) \\<and> (a % w) ?! Suc i \\<in> A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. enat i < llength (a % w) \\<and> (a % w) ?! i \\<in> A} =\n    Suc `\n    {i. enat (Suc i) < llength (a % w) \\<and> (a % w) ?! Suc i \\<in> A}", "using Collect_split_Suc(1) assms"], ["proof (prove)\nusing this:\n  \\<not> ?P 0 \\<Longrightarrow> {i. ?P i} = Suc ` {i. ?P (Suc i)}\n  a \\<notin> A\n\ngoal (1 subgoal):\n 1. {i. enat i < llength (a % w) \\<and> (a % w) ?! i \\<in> A} =\n    Suc `\n    {i. enat (Suc i) < llength (a % w) \\<and> (a % w) ?! Suc i \\<in> A}", "by simp"], ["proof (state)\nthis:\n  {i. enat i < llength (a % w) \\<and> (a % w) ?! i \\<in> A} =\n  Suc ` {i. enat (Suc i) < llength (a % w) \\<and> (a % w) ?! Suc i \\<in> A}\n\ngoal (1 subgoal):\n 1. liset A (a % w) = Suc ` liset A w", "also"], ["proof (state)\nthis:\n  {i. enat i < llength (a % w) \\<and> (a % w) ?! i \\<in> A} =\n  Suc ` {i. enat (Suc i) < llength (a % w) \\<and> (a % w) ?! Suc i \\<in> A}\n\ngoal (1 subgoal):\n 1. liset A (a % w) = Suc ` liset A w", "have \"\\<dots> = Suc ` {i. enat i < llength w \\<and> w ?! i \\<in> A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc `\n    {i. enat (Suc i) < llength (a % w) \\<and> (a % w) ?! Suc i \\<in> A} =\n    Suc ` {i. enat i < llength w \\<and> w ?! i \\<in> A}", "using Suc_ile_eq"], ["proof (prove)\nusing this:\n  (enat (Suc ?m) \\<le> ?n) = (enat ?m < ?n)\n\ngoal (1 subgoal):\n 1. Suc `\n    {i. enat (Suc i) < llength (a % w) \\<and> (a % w) ?! Suc i \\<in> A} =\n    Suc ` {i. enat i < llength w \\<and> w ?! i \\<in> A}", "by simp"], ["proof (state)\nthis:\n  Suc `\n  {i. enat (Suc i) < llength (a % w) \\<and> (a % w) ?! Suc i \\<in> A} =\n  Suc ` {i. enat i < llength w \\<and> w ?! i \\<in> A}\n\ngoal (1 subgoal):\n 1. liset A (a % w) = Suc ` liset A w", "also"], ["proof (state)\nthis:\n  Suc `\n  {i. enat (Suc i) < llength (a % w) \\<and> (a % w) ?! Suc i \\<in> A} =\n  Suc ` {i. enat i < llength w \\<and> w ?! i \\<in> A}\n\ngoal (1 subgoal):\n 1. liset A (a % w) = Suc ` liset A w", "have \"\\<dots> = Suc ` liset A w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc ` {i. enat i < llength w \\<and> w ?! i \\<in> A} = Suc ` liset A w", "by auto"], ["proof (state)\nthis:\n  Suc ` {i. enat i < llength w \\<and> w ?! i \\<in> A} = Suc ` liset A w\n\ngoal (1 subgoal):\n 1. liset A (a % w) = Suc ` liset A w", "finally"], ["proof (chain)\npicking this:\n  liset A (a % w) = Suc ` liset A w", "show ?thesis"], ["proof (prove)\nusing this:\n  liset A (a % w) = Suc ` liset A w\n\ngoal (1 subgoal):\n 1. liset A (a % w) = Suc ` liset A w", "by this"], ["proof (state)\nthis:\n  liset A (a % w) = Suc ` liset A w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma liset_cons_member[simp]:\n      assumes \"a \\<in> A\"\n      shows \"liset A (a % w) = {0} \\<union> Suc ` liset A w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liset A (a % w) = {0} \\<union> Suc ` liset A w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. liset A (a % w) = {0} \\<union> Suc ` liset A w", "have \"liset A (a % w) = {i. enat i < llength (a % w) \\<and> (a % w) ?! i \\<in> A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liset A (a % w) =\n    {i. enat i < llength (a % w) \\<and> (a % w) ?! i \\<in> A}", "by auto"], ["proof (state)\nthis:\n  liset A (a % w) =\n  {i. enat i < llength (a % w) \\<and> (a % w) ?! i \\<in> A}\n\ngoal (1 subgoal):\n 1. liset A (a % w) = {0} \\<union> Suc ` liset A w", "also"], ["proof (state)\nthis:\n  liset A (a % w) =\n  {i. enat i < llength (a % w) \\<and> (a % w) ?! i \\<in> A}\n\ngoal (1 subgoal):\n 1. liset A (a % w) = {0} \\<union> Suc ` liset A w", "have \"\\<dots> = {0} \\<union> Suc ` {i. enat (Suc i) < llength (a % w) \\<and> (a % w) ?! Suc i \\<in> A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. enat i < llength (a % w) \\<and> (a % w) ?! i \\<in> A} =\n    {0} \\<union>\n    Suc `\n    {i. enat (Suc i) < llength (a % w) \\<and> (a % w) ?! Suc i \\<in> A}", "using Collect_split_Suc(2) assms"], ["proof (prove)\nusing this:\n  ?P 0 \\<Longrightarrow> {i. ?P i} = {0} \\<union> Suc ` {i. ?P (Suc i)}\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. {i. enat i < llength (a % w) \\<and> (a % w) ?! i \\<in> A} =\n    {0} \\<union>\n    Suc `\n    {i. enat (Suc i) < llength (a % w) \\<and> (a % w) ?! Suc i \\<in> A}", "by simp"], ["proof (state)\nthis:\n  {i. enat i < llength (a % w) \\<and> (a % w) ?! i \\<in> A} =\n  {0} \\<union>\n  Suc ` {i. enat (Suc i) < llength (a % w) \\<and> (a % w) ?! Suc i \\<in> A}\n\ngoal (1 subgoal):\n 1. liset A (a % w) = {0} \\<union> Suc ` liset A w", "also"], ["proof (state)\nthis:\n  {i. enat i < llength (a % w) \\<and> (a % w) ?! i \\<in> A} =\n  {0} \\<union>\n  Suc ` {i. enat (Suc i) < llength (a % w) \\<and> (a % w) ?! Suc i \\<in> A}\n\ngoal (1 subgoal):\n 1. liset A (a % w) = {0} \\<union> Suc ` liset A w", "have \"\\<dots> = {0} \\<union> Suc ` {i. enat i < llength w \\<and> w ?! i \\<in> A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0} \\<union>\n    Suc `\n    {i. enat (Suc i) < llength (a % w) \\<and> (a % w) ?! Suc i \\<in> A} =\n    {0} \\<union> Suc ` {i. enat i < llength w \\<and> w ?! i \\<in> A}", "using Suc_ile_eq"], ["proof (prove)\nusing this:\n  (enat (Suc ?m) \\<le> ?n) = (enat ?m < ?n)\n\ngoal (1 subgoal):\n 1. {0} \\<union>\n    Suc `\n    {i. enat (Suc i) < llength (a % w) \\<and> (a % w) ?! Suc i \\<in> A} =\n    {0} \\<union> Suc ` {i. enat i < llength w \\<and> w ?! i \\<in> A}", "by simp"], ["proof (state)\nthis:\n  {0} \\<union>\n  Suc `\n  {i. enat (Suc i) < llength (a % w) \\<and> (a % w) ?! Suc i \\<in> A} =\n  {0} \\<union> Suc ` {i. enat i < llength w \\<and> w ?! i \\<in> A}\n\ngoal (1 subgoal):\n 1. liset A (a % w) = {0} \\<union> Suc ` liset A w", "also"], ["proof (state)\nthis:\n  {0} \\<union>\n  Suc `\n  {i. enat (Suc i) < llength (a % w) \\<and> (a % w) ?! Suc i \\<in> A} =\n  {0} \\<union> Suc ` {i. enat i < llength w \\<and> w ?! i \\<in> A}\n\ngoal (1 subgoal):\n 1. liset A (a % w) = {0} \\<union> Suc ` liset A w", "have \"\\<dots> = {0} \\<union> Suc ` liset A w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0} \\<union> Suc ` {i. enat i < llength w \\<and> w ?! i \\<in> A} =\n    {0} \\<union> Suc ` liset A w", "by auto"], ["proof (state)\nthis:\n  {0} \\<union> Suc ` {i. enat i < llength w \\<and> w ?! i \\<in> A} =\n  {0} \\<union> Suc ` liset A w\n\ngoal (1 subgoal):\n 1. liset A (a % w) = {0} \\<union> Suc ` liset A w", "finally"], ["proof (chain)\npicking this:\n  liset A (a % w) = {0} \\<union> Suc ` liset A w", "show ?thesis"], ["proof (prove)\nusing this:\n  liset A (a % w) = {0} \\<union> Suc ` liset A w\n\ngoal (1 subgoal):\n 1. liset A (a % w) = {0} \\<union> Suc ` liset A w", "by this"], ["proof (state)\nthis:\n  liset A (a % w) = {0} \\<union> Suc ` liset A w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma liset_prefix:\n      assumes \"i \\<in> liset A v\" \"u \\<le> v\" \"enat i < llength u\"\n      shows \"i \\<in> liset A u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> liset A u", "unfolding liset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> {i. enat i < llength u \\<and> u ?! i \\<in> A}", "proof (intro CollectI conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. enat i < llength u\n 2. u ?! i \\<in> A", "have 1: \"v ?! i \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v ?! i \\<in> A", "using assms(1)"], ["proof (prove)\nusing this:\n  i \\<in> liset A v\n\ngoal (1 subgoal):\n 1. v ?! i \\<in> A", "by auto"], ["proof (state)\nthis:\n  v ?! i \\<in> A\n\ngoal (2 subgoals):\n 1. enat i < llength u\n 2. u ?! i \\<in> A", "show \"enat i < llength u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat i < llength u", "using assms(3)"], ["proof (prove)\nusing this:\n  enat i < llength u\n\ngoal (1 subgoal):\n 1. enat i < llength u", "by this"], ["proof (state)\nthis:\n  enat i < llength u\n\ngoal (1 subgoal):\n 1. u ?! i \\<in> A", "show \"u ?! i \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u ?! i \\<in> A", "using lprefix_lnthD assms(2, 3) 1"], ["proof (prove)\nusing this:\n  \\<lbrakk>lprefix ?xs ?ys; enat ?n < llength ?xs\\<rbrakk>\n  \\<Longrightarrow> ?xs ?! ?n = ?ys ?! ?n\n  u \\<le> v\n  enat i < llength u\n  v ?! i \\<in> A\n\ngoal (1 subgoal):\n 1. u ?! i \\<in> A", "by force"], ["proof (state)\nthis:\n  u ?! i \\<in> A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma liset_suffix:\n      assumes \"i \\<in> liset A u\" \"u \\<le> v\"\n      shows \"i \\<in> liset A v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> liset A v", "unfolding liset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> {i. enat i < llength v \\<and> v ?! i \\<in> A}", "proof (intro CollectI conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. enat i < llength v\n 2. v ?! i \\<in> A", "have 1: \"enat i < llength u\" \"u ?! i \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat i < llength u &&& u ?! i \\<in> A", "using assms(1)"], ["proof (prove)\nusing this:\n  i \\<in> liset A u\n\ngoal (1 subgoal):\n 1. enat i < llength u &&& u ?! i \\<in> A", "by auto"], ["proof (state)\nthis:\n  enat i < llength u\n  u ?! i \\<in> A\n\ngoal (2 subgoals):\n 1. enat i < llength v\n 2. v ?! i \\<in> A", "show \"enat i < llength v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat i < llength v", "using lprefix_llength_le 1(1) assms(2)"], ["proof (prove)\nusing this:\n  lprefix ?xs ?ys \\<Longrightarrow> llength ?xs \\<le> llength ?ys\n  enat i < llength u\n  u \\<le> v\n\ngoal (1 subgoal):\n 1. enat i < llength v", "by fastforce"], ["proof (state)\nthis:\n  enat i < llength v\n\ngoal (1 subgoal):\n 1. v ?! i \\<in> A", "show \"v ?! i \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v ?! i \\<in> A", "using lprefix_lnthD assms(2) 1"], ["proof (prove)\nusing this:\n  \\<lbrakk>lprefix ?xs ?ys; enat ?n < llength ?xs\\<rbrakk>\n  \\<Longrightarrow> ?xs ?! ?n = ?ys ?! ?n\n  u \\<le> v\n  enat i < llength u\n  u ?! i \\<in> A\n\ngoal (1 subgoal):\n 1. v ?! i \\<in> A", "by force"], ["proof (state)\nthis:\n  v ?! i \\<in> A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma liset_ltake[simp]: \"liset A (ltake (enat k) w) = liset A w \\<inter> {..< k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liset A (ltake (enat k) w) = liset A w \\<inter> {..<k}", "proof (intro equalityI subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> liset A (ltake (enat k) w) \\<Longrightarrow>\n       x \\<in> liset A w \\<inter> {..<k}\n 2. \\<And>x.\n       x \\<in> liset A w \\<inter> {..<k} \\<Longrightarrow>\n       x \\<in> liset A (ltake (enat k) w)", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> liset A (ltake (enat k) w) \\<Longrightarrow>\n       x \\<in> liset A w \\<inter> {..<k}\n 2. \\<And>x.\n       x \\<in> liset A w \\<inter> {..<k} \\<Longrightarrow>\n       x \\<in> liset A (ltake (enat k) w)", "assume 1: \"i \\<in> liset A (ltake (enat k) w)\""], ["proof (state)\nthis:\n  i \\<in> liset A (ltake (enat k) w)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> liset A (ltake (enat k) w) \\<Longrightarrow>\n       x \\<in> liset A w \\<inter> {..<k}\n 2. \\<And>x.\n       x \\<in> liset A w \\<inter> {..<k} \\<Longrightarrow>\n       x \\<in> liset A (ltake (enat k) w)", "have 2: \"enat i < enat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat i < enat k", "using 1"], ["proof (prove)\nusing this:\n  i \\<in> liset A (ltake (enat k) w)\n\ngoal (1 subgoal):\n 1. enat i < enat k", "by auto"], ["proof (state)\nthis:\n  enat i < enat k\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> liset A (ltake (enat k) w) \\<Longrightarrow>\n       x \\<in> liset A w \\<inter> {..<k}\n 2. \\<And>x.\n       x \\<in> liset A w \\<inter> {..<k} \\<Longrightarrow>\n       x \\<in> liset A (ltake (enat k) w)", "have 3: \"ltake (enat k) w ?! i = w ?! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake (enat k) w ?! i = w ?! i", "using lnth_ltake 2"], ["proof (prove)\nusing this:\n  enat ?m < ?n \\<Longrightarrow> ltake ?n ?xs ?! ?m = ?xs ?! ?m\n  enat i < enat k\n\ngoal (1 subgoal):\n 1. ltake (enat k) w ?! i = w ?! i", "by this"], ["proof (state)\nthis:\n  ltake (enat k) w ?! i = w ?! i\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> liset A (ltake (enat k) w) \\<Longrightarrow>\n       x \\<in> liset A w \\<inter> {..<k}\n 2. \\<And>x.\n       x \\<in> liset A w \\<inter> {..<k} \\<Longrightarrow>\n       x \\<in> liset A (ltake (enat k) w)", "show \"i \\<in> liset A w \\<inter> {..< k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> liset A w \\<inter> {..<k}", "using 1 3"], ["proof (prove)\nusing this:\n  i \\<in> liset A (ltake (enat k) w)\n  ltake (enat k) w ?! i = w ?! i\n\ngoal (1 subgoal):\n 1. i \\<in> liset A w \\<inter> {..<k}", "by fastforce"], ["proof (state)\nthis:\n  i \\<in> liset A w \\<inter> {..<k}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> liset A w \\<inter> {..<k} \\<Longrightarrow>\n       x \\<in> liset A (ltake (enat k) w)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> liset A w \\<inter> {..<k} \\<Longrightarrow>\n       x \\<in> liset A (ltake (enat k) w)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> liset A w \\<inter> {..<k} \\<Longrightarrow>\n       x \\<in> liset A (ltake (enat k) w)", "assume 1: \"i \\<in> liset A w \\<inter> {..< k}\""], ["proof (state)\nthis:\n  i \\<in> liset A w \\<inter> {..<k}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> liset A w \\<inter> {..<k} \\<Longrightarrow>\n       x \\<in> liset A (ltake (enat k) w)", "have 2: \"enat i < enat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat i < enat k", "using 1"], ["proof (prove)\nusing this:\n  i \\<in> liset A w \\<inter> {..<k}\n\ngoal (1 subgoal):\n 1. enat i < enat k", "by auto"], ["proof (state)\nthis:\n  enat i < enat k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> liset A w \\<inter> {..<k} \\<Longrightarrow>\n       x \\<in> liset A (ltake (enat k) w)", "have 3: \"ltake (enat k) w ?! i = w ?! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake (enat k) w ?! i = w ?! i", "using lnth_ltake 2"], ["proof (prove)\nusing this:\n  enat ?m < ?n \\<Longrightarrow> ltake ?n ?xs ?! ?m = ?xs ?! ?m\n  enat i < enat k\n\ngoal (1 subgoal):\n 1. ltake (enat k) w ?! i = w ?! i", "by this"], ["proof (state)\nthis:\n  ltake (enat k) w ?! i = w ?! i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> liset A w \\<inter> {..<k} \\<Longrightarrow>\n       x \\<in> liset A (ltake (enat k) w)", "show \"i \\<in> liset A (ltake (enat k) w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> liset A (ltake (enat k) w)", "using 1 3"], ["proof (prove)\nusing this:\n  i \\<in> liset A w \\<inter> {..<k}\n  ltake (enat k) w ?! i = w ?! i\n\ngoal (1 subgoal):\n 1. i \\<in> liset A (ltake (enat k) w)", "by fastforce"], ["proof (state)\nthis:\n  i \\<in> liset A (ltake (enat k) w)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma liset_mono[dest]: \"u \\<le> v \\<Longrightarrow> liset A u \\<subseteq> liset A v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<le> v \\<Longrightarrow> liset A u \\<subseteq> liset A v", "unfolding liset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<le> v \\<Longrightarrow>\n    {i. enat i < llength u \\<and> u ?! i \\<in> A}\n    \\<subseteq> {i. enat i < llength v \\<and> v ?! i \\<in> A}", "using lprefix_lnthD"], ["proof (prove)\nusing this:\n  \\<lbrakk>lprefix ?xs ?ys; enat ?n < llength ?xs\\<rbrakk>\n  \\<Longrightarrow> ?xs ?! ?n = ?ys ?! ?n\n\ngoal (1 subgoal):\n 1. u \\<le> v \\<Longrightarrow>\n    {i. enat i < llength u \\<and> u ?! i \\<in> A}\n    \\<subseteq> {i. enat i < llength v \\<and> v ?! i \\<in> A}", "by fastforce"], ["", "lemma liset_cont[dest]:\n      assumes \"Complete_Partial_Order.chain less_eq C\" \"C \\<noteq> {}\"\n      shows \"liset A (\\<Squnion> C) = (\\<Union> w \\<in> C. liset A w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liset A (\\<Squnion> C) = \\<Union> (liset A ` C)", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> liset A (\\<Squnion> C) \\<Longrightarrow>\n       x \\<in> \\<Union> (liset A ` C)\n 2. \\<And>x w.\n       \\<lbrakk>w \\<in> C; x \\<in> liset A w\\<rbrakk>\n       \\<Longrightarrow> x \\<in> liset A (\\<Squnion> C)", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> liset A (\\<Squnion> C) \\<Longrightarrow>\n       x \\<in> \\<Union> (liset A ` C)\n 2. \\<And>x w.\n       \\<lbrakk>w \\<in> C; x \\<in> liset A w\\<rbrakk>\n       \\<Longrightarrow> x \\<in> liset A (\\<Squnion> C)", "assume 1: \"i \\<in> liset A (\\<Squnion> C)\""], ["proof (state)\nthis:\n  i \\<in> liset A (\\<Squnion> C)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> liset A (\\<Squnion> C) \\<Longrightarrow>\n       x \\<in> \\<Union> (liset A ` C)\n 2. \\<And>x w.\n       \\<lbrakk>w \\<in> C; x \\<in> liset A w\\<rbrakk>\n       \\<Longrightarrow> x \\<in> liset A (\\<Squnion> C)", "show \"i \\<in> (\\<Union> w \\<in> C. liset A w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> \\<Union> (liset A ` C)", "proof (cases \"finite C\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite C \\<Longrightarrow> i \\<in> \\<Union> (liset A ` C)\n 2. infinite C \\<Longrightarrow> i \\<in> \\<Union> (liset A ` C)", "case False"], ["proof (state)\nthis:\n  infinite C\n\ngoal (2 subgoals):\n 1. finite C \\<Longrightarrow> i \\<in> \\<Union> (liset A ` C)\n 2. infinite C \\<Longrightarrow> i \\<in> \\<Union> (liset A ` C)", "obtain w where 2: \"w \\<in> C\" \"enat i < llength w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>w \\<in> C; enat i < llength w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using esize_llist_def infinite_chain_arbitrary_esize assms(1) False Suc_ile_eq"], ["proof (prove)\nusing this:\n  esize \\<equiv> llength\n  \\<lbrakk>Complete_Partial_Order.chain (\\<le>) ?C; infinite ?C;\n   \\<And>x.\n      \\<lbrakk>x \\<in> ?C; enat ?n \\<le> esize x\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  Complete_Partial_Order.chain (\\<le>) C\n  infinite C\n  (enat (Suc ?m) \\<le> ?n) = (enat ?m < ?n)\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>w \\<in> C; enat i < llength w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  w \\<in> C\n  enat i < llength w\n\ngoal (2 subgoals):\n 1. finite C \\<Longrightarrow> i \\<in> \\<Union> (liset A ` C)\n 2. infinite C \\<Longrightarrow> i \\<in> \\<Union> (liset A ` C)", "have 3: \"w \\<le> \\<Squnion> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<le> \\<Squnion> C", "using chain_lprefix_lSup assms(1) 2(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>Complete_Partial_Order.chain lprefix ?A; ?xs \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> lprefix ?xs (lSup ?A)\n  Complete_Partial_Order.chain (\\<le>) C\n  w \\<in> C\n\ngoal (1 subgoal):\n 1. w \\<le> \\<Squnion> C", "by simp"], ["proof (state)\nthis:\n  w \\<le> \\<Squnion> C\n\ngoal (2 subgoals):\n 1. finite C \\<Longrightarrow> i \\<in> \\<Union> (liset A ` C)\n 2. infinite C \\<Longrightarrow> i \\<in> \\<Union> (liset A ` C)", "have 4: \"i \\<in> liset A w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> liset A w", "using liset_prefix 1 3 2(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i \\<in> liset ?A ?v; ?u \\<le> ?v; enat ?i < llength ?u\\<rbrakk>\n  \\<Longrightarrow> ?i \\<in> liset ?A ?u\n  i \\<in> liset A (\\<Squnion> C)\n  w \\<le> \\<Squnion> C\n  enat i < llength w\n\ngoal (1 subgoal):\n 1. i \\<in> liset A w", "by this"], ["proof (state)\nthis:\n  i \\<in> liset A w\n\ngoal (2 subgoals):\n 1. finite C \\<Longrightarrow> i \\<in> \\<Union> (liset A ` C)\n 2. infinite C \\<Longrightarrow> i \\<in> \\<Union> (liset A ` C)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> \\<Union> (liset A ` C)", "using 2(1) 4"], ["proof (prove)\nusing this:\n  w \\<in> C\n  i \\<in> liset A w\n\ngoal (1 subgoal):\n 1. i \\<in> \\<Union> (liset A ` C)", "by auto"], ["proof (state)\nthis:\n  i \\<in> \\<Union> (liset A ` C)\n\ngoal (1 subgoal):\n 1. finite C \\<Longrightarrow> i \\<in> \\<Union> (liset A ` C)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. finite C \\<Longrightarrow> i \\<in> \\<Union> (liset A ` C)", "case True"], ["proof (state)\nthis:\n  finite C\n\ngoal (1 subgoal):\n 1. finite C \\<Longrightarrow> i \\<in> \\<Union> (liset A ` C)", "have 2: \"\\<Squnion> C \\<in> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> C \\<in> C", "using in_chain_finite assms(1) True assms(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>Complete_Partial_Order.chain (\\<le>) ?A; finite ?A;\n   ?A \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<Squnion> ?A \\<in> ?A\n  Complete_Partial_Order.chain (\\<le>) C\n  finite C\n  C \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<Squnion> C \\<in> C", "by this"], ["proof (state)\nthis:\n  \\<Squnion> C \\<in> C\n\ngoal (1 subgoal):\n 1. finite C \\<Longrightarrow> i \\<in> \\<Union> (liset A ` C)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> \\<Union> (liset A ` C)", "using 1 2"], ["proof (prove)\nusing this:\n  i \\<in> liset A (\\<Squnion> C)\n  \\<Squnion> C \\<in> C\n\ngoal (1 subgoal):\n 1. i \\<in> \\<Union> (liset A ` C)", "by auto"], ["proof (state)\nthis:\n  i \\<in> \\<Union> (liset A ` C)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i \\<in> \\<Union> (liset A ` C)\n\ngoal (1 subgoal):\n 1. \\<And>x w.\n       \\<lbrakk>w \\<in> C; x \\<in> liset A w\\<rbrakk>\n       \\<Longrightarrow> x \\<in> liset A (\\<Squnion> C)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x w.\n       \\<lbrakk>w \\<in> C; x \\<in> liset A w\\<rbrakk>\n       \\<Longrightarrow> x \\<in> liset A (\\<Squnion> C)", "fix w i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x w.\n       \\<lbrakk>w \\<in> C; x \\<in> liset A w\\<rbrakk>\n       \\<Longrightarrow> x \\<in> liset A (\\<Squnion> C)", "assume 1: \"w \\<in> C\" \"i \\<in> liset A w\""], ["proof (state)\nthis:\n  w \\<in> C\n  i \\<in> liset A w\n\ngoal (1 subgoal):\n 1. \\<And>x w.\n       \\<lbrakk>w \\<in> C; x \\<in> liset A w\\<rbrakk>\n       \\<Longrightarrow> x \\<in> liset A (\\<Squnion> C)", "have 2: \"w \\<le> \\<Squnion> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<le> \\<Squnion> C", "using chain_lprefix_lSup assms(1) 1(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>Complete_Partial_Order.chain lprefix ?A; ?xs \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> lprefix ?xs (lSup ?A)\n  Complete_Partial_Order.chain (\\<le>) C\n  w \\<in> C\n\ngoal (1 subgoal):\n 1. w \\<le> \\<Squnion> C", "by simp"], ["proof (state)\nthis:\n  w \\<le> \\<Squnion> C\n\ngoal (1 subgoal):\n 1. \\<And>x w.\n       \\<lbrakk>w \\<in> C; x \\<in> liset A w\\<rbrakk>\n       \\<Longrightarrow> x \\<in> liset A (\\<Squnion> C)", "show \"i \\<in> liset A (\\<Squnion> C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> liset A (\\<Squnion> C)", "using liset_suffix 1(2) 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i \\<in> liset ?A ?u; ?u \\<le> ?v\\<rbrakk>\n  \\<Longrightarrow> ?i \\<in> liset ?A ?v\n  i \\<in> liset A w\n  w \\<le> \\<Squnion> C\n\ngoal (1 subgoal):\n 1. i \\<in> liset A (\\<Squnion> C)", "by this"], ["proof (state)\nthis:\n  i \\<in> liset A (\\<Squnion> C)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma liset_mcont: \"Complete_Partial_Order2.mcont lSup lprefix Sup less_eq (liset A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont lSup lprefix \\<Union> (\\<subseteq>) (liset A)", "unfolding lprefix_lSup_revert"], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont Sup (\\<le>) \\<Union> (\\<subseteq>) (liset A)", "by (blast intro: mcontI monotoneI contI)"], ["", "lemmas mcont2mcont_liset = liset_mcont[THEN lfp.mcont2mcont, simp, cont_intro]"], ["", "subsection \\<open>Selections\\<close>"], ["", "(* TODO: thm lfitler_K_False *)"], ["", "abbreviation \"lproject A \\<equiv> lfilter (\\<lambda> a. a \\<in> A)\""], ["", "abbreviation \"lselect s w \\<equiv> lnths w s\""], ["", "lemma lselect_to_lproject: \"lselect s w = lmap fst (lproject (UNIV \\<times> s) (w \\<bar>\\<bar> iterates Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect s w =\n    lmap fst (lproject (UNIV \\<times> s) (w \\<bar>\\<bar> iterates Suc 0))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lselect s w =\n    lmap fst (lproject (UNIV \\<times> s) (w \\<bar>\\<bar> iterates Suc 0))", "have 1: \"{(x, y). y \\<in> s} = UNIV \\<times> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). y \\<in> s} = UNIV \\<times> s", "by auto"], ["proof (state)\nthis:\n  {(x, y). y \\<in> s} = UNIV \\<times> s\n\ngoal (1 subgoal):\n 1. lselect s w =\n    lmap fst (lproject (UNIV \\<times> s) (w \\<bar>\\<bar> iterates Suc 0))", "have \"lselect s w = lmap fst (lproject {(x, y). y \\<in> s} (w \\<bar>\\<bar> iterates Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect s w =\n    lmap fst (lproject {(x, y). y \\<in> s} (w \\<bar>\\<bar> iterates Suc 0))", "unfolding lnths_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap fst\n     (lfilter (\\<lambda>(x, y). y \\<in> s)\n       (w \\<bar>\\<bar> iterates Suc 0)) =\n    lmap fst (lproject {(x, y). y \\<in> s} (w \\<bar>\\<bar> iterates Suc 0))", "by simp"], ["proof (state)\nthis:\n  lselect s w =\n  lmap fst (lproject {(x, y). y \\<in> s} (w \\<bar>\\<bar> iterates Suc 0))\n\ngoal (1 subgoal):\n 1. lselect s w =\n    lmap fst (lproject (UNIV \\<times> s) (w \\<bar>\\<bar> iterates Suc 0))", "also"], ["proof (state)\nthis:\n  lselect s w =\n  lmap fst (lproject {(x, y). y \\<in> s} (w \\<bar>\\<bar> iterates Suc 0))\n\ngoal (1 subgoal):\n 1. lselect s w =\n    lmap fst (lproject (UNIV \\<times> s) (w \\<bar>\\<bar> iterates Suc 0))", "have \"\\<dots> = lmap fst (lproject (UNIV \\<times> s) (w \\<bar>\\<bar> iterates Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap fst\n     (lproject {(x, y). y \\<in> s} (w \\<bar>\\<bar> iterates Suc 0)) =\n    lmap fst (lproject (UNIV \\<times> s) (w \\<bar>\\<bar> iterates Suc 0))", "unfolding 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap fst (lproject (UNIV \\<times> s) (w \\<bar>\\<bar> iterates Suc 0)) =\n    lmap fst (lproject (UNIV \\<times> s) (w \\<bar>\\<bar> iterates Suc 0))", "by rule"], ["proof (state)\nthis:\n  lmap fst (lproject {(x, y). y \\<in> s} (w \\<bar>\\<bar> iterates Suc 0)) =\n  lmap fst (lproject (UNIV \\<times> s) (w \\<bar>\\<bar> iterates Suc 0))\n\ngoal (1 subgoal):\n 1. lselect s w =\n    lmap fst (lproject (UNIV \\<times> s) (w \\<bar>\\<bar> iterates Suc 0))", "finally"], ["proof (chain)\npicking this:\n  lselect s w =\n  lmap fst (lproject (UNIV \\<times> s) (w \\<bar>\\<bar> iterates Suc 0))", "show ?thesis"], ["proof (prove)\nusing this:\n  lselect s w =\n  lmap fst (lproject (UNIV \\<times> s) (w \\<bar>\\<bar> iterates Suc 0))\n\ngoal (1 subgoal):\n 1. lselect s w =\n    lmap fst (lproject (UNIV \\<times> s) (w \\<bar>\\<bar> iterates Suc 0))", "by this"], ["proof (state)\nthis:\n  lselect s w =\n  lmap fst (lproject (UNIV \\<times> s) (w \\<bar>\\<bar> iterates Suc 0))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lproject_to_lselect: \"lproject A w = lselect (liset A w) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lproject A w = lselect (liset A w) w", "unfolding lfilter_conv_lnths liset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect {n. enat n < llength w \\<and> w ?! n \\<in> A} w =\n    lselect {i. enat i < llength w \\<and> w ?! i \\<in> A} w", "by rule"], ["", "lemma lproject_llength[simp]: \"llength (lproject A w) = esize (liset A w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (lproject A w) = esize (liset A w)", "by (induct rule: llist_induct) (auto)"], ["", "lemma lproject_lfinite[simp]: \"lfinite (lproject A w) \\<longleftrightarrow> finite (liset A w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite (lproject A w) = finite (liset A w)", "using lproject_llength esize_iff_infinite llength_eq_infty_conv_lfinite"], ["proof (prove)\nusing this:\n  llength (lproject ?A ?w) = esize (liset ?A ?w)\n  (esize ?A = \\<infinity>) = infinite ?A\n  (llength ?xs = \\<infinity>) = linfinite ?xs\n\ngoal (1 subgoal):\n 1. lfinite (lproject A w) = finite (liset A w)", "by metis"], ["", "lemma lselect_restrict_indices[simp]: \"lselect {i \\<in> s. enat i < llength w} w = lselect s w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect {i \\<in> s. enat i < llength w} w = lselect s w", "proof (rule lnths_cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. w = w\n 2. \\<And>n.\n       enat n < llength w \\<Longrightarrow>\n       (n \\<in> {i \\<in> s. enat i < llength w}) = (n \\<in> s)", "show \"w = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w = w", "by rule"], ["proof (state)\nthis:\n  w = w\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       enat n < llength w \\<Longrightarrow>\n       (n \\<in> {i \\<in> s. enat i < llength w}) = (n \\<in> s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       enat n < llength w \\<Longrightarrow>\n       (n \\<in> {i \\<in> s. enat i < llength w}) = (n \\<in> s)", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       enat n < llength w \\<Longrightarrow>\n       (n \\<in> {i \\<in> s. enat i < llength w}) = (n \\<in> s)", "assume 1: \"enat n < llength w\""], ["proof (state)\nthis:\n  enat n < llength w\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       enat n < llength w \\<Longrightarrow>\n       (n \\<in> {i \\<in> s. enat i < llength w}) = (n \\<in> s)", "show \"n \\<in> {i \\<in> s. enat i < llength w} \\<longleftrightarrow> n \\<in> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n \\<in> {i \\<in> s. enat i < llength w}) = (n \\<in> s)", "using 1"], ["proof (prove)\nusing this:\n  enat n < llength w\n\ngoal (1 subgoal):\n 1. (n \\<in> {i \\<in> s. enat i < llength w}) = (n \\<in> s)", "by blast"], ["proof (state)\nthis:\n  (n \\<in> {i \\<in> s. enat i < llength w}) = (n \\<in> s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lselect_llength: \"llength (lselect s w) = esize {i \\<in> s. enat i < llength w}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (lselect s w) = esize {i \\<in> s. enat i < llength w}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. llength (lselect s w) = esize {i \\<in> s. enat i < llength w}", "have 1: \"\\<And> i. enat i < llength w \\<Longrightarrow> (w \\<bar>\\<bar> iterates Suc 0) ?! i = (w ?! i, i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       enat i < llength w \\<Longrightarrow>\n       (w \\<bar>\\<bar> iterates Suc 0) ?! i = (w ?! i, i)", "by (metis Suc_funpow enat.distinct(1) enat_ord_simps(4) llength_iterates lnth_iterates\n          lnth_lzip monoid_add_class.add.right_neutral)"], ["proof (state)\nthis:\n  enat ?i < llength w \\<Longrightarrow>\n  (w \\<bar>\\<bar> iterates Suc 0) ?! ?i = (w ?! ?i, ?i)\n\ngoal (1 subgoal):\n 1. llength (lselect s w) = esize {i \\<in> s. enat i < llength w}", "have 2: \"{i. enat i < llength w \\<and> (w \\<bar>\\<bar> iterates Suc 0) ?! i \\<in> UNIV \\<times> s} =\n        {i \\<in> s. enat i < llength w}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. enat i < llength w \\<and>\n        (w \\<bar>\\<bar> iterates Suc 0) ?! i \\<in> UNIV \\<times> s} =\n    {i \\<in> s. enat i < llength w}", "using 1"], ["proof (prove)\nusing this:\n  enat ?i < llength w \\<Longrightarrow>\n  (w \\<bar>\\<bar> iterates Suc 0) ?! ?i = (w ?! ?i, ?i)\n\ngoal (1 subgoal):\n 1. {i. enat i < llength w \\<and>\n        (w \\<bar>\\<bar> iterates Suc 0) ?! i \\<in> UNIV \\<times> s} =\n    {i \\<in> s. enat i < llength w}", "by auto"], ["proof (state)\nthis:\n  {i. enat i < llength w \\<and>\n      (w \\<bar>\\<bar> iterates Suc 0) ?! i \\<in> UNIV \\<times> s} =\n  {i \\<in> s. enat i < llength w}\n\ngoal (1 subgoal):\n 1. llength (lselect s w) = esize {i \\<in> s. enat i < llength w}", "have \"llength (lselect s w) = esize (liset (UNIV \\<times> s) (w \\<bar>\\<bar> iterates Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (lselect s w) =\n    esize (liset (UNIV \\<times> s) (w \\<bar>\\<bar> iterates Suc 0))", "unfolding lselect_to_lproject"], ["proof (prove)\ngoal (1 subgoal):\n 1. llength\n     (lmap fst\n       (lproject (UNIV \\<times> s) (w \\<bar>\\<bar> iterates Suc 0))) =\n    esize (liset (UNIV \\<times> s) (w \\<bar>\\<bar> iterates Suc 0))", "by simp"], ["proof (state)\nthis:\n  llength (lselect s w) =\n  esize (liset (UNIV \\<times> s) (w \\<bar>\\<bar> iterates Suc 0))\n\ngoal (1 subgoal):\n 1. llength (lselect s w) = esize {i \\<in> s. enat i < llength w}", "also"], ["proof (state)\nthis:\n  llength (lselect s w) =\n  esize (liset (UNIV \\<times> s) (w \\<bar>\\<bar> iterates Suc 0))\n\ngoal (1 subgoal):\n 1. llength (lselect s w) = esize {i \\<in> s. enat i < llength w}", "have \"\\<dots> = esize {i. enat i < llength w \\<and> (w \\<bar>\\<bar> iterates Suc 0) ?! i \\<in> UNIV \\<times> s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. esize (liset (UNIV \\<times> s) (w \\<bar>\\<bar> iterates Suc 0)) =\n    esize\n     {i. enat i < llength w \\<and>\n         (w \\<bar>\\<bar> iterates Suc 0) ?! i \\<in> UNIV \\<times> s}", "unfolding liset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. esize\n     {i. enat i < llength (w \\<bar>\\<bar> iterates Suc 0) \\<and>\n         (w \\<bar>\\<bar> iterates Suc 0) ?! i \\<in> UNIV \\<times> s} =\n    esize\n     {i. enat i < llength w \\<and>\n         (w \\<bar>\\<bar> iterates Suc 0) ?! i \\<in> UNIV \\<times> s}", "by simp"], ["proof (state)\nthis:\n  esize (liset (UNIV \\<times> s) (w \\<bar>\\<bar> iterates Suc 0)) =\n  esize\n   {i. enat i < llength w \\<and>\n       (w \\<bar>\\<bar> iterates Suc 0) ?! i \\<in> UNIV \\<times> s}\n\ngoal (1 subgoal):\n 1. llength (lselect s w) = esize {i \\<in> s. enat i < llength w}", "also"], ["proof (state)\nthis:\n  esize (liset (UNIV \\<times> s) (w \\<bar>\\<bar> iterates Suc 0)) =\n  esize\n   {i. enat i < llength w \\<and>\n       (w \\<bar>\\<bar> iterates Suc 0) ?! i \\<in> UNIV \\<times> s}\n\ngoal (1 subgoal):\n 1. llength (lselect s w) = esize {i \\<in> s. enat i < llength w}", "have \"\\<dots> = esize {i \\<in> s. enat i < llength w}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. esize\n     {i. enat i < llength w \\<and>\n         (w \\<bar>\\<bar> iterates Suc 0) ?! i \\<in> UNIV \\<times> s} =\n    esize {i \\<in> s. enat i < llength w}", "unfolding 2"], ["proof (prove)\ngoal (1 subgoal):\n 1. esize {i \\<in> s. enat i < llength w} =\n    esize {i \\<in> s. enat i < llength w}", "by rule"], ["proof (state)\nthis:\n  esize\n   {i. enat i < llength w \\<and>\n       (w \\<bar>\\<bar> iterates Suc 0) ?! i \\<in> UNIV \\<times> s} =\n  esize {i \\<in> s. enat i < llength w}\n\ngoal (1 subgoal):\n 1. llength (lselect s w) = esize {i \\<in> s. enat i < llength w}", "finally"], ["proof (chain)\npicking this:\n  llength (lselect s w) = esize {i \\<in> s. enat i < llength w}", "show ?thesis"], ["proof (prove)\nusing this:\n  llength (lselect s w) = esize {i \\<in> s. enat i < llength w}\n\ngoal (1 subgoal):\n 1. llength (lselect s w) = esize {i \\<in> s. enat i < llength w}", "by this"], ["proof (state)\nthis:\n  llength (lselect s w) = esize {i \\<in> s. enat i < llength w}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lselect_llength_le[simp]: \"llength (lselect s w) \\<le> esize s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (lselect s w) \\<le> esize s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. llength (lselect s w) \\<le> esize s", "have \"llength (lselect s w) = esize {i \\<in> s. enat i < llength w}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (lselect s w) = esize {i \\<in> s. enat i < llength w}", "unfolding lselect_llength"], ["proof (prove)\ngoal (1 subgoal):\n 1. esize {i \\<in> s. enat i < llength w} =\n    esize {i \\<in> s. enat i < llength w}", "by rule"], ["proof (state)\nthis:\n  llength (lselect s w) = esize {i \\<in> s. enat i < llength w}\n\ngoal (1 subgoal):\n 1. llength (lselect s w) \\<le> esize s", "also"], ["proof (state)\nthis:\n  llength (lselect s w) = esize {i \\<in> s. enat i < llength w}\n\ngoal (1 subgoal):\n 1. llength (lselect s w) \\<le> esize s", "have \"\\<dots> = esize (s \\<inter> {i. enat i < llength w})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. esize {i \\<in> s. enat i < llength w} =\n    esize (s \\<inter> {i. enat i < llength w})", "unfolding Collect_conj_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. esize ({i. i \\<in> s} \\<inter> {i. enat i < llength w}) =\n    esize (s \\<inter> {i. enat i < llength w})", "by simp"], ["proof (state)\nthis:\n  esize {i \\<in> s. enat i < llength w} =\n  esize (s \\<inter> {i. enat i < llength w})\n\ngoal (1 subgoal):\n 1. llength (lselect s w) \\<le> esize s", "also"], ["proof (state)\nthis:\n  esize {i \\<in> s. enat i < llength w} =\n  esize (s \\<inter> {i. enat i < llength w})\n\ngoal (1 subgoal):\n 1. llength (lselect s w) \\<le> esize s", "have \"\\<dots> \\<le> esize s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. esize (s \\<inter> {i. enat i < llength w}) \\<le> esize s", "by blast"], ["proof (state)\nthis:\n  esize (s \\<inter> {i. enat i < llength w}) \\<le> esize s\n\ngoal (1 subgoal):\n 1. llength (lselect s w) \\<le> esize s", "finally"], ["proof (chain)\npicking this:\n  llength (lselect s w) \\<le> esize s", "show ?thesis"], ["proof (prove)\nusing this:\n  llength (lselect s w) \\<le> esize s\n\ngoal (1 subgoal):\n 1. llength (lselect s w) \\<le> esize s", "by this"], ["proof (state)\nthis:\n  llength (lselect s w) \\<le> esize s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma least_lselect_llength:\n      assumes \"\\<not> lnull (lselect s w)\"\n      shows \"enat (least s) < llength w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat (least s) < llength w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. enat (least s) < llength w", "have 0: \"llength (lselect s w) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < llength (lselect s w)", "using assms"], ["proof (prove)\nusing this:\n  \\<not> lnull (lselect s w)\n\ngoal (1 subgoal):\n 1. 0 < llength (lselect s w)", "by auto"], ["proof (state)\nthis:\n  0 < llength (lselect s w)\n\ngoal (1 subgoal):\n 1. enat (least s) < llength w", "have 1: \"\\<And> i. i \\<in> s \\<Longrightarrow> least s \\<le> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> s \\<Longrightarrow> least s \\<le> i", "using Least_le 0"], ["proof (prove)\nusing this:\n  ?P ?k \\<Longrightarrow> (LEAST x. ?P x) \\<le> ?k\n  0 < llength (lselect s w)\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> s \\<Longrightarrow> least s \\<le> i", "by fast"], ["proof (state)\nthis:\n  ?i \\<in> s \\<Longrightarrow> least s \\<le> ?i\n\ngoal (1 subgoal):\n 1. enat (least s) < llength w", "obtain i where 2: \"i \\<in> s\" \"enat i < llength w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i \\<in> s; enat i < llength w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 0"], ["proof (prove)\nusing this:\n  0 < llength (lselect s w)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i \\<in> s; enat i < llength w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding lselect_llength"], ["proof (prove)\nusing this:\n  0 < esize {i \\<in> s. enat i < llength w}\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i \\<in> s; enat i < llength w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i \\<in> s\n  enat i < llength w\n\ngoal (1 subgoal):\n 1. enat (least s) < llength w", "have \"enat (least s) \\<le> enat i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat (least s) \\<le> enat i", "using 1 2(1)"], ["proof (prove)\nusing this:\n  ?i \\<in> s \\<Longrightarrow> least s \\<le> ?i\n  i \\<in> s\n\ngoal (1 subgoal):\n 1. enat (least s) \\<le> enat i", "by auto"], ["proof (state)\nthis:\n  enat (least s) \\<le> enat i\n\ngoal (1 subgoal):\n 1. enat (least s) < llength w", "also"], ["proof (state)\nthis:\n  enat (least s) \\<le> enat i\n\ngoal (1 subgoal):\n 1. enat (least s) < llength w", "have \"\\<dots> < llength w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat i < llength w", "using 2(2)"], ["proof (prove)\nusing this:\n  enat i < llength w\n\ngoal (1 subgoal):\n 1. enat i < llength w", "by this"], ["proof (state)\nthis:\n  enat i < llength w\n\ngoal (1 subgoal):\n 1. enat (least s) < llength w", "finally"], ["proof (chain)\npicking this:\n  enat (least s) < llength w", "show \"enat (least s) < llength w\""], ["proof (prove)\nusing this:\n  enat (least s) < llength w\n\ngoal (1 subgoal):\n 1. enat (least s) < llength w", "by this"], ["proof (state)\nthis:\n  enat (least s) < llength w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lselect_lnull: \"lnull (lselect s w) \\<longleftrightarrow> (\\<forall> i \\<in> s. enat i \\<ge> llength w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull (lselect s w) = (\\<forall>i\\<in>s. llength w \\<le> enat i)", "unfolding llength_eq_0[symmetric] lselect_llength"], ["proof (prove)\ngoal (1 subgoal):\n 1. (esize {i \\<in> s. enat i < llength w} = 0) =\n    (\\<forall>i\\<in>s. llength w \\<le> enat i)", "by auto"], ["", "lemma lselect_discard_start:\n      assumes \"\\<And> i. i \\<in> s \\<Longrightarrow> k \\<le> i\"\n      shows \"lselect {i. k + i \\<in> s} (ldropn k w) = lselect s w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect {i. k + i \\<in> s} (ldropn k w) = lselect s w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lselect {i. k + i \\<in> s} (ldropn k w) = lselect s w", "have 1: \"lselect s (ltake (enat k) w) = <>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect s (ltake (enat k) w) = <>", "using assms"], ["proof (prove)\nusing this:\n  ?i \\<in> s \\<Longrightarrow> k \\<le> ?i\n\ngoal (1 subgoal):\n 1. lselect s (ltake (enat k) w) = <>", "by (fastforce simp add: lselect_lnull min_le_iff_disj)"], ["proof (state)\nthis:\n  lselect s (ltake (enat k) w) = <>\n\ngoal (1 subgoal):\n 1. lselect {i. k + i \\<in> s} (ldropn k w) = lselect s w", "have \"lselect {m. k + m \\<in> s} (ldropn k w) =\n        lselect s (ltake (enat k) w) $ lselect {m. k + m \\<in> s} (ldropn k w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect {m. k + m \\<in> s} (ldropn k w) =\n    lselect s (ltake (enat k) w) $ lselect {m. k + m \\<in> s} (ldropn k w)", "unfolding 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect {m. k + m \\<in> s} (ldropn k w) =\n    <> $ lselect {m. k + m \\<in> s} (ldropn k w)", "by simp"], ["proof (state)\nthis:\n  lselect {m. k + m \\<in> s} (ldropn k w) =\n  lselect s (ltake (enat k) w) $ lselect {m. k + m \\<in> s} (ldropn k w)\n\ngoal (1 subgoal):\n 1. lselect {i. k + i \\<in> s} (ldropn k w) = lselect s w", "also"], ["proof (state)\nthis:\n  lselect {m. k + m \\<in> s} (ldropn k w) =\n  lselect s (ltake (enat k) w) $ lselect {m. k + m \\<in> s} (ldropn k w)\n\ngoal (1 subgoal):\n 1. lselect {i. k + i \\<in> s} (ldropn k w) = lselect s w", "have \"\\<dots> = lselect s w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect s (ltake (enat k) w) $ lselect {m. k + m \\<in> s} (ldropn k w) =\n    lselect s w", "using lnths_split"], ["proof (prove)\nusing this:\n  lselect ?A ?xs =\n  lselect ?A (ltake (enat ?n) ?xs) $\n  lselect {m. ?n + m \\<in> ?A} (ldropn ?n ?xs)\n\ngoal (1 subgoal):\n 1. lselect s (ltake (enat k) w) $ lselect {m. k + m \\<in> s} (ldropn k w) =\n    lselect s w", "by rule"], ["proof (state)\nthis:\n  lselect s (ltake (enat k) w) $ lselect {m. k + m \\<in> s} (ldropn k w) =\n  lselect s w\n\ngoal (1 subgoal):\n 1. lselect {i. k + i \\<in> s} (ldropn k w) = lselect s w", "finally"], ["proof (chain)\npicking this:\n  lselect {m. k + m \\<in> s} (ldropn k w) = lselect s w", "show ?thesis"], ["proof (prove)\nusing this:\n  lselect {m. k + m \\<in> s} (ldropn k w) = lselect s w\n\ngoal (1 subgoal):\n 1. lselect {i. k + i \\<in> s} (ldropn k w) = lselect s w", "by this"], ["proof (state)\nthis:\n  lselect {i. k + i \\<in> s} (ldropn k w) = lselect s w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lselect_discard_end:\n      assumes \"\\<And> i. i \\<in> s \\<Longrightarrow> i < k\"\n      shows \"lselect s (ltake (enat k) w) = lselect s w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect s (ltake (enat k) w) = lselect s w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lselect s (ltake (enat k) w) = lselect s w", "have 1: \"lselect {m. k + m \\<in> s} (ldropn k w) = <>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect {m. k + m \\<in> s} (ldropn k w) = <>", "using assms"], ["proof (prove)\nusing this:\n  ?i \\<in> s \\<Longrightarrow> ?i < k\n\ngoal (1 subgoal):\n 1. lselect {m. k + m \\<in> s} (ldropn k w) = <>", "by (fastforce simp add: lselect_lnull min_le_iff_disj)"], ["proof (state)\nthis:\n  lselect {m. k + m \\<in> s} (ldropn k w) = <>\n\ngoal (1 subgoal):\n 1. lselect s (ltake (enat k) w) = lselect s w", "have \"lselect s (ltake (enat k) w) =\n        lselect s (ltake (enat k) w) $ lselect {m. k + m \\<in> s} (ldropn k w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect s (ltake (enat k) w) =\n    lselect s (ltake (enat k) w) $ lselect {m. k + m \\<in> s} (ldropn k w)", "unfolding 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect s (ltake (enat k) w) = lselect s (ltake (enat k) w) $ <>", "by simp"], ["proof (state)\nthis:\n  lselect s (ltake (enat k) w) =\n  lselect s (ltake (enat k) w) $ lselect {m. k + m \\<in> s} (ldropn k w)\n\ngoal (1 subgoal):\n 1. lselect s (ltake (enat k) w) = lselect s w", "also"], ["proof (state)\nthis:\n  lselect s (ltake (enat k) w) =\n  lselect s (ltake (enat k) w) $ lselect {m. k + m \\<in> s} (ldropn k w)\n\ngoal (1 subgoal):\n 1. lselect s (ltake (enat k) w) = lselect s w", "have \"\\<dots> = lselect s w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect s (ltake (enat k) w) $ lselect {m. k + m \\<in> s} (ldropn k w) =\n    lselect s w", "using lnths_split"], ["proof (prove)\nusing this:\n  lselect ?A ?xs =\n  lselect ?A (ltake (enat ?n) ?xs) $\n  lselect {m. ?n + m \\<in> ?A} (ldropn ?n ?xs)\n\ngoal (1 subgoal):\n 1. lselect s (ltake (enat k) w) $ lselect {m. k + m \\<in> s} (ldropn k w) =\n    lselect s w", "by rule"], ["proof (state)\nthis:\n  lselect s (ltake (enat k) w) $ lselect {m. k + m \\<in> s} (ldropn k w) =\n  lselect s w\n\ngoal (1 subgoal):\n 1. lselect s (ltake (enat k) w) = lselect s w", "finally"], ["proof (chain)\npicking this:\n  lselect s (ltake (enat k) w) = lselect s w", "show ?thesis"], ["proof (prove)\nusing this:\n  lselect s (ltake (enat k) w) = lselect s w\n\ngoal (1 subgoal):\n 1. lselect s (ltake (enat k) w) = lselect s w", "by this"], ["proof (state)\nthis:\n  lselect s (ltake (enat k) w) = lselect s w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lselect_least:\n      assumes \"\\<not> lnull (lselect s w)\"\n      shows \"lselect s w = w ?! least s % lselect (s - {least s}) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect s w = w ?! least s % lselect (s - {least s}) w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lselect s w = w ?! least s % lselect (s - {least s}) w", "have 0: \"s \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<noteq> {}", "using assms"], ["proof (prove)\nusing this:\n  \\<not> lnull (lselect s w)\n\ngoal (1 subgoal):\n 1. s \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  s \\<noteq> {}\n\ngoal (1 subgoal):\n 1. lselect s w = w ?! least s % lselect (s - {least s}) w", "have 1: \"least s \\<in> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. least s \\<in> s", "using LeastI 0"], ["proof (prove)\nusing this:\n  ?P ?k \\<Longrightarrow> ?P (LEAST x. ?P x)\n  s \\<noteq> {}\n\ngoal (1 subgoal):\n 1. least s \\<in> s", "by fast"], ["proof (state)\nthis:\n  least s \\<in> s\n\ngoal (1 subgoal):\n 1. lselect s w = w ?! least s % lselect (s - {least s}) w", "have 2: \"\\<And> i. i \\<in> s \\<Longrightarrow> least s \\<le> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> s \\<Longrightarrow> least s \\<le> i", "using Least_le 0"], ["proof (prove)\nusing this:\n  ?P ?k \\<Longrightarrow> (LEAST x. ?P x) \\<le> ?k\n  s \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> s \\<Longrightarrow> least s \\<le> i", "by fast"], ["proof (state)\nthis:\n  ?i \\<in> s \\<Longrightarrow> least s \\<le> ?i\n\ngoal (1 subgoal):\n 1. lselect s w = w ?! least s % lselect (s - {least s}) w", "have 3: \"\\<And> i. i \\<in> s - {least s} \\<Longrightarrow> Suc (least s) \\<le> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> s - {least s} \\<Longrightarrow> Suc (least s) \\<le> i", "using least_unique 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?k \\<in> ?A; ?k \\<le> least ?A\\<rbrakk>\n  \\<Longrightarrow> ?k = least ?A\n  ?i \\<in> s \\<Longrightarrow> least s \\<le> ?i\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> s - {least s} \\<Longrightarrow> Suc (least s) \\<le> i", "by force"], ["proof (state)\nthis:\n  ?i \\<in> s - {least s} \\<Longrightarrow> Suc (least s) \\<le> ?i\n\ngoal (1 subgoal):\n 1. lselect s w = w ?! least s % lselect (s - {least s}) w", "have 4: \"insert (least s) (s - {least s}) = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (least s) (s - {least s}) = s", "using 1"], ["proof (prove)\nusing this:\n  least s \\<in> s\n\ngoal (1 subgoal):\n 1. insert (least s) (s - {least s}) = s", "by auto"], ["proof (state)\nthis:\n  insert (least s) (s - {least s}) = s\n\ngoal (1 subgoal):\n 1. lselect s w = w ?! least s % lselect (s - {least s}) w", "have 5: \"enat (least s) < llength w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat (least s) < llength w", "using least_lselect_llength assms"], ["proof (prove)\nusing this:\n  \\<not> lnull (lselect ?s ?w) \\<Longrightarrow>\n  enat (least ?s) < llength ?w\n  \\<not> lnull (lselect s w)\n\ngoal (1 subgoal):\n 1. enat (least s) < llength w", "by this"], ["proof (state)\nthis:\n  enat (least s) < llength w\n\ngoal (1 subgoal):\n 1. lselect s w = w ?! least s % lselect (s - {least s}) w", "have 6: \"lselect (s - {least s}) (ltake (enat (least s)) w) = <>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect (s - {least s}) (ltake (enat (least s)) w) = <>", "by (rule, auto simp: lselect_llength dest: least_not_less)"], ["proof (state)\nthis:\n  lselect (s - {least s}) (ltake (enat (least s)) w) = <>\n\ngoal (1 subgoal):\n 1. lselect s w = w ?! least s % lselect (s - {least s}) w", "have 7: \"lselect {i. Suc (least s) + i \\<in> s - {least s}} (ldropn (Suc (least s)) w) =\n        lselect (s - {least s}) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect {i. Suc (least s) + i \\<in> s - {least s}}\n     (ldropn (Suc (least s)) w) =\n    lselect (s - {least s}) w", "using lselect_discard_start 3"], ["proof (prove)\nusing this:\n  (\\<And>i. i \\<in> ?s \\<Longrightarrow> ?k \\<le> i) \\<Longrightarrow>\n  lselect {i. ?k + i \\<in> ?s} (ldropn ?k ?w) = lselect ?s ?w\n  ?i \\<in> s - {least s} \\<Longrightarrow> Suc (least s) \\<le> ?i\n\ngoal (1 subgoal):\n 1. lselect {i. Suc (least s) + i \\<in> s - {least s}}\n     (ldropn (Suc (least s)) w) =\n    lselect (s - {least s}) w", "by this"], ["proof (state)\nthis:\n  lselect {i. Suc (least s) + i \\<in> s - {least s}}\n   (ldropn (Suc (least s)) w) =\n  lselect (s - {least s}) w\n\ngoal (1 subgoal):\n 1. lselect s w = w ?! least s % lselect (s - {least s}) w", "have \"lselect s w = lselect (insert (least s) (s - {least s})) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect s w = lselect (insert (least s) (s - {least s})) w", "unfolding 4"], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect s w = lselect s w", "by simp"], ["proof (state)\nthis:\n  lselect s w = lselect (insert (least s) (s - {least s})) w\n\ngoal (1 subgoal):\n 1. lselect s w = w ?! least s % lselect (s - {least s}) w", "also"], ["proof (state)\nthis:\n  lselect s w = lselect (insert (least s) (s - {least s})) w\n\ngoal (1 subgoal):\n 1. lselect s w = w ?! least s % lselect (s - {least s}) w", "have \"\\<dots> = lselect (s - {least s}) (ltake (enat (least s)) w) $ <w ?! least s> $\n        lselect {m. Suc (least s) + m \\<in> s - {least s}} (ldropn (Suc (least s)) w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect (insert (least s) (s - {least s})) w =\n    lselect (s - {least s}) (ltake (enat (least s)) w) $\n    <w ?! least s> $\n    lselect {m. Suc (least s) + m \\<in> s - {least s}}\n     (ldropn (Suc (least s)) w)", "unfolding lnths_insert[OF 5]"], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect (s - {least s}) (ltake (enat (least s)) w) $\n    w ?! least s %\n    lselect {m. Suc (least s + m) \\<in> s - {least s}}\n     (ldropn (Suc (least s)) w) =\n    lselect (s - {least s}) (ltake (enat (least s)) w) $\n    <w ?! least s> $\n    lselect {m. Suc (least s) + m \\<in> s - {least s}}\n     (ldropn (Suc (least s)) w)", "by simp"], ["proof (state)\nthis:\n  lselect (insert (least s) (s - {least s})) w =\n  lselect (s - {least s}) (ltake (enat (least s)) w) $\n  <w ?! least s> $\n  lselect {m. Suc (least s) + m \\<in> s - {least s}}\n   (ldropn (Suc (least s)) w)\n\ngoal (1 subgoal):\n 1. lselect s w = w ?! least s % lselect (s - {least s}) w", "also"], ["proof (state)\nthis:\n  lselect (insert (least s) (s - {least s})) w =\n  lselect (s - {least s}) (ltake (enat (least s)) w) $\n  <w ?! least s> $\n  lselect {m. Suc (least s) + m \\<in> s - {least s}}\n   (ldropn (Suc (least s)) w)\n\ngoal (1 subgoal):\n 1. lselect s w = w ?! least s % lselect (s - {least s}) w", "have \"\\<dots> = <w ?! least s> $\n        lselect {m. Suc (least s) + m \\<in> s - {least s}} (ldropn (Suc (least s)) w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect (s - {least s}) (ltake (enat (least s)) w) $\n    <w ?! least s> $\n    lselect {m. Suc (least s) + m \\<in> s - {least s}}\n     (ldropn (Suc (least s)) w) =\n    <w ?! least s> $\n    lselect {m. Suc (least s) + m \\<in> s - {least s}}\n     (ldropn (Suc (least s)) w)", "unfolding 6"], ["proof (prove)\ngoal (1 subgoal):\n 1. <> $\n    <w ?! least s> $\n    lselect {m. Suc (least s) + m \\<in> s - {least s}}\n     (ldropn (Suc (least s)) w) =\n    <w ?! least s> $\n    lselect {m. Suc (least s) + m \\<in> s - {least s}}\n     (ldropn (Suc (least s)) w)", "by simp"], ["proof (state)\nthis:\n  lselect (s - {least s}) (ltake (enat (least s)) w) $\n  <w ?! least s> $\n  lselect {m. Suc (least s) + m \\<in> s - {least s}}\n   (ldropn (Suc (least s)) w) =\n  <w ?! least s> $\n  lselect {m. Suc (least s) + m \\<in> s - {least s}}\n   (ldropn (Suc (least s)) w)\n\ngoal (1 subgoal):\n 1. lselect s w = w ?! least s % lselect (s - {least s}) w", "also"], ["proof (state)\nthis:\n  lselect (s - {least s}) (ltake (enat (least s)) w) $\n  <w ?! least s> $\n  lselect {m. Suc (least s) + m \\<in> s - {least s}}\n   (ldropn (Suc (least s)) w) =\n  <w ?! least s> $\n  lselect {m. Suc (least s) + m \\<in> s - {least s}}\n   (ldropn (Suc (least s)) w)\n\ngoal (1 subgoal):\n 1. lselect s w = w ?! least s % lselect (s - {least s}) w", "have \"\\<dots> = w ?! (least s) % lselect (s - {least s}) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <w ?! least s> $\n    lselect {m. Suc (least s) + m \\<in> s - {least s}}\n     (ldropn (Suc (least s)) w) =\n    w ?! least s % lselect (s - {least s}) w", "unfolding 7"], ["proof (prove)\ngoal (1 subgoal):\n 1. <w ?! least s> $ lselect (s - {least s}) w =\n    w ?! least s % lselect (s - {least s}) w", "by simp"], ["proof (state)\nthis:\n  <w ?! least s> $\n  lselect {m. Suc (least s) + m \\<in> s - {least s}}\n   (ldropn (Suc (least s)) w) =\n  w ?! least s % lselect (s - {least s}) w\n\ngoal (1 subgoal):\n 1. lselect s w = w ?! least s % lselect (s - {least s}) w", "finally"], ["proof (chain)\npicking this:\n  lselect s w = w ?! least s % lselect (s - {least s}) w", "show ?thesis"], ["proof (prove)\nusing this:\n  lselect s w = w ?! least s % lselect (s - {least s}) w\n\ngoal (1 subgoal):\n 1. lselect s w = w ?! least s % lselect (s - {least s}) w", "by this"], ["proof (state)\nthis:\n  lselect s w = w ?! least s % lselect (s - {least s}) w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lselect_lnth[simp]:\n      assumes \"enat i < llength (lselect s w)\"\n      shows \"lselect s w ?! i = w ?! nth_least s i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect s w ?! i = w ?! nth_least s i", "using assms"], ["proof (prove)\nusing this:\n  enat i < llength (lselect s w)\n\ngoal (1 subgoal):\n 1. lselect s w ?! i = w ?! nth_least s i", "proof (induct i arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       enat 0 < llength (lselect s w) \\<Longrightarrow>\n       lselect s w ?! 0 = w ?! nth_least s 0\n 2. \\<And>i s.\n       \\<lbrakk>\\<And>s.\n                   enat i < llength (lselect s w) \\<Longrightarrow>\n                   lselect s w ?! i = w ?! nth_least s i;\n        enat (Suc i) < llength (lselect s w)\\<rbrakk>\n       \\<Longrightarrow> lselect s w ?! Suc i = w ?! nth_least s (Suc i)", "case 0"], ["proof (state)\nthis:\n  enat 0 < llength (lselect s w)\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       enat 0 < llength (lselect s w) \\<Longrightarrow>\n       lselect s w ?! 0 = w ?! nth_least s 0\n 2. \\<And>i s.\n       \\<lbrakk>\\<And>s.\n                   enat i < llength (lselect s w) \\<Longrightarrow>\n                   lselect s w ?! i = w ?! nth_least s i;\n        enat (Suc i) < llength (lselect s w)\\<rbrakk>\n       \\<Longrightarrow> lselect s w ?! Suc i = w ?! nth_least s (Suc i)", "have 1: \"\\<not> lnull (lselect s w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lnull (lselect s w)", "using 0"], ["proof (prove)\nusing this:\n  enat 0 < llength (lselect s w)\n\ngoal (1 subgoal):\n 1. \\<not> lnull (lselect s w)", "by auto"], ["proof (state)\nthis:\n  \\<not> lnull (lselect s w)\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       enat 0 < llength (lselect s w) \\<Longrightarrow>\n       lselect s w ?! 0 = w ?! nth_least s 0\n 2. \\<And>i s.\n       \\<lbrakk>\\<And>s.\n                   enat i < llength (lselect s w) \\<Longrightarrow>\n                   lselect s w ?! i = w ?! nth_least s i;\n        enat (Suc i) < llength (lselect s w)\\<rbrakk>\n       \\<Longrightarrow> lselect s w ?! Suc i = w ?! nth_least s (Suc i)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect s w ?! 0 = w ?! nth_least s 0", "using lselect_least 1"], ["proof (prove)\nusing this:\n  \\<not> lnull (lselect ?s ?w) \\<Longrightarrow>\n  lselect ?s ?w = ?w ?! least ?s % lselect (?s - {least ?s}) ?w\n  \\<not> lnull (lselect s w)\n\ngoal (1 subgoal):\n 1. lselect s w ?! 0 = w ?! nth_least s 0", "by force"], ["proof (state)\nthis:\n  lselect s w ?! 0 = w ?! nth_least s 0\n\ngoal (1 subgoal):\n 1. \\<And>i s.\n       \\<lbrakk>\\<And>s.\n                   enat i < llength (lselect s w) \\<Longrightarrow>\n                   lselect s w ?! i = w ?! nth_least s i;\n        enat (Suc i) < llength (lselect s w)\\<rbrakk>\n       \\<Longrightarrow> lselect s w ?! Suc i = w ?! nth_least s (Suc i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i s.\n       \\<lbrakk>\\<And>s.\n                   enat i < llength (lselect s w) \\<Longrightarrow>\n                   lselect s w ?! i = w ?! nth_least s i;\n        enat (Suc i) < llength (lselect s w)\\<rbrakk>\n       \\<Longrightarrow> lselect s w ?! Suc i = w ?! nth_least s (Suc i)", "case (Suc i)"], ["proof (state)\nthis:\n  enat i < llength (lselect ?s w) \\<Longrightarrow>\n  lselect ?s w ?! i = w ?! nth_least ?s i\n  enat (Suc i) < llength (lselect s w)\n\ngoal (1 subgoal):\n 1. \\<And>i s.\n       \\<lbrakk>\\<And>s.\n                   enat i < llength (lselect s w) \\<Longrightarrow>\n                   lselect s w ?! i = w ?! nth_least s i;\n        enat (Suc i) < llength (lselect s w)\\<rbrakk>\n       \\<Longrightarrow> lselect s w ?! Suc i = w ?! nth_least s (Suc i)", "have 1: \"\\<not> lnull (lselect s w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lnull (lselect s w)", "using Suc(2)"], ["proof (prove)\nusing this:\n  enat (Suc i) < llength (lselect s w)\n\ngoal (1 subgoal):\n 1. \\<not> lnull (lselect s w)", "by auto"], ["proof (state)\nthis:\n  \\<not> lnull (lselect s w)\n\ngoal (1 subgoal):\n 1. \\<And>i s.\n       \\<lbrakk>\\<And>s.\n                   enat i < llength (lselect s w) \\<Longrightarrow>\n                   lselect s w ?! i = w ?! nth_least s i;\n        enat (Suc i) < llength (lselect s w)\\<rbrakk>\n       \\<Longrightarrow> lselect s w ?! Suc i = w ?! nth_least s (Suc i)", "have 2: \"lselect s w = w ?! least s % lselect (s - {least s}) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect s w = w ?! least s % lselect (s - {least s}) w", "using lselect_least 1"], ["proof (prove)\nusing this:\n  \\<not> lnull (lselect ?s ?w) \\<Longrightarrow>\n  lselect ?s ?w = ?w ?! least ?s % lselect (?s - {least ?s}) ?w\n  \\<not> lnull (lselect s w)\n\ngoal (1 subgoal):\n 1. lselect s w = w ?! least s % lselect (s - {least s}) w", "by this"], ["proof (state)\nthis:\n  lselect s w = w ?! least s % lselect (s - {least s}) w\n\ngoal (1 subgoal):\n 1. \\<And>i s.\n       \\<lbrakk>\\<And>s.\n                   enat i < llength (lselect s w) \\<Longrightarrow>\n                   lselect s w ?! i = w ?! nth_least s i;\n        enat (Suc i) < llength (lselect s w)\\<rbrakk>\n       \\<Longrightarrow> lselect s w ?! Suc i = w ?! nth_least s (Suc i)", "have 3: \"llength (lselect s w) = eSuc (llength (lselect (s - {least s}) w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (lselect s w) = eSuc (llength (lselect (s - {least s}) w))", "using 2"], ["proof (prove)\nusing this:\n  lselect s w = w ?! least s % lselect (s - {least s}) w\n\ngoal (1 subgoal):\n 1. llength (lselect s w) = eSuc (llength (lselect (s - {least s}) w))", "by simp"], ["proof (state)\nthis:\n  llength (lselect s w) = eSuc (llength (lselect (s - {least s}) w))\n\ngoal (1 subgoal):\n 1. \\<And>i s.\n       \\<lbrakk>\\<And>s.\n                   enat i < llength (lselect s w) \\<Longrightarrow>\n                   lselect s w ?! i = w ?! nth_least s i;\n        enat (Suc i) < llength (lselect s w)\\<rbrakk>\n       \\<Longrightarrow> lselect s w ?! Suc i = w ?! nth_least s (Suc i)", "have 4: \"enat i < llength (lselect (s - {least s}) w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat i < llength (lselect (s - {least s}) w)", "using 3 Suc(2)"], ["proof (prove)\nusing this:\n  llength (lselect s w) = eSuc (llength (lselect (s - {least s}) w))\n  enat (Suc i) < llength (lselect s w)\n\ngoal (1 subgoal):\n 1. enat i < llength (lselect (s - {least s}) w)", "by simp"], ["proof (state)\nthis:\n  enat i < llength (lselect (s - {least s}) w)\n\ngoal (1 subgoal):\n 1. \\<And>i s.\n       \\<lbrakk>\\<And>s.\n                   enat i < llength (lselect s w) \\<Longrightarrow>\n                   lselect s w ?! i = w ?! nth_least s i;\n        enat (Suc i) < llength (lselect s w)\\<rbrakk>\n       \\<Longrightarrow> lselect s w ?! Suc i = w ?! nth_least s (Suc i)", "have \"lselect s w ?! Suc i = (w ?! least s % lselect (s - {least s}) w) ?! Suc i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect s w ?! Suc i =\n    (w ?! least s % lselect (s - {least s}) w) ?! Suc i", "using 2"], ["proof (prove)\nusing this:\n  lselect s w = w ?! least s % lselect (s - {least s}) w\n\ngoal (1 subgoal):\n 1. lselect s w ?! Suc i =\n    (w ?! least s % lselect (s - {least s}) w) ?! Suc i", "by simp"], ["proof (state)\nthis:\n  lselect s w ?! Suc i = (w ?! least s % lselect (s - {least s}) w) ?! Suc i\n\ngoal (1 subgoal):\n 1. \\<And>i s.\n       \\<lbrakk>\\<And>s.\n                   enat i < llength (lselect s w) \\<Longrightarrow>\n                   lselect s w ?! i = w ?! nth_least s i;\n        enat (Suc i) < llength (lselect s w)\\<rbrakk>\n       \\<Longrightarrow> lselect s w ?! Suc i = w ?! nth_least s (Suc i)", "also"], ["proof (state)\nthis:\n  lselect s w ?! Suc i = (w ?! least s % lselect (s - {least s}) w) ?! Suc i\n\ngoal (1 subgoal):\n 1. \\<And>i s.\n       \\<lbrakk>\\<And>s.\n                   enat i < llength (lselect s w) \\<Longrightarrow>\n                   lselect s w ?! i = w ?! nth_least s i;\n        enat (Suc i) < llength (lselect s w)\\<rbrakk>\n       \\<Longrightarrow> lselect s w ?! Suc i = w ?! nth_least s (Suc i)", "have \"\\<dots> = lselect (s - {least s}) w ?! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w ?! least s % lselect (s - {least s}) w) ?! Suc i =\n    lselect (s - {least s}) w ?! i", "by simp"], ["proof (state)\nthis:\n  (w ?! least s % lselect (s - {least s}) w) ?! Suc i =\n  lselect (s - {least s}) w ?! i\n\ngoal (1 subgoal):\n 1. \\<And>i s.\n       \\<lbrakk>\\<And>s.\n                   enat i < llength (lselect s w) \\<Longrightarrow>\n                   lselect s w ?! i = w ?! nth_least s i;\n        enat (Suc i) < llength (lselect s w)\\<rbrakk>\n       \\<Longrightarrow> lselect s w ?! Suc i = w ?! nth_least s (Suc i)", "also"], ["proof (state)\nthis:\n  (w ?! least s % lselect (s - {least s}) w) ?! Suc i =\n  lselect (s - {least s}) w ?! i\n\ngoal (1 subgoal):\n 1. \\<And>i s.\n       \\<lbrakk>\\<And>s.\n                   enat i < llength (lselect s w) \\<Longrightarrow>\n                   lselect s w ?! i = w ?! nth_least s i;\n        enat (Suc i) < llength (lselect s w)\\<rbrakk>\n       \\<Longrightarrow> lselect s w ?! Suc i = w ?! nth_least s (Suc i)", "have \"\\<dots> = w ?! nth_least (s - {least s}) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect (s - {least s}) w ?! i = w ?! nth_least (s - {least s}) i", "using Suc(1) 4"], ["proof (prove)\nusing this:\n  enat i < llength (lselect ?s w) \\<Longrightarrow>\n  lselect ?s w ?! i = w ?! nth_least ?s i\n  enat i < llength (lselect (s - {least s}) w)\n\ngoal (1 subgoal):\n 1. lselect (s - {least s}) w ?! i = w ?! nth_least (s - {least s}) i", "by simp"], ["proof (state)\nthis:\n  lselect (s - {least s}) w ?! i = w ?! nth_least (s - {least s}) i\n\ngoal (1 subgoal):\n 1. \\<And>i s.\n       \\<lbrakk>\\<And>s.\n                   enat i < llength (lselect s w) \\<Longrightarrow>\n                   lselect s w ?! i = w ?! nth_least s i;\n        enat (Suc i) < llength (lselect s w)\\<rbrakk>\n       \\<Longrightarrow> lselect s w ?! Suc i = w ?! nth_least s (Suc i)", "also"], ["proof (state)\nthis:\n  lselect (s - {least s}) w ?! i = w ?! nth_least (s - {least s}) i\n\ngoal (1 subgoal):\n 1. \\<And>i s.\n       \\<lbrakk>\\<And>s.\n                   enat i < llength (lselect s w) \\<Longrightarrow>\n                   lselect s w ?! i = w ?! nth_least s i;\n        enat (Suc i) < llength (lselect s w)\\<rbrakk>\n       \\<Longrightarrow> lselect s w ?! Suc i = w ?! nth_least s (Suc i)", "have \"\\<dots> = w ?! nth_least s (Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w ?! nth_least (s - {least s}) i = w ?! nth_least s (Suc i)", "by simp"], ["proof (state)\nthis:\n  w ?! nth_least (s - {least s}) i = w ?! nth_least s (Suc i)\n\ngoal (1 subgoal):\n 1. \\<And>i s.\n       \\<lbrakk>\\<And>s.\n                   enat i < llength (lselect s w) \\<Longrightarrow>\n                   lselect s w ?! i = w ?! nth_least s i;\n        enat (Suc i) < llength (lselect s w)\\<rbrakk>\n       \\<Longrightarrow> lselect s w ?! Suc i = w ?! nth_least s (Suc i)", "finally"], ["proof (chain)\npicking this:\n  lselect s w ?! Suc i = w ?! nth_least s (Suc i)", "show ?case"], ["proof (prove)\nusing this:\n  lselect s w ?! Suc i = w ?! nth_least s (Suc i)\n\ngoal (1 subgoal):\n 1. lselect s w ?! Suc i = w ?! nth_least s (Suc i)", "by this"], ["proof (state)\nthis:\n  lselect s w ?! Suc i = w ?! nth_least s (Suc i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lproject_lnth[simp]:\n      assumes \"enat i < llength (lproject A w)\"\n      shows \"lproject A w ?! i = w ?! nth_least (liset A w) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lproject A w ?! i = w ?! nth_least (liset A w) i", "using assms"], ["proof (prove)\nusing this:\n  enat i < llength (lproject A w)\n\ngoal (1 subgoal):\n 1. lproject A w ?! i = w ?! nth_least (liset A w) i", "unfolding lproject_to_lselect"], ["proof (prove)\nusing this:\n  enat i < llength (lselect (liset A w) w)\n\ngoal (1 subgoal):\n 1. lselect (liset A w) w ?! i = w ?! nth_least (liset A w) i", "by simp"], ["", "lemma lproject_ltake[simp]:\n      assumes \"enat k \\<le> llength (lproject A w)\"\n      shows \"lproject A (ltake (enat (nth_least (lift (liset A w)) k)) w) =\n        ltake (enat k) (lproject A w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lproject A (ltake (enat (nth_least (lift (liset A w)) k)) w) =\n    ltake (enat k) (lproject A w)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. llength (lproject A (ltake (enat (nth_least (lift (liset A w)) k)) w)) =\n    llength (ltake (enat k) (lproject A w))\n 2. \\<And>i.\n       \\<lbrakk>enat i\n                < llength\n                   (lproject A\n                     (ltake (enat (nth_least (lift (liset A w)) k)) w));\n        enat i < llength (ltake (enat k) (lproject A w))\\<rbrakk>\n       \\<Longrightarrow> lproject A\n                          (ltake (enat (nth_least (lift (liset A w)) k))\n                            w) ?!\n                         i =\n                         ltake (enat k) (lproject A w) ?! i", "have \"llength (lproject A (ltake (enat (nth_least (lift (liset A w)) k)) w)) =\n        enat (card (liset A w \\<inter> {..< nth_least (lift (liset A w)) k}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (lproject A (ltake (enat (nth_least (lift (liset A w)) k)) w)) =\n    enat (card (liset A w \\<inter> {..<nth_least (lift (liset A w)) k}))", "by simp"], ["proof (state)\nthis:\n  llength (lproject A (ltake (enat (nth_least (lift (liset A w)) k)) w)) =\n  enat (card (liset A w \\<inter> {..<nth_least (lift (liset A w)) k}))\n\ngoal (2 subgoals):\n 1. llength (lproject A (ltake (enat (nth_least (lift (liset A w)) k)) w)) =\n    llength (ltake (enat k) (lproject A w))\n 2. \\<And>i.\n       \\<lbrakk>enat i\n                < llength\n                   (lproject A\n                     (ltake (enat (nth_least (lift (liset A w)) k)) w));\n        enat i < llength (ltake (enat k) (lproject A w))\\<rbrakk>\n       \\<Longrightarrow> lproject A\n                          (ltake (enat (nth_least (lift (liset A w)) k))\n                            w) ?!\n                         i =\n                         ltake (enat k) (lproject A w) ?! i", "also"], ["proof (state)\nthis:\n  llength (lproject A (ltake (enat (nth_least (lift (liset A w)) k)) w)) =\n  enat (card (liset A w \\<inter> {..<nth_least (lift (liset A w)) k}))\n\ngoal (2 subgoals):\n 1. llength (lproject A (ltake (enat (nth_least (lift (liset A w)) k)) w)) =\n    llength (ltake (enat k) (lproject A w))\n 2. \\<And>i.\n       \\<lbrakk>enat i\n                < llength\n                   (lproject A\n                     (ltake (enat (nth_least (lift (liset A w)) k)) w));\n        enat i < llength (ltake (enat k) (lproject A w))\\<rbrakk>\n       \\<Longrightarrow> lproject A\n                          (ltake (enat (nth_least (lift (liset A w)) k))\n                            w) ?!\n                         i =\n                         ltake (enat k) (lproject A w) ?! i", "have \"\\<dots> = enat (card {i \\<in> liset A w. i < nth_least (lift (liset A w)) k})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat (card (liset A w \\<inter> {..<nth_least (lift (liset A w)) k})) =\n    enat (card {i \\<in> liset A w. i < nth_least (lift (liset A w)) k})", "unfolding lessThan_def Collect_conj_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. enat\n     (card (liset A w \\<inter> {x. x < nth_least (lift (liset A w)) k})) =\n    enat\n     (card\n       ({i. i \\<in> liset A w} \\<inter>\n        {i. i < nth_least (lift (liset A w)) k}))", "by simp"], ["proof (state)\nthis:\n  enat (card (liset A w \\<inter> {..<nth_least (lift (liset A w)) k})) =\n  enat (card {i \\<in> liset A w. i < nth_least (lift (liset A w)) k})\n\ngoal (2 subgoals):\n 1. llength (lproject A (ltake (enat (nth_least (lift (liset A w)) k)) w)) =\n    llength (ltake (enat k) (lproject A w))\n 2. \\<And>i.\n       \\<lbrakk>enat i\n                < llength\n                   (lproject A\n                     (ltake (enat (nth_least (lift (liset A w)) k)) w));\n        enat i < llength (ltake (enat k) (lproject A w))\\<rbrakk>\n       \\<Longrightarrow> lproject A\n                          (ltake (enat (nth_least (lift (liset A w)) k))\n                            w) ?!\n                         i =\n                         ltake (enat k) (lproject A w) ?! i", "also"], ["proof (state)\nthis:\n  enat (card (liset A w \\<inter> {..<nth_least (lift (liset A w)) k})) =\n  enat (card {i \\<in> liset A w. i < nth_least (lift (liset A w)) k})\n\ngoal (2 subgoals):\n 1. llength (lproject A (ltake (enat (nth_least (lift (liset A w)) k)) w)) =\n    llength (ltake (enat k) (lproject A w))\n 2. \\<And>i.\n       \\<lbrakk>enat i\n                < llength\n                   (lproject A\n                     (ltake (enat (nth_least (lift (liset A w)) k)) w));\n        enat i < llength (ltake (enat k) (lproject A w))\\<rbrakk>\n       \\<Longrightarrow> lproject A\n                          (ltake (enat (nth_least (lift (liset A w)) k))\n                            w) ?!\n                         i =\n                         ltake (enat k) (lproject A w) ?! i", "have \"\\<dots> = enat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat (card {i \\<in> liset A w. i < nth_least (lift (liset A w)) k}) =\n    enat k", "using assms"], ["proof (prove)\nusing this:\n  enat k \\<le> llength (lproject A w)\n\ngoal (1 subgoal):\n 1. enat (card {i \\<in> liset A w. i < nth_least (lift (liset A w)) k}) =\n    enat k", "by simp"], ["proof (state)\nthis:\n  enat (card {i \\<in> liset A w. i < nth_least (lift (liset A w)) k}) =\n  enat k\n\ngoal (2 subgoals):\n 1. llength (lproject A (ltake (enat (nth_least (lift (liset A w)) k)) w)) =\n    llength (ltake (enat k) (lproject A w))\n 2. \\<And>i.\n       \\<lbrakk>enat i\n                < llength\n                   (lproject A\n                     (ltake (enat (nth_least (lift (liset A w)) k)) w));\n        enat i < llength (ltake (enat k) (lproject A w))\\<rbrakk>\n       \\<Longrightarrow> lproject A\n                          (ltake (enat (nth_least (lift (liset A w)) k))\n                            w) ?!\n                         i =\n                         ltake (enat k) (lproject A w) ?! i", "also"], ["proof (state)\nthis:\n  enat (card {i \\<in> liset A w. i < nth_least (lift (liset A w)) k}) =\n  enat k\n\ngoal (2 subgoals):\n 1. llength (lproject A (ltake (enat (nth_least (lift (liset A w)) k)) w)) =\n    llength (ltake (enat k) (lproject A w))\n 2. \\<And>i.\n       \\<lbrakk>enat i\n                < llength\n                   (lproject A\n                     (ltake (enat (nth_least (lift (liset A w)) k)) w));\n        enat i < llength (ltake (enat k) (lproject A w))\\<rbrakk>\n       \\<Longrightarrow> lproject A\n                          (ltake (enat (nth_least (lift (liset A w)) k))\n                            w) ?!\n                         i =\n                         ltake (enat k) (lproject A w) ?! i", "have \"\\<dots> = llength (ltake (enat k) (lproject A w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat k = llength (ltake (enat k) (lproject A w))", "using min_absorb1 assms"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<Longrightarrow> min ?x ?y = ?x\n  enat k \\<le> llength (lproject A w)\n\ngoal (1 subgoal):\n 1. enat k = llength (ltake (enat k) (lproject A w))", "by force"], ["proof (state)\nthis:\n  enat k = llength (ltake (enat k) (lproject A w))\n\ngoal (2 subgoals):\n 1. llength (lproject A (ltake (enat (nth_least (lift (liset A w)) k)) w)) =\n    llength (ltake (enat k) (lproject A w))\n 2. \\<And>i.\n       \\<lbrakk>enat i\n                < llength\n                   (lproject A\n                     (ltake (enat (nth_least (lift (liset A w)) k)) w));\n        enat i < llength (ltake (enat k) (lproject A w))\\<rbrakk>\n       \\<Longrightarrow> lproject A\n                          (ltake (enat (nth_least (lift (liset A w)) k))\n                            w) ?!\n                         i =\n                         ltake (enat k) (lproject A w) ?! i", "finally"], ["proof (chain)\npicking this:\n  llength (lproject A (ltake (enat (nth_least (lift (liset A w)) k)) w)) =\n  llength (ltake (enat k) (lproject A w))", "show \"llength (lproject A (ltake (enat (nth_least (lift (liset A w)) k)) w)) =\n        llength (ltake (enat k) (lproject A w))\""], ["proof (prove)\nusing this:\n  llength (lproject A (ltake (enat (nth_least (lift (liset A w)) k)) w)) =\n  llength (ltake (enat k) (lproject A w))\n\ngoal (1 subgoal):\n 1. llength (lproject A (ltake (enat (nth_least (lift (liset A w)) k)) w)) =\n    llength (ltake (enat k) (lproject A w))", "by this"], ["proof (state)\nthis:\n  llength (lproject A (ltake (enat (nth_least (lift (liset A w)) k)) w)) =\n  llength (ltake (enat k) (lproject A w))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>enat i\n                < llength\n                   (lproject A\n                     (ltake (enat (nth_least (lift (liset A w)) k)) w));\n        enat i < llength (ltake (enat k) (lproject A w))\\<rbrakk>\n       \\<Longrightarrow> lproject A\n                          (ltake (enat (nth_least (lift (liset A w)) k))\n                            w) ?!\n                         i =\n                         ltake (enat k) (lproject A w) ?! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>enat i\n                < llength\n                   (lproject A\n                     (ltake (enat (nth_least (lift (liset A w)) k)) w));\n        enat i < llength (ltake (enat k) (lproject A w))\\<rbrakk>\n       \\<Longrightarrow> lproject A\n                          (ltake (enat (nth_least (lift (liset A w)) k))\n                            w) ?!\n                         i =\n                         ltake (enat k) (lproject A w) ?! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>enat i\n                < llength\n                   (lproject A\n                     (ltake (enat (nth_least (lift (liset A w)) k)) w));\n        enat i < llength (ltake (enat k) (lproject A w))\\<rbrakk>\n       \\<Longrightarrow> lproject A\n                          (ltake (enat (nth_least (lift (liset A w)) k))\n                            w) ?!\n                         i =\n                         ltake (enat k) (lproject A w) ?! i", "assume 1: \"enat i < llength (lproject A (ltake (enat (nth_least (lift (liset A w)) k)) w))\""], ["proof (state)\nthis:\n  enat i\n  < llength (lproject A (ltake (enat (nth_least (lift (liset A w)) k)) w))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>enat i\n                < llength\n                   (lproject A\n                     (ltake (enat (nth_least (lift (liset A w)) k)) w));\n        enat i < llength (ltake (enat k) (lproject A w))\\<rbrakk>\n       \\<Longrightarrow> lproject A\n                          (ltake (enat (nth_least (lift (liset A w)) k))\n                            w) ?!\n                         i =\n                         ltake (enat k) (lproject A w) ?! i", "assume 2: \"enat i < llength (ltake (enat k) (lproject A w))\""], ["proof (state)\nthis:\n  enat i < llength (ltake (enat k) (lproject A w))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>enat i\n                < llength\n                   (lproject A\n                     (ltake (enat (nth_least (lift (liset A w)) k)) w));\n        enat i < llength (ltake (enat k) (lproject A w))\\<rbrakk>\n       \\<Longrightarrow> lproject A\n                          (ltake (enat (nth_least (lift (liset A w)) k))\n                            w) ?!\n                         i =\n                         ltake (enat k) (lproject A w) ?! i", "obtain k' where 3: \"k = Suc k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k'. k = Suc k' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using 2 nat.exhaust"], ["proof (prove)\nusing this:\n  enat i < llength (ltake (enat k) (lproject A w))\n  \\<lbrakk>?y = 0 \\<Longrightarrow> ?P;\n   \\<And>x2. ?y = Suc x2 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>k'. k = Suc k' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  k = Suc k'\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>enat i\n                < llength\n                   (lproject A\n                     (ltake (enat (nth_least (lift (liset A w)) k)) w));\n        enat i < llength (ltake (enat k) (lproject A w))\\<rbrakk>\n       \\<Longrightarrow> lproject A\n                          (ltake (enat (nth_least (lift (liset A w)) k))\n                            w) ?!\n                         i =\n                         ltake (enat k) (lproject A w) ?! i", "have 4: \"enat k' < llength (lproject A w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat k' < llength (lproject A w)", "using assms 3"], ["proof (prove)\nusing this:\n  enat k \\<le> llength (lproject A w)\n  k = Suc k'\n\ngoal (1 subgoal):\n 1. enat k' < llength (lproject A w)", "by simp"], ["proof (state)\nthis:\n  enat k' < llength (lproject A w)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>enat i\n                < llength\n                   (lproject A\n                     (ltake (enat (nth_least (lift (liset A w)) k)) w));\n        enat i < llength (ltake (enat k) (lproject A w))\\<rbrakk>\n       \\<Longrightarrow> lproject A\n                          (ltake (enat (nth_least (lift (liset A w)) k))\n                            w) ?!\n                         i =\n                         ltake (enat k) (lproject A w) ?! i", "have 5: \"i \\<le> k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> k'", "using 2 3"], ["proof (prove)\nusing this:\n  enat i < llength (ltake (enat k) (lproject A w))\n  k = Suc k'\n\ngoal (1 subgoal):\n 1. i \\<le> k'", "by simp"], ["proof (state)\nthis:\n  i \\<le> k'\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>enat i\n                < llength\n                   (lproject A\n                     (ltake (enat (nth_least (lift (liset A w)) k)) w));\n        enat i < llength (ltake (enat k) (lproject A w))\\<rbrakk>\n       \\<Longrightarrow> lproject A\n                          (ltake (enat (nth_least (lift (liset A w)) k))\n                            w) ?!\n                         i =\n                         ltake (enat k) (lproject A w) ?! i", "have 6: \"nth_least (lift (liset A w)) k = Suc (nth_least (liset A w) k')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nth_least (lift (liset A w)) k = Suc (nth_least (liset A w) k')", "using 3 4"], ["proof (prove)\nusing this:\n  k = Suc k'\n  enat k' < llength (lproject A w)\n\ngoal (1 subgoal):\n 1. nth_least (lift (liset A w)) k = Suc (nth_least (liset A w) k')", "by (simp del: nth_least.simps)"], ["proof (state)\nthis:\n  nth_least (lift (liset A w)) k = Suc (nth_least (liset A w) k')\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>enat i\n                < llength\n                   (lproject A\n                     (ltake (enat (nth_least (lift (liset A w)) k)) w));\n        enat i < llength (ltake (enat k) (lproject A w))\\<rbrakk>\n       \\<Longrightarrow> lproject A\n                          (ltake (enat (nth_least (lift (liset A w)) k))\n                            w) ?!\n                         i =\n                         ltake (enat k) (lproject A w) ?! i", "have 7: \"nth_least (liset A w) i < Suc (nth_least (liset A w) k')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nth_least (liset A w) i < Suc (nth_least (liset A w) k')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nth_least (liset A w) i < Suc (nth_least (liset A w) k')", "have \"nth_least (liset A w) i \\<le> nth_least (liset A w) k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nth_least (liset A w) i \\<le> nth_least (liset A w) k'", "using 4 5"], ["proof (prove)\nusing this:\n  enat k' < llength (lproject A w)\n  i \\<le> k'\n\ngoal (1 subgoal):\n 1. nth_least (liset A w) i \\<le> nth_least (liset A w) k'", "by simp"], ["proof (state)\nthis:\n  nth_least (liset A w) i \\<le> nth_least (liset A w) k'\n\ngoal (1 subgoal):\n 1. nth_least (liset A w) i < Suc (nth_least (liset A w) k')", "also"], ["proof (state)\nthis:\n  nth_least (liset A w) i \\<le> nth_least (liset A w) k'\n\ngoal (1 subgoal):\n 1. nth_least (liset A w) i < Suc (nth_least (liset A w) k')", "have \"\\<dots> < Suc (nth_least (liset A w) k')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nth_least (liset A w) k' < Suc (nth_least (liset A w) k')", "by simp"], ["proof (state)\nthis:\n  nth_least (liset A w) k' < Suc (nth_least (liset A w) k')\n\ngoal (1 subgoal):\n 1. nth_least (liset A w) i < Suc (nth_least (liset A w) k')", "finally"], ["proof (chain)\npicking this:\n  nth_least (liset A w) i < Suc (nth_least (liset A w) k')", "show ?thesis"], ["proof (prove)\nusing this:\n  nth_least (liset A w) i < Suc (nth_least (liset A w) k')\n\ngoal (1 subgoal):\n 1. nth_least (liset A w) i < Suc (nth_least (liset A w) k')", "by this"], ["proof (state)\nthis:\n  nth_least (liset A w) i < Suc (nth_least (liset A w) k')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nth_least (liset A w) i < Suc (nth_least (liset A w) k')\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>enat i\n                < llength\n                   (lproject A\n                     (ltake (enat (nth_least (lift (liset A w)) k)) w));\n        enat i < llength (ltake (enat k) (lproject A w))\\<rbrakk>\n       \\<Longrightarrow> lproject A\n                          (ltake (enat (nth_least (lift (liset A w)) k))\n                            w) ?!\n                         i =\n                         ltake (enat k) (lproject A w) ?! i", "have 8: \"nth_least (liset A w \\<inter> {..< Suc (nth_least (liset A w) k')}) i =\n        nth_least (liset A w) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nth_least (liset A w \\<inter> {..<Suc (nth_least (liset A w) k')}) i =\n    nth_least (liset A w) i", "proof (rule nth_least_eq)"], ["proof (state)\ngoal (3 subgoals):\n 1. enat i < esize (liset A w \\<inter> {..<Suc (nth_least (liset A w) k')})\n 2. enat i < esize (liset A w)\n 3. \\<And>ia.\n       \\<lbrakk>ia \\<le> nth_least\n                          (liset A w \\<inter>\n                           {..<Suc (nth_least (liset A w) k')})\n                          i;\n        ia \\<le> nth_least (liset A w) i\\<rbrakk>\n       \\<Longrightarrow> (ia \\<in> liset A w \\<inter>\n                                   {..<Suc (nth_least (liset A w) k')}) =\n                         (ia \\<in> liset A w)", "show \"enat i < esize (liset A w \\<inter> {..< Suc (nth_least (liset A w) k')})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat i < esize (liset A w \\<inter> {..<Suc (nth_least (liset A w) k')})", "using 1 6"], ["proof (prove)\nusing this:\n  enat i\n  < llength (lproject A (ltake (enat (nth_least (lift (liset A w)) k)) w))\n  nth_least (lift (liset A w)) k = Suc (nth_least (liset A w) k')\n\ngoal (1 subgoal):\n 1. enat i < esize (liset A w \\<inter> {..<Suc (nth_least (liset A w) k')})", "by simp"], ["proof (state)\nthis:\n  enat i < esize (liset A w \\<inter> {..<Suc (nth_least (liset A w) k')})\n\ngoal (2 subgoals):\n 1. enat i < esize (liset A w)\n 2. \\<And>ia.\n       \\<lbrakk>ia \\<le> nth_least\n                          (liset A w \\<inter>\n                           {..<Suc (nth_least (liset A w) k')})\n                          i;\n        ia \\<le> nth_least (liset A w) i\\<rbrakk>\n       \\<Longrightarrow> (ia \\<in> liset A w \\<inter>\n                                   {..<Suc (nth_least (liset A w) k')}) =\n                         (ia \\<in> liset A w)", "have \"enat i \\<le> enat k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat i \\<le> enat k'", "using 5"], ["proof (prove)\nusing this:\n  i \\<le> k'\n\ngoal (1 subgoal):\n 1. enat i \\<le> enat k'", "by simp"], ["proof (state)\nthis:\n  enat i \\<le> enat k'\n\ngoal (2 subgoals):\n 1. enat i < esize (liset A w)\n 2. \\<And>ia.\n       \\<lbrakk>ia \\<le> nth_least\n                          (liset A w \\<inter>\n                           {..<Suc (nth_least (liset A w) k')})\n                          i;\n        ia \\<le> nth_least (liset A w) i\\<rbrakk>\n       \\<Longrightarrow> (ia \\<in> liset A w \\<inter>\n                                   {..<Suc (nth_least (liset A w) k')}) =\n                         (ia \\<in> liset A w)", "also"], ["proof (state)\nthis:\n  enat i \\<le> enat k'\n\ngoal (2 subgoals):\n 1. enat i < esize (liset A w)\n 2. \\<And>ia.\n       \\<lbrakk>ia \\<le> nth_least\n                          (liset A w \\<inter>\n                           {..<Suc (nth_least (liset A w) k')})\n                          i;\n        ia \\<le> nth_least (liset A w) i\\<rbrakk>\n       \\<Longrightarrow> (ia \\<in> liset A w \\<inter>\n                                   {..<Suc (nth_least (liset A w) k')}) =\n                         (ia \\<in> liset A w)", "have \"enat k' < esize (liset A w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat k' < esize (liset A w)", "using 4"], ["proof (prove)\nusing this:\n  enat k' < llength (lproject A w)\n\ngoal (1 subgoal):\n 1. enat k' < esize (liset A w)", "by simp"], ["proof (state)\nthis:\n  enat k' < esize (liset A w)\n\ngoal (2 subgoals):\n 1. enat i < esize (liset A w)\n 2. \\<And>ia.\n       \\<lbrakk>ia \\<le> nth_least\n                          (liset A w \\<inter>\n                           {..<Suc (nth_least (liset A w) k')})\n                          i;\n        ia \\<le> nth_least (liset A w) i\\<rbrakk>\n       \\<Longrightarrow> (ia \\<in> liset A w \\<inter>\n                                   {..<Suc (nth_least (liset A w) k')}) =\n                         (ia \\<in> liset A w)", "finally"], ["proof (chain)\npicking this:\n  enat i < esize (liset A w)", "show \"enat i < esize (liset A w)\""], ["proof (prove)\nusing this:\n  enat i < esize (liset A w)\n\ngoal (1 subgoal):\n 1. enat i < esize (liset A w)", "by this"], ["proof (state)\nthis:\n  enat i < esize (liset A w)\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>ia \\<le> nth_least\n                          (liset A w \\<inter>\n                           {..<Suc (nth_least (liset A w) k')})\n                          i;\n        ia \\<le> nth_least (liset A w) i\\<rbrakk>\n       \\<Longrightarrow> (ia \\<in> liset A w \\<inter>\n                                   {..<Suc (nth_least (liset A w) k')}) =\n                         (ia \\<in> liset A w)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>ia \\<le> nth_least\n                          (liset A w \\<inter>\n                           {..<Suc (nth_least (liset A w) k')})\n                          i;\n        ia \\<le> nth_least (liset A w) i\\<rbrakk>\n       \\<Longrightarrow> (ia \\<in> liset A w \\<inter>\n                                   {..<Suc (nth_least (liset A w) k')}) =\n                         (ia \\<in> liset A w)", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>ia \\<le> nth_least\n                          (liset A w \\<inter>\n                           {..<Suc (nth_least (liset A w) k')})\n                          i;\n        ia \\<le> nth_least (liset A w) i\\<rbrakk>\n       \\<Longrightarrow> (ia \\<in> liset A w \\<inter>\n                                   {..<Suc (nth_least (liset A w) k')}) =\n                         (ia \\<in> liset A w)", "assume 1: \"j \\<le> nth_least (liset A w) i\""], ["proof (state)\nthis:\n  j \\<le> nth_least (liset A w) i\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>ia \\<le> nth_least\n                          (liset A w \\<inter>\n                           {..<Suc (nth_least (liset A w) k')})\n                          i;\n        ia \\<le> nth_least (liset A w) i\\<rbrakk>\n       \\<Longrightarrow> (ia \\<in> liset A w \\<inter>\n                                   {..<Suc (nth_least (liset A w) k')}) =\n                         (ia \\<in> liset A w)", "show \"j \\<in> liset A w \\<inter> {..< Suc (nth_least (liset A w) k')} \\<longleftrightarrow> j \\<in> liset A w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (j \\<in> liset A w \\<inter> {..<Suc (nth_least (liset A w) k')}) =\n    (j \\<in> liset A w)", "using 1 7"], ["proof (prove)\nusing this:\n  j \\<le> nth_least (liset A w) i\n  nth_least (liset A w) i < Suc (nth_least (liset A w) k')\n\ngoal (1 subgoal):\n 1. (j \\<in> liset A w \\<inter> {..<Suc (nth_least (liset A w) k')}) =\n    (j \\<in> liset A w)", "by simp"], ["proof (state)\nthis:\n  (j \\<in> liset A w \\<inter> {..<Suc (nth_least (liset A w) k')}) =\n  (j \\<in> liset A w)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nth_least (liset A w \\<inter> {..<Suc (nth_least (liset A w) k')}) i =\n  nth_least (liset A w) i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>enat i\n                < llength\n                   (lproject A\n                     (ltake (enat (nth_least (lift (liset A w)) k)) w));\n        enat i < llength (ltake (enat k) (lproject A w))\\<rbrakk>\n       \\<Longrightarrow> lproject A\n                          (ltake (enat (nth_least (lift (liset A w)) k))\n                            w) ?!\n                         i =\n                         ltake (enat k) (lproject A w) ?! i", "have \"lproject A (ltake (enat (nth_least (lift (liset A w)) k)) w) ?! i =\n        ltake (enat (Suc (nth_least (liset A w) k'))) w ?!\n        nth_least (liset A w \\<inter> {..< Suc (nth_least (liset A w) k')}) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lproject A (ltake (enat (nth_least (lift (liset A w)) k)) w) ?! i =\n    ltake (enat (Suc (nth_least (liset A w) k'))) w ?!\n    nth_least (liset A w \\<inter> {..<Suc (nth_least (liset A w) k')}) i", "using 1 6"], ["proof (prove)\nusing this:\n  enat i\n  < llength (lproject A (ltake (enat (nth_least (lift (liset A w)) k)) w))\n  nth_least (lift (liset A w)) k = Suc (nth_least (liset A w) k')\n\ngoal (1 subgoal):\n 1. lproject A (ltake (enat (nth_least (lift (liset A w)) k)) w) ?! i =\n    ltake (enat (Suc (nth_least (liset A w) k'))) w ?!\n    nth_least (liset A w \\<inter> {..<Suc (nth_least (liset A w) k')}) i", "by simp"], ["proof (state)\nthis:\n  lproject A (ltake (enat (nth_least (lift (liset A w)) k)) w) ?! i =\n  ltake (enat (Suc (nth_least (liset A w) k'))) w ?!\n  nth_least (liset A w \\<inter> {..<Suc (nth_least (liset A w) k')}) i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>enat i\n                < llength\n                   (lproject A\n                     (ltake (enat (nth_least (lift (liset A w)) k)) w));\n        enat i < llength (ltake (enat k) (lproject A w))\\<rbrakk>\n       \\<Longrightarrow> lproject A\n                          (ltake (enat (nth_least (lift (liset A w)) k))\n                            w) ?!\n                         i =\n                         ltake (enat k) (lproject A w) ?! i", "also"], ["proof (state)\nthis:\n  lproject A (ltake (enat (nth_least (lift (liset A w)) k)) w) ?! i =\n  ltake (enat (Suc (nth_least (liset A w) k'))) w ?!\n  nth_least (liset A w \\<inter> {..<Suc (nth_least (liset A w) k')}) i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>enat i\n                < llength\n                   (lproject A\n                     (ltake (enat (nth_least (lift (liset A w)) k)) w));\n        enat i < llength (ltake (enat k) (lproject A w))\\<rbrakk>\n       \\<Longrightarrow> lproject A\n                          (ltake (enat (nth_least (lift (liset A w)) k))\n                            w) ?!\n                         i =\n                         ltake (enat k) (lproject A w) ?! i", "have \"\\<dots> = ltake (enat (Suc (nth_least (liset A w) k'))) w ?! nth_least (liset A w) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake (enat (Suc (nth_least (liset A w) k'))) w ?!\n    nth_least (liset A w \\<inter> {..<Suc (nth_least (liset A w) k')}) i =\n    ltake (enat (Suc (nth_least (liset A w) k'))) w ?!\n    nth_least (liset A w) i", "using 8"], ["proof (prove)\nusing this:\n  nth_least (liset A w \\<inter> {..<Suc (nth_least (liset A w) k')}) i =\n  nth_least (liset A w) i\n\ngoal (1 subgoal):\n 1. ltake (enat (Suc (nth_least (liset A w) k'))) w ?!\n    nth_least (liset A w \\<inter> {..<Suc (nth_least (liset A w) k')}) i =\n    ltake (enat (Suc (nth_least (liset A w) k'))) w ?!\n    nth_least (liset A w) i", "by simp"], ["proof (state)\nthis:\n  ltake (enat (Suc (nth_least (liset A w) k'))) w ?!\n  nth_least (liset A w \\<inter> {..<Suc (nth_least (liset A w) k')}) i =\n  ltake (enat (Suc (nth_least (liset A w) k'))) w ?! nth_least (liset A w) i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>enat i\n                < llength\n                   (lproject A\n                     (ltake (enat (nth_least (lift (liset A w)) k)) w));\n        enat i < llength (ltake (enat k) (lproject A w))\\<rbrakk>\n       \\<Longrightarrow> lproject A\n                          (ltake (enat (nth_least (lift (liset A w)) k))\n                            w) ?!\n                         i =\n                         ltake (enat k) (lproject A w) ?! i", "also"], ["proof (state)\nthis:\n  ltake (enat (Suc (nth_least (liset A w) k'))) w ?!\n  nth_least (liset A w \\<inter> {..<Suc (nth_least (liset A w) k')}) i =\n  ltake (enat (Suc (nth_least (liset A w) k'))) w ?! nth_least (liset A w) i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>enat i\n                < llength\n                   (lproject A\n                     (ltake (enat (nth_least (lift (liset A w)) k)) w));\n        enat i < llength (ltake (enat k) (lproject A w))\\<rbrakk>\n       \\<Longrightarrow> lproject A\n                          (ltake (enat (nth_least (lift (liset A w)) k))\n                            w) ?!\n                         i =\n                         ltake (enat k) (lproject A w) ?! i", "have \"\\<dots> = w ?! nth_least (liset A w) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake (enat (Suc (nth_least (liset A w) k'))) w ?!\n    nth_least (liset A w) i =\n    w ?! nth_least (liset A w) i", "using 7"], ["proof (prove)\nusing this:\n  nth_least (liset A w) i < Suc (nth_least (liset A w) k')\n\ngoal (1 subgoal):\n 1. ltake (enat (Suc (nth_least (liset A w) k'))) w ?!\n    nth_least (liset A w) i =\n    w ?! nth_least (liset A w) i", "by simp"], ["proof (state)\nthis:\n  ltake (enat (Suc (nth_least (liset A w) k'))) w ?!\n  nth_least (liset A w) i =\n  w ?! nth_least (liset A w) i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>enat i\n                < llength\n                   (lproject A\n                     (ltake (enat (nth_least (lift (liset A w)) k)) w));\n        enat i < llength (ltake (enat k) (lproject A w))\\<rbrakk>\n       \\<Longrightarrow> lproject A\n                          (ltake (enat (nth_least (lift (liset A w)) k))\n                            w) ?!\n                         i =\n                         ltake (enat k) (lproject A w) ?! i", "also"], ["proof (state)\nthis:\n  ltake (enat (Suc (nth_least (liset A w) k'))) w ?!\n  nth_least (liset A w) i =\n  w ?! nth_least (liset A w) i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>enat i\n                < llength\n                   (lproject A\n                     (ltake (enat (nth_least (lift (liset A w)) k)) w));\n        enat i < llength (ltake (enat k) (lproject A w))\\<rbrakk>\n       \\<Longrightarrow> lproject A\n                          (ltake (enat (nth_least (lift (liset A w)) k))\n                            w) ?!\n                         i =\n                         ltake (enat k) (lproject A w) ?! i", "have \"\\<dots> = lproject A w ?! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w ?! nth_least (liset A w) i = lproject A w ?! i", "using 2"], ["proof (prove)\nusing this:\n  enat i < llength (ltake (enat k) (lproject A w))\n\ngoal (1 subgoal):\n 1. w ?! nth_least (liset A w) i = lproject A w ?! i", "by simp"], ["proof (state)\nthis:\n  w ?! nth_least (liset A w) i = lproject A w ?! i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>enat i\n                < llength\n                   (lproject A\n                     (ltake (enat (nth_least (lift (liset A w)) k)) w));\n        enat i < llength (ltake (enat k) (lproject A w))\\<rbrakk>\n       \\<Longrightarrow> lproject A\n                          (ltake (enat (nth_least (lift (liset A w)) k))\n                            w) ?!\n                         i =\n                         ltake (enat k) (lproject A w) ?! i", "also"], ["proof (state)\nthis:\n  w ?! nth_least (liset A w) i = lproject A w ?! i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>enat i\n                < llength\n                   (lproject A\n                     (ltake (enat (nth_least (lift (liset A w)) k)) w));\n        enat i < llength (ltake (enat k) (lproject A w))\\<rbrakk>\n       \\<Longrightarrow> lproject A\n                          (ltake (enat (nth_least (lift (liset A w)) k))\n                            w) ?!\n                         i =\n                         ltake (enat k) (lproject A w) ?! i", "have \"\\<dots> = ltake (enat k) (lproject A w) ?! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lproject A w ?! i = ltake (enat k) (lproject A w) ?! i", "using 2"], ["proof (prove)\nusing this:\n  enat i < llength (ltake (enat k) (lproject A w))\n\ngoal (1 subgoal):\n 1. lproject A w ?! i = ltake (enat k) (lproject A w) ?! i", "by simp"], ["proof (state)\nthis:\n  lproject A w ?! i = ltake (enat k) (lproject A w) ?! i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>enat i\n                < llength\n                   (lproject A\n                     (ltake (enat (nth_least (lift (liset A w)) k)) w));\n        enat i < llength (ltake (enat k) (lproject A w))\\<rbrakk>\n       \\<Longrightarrow> lproject A\n                          (ltake (enat (nth_least (lift (liset A w)) k))\n                            w) ?!\n                         i =\n                         ltake (enat k) (lproject A w) ?! i", "finally"], ["proof (chain)\npicking this:\n  lproject A (ltake (enat (nth_least (lift (liset A w)) k)) w) ?! i =\n  ltake (enat k) (lproject A w) ?! i", "show \"lproject A (ltake (enat (nth_least (lift (liset A w)) k)) w) ?! i =\n        ltake (enat k) (lproject A w) ?! i\""], ["proof (prove)\nusing this:\n  lproject A (ltake (enat (nth_least (lift (liset A w)) k)) w) ?! i =\n  ltake (enat k) (lproject A w) ?! i\n\ngoal (1 subgoal):\n 1. lproject A (ltake (enat (nth_least (lift (liset A w)) k)) w) ?! i =\n    ltake (enat k) (lproject A w) ?! i", "by this"], ["proof (state)\nthis:\n  lproject A (ltake (enat (nth_least (lift (liset A w)) k)) w) ?! i =\n  ltake (enat k) (lproject A w) ?! i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma llength_less_llength_lselect_less:\n      \"enat i < esize s \\<and> enat (nth_least s i) < llength w \\<longleftrightarrow> enat i < llength (lselect s w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (enat i < esize s \\<and> enat (nth_least s i) < llength w) =\n    (enat i < llength (lselect s w))", "using nth_least_less_esize_less"], ["proof (prove)\nusing this:\n  (enat ?n < esize ?A \\<and> enat (nth_least ?A ?n) < ?k) =\n  (enat ?n < esize {i \\<in> ?A. enat i < ?k})\n\ngoal (1 subgoal):\n 1. (enat i < esize s \\<and> enat (nth_least s i) < llength w) =\n    (enat i < llength (lselect s w))", "unfolding lselect_llength"], ["proof (prove)\nusing this:\n  (enat ?n < esize ?A \\<and> enat (nth_least ?A ?n) < ?k) =\n  (enat ?n < esize {i \\<in> ?A. enat i < ?k})\n\ngoal (1 subgoal):\n 1. (enat i < esize s \\<and> enat (nth_least s i) < llength w) =\n    (enat i < esize {i \\<in> s. enat i < llength w})", "by this"], ["", "lemma lselect_lselect'':\n      assumes \"\\<And> i. i \\<in> s \\<Longrightarrow> enat i < llength w\"\n      assumes \"\\<And> i. i \\<in> t \\<Longrightarrow> enat i < llength (lselect s w)\"\n      shows \"lselect t (lselect s w) = lselect (nth_least s ` t) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect t (lselect s w) = lselect (nth_least s ` t) w", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. llength (lselect t (lselect s w)) =\n    llength (lselect (nth_least s ` t) w)\n 2. \\<And>i.\n       \\<lbrakk>enat i < llength (lselect t (lselect s w));\n        enat i < llength (lselect (nth_least s ` t) w)\\<rbrakk>\n       \\<Longrightarrow> lselect t (lselect s w) ?! i =\n                         lselect (nth_least s ` t) w ?! i", "note lselect_llength[simp]"], ["proof (state)\nthis:\n  llength (lselect ?s ?w) = esize {i \\<in> ?s. enat i < llength ?w}\n\ngoal (2 subgoals):\n 1. llength (lselect t (lselect s w)) =\n    llength (lselect (nth_least s ` t) w)\n 2. \\<And>i.\n       \\<lbrakk>enat i < llength (lselect t (lselect s w));\n        enat i < llength (lselect (nth_least s ` t) w)\\<rbrakk>\n       \\<Longrightarrow> lselect t (lselect s w) ?! i =\n                         lselect (nth_least s ` t) w ?! i", "have 1: \"\\<And> i. i \\<in> nth_least s ` t \\<Longrightarrow> enat i < llength w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> nth_least s ` t \\<Longrightarrow> enat i < llength w", "using assms"], ["proof (prove)\nusing this:\n  ?i \\<in> s \\<Longrightarrow> enat ?i < llength w\n  ?i \\<in> t \\<Longrightarrow> enat ?i < llength (lselect s w)\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> nth_least s ` t \\<Longrightarrow> enat i < llength w", "by auto"], ["proof (state)\nthis:\n  ?i \\<in> nth_least s ` t \\<Longrightarrow> enat ?i < llength w\n\ngoal (2 subgoals):\n 1. llength (lselect t (lselect s w)) =\n    llength (lselect (nth_least s ` t) w)\n 2. \\<And>i.\n       \\<lbrakk>enat i < llength (lselect t (lselect s w));\n        enat i < llength (lselect (nth_least s ` t) w)\\<rbrakk>\n       \\<Longrightarrow> lselect t (lselect s w) ?! i =\n                         lselect (nth_least s ` t) w ?! i", "have 2: \"t \\<subseteq> {i. enat i < esize s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<subseteq> {i. enat i < esize s}", "using assms(2) lselect_llength_le less_le_trans"], ["proof (prove)\nusing this:\n  ?i \\<in> t \\<Longrightarrow> enat ?i < llength (lselect s w)\n  llength (lselect ?s ?w) \\<le> esize ?s\n  \\<lbrakk>?x < ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n\ngoal (1 subgoal):\n 1. t \\<subseteq> {i. enat i < esize s}", "by blast"], ["proof (state)\nthis:\n  t \\<subseteq> {i. enat i < esize s}\n\ngoal (2 subgoals):\n 1. llength (lselect t (lselect s w)) =\n    llength (lselect (nth_least s ` t) w)\n 2. \\<And>i.\n       \\<lbrakk>enat i < llength (lselect t (lselect s w));\n        enat i < llength (lselect (nth_least s ` t) w)\\<rbrakk>\n       \\<Longrightarrow> lselect t (lselect s w) ?! i =\n                         lselect (nth_least s ` t) w ?! i", "have 3: \"inj_on (nth_least s) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (nth_least s) t", "using subset_inj_on nth_least.inj_on 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>inj_on ?f ?B; ?A \\<subseteq> ?B\\<rbrakk>\n  \\<Longrightarrow> inj_on ?f ?A\n  inj_on (nth_least ?A) {i. enat i < esize ?A}\n  t \\<subseteq> {i. enat i < esize s}\n\ngoal (1 subgoal):\n 1. inj_on (nth_least s) t", "by this"], ["proof (state)\nthis:\n  inj_on (nth_least s) t\n\ngoal (2 subgoals):\n 1. llength (lselect t (lselect s w)) =\n    llength (lselect (nth_least s ` t) w)\n 2. \\<And>i.\n       \\<lbrakk>enat i < llength (lselect t (lselect s w));\n        enat i < llength (lselect (nth_least s ` t) w)\\<rbrakk>\n       \\<Longrightarrow> lselect t (lselect s w) ?! i =\n                         lselect (nth_least s ` t) w ?! i", "have \"llength (lselect t (lselect s w)) = esize t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (lselect t (lselect s w)) = esize t", "using assms(2)"], ["proof (prove)\nusing this:\n  ?i \\<in> t \\<Longrightarrow> enat ?i < llength (lselect s w)\n\ngoal (1 subgoal):\n 1. llength (lselect t (lselect s w)) = esize t", "by simp"], ["proof (state)\nthis:\n  llength (lselect t (lselect s w)) = esize t\n\ngoal (2 subgoals):\n 1. llength (lselect t (lselect s w)) =\n    llength (lselect (nth_least s ` t) w)\n 2. \\<And>i.\n       \\<lbrakk>enat i < llength (lselect t (lselect s w));\n        enat i < llength (lselect (nth_least s ` t) w)\\<rbrakk>\n       \\<Longrightarrow> lselect t (lselect s w) ?! i =\n                         lselect (nth_least s ` t) w ?! i", "also"], ["proof (state)\nthis:\n  llength (lselect t (lselect s w)) = esize t\n\ngoal (2 subgoals):\n 1. llength (lselect t (lselect s w)) =\n    llength (lselect (nth_least s ` t) w)\n 2. \\<And>i.\n       \\<lbrakk>enat i < llength (lselect t (lselect s w));\n        enat i < llength (lselect (nth_least s ` t) w)\\<rbrakk>\n       \\<Longrightarrow> lselect t (lselect s w) ?! i =\n                         lselect (nth_least s ` t) w ?! i", "have \"\\<dots> = esize (nth_least s ` t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. esize t = esize (nth_least s ` t)", "using 3"], ["proof (prove)\nusing this:\n  inj_on (nth_least s) t\n\ngoal (1 subgoal):\n 1. esize t = esize (nth_least s ` t)", "by auto"], ["proof (state)\nthis:\n  esize t = esize (nth_least s ` t)\n\ngoal (2 subgoals):\n 1. llength (lselect t (lselect s w)) =\n    llength (lselect (nth_least s ` t) w)\n 2. \\<And>i.\n       \\<lbrakk>enat i < llength (lselect t (lselect s w));\n        enat i < llength (lselect (nth_least s ` t) w)\\<rbrakk>\n       \\<Longrightarrow> lselect t (lselect s w) ?! i =\n                         lselect (nth_least s ` t) w ?! i", "also"], ["proof (state)\nthis:\n  esize t = esize (nth_least s ` t)\n\ngoal (2 subgoals):\n 1. llength (lselect t (lselect s w)) =\n    llength (lselect (nth_least s ` t) w)\n 2. \\<And>i.\n       \\<lbrakk>enat i < llength (lselect t (lselect s w));\n        enat i < llength (lselect (nth_least s ` t) w)\\<rbrakk>\n       \\<Longrightarrow> lselect t (lselect s w) ?! i =\n                         lselect (nth_least s ` t) w ?! i", "have \"\\<dots> = llength (lselect (nth_least s ` t) w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. esize (nth_least s ` t) = llength (lselect (nth_least s ` t) w)", "using 1"], ["proof (prove)\nusing this:\n  ?i \\<in> nth_least s ` t \\<Longrightarrow> enat ?i < llength w\n\ngoal (1 subgoal):\n 1. esize (nth_least s ` t) = llength (lselect (nth_least s ` t) w)", "by simp"], ["proof (state)\nthis:\n  esize (nth_least s ` t) = llength (lselect (nth_least s ` t) w)\n\ngoal (2 subgoals):\n 1. llength (lselect t (lselect s w)) =\n    llength (lselect (nth_least s ` t) w)\n 2. \\<And>i.\n       \\<lbrakk>enat i < llength (lselect t (lselect s w));\n        enat i < llength (lselect (nth_least s ` t) w)\\<rbrakk>\n       \\<Longrightarrow> lselect t (lselect s w) ?! i =\n                         lselect (nth_least s ` t) w ?! i", "finally"], ["proof (chain)\npicking this:\n  llength (lselect t (lselect s w)) = llength (lselect (nth_least s ` t) w)", "show \"llength (lselect t (lselect s w)) = llength (lselect (nth_least s ` t) w)\""], ["proof (prove)\nusing this:\n  llength (lselect t (lselect s w)) = llength (lselect (nth_least s ` t) w)\n\ngoal (1 subgoal):\n 1. llength (lselect t (lselect s w)) =\n    llength (lselect (nth_least s ` t) w)", "by this"], ["proof (state)\nthis:\n  llength (lselect t (lselect s w)) = llength (lselect (nth_least s ` t) w)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>enat i < llength (lselect t (lselect s w));\n        enat i < llength (lselect (nth_least s ` t) w)\\<rbrakk>\n       \\<Longrightarrow> lselect t (lselect s w) ?! i =\n                         lselect (nth_least s ` t) w ?! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>enat i < llength (lselect t (lselect s w));\n        enat i < llength (lselect (nth_least s ` t) w)\\<rbrakk>\n       \\<Longrightarrow> lselect t (lselect s w) ?! i =\n                         lselect (nth_least s ` t) w ?! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>enat i < llength (lselect t (lselect s w));\n        enat i < llength (lselect (nth_least s ` t) w)\\<rbrakk>\n       \\<Longrightarrow> lselect t (lselect s w) ?! i =\n                         lselect (nth_least s ` t) w ?! i", "assume 1: \"enat i < llength (lselect t (lselect s w))\""], ["proof (state)\nthis:\n  enat i < llength (lselect t (lselect s w))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>enat i < llength (lselect t (lselect s w));\n        enat i < llength (lselect (nth_least s ` t) w)\\<rbrakk>\n       \\<Longrightarrow> lselect t (lselect s w) ?! i =\n                         lselect (nth_least s ` t) w ?! i", "assume 2: \"enat i < llength (lselect (nth_least s ` t) w)\""], ["proof (state)\nthis:\n  enat i < llength (lselect (nth_least s ` t) w)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>enat i < llength (lselect t (lselect s w));\n        enat i < llength (lselect (nth_least s ` t) w)\\<rbrakk>\n       \\<Longrightarrow> lselect t (lselect s w) ?! i =\n                         lselect (nth_least s ` t) w ?! i", "have 3: \"enat i < esize t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat i < esize t", "using less_le_trans 1 lselect_llength_le"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x < ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n  enat i < llength (lselect t (lselect s w))\n  llength (lselect ?s ?w) \\<le> esize ?s\n\ngoal (1 subgoal):\n 1. enat i < esize t", "by this"], ["proof (state)\nthis:\n  enat i < esize t\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>enat i < llength (lselect t (lselect s w));\n        enat i < llength (lselect (nth_least s ` t) w)\\<rbrakk>\n       \\<Longrightarrow> lselect t (lselect s w) ?! i =\n                         lselect (nth_least s ` t) w ?! i", "have 4: \"\\<And> i. i \\<in> t \\<Longrightarrow> enat i < esize s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> t \\<Longrightarrow> enat i < esize s", "using assms(2) lselect_llength_le less_le_trans"], ["proof (prove)\nusing this:\n  ?i \\<in> t \\<Longrightarrow> enat ?i < llength (lselect s w)\n  llength (lselect ?s ?w) \\<le> esize ?s\n  \\<lbrakk>?x < ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> t \\<Longrightarrow> enat i < esize s", "by blast"], ["proof (state)\nthis:\n  ?i \\<in> t \\<Longrightarrow> enat ?i < esize s\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>enat i < llength (lselect t (lselect s w));\n        enat i < llength (lselect (nth_least s ` t) w)\\<rbrakk>\n       \\<Longrightarrow> lselect t (lselect s w) ?! i =\n                         lselect (nth_least s ` t) w ?! i", "have \"lselect t (lselect s w) ?! i = lselect s w ?! nth_least t i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect t (lselect s w) ?! i = lselect s w ?! nth_least t i", "using 1"], ["proof (prove)\nusing this:\n  enat i < llength (lselect t (lselect s w))\n\ngoal (1 subgoal):\n 1. lselect t (lselect s w) ?! i = lselect s w ?! nth_least t i", "by simp"], ["proof (state)\nthis:\n  lselect t (lselect s w) ?! i = lselect s w ?! nth_least t i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>enat i < llength (lselect t (lselect s w));\n        enat i < llength (lselect (nth_least s ` t) w)\\<rbrakk>\n       \\<Longrightarrow> lselect t (lselect s w) ?! i =\n                         lselect (nth_least s ` t) w ?! i", "also"], ["proof (state)\nthis:\n  lselect t (lselect s w) ?! i = lselect s w ?! nth_least t i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>enat i < llength (lselect t (lselect s w));\n        enat i < llength (lselect (nth_least s ` t) w)\\<rbrakk>\n       \\<Longrightarrow> lselect t (lselect s w) ?! i =\n                         lselect (nth_least s ` t) w ?! i", "have \"\\<dots> = w ?! nth_least s (nth_least t i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect s w ?! nth_least t i = w ?! nth_least s (nth_least t i)", "using assms(2) 3"], ["proof (prove)\nusing this:\n  ?i \\<in> t \\<Longrightarrow> enat ?i < llength (lselect s w)\n  enat i < esize t\n\ngoal (1 subgoal):\n 1. lselect s w ?! nth_least t i = w ?! nth_least s (nth_least t i)", "by simp"], ["proof (state)\nthis:\n  lselect s w ?! nth_least t i = w ?! nth_least s (nth_least t i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>enat i < llength (lselect t (lselect s w));\n        enat i < llength (lselect (nth_least s ` t) w)\\<rbrakk>\n       \\<Longrightarrow> lselect t (lselect s w) ?! i =\n                         lselect (nth_least s ` t) w ?! i", "also"], ["proof (state)\nthis:\n  lselect s w ?! nth_least t i = w ?! nth_least s (nth_least t i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>enat i < llength (lselect t (lselect s w));\n        enat i < llength (lselect (nth_least s ` t) w)\\<rbrakk>\n       \\<Longrightarrow> lselect t (lselect s w) ?! i =\n                         lselect (nth_least s ` t) w ?! i", "have \"\\<dots> = w ?! nth_least (nth_least s ` t) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w ?! nth_least s (nth_least t i) = w ?! nth_least (nth_least s ` t) i", "using 3 4"], ["proof (prove)\nusing this:\n  enat i < esize t\n  ?i \\<in> t \\<Longrightarrow> enat ?i < esize s\n\ngoal (1 subgoal):\n 1. w ?! nth_least s (nth_least t i) = w ?! nth_least (nth_least s ` t) i", "by simp"], ["proof (state)\nthis:\n  w ?! nth_least s (nth_least t i) = w ?! nth_least (nth_least s ` t) i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>enat i < llength (lselect t (lselect s w));\n        enat i < llength (lselect (nth_least s ` t) w)\\<rbrakk>\n       \\<Longrightarrow> lselect t (lselect s w) ?! i =\n                         lselect (nth_least s ` t) w ?! i", "also"], ["proof (state)\nthis:\n  w ?! nth_least s (nth_least t i) = w ?! nth_least (nth_least s ` t) i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>enat i < llength (lselect t (lselect s w));\n        enat i < llength (lselect (nth_least s ` t) w)\\<rbrakk>\n       \\<Longrightarrow> lselect t (lselect s w) ?! i =\n                         lselect (nth_least s ` t) w ?! i", "have \"\\<dots> = lselect (nth_least s ` t) w ?! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w ?! nth_least (nth_least s ` t) i = lselect (nth_least s ` t) w ?! i", "using 2"], ["proof (prove)\nusing this:\n  enat i < llength (lselect (nth_least s ` t) w)\n\ngoal (1 subgoal):\n 1. w ?! nth_least (nth_least s ` t) i = lselect (nth_least s ` t) w ?! i", "by simp"], ["proof (state)\nthis:\n  w ?! nth_least (nth_least s ` t) i = lselect (nth_least s ` t) w ?! i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>enat i < llength (lselect t (lselect s w));\n        enat i < llength (lselect (nth_least s ` t) w)\\<rbrakk>\n       \\<Longrightarrow> lselect t (lselect s w) ?! i =\n                         lselect (nth_least s ` t) w ?! i", "finally"], ["proof (chain)\npicking this:\n  lselect t (lselect s w) ?! i = lselect (nth_least s ` t) w ?! i", "show \"lselect t (lselect s w) ?! i = lselect (nth_least s ` t) w ?! i\""], ["proof (prove)\nusing this:\n  lselect t (lselect s w) ?! i = lselect (nth_least s ` t) w ?! i\n\ngoal (1 subgoal):\n 1. lselect t (lselect s w) ?! i = lselect (nth_least s ` t) w ?! i", "by this"], ["proof (state)\nthis:\n  lselect t (lselect s w) ?! i = lselect (nth_least s ` t) w ?! i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lselect_lselect'[simp]:\n      assumes \"\\<And> i. i \\<in> t \\<Longrightarrow> enat i < esize s\"\n      shows \"lselect t (lselect s w) = lselect (nth_least s ` t) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect t (lselect s w) = lselect (nth_least s ` t) w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lselect t (lselect s w) = lselect (nth_least s ` t) w", "have 1: \"nth_least {i \\<in> s. enat i < llength w} ` {i \\<in> t. enat i < llength (lselect s w)} =\n        {i \\<in> nth_least s ` t. enat i < llength w}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nth_least {i \\<in> s. enat i < llength w} `\n    {i \\<in> t. enat i < llength (lselect s w)} =\n    {i \\<in> nth_least s ` t. enat i < llength w}", "unfolding Compr_image_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. nth_least {i \\<in> s. enat i < llength w} `\n    {i \\<in> t. enat i < llength (lselect s w)} =\n    nth_least s ` {i \\<in> t. enat (nth_least s i) < llength w}", "proof (rule image_cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. {i \\<in> t. enat i < llength (lselect s w)} =\n    {i \\<in> t. enat (nth_least s i) < llength w}\n 2. \\<And>x.\n       x \\<in> {i \\<in> t.\n                enat (nth_least s i) < llength w} \\<Longrightarrow>\n       nth_least {i \\<in> s. enat i < llength w} x = nth_least s x", "show \"{i \\<in> t. enat i < llength (lselect s w)} = {i \\<in> t. enat (nth_least s i) < llength w}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i \\<in> t. enat i < llength (lselect s w)} =\n    {i \\<in> t. enat (nth_least s i) < llength w}", "using llength_less_llength_lselect_less assms"], ["proof (prove)\nusing this:\n  (enat ?i < esize ?s \\<and> enat (nth_least ?s ?i) < llength ?w) =\n  (enat ?i < llength (lselect ?s ?w))\n  ?i \\<in> t \\<Longrightarrow> enat ?i < esize s\n\ngoal (1 subgoal):\n 1. {i \\<in> t. enat i < llength (lselect s w)} =\n    {i \\<in> t. enat (nth_least s i) < llength w}", "by blast"], ["proof (state)\nthis:\n  {i \\<in> t. enat i < llength (lselect s w)} =\n  {i \\<in> t. enat (nth_least s i) < llength w}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {i \\<in> t.\n                enat (nth_least s i) < llength w} \\<Longrightarrow>\n       nth_least {i \\<in> s. enat i < llength w} x = nth_least s x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {i \\<in> t.\n                enat (nth_least s i) < llength w} \\<Longrightarrow>\n       nth_least {i \\<in> s. enat i < llength w} x = nth_least s x", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {i \\<in> t.\n                enat (nth_least s i) < llength w} \\<Longrightarrow>\n       nth_least {i \\<in> s. enat i < llength w} x = nth_least s x", "assume 1: \"i \\<in> {i \\<in> t. enat (nth_least s i) < llength w}\""], ["proof (state)\nthis:\n  i \\<in> {i \\<in> t. enat (nth_least s i) < llength w}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {i \\<in> t.\n                enat (nth_least s i) < llength w} \\<Longrightarrow>\n       nth_least {i \\<in> s. enat i < llength w} x = nth_least s x", "have 2: \"enat i < esize {i \\<in> s. enat i < llength w}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat i < esize {i \\<in> s. enat i < llength w}", "using nth_least_less_esize_less assms 1"], ["proof (prove)\nusing this:\n  (enat ?n < esize ?A \\<and> enat (nth_least ?A ?n) < ?k) =\n  (enat ?n < esize {i \\<in> ?A. enat i < ?k})\n  ?i \\<in> t \\<Longrightarrow> enat ?i < esize s\n  i \\<in> {i \\<in> t. enat (nth_least s i) < llength w}\n\ngoal (1 subgoal):\n 1. enat i < esize {i \\<in> s. enat i < llength w}", "by blast"], ["proof (state)\nthis:\n  enat i < esize {i \\<in> s. enat i < llength w}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {i \\<in> t.\n                enat (nth_least s i) < llength w} \\<Longrightarrow>\n       nth_least {i \\<in> s. enat i < llength w} x = nth_least s x", "show \"nth_least {i \\<in> s. enat i < llength w} i = nth_least s i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nth_least {i \\<in> s. enat i < llength w} i = nth_least s i", "using 2"], ["proof (prove)\nusing this:\n  enat i < esize {i \\<in> s. enat i < llength w}\n\ngoal (1 subgoal):\n 1. nth_least {i \\<in> s. enat i < llength w} i = nth_least s i", "by simp"], ["proof (state)\nthis:\n  nth_least {i \\<in> s. enat i < llength w} i = nth_least s i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nth_least {i \\<in> s. enat i < llength w} `\n  {i \\<in> t. enat i < llength (lselect s w)} =\n  {i \\<in> nth_least s ` t. enat i < llength w}\n\ngoal (1 subgoal):\n 1. lselect t (lselect s w) = lselect (nth_least s ` t) w", "have \"lselect t (lselect s w) =\n        lselect {i \\<in> t. enat i < llength (lselect s w)} (lselect {i \\<in> s. enat i < llength w} w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect t (lselect s w) =\n    lselect {i \\<in> t. enat i < llength (lselect s w)}\n     (lselect {i \\<in> s. enat i < llength w} w)", "by simp"], ["proof (state)\nthis:\n  lselect t (lselect s w) =\n  lselect {i \\<in> t. enat i < llength (lselect s w)}\n   (lselect {i \\<in> s. enat i < llength w} w)\n\ngoal (1 subgoal):\n 1. lselect t (lselect s w) = lselect (nth_least s ` t) w", "also"], ["proof (state)\nthis:\n  lselect t (lselect s w) =\n  lselect {i \\<in> t. enat i < llength (lselect s w)}\n   (lselect {i \\<in> s. enat i < llength w} w)\n\ngoal (1 subgoal):\n 1. lselect t (lselect s w) = lselect (nth_least s ` t) w", "have \"\\<dots> = lselect (nth_least {i \\<in> s. enat i < llength w} `\n        {i \\<in> t. enat i < llength (lselect s w)}) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect {i \\<in> t. enat i < llength (lselect s w)}\n     (lselect {i \\<in> s. enat i < llength w} w) =\n    lselect\n     (nth_least {i \\<in> s. enat i < llength w} `\n      {i \\<in> t. enat i < llength (lselect s w)})\n     w", "by (rule lselect_lselect'', auto simp: lselect_llength)"], ["proof (state)\nthis:\n  lselect {i \\<in> t. enat i < llength (lselect s w)}\n   (lselect {i \\<in> s. enat i < llength w} w) =\n  lselect\n   (nth_least {i \\<in> s. enat i < llength w} `\n    {i \\<in> t. enat i < llength (lselect s w)})\n   w\n\ngoal (1 subgoal):\n 1. lselect t (lselect s w) = lselect (nth_least s ` t) w", "also"], ["proof (state)\nthis:\n  lselect {i \\<in> t. enat i < llength (lselect s w)}\n   (lselect {i \\<in> s. enat i < llength w} w) =\n  lselect\n   (nth_least {i \\<in> s. enat i < llength w} `\n    {i \\<in> t. enat i < llength (lselect s w)})\n   w\n\ngoal (1 subgoal):\n 1. lselect t (lselect s w) = lselect (nth_least s ` t) w", "have \"\\<dots> = lselect {i \\<in> nth_least s ` t. enat i < llength w} w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect\n     (nth_least {i \\<in> s. enat i < llength w} `\n      {i \\<in> t. enat i < llength (lselect s w)})\n     w =\n    lselect {i \\<in> nth_least s ` t. enat i < llength w} w", "unfolding 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect {i \\<in> nth_least s ` t. enat i < llength w} w =\n    lselect {i \\<in> nth_least s ` t. enat i < llength w} w", "by rule"], ["proof (state)\nthis:\n  lselect\n   (nth_least {i \\<in> s. enat i < llength w} `\n    {i \\<in> t. enat i < llength (lselect s w)})\n   w =\n  lselect {i \\<in> nth_least s ` t. enat i < llength w} w\n\ngoal (1 subgoal):\n 1. lselect t (lselect s w) = lselect (nth_least s ` t) w", "also"], ["proof (state)\nthis:\n  lselect\n   (nth_least {i \\<in> s. enat i < llength w} `\n    {i \\<in> t. enat i < llength (lselect s w)})\n   w =\n  lselect {i \\<in> nth_least s ` t. enat i < llength w} w\n\ngoal (1 subgoal):\n 1. lselect t (lselect s w) = lselect (nth_least s ` t) w", "have \"\\<dots> = lselect (nth_least s ` t) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect {i \\<in> nth_least s ` t. enat i < llength w} w =\n    lselect (nth_least s ` t) w", "by simp"], ["proof (state)\nthis:\n  lselect {i \\<in> nth_least s ` t. enat i < llength w} w =\n  lselect (nth_least s ` t) w\n\ngoal (1 subgoal):\n 1. lselect t (lselect s w) = lselect (nth_least s ` t) w", "finally"], ["proof (chain)\npicking this:\n  lselect t (lselect s w) = lselect (nth_least s ` t) w", "show ?thesis"], ["proof (prove)\nusing this:\n  lselect t (lselect s w) = lselect (nth_least s ` t) w\n\ngoal (1 subgoal):\n 1. lselect t (lselect s w) = lselect (nth_least s ` t) w", "by this"], ["proof (state)\nthis:\n  lselect t (lselect s w) = lselect (nth_least s ` t) w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lselect_lselect:\n      \"lselect t (lselect s w) = lselect (nth_least s ` {i \\<in> t. enat i < esize s}) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect t (lselect s w) =\n    lselect (nth_least s ` {i \\<in> t. enat i < esize s}) w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lselect t (lselect s w) =\n    lselect (nth_least s ` {i \\<in> t. enat i < esize s}) w", "have \"lselect t (lselect s w) = lselect {i \\<in> t. enat i < llength (lselect s w)} (lselect s w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect t (lselect s w) =\n    lselect {i \\<in> t. enat i < llength (lselect s w)} (lselect s w)", "by simp"], ["proof (state)\nthis:\n  lselect t (lselect s w) =\n  lselect {i \\<in> t. enat i < llength (lselect s w)} (lselect s w)\n\ngoal (1 subgoal):\n 1. lselect t (lselect s w) =\n    lselect (nth_least s ` {i \\<in> t. enat i < esize s}) w", "also"], ["proof (state)\nthis:\n  lselect t (lselect s w) =\n  lselect {i \\<in> t. enat i < llength (lselect s w)} (lselect s w)\n\ngoal (1 subgoal):\n 1. lselect t (lselect s w) =\n    lselect (nth_least s ` {i \\<in> t. enat i < esize s}) w", "have \"\\<dots> = lselect (nth_least s ` {i \\<in> t. enat i < llength (lselect s w)}) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect {i \\<in> t. enat i < llength (lselect s w)} (lselect s w) =\n    lselect (nth_least s ` {i \\<in> t. enat i < llength (lselect s w)}) w", "using lselect_llength_le less_le_trans"], ["proof (prove)\nusing this:\n  llength (lselect ?s ?w) \\<le> esize ?s\n  \\<lbrakk>?x < ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n\ngoal (1 subgoal):\n 1. lselect {i \\<in> t. enat i < llength (lselect s w)} (lselect s w) =\n    lselect (nth_least s ` {i \\<in> t. enat i < llength (lselect s w)}) w", "by (blast intro: lselect_lselect')"], ["proof (state)\nthis:\n  lselect {i \\<in> t. enat i < llength (lselect s w)} (lselect s w) =\n  lselect (nth_least s ` {i \\<in> t. enat i < llength (lselect s w)}) w\n\ngoal (1 subgoal):\n 1. lselect t (lselect s w) =\n    lselect (nth_least s ` {i \\<in> t. enat i < esize s}) w", "also"], ["proof (state)\nthis:\n  lselect {i \\<in> t. enat i < llength (lselect s w)} (lselect s w) =\n  lselect (nth_least s ` {i \\<in> t. enat i < llength (lselect s w)}) w\n\ngoal (1 subgoal):\n 1. lselect t (lselect s w) =\n    lselect (nth_least s ` {i \\<in> t. enat i < esize s}) w", "have \"\\<dots> = lselect (nth_least s ` {i \\<in> t. enat i < esize s}) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect (nth_least s ` {i \\<in> t. enat i < llength (lselect s w)}) w =\n    lselect (nth_least s ` {i \\<in> t. enat i < esize s}) w", "using llength_less_llength_lselect_less"], ["proof (prove)\nusing this:\n  (enat ?i < esize ?s \\<and> enat (nth_least ?s ?i) < llength ?w) =\n  (enat ?i < llength (lselect ?s ?w))\n\ngoal (1 subgoal):\n 1. lselect (nth_least s ` {i \\<in> t. enat i < llength (lselect s w)}) w =\n    lselect (nth_least s ` {i \\<in> t. enat i < esize s}) w", "by (auto intro!: lnths_cong)"], ["proof (state)\nthis:\n  lselect (nth_least s ` {i \\<in> t. enat i < llength (lselect s w)}) w =\n  lselect (nth_least s ` {i \\<in> t. enat i < esize s}) w\n\ngoal (1 subgoal):\n 1. lselect t (lselect s w) =\n    lselect (nth_least s ` {i \\<in> t. enat i < esize s}) w", "finally"], ["proof (chain)\npicking this:\n  lselect t (lselect s w) =\n  lselect (nth_least s ` {i \\<in> t. enat i < esize s}) w", "show ?thesis"], ["proof (prove)\nusing this:\n  lselect t (lselect s w) =\n  lselect (nth_least s ` {i \\<in> t. enat i < esize s}) w\n\ngoal (1 subgoal):\n 1. lselect t (lselect s w) =\n    lselect (nth_least s ` {i \\<in> t. enat i < esize s}) w", "by this"], ["proof (state)\nthis:\n  lselect t (lselect s w) =\n  lselect (nth_least s ` {i \\<in> t. enat i < esize s}) w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lselect_lproject':\n      assumes \"\\<And> i. i \\<in> s \\<Longrightarrow> enat i < llength w\"\n      shows \"lproject A (lselect s w) = lselect (s \\<inter> liset A w) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lproject A (lselect s w) = lselect (s \\<inter> liset A w) w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lproject A (lselect s w) = lselect (s \\<inter> liset A w) w", "have 1: \"\\<And> i. i \\<in> liset A (lselect s w) \\<Longrightarrow> enat i < esize s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> liset A (lselect s w) \\<Longrightarrow> enat i < esize s", "using less_le_trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x < ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> liset A (lselect s w) \\<Longrightarrow> enat i < esize s", "by force"], ["proof (state)\nthis:\n  ?i \\<in> liset A (lselect s w) \\<Longrightarrow> enat ?i < esize s\n\ngoal (1 subgoal):\n 1. lproject A (lselect s w) = lselect (s \\<inter> liset A w) w", "have 2: \"{i \\<in> liset A (lselect s w). enat i < esize s} = liset A (lselect s w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i \\<in> liset A (lselect s w). enat i < esize s} =\n    liset A (lselect s w)", "using 1"], ["proof (prove)\nusing this:\n  ?i \\<in> liset A (lselect s w) \\<Longrightarrow> enat ?i < esize s\n\ngoal (1 subgoal):\n 1. {i \\<in> liset A (lselect s w). enat i < esize s} =\n    liset A (lselect s w)", "by auto"], ["proof (state)\nthis:\n  {i \\<in> liset A (lselect s w). enat i < esize s} = liset A (lselect s w)\n\ngoal (1 subgoal):\n 1. lproject A (lselect s w) = lselect (s \\<inter> liset A w) w", "have 3: \"nth_least s ` liset A (lselect s w) = s \\<inter> liset A w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nth_least s ` liset A (lselect s w) = s \\<inter> liset A w", "proof safe"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> liset A (lselect s w) \\<Longrightarrow>\n       nth_least s xa \\<in> s\n 2. \\<And>x xa.\n       xa \\<in> liset A (lselect s w) \\<Longrightarrow>\n       nth_least s xa \\<in> liset A w\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> s; x \\<in> liset A w\\<rbrakk>\n       \\<Longrightarrow> x \\<in> nth_least s ` liset A (lselect s w)", "fix k"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> liset A (lselect s w) \\<Longrightarrow>\n       nth_least s xa \\<in> s\n 2. \\<And>x xa.\n       xa \\<in> liset A (lselect s w) \\<Longrightarrow>\n       nth_least s xa \\<in> liset A w\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> s; x \\<in> liset A w\\<rbrakk>\n       \\<Longrightarrow> x \\<in> nth_least s ` liset A (lselect s w)", "assume 4: \"k \\<in> liset A (lselect s w)\""], ["proof (state)\nthis:\n  k \\<in> liset A (lselect s w)\n\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> liset A (lselect s w) \\<Longrightarrow>\n       nth_least s xa \\<in> s\n 2. \\<And>x xa.\n       xa \\<in> liset A (lselect s w) \\<Longrightarrow>\n       nth_least s xa \\<in> liset A w\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> s; x \\<in> liset A w\\<rbrakk>\n       \\<Longrightarrow> x \\<in> nth_least s ` liset A (lselect s w)", "show \"nth_least s k \\<in> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nth_least s k \\<in> s", "using 1 4"], ["proof (prove)\nusing this:\n  ?i \\<in> liset A (lselect s w) \\<Longrightarrow> enat ?i < esize s\n  k \\<in> liset A (lselect s w)\n\ngoal (1 subgoal):\n 1. nth_least s k \\<in> s", "by simp"], ["proof (state)\nthis:\n  nth_least s k \\<in> s\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> liset A (lselect s w) \\<Longrightarrow>\n       nth_least s xa \\<in> liset A w\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> s; x \\<in> liset A w\\<rbrakk>\n       \\<Longrightarrow> x \\<in> nth_least s ` liset A (lselect s w)", "show \"nth_least s k \\<in> liset A w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nth_least s k \\<in> liset A w", "using llength_less_llength_lselect_less 4"], ["proof (prove)\nusing this:\n  (enat ?i < esize ?s \\<and> enat (nth_least ?s ?i) < llength ?w) =\n  (enat ?i < llength (lselect ?s ?w))\n  k \\<in> liset A (lselect s w)\n\ngoal (1 subgoal):\n 1. nth_least s k \\<in> liset A w", "unfolding liset_def"], ["proof (prove)\nusing this:\n  (enat ?i < esize ?s \\<and> enat (nth_least ?s ?i) < llength ?w) =\n  (enat ?i < llength (lselect ?s ?w))\n  k \\<in> {i. enat i < llength (lselect s w) \\<and>\n              lselect s w ?! i \\<in> A}\n\ngoal (1 subgoal):\n 1. nth_least s k \\<in> {i. enat i < llength w \\<and> w ?! i \\<in> A}", "by auto"], ["proof (state)\nthis:\n  nth_least s k \\<in> liset A w\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> s; x \\<in> liset A w\\<rbrakk>\n       \\<Longrightarrow> x \\<in> nth_least s ` liset A (lselect s w)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> s; x \\<in> liset A w\\<rbrakk>\n       \\<Longrightarrow> x \\<in> nth_least s ` liset A (lselect s w)", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> s; x \\<in> liset A w\\<rbrakk>\n       \\<Longrightarrow> x \\<in> nth_least s ` liset A (lselect s w)", "assume 1: \"k \\<in> s\" \"k \\<in> liset A w\""], ["proof (state)\nthis:\n  k \\<in> s\n  k \\<in> liset A w\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> s; x \\<in> liset A w\\<rbrakk>\n       \\<Longrightarrow> x \\<in> nth_least s ` liset A (lselect s w)", "have 2: \"nth_least s (card {i \\<in> s. i < k}) = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nth_least s (card {i \\<in> s. i < k}) = k", "using nth_least_card 1(1)"], ["proof (prove)\nusing this:\n  ?k \\<in> ?A \\<Longrightarrow>\n  nth_least ?A (card {i \\<in> ?A. i < ?k}) = ?k\n  k \\<in> s\n\ngoal (1 subgoal):\n 1. nth_least s (card {i \\<in> s. i < k}) = k", "by this"], ["proof (state)\nthis:\n  nth_least s (card {i \\<in> s. i < k}) = k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> s; x \\<in> liset A w\\<rbrakk>\n       \\<Longrightarrow> x \\<in> nth_least s ` liset A (lselect s w)", "have 3: \"enat (card {i \\<in> s. i < k}) < llength (lselect s w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat (card {i \\<in> s. i < k}) < llength (lselect s w)", "unfolding lselect_llength"], ["proof (prove)\ngoal (1 subgoal):\n 1. enat (card {i \\<in> s. i < k}) < esize {i \\<in> s. enat i < llength w}", "using assms 1(1)"], ["proof (prove)\nusing this:\n  ?i \\<in> s \\<Longrightarrow> enat ?i < llength w\n  k \\<in> s\n\ngoal (1 subgoal):\n 1. enat (card {i \\<in> s. i < k}) < esize {i \\<in> s. enat i < llength w}", "by simp"], ["proof (state)\nthis:\n  enat (card {i \\<in> s. i < k}) < llength (lselect s w)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> s; x \\<in> liset A w\\<rbrakk>\n       \\<Longrightarrow> x \\<in> nth_least s ` liset A (lselect s w)", "show \"k \\<in> nth_least s ` liset A (lselect s w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<in> nth_least s ` liset A (lselect s w)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. k = nth_least s ?x\n 2. ?x \\<in> liset A (lselect s w)", "show \"k = nth_least s (card {i \\<in> s. i < k})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k = nth_least s (card {i \\<in> s. i < k})", "using 2"], ["proof (prove)\nusing this:\n  nth_least s (card {i \\<in> s. i < k}) = k\n\ngoal (1 subgoal):\n 1. k = nth_least s (card {i \\<in> s. i < k})", "by simp"], ["proof (state)\nthis:\n  k = nth_least s (card {i \\<in> s. i < k})\n\ngoal (1 subgoal):\n 1. card {i \\<in> s. i < k} \\<in> liset A (lselect s w)", "show \"card {i \\<in> s. i < k} \\<in> liset A (lselect s w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {i \\<in> s. i < k} \\<in> liset A (lselect s w)", "using 1(2) 2 3"], ["proof (prove)\nusing this:\n  k \\<in> liset A w\n  nth_least s (card {i \\<in> s. i < k}) = k\n  enat (card {i \\<in> s. i < k}) < llength (lselect s w)\n\ngoal (1 subgoal):\n 1. card {i \\<in> s. i < k} \\<in> liset A (lselect s w)", "by fastforce"], ["proof (state)\nthis:\n  card {i \\<in> s. i < k} \\<in> liset A (lselect s w)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k \\<in> nth_least s ` liset A (lselect s w)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nth_least s ` liset A (lselect s w) = s \\<inter> liset A w\n\ngoal (1 subgoal):\n 1. lproject A (lselect s w) = lselect (s \\<inter> liset A w) w", "have \"lproject A (lselect s w) = lselect (liset A (lselect s w)) (lselect s w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lproject A (lselect s w) = lselect (liset A (lselect s w)) (lselect s w)", "unfolding lproject_to_lselect"], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect (liset A (lselect s w)) (lselect s w) =\n    lselect (liset A (lselect s w)) (lselect s w)", "by rule"], ["proof (state)\nthis:\n  lproject A (lselect s w) = lselect (liset A (lselect s w)) (lselect s w)\n\ngoal (1 subgoal):\n 1. lproject A (lselect s w) = lselect (s \\<inter> liset A w) w", "also"], ["proof (state)\nthis:\n  lproject A (lselect s w) = lselect (liset A (lselect s w)) (lselect s w)\n\ngoal (1 subgoal):\n 1. lproject A (lselect s w) = lselect (s \\<inter> liset A w) w", "have \"\\<dots> = lselect (nth_least s ` {i \\<in> liset A (lselect s w). enat i < esize s}) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect (liset A (lselect s w)) (lselect s w) =\n    lselect\n     (nth_least s ` {i \\<in> liset A (lselect s w). enat i < esize s}) w", "unfolding lselect_lselect"], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect\n     (nth_least s ` {i \\<in> liset A (lselect s w). enat i < esize s}) w =\n    lselect\n     (nth_least s ` {i \\<in> liset A (lselect s w). enat i < esize s}) w", "by rule"], ["proof (state)\nthis:\n  lselect (liset A (lselect s w)) (lselect s w) =\n  lselect (nth_least s ` {i \\<in> liset A (lselect s w). enat i < esize s})\n   w\n\ngoal (1 subgoal):\n 1. lproject A (lselect s w) = lselect (s \\<inter> liset A w) w", "also"], ["proof (state)\nthis:\n  lselect (liset A (lselect s w)) (lselect s w) =\n  lselect (nth_least s ` {i \\<in> liset A (lselect s w). enat i < esize s})\n   w\n\ngoal (1 subgoal):\n 1. lproject A (lselect s w) = lselect (s \\<inter> liset A w) w", "have \"\\<dots> = lselect (nth_least s ` liset A (lselect s w)) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect\n     (nth_least s ` {i \\<in> liset A (lselect s w). enat i < esize s}) w =\n    lselect (nth_least s ` liset A (lselect s w)) w", "unfolding 2"], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect (nth_least s ` liset A (lselect s w)) w =\n    lselect (nth_least s ` liset A (lselect s w)) w", "by rule"], ["proof (state)\nthis:\n  lselect (nth_least s ` {i \\<in> liset A (lselect s w). enat i < esize s})\n   w =\n  lselect (nth_least s ` liset A (lselect s w)) w\n\ngoal (1 subgoal):\n 1. lproject A (lselect s w) = lselect (s \\<inter> liset A w) w", "also"], ["proof (state)\nthis:\n  lselect (nth_least s ` {i \\<in> liset A (lselect s w). enat i < esize s})\n   w =\n  lselect (nth_least s ` liset A (lselect s w)) w\n\ngoal (1 subgoal):\n 1. lproject A (lselect s w) = lselect (s \\<inter> liset A w) w", "have \"\\<dots> = lselect (s \\<inter> liset A w) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect (nth_least s ` liset A (lselect s w)) w =\n    lselect (s \\<inter> liset A w) w", "unfolding 3"], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect (s \\<inter> liset A w) w = lselect (s \\<inter> liset A w) w", "by rule"], ["proof (state)\nthis:\n  lselect (nth_least s ` liset A (lselect s w)) w =\n  lselect (s \\<inter> liset A w) w\n\ngoal (1 subgoal):\n 1. lproject A (lselect s w) = lselect (s \\<inter> liset A w) w", "finally"], ["proof (chain)\npicking this:\n  lproject A (lselect s w) = lselect (s \\<inter> liset A w) w", "show ?thesis"], ["proof (prove)\nusing this:\n  lproject A (lselect s w) = lselect (s \\<inter> liset A w) w\n\ngoal (1 subgoal):\n 1. lproject A (lselect s w) = lselect (s \\<inter> liset A w) w", "by this"], ["proof (state)\nthis:\n  lproject A (lselect s w) = lselect (s \\<inter> liset A w) w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lselect_lproject[simp]: \"lproject A (lselect s w) = lselect (s \\<inter> liset A w) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lproject A (lselect s w) = lselect (s \\<inter> liset A w) w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lproject A (lselect s w) = lselect (s \\<inter> liset A w) w", "have 1: \"{i \\<in> s. enat i < llength w} \\<inter> liset A w = s \\<inter> liset A w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i \\<in> s. enat i < llength w} \\<inter> liset A w =\n    s \\<inter> liset A w", "by auto"], ["proof (state)\nthis:\n  {i \\<in> s. enat i < llength w} \\<inter> liset A w = s \\<inter> liset A w\n\ngoal (1 subgoal):\n 1. lproject A (lselect s w) = lselect (s \\<inter> liset A w) w", "have \"lproject A (lselect s w) = lproject A (lselect {i \\<in> s. enat i < llength w} w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lproject A (lselect s w) =\n    lproject A (lselect {i \\<in> s. enat i < llength w} w)", "by simp"], ["proof (state)\nthis:\n  lproject A (lselect s w) =\n  lproject A (lselect {i \\<in> s. enat i < llength w} w)\n\ngoal (1 subgoal):\n 1. lproject A (lselect s w) = lselect (s \\<inter> liset A w) w", "also"], ["proof (state)\nthis:\n  lproject A (lselect s w) =\n  lproject A (lselect {i \\<in> s. enat i < llength w} w)\n\ngoal (1 subgoal):\n 1. lproject A (lselect s w) = lselect (s \\<inter> liset A w) w", "have \"\\<dots> = lselect ({i \\<in> s. enat i < llength w} \\<inter> liset A w) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lproject A (lselect {i \\<in> s. enat i < llength w} w) =\n    lselect ({i \\<in> s. enat i < llength w} \\<inter> liset A w) w", "by (rule lselect_lproject', simp)"], ["proof (state)\nthis:\n  lproject A (lselect {i \\<in> s. enat i < llength w} w) =\n  lselect ({i \\<in> s. enat i < llength w} \\<inter> liset A w) w\n\ngoal (1 subgoal):\n 1. lproject A (lselect s w) = lselect (s \\<inter> liset A w) w", "also"], ["proof (state)\nthis:\n  lproject A (lselect {i \\<in> s. enat i < llength w} w) =\n  lselect ({i \\<in> s. enat i < llength w} \\<inter> liset A w) w\n\ngoal (1 subgoal):\n 1. lproject A (lselect s w) = lselect (s \\<inter> liset A w) w", "have \"\\<dots> = lselect (s \\<inter> liset A w) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect ({i \\<in> s. enat i < llength w} \\<inter> liset A w) w =\n    lselect (s \\<inter> liset A w) w", "unfolding 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect (s \\<inter> liset A w) w = lselect (s \\<inter> liset A w) w", "by rule"], ["proof (state)\nthis:\n  lselect ({i \\<in> s. enat i < llength w} \\<inter> liset A w) w =\n  lselect (s \\<inter> liset A w) w\n\ngoal (1 subgoal):\n 1. lproject A (lselect s w) = lselect (s \\<inter> liset A w) w", "finally"], ["proof (chain)\npicking this:\n  lproject A (lselect s w) = lselect (s \\<inter> liset A w) w", "show ?thesis"], ["proof (prove)\nusing this:\n  lproject A (lselect s w) = lselect (s \\<inter> liset A w) w\n\ngoal (1 subgoal):\n 1. lproject A (lselect s w) = lselect (s \\<inter> liset A w) w", "by this"], ["proof (state)\nthis:\n  lproject A (lselect s w) = lselect (s \\<inter> liset A w) w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lproject_lselect_subset[simp]:\n      assumes \"liset A w \\<subseteq> s\"\n      shows \"lproject A (lselect s w) = lproject A w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lproject A (lselect s w) = lproject A w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lproject A (lselect s w) = lproject A w", "have 1: \"s \\<inter> liset A w = liset A w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<inter> liset A w = liset A w", "using assms"], ["proof (prove)\nusing this:\n  liset A w \\<subseteq> s\n\ngoal (1 subgoal):\n 1. s \\<inter> liset A w = liset A w", "by auto"], ["proof (state)\nthis:\n  s \\<inter> liset A w = liset A w\n\ngoal (1 subgoal):\n 1. lproject A (lselect s w) = lproject A w", "have \"lproject A (lselect s w) = lselect (s \\<inter> liset A w) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lproject A (lselect s w) = lselect (s \\<inter> liset A w) w", "by simp"], ["proof (state)\nthis:\n  lproject A (lselect s w) = lselect (s \\<inter> liset A w) w\n\ngoal (1 subgoal):\n 1. lproject A (lselect s w) = lproject A w", "also"], ["proof (state)\nthis:\n  lproject A (lselect s w) = lselect (s \\<inter> liset A w) w\n\ngoal (1 subgoal):\n 1. lproject A (lselect s w) = lproject A w", "have \"\\<dots> = lselect (liset A w) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect (s \\<inter> liset A w) w = lselect (liset A w) w", "unfolding 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect (liset A w) w = lselect (liset A w) w", "by rule"], ["proof (state)\nthis:\n  lselect (s \\<inter> liset A w) w = lselect (liset A w) w\n\ngoal (1 subgoal):\n 1. lproject A (lselect s w) = lproject A w", "also"], ["proof (state)\nthis:\n  lselect (s \\<inter> liset A w) w = lselect (liset A w) w\n\ngoal (1 subgoal):\n 1. lproject A (lselect s w) = lproject A w", "have \"\\<dots> = lproject A w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect (liset A w) w = lproject A w", "unfolding lproject_to_lselect"], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect (liset A w) w = lselect (liset A w) w", "by rule"], ["proof (state)\nthis:\n  lselect (liset A w) w = lproject A w\n\ngoal (1 subgoal):\n 1. lproject A (lselect s w) = lproject A w", "finally"], ["proof (chain)\npicking this:\n  lproject A (lselect s w) = lproject A w", "show ?thesis"], ["proof (prove)\nusing this:\n  lproject A (lselect s w) = lproject A w\n\ngoal (1 subgoal):\n 1. lproject A (lselect s w) = lproject A w", "by this"], ["proof (state)\nthis:\n  lproject A (lselect s w) = lproject A w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lselect_prefix[intro]:\n      assumes \"u \\<le> v\"\n      shows \"lselect s u \\<le> lselect s v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect s u \\<le> lselect s v", "proof (cases \"lfinite u\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lfinite u \\<Longrightarrow> lselect s u \\<le> lselect s v\n 2. linfinite u \\<Longrightarrow> lselect s u \\<le> lselect s v", "case False"], ["proof (state)\nthis:\n  linfinite u\n\ngoal (2 subgoals):\n 1. lfinite u \\<Longrightarrow> lselect s u \\<le> lselect s v\n 2. linfinite u \\<Longrightarrow> lselect s u \\<le> lselect s v", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect s u \\<le> lselect s v", "using lprefix_infinite assms False"], ["proof (prove)\nusing this:\n  \\<lbrakk>?u \\<le> ?v; linfinite ?u\\<rbrakk> \\<Longrightarrow> ?u = ?v\n  u \\<le> v\n  linfinite u\n\ngoal (1 subgoal):\n 1. lselect s u \\<le> lselect s v", "by auto"], ["proof (state)\nthis:\n  lselect s u \\<le> lselect s v\n\ngoal (1 subgoal):\n 1. lfinite u \\<Longrightarrow> lselect s u \\<le> lselect s v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. lfinite u \\<Longrightarrow> lselect s u \\<le> lselect s v", "case True"], ["proof (state)\nthis:\n  lfinite u\n\ngoal (1 subgoal):\n 1. lfinite u \\<Longrightarrow> lselect s u \\<le> lselect s v", "obtain k where 1: \"llength u = enat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k. llength u = enat k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using True length_list_of"], ["proof (prove)\nusing this:\n  lfinite u\n  lfinite ?xs \\<Longrightarrow> enat (length (list_of ?xs)) = llength ?xs\n\ngoal (1 subgoal):\n 1. (\\<And>k. llength u = enat k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  llength u = enat k\n\ngoal (1 subgoal):\n 1. lfinite u \\<Longrightarrow> lselect s u \\<le> lselect s v", "obtain w where 2: \"v = u $ w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>w. v = u $ w \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using lprefix_conv_lappend assms"], ["proof (prove)\nusing this:\n  lprefix ?xs ?ys = (\\<exists>zs. ?ys = ?xs $ zs)\n  u \\<le> v\n\ngoal (1 subgoal):\n 1. (\\<And>w. v = u $ w \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  v = u $ w\n\ngoal (1 subgoal):\n 1. lfinite u \\<Longrightarrow> lselect s u \\<le> lselect s v", "have \"lselect s u \\<le> lselect s u $ lselect {n. n + k \\<in> s} w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect s u \\<le> lselect s u $ lselect {n. n + k \\<in> s} w", "by simp"], ["proof (state)\nthis:\n  lselect s u \\<le> lselect s u $ lselect {n. n + k \\<in> s} w\n\ngoal (1 subgoal):\n 1. lfinite u \\<Longrightarrow> lselect s u \\<le> lselect s v", "also"], ["proof (state)\nthis:\n  lselect s u \\<le> lselect s u $ lselect {n. n + k \\<in> s} w\n\ngoal (1 subgoal):\n 1. lfinite u \\<Longrightarrow> lselect s u \\<le> lselect s v", "have \"\\<dots> = lselect s (u $ w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect s u $ lselect {n. n + k \\<in> s} w = lselect s (u $ w)", "using lnths_lappend_lfinite[symmetric] 1"], ["proof (prove)\nusing this:\n  llength ?xs = enat ?k \\<Longrightarrow>\n  lselect ?A ?xs $ lselect {n. n + ?k \\<in> ?A} ?ys = lselect ?A (?xs $ ?ys)\n  llength u = enat k\n\ngoal (1 subgoal):\n 1. lselect s u $ lselect {n. n + k \\<in> s} w = lselect s (u $ w)", "by this"], ["proof (state)\nthis:\n  lselect s u $ lselect {n. n + k \\<in> s} w = lselect s (u $ w)\n\ngoal (1 subgoal):\n 1. lfinite u \\<Longrightarrow> lselect s u \\<le> lselect s v", "also"], ["proof (state)\nthis:\n  lselect s u $ lselect {n. n + k \\<in> s} w = lselect s (u $ w)\n\ngoal (1 subgoal):\n 1. lfinite u \\<Longrightarrow> lselect s u \\<le> lselect s v", "have \"\\<dots> = lselect s v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect s (u $ w) = lselect s v", "unfolding 2"], ["proof (prove)\ngoal (1 subgoal):\n 1. lselect s (u $ w) = lselect s (u $ w)", "by rule"], ["proof (state)\nthis:\n  lselect s (u $ w) = lselect s v\n\ngoal (1 subgoal):\n 1. lfinite u \\<Longrightarrow> lselect s u \\<le> lselect s v", "finally"], ["proof (chain)\npicking this:\n  lselect s u \\<le> lselect s v", "show ?thesis"], ["proof (prove)\nusing this:\n  lselect s u \\<le> lselect s v\n\ngoal (1 subgoal):\n 1. lselect s u \\<le> lselect s v", "by this"], ["proof (state)\nthis:\n  lselect s u \\<le> lselect s v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lproject_prefix[intro]:\n      assumes \"u \\<le> v\"\n      shows \"lproject A u \\<le> lproject A v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lproject A u \\<le> lproject A v", "using lprefix_lfilterI assms"], ["proof (prove)\nusing this:\n  lprefix ?xs ?ys \\<Longrightarrow>\n  lprefix (lfilter ?P ?xs) (lfilter ?P ?ys)\n  u \\<le> v\n\ngoal (1 subgoal):\n 1. lproject A u \\<le> lproject A v", "by auto"], ["", "lemma lproject_prefix_limit[intro?]:\n      assumes \"\\<And> v. v \\<le> w \\<Longrightarrow> lfinite v \\<Longrightarrow> lproject A v \\<le> x\"\n      shows \"lproject A w \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lproject A w \\<le> x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lproject A w \\<le> x", "have 1: \"ccpo.admissible lSup lprefix (\\<lambda> v. lproject A v \\<le> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible lSup lprefix (\\<lambda>v. lproject A v \\<le> x)", "by simp"], ["proof (state)\nthis:\n  ccpo.admissible lSup lprefix (\\<lambda>v. lproject A v \\<le> x)\n\ngoal (1 subgoal):\n 1. lproject A w \\<le> x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lproject A w \\<le> x", "using llist_lift_admissible 1 assms(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>ccpo.admissible lSup lprefix ?P;\n   \\<And>u.\n      \\<lbrakk>u \\<le> ?v; lfinite u\\<rbrakk>\n      \\<Longrightarrow> ?P u\\<rbrakk>\n  \\<Longrightarrow> ?P ?v\n  ccpo.admissible lSup lprefix (\\<lambda>v. lproject A v \\<le> x)\n  \\<lbrakk>?v \\<le> w; lfinite ?v\\<rbrakk>\n  \\<Longrightarrow> lproject A ?v \\<le> x\n\ngoal (1 subgoal):\n 1. lproject A w \\<le> x", "by this"], ["proof (state)\nthis:\n  lproject A w \\<le> x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lproject_prefix_limit':\n      assumes \"\\<And> k. \\<exists> v. v \\<le> w \\<and> enat k < llength v \\<and> lproject A v \\<le> x\"\n      shows \"lproject A w \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lproject A w \\<le> x", "proof (rule lproject_prefix_limit)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<le> w; lfinite v\\<rbrakk>\n       \\<Longrightarrow> lproject A v \\<le> x", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<le> w; lfinite v\\<rbrakk>\n       \\<Longrightarrow> lproject A v \\<le> x", "assume 1: \"u \\<le> w\" \"lfinite u\""], ["proof (state)\nthis:\n  u \\<le> w\n  lfinite u\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<le> w; lfinite v\\<rbrakk>\n       \\<Longrightarrow> lproject A v \\<le> x", "obtain k where 2: \"llength u = enat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k. llength u = enat k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 1(2)"], ["proof (prove)\nusing this:\n  lfinite u\n\ngoal (1 subgoal):\n 1. (\\<And>k. llength u = enat k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis length_list_of)"], ["proof (state)\nthis:\n  llength u = enat k\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<le> w; lfinite v\\<rbrakk>\n       \\<Longrightarrow> lproject A v \\<le> x", "obtain v where 3: \"v \\<le> w\" \"llength u < llength v\" \"lproject A v \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<le> w; llength u < llength v;\n         lproject A v \\<le> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding 2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<le> w; enat k < llength v;\n         lproject A v \\<le> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1)"], ["proof (prove)\nusing this:\n  \\<exists>v\\<le>w. enat ?k < llength v \\<and> lproject A v \\<le> x\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<le> w; enat k < llength v;\n         lproject A v \\<le> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v \\<le> w\n  llength u < llength v\n  lproject A v \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<le> w; lfinite v\\<rbrakk>\n       \\<Longrightarrow> lproject A v \\<le> x", "have 4: \"llength u \\<le> llength v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength u \\<le> llength v", "using 3(2)"], ["proof (prove)\nusing this:\n  llength u < llength v\n\ngoal (1 subgoal):\n 1. llength u \\<le> llength v", "by simp"], ["proof (state)\nthis:\n  llength u \\<le> llength v\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<le> w; lfinite v\\<rbrakk>\n       \\<Longrightarrow> lproject A v \\<le> x", "have 5: \"u \\<le> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<le> v", "using prefix_subsume 1(1) 3(1) 4"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<le> ?w; ?u \\<le> ?w; llength ?v \\<le> llength ?u\\<rbrakk>\n  \\<Longrightarrow> ?v \\<le> ?u\n  u \\<le> w\n  v \\<le> w\n  llength u \\<le> llength v\n\ngoal (1 subgoal):\n 1. u \\<le> v", "by this"], ["proof (state)\nthis:\n  u \\<le> v\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<le> w; lfinite v\\<rbrakk>\n       \\<Longrightarrow> lproject A v \\<le> x", "have \"lproject A u \\<le> lproject A v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lproject A u \\<le> lproject A v", "using 5"], ["proof (prove)\nusing this:\n  u \\<le> v\n\ngoal (1 subgoal):\n 1. lproject A u \\<le> lproject A v", "by rule"], ["proof (state)\nthis:\n  lproject A u \\<le> lproject A v\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<le> w; lfinite v\\<rbrakk>\n       \\<Longrightarrow> lproject A v \\<le> x", "also"], ["proof (state)\nthis:\n  lproject A u \\<le> lproject A v\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<le> w; lfinite v\\<rbrakk>\n       \\<Longrightarrow> lproject A v \\<le> x", "have \"\\<dots> \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lproject A v \\<le> x", "using 3(3)"], ["proof (prove)\nusing this:\n  lproject A v \\<le> x\n\ngoal (1 subgoal):\n 1. lproject A v \\<le> x", "by this"], ["proof (state)\nthis:\n  lproject A v \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<le> w; lfinite v\\<rbrakk>\n       \\<Longrightarrow> lproject A v \\<le> x", "finally"], ["proof (chain)\npicking this:\n  lproject A u \\<le> x", "show \"lproject A u \\<le> x\""], ["proof (prove)\nusing this:\n  lproject A u \\<le> x\n\ngoal (1 subgoal):\n 1. lproject A u \\<le> x", "by this"], ["proof (state)\nthis:\n  lproject A u \\<le> x\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}