{"file_name": "/home/qj213/afp-2021-10-22/thys/Partial_Order_Reduction/Transition_System_Extensions.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Partial_Order_Reduction", "problem_names": ["lemma cyclesI[intro!]:\n      assumes \"path w p\" \"target w p = p\"\n      shows \"w \\<in> cycles p\"", "lemma cyclesE[elim!]:\n      assumes \"w \\<in> cycles p\"\n      obtains \"path w p\" \"target w p = p\"", "lemma executableI_step[intro!]:\n      assumes \"p \\<in> nodes\" \"enabled a p\"\n      shows \"a \\<in> executable\"", "lemma executableI_words_fin[intro!]:\n      assumes \"p \\<in> nodes\" \"path w p\"\n      shows \"set w \\<subseteq> executable\"", "lemma executableE[elim?]:\n      assumes \"a \\<in> executable\"\n      obtains p\n      where \"p \\<in> nodes\" \"enabled a p\"", "lemma visibleI[intro]:\n      assumes \"en a q\" \"int q \\<noteq> int (ex a q)\"\n      shows \"a \\<in> visible\"", "lemma visibleE[elim]:\n      assumes \"a \\<in> visible\"\n      obtains q\n      where \"en a q\" \"int q \\<noteq> int (ex a q)\"", "lemma execute_fin_word_invisible:\n      assumes \"path w p\" \"set w \\<subseteq> invisible\"\n      shows \"int (target w p) = int p\"", "lemma execute_inf_word_invisible:\n      assumes \"run w p\" \"k \\<le> l\" \"\\<And> i. k \\<le> i \\<Longrightarrow> i < l \\<Longrightarrow> w !! i \\<notin> visible\"\n      shows \"int ((p ## trace w p) !! k) = int ((p ## trace w p) !! l)\"", "lemma languageI[intro!]:\n      assumes \"w = smap int (p ## trace v p)\" \"init p\" \"run v p\"\n      shows \"w \\<in> language\"", "lemma languageE[elim!]:\n      assumes \"w \\<in> language\"\n      obtains p v\n      where \"w = smap int (p ## trace v p)\" \"init p\" \"run v p\"", "lemma scut_reachable:\n      assumes \"scut p q\"\n      shows \"p \\<in> nodes\" \"q \\<in> nodes\"", "lemma scut_trancl:\n      assumes \"scut\\<^sup>+\\<^sup>+ p q\"\n      obtains w\n      where \"path w p\" \"target w p = q\" \"set w \\<inter> cuts = {}\" \"w \\<noteq> []\"", "lemma no_cut_scut:\n      assumes \"p \\<in> nodes\" \"en a p\" \"a \\<notin> cuts\"\n      shows \"scut\\<inverse>\\<inverse> (ex a p) p\""], "translations": [["", "lemma cyclesI[intro!]:\n      assumes \"path w p\" \"target w p = p\"\n      shows \"w \\<in> cycles p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> cycles p", "using assms"], ["proof (prove)\nusing this:\n  path w p\n  target w p = p\n\ngoal (1 subgoal):\n 1. w \\<in> cycles p", "unfolding cycles_def"], ["proof (prove)\nusing this:\n  path w p\n  target w p = p\n\ngoal (1 subgoal):\n 1. w \\<in> {w. path w p \\<and> target w p = p}", "by auto"], ["", "lemma cyclesE[elim!]:\n      assumes \"w \\<in> cycles p\"\n      obtains \"path w p\" \"target w p = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>path w p; target w p = p\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  w \\<in> cycles p\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>path w p; target w p = p\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding cycles_def"], ["proof (prove)\nusing this:\n  w \\<in> {w. path w p \\<and> target w p = p}\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>path w p; target w p = p\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["", "inductive_set executable :: \"'transition set\"\n      where executable: \"p \\<in> nodes \\<Longrightarrow> enabled a p \\<Longrightarrow> a \\<in> executable\""], ["", "lemma executableI_step[intro!]:\n      assumes \"p \\<in> nodes\" \"enabled a p\"\n      shows \"a \\<in> executable\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> executable", "using executable assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<in> nodes; enabled ?a ?p\\<rbrakk>\n  \\<Longrightarrow> ?a \\<in> executable\n  p \\<in> nodes\n  enabled a p\n\ngoal (1 subgoal):\n 1. a \\<in> executable", "by this"], ["", "lemma executableI_words_fin[intro!]:\n      assumes \"p \\<in> nodes\" \"path w p\"\n      shows \"set w \\<subseteq> executable\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set w \\<subseteq> executable", "using assms"], ["proof (prove)\nusing this:\n  p \\<in> nodes\n  path w p\n\ngoal (1 subgoal):\n 1. set w \\<subseteq> executable", "by (induct w arbitrary: p, auto del: subsetI)"], ["", "lemma executableE[elim?]:\n      assumes \"a \\<in> executable\"\n      obtains p\n      where \"p \\<in> nodes\" \"enabled a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<in> nodes; enabled a p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  a \\<in> executable\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<in> nodes; enabled a p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by induct auto"], ["", "end"], ["", "locale transition_system_interpreted =\n    transition_system ex en\n    for ex :: \"'action \\<Rightarrow> 'state \\<Rightarrow> 'state\"\n    and en :: \"'action \\<Rightarrow> 'state \\<Rightarrow> bool\"\n    and int :: \"'state \\<Rightarrow> 'interpretation\"\n  begin"], ["", "definition visible :: \"'action set\"\n      where \"visible \\<equiv> {a. \\<exists> q. en a q \\<and> int q \\<noteq> int (ex a q)}\""], ["", "lemma visibleI[intro]:\n      assumes \"en a q\" \"int q \\<noteq> int (ex a q)\"\n      shows \"a \\<in> visible\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> visible", "using assms"], ["proof (prove)\nusing this:\n  en a q\n  int q \\<noteq> int (ex a q)\n\ngoal (1 subgoal):\n 1. a \\<in> visible", "unfolding visible_def"], ["proof (prove)\nusing this:\n  en a q\n  int q \\<noteq> int (ex a q)\n\ngoal (1 subgoal):\n 1. a \\<in> {a. \\<exists>q. en a q \\<and> int q \\<noteq> int (ex a q)}", "by auto"], ["", "lemma visibleE[elim]:\n      assumes \"a \\<in> visible\"\n      obtains q\n      where \"en a q\" \"int q \\<noteq> int (ex a q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>en a q; int q \\<noteq> int (ex a q)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  a \\<in> visible\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>en a q; int q \\<noteq> int (ex a q)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding visible_def"], ["proof (prove)\nusing this:\n  a \\<in> {a. \\<exists>q. en a q \\<and> int q \\<noteq> int (ex a q)}\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>en a q; int q \\<noteq> int (ex a q)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["", "abbreviation \"invisible \\<equiv> - visible\""], ["", "lemma execute_fin_word_invisible:\n      assumes \"path w p\" \"set w \\<subseteq> invisible\"\n      shows \"int (target w p) = int p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (target w p) = int p", "using assms"], ["proof (prove)\nusing this:\n  path w p\n  set w \\<subseteq> invisible\n\ngoal (1 subgoal):\n 1. int (target w p) = int p", "by (induct w arbitrary: p rule: list.induct, auto)"], ["", "lemma execute_inf_word_invisible:\n      assumes \"run w p\" \"k \\<le> l\" \"\\<And> i. k \\<le> i \\<Longrightarrow> i < l \\<Longrightarrow> w !! i \\<notin> visible\"\n      shows \"int ((p ## trace w p) !! k) = int ((p ## trace w p) !! l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int ((p ## trace w p) !! k) = int ((p ## trace w p) !! l)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int ((p ## trace w p) !! k) = int ((p ## trace w p) !! l)", "have \"(p ## trace w p) !! l = target (stake l w) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p ## trace w p) !! l = target (stake l w) p", "by simp"], ["proof (state)\nthis:\n  (p ## trace w p) !! l = target (stake l w) p\n\ngoal (1 subgoal):\n 1. int ((p ## trace w p) !! k) = int ((p ## trace w p) !! l)", "also"], ["proof (state)\nthis:\n  (p ## trace w p) !! l = target (stake l w) p\n\ngoal (1 subgoal):\n 1. int ((p ## trace w p) !! k) = int ((p ## trace w p) !! l)", "have \"stake l w = stake k w @ stake (l - k) (sdrop k w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stake l w = stake k w @ stake (l - k) (sdrop k w)", "using assms(2)"], ["proof (prove)\nusing this:\n  k \\<le> l\n\ngoal (1 subgoal):\n 1. stake l w = stake k w @ stake (l - k) (sdrop k w)", "by simp"], ["proof (state)\nthis:\n  stake l w = stake k w @ stake (l - k) (sdrop k w)\n\ngoal (1 subgoal):\n 1. int ((p ## trace w p) !! k) = int ((p ## trace w p) !! l)", "also"], ["proof (state)\nthis:\n  stake l w = stake k w @ stake (l - k) (sdrop k w)\n\ngoal (1 subgoal):\n 1. int ((p ## trace w p) !! k) = int ((p ## trace w p) !! l)", "have \"target \\<dots> p = target (stake (l - k) (sdrop k w)) (target (stake k w) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target (stake k w @ stake (l - k) (sdrop k w)) p =\n    target (stake (l - k) (sdrop k w)) (target (stake k w) p)", "unfolding fold_append comp_apply"], ["proof (prove)\ngoal (1 subgoal):\n 1. target (stake (l - k) (sdrop k w)) (target (stake k w) p) =\n    target (stake (l - k) (sdrop k w)) (target (stake k w) p)", "by rule"], ["proof (state)\nthis:\n  target (stake k w @ stake (l - k) (sdrop k w)) p =\n  target (stake (l - k) (sdrop k w)) (target (stake k w) p)\n\ngoal (1 subgoal):\n 1. int ((p ## trace w p) !! k) = int ((p ## trace w p) !! l)", "also"], ["proof (state)\nthis:\n  target (stake k w @ stake (l - k) (sdrop k w)) p =\n  target (stake (l - k) (sdrop k w)) (target (stake k w) p)\n\ngoal (1 subgoal):\n 1. int ((p ## trace w p) !! k) = int ((p ## trace w p) !! l)", "have \"int \\<dots> = int (target (stake k w) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (target (stake (l - k) (sdrop k w)) (target (stake k w) p)) =\n    int (target (stake k w) p)", "proof (rule execute_fin_word_invisible)"], ["proof (state)\ngoal (2 subgoals):\n 1. path (stake (l - k) (sdrop k w)) (target (stake k w) p)\n 2. set (stake (l - k) (sdrop k w)) \\<subseteq> invisible", "have \"w = stake l w @- sdrop l w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w = stake l w @- sdrop l w", "by simp"], ["proof (state)\nthis:\n  w = stake l w @- sdrop l w\n\ngoal (2 subgoals):\n 1. path (stake (l - k) (sdrop k w)) (target (stake k w) p)\n 2. set (stake (l - k) (sdrop k w)) \\<subseteq> invisible", "also"], ["proof (state)\nthis:\n  w = stake l w @- sdrop l w\n\ngoal (2 subgoals):\n 1. path (stake (l - k) (sdrop k w)) (target (stake k w) p)\n 2. set (stake (l - k) (sdrop k w)) \\<subseteq> invisible", "have \"stake l w = stake k w @ stake (l - k) (sdrop k w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stake l w = stake k w @ stake (l - k) (sdrop k w)", "using assms(2)"], ["proof (prove)\nusing this:\n  k \\<le> l\n\ngoal (1 subgoal):\n 1. stake l w = stake k w @ stake (l - k) (sdrop k w)", "by simp"], ["proof (state)\nthis:\n  stake l w = stake k w @ stake (l - k) (sdrop k w)\n\ngoal (2 subgoals):\n 1. path (stake (l - k) (sdrop k w)) (target (stake k w) p)\n 2. set (stake (l - k) (sdrop k w)) \\<subseteq> invisible", "finally"], ["proof (chain)\npicking this:\n  w = (stake k w @ stake (l - k) (sdrop k w)) @- sdrop l w", "have 1: \"run (stake k w @- stake (l - k) (sdrop k w) @- sdrop l w) p\""], ["proof (prove)\nusing this:\n  w = (stake k w @ stake (l - k) (sdrop k w)) @- sdrop l w\n\ngoal (1 subgoal):\n 1. run (stake k w @- stake (l - k) (sdrop k w) @- sdrop l w) p", "unfolding shift_append"], ["proof (prove)\nusing this:\n  w = stake k w @- stake (l - k) (sdrop k w) @- sdrop l w\n\ngoal (1 subgoal):\n 1. run (stake k w @- stake (l - k) (sdrop k w) @- sdrop l w) p", "using assms(1)"], ["proof (prove)\nusing this:\n  w = stake k w @- stake (l - k) (sdrop k w) @- sdrop l w\n  run w p\n\ngoal (1 subgoal):\n 1. run (stake k w @- stake (l - k) (sdrop k w) @- sdrop l w) p", "by simp"], ["proof (state)\nthis:\n  run (stake k w @- stake (l - k) (sdrop k w) @- sdrop l w) p\n\ngoal (2 subgoals):\n 1. path (stake (l - k) (sdrop k w)) (target (stake k w) p)\n 2. set (stake (l - k) (sdrop k w)) \\<subseteq> invisible", "show \"path (stake (l - k) (sdrop k w)) (target (stake k w) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (stake (l - k) (sdrop k w)) (target (stake k w) p)", "using 1"], ["proof (prove)\nusing this:\n  run (stake k w @- stake (l - k) (sdrop k w) @- sdrop l w) p\n\ngoal (1 subgoal):\n 1. path (stake (l - k) (sdrop k w)) (target (stake k w) p)", "by auto"], ["proof (state)\nthis:\n  path (stake (l - k) (sdrop k w)) (target (stake k w) p)\n\ngoal (1 subgoal):\n 1. set (stake (l - k) (sdrop k w)) \\<subseteq> invisible", "show \"set (stake (l - k) (sdrop k w)) \\<subseteq> invisible\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (stake (l - k) (sdrop k w)) \\<subseteq> invisible", "using assms(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>k \\<le> ?i; ?i < l\\<rbrakk>\n  \\<Longrightarrow> w !! ?i \\<notin> visible\n\ngoal (1 subgoal):\n 1. set (stake (l - k) (sdrop k w)) \\<subseteq> invisible", "by (auto simp: set_stake_snth)"], ["proof (state)\nthis:\n  set (stake (l - k) (sdrop k w)) \\<subseteq> invisible\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  int (target (stake (l - k) (sdrop k w)) (target (stake k w) p)) =\n  int (target (stake k w) p)\n\ngoal (1 subgoal):\n 1. int ((p ## trace w p) !! k) = int ((p ## trace w p) !! l)", "also"], ["proof (state)\nthis:\n  int (target (stake (l - k) (sdrop k w)) (target (stake k w) p)) =\n  int (target (stake k w) p)\n\ngoal (1 subgoal):\n 1. int ((p ## trace w p) !! k) = int ((p ## trace w p) !! l)", "have \"\\<dots> = int ((p ## trace w p) !! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (target (stake k w) p) = int ((p ## trace w p) !! k)", "by simp"], ["proof (state)\nthis:\n  int (target (stake k w) p) = int ((p ## trace w p) !! k)\n\ngoal (1 subgoal):\n 1. int ((p ## trace w p) !! k) = int ((p ## trace w p) !! l)", "finally"], ["proof (chain)\npicking this:\n  int ((p ## trace w p) !! l) = int ((p ## trace w p) !! k)", "show ?thesis"], ["proof (prove)\nusing this:\n  int ((p ## trace w p) !! l) = int ((p ## trace w p) !! k)\n\ngoal (1 subgoal):\n 1. int ((p ## trace w p) !! k) = int ((p ## trace w p) !! l)", "by rule"], ["proof (state)\nthis:\n  int ((p ## trace w p) !! k) = int ((p ## trace w p) !! l)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale transition_system_complete =\n    transition_system_initial ex en init +\n    transition_system_interpreted ex en int\n    for ex :: \"'action \\<Rightarrow> 'state \\<Rightarrow> 'state\"\n    and en :: \"'action \\<Rightarrow> 'state \\<Rightarrow> bool\"\n    and init :: \"'state \\<Rightarrow> bool\"\n    and int :: \"'state \\<Rightarrow> 'interpretation\"\n  begin"], ["", "definition language :: \"'interpretation stream set\"\n      where \"language \\<equiv> {smap int (p ## trace w p) |p w. init p \\<and> run w p}\""], ["", "lemma languageI[intro!]:\n      assumes \"w = smap int (p ## trace v p)\" \"init p\" \"run v p\"\n      shows \"w \\<in> language\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> language", "using assms"], ["proof (prove)\nusing this:\n  w = smap int (p ## trace v p)\n  init p\n  run v p\n\ngoal (1 subgoal):\n 1. w \\<in> language", "unfolding language_def"], ["proof (prove)\nusing this:\n  w = smap int (p ## trace v p)\n  init p\n  run v p\n\ngoal (1 subgoal):\n 1. w \\<in> {smap int (p ## trace w p) |p w. init p \\<and> run w p}", "by auto"], ["", "lemma languageE[elim!]:\n      assumes \"w \\<in> language\"\n      obtains p v\n      where \"w = smap int (p ## trace v p)\" \"init p\" \"run v p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p v.\n        \\<lbrakk>w = smap int (p ## trace v p); init p; run v p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  w \\<in> language\n\ngoal (1 subgoal):\n 1. (\\<And>p v.\n        \\<lbrakk>w = smap int (p ## trace v p); init p; run v p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding language_def"], ["proof (prove)\nusing this:\n  w \\<in> {smap int (p ## trace w p) |p w. init p \\<and> run w p}\n\ngoal (1 subgoal):\n 1. (\\<And>p v.\n        \\<lbrakk>w = smap int (p ## trace v p); init p; run v p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["", "end"], ["", "locale transition_system_finite_nodes =\n    transition_system_initial ex en init\n    for ex :: \"'action \\<Rightarrow> 'state \\<Rightarrow> 'state\"\n    and en :: \"'action \\<Rightarrow> 'state \\<Rightarrow> bool\"\n    and init :: \"'state \\<Rightarrow> bool\"\n    +\n    assumes reachable_finite: \"finite nodes\""], ["", "locale transition_system_cut =\n    transition_system_finite_nodes ex en init\n    for ex :: \"'action \\<Rightarrow> 'state \\<Rightarrow> 'state\"\n    and en :: \"'action \\<Rightarrow> 'state \\<Rightarrow> bool\"\n    and init :: \"'state \\<Rightarrow> bool\"\n    +\n    fixes cuts :: \"'action set\"\n    assumes cycles_cut: \"p \\<in> nodes \\<Longrightarrow> w \\<in> cycles p \\<Longrightarrow> w \\<noteq> [] \\<Longrightarrow> set w \\<inter> cuts \\<noteq> {}\"\n  begin"], ["", "inductive scut :: \"'state \\<Rightarrow> 'state \\<Rightarrow> bool\"\n      where scut: \"p \\<in> nodes \\<Longrightarrow> en a p \\<Longrightarrow> a \\<notin> cuts \\<Longrightarrow> scut p (ex a p)\""], ["", "declare scut.intros[intro!]"], ["", "declare scut.cases[elim!]"], ["", "lemma scut_reachable:\n      assumes \"scut p q\"\n      shows \"p \\<in> nodes\" \"q \\<in> nodes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> nodes &&& q \\<in> nodes", "using assms"], ["proof (prove)\nusing this:\n  scut p q\n\ngoal (1 subgoal):\n 1. p \\<in> nodes &&& q \\<in> nodes", "by auto"], ["", "lemma scut_trancl:\n      assumes \"scut\\<^sup>+\\<^sup>+ p q\"\n      obtains w\n      where \"path w p\" \"target w p = q\" \"set w \\<inter> cuts = {}\" \"w \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>path w p; target w p = q; set w \\<inter> cuts = {};\n         w \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  scut\\<^sup>+\\<^sup>+ p q\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>path w p; target w p = q; set w \\<inter> cuts = {};\n         w \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (induct arbitrary: thesis)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y thesis.\n       \\<lbrakk>scut p y;\n        \\<And>w.\n           \\<lbrakk>path w p; target w p = y; set w \\<inter> cuts = {};\n            w \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>y z thesis.\n       \\<lbrakk>scut\\<^sup>+\\<^sup>+ p y; scut y z;\n        \\<And>thesis.\n           (\\<And>w.\n               \\<lbrakk>path w p; target w p = y; set w \\<inter> cuts = {};\n                w \\<noteq> []\\<rbrakk>\n               \\<Longrightarrow> thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>w.\n           \\<lbrakk>path w p; target w p = z; set w \\<inter> cuts = {};\n            w \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (base q)"], ["proof (state)\nthis:\n  scut p q\n  \\<lbrakk>path ?w p; target ?w p = q; set ?w \\<inter> cuts = {};\n   ?w \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (2 subgoals):\n 1. \\<And>y thesis.\n       \\<lbrakk>scut p y;\n        \\<And>w.\n           \\<lbrakk>path w p; target w p = y; set w \\<inter> cuts = {};\n            w \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>y z thesis.\n       \\<lbrakk>scut\\<^sup>+\\<^sup>+ p y; scut y z;\n        \\<And>thesis.\n           (\\<And>w.\n               \\<lbrakk>path w p; target w p = y; set w \\<inter> cuts = {};\n                w \\<noteq> []\\<rbrakk>\n               \\<Longrightarrow> thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>w.\n           \\<lbrakk>path w p; target w p = z; set w \\<inter> cuts = {};\n            w \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using base"], ["proof (prove)\nusing this:\n  scut p q\n  \\<lbrakk>path ?w p; target ?w p = q; set ?w \\<inter> cuts = {};\n   ?w \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by force"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>y z thesis.\n       \\<lbrakk>scut\\<^sup>+\\<^sup>+ p y; scut y z;\n        \\<And>thesis.\n           (\\<And>w.\n               \\<lbrakk>path w p; target w p = y; set w \\<inter> cuts = {};\n                w \\<noteq> []\\<rbrakk>\n               \\<Longrightarrow> thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>w.\n           \\<lbrakk>path w p; target w p = z; set w \\<inter> cuts = {};\n            w \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z thesis.\n       \\<lbrakk>scut\\<^sup>+\\<^sup>+ p y; scut y z;\n        \\<And>thesis.\n           (\\<And>w.\n               \\<lbrakk>path w p; target w p = y; set w \\<inter> cuts = {};\n                w \\<noteq> []\\<rbrakk>\n               \\<Longrightarrow> thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>w.\n           \\<lbrakk>path w p; target w p = z; set w \\<inter> cuts = {};\n            w \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (step q r)"], ["proof (state)\nthis:\n  scut\\<^sup>+\\<^sup>+ p q\n  scut q r\n  (\\<And>w.\n      \\<lbrakk>path w p; target w p = q; set w \\<inter> cuts = {};\n       w \\<noteq> []\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n  \\<lbrakk>path ?w p; target ?w p = r; set ?w \\<inter> cuts = {};\n   ?w \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. \\<And>y z thesis.\n       \\<lbrakk>scut\\<^sup>+\\<^sup>+ p y; scut y z;\n        \\<And>thesis.\n           (\\<And>w.\n               \\<lbrakk>path w p; target w p = y; set w \\<inter> cuts = {};\n                w \\<noteq> []\\<rbrakk>\n               \\<Longrightarrow> thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>w.\n           \\<lbrakk>path w p; target w p = z; set w \\<inter> cuts = {};\n            w \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain w where 1: \"path w p\" \"target w p = q\" \"set w \\<inter> cuts = {}\" \"w \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>path w p; target w p = q; set w \\<inter> cuts = {};\n         w \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using step(3)"], ["proof (prove)\nusing this:\n  (\\<And>w.\n      \\<lbrakk>path w p; target w p = q; set w \\<inter> cuts = {};\n       w \\<noteq> []\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>path w p; target w p = q; set w \\<inter> cuts = {};\n         w \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by this"], ["proof (state)\nthis:\n  path w p\n  target w p = q\n  set w \\<inter> cuts = {}\n  w \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>y z thesis.\n       \\<lbrakk>scut\\<^sup>+\\<^sup>+ p y; scut y z;\n        \\<And>thesis.\n           (\\<And>w.\n               \\<lbrakk>path w p; target w p = y; set w \\<inter> cuts = {};\n                w \\<noteq> []\\<rbrakk>\n               \\<Longrightarrow> thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>w.\n           \\<lbrakk>path w p; target w p = z; set w \\<inter> cuts = {};\n            w \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain a where 2: \"en a q\" \"a \\<notin> cuts\" \"ex a q = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>en a q; a \\<notin> cuts; ex a q = r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using step(2)"], ["proof (prove)\nusing this:\n  scut q r\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>en a q; a \\<notin> cuts; ex a q = r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  en a q\n  a \\<notin> cuts\n  ex a q = r\n\ngoal (1 subgoal):\n 1. \\<And>y z thesis.\n       \\<lbrakk>scut\\<^sup>+\\<^sup>+ p y; scut y z;\n        \\<And>thesis.\n           (\\<And>w.\n               \\<lbrakk>path w p; target w p = y; set w \\<inter> cuts = {};\n                w \\<noteq> []\\<rbrakk>\n               \\<Longrightarrow> thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>w.\n           \\<lbrakk>path w p; target w p = z; set w \\<inter> cuts = {};\n            w \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule step(4))"], ["proof (state)\ngoal (4 subgoals):\n 1. path ?w p\n 2. target ?w p = r\n 3. set ?w \\<inter> cuts = {}\n 4. ?w \\<noteq> []", "show \"path (w @ [a]) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (w @ [a]) p", "using 1 2"], ["proof (prove)\nusing this:\n  path w p\n  target w p = q\n  set w \\<inter> cuts = {}\n  w \\<noteq> []\n  en a q\n  a \\<notin> cuts\n  ex a q = r\n\ngoal (1 subgoal):\n 1. path (w @ [a]) p", "by auto"], ["proof (state)\nthis:\n  path (w @ [a]) p\n\ngoal (3 subgoals):\n 1. target (w @ [a]) p = r\n 2. set (w @ [a]) \\<inter> cuts = {}\n 3. w @ [a] \\<noteq> []", "show \"target (w @ [a]) p = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target (w @ [a]) p = r", "using 1 2"], ["proof (prove)\nusing this:\n  path w p\n  target w p = q\n  set w \\<inter> cuts = {}\n  w \\<noteq> []\n  en a q\n  a \\<notin> cuts\n  ex a q = r\n\ngoal (1 subgoal):\n 1. target (w @ [a]) p = r", "by auto"], ["proof (state)\nthis:\n  target (w @ [a]) p = r\n\ngoal (2 subgoals):\n 1. set (w @ [a]) \\<inter> cuts = {}\n 2. w @ [a] \\<noteq> []", "show \"set (w @ [a]) \\<inter> cuts = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (w @ [a]) \\<inter> cuts = {}", "using 1 2"], ["proof (prove)\nusing this:\n  path w p\n  target w p = q\n  set w \\<inter> cuts = {}\n  w \\<noteq> []\n  en a q\n  a \\<notin> cuts\n  ex a q = r\n\ngoal (1 subgoal):\n 1. set (w @ [a]) \\<inter> cuts = {}", "by auto"], ["proof (state)\nthis:\n  set (w @ [a]) \\<inter> cuts = {}\n\ngoal (1 subgoal):\n 1. w @ [a] \\<noteq> []", "show \"w @ [a] \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w @ [a] \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  w @ [a] \\<noteq> []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale wellfounded_relation \"scut\\<inverse>\\<inverse>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellfounded_relation scut\\<inverse>\\<inverse>", "proof (unfold_locales, intro finite_acyclic_wf_converse[to_pred] acyclicI[to_pred], safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite {(x, y). scut x y}\n 2. \\<And>x. scut\\<^sup>+\\<^sup>+ x x \\<Longrightarrow> False", "have 1: \"{(p, q). scut p q} \\<subseteq> nodes \\<times> nodes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). scut x y} \\<subseteq> nodes \\<times> nodes", "using scut_reachable"], ["proof (prove)\nusing this:\n  scut ?p ?q \\<Longrightarrow> ?p \\<in> nodes\n  scut ?p ?q \\<Longrightarrow> ?q \\<in> nodes\n\ngoal (1 subgoal):\n 1. {(x, y). scut x y} \\<subseteq> nodes \\<times> nodes", "by blast"], ["proof (state)\nthis:\n  {(x, y). scut x y} \\<subseteq> nodes \\<times> nodes\n\ngoal (2 subgoals):\n 1. finite {(x, y). scut x y}\n 2. \\<And>x. scut\\<^sup>+\\<^sup>+ x x \\<Longrightarrow> False", "have 2: \"finite (nodes \\<times> nodes)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (nodes \\<times> nodes)", "using finite_cartesian_product reachable_finite"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?A; finite ?B\\<rbrakk>\n  \\<Longrightarrow> finite (?A \\<times> ?B)\n  finite nodes\n\ngoal (1 subgoal):\n 1. finite (nodes \\<times> nodes)", "by blast"], ["proof (state)\nthis:\n  finite (nodes \\<times> nodes)\n\ngoal (2 subgoals):\n 1. finite {(x, y). scut x y}\n 2. \\<And>x. scut\\<^sup>+\\<^sup>+ x x \\<Longrightarrow> False", "show \"finite {(p, q). scut p q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {(x, y). scut x y}", "using 1 2"], ["proof (prove)\nusing this:\n  {(x, y). scut x y} \\<subseteq> nodes \\<times> nodes\n  finite (nodes \\<times> nodes)\n\ngoal (1 subgoal):\n 1. finite {(x, y). scut x y}", "by blast"], ["proof (state)\nthis:\n  finite {(x, y). scut x y}\n\ngoal (1 subgoal):\n 1. \\<And>x. scut\\<^sup>+\\<^sup>+ x x \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. scut\\<^sup>+\\<^sup>+ x x \\<Longrightarrow> False", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. scut\\<^sup>+\\<^sup>+ x x \\<Longrightarrow> False", "assume 1: \"scut\\<^sup>+\\<^sup>+ p p\""], ["proof (state)\nthis:\n  scut\\<^sup>+\\<^sup>+ p p\n\ngoal (1 subgoal):\n 1. \\<And>x. scut\\<^sup>+\\<^sup>+ x x \\<Longrightarrow> False", "have 2: \"p \\<in> nodes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> nodes", "using 1 tranclE[to_pred] scut_reachable"], ["proof (prove)\nusing this:\n  scut\\<^sup>+\\<^sup>+ p p\n  \\<lbrakk>?r\\<^sup>+\\<^sup>+ ?a ?b; ?r ?a ?b \\<Longrightarrow> ?thesis;\n   \\<And>c.\n      \\<lbrakk>?r\\<^sup>+\\<^sup>+ ?a c; ?r c ?b\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  scut ?p ?q \\<Longrightarrow> ?p \\<in> nodes\n  scut ?p ?q \\<Longrightarrow> ?q \\<in> nodes\n\ngoal (1 subgoal):\n 1. p \\<in> nodes", "by metis"], ["proof (state)\nthis:\n  p \\<in> nodes\n\ngoal (1 subgoal):\n 1. \\<And>x. scut\\<^sup>+\\<^sup>+ x x \\<Longrightarrow> False", "obtain w where 3: \"path w p\" \"target w p = p\" \"set w \\<inter> cuts = {}\" \"w \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>path w p; target w p = p; set w \\<inter> cuts = {};\n         w \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using scut_trancl 1"], ["proof (prove)\nusing this:\n  \\<lbrakk>scut\\<^sup>+\\<^sup>+ ?p ?q;\n   \\<And>w.\n      \\<lbrakk>path w ?p; target w ?p = ?q; set w \\<inter> cuts = {};\n       w \\<noteq> []\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  scut\\<^sup>+\\<^sup>+ p p\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>path w p; target w p = p; set w \\<inter> cuts = {};\n         w \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by this"], ["proof (state)\nthis:\n  path w p\n  target w p = p\n  set w \\<inter> cuts = {}\n  w \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>x. scut\\<^sup>+\\<^sup>+ x x \\<Longrightarrow> False", "have 4: \"w \\<in> cycles p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> cycles p", "using 3(1, 2)"], ["proof (prove)\nusing this:\n  path w p\n  target w p = p\n\ngoal (1 subgoal):\n 1. w \\<in> cycles p", "by auto"], ["proof (state)\nthis:\n  w \\<in> cycles p\n\ngoal (1 subgoal):\n 1. \\<And>x. scut\\<^sup>+\\<^sup>+ x x \\<Longrightarrow> False", "have 5: \"set w \\<inter> cuts \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set w \\<inter> cuts \\<noteq> {}", "using cycles_cut 2 4 3(4)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<in> nodes; ?w \\<in> cycles ?p; ?w \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> set ?w \\<inter> cuts \\<noteq> {}\n  p \\<in> nodes\n  w \\<in> cycles p\n  w \\<noteq> []\n\ngoal (1 subgoal):\n 1. set w \\<inter> cuts \\<noteq> {}", "by this"], ["proof (state)\nthis:\n  set w \\<inter> cuts \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>x. scut\\<^sup>+\\<^sup>+ x x \\<Longrightarrow> False", "show \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using 3(3) 5"], ["proof (prove)\nusing this:\n  set w \\<inter> cuts = {}\n  set w \\<inter> cuts \\<noteq> {}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma no_cut_scut:\n      assumes \"p \\<in> nodes\" \"en a p\" \"a \\<notin> cuts\"\n      shows \"scut\\<inverse>\\<inverse> (ex a p) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scut\\<inverse>\\<inverse> (ex a p) p", "using assms"], ["proof (prove)\nusing this:\n  p \\<in> nodes\n  en a p\n  a \\<notin> cuts\n\ngoal (1 subgoal):\n 1. scut\\<inverse>\\<inverse> (ex a p) p", "by auto"], ["", "end"], ["", "locale transition_system_sticky =\n    transition_system_complete ex en init int +\n    transition_system_cut ex en init sticky\n    for ex :: \"'action \\<Rightarrow> 'state \\<Rightarrow> 'state\"\n    and en :: \"'action \\<Rightarrow> 'state \\<Rightarrow> bool\"\n    and init :: \"'state \\<Rightarrow> bool\"\n    and int :: \"'state \\<Rightarrow> 'interpretation\"\n    and sticky :: \"'action set\"\n    +\n    assumes executable_visible_sticky: \"executable \\<inter> visible \\<subseteq> sticky\""], ["", "end"]]}