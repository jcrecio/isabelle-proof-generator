{"file_name": "/home/qj213/afp-2021-10-22/thys/Partial_Order_Reduction/Extensions/CCPO_Extensions.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Partial_Order_Reduction", "problem_names": ["lemma chain_split[dest]:\n    assumes \"Complete_Partial_Order.chain ord C\" \"x \\<in> C\"\n    shows \"C = {y \\<in> C. ord x y} \\<union> {y \\<in> C. ord y x}\"", "lemma infinite_chain_below[dest]:\n    assumes \"Complete_Partial_Order.chain ord C\" \"infinite C\" \"x \\<in> C\"\n    assumes \"finite {y \\<in> C. ord x y}\"\n    shows \"infinite {y \\<in> C. ord y x}\"", "lemma infinite_chain_above[dest]:\n    assumes \"Complete_Partial_Order.chain ord C\" \"infinite C\" \"x \\<in> C\"\n    assumes \"finite {y \\<in> C. ord y x}\"\n    shows \"infinite {y \\<in> C. ord x y}\"", "lemma (in ccpo) ccpo_Sup_upper_inv:\n    assumes \"Complete_Partial_Order.chain less_eq C\" \"x > \\<Squnion> C\"\n    shows \"x \\<notin> C\"", "lemma (in ccpo) ccpo_Sup_least_inv:\n    assumes \"Complete_Partial_Order.chain less_eq C\" \"\\<Squnion> C > x\"\n    obtains y\n    where \"y \\<in> C\" \"\\<not> y \\<le> x\"", "lemma ccpo_Sup_least_inv':\n    fixes C :: \"'a :: {ccpo, linorder} set\"\n    assumes \"Complete_Partial_Order.chain less_eq C\" \"\\<Squnion> C > x\"\n    obtains y\n    where \"y \\<in> C\" \"y > x\"", "lemma mcont2mcont_lessThan[THEN lfp.mcont2mcont, simp, cont_intro]:\n    shows mcont_lessThan: \"mcont Sup less_eq Sup less_eq\n      (lessThan :: 'a :: {ccpo, linorder} \\<Rightarrow> 'a set)\"", "lemma infinite_chain_eSuc_esize[dest]:\n      assumes \"Complete_Partial_Order.chain less_eq C\" \"infinite C\" \"x \\<in> C\"\n      obtains y\n      where \"y \\<in> C\" \"esize y \\<ge> eSuc (esize x)\"", "lemma infinite_chain_arbitrary_esize[dest]:\n      assumes \"Complete_Partial_Order.chain less_eq C\" \"infinite C\"\n      obtains x\n      where \"x \\<in> C\" \"esize x \\<ge> enat n\"", "lemma esize_cont[dest]:\n      assumes \"Complete_Partial_Order.chain less_eq C\" \"C \\<noteq> {}\"\n      shows \"esize (\\<Squnion> C) = \\<Squnion> (esize ` C)\"", "lemma esize_mcont: \"mcont Sup less_eq Sup less_eq esize\"", "lemmas mcont2mcont_esize = esize_mcont[THEN lfp.mcont2mcont, simp, cont_intro]"], "translations": [["", "lemma chain_split[dest]:\n    assumes \"Complete_Partial_Order.chain ord C\" \"x \\<in> C\"\n    shows \"C = {y \\<in> C. ord x y} \\<union> {y \\<in> C. ord y x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C = {y \\<in> C. ord x y} \\<union> {y \\<in> C. ord y x}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. C = {y \\<in> C. ord x y} \\<union> {y \\<in> C. ord y x}", "have 1: \"\\<And> y. y \\<in> C \\<Longrightarrow> ord x y \\<or> ord y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> C \\<Longrightarrow> ord x y \\<or> ord y x", "using chainD assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>Complete_Partial_Order.chain ?ord ?S; ?x \\<in> ?S;\n   ?y \\<in> ?S\\<rbrakk>\n  \\<Longrightarrow> ?ord ?x ?y \\<or> ?ord ?y ?x\n  Complete_Partial_Order.chain ord C\n  x \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> C \\<Longrightarrow> ord x y \\<or> ord y x", "by this"], ["proof (state)\nthis:\n  ?y \\<in> C \\<Longrightarrow> ord x ?y \\<or> ord ?y x\n\ngoal (1 subgoal):\n 1. C = {y \\<in> C. ord x y} \\<union> {y \\<in> C. ord y x}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. C = {y \\<in> C. ord x y} \\<union> {y \\<in> C. ord y x}", "using 1"], ["proof (prove)\nusing this:\n  ?y \\<in> C \\<Longrightarrow> ord x ?y \\<or> ord ?y x\n\ngoal (1 subgoal):\n 1. C = {y \\<in> C. ord x y} \\<union> {y \\<in> C. ord y x}", "by blast"], ["proof (state)\nthis:\n  C = {y \\<in> C. ord x y} \\<union> {y \\<in> C. ord y x}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma infinite_chain_below[dest]:\n    assumes \"Complete_Partial_Order.chain ord C\" \"infinite C\" \"x \\<in> C\"\n    assumes \"finite {y \\<in> C. ord x y}\"\n    shows \"infinite {y \\<in> C. ord y x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite {y \\<in> C. ord y x}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite {y \\<in> C. ord y x}", "have 1: \"C = {y \\<in> C. ord x y} \\<union> {y \\<in> C. ord y x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C = {y \\<in> C. ord x y} \\<union> {y \\<in> C. ord y x}", "using assms(1, 3)"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain ord C\n  x \\<in> C\n\ngoal (1 subgoal):\n 1. C = {y \\<in> C. ord x y} \\<union> {y \\<in> C. ord y x}", "by rule"], ["proof (state)\nthis:\n  C = {y \\<in> C. ord x y} \\<union> {y \\<in> C. ord y x}\n\ngoal (1 subgoal):\n 1. infinite {y \\<in> C. ord y x}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite {y \\<in> C. ord y x}", "using finite_Un assms(2, 4) 1"], ["proof (prove)\nusing this:\n  finite (?F \\<union> ?G) = (finite ?F \\<and> finite ?G)\n  infinite C\n  finite {y \\<in> C. ord x y}\n  C = {y \\<in> C. ord x y} \\<union> {y \\<in> C. ord y x}\n\ngoal (1 subgoal):\n 1. infinite {y \\<in> C. ord y x}", "by (metis (poly_guards_query))"], ["proof (state)\nthis:\n  infinite {y \\<in> C. ord y x}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma infinite_chain_above[dest]:\n    assumes \"Complete_Partial_Order.chain ord C\" \"infinite C\" \"x \\<in> C\"\n    assumes \"finite {y \\<in> C. ord y x}\"\n    shows \"infinite {y \\<in> C. ord x y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite {y \\<in> C. ord x y}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite {y \\<in> C. ord x y}", "have 1: \"C = {y \\<in> C. ord x y} \\<union> {y \\<in> C. ord y x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C = {y \\<in> C. ord x y} \\<union> {y \\<in> C. ord y x}", "using assms(1, 3)"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain ord C\n  x \\<in> C\n\ngoal (1 subgoal):\n 1. C = {y \\<in> C. ord x y} \\<union> {y \\<in> C. ord y x}", "by rule"], ["proof (state)\nthis:\n  C = {y \\<in> C. ord x y} \\<union> {y \\<in> C. ord y x}\n\ngoal (1 subgoal):\n 1. infinite {y \\<in> C. ord x y}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite {y \\<in> C. ord x y}", "using finite_Un assms(2, 4) 1"], ["proof (prove)\nusing this:\n  finite (?F \\<union> ?G) = (finite ?F \\<and> finite ?G)\n  infinite C\n  finite {y \\<in> C. ord y x}\n  C = {y \\<in> C. ord x y} \\<union> {y \\<in> C. ord y x}\n\ngoal (1 subgoal):\n 1. infinite {y \\<in> C. ord x y}", "by (metis (poly_guards_query))"], ["proof (state)\nthis:\n  infinite {y \\<in> C. ord x y}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in ccpo) ccpo_Sup_upper_inv:\n    assumes \"Complete_Partial_Order.chain less_eq C\" \"x > \\<Squnion> C\"\n    shows \"x \\<notin> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> C", "using assms ccpo_Sup_upper"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) C\n  \\<Squnion> C < x\n  \\<lbrakk>Complete_Partial_Order.chain (\\<le>) ?A; ?x \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> \\<Squnion> ?A\n\ngoal (1 subgoal):\n 1. x \\<notin> C", "by fastforce"], ["", "lemma (in ccpo) ccpo_Sup_least_inv:\n    assumes \"Complete_Partial_Order.chain less_eq C\" \"\\<Squnion> C > x\"\n    obtains y\n    where \"y \\<in> C\" \"\\<not> y \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> C; \\<not> y \\<le> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms ccpo_Sup_least that"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) C\n  x < \\<Squnion> C\n  \\<lbrakk>Complete_Partial_Order.chain (\\<le>) ?A;\n   \\<And>x. x \\<in> ?A \\<Longrightarrow> x \\<le> ?z\\<rbrakk>\n  \\<Longrightarrow> \\<Squnion> ?A \\<le> ?z\n  \\<lbrakk>?y \\<in> C; \\<not> ?y \\<le> x\\<rbrakk> \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> C; \\<not> y \\<le> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["", "lemma ccpo_Sup_least_inv':\n    fixes C :: \"'a :: {ccpo, linorder} set\"\n    assumes \"Complete_Partial_Order.chain less_eq C\" \"\\<Squnion> C > x\"\n    obtains y\n    where \"y \\<in> C\" \"y > x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> C; x < y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> C; x < y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain y where 1: \"y \\<in> C\" \"\\<not> y \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> C; \\<not> y \\<le> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ccpo_Sup_least_inv assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>Complete_Partial_Order.chain (\\<le>) ?C; ?x < \\<Squnion> ?C;\n   \\<And>y.\n      \\<lbrakk>y \\<in> ?C; \\<not> y \\<le> ?x\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  Complete_Partial_Order.chain (\\<le>) C\n  x < \\<Squnion> C\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> C; \\<not> y \\<le> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by this"], ["proof (state)\nthis:\n  y \\<in> C\n  \\<not> y \\<le> x\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> C; x < y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using that 1"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<in> C; x < ?y\\<rbrakk> \\<Longrightarrow> thesis\n  y \\<in> C\n  \\<not> y \\<le> x\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mcont2mcont_lessThan[THEN lfp.mcont2mcont, simp, cont_intro]:\n    shows mcont_lessThan: \"mcont Sup less_eq Sup less_eq\n      (lessThan :: 'a :: {ccpo, linorder} \\<Rightarrow> 'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont Sup (\\<le>) \\<Union> (\\<subseteq>) lessThan", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. monotone (\\<le>) (\\<subseteq>) lessThan\n 2. cont Sup (\\<le>) \\<Union> (\\<subseteq>) lessThan", "show \"monotone less_eq less_eq (lessThan :: 'a \\<Rightarrow> 'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<le>) (\\<subseteq>) lessThan", "by (rule, auto)"], ["proof (state)\nthis:\n  monotone (\\<le>) (\\<subseteq>) lessThan\n\ngoal (1 subgoal):\n 1. cont Sup (\\<le>) \\<Union> (\\<subseteq>) lessThan", "show \"cont Sup less_eq Sup less_eq (lessThan :: 'a \\<Rightarrow> 'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont Sup (\\<le>) \\<Union> (\\<subseteq>) lessThan", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) Y;\n        Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> {..<\\<Squnion> Y} = \\<Union> (lessThan ` Y)", "fix C :: \"'a set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) Y;\n        Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> {..<\\<Squnion> Y} = \\<Union> (lessThan ` Y)", "assume 1: \"Complete_Partial_Order.chain less_eq C\""], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (\\<le>) C\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) Y;\n        Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> {..<\\<Squnion> Y} = \\<Union> (lessThan ` Y)", "show \"{..< \\<Squnion> C} = \\<Union> (lessThan ` C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {..<\\<Squnion> C} = \\<Union> (lessThan ` C)", "proof (intro equalityI subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {..<\\<Squnion> C} \\<Longrightarrow>\n       x \\<in> \\<Union> (lessThan ` C)\n 2. \\<And>x.\n       x \\<in> \\<Union> (lessThan ` C) \\<Longrightarrow>\n       x \\<in> {..<\\<Squnion> C}", "fix A"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {..<\\<Squnion> C} \\<Longrightarrow>\n       x \\<in> \\<Union> (lessThan ` C)\n 2. \\<And>x.\n       x \\<in> \\<Union> (lessThan ` C) \\<Longrightarrow>\n       x \\<in> {..<\\<Squnion> C}", "assume 2: \"A \\<in> {..< \\<Squnion> C}\""], ["proof (state)\nthis:\n  A \\<in> {..<\\<Squnion> C}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {..<\\<Squnion> C} \\<Longrightarrow>\n       x \\<in> \\<Union> (lessThan ` C)\n 2. \\<And>x.\n       x \\<in> \\<Union> (lessThan ` C) \\<Longrightarrow>\n       x \\<in> {..<\\<Squnion> C}", "obtain B where 3: \"B \\<in> C\" \"B > A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>B \\<in> C; A < B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ccpo_Sup_least_inv' 1 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>Complete_Partial_Order.chain (\\<le>) ?C; ?x < \\<Squnion> ?C;\n   \\<And>y.\n      \\<lbrakk>y \\<in> ?C; ?x < y\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  Complete_Partial_Order.chain (\\<le>) C\n  A \\<in> {..<\\<Squnion> C}\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>B \\<in> C; A < B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  B \\<in> C\n  A < B\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {..<\\<Squnion> C} \\<Longrightarrow>\n       x \\<in> \\<Union> (lessThan ` C)\n 2. \\<And>x.\n       x \\<in> \\<Union> (lessThan ` C) \\<Longrightarrow>\n       x \\<in> {..<\\<Squnion> C}", "show \"A \\<in> \\<Union> (lessThan ` C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> \\<Union> (lessThan ` C)", "using 3"], ["proof (prove)\nusing this:\n  B \\<in> C\n  A < B\n\ngoal (1 subgoal):\n 1. A \\<in> \\<Union> (lessThan ` C)", "by auto"], ["proof (state)\nthis:\n  A \\<in> \\<Union> (lessThan ` C)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (lessThan ` C) \\<Longrightarrow>\n       x \\<in> {..<\\<Squnion> C}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (lessThan ` C) \\<Longrightarrow>\n       x \\<in> {..<\\<Squnion> C}", "fix A"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (lessThan ` C) \\<Longrightarrow>\n       x \\<in> {..<\\<Squnion> C}", "assume 2: \"A \\<in> \\<Union> (lessThan ` C)\""], ["proof (state)\nthis:\n  A \\<in> \\<Union> (lessThan ` C)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (lessThan ` C) \\<Longrightarrow>\n       x \\<in> {..<\\<Squnion> C}", "show \"A \\<in> {..< \\<Squnion> C}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> {..<\\<Squnion> C}", "using ccpo_Sup_upper 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>Complete_Partial_Order.chain (\\<le>) ?A; ?x \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> \\<Squnion> ?A\n  A \\<in> \\<Union> (lessThan ` C)\n\ngoal (1 subgoal):\n 1. A \\<in> {..<\\<Squnion> C}", "by force"], ["proof (state)\nthis:\n  A \\<in> {..<\\<Squnion> C}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {..<\\<Squnion> C} = \\<Union> (lessThan ` C)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cont Sup (\\<le>) \\<Union> (\\<subseteq>) lessThan\n\ngoal:\nNo subgoals!", "qed"], ["", "class esize =\n    fixes esize :: \"'a \\<Rightarrow> enat\""], ["", "class esize_order = esize + order +\n    assumes esize_finite[dest]: \"esize x \\<noteq> \\<infinity> \\<Longrightarrow> finite {y. y \\<le> x}\"\n    assumes esize_mono[intro]: \"x \\<le> y \\<Longrightarrow> esize x \\<le> esize y\"\n    assumes esize_strict_mono[intro]: \"esize x \\<noteq> \\<infinity> \\<Longrightarrow> x < y \\<Longrightarrow> esize x < esize y\"\n  begin"], ["", "lemma infinite_chain_eSuc_esize[dest]:\n      assumes \"Complete_Partial_Order.chain less_eq C\" \"infinite C\" \"x \\<in> C\"\n      obtains y\n      where \"y \\<in> C\" \"esize y \\<ge> eSuc (esize x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> C; eSuc (esize x) \\<le> esize y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (cases \"esize x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y \\<in> C; eSuc (esize x) \\<le> esize y\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        esize x = enat nat\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>y.\n                \\<lbrakk>y \\<in> C; eSuc (esize x) \\<le> esize y\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     esize x = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> thesis", "case (enat k)"], ["proof (state)\nthis:\n  esize x = enat k\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y \\<in> C; eSuc (esize x) \\<le> esize y\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        esize x = enat nat\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>y.\n                \\<lbrakk>y \\<in> C; eSuc (esize x) \\<le> esize y\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     esize x = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> thesis", "have 1: \"finite {y \\<in> C. y \\<le> x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {y \\<in> C. y \\<le> x}", "using esize_finite enat"], ["proof (prove)\nusing this:\n  esize ?x \\<noteq> \\<infinity> \\<Longrightarrow> finite {y. y \\<le> ?x}\n  esize x = enat k\n\ngoal (1 subgoal):\n 1. finite {y \\<in> C. y \\<le> x}", "by simp"], ["proof (state)\nthis:\n  finite {y \\<in> C. y \\<le> x}\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y \\<in> C; eSuc (esize x) \\<le> esize y\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        esize x = enat nat\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>y.\n                \\<lbrakk>y \\<in> C; eSuc (esize x) \\<le> esize y\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     esize x = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> thesis", "have 2: \"infinite {y \\<in> C. y \\<ge> x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite {y \\<in> C. x \\<le> y}", "using assms 1"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) C\n  infinite C\n  x \\<in> C\n  finite {y \\<in> C. y \\<le> x}\n\ngoal (1 subgoal):\n 1. infinite {y \\<in> C. x \\<le> y}", "by rule"], ["proof (state)\nthis:\n  infinite {y \\<in> C. x \\<le> y}\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y \\<in> C; eSuc (esize x) \\<le> esize y\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        esize x = enat nat\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>y.\n                \\<lbrakk>y \\<in> C; eSuc (esize x) \\<le> esize y\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     esize x = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> thesis", "have 3: \"{y \\<in> C. y > x} = {y \\<in> C. y \\<ge> x} - {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y \\<in> C. x < y} = {y \\<in> C. x \\<le> y} - {x}", "by auto"], ["proof (state)\nthis:\n  {y \\<in> C. x < y} = {y \\<in> C. x \\<le> y} - {x}\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y \\<in> C; eSuc (esize x) \\<le> esize y\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        esize x = enat nat\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>y.\n                \\<lbrakk>y \\<in> C; eSuc (esize x) \\<le> esize y\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     esize x = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> thesis", "have 4: \"infinite {y \\<in> C. y > x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite {y \\<in> C. x < y}", "using 2"], ["proof (prove)\nusing this:\n  infinite {y \\<in> C. x \\<le> y}\n\ngoal (1 subgoal):\n 1. infinite {y \\<in> C. x < y}", "unfolding 3"], ["proof (prove)\nusing this:\n  infinite {y \\<in> C. x \\<le> y}\n\ngoal (1 subgoal):\n 1. infinite ({y \\<in> C. x \\<le> y} - {x})", "by simp"], ["proof (state)\nthis:\n  infinite {y \\<in> C. x < y}\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y \\<in> C; eSuc (esize x) \\<le> esize y\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        esize x = enat nat\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>y.\n                \\<lbrakk>y \\<in> C; eSuc (esize x) \\<le> esize y\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     esize x = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> thesis", "obtain y where 5: \"y \\<in> C\" \"y > x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> C; x < y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 4"], ["proof (prove)\nusing this:\n  infinite {y \\<in> C. x < y}\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> C; x < y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y \\<in> C\n  x < y\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y \\<in> C; eSuc (esize x) \\<le> esize y\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        esize x = enat nat\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>y.\n                \\<lbrakk>y \\<in> C; eSuc (esize x) \\<le> esize y\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     esize x = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> thesis", "have 6: \"esize y > esize x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. esize x < esize y", "using esize_strict_mono enat 5(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>esize ?x \\<noteq> \\<infinity>; ?x < ?y\\<rbrakk>\n  \\<Longrightarrow> esize ?x < esize ?y\n  esize x = enat k\n  x < y\n\ngoal (1 subgoal):\n 1. esize x < esize y", "by blast"], ["proof (state)\nthis:\n  esize x < esize y\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y \\<in> C; eSuc (esize x) \\<le> esize y\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        esize x = enat nat\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>y.\n                \\<lbrakk>y \\<in> C; eSuc (esize x) \\<le> esize y\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     esize x = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using that 5(1) 6 ileI1"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<in> C; eSuc (esize x) \\<le> esize ?y\\<rbrakk>\n  \\<Longrightarrow> thesis\n  y \\<in> C\n  esize x < esize y\n  ?m < ?n \\<Longrightarrow> eSuc ?m \\<le> ?n\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>y.\n                \\<lbrakk>y \\<in> C; eSuc (esize x) \\<le> esize y\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     esize x = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>y.\n                \\<lbrakk>y \\<in> C; eSuc (esize x) \\<le> esize y\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     esize x = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> thesis", "case (infinity)"], ["proof (state)\nthis:\n  esize x = \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>y.\n                \\<lbrakk>y \\<in> C; eSuc (esize x) \\<le> esize y\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     esize x = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using that infinity assms(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<in> C; eSuc (esize x) \\<le> esize ?y\\<rbrakk>\n  \\<Longrightarrow> thesis\n  esize x = \\<infinity>\n  x \\<in> C\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma infinite_chain_arbitrary_esize[dest]:\n      assumes \"Complete_Partial_Order.chain less_eq C\" \"infinite C\"\n      obtains x\n      where \"x \\<in> C\" \"esize x \\<ge> enat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> C; enat n \\<le> esize x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (induct n arbitrary: thesis)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       (\\<And>x.\n           \\<lbrakk>x \\<in> C; enat 0 \\<le> esize x\\<rbrakk>\n           \\<Longrightarrow> thesis) \\<Longrightarrow>\n       thesis\n 2. \\<And>n thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>x.\n                       \\<lbrakk>x \\<in> C; enat n \\<le> esize x\\<rbrakk>\n                       \\<Longrightarrow> thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>x.\n           \\<lbrakk>x \\<in> C; enat (Suc n) \\<le> esize x\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "case 0"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> C; enat 0 \\<le> esize ?x\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       (\\<And>x.\n           \\<lbrakk>x \\<in> C; enat 0 \\<le> esize x\\<rbrakk>\n           \\<Longrightarrow> thesis) \\<Longrightarrow>\n       thesis\n 2. \\<And>n thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>x.\n                       \\<lbrakk>x \\<in> C; enat n \\<le> esize x\\<rbrakk>\n                       \\<Longrightarrow> thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>x.\n           \\<lbrakk>x \\<in> C; enat (Suc n) \\<le> esize x\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using assms(2) 0"], ["proof (prove)\nusing this:\n  infinite C\n  \\<lbrakk>?x \\<in> C; enat 0 \\<le> esize ?x\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by force"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>n thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>x.\n                       \\<lbrakk>x \\<in> C; enat n \\<le> esize x\\<rbrakk>\n                       \\<Longrightarrow> thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>x.\n           \\<lbrakk>x \\<in> C; enat (Suc n) \\<le> esize x\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>x.\n                       \\<lbrakk>x \\<in> C; enat n \\<le> esize x\\<rbrakk>\n                       \\<Longrightarrow> thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>x.\n           \\<lbrakk>x \\<in> C; enat (Suc n) \\<le> esize x\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (Suc n)"], ["proof (state)\nthis:\n  (\\<And>x.\n      \\<lbrakk>x \\<in> C; enat n \\<le> esize x\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n  \\<lbrakk>?x \\<in> C; enat (Suc n) \\<le> esize ?x\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. \\<And>n thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>x.\n                       \\<lbrakk>x \\<in> C; enat n \\<le> esize x\\<rbrakk>\n                       \\<Longrightarrow> thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>x.\n           \\<lbrakk>x \\<in> C; enat (Suc n) \\<le> esize x\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain x where 1: \"x \\<in> C\" \"esize x \\<ge> enat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> C; enat n \\<le> esize x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Suc(1)"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      \\<lbrakk>x \\<in> C; enat n \\<le> esize x\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> C; enat n \\<le> esize x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> C\n  enat n \\<le> esize x\n\ngoal (1 subgoal):\n 1. \\<And>n thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>x.\n                       \\<lbrakk>x \\<in> C; enat n \\<le> esize x\\<rbrakk>\n                       \\<Longrightarrow> thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>x.\n           \\<lbrakk>x \\<in> C; enat (Suc n) \\<le> esize x\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain y where 2: \"y \\<in> C\" \"esize y \\<ge> eSuc (esize x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> C; eSuc (esize x) \\<le> esize y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms 1(1)"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) C\n  infinite C\n  x \\<in> C\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> C; eSuc (esize x) \\<le> esize y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by rule"], ["proof (state)\nthis:\n  y \\<in> C\n  eSuc (esize x) \\<le> esize y\n\ngoal (1 subgoal):\n 1. \\<And>n thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>x.\n                       \\<lbrakk>x \\<in> C; enat n \\<le> esize x\\<rbrakk>\n                       \\<Longrightarrow> thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>x.\n           \\<lbrakk>x \\<in> C; enat (Suc n) \\<le> esize x\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using gfp.leq_trans Suc(2) 1(2) 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<le> ?x; ?z \\<le> ?y\\<rbrakk> \\<Longrightarrow> ?z \\<le> ?x\n  \\<lbrakk>?x \\<in> C; enat (Suc n) \\<le> esize ?x\\<rbrakk>\n  \\<Longrightarrow> thesis\n  enat n \\<le> esize x\n  y \\<in> C\n  eSuc (esize x) \\<le> esize y\n\ngoal (1 subgoal):\n 1. thesis", "by fastforce"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "class esize_ccpo = esize_order + ccpo\n  begin"], ["", "lemma esize_cont[dest]:\n      assumes \"Complete_Partial_Order.chain less_eq C\" \"C \\<noteq> {}\"\n      shows \"esize (\\<Squnion> C) = \\<Squnion> (esize ` C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. esize (\\<Squnion> C) = \\<Squnion> (esize ` C)", "proof (cases \"finite C\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite C \\<Longrightarrow> esize (\\<Squnion> C) = \\<Squnion> (esize ` C)\n 2. infinite C \\<Longrightarrow>\n    esize (\\<Squnion> C) = \\<Squnion> (esize ` C)", "case False"], ["proof (state)\nthis:\n  infinite C\n\ngoal (2 subgoals):\n 1. finite C \\<Longrightarrow> esize (\\<Squnion> C) = \\<Squnion> (esize ` C)\n 2. infinite C \\<Longrightarrow>\n    esize (\\<Squnion> C) = \\<Squnion> (esize ` C)", "have 1: \"esize (\\<Squnion> C) = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. esize (\\<Squnion> C) = \\<infinity>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. enat n \\<le> esize (\\<Squnion> C)", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. enat n \\<le> esize (\\<Squnion> C)", "obtain A where 1: \"A \\<in> C\" \"esize A \\<ge> enat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>A \\<in> C; enat n \\<le> esize A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1) False"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) C\n  infinite C\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>A \\<in> C; enat n \\<le> esize A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by rule"], ["proof (state)\nthis:\n  A \\<in> C\n  enat n \\<le> esize A\n\ngoal (1 subgoal):\n 1. \\<And>n. enat n \\<le> esize (\\<Squnion> C)", "have 2: \"A \\<le> \\<Squnion> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<le> \\<Squnion> C", "using ccpo_Sup_upper assms(1) 1(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>Complete_Partial_Order.chain (\\<le>) ?A; ?x \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> \\<Squnion> ?A\n  Complete_Partial_Order.chain (\\<le>) C\n  A \\<in> C\n\ngoal (1 subgoal):\n 1. A \\<le> \\<Squnion> C", "by this"], ["proof (state)\nthis:\n  A \\<le> \\<Squnion> C\n\ngoal (1 subgoal):\n 1. \\<And>n. enat n \\<le> esize (\\<Squnion> C)", "have \"enat n \\<le> esize A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat n \\<le> esize A", "using 1(2)"], ["proof (prove)\nusing this:\n  enat n \\<le> esize A\n\ngoal (1 subgoal):\n 1. enat n \\<le> esize A", "by this"], ["proof (state)\nthis:\n  enat n \\<le> esize A\n\ngoal (1 subgoal):\n 1. \\<And>n. enat n \\<le> esize (\\<Squnion> C)", "also"], ["proof (state)\nthis:\n  enat n \\<le> esize A\n\ngoal (1 subgoal):\n 1. \\<And>n. enat n \\<le> esize (\\<Squnion> C)", "have \"\\<dots> \\<le> esize (\\<Squnion> C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. esize A \\<le> esize (\\<Squnion> C)", "using 2"], ["proof (prove)\nusing this:\n  A \\<le> \\<Squnion> C\n\ngoal (1 subgoal):\n 1. esize A \\<le> esize (\\<Squnion> C)", "by rule"], ["proof (state)\nthis:\n  esize A \\<le> esize (\\<Squnion> C)\n\ngoal (1 subgoal):\n 1. \\<And>n. enat n \\<le> esize (\\<Squnion> C)", "finally"], ["proof (chain)\npicking this:\n  enat n \\<le> esize (\\<Squnion> C)", "show \"enat n \\<le> esize (\\<Squnion> C)\""], ["proof (prove)\nusing this:\n  enat n \\<le> esize (\\<Squnion> C)\n\ngoal (1 subgoal):\n 1. enat n \\<le> esize (\\<Squnion> C)", "by this"], ["proof (state)\nthis:\n  enat n \\<le> esize (\\<Squnion> C)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  esize (\\<Squnion> C) = \\<infinity>\n\ngoal (2 subgoals):\n 1. finite C \\<Longrightarrow> esize (\\<Squnion> C) = \\<Squnion> (esize ` C)\n 2. infinite C \\<Longrightarrow>\n    esize (\\<Squnion> C) = \\<Squnion> (esize ` C)", "have 2: \"(\\<Squnion> A \\<in> C. esize A) = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> (esize ` C) = \\<infinity>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. enat n \\<le> \\<Squnion> (esize ` C)", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. enat n \\<le> \\<Squnion> (esize ` C)", "obtain A where 1: \"A \\<in> C\" \"esize A \\<ge> enat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>A \\<in> C; enat n \\<le> esize A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1) False"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) C\n  infinite C\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>A \\<in> C; enat n \\<le> esize A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by rule"], ["proof (state)\nthis:\n  A \\<in> C\n  enat n \\<le> esize A\n\ngoal (1 subgoal):\n 1. \\<And>n. enat n \\<le> \\<Squnion> (esize ` C)", "show \"enat n \\<le> (\\<Squnion> A \\<in> C. esize A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat n \\<le> \\<Squnion> (esize ` C)", "using SUP_upper2 1"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i \\<in> ?A; ?u \\<le> ?f ?i\\<rbrakk>\n  \\<Longrightarrow> ?u \\<le> \\<Squnion> (?f ` ?A)\n  A \\<in> C\n  enat n \\<le> esize A\n\ngoal (1 subgoal):\n 1. enat n \\<le> \\<Squnion> (esize ` C)", "by this"], ["proof (state)\nthis:\n  enat n \\<le> \\<Squnion> (esize ` C)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Squnion> (esize ` C) = \\<infinity>\n\ngoal (2 subgoals):\n 1. finite C \\<Longrightarrow> esize (\\<Squnion> C) = \\<Squnion> (esize ` C)\n 2. infinite C \\<Longrightarrow>\n    esize (\\<Squnion> C) = \\<Squnion> (esize ` C)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. esize (\\<Squnion> C) = \\<Squnion> (esize ` C)", "using 1 2"], ["proof (prove)\nusing this:\n  esize (\\<Squnion> C) = \\<infinity>\n  \\<Squnion> (esize ` C) = \\<infinity>\n\ngoal (1 subgoal):\n 1. esize (\\<Squnion> C) = \\<Squnion> (esize ` C)", "by simp"], ["proof (state)\nthis:\n  esize (\\<Squnion> C) = \\<Squnion> (esize ` C)\n\ngoal (1 subgoal):\n 1. finite C \\<Longrightarrow> esize (\\<Squnion> C) = \\<Squnion> (esize ` C)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. finite C \\<Longrightarrow> esize (\\<Squnion> C) = \\<Squnion> (esize ` C)", "case True"], ["proof (state)\nthis:\n  finite C\n\ngoal (1 subgoal):\n 1. finite C \\<Longrightarrow> esize (\\<Squnion> C) = \\<Squnion> (esize ` C)", "have 1: \"esize (\\<Squnion> C) = (\\<Squnion> x \\<in> C. esize x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. esize (\\<Squnion> C) = \\<Squnion> (esize ` C)", "proof (intro order_class.antisym SUP_upper SUP_least esize_mono)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<Squnion> C \\<in> C\n 2. \\<And>x. x \\<in> C \\<Longrightarrow> x \\<le> \\<Squnion> C", "show \"\\<Squnion> C \\<in> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> C \\<in> C", "using in_chain_finite assms(1) True assms(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>Complete_Partial_Order.chain (\\<le>) ?A; finite ?A;\n   ?A \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<Squnion> ?A \\<in> ?A\n  Complete_Partial_Order.chain (\\<le>) C\n  finite C\n  C \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<Squnion> C \\<in> C", "by this"], ["proof (state)\nthis:\n  \\<Squnion> C \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> C \\<Longrightarrow> x \\<le> \\<Squnion> C", "show \"\\<And> x. x \\<in> C \\<Longrightarrow> x \\<le> \\<Squnion> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> C \\<Longrightarrow> x \\<le> \\<Squnion> C", "using ccpo_Sup_upper assms(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>Complete_Partial_Order.chain (\\<le>) ?A; ?x \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> \\<Squnion> ?A\n  Complete_Partial_Order.chain (\\<le>) C\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> C \\<Longrightarrow> x \\<le> \\<Squnion> C", "by this"], ["proof (state)\nthis:\n  ?x \\<in> C \\<Longrightarrow> ?x \\<le> \\<Squnion> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  esize (\\<Squnion> C) = \\<Squnion> (esize ` C)\n\ngoal (1 subgoal):\n 1. finite C \\<Longrightarrow> esize (\\<Squnion> C) = \\<Squnion> (esize ` C)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. esize (\\<Squnion> C) = \\<Squnion> (esize ` C)", "using 1"], ["proof (prove)\nusing this:\n  esize (\\<Squnion> C) = \\<Squnion> (esize ` C)\n\ngoal (1 subgoal):\n 1. esize (\\<Squnion> C) = \\<Squnion> (esize ` C)", "by simp"], ["proof (state)\nthis:\n  esize (\\<Squnion> C) = \\<Squnion> (esize ` C)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma esize_mcont: \"mcont Sup less_eq Sup less_eq esize\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont Sup (\\<le>) Sup (\\<le>) esize", "by (blast intro: mcontI monotoneI contI)"], ["", "lemmas mcont2mcont_esize = esize_mcont[THEN lfp.mcont2mcont, simp, cont_intro]"], ["", "end"], ["", "end"]]}