{"file_name": "/home/qj213/afp-2021-10-22/thys/Partial_Order_Reduction/Extensions/Basic_Extensions.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Partial_Order_Reduction", "problem_names": ["lemma IdI'[intro]:\n      assumes \"x = y\"\n      shows \"(x, y) \\<in> Id\"", "lemma (in order) order_le_cases:\n      assumes \"x \\<le> y\"\n      obtains (eq) \"x = y\" | (lt) \"x < y\"", "lemma (in linorder) linorder_cases':\n      obtains (le) \"x \\<le> y\" | (gt) \"x > y\"", "lemma monoI_comp[intro]:\n      assumes \"mono f\" \"mono g\"\n      shows \"mono (f \\<circ> g)\"", "lemma strict_monoI_comp[intro]:\n      assumes \"strict_mono f\" \"strict_mono g\"\n      shows \"strict_mono (f \\<circ> g)\"", "lemma eq_le_absorb[simp]:\n      fixes x y :: \"'a :: order\"\n      shows \"x = y \\<and> x \\<le> y \\<longleftrightarrow> x = y\" \"x \\<le> y \\<and> x = y \\<longleftrightarrow> x = y\"", "lemma INFM_Suc[simp]: \"(\\<exists>\\<^sub>\\<infinity> i. P (Suc i)) \\<longleftrightarrow> (\\<exists>\\<^sub>\\<infinity> i. P i)\"", "lemma INFM_plus[simp]: \"(\\<exists>\\<^sub>\\<infinity> i. P (i + n :: nat)) \\<longleftrightarrow> (\\<exists>\\<^sub>\\<infinity> i. P i)\"", "lemma INFM_minus[simp]: \"(\\<exists>\\<^sub>\\<infinity> i. P (i - n :: nat)) \\<longleftrightarrow> (\\<exists>\\<^sub>\\<infinity> i. P i)\"", "lemma const_apply[simp]: \"const x y = x\"", "lemma const2_apply[simp]: \"const2 x y z = x\"", "lemma const3_apply[simp]: \"const3 x y z u = x\"", "lemma const4_apply[simp]: \"const4 x y z u v = x\"", "lemma const5_apply[simp]: \"const5 x y z u v w = x\"", "lemma zip_fun_simps[simp]:\n      \"(f \\<parallel> g) x = (f x, g x)\"\n      \"fst \\<circ> (f \\<parallel> g) = f\"\n      \"snd \\<circ> (f \\<parallel> g) = g\"\n      \"fst \\<circ> h \\<parallel> snd \\<circ> h = h\"\n      \"fst ` range (f \\<parallel> g) = range f\"\n      \"snd ` range (f \\<parallel> g) = range g\"", "lemma zip_fun_eq[dest]:\n      assumes \"f \\<parallel> g = h \\<parallel> i\"\n      shows \"f = h\" \"g = i\"", "lemma zip_fun_range_subset[intro, simp]: \"range (f \\<parallel> g) \\<subseteq> range f \\<times> range g\"", "lemma zip_fun_range_finite[elim]:\n      assumes \"finite (range (f \\<parallel> g))\"\n      obtains \"finite (range f)\" \"finite (range g)\"", "lemma zip_fun_split:\n      obtains f g\n      where \"h = f \\<parallel> g\"", "lemma inj_Some2[simp, intro]:\n      \"inj None_Some\"\n      \"inj Some_None\"\n      \"inj Some_Some\"", "lemma inj_Some3[simp, intro]:\n      \"inj None_None_Some\"\n      \"inj None_Some_None\"\n      \"inj None_Some_Some\"\n      \"inj Some_None_None\"\n      \"inj Some_None_Some\"\n      \"inj Some_Some_None\"\n      \"inj Some_Some_Some\"", "lemma swap_simps[simp]: \"swap (a, b) = (b, a)\"", "lemma swap_inj[intro, simp]: \"inj swap\"", "lemma swap_surj[intro, simp]: \"surj swap\"", "lemma swap_bij[intro, simp]: \"bij swap\"", "lemma push_simps[simp]: \"push ((x, y), z) = (x, y, z)\"", "lemma pull_simps[simp]: \"pull (x, y, z) = ((x, y), z)\"", "lemma label_select[simp]: \"label (p, a, q) = a\"", "lemma curry_split[simp]: \"curry \\<circ> case_prod = id\"", "lemma split_curry[simp]: \"case_prod \\<circ> curry = id\"", "lemma curry_le[simp]: \"curry f \\<le> curry g \\<longleftrightarrow> f \\<le> g\"", "lemma split_le[simp]: \"case_prod f \\<le> case_prod g \\<longleftrightarrow> f \\<le> g\"", "lemma mono_curry_left[simp]: \"mono (curry \\<circ> h) \\<longleftrightarrow> mono h\"", "lemma mono_split_left[simp]: \"mono (case_prod \\<circ> h) \\<longleftrightarrow> mono h\"", "lemma mono_curry_right[simp]: \"mono (h \\<circ> curry) \\<longleftrightarrow> mono h\"", "lemma mono_split_right[simp]: \"mono (h \\<circ> case_prod) \\<longleftrightarrow> mono h\"", "lemma Collect_curry[simp]: \"{x. P (curry x)} = case_prod ` {x. P x}\"", "lemma Collect_split[simp]: \"{x. P (case_prod x)} = curry ` {x. P x}\"", "lemma gfp_split_curry[simp]: \"gfp (case_prod \\<circ> f \\<circ> curry) = case_prod (gfp f)\"", "lemma gfp_curry_split[simp]: \"gfp (curry \\<circ> f \\<circ> case_prod) = curry (gfp f)\"", "lemma not_someI:\n      assumes \"\\<And> x. P x \\<Longrightarrow> False\"\n      shows \"\\<not> P (SOME x. P x)\"", "lemma some_ccontr:\n      assumes \"(\\<And> x. \\<not> P x) \\<Longrightarrow> False\"\n      shows \"P (SOME x. P x)\""], "translations": [["", "lemma IdI'[intro]:\n      assumes \"x = y\"\n      shows \"(x, y) \\<in> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> Id", "using assms"], ["proof (prove)\nusing this:\n  x = y\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> Id", "by auto"], ["", "lemma (in order) order_le_cases:\n      assumes \"x \\<le> y\"\n      obtains (eq) \"x = y\" | (lt) \"x < y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = y \\<Longrightarrow> thesis;\n     x < y \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms le_less"], ["proof (prove)\nusing this:\n  x \\<le> y\n  (?x \\<le> ?y) = (?x < ?y \\<or> ?x = ?y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = y \\<Longrightarrow> thesis;\n     x < y \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["", "lemma (in linorder) linorder_cases':\n      obtains (le) \"x \\<le> y\" | (gt) \"x > y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y \\<Longrightarrow> thesis;\n     y < x \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by force"], ["", "lemma monoI_comp[intro]:\n      assumes \"mono f\" \"mono g\"\n      shows \"mono (f \\<circ> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (f \\<circ> g)", "using assms"], ["proof (prove)\nusing this:\n  mono f\n  mono g\n\ngoal (1 subgoal):\n 1. mono (f \\<circ> g)", "by (intro monoI, auto dest: monoD)"], ["", "lemma strict_monoI_comp[intro]:\n      assumes \"strict_mono f\" \"strict_mono g\"\n      shows \"strict_mono (f \\<circ> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_mono (f \\<circ> g)", "using assms"], ["proof (prove)\nusing this:\n  strict_mono f\n  strict_mono g\n\ngoal (1 subgoal):\n 1. strict_mono (f \\<circ> g)", "by (intro strict_monoI, auto dest: strict_monoD)"], ["", "lemma eq_le_absorb[simp]:\n      fixes x y :: \"'a :: order\"\n      shows \"x = y \\<and> x \\<le> y \\<longleftrightarrow> x = y\" \"x \\<le> y \\<and> x = y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = y \\<and> x \\<le> y) = (x = y) &&&\n    (x \\<le> y \\<and> x = y) = (x = y)", "by auto"], ["", "lemma INFM_Suc[simp]: \"(\\<exists>\\<^sub>\\<infinity> i. P (Suc i)) \\<longleftrightarrow> (\\<exists>\\<^sub>\\<infinity> i. P i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>\\<^sub>\\<infinity>i. P (Suc i)) =\n    (\\<exists>\\<^sub>\\<infinity>i. P i)", "unfolding INFM_nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>m. \\<exists>n>m. P (Suc n)) = (\\<forall>m. \\<exists>n>m. P n)", "using Suc_lessE less_Suc_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>Suc ?i < ?k;\n   \\<And>j.\n      \\<lbrakk>?i < j; ?k = Suc j\\<rbrakk> \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  (?m < Suc ?n) = (?m < ?n \\<or> ?m = ?n)\n\ngoal (1 subgoal):\n 1. (\\<forall>m. \\<exists>n>m. P (Suc n)) = (\\<forall>m. \\<exists>n>m. P n)", "by metis"], ["", "lemma INFM_plus[simp]: \"(\\<exists>\\<^sub>\\<infinity> i. P (i + n :: nat)) \\<longleftrightarrow> (\\<exists>\\<^sub>\\<infinity> i. P i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>\\<^sub>\\<infinity>i. P (i + n)) =\n    (\\<exists>\\<^sub>\\<infinity>i. P i)", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<exists>\\<^sub>\\<infinity>i. P (i + 0)) =\n    (\\<exists>\\<^sub>\\<infinity>i. P i)\n 2. \\<And>n.\n       (\\<exists>\\<^sub>\\<infinity>i. P (i + n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i) \\<Longrightarrow>\n       (\\<exists>\\<^sub>\\<infinity>i. P (i + Suc n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (\\<exists>\\<^sub>\\<infinity>i. P (i + 0)) =\n    (\\<exists>\\<^sub>\\<infinity>i. P i)\n 2. \\<And>n.\n       (\\<exists>\\<^sub>\\<infinity>i. P (i + n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i) \\<Longrightarrow>\n       (\\<exists>\\<^sub>\\<infinity>i. P (i + Suc n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>\\<^sub>\\<infinity>i. P (i + 0)) =\n    (\\<exists>\\<^sub>\\<infinity>i. P i)", "by simp"], ["proof (state)\nthis:\n  (\\<exists>\\<^sub>\\<infinity>i. P (i + 0)) =\n  (\\<exists>\\<^sub>\\<infinity>i. P i)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<exists>\\<^sub>\\<infinity>i. P (i + n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i) \\<Longrightarrow>\n       (\\<exists>\\<^sub>\\<infinity>i. P (i + Suc n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<exists>\\<^sub>\\<infinity>i. P (i + n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i) \\<Longrightarrow>\n       (\\<exists>\\<^sub>\\<infinity>i. P (i + Suc n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i)", "case (Suc n)"], ["proof (state)\nthis:\n  (\\<exists>\\<^sub>\\<infinity>i. P (i + n)) =\n  (\\<exists>\\<^sub>\\<infinity>i. P i)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<exists>\\<^sub>\\<infinity>i. P (i + n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i) \\<Longrightarrow>\n       (\\<exists>\\<^sub>\\<infinity>i. P (i + Suc n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i)", "have \"(\\<exists>\\<^sub>\\<infinity> i. P (i + Suc n)) \\<longleftrightarrow> (\\<exists>\\<^sub>\\<infinity> i. P (Suc i + n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>\\<^sub>\\<infinity>i. P (i + Suc n)) =\n    (\\<exists>\\<^sub>\\<infinity>i. P (Suc i + n))", "by simp"], ["proof (state)\nthis:\n  (\\<exists>\\<^sub>\\<infinity>i. P (i + Suc n)) =\n  (\\<exists>\\<^sub>\\<infinity>i. P (Suc i + n))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<exists>\\<^sub>\\<infinity>i. P (i + n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i) \\<Longrightarrow>\n       (\\<exists>\\<^sub>\\<infinity>i. P (i + Suc n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i)", "also"], ["proof (state)\nthis:\n  (\\<exists>\\<^sub>\\<infinity>i. P (i + Suc n)) =\n  (\\<exists>\\<^sub>\\<infinity>i. P (Suc i + n))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<exists>\\<^sub>\\<infinity>i. P (i + n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i) \\<Longrightarrow>\n       (\\<exists>\\<^sub>\\<infinity>i. P (i + Suc n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i)", "have \"\\<dots> \\<longleftrightarrow> (\\<exists>\\<^sub>\\<infinity> i. P (i + n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>\\<^sub>\\<infinity>i. P (Suc i + n)) =\n    (\\<exists>\\<^sub>\\<infinity>i. P (i + n))", "using INFM_Suc"], ["proof (prove)\nusing this:\n  (\\<exists>\\<^sub>\\<infinity>i. ?P (Suc i)) =\n  (\\<exists>\\<^sub>\\<infinity>i. ?P i)\n\ngoal (1 subgoal):\n 1. (\\<exists>\\<^sub>\\<infinity>i. P (Suc i + n)) =\n    (\\<exists>\\<^sub>\\<infinity>i. P (i + n))", "by this"], ["proof (state)\nthis:\n  (\\<exists>\\<^sub>\\<infinity>i. P (Suc i + n)) =\n  (\\<exists>\\<^sub>\\<infinity>i. P (i + n))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<exists>\\<^sub>\\<infinity>i. P (i + n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i) \\<Longrightarrow>\n       (\\<exists>\\<^sub>\\<infinity>i. P (i + Suc n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i)", "also"], ["proof (state)\nthis:\n  (\\<exists>\\<^sub>\\<infinity>i. P (Suc i + n)) =\n  (\\<exists>\\<^sub>\\<infinity>i. P (i + n))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<exists>\\<^sub>\\<infinity>i. P (i + n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i) \\<Longrightarrow>\n       (\\<exists>\\<^sub>\\<infinity>i. P (i + Suc n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i)", "have \"\\<dots> \\<longleftrightarrow> (\\<exists>\\<^sub>\\<infinity> i. P i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>\\<^sub>\\<infinity>i. P (i + n)) =\n    (\\<exists>\\<^sub>\\<infinity>i. P i)", "using Suc"], ["proof (prove)\nusing this:\n  (\\<exists>\\<^sub>\\<infinity>i. P (i + n)) =\n  (\\<exists>\\<^sub>\\<infinity>i. P i)\n\ngoal (1 subgoal):\n 1. (\\<exists>\\<^sub>\\<infinity>i. P (i + n)) =\n    (\\<exists>\\<^sub>\\<infinity>i. P i)", "by this"], ["proof (state)\nthis:\n  (\\<exists>\\<^sub>\\<infinity>i. P (i + n)) =\n  (\\<exists>\\<^sub>\\<infinity>i. P i)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<exists>\\<^sub>\\<infinity>i. P (i + n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i) \\<Longrightarrow>\n       (\\<exists>\\<^sub>\\<infinity>i. P (i + Suc n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i)", "finally"], ["proof (chain)\npicking this:\n  (\\<exists>\\<^sub>\\<infinity>i. P (i + Suc n)) =\n  (\\<exists>\\<^sub>\\<infinity>i. P i)", "show ?case"], ["proof (prove)\nusing this:\n  (\\<exists>\\<^sub>\\<infinity>i. P (i + Suc n)) =\n  (\\<exists>\\<^sub>\\<infinity>i. P i)\n\ngoal (1 subgoal):\n 1. (\\<exists>\\<^sub>\\<infinity>i. P (i + Suc n)) =\n    (\\<exists>\\<^sub>\\<infinity>i. P i)", "by this"], ["proof (state)\nthis:\n  (\\<exists>\\<^sub>\\<infinity>i. P (i + Suc n)) =\n  (\\<exists>\\<^sub>\\<infinity>i. P i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma INFM_minus[simp]: \"(\\<exists>\\<^sub>\\<infinity> i. P (i - n :: nat)) \\<longleftrightarrow> (\\<exists>\\<^sub>\\<infinity> i. P i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>\\<^sub>\\<infinity>i. P (i - n)) =\n    (\\<exists>\\<^sub>\\<infinity>i. P i)", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<exists>\\<^sub>\\<infinity>i. P (i - 0)) =\n    (\\<exists>\\<^sub>\\<infinity>i. P i)\n 2. \\<And>n.\n       (\\<exists>\\<^sub>\\<infinity>i. P (i - n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i) \\<Longrightarrow>\n       (\\<exists>\\<^sub>\\<infinity>i. P (i - Suc n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (\\<exists>\\<^sub>\\<infinity>i. P (i - 0)) =\n    (\\<exists>\\<^sub>\\<infinity>i. P i)\n 2. \\<And>n.\n       (\\<exists>\\<^sub>\\<infinity>i. P (i - n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i) \\<Longrightarrow>\n       (\\<exists>\\<^sub>\\<infinity>i. P (i - Suc n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>\\<^sub>\\<infinity>i. P (i - 0)) =\n    (\\<exists>\\<^sub>\\<infinity>i. P i)", "by simp"], ["proof (state)\nthis:\n  (\\<exists>\\<^sub>\\<infinity>i. P (i - 0)) =\n  (\\<exists>\\<^sub>\\<infinity>i. P i)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<exists>\\<^sub>\\<infinity>i. P (i - n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i) \\<Longrightarrow>\n       (\\<exists>\\<^sub>\\<infinity>i. P (i - Suc n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<exists>\\<^sub>\\<infinity>i. P (i - n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i) \\<Longrightarrow>\n       (\\<exists>\\<^sub>\\<infinity>i. P (i - Suc n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i)", "case (Suc n)"], ["proof (state)\nthis:\n  (\\<exists>\\<^sub>\\<infinity>i. P (i - n)) =\n  (\\<exists>\\<^sub>\\<infinity>i. P i)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<exists>\\<^sub>\\<infinity>i. P (i - n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i) \\<Longrightarrow>\n       (\\<exists>\\<^sub>\\<infinity>i. P (i - Suc n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i)", "have \"(\\<exists>\\<^sub>\\<infinity> i. P (i - Suc n)) \\<longleftrightarrow> (\\<exists>\\<^sub>\\<infinity> i. P (Suc i - Suc n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>\\<^sub>\\<infinity>i. P (i - Suc n)) =\n    (\\<exists>\\<^sub>\\<infinity>i. P (Suc i - Suc n))", "using INFM_Suc"], ["proof (prove)\nusing this:\n  (\\<exists>\\<^sub>\\<infinity>i. ?P (Suc i)) =\n  (\\<exists>\\<^sub>\\<infinity>i. ?P i)\n\ngoal (1 subgoal):\n 1. (\\<exists>\\<^sub>\\<infinity>i. P (i - Suc n)) =\n    (\\<exists>\\<^sub>\\<infinity>i. P (Suc i - Suc n))", "by meson"], ["proof (state)\nthis:\n  (\\<exists>\\<^sub>\\<infinity>i. P (i - Suc n)) =\n  (\\<exists>\\<^sub>\\<infinity>i. P (Suc i - Suc n))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<exists>\\<^sub>\\<infinity>i. P (i - n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i) \\<Longrightarrow>\n       (\\<exists>\\<^sub>\\<infinity>i. P (i - Suc n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i)", "also"], ["proof (state)\nthis:\n  (\\<exists>\\<^sub>\\<infinity>i. P (i - Suc n)) =\n  (\\<exists>\\<^sub>\\<infinity>i. P (Suc i - Suc n))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<exists>\\<^sub>\\<infinity>i. P (i - n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i) \\<Longrightarrow>\n       (\\<exists>\\<^sub>\\<infinity>i. P (i - Suc n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i)", "have \"\\<dots> \\<longleftrightarrow> (\\<exists>\\<^sub>\\<infinity> i. P (i - n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>\\<^sub>\\<infinity>i. P (Suc i - Suc n)) =\n    (\\<exists>\\<^sub>\\<infinity>i. P (i - n))", "by simp"], ["proof (state)\nthis:\n  (\\<exists>\\<^sub>\\<infinity>i. P (Suc i - Suc n)) =\n  (\\<exists>\\<^sub>\\<infinity>i. P (i - n))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<exists>\\<^sub>\\<infinity>i. P (i - n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i) \\<Longrightarrow>\n       (\\<exists>\\<^sub>\\<infinity>i. P (i - Suc n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i)", "also"], ["proof (state)\nthis:\n  (\\<exists>\\<^sub>\\<infinity>i. P (Suc i - Suc n)) =\n  (\\<exists>\\<^sub>\\<infinity>i. P (i - n))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<exists>\\<^sub>\\<infinity>i. P (i - n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i) \\<Longrightarrow>\n       (\\<exists>\\<^sub>\\<infinity>i. P (i - Suc n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i)", "have \"\\<dots> \\<longleftrightarrow> (\\<exists>\\<^sub>\\<infinity> i. P i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>\\<^sub>\\<infinity>i. P (i - n)) =\n    (\\<exists>\\<^sub>\\<infinity>i. P i)", "using Suc"], ["proof (prove)\nusing this:\n  (\\<exists>\\<^sub>\\<infinity>i. P (i - n)) =\n  (\\<exists>\\<^sub>\\<infinity>i. P i)\n\ngoal (1 subgoal):\n 1. (\\<exists>\\<^sub>\\<infinity>i. P (i - n)) =\n    (\\<exists>\\<^sub>\\<infinity>i. P i)", "by this"], ["proof (state)\nthis:\n  (\\<exists>\\<^sub>\\<infinity>i. P (i - n)) =\n  (\\<exists>\\<^sub>\\<infinity>i. P i)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<exists>\\<^sub>\\<infinity>i. P (i - n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i) \\<Longrightarrow>\n       (\\<exists>\\<^sub>\\<infinity>i. P (i - Suc n)) =\n       (\\<exists>\\<^sub>\\<infinity>i. P i)", "finally"], ["proof (chain)\npicking this:\n  (\\<exists>\\<^sub>\\<infinity>i. P (i - Suc n)) =\n  (\\<exists>\\<^sub>\\<infinity>i. P i)", "show ?case"], ["proof (prove)\nusing this:\n  (\\<exists>\\<^sub>\\<infinity>i. P (i - Suc n)) =\n  (\\<exists>\\<^sub>\\<infinity>i. P i)\n\ngoal (1 subgoal):\n 1. (\\<exists>\\<^sub>\\<infinity>i. P (i - Suc n)) =\n    (\\<exists>\\<^sub>\\<infinity>i. P i)", "by this"], ["proof (state)\nthis:\n  (\\<exists>\\<^sub>\\<infinity>i. P (i - Suc n)) =\n  (\\<exists>\\<^sub>\\<infinity>i. P i)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Constants\\<close>"], ["", "definition const :: \"'a \\<Rightarrow> 'b \\<Rightarrow> 'a\"\n      where \"const x \\<equiv> \\<lambda> _. x\""], ["", "definition const2 :: \"'a \\<Rightarrow> 'b \\<Rightarrow> 'c \\<Rightarrow> 'a\"\n      where \"const2 x \\<equiv> \\<lambda> _ _. x\""], ["", "definition const3 :: \"'a \\<Rightarrow> 'b \\<Rightarrow> 'c \\<Rightarrow> 'd \\<Rightarrow> 'a\"\n      where \"const3 x \\<equiv> \\<lambda> _ _ _. x\""], ["", "definition const4 :: \"'a \\<Rightarrow> 'b \\<Rightarrow> 'c \\<Rightarrow> 'd \\<Rightarrow> 'e \\<Rightarrow> 'a\"\n      where \"const4 x \\<equiv> \\<lambda> _ _ _ _. x\""], ["", "definition const5 :: \"'a \\<Rightarrow> 'b \\<Rightarrow> 'c \\<Rightarrow> 'd \\<Rightarrow> 'e \\<Rightarrow> 'f \\<Rightarrow> 'a\"\n      where \"const5 x \\<equiv> \\<lambda> _ _ _ _ _. x\""], ["", "lemma const_apply[simp]: \"const x y = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const x y = x", "unfolding const_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = x", "by rule"], ["", "lemma const2_apply[simp]: \"const2 x y z = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const2 x y z = x", "unfolding const2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = x", "by rule"], ["", "lemma const3_apply[simp]: \"const3 x y z u = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const3 x y z u = x", "unfolding const3_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = x", "by rule"], ["", "lemma const4_apply[simp]: \"const4 x y z u v = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const4 x y z u v = x", "unfolding const4_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = x", "by rule"], ["", "lemma const5_apply[simp]: \"const5 x y z u v w = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const5 x y z u v w = x", "unfolding const5_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = x", "by rule"], ["", "definition zip_fun :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> ('a \\<Rightarrow> 'c) \\<Rightarrow> 'a \\<Rightarrow> 'b \\<times> 'c\" (infixr \"\\<parallel>\" 51)\n      where \"f \\<parallel> g \\<equiv> \\<lambda> x. (f x, g x)\""], ["", "lemma zip_fun_simps[simp]:\n      \"(f \\<parallel> g) x = (f x, g x)\"\n      \"fst \\<circ> (f \\<parallel> g) = f\"\n      \"snd \\<circ> (f \\<parallel> g) = g\"\n      \"fst \\<circ> h \\<parallel> snd \\<circ> h = h\"\n      \"fst ` range (f \\<parallel> g) = range f\"\n      \"snd ` range (f \\<parallel> g) = range g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((f \\<parallel> g) x = (f x, g x) &&&\n     fst \\<circ> (f \\<parallel> g) = f &&&\n     snd \\<circ> (f \\<parallel> g) = g) &&&\n    fst \\<circ> h \\<parallel> snd \\<circ> h = h &&&\n    fst ` range (f \\<parallel> g) = range f &&&\n    snd ` range (f \\<parallel> g) = range g", "unfolding zip_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((f x, g x) = (f x, g x) &&&\n     fst \\<circ> (\\<lambda>x. (f x, g x)) = f &&&\n     snd \\<circ> (\\<lambda>x. (f x, g x)) = g) &&&\n    (\\<lambda>x. ((fst \\<circ> h) x, (snd \\<circ> h) x)) = h &&&\n    fst ` range (\\<lambda>x. (f x, g x)) = range f &&&\n    snd ` range (\\<lambda>x. (f x, g x)) = range g", "by force+"], ["", "lemma zip_fun_eq[dest]:\n      assumes \"f \\<parallel> g = h \\<parallel> i\"\n      shows \"f = h\" \"g = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = h &&& g = i", "using assms"], ["proof (prove)\nusing this:\n  f \\<parallel> g = h \\<parallel> i\n\ngoal (1 subgoal):\n 1. f = h &&& g = i", "unfolding zip_fun_def"], ["proof (prove)\nusing this:\n  (\\<lambda>x. (f x, g x)) = (\\<lambda>x. (h x, i x))\n\ngoal (1 subgoal):\n 1. f = h &&& g = i", "by (auto dest: fun_cong)"], ["", "lemma zip_fun_range_subset[intro, simp]: \"range (f \\<parallel> g) \\<subseteq> range f \\<times> range g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (f \\<parallel> g) \\<subseteq> range f \\<times> range g", "unfolding zip_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. range (\\<lambda>x. (f x, g x)) \\<subseteq> range f \\<times> range g", "by blast"], ["", "lemma zip_fun_range_finite[elim]:\n      assumes \"finite (range (f \\<parallel> g))\"\n      obtains \"finite (range f)\" \"finite (range g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>finite (range f); finite (range g)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<lbrakk>finite (range f); finite (range g)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    finite (range f)\n 2. (\\<lbrakk>finite (range f); finite (range g)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    finite (range g)", "show \"finite (range f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (range f)", "using finite_imageI [OF assms(1), of fst]"], ["proof (prove)\nusing this:\n  finite (fst ` range (f \\<parallel> g))\n\ngoal (1 subgoal):\n 1. finite (range f)", "by (simp add: image_image)"], ["proof (state)\nthis:\n  finite (range f)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>finite (range f); finite (range g)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    finite (range g)", "show \"finite (range g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (range g)", "using finite_imageI [OF assms(1), of snd]"], ["proof (prove)\nusing this:\n  finite (snd ` range (f \\<parallel> g))\n\ngoal (1 subgoal):\n 1. finite (range g)", "by (simp add: image_image)"], ["proof (state)\nthis:\n  finite (range g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zip_fun_split:\n      obtains f g\n      where \"h = f \\<parallel> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        h = f \\<parallel> g \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        h = f \\<parallel> g \\<Longrightarrow> thesis) \\<Longrightarrow>\n    h = ?f2 \\<parallel> ?g2", "show \"h = fst \\<circ> h \\<parallel> snd \\<circ> h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h = fst \\<circ> h \\<parallel> snd \\<circ> h", "by simp"], ["proof (state)\nthis:\n  h = fst \\<circ> h \\<parallel> snd \\<circ> h\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation \"None_None \\<equiv> (None, None)\""], ["", "abbreviation \"None_Some \\<equiv> \\<lambda> (y). (None, Some y)\""], ["", "abbreviation \"Some_None \\<equiv> \\<lambda> (x). (Some x, None)\""], ["", "abbreviation \"Some_Some \\<equiv> \\<lambda> (x, y). (Some x, Some y)\""], ["", "abbreviation \"None_None_None \\<equiv> (None, None, None)\""], ["", "abbreviation \"None_None_Some \\<equiv> \\<lambda> (z). (None, None, Some z)\""], ["", "abbreviation \"None_Some_None \\<equiv> \\<lambda> (y). (None, Some y, None)\""], ["", "abbreviation \"None_Some_Some \\<equiv> \\<lambda> (y, z). (None, Some y, Some z)\""], ["", "abbreviation \"Some_None_None \\<equiv> \\<lambda> (x). (Some x, None, None)\""], ["", "abbreviation \"Some_None_Some \\<equiv> \\<lambda> (x, z). (Some x, None, Some z)\""], ["", "abbreviation \"Some_Some_None \\<equiv> \\<lambda> (x, y). (Some x, Some y, None)\""], ["", "abbreviation \"Some_Some_Some \\<equiv> \\<lambda> (x, y, z). (Some x, Some y, Some z)\""], ["", "lemma inj_Some2[simp, intro]:\n      \"inj None_Some\"\n      \"inj Some_None\"\n      \"inj Some_Some\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj None_Some &&& inj Some_None &&& inj Some_Some", "by (rule injI, force)+"], ["", "lemma inj_Some3[simp, intro]:\n      \"inj None_None_Some\"\n      \"inj None_Some_None\"\n      \"inj None_Some_Some\"\n      \"inj Some_None_None\"\n      \"inj Some_None_Some\"\n      \"inj Some_Some_None\"\n      \"inj Some_Some_Some\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (inj None_None_Some &&& inj None_Some_None &&& inj None_Some_Some) &&&\n    (inj Some_None_None &&& inj Some_None_Some) &&&\n    inj Some_Some_None &&& inj Some_Some_Some", "by (rule injI, force)+"], ["", "definition swap :: \"'a \\<times> 'b \\<Rightarrow> 'b \\<times> 'a\"\n      where \"swap x \\<equiv> (snd x, fst x)\""], ["", "lemma swap_simps[simp]: \"swap (a, b) = (b, a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swap (a, b) = (b, a)", "unfolding swap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (snd (a, b), fst (a, b)) = (b, a)", "by simp"], ["", "lemma swap_inj[intro, simp]: \"inj swap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj swap", "by (rule injI, auto)"], ["", "lemma swap_surj[intro, simp]: \"surj swap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surj swap", "by (rule surjI[where ?f = swap], auto)"], ["", "lemma swap_bij[intro, simp]: \"bij swap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij swap", "by (rule bijI, auto)"], ["", "definition push :: \"('a \\<times> 'b) \\<times> 'c \\<Rightarrow> 'a \\<times> 'b \\<times> 'c\"\n      where \"push x \\<equiv> (fst (fst x), snd (fst x), snd x)\""], ["", "definition pull :: \"'a \\<times> 'b \\<times> 'c \\<Rightarrow> ('a \\<times> 'b) \\<times> 'c\"\n      where \"pull x \\<equiv> ((fst x, fst (snd x)), snd (snd x))\""], ["", "lemma push_simps[simp]: \"push ((x, y), z) = (x, y, z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. push ((x, y), z) = (x, y, z)", "unfolding push_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst (fst ((x, y), z)), snd (fst ((x, y), z)), snd ((x, y), z)) =\n    (x, y, z)", "by simp"], ["", "lemma pull_simps[simp]: \"pull (x, y, z) = ((x, y), z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pull (x, y, z) = ((x, y), z)", "unfolding pull_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((fst (x, y, z), fst (snd (x, y, z))), snd (snd (x, y, z))) =\n    ((x, y), z)", "by simp"], ["", "definition label :: \"'vertex \\<times> 'label \\<times> 'vertex \\<Rightarrow> 'label\"\n      where \"label \\<equiv> fst \\<circ> snd\""], ["", "lemma label_select[simp]: \"label (p, a, q) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. label (p, a, q) = a", "unfolding label_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst \\<circ> snd) (p, a, q) = a", "by simp"], ["", "subsection \\<open>Theorems for @term{curry} and @term{split}\\<close>"], ["", "lemma curry_split[simp]: \"curry \\<circ> case_prod = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. curry \\<circ> case_prod = id", "by auto"], ["", "lemma split_curry[simp]: \"case_prod \\<circ> curry = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case_prod \\<circ> curry = id", "by auto"], ["", "lemma curry_le[simp]: \"curry f \\<le> curry g \\<longleftrightarrow> f \\<le> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (curry f \\<le> curry g) = (f \\<le> g)", "unfolding le_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x xa. curry f x xa \\<le> curry g x xa) =\n    (\\<forall>x. f x \\<le> g x)", "by force"], ["", "lemma split_le[simp]: \"case_prod f \\<le> case_prod g \\<longleftrightarrow> f \\<le> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>(x, y). f x y) \\<le> (\\<lambda>(x, y). g x y)) = (f \\<le> g)", "unfolding le_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x.\n        (case x of (x, xa) \\<Rightarrow> f x xa)\n        \\<le> (case x of (x, xa) \\<Rightarrow> g x xa)) =\n    (\\<forall>x xa. f x xa \\<le> g x xa)", "by force"], ["", "lemma mono_curry_left[simp]: \"mono (curry \\<circ> h) \\<longleftrightarrow> mono h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (curry \\<circ> h) = mono h", "unfolding mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x y.\n        x \\<le> y \\<longrightarrow>\n        (curry \\<circ> h) x \\<le> (curry \\<circ> h) y) =\n    (\\<forall>x y. x \\<le> y \\<longrightarrow> h x \\<le> h y)", "by fastforce"], ["", "lemma mono_split_left[simp]: \"mono (case_prod \\<circ> h) \\<longleftrightarrow> mono h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (case_prod \\<circ> h) = mono h", "unfolding mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x y.\n        x \\<le> y \\<longrightarrow>\n        (case_prod \\<circ> h) x \\<le> (case_prod \\<circ> h) y) =\n    (\\<forall>x y. x \\<le> y \\<longrightarrow> h x \\<le> h y)", "by fastforce"], ["", "lemma mono_curry_right[simp]: \"mono (h \\<circ> curry) \\<longleftrightarrow> mono h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (h \\<circ> curry) = mono h", "unfolding mono_def split_le[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x y.\n        x \\<le> y \\<longrightarrow>\n        (h \\<circ> curry) x \\<le> (h \\<circ> curry) y) =\n    (\\<forall>x y.\n        (\\<lambda>(xa, y). x xa y)\n        \\<le> (\\<lambda>(x, ya). y x ya) \\<longrightarrow>\n        h x \\<le> h y)", "by bestsimp"], ["", "lemma mono_split_right[simp]: \"mono (h \\<circ> case_prod) \\<longleftrightarrow> mono h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (h \\<circ> case_prod) = mono h", "unfolding mono_def curry_le[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x y.\n        x \\<le> y \\<longrightarrow>\n        (h \\<circ> case_prod) x \\<le> (h \\<circ> case_prod) y) =\n    (\\<forall>x y. curry x \\<le> curry y \\<longrightarrow> h x \\<le> h y)", "by bestsimp"], ["", "lemma Collect_curry[simp]: \"{x. P (curry x)} = case_prod ` {x. P x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. P (curry x)} = case_prod ` {x. P x}", "using image_Collect"], ["proof (prove)\nusing this:\n  ?f ` {x. ?P x} = {?f x |x. ?P x}\n\ngoal (1 subgoal):\n 1. {x. P (curry x)} = case_prod ` {x. P x}", "by fastforce"], ["", "lemma Collect_split[simp]: \"{x. P (case_prod x)} = curry ` {x. P x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. P (\\<lambda>(xa, y). x xa y)} = curry ` {x. P x}", "using image_Collect"], ["proof (prove)\nusing this:\n  ?f ` {x. ?P x} = {?f x |x. ?P x}\n\ngoal (1 subgoal):\n 1. {x. P (\\<lambda>(xa, y). x xa y)} = curry ` {x. P x}", "by force"], ["", "lemma gfp_split_curry[simp]: \"gfp (case_prod \\<circ> f \\<circ> curry) = case_prod (gfp f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gfp (case_prod \\<circ> f \\<circ> curry) = (\\<lambda>(x, y). gfp f x y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gfp (case_prod \\<circ> f \\<circ> curry) = (\\<lambda>(x, y). gfp f x y)", "have \"gfp (case_prod \\<circ> f \\<circ> curry) = Sup {u. u \\<le> case_prod (f (curry u))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gfp (case_prod \\<circ> f \\<circ> curry) =\n    Sup {u. u \\<le> (\\<lambda>(x, y). f (curry u) x y)}", "unfolding gfp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup {u. u \\<le> (case_prod \\<circ> f \\<circ> curry) u} =\n    Sup {u. u \\<le> (\\<lambda>(x, y). f (curry u) x y)}", "by simp"], ["proof (state)\nthis:\n  gfp (case_prod \\<circ> f \\<circ> curry) =\n  Sup {u. u \\<le> (\\<lambda>(x, y). f (curry u) x y)}\n\ngoal (1 subgoal):\n 1. gfp (case_prod \\<circ> f \\<circ> curry) = (\\<lambda>(x, y). gfp f x y)", "also"], ["proof (state)\nthis:\n  gfp (case_prod \\<circ> f \\<circ> curry) =\n  Sup {u. u \\<le> (\\<lambda>(x, y). f (curry u) x y)}\n\ngoal (1 subgoal):\n 1. gfp (case_prod \\<circ> f \\<circ> curry) = (\\<lambda>(x, y). gfp f x y)", "have \"\\<dots> = Sup {u. curry u \\<le> curry (case_prod (f (curry u)))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup {u. u \\<le> (\\<lambda>(x, y). f (curry u) x y)} =\n    Sup {u. curry u \\<le> curry (\\<lambda>(x, y). f (curry u) x y)}", "unfolding curry_le"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup {u. u \\<le> (\\<lambda>(x, y). f (curry u) x y)} =\n    Sup {u. u \\<le> (\\<lambda>(x, y). f (curry u) x y)}", "by simp"], ["proof (state)\nthis:\n  Sup {u. u \\<le> (\\<lambda>(x, y). f (curry u) x y)} =\n  Sup {u. curry u \\<le> curry (\\<lambda>(x, y). f (curry u) x y)}\n\ngoal (1 subgoal):\n 1. gfp (case_prod \\<circ> f \\<circ> curry) = (\\<lambda>(x, y). gfp f x y)", "also"], ["proof (state)\nthis:\n  Sup {u. u \\<le> (\\<lambda>(x, y). f (curry u) x y)} =\n  Sup {u. curry u \\<le> curry (\\<lambda>(x, y). f (curry u) x y)}\n\ngoal (1 subgoal):\n 1. gfp (case_prod \\<circ> f \\<circ> curry) = (\\<lambda>(x, y). gfp f x y)", "have \"\\<dots> = Sup {u. curry u \\<le> f (curry u)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup {u. curry u \\<le> curry (\\<lambda>(x, y). f (curry u) x y)} =\n    Sup {u. curry u \\<le> f (curry u)}", "by simp"], ["proof (state)\nthis:\n  Sup {u. curry u \\<le> curry (\\<lambda>(x, y). f (curry u) x y)} =\n  Sup {u. curry u \\<le> f (curry u)}\n\ngoal (1 subgoal):\n 1. gfp (case_prod \\<circ> f \\<circ> curry) = (\\<lambda>(x, y). gfp f x y)", "also"], ["proof (state)\nthis:\n  Sup {u. curry u \\<le> curry (\\<lambda>(x, y). f (curry u) x y)} =\n  Sup {u. curry u \\<le> f (curry u)}\n\ngoal (1 subgoal):\n 1. gfp (case_prod \\<circ> f \\<circ> curry) = (\\<lambda>(x, y). gfp f x y)", "have \"\\<dots> = Sup (case_prod ` {u. u \\<le> f u})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup {u. curry u \\<le> f (curry u)} = Sup (case_prod ` {u. u \\<le> f u})", "unfolding Collect_curry[of \"\\<lambda> u. u \\<le> f u\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup (case_prod ` {u. u \\<le> f u}) = Sup (case_prod ` {u. u \\<le> f u})", "by simp"], ["proof (state)\nthis:\n  Sup {u. curry u \\<le> f (curry u)} = Sup (case_prod ` {u. u \\<le> f u})\n\ngoal (1 subgoal):\n 1. gfp (case_prod \\<circ> f \\<circ> curry) = (\\<lambda>(x, y). gfp f x y)", "also"], ["proof (state)\nthis:\n  Sup {u. curry u \\<le> f (curry u)} = Sup (case_prod ` {u. u \\<le> f u})\n\ngoal (1 subgoal):\n 1. gfp (case_prod \\<circ> f \\<circ> curry) = (\\<lambda>(x, y). gfp f x y)", "have \"\\<dots> = case_prod (Sup {u. u \\<le> f u})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup (case_prod ` {u. u \\<le> f u}) =\n    (\\<lambda>(x, y). Sup {u. u \\<le> f u} x y)", "by (force simp add: image_comp)"], ["proof (state)\nthis:\n  Sup (case_prod ` {u. u \\<le> f u}) =\n  (\\<lambda>(x, y). Sup {u. u \\<le> f u} x y)\n\ngoal (1 subgoal):\n 1. gfp (case_prod \\<circ> f \\<circ> curry) = (\\<lambda>(x, y). gfp f x y)", "also"], ["proof (state)\nthis:\n  Sup (case_prod ` {u. u \\<le> f u}) =\n  (\\<lambda>(x, y). Sup {u. u \\<le> f u} x y)\n\ngoal (1 subgoal):\n 1. gfp (case_prod \\<circ> f \\<circ> curry) = (\\<lambda>(x, y). gfp f x y)", "have \"\\<dots> = case_prod (gfp f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). Sup {u. u \\<le> f u} x y) =\n    (\\<lambda>(x, y). gfp f x y)", "unfolding gfp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). Sup {u. u \\<le> f u} x y) =\n    (\\<lambda>(x, y). Sup {u. u \\<le> f u} x y)", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>(x, y). Sup {u. u \\<le> f u} x y) = (\\<lambda>(x, y). gfp f x y)\n\ngoal (1 subgoal):\n 1. gfp (case_prod \\<circ> f \\<circ> curry) = (\\<lambda>(x, y). gfp f x y)", "finally"], ["proof (chain)\npicking this:\n  gfp (case_prod \\<circ> f \\<circ> curry) = (\\<lambda>(x, y). gfp f x y)", "show ?thesis"], ["proof (prove)\nusing this:\n  gfp (case_prod \\<circ> f \\<circ> curry) = (\\<lambda>(x, y). gfp f x y)\n\ngoal (1 subgoal):\n 1. gfp (case_prod \\<circ> f \\<circ> curry) = (\\<lambda>(x, y). gfp f x y)", "by this"], ["proof (state)\nthis:\n  gfp (case_prod \\<circ> f \\<circ> curry) = (\\<lambda>(x, y). gfp f x y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gfp_curry_split[simp]: \"gfp (curry \\<circ> f \\<circ> case_prod) = curry (gfp f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gfp (curry \\<circ> f \\<circ> case_prod) = curry (gfp f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gfp (curry \\<circ> f \\<circ> case_prod) = curry (gfp f)", "have \"gfp (curry \\<circ> f \\<circ> case_prod) = Sup {u. u \\<le> curry (f (case_prod u))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gfp (curry \\<circ> f \\<circ> case_prod) =\n    Sup {u. u \\<le> curry (f (\\<lambda>(x, y). u x y))}", "unfolding gfp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup {u. u \\<le> (curry \\<circ> f \\<circ> case_prod) u} =\n    Sup {u. u \\<le> curry (f (\\<lambda>(x, y). u x y))}", "by simp"], ["proof (state)\nthis:\n  gfp (curry \\<circ> f \\<circ> case_prod) =\n  Sup {u. u \\<le> curry (f (\\<lambda>(x, y). u x y))}\n\ngoal (1 subgoal):\n 1. gfp (curry \\<circ> f \\<circ> case_prod) = curry (gfp f)", "also"], ["proof (state)\nthis:\n  gfp (curry \\<circ> f \\<circ> case_prod) =\n  Sup {u. u \\<le> curry (f (\\<lambda>(x, y). u x y))}\n\ngoal (1 subgoal):\n 1. gfp (curry \\<circ> f \\<circ> case_prod) = curry (gfp f)", "have \"\\<dots> = Sup {u. case_prod u \\<le> case_prod (curry (f (case_prod u)))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup {u. u \\<le> curry (f (\\<lambda>(x, y). u x y))} =\n    Sup {u. (\\<lambda>(x, y). u x y)\n            \\<le> (\\<lambda>(x, y). curry (f (\\<lambda>(x, y). u x y)) x y)}", "unfolding split_le"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup {u. u \\<le> curry (f (\\<lambda>(x, y). u x y))} =\n    Sup {u. u \\<le> curry (f (\\<lambda>(x, y). u x y))}", "by simp"], ["proof (state)\nthis:\n  Sup {u. u \\<le> curry (f (\\<lambda>(x, y). u x y))} =\n  Sup {u. (\\<lambda>(x, y). u x y)\n          \\<le> (\\<lambda>(x, y). curry (f (\\<lambda>(x, y). u x y)) x y)}\n\ngoal (1 subgoal):\n 1. gfp (curry \\<circ> f \\<circ> case_prod) = curry (gfp f)", "also"], ["proof (state)\nthis:\n  Sup {u. u \\<le> curry (f (\\<lambda>(x, y). u x y))} =\n  Sup {u. (\\<lambda>(x, y). u x y)\n          \\<le> (\\<lambda>(x, y). curry (f (\\<lambda>(x, y). u x y)) x y)}\n\ngoal (1 subgoal):\n 1. gfp (curry \\<circ> f \\<circ> case_prod) = curry (gfp f)", "have \"\\<dots> = Sup {u. case_prod u \\<le> f (case_prod u)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup {u. (\\<lambda>(x, y). u x y)\n            \\<le> (\\<lambda>(x, y).\n                      curry (f (\\<lambda>(x, y). u x y)) x y)} =\n    Sup {u. (\\<lambda>(x, y). u x y) \\<le> f (\\<lambda>(x, y). u x y)}", "by simp"], ["proof (state)\nthis:\n  Sup {u. (\\<lambda>(x, y). u x y)\n          \\<le> (\\<lambda>(x, y). curry (f (\\<lambda>(x, y). u x y)) x y)} =\n  Sup {u. (\\<lambda>(x, y). u x y) \\<le> f (\\<lambda>(x, y). u x y)}\n\ngoal (1 subgoal):\n 1. gfp (curry \\<circ> f \\<circ> case_prod) = curry (gfp f)", "also"], ["proof (state)\nthis:\n  Sup {u. (\\<lambda>(x, y). u x y)\n          \\<le> (\\<lambda>(x, y). curry (f (\\<lambda>(x, y). u x y)) x y)} =\n  Sup {u. (\\<lambda>(x, y). u x y) \\<le> f (\\<lambda>(x, y). u x y)}\n\ngoal (1 subgoal):\n 1. gfp (curry \\<circ> f \\<circ> case_prod) = curry (gfp f)", "have \"\\<dots> = Sup (curry ` {u. u \\<le> f u})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup {u. (\\<lambda>(x, y). u x y) \\<le> f (\\<lambda>(x, y). u x y)} =\n    Sup (curry ` {u. u \\<le> f u})", "unfolding Collect_split[of \"\\<lambda> u. u \\<le> f u\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup (curry ` {u. u \\<le> f u}) = Sup (curry ` {u. u \\<le> f u})", "by simp"], ["proof (state)\nthis:\n  Sup {u. (\\<lambda>(x, y). u x y) \\<le> f (\\<lambda>(x, y). u x y)} =\n  Sup (curry ` {u. u \\<le> f u})\n\ngoal (1 subgoal):\n 1. gfp (curry \\<circ> f \\<circ> case_prod) = curry (gfp f)", "also"], ["proof (state)\nthis:\n  Sup {u. (\\<lambda>(x, y). u x y) \\<le> f (\\<lambda>(x, y). u x y)} =\n  Sup (curry ` {u. u \\<le> f u})\n\ngoal (1 subgoal):\n 1. gfp (curry \\<circ> f \\<circ> case_prod) = curry (gfp f)", "have \"\\<dots> = curry (Sup {u. u \\<le> f u})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup (curry ` {u. u \\<le> f u}) = curry (Sup {u. u \\<le> f u})", "by (force simp add: image_comp)"], ["proof (state)\nthis:\n  Sup (curry ` {u. u \\<le> f u}) = curry (Sup {u. u \\<le> f u})\n\ngoal (1 subgoal):\n 1. gfp (curry \\<circ> f \\<circ> case_prod) = curry (gfp f)", "also"], ["proof (state)\nthis:\n  Sup (curry ` {u. u \\<le> f u}) = curry (Sup {u. u \\<le> f u})\n\ngoal (1 subgoal):\n 1. gfp (curry \\<circ> f \\<circ> case_prod) = curry (gfp f)", "have \"\\<dots> = curry (gfp f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. curry (Sup {u. u \\<le> f u}) = curry (gfp f)", "unfolding gfp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. curry (Sup {u. u \\<le> f u}) = curry (Sup {u. u \\<le> f u})", "by simp"], ["proof (state)\nthis:\n  curry (Sup {u. u \\<le> f u}) = curry (gfp f)\n\ngoal (1 subgoal):\n 1. gfp (curry \\<circ> f \\<circ> case_prod) = curry (gfp f)", "finally"], ["proof (chain)\npicking this:\n  gfp (curry \\<circ> f \\<circ> case_prod) = curry (gfp f)", "show ?thesis"], ["proof (prove)\nusing this:\n  gfp (curry \\<circ> f \\<circ> case_prod) = curry (gfp f)\n\ngoal (1 subgoal):\n 1. gfp (curry \\<circ> f \\<circ> case_prod) = curry (gfp f)", "by this"], ["proof (state)\nthis:\n  gfp (curry \\<circ> f \\<circ> case_prod) = curry (gfp f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_someI:\n      assumes \"\\<And> x. P x \\<Longrightarrow> False\"\n      shows \"\\<not> P (SOME x. P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> P (SOME x. P x)", "using assms"], ["proof (prove)\nusing this:\n  P ?x \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> P (SOME x. P x)", "by blast"], ["", "lemma some_ccontr:\n      assumes \"(\\<And> x. \\<not> P x) \\<Longrightarrow> False\"\n      shows \"P (SOME x. P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (SOME x. P x)", "using assms someI_ex ccontr"], ["proof (prove)\nusing this:\n  (\\<And>x. \\<not> P x) \\<Longrightarrow> False\n  \\<exists>x. ?P x \\<Longrightarrow> ?P (SOME x. ?P x)\n  (\\<not> ?P \\<Longrightarrow> False) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. P (SOME x. P x)", "by metis"], ["", "end"]]}