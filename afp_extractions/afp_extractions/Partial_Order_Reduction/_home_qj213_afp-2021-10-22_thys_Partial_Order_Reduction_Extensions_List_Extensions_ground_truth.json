{"file_name": "/home/qj213/afp-2021-10-22/thys/Partial_Order_Reduction/Extensions/List_Extensions.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Partial_Order_Reduction", "problem_names": ["lemma nth_append_simps[simp]:\n    \"i < length xs \\<Longrightarrow> (xs @ ys) ! i = xs ! i\"\n    \"i \\<ge> length xs \\<Longrightarrow> (xs @ ys) ! i = ys ! (i - length xs)\"", "lemma map_plus[simp]: \"map (plus n) [i ..< j] = [i + n ..< j + n]\"", "lemma singleton_list_lengthE[elim]:\n    assumes \"length xs = 1\"\n    obtains x\n    where \"xs = [x]\"", "lemma singleton_hd_last: \"length xs = 1 \\<Longrightarrow> hd xs = last xs\"", "lemma set_subsetI[intro]:\n    assumes \"\\<And> i. i < length xs \\<Longrightarrow> xs ! i \\<in> S\"\n    shows \"set xs \\<subseteq> S\"", "lemma hd_take[simp]:\n    assumes \"n \\<noteq> 0\" \"xs \\<noteq> []\"\n    shows \"hd (take n xs) = hd xs\"", "lemma hd_drop[simp]:\n    assumes \"n < length xs\"\n    shows \"hd (drop n xs) = xs ! n\"", "lemma last_take[simp]:\n    assumes \"n < length xs\"\n    shows \"last (take (Suc n) xs) = xs ! n\"", "lemma split_list_first_unique:\n    assumes \"u\\<^sub>1 @ [a] @ u\\<^sub>2 = v\\<^sub>1 @ [a] @ v\\<^sub>2\" \"a \\<notin> set u\\<^sub>1\" \"a \\<notin> set v\\<^sub>1\"\n    shows \"u\\<^sub>1 = v\\<^sub>1\""], "translations": [["", "lemma nth_append_simps[simp]:\n    \"i < length xs \\<Longrightarrow> (xs @ ys) ! i = xs ! i\"\n    \"i \\<ge> length xs \\<Longrightarrow> (xs @ ys) ! i = ys ! (i - length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i < length xs \\<Longrightarrow> (xs @ ys) ! i = xs ! i) &&&\n    (length xs \\<le> i \\<Longrightarrow>\n     (xs @ ys) ! i = ys ! (i - length xs))", "unfolding nth_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. (i < length xs \\<Longrightarrow>\n     (if i < length xs then xs ! i else ys ! (i - length xs)) = xs ! i) &&&\n    (length xs \\<le> i \\<Longrightarrow>\n     (if i < length xs then xs ! i else ys ! (i - length xs)) =\n     ys ! (i - length xs))", "by simp+"], ["", "notation zip (infixr \"||\" 51)"], ["", "abbreviation \"project A \\<equiv> filter (\\<lambda> a. a \\<in> A)\""], ["", "abbreviation \"select s w \\<equiv> nths w s\""], ["", "lemma map_plus[simp]: \"map (plus n) [i ..< j] = [i + n ..< j + n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((+) n) [i..<j] = [i + n..<j + n]", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. map ((+) 0) [i..<j] = [i + 0..<j + 0]\n 2. \\<And>n.\n       map ((+) n) [i..<j] = [i + n..<j + n] \\<Longrightarrow>\n       map ((+) (Suc n)) [i..<j] = [i + Suc n..<j + Suc n]", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. map ((+) 0) [i..<j] = [i + 0..<j + 0]\n 2. \\<And>n.\n       map ((+) n) [i..<j] = [i + n..<j + n] \\<Longrightarrow>\n       map ((+) (Suc n)) [i..<j] = [i + Suc n..<j + Suc n]", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((+) 0) [i..<j] = [i + 0..<j + 0]", "by simp"], ["proof (state)\nthis:\n  map ((+) 0) [i..<j] = [i + 0..<j + 0]\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       map ((+) n) [i..<j] = [i + n..<j + n] \\<Longrightarrow>\n       map ((+) (Suc n)) [i..<j] = [i + Suc n..<j + Suc n]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       map ((+) n) [i..<j] = [i + n..<j + n] \\<Longrightarrow>\n       map ((+) (Suc n)) [i..<j] = [i + Suc n..<j + Suc n]", "case (Suc n)"], ["proof (state)\nthis:\n  map ((+) n) [i..<j] = [i + n..<j + n]\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       map ((+) n) [i..<j] = [i + n..<j + n] \\<Longrightarrow>\n       map ((+) (Suc n)) [i..<j] = [i + Suc n..<j + Suc n]", "have \"map (plus (Suc n)) [i ..< j] = map (Suc \\<circ> plus n) [i ..< j]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((+) (Suc n)) [i..<j] = map (Suc \\<circ> (+) n) [i..<j]", "by simp"], ["proof (state)\nthis:\n  map ((+) (Suc n)) [i..<j] = map (Suc \\<circ> (+) n) [i..<j]\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       map ((+) n) [i..<j] = [i + n..<j + n] \\<Longrightarrow>\n       map ((+) (Suc n)) [i..<j] = [i + Suc n..<j + Suc n]", "also"], ["proof (state)\nthis:\n  map ((+) (Suc n)) [i..<j] = map (Suc \\<circ> (+) n) [i..<j]\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       map ((+) n) [i..<j] = [i + n..<j + n] \\<Longrightarrow>\n       map ((+) (Suc n)) [i..<j] = [i + Suc n..<j + Suc n]", "have \"\\<dots> = (map Suc \\<circ> map (plus n)) [i ..< j]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (Suc \\<circ> (+) n) [i..<j] = (map Suc \\<circ> map ((+) n)) [i..<j]", "by simp"], ["proof (state)\nthis:\n  map (Suc \\<circ> (+) n) [i..<j] = (map Suc \\<circ> map ((+) n)) [i..<j]\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       map ((+) n) [i..<j] = [i + n..<j + n] \\<Longrightarrow>\n       map ((+) (Suc n)) [i..<j] = [i + Suc n..<j + Suc n]", "also"], ["proof (state)\nthis:\n  map (Suc \\<circ> (+) n) [i..<j] = (map Suc \\<circ> map ((+) n)) [i..<j]\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       map ((+) n) [i..<j] = [i + n..<j + n] \\<Longrightarrow>\n       map ((+) (Suc n)) [i..<j] = [i + Suc n..<j + Suc n]", "have \"\\<dots> = map Suc (map (plus n) [i ..< j])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map Suc \\<circ> map ((+) n)) [i..<j] = map Suc (map ((+) n) [i..<j])", "by simp"], ["proof (state)\nthis:\n  (map Suc \\<circ> map ((+) n)) [i..<j] = map Suc (map ((+) n) [i..<j])\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       map ((+) n) [i..<j] = [i + n..<j + n] \\<Longrightarrow>\n       map ((+) (Suc n)) [i..<j] = [i + Suc n..<j + Suc n]", "also"], ["proof (state)\nthis:\n  (map Suc \\<circ> map ((+) n)) [i..<j] = map Suc (map ((+) n) [i..<j])\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       map ((+) n) [i..<j] = [i + n..<j + n] \\<Longrightarrow>\n       map ((+) (Suc n)) [i..<j] = [i + Suc n..<j + Suc n]", "have \"\\<dots> = map Suc [i + n ..< j + n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map Suc (map ((+) n) [i..<j]) = map Suc [i + n..<j + n]", "unfolding Suc"], ["proof (prove)\ngoal (1 subgoal):\n 1. map Suc [i + n..<j + n] = map Suc [i + n..<j + n]", "by simp"], ["proof (state)\nthis:\n  map Suc (map ((+) n) [i..<j]) = map Suc [i + n..<j + n]\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       map ((+) n) [i..<j] = [i + n..<j + n] \\<Longrightarrow>\n       map ((+) (Suc n)) [i..<j] = [i + Suc n..<j + Suc n]", "also"], ["proof (state)\nthis:\n  map Suc (map ((+) n) [i..<j]) = map Suc [i + n..<j + n]\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       map ((+) n) [i..<j] = [i + n..<j + n] \\<Longrightarrow>\n       map ((+) (Suc n)) [i..<j] = [i + Suc n..<j + Suc n]", "have \"\\<dots> = [Suc (i + n) ..< Suc (j + n)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map Suc [i + n..<j + n] = [Suc (i + n)..<Suc (j + n)]", "unfolding map_Suc_upt"], ["proof (prove)\ngoal (1 subgoal):\n 1. [Suc (i + n)..<Suc (j + n)] = [Suc (i + n)..<Suc (j + n)]", "by simp"], ["proof (state)\nthis:\n  map Suc [i + n..<j + n] = [Suc (i + n)..<Suc (j + n)]\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       map ((+) n) [i..<j] = [i + n..<j + n] \\<Longrightarrow>\n       map ((+) (Suc n)) [i..<j] = [i + Suc n..<j + Suc n]", "also"], ["proof (state)\nthis:\n  map Suc [i + n..<j + n] = [Suc (i + n)..<Suc (j + n)]\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       map ((+) n) [i..<j] = [i + n..<j + n] \\<Longrightarrow>\n       map ((+) (Suc n)) [i..<j] = [i + Suc n..<j + Suc n]", "have \"\\<dots> = [i + Suc n ..< j + Suc n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [Suc (i + n)..<Suc (j + n)] = [i + Suc n..<j + Suc n]", "by simp"], ["proof (state)\nthis:\n  [Suc (i + n)..<Suc (j + n)] = [i + Suc n..<j + Suc n]\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       map ((+) n) [i..<j] = [i + n..<j + n] \\<Longrightarrow>\n       map ((+) (Suc n)) [i..<j] = [i + Suc n..<j + Suc n]", "finally"], ["proof (chain)\npicking this:\n  map ((+) (Suc n)) [i..<j] = [i + Suc n..<j + Suc n]", "show ?case"], ["proof (prove)\nusing this:\n  map ((+) (Suc n)) [i..<j] = [i + Suc n..<j + Suc n]\n\ngoal (1 subgoal):\n 1. map ((+) (Suc n)) [i..<j] = [i + Suc n..<j + Suc n]", "by this"], ["proof (state)\nthis:\n  map ((+) (Suc n)) [i..<j] = [i + Suc n..<j + Suc n]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma singleton_list_lengthE[elim]:\n    assumes \"length xs = 1\"\n    obtains x\n    where \"xs = [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. xs = [x] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>x. xs = [x] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "have 0: \"length xs = Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = Suc 0", "using assms"], ["proof (prove)\nusing this:\n  length xs = 1\n\ngoal (1 subgoal):\n 1. length xs = Suc 0", "by simp"], ["proof (state)\nthis:\n  length xs = Suc 0\n\ngoal (1 subgoal):\n 1. (\\<And>x. xs = [x] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "obtain y ys where 1: \"xs = y # ys\" \"length ys = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y ys.\n        \\<lbrakk>xs = y # ys; length ys = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 0 Suc_length_conv"], ["proof (prove)\nusing this:\n  length xs = Suc 0\n  (Suc ?n = length ?xs) =\n  (\\<exists>y ys. ?xs = y # ys \\<and> length ys = ?n)\n\ngoal (1 subgoal):\n 1. (\\<And>y ys.\n        \\<lbrakk>xs = y # ys; length ys = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  xs = y # ys\n  length ys = 0\n\ngoal (1 subgoal):\n 1. (\\<And>x. xs = [x] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using that 1"], ["proof (prove)\nusing this:\n  xs = [?x] \\<Longrightarrow> thesis\n  xs = y # ys\n  length ys = 0\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma singleton_hd_last: \"length xs = 1 \\<Longrightarrow> hd xs = last xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = 1 \\<Longrightarrow> hd xs = last xs", "by fastforce"], ["", "lemma set_subsetI[intro]:\n    assumes \"\\<And> i. i < length xs \\<Longrightarrow> xs ! i \\<in> S\"\n    shows \"set xs \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<subseteq> S", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<in> S", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<in> S", "assume 0: \"x \\<in> set xs\""], ["proof (state)\nthis:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<in> S", "obtain i where 1: \"i < length xs\" \"x = xs ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length xs; x = xs ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 0"], ["proof (prove)\nusing this:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length xs; x = xs ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding in_set_conv_nth"], ["proof (prove)\nusing this:\n  \\<exists>i<length xs. xs ! i = x\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length xs; x = xs ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  i < length xs\n  x = xs ! i\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<in> S", "show \"x \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> S", "using assms(1) 1"], ["proof (prove)\nusing this:\n  ?i < length xs \\<Longrightarrow> xs ! ?i \\<in> S\n  i < length xs\n  x = xs ! i\n\ngoal (1 subgoal):\n 1. x \\<in> S", "by auto"], ["proof (state)\nthis:\n  x \\<in> S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hd_take[simp]:\n    assumes \"n \\<noteq> 0\" \"xs \\<noteq> []\"\n    shows \"hd (take n xs) = hd xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (take n xs) = hd xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hd (take n xs) = hd xs", "have 1: \"take n xs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take n xs \\<noteq> []", "using assms"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. take n xs \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  take n xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd (take n xs) = hd xs", "have 2: \"0 < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n", "using assms"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. 0 < n", "by simp"], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. hd (take n xs) = hd xs", "have \"hd (take n xs) = take n xs ! 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (take n xs) = take n xs ! 0", "using hd_conv_nth[OF 1]"], ["proof (prove)\nusing this:\n  hd (take n xs) = take n xs ! 0\n\ngoal (1 subgoal):\n 1. hd (take n xs) = take n xs ! 0", "by this"], ["proof (state)\nthis:\n  hd (take n xs) = take n xs ! 0\n\ngoal (1 subgoal):\n 1. hd (take n xs) = hd xs", "also"], ["proof (state)\nthis:\n  hd (take n xs) = take n xs ! 0\n\ngoal (1 subgoal):\n 1. hd (take n xs) = hd xs", "have \"\\<dots> = xs ! 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take n xs ! 0 = xs ! 0", "using nth_take[OF 2]"], ["proof (prove)\nusing this:\n  take n ?xs ! 0 = ?xs ! 0\n\ngoal (1 subgoal):\n 1. take n xs ! 0 = xs ! 0", "by this"], ["proof (state)\nthis:\n  take n xs ! 0 = xs ! 0\n\ngoal (1 subgoal):\n 1. hd (take n xs) = hd xs", "also"], ["proof (state)\nthis:\n  take n xs ! 0 = xs ! 0\n\ngoal (1 subgoal):\n 1. hd (take n xs) = hd xs", "have \"\\<dots> = hd xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs ! 0 = hd xs", "using hd_conv_nth[OF assms(2)]"], ["proof (prove)\nusing this:\n  hd xs = xs ! 0\n\ngoal (1 subgoal):\n 1. xs ! 0 = hd xs", "by simp"], ["proof (state)\nthis:\n  xs ! 0 = hd xs\n\ngoal (1 subgoal):\n 1. hd (take n xs) = hd xs", "finally"], ["proof (chain)\npicking this:\n  hd (take n xs) = hd xs", "show ?thesis"], ["proof (prove)\nusing this:\n  hd (take n xs) = hd xs\n\ngoal (1 subgoal):\n 1. hd (take n xs) = hd xs", "by this"], ["proof (state)\nthis:\n  hd (take n xs) = hd xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hd_drop[simp]:\n    assumes \"n < length xs\"\n    shows \"hd (drop n xs) = xs ! n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (drop n xs) = xs ! n", "using hd_drop_conv_nth assms"], ["proof (prove)\nusing this:\n  ?n < length ?xs \\<Longrightarrow> hd (drop ?n ?xs) = ?xs ! ?n\n  n < length xs\n\ngoal (1 subgoal):\n 1. hd (drop n xs) = xs ! n", "by this"], ["", "lemma last_take[simp]:\n    assumes \"n < length xs\"\n    shows \"last (take (Suc n) xs) = xs ! n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (take (Suc n) xs) = xs ! n", "using assms"], ["proof (prove)\nusing this:\n  n < length xs\n\ngoal (1 subgoal):\n 1. last (take (Suc n) xs) = xs ! n", "proof (induct xs arbitrary: n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n. n < length [] \\<Longrightarrow> last (take (Suc n) []) = [] ! n\n 2. \\<And>a xs n.\n       \\<lbrakk>\\<And>n.\n                   n < length xs \\<Longrightarrow>\n                   last (take (Suc n) xs) = xs ! n;\n        n < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> last (take (Suc n) (a # xs)) = (a # xs) ! n", "case (Nil)"], ["proof (state)\nthis:\n  n < length []\n\ngoal (2 subgoals):\n 1. \\<And>n. n < length [] \\<Longrightarrow> last (take (Suc n) []) = [] ! n\n 2. \\<And>a xs n.\n       \\<lbrakk>\\<And>n.\n                   n < length xs \\<Longrightarrow>\n                   last (take (Suc n) xs) = xs ! n;\n        n < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> last (take (Suc n) (a # xs)) = (a # xs) ! n", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. last (take (Suc n) []) = [] ! n", "using Nil"], ["proof (prove)\nusing this:\n  n < length []\n\ngoal (1 subgoal):\n 1. last (take (Suc n) []) = [] ! n", "by simp"], ["proof (state)\nthis:\n  last (take (Suc n) []) = [] ! n\n\ngoal (1 subgoal):\n 1. \\<And>a xs n.\n       \\<lbrakk>\\<And>n.\n                   n < length xs \\<Longrightarrow>\n                   last (take (Suc n) xs) = xs ! n;\n        n < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> last (take (Suc n) (a # xs)) = (a # xs) ! n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs n.\n       \\<lbrakk>\\<And>n.\n                   n < length xs \\<Longrightarrow>\n                   last (take (Suc n) xs) = xs ! n;\n        n < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> last (take (Suc n) (a # xs)) = (a # xs) ! n", "case (Cons x xs)"], ["proof (state)\nthis:\n  ?n < length xs \\<Longrightarrow> last (take (Suc ?n) xs) = xs ! ?n\n  n < length (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs n.\n       \\<lbrakk>\\<And>n.\n                   n < length xs \\<Longrightarrow>\n                   last (take (Suc n) xs) = xs ! n;\n        n < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> last (take (Suc n) (a # xs)) = (a # xs) ! n", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. last (take (Suc n) (x # xs)) = (x # xs) ! n", "using Cons"], ["proof (prove)\nusing this:\n  ?n < length xs \\<Longrightarrow> last (take (Suc ?n) xs) = xs ! ?n\n  n < length (x # xs)\n\ngoal (1 subgoal):\n 1. last (take (Suc n) (x # xs)) = (x # xs) ! n", "by (auto) (metis Suc_less_eq Suc_pred)"], ["proof (state)\nthis:\n  last (take (Suc n) (x # xs)) = (x # xs) ! n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma split_list_first_unique:\n    assumes \"u\\<^sub>1 @ [a] @ u\\<^sub>2 = v\\<^sub>1 @ [a] @ v\\<^sub>2\" \"a \\<notin> set u\\<^sub>1\" \"a \\<notin> set v\\<^sub>1\"\n    shows \"u\\<^sub>1 = v\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u\\<^sub>1 = v\\<^sub>1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u\\<^sub>1 = v\\<^sub>1", "obtain w where \"u\\<^sub>1 = v\\<^sub>1 @ w \\<and> w @ [a] @ u\\<^sub>2 = [a] @ v\\<^sub>2 \\<or>\n      u\\<^sub>1 @ w = v\\<^sub>1 \\<and> [a] @ u\\<^sub>2 = w @ [a] @ v\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>w.\n        u\\<^sub>1 = v\\<^sub>1 @ w \\<and>\n        w @ [a] @ u\\<^sub>2 = [a] @ v\\<^sub>2 \\<or>\n        u\\<^sub>1 @ w = v\\<^sub>1 \\<and>\n        [a] @ u\\<^sub>2 = w @ [a] @ v\\<^sub>2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms(1) append_eq_append_conv2"], ["proof (prove)\nusing this:\n  u\\<^sub>1 @ [a] @ u\\<^sub>2 = v\\<^sub>1 @ [a] @ v\\<^sub>2\n  (?xs @ ?ys = ?zs @ ?ts) =\n  (\\<exists>us.\n      ?xs = ?zs @ us \\<and> us @ ?ys = ?ts \\<or>\n      ?xs @ us = ?zs \\<and> ?ys = us @ ?ts)\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        u\\<^sub>1 = v\\<^sub>1 @ w \\<and>\n        w @ [a] @ u\\<^sub>2 = [a] @ v\\<^sub>2 \\<or>\n        u\\<^sub>1 @ w = v\\<^sub>1 \\<and>\n        [a] @ u\\<^sub>2 = w @ [a] @ v\\<^sub>2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  u\\<^sub>1 = v\\<^sub>1 @ w \\<and>\n  w @ [a] @ u\\<^sub>2 = [a] @ v\\<^sub>2 \\<or>\n  u\\<^sub>1 @ w = v\\<^sub>1 \\<and> [a] @ u\\<^sub>2 = w @ [a] @ v\\<^sub>2\n\ngoal (1 subgoal):\n 1. u\\<^sub>1 = v\\<^sub>1", "thus ?thesis"], ["proof (prove)\nusing this:\n  u\\<^sub>1 = v\\<^sub>1 @ w \\<and>\n  w @ [a] @ u\\<^sub>2 = [a] @ v\\<^sub>2 \\<or>\n  u\\<^sub>1 @ w = v\\<^sub>1 \\<and> [a] @ u\\<^sub>2 = w @ [a] @ v\\<^sub>2\n\ngoal (1 subgoal):\n 1. u\\<^sub>1 = v\\<^sub>1", "using assms(2, 3)"], ["proof (prove)\nusing this:\n  u\\<^sub>1 = v\\<^sub>1 @ w \\<and>\n  w @ [a] @ u\\<^sub>2 = [a] @ v\\<^sub>2 \\<or>\n  u\\<^sub>1 @ w = v\\<^sub>1 \\<and> [a] @ u\\<^sub>2 = w @ [a] @ v\\<^sub>2\n  a \\<notin> set u\\<^sub>1\n  a \\<notin> set v\\<^sub>1\n\ngoal (1 subgoal):\n 1. u\\<^sub>1 = v\\<^sub>1", "by (auto) (metis hd_append2 list.sel(1) list.set_sel(1))+"], ["proof (state)\nthis:\n  u\\<^sub>1 = v\\<^sub>1\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}