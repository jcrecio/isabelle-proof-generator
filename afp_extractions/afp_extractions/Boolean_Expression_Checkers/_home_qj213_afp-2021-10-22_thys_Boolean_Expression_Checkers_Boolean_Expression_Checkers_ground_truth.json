{"file_name": "/home/qj213/afp-2021-10-22/thys/Boolean_Expression_Checkers/Boolean_Expression_Checkers.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Boolean_Expression_Checkers", "problem_names": ["lemma agree_Nil: \n  \"agree s Mapping.empty\"", "lemma lookup_update_unfold: \n  \"Mapping.lookup (Mapping.update k v m) k' = (if k = k' then Some v else Mapping.lookup m k')\"", "lemma agree_Cons: \n  \"x \\<notin> Mapping.keys env \\<Longrightarrow> agree s (Mapping.update x b env) = ((if b then s x else \\<not> s x) \\<and> agree s env)\"", "lemma agreeDT:\n  \"agree s env \\<Longrightarrow> Mapping.lookup env x = Some True \\<Longrightarrow> s x\"", "lemma agreeDF:\n  \"agree s env \\<Longrightarrow> Mapping.lookup env x = Some False \\<Longrightarrow> \\<not>s x\"", "lemma taut_test_rec: \n  \"taut_test_rec t env = (\\<forall>s. agree s env \\<longrightarrow> val_ifex t s)\"", "lemma val_mkIF: \n  \"val_ifex (mkIF x t1 t2) s = val_ifex (IF x t1 t2) s\"", "theorem val_reduce: \n  \"agree s env \\<Longrightarrow> val_ifex (reduce env t) s = val_ifex t s\"", "lemma val_normif: \n  \"agree s env \\<Longrightarrow> val_ifex (normif env t t1 t2) s = val_ifex (if val_ifex t s then t1 else t2) s\"", "lemma reduced_antimono: \n  \"X \\<subseteq> Y \\<Longrightarrow> reduced t Y \\<Longrightarrow> reduced t X\"", "lemma reduced_mkIF: \n  \"x \\<notin> X \\<Longrightarrow> reduced t1 (insert x X) \\<Longrightarrow> reduced t2 (insert x X) \\<Longrightarrow> reduced (mkIF x t1 t2) X\"", "lemma reduced_reduce:\n  \"reduced (reduce env t) (Mapping.keys env)\"", "lemma reduced_normif:\n  \"reduced (normif env t t1 t2) (Mapping.keys env)\"", "lemma same_val_if_reduced:\n  \"reduced t X \\<Longrightarrow> \\<forall>x. x \\<notin> X \\<longrightarrow> s1 x = s2 x \\<Longrightarrow> val_ifex t s1 = val_ifex t s2\"", "lemma reduced_IF_depends: \n  \"\\<lbrakk> reduced t X; t \\<noteq> Trueif; t \\<noteq> Falseif \\<rbrakk> \\<Longrightarrow> \\<exists>s1 s2. val_ifex t s1 \\<noteq> val_ifex t s2\"", "theorem val_ifex:\n  \"val_ifex (ifex_of b) s = val_bool_expr b s\"", "theorem reduced_ifex: \n  \"reduced (ifex_of b) {}\"", "lemma bool_tests:\n  \"bool_taut_test b = (\\<forall>s. val_bool_expr b s)\" (is ?t1)\n  \"bool_sat_test b = (\\<exists>s. val_bool_expr b s)\" (is ?t2)\n  \"bool_impl_test b1 b2 = (\\<forall>s. val_bool_expr b1 s \\<longrightarrow> val_bool_expr b2 s)\" (is ?t3)\n  \"bool_equiv_test b1 b2 = (\\<forall>s. val_bool_expr b1 s \\<longleftrightarrow> val_bool_expr b2 s)\" (is ?t4)"], "translations": [["", "lemma agree_Nil: \n  \"agree s Mapping.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. agree s Mapping.empty", "by (simp add: agree_def lookup_empty)"], ["", "lemma lookup_update_unfold: \n  \"Mapping.lookup (Mapping.update k v m) k' = (if k = k' then Some v else Mapping.lookup m k')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup (Mapping.update k v m) k' =\n    (if k = k' then Some v else Mapping.lookup m k')", "using lookup_update lookup_update_neq"], ["proof (prove)\nusing this:\n  Mapping.lookup (Mapping.update ?k ?v ?m) ?k = Some ?v\n  ?k \\<noteq> ?k' \\<Longrightarrow>\n  Mapping.lookup (Mapping.update ?k ?v ?m) ?k' = Mapping.lookup ?m ?k'\n\ngoal (1 subgoal):\n 1. Mapping.lookup (Mapping.update k v m) k' =\n    (if k = k' then Some v else Mapping.lookup m k')", "by metis"], ["", "lemma agree_Cons: \n  \"x \\<notin> Mapping.keys env \\<Longrightarrow> agree s (Mapping.update x b env) = ((if b then s x else \\<not> s x) \\<and> agree s env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> Mapping.keys env \\<Longrightarrow>\n    agree s (Mapping.update x b env) =\n    ((if b then s x else \\<not> s x) \\<and> agree s env)", "by (simp add: agree_def lookup_update_unfold; unfold keys_is_none_rep lookup_update_unfold Option.is_none_def; blast)"], ["", "lemma agreeDT:\n  \"agree s env \\<Longrightarrow> Mapping.lookup env x = Some True \\<Longrightarrow> s x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>agree s env; Mapping.lookup env x = Some True\\<rbrakk>\n    \\<Longrightarrow> s x", "by (simp add: agree_def)"], ["", "lemma agreeDF:\n  \"agree s env \\<Longrightarrow> Mapping.lookup env x = Some False \\<Longrightarrow> \\<not>s x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>agree s env; Mapping.lookup env x = Some False\\<rbrakk>\n    \\<Longrightarrow> \\<not> s x", "by (auto simp add: agree_def)"], ["", "subsection \\<open>Recursive Tautology Checker\\<close>"], ["", "text \\<open>Provided for completeness. However, it is recommend to use the checkers based on reduced trees.\\<close>"], ["", "fun taut_test_rec :: \"'a ifex \\<Rightarrow> 'a env_bool \\<Rightarrow> bool\" \nwhere\n  \"taut_test_rec Trueif env = True\" \n| \"taut_test_rec Falseif env = False\" \n| \"taut_test_rec (IF x t1 t2) env = (case Mapping.lookup env x of\n  Some b \\<Rightarrow> taut_test_rec (if b then t1 else t2) env |\n  None \\<Rightarrow> taut_test_rec t1 (Mapping.update x True env) \\<and> taut_test_rec t2 (Mapping.update x False env))\""], ["", "lemma taut_test_rec: \n  \"taut_test_rec t env = (\\<forall>s. agree s env \\<longrightarrow> val_ifex t s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. taut_test_rec t env =\n    (\\<forall>s. agree s env \\<longrightarrow> val_ifex t s)", "proof (induction t arbitrary: env)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>env.\n       taut_test_rec Trueif env =\n       (\\<forall>s. agree s env \\<longrightarrow> val_ifex Trueif s)\n 2. \\<And>env.\n       taut_test_rec Falseif env =\n       (\\<forall>s. agree s env \\<longrightarrow> val_ifex Falseif s)\n 3. \\<And>x1 t1 t2 env.\n       \\<lbrakk>\\<And>env.\n                   taut_test_rec t1 env =\n                   (\\<forall>s.\n                       agree s env \\<longrightarrow> val_ifex t1 s);\n        \\<And>env.\n           taut_test_rec t2 env =\n           (\\<forall>s.\n               agree s env \\<longrightarrow> val_ifex t2 s)\\<rbrakk>\n       \\<Longrightarrow> taut_test_rec (IF x1 t1 t2) env =\n                         (\\<forall>s.\n                             agree s env \\<longrightarrow>\n                             val_ifex (IF x1 t1 t2) s)", "case Falseif"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>env.\n       taut_test_rec Trueif env =\n       (\\<forall>s. agree s env \\<longrightarrow> val_ifex Trueif s)\n 2. \\<And>env.\n       taut_test_rec Falseif env =\n       (\\<forall>s. agree s env \\<longrightarrow> val_ifex Falseif s)\n 3. \\<And>x1 t1 t2 env.\n       \\<lbrakk>\\<And>env.\n                   taut_test_rec t1 env =\n                   (\\<forall>s.\n                       agree s env \\<longrightarrow> val_ifex t1 s);\n        \\<And>env.\n           taut_test_rec t2 env =\n           (\\<forall>s.\n               agree s env \\<longrightarrow> val_ifex t2 s)\\<rbrakk>\n       \\<Longrightarrow> taut_test_rec (IF x1 t1 t2) env =\n                         (\\<forall>s.\n                             agree s env \\<longrightarrow>\n                             val_ifex (IF x1 t1 t2) s)", "have \"agree (\\<lambda>x. the (Mapping.lookup env x)) env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. agree (\\<lambda>x. the (Mapping.lookup env x)) env", "by (auto simp: agree_def)"], ["proof (state)\nthis:\n  agree (\\<lambda>x. the (Mapping.lookup env x)) env\n\ngoal (3 subgoals):\n 1. \\<And>env.\n       taut_test_rec Trueif env =\n       (\\<forall>s. agree s env \\<longrightarrow> val_ifex Trueif s)\n 2. \\<And>env.\n       taut_test_rec Falseif env =\n       (\\<forall>s. agree s env \\<longrightarrow> val_ifex Falseif s)\n 3. \\<And>x1 t1 t2 env.\n       \\<lbrakk>\\<And>env.\n                   taut_test_rec t1 env =\n                   (\\<forall>s.\n                       agree s env \\<longrightarrow> val_ifex t1 s);\n        \\<And>env.\n           taut_test_rec t2 env =\n           (\\<forall>s.\n               agree s env \\<longrightarrow> val_ifex t2 s)\\<rbrakk>\n       \\<Longrightarrow> taut_test_rec (IF x1 t1 t2) env =\n                         (\\<forall>s.\n                             agree s env \\<longrightarrow>\n                             val_ifex (IF x1 t1 t2) s)", "thus ?case"], ["proof (prove)\nusing this:\n  agree (\\<lambda>x. the (Mapping.lookup env x)) env\n\ngoal (1 subgoal):\n 1. taut_test_rec Falseif env =\n    (\\<forall>s. agree s env \\<longrightarrow> val_ifex Falseif s)", "by auto"], ["proof (state)\nthis:\n  taut_test_rec Falseif env =\n  (\\<forall>s. agree s env \\<longrightarrow> val_ifex Falseif s)\n\ngoal (2 subgoals):\n 1. \\<And>env.\n       taut_test_rec Trueif env =\n       (\\<forall>s. agree s env \\<longrightarrow> val_ifex Trueif s)\n 2. \\<And>x1 t1 t2 env.\n       \\<lbrakk>\\<And>env.\n                   taut_test_rec t1 env =\n                   (\\<forall>s.\n                       agree s env \\<longrightarrow> val_ifex t1 s);\n        \\<And>env.\n           taut_test_rec t2 env =\n           (\\<forall>s.\n               agree s env \\<longrightarrow> val_ifex t2 s)\\<rbrakk>\n       \\<Longrightarrow> taut_test_rec (IF x1 t1 t2) env =\n                         (\\<forall>s.\n                             agree s env \\<longrightarrow>\n                             val_ifex (IF x1 t1 t2) s)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>env.\n       taut_test_rec Trueif env =\n       (\\<forall>s. agree s env \\<longrightarrow> val_ifex Trueif s)\n 2. \\<And>x1 t1 t2 env.\n       \\<lbrakk>\\<And>env.\n                   taut_test_rec t1 env =\n                   (\\<forall>s.\n                       agree s env \\<longrightarrow> val_ifex t1 s);\n        \\<And>env.\n           taut_test_rec t2 env =\n           (\\<forall>s.\n               agree s env \\<longrightarrow> val_ifex t2 s)\\<rbrakk>\n       \\<Longrightarrow> taut_test_rec (IF x1 t1 t2) env =\n                         (\\<forall>s.\n                             agree s env \\<longrightarrow>\n                             val_ifex (IF x1 t1 t2) s)", "case (IF x t1 t2)"], ["proof (state)\nthis:\n  taut_test_rec t1 ?env =\n  (\\<forall>s. agree s ?env \\<longrightarrow> val_ifex t1 s)\n  taut_test_rec t2 ?env =\n  (\\<forall>s. agree s ?env \\<longrightarrow> val_ifex t2 s)\n\ngoal (2 subgoals):\n 1. \\<And>env.\n       taut_test_rec Trueif env =\n       (\\<forall>s. agree s env \\<longrightarrow> val_ifex Trueif s)\n 2. \\<And>x1 t1 t2 env.\n       \\<lbrakk>\\<And>env.\n                   taut_test_rec t1 env =\n                   (\\<forall>s.\n                       agree s env \\<longrightarrow> val_ifex t1 s);\n        \\<And>env.\n           taut_test_rec t2 env =\n           (\\<forall>s.\n               agree s env \\<longrightarrow> val_ifex t2 s)\\<rbrakk>\n       \\<Longrightarrow> taut_test_rec (IF x1 t1 t2) env =\n                         (\\<forall>s.\n                             agree s env \\<longrightarrow>\n                             val_ifex (IF x1 t1 t2) s)", "thus ?case"], ["proof (prove)\nusing this:\n  taut_test_rec t1 ?env =\n  (\\<forall>s. agree s ?env \\<longrightarrow> val_ifex t1 s)\n  taut_test_rec t2 ?env =\n  (\\<forall>s. agree s ?env \\<longrightarrow> val_ifex t2 s)\n\ngoal (1 subgoal):\n 1. taut_test_rec (IF x t1 t2) env =\n    (\\<forall>s. agree s env \\<longrightarrow> val_ifex (IF x t1 t2) s)", "proof (cases \"Mapping.lookup env x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>env.\n                taut_test_rec t1 env =\n                (\\<forall>s. agree s env \\<longrightarrow> val_ifex t1 s);\n     \\<And>env.\n        taut_test_rec t2 env =\n        (\\<forall>s. agree s env \\<longrightarrow> val_ifex t2 s);\n     Mapping.lookup env x = None\\<rbrakk>\n    \\<Longrightarrow> taut_test_rec (IF x t1 t2) env =\n                      (\\<forall>s.\n                          agree s env \\<longrightarrow>\n                          val_ifex (IF x t1 t2) s)\n 2. \\<And>a.\n       \\<lbrakk>\\<And>env.\n                   taut_test_rec t1 env =\n                   (\\<forall>s.\n                       agree s env \\<longrightarrow> val_ifex t1 s);\n        \\<And>env.\n           taut_test_rec t2 env =\n           (\\<forall>s. agree s env \\<longrightarrow> val_ifex t2 s);\n        Mapping.lookup env x = Some a\\<rbrakk>\n       \\<Longrightarrow> taut_test_rec (IF x t1 t2) env =\n                         (\\<forall>s.\n                             agree s env \\<longrightarrow>\n                             val_ifex (IF x t1 t2) s)", "case None"], ["proof (state)\nthis:\n  Mapping.lookup env x = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>env.\n                taut_test_rec t1 env =\n                (\\<forall>s. agree s env \\<longrightarrow> val_ifex t1 s);\n     \\<And>env.\n        taut_test_rec t2 env =\n        (\\<forall>s. agree s env \\<longrightarrow> val_ifex t2 s);\n     Mapping.lookup env x = None\\<rbrakk>\n    \\<Longrightarrow> taut_test_rec (IF x t1 t2) env =\n                      (\\<forall>s.\n                          agree s env \\<longrightarrow>\n                          val_ifex (IF x t1 t2) s)\n 2. \\<And>a.\n       \\<lbrakk>\\<And>env.\n                   taut_test_rec t1 env =\n                   (\\<forall>s.\n                       agree s env \\<longrightarrow> val_ifex t1 s);\n        \\<And>env.\n           taut_test_rec t2 env =\n           (\\<forall>s. agree s env \\<longrightarrow> val_ifex t2 s);\n        Mapping.lookup env x = Some a\\<rbrakk>\n       \\<Longrightarrow> taut_test_rec (IF x t1 t2) env =\n                         (\\<forall>s.\n                             agree s env \\<longrightarrow>\n                             val_ifex (IF x t1 t2) s)", "with IF"], ["proof (chain)\npicking this:\n  taut_test_rec t1 ?env =\n  (\\<forall>s. agree s ?env \\<longrightarrow> val_ifex t1 s)\n  taut_test_rec t2 ?env =\n  (\\<forall>s. agree s ?env \\<longrightarrow> val_ifex t2 s)\n  Mapping.lookup env x = None", "show ?thesis"], ["proof (prove)\nusing this:\n  taut_test_rec t1 ?env =\n  (\\<forall>s. agree s ?env \\<longrightarrow> val_ifex t1 s)\n  taut_test_rec t2 ?env =\n  (\\<forall>s. agree s ?env \\<longrightarrow> val_ifex t2 s)\n  Mapping.lookup env x = None\n\ngoal (1 subgoal):\n 1. taut_test_rec (IF x t1 t2) env =\n    (\\<forall>s. agree s env \\<longrightarrow> val_ifex (IF x t1 t2) s)", "by simp (metis is_none_simps(1) agree_Cons keys_is_none_rep)"], ["proof (state)\nthis:\n  taut_test_rec (IF x t1 t2) env =\n  (\\<forall>s. agree s env \\<longrightarrow> val_ifex (IF x t1 t2) s)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>env.\n                   taut_test_rec t1 env =\n                   (\\<forall>s.\n                       agree s env \\<longrightarrow> val_ifex t1 s);\n        \\<And>env.\n           taut_test_rec t2 env =\n           (\\<forall>s. agree s env \\<longrightarrow> val_ifex t2 s);\n        Mapping.lookup env x = Some a\\<rbrakk>\n       \\<Longrightarrow> taut_test_rec (IF x t1 t2) env =\n                         (\\<forall>s.\n                             agree s env \\<longrightarrow>\n                             val_ifex (IF x t1 t2) s)", "qed (simp add: agree_def)"], ["proof (state)\nthis:\n  taut_test_rec (IF x t1 t2) env =\n  (\\<forall>s. agree s env \\<longrightarrow> val_ifex (IF x t1 t2) s)\n\ngoal (1 subgoal):\n 1. \\<And>env.\n       taut_test_rec Trueif env =\n       (\\<forall>s. agree s env \\<longrightarrow> val_ifex Trueif s)", "qed simp"], ["", "definition taut_test_ifex :: \"'a ifex \\<Rightarrow> bool\" \nwhere\n  \"taut_test_ifex t = taut_test_rec t Mapping.empty\""], ["", "corollary taut_test_ifex: \n  \"taut_test_ifex t = (\\<forall>s. val_ifex t s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. taut_test_ifex t = (\\<forall>s. val_ifex t s)", "by (auto simp: taut_test_ifex_def taut_test_rec agree_Nil)"], ["", "subsection \\<open>Reduced Binary Decision Trees\\<close>"], ["", "subsubsection \\<open>Normalisation\\<close>"], ["", "text \\<open>A normalisation avoiding duplicate variables and collapsing @{term \"If x t t\"} to \\<open>t\\<close>.\\<close>"], ["", "definition mkIF :: \"'a \\<Rightarrow> 'a ifex \\<Rightarrow> 'a ifex \\<Rightarrow> 'a ifex\" \nwhere\n  \"mkIF x t1 t2 = (if t1=t2 then t1 else IF x t1 t2)\""], ["", "fun reduce :: \"'a env_bool \\<Rightarrow> 'a ifex \\<Rightarrow> 'a ifex\"\nwhere\n  \"reduce env (IF x t1 t2) = (case Mapping.lookup env x of\n     None \\<Rightarrow> mkIF x (reduce (Mapping.update x True env) t1) (reduce (Mapping.update x False env) t2) |\n     Some b \\<Rightarrow> reduce env (if b then t1 else t2))\" \n| \"reduce _ t = t\""], ["", "primrec normif :: \"'a env_bool \\<Rightarrow> 'a ifex \\<Rightarrow> 'a ifex \\<Rightarrow> 'a ifex \\<Rightarrow> 'a ifex\" \nwhere\n  \"normif env Trueif t1 t2 = reduce env t1\" \n| \"normif env Falseif t1 t2 = reduce env t2\" \n| \"normif env (IF x t1 t2) t3 t4 =\n    (case Mapping.lookup env x of\n       None \\<Rightarrow> mkIF x (normif (Mapping.update x True env) t1 t3 t4) (normif (Mapping.update x False env) t2 t3 t4) |\n       Some b \\<Rightarrow> if b then normif env t1 t3 t4 else normif env t2 t3 t4)\""], ["", "subsubsection \\<open>Functional Correctness Proof\\<close>"], ["", "lemma val_mkIF: \n  \"val_ifex (mkIF x t1 t2) s = val_ifex (IF x t1 t2) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val_ifex (mkIF x t1 t2) s = val_ifex (IF x t1 t2) s", "by (auto simp: mkIF_def Let_def)"], ["", "theorem val_reduce: \n  \"agree s env \\<Longrightarrow> val_ifex (reduce env t) s = val_ifex t s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. agree s env \\<Longrightarrow> val_ifex (reduce env t) s = val_ifex t s", "by (induction t arbitrary: s env)\n     (auto simp: map_of_eq_None_iff val_mkIF agree_Cons Let_def keys_is_none_rep\n           dest: agreeDT agreeDF split: option.splits)"], ["", "lemma val_normif: \n  \"agree s env \\<Longrightarrow> val_ifex (normif env t t1 t2) s = val_ifex (if val_ifex t s then t1 else t2) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. agree s env \\<Longrightarrow>\n    val_ifex (normif env t t1 t2) s =\n    val_ifex (if val_ifex t s then t1 else t2) s", "by (induct t arbitrary: t1 t2 s env)\n     (auto simp: val_reduce val_mkIF agree_Cons map_of_eq_None_iff keys_is_none_rep\n           dest: agreeDT agreeDF split: option.splits)"], ["", "subsubsection \\<open>Reduced If-Expressions\\<close>"], ["", "text \\<open>An expression reduced iff no variable appears twice on any branch and there is no subexpression @{term \"IF x t t\"}.\\<close>"], ["", "fun reduced :: \"'a ifex \\<Rightarrow> 'a set \\<Rightarrow> bool\" where\n\"reduced (IF x t1 t2) X =\n  (x \\<notin> X \\<and> t1 \\<noteq> t2 \\<and> reduced t1 (insert x X) \\<and> reduced t2 (insert x X))\" |\n\"reduced _ _ = True\""], ["", "lemma reduced_antimono: \n  \"X \\<subseteq> Y \\<Longrightarrow> reduced t Y \\<Longrightarrow> reduced t X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<subseteq> Y; reduced t Y\\<rbrakk>\n    \\<Longrightarrow> reduced t X", "by (induction t arbitrary: X Y)\n     (auto, (metis insert_mono)+)"], ["", "lemma reduced_mkIF: \n  \"x \\<notin> X \\<Longrightarrow> reduced t1 (insert x X) \\<Longrightarrow> reduced t2 (insert x X) \\<Longrightarrow> reduced (mkIF x t1 t2) X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> X; reduced t1 (insert x X);\n     reduced t2 (insert x X)\\<rbrakk>\n    \\<Longrightarrow> reduced (mkIF x t1 t2) X", "by (auto simp: mkIF_def intro:reduced_antimono)"], ["", "lemma reduced_reduce:\n  \"reduced (reduce env t) (Mapping.keys env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced (reduce env t) (Mapping.keys env)", "proof(induction t arbitrary: env)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>env. reduced (reduce env Trueif) (Mapping.keys env)\n 2. \\<And>env. reduced (reduce env Falseif) (Mapping.keys env)\n 3. \\<And>x1 t1 t2 env.\n       \\<lbrakk>\\<And>env. reduced (reduce env t1) (Mapping.keys env);\n        \\<And>env. reduced (reduce env t2) (Mapping.keys env)\\<rbrakk>\n       \\<Longrightarrow> reduced (reduce env (IF x1 t1 t2))\n                          (Mapping.keys env)", "case (IF x t1 t2)"], ["proof (state)\nthis:\n  reduced (reduce ?env t1) (Mapping.keys ?env)\n  reduced (reduce ?env t2) (Mapping.keys ?env)\n\ngoal (3 subgoals):\n 1. \\<And>env. reduced (reduce env Trueif) (Mapping.keys env)\n 2. \\<And>env. reduced (reduce env Falseif) (Mapping.keys env)\n 3. \\<And>x1 t1 t2 env.\n       \\<lbrakk>\\<And>env. reduced (reduce env t1) (Mapping.keys env);\n        \\<And>env. reduced (reduce env t2) (Mapping.keys env)\\<rbrakk>\n       \\<Longrightarrow> reduced (reduce env (IF x1 t1 t2))\n                          (Mapping.keys env)", "thus ?case"], ["proof (prove)\nusing this:\n  reduced (reduce ?env t1) (Mapping.keys ?env)\n  reduced (reduce ?env t2) (Mapping.keys ?env)\n\ngoal (1 subgoal):\n 1. reduced (reduce env (IF x t1 t2)) (Mapping.keys env)", "using IF.IH(1) IF.IH(2)"], ["proof (prove)\nusing this:\n  reduced (reduce ?env t1) (Mapping.keys ?env)\n  reduced (reduce ?env t2) (Mapping.keys ?env)\n  reduced (reduce ?env t1) (Mapping.keys ?env)\n  reduced (reduce ?env t2) (Mapping.keys ?env)\n\ngoal (1 subgoal):\n 1. reduced (reduce env (IF x t1 t2)) (Mapping.keys env)", "apply (auto simp: map_of_eq_None_iff image_iff reduced_mkIF split: option.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>env. reduced (reduce env t1) (Mapping.keys env);\n     \\<And>env. reduced (reduce env t2) (Mapping.keys env);\n     Mapping.lookup env x = None\\<rbrakk>\n    \\<Longrightarrow> reduced\n                       (mkIF x (reduce (Mapping.update x True env) t1)\n                         (reduce (Mapping.update x False env) t2))\n                       (Mapping.keys env)", "by (metis is_none_code(1) keys_is_none_rep keys_update reduced_mkIF)"], ["proof (state)\nthis:\n  reduced (reduce env (IF x t1 t2)) (Mapping.keys env)\n\ngoal (2 subgoals):\n 1. \\<And>env. reduced (reduce env Trueif) (Mapping.keys env)\n 2. \\<And>env. reduced (reduce env Falseif) (Mapping.keys env)", "qed auto"], ["", "lemma reduced_normif:\n  \"reduced (normif env t t1 t2) (Mapping.keys env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced (normif env t t1 t2) (Mapping.keys env)", "proof(induction t arbitrary: t1 t2 env)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t1 t2 env. reduced (normif env Trueif t1 t2) (Mapping.keys env)\n 2. \\<And>t1 t2 env. reduced (normif env Falseif t1 t2) (Mapping.keys env)\n 3. \\<And>x1 t1 t2 t1a t2a env.\n       \\<lbrakk>\\<And>t1a t2 env.\n                   reduced (normif env t1 t1a t2) (Mapping.keys env);\n        \\<And>t1 t2a env.\n           reduced (normif env t2 t1 t2a) (Mapping.keys env)\\<rbrakk>\n       \\<Longrightarrow> reduced (normif env (IF x1 t1 t2) t1a t2a)\n                          (Mapping.keys env)", "case (IF x s1 s2)"], ["proof (state)\nthis:\n  reduced (normif ?env s1 ?t1.0 ?t2.0) (Mapping.keys ?env)\n  reduced (normif ?env s2 ?t1.0 ?t2.0) (Mapping.keys ?env)\n\ngoal (3 subgoals):\n 1. \\<And>t1 t2 env. reduced (normif env Trueif t1 t2) (Mapping.keys env)\n 2. \\<And>t1 t2 env. reduced (normif env Falseif t1 t2) (Mapping.keys env)\n 3. \\<And>x1 t1 t2 t1a t2a env.\n       \\<lbrakk>\\<And>t1a t2 env.\n                   reduced (normif env t1 t1a t2) (Mapping.keys env);\n        \\<And>t1 t2a env.\n           reduced (normif env t2 t1 t2a) (Mapping.keys env)\\<rbrakk>\n       \\<Longrightarrow> reduced (normif env (IF x1 t1 t2) t1a t2a)\n                          (Mapping.keys env)", "thus ?case"], ["proof (prove)\nusing this:\n  reduced (normif ?env s1 ?t1.0 ?t2.0) (Mapping.keys ?env)\n  reduced (normif ?env s2 ?t1.0 ?t2.0) (Mapping.keys ?env)\n\ngoal (1 subgoal):\n 1. reduced (normif env (IF x s1 s2) t1 t2) (Mapping.keys env)", "using IF.IH"], ["proof (prove)\nusing this:\n  reduced (normif ?env s1 ?t1.0 ?t2.0) (Mapping.keys ?env)\n  reduced (normif ?env s2 ?t1.0 ?t2.0) (Mapping.keys ?env)\n  reduced (normif ?env s1 ?t1.0 ?t2.0) (Mapping.keys ?env)\n  reduced (normif ?env s2 ?t1.0 ?t2.0) (Mapping.keys ?env)\n\ngoal (1 subgoal):\n 1. reduced (normif env (IF x s1 s2) t1 t2) (Mapping.keys env)", "apply (auto simp: reduced_mkIF map_of_eq_None_iff split: option.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>env t1 t2.\n                reduced (normif env s1 t1 t2) (Mapping.keys env);\n     \\<And>env t1 t2. reduced (normif env s2 t1 t2) (Mapping.keys env);\n     Mapping.lookup env x = None\\<rbrakk>\n    \\<Longrightarrow> reduced\n                       (mkIF x (normif (Mapping.update x True env) s1 t1 t2)\n                         (normif (Mapping.update x False env) s2 t1 t2))\n                       (Mapping.keys env)", "by (metis is_none_code(1) keys_is_none_rep keys_update reduced_mkIF)"], ["proof (state)\nthis:\n  reduced (normif env (IF x s1 s2) t1 t2) (Mapping.keys env)\n\ngoal (2 subgoals):\n 1. \\<And>t1 t2 env. reduced (normif env Trueif t1 t2) (Mapping.keys env)\n 2. \\<And>t1 t2 env. reduced (normif env Falseif t1 t2) (Mapping.keys env)", "qed (auto simp: reduced_reduce)"], ["", "subsubsection \\<open>Checkers Based on Reduced Binary Decision Trees\\<close>"], ["", "text \\<open>The checkers are parameterized over the translation function to binary decision trees. \n  They rely on the fact that @{term ifex_of} produces reduced trees\\<close>"], ["", "definition taut_test :: \"('a \\<Rightarrow> 'b ifex) \\<Rightarrow> 'a \\<Rightarrow> bool\" \nwhere\n  \"taut_test ifex_of b = (ifex_of b = Trueif)\""], ["", "definition sat_test :: \"('a \\<Rightarrow> 'b ifex) \\<Rightarrow> 'a \\<Rightarrow> bool\" \nwhere\n  \"sat_test ifex_of b = (ifex_of b \\<noteq> Falseif)\""], ["", "definition impl_test :: \"('a \\<Rightarrow> 'b ifex) \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> bool\" \nwhere\n  \"impl_test ifex_of b1 b2 = (normif Mapping.empty (ifex_of b1) (ifex_of b2) Trueif = Trueif)\""], ["", "definition equiv_test :: \"('a \\<Rightarrow> 'b ifex) \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> bool\" \nwhere\n  \"equiv_test ifex_of b1 b2 = (let t1 = ifex_of b1; t2 = ifex_of b2 \n    in Trueif = normif Mapping.empty t1 t2 (normif Mapping.empty t2 Falseif Trueif))\""], ["", "locale reduced_bdt_checkers = \n  fixes\n    ifex_of :: \"'b \\<Rightarrow> 'a ifex\"\n  fixes\n    val :: \"'b \\<Rightarrow> ('a \\<Rightarrow> bool) \\<Rightarrow> bool\"\n  assumes\n    val_ifex: \"val_ifex (ifex_of b) s = val b s\"\n  assumes \n    reduced_ifex: \"reduced (ifex_of b) {}\"\nbegin"], ["", "text \\<open>Proof that reduced if-expressions are @{const Trueif}, @{const Falseif}\nor can evaluate to both @{const True} and @{const False}.\\<close>"], ["", "lemma same_val_if_reduced:\n  \"reduced t X \\<Longrightarrow> \\<forall>x. x \\<notin> X \\<longrightarrow> s1 x = s2 x \\<Longrightarrow> val_ifex t s1 = val_ifex t s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reduced t X;\n     \\<forall>x. x \\<notin> X \\<longrightarrow> s1 x = s2 x\\<rbrakk>\n    \\<Longrightarrow> val_ifex t s1 = val_ifex t s2", "by (induction t arbitrary: X) auto"], ["", "lemma reduced_IF_depends: \n  \"\\<lbrakk> reduced t X; t \\<noteq> Trueif; t \\<noteq> Falseif \\<rbrakk> \\<Longrightarrow> \\<exists>s1 s2. val_ifex t s1 \\<noteq> val_ifex t s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reduced t X; t \\<noteq> Trueif; t \\<noteq> Falseif\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s1 s2. val_ifex t s1 \\<noteq> val_ifex t s2", "proof(induction t arbitrary: X)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>X.\n       \\<lbrakk>reduced Trueif X; Trueif \\<noteq> Trueif;\n        Trueif \\<noteq> Falseif\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 s2.\n                            val_ifex Trueif s1 \\<noteq> val_ifex Trueif s2\n 2. \\<And>X.\n       \\<lbrakk>reduced Falseif X; Falseif \\<noteq> Trueif;\n        Falseif \\<noteq> Falseif\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 s2.\n                            val_ifex Falseif s1 \\<noteq> val_ifex Falseif s2\n 3. \\<And>x1 t1 t2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>reduced t1 X; t1 \\<noteq> Trueif;\n                    t1 \\<noteq> Falseif\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>s1 s2.\n  val_ifex t1 s1 \\<noteq> val_ifex t1 s2;\n        \\<And>X.\n           \\<lbrakk>reduced t2 X; t2 \\<noteq> Trueif;\n            t2 \\<noteq> Falseif\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s1 s2.\n                                val_ifex t2 s1 \\<noteq> val_ifex t2 s2;\n        reduced (IF x1 t1 t2) X; IF x1 t1 t2 \\<noteq> Trueif;\n        IF x1 t1 t2 \\<noteq> Falseif\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 s2.\n                            val_ifex (IF x1 t1 t2) s1 \\<noteq>\n                            val_ifex (IF x1 t1 t2) s2", "case (IF x t1 t2)"], ["proof (state)\nthis:\n  \\<lbrakk>reduced t1 ?X; t1 \\<noteq> Trueif; t1 \\<noteq> Falseif\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s1 s2. val_ifex t1 s1 \\<noteq> val_ifex t1 s2\n  \\<lbrakk>reduced t2 ?X; t2 \\<noteq> Trueif; t2 \\<noteq> Falseif\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s1 s2. val_ifex t2 s1 \\<noteq> val_ifex t2 s2\n  reduced (IF x t1 t2) X\n  IF x t1 t2 \\<noteq> Trueif\n  IF x t1 t2 \\<noteq> Falseif\n\ngoal (3 subgoals):\n 1. \\<And>X.\n       \\<lbrakk>reduced Trueif X; Trueif \\<noteq> Trueif;\n        Trueif \\<noteq> Falseif\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 s2.\n                            val_ifex Trueif s1 \\<noteq> val_ifex Trueif s2\n 2. \\<And>X.\n       \\<lbrakk>reduced Falseif X; Falseif \\<noteq> Trueif;\n        Falseif \\<noteq> Falseif\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 s2.\n                            val_ifex Falseif s1 \\<noteq> val_ifex Falseif s2\n 3. \\<And>x1 t1 t2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>reduced t1 X; t1 \\<noteq> Trueif;\n                    t1 \\<noteq> Falseif\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>s1 s2.\n  val_ifex t1 s1 \\<noteq> val_ifex t1 s2;\n        \\<And>X.\n           \\<lbrakk>reduced t2 X; t2 \\<noteq> Trueif;\n            t2 \\<noteq> Falseif\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s1 s2.\n                                val_ifex t2 s1 \\<noteq> val_ifex t2 s2;\n        reduced (IF x1 t1 t2) X; IF x1 t1 t2 \\<noteq> Trueif;\n        IF x1 t1 t2 \\<noteq> Falseif\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 s2.\n                            val_ifex (IF x1 t1 t2) s1 \\<noteq>\n                            val_ifex (IF x1 t1 t2) s2", "let ?t = \"IF x t1 t2\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>X.\n       \\<lbrakk>reduced Trueif X; Trueif \\<noteq> Trueif;\n        Trueif \\<noteq> Falseif\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 s2.\n                            val_ifex Trueif s1 \\<noteq> val_ifex Trueif s2\n 2. \\<And>X.\n       \\<lbrakk>reduced Falseif X; Falseif \\<noteq> Trueif;\n        Falseif \\<noteq> Falseif\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 s2.\n                            val_ifex Falseif s1 \\<noteq> val_ifex Falseif s2\n 3. \\<And>x1 t1 t2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>reduced t1 X; t1 \\<noteq> Trueif;\n                    t1 \\<noteq> Falseif\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>s1 s2.\n  val_ifex t1 s1 \\<noteq> val_ifex t1 s2;\n        \\<And>X.\n           \\<lbrakk>reduced t2 X; t2 \\<noteq> Trueif;\n            t2 \\<noteq> Falseif\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s1 s2.\n                                val_ifex t2 s1 \\<noteq> val_ifex t2 s2;\n        reduced (IF x1 t1 t2) X; IF x1 t1 t2 \\<noteq> Trueif;\n        IF x1 t1 t2 \\<noteq> Falseif\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 s2.\n                            val_ifex (IF x1 t1 t2) s1 \\<noteq>\n                            val_ifex (IF x1 t1 t2) s2", "have 1: \"reduced t1 (insert x X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced t1 (insert x X)", "using IF.prems(1)"], ["proof (prove)\nusing this:\n  reduced (IF x t1 t2) X\n\ngoal (1 subgoal):\n 1. reduced t1 (insert x X)", "by simp"], ["proof (state)\nthis:\n  reduced t1 (insert x X)\n\ngoal (3 subgoals):\n 1. \\<And>X.\n       \\<lbrakk>reduced Trueif X; Trueif \\<noteq> Trueif;\n        Trueif \\<noteq> Falseif\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 s2.\n                            val_ifex Trueif s1 \\<noteq> val_ifex Trueif s2\n 2. \\<And>X.\n       \\<lbrakk>reduced Falseif X; Falseif \\<noteq> Trueif;\n        Falseif \\<noteq> Falseif\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 s2.\n                            val_ifex Falseif s1 \\<noteq> val_ifex Falseif s2\n 3. \\<And>x1 t1 t2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>reduced t1 X; t1 \\<noteq> Trueif;\n                    t1 \\<noteq> Falseif\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>s1 s2.\n  val_ifex t1 s1 \\<noteq> val_ifex t1 s2;\n        \\<And>X.\n           \\<lbrakk>reduced t2 X; t2 \\<noteq> Trueif;\n            t2 \\<noteq> Falseif\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s1 s2.\n                                val_ifex t2 s1 \\<noteq> val_ifex t2 s2;\n        reduced (IF x1 t1 t2) X; IF x1 t1 t2 \\<noteq> Trueif;\n        IF x1 t1 t2 \\<noteq> Falseif\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 s2.\n                            val_ifex (IF x1 t1 t2) s1 \\<noteq>\n                            val_ifex (IF x1 t1 t2) s2", "have 2: \"reduced t2 (insert x X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced t2 (insert x X)", "using IF.prems(1)"], ["proof (prove)\nusing this:\n  reduced (IF x t1 t2) X\n\ngoal (1 subgoal):\n 1. reduced t2 (insert x X)", "by simp"], ["proof (state)\nthis:\n  reduced t2 (insert x X)\n\ngoal (3 subgoals):\n 1. \\<And>X.\n       \\<lbrakk>reduced Trueif X; Trueif \\<noteq> Trueif;\n        Trueif \\<noteq> Falseif\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 s2.\n                            val_ifex Trueif s1 \\<noteq> val_ifex Trueif s2\n 2. \\<And>X.\n       \\<lbrakk>reduced Falseif X; Falseif \\<noteq> Trueif;\n        Falseif \\<noteq> Falseif\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 s2.\n                            val_ifex Falseif s1 \\<noteq> val_ifex Falseif s2\n 3. \\<And>x1 t1 t2 X.\n       \\<lbrakk>\\<And>X.\n                   \\<lbrakk>reduced t1 X; t1 \\<noteq> Trueif;\n                    t1 \\<noteq> Falseif\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>s1 s2.\n  val_ifex t1 s1 \\<noteq> val_ifex t1 s2;\n        \\<And>X.\n           \\<lbrakk>reduced t2 X; t2 \\<noteq> Trueif;\n            t2 \\<noteq> Falseif\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s1 s2.\n                                val_ifex t2 s1 \\<noteq> val_ifex t2 s2;\n        reduced (IF x1 t1 t2) X; IF x1 t1 t2 \\<noteq> Trueif;\n        IF x1 t1 t2 \\<noteq> Falseif\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 s2.\n                            val_ifex (IF x1 t1 t2) s1 \\<noteq>\n                            val_ifex (IF x1 t1 t2) s2", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s1 s2.\n       val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "proof(cases t1)"], ["proof (state)\ngoal (3 subgoals):\n 1. t1 = Trueif \\<Longrightarrow>\n    \\<exists>s1 s2.\n       val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2\n 2. t1 = Falseif \\<Longrightarrow>\n    \\<exists>s1 s2.\n       val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2\n 3. \\<And>x31 x32 x33.\n       t1 = IF x31 x32 x33 \\<Longrightarrow>\n       \\<exists>s1 s2.\n          val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "case [simp]: Trueif"], ["proof (state)\nthis:\n  t1 = Trueif\n\ngoal (3 subgoals):\n 1. t1 = Trueif \\<Longrightarrow>\n    \\<exists>s1 s2.\n       val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2\n 2. t1 = Falseif \\<Longrightarrow>\n    \\<exists>s1 s2.\n       val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2\n 3. \\<And>x31 x32 x33.\n       t1 = IF x31 x32 x33 \\<Longrightarrow>\n       \\<exists>s1 s2.\n          val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s1 s2.\n       val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "proof (cases t2)"], ["proof (state)\ngoal (3 subgoals):\n 1. t2 = Trueif \\<Longrightarrow>\n    \\<exists>s1 s2.\n       val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2\n 2. t2 = Falseif \\<Longrightarrow>\n    \\<exists>s1 s2.\n       val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2\n 3. \\<And>x31 x32 x33.\n       t2 = IF x31 x32 x33 \\<Longrightarrow>\n       \\<exists>s1 s2.\n          val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "case Trueif"], ["proof (state)\nthis:\n  t2 = Trueif\n\ngoal (3 subgoals):\n 1. t2 = Trueif \\<Longrightarrow>\n    \\<exists>s1 s2.\n       val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2\n 2. t2 = Falseif \\<Longrightarrow>\n    \\<exists>s1 s2.\n       val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2\n 3. \\<And>x31 x32 x33.\n       t2 = IF x31 x32 x33 \\<Longrightarrow>\n       \\<exists>s1 s2.\n          val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "thus ?thesis"], ["proof (prove)\nusing this:\n  t2 = Trueif\n\ngoal (1 subgoal):\n 1. \\<exists>s1 s2.\n       val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "using IF.prems(1)"], ["proof (prove)\nusing this:\n  t2 = Trueif\n  reduced (IF x t1 t2) X\n\ngoal (1 subgoal):\n 1. \\<exists>s1 s2.\n       val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "by simp"], ["proof (state)\nthis:\n  \\<exists>s1 s2. val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2\n\ngoal (2 subgoals):\n 1. t2 = Falseif \\<Longrightarrow>\n    \\<exists>s1 s2.\n       val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2\n 2. \\<And>x31 x32 x33.\n       t2 = IF x31 x32 x33 \\<Longrightarrow>\n       \\<exists>s1 s2.\n          val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. t2 = Falseif \\<Longrightarrow>\n    \\<exists>s1 s2.\n       val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2\n 2. \\<And>x31 x32 x33.\n       t2 = IF x31 x32 x33 \\<Longrightarrow>\n       \\<exists>s1 s2.\n          val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "case Falseif"], ["proof (state)\nthis:\n  t2 = Falseif\n\ngoal (2 subgoals):\n 1. t2 = Falseif \\<Longrightarrow>\n    \\<exists>s1 s2.\n       val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2\n 2. \\<And>x31 x32 x33.\n       t2 = IF x31 x32 x33 \\<Longrightarrow>\n       \\<exists>s1 s2.\n          val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "hence \"val_ifex ?t (\\<lambda>_. True) \\<noteq> val_ifex ?t (\\<lambda>_. False)\""], ["proof (prove)\nusing this:\n  t2 = Falseif\n\ngoal (1 subgoal):\n 1. val_ifex (IF x t1 t2) (\\<lambda>_. True) \\<noteq>\n    val_ifex (IF x t1 t2) (\\<lambda>_. False)", "by simp"], ["proof (state)\nthis:\n  val_ifex (IF x t1 t2) (\\<lambda>_. True) \\<noteq>\n  val_ifex (IF x t1 t2) (\\<lambda>_. False)\n\ngoal (2 subgoals):\n 1. t2 = Falseif \\<Longrightarrow>\n    \\<exists>s1 s2.\n       val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2\n 2. \\<And>x31 x32 x33.\n       t2 = IF x31 x32 x33 \\<Longrightarrow>\n       \\<exists>s1 s2.\n          val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "thus ?thesis"], ["proof (prove)\nusing this:\n  val_ifex (IF x t1 t2) (\\<lambda>_. True) \\<noteq>\n  val_ifex (IF x t1 t2) (\\<lambda>_. False)\n\ngoal (1 subgoal):\n 1. \\<exists>s1 s2.\n       val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "by blast"], ["proof (state)\nthis:\n  \\<exists>s1 s2. val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32 x33.\n       t2 = IF x31 x32 x33 \\<Longrightarrow>\n       \\<exists>s1 s2.\n          val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x31 x32 x33.\n       t2 = IF x31 x32 x33 \\<Longrightarrow>\n       \\<exists>s1 s2.\n          val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "case IF"], ["proof (state)\nthis:\n  t2 = IF x31_ x32_ x33_\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32 x33.\n       t2 = IF x31 x32 x33 \\<Longrightarrow>\n       \\<exists>s1 s2.\n          val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "then"], ["proof (chain)\npicking this:\n  t2 = IF x31_ x32_ x33_", "obtain s1 s2 where \"val_ifex t2 s1 \\<noteq> val_ifex t2 s2\""], ["proof (prove)\nusing this:\n  t2 = IF x31_ x32_ x33_\n\ngoal (1 subgoal):\n 1. (\\<And>s1 s2.\n        val_ifex t2 s1 \\<noteq> val_ifex t2 s2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using IF.IH(2)[OF 2] IF.prems(1)"], ["proof (prove)\nusing this:\n  t2 = IF x31_ x32_ x33_\n  \\<lbrakk>t2 \\<noteq> Trueif; t2 \\<noteq> Falseif\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s1 s2. val_ifex t2 s1 \\<noteq> val_ifex t2 s2\n  reduced (IF x t1 t2) X\n\ngoal (1 subgoal):\n 1. (\\<And>s1 s2.\n        val_ifex t2 s1 \\<noteq> val_ifex t2 s2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  val_ifex t2 s1 \\<noteq> val_ifex t2 s2\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32 x33.\n       t2 = IF x31 x32 x33 \\<Longrightarrow>\n       \\<exists>s1 s2.\n          val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "hence \"val_ifex ?t (s1(x:=False)) \\<noteq> val_ifex ?t (s2(x:=False))\""], ["proof (prove)\nusing this:\n  val_ifex t2 s1 \\<noteq> val_ifex t2 s2\n\ngoal (1 subgoal):\n 1. val_ifex (IF x t1 t2) (s1(x := False)) \\<noteq>\n    val_ifex (IF x t1 t2) (s2(x := False))", "using same_val_if_reduced[OF 2, of \"s1(x:=False)\" s1]\n          same_val_if_reduced[OF 2, of \"s2(x:=False)\" s2]"], ["proof (prove)\nusing this:\n  val_ifex t2 s1 \\<noteq> val_ifex t2 s2\n  \\<forall>xa.\n     xa \\<notin> insert x X \\<longrightarrow>\n     (s1(x := False)) xa = s1 xa \\<Longrightarrow>\n  val_ifex t2 (s1(x := False)) = val_ifex t2 s1\n  \\<forall>xa.\n     xa \\<notin> insert x X \\<longrightarrow>\n     (s2(x := False)) xa = s2 xa \\<Longrightarrow>\n  val_ifex t2 (s2(x := False)) = val_ifex t2 s2\n\ngoal (1 subgoal):\n 1. val_ifex (IF x t1 t2) (s1(x := False)) \\<noteq>\n    val_ifex (IF x t1 t2) (s2(x := False))", "by simp"], ["proof (state)\nthis:\n  val_ifex (IF x t1 t2) (s1(x := False)) \\<noteq>\n  val_ifex (IF x t1 t2) (s2(x := False))\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32 x33.\n       t2 = IF x31 x32 x33 \\<Longrightarrow>\n       \\<exists>s1 s2.\n          val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "thus ?thesis"], ["proof (prove)\nusing this:\n  val_ifex (IF x t1 t2) (s1(x := False)) \\<noteq>\n  val_ifex (IF x t1 t2) (s2(x := False))\n\ngoal (1 subgoal):\n 1. \\<exists>s1 s2.\n       val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "by blast"], ["proof (state)\nthis:\n  \\<exists>s1 s2. val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s1 s2. val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2\n\ngoal (2 subgoals):\n 1. t1 = Falseif \\<Longrightarrow>\n    \\<exists>s1 s2.\n       val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2\n 2. \\<And>x31 x32 x33.\n       t1 = IF x31 x32 x33 \\<Longrightarrow>\n       \\<exists>s1 s2.\n          val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. t1 = Falseif \\<Longrightarrow>\n    \\<exists>s1 s2.\n       val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2\n 2. \\<And>x31 x32 x33.\n       t1 = IF x31 x32 x33 \\<Longrightarrow>\n       \\<exists>s1 s2.\n          val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "case [simp]: Falseif"], ["proof (state)\nthis:\n  t1 = Falseif\n\ngoal (2 subgoals):\n 1. t1 = Falseif \\<Longrightarrow>\n    \\<exists>s1 s2.\n       val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2\n 2. \\<And>x31 x32 x33.\n       t1 = IF x31 x32 x33 \\<Longrightarrow>\n       \\<exists>s1 s2.\n          val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s1 s2.\n       val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "proof (cases t2)"], ["proof (state)\ngoal (3 subgoals):\n 1. t2 = Trueif \\<Longrightarrow>\n    \\<exists>s1 s2.\n       val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2\n 2. t2 = Falseif \\<Longrightarrow>\n    \\<exists>s1 s2.\n       val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2\n 3. \\<And>x31 x32 x33.\n       t2 = IF x31 x32 x33 \\<Longrightarrow>\n       \\<exists>s1 s2.\n          val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "case Falseif"], ["proof (state)\nthis:\n  t2 = Falseif\n\ngoal (3 subgoals):\n 1. t2 = Trueif \\<Longrightarrow>\n    \\<exists>s1 s2.\n       val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2\n 2. t2 = Falseif \\<Longrightarrow>\n    \\<exists>s1 s2.\n       val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2\n 3. \\<And>x31 x32 x33.\n       t2 = IF x31 x32 x33 \\<Longrightarrow>\n       \\<exists>s1 s2.\n          val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "thus ?thesis"], ["proof (prove)\nusing this:\n  t2 = Falseif\n\ngoal (1 subgoal):\n 1. \\<exists>s1 s2.\n       val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "using IF.prems(1)"], ["proof (prove)\nusing this:\n  t2 = Falseif\n  reduced (IF x t1 t2) X\n\ngoal (1 subgoal):\n 1. \\<exists>s1 s2.\n       val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "by simp"], ["proof (state)\nthis:\n  \\<exists>s1 s2. val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2\n\ngoal (2 subgoals):\n 1. t2 = Trueif \\<Longrightarrow>\n    \\<exists>s1 s2.\n       val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2\n 2. \\<And>x31 x32 x33.\n       t2 = IF x31 x32 x33 \\<Longrightarrow>\n       \\<exists>s1 s2.\n          val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. t2 = Trueif \\<Longrightarrow>\n    \\<exists>s1 s2.\n       val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2\n 2. \\<And>x31 x32 x33.\n       t2 = IF x31 x32 x33 \\<Longrightarrow>\n       \\<exists>s1 s2.\n          val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "case Trueif"], ["proof (state)\nthis:\n  t2 = Trueif\n\ngoal (2 subgoals):\n 1. t2 = Trueif \\<Longrightarrow>\n    \\<exists>s1 s2.\n       val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2\n 2. \\<And>x31 x32 x33.\n       t2 = IF x31 x32 x33 \\<Longrightarrow>\n       \\<exists>s1 s2.\n          val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "hence \"val_ifex ?t (\\<lambda>_. True) \\<noteq> val_ifex ?t (\\<lambda>_. False)\""], ["proof (prove)\nusing this:\n  t2 = Trueif\n\ngoal (1 subgoal):\n 1. val_ifex (IF x t1 t2) (\\<lambda>_. True) \\<noteq>\n    val_ifex (IF x t1 t2) (\\<lambda>_. False)", "by simp"], ["proof (state)\nthis:\n  val_ifex (IF x t1 t2) (\\<lambda>_. True) \\<noteq>\n  val_ifex (IF x t1 t2) (\\<lambda>_. False)\n\ngoal (2 subgoals):\n 1. t2 = Trueif \\<Longrightarrow>\n    \\<exists>s1 s2.\n       val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2\n 2. \\<And>x31 x32 x33.\n       t2 = IF x31 x32 x33 \\<Longrightarrow>\n       \\<exists>s1 s2.\n          val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "thus ?thesis"], ["proof (prove)\nusing this:\n  val_ifex (IF x t1 t2) (\\<lambda>_. True) \\<noteq>\n  val_ifex (IF x t1 t2) (\\<lambda>_. False)\n\ngoal (1 subgoal):\n 1. \\<exists>s1 s2.\n       val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "by blast"], ["proof (state)\nthis:\n  \\<exists>s1 s2. val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32 x33.\n       t2 = IF x31 x32 x33 \\<Longrightarrow>\n       \\<exists>s1 s2.\n          val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x31 x32 x33.\n       t2 = IF x31 x32 x33 \\<Longrightarrow>\n       \\<exists>s1 s2.\n          val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "case IF"], ["proof (state)\nthis:\n  t2 = IF x31_ x32_ x33_\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32 x33.\n       t2 = IF x31 x32 x33 \\<Longrightarrow>\n       \\<exists>s1 s2.\n          val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "then"], ["proof (chain)\npicking this:\n  t2 = IF x31_ x32_ x33_", "obtain s1 s2 where \"val_ifex t2 s1 \\<noteq> val_ifex t2 s2\""], ["proof (prove)\nusing this:\n  t2 = IF x31_ x32_ x33_\n\ngoal (1 subgoal):\n 1. (\\<And>s1 s2.\n        val_ifex t2 s1 \\<noteq> val_ifex t2 s2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using IF.IH(2)[OF 2] IF.prems(1)"], ["proof (prove)\nusing this:\n  t2 = IF x31_ x32_ x33_\n  \\<lbrakk>t2 \\<noteq> Trueif; t2 \\<noteq> Falseif\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s1 s2. val_ifex t2 s1 \\<noteq> val_ifex t2 s2\n  reduced (IF x t1 t2) X\n\ngoal (1 subgoal):\n 1. (\\<And>s1 s2.\n        val_ifex t2 s1 \\<noteq> val_ifex t2 s2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  val_ifex t2 s1 \\<noteq> val_ifex t2 s2\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32 x33.\n       t2 = IF x31 x32 x33 \\<Longrightarrow>\n       \\<exists>s1 s2.\n          val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "hence \"val_ifex ?t (s1(x:=False)) \\<noteq> val_ifex ?t (s2(x:=False))\""], ["proof (prove)\nusing this:\n  val_ifex t2 s1 \\<noteq> val_ifex t2 s2\n\ngoal (1 subgoal):\n 1. val_ifex (IF x t1 t2) (s1(x := False)) \\<noteq>\n    val_ifex (IF x t1 t2) (s2(x := False))", "using same_val_if_reduced[OF 2, of \"s1(x:=False)\" s1]\n          same_val_if_reduced[OF 2, of \"s2(x:=False)\" s2]"], ["proof (prove)\nusing this:\n  val_ifex t2 s1 \\<noteq> val_ifex t2 s2\n  \\<forall>xa.\n     xa \\<notin> insert x X \\<longrightarrow>\n     (s1(x := False)) xa = s1 xa \\<Longrightarrow>\n  val_ifex t2 (s1(x := False)) = val_ifex t2 s1\n  \\<forall>xa.\n     xa \\<notin> insert x X \\<longrightarrow>\n     (s2(x := False)) xa = s2 xa \\<Longrightarrow>\n  val_ifex t2 (s2(x := False)) = val_ifex t2 s2\n\ngoal (1 subgoal):\n 1. val_ifex (IF x t1 t2) (s1(x := False)) \\<noteq>\n    val_ifex (IF x t1 t2) (s2(x := False))", "by simp"], ["proof (state)\nthis:\n  val_ifex (IF x t1 t2) (s1(x := False)) \\<noteq>\n  val_ifex (IF x t1 t2) (s2(x := False))\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32 x33.\n       t2 = IF x31 x32 x33 \\<Longrightarrow>\n       \\<exists>s1 s2.\n          val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "thus ?thesis"], ["proof (prove)\nusing this:\n  val_ifex (IF x t1 t2) (s1(x := False)) \\<noteq>\n  val_ifex (IF x t1 t2) (s2(x := False))\n\ngoal (1 subgoal):\n 1. \\<exists>s1 s2.\n       val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "by blast"], ["proof (state)\nthis:\n  \\<exists>s1 s2. val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s1 s2. val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32 x33.\n       t1 = IF x31 x32 x33 \\<Longrightarrow>\n       \\<exists>s1 s2.\n          val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x31 x32 x33.\n       t1 = IF x31 x32 x33 \\<Longrightarrow>\n       \\<exists>s1 s2.\n          val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "case IF"], ["proof (state)\nthis:\n  t1 = IF x31_ x32_ x33_\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32 x33.\n       t1 = IF x31 x32 x33 \\<Longrightarrow>\n       \\<exists>s1 s2.\n          val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "then"], ["proof (chain)\npicking this:\n  t1 = IF x31_ x32_ x33_", "obtain s1 s2 where \"val_ifex t1 s1 \\<noteq> val_ifex t1 s2\""], ["proof (prove)\nusing this:\n  t1 = IF x31_ x32_ x33_\n\ngoal (1 subgoal):\n 1. (\\<And>s1 s2.\n        val_ifex t1 s1 \\<noteq> val_ifex t1 s2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using IF.IH(1)[OF 1] IF.prems(1)"], ["proof (prove)\nusing this:\n  t1 = IF x31_ x32_ x33_\n  \\<lbrakk>t1 \\<noteq> Trueif; t1 \\<noteq> Falseif\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s1 s2. val_ifex t1 s1 \\<noteq> val_ifex t1 s2\n  reduced (IF x t1 t2) X\n\ngoal (1 subgoal):\n 1. (\\<And>s1 s2.\n        val_ifex t1 s1 \\<noteq> val_ifex t1 s2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  val_ifex t1 s1 \\<noteq> val_ifex t1 s2\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32 x33.\n       t1 = IF x31 x32 x33 \\<Longrightarrow>\n       \\<exists>s1 s2.\n          val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "hence \"val_ifex ?t (s1(x:=True)) \\<noteq> val_ifex ?t (s2(x:=True))\""], ["proof (prove)\nusing this:\n  val_ifex t1 s1 \\<noteq> val_ifex t1 s2\n\ngoal (1 subgoal):\n 1. val_ifex (IF x t1 t2) (s1(x := True)) \\<noteq>\n    val_ifex (IF x t1 t2) (s2(x := True))", "using same_val_if_reduced[OF 1, of \"s1(x:=True)\" s1]\n          same_val_if_reduced[OF 1, of \"s2(x:=True)\" s2]"], ["proof (prove)\nusing this:\n  val_ifex t1 s1 \\<noteq> val_ifex t1 s2\n  \\<forall>xa.\n     xa \\<notin> insert x X \\<longrightarrow>\n     (s1(x := True)) xa = s1 xa \\<Longrightarrow>\n  val_ifex t1 (s1(x := True)) = val_ifex t1 s1\n  \\<forall>xa.\n     xa \\<notin> insert x X \\<longrightarrow>\n     (s2(x := True)) xa = s2 xa \\<Longrightarrow>\n  val_ifex t1 (s2(x := True)) = val_ifex t1 s2\n\ngoal (1 subgoal):\n 1. val_ifex (IF x t1 t2) (s1(x := True)) \\<noteq>\n    val_ifex (IF x t1 t2) (s2(x := True))", "by simp"], ["proof (state)\nthis:\n  val_ifex (IF x t1 t2) (s1(x := True)) \\<noteq>\n  val_ifex (IF x t1 t2) (s2(x := True))\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32 x33.\n       t1 = IF x31 x32 x33 \\<Longrightarrow>\n       \\<exists>s1 s2.\n          val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "thus ?thesis"], ["proof (prove)\nusing this:\n  val_ifex (IF x t1 t2) (s1(x := True)) \\<noteq>\n  val_ifex (IF x t1 t2) (s2(x := True))\n\ngoal (1 subgoal):\n 1. \\<exists>s1 s2.\n       val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2", "by blast"], ["proof (state)\nthis:\n  \\<exists>s1 s2. val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s1 s2. val_ifex (IF x t1 t2) s1 \\<noteq> val_ifex (IF x t1 t2) s2\n\ngoal (2 subgoals):\n 1. \\<And>X.\n       \\<lbrakk>reduced Trueif X; Trueif \\<noteq> Trueif;\n        Trueif \\<noteq> Falseif\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 s2.\n                            val_ifex Trueif s1 \\<noteq> val_ifex Trueif s2\n 2. \\<And>X.\n       \\<lbrakk>reduced Falseif X; Falseif \\<noteq> Trueif;\n        Falseif \\<noteq> Falseif\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 s2.\n                            val_ifex Falseif s1 \\<noteq> val_ifex Falseif s2", "qed auto"], ["", "corollary taut_test: \n  \"taut_test ifex_of b = (\\<forall>s. val b s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. taut_test ifex_of b = (\\<forall>s. val b s)", "by (metis taut_test_def reduced_IF_depends[OF reduced_ifex] val_ifex val_ifex.simps(1,2))"], ["", "corollary sat_test: \n  \"sat_test ifex_of b = (\\<exists>s. val b s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sat_test ifex_of b = (\\<exists>s. val b s)", "by (metis sat_test_def reduced_IF_depends[OF reduced_ifex] val_ifex val_ifex.simps(1,2))"], ["", "corollary impl_test: \n  \"impl_test ifex_of b1 b2 = (\\<forall>s. val b1 s \\<longrightarrow> val b2 s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. impl_test ifex_of b1 b2 =\n    (\\<forall>s. val b1 s \\<longrightarrow> val b2 s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. impl_test ifex_of b1 b2 =\n    (\\<forall>s. val b1 s \\<longrightarrow> val b2 s)", "have \"impl_test ifex_of b1 b2 = (\\<forall>s. val_ifex (normif Mapping.empty (ifex_of b1) (ifex_of b2) Trueif) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. impl_test ifex_of b1 b2 =\n    (\\<forall>s.\n        val_ifex (normif Mapping.empty (ifex_of b1) (ifex_of b2) Trueif) s)", "using reduced_IF_depends[OF reduced_normif]"], ["proof (prove)\nusing this:\n  \\<lbrakk>normif ?env1 ?t1 ?t1.1 ?t2.1 \\<noteq> Trueif;\n   normif ?env1 ?t1 ?t1.1 ?t2.1 \\<noteq> Falseif\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s1 s2.\n                       val_ifex (normif ?env1 ?t1 ?t1.1 ?t2.1) s1 \\<noteq>\n                       val_ifex (normif ?env1 ?t1 ?t1.1 ?t2.1) s2\n\ngoal (1 subgoal):\n 1. impl_test ifex_of b1 b2 =\n    (\\<forall>s.\n        val_ifex (normif Mapping.empty (ifex_of b1) (ifex_of b2) Trueif) s)", "by (fastforce  simp: impl_test_def)"], ["proof (state)\nthis:\n  impl_test ifex_of b1 b2 =\n  (\\<forall>s.\n      val_ifex (normif Mapping.empty (ifex_of b1) (ifex_of b2) Trueif) s)\n\ngoal (1 subgoal):\n 1. impl_test ifex_of b1 b2 =\n    (\\<forall>s. val b1 s \\<longrightarrow> val b2 s)", "also"], ["proof (state)\nthis:\n  impl_test ifex_of b1 b2 =\n  (\\<forall>s.\n      val_ifex (normif Mapping.empty (ifex_of b1) (ifex_of b2) Trueif) s)\n\ngoal (1 subgoal):\n 1. impl_test ifex_of b1 b2 =\n    (\\<forall>s. val b1 s \\<longrightarrow> val b2 s)", "have \"(\\<forall>s. val_ifex (normif Mapping.empty (ifex_of b1) (ifex_of b2) Trueif) s) \\<longleftrightarrow> (\\<forall>s. val b1 s \\<longrightarrow> val b2 s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>s.\n        val_ifex (normif Mapping.empty (ifex_of b1) (ifex_of b2) Trueif)\n         s) =\n    (\\<forall>s. val b1 s \\<longrightarrow> val b2 s)", "using reduced_IF_depends[OF reduced_ifex] val_ifex"], ["proof (prove)\nusing this:\n  \\<lbrakk>ifex_of ?b1 \\<noteq> Trueif;\n   ifex_of ?b1 \\<noteq> Falseif\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s1 s2.\n                       val_ifex (ifex_of ?b1) s1 \\<noteq>\n                       val_ifex (ifex_of ?b1) s2\n  val_ifex (ifex_of ?b) ?s = val ?b ?s\n\ngoal (1 subgoal):\n 1. (\\<forall>s.\n        val_ifex (normif Mapping.empty (ifex_of b1) (ifex_of b2) Trueif)\n         s) =\n    (\\<forall>s. val b1 s \\<longrightarrow> val b2 s)", "unfolding val_normif[OF agree_Nil]"], ["proof (prove)\nusing this:\n  \\<lbrakk>ifex_of ?b1 \\<noteq> Trueif;\n   ifex_of ?b1 \\<noteq> Falseif\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s1 s2.\n                       val_ifex (ifex_of ?b1) s1 \\<noteq>\n                       val_ifex (ifex_of ?b1) s2\n  val_ifex (ifex_of ?b) ?s = val ?b ?s\n\ngoal (1 subgoal):\n 1. (\\<forall>s.\n        val_ifex (if val_ifex (ifex_of b1) s then ifex_of b2 else Trueif)\n         s) =\n    (\\<forall>s. val b1 s \\<longrightarrow> val b2 s)", "by simp"], ["proof (state)\nthis:\n  (\\<forall>s.\n      val_ifex (normif Mapping.empty (ifex_of b1) (ifex_of b2) Trueif) s) =\n  (\\<forall>s. val b1 s \\<longrightarrow> val b2 s)\n\ngoal (1 subgoal):\n 1. impl_test ifex_of b1 b2 =\n    (\\<forall>s. val b1 s \\<longrightarrow> val b2 s)", "finally"], ["proof (chain)\npicking this:\n  impl_test ifex_of b1 b2 =\n  (\\<forall>s. val b1 s \\<longrightarrow> val b2 s)", "show ?thesis"], ["proof (prove)\nusing this:\n  impl_test ifex_of b1 b2 =\n  (\\<forall>s. val b1 s \\<longrightarrow> val b2 s)\n\ngoal (1 subgoal):\n 1. impl_test ifex_of b1 b2 =\n    (\\<forall>s. val b1 s \\<longrightarrow> val b2 s)", "."], ["proof (state)\nthis:\n  impl_test ifex_of b1 b2 =\n  (\\<forall>s. val b1 s \\<longrightarrow> val b2 s)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary equiv_test: \n  \"equiv_test ifex_of b1 b2 = (\\<forall>s. val b1 s = val b2 s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv_test ifex_of b1 b2 = (\\<forall>s. val b1 s = val b2 s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. equiv_test ifex_of b1 b2 = (\\<forall>s. val b1 s = val b2 s)", "have \"equiv_test ifex_of b1 b2 = (\\<forall>s. val_ifex (let t1 = ifex_of b1; t2 = ifex_of b2 in normif Mapping.empty t1 t2 (normif Mapping.empty t2 Falseif Trueif)) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv_test ifex_of b1 b2 =\n    (\\<forall>s.\n        val_ifex\n         (let t1 = ifex_of b1; t2 = ifex_of b2\n          in normif Mapping.empty t1 t2\n              (normif Mapping.empty t2 Falseif Trueif))\n         s)", "by (simp add: equiv_test_def Let_def; insert reduced_IF_depends[OF reduced_normif]; force)"], ["proof (state)\nthis:\n  equiv_test ifex_of b1 b2 =\n  (\\<forall>s.\n      val_ifex\n       (let t1 = ifex_of b1; t2 = ifex_of b2\n        in normif Mapping.empty t1 t2\n            (normif Mapping.empty t2 Falseif Trueif))\n       s)\n\ngoal (1 subgoal):\n 1. equiv_test ifex_of b1 b2 = (\\<forall>s. val b1 s = val b2 s)", "moreover"], ["proof (state)\nthis:\n  equiv_test ifex_of b1 b2 =\n  (\\<forall>s.\n      val_ifex\n       (let t1 = ifex_of b1; t2 = ifex_of b2\n        in normif Mapping.empty t1 t2\n            (normif Mapping.empty t2 Falseif Trueif))\n       s)\n\ngoal (1 subgoal):\n 1. equiv_test ifex_of b1 b2 = (\\<forall>s. val b1 s = val b2 s)", "{"], ["proof (state)\nthis:\n  equiv_test ifex_of b1 b2 =\n  (\\<forall>s.\n      val_ifex\n       (let t1 = ifex_of b1; t2 = ifex_of b2\n        in normif Mapping.empty t1 t2\n            (normif Mapping.empty t2 Falseif Trueif))\n       s)\n\ngoal (1 subgoal):\n 1. equiv_test ifex_of b1 b2 = (\\<forall>s. val b1 s = val b2 s)", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. equiv_test ifex_of b1 b2 = (\\<forall>s. val b1 s = val b2 s)", "have \"val_ifex (let t1 = ifex_of b1; t2 = ifex_of b2 in normif Mapping.empty t1 t2 (normif Mapping.empty t2 Falseif Trueif)) s\n      = (val b1 s = val b2 s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val_ifex\n     (let t1 = ifex_of b1; t2 = ifex_of b2\n      in normif Mapping.empty t1 t2\n          (normif Mapping.empty t2 Falseif Trueif))\n     s =\n    (val b1 s = val b2 s)", "using val_ifex"], ["proof (prove)\nusing this:\n  val_ifex (ifex_of ?b) ?s = val ?b ?s\n\ngoal (1 subgoal):\n 1. val_ifex\n     (let t1 = ifex_of b1; t2 = ifex_of b2\n      in normif Mapping.empty t1 t2\n          (normif Mapping.empty t2 Falseif Trueif))\n     s =\n    (val b1 s = val b2 s)", "by (simp add: Let_def val_normif[OF agree_Nil])"], ["proof (state)\nthis:\n  val_ifex\n   (let t1 = ifex_of b1; t2 = ifex_of b2\n    in normif Mapping.empty t1 t2 (normif Mapping.empty t2 Falseif Trueif))\n   s =\n  (val b1 s = val b2 s)\n\ngoal (1 subgoal):\n 1. equiv_test ifex_of b1 b2 = (\\<forall>s. val b1 s = val b2 s)", "}"], ["proof (state)\nthis:\n  val_ifex\n   (let t1 = ifex_of b1; t2 = ifex_of b2\n    in normif Mapping.empty t1 t2 (normif Mapping.empty t2 Falseif Trueif))\n   ?s2 =\n  (val b1 ?s2 = val b2 ?s2)\n\ngoal (1 subgoal):\n 1. equiv_test ifex_of b1 b2 = (\\<forall>s. val b1 s = val b2 s)", "ultimately"], ["proof (chain)\npicking this:\n  equiv_test ifex_of b1 b2 =\n  (\\<forall>s.\n      val_ifex\n       (let t1 = ifex_of b1; t2 = ifex_of b2\n        in normif Mapping.empty t1 t2\n            (normif Mapping.empty t2 Falseif Trueif))\n       s)\n  val_ifex\n   (let t1 = ifex_of b1; t2 = ifex_of b2\n    in normif Mapping.empty t1 t2 (normif Mapping.empty t2 Falseif Trueif))\n   ?s2 =\n  (val b1 ?s2 = val b2 ?s2)", "show ?thesis"], ["proof (prove)\nusing this:\n  equiv_test ifex_of b1 b2 =\n  (\\<forall>s.\n      val_ifex\n       (let t1 = ifex_of b1; t2 = ifex_of b2\n        in normif Mapping.empty t1 t2\n            (normif Mapping.empty t2 Falseif Trueif))\n       s)\n  val_ifex\n   (let t1 = ifex_of b1; t2 = ifex_of b2\n    in normif Mapping.empty t1 t2 (normif Mapping.empty t2 Falseif Trueif))\n   ?s2 =\n  (val b1 ?s2 = val b2 ?s2)\n\ngoal (1 subgoal):\n 1. equiv_test ifex_of b1 b2 = (\\<forall>s. val b1 s = val b2 s)", "by blast"], ["proof (state)\nthis:\n  equiv_test ifex_of b1 b2 = (\\<forall>s. val b1 s = val b2 s)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Boolean Expressions\\<close>"], ["", "text \\<open>This is the simplified interface to the tautology checker. If you have your own type of Boolean \nexpressions you can either define your own translation to reduced binary decision trees or you can just \ntranslate into this type.\\<close>"], ["", "datatype 'a bool_expr =\n  Const_bool_expr bool |\n  Atom_bool_expr 'a |\n  Neg_bool_expr \"'a bool_expr\" |\n  And_bool_expr \"'a bool_expr\" \"'a bool_expr\" |\n  Or_bool_expr \"'a bool_expr\" \"'a bool_expr\" |\n  Imp_bool_expr \"'a bool_expr\" \"'a bool_expr\" |\n  Iff_bool_expr \"'a bool_expr\" \"'a bool_expr\""], ["", "primrec val_bool_expr :: \"'a bool_expr \\<Rightarrow> ('a \\<Rightarrow> bool) \\<Rightarrow> bool\" where\n\"val_bool_expr (Const_bool_expr b) s = b\" |\n\"val_bool_expr (Atom_bool_expr x) s = s x\" |\n\"val_bool_expr (Neg_bool_expr b) s = (\\<not> val_bool_expr b s)\" |\n\"val_bool_expr (And_bool_expr b1 b2) s = (val_bool_expr b1 s \\<and> val_bool_expr b2 s)\" |\n\"val_bool_expr (Or_bool_expr b1 b2) s = (val_bool_expr b1 s \\<or> val_bool_expr b2 s)\" |\n\"val_bool_expr (Imp_bool_expr b1 b2) s = (val_bool_expr b1 s \\<longrightarrow> val_bool_expr b2 s)\" |\n\"val_bool_expr (Iff_bool_expr b1 b2) s = (val_bool_expr b1 s = val_bool_expr b2 s)\""], ["", "fun ifex_of :: \"'a bool_expr \\<Rightarrow> 'a ifex\" where\n\"ifex_of (Const_bool_expr b) = (if b then Trueif else Falseif)\" |\n\"ifex_of (Atom_bool_expr x)   = IF x Trueif Falseif\" |\n\"ifex_of (Neg_bool_expr b)   = normif Mapping.empty (ifex_of b) Falseif Trueif\" |\n\"ifex_of (And_bool_expr b1 b2) = normif Mapping.empty (ifex_of b1) (ifex_of b2) Falseif\" |\n\"ifex_of (Or_bool_expr b1 b2) = normif Mapping.empty (ifex_of b1) Trueif (ifex_of b2)\" |\n\"ifex_of (Imp_bool_expr b1 b2) = normif Mapping.empty (ifex_of b1) (ifex_of b2) Trueif\" |\n\"ifex_of (Iff_bool_expr b1 b2) = (let t1 = ifex_of b1; t2 = ifex_of b2 in\n   normif Mapping.empty t1 t2 (normif Mapping.empty t2 Falseif Trueif))\""], ["", "theorem val_ifex:\n  \"val_ifex (ifex_of b) s = val_bool_expr b s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val_ifex (ifex_of b) s = val_bool_expr b s", "by (induct_tac b) (auto simp: val_normif agree_Nil Let_def)"], ["", "theorem reduced_ifex: \n  \"reduced (ifex_of b) {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced (ifex_of b) {}", "by (induction b) (simp add: Let_def; metis keys_empty reduced_normif)+"], ["", "definition \"bool_taut_test \\<equiv> taut_test ifex_of\""], ["", "definition \"bool_sat_test \\<equiv> sat_test ifex_of\""], ["", "definition \"bool_impl_test \\<equiv> impl_test ifex_of\""], ["", "definition \"bool_equiv_test \\<equiv> equiv_test ifex_of\""], ["", "lemma bool_tests:\n  \"bool_taut_test b = (\\<forall>s. val_bool_expr b s)\" (is ?t1)\n  \"bool_sat_test b = (\\<exists>s. val_bool_expr b s)\" (is ?t2)\n  \"bool_impl_test b1 b2 = (\\<forall>s. val_bool_expr b1 s \\<longrightarrow> val_bool_expr b2 s)\" (is ?t3)\n  \"bool_equiv_test b1 b2 = (\\<forall>s. val_bool_expr b1 s \\<longleftrightarrow> val_bool_expr b2 s)\" (is ?t4)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (bool_taut_test b = (\\<forall>s. val_bool_expr b s) &&&\n     bool_sat_test b = (\\<exists>s. val_bool_expr b s)) &&&\n    bool_impl_test b1 b2 =\n    (\\<forall>s.\n        val_bool_expr b1 s \\<longrightarrow> val_bool_expr b2 s) &&&\n    bool_equiv_test b1 b2 =\n    (\\<forall>s. val_bool_expr b1 s = val_bool_expr b2 s)", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. bool_taut_test b = (\\<forall>s. val_bool_expr b s)\n 2. bool_sat_test b = (\\<exists>s. val_bool_expr b s)\n 3. bool_impl_test b1 b2 =\n    (\\<forall>s. val_bool_expr b1 s \\<longrightarrow> val_bool_expr b2 s)\n 4. bool_equiv_test b1 b2 =\n    (\\<forall>s. val_bool_expr b1 s = val_bool_expr b2 s)", "interpret reduced_bdt_checkers ifex_of val_bool_expr"], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_bdt_checkers ifex_of val_bool_expr", "by (unfold_locales; insert val_ifex reduced_ifex; blast)"], ["proof (state)\ngoal (4 subgoals):\n 1. bool_taut_test b = (\\<forall>s. val_bool_expr b s)\n 2. bool_sat_test b = (\\<exists>s. val_bool_expr b s)\n 3. bool_impl_test b1 b2 =\n    (\\<forall>s. val_bool_expr b1 s \\<longrightarrow> val_bool_expr b2 s)\n 4. bool_equiv_test b1 b2 =\n    (\\<forall>s. val_bool_expr b1 s = val_bool_expr b2 s)", "show ?t1 ?t2 ?t3 ?t4"], ["proof (prove)\ngoal (1 subgoal):\n 1. (bool_taut_test b = (\\<forall>s. val_bool_expr b s) &&&\n     bool_sat_test b = (\\<exists>s. val_bool_expr b s)) &&&\n    bool_impl_test b1 b2 =\n    (\\<forall>s.\n        val_bool_expr b1 s \\<longrightarrow> val_bool_expr b2 s) &&&\n    bool_equiv_test b1 b2 =\n    (\\<forall>s. val_bool_expr b1 s = val_bool_expr b2 s)", "by (simp_all add: bool_taut_test_def bool_sat_test_def bool_impl_test_def bool_equiv_test_def taut_test sat_test impl_test equiv_test)"], ["proof (state)\nthis:\n  bool_taut_test b = (\\<forall>s. val_bool_expr b s)\n  bool_sat_test b = (\\<exists>s. val_bool_expr b s)\n  bool_impl_test b1 b2 =\n  (\\<forall>s. val_bool_expr b1 s \\<longrightarrow> val_bool_expr b2 s)\n  bool_equiv_test b1 b2 =\n  (\\<forall>s. val_bool_expr b1 s = val_bool_expr b2 s)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}