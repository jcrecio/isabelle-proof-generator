{"file_name": "/home/qj213/afp-2021-10-22/thys/Boolean_Expression_Checkers/Boolean_Expression_Example.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Boolean_Expression_Checkers", "problem_names": ["lemma val_preservation: \n  \"val_bool_expr (bool_expr_of_bexp b) s = bval b s\"", "lemma val_ifex: \n  \"val_ifex (ifex_of b) s = bval b s\"", "theorem reduced_ifex: \n  \"reduced (ifex_of b) {}\"", "lemma \"my_taut_test_bool (php 6)\"", "lemma \"my_taut_test_ifex (php 6)\""], "translations": [["", "lemma val_preservation: \n  \"val_bool_expr (bool_expr_of_bexp b) s = bval b s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val_bool_expr (bool_expr_of_bexp b) s = bval b s", "by (induction b) auto"], ["", "definition \"my_taut_test_bool = bool_taut_test o bool_expr_of_bexp\""], ["", "corollary my_taut_test: \n  \"my_taut_test_bool b = (\\<forall>s. bval b s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. my_taut_test_bool b = (\\<forall>s. bval b s)", "by (simp add: my_taut_test_bool_def val_preservation bool_tests)"], ["", "subsection \\<open>Direct Translation into Reduced Binary Decision Trees\\<close>"], ["", "text \\<open>Now we translate into a reduced binary decision tree, show that the semantics remains the same and \n  the tree is reduced:\\<close>"], ["", "fun ifex_of :: \"'a bexp \\<Rightarrow> 'a ifex\" \nwhere\n  \"ifex_of (Const b) = (if b then Trueif else Falseif)\" \n| \"ifex_of (Atom a) = IF a Trueif Falseif\" \n| \"ifex_of (Neg b)   = normif Mapping.empty (ifex_of b) Falseif Trueif\" \n| \"ifex_of (And b1 b2) = normif Mapping.empty (ifex_of b1) (ifex_of b2) Falseif\""], ["", "lemma val_ifex: \n  \"val_ifex (ifex_of b) s = bval b s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val_ifex (Boolean_Expression_Example.ifex_of b) s = bval b s", "by (induction b) (simp_all add: agree_Nil val_normif)"], ["", "theorem reduced_ifex: \n  \"reduced (ifex_of b) {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced (Boolean_Expression_Example.ifex_of b) {}", "by (induction b) (simp; metis keys_empty reduced_normif)+"], ["", "definition \"my_taut_test_ifex = taut_test ifex_of\""], ["", "corollary my_taut_test_ifex: \n  \"my_taut_test_ifex b = (\\<forall>s. bval b s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. my_taut_test_ifex b = (\\<forall>s. bval b s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. my_taut_test_ifex b = (\\<forall>s. bval b s)", "interpret reduced_bdt_checkers ifex_of bval"], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_bdt_checkers Boolean_Expression_Example.ifex_of bval", "by (unfold_locales; insert val_ifex reduced_ifex; blast)"], ["proof (state)\ngoal (1 subgoal):\n 1. my_taut_test_ifex b = (\\<forall>s. bval b s)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. my_taut_test_ifex b = (\\<forall>s. bval b s)", "by (simp add: my_taut_test_ifex_def taut_test)"], ["proof (state)\nthis:\n  my_taut_test_ifex b = (\\<forall>s. bval b s)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Test: Pigeonhole Formulas\\<close>"], ["", "definition \"Or b1 b2 == Neg (And (Neg b1) (Neg b2))\""], ["", "definition \"ors = foldl Or (Const False)\""], ["", "definition \"ands = foldl And (Const True)\""], ["", "definition \"pc n = ands[ors[Atom(i,j). j <- [1..<n+1]]. i <- [1..<n+2]]\""], ["", "definition \"nc n = ands[Or (Neg(Atom(i,k))) (Neg(Atom(j,k))). k <- [1..<n+1], i <- [1..<n+1], j <- [i+1..<n+2]]\""], ["", "definition \"php n = Neg(And (pc n) (nc n))\""], ["", "text \\<open>Takes about 5 secs each; with 7 instead of 6 it takes about 4 mins (2015).\\<close>"], ["", "lemma \"my_taut_test_bool (php 6)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. my_taut_test_bool (php 6)", "by eval"], ["", "lemma \"my_taut_test_ifex (php 6)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. my_taut_test_ifex (php 6)", "by eval"], ["", "end"]]}