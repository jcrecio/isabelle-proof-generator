{"file_name": "/home/qj213/afp-2021-10-22/thys/Transitive-Closure/Finite_Transitive_Closure_Simprocs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Transitive-Closure", "problem_names": ["lemma rtrancl_Image_eq:\n  assumes \"r = set r'\" and \"x = set x'\"\n  shows \"r\\<^sup>* `` x = set (rtrancl_list_impl r' x')\"", "lemma trancl_Image_eq:\n  assumes \"r = set r'\" and \"x = set x'\"\n  shows \"r\\<^sup>+ `` x = set (trancl_list_impl r' x')\"", "lemma\n  \"{(1::nat, 2), (2, 3), (3, 4), (4, 5)}\\<^sup>* `` {1} = {1, 2, 3, 4, 5}\"\n  \"{(1::nat, 2), (2, 3), (3, 4), (4, 5)}\\<^sup>+ `` {1} = {2, 3, 4, 5}\"", "lemma\n  \"{(x, y)}\\<^sup>* `` {x} = {x, y}\""], "translations": [["", "lemma rtrancl_Image_eq:\n  assumes \"r = set r'\" and \"x = set x'\"\n  shows \"r\\<^sup>* `` x = set (rtrancl_list_impl r' x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r\\<^sup>* `` x = set (rtrancl_list_impl r' x')", "using assms"], ["proof (prove)\nusing this:\n  r = set r'\n  x = set x'\n\ngoal (1 subgoal):\n 1. r\\<^sup>* `` x = set (rtrancl_list_impl r' x')", "by (auto simp: rtrancl_list_impl)"], ["", "lemma trancl_Image_eq:\n  assumes \"r = set r'\" and \"x = set x'\"\n  shows \"r\\<^sup>+ `` x = set (trancl_list_impl r' x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r\\<^sup>+ `` x = set (trancl_list_impl r' x')", "using assms"], ["proof (prove)\nusing this:\n  r = set r'\n  x = set x'\n\ngoal (1 subgoal):\n 1. r\\<^sup>+ `` x = set (trancl_list_impl r' x')", "by (auto simp: trancl_list_impl)"], ["", "subsection \\<open>A Simproc for Computing the Images of Finite Transitive Closures\\<close>"], ["", "ML \\<open>\nsignature FINITE_TRANCL_IMAGE =\nsig\n  val trancl_simproc : Proof.context -> cterm -> thm option\n  val rtrancl_simproc : Proof.context -> cterm -> thm option\nend\n\nstructure Finite_Trancl_Image : FINITE_TRANCL_IMAGE =\nstruct\n\nfun eval_tac ctxt =\n  let val conv = Code_Runtime.dynamic_holds_conv ctxt\n  in CONVERSION (Conv.params_conv ~1 (K (Conv.concl_conv ~1 conv)) ctxt) THEN' resolve_tac ctxt [TrueI] end\n\nfun mk_rtrancl T = Const (@{const_name rtrancl_list_impl}, T);\n\nfun mk_trancl T = Const (@{const_name trancl_list_impl}, T);\n\nfun dest_rtrancl_Image\n      (Const (@{const_name Image}, T) $ (Const (@{const_name rtrancl}, _) $ r) $ x) = (T, r, x)\n  | dest_rtrancl_Image _ = raise Match\n\nfun dest_trancl_Image\n      (Const (@{const_name Image}, T) $ (Const (@{const_name trancl}, _) $ r) $ x) = (T, r, x)\n  | dest_trancl_Image _ = raise Match\n\nfun gen_simproc dest mk_const eq_thm ctxt ct =\n  let\n    val t = Thm.term_of ct;\n    val (T, r, x) = t |> dest;\n  in\n    (*make sure that the relation as well as the given domain are finite sets*)\n    (case (try HOLogic.dest_set r, try HOLogic.dest_set x) of\n      (SOME xs, SOME ys) =>\n        let\n          (*types*)\n          val setT = T |> dest_funT |> snd |> dest_funT |> fst;\n          val eltT = setT |> HOLogic.dest_setT;\n          val prodT = HOLogic.mk_prodT (eltT, eltT);\n          val prod_listT = HOLogic.listT prodT;\n          val listT = HOLogic.listT eltT;\n\n          (*terms*)\n          val set = Const (@{const_name List.set}, listT --> setT);\n          val const = mk_const (prod_listT --> listT --> listT);\n          val r' = HOLogic.mk_list prodT xs;\n          val x' = HOLogic.mk_list eltT ys;\n          val t' = set $ (const $ r' $ x')\n          val u = Value_Command.value ctxt t';\n          val eval = (t', u) |> HOLogic.mk_eq |> HOLogic.mk_Trueprop;\n\n          val maybe_rule =\n            try (Goal.prove ctxt [] [] eval) (fn {context, ...} => eval_tac context 1);\n        in\n          (case maybe_rule of\n            SOME rule =>\n            let\n              val conv = (t, t') |> HOLogic.mk_eq |> HOLogic.mk_Trueprop;\n              val eq_thm' = Goal.prove ctxt [] [] conv (fn {context = ctxt', ...} =>\n                resolve_tac ctxt' [eq_thm] 1 THEN REPEAT (simp_tac ctxt' 1));\n            in\n              SOME (@{thm HOL.trans} OF [eq_thm', rule] RS @{thm eq_reflection})\n            end\n          | NONE => NONE)\n        end\n    | _ => NONE)\n  end\n\n\nval rtrancl_simproc = gen_simproc dest_rtrancl_Image mk_rtrancl @{thm rtrancl_Image_eq}\nval trancl_simproc = gen_simproc dest_trancl_Image mk_trancl @{thm trancl_Image_eq}\n\nend\n\\<close>"], ["", "simproc_setup rtrancl_Image (\"r\\<^sup>* `` x\") = \\<open>K Finite_Trancl_Image.rtrancl_simproc\\<close>"], ["", "simproc_setup trancl_Image  (\"r\\<^sup>+ `` x\") = \\<open>K Finite_Trancl_Image.trancl_simproc\\<close>"], ["", "subsection \\<open>Example\\<close>"], ["", "text \\<open>\n  The images of (reflexive) transitive closures are computed by evaluation.\n\\<close>"], ["", "lemma\n  \"{(1::nat, 2), (2, 3), (3, 4), (4, 5)}\\<^sup>* `` {1} = {1, 2, 3, 4, 5}\"\n  \"{(1::nat, 2), (2, 3), (3, 4), (4, 5)}\\<^sup>+ `` {1} = {2, 3, 4, 5}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(1, 2), (2, 3), (3, 4), (4, 5)}\\<^sup>* `` {1} = {1, 2, 3, 4, 5} &&&\n    {(1, 2), (2, 3), (3, 4), (4, 5)}\\<^sup>+ `` {1} = {2, 3, 4, 5}", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. {5, 4, 3, 2, Suc 0} = {Suc 0, 2, 3, 4, 5}\n 2. {5, 4, 3, 2} = {2, 3, 4, 5}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\n  Evaluation does not allow for free variables and thus fails in their presence.\n\\<close>"], ["", "lemma\n  \"{(x, y)}\\<^sup>* `` {x} = {x, y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y)}\\<^sup>* `` {x} = {x, y}", "oops"], ["", "end"]]}