{"file_name": "/home/qj213/afp-2021-10-22/thys/Transitive-Closure/Transitive_Closure_RBT_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Transitive-Closure", "problem_names": ["lemma rtrancl_rbt_impl:\n  \"rs.\\<alpha> (rtrancl_rbt_impl r as) = {b. \\<exists> a \\<in> set as. (a,b) \\<in> (set r)\\<^sup>*}\"", "lemma trancl_rbt_impl:\n  \"rs.\\<alpha> (trancl_rbt_impl r as) = {b. \\<exists> a \\<in> set as. (a,b) \\<in> (set r)\\<^sup>+}\"", "lemma memo_rbt_rtrancl:\n  \"rs.\\<alpha> (memo_rbt_rtrancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>*}\" (is \"?l = ?r\")", "lemma memo_rbt_trancl:\n  \"rs.\\<alpha> (memo_rbt_trancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>+}\" (is \"?l = ?r\")"], "translations": [["", "lemma rtrancl_rbt_impl:\n  \"rs.\\<alpha> (rtrancl_rbt_impl r as) = {b. \\<exists> a \\<in> set as. (a,b) \\<in> (set r)\\<^sup>*}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs.\\<alpha> (rtrancl_rbt_impl r as) =\n    {b. \\<exists>a\\<in>set as. (a, b) \\<in> (set r)\\<^sup>*}", "unfolding rtrancl_rbt_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs.\\<alpha>\n     (rtrancl_impl rm_succ (\\<lambda>as bs. rs.union bs (rs.from_list as))\n       rs.memb (rs.empty ()) r as) =\n    {b. \\<exists>a\\<in>set as. (a, b) \\<in> (set r)\\<^sup>*}", "by (rule set_access_gen.rtrancl_impl, unfold_locales, unfold Let_def, simp add: rs.correct elem_list_to_rm.rm_set_lookup, force)"], ["", "lemma trancl_rbt_impl:\n  \"rs.\\<alpha> (trancl_rbt_impl r as) = {b. \\<exists> a \\<in> set as. (a,b) \\<in> (set r)\\<^sup>+}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs.\\<alpha> (trancl_rbt_impl r as) =\n    {b. \\<exists>a\\<in>set as. (a, b) \\<in> (set r)\\<^sup>+}", "unfolding trancl_rbt_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs.\\<alpha>\n     (trancl_impl rm_succ (\\<lambda>as bs. rs.union bs (rs.from_list as))\n       rs.memb (rs.empty ()) r as) =\n    {b. \\<exists>a\\<in>set as. (a, b) \\<in> (set r)\\<^sup>+}", "by (rule set_access_gen.trancl_impl, unfold_locales, unfold Let_def, simp add: rs.correct elem_list_to_rm.rm_set_lookup, force)"], ["", "subsection \\<open>Precomputing Closures for Single States\\<close>"], ["", "text \\<open>\n  Storing all relevant entries is done by mapping all left-hand sides of the relation to their\n  closure. Since we assume a linear order on the carrier, for the lookup we can use maps that are\n  implemented as red black trees.\n\\<close>"], ["", "definition memo_rbt_rtrancl :: \"('a :: linorder \\<times> 'a) list \\<Rightarrow> ('a \\<Rightarrow> 'a rs)\"\nwhere\n  \"memo_rbt_rtrancl r =\n    (let \n      tr = rtrancl_rbt_impl r;\n      rm = rm.to_map (map (\\<lambda> a. (a, tr [a])) ((rs.to_list \\<circ> rs.from_list \\<circ> map fst) r))\n    in\n      (\\<lambda>a. case rm.lookup a rm of \n        None \\<Rightarrow> rs.from_list [a] \n      | Some as \\<Rightarrow> as))\""], ["", "lemma memo_rbt_rtrancl:\n  \"rs.\\<alpha> (memo_rbt_rtrancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>*}\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs.\\<alpha> (memo_rbt_rtrancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>*}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rs.\\<alpha> (memo_rbt_rtrancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>*}", "let ?rm = \"rm.to_map\n    (map (\\<lambda>a. (a, rtrancl_rbt_impl r [a])) ((rs.to_list \\<circ> rs.from_list \\<circ> map fst) r))\""], ["proof (state)\ngoal (1 subgoal):\n 1. rs.\\<alpha> (memo_rbt_rtrancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>*}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs.\\<alpha> (memo_rbt_rtrancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>*}", "proof (cases \"rm.lookup a ?rm\")"], ["proof (state)\ngoal (2 subgoals):\n 1. rm.lookup a\n     (rm.to_map\n       (map (\\<lambda>a. (a, rtrancl_rbt_impl r [a]))\n         (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n            rs_ops \\<circ>\\<circ>\n           map)\n           fst r))) =\n    None \\<Longrightarrow>\n    rs.\\<alpha> (memo_rbt_rtrancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>*}\n 2. \\<And>aa.\n       rm.lookup a\n        (rm.to_map\n          (map (\\<lambda>a. (a, rtrancl_rbt_impl r [a]))\n            (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n               rs_ops \\<circ>\\<circ>\n              map)\n              fst r))) =\n       Some aa \\<Longrightarrow>\n       rs.\\<alpha> (memo_rbt_rtrancl r a) =\n       {b. (a, b) \\<in> (set r)\\<^sup>*}", "case None"], ["proof (state)\nthis:\n  rm.lookup a\n   (rm.to_map\n     (map (\\<lambda>a. (a, rtrancl_rbt_impl r [a]))\n       (((rs.to_list \\<circ>\\<circ> set_op_from_list) rs_ops \\<circ>\\<circ>\n         map)\n         fst r))) =\n  None\n\ngoal (2 subgoals):\n 1. rm.lookup a\n     (rm.to_map\n       (map (\\<lambda>a. (a, rtrancl_rbt_impl r [a]))\n         (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n            rs_ops \\<circ>\\<circ>\n           map)\n           fst r))) =\n    None \\<Longrightarrow>\n    rs.\\<alpha> (memo_rbt_rtrancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>*}\n 2. \\<And>aa.\n       rm.lookup a\n        (rm.to_map\n          (map (\\<lambda>a. (a, rtrancl_rbt_impl r [a]))\n            (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n               rs_ops \\<circ>\\<circ>\n              map)\n              fst r))) =\n       Some aa \\<Longrightarrow>\n       rs.\\<alpha> (memo_rbt_rtrancl r a) =\n       {b. (a, b) \\<in> (set r)\\<^sup>*}", "have one: \"?l = {a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs.\\<alpha> (memo_rbt_rtrancl r a) = {a}", "unfolding memo_rbt_rtrancl_def Let_def None"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs.\\<alpha>\n     (case None of None \\<Rightarrow> rs.from_list [a]\n      | Some as \\<Rightarrow> as) =\n    {a}", "by (simp add: rs.correct)"], ["proof (state)\nthis:\n  rs.\\<alpha> (memo_rbt_rtrancl r a) = {a}\n\ngoal (2 subgoals):\n 1. rm.lookup a\n     (rm.to_map\n       (map (\\<lambda>a. (a, rtrancl_rbt_impl r [a]))\n         (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n            rs_ops \\<circ>\\<circ>\n           map)\n           fst r))) =\n    None \\<Longrightarrow>\n    rs.\\<alpha> (memo_rbt_rtrancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>*}\n 2. \\<And>aa.\n       rm.lookup a\n        (rm.to_map\n          (map (\\<lambda>a. (a, rtrancl_rbt_impl r [a]))\n            (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n               rs_ops \\<circ>\\<circ>\n              map)\n              fst r))) =\n       Some aa \\<Longrightarrow>\n       rs.\\<alpha> (memo_rbt_rtrancl r a) =\n       {b. (a, b) \\<in> (set r)\\<^sup>*}", "from None [unfolded rm.lookup_correct [OF rm.invar], simplified rm.correct map_of_eq_None_iff]"], ["proof (chain)\npicking this:\n  a \\<notin> fst `\n             set (map (\\<lambda>a. (a, rtrancl_rbt_impl r [a]))\n                   (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n                      rs_ops \\<circ>\\<circ>\n                     map)\n                     fst r))", "have a: \"a \\<notin> fst ` set r\""], ["proof (prove)\nusing this:\n  a \\<notin> fst `\n             set (map (\\<lambda>a. (a, rtrancl_rbt_impl r [a]))\n                   (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n                      rs_ops \\<circ>\\<circ>\n                     map)\n                     fst r))\n\ngoal (1 subgoal):\n 1. a \\<notin> fst ` set r", "by (simp add: rs.correct, force)"], ["proof (state)\nthis:\n  a \\<notin> fst ` set r\n\ngoal (2 subgoals):\n 1. rm.lookup a\n     (rm.to_map\n       (map (\\<lambda>a. (a, rtrancl_rbt_impl r [a]))\n         (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n            rs_ops \\<circ>\\<circ>\n           map)\n           fst r))) =\n    None \\<Longrightarrow>\n    rs.\\<alpha> (memo_rbt_rtrancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>*}\n 2. \\<And>aa.\n       rm.lookup a\n        (rm.to_map\n          (map (\\<lambda>a. (a, rtrancl_rbt_impl r [a]))\n            (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n               rs_ops \\<circ>\\<circ>\n              map)\n              fst r))) =\n       Some aa \\<Longrightarrow>\n       rs.\\<alpha> (memo_rbt_rtrancl r a) =\n       {b. (a, b) \\<in> (set r)\\<^sup>*}", "{"], ["proof (state)\nthis:\n  a \\<notin> fst ` set r\n\ngoal (2 subgoals):\n 1. rm.lookup a\n     (rm.to_map\n       (map (\\<lambda>a. (a, rtrancl_rbt_impl r [a]))\n         (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n            rs_ops \\<circ>\\<circ>\n           map)\n           fst r))) =\n    None \\<Longrightarrow>\n    rs.\\<alpha> (memo_rbt_rtrancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>*}\n 2. \\<And>aa.\n       rm.lookup a\n        (rm.to_map\n          (map (\\<lambda>a. (a, rtrancl_rbt_impl r [a]))\n            (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n               rs_ops \\<circ>\\<circ>\n              map)\n              fst r))) =\n       Some aa \\<Longrightarrow>\n       rs.\\<alpha> (memo_rbt_rtrancl r a) =\n       {b. (a, b) \\<in> (set r)\\<^sup>*}", "fix b"], ["proof (state)\ngoal (2 subgoals):\n 1. rm.lookup a\n     (rm.to_map\n       (map (\\<lambda>a. (a, rtrancl_rbt_impl r [a]))\n         (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n            rs_ops \\<circ>\\<circ>\n           map)\n           fst r))) =\n    None \\<Longrightarrow>\n    rs.\\<alpha> (memo_rbt_rtrancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>*}\n 2. \\<And>aa.\n       rm.lookup a\n        (rm.to_map\n          (map (\\<lambda>a. (a, rtrancl_rbt_impl r [a]))\n            (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n               rs_ops \\<circ>\\<circ>\n              map)\n              fst r))) =\n       Some aa \\<Longrightarrow>\n       rs.\\<alpha> (memo_rbt_rtrancl r a) =\n       {b. (a, b) \\<in> (set r)\\<^sup>*}", "assume \"b \\<in> ?r\""], ["proof (state)\nthis:\n  b \\<in> {b. (a, b) \\<in> (set r)\\<^sup>*}\n\ngoal (2 subgoals):\n 1. rm.lookup a\n     (rm.to_map\n       (map (\\<lambda>a. (a, rtrancl_rbt_impl r [a]))\n         (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n            rs_ops \\<circ>\\<circ>\n           map)\n           fst r))) =\n    None \\<Longrightarrow>\n    rs.\\<alpha> (memo_rbt_rtrancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>*}\n 2. \\<And>aa.\n       rm.lookup a\n        (rm.to_map\n          (map (\\<lambda>a. (a, rtrancl_rbt_impl r [a]))\n            (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n               rs_ops \\<circ>\\<circ>\n              map)\n              fst r))) =\n       Some aa \\<Longrightarrow>\n       rs.\\<alpha> (memo_rbt_rtrancl r a) =\n       {b. (a, b) \\<in> (set r)\\<^sup>*}", "from this [unfolded rtrancl_power relpow_fun_conv]"], ["proof (chain)\npicking this:\n  b \\<in> {b. \\<exists>n f.\n                 f 0 = a \\<and>\n                 f n = b \\<and>\n                 (\\<forall>i<n. (f i, f (Suc i)) \\<in> set r)}", "obtain n f where \n        ab: \"f 0 = a \\<and> f n = b\" and steps: \"\\<And> i. i < n \\<Longrightarrow> (f i, f (Suc i)) \\<in> set r\""], ["proof (prove)\nusing this:\n  b \\<in> {b. \\<exists>n f.\n                 f 0 = a \\<and>\n                 f n = b \\<and>\n                 (\\<forall>i<n. (f i, f (Suc i)) \\<in> set r)}\n\ngoal (1 subgoal):\n 1. (\\<And>f n.\n        \\<lbrakk>f 0 = a \\<and> f n = b;\n         \\<And>i.\n            i < n \\<Longrightarrow> (f i, f (Suc i)) \\<in> set r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f 0 = a \\<and> f n = b\n  ?i < n \\<Longrightarrow> (f ?i, f (Suc ?i)) \\<in> set r\n\ngoal (2 subgoals):\n 1. rm.lookup a\n     (rm.to_map\n       (map (\\<lambda>a. (a, rtrancl_rbt_impl r [a]))\n         (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n            rs_ops \\<circ>\\<circ>\n           map)\n           fst r))) =\n    None \\<Longrightarrow>\n    rs.\\<alpha> (memo_rbt_rtrancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>*}\n 2. \\<And>aa.\n       rm.lookup a\n        (rm.to_map\n          (map (\\<lambda>a. (a, rtrancl_rbt_impl r [a]))\n            (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n               rs_ops \\<circ>\\<circ>\n              map)\n              fst r))) =\n       Some aa \\<Longrightarrow>\n       rs.\\<alpha> (memo_rbt_rtrancl r a) =\n       {b. (a, b) \\<in> (set r)\\<^sup>*}", "from ab steps [of 0] a"], ["proof (chain)\npicking this:\n  f 0 = a \\<and> f n = b\n  0 < n \\<Longrightarrow> (f 0, f (Suc 0)) \\<in> set r\n  a \\<notin> fst ` set r", "have \"b = a\""], ["proof (prove)\nusing this:\n  f 0 = a \\<and> f n = b\n  0 < n \\<Longrightarrow> (f 0, f (Suc 0)) \\<in> set r\n  a \\<notin> fst ` set r\n\ngoal (1 subgoal):\n 1. b = a", "by (cases n, force+)"], ["proof (state)\nthis:\n  b = a\n\ngoal (2 subgoals):\n 1. rm.lookup a\n     (rm.to_map\n       (map (\\<lambda>a. (a, rtrancl_rbt_impl r [a]))\n         (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n            rs_ops \\<circ>\\<circ>\n           map)\n           fst r))) =\n    None \\<Longrightarrow>\n    rs.\\<alpha> (memo_rbt_rtrancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>*}\n 2. \\<And>aa.\n       rm.lookup a\n        (rm.to_map\n          (map (\\<lambda>a. (a, rtrancl_rbt_impl r [a]))\n            (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n               rs_ops \\<circ>\\<circ>\n              map)\n              fst r))) =\n       Some aa \\<Longrightarrow>\n       rs.\\<alpha> (memo_rbt_rtrancl r a) =\n       {b. (a, b) \\<in> (set r)\\<^sup>*}", "}"], ["proof (state)\nthis:\n  ?b2 \\<in> {b. (a, b) \\<in> (set r)\\<^sup>*} \\<Longrightarrow> ?b2 = a\n\ngoal (2 subgoals):\n 1. rm.lookup a\n     (rm.to_map\n       (map (\\<lambda>a. (a, rtrancl_rbt_impl r [a]))\n         (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n            rs_ops \\<circ>\\<circ>\n           map)\n           fst r))) =\n    None \\<Longrightarrow>\n    rs.\\<alpha> (memo_rbt_rtrancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>*}\n 2. \\<And>aa.\n       rm.lookup a\n        (rm.to_map\n          (map (\\<lambda>a. (a, rtrancl_rbt_impl r [a]))\n            (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n               rs_ops \\<circ>\\<circ>\n              map)\n              fst r))) =\n       Some aa \\<Longrightarrow>\n       rs.\\<alpha> (memo_rbt_rtrancl r a) =\n       {b. (a, b) \\<in> (set r)\\<^sup>*}", "then"], ["proof (chain)\npicking this:\n  ?b2 \\<in> {b. (a, b) \\<in> (set r)\\<^sup>*} \\<Longrightarrow> ?b2 = a", "have \"?r = {a}\""], ["proof (prove)\nusing this:\n  ?b2 \\<in> {b. (a, b) \\<in> (set r)\\<^sup>*} \\<Longrightarrow> ?b2 = a\n\ngoal (1 subgoal):\n 1. {b. (a, b) \\<in> (set r)\\<^sup>*} = {a}", "by auto"], ["proof (state)\nthis:\n  {b. (a, b) \\<in> (set r)\\<^sup>*} = {a}\n\ngoal (2 subgoals):\n 1. rm.lookup a\n     (rm.to_map\n       (map (\\<lambda>a. (a, rtrancl_rbt_impl r [a]))\n         (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n            rs_ops \\<circ>\\<circ>\n           map)\n           fst r))) =\n    None \\<Longrightarrow>\n    rs.\\<alpha> (memo_rbt_rtrancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>*}\n 2. \\<And>aa.\n       rm.lookup a\n        (rm.to_map\n          (map (\\<lambda>a. (a, rtrancl_rbt_impl r [a]))\n            (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n               rs_ops \\<circ>\\<circ>\n              map)\n              fst r))) =\n       Some aa \\<Longrightarrow>\n       rs.\\<alpha> (memo_rbt_rtrancl r a) =\n       {b. (a, b) \\<in> (set r)\\<^sup>*}", "then"], ["proof (chain)\npicking this:\n  {b. (a, b) \\<in> (set r)\\<^sup>*} = {a}", "show ?thesis"], ["proof (prove)\nusing this:\n  {b. (a, b) \\<in> (set r)\\<^sup>*} = {a}\n\ngoal (1 subgoal):\n 1. rs.\\<alpha> (memo_rbt_rtrancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>*}", "unfolding one"], ["proof (prove)\nusing this:\n  {b. (a, b) \\<in> (set r)\\<^sup>*} = {a}\n\ngoal (1 subgoal):\n 1. {a} = {b. (a, b) \\<in> (set r)\\<^sup>*}", "by simp"], ["proof (state)\nthis:\n  rs.\\<alpha> (memo_rbt_rtrancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>*}\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       rm.lookup a\n        (rm.to_map\n          (map (\\<lambda>a. (a, rtrancl_rbt_impl r [a]))\n            (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n               rs_ops \\<circ>\\<circ>\n              map)\n              fst r))) =\n       Some aa \\<Longrightarrow>\n       rs.\\<alpha> (memo_rbt_rtrancl r a) =\n       {b. (a, b) \\<in> (set r)\\<^sup>*}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       rm.lookup a\n        (rm.to_map\n          (map (\\<lambda>a. (a, rtrancl_rbt_impl r [a]))\n            (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n               rs_ops \\<circ>\\<circ>\n              map)\n              fst r))) =\n       Some aa \\<Longrightarrow>\n       rs.\\<alpha> (memo_rbt_rtrancl r a) =\n       {b. (a, b) \\<in> (set r)\\<^sup>*}", "case (Some as)"], ["proof (state)\nthis:\n  rm.lookup a\n   (rm.to_map\n     (map (\\<lambda>a. (a, rtrancl_rbt_impl r [a]))\n       (((rs.to_list \\<circ>\\<circ> set_op_from_list) rs_ops \\<circ>\\<circ>\n         map)\n         fst r))) =\n  Some as\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       rm.lookup a\n        (rm.to_map\n          (map (\\<lambda>a. (a, rtrancl_rbt_impl r [a]))\n            (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n               rs_ops \\<circ>\\<circ>\n              map)\n              fst r))) =\n       Some aa \\<Longrightarrow>\n       rs.\\<alpha> (memo_rbt_rtrancl r a) =\n       {b. (a, b) \\<in> (set r)\\<^sup>*}", "have as: \"rs.\\<alpha> as = {b. (a,b) \\<in> (set r)\\<^sup>*}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs.\\<alpha> as = {b. (a, b) \\<in> (set r)\\<^sup>*}", "using map_of_SomeD [OF Some [unfolded rm.lookup_correct [OF rm.invar], simplified rm.correct]]\n        rtrancl_rbt_impl [of r \"[a]\"]"], ["proof (prove)\nusing this:\n  (a, as)\n  \\<in> set (map (\\<lambda>a. (a, rtrancl_rbt_impl r [a]))\n              (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n                 rs_ops \\<circ>\\<circ>\n                map)\n                fst r))\n  rs.\\<alpha> (rtrancl_rbt_impl r [a]) =\n  {b. \\<exists>a\\<in>set [a]. (a, b) \\<in> (set r)\\<^sup>*}\n\ngoal (1 subgoal):\n 1. rs.\\<alpha> as = {b. (a, b) \\<in> (set r)\\<^sup>*}", "by force"], ["proof (state)\nthis:\n  rs.\\<alpha> as = {b. (a, b) \\<in> (set r)\\<^sup>*}\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       rm.lookup a\n        (rm.to_map\n          (map (\\<lambda>a. (a, rtrancl_rbt_impl r [a]))\n            (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n               rs_ops \\<circ>\\<circ>\n              map)\n              fst r))) =\n       Some aa \\<Longrightarrow>\n       rs.\\<alpha> (memo_rbt_rtrancl r a) =\n       {b. (a, b) \\<in> (set r)\\<^sup>*}", "then"], ["proof (chain)\npicking this:\n  rs.\\<alpha> as = {b. (a, b) \\<in> (set r)\\<^sup>*}", "show ?thesis"], ["proof (prove)\nusing this:\n  rs.\\<alpha> as = {b. (a, b) \\<in> (set r)\\<^sup>*}\n\ngoal (1 subgoal):\n 1. rs.\\<alpha> (memo_rbt_rtrancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>*}", "unfolding memo_rbt_rtrancl_def Let_def Some"], ["proof (prove)\nusing this:\n  rs.\\<alpha> as = {b. (a, b) \\<in> (set r)\\<^sup>*}\n\ngoal (1 subgoal):\n 1. rs.\\<alpha>\n     (case Some as of None \\<Rightarrow> rs.from_list [a]\n      | Some as \\<Rightarrow> as) =\n    {b. (a, b) \\<in> (set r)\\<^sup>*}", "by simp"], ["proof (state)\nthis:\n  rs.\\<alpha> (memo_rbt_rtrancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>*}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rs.\\<alpha> (memo_rbt_rtrancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>*}\n\ngoal:\nNo subgoals!", "qed"], ["", "definition memo_rbt_trancl :: \"('a :: linorder \\<times> 'a) list \\<Rightarrow> ('a \\<Rightarrow> 'a rs)\" \nwhere\n  \"memo_rbt_trancl r =\n    (let\n      tr = trancl_rbt_impl r;\n      rm = rm.to_map (map (\\<lambda> a. (a, tr [a])) ((rs.to_list \\<circ> rs.from_list \\<circ> map fst) r))\n    in (\\<lambda> a.\n      (case rm.lookup a rm of\n        None \\<Rightarrow> rs.empty ()\n      | Some as \\<Rightarrow> as)))\""], ["", "lemma memo_rbt_trancl:\n  \"rs.\\<alpha> (memo_rbt_trancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>+}\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs.\\<alpha> (memo_rbt_trancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>+}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rs.\\<alpha> (memo_rbt_trancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>+}", "let ?rm = \"rm.to_map\n    (map (\\<lambda> a. (a, trancl_rbt_impl r [a])) ((rs.to_list \\<circ> rs.from_list \\<circ> map fst) r))\""], ["proof (state)\ngoal (1 subgoal):\n 1. rs.\\<alpha> (memo_rbt_trancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>+}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs.\\<alpha> (memo_rbt_trancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>+}", "proof (cases \"rm.lookup a ?rm\")"], ["proof (state)\ngoal (2 subgoals):\n 1. rm.lookup a\n     (rm.to_map\n       (map (\\<lambda>a. (a, trancl_rbt_impl r [a]))\n         (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n            rs_ops \\<circ>\\<circ>\n           map)\n           fst r))) =\n    None \\<Longrightarrow>\n    rs.\\<alpha> (memo_rbt_trancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>+}\n 2. \\<And>aa.\n       rm.lookup a\n        (rm.to_map\n          (map (\\<lambda>a. (a, trancl_rbt_impl r [a]))\n            (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n               rs_ops \\<circ>\\<circ>\n              map)\n              fst r))) =\n       Some aa \\<Longrightarrow>\n       rs.\\<alpha> (memo_rbt_trancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>+}", "case None"], ["proof (state)\nthis:\n  rm.lookup a\n   (rm.to_map\n     (map (\\<lambda>a. (a, trancl_rbt_impl r [a]))\n       (((rs.to_list \\<circ>\\<circ> set_op_from_list) rs_ops \\<circ>\\<circ>\n         map)\n         fst r))) =\n  None\n\ngoal (2 subgoals):\n 1. rm.lookup a\n     (rm.to_map\n       (map (\\<lambda>a. (a, trancl_rbt_impl r [a]))\n         (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n            rs_ops \\<circ>\\<circ>\n           map)\n           fst r))) =\n    None \\<Longrightarrow>\n    rs.\\<alpha> (memo_rbt_trancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>+}\n 2. \\<And>aa.\n       rm.lookup a\n        (rm.to_map\n          (map (\\<lambda>a. (a, trancl_rbt_impl r [a]))\n            (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n               rs_ops \\<circ>\\<circ>\n              map)\n              fst r))) =\n       Some aa \\<Longrightarrow>\n       rs.\\<alpha> (memo_rbt_trancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>+}", "have one: \"?l = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs.\\<alpha> (memo_rbt_trancl r a) = {}", "unfolding memo_rbt_trancl_def Let_def None"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs.\\<alpha>\n     (case None of None \\<Rightarrow> rs.empty ()\n      | Some as \\<Rightarrow> as) =\n    {}", "by (simp add: rs.correct)"], ["proof (state)\nthis:\n  rs.\\<alpha> (memo_rbt_trancl r a) = {}\n\ngoal (2 subgoals):\n 1. rm.lookup a\n     (rm.to_map\n       (map (\\<lambda>a. (a, trancl_rbt_impl r [a]))\n         (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n            rs_ops \\<circ>\\<circ>\n           map)\n           fst r))) =\n    None \\<Longrightarrow>\n    rs.\\<alpha> (memo_rbt_trancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>+}\n 2. \\<And>aa.\n       rm.lookup a\n        (rm.to_map\n          (map (\\<lambda>a. (a, trancl_rbt_impl r [a]))\n            (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n               rs_ops \\<circ>\\<circ>\n              map)\n              fst r))) =\n       Some aa \\<Longrightarrow>\n       rs.\\<alpha> (memo_rbt_trancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>+}", "from None [unfolded rm.lookup_correct [OF rm.invar], simplified rm.correct map_of_eq_None_iff]"], ["proof (chain)\npicking this:\n  a \\<notin> fst `\n             set (map (\\<lambda>a. (a, trancl_rbt_impl r [a]))\n                   (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n                      rs_ops \\<circ>\\<circ>\n                     map)\n                     fst r))", "have a: \"a \\<notin> fst ` set r\""], ["proof (prove)\nusing this:\n  a \\<notin> fst `\n             set (map (\\<lambda>a. (a, trancl_rbt_impl r [a]))\n                   (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n                      rs_ops \\<circ>\\<circ>\n                     map)\n                     fst r))\n\ngoal (1 subgoal):\n 1. a \\<notin> fst ` set r", "by (simp add: rs.correct, force)"], ["proof (state)\nthis:\n  a \\<notin> fst ` set r\n\ngoal (2 subgoals):\n 1. rm.lookup a\n     (rm.to_map\n       (map (\\<lambda>a. (a, trancl_rbt_impl r [a]))\n         (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n            rs_ops \\<circ>\\<circ>\n           map)\n           fst r))) =\n    None \\<Longrightarrow>\n    rs.\\<alpha> (memo_rbt_trancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>+}\n 2. \\<And>aa.\n       rm.lookup a\n        (rm.to_map\n          (map (\\<lambda>a. (a, trancl_rbt_impl r [a]))\n            (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n               rs_ops \\<circ>\\<circ>\n              map)\n              fst r))) =\n       Some aa \\<Longrightarrow>\n       rs.\\<alpha> (memo_rbt_trancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>+}", "{"], ["proof (state)\nthis:\n  a \\<notin> fst ` set r\n\ngoal (2 subgoals):\n 1. rm.lookup a\n     (rm.to_map\n       (map (\\<lambda>a. (a, trancl_rbt_impl r [a]))\n         (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n            rs_ops \\<circ>\\<circ>\n           map)\n           fst r))) =\n    None \\<Longrightarrow>\n    rs.\\<alpha> (memo_rbt_trancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>+}\n 2. \\<And>aa.\n       rm.lookup a\n        (rm.to_map\n          (map (\\<lambda>a. (a, trancl_rbt_impl r [a]))\n            (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n               rs_ops \\<circ>\\<circ>\n              map)\n              fst r))) =\n       Some aa \\<Longrightarrow>\n       rs.\\<alpha> (memo_rbt_trancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>+}", "fix b"], ["proof (state)\ngoal (2 subgoals):\n 1. rm.lookup a\n     (rm.to_map\n       (map (\\<lambda>a. (a, trancl_rbt_impl r [a]))\n         (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n            rs_ops \\<circ>\\<circ>\n           map)\n           fst r))) =\n    None \\<Longrightarrow>\n    rs.\\<alpha> (memo_rbt_trancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>+}\n 2. \\<And>aa.\n       rm.lookup a\n        (rm.to_map\n          (map (\\<lambda>a. (a, trancl_rbt_impl r [a]))\n            (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n               rs_ops \\<circ>\\<circ>\n              map)\n              fst r))) =\n       Some aa \\<Longrightarrow>\n       rs.\\<alpha> (memo_rbt_trancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>+}", "assume \"b \\<in> ?r\""], ["proof (state)\nthis:\n  b \\<in> {b. (a, b) \\<in> (set r)\\<^sup>+}\n\ngoal (2 subgoals):\n 1. rm.lookup a\n     (rm.to_map\n       (map (\\<lambda>a. (a, trancl_rbt_impl r [a]))\n         (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n            rs_ops \\<circ>\\<circ>\n           map)\n           fst r))) =\n    None \\<Longrightarrow>\n    rs.\\<alpha> (memo_rbt_trancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>+}\n 2. \\<And>aa.\n       rm.lookup a\n        (rm.to_map\n          (map (\\<lambda>a. (a, trancl_rbt_impl r [a]))\n            (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n               rs_ops \\<circ>\\<circ>\n              map)\n              fst r))) =\n       Some aa \\<Longrightarrow>\n       rs.\\<alpha> (memo_rbt_trancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>+}", "from this [unfolded trancl_unfold_left] a"], ["proof (chain)\npicking this:\n  b \\<in> {b. (a, b) \\<in> set r O (set r)\\<^sup>*}\n  a \\<notin> fst ` set r", "have False"], ["proof (prove)\nusing this:\n  b \\<in> {b. (a, b) \\<in> set r O (set r)\\<^sup>*}\n  a \\<notin> fst ` set r\n\ngoal (1 subgoal):\n 1. False", "by force"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. rm.lookup a\n     (rm.to_map\n       (map (\\<lambda>a. (a, trancl_rbt_impl r [a]))\n         (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n            rs_ops \\<circ>\\<circ>\n           map)\n           fst r))) =\n    None \\<Longrightarrow>\n    rs.\\<alpha> (memo_rbt_trancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>+}\n 2. \\<And>aa.\n       rm.lookup a\n        (rm.to_map\n          (map (\\<lambda>a. (a, trancl_rbt_impl r [a]))\n            (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n               rs_ops \\<circ>\\<circ>\n              map)\n              fst r))) =\n       Some aa \\<Longrightarrow>\n       rs.\\<alpha> (memo_rbt_trancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>+}", "}"], ["proof (state)\nthis:\n  ?b2 \\<in> {b. (a, b) \\<in> (set r)\\<^sup>+} \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. rm.lookup a\n     (rm.to_map\n       (map (\\<lambda>a. (a, trancl_rbt_impl r [a]))\n         (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n            rs_ops \\<circ>\\<circ>\n           map)\n           fst r))) =\n    None \\<Longrightarrow>\n    rs.\\<alpha> (memo_rbt_trancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>+}\n 2. \\<And>aa.\n       rm.lookup a\n        (rm.to_map\n          (map (\\<lambda>a. (a, trancl_rbt_impl r [a]))\n            (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n               rs_ops \\<circ>\\<circ>\n              map)\n              fst r))) =\n       Some aa \\<Longrightarrow>\n       rs.\\<alpha> (memo_rbt_trancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>+}", "then"], ["proof (chain)\npicking this:\n  ?b2 \\<in> {b. (a, b) \\<in> (set r)\\<^sup>+} \\<Longrightarrow> False", "have \"?r = {}\""], ["proof (prove)\nusing this:\n  ?b2 \\<in> {b. (a, b) \\<in> (set r)\\<^sup>+} \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. {b. (a, b) \\<in> (set r)\\<^sup>+} = {}", "by auto"], ["proof (state)\nthis:\n  {b. (a, b) \\<in> (set r)\\<^sup>+} = {}\n\ngoal (2 subgoals):\n 1. rm.lookup a\n     (rm.to_map\n       (map (\\<lambda>a. (a, trancl_rbt_impl r [a]))\n         (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n            rs_ops \\<circ>\\<circ>\n           map)\n           fst r))) =\n    None \\<Longrightarrow>\n    rs.\\<alpha> (memo_rbt_trancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>+}\n 2. \\<And>aa.\n       rm.lookup a\n        (rm.to_map\n          (map (\\<lambda>a. (a, trancl_rbt_impl r [a]))\n            (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n               rs_ops \\<circ>\\<circ>\n              map)\n              fst r))) =\n       Some aa \\<Longrightarrow>\n       rs.\\<alpha> (memo_rbt_trancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>+}", "then"], ["proof (chain)\npicking this:\n  {b. (a, b) \\<in> (set r)\\<^sup>+} = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  {b. (a, b) \\<in> (set r)\\<^sup>+} = {}\n\ngoal (1 subgoal):\n 1. rs.\\<alpha> (memo_rbt_trancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>+}", "unfolding one"], ["proof (prove)\nusing this:\n  {b. (a, b) \\<in> (set r)\\<^sup>+} = {}\n\ngoal (1 subgoal):\n 1. {} = {b. (a, b) \\<in> (set r)\\<^sup>+}", "by simp"], ["proof (state)\nthis:\n  rs.\\<alpha> (memo_rbt_trancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>+}\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       rm.lookup a\n        (rm.to_map\n          (map (\\<lambda>a. (a, trancl_rbt_impl r [a]))\n            (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n               rs_ops \\<circ>\\<circ>\n              map)\n              fst r))) =\n       Some aa \\<Longrightarrow>\n       rs.\\<alpha> (memo_rbt_trancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>+}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       rm.lookup a\n        (rm.to_map\n          (map (\\<lambda>a. (a, trancl_rbt_impl r [a]))\n            (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n               rs_ops \\<circ>\\<circ>\n              map)\n              fst r))) =\n       Some aa \\<Longrightarrow>\n       rs.\\<alpha> (memo_rbt_trancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>+}", "case (Some as)"], ["proof (state)\nthis:\n  rm.lookup a\n   (rm.to_map\n     (map (\\<lambda>a. (a, trancl_rbt_impl r [a]))\n       (((rs.to_list \\<circ>\\<circ> set_op_from_list) rs_ops \\<circ>\\<circ>\n         map)\n         fst r))) =\n  Some as\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       rm.lookup a\n        (rm.to_map\n          (map (\\<lambda>a. (a, trancl_rbt_impl r [a]))\n            (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n               rs_ops \\<circ>\\<circ>\n              map)\n              fst r))) =\n       Some aa \\<Longrightarrow>\n       rs.\\<alpha> (memo_rbt_trancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>+}", "have as: \"rs.\\<alpha> as = {b. (a,b) \\<in> (set r)\\<^sup>+}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs.\\<alpha> as = {b. (a, b) \\<in> (set r)\\<^sup>+}", "using map_of_SomeD [OF Some [unfolded rm.lookup_correct [OF rm.invar], simplified rm.correct]]\n        trancl_rbt_impl [of r \"[a]\"]"], ["proof (prove)\nusing this:\n  (a, as)\n  \\<in> set (map (\\<lambda>a. (a, trancl_rbt_impl r [a]))\n              (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n                 rs_ops \\<circ>\\<circ>\n                map)\n                fst r))\n  rs.\\<alpha> (trancl_rbt_impl r [a]) =\n  {b. \\<exists>a\\<in>set [a]. (a, b) \\<in> (set r)\\<^sup>+}\n\ngoal (1 subgoal):\n 1. rs.\\<alpha> as = {b. (a, b) \\<in> (set r)\\<^sup>+}", "by force"], ["proof (state)\nthis:\n  rs.\\<alpha> as = {b. (a, b) \\<in> (set r)\\<^sup>+}\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       rm.lookup a\n        (rm.to_map\n          (map (\\<lambda>a. (a, trancl_rbt_impl r [a]))\n            (((rs.to_list \\<circ>\\<circ> set_op_from_list)\n               rs_ops \\<circ>\\<circ>\n              map)\n              fst r))) =\n       Some aa \\<Longrightarrow>\n       rs.\\<alpha> (memo_rbt_trancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>+}", "then"], ["proof (chain)\npicking this:\n  rs.\\<alpha> as = {b. (a, b) \\<in> (set r)\\<^sup>+}", "show ?thesis"], ["proof (prove)\nusing this:\n  rs.\\<alpha> as = {b. (a, b) \\<in> (set r)\\<^sup>+}\n\ngoal (1 subgoal):\n 1. rs.\\<alpha> (memo_rbt_trancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>+}", "unfolding memo_rbt_trancl_def Let_def Some"], ["proof (prove)\nusing this:\n  rs.\\<alpha> as = {b. (a, b) \\<in> (set r)\\<^sup>+}\n\ngoal (1 subgoal):\n 1. rs.\\<alpha>\n     (case Some as of None \\<Rightarrow> rs.empty ()\n      | Some as \\<Rightarrow> as) =\n    {b. (a, b) \\<in> (set r)\\<^sup>+}", "by simp"], ["proof (state)\nthis:\n  rs.\\<alpha> (memo_rbt_trancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>+}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rs.\\<alpha> (memo_rbt_trancl r a) = {b. (a, b) \\<in> (set r)\\<^sup>+}\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}