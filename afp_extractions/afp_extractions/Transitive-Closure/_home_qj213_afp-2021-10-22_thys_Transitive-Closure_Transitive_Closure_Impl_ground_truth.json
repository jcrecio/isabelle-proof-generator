{"file_name": "/home/qj213/afp-2021-10-22/thys/Transitive-Closure/Transitive_Closure_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Transitive-Closure", "problem_names": ["lemma relpow_impl_main: \n  \"set_of (relpow_i new have n) = \n    {b | a b m. a \\<in> set new \\<and> m \\<le> n \\<and> (a, b) \\<in> (rel \\<inter> {(a, b). b \\<notin> set_of have}) ^^ m} \\<union>\n    set_of have\"\n  (is \"?l new have n = ?r new have n\")", "lemma relpow_impl:\n  \"set_of (relpow_i new empty n) = {b | a b m. a \\<in> set new \\<and> m \\<le> n \\<and> (a, b) \\<in> rel ^^ m}\"", "lemma rtrancl_finite_relpow:\n  \"(a, b) \\<in> (set rel)\\<^sup>* \\<longleftrightarrow> (\\<exists> n \\<le> length rel. (a, b) \\<in> set rel ^^ n)\" (is \"?l = ?r\")", "lemma rtrancl_impl:\n  \"set_of (rtrancl_i rel as) = {b. (\\<exists> a \\<in> set as. (a, b) \\<in> (set rel)\\<^sup>*)}\"", "lemma trancl_impl:\n  \"set_of (trancl_i rel as) = {b. (\\<exists> a \\<in> set as. (a, b) \\<in> (set rel)\\<^sup>+)}\""], "translations": [["", "lemma relpow_impl_main: \n  \"set_of (relpow_i new have n) = \n    {b | a b m. a \\<in> set new \\<and> m \\<le> n \\<and> (a, b) \\<in> (rel \\<inter> {(a, b). b \\<notin> set_of have}) ^^ m} \\<union>\n    set_of have\"\n  (is \"?l new have n = ?r new have n\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_of (relpow_i new have n) =\n    {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> set new \\<and>\n        m \\<le> n \\<and>\n        (a, b)\n        \\<in> (rel \\<inter> {(a, b). b \\<notin> set_of have}) ^^ m} \\<union>\n    set_of have", "proof (induction n arbitrary: \"have\" new)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>have new.\n       set_of (relpow_i new have 0) =\n       {uu_.\n        \\<exists>a b m.\n           uu_ = b \\<and>\n           a \\<in> set new \\<and>\n           m \\<le> 0 \\<and>\n           (a, b)\n           \\<in> (rel \\<inter> {(a, b). b \\<notin> set_of have}) ^^\n                 m} \\<union>\n       set_of have\n 2. \\<And>n have new.\n       (\\<And>have new.\n           set_of (relpow_i new have n) =\n           {uu_.\n            \\<exists>a b m.\n               uu_ = b \\<and>\n               a \\<in> set new \\<and>\n               m \\<le> n \\<and>\n               (a, b)\n               \\<in> (rel \\<inter> {(a, b). b \\<notin> set_of have}) ^^\n                     m} \\<union>\n           set_of have) \\<Longrightarrow>\n       set_of (relpow_i new have (Suc n)) =\n       {uu_.\n        \\<exists>a b m.\n           uu_ = b \\<and>\n           a \\<in> set new \\<and>\n           m \\<le> Suc n \\<and>\n           (a, b)\n           \\<in> (rel \\<inter> {(a, b). b \\<notin> set_of have}) ^^\n                 m} \\<union>\n       set_of have", "case (Suc n hhave nnew)"], ["proof (state)\nthis:\n  set_of (relpow_i ?new ?have n) =\n  {uu_.\n   \\<exists>a b m.\n      uu_ = b \\<and>\n      a \\<in> set ?new \\<and>\n      m \\<le> n \\<and>\n      (a, b)\n      \\<in> (rel \\<inter>\n             {a. case a of (a, b) \\<Rightarrow> b \\<notin> set_of ?have}) ^^\n            m} \\<union>\n  set_of ?have\n\ngoal (2 subgoals):\n 1. \\<And>have new.\n       set_of (relpow_i new have 0) =\n       {uu_.\n        \\<exists>a b m.\n           uu_ = b \\<and>\n           a \\<in> set new \\<and>\n           m \\<le> 0 \\<and>\n           (a, b)\n           \\<in> (rel \\<inter> {(a, b). b \\<notin> set_of have}) ^^\n                 m} \\<union>\n       set_of have\n 2. \\<And>n have new.\n       (\\<And>have new.\n           set_of (relpow_i new have n) =\n           {uu_.\n            \\<exists>a b m.\n               uu_ = b \\<and>\n               a \\<in> set new \\<and>\n               m \\<le> n \\<and>\n               (a, b)\n               \\<in> (rel \\<inter> {(a, b). b \\<notin> set_of have}) ^^\n                     m} \\<union>\n           set_of have) \\<Longrightarrow>\n       set_of (relpow_i new have (Suc n)) =\n       {uu_.\n        \\<exists>a b m.\n           uu_ = b \\<and>\n           a \\<in> set new \\<and>\n           m \\<le> Suc n \\<and>\n           (a, b)\n           \\<in> (rel \\<inter> {(a, b). b \\<notin> set_of have}) ^^\n                 m} \\<union>\n       set_of have", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_of (relpow_i nnew hhave (Suc n)) =\n    {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> set nnew \\<and>\n        m \\<le> Suc n \\<and>\n        (a, b)\n        \\<in> (rel \\<inter>\n               {a. case a of\n                   (a, b) \\<Rightarrow> b \\<notin> set_of hhave}) ^^\n              m} \\<union>\n    set_of hhave", "proof (cases \"nnew = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. nnew = [] \\<Longrightarrow>\n    set_of (relpow_i nnew hhave (Suc n)) =\n    {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> set nnew \\<and>\n        m \\<le> Suc n \\<and>\n        (a, b)\n        \\<in> (rel \\<inter>\n               {a. case a of\n                   (a, b) \\<Rightarrow> b \\<notin> set_of hhave}) ^^\n              m} \\<union>\n    set_of hhave\n 2. nnew \\<noteq> [] \\<Longrightarrow>\n    set_of (relpow_i nnew hhave (Suc n)) =\n    {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> set nnew \\<and>\n        m \\<le> Suc n \\<and>\n        (a, b)\n        \\<in> (rel \\<inter>\n               {a. case a of\n                   (a, b) \\<Rightarrow> b \\<notin> set_of hhave}) ^^\n              m} \\<union>\n    set_of hhave", "case True"], ["proof (state)\nthis:\n  nnew = []\n\ngoal (2 subgoals):\n 1. nnew = [] \\<Longrightarrow>\n    set_of (relpow_i nnew hhave (Suc n)) =\n    {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> set nnew \\<and>\n        m \\<le> Suc n \\<and>\n        (a, b)\n        \\<in> (rel \\<inter>\n               {a. case a of\n                   (a, b) \\<Rightarrow> b \\<notin> set_of hhave}) ^^\n              m} \\<union>\n    set_of hhave\n 2. nnew \\<noteq> [] \\<Longrightarrow>\n    set_of (relpow_i nnew hhave (Suc n)) =\n    {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> set nnew \\<and>\n        m \\<le> Suc n \\<and>\n        (a, b)\n        \\<in> (rel \\<inter>\n               {a. case a of\n                   (a, b) \\<Rightarrow> b \\<notin> set_of hhave}) ^^\n              m} \\<union>\n    set_of hhave", "then"], ["proof (chain)\npicking this:\n  nnew = []", "show ?thesis"], ["proof (prove)\nusing this:\n  nnew = []\n\ngoal (1 subgoal):\n 1. set_of (relpow_i nnew hhave (Suc n)) =\n    {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> set nnew \\<and>\n        m \\<le> Suc n \\<and>\n        (a, b)\n        \\<in> (rel \\<inter>\n               {a. case a of\n                   (a, b) \\<Rightarrow> b \\<notin> set_of hhave}) ^^\n              m} \\<union>\n    set_of hhave", "by auto"], ["proof (state)\nthis:\n  set_of (relpow_i nnew hhave (Suc n)) =\n  {uu_.\n   \\<exists>a b m.\n      uu_ = b \\<and>\n      a \\<in> set nnew \\<and>\n      m \\<le> Suc n \\<and>\n      (a, b)\n      \\<in> (rel \\<inter>\n             {a. case a of (a, b) \\<Rightarrow> b \\<notin> set_of hhave}) ^^\n            m} \\<union>\n  set_of hhave\n\ngoal (1 subgoal):\n 1. nnew \\<noteq> [] \\<Longrightarrow>\n    set_of (relpow_i nnew hhave (Suc n)) =\n    {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> set nnew \\<and>\n        m \\<le> Suc n \\<and>\n        (a, b)\n        \\<in> (rel \\<inter>\n               {a. case a of\n                   (a, b) \\<Rightarrow> b \\<notin> set_of hhave}) ^^\n              m} \\<union>\n    set_of hhave", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. nnew \\<noteq> [] \\<Longrightarrow>\n    set_of (relpow_i nnew hhave (Suc n)) =\n    {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> set nnew \\<and>\n        m \\<le> Suc n \\<and>\n        (a, b)\n        \\<in> (rel \\<inter>\n               {a. case a of\n                   (a, b) \\<Rightarrow> b \\<notin> set_of hhave}) ^^\n              m} \\<union>\n    set_of hhave", "case False"], ["proof (state)\nthis:\n  nnew \\<noteq> []\n\ngoal (1 subgoal):\n 1. nnew \\<noteq> [] \\<Longrightarrow>\n    set_of (relpow_i nnew hhave (Suc n)) =\n    {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> set nnew \\<and>\n        m \\<le> Suc n \\<and>\n        (a, b)\n        \\<in> (rel \\<inter>\n               {a. case a of\n                   (a, b) \\<Rightarrow> b \\<notin> set_of hhave}) ^^\n              m} \\<union>\n    set_of hhave", "let ?have = \"set_of hhave\""], ["proof (state)\ngoal (1 subgoal):\n 1. nnew \\<noteq> [] \\<Longrightarrow>\n    set_of (relpow_i nnew hhave (Suc n)) =\n    {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> set nnew \\<and>\n        m \\<le> Suc n \\<and>\n        (a, b)\n        \\<in> (rel \\<inter>\n               {a. case a of\n                   (a, b) \\<Rightarrow> b \\<notin> set_of hhave}) ^^\n              m} \\<union>\n    set_of hhave", "let ?new = \"set nnew\""], ["proof (state)\ngoal (1 subgoal):\n 1. nnew \\<noteq> [] \\<Longrightarrow>\n    set_of (relpow_i nnew hhave (Suc n)) =\n    {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> set nnew \\<and>\n        m \\<le> Suc n \\<and>\n        (a, b)\n        \\<in> (rel \\<inter>\n               {a. case a of\n                   (a, b) \\<Rightarrow> b \\<notin> set_of hhave}) ^^\n              m} \\<union>\n    set_of hhave", "obtain \"have\" new where hav: \"have = ?have\" and new: \"new = ?new\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>have new.\n        \\<lbrakk>have = set_of hhave; new = set nnew\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  have = set_of hhave\n  new = set nnew\n\ngoal (1 subgoal):\n 1. nnew \\<noteq> [] \\<Longrightarrow>\n    set_of (relpow_i nnew hhave (Suc n)) =\n    {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> set nnew \\<and>\n        m \\<le> Suc n \\<and>\n        (a, b)\n        \\<in> (rel \\<inter>\n               {a. case a of\n                   (a, b) \\<Rightarrow> b \\<notin> set_of hhave}) ^^\n              m} \\<union>\n    set_of hhave", "let ?reln = \"\\<lambda> m. (rel \\<inter> {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^  m\""], ["proof (state)\ngoal (1 subgoal):\n 1. nnew \\<noteq> [] \\<Longrightarrow>\n    set_of (relpow_i nnew hhave (Suc n)) =\n    {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> set nnew \\<and>\n        m \\<le> Suc n \\<and>\n        (a, b)\n        \\<in> (rel \\<inter>\n               {a. case a of\n                   (a, b) \\<Rightarrow> b \\<notin> set_of hhave}) ^^\n              m} \\<union>\n    set_of hhave", "let ?rel = \"\\<lambda> m. (rel \\<inter> {(a, b). b \\<notin> have}) ^^  m\""], ["proof (state)\ngoal (1 subgoal):\n 1. nnew \\<noteq> [] \\<Longrightarrow>\n    set_of (relpow_i nnew hhave (Suc n)) =\n    {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> set nnew \\<and>\n        m \\<le> Suc n \\<and>\n        (a, b)\n        \\<in> (rel \\<inter>\n               {a. case a of\n                   (a, b) \\<Rightarrow> b \\<notin> set_of hhave}) ^^\n              m} \\<union>\n    set_of hhave", "have idl: \"?l nnew hhave (Suc n) = \n      {uu. \\<exists>a. (\\<exists>aa\\<in> new. (aa,a) \\<in> rel) \\<and> a \\<notin> new \\<and> a \\<notin> have \\<and> (\\<exists>m \\<le> n. (a, uu) \\<in> ?reln m)} \\<union>\n      (new \\<union> have)\"\n      (is \"_ = ?l1 \\<union> (?l2 \\<union> ?l3)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_of (relpow_i nnew hhave (Suc n)) =\n    {uu.\n     \\<exists>a.\n        (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n        a \\<notin> new \\<and>\n        a \\<notin> have \\<and>\n        (\\<exists>m\\<le>n.\n            (a, uu)\n            \\<in> (rel \\<inter>\n                   {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n                  m)} \\<union>\n    (new \\<union> have)", "by (simp add: hav new False Let_def Suc, simp add: memb un succ)"], ["proof (state)\nthis:\n  set_of (relpow_i nnew hhave (Suc n)) =\n  {uu.\n   \\<exists>a.\n      (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n      a \\<notin> new \\<and>\n      a \\<notin> have \\<and>\n      (\\<exists>m\\<le>n.\n          (a, uu)\n          \\<in> (rel \\<inter>\n                 {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n                m)} \\<union>\n  (new \\<union> have)\n\ngoal (1 subgoal):\n 1. nnew \\<noteq> [] \\<Longrightarrow>\n    set_of (relpow_i nnew hhave (Suc n)) =\n    {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> set nnew \\<and>\n        m \\<le> Suc n \\<and>\n        (a, b)\n        \\<in> (rel \\<inter>\n               {a. case a of\n                   (a, b) \\<Rightarrow> b \\<notin> set_of hhave}) ^^\n              m} \\<union>\n    set_of hhave", "let ?l = \"?l1 \\<union> (?l2 \\<union> ?l3)\""], ["proof (state)\ngoal (1 subgoal):\n 1. nnew \\<noteq> [] \\<Longrightarrow>\n    set_of (relpow_i nnew hhave (Suc n)) =\n    {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> set nnew \\<and>\n        m \\<le> Suc n \\<and>\n        (a, b)\n        \\<in> (rel \\<inter>\n               {a. case a of\n                   (a, b) \\<Rightarrow> b \\<notin> set_of hhave}) ^^\n              m} \\<union>\n    set_of hhave", "have idr: \"?r nnew hhave (Suc n) = {b. \\<exists> a m. a \\<in> new \\<and> m \\<le> Suc n \\<and> (a, b) \\<in> ?rel m} \\<union> have\"\n      (is \"_ = (?r1 \\<union> ?r2)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> set nnew \\<and>\n        m \\<le> Suc n \\<and>\n        (a, b)\n        \\<in> (rel \\<inter>\n               {a. case a of\n                   (a, b) \\<Rightarrow> b \\<notin> set_of hhave}) ^^\n              m} \\<union>\n    set_of hhave =\n    {b. \\<exists>a m.\n           a \\<in> new \\<and>\n           m \\<le> Suc n \\<and>\n           (a, b)\n           \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ m} \\<union>\n    have", "by (simp add: hav new)"], ["proof (state)\nthis:\n  {uu_.\n   \\<exists>a b m.\n      uu_ = b \\<and>\n      a \\<in> set nnew \\<and>\n      m \\<le> Suc n \\<and>\n      (a, b)\n      \\<in> (rel \\<inter>\n             {a. case a of (a, b) \\<Rightarrow> b \\<notin> set_of hhave}) ^^\n            m} \\<union>\n  set_of hhave =\n  {b. \\<exists>a m.\n         a \\<in> new \\<and>\n         m \\<le> Suc n \\<and>\n         (a, b)\n         \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ m} \\<union>\n  have\n\ngoal (1 subgoal):\n 1. nnew \\<noteq> [] \\<Longrightarrow>\n    set_of (relpow_i nnew hhave (Suc n)) =\n    {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> set nnew \\<and>\n        m \\<le> Suc n \\<and>\n        (a, b)\n        \\<in> (rel \\<inter>\n               {a. case a of\n                   (a, b) \\<Rightarrow> b \\<notin> set_of hhave}) ^^\n              m} \\<union>\n    set_of hhave", "let ?r = \"?r1 \\<union> ?r2\""], ["proof (state)\ngoal (1 subgoal):\n 1. nnew \\<noteq> [] \\<Longrightarrow>\n    set_of (relpow_i nnew hhave (Suc n)) =\n    {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> set nnew \\<and>\n        m \\<le> Suc n \\<and>\n        (a, b)\n        \\<in> (rel \\<inter>\n               {a. case a of\n                   (a, b) \\<Rightarrow> b \\<notin> set_of hhave}) ^^\n              m} \\<union>\n    set_of hhave", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. nnew \\<noteq> [] \\<Longrightarrow>\n    set_of (relpow_i nnew hhave (Suc n)) =\n    {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> set nnew \\<and>\n        m \\<le> Suc n \\<and>\n        (a, b)\n        \\<in> (rel \\<inter>\n               {a. case a of\n                   (a, b) \\<Rightarrow> b \\<notin> set_of hhave}) ^^\n              m} \\<union>\n    set_of hhave", "fix b"], ["proof (state)\ngoal (1 subgoal):\n 1. nnew \\<noteq> [] \\<Longrightarrow>\n    set_of (relpow_i nnew hhave (Suc n)) =\n    {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> set nnew \\<and>\n        m \\<le> Suc n \\<and>\n        (a, b)\n        \\<in> (rel \\<inter>\n               {a. case a of\n                   (a, b) \\<Rightarrow> b \\<notin> set_of hhave}) ^^\n              m} \\<union>\n    set_of hhave", "assume b: \"b \\<in> ?l\""], ["proof (state)\nthis:\n  b \\<in> {uu.\n           \\<exists>a.\n              (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n              a \\<notin> new \\<and>\n              a \\<notin> have \\<and>\n              (\\<exists>m\\<le>n.\n                  (a, uu)\n                  \\<in> (rel \\<inter>\n                         {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n                        m)} \\<union>\n          (new \\<union> have)\n\ngoal (1 subgoal):\n 1. nnew \\<noteq> [] \\<Longrightarrow>\n    set_of (relpow_i nnew hhave (Suc n)) =\n    {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> set nnew \\<and>\n        m \\<le> Suc n \\<and>\n        (a, b)\n        \\<in> (rel \\<inter>\n               {a. case a of\n                   (a, b) \\<Rightarrow> b \\<notin> set_of hhave}) ^^\n              m} \\<union>\n    set_of hhave", "have \"b \\<in> ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> {b. \\<exists>a m.\n                   a \\<in> new \\<and>\n                   m \\<le> Suc n \\<and>\n                   (a, b)\n                   \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                         m} \\<union>\n            have", "proof (cases \"b \\<in> new \\<or> b \\<in> have\")"], ["proof (state)\ngoal (2 subgoals):\n 1. b \\<in> new \\<or> b \\<in> have \\<Longrightarrow>\n    b \\<in> {b. \\<exists>a m.\n                   a \\<in> new \\<and>\n                   m \\<le> Suc n \\<and>\n                   (a, b)\n                   \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                         m} \\<union>\n            have\n 2. \\<not> (b \\<in> new \\<or> b \\<in> have) \\<Longrightarrow>\n    b \\<in> {b. \\<exists>a m.\n                   a \\<in> new \\<and>\n                   m \\<le> Suc n \\<and>\n                   (a, b)\n                   \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                         m} \\<union>\n            have", "case True"], ["proof (state)\nthis:\n  b \\<in> new \\<or> b \\<in> have\n\ngoal (2 subgoals):\n 1. b \\<in> new \\<or> b \\<in> have \\<Longrightarrow>\n    b \\<in> {b. \\<exists>a m.\n                   a \\<in> new \\<and>\n                   m \\<le> Suc n \\<and>\n                   (a, b)\n                   \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                         m} \\<union>\n            have\n 2. \\<not> (b \\<in> new \\<or> b \\<in> have) \\<Longrightarrow>\n    b \\<in> {b. \\<exists>a m.\n                   a \\<in> new \\<and>\n                   m \\<le> Suc n \\<and>\n                   (a, b)\n                   \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                         m} \\<union>\n            have", "then"], ["proof (chain)\npicking this:\n  b \\<in> new \\<or> b \\<in> have", "show ?thesis"], ["proof (prove)\nusing this:\n  b \\<in> new \\<or> b \\<in> have\n\ngoal (1 subgoal):\n 1. b \\<in> {b. \\<exists>a m.\n                   a \\<in> new \\<and>\n                   m \\<le> Suc n \\<and>\n                   (a, b)\n                   \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                         m} \\<union>\n            have", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. b \\<in> new \\<Longrightarrow>\n    b \\<in> {b. \\<exists>a m.\n                   a \\<in> new \\<and>\n                   m \\<le> Suc n \\<and>\n                   (a, b)\n                   \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                         m} \\<union>\n            have\n 2. b \\<in> have \\<Longrightarrow>\n    b \\<in> {b. \\<exists>a m.\n                   a \\<in> new \\<and>\n                   m \\<le> Suc n \\<and>\n                   (a, b)\n                   \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                         m} \\<union>\n            have", "assume \"b \\<in> have\""], ["proof (state)\nthis:\n  b \\<in> have\n\ngoal (2 subgoals):\n 1. b \\<in> new \\<Longrightarrow>\n    b \\<in> {b. \\<exists>a m.\n                   a \\<in> new \\<and>\n                   m \\<le> Suc n \\<and>\n                   (a, b)\n                   \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                         m} \\<union>\n            have\n 2. b \\<in> have \\<Longrightarrow>\n    b \\<in> {b. \\<exists>a m.\n                   a \\<in> new \\<and>\n                   m \\<le> Suc n \\<and>\n                   (a, b)\n                   \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                         m} \\<union>\n            have", "then"], ["proof (chain)\npicking this:\n  b \\<in> have", "show ?thesis"], ["proof (prove)\nusing this:\n  b \\<in> have\n\ngoal (1 subgoal):\n 1. b \\<in> {b. \\<exists>a m.\n                   a \\<in> new \\<and>\n                   m \\<le> Suc n \\<and>\n                   (a, b)\n                   \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                         m} \\<union>\n            have", "by auto"], ["proof (state)\nthis:\n  b \\<in> {b. \\<exists>a m.\n                 a \\<in> new \\<and>\n                 m \\<le> Suc n \\<and>\n                 (a, b)\n                 \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                       m} \\<union>\n          have\n\ngoal (1 subgoal):\n 1. b \\<in> new \\<Longrightarrow>\n    b \\<in> {b. \\<exists>a m.\n                   a \\<in> new \\<and>\n                   m \\<le> Suc n \\<and>\n                   (a, b)\n                   \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                         m} \\<union>\n            have", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<in> new \\<Longrightarrow>\n    b \\<in> {b. \\<exists>a m.\n                   a \\<in> new \\<and>\n                   m \\<le> Suc n \\<and>\n                   (a, b)\n                   \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                         m} \\<union>\n            have", "assume b: \"b \\<in> new\""], ["proof (state)\nthis:\n  b \\<in> new\n\ngoal (1 subgoal):\n 1. b \\<in> new \\<Longrightarrow>\n    b \\<in> {b. \\<exists>a m.\n                   a \\<in> new \\<and>\n                   m \\<le> Suc n \\<and>\n                   (a, b)\n                   \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                         m} \\<union>\n            have", "have \"b \\<in> ?r1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> {b. \\<exists>a m.\n                   a \\<in> new \\<and>\n                   m \\<le> Suc n \\<and>\n                   (a, b)\n                   \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ m}", "by (intro CollectI, rule exI, rule exI [of _ 0], intro conjI, rule b, auto)"], ["proof (state)\nthis:\n  b \\<in> {b. \\<exists>a m.\n                 a \\<in> new \\<and>\n                 m \\<le> Suc n \\<and>\n                 (a, b) \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ m}\n\ngoal (1 subgoal):\n 1. b \\<in> new \\<Longrightarrow>\n    b \\<in> {b. \\<exists>a m.\n                   a \\<in> new \\<and>\n                   m \\<le> Suc n \\<and>\n                   (a, b)\n                   \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                         m} \\<union>\n            have", "then"], ["proof (chain)\npicking this:\n  b \\<in> {b. \\<exists>a m.\n                 a \\<in> new \\<and>\n                 m \\<le> Suc n \\<and>\n                 (a, b) \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ m}", "show ?thesis"], ["proof (prove)\nusing this:\n  b \\<in> {b. \\<exists>a m.\n                 a \\<in> new \\<and>\n                 m \\<le> Suc n \\<and>\n                 (a, b) \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ m}\n\ngoal (1 subgoal):\n 1. b \\<in> {b. \\<exists>a m.\n                   a \\<in> new \\<and>\n                   m \\<le> Suc n \\<and>\n                   (a, b)\n                   \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                         m} \\<union>\n            have", "by auto"], ["proof (state)\nthis:\n  b \\<in> {b. \\<exists>a m.\n                 a \\<in> new \\<and>\n                 m \\<le> Suc n \\<and>\n                 (a, b)\n                 \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                       m} \\<union>\n          have\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b \\<in> {b. \\<exists>a m.\n                 a \\<in> new \\<and>\n                 m \\<le> Suc n \\<and>\n                 (a, b)\n                 \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                       m} \\<union>\n          have\n\ngoal (1 subgoal):\n 1. \\<not> (b \\<in> new \\<or> b \\<in> have) \\<Longrightarrow>\n    b \\<in> {b. \\<exists>a m.\n                   a \\<in> new \\<and>\n                   m \\<le> Suc n \\<and>\n                   (a, b)\n                   \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                         m} \\<union>\n            have", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (b \\<in> new \\<or> b \\<in> have) \\<Longrightarrow>\n    b \\<in> {b. \\<exists>a m.\n                   a \\<in> new \\<and>\n                   m \\<le> Suc n \\<and>\n                   (a, b)\n                   \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                         m} \\<union>\n            have", "case False"], ["proof (state)\nthis:\n  \\<not> (b \\<in> new \\<or> b \\<in> have)\n\ngoal (1 subgoal):\n 1. \\<not> (b \\<in> new \\<or> b \\<in> have) \\<Longrightarrow>\n    b \\<in> {b. \\<exists>a m.\n                   a \\<in> new \\<and>\n                   m \\<le> Suc n \\<and>\n                   (a, b)\n                   \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                         m} \\<union>\n            have", "with b"], ["proof (chain)\npicking this:\n  b \\<in> {uu.\n           \\<exists>a.\n              (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n              a \\<notin> new \\<and>\n              a \\<notin> have \\<and>\n              (\\<exists>m\\<le>n.\n                  (a, uu)\n                  \\<in> (rel \\<inter>\n                         {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n                        m)} \\<union>\n          (new \\<union> have)\n  \\<not> (b \\<in> new \\<or> b \\<in> have)", "have \"b \\<in> ?l1\""], ["proof (prove)\nusing this:\n  b \\<in> {uu.\n           \\<exists>a.\n              (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n              a \\<notin> new \\<and>\n              a \\<notin> have \\<and>\n              (\\<exists>m\\<le>n.\n                  (a, uu)\n                  \\<in> (rel \\<inter>\n                         {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n                        m)} \\<union>\n          (new \\<union> have)\n  \\<not> (b \\<in> new \\<or> b \\<in> have)\n\ngoal (1 subgoal):\n 1. b \\<in> {uu.\n             \\<exists>a.\n                (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n                a \\<notin> new \\<and>\n                a \\<notin> have \\<and>\n                (\\<exists>m\\<le>n.\n                    (a, uu)\n                    \\<in> (rel \\<inter>\n                           {(a, b).\n                            b \\<notin> new \\<and> b \\<notin> have}) ^^\n                          m)}", "by auto"], ["proof (state)\nthis:\n  b \\<in> {uu.\n           \\<exists>a.\n              (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n              a \\<notin> new \\<and>\n              a \\<notin> have \\<and>\n              (\\<exists>m\\<le>n.\n                  (a, uu)\n                  \\<in> (rel \\<inter>\n                         {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n                        m)}\n\ngoal (1 subgoal):\n 1. \\<not> (b \\<in> new \\<or> b \\<in> have) \\<Longrightarrow>\n    b \\<in> {b. \\<exists>a m.\n                   a \\<in> new \\<and>\n                   m \\<le> Suc n \\<and>\n                   (a, b)\n                   \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                         m} \\<union>\n            have", "then"], ["proof (chain)\npicking this:\n  b \\<in> {uu.\n           \\<exists>a.\n              (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n              a \\<notin> new \\<and>\n              a \\<notin> have \\<and>\n              (\\<exists>m\\<le>n.\n                  (a, uu)\n                  \\<in> (rel \\<inter>\n                         {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n                        m)}", "obtain a2 a1 m where a2n: \"a2 \\<notin> new\" and a2h: \"a2 \\<notin> have\" and a1: \"a1 \\<in> new\"\n          and a1a2: \"(a1,a2) \\<in> rel\" and m: \"m \\<le> n\" and a2b: \"(a2,b) \\<in> ?reln m\""], ["proof (prove)\nusing this:\n  b \\<in> {uu.\n           \\<exists>a.\n              (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n              a \\<notin> new \\<and>\n              a \\<notin> have \\<and>\n              (\\<exists>m\\<le>n.\n                  (a, uu)\n                  \\<in> (rel \\<inter>\n                         {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n                        m)}\n\ngoal (1 subgoal):\n 1. (\\<And>a2 a1 m.\n        \\<lbrakk>a2 \\<notin> new; a2 \\<notin> have; a1 \\<in> new;\n         (a1, a2) \\<in> rel; m \\<le> n;\n         (a2, b)\n         \\<in> (rel \\<inter>\n                {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n               m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a2 \\<notin> new\n  a2 \\<notin> have\n  a1 \\<in> new\n  (a1, a2) \\<in> rel\n  m \\<le> n\n  (a2, b)\n  \\<in> (rel \\<inter> {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^ m\n\ngoal (1 subgoal):\n 1. \\<not> (b \\<in> new \\<or> b \\<in> have) \\<Longrightarrow>\n    b \\<in> {b. \\<exists>a m.\n                   a \\<in> new \\<and>\n                   m \\<le> Suc n \\<and>\n                   (a, b)\n                   \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                         m} \\<union>\n            have", "have \"b \\<in> ?r1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> {b. \\<exists>a m.\n                   a \\<in> new \\<and>\n                   m \\<le> Suc n \\<and>\n                   (a, b)\n                   \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ m}", "by (rule CollectI, rule exI, rule exI [of _ \"Suc m\"], intro conjI, rule a1, simp add: m, rule relpow_Suc_I2, rule, rule a1a2, simp add: a2h, insert a2b, induct m arbitrary: a2 b, auto)"], ["proof (state)\nthis:\n  b \\<in> {b. \\<exists>a m.\n                 a \\<in> new \\<and>\n                 m \\<le> Suc n \\<and>\n                 (a, b) \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ m}\n\ngoal (1 subgoal):\n 1. \\<not> (b \\<in> new \\<or> b \\<in> have) \\<Longrightarrow>\n    b \\<in> {b. \\<exists>a m.\n                   a \\<in> new \\<and>\n                   m \\<le> Suc n \\<and>\n                   (a, b)\n                   \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                         m} \\<union>\n            have", "then"], ["proof (chain)\npicking this:\n  b \\<in> {b. \\<exists>a m.\n                 a \\<in> new \\<and>\n                 m \\<le> Suc n \\<and>\n                 (a, b) \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ m}", "show ?thesis"], ["proof (prove)\nusing this:\n  b \\<in> {b. \\<exists>a m.\n                 a \\<in> new \\<and>\n                 m \\<le> Suc n \\<and>\n                 (a, b) \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ m}\n\ngoal (1 subgoal):\n 1. b \\<in> {b. \\<exists>a m.\n                   a \\<in> new \\<and>\n                   m \\<le> Suc n \\<and>\n                   (a, b)\n                   \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                         m} \\<union>\n            have", "by auto"], ["proof (state)\nthis:\n  b \\<in> {b. \\<exists>a m.\n                 a \\<in> new \\<and>\n                 m \\<le> Suc n \\<and>\n                 (a, b)\n                 \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                       m} \\<union>\n          have\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b \\<in> {b. \\<exists>a m.\n                 a \\<in> new \\<and>\n                 m \\<le> Suc n \\<and>\n                 (a, b)\n                 \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                       m} \\<union>\n          have\n\ngoal (1 subgoal):\n 1. nnew \\<noteq> [] \\<Longrightarrow>\n    set_of (relpow_i nnew hhave (Suc n)) =\n    {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> set nnew \\<and>\n        m \\<le> Suc n \\<and>\n        (a, b)\n        \\<in> (rel \\<inter>\n               {a. case a of\n                   (a, b) \\<Rightarrow> b \\<notin> set_of hhave}) ^^\n              m} \\<union>\n    set_of hhave", "}"], ["proof (state)\nthis:\n  ?b2\n  \\<in> {uu.\n         \\<exists>a.\n            (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n            a \\<notin> new \\<and>\n            a \\<notin> have \\<and>\n            (\\<exists>m\\<le>n.\n                (a, uu)\n                \\<in> (rel \\<inter>\n                       {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n                      m)} \\<union>\n        (new \\<union> have) \\<Longrightarrow>\n  ?b2\n  \\<in> {b. \\<exists>a m.\n               a \\<in> new \\<and>\n               m \\<le> Suc n \\<and>\n               (a, b)\n               \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ m} \\<union>\n        have\n\ngoal (1 subgoal):\n 1. nnew \\<noteq> [] \\<Longrightarrow>\n    set_of (relpow_i nnew hhave (Suc n)) =\n    {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> set nnew \\<and>\n        m \\<le> Suc n \\<and>\n        (a, b)\n        \\<in> (rel \\<inter>\n               {a. case a of\n                   (a, b) \\<Rightarrow> b \\<notin> set_of hhave}) ^^\n              m} \\<union>\n    set_of hhave", "moreover"], ["proof (state)\nthis:\n  ?b2\n  \\<in> {uu.\n         \\<exists>a.\n            (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n            a \\<notin> new \\<and>\n            a \\<notin> have \\<and>\n            (\\<exists>m\\<le>n.\n                (a, uu)\n                \\<in> (rel \\<inter>\n                       {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n                      m)} \\<union>\n        (new \\<union> have) \\<Longrightarrow>\n  ?b2\n  \\<in> {b. \\<exists>a m.\n               a \\<in> new \\<and>\n               m \\<le> Suc n \\<and>\n               (a, b)\n               \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ m} \\<union>\n        have\n\ngoal (1 subgoal):\n 1. nnew \\<noteq> [] \\<Longrightarrow>\n    set_of (relpow_i nnew hhave (Suc n)) =\n    {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> set nnew \\<and>\n        m \\<le> Suc n \\<and>\n        (a, b)\n        \\<in> (rel \\<inter>\n               {a. case a of\n                   (a, b) \\<Rightarrow> b \\<notin> set_of hhave}) ^^\n              m} \\<union>\n    set_of hhave", "{"], ["proof (state)\nthis:\n  ?b2\n  \\<in> {uu.\n         \\<exists>a.\n            (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n            a \\<notin> new \\<and>\n            a \\<notin> have \\<and>\n            (\\<exists>m\\<le>n.\n                (a, uu)\n                \\<in> (rel \\<inter>\n                       {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n                      m)} \\<union>\n        (new \\<union> have) \\<Longrightarrow>\n  ?b2\n  \\<in> {b. \\<exists>a m.\n               a \\<in> new \\<and>\n               m \\<le> Suc n \\<and>\n               (a, b)\n               \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ m} \\<union>\n        have\n\ngoal (1 subgoal):\n 1. nnew \\<noteq> [] \\<Longrightarrow>\n    set_of (relpow_i nnew hhave (Suc n)) =\n    {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> set nnew \\<and>\n        m \\<le> Suc n \\<and>\n        (a, b)\n        \\<in> (rel \\<inter>\n               {a. case a of\n                   (a, b) \\<Rightarrow> b \\<notin> set_of hhave}) ^^\n              m} \\<union>\n    set_of hhave", "fix b"], ["proof (state)\ngoal (1 subgoal):\n 1. nnew \\<noteq> [] \\<Longrightarrow>\n    set_of (relpow_i nnew hhave (Suc n)) =\n    {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> set nnew \\<and>\n        m \\<le> Suc n \\<and>\n        (a, b)\n        \\<in> (rel \\<inter>\n               {a. case a of\n                   (a, b) \\<Rightarrow> b \\<notin> set_of hhave}) ^^\n              m} \\<union>\n    set_of hhave", "assume b: \"b \\<in> ?r\""], ["proof (state)\nthis:\n  b \\<in> {b. \\<exists>a m.\n                 a \\<in> new \\<and>\n                 m \\<le> Suc n \\<and>\n                 (a, b)\n                 \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                       m} \\<union>\n          have\n\ngoal (1 subgoal):\n 1. nnew \\<noteq> [] \\<Longrightarrow>\n    set_of (relpow_i nnew hhave (Suc n)) =\n    {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> set nnew \\<and>\n        m \\<le> Suc n \\<and>\n        (a, b)\n        \\<in> (rel \\<inter>\n               {a. case a of\n                   (a, b) \\<Rightarrow> b \\<notin> set_of hhave}) ^^\n              m} \\<union>\n    set_of hhave", "then"], ["proof (chain)\npicking this:\n  b \\<in> {b. \\<exists>a m.\n                 a \\<in> new \\<and>\n                 m \\<le> Suc n \\<and>\n                 (a, b)\n                 \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                       m} \\<union>\n          have", "have \"b \\<in> ?l\""], ["proof (prove)\nusing this:\n  b \\<in> {b. \\<exists>a m.\n                 a \\<in> new \\<and>\n                 m \\<le> Suc n \\<and>\n                 (a, b)\n                 \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                       m} \\<union>\n          have\n\ngoal (1 subgoal):\n 1. b \\<in> {uu.\n             \\<exists>a.\n                (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n                a \\<notin> new \\<and>\n                a \\<notin> have \\<and>\n                (\\<exists>m\\<le>n.\n                    (a, uu)\n                    \\<in> (rel \\<inter>\n                           {(a, b).\n                            b \\<notin> new \\<and> b \\<notin> have}) ^^\n                          m)} \\<union>\n            (new \\<union> have)", "proof (cases \"b \\<in> have\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>b \\<in> {b. \\<exists>a m.\n                            a \\<in> new \\<and>\n                            m \\<le> Suc n \\<and>\n                            (a, b)\n                            \\<in> (rel \\<inter>\n                                   {(a, b). b \\<notin> have}) ^^\n                                  m} \\<union>\n                     have;\n     b \\<in> have\\<rbrakk>\n    \\<Longrightarrow> b \\<in> {uu.\n                               \\<exists>a.\n                                  (\\<exists>aa\\<in>new.\n(aa, a) \\<in> rel) \\<and>\n                                  a \\<notin> new \\<and>\n                                  a \\<notin> have \\<and>\n                                  (\\<exists>m\\<le>n.\n(a, uu)\n\\<in> (rel \\<inter> {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n      m)} \\<union>\n                              (new \\<union> have)\n 2. \\<lbrakk>b \\<in> {b. \\<exists>a m.\n                            a \\<in> new \\<and>\n                            m \\<le> Suc n \\<and>\n                            (a, b)\n                            \\<in> (rel \\<inter>\n                                   {(a, b). b \\<notin> have}) ^^\n                                  m} \\<union>\n                     have;\n     b \\<notin> have\\<rbrakk>\n    \\<Longrightarrow> b \\<in> {uu.\n                               \\<exists>a.\n                                  (\\<exists>aa\\<in>new.\n(aa, a) \\<in> rel) \\<and>\n                                  a \\<notin> new \\<and>\n                                  a \\<notin> have \\<and>\n                                  (\\<exists>m\\<le>n.\n(a, uu)\n\\<in> (rel \\<inter> {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n      m)} \\<union>\n                              (new \\<union> have)", "case True"], ["proof (state)\nthis:\n  b \\<in> have\n\ngoal (2 subgoals):\n 1. \\<lbrakk>b \\<in> {b. \\<exists>a m.\n                            a \\<in> new \\<and>\n                            m \\<le> Suc n \\<and>\n                            (a, b)\n                            \\<in> (rel \\<inter>\n                                   {(a, b). b \\<notin> have}) ^^\n                                  m} \\<union>\n                     have;\n     b \\<in> have\\<rbrakk>\n    \\<Longrightarrow> b \\<in> {uu.\n                               \\<exists>a.\n                                  (\\<exists>aa\\<in>new.\n(aa, a) \\<in> rel) \\<and>\n                                  a \\<notin> new \\<and>\n                                  a \\<notin> have \\<and>\n                                  (\\<exists>m\\<le>n.\n(a, uu)\n\\<in> (rel \\<inter> {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n      m)} \\<union>\n                              (new \\<union> have)\n 2. \\<lbrakk>b \\<in> {b. \\<exists>a m.\n                            a \\<in> new \\<and>\n                            m \\<le> Suc n \\<and>\n                            (a, b)\n                            \\<in> (rel \\<inter>\n                                   {(a, b). b \\<notin> have}) ^^\n                                  m} \\<union>\n                     have;\n     b \\<notin> have\\<rbrakk>\n    \\<Longrightarrow> b \\<in> {uu.\n                               \\<exists>a.\n                                  (\\<exists>aa\\<in>new.\n(aa, a) \\<in> rel) \\<and>\n                                  a \\<notin> new \\<and>\n                                  a \\<notin> have \\<and>\n                                  (\\<exists>m\\<le>n.\n(a, uu)\n\\<in> (rel \\<inter> {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n      m)} \\<union>\n                              (new \\<union> have)", "then"], ["proof (chain)\npicking this:\n  b \\<in> have", "show ?thesis"], ["proof (prove)\nusing this:\n  b \\<in> have\n\ngoal (1 subgoal):\n 1. b \\<in> {uu.\n             \\<exists>a.\n                (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n                a \\<notin> new \\<and>\n                a \\<notin> have \\<and>\n                (\\<exists>m\\<le>n.\n                    (a, uu)\n                    \\<in> (rel \\<inter>\n                           {(a, b).\n                            b \\<notin> new \\<and> b \\<notin> have}) ^^\n                          m)} \\<union>\n            (new \\<union> have)", "by auto"], ["proof (state)\nthis:\n  b \\<in> {uu.\n           \\<exists>a.\n              (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n              a \\<notin> new \\<and>\n              a \\<notin> have \\<and>\n              (\\<exists>m\\<le>n.\n                  (a, uu)\n                  \\<in> (rel \\<inter>\n                         {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n                        m)} \\<union>\n          (new \\<union> have)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<in> {b. \\<exists>a m.\n                            a \\<in> new \\<and>\n                            m \\<le> Suc n \\<and>\n                            (a, b)\n                            \\<in> (rel \\<inter>\n                                   {(a, b). b \\<notin> have}) ^^\n                                  m} \\<union>\n                     have;\n     b \\<notin> have\\<rbrakk>\n    \\<Longrightarrow> b \\<in> {uu.\n                               \\<exists>a.\n                                  (\\<exists>aa\\<in>new.\n(aa, a) \\<in> rel) \\<and>\n                                  a \\<notin> new \\<and>\n                                  a \\<notin> have \\<and>\n                                  (\\<exists>m\\<le>n.\n(a, uu)\n\\<in> (rel \\<inter> {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n      m)} \\<union>\n                              (new \\<union> have)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<in> {b. \\<exists>a m.\n                            a \\<in> new \\<and>\n                            m \\<le> Suc n \\<and>\n                            (a, b)\n                            \\<in> (rel \\<inter>\n                                   {(a, b). b \\<notin> have}) ^^\n                                  m} \\<union>\n                     have;\n     b \\<notin> have\\<rbrakk>\n    \\<Longrightarrow> b \\<in> {uu.\n                               \\<exists>a.\n                                  (\\<exists>aa\\<in>new.\n(aa, a) \\<in> rel) \\<and>\n                                  a \\<notin> new \\<and>\n                                  a \\<notin> have \\<and>\n                                  (\\<exists>m\\<le>n.\n(a, uu)\n\\<in> (rel \\<inter> {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n      m)} \\<union>\n                              (new \\<union> have)", "case False"], ["proof (state)\nthis:\n  b \\<notin> have\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<in> {b. \\<exists>a m.\n                            a \\<in> new \\<and>\n                            m \\<le> Suc n \\<and>\n                            (a, b)\n                            \\<in> (rel \\<inter>\n                                   {(a, b). b \\<notin> have}) ^^\n                                  m} \\<union>\n                     have;\n     b \\<notin> have\\<rbrakk>\n    \\<Longrightarrow> b \\<in> {uu.\n                               \\<exists>a.\n                                  (\\<exists>aa\\<in>new.\n(aa, a) \\<in> rel) \\<and>\n                                  a \\<notin> new \\<and>\n                                  a \\<notin> have \\<and>\n                                  (\\<exists>m\\<le>n.\n(a, uu)\n\\<in> (rel \\<inter> {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n      m)} \\<union>\n                              (new \\<union> have)", "with b"], ["proof (chain)\npicking this:\n  b \\<in> {b. \\<exists>a m.\n                 a \\<in> new \\<and>\n                 m \\<le> Suc n \\<and>\n                 (a, b)\n                 \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                       m} \\<union>\n          have\n  b \\<notin> have", "have \"b \\<in> ?r1\""], ["proof (prove)\nusing this:\n  b \\<in> {b. \\<exists>a m.\n                 a \\<in> new \\<and>\n                 m \\<le> Suc n \\<and>\n                 (a, b)\n                 \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                       m} \\<union>\n          have\n  b \\<notin> have\n\ngoal (1 subgoal):\n 1. b \\<in> {b. \\<exists>a m.\n                   a \\<in> new \\<and>\n                   m \\<le> Suc n \\<and>\n                   (a, b)\n                   \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ m}", "by auto"], ["proof (state)\nthis:\n  b \\<in> {b. \\<exists>a m.\n                 a \\<in> new \\<and>\n                 m \\<le> Suc n \\<and>\n                 (a, b) \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ m}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<in> {b. \\<exists>a m.\n                            a \\<in> new \\<and>\n                            m \\<le> Suc n \\<and>\n                            (a, b)\n                            \\<in> (rel \\<inter>\n                                   {(a, b). b \\<notin> have}) ^^\n                                  m} \\<union>\n                     have;\n     b \\<notin> have\\<rbrakk>\n    \\<Longrightarrow> b \\<in> {uu.\n                               \\<exists>a.\n                                  (\\<exists>aa\\<in>new.\n(aa, a) \\<in> rel) \\<and>\n                                  a \\<notin> new \\<and>\n                                  a \\<notin> have \\<and>\n                                  (\\<exists>m\\<le>n.\n(a, uu)\n\\<in> (rel \\<inter> {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n      m)} \\<union>\n                              (new \\<union> have)", "then"], ["proof (chain)\npicking this:\n  b \\<in> {b. \\<exists>a m.\n                 a \\<in> new \\<and>\n                 m \\<le> Suc n \\<and>\n                 (a, b) \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ m}", "obtain a m where a: \"a \\<in> new\" and m: \"m \\<le> Suc n\" and ab: \"(a, b) \\<in> ?rel m\""], ["proof (prove)\nusing this:\n  b \\<in> {b. \\<exists>a m.\n                 a \\<in> new \\<and>\n                 m \\<le> Suc n \\<and>\n                 (a, b) \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ m}\n\ngoal (1 subgoal):\n 1. (\\<And>a m.\n        \\<lbrakk>a \\<in> new; m \\<le> Suc n;\n         (a, b) \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a \\<in> new\n  m \\<le> Suc n\n  (a, b) \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<in> {b. \\<exists>a m.\n                            a \\<in> new \\<and>\n                            m \\<le> Suc n \\<and>\n                            (a, b)\n                            \\<in> (rel \\<inter>\n                                   {(a, b). b \\<notin> have}) ^^\n                                  m} \\<union>\n                     have;\n     b \\<notin> have\\<rbrakk>\n    \\<Longrightarrow> b \\<in> {uu.\n                               \\<exists>a.\n                                  (\\<exists>aa\\<in>new.\n(aa, a) \\<in> rel) \\<and>\n                                  a \\<notin> new \\<and>\n                                  a \\<notin> have \\<and>\n                                  (\\<exists>m\\<le>n.\n(a, uu)\n\\<in> (rel \\<inter> {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n      m)} \\<union>\n                              (new \\<union> have)", "have seq: \"\\<exists> a \\<in> new. (a, b) \\<in> ?rel m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>new.\n       (a, b) \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ m", "using a  ab"], ["proof (prove)\nusing this:\n  a \\<in> new\n  (a, b) \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ m\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>new.\n       (a, b) \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ m", "by auto"], ["proof (state)\nthis:\n  \\<exists>a\\<in>new.\n     (a, b) \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<in> {b. \\<exists>a m.\n                            a \\<in> new \\<and>\n                            m \\<le> Suc n \\<and>\n                            (a, b)\n                            \\<in> (rel \\<inter>\n                                   {(a, b). b \\<notin> have}) ^^\n                                  m} \\<union>\n                     have;\n     b \\<notin> have\\<rbrakk>\n    \\<Longrightarrow> b \\<in> {uu.\n                               \\<exists>a.\n                                  (\\<exists>aa\\<in>new.\n(aa, a) \\<in> rel) \\<and>\n                                  a \\<notin> new \\<and>\n                                  a \\<notin> have \\<and>\n                                  (\\<exists>m\\<le>n.\n(a, uu)\n\\<in> (rel \\<inter> {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n      m)} \\<union>\n                              (new \\<union> have)", "obtain l where l: \"l = (LEAST m. (\\<exists> a \\<in> new. (a, b) \\<in> ?rel m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l.\n        l =\n        (LEAST m.\n            \\<exists>a\\<in>new.\n               (a, b)\n               \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                     m) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  l =\n  (LEAST m.\n      \\<exists>a\\<in>new.\n         (a, b) \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ m)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<in> {b. \\<exists>a m.\n                            a \\<in> new \\<and>\n                            m \\<le> Suc n \\<and>\n                            (a, b)\n                            \\<in> (rel \\<inter>\n                                   {(a, b). b \\<notin> have}) ^^\n                                  m} \\<union>\n                     have;\n     b \\<notin> have\\<rbrakk>\n    \\<Longrightarrow> b \\<in> {uu.\n                               \\<exists>a.\n                                  (\\<exists>aa\\<in>new.\n(aa, a) \\<in> rel) \\<and>\n                                  a \\<notin> new \\<and>\n                                  a \\<notin> have \\<and>\n                                  (\\<exists>m\\<le>n.\n(a, uu)\n\\<in> (rel \\<inter> {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n      m)} \\<union>\n                              (new \\<union> have)", "have least: \"(\\<exists> a \\<in> new. (a, b) \\<in> ?rel l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>new.\n       (a, b) \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ l", "by (unfold l, rule LeastI, rule seq)"], ["proof (state)\nthis:\n  \\<exists>a\\<in>new.\n     (a, b) \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<in> {b. \\<exists>a m.\n                            a \\<in> new \\<and>\n                            m \\<le> Suc n \\<and>\n                            (a, b)\n                            \\<in> (rel \\<inter>\n                                   {(a, b). b \\<notin> have}) ^^\n                                  m} \\<union>\n                     have;\n     b \\<notin> have\\<rbrakk>\n    \\<Longrightarrow> b \\<in> {uu.\n                               \\<exists>a.\n                                  (\\<exists>aa\\<in>new.\n(aa, a) \\<in> rel) \\<and>\n                                  a \\<notin> new \\<and>\n                                  a \\<notin> have \\<and>\n                                  (\\<exists>m\\<le>n.\n(a, uu)\n\\<in> (rel \\<inter> {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n      m)} \\<union>\n                              (new \\<union> have)", "have lm: \"l \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<le> m", "unfolding l"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST m.\n        \\<exists>a\\<in>new.\n           (a, b) \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ m)\n    \\<le> m", "by (rule Least_le, rule seq)"], ["proof (state)\nthis:\n  l \\<le> m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<in> {b. \\<exists>a m.\n                            a \\<in> new \\<and>\n                            m \\<le> Suc n \\<and>\n                            (a, b)\n                            \\<in> (rel \\<inter>\n                                   {(a, b). b \\<notin> have}) ^^\n                                  m} \\<union>\n                     have;\n     b \\<notin> have\\<rbrakk>\n    \\<Longrightarrow> b \\<in> {uu.\n                               \\<exists>a.\n                                  (\\<exists>aa\\<in>new.\n(aa, a) \\<in> rel) \\<and>\n                                  a \\<notin> new \\<and>\n                                  a \\<notin> have \\<and>\n                                  (\\<exists>m\\<le>n.\n(a, uu)\n\\<in> (rel \\<inter> {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n      m)} \\<union>\n                              (new \\<union> have)", "with m"], ["proof (chain)\npicking this:\n  m \\<le> Suc n\n  l \\<le> m", "have ln: \"l \\<le> Suc n\""], ["proof (prove)\nusing this:\n  m \\<le> Suc n\n  l \\<le> m\n\ngoal (1 subgoal):\n 1. l \\<le> Suc n", "by auto"], ["proof (state)\nthis:\n  l \\<le> Suc n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<in> {b. \\<exists>a m.\n                            a \\<in> new \\<and>\n                            m \\<le> Suc n \\<and>\n                            (a, b)\n                            \\<in> (rel \\<inter>\n                                   {(a, b). b \\<notin> have}) ^^\n                                  m} \\<union>\n                     have;\n     b \\<notin> have\\<rbrakk>\n    \\<Longrightarrow> b \\<in> {uu.\n                               \\<exists>a.\n                                  (\\<exists>aa\\<in>new.\n(aa, a) \\<in> rel) \\<and>\n                                  a \\<notin> new \\<and>\n                                  a \\<notin> have \\<and>\n                                  (\\<exists>m\\<le>n.\n(a, uu)\n\\<in> (rel \\<inter> {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n      m)} \\<union>\n                              (new \\<union> have)", "from least"], ["proof (chain)\npicking this:\n  \\<exists>a\\<in>new.\n     (a, b) \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ l", "obtain a where a: \"a \\<in> new\"\n          and ab: \"(a, b) \\<in> ?rel l\""], ["proof (prove)\nusing this:\n  \\<exists>a\\<in>new.\n     (a, b) \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ l\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> new;\n         (a, b) \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a \\<in> new\n  (a, b) \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<in> {b. \\<exists>a m.\n                            a \\<in> new \\<and>\n                            m \\<le> Suc n \\<and>\n                            (a, b)\n                            \\<in> (rel \\<inter>\n                                   {(a, b). b \\<notin> have}) ^^\n                                  m} \\<union>\n                     have;\n     b \\<notin> have\\<rbrakk>\n    \\<Longrightarrow> b \\<in> {uu.\n                               \\<exists>a.\n                                  (\\<exists>aa\\<in>new.\n(aa, a) \\<in> rel) \\<and>\n                                  a \\<notin> new \\<and>\n                                  a \\<notin> have \\<and>\n                                  (\\<exists>m\\<le>n.\n(a, uu)\n\\<in> (rel \\<inter> {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n      m)} \\<union>\n                              (new \\<union> have)", "from ab [unfolded relpow_fun_conv]"], ["proof (chain)\npicking this:\n  \\<exists>f.\n     f 0 = a \\<and>\n     f l = b \\<and>\n     (\\<forall>i<l.\n         (f i, f (Suc i)) \\<in> rel \\<inter> {(a, b). b \\<notin> have})", "obtain f where fa: \"f 0 = a\" and fb: \"b = f l\"\n          and steps: \"\\<And> i. i < l \\<Longrightarrow> (f i, f (Suc i)) \\<in> ?rel 1\""], ["proof (prove)\nusing this:\n  \\<exists>f.\n     f 0 = a \\<and>\n     f l = b \\<and>\n     (\\<forall>i<l.\n         (f i, f (Suc i)) \\<in> rel \\<inter> {(a, b). b \\<notin> have})\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f 0 = a; b = f l;\n         \\<And>i.\n            i < l \\<Longrightarrow>\n            (f i, f (Suc i))\n            \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f 0 = a\n  b = f l\n  ?i < l \\<Longrightarrow>\n  (f ?i, f (Suc ?i)) \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<in> {b. \\<exists>a m.\n                            a \\<in> new \\<and>\n                            m \\<le> Suc n \\<and>\n                            (a, b)\n                            \\<in> (rel \\<inter>\n                                   {(a, b). b \\<notin> have}) ^^\n                                  m} \\<union>\n                     have;\n     b \\<notin> have\\<rbrakk>\n    \\<Longrightarrow> b \\<in> {uu.\n                               \\<exists>a.\n                                  (\\<exists>aa\\<in>new.\n(aa, a) \\<in> rel) \\<and>\n                                  a \\<notin> new \\<and>\n                                  a \\<notin> have \\<and>\n                                  (\\<exists>m\\<le>n.\n(a, uu)\n\\<in> (rel \\<inter> {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n      m)} \\<union>\n                              (new \\<union> have)", "{"], ["proof (state)\nthis:\n  f 0 = a\n  b = f l\n  ?i < l \\<Longrightarrow>\n  (f ?i, f (Suc ?i)) \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<in> {b. \\<exists>a m.\n                            a \\<in> new \\<and>\n                            m \\<le> Suc n \\<and>\n                            (a, b)\n                            \\<in> (rel \\<inter>\n                                   {(a, b). b \\<notin> have}) ^^\n                                  m} \\<union>\n                     have;\n     b \\<notin> have\\<rbrakk>\n    \\<Longrightarrow> b \\<in> {uu.\n                               \\<exists>a.\n                                  (\\<exists>aa\\<in>new.\n(aa, a) \\<in> rel) \\<and>\n                                  a \\<notin> new \\<and>\n                                  a \\<notin> have \\<and>\n                                  (\\<exists>m\\<le>n.\n(a, uu)\n\\<in> (rel \\<inter> {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n      m)} \\<union>\n                              (new \\<union> have)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<in> {b. \\<exists>a m.\n                            a \\<in> new \\<and>\n                            m \\<le> Suc n \\<and>\n                            (a, b)\n                            \\<in> (rel \\<inter>\n                                   {(a, b). b \\<notin> have}) ^^\n                                  m} \\<union>\n                     have;\n     b \\<notin> have\\<rbrakk>\n    \\<Longrightarrow> b \\<in> {uu.\n                               \\<exists>a.\n                                  (\\<exists>aa\\<in>new.\n(aa, a) \\<in> rel) \\<and>\n                                  a \\<notin> new \\<and>\n                                  a \\<notin> have \\<and>\n                                  (\\<exists>m\\<le>n.\n(a, uu)\n\\<in> (rel \\<inter> {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n      m)} \\<union>\n                              (new \\<union> have)", "assume i: \"i < l\""], ["proof (state)\nthis:\n  i < l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<in> {b. \\<exists>a m.\n                            a \\<in> new \\<and>\n                            m \\<le> Suc n \\<and>\n                            (a, b)\n                            \\<in> (rel \\<inter>\n                                   {(a, b). b \\<notin> have}) ^^\n                                  m} \\<union>\n                     have;\n     b \\<notin> have\\<rbrakk>\n    \\<Longrightarrow> b \\<in> {uu.\n                               \\<exists>a.\n                                  (\\<exists>aa\\<in>new.\n(aa, a) \\<in> rel) \\<and>\n                                  a \\<notin> new \\<and>\n                                  a \\<notin> have \\<and>\n                                  (\\<exists>m\\<le>n.\n(a, uu)\n\\<in> (rel \\<inter> {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n      m)} \\<union>\n                              (new \\<union> have)", "have main: \"f (Suc i) \\<notin> new\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (Suc i) \\<notin> new", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. f (Suc i) \\<in> new \\<Longrightarrow> False", "assume new: \"f (Suc i) \\<in> new\""], ["proof (state)\nthis:\n  f (Suc i) \\<in> new\n\ngoal (1 subgoal):\n 1. f (Suc i) \\<in> new \\<Longrightarrow> False", "let ?f = \"\\<lambda> j. f (Suc i + j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. f (Suc i) \\<in> new \\<Longrightarrow> False", "have seq: \"(f (Suc i), b) \\<in> ?rel (l - Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f (Suc i), b)\n    \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ (l - Suc i)", "unfolding relpow_fun_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>fa.\n       fa 0 = f (Suc i) \\<and>\n       fa (l - Suc i) = b \\<and>\n       (\\<forall>ia<l - Suc i.\n           (fa ia, fa (Suc ia))\n           \\<in> rel \\<inter> {(a, b). b \\<notin> have})", "proof (rule exI[of _ ?f], intro conjI allI impI)"], ["proof (state)\ngoal (3 subgoals):\n 1. f (Suc i + 0) = f (Suc i)\n 2. f (Suc i + (l - Suc i)) = b\n 3. \\<And>ia.\n       ia < l - Suc i \\<Longrightarrow>\n       (f (Suc i + ia), f (Suc i + Suc ia))\n       \\<in> rel \\<inter> {(a, b). b \\<notin> have}", "from i"], ["proof (chain)\npicking this:\n  i < l", "show \"f (Suc i + (l - Suc i)) = b\""], ["proof (prove)\nusing this:\n  i < l\n\ngoal (1 subgoal):\n 1. f (Suc i + (l - Suc i)) = b", "unfolding fb"], ["proof (prove)\nusing this:\n  i < l\n\ngoal (1 subgoal):\n 1. f (Suc i + (l - Suc i)) = f l", "by auto"], ["proof (state)\nthis:\n  f (Suc i + (l - Suc i)) = b\n\ngoal (2 subgoals):\n 1. f (Suc i + 0) = f (Suc i)\n 2. \\<And>ia.\n       ia < l - Suc i \\<Longrightarrow>\n       (f (Suc i + ia), f (Suc i + Suc ia))\n       \\<in> rel \\<inter> {(a, b). b \\<notin> have}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. f (Suc i + 0) = f (Suc i)\n 2. \\<And>ia.\n       ia < l - Suc i \\<Longrightarrow>\n       (f (Suc i + ia), f (Suc i + Suc ia))\n       \\<in> rel \\<inter> {(a, b). b \\<notin> have}", "fix j"], ["proof (state)\ngoal (2 subgoals):\n 1. f (Suc i + 0) = f (Suc i)\n 2. \\<And>ia.\n       ia < l - Suc i \\<Longrightarrow>\n       (f (Suc i + ia), f (Suc i + Suc ia))\n       \\<in> rel \\<inter> {(a, b). b \\<notin> have}", "assume \"j < l - Suc i\""], ["proof (state)\nthis:\n  j < l - Suc i\n\ngoal (2 subgoals):\n 1. f (Suc i + 0) = f (Suc i)\n 2. \\<And>ia.\n       ia < l - Suc i \\<Longrightarrow>\n       (f (Suc i + ia), f (Suc i + Suc ia))\n       \\<in> rel \\<inter> {(a, b). b \\<notin> have}", "then"], ["proof (chain)\npicking this:\n  j < l - Suc i", "have small: \"Suc i + j < l\""], ["proof (prove)\nusing this:\n  j < l - Suc i\n\ngoal (1 subgoal):\n 1. Suc i + j < l", "by auto"], ["proof (state)\nthis:\n  Suc i + j < l\n\ngoal (2 subgoals):\n 1. f (Suc i + 0) = f (Suc i)\n 2. \\<And>ia.\n       ia < l - Suc i \\<Longrightarrow>\n       (f (Suc i + ia), f (Suc i + Suc ia))\n       \\<in> rel \\<inter> {(a, b). b \\<notin> have}", "show \"(?f j, ?f (Suc j)) \\<in> rel \\<inter> {(a, b). b \\<notin> have}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f (Suc i + j), f (Suc i + Suc j))\n    \\<in> rel \\<inter> {(a, b). b \\<notin> have}", "using steps [OF small]"], ["proof (prove)\nusing this:\n  (f (Suc i + j), f (Suc (Suc i + j)))\n  \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ 1\n\ngoal (1 subgoal):\n 1. (f (Suc i + j), f (Suc i + Suc j))\n    \\<in> rel \\<inter> {(a, b). b \\<notin> have}", "by auto"], ["proof (state)\nthis:\n  (f (Suc i + j), f (Suc i + Suc j))\n  \\<in> rel \\<inter> {(a, b). b \\<notin> have}\n\ngoal (1 subgoal):\n 1. f (Suc i + 0) = f (Suc i)", "qed simp"], ["proof (state)\nthis:\n  (f (Suc i), b)\n  \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ (l - Suc i)\n\ngoal (1 subgoal):\n 1. f (Suc i) \\<in> new \\<Longrightarrow> False", "from i"], ["proof (chain)\npicking this:\n  i < l", "have small: \"l - Suc i < l\""], ["proof (prove)\nusing this:\n  i < l\n\ngoal (1 subgoal):\n 1. l - Suc i < l", "by auto"], ["proof (state)\nthis:\n  l - Suc i < l\n\ngoal (1 subgoal):\n 1. f (Suc i) \\<in> new \\<Longrightarrow> False", "from seq new"], ["proof (chain)\npicking this:\n  (f (Suc i), b)\n  \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ (l - Suc i)\n  f (Suc i) \\<in> new", "have \"\\<exists> a \\<in> new. (a, b) \\<in> ?rel (l - Suc i)\""], ["proof (prove)\nusing this:\n  (f (Suc i), b)\n  \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ (l - Suc i)\n  f (Suc i) \\<in> new\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>new.\n       (a, b) \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ (l - Suc i)", "by auto"], ["proof (state)\nthis:\n  \\<exists>a\\<in>new.\n     (a, b) \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ (l - Suc i)\n\ngoal (1 subgoal):\n 1. f (Suc i) \\<in> new \\<Longrightarrow> False", "with not_less_Least [OF small [unfolded l]]"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>a\\<in>new.\n             (a, b)\n             \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                   ((LEAST m.\n                        \\<exists>a\\<in>new.\n                           (a, b)\n                           \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                                 m) -\n                    Suc i))\n  \\<exists>a\\<in>new.\n     (a, b) \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ (l - Suc i)", "show False"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>a\\<in>new.\n             (a, b)\n             \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                   ((LEAST m.\n                        \\<exists>a\\<in>new.\n                           (a, b)\n                           \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                                 m) -\n                    Suc i))\n  \\<exists>a\\<in>new.\n     (a, b) \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ (l - Suc i)\n\ngoal (1 subgoal):\n 1. False", "unfolding l"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>a\\<in>new.\n             (a, b)\n             \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                   ((LEAST m.\n                        \\<exists>a\\<in>new.\n                           (a, b)\n                           \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n                                 m) -\n                    Suc i))\n  \\<exists>a\\<in>new.\n     (a, b)\n     \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^\n           ((LEAST m.\n                \\<exists>a\\<in>new.\n                   (a, b)\n                   \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ m) -\n            Suc i)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f (Suc i) \\<notin> new\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<in> {b. \\<exists>a m.\n                            a \\<in> new \\<and>\n                            m \\<le> Suc n \\<and>\n                            (a, b)\n                            \\<in> (rel \\<inter>\n                                   {(a, b). b \\<notin> have}) ^^\n                                  m} \\<union>\n                     have;\n     b \\<notin> have\\<rbrakk>\n    \\<Longrightarrow> b \\<in> {uu.\n                               \\<exists>a.\n                                  (\\<exists>aa\\<in>new.\n(aa, a) \\<in> rel) \\<and>\n                                  a \\<notin> new \\<and>\n                                  a \\<notin> have \\<and>\n                                  (\\<exists>m\\<le>n.\n(a, uu)\n\\<in> (rel \\<inter> {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n      m)} \\<union>\n                              (new \\<union> have)", "then"], ["proof (chain)\npicking this:\n  f (Suc i) \\<notin> new", "have \"(f i, f (Suc i)) \\<in> ?reln 1\""], ["proof (prove)\nusing this:\n  f (Suc i) \\<notin> new\n\ngoal (1 subgoal):\n 1. (f i, f (Suc i))\n    \\<in> (rel \\<inter> {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n          1", "using steps [OF i]"], ["proof (prove)\nusing this:\n  f (Suc i) \\<notin> new\n  (f i, f (Suc i)) \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ 1\n\ngoal (1 subgoal):\n 1. (f i, f (Suc i))\n    \\<in> (rel \\<inter> {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n          1", "by auto"], ["proof (state)\nthis:\n  (f i, f (Suc i))\n  \\<in> (rel \\<inter> {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^ 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<in> {b. \\<exists>a m.\n                            a \\<in> new \\<and>\n                            m \\<le> Suc n \\<and>\n                            (a, b)\n                            \\<in> (rel \\<inter>\n                                   {(a, b). b \\<notin> have}) ^^\n                                  m} \\<union>\n                     have;\n     b \\<notin> have\\<rbrakk>\n    \\<Longrightarrow> b \\<in> {uu.\n                               \\<exists>a.\n                                  (\\<exists>aa\\<in>new.\n(aa, a) \\<in> rel) \\<and>\n                                  a \\<notin> new \\<and>\n                                  a \\<notin> have \\<and>\n                                  (\\<exists>m\\<le>n.\n(a, uu)\n\\<in> (rel \\<inter> {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n      m)} \\<union>\n                              (new \\<union> have)", "}"], ["proof (state)\nthis:\n  ?i2 < l \\<Longrightarrow>\n  (f ?i2, f (Suc ?i2))\n  \\<in> (rel \\<inter> {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^ 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<in> {b. \\<exists>a m.\n                            a \\<in> new \\<and>\n                            m \\<le> Suc n \\<and>\n                            (a, b)\n                            \\<in> (rel \\<inter>\n                                   {(a, b). b \\<notin> have}) ^^\n                                  m} \\<union>\n                     have;\n     b \\<notin> have\\<rbrakk>\n    \\<Longrightarrow> b \\<in> {uu.\n                               \\<exists>a.\n                                  (\\<exists>aa\\<in>new.\n(aa, a) \\<in> rel) \\<and>\n                                  a \\<notin> new \\<and>\n                                  a \\<notin> have \\<and>\n                                  (\\<exists>m\\<le>n.\n(a, uu)\n\\<in> (rel \\<inter> {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n      m)} \\<union>\n                              (new \\<union> have)", "note steps = this"], ["proof (state)\nthis:\n  ?i2 < l \\<Longrightarrow>\n  (f ?i2, f (Suc ?i2))\n  \\<in> (rel \\<inter> {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^ 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<in> {b. \\<exists>a m.\n                            a \\<in> new \\<and>\n                            m \\<le> Suc n \\<and>\n                            (a, b)\n                            \\<in> (rel \\<inter>\n                                   {(a, b). b \\<notin> have}) ^^\n                                  m} \\<union>\n                     have;\n     b \\<notin> have\\<rbrakk>\n    \\<Longrightarrow> b \\<in> {uu.\n                               \\<exists>a.\n                                  (\\<exists>aa\\<in>new.\n(aa, a) \\<in> rel) \\<and>\n                                  a \\<notin> new \\<and>\n                                  a \\<notin> have \\<and>\n                                  (\\<exists>m\\<le>n.\n(a, uu)\n\\<in> (rel \\<inter> {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n      m)} \\<union>\n                              (new \\<union> have)", "have ab: \"(a, b) \\<in> ?reln l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> (rel \\<inter> {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n          l", "unfolding relpow_fun_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       f 0 = a \\<and>\n       f l = b \\<and>\n       (\\<forall>i<l.\n           (f i, f (Suc i))\n           \\<in> rel \\<inter>\n                 {(a, b). b \\<notin> new \\<and> b \\<notin> have})", "by (intro exI conjI, insert fa fb steps, auto)"], ["proof (state)\nthis:\n  (a, b)\n  \\<in> (rel \\<inter> {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^ l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<in> {b. \\<exists>a m.\n                            a \\<in> new \\<and>\n                            m \\<le> Suc n \\<and>\n                            (a, b)\n                            \\<in> (rel \\<inter>\n                                   {(a, b). b \\<notin> have}) ^^\n                                  m} \\<union>\n                     have;\n     b \\<notin> have\\<rbrakk>\n    \\<Longrightarrow> b \\<in> {uu.\n                               \\<exists>a.\n                                  (\\<exists>aa\\<in>new.\n(aa, a) \\<in> rel) \\<and>\n                                  a \\<notin> new \\<and>\n                                  a \\<notin> have \\<and>\n                                  (\\<exists>m\\<le>n.\n(a, uu)\n\\<in> (rel \\<inter> {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n      m)} \\<union>\n                              (new \\<union> have)", "have \"b \\<in> ?l1 \\<union> ?l2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> {uu.\n             \\<exists>a.\n                (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n                a \\<notin> new \\<and>\n                a \\<notin> have \\<and>\n                (\\<exists>m\\<le>n.\n                    (a, uu)\n                    \\<in> (rel \\<inter>\n                           {(a, b).\n                            b \\<notin> new \\<and> b \\<notin> have}) ^^\n                          m)} \\<union>\n            new", "proof (cases l)"], ["proof (state)\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    b \\<in> {uu.\n             \\<exists>a.\n                (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n                a \\<notin> new \\<and>\n                a \\<notin> have \\<and>\n                (\\<exists>m\\<le>n.\n                    (a, uu)\n                    \\<in> (rel \\<inter>\n                           {(a, b).\n                            b \\<notin> new \\<and> b \\<notin> have}) ^^\n                          m)} \\<union>\n            new\n 2. \\<And>nat.\n       l = Suc nat \\<Longrightarrow>\n       b \\<in> {uu.\n                \\<exists>a.\n                   (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n                   a \\<notin> new \\<and>\n                   a \\<notin> have \\<and>\n                   (\\<exists>m\\<le>n.\n                       (a, uu)\n                       \\<in> (rel \\<inter>\n                              {(a, b).\n                               b \\<notin> new \\<and> b \\<notin> have}) ^^\n                             m)} \\<union>\n               new", "case 0"], ["proof (state)\nthis:\n  l = 0\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    b \\<in> {uu.\n             \\<exists>a.\n                (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n                a \\<notin> new \\<and>\n                a \\<notin> have \\<and>\n                (\\<exists>m\\<le>n.\n                    (a, uu)\n                    \\<in> (rel \\<inter>\n                           {(a, b).\n                            b \\<notin> new \\<and> b \\<notin> have}) ^^\n                          m)} \\<union>\n            new\n 2. \\<And>nat.\n       l = Suc nat \\<Longrightarrow>\n       b \\<in> {uu.\n                \\<exists>a.\n                   (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n                   a \\<notin> new \\<and>\n                   a \\<notin> have \\<and>\n                   (\\<exists>m\\<le>n.\n                       (a, uu)\n                       \\<in> (rel \\<inter>\n                              {(a, b).\n                               b \\<notin> new \\<and> b \\<notin> have}) ^^\n                             m)} \\<union>\n               new", "with ab a"], ["proof (chain)\npicking this:\n  (a, b)\n  \\<in> (rel \\<inter> {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^ l\n  a \\<in> new\n  l = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  (a, b)\n  \\<in> (rel \\<inter> {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^ l\n  a \\<in> new\n  l = 0\n\ngoal (1 subgoal):\n 1. b \\<in> {uu.\n             \\<exists>a.\n                (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n                a \\<notin> new \\<and>\n                a \\<notin> have \\<and>\n                (\\<exists>m\\<le>n.\n                    (a, uu)\n                    \\<in> (rel \\<inter>\n                           {(a, b).\n                            b \\<notin> new \\<and> b \\<notin> have}) ^^\n                          m)} \\<union>\n            new", "by auto"], ["proof (state)\nthis:\n  b \\<in> {uu.\n           \\<exists>a.\n              (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n              a \\<notin> new \\<and>\n              a \\<notin> have \\<and>\n              (\\<exists>m\\<le>n.\n                  (a, uu)\n                  \\<in> (rel \\<inter>\n                         {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n                        m)} \\<union>\n          new\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       l = Suc nat \\<Longrightarrow>\n       b \\<in> {uu.\n                \\<exists>a.\n                   (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n                   a \\<notin> new \\<and>\n                   a \\<notin> have \\<and>\n                   (\\<exists>m\\<le>n.\n                       (a, uu)\n                       \\<in> (rel \\<inter>\n                              {(a, b).\n                               b \\<notin> new \\<and> b \\<notin> have}) ^^\n                             m)} \\<union>\n               new", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       l = Suc nat \\<Longrightarrow>\n       b \\<in> {uu.\n                \\<exists>a.\n                   (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n                   a \\<notin> new \\<and>\n                   a \\<notin> have \\<and>\n                   (\\<exists>m\\<le>n.\n                       (a, uu)\n                       \\<in> (rel \\<inter>\n                              {(a, b).\n                               b \\<notin> new \\<and> b \\<notin> have}) ^^\n                             m)} \\<union>\n               new", "case (Suc ll)"], ["proof (state)\nthis:\n  l = Suc ll\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       l = Suc nat \\<Longrightarrow>\n       b \\<in> {uu.\n                \\<exists>a.\n                   (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n                   a \\<notin> new \\<and>\n                   a \\<notin> have \\<and>\n                   (\\<exists>m\\<le>n.\n                       (a, uu)\n                       \\<in> (rel \\<inter>\n                              {(a, b).\n                               b \\<notin> new \\<and> b \\<notin> have}) ^^\n                             m)} \\<union>\n               new", "from relpow_Suc_D2 [OF ab [unfolded Suc]] a ln Suc"], ["proof (chain)\npicking this:\n  \\<exists>y.\n     (a, y)\n     \\<in> rel \\<inter>\n           {(a, b). b \\<notin> new \\<and> b \\<notin> have} \\<and>\n     (y, b)\n     \\<in> (rel \\<inter> {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n           ll\n  a \\<in> new\n  l \\<le> Suc n\n  l = Suc ll", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>y.\n     (a, y)\n     \\<in> rel \\<inter>\n           {(a, b). b \\<notin> new \\<and> b \\<notin> have} \\<and>\n     (y, b)\n     \\<in> (rel \\<inter> {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n           ll\n  a \\<in> new\n  l \\<le> Suc n\n  l = Suc ll\n\ngoal (1 subgoal):\n 1. b \\<in> {uu.\n             \\<exists>a.\n                (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n                a \\<notin> new \\<and>\n                a \\<notin> have \\<and>\n                (\\<exists>m\\<le>n.\n                    (a, uu)\n                    \\<in> (rel \\<inter>\n                           {(a, b).\n                            b \\<notin> new \\<and> b \\<notin> have}) ^^\n                          m)} \\<union>\n            new", "by auto"], ["proof (state)\nthis:\n  b \\<in> {uu.\n           \\<exists>a.\n              (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n              a \\<notin> new \\<and>\n              a \\<notin> have \\<and>\n              (\\<exists>m\\<le>n.\n                  (a, uu)\n                  \\<in> (rel \\<inter>\n                         {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n                        m)} \\<union>\n          new\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b \\<in> {uu.\n           \\<exists>a.\n              (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n              a \\<notin> new \\<and>\n              a \\<notin> have \\<and>\n              (\\<exists>m\\<le>n.\n                  (a, uu)\n                  \\<in> (rel \\<inter>\n                         {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n                        m)} \\<union>\n          new\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<in> {b. \\<exists>a m.\n                            a \\<in> new \\<and>\n                            m \\<le> Suc n \\<and>\n                            (a, b)\n                            \\<in> (rel \\<inter>\n                                   {(a, b). b \\<notin> have}) ^^\n                                  m} \\<union>\n                     have;\n     b \\<notin> have\\<rbrakk>\n    \\<Longrightarrow> b \\<in> {uu.\n                               \\<exists>a.\n                                  (\\<exists>aa\\<in>new.\n(aa, a) \\<in> rel) \\<and>\n                                  a \\<notin> new \\<and>\n                                  a \\<notin> have \\<and>\n                                  (\\<exists>m\\<le>n.\n(a, uu)\n\\<in> (rel \\<inter> {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n      m)} \\<union>\n                              (new \\<union> have)", "then"], ["proof (chain)\npicking this:\n  b \\<in> {uu.\n           \\<exists>a.\n              (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n              a \\<notin> new \\<and>\n              a \\<notin> have \\<and>\n              (\\<exists>m\\<le>n.\n                  (a, uu)\n                  \\<in> (rel \\<inter>\n                         {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n                        m)} \\<union>\n          new", "show ?thesis"], ["proof (prove)\nusing this:\n  b \\<in> {uu.\n           \\<exists>a.\n              (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n              a \\<notin> new \\<and>\n              a \\<notin> have \\<and>\n              (\\<exists>m\\<le>n.\n                  (a, uu)\n                  \\<in> (rel \\<inter>\n                         {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n                        m)} \\<union>\n          new\n\ngoal (1 subgoal):\n 1. b \\<in> {uu.\n             \\<exists>a.\n                (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n                a \\<notin> new \\<and>\n                a \\<notin> have \\<and>\n                (\\<exists>m\\<le>n.\n                    (a, uu)\n                    \\<in> (rel \\<inter>\n                           {(a, b).\n                            b \\<notin> new \\<and> b \\<notin> have}) ^^\n                          m)} \\<union>\n            (new \\<union> have)", "by auto"], ["proof (state)\nthis:\n  b \\<in> {uu.\n           \\<exists>a.\n              (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n              a \\<notin> new \\<and>\n              a \\<notin> have \\<and>\n              (\\<exists>m\\<le>n.\n                  (a, uu)\n                  \\<in> (rel \\<inter>\n                         {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n                        m)} \\<union>\n          (new \\<union> have)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b \\<in> {uu.\n           \\<exists>a.\n              (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n              a \\<notin> new \\<and>\n              a \\<notin> have \\<and>\n              (\\<exists>m\\<le>n.\n                  (a, uu)\n                  \\<in> (rel \\<inter>\n                         {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n                        m)} \\<union>\n          (new \\<union> have)\n\ngoal (1 subgoal):\n 1. nnew \\<noteq> [] \\<Longrightarrow>\n    set_of (relpow_i nnew hhave (Suc n)) =\n    {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> set nnew \\<and>\n        m \\<le> Suc n \\<and>\n        (a, b)\n        \\<in> (rel \\<inter>\n               {a. case a of\n                   (a, b) \\<Rightarrow> b \\<notin> set_of hhave}) ^^\n              m} \\<union>\n    set_of hhave", "}"], ["proof (state)\nthis:\n  ?b2\n  \\<in> {b. \\<exists>a m.\n               a \\<in> new \\<and>\n               m \\<le> Suc n \\<and>\n               (a, b)\n               \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ m} \\<union>\n        have \\<Longrightarrow>\n  ?b2\n  \\<in> {uu.\n         \\<exists>a.\n            (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n            a \\<notin> new \\<and>\n            a \\<notin> have \\<and>\n            (\\<exists>m\\<le>n.\n                (a, uu)\n                \\<in> (rel \\<inter>\n                       {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n                      m)} \\<union>\n        (new \\<union> have)\n\ngoal (1 subgoal):\n 1. nnew \\<noteq> [] \\<Longrightarrow>\n    set_of (relpow_i nnew hhave (Suc n)) =\n    {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> set nnew \\<and>\n        m \\<le> Suc n \\<and>\n        (a, b)\n        \\<in> (rel \\<inter>\n               {a. case a of\n                   (a, b) \\<Rightarrow> b \\<notin> set_of hhave}) ^^\n              m} \\<union>\n    set_of hhave", "ultimately"], ["proof (chain)\npicking this:\n  ?b2\n  \\<in> {uu.\n         \\<exists>a.\n            (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n            a \\<notin> new \\<and>\n            a \\<notin> have \\<and>\n            (\\<exists>m\\<le>n.\n                (a, uu)\n                \\<in> (rel \\<inter>\n                       {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n                      m)} \\<union>\n        (new \\<union> have) \\<Longrightarrow>\n  ?b2\n  \\<in> {b. \\<exists>a m.\n               a \\<in> new \\<and>\n               m \\<le> Suc n \\<and>\n               (a, b)\n               \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ m} \\<union>\n        have\n  ?b2\n  \\<in> {b. \\<exists>a m.\n               a \\<in> new \\<and>\n               m \\<le> Suc n \\<and>\n               (a, b)\n               \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ m} \\<union>\n        have \\<Longrightarrow>\n  ?b2\n  \\<in> {uu.\n         \\<exists>a.\n            (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n            a \\<notin> new \\<and>\n            a \\<notin> have \\<and>\n            (\\<exists>m\\<le>n.\n                (a, uu)\n                \\<in> (rel \\<inter>\n                       {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n                      m)} \\<union>\n        (new \\<union> have)", "show ?thesis"], ["proof (prove)\nusing this:\n  ?b2\n  \\<in> {uu.\n         \\<exists>a.\n            (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n            a \\<notin> new \\<and>\n            a \\<notin> have \\<and>\n            (\\<exists>m\\<le>n.\n                (a, uu)\n                \\<in> (rel \\<inter>\n                       {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n                      m)} \\<union>\n        (new \\<union> have) \\<Longrightarrow>\n  ?b2\n  \\<in> {b. \\<exists>a m.\n               a \\<in> new \\<and>\n               m \\<le> Suc n \\<and>\n               (a, b)\n               \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ m} \\<union>\n        have\n  ?b2\n  \\<in> {b. \\<exists>a m.\n               a \\<in> new \\<and>\n               m \\<le> Suc n \\<and>\n               (a, b)\n               \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ m} \\<union>\n        have \\<Longrightarrow>\n  ?b2\n  \\<in> {uu.\n         \\<exists>a.\n            (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n            a \\<notin> new \\<and>\n            a \\<notin> have \\<and>\n            (\\<exists>m\\<le>n.\n                (a, uu)\n                \\<in> (rel \\<inter>\n                       {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n                      m)} \\<union>\n        (new \\<union> have)\n\ngoal (1 subgoal):\n 1. set_of (relpow_i nnew hhave (Suc n)) =\n    {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> set nnew \\<and>\n        m \\<le> Suc n \\<and>\n        (a, b)\n        \\<in> (rel \\<inter>\n               {a. case a of\n                   (a, b) \\<Rightarrow> b \\<notin> set_of hhave}) ^^\n              m} \\<union>\n    set_of hhave", "unfolding idl idr"], ["proof (prove)\nusing this:\n  ?b2\n  \\<in> {uu.\n         \\<exists>a.\n            (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n            a \\<notin> new \\<and>\n            a \\<notin> have \\<and>\n            (\\<exists>m\\<le>n.\n                (a, uu)\n                \\<in> (rel \\<inter>\n                       {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n                      m)} \\<union>\n        (new \\<union> have) \\<Longrightarrow>\n  ?b2\n  \\<in> {b. \\<exists>a m.\n               a \\<in> new \\<and>\n               m \\<le> Suc n \\<and>\n               (a, b)\n               \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ m} \\<union>\n        have\n  ?b2\n  \\<in> {b. \\<exists>a m.\n               a \\<in> new \\<and>\n               m \\<le> Suc n \\<and>\n               (a, b)\n               \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ m} \\<union>\n        have \\<Longrightarrow>\n  ?b2\n  \\<in> {uu.\n         \\<exists>a.\n            (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n            a \\<notin> new \\<and>\n            a \\<notin> have \\<and>\n            (\\<exists>m\\<le>n.\n                (a, uu)\n                \\<in> (rel \\<inter>\n                       {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n                      m)} \\<union>\n        (new \\<union> have)\n\ngoal (1 subgoal):\n 1. {uu.\n     \\<exists>a.\n        (\\<exists>aa\\<in>new. (aa, a) \\<in> rel) \\<and>\n        a \\<notin> new \\<and>\n        a \\<notin> have \\<and>\n        (\\<exists>m\\<le>n.\n            (a, uu)\n            \\<in> (rel \\<inter>\n                   {(a, b). b \\<notin> new \\<and> b \\<notin> have}) ^^\n                  m)} \\<union>\n    (new \\<union> have) =\n    {b. \\<exists>a m.\n           a \\<in> new \\<and>\n           m \\<le> Suc n \\<and>\n           (a, b)\n           \\<in> (rel \\<inter> {(a, b). b \\<notin> have}) ^^ m} \\<union>\n    have", "by blast"], ["proof (state)\nthis:\n  set_of (relpow_i nnew hhave (Suc n)) =\n  {uu_.\n   \\<exists>a b m.\n      uu_ = b \\<and>\n      a \\<in> set nnew \\<and>\n      m \\<le> Suc n \\<and>\n      (a, b)\n      \\<in> (rel \\<inter>\n             {a. case a of (a, b) \\<Rightarrow> b \\<notin> set_of hhave}) ^^\n            m} \\<union>\n  set_of hhave\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set_of (relpow_i nnew hhave (Suc n)) =\n  {uu_.\n   \\<exists>a b m.\n      uu_ = b \\<and>\n      a \\<in> set nnew \\<and>\n      m \\<le> Suc n \\<and>\n      (a, b)\n      \\<in> (rel \\<inter>\n             {a. case a of (a, b) \\<Rightarrow> b \\<notin> set_of hhave}) ^^\n            m} \\<union>\n  set_of hhave\n\ngoal (1 subgoal):\n 1. \\<And>have new.\n       set_of (relpow_i new have 0) =\n       {uu_.\n        \\<exists>a b m.\n           uu_ = b \\<and>\n           a \\<in> set new \\<and>\n           m \\<le> 0 \\<and>\n           (a, b)\n           \\<in> (rel \\<inter> {(a, b). b \\<notin> set_of have}) ^^\n                 m} \\<union>\n       set_of have", "qed (simp add: un)"], ["", "text \\<open>\n  From the previous lemma we can directly derive that @{const relpow_impl} works correctly if @{term\n  have} is initially set to \\<open>empty\\<close>\n\\<close>"], ["", "lemma relpow_impl:\n  \"set_of (relpow_i new empty n) = {b | a b m. a \\<in> set new \\<and> m \\<le> n \\<and> (a, b) \\<in> rel ^^ m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_of (relpow_i new empty n) =\n    {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> set new \\<and> m \\<le> n \\<and> (a, b) \\<in> rel ^^ m}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_of (relpow_i new empty n) =\n    {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> set new \\<and> m \\<le> n \\<and> (a, b) \\<in> rel ^^ m}", "have id: \"rel \\<inter> {(a ,b). True} = rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel \\<inter> {(a, b). True} = rel", "by auto"], ["proof (state)\nthis:\n  rel \\<inter> {(a, b). True} = rel\n\ngoal (1 subgoal):\n 1. set_of (relpow_i new empty n) =\n    {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> set new \\<and> m \\<le> n \\<and> (a, b) \\<in> rel ^^ m}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_of (relpow_i new empty n) =\n    {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> set new \\<and> m \\<le> n \\<and> (a, b) \\<in> rel ^^ m}", "unfolding relpow_impl_main empty"], ["proof (prove)\ngoal (1 subgoal):\n 1. {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> set new \\<and>\n        m \\<le> n \\<and>\n        (a, b) \\<in> (rel \\<inter> {(a, b). b \\<notin> {}}) ^^ m} \\<union>\n    {} =\n    {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> set new \\<and> m \\<le> n \\<and> (a, b) \\<in> rel ^^ m}", "by (simp add: id)"], ["proof (state)\nthis:\n  set_of (relpow_i new empty n) =\n  {uu_.\n   \\<exists>a b m.\n      uu_ = b \\<and>\n      a \\<in> set new \\<and> m \\<le> n \\<and> (a, b) \\<in> rel ^^ m}\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Reflexive Transitive Closure and Transitive closure\\<close>"], ["", "text \\<open>\n  Using @{const relpow_impl} it is now easy to obtain algorithms for the reflexive transitive\n  closure and the transitive closure by restricting the number of steps to the size of the finite\n  relation. Note that @{const relpow_impl} will abort the computation as soon as no new states are\n  detected. Hence, there is no penalty in using this large bound.\n\\<close>"], ["", "definition\n  rtrancl_impl ::\n    \"(('a \\<times> 'a) list \\<Rightarrow> 'a list \\<Rightarrow> 'a list) \\<Rightarrow>\n      ('a list \\<Rightarrow> 'b \\<Rightarrow> 'b) \\<Rightarrow> ('a \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> 'b \\<Rightarrow> ('a \\<times> 'a) list \\<Rightarrow> 'a list \\<Rightarrow> 'b\"\nwhere\n  \"rtrancl_impl gen_succ un memb emp rel =\n    (let\n      succ = gen_succ rel;\n      n = length rel\n    in (\\<lambda> as. relpow_impl succ un memb as emp n))\""], ["", "definition\n  trancl_impl ::\n    \"(('a \\<times> 'a) list \\<Rightarrow> 'a list \\<Rightarrow> 'a list) \\<Rightarrow>\n      ('a list \\<Rightarrow> 'b \\<Rightarrow> 'b) \\<Rightarrow> ('a \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> 'b \\<Rightarrow> ('a \\<times> 'a) list \\<Rightarrow> 'a list \\<Rightarrow> 'b\"\nwhere\n  \"trancl_impl gen_succ un memb emp rel =\n    (let\n      succ = gen_succ rel;\n      n = length rel\n    in (\\<lambda> as. relpow_impl succ un memb (succ as) emp n))\""], ["", "text \\<open>\n  The soundness of both @{const rtrancl_impl} and @{const trancl_impl} follows from the soundness of\n  @{const relpow_impl} and the fact that for finite relations, we can limit the number of steps to\n  explore all elements in the reflexive transitive closure.\n\\<close>"], ["", "lemma rtrancl_finite_relpow:\n  \"(a, b) \\<in> (set rel)\\<^sup>* \\<longleftrightarrow> (\\<exists> n \\<le> length rel. (a, b) \\<in> set rel ^^ n)\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((a, b) \\<in> (set rel)\\<^sup>*) =\n    (\\<exists>n\\<le>length rel. (a, b) \\<in> set rel ^^ n)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (a, b) \\<in> (set rel)\\<^sup>* \\<Longrightarrow>\n    \\<exists>n\\<le>length rel. (a, b) \\<in> set rel ^^ n\n 2. \\<exists>n\\<le>length rel. (a, b) \\<in> set rel ^^ n \\<Longrightarrow>\n    (a, b) \\<in> (set rel)\\<^sup>*", "assume ?r"], ["proof (state)\nthis:\n  \\<exists>n\\<le>length rel. (a, b) \\<in> set rel ^^ n\n\ngoal (2 subgoals):\n 1. (a, b) \\<in> (set rel)\\<^sup>* \\<Longrightarrow>\n    \\<exists>n\\<le>length rel. (a, b) \\<in> set rel ^^ n\n 2. \\<exists>n\\<le>length rel. (a, b) \\<in> set rel ^^ n \\<Longrightarrow>\n    (a, b) \\<in> (set rel)\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  \\<exists>n\\<le>length rel. (a, b) \\<in> set rel ^^ n", "show ?l"], ["proof (prove)\nusing this:\n  \\<exists>n\\<le>length rel. (a, b) \\<in> set rel ^^ n\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> (set rel)\\<^sup>*", "unfolding rtrancl_power"], ["proof (prove)\nusing this:\n  \\<exists>n\\<le>length rel. (a, b) \\<in> set rel ^^ n\n\ngoal (1 subgoal):\n 1. \\<exists>n. (a, b) \\<in> set rel ^^ n", "by auto"], ["proof (state)\nthis:\n  (a, b) \\<in> (set rel)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> (set rel)\\<^sup>* \\<Longrightarrow>\n    \\<exists>n\\<le>length rel. (a, b) \\<in> set rel ^^ n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (a, b) \\<in> (set rel)\\<^sup>* \\<Longrightarrow>\n    \\<exists>n\\<le>length rel. (a, b) \\<in> set rel ^^ n", "assume ?l"], ["proof (state)\nthis:\n  (a, b) \\<in> (set rel)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> (set rel)\\<^sup>* \\<Longrightarrow>\n    \\<exists>n\\<le>length rel. (a, b) \\<in> set rel ^^ n", "from this [unfolded rtrancl_power]"], ["proof (chain)\npicking this:\n  \\<exists>n. (a, b) \\<in> set rel ^^ n", "obtain n where ab: \"(a,b) \\<in> set rel ^^ n\""], ["proof (prove)\nusing this:\n  \\<exists>n. (a, b) \\<in> set rel ^^ n\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        (a, b) \\<in> set rel ^^ n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  (a, b) \\<in> set rel ^^ n\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> (set rel)\\<^sup>* \\<Longrightarrow>\n    \\<exists>n\\<le>length rel. (a, b) \\<in> set rel ^^ n", "obtain l where l: \"l = (LEAST n. (a,b) \\<in> set rel ^^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l.\n        l = (LEAST n. (a, b) \\<in> set rel ^^ n) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  l = (LEAST n. (a, b) \\<in> set rel ^^ n)\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> (set rel)\\<^sup>* \\<Longrightarrow>\n    \\<exists>n\\<le>length rel. (a, b) \\<in> set rel ^^ n", "have ab: \"(a, b) \\<in> set rel ^^ l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> set rel ^^ l", "unfolding l"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> set rel ^^ (LEAST n. (a, b) \\<in> set rel ^^ n)", "by (intro LeastI, rule ab)"], ["proof (state)\nthis:\n  (a, b) \\<in> set rel ^^ l\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> (set rel)\\<^sup>* \\<Longrightarrow>\n    \\<exists>n\\<le>length rel. (a, b) \\<in> set rel ^^ n", "from this [unfolded relpow_fun_conv]"], ["proof (chain)\npicking this:\n  \\<exists>f.\n     f 0 = a \\<and>\n     f l = b \\<and> (\\<forall>i<l. (f i, f (Suc i)) \\<in> set rel)", "obtain f where a: \"f 0 = a\" and b: \"f l = b\"\n    and steps: \"\\<And> i. i < l \\<Longrightarrow> (f i, f (Suc i)) \\<in> set rel\""], ["proof (prove)\nusing this:\n  \\<exists>f.\n     f 0 = a \\<and>\n     f l = b \\<and> (\\<forall>i<l. (f i, f (Suc i)) \\<in> set rel)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f 0 = a; f l = b;\n         \\<And>i.\n            i < l \\<Longrightarrow> (f i, f (Suc i)) \\<in> set rel\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f 0 = a\n  f l = b\n  ?i < l \\<Longrightarrow> (f ?i, f (Suc ?i)) \\<in> set rel\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> (set rel)\\<^sup>* \\<Longrightarrow>\n    \\<exists>n\\<le>length rel. (a, b) \\<in> set rel ^^ n", "let ?hits = \"map (\\<lambda> i. f (Suc i)) [0 ..< l]\""], ["proof (state)\ngoal (1 subgoal):\n 1. (a, b) \\<in> (set rel)\\<^sup>* \\<Longrightarrow>\n    \\<exists>n\\<le>length rel. (a, b) \\<in> set rel ^^ n", "from steps"], ["proof (chain)\npicking this:\n  ?i < l \\<Longrightarrow> (f ?i, f (Suc ?i)) \\<in> set rel", "have subset: \"set ?hits \\<subseteq> snd ` set rel\""], ["proof (prove)\nusing this:\n  ?i < l \\<Longrightarrow> (f ?i, f (Suc ?i)) \\<in> set rel\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>i. f (Suc i)) [0..<l]) \\<subseteq> snd ` set rel", "by force"], ["proof (state)\nthis:\n  set (map (\\<lambda>i. f (Suc i)) [0..<l]) \\<subseteq> snd ` set rel\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> (set rel)\\<^sup>* \\<Longrightarrow>\n    \\<exists>n\\<le>length rel. (a, b) \\<in> set rel ^^ n", "have \"l \\<le> length rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<le> length rel", "proof (cases \"distinct ?hits\")"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct (map (\\<lambda>i. f (Suc i)) [0..<l]) \\<Longrightarrow>\n    l \\<le> length rel\n 2. \\<not> distinct (map (\\<lambda>i. f (Suc i)) [0..<l]) \\<Longrightarrow>\n    l \\<le> length rel", "case True"], ["proof (state)\nthis:\n  distinct (map (\\<lambda>i. f (Suc i)) [0..<l])\n\ngoal (2 subgoals):\n 1. distinct (map (\\<lambda>i. f (Suc i)) [0..<l]) \\<Longrightarrow>\n    l \\<le> length rel\n 2. \\<not> distinct (map (\\<lambda>i. f (Suc i)) [0..<l]) \\<Longrightarrow>\n    l \\<le> length rel", "have \"l = length ?hits\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l = length (map (\\<lambda>i. f (Suc i)) [0..<l])", "by simp"], ["proof (state)\nthis:\n  l = length (map (\\<lambda>i. f (Suc i)) [0..<l])\n\ngoal (2 subgoals):\n 1. distinct (map (\\<lambda>i. f (Suc i)) [0..<l]) \\<Longrightarrow>\n    l \\<le> length rel\n 2. \\<not> distinct (map (\\<lambda>i. f (Suc i)) [0..<l]) \\<Longrightarrow>\n    l \\<le> length rel", "also"], ["proof (state)\nthis:\n  l = length (map (\\<lambda>i. f (Suc i)) [0..<l])\n\ngoal (2 subgoals):\n 1. distinct (map (\\<lambda>i. f (Suc i)) [0..<l]) \\<Longrightarrow>\n    l \\<le> length rel\n 2. \\<not> distinct (map (\\<lambda>i. f (Suc i)) [0..<l]) \\<Longrightarrow>\n    l \\<le> length rel", "have \"... = card (set ?hits)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map (\\<lambda>i. f (Suc i)) [0..<l]) =\n    card (set (map (\\<lambda>i. f (Suc i)) [0..<l]))", "unfolding distinct_card [OF True]"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map (\\<lambda>i. f (Suc i)) [0..<l]) =\n    length (map (\\<lambda>i. f (Suc i)) [0..<l])", ".."], ["proof (state)\nthis:\n  length (map (\\<lambda>i. f (Suc i)) [0..<l]) =\n  card (set (map (\\<lambda>i. f (Suc i)) [0..<l]))\n\ngoal (2 subgoals):\n 1. distinct (map (\\<lambda>i. f (Suc i)) [0..<l]) \\<Longrightarrow>\n    l \\<le> length rel\n 2. \\<not> distinct (map (\\<lambda>i. f (Suc i)) [0..<l]) \\<Longrightarrow>\n    l \\<le> length rel", "also"], ["proof (state)\nthis:\n  length (map (\\<lambda>i. f (Suc i)) [0..<l]) =\n  card (set (map (\\<lambda>i. f (Suc i)) [0..<l]))\n\ngoal (2 subgoals):\n 1. distinct (map (\\<lambda>i. f (Suc i)) [0..<l]) \\<Longrightarrow>\n    l \\<le> length rel\n 2. \\<not> distinct (map (\\<lambda>i. f (Suc i)) [0..<l]) \\<Longrightarrow>\n    l \\<le> length rel", "have \"... \\<le> card (snd ` set rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (map (\\<lambda>i. f (Suc i)) [0..<l]))\n    \\<le> card (snd ` set rel)", "by (rule card_mono [OF _ subset], auto)"], ["proof (state)\nthis:\n  card (set (map (\\<lambda>i. f (Suc i)) [0..<l]))\n  \\<le> card (snd ` set rel)\n\ngoal (2 subgoals):\n 1. distinct (map (\\<lambda>i. f (Suc i)) [0..<l]) \\<Longrightarrow>\n    l \\<le> length rel\n 2. \\<not> distinct (map (\\<lambda>i. f (Suc i)) [0..<l]) \\<Longrightarrow>\n    l \\<le> length rel", "also"], ["proof (state)\nthis:\n  card (set (map (\\<lambda>i. f (Suc i)) [0..<l]))\n  \\<le> card (snd ` set rel)\n\ngoal (2 subgoals):\n 1. distinct (map (\\<lambda>i. f (Suc i)) [0..<l]) \\<Longrightarrow>\n    l \\<le> length rel\n 2. \\<not> distinct (map (\\<lambda>i. f (Suc i)) [0..<l]) \\<Longrightarrow>\n    l \\<le> length rel", "have \"... = card (set (map snd rel))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (snd ` set rel) = card (set (map snd rel))", "by auto"], ["proof (state)\nthis:\n  card (snd ` set rel) = card (set (map snd rel))\n\ngoal (2 subgoals):\n 1. distinct (map (\\<lambda>i. f (Suc i)) [0..<l]) \\<Longrightarrow>\n    l \\<le> length rel\n 2. \\<not> distinct (map (\\<lambda>i. f (Suc i)) [0..<l]) \\<Longrightarrow>\n    l \\<le> length rel", "also"], ["proof (state)\nthis:\n  card (snd ` set rel) = card (set (map snd rel))\n\ngoal (2 subgoals):\n 1. distinct (map (\\<lambda>i. f (Suc i)) [0..<l]) \\<Longrightarrow>\n    l \\<le> length rel\n 2. \\<not> distinct (map (\\<lambda>i. f (Suc i)) [0..<l]) \\<Longrightarrow>\n    l \\<le> length rel", "have \"... \\<le> length (map snd rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (map snd rel)) \\<le> length (map snd rel)", "by (rule card_length)"], ["proof (state)\nthis:\n  card (set (map snd rel)) \\<le> length (map snd rel)\n\ngoal (2 subgoals):\n 1. distinct (map (\\<lambda>i. f (Suc i)) [0..<l]) \\<Longrightarrow>\n    l \\<le> length rel\n 2. \\<not> distinct (map (\\<lambda>i. f (Suc i)) [0..<l]) \\<Longrightarrow>\n    l \\<le> length rel", "finally"], ["proof (chain)\npicking this:\n  l \\<le> length (map snd rel)", "show ?thesis"], ["proof (prove)\nusing this:\n  l \\<le> length (map snd rel)\n\ngoal (1 subgoal):\n 1. l \\<le> length rel", "by simp"], ["proof (state)\nthis:\n  l \\<le> length rel\n\ngoal (1 subgoal):\n 1. \\<not> distinct (map (\\<lambda>i. f (Suc i)) [0..<l]) \\<Longrightarrow>\n    l \\<le> length rel", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> distinct (map (\\<lambda>i. f (Suc i)) [0..<l]) \\<Longrightarrow>\n    l \\<le> length rel", "case False"], ["proof (state)\nthis:\n  \\<not> distinct (map (\\<lambda>i. f (Suc i)) [0..<l])\n\ngoal (1 subgoal):\n 1. \\<not> distinct (map (\\<lambda>i. f (Suc i)) [0..<l]) \\<Longrightarrow>\n    l \\<le> length rel", "from this [unfolded distinct_conv_nth]"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>i<length (map (\\<lambda>i. f (Suc i)) [0..<l]).\n             \\<forall>j<length (map (\\<lambda>i. f (Suc i)) [0..<l]).\n                i \\<noteq> j \\<longrightarrow>\n                map (\\<lambda>i. f (Suc i)) [0..<l] ! i \\<noteq>\n                map (\\<lambda>i. f (Suc i)) [0..<l] ! j)", "obtain i j where i: \"i < l\" and j: \"j < l\" and ij: \"i \\<noteq> j\" and fij: \"f (Suc i) = f (Suc j)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>i<length (map (\\<lambda>i. f (Suc i)) [0..<l]).\n             \\<forall>j<length (map (\\<lambda>i. f (Suc i)) [0..<l]).\n                i \\<noteq> j \\<longrightarrow>\n                map (\\<lambda>i. f (Suc i)) [0..<l] ! i \\<noteq>\n                map (\\<lambda>i. f (Suc i)) [0..<l] ! j)\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i < l; j < l; i \\<noteq> j; f (Suc i) = f (Suc j)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < l\n  j < l\n  i \\<noteq> j\n  f (Suc i) = f (Suc j)\n\ngoal (1 subgoal):\n 1. \\<not> distinct (map (\\<lambda>i. f (Suc i)) [0..<l]) \\<Longrightarrow>\n    l \\<le> length rel", "let ?i = \"min i j\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> distinct (map (\\<lambda>i. f (Suc i)) [0..<l]) \\<Longrightarrow>\n    l \\<le> length rel", "let ?j = \"max i j\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> distinct (map (\\<lambda>i. f (Suc i)) [0..<l]) \\<Longrightarrow>\n    l \\<le> length rel", "have i: \"?i < l\" and j: \"?j < l\" and fij: \"f (Suc ?i) = f (Suc ?j)\" \n      and ij: \"?i < ?j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (min i j < l &&& max i j < l) &&&\n    f (Suc (min i j)) = f (Suc (max i j)) &&& min i j < max i j", "using i j ij fij"], ["proof (prove)\nusing this:\n  i < l\n  j < l\n  i \\<noteq> j\n  f (Suc i) = f (Suc j)\n\ngoal (1 subgoal):\n 1. (min i j < l &&& max i j < l) &&&\n    f (Suc (min i j)) = f (Suc (max i j)) &&& min i j < max i j", "unfolding min_def max_def"], ["proof (prove)\nusing this:\n  i < l\n  j < l\n  i \\<noteq> j\n  f (Suc i) = f (Suc j)\n\ngoal (1 subgoal):\n 1. ((if i \\<le> j then i else j) < l &&&\n     (if i \\<le> j then j else i) < l) &&&\n    f (Suc (if i \\<le> j then i else j)) =\n    f (Suc (if i \\<le> j then j else i)) &&&\n    (if i \\<le> j then i else j) < (if i \\<le> j then j else i)", "by (cases \"i \\<le> j\", auto)"], ["proof (state)\nthis:\n  min i j < l\n  max i j < l\n  f (Suc (min i j)) = f (Suc (max i j))\n  min i j < max i j\n\ngoal (1 subgoal):\n 1. \\<not> distinct (map (\\<lambda>i. f (Suc i)) [0..<l]) \\<Longrightarrow>\n    l \\<le> length rel", "from i j fij ij"], ["proof (chain)\npicking this:\n  min i j < l\n  max i j < l\n  f (Suc (min i j)) = f (Suc (max i j))\n  min i j < max i j", "obtain i j where i: \"i < l\" and j: \"j < l\" and ij: \"i < j\" and fij: \"f (Suc i) = f (Suc j)\""], ["proof (prove)\nusing this:\n  min i j < l\n  max i j < l\n  f (Suc (min i j)) = f (Suc (max i j))\n  min i j < max i j\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i < l; j < l; i < j; f (Suc i) = f (Suc j)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  i < l\n  j < l\n  i < j\n  f (Suc i) = f (Suc j)\n\ngoal (1 subgoal):\n 1. \\<not> distinct (map (\\<lambda>i. f (Suc i)) [0..<l]) \\<Longrightarrow>\n    l \\<le> length rel", "let ?g = \"\\<lambda> n. if n \\<le> i then f n else f (n + (j - i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> distinct (map (\\<lambda>i. f (Suc i)) [0..<l]) \\<Longrightarrow>\n    l \\<le> length rel", "let ?l = \"l - (j - i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> distinct (map (\\<lambda>i. f (Suc i)) [0..<l]) \\<Longrightarrow>\n    l \\<le> length rel", "have abl: \"(a,b) \\<in> set rel ^^ ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> set rel ^^ (l - (j - i))", "unfolding relpow_fun_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       f 0 = a \\<and>\n       f (l - (j - i)) = b \\<and>\n       (\\<forall>i<l - (j - i). (f i, f (Suc i)) \\<in> set rel)", "proof (rule exI [of _ ?g], intro conjI impI allI)"], ["proof (state)\ngoal (3 subgoals):\n 1. (if 0 \\<le> i then f 0 else f (0 + (j - i))) = a\n 2. (if l - (j - i) \\<le> i then f (l - (j - i))\n     else f (l - (j - i) + (j - i))) =\n    b\n 3. \\<And>i.\n       i < l - (j - i) \\<Longrightarrow>\n       (if i \\<le> i then f i else f (i + (j - i)),\n        if Suc i \\<le> i then f (Suc i) else f (Suc i + (j - i)))\n       \\<in> set rel", "show \"?g ?l = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if l - (j - i) \\<le> i then f (l - (j - i))\n     else f (l - (j - i) + (j - i))) =\n    b", "unfolding b [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if l - (j - i) \\<le> i then f (l - (j - i))\n     else f (l - (j - i) + (j - i))) =\n    f l", "using j ij"], ["proof (prove)\nusing this:\n  j < l\n  i < j\n\ngoal (1 subgoal):\n 1. (if l - (j - i) \\<le> i then f (l - (j - i))\n     else f (l - (j - i) + (j - i))) =\n    f l", "by auto"], ["proof (state)\nthis:\n  (if l - (j - i) \\<le> i then f (l - (j - i))\n   else f (l - (j - i) + (j - i))) =\n  b\n\ngoal (2 subgoals):\n 1. (if 0 \\<le> i then f 0 else f (0 + (j - i))) = a\n 2. \\<And>i.\n       i < l - (j - i) \\<Longrightarrow>\n       (if i \\<le> i then f i else f (i + (j - i)),\n        if Suc i \\<le> i then f (Suc i) else f (Suc i + (j - i)))\n       \\<in> set rel", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (if 0 \\<le> i then f 0 else f (0 + (j - i))) = a\n 2. \\<And>i.\n       i < l - (j - i) \\<Longrightarrow>\n       (if i \\<le> i then f i else f (i + (j - i)),\n        if Suc i \\<le> i then f (Suc i) else f (Suc i + (j - i)))\n       \\<in> set rel", "fix k"], ["proof (state)\ngoal (2 subgoals):\n 1. (if 0 \\<le> i then f 0 else f (0 + (j - i))) = a\n 2. \\<And>i.\n       i < l - (j - i) \\<Longrightarrow>\n       (if i \\<le> i then f i else f (i + (j - i)),\n        if Suc i \\<le> i then f (Suc i) else f (Suc i + (j - i)))\n       \\<in> set rel", "assume k: \"k < ?l\""], ["proof (state)\nthis:\n  k < l - (j - i)\n\ngoal (2 subgoals):\n 1. (if 0 \\<le> i then f 0 else f (0 + (j - i))) = a\n 2. \\<And>i.\n       i < l - (j - i) \\<Longrightarrow>\n       (if i \\<le> i then f i else f (i + (j - i)),\n        if Suc i \\<le> i then f (Suc i) else f (Suc i + (j - i)))\n       \\<in> set rel", "show \"(?g k, ?g (Suc k)) \\<in> set rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if k \\<le> i then f k else f (k + (j - i)),\n     if Suc k \\<le> i then f (Suc k) else f (Suc k + (j - i)))\n    \\<in> set rel", "proof (cases \"k < i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k < i \\<Longrightarrow>\n    (if k \\<le> i then f k else f (k + (j - i)),\n     if Suc k \\<le> i then f (Suc k) else f (Suc k + (j - i)))\n    \\<in> set rel\n 2. \\<not> k < i \\<Longrightarrow>\n    (if k \\<le> i then f k else f (k + (j - i)),\n     if Suc k \\<le> i then f (Suc k) else f (Suc k + (j - i)))\n    \\<in> set rel", "case True"], ["proof (state)\nthis:\n  k < i\n\ngoal (2 subgoals):\n 1. k < i \\<Longrightarrow>\n    (if k \\<le> i then f k else f (k + (j - i)),\n     if Suc k \\<le> i then f (Suc k) else f (Suc k + (j - i)))\n    \\<in> set rel\n 2. \\<not> k < i \\<Longrightarrow>\n    (if k \\<le> i then f k else f (k + (j - i)),\n     if Suc k \\<le> i then f (Suc k) else f (Suc k + (j - i)))\n    \\<in> set rel", "with i"], ["proof (chain)\npicking this:\n  i < l\n  k < i", "have \"k < l\""], ["proof (prove)\nusing this:\n  i < l\n  k < i\n\ngoal (1 subgoal):\n 1. k < l", "by auto"], ["proof (state)\nthis:\n  k < l\n\ngoal (2 subgoals):\n 1. k < i \\<Longrightarrow>\n    (if k \\<le> i then f k else f (k + (j - i)),\n     if Suc k \\<le> i then f (Suc k) else f (Suc k + (j - i)))\n    \\<in> set rel\n 2. \\<not> k < i \\<Longrightarrow>\n    (if k \\<le> i then f k else f (k + (j - i)),\n     if Suc k \\<le> i then f (Suc k) else f (Suc k + (j - i)))\n    \\<in> set rel", "from steps [OF this]"], ["proof (chain)\npicking this:\n  (f k, f (Suc k)) \\<in> set rel", "show ?thesis"], ["proof (prove)\nusing this:\n  (f k, f (Suc k)) \\<in> set rel\n\ngoal (1 subgoal):\n 1. (if k \\<le> i then f k else f (k + (j - i)),\n     if Suc k \\<le> i then f (Suc k) else f (Suc k + (j - i)))\n    \\<in> set rel", "using True"], ["proof (prove)\nusing this:\n  (f k, f (Suc k)) \\<in> set rel\n  k < i\n\ngoal (1 subgoal):\n 1. (if k \\<le> i then f k else f (k + (j - i)),\n     if Suc k \\<le> i then f (Suc k) else f (Suc k + (j - i)))\n    \\<in> set rel", "by simp"], ["proof (state)\nthis:\n  (if k \\<le> i then f k else f (k + (j - i)),\n   if Suc k \\<le> i then f (Suc k) else f (Suc k + (j - i)))\n  \\<in> set rel\n\ngoal (1 subgoal):\n 1. \\<not> k < i \\<Longrightarrow>\n    (if k \\<le> i then f k else f (k + (j - i)),\n     if Suc k \\<le> i then f (Suc k) else f (Suc k + (j - i)))\n    \\<in> set rel", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> k < i \\<Longrightarrow>\n    (if k \\<le> i then f k else f (k + (j - i)),\n     if Suc k \\<le> i then f (Suc k) else f (Suc k + (j - i)))\n    \\<in> set rel", "case False"], ["proof (state)\nthis:\n  \\<not> k < i\n\ngoal (1 subgoal):\n 1. \\<not> k < i \\<Longrightarrow>\n    (if k \\<le> i then f k else f (k + (j - i)),\n     if Suc k \\<le> i then f (Suc k) else f (Suc k + (j - i)))\n    \\<in> set rel", "then"], ["proof (chain)\npicking this:\n  \\<not> k < i", "have ik: \"i \\<le> k\""], ["proof (prove)\nusing this:\n  \\<not> k < i\n\ngoal (1 subgoal):\n 1. i \\<le> k", "by auto"], ["proof (state)\nthis:\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. \\<not> k < i \\<Longrightarrow>\n    (if k \\<le> i then f k else f (k + (j - i)),\n     if Suc k \\<le> i then f (Suc k) else f (Suc k + (j - i)))\n    \\<in> set rel", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if k \\<le> i then f k else f (k + (j - i)),\n     if Suc k \\<le> i then f (Suc k) else f (Suc k + (j - i)))\n    \\<in> set rel", "proof (cases \"k = i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = i \\<Longrightarrow>\n    (if k \\<le> i then f k else f (k + (j - i)),\n     if Suc k \\<le> i then f (Suc k) else f (Suc k + (j - i)))\n    \\<in> set rel\n 2. k \\<noteq> i \\<Longrightarrow>\n    (if k \\<le> i then f k else f (k + (j - i)),\n     if Suc k \\<le> i then f (Suc k) else f (Suc k + (j - i)))\n    \\<in> set rel", "case True"], ["proof (state)\nthis:\n  k = i\n\ngoal (2 subgoals):\n 1. k = i \\<Longrightarrow>\n    (if k \\<le> i then f k else f (k + (j - i)),\n     if Suc k \\<le> i then f (Suc k) else f (Suc k + (j - i)))\n    \\<in> set rel\n 2. k \\<noteq> i \\<Longrightarrow>\n    (if k \\<le> i then f k else f (k + (j - i)),\n     if Suc k \\<le> i then f (Suc k) else f (Suc k + (j - i)))\n    \\<in> set rel", "then"], ["proof (chain)\npicking this:\n  k = i", "show ?thesis"], ["proof (prove)\nusing this:\n  k = i\n\ngoal (1 subgoal):\n 1. (if k \\<le> i then f k else f (k + (j - i)),\n     if Suc k \\<le> i then f (Suc k) else f (Suc k + (j - i)))\n    \\<in> set rel", "using ij fij steps [OF i]"], ["proof (prove)\nusing this:\n  k = i\n  i < j\n  f (Suc i) = f (Suc j)\n  (f i, f (Suc i)) \\<in> set rel\n\ngoal (1 subgoal):\n 1. (if k \\<le> i then f k else f (k + (j - i)),\n     if Suc k \\<le> i then f (Suc k) else f (Suc k + (j - i)))\n    \\<in> set rel", "by simp"], ["proof (state)\nthis:\n  (if k \\<le> i then f k else f (k + (j - i)),\n   if Suc k \\<le> i then f (Suc k) else f (Suc k + (j - i)))\n  \\<in> set rel\n\ngoal (1 subgoal):\n 1. k \\<noteq> i \\<Longrightarrow>\n    (if k \\<le> i then f k else f (k + (j - i)),\n     if Suc k \\<le> i then f (Suc k) else f (Suc k + (j - i)))\n    \\<in> set rel", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> i \\<Longrightarrow>\n    (if k \\<le> i then f k else f (k + (j - i)),\n     if Suc k \\<le> i then f (Suc k) else f (Suc k + (j - i)))\n    \\<in> set rel", "case False"], ["proof (state)\nthis:\n  k \\<noteq> i\n\ngoal (1 subgoal):\n 1. k \\<noteq> i \\<Longrightarrow>\n    (if k \\<le> i then f k else f (k + (j - i)),\n     if Suc k \\<le> i then f (Suc k) else f (Suc k + (j - i)))\n    \\<in> set rel", "with ik"], ["proof (chain)\npicking this:\n  i \\<le> k\n  k \\<noteq> i", "have ik: \"i < k\""], ["proof (prove)\nusing this:\n  i \\<le> k\n  k \\<noteq> i\n\ngoal (1 subgoal):\n 1. i < k", "by auto"], ["proof (state)\nthis:\n  i < k\n\ngoal (1 subgoal):\n 1. k \\<noteq> i \\<Longrightarrow>\n    (if k \\<le> i then f k else f (k + (j - i)),\n     if Suc k \\<le> i then f (Suc k) else f (Suc k + (j - i)))\n    \\<in> set rel", "then"], ["proof (chain)\npicking this:\n  i < k", "have small: \"k + (j - i) < l\""], ["proof (prove)\nusing this:\n  i < k\n\ngoal (1 subgoal):\n 1. k + (j - i) < l", "using k"], ["proof (prove)\nusing this:\n  i < k\n  k < l - (j - i)\n\ngoal (1 subgoal):\n 1. k + (j - i) < l", "by auto"], ["proof (state)\nthis:\n  k + (j - i) < l\n\ngoal (1 subgoal):\n 1. k \\<noteq> i \\<Longrightarrow>\n    (if k \\<le> i then f k else f (k + (j - i)),\n     if Suc k \\<le> i then f (Suc k) else f (Suc k + (j - i)))\n    \\<in> set rel", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if k \\<le> i then f k else f (k + (j - i)),\n     if Suc k \\<le> i then f (Suc k) else f (Suc k + (j - i)))\n    \\<in> set rel", "using steps[OF small] ik"], ["proof (prove)\nusing this:\n  (f (k + (j - i)), f (Suc (k + (j - i)))) \\<in> set rel\n  i < k\n\ngoal (1 subgoal):\n 1. (if k \\<le> i then f k else f (k + (j - i)),\n     if Suc k \\<le> i then f (Suc k) else f (Suc k + (j - i)))\n    \\<in> set rel", "by auto"], ["proof (state)\nthis:\n  (if k \\<le> i then f k else f (k + (j - i)),\n   if Suc k \\<le> i then f (Suc k) else f (Suc k + (j - i)))\n  \\<in> set rel\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if k \\<le> i then f k else f (k + (j - i)),\n   if Suc k \\<le> i then f (Suc k) else f (Suc k + (j - i)))\n  \\<in> set rel\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if k \\<le> i then f k else f (k + (j - i)),\n   if Suc k \\<le> i then f (Suc k) else f (Suc k + (j - i)))\n  \\<in> set rel\n\ngoal (1 subgoal):\n 1. (if 0 \\<le> i then f 0 else f (0 + (j - i))) = a", "qed (simp add: a)"], ["proof (state)\nthis:\n  (a, b) \\<in> set rel ^^ (l - (j - i))\n\ngoal (1 subgoal):\n 1. \\<not> distinct (map (\\<lambda>i. f (Suc i)) [0..<l]) \\<Longrightarrow>\n    l \\<le> length rel", "from ij i"], ["proof (chain)\npicking this:\n  i < j\n  i < l", "have ll: \"?l < l\""], ["proof (prove)\nusing this:\n  i < j\n  i < l\n\ngoal (1 subgoal):\n 1. l - (j - i) < l", "by auto"], ["proof (state)\nthis:\n  l - (j - i) < l\n\ngoal (1 subgoal):\n 1. \\<not> distinct (map (\\<lambda>i. f (Suc i)) [0..<l]) \\<Longrightarrow>\n    l \\<le> length rel", "have \"l \\<le> ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<le> l - (j - i)", "unfolding l"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. (a, b) \\<in> set rel ^^ n)\n    \\<le> (LEAST n. (a, b) \\<in> set rel ^^ n) - (j - i)", "by (rule Least_le, rule abl [unfolded l])"], ["proof (state)\nthis:\n  l \\<le> l - (j - i)\n\ngoal (1 subgoal):\n 1. \\<not> distinct (map (\\<lambda>i. f (Suc i)) [0..<l]) \\<Longrightarrow>\n    l \\<le> length rel", "with ll"], ["proof (chain)\npicking this:\n  l - (j - i) < l\n  l \\<le> l - (j - i)", "have False"], ["proof (prove)\nusing this:\n  l - (j - i) < l\n  l \\<le> l - (j - i)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> distinct (map (\\<lambda>i. f (Suc i)) [0..<l]) \\<Longrightarrow>\n    l \\<le> length rel", "then"], ["proof (chain)\npicking this:\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. l \\<le> length rel", "by simp"], ["proof (state)\nthis:\n  l \\<le> length rel\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l \\<le> length rel\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> (set rel)\\<^sup>* \\<Longrightarrow>\n    \\<exists>n\\<le>length rel. (a, b) \\<in> set rel ^^ n", "with ab"], ["proof (chain)\npicking this:\n  (a, b) \\<in> set rel ^^ l\n  l \\<le> length rel", "show ?r"], ["proof (prove)\nusing this:\n  (a, b) \\<in> set rel ^^ l\n  l \\<le> length rel\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<le>length rel. (a, b) \\<in> set rel ^^ n", "by auto"], ["proof (state)\nthis:\n  \\<exists>n\\<le>length rel. (a, b) \\<in> set rel ^^ n\n\ngoal:\nNo subgoals!", "qed"], ["", "locale set_access_gen = set_access un\n  for un :: \"'a list \\<Rightarrow> 'b \\<Rightarrow> 'b\" +\n  fixes gen_succ :: \"('a \\<times> 'a) list \\<Rightarrow> 'a list \\<Rightarrow> 'a list\"\n  assumes gen_succ: \"set (gen_succ rel as) = {b. \\<exists> a \\<in> set as. (a, b) \\<in> set rel}\"\nbegin"], ["", "abbreviation \"rtrancl_i \\<equiv> rtrancl_impl gen_succ un memb empty\""], ["", "abbreviation \"trancl_i \\<equiv> trancl_impl gen_succ un memb empty\""], ["", "lemma rtrancl_impl:\n  \"set_of (rtrancl_i rel as) = {b. (\\<exists> a \\<in> set as. (a, b) \\<in> (set rel)\\<^sup>*)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_of (rtrancl_i rel as) =\n    {b. \\<exists>a\\<in>set as. (a, b) \\<in> (set rel)\\<^sup>*}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_of (rtrancl_i rel as) =\n    {b. \\<exists>a\\<in>set as. (a, b) \\<in> (set rel)\\<^sup>*}", "interpret set_access_succ set_of memb empty un \"gen_succ rel\" \"set rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_access_succ set_of memb empty un (gen_succ rel) (set rel)", "by (unfold_locales, insert gen_succ, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. set_of (rtrancl_i rel as) =\n    {b. \\<exists>a\\<in>set as. (a, b) \\<in> (set rel)\\<^sup>*}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_of (rtrancl_i rel as) =\n    {b. \\<exists>a\\<in>set as. (a, b) \\<in> (set rel)\\<^sup>*}", "unfolding rtrancl_impl_def Let_def relpow_impl"], ["proof (prove)\ngoal (1 subgoal):\n 1. {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> set as \\<and>\n        m \\<le> length rel \\<and> (a, b) \\<in> set rel ^^ m} =\n    {b. \\<exists>a\\<in>set as. (a, b) \\<in> (set rel)\\<^sup>*}", "by (auto simp: rtrancl_finite_relpow)"], ["proof (state)\nthis:\n  set_of (rtrancl_i rel as) =\n  {b. \\<exists>a\\<in>set as. (a, b) \\<in> (set rel)\\<^sup>*}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trancl_impl:\n  \"set_of (trancl_i rel as) = {b. (\\<exists> a \\<in> set as. (a, b) \\<in> (set rel)\\<^sup>+)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_of (trancl_i rel as) =\n    {b. \\<exists>a\\<in>set as. (a, b) \\<in> (set rel)\\<^sup>+}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_of (trancl_i rel as) =\n    {b. \\<exists>a\\<in>set as. (a, b) \\<in> (set rel)\\<^sup>+}", "interpret set_access_succ set_of memb empty un \"gen_succ rel\" \"set rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_access_succ set_of memb empty un (gen_succ rel) (set rel)", "by (unfold_locales, insert gen_succ, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. set_of (trancl_i rel as) =\n    {b. \\<exists>a\\<in>set as. (a, b) \\<in> (set rel)\\<^sup>+}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_of (trancl_i rel as) =\n    {b. \\<exists>a\\<in>set as. (a, b) \\<in> (set rel)\\<^sup>+}", "unfolding trancl_impl_def Let_def relpow_impl trancl_unfold_left relcomp_unfold rtrancl_finite_relpow succ"], ["proof (prove)\ngoal (1 subgoal):\n 1. {uu_.\n     \\<exists>a b m.\n        uu_ = b \\<and>\n        a \\<in> {b. \\<exists>a\\<in>set as. (a, b) \\<in> set rel} \\<and>\n        m \\<le> length rel \\<and> (a, b) \\<in> set rel ^^ m} =\n    {b. \\<exists>a\\<in>set as.\n           (a, b)\n           \\<in> {(x, z).\n                  \\<exists>y.\n                     (x, y) \\<in> set rel \\<and>\n                     (\\<exists>n\\<le>length rel.\n                         (y, z) \\<in> set rel ^^ n)}}", "by auto"], ["proof (state)\nthis:\n  set_of (trancl_i rel as) =\n  {b. \\<exists>a\\<in>set as. (a, b) \\<in> (set rel)\\<^sup>+}\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}