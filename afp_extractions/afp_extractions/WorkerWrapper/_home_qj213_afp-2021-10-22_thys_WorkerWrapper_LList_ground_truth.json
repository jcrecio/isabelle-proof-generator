{"file_name": "/home/qj213/afp-2021-10-22/thys/WorkerWrapper/LList.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/WorkerWrapper", "problem_names": ["lemma llist_map_eval_simps[simp]:\n  \"llist_map\\<cdot>f\\<cdot>\\<bottom> = \\<bottom>\"\n  \"llist_map\\<cdot>f\\<cdot>lnil = lnil\"\n  \"llist_map\\<cdot>f\\<cdot>(x :@ xs) = f\\<cdot>x :@ llist_map\\<cdot>f\\<cdot>xs\"", "lemma llist_case_distr_strict:\n  \"f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow> f\\<cdot>(llist_case\\<cdot>g\\<cdot>h\\<cdot>xxs) = llist_case\\<cdot>(f\\<cdot>g)\\<cdot>(\\<Lambda> x xs. f\\<cdot>(h\\<cdot>x\\<cdot>xs))\\<cdot>xxs\"", "lemma lappend_strict': \"lappend\\<cdot>\\<bottom> = (\\<Lambda> a. \\<bottom>)\"", "lemma lappend_strict[simp]: \"lappend\\<cdot>\\<bottom> = \\<bottom>\"", "lemma lappend_assoc: \"(xs :++ ys) :++ zs = xs :++ (ys :++ zs)\"", "lemma lappend_lnil_id_left[simp]: \"lappend\\<cdot>lnil = ID\"", "lemma lappend_lnil_id_right[simp]: \"xs :++ lnil = xs\"", "lemma lconcat_strict[simp]: \"lconcat\\<cdot>\\<bottom> = \\<bottom>\"", "lemma lall_strict[simp]: \"lall\\<cdot>p\\<cdot>\\<bottom> = \\<bottom>\"", "lemma lfilter_strict[simp]: \"lfilter\\<cdot>p\\<cdot>\\<bottom> = \\<bottom>\"", "lemma lfilter_const_true: \"lfilter\\<cdot>(\\<Lambda> x. TT)\\<cdot>xs = xs\"", "lemma lfilter_lnil: \"(lfilter\\<cdot>p\\<cdot>xs = lnil) = (lall\\<cdot>(neg oo p)\\<cdot>xs = TT)\"", "lemma filter_filter: \"lfilter\\<cdot>p\\<cdot>(lfilter\\<cdot>q\\<cdot>xs) = lfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>xs\"", "lemma ldropWhile_strict[simp]: \"ldropWhile\\<cdot>p\\<cdot>\\<bottom> = \\<bottom>\"", "lemma ldropWhile_lnil: \"(ldropWhile\\<cdot>p\\<cdot>xs = lnil) = (lall\\<cdot>p\\<cdot>xs = TT)\"", "lemma lmember_strict[simp]: \"lmember\\<cdot>eq\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\"", "lemma llength_strict[simp]: \"llength\\<cdot>\\<bottom> = \\<bottom>\"", "lemma lmap_strict[simp]: \"lmap\\<cdot>f\\<cdot>\\<bottom> = \\<bottom>\"", "lemma lmap_lmap:\n  \"lmap\\<cdot>f\\<cdot>(lmap\\<cdot>g\\<cdot>xs) = lmap\\<cdot>(f oo g)\\<cdot>xs\"", "lemma lconcatMap_comp_simps[simp]:\n  \"lconcatMap\\<cdot>f\\<cdot>\\<bottom> = \\<bottom>\"\n  \"lconcatMap\\<cdot>f\\<cdot>lnil = lnil\"\n  \"lconcatMap\\<cdot>f\\<cdot>(x :@ xs) = f\\<cdot>x :++ lconcatMap\\<cdot>f\\<cdot>xs\"", "lemma lconcatMap_lsingleton[simp]:\n  \"lconcatMap\\<cdot>lsingleton\\<cdot>x = x\"", "lemma lzipWith0_stricts [simp]:\n  \"lzipWith0\\<cdot>f\\<cdot>\\<bottom>\\<cdot>ys = \\<bottom>\"\n  \"lzipWith0\\<cdot>f\\<cdot>lnil\\<cdot>\\<bottom> = \\<bottom>\"\n  \"lzipWith0\\<cdot>f\\<cdot>(x :@ xs)\\<cdot>\\<bottom> = \\<bottom>\"", "lemma lzipWith0_undefs [simp]:\n  \"lzipWith0\\<cdot>f\\<cdot>lnil\\<cdot>(y :@ ys) = \\<bottom>\"\n  \"lzipWith0\\<cdot>f\\<cdot>(x :@ xs)\\<cdot>lnil = \\<bottom>\"", "lemma lzipWith_simps [simp]:\n  \"lzipWith\\<cdot>f\\<cdot>(x :@ xs)\\<cdot>(y :@ ys) = f\\<cdot>x\\<cdot>y :@ lzipWith\\<cdot>f\\<cdot>xs\\<cdot>ys\"\n  \"lzipWith\\<cdot>f\\<cdot>(x :@ xs)\\<cdot>lnil = lnil\"\n  \"lzipWith\\<cdot>f\\<cdot>lnil\\<cdot>(y :@ ys) = lnil\"\n  \"lzipWith\\<cdot>f\\<cdot>lnil\\<cdot>lnil = lnil\"", "lemma lzipWith_stricts [simp]:\n  \"lzipWith\\<cdot>f\\<cdot>\\<bottom>\\<cdot>ys = \\<bottom>\"\n  \"lzipWith\\<cdot>f\\<cdot>(x :@ xs)\\<cdot>\\<bottom> = \\<bottom>\"", "lemma lmap_lappend_dist:\n  \"lmap\\<cdot>f\\<cdot>(xs :++ ys) = lmap\\<cdot>f\\<cdot>xs :++ lmap\\<cdot>f\\<cdot>ys\"", "lemma lconcat_lappend_dist:\n  \"lconcat\\<cdot>(xs :++ ys) = lconcat\\<cdot>xs :++ lconcat\\<cdot>ys\"", "lemma lconcatMap_assoc:\n  \"lconcatMap\\<cdot>h\\<cdot>(lconcatMap\\<cdot>g\\<cdot>f) = lconcatMap\\<cdot>(\\<Lambda> v. lconcatMap\\<cdot>h\\<cdot>(g\\<cdot>v))\\<cdot>f\"", "lemma lconcatMap_lappend_dist:\n  \"lconcatMap\\<cdot>f\\<cdot>(xs :++ ys) = lconcatMap\\<cdot>f\\<cdot>xs :++ lconcatMap\\<cdot>f\\<cdot>ys\"", "lemma lmap_not_bottoms[simp]:\n  \"x \\<noteq> \\<bottom> \\<Longrightarrow> lmap\\<cdot>f\\<cdot>x \\<noteq> \\<bottom>\"", "lemma lsingleton_not_bottom[simp]:\n  \"lsingleton\\<cdot>x \\<noteq> \\<bottom>\"", "lemma lappend_not_bottom[simp]:\n  \"\\<lbrakk> xs \\<noteq> \\<bottom>; xs = lnil \\<Longrightarrow> ys \\<noteq> \\<bottom> \\<rbrakk> \\<Longrightarrow> xs :++ ys \\<noteq> \\<bottom>\""], "translations": [["", "lemma llist_map_eval_simps[simp]:\n  \"llist_map\\<cdot>f\\<cdot>\\<bottom> = \\<bottom>\"\n  \"llist_map\\<cdot>f\\<cdot>lnil = lnil\"\n  \"llist_map\\<cdot>f\\<cdot>(x :@ xs) = f\\<cdot>x :@ llist_map\\<cdot>f\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_map\\<cdot>f\\<cdot>\\<bottom> = \\<bottom> &&&\n    llist_map\\<cdot>f\\<cdot>lnil = lnil &&&\n    llist_map\\<cdot>f\\<cdot>(x :@ xs) =\n    f\\<cdot>x :@ llist_map\\<cdot>f\\<cdot>xs", "apply (subst llist_map_unfold)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (llist_abs oo\n     ssum_map\\<cdot>ID\\<cdot>\n     (sprod_map\\<cdot>(u_map\\<cdot>f)\\<cdot>\n      (u_map\\<cdot>(llist_map\\<cdot>f))) oo\n     llist_rep)\\<cdot>\n    \\<bottom> =\n    \\<bottom>\n 2. llist_map\\<cdot>f\\<cdot>lnil = lnil\n 3. llist_map\\<cdot>f\\<cdot>(x :@ xs) =\n    f\\<cdot>x :@ llist_map\\<cdot>f\\<cdot>xs", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. llist_map\\<cdot>f\\<cdot>lnil = lnil\n 2. llist_map\\<cdot>f\\<cdot>(x :@ xs) =\n    f\\<cdot>x :@ llist_map\\<cdot>f\\<cdot>xs", "apply (subst llist_map_unfold)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (llist_abs oo\n     ssum_map\\<cdot>ID\\<cdot>\n     (sprod_map\\<cdot>(u_map\\<cdot>f)\\<cdot>\n      (u_map\\<cdot>(llist_map\\<cdot>f))) oo\n     llist_rep)\\<cdot>\n    lnil =\n    lnil\n 2. llist_map\\<cdot>f\\<cdot>(x :@ xs) =\n    f\\<cdot>x :@ llist_map\\<cdot>f\\<cdot>xs", "apply (simp add: lnil_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_map\\<cdot>f\\<cdot>(x :@ xs) =\n    f\\<cdot>x :@ llist_map\\<cdot>f\\<cdot>xs", "apply (subst llist_map_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (llist_abs oo\n     ssum_map\\<cdot>ID\\<cdot>\n     (sprod_map\\<cdot>(u_map\\<cdot>f)\\<cdot>\n      (u_map\\<cdot>(llist_map\\<cdot>f))) oo\n     llist_rep)\\<cdot>\n    (x :@ xs) =\n    f\\<cdot>x :@ llist_map\\<cdot>f\\<cdot>xs", "apply (simp add: lcons_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma llist_case_distr_strict:\n  \"f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow> f\\<cdot>(llist_case\\<cdot>g\\<cdot>h\\<cdot>xxs) = llist_case\\<cdot>(f\\<cdot>g)\\<cdot>(\\<Lambda> x xs. f\\<cdot>(h\\<cdot>x\\<cdot>xs))\\<cdot>xxs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n    f\\<cdot>(llist_case\\<cdot>g\\<cdot>h\\<cdot>xxs) =\n    (case xxs of lnil \\<Rightarrow> f\\<cdot>g\n     | x :@ xs \\<Rightarrow> f\\<cdot>(h\\<cdot>x\\<cdot>xs))", "by (cases xxs) simp_all"], ["", "fixrec lsingleton :: \"('a::predomain) \\<rightarrow> 'a llist\"\nwhere\n  \"lsingleton\\<cdot>x = x :@ lnil\""], ["", "fixrec lappend :: \"'a llist \\<rightarrow> 'a llist \\<rightarrow> 'a llist\"\nwhere\n  \"lappend\\<cdot>lnil\\<cdot>ys = ys\"\n| \"lappend\\<cdot>(x :@ xs)\\<cdot>ys = x :@ (lappend\\<cdot>xs\\<cdot>ys)\""], ["", "abbreviation\n  lappend_syn :: \"'a llist \\<Rightarrow> 'a llist \\<Rightarrow> 'a llist\" (infixr \":++\" 65) where\n  \"xs :++ ys \\<equiv> lappend\\<cdot>xs\\<cdot>ys\""], ["", "lemma lappend_strict': \"lappend\\<cdot>\\<bottom> = (\\<Lambda> a. \\<bottom>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lappend\\<cdot>\\<bottom> = (\\<Lambda> a. \\<bottom>)", "by fixrec_simp"], ["", "text\\<open>This gives us that @{thm lappend_strict'}.\\<close>"], ["", "text \\<open>This is where we use @{thm inst_cfun_pcpo}\\<close>"], ["", "lemma lappend_strict[simp]: \"lappend\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lappend\\<cdot>\\<bottom> = \\<bottom>", "by (rule cfun_eqI) (simp add: lappend_strict')"], ["", "lemma lappend_assoc: \"(xs :++ ys) :++ zs = xs :++ (ys :++ zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs :++ ys) :++ zs = xs :++ ys :++ zs", "by (induct xs, simp_all)"], ["", "lemma lappend_lnil_id_left[simp]: \"lappend\\<cdot>lnil = ID\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lappend\\<cdot>lnil = ID", "by (rule cfun_eqI) simp"], ["", "lemma lappend_lnil_id_right[simp]: \"xs :++ lnil = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs :++ lnil = xs", "by (induct xs) simp_all"], ["", "fixrec lconcat :: \"'a llist llist \\<rightarrow> 'a llist\"\nwhere\n  \"lconcat\\<cdot>lnil = lnil\"\n| \"lconcat\\<cdot>(x :@ xs) = x :++ lconcat\\<cdot>xs\""], ["", "lemma lconcat_strict[simp]: \"lconcat\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lconcat\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "fixrec lall :: \"('a \\<rightarrow> tr) \\<rightarrow> 'a llist \\<rightarrow> tr\"\nwhere\n  \"lall\\<cdot>p\\<cdot>lnil = TT\"\n| \"lall\\<cdot>p\\<cdot>(x :@ xs) = (p\\<cdot>x andalso lall\\<cdot>p\\<cdot>xs)\""], ["", "lemma lall_strict[simp]: \"lall\\<cdot>p\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lall\\<cdot>p\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "fixrec lfilter :: \"('a \\<rightarrow> tr) \\<rightarrow> 'a llist \\<rightarrow> 'a llist\"\nwhere\n  \"lfilter\\<cdot>p\\<cdot>lnil = lnil\"\n| \"lfilter\\<cdot>p\\<cdot>(x :@ xs) = If p\\<cdot>x then x :@ lfilter\\<cdot>p\\<cdot>xs else lfilter\\<cdot>p\\<cdot>xs\""], ["", "lemma lfilter_strict[simp]: \"lfilter\\<cdot>p\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfilter\\<cdot>p\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "lemma lfilter_const_true: \"lfilter\\<cdot>(\\<Lambda> x. TT)\\<cdot>xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfilter\\<cdot>(\\<Lambda> x. TT)\\<cdot>xs = xs", "by (induct xs, simp_all)"], ["", "lemma lfilter_lnil: \"(lfilter\\<cdot>p\\<cdot>xs = lnil) = (lall\\<cdot>(neg oo p)\\<cdot>xs = TT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lfilter\\<cdot>p\\<cdot>xs = lnil) =\n    (lall\\<cdot>(neg oo p)\\<cdot>xs = TT)", "proof(induct xs)"], ["proof (state)\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            (lfilter\\<cdot>p\\<cdot>a = lnil) =\n            (lall\\<cdot>(neg oo p)\\<cdot>a = TT))\n 2. (lfilter\\<cdot>p\\<cdot>\\<bottom> = lnil) =\n    (lall\\<cdot>(neg oo p)\\<cdot>\\<bottom> = TT)\n 3. (lfilter\\<cdot>p\\<cdot>lnil = lnil) =\n    (lall\\<cdot>(neg oo p)\\<cdot>lnil = TT)\n 4. \\<And>a xs.\n       (lfilter\\<cdot>p\\<cdot>xs = lnil) =\n       (lall\\<cdot>(neg oo p)\\<cdot>xs = TT) \\<Longrightarrow>\n       (lfilter\\<cdot>p\\<cdot>(a :@ xs) = lnil) =\n       (lall\\<cdot>(neg oo p)\\<cdot>(a :@ xs) = TT)", "fix a l"], ["proof (state)\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            (lfilter\\<cdot>p\\<cdot>a = lnil) =\n            (lall\\<cdot>(neg oo p)\\<cdot>a = TT))\n 2. (lfilter\\<cdot>p\\<cdot>\\<bottom> = lnil) =\n    (lall\\<cdot>(neg oo p)\\<cdot>\\<bottom> = TT)\n 3. (lfilter\\<cdot>p\\<cdot>lnil = lnil) =\n    (lall\\<cdot>(neg oo p)\\<cdot>lnil = TT)\n 4. \\<And>a xs.\n       (lfilter\\<cdot>p\\<cdot>xs = lnil) =\n       (lall\\<cdot>(neg oo p)\\<cdot>xs = TT) \\<Longrightarrow>\n       (lfilter\\<cdot>p\\<cdot>(a :@ xs) = lnil) =\n       (lall\\<cdot>(neg oo p)\\<cdot>(a :@ xs) = TT)", "assume indhyp: \"(lfilter\\<cdot>p\\<cdot>l = lnil) = (lall\\<cdot>(Tr.neg oo p)\\<cdot>l = TT)\""], ["proof (state)\nthis:\n  (lfilter\\<cdot>p\\<cdot>l = lnil) = (lall\\<cdot>(neg oo p)\\<cdot>l = TT)\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            (lfilter\\<cdot>p\\<cdot>a = lnil) =\n            (lall\\<cdot>(neg oo p)\\<cdot>a = TT))\n 2. (lfilter\\<cdot>p\\<cdot>\\<bottom> = lnil) =\n    (lall\\<cdot>(neg oo p)\\<cdot>\\<bottom> = TT)\n 3. (lfilter\\<cdot>p\\<cdot>lnil = lnil) =\n    (lall\\<cdot>(neg oo p)\\<cdot>lnil = TT)\n 4. \\<And>a xs.\n       (lfilter\\<cdot>p\\<cdot>xs = lnil) =\n       (lall\\<cdot>(neg oo p)\\<cdot>xs = TT) \\<Longrightarrow>\n       (lfilter\\<cdot>p\\<cdot>(a :@ xs) = lnil) =\n       (lall\\<cdot>(neg oo p)\\<cdot>(a :@ xs) = TT)", "thus \"(lfilter\\<cdot>p\\<cdot>(a :@ l) = lnil) = (lall\\<cdot>(Tr.neg oo p)\\<cdot>(a :@ l) = TT)\""], ["proof (prove)\nusing this:\n  (lfilter\\<cdot>p\\<cdot>l = lnil) = (lall\\<cdot>(neg oo p)\\<cdot>l = TT)\n\ngoal (1 subgoal):\n 1. (lfilter\\<cdot>p\\<cdot>(a :@ l) = lnil) =\n    (lall\\<cdot>(neg oo p)\\<cdot>(a :@ l) = TT)", "by (cases \"p\\<cdot>a\" rule: trE, simp_all)"], ["proof (state)\nthis:\n  (lfilter\\<cdot>p\\<cdot>(a :@ l) = lnil) =\n  (lall\\<cdot>(neg oo p)\\<cdot>(a :@ l) = TT)\n\ngoal (3 subgoals):\n 1. adm (\\<lambda>a.\n            (lfilter\\<cdot>p\\<cdot>a = lnil) =\n            (lall\\<cdot>(neg oo p)\\<cdot>a = TT))\n 2. (lfilter\\<cdot>p\\<cdot>\\<bottom> = lnil) =\n    (lall\\<cdot>(neg oo p)\\<cdot>\\<bottom> = TT)\n 3. (lfilter\\<cdot>p\\<cdot>lnil = lnil) =\n    (lall\\<cdot>(neg oo p)\\<cdot>lnil = TT)", "qed simp_all"], ["", "lemma filter_filter: \"lfilter\\<cdot>p\\<cdot>(lfilter\\<cdot>q\\<cdot>xs) = lfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfilter\\<cdot>p\\<cdot>(lfilter\\<cdot>q\\<cdot>xs) =\n    lfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>xs", "proof(induct xs)"], ["proof (state)\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            lfilter\\<cdot>p\\<cdot>(lfilter\\<cdot>q\\<cdot>a) =\n            lfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>\n            a)\n 2. lfilter\\<cdot>p\\<cdot>(lfilter\\<cdot>q\\<cdot>\\<bottom>) =\n    lfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>\\<bottom>\n 3. lfilter\\<cdot>p\\<cdot>(lfilter\\<cdot>q\\<cdot>lnil) =\n    lfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>lnil\n 4. \\<And>a xs.\n       lfilter\\<cdot>p\\<cdot>(lfilter\\<cdot>q\\<cdot>xs) =\n       lfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>\n       xs \\<Longrightarrow>\n       lfilter\\<cdot>p\\<cdot>(lfilter\\<cdot>q\\<cdot>(a :@ xs)) =\n       lfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>\n       (a :@ xs)", "fix a l"], ["proof (state)\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            lfilter\\<cdot>p\\<cdot>(lfilter\\<cdot>q\\<cdot>a) =\n            lfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>\n            a)\n 2. lfilter\\<cdot>p\\<cdot>(lfilter\\<cdot>q\\<cdot>\\<bottom>) =\n    lfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>\\<bottom>\n 3. lfilter\\<cdot>p\\<cdot>(lfilter\\<cdot>q\\<cdot>lnil) =\n    lfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>lnil\n 4. \\<And>a xs.\n       lfilter\\<cdot>p\\<cdot>(lfilter\\<cdot>q\\<cdot>xs) =\n       lfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>\n       xs \\<Longrightarrow>\n       lfilter\\<cdot>p\\<cdot>(lfilter\\<cdot>q\\<cdot>(a :@ xs)) =\n       lfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>\n       (a :@ xs)", "assume \"lfilter\\<cdot>p\\<cdot>(lfilter\\<cdot>q\\<cdot>l) = lfilter\\<cdot>(\\<Lambda>(x::'a). q\\<cdot>x andalso p\\<cdot>x)\\<cdot>l\""], ["proof (state)\nthis:\n  lfilter\\<cdot>p\\<cdot>(lfilter\\<cdot>q\\<cdot>l) =\n  lfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>l\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            lfilter\\<cdot>p\\<cdot>(lfilter\\<cdot>q\\<cdot>a) =\n            lfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>\n            a)\n 2. lfilter\\<cdot>p\\<cdot>(lfilter\\<cdot>q\\<cdot>\\<bottom>) =\n    lfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>\\<bottom>\n 3. lfilter\\<cdot>p\\<cdot>(lfilter\\<cdot>q\\<cdot>lnil) =\n    lfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>lnil\n 4. \\<And>a xs.\n       lfilter\\<cdot>p\\<cdot>(lfilter\\<cdot>q\\<cdot>xs) =\n       lfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>\n       xs \\<Longrightarrow>\n       lfilter\\<cdot>p\\<cdot>(lfilter\\<cdot>q\\<cdot>(a :@ xs)) =\n       lfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>\n       (a :@ xs)", "thus \"lfilter\\<cdot>p\\<cdot>(lfilter\\<cdot>q\\<cdot>(a :@ l)) = lfilter\\<cdot>(\\<Lambda>(x::'a). q\\<cdot>x andalso p\\<cdot>x)\\<cdot>(a :@ l)\""], ["proof (prove)\nusing this:\n  lfilter\\<cdot>p\\<cdot>(lfilter\\<cdot>q\\<cdot>l) =\n  lfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>l\n\ngoal (1 subgoal):\n 1. lfilter\\<cdot>p\\<cdot>(lfilter\\<cdot>q\\<cdot>(a :@ l)) =\n    lfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>(a :@ l)", "by (cases \"q\\<cdot>a\" rule: trE, simp_all)"], ["proof (state)\nthis:\n  lfilter\\<cdot>p\\<cdot>(lfilter\\<cdot>q\\<cdot>(a :@ l)) =\n  lfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>(a :@ l)\n\ngoal (3 subgoals):\n 1. adm (\\<lambda>a.\n            lfilter\\<cdot>p\\<cdot>(lfilter\\<cdot>q\\<cdot>a) =\n            lfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>\n            a)\n 2. lfilter\\<cdot>p\\<cdot>(lfilter\\<cdot>q\\<cdot>\\<bottom>) =\n    lfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>\\<bottom>\n 3. lfilter\\<cdot>p\\<cdot>(lfilter\\<cdot>q\\<cdot>lnil) =\n    lfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>lnil", "qed simp_all"], ["", "fixrec ldropWhile :: \"('a \\<rightarrow> tr) \\<rightarrow> 'a llist \\<rightarrow> 'a llist\"\nwhere\n  \"ldropWhile\\<cdot>p\\<cdot>lnil = lnil\"\n| \"ldropWhile\\<cdot>p\\<cdot>(x :@ xs) = If p\\<cdot>x then ldropWhile\\<cdot>p\\<cdot>xs else x :@ xs\""], ["", "lemma ldropWhile_strict[simp]: \"ldropWhile\\<cdot>p\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldropWhile\\<cdot>p\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "lemma ldropWhile_lnil: \"(ldropWhile\\<cdot>p\\<cdot>xs = lnil) = (lall\\<cdot>p\\<cdot>xs = TT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ldropWhile\\<cdot>p\\<cdot>xs = lnil) = (lall\\<cdot>p\\<cdot>xs = TT)", "proof(induct xs)"], ["proof (state)\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            (ldropWhile\\<cdot>p\\<cdot>a = lnil) =\n            (lall\\<cdot>p\\<cdot>a = TT))\n 2. (ldropWhile\\<cdot>p\\<cdot>\\<bottom> = lnil) =\n    (lall\\<cdot>p\\<cdot>\\<bottom> = TT)\n 3. (ldropWhile\\<cdot>p\\<cdot>lnil = lnil) = (lall\\<cdot>p\\<cdot>lnil = TT)\n 4. \\<And>a xs.\n       (ldropWhile\\<cdot>p\\<cdot>xs = lnil) =\n       (lall\\<cdot>p\\<cdot>xs = TT) \\<Longrightarrow>\n       (ldropWhile\\<cdot>p\\<cdot>(a :@ xs) = lnil) =\n       (lall\\<cdot>p\\<cdot>(a :@ xs) = TT)", "fix a l"], ["proof (state)\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            (ldropWhile\\<cdot>p\\<cdot>a = lnil) =\n            (lall\\<cdot>p\\<cdot>a = TT))\n 2. (ldropWhile\\<cdot>p\\<cdot>\\<bottom> = lnil) =\n    (lall\\<cdot>p\\<cdot>\\<bottom> = TT)\n 3. (ldropWhile\\<cdot>p\\<cdot>lnil = lnil) = (lall\\<cdot>p\\<cdot>lnil = TT)\n 4. \\<And>a xs.\n       (ldropWhile\\<cdot>p\\<cdot>xs = lnil) =\n       (lall\\<cdot>p\\<cdot>xs = TT) \\<Longrightarrow>\n       (ldropWhile\\<cdot>p\\<cdot>(a :@ xs) = lnil) =\n       (lall\\<cdot>p\\<cdot>(a :@ xs) = TT)", "assume \"(ldropWhile\\<cdot>p\\<cdot>l = lnil) = (lall\\<cdot>p\\<cdot>l = TT)\""], ["proof (state)\nthis:\n  (ldropWhile\\<cdot>p\\<cdot>l = lnil) = (lall\\<cdot>p\\<cdot>l = TT)\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            (ldropWhile\\<cdot>p\\<cdot>a = lnil) =\n            (lall\\<cdot>p\\<cdot>a = TT))\n 2. (ldropWhile\\<cdot>p\\<cdot>\\<bottom> = lnil) =\n    (lall\\<cdot>p\\<cdot>\\<bottom> = TT)\n 3. (ldropWhile\\<cdot>p\\<cdot>lnil = lnil) = (lall\\<cdot>p\\<cdot>lnil = TT)\n 4. \\<And>a xs.\n       (ldropWhile\\<cdot>p\\<cdot>xs = lnil) =\n       (lall\\<cdot>p\\<cdot>xs = TT) \\<Longrightarrow>\n       (ldropWhile\\<cdot>p\\<cdot>(a :@ xs) = lnil) =\n       (lall\\<cdot>p\\<cdot>(a :@ xs) = TT)", "thus \"(ldropWhile\\<cdot>p\\<cdot>(a :@ l) = lnil) = (lall\\<cdot>p\\<cdot>(a :@ l) = TT)\""], ["proof (prove)\nusing this:\n  (ldropWhile\\<cdot>p\\<cdot>l = lnil) = (lall\\<cdot>p\\<cdot>l = TT)\n\ngoal (1 subgoal):\n 1. (ldropWhile\\<cdot>p\\<cdot>(a :@ l) = lnil) =\n    (lall\\<cdot>p\\<cdot>(a :@ l) = TT)", "by (cases \"p\\<cdot>a\" rule: trE, simp_all)"], ["proof (state)\nthis:\n  (ldropWhile\\<cdot>p\\<cdot>(a :@ l) = lnil) =\n  (lall\\<cdot>p\\<cdot>(a :@ l) = TT)\n\ngoal (3 subgoals):\n 1. adm (\\<lambda>a.\n            (ldropWhile\\<cdot>p\\<cdot>a = lnil) =\n            (lall\\<cdot>p\\<cdot>a = TT))\n 2. (ldropWhile\\<cdot>p\\<cdot>\\<bottom> = lnil) =\n    (lall\\<cdot>p\\<cdot>\\<bottom> = TT)\n 3. (ldropWhile\\<cdot>p\\<cdot>lnil = lnil) = (lall\\<cdot>p\\<cdot>lnil = TT)", "qed simp_all"], ["", "fixrec literate :: \"('a \\<rightarrow> 'a) \\<rightarrow> 'a \\<rightarrow> 'a llist\"\nwhere\n  \"literate\\<cdot>f\\<cdot>x = x :@ literate\\<cdot>f\\<cdot>(f\\<cdot>x)\""], ["", "declare literate.simps[simp del]"], ["", "text\\<open>This order of tests is convenient for the nub proof. I can\nimagine the other would be convenient for other proofs...\\<close>"], ["", "fixrec lmember :: \"('a \\<rightarrow> 'a \\<rightarrow> tr) \\<rightarrow> 'a \\<rightarrow> 'a llist \\<rightarrow> tr\"\nwhere\n  \"lmember\\<cdot>eq\\<cdot>x\\<cdot>lnil = FF\"\n| \"lmember\\<cdot>eq\\<cdot>x\\<cdot>(lcons\\<cdot>y\\<cdot>ys) = (lmember\\<cdot>eq\\<cdot>x\\<cdot>ys orelse eq\\<cdot>y\\<cdot>x)\""], ["", "lemma lmember_strict[simp]: \"lmember\\<cdot>eq\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmember\\<cdot>eq\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "fixrec llength :: \"'a llist \\<rightarrow> Nat\"\nwhere\n  \"llength\\<cdot>lnil = 0\"\n| \"llength\\<cdot>(lcons\\<cdot>x\\<cdot>xs) = 1 + llength\\<cdot>xs\""], ["", "lemma llength_strict[simp]: \"llength\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "fixrec lmap :: \"('a \\<rightarrow> 'b) \\<rightarrow> 'a llist \\<rightarrow> 'b llist\"\nwhere\n  \"lmap\\<cdot>f\\<cdot>lnil = lnil\"\n| \"lmap\\<cdot>f\\<cdot>(x :@ xs) = f\\<cdot>x :@ lmap\\<cdot>f\\<cdot>xs\""], ["", "lemma lmap_strict[simp]: \"lmap\\<cdot>f\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap\\<cdot>f\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "lemma lmap_lmap:\n  \"lmap\\<cdot>f\\<cdot>(lmap\\<cdot>g\\<cdot>xs) = lmap\\<cdot>(f oo g)\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap\\<cdot>f\\<cdot>(lmap\\<cdot>g\\<cdot>xs) =\n    lmap\\<cdot>(f oo g)\\<cdot>xs", "by (induct xs) simp_all"], ["", "text \\<open>The traditional list monad uses lconcatMap as its bind.\\<close>"], ["", "definition\n  \"lconcatMap \\<equiv> (\\<Lambda> f. lconcat oo lmap\\<cdot>f)\""], ["", "lemma lconcatMap_comp_simps[simp]:\n  \"lconcatMap\\<cdot>f\\<cdot>\\<bottom> = \\<bottom>\"\n  \"lconcatMap\\<cdot>f\\<cdot>lnil = lnil\"\n  \"lconcatMap\\<cdot>f\\<cdot>(x :@ xs) = f\\<cdot>x :++ lconcatMap\\<cdot>f\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lconcatMap\\<cdot>f\\<cdot>\\<bottom> = \\<bottom> &&&\n    lconcatMap\\<cdot>f\\<cdot>lnil = lnil &&&\n    lconcatMap\\<cdot>f\\<cdot>(x :@ xs) =\n    f\\<cdot>x :++ lconcatMap\\<cdot>f\\<cdot>xs", "by (simp_all add: lconcatMap_def)"], ["", "lemma lconcatMap_lsingleton[simp]:\n  \"lconcatMap\\<cdot>lsingleton\\<cdot>x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lconcatMap\\<cdot>lsingleton\\<cdot>x = x", "by (induct x) (simp_all add: lconcatMap_def)"], ["", "text\\<open>This @{term \"zipWith\"} function is only fully defined if the\nlists have the same length.\\<close>"], ["", "fixrec lzipWith0 :: \"('a \\<rightarrow> 'b \\<rightarrow> 'c) \\<rightarrow> 'a llist \\<rightarrow> 'b llist \\<rightarrow> 'c llist\"\nwhere\n  \"lzipWith0\\<cdot>f\\<cdot>(a :@ as)\\<cdot>(b :@ bs) = f\\<cdot>a\\<cdot>b :@ lzipWith0\\<cdot>f\\<cdot>as\\<cdot>bs\"\n| \"lzipWith0\\<cdot>f\\<cdot>lnil\\<cdot>lnil = lnil\""], ["", "lemma lzipWith0_stricts [simp]:\n  \"lzipWith0\\<cdot>f\\<cdot>\\<bottom>\\<cdot>ys = \\<bottom>\"\n  \"lzipWith0\\<cdot>f\\<cdot>lnil\\<cdot>\\<bottom> = \\<bottom>\"\n  \"lzipWith0\\<cdot>f\\<cdot>(x :@ xs)\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lzipWith0\\<cdot>f\\<cdot>\\<bottom>\\<cdot>ys = \\<bottom> &&&\n    lzipWith0\\<cdot>f\\<cdot>lnil\\<cdot>\\<bottom> = \\<bottom> &&&\n    lzipWith0\\<cdot>f\\<cdot>(x :@ xs)\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp+"], ["", "lemma lzipWith0_undefs [simp]:\n  \"lzipWith0\\<cdot>f\\<cdot>lnil\\<cdot>(y :@ ys) = \\<bottom>\"\n  \"lzipWith0\\<cdot>f\\<cdot>(x :@ xs)\\<cdot>lnil = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lzipWith0\\<cdot>f\\<cdot>lnil\\<cdot>(y :@ ys) = \\<bottom> &&&\n    lzipWith0\\<cdot>f\\<cdot>(x :@ xs)\\<cdot>lnil = \\<bottom>", "by fixrec_simp+"], ["", "text\\<open>This @{term \"zipWith\"} function follows Haskell's in being more\npermissive: zipping uneven lists results in a list as long as the\nshortest one. This is what the backtracking monad expects.\\<close>"], ["", "fixrec lzipWith :: \"('a \\<rightarrow> 'b \\<rightarrow> 'c) \\<rightarrow> 'a llist \\<rightarrow> 'b llist \\<rightarrow> 'c llist\"\nwhere\n  \"lzipWith\\<cdot>f\\<cdot>(a :@ as)\\<cdot>(b :@ bs) = f\\<cdot>a\\<cdot>b :@ lzipWith\\<cdot>f\\<cdot>as\\<cdot>bs\"\n| (unchecked) \"lzipWith\\<cdot>f\\<cdot>xs\\<cdot>ys = lnil\""], ["", "lemma lzipWith_simps [simp]:\n  \"lzipWith\\<cdot>f\\<cdot>(x :@ xs)\\<cdot>(y :@ ys) = f\\<cdot>x\\<cdot>y :@ lzipWith\\<cdot>f\\<cdot>xs\\<cdot>ys\"\n  \"lzipWith\\<cdot>f\\<cdot>(x :@ xs)\\<cdot>lnil = lnil\"\n  \"lzipWith\\<cdot>f\\<cdot>lnil\\<cdot>(y :@ ys) = lnil\"\n  \"lzipWith\\<cdot>f\\<cdot>lnil\\<cdot>lnil = lnil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lzipWith\\<cdot>f\\<cdot>(x :@ xs)\\<cdot>(y :@ ys) =\n     f\\<cdot>x\\<cdot>y :@ lzipWith\\<cdot>f\\<cdot>xs\\<cdot>ys &&&\n     lzipWith\\<cdot>f\\<cdot>(x :@ xs)\\<cdot>lnil = lnil) &&&\n    lzipWith\\<cdot>f\\<cdot>lnil\\<cdot>(y :@ ys) = lnil &&&\n    lzipWith\\<cdot>f\\<cdot>lnil\\<cdot>lnil = lnil", "by fixrec_simp+"], ["", "lemma lzipWith_stricts [simp]:\n  \"lzipWith\\<cdot>f\\<cdot>\\<bottom>\\<cdot>ys = \\<bottom>\"\n  \"lzipWith\\<cdot>f\\<cdot>(x :@ xs)\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lzipWith\\<cdot>f\\<cdot>\\<bottom>\\<cdot>ys = \\<bottom> &&&\n    lzipWith\\<cdot>f\\<cdot>(x :@ xs)\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp+"], ["", "text\\<open>Homomorphism properties, see Bird's life's work.\\<close>"], ["", "lemma lmap_lappend_dist:\n  \"lmap\\<cdot>f\\<cdot>(xs :++ ys) = lmap\\<cdot>f\\<cdot>xs :++ lmap\\<cdot>f\\<cdot>ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap\\<cdot>f\\<cdot>(xs :++ ys) =\n    lmap\\<cdot>f\\<cdot>xs :++ lmap\\<cdot>f\\<cdot>ys", "by (induct xs) simp_all"], ["", "lemma lconcat_lappend_dist:\n  \"lconcat\\<cdot>(xs :++ ys) = lconcat\\<cdot>xs :++ lconcat\\<cdot>ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lconcat\\<cdot>(xs :++ ys) = lconcat\\<cdot>xs :++ lconcat\\<cdot>ys", "by (induct xs) (simp_all add: lappend_assoc)"], ["", "lemma lconcatMap_assoc:\n  \"lconcatMap\\<cdot>h\\<cdot>(lconcatMap\\<cdot>g\\<cdot>f) = lconcatMap\\<cdot>(\\<Lambda> v. lconcatMap\\<cdot>h\\<cdot>(g\\<cdot>v))\\<cdot>f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lconcatMap\\<cdot>h\\<cdot>(lconcatMap\\<cdot>g\\<cdot>f) =\n    lconcatMap\\<cdot>\n    (\\<Lambda> v. lconcatMap\\<cdot>h\\<cdot>(g\\<cdot>v))\\<cdot>\n    f", "by (induct f) (simp_all add: lmap_lappend_dist lconcat_lappend_dist lconcatMap_def)"], ["", "lemma lconcatMap_lappend_dist:\n  \"lconcatMap\\<cdot>f\\<cdot>(xs :++ ys) = lconcatMap\\<cdot>f\\<cdot>xs :++ lconcatMap\\<cdot>f\\<cdot>ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lconcatMap\\<cdot>f\\<cdot>(xs :++ ys) =\n    lconcatMap\\<cdot>f\\<cdot>xs :++ lconcatMap\\<cdot>f\\<cdot>ys", "unfolding lconcatMap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> f. lconcat oo lmap\\<cdot>f)\\<cdot>f\\<cdot>(xs :++ ys) =\n    (\\<Lambda> f. lconcat oo lmap\\<cdot>f)\\<cdot>f\\<cdot>xs :++\n    (\\<Lambda> f. lconcat oo lmap\\<cdot>f)\\<cdot>f\\<cdot>ys", "by (simp add: lconcat_lappend_dist lmap_lappend_dist)"], ["", "(* The following avoid some case_tackery. *)"], ["", "lemma lmap_not_bottoms[simp]:\n  \"x \\<noteq> \\<bottom> \\<Longrightarrow> lmap\\<cdot>f\\<cdot>x \\<noteq> \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> \\<bottom> \\<Longrightarrow>\n    lmap\\<cdot>f\\<cdot>x \\<noteq> \\<bottom>", "by (cases x) simp_all"], ["", "lemma lsingleton_not_bottom[simp]:\n  \"lsingleton\\<cdot>x \\<noteq> \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsingleton\\<cdot>x \\<noteq> \\<bottom>", "by simp"], ["", "lemma lappend_not_bottom[simp]:\n  \"\\<lbrakk> xs \\<noteq> \\<bottom>; xs = lnil \\<Longrightarrow> ys \\<noteq> \\<bottom> \\<rbrakk> \\<Longrightarrow> xs :++ ys \\<noteq> \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> \\<bottom>;\n     xs = lnil \\<Longrightarrow> ys \\<noteq> \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> xs :++ ys \\<noteq> \\<bottom>", "apply (cases xs)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>xs \\<noteq> \\<bottom>;\n     xs = lnil \\<Longrightarrow> ys \\<noteq> \\<bottom>;\n     xs = \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> xs :++ ys \\<noteq> \\<bottom>\n 2. \\<lbrakk>xs \\<noteq> \\<bottom>;\n     xs = lnil \\<Longrightarrow> ys \\<noteq> \\<bottom>; xs = lnil\\<rbrakk>\n    \\<Longrightarrow> xs :++ ys \\<noteq> \\<bottom>\n 3. \\<And>a llist.\n       \\<lbrakk>xs \\<noteq> \\<bottom>;\n        xs = lnil \\<Longrightarrow> ys \\<noteq> \\<bottom>;\n        xs = a :@ llist\\<rbrakk>\n       \\<Longrightarrow> xs :++ ys \\<noteq> \\<bottom>", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "default_sort \"domain\""], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}