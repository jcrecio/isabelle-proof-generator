{"file_name": "/home/qj213/afp-2021-10-22/thys/WorkerWrapper/Nats.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/WorkerWrapper", "problem_names": ["lemma zero_discr[simp]: \"undiscr 0 = 0\"", "lemma one_discr[simp]: \"undiscr 1 = 1\"", "lemma uMult_unit_left: \"1 *\\<^sub># (x::UNat) = x\"", "lemma uMult_unit_right: \"(x::UNat) *\\<^sub># 1 = x\"", "lemma uMult_assoc: \"(x *\\<^sub># y) *\\<^sub># z = x *\\<^sub># (y *\\<^sub># z)\"", "lemma uMult_commute: \"x *\\<^sub># y = y *\\<^sub># x\"", "lemma uMult_left_commute: \"a *\\<^sub># (b *\\<^sub># c) = b *\\<^sub># (a *\\<^sub># c)\"", "lemmas uMult_arithmetic =\n  uMult_unit_left uMult_unit_right uMult_assoc uMult_commute uMult_left_commute", "lemma bbind_strict1[simp]: \"bbind\\<cdot>\\<bottom> = \\<bottom>\"", "lemma bbind_strict2[simp]: \"x >>= \\<bottom> = \\<bottom>\"", "lemma bbind_leftID[simp]: \"up\\<cdot>a >>= f = f\\<cdot>a\"", "lemma bbind_rightID[simp]: \"m >>= up = m\"", "lemma bbind_assoc[simp]: \"f >>= g >>= h = f >>= (\\<Lambda> x. g\\<cdot>x >>= h)\"", "lemma bbind_case_distr_strict: \"f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow> f\\<cdot>(g >>= h) = g >>= (\\<Lambda> x. f\\<cdot>(h\\<cdot>x))\"", "lemma bKleisli_strict1[simp]: \"bKleisli\\<cdot>\\<bottom> = \\<bottom>\"", "lemma bKleisli_strict2[simp]: \"b >=> \\<bottom> = \\<bottom>\"", "lemma bKleisli_bbind: \"(f >>= g) >=> h = f >>= (\\<Lambda> x. g\\<cdot>x >=> h)\"", "lemma boxI: \"Box\\<cdot>(up\\<cdot>x) = box\\<cdot>x\"", "lemma unbox_box[simp]: \"unbox\\<cdot>(box\\<cdot>x) = up\\<cdot>x\"", "lemma unbox_Box[simp]: \"x \\<noteq> \\<bottom> \\<Longrightarrow> unbox\\<cdot>(Box\\<cdot>x) = x\"", "lemma box_casedist[case_names bottom Box, cases type: Box]:\n  assumes xbot: \"x = \\<bottom> \\<Longrightarrow> P\"\n      and xbox: \"\\<And>u. x = box\\<cdot>u \\<Longrightarrow> P\"\n  shows \"P\"", "lemma bbind_leftID'[simp]: \"unbox\\<cdot>a >>= box = a\"", "lemma box_repeated:\n  \"x >>= (\\<Lambda> x'. f >>= (\\<Lambda> y'. x >>= body\\<cdot>x'\\<cdot>y'))\n  = x >>= (\\<Lambda> x'. f >>= (\\<Lambda> y'. body\\<cdot>x'\\<cdot>y'\\<cdot>x'))\"", "lemma bliftM_strict1[simp]: \"bliftM f\\<cdot>\\<bottom> = \\<bottom>\"", "lemma bliftM_op[simp]: \"bliftM f\\<cdot>(box\\<cdot>x) = box\\<cdot>(f\\<cdot>x)\"", "lemma bliftM2_strict1[simp]: \"bliftM2 f\\<cdot>\\<bottom> = \\<bottom>\"", "lemma bliftM2_strict2[simp]: \"bliftM2 f\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\"", "lemma bliftM2_op[simp]: \"bliftM2 f\\<cdot>(box\\<cdot>x)\\<cdot>(box\\<cdot>y) = box\\<cdot>(f\\<cdot>x\\<cdot>y)\"", "lemma plus_Box_cont[simp, cont2cont]:\n  \"\\<lbrakk>cont g; cont h\\<rbrakk> \\<Longrightarrow> cont (\\<lambda>x. (g x :: 'a :: {predomain, plus} Box) + h x)\"", "lemma plus_Box_strict1[simp]: \"\\<bottom> + (y :: 'a::{predomain, plus} Box) = \\<bottom>\"", "lemma plus_Box_strict2[simp]: \"(x :: 'a::{predomain, plus} Box) + \\<bottom> = \\<bottom>\"", "lemma minus_Box_cont[simp, cont2cont]:\n  \"\\<lbrakk>cont g; cont h\\<rbrakk> \\<Longrightarrow> cont (\\<lambda>x. (g x :: 'a :: {predomain, minus} Box) - h x)\"", "lemma minus_Box_strict1[simp]: \"\\<bottom> - (y :: 'a::{predomain, minus} Box) = \\<bottom>\"", "lemma minus_Box_strict2[simp]: \"(x :: 'a::{predomain, minus} Box) - \\<bottom> = \\<bottom>\"", "lemma times_Box_cont[simp, cont2cont]:\n  \"\\<lbrakk>cont g; cont h\\<rbrakk> \\<Longrightarrow> cont (\\<lambda>x. (g x :: 'a :: {predomain, times} Box) * h x)\"", "lemma times_Box_strict1[simp]: \"\\<bottom> * (y :: 'a::{predomain, times} Box) = \\<bottom>\"", "lemma times_Box_strict2[simp]: \"(x :: 'a::{predomain, times} Box) * \\<bottom> = \\<bottom>\"", "lemma bpred_strict1[simp]: \"bpred p\\<cdot>\\<bottom> = \\<bottom>\"", "lemma bpred_strict2[simp]: \"bpred p\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\"", "lemma bpred_eval[simp]: \"bpred p\\<cdot>(box\\<cdot>x)\\<cdot>(box\\<cdot>y) = (if p x y then TT else FF)\"", "lemma plus_Nat_eval[simp]: \"(box\\<cdot>x :: Nat) + box\\<cdot>y = box\\<cdot>(x + y)\"", "lemma minus_Nat_eval[simp]: \"(box\\<cdot>x :: Nat) - box\\<cdot>y = box\\<cdot>(x - y)\"", "lemma times_Nat_eval[simp]: \"(box\\<cdot>x :: Nat) * box\\<cdot>y = box\\<cdot>(x * y)\"", "lemma cont_case_nat[simp]:\n  \"\\<lbrakk>cont (\\<lambda>x. f x); \\<And>n. cont (\\<lambda>x. g x n) \\<rbrakk> \\<Longrightarrow> cont (\\<lambda>x. case_nat (f x) (g x) n)\"", "lemma Nat_case_strict[simp]: \"Nat_case\\<cdot>z\\<cdot>s\\<cdot>\\<bottom> = \\<bottom>\"", "lemma Nat_case_zero[simp]: \"Nat_case\\<cdot>z\\<cdot>s\\<cdot>0 = z\"", "lemma Nat_case_suc[simp]:  \"Nat_case\\<cdot>z\\<cdot>s\\<cdot>(box\\<cdot>(Discr (Suc n))) = s\\<cdot>(box\\<cdot>(Discr n))\"", "lemma Nat_case_add_1[simp]:\n  assumes ndef: \"n \\<noteq> \\<bottom>\"\n  shows \"Nat_case\\<cdot>z\\<cdot>s\\<cdot>(n + 1) = s\\<cdot>n\"", "lemma Nat_case_case_nat: \"Nat_case\\<cdot>z\\<cdot>s\\<cdot>(box\\<cdot>(Discr n)) = case_nat z (\\<lambda>n'. s\\<cdot>(box\\<cdot>(Discr n'))) n\"", "lemma Nat_casedist[case_names bottom zero Suc]:\n  fixes x :: Nat\n  assumes xbot: \"x = \\<bottom> \\<Longrightarrow> P\"\n      and xzero: \"x = 0 \\<Longrightarrow> P\"\n      and xsuc: \"\\<And>n. x = n + 1 \\<Longrightarrow> P\"\n  shows \"P\"", "lemma cont_Nat_case[simp]:\n  \"\\<lbrakk>cont (\\<lambda>x. f x); \\<And>n. cont (\\<lambda>x. g x\\<cdot>n) \\<rbrakk> \\<Longrightarrow> cont (\\<lambda>x. Nat_case\\<cdot>(f x)\\<cdot>(g x)\\<cdot>n)\"", "lemma Nat_induct[case_names bottom zero Suc]:\n  fixes P :: \"Nat \\<Rightarrow> bool\"\n  assumes xbot: \"P \\<bottom>\"\n      and xzero: \"P 0\"\n      and xsuc: \"\\<And>n. \\<lbrakk>n \\<noteq> \\<bottom>; P n \\<rbrakk> \\<Longrightarrow> P (n + 1)\"\n  shows \"P x\"", "lemma plus_commute: \"(x :: Nat) + y = y + x\"", "lemma mult_unit: \"(x::Nat) * 1 = x\"", "lemma mult_commute: \"(x :: Nat) * y = y * x\"", "lemma mult_assoc: \"((x :: Nat) * y) * z = x * (y * z)\""], "translations": [["", "lemma zero_discr[simp]: \"undiscr 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. undiscr 0 = (0::'a)", "unfolding zero_discr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. undiscr (Discr (0::'a)) = (0::'a)", "by simp"], ["", "instantiation discr :: (one) one\nbegin"], ["", "definition one_discr_def: \"1 \\<equiv> Discr 1\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a discr, one_class)", ".."], ["", "end"], ["", "lemma one_discr[simp]: \"undiscr 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. undiscr 1 = (1::'a)", "unfolding one_discr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. undiscr (Discr (1::'a)) = (1::'a)", "by simp"], ["", "instantiation discr :: (ord) ord\nbegin"], ["", "definition less_def[simp]: \"m < n \\<equiv> (undiscr m) < (undiscr n)\""], ["", "definition le_def[simp]:   \"m \\<le> n \\<equiv> (undiscr m) \\<le> (undiscr n)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a discr, ord_class)", ".."], ["", "end"], ["", "definition\n  uPlus :: \"UNat \\<rightarrow> UNat \\<rightarrow> UNat\" where\n  \"uPlus \\<equiv> \\<Lambda> x y. Discr (undiscr x + undiscr y)\""], ["", "abbreviation\n  uPlus_syn :: \"UNat \\<Rightarrow> UNat \\<Rightarrow> UNat\" (infixl \"+\\<^sub>#\" 65) where\n  \"x +\\<^sub># y \\<equiv> uPlus\\<cdot>x\\<cdot>y\""], ["", "instantiation discr :: (plus) plus\nbegin"], ["", "definition plus_discr_def[simp]: \"x + y \\<equiv> Discr (undiscr x + undiscr y)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a discr, plus_class)", ".."], ["", "end"], ["", "definition\n  uMinus :: \"UNat \\<rightarrow> UNat \\<rightarrow> UNat\" where\n  \"uMinus \\<equiv> \\<Lambda> x y. Discr (undiscr x - undiscr y)\""], ["", "abbreviation\n  uMinus_syn :: \"UNat \\<Rightarrow> UNat \\<Rightarrow> UNat\" (infixl \"-\\<^sub>#\" 65) where\n  \"x -\\<^sub># y \\<equiv> uMinus\\<cdot>x\\<cdot>y\""], ["", "instantiation discr :: (minus) minus\nbegin"], ["", "definition minus_discr_def[simp]: \"x - y \\<equiv> Discr (undiscr x - undiscr y)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a discr, minus_class)", ".."], ["", "end"], ["", "definition\n  uMult :: \"UNat \\<rightarrow> UNat \\<rightarrow> UNat\" where\n  \"uMult \\<equiv> \\<Lambda> x y. Discr (undiscr x * undiscr y)\""], ["", "abbreviation\n  uMult_syn :: \"UNat \\<Rightarrow> UNat \\<Rightarrow> UNat\" (infixl \"*\\<^sub>#\" 65) where\n  \"x *\\<^sub># y \\<equiv> uMult\\<cdot>x\\<cdot>y\""], ["", "instantiation discr :: (times) times\nbegin"], ["", "definition times_discr_def[simp]: \"x * y \\<equiv> Discr (undiscr x * undiscr y)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a discr, times_class)", ".."], ["", "end"], ["", "lemma uMult_unit_left: \"1 *\\<^sub># (x::UNat) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 *\\<^sub># x = x", "unfolding uMult_def one_discr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> x y. Discr (undiscr x * undiscr y))\\<cdot>(Discr 1)\\<cdot>x =\n    x", "by simp"], ["", "lemma uMult_unit_right: \"(x::UNat) *\\<^sub># 1 = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x *\\<^sub># 1 = x", "unfolding uMult_def one_discr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> x y. Discr (undiscr x * undiscr y))\\<cdot>x\\<cdot>(Discr 1) =\n    x", "by simp"], ["", "lemma uMult_assoc: \"(x *\\<^sub># y) *\\<^sub># z = x *\\<^sub># (y *\\<^sub># z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x *\\<^sub># y *\\<^sub># z = x *\\<^sub># (y *\\<^sub># z)", "unfolding uMult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> x y. Discr (undiscr x * undiscr y))\\<cdot>\n    ((\\<Lambda> x y. Discr (undiscr x * undiscr y))\\<cdot>x\\<cdot>y)\\<cdot>\n    z =\n    (\\<Lambda> x y. Discr (undiscr x * undiscr y))\\<cdot>x\\<cdot>\n    ((\\<Lambda> x y. Discr (undiscr x * undiscr y))\\<cdot>y\\<cdot>z)", "by simp"], ["", "lemma uMult_commute: \"x *\\<^sub># y = y *\\<^sub># x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x *\\<^sub># y = y *\\<^sub># x", "unfolding uMult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> x y. Discr (undiscr x * undiscr y))\\<cdot>x\\<cdot>y =\n    (\\<Lambda> x y. Discr (undiscr x * undiscr y))\\<cdot>y\\<cdot>x", "by simp"], ["", "lemma uMult_left_commute: \"a *\\<^sub># (b *\\<^sub># c) = b *\\<^sub># (a *\\<^sub># c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a *\\<^sub># (b *\\<^sub># c) = b *\\<^sub># (a *\\<^sub># c)", "unfolding uMult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> x y. Discr (undiscr x * undiscr y))\\<cdot>a\\<cdot>\n    ((\\<Lambda> x y. Discr (undiscr x * undiscr y))\\<cdot>b\\<cdot>c) =\n    (\\<Lambda> x y. Discr (undiscr x * undiscr y))\\<cdot>b\\<cdot>\n    ((\\<Lambda> x y. Discr (undiscr x * undiscr y))\\<cdot>a\\<cdot>c)", "by simp"], ["", "lemmas uMult_arithmetic =\n  uMult_unit_left uMult_unit_right uMult_assoc uMult_commute uMult_left_commute"], ["", "subsection \\<open>The \"@{term \\<bottom>}\" monad.\\<close>"], ["", "text\\<open>\n\nAs Brian Huffman helpfully observed, the \"@{term \"\\<bottom>\"}\" type\nconstructor supports the monadic operations; it's isomorphic to\nHaskell's @{term \"Maybe a\"}, or ML's @{typ \"'a option\"}.\n\nNote that @{term \"return\"} is @{term \"up\"}.\n\n\\<close>"], ["", "definition\n  bbind :: \"('a::cpo)\\<^sub>\\<bottom> \\<rightarrow> ('a \\<rightarrow> ('b::pcpo)) \\<rightarrow> 'b\" where\n  \"bbind \\<equiv> \\<Lambda> b g. fup\\<cdot>g\\<cdot>b\""], ["", "abbreviation\n  bbind_syn :: \"('a::cpo)\\<^sub>\\<bottom> \\<Rightarrow> ('a \\<rightarrow> ('b::pcpo)) \\<Rightarrow> 'b\" (infixl \">>=\" 65) where\n  \"b >>= g \\<equiv> bbind\\<cdot>b\\<cdot>g\""], ["", "lemma bbind_strict1[simp]: \"bbind\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bbind\\<cdot>\\<bottom> = \\<bottom>", "by (simp add: bbind_def)"], ["", "lemma bbind_strict2[simp]: \"x >>= \\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x >>= \\<bottom> = \\<bottom>", "by (cases x, simp_all add: bbind_def)"], ["", "lemma bbind_leftID[simp]: \"up\\<cdot>a >>= f = f\\<cdot>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. up\\<cdot>a >>= f = f\\<cdot>a", "by (simp add: bbind_def)"], ["", "lemma bbind_rightID[simp]: \"m >>= up = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m >>= up = m", "by (cases m, simp_all)"], ["", "lemma bbind_assoc[simp]: \"f >>= g >>= h = f >>= (\\<Lambda> x. g\\<cdot>x >>= h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f >>= g >>= h = f >>= (\\<Lambda> x. g\\<cdot>x >>= h)", "by (cases f, simp_all)"], ["", "lemma bbind_case_distr_strict: \"f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow> f\\<cdot>(g >>= h) = g >>= (\\<Lambda> x. f\\<cdot>(h\\<cdot>x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n    f\\<cdot>(g >>= h) = g >>= (\\<Lambda> x. f\\<cdot>(h\\<cdot>x))", "unfolding bbind_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n    f\\<cdot>((\\<Lambda> b g. fup\\<cdot>g\\<cdot>b)\\<cdot>g\\<cdot>h) =\n    (\\<Lambda> b g. fup\\<cdot>g\\<cdot>b)\\<cdot>g\\<cdot>\n    (\\<Lambda> x. f\\<cdot>(h\\<cdot>x))", "by (cases g, simp_all)"], ["", "text\\<open>\n\nKleisli composition is sometimes helpful. It forms a monad too,\nand has many useful algebraic properties. Unfortunately it is more\nwork than is useful to write the lemmas in a way that makes the\nhigher-order unifier in the simplifier happy. Seems easier just to\nunfold the definition and go from there.\n\n\\<close>"], ["", "definition\n  bKleisli :: \"('a::cpo \\<rightarrow> ('b::cpo)\\<^sub>\\<bottom>) \\<rightarrow> ('b \\<rightarrow> ('c::cpo)\\<^sub>\\<bottom>) \\<rightarrow> ('a \\<rightarrow> 'c\\<^sub>\\<bottom>)\" where\n  \"bKleisli \\<equiv> \\<Lambda> f g x. f\\<cdot>x >>= g\""], ["", "abbreviation\n  bKleisli_syn :: \"('a::cpo \\<rightarrow> ('b::cpo)\\<^sub>\\<bottom>) \\<Rightarrow> ('b \\<rightarrow> ('c::cpo)\\<^sub>\\<bottom>) \\<Rightarrow> ('a \\<rightarrow> 'c\\<^sub>\\<bottom>)\" (infixl \">=>\" 65) where\n  \"b >=> g \\<equiv> bKleisli\\<cdot>b\\<cdot>g\""], ["", "lemma bKleisli_strict1[simp]: \"bKleisli\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bKleisli\\<cdot>\\<bottom> = \\<bottom>", "by (simp add: bKleisli_def)"], ["", "lemma bKleisli_strict2[simp]: \"b >=> \\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b >=> \\<bottom> = \\<bottom>", "by (rule cfun_eqI, simp add: bKleisli_def)"], ["", "lemma bKleisli_bbind: \"(f >>= g) >=> h = f >>= (\\<Lambda> x. g\\<cdot>x >=> h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f >>= g >=> h = f >>= (\\<Lambda> x. g\\<cdot>x >=> h)", "by (cases f, simp_all)"], ["", "text \\<open>\n\nThe \"Box\" type denotes computations that, when demanded, yield\neither @{term \"\\<bottom>\"} or an unboxed value. Note that the @{term \"Box\"}\nconstructor is strict, and so merely tags the lifted computation @{typ\n\"'a\\<^sub>\\<bottom>\"}. @{typ \"'a\"} can be pointed or unpointed. This approach enables\nus to distinguish the boxed values from the lifted-function-space that\nmodels recursive functions with unboxed codomains.\n\n\\<close>"], ["", "domain 'a Box = Box (unbox :: \"'a\\<^sub>\\<bottom>\")"], ["", "definition\n  box :: \"('a::predomain) \\<rightarrow> 'a Box\" where\n  \"box \\<equiv> Box oo up\""], ["", "lemma boxI: \"Box\\<cdot>(up\\<cdot>x) = box\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Box\\<cdot>(up\\<cdot>x) = box\\<cdot>x", "unfolding box_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Box\\<cdot>(up\\<cdot>x) = (Box oo up)\\<cdot>x", "by simp"], ["", "lemma unbox_box[simp]: \"unbox\\<cdot>(box\\<cdot>x) = up\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unbox\\<cdot>(box\\<cdot>x) = up\\<cdot>x", "unfolding box_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. unbox\\<cdot>((Box oo up)\\<cdot>x) = up\\<cdot>x", "by simp"], ["", "lemma unbox_Box[simp]: \"x \\<noteq> \\<bottom> \\<Longrightarrow> unbox\\<cdot>(Box\\<cdot>x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> \\<bottom> \\<Longrightarrow> unbox\\<cdot>(Box\\<cdot>x) = x", "by simp"], ["", "text\\<open>\n\nIf we suceed in @{term \"box\"}ing something, then clearly that\nsomething was not @{term \"\\<bottom>\"}.\n\n\\<close>"], ["", "lemma box_casedist[case_names bottom Box, cases type: Box]:\n  assumes xbot: \"x = \\<bottom> \\<Longrightarrow> P\"\n      and xbox: \"\\<And>u. x = box\\<cdot>u \\<Longrightarrow> P\"\n  shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof(cases x)"], ["proof (state)\ngoal (2 subgoals):\n 1. x = \\<bottom> \\<Longrightarrow> P\n 2. \\<And>u.\n       \\<lbrakk>x = Box\\<cdot>u; u \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> P", "case bottom"], ["proof (state)\nthis:\n  x = \\<bottom>\n\ngoal (2 subgoals):\n 1. x = \\<bottom> \\<Longrightarrow> P\n 2. \\<And>u.\n       \\<lbrakk>x = Box\\<cdot>u; u \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> P", "with xbot"], ["proof (chain)\npicking this:\n  x = \\<bottom> \\<Longrightarrow> P\n  x = \\<bottom>", "show ?thesis"], ["proof (prove)\nusing this:\n  x = \\<bottom> \\<Longrightarrow> P\n  x = \\<bottom>\n\ngoal (1 subgoal):\n 1. P", "by simp"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>x = Box\\<cdot>u; u \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>x = Box\\<cdot>u; u \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> P", "case (Box u)"], ["proof (state)\nthis:\n  x = Box\\<cdot>u\n  u \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>x = Box\\<cdot>u; u \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> P", "with xbox"], ["proof (chain)\npicking this:\n  x = box\\<cdot>?u \\<Longrightarrow> P\n  x = Box\\<cdot>u\n  u \\<noteq> \\<bottom>", "show ?thesis"], ["proof (prove)\nusing this:\n  x = box\\<cdot>?u \\<Longrightarrow> P\n  x = Box\\<cdot>u\n  u \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. P", "by (cases u, simp_all add: box_def up_def cont_Iup bottomI[OF minimal_up])"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bbind_leftID'[simp]: \"unbox\\<cdot>a >>= box = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unbox\\<cdot>a >>= box = a", "by (cases a, simp_all add: bbind_def)"], ["", "(*<*)"], ["", "text \\<open>\n\nThe optimisations of \\citet{SPJ-JL:1991}.\n\np11: Repeated unboxing of the same value can be done once (roughly:\nstore the value in a register). Their story is more general.\n\n\\<close>"], ["", "lemma box_repeated:\n  \"x >>= (\\<Lambda> x'. f >>= (\\<Lambda> y'. x >>= body\\<cdot>x'\\<cdot>y'))\n  = x >>= (\\<Lambda> x'. f >>= (\\<Lambda> y'. body\\<cdot>x'\\<cdot>y'\\<cdot>x'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x >>=\n    (\\<Lambda> x'. f >>= (\\<Lambda> y'. x >>= body\\<cdot>x'\\<cdot>y')) =\n    x >>=\n    (\\<Lambda> x'. f >>= (\\<Lambda> y'. body\\<cdot>x'\\<cdot>y'\\<cdot>x'))", "by (cases x, simp_all)"], ["", "(*>*)"], ["", "text\\<open>Lift binary predicates over @{typ \"'a discr\"} into @{typ \"'a discr Box\"}.\\<close>"], ["", "text \\<open>@{term \"bliftM\"} and @{term \"bliftM2\"} encapsulate the boxing\nand unboxing.\\<close>"], ["", "definition\n  bliftM :: \"('a::predomain \\<rightarrow> 'b::predomain) \\<Rightarrow> 'a Box \\<rightarrow> 'b Box\" where\n  \"bliftM f \\<equiv> \\<Lambda> x. unbox\\<cdot>x >>= (\\<Lambda> x'. box\\<cdot>(f\\<cdot>x'))\""], ["", "lemma bliftM_strict1[simp]: \"bliftM f\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bliftM f\\<cdot>\\<bottom> = \\<bottom>", "by (simp add: bliftM_def)"], ["", "lemma bliftM_op[simp]: \"bliftM f\\<cdot>(box\\<cdot>x) = box\\<cdot>(f\\<cdot>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bliftM f\\<cdot>(box\\<cdot>x) = box\\<cdot>(f\\<cdot>x)", "by (simp add: bliftM_def)"], ["", "definition\n  bliftM2 :: \"('a::predomain \\<rightarrow> 'b::predomain \\<rightarrow> 'c::predomain) \\<Rightarrow> 'a Box \\<rightarrow> 'b Box \\<rightarrow> 'c Box\" where\n  \"bliftM2 f \\<equiv> \\<Lambda> x y. unbox\\<cdot>x >>= (\\<Lambda> x'. unbox\\<cdot>y >>= (\\<Lambda> y'. box\\<cdot>(f\\<cdot>x'\\<cdot>y')))\""], ["", "lemma bliftM2_strict1[simp]: \"bliftM2 f\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bliftM2 f\\<cdot>\\<bottom> = \\<bottom>", "by (rule cfun_eqI)+ (simp add: bliftM2_def)"], ["", "lemma bliftM2_strict2[simp]: \"bliftM2 f\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bliftM2 f\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>", "by (cases x, simp_all add: bliftM2_def)"], ["", "lemma bliftM2_op[simp]: \"bliftM2 f\\<cdot>(box\\<cdot>x)\\<cdot>(box\\<cdot>y) = box\\<cdot>(f\\<cdot>x\\<cdot>y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bliftM2 f\\<cdot>(box\\<cdot>x)\\<cdot>(box\\<cdot>y) =\n    box\\<cdot>(f\\<cdot>x\\<cdot>y)", "by (simp add: bliftM2_def)"], ["", "text\\<open>\n\nDefine the arithmetic operations. We need extra continuity lemmas as\nwe're using the full function space, so we can re-use the conventional\noperators. The goal is to work at this level.\n\n\\<close>"], ["", "instantiation Box :: (\"{predomain,plus}\") plus\nbegin"], ["", "definition plus_Box_def: \"x + y \\<equiv> bliftM2 (\\<Lambda> a b. a + b)\\<cdot>x\\<cdot>y\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a Box, plus_class)", ".."], ["", "end"], ["", "lemma plus_Box_cont[simp, cont2cont]:\n  \"\\<lbrakk>cont g; cont h\\<rbrakk> \\<Longrightarrow> cont (\\<lambda>x. (g x :: 'a :: {predomain, plus} Box) + h x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cont g; cont h\\<rbrakk>\n    \\<Longrightarrow> cont (\\<lambda>x. g x + h x)", "unfolding plus_Box_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cont g; cont h\\<rbrakk>\n    \\<Longrightarrow> cont\n                       (\\<lambda>x.\n                           bliftM2 (\\<Lambda> a b. a + b)\\<cdot>(g x)\\<cdot>\n                           (h x))", "by simp"], ["", "lemma plus_Box_strict1[simp]: \"\\<bottom> + (y :: 'a::{predomain, plus} Box) = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> + y = \\<bottom>", "unfolding plus_Box_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bliftM2 (\\<Lambda> a b. a + b)\\<cdot>\\<bottom>\\<cdot>y = \\<bottom>", "by simp"], ["", "lemma plus_Box_strict2[simp]: \"(x :: 'a::{predomain, plus} Box) + \\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + \\<bottom> = \\<bottom>", "unfolding plus_Box_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bliftM2 (\\<Lambda> a b. a + b)\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>", "by simp"], ["", "instantiation Box :: (\"{predomain,minus}\") minus\nbegin"], ["", "definition minus_Box_def: \"x - y \\<equiv> bliftM2 (\\<Lambda> a b. a - b)\\<cdot>x\\<cdot>y\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a Box, minus_class)", ".."], ["", "end"], ["", "lemma minus_Box_cont[simp, cont2cont]:\n  \"\\<lbrakk>cont g; cont h\\<rbrakk> \\<Longrightarrow> cont (\\<lambda>x. (g x :: 'a :: {predomain, minus} Box) - h x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cont g; cont h\\<rbrakk>\n    \\<Longrightarrow> cont (\\<lambda>x. g x - h x)", "unfolding minus_Box_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cont g; cont h\\<rbrakk>\n    \\<Longrightarrow> cont\n                       (\\<lambda>x.\n                           bliftM2 (\\<Lambda> a b. a - b)\\<cdot>(g x)\\<cdot>\n                           (h x))", "by simp"], ["", "lemma minus_Box_strict1[simp]: \"\\<bottom> - (y :: 'a::{predomain, minus} Box) = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> - y = \\<bottom>", "unfolding minus_Box_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bliftM2 (\\<Lambda> a b. a - b)\\<cdot>\\<bottom>\\<cdot>y = \\<bottom>", "by simp"], ["", "lemma minus_Box_strict2[simp]: \"(x :: 'a::{predomain, minus} Box) - \\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x - \\<bottom> = \\<bottom>", "unfolding minus_Box_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bliftM2 (\\<Lambda> a b. a - b)\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>", "by simp"], ["", "instantiation Box :: (\"{predomain,times}\") times\nbegin"], ["", "definition times_Box_def: \"x * y \\<equiv> bliftM2 (\\<Lambda> a b. a * b)\\<cdot>x\\<cdot>y\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a Box, times_class)", ".."], ["", "end"], ["", "lemma times_Box_cont[simp, cont2cont]:\n  \"\\<lbrakk>cont g; cont h\\<rbrakk> \\<Longrightarrow> cont (\\<lambda>x. (g x :: 'a :: {predomain, times} Box) * h x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cont g; cont h\\<rbrakk>\n    \\<Longrightarrow> cont (\\<lambda>x. g x * h x)", "unfolding times_Box_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cont g; cont h\\<rbrakk>\n    \\<Longrightarrow> cont\n                       (\\<lambda>x.\n                           bliftM2 (\\<Lambda> a b. a * b)\\<cdot>(g x)\\<cdot>\n                           (h x))", "by simp"], ["", "lemma times_Box_strict1[simp]: \"\\<bottom> * (y :: 'a::{predomain, times} Box) = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> * y = \\<bottom>", "unfolding times_Box_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bliftM2 (\\<Lambda> a b. a * b)\\<cdot>\\<bottom>\\<cdot>y = \\<bottom>", "by simp"], ["", "lemma times_Box_strict2[simp]: \"(x :: 'a::{predomain, times} Box) * \\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<bottom> = \\<bottom>", "unfolding times_Box_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bliftM2 (\\<Lambda> a b. a * b)\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>", "by simp"], ["", "definition\n  bpred :: \"('a::countable discr \\<Rightarrow> 'a discr \\<Rightarrow> bool) \\<Rightarrow> 'a discr Box \\<rightarrow> 'a discr Box \\<rightarrow> tr\" where\n  \"bpred p \\<equiv> \\<Lambda> x y. unbox\\<cdot>x >>= (\\<Lambda> x'. unbox\\<cdot>y >>= (\\<Lambda> y'. if p x' y' then TT else FF))\""], ["", "lemma bpred_strict1[simp]: \"bpred p\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bpred p\\<cdot>\\<bottom> = \\<bottom>", "unfolding bpred_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> x y.\n        unbox\\<cdot>x >>=\n        (\\<Lambda> x'.\n            unbox\\<cdot>y >>=\n            (\\<Lambda> y'. if p x' y' then TT else FF)))\\<cdot>\n    \\<bottom> =\n    \\<bottom>", "by (rule cfun_eqI, simp)"], ["", "lemma bpred_strict2[simp]: \"bpred p\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bpred p\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>", "unfolding bpred_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> x y.\n        unbox\\<cdot>x >>=\n        (\\<Lambda> x'.\n            unbox\\<cdot>y >>=\n            (\\<Lambda> y'. if p x' y' then TT else FF)))\\<cdot>\n    x\\<cdot>\n    \\<bottom> =\n    \\<bottom>", "by (cases x, simp_all)"], ["", "lemma bpred_eval[simp]: \"bpred p\\<cdot>(box\\<cdot>x)\\<cdot>(box\\<cdot>y) = (if p x y then TT else FF)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bpred p\\<cdot>(box\\<cdot>x)\\<cdot>(box\\<cdot>y) =\n    (if p x y then TT else FF)", "unfolding bpred_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> x y.\n        unbox\\<cdot>x >>=\n        (\\<Lambda> x'.\n            unbox\\<cdot>y >>=\n            (\\<Lambda> y'. if p x' y' then TT else FF)))\\<cdot>\n    (box\\<cdot>x)\\<cdot>\n    (box\\<cdot>y) =\n    (if p x y then TT else FF)", "by simp"], ["", "abbreviation\n  beq_syn :: \"'a::countable discr Box \\<Rightarrow> 'a discr Box \\<Rightarrow> tr\" (infix \"=\\<^sub>B\" 50) where\n  \"x =\\<^sub>B y \\<equiv> bpred (=)\\<cdot>x\\<cdot>y\""], ["", "abbreviation\n  ble_syn :: \"'a::{countable,ord} discr Box \\<Rightarrow> 'a discr Box \\<Rightarrow> tr\" (infix \"\\<le>\\<^sub>B\" 50) where\n  \"x \\<le>\\<^sub>B y \\<equiv> bpred (\\<le>)\\<cdot>x\\<cdot>y\""], ["", "abbreviation\n  blt_syn :: \"'a::{countable,ord} discr Box \\<Rightarrow> 'a discr Box \\<Rightarrow> tr\" (infix \"<\\<^sub>B\" 50) where\n  \"x <\\<^sub>B y \\<equiv> bpred (<)\\<cdot>x\\<cdot>y\""], ["", "subsection\\<open>The flat domain of natural numbers\\<close>"], ["", "text\\<open>Lift arithmetic to the boxed naturals. Define some things that make\nplaying with boxed naturals more convenient.\\<close>"], ["", "type_synonym Nat = \"UNat Box\""], ["", "instantiation Box :: (\"{predomain, zero}\") zero\nbegin"], ["", "definition zero_Nat_def: \"0 \\<equiv> box\\<cdot>0\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a Box, zero_class)", ".."], ["", "end"], ["", "instantiation Box :: (\"{predomain, one}\") one\nbegin"], ["", "definition one_Nat_def: \"1 \\<equiv> box\\<cdot>1\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a Box, one_class)", ".."], ["", "end"], ["", "text \\<open>We need to know the underlying operations are continuous for these to work.\\<close>"], ["", "lemma plus_Nat_eval[simp]: \"(box\\<cdot>x :: Nat) + box\\<cdot>y = box\\<cdot>(x + y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. box\\<cdot>x + box\\<cdot>y = box\\<cdot>(x + y)", "unfolding plus_Box_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bliftM2 (\\<Lambda> a b. a + b)\\<cdot>(box\\<cdot>x)\\<cdot>(box\\<cdot>y) =\n    box\\<cdot>(x + y)", "by simp"], ["", "lemma minus_Nat_eval[simp]: \"(box\\<cdot>x :: Nat) - box\\<cdot>y = box\\<cdot>(x - y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. box\\<cdot>x - box\\<cdot>y = box\\<cdot>(x - y)", "unfolding minus_Box_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bliftM2 (\\<Lambda> a b. a - b)\\<cdot>(box\\<cdot>x)\\<cdot>(box\\<cdot>y) =\n    box\\<cdot>(x - y)", "by simp"], ["", "lemma times_Nat_eval[simp]: \"(box\\<cdot>x :: Nat) * box\\<cdot>y = box\\<cdot>(x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. box\\<cdot>x * box\\<cdot>y = box\\<cdot>(x * y)", "unfolding times_Box_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bliftM2 (\\<Lambda> a b. a * b)\\<cdot>(box\\<cdot>x)\\<cdot>(box\\<cdot>y) =\n    box\\<cdot>(x * y)", "by simp"], ["", "definition\n  Nat_case :: \"'a::domain \\<rightarrow> (Nat \\<rightarrow> 'a) \\<rightarrow> Nat \\<rightarrow> 'a\" where\n  \"Nat_case \\<equiv> \\<Lambda> z s n. unbox\\<cdot>n >>= (\\<Lambda> n'. case_nat z (\\<lambda>n''. s\\<cdot>(box\\<cdot>(Discr n''))) (undiscr n'))\""], ["", "lemma cont_case_nat[simp]:\n  \"\\<lbrakk>cont (\\<lambda>x. f x); \\<And>n. cont (\\<lambda>x. g x n) \\<rbrakk> \\<Longrightarrow> cont (\\<lambda>x. case_nat (f x) (g x) n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cont f; \\<And>n. cont (\\<lambda>x. g x n)\\<rbrakk>\n    \\<Longrightarrow> cont\n                       (\\<lambda>x.\n                           case n of 0 \\<Rightarrow> f x\n                           | Suc xa \\<Rightarrow> g x xa)", "by (cases n, simp_all)"], ["", "lemma Nat_case_strict[simp]: \"Nat_case\\<cdot>z\\<cdot>s\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Nat_case\\<cdot>z\\<cdot>s\\<cdot>\\<bottom> = \\<bottom>", "by (simp add: Nat_case_def)"], ["", "lemma Nat_case_zero[simp]: \"Nat_case\\<cdot>z\\<cdot>s\\<cdot>0 = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Nat_case\\<cdot>z\\<cdot>s\\<cdot>0 = z", "by (simp add: Nat_case_def zero_Nat_def zero_discr_def)"], ["", "lemma Nat_case_suc[simp]:  \"Nat_case\\<cdot>z\\<cdot>s\\<cdot>(box\\<cdot>(Discr (Suc n))) = s\\<cdot>(box\\<cdot>(Discr n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Nat_case\\<cdot>z\\<cdot>s\\<cdot>(box\\<cdot>(Discr (Suc n))) =\n    s\\<cdot>(box\\<cdot>(Discr n))", "by (simp add: Nat_case_def)"], ["", "lemma Nat_case_add_1[simp]:\n  assumes ndef: \"n \\<noteq> \\<bottom>\"\n  shows \"Nat_case\\<cdot>z\\<cdot>s\\<cdot>(n + 1) = s\\<cdot>n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Nat_case\\<cdot>z\\<cdot>s\\<cdot>(n + 1) = s\\<cdot>n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Nat_case\\<cdot>z\\<cdot>s\\<cdot>(n + 1) = s\\<cdot>n", "from ndef"], ["proof (chain)\npicking this:\n  n \\<noteq> \\<bottom>", "obtain nu where nu: \"n = box\\<cdot>nu\""], ["proof (prove)\nusing this:\n  n \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. (\\<And>nu. n = box\\<cdot>nu \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding box_def"], ["proof (prove)\nusing this:\n  n \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. (\\<And>nu.\n        n = (Box oo up)\\<cdot>nu \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (cases \"n\" rule: Box.exhaust)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>nu. n = (Box oo up)\\<cdot>nu \\<Longrightarrow> thesis;\n     n \\<noteq> \\<bottom>; n = \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>u.\n       \\<lbrakk>\\<And>nu. n = (Box oo up)\\<cdot>nu \\<Longrightarrow> thesis;\n        n \\<noteq> \\<bottom>; n = Box\\<cdot>u; u \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>\\<And>nu. n = (Box oo up)\\<cdot>nu \\<Longrightarrow> thesis;\n        n \\<noteq> \\<bottom>; n = Box\\<cdot>u; u \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (case_tac \"u\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>\\<And>nu. n = (Box oo up)\\<cdot>nu \\<Longrightarrow> thesis;\n        n \\<noteq> \\<bottom>; n = Box\\<cdot>u; u \\<noteq> \\<bottom>;\n        u = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>u x.\n       \\<lbrakk>\\<And>nu. n = (Box oo up)\\<cdot>nu \\<Longrightarrow> thesis;\n        n \\<noteq> \\<bottom>; n = Box\\<cdot>u; u \\<noteq> \\<bottom>;\n        u = up\\<cdot>x\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  n = box\\<cdot>nu\n\ngoal (1 subgoal):\n 1. Nat_case\\<cdot>z\\<cdot>s\\<cdot>(n + 1) = s\\<cdot>n", "then"], ["proof (chain)\npicking this:\n  n = box\\<cdot>nu", "obtain u where \"nu = Discr u\""], ["proof (prove)\nusing this:\n  n = box\\<cdot>nu\n\ngoal (1 subgoal):\n 1. (\\<And>u. nu = Discr u \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding box_def"], ["proof (prove)\nusing this:\n  n = (Box oo up)\\<cdot>nu\n\ngoal (1 subgoal):\n 1. (\\<And>u. nu = Discr u \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (cases nu)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>u. nu = Discr u \\<Longrightarrow> thesis;\n        n = (Box oo up)\\<cdot>nu; nu = Discr x\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  nu = Discr u\n\ngoal (1 subgoal):\n 1. Nat_case\\<cdot>z\\<cdot>s\\<cdot>(n + 1) = s\\<cdot>n", "with nu"], ["proof (chain)\npicking this:\n  n = box\\<cdot>nu\n  nu = Discr u", "show ?thesis"], ["proof (prove)\nusing this:\n  n = box\\<cdot>nu\n  nu = Discr u\n\ngoal (1 subgoal):\n 1. Nat_case\\<cdot>z\\<cdot>s\\<cdot>(n + 1) = s\\<cdot>n", "unfolding one_Nat_def"], ["proof (prove)\nusing this:\n  n = box\\<cdot>nu\n  nu = Discr u\n\ngoal (1 subgoal):\n 1. Nat_case\\<cdot>z\\<cdot>s\\<cdot>(n + box\\<cdot>1) = s\\<cdot>n", "by simp"], ["proof (state)\nthis:\n  Nat_case\\<cdot>z\\<cdot>s\\<cdot>(n + 1) = s\\<cdot>n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Nat_case_case_nat: \"Nat_case\\<cdot>z\\<cdot>s\\<cdot>(box\\<cdot>(Discr n)) = case_nat z (\\<lambda>n'. s\\<cdot>(box\\<cdot>(Discr n'))) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Nat_case\\<cdot>z\\<cdot>s\\<cdot>(box\\<cdot>(Discr n)) =\n    (case n of 0 \\<Rightarrow> z\n     | Suc n' \\<Rightarrow> s\\<cdot>(box\\<cdot>(Discr n')))", "by (simp add: Nat_case_def)"], ["", "lemma Nat_casedist[case_names bottom zero Suc]:\n  fixes x :: Nat\n  assumes xbot: \"x = \\<bottom> \\<Longrightarrow> P\"\n      and xzero: \"x = 0 \\<Longrightarrow> P\"\n      and xsuc: \"\\<And>n. x = n + 1 \\<Longrightarrow> P\"\n  shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof(cases x rule: Box.exhaust)"], ["proof (state)\ngoal (2 subgoals):\n 1. x = \\<bottom> \\<Longrightarrow> P\n 2. \\<And>u.\n       \\<lbrakk>x = Box\\<cdot>u; u \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> P", "case bottom"], ["proof (state)\nthis:\n  x = \\<bottom>\n\ngoal (2 subgoals):\n 1. x = \\<bottom> \\<Longrightarrow> P\n 2. \\<And>u.\n       \\<lbrakk>x = Box\\<cdot>u; u \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> P", "with xbot"], ["proof (chain)\npicking this:\n  x = \\<bottom> \\<Longrightarrow> P\n  x = \\<bottom>", "show ?thesis"], ["proof (prove)\nusing this:\n  x = \\<bottom> \\<Longrightarrow> P\n  x = \\<bottom>\n\ngoal (1 subgoal):\n 1. P", "by simp"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>x = Box\\<cdot>u; u \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>x = Box\\<cdot>u; u \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> P", "case (Box u)"], ["proof (state)\nthis:\n  x = Box\\<cdot>u\n  u \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>x = Box\\<cdot>u; u \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> P", "hence xu: \"x = Box\\<cdot>u\" and ubottom: \"u \\<noteq> \\<bottom>\""], ["proof (prove)\nusing this:\n  x = Box\\<cdot>u\n  u \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. x = Box\\<cdot>u &&& u \\<noteq> \\<bottom>", "."], ["proof (state)\nthis:\n  x = Box\\<cdot>u\n  u \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>x = Box\\<cdot>u; u \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> P", "from ubottom"], ["proof (chain)\npicking this:\n  u \\<noteq> \\<bottom>", "obtain n where ndn: \"u = up\\<cdot>(Discr n)\""], ["proof (prove)\nusing this:\n  u \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        u = up\\<cdot>(Discr n) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (cases u)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>n. u = up\\<cdot>(Discr n) \\<Longrightarrow> thesis;\n     u \\<noteq> \\<bottom>; u = \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>x.\n       \\<lbrakk>\\<And>n. u = up\\<cdot>(Discr n) \\<Longrightarrow> thesis;\n        u \\<noteq> \\<bottom>; u = up\\<cdot>x\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>n. x = Discr n \\<Longrightarrow> thesis;\n        u = up\\<cdot>x\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (case_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<And>n. x = Discr n \\<Longrightarrow> thesis;\n        u = up\\<cdot>x; x = Discr xa\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  u = up\\<cdot>(Discr n)\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>x = Box\\<cdot>u; u \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> P", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof(cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> P\n 2. \\<And>nat. n = Suc nat \\<Longrightarrow> P", "case 0"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> P\n 2. \\<And>nat. n = Suc nat \\<Longrightarrow> P", "with ndn xu xzero"], ["proof (chain)\npicking this:\n  u = up\\<cdot>(Discr n)\n  x = Box\\<cdot>u\n  x = 0 \\<Longrightarrow> P\n  n = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  u = up\\<cdot>(Discr n)\n  x = Box\\<cdot>u\n  x = 0 \\<Longrightarrow> P\n  n = 0\n\ngoal (1 subgoal):\n 1. P", "unfolding zero_Nat_def"], ["proof (prove)\nusing this:\n  u = up\\<cdot>(Discr n)\n  x = Box\\<cdot>u\n  x = box\\<cdot>0 \\<Longrightarrow> P\n  n = 0\n\ngoal (1 subgoal):\n 1. P", "by (simp add: boxI zero_discr_def)"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. \\<And>nat. n = Suc nat \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. n = Suc nat \\<Longrightarrow> P", "case (Suc m)"], ["proof (state)\nthis:\n  n = Suc m\n\ngoal (1 subgoal):\n 1. \\<And>nat. n = Suc nat \\<Longrightarrow> P", "with ndn xu xsuc[where n=\"box\\<cdot>(Discr m)\"]"], ["proof (chain)\npicking this:\n  u = up\\<cdot>(Discr n)\n  x = Box\\<cdot>u\n  x = box\\<cdot>(Discr m) + 1 \\<Longrightarrow> P\n  n = Suc m", "show ?thesis"], ["proof (prove)\nusing this:\n  u = up\\<cdot>(Discr n)\n  x = Box\\<cdot>u\n  x = box\\<cdot>(Discr m) + 1 \\<Longrightarrow> P\n  n = Suc m\n\ngoal (1 subgoal):\n 1. P", "unfolding plus_Box_def"], ["proof (prove)\nusing this:\n  u = up\\<cdot>(Discr n)\n  x = Box\\<cdot>u\n  x =\n  bliftM2 (\\<Lambda> a b. a + b)\\<cdot>(box\\<cdot>(Discr m))\\<cdot>\n  1 \\<Longrightarrow>\n  P\n  n = Suc m\n\ngoal (1 subgoal):\n 1. P", "unfolding one_Nat_def"], ["proof (prove)\nusing this:\n  u = up\\<cdot>(Discr n)\n  x = Box\\<cdot>u\n  x =\n  bliftM2 (\\<Lambda> a b. a + b)\\<cdot>(box\\<cdot>(Discr m))\\<cdot>\n  (box\\<cdot>1) \\<Longrightarrow>\n  P\n  n = Suc m\n\ngoal (1 subgoal):\n 1. P", "by (simp add: boxI one_discr_def)"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cont_Nat_case[simp]:\n  \"\\<lbrakk>cont (\\<lambda>x. f x); \\<And>n. cont (\\<lambda>x. g x\\<cdot>n) \\<rbrakk> \\<Longrightarrow> cont (\\<lambda>x. Nat_case\\<cdot>(f x)\\<cdot>(g x)\\<cdot>n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cont f; \\<And>n. cont (\\<lambda>x. g x\\<cdot>n)\\<rbrakk>\n    \\<Longrightarrow> cont\n                       (\\<lambda>x.\n                           Nat_case\\<cdot>(f x)\\<cdot>(g x)\\<cdot>n)", "apply (cases n rule: Nat_casedist)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>cont f; \\<And>n. cont (\\<lambda>x. g x\\<cdot>n);\n     n = \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> cont\n                       (\\<lambda>x.\n                           Nat_case\\<cdot>(f x)\\<cdot>(g x)\\<cdot>n)\n 2. \\<lbrakk>cont f; \\<And>n. cont (\\<lambda>x. g x\\<cdot>n); n = 0\\<rbrakk>\n    \\<Longrightarrow> cont\n                       (\\<lambda>x.\n                           Nat_case\\<cdot>(f x)\\<cdot>(g x)\\<cdot>n)\n 3. \\<And>na.\n       \\<lbrakk>cont f; \\<And>n. cont (\\<lambda>x. g x\\<cdot>n);\n        n = na + 1\\<rbrakk>\n       \\<Longrightarrow> cont\n                          (\\<lambda>x.\n                              Nat_case\\<cdot>(f x)\\<cdot>(g x)\\<cdot>n)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>cont f; \\<And>n. cont (\\<lambda>x. g x\\<cdot>n);\n        n = na + 1\\<rbrakk>\n       \\<Longrightarrow> cont\n                          (\\<lambda>x.\n                              Nat_case\\<cdot>(f x)\\<cdot>(g x)\\<cdot>\n                              (na + 1))", "apply (case_tac na rule: Box.exhaust)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>na.\n       \\<lbrakk>cont f; \\<And>n. cont (\\<lambda>x. g x\\<cdot>n); n = na + 1;\n        na = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> cont\n                          (\\<lambda>x.\n                              Nat_case\\<cdot>(f x)\\<cdot>(g x)\\<cdot>\n                              (na + 1))\n 2. \\<And>na u.\n       \\<lbrakk>cont f; \\<And>n. cont (\\<lambda>x. g x\\<cdot>n); n = na + 1;\n        na = Box\\<cdot>u; u \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> cont\n                          (\\<lambda>x.\n                              Nat_case\\<cdot>(f x)\\<cdot>(g x)\\<cdot>\n                              (na + 1))", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Nat_induct[case_names bottom zero Suc]:\n  fixes P :: \"Nat \\<Rightarrow> bool\"\n  assumes xbot: \"P \\<bottom>\"\n      and xzero: \"P 0\"\n      and xsuc: \"\\<And>n. \\<lbrakk>n \\<noteq> \\<bottom>; P n \\<rbrakk> \\<Longrightarrow> P (n + 1)\"\n  shows \"P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x", "proof(cases x rule: box_casedist)"], ["proof (state)\ngoal (2 subgoals):\n 1. x = \\<bottom> \\<Longrightarrow> P x\n 2. \\<And>u. x = box\\<cdot>u \\<Longrightarrow> P x", "case bottom"], ["proof (state)\nthis:\n  x = \\<bottom>\n\ngoal (2 subgoals):\n 1. x = \\<bottom> \\<Longrightarrow> P x\n 2. \\<And>u. x = box\\<cdot>u \\<Longrightarrow> P x", "with xbot"], ["proof (chain)\npicking this:\n  P \\<bottom>\n  x = \\<bottom>", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<bottom>\n  x = \\<bottom>\n\ngoal (1 subgoal):\n 1. P x", "by simp"], ["proof (state)\nthis:\n  P x\n\ngoal (1 subgoal):\n 1. \\<And>u. x = box\\<cdot>u \\<Longrightarrow> P x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u. x = box\\<cdot>u \\<Longrightarrow> P x", "case (Box u)"], ["proof (state)\nthis:\n  x = box\\<cdot>u\n\ngoal (1 subgoal):\n 1. \\<And>u. x = box\\<cdot>u \\<Longrightarrow> P x", "then"], ["proof (chain)\npicking this:\n  x = box\\<cdot>u", "obtain n where un: \"u = Discr n\""], ["proof (prove)\nusing this:\n  x = box\\<cdot>u\n\ngoal (1 subgoal):\n 1. (\\<And>n. u = Discr n \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases u, simp)"], ["proof (state)\nthis:\n  u = Discr n\n\ngoal (1 subgoal):\n 1. \\<And>u. x = box\\<cdot>u \\<Longrightarrow> P x", "{"], ["proof (state)\nthis:\n  u = Discr n\n\ngoal (1 subgoal):\n 1. \\<And>u. x = box\\<cdot>u \\<Longrightarrow> P x", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u. x = box\\<cdot>u \\<Longrightarrow> P x", "have \"\\<And>x. x = box\\<cdot>(Discr n) \\<Longrightarrow> P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x = box\\<cdot>(Discr n) \\<Longrightarrow> P x", "proof(induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x = box\\<cdot>(Discr 0) \\<Longrightarrow> P x\n 2. \\<And>n x.\n       \\<lbrakk>\\<And>x. x = box\\<cdot>(Discr n) \\<Longrightarrow> P x;\n        x = box\\<cdot>(Discr (Suc n))\\<rbrakk>\n       \\<Longrightarrow> P x", "case 0"], ["proof (state)\nthis:\n  x = box\\<cdot>(Discr 0)\n\ngoal (2 subgoals):\n 1. \\<And>x. x = box\\<cdot>(Discr 0) \\<Longrightarrow> P x\n 2. \\<And>n x.\n       \\<lbrakk>\\<And>x. x = box\\<cdot>(Discr n) \\<Longrightarrow> P x;\n        x = box\\<cdot>(Discr (Suc n))\\<rbrakk>\n       \\<Longrightarrow> P x", "with xzero"], ["proof (chain)\npicking this:\n  P 0\n  x = box\\<cdot>(Discr 0)", "show ?case"], ["proof (prove)\nusing this:\n  P 0\n  x = box\\<cdot>(Discr 0)\n\ngoal (1 subgoal):\n 1. P x", "unfolding zero_Nat_def zero_discr_def"], ["proof (prove)\nusing this:\n  P (box\\<cdot>(Discr 0))\n  x = box\\<cdot>(Discr 0)\n\ngoal (1 subgoal):\n 1. P x", "by simp"], ["proof (state)\nthis:\n  P x\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       \\<lbrakk>\\<And>x. x = box\\<cdot>(Discr n) \\<Longrightarrow> P x;\n        x = box\\<cdot>(Discr (Suc n))\\<rbrakk>\n       \\<Longrightarrow> P x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n x.\n       \\<lbrakk>\\<And>x. x = box\\<cdot>(Discr n) \\<Longrightarrow> P x;\n        x = box\\<cdot>(Discr (Suc n))\\<rbrakk>\n       \\<Longrightarrow> P x", "case (Suc n)"], ["proof (state)\nthis:\n  ?x = box\\<cdot>(Discr n) \\<Longrightarrow> P ?x\n  x = box\\<cdot>(Discr (Suc n))\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       \\<lbrakk>\\<And>x. x = box\\<cdot>(Discr n) \\<Longrightarrow> P x;\n        x = box\\<cdot>(Discr (Suc n))\\<rbrakk>\n       \\<Longrightarrow> P x", "hence \"P (box\\<cdot>(Discr n))\""], ["proof (prove)\nusing this:\n  ?x = box\\<cdot>(Discr n) \\<Longrightarrow> P ?x\n  x = box\\<cdot>(Discr (Suc n))\n\ngoal (1 subgoal):\n 1. P (box\\<cdot>(Discr n))", "by simp"], ["proof (state)\nthis:\n  P (box\\<cdot>(Discr n))\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       \\<lbrakk>\\<And>x. x = box\\<cdot>(Discr n) \\<Longrightarrow> P x;\n        x = box\\<cdot>(Discr (Suc n))\\<rbrakk>\n       \\<Longrightarrow> P x", "with xsuc[where n=\"box\\<cdot>(Discr n)\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>box\\<cdot>(Discr n) \\<noteq> \\<bottom>;\n   P (box\\<cdot>(Discr n))\\<rbrakk>\n  \\<Longrightarrow> P (box\\<cdot>(Discr n) + 1)\n  P (box\\<cdot>(Discr n))", "have \"P (box\\<cdot>(Discr n) + 1)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>box\\<cdot>(Discr n) \\<noteq> \\<bottom>;\n   P (box\\<cdot>(Discr n))\\<rbrakk>\n  \\<Longrightarrow> P (box\\<cdot>(Discr n) + 1)\n  P (box\\<cdot>(Discr n))\n\ngoal (1 subgoal):\n 1. P (box\\<cdot>(Discr n) + 1)", "unfolding box_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>(Box oo up)\\<cdot>(Discr n) \\<noteq> \\<bottom>;\n   P ((Box oo up)\\<cdot>(Discr n))\\<rbrakk>\n  \\<Longrightarrow> P ((Box oo up)\\<cdot>(Discr n) + 1)\n  P ((Box oo up)\\<cdot>(Discr n))\n\ngoal (1 subgoal):\n 1. P ((Box oo up)\\<cdot>(Discr n) + 1)", "by simp"], ["proof (state)\nthis:\n  P (box\\<cdot>(Discr n) + 1)\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       \\<lbrakk>\\<And>x. x = box\\<cdot>(Discr n) \\<Longrightarrow> P x;\n        x = box\\<cdot>(Discr (Suc n))\\<rbrakk>\n       \\<Longrightarrow> P x", "with Suc"], ["proof (chain)\npicking this:\n  ?x = box\\<cdot>(Discr n) \\<Longrightarrow> P ?x\n  x = box\\<cdot>(Discr (Suc n))\n  P (box\\<cdot>(Discr n) + 1)", "show ?case"], ["proof (prove)\nusing this:\n  ?x = box\\<cdot>(Discr n) \\<Longrightarrow> P ?x\n  x = box\\<cdot>(Discr (Suc n))\n  P (box\\<cdot>(Discr n) + 1)\n\ngoal (1 subgoal):\n 1. P x", "unfolding one_Nat_def one_discr_def plus_Box_def"], ["proof (prove)\nusing this:\n  ?x = box\\<cdot>(Discr n) \\<Longrightarrow> P ?x\n  x = box\\<cdot>(Discr (Suc n))\n  P (bliftM2 (\\<Lambda> a b. a + b)\\<cdot>(box\\<cdot>(Discr n))\\<cdot>\n     (box\\<cdot>(Discr 1)))\n\ngoal (1 subgoal):\n 1. P x", "by simp"], ["proof (state)\nthis:\n  P x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x = box\\<cdot>(Discr n) \\<Longrightarrow> P ?x\n\ngoal (1 subgoal):\n 1. \\<And>u. x = box\\<cdot>u \\<Longrightarrow> P x", "}"], ["proof (state)\nthis:\n  ?x = box\\<cdot>(Discr ?na3) \\<Longrightarrow> P ?x\n\ngoal (1 subgoal):\n 1. \\<And>u. x = box\\<cdot>u \\<Longrightarrow> P x", "with un Box"], ["proof (chain)\npicking this:\n  u = Discr n\n  x = box\\<cdot>u\n  ?x = box\\<cdot>(Discr ?na3) \\<Longrightarrow> P ?x", "show ?thesis"], ["proof (prove)\nusing this:\n  u = Discr n\n  x = box\\<cdot>u\n  ?x = box\\<cdot>(Discr ?na3) \\<Longrightarrow> P ?x\n\ngoal (1 subgoal):\n 1. P x", "by simp"], ["proof (state)\nthis:\n  P x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma plus_commute: \"(x :: Nat) + y = y + x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y = y + x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x + y = y + x", "have dc: \"\\<And>u v. (undiscr (u::nat discr) + undiscr v) = (undiscr v + undiscr u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u v. undiscr u + undiscr v = undiscr v + undiscr u", "by simp"], ["proof (state)\nthis:\n  undiscr ?u + undiscr ?v = undiscr ?v + undiscr ?u\n\ngoal (1 subgoal):\n 1. x + y = y + x", "thus ?thesis"], ["proof (prove)\nusing this:\n  undiscr ?u + undiscr ?v = undiscr ?v + undiscr ?u\n\ngoal (1 subgoal):\n 1. x + y = y + x", "apply (cases x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>u v. undiscr u + undiscr v = undiscr v + undiscr u;\n     x = \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> x + y = y + x\n 2. \\<And>u.\n       \\<lbrakk>\\<And>u v. undiscr u + undiscr v = undiscr v + undiscr u;\n        x = box\\<cdot>u\\<rbrakk>\n       \\<Longrightarrow> x + y = y + x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>\\<And>u v. undiscr u + undiscr v = undiscr v + undiscr u;\n        x = box\\<cdot>u\\<rbrakk>\n       \\<Longrightarrow> x + y = y + x", "apply (cases y)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>\\<And>u v. undiscr u + undiscr v = undiscr v + undiscr u;\n        x = box\\<cdot>u; y = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> x + y = y + x\n 2. \\<And>u ua.\n       \\<lbrakk>\\<And>u v. undiscr u + undiscr v = undiscr v + undiscr u;\n        x = box\\<cdot>u; y = box\\<cdot>ua\\<rbrakk>\n       \\<Longrightarrow> x + y = y + x", "by (simp_all add: dc plus_Box_def)"], ["proof (state)\nthis:\n  x + y = y + x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mult_unit: \"(x::Nat) * 1 = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * 1 = x", "unfolding times_Box_def one_Nat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bliftM2 (\\<Lambda> a b. a * b)\\<cdot>x\\<cdot>(box\\<cdot>1) = x", "by (cases x, simp_all)"], ["", "lemma mult_commute: \"(x :: Nat) * y = y * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y = y * x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x * y = y * x", "have dc: \"\\<And>u v. (undiscr (u::nat discr) * undiscr v) = (undiscr v * undiscr u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u v. undiscr u * undiscr v = undiscr v * undiscr u", "by simp"], ["proof (state)\nthis:\n  undiscr ?u * undiscr ?v = undiscr ?v * undiscr ?u\n\ngoal (1 subgoal):\n 1. x * y = y * x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y = y * x", "apply (cases x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x = \\<bottom> \\<Longrightarrow> x * y = y * x\n 2. \\<And>u. x = box\\<cdot>u \\<Longrightarrow> x * y = y * x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u. x = box\\<cdot>u \\<Longrightarrow> x * y = y * x", "apply (cases y)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>x = box\\<cdot>u; y = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> x * y = y * x\n 2. \\<And>u ua.\n       \\<lbrakk>x = box\\<cdot>u; y = box\\<cdot>ua\\<rbrakk>\n       \\<Longrightarrow> x * y = y * x", "by (simp_all add: dc)"], ["proof (state)\nthis:\n  x * y = y * x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mult_assoc: \"((x :: Nat) * y) * z = x * (y * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y * z = x * (y * z)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x * y * z = x * (y * z)", "have ac: \"\\<And>u v w. undiscr (u::nat discr) * (undiscr v * undiscr w)\n                   =  (undiscr u * undiscr v) * undiscr w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u v w.\n       undiscr u * (undiscr v * undiscr w) =\n       undiscr u * undiscr v * undiscr w", "by simp"], ["proof (state)\nthis:\n  undiscr ?u * (undiscr ?v * undiscr ?w) =\n  undiscr ?u * undiscr ?v * undiscr ?w\n\ngoal (1 subgoal):\n 1. x * y * z = x * (y * z)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y * z = x * (y * z)", "apply (cases x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x = \\<bottom> \\<Longrightarrow> x * y * z = x * (y * z)\n 2. \\<And>u. x = box\\<cdot>u \\<Longrightarrow> x * y * z = x * (y * z)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u. x = box\\<cdot>u \\<Longrightarrow> x * y * z = x * (y * z)", "apply (cases y)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>x = box\\<cdot>u; y = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> x * y * z = x * (y * z)\n 2. \\<And>u ua.\n       \\<lbrakk>x = box\\<cdot>u; y = box\\<cdot>ua\\<rbrakk>\n       \\<Longrightarrow> x * y * z = x * (y * z)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u ua.\n       \\<lbrakk>x = box\\<cdot>u; y = box\\<cdot>ua\\<rbrakk>\n       \\<Longrightarrow> x * y * z = x * (y * z)", "apply (cases z)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u ua.\n       \\<lbrakk>x = box\\<cdot>u; y = box\\<cdot>ua; z = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> x * y * z = x * (y * z)\n 2. \\<And>u ua ub.\n       \\<lbrakk>x = box\\<cdot>u; y = box\\<cdot>ua; z = box\\<cdot>ub\\<rbrakk>\n       \\<Longrightarrow> x * y * z = x * (y * z)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u ua ub.\n       \\<lbrakk>x = box\\<cdot>u; y = box\\<cdot>ua; z = box\\<cdot>ub\\<rbrakk>\n       \\<Longrightarrow> x * y * z = x * (y * z)", "by (simp add: ac)"], ["proof (state)\nthis:\n  x * y * z = x * (y * z)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Restore the HOLCF default sort.\\<close>"], ["", "default_sort \"domain\""], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}