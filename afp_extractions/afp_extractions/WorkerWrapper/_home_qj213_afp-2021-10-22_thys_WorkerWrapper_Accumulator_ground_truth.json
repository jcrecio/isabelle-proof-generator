{"file_name": "/home/qj213/afp-2021-10-22/thys/WorkerWrapper/Accumulator.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/WorkerWrapper", "problem_names": ["lemma acc_c2a_strict[simp]: \"list2H\\<cdot>\\<bottom> = \\<bottom>\"", "lemma H_llist_hom_append: \"list2H\\<cdot>(xs :++ ys) = list2H\\<cdot>xs oo list2H\\<cdot>ys\" (is \"?lhs = ?rhs\")", "lemma H_llist_hom_id: \"list2H\\<cdot>lnil = ID\"", "lemma H2list_list2H_inv: \"H2list oo list2H = ID\"", "lemma lrev_strict[simp]: \"lrev\\<cdot>\\<bottom> = \\<bottom>\"", "lemma lrev_body_strict[simp]: \"lrev_body\\<cdot>r\\<cdot>\\<bottom> = \\<bottom>\"", "lemma lrev_lrev_body_eq: \"lrev = fix\\<cdot>lrev_body\"", "lemma unwrapH_strict[simp]: \"unwrapH\\<cdot>\\<bottom> = \\<bottom>\"", "lemma wrapH_unwrapH_id: \"wrapH oo unwrapH = ID\" (is \"?lhs = ?rhs\")", "lemma lrev_lrev_ww_eq: \"lrev = lrev_wrap\"", "lemma lrev_body_lrev_body1_eq: \"lrev_body1 = unwrapH oo lrev_body oo wrapH\"", "lemma lrev_work1_lrev_work_eq: \"lrev_work1 = lrev_work\"", "lemma lrev_body2_strict[simp]: \"lrev_body2\\<cdot>r\\<cdot>\\<bottom> = \\<bottom>\"", "lemma lrev_work2_strict[simp]: \"lrev_work2\\<cdot>\\<bottom> = \\<bottom>\"", "lemma lrev_body2_lrev_body1_eq: \"lrev_body2 = lrev_body1\"", "lemma lrev_work2_lrev_work1_eq: \"lrev_work2 = lrev_work1\"", "lemma lrev_body3_strict[simp]: \"lrev_body3\\<cdot>r\\<cdot>\\<bottom> = \\<bottom>\"", "lemma lrev_wwfusion: \"list2H\\<cdot>((wrapH\\<cdot>lrev_work2)\\<cdot>xs) = lrev_work2\\<cdot>xs\"", "lemma \"lrev_work3 \\<sqsubseteq> lrev_work2\"", "lemma lrev_work3_lrev_work2_eq: \"lrev_work3 = lrev_work2\" (is \"?lhs = ?rhs\")", "lemma lrev3_2_syntactic: \"lrev_body3 oo (unwrapH oo wrapH) = lrev_body2\"", "lemma lrev_work3_lrev_work2_eq': \"lrev = wrapH\\<cdot>lrev_work3\"", "lemma lrev_body_final_lrev_body3_eq': \"lrev_body_final\\<cdot>r\\<cdot>xs = lrev_body3\\<cdot>r\\<cdot>xs\"", "lemma lrev_body_final_lrev_body3_eq: \"lrev_body_final = lrev_body3\"", "lemma lrev_final_lrev_eq: \"lrev = lrev_final\" (is \"?lhs = ?rhs\")"], "translations": [["", "lemma acc_c2a_strict[simp]: \"list2H\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list2H\\<cdot>\\<bottom> = \\<bottom>", "by (rule cfun_eqI, simp add: list2H_def)"], ["", "definition\n  H2list :: \"'a H \\<rightarrow> 'a llist\" where\n  \"H2list \\<equiv> \\<Lambda> f . f\\<cdot>lnil\""], ["", "text\\<open>The paper only claims the homomorphism holds for finite lists,\nbut in fact it holds for all lazy lists in HOLCF. They are trying to\ndodge an explicit appeal to the equation @{thm \"inst_cfun_pcpo\"},\nwhich does not hold in Haskell.\\<close>"], ["", "lemma H_llist_hom_append: \"list2H\\<cdot>(xs :++ ys) = list2H\\<cdot>xs oo list2H\\<cdot>ys\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. list2H\\<cdot>(xs :++ ys) = list2H\\<cdot>xs oo list2H\\<cdot>ys", "proof(rule cfun_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       list2H\\<cdot>(xs :++ ys)\\<cdot>x =\n       (list2H\\<cdot>xs oo list2H\\<cdot>ys)\\<cdot>x", "fix zs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       list2H\\<cdot>(xs :++ ys)\\<cdot>x =\n       (list2H\\<cdot>xs oo list2H\\<cdot>ys)\\<cdot>x", "have \"?lhs\\<cdot>zs = (xs :++ ys) :++ zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list2H\\<cdot>(xs :++ ys)\\<cdot>zs = (xs :++ ys) :++ zs", "by (simp add: list2H_def)"], ["proof (state)\nthis:\n  list2H\\<cdot>(xs :++ ys)\\<cdot>zs = (xs :++ ys) :++ zs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       list2H\\<cdot>(xs :++ ys)\\<cdot>x =\n       (list2H\\<cdot>xs oo list2H\\<cdot>ys)\\<cdot>x", "also"], ["proof (state)\nthis:\n  list2H\\<cdot>(xs :++ ys)\\<cdot>zs = (xs :++ ys) :++ zs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       list2H\\<cdot>(xs :++ ys)\\<cdot>x =\n       (list2H\\<cdot>xs oo list2H\\<cdot>ys)\\<cdot>x", "have \"\\<dots> = xs :++ (ys :++ zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs :++ ys) :++ zs = xs :++ ys :++ zs", "by (rule lappend_assoc)"], ["proof (state)\nthis:\n  (xs :++ ys) :++ zs = xs :++ ys :++ zs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       list2H\\<cdot>(xs :++ ys)\\<cdot>x =\n       (list2H\\<cdot>xs oo list2H\\<cdot>ys)\\<cdot>x", "also"], ["proof (state)\nthis:\n  (xs :++ ys) :++ zs = xs :++ ys :++ zs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       list2H\\<cdot>(xs :++ ys)\\<cdot>x =\n       (list2H\\<cdot>xs oo list2H\\<cdot>ys)\\<cdot>x", "have \"\\<dots> = list2H\\<cdot>xs\\<cdot>(ys :++ zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs :++ ys :++ zs = list2H\\<cdot>xs\\<cdot>(ys :++ zs)", "by (simp add: list2H_def)"], ["proof (state)\nthis:\n  xs :++ ys :++ zs = list2H\\<cdot>xs\\<cdot>(ys :++ zs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       list2H\\<cdot>(xs :++ ys)\\<cdot>x =\n       (list2H\\<cdot>xs oo list2H\\<cdot>ys)\\<cdot>x", "also"], ["proof (state)\nthis:\n  xs :++ ys :++ zs = list2H\\<cdot>xs\\<cdot>(ys :++ zs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       list2H\\<cdot>(xs :++ ys)\\<cdot>x =\n       (list2H\\<cdot>xs oo list2H\\<cdot>ys)\\<cdot>x", "have \"\\<dots> = list2H\\<cdot>xs\\<cdot>(list2H\\<cdot>ys\\<cdot>zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list2H\\<cdot>xs\\<cdot>(ys :++ zs) =\n    list2H\\<cdot>xs\\<cdot>(list2H\\<cdot>ys\\<cdot>zs)", "by (simp add: list2H_def)"], ["proof (state)\nthis:\n  list2H\\<cdot>xs\\<cdot>(ys :++ zs) =\n  list2H\\<cdot>xs\\<cdot>(list2H\\<cdot>ys\\<cdot>zs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       list2H\\<cdot>(xs :++ ys)\\<cdot>x =\n       (list2H\\<cdot>xs oo list2H\\<cdot>ys)\\<cdot>x", "also"], ["proof (state)\nthis:\n  list2H\\<cdot>xs\\<cdot>(ys :++ zs) =\n  list2H\\<cdot>xs\\<cdot>(list2H\\<cdot>ys\\<cdot>zs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       list2H\\<cdot>(xs :++ ys)\\<cdot>x =\n       (list2H\\<cdot>xs oo list2H\\<cdot>ys)\\<cdot>x", "have \"\\<dots> = (list2H\\<cdot>xs oo list2H\\<cdot>ys)\\<cdot>zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list2H\\<cdot>xs\\<cdot>(list2H\\<cdot>ys\\<cdot>zs) =\n    (list2H\\<cdot>xs oo list2H\\<cdot>ys)\\<cdot>zs", "by simp"], ["proof (state)\nthis:\n  list2H\\<cdot>xs\\<cdot>(list2H\\<cdot>ys\\<cdot>zs) =\n  (list2H\\<cdot>xs oo list2H\\<cdot>ys)\\<cdot>zs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       list2H\\<cdot>(xs :++ ys)\\<cdot>x =\n       (list2H\\<cdot>xs oo list2H\\<cdot>ys)\\<cdot>x", "finally"], ["proof (chain)\npicking this:\n  list2H\\<cdot>(xs :++ ys)\\<cdot>zs =\n  (list2H\\<cdot>xs oo list2H\\<cdot>ys)\\<cdot>zs", "show \"?lhs\\<cdot>zs = (list2H\\<cdot>xs oo list2H\\<cdot>ys)\\<cdot>zs\""], ["proof (prove)\nusing this:\n  list2H\\<cdot>(xs :++ ys)\\<cdot>zs =\n  (list2H\\<cdot>xs oo list2H\\<cdot>ys)\\<cdot>zs\n\ngoal (1 subgoal):\n 1. list2H\\<cdot>(xs :++ ys)\\<cdot>zs =\n    (list2H\\<cdot>xs oo list2H\\<cdot>ys)\\<cdot>zs", "."], ["proof (state)\nthis:\n  list2H\\<cdot>(xs :++ ys)\\<cdot>zs =\n  (list2H\\<cdot>xs oo list2H\\<cdot>ys)\\<cdot>zs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma H_llist_hom_id: \"list2H\\<cdot>lnil = ID\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list2H\\<cdot>lnil = ID", "by (simp add: list2H_def)"], ["", "lemma H2list_list2H_inv: \"H2list oo list2H = ID\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H2list oo list2H = ID", "by (rule cfun_eqI, simp add: H2list_def list2H_def)"], ["", "text\\<open>\\citet[\\S4.2]{GillHutton:2009} define the naive reverse\nfunction as follows.\\<close>"], ["", "fixrec lrev :: \"'a llist \\<rightarrow> 'a llist\"\nwhere\n  \"lrev\\<cdot>lnil = lnil\"\n| \"lrev\\<cdot>(x :@ xs) = lrev\\<cdot>xs :++ (x :@ lnil)\""], ["", "text\\<open>Note ``body'' is the generator of @{term \"lrev_def\"}.\\<close>"], ["", "lemma lrev_strict[simp]: \"lrev\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lrev\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "fixrec lrev_body :: \"('a llist \\<rightarrow> 'a llist) \\<rightarrow> 'a llist \\<rightarrow> 'a llist\"\nwhere\n  \"lrev_body\\<cdot>r\\<cdot>lnil = lnil\"\n| \"lrev_body\\<cdot>r\\<cdot>(x :@ xs) = r\\<cdot>xs :++ (x :@ lnil)\""], ["", "lemma lrev_body_strict[simp]: \"lrev_body\\<cdot>r\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lrev_body\\<cdot>r\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "text\\<open>This is trivial but syntactically a bit touchy. Would be nicer\nto define @{term \"lrev_body\"} as the generator of the fixpoint\ndefinition of @{term \"lrev\"} directly.\\<close>"], ["", "lemma lrev_lrev_body_eq: \"lrev = fix\\<cdot>lrev_body\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lrev = fix\\<cdot>lrev_body", "by (rule cfun_eqI, subst lrev_def, subst lrev_body.unfold, simp)"], ["", "text\\<open>Wrap / unwrap functions.\\<close>"], ["", "definition\n  unwrapH :: \"('a llist \\<rightarrow> 'a llist) \\<rightarrow> 'a llist \\<rightarrow> 'a H\" where\n  \"unwrapH \\<equiv> \\<Lambda> f xs . list2H\\<cdot>(f\\<cdot>xs)\""], ["", "lemma unwrapH_strict[simp]: \"unwrapH\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unwrapH\\<cdot>\\<bottom> = \\<bottom>", "unfolding unwrapH_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> f xs. list2H\\<cdot>(f\\<cdot>xs))\\<cdot>\\<bottom> = \\<bottom>", "by (rule cfun_eqI, simp)"], ["", "definition\n  wrapH :: \"('a llist \\<rightarrow> 'a H) \\<rightarrow> 'a llist \\<rightarrow> 'a llist\" where\n  \"wrapH \\<equiv> \\<Lambda> f xs . H2list\\<cdot>(f\\<cdot>xs)\""], ["", "lemma wrapH_unwrapH_id: \"wrapH oo unwrapH = ID\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. wrapH oo unwrapH = ID", "proof(rule cfun_eqI)+"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. (wrapH oo unwrapH)\\<cdot>x\\<cdot>xa = ID\\<cdot>x\\<cdot>xa", "fix f xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. (wrapH oo unwrapH)\\<cdot>x\\<cdot>xa = ID\\<cdot>x\\<cdot>xa", "have \"?lhs\\<cdot>f\\<cdot>xs = H2list\\<cdot>(list2H\\<cdot>(f\\<cdot>xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (wrapH oo unwrapH)\\<cdot>f\\<cdot>xs =\n    H2list\\<cdot>(list2H\\<cdot>(f\\<cdot>xs))", "by (simp add: wrapH_def unwrapH_def)"], ["proof (state)\nthis:\n  (wrapH oo unwrapH)\\<cdot>f\\<cdot>xs =\n  H2list\\<cdot>(list2H\\<cdot>(f\\<cdot>xs))\n\ngoal (1 subgoal):\n 1. \\<And>x xa. (wrapH oo unwrapH)\\<cdot>x\\<cdot>xa = ID\\<cdot>x\\<cdot>xa", "also"], ["proof (state)\nthis:\n  (wrapH oo unwrapH)\\<cdot>f\\<cdot>xs =\n  H2list\\<cdot>(list2H\\<cdot>(f\\<cdot>xs))\n\ngoal (1 subgoal):\n 1. \\<And>x xa. (wrapH oo unwrapH)\\<cdot>x\\<cdot>xa = ID\\<cdot>x\\<cdot>xa", "have \"\\<dots> = (H2list oo list2H)\\<cdot>(f\\<cdot>xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H2list\\<cdot>(list2H\\<cdot>(f\\<cdot>xs)) =\n    (H2list oo list2H)\\<cdot>(f\\<cdot>xs)", "by simp"], ["proof (state)\nthis:\n  H2list\\<cdot>(list2H\\<cdot>(f\\<cdot>xs)) =\n  (H2list oo list2H)\\<cdot>(f\\<cdot>xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xa. (wrapH oo unwrapH)\\<cdot>x\\<cdot>xa = ID\\<cdot>x\\<cdot>xa", "also"], ["proof (state)\nthis:\n  H2list\\<cdot>(list2H\\<cdot>(f\\<cdot>xs)) =\n  (H2list oo list2H)\\<cdot>(f\\<cdot>xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xa. (wrapH oo unwrapH)\\<cdot>x\\<cdot>xa = ID\\<cdot>x\\<cdot>xa", "have \"\\<dots> = ID\\<cdot>(f\\<cdot>xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (H2list oo list2H)\\<cdot>(f\\<cdot>xs) = ID\\<cdot>(f\\<cdot>xs)", "by (simp only: H2list_list2H_inv)"], ["proof (state)\nthis:\n  (H2list oo list2H)\\<cdot>(f\\<cdot>xs) = ID\\<cdot>(f\\<cdot>xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xa. (wrapH oo unwrapH)\\<cdot>x\\<cdot>xa = ID\\<cdot>x\\<cdot>xa", "also"], ["proof (state)\nthis:\n  (H2list oo list2H)\\<cdot>(f\\<cdot>xs) = ID\\<cdot>(f\\<cdot>xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xa. (wrapH oo unwrapH)\\<cdot>x\\<cdot>xa = ID\\<cdot>x\\<cdot>xa", "have \"\\<dots> = ?rhs\\<cdot>f\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ID\\<cdot>(f\\<cdot>xs) = ID\\<cdot>f\\<cdot>xs", "by simp"], ["proof (state)\nthis:\n  ID\\<cdot>(f\\<cdot>xs) = ID\\<cdot>f\\<cdot>xs\n\ngoal (1 subgoal):\n 1. \\<And>x xa. (wrapH oo unwrapH)\\<cdot>x\\<cdot>xa = ID\\<cdot>x\\<cdot>xa", "finally"], ["proof (chain)\npicking this:\n  (wrapH oo unwrapH)\\<cdot>f\\<cdot>xs = ID\\<cdot>f\\<cdot>xs", "show \"?lhs\\<cdot>f\\<cdot>xs = ?rhs\\<cdot>f\\<cdot>xs\""], ["proof (prove)\nusing this:\n  (wrapH oo unwrapH)\\<cdot>f\\<cdot>xs = ID\\<cdot>f\\<cdot>xs\n\ngoal (1 subgoal):\n 1. (wrapH oo unwrapH)\\<cdot>f\\<cdot>xs = ID\\<cdot>f\\<cdot>xs", "."], ["proof (state)\nthis:\n  (wrapH oo unwrapH)\\<cdot>f\\<cdot>xs = ID\\<cdot>f\\<cdot>xs\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Gill/Hutton-style worker/wrapper.\\<close>"], ["", "definition\n  lrev_work :: \"'a llist \\<rightarrow> 'a H\" where\n  \"lrev_work \\<equiv> fix\\<cdot>(unwrapH oo lrev_body oo wrapH)\""], ["", "definition\n  lrev_wrap :: \"'a llist \\<rightarrow> 'a llist\" where\n  \"lrev_wrap \\<equiv> wrapH\\<cdot>lrev_work\""], ["", "lemma lrev_lrev_ww_eq: \"lrev = lrev_wrap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lrev = lrev_wrap", "using worker_wrapper_id[OF wrapH_unwrapH_id lrev_lrev_body_eq]"], ["proof (prove)\nusing this:\n  lrev = wrapH\\<cdot>(fix\\<cdot>(unwrapH oo lrev_body oo wrapH))\n\ngoal (1 subgoal):\n 1. lrev = lrev_wrap", "by (simp add: lrev_wrap_def lrev_work_def)"], ["", "subsection\\<open>Optimise worker/wrapper.\\<close>"], ["", "text\\<open>Intermediate worker.\\<close>"], ["", "fixrec lrev_body1 :: \"('a llist \\<rightarrow> 'a H) \\<rightarrow> 'a llist \\<rightarrow> 'a H\"\nwhere\n  \"lrev_body1\\<cdot>r\\<cdot>lnil = list2H\\<cdot>lnil\"\n| \"lrev_body1\\<cdot>r\\<cdot>(x :@ xs) = list2H\\<cdot>(wrapH\\<cdot>r\\<cdot>xs :++ (x :@ lnil))\""], ["", "definition\n  lrev_work1 :: \"'a llist \\<rightarrow> 'a H\" where\n  \"lrev_work1 \\<equiv> fix\\<cdot>lrev_body1\""], ["", "lemma lrev_body_lrev_body1_eq: \"lrev_body1 = unwrapH oo lrev_body oo wrapH\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lrev_body1 = unwrapH oo lrev_body oo wrapH", "apply (rule cfun_eqI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       lrev_body1\\<cdot>x\\<cdot>xa\\<cdot>xb =\n       (unwrapH oo lrev_body oo wrapH)\\<cdot>x\\<cdot>xa\\<cdot>xb", "apply (subst lrev_body.unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       lrev_body1\\<cdot>x\\<cdot>xa\\<cdot>xb =\n       (unwrapH oo\n        (\\<Lambda> r v.\n            Fixrec.run\\<cdot>\n            (match_lnil\\<cdot>v\\<cdot>(Fixrec.succeed\\<cdot>lnil) +++\n             match_lcons\\<cdot>v\\<cdot>\n             (\\<Lambda> x xs.\n                 Fixrec.succeed\\<cdot>(r\\<cdot>xs :++ x :@ lnil)))) oo\n        wrapH)\\<cdot>\n       x\\<cdot>\n       xa\\<cdot>\n       xb", "apply (subst lrev_body1.unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       (\\<Lambda> r v.\n           Fixrec.run\\<cdot>\n           (match_lnil\\<cdot>v\\<cdot>\n            (Fixrec.succeed\\<cdot>(list2H\\<cdot>lnil)) +++\n            match_lcons\\<cdot>v\\<cdot>\n            (\\<Lambda> x xs.\n                Fixrec.succeed\\<cdot>\n                (list2H\\<cdot>\n                 (wrapH\\<cdot>r\\<cdot>xs :++ x :@ lnil)))))\\<cdot>\n       x\\<cdot>\n       xa\\<cdot>\n       xb =\n       (unwrapH oo\n        (\\<Lambda> r v.\n            Fixrec.run\\<cdot>\n            (match_lnil\\<cdot>v\\<cdot>(Fixrec.succeed\\<cdot>lnil) +++\n             match_lcons\\<cdot>v\\<cdot>\n             (\\<Lambda> x xs.\n                 Fixrec.succeed\\<cdot>(r\\<cdot>xs :++ x :@ lnil)))) oo\n        wrapH)\\<cdot>\n       x\\<cdot>\n       xa\\<cdot>\n       xb", "apply (case_tac xa)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa xb.\n       xa = \\<bottom> \\<Longrightarrow>\n       (\\<Lambda> r v.\n           Fixrec.run\\<cdot>\n           (match_lnil\\<cdot>v\\<cdot>\n            (Fixrec.succeed\\<cdot>(list2H\\<cdot>lnil)) +++\n            match_lcons\\<cdot>v\\<cdot>\n            (\\<Lambda> x xs.\n                Fixrec.succeed\\<cdot>\n                (list2H\\<cdot>\n                 (wrapH\\<cdot>r\\<cdot>xs :++ x :@ lnil)))))\\<cdot>\n       x\\<cdot>\n       xa\\<cdot>\n       xb =\n       (unwrapH oo\n        (\\<Lambda> r v.\n            Fixrec.run\\<cdot>\n            (match_lnil\\<cdot>v\\<cdot>(Fixrec.succeed\\<cdot>lnil) +++\n             match_lcons\\<cdot>v\\<cdot>\n             (\\<Lambda> x xs.\n                 Fixrec.succeed\\<cdot>(r\\<cdot>xs :++ x :@ lnil)))) oo\n        wrapH)\\<cdot>\n       x\\<cdot>\n       xa\\<cdot>\n       xb\n 2. \\<And>x xa xb.\n       xa = lnil \\<Longrightarrow>\n       (\\<Lambda> r v.\n           Fixrec.run\\<cdot>\n           (match_lnil\\<cdot>v\\<cdot>\n            (Fixrec.succeed\\<cdot>(list2H\\<cdot>lnil)) +++\n            match_lcons\\<cdot>v\\<cdot>\n            (\\<Lambda> x xs.\n                Fixrec.succeed\\<cdot>\n                (list2H\\<cdot>\n                 (wrapH\\<cdot>r\\<cdot>xs :++ x :@ lnil)))))\\<cdot>\n       x\\<cdot>\n       xa\\<cdot>\n       xb =\n       (unwrapH oo\n        (\\<Lambda> r v.\n            Fixrec.run\\<cdot>\n            (match_lnil\\<cdot>v\\<cdot>(Fixrec.succeed\\<cdot>lnil) +++\n             match_lcons\\<cdot>v\\<cdot>\n             (\\<Lambda> x xs.\n                 Fixrec.succeed\\<cdot>(r\\<cdot>xs :++ x :@ lnil)))) oo\n        wrapH)\\<cdot>\n       x\\<cdot>\n       xa\\<cdot>\n       xb\n 3. \\<And>x xa xb a llist.\n       xa = a :@ llist \\<Longrightarrow>\n       (\\<Lambda> r v.\n           Fixrec.run\\<cdot>\n           (match_lnil\\<cdot>v\\<cdot>\n            (Fixrec.succeed\\<cdot>(list2H\\<cdot>lnil)) +++\n            match_lcons\\<cdot>v\\<cdot>\n            (\\<Lambda> x xs.\n                Fixrec.succeed\\<cdot>\n                (list2H\\<cdot>\n                 (wrapH\\<cdot>r\\<cdot>xs :++ x :@ lnil)))))\\<cdot>\n       x\\<cdot>\n       xa\\<cdot>\n       xb =\n       (unwrapH oo\n        (\\<Lambda> r v.\n            Fixrec.run\\<cdot>\n            (match_lnil\\<cdot>v\\<cdot>(Fixrec.succeed\\<cdot>lnil) +++\n             match_lcons\\<cdot>v\\<cdot>\n             (\\<Lambda> x xs.\n                 Fixrec.succeed\\<cdot>(r\\<cdot>xs :++ x :@ lnil)))) oo\n        wrapH)\\<cdot>\n       x\\<cdot>\n       xa\\<cdot>\n       xb", "apply (simp_all add: list2H_def wrapH_def unwrapH_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lrev_work1_lrev_work_eq: \"lrev_work1 = lrev_work\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lrev_work1 = lrev_work", "by (unfold lrev_work_def lrev_work1_def,\n      rule cfun_arg_cong[OF lrev_body_lrev_body1_eq])"], ["", "text\\<open>Now use the homomorphism.\\<close>"], ["", "fixrec lrev_body2 :: \"('a llist \\<rightarrow> 'a H) \\<rightarrow> 'a llist \\<rightarrow> 'a H\"\nwhere\n  \"lrev_body2\\<cdot>r\\<cdot>lnil = ID\"\n| \"lrev_body2\\<cdot>r\\<cdot>(x :@ xs) = list2H\\<cdot>(wrapH\\<cdot>r\\<cdot>xs) oo list2H\\<cdot>(x :@ lnil)\""], ["", "lemma lrev_body2_strict[simp]: \"lrev_body2\\<cdot>r\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lrev_body2\\<cdot>r\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "definition\n  lrev_work2 :: \"'a llist \\<rightarrow> 'a H\" where\n  \"lrev_work2 \\<equiv> fix\\<cdot>lrev_body2\""], ["", "lemma lrev_work2_strict[simp]: \"lrev_work2\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lrev_work2\\<cdot>\\<bottom> = \\<bottom>", "unfolding lrev_work2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fix\\<cdot>lrev_body2\\<cdot>\\<bottom> = \\<bottom>", "by (subst fix_eq) simp"], ["", "lemma lrev_body2_lrev_body1_eq: \"lrev_body2 = lrev_body1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lrev_body2 = lrev_body1", "by ((rule cfun_eqI)+\n     , (subst lrev_body1.unfold, subst lrev_body2.unfold)\n     , (simp add: H_llist_hom_append[symmetric] H_llist_hom_id))"], ["", "lemma lrev_work2_lrev_work1_eq: \"lrev_work2 = lrev_work1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lrev_work2 = lrev_work1", "by (unfold lrev_work2_def lrev_work1_def\n     , rule cfun_arg_cong[OF lrev_body2_lrev_body1_eq])"], ["", "text \\<open>Simplify.\\<close>"], ["", "fixrec lrev_body3 :: \"('a llist \\<rightarrow> 'a H) \\<rightarrow> 'a llist \\<rightarrow> 'a H\"\nwhere\n  \"lrev_body3\\<cdot>r\\<cdot>lnil = ID\"\n| \"lrev_body3\\<cdot>r\\<cdot>(x :@ xs) = r\\<cdot>xs oo list2H\\<cdot>(x :@ lnil)\""], ["", "lemma lrev_body3_strict[simp]: \"lrev_body3\\<cdot>r\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lrev_body3\\<cdot>r\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "definition\n  lrev_work3 :: \"'a llist \\<rightarrow> 'a H\" where\n  \"lrev_work3 \\<equiv> fix\\<cdot>lrev_body3\""], ["", "lemma lrev_wwfusion: \"list2H\\<cdot>((wrapH\\<cdot>lrev_work2)\\<cdot>xs) = lrev_work2\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list2H\\<cdot>(wrapH\\<cdot>lrev_work2\\<cdot>xs) = lrev_work2\\<cdot>xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list2H\\<cdot>(wrapH\\<cdot>lrev_work2\\<cdot>xs) = lrev_work2\\<cdot>xs", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. list2H\\<cdot>(wrapH\\<cdot>lrev_work2\\<cdot>xs) = lrev_work2\\<cdot>xs", "have \"list2H oo wrapH\\<cdot>lrev_work2 = unwrapH\\<cdot>(wrapH\\<cdot>lrev_work2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list2H oo wrapH\\<cdot>lrev_work2 =\n    unwrapH\\<cdot>(wrapH\\<cdot>lrev_work2)", "by (rule cfun_eqI, simp add: unwrapH_def)"], ["proof (state)\nthis:\n  list2H oo wrapH\\<cdot>lrev_work2 = unwrapH\\<cdot>(wrapH\\<cdot>lrev_work2)\n\ngoal (1 subgoal):\n 1. list2H\\<cdot>(wrapH\\<cdot>lrev_work2\\<cdot>xs) = lrev_work2\\<cdot>xs", "also"], ["proof (state)\nthis:\n  list2H oo wrapH\\<cdot>lrev_work2 = unwrapH\\<cdot>(wrapH\\<cdot>lrev_work2)\n\ngoal (1 subgoal):\n 1. list2H\\<cdot>(wrapH\\<cdot>lrev_work2\\<cdot>xs) = lrev_work2\\<cdot>xs", "have \"\\<dots> = (unwrapH oo wrapH)\\<cdot>lrev_work2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unwrapH\\<cdot>(wrapH\\<cdot>lrev_work2) =\n    (unwrapH oo wrapH)\\<cdot>lrev_work2", "by simp"], ["proof (state)\nthis:\n  unwrapH\\<cdot>(wrapH\\<cdot>lrev_work2) =\n  (unwrapH oo wrapH)\\<cdot>lrev_work2\n\ngoal (1 subgoal):\n 1. list2H\\<cdot>(wrapH\\<cdot>lrev_work2\\<cdot>xs) = lrev_work2\\<cdot>xs", "also"], ["proof (state)\nthis:\n  unwrapH\\<cdot>(wrapH\\<cdot>lrev_work2) =\n  (unwrapH oo wrapH)\\<cdot>lrev_work2\n\ngoal (1 subgoal):\n 1. list2H\\<cdot>(wrapH\\<cdot>lrev_work2\\<cdot>xs) = lrev_work2\\<cdot>xs", "have \"\\<dots> = lrev_work2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (unwrapH oo wrapH)\\<cdot>lrev_work2 = lrev_work2", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. (unwrapH oo wrapH)\\<cdot>lrev_work2 = lrev_work2", "apply (rule worker_wrapper_fusion[OF wrapH_unwrapH_id, where body=\"lrev_body\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. lrev_work2 = fix\\<cdot>(unwrapH oo lrev_body oo wrapH)", "apply (auto iff: lrev_body2_lrev_body1_eq lrev_body_lrev_body1_eq lrev_work2_def lrev_work1_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (unwrapH oo wrapH)\\<cdot>lrev_work2 = lrev_work2\n\ngoal (1 subgoal):\n 1. list2H\\<cdot>(wrapH\\<cdot>lrev_work2\\<cdot>xs) = lrev_work2\\<cdot>xs", "finally"], ["proof (chain)\npicking this:\n  list2H oo wrapH\\<cdot>lrev_work2 = lrev_work2", "have \"list2H oo wrapH\\<cdot>lrev_work2 = lrev_work2\""], ["proof (prove)\nusing this:\n  list2H oo wrapH\\<cdot>lrev_work2 = lrev_work2\n\ngoal (1 subgoal):\n 1. list2H oo wrapH\\<cdot>lrev_work2 = lrev_work2", "."], ["proof (state)\nthis:\n  list2H oo wrapH\\<cdot>lrev_work2 = lrev_work2\n\ngoal (1 subgoal):\n 1. list2H\\<cdot>(wrapH\\<cdot>lrev_work2\\<cdot>xs) = lrev_work2\\<cdot>xs", "}"], ["proof (state)\nthis:\n  list2H oo wrapH\\<cdot>lrev_work2 = lrev_work2\n\ngoal (1 subgoal):\n 1. list2H\\<cdot>(wrapH\\<cdot>lrev_work2\\<cdot>xs) = lrev_work2\\<cdot>xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  list2H oo wrapH\\<cdot>lrev_work2 = lrev_work2\n\ngoal (1 subgoal):\n 1. list2H\\<cdot>(wrapH\\<cdot>lrev_work2\\<cdot>xs) = lrev_work2\\<cdot>xs", "using cfun_eq_iff[where f=\"list2H oo wrapH\\<cdot>lrev_work2\" and g=\"lrev_work2\"]"], ["proof (prove)\nusing this:\n  list2H oo wrapH\\<cdot>lrev_work2 = lrev_work2\n  (list2H oo wrapH\\<cdot>lrev_work2 = lrev_work2) =\n  (\\<forall>x.\n      (list2H oo wrapH\\<cdot>lrev_work2)\\<cdot>x = lrev_work2\\<cdot>x)\n\ngoal (1 subgoal):\n 1. list2H\\<cdot>(wrapH\\<cdot>lrev_work2\\<cdot>xs) = lrev_work2\\<cdot>xs", "by auto"], ["proof (state)\nthis:\n  list2H\\<cdot>(wrapH\\<cdot>lrev_work2\\<cdot>xs) = lrev_work2\\<cdot>xs\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>If we use this result directly, we only get a partially-correct\nprogram transformation, see \\citet{Tullsen:PhDThesis} for details.\\<close>"], ["", "lemma \"lrev_work3 \\<sqsubseteq> lrev_work2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lrev_work3 \\<sqsubseteq> lrev_work2", "unfolding lrev_work3_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fix\\<cdot>lrev_body3 \\<sqsubseteq> lrev_work2", "proof(rule fix_least)"], ["proof (state)\ngoal (1 subgoal):\n 1. lrev_body3\\<cdot>lrev_work2 = lrev_work2", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. lrev_body3\\<cdot>lrev_work2 = lrev_work2", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. lrev_body3\\<cdot>lrev_work2 = lrev_work2", "have \"lrev_body3\\<cdot>lrev_work2\\<cdot>xs = lrev_work2\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lrev_body3\\<cdot>lrev_work2\\<cdot>xs = lrev_work2\\<cdot>xs", "proof(cases xs)"], ["proof (state)\ngoal (3 subgoals):\n 1. xs = \\<bottom> \\<Longrightarrow>\n    lrev_body3\\<cdot>lrev_work2\\<cdot>xs = lrev_work2\\<cdot>xs\n 2. xs = lnil \\<Longrightarrow>\n    lrev_body3\\<cdot>lrev_work2\\<cdot>xs = lrev_work2\\<cdot>xs\n 3. \\<And>a llist.\n       xs = a :@ llist \\<Longrightarrow>\n       lrev_body3\\<cdot>lrev_work2\\<cdot>xs = lrev_work2\\<cdot>xs", "case bottom"], ["proof (state)\nthis:\n  xs = \\<bottom>\n\ngoal (3 subgoals):\n 1. xs = \\<bottom> \\<Longrightarrow>\n    lrev_body3\\<cdot>lrev_work2\\<cdot>xs = lrev_work2\\<cdot>xs\n 2. xs = lnil \\<Longrightarrow>\n    lrev_body3\\<cdot>lrev_work2\\<cdot>xs = lrev_work2\\<cdot>xs\n 3. \\<And>a llist.\n       xs = a :@ llist \\<Longrightarrow>\n       lrev_body3\\<cdot>lrev_work2\\<cdot>xs = lrev_work2\\<cdot>xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = \\<bottom>\n\ngoal (1 subgoal):\n 1. lrev_body3\\<cdot>lrev_work2\\<cdot>xs = lrev_work2\\<cdot>xs", "by simp"], ["proof (state)\nthis:\n  lrev_body3\\<cdot>lrev_work2\\<cdot>xs = lrev_work2\\<cdot>xs\n\ngoal (2 subgoals):\n 1. xs = lnil \\<Longrightarrow>\n    lrev_body3\\<cdot>lrev_work2\\<cdot>xs = lrev_work2\\<cdot>xs\n 2. \\<And>a llist.\n       xs = a :@ llist \\<Longrightarrow>\n       lrev_body3\\<cdot>lrev_work2\\<cdot>xs = lrev_work2\\<cdot>xs", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = lnil \\<Longrightarrow>\n    lrev_body3\\<cdot>lrev_work2\\<cdot>xs = lrev_work2\\<cdot>xs\n 2. \\<And>a llist.\n       xs = a :@ llist \\<Longrightarrow>\n       lrev_body3\\<cdot>lrev_work2\\<cdot>xs = lrev_work2\\<cdot>xs", "case lnil"], ["proof (state)\nthis:\n  xs = lnil\n\ngoal (2 subgoals):\n 1. xs = lnil \\<Longrightarrow>\n    lrev_body3\\<cdot>lrev_work2\\<cdot>xs = lrev_work2\\<cdot>xs\n 2. \\<And>a llist.\n       xs = a :@ llist \\<Longrightarrow>\n       lrev_body3\\<cdot>lrev_work2\\<cdot>xs = lrev_work2\\<cdot>xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = lnil\n\ngoal (1 subgoal):\n 1. lrev_body3\\<cdot>lrev_work2\\<cdot>xs = lrev_work2\\<cdot>xs", "unfolding lrev_work2_def"], ["proof (prove)\nusing this:\n  xs = lnil\n\ngoal (1 subgoal):\n 1. lrev_body3\\<cdot>(fix\\<cdot>lrev_body2)\\<cdot>xs =\n    fix\\<cdot>lrev_body2\\<cdot>xs", "by (subst fix_eq[where F=\"lrev_body2\"], simp)"], ["proof (state)\nthis:\n  lrev_body3\\<cdot>lrev_work2\\<cdot>xs = lrev_work2\\<cdot>xs\n\ngoal (1 subgoal):\n 1. \\<And>a llist.\n       xs = a :@ llist \\<Longrightarrow>\n       lrev_body3\\<cdot>lrev_work2\\<cdot>xs = lrev_work2\\<cdot>xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a llist.\n       xs = a :@ llist \\<Longrightarrow>\n       lrev_body3\\<cdot>lrev_work2\\<cdot>xs = lrev_work2\\<cdot>xs", "case (lcons y ys)"], ["proof (state)\nthis:\n  xs = y :@ ys\n\ngoal (1 subgoal):\n 1. \\<And>a llist.\n       xs = a :@ llist \\<Longrightarrow>\n       lrev_body3\\<cdot>lrev_work2\\<cdot>xs = lrev_work2\\<cdot>xs", "hence \"lrev_body3\\<cdot>lrev_work2\\<cdot>xs = lrev_work2\\<cdot>ys oo list2H\\<cdot>(y :@ lnil)\""], ["proof (prove)\nusing this:\n  xs = y :@ ys\n\ngoal (1 subgoal):\n 1. lrev_body3\\<cdot>lrev_work2\\<cdot>xs =\n    lrev_work2\\<cdot>ys oo list2H\\<cdot>(y :@ lnil)", "by simp"], ["proof (state)\nthis:\n  lrev_body3\\<cdot>lrev_work2\\<cdot>xs =\n  lrev_work2\\<cdot>ys oo list2H\\<cdot>(y :@ lnil)\n\ngoal (1 subgoal):\n 1. \\<And>a llist.\n       xs = a :@ llist \\<Longrightarrow>\n       lrev_body3\\<cdot>lrev_work2\\<cdot>xs = lrev_work2\\<cdot>xs", "also"], ["proof (state)\nthis:\n  lrev_body3\\<cdot>lrev_work2\\<cdot>xs =\n  lrev_work2\\<cdot>ys oo list2H\\<cdot>(y :@ lnil)\n\ngoal (1 subgoal):\n 1. \\<And>a llist.\n       xs = a :@ llist \\<Longrightarrow>\n       lrev_body3\\<cdot>lrev_work2\\<cdot>xs = lrev_work2\\<cdot>xs", "have \"\\<dots> = list2H\\<cdot>((wrapH\\<cdot>lrev_work2)\\<cdot>ys) oo list2H\\<cdot>(y :@ lnil)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lrev_work2\\<cdot>ys oo list2H\\<cdot>(y :@ lnil) =\n    list2H\\<cdot>(wrapH\\<cdot>lrev_work2\\<cdot>ys) oo\n    list2H\\<cdot>(y :@ lnil)", "using lrev_wwfusion[where xs=ys]"], ["proof (prove)\nusing this:\n  list2H\\<cdot>(wrapH\\<cdot>lrev_work2\\<cdot>ys) = lrev_work2\\<cdot>ys\n\ngoal (1 subgoal):\n 1. lrev_work2\\<cdot>ys oo list2H\\<cdot>(y :@ lnil) =\n    list2H\\<cdot>(wrapH\\<cdot>lrev_work2\\<cdot>ys) oo\n    list2H\\<cdot>(y :@ lnil)", "by simp"], ["proof (state)\nthis:\n  lrev_work2\\<cdot>ys oo list2H\\<cdot>(y :@ lnil) =\n  list2H\\<cdot>(wrapH\\<cdot>lrev_work2\\<cdot>ys) oo list2H\\<cdot>(y :@ lnil)\n\ngoal (1 subgoal):\n 1. \\<And>a llist.\n       xs = a :@ llist \\<Longrightarrow>\n       lrev_body3\\<cdot>lrev_work2\\<cdot>xs = lrev_work2\\<cdot>xs", "also"], ["proof (state)\nthis:\n  lrev_work2\\<cdot>ys oo list2H\\<cdot>(y :@ lnil) =\n  list2H\\<cdot>(wrapH\\<cdot>lrev_work2\\<cdot>ys) oo list2H\\<cdot>(y :@ lnil)\n\ngoal (1 subgoal):\n 1. \\<And>a llist.\n       xs = a :@ llist \\<Longrightarrow>\n       lrev_body3\\<cdot>lrev_work2\\<cdot>xs = lrev_work2\\<cdot>xs", "from lcons"], ["proof (chain)\npicking this:\n  xs = y :@ ys", "have \"\\<dots> = lrev_body2\\<cdot>lrev_work2\\<cdot>xs\""], ["proof (prove)\nusing this:\n  xs = y :@ ys\n\ngoal (1 subgoal):\n 1. list2H\\<cdot>(wrapH\\<cdot>lrev_work2\\<cdot>ys) oo\n    list2H\\<cdot>(y :@ lnil) =\n    lrev_body2\\<cdot>lrev_work2\\<cdot>xs", "by simp"], ["proof (state)\nthis:\n  list2H\\<cdot>(wrapH\\<cdot>lrev_work2\\<cdot>ys) oo\n  list2H\\<cdot>(y :@ lnil) =\n  lrev_body2\\<cdot>lrev_work2\\<cdot>xs\n\ngoal (1 subgoal):\n 1. \\<And>a llist.\n       xs = a :@ llist \\<Longrightarrow>\n       lrev_body3\\<cdot>lrev_work2\\<cdot>xs = lrev_work2\\<cdot>xs", "also"], ["proof (state)\nthis:\n  list2H\\<cdot>(wrapH\\<cdot>lrev_work2\\<cdot>ys) oo\n  list2H\\<cdot>(y :@ lnil) =\n  lrev_body2\\<cdot>lrev_work2\\<cdot>xs\n\ngoal (1 subgoal):\n 1. \\<And>a llist.\n       xs = a :@ llist \\<Longrightarrow>\n       lrev_body3\\<cdot>lrev_work2\\<cdot>xs = lrev_work2\\<cdot>xs", "have \"\\<dots> = lrev_work2\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lrev_body2\\<cdot>lrev_work2\\<cdot>xs = lrev_work2\\<cdot>xs", "unfolding lrev_work2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lrev_body2\\<cdot>(fix\\<cdot>lrev_body2)\\<cdot>xs =\n    fix\\<cdot>lrev_body2\\<cdot>xs", "by (simp only: fix_eq[symmetric])"], ["proof (state)\nthis:\n  lrev_body2\\<cdot>lrev_work2\\<cdot>xs = lrev_work2\\<cdot>xs\n\ngoal (1 subgoal):\n 1. \\<And>a llist.\n       xs = a :@ llist \\<Longrightarrow>\n       lrev_body3\\<cdot>lrev_work2\\<cdot>xs = lrev_work2\\<cdot>xs", "finally"], ["proof (chain)\npicking this:\n  lrev_body3\\<cdot>lrev_work2\\<cdot>xs = lrev_work2\\<cdot>xs", "show ?thesis"], ["proof (prove)\nusing this:\n  lrev_body3\\<cdot>lrev_work2\\<cdot>xs = lrev_work2\\<cdot>xs\n\ngoal (1 subgoal):\n 1. lrev_body3\\<cdot>lrev_work2\\<cdot>xs = lrev_work2\\<cdot>xs", "by simp"], ["proof (state)\nthis:\n  lrev_body3\\<cdot>lrev_work2\\<cdot>xs = lrev_work2\\<cdot>xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lrev_body3\\<cdot>lrev_work2\\<cdot>xs = lrev_work2\\<cdot>xs\n\ngoal (1 subgoal):\n 1. lrev_body3\\<cdot>lrev_work2 = lrev_work2", "}"], ["proof (state)\nthis:\n  lrev_body3\\<cdot>lrev_work2\\<cdot>?xs2 = lrev_work2\\<cdot>?xs2\n\ngoal (1 subgoal):\n 1. lrev_body3\\<cdot>lrev_work2 = lrev_work2", "thus \"lrev_body3\\<cdot>lrev_work2 = lrev_work2\""], ["proof (prove)\nusing this:\n  lrev_body3\\<cdot>lrev_work2\\<cdot>?xs2 = lrev_work2\\<cdot>?xs2\n\ngoal (1 subgoal):\n 1. lrev_body3\\<cdot>lrev_work2 = lrev_work2", "by (rule cfun_eqI)"], ["proof (state)\nthis:\n  lrev_body3\\<cdot>lrev_work2 = lrev_work2\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>We can't show the reverse inclusion in the same way as the\nfusion law doesn't hold for the optimised definition. (Intuitively we\nhaven't established that it is equal to the original @{term \"lrev\"}\ndefinition.) We could show termination of the optimised definition\nthough, as it operates on finite lists. Alternatively we can use\ninduction (over the list argument) to show total equivalence.\n\nThe following lemma shows that the fusion Gill/Hutton want to do is\ncompletely sound in this context, by appealing to the lazy list\ninduction principle.\\<close>"], ["", "lemma lrev_work3_lrev_work2_eq: \"lrev_work3 = lrev_work2\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lrev_work3 = lrev_work2", "proof(rule cfun_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. lrev_work3\\<cdot>x = lrev_work2\\<cdot>x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. lrev_work3\\<cdot>x = lrev_work2\\<cdot>x", "show \"?lhs\\<cdot>x = ?rhs\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lrev_work3\\<cdot>x = lrev_work2\\<cdot>x", "proof(induct x)"], ["proof (state)\ngoal (4 subgoals):\n 1. adm (\\<lambda>a. lrev_work3\\<cdot>a = lrev_work2\\<cdot>a)\n 2. lrev_work3\\<cdot>\\<bottom> = lrev_work2\\<cdot>\\<bottom>\n 3. lrev_work3\\<cdot>lnil = lrev_work2\\<cdot>lnil\n 4. \\<And>a x.\n       lrev_work3\\<cdot>x = lrev_work2\\<cdot>x \\<Longrightarrow>\n       lrev_work3\\<cdot>(a :@ x) = lrev_work2\\<cdot>(a :@ x)", "show \"lrev_work3\\<cdot>\\<bottom> = lrev_work2\\<cdot>\\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lrev_work3\\<cdot>\\<bottom> = lrev_work2\\<cdot>\\<bottom>", "apply (unfold lrev_work3_def lrev_work2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fix\\<cdot>lrev_body3\\<cdot>\\<bottom> =\n    fix\\<cdot>lrev_body2\\<cdot>\\<bottom>", "apply (subst fix_eq[where F=\"lrev_body2\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. fix\\<cdot>lrev_body3\\<cdot>\\<bottom> =\n    lrev_body2\\<cdot>(fix\\<cdot>lrev_body2)\\<cdot>\\<bottom>", "apply (subst fix_eq[where F=\"lrev_body3\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. lrev_body3\\<cdot>(fix\\<cdot>lrev_body3)\\<cdot>\\<bottom> =\n    lrev_body2\\<cdot>(fix\\<cdot>lrev_body2)\\<cdot>\\<bottom>", "by (simp add: lrev_body3.unfold lrev_body2.unfold)"], ["proof (state)\nthis:\n  lrev_work3\\<cdot>\\<bottom> = lrev_work2\\<cdot>\\<bottom>\n\ngoal (3 subgoals):\n 1. adm (\\<lambda>a. lrev_work3\\<cdot>a = lrev_work2\\<cdot>a)\n 2. lrev_work3\\<cdot>lnil = lrev_work2\\<cdot>lnil\n 3. \\<And>a x.\n       lrev_work3\\<cdot>x = lrev_work2\\<cdot>x \\<Longrightarrow>\n       lrev_work3\\<cdot>(a :@ x) = lrev_work2\\<cdot>(a :@ x)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. adm (\\<lambda>a. lrev_work3\\<cdot>a = lrev_work2\\<cdot>a)\n 2. lrev_work3\\<cdot>lnil = lrev_work2\\<cdot>lnil\n 3. \\<And>a x.\n       lrev_work3\\<cdot>x = lrev_work2\\<cdot>x \\<Longrightarrow>\n       lrev_work3\\<cdot>(a :@ x) = lrev_work2\\<cdot>(a :@ x)", "show \"lrev_work3\\<cdot>lnil = lrev_work2\\<cdot>lnil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lrev_work3\\<cdot>lnil = lrev_work2\\<cdot>lnil", "apply (unfold lrev_work3_def lrev_work2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fix\\<cdot>lrev_body3\\<cdot>lnil = fix\\<cdot>lrev_body2\\<cdot>lnil", "apply (subst fix_eq[where F=\"lrev_body2\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. fix\\<cdot>lrev_body3\\<cdot>lnil =\n    lrev_body2\\<cdot>(fix\\<cdot>lrev_body2)\\<cdot>lnil", "apply (subst fix_eq[where F=\"lrev_body3\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. lrev_body3\\<cdot>(fix\\<cdot>lrev_body3)\\<cdot>lnil =\n    lrev_body2\\<cdot>(fix\\<cdot>lrev_body2)\\<cdot>lnil", "by (simp add: lrev_body3.unfold lrev_body2.unfold)"], ["proof (state)\nthis:\n  lrev_work3\\<cdot>lnil = lrev_work2\\<cdot>lnil\n\ngoal (2 subgoals):\n 1. adm (\\<lambda>a. lrev_work3\\<cdot>a = lrev_work2\\<cdot>a)\n 2. \\<And>a x.\n       lrev_work3\\<cdot>x = lrev_work2\\<cdot>x \\<Longrightarrow>\n       lrev_work3\\<cdot>(a :@ x) = lrev_work2\\<cdot>(a :@ x)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. adm (\\<lambda>a. lrev_work3\\<cdot>a = lrev_work2\\<cdot>a)\n 2. \\<And>a x.\n       lrev_work3\\<cdot>x = lrev_work2\\<cdot>x \\<Longrightarrow>\n       lrev_work3\\<cdot>(a :@ x) = lrev_work2\\<cdot>(a :@ x)", "fix a l"], ["proof (state)\ngoal (2 subgoals):\n 1. adm (\\<lambda>a. lrev_work3\\<cdot>a = lrev_work2\\<cdot>a)\n 2. \\<And>a x.\n       lrev_work3\\<cdot>x = lrev_work2\\<cdot>x \\<Longrightarrow>\n       lrev_work3\\<cdot>(a :@ x) = lrev_work2\\<cdot>(a :@ x)", "assume \"lrev_work3\\<cdot>l = lrev_work2\\<cdot>l\""], ["proof (state)\nthis:\n  lrev_work3\\<cdot>l = lrev_work2\\<cdot>l\n\ngoal (2 subgoals):\n 1. adm (\\<lambda>a. lrev_work3\\<cdot>a = lrev_work2\\<cdot>a)\n 2. \\<And>a x.\n       lrev_work3\\<cdot>x = lrev_work2\\<cdot>x \\<Longrightarrow>\n       lrev_work3\\<cdot>(a :@ x) = lrev_work2\\<cdot>(a :@ x)", "thus \"lrev_work3\\<cdot>(a :@ l) = lrev_work2\\<cdot>(a :@ l)\""], ["proof (prove)\nusing this:\n  lrev_work3\\<cdot>l = lrev_work2\\<cdot>l\n\ngoal (1 subgoal):\n 1. lrev_work3\\<cdot>(a :@ l) = lrev_work2\\<cdot>(a :@ l)", "apply (unfold lrev_work3_def lrev_work2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fix\\<cdot>lrev_body3\\<cdot>l =\n    fix\\<cdot>lrev_body2\\<cdot>l \\<Longrightarrow>\n    fix\\<cdot>lrev_body3\\<cdot>(a :@ l) =\n    fix\\<cdot>lrev_body2\\<cdot>(a :@ l)", "apply (subst fix_eq[where F=\"lrev_body2\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. fix\\<cdot>lrev_body3\\<cdot>l =\n    fix\\<cdot>lrev_body2\\<cdot>l \\<Longrightarrow>\n    fix\\<cdot>lrev_body3\\<cdot>(a :@ l) =\n    lrev_body2\\<cdot>(fix\\<cdot>lrev_body2)\\<cdot>(a :@ l)", "apply (subst fix_eq[where F=\"lrev_body3\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. fix\\<cdot>lrev_body3\\<cdot>l =\n    fix\\<cdot>lrev_body2\\<cdot>l \\<Longrightarrow>\n    lrev_body3\\<cdot>(fix\\<cdot>lrev_body3)\\<cdot>(a :@ l) =\n    lrev_body2\\<cdot>(fix\\<cdot>lrev_body2)\\<cdot>(a :@ l)", "apply (fold lrev_work3_def lrev_work2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. lrev_work3\\<cdot>l = lrev_work2\\<cdot>l \\<Longrightarrow>\n    lrev_body3\\<cdot>lrev_work3\\<cdot>(a :@ l) =\n    lrev_body2\\<cdot>lrev_work2\\<cdot>(a :@ l)", "apply (simp add: lrev_body3.unfold lrev_body2.unfold lrev_wwfusion)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  lrev_work3\\<cdot>(a :@ l) = lrev_work2\\<cdot>(a :@ l)\n\ngoal (1 subgoal):\n 1. adm (\\<lambda>a. lrev_work3\\<cdot>a = lrev_work2\\<cdot>a)", "qed simp_all"], ["proof (state)\nthis:\n  lrev_work3\\<cdot>x = lrev_work2\\<cdot>x\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Use the combined worker/wrapper-fusion rule. Note we get a weaker lemma.\\<close>"], ["", "lemma lrev3_2_syntactic: \"lrev_body3 oo (unwrapH oo wrapH) = lrev_body2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lrev_body3 oo unwrapH oo wrapH = lrev_body2", "apply (subst lrev_body2.unfold, subst lrev_body3.unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> r v.\n        Fixrec.run\\<cdot>\n        (match_lnil\\<cdot>v\\<cdot>(Fixrec.succeed\\<cdot>ID) +++\n         match_lcons\\<cdot>v\\<cdot>\n         (\\<Lambda> x xs.\n             Fixrec.succeed\\<cdot>\n             (r\\<cdot>xs oo list2H\\<cdot>(x :@ lnil))))) oo\n    unwrapH oo wrapH =\n    (\\<Lambda> r v.\n        Fixrec.run\\<cdot>\n        (match_lnil\\<cdot>v\\<cdot>(Fixrec.succeed\\<cdot>ID) +++\n         match_lcons\\<cdot>v\\<cdot>\n         (\\<Lambda> x xs.\n             Fixrec.succeed\\<cdot>\n             (list2H\\<cdot>(wrapH\\<cdot>r\\<cdot>xs) oo\n              list2H\\<cdot>(x :@ lnil)))))", "apply (rule cfun_eqI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       ((\\<Lambda> r v.\n            Fixrec.run\\<cdot>\n            (match_lnil\\<cdot>v\\<cdot>(Fixrec.succeed\\<cdot>ID) +++\n             match_lcons\\<cdot>v\\<cdot>\n             (\\<Lambda> x xs.\n                 Fixrec.succeed\\<cdot>\n                 (r\\<cdot>xs oo list2H\\<cdot>(x :@ lnil))))) oo\n        unwrapH oo wrapH)\\<cdot>\n       x\\<cdot>\n       xa\\<cdot>\n       xb =\n       (\\<Lambda> r v.\n           Fixrec.run\\<cdot>\n           (match_lnil\\<cdot>v\\<cdot>(Fixrec.succeed\\<cdot>ID) +++\n            match_lcons\\<cdot>v\\<cdot>\n            (\\<Lambda> x xs.\n                Fixrec.succeed\\<cdot>\n                (list2H\\<cdot>(wrapH\\<cdot>r\\<cdot>xs) oo\n                 list2H\\<cdot>(x :@ lnil)))))\\<cdot>\n       x\\<cdot>\n       xa\\<cdot>\n       xb", "apply (case_tac xa)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa xb.\n       xa = \\<bottom> \\<Longrightarrow>\n       ((\\<Lambda> r v.\n            Fixrec.run\\<cdot>\n            (match_lnil\\<cdot>v\\<cdot>(Fixrec.succeed\\<cdot>ID) +++\n             match_lcons\\<cdot>v\\<cdot>\n             (\\<Lambda> x xs.\n                 Fixrec.succeed\\<cdot>\n                 (r\\<cdot>xs oo list2H\\<cdot>(x :@ lnil))))) oo\n        unwrapH oo wrapH)\\<cdot>\n       x\\<cdot>\n       xa\\<cdot>\n       xb =\n       (\\<Lambda> r v.\n           Fixrec.run\\<cdot>\n           (match_lnil\\<cdot>v\\<cdot>(Fixrec.succeed\\<cdot>ID) +++\n            match_lcons\\<cdot>v\\<cdot>\n            (\\<Lambda> x xs.\n                Fixrec.succeed\\<cdot>\n                (list2H\\<cdot>(wrapH\\<cdot>r\\<cdot>xs) oo\n                 list2H\\<cdot>(x :@ lnil)))))\\<cdot>\n       x\\<cdot>\n       xa\\<cdot>\n       xb\n 2. \\<And>x xa xb.\n       xa = lnil \\<Longrightarrow>\n       ((\\<Lambda> r v.\n            Fixrec.run\\<cdot>\n            (match_lnil\\<cdot>v\\<cdot>(Fixrec.succeed\\<cdot>ID) +++\n             match_lcons\\<cdot>v\\<cdot>\n             (\\<Lambda> x xs.\n                 Fixrec.succeed\\<cdot>\n                 (r\\<cdot>xs oo list2H\\<cdot>(x :@ lnil))))) oo\n        unwrapH oo wrapH)\\<cdot>\n       x\\<cdot>\n       xa\\<cdot>\n       xb =\n       (\\<Lambda> r v.\n           Fixrec.run\\<cdot>\n           (match_lnil\\<cdot>v\\<cdot>(Fixrec.succeed\\<cdot>ID) +++\n            match_lcons\\<cdot>v\\<cdot>\n            (\\<Lambda> x xs.\n                Fixrec.succeed\\<cdot>\n                (list2H\\<cdot>(wrapH\\<cdot>r\\<cdot>xs) oo\n                 list2H\\<cdot>(x :@ lnil)))))\\<cdot>\n       x\\<cdot>\n       xa\\<cdot>\n       xb\n 3. \\<And>x xa xb a llist.\n       xa = a :@ llist \\<Longrightarrow>\n       ((\\<Lambda> r v.\n            Fixrec.run\\<cdot>\n            (match_lnil\\<cdot>v\\<cdot>(Fixrec.succeed\\<cdot>ID) +++\n             match_lcons\\<cdot>v\\<cdot>\n             (\\<Lambda> x xs.\n                 Fixrec.succeed\\<cdot>\n                 (r\\<cdot>xs oo list2H\\<cdot>(x :@ lnil))))) oo\n        unwrapH oo wrapH)\\<cdot>\n       x\\<cdot>\n       xa\\<cdot>\n       xb =\n       (\\<Lambda> r v.\n           Fixrec.run\\<cdot>\n           (match_lnil\\<cdot>v\\<cdot>(Fixrec.succeed\\<cdot>ID) +++\n            match_lcons\\<cdot>v\\<cdot>\n            (\\<Lambda> x xs.\n                Fixrec.succeed\\<cdot>\n                (list2H\\<cdot>(wrapH\\<cdot>r\\<cdot>xs) oo\n                 list2H\\<cdot>(x :@ lnil)))))\\<cdot>\n       x\\<cdot>\n       xa\\<cdot>\n       xb", "apply (simp_all add: unwrapH_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lrev_work3_lrev_work2_eq': \"lrev = wrapH\\<cdot>lrev_work3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lrev = wrapH\\<cdot>lrev_work3", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lrev = wrapH\\<cdot>lrev_work3", "from lrev_lrev_body_eq"], ["proof (chain)\npicking this:\n  lrev = fix\\<cdot>lrev_body", "have \"lrev = fix\\<cdot>lrev_body\""], ["proof (prove)\nusing this:\n  lrev = fix\\<cdot>lrev_body\n\ngoal (1 subgoal):\n 1. lrev = fix\\<cdot>lrev_body", "."], ["proof (state)\nthis:\n  lrev = fix\\<cdot>lrev_body\n\ngoal (1 subgoal):\n 1. lrev = wrapH\\<cdot>lrev_work3", "also"], ["proof (state)\nthis:\n  lrev = fix\\<cdot>lrev_body\n\ngoal (1 subgoal):\n 1. lrev = wrapH\\<cdot>lrev_work3", "from wrapH_unwrapH_id unwrapH_strict"], ["proof (chain)\npicking this:\n  wrapH oo unwrapH = ID\n  unwrapH\\<cdot>\\<bottom> = \\<bottom>", "have \"\\<dots> = wrapH\\<cdot>(fix\\<cdot>lrev_body3)\""], ["proof (prove)\nusing this:\n  wrapH oo unwrapH = ID\n  unwrapH\\<cdot>\\<bottom> = \\<bottom>\n\ngoal (1 subgoal):\n 1. fix\\<cdot>lrev_body = wrapH\\<cdot>(fix\\<cdot>lrev_body3)", "by (rule worker_wrapper_fusion_new\n       , simp add: lrev3_2_syntactic lrev_body2_lrev_body1_eq lrev_body_lrev_body1_eq)"], ["proof (state)\nthis:\n  fix\\<cdot>lrev_body = wrapH\\<cdot>(fix\\<cdot>lrev_body3)\n\ngoal (1 subgoal):\n 1. lrev = wrapH\\<cdot>lrev_work3", "finally"], ["proof (chain)\npicking this:\n  lrev = wrapH\\<cdot>(fix\\<cdot>lrev_body3)", "show ?thesis"], ["proof (prove)\nusing this:\n  lrev = wrapH\\<cdot>(fix\\<cdot>lrev_body3)\n\ngoal (1 subgoal):\n 1. lrev = wrapH\\<cdot>lrev_work3", "unfolding lrev_work3_def"], ["proof (prove)\nusing this:\n  lrev = wrapH\\<cdot>(fix\\<cdot>lrev_body3)\n\ngoal (1 subgoal):\n 1. lrev = wrapH\\<cdot>(fix\\<cdot>lrev_body3)", "by simp"], ["proof (state)\nthis:\n  lrev = wrapH\\<cdot>lrev_work3\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Final syntactic tidy-up.\\<close>"], ["", "fixrec lrev_body_final :: \"('a llist \\<rightarrow> 'a H) \\<rightarrow> 'a llist \\<rightarrow> 'a H\"\nwhere\n  \"lrev_body_final\\<cdot>r\\<cdot>lnil\\<cdot>ys = ys\"\n| \"lrev_body_final\\<cdot>r\\<cdot>(x :@ xs)\\<cdot>ys = r\\<cdot>xs\\<cdot>(x :@ ys)\""], ["", "definition\n  lrev_work_final :: \"'a llist \\<rightarrow> 'a H\" where\n  \"lrev_work_final \\<equiv> fix\\<cdot>lrev_body_final\""], ["", "definition\n  lrev_final :: \"'a llist \\<rightarrow> 'a llist\" where\n  \"lrev_final \\<equiv> \\<Lambda> xs. lrev_work_final\\<cdot>xs\\<cdot>lnil\""], ["", "lemma lrev_body_final_lrev_body3_eq': \"lrev_body_final\\<cdot>r\\<cdot>xs = lrev_body3\\<cdot>r\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lrev_body_final\\<cdot>r\\<cdot>xs = lrev_body3\\<cdot>r\\<cdot>xs", "apply (subst lrev_body_final.unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> r v ys.\n        Fixrec.run\\<cdot>\n        (match_lnil\\<cdot>v\\<cdot>(Fixrec.succeed\\<cdot>ys) +++\n         match_lcons\\<cdot>v\\<cdot>\n         (\\<Lambda> x xs.\n             Fixrec.succeed\\<cdot>(r\\<cdot>xs\\<cdot>(x :@ ys)))))\\<cdot>\n    r\\<cdot>\n    xs =\n    lrev_body3\\<cdot>r\\<cdot>xs", "apply (subst lrev_body3.unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> r v ys.\n        Fixrec.run\\<cdot>\n        (match_lnil\\<cdot>v\\<cdot>(Fixrec.succeed\\<cdot>ys) +++\n         match_lcons\\<cdot>v\\<cdot>\n         (\\<Lambda> x xs.\n             Fixrec.succeed\\<cdot>(r\\<cdot>xs\\<cdot>(x :@ ys)))))\\<cdot>\n    r\\<cdot>\n    xs =\n    (\\<Lambda> r v.\n        Fixrec.run\\<cdot>\n        (match_lnil\\<cdot>v\\<cdot>(Fixrec.succeed\\<cdot>ID) +++\n         match_lcons\\<cdot>v\\<cdot>\n         (\\<Lambda> x xs.\n             Fixrec.succeed\\<cdot>\n             (r\\<cdot>xs oo list2H\\<cdot>(x :@ lnil)))))\\<cdot>\n    r\\<cdot>\n    xs", "apply (cases xs)"], ["proof (prove)\ngoal (3 subgoals):\n 1. xs = \\<bottom> \\<Longrightarrow>\n    (\\<Lambda> r v ys.\n        Fixrec.run\\<cdot>\n        (match_lnil\\<cdot>v\\<cdot>(Fixrec.succeed\\<cdot>ys) +++\n         match_lcons\\<cdot>v\\<cdot>\n         (\\<Lambda> x xs.\n             Fixrec.succeed\\<cdot>(r\\<cdot>xs\\<cdot>(x :@ ys)))))\\<cdot>\n    r\\<cdot>\n    xs =\n    (\\<Lambda> r v.\n        Fixrec.run\\<cdot>\n        (match_lnil\\<cdot>v\\<cdot>(Fixrec.succeed\\<cdot>ID) +++\n         match_lcons\\<cdot>v\\<cdot>\n         (\\<Lambda> x xs.\n             Fixrec.succeed\\<cdot>\n             (r\\<cdot>xs oo list2H\\<cdot>(x :@ lnil)))))\\<cdot>\n    r\\<cdot>\n    xs\n 2. xs = lnil \\<Longrightarrow>\n    (\\<Lambda> r v ys.\n        Fixrec.run\\<cdot>\n        (match_lnil\\<cdot>v\\<cdot>(Fixrec.succeed\\<cdot>ys) +++\n         match_lcons\\<cdot>v\\<cdot>\n         (\\<Lambda> x xs.\n             Fixrec.succeed\\<cdot>(r\\<cdot>xs\\<cdot>(x :@ ys)))))\\<cdot>\n    r\\<cdot>\n    xs =\n    (\\<Lambda> r v.\n        Fixrec.run\\<cdot>\n        (match_lnil\\<cdot>v\\<cdot>(Fixrec.succeed\\<cdot>ID) +++\n         match_lcons\\<cdot>v\\<cdot>\n         (\\<Lambda> x xs.\n             Fixrec.succeed\\<cdot>\n             (r\\<cdot>xs oo list2H\\<cdot>(x :@ lnil)))))\\<cdot>\n    r\\<cdot>\n    xs\n 3. \\<And>a llist.\n       xs = a :@ llist \\<Longrightarrow>\n       (\\<Lambda> r v ys.\n           Fixrec.run\\<cdot>\n           (match_lnil\\<cdot>v\\<cdot>(Fixrec.succeed\\<cdot>ys) +++\n            match_lcons\\<cdot>v\\<cdot>\n            (\\<Lambda> x xs.\n                Fixrec.succeed\\<cdot>(r\\<cdot>xs\\<cdot>(x :@ ys)))))\\<cdot>\n       r\\<cdot>\n       xs =\n       (\\<Lambda> r v.\n           Fixrec.run\\<cdot>\n           (match_lnil\\<cdot>v\\<cdot>(Fixrec.succeed\\<cdot>ID) +++\n            match_lcons\\<cdot>v\\<cdot>\n            (\\<Lambda> x xs.\n                Fixrec.succeed\\<cdot>\n                (r\\<cdot>xs oo list2H\\<cdot>(x :@ lnil)))))\\<cdot>\n       r\\<cdot>\n       xs", "apply (simp_all add: list2H_def ID_def cfun_eqI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lrev_body_final_lrev_body3_eq: \"lrev_body_final = lrev_body3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lrev_body_final = lrev_body3", "by (simp only: lrev_body_final_lrev_body3_eq' cfun_eqI)"], ["", "lemma lrev_final_lrev_eq: \"lrev = lrev_final\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lrev = lrev_final", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lrev = lrev_final", "have \"?lhs = lrev_wrap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lrev = lrev_wrap", "by (rule lrev_lrev_ww_eq)"], ["proof (state)\nthis:\n  lrev = lrev_wrap\n\ngoal (1 subgoal):\n 1. lrev = lrev_final", "also"], ["proof (state)\nthis:\n  lrev = lrev_wrap\n\ngoal (1 subgoal):\n 1. lrev = lrev_final", "have \"\\<dots> = wrapH\\<cdot>lrev_work\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lrev_wrap = wrapH\\<cdot>lrev_work", "by (simp only: lrev_wrap_def)"], ["proof (state)\nthis:\n  lrev_wrap = wrapH\\<cdot>lrev_work\n\ngoal (1 subgoal):\n 1. lrev = lrev_final", "also"], ["proof (state)\nthis:\n  lrev_wrap = wrapH\\<cdot>lrev_work\n\ngoal (1 subgoal):\n 1. lrev = lrev_final", "have \"\\<dots> = wrapH\\<cdot>lrev_work1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wrapH\\<cdot>lrev_work = wrapH\\<cdot>lrev_work1", "by (simp only: lrev_work1_lrev_work_eq)"], ["proof (state)\nthis:\n  wrapH\\<cdot>lrev_work = wrapH\\<cdot>lrev_work1\n\ngoal (1 subgoal):\n 1. lrev = lrev_final", "also"], ["proof (state)\nthis:\n  wrapH\\<cdot>lrev_work = wrapH\\<cdot>lrev_work1\n\ngoal (1 subgoal):\n 1. lrev = lrev_final", "have \"\\<dots> = wrapH\\<cdot>lrev_work2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wrapH\\<cdot>lrev_work1 = wrapH\\<cdot>lrev_work2", "by (simp only: lrev_work2_lrev_work1_eq)"], ["proof (state)\nthis:\n  wrapH\\<cdot>lrev_work1 = wrapH\\<cdot>lrev_work2\n\ngoal (1 subgoal):\n 1. lrev = lrev_final", "also"], ["proof (state)\nthis:\n  wrapH\\<cdot>lrev_work1 = wrapH\\<cdot>lrev_work2\n\ngoal (1 subgoal):\n 1. lrev = lrev_final", "have \"\\<dots> = wrapH\\<cdot>lrev_work3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wrapH\\<cdot>lrev_work2 = wrapH\\<cdot>lrev_work3", "by (simp only: lrev_work3_lrev_work2_eq)"], ["proof (state)\nthis:\n  wrapH\\<cdot>lrev_work2 = wrapH\\<cdot>lrev_work3\n\ngoal (1 subgoal):\n 1. lrev = lrev_final", "also"], ["proof (state)\nthis:\n  wrapH\\<cdot>lrev_work2 = wrapH\\<cdot>lrev_work3\n\ngoal (1 subgoal):\n 1. lrev = lrev_final", "have \"\\<dots> = wrapH\\<cdot>lrev_work_final\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wrapH\\<cdot>lrev_work3 = wrapH\\<cdot>lrev_work_final", "by (simp only: lrev_work3_def lrev_work_final_def lrev_body_final_lrev_body3_eq)"], ["proof (state)\nthis:\n  wrapH\\<cdot>lrev_work3 = wrapH\\<cdot>lrev_work_final\n\ngoal (1 subgoal):\n 1. lrev = lrev_final", "also"], ["proof (state)\nthis:\n  wrapH\\<cdot>lrev_work3 = wrapH\\<cdot>lrev_work_final\n\ngoal (1 subgoal):\n 1. lrev = lrev_final", "have \"\\<dots> = lrev_final\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wrapH\\<cdot>lrev_work_final = lrev_final", "by (simp add: lrev_final_def cfun_eqI H2list_def wrapH_def)"], ["proof (state)\nthis:\n  wrapH\\<cdot>lrev_work_final = lrev_final\n\ngoal (1 subgoal):\n 1. lrev = lrev_final", "finally"], ["proof (chain)\npicking this:\n  lrev = lrev_final", "show ?thesis"], ["proof (prove)\nusing this:\n  lrev = lrev_final\n\ngoal (1 subgoal):\n 1. lrev = lrev_final", "."], ["proof (state)\nthis:\n  lrev = lrev_final\n\ngoal:\nNo subgoals!", "qed"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}