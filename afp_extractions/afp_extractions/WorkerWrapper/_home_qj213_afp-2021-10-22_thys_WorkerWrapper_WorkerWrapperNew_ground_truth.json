{"file_name": "/home/qj213/afp-2021-10-22/thys/WorkerWrapper/WorkerWrapperNew.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/WorkerWrapper", "problem_names": ["lemma worker_wrapper_fusion_new:\n  fixes wrap :: \"'b::pcpo \\<rightarrow> 'a::pcpo\"\n  fixes unwrap :: \"'a \\<rightarrow> 'b\"\n  fixes body' :: \"'b \\<rightarrow> 'b\"\n  assumes wrap_unwrap: \"wrap oo unwrap = (ID :: 'a \\<rightarrow> 'a)\"\n  assumes unwrap_strict: \"unwrap\\<cdot>\\<bottom> = \\<bottom>\"\n  assumes body_body': \"unwrap oo body oo wrap = body' oo (unwrap oo wrap)\"\n  shows \"fix\\<cdot>body = wrap\\<cdot>(fix\\<cdot>body')\"", "lemma worker_wrapper_fusion_new_general:\n  fixes wrap :: \"'b::pcpo \\<rightarrow> 'a::pcpo\"\n  fixes unwrap :: \"'a \\<rightarrow> 'b\"\n  assumes wrap_unwrap: \"wrap oo unwrap = (ID :: 'a \\<rightarrow> 'a)\"\n  assumes unwrap_strict: \"unwrap\\<cdot>\\<bottom> = \\<bottom>\"\n  assumes body_body': \"\\<And>r. (unwrap oo wrap)\\<cdot>r = r\n                        \\<Longrightarrow> (unwrap oo body oo wrap)\\<cdot>r = body'\\<cdot>r\"\n  shows \"fix\\<cdot>body = wrap\\<cdot>(fix\\<cdot>body')\""], "translations": [["", "lemma worker_wrapper_fusion_new:\n  fixes wrap :: \"'b::pcpo \\<rightarrow> 'a::pcpo\"\n  fixes unwrap :: \"'a \\<rightarrow> 'b\"\n  fixes body' :: \"'b \\<rightarrow> 'b\"\n  assumes wrap_unwrap: \"wrap oo unwrap = (ID :: 'a \\<rightarrow> 'a)\"\n  assumes unwrap_strict: \"unwrap\\<cdot>\\<bottom> = \\<bottom>\"\n  assumes body_body': \"unwrap oo body oo wrap = body' oo (unwrap oo wrap)\"\n  shows \"fix\\<cdot>body = wrap\\<cdot>(fix\\<cdot>body')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fix\\<cdot>body = wrap\\<cdot>(fix\\<cdot>body')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fix\\<cdot>body = wrap\\<cdot>(fix\\<cdot>body')", "from body_body'"], ["proof (chain)\npicking this:\n  unwrap oo body oo wrap = body' oo unwrap oo wrap", "have \"unwrap oo body oo (wrap oo unwrap) = (body' oo unwrap oo (wrap oo unwrap))\""], ["proof (prove)\nusing this:\n  unwrap oo body oo wrap = body' oo unwrap oo wrap\n\ngoal (1 subgoal):\n 1. unwrap oo body oo wrap oo unwrap = body' oo unwrap oo wrap oo unwrap", "by (simp add: assoc_oo)"], ["proof (state)\nthis:\n  unwrap oo body oo wrap oo unwrap = body' oo unwrap oo wrap oo unwrap\n\ngoal (1 subgoal):\n 1. fix\\<cdot>body = wrap\\<cdot>(fix\\<cdot>body')", "with wrap_unwrap"], ["proof (chain)\npicking this:\n  wrap oo unwrap = ID\n  unwrap oo body oo wrap oo unwrap = body' oo unwrap oo wrap oo unwrap", "have \"unwrap oo body = body' oo unwrap\""], ["proof (prove)\nusing this:\n  wrap oo unwrap = ID\n  unwrap oo body oo wrap oo unwrap = body' oo unwrap oo wrap oo unwrap\n\ngoal (1 subgoal):\n 1. unwrap oo body = body' oo unwrap", "by simp"], ["proof (state)\nthis:\n  unwrap oo body = body' oo unwrap\n\ngoal (1 subgoal):\n 1. fix\\<cdot>body = wrap\\<cdot>(fix\\<cdot>body')", "with unwrap_strict"], ["proof (chain)\npicking this:\n  unwrap\\<cdot>\\<bottom> = \\<bottom>\n  unwrap oo body = body' oo unwrap", "have \"unwrap\\<cdot>(fix\\<cdot>body) = fix\\<cdot>body'\""], ["proof (prove)\nusing this:\n  unwrap\\<cdot>\\<bottom> = \\<bottom>\n  unwrap oo body = body' oo unwrap\n\ngoal (1 subgoal):\n 1. unwrap\\<cdot>(fix\\<cdot>body) = fix\\<cdot>body'", "by (rule lfp_fusion)"], ["proof (state)\nthis:\n  unwrap\\<cdot>(fix\\<cdot>body) = fix\\<cdot>body'\n\ngoal (1 subgoal):\n 1. fix\\<cdot>body = wrap\\<cdot>(fix\\<cdot>body')", "hence \"(wrap oo unwrap)\\<cdot>(fix\\<cdot>body) = wrap\\<cdot>(fix\\<cdot>body')\""], ["proof (prove)\nusing this:\n  unwrap\\<cdot>(fix\\<cdot>body) = fix\\<cdot>body'\n\ngoal (1 subgoal):\n 1. (wrap oo unwrap)\\<cdot>(fix\\<cdot>body) = wrap\\<cdot>(fix\\<cdot>body')", "by simp"], ["proof (state)\nthis:\n  (wrap oo unwrap)\\<cdot>(fix\\<cdot>body) = wrap\\<cdot>(fix\\<cdot>body')\n\ngoal (1 subgoal):\n 1. fix\\<cdot>body = wrap\\<cdot>(fix\\<cdot>body')", "with wrap_unwrap"], ["proof (chain)\npicking this:\n  wrap oo unwrap = ID\n  (wrap oo unwrap)\\<cdot>(fix\\<cdot>body) = wrap\\<cdot>(fix\\<cdot>body')", "show ?thesis"], ["proof (prove)\nusing this:\n  wrap oo unwrap = ID\n  (wrap oo unwrap)\\<cdot>(fix\\<cdot>body) = wrap\\<cdot>(fix\\<cdot>body')\n\ngoal (1 subgoal):\n 1. fix\\<cdot>body = wrap\\<cdot>(fix\\<cdot>body')", "by simp"], ["proof (state)\nthis:\n  fix\\<cdot>body = wrap\\<cdot>(fix\\<cdot>body')\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n\nWe can also show a more general result which allows fusion to be\noptionally performed on a per-recursive-call basis using\n\\texttt{parallel\\_fix\\_ind}:\n\n\\<close>"], ["", "lemma worker_wrapper_fusion_new_general:\n  fixes wrap :: \"'b::pcpo \\<rightarrow> 'a::pcpo\"\n  fixes unwrap :: \"'a \\<rightarrow> 'b\"\n  assumes wrap_unwrap: \"wrap oo unwrap = (ID :: 'a \\<rightarrow> 'a)\"\n  assumes unwrap_strict: \"unwrap\\<cdot>\\<bottom> = \\<bottom>\"\n  assumes body_body': \"\\<And>r. (unwrap oo wrap)\\<cdot>r = r\n                        \\<Longrightarrow> (unwrap oo body oo wrap)\\<cdot>r = body'\\<cdot>r\"\n  shows \"fix\\<cdot>body = wrap\\<cdot>(fix\\<cdot>body')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fix\\<cdot>body = wrap\\<cdot>(fix\\<cdot>body')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fix\\<cdot>body = wrap\\<cdot>(fix\\<cdot>body')", "let ?P = \"\\<lambda>(x, y). x = y \\<and> unwrap\\<cdot>(wrap\\<cdot>x) = x\""], ["proof (state)\ngoal (1 subgoal):\n 1. fix\\<cdot>body = wrap\\<cdot>(fix\\<cdot>body')", "have \"?P (fix\\<cdot>(unwrap oo body oo wrap), (fix\\<cdot>body'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case (fix\\<cdot>(unwrap oo body oo wrap), fix\\<cdot>body') of\n    (x, y) \\<Rightarrow> x = y \\<and> unwrap\\<cdot>(wrap\\<cdot>x) = x", "proof(induct rule: parallel_fix_ind)"], ["proof (state)\ngoal (3 subgoals):\n 1. adm (\\<lambda>x.\n            case (fst x, snd x) of\n            (x, y) \\<Rightarrow>\n              x = y \\<and> unwrap\\<cdot>(wrap\\<cdot>x) = x)\n 2. case (\\<bottom>, \\<bottom>) of\n    (x, y) \\<Rightarrow> x = y \\<and> unwrap\\<cdot>(wrap\\<cdot>x) = x\n 3. \\<And>x y.\n       case (x, y) of\n       (x, y) \\<Rightarrow>\n         x = y \\<and> unwrap\\<cdot>(wrap\\<cdot>x) = x \\<Longrightarrow>\n       case ((unwrap oo body oo wrap)\\<cdot>x, body'\\<cdot>y) of\n       (x, y) \\<Rightarrow> x = y \\<and> unwrap\\<cdot>(wrap\\<cdot>x) = x", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. adm (\\<lambda>x.\n            case (fst x, snd x) of\n            (x, y) \\<Rightarrow>\n              x = y \\<and> unwrap\\<cdot>(wrap\\<cdot>x) = x)\n 2. case (\\<bottom>, \\<bottom>) of\n    (x, y) \\<Rightarrow> x = y \\<and> unwrap\\<cdot>(wrap\\<cdot>x) = x\n 3. \\<And>x y.\n       case (x, y) of\n       (x, y) \\<Rightarrow>\n         x = y \\<and> unwrap\\<cdot>(wrap\\<cdot>x) = x \\<Longrightarrow>\n       case ((unwrap oo body oo wrap)\\<cdot>x, body'\\<cdot>y) of\n       (x, y) \\<Rightarrow> x = y \\<and> unwrap\\<cdot>(wrap\\<cdot>x) = x", "with retraction_strict unwrap_strict wrap_unwrap"], ["proof (chain)\npicking this:\n  \\<forall>x. ?f\\<cdot>(?g\\<cdot>x) = x \\<Longrightarrow>\n  ?f\\<cdot>\\<bottom> = \\<bottom>\n  unwrap\\<cdot>\\<bottom> = \\<bottom>\n  wrap oo unwrap = ID", "show \"?P (\\<bottom>, \\<bottom>)\""], ["proof (prove)\nusing this:\n  \\<forall>x. ?f\\<cdot>(?g\\<cdot>x) = x \\<Longrightarrow>\n  ?f\\<cdot>\\<bottom> = \\<bottom>\n  unwrap\\<cdot>\\<bottom> = \\<bottom>\n  wrap oo unwrap = ID\n\ngoal (1 subgoal):\n 1. case (\\<bottom>, \\<bottom>) of\n    (x, y) \\<Rightarrow> x = y \\<and> unwrap\\<cdot>(wrap\\<cdot>x) = x", "by (bestsimp simp add: cfun_eq_iff)"], ["proof (state)\nthis:\n  case (\\<bottom>, \\<bottom>) of\n  (x, y) \\<Rightarrow> x = y \\<and> unwrap\\<cdot>(wrap\\<cdot>x) = x\n\ngoal (2 subgoals):\n 1. adm (\\<lambda>x.\n            case (fst x, snd x) of\n            (x, y) \\<Rightarrow>\n              x = y \\<and> unwrap\\<cdot>(wrap\\<cdot>x) = x)\n 2. \\<And>x y.\n       case (x, y) of\n       (x, y) \\<Rightarrow>\n         x = y \\<and> unwrap\\<cdot>(wrap\\<cdot>x) = x \\<Longrightarrow>\n       case ((unwrap oo body oo wrap)\\<cdot>x, body'\\<cdot>y) of\n       (x, y) \\<Rightarrow> x = y \\<and> unwrap\\<cdot>(wrap\\<cdot>x) = x", "case (3 x y)"], ["proof (state)\nthis:\n  case (x, y) of\n  (x, y) \\<Rightarrow> x = y \\<and> unwrap\\<cdot>(wrap\\<cdot>x) = x\n\ngoal (2 subgoals):\n 1. adm (\\<lambda>x.\n            case (fst x, snd x) of\n            (x, y) \\<Rightarrow>\n              x = y \\<and> unwrap\\<cdot>(wrap\\<cdot>x) = x)\n 2. \\<And>x y.\n       case (x, y) of\n       (x, y) \\<Rightarrow>\n         x = y \\<and> unwrap\\<cdot>(wrap\\<cdot>x) = x \\<Longrightarrow>\n       case ((unwrap oo body oo wrap)\\<cdot>x, body'\\<cdot>y) of\n       (x, y) \\<Rightarrow> x = y \\<and> unwrap\\<cdot>(wrap\\<cdot>x) = x", "hence xy: \"x = y\" and unwrap_wrap: \"unwrap\\<cdot>(wrap\\<cdot>x) = x\""], ["proof (prove)\nusing this:\n  case (x, y) of\n  (x, y) \\<Rightarrow> x = y \\<and> unwrap\\<cdot>(wrap\\<cdot>x) = x\n\ngoal (1 subgoal):\n 1. x = y &&& unwrap\\<cdot>(wrap\\<cdot>x) = x", "by auto"], ["proof (state)\nthis:\n  x = y\n  unwrap\\<cdot>(wrap\\<cdot>x) = x\n\ngoal (2 subgoals):\n 1. adm (\\<lambda>x.\n            case (fst x, snd x) of\n            (x, y) \\<Rightarrow>\n              x = y \\<and> unwrap\\<cdot>(wrap\\<cdot>x) = x)\n 2. \\<And>x y.\n       case (x, y) of\n       (x, y) \\<Rightarrow>\n         x = y \\<and> unwrap\\<cdot>(wrap\\<cdot>x) = x \\<Longrightarrow>\n       case ((unwrap oo body oo wrap)\\<cdot>x, body'\\<cdot>y) of\n       (x, y) \\<Rightarrow> x = y \\<and> unwrap\\<cdot>(wrap\\<cdot>x) = x", "from body_body' xy unwrap_wrap"], ["proof (chain)\npicking this:\n  (unwrap oo wrap)\\<cdot>?r = ?r \\<Longrightarrow>\n  (unwrap oo body oo wrap)\\<cdot>?r = body'\\<cdot>?r\n  x = y\n  unwrap\\<cdot>(wrap\\<cdot>x) = x", "have \"(unwrap oo body oo wrap)\\<cdot>x = body'\\<cdot>y\""], ["proof (prove)\nusing this:\n  (unwrap oo wrap)\\<cdot>?r = ?r \\<Longrightarrow>\n  (unwrap oo body oo wrap)\\<cdot>?r = body'\\<cdot>?r\n  x = y\n  unwrap\\<cdot>(wrap\\<cdot>x) = x\n\ngoal (1 subgoal):\n 1. (unwrap oo body oo wrap)\\<cdot>x = body'\\<cdot>y", "by simp"], ["proof (state)\nthis:\n  (unwrap oo body oo wrap)\\<cdot>x = body'\\<cdot>y\n\ngoal (2 subgoals):\n 1. adm (\\<lambda>x.\n            case (fst x, snd x) of\n            (x, y) \\<Rightarrow>\n              x = y \\<and> unwrap\\<cdot>(wrap\\<cdot>x) = x)\n 2. \\<And>x y.\n       case (x, y) of\n       (x, y) \\<Rightarrow>\n         x = y \\<and> unwrap\\<cdot>(wrap\\<cdot>x) = x \\<Longrightarrow>\n       case ((unwrap oo body oo wrap)\\<cdot>x, body'\\<cdot>y) of\n       (x, y) \\<Rightarrow> x = y \\<and> unwrap\\<cdot>(wrap\\<cdot>x) = x", "moreover"], ["proof (state)\nthis:\n  (unwrap oo body oo wrap)\\<cdot>x = body'\\<cdot>y\n\ngoal (2 subgoals):\n 1. adm (\\<lambda>x.\n            case (fst x, snd x) of\n            (x, y) \\<Rightarrow>\n              x = y \\<and> unwrap\\<cdot>(wrap\\<cdot>x) = x)\n 2. \\<And>x y.\n       case (x, y) of\n       (x, y) \\<Rightarrow>\n         x = y \\<and> unwrap\\<cdot>(wrap\\<cdot>x) = x \\<Longrightarrow>\n       case ((unwrap oo body oo wrap)\\<cdot>x, body'\\<cdot>y) of\n       (x, y) \\<Rightarrow> x = y \\<and> unwrap\\<cdot>(wrap\\<cdot>x) = x", "from wrap_unwrap"], ["proof (chain)\npicking this:\n  wrap oo unwrap = ID", "have \"unwrap\\<cdot>(wrap\\<cdot>((unwrap oo body oo wrap)\\<cdot>x)) = (unwrap oo body oo wrap)\\<cdot>x\""], ["proof (prove)\nusing this:\n  wrap oo unwrap = ID\n\ngoal (1 subgoal):\n 1. unwrap\\<cdot>(wrap\\<cdot>((unwrap oo body oo wrap)\\<cdot>x)) =\n    (unwrap oo body oo wrap)\\<cdot>x", "by (simp add: cfun_eq_iff)"], ["proof (state)\nthis:\n  unwrap\\<cdot>(wrap\\<cdot>((unwrap oo body oo wrap)\\<cdot>x)) =\n  (unwrap oo body oo wrap)\\<cdot>x\n\ngoal (2 subgoals):\n 1. adm (\\<lambda>x.\n            case (fst x, snd x) of\n            (x, y) \\<Rightarrow>\n              x = y \\<and> unwrap\\<cdot>(wrap\\<cdot>x) = x)\n 2. \\<And>x y.\n       case (x, y) of\n       (x, y) \\<Rightarrow>\n         x = y \\<and> unwrap\\<cdot>(wrap\\<cdot>x) = x \\<Longrightarrow>\n       case ((unwrap oo body oo wrap)\\<cdot>x, body'\\<cdot>y) of\n       (x, y) \\<Rightarrow> x = y \\<and> unwrap\\<cdot>(wrap\\<cdot>x) = x", "ultimately"], ["proof (chain)\npicking this:\n  (unwrap oo body oo wrap)\\<cdot>x = body'\\<cdot>y\n  unwrap\\<cdot>(wrap\\<cdot>((unwrap oo body oo wrap)\\<cdot>x)) =\n  (unwrap oo body oo wrap)\\<cdot>x", "show ?case"], ["proof (prove)\nusing this:\n  (unwrap oo body oo wrap)\\<cdot>x = body'\\<cdot>y\n  unwrap\\<cdot>(wrap\\<cdot>((unwrap oo body oo wrap)\\<cdot>x)) =\n  (unwrap oo body oo wrap)\\<cdot>x\n\ngoal (1 subgoal):\n 1. case ((unwrap oo body oo wrap)\\<cdot>x, body'\\<cdot>y) of\n    (x, y) \\<Rightarrow> x = y \\<and> unwrap\\<cdot>(wrap\\<cdot>x) = x", "by simp"], ["proof (state)\nthis:\n  case ((unwrap oo body oo wrap)\\<cdot>x, body'\\<cdot>y) of\n  (x, y) \\<Rightarrow> x = y \\<and> unwrap\\<cdot>(wrap\\<cdot>x) = x\n\ngoal (1 subgoal):\n 1. adm (\\<lambda>x.\n            case (fst x, snd x) of\n            (x, y) \\<Rightarrow>\n              x = y \\<and> unwrap\\<cdot>(wrap\\<cdot>x) = x)", "qed simp"], ["proof (state)\nthis:\n  case (fix\\<cdot>(unwrap oo body oo wrap), fix\\<cdot>body') of\n  (x, y) \\<Rightarrow> x = y \\<and> unwrap\\<cdot>(wrap\\<cdot>x) = x\n\ngoal (1 subgoal):\n 1. fix\\<cdot>body = wrap\\<cdot>(fix\\<cdot>body')", "thus ?thesis"], ["proof (prove)\nusing this:\n  case (fix\\<cdot>(unwrap oo body oo wrap), fix\\<cdot>body') of\n  (x, y) \\<Rightarrow> x = y \\<and> unwrap\\<cdot>(wrap\\<cdot>x) = x\n\ngoal (1 subgoal):\n 1. fix\\<cdot>body = wrap\\<cdot>(fix\\<cdot>body')", "using worker_wrapper_id[OF wrap_unwrap refl]"], ["proof (prove)\nusing this:\n  case (fix\\<cdot>(unwrap oo body oo wrap), fix\\<cdot>body') of\n  (x, y) \\<Rightarrow> x = y \\<and> unwrap\\<cdot>(wrap\\<cdot>x) = x\n  fix\\<cdot>?body = wrap\\<cdot>(fix\\<cdot>(unwrap oo ?body oo wrap))\n\ngoal (1 subgoal):\n 1. fix\\<cdot>body = wrap\\<cdot>(fix\\<cdot>body')", "by simp"], ["proof (state)\nthis:\n  fix\\<cdot>body = wrap\\<cdot>(fix\\<cdot>body')\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n\nThis justifies the syntactically-oriented rules shown in\nFigure~\\ref{fig:wwc2}; note the scoping of the fusion rule.\n\nThose familiar with the ``bananas'' work of \\citet*{barbed-wire:1991}\nwill not be surprised that adding a strictness assumption justifies an\nequational fusion rule.\n\n\\begin{figure}[tb]\n \\begin{center}\n  \\fbox{\\parbox{0.96\\textwidth}{For a recursive definition @{haskell \"comp =\n      body\"} of type @{haskell \"A\"} and a pair of functions @{haskell \"wrap :: B \\\\to A\"}\n      and @{haskell \"unwrap :: A \\\\to B\"} where @{haskell \"wrap \\\\circ unwrap = id_A\"} and\n      @{haskell \"unwrap\\\\ \\\\bot = \\\\bot\"}, define:\n\n      \\parbox{0.35\\textwidth}{\\begin{haskell}\n        comp & = wrap\\ work\\\\\n        work & = unwrap\\ (body[wrap\\ work / comp])\n      \\end{haskell}}\\hfill \\textsf{(the worker/wrapper transformation)}\n\n    In the scope of @{haskell \"work\"}, the following rewrite is admissable:\n\n    \\parbox{0.35\\textwidth}{\\begin{haskell}\n        unwrap\\ (wrap\\ work) \\Longrightarrow work\n      \\end{haskell}}\\hfill \\textsf{(worker/wrapper fusion)}}}%\n \\end{center}%\n\\caption{The syntactic worker/wrapper transformation and fusion rule.}\\label{fig:wwc2}\n\\end{figure}\n\n\\<close>"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}