{"file_name": "/home/qj213/afp-2021-10-22/thys/WorkerWrapper/Nub.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/WorkerWrapper", "problem_names": ["lemma nub_strict[simp]: \"nub\\<cdot>\\<bottom> = \\<bottom>\"", "lemma nub_nub_body_eq: \"nub = fix\\<cdot>nub_body\"", "lemma SetMem_strict[simp]: \"SetMem\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\"", "lemma SetMem_SetEmpty[simp]: \"SetMem\\<cdot>x\\<cdot>SetEmpty = FF\"", "lemma SetMem_SetInsert: \"SetMem\\<cdot>v\\<cdot>(SetInsert\\<cdot>x\\<cdot>s) = (SetMem\\<cdot>v\\<cdot>s orelse x =\\<^sub>B v)\"", "lemma nextR_strict1[simp]: \"nextR\\<cdot>\\<bottom> = \\<bottom>\"", "lemma nextR_strict2[simp]: \"nextR\\<cdot>(R\\<cdot>\\<bottom>\\<cdot>S) = \\<bottom>\"", "lemma nextR_lnil[simp]: \"nextR\\<cdot>(R\\<cdot>lnil\\<cdot>S) = Nothing\"", "lemma a2c_strict[simp]: \"a2c\\<cdot>\\<bottom> = \\<bottom>\"", "lemma a2c_c2a_id: \"a2c oo c2a = ID\"", "lemma unwrap_strict[simp]: \"unwrap\\<cdot>\\<bottom> = \\<bottom>\"", "lemma wrap_unwrap_id: \"wrap oo unwrap = ID\"", "lemma TR_deMorgan: \"neg\\<cdot>(x orelse y) = (neg\\<cdot>x andalso neg\\<cdot>y)\"", "lemma case_maybe_case:\n  \"(case (case L of lnil \\<Rightarrow> Nothing | x :@ xs \\<Rightarrow> Just\\<cdot>(h\\<cdot>x\\<cdot>xs)) of\n     Nothing \\<Rightarrow> f | Just\\<cdot>(a, b) \\<Rightarrow> g\\<cdot>a\\<cdot>b)\n   =\n   (case L of lnil \\<Rightarrow> f | x :@ xs \\<Rightarrow> g\\<cdot>(fst (h\\<cdot>x\\<cdot>xs))\\<cdot>(snd (h\\<cdot>x\\<cdot>xs)))\"", "lemma case_a2c_case_caseR:\n    \"(case a2c\\<cdot>w of lnil \\<Rightarrow> f | x :@ xs \\<Rightarrow> g\\<cdot>x\\<cdot>xs)\n   = (case nextR\\<cdot>w of Nothing \\<Rightarrow> f | Just\\<cdot>(x, r) \\<Rightarrow> g\\<cdot>x\\<cdot>(a2c\\<cdot>r))\" (is \"?lhs = ?rhs\")", "lemma filter_filterR: \"lfilter\\<cdot>(neg oo (\\<Lambda> y. x =\\<^sub>B y))\\<cdot>(a2c\\<cdot>r) = a2c\\<cdot>(filterR\\<cdot>x\\<cdot>r)\"", "lemma nub_body_nub_body'_eq: \"unwrap oo nub_body oo wrap = nub_body'\"", "lemma nub_body'_nub_body''_eq: \"nub_body' = nub_body''\"", "lemma nub_body''_nub_body'''_eq: \"nub_body'' = nub_body''' oo (unwrap oo wrap)\"", "lemma nub_wrap_nub_body''': \"nub = wrap\\<cdot>(fix\\<cdot>nub_body''')\""], "translations": [["", "lemma nub_strict[simp]: \"nub\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nub\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "fixrec nub_body :: \"(Nat llist \\<rightarrow> Nat llist) \\<rightarrow> Nat llist \\<rightarrow> Nat llist\"\nwhere\n  \"nub_body\\<cdot>f\\<cdot>lnil = lnil\"\n| \"nub_body\\<cdot>f\\<cdot>(x :@ xs) = x :@ f\\<cdot>(lfilter\\<cdot>(neg oo (\\<Lambda> y. x =\\<^sub>B y))\\<cdot>xs)\""], ["", "lemma nub_nub_body_eq: \"nub = fix\\<cdot>nub_body\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nub = fix\\<cdot>nub_body", "by (rule cfun_eqI, subst nub_def, subst nub_body.unfold, simp)"], ["", "(* **************************************** *)"], ["", "subsection\\<open>Optimised data type.\\<close>"], ["", "text \\<open>Implement sets using lazy lists for now. Lifting up HOL's @{typ \"'a\nset\"} type causes continuity grief.\\<close>"], ["", "type_synonym NatSet = \"Nat llist\""], ["", "definition\n  SetEmpty :: \"NatSet\" where\n  \"SetEmpty \\<equiv> lnil\""], ["", "definition\n  SetInsert :: \"Nat \\<rightarrow> NatSet \\<rightarrow> NatSet\" where\n  \"SetInsert \\<equiv> lcons\""], ["", "definition\n  SetMem :: \"Nat \\<rightarrow> NatSet \\<rightarrow> tr\" where\n  \"SetMem \\<equiv> lmember\\<cdot>(bpred (=))\""], ["", "lemma SetMem_strict[simp]: \"SetMem\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SetMem\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>", "by (simp add: SetMem_def)"], ["", "lemma SetMem_SetEmpty[simp]: \"SetMem\\<cdot>x\\<cdot>SetEmpty = FF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SetMem\\<cdot>x\\<cdot>SetEmpty = FF", "by (simp add: SetMem_def SetEmpty_def)"], ["", "lemma SetMem_SetInsert: \"SetMem\\<cdot>v\\<cdot>(SetInsert\\<cdot>x\\<cdot>s) = (SetMem\\<cdot>v\\<cdot>s orelse x =\\<^sub>B v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SetMem\\<cdot>v\\<cdot>(SetInsert\\<cdot>x\\<cdot>s) =\n    (SetMem\\<cdot>v\\<cdot>s orelse x =\\<^sub>B v)", "by (simp add: SetMem_def SetInsert_def)"], ["", "text \\<open>AndyG's new type.\\<close>"], ["", "domain R = R (lazy resultR :: \"Nat llist\") (lazy exceptR :: \"NatSet\")"], ["", "definition\n  nextR :: \"R \\<rightarrow> (Nat * R) Maybe\" where\n  \"nextR = (\\<Lambda> r. case ldropWhile\\<cdot>(\\<Lambda> x. SetMem\\<cdot>x\\<cdot>(exceptR\\<cdot>r))\\<cdot>(resultR\\<cdot>r) of\n                     lnil \\<Rightarrow> Nothing\n                   | x :@ xs \\<Rightarrow> Just\\<cdot>(x, R\\<cdot>xs\\<cdot>(exceptR\\<cdot>r)))\""], ["", "lemma nextR_strict1[simp]: \"nextR\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nextR\\<cdot>\\<bottom> = \\<bottom>", "by (simp add: nextR_def)"], ["", "lemma nextR_strict2[simp]: \"nextR\\<cdot>(R\\<cdot>\\<bottom>\\<cdot>S) = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nextR\\<cdot>(R\\<cdot>\\<bottom>\\<cdot>S) = \\<bottom>", "by (simp add: nextR_def)"], ["", "lemma nextR_lnil[simp]: \"nextR\\<cdot>(R\\<cdot>lnil\\<cdot>S) = Nothing\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nextR\\<cdot>(R\\<cdot>lnil\\<cdot>S) = Nothing", "by (simp add: nextR_def)"], ["", "definition\n  filterR :: \"Nat \\<rightarrow> R \\<rightarrow> R\" where\n  \"filterR \\<equiv> (\\<Lambda> v r. R\\<cdot>(resultR\\<cdot>r)\\<cdot>(SetInsert\\<cdot>v\\<cdot>(exceptR\\<cdot>r)))\""], ["", "definition\n  c2a :: \"Nat llist \\<rightarrow> R\" where\n  \"c2a \\<equiv> \\<Lambda> xs. R\\<cdot>xs\\<cdot>SetEmpty\""], ["", "definition\n  a2c :: \"R \\<rightarrow> Nat llist\" where\n  \"a2c \\<equiv> \\<Lambda> r. lfilter\\<cdot>(\\<Lambda> v. neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>r)))\\<cdot>(resultR\\<cdot>r)\""], ["", "lemma a2c_strict[simp]: \"a2c\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a2c\\<cdot>\\<bottom> = \\<bottom>", "unfolding a2c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> r.\n        lfilter\\<cdot>\n        (\\<Lambda> v.\n            neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>r)))\\<cdot>\n        (resultR\\<cdot>r))\\<cdot>\n    \\<bottom> =\n    \\<bottom>", "by simp"], ["", "lemma a2c_c2a_id: \"a2c oo c2a = ID\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a2c oo c2a = ID", "by (rule cfun_eqI, simp add: a2c_def c2a_def lfilter_const_true)"], ["", "definition\n  wrap :: \"(R \\<rightarrow> Nat llist) \\<rightarrow> Nat llist \\<rightarrow> Nat llist\" where\n  \"wrap \\<equiv> \\<Lambda> f xs. f\\<cdot>(c2a\\<cdot>xs)\""], ["", "definition\n  unwrap :: \"(Nat llist \\<rightarrow> Nat llist) \\<rightarrow> R \\<rightarrow> Nat llist\" where\n  \"unwrap \\<equiv> \\<Lambda> f r. f\\<cdot>(a2c\\<cdot>r)\""], ["", "lemma unwrap_strict[simp]: \"unwrap\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unwrap\\<cdot>\\<bottom> = \\<bottom>", "unfolding unwrap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> f r. f\\<cdot>(a2c\\<cdot>r))\\<cdot>\\<bottom> = \\<bottom>", "by (rule cfun_eqI, simp)"], ["", "lemma wrap_unwrap_id: \"wrap oo unwrap = ID\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wrap oo unwrap = ID", "using cfun_fun_cong[OF a2c_c2a_id]"], ["proof (prove)\nusing this:\n  (a2c oo c2a)\\<cdot>?x = ID\\<cdot>?x\n\ngoal (1 subgoal):\n 1. wrap oo unwrap = ID", "by - ((rule cfun_eqI)+, simp add: wrap_def unwrap_def)"], ["", "text \\<open>Equivalences needed for later.\\<close>"], ["", "lemma TR_deMorgan: \"neg\\<cdot>(x orelse y) = (neg\\<cdot>x andalso neg\\<cdot>y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. neg\\<cdot>(x orelse y) = (neg\\<cdot>x andalso neg\\<cdot>y)", "by (rule trE[where p=x], simp_all)"], ["", "lemma case_maybe_case:\n  \"(case (case L of lnil \\<Rightarrow> Nothing | x :@ xs \\<Rightarrow> Just\\<cdot>(h\\<cdot>x\\<cdot>xs)) of\n     Nothing \\<Rightarrow> f | Just\\<cdot>(a, b) \\<Rightarrow> g\\<cdot>a\\<cdot>b)\n   =\n   (case L of lnil \\<Rightarrow> f | x :@ xs \\<Rightarrow> g\\<cdot>(fst (h\\<cdot>x\\<cdot>xs))\\<cdot>(snd (h\\<cdot>x\\<cdot>xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case case L of lnil \\<Rightarrow> Nothing\n          | x :@ xs \\<Rightarrow> Just\\<cdot>(h\\<cdot>x\\<cdot>xs) of\n     Nothing \\<Rightarrow> f\n     | Just\\<cdot>(a, b) \\<Rightarrow> g\\<cdot>a\\<cdot>b) =\n    (case L of lnil \\<Rightarrow> f\n     | x :@ xs \\<Rightarrow>\n         g\\<cdot>(fst (h\\<cdot>x\\<cdot>xs))\\<cdot>\n         (snd (h\\<cdot>x\\<cdot>xs)))", "apply (cases L, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a llist.\n       L = a :@ llist \\<Longrightarrow>\n       csplit\\<cdot>(\\<Lambda> a. Abs_cfun (Rep_cfun (g\\<cdot>a)))\\<cdot>\n       (h\\<cdot>a\\<cdot>llist) =\n       g\\<cdot>(fst (h\\<cdot>a\\<cdot>llist))\\<cdot>\n       (snd (h\\<cdot>a\\<cdot>llist))", "apply (case_tac \"h\\<cdot>a\\<cdot>llist\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a llist aa b.\n       \\<lbrakk>L = a :@ llist; h\\<cdot>a\\<cdot>llist = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> csplit\\<cdot>\n                         (\\<Lambda> a.\n                             Abs_cfun (Rep_cfun (g\\<cdot>a)))\\<cdot>\n                         (h\\<cdot>a\\<cdot>llist) =\n                         g\\<cdot>(fst (h\\<cdot>a\\<cdot>llist))\\<cdot>\n                         (snd (h\\<cdot>a\\<cdot>llist))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma case_a2c_case_caseR:\n    \"(case a2c\\<cdot>w of lnil \\<Rightarrow> f | x :@ xs \\<Rightarrow> g\\<cdot>x\\<cdot>xs)\n   = (case nextR\\<cdot>w of Nothing \\<Rightarrow> f | Just\\<cdot>(x, r) \\<Rightarrow> g\\<cdot>x\\<cdot>(a2c\\<cdot>r))\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case a2c\\<cdot>w of lnil \\<Rightarrow> f\n     | x :@ xs \\<Rightarrow> g\\<cdot>x\\<cdot>xs) =\n    (case nextR\\<cdot>w of Nothing \\<Rightarrow> f\n     | Just\\<cdot>(x, r) \\<Rightarrow> g\\<cdot>x\\<cdot>(a2c\\<cdot>r))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (case a2c\\<cdot>w of lnil \\<Rightarrow> f\n     | x :@ xs \\<Rightarrow> g\\<cdot>x\\<cdot>xs) =\n    (case nextR\\<cdot>w of Nothing \\<Rightarrow> f\n     | Just\\<cdot>(x, r) \\<Rightarrow> g\\<cdot>x\\<cdot>(a2c\\<cdot>r))", "have \"?rhs = (case (case ldropWhile\\<cdot>(\\<Lambda> x. SetMem\\<cdot>x\\<cdot>(exceptR\\<cdot>w))\\<cdot>(resultR\\<cdot>w) of\n                     lnil \\<Rightarrow> Nothing\n                   | x :@ xs \\<Rightarrow> Just\\<cdot>(x, R\\<cdot>xs\\<cdot>(exceptR\\<cdot>w))) of Nothing \\<Rightarrow> f | Just\\<cdot>(x, r) \\<Rightarrow> g\\<cdot>x\\<cdot>(a2c\\<cdot>r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case nextR\\<cdot>w of Nothing \\<Rightarrow> f\n     | Just\\<cdot>(x, r) \\<Rightarrow> g\\<cdot>x\\<cdot>(a2c\\<cdot>r)) =\n    (case case ldropWhile\\<cdot>\n               (\\<Lambda> x. SetMem\\<cdot>x\\<cdot>(exceptR\\<cdot>w))\\<cdot>\n               (resultR\\<cdot>w) of\n          lnil \\<Rightarrow> Nothing\n          | x :@ xs \\<Rightarrow>\n              Just\\<cdot>(x, R\\<cdot>xs\\<cdot>(exceptR\\<cdot>w)) of\n     Nothing \\<Rightarrow> f\n     | Just\\<cdot>(x, r) \\<Rightarrow> g\\<cdot>x\\<cdot>(a2c\\<cdot>r))", "by (simp add: nextR_def)"], ["proof (state)\nthis:\n  (case nextR\\<cdot>w of Nothing \\<Rightarrow> f\n   | Just\\<cdot>(x, r) \\<Rightarrow> g\\<cdot>x\\<cdot>(a2c\\<cdot>r)) =\n  (case case ldropWhile\\<cdot>\n             (\\<Lambda> x. SetMem\\<cdot>x\\<cdot>(exceptR\\<cdot>w))\\<cdot>\n             (resultR\\<cdot>w) of\n        lnil \\<Rightarrow> Nothing\n        | x :@ xs \\<Rightarrow>\n            Just\\<cdot>(x, R\\<cdot>xs\\<cdot>(exceptR\\<cdot>w)) of\n   Nothing \\<Rightarrow> f\n   | Just\\<cdot>(x, r) \\<Rightarrow> g\\<cdot>x\\<cdot>(a2c\\<cdot>r))\n\ngoal (1 subgoal):\n 1. (case a2c\\<cdot>w of lnil \\<Rightarrow> f\n     | x :@ xs \\<Rightarrow> g\\<cdot>x\\<cdot>xs) =\n    (case nextR\\<cdot>w of Nothing \\<Rightarrow> f\n     | Just\\<cdot>(x, r) \\<Rightarrow> g\\<cdot>x\\<cdot>(a2c\\<cdot>r))", "also"], ["proof (state)\nthis:\n  (case nextR\\<cdot>w of Nothing \\<Rightarrow> f\n   | Just\\<cdot>(x, r) \\<Rightarrow> g\\<cdot>x\\<cdot>(a2c\\<cdot>r)) =\n  (case case ldropWhile\\<cdot>\n             (\\<Lambda> x. SetMem\\<cdot>x\\<cdot>(exceptR\\<cdot>w))\\<cdot>\n             (resultR\\<cdot>w) of\n        lnil \\<Rightarrow> Nothing\n        | x :@ xs \\<Rightarrow>\n            Just\\<cdot>(x, R\\<cdot>xs\\<cdot>(exceptR\\<cdot>w)) of\n   Nothing \\<Rightarrow> f\n   | Just\\<cdot>(x, r) \\<Rightarrow> g\\<cdot>x\\<cdot>(a2c\\<cdot>r))\n\ngoal (1 subgoal):\n 1. (case a2c\\<cdot>w of lnil \\<Rightarrow> f\n     | x :@ xs \\<Rightarrow> g\\<cdot>x\\<cdot>xs) =\n    (case nextR\\<cdot>w of Nothing \\<Rightarrow> f\n     | Just\\<cdot>(x, r) \\<Rightarrow> g\\<cdot>x\\<cdot>(a2c\\<cdot>r))", "have \"\\<dots> = (case ldropWhile\\<cdot>(\\<Lambda> x. SetMem\\<cdot>x\\<cdot>(exceptR\\<cdot>w))\\<cdot>(resultR\\<cdot>w) of\n                     lnil \\<Rightarrow> f | x :@ xs \\<Rightarrow> g\\<cdot>x\\<cdot>(a2c\\<cdot>(R\\<cdot>xs\\<cdot>(exceptR\\<cdot>w))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case case ldropWhile\\<cdot>\n               (\\<Lambda> x. SetMem\\<cdot>x\\<cdot>(exceptR\\<cdot>w))\\<cdot>\n               (resultR\\<cdot>w) of\n          lnil \\<Rightarrow> Nothing\n          | x :@ xs \\<Rightarrow>\n              Just\\<cdot>(x, R\\<cdot>xs\\<cdot>(exceptR\\<cdot>w)) of\n     Nothing \\<Rightarrow> f\n     | Just\\<cdot>(x, r) \\<Rightarrow> g\\<cdot>x\\<cdot>(a2c\\<cdot>r)) =\n    (case ldropWhile\\<cdot>\n          (\\<Lambda> x. SetMem\\<cdot>x\\<cdot>(exceptR\\<cdot>w))\\<cdot>\n          (resultR\\<cdot>w) of\n     lnil \\<Rightarrow> f\n     | x :@ xs \\<Rightarrow>\n         g\\<cdot>x\\<cdot>(a2c\\<cdot>(R\\<cdot>xs\\<cdot>(exceptR\\<cdot>w))))", "using case_maybe_case[where L=\"ldropWhile\\<cdot>(\\<Lambda> x. SetMem\\<cdot>x\\<cdot>(exceptR\\<cdot>w))\\<cdot>(resultR\\<cdot>w)\"\n                            and f=f and g=\"\\<Lambda> x r. g\\<cdot>x\\<cdot>(a2c\\<cdot>r)\" and h=\"\\<Lambda> x xs. (x, R\\<cdot>xs\\<cdot>(exceptR\\<cdot>w))\"]"], ["proof (prove)\nusing this:\n  (case case ldropWhile\\<cdot>\n             (\\<Lambda> x. SetMem\\<cdot>x\\<cdot>(exceptR\\<cdot>w))\\<cdot>\n             (resultR\\<cdot>w) of\n        lnil \\<Rightarrow> Nothing\n        | x :@ xs \\<Rightarrow>\n            Just\\<cdot>\n            ((\\<Lambda> x xs.\n                 (x, R\\<cdot>xs\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n             x\\<cdot>\n             xs) of\n   Nothing \\<Rightarrow> f\n   | Just\\<cdot>(a, b) \\<Rightarrow>\n       (\\<Lambda> x r. g\\<cdot>x\\<cdot>(a2c\\<cdot>r))\\<cdot>a\\<cdot>b) =\n  (case ldropWhile\\<cdot>\n        (\\<Lambda> x. SetMem\\<cdot>x\\<cdot>(exceptR\\<cdot>w))\\<cdot>\n        (resultR\\<cdot>w) of\n   lnil \\<Rightarrow> f\n   | x :@ xs \\<Rightarrow>\n       (\\<Lambda> x r. g\\<cdot>x\\<cdot>(a2c\\<cdot>r))\\<cdot>\n       (fst ((\\<Lambda> x xs.\n                 (x, R\\<cdot>xs\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n             x\\<cdot>\n             xs))\\<cdot>\n       (snd ((\\<Lambda> x xs.\n                 (x, R\\<cdot>xs\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n             x\\<cdot>\n             xs)))\n\ngoal (1 subgoal):\n 1. (case case ldropWhile\\<cdot>\n               (\\<Lambda> x. SetMem\\<cdot>x\\<cdot>(exceptR\\<cdot>w))\\<cdot>\n               (resultR\\<cdot>w) of\n          lnil \\<Rightarrow> Nothing\n          | x :@ xs \\<Rightarrow>\n              Just\\<cdot>(x, R\\<cdot>xs\\<cdot>(exceptR\\<cdot>w)) of\n     Nothing \\<Rightarrow> f\n     | Just\\<cdot>(x, r) \\<Rightarrow> g\\<cdot>x\\<cdot>(a2c\\<cdot>r)) =\n    (case ldropWhile\\<cdot>\n          (\\<Lambda> x. SetMem\\<cdot>x\\<cdot>(exceptR\\<cdot>w))\\<cdot>\n          (resultR\\<cdot>w) of\n     lnil \\<Rightarrow> f\n     | x :@ xs \\<Rightarrow>\n         g\\<cdot>x\\<cdot>(a2c\\<cdot>(R\\<cdot>xs\\<cdot>(exceptR\\<cdot>w))))", "by simp"], ["proof (state)\nthis:\n  (case case ldropWhile\\<cdot>\n             (\\<Lambda> x. SetMem\\<cdot>x\\<cdot>(exceptR\\<cdot>w))\\<cdot>\n             (resultR\\<cdot>w) of\n        lnil \\<Rightarrow> Nothing\n        | x :@ xs \\<Rightarrow>\n            Just\\<cdot>(x, R\\<cdot>xs\\<cdot>(exceptR\\<cdot>w)) of\n   Nothing \\<Rightarrow> f\n   | Just\\<cdot>(x, r) \\<Rightarrow> g\\<cdot>x\\<cdot>(a2c\\<cdot>r)) =\n  (case ldropWhile\\<cdot>\n        (\\<Lambda> x. SetMem\\<cdot>x\\<cdot>(exceptR\\<cdot>w))\\<cdot>\n        (resultR\\<cdot>w) of\n   lnil \\<Rightarrow> f\n   | x :@ xs \\<Rightarrow>\n       g\\<cdot>x\\<cdot>(a2c\\<cdot>(R\\<cdot>xs\\<cdot>(exceptR\\<cdot>w))))\n\ngoal (1 subgoal):\n 1. (case a2c\\<cdot>w of lnil \\<Rightarrow> f\n     | x :@ xs \\<Rightarrow> g\\<cdot>x\\<cdot>xs) =\n    (case nextR\\<cdot>w of Nothing \\<Rightarrow> f\n     | Just\\<cdot>(x, r) \\<Rightarrow> g\\<cdot>x\\<cdot>(a2c\\<cdot>r))", "also"], ["proof (state)\nthis:\n  (case case ldropWhile\\<cdot>\n             (\\<Lambda> x. SetMem\\<cdot>x\\<cdot>(exceptR\\<cdot>w))\\<cdot>\n             (resultR\\<cdot>w) of\n        lnil \\<Rightarrow> Nothing\n        | x :@ xs \\<Rightarrow>\n            Just\\<cdot>(x, R\\<cdot>xs\\<cdot>(exceptR\\<cdot>w)) of\n   Nothing \\<Rightarrow> f\n   | Just\\<cdot>(x, r) \\<Rightarrow> g\\<cdot>x\\<cdot>(a2c\\<cdot>r)) =\n  (case ldropWhile\\<cdot>\n        (\\<Lambda> x. SetMem\\<cdot>x\\<cdot>(exceptR\\<cdot>w))\\<cdot>\n        (resultR\\<cdot>w) of\n   lnil \\<Rightarrow> f\n   | x :@ xs \\<Rightarrow>\n       g\\<cdot>x\\<cdot>(a2c\\<cdot>(R\\<cdot>xs\\<cdot>(exceptR\\<cdot>w))))\n\ngoal (1 subgoal):\n 1. (case a2c\\<cdot>w of lnil \\<Rightarrow> f\n     | x :@ xs \\<Rightarrow> g\\<cdot>x\\<cdot>xs) =\n    (case nextR\\<cdot>w of Nothing \\<Rightarrow> f\n     | Just\\<cdot>(x, r) \\<Rightarrow> g\\<cdot>x\\<cdot>(a2c\\<cdot>r))", "have \"\\<dots> = ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case ldropWhile\\<cdot>\n          (\\<Lambda> x. SetMem\\<cdot>x\\<cdot>(exceptR\\<cdot>w))\\<cdot>\n          (resultR\\<cdot>w) of\n     lnil \\<Rightarrow> f\n     | x :@ xs \\<Rightarrow>\n         g\\<cdot>x\\<cdot>(a2c\\<cdot>(R\\<cdot>xs\\<cdot>(exceptR\\<cdot>w)))) =\n    (case a2c\\<cdot>w of lnil \\<Rightarrow> f\n     | x :@ xs \\<Rightarrow> g\\<cdot>x\\<cdot>xs)", "apply (simp add: a2c_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case ldropWhile\\<cdot>\n          (\\<Lambda> x. SetMem\\<cdot>x\\<cdot>(exceptR\\<cdot>w))\\<cdot>\n          (resultR\\<cdot>w) of\n     lnil \\<Rightarrow> f\n     | x :@ xs \\<Rightarrow>\n         g\\<cdot>x\\<cdot>\n         (lfilter\\<cdot>\n          (\\<Lambda> v.\n              neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n          xs)) =\n    (case lfilter\\<cdot>\n          (\\<Lambda> v.\n              neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n          (resultR\\<cdot>w) of\n     lnil \\<Rightarrow> f | x :@ xs \\<Rightarrow> g\\<cdot>x\\<cdot>xs)", "apply (cases \"resultR\\<cdot>w\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. resultR\\<cdot>w = \\<bottom> \\<Longrightarrow>\n    (case ldropWhile\\<cdot>\n          (\\<Lambda> x. SetMem\\<cdot>x\\<cdot>(exceptR\\<cdot>w))\\<cdot>\n          (resultR\\<cdot>w) of\n     lnil \\<Rightarrow> f\n     | x :@ xs \\<Rightarrow>\n         g\\<cdot>x\\<cdot>\n         (lfilter\\<cdot>\n          (\\<Lambda> v.\n              neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n          xs)) =\n    (case lfilter\\<cdot>\n          (\\<Lambda> v.\n              neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n          (resultR\\<cdot>w) of\n     lnil \\<Rightarrow> f | x :@ xs \\<Rightarrow> g\\<cdot>x\\<cdot>xs)\n 2. resultR\\<cdot>w = lnil \\<Longrightarrow>\n    (case ldropWhile\\<cdot>\n          (\\<Lambda> x. SetMem\\<cdot>x\\<cdot>(exceptR\\<cdot>w))\\<cdot>\n          (resultR\\<cdot>w) of\n     lnil \\<Rightarrow> f\n     | x :@ xs \\<Rightarrow>\n         g\\<cdot>x\\<cdot>\n         (lfilter\\<cdot>\n          (\\<Lambda> v.\n              neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n          xs)) =\n    (case lfilter\\<cdot>\n          (\\<Lambda> v.\n              neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n          (resultR\\<cdot>w) of\n     lnil \\<Rightarrow> f | x :@ xs \\<Rightarrow> g\\<cdot>x\\<cdot>xs)\n 3. \\<And>a llist.\n       resultR\\<cdot>w = a :@ llist \\<Longrightarrow>\n       (case ldropWhile\\<cdot>\n             (\\<Lambda> x. SetMem\\<cdot>x\\<cdot>(exceptR\\<cdot>w))\\<cdot>\n             (resultR\\<cdot>w) of\n        lnil \\<Rightarrow> f\n        | x :@ xs \\<Rightarrow>\n            g\\<cdot>x\\<cdot>\n            (lfilter\\<cdot>\n             (\\<Lambda> v.\n                 neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n             xs)) =\n       (case lfilter\\<cdot>\n             (\\<Lambda> v.\n                 neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n             (resultR\\<cdot>w) of\n        lnil \\<Rightarrow> f | x :@ xs \\<Rightarrow> g\\<cdot>x\\<cdot>xs)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a llist.\n       resultR\\<cdot>w = a :@ llist \\<Longrightarrow>\n       (case If SetMem\\<cdot>a\\<cdot>(exceptR\\<cdot>w)\n             then ldropWhile\\<cdot>\n                  (\\<Lambda> x.\n                      SetMem\\<cdot>x\\<cdot>(exceptR\\<cdot>w))\\<cdot>\n                  llist\n             else a :@ llist of\n        lnil \\<Rightarrow> f\n        | x :@ xs \\<Rightarrow>\n            g\\<cdot>x\\<cdot>\n            (lfilter\\<cdot>\n             (\\<Lambda> v.\n                 neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n             xs)) =\n       (case If neg\\<cdot>(SetMem\\<cdot>a\\<cdot>(exceptR\\<cdot>w))\n             then a :@\n                  lfilter\\<cdot>\n                  (\\<Lambda> v.\n                      neg\\<cdot>\n                      (SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n                  llist\n             else lfilter\\<cdot>\n                  (\\<Lambda> v.\n                      neg\\<cdot>\n                      (SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n                  llist of\n        lnil \\<Rightarrow> f | x :@ xs \\<Rightarrow> g\\<cdot>x\\<cdot>xs)", "apply (rule_tac p=\"SetMem\\<cdot>a\\<cdot>(exceptR\\<cdot>w)\" in trE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a llist.\n       \\<lbrakk>resultR\\<cdot>w = a :@ llist;\n        SetMem\\<cdot>a\\<cdot>(exceptR\\<cdot>w) = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> (case If SetMem\\<cdot>a\\<cdot>(exceptR\\<cdot>w)\n                               then ldropWhile\\<cdot>\n                                    (\\<Lambda> x.\n  SetMem\\<cdot>x\\<cdot>(exceptR\\<cdot>w))\\<cdot>\n                                    llist\n                               else a :@ llist of\n                          lnil \\<Rightarrow> f\n                          | x :@ xs \\<Rightarrow>\n                              g\\<cdot>x\\<cdot>\n                              (lfilter\\<cdot>\n                               (\\<Lambda> v.\n                                   neg\\<cdot>\n                                   (SetMem\\<cdot>v\\<cdot>\n                                    (exceptR\\<cdot>w)))\\<cdot>\n                               xs)) =\n                         (case If neg\\<cdot>\n                                  (SetMem\\<cdot>a\\<cdot>(exceptR\\<cdot>w))\n                               then a :@\n                                    lfilter\\<cdot>\n                                    (\\<Lambda> v.\n  neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n                                    llist\n                               else lfilter\\<cdot>\n                                    (\\<Lambda> v.\n  neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n                                    llist of\n                          lnil \\<Rightarrow> f\n                          | x :@ xs \\<Rightarrow> g\\<cdot>x\\<cdot>xs)\n 2. \\<And>a llist.\n       \\<lbrakk>resultR\\<cdot>w = a :@ llist;\n        SetMem\\<cdot>a\\<cdot>(exceptR\\<cdot>w) = TT\\<rbrakk>\n       \\<Longrightarrow> (case If SetMem\\<cdot>a\\<cdot>(exceptR\\<cdot>w)\n                               then ldropWhile\\<cdot>\n                                    (\\<Lambda> x.\n  SetMem\\<cdot>x\\<cdot>(exceptR\\<cdot>w))\\<cdot>\n                                    llist\n                               else a :@ llist of\n                          lnil \\<Rightarrow> f\n                          | x :@ xs \\<Rightarrow>\n                              g\\<cdot>x\\<cdot>\n                              (lfilter\\<cdot>\n                               (\\<Lambda> v.\n                                   neg\\<cdot>\n                                   (SetMem\\<cdot>v\\<cdot>\n                                    (exceptR\\<cdot>w)))\\<cdot>\n                               xs)) =\n                         (case If neg\\<cdot>\n                                  (SetMem\\<cdot>a\\<cdot>(exceptR\\<cdot>w))\n                               then a :@\n                                    lfilter\\<cdot>\n                                    (\\<Lambda> v.\n  neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n                                    llist\n                               else lfilter\\<cdot>\n                                    (\\<Lambda> v.\n  neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n                                    llist of\n                          lnil \\<Rightarrow> f\n                          | x :@ xs \\<Rightarrow> g\\<cdot>x\\<cdot>xs)\n 3. \\<And>a llist.\n       \\<lbrakk>resultR\\<cdot>w = a :@ llist;\n        SetMem\\<cdot>a\\<cdot>(exceptR\\<cdot>w) = FF\\<rbrakk>\n       \\<Longrightarrow> (case If SetMem\\<cdot>a\\<cdot>(exceptR\\<cdot>w)\n                               then ldropWhile\\<cdot>\n                                    (\\<Lambda> x.\n  SetMem\\<cdot>x\\<cdot>(exceptR\\<cdot>w))\\<cdot>\n                                    llist\n                               else a :@ llist of\n                          lnil \\<Rightarrow> f\n                          | x :@ xs \\<Rightarrow>\n                              g\\<cdot>x\\<cdot>\n                              (lfilter\\<cdot>\n                               (\\<Lambda> v.\n                                   neg\\<cdot>\n                                   (SetMem\\<cdot>v\\<cdot>\n                                    (exceptR\\<cdot>w)))\\<cdot>\n                               xs)) =\n                         (case If neg\\<cdot>\n                                  (SetMem\\<cdot>a\\<cdot>(exceptR\\<cdot>w))\n                               then a :@\n                                    lfilter\\<cdot>\n                                    (\\<Lambda> v.\n  neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n                                    llist\n                               else lfilter\\<cdot>\n                                    (\\<Lambda> v.\n  neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n                                    llist of\n                          lnil \\<Rightarrow> f\n                          | x :@ xs \\<Rightarrow> g\\<cdot>x\\<cdot>xs)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a llist.\n       \\<lbrakk>resultR\\<cdot>w = a :@ llist;\n        SetMem\\<cdot>a\\<cdot>(exceptR\\<cdot>w) = TT\\<rbrakk>\n       \\<Longrightarrow> (case ldropWhile\\<cdot>\n                               (\\<Lambda> x.\n                                   SetMem\\<cdot>x\\<cdot>\n                                   (exceptR\\<cdot>w))\\<cdot>\n                               llist of\n                          lnil \\<Rightarrow> f\n                          | x :@ xs \\<Rightarrow>\n                              g\\<cdot>x\\<cdot>\n                              (lfilter\\<cdot>\n                               (\\<Lambda> v.\n                                   neg\\<cdot>\n                                   (SetMem\\<cdot>v\\<cdot>\n                                    (exceptR\\<cdot>w)))\\<cdot>\n                               xs)) =\n                         (case lfilter\\<cdot>\n                               (\\<Lambda> v.\n                                   neg\\<cdot>\n                                   (SetMem\\<cdot>v\\<cdot>\n                                    (exceptR\\<cdot>w)))\\<cdot>\n                               llist of\n                          lnil \\<Rightarrow> f\n                          | x :@ xs \\<Rightarrow> g\\<cdot>x\\<cdot>xs)", "apply (induct_tac llist)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a llist.\n       \\<lbrakk>resultR\\<cdot>w = a :@ llist;\n        SetMem\\<cdot>a\\<cdot>(exceptR\\<cdot>w) = TT\\<rbrakk>\n       \\<Longrightarrow> adm (\\<lambda>a.\n                                 (case ldropWhile\\<cdot>\n (\\<Lambda> x. SetMem\\<cdot>x\\<cdot>(exceptR\\<cdot>w))\\<cdot>\n a of\n                                  lnil \\<Rightarrow> f\n                                  | x :@ xs \\<Rightarrow>\ng\\<cdot>x\\<cdot>\n(lfilter\\<cdot>\n (\\<Lambda> v. neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n xs)) =\n                                 (case lfilter\\<cdot>\n (\\<Lambda> v. neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n a of\n                                  lnil \\<Rightarrow> f\n                                  | x :@ xs \\<Rightarrow>\ng\\<cdot>x\\<cdot>xs))\n 2. \\<And>a llist.\n       \\<lbrakk>resultR\\<cdot>w = a :@ llist;\n        SetMem\\<cdot>a\\<cdot>(exceptR\\<cdot>w) = TT\\<rbrakk>\n       \\<Longrightarrow> (case ldropWhile\\<cdot>\n                               (\\<Lambda> x.\n                                   SetMem\\<cdot>x\\<cdot>\n                                   (exceptR\\<cdot>w))\\<cdot>\n                               \\<bottom> of\n                          lnil \\<Rightarrow> f\n                          | x :@ xs \\<Rightarrow>\n                              g\\<cdot>x\\<cdot>\n                              (lfilter\\<cdot>\n                               (\\<Lambda> v.\n                                   neg\\<cdot>\n                                   (SetMem\\<cdot>v\\<cdot>\n                                    (exceptR\\<cdot>w)))\\<cdot>\n                               xs)) =\n                         (case lfilter\\<cdot>\n                               (\\<Lambda> v.\n                                   neg\\<cdot>\n                                   (SetMem\\<cdot>v\\<cdot>\n                                    (exceptR\\<cdot>w)))\\<cdot>\n                               \\<bottom> of\n                          lnil \\<Rightarrow> f\n                          | x :@ xs \\<Rightarrow> g\\<cdot>x\\<cdot>xs)\n 3. \\<And>a llist.\n       \\<lbrakk>resultR\\<cdot>w = a :@ llist;\n        SetMem\\<cdot>a\\<cdot>(exceptR\\<cdot>w) = TT\\<rbrakk>\n       \\<Longrightarrow> (case ldropWhile\\<cdot>\n                               (\\<Lambda> x.\n                                   SetMem\\<cdot>x\\<cdot>\n                                   (exceptR\\<cdot>w))\\<cdot>\n                               lnil of\n                          lnil \\<Rightarrow> f\n                          | x :@ xs \\<Rightarrow>\n                              g\\<cdot>x\\<cdot>\n                              (lfilter\\<cdot>\n                               (\\<Lambda> v.\n                                   neg\\<cdot>\n                                   (SetMem\\<cdot>v\\<cdot>\n                                    (exceptR\\<cdot>w)))\\<cdot>\n                               xs)) =\n                         (case lfilter\\<cdot>\n                               (\\<Lambda> v.\n                                   neg\\<cdot>\n                                   (SetMem\\<cdot>v\\<cdot>\n                                    (exceptR\\<cdot>w)))\\<cdot>\n                               lnil of\n                          lnil \\<Rightarrow> f\n                          | x :@ xs \\<Rightarrow> g\\<cdot>x\\<cdot>xs)\n 4. \\<And>a llist aa llista.\n       \\<lbrakk>resultR\\<cdot>w = a :@ llist;\n        SetMem\\<cdot>a\\<cdot>(exceptR\\<cdot>w) = TT;\n        (case ldropWhile\\<cdot>\n              (\\<Lambda> x. SetMem\\<cdot>x\\<cdot>(exceptR\\<cdot>w))\\<cdot>\n              llista of\n         lnil \\<Rightarrow> f\n         | x :@ xs \\<Rightarrow>\n             g\\<cdot>x\\<cdot>\n             (lfilter\\<cdot>\n              (\\<Lambda> v.\n                  neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n              xs)) =\n        (case lfilter\\<cdot>\n              (\\<Lambda> v.\n                  neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n              llista of\n         lnil \\<Rightarrow> f\n         | x :@ xs \\<Rightarrow> g\\<cdot>x\\<cdot>xs)\\<rbrakk>\n       \\<Longrightarrow> (case ldropWhile\\<cdot>\n                               (\\<Lambda> x.\n                                   SetMem\\<cdot>x\\<cdot>\n                                   (exceptR\\<cdot>w))\\<cdot>\n                               (aa :@ llista) of\n                          lnil \\<Rightarrow> f\n                          | x :@ xs \\<Rightarrow>\n                              g\\<cdot>x\\<cdot>\n                              (lfilter\\<cdot>\n                               (\\<Lambda> v.\n                                   neg\\<cdot>\n                                   (SetMem\\<cdot>v\\<cdot>\n                                    (exceptR\\<cdot>w)))\\<cdot>\n                               xs)) =\n                         (case lfilter\\<cdot>\n                               (\\<Lambda> v.\n                                   neg\\<cdot>\n                                   (SetMem\\<cdot>v\\<cdot>\n                                    (exceptR\\<cdot>w)))\\<cdot>\n                               (aa :@ llista) of\n                          lnil \\<Rightarrow> f\n                          | x :@ xs \\<Rightarrow> g\\<cdot>x\\<cdot>xs)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a llist aa llista.\n       \\<lbrakk>resultR\\<cdot>w = a :@ llist;\n        SetMem\\<cdot>a\\<cdot>(exceptR\\<cdot>w) = TT;\n        (case ldropWhile\\<cdot>\n              (\\<Lambda> x. SetMem\\<cdot>x\\<cdot>(exceptR\\<cdot>w))\\<cdot>\n              llista of\n         lnil \\<Rightarrow> f\n         | x :@ xs \\<Rightarrow>\n             g\\<cdot>x\\<cdot>\n             (lfilter\\<cdot>\n              (\\<Lambda> v.\n                  neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n              xs)) =\n        (case lfilter\\<cdot>\n              (\\<Lambda> v.\n                  neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n              llista of\n         lnil \\<Rightarrow> f\n         | x :@ xs \\<Rightarrow> g\\<cdot>x\\<cdot>xs)\\<rbrakk>\n       \\<Longrightarrow> (case If SetMem\\<cdot>aa\\<cdot>(exceptR\\<cdot>w)\n                               then ldropWhile\\<cdot>\n                                    (\\<Lambda> x.\n  SetMem\\<cdot>x\\<cdot>(exceptR\\<cdot>w))\\<cdot>\n                                    llista\n                               else aa :@ llista of\n                          lnil \\<Rightarrow> f\n                          | x :@ xs \\<Rightarrow>\n                              g\\<cdot>x\\<cdot>\n                              (lfilter\\<cdot>\n                               (\\<Lambda> v.\n                                   neg\\<cdot>\n                                   (SetMem\\<cdot>v\\<cdot>\n                                    (exceptR\\<cdot>w)))\\<cdot>\n                               xs)) =\n                         (case If neg\\<cdot>\n                                  (SetMem\\<cdot>aa\\<cdot>(exceptR\\<cdot>w))\n                               then aa :@\n                                    lfilter\\<cdot>\n                                    (\\<Lambda> v.\n  neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n                                    llista\n                               else lfilter\\<cdot>\n                                    (\\<Lambda> v.\n  neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n                                    llista of\n                          lnil \\<Rightarrow> f\n                          | x :@ xs \\<Rightarrow> g\\<cdot>x\\<cdot>xs)", "apply (rule_tac p=\"SetMem\\<cdot>aa\\<cdot>(exceptR\\<cdot>w)\" in trE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a llist aa llista.\n       \\<lbrakk>resultR\\<cdot>w = a :@ llist;\n        SetMem\\<cdot>a\\<cdot>(exceptR\\<cdot>w) = TT;\n        (case ldropWhile\\<cdot>\n              (\\<Lambda> x. SetMem\\<cdot>x\\<cdot>(exceptR\\<cdot>w))\\<cdot>\n              llista of\n         lnil \\<Rightarrow> f\n         | x :@ xs \\<Rightarrow>\n             g\\<cdot>x\\<cdot>\n             (lfilter\\<cdot>\n              (\\<Lambda> v.\n                  neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n              xs)) =\n        (case lfilter\\<cdot>\n              (\\<Lambda> v.\n                  neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n              llista of\n         lnil \\<Rightarrow> f | x :@ xs \\<Rightarrow> g\\<cdot>x\\<cdot>xs);\n        SetMem\\<cdot>aa\\<cdot>(exceptR\\<cdot>w) = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> (case If SetMem\\<cdot>aa\\<cdot>(exceptR\\<cdot>w)\n                               then ldropWhile\\<cdot>\n                                    (\\<Lambda> x.\n  SetMem\\<cdot>x\\<cdot>(exceptR\\<cdot>w))\\<cdot>\n                                    llista\n                               else aa :@ llista of\n                          lnil \\<Rightarrow> f\n                          | x :@ xs \\<Rightarrow>\n                              g\\<cdot>x\\<cdot>\n                              (lfilter\\<cdot>\n                               (\\<Lambda> v.\n                                   neg\\<cdot>\n                                   (SetMem\\<cdot>v\\<cdot>\n                                    (exceptR\\<cdot>w)))\\<cdot>\n                               xs)) =\n                         (case If neg\\<cdot>\n                                  (SetMem\\<cdot>aa\\<cdot>(exceptR\\<cdot>w))\n                               then aa :@\n                                    lfilter\\<cdot>\n                                    (\\<Lambda> v.\n  neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n                                    llista\n                               else lfilter\\<cdot>\n                                    (\\<Lambda> v.\n  neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n                                    llista of\n                          lnil \\<Rightarrow> f\n                          | x :@ xs \\<Rightarrow> g\\<cdot>x\\<cdot>xs)\n 2. \\<And>a llist aa llista.\n       \\<lbrakk>resultR\\<cdot>w = a :@ llist;\n        SetMem\\<cdot>a\\<cdot>(exceptR\\<cdot>w) = TT;\n        (case ldropWhile\\<cdot>\n              (\\<Lambda> x. SetMem\\<cdot>x\\<cdot>(exceptR\\<cdot>w))\\<cdot>\n              llista of\n         lnil \\<Rightarrow> f\n         | x :@ xs \\<Rightarrow>\n             g\\<cdot>x\\<cdot>\n             (lfilter\\<cdot>\n              (\\<Lambda> v.\n                  neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n              xs)) =\n        (case lfilter\\<cdot>\n              (\\<Lambda> v.\n                  neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n              llista of\n         lnil \\<Rightarrow> f | x :@ xs \\<Rightarrow> g\\<cdot>x\\<cdot>xs);\n        SetMem\\<cdot>aa\\<cdot>(exceptR\\<cdot>w) = TT\\<rbrakk>\n       \\<Longrightarrow> (case If SetMem\\<cdot>aa\\<cdot>(exceptR\\<cdot>w)\n                               then ldropWhile\\<cdot>\n                                    (\\<Lambda> x.\n  SetMem\\<cdot>x\\<cdot>(exceptR\\<cdot>w))\\<cdot>\n                                    llista\n                               else aa :@ llista of\n                          lnil \\<Rightarrow> f\n                          | x :@ xs \\<Rightarrow>\n                              g\\<cdot>x\\<cdot>\n                              (lfilter\\<cdot>\n                               (\\<Lambda> v.\n                                   neg\\<cdot>\n                                   (SetMem\\<cdot>v\\<cdot>\n                                    (exceptR\\<cdot>w)))\\<cdot>\n                               xs)) =\n                         (case If neg\\<cdot>\n                                  (SetMem\\<cdot>aa\\<cdot>(exceptR\\<cdot>w))\n                               then aa :@\n                                    lfilter\\<cdot>\n                                    (\\<Lambda> v.\n  neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n                                    llista\n                               else lfilter\\<cdot>\n                                    (\\<Lambda> v.\n  neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n                                    llista of\n                          lnil \\<Rightarrow> f\n                          | x :@ xs \\<Rightarrow> g\\<cdot>x\\<cdot>xs)\n 3. \\<And>a llist aa llista.\n       \\<lbrakk>resultR\\<cdot>w = a :@ llist;\n        SetMem\\<cdot>a\\<cdot>(exceptR\\<cdot>w) = TT;\n        (case ldropWhile\\<cdot>\n              (\\<Lambda> x. SetMem\\<cdot>x\\<cdot>(exceptR\\<cdot>w))\\<cdot>\n              llista of\n         lnil \\<Rightarrow> f\n         | x :@ xs \\<Rightarrow>\n             g\\<cdot>x\\<cdot>\n             (lfilter\\<cdot>\n              (\\<Lambda> v.\n                  neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n              xs)) =\n        (case lfilter\\<cdot>\n              (\\<Lambda> v.\n                  neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n              llista of\n         lnil \\<Rightarrow> f | x :@ xs \\<Rightarrow> g\\<cdot>x\\<cdot>xs);\n        SetMem\\<cdot>aa\\<cdot>(exceptR\\<cdot>w) = FF\\<rbrakk>\n       \\<Longrightarrow> (case If SetMem\\<cdot>aa\\<cdot>(exceptR\\<cdot>w)\n                               then ldropWhile\\<cdot>\n                                    (\\<Lambda> x.\n  SetMem\\<cdot>x\\<cdot>(exceptR\\<cdot>w))\\<cdot>\n                                    llista\n                               else aa :@ llista of\n                          lnil \\<Rightarrow> f\n                          | x :@ xs \\<Rightarrow>\n                              g\\<cdot>x\\<cdot>\n                              (lfilter\\<cdot>\n                               (\\<Lambda> v.\n                                   neg\\<cdot>\n                                   (SetMem\\<cdot>v\\<cdot>\n                                    (exceptR\\<cdot>w)))\\<cdot>\n                               xs)) =\n                         (case If neg\\<cdot>\n                                  (SetMem\\<cdot>aa\\<cdot>(exceptR\\<cdot>w))\n                               then aa :@\n                                    lfilter\\<cdot>\n                                    (\\<Lambda> v.\n  neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n                                    llista\n                               else lfilter\\<cdot>\n                                    (\\<Lambda> v.\n  neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>w)))\\<cdot>\n                                    llista of\n                          lnil \\<Rightarrow> f\n                          | x :@ xs \\<Rightarrow> g\\<cdot>x\\<cdot>xs)", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (case ldropWhile\\<cdot>\n        (\\<Lambda> x. SetMem\\<cdot>x\\<cdot>(exceptR\\<cdot>w))\\<cdot>\n        (resultR\\<cdot>w) of\n   lnil \\<Rightarrow> f\n   | x :@ xs \\<Rightarrow>\n       g\\<cdot>x\\<cdot>(a2c\\<cdot>(R\\<cdot>xs\\<cdot>(exceptR\\<cdot>w)))) =\n  (case a2c\\<cdot>w of lnil \\<Rightarrow> f\n   | x :@ xs \\<Rightarrow> g\\<cdot>x\\<cdot>xs)\n\ngoal (1 subgoal):\n 1. (case a2c\\<cdot>w of lnil \\<Rightarrow> f\n     | x :@ xs \\<Rightarrow> g\\<cdot>x\\<cdot>xs) =\n    (case nextR\\<cdot>w of Nothing \\<Rightarrow> f\n     | Just\\<cdot>(x, r) \\<Rightarrow> g\\<cdot>x\\<cdot>(a2c\\<cdot>r))", "finally"], ["proof (chain)\npicking this:\n  (case nextR\\<cdot>w of Nothing \\<Rightarrow> f\n   | Just\\<cdot>(x, r) \\<Rightarrow> g\\<cdot>x\\<cdot>(a2c\\<cdot>r)) =\n  (case a2c\\<cdot>w of lnil \\<Rightarrow> f\n   | x :@ xs \\<Rightarrow> g\\<cdot>x\\<cdot>xs)", "show \"?lhs = ?rhs\""], ["proof (prove)\nusing this:\n  (case nextR\\<cdot>w of Nothing \\<Rightarrow> f\n   | Just\\<cdot>(x, r) \\<Rightarrow> g\\<cdot>x\\<cdot>(a2c\\<cdot>r)) =\n  (case a2c\\<cdot>w of lnil \\<Rightarrow> f\n   | x :@ xs \\<Rightarrow> g\\<cdot>x\\<cdot>xs)\n\ngoal (1 subgoal):\n 1. (case a2c\\<cdot>w of lnil \\<Rightarrow> f\n     | x :@ xs \\<Rightarrow> g\\<cdot>x\\<cdot>xs) =\n    (case nextR\\<cdot>w of Nothing \\<Rightarrow> f\n     | Just\\<cdot>(x, r) \\<Rightarrow> g\\<cdot>x\\<cdot>(a2c\\<cdot>r))", "by simp"], ["proof (state)\nthis:\n  (case a2c\\<cdot>w of lnil \\<Rightarrow> f\n   | x :@ xs \\<Rightarrow> g\\<cdot>x\\<cdot>xs) =\n  (case nextR\\<cdot>w of Nothing \\<Rightarrow> f\n   | Just\\<cdot>(x, r) \\<Rightarrow> g\\<cdot>x\\<cdot>(a2c\\<cdot>r))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma filter_filterR: \"lfilter\\<cdot>(neg oo (\\<Lambda> y. x =\\<^sub>B y))\\<cdot>(a2c\\<cdot>r) = a2c\\<cdot>(filterR\\<cdot>x\\<cdot>r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfilter\\<cdot>(neg oo Abs_cfun ((=\\<^sub>B) x))\\<cdot>(a2c\\<cdot>r) =\n    a2c\\<cdot>(filterR\\<cdot>x\\<cdot>r)", "using filter_filter[where p=\"Tr.neg oo (\\<Lambda> y. x =\\<^sub>B y)\" and q=\"\\<Lambda> v. Tr.neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>r))\"]"], ["proof (prove)\nusing this:\n  lfilter\\<cdot>(neg oo Abs_cfun ((=\\<^sub>B) x))\\<cdot>\n  (lfilter\\<cdot>\n   (\\<Lambda> v. neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>r)))\\<cdot>\n   ?xs) =\n  lfilter\\<cdot>\n  (\\<Lambda> xa.\n      (\\<Lambda> v.\n          neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>r)))\\<cdot>\n      xa andalso (neg oo Abs_cfun ((=\\<^sub>B) x))\\<cdot>xa)\\<cdot>\n  ?xs\n\ngoal (1 subgoal):\n 1. lfilter\\<cdot>(neg oo Abs_cfun ((=\\<^sub>B) x))\\<cdot>(a2c\\<cdot>r) =\n    a2c\\<cdot>(filterR\\<cdot>x\\<cdot>r)", "unfolding a2c_def filterR_def"], ["proof (prove)\nusing this:\n  lfilter\\<cdot>(neg oo Abs_cfun ((=\\<^sub>B) x))\\<cdot>\n  (lfilter\\<cdot>\n   (\\<Lambda> v. neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>r)))\\<cdot>\n   ?xs) =\n  lfilter\\<cdot>\n  (\\<Lambda> xa.\n      (\\<Lambda> v.\n          neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>r)))\\<cdot>\n      xa andalso (neg oo Abs_cfun ((=\\<^sub>B) x))\\<cdot>xa)\\<cdot>\n  ?xs\n\ngoal (1 subgoal):\n 1. lfilter\\<cdot>(neg oo Abs_cfun ((=\\<^sub>B) x))\\<cdot>\n    ((\\<Lambda> r.\n         lfilter\\<cdot>\n         (\\<Lambda> v.\n             neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>r)))\\<cdot>\n         (resultR\\<cdot>r))\\<cdot>\n     r) =\n    (\\<Lambda> r.\n        lfilter\\<cdot>\n        (\\<Lambda> v.\n            neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>r)))\\<cdot>\n        (resultR\\<cdot>r))\\<cdot>\n    ((\\<Lambda> v r.\n         R\\<cdot>(resultR\\<cdot>r)\\<cdot>\n         (SetInsert\\<cdot>v\\<cdot>(exceptR\\<cdot>r)))\\<cdot>\n     x\\<cdot>\n     r)", "by (cases r, simp_all add: SetMem_SetInsert TR_deMorgan)"], ["", "text\\<open>Apply worker/wrapper. Unlike Gill/Hutton, we manipulate the body of\nthe worker into the right form then apply the lemma.\\<close>"], ["", "definition\n  nub_body' :: \"(R \\<rightarrow> Nat llist) \\<rightarrow> R \\<rightarrow> Nat llist\" where\n  \"nub_body' \\<equiv> \\<Lambda> f r. case a2c\\<cdot>r of lnil \\<Rightarrow> lnil\n                                   | x :@ xs \\<Rightarrow> x :@ f\\<cdot>(c2a\\<cdot>(lfilter\\<cdot>(neg oo (\\<Lambda> y. x =\\<^sub>B y))\\<cdot>xs))\""], ["", "lemma nub_body_nub_body'_eq: \"unwrap oo nub_body oo wrap = nub_body'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unwrap oo nub_body oo wrap = nub_body'", "unfolding nub_body_def nub_body'_def unwrap_def wrap_def a2c_def c2a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> f r.\n        f\\<cdot>\n        ((\\<Lambda> r.\n             lfilter\\<cdot>\n             (\\<Lambda> v.\n                 neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>r)))\\<cdot>\n             (resultR\\<cdot>r))\\<cdot>\n         r)) oo\n    (\\<mu> nub_body.\n        \\<Lambda> f v.\n           Fixrec.run\\<cdot>\n           (match_lnil\\<cdot>v\\<cdot>(Fixrec.succeed\\<cdot>lnil) +++\n            match_lcons\\<cdot>v\\<cdot>\n            (\\<Lambda> x xs.\n                Fixrec.succeed\\<cdot>\n                (x :@\n                 f\\<cdot>\n                 (lfilter\\<cdot>(neg oo Abs_cfun ((=\\<^sub>B) x))\\<cdot>\n                  xs))))) oo\n    (\\<Lambda> f xs.\n        f\\<cdot>((\\<Lambda> xs. R\\<cdot>xs\\<cdot>SetEmpty)\\<cdot>xs)) =\n    (\\<Lambda> f r.\n        case (\\<Lambda> r.\n                 lfilter\\<cdot>\n                 (\\<Lambda> v.\n                     neg\\<cdot>\n                     (SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>r)))\\<cdot>\n                 (resultR\\<cdot>r))\\<cdot>\n             r of\n        lnil \\<Rightarrow> lnil\n        | x :@ xs \\<Rightarrow>\n            x :@\n            f\\<cdot>\n            ((\\<Lambda> xs. R\\<cdot>xs\\<cdot>SetEmpty)\\<cdot>\n             (lfilter\\<cdot>(neg oo Abs_cfun ((=\\<^sub>B) x))\\<cdot>xs)))", "by ((rule cfun_eqI)+\n     , case_tac \"lfilter\\<cdot>(\\<Lambda> v. Tr.neg\\<cdot>(SetMem\\<cdot>v\\<cdot>(exceptR\\<cdot>xa)))\\<cdot>(resultR\\<cdot>xa)\"\n     , simp_all add: fix_const)"], ["", "definition\n  nub_body'' :: \"(R \\<rightarrow> Nat llist) \\<rightarrow> R \\<rightarrow> Nat llist\" where\n  \"nub_body'' \\<equiv> \\<Lambda> f r. case nextR\\<cdot>r of Nothing \\<Rightarrow> lnil\n                                      | Just\\<cdot>(x, xs) \\<Rightarrow> x :@ f\\<cdot>(c2a\\<cdot>(lfilter\\<cdot>(neg oo (\\<Lambda> y. x =\\<^sub>B y))\\<cdot>(a2c\\<cdot>xs)))\""], ["", "lemma nub_body'_nub_body''_eq: \"nub_body' = nub_body''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nub_body' = nub_body''", "proof(rule cfun_eqI)+"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. nub_body'\\<cdot>x\\<cdot>xa = nub_body''\\<cdot>x\\<cdot>xa", "fix f r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. nub_body'\\<cdot>x\\<cdot>xa = nub_body''\\<cdot>x\\<cdot>xa", "show \"nub_body'\\<cdot>f\\<cdot>r = nub_body''\\<cdot>f\\<cdot>r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nub_body'\\<cdot>f\\<cdot>r = nub_body''\\<cdot>f\\<cdot>r", "unfolding nub_body'_def nub_body''_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> f r.\n        case a2c\\<cdot>r of lnil \\<Rightarrow> lnil\n        | x :@ xs \\<Rightarrow>\n            x :@\n            f\\<cdot>\n            (c2a\\<cdot>\n             (lfilter\\<cdot>(neg oo Abs_cfun ((=\\<^sub>B) x))\\<cdot>\n              xs)))\\<cdot>\n    f\\<cdot>\n    r =\n    (\\<Lambda> f r.\n        case nextR\\<cdot>r of Nothing \\<Rightarrow> lnil\n        | Just\\<cdot>(x, xs) \\<Rightarrow>\n            x :@\n            f\\<cdot>\n            (c2a\\<cdot>\n             (lfilter\\<cdot>(neg oo Abs_cfun ((=\\<^sub>B) x))\\<cdot>\n              (a2c\\<cdot>xs))))\\<cdot>\n    f\\<cdot>\n    r", "using case_a2c_case_caseR[where f=\"lnil\" and g=\"\\<Lambda> x xs. x :@ f\\<cdot>(c2a\\<cdot>(lfilter\\<cdot>(Tr.neg oo (\\<Lambda> y. x =\\<^sub>B y))\\<cdot>xs))\" and w=\"r\"]"], ["proof (prove)\nusing this:\n  (case a2c\\<cdot>r of lnil \\<Rightarrow> lnil\n   | x :@ xs \\<Rightarrow>\n       (\\<Lambda> x xs.\n           x :@\n           f\\<cdot>\n           (c2a\\<cdot>\n            (lfilter\\<cdot>(neg oo Abs_cfun ((=\\<^sub>B) x))\\<cdot>\n             xs)))\\<cdot>\n       x\\<cdot>\n       xs) =\n  (case nextR\\<cdot>r of Nothing \\<Rightarrow> lnil\n   | Just\\<cdot>(x, r) \\<Rightarrow>\n       (\\<Lambda> x xs.\n           x :@\n           f\\<cdot>\n           (c2a\\<cdot>\n            (lfilter\\<cdot>(neg oo Abs_cfun ((=\\<^sub>B) x))\\<cdot>\n             xs)))\\<cdot>\n       x\\<cdot>\n       (a2c\\<cdot>r))\n\ngoal (1 subgoal):\n 1. (\\<Lambda> f r.\n        case a2c\\<cdot>r of lnil \\<Rightarrow> lnil\n        | x :@ xs \\<Rightarrow>\n            x :@\n            f\\<cdot>\n            (c2a\\<cdot>\n             (lfilter\\<cdot>(neg oo Abs_cfun ((=\\<^sub>B) x))\\<cdot>\n              xs)))\\<cdot>\n    f\\<cdot>\n    r =\n    (\\<Lambda> f r.\n        case nextR\\<cdot>r of Nothing \\<Rightarrow> lnil\n        | Just\\<cdot>(x, xs) \\<Rightarrow>\n            x :@\n            f\\<cdot>\n            (c2a\\<cdot>\n             (lfilter\\<cdot>(neg oo Abs_cfun ((=\\<^sub>B) x))\\<cdot>\n              (a2c\\<cdot>xs))))\\<cdot>\n    f\\<cdot>\n    r", "by simp"], ["proof (state)\nthis:\n  nub_body'\\<cdot>f\\<cdot>r = nub_body''\\<cdot>f\\<cdot>r\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  nub_body''' :: \"(R \\<rightarrow> Nat llist) \\<rightarrow> R \\<rightarrow> Nat llist\" where\n  \"nub_body''' \\<equiv> (\\<Lambda> f r. case nextR\\<cdot>r of Nothing \\<Rightarrow> lnil\n                                      | Just\\<cdot>(x, xs) \\<Rightarrow> x :@ f\\<cdot>(filterR\\<cdot>x\\<cdot>xs))\""], ["", "lemma nub_body''_nub_body'''_eq: \"nub_body'' = nub_body''' oo (unwrap oo wrap)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nub_body'' = nub_body''' oo unwrap oo wrap", "unfolding nub_body''_def nub_body'''_def wrap_def unwrap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> f r.\n        case nextR\\<cdot>r of Nothing \\<Rightarrow> lnil\n        | Just\\<cdot>(x, xs) \\<Rightarrow>\n            x :@\n            f\\<cdot>\n            (c2a\\<cdot>\n             (lfilter\\<cdot>(neg oo Abs_cfun ((=\\<^sub>B) x))\\<cdot>\n              (a2c\\<cdot>xs)))) =\n    (\\<Lambda> f r.\n        case nextR\\<cdot>r of Nothing \\<Rightarrow> lnil\n        | Just\\<cdot>(x, xs) \\<Rightarrow>\n            x :@ f\\<cdot>(filterR\\<cdot>x\\<cdot>xs)) oo\n    (\\<Lambda> f r. f\\<cdot>(a2c\\<cdot>r)) oo\n    (\\<Lambda> f xs. f\\<cdot>(c2a\\<cdot>xs))", "by ((rule cfun_eqI)+, simp add: filter_filterR)"], ["", "text\\<open>Finally glue it all together.\\<close>"], ["", "lemma nub_wrap_nub_body''': \"nub = wrap\\<cdot>(fix\\<cdot>nub_body''')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nub = wrap\\<cdot>(fix\\<cdot>nub_body''')", "using worker_wrapper_fusion_new[OF wrap_unwrap_id unwrap_strict, where body=nub_body]\n        nub_nub_body_eq\n        nub_body_nub_body'_eq\n        nub_body'_nub_body''_eq\n        nub_body''_nub_body'''_eq"], ["proof (prove)\nusing this:\n  unwrap oo nub_body oo wrap = ?body' oo unwrap oo wrap \\<Longrightarrow>\n  fix\\<cdot>nub_body = wrap\\<cdot>(fix\\<cdot>?body')\n  nub = fix\\<cdot>nub_body\n  unwrap oo nub_body oo wrap = nub_body'\n  nub_body' = nub_body''\n  nub_body'' = nub_body''' oo unwrap oo wrap\n\ngoal (1 subgoal):\n 1. nub = wrap\\<cdot>(fix\\<cdot>nub_body''')", "by simp"], ["", "end"]]}