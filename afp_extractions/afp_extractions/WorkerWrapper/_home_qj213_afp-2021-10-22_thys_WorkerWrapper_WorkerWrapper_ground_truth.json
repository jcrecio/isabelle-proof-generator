{"file_name": "/home/qj213/afp-2021-10-22/thys/WorkerWrapper/WorkerWrapper.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/WorkerWrapper", "problem_names": ["lemma worker_wrapper_id:\n  fixes wrap :: \"'b::pcpo \\<rightarrow> 'a::pcpo\"\n  fixes unwrap :: \"'a \\<rightarrow> 'b\"\n  assumes wrap_unwrap: \"wrap oo unwrap = ID\"\n  assumes comp_body: \"computation = fix\\<cdot>body\"\n  shows \"computation = wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))\"", "lemma worker_wrapper_body:\n  fixes wrap :: \"'b::pcpo \\<rightarrow> 'a::pcpo\"\n  fixes unwrap :: \"'a \\<rightarrow> 'b\"\n  assumes wrap_unwrap: \"wrap oo unwrap oo body = body\"\n  assumes comp_body: \"computation = fix\\<cdot>body\"\n  shows \"computation = wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))\"", "lemma worker_wrapper_fix:\n  fixes wrap :: \"'b::pcpo \\<rightarrow> 'a::pcpo\"\n  fixes unwrap :: \"'a \\<rightarrow> 'b\"\n  assumes wrap_unwrap: \"fix\\<cdot>(wrap oo unwrap oo body) = fix\\<cdot>body\"\n  assumes comp_body: \"computation = fix\\<cdot>body\"\n  shows \"computation = wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))\"", "lemma worker_wrapper_fusion:\n  fixes wrap :: \"'b::pcpo \\<rightarrow> 'a::pcpo\"\n  fixes unwrap :: \"'a \\<rightarrow> 'b\"\n  assumes wrap_unwrap: \"wrap oo unwrap = ID\"\n  assumes work: \"work = fix\\<cdot>(unwrap oo body oo wrap)\"\n  shows \"(unwrap oo wrap)\\<cdot>work = work\""], "translations": [["", "lemma worker_wrapper_id:\n  fixes wrap :: \"'b::pcpo \\<rightarrow> 'a::pcpo\"\n  fixes unwrap :: \"'a \\<rightarrow> 'b\"\n  assumes wrap_unwrap: \"wrap oo unwrap = ID\"\n  assumes comp_body: \"computation = fix\\<cdot>body\"\n  shows \"computation = wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. computation = wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. computation = wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))", "from comp_body"], ["proof (chain)\npicking this:\n  computation = fix\\<cdot>body", "have \"computation = fix\\<cdot>(ID oo body)\""], ["proof (prove)\nusing this:\n  computation = fix\\<cdot>body\n\ngoal (1 subgoal):\n 1. computation = fix\\<cdot>(ID oo body)", "by simp"], ["proof (state)\nthis:\n  computation = fix\\<cdot>(ID oo body)\n\ngoal (1 subgoal):\n 1. computation = wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))", "also"], ["proof (state)\nthis:\n  computation = fix\\<cdot>(ID oo body)\n\ngoal (1 subgoal):\n 1. computation = wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))", "from wrap_unwrap"], ["proof (chain)\npicking this:\n  wrap oo unwrap = ID", "have \"\\<dots> = fix\\<cdot>(wrap oo unwrap oo body)\""], ["proof (prove)\nusing this:\n  wrap oo unwrap = ID\n\ngoal (1 subgoal):\n 1. fix\\<cdot>(ID oo body) = fix\\<cdot>(wrap oo unwrap oo body)", "by (simp add: assoc_oo)"], ["proof (state)\nthis:\n  fix\\<cdot>(ID oo body) = fix\\<cdot>(wrap oo unwrap oo body)\n\ngoal (1 subgoal):\n 1. computation = wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))", "also"], ["proof (state)\nthis:\n  fix\\<cdot>(ID oo body) = fix\\<cdot>(wrap oo unwrap oo body)\n\ngoal (1 subgoal):\n 1. computation = wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))", "have \"... = wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fix\\<cdot>(wrap oo unwrap oo body) =\n    wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))", "using rolling_rule[where f=\"unwrap oo body\" and g=\"wrap\"]"], ["proof (prove)\nusing this:\n  fix\\<cdot>(wrap oo unwrap oo body) =\n  wrap\\<cdot>(fix\\<cdot>((unwrap oo body) oo wrap))\n\ngoal (1 subgoal):\n 1. fix\\<cdot>(wrap oo unwrap oo body) =\n    wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))", "by (simp add: assoc_oo)"], ["proof (state)\nthis:\n  fix\\<cdot>(wrap oo unwrap oo body) =\n  wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))\n\ngoal (1 subgoal):\n 1. computation = wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))", "finally"], ["proof (chain)\npicking this:\n  computation = wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))", "show ?thesis"], ["proof (prove)\nusing this:\n  computation = wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))\n\ngoal (1 subgoal):\n 1. computation = wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))", "."], ["proof (state)\nthis:\n  computation = wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n\nThe second weakens this assumption by requiring that @{term \"wrap oo\nwrap\"} only act as the identity on values in the image of @{term\n\"body\"}.\n\n\\<close>"], ["", "lemma worker_wrapper_body:\n  fixes wrap :: \"'b::pcpo \\<rightarrow> 'a::pcpo\"\n  fixes unwrap :: \"'a \\<rightarrow> 'b\"\n  assumes wrap_unwrap: \"wrap oo unwrap oo body = body\"\n  assumes comp_body: \"computation = fix\\<cdot>body\"\n  shows \"computation = wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. computation = wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. computation = wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))", "from comp_body"], ["proof (chain)\npicking this:\n  computation = fix\\<cdot>body", "have \"computation = fix\\<cdot>(wrap oo unwrap oo body)\""], ["proof (prove)\nusing this:\n  computation = fix\\<cdot>body\n\ngoal (1 subgoal):\n 1. computation = fix\\<cdot>(wrap oo unwrap oo body)", "using wrap_unwrap"], ["proof (prove)\nusing this:\n  computation = fix\\<cdot>body\n  wrap oo unwrap oo body = body\n\ngoal (1 subgoal):\n 1. computation = fix\\<cdot>(wrap oo unwrap oo body)", "by (simp add: assoc_oo wrap_unwrap)"], ["proof (state)\nthis:\n  computation = fix\\<cdot>(wrap oo unwrap oo body)\n\ngoal (1 subgoal):\n 1. computation = wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))", "also"], ["proof (state)\nthis:\n  computation = fix\\<cdot>(wrap oo unwrap oo body)\n\ngoal (1 subgoal):\n 1. computation = wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))", "have \"... = wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fix\\<cdot>(wrap oo unwrap oo body) =\n    wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))", "using rolling_rule[where f=\"unwrap oo body\" and g=\"wrap\"]"], ["proof (prove)\nusing this:\n  fix\\<cdot>(wrap oo unwrap oo body) =\n  wrap\\<cdot>(fix\\<cdot>((unwrap oo body) oo wrap))\n\ngoal (1 subgoal):\n 1. fix\\<cdot>(wrap oo unwrap oo body) =\n    wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))", "by (simp add: assoc_oo)"], ["proof (state)\nthis:\n  fix\\<cdot>(wrap oo unwrap oo body) =\n  wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))\n\ngoal (1 subgoal):\n 1. computation = wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))", "finally"], ["proof (chain)\npicking this:\n  computation = wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))", "show ?thesis"], ["proof (prove)\nusing this:\n  computation = wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))\n\ngoal (1 subgoal):\n 1. computation = wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))", "."], ["proof (state)\nthis:\n  computation = wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n\nThis is particularly useful when the computation being transformed is\nstrict in its argument.\n\nFinally we can allow the identity to take the full recursive context\ninto account. This rule was described by Gill and Hutton but not used.\n\n\\<close>"], ["", "lemma worker_wrapper_fix:\n  fixes wrap :: \"'b::pcpo \\<rightarrow> 'a::pcpo\"\n  fixes unwrap :: \"'a \\<rightarrow> 'b\"\n  assumes wrap_unwrap: \"fix\\<cdot>(wrap oo unwrap oo body) = fix\\<cdot>body\"\n  assumes comp_body: \"computation = fix\\<cdot>body\"\n  shows \"computation = wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. computation = wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. computation = wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))", "from comp_body"], ["proof (chain)\npicking this:\n  computation = fix\\<cdot>body", "have \"computation = fix\\<cdot>(wrap oo unwrap oo body)\""], ["proof (prove)\nusing this:\n  computation = fix\\<cdot>body\n\ngoal (1 subgoal):\n 1. computation = fix\\<cdot>(wrap oo unwrap oo body)", "using wrap_unwrap"], ["proof (prove)\nusing this:\n  computation = fix\\<cdot>body\n  fix\\<cdot>(wrap oo unwrap oo body) = fix\\<cdot>body\n\ngoal (1 subgoal):\n 1. computation = fix\\<cdot>(wrap oo unwrap oo body)", "by (simp add: assoc_oo wrap_unwrap)"], ["proof (state)\nthis:\n  computation = fix\\<cdot>(wrap oo unwrap oo body)\n\ngoal (1 subgoal):\n 1. computation = wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))", "also"], ["proof (state)\nthis:\n  computation = fix\\<cdot>(wrap oo unwrap oo body)\n\ngoal (1 subgoal):\n 1. computation = wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))", "have \"... = wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fix\\<cdot>(wrap oo unwrap oo body) =\n    wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))", "using rolling_rule[where f=\"unwrap oo body\" and g=\"wrap\"]"], ["proof (prove)\nusing this:\n  fix\\<cdot>(wrap oo unwrap oo body) =\n  wrap\\<cdot>(fix\\<cdot>((unwrap oo body) oo wrap))\n\ngoal (1 subgoal):\n 1. fix\\<cdot>(wrap oo unwrap oo body) =\n    wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))", "by (simp add: assoc_oo)"], ["proof (state)\nthis:\n  fix\\<cdot>(wrap oo unwrap oo body) =\n  wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))\n\ngoal (1 subgoal):\n 1. computation = wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))", "finally"], ["proof (chain)\npicking this:\n  computation = wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))", "show ?thesis"], ["proof (prove)\nusing this:\n  computation = wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))\n\ngoal (1 subgoal):\n 1. computation = wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))", "."], ["proof (state)\nthis:\n  computation = wrap\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n\nGill and Hutton's \\<open>worker_wrapper_fusion\\<close> rule is intended to\nallow the transformation of @{term \"(unwrap oo wrap)\\<cdot>R\"} to @{term\n\"R\"} in recursive contexts, where @{term \"R\"} is meant to be a\nself-call. Note that it assumes that the first worker/wrapper\nhypothesis can be established.\n\n\\<close>"], ["", "lemma worker_wrapper_fusion:\n  fixes wrap :: \"'b::pcpo \\<rightarrow> 'a::pcpo\"\n  fixes unwrap :: \"'a \\<rightarrow> 'b\"\n  assumes wrap_unwrap: \"wrap oo unwrap = ID\"\n  assumes work: \"work = fix\\<cdot>(unwrap oo body oo wrap)\"\n  shows \"(unwrap oo wrap)\\<cdot>work = work\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (unwrap oo wrap)\\<cdot>work = work", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (unwrap oo wrap)\\<cdot>work = work", "have \"(unwrap oo wrap)\\<cdot>work = (unwrap oo wrap)\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (unwrap oo wrap)\\<cdot>work =\n    (unwrap oo wrap)\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))", "using work"], ["proof (prove)\nusing this:\n  work = fix\\<cdot>(unwrap oo body oo wrap)\n\ngoal (1 subgoal):\n 1. (unwrap oo wrap)\\<cdot>work =\n    (unwrap oo wrap)\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))", "by simp"], ["proof (state)\nthis:\n  (unwrap oo wrap)\\<cdot>work =\n  (unwrap oo wrap)\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))\n\ngoal (1 subgoal):\n 1. (unwrap oo wrap)\\<cdot>work = work", "also"], ["proof (state)\nthis:\n  (unwrap oo wrap)\\<cdot>work =\n  (unwrap oo wrap)\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap))\n\ngoal (1 subgoal):\n 1. (unwrap oo wrap)\\<cdot>work = work", "have \"\\<dots> = (unwrap oo wrap)\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap oo unwrap oo wrap))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (unwrap oo wrap)\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap)) =\n    (unwrap oo wrap)\\<cdot>\n    (fix\\<cdot>(unwrap oo body oo wrap oo unwrap oo wrap))", "using wrap_unwrap"], ["proof (prove)\nusing this:\n  wrap oo unwrap = ID\n\ngoal (1 subgoal):\n 1. (unwrap oo wrap)\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap)) =\n    (unwrap oo wrap)\\<cdot>\n    (fix\\<cdot>(unwrap oo body oo wrap oo unwrap oo wrap))", "by (simp add: assoc_oo)"], ["proof (state)\nthis:\n  (unwrap oo wrap)\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap)) =\n  (unwrap oo wrap)\\<cdot>\n  (fix\\<cdot>(unwrap oo body oo wrap oo unwrap oo wrap))\n\ngoal (1 subgoal):\n 1. (unwrap oo wrap)\\<cdot>work = work", "also"], ["proof (state)\nthis:\n  (unwrap oo wrap)\\<cdot>(fix\\<cdot>(unwrap oo body oo wrap)) =\n  (unwrap oo wrap)\\<cdot>\n  (fix\\<cdot>(unwrap oo body oo wrap oo unwrap oo wrap))\n\ngoal (1 subgoal):\n 1. (unwrap oo wrap)\\<cdot>work = work", "have \"\\<dots> = fix\\<cdot>(unwrap oo wrap oo unwrap oo body oo wrap)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (unwrap oo wrap)\\<cdot>\n    (fix\\<cdot>(unwrap oo body oo wrap oo unwrap oo wrap)) =\n    fix\\<cdot>(unwrap oo wrap oo unwrap oo body oo wrap)", "using rolling_rule[where f=\"unwrap oo body oo wrap\" and g=\"unwrap oo wrap\"]"], ["proof (prove)\nusing this:\n  fix\\<cdot>((unwrap oo wrap) oo unwrap oo body oo wrap) =\n  (unwrap oo wrap)\\<cdot>\n  (fix\\<cdot>((unwrap oo body oo wrap) oo unwrap oo wrap))\n\ngoal (1 subgoal):\n 1. (unwrap oo wrap)\\<cdot>\n    (fix\\<cdot>(unwrap oo body oo wrap oo unwrap oo wrap)) =\n    fix\\<cdot>(unwrap oo wrap oo unwrap oo body oo wrap)", "by (simp add: assoc_oo)"], ["proof (state)\nthis:\n  (unwrap oo wrap)\\<cdot>\n  (fix\\<cdot>(unwrap oo body oo wrap oo unwrap oo wrap)) =\n  fix\\<cdot>(unwrap oo wrap oo unwrap oo body oo wrap)\n\ngoal (1 subgoal):\n 1. (unwrap oo wrap)\\<cdot>work = work", "also"], ["proof (state)\nthis:\n  (unwrap oo wrap)\\<cdot>\n  (fix\\<cdot>(unwrap oo body oo wrap oo unwrap oo wrap)) =\n  fix\\<cdot>(unwrap oo wrap oo unwrap oo body oo wrap)\n\ngoal (1 subgoal):\n 1. (unwrap oo wrap)\\<cdot>work = work", "have \"\\<dots> = fix\\<cdot>(unwrap oo body oo wrap)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fix\\<cdot>(unwrap oo wrap oo unwrap oo body oo wrap) =\n    fix\\<cdot>(unwrap oo body oo wrap)", "using wrap_unwrap"], ["proof (prove)\nusing this:\n  wrap oo unwrap = ID\n\ngoal (1 subgoal):\n 1. fix\\<cdot>(unwrap oo wrap oo unwrap oo body oo wrap) =\n    fix\\<cdot>(unwrap oo body oo wrap)", "by (simp add: assoc_oo)"], ["proof (state)\nthis:\n  fix\\<cdot>(unwrap oo wrap oo unwrap oo body oo wrap) =\n  fix\\<cdot>(unwrap oo body oo wrap)\n\ngoal (1 subgoal):\n 1. (unwrap oo wrap)\\<cdot>work = work", "finally"], ["proof (chain)\npicking this:\n  (unwrap oo wrap)\\<cdot>work = fix\\<cdot>(unwrap oo body oo wrap)", "show ?thesis"], ["proof (prove)\nusing this:\n  (unwrap oo wrap)\\<cdot>work = fix\\<cdot>(unwrap oo body oo wrap)\n\ngoal (1 subgoal):\n 1. (unwrap oo wrap)\\<cdot>work = work", "using work"], ["proof (prove)\nusing this:\n  (unwrap oo wrap)\\<cdot>work = fix\\<cdot>(unwrap oo body oo wrap)\n  work = fix\\<cdot>(unwrap oo body oo wrap)\n\ngoal (1 subgoal):\n 1. (unwrap oo wrap)\\<cdot>work = work", "by simp"], ["proof (state)\nthis:\n  (unwrap oo wrap)\\<cdot>work = work\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n\nThe following sections show that this rule only preserves partial\ncorrectness. This is because Gill and Hutton apply it in the context\nof the fold/unfold program transformation framework of\n\\citet*{BurstallDarlington:1977}, which need not preserve termination.\nWe show that the fusion rule does in fact require extra conditions to\nbe totally correct and propose one such sufficient condition.\n\n\n\\<close>"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}