{"file_name": "/home/qj213/afp-2021-10-22/thys/WorkerWrapper/Backtracking.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/WorkerWrapper", "problem_names": ["lemma case_expr_cont[cont2cont]:\n  assumes f1: \"\\<And>y. cont (\\<lambda>x. f1 x y)\"\n  assumes f2: \"\\<And>y z. cont (\\<lambda>x. f2 x y z)\"\n  assumes f3: \"\\<And>y z. cont (\\<lambda>x. f3 x y z)\"\n  assumes f4: \"cont (\\<lambda>x. f4 x)\"\n  shows \"cont (\\<lambda>x. case_expr (f1 x) (f2 x) (f3 x) (f4 x) expr)\"", "lemma expr_encode_inj:\n  \"expr_encode x = expr_encode y \\<Longrightarrow> x = y\"", "lemma lappend_strict'[simp]: \"lappend\\<cdot>\\<bottom> = (\\<Lambda> a. \\<bottom>)\"", "lemma lconcat_strict[simp]: \"lconcat\\<cdot>\\<bottom> = \\<bottom>\"", "lemma lmap_strict[simp]: \"lmap\\<cdot>f\\<cdot>\\<bottom> = \\<bottom>\"", "lemma SK_strict[simp]: \"SK\\<cdot>\\<bottom> = \\<bottom>\"", "lemma unwrap_strict[simp]: \"unwrap\\<cdot>\\<bottom> = \\<bottom>\"", "lemma KS_strict[simp]: \"KS\\<cdot>\\<bottom> = \\<bottom>\"", "lemma wrap_strict[simp]: \"wrap\\<cdot>\\<bottom> = \\<bottom>\"", "lemma KS_SK_id:\n  \"KS\\<cdot>(SK\\<cdot>xs) = xs\"", "lemma wrap_unwrap_id:\n  \"wrap oo unwrap = ID\"", "lemma cfun_not_below:\n  \"f\\<cdot>x \\<notsqsubseteq> g\\<cdot>x \\<Longrightarrow> f \\<notsqsubseteq> g\"", "lemma unwrap_wrap_not_under_id:\n  \"unwrap oo wrap \\<notsqsubseteq> ID\"", "lemma \"evalS = eval_ww\"", "lemma SK_returnS_returnK:\n  \"SK\\<cdot>(returnS\\<cdot>x) = returnK\\<cdot>x\"", "lemma SK_lappend_distrib:\n \"SK\\<cdot>(lappend\\<cdot>xs\\<cdot>ys)\\<cdot>s\\<cdot>f = SK\\<cdot>xs\\<cdot>s\\<cdot>(SK\\<cdot>ys\\<cdot>s\\<cdot>f)\"", "lemma SK_bindS_bindK:\n  \"SK\\<cdot>(bindS\\<cdot>x\\<cdot>g) = bindK\\<cdot>(SK\\<cdot>x)\\<cdot>(SK oo g)\"", "lemma SK_addS_distrib:\n  \"SK\\<cdot>(addS\\<cdot>x\\<cdot>y) = addK\\<cdot>(SK\\<cdot>x)\\<cdot>(SK\\<cdot>y)\"", "lemma SK_disjS_disjK:\n \"SK\\<cdot>(disjS\\<cdot>xs\\<cdot>ys) = disjK\\<cdot>(SK\\<cdot>xs)\\<cdot>(SK\\<cdot>ys)\"", "lemma SK_failS_failK:\n  \"SK\\<cdot>failS = failK\"", "lemma evalS_body_evalK_body:\n  \"unwrap oo evalS_body oo wrap = evalK_body oo unwrap oo wrap\"", "theorem evalS_evalK:\n  \"evalS = wrap\\<cdot>evalK\""], "translations": [["", "lemma case_expr_cont[cont2cont]:\n  assumes f1: \"\\<And>y. cont (\\<lambda>x. f1 x y)\"\n  assumes f2: \"\\<And>y z. cont (\\<lambda>x. f2 x y z)\"\n  assumes f3: \"\\<And>y z. cont (\\<lambda>x. f3 x y z)\"\n  assumes f4: \"cont (\\<lambda>x. f4 x)\"\n  shows \"cont (\\<lambda>x. case_expr (f1 x) (f2 x) (f3 x) (f4 x) expr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>x.\n         case expr of const xa \\<Rightarrow> f1 x xa\n         | add xa xb \\<Rightarrow> f2 x xa xb\n         | expr.disj xa xb \\<Rightarrow> f3 x xa xb\n         | fail \\<Rightarrow> f4 x)", "using assms"], ["proof (prove)\nusing this:\n  cont (\\<lambda>x. f1 x ?y)\n  cont (\\<lambda>x. f2 x ?y ?z)\n  cont (\\<lambda>x. f3 x ?y ?z)\n  cont f4\n\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>x.\n         case expr of const xa \\<Rightarrow> f1 x xa\n         | add xa xb \\<Rightarrow> f2 x xa xb\n         | expr.disj xa xb \\<Rightarrow> f3 x xa xb\n         | fail \\<Rightarrow> f4 x)", "by (cases expr) simp_all"], ["", "(* Presumably obsolete in the HG version, not so in Isabelle2011. *)"], ["", "fun\n  expr_encode :: \"expr \\<Rightarrow> nat\"\nwhere\n  \"expr_encode (const n) = prod_encode (0, n)\"\n| \"expr_encode (add e1 e2) = prod_encode (1, (prod_encode (expr_encode e1, expr_encode e2)))\"\n| \"expr_encode (disj e1 e2) = prod_encode (2, (prod_encode (expr_encode e1, expr_encode e2)))\"\n| \"expr_encode fail = prod_encode (3, 0)\""], ["", "lemma expr_encode_inj:\n  \"expr_encode x = expr_encode y \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expr_encode x = expr_encode y \\<Longrightarrow> x = y", "by (induct x arbitrary: y) ((case_tac y, auto dest!: inj_onD[OF inj_prod_encode, where A=UNIV])[1])+"], ["", "instance expr :: countable"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(expr, countable_class)", "by (rule countable_classI[OF expr_encode_inj])"], ["", "(*>*)"], ["", "text\\<open>\n\nThe language consists of constants, an addition function, a\ndisjunctive choice between expressions, and failure. We give it a\ndirect semantics using the monad of lazy lists of natural numbers,\nwith the goal of deriving an an extensionally-equivalent evaluator\nthat uses double-barrelled continuations.\n\nOur theory of lazy lists is entirely standard.\n\n\\<close>"], ["", "default_sort predomain"], ["", "domain 'a llist =\n    lnil\n  | lcons (lazy \"'a\") (lazy \"'a llist\")"], ["", "text\\<open>\n\nBy relaxing the default sort of type variables to \\<open>predomain\\<close>,\nour polymorphic definitions can be used at concrete types that do not\ncontain @{term \"\\<bottom>\"}. These include those constructed from HOL types\nusing the discrete ordering type constructor @{typ \"'a discr\"}, and in\nparticular our interpretation @{typ \"nat discr\"} of the natural\nnumbers.\n\nThe following standard list functions underpin the monadic\ninfrastructure:\n\n\\<close>"], ["", "fixrec lappend :: \"'a llist \\<rightarrow> 'a llist \\<rightarrow> 'a llist\" where\n  \"lappend\\<cdot>lnil\\<cdot>ys = ys\"\n| \"lappend\\<cdot>(lcons\\<cdot>x\\<cdot>xs)\\<cdot>ys = lcons\\<cdot>x\\<cdot>(lappend\\<cdot>xs\\<cdot>ys)\""], ["", "fixrec lconcat :: \"'a llist llist \\<rightarrow> 'a llist\" where\n  \"lconcat\\<cdot>lnil = lnil\"\n| \"lconcat\\<cdot>(lcons\\<cdot>x\\<cdot>xs) = lappend\\<cdot>x\\<cdot>(lconcat\\<cdot>xs)\""], ["", "fixrec lmap :: \"('a \\<rightarrow> 'b) \\<rightarrow> 'a llist \\<rightarrow> 'b llist\" where\n  \"lmap\\<cdot>f\\<cdot>lnil = lnil\"\n| \"lmap\\<cdot>f\\<cdot>(lcons\\<cdot>x\\<cdot>xs) = lcons\\<cdot>(f\\<cdot>x)\\<cdot>(lmap\\<cdot>f\\<cdot>xs)\""], ["", "(*<*)"], ["", "lemma lappend_strict'[simp]: \"lappend\\<cdot>\\<bottom> = (\\<Lambda> a. \\<bottom>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lappend\\<cdot>\\<bottom> = (\\<Lambda> a. \\<bottom>)", "by fixrec_simp"], ["", "lemma lconcat_strict[simp]: \"lconcat\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lconcat\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "lemma lmap_strict[simp]: \"lmap\\<cdot>f\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap\\<cdot>f\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "(*>*)"], ["", "text\\<open>\n\nWe define the lazy list monad \\<open>S\\<close> in the traditional fashion:\n\n\\<close>"], ["", "type_synonym S = \"nat discr llist\""], ["", "definition returnS :: \"nat discr \\<rightarrow> S\" where\n  \"returnS = (\\<Lambda> x. lcons\\<cdot>x\\<cdot>lnil)\""], ["", "definition bindS :: \"S \\<rightarrow> (nat discr \\<rightarrow> S) \\<rightarrow> S\" where\n  \"bindS = (\\<Lambda> x g. lconcat\\<cdot>(lmap\\<cdot>g\\<cdot>x))\""], ["", "text\\<open>\n\nUnfortunately the lack of higher-order polymorphism in HOL prevents us\nfrom providing the general typing one would expect a monad to have in\nHaskell.\n\nThe evaluator uses the following extra constants:\n\n\\<close>"], ["", "definition addS :: \"S \\<rightarrow> S \\<rightarrow> S\" where\n  \"addS \\<equiv> (\\<Lambda> x y. bindS\\<cdot>x\\<cdot>(\\<Lambda> xv. bindS\\<cdot>y\\<cdot>(\\<Lambda> yv. returnS\\<cdot>(xv + yv))))\""], ["", "definition disjS :: \"S \\<rightarrow> S \\<rightarrow> S\" where\n  \"disjS \\<equiv> lappend\""], ["", "definition failS :: \"S\" where\n  \"failS \\<equiv> lnil\""], ["", "text\\<open>\n\nWe interpret our language using these combinators in the obvious\nway. The only complication is that, even though our evaluator is\nprimitive recursive, we must explicitly use the fixed point operator\nas the worker/wrapper technique requires us to talk about the body of\nthe recursive definition.\n\n\\<close>"], ["", "definition\n  evalS_body :: \"(expr discr \\<rightarrow> nat discr llist)\n              \\<rightarrow> (expr discr \\<rightarrow> nat discr llist)\"\nwhere\n  \"evalS_body \\<equiv> \\<Lambda> r e. case undiscr e of\n     const n \\<Rightarrow> returnS\\<cdot>(Discr n)\n   | add e1 e2 \\<Rightarrow> addS\\<cdot>(r\\<cdot>(Discr e1))\\<cdot>(r\\<cdot>(Discr e2))\n   | disj e1 e2 \\<Rightarrow> disjS\\<cdot>(r\\<cdot>(Discr e1))\\<cdot>(r\\<cdot>(Discr e2))\n   | fail \\<Rightarrow> failS\""], ["", "abbreviation evalS :: \"expr discr \\<rightarrow> nat discr llist\" where\n  \"evalS \\<equiv> fix\\<cdot>evalS_body\""], ["", "text\\<open>\n\nWe aim to transform this evaluator into one using double-barrelled\ncontinuations; one will serve as a \"success\" context, taking a natural\nnumber into \"the rest of the computation\", and the other outright\nfailure.\n\nIn general we could work with an arbitrary observation type ala\n\\citet{DBLP:conf/icalp/Reynolds74}, but for convenience we use the\nclearly adequate concrete type @{typ \"nat discr llist\"}.\n\n\\<close>"], ["", "type_synonym Obs = \"nat discr llist\""], ["", "type_synonym Failure = \"Obs\""], ["", "type_synonym Success = \"nat discr \\<rightarrow> Failure \\<rightarrow> Obs\""], ["", "type_synonym K = \"Success \\<rightarrow> Failure \\<rightarrow> Obs\""], ["", "text\\<open>\n\nTo ease our development we adopt what\n\\citet[\\S5]{DBLP:conf/icfp/WandV04} call a \"failure computation\"\ninstead of a failure continuation, which would have the type @{typ\n\"unit \\<rightarrow> Obs\"}.\n\nThe monad over the continuation type @{typ \"K\"} is as follows:\n\n\\<close>"], ["", "definition returnK :: \"nat discr \\<rightarrow> K\" where\n  \"returnK \\<equiv> (\\<Lambda> x. \\<Lambda> s f. s\\<cdot>x\\<cdot>f)\""], ["", "definition bindK :: \"K \\<rightarrow> (nat discr \\<rightarrow> K) \\<rightarrow> K\" where\n  \"bindK \\<equiv> \\<Lambda> x g. \\<Lambda> s f. x\\<cdot>(\\<Lambda> xv f'. g\\<cdot>xv\\<cdot>s\\<cdot>f')\\<cdot>f\""], ["", "text\\<open>\n\nOur extra constants are defined as follows:\n\n\\<close>"], ["", "definition addK :: \"K \\<rightarrow> K \\<rightarrow> K\" where\n  \"addK \\<equiv> (\\<Lambda> x y. bindK\\<cdot>x\\<cdot>(\\<Lambda> xv. bindK\\<cdot>y\\<cdot>(\\<Lambda> yv. returnK\\<cdot>(xv + yv))))\""], ["", "definition disjK :: \"K \\<rightarrow> K \\<rightarrow> K\" where\n  \"disjK \\<equiv> (\\<Lambda> g h. \\<Lambda> s f. g\\<cdot>s\\<cdot>(h\\<cdot>s\\<cdot>f))\""], ["", "definition failK :: \"K\" where\n  \"failK \\<equiv> \\<Lambda> s f. f\""], ["", "text\\<open>\n\nThe continuation semantics is again straightforward:\n\n\\<close>"], ["", "definition\n  evalK_body :: \"(expr discr \\<rightarrow> K) \\<rightarrow> (expr discr \\<rightarrow> K)\"\nwhere\n  \"evalK_body \\<equiv> \\<Lambda> r e. case undiscr e of\n     const n \\<Rightarrow> returnK\\<cdot>(Discr n)\n   | add e1 e2 \\<Rightarrow> addK\\<cdot>(r\\<cdot>(Discr e1))\\<cdot>(r\\<cdot>(Discr e2))\n   | disj e1 e2 \\<Rightarrow> disjK\\<cdot>(r\\<cdot>(Discr e1))\\<cdot>(r\\<cdot>(Discr e2))\n   | fail \\<Rightarrow> failK\""], ["", "abbreviation evalK :: \"expr discr \\<rightarrow> K\" where\n  \"evalK \\<equiv> fix\\<cdot>evalK_body\""], ["", "text\\<open>\n\nWe now set up a worker/wrapper relation between these two semantics.\n\nThe kernel of @{term \"unwrap\"} is the following function that converts\na lazy list into an equivalent continuation representation.\n\n\\<close>"], ["", "fixrec SK :: \"S \\<rightarrow> K\" where\n  \"SK\\<cdot>lnil = failK\"\n| \"SK\\<cdot>(lcons\\<cdot>x\\<cdot>xs) = (\\<Lambda> s f. s\\<cdot>x\\<cdot>(SK\\<cdot>xs\\<cdot>s\\<cdot>f))\""], ["", "definition\n  unwrap :: \"(expr discr \\<rightarrow> nat discr llist) \\<rightarrow> (expr discr \\<rightarrow> K)\"\nwhere\n  \"unwrap \\<equiv> \\<Lambda> r e. SK\\<cdot>(r\\<cdot>e)\""], ["", "(*<*)"], ["", "lemma SK_strict[simp]: \"SK\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SK\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "lemma unwrap_strict[simp]: \"unwrap\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unwrap\\<cdot>\\<bottom> = \\<bottom>", "unfolding unwrap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> r e. SK\\<cdot>(r\\<cdot>e))\\<cdot>\\<bottom> = \\<bottom>", "by simp"], ["", "(*>*)"], ["", "text\\<open>\n\nSymmetrically @{term \"wrap\"} converts an evaluator using continuations\ninto one generating lazy lists by passing it the right continuations.\n\n\\<close>"], ["", "definition KS :: \"K \\<rightarrow> S\" where\n  \"KS \\<equiv> (\\<Lambda> k. k\\<cdot>lcons\\<cdot>lnil)\""], ["", "definition wrap :: \"(expr discr \\<rightarrow> K) \\<rightarrow> (expr discr \\<rightarrow> nat discr llist)\" where\n  \"wrap \\<equiv> \\<Lambda> r e. KS\\<cdot>(r\\<cdot>e)\""], ["", "(*<*)"], ["", "lemma KS_strict[simp]: \"KS\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. KS\\<cdot>\\<bottom> = \\<bottom>", "unfolding KS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> k. k\\<cdot>lcons\\<cdot>lnil)\\<cdot>\\<bottom> = \\<bottom>", "by simp"], ["", "lemma wrap_strict[simp]: \"wrap\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wrap\\<cdot>\\<bottom> = \\<bottom>", "unfolding wrap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> r e. KS\\<cdot>(r\\<cdot>e))\\<cdot>\\<bottom> = \\<bottom>", "by simp"], ["", "(*>*)"], ["", "text\\<open>\n\nThe worker/wrapper condition follows directly from these definitions.\n\n\\<close>"], ["", "lemma KS_SK_id:\n  \"KS\\<cdot>(SK\\<cdot>xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. KS\\<cdot>(SK\\<cdot>xs) = xs", "by (induct xs) (simp_all add: KS_def failK_def)"], ["", "lemma wrap_unwrap_id:\n  \"wrap oo unwrap = ID\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wrap oo unwrap = ID", "unfolding wrap_def unwrap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> r e. KS\\<cdot>(r\\<cdot>e)) oo\n    (\\<Lambda> r e. SK\\<cdot>(r\\<cdot>e)) =\n    ID", "by (simp add: KS_SK_id cfun_eq_iff)"], ["", "text\\<open>\n\nThe worker/wrapper transformation is only non-trivial if @{term\n\"wrap\"} and @{term \"unwrap\"} do not witness an isomorphism. In this\ncase we can show that we do not even have a Galois connection.\n\n\\<close>"], ["", "lemma cfun_not_below:\n  \"f\\<cdot>x \\<notsqsubseteq> g\\<cdot>x \\<Longrightarrow> f \\<notsqsubseteq> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f\\<cdot>x \\<notsqsubseteq> g\\<cdot>x \\<Longrightarrow>\n    f \\<notsqsubseteq> g", "by (auto simp: cfun_below_iff)"], ["", "lemma unwrap_wrap_not_under_id:\n  \"unwrap oo wrap \\<notsqsubseteq> ID\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unwrap oo wrap \\<notsqsubseteq> ID", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. unwrap oo wrap \\<notsqsubseteq> ID", "let ?witness = \"\\<Lambda> e. (\\<Lambda> s f. lnil :: K)\""], ["proof (state)\ngoal (1 subgoal):\n 1. unwrap oo wrap \\<notsqsubseteq> ID", "have \"(unwrap oo wrap)\\<cdot>?witness\\<cdot>(Discr fail)\\<cdot>\\<bottom>\\<cdot>(lcons\\<cdot>0\\<cdot>lnil)\n       \\<notsqsubseteq> ?witness\\<cdot>(Discr fail)\\<cdot>\\<bottom>\\<cdot>(lcons\\<cdot>0\\<cdot>lnil)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (unwrap oo wrap)\\<cdot>(\\<Lambda> e s f. lnil)\\<cdot>(Discr fail)\\<cdot>\n    \\<bottom>\\<cdot>\n    (lcons\\<cdot>0\\<cdot>lnil) \\<notsqsubseteq>\n    (\\<Lambda> e s f. lnil)\\<cdot>(Discr fail)\\<cdot>\\<bottom>\\<cdot>\n    (lcons\\<cdot>0\\<cdot>lnil)", "by (simp add: failK_def wrap_def unwrap_def KS_def)"], ["proof (state)\nthis:\n  (unwrap oo wrap)\\<cdot>(\\<Lambda> e s f. lnil)\\<cdot>(Discr fail)\\<cdot>\n  \\<bottom>\\<cdot>\n  (lcons\\<cdot>0\\<cdot>lnil) \\<notsqsubseteq>\n  (\\<Lambda> e s f. lnil)\\<cdot>(Discr fail)\\<cdot>\\<bottom>\\<cdot>\n  (lcons\\<cdot>0\\<cdot>lnil)\n\ngoal (1 subgoal):\n 1. unwrap oo wrap \\<notsqsubseteq> ID", "hence \"(unwrap oo wrap)\\<cdot>?witness \\<notsqsubseteq> ?witness\""], ["proof (prove)\nusing this:\n  (unwrap oo wrap)\\<cdot>(\\<Lambda> e s f. lnil)\\<cdot>(Discr fail)\\<cdot>\n  \\<bottom>\\<cdot>\n  (lcons\\<cdot>0\\<cdot>lnil) \\<notsqsubseteq>\n  (\\<Lambda> e s f. lnil)\\<cdot>(Discr fail)\\<cdot>\\<bottom>\\<cdot>\n  (lcons\\<cdot>0\\<cdot>lnil)\n\ngoal (1 subgoal):\n 1. (unwrap oo wrap)\\<cdot>(\\<Lambda> e s f. lnil) \\<notsqsubseteq>\n    (\\<Lambda> e s f. lnil)", "by (fastforce intro!: cfun_not_below)"], ["proof (state)\nthis:\n  (unwrap oo wrap)\\<cdot>(\\<Lambda> e s f. lnil) \\<notsqsubseteq>\n  (\\<Lambda> e s f. lnil)\n\ngoal (1 subgoal):\n 1. unwrap oo wrap \\<notsqsubseteq> ID", "thus ?thesis"], ["proof (prove)\nusing this:\n  (unwrap oo wrap)\\<cdot>(\\<Lambda> e s f. lnil) \\<notsqsubseteq>\n  (\\<Lambda> e s f. lnil)\n\ngoal (1 subgoal):\n 1. unwrap oo wrap \\<notsqsubseteq> ID", "by (simp add: cfun_not_below)"], ["proof (state)\nthis:\n  unwrap oo wrap \\<notsqsubseteq> ID\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n\nWe now apply \\texttt{worker\\_wrapper\\_id}:\n\n\\<close>"], ["", "definition eval_work :: \"expr discr \\<rightarrow> K\" where\n  \"eval_work \\<equiv> fix\\<cdot>(unwrap oo evalS_body oo wrap)\""], ["", "definition eval_ww :: \"expr discr \\<rightarrow> nat discr llist\" where\n  \"eval_ww \\<equiv> wrap\\<cdot>eval_work\""], ["", "lemma \"evalS = eval_ww\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalS = eval_ww", "unfolding eval_ww_def eval_work_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. evalS = wrap\\<cdot>(fix\\<cdot>(unwrap oo evalS_body oo wrap))", "using worker_wrapper_id[OF wrap_unwrap_id]"], ["proof (prove)\nusing this:\n  ?computation = fix\\<cdot>?body \\<Longrightarrow>\n  ?computation = wrap\\<cdot>(fix\\<cdot>(unwrap oo ?body oo wrap))\n\ngoal (1 subgoal):\n 1. evalS = wrap\\<cdot>(fix\\<cdot>(unwrap oo evalS_body oo wrap))", "by simp"], ["", "text\\<open>\n\nWe now show how the monadic operations correspond by showing that\n@{term \"SK\"} witnesses a \\emph{monad morphism}\n\\citep[\\S6]{wadler92:_comprehending_monads}. As required by\n\\citet[Definition~2.1]{DBLP:journals/ngc/DanvyGR01}, the mapping needs\nto hold for our specific operations in addition to the common monadic\nscaffolding.\n\n\\<close>"], ["", "lemma SK_returnS_returnK:\n  \"SK\\<cdot>(returnS\\<cdot>x) = returnK\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SK\\<cdot>(returnS\\<cdot>x) = returnK\\<cdot>x", "by (simp add: returnS_def returnK_def failK_def)"], ["", "lemma SK_lappend_distrib:\n \"SK\\<cdot>(lappend\\<cdot>xs\\<cdot>ys)\\<cdot>s\\<cdot>f = SK\\<cdot>xs\\<cdot>s\\<cdot>(SK\\<cdot>ys\\<cdot>s\\<cdot>f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SK\\<cdot>(lappend\\<cdot>xs\\<cdot>ys)\\<cdot>s\\<cdot>f =\n    SK\\<cdot>xs\\<cdot>s\\<cdot>(SK\\<cdot>ys\\<cdot>s\\<cdot>f)", "by (induct xs) (simp_all add: failK_def)"], ["", "lemma SK_bindS_bindK:\n  \"SK\\<cdot>(bindS\\<cdot>x\\<cdot>g) = bindK\\<cdot>(SK\\<cdot>x)\\<cdot>(SK oo g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SK\\<cdot>(bindS\\<cdot>x\\<cdot>g) =\n    bindK\\<cdot>(SK\\<cdot>x)\\<cdot>(SK oo g)", "by (induct x)\n     (simp_all add: cfun_eq_iff\n                    bindS_def bindK_def failK_def\n                    SK_lappend_distrib)"], ["", "lemma SK_addS_distrib:\n  \"SK\\<cdot>(addS\\<cdot>x\\<cdot>y) = addK\\<cdot>(SK\\<cdot>x)\\<cdot>(SK\\<cdot>y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SK\\<cdot>(addS\\<cdot>x\\<cdot>y) =\n    addK\\<cdot>(SK\\<cdot>x)\\<cdot>(SK\\<cdot>y)", "by (clarsimp simp: cfcomp1\n                     addS_def addK_def failK_def\n                     SK_bindS_bindK SK_returnS_returnK)"], ["", "lemma SK_disjS_disjK:\n \"SK\\<cdot>(disjS\\<cdot>xs\\<cdot>ys) = disjK\\<cdot>(SK\\<cdot>xs)\\<cdot>(SK\\<cdot>ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SK\\<cdot>(disjS\\<cdot>xs\\<cdot>ys) =\n    disjK\\<cdot>(SK\\<cdot>xs)\\<cdot>(SK\\<cdot>ys)", "by (simp add: cfun_eq_iff disjS_def disjK_def SK_lappend_distrib)"], ["", "lemma SK_failS_failK:\n  \"SK\\<cdot>failS = failK\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SK\\<cdot>failS = failK", "unfolding failS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. SK\\<cdot>lnil = failK", "by simp"], ["", "text\\<open>\n\nThese lemmas directly establish the precondition for our all-in-one\nworker/wrapper and fusion rule:\n\n\\<close>"], ["", "lemma evalS_body_evalK_body:\n  \"unwrap oo evalS_body oo wrap = evalK_body oo unwrap oo wrap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unwrap oo evalS_body oo wrap = evalK_body oo unwrap oo wrap", "proof(intro cfun_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb xc.\n       (unwrap oo evalS_body oo wrap)\\<cdot>x\\<cdot>xa\\<cdot>xb\\<cdot>xc =\n       (evalK_body oo unwrap oo wrap)\\<cdot>x\\<cdot>xa\\<cdot>xb\\<cdot>xc", "fix r e' s f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb xc.\n       (unwrap oo evalS_body oo wrap)\\<cdot>x\\<cdot>xa\\<cdot>xb\\<cdot>xc =\n       (evalK_body oo unwrap oo wrap)\\<cdot>x\\<cdot>xa\\<cdot>xb\\<cdot>xc", "obtain e :: \"expr\"\n    where ee': \"e' = Discr e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e. e' = Discr e \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases e')"], ["proof (state)\nthis:\n  e' = Discr e\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb xc.\n       (unwrap oo evalS_body oo wrap)\\<cdot>x\\<cdot>xa\\<cdot>xb\\<cdot>xc =\n       (evalK_body oo unwrap oo wrap)\\<cdot>x\\<cdot>xa\\<cdot>xb\\<cdot>xc", "have \"(unwrap oo evalS_body oo wrap)\\<cdot>r\\<cdot>(Discr e)\\<cdot>s\\<cdot>f\n      = (evalK_body oo unwrap oo wrap)\\<cdot>r\\<cdot>(Discr e)\\<cdot>s\\<cdot>f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (unwrap oo evalS_body oo wrap)\\<cdot>r\\<cdot>(Discr e)\\<cdot>s\\<cdot>f =\n    (evalK_body oo unwrap oo wrap)\\<cdot>r\\<cdot>(Discr e)\\<cdot>s\\<cdot>f", "by (cases e)\n       (simp_all add: evalS_body_def evalK_body_def unwrap_def\n                      SK_returnS_returnK SK_addS_distrib\n                      SK_disjS_disjK SK_failS_failK)"], ["proof (state)\nthis:\n  (unwrap oo evalS_body oo wrap)\\<cdot>r\\<cdot>(Discr e)\\<cdot>s\\<cdot>f =\n  (evalK_body oo unwrap oo wrap)\\<cdot>r\\<cdot>(Discr e)\\<cdot>s\\<cdot>f\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb xc.\n       (unwrap oo evalS_body oo wrap)\\<cdot>x\\<cdot>xa\\<cdot>xb\\<cdot>xc =\n       (evalK_body oo unwrap oo wrap)\\<cdot>x\\<cdot>xa\\<cdot>xb\\<cdot>xc", "with ee'"], ["proof (chain)\npicking this:\n  e' = Discr e\n  (unwrap oo evalS_body oo wrap)\\<cdot>r\\<cdot>(Discr e)\\<cdot>s\\<cdot>f =\n  (evalK_body oo unwrap oo wrap)\\<cdot>r\\<cdot>(Discr e)\\<cdot>s\\<cdot>f", "show \"(unwrap oo evalS_body oo wrap)\\<cdot>r\\<cdot>e'\\<cdot>s\\<cdot>f\n                = (evalK_body oo unwrap oo wrap)\\<cdot>r\\<cdot>e'\\<cdot>s\\<cdot>f\""], ["proof (prove)\nusing this:\n  e' = Discr e\n  (unwrap oo evalS_body oo wrap)\\<cdot>r\\<cdot>(Discr e)\\<cdot>s\\<cdot>f =\n  (evalK_body oo unwrap oo wrap)\\<cdot>r\\<cdot>(Discr e)\\<cdot>s\\<cdot>f\n\ngoal (1 subgoal):\n 1. (unwrap oo evalS_body oo wrap)\\<cdot>r\\<cdot>e'\\<cdot>s\\<cdot>f =\n    (evalK_body oo unwrap oo wrap)\\<cdot>r\\<cdot>e'\\<cdot>s\\<cdot>f", "by simp"], ["proof (state)\nthis:\n  (unwrap oo evalS_body oo wrap)\\<cdot>r\\<cdot>e'\\<cdot>s\\<cdot>f =\n  (evalK_body oo unwrap oo wrap)\\<cdot>r\\<cdot>e'\\<cdot>s\\<cdot>f\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem evalS_evalK:\n  \"evalS = wrap\\<cdot>evalK\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalS = wrap\\<cdot>evalK", "using worker_wrapper_fusion_new[OF wrap_unwrap_id unwrap_strict]\n        evalS_body_evalK_body"], ["proof (prove)\nusing this:\n  unwrap oo ?body oo wrap = ?body' oo unwrap oo wrap \\<Longrightarrow>\n  fix\\<cdot>?body = wrap\\<cdot>(fix\\<cdot>?body')\n  unwrap oo evalS_body oo wrap = evalK_body oo unwrap oo wrap\n\ngoal (1 subgoal):\n 1. evalS = wrap\\<cdot>evalK", "by simp"], ["", "text\\<open>\n\nThis proof can be considered an instance of the approach of\n\\citet{DBLP:journals/jfp/HuttonJG10}, which uses the worker/wrapper\nmachinery to relate two algebras.\n\nThis result could be obtained by a structural induction over the\nsyntax of the language. However our goal here is to show how such a\ntransformation can be achieved by purely equational means; this has\nthe advantange that our proof can be locally extended, e.g. to the\nfull language of \\citet{DBLP:journals/ngc/DanvyGR01} simply by proving\nextra equations. In contrast the higher-order language of\n\\citet{DBLP:conf/icfp/WandV04} is beyond the reach of this approach.\n\n\\<close>"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}