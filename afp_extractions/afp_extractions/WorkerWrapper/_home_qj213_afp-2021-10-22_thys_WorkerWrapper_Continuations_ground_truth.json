{"file_name": "/home/qj213/afp-2021-10-22/thys/WorkerWrapper/Continuations.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/WorkerWrapper", "problem_names": ["lemma cont2val_val2cont_id: \"cont2val oo val2cont = ID\"", "lemma eval_body_strictExpr[simp]: \"eval_body\\<cdot>r\\<cdot>\\<bottom> = \\<bottom>\"", "lemma eval_eval_body_eq: \"eval = fix\\<cdot>eval_body\"", "lemma unwrapC_strict[simp]: \"unwrapC\\<cdot>\\<bottom> = \\<bottom>\"", "lemma wrapC_unwrapC_id: \"wrapC oo unwrapC = ID\"", "lemma eval_body'_strictExpr[simp]: \"eval_body'\\<cdot>r\\<cdot>\\<bottom>\\<cdot>s\\<cdot>f = \\<bottom>\"", "lemma eval_body'_eval_body_eq: \"eval_body' = unwrapC oo eval_body oo wrapC\"", "lemma eval_body_final_strictExpr[simp]: \"eval_body_final\\<cdot>r\\<cdot>\\<bottom>\\<cdot>s\\<cdot>f = \\<bottom>\"", "lemma eval_body'_eval_body_final_eq: \"eval_body_final oo unwrapC oo wrapC = eval_body'\"", "lemma \"eval = eval_final\""], "translations": [["", "lemma cont2val_val2cont_id: \"cont2val oo val2cont = ID\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont2val oo val2cont = ID", "by (rule cfun_eqI, simp add: val2cont_def cont2val_def)"], ["", "domain Expr =\n    Val (lazy val::\"Nat\")\n  | Add (lazy addl::\"Expr\") (lazy addr::\"Expr\")\n  | Throw\n  | Catch (lazy cbody::\"Expr\") (lazy chandler::\"Expr\")"], ["", "fixrec eval :: \"Expr \\<rightarrow> Nat Maybe\"\nwhere\n  \"eval\\<cdot>(Val\\<cdot>n) = Just\\<cdot>n\"\n| \"eval\\<cdot>(Add\\<cdot>x\\<cdot>y) = mliftM2 (\\<Lambda> a b. a + b)\\<cdot>(eval\\<cdot>x)\\<cdot>(eval\\<cdot>y)\"\n| \"eval\\<cdot>Throw = mfail\"\n| \"eval\\<cdot>(Catch\\<cdot>x\\<cdot>y) = mcatch\\<cdot>(eval\\<cdot>x)\\<cdot>(eval\\<cdot>y)\""], ["", "fixrec eval_body :: \"(Expr \\<rightarrow> Nat Maybe) \\<rightarrow> Expr \\<rightarrow> Nat Maybe\"\nwhere\n  \"eval_body\\<cdot>r\\<cdot>(Val\\<cdot>n) = Just\\<cdot>n\"\n| \"eval_body\\<cdot>r\\<cdot>(Add\\<cdot>x\\<cdot>y) = mliftM2 (\\<Lambda> a b. a + b)\\<cdot>(r\\<cdot>x)\\<cdot>(r\\<cdot>y)\"\n| \"eval_body\\<cdot>r\\<cdot>Throw = mfail\"\n| \"eval_body\\<cdot>r\\<cdot>(Catch\\<cdot>x\\<cdot>y) = mcatch\\<cdot>(r\\<cdot>x)\\<cdot>(r\\<cdot>y)\""], ["", "lemma eval_body_strictExpr[simp]: \"eval_body\\<cdot>r\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_body\\<cdot>r\\<cdot>\\<bottom> = \\<bottom>", "by (subst eval_body.unfold, simp)"], ["", "lemma eval_eval_body_eq: \"eval = fix\\<cdot>eval_body\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval = fix\\<cdot>eval_body", "by (rule cfun_eqI, subst eval_def, subst eval_body.unfold, simp)"], ["", "subsection\\<open>Worker/wrapper\\<close>"], ["", "definition\n  unwrapC :: \"(Expr \\<rightarrow> Nat Maybe) \\<rightarrow> (Expr \\<rightarrow> (Nat \\<rightarrow> Nat Maybe) \\<rightarrow> Nat Maybe \\<rightarrow> Nat Maybe)\" where\n  \"unwrapC \\<equiv> \\<Lambda> g e s f. case g\\<cdot>e of Nothing \\<Rightarrow> f | Just\\<cdot>n \\<Rightarrow> s\\<cdot>n\""], ["", "lemma unwrapC_strict[simp]: \"unwrapC\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unwrapC\\<cdot>\\<bottom> = \\<bottom>", "unfolding unwrapC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> g e s f.\n        case g\\<cdot>e of Nothing \\<Rightarrow> f\n        | Just\\<cdot>n \\<Rightarrow> s\\<cdot>n)\\<cdot>\n    \\<bottom> =\n    \\<bottom>", "by (rule cfun_eqI)+ simp"], ["", "definition\n  wrapC :: \"(Expr \\<rightarrow> (Nat \\<rightarrow> Nat Maybe) \\<rightarrow> Nat Maybe \\<rightarrow> Nat Maybe) \\<rightarrow> (Expr \\<rightarrow> Nat Maybe)\" where\n  \"wrapC \\<equiv> \\<Lambda> g e. g\\<cdot>e\\<cdot>Just\\<cdot>Nothing\""], ["", "lemma wrapC_unwrapC_id: \"wrapC oo unwrapC = ID\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wrapC oo unwrapC = ID", "proof(intro cfun_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. (wrapC oo unwrapC)\\<cdot>x\\<cdot>xa = ID\\<cdot>x\\<cdot>xa", "fix g e"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. (wrapC oo unwrapC)\\<cdot>x\\<cdot>xa = ID\\<cdot>x\\<cdot>xa", "show \"(wrapC oo unwrapC)\\<cdot>g\\<cdot>e = ID\\<cdot>g\\<cdot>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (wrapC oo unwrapC)\\<cdot>g\\<cdot>e = ID\\<cdot>g\\<cdot>e", "by (cases \"g\\<cdot>e\", simp_all add: wrapC_def unwrapC_def)"], ["proof (state)\nthis:\n  (wrapC oo unwrapC)\\<cdot>g\\<cdot>e = ID\\<cdot>g\\<cdot>e\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  eval_work :: \"Expr \\<rightarrow> (Nat \\<rightarrow> Nat Maybe) \\<rightarrow> Nat Maybe \\<rightarrow> Nat Maybe\" where\n  \"eval_work \\<equiv> fix\\<cdot>(unwrapC oo eval_body oo wrapC)\""], ["", "definition\n  eval_wrap :: \"Expr \\<rightarrow> Nat Maybe\" where\n  \"eval_wrap \\<equiv> wrapC\\<cdot>eval_work\""], ["", "fixrec eval_body' :: \"(Expr \\<rightarrow> (Nat \\<rightarrow> Nat Maybe) \\<rightarrow> Nat Maybe \\<rightarrow> Nat Maybe)\n                    \\<rightarrow> Expr \\<rightarrow> (Nat \\<rightarrow> Nat Maybe) \\<rightarrow> Nat Maybe \\<rightarrow> Nat Maybe\"\nwhere\n  \"eval_body'\\<cdot>r\\<cdot>(Val\\<cdot>n)\\<cdot>s\\<cdot>f = s\\<cdot>n\"\n| \"eval_body'\\<cdot>r\\<cdot>(Add\\<cdot>x\\<cdot>y)\\<cdot>s\\<cdot>f = (case wrapC\\<cdot>r\\<cdot>x of\n                                     Nothing \\<Rightarrow> f\n                                   | Just\\<cdot>n \\<Rightarrow> (case wrapC\\<cdot>r\\<cdot>y of\n                                                    Nothing \\<Rightarrow> f\n                                                  | Just\\<cdot>m \\<Rightarrow> s\\<cdot>(n + m)))\"\n| \"eval_body'\\<cdot>r\\<cdot>Throw\\<cdot>s\\<cdot>f = f\"\n| \"eval_body'\\<cdot>r\\<cdot>(Catch\\<cdot>x\\<cdot>y)\\<cdot>s\\<cdot>f = (case wrapC\\<cdot>r\\<cdot>x of\n                                       Nothing \\<Rightarrow> (case wrapC\\<cdot>r\\<cdot>y of\n                                                      Nothing \\<Rightarrow> f\n                                                    | Just\\<cdot>n \\<Rightarrow> s\\<cdot>n)\n                                     | Just\\<cdot>n \\<Rightarrow> s\\<cdot>n)\""], ["", "lemma eval_body'_strictExpr[simp]: \"eval_body'\\<cdot>r\\<cdot>\\<bottom>\\<cdot>s\\<cdot>f = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_body'\\<cdot>r\\<cdot>\\<bottom>\\<cdot>s\\<cdot>f = \\<bottom>", "by (subst eval_body'.unfold, simp)"], ["", "definition\n  eval_work' :: \"Expr \\<rightarrow> (Nat \\<rightarrow> Nat Maybe) \\<rightarrow> Nat Maybe \\<rightarrow> Nat Maybe\" where\n  \"eval_work' \\<equiv> fix\\<cdot>eval_body'\""], ["", "text\\<open>This proof is unfortunately quite messy, due to the\nsimplifier's inability to cope with HOLCF's case distinctions.\\<close>"], ["", "lemma eval_body'_eval_body_eq: \"eval_body' = unwrapC oo eval_body oo wrapC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_body' = unwrapC oo eval_body oo wrapC", "apply (intro cfun_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb xc.\n       eval_body'\\<cdot>x\\<cdot>xa\\<cdot>xb\\<cdot>xc =\n       (unwrapC oo eval_body oo wrapC)\\<cdot>x\\<cdot>xa\\<cdot>xb\\<cdot>xc", "apply (unfold unwrapC_def wrapC_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb xc.\n       eval_body'\\<cdot>x\\<cdot>xa\\<cdot>xb\\<cdot>xc =\n       ((\\<Lambda> g e s f.\n            case g\\<cdot>e of Nothing \\<Rightarrow> f\n            | Just\\<cdot>n \\<Rightarrow> s\\<cdot>n) oo\n        eval_body oo\n        (\\<Lambda> g e. g\\<cdot>e\\<cdot>Just\\<cdot>Nothing))\\<cdot>\n       x\\<cdot>\n       xa\\<cdot>\n       xb\\<cdot>\n       xc", "apply (case_tac xa)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x xa xb xc.\n       xa = \\<bottom> \\<Longrightarrow>\n       eval_body'\\<cdot>x\\<cdot>xa\\<cdot>xb\\<cdot>xc =\n       ((\\<Lambda> g e s f.\n            case g\\<cdot>e of Nothing \\<Rightarrow> f\n            | Just\\<cdot>n \\<Rightarrow> s\\<cdot>n) oo\n        eval_body oo\n        (\\<Lambda> g e. g\\<cdot>e\\<cdot>Just\\<cdot>Nothing))\\<cdot>\n       x\\<cdot>\n       xa\\<cdot>\n       xb\\<cdot>\n       xc\n 2. \\<And>x xa xb xc Box.\n       xa = Val\\<cdot>Box \\<Longrightarrow>\n       eval_body'\\<cdot>x\\<cdot>xa\\<cdot>xb\\<cdot>xc =\n       ((\\<Lambda> g e s f.\n            case g\\<cdot>e of Nothing \\<Rightarrow> f\n            | Just\\<cdot>n \\<Rightarrow> s\\<cdot>n) oo\n        eval_body oo\n        (\\<Lambda> g e. g\\<cdot>e\\<cdot>Just\\<cdot>Nothing))\\<cdot>\n       x\\<cdot>\n       xa\\<cdot>\n       xb\\<cdot>\n       xc\n 3. \\<And>x xa xb xc Expr1 Expr2.\n       xa = Add\\<cdot>Expr1\\<cdot>Expr2 \\<Longrightarrow>\n       eval_body'\\<cdot>x\\<cdot>xa\\<cdot>xb\\<cdot>xc =\n       ((\\<Lambda> g e s f.\n            case g\\<cdot>e of Nothing \\<Rightarrow> f\n            | Just\\<cdot>n \\<Rightarrow> s\\<cdot>n) oo\n        eval_body oo\n        (\\<Lambda> g e. g\\<cdot>e\\<cdot>Just\\<cdot>Nothing))\\<cdot>\n       x\\<cdot>\n       xa\\<cdot>\n       xb\\<cdot>\n       xc\n 4. \\<And>x xa xb xc.\n       xa = Throw \\<Longrightarrow>\n       eval_body'\\<cdot>x\\<cdot>xa\\<cdot>xb\\<cdot>xc =\n       ((\\<Lambda> g e s f.\n            case g\\<cdot>e of Nothing \\<Rightarrow> f\n            | Just\\<cdot>n \\<Rightarrow> s\\<cdot>n) oo\n        eval_body oo\n        (\\<Lambda> g e. g\\<cdot>e\\<cdot>Just\\<cdot>Nothing))\\<cdot>\n       x\\<cdot>\n       xa\\<cdot>\n       xb\\<cdot>\n       xc\n 5. \\<And>x xa xb xc Expr1 Expr2.\n       xa = Catch\\<cdot>Expr1\\<cdot>Expr2 \\<Longrightarrow>\n       eval_body'\\<cdot>x\\<cdot>xa\\<cdot>xb\\<cdot>xc =\n       ((\\<Lambda> g e s f.\n            case g\\<cdot>e of Nothing \\<Rightarrow> f\n            | Just\\<cdot>n \\<Rightarrow> s\\<cdot>n) oo\n        eval_body oo\n        (\\<Lambda> g e. g\\<cdot>e\\<cdot>Just\\<cdot>Nothing))\\<cdot>\n       x\\<cdot>\n       xa\\<cdot>\n       xb\\<cdot>\n       xc", "apply simp_all"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa xb xc Expr1 Expr2.\n       xa = Add\\<cdot>Expr1\\<cdot>Expr2 \\<Longrightarrow>\n       (case wrapC\\<cdot>x\\<cdot>Expr1 of Nothing \\<Rightarrow> xc\n        | Just\\<cdot>n \\<Rightarrow>\n            case wrapC\\<cdot>x\\<cdot>Expr2 of Nothing \\<Rightarrow> xc\n            | Just\\<cdot>m \\<Rightarrow> xb\\<cdot>(n + m)) =\n       Maybe_case\\<cdot>xc\\<cdot>(Abs_cfun (Rep_cfun xb))\\<cdot>\n       (mliftM2 (\\<Lambda> a. Abs_cfun ((+) a))\\<cdot>\n        (x\\<cdot>Expr1\\<cdot>Just\\<cdot>Nothing)\\<cdot>\n        (x\\<cdot>Expr2\\<cdot>Just\\<cdot>Nothing))\n 2. \\<And>xa xb xc.\n       xa = Throw \\<Longrightarrow>\n       xc = Maybe_case\\<cdot>xc\\<cdot>(Abs_cfun (Rep_cfun xb))\\<cdot>mfail\n 3. \\<And>x xa xb xc Expr1 Expr2.\n       xa = Catch\\<cdot>Expr1\\<cdot>Expr2 \\<Longrightarrow>\n       (case wrapC\\<cdot>x\\<cdot>Expr1 of\n        Nothing \\<Rightarrow>\n          case wrapC\\<cdot>x\\<cdot>Expr2 of Nothing \\<Rightarrow> xc\n          | Just\\<cdot>n \\<Rightarrow> xb\\<cdot>n\n        | Just\\<cdot>n \\<Rightarrow> xb\\<cdot>n) =\n       Maybe_case\\<cdot>xc\\<cdot>(Abs_cfun (Rep_cfun xb))\\<cdot>\n       (mcatch\\<cdot>(x\\<cdot>Expr1\\<cdot>Just\\<cdot>Nothing)\\<cdot>\n        (x\\<cdot>Expr2\\<cdot>Just\\<cdot>Nothing))", "apply (simp add: wrapC_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa xb xc Expr1 Expr2.\n       xa = Add\\<cdot>Expr1\\<cdot>Expr2 \\<Longrightarrow>\n       (case x\\<cdot>Expr1\\<cdot>Just\\<cdot>Nothing of\n        Nothing \\<Rightarrow> xc\n        | Just\\<cdot>n \\<Rightarrow>\n            case x\\<cdot>Expr2\\<cdot>Just\\<cdot>Nothing of\n            Nothing \\<Rightarrow> xc\n            | Just\\<cdot>m \\<Rightarrow> xb\\<cdot>(n + m)) =\n       Maybe_case\\<cdot>xc\\<cdot>(Abs_cfun (Rep_cfun xb))\\<cdot>\n       (mliftM2 (\\<Lambda> a. Abs_cfun ((+) a))\\<cdot>\n        (x\\<cdot>Expr1\\<cdot>Just\\<cdot>Nothing)\\<cdot>\n        (x\\<cdot>Expr2\\<cdot>Just\\<cdot>Nothing))\n 2. \\<And>xa xb xc.\n       xa = Throw \\<Longrightarrow>\n       xc = Maybe_case\\<cdot>xc\\<cdot>(Abs_cfun (Rep_cfun xb))\\<cdot>mfail\n 3. \\<And>x xa xb xc Expr1 Expr2.\n       xa = Catch\\<cdot>Expr1\\<cdot>Expr2 \\<Longrightarrow>\n       (case wrapC\\<cdot>x\\<cdot>Expr1 of\n        Nothing \\<Rightarrow>\n          case wrapC\\<cdot>x\\<cdot>Expr2 of Nothing \\<Rightarrow> xc\n          | Just\\<cdot>n \\<Rightarrow> xb\\<cdot>n\n        | Just\\<cdot>n \\<Rightarrow> xb\\<cdot>n) =\n       Maybe_case\\<cdot>xc\\<cdot>(Abs_cfun (Rep_cfun xb))\\<cdot>\n       (mcatch\\<cdot>(x\\<cdot>Expr1\\<cdot>Just\\<cdot>Nothing)\\<cdot>\n        (x\\<cdot>Expr2\\<cdot>Just\\<cdot>Nothing))", "apply (case_tac \"x\\<cdot>Expr1\\<cdot>Just\\<cdot>Nothing\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x xa xb xc Expr1 Expr2.\n       \\<lbrakk>xa = Add\\<cdot>Expr1\\<cdot>Expr2;\n        x\\<cdot>Expr1\\<cdot>Just\\<cdot>Nothing = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> (case x\\<cdot>Expr1\\<cdot>Just\\<cdot>Nothing of\n                          Nothing \\<Rightarrow> xc\n                          | Just\\<cdot>n \\<Rightarrow>\n                              case x\\<cdot>Expr2\\<cdot>Just\\<cdot>Nothing of\n                              Nothing \\<Rightarrow> xc\n                              | Just\\<cdot>m \\<Rightarrow>\n                                  xb\\<cdot>(n + m)) =\n                         Maybe_case\\<cdot>xc\\<cdot>\n                         (Abs_cfun (Rep_cfun xb))\\<cdot>\n                         (mliftM2 (\\<Lambda> a. Abs_cfun ((+) a))\\<cdot>\n                          (x\\<cdot>Expr1\\<cdot>Just\\<cdot>Nothing)\\<cdot>\n                          (x\\<cdot>Expr2\\<cdot>Just\\<cdot>Nothing))\n 2. \\<And>x xa xb xc Expr1 Expr2.\n       \\<lbrakk>xa = Add\\<cdot>Expr1\\<cdot>Expr2;\n        x\\<cdot>Expr1\\<cdot>Just\\<cdot>Nothing = Nothing\\<rbrakk>\n       \\<Longrightarrow> (case x\\<cdot>Expr1\\<cdot>Just\\<cdot>Nothing of\n                          Nothing \\<Rightarrow> xc\n                          | Just\\<cdot>n \\<Rightarrow>\n                              case x\\<cdot>Expr2\\<cdot>Just\\<cdot>Nothing of\n                              Nothing \\<Rightarrow> xc\n                              | Just\\<cdot>m \\<Rightarrow>\n                                  xb\\<cdot>(n + m)) =\n                         Maybe_case\\<cdot>xc\\<cdot>\n                         (Abs_cfun (Rep_cfun xb))\\<cdot>\n                         (mliftM2 (\\<Lambda> a. Abs_cfun ((+) a))\\<cdot>\n                          (x\\<cdot>Expr1\\<cdot>Just\\<cdot>Nothing)\\<cdot>\n                          (x\\<cdot>Expr2\\<cdot>Just\\<cdot>Nothing))\n 3. \\<And>x xa xb xc Expr1 Expr2 a.\n       \\<lbrakk>xa = Add\\<cdot>Expr1\\<cdot>Expr2;\n        x\\<cdot>Expr1\\<cdot>Just\\<cdot>Nothing = Just\\<cdot>a\\<rbrakk>\n       \\<Longrightarrow> (case x\\<cdot>Expr1\\<cdot>Just\\<cdot>Nothing of\n                          Nothing \\<Rightarrow> xc\n                          | Just\\<cdot>n \\<Rightarrow>\n                              case x\\<cdot>Expr2\\<cdot>Just\\<cdot>Nothing of\n                              Nothing \\<Rightarrow> xc\n                              | Just\\<cdot>m \\<Rightarrow>\n                                  xb\\<cdot>(n + m)) =\n                         Maybe_case\\<cdot>xc\\<cdot>\n                         (Abs_cfun (Rep_cfun xb))\\<cdot>\n                         (mliftM2 (\\<Lambda> a. Abs_cfun ((+) a))\\<cdot>\n                          (x\\<cdot>Expr1\\<cdot>Just\\<cdot>Nothing)\\<cdot>\n                          (x\\<cdot>Expr2\\<cdot>Just\\<cdot>Nothing))\n 4. \\<And>xa xb xc.\n       xa = Throw \\<Longrightarrow>\n       xc = Maybe_case\\<cdot>xc\\<cdot>(Abs_cfun (Rep_cfun xb))\\<cdot>mfail\n 5. \\<And>x xa xb xc Expr1 Expr2.\n       xa = Catch\\<cdot>Expr1\\<cdot>Expr2 \\<Longrightarrow>\n       (case wrapC\\<cdot>x\\<cdot>Expr1 of\n        Nothing \\<Rightarrow>\n          case wrapC\\<cdot>x\\<cdot>Expr2 of Nothing \\<Rightarrow> xc\n          | Just\\<cdot>n \\<Rightarrow> xb\\<cdot>n\n        | Just\\<cdot>n \\<Rightarrow> xb\\<cdot>n) =\n       Maybe_case\\<cdot>xc\\<cdot>(Abs_cfun (Rep_cfun xb))\\<cdot>\n       (mcatch\\<cdot>(x\\<cdot>Expr1\\<cdot>Just\\<cdot>Nothing)\\<cdot>\n        (x\\<cdot>Expr2\\<cdot>Just\\<cdot>Nothing))", "apply simp_all"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa xb xc Expr1 Expr2 a.\n       \\<lbrakk>xa = Add\\<cdot>Expr1\\<cdot>Expr2;\n        x\\<cdot>Expr1\\<cdot>Just\\<cdot>Nothing = Just\\<cdot>a\\<rbrakk>\n       \\<Longrightarrow> (case x\\<cdot>Expr2\\<cdot>Just\\<cdot>Nothing of\n                          Nothing \\<Rightarrow> xc\n                          | Just\\<cdot>m \\<Rightarrow> xb\\<cdot>(a + m)) =\n                         Maybe_case\\<cdot>xc\\<cdot>\n                         (Abs_cfun (Rep_cfun xb))\\<cdot>\n                         (mliftM2 (\\<Lambda> a. Abs_cfun ((+) a))\\<cdot>\n                          (Just\\<cdot>a)\\<cdot>\n                          (x\\<cdot>Expr2\\<cdot>Just\\<cdot>Nothing))\n 2. \\<And>xa xb xc.\n       xa = Throw \\<Longrightarrow>\n       xc = Maybe_case\\<cdot>xc\\<cdot>(Abs_cfun (Rep_cfun xb))\\<cdot>mfail\n 3. \\<And>x xa xb xc Expr1 Expr2.\n       xa = Catch\\<cdot>Expr1\\<cdot>Expr2 \\<Longrightarrow>\n       (case wrapC\\<cdot>x\\<cdot>Expr1 of\n        Nothing \\<Rightarrow>\n          case wrapC\\<cdot>x\\<cdot>Expr2 of Nothing \\<Rightarrow> xc\n          | Just\\<cdot>n \\<Rightarrow> xb\\<cdot>n\n        | Just\\<cdot>n \\<Rightarrow> xb\\<cdot>n) =\n       Maybe_case\\<cdot>xc\\<cdot>(Abs_cfun (Rep_cfun xb))\\<cdot>\n       (mcatch\\<cdot>(x\\<cdot>Expr1\\<cdot>Just\\<cdot>Nothing)\\<cdot>\n        (x\\<cdot>Expr2\\<cdot>Just\\<cdot>Nothing))", "apply (case_tac \"x\\<cdot>Expr2\\<cdot>Just\\<cdot>Nothing\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x xa xb xc Expr1 Expr2 a.\n       \\<lbrakk>xa = Add\\<cdot>Expr1\\<cdot>Expr2;\n        x\\<cdot>Expr1\\<cdot>Just\\<cdot>Nothing = Just\\<cdot>a;\n        x\\<cdot>Expr2\\<cdot>Just\\<cdot>Nothing = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> (case x\\<cdot>Expr2\\<cdot>Just\\<cdot>Nothing of\n                          Nothing \\<Rightarrow> xc\n                          | Just\\<cdot>m \\<Rightarrow> xb\\<cdot>(a + m)) =\n                         Maybe_case\\<cdot>xc\\<cdot>\n                         (Abs_cfun (Rep_cfun xb))\\<cdot>\n                         (mliftM2 (\\<Lambda> a. Abs_cfun ((+) a))\\<cdot>\n                          (Just\\<cdot>a)\\<cdot>\n                          (x\\<cdot>Expr2\\<cdot>Just\\<cdot>Nothing))\n 2. \\<And>x xa xb xc Expr1 Expr2 a.\n       \\<lbrakk>xa = Add\\<cdot>Expr1\\<cdot>Expr2;\n        x\\<cdot>Expr1\\<cdot>Just\\<cdot>Nothing = Just\\<cdot>a;\n        x\\<cdot>Expr2\\<cdot>Just\\<cdot>Nothing = Nothing\\<rbrakk>\n       \\<Longrightarrow> (case x\\<cdot>Expr2\\<cdot>Just\\<cdot>Nothing of\n                          Nothing \\<Rightarrow> xc\n                          | Just\\<cdot>m \\<Rightarrow> xb\\<cdot>(a + m)) =\n                         Maybe_case\\<cdot>xc\\<cdot>\n                         (Abs_cfun (Rep_cfun xb))\\<cdot>\n                         (mliftM2 (\\<Lambda> a. Abs_cfun ((+) a))\\<cdot>\n                          (Just\\<cdot>a)\\<cdot>\n                          (x\\<cdot>Expr2\\<cdot>Just\\<cdot>Nothing))\n 3. \\<And>x xa xb xc Expr1 Expr2 a aa.\n       \\<lbrakk>xa = Add\\<cdot>Expr1\\<cdot>Expr2;\n        x\\<cdot>Expr1\\<cdot>Just\\<cdot>Nothing = Just\\<cdot>a;\n        x\\<cdot>Expr2\\<cdot>Just\\<cdot>Nothing = Just\\<cdot>aa\\<rbrakk>\n       \\<Longrightarrow> (case x\\<cdot>Expr2\\<cdot>Just\\<cdot>Nothing of\n                          Nothing \\<Rightarrow> xc\n                          | Just\\<cdot>m \\<Rightarrow> xb\\<cdot>(a + m)) =\n                         Maybe_case\\<cdot>xc\\<cdot>\n                         (Abs_cfun (Rep_cfun xb))\\<cdot>\n                         (mliftM2 (\\<Lambda> a. Abs_cfun ((+) a))\\<cdot>\n                          (Just\\<cdot>a)\\<cdot>\n                          (x\\<cdot>Expr2\\<cdot>Just\\<cdot>Nothing))\n 4. \\<And>xa xb xc.\n       xa = Throw \\<Longrightarrow>\n       xc = Maybe_case\\<cdot>xc\\<cdot>(Abs_cfun (Rep_cfun xb))\\<cdot>mfail\n 5. \\<And>x xa xb xc Expr1 Expr2.\n       xa = Catch\\<cdot>Expr1\\<cdot>Expr2 \\<Longrightarrow>\n       (case wrapC\\<cdot>x\\<cdot>Expr1 of\n        Nothing \\<Rightarrow>\n          case wrapC\\<cdot>x\\<cdot>Expr2 of Nothing \\<Rightarrow> xc\n          | Just\\<cdot>n \\<Rightarrow> xb\\<cdot>n\n        | Just\\<cdot>n \\<Rightarrow> xb\\<cdot>n) =\n       Maybe_case\\<cdot>xc\\<cdot>(Abs_cfun (Rep_cfun xb))\\<cdot>\n       (mcatch\\<cdot>(x\\<cdot>Expr1\\<cdot>Just\\<cdot>Nothing)\\<cdot>\n        (x\\<cdot>Expr2\\<cdot>Just\\<cdot>Nothing))", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa xb xc.\n       xa = Throw \\<Longrightarrow>\n       xc = Maybe_case\\<cdot>xc\\<cdot>(Abs_cfun (Rep_cfun xb))\\<cdot>mfail\n 2. \\<And>x xa xb xc Expr1 Expr2.\n       xa = Catch\\<cdot>Expr1\\<cdot>Expr2 \\<Longrightarrow>\n       (case wrapC\\<cdot>x\\<cdot>Expr1 of\n        Nothing \\<Rightarrow>\n          case wrapC\\<cdot>x\\<cdot>Expr2 of Nothing \\<Rightarrow> xc\n          | Just\\<cdot>n \\<Rightarrow> xb\\<cdot>n\n        | Just\\<cdot>n \\<Rightarrow> xb\\<cdot>n) =\n       Maybe_case\\<cdot>xc\\<cdot>(Abs_cfun (Rep_cfun xb))\\<cdot>\n       (mcatch\\<cdot>(x\\<cdot>Expr1\\<cdot>Just\\<cdot>Nothing)\\<cdot>\n        (x\\<cdot>Expr2\\<cdot>Just\\<cdot>Nothing))", "apply (simp add: mfail_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb xc Expr1 Expr2.\n       xa = Catch\\<cdot>Expr1\\<cdot>Expr2 \\<Longrightarrow>\n       (case wrapC\\<cdot>x\\<cdot>Expr1 of\n        Nothing \\<Rightarrow>\n          case wrapC\\<cdot>x\\<cdot>Expr2 of Nothing \\<Rightarrow> xc\n          | Just\\<cdot>n \\<Rightarrow> xb\\<cdot>n\n        | Just\\<cdot>n \\<Rightarrow> xb\\<cdot>n) =\n       Maybe_case\\<cdot>xc\\<cdot>(Abs_cfun (Rep_cfun xb))\\<cdot>\n       (mcatch\\<cdot>(x\\<cdot>Expr1\\<cdot>Just\\<cdot>Nothing)\\<cdot>\n        (x\\<cdot>Expr2\\<cdot>Just\\<cdot>Nothing))", "apply (simp add: mcatch_def wrapC_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb xc Expr1 Expr2.\n       xa = Catch\\<cdot>Expr1\\<cdot>Expr2 \\<Longrightarrow>\n       (case x\\<cdot>Expr1\\<cdot>Just\\<cdot>Nothing of\n        Nothing \\<Rightarrow>\n          case x\\<cdot>Expr2\\<cdot>Just\\<cdot>Nothing of\n          Nothing \\<Rightarrow> xc | Just\\<cdot>n \\<Rightarrow> xb\\<cdot>n\n        | Just\\<cdot>n \\<Rightarrow> xb\\<cdot>n) =\n       Maybe_case\\<cdot>xc\\<cdot>(Abs_cfun (Rep_cfun xb))\\<cdot>\n       (Maybe_case\\<cdot>(x\\<cdot>Expr2\\<cdot>Just\\<cdot>Nothing)\\<cdot>\n        (Abs_cfun (Rep_cfun Just))\\<cdot>\n        (x\\<cdot>Expr1\\<cdot>Just\\<cdot>Nothing))", "apply (case_tac \"x\\<cdot>Expr1\\<cdot>Just\\<cdot>Nothing\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa xb xc Expr1 Expr2.\n       \\<lbrakk>xa = Catch\\<cdot>Expr1\\<cdot>Expr2;\n        x\\<cdot>Expr1\\<cdot>Just\\<cdot>Nothing = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> (case x\\<cdot>Expr1\\<cdot>Just\\<cdot>Nothing of\n                          Nothing \\<Rightarrow>\n                            case x\\<cdot>Expr2\\<cdot>Just\\<cdot>Nothing of\n                            Nothing \\<Rightarrow> xc\n                            | Just\\<cdot>n \\<Rightarrow> xb\\<cdot>n\n                          | Just\\<cdot>n \\<Rightarrow> xb\\<cdot>n) =\n                         Maybe_case\\<cdot>xc\\<cdot>\n                         (Abs_cfun (Rep_cfun xb))\\<cdot>\n                         (Maybe_case\\<cdot>\n                          (x\\<cdot>Expr2\\<cdot>Just\\<cdot>Nothing)\\<cdot>\n                          (Abs_cfun (Rep_cfun Just))\\<cdot>\n                          (x\\<cdot>Expr1\\<cdot>Just\\<cdot>Nothing))\n 2. \\<And>x xa xb xc Expr1 Expr2.\n       \\<lbrakk>xa = Catch\\<cdot>Expr1\\<cdot>Expr2;\n        x\\<cdot>Expr1\\<cdot>Just\\<cdot>Nothing = Nothing\\<rbrakk>\n       \\<Longrightarrow> (case x\\<cdot>Expr1\\<cdot>Just\\<cdot>Nothing of\n                          Nothing \\<Rightarrow>\n                            case x\\<cdot>Expr2\\<cdot>Just\\<cdot>Nothing of\n                            Nothing \\<Rightarrow> xc\n                            | Just\\<cdot>n \\<Rightarrow> xb\\<cdot>n\n                          | Just\\<cdot>n \\<Rightarrow> xb\\<cdot>n) =\n                         Maybe_case\\<cdot>xc\\<cdot>\n                         (Abs_cfun (Rep_cfun xb))\\<cdot>\n                         (Maybe_case\\<cdot>\n                          (x\\<cdot>Expr2\\<cdot>Just\\<cdot>Nothing)\\<cdot>\n                          (Abs_cfun (Rep_cfun Just))\\<cdot>\n                          (x\\<cdot>Expr1\\<cdot>Just\\<cdot>Nothing))\n 3. \\<And>x xa xb xc Expr1 Expr2 a.\n       \\<lbrakk>xa = Catch\\<cdot>Expr1\\<cdot>Expr2;\n        x\\<cdot>Expr1\\<cdot>Just\\<cdot>Nothing = Just\\<cdot>a\\<rbrakk>\n       \\<Longrightarrow> (case x\\<cdot>Expr1\\<cdot>Just\\<cdot>Nothing of\n                          Nothing \\<Rightarrow>\n                            case x\\<cdot>Expr2\\<cdot>Just\\<cdot>Nothing of\n                            Nothing \\<Rightarrow> xc\n                            | Just\\<cdot>n \\<Rightarrow> xb\\<cdot>n\n                          | Just\\<cdot>n \\<Rightarrow> xb\\<cdot>n) =\n                         Maybe_case\\<cdot>xc\\<cdot>\n                         (Abs_cfun (Rep_cfun xb))\\<cdot>\n                         (Maybe_case\\<cdot>\n                          (x\\<cdot>Expr2\\<cdot>Just\\<cdot>Nothing)\\<cdot>\n                          (Abs_cfun (Rep_cfun Just))\\<cdot>\n                          (x\\<cdot>Expr1\\<cdot>Just\\<cdot>Nothing))", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "fixrec eval_body_final :: \"(Expr \\<rightarrow> (Nat \\<rightarrow> Nat Maybe) \\<rightarrow> Nat Maybe \\<rightarrow> Nat Maybe)\n                         \\<rightarrow> Expr \\<rightarrow> (Nat \\<rightarrow> Nat Maybe) \\<rightarrow> Nat Maybe \\<rightarrow> Nat Maybe\"\nwhere\n  \"eval_body_final\\<cdot>r\\<cdot>(Val\\<cdot>n)\\<cdot>s\\<cdot>f = s\\<cdot>n\"\n| \"eval_body_final\\<cdot>r\\<cdot>(Add\\<cdot>x\\<cdot>y)\\<cdot>s\\<cdot>f = r\\<cdot>x\\<cdot>(\\<Lambda> n. r\\<cdot>y\\<cdot>(\\<Lambda> m. s\\<cdot>(n + m))\\<cdot>f)\\<cdot>f\"\n| \"eval_body_final\\<cdot>r\\<cdot>Throw\\<cdot>s\\<cdot>f = f\"\n| \"eval_body_final\\<cdot>r\\<cdot>(Catch\\<cdot>x\\<cdot>y)\\<cdot>s\\<cdot>f = r\\<cdot>x\\<cdot>s\\<cdot>(r\\<cdot>y\\<cdot>s\\<cdot>f)\""], ["", "lemma eval_body_final_strictExpr[simp]: \"eval_body_final\\<cdot>r\\<cdot>\\<bottom>\\<cdot>s\\<cdot>f = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_body_final\\<cdot>r\\<cdot>\\<bottom>\\<cdot>s\\<cdot>f = \\<bottom>", "by (subst eval_body_final.unfold, simp)"], ["", "lemma eval_body'_eval_body_final_eq: \"eval_body_final oo unwrapC oo wrapC = eval_body'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_body_final oo unwrapC oo wrapC = eval_body'", "apply (rule cfun_eqI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb xc.\n       (eval_body_final oo unwrapC oo wrapC)\\<cdot>x\\<cdot>xa\\<cdot>\n       xb\\<cdot>\n       xc =\n       eval_body'\\<cdot>x\\<cdot>xa\\<cdot>xb\\<cdot>xc", "apply (case_tac xa)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x xa xb xc.\n       xa = \\<bottom> \\<Longrightarrow>\n       (eval_body_final oo unwrapC oo wrapC)\\<cdot>x\\<cdot>xa\\<cdot>\n       xb\\<cdot>\n       xc =\n       eval_body'\\<cdot>x\\<cdot>xa\\<cdot>xb\\<cdot>xc\n 2. \\<And>x xa xb xc Box.\n       xa = Val\\<cdot>Box \\<Longrightarrow>\n       (eval_body_final oo unwrapC oo wrapC)\\<cdot>x\\<cdot>xa\\<cdot>\n       xb\\<cdot>\n       xc =\n       eval_body'\\<cdot>x\\<cdot>xa\\<cdot>xb\\<cdot>xc\n 3. \\<And>x xa xb xc Expr1 Expr2.\n       xa = Add\\<cdot>Expr1\\<cdot>Expr2 \\<Longrightarrow>\n       (eval_body_final oo unwrapC oo wrapC)\\<cdot>x\\<cdot>xa\\<cdot>\n       xb\\<cdot>\n       xc =\n       eval_body'\\<cdot>x\\<cdot>xa\\<cdot>xb\\<cdot>xc\n 4. \\<And>x xa xb xc.\n       xa = Throw \\<Longrightarrow>\n       (eval_body_final oo unwrapC oo wrapC)\\<cdot>x\\<cdot>xa\\<cdot>\n       xb\\<cdot>\n       xc =\n       eval_body'\\<cdot>x\\<cdot>xa\\<cdot>xb\\<cdot>xc\n 5. \\<And>x xa xb xc Expr1 Expr2.\n       xa = Catch\\<cdot>Expr1\\<cdot>Expr2 \\<Longrightarrow>\n       (eval_body_final oo unwrapC oo wrapC)\\<cdot>x\\<cdot>xa\\<cdot>\n       xb\\<cdot>\n       xc =\n       eval_body'\\<cdot>x\\<cdot>xa\\<cdot>xb\\<cdot>xc", "apply (simp_all add: unwrapC_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition\n  eval_work_final :: \"Expr \\<rightarrow> (Nat \\<rightarrow> Nat Maybe) \\<rightarrow> Nat Maybe \\<rightarrow> Nat Maybe\" where\n  \"eval_work_final \\<equiv> fix\\<cdot>eval_body_final\""], ["", "definition\n  eval_final :: \"Expr \\<rightarrow> Nat Maybe\" where\n  \"eval_final \\<equiv> (\\<Lambda> e. eval_work_final\\<cdot>e\\<cdot>Just\\<cdot>Nothing)\""], ["", "lemma \"eval = eval_final\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval = eval_final", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval = eval_final", "have \"eval = fix\\<cdot>eval_body\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval = fix\\<cdot>eval_body", "by (rule eval_eval_body_eq)"], ["proof (state)\nthis:\n  eval = fix\\<cdot>eval_body\n\ngoal (1 subgoal):\n 1. eval = eval_final", "also"], ["proof (state)\nthis:\n  eval = fix\\<cdot>eval_body\n\ngoal (1 subgoal):\n 1. eval = eval_final", "from wrapC_unwrapC_id unwrapC_strict"], ["proof (chain)\npicking this:\n  wrapC oo unwrapC = ID\n  unwrapC\\<cdot>\\<bottom> = \\<bottom>", "have \"\\<dots> = wrapC\\<cdot>(fix\\<cdot>eval_body_final)\""], ["proof (prove)\nusing this:\n  wrapC oo unwrapC = ID\n  unwrapC\\<cdot>\\<bottom> = \\<bottom>\n\ngoal (1 subgoal):\n 1. fix\\<cdot>eval_body = wrapC\\<cdot>(fix\\<cdot>eval_body_final)", "apply (rule worker_wrapper_fusion_new)"], ["proof (prove)\ngoal (1 subgoal):\n 1. unwrapC oo eval_body oo wrapC = eval_body_final oo unwrapC oo wrapC", "using eval_body'_eval_body_final_eq eval_body'_eval_body_eq"], ["proof (prove)\nusing this:\n  eval_body_final oo unwrapC oo wrapC = eval_body'\n  eval_body' = unwrapC oo eval_body oo wrapC\n\ngoal (1 subgoal):\n 1. unwrapC oo eval_body oo wrapC = eval_body_final oo unwrapC oo wrapC", "by simp"], ["proof (state)\nthis:\n  fix\\<cdot>eval_body = wrapC\\<cdot>(fix\\<cdot>eval_body_final)\n\ngoal (1 subgoal):\n 1. eval = eval_final", "also"], ["proof (state)\nthis:\n  fix\\<cdot>eval_body = wrapC\\<cdot>(fix\\<cdot>eval_body_final)\n\ngoal (1 subgoal):\n 1. eval = eval_final", "have \"\\<dots> = eval_final\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wrapC\\<cdot>(fix\\<cdot>eval_body_final) = eval_final", "unfolding eval_final_def eval_work_final_def wrapC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> g e. g\\<cdot>e\\<cdot>Just\\<cdot>Nothing)\\<cdot>\n    (fix\\<cdot>eval_body_final) =\n    (\\<Lambda> e.\n        fix\\<cdot>eval_body_final\\<cdot>e\\<cdot>Just\\<cdot>Nothing)", "by simp"], ["proof (state)\nthis:\n  wrapC\\<cdot>(fix\\<cdot>eval_body_final) = eval_final\n\ngoal (1 subgoal):\n 1. eval = eval_final", "finally"], ["proof (chain)\npicking this:\n  eval = eval_final", "show ?thesis"], ["proof (prove)\nusing this:\n  eval = eval_final\n\ngoal (1 subgoal):\n 1. eval = eval_final", "."], ["proof (state)\nthis:\n  eval = eval_final\n\ngoal:\nNo subgoals!", "qed"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}