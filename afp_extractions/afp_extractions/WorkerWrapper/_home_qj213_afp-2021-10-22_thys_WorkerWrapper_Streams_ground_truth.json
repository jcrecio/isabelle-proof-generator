{"file_name": "/home/qj213/afp-2021-10-22/thys/WorkerWrapper/Streams.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/WorkerWrapper", "problem_names": ["lemma Stream_bisimI[intro]:\n  \"(\\<And>xs ys. R xs ys\n     \\<Longrightarrow> (xs = \\<bottom> \\<and> ys = \\<bottom>)\n       \\<or> (\\<exists>h t t'. R t t' \\<and> xs = h && t \\<and> ys = h && t'))\n  \\<Longrightarrow> Stream_bisim R\"", "lemma smap_strict[simp]: \"smap\\<cdot>f\\<cdot>\\<bottom> = \\<bottom>\"", "lemma smap_smap: \"smap\\<cdot>f\\<cdot>(smap\\<cdot>g\\<cdot>xs) = smap\\<cdot>(f oo g)\\<cdot>xs\"", "lemma i_th_strict1[simp]: \"\\<bottom> !! i = \\<bottom>\"", "lemma i_th_strict2[simp]: \"s !! \\<bottom> = \\<bottom>\"", "lemma i_th_0[simp]: \"(s !! 0) = sthead\\<cdot>s\"", "lemma i_th_suc[simp]: \"i \\<noteq> \\<bottom> \\<Longrightarrow> (x && xs) !! (i + 1) = xs !! i\"", "lemma unwrapS'_unfold: \"unwrapS'\\<cdot>f = f\\<cdot>0 && smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>nats\"", "lemma unwrapS_unwrapS'_eq: \"unwrapS = unwrapS'\" (is \"?lhs = ?rhs\")", "lemma wrapS_unwrapS_id':\n  assumes strictF: \"(f::Nat \\<rightarrow> 'a)\\<cdot>\\<bottom> = \\<bottom>\"\n  shows \"unwrapS\\<cdot>f !! n = f\\<cdot>n\"", "lemma wrapS_unwrapS_id: \"f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow> (wrapS oo unwrapS)\\<cdot>f = f\"", "lemma fib_body_strict[simp]: \"fib_body\\<cdot>r\\<cdot>\\<bottom> = \\<bottom>\"", "lemma fib_strict[simp]: \"fib\\<cdot>\\<bottom> = \\<bottom>\"", "lemma wrapS_unwrapS_fib_body: \"wrapS oo unwrapS oo fib_body = fib_body\"", "lemma fib_ww_eq: \"fib = fib_wrap\"", "lemma fib_work_final_fib_work_eq: \"fib_work_final = fib_work\" (is \"?lhs = ?rhs\")", "lemma fib_final_fib_eq: \"fib_final = fib\" (is \"?lhs = ?rhs\")"], "translations": [["", "lemma Stream_bisimI[intro]:\n  \"(\\<And>xs ys. R xs ys\n     \\<Longrightarrow> (xs = \\<bottom> \\<and> ys = \\<bottom>)\n       \\<or> (\\<exists>h t t'. R t t' \\<and> xs = h && t \\<and> ys = h && t'))\n  \\<Longrightarrow> Stream_bisim R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        R xs ys \\<Longrightarrow>\n        xs = \\<bottom> \\<and> ys = \\<bottom> \\<or>\n        (\\<exists>h t t'.\n            R t t' \\<and>\n            xs = h && t \\<and> ys = h && t')) \\<Longrightarrow>\n    Stream_bisim R", "unfolding Stream.bisim_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        R xs ys \\<Longrightarrow>\n        xs = \\<bottom> \\<and> ys = \\<bottom> \\<or>\n        (\\<exists>h t t'.\n            R t t' \\<and>\n            xs = h && t \\<and> ys = h && t')) \\<Longrightarrow>\n    \\<forall>x y.\n       R x y \\<longrightarrow>\n       x = \\<bottom> \\<and> y = \\<bottom> \\<or>\n       (\\<exists>a Stream a' Stream'.\n           a = a' \\<and>\n           R Stream Stream' \\<and> x = a && Stream \\<and> y = a' && Stream')", "by auto"], ["", "(*>*)"], ["", "fixrec smap :: \"('a \\<rightarrow> 'b) \\<rightarrow> 'a Stream \\<rightarrow> 'b Stream\"\nwhere\n  \"smap\\<cdot>f\\<cdot>(x && xs) = f\\<cdot>x && smap\\<cdot>f\\<cdot>xs\""], ["", "(*<*)"], ["", "lemma smap_strict[simp]: \"smap\\<cdot>f\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap\\<cdot>f\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "(*>*)"], ["", "lemma smap_smap: \"smap\\<cdot>f\\<cdot>(smap\\<cdot>g\\<cdot>xs) = smap\\<cdot>(f oo g)\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap\\<cdot>f\\<cdot>(smap\\<cdot>g\\<cdot>xs) =\n    smap\\<cdot>(f oo g)\\<cdot>xs", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. smap\\<cdot>f\\<cdot>(smap\\<cdot>g\\<cdot>xs) =\n    smap\\<cdot>(f oo g)\\<cdot>xs", "by (induct xs, simp_all)"], ["", "(*>*)"], ["", "fixrec i_th :: \"'a Stream \\<rightarrow> Nat \\<rightarrow> 'a\"\nwhere\n  \"i_th\\<cdot>(x && xs) = Nat_case\\<cdot>x\\<cdot>(i_th\\<cdot>xs)\""], ["", "abbreviation\n  i_th_syn :: \"'a Stream \\<Rightarrow> Nat \\<Rightarrow> 'a\" (infixl \"!!\" 100) where\n  \"s !! i \\<equiv> i_th\\<cdot>s\\<cdot>i\""], ["", "(*<*)"], ["", "lemma i_th_strict1[simp]: \"\\<bottom> !! i = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> !! i = \\<bottom>", "by fixrec_simp"], ["", "lemma i_th_strict2[simp]: \"s !! \\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s !! \\<bottom> = \\<bottom>", "by (subst i_th.unfold, cases s, simp_all)"], ["", "lemma i_th_0[simp]: \"(s !! 0) = sthead\\<cdot>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s !! 0 = sthead\\<cdot>s", "by (subst i_th.unfold, cases s, simp_all)"], ["", "lemma i_th_suc[simp]: \"i \\<noteq> \\<bottom> \\<Longrightarrow> (x && xs) !! (i + 1) = xs !! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> \\<bottom> \\<Longrightarrow> (x && xs) !! (i + 1) = xs !! i", "by (subst i_th.unfold, simp)"], ["", "(*>*)"], ["", "text\\<open>The infinite stream of natural numbers.\\<close>"], ["", "fixrec nats :: \"Nat Stream\"\nwhere\n  \"nats = 0 && smap\\<cdot>(\\<Lambda> x. 1 + x)\\<cdot>nats\""], ["", "(*<*)"], ["", "declare nats.simps[simp del]"], ["", "(*>*)"], ["", "subsection\\<open>The wrapper/unwrapper functions.\\<close>"], ["", "definition\n  unwrapS' :: \"(Nat \\<rightarrow> 'a) \\<rightarrow> 'a Stream\" where\n  \"unwrapS' \\<equiv> \\<Lambda> f . smap\\<cdot>f\\<cdot>nats\""], ["", "lemma unwrapS'_unfold: \"unwrapS'\\<cdot>f = f\\<cdot>0 && smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>nats\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unwrapS'\\<cdot>f =\n    f\\<cdot>0 && smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>nats", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. unwrapS'\\<cdot>f =\n    f\\<cdot>0 && smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>nats", "by (unfold unwrapS'_def, subst nats.unfold, simp add: smap_smap)"], ["", "(*>*)"], ["", "fixrec unwrapS :: \"(Nat \\<rightarrow> 'a) \\<rightarrow> 'a Stream\"\nwhere\n  \"unwrapS\\<cdot>f = f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x))\""], ["", "(*<*)"], ["", "declare unwrapS.simps[simp del]"], ["", "(*>*)"], ["", "text\\<open>The two versions of @{term \"unwrapS\"} are equivalent. We could\ntry to fold some definitions here but it's easier if the stream\nconstructor is manifest.\\<close>"], ["", "lemma unwrapS_unwrapS'_eq: \"unwrapS = unwrapS'\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. unwrapS = unwrapS'", "proof(rule cfun_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. unwrapS\\<cdot>x = unwrapS'\\<cdot>x", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. unwrapS\\<cdot>x = unwrapS'\\<cdot>x", "show \"?lhs\\<cdot>f = ?rhs\\<cdot>f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unwrapS\\<cdot>f = unwrapS'\\<cdot>f", "proof(coinduct rule: Stream.coinduct)"], ["proof (state)\ngoal (2 subgoals):\n 1. Stream_bisim ?R\n 2. ?R (unwrapS\\<cdot>f) (unwrapS'\\<cdot>f)", "let ?R = \"\\<lambda>s s'. (\\<exists>f. s = f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x))\n                        \\<and> s' = f\\<cdot>0 && smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>nats)\""], ["proof (state)\ngoal (2 subgoals):\n 1. Stream_bisim ?R\n 2. ?R (unwrapS\\<cdot>f) (unwrapS'\\<cdot>f)", "show \"Stream_bisim ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Stream_bisim\n     (\\<lambda>s s'.\n         \\<exists>f.\n            s =\n            f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x)) \\<and>\n            s' =\n            f\\<cdot>0 && smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>nats)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<exists>f.\n          xs = f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x)) \\<and>\n          ys =\n          f\\<cdot>0 &&\n          smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>\n          nats \\<Longrightarrow>\n       xs = \\<bottom> \\<and> ys = \\<bottom> \\<or>\n       (\\<exists>h t t'.\n           (\\<exists>f.\n               t =\n               f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x)) \\<and>\n               t' =\n               f\\<cdot>0 &&\n               smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>nats) \\<and>\n           xs = h && t \\<and> ys = h && t')", "fix s s'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<exists>f.\n          xs = f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x)) \\<and>\n          ys =\n          f\\<cdot>0 &&\n          smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>\n          nats \\<Longrightarrow>\n       xs = \\<bottom> \\<and> ys = \\<bottom> \\<or>\n       (\\<exists>h t t'.\n           (\\<exists>f.\n               t =\n               f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x)) \\<and>\n               t' =\n               f\\<cdot>0 &&\n               smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>nats) \\<and>\n           xs = h && t \\<and> ys = h && t')", "assume \"?R s s'\""], ["proof (state)\nthis:\n  \\<exists>f.\n     s = f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x)) \\<and>\n     s' = f\\<cdot>0 && smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>nats\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<exists>f.\n          xs = f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x)) \\<and>\n          ys =\n          f\\<cdot>0 &&\n          smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>\n          nats \\<Longrightarrow>\n       xs = \\<bottom> \\<and> ys = \\<bottom> \\<or>\n       (\\<exists>h t t'.\n           (\\<exists>f.\n               t =\n               f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x)) \\<and>\n               t' =\n               f\\<cdot>0 &&\n               smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>nats) \\<and>\n           xs = h && t \\<and> ys = h && t')", "then"], ["proof (chain)\npicking this:\n  \\<exists>f.\n     s = f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x)) \\<and>\n     s' = f\\<cdot>0 && smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>nats", "obtain f where fs:  \"s = f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x))\"\n                      and fs': \"s' = f\\<cdot>0 && smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>nats\""], ["proof (prove)\nusing this:\n  \\<exists>f.\n     s = f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x)) \\<and>\n     s' = f\\<cdot>0 && smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>nats\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>s = f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x));\n         s' =\n         f\\<cdot>0 &&\n         smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>nats\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s = f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x))\n  s' = f\\<cdot>0 && smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>nats\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<exists>f.\n          xs = f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x)) \\<and>\n          ys =\n          f\\<cdot>0 &&\n          smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>\n          nats \\<Longrightarrow>\n       xs = \\<bottom> \\<and> ys = \\<bottom> \\<or>\n       (\\<exists>h t t'.\n           (\\<exists>f.\n               t =\n               f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x)) \\<and>\n               t' =\n               f\\<cdot>0 &&\n               smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>nats) \\<and>\n           xs = h && t \\<and> ys = h && t')", "have \"?R (unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x))) (smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>nats)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x)) =\n       f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x)) \\<and>\n       smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>nats =\n       f\\<cdot>0 && smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>nats", "by ( rule exI[where x=\"f oo (\\<Lambda> x. 1 + x)\"]\n           , subst unwrapS.unfold, subst nats.unfold, simp add: smap_smap)"], ["proof (state)\nthis:\n  \\<exists>f.\n     unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x)) =\n     f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x)) \\<and>\n     smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>nats =\n     f\\<cdot>0 && smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>nats\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<exists>f.\n          xs = f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x)) \\<and>\n          ys =\n          f\\<cdot>0 &&\n          smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>\n          nats \\<Longrightarrow>\n       xs = \\<bottom> \\<and> ys = \\<bottom> \\<or>\n       (\\<exists>h t t'.\n           (\\<exists>f.\n               t =\n               f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x)) \\<and>\n               t' =\n               f\\<cdot>0 &&\n               smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>nats) \\<and>\n           xs = h && t \\<and> ys = h && t')", "with fs fs'"], ["proof (chain)\npicking this:\n  s = f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x))\n  s' = f\\<cdot>0 && smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>nats\n  \\<exists>f.\n     unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x)) =\n     f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x)) \\<and>\n     smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>nats =\n     f\\<cdot>0 && smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>nats", "show \"(s = \\<bottom> \\<and> s' = \\<bottom>)\n          \\<or> (\\<exists>h t t'.\n              (\\<exists>f. t = f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x))\n                 \\<and> t' = f\\<cdot>0 && smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>nats)\n                 \\<and> s = h && t \\<and> s' = h && t')\""], ["proof (prove)\nusing this:\n  s = f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x))\n  s' = f\\<cdot>0 && smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>nats\n  \\<exists>f.\n     unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x)) =\n     f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x)) \\<and>\n     smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>nats =\n     f\\<cdot>0 && smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>nats\n\ngoal (1 subgoal):\n 1. s = \\<bottom> \\<and> s' = \\<bottom> \\<or>\n    (\\<exists>h t t'.\n        (\\<exists>f.\n            t =\n            f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x)) \\<and>\n            t' =\n            f\\<cdot>0 &&\n            smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>nats) \\<and>\n        s = h && t \\<and> s' = h && t')", "by best"], ["proof (state)\nthis:\n  s = \\<bottom> \\<and> s' = \\<bottom> \\<or>\n  (\\<exists>h t t'.\n      (\\<exists>f.\n          t = f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x)) \\<and>\n          t' =\n          f\\<cdot>0 &&\n          smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>nats) \\<and>\n      s = h && t \\<and> s' = h && t')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Stream_bisim\n   (\\<lambda>s s'.\n       \\<exists>f.\n          s = f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x)) \\<and>\n          s' =\n          f\\<cdot>0 && smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>nats)\n\ngoal (1 subgoal):\n 1. \\<exists>fa.\n       unwrapS\\<cdot>f =\n       fa\\<cdot>0 && unwrapS\\<cdot>(fa oo (\\<Lambda> x. 1 + x)) \\<and>\n       unwrapS'\\<cdot>f =\n       fa\\<cdot>0 && smap\\<cdot>(fa oo (\\<Lambda> x. 1 + x))\\<cdot>nats", "show \"?R (?lhs\\<cdot>f) (?rhs\\<cdot>f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>fa.\n       unwrapS\\<cdot>f =\n       fa\\<cdot>0 && unwrapS\\<cdot>(fa oo (\\<Lambda> x. 1 + x)) \\<and>\n       unwrapS'\\<cdot>f =\n       fa\\<cdot>0 && smap\\<cdot>(fa oo (\\<Lambda> x. 1 + x))\\<cdot>nats", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>fa.\n       unwrapS\\<cdot>f =\n       fa\\<cdot>0 && unwrapS\\<cdot>(fa oo (\\<Lambda> x. 1 + x)) \\<and>\n       unwrapS'\\<cdot>f =\n       fa\\<cdot>0 && smap\\<cdot>(fa oo (\\<Lambda> x. 1 + x))\\<cdot>nats", "have lhs: \"?lhs\\<cdot>f = f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unwrapS\\<cdot>f = f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x))", "by (subst unwrapS.unfold, simp)"], ["proof (state)\nthis:\n  unwrapS\\<cdot>f = f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x))\n\ngoal (1 subgoal):\n 1. \\<exists>fa.\n       unwrapS\\<cdot>f =\n       fa\\<cdot>0 && unwrapS\\<cdot>(fa oo (\\<Lambda> x. 1 + x)) \\<and>\n       unwrapS'\\<cdot>f =\n       fa\\<cdot>0 && smap\\<cdot>(fa oo (\\<Lambda> x. 1 + x))\\<cdot>nats", "have rhs: \"?rhs\\<cdot>f = f\\<cdot>0 && smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>nats\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unwrapS'\\<cdot>f =\n    f\\<cdot>0 && smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>nats", "by (rule unwrapS'_unfold)"], ["proof (state)\nthis:\n  unwrapS'\\<cdot>f =\n  f\\<cdot>0 && smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>nats\n\ngoal (1 subgoal):\n 1. \\<exists>fa.\n       unwrapS\\<cdot>f =\n       fa\\<cdot>0 && unwrapS\\<cdot>(fa oo (\\<Lambda> x. 1 + x)) \\<and>\n       unwrapS'\\<cdot>f =\n       fa\\<cdot>0 && smap\\<cdot>(fa oo (\\<Lambda> x. 1 + x))\\<cdot>nats", "from lhs rhs"], ["proof (chain)\npicking this:\n  unwrapS\\<cdot>f = f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x))\n  unwrapS'\\<cdot>f =\n  f\\<cdot>0 && smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>nats", "show ?thesis"], ["proof (prove)\nusing this:\n  unwrapS\\<cdot>f = f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x))\n  unwrapS'\\<cdot>f =\n  f\\<cdot>0 && smap\\<cdot>(f oo (\\<Lambda> x. 1 + x))\\<cdot>nats\n\ngoal (1 subgoal):\n 1. \\<exists>fa.\n       unwrapS\\<cdot>f =\n       fa\\<cdot>0 && unwrapS\\<cdot>(fa oo (\\<Lambda> x. 1 + x)) \\<and>\n       unwrapS'\\<cdot>f =\n       fa\\<cdot>0 && smap\\<cdot>(fa oo (\\<Lambda> x. 1 + x))\\<cdot>nats", "by best"], ["proof (state)\nthis:\n  \\<exists>fa.\n     unwrapS\\<cdot>f =\n     fa\\<cdot>0 && unwrapS\\<cdot>(fa oo (\\<Lambda> x. 1 + x)) \\<and>\n     unwrapS'\\<cdot>f =\n     fa\\<cdot>0 && smap\\<cdot>(fa oo (\\<Lambda> x. 1 + x))\\<cdot>nats\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>fa.\n     unwrapS\\<cdot>f =\n     fa\\<cdot>0 && unwrapS\\<cdot>(fa oo (\\<Lambda> x. 1 + x)) \\<and>\n     unwrapS'\\<cdot>f =\n     fa\\<cdot>0 && smap\\<cdot>(fa oo (\\<Lambda> x. 1 + x))\\<cdot>nats\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  unwrapS\\<cdot>f = unwrapS'\\<cdot>f\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  wrapS :: \"'a Stream \\<rightarrow> Nat \\<rightarrow> 'a\" where\n  \"wrapS \\<equiv> \\<Lambda> s i . s !! i\""], ["", "text\\<open>Note the identity requires that @{term \"f\"} be\nstrict. \\citet[\\S6.1]{GillHutton:2009} do not make this requirement,\nan oversight on their part.\n\nIn practice all functions worth memoising are strict in the memoised\nargument.\\<close>"], ["", "lemma wrapS_unwrapS_id':\n  assumes strictF: \"(f::Nat \\<rightarrow> 'a)\\<cdot>\\<bottom> = \\<bottom>\"\n  shows \"unwrapS\\<cdot>f !! n = f\\<cdot>n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unwrapS\\<cdot>f !! n = f\\<cdot>n", "using strictF"], ["proof (prove)\nusing this:\n  f\\<cdot>\\<bottom> = \\<bottom>\n\ngoal (1 subgoal):\n 1. unwrapS\\<cdot>f !! n = f\\<cdot>n", "proof(induct n arbitrary: f rule: Nat_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>f.\n       f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n       unwrapS\\<cdot>f !! \\<bottom> = f\\<cdot>\\<bottom>\n 2. \\<And>f.\n       f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n       unwrapS\\<cdot>f !! 0 = f\\<cdot>0\n 3. \\<And>n f.\n       \\<lbrakk>n \\<noteq> \\<bottom>;\n        \\<And>f.\n           f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n           unwrapS\\<cdot>f !! n = f\\<cdot>n;\n        f\\<cdot>\\<bottom> = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> unwrapS\\<cdot>f !! (n + 1) = f\\<cdot>(n + 1)", "case bottom"], ["proof (state)\nthis:\n  f\\<cdot>\\<bottom> = \\<bottom>\n\ngoal (3 subgoals):\n 1. \\<And>f.\n       f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n       unwrapS\\<cdot>f !! \\<bottom> = f\\<cdot>\\<bottom>\n 2. \\<And>f.\n       f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n       unwrapS\\<cdot>f !! 0 = f\\<cdot>0\n 3. \\<And>n f.\n       \\<lbrakk>n \\<noteq> \\<bottom>;\n        \\<And>f.\n           f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n           unwrapS\\<cdot>f !! n = f\\<cdot>n;\n        f\\<cdot>\\<bottom> = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> unwrapS\\<cdot>f !! (n + 1) = f\\<cdot>(n + 1)", "with strictF"], ["proof (chain)\npicking this:\n  f\\<cdot>\\<bottom> = \\<bottom>\n  f\\<cdot>\\<bottom> = \\<bottom>", "show ?case"], ["proof (prove)\nusing this:\n  f\\<cdot>\\<bottom> = \\<bottom>\n  f\\<cdot>\\<bottom> = \\<bottom>\n\ngoal (1 subgoal):\n 1. unwrapS\\<cdot>f !! \\<bottom> = f\\<cdot>\\<bottom>", "by simp"], ["proof (state)\nthis:\n  unwrapS\\<cdot>f !! \\<bottom> = f\\<cdot>\\<bottom>\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n       unwrapS\\<cdot>f !! 0 = f\\<cdot>0\n 2. \\<And>n f.\n       \\<lbrakk>n \\<noteq> \\<bottom>;\n        \\<And>f.\n           f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n           unwrapS\\<cdot>f !! n = f\\<cdot>n;\n        f\\<cdot>\\<bottom> = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> unwrapS\\<cdot>f !! (n + 1) = f\\<cdot>(n + 1)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f.\n       f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n       unwrapS\\<cdot>f !! 0 = f\\<cdot>0\n 2. \\<And>n f.\n       \\<lbrakk>n \\<noteq> \\<bottom>;\n        \\<And>f.\n           f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n           unwrapS\\<cdot>f !! n = f\\<cdot>n;\n        f\\<cdot>\\<bottom> = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> unwrapS\\<cdot>f !! (n + 1) = f\\<cdot>(n + 1)", "case zero"], ["proof (state)\nthis:\n  f\\<cdot>\\<bottom> = \\<bottom>\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n       unwrapS\\<cdot>f !! 0 = f\\<cdot>0\n 2. \\<And>n f.\n       \\<lbrakk>n \\<noteq> \\<bottom>;\n        \\<And>f.\n           f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n           unwrapS\\<cdot>f !! n = f\\<cdot>n;\n        f\\<cdot>\\<bottom> = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> unwrapS\\<cdot>f !! (n + 1) = f\\<cdot>(n + 1)", "thus ?case"], ["proof (prove)\nusing this:\n  f\\<cdot>\\<bottom> = \\<bottom>\n\ngoal (1 subgoal):\n 1. unwrapS\\<cdot>f !! 0 = f\\<cdot>0", "by (subst unwrapS.unfold, simp)"], ["proof (state)\nthis:\n  unwrapS\\<cdot>f !! 0 = f\\<cdot>0\n\ngoal (1 subgoal):\n 1. \\<And>n f.\n       \\<lbrakk>n \\<noteq> \\<bottom>;\n        \\<And>f.\n           f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n           unwrapS\\<cdot>f !! n = f\\<cdot>n;\n        f\\<cdot>\\<bottom> = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> unwrapS\\<cdot>f !! (n + 1) = f\\<cdot>(n + 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n f.\n       \\<lbrakk>n \\<noteq> \\<bottom>;\n        \\<And>f.\n           f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n           unwrapS\\<cdot>f !! n = f\\<cdot>n;\n        f\\<cdot>\\<bottom> = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> unwrapS\\<cdot>f !! (n + 1) = f\\<cdot>(n + 1)", "case (Suc i f)"], ["proof (state)\nthis:\n  i \\<noteq> \\<bottom>\n  ?f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n  unwrapS\\<cdot>?f !! i = ?f\\<cdot>i\n  f\\<cdot>\\<bottom> = \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<And>n f.\n       \\<lbrakk>n \\<noteq> \\<bottom>;\n        \\<And>f.\n           f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n           unwrapS\\<cdot>f !! n = f\\<cdot>n;\n        f\\<cdot>\\<bottom> = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> unwrapS\\<cdot>f !! (n + 1) = f\\<cdot>(n + 1)", "have \"unwrapS\\<cdot>f !! (i + 1) = (f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x))) !! (i + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unwrapS\\<cdot>f !! (i + 1) =\n    (f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x))) !! (i + 1)", "by (subst unwrapS.unfold, simp)"], ["proof (state)\nthis:\n  unwrapS\\<cdot>f !! (i + 1) =\n  (f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x))) !! (i + 1)\n\ngoal (1 subgoal):\n 1. \\<And>n f.\n       \\<lbrakk>n \\<noteq> \\<bottom>;\n        \\<And>f.\n           f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n           unwrapS\\<cdot>f !! n = f\\<cdot>n;\n        f\\<cdot>\\<bottom> = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> unwrapS\\<cdot>f !! (n + 1) = f\\<cdot>(n + 1)", "also"], ["proof (state)\nthis:\n  unwrapS\\<cdot>f !! (i + 1) =\n  (f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x))) !! (i + 1)\n\ngoal (1 subgoal):\n 1. \\<And>n f.\n       \\<lbrakk>n \\<noteq> \\<bottom>;\n        \\<And>f.\n           f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n           unwrapS\\<cdot>f !! n = f\\<cdot>n;\n        f\\<cdot>\\<bottom> = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> unwrapS\\<cdot>f !! (n + 1) = f\\<cdot>(n + 1)", "from Suc"], ["proof (chain)\npicking this:\n  i \\<noteq> \\<bottom>\n  ?f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n  unwrapS\\<cdot>?f !! i = ?f\\<cdot>i\n  f\\<cdot>\\<bottom> = \\<bottom>", "have \"\\<dots> = unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x)) !! i\""], ["proof (prove)\nusing this:\n  i \\<noteq> \\<bottom>\n  ?f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n  unwrapS\\<cdot>?f !! i = ?f\\<cdot>i\n  f\\<cdot>\\<bottom> = \\<bottom>\n\ngoal (1 subgoal):\n 1. (f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x))) !! (i + 1) =\n    unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x)) !! i", "by simp"], ["proof (state)\nthis:\n  (f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x))) !! (i + 1) =\n  unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x)) !! i\n\ngoal (1 subgoal):\n 1. \\<And>n f.\n       \\<lbrakk>n \\<noteq> \\<bottom>;\n        \\<And>f.\n           f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n           unwrapS\\<cdot>f !! n = f\\<cdot>n;\n        f\\<cdot>\\<bottom> = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> unwrapS\\<cdot>f !! (n + 1) = f\\<cdot>(n + 1)", "also"], ["proof (state)\nthis:\n  (f\\<cdot>0 && unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x))) !! (i + 1) =\n  unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x)) !! i\n\ngoal (1 subgoal):\n 1. \\<And>n f.\n       \\<lbrakk>n \\<noteq> \\<bottom>;\n        \\<And>f.\n           f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n           unwrapS\\<cdot>f !! n = f\\<cdot>n;\n        f\\<cdot>\\<bottom> = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> unwrapS\\<cdot>f !! (n + 1) = f\\<cdot>(n + 1)", "from Suc"], ["proof (chain)\npicking this:\n  i \\<noteq> \\<bottom>\n  ?f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n  unwrapS\\<cdot>?f !! i = ?f\\<cdot>i\n  f\\<cdot>\\<bottom> = \\<bottom>", "have \"\\<dots> = (f oo (\\<Lambda> x. 1 + x))\\<cdot>i\""], ["proof (prove)\nusing this:\n  i \\<noteq> \\<bottom>\n  ?f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n  unwrapS\\<cdot>?f !! i = ?f\\<cdot>i\n  f\\<cdot>\\<bottom> = \\<bottom>\n\ngoal (1 subgoal):\n 1. unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x)) !! i =\n    (f oo (\\<Lambda> x. 1 + x))\\<cdot>i", "by simp"], ["proof (state)\nthis:\n  unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x)) !! i =\n  (f oo (\\<Lambda> x. 1 + x))\\<cdot>i\n\ngoal (1 subgoal):\n 1. \\<And>n f.\n       \\<lbrakk>n \\<noteq> \\<bottom>;\n        \\<And>f.\n           f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n           unwrapS\\<cdot>f !! n = f\\<cdot>n;\n        f\\<cdot>\\<bottom> = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> unwrapS\\<cdot>f !! (n + 1) = f\\<cdot>(n + 1)", "also"], ["proof (state)\nthis:\n  unwrapS\\<cdot>(f oo (\\<Lambda> x. 1 + x)) !! i =\n  (f oo (\\<Lambda> x. 1 + x))\\<cdot>i\n\ngoal (1 subgoal):\n 1. \\<And>n f.\n       \\<lbrakk>n \\<noteq> \\<bottom>;\n        \\<And>f.\n           f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n           unwrapS\\<cdot>f !! n = f\\<cdot>n;\n        f\\<cdot>\\<bottom> = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> unwrapS\\<cdot>f !! (n + 1) = f\\<cdot>(n + 1)", "have \"\\<dots> = f\\<cdot>(i + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f oo (\\<Lambda> x. 1 + x))\\<cdot>i = f\\<cdot>(i + 1)", "by (simp add: plus_commute)"], ["proof (state)\nthis:\n  (f oo (\\<Lambda> x. 1 + x))\\<cdot>i = f\\<cdot>(i + 1)\n\ngoal (1 subgoal):\n 1. \\<And>n f.\n       \\<lbrakk>n \\<noteq> \\<bottom>;\n        \\<And>f.\n           f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n           unwrapS\\<cdot>f !! n = f\\<cdot>n;\n        f\\<cdot>\\<bottom> = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> unwrapS\\<cdot>f !! (n + 1) = f\\<cdot>(n + 1)", "finally"], ["proof (chain)\npicking this:\n  unwrapS\\<cdot>f !! (i + 1) = f\\<cdot>(i + 1)", "show ?case"], ["proof (prove)\nusing this:\n  unwrapS\\<cdot>f !! (i + 1) = f\\<cdot>(i + 1)\n\ngoal (1 subgoal):\n 1. unwrapS\\<cdot>f !! (i + 1) = f\\<cdot>(i + 1)", "."], ["proof (state)\nthis:\n  unwrapS\\<cdot>f !! (i + 1) = f\\<cdot>(i + 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wrapS_unwrapS_id: \"f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow> (wrapS oo unwrapS)\\<cdot>f = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n    (wrapS oo unwrapS)\\<cdot>f = f", "by (rule cfun_eqI, simp add: wrapS_unwrapS_id' wrapS_def)"], ["", "subsection\\<open>Fibonacci example.\\<close>"], ["", "definition\n  fib_body :: \"(Nat \\<rightarrow> Nat) \\<rightarrow> Nat \\<rightarrow> Nat\" where\n  \"fib_body \\<equiv> \\<Lambda> r. Nat_case\\<cdot>1\\<cdot>(Nat_case\\<cdot>1\\<cdot>(\\<Lambda> n. r\\<cdot>n + r\\<cdot>(n + 1)))\""], ["", "(*<*)"], ["", "lemma fib_body_strict[simp]: \"fib_body\\<cdot>r\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fib_body\\<cdot>r\\<cdot>\\<bottom> = \\<bottom>", "by (simp add: fib_body_def)"], ["", "(*>*)"], ["", "definition\n  fib :: \"Nat \\<rightarrow> Nat\" where\n  \"fib \\<equiv> fix\\<cdot>fib_body\""], ["", "(*<*)"], ["", "lemma fib_strict[simp]: \"fib\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fib\\<cdot>\\<bottom> = \\<bottom>", "by (unfold fib_def, subst fix_eq, fold fib_def, simp add: fib_body_def)"], ["", "(*>*)"], ["", "text\\<open>Apply worker/wrapper.\\<close>"], ["", "definition\n  fib_work :: \"Nat Stream\" where\n  \"fib_work \\<equiv> fix\\<cdot>(unwrapS oo fib_body oo wrapS)\""], ["", "definition\n  fib_wrap :: \"Nat \\<rightarrow> Nat\" where\n  \"fib_wrap \\<equiv> wrapS\\<cdot>fib_work\""], ["", "lemma wrapS_unwrapS_fib_body: \"wrapS oo unwrapS oo fib_body = fib_body\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wrapS oo unwrapS oo fib_body = fib_body", "proof(rule cfun_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (wrapS oo unwrapS oo fib_body)\\<cdot>x = fib_body\\<cdot>x", "fix r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (wrapS oo unwrapS oo fib_body)\\<cdot>x = fib_body\\<cdot>x", "show \"(wrapS oo unwrapS oo fib_body)\\<cdot>r = fib_body\\<cdot>r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (wrapS oo unwrapS oo fib_body)\\<cdot>r = fib_body\\<cdot>r", "using wrapS_unwrapS_id[where f=\"fib_body\\<cdot>r\"]"], ["proof (prove)\nusing this:\n  fib_body\\<cdot>r\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n  (wrapS oo unwrapS)\\<cdot>(fib_body\\<cdot>r) = fib_body\\<cdot>r\n\ngoal (1 subgoal):\n 1. (wrapS oo unwrapS oo fib_body)\\<cdot>r = fib_body\\<cdot>r", "by simp"], ["proof (state)\nthis:\n  (wrapS oo unwrapS oo fib_body)\\<cdot>r = fib_body\\<cdot>r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fib_ww_eq: \"fib = fib_wrap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fib = fib_wrap", "using worker_wrapper_body[OF wrapS_unwrapS_fib_body]"], ["proof (prove)\nusing this:\n  ?computation = fix\\<cdot>fib_body \\<Longrightarrow>\n  ?computation = wrapS\\<cdot>(fix\\<cdot>(unwrapS oo fib_body oo wrapS))\n\ngoal (1 subgoal):\n 1. fib = fib_wrap", "by (simp add: fib_def fib_wrap_def fib_work_def)"], ["", "text\\<open>Optimise.\\<close>"], ["", "fixrec\n  fib_work_final :: \"Nat Stream\"\nand\n  fib_f_final :: \"Nat \\<rightarrow> Nat\"\nwhere\n  \"fib_work_final = smap\\<cdot>fib_f_final\\<cdot>nats\"\n| \"fib_f_final = Nat_case\\<cdot>1\\<cdot>(Nat_case\\<cdot>1\\<cdot>(\\<Lambda> n'. fib_work_final !! n' + fib_work_final !! (n' + 1)))\""], ["", "declare fib_f_final.simps[simp del] fib_work_final.simps[simp del]"], ["", "definition\n  fib_final :: \"Nat \\<rightarrow> Nat\" where\n  \"fib_final \\<equiv> \\<Lambda> n. fib_work_final !! n\""], ["", "text\\<open>\n\nThis proof is only fiddly due to the way mutual recursion is encoded:\nwe need to use Beki\\'{c}'s Theorem \\citep{Bekic:1969}\\footnote{The\ninterested reader can find some historical commentary in\n\\citet{Harel:1980, DBLP:journals/toplas/Sangiorgi09}.} to massage the\ndefinitions into their final form.\n\n\\<close>"], ["", "lemma fib_work_final_fib_work_eq: \"fib_work_final = fib_work\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. fib_work_final = fib_work", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fib_work_final = fib_work", "let ?wb = \"\\<Lambda> r. Nat_case\\<cdot>1\\<cdot>(Nat_case\\<cdot>1\\<cdot>(\\<Lambda> n'. r !! n' + r !! (n' + 1)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. fib_work_final = fib_work", "let ?mr = \"\\<Lambda> (fwf :: Nat Stream, fff). (smap\\<cdot>fff\\<cdot>nats, ?wb\\<cdot>fwf)\""], ["proof (state)\ngoal (1 subgoal):\n 1. fib_work_final = fib_work", "have \"?lhs = fst (fix\\<cdot>?mr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fib_work_final =\n    fst (fix\\<cdot>\n         (\\<Lambda> (fwf, fff).\n             (smap\\<cdot>fff\\<cdot>nats,\n              (\\<Lambda> r.\n                  Nat_case\\<cdot>1\\<cdot>\n                  (Nat_case\\<cdot>1\\<cdot>\n                   (\\<Lambda> n'. r !! n' + r !! (n' + 1))))\\<cdot>\n              fwf)))", "by (simp add: fib_work_final_def split_def csplit_def)"], ["proof (state)\nthis:\n  fib_work_final =\n  fst (fix\\<cdot>\n       (\\<Lambda> (fwf, fff).\n           (smap\\<cdot>fff\\<cdot>nats,\n            (\\<Lambda> r.\n                Nat_case\\<cdot>1\\<cdot>\n                (Nat_case\\<cdot>1\\<cdot>\n                 (\\<Lambda> n'. r !! n' + r !! (n' + 1))))\\<cdot>\n            fwf)))\n\ngoal (1 subgoal):\n 1. fib_work_final = fib_work", "also"], ["proof (state)\nthis:\n  fib_work_final =\n  fst (fix\\<cdot>\n       (\\<Lambda> (fwf, fff).\n           (smap\\<cdot>fff\\<cdot>nats,\n            (\\<Lambda> r.\n                Nat_case\\<cdot>1\\<cdot>\n                (Nat_case\\<cdot>1\\<cdot>\n                 (\\<Lambda> n'. r !! n' + r !! (n' + 1))))\\<cdot>\n            fwf)))\n\ngoal (1 subgoal):\n 1. fib_work_final = fib_work", "have \"\\<dots> = (\\<mu> fwf. fst (?mr\\<cdot>(fwf, \\<mu> fff. snd (?mr\\<cdot>(fwf, fff)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (fix\\<cdot>\n         (\\<Lambda> (fwf, fff).\n             (smap\\<cdot>fff\\<cdot>nats,\n              (\\<Lambda> r.\n                  Nat_case\\<cdot>1\\<cdot>\n                  (Nat_case\\<cdot>1\\<cdot>\n                   (\\<Lambda> n'. r !! n' + r !! (n' + 1))))\\<cdot>\n              fwf))) =\n    (\\<mu> x.\n        fst ((\\<Lambda> (fwf, fff).\n                 (smap\\<cdot>fff\\<cdot>nats,\n                  (\\<Lambda> r.\n                      Nat_case\\<cdot>1\\<cdot>\n                      (Nat_case\\<cdot>1\\<cdot>\n                       (\\<Lambda> n'. r !! n' + r !! (n' + 1))))\\<cdot>\n                  fwf))\\<cdot>\n             (x, \\<mu> xa.\n                    snd ((\\<Lambda> (fwf, fff).\n                             (smap\\<cdot>fff\\<cdot>nats,\n                              (\\<Lambda> r.\n                                  Nat_case\\<cdot>1\\<cdot>\n                                  (Nat_case\\<cdot>1\\<cdot>\n                                   (\\<Lambda> n'.\n r !! n' + r !! (n' + 1))))\\<cdot>\n                              fwf))\\<cdot>\n                         (x, xa)))))", "using fix_cprod[where F=\"?mr\"]"], ["proof (prove)\nusing this:\n  fix\\<cdot>\n  (\\<Lambda> (fwf, fff).\n      (smap\\<cdot>fff\\<cdot>nats,\n       (\\<Lambda> r.\n           Nat_case\\<cdot>1\\<cdot>\n           (Nat_case\\<cdot>1\\<cdot>\n            (\\<Lambda> n'. r !! n' + r !! (n' + 1))))\\<cdot>\n       fwf)) =\n  (\\<mu> x.\n      fst ((\\<Lambda> (fwf, fff).\n               (smap\\<cdot>fff\\<cdot>nats,\n                (\\<Lambda> r.\n                    Nat_case\\<cdot>1\\<cdot>\n                    (Nat_case\\<cdot>1\\<cdot>\n                     (\\<Lambda> n'. r !! n' + r !! (n' + 1))))\\<cdot>\n                fwf))\\<cdot>\n           (x, \\<mu> xa.\n                  snd ((\\<Lambda> (fwf, fff).\n                           (smap\\<cdot>fff\\<cdot>nats,\n                            (\\<Lambda> r.\n                                Nat_case\\<cdot>1\\<cdot>\n                                (Nat_case\\<cdot>1\\<cdot>\n                                 (\\<Lambda> n'.\n                                     r !! n' + r !! (n' + 1))))\\<cdot>\n                            fwf))\\<cdot>\n                       (x, xa)))),\n   \\<mu> x.\n      snd ((\\<Lambda> (fwf, fff).\n               (smap\\<cdot>fff\\<cdot>nats,\n                (\\<Lambda> r.\n                    Nat_case\\<cdot>1\\<cdot>\n                    (Nat_case\\<cdot>1\\<cdot>\n                     (\\<Lambda> n'. r !! n' + r !! (n' + 1))))\\<cdot>\n                fwf))\\<cdot>\n           (\\<mu> x.\n               fst ((\\<Lambda> (fwf, fff).\n                        (smap\\<cdot>fff\\<cdot>nats,\n                         (\\<Lambda> r.\n                             Nat_case\\<cdot>1\\<cdot>\n                             (Nat_case\\<cdot>1\\<cdot>\n                              (\\<Lambda> n'.\n                                  r !! n' + r !! (n' + 1))))\\<cdot>\n                         fwf))\\<cdot>\n                    (x, \\<mu> xa.\n                           snd ((\\<Lambda> (fwf, fff).\n                                    (smap\\<cdot>fff\\<cdot>nats,\n                                     (\\<Lambda> r.\n   Nat_case\\<cdot>1\\<cdot>\n   (Nat_case\\<cdot>1\\<cdot>(\\<Lambda> n'. r !! n' + r !! (n' + 1))))\\<cdot>\n                                     fwf))\\<cdot>\n                                (x, xa)))),\n            x)))\n\ngoal (1 subgoal):\n 1. fst (fix\\<cdot>\n         (\\<Lambda> (fwf, fff).\n             (smap\\<cdot>fff\\<cdot>nats,\n              (\\<Lambda> r.\n                  Nat_case\\<cdot>1\\<cdot>\n                  (Nat_case\\<cdot>1\\<cdot>\n                   (\\<Lambda> n'. r !! n' + r !! (n' + 1))))\\<cdot>\n              fwf))) =\n    (\\<mu> x.\n        fst ((\\<Lambda> (fwf, fff).\n                 (smap\\<cdot>fff\\<cdot>nats,\n                  (\\<Lambda> r.\n                      Nat_case\\<cdot>1\\<cdot>\n                      (Nat_case\\<cdot>1\\<cdot>\n                       (\\<Lambda> n'. r !! n' + r !! (n' + 1))))\\<cdot>\n                  fwf))\\<cdot>\n             (x, \\<mu> xa.\n                    snd ((\\<Lambda> (fwf, fff).\n                             (smap\\<cdot>fff\\<cdot>nats,\n                              (\\<Lambda> r.\n                                  Nat_case\\<cdot>1\\<cdot>\n                                  (Nat_case\\<cdot>1\\<cdot>\n                                   (\\<Lambda> n'.\n r !! n' + r !! (n' + 1))))\\<cdot>\n                              fwf))\\<cdot>\n                         (x, xa)))))", "by simp"], ["proof (state)\nthis:\n  fst (fix\\<cdot>\n       (\\<Lambda> (fwf, fff).\n           (smap\\<cdot>fff\\<cdot>nats,\n            (\\<Lambda> r.\n                Nat_case\\<cdot>1\\<cdot>\n                (Nat_case\\<cdot>1\\<cdot>\n                 (\\<Lambda> n'. r !! n' + r !! (n' + 1))))\\<cdot>\n            fwf))) =\n  (\\<mu> x.\n      fst ((\\<Lambda> (fwf, fff).\n               (smap\\<cdot>fff\\<cdot>nats,\n                (\\<Lambda> r.\n                    Nat_case\\<cdot>1\\<cdot>\n                    (Nat_case\\<cdot>1\\<cdot>\n                     (\\<Lambda> n'. r !! n' + r !! (n' + 1))))\\<cdot>\n                fwf))\\<cdot>\n           (x, \\<mu> xa.\n                  snd ((\\<Lambda> (fwf, fff).\n                           (smap\\<cdot>fff\\<cdot>nats,\n                            (\\<Lambda> r.\n                                Nat_case\\<cdot>1\\<cdot>\n                                (Nat_case\\<cdot>1\\<cdot>\n                                 (\\<Lambda> n'.\n                                     r !! n' + r !! (n' + 1))))\\<cdot>\n                            fwf))\\<cdot>\n                       (x, xa)))))\n\ngoal (1 subgoal):\n 1. fib_work_final = fib_work", "also"], ["proof (state)\nthis:\n  fst (fix\\<cdot>\n       (\\<Lambda> (fwf, fff).\n           (smap\\<cdot>fff\\<cdot>nats,\n            (\\<Lambda> r.\n                Nat_case\\<cdot>1\\<cdot>\n                (Nat_case\\<cdot>1\\<cdot>\n                 (\\<Lambda> n'. r !! n' + r !! (n' + 1))))\\<cdot>\n            fwf))) =\n  (\\<mu> x.\n      fst ((\\<Lambda> (fwf, fff).\n               (smap\\<cdot>fff\\<cdot>nats,\n                (\\<Lambda> r.\n                    Nat_case\\<cdot>1\\<cdot>\n                    (Nat_case\\<cdot>1\\<cdot>\n                     (\\<Lambda> n'. r !! n' + r !! (n' + 1))))\\<cdot>\n                fwf))\\<cdot>\n           (x, \\<mu> xa.\n                  snd ((\\<Lambda> (fwf, fff).\n                           (smap\\<cdot>fff\\<cdot>nats,\n                            (\\<Lambda> r.\n                                Nat_case\\<cdot>1\\<cdot>\n                                (Nat_case\\<cdot>1\\<cdot>\n                                 (\\<Lambda> n'.\n                                     r !! n' + r !! (n' + 1))))\\<cdot>\n                            fwf))\\<cdot>\n                       (x, xa)))))\n\ngoal (1 subgoal):\n 1. fib_work_final = fib_work", "have \"\\<dots> = (\\<mu> fwf. smap\\<cdot>(\\<mu> fff. ?wb\\<cdot>fwf)\\<cdot>nats)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<mu> x.\n        fst ((\\<Lambda> (fwf, fff).\n                 (smap\\<cdot>fff\\<cdot>nats,\n                  (\\<Lambda> r.\n                      Nat_case\\<cdot>1\\<cdot>\n                      (Nat_case\\<cdot>1\\<cdot>\n                       (\\<Lambda> n'. r !! n' + r !! (n' + 1))))\\<cdot>\n                  fwf))\\<cdot>\n             (x, \\<mu> xa.\n                    snd ((\\<Lambda> (fwf, fff).\n                             (smap\\<cdot>fff\\<cdot>nats,\n                              (\\<Lambda> r.\n                                  Nat_case\\<cdot>1\\<cdot>\n                                  (Nat_case\\<cdot>1\\<cdot>\n                                   (\\<Lambda> n'.\n r !! n' + r !! (n' + 1))))\\<cdot>\n                              fwf))\\<cdot>\n                         (x, xa))))) =\n    (\\<mu> x.\n        smap\\<cdot>\n        (\\<mu> xa.\n            (\\<Lambda> r.\n                Nat_case\\<cdot>1\\<cdot>\n                (Nat_case\\<cdot>1\\<cdot>\n                 (\\<Lambda> n'. r !! n' + r !! (n' + 1))))\\<cdot>\n            x)\\<cdot>\n        nats)", "by simp"], ["proof (state)\nthis:\n  (\\<mu> x.\n      fst ((\\<Lambda> (fwf, fff).\n               (smap\\<cdot>fff\\<cdot>nats,\n                (\\<Lambda> r.\n                    Nat_case\\<cdot>1\\<cdot>\n                    (Nat_case\\<cdot>1\\<cdot>\n                     (\\<Lambda> n'. r !! n' + r !! (n' + 1))))\\<cdot>\n                fwf))\\<cdot>\n           (x, \\<mu> xa.\n                  snd ((\\<Lambda> (fwf, fff).\n                           (smap\\<cdot>fff\\<cdot>nats,\n                            (\\<Lambda> r.\n                                Nat_case\\<cdot>1\\<cdot>\n                                (Nat_case\\<cdot>1\\<cdot>\n                                 (\\<Lambda> n'.\n                                     r !! n' + r !! (n' + 1))))\\<cdot>\n                            fwf))\\<cdot>\n                       (x, xa))))) =\n  (\\<mu> x.\n      smap\\<cdot>\n      (\\<mu> xa.\n          (\\<Lambda> r.\n              Nat_case\\<cdot>1\\<cdot>\n              (Nat_case\\<cdot>1\\<cdot>\n               (\\<Lambda> n'. r !! n' + r !! (n' + 1))))\\<cdot>\n          x)\\<cdot>\n      nats)\n\ngoal (1 subgoal):\n 1. fib_work_final = fib_work", "also"], ["proof (state)\nthis:\n  (\\<mu> x.\n      fst ((\\<Lambda> (fwf, fff).\n               (smap\\<cdot>fff\\<cdot>nats,\n                (\\<Lambda> r.\n                    Nat_case\\<cdot>1\\<cdot>\n                    (Nat_case\\<cdot>1\\<cdot>\n                     (\\<Lambda> n'. r !! n' + r !! (n' + 1))))\\<cdot>\n                fwf))\\<cdot>\n           (x, \\<mu> xa.\n                  snd ((\\<Lambda> (fwf, fff).\n                           (smap\\<cdot>fff\\<cdot>nats,\n                            (\\<Lambda> r.\n                                Nat_case\\<cdot>1\\<cdot>\n                                (Nat_case\\<cdot>1\\<cdot>\n                                 (\\<Lambda> n'.\n                                     r !! n' + r !! (n' + 1))))\\<cdot>\n                            fwf))\\<cdot>\n                       (x, xa))))) =\n  (\\<mu> x.\n      smap\\<cdot>\n      (\\<mu> xa.\n          (\\<Lambda> r.\n              Nat_case\\<cdot>1\\<cdot>\n              (Nat_case\\<cdot>1\\<cdot>\n               (\\<Lambda> n'. r !! n' + r !! (n' + 1))))\\<cdot>\n          x)\\<cdot>\n      nats)\n\ngoal (1 subgoal):\n 1. fib_work_final = fib_work", "have \"\\<dots> = (\\<mu> fwf. smap\\<cdot>(?wb\\<cdot>fwf)\\<cdot>nats)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<mu> x.\n        smap\\<cdot>\n        (\\<mu> xa.\n            (\\<Lambda> r.\n                Nat_case\\<cdot>1\\<cdot>\n                (Nat_case\\<cdot>1\\<cdot>\n                 (\\<Lambda> n'. r !! n' + r !! (n' + 1))))\\<cdot>\n            x)\\<cdot>\n        nats) =\n    (\\<mu> x.\n        smap\\<cdot>\n        ((\\<Lambda> r.\n             Nat_case\\<cdot>1\\<cdot>\n             (Nat_case\\<cdot>1\\<cdot>\n              (\\<Lambda> n'. r !! n' + r !! (n' + 1))))\\<cdot>\n         x)\\<cdot>\n        nats)", "by (simp add: fix_const)"], ["proof (state)\nthis:\n  (\\<mu> x.\n      smap\\<cdot>\n      (\\<mu> xa.\n          (\\<Lambda> r.\n              Nat_case\\<cdot>1\\<cdot>\n              (Nat_case\\<cdot>1\\<cdot>\n               (\\<Lambda> n'. r !! n' + r !! (n' + 1))))\\<cdot>\n          x)\\<cdot>\n      nats) =\n  (\\<mu> x.\n      smap\\<cdot>\n      ((\\<Lambda> r.\n           Nat_case\\<cdot>1\\<cdot>\n           (Nat_case\\<cdot>1\\<cdot>\n            (\\<Lambda> n'. r !! n' + r !! (n' + 1))))\\<cdot>\n       x)\\<cdot>\n      nats)\n\ngoal (1 subgoal):\n 1. fib_work_final = fib_work", "also"], ["proof (state)\nthis:\n  (\\<mu> x.\n      smap\\<cdot>\n      (\\<mu> xa.\n          (\\<Lambda> r.\n              Nat_case\\<cdot>1\\<cdot>\n              (Nat_case\\<cdot>1\\<cdot>\n               (\\<Lambda> n'. r !! n' + r !! (n' + 1))))\\<cdot>\n          x)\\<cdot>\n      nats) =\n  (\\<mu> x.\n      smap\\<cdot>\n      ((\\<Lambda> r.\n           Nat_case\\<cdot>1\\<cdot>\n           (Nat_case\\<cdot>1\\<cdot>\n            (\\<Lambda> n'. r !! n' + r !! (n' + 1))))\\<cdot>\n       x)\\<cdot>\n      nats)\n\ngoal (1 subgoal):\n 1. fib_work_final = fib_work", "have \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<mu> x.\n        smap\\<cdot>\n        ((\\<Lambda> r.\n             Nat_case\\<cdot>1\\<cdot>\n             (Nat_case\\<cdot>1\\<cdot>\n              (\\<Lambda> n'. r !! n' + r !! (n' + 1))))\\<cdot>\n         x)\\<cdot>\n        nats) =\n    fib_work", "unfolding fib_body_def fib_work_def unwrapS_unwrapS'_eq unwrapS'_def wrapS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<mu> x.\n        smap\\<cdot>\n        ((\\<Lambda> r.\n             Nat_case\\<cdot>1\\<cdot>\n             (Nat_case\\<cdot>1\\<cdot>\n              (\\<Lambda> n'. r !! n' + r !! (n' + 1))))\\<cdot>\n         x)\\<cdot>\n        nats) =\n    fix\\<cdot>\n    ((\\<Lambda> f. smap\\<cdot>f\\<cdot>nats) oo\n     (\\<Lambda> r.\n         Nat_case\\<cdot>1\\<cdot>\n         (Nat_case\\<cdot>1\\<cdot>\n          (\\<Lambda> n. r\\<cdot>n + r\\<cdot>(n + 1)))) oo\n     (\\<Lambda> s. Abs_cfun ((!!) s)))", "by (simp add: cfcomp1)"], ["proof (state)\nthis:\n  (\\<mu> x.\n      smap\\<cdot>\n      ((\\<Lambda> r.\n           Nat_case\\<cdot>1\\<cdot>\n           (Nat_case\\<cdot>1\\<cdot>\n            (\\<Lambda> n'. r !! n' + r !! (n' + 1))))\\<cdot>\n       x)\\<cdot>\n      nats) =\n  fib_work\n\ngoal (1 subgoal):\n 1. fib_work_final = fib_work", "finally"], ["proof (chain)\npicking this:\n  fib_work_final = fib_work", "show ?thesis"], ["proof (prove)\nusing this:\n  fib_work_final = fib_work\n\ngoal (1 subgoal):\n 1. fib_work_final = fib_work", "."], ["proof (state)\nthis:\n  fib_work_final = fib_work\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fib_final_fib_eq: \"fib_final = fib\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. fib_final = fib", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fib_final = fib", "have \"?lhs = (\\<Lambda> n. fib_work_final !! n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fib_final = Abs_cfun ((!!) fib_work_final)", "by (simp add: fib_final_def)"], ["proof (state)\nthis:\n  fib_final = Abs_cfun ((!!) fib_work_final)\n\ngoal (1 subgoal):\n 1. fib_final = fib", "also"], ["proof (state)\nthis:\n  fib_final = Abs_cfun ((!!) fib_work_final)\n\ngoal (1 subgoal):\n 1. fib_final = fib", "have \"\\<dots> = (\\<Lambda> n. fib_work !! n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_cfun ((!!) fib_work_final) = Abs_cfun ((!!) fib_work)", "by (simp only: fib_work_final_fib_work_eq)"], ["proof (state)\nthis:\n  Abs_cfun ((!!) fib_work_final) = Abs_cfun ((!!) fib_work)\n\ngoal (1 subgoal):\n 1. fib_final = fib", "also"], ["proof (state)\nthis:\n  Abs_cfun ((!!) fib_work_final) = Abs_cfun ((!!) fib_work)\n\ngoal (1 subgoal):\n 1. fib_final = fib", "have \"\\<dots> = fib_wrap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_cfun ((!!) fib_work) = fib_wrap", "by (simp add: fib_wrap_def wrapS_def)"], ["proof (state)\nthis:\n  Abs_cfun ((!!) fib_work) = fib_wrap\n\ngoal (1 subgoal):\n 1. fib_final = fib", "also"], ["proof (state)\nthis:\n  Abs_cfun ((!!) fib_work) = fib_wrap\n\ngoal (1 subgoal):\n 1. fib_final = fib", "have \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fib_wrap = fib", "by (simp only: fib_ww_eq)"], ["proof (state)\nthis:\n  fib_wrap = fib\n\ngoal (1 subgoal):\n 1. fib_final = fib", "finally"], ["proof (chain)\npicking this:\n  fib_final = fib", "show ?thesis"], ["proof (prove)\nusing this:\n  fib_final = fib\n\ngoal (1 subgoal):\n 1. fib_final = fib", "."], ["proof (state)\nthis:\n  fib_final = fib\n\ngoal:\nNo subgoals!", "qed"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}