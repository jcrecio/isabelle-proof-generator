{"file_name": "/home/qj213/afp-2021-10-22/thys/WorkerWrapper/CounterExample.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/WorkerWrapper", "problem_names": ["lemma fusion_partially_correct:\n  assumes wrap_unwrap: \"wrap oo unwrap = ID\"\n  assumes work: \"work = fix\\<cdot>(unwrap oo body oo wrap)\"\n  assumes body': \"unwrap oo body oo wrap = body' oo unwrap oo wrap\"\n  shows \"fix\\<cdot>body' \\<sqsubseteq> work\"", "lemma wrap_strict[simp]: \"wrap\\<cdot>\\<bottom> = \\<bottom>\"", "lemma wrap_unwrap: \"wrap oo unwrap = ID\"", "lemma body'_strict[simp]: \"body'\\<cdot>\\<bottom> = \\<bottom>\"", "lemma body_body': \"unwrap oo body oo wrap = body' oo unwrap oo wrap\"", "lemma \"fix\\<cdot>body' \\<sqsubseteq> fix\\<cdot>(unwrap oo body oo wrap)\"", "lemma \"\\<not> fix\\<cdot>(unwrap oo body oo wrap) \\<sqsubseteq> fix\\<cdot>body'\"", "lemma\n  assumes \"wrap oo unwrap = ID\"\n  shows \"wrap oo strictify\\<cdot>unwrap = ID\"", "lemma\n  \"\\<not> strictify\\<cdot>unwrap oo body oo wrap = body' oo strictify\\<cdot>unwrap oo wrap\""], "translations": [["", "lemma fusion_partially_correct:\n  assumes wrap_unwrap: \"wrap oo unwrap = ID\"\n  assumes work: \"work = fix\\<cdot>(unwrap oo body oo wrap)\"\n  assumes body': \"unwrap oo body oo wrap = body' oo unwrap oo wrap\"\n  shows \"fix\\<cdot>body' \\<sqsubseteq> work\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fix\\<cdot>body' \\<sqsubseteq> work", "proof(rule fix_least)"], ["proof (state)\ngoal (1 subgoal):\n 1. body'\\<cdot>work = work", "have \"work = (unwrap oo body oo wrap)\\<cdot>work\""], ["proof (prove)\ngoal (1 subgoal):\n 1. work = (unwrap oo body oo wrap)\\<cdot>work", "using work"], ["proof (prove)\nusing this:\n  work = fix\\<cdot>(unwrap oo body oo wrap)\n\ngoal (1 subgoal):\n 1. work = (unwrap oo body oo wrap)\\<cdot>work", "by (simp add: fix_eq[symmetric])"], ["proof (state)\nthis:\n  work = (unwrap oo body oo wrap)\\<cdot>work\n\ngoal (1 subgoal):\n 1. body'\\<cdot>work = work", "also"], ["proof (state)\nthis:\n  work = (unwrap oo body oo wrap)\\<cdot>work\n\ngoal (1 subgoal):\n 1. body'\\<cdot>work = work", "have \"... = (body' oo unwrap oo wrap)\\<cdot>work\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (unwrap oo body oo wrap)\\<cdot>work =\n    (body' oo unwrap oo wrap)\\<cdot>work", "using body'"], ["proof (prove)\nusing this:\n  unwrap oo body oo wrap = body' oo unwrap oo wrap\n\ngoal (1 subgoal):\n 1. (unwrap oo body oo wrap)\\<cdot>work =\n    (body' oo unwrap oo wrap)\\<cdot>work", "by simp"], ["proof (state)\nthis:\n  (unwrap oo body oo wrap)\\<cdot>work = (body' oo unwrap oo wrap)\\<cdot>work\n\ngoal (1 subgoal):\n 1. body'\\<cdot>work = work", "also"], ["proof (state)\nthis:\n  (unwrap oo body oo wrap)\\<cdot>work = (body' oo unwrap oo wrap)\\<cdot>work\n\ngoal (1 subgoal):\n 1. body'\\<cdot>work = work", "have \"... = (body' oo unwrap oo wrap)\\<cdot>((unwrap oo body oo wrap)\\<cdot>work)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (body' oo unwrap oo wrap)\\<cdot>work =\n    (body' oo unwrap oo wrap)\\<cdot>((unwrap oo body oo wrap)\\<cdot>work)", "using work"], ["proof (prove)\nusing this:\n  work = fix\\<cdot>(unwrap oo body oo wrap)\n\ngoal (1 subgoal):\n 1. (body' oo unwrap oo wrap)\\<cdot>work =\n    (body' oo unwrap oo wrap)\\<cdot>((unwrap oo body oo wrap)\\<cdot>work)", "by (simp add: fix_eq[symmetric])"], ["proof (state)\nthis:\n  (body' oo unwrap oo wrap)\\<cdot>work =\n  (body' oo unwrap oo wrap)\\<cdot>((unwrap oo body oo wrap)\\<cdot>work)\n\ngoal (1 subgoal):\n 1. body'\\<cdot>work = work", "also"], ["proof (state)\nthis:\n  (body' oo unwrap oo wrap)\\<cdot>work =\n  (body' oo unwrap oo wrap)\\<cdot>((unwrap oo body oo wrap)\\<cdot>work)\n\ngoal (1 subgoal):\n 1. body'\\<cdot>work = work", "have \"... = (body' oo unwrap oo wrap oo unwrap oo body oo wrap)\\<cdot>work\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (body' oo unwrap oo wrap)\\<cdot>((unwrap oo body oo wrap)\\<cdot>work) =\n    (body' oo unwrap oo wrap oo unwrap oo body oo wrap)\\<cdot>work", "by simp"], ["proof (state)\nthis:\n  (body' oo unwrap oo wrap)\\<cdot>((unwrap oo body oo wrap)\\<cdot>work) =\n  (body' oo unwrap oo wrap oo unwrap oo body oo wrap)\\<cdot>work\n\ngoal (1 subgoal):\n 1. body'\\<cdot>work = work", "also"], ["proof (state)\nthis:\n  (body' oo unwrap oo wrap)\\<cdot>((unwrap oo body oo wrap)\\<cdot>work) =\n  (body' oo unwrap oo wrap oo unwrap oo body oo wrap)\\<cdot>work\n\ngoal (1 subgoal):\n 1. body'\\<cdot>work = work", "have \"... = (body' oo unwrap oo body oo wrap)\\<cdot>work\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (body' oo unwrap oo wrap oo unwrap oo body oo wrap)\\<cdot>work =\n    (body' oo unwrap oo body oo wrap)\\<cdot>work", "using wrap_unwrap"], ["proof (prove)\nusing this:\n  wrap oo unwrap = ID\n\ngoal (1 subgoal):\n 1. (body' oo unwrap oo wrap oo unwrap oo body oo wrap)\\<cdot>work =\n    (body' oo unwrap oo body oo wrap)\\<cdot>work", "by (simp add: assoc_oo)"], ["proof (state)\nthis:\n  (body' oo unwrap oo wrap oo unwrap oo body oo wrap)\\<cdot>work =\n  (body' oo unwrap oo body oo wrap)\\<cdot>work\n\ngoal (1 subgoal):\n 1. body'\\<cdot>work = work", "also"], ["proof (state)\nthis:\n  (body' oo unwrap oo wrap oo unwrap oo body oo wrap)\\<cdot>work =\n  (body' oo unwrap oo body oo wrap)\\<cdot>work\n\ngoal (1 subgoal):\n 1. body'\\<cdot>work = work", "have \"... = body'\\<cdot>work\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (body' oo unwrap oo body oo wrap)\\<cdot>work = body'\\<cdot>work", "using work"], ["proof (prove)\nusing this:\n  work = fix\\<cdot>(unwrap oo body oo wrap)\n\ngoal (1 subgoal):\n 1. (body' oo unwrap oo body oo wrap)\\<cdot>work = body'\\<cdot>work", "by (simp add: fix_eq[symmetric])"], ["proof (state)\nthis:\n  (body' oo unwrap oo body oo wrap)\\<cdot>work = body'\\<cdot>work\n\ngoal (1 subgoal):\n 1. body'\\<cdot>work = work", "finally"], ["proof (chain)\npicking this:\n  work = body'\\<cdot>work", "show \"body'\\<cdot>work = work\""], ["proof (prove)\nusing this:\n  work = body'\\<cdot>work\n\ngoal (1 subgoal):\n 1. body'\\<cdot>work = work", "by simp"], ["proof (state)\nthis:\n  body'\\<cdot>work = work\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n\nThe next section shows the converse does not obtain.\n\n\\<close>"], ["", "subsection\\<open>A non-strict @{term \"unwrap\"} may go awry\\<close>"], ["", "text\\<open>\n\n\\label{sec:ww-counterexample}\n\nIf @{term \"unwrap\"} is non-strict, then it is possible that the fusion\nrule proposed by Gill and Hutton does not preserve termination. To\nshow this we take a small artificial example. The type @{term \"A\"} is\nnot important, but we need access to a non-bottom inhabitant. The\ntarget type @{term \"B\"} is the non-strict lift of @{term \"A\"}.\n\n\\<close>"], ["", "domain A = A"], ["", "domain B = B (lazy \"A\")"], ["", "text\\<open>\n\nThe functions @{term \"wrap\"} and @{term \"unwrap\"} that map between\nthese types are routine. Note that @{term \"wrap\"} is (necessarily)\nstrict due to the property @{thm \"retraction_strict\"}.\n\n\\<close>"], ["", "fixrec wrap :: \"B \\<rightarrow> A\"\nwhere \"wrap\\<cdot>(B\\<cdot>a) = a\""], ["", "(*<*)"], ["", "lemma wrap_strict[simp]: \"wrap\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wrap\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "(*>*)"], ["", "fixrec unwrap :: \"A \\<rightarrow> B\"\nwhere \"unwrap = B\""], ["", "text\\<open>\n\nDischarging the worker/wrapper hypothesis is similarly routine.\n\n\\<close>"], ["", "lemma wrap_unwrap: \"wrap oo unwrap = ID\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wrap oo unwrap = ID", "by (simp add: cfun_eq_iff)"], ["", "text\\<open>\n\nThe candidate computation we transform can be any that uses the\nrecursion parameter @{term \"r\"} non-strictly. The following is\nespecially trivial.\n\n\\<close>"], ["", "fixrec body :: \"A \\<rightarrow> A\"\nwhere \"body\\<cdot>r = A\""], ["", "text\\<open>\n\nThe wrinkle is that the transformed worker can be strict in the\nrecursion parameter @{term \"r\"}, as @{term \"unwrap\"} always lifts it.\n\n\\<close>"], ["", "fixrec body' :: \"B \\<rightarrow> B\"\nwhere \"body'\\<cdot>(B\\<cdot>a) = B\\<cdot>A\""], ["", "(*<*)"], ["", "lemma body'_strict[simp]: \"body'\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. body'\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "(*>*)"], ["", "text\\<open>\n\nAs explained above, we set up the fusion opportunity:\n\n\\<close>"], ["", "lemma body_body': \"unwrap oo body oo wrap = body' oo unwrap oo wrap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unwrap oo body oo wrap = body' oo unwrap oo wrap", "by (simp add: cfun_eq_iff)"], ["", "text\\<open>\n\nThis result depends crucially on @{term \"unwrap\"} being non-strict.\n\nOur earlier result shows that the proposed transformation is partially\ncorrect:\n\n\\<close>"], ["", "lemma \"fix\\<cdot>body' \\<sqsubseteq> fix\\<cdot>(unwrap oo body oo wrap)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fix\\<cdot>body' \\<sqsubseteq> fix\\<cdot>(unwrap oo body oo wrap)", "by (rule fusion_partially_correct[OF wrap_unwrap refl body_body'])"], ["", "text\\<open>\n\nHowever it is easy to see that it is not totally correct:\n\n\\<close>"], ["", "lemma \"\\<not> fix\\<cdot>(unwrap oo body oo wrap) \\<sqsubseteq> fix\\<cdot>body'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fix\\<cdot>(unwrap oo body oo wrap) \\<notsqsubseteq> fix\\<cdot>body'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fix\\<cdot>(unwrap oo body oo wrap) \\<notsqsubseteq> fix\\<cdot>body'", "have l: \"fix\\<cdot>(unwrap oo body oo wrap) = B\\<cdot>A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fix\\<cdot>(unwrap oo body oo wrap) = B\\<cdot>A", "by (subst fix_eq) simp"], ["proof (state)\nthis:\n  fix\\<cdot>(unwrap oo body oo wrap) = B\\<cdot>A\n\ngoal (1 subgoal):\n 1. fix\\<cdot>(unwrap oo body oo wrap) \\<notsqsubseteq> fix\\<cdot>body'", "have r: \"fix\\<cdot>body' = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fix\\<cdot>body' = \\<bottom>", "by (simp add: fix_strict)"], ["proof (state)\nthis:\n  fix\\<cdot>body' = \\<bottom>\n\ngoal (1 subgoal):\n 1. fix\\<cdot>(unwrap oo body oo wrap) \\<notsqsubseteq> fix\\<cdot>body'", "from l r"], ["proof (chain)\npicking this:\n  fix\\<cdot>(unwrap oo body oo wrap) = B\\<cdot>A\n  fix\\<cdot>body' = \\<bottom>", "show ?thesis"], ["proof (prove)\nusing this:\n  fix\\<cdot>(unwrap oo body oo wrap) = B\\<cdot>A\n  fix\\<cdot>body' = \\<bottom>\n\ngoal (1 subgoal):\n 1. fix\\<cdot>(unwrap oo body oo wrap) \\<notsqsubseteq> fix\\<cdot>body'", "by simp"], ["proof (state)\nthis:\n  fix\\<cdot>(unwrap oo body oo wrap) \\<notsqsubseteq> fix\\<cdot>body'\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n\nThis trick works whenever @{term \"unwrap\"} is not strict. In the\nfollowing section we show that requiring @{term \"unwrap\"} to be strict\nleads to a straightforward proof of total correctness.\n\nNote that if we have already established that @{term \"wrap oo unwrap =\nID\"}, then making @{term \"unwrap\"} strict preserves this equation:\n\n\\<close>"], ["", "lemma\n  assumes \"wrap oo unwrap = ID\"\n  shows \"wrap oo strictify\\<cdot>unwrap = ID\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wrap oo strictify\\<cdot>unwrap = ID", "proof(rule cfun_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (wrap oo strictify\\<cdot>unwrap)\\<cdot>x = ID\\<cdot>x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (wrap oo strictify\\<cdot>unwrap)\\<cdot>x = ID\\<cdot>x", "from assms"], ["proof (chain)\npicking this:\n  wrap oo unwrap = ID", "show \"(wrap oo strictify\\<cdot>unwrap)\\<cdot>x = ID\\<cdot>x\""], ["proof (prove)\nusing this:\n  wrap oo unwrap = ID\n\ngoal (1 subgoal):\n 1. (wrap oo strictify\\<cdot>unwrap)\\<cdot>x = ID\\<cdot>x", "by (cases \"x = \\<bottom>\") (simp_all add: cfun_eq_iff retraction_strict)"], ["proof (state)\nthis:\n  (wrap oo strictify\\<cdot>unwrap)\\<cdot>x = ID\\<cdot>x\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n\nFrom this we conclude that the worker/wrapper transformation itself\ncannot exploit any laziness in @{term \"unwrap\"} under the\ncontext-insensitive assumptions of @{thm [source]\n\"worker_wrapper_id\"}. This is not to say that other program\ntransformations may not be able to.\n\n\\<close>"], ["", "(*<*)"], ["", "lemma\n  \"\\<not> strictify\\<cdot>unwrap oo body oo wrap = body' oo strictify\\<cdot>unwrap oo wrap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strictify\\<cdot>unwrap oo body oo wrap \\<noteq>\n    body' oo strictify\\<cdot>unwrap oo wrap", "by (simp add: cfun_eq_iff exI[where x=\"\\<bottom>\"])"], ["", "(*>*)\n\n(*<*)"], ["", "end"], ["", "(*>*)"]]}