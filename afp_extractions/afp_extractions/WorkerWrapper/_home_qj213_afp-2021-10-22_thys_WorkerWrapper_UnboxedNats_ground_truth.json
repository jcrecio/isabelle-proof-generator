{"file_name": "/home/qj213/afp-2021-10-22/thys/WorkerWrapper/UnboxedNats.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/WorkerWrapper", "problem_names": ["lemma fac_strict[simp]: \"fac\\<cdot>\\<bottom> = \\<bottom>\"", "lemma fac_body_strict[simp]: \"fac_body\\<cdot>r\\<cdot>\\<bottom> = \\<bottom>\"", "lemma fac_fac_body_eq: \"fac = fix\\<cdot>fac_body\"", "lemma wrapB_unwrapB_body:\n  assumes strictF: \"f\\<cdot>\\<bottom> = \\<bottom>\"\n  shows \"(wrapB oo unwrapB)\\<cdot>f = f\" (is \"?lhs = ?rhs\")", "lemma fac_fac_ww_eq: \"fac = fac_wrap\" (is \"?lhs = ?rhs\")", "lemma fac_body'_fac_body: \"fac_body' = unwrapB oo fac_body oo wrapB\" (is \"?lhs = ?rhs\")", "lemma fac_body_final_fac_body': \"fac_body_final = fac_body'\" (is \"?lhs = ?rhs\")", "lemma fac_fac_final: \"fac = fac_final\" (is \"?lhs=?rhs\")", "lemma a2n_strict[simp]: \"a2n\\<cdot>\\<bottom> = \\<bottom>\"", "lemma a2n_n2a: \"a2n\\<cdot>(n2a\\<cdot>u) = up\\<cdot>u\"", "lemma A_hom_mult: \"n2a\\<cdot>(x *\\<^sub># y) = (n2a\\<cdot>x >=> n2a\\<cdot>y)\"", "lemma unwrapA_strict[simp]: \"unwrapA\\<cdot>\\<bottom> = \\<bottom>\"", "lemma wrapA_unwrapA_id: \"wrapA oo unwrapA = ID\"", "lemma fac_acc_body1_fac_body_final_eq: \"fac_acc_body1 = unwrapA oo fac_body_final oo wrapA\"", "lemma fac_acc_body2_body1_eq: \"fac_acc_body2 = fac_acc_body1\"", "lemma fac_acc_body3_body2: \"fac_acc_body3 oo (unwrapA oo wrapA) = fac_acc_body2\" (is \"?lhs=?rhs\")", "lemma fac_work_final_body3_eq: \"fac_work_final = wrapA\\<cdot>(fix\\<cdot>fac_acc_body3)\"", "lemma fac_acc_work_final_fac_acc_work3_eq: \"fac_acc_body_final = fac_acc_body3\" (is \"?lhs=?rhs\")", "lemma fac_acc_work_final_fac_work: \"fac_acc_work_final = fac_work_final\" (is \"?lhs=?rhs\")"], "translations": [["", "lemma fac_strict[simp]: \"fac\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fac\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "definition\n  fac_body :: \"(Nat \\<rightarrow> Nat) \\<rightarrow> Nat \\<rightarrow> Nat\" where\n  \"fac_body \\<equiv> \\<Lambda> r n. If n =\\<^sub>B 0 then 1 else n * r\\<cdot>(n - 1)\""], ["", "lemma fac_body_strict[simp]: \"fac_body\\<cdot>r\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fac_body\\<cdot>r\\<cdot>\\<bottom> = \\<bottom>", "unfolding fac_body_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> r n. If n =\\<^sub>B 0 then 1 else n * r\\<cdot>(n - 1))\\<cdot>\n    r\\<cdot>\n    \\<bottom> =\n    \\<bottom>", "by simp"], ["", "lemma fac_fac_body_eq: \"fac = fix\\<cdot>fac_body\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fac = fix\\<cdot>fac_body", "unfolding fac_body_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fac =\n    (\\<mu> r. \\<Lambda> n. If n =\\<^sub>B 0 then 1 else n * r\\<cdot>(n - 1))", "by (rule cfun_eqI, subst fac_def, simp)"], ["", "text\\<open>Wrap / unwrap functions. Note the explicit lifting of the\nco-domain. For some reason the published version of\n\\citet{GillHutton:2009} does not discuss this point: if we're going to\nhandle recursive functions, we need a bottom.\n\n@{term \"unbox\"} simply removes the tag, yielding a possibly-divergent\nunboxed value, the result of the function.\\<close>"], ["", "definition\n  unwrapB :: \"(Nat \\<rightarrow> Nat) \\<rightarrow> UNat \\<rightarrow> UNat\\<^sub>\\<bottom>\" where\n  \"unwrapB \\<equiv> \\<Lambda> f. unbox oo f oo box\""], ["", "text\\<open>Note that the monadic bind operator @{term \"(>>=)\"} here stands\nin for the \\textsf{case} construct in the paper.\\<close>"], ["", "definition\n  wrapB :: \"(UNat \\<rightarrow> UNat\\<^sub>\\<bottom>) \\<rightarrow> Nat \\<rightarrow> Nat\" where\n  \"wrapB \\<equiv> \\<Lambda> f x . unbox\\<cdot>x >>= f >>= box\""], ["", "lemma wrapB_unwrapB_body:\n  assumes strictF: \"f\\<cdot>\\<bottom> = \\<bottom>\"\n  shows \"(wrapB oo unwrapB)\\<cdot>f = f\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (wrapB oo unwrapB)\\<cdot>f = f", "proof(rule cfun_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (wrapB oo unwrapB)\\<cdot>f\\<cdot>x = f\\<cdot>x", "fix x :: Nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (wrapB oo unwrapB)\\<cdot>f\\<cdot>x = f\\<cdot>x", "have \"?lhs\\<cdot>x = unbox\\<cdot>x >>= (\\<Lambda> x'. unwrapB\\<cdot>f\\<cdot>x' >>= box)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (wrapB oo unwrapB)\\<cdot>f\\<cdot>x =\n    unbox\\<cdot>x >>= (\\<Lambda> x'. unwrapB\\<cdot>f\\<cdot>x' >>= box)", "unfolding wrapB_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Lambda> f x. unbox\\<cdot>x >>= f >>= box) oo unwrapB)\\<cdot>f\\<cdot>\n    x =\n    unbox\\<cdot>x >>= (\\<Lambda> x'. unwrapB\\<cdot>f\\<cdot>x' >>= box)", "by simp"], ["proof (state)\nthis:\n  (wrapB oo unwrapB)\\<cdot>f\\<cdot>x =\n  unbox\\<cdot>x >>= (\\<Lambda> x'. unwrapB\\<cdot>f\\<cdot>x' >>= box)\n\ngoal (1 subgoal):\n 1. \\<And>x. (wrapB oo unwrapB)\\<cdot>f\\<cdot>x = f\\<cdot>x", "also"], ["proof (state)\nthis:\n  (wrapB oo unwrapB)\\<cdot>f\\<cdot>x =\n  unbox\\<cdot>x >>= (\\<Lambda> x'. unwrapB\\<cdot>f\\<cdot>x' >>= box)\n\ngoal (1 subgoal):\n 1. \\<And>x. (wrapB oo unwrapB)\\<cdot>f\\<cdot>x = f\\<cdot>x", "have \"\\<dots> = unbox\\<cdot>x >>= (\\<Lambda> x'. unbox\\<cdot>(f\\<cdot>(box\\<cdot>x')) >>= box)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unbox\\<cdot>x >>= (\\<Lambda> x'. unwrapB\\<cdot>f\\<cdot>x' >>= box) =\n    unbox\\<cdot>x >>=\n    (\\<Lambda> x'. unbox\\<cdot>(f\\<cdot>(box\\<cdot>x')) >>= box)", "unfolding unwrapB_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. unbox\\<cdot>x >>=\n    (\\<Lambda> x'.\n        (\\<Lambda> f. unbox oo f oo box)\\<cdot>f\\<cdot>x' >>= box) =\n    unbox\\<cdot>x >>=\n    (\\<Lambda> x'. unbox\\<cdot>(f\\<cdot>(box\\<cdot>x')) >>= box)", "by simp"], ["proof (state)\nthis:\n  unbox\\<cdot>x >>= (\\<Lambda> x'. unwrapB\\<cdot>f\\<cdot>x' >>= box) =\n  unbox\\<cdot>x >>=\n  (\\<Lambda> x'. unbox\\<cdot>(f\\<cdot>(box\\<cdot>x')) >>= box)\n\ngoal (1 subgoal):\n 1. \\<And>x. (wrapB oo unwrapB)\\<cdot>f\\<cdot>x = f\\<cdot>x", "also"], ["proof (state)\nthis:\n  unbox\\<cdot>x >>= (\\<Lambda> x'. unwrapB\\<cdot>f\\<cdot>x' >>= box) =\n  unbox\\<cdot>x >>=\n  (\\<Lambda> x'. unbox\\<cdot>(f\\<cdot>(box\\<cdot>x')) >>= box)\n\ngoal (1 subgoal):\n 1. \\<And>x. (wrapB oo unwrapB)\\<cdot>f\\<cdot>x = f\\<cdot>x", "from strictF"], ["proof (chain)\npicking this:\n  f\\<cdot>\\<bottom> = \\<bottom>", "have \"\\<dots> = f\\<cdot>x\""], ["proof (prove)\nusing this:\n  f\\<cdot>\\<bottom> = \\<bottom>\n\ngoal (1 subgoal):\n 1. unbox\\<cdot>x >>=\n    (\\<Lambda> x'. unbox\\<cdot>(f\\<cdot>(box\\<cdot>x')) >>= box) =\n    f\\<cdot>x", "by (cases x, simp_all)"], ["proof (state)\nthis:\n  unbox\\<cdot>x >>=\n  (\\<Lambda> x'. unbox\\<cdot>(f\\<cdot>(box\\<cdot>x')) >>= box) =\n  f\\<cdot>x\n\ngoal (1 subgoal):\n 1. \\<And>x. (wrapB oo unwrapB)\\<cdot>f\\<cdot>x = f\\<cdot>x", "finally"], ["proof (chain)\npicking this:\n  (wrapB oo unwrapB)\\<cdot>f\\<cdot>x = f\\<cdot>x", "show \"?lhs\\<cdot>x = ?rhs\\<cdot>x\""], ["proof (prove)\nusing this:\n  (wrapB oo unwrapB)\\<cdot>f\\<cdot>x = f\\<cdot>x\n\ngoal (1 subgoal):\n 1. (wrapB oo unwrapB)\\<cdot>f\\<cdot>x = f\\<cdot>x", "."], ["proof (state)\nthis:\n  (wrapB oo unwrapB)\\<cdot>f\\<cdot>x = f\\<cdot>x\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Apply worker/wrapper.\\<close>"], ["", "definition\n  fac_work :: \"UNat \\<rightarrow> UNat\\<^sub>\\<bottom>\" where\n  \"fac_work \\<equiv> fix\\<cdot>(unwrapB oo fac_body oo wrapB)\""], ["", "definition\n  fac_wrap :: \"Nat \\<rightarrow> Nat\" where\n  \"fac_wrap \\<equiv> wrapB\\<cdot>fac_work\""], ["", "lemma fac_fac_ww_eq: \"fac = fac_wrap\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. fac = fac_wrap", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fac = fac_wrap", "have \"wrapB oo unwrapB oo fac_body = fac_body\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wrapB oo unwrapB oo fac_body = fac_body", "using wrapB_unwrapB_body[OF fac_body_strict]"], ["proof (prove)\nusing this:\n  (wrapB oo unwrapB)\\<cdot>(fac_body\\<cdot>?r1) = fac_body\\<cdot>?r1\n\ngoal (1 subgoal):\n 1. wrapB oo unwrapB oo fac_body = fac_body", "by - (rule cfun_eqI, simp)"], ["proof (state)\nthis:\n  wrapB oo unwrapB oo fac_body = fac_body\n\ngoal (1 subgoal):\n 1. fac = fac_wrap", "thus ?thesis"], ["proof (prove)\nusing this:\n  wrapB oo unwrapB oo fac_body = fac_body\n\ngoal (1 subgoal):\n 1. fac = fac_wrap", "using worker_wrapper_body[where computation=fac and body=fac_body and wrap=wrapB and unwrap=unwrapB]"], ["proof (prove)\nusing this:\n  wrapB oo unwrapB oo fac_body = fac_body\n  \\<lbrakk>wrapB oo unwrapB oo fac_body = fac_body;\n   fac = fix\\<cdot>fac_body\\<rbrakk>\n  \\<Longrightarrow> fac =\n                    wrapB\\<cdot>(fix\\<cdot>(unwrapB oo fac_body oo wrapB))\n\ngoal (1 subgoal):\n 1. fac = fac_wrap", "unfolding fac_work_def fac_wrap_def"], ["proof (prove)\nusing this:\n  wrapB oo unwrapB oo fac_body = fac_body\n  \\<lbrakk>wrapB oo unwrapB oo fac_body = fac_body;\n   fac = fix\\<cdot>fac_body\\<rbrakk>\n  \\<Longrightarrow> fac =\n                    wrapB\\<cdot>(fix\\<cdot>(unwrapB oo fac_body oo wrapB))\n\ngoal (1 subgoal):\n 1. fac = wrapB\\<cdot>(fix\\<cdot>(unwrapB oo fac_body oo wrapB))", "by (simp add: fac_fac_body_eq)"], ["proof (state)\nthis:\n  fac = fac_wrap\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>This is not entirely faithful to the paper, as they don't\nexplicitly handle the lifting of the codomain.\\<close>"], ["", "definition\n  fac_body' :: \"(UNat \\<rightarrow> UNat\\<^sub>\\<bottom>) \\<rightarrow> UNat \\<rightarrow> UNat\\<^sub>\\<bottom>\" where\n  \"fac_body' \\<equiv> \\<Lambda> r n.\n     unbox\\<cdot>(If box\\<cdot>n =\\<^sub>B 0\n              then 1\n              else unbox\\<cdot>(box\\<cdot>n - 1) >>= r >>= (\\<Lambda> b. box\\<cdot>n * box\\<cdot>b))\""], ["", "lemma fac_body'_fac_body: \"fac_body' = unwrapB oo fac_body oo wrapB\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. fac_body' = unwrapB oo fac_body oo wrapB", "proof(rule cfun_eqI)+"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       fac_body'\\<cdot>x\\<cdot>xa =\n       (unwrapB oo fac_body oo wrapB)\\<cdot>x\\<cdot>xa", "fix r x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       fac_body'\\<cdot>x\\<cdot>xa =\n       (unwrapB oo fac_body oo wrapB)\\<cdot>x\\<cdot>xa", "show \"?lhs\\<cdot>r\\<cdot>x = ?rhs\\<cdot>r\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fac_body'\\<cdot>r\\<cdot>x =\n    (unwrapB oo fac_body oo wrapB)\\<cdot>r\\<cdot>x", "using bbind_case_distr_strict[where f=\"\\<Lambda> y. box\\<cdot>x * y\" and g=\"unbox\\<cdot>(box\\<cdot>x - 1)\"]\n          bbind_case_distr_strict[where f=\"\\<Lambda> y. box\\<cdot>x * y\" and h=\"box\"]"], ["proof (prove)\nusing this:\n  (\\<Lambda> y. box\\<cdot>x * y)\\<cdot>\\<bottom> =\n  \\<bottom> \\<Longrightarrow>\n  (\\<Lambda> y. box\\<cdot>x * y)\\<cdot>\n  (unbox\\<cdot>(box\\<cdot>x - 1) >>= ?h) =\n  unbox\\<cdot>(box\\<cdot>x - 1) >>=\n  (\\<Lambda> xa. (\\<Lambda> y. box\\<cdot>x * y)\\<cdot>(?h\\<cdot>xa))\n  (\\<Lambda> y. box\\<cdot>x * y)\\<cdot>\\<bottom> =\n  \\<bottom> \\<Longrightarrow>\n  (\\<Lambda> y. box\\<cdot>x * y)\\<cdot>(?g >>= box) =\n  ?g >>= (\\<Lambda> xa. (\\<Lambda> y. box\\<cdot>x * y)\\<cdot>(box\\<cdot>xa))\n\ngoal (1 subgoal):\n 1. fac_body'\\<cdot>r\\<cdot>x =\n    (unwrapB oo fac_body oo wrapB)\\<cdot>r\\<cdot>x", "unfolding fac_body'_def fac_body_def unwrapB_def wrapB_def"], ["proof (prove)\nusing this:\n  (\\<Lambda> y. box\\<cdot>x * y)\\<cdot>\\<bottom> =\n  \\<bottom> \\<Longrightarrow>\n  (\\<Lambda> y. box\\<cdot>x * y)\\<cdot>\n  (unbox\\<cdot>(box\\<cdot>x - 1) >>= ?h) =\n  unbox\\<cdot>(box\\<cdot>x - 1) >>=\n  (\\<Lambda> xa. (\\<Lambda> y. box\\<cdot>x * y)\\<cdot>(?h\\<cdot>xa))\n  (\\<Lambda> y. box\\<cdot>x * y)\\<cdot>\\<bottom> =\n  \\<bottom> \\<Longrightarrow>\n  (\\<Lambda> y. box\\<cdot>x * y)\\<cdot>(?g >>= box) =\n  ?g >>= (\\<Lambda> xa. (\\<Lambda> y. box\\<cdot>x * y)\\<cdot>(box\\<cdot>xa))\n\ngoal (1 subgoal):\n 1. (\\<Lambda> r n.\n        unbox\\<cdot>\n        (If box\\<cdot>n =\\<^sub>B 0 then 1\n         else unbox\\<cdot>(box\\<cdot>n - 1) >>= r >>=\n              (\\<Lambda> b. box\\<cdot>n * box\\<cdot>b)))\\<cdot>\n    r\\<cdot>\n    x =\n    ((\\<Lambda> f. unbox oo f oo box) oo\n     (\\<Lambda> r n. If n =\\<^sub>B 0 then 1 else n * r\\<cdot>(n - 1)) oo\n     (\\<Lambda> f x. unbox\\<cdot>x >>= f >>= box))\\<cdot>\n    r\\<cdot>\n    x", "by simp"], ["proof (state)\nthis:\n  fac_body'\\<cdot>r\\<cdot>x = (unwrapB oo fac_body oo wrapB)\\<cdot>r\\<cdot>x\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>The @{term \"up\"} constructors here again mediate the\nisomorphism, operationally doing nothing. Note the switch to the\nmachine-oriented \\emph{if} construct: the test @{term \"n = 0\"} cannot\ndiverge.\\<close>"], ["", "definition\n  fac_body_final :: \"(UNat \\<rightarrow> UNat\\<^sub>\\<bottom>) \\<rightarrow> UNat \\<rightarrow> UNat\\<^sub>\\<bottom>\" where\n  \"fac_body_final \\<equiv> \\<Lambda> r n.\n     if n = 0 then up\\<cdot>1 else r\\<cdot>(n -\\<^sub># 1) >>= (\\<Lambda> b. up\\<cdot>(n *\\<^sub># b))\""], ["", "lemma fac_body_final_fac_body': \"fac_body_final = fac_body'\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. fac_body_final = fac_body'", "proof(rule cfun_eqI)+"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. fac_body_final\\<cdot>x\\<cdot>xa = fac_body'\\<cdot>x\\<cdot>xa", "fix r x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. fac_body_final\\<cdot>x\\<cdot>xa = fac_body'\\<cdot>x\\<cdot>xa", "show \"?lhs\\<cdot>r\\<cdot>x = ?rhs\\<cdot>r\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fac_body_final\\<cdot>r\\<cdot>x = fac_body'\\<cdot>r\\<cdot>x", "using bbind_case_distr_strict[where f=\"unbox\" and g=\"r\\<cdot>(x -\\<^sub># 1)\" and h=\"(\\<Lambda> b. box\\<cdot>(x *\\<^sub># b))\"]"], ["proof (prove)\nusing this:\n  unbox\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n  unbox\\<cdot>\n  (r\\<cdot>(x -\\<^sub># 1) >>= (\\<Lambda> b. box\\<cdot>(x *\\<^sub># b))) =\n  r\\<cdot>(x -\\<^sub># 1) >>=\n  (\\<Lambda> xa.\n      unbox\\<cdot>((\\<Lambda> b. box\\<cdot>(x *\\<^sub># b))\\<cdot>xa))\n\ngoal (1 subgoal):\n 1. fac_body_final\\<cdot>r\\<cdot>x = fac_body'\\<cdot>r\\<cdot>x", "unfolding fac_body_final_def fac_body'_def uMinus_def uMult_def zero_Nat_def one_Nat_def"], ["proof (prove)\nusing this:\n  unbox\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n  unbox\\<cdot>\n  (r\\<cdot>\n   ((\\<Lambda> x y. Discr (undiscr x - undiscr y))\\<cdot>x\\<cdot>1) >>=\n   (\\<Lambda> b.\n       box\\<cdot>\n       ((\\<Lambda> x y. Discr (undiscr x * undiscr y))\\<cdot>x\\<cdot>b))) =\n  r\\<cdot>\n  ((\\<Lambda> x y. Discr (undiscr x - undiscr y))\\<cdot>x\\<cdot>1) >>=\n  (\\<Lambda> xa.\n      unbox\\<cdot>\n      ((\\<Lambda> b.\n           box\\<cdot>\n           ((\\<Lambda> x y. Discr (undiscr x * undiscr y))\\<cdot>x\\<cdot>\n            b))\\<cdot>\n       xa))\n\ngoal (1 subgoal):\n 1. (\\<Lambda> r n.\n        if n = 0 then up\\<cdot>1\n        else r\\<cdot>\n             ((\\<Lambda> x y. Discr (undiscr x - undiscr y))\\<cdot>n\\<cdot>\n              1) >>=\n             (\\<Lambda> b.\n                 up\\<cdot>\n                 ((\\<Lambda> x y. Discr (undiscr x * undiscr y))\\<cdot>\n                  n\\<cdot>\n                  b)))\\<cdot>\n    r\\<cdot>\n    x =\n    (\\<Lambda> r n.\n        unbox\\<cdot>\n        (If box\\<cdot>n =\\<^sub>B box\\<cdot>0 then box\\<cdot>1\n         else unbox\\<cdot>(box\\<cdot>n - box\\<cdot>1) >>= r >>=\n              (\\<Lambda> b. box\\<cdot>n * box\\<cdot>b)))\\<cdot>\n    r\\<cdot>\n    x", "by simp"], ["proof (state)\nthis:\n  fac_body_final\\<cdot>r\\<cdot>x = fac_body'\\<cdot>r\\<cdot>x\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  fac_work_final :: \"UNat \\<rightarrow> UNat\\<^sub>\\<bottom>\" where\n  \"fac_work_final \\<equiv> fix\\<cdot>fac_body_final\""], ["", "definition\n  fac_final :: \"Nat \\<rightarrow> Nat\" where\n  \"fac_final \\<equiv> \\<Lambda> n. unbox\\<cdot>n >>= fac_work_final >>= box\""], ["", "lemma fac_fac_final: \"fac = fac_final\" (is \"?lhs=?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. fac = fac_final", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fac = fac_final", "have \"?lhs = fac_wrap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fac = fac_wrap", "by (rule fac_fac_ww_eq)"], ["proof (state)\nthis:\n  fac = fac_wrap\n\ngoal (1 subgoal):\n 1. fac = fac_final", "also"], ["proof (state)\nthis:\n  fac = fac_wrap\n\ngoal (1 subgoal):\n 1. fac = fac_final", "have \"\\<dots> = wrapB\\<cdot>fac_work\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fac_wrap = wrapB\\<cdot>fac_work", "by (simp only: fac_wrap_def)"], ["proof (state)\nthis:\n  fac_wrap = wrapB\\<cdot>fac_work\n\ngoal (1 subgoal):\n 1. fac = fac_final", "also"], ["proof (state)\nthis:\n  fac_wrap = wrapB\\<cdot>fac_work\n\ngoal (1 subgoal):\n 1. fac = fac_final", "have \"\\<dots> = wrapB\\<cdot>(fix\\<cdot>(unwrapB oo fac_body oo wrapB))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wrapB\\<cdot>fac_work =\n    wrapB\\<cdot>(fix\\<cdot>(unwrapB oo fac_body oo wrapB))", "by (simp only: fac_work_def)"], ["proof (state)\nthis:\n  wrapB\\<cdot>fac_work =\n  wrapB\\<cdot>(fix\\<cdot>(unwrapB oo fac_body oo wrapB))\n\ngoal (1 subgoal):\n 1. fac = fac_final", "also"], ["proof (state)\nthis:\n  wrapB\\<cdot>fac_work =\n  wrapB\\<cdot>(fix\\<cdot>(unwrapB oo fac_body oo wrapB))\n\ngoal (1 subgoal):\n 1. fac = fac_final", "have \"\\<dots> = wrapB\\<cdot>(fix\\<cdot>fac_body')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wrapB\\<cdot>(fix\\<cdot>(unwrapB oo fac_body oo wrapB)) =\n    wrapB\\<cdot>(fix\\<cdot>fac_body')", "by (simp only: fac_body'_fac_body)"], ["proof (state)\nthis:\n  wrapB\\<cdot>(fix\\<cdot>(unwrapB oo fac_body oo wrapB)) =\n  wrapB\\<cdot>(fix\\<cdot>fac_body')\n\ngoal (1 subgoal):\n 1. fac = fac_final", "also"], ["proof (state)\nthis:\n  wrapB\\<cdot>(fix\\<cdot>(unwrapB oo fac_body oo wrapB)) =\n  wrapB\\<cdot>(fix\\<cdot>fac_body')\n\ngoal (1 subgoal):\n 1. fac = fac_final", "have \"\\<dots> = wrapB\\<cdot>fac_work_final\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wrapB\\<cdot>(fix\\<cdot>fac_body') = wrapB\\<cdot>fac_work_final", "by (simp only: fac_body_final_fac_body' fac_work_final_def)"], ["proof (state)\nthis:\n  wrapB\\<cdot>(fix\\<cdot>fac_body') = wrapB\\<cdot>fac_work_final\n\ngoal (1 subgoal):\n 1. fac = fac_final", "also"], ["proof (state)\nthis:\n  wrapB\\<cdot>(fix\\<cdot>fac_body') = wrapB\\<cdot>fac_work_final\n\ngoal (1 subgoal):\n 1. fac = fac_final", "have \"\\<dots> = fac_final\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wrapB\\<cdot>fac_work_final = fac_final", "by (simp add: fac_final_def wrapB_def)"], ["proof (state)\nthis:\n  wrapB\\<cdot>fac_work_final = fac_final\n\ngoal (1 subgoal):\n 1. fac = fac_final", "finally"], ["proof (chain)\npicking this:\n  fac = fac_final", "show ?thesis"], ["proof (prove)\nusing this:\n  fac = fac_final\n\ngoal (1 subgoal):\n 1. fac = fac_final", "."], ["proof (state)\nthis:\n  fac = fac_final\n\ngoal:\nNo subgoals!", "qed"], ["", "(* **************************************** *)"], ["", "subsection\\<open>Introducing an accumulator.\\<close>"], ["", "text\\<open>\n\nThe final version of factorial uses unboxed naturals but is not\ntail-recursive. We can apply worker/wrapper once more to introduce an\naccumulator, similar to \\S\\ref{sec:accum}.\n\nThe monadic machinery complicates things slightly here. We use\n\\emph{Kleisli composition}, denoted @{term \"(>=>)\"}, in the\nhomomorphism.\n\nFirstly we introduce an ``accumulator'' monoid and show the\nhomomorphism.\n\n\\<close>"], ["", "type_synonym UNatAcc = \"UNat \\<rightarrow> UNat\\<^sub>\\<bottom>\""], ["", "definition\n  n2a :: \"UNat \\<rightarrow> UNatAcc\" where\n  \"n2a \\<equiv> \\<Lambda> m n. up\\<cdot>(m *\\<^sub># n)\""], ["", "definition\n  a2n :: \"UNatAcc \\<rightarrow> UNat\\<^sub>\\<bottom>\" where\n  \"a2n \\<equiv> \\<Lambda> a. a\\<cdot>1\""], ["", "lemma a2n_strict[simp]: \"a2n\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a2n\\<cdot>\\<bottom> = \\<bottom>", "unfolding a2n_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> a. a\\<cdot>1)\\<cdot>\\<bottom> = \\<bottom>", "by simp"], ["", "lemma a2n_n2a: \"a2n\\<cdot>(n2a\\<cdot>u) = up\\<cdot>u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a2n\\<cdot>(n2a\\<cdot>u) = up\\<cdot>u", "unfolding a2n_def n2a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> a. a\\<cdot>1)\\<cdot>\n    ((\\<Lambda> m n. up\\<cdot>(m *\\<^sub># n))\\<cdot>u) =\n    up\\<cdot>u", "by (simp add: uMult_arithmetic)"], ["", "lemma A_hom_mult: \"n2a\\<cdot>(x *\\<^sub># y) = (n2a\\<cdot>x >=> n2a\\<cdot>y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n2a\\<cdot>(x *\\<^sub># y) = n2a\\<cdot>x >=> n2a\\<cdot>y", "unfolding n2a_def bKleisli_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> m n. up\\<cdot>(m *\\<^sub># n))\\<cdot>(x *\\<^sub># y) =\n    (\\<Lambda> f g x. f\\<cdot>x >>= g)\\<cdot>\n    ((\\<Lambda> m n. up\\<cdot>(m *\\<^sub># n))\\<cdot>x)\\<cdot>\n    ((\\<Lambda> m n. up\\<cdot>(m *\\<^sub># n))\\<cdot>y)", "by (simp add: uMult_arithmetic)"], ["", "definition\n  unwrapA :: \"(UNat \\<rightarrow> UNat\\<^sub>\\<bottom>) \\<rightarrow> UNat \\<rightarrow> UNatAcc\" where\n  \"unwrapA \\<equiv> \\<Lambda> f n. f\\<cdot>n >>= n2a\""], ["", "lemma unwrapA_strict[simp]: \"unwrapA\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unwrapA\\<cdot>\\<bottom> = \\<bottom>", "unfolding unwrapA_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> f n. f\\<cdot>n >>= n2a)\\<cdot>\\<bottom> = \\<bottom>", "by (rule cfun_eqI) simp"], ["", "definition\n  wrapA :: \"(UNat \\<rightarrow> UNatAcc) \\<rightarrow> UNat \\<rightarrow> UNat\\<^sub>\\<bottom>\" where\n  \"wrapA \\<equiv> \\<Lambda> f. a2n oo f\""], ["", "lemma wrapA_unwrapA_id: \"wrapA oo unwrapA = ID\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wrapA oo unwrapA = ID", "unfolding wrapA_def unwrapA_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_cfun ((oo) a2n) oo (\\<Lambda> f n. f\\<cdot>n >>= n2a) = ID", "apply (rule cfun_eqI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       (Abs_cfun ((oo) a2n) oo (\\<Lambda> f n. f\\<cdot>n >>= n2a))\\<cdot>\n       x\\<cdot>\n       xa =\n       ID\\<cdot>x\\<cdot>xa", "apply (case_tac \"x\\<cdot>xa\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       x\\<cdot>xa = \\<bottom> \\<Longrightarrow>\n       (Abs_cfun ((oo) a2n) oo (\\<Lambda> f n. f\\<cdot>n >>= n2a))\\<cdot>\n       x\\<cdot>\n       xa =\n       ID\\<cdot>x\\<cdot>xa\n 2. \\<And>x xa xb.\n       x\\<cdot>xa = up\\<cdot>xb \\<Longrightarrow>\n       (Abs_cfun ((oo) a2n) oo (\\<Lambda> f n. f\\<cdot>n >>= n2a))\\<cdot>\n       x\\<cdot>\n       xa =\n       ID\\<cdot>x\\<cdot>xa", "apply (simp_all add: a2n_n2a)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>Some steps along the way.\\<close>"], ["", "definition\n  fac_acc_body1 :: \"(UNat \\<rightarrow> UNatAcc) \\<rightarrow> UNat \\<rightarrow> UNatAcc\" where\n  \"fac_acc_body1 \\<equiv> \\<Lambda> r n.\n     if n = 0 then n2a\\<cdot>1 else wrapA\\<cdot>r\\<cdot>(n -\\<^sub># 1) >>= (\\<Lambda> res. n2a\\<cdot>(n *\\<^sub># res))\""], ["", "lemma fac_acc_body1_fac_body_final_eq: \"fac_acc_body1 = unwrapA oo fac_body_final oo wrapA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fac_acc_body1 = unwrapA oo fac_body_final oo wrapA", "unfolding fac_acc_body1_def fac_body_final_def wrapA_def unwrapA_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> r n.\n        if n = 0 then n2a\\<cdot>1\n        else Abs_cfun ((oo) a2n)\\<cdot>r\\<cdot>(n -\\<^sub># 1) >>=\n             (\\<Lambda> res. n2a\\<cdot>(n *\\<^sub># res))) =\n    (\\<Lambda> f n. f\\<cdot>n >>= n2a) oo\n    (\\<Lambda> r n.\n        if n = 0 then up\\<cdot>1\n        else r\\<cdot>(n -\\<^sub># 1) >>=\n             (\\<Lambda> b. up\\<cdot>(n *\\<^sub># b))) oo\n    Abs_cfun ((oo) a2n)", "by (rule cfun_eqI)+ simp"], ["", "text\\<open>Use the homomorphism.\\<close>"], ["", "definition\n  fac_acc_body2 :: \"(UNat \\<rightarrow> UNatAcc) \\<rightarrow> UNat \\<rightarrow> UNatAcc\" where\n  \"fac_acc_body2 \\<equiv> \\<Lambda> r n.\n     if n = 0 then n2a\\<cdot>1 else wrapA\\<cdot>r\\<cdot>(n -\\<^sub># 1) >>= (\\<Lambda> res. n2a\\<cdot>n >=> n2a\\<cdot>res)\""], ["", "lemma fac_acc_body2_body1_eq: \"fac_acc_body2 = fac_acc_body1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fac_acc_body2 = fac_acc_body1", "unfolding fac_acc_body1_def fac_acc_body2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> r n.\n        if n = 0 then n2a\\<cdot>1\n        else wrapA\\<cdot>r\\<cdot>(n -\\<^sub># 1) >>=\n             (\\<Lambda> res. n2a\\<cdot>n >=> n2a\\<cdot>res)) =\n    (\\<Lambda> r n.\n        if n = 0 then n2a\\<cdot>1\n        else wrapA\\<cdot>r\\<cdot>(n -\\<^sub># 1) >>=\n             (\\<Lambda> res. n2a\\<cdot>(n *\\<^sub># res)))", "by (rule cfun_eqI)+ (simp add: A_hom_mult)"], ["", "text\\<open>Apply worker/wrapper.\\<close>"], ["", "definition\n  fac_acc_body3 :: \"(UNat \\<rightarrow> UNatAcc) \\<rightarrow> UNat \\<rightarrow> UNatAcc\" where\n  \"fac_acc_body3 \\<equiv> \\<Lambda> r n.\n     if n = 0 then n2a\\<cdot>1 else n2a\\<cdot>n >=> r\\<cdot>(n -\\<^sub># 1)\""], ["", "lemma fac_acc_body3_body2: \"fac_acc_body3 oo (unwrapA oo wrapA) = fac_acc_body2\" (is \"?lhs=?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. fac_acc_body3 oo unwrapA oo wrapA = fac_acc_body2", "proof(rule cfun_eqI)+"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       (fac_acc_body3 oo unwrapA oo wrapA)\\<cdot>x\\<cdot>xa\\<cdot>xb =\n       fac_acc_body2\\<cdot>x\\<cdot>xa\\<cdot>xb", "fix r n acc"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       (fac_acc_body3 oo unwrapA oo wrapA)\\<cdot>x\\<cdot>xa\\<cdot>xb =\n       fac_acc_body2\\<cdot>x\\<cdot>xa\\<cdot>xb", "show \"((fac_acc_body3 oo (unwrapA oo wrapA))\\<cdot>r\\<cdot>n\\<cdot>acc) = fac_acc_body2\\<cdot>r\\<cdot>n\\<cdot>acc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fac_acc_body3 oo unwrapA oo wrapA)\\<cdot>r\\<cdot>n\\<cdot>acc =\n    fac_acc_body2\\<cdot>r\\<cdot>n\\<cdot>acc", "unfolding fac_acc_body2_def fac_acc_body3_def unwrapA_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Lambda> r n.\n         if n = 0 then n2a\\<cdot>1\n         else n2a\\<cdot>n >=> r\\<cdot>(n -\\<^sub># 1)) oo\n     (\\<Lambda> f n. f\\<cdot>n >>= n2a) oo wrapA)\\<cdot>\n    r\\<cdot>\n    n\\<cdot>\n    acc =\n    (\\<Lambda> r n.\n        if n = 0 then n2a\\<cdot>1\n        else wrapA\\<cdot>r\\<cdot>(n -\\<^sub># 1) >>=\n             (\\<Lambda> res. n2a\\<cdot>n >=> n2a\\<cdot>res))\\<cdot>\n    r\\<cdot>\n    n\\<cdot>\n    acc", "using bbind_case_distr_strict[where f=\"\\<Lambda> y. n2a\\<cdot>n >=> y\" and h=\"n2a\", symmetric]"], ["proof (prove)\nusing this:\n  Abs_cfun ((>=>) (n2a\\<cdot>n))\\<cdot>\\<bottom> =\n  \\<bottom> \\<Longrightarrow>\n  ?g >>= (\\<Lambda> x. Abs_cfun ((>=>) (n2a\\<cdot>n))\\<cdot>(n2a\\<cdot>x)) =\n  Abs_cfun ((>=>) (n2a\\<cdot>n))\\<cdot>(?g >>= n2a)\n\ngoal (1 subgoal):\n 1. ((\\<Lambda> r n.\n         if n = 0 then n2a\\<cdot>1\n         else n2a\\<cdot>n >=> r\\<cdot>(n -\\<^sub># 1)) oo\n     (\\<Lambda> f n. f\\<cdot>n >>= n2a) oo wrapA)\\<cdot>\n    r\\<cdot>\n    n\\<cdot>\n    acc =\n    (\\<Lambda> r n.\n        if n = 0 then n2a\\<cdot>1\n        else wrapA\\<cdot>r\\<cdot>(n -\\<^sub># 1) >>=\n             (\\<Lambda> res. n2a\\<cdot>n >=> n2a\\<cdot>res))\\<cdot>\n    r\\<cdot>\n    n\\<cdot>\n    acc", "by simp"], ["proof (state)\nthis:\n  (fac_acc_body3 oo unwrapA oo wrapA)\\<cdot>r\\<cdot>n\\<cdot>acc =\n  fac_acc_body2\\<cdot>r\\<cdot>n\\<cdot>acc\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fac_work_final_body3_eq: \"fac_work_final = wrapA\\<cdot>(fix\\<cdot>fac_acc_body3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fac_work_final = wrapA\\<cdot>(fix\\<cdot>fac_acc_body3)", "unfolding fac_work_final_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fix\\<cdot>fac_body_final = wrapA\\<cdot>(fix\\<cdot>fac_acc_body3)", "by (rule worker_wrapper_fusion_new[OF wrapA_unwrapA_id unwrapA_strict])\n     (simp add: fac_acc_body3_body2 fac_acc_body2_body1_eq fac_acc_body1_fac_body_final_eq)"], ["", "definition\n  fac_acc_body_final :: \"(UNat \\<rightarrow> UNatAcc) \\<rightarrow> UNat \\<rightarrow> UNatAcc\" where\n  \"fac_acc_body_final \\<equiv> \\<Lambda> r n acc.\n     if n = 0 then up\\<cdot>acc else r\\<cdot>(n -\\<^sub># 1)\\<cdot>(n *\\<^sub># acc)\""], ["", "definition\n  fac_acc_work_final :: \"UNat \\<rightarrow> UNat\\<^sub>\\<bottom>\" where\n  \"fac_acc_work_final \\<equiv> \\<Lambda> x. fix\\<cdot>fac_acc_body_final\\<cdot>x\\<cdot>1\""], ["", "lemma fac_acc_work_final_fac_acc_work3_eq: \"fac_acc_body_final = fac_acc_body3\" (is \"?lhs=?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. fac_acc_body_final = fac_acc_body3", "unfolding fac_acc_body3_def fac_acc_body_final_def n2a_def bKleisli_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> r n acc.\n        if n = 0 then up\\<cdot>acc\n        else r\\<cdot>(n -\\<^sub># 1)\\<cdot>(n *\\<^sub># acc)) =\n    (\\<Lambda> r n.\n        if n = 0 then (\\<Lambda> m n. up\\<cdot>(m *\\<^sub># n))\\<cdot>1\n        else (\\<Lambda> f g x. f\\<cdot>x >>= g)\\<cdot>\n             ((\\<Lambda> m n. up\\<cdot>(m *\\<^sub># n))\\<cdot>n)\\<cdot>\n             (r\\<cdot>(n -\\<^sub># 1)))", "by (rule cfun_eqI)+\n     (simp add: uMult_arithmetic)"], ["", "lemma fac_acc_work_final_fac_work: \"fac_acc_work_final = fac_work_final\" (is \"?lhs=?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. fac_acc_work_final = fac_work_final", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fac_acc_work_final = fac_work_final", "have \"?rhs = wrapA\\<cdot>(fix\\<cdot>fac_acc_body3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fac_work_final = wrapA\\<cdot>(fix\\<cdot>fac_acc_body3)", "by (rule fac_work_final_body3_eq)"], ["proof (state)\nthis:\n  fac_work_final = wrapA\\<cdot>(fix\\<cdot>fac_acc_body3)\n\ngoal (1 subgoal):\n 1. fac_acc_work_final = fac_work_final", "also"], ["proof (state)\nthis:\n  fac_work_final = wrapA\\<cdot>(fix\\<cdot>fac_acc_body3)\n\ngoal (1 subgoal):\n 1. fac_acc_work_final = fac_work_final", "have \"\\<dots> = wrapA\\<cdot>(fix\\<cdot>fac_acc_body_final)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wrapA\\<cdot>(fix\\<cdot>fac_acc_body3) =\n    wrapA\\<cdot>(fix\\<cdot>fac_acc_body_final)", "using fac_acc_work_final_fac_acc_work3_eq"], ["proof (prove)\nusing this:\n  fac_acc_body_final = fac_acc_body3\n\ngoal (1 subgoal):\n 1. wrapA\\<cdot>(fix\\<cdot>fac_acc_body3) =\n    wrapA\\<cdot>(fix\\<cdot>fac_acc_body_final)", "by simp"], ["proof (state)\nthis:\n  wrapA\\<cdot>(fix\\<cdot>fac_acc_body3) =\n  wrapA\\<cdot>(fix\\<cdot>fac_acc_body_final)\n\ngoal (1 subgoal):\n 1. fac_acc_work_final = fac_work_final", "also"], ["proof (state)\nthis:\n  wrapA\\<cdot>(fix\\<cdot>fac_acc_body3) =\n  wrapA\\<cdot>(fix\\<cdot>fac_acc_body_final)\n\ngoal (1 subgoal):\n 1. fac_acc_work_final = fac_work_final", "have \"\\<dots> = ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wrapA\\<cdot>(fix\\<cdot>fac_acc_body_final) = fac_acc_work_final", "unfolding fac_acc_work_final_def wrapA_def a2n_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_cfun ((oo) (\\<Lambda> a. a\\<cdot>1))\\<cdot>\n    (fix\\<cdot>fac_acc_body_final) =\n    (\\<Lambda> x. fix\\<cdot>fac_acc_body_final\\<cdot>x\\<cdot>1)", "by (simp add: cfcomp1)"], ["proof (state)\nthis:\n  wrapA\\<cdot>(fix\\<cdot>fac_acc_body_final) = fac_acc_work_final\n\ngoal (1 subgoal):\n 1. fac_acc_work_final = fac_work_final", "finally"], ["proof (chain)\npicking this:\n  fac_work_final = fac_acc_work_final", "show ?thesis"], ["proof (prove)\nusing this:\n  fac_work_final = fac_acc_work_final\n\ngoal (1 subgoal):\n 1. fac_acc_work_final = fac_work_final", "by simp"], ["proof (state)\nthis:\n  fac_acc_work_final = fac_work_final\n\ngoal:\nNo subgoals!", "qed"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}