{"file_name": "/home/qj213/afp-2021-10-22/thys/Case_Labeling/Case_Labeling.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Case_Labeling", "problem_names": ["lemmas LABEL_simps = BIND_def CTXT_def HIER_def SPLIT_def VC_def", "lemma Initial_Label: \"CTXT 0 [] outp P \\<Longrightarrow> P\"", "lemma\n    BIND_I: \"P \\<Longrightarrow> BIND name inp P\" and\n    BIND_D: \"BIND name inp P \\<Longrightarrow> P\" and\n    VC_I: \"P \\<Longrightarrow> VC ct P\"", "lemma DISAMBIG_I: \"(DISAMBIG n \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma DISAMBIG_E: \"(DISAMBIG n \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma SPLIT_reflection: \"SPLIT x y \\<Longrightarrow> (x \\<equiv> y)\"", "lemma rev_SPLIT_reflection: \"(x \\<equiv> y) \\<Longrightarrow> SPLIT x y\"", "lemma SPLIT_sym: \"SPLIT x y \\<Longrightarrow> SPLIT y x\"", "lemma SPLIT_thin_refl: \"\\<lbrakk>SPLIT x x; PROP W\\<rbrakk> \\<Longrightarrow> PROP W\"", "lemma SPLIT_subst: \"\\<lbrakk>SPLIT x y; P x\\<rbrakk> \\<Longrightarrow> P y\"", "lemma SPLIT_prodE:\n    assumes \"SPLIT (x1, y1) (x2, y2)\"\n    obtains \"SPLIT x1 x2\" \"SPLIT y1 y2\"", "lemma Suc_numerals_conv:\n  \"Suc 0 = Numeral1\"\n  \"Suc (numeral n) = numeral (n + num.One)\"", "lemmas Suc_numeral_simps = Suc_numerals_conv add_num_simps"], "translations": [["", "lemmas LABEL_simps = BIND_def CTXT_def HIER_def SPLIT_def VC_def"], ["", "lemma Initial_Label: \"CTXT 0 [] outp P \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CTXT 0 [] outp P \\<Longrightarrow> P", "by (simp add: Case_Labeling.CTXT_def)"], ["", "lemma\n    BIND_I: \"P \\<Longrightarrow> BIND name inp P\" and\n    BIND_D: \"BIND name inp P \\<Longrightarrow> P\" and\n    VC_I: \"P \\<Longrightarrow> VC ct P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<Longrightarrow> BIND name inp P) &&&\n    (BIND name inp P \\<Longrightarrow> P) &&& (P \\<Longrightarrow> VC ct P)", "unfolding Case_Labeling.BIND_def Case_Labeling.VC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<Longrightarrow> P) &&&\n    (P \\<Longrightarrow> P) &&& (P \\<Longrightarrow> P)", "."], ["", "lemma DISAMBIG_I: \"(DISAMBIG n \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (DISAMBIG n \\<Longrightarrow> P) \\<Longrightarrow> P", "by (auto simp: DISAMBIG_def Case_Labeling.VC_def)"], ["", "lemma DISAMBIG_E: \"(DISAMBIG n \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (DISAMBIG n \\<Longrightarrow> P) \\<Longrightarrow> P", "by (auto simp: DISAMBIG_def)"], ["", "text \\<open>Lemmas for the tuple postprocessing\\<close>"], ["", "lemma SPLIT_reflection: \"SPLIT x y \\<Longrightarrow> (x \\<equiv> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SPLIT x y \\<Longrightarrow> x \\<equiv> y", "unfolding SPLIT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y \\<Longrightarrow> x \\<equiv> y", "by (rule eq_reflection)"], ["", "lemma rev_SPLIT_reflection: \"(x \\<equiv> y) \\<Longrightarrow> SPLIT x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<equiv> y \\<Longrightarrow> SPLIT x y", "unfolding SPLIT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<equiv> y \\<Longrightarrow> y = y", ".."], ["", "lemma SPLIT_sym: \"SPLIT x y \\<Longrightarrow> SPLIT y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SPLIT x y \\<Longrightarrow> SPLIT y x", "unfolding SPLIT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y \\<Longrightarrow> y = x", "by (rule sym)"], ["", "lemma SPLIT_thin_refl: \"\\<lbrakk>SPLIT x x; PROP W\\<rbrakk> \\<Longrightarrow> PROP W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>SPLIT x x; PROP W\\<rbrakk> \\<Longrightarrow> PROP W", "."], ["", "lemma SPLIT_subst: \"\\<lbrakk>SPLIT x y; P x\\<rbrakk> \\<Longrightarrow> P y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>SPLIT x y; P x\\<rbrakk> \\<Longrightarrow> P y", "unfolding SPLIT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = y; P x\\<rbrakk> \\<Longrightarrow> P y", "by hypsubst"], ["", "lemma SPLIT_prodE:\n    assumes \"SPLIT (x1, y1) (x2, y2)\"\n    obtains \"SPLIT x1 x2\" \"SPLIT y1 y2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>SPLIT x1 x2; SPLIT y1 y2\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  SPLIT (x1, y1) (x2, y2)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>SPLIT x1 x2; SPLIT y1 y2\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding SPLIT_def"], ["proof (prove)\nusing this:\n  (x1, y1) = (x2, y2)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>x1 = x2; y1 = y2\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["", "end"], ["", "text \\<open>\n  The labeling constants were qualified to not interfere with any other theory.\n  The following locale allows using a nice syntax in other theories\n\\<close>"], ["", "locale Labeling_Syntax begin"], ["", "abbreviation VAR where \"VAR \\<equiv> Case_Labeling.VAR\""], ["", "abbreviation VC (\"V\\<langle>(2_,_:/ _)\\<rangle>\") where \"VC bl ct  \\<equiv> Case_Labeling.VC (bl # ct)\""], ["", "abbreviation CTXT (\"C\\<langle>(2_,_,_:/ _\\<rangle>)\") where \"CTXT \\<equiv> Case_Labeling.CTXT\""], ["", "abbreviation BIND (\"B\\<langle>(2_,_:/ _\\<rangle>)\") where \"BIND \\<equiv> Case_Labeling.BIND\""], ["", "abbreviation HIER (\"H\\<langle>(2_:/ _\\<rangle>)\") where \"HIER \\<equiv> Case_Labeling.HIER\""], ["", "abbreviation SPLIT where \"SPLIT \\<equiv> Case_Labeling.SPLIT\""], ["", "end"], ["", "text \\<open>Lemmas for converting terms from @{term Suc}/@{term \"0::nat\"} notation to numerals\\<close>"], ["", "lemma Suc_numerals_conv:\n  \"Suc 0 = Numeral1\"\n  \"Suc (numeral n) = numeral (n + num.One)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 = Numeral1 &&& Suc (numeral n) = numeral (n + num.One)", "by auto"], ["", "lemmas Suc_numeral_simps = Suc_numerals_conv add_num_simps"], ["", "section \\<open>Casify\\<close>"], ["", "text \\<open>\n  Introduces a command @{command print_nested_cases}. This is similar to @{command print_cases},\n  but shows also the nested cases.\n\\<close>"], ["", "ML_file \\<open>print_nested_cases.ML\\<close>"], ["", "ML_file \\<open>util.ML\\<close>"], ["", "text \\<open>Introduces the proof method.\\<close>"], ["", "ML_file \\<open>casify.ML\\<close>"], ["", "ML \\<open>\n  val casify_defs = Casify.Options { simp_all_cases=true, split_right_only=true, protect_subgoals=false }\n\\<close>"], ["", "method_setup prepare_labels = \\<open>\n  Scan.succeed (fn ctxt => SIMPLE_METHOD (ALLGOALS (Casify.prepare_labels_tac ctxt)))\n\\<close> \"VCG labelling: prepare labels\""], ["", "method_setup casify = \\<open>Casify.casify_method_setup casify_defs\\<close>\n  \"VCG labelling: Turn the labels into cases\""], ["", "end"]]}