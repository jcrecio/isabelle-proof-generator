{"file_name": "/home/qj213/afp-2021-10-22/thys/Sliding_Window_Algorithm/SWA.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Sliding_Window_Algorithm", "problem_names": ["lemma neq_Leaf_if_l_gt0: \"0 < l t \\<Longrightarrow> t \\<noteq> Leaf\"", "lemma combine_non_Leaves: \"\\<lbrakk>t \\<noteq> Leaf; u \\<noteq> Leaf\\<rbrakk> \\<Longrightarrow> combine t u = Node (l t) (r u) (val t + val u) (discharge t) u\"", "lemma r_combine_non_Leaves: \"\\<lbrakk>t \\<noteq> Leaf; u \\<noteq> Leaf\\<rbrakk> \\<Longrightarrow> r (combine t u) = r u\"", "lemma reusables_Leaf[simp]: \"0 < fst w \\<Longrightarrow> reusables Leaf w = []\"", "lemma l_lchild_eq_l_if_well_shaped[simp]:\n  \"\\<lbrakk>well_shaped t; l t < r t\\<rbrakk> \\<Longrightarrow> l (lchild t) = l t\"", "lemma r_rchild_eq_r_if_well_shaped[simp]:\n  \"\\<lbrakk>well_shaped t; l t < r t\\<rbrakk> \\<Longrightarrow> r (rchild t) = r t\"", "lemma r_lchild_eq_l_rchild_if_well_shaped:\n  \"\\<lbrakk>well_shaped t; l t < r t\\<rbrakk> \\<Longrightarrow> r (lchild t) = l (rchild t) - 1\"", "lemma r_lchild_le_r: \"well_shaped t \\<Longrightarrow> r (lchild t) \\<le> r t\"", "lemma well_shaped_lchild[simp]: \"well_shaped t \\<Longrightarrow> well_shaped (lchild t)\"", "lemma well_shaped_rchild[simp]: \"well_shaped t \\<Longrightarrow> well_shaped (rchild t)\"", "lemma adjacent_Nil[simp]: \"adjacent w []\"", "lemma adjacent_Cons: \"adjacent w (t # ts) =\n  (t \\<noteq> Leaf \\<and> r t = snd w \\<and> (case ts of [] \\<Rightarrow> l t = fst w\n     | u # us \\<Rightarrow> adjacent (fst w, r u) ts \\<and> l t = Suc (r u)))\"", "lemma adjacent_ConsI: \"\\<lbrakk>t \\<noteq> Leaf; r t = snd w;\n  (case ts of [] \\<Rightarrow> l t = fst w\n     | u # us \\<Rightarrow> adjacent (fst w, r u) ts \\<and> l t = Suc (r u))\\<rbrakk> \\<Longrightarrow> \n  adjacent w (t # ts)\"", "lemma adjacent_singleton: \"t \\<noteq> Leaf \\<Longrightarrow> adjacent (l t, r t) [t]\"", "lemma append_Cons_eq_append_append: \"xs @ y # ys = xs @ [y] @ ys\"", "lemma list_all2_append_singletonI: \"\\<lbrakk>list_all2 P xs ys; P x y\\<rbrakk> \\<Longrightarrow> list_all2 P (xs @ [x]) (ys @ [y])\"", "lemma list_all2_Cons_append_singletonI: \"\\<lbrakk>xs \\<noteq> []; list_all2 P (x # butlast xs) ys; P (last xs) y\\<rbrakk> \\<Longrightarrow> list_all2 P (x # xs) (ys @ [y])\"", "lemma adjacent_appendI: \"\\<lbrakk>0 < fst w; fst w \\<le> snd w;\n  (case us of [] \\<Rightarrow> adjacent w ts\n    | u # us' \\<Rightarrow> adjacent (Suc (r u), snd w) ts \\<and> adjacent (fst w, (case ts of [] \\<Rightarrow> snd w | ts \\<Rightarrow> r u)) (u # us'))\\<rbrakk> \\<Longrightarrow> \n  adjacent w (ts @ us)\"", "lemma adjacent_Cons_implies_adjacent: \"adjacent (a, b) (t # ts) \\<Longrightarrow> adjacent (a, l t - Suc 0) ts\"", "lemma (in semigroup_add) fold_add_add: \"fold (+) xs (x + y) = fold (+) xs x + y\"", "lemma valid_Leaf: \"valid Leaf\"", "lemma add_sum:\n  assumes \"i > 0\" \"j \\<ge> i\" \"k > j\"\n  shows \"sum i j + sum (Suc j) k = sum i k\"", "lemma well_valued0_rchild_if_well_valued0[simp]: \"well_valued0 t \\<Longrightarrow> well_valued0 (rchild t)\"", "lemma well_valued0_lchild_if_well_valued0[simp]: \"well_valued0 t \\<Longrightarrow> well_valued0 (lchild t)\"", "lemma valid_rchild_if_valid: \"valid t \\<Longrightarrow> valid (rchild t)\"", "lemma val_eq_Some_sum_if_valid_neq_Leaf: \"\\<lbrakk>valid t; t \\<noteq> Leaf\\<rbrakk> \\<Longrightarrow> val t = Some (sum (l t) (r t))\"", "lemma adjacent_atomics: \"adjacent (i, j) (atomics i j)\"", "lemma valid_atomics: \"\\<lbrakk>t \\<in> set (atomics i j); 0 < i; j \\<le> length as\\<rbrakk> \\<Longrightarrow> valid t\"", "lemma reusables_neq_Nil_if_well_shaped_and_overlapping:\n  \"\\<lbrakk>well_shaped t; l t \\<le> fst w; r t \\<le> snd w; fst w \\<le> r t\\<rbrakk> \\<Longrightarrow> reusables t w \\<noteq> []\"", "lemma reusables_lchild_neq_Nil_under_some_conditions:\n  \"\\<lbrakk>well_shaped t; l t \\<le> fst w; r t \\<le> snd w; fst w \\<noteq> l t; r t \\<ge> fst w; l (rchild t) > fst w\\<rbrakk> \\<Longrightarrow>\n    reusables (lchild t) w \\<noteq> []\"", "lemma adjacent_reusables: \"\\<lbrakk>0 < fst w; well_shaped t; l t \\<le> fst w; r t \\<le> snd w\\<rbrakk> \\<Longrightarrow>\n  adjacent (fst w, r t) (reusables t w)\"", "lemma valid_rchild_if_well_valued0: \"\\<lbrakk>well_shaped t; well_valued0 t\\<rbrakk> \\<Longrightarrow> valid (rchild t)\"", "lemma valid_reusables_under_some_conditions:\n  \"\\<lbrakk>0 < fst w; well_valued0 t; well_shaped t; l t < fst w; r t \\<le> snd w\\<rbrakk> \\<Longrightarrow>\n    \\<forall>t' \\<in> set (reusables t w). valid t'\"", "lemma valid_reusables:\n  assumes \"0 < fst w\" \"valid t\" \"l t \\<le> fst w\" \"r t \\<le> snd w\"\n  shows \"\\<forall>t' \\<in> set (reusables t w). valid t'\"", "lemma combine_valid_Nodes_aux:\n  assumes prems: \"0 < l a\" \"a \\<noteq> Leaf\" \"z \\<noteq> Leaf\" \"l z = Suc (r a)\" \"well_shaped a\" \"well_shaped z\"\n    \"well_valued0 a\" \"val a = Some va\" \"well_valued0 z\" \"val z = Some vz\"\n  shows \"va + vz = fold (+) (rev (map ((!) as) [l a - Suc 0..<r z - Suc 0])) (as ! (r z - Suc 0))\"", "lemma discharge_is_Leaf[simp]: \"discharge a = Leaf \\<longleftrightarrow> a = Leaf\"", "lemma well_shaped_discharge[simp]: \"well_shaped a \\<Longrightarrow> well_shaped (discharge a)\"", "lemma well_valued0_discharge[simp]: \"well_valued0 a \\<Longrightarrow> well_valued0 (discharge a)\"", "lemma l_discharge[simp]: \"l (discharge a) = l a\"", "lemma r_discharge[simp]: \"r (discharge a) = r a\"", "lemma well_shaped_lr: \"well_shaped a \\<Longrightarrow> l a \\<le> r a\"", "lemma well_valued0_r: \"well_valued0 a \\<Longrightarrow> a \\<noteq> Leaf \\<Longrightarrow> r a \\<le> length as\"", "lemma valid_combine_if_valid: \"\\<lbrakk>0 < l a; valid a; valid z; a \\<noteq> Leaf; z \\<noteq> Leaf; l z = Suc (r a)\\<rbrakk> \\<Longrightarrow>\n  valid (combine a z)\"", "lemma combine_neq_Leaf_if_both_non_Leaf: \"\\<lbrakk>a \\<noteq> Leaf; z \\<noteq> Leaf\\<rbrakk> \\<Longrightarrow>\n  combine a z \\<noteq> Leaf\"", "lemma valid_fold_combine: \"\\<lbrakk>0 < fst w; ts = h # ts'; \\<forall>t \\<in> set ts. valid t; adjacent (fst w, l h - 1) ts';\n    valid z; z \\<noteq> Leaf; l z = (case ts' of [] \\<Rightarrow> fst w | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1)); r z = snd w\\<rbrakk> \\<Longrightarrow>\n      valid (fold combine ts' z) \\<and>\n      l (fold combine ts' z) = fst w \\<and> r (fold combine ts' z) = snd w\"", "lemma valid_fold_combine_Leaf: \n  assumes \"0 < fst w\" \"ts = h # ts'\" \"\\<forall>t \\<in> set ts. valid t\" \"adjacent w ts\"\n  shows \"valid (fold combine ts Leaf) \\<and>\n  l (fold combine ts Leaf) = fst w \\<and> r (fold combine ts Leaf) = snd w\"", "lemma adjacent_atomics_nonempty_reusables:\n  fixes x :: \"'a tree\" and xs :: \"'a tree list\"\n  assumes a1: \"0 < fst w\"\n      and a2: \"l t \\<le> fst w\"\n      and a3: \"r t \\<le> snd w\"\n      and a4: \"valid t\"\n      and a5: \"reusables t w = x # xs\"\n  shows \"adjacent (Suc (r x), snd w) (atomics (max (fst w) (Suc (r t))) (snd w))\"", "lemma adjacent_Cons_r: \"adjacent (a, r t) (x # xs) \\<Longrightarrow> adjacent (a, r x) (x # xs)\"", "lemma adjacent_Cons_r2:\n  \"adjacent (fst w, r t) (x # xs) \\<Longrightarrow> 0 < fst w \\<Longrightarrow> fst w \\<le> snd w \\<Longrightarrow> r t \\<le> snd w \\<Longrightarrow>\n   atomics (max (fst w) (Suc (r t))) (snd w) = [] \\<Longrightarrow>\n   adjacent w (x # xs)\"", "lemma adjacent_append_atomics_reusables:\n  \"\\<lbrakk>0 < fst w; fst w \\<le> snd w; valid t; l t \\<le> fst w; r t \\<le> snd w\\<rbrakk> \\<Longrightarrow>\n    adjacent w (atomics (max (fst w) (Suc (r t))) (snd w) @ reusables t w)\"", "lemma valid_append_atomics_reusables: \"\\<lbrakk>0 < fst w; valid t; l t \\<le> fst w; r t \\<le> snd w; snd w \\<le> length as\\<rbrakk> \\<Longrightarrow>\n  \\<forall>t \\<in> set (atomics (max (fst w) (Suc (r t))) (snd w) @ reusables t w). valid t\"", "lemma append_atomics_reusables_neq_Nil: \"\\<lbrakk>0 < fst w; fst w \\<le> snd w; valid t; l t \\<le> fst w; r t \\<le> snd w\\<rbrakk> \\<Longrightarrow>\n  atomics (max (fst w) (Suc (r t))) (snd w) @ reusables t w \\<noteq> []\"", "lemma valid_slide:\n  assumes \"0 < fst w\" \"fst w \\<le> snd w\" \"valid t\" \"l t \\<le> fst w\" \"r t \\<le> snd w\" \"snd w \\<le> length as\"\n  shows \"valid (slide t w) \\<and> l (slide t w) = fst w \\<and> r (slide t w) = snd w\"", "lemma iterate_eq_map_sum: \"\\<lbrakk>valid t; windows as xs; (case xs of [] \\<Rightarrow> True | x # xs' \\<Rightarrow> l t \\<le> fst x \\<and> r t \\<le> snd x)\\<rbrakk> \\<Longrightarrow>\n  iterate t xs = map (\\<lambda>w. sum (fst w) (snd w)) xs\"", "theorem correctness: \"windows as ws \\<Longrightarrow> sliding_window = map (\\<lambda>w. sum (fst w) (snd w)) ws\"", "lemma slide_eq_slide':\n  assumes \"0 < fst w\" \"fst w \\<le> snd w\" \"valid as t\" \"r t = length as\" \"l t \\<le> fst w\" \"r t \\<le> snd w\" \"snd w \\<le> length (as @ as')\"\n  shows \"slide (as @ as') t w = slide' as' t w\"", "lemma sum_eq_sum_append: \"\\<lbrakk>0 < i; i \\<le> j; j \\<le> length as\\<rbrakk> \\<Longrightarrow> sum as i j = sum (as @ as') i j\"", "lemma well_valued0_append: \"\\<lbrakk>well_shaped t; well_valued0 as t\\<rbrakk> \\<Longrightarrow> well_valued0 (as @ as') t\"", "lemma valid_append: \"valid as t \\<Longrightarrow> valid (as @ as') t\"", "lemma valid_slide_append: \"\\<lbrakk>0 < fst w; fst w \\<le> snd w; valid as t; l t \\<le> fst w; r t \\<le> snd w; snd w \\<le> length as + length as'\\<rbrakk> \\<Longrightarrow>\n  valid (as @ as') (slide (as @ as') t w) \\<and> l (slide (as @ as') t w) = fst w \\<and> r (slide (as @ as') t w) = snd w\"", "theorem valid_slide':\n  assumes \"0 < fst w\" \"fst w \\<le> snd w\" \"valid as t\" \"length as = r t\" \"length as' \\<ge> snd w - r t\" \"l t \\<le> fst w\" \"r t \\<le> snd w\"\n  shows \"valid (as @ as') (slide' as' t w) \\<and> l (slide' as' t w) = fst w \\<and> r (slide' as' t w) = snd w\"", "lemma map_tree_eq_Leaf_iff: \"map_tree f t = Leaf \\<longleftrightarrow> t = Leaf\"", "lemma l_map_tree_eq_l[simp]: \"l (map_tree f t) = l t\"", "lemma r_map_tree_eq_r[simp]: \"r (map_tree f t) = r t\"", "lemma val_map_tree_neq_None: \"val t \\<noteq> None \\<Longrightarrow> val (map_tree f t) \\<noteq> None\"", "lemma well_shaped_map_tree: \"well_shaped t \\<Longrightarrow> well_shaped (map_tree f t)\"", "lemma fold_distr: \"(\\<forall>x y. f (x + y) = f x + f y) \\<Longrightarrow> f (fold (+) list e) = fold (+) (map f list) (f e)\"", "lemma map_rev_map_nth_eq: \"\\<forall>x \\<in> set xs. x < length as \\<Longrightarrow> map f (rev (map ((!) as) xs)) = rev (map ((!) (map f as)) xs)\"", "lemma f_nth_eq_map_f_nth: \"\\<lbrakk>as \\<noteq> []; length as \\<ge> n\\<rbrakk> \\<Longrightarrow> f (as ! (n - Suc 0)) = map f as ! (n - Suc 0)\"", "lemma well_valued0_map_map_tree:\n   \"\\<lbrakk>\\<forall>x y. f (x + y) = f x + f y; well_shaped t; well_valued0 as t; r t \\<le> length as; as \\<noteq> []\\<rbrakk> \\<Longrightarrow>\n     well_shaped (map_tree f t) \\<and> well_valued0 (map f as) (map_tree f t)\"", "lemma valid_map_map_tree:\n  assumes \"\\<forall>x y. f (x + y) = f x + f y\" \"valid as t\" \"r t \\<le> length as\"\n  shows \"valid (map f as) (map_tree f t)\"", "lemma valid_Nil_iff: \"valid [] t \\<longleftrightarrow> t = Leaf\"", "lemma update_rightmost_eq_Leaf_iff: \"update_rightmost f t = Leaf \\<longleftrightarrow> t = Leaf\"", "lemma l_update_rightmost_eq_l[simp]: \"l (update_rightmost f t) = l t\"", "lemma r_update_rightmost_eq_r[simp]: \"r (update_rightmost f t) = r t\"", "lemma val_update_rightmost_neq_None: \"val t \\<noteq> None \\<Longrightarrow> val (update_rightmost f t) \\<noteq> None\"", "lemma well_shaped_update_rightmost: \"well_shaped t \\<Longrightarrow> well_shaped (update_rightmost f t)\"", "lemma sum_eq_sum_prepend: \"\\<lbrakk>0 < i; i \\<le> j; length xs < i; length ys = length xs\\<rbrakk> \\<Longrightarrow> sum (xs @ as) i j = sum (ys @ as) i j\"", "lemma well_valued0_prepend: \"\\<lbrakk>length xs \\<le> l t - 1; length ys = length xs; well_shaped t; well_valued0 (xs @ as) t\\<rbrakk> \\<Longrightarrow> well_valued0 (ys @ as) t\"", "lemma valid_prepend: \"\\<lbrakk>length xs \\<le> l t - 1; length ys = length xs; valid (xs @ as) t\\<rbrakk> \\<Longrightarrow> valid (ys @ as) t\"", "lemma take_eq_append_take_take_drop: \"m \\<le> n \\<Longrightarrow> take n xs = take m xs @ take (n-m) (drop m xs)\"", "lemma well_valued0_take_r: \"\\<lbrakk>well_shaped t; well_valued0 as t\\<rbrakk> \\<Longrightarrow> well_valued0 (take (r t) as) t\"", "lemma valid_take_r: \"valid as t \\<Longrightarrow> valid (take (r t) as) t\"", "lemma well_valued0_butlast: \"\\<lbrakk>well_shaped t; well_valued0 as t; r t < length as\\<rbrakk> \\<Longrightarrow> well_valued0 (butlast as) t\"", "lemma well_valued0_append_butlast_lchild: \"\\<lbrakk>well_shaped t; well_valued0 as t\\<rbrakk> \\<Longrightarrow>\n  well_valued0 (butlast as @ [last as + x]) (lchild t)\"", "lemma sum_update_rightmost: \"\\<lbrakk>0 < i; i \\<le> j; length as = j\\<rbrakk> \\<Longrightarrow>\n  sum as i j + x = sum (butlast as @ [last as + x]) i j\"", "lemma well_valued0_update_rightmost: \"\\<lbrakk>well_shaped t; well_valued0 as t; length as = r t\\<rbrakk> \\<Longrightarrow>\n  well_valued0 (butlast as @ [last as + x]) (update_rightmost (\\<lambda>a. a + x) t)\"", "lemma valid_update_rightmost: \"\\<lbrakk>valid as t; length as = r t\\<rbrakk> \\<Longrightarrow>\n  valid (butlast as @ [last as + x]) (update_rightmost (\\<lambda>a. a + x) t)\""], "translations": [["", "lemma neq_Leaf_if_l_gt0: \"0 < l t \\<Longrightarrow> t \\<noteq> Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < l t \\<Longrightarrow> t \\<noteq> Leaf", "by auto"], ["", "primrec discharge :: \"'a tree \\<Rightarrow> 'a tree\" where\n  \"discharge Leaf = Leaf\"\n| \"discharge (Node i j _ t u) = Node i j None t u\""], ["", "instantiation option :: (semigroup_add) semigroup_add begin"], ["", "fun plus_option :: \"'a option \\<Rightarrow> 'a option \\<Rightarrow> 'a option\" where\n  \"plus_option None _ = None\"\n| \"plus_option _ None = None\"\n| \"plus_option (Some a) (Some b) = Some (a + b)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a option, semigroup_add_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c. a + b + c = a + (b + c)", "fix a b c :: \"'a option\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c. a + b + c = a + (b + c)", "show \"a + b + c = a + (b + c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b + c = a + (b + c)", "by (induct a b rule: plus_option.induct; cases c)\n      (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  a + b + c = a + (b + c)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "fun combine :: \"'a :: semigroup_add tree \\<Rightarrow> 'a tree \\<Rightarrow> 'a tree\" where\n  \"combine t Leaf = t\"\n| \"combine Leaf t = t\"\n| \"combine t u = Node (l t) (r u) (val t + val u) (discharge t) u\""], ["", "lemma combine_non_Leaves: \"\\<lbrakk>t \\<noteq> Leaf; u \\<noteq> Leaf\\<rbrakk> \\<Longrightarrow> combine t u = Node (l t) (r u) (val t + val u) (discharge t) u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> Leaf; u \\<noteq> Leaf\\<rbrakk>\n    \\<Longrightarrow> combine t u =\n                      Node (l t) (r u) (val t + val u) (discharge t) u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> Leaf; u \\<noteq> Leaf\\<rbrakk>\n    \\<Longrightarrow> combine t u =\n                      Node (l t) (r u) (val t + val u) (discharge t) u", "assume assms: \"t \\<noteq> Leaf\" \"u \\<noteq> Leaf\""], ["proof (state)\nthis:\n  t \\<noteq> Leaf\n  u \\<noteq> Leaf\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> Leaf; u \\<noteq> Leaf\\<rbrakk>\n    \\<Longrightarrow> combine t u =\n                      Node (l t) (r u) (val t + val u) (discharge t) u", "from assms"], ["proof (chain)\npicking this:\n  t \\<noteq> Leaf\n  u \\<noteq> Leaf", "have \"combine t u = Node (l (Node (l t) (r t) (val t) (lchild t) (rchild t))) (r (Node (l u) (r u) (val u) (lchild u) (rchild u))) (val (Node (l t) (r t) (val t) (lchild t) (rchild t)) + val (Node (l u) (r u) (val u) (lchild u) (rchild u))) (discharge (Node (l t) (r t) (val t) (lchild t) (rchild t))) (Node (l u) (r u) (val u) (lchild u) (rchild u))\""], ["proof (prove)\nusing this:\n  t \\<noteq> Leaf\n  u \\<noteq> Leaf\n\ngoal (1 subgoal):\n 1. combine t u =\n    Node (l (Node (l t) (r t) (val t) (lchild t) (rchild t)))\n     (r (Node (l u) (r u) (val u) (lchild u) (rchild u)))\n     (val (Node (l t) (r t) (val t) (lchild t) (rchild t)) +\n      val (Node (l u) (r u) (val u) (lchild u) (rchild u)))\n     (discharge (Node (l t) (r t) (val t) (lchild t) (rchild t)))\n     (Node (l u) (r u) (val u) (lchild u) (rchild u))", "by (metis (no_types) combine.simps(3) tree.exhaust_sel)"], ["proof (state)\nthis:\n  combine t u =\n  Node (l (Node (l t) (r t) (val t) (lchild t) (rchild t)))\n   (r (Node (l u) (r u) (val u) (lchild u) (rchild u)))\n   (val (Node (l t) (r t) (val t) (lchild t) (rchild t)) +\n    val (Node (l u) (r u) (val u) (lchild u) (rchild u)))\n   (discharge (Node (l t) (r t) (val t) (lchild t) (rchild t)))\n   (Node (l u) (r u) (val u) (lchild u) (rchild u))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> Leaf; u \\<noteq> Leaf\\<rbrakk>\n    \\<Longrightarrow> combine t u =\n                      Node (l t) (r u) (val t + val u) (discharge t) u", "with assms"], ["proof (chain)\npicking this:\n  t \\<noteq> Leaf\n  u \\<noteq> Leaf\n  combine t u =\n  Node (l (Node (l t) (r t) (val t) (lchild t) (rchild t)))\n   (r (Node (l u) (r u) (val u) (lchild u) (rchild u)))\n   (val (Node (l t) (r t) (val t) (lchild t) (rchild t)) +\n    val (Node (l u) (r u) (val u) (lchild u) (rchild u)))\n   (discharge (Node (l t) (r t) (val t) (lchild t) (rchild t)))\n   (Node (l u) (r u) (val u) (lchild u) (rchild u))", "show ?thesis"], ["proof (prove)\nusing this:\n  t \\<noteq> Leaf\n  u \\<noteq> Leaf\n  combine t u =\n  Node (l (Node (l t) (r t) (val t) (lchild t) (rchild t)))\n   (r (Node (l u) (r u) (val u) (lchild u) (rchild u)))\n   (val (Node (l t) (r t) (val t) (lchild t) (rchild t)) +\n    val (Node (l u) (r u) (val u) (lchild u) (rchild u)))\n   (discharge (Node (l t) (r t) (val t) (lchild t) (rchild t)))\n   (Node (l u) (r u) (val u) (lchild u) (rchild u))\n\ngoal (1 subgoal):\n 1. combine t u = Node (l t) (r u) (val t + val u) (discharge t) u", "by simp"], ["proof (state)\nthis:\n  combine t u = Node (l t) (r u) (val t + val u) (discharge t) u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma r_combine_non_Leaves: \"\\<lbrakk>t \\<noteq> Leaf; u \\<noteq> Leaf\\<rbrakk> \\<Longrightarrow> r (combine t u) = r u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> Leaf; u \\<noteq> Leaf\\<rbrakk>\n    \\<Longrightarrow> r (combine t u) = r u", "by (simp add: combine_non_Leaves)"], ["", "type_synonym window = \"nat \\<times> nat\""], ["", "definition window :: \"'a list \\<Rightarrow> window \\<Rightarrow> bool\" where\n  \"window as = (\\<lambda>(l, r). 0 < l \\<and> l \\<le> r \\<and> r \\<le> length as)\""], ["", "definition windows :: \"'a list \\<Rightarrow> window list \\<Rightarrow> bool\" where\n  \"windows as ws = ((\\<forall>w \\<in> set ws. window as w) \\<and>\n    sorted (map fst ws) \\<and> sorted (map snd ws))\""], ["", "function reusables :: \"'a tree \\<Rightarrow> window \\<Rightarrow> 'a tree list\" where\n  \"reusables t w = (if fst w > r t then [] else if fst w = l t then [t]\n     else let v = lchild t; u = rchild t in if fst w \\<ge> l u then\n       reusables u w else u # reusables v w)\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>t w. x = (t, w) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>t w ta wa.\n       (t, w) = (ta, wa) \\<Longrightarrow>\n       (if r t < fst w then []\n        else if fst w = l t then [t]\n             else let v = lchild t; u = rchild t\n                  in if l u \\<le> fst w then reusables_sumC (u, w)\n                     else u # reusables_sumC (v, w)) =\n       (if r ta < fst wa then []\n        else if fst wa = l ta then [ta]\n             else let v = lchild ta; u = rchild ta\n                  in if l u \\<le> fst wa then reusables_sumC (u, wa)\n                     else u # reusables_sumC (v, wa))", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All reusables_dom", "by (relation \"measure (\\<lambda>p. size (fst p))\")\n    (auto simp: lchild_def rchild_def split: tree.splits)"], ["", "declare reusables.simps[simp del]"], ["", "lemma reusables_Leaf[simp]: \"0 < fst w \\<Longrightarrow> reusables Leaf w = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < fst w \\<Longrightarrow> reusables Leaf w = []", "by (simp add: reusables.simps)"], ["", "primrec well_shaped :: \"'a tree \\<Rightarrow> bool\" where\n  \"well_shaped Leaf = True\"\n| \"well_shaped (Node i j _ t u) = (i \\<le> j \\<and> (i = j \\<longrightarrow> t = Leaf \\<and> u = Leaf) \\<and>\n    (i < j \\<longrightarrow> t \\<noteq> Leaf \\<and> u \\<noteq> Leaf \\<and> well_shaped t \\<and> well_shaped u \\<and>\n      i = l t \\<and> j = r u \\<and> Suc (r t) = l u))\""], ["", "lemma l_lchild_eq_l_if_well_shaped[simp]:\n  \"\\<lbrakk>well_shaped t; l t < r t\\<rbrakk> \\<Longrightarrow> l (lchild t) = l t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>well_shaped t; l t < r t\\<rbrakk>\n    \\<Longrightarrow> l (lchild t) = l t", "by (induct t) auto"], ["", "lemma r_rchild_eq_r_if_well_shaped[simp]:\n  \"\\<lbrakk>well_shaped t; l t < r t\\<rbrakk> \\<Longrightarrow> r (rchild t) = r t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>well_shaped t; l t < r t\\<rbrakk>\n    \\<Longrightarrow> r (rchild t) = r t", "by (induct t) auto"], ["", "lemma r_lchild_eq_l_rchild_if_well_shaped:\n  \"\\<lbrakk>well_shaped t; l t < r t\\<rbrakk> \\<Longrightarrow> r (lchild t) = l (rchild t) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>well_shaped t; l t < r t\\<rbrakk>\n    \\<Longrightarrow> r (lchild t) = l (rchild t) - 1", "by (induct t) auto"], ["", "lemma r_lchild_le_r: \"well_shaped t \\<Longrightarrow> r (lchild t) \\<le> r t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_shaped t \\<Longrightarrow> r (lchild t) \\<le> r t", "proof (induct t)"], ["proof (state)\ngoal (2 subgoals):\n 1. well_shaped Leaf \\<Longrightarrow> r (lchild Leaf) \\<le> r Leaf\n 2. \\<And>x1 x2 x3 t1 t2.\n       \\<lbrakk>well_shaped t1 \\<Longrightarrow> r (lchild t1) \\<le> r t1;\n        well_shaped t2 \\<Longrightarrow> r (lchild t2) \\<le> r t2;\n        well_shaped (Node x1 x2 x3 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> r (lchild (Node x1 x2 x3 t1 t2))\n                         \\<le> r (Node x1 x2 x3 t1 t2)", "case (Node i j a t1 t2)"], ["proof (state)\nthis:\n  well_shaped t1 \\<Longrightarrow> r (lchild t1) \\<le> r t1\n  well_shaped t2 \\<Longrightarrow> r (lchild t2) \\<le> r t2\n  well_shaped (Node i j a t1 t2)\n\ngoal (2 subgoals):\n 1. well_shaped Leaf \\<Longrightarrow> r (lchild Leaf) \\<le> r Leaf\n 2. \\<And>x1 x2 x3 t1 t2.\n       \\<lbrakk>well_shaped t1 \\<Longrightarrow> r (lchild t1) \\<le> r t1;\n        well_shaped t2 \\<Longrightarrow> r (lchild t2) \\<le> r t2;\n        well_shaped (Node x1 x2 x3 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> r (lchild (Node x1 x2 x3 t1 t2))\n                         \\<le> r (Node x1 x2 x3 t1 t2)", "then"], ["proof (chain)\npicking this:\n  well_shaped t1 \\<Longrightarrow> r (lchild t1) \\<le> r t1\n  well_shaped t2 \\<Longrightarrow> r (lchild t2) \\<le> r t2\n  well_shaped (Node i j a t1 t2)", "show ?case"], ["proof (prove)\nusing this:\n  well_shaped t1 \\<Longrightarrow> r (lchild t1) \\<le> r t1\n  well_shaped t2 \\<Longrightarrow> r (lchild t2) \\<le> r t2\n  well_shaped (Node i j a t1 t2)\n\ngoal (1 subgoal):\n 1. r (lchild (Node i j a t1 t2)) \\<le> r (Node i j a t1 t2)", "by auto\n      (metis Suc_eq_plus1_left order.trans le_add2 tree.exhaust_sel well_shaped.simps(2))"], ["proof (state)\nthis:\n  r (lchild (Node i j a t1 t2)) \\<le> r (Node i j a t1 t2)\n\ngoal (1 subgoal):\n 1. well_shaped Leaf \\<Longrightarrow> r (lchild Leaf) \\<le> r Leaf", "qed simp"], ["", "lemma well_shaped_lchild[simp]: \"well_shaped t \\<Longrightarrow> well_shaped (lchild t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_shaped t \\<Longrightarrow> well_shaped (lchild t)", "by (induct t) auto"], ["", "lemma well_shaped_rchild[simp]: \"well_shaped t \\<Longrightarrow> well_shaped (rchild t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_shaped t \\<Longrightarrow> well_shaped (rchild t)", "by (induct t) auto"], ["", "definition adjacent where\n  \"adjacent w ts = (Leaf \\<notin> set ts \\<and>\n     list_all2 (\\<lambda>t u. l t = Suc (r u)) (butlast ts) (tl ts) \\<and>\n     (ts = [] \\<or> (l (last ts) = fst w \\<and> r (hd ts) = snd w)))\""], ["", "lemma adjacent_Nil[simp]: \"adjacent w []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent w []", "unfolding adjacent_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Leaf \\<notin> set [] \\<and>\n    list_all2 (\\<lambda>t u. l t = Suc (r u)) (butlast []) (tl []) \\<and>\n    ([] = [] \\<or> l (last []) = fst w \\<and> r (hd []) = snd w)", "by simp"], ["", "lemma adjacent_Cons: \"adjacent w (t # ts) =\n  (t \\<noteq> Leaf \\<and> r t = snd w \\<and> (case ts of [] \\<Rightarrow> l t = fst w\n     | u # us \\<Rightarrow> adjacent (fst w, r u) ts \\<and> l t = Suc (r u)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent w (t # ts) =\n    (t \\<noteq> Leaf \\<and>\n     r t = snd w \\<and>\n     (case ts of [] \\<Rightarrow> l t = fst w\n      | u # us \\<Rightarrow>\n          adjacent (fst w, r u) ts \\<and> l t = Suc (r u)))", "unfolding adjacent_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Leaf \\<notin> set (t # ts) \\<and>\n     list_all2 (\\<lambda>t u. l t = Suc (r u)) (butlast (t # ts))\n      (tl (t # ts)) \\<and>\n     (t # ts = [] \\<or>\n      l (last (t # ts)) = fst w \\<and> r (hd (t # ts)) = snd w)) =\n    (t \\<noteq> Leaf \\<and>\n     r t = snd w \\<and>\n     (case ts of [] \\<Rightarrow> l t = fst w\n      | u # us \\<Rightarrow>\n          (Leaf \\<notin> set ts \\<and>\n           list_all2 (\\<lambda>t u. l t = Suc (r u)) (butlast ts)\n            (tl ts) \\<and>\n           (ts = [] \\<or>\n            l (last ts) = fst (fst w, r u) \\<and>\n            r (hd ts) = snd (fst w, r u))) \\<and>\n          l t = Suc (r u)))", "by (auto split: list.splits)"], ["", "lemma adjacent_ConsI: \"\\<lbrakk>t \\<noteq> Leaf; r t = snd w;\n  (case ts of [] \\<Rightarrow> l t = fst w\n     | u # us \\<Rightarrow> adjacent (fst w, r u) ts \\<and> l t = Suc (r u))\\<rbrakk> \\<Longrightarrow> \n  adjacent w (t # ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> Leaf; r t = snd w;\n     case ts of [] \\<Rightarrow> l t = fst w\n     | u # us \\<Rightarrow>\n         adjacent (fst w, r u) ts \\<and> l t = Suc (r u)\\<rbrakk>\n    \\<Longrightarrow> adjacent w (t # ts)", "by (simp add: adjacent_Cons)"], ["", "lemma adjacent_singleton: \"t \\<noteq> Leaf \\<Longrightarrow> adjacent (l t, r t) [t]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<noteq> Leaf \\<Longrightarrow> adjacent (l t, r t) [t]", "unfolding adjacent_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<noteq> Leaf \\<Longrightarrow>\n    Leaf \\<notin> set [t] \\<and>\n    list_all2 (\\<lambda>t u. l t = Suc (r u)) (butlast [t]) (tl [t]) \\<and>\n    ([t] = [] \\<or>\n     l (last [t]) = fst (l t, r t) \\<and> r (hd [t]) = snd (l t, r t))", "by simp"], ["", "lemma append_Cons_eq_append_append: \"xs @ y # ys = xs @ [y] @ ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs @ y # ys = xs @ [y] @ ys", "by simp"], ["", "lemma list_all2_append_singletonI: \"\\<lbrakk>list_all2 P xs ys; P x y\\<rbrakk> \\<Longrightarrow> list_all2 P (xs @ [x]) (ys @ [y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all2 P xs ys; P x y\\<rbrakk>\n    \\<Longrightarrow> list_all2 P (xs @ [x]) (ys @ [y])", "by (simp add: list_all2_appendI)"], ["", "lemma list_all2_Cons_append_singletonI: \"\\<lbrakk>xs \\<noteq> []; list_all2 P (x # butlast xs) ys; P (last xs) y\\<rbrakk> \\<Longrightarrow> list_all2 P (x # xs) (ys @ [y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> []; list_all2 P (x # butlast xs) ys;\n     P (last xs) y\\<rbrakk>\n    \\<Longrightarrow> list_all2 P (x # xs) (ys @ [y])", "using list_all2_append_singletonI"], ["proof (prove)\nusing this:\n  \\<lbrakk>list_all2 ?P ?xs ?ys; ?P ?x ?y\\<rbrakk>\n  \\<Longrightarrow> list_all2 ?P (?xs @ [?x]) (?ys @ [?y])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> []; list_all2 P (x # butlast xs) ys;\n     P (last xs) y\\<rbrakk>\n    \\<Longrightarrow> list_all2 P (x # xs) (ys @ [y])", "by fastforce"], ["", "lemma adjacent_appendI: \"\\<lbrakk>0 < fst w; fst w \\<le> snd w;\n  (case us of [] \\<Rightarrow> adjacent w ts\n    | u # us' \\<Rightarrow> adjacent (Suc (r u), snd w) ts \\<and> adjacent (fst w, (case ts of [] \\<Rightarrow> snd w | ts \\<Rightarrow> r u)) (u # us'))\\<rbrakk> \\<Longrightarrow> \n  adjacent w (ts @ us)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < fst w; fst w \\<le> snd w;\n     case us of [] \\<Rightarrow> adjacent w ts\n     | u # us' \\<Rightarrow>\n         adjacent (Suc (r u), snd w) ts \\<and>\n         adjacent\n          (fst w,\n           case ts of [] \\<Rightarrow> snd w | a # list \\<Rightarrow> r u)\n          (u # us')\\<rbrakk>\n    \\<Longrightarrow> adjacent w (ts @ us)", "unfolding adjacent_def butlast_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < fst w; fst w \\<le> snd w;\n     case us of\n     [] \\<Rightarrow>\n       Leaf \\<notin> set ts \\<and>\n       list_all2 (\\<lambda>t u. l t = Suc (r u)) (butlast ts) (tl ts) \\<and>\n       (ts = [] \\<or> l (last ts) = fst w \\<and> r (hd ts) = snd w)\n     | u # us' \\<Rightarrow>\n         (Leaf \\<notin> set ts \\<and>\n          list_all2 (\\<lambda>t u. l t = Suc (r u)) (butlast ts)\n           (tl ts) \\<and>\n          (ts = [] \\<or>\n           l (last ts) = fst (Suc (r u), snd w) \\<and>\n           r (hd ts) = snd (Suc (r u), snd w))) \\<and>\n         Leaf \\<notin> set (u # us') \\<and>\n         list_all2 (\\<lambda>t u. l t = Suc (r u)) (butlast (u # us'))\n          (tl (u # us')) \\<and>\n         (u # us' = [] \\<or>\n          l (last (u # us')) =\n          fst (fst w,\n               case ts of [] \\<Rightarrow> snd w\n               | a # list \\<Rightarrow> r u) \\<and>\n          r (hd (u # us')) =\n          snd (fst w,\n               case ts of [] \\<Rightarrow> snd w\n               | a # list \\<Rightarrow> r u))\\<rbrakk>\n    \\<Longrightarrow> Leaf \\<notin> set (ts @ us) \\<and>\n                      list_all2 (\\<lambda>t u. l t = Suc (r u))\n                       (if us = [] then butlast ts else ts @ butlast us)\n                       (tl (ts @ us)) \\<and>\n                      (ts @ us = [] \\<or>\n                       l (last (ts @ us)) = fst w \\<and>\n                       r (hd (ts @ us)) = snd w)", "by (auto simp: intro: list_all2_Cons_append_singletonI\n    list_all2_appendI[OF list_all2_Cons_append_singletonI, simplified] split: list.splits if_splits)"], ["", "lemma adjacent_Cons_implies_adjacent: \"adjacent (a, b) (t # ts) \\<Longrightarrow> adjacent (a, l t - Suc 0) ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent (a, b) (t # ts) \\<Longrightarrow> adjacent (a, l t - Suc 0) ts", "by (cases ts) (simp_all add: adjacent_def)"], ["", "lemma (in semigroup_add) fold_add_add: \"fold (+) xs (x + y) = fold (+) xs x + y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (+) xs (x + y) = fold (+) xs x + y", "by (induct xs arbitrary: x) (auto simp: add_assoc[symmetric])"], ["", "context\n  fixes as :: \"'a :: semigroup_add list\"\n  and ws :: \"window list\"\nbegin"], ["", "abbreviation atomic where\n  \"atomic i \\<equiv> Node i i (Some (nth as (i - 1))) Leaf Leaf\""], ["", "definition atomics :: \"nat \\<Rightarrow> nat \\<Rightarrow> 'a tree list\" where\n  \"atomics i j \\<equiv> map atomic (rev [i ..< Suc j])\""], ["", "definition slide :: \"'a tree \\<Rightarrow> window \\<Rightarrow> 'a tree\" where\n  \"slide t w =\n    (let\n      ts = atomics (max (fst w) (Suc (r t))) (snd w);\n      ts' = reusables t w\n    in fold combine (ts @ ts') Leaf)\""], ["", "primrec iterate :: \"'a tree \\<Rightarrow> window list \\<Rightarrow> 'a list\" where\n  \"iterate t [] = []\"\n| \"iterate t (w # xs) = (let t' = slide t w in the (val t') # iterate t' xs)\""], ["", "definition sliding_window :: \"'a list\" where\n  \"sliding_window = iterate Leaf ws\""], ["", "section \\<open>Correctness\\<close>"], ["", "abbreviation sum where\n  \"sum i j \\<equiv> fold (+) (rev (map (nth as) [i - 1 ..< j - 1])) (nth as (j - 1))\""], ["", "primrec well_valued0 :: \"'a tree \\<Rightarrow> bool\" where\n  \"well_valued0 Leaf = True\"\n| \"well_valued0 (Node i j a t u) = (0 < i \\<and> j \\<le> length as \\<and> (a \\<noteq> None \\<longrightarrow> a = Some (sum i j)) \\<and>\n    well_valued0 t \\<and> well_valued0 u \\<and> (u = Leaf \\<or> val u \\<noteq> None))\""], ["", "abbreviation well_valued :: \"'a tree \\<Rightarrow> bool\" where\n  \"well_valued t \\<equiv> (well_valued0 t \\<and> (t \\<noteq> Leaf \\<longrightarrow> val t \\<noteq> None))\""], ["", "definition valid :: \"'a tree \\<Rightarrow> bool\" where\n  \"valid t = (well_shaped t \\<and> well_valued t)\""], ["", "lemma valid_Leaf: \"valid Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.valid Leaf", "unfolding valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. well_shaped Leaf \\<and>\n    local.well_valued0 Leaf \\<and>\n    (Leaf \\<noteq> Leaf \\<longrightarrow> val Leaf \\<noteq> None)", "by auto"], ["", "lemma add_sum:\n  assumes \"i > 0\" \"j \\<ge> i\" \"k > j\"\n  shows \"sum i j + sum (Suc j) k = sum i k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.sum i j + local.sum (Suc j) k = local.sum i k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.sum i j + local.sum (Suc j) k = local.sum i k", "have *: \"[i - 1 ..< k - 1] = [i - 1..< j] @ [j..< k - 1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [i - 1..<k - 1] = [i - 1..<j] @ [j..<k - 1]", "using assms upt_add_eq_append[of \"i - 1\" \"j - 1\" \"k - j\"]"], ["proof (prove)\nusing this:\n  0 < i\n  i \\<le> j\n  j < k\n  i - 1 \\<le> j - 1 \\<Longrightarrow>\n  [i - 1..<j - 1 + (k - j)] = [i - 1..<j - 1] @ [j - 1..<j - 1 + (k - j)]\n\ngoal (1 subgoal):\n 1. [i - 1..<k - 1] = [i - 1..<j] @ [j..<k - 1]", "by (cases j) (auto simp: upt_conv_Cons)"], ["proof (state)\nthis:\n  [i - 1..<k - 1] = [i - 1..<j] @ [j..<k - 1]\n\ngoal (1 subgoal):\n 1. local.sum i j + local.sum (Suc j) k = local.sum i k", "then"], ["proof (chain)\npicking this:\n  [i - 1..<k - 1] = [i - 1..<j] @ [j..<k - 1]", "show ?thesis"], ["proof (prove)\nusing this:\n  [i - 1..<k - 1] = [i - 1..<j] @ [j..<k - 1]\n\ngoal (1 subgoal):\n 1. local.sum i j + local.sum (Suc j) k = local.sum i k", "using assms"], ["proof (prove)\nusing this:\n  [i - 1..<k - 1] = [i - 1..<j] @ [j..<k - 1]\n  0 < i\n  i \\<le> j\n  j < k\n\ngoal (1 subgoal):\n 1. local.sum i j + local.sum (Suc j) k = local.sum i k", "by (cases j) (auto simp: fold_add_add)"], ["proof (state)\nthis:\n  local.sum i j + local.sum (Suc j) k = local.sum i k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma well_valued0_rchild_if_well_valued0[simp]: \"well_valued0 t \\<Longrightarrow> well_valued0 (rchild t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.well_valued0 t \\<Longrightarrow> local.well_valued0 (rchild t)", "by (induct t) auto"], ["", "lemma well_valued0_lchild_if_well_valued0[simp]: \"well_valued0 t \\<Longrightarrow> well_valued0 (lchild t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.well_valued0 t \\<Longrightarrow> local.well_valued0 (lchild t)", "by (induct t) auto"], ["", "lemma valid_rchild_if_valid: \"valid t \\<Longrightarrow> valid (rchild t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.valid t \\<Longrightarrow> local.valid (rchild t)", "by (metis tree.exhaust_sel tree.sel(9) valid_def well_shaped_rchild well_valued0.simps(2))"], ["", "lemma val_eq_Some_sum_if_valid_neq_Leaf: \"\\<lbrakk>valid t; t \\<noteq> Leaf\\<rbrakk> \\<Longrightarrow> val t = Some (sum (l t) (r t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.valid t; t \\<noteq> Leaf\\<rbrakk>\n    \\<Longrightarrow> val t = Some (local.sum (l t) (r t))", "by (auto simp: valid_def foldr_conv_fold)\n    (metis One_nat_def option.distinct(1) option.inject tree.exhaust_sel well_valued0.simps(2))"], ["", "subsection \\<open>Correctness of the Slide Function\\<close>"], ["", "(* fact (b) part 1 *)"], ["", "lemma adjacent_atomics: \"adjacent (i, j) (atomics i j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent (i, j) (local.atomics i j)", "unfolding adjacent_def atomics_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Leaf \\<notin> set (map local.atomic (rev [i..<Suc j])) \\<and>\n    list_all2 (\\<lambda>t u. l t = Suc (r u))\n     (butlast (map local.atomic (rev [i..<Suc j])))\n     (tl (map local.atomic (rev [i..<Suc j]))) \\<and>\n    (map local.atomic (rev [i..<Suc j]) = [] \\<or>\n     l (last (map local.atomic (rev [i..<Suc j]))) = fst (i, j) \\<and>\n     r (hd (map local.atomic (rev [i..<Suc j]))) = snd (i, j))", "by (auto 0 1 simp: last_map last_rev nth_tl\n    map_butlast[symmetric] list_all2_conv_all_nth nth_Cons' rev_nth nth_append)"], ["", "(* fact (b) part 2 *)"], ["", "lemma valid_atomics: \"\\<lbrakk>t \\<in> set (atomics i j); 0 < i; j \\<le> length as\\<rbrakk> \\<Longrightarrow> valid t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> set (local.atomics i j); 0 < i;\n     j \\<le> length as\\<rbrakk>\n    \\<Longrightarrow> local.valid t", "unfolding atomics_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> set (map local.atomic (rev [i..<Suc j])); 0 < i;\n     j \\<le> length as\\<rbrakk>\n    \\<Longrightarrow> local.valid t", "by (auto simp: valid_def)"], ["", "lemma reusables_neq_Nil_if_well_shaped_and_overlapping:\n  \"\\<lbrakk>well_shaped t; l t \\<le> fst w; r t \\<le> snd w; fst w \\<le> r t\\<rbrakk> \\<Longrightarrow> reusables t w \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>well_shaped t; l t \\<le> fst w; r t \\<le> snd w;\n     fst w \\<le> r t\\<rbrakk>\n    \\<Longrightarrow> reusables t w \\<noteq> []", "by (induction t w rule: reusables.induct) (simp add: reusables.simps Let_def)"], ["", "lemma reusables_lchild_neq_Nil_under_some_conditions:\n  \"\\<lbrakk>well_shaped t; l t \\<le> fst w; r t \\<le> snd w; fst w \\<noteq> l t; r t \\<ge> fst w; l (rchild t) > fst w\\<rbrakk> \\<Longrightarrow>\n    reusables (lchild t) w \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>well_shaped t; l t \\<le> fst w; r t \\<le> snd w;\n     fst w \\<noteq> l t; fst w \\<le> r t; fst w < l (rchild t)\\<rbrakk>\n    \\<Longrightarrow> reusables (lchild t) w \\<noteq> []", "using r_lchild_eq_l_rchild_if_well_shaped[of \"t\"] r_lchild_le_r[of t]"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_shaped t; l t < r t\\<rbrakk>\n  \\<Longrightarrow> r (lchild t) = l (rchild t) - 1\n  well_shaped t \\<Longrightarrow> r (lchild t) \\<le> r t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>well_shaped t; l t \\<le> fst w; r t \\<le> snd w;\n     fst w \\<noteq> l t; fst w \\<le> r t; fst w < l (rchild t)\\<rbrakk>\n    \\<Longrightarrow> reusables (lchild t) w \\<noteq> []", "by (intro reusables_neq_Nil_if_well_shaped_and_overlapping) auto"], ["", "(* fact (a) part 1 *)"], ["", "lemma adjacent_reusables: \"\\<lbrakk>0 < fst w; well_shaped t; l t \\<le> fst w; r t \\<le> snd w\\<rbrakk> \\<Longrightarrow>\n  adjacent (fst w, r t) (reusables t w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < fst w; well_shaped t; l t \\<le> fst w;\n     r t \\<le> snd w\\<rbrakk>\n    \\<Longrightarrow> adjacent (fst w, r t) (reusables t w)", "proof (induction t w rule: reusables.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t w.\n       \\<lbrakk>\\<And>x xa.\n                   \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t;\n                    x = lchild t; xa = rchild t; l xa \\<le> fst w;\n                    0 < fst w; well_shaped xa; l xa \\<le> fst w;\n                    r xa \\<le> snd w\\<rbrakk>\n                   \\<Longrightarrow> adjacent (fst w, r xa)\n(reusables xa w);\n        \\<And>x xa.\n           \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; x = lchild t;\n            xa = rchild t; \\<not> l xa \\<le> fst w; 0 < fst w;\n            well_shaped x; l x \\<le> fst w; r x \\<le> snd w\\<rbrakk>\n           \\<Longrightarrow> adjacent (fst w, r x) (reusables x w);\n        0 < fst w; well_shaped t; l t \\<le> fst w; r t \\<le> snd w\\<rbrakk>\n       \\<Longrightarrow> adjacent (fst w, r t) (reusables t w)", "case (1 t w)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; l ?xa \\<le> fst w; 0 < fst w; well_shaped ?xa;\n   l ?xa \\<le> fst w; r ?xa \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> adjacent (fst w, r ?xa) (reusables ?xa w)\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; \\<not> l ?xa \\<le> fst w; 0 < fst w; well_shaped ?x;\n   l ?x \\<le> fst w; r ?x \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> adjacent (fst w, r ?x) (reusables ?x w)\n  0 < fst w\n  well_shaped t\n  l t \\<le> fst w\n  r t \\<le> snd w\n\ngoal (1 subgoal):\n 1. \\<And>t w.\n       \\<lbrakk>\\<And>x xa.\n                   \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t;\n                    x = lchild t; xa = rchild t; l xa \\<le> fst w;\n                    0 < fst w; well_shaped xa; l xa \\<le> fst w;\n                    r xa \\<le> snd w\\<rbrakk>\n                   \\<Longrightarrow> adjacent (fst w, r xa)\n(reusables xa w);\n        \\<And>x xa.\n           \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; x = lchild t;\n            xa = rchild t; \\<not> l xa \\<le> fst w; 0 < fst w;\n            well_shaped x; l x \\<le> fst w; r x \\<le> snd w\\<rbrakk>\n           \\<Longrightarrow> adjacent (fst w, r x) (reusables x w);\n        0 < fst w; well_shaped t; l t \\<le> fst w; r t \\<le> snd w\\<rbrakk>\n       \\<Longrightarrow> adjacent (fst w, r t) (reusables t w)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent (fst w, r t) (reusables t w)", "proof (cases \"fst w > r t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. r t < fst w \\<Longrightarrow> adjacent (fst w, r t) (reusables t w)\n 2. \\<not> r t < fst w \\<Longrightarrow>\n    adjacent (fst w, r t) (reusables t w)", "case False"], ["proof (state)\nthis:\n  \\<not> r t < fst w\n\ngoal (2 subgoals):\n 1. r t < fst w \\<Longrightarrow> adjacent (fst w, r t) (reusables t w)\n 2. \\<not> r t < fst w \\<Longrightarrow>\n    adjacent (fst w, r t) (reusables t w)", "with 1"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; l ?xa \\<le> fst w; 0 < fst w; well_shaped ?xa;\n   l ?xa \\<le> fst w; r ?xa \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> adjacent (fst w, r ?xa) (reusables ?xa w)\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; \\<not> l ?xa \\<le> fst w; 0 < fst w; well_shaped ?x;\n   l ?x \\<le> fst w; r ?x \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> adjacent (fst w, r ?x) (reusables ?x w)\n  0 < fst w\n  well_shaped t\n  l t \\<le> fst w\n  r t \\<le> snd w\n  \\<not> r t < fst w", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; l ?xa \\<le> fst w; 0 < fst w; well_shaped ?xa;\n   l ?xa \\<le> fst w; r ?xa \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> adjacent (fst w, r ?xa) (reusables ?xa w)\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; \\<not> l ?xa \\<le> fst w; 0 < fst w; well_shaped ?x;\n   l ?x \\<le> fst w; r ?x \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> adjacent (fst w, r ?x) (reusables ?x w)\n  0 < fst w\n  well_shaped t\n  l t \\<le> fst w\n  r t \\<le> snd w\n  \\<not> r t < fst w\n\ngoal (1 subgoal):\n 1. adjacent (fst w, r t) (reusables t w)", "proof (cases \"fst w = l t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x xa.\n                \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t;\n                 x = lchild t; xa = rchild t; l xa \\<le> fst w; 0 < fst w;\n                 well_shaped xa; l xa \\<le> fst w; r xa \\<le> snd w\\<rbrakk>\n                \\<Longrightarrow> adjacent (fst w, r xa) (reusables xa w);\n     \\<And>x xa.\n        \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; x = lchild t;\n         xa = rchild t; \\<not> l xa \\<le> fst w; 0 < fst w; well_shaped x;\n         l x \\<le> fst w; r x \\<le> snd w\\<rbrakk>\n        \\<Longrightarrow> adjacent (fst w, r x) (reusables x w);\n     0 < fst w; well_shaped t; l t \\<le> fst w; r t \\<le> snd w;\n     \\<not> r t < fst w; fst w = l t\\<rbrakk>\n    \\<Longrightarrow> adjacent (fst w, r t) (reusables t w)\n 2. \\<lbrakk>\\<And>x xa.\n                \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t;\n                 x = lchild t; xa = rchild t; l xa \\<le> fst w; 0 < fst w;\n                 well_shaped xa; l xa \\<le> fst w; r xa \\<le> snd w\\<rbrakk>\n                \\<Longrightarrow> adjacent (fst w, r xa) (reusables xa w);\n     \\<And>x xa.\n        \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; x = lchild t;\n         xa = rchild t; \\<not> l xa \\<le> fst w; 0 < fst w; well_shaped x;\n         l x \\<le> fst w; r x \\<le> snd w\\<rbrakk>\n        \\<Longrightarrow> adjacent (fst w, r x) (reusables x w);\n     0 < fst w; well_shaped t; l t \\<le> fst w; r t \\<le> snd w;\n     \\<not> r t < fst w; fst w \\<noteq> l t\\<rbrakk>\n    \\<Longrightarrow> adjacent (fst w, r t) (reusables t w)", "case False"], ["proof (state)\nthis:\n  fst w \\<noteq> l t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x xa.\n                \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t;\n                 x = lchild t; xa = rchild t; l xa \\<le> fst w; 0 < fst w;\n                 well_shaped xa; l xa \\<le> fst w; r xa \\<le> snd w\\<rbrakk>\n                \\<Longrightarrow> adjacent (fst w, r xa) (reusables xa w);\n     \\<And>x xa.\n        \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; x = lchild t;\n         xa = rchild t; \\<not> l xa \\<le> fst w; 0 < fst w; well_shaped x;\n         l x \\<le> fst w; r x \\<le> snd w\\<rbrakk>\n        \\<Longrightarrow> adjacent (fst w, r x) (reusables x w);\n     0 < fst w; well_shaped t; l t \\<le> fst w; r t \\<le> snd w;\n     \\<not> r t < fst w; fst w = l t\\<rbrakk>\n    \\<Longrightarrow> adjacent (fst w, r t) (reusables t w)\n 2. \\<lbrakk>\\<And>x xa.\n                \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t;\n                 x = lchild t; xa = rchild t; l xa \\<le> fst w; 0 < fst w;\n                 well_shaped xa; l xa \\<le> fst w; r xa \\<le> snd w\\<rbrakk>\n                \\<Longrightarrow> adjacent (fst w, r xa) (reusables xa w);\n     \\<And>x xa.\n        \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; x = lchild t;\n         xa = rchild t; \\<not> l xa \\<le> fst w; 0 < fst w; well_shaped x;\n         l x \\<le> fst w; r x \\<le> snd w\\<rbrakk>\n        \\<Longrightarrow> adjacent (fst w, r x) (reusables x w);\n     0 < fst w; well_shaped t; l t \\<le> fst w; r t \\<le> snd w;\n     \\<not> r t < fst w; fst w \\<noteq> l t\\<rbrakk>\n    \\<Longrightarrow> adjacent (fst w, r t) (reusables t w)", "then"], ["proof (chain)\npicking this:\n  fst w \\<noteq> l t", "show ?thesis"], ["proof (prove)\nusing this:\n  fst w \\<noteq> l t\n\ngoal (1 subgoal):\n 1. adjacent (fst w, r t) (reusables t w)", "proof (cases \"fst w \\<ge> l (rchild t)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>fst w \\<noteq> l t; l (rchild t) \\<le> fst w\\<rbrakk>\n    \\<Longrightarrow> adjacent (fst w, r t) (reusables t w)\n 2. \\<lbrakk>fst w \\<noteq> l t; \\<not> l (rchild t) \\<le> fst w\\<rbrakk>\n    \\<Longrightarrow> adjacent (fst w, r t) (reusables t w)", "case True"], ["proof (state)\nthis:\n  l (rchild t) \\<le> fst w\n\ngoal (2 subgoals):\n 1. \\<lbrakk>fst w \\<noteq> l t; l (rchild t) \\<le> fst w\\<rbrakk>\n    \\<Longrightarrow> adjacent (fst w, r t) (reusables t w)\n 2. \\<lbrakk>fst w \\<noteq> l t; \\<not> l (rchild t) \\<le> fst w\\<rbrakk>\n    \\<Longrightarrow> adjacent (fst w, r t) (reusables t w)", "with 1 \\<open>fst w \\<noteq> l t\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; l ?xa \\<le> fst w; 0 < fst w; well_shaped ?xa;\n   l ?xa \\<le> fst w; r ?xa \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> adjacent (fst w, r ?xa) (reusables ?xa w)\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; \\<not> l ?xa \\<le> fst w; 0 < fst w; well_shaped ?x;\n   l ?x \\<le> fst w; r ?x \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> adjacent (fst w, r ?x) (reusables ?x w)\n  0 < fst w\n  well_shaped t\n  l t \\<le> fst w\n  r t \\<le> snd w\n  fst w \\<noteq> l t\n  l (rchild t) \\<le> fst w", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; l ?xa \\<le> fst w; 0 < fst w; well_shaped ?xa;\n   l ?xa \\<le> fst w; r ?xa \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> adjacent (fst w, r ?xa) (reusables ?xa w)\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; \\<not> l ?xa \\<le> fst w; 0 < fst w; well_shaped ?x;\n   l ?x \\<le> fst w; r ?x \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> adjacent (fst w, r ?x) (reusables ?x w)\n  0 < fst w\n  well_shaped t\n  l t \\<le> fst w\n  r t \\<le> snd w\n  fst w \\<noteq> l t\n  l (rchild t) \\<le> fst w\n\ngoal (1 subgoal):\n 1. adjacent (fst w, r t) (reusables t w)", "by (subst reusables.simps) auto"], ["proof (state)\nthis:\n  adjacent (fst w, r t) (reusables t w)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fst w \\<noteq> l t; \\<not> l (rchild t) \\<le> fst w\\<rbrakk>\n    \\<Longrightarrow> adjacent (fst w, r t) (reusables t w)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>fst w \\<noteq> l t; \\<not> l (rchild t) \\<le> fst w\\<rbrakk>\n    \\<Longrightarrow> adjacent (fst w, r t) (reusables t w)", "case False"], ["proof (state)\nthis:\n  \\<not> l (rchild t) \\<le> fst w\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fst w \\<noteq> l t; \\<not> l (rchild t) \\<le> fst w\\<rbrakk>\n    \\<Longrightarrow> adjacent (fst w, r t) (reusables t w)", "with 1 \\<open>fst w \\<noteq> l t\\<close> \\<open>\\<not> fst w > r t\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; l ?xa \\<le> fst w; 0 < fst w; well_shaped ?xa;\n   l ?xa \\<le> fst w; r ?xa \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> adjacent (fst w, r ?xa) (reusables ?xa w)\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; \\<not> l ?xa \\<le> fst w; 0 < fst w; well_shaped ?x;\n   l ?x \\<le> fst w; r ?x \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> adjacent (fst w, r ?x) (reusables ?x w)\n  0 < fst w\n  well_shaped t\n  l t \\<le> fst w\n  r t \\<le> snd w\n  fst w \\<noteq> l t\n  \\<not> r t < fst w\n  \\<not> l (rchild t) \\<le> fst w", "obtain x xs where *: \"reusables (lchild t) w = x # xs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; l ?xa \\<le> fst w; 0 < fst w; well_shaped ?xa;\n   l ?xa \\<le> fst w; r ?xa \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> adjacent (fst w, r ?xa) (reusables ?xa w)\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; \\<not> l ?xa \\<le> fst w; 0 < fst w; well_shaped ?x;\n   l ?x \\<le> fst w; r ?x \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> adjacent (fst w, r ?x) (reusables ?x w)\n  0 < fst w\n  well_shaped t\n  l t \\<le> fst w\n  r t \\<le> snd w\n  fst w \\<noteq> l t\n  \\<not> r t < fst w\n  \\<not> l (rchild t) \\<le> fst w\n\ngoal (1 subgoal):\n 1. (\\<And>x xs.\n        reusables (lchild t) w = x # xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"reusables (lchild t) w\") (auto simp: reusables_lchild_neq_Nil_under_some_conditions)"], ["proof (state)\nthis:\n  reusables (lchild t) w = x # xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fst w \\<noteq> l t; \\<not> l (rchild t) \\<le> fst w\\<rbrakk>\n    \\<Longrightarrow> adjacent (fst w, r t) (reusables t w)", "with 1(2-6) \\<open>fst w \\<noteq> l t\\<close> \\<open>\\<not> fst w > r t\\<close> \\<open>\\<not> l (rchild t) \\<le> fst w\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; \\<not> l ?xa \\<le> fst w; 0 < fst w; well_shaped ?x;\n   l ?x \\<le> fst w; r ?x \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> adjacent (fst w, r ?x) (reusables ?x w)\n  0 < fst w\n  well_shaped t\n  l t \\<le> fst w\n  r t \\<le> snd w\n  fst w \\<noteq> l t\n  \\<not> r t < fst w\n  \\<not> l (rchild t) \\<le> fst w\n  reusables (lchild t) w = x # xs", "have \"adjacent (fst w, r (lchild t)) (x # xs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; \\<not> l ?xa \\<le> fst w; 0 < fst w; well_shaped ?x;\n   l ?x \\<le> fst w; r ?x \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> adjacent (fst w, r ?x) (reusables ?x w)\n  0 < fst w\n  well_shaped t\n  l t \\<le> fst w\n  r t \\<le> snd w\n  fst w \\<noteq> l t\n  \\<not> r t < fst w\n  \\<not> l (rchild t) \\<le> fst w\n  reusables (lchild t) w = x # xs\n\ngoal (1 subgoal):\n 1. adjacent (fst w, r (lchild t)) (x # xs)", "by (simp add: adjacent_Cons r_lchild_le_r dual_order.trans)"], ["proof (state)\nthis:\n  adjacent (fst w, r (lchild t)) (x # xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fst w \\<noteq> l t; \\<not> l (rchild t) \\<le> fst w\\<rbrakk>\n    \\<Longrightarrow> adjacent (fst w, r t) (reusables t w)", "with 1 \\<open>fst w \\<noteq> l t\\<close> \\<open>\\<not> fst w > r t\\<close> *"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; l ?xa \\<le> fst w; 0 < fst w; well_shaped ?xa;\n   l ?xa \\<le> fst w; r ?xa \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> adjacent (fst w, r ?xa) (reusables ?xa w)\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; \\<not> l ?xa \\<le> fst w; 0 < fst w; well_shaped ?x;\n   l ?x \\<le> fst w; r ?x \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> adjacent (fst w, r ?x) (reusables ?x w)\n  0 < fst w\n  well_shaped t\n  l t \\<le> fst w\n  r t \\<le> snd w\n  fst w \\<noteq> l t\n  \\<not> r t < fst w\n  reusables (lchild t) w = x # xs\n  adjacent (fst w, r (lchild t)) (x # xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; l ?xa \\<le> fst w; 0 < fst w; well_shaped ?xa;\n   l ?xa \\<le> fst w; r ?xa \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> adjacent (fst w, r ?xa) (reusables ?xa w)\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; \\<not> l ?xa \\<le> fst w; 0 < fst w; well_shaped ?x;\n   l ?x \\<le> fst w; r ?x \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> adjacent (fst w, r ?x) (reusables ?x w)\n  0 < fst w\n  well_shaped t\n  l t \\<le> fst w\n  r t \\<le> snd w\n  fst w \\<noteq> l t\n  \\<not> r t < fst w\n  reusables (lchild t) w = x # xs\n  adjacent (fst w, r (lchild t)) (x # xs)\n\ngoal (1 subgoal):\n 1. adjacent (fst w, r t) (reusables t w)", "by (subst reusables.simps)\n            (auto simp add: Let_def adjacent_Cons r_lchild_eq_l_rchild_if_well_shaped)"], ["proof (state)\nthis:\n  adjacent (fst w, r t) (reusables t w)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  adjacent (fst w, r t) (reusables t w)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa.\n                \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t;\n                 x = lchild t; xa = rchild t; l xa \\<le> fst w; 0 < fst w;\n                 well_shaped xa; l xa \\<le> fst w; r xa \\<le> snd w\\<rbrakk>\n                \\<Longrightarrow> adjacent (fst w, r xa) (reusables xa w);\n     \\<And>x xa.\n        \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; x = lchild t;\n         xa = rchild t; \\<not> l xa \\<le> fst w; 0 < fst w; well_shaped x;\n         l x \\<le> fst w; r x \\<le> snd w\\<rbrakk>\n        \\<Longrightarrow> adjacent (fst w, r x) (reusables x w);\n     0 < fst w; well_shaped t; l t \\<le> fst w; r t \\<le> snd w;\n     \\<not> r t < fst w; fst w = l t\\<rbrakk>\n    \\<Longrightarrow> adjacent (fst w, r t) (reusables t w)", "qed (auto simp: reusables.simps intro!: adjacent_singleton)"], ["proof (state)\nthis:\n  adjacent (fst w, r t) (reusables t w)\n\ngoal (1 subgoal):\n 1. r t < fst w \\<Longrightarrow> adjacent (fst w, r t) (reusables t w)", "qed (auto simp: reusables.simps)"], ["proof (state)\nthis:\n  adjacent (fst w, r t) (reusables t w)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_rchild_if_well_valued0: \"\\<lbrakk>well_shaped t; well_valued0 t\\<rbrakk> \\<Longrightarrow> valid (rchild t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>well_shaped t; local.well_valued0 t\\<rbrakk>\n    \\<Longrightarrow> local.valid (rchild t)", "by (metis tree.exhaust_sel tree.sel(9) valid_def well_shaped_rchild well_valued0.simps(2))"], ["", "lemma valid_reusables_under_some_conditions:\n  \"\\<lbrakk>0 < fst w; well_valued0 t; well_shaped t; l t < fst w; r t \\<le> snd w\\<rbrakk> \\<Longrightarrow>\n    \\<forall>t' \\<in> set (reusables t w). valid t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < fst w; local.well_valued0 t; well_shaped t; l t < fst w;\n     r t \\<le> snd w\\<rbrakk>\n    \\<Longrightarrow> Ball (set (reusables t w)) local.valid", "proof (induction t w rule: reusables.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t w.\n       \\<lbrakk>\\<And>x xa.\n                   \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t;\n                    x = lchild t; xa = rchild t; l xa \\<le> fst w;\n                    0 < fst w; local.well_valued0 xa; well_shaped xa;\n                    l xa < fst w; r xa \\<le> snd w\\<rbrakk>\n                   \\<Longrightarrow> Ball (set (reusables xa w))\nlocal.valid;\n        \\<And>x xa.\n           \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; x = lchild t;\n            xa = rchild t; \\<not> l xa \\<le> fst w; 0 < fst w;\n            local.well_valued0 x; well_shaped x; l x < fst w;\n            r x \\<le> snd w\\<rbrakk>\n           \\<Longrightarrow> Ball (set (reusables x w)) local.valid;\n        0 < fst w; local.well_valued0 t; well_shaped t; l t < fst w;\n        r t \\<le> snd w\\<rbrakk>\n       \\<Longrightarrow> Ball (set (reusables t w)) local.valid", "case (1 t w)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; l ?xa \\<le> fst w; 0 < fst w; local.well_valued0 ?xa;\n   well_shaped ?xa; l ?xa < fst w; r ?xa \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> Ball (set (reusables ?xa w)) local.valid\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; \\<not> l ?xa \\<le> fst w; 0 < fst w;\n   local.well_valued0 ?x; well_shaped ?x; l ?x < fst w;\n   r ?x \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> Ball (set (reusables ?x w)) local.valid\n  0 < fst w\n  local.well_valued0 t\n  well_shaped t\n  l t < fst w\n  r t \\<le> snd w\n\ngoal (1 subgoal):\n 1. \\<And>t w.\n       \\<lbrakk>\\<And>x xa.\n                   \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t;\n                    x = lchild t; xa = rchild t; l xa \\<le> fst w;\n                    0 < fst w; local.well_valued0 xa; well_shaped xa;\n                    l xa < fst w; r xa \\<le> snd w\\<rbrakk>\n                   \\<Longrightarrow> Ball (set (reusables xa w))\nlocal.valid;\n        \\<And>x xa.\n           \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; x = lchild t;\n            xa = rchild t; \\<not> l xa \\<le> fst w; 0 < fst w;\n            local.well_valued0 x; well_shaped x; l x < fst w;\n            r x \\<le> snd w\\<rbrakk>\n           \\<Longrightarrow> Ball (set (reusables x w)) local.valid;\n        0 < fst w; local.well_valued0 t; well_shaped t; l t < fst w;\n        r t \\<le> snd w\\<rbrakk>\n       \\<Longrightarrow> Ball (set (reusables t w)) local.valid", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (set (reusables t w)) local.valid", "proof (cases \"fst w > r t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. r t < fst w \\<Longrightarrow> Ball (set (reusables t w)) local.valid\n 2. \\<not> r t < fst w \\<Longrightarrow>\n    Ball (set (reusables t w)) local.valid", "case False"], ["proof (state)\nthis:\n  \\<not> r t < fst w\n\ngoal (2 subgoals):\n 1. r t < fst w \\<Longrightarrow> Ball (set (reusables t w)) local.valid\n 2. \\<not> r t < fst w \\<Longrightarrow>\n    Ball (set (reusables t w)) local.valid", "with 1"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; l ?xa \\<le> fst w; 0 < fst w; local.well_valued0 ?xa;\n   well_shaped ?xa; l ?xa < fst w; r ?xa \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> Ball (set (reusables ?xa w)) local.valid\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; \\<not> l ?xa \\<le> fst w; 0 < fst w;\n   local.well_valued0 ?x; well_shaped ?x; l ?x < fst w;\n   r ?x \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> Ball (set (reusables ?x w)) local.valid\n  0 < fst w\n  local.well_valued0 t\n  well_shaped t\n  l t < fst w\n  r t \\<le> snd w\n  \\<not> r t < fst w", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; l ?xa \\<le> fst w; 0 < fst w; local.well_valued0 ?xa;\n   well_shaped ?xa; l ?xa < fst w; r ?xa \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> Ball (set (reusables ?xa w)) local.valid\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; \\<not> l ?xa \\<le> fst w; 0 < fst w;\n   local.well_valued0 ?x; well_shaped ?x; l ?x < fst w;\n   r ?x \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> Ball (set (reusables ?x w)) local.valid\n  0 < fst w\n  local.well_valued0 t\n  well_shaped t\n  l t < fst w\n  r t \\<le> snd w\n  \\<not> r t < fst w\n\ngoal (1 subgoal):\n 1. Ball (set (reusables t w)) local.valid", "proof (cases \"fst w = l t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x xa.\n                \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t;\n                 x = lchild t; xa = rchild t; l xa \\<le> fst w; 0 < fst w;\n                 local.well_valued0 xa; well_shaped xa; l xa < fst w;\n                 r xa \\<le> snd w\\<rbrakk>\n                \\<Longrightarrow> Ball (set (reusables xa w)) local.valid;\n     \\<And>x xa.\n        \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; x = lchild t;\n         xa = rchild t; \\<not> l xa \\<le> fst w; 0 < fst w;\n         local.well_valued0 x; well_shaped x; l x < fst w;\n         r x \\<le> snd w\\<rbrakk>\n        \\<Longrightarrow> Ball (set (reusables x w)) local.valid;\n     0 < fst w; local.well_valued0 t; well_shaped t; l t < fst w;\n     r t \\<le> snd w; \\<not> r t < fst w; fst w = l t\\<rbrakk>\n    \\<Longrightarrow> Ball (set (reusables t w)) local.valid\n 2. \\<lbrakk>\\<And>x xa.\n                \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t;\n                 x = lchild t; xa = rchild t; l xa \\<le> fst w; 0 < fst w;\n                 local.well_valued0 xa; well_shaped xa; l xa < fst w;\n                 r xa \\<le> snd w\\<rbrakk>\n                \\<Longrightarrow> Ball (set (reusables xa w)) local.valid;\n     \\<And>x xa.\n        \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; x = lchild t;\n         xa = rchild t; \\<not> l xa \\<le> fst w; 0 < fst w;\n         local.well_valued0 x; well_shaped x; l x < fst w;\n         r x \\<le> snd w\\<rbrakk>\n        \\<Longrightarrow> Ball (set (reusables x w)) local.valid;\n     0 < fst w; local.well_valued0 t; well_shaped t; l t < fst w;\n     r t \\<le> snd w; \\<not> r t < fst w; fst w \\<noteq> l t\\<rbrakk>\n    \\<Longrightarrow> Ball (set (reusables t w)) local.valid", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x xa.\n                \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t;\n                 x = lchild t; xa = rchild t; l xa \\<le> fst w; 0 < fst w;\n                 local.well_valued0 xa; well_shaped xa; l xa < fst w;\n                 r xa \\<le> snd w\\<rbrakk>\n                \\<Longrightarrow> Ball (set (reusables xa w)) local.valid;\n     \\<And>x xa.\n        \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; x = lchild t;\n         xa = rchild t; \\<not> l xa \\<le> fst w; 0 < fst w;\n         local.well_valued0 x; well_shaped x; l x < fst w;\n         r x \\<le> snd w\\<rbrakk>\n        \\<Longrightarrow> Ball (set (reusables x w)) local.valid;\n     0 < fst w; local.well_valued0 t; well_shaped t; l t < fst w;\n     r t \\<le> snd w; \\<not> r t < fst w; fst w = l t\\<rbrakk>\n    \\<Longrightarrow> Ball (set (reusables t w)) local.valid\n 2. \\<lbrakk>\\<And>x xa.\n                \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t;\n                 x = lchild t; xa = rchild t; l xa \\<le> fst w; 0 < fst w;\n                 local.well_valued0 xa; well_shaped xa; l xa < fst w;\n                 r xa \\<le> snd w\\<rbrakk>\n                \\<Longrightarrow> Ball (set (reusables xa w)) local.valid;\n     \\<And>x xa.\n        \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; x = lchild t;\n         xa = rchild t; \\<not> l xa \\<le> fst w; 0 < fst w;\n         local.well_valued0 x; well_shaped x; l x < fst w;\n         r x \\<le> snd w\\<rbrakk>\n        \\<Longrightarrow> Ball (set (reusables x w)) local.valid;\n     0 < fst w; local.well_valued0 t; well_shaped t; l t < fst w;\n     r t \\<le> snd w; \\<not> r t < fst w; fst w \\<noteq> l t\\<rbrakk>\n    \\<Longrightarrow> Ball (set (reusables t w)) local.valid", "case False"], ["proof (state)\nthis:\n  fst w \\<noteq> l t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x xa.\n                \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t;\n                 x = lchild t; xa = rchild t; l xa \\<le> fst w; 0 < fst w;\n                 local.well_valued0 xa; well_shaped xa; l xa < fst w;\n                 r xa \\<le> snd w\\<rbrakk>\n                \\<Longrightarrow> Ball (set (reusables xa w)) local.valid;\n     \\<And>x xa.\n        \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; x = lchild t;\n         xa = rchild t; \\<not> l xa \\<le> fst w; 0 < fst w;\n         local.well_valued0 x; well_shaped x; l x < fst w;\n         r x \\<le> snd w\\<rbrakk>\n        \\<Longrightarrow> Ball (set (reusables x w)) local.valid;\n     0 < fst w; local.well_valued0 t; well_shaped t; l t < fst w;\n     r t \\<le> snd w; \\<not> r t < fst w; fst w = l t\\<rbrakk>\n    \\<Longrightarrow> Ball (set (reusables t w)) local.valid\n 2. \\<lbrakk>\\<And>x xa.\n                \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t;\n                 x = lchild t; xa = rchild t; l xa \\<le> fst w; 0 < fst w;\n                 local.well_valued0 xa; well_shaped xa; l xa < fst w;\n                 r xa \\<le> snd w\\<rbrakk>\n                \\<Longrightarrow> Ball (set (reusables xa w)) local.valid;\n     \\<And>x xa.\n        \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; x = lchild t;\n         xa = rchild t; \\<not> l xa \\<le> fst w; 0 < fst w;\n         local.well_valued0 x; well_shaped x; l x < fst w;\n         r x \\<le> snd w\\<rbrakk>\n        \\<Longrightarrow> Ball (set (reusables x w)) local.valid;\n     0 < fst w; local.well_valued0 t; well_shaped t; l t < fst w;\n     r t \\<le> snd w; \\<not> r t < fst w; fst w \\<noteq> l t\\<rbrakk>\n    \\<Longrightarrow> Ball (set (reusables t w)) local.valid", "then"], ["proof (chain)\npicking this:\n  fst w \\<noteq> l t", "show ?thesis"], ["proof (prove)\nusing this:\n  fst w \\<noteq> l t\n\ngoal (1 subgoal):\n 1. Ball (set (reusables t w)) local.valid", "proof (cases \"fst w \\<ge> l (rchild t)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>fst w \\<noteq> l t; l (rchild t) \\<le> fst w\\<rbrakk>\n    \\<Longrightarrow> Ball (set (reusables t w)) local.valid\n 2. \\<lbrakk>fst w \\<noteq> l t; \\<not> l (rchild t) \\<le> fst w\\<rbrakk>\n    \\<Longrightarrow> Ball (set (reusables t w)) local.valid", "case True"], ["proof (state)\nthis:\n  l (rchild t) \\<le> fst w\n\ngoal (2 subgoals):\n 1. \\<lbrakk>fst w \\<noteq> l t; l (rchild t) \\<le> fst w\\<rbrakk>\n    \\<Longrightarrow> Ball (set (reusables t w)) local.valid\n 2. \\<lbrakk>fst w \\<noteq> l t; \\<not> l (rchild t) \\<le> fst w\\<rbrakk>\n    \\<Longrightarrow> Ball (set (reusables t w)) local.valid", "with 1 \\<open>fst w \\<noteq> l t\\<close> \\<open>\\<not> fst w > r t\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; l ?xa \\<le> fst w; 0 < fst w; local.well_valued0 ?xa;\n   well_shaped ?xa; l ?xa < fst w; r ?xa \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> Ball (set (reusables ?xa w)) local.valid\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; \\<not> l ?xa \\<le> fst w; 0 < fst w;\n   local.well_valued0 ?x; well_shaped ?x; l ?x < fst w;\n   r ?x \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> Ball (set (reusables ?x w)) local.valid\n  0 < fst w\n  local.well_valued0 t\n  well_shaped t\n  l t < fst w\n  r t \\<le> snd w\n  fst w \\<noteq> l t\n  \\<not> r t < fst w\n  l (rchild t) \\<le> fst w", "have *: \"Ball (set (reusables (rchild t) w)) valid\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; l ?xa \\<le> fst w; 0 < fst w; local.well_valued0 ?xa;\n   well_shaped ?xa; l ?xa < fst w; r ?xa \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> Ball (set (reusables ?xa w)) local.valid\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; \\<not> l ?xa \\<le> fst w; 0 < fst w;\n   local.well_valued0 ?x; well_shaped ?x; l ?x < fst w;\n   r ?x \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> Ball (set (reusables ?x w)) local.valid\n  0 < fst w\n  local.well_valued0 t\n  well_shaped t\n  l t < fst w\n  r t \\<le> snd w\n  fst w \\<noteq> l t\n  \\<not> r t < fst w\n  l (rchild t) \\<le> fst w\n\ngoal (1 subgoal):\n 1. Ball (set (reusables (rchild t) w)) local.valid", "by (metis (no_types, lifting) ball_empty dual_order.strict_trans2 leI le_neq_implies_less list.set(1) r_rchild_eq_r_if_well_shaped reusables.simps set_ConsD valid_rchild_if_well_valued0 well_shaped_rchild well_valued0_rchild_if_well_valued0)"], ["proof (state)\nthis:\n  Ball (set (reusables (rchild t) w)) local.valid\n\ngoal (2 subgoals):\n 1. \\<lbrakk>fst w \\<noteq> l t; l (rchild t) \\<le> fst w\\<rbrakk>\n    \\<Longrightarrow> Ball (set (reusables t w)) local.valid\n 2. \\<lbrakk>fst w \\<noteq> l t; \\<not> l (rchild t) \\<le> fst w\\<rbrakk>\n    \\<Longrightarrow> Ball (set (reusables t w)) local.valid", "from 1 \\<open>fst w \\<noteq> l t\\<close> \\<open>\\<not> fst w > r t\\<close> True"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; l ?xa \\<le> fst w; 0 < fst w; local.well_valued0 ?xa;\n   well_shaped ?xa; l ?xa < fst w; r ?xa \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> Ball (set (reusables ?xa w)) local.valid\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; \\<not> l ?xa \\<le> fst w; 0 < fst w;\n   local.well_valued0 ?x; well_shaped ?x; l ?x < fst w;\n   r ?x \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> Ball (set (reusables ?x w)) local.valid\n  0 < fst w\n  local.well_valued0 t\n  well_shaped t\n  l t < fst w\n  r t \\<le> snd w\n  fst w \\<noteq> l t\n  \\<not> r t < fst w\n  l (rchild t) \\<le> fst w", "have \"reusables t w = reusables (rchild t) w\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; l ?xa \\<le> fst w; 0 < fst w; local.well_valued0 ?xa;\n   well_shaped ?xa; l ?xa < fst w; r ?xa \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> Ball (set (reusables ?xa w)) local.valid\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; \\<not> l ?xa \\<le> fst w; 0 < fst w;\n   local.well_valued0 ?x; well_shaped ?x; l ?x < fst w;\n   r ?x \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> Ball (set (reusables ?x w)) local.valid\n  0 < fst w\n  local.well_valued0 t\n  well_shaped t\n  l t < fst w\n  r t \\<le> snd w\n  fst w \\<noteq> l t\n  \\<not> r t < fst w\n  l (rchild t) \\<le> fst w\n\ngoal (1 subgoal):\n 1. reusables t w = reusables (rchild t) w", "by (subst reusables.simps)\n            simp"], ["proof (state)\nthis:\n  reusables t w = reusables (rchild t) w\n\ngoal (2 subgoals):\n 1. \\<lbrakk>fst w \\<noteq> l t; l (rchild t) \\<le> fst w\\<rbrakk>\n    \\<Longrightarrow> Ball (set (reusables t w)) local.valid\n 2. \\<lbrakk>fst w \\<noteq> l t; \\<not> l (rchild t) \\<le> fst w\\<rbrakk>\n    \\<Longrightarrow> Ball (set (reusables t w)) local.valid", "with 1 *"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; l ?xa \\<le> fst w; 0 < fst w; local.well_valued0 ?xa;\n   well_shaped ?xa; l ?xa < fst w; r ?xa \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> Ball (set (reusables ?xa w)) local.valid\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; \\<not> l ?xa \\<le> fst w; 0 < fst w;\n   local.well_valued0 ?x; well_shaped ?x; l ?x < fst w;\n   r ?x \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> Ball (set (reusables ?x w)) local.valid\n  0 < fst w\n  local.well_valued0 t\n  well_shaped t\n  l t < fst w\n  r t \\<le> snd w\n  Ball (set (reusables (rchild t) w)) local.valid\n  reusables t w = reusables (rchild t) w", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; l ?xa \\<le> fst w; 0 < fst w; local.well_valued0 ?xa;\n   well_shaped ?xa; l ?xa < fst w; r ?xa \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> Ball (set (reusables ?xa w)) local.valid\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; \\<not> l ?xa \\<le> fst w; 0 < fst w;\n   local.well_valued0 ?x; well_shaped ?x; l ?x < fst w;\n   r ?x \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> Ball (set (reusables ?x w)) local.valid\n  0 < fst w\n  local.well_valued0 t\n  well_shaped t\n  l t < fst w\n  r t \\<le> snd w\n  Ball (set (reusables (rchild t) w)) local.valid\n  reusables t w = reusables (rchild t) w\n\ngoal (1 subgoal):\n 1. Ball (set (reusables t w)) local.valid", "by simp"], ["proof (state)\nthis:\n  Ball (set (reusables t w)) local.valid\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fst w \\<noteq> l t; \\<not> l (rchild t) \\<le> fst w\\<rbrakk>\n    \\<Longrightarrow> Ball (set (reusables t w)) local.valid", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>fst w \\<noteq> l t; \\<not> l (rchild t) \\<le> fst w\\<rbrakk>\n    \\<Longrightarrow> Ball (set (reusables t w)) local.valid", "case False"], ["proof (state)\nthis:\n  \\<not> l (rchild t) \\<le> fst w\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fst w \\<noteq> l t; \\<not> l (rchild t) \\<le> fst w\\<rbrakk>\n    \\<Longrightarrow> Ball (set (reusables t w)) local.valid", "with 1 \\<open>fst w \\<noteq> l t\\<close> \\<open>\\<not> fst w > r t\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; l ?xa \\<le> fst w; 0 < fst w; local.well_valued0 ?xa;\n   well_shaped ?xa; l ?xa < fst w; r ?xa \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> Ball (set (reusables ?xa w)) local.valid\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; \\<not> l ?xa \\<le> fst w; 0 < fst w;\n   local.well_valued0 ?x; well_shaped ?x; l ?x < fst w;\n   r ?x \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> Ball (set (reusables ?x w)) local.valid\n  0 < fst w\n  local.well_valued0 t\n  well_shaped t\n  l t < fst w\n  r t \\<le> snd w\n  fst w \\<noteq> l t\n  \\<not> r t < fst w\n  \\<not> l (rchild t) \\<le> fst w", "have *: \"Ball (set (reusables (lchild t) w)) valid\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; l ?xa \\<le> fst w; 0 < fst w; local.well_valued0 ?xa;\n   well_shaped ?xa; l ?xa < fst w; r ?xa \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> Ball (set (reusables ?xa w)) local.valid\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; \\<not> l ?xa \\<le> fst w; 0 < fst w;\n   local.well_valued0 ?x; well_shaped ?x; l ?x < fst w;\n   r ?x \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> Ball (set (reusables ?x w)) local.valid\n  0 < fst w\n  local.well_valued0 t\n  well_shaped t\n  l t < fst w\n  r t \\<le> snd w\n  fst w \\<noteq> l t\n  \\<not> r t < fst w\n  \\<not> l (rchild t) \\<le> fst w\n\ngoal (1 subgoal):\n 1. Ball (set (reusables (lchild t) w)) local.valid", "by (metis dual_order.strict_trans2 l_lchild_eq_l_if_well_shaped leI order_trans r_lchild_le_r well_shaped_lchild well_valued0_lchild_if_well_valued0)"], ["proof (state)\nthis:\n  Ball (set (reusables (lchild t) w)) local.valid\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fst w \\<noteq> l t; \\<not> l (rchild t) \\<le> fst w\\<rbrakk>\n    \\<Longrightarrow> Ball (set (reusables t w)) local.valid", "with 1"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; l ?xa \\<le> fst w; 0 < fst w; local.well_valued0 ?xa;\n   well_shaped ?xa; l ?xa < fst w; r ?xa \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> Ball (set (reusables ?xa w)) local.valid\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; \\<not> l ?xa \\<le> fst w; 0 < fst w;\n   local.well_valued0 ?x; well_shaped ?x; l ?x < fst w;\n   r ?x \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> Ball (set (reusables ?x w)) local.valid\n  0 < fst w\n  local.well_valued0 t\n  well_shaped t\n  l t < fst w\n  r t \\<le> snd w\n  Ball (set (reusables (lchild t) w)) local.valid", "have valid_rchild: \"valid (rchild t)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; l ?xa \\<le> fst w; 0 < fst w; local.well_valued0 ?xa;\n   well_shaped ?xa; l ?xa < fst w; r ?xa \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> Ball (set (reusables ?xa w)) local.valid\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; \\<not> l ?xa \\<le> fst w; 0 < fst w;\n   local.well_valued0 ?x; well_shaped ?x; l ?x < fst w;\n   r ?x \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> Ball (set (reusables ?x w)) local.valid\n  0 < fst w\n  local.well_valued0 t\n  well_shaped t\n  l t < fst w\n  r t \\<le> snd w\n  Ball (set (reusables (lchild t) w)) local.valid\n\ngoal (1 subgoal):\n 1. local.valid (rchild t)", "by (simp add: valid_rchild_if_well_valued0)"], ["proof (state)\nthis:\n  local.valid (rchild t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fst w \\<noteq> l t; \\<not> l (rchild t) \\<le> fst w\\<rbrakk>\n    \\<Longrightarrow> Ball (set (reusables t w)) local.valid", "with 1 \\<open>fst w \\<noteq> l t\\<close> \\<open>\\<not> fst w > r t\\<close> False"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; l ?xa \\<le> fst w; 0 < fst w; local.well_valued0 ?xa;\n   well_shaped ?xa; l ?xa < fst w; r ?xa \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> Ball (set (reusables ?xa w)) local.valid\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; \\<not> l ?xa \\<le> fst w; 0 < fst w;\n   local.well_valued0 ?x; well_shaped ?x; l ?x < fst w;\n   r ?x \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> Ball (set (reusables ?x w)) local.valid\n  0 < fst w\n  local.well_valued0 t\n  well_shaped t\n  l t < fst w\n  r t \\<le> snd w\n  fst w \\<noteq> l t\n  \\<not> r t < fst w\n  \\<not> l (rchild t) \\<le> fst w\n  local.valid (rchild t)", "have \"reusables t w = rchild t # reusables (lchild t) w\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; l ?xa \\<le> fst w; 0 < fst w; local.well_valued0 ?xa;\n   well_shaped ?xa; l ?xa < fst w; r ?xa \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> Ball (set (reusables ?xa w)) local.valid\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; \\<not> l ?xa \\<le> fst w; 0 < fst w;\n   local.well_valued0 ?x; well_shaped ?x; l ?x < fst w;\n   r ?x \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> Ball (set (reusables ?x w)) local.valid\n  0 < fst w\n  local.well_valued0 t\n  well_shaped t\n  l t < fst w\n  r t \\<le> snd w\n  fst w \\<noteq> l t\n  \\<not> r t < fst w\n  \\<not> l (rchild t) \\<le> fst w\n  local.valid (rchild t)\n\ngoal (1 subgoal):\n 1. reusables t w = rchild t # reusables (lchild t) w", "by (subst reusables.simps) presburger"], ["proof (state)\nthis:\n  reusables t w = rchild t # reusables (lchild t) w\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fst w \\<noteq> l t; \\<not> l (rchild t) \\<le> fst w\\<rbrakk>\n    \\<Longrightarrow> Ball (set (reusables t w)) local.valid", "with 1 \\<open>fst w \\<noteq> l t\\<close> \\<open>\\<not> fst w > r t\\<close> False * valid_rchild"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; l ?xa \\<le> fst w; 0 < fst w; local.well_valued0 ?xa;\n   well_shaped ?xa; l ?xa < fst w; r ?xa \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> Ball (set (reusables ?xa w)) local.valid\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; \\<not> l ?xa \\<le> fst w; 0 < fst w;\n   local.well_valued0 ?x; well_shaped ?x; l ?x < fst w;\n   r ?x \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> Ball (set (reusables ?x w)) local.valid\n  0 < fst w\n  local.well_valued0 t\n  well_shaped t\n  l t < fst w\n  r t \\<le> snd w\n  fst w \\<noteq> l t\n  \\<not> r t < fst w\n  \\<not> l (rchild t) \\<le> fst w\n  Ball (set (reusables (lchild t) w)) local.valid\n  local.valid (rchild t)\n  reusables t w = rchild t # reusables (lchild t) w", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; l ?xa \\<le> fst w; 0 < fst w; local.well_valued0 ?xa;\n   well_shaped ?xa; l ?xa < fst w; r ?xa \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> Ball (set (reusables ?xa w)) local.valid\n  \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; ?x = lchild t;\n   ?xa = rchild t; \\<not> l ?xa \\<le> fst w; 0 < fst w;\n   local.well_valued0 ?x; well_shaped ?x; l ?x < fst w;\n   r ?x \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> Ball (set (reusables ?x w)) local.valid\n  0 < fst w\n  local.well_valued0 t\n  well_shaped t\n  l t < fst w\n  r t \\<le> snd w\n  fst w \\<noteq> l t\n  \\<not> r t < fst w\n  \\<not> l (rchild t) \\<le> fst w\n  Ball (set (reusables (lchild t) w)) local.valid\n  local.valid (rchild t)\n  reusables t w = rchild t # reusables (lchild t) w\n\ngoal (1 subgoal):\n 1. Ball (set (reusables t w)) local.valid", "by (metis set_ConsD)"], ["proof (state)\nthis:\n  Ball (set (reusables t w)) local.valid\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Ball (set (reusables t w)) local.valid\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa.\n                \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t;\n                 x = lchild t; xa = rchild t; l xa \\<le> fst w; 0 < fst w;\n                 local.well_valued0 xa; well_shaped xa; l xa < fst w;\n                 r xa \\<le> snd w\\<rbrakk>\n                \\<Longrightarrow> Ball (set (reusables xa w)) local.valid;\n     \\<And>x xa.\n        \\<lbrakk>\\<not> r t < fst w; fst w \\<noteq> l t; x = lchild t;\n         xa = rchild t; \\<not> l xa \\<le> fst w; 0 < fst w;\n         local.well_valued0 x; well_shaped x; l x < fst w;\n         r x \\<le> snd w\\<rbrakk>\n        \\<Longrightarrow> Ball (set (reusables x w)) local.valid;\n     0 < fst w; local.well_valued0 t; well_shaped t; l t < fst w;\n     r t \\<le> snd w; \\<not> r t < fst w; fst w = l t\\<rbrakk>\n    \\<Longrightarrow> Ball (set (reusables t w)) local.valid", "qed (auto simp: reusables.simps)"], ["proof (state)\nthis:\n  Ball (set (reusables t w)) local.valid\n\ngoal (1 subgoal):\n 1. r t < fst w \\<Longrightarrow> Ball (set (reusables t w)) local.valid", "qed (auto simp: reusables.simps)"], ["proof (state)\nthis:\n  Ball (set (reusables t w)) local.valid\n\ngoal:\nNo subgoals!", "qed"], ["", "(* fact (a) part 2 *)"], ["", "lemma valid_reusables:\n  assumes \"0 < fst w\" \"valid t\" \"l t \\<le> fst w\" \"r t \\<le> snd w\"\n  shows \"\\<forall>t' \\<in> set (reusables t w). valid t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (set (reusables t w)) local.valid", "proof (cases \"l t < fst w\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l t < fst w \\<Longrightarrow> Ball (set (reusables t w)) local.valid\n 2. \\<not> l t < fst w \\<Longrightarrow>\n    Ball (set (reusables t w)) local.valid", "case True"], ["proof (state)\nthis:\n  l t < fst w\n\ngoal (2 subgoals):\n 1. l t < fst w \\<Longrightarrow> Ball (set (reusables t w)) local.valid\n 2. \\<not> l t < fst w \\<Longrightarrow>\n    Ball (set (reusables t w)) local.valid", "with assms"], ["proof (chain)\npicking this:\n  0 < fst w\n  local.valid t\n  l t \\<le> fst w\n  r t \\<le> snd w\n  l t < fst w", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < fst w\n  local.valid t\n  l t \\<le> fst w\n  r t \\<le> snd w\n  l t < fst w\n\ngoal (1 subgoal):\n 1. Ball (set (reusables t w)) local.valid", "using valid_def valid_reusables_under_some_conditions"], ["proof (prove)\nusing this:\n  0 < fst w\n  local.valid t\n  l t \\<le> fst w\n  r t \\<le> snd w\n  l t < fst w\n  local.valid ?t =\n  (well_shaped ?t \\<and>\n   local.well_valued0 ?t \\<and>\n   (?t \\<noteq> Leaf \\<longrightarrow> val ?t \\<noteq> None))\n  \\<lbrakk>0 < fst ?w; local.well_valued0 ?t; well_shaped ?t; l ?t < fst ?w;\n   r ?t \\<le> snd ?w\\<rbrakk>\n  \\<Longrightarrow> Ball (set (reusables ?t ?w)) local.valid\n\ngoal (1 subgoal):\n 1. Ball (set (reusables t w)) local.valid", "by blast"], ["proof (state)\nthis:\n  Ball (set (reusables t w)) local.valid\n\ngoal (1 subgoal):\n 1. \\<not> l t < fst w \\<Longrightarrow>\n    Ball (set (reusables t w)) local.valid", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> l t < fst w \\<Longrightarrow>\n    Ball (set (reusables t w)) local.valid", "case False"], ["proof (state)\nthis:\n  \\<not> l t < fst w\n\ngoal (1 subgoal):\n 1. \\<not> l t < fst w \\<Longrightarrow>\n    Ball (set (reusables t w)) local.valid", "with assms"], ["proof (chain)\npicking this:\n  0 < fst w\n  local.valid t\n  l t \\<le> fst w\n  r t \\<le> snd w\n  \\<not> l t < fst w", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < fst w\n  local.valid t\n  l t \\<le> fst w\n  r t \\<le> snd w\n  \\<not> l t < fst w\n\ngoal (1 subgoal):\n 1. Ball (set (reusables t w)) local.valid", "by (simp add: reusables.simps)"], ["proof (state)\nthis:\n  Ball (set (reusables t w)) local.valid\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma combine_valid_Nodes_aux:\n  assumes prems: \"0 < l a\" \"a \\<noteq> Leaf\" \"z \\<noteq> Leaf\" \"l z = Suc (r a)\" \"well_shaped a\" \"well_shaped z\"\n    \"well_valued0 a\" \"val a = Some va\" \"well_valued0 z\" \"val z = Some vz\"\n  shows \"va + vz = fold (+) (rev (map ((!) as) [l a - Suc 0..<r z - Suc 0])) (as ! (r z - Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. va + vz =\n    fold (+) (rev (map ((!) as) [l a - Suc 0..<r z - Suc 0]))\n     (as ! (r z - Suc 0))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. va + vz =\n    fold (+) (rev (map ((!) as) [l a - Suc 0..<r z - Suc 0]))\n     (as ! (r z - Suc 0))", "from prems"], ["proof (chain)\npicking this:\n  0 < l a\n  a \\<noteq> Leaf\n  z \\<noteq> Leaf\n  l z = Suc (r a)\n  well_shaped a\n  well_shaped z\n  local.well_valued0 a\n  val a = Some va\n  local.well_valued0 z\n  val z = Some vz", "have \"l a > 0\""], ["proof (prove)\nusing this:\n  0 < l a\n  a \\<noteq> Leaf\n  z \\<noteq> Leaf\n  l z = Suc (r a)\n  well_shaped a\n  well_shaped z\n  local.well_valued0 a\n  val a = Some va\n  local.well_valued0 z\n  val z = Some vz\n\ngoal (1 subgoal):\n 1. 0 < l a", "by simp"], ["proof (state)\nthis:\n  0 < l a\n\ngoal (1 subgoal):\n 1. va + vz =\n    fold (+) (rev (map ((!) as) [l a - Suc 0..<r z - Suc 0]))\n     (as ! (r z - Suc 0))", "moreover"], ["proof (state)\nthis:\n  0 < l a\n\ngoal (1 subgoal):\n 1. va + vz =\n    fold (+) (rev (map ((!) as) [l a - Suc 0..<r z - Suc 0]))\n     (as ! (r z - Suc 0))", "from prems"], ["proof (chain)\npicking this:\n  0 < l a\n  a \\<noteq> Leaf\n  z \\<noteq> Leaf\n  l z = Suc (r a)\n  well_shaped a\n  well_shaped z\n  local.well_valued0 a\n  val a = Some va\n  local.well_valued0 z\n  val z = Some vz", "have \"r a \\<ge> l a\""], ["proof (prove)\nusing this:\n  0 < l a\n  a \\<noteq> Leaf\n  z \\<noteq> Leaf\n  l z = Suc (r a)\n  well_shaped a\n  well_shaped z\n  local.well_valued0 a\n  val a = Some va\n  local.well_valued0 z\n  val z = Some vz\n\ngoal (1 subgoal):\n 1. l a \\<le> r a", "by (metis tree.collapse well_shaped.simps(2))"], ["proof (state)\nthis:\n  l a \\<le> r a\n\ngoal (1 subgoal):\n 1. va + vz =\n    fold (+) (rev (map ((!) as) [l a - Suc 0..<r z - Suc 0]))\n     (as ! (r z - Suc 0))", "moreover"], ["proof (state)\nthis:\n  l a \\<le> r a\n\ngoal (1 subgoal):\n 1. va + vz =\n    fold (+) (rev (map ((!) as) [l a - Suc 0..<r z - Suc 0]))\n     (as ! (r z - Suc 0))", "have \"r z > r a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r a < r z", "by (metis Suc_le_lessD prems(3) prems(4) prems(6) tree.collapse well_shaped.simps(2))"], ["proof (state)\nthis:\n  r a < r z\n\ngoal (1 subgoal):\n 1. va + vz =\n    fold (+) (rev (map ((!) as) [l a - Suc 0..<r z - Suc 0]))\n     (as ! (r z - Suc 0))", "ultimately"], ["proof (chain)\npicking this:\n  0 < l a\n  l a \\<le> r a\n  r a < r z", "have *: \"sum (l a) (r a) + sum (Suc (r a)) (r z) = sum (l a) (r z)\""], ["proof (prove)\nusing this:\n  0 < l a\n  l a \\<le> r a\n  r a < r z\n\ngoal (1 subgoal):\n 1. local.sum (l a) (r a) + local.sum (Suc (r a)) (r z) =\n    local.sum (l a) (r z)", "by (frule add_sum)"], ["proof (state)\nthis:\n  local.sum (l a) (r a) + local.sum (Suc (r a)) (r z) =\n  local.sum (l a) (r z)\n\ngoal (1 subgoal):\n 1. va + vz =\n    fold (+) (rev (map ((!) as) [l a - Suc 0..<r z - Suc 0]))\n     (as ! (r z - Suc 0))", "from prems"], ["proof (chain)\npicking this:\n  0 < l a\n  a \\<noteq> Leaf\n  z \\<noteq> Leaf\n  l z = Suc (r a)\n  well_shaped a\n  well_shaped z\n  local.well_valued0 a\n  val a = Some va\n  local.well_valued0 z\n  val z = Some vz", "have \"va = sum (l a) (r a)\""], ["proof (prove)\nusing this:\n  0 < l a\n  a \\<noteq> Leaf\n  z \\<noteq> Leaf\n  l z = Suc (r a)\n  well_shaped a\n  well_shaped z\n  local.well_valued0 a\n  val a = Some va\n  local.well_valued0 z\n  val z = Some vz\n\ngoal (1 subgoal):\n 1. va = local.sum (l a) (r a)", "by (metis option.discI option.inject tree.collapse well_valued0.simps(2))"], ["proof (state)\nthis:\n  va = local.sum (l a) (r a)\n\ngoal (1 subgoal):\n 1. va + vz =\n    fold (+) (rev (map ((!) as) [l a - Suc 0..<r z - Suc 0]))\n     (as ! (r z - Suc 0))", "moreover"], ["proof (state)\nthis:\n  va = local.sum (l a) (r a)\n\ngoal (1 subgoal):\n 1. va + vz =\n    fold (+) (rev (map ((!) as) [l a - Suc 0..<r z - Suc 0]))\n     (as ! (r z - Suc 0))", "from prems"], ["proof (chain)\npicking this:\n  0 < l a\n  a \\<noteq> Leaf\n  z \\<noteq> Leaf\n  l z = Suc (r a)\n  well_shaped a\n  well_shaped z\n  local.well_valued0 a\n  val a = Some va\n  local.well_valued0 z\n  val z = Some vz", "have \"vz = sum (Suc (r a)) (r z)\""], ["proof (prove)\nusing this:\n  0 < l a\n  a \\<noteq> Leaf\n  z \\<noteq> Leaf\n  l z = Suc (r a)\n  well_shaped a\n  well_shaped z\n  local.well_valued0 a\n  val a = Some va\n  local.well_valued0 z\n  val z = Some vz\n\ngoal (1 subgoal):\n 1. vz = local.sum (Suc (r a)) (r z)", "by (metis option.discI option.inject prems(2) prems(3) prems(8) prems(9) tree.collapse well_valued0.simps(2))"], ["proof (state)\nthis:\n  vz = local.sum (Suc (r a)) (r z)\n\ngoal (1 subgoal):\n 1. va + vz =\n    fold (+) (rev (map ((!) as) [l a - Suc 0..<r z - Suc 0]))\n     (as ! (r z - Suc 0))", "moreover"], ["proof (state)\nthis:\n  vz = local.sum (Suc (r a)) (r z)\n\ngoal (1 subgoal):\n 1. va + vz =\n    fold (+) (rev (map ((!) as) [l a - Suc 0..<r z - Suc 0]))\n     (as ! (r z - Suc 0))", "have \"fold (+) (rev (map ((!) as) [l a - Suc 0..<r z - Suc 0])) (as ! (r z - Suc 0)) = sum (l a) (r z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (+) (rev (map ((!) as) [l a - Suc 0..<r z - Suc 0]))\n     (as ! (r z - Suc 0)) =\n    local.sum (l a) (r z)", "by simp"], ["proof (state)\nthis:\n  fold (+) (rev (map ((!) as) [l a - Suc 0..<r z - Suc 0]))\n   (as ! (r z - Suc 0)) =\n  local.sum (l a) (r z)\n\ngoal (1 subgoal):\n 1. va + vz =\n    fold (+) (rev (map ((!) as) [l a - Suc 0..<r z - Suc 0]))\n     (as ! (r z - Suc 0))", "ultimately"], ["proof (chain)\npicking this:\n  va = local.sum (l a) (r a)\n  vz = local.sum (Suc (r a)) (r z)\n  fold (+) (rev (map ((!) as) [l a - Suc 0..<r z - Suc 0]))\n   (as ! (r z - Suc 0)) =\n  local.sum (l a) (r z)", "show ?thesis"], ["proof (prove)\nusing this:\n  va = local.sum (l a) (r a)\n  vz = local.sum (Suc (r a)) (r z)\n  fold (+) (rev (map ((!) as) [l a - Suc 0..<r z - Suc 0]))\n   (as ! (r z - Suc 0)) =\n  local.sum (l a) (r z)\n\ngoal (1 subgoal):\n 1. va + vz =\n    fold (+) (rev (map ((!) as) [l a - Suc 0..<r z - Suc 0]))\n     (as ! (r z - Suc 0))", "using *"], ["proof (prove)\nusing this:\n  va = local.sum (l a) (r a)\n  vz = local.sum (Suc (r a)) (r z)\n  fold (+) (rev (map ((!) as) [l a - Suc 0..<r z - Suc 0]))\n   (as ! (r z - Suc 0)) =\n  local.sum (l a) (r z)\n  local.sum (l a) (r a) + local.sum (Suc (r a)) (r z) =\n  local.sum (l a) (r z)\n\ngoal (1 subgoal):\n 1. va + vz =\n    fold (+) (rev (map ((!) as) [l a - Suc 0..<r z - Suc 0]))\n     (as ! (r z - Suc 0))", "by (auto simp: add_sum)"], ["proof (state)\nthis:\n  va + vz =\n  fold (+) (rev (map ((!) as) [l a - Suc 0..<r z - Suc 0]))\n   (as ! (r z - Suc 0))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma discharge_is_Leaf[simp]: \"discharge a = Leaf \\<longleftrightarrow> a = Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (discharge a = Leaf) = (a = Leaf)", "by (cases a) auto"], ["", "lemma well_shaped_discharge[simp]: \"well_shaped a \\<Longrightarrow> well_shaped (discharge a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_shaped a \\<Longrightarrow> well_shaped (discharge a)", "by (cases a) auto"], ["", "lemma well_valued0_discharge[simp]: \"well_valued0 a \\<Longrightarrow> well_valued0 (discharge a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.well_valued0 a \\<Longrightarrow> local.well_valued0 (discharge a)", "by (cases a) auto"], ["", "lemma l_discharge[simp]: \"l (discharge a) = l a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l (discharge a) = l a", "by (cases a) auto"], ["", "lemma r_discharge[simp]: \"r (discharge a) = r a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r (discharge a) = r a", "by (cases a) auto"], ["", "lemma well_shaped_lr: \"well_shaped a \\<Longrightarrow> l a \\<le> r a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_shaped a \\<Longrightarrow> l a \\<le> r a", "by (cases a) auto"], ["", "lemma well_valued0_r: \"well_valued0 a \\<Longrightarrow> a \\<noteq> Leaf \\<Longrightarrow> r a \\<le> length as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.well_valued0 a; a \\<noteq> Leaf\\<rbrakk>\n    \\<Longrightarrow> r a \\<le> length as", "by (cases a) auto"], ["", "lemma valid_combine_if_valid: \"\\<lbrakk>0 < l a; valid a; valid z; a \\<noteq> Leaf; z \\<noteq> Leaf; l z = Suc (r a)\\<rbrakk> \\<Longrightarrow>\n  valid (combine a z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < l a; local.valid a; local.valid z; a \\<noteq> Leaf;\n     z \\<noteq> Leaf; l z = Suc (r a)\\<rbrakk>\n    \\<Longrightarrow> local.valid (combine a z)", "by (force simp add: valid_def combine_non_Leaves combine_valid_Nodes_aux\n    dest: well_shaped_lr well_valued0_r)"], ["", "lemma combine_neq_Leaf_if_both_non_Leaf: \"\\<lbrakk>a \\<noteq> Leaf; z \\<noteq> Leaf\\<rbrakk> \\<Longrightarrow>\n  combine a z \\<noteq> Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> Leaf; z \\<noteq> Leaf\\<rbrakk>\n    \\<Longrightarrow> combine a z \\<noteq> Leaf", "by (simp add: combine_non_Leaves)"], ["", "(* generalized version of fact (c) *)"], ["", "lemma valid_fold_combine: \"\\<lbrakk>0 < fst w; ts = h # ts'; \\<forall>t \\<in> set ts. valid t; adjacent (fst w, l h - 1) ts';\n    valid z; z \\<noteq> Leaf; l z = (case ts' of [] \\<Rightarrow> fst w | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1)); r z = snd w\\<rbrakk> \\<Longrightarrow>\n      valid (fold combine ts' z) \\<and>\n      l (fold combine ts' z) = fst w \\<and> r (fold combine ts' z) = snd w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < fst w; ts = h # ts'; Ball (set ts) local.valid;\n     adjacent (fst w, l h - 1) ts'; local.valid z; z \\<noteq> Leaf;\n     l z =\n     (case ts' of [] \\<Rightarrow> fst w\n      | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n     r z = snd w\\<rbrakk>\n    \\<Longrightarrow> local.valid (fold combine ts' z) \\<and>\n                      l (fold combine ts' z) = fst w \\<and>\n                      r (fold combine ts' z) = snd w", "proof (induction ts' arbitrary: z ts h)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>z ts h.\n       \\<lbrakk>0 < fst w; ts = [h]; Ball (set ts) local.valid;\n        adjacent (fst w, l h - 1) []; local.valid z; z \\<noteq> Leaf;\n        l z =\n        (case [] of [] \\<Rightarrow> fst w\n         | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n        r z = snd w\\<rbrakk>\n       \\<Longrightarrow> local.valid (fold combine [] z) \\<and>\n                         l (fold combine [] z) = fst w \\<and>\n                         r (fold combine [] z) = snd w\n 2. \\<And>a ts' z ts h.\n       \\<lbrakk>\\<And>z ts h.\n                   \\<lbrakk>0 < fst w; ts = h # ts';\n                    Ball (set ts) local.valid;\n                    adjacent (fst w, l h - 1) ts'; local.valid z;\n                    z \\<noteq> Leaf;\n                    l z =\n                    (case ts' of [] \\<Rightarrow> fst w\n                     | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n                    r z = snd w\\<rbrakk>\n                   \\<Longrightarrow> local.valid (fold combine ts' z) \\<and>\n                                     l (fold combine ts' z) = fst w \\<and>\n                                     r (fold combine ts' z) = snd w;\n        0 < fst w; ts = h # a # ts'; Ball (set ts) local.valid;\n        adjacent (fst w, l h - 1) (a # ts'); local.valid z; z \\<noteq> Leaf;\n        l z =\n        (case a # ts' of [] \\<Rightarrow> fst w\n         | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n        r z = snd w\\<rbrakk>\n       \\<Longrightarrow> local.valid (fold combine (a # ts') z) \\<and>\n                         l (fold combine (a # ts') z) = fst w \\<and>\n                         r (fold combine (a # ts') z) = snd w", "case Nil"], ["proof (state)\nthis:\n  0 < fst w\n  ts = [h]\n  Ball (set ts) local.valid\n  adjacent (fst w, l h - 1) []\n  local.valid z\n  z \\<noteq> Leaf\n  l z =\n  (case [] of [] \\<Rightarrow> fst w\n   | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1))\n  r z = snd w\n\ngoal (2 subgoals):\n 1. \\<And>z ts h.\n       \\<lbrakk>0 < fst w; ts = [h]; Ball (set ts) local.valid;\n        adjacent (fst w, l h - 1) []; local.valid z; z \\<noteq> Leaf;\n        l z =\n        (case [] of [] \\<Rightarrow> fst w\n         | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n        r z = snd w\\<rbrakk>\n       \\<Longrightarrow> local.valid (fold combine [] z) \\<and>\n                         l (fold combine [] z) = fst w \\<and>\n                         r (fold combine [] z) = snd w\n 2. \\<And>a ts' z ts h.\n       \\<lbrakk>\\<And>z ts h.\n                   \\<lbrakk>0 < fst w; ts = h # ts';\n                    Ball (set ts) local.valid;\n                    adjacent (fst w, l h - 1) ts'; local.valid z;\n                    z \\<noteq> Leaf;\n                    l z =\n                    (case ts' of [] \\<Rightarrow> fst w\n                     | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n                    r z = snd w\\<rbrakk>\n                   \\<Longrightarrow> local.valid (fold combine ts' z) \\<and>\n                                     l (fold combine ts' z) = fst w \\<and>\n                                     r (fold combine ts' z) = snd w;\n        0 < fst w; ts = h # a # ts'; Ball (set ts) local.valid;\n        adjacent (fst w, l h - 1) (a # ts'); local.valid z; z \\<noteq> Leaf;\n        l z =\n        (case a # ts' of [] \\<Rightarrow> fst w\n         | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n        r z = snd w\\<rbrakk>\n       \\<Longrightarrow> local.valid (fold combine (a # ts') z) \\<and>\n                         l (fold combine (a # ts') z) = fst w \\<and>\n                         r (fold combine (a # ts') z) = snd w", "then"], ["proof (chain)\npicking this:\n  0 < fst w\n  ts = [h]\n  Ball (set ts) local.valid\n  adjacent (fst w, l h - 1) []\n  local.valid z\n  z \\<noteq> Leaf\n  l z =\n  (case [] of [] \\<Rightarrow> fst w\n   | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1))\n  r z = snd w", "show ?case"], ["proof (prove)\nusing this:\n  0 < fst w\n  ts = [h]\n  Ball (set ts) local.valid\n  adjacent (fst w, l h - 1) []\n  local.valid z\n  z \\<noteq> Leaf\n  l z =\n  (case [] of [] \\<Rightarrow> fst w\n   | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1))\n  r z = snd w\n\ngoal (1 subgoal):\n 1. local.valid (fold combine [] z) \\<and>\n    l (fold combine [] z) = fst w \\<and> r (fold combine [] z) = snd w", "by simp"], ["proof (state)\nthis:\n  local.valid (fold combine [] z) \\<and>\n  l (fold combine [] z) = fst w \\<and> r (fold combine [] z) = snd w\n\ngoal (1 subgoal):\n 1. \\<And>a ts' z ts h.\n       \\<lbrakk>\\<And>z ts h.\n                   \\<lbrakk>0 < fst w; ts = h # ts';\n                    Ball (set ts) local.valid;\n                    adjacent (fst w, l h - 1) ts'; local.valid z;\n                    z \\<noteq> Leaf;\n                    l z =\n                    (case ts' of [] \\<Rightarrow> fst w\n                     | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n                    r z = snd w\\<rbrakk>\n                   \\<Longrightarrow> local.valid (fold combine ts' z) \\<and>\n                                     l (fold combine ts' z) = fst w \\<and>\n                                     r (fold combine ts' z) = snd w;\n        0 < fst w; ts = h # a # ts'; Ball (set ts) local.valid;\n        adjacent (fst w, l h - 1) (a # ts'); local.valid z; z \\<noteq> Leaf;\n        l z =\n        (case a # ts' of [] \\<Rightarrow> fst w\n         | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n        r z = snd w\\<rbrakk>\n       \\<Longrightarrow> local.valid (fold combine (a # ts') z) \\<and>\n                         l (fold combine (a # ts') z) = fst w \\<and>\n                         r (fold combine (a # ts') z) = snd w", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ts' z ts h.\n       \\<lbrakk>\\<And>z ts h.\n                   \\<lbrakk>0 < fst w; ts = h # ts';\n                    Ball (set ts) local.valid;\n                    adjacent (fst w, l h - 1) ts'; local.valid z;\n                    z \\<noteq> Leaf;\n                    l z =\n                    (case ts' of [] \\<Rightarrow> fst w\n                     | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n                    r z = snd w\\<rbrakk>\n                   \\<Longrightarrow> local.valid (fold combine ts' z) \\<and>\n                                     l (fold combine ts' z) = fst w \\<and>\n                                     r (fold combine ts' z) = snd w;\n        0 < fst w; ts = h # a # ts'; Ball (set ts) local.valid;\n        adjacent (fst w, l h - 1) (a # ts'); local.valid z; z \\<noteq> Leaf;\n        l z =\n        (case a # ts' of [] \\<Rightarrow> fst w\n         | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n        r z = snd w\\<rbrakk>\n       \\<Longrightarrow> local.valid (fold combine (a # ts') z) \\<and>\n                         l (fold combine (a # ts') z) = fst w \\<and>\n                         r (fold combine (a # ts') z) = snd w", "case (Cons a ts')"], ["proof (state)\nthis:\n  \\<lbrakk>0 < fst w; ?ts = ?h # ts'; Ball (set ?ts) local.valid;\n   adjacent (fst w, l ?h - 1) ts'; local.valid ?z; ?z \\<noteq> Leaf;\n   l ?z =\n   (case ts' of [] \\<Rightarrow> fst w\n    | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n   r ?z = snd w\\<rbrakk>\n  \\<Longrightarrow> local.valid (fold combine ts' ?z) \\<and>\n                    l (fold combine ts' ?z) = fst w \\<and>\n                    r (fold combine ts' ?z) = snd w\n  0 < fst w\n  ts = h # a # ts'\n  Ball (set ts) local.valid\n  adjacent (fst w, l h - 1) (a # ts')\n  local.valid z\n  z \\<noteq> Leaf\n  l z =\n  (case a # ts' of [] \\<Rightarrow> fst w\n   | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1))\n  r z = snd w\n\ngoal (1 subgoal):\n 1. \\<And>a ts' z ts h.\n       \\<lbrakk>\\<And>z ts h.\n                   \\<lbrakk>0 < fst w; ts = h # ts';\n                    Ball (set ts) local.valid;\n                    adjacent (fst w, l h - 1) ts'; local.valid z;\n                    z \\<noteq> Leaf;\n                    l z =\n                    (case ts' of [] \\<Rightarrow> fst w\n                     | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n                    r z = snd w\\<rbrakk>\n                   \\<Longrightarrow> local.valid (fold combine ts' z) \\<and>\n                                     l (fold combine ts' z) = fst w \\<and>\n                                     r (fold combine ts' z) = snd w;\n        0 < fst w; ts = h # a # ts'; Ball (set ts) local.valid;\n        adjacent (fst w, l h - 1) (a # ts'); local.valid z; z \\<noteq> Leaf;\n        l z =\n        (case a # ts' of [] \\<Rightarrow> fst w\n         | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n        r z = snd w\\<rbrakk>\n       \\<Longrightarrow> local.valid (fold combine (a # ts') z) \\<and>\n                         l (fold combine (a # ts') z) = fst w \\<and>\n                         r (fold combine (a # ts') z) = snd w", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>0 < fst w; ?ts = ?h # ts'; Ball (set ?ts) local.valid;\n   adjacent (fst w, l ?h - 1) ts'; local.valid ?z; ?z \\<noteq> Leaf;\n   l ?z =\n   (case ts' of [] \\<Rightarrow> fst w\n    | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n   r ?z = snd w\\<rbrakk>\n  \\<Longrightarrow> local.valid (fold combine ts' ?z) \\<and>\n                    l (fold combine ts' ?z) = fst w \\<and>\n                    r (fold combine ts' ?z) = snd w\n  0 < fst w\n  ts = h # a # ts'\n  Ball (set ts) local.valid\n  adjacent (fst w, l h - 1) (a # ts')\n  local.valid z\n  z \\<noteq> Leaf\n  l z =\n  (case a # ts' of [] \\<Rightarrow> fst w\n   | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1))\n  r z = snd w\n\ngoal (1 subgoal):\n 1. \\<And>a ts' z ts h.\n       \\<lbrakk>\\<And>z ts h.\n                   \\<lbrakk>0 < fst w; ts = h # ts';\n                    Ball (set ts) local.valid;\n                    adjacent (fst w, l h - 1) ts'; local.valid z;\n                    z \\<noteq> Leaf;\n                    l z =\n                    (case ts' of [] \\<Rightarrow> fst w\n                     | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n                    r z = snd w\\<rbrakk>\n                   \\<Longrightarrow> local.valid (fold combine ts' z) \\<and>\n                                     l (fold combine ts' z) = fst w \\<and>\n                                     r (fold combine ts' z) = snd w;\n        0 < fst w; ts = h # a # ts'; Ball (set ts) local.valid;\n        adjacent (fst w, l h - 1) (a # ts'); local.valid z; z \\<noteq> Leaf;\n        l z =\n        (case a # ts' of [] \\<Rightarrow> fst w\n         | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n        r z = snd w\\<rbrakk>\n       \\<Longrightarrow> local.valid (fold combine (a # ts') z) \\<and>\n                         l (fold combine (a # ts') z) = fst w \\<and>\n                         r (fold combine (a # ts') z) = snd w", "from Cons(3-4)"], ["proof (chain)\npicking this:\n  ts = h # a # ts'\n  Ball (set ts) local.valid", "have \"valid a\""], ["proof (prove)\nusing this:\n  ts = h # a # ts'\n  Ball (set ts) local.valid\n\ngoal (1 subgoal):\n 1. local.valid a", "by simp"], ["proof (state)\nthis:\n  local.valid a\n\ngoal (1 subgoal):\n 1. \\<And>a ts' z ts h.\n       \\<lbrakk>\\<And>z ts h.\n                   \\<lbrakk>0 < fst w; ts = h # ts';\n                    Ball (set ts) local.valid;\n                    adjacent (fst w, l h - 1) ts'; local.valid z;\n                    z \\<noteq> Leaf;\n                    l z =\n                    (case ts' of [] \\<Rightarrow> fst w\n                     | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n                    r z = snd w\\<rbrakk>\n                   \\<Longrightarrow> local.valid (fold combine ts' z) \\<and>\n                                     l (fold combine ts' z) = fst w \\<and>\n                                     r (fold combine ts' z) = snd w;\n        0 < fst w; ts = h # a # ts'; Ball (set ts) local.valid;\n        adjacent (fst w, l h - 1) (a # ts'); local.valid z; z \\<noteq> Leaf;\n        l z =\n        (case a # ts' of [] \\<Rightarrow> fst w\n         | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n        r z = snd w\\<rbrakk>\n       \\<Longrightarrow> local.valid (fold combine (a # ts') z) \\<and>\n                         l (fold combine (a # ts') z) = fst w \\<and>\n                         r (fold combine (a # ts') z) = snd w", "moreover"], ["proof (state)\nthis:\n  local.valid a\n\ngoal (1 subgoal):\n 1. \\<And>a ts' z ts h.\n       \\<lbrakk>\\<And>z ts h.\n                   \\<lbrakk>0 < fst w; ts = h # ts';\n                    Ball (set ts) local.valid;\n                    adjacent (fst w, l h - 1) ts'; local.valid z;\n                    z \\<noteq> Leaf;\n                    l z =\n                    (case ts' of [] \\<Rightarrow> fst w\n                     | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n                    r z = snd w\\<rbrakk>\n                   \\<Longrightarrow> local.valid (fold combine ts' z) \\<and>\n                                     l (fold combine ts' z) = fst w \\<and>\n                                     r (fold combine ts' z) = snd w;\n        0 < fst w; ts = h # a # ts'; Ball (set ts) local.valid;\n        adjacent (fst w, l h - 1) (a # ts'); local.valid z; z \\<noteq> Leaf;\n        l z =\n        (case a # ts' of [] \\<Rightarrow> fst w\n         | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n        r z = snd w\\<rbrakk>\n       \\<Longrightarrow> local.valid (fold combine (a # ts') z) \\<and>\n                         l (fold combine (a # ts') z) = fst w \\<and>\n                         r (fold combine (a # ts') z) = snd w", "from Cons(5)"], ["proof (chain)\npicking this:\n  adjacent (fst w, l h - 1) (a # ts')", "have \"adjacent (fst w, l a - Suc 0) ts'\""], ["proof (prove)\nusing this:\n  adjacent (fst w, l h - 1) (a # ts')\n\ngoal (1 subgoal):\n 1. adjacent (fst w, l a - Suc 0) ts'", "unfolding adjacent_Cons"], ["proof (prove)\nusing this:\n  a \\<noteq> Leaf \\<and>\n  r a = snd (fst w, l h - 1) \\<and>\n  (case ts' of [] \\<Rightarrow> l a = fst (fst w, l h - 1)\n   | u # us \\<Rightarrow>\n       adjacent (fst (fst w, l h - 1), r u) ts' \\<and> l a = Suc (r u))\n\ngoal (1 subgoal):\n 1. adjacent (fst w, l a - Suc 0) ts'", "by (auto split: list.splits)"], ["proof (state)\nthis:\n  adjacent (fst w, l a - Suc 0) ts'\n\ngoal (1 subgoal):\n 1. \\<And>a ts' z ts h.\n       \\<lbrakk>\\<And>z ts h.\n                   \\<lbrakk>0 < fst w; ts = h # ts';\n                    Ball (set ts) local.valid;\n                    adjacent (fst w, l h - 1) ts'; local.valid z;\n                    z \\<noteq> Leaf;\n                    l z =\n                    (case ts' of [] \\<Rightarrow> fst w\n                     | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n                    r z = snd w\\<rbrakk>\n                   \\<Longrightarrow> local.valid (fold combine ts' z) \\<and>\n                                     l (fold combine ts' z) = fst w \\<and>\n                                     r (fold combine ts' z) = snd w;\n        0 < fst w; ts = h # a # ts'; Ball (set ts) local.valid;\n        adjacent (fst w, l h - 1) (a # ts'); local.valid z; z \\<noteq> Leaf;\n        l z =\n        (case a # ts' of [] \\<Rightarrow> fst w\n         | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n        r z = snd w\\<rbrakk>\n       \\<Longrightarrow> local.valid (fold combine (a # ts') z) \\<and>\n                         l (fold combine (a # ts') z) = fst w \\<and>\n                         r (fold combine (a # ts') z) = snd w", "moreover"], ["proof (state)\nthis:\n  adjacent (fst w, l a - Suc 0) ts'\n\ngoal (1 subgoal):\n 1. \\<And>a ts' z ts h.\n       \\<lbrakk>\\<And>z ts h.\n                   \\<lbrakk>0 < fst w; ts = h # ts';\n                    Ball (set ts) local.valid;\n                    adjacent (fst w, l h - 1) ts'; local.valid z;\n                    z \\<noteq> Leaf;\n                    l z =\n                    (case ts' of [] \\<Rightarrow> fst w\n                     | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n                    r z = snd w\\<rbrakk>\n                   \\<Longrightarrow> local.valid (fold combine ts' z) \\<and>\n                                     l (fold combine ts' z) = fst w \\<and>\n                                     r (fold combine ts' z) = snd w;\n        0 < fst w; ts = h # a # ts'; Ball (set ts) local.valid;\n        adjacent (fst w, l h - 1) (a # ts'); local.valid z; z \\<noteq> Leaf;\n        l z =\n        (case a # ts' of [] \\<Rightarrow> fst w\n         | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n        r z = snd w\\<rbrakk>\n       \\<Longrightarrow> local.valid (fold combine (a # ts') z) \\<and>\n                         l (fold combine (a # ts') z) = fst w \\<and>\n                         r (fold combine (a # ts') z) = snd w", "from Cons(2-6,8)"], ["proof (chain)\npicking this:\n  0 < fst w\n  ts = h # a # ts'\n  Ball (set ts) local.valid\n  adjacent (fst w, l h - 1) (a # ts')\n  local.valid z\n  l z =\n  (case a # ts' of [] \\<Rightarrow> fst w\n   | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1))", "have \"valid (combine a z)\""], ["proof (prove)\nusing this:\n  0 < fst w\n  ts = h # a # ts'\n  Ball (set ts) local.valid\n  adjacent (fst w, l h - 1) (a # ts')\n  local.valid z\n  l z =\n  (case a # ts' of [] \\<Rightarrow> fst w\n   | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1))\n\ngoal (1 subgoal):\n 1. local.valid (combine a z)", "unfolding adjacent_Cons"], ["proof (prove)\nusing this:\n  0 < fst w\n  ts = h # a # ts'\n  Ball (set ts) local.valid\n  a \\<noteq> Leaf \\<and>\n  r a = snd (fst w, l h - 1) \\<and>\n  (case ts' of [] \\<Rightarrow> l a = fst (fst w, l h - 1)\n   | u # us \\<Rightarrow>\n       adjacent (fst (fst w, l h - 1), r u) ts' \\<and> l a = Suc (r u))\n  local.valid z\n  l z =\n  (case a # ts' of [] \\<Rightarrow> fst w\n   | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1))\n\ngoal (1 subgoal):\n 1. local.valid (combine a z)", "by (intro valid_combine_if_valid) (auto split: list.splits)"], ["proof (state)\nthis:\n  local.valid (combine a z)\n\ngoal (1 subgoal):\n 1. \\<And>a ts' z ts h.\n       \\<lbrakk>\\<And>z ts h.\n                   \\<lbrakk>0 < fst w; ts = h # ts';\n                    Ball (set ts) local.valid;\n                    adjacent (fst w, l h - 1) ts'; local.valid z;\n                    z \\<noteq> Leaf;\n                    l z =\n                    (case ts' of [] \\<Rightarrow> fst w\n                     | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n                    r z = snd w\\<rbrakk>\n                   \\<Longrightarrow> local.valid (fold combine ts' z) \\<and>\n                                     l (fold combine ts' z) = fst w \\<and>\n                                     r (fold combine ts' z) = snd w;\n        0 < fst w; ts = h # a # ts'; Ball (set ts) local.valid;\n        adjacent (fst w, l h - 1) (a # ts'); local.valid z; z \\<noteq> Leaf;\n        l z =\n        (case a # ts' of [] \\<Rightarrow> fst w\n         | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n        r z = snd w\\<rbrakk>\n       \\<Longrightarrow> local.valid (fold combine (a # ts') z) \\<and>\n                         l (fold combine (a # ts') z) = fst w \\<and>\n                         r (fold combine (a # ts') z) = snd w", "moreover"], ["proof (state)\nthis:\n  local.valid (combine a z)\n\ngoal (1 subgoal):\n 1. \\<And>a ts' z ts h.\n       \\<lbrakk>\\<And>z ts h.\n                   \\<lbrakk>0 < fst w; ts = h # ts';\n                    Ball (set ts) local.valid;\n                    adjacent (fst w, l h - 1) ts'; local.valid z;\n                    z \\<noteq> Leaf;\n                    l z =\n                    (case ts' of [] \\<Rightarrow> fst w\n                     | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n                    r z = snd w\\<rbrakk>\n                   \\<Longrightarrow> local.valid (fold combine ts' z) \\<and>\n                                     l (fold combine ts' z) = fst w \\<and>\n                                     r (fold combine ts' z) = snd w;\n        0 < fst w; ts = h # a # ts'; Ball (set ts) local.valid;\n        adjacent (fst w, l h - 1) (a # ts'); local.valid z; z \\<noteq> Leaf;\n        l z =\n        (case a # ts' of [] \\<Rightarrow> fst w\n         | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n        r z = snd w\\<rbrakk>\n       \\<Longrightarrow> local.valid (fold combine (a # ts') z) \\<and>\n                         l (fold combine (a # ts') z) = fst w \\<and>\n                         r (fold combine (a # ts') z) = snd w", "from Cons(5,7)"], ["proof (chain)\npicking this:\n  adjacent (fst w, l h - 1) (a # ts')\n  z \\<noteq> Leaf", "have \"combine a z \\<noteq> Leaf\""], ["proof (prove)\nusing this:\n  adjacent (fst w, l h - 1) (a # ts')\n  z \\<noteq> Leaf\n\ngoal (1 subgoal):\n 1. combine a z \\<noteq> Leaf", "by (intro combine_neq_Leaf_if_both_non_Leaf) (simp_all add: adjacent_Cons)"], ["proof (state)\nthis:\n  combine a z \\<noteq> Leaf\n\ngoal (1 subgoal):\n 1. \\<And>a ts' z ts h.\n       \\<lbrakk>\\<And>z ts h.\n                   \\<lbrakk>0 < fst w; ts = h # ts';\n                    Ball (set ts) local.valid;\n                    adjacent (fst w, l h - 1) ts'; local.valid z;\n                    z \\<noteq> Leaf;\n                    l z =\n                    (case ts' of [] \\<Rightarrow> fst w\n                     | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n                    r z = snd w\\<rbrakk>\n                   \\<Longrightarrow> local.valid (fold combine ts' z) \\<and>\n                                     l (fold combine ts' z) = fst w \\<and>\n                                     r (fold combine ts' z) = snd w;\n        0 < fst w; ts = h # a # ts'; Ball (set ts) local.valid;\n        adjacent (fst w, l h - 1) (a # ts'); local.valid z; z \\<noteq> Leaf;\n        l z =\n        (case a # ts' of [] \\<Rightarrow> fst w\n         | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n        r z = snd w\\<rbrakk>\n       \\<Longrightarrow> local.valid (fold combine (a # ts') z) \\<and>\n                         l (fold combine (a # ts') z) = fst w \\<and>\n                         r (fold combine (a # ts') z) = snd w", "moreover"], ["proof (state)\nthis:\n  combine a z \\<noteq> Leaf\n\ngoal (1 subgoal):\n 1. \\<And>a ts' z ts h.\n       \\<lbrakk>\\<And>z ts h.\n                   \\<lbrakk>0 < fst w; ts = h # ts';\n                    Ball (set ts) local.valid;\n                    adjacent (fst w, l h - 1) ts'; local.valid z;\n                    z \\<noteq> Leaf;\n                    l z =\n                    (case ts' of [] \\<Rightarrow> fst w\n                     | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n                    r z = snd w\\<rbrakk>\n                   \\<Longrightarrow> local.valid (fold combine ts' z) \\<and>\n                                     l (fold combine ts' z) = fst w \\<and>\n                                     r (fold combine ts' z) = snd w;\n        0 < fst w; ts = h # a # ts'; Ball (set ts) local.valid;\n        adjacent (fst w, l h - 1) (a # ts'); local.valid z; z \\<noteq> Leaf;\n        l z =\n        (case a # ts' of [] \\<Rightarrow> fst w\n         | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n        r z = snd w\\<rbrakk>\n       \\<Longrightarrow> local.valid (fold combine (a # ts') z) \\<and>\n                         l (fold combine (a # ts') z) = fst w \\<and>\n                         r (fold combine (a # ts') z) = snd w", "from Cons(5,7)"], ["proof (chain)\npicking this:\n  adjacent (fst w, l h - 1) (a # ts')\n  z \\<noteq> Leaf", "have \"l (combine a z) = (case ts' of [] \\<Rightarrow> fst w | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1))\""], ["proof (prove)\nusing this:\n  adjacent (fst w, l h - 1) (a # ts')\n  z \\<noteq> Leaf\n\ngoal (1 subgoal):\n 1. l (combine a z) =\n    (case ts' of [] \\<Rightarrow> fst w\n     | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1))", "by (auto simp add: adjacent_def combine_non_Leaves split: list.splits)"], ["proof (state)\nthis:\n  l (combine a z) =\n  (case ts' of [] \\<Rightarrow> fst w\n   | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1))\n\ngoal (1 subgoal):\n 1. \\<And>a ts' z ts h.\n       \\<lbrakk>\\<And>z ts h.\n                   \\<lbrakk>0 < fst w; ts = h # ts';\n                    Ball (set ts) local.valid;\n                    adjacent (fst w, l h - 1) ts'; local.valid z;\n                    z \\<noteq> Leaf;\n                    l z =\n                    (case ts' of [] \\<Rightarrow> fst w\n                     | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n                    r z = snd w\\<rbrakk>\n                   \\<Longrightarrow> local.valid (fold combine ts' z) \\<and>\n                                     l (fold combine ts' z) = fst w \\<and>\n                                     r (fold combine ts' z) = snd w;\n        0 < fst w; ts = h # a # ts'; Ball (set ts) local.valid;\n        adjacent (fst w, l h - 1) (a # ts'); local.valid z; z \\<noteq> Leaf;\n        l z =\n        (case a # ts' of [] \\<Rightarrow> fst w\n         | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n        r z = snd w\\<rbrakk>\n       \\<Longrightarrow> local.valid (fold combine (a # ts') z) \\<and>\n                         l (fold combine (a # ts') z) = fst w \\<and>\n                         r (fold combine (a # ts') z) = snd w", "moreover"], ["proof (state)\nthis:\n  l (combine a z) =\n  (case ts' of [] \\<Rightarrow> fst w\n   | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1))\n\ngoal (1 subgoal):\n 1. \\<And>a ts' z ts h.\n       \\<lbrakk>\\<And>z ts h.\n                   \\<lbrakk>0 < fst w; ts = h # ts';\n                    Ball (set ts) local.valid;\n                    adjacent (fst w, l h - 1) ts'; local.valid z;\n                    z \\<noteq> Leaf;\n                    l z =\n                    (case ts' of [] \\<Rightarrow> fst w\n                     | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n                    r z = snd w\\<rbrakk>\n                   \\<Longrightarrow> local.valid (fold combine ts' z) \\<and>\n                                     l (fold combine ts' z) = fst w \\<and>\n                                     r (fold combine ts' z) = snd w;\n        0 < fst w; ts = h # a # ts'; Ball (set ts) local.valid;\n        adjacent (fst w, l h - 1) (a # ts'); local.valid z; z \\<noteq> Leaf;\n        l z =\n        (case a # ts' of [] \\<Rightarrow> fst w\n         | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n        r z = snd w\\<rbrakk>\n       \\<Longrightarrow> local.valid (fold combine (a # ts') z) \\<and>\n                         l (fold combine (a # ts') z) = fst w \\<and>\n                         r (fold combine (a # ts') z) = snd w", "from Cons(5,7,9)"], ["proof (chain)\npicking this:\n  adjacent (fst w, l h - 1) (a # ts')\n  z \\<noteq> Leaf\n  r z = snd w", "have \"r (combine a z) = snd w\""], ["proof (prove)\nusing this:\n  adjacent (fst w, l h - 1) (a # ts')\n  z \\<noteq> Leaf\n  r z = snd w\n\ngoal (1 subgoal):\n 1. r (combine a z) = snd w", "by (subst r_combine_non_Leaves) (auto simp add: adjacent_def)"], ["proof (state)\nthis:\n  r (combine a z) = snd w\n\ngoal (1 subgoal):\n 1. \\<And>a ts' z ts h.\n       \\<lbrakk>\\<And>z ts h.\n                   \\<lbrakk>0 < fst w; ts = h # ts';\n                    Ball (set ts) local.valid;\n                    adjacent (fst w, l h - 1) ts'; local.valid z;\n                    z \\<noteq> Leaf;\n                    l z =\n                    (case ts' of [] \\<Rightarrow> fst w\n                     | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n                    r z = snd w\\<rbrakk>\n                   \\<Longrightarrow> local.valid (fold combine ts' z) \\<and>\n                                     l (fold combine ts' z) = fst w \\<and>\n                                     r (fold combine ts' z) = snd w;\n        0 < fst w; ts = h # a # ts'; Ball (set ts) local.valid;\n        adjacent (fst w, l h - 1) (a # ts'); local.valid z; z \\<noteq> Leaf;\n        l z =\n        (case a # ts' of [] \\<Rightarrow> fst w\n         | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n        r z = snd w\\<rbrakk>\n       \\<Longrightarrow> local.valid (fold combine (a # ts') z) \\<and>\n                         l (fold combine (a # ts') z) = fst w \\<and>\n                         r (fold combine (a # ts') z) = snd w", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < fst w; ?ts = ?h # ts'; Ball (set ?ts) local.valid;\n   adjacent (fst w, l ?h - 1) ts'; local.valid ?z; ?z \\<noteq> Leaf;\n   l ?z =\n   (case ts' of [] \\<Rightarrow> fst w\n    | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n   r ?z = snd w\\<rbrakk>\n  \\<Longrightarrow> local.valid (fold combine ts' ?z) \\<and>\n                    l (fold combine ts' ?z) = fst w \\<and>\n                    r (fold combine ts' ?z) = snd w\n  0 < fst w\n  ts = h # a # ts'\n  Ball (set ts) local.valid\n  adjacent (fst w, l h - 1) (a # ts')\n  local.valid z\n  z \\<noteq> Leaf\n  l z =\n  (case a # ts' of [] \\<Rightarrow> fst w\n   | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1))\n  r z = snd w\n  local.valid a\n  adjacent (fst w, l a - Suc 0) ts'\n  local.valid (combine a z)\n  combine a z \\<noteq> Leaf\n  l (combine a z) =\n  (case ts' of [] \\<Rightarrow> fst w\n   | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1))\n  r (combine a z) = snd w", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < fst w; ?ts = ?h # ts'; Ball (set ?ts) local.valid;\n   adjacent (fst w, l ?h - 1) ts'; local.valid ?z; ?z \\<noteq> Leaf;\n   l ?z =\n   (case ts' of [] \\<Rightarrow> fst w\n    | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1));\n   r ?z = snd w\\<rbrakk>\n  \\<Longrightarrow> local.valid (fold combine ts' ?z) \\<and>\n                    l (fold combine ts' ?z) = fst w \\<and>\n                    r (fold combine ts' ?z) = snd w\n  0 < fst w\n  ts = h # a # ts'\n  Ball (set ts) local.valid\n  adjacent (fst w, l h - 1) (a # ts')\n  local.valid z\n  z \\<noteq> Leaf\n  l z =\n  (case a # ts' of [] \\<Rightarrow> fst w\n   | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1))\n  r z = snd w\n  local.valid a\n  adjacent (fst w, l a - Suc 0) ts'\n  local.valid (combine a z)\n  combine a z \\<noteq> Leaf\n  l (combine a z) =\n  (case ts' of [] \\<Rightarrow> fst w\n   | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1))\n  r (combine a z) = snd w\n\ngoal (1 subgoal):\n 1. local.valid (fold combine (a # ts') z) \\<and>\n    l (fold combine (a # ts') z) = fst w \\<and>\n    r (fold combine (a # ts') z) = snd w", "by simp"], ["proof (state)\nthis:\n  local.valid (fold combine (a # ts') z) \\<and>\n  l (fold combine (a # ts') z) = fst w \\<and>\n  r (fold combine (a # ts') z) = snd w\n\ngoal:\nNo subgoals!", "qed"], ["", "(* fact (c) *)"], ["", "lemma valid_fold_combine_Leaf: \n  assumes \"0 < fst w\" \"ts = h # ts'\" \"\\<forall>t \\<in> set ts. valid t\" \"adjacent w ts\"\n  shows \"valid (fold combine ts Leaf) \\<and>\n  l (fold combine ts Leaf) = fst w \\<and> r (fold combine ts Leaf) = snd w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.valid (fold combine ts Leaf) \\<and>\n    l (fold combine ts Leaf) = fst w \\<and> r (fold combine ts Leaf) = snd w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.valid (fold combine ts Leaf) \\<and>\n    l (fold combine ts Leaf) = fst w \\<and> r (fold combine ts Leaf) = snd w", "from assms(2)"], ["proof (chain)\npicking this:\n  ts = h # ts'", "have \"fold combine ts Leaf = fold combine ts' h\""], ["proof (prove)\nusing this:\n  ts = h # ts'\n\ngoal (1 subgoal):\n 1. fold combine ts Leaf = fold combine ts' h", "by simp"], ["proof (state)\nthis:\n  fold combine ts Leaf = fold combine ts' h\n\ngoal (1 subgoal):\n 1. local.valid (fold combine ts Leaf) \\<and>\n    l (fold combine ts Leaf) = fst w \\<and> r (fold combine ts Leaf) = snd w", "moreover"], ["proof (state)\nthis:\n  fold combine ts Leaf = fold combine ts' h\n\ngoal (1 subgoal):\n 1. local.valid (fold combine ts Leaf) \\<and>\n    l (fold combine ts Leaf) = fst w \\<and> r (fold combine ts Leaf) = snd w", "have \"valid (fold combine ts' h) \\<and>\n    l (fold combine ts' h) = fst w \\<and> r (fold combine ts' h) = snd w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.valid (fold combine ts' h) \\<and>\n    l (fold combine ts' h) = fst w \\<and> r (fold combine ts' h) = snd w", "proof (rule valid_fold_combine)"], ["proof (state)\ngoal (8 subgoals):\n 1. 0 < fst w\n 2. ?ts = ?h # ts'\n 3. Ball (set ?ts) local.valid\n 4. adjacent (fst w, l ?h - 1) ts'\n 5. local.valid h\n 6. h \\<noteq> Leaf\n 7. l h =\n    (case ts' of [] \\<Rightarrow> fst w\n     | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1))\n 8. r h = snd w", "from assms"], ["proof (chain)\npicking this:\n  0 < fst w\n  ts = h # ts'\n  Ball (set ts) local.valid\n  adjacent w ts", "show \"0 < fst w\" \"ts = h # ts'\" \"\\<forall>t \\<in> set ts. valid t\" \"valid h\" \"h \\<noteq> Leaf\" \"r h = snd w\"\n      \"l h = (case ts' of [] \\<Rightarrow> fst w | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1))\""], ["proof (prove)\nusing this:\n  0 < fst w\n  ts = h # ts'\n  Ball (set ts) local.valid\n  adjacent w ts\n\ngoal (1 subgoal):\n 1. (0 < fst w &&& ts = h # ts' &&& Ball (set ts) local.valid) &&&\n    (local.valid h &&& h \\<noteq> Leaf) &&&\n    r h = snd w &&&\n    l h =\n    (case ts' of [] \\<Rightarrow> fst w\n     | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1))", "by (simp_all add: adjacent_Cons list.case_eq_if)"], ["proof (state)\nthis:\n  0 < fst w\n  ts = h # ts'\n  Ball (set ts) local.valid\n  local.valid h\n  h \\<noteq> Leaf\n  r h = snd w\n  l h =\n  (case ts' of [] \\<Rightarrow> fst w\n   | t\\<^sub>1 # ts'' \\<Rightarrow> Suc (r t\\<^sub>1))\n\ngoal (1 subgoal):\n 1. adjacent (fst w, l h - 1) ts'", "from assms"], ["proof (chain)\npicking this:\n  0 < fst w\n  ts = h # ts'\n  Ball (set ts) local.valid\n  adjacent w ts", "show \"adjacent (fst w, l h - 1) ts'\""], ["proof (prove)\nusing this:\n  0 < fst w\n  ts = h # ts'\n  Ball (set ts) local.valid\n  adjacent w ts\n\ngoal (1 subgoal):\n 1. adjacent (fst w, l h - 1) ts'", "by (metis One_nat_def adjacent_Cons_implies_adjacent prod.collapse)"], ["proof (state)\nthis:\n  adjacent (fst w, l h - 1) ts'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.valid (fold combine ts' h) \\<and>\n  l (fold combine ts' h) = fst w \\<and> r (fold combine ts' h) = snd w\n\ngoal (1 subgoal):\n 1. local.valid (fold combine ts Leaf) \\<and>\n    l (fold combine ts Leaf) = fst w \\<and> r (fold combine ts Leaf) = snd w", "ultimately"], ["proof (chain)\npicking this:\n  fold combine ts Leaf = fold combine ts' h\n  local.valid (fold combine ts' h) \\<and>\n  l (fold combine ts' h) = fst w \\<and> r (fold combine ts' h) = snd w", "show ?thesis"], ["proof (prove)\nusing this:\n  fold combine ts Leaf = fold combine ts' h\n  local.valid (fold combine ts' h) \\<and>\n  l (fold combine ts' h) = fst w \\<and> r (fold combine ts' h) = snd w\n\ngoal (1 subgoal):\n 1. local.valid (fold combine ts Leaf) \\<and>\n    l (fold combine ts Leaf) = fst w \\<and> r (fold combine ts Leaf) = snd w", "by simp"], ["proof (state)\nthis:\n  local.valid (fold combine ts Leaf) \\<and>\n  l (fold combine ts Leaf) = fst w \\<and> r (fold combine ts Leaf) = snd w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma adjacent_atomics_nonempty_reusables:\n  fixes x :: \"'a tree\" and xs :: \"'a tree list\"\n  assumes a1: \"0 < fst w\"\n      and a2: \"l t \\<le> fst w\"\n      and a3: \"r t \\<le> snd w\"\n      and a4: \"valid t\"\n      and a5: \"reusables t w = x # xs\"\n  shows \"adjacent (Suc (r x), snd w) (atomics (max (fst w) (Suc (r t))) (snd w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent (Suc (r x), snd w)\n     (local.atomics (max (fst w) (Suc (r t))) (snd w))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. adjacent (Suc (r x), snd w)\n     (local.atomics (max (fst w) (Suc (r t))) (snd w))", "have f6: \"\\<forall>p ts. adjacent p ts = ((Leaf::'a tree) \\<notin> set ts \\<and> list_all2 (\\<lambda>t ta. l t = Suc (r ta)) (butlast ts) (tl ts) \\<and> (ts = [] \\<or> l (last ts) = fst p \\<and> r (hd ts) = snd p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p ts.\n       adjacent p ts =\n       (Leaf \\<notin> set ts \\<and>\n        list_all2 (\\<lambda>t ta. l t = Suc (r ta)) (butlast ts)\n         (tl ts) \\<and>\n        (ts = [] \\<or> l (last ts) = fst p \\<and> r (hd ts) = snd p))", "using adjacent_def"], ["proof (prove)\nusing this:\n  adjacent ?w ?ts =\n  (Leaf \\<notin> set ?ts \\<and>\n   list_all2 (\\<lambda>t u. l t = Suc (r u)) (butlast ?ts) (tl ?ts) \\<and>\n   (?ts = [] \\<or> l (last ?ts) = fst ?w \\<and> r (hd ?ts) = snd ?w))\n\ngoal (1 subgoal):\n 1. \\<forall>p ts.\n       adjacent p ts =\n       (Leaf \\<notin> set ts \\<and>\n        list_all2 (\\<lambda>t ta. l t = Suc (r ta)) (butlast ts)\n         (tl ts) \\<and>\n        (ts = [] \\<or> l (last ts) = fst p \\<and> r (hd ts) = snd p))", "by blast"], ["proof (state)\nthis:\n  \\<forall>p ts.\n     adjacent p ts =\n     (Leaf \\<notin> set ts \\<and>\n      list_all2 (\\<lambda>t ta. l t = Suc (r ta)) (butlast ts)\n       (tl ts) \\<and>\n      (ts = [] \\<or> l (last ts) = fst p \\<and> r (hd ts) = snd p))\n\ngoal (1 subgoal):\n 1. adjacent (Suc (r x), snd w)\n     (local.atomics (max (fst w) (Suc (r t))) (snd w))", "then"], ["proof (chain)\npicking this:\n  \\<forall>p ts.\n     adjacent p ts =\n     (Leaf \\<notin> set ts \\<and>\n      list_all2 (\\<lambda>t ta. l t = Suc (r ta)) (butlast ts)\n       (tl ts) \\<and>\n      (ts = [] \\<or> l (last ts) = fst p \\<and> r (hd ts) = snd p))", "have f7: \"Leaf \\<notin> set (atomics (max (fst w) (Suc (r t))) (snd w)) \\<and> list_all2 (\\<lambda>t ta. l t = Suc (r ta)) (butlast (atomics (max (fst w) (Suc (r t))) (snd w))) (tl (atomics (max (fst w) (Suc (r t))) (snd w))) \\<and> (atomics (max (fst w) (Suc (r t))) (snd w) = [] \\<or> l (last (atomics (max (fst w) (Suc (r t))) (snd w))) = fst (max (fst w) (Suc (r t)), snd w) \\<and> r (hd (atomics (max (fst w) (Suc (r t))) (snd w))) = snd (max (fst w) (Suc (r t)), snd w))\""], ["proof (prove)\nusing this:\n  \\<forall>p ts.\n     adjacent p ts =\n     (Leaf \\<notin> set ts \\<and>\n      list_all2 (\\<lambda>t ta. l t = Suc (r ta)) (butlast ts)\n       (tl ts) \\<and>\n      (ts = [] \\<or> l (last ts) = fst p \\<and> r (hd ts) = snd p))\n\ngoal (1 subgoal):\n 1. Leaf\n    \\<notin> set (local.atomics (max (fst w) (Suc (r t))) (snd w)) \\<and>\n    list_all2 (\\<lambda>t ta. l t = Suc (r ta))\n     (butlast (local.atomics (max (fst w) (Suc (r t))) (snd w)))\n     (tl (local.atomics (max (fst w) (Suc (r t))) (snd w))) \\<and>\n    (local.atomics (max (fst w) (Suc (r t))) (snd w) = [] \\<or>\n     l (last (local.atomics (max (fst w) (Suc (r t))) (snd w))) =\n     fst (max (fst w) (Suc (r t)), snd w) \\<and>\n     r (hd (local.atomics (max (fst w) (Suc (r t))) (snd w))) =\n     snd (max (fst w) (Suc (r t)), snd w))", "using adjacent_atomics"], ["proof (prove)\nusing this:\n  \\<forall>p ts.\n     adjacent p ts =\n     (Leaf \\<notin> set ts \\<and>\n      list_all2 (\\<lambda>t ta. l t = Suc (r ta)) (butlast ts)\n       (tl ts) \\<and>\n      (ts = [] \\<or> l (last ts) = fst p \\<and> r (hd ts) = snd p))\n  adjacent (?i, ?j) (local.atomics ?i ?j)\n\ngoal (1 subgoal):\n 1. Leaf\n    \\<notin> set (local.atomics (max (fst w) (Suc (r t))) (snd w)) \\<and>\n    list_all2 (\\<lambda>t ta. l t = Suc (r ta))\n     (butlast (local.atomics (max (fst w) (Suc (r t))) (snd w)))\n     (tl (local.atomics (max (fst w) (Suc (r t))) (snd w))) \\<and>\n    (local.atomics (max (fst w) (Suc (r t))) (snd w) = [] \\<or>\n     l (last (local.atomics (max (fst w) (Suc (r t))) (snd w))) =\n     fst (max (fst w) (Suc (r t)), snd w) \\<and>\n     r (hd (local.atomics (max (fst w) (Suc (r t))) (snd w))) =\n     snd (max (fst w) (Suc (r t)), snd w))", "by presburger"], ["proof (state)\nthis:\n  Leaf \\<notin> set (local.atomics (max (fst w) (Suc (r t))) (snd w)) \\<and>\n  list_all2 (\\<lambda>t ta. l t = Suc (r ta))\n   (butlast (local.atomics (max (fst w) (Suc (r t))) (snd w)))\n   (tl (local.atomics (max (fst w) (Suc (r t))) (snd w))) \\<and>\n  (local.atomics (max (fst w) (Suc (r t))) (snd w) = [] \\<or>\n   l (last (local.atomics (max (fst w) (Suc (r t))) (snd w))) =\n   fst (max (fst w) (Suc (r t)), snd w) \\<and>\n   r (hd (local.atomics (max (fst w) (Suc (r t))) (snd w))) =\n   snd (max (fst w) (Suc (r t)), snd w))\n\ngoal (1 subgoal):\n 1. adjacent (Suc (r x), snd w)\n     (local.atomics (max (fst w) (Suc (r t))) (snd w))", "have \"adjacent (fst w, r t) (reusables t w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent (fst w, r t) (reusables t w)", "using a4 a3 a2 a1"], ["proof (prove)\nusing this:\n  local.valid t\n  r t \\<le> snd w\n  l t \\<le> fst w\n  0 < fst w\n\ngoal (1 subgoal):\n 1. adjacent (fst w, r t) (reusables t w)", "by (simp add: adjacent_reusables valid_def)"], ["proof (state)\nthis:\n  adjacent (fst w, r t) (reusables t w)\n\ngoal (1 subgoal):\n 1. adjacent (Suc (r x), snd w)\n     (local.atomics (max (fst w) (Suc (r t))) (snd w))", "then"], ["proof (chain)\npicking this:\n  adjacent (fst w, r t) (reusables t w)", "have f8: \"r x = r t\""], ["proof (prove)\nusing this:\n  adjacent (fst w, r t) (reusables t w)\n\ngoal (1 subgoal):\n 1. r x = r t", "using a5"], ["proof (prove)\nusing this:\n  adjacent (fst w, r t) (reusables t w)\n  reusables t w = x # xs\n\ngoal (1 subgoal):\n 1. r x = r t", "by (simp add: adjacent_Cons)"], ["proof (state)\nthis:\n  r x = r t\n\ngoal (1 subgoal):\n 1. adjacent (Suc (r x), snd w)\n     (local.atomics (max (fst w) (Suc (r t))) (snd w))", "have \"max (fst w) (Suc (r t)) = Suc (r t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max (fst w) (Suc (r t)) = Suc (r t)", "using a5"], ["proof (prove)\nusing this:\n  reusables t w = x # xs\n\ngoal (1 subgoal):\n 1. max (fst w) (Suc (r t)) = Suc (r t)", "by (metis (no_types) Suc_n_not_le_n list.simps(3) max.bounded_iff max_def_raw not_le_imp_less reusables.simps)"], ["proof (state)\nthis:\n  max (fst w) (Suc (r t)) = Suc (r t)\n\ngoal (1 subgoal):\n 1. adjacent (Suc (r x), snd w)\n     (local.atomics (max (fst w) (Suc (r t))) (snd w))", "then"], ["proof (chain)\npicking this:\n  max (fst w) (Suc (r t)) = Suc (r t)", "show ?thesis"], ["proof (prove)\nusing this:\n  max (fst w) (Suc (r t)) = Suc (r t)\n\ngoal (1 subgoal):\n 1. adjacent (Suc (r x), snd w)\n     (local.atomics (max (fst w) (Suc (r t))) (snd w))", "using f8 f7 f6"], ["proof (prove)\nusing this:\n  max (fst w) (Suc (r t)) = Suc (r t)\n  r x = r t\n  Leaf \\<notin> set (local.atomics (max (fst w) (Suc (r t))) (snd w)) \\<and>\n  list_all2 (\\<lambda>t ta. l t = Suc (r ta))\n   (butlast (local.atomics (max (fst w) (Suc (r t))) (snd w)))\n   (tl (local.atomics (max (fst w) (Suc (r t))) (snd w))) \\<and>\n  (local.atomics (max (fst w) (Suc (r t))) (snd w) = [] \\<or>\n   l (last (local.atomics (max (fst w) (Suc (r t))) (snd w))) =\n   fst (max (fst w) (Suc (r t)), snd w) \\<and>\n   r (hd (local.atomics (max (fst w) (Suc (r t))) (snd w))) =\n   snd (max (fst w) (Suc (r t)), snd w))\n  \\<forall>p ts.\n     adjacent p ts =\n     (Leaf \\<notin> set ts \\<and>\n      list_all2 (\\<lambda>t ta. l t = Suc (r ta)) (butlast ts)\n       (tl ts) \\<and>\n      (ts = [] \\<or> l (last ts) = fst p \\<and> r (hd ts) = snd p))\n\ngoal (1 subgoal):\n 1. adjacent (Suc (r x), snd w)\n     (local.atomics (max (fst w) (Suc (r t))) (snd w))", "by presburger"], ["proof (state)\nthis:\n  adjacent (Suc (r x), snd w)\n   (local.atomics (max (fst w) (Suc (r t))) (snd w))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma adjacent_Cons_r: \"adjacent (a, r t) (x # xs) \\<Longrightarrow> adjacent (a, r x) (x # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent (a, r t) (x # xs) \\<Longrightarrow> adjacent (a, r x) (x # xs)", "by (simp add: adjacent_Cons)"], ["", "lemma adjacent_Cons_r2:\n  \"adjacent (fst w, r t) (x # xs) \\<Longrightarrow> 0 < fst w \\<Longrightarrow> fst w \\<le> snd w \\<Longrightarrow> r t \\<le> snd w \\<Longrightarrow>\n   atomics (max (fst w) (Suc (r t))) (snd w) = [] \\<Longrightarrow>\n   adjacent w (x # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>adjacent (fst w, r t) (x # xs); 0 < fst w; fst w \\<le> snd w;\n     r t \\<le> snd w;\n     local.atomics (max (fst w) (Suc (r t))) (snd w) = []\\<rbrakk>\n    \\<Longrightarrow> adjacent w (x # xs)", "by (metis (no_types, lifting) atomics_def adjacent_def append_is_Nil_conv diff_Suc_Suc diff_zero le_Suc_eq list.simps(3) map_is_Nil_conv max_Suc_Suc max_def_raw prod.sel(1) prod.sel(2) rev_is_Nil_conv upt.simps(2))"], ["", "lemma adjacent_append_atomics_reusables:\n  \"\\<lbrakk>0 < fst w; fst w \\<le> snd w; valid t; l t \\<le> fst w; r t \\<le> snd w\\<rbrakk> \\<Longrightarrow>\n    adjacent w (atomics (max (fst w) (Suc (r t))) (snd w) @ reusables t w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < fst w; fst w \\<le> snd w; local.valid t; l t \\<le> fst w;\n     r t \\<le> snd w\\<rbrakk>\n    \\<Longrightarrow> adjacent w\n                       (local.atomics (max (fst w) (Suc (r t))) (snd w) @\n                        reusables t w)", "using adjacent_atomics_nonempty_reusables[of w t] reusables_neq_Nil_if_well_shaped_and_overlapping[of t w]\n    adjacent_atomics[of \"fst w\" \"snd w\"] adjacent_reusables[of w t]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < fst w; l t \\<le> fst w; r t \\<le> snd w; local.valid t;\n   reusables t w = ?x # ?xs\\<rbrakk>\n  \\<Longrightarrow> adjacent (Suc (r ?x), snd w)\n                     (local.atomics (max (fst w) (Suc (r t))) (snd w))\n  \\<lbrakk>well_shaped t; l t \\<le> fst w; r t \\<le> snd w;\n   fst w \\<le> r t\\<rbrakk>\n  \\<Longrightarrow> reusables t w \\<noteq> []\n  adjacent (fst w, snd w) (local.atomics (fst w) (snd w))\n  \\<lbrakk>0 < fst w; well_shaped t; l t \\<le> fst w;\n   r t \\<le> snd w\\<rbrakk>\n  \\<Longrightarrow> adjacent (fst w, r t) (reusables t w)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < fst w; fst w \\<le> snd w; local.valid t; l t \\<le> fst w;\n     r t \\<le> snd w\\<rbrakk>\n    \\<Longrightarrow> adjacent w\n                       (local.atomics (max (fst w) (Suc (r t))) (snd w) @\n                        reusables t w)", "by (intro adjacent_appendI) (auto simp: valid_def max.absorb1 atomize_not\n    elim: adjacent_Cons_r adjacent_Cons_r2 split: list.splits nat.splits)"], ["", "lemma valid_append_atomics_reusables: \"\\<lbrakk>0 < fst w; valid t; l t \\<le> fst w; r t \\<le> snd w; snd w \\<le> length as\\<rbrakk> \\<Longrightarrow>\n  \\<forall>t \\<in> set (atomics (max (fst w) (Suc (r t))) (snd w) @ reusables t w). valid t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < fst w; local.valid t; l t \\<le> fst w; r t \\<le> snd w;\n     snd w \\<le> length as\\<rbrakk>\n    \\<Longrightarrow> Ball\n                       (set (local.atomics (max (fst w) (Suc (r t)))\n                              (snd w) @\n                             reusables t w))\n                       local.valid", "by (auto simp only: set_append valid_reusables dest: valid_atomics split: if_splits)"], ["", "lemma append_atomics_reusables_neq_Nil: \"\\<lbrakk>0 < fst w; fst w \\<le> snd w; valid t; l t \\<le> fst w; r t \\<le> snd w\\<rbrakk> \\<Longrightarrow>\n  atomics (max (fst w) (Suc (r t))) (snd w) @ reusables t w \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < fst w; fst w \\<le> snd w; local.valid t; l t \\<le> fst w;\n     r t \\<le> snd w\\<rbrakk>\n    \\<Longrightarrow> local.atomics (max (fst w) (Suc (r t))) (snd w) @\n                      reusables t w \\<noteq>\n                      []", "by (simp add: reusables_neq_Nil_if_well_shaped_and_overlapping valid_def atomics_def)"], ["", "(* lemma 1 *)"], ["", "lemma valid_slide:\n  assumes \"0 < fst w\" \"fst w \\<le> snd w\" \"valid t\" \"l t \\<le> fst w\" \"r t \\<le> snd w\" \"snd w \\<le> length as\"\n  shows \"valid (slide t w) \\<and> l (slide t w) = fst w \\<and> r (slide t w) = snd w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.valid (local.slide t w) \\<and>\n    l (local.slide t w) = fst w \\<and> r (local.slide t w) = snd w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.valid (local.slide t w) \\<and>\n    l (local.slide t w) = fst w \\<and> r (local.slide t w) = snd w", "from assms"], ["proof (chain)\npicking this:\n  0 < fst w\n  fst w \\<le> snd w\n  local.valid t\n  l t \\<le> fst w\n  r t \\<le> snd w\n  snd w \\<le> length as", "have non_empty: \"atomics (max (fst w) (Suc (r t))) (snd w) @ reusables t w \\<noteq> []\""], ["proof (prove)\nusing this:\n  0 < fst w\n  fst w \\<le> snd w\n  local.valid t\n  l t \\<le> fst w\n  r t \\<le> snd w\n  snd w \\<le> length as\n\ngoal (1 subgoal):\n 1. local.atomics (max (fst w) (Suc (r t))) (snd w) @ reusables t w \\<noteq>\n    []", "using append_atomics_reusables_neq_Nil"], ["proof (prove)\nusing this:\n  0 < fst w\n  fst w \\<le> snd w\n  local.valid t\n  l t \\<le> fst w\n  r t \\<le> snd w\n  snd w \\<le> length as\n  \\<lbrakk>0 < fst ?w; fst ?w \\<le> snd ?w; local.valid ?t;\n   l ?t \\<le> fst ?w; r ?t \\<le> snd ?w\\<rbrakk>\n  \\<Longrightarrow> local.atomics (max (fst ?w) (Suc (r ?t))) (snd ?w) @\n                    reusables ?t ?w \\<noteq>\n                    []\n\ngoal (1 subgoal):\n 1. local.atomics (max (fst w) (Suc (r t))) (snd w) @ reusables t w \\<noteq>\n    []", "by blast"], ["proof (state)\nthis:\n  local.atomics (max (fst w) (Suc (r t))) (snd w) @ reusables t w \\<noteq>\n  []\n\ngoal (1 subgoal):\n 1. local.valid (local.slide t w) \\<and>\n    l (local.slide t w) = fst w \\<and> r (local.slide t w) = snd w", "from assms"], ["proof (chain)\npicking this:\n  0 < fst w\n  fst w \\<le> snd w\n  local.valid t\n  l t \\<le> fst w\n  r t \\<le> snd w\n  snd w \\<le> length as", "have adjacent: \"adjacent w (atomics (max (fst w) (Suc (r t))) (snd w) @ reusables t w)\""], ["proof (prove)\nusing this:\n  0 < fst w\n  fst w \\<le> snd w\n  local.valid t\n  l t \\<le> fst w\n  r t \\<le> snd w\n  snd w \\<le> length as\n\ngoal (1 subgoal):\n 1. adjacent w\n     (local.atomics (max (fst w) (Suc (r t))) (snd w) @ reusables t w)", "using adjacent_append_atomics_reusables"], ["proof (prove)\nusing this:\n  0 < fst w\n  fst w \\<le> snd w\n  local.valid t\n  l t \\<le> fst w\n  r t \\<le> snd w\n  snd w \\<le> length as\n  \\<lbrakk>0 < fst ?w; fst ?w \\<le> snd ?w; local.valid ?t;\n   l ?t \\<le> fst ?w; r ?t \\<le> snd ?w\\<rbrakk>\n  \\<Longrightarrow> adjacent ?w\n                     (local.atomics (max (fst ?w) (Suc (r ?t))) (snd ?w) @\n                      reusables ?t ?w)\n\ngoal (1 subgoal):\n 1. adjacent w\n     (local.atomics (max (fst w) (Suc (r t))) (snd w) @ reusables t w)", "by blast"], ["proof (state)\nthis:\n  adjacent w\n   (local.atomics (max (fst w) (Suc (r t))) (snd w) @ reusables t w)\n\ngoal (1 subgoal):\n 1. local.valid (local.slide t w) \\<and>\n    l (local.slide t w) = fst w \\<and> r (local.slide t w) = snd w", "from assms"], ["proof (chain)\npicking this:\n  0 < fst w\n  fst w \\<le> snd w\n  local.valid t\n  l t \\<le> fst w\n  r t \\<le> snd w\n  snd w \\<le> length as", "have valid: \"\\<forall>t \\<in> set (atomics (max (fst w) (Suc (r t))) (snd w) @ reusables t w). valid t\""], ["proof (prove)\nusing this:\n  0 < fst w\n  fst w \\<le> snd w\n  local.valid t\n  l t \\<le> fst w\n  r t \\<le> snd w\n  snd w \\<le> length as\n\ngoal (1 subgoal):\n 1. Ball\n     (set (local.atomics (max (fst w) (Suc (r t))) (snd w) @ reusables t w))\n     local.valid", "using valid_append_atomics_reusables"], ["proof (prove)\nusing this:\n  0 < fst w\n  fst w \\<le> snd w\n  local.valid t\n  l t \\<le> fst w\n  r t \\<le> snd w\n  snd w \\<le> length as\n  \\<lbrakk>0 < fst ?w; local.valid ?t; l ?t \\<le> fst ?w; r ?t \\<le> snd ?w;\n   snd ?w \\<le> length as\\<rbrakk>\n  \\<Longrightarrow> Ball\n                     (set (local.atomics (max (fst ?w) (Suc (r ?t)))\n                            (snd ?w) @\n                           reusables ?t ?w))\n                     local.valid\n\ngoal (1 subgoal):\n 1. Ball\n     (set (local.atomics (max (fst w) (Suc (r t))) (snd w) @ reusables t w))\n     local.valid", "by blast"], ["proof (state)\nthis:\n  Ball\n   (set (local.atomics (max (fst w) (Suc (r t))) (snd w) @ reusables t w))\n   local.valid\n\ngoal (1 subgoal):\n 1. local.valid (local.slide t w) \\<and>\n    l (local.slide t w) = fst w \\<and> r (local.slide t w) = snd w", "have *: \"slide t w = fold combine (atomics (max (fst w) (Suc (r t))) (snd w) @ reusables t w) Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.slide t w =\n    fold combine\n     (local.atomics (max (fst w) (Suc (r t))) (snd w) @ reusables t w) Leaf", "by (simp add: slide_def)"], ["proof (state)\nthis:\n  local.slide t w =\n  fold combine\n   (local.atomics (max (fst w) (Suc (r t))) (snd w) @ reusables t w) Leaf\n\ngoal (1 subgoal):\n 1. local.valid (local.slide t w) \\<and>\n    l (local.slide t w) = fst w \\<and> r (local.slide t w) = snd w", "from assms(1) non_empty adjacent valid"], ["proof (chain)\npicking this:\n  0 < fst w\n  local.atomics (max (fst w) (Suc (r t))) (snd w) @ reusables t w \\<noteq>\n  []\n  adjacent w\n   (local.atomics (max (fst w) (Suc (r t))) (snd w) @ reusables t w)\n  Ball\n   (set (local.atomics (max (fst w) (Suc (r t))) (snd w) @ reusables t w))\n   local.valid", "show \"valid (slide t w) \\<and> l (slide t w) = fst w \\<and> r (slide t w) = snd w\""], ["proof (prove)\nusing this:\n  0 < fst w\n  local.atomics (max (fst w) (Suc (r t))) (snd w) @ reusables t w \\<noteq>\n  []\n  adjacent w\n   (local.atomics (max (fst w) (Suc (r t))) (snd w) @ reusables t w)\n  Ball\n   (set (local.atomics (max (fst w) (Suc (r t))) (snd w) @ reusables t w))\n   local.valid\n\ngoal (1 subgoal):\n 1. local.valid (local.slide t w) \\<and>\n    l (local.slide t w) = fst w \\<and> r (local.slide t w) = snd w", "unfolding * neq_Nil_conv"], ["proof (prove)\nusing this:\n  0 < fst w\n  \\<exists>y ys.\n     local.atomics (max (fst w) (Suc (r t))) (snd w) @ reusables t w =\n     y # ys\n  adjacent w\n   (local.atomics (max (fst w) (Suc (r t))) (snd w) @ reusables t w)\n  Ball\n   (set (local.atomics (max (fst w) (Suc (r t))) (snd w) @ reusables t w))\n   local.valid\n\ngoal (1 subgoal):\n 1. local.valid\n     (fold combine\n       (local.atomics (max (fst w) (Suc (r t))) (snd w) @ reusables t w)\n       Leaf) \\<and>\n    l (fold combine\n        (local.atomics (max (fst w) (Suc (r t))) (snd w) @ reusables t w)\n        Leaf) =\n    fst w \\<and>\n    r (fold combine\n        (local.atomics (max (fst w) (Suc (r t))) (snd w) @ reusables t w)\n        Leaf) =\n    snd w", "using valid_fold_combine_Leaf"], ["proof (prove)\nusing this:\n  0 < fst w\n  \\<exists>y ys.\n     local.atomics (max (fst w) (Suc (r t))) (snd w) @ reusables t w =\n     y # ys\n  adjacent w\n   (local.atomics (max (fst w) (Suc (r t))) (snd w) @ reusables t w)\n  Ball\n   (set (local.atomics (max (fst w) (Suc (r t))) (snd w) @ reusables t w))\n   local.valid\n  \\<lbrakk>0 < fst ?w; ?ts = ?h # ?ts'; Ball (set ?ts) local.valid;\n   adjacent ?w ?ts\\<rbrakk>\n  \\<Longrightarrow> local.valid (fold combine ?ts Leaf) \\<and>\n                    l (fold combine ?ts Leaf) = fst ?w \\<and>\n                    r (fold combine ?ts Leaf) = snd ?w\n\ngoal (1 subgoal):\n 1. local.valid\n     (fold combine\n       (local.atomics (max (fst w) (Suc (r t))) (snd w) @ reusables t w)\n       Leaf) \\<and>\n    l (fold combine\n        (local.atomics (max (fst w) (Suc (r t))) (snd w) @ reusables t w)\n        Leaf) =\n    fst w \\<and>\n    r (fold combine\n        (local.atomics (max (fst w) (Suc (r t))) (snd w) @ reusables t w)\n        Leaf) =\n    snd w", "by blast"], ["proof (state)\nthis:\n  local.valid (local.slide t w) \\<and>\n  l (local.slide t w) = fst w \\<and> r (local.slide t w) = snd w\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Correctness of the Sliding Window Algorithm\\<close>"], ["", "lemma iterate_eq_map_sum: \"\\<lbrakk>valid t; windows as xs; (case xs of [] \\<Rightarrow> True | x # xs' \\<Rightarrow> l t \\<le> fst x \\<and> r t \\<le> snd x)\\<rbrakk> \\<Longrightarrow>\n  iterate t xs = map (\\<lambda>w. sum (fst w) (snd w)) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.valid t; windows as xs;\n     case xs of [] \\<Rightarrow> True\n     | x # xs' \\<Rightarrow> l t \\<le> fst x \\<and> r t \\<le> snd x\\<rbrakk>\n    \\<Longrightarrow> local.iterate t xs =\n                      map (\\<lambda>w. local.sum (fst w) (snd w)) xs", "by (induction xs arbitrary: t)\n    (auto simp: valid_slide windows_def window_def val_eq_Some_sum_if_valid_neq_Leaf neq_Leaf_if_l_gt0 split: list.split)"], ["", "(* theorem 2: functional correctness *)"], ["", "theorem correctness: \"windows as ws \\<Longrightarrow> sliding_window = map (\\<lambda>w. sum (fst w) (snd w)) ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. windows as ws \\<Longrightarrow>\n    local.sliding_window = map (\\<lambda>w. local.sum (fst w) (snd w)) ws", "by (auto simp only: sliding_window_def intro!: iterate_eq_map_sum)\n    (auto simp: valid_def split: list.split)"], ["", "end"], ["", "(*<*)"], ["", "value[code] \"sliding_window [2,4,5,2 :: nat] [(1, 3), (1, 4), (2, 4)]\""], ["", "value[code] \"slide [2,4,5,2 :: nat] Leaf (1, 3)\""], ["", "(*>*)"], ["", "subsection \\<open>Summary of the Correctness Proof\\<close>"], ["", "text \\<open>We closely follow Basin et al.'s proof outline~\\cite{BASIN2015186}.\n  \\begin{enumerate}\n    \\item Lemma 1, the correctness result about the function @{term SWA.slide}, is formalized \n      by @{thm[source] SWA.valid_slide}. It follows from the following auxiliary facts:\n      \\begin{itemize}\n        \\item Fact (a) is formalized by @{thm[source] SWA.adjacent_reusables} and @{thm[source] SWA.valid_reusables}.\n        \\item Fact (b) is formalized by @{thm[source] SWA.adjacent_atomics} and @{thm[source] SWA.valid_atomics}.\n        \\item Fact (c) is formalized by @{thm[source] SWA.valid_fold_combine_Leaf}.\n      \\end{itemize}\n    \\item Theorem 2, the correctness result about the function @{term SWA.sliding_window}, is formalized\n      by @{thm[source] SWA.correctness}.\n  \\end{enumerate}\n\\<close>"], ["", "section \\<open>Alternative Slide Interface and Additional Operations\\<close>"], ["", "subsection \\<open>Alternative Slide Interface\\<close>"], ["", "text \\<open>\n  The slide operation above takes the \\emph{entire} input sequence as a parameter. This is often\n  impractical. We provide an alternative interface to the slide operation that takes only the\n  \\emph{new} elements as a parameter.\n\\<close>"], ["", "abbreviation atomic' where\n  \"atomic' as b idx \\<equiv> Node b b (Some (nth as idx)) Leaf Leaf\""], ["", "abbreviation atomics' :: \"'a list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 'a tree list\" where\n  \"atomics' as i j sidx \\<equiv> map (\\<lambda>b. atomic' as b (b - sidx)) (rev [i ..< Suc j])\""], ["", "definition slide' :: \"'a :: semigroup_add list \\<Rightarrow> 'a tree \\<Rightarrow> window \\<Rightarrow> 'a tree\" where\n\"slide' as t w =\n    (let\n      ts = atomics' as (max (fst w) (Suc (r t))) (snd w) (Suc (r t));\n      ts' = reusables t w\n    in fold combine (ts @ ts') Leaf)\""], ["", "(* examples from paper *)\n(*<*)"], ["", "value[code] \"slide' [2,4,5,2 :: nat] Leaf (1, 3)\""], ["", "value[code] \"slide' [2,4,5,2 :: nat] Leaf (1, 4)\""], ["", "value[code] \"slide' [2,4,5,2 :: nat] Leaf (2, 4)\""], ["", "value[code] \"slide' [2 :: nat] (slide' [2,4,5 :: nat] Leaf (1, 3)) (1, 4)\""], ["", "value[code] \"slide' [] (slide' [2 :: nat] (slide' [2,4,5 :: nat] Leaf (1, 3)) (1, 4)) (2, 4)\""], ["", "value[code] \"slide' [2,4,5 :: nat] Leaf (1, 3)\""], ["", "value[code] \"slide' [2 :: nat] (slide' [2,4,5 :: nat] Leaf (1, 3)) (2, 4)\""], ["", "(*>*)"], ["", "lemma slide_eq_slide':\n  assumes \"0 < fst w\" \"fst w \\<le> snd w\" \"valid as t\" \"r t = length as\" \"l t \\<le> fst w\" \"r t \\<le> snd w\" \"snd w \\<le> length (as @ as')\"\n  shows \"slide (as @ as') t w = slide' as' t w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slide (as @ as') t w = slide' as' t w", "proof (cases \"r t = snd w\")"], ["proof (state)\ngoal (2 subgoals):\n 1. r t = snd w \\<Longrightarrow> slide (as @ as') t w = slide' as' t w\n 2. r t \\<noteq> snd w \\<Longrightarrow>\n    slide (as @ as') t w = slide' as' t w", "case True"], ["proof (state)\nthis:\n  r t = snd w\n\ngoal (2 subgoals):\n 1. r t = snd w \\<Longrightarrow> slide (as @ as') t w = slide' as' t w\n 2. r t \\<noteq> snd w \\<Longrightarrow>\n    slide (as @ as') t w = slide' as' t w", "with assms"], ["proof (chain)\npicking this:\n  0 < fst w\n  fst w \\<le> snd w\n  valid as t\n  r t = length as\n  l t \\<le> fst w\n  r t \\<le> snd w\n  snd w \\<le> length (as @ as')\n  r t = snd w", "have *: \"atomics' (as @ as') (max (fst w) (Suc (r t))) (snd w) 1 = []\""], ["proof (prove)\nusing this:\n  0 < fst w\n  fst w \\<le> snd w\n  valid as t\n  r t = length as\n  l t \\<le> fst w\n  r t \\<le> snd w\n  snd w \\<le> length (as @ as')\n  r t = snd w\n\ngoal (1 subgoal):\n 1. atomics' (as @ as') (max (fst w) (Suc (r t))) (snd w) 1 = []", "by simp"], ["proof (state)\nthis:\n  atomics' (as @ as') (max (fst w) (Suc (r t))) (snd w) 1 = []\n\ngoal (2 subgoals):\n 1. r t = snd w \\<Longrightarrow> slide (as @ as') t w = slide' as' t w\n 2. r t \\<noteq> snd w \\<Longrightarrow>\n    slide (as @ as') t w = slide' as' t w", "from True assms"], ["proof (chain)\npicking this:\n  r t = snd w\n  0 < fst w\n  fst w \\<le> snd w\n  valid as t\n  r t = length as\n  l t \\<le> fst w\n  r t \\<le> snd w\n  snd w \\<le> length (as @ as')", "have \"atomics' as' (max (fst w) (Suc (r t))) (snd w) (Suc (r t)) = []\""], ["proof (prove)\nusing this:\n  r t = snd w\n  0 < fst w\n  fst w \\<le> snd w\n  valid as t\n  r t = length as\n  l t \\<le> fst w\n  r t \\<le> snd w\n  snd w \\<le> length (as @ as')\n\ngoal (1 subgoal):\n 1. atomics' as' (max (fst w) (Suc (r t))) (snd w) (Suc (r t)) = []", "by simp"], ["proof (state)\nthis:\n  atomics' as' (max (fst w) (Suc (r t))) (snd w) (Suc (r t)) = []\n\ngoal (2 subgoals):\n 1. r t = snd w \\<Longrightarrow> slide (as @ as') t w = slide' as' t w\n 2. r t \\<noteq> snd w \\<Longrightarrow>\n    slide (as @ as') t w = slide' as' t w", "with *"], ["proof (chain)\npicking this:\n  atomics' (as @ as') (max (fst w) (Suc (r t))) (snd w) 1 = []\n  atomics' as' (max (fst w) (Suc (r t))) (snd w) (Suc (r t)) = []", "show ?thesis"], ["proof (prove)\nusing this:\n  atomics' (as @ as') (max (fst w) (Suc (r t))) (snd w) 1 = []\n  atomics' as' (max (fst w) (Suc (r t))) (snd w) (Suc (r t)) = []\n\ngoal (1 subgoal):\n 1. slide (as @ as') t w = slide' as' t w", "unfolding slide_def slide'_def atomics_def"], ["proof (prove)\nusing this:\n  atomics' (as @ as') (max (fst w) (Suc (r t))) (snd w) 1 = []\n  atomics' as' (max (fst w) (Suc (r t))) (snd w) (Suc (r t)) = []\n\ngoal (1 subgoal):\n 1. (let ts = atomics' (as @ as') (max (fst w) (Suc (r t))) (snd w) 1;\n         ts' = reusables t w\n     in fold combine (ts @ ts') Leaf) =\n    (let ts = atomics' as' (max (fst w) (Suc (r t))) (snd w) (Suc (r t));\n         ts' = reusables t w\n     in fold combine (ts @ ts') Leaf)", "by simp"], ["proof (state)\nthis:\n  slide (as @ as') t w = slide' as' t w\n\ngoal (1 subgoal):\n 1. r t \\<noteq> snd w \\<Longrightarrow>\n    slide (as @ as') t w = slide' as' t w", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. r t \\<noteq> snd w \\<Longrightarrow>\n    slide (as @ as') t w = slide' as' t w", "case False"], ["proof (state)\nthis:\n  r t \\<noteq> snd w\n\ngoal (1 subgoal):\n 1. r t \\<noteq> snd w \\<Longrightarrow>\n    slide (as @ as') t w = slide' as' t w", "with assms"], ["proof (chain)\npicking this:\n  0 < fst w\n  fst w \\<le> snd w\n  valid as t\n  r t = length as\n  l t \\<le> fst w\n  r t \\<le> snd w\n  snd w \\<le> length (as @ as')\n  r t \\<noteq> snd w", "have \"r t < snd w\""], ["proof (prove)\nusing this:\n  0 < fst w\n  fst w \\<le> snd w\n  valid as t\n  r t = length as\n  l t \\<le> fst w\n  r t \\<le> snd w\n  snd w \\<le> length (as @ as')\n  r t \\<noteq> snd w\n\ngoal (1 subgoal):\n 1. r t < snd w", "by simp"], ["proof (state)\nthis:\n  r t < snd w\n\ngoal (1 subgoal):\n 1. r t \\<noteq> snd w \\<Longrightarrow>\n    slide (as @ as') t w = slide' as' t w", "with assms"], ["proof (chain)\npicking this:\n  0 < fst w\n  fst w \\<le> snd w\n  valid as t\n  r t = length as\n  l t \\<le> fst w\n  r t \\<le> snd w\n  snd w \\<le> length (as @ as')\n  r t < snd w", "have \"atomic' (as @ as') (snd w) (snd w - Suc 0) = atomic' as' (snd w) (snd w - Suc (length as))\""], ["proof (prove)\nusing this:\n  0 < fst w\n  fst w \\<le> snd w\n  valid as t\n  r t = length as\n  l t \\<le> fst w\n  r t \\<le> snd w\n  snd w \\<le> length (as @ as')\n  r t < snd w\n\ngoal (1 subgoal):\n 1. atomic' (as @ as') (snd w) (snd w - Suc 0) =\n    atomic' as' (snd w) (snd w - Suc (length as))", "by (simp add: leD nth_append)"], ["proof (state)\nthis:\n  atomic' (as @ as') (snd w) (snd w - Suc 0) =\n  atomic' as' (snd w) (snd w - Suc (length as))\n\ngoal (1 subgoal):\n 1. r t \\<noteq> snd w \\<Longrightarrow>\n    slide (as @ as') t w = slide' as' t w", "with assms"], ["proof (chain)\npicking this:\n  0 < fst w\n  fst w \\<le> snd w\n  valid as t\n  r t = length as\n  l t \\<le> fst w\n  r t \\<le> snd w\n  snd w \\<le> length (as @ as')\n  atomic' (as @ as') (snd w) (snd w - Suc 0) =\n  atomic' as' (snd w) (snd w - Suc (length as))", "have *: \"\\<forall>i. i \\<in> set ([max (fst w) (Suc (length as))..<snd w]) \\<longrightarrow> atomic' (as @ as') i (i - Suc 0) = atomic' as' i (i - Suc (length as))\""], ["proof (prove)\nusing this:\n  0 < fst w\n  fst w \\<le> snd w\n  valid as t\n  r t = length as\n  l t \\<le> fst w\n  r t \\<le> snd w\n  snd w \\<le> length (as @ as')\n  atomic' (as @ as') (snd w) (snd w - Suc 0) =\n  atomic' as' (snd w) (snd w - Suc (length as))\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       i \\<in> set [max (fst w) (Suc (length as))..<snd w] \\<longrightarrow>\n       atomic' (as @ as') i (i - Suc 0) =\n       atomic' as' i (i - Suc (length as))", "by (auto simp: nth_append)"], ["proof (state)\nthis:\n  \\<forall>i.\n     i \\<in> set [max (fst w) (Suc (length as))..<snd w] \\<longrightarrow>\n     atomic' (as @ as') i (i - Suc 0) = atomic' as' i (i - Suc (length as))\n\ngoal (1 subgoal):\n 1. r t \\<noteq> snd w \\<Longrightarrow>\n    slide (as @ as') t w = slide' as' t w", "then"], ["proof (chain)\npicking this:\n  \\<forall>i.\n     i \\<in> set [max (fst w) (Suc (length as))..<snd w] \\<longrightarrow>\n     atomic' (as @ as') i (i - Suc 0) = atomic' as' i (i - Suc (length as))", "have \"map (\\<lambda>i. atomic' (as @ as') i (i - Suc 0)) (rev [max (fst w) (Suc (length as))..<snd w]) = map (\\<lambda>b. atomic' as' b (b - Suc (r t))) (rev [max (fst w) (Suc (r t))..<snd w])\""], ["proof (prove)\nusing this:\n  \\<forall>i.\n     i \\<in> set [max (fst w) (Suc (length as))..<snd w] \\<longrightarrow>\n     atomic' (as @ as') i (i - Suc 0) = atomic' as' i (i - Suc (length as))\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i. atomic' (as @ as') i (i - Suc 0))\n     (rev [max (fst w) (Suc (length as))..<snd w]) =\n    map (\\<lambda>b. atomic' as' b (b - Suc (r t)))\n     (rev [max (fst w) (Suc (r t))..<snd w])", "by (simp add: assms(4))"], ["proof (state)\nthis:\n  map (\\<lambda>i. atomic' (as @ as') i (i - Suc 0))\n   (rev [max (fst w) (Suc (length as))..<snd w]) =\n  map (\\<lambda>b. atomic' as' b (b - Suc (r t)))\n   (rev [max (fst w) (Suc (r t))..<snd w])\n\ngoal (1 subgoal):\n 1. r t \\<noteq> snd w \\<Longrightarrow>\n    slide (as @ as') t w = slide' as' t w", "with assms"], ["proof (chain)\npicking this:\n  0 < fst w\n  fst w \\<le> snd w\n  valid as t\n  r t = length as\n  l t \\<le> fst w\n  r t \\<le> snd w\n  snd w \\<le> length (as @ as')\n  map (\\<lambda>i. atomic' (as @ as') i (i - Suc 0))\n   (rev [max (fst w) (Suc (length as))..<snd w]) =\n  map (\\<lambda>b. atomic' as' b (b - Suc (r t)))\n   (rev [max (fst w) (Suc (r t))..<snd w])", "have \"atomics' (as @ as') (max (fst w) (Suc (r t))) (snd w) 1 = atomics' as' (max (fst w) (Suc (r t))) (snd w) (Suc (r t))\""], ["proof (prove)\nusing this:\n  0 < fst w\n  fst w \\<le> snd w\n  valid as t\n  r t = length as\n  l t \\<le> fst w\n  r t \\<le> snd w\n  snd w \\<le> length (as @ as')\n  map (\\<lambda>i. atomic' (as @ as') i (i - Suc 0))\n   (rev [max (fst w) (Suc (length as))..<snd w]) =\n  map (\\<lambda>b. atomic' as' b (b - Suc (r t)))\n   (rev [max (fst w) (Suc (r t))..<snd w])\n\ngoal (1 subgoal):\n 1. atomics' (as @ as') (max (fst w) (Suc (r t))) (snd w) 1 =\n    atomics' as' (max (fst w) (Suc (r t))) (snd w) (Suc (r t))", "by (auto simp: nth_append)"], ["proof (state)\nthis:\n  atomics' (as @ as') (max (fst w) (Suc (r t))) (snd w) 1 =\n  atomics' as' (max (fst w) (Suc (r t))) (snd w) (Suc (r t))\n\ngoal (1 subgoal):\n 1. r t \\<noteq> snd w \\<Longrightarrow>\n    slide (as @ as') t w = slide' as' t w", "then"], ["proof (chain)\npicking this:\n  atomics' (as @ as') (max (fst w) (Suc (r t))) (snd w) 1 =\n  atomics' as' (max (fst w) (Suc (r t))) (snd w) (Suc (r t))", "show ?thesis"], ["proof (prove)\nusing this:\n  atomics' (as @ as') (max (fst w) (Suc (r t))) (snd w) 1 =\n  atomics' as' (max (fst w) (Suc (r t))) (snd w) (Suc (r t))\n\ngoal (1 subgoal):\n 1. slide (as @ as') t w = slide' as' t w", "unfolding slide_def slide'_def atomics_def"], ["proof (prove)\nusing this:\n  atomics' (as @ as') (max (fst w) (Suc (r t))) (snd w) 1 =\n  atomics' as' (max (fst w) (Suc (r t))) (snd w) (Suc (r t))\n\ngoal (1 subgoal):\n 1. (let ts = atomics' (as @ as') (max (fst w) (Suc (r t))) (snd w) 1;\n         ts' = reusables t w\n     in fold combine (ts @ ts') Leaf) =\n    (let ts = atomics' as' (max (fst w) (Suc (r t))) (snd w) (Suc (r t));\n         ts' = reusables t w\n     in fold combine (ts @ ts') Leaf)", "by presburger"], ["proof (state)\nthis:\n  slide (as @ as') t w = slide' as' t w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_eq_sum_append: \"\\<lbrakk>0 < i; i \\<le> j; j \\<le> length as\\<rbrakk> \\<Longrightarrow> sum as i j = sum (as @ as') i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < i; i \\<le> j; j \\<le> length as\\<rbrakk>\n    \\<Longrightarrow> SWA.sum as i j = SWA.sum (as @ as') i j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < i; i \\<le> j; j \\<le> length as\\<rbrakk>\n    \\<Longrightarrow> SWA.sum as i j = SWA.sum (as @ as') i j", "assume assms: \"0 < i\" \"i \\<le> j\" \"j \\<le> length as\""], ["proof (state)\nthis:\n  0 < i\n  i \\<le> j\n  j \\<le> length as\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < i; i \\<le> j; j \\<le> length as\\<rbrakk>\n    \\<Longrightarrow> SWA.sum as i j = SWA.sum (as @ as') i j", "then"], ["proof (chain)\npicking this:\n  0 < i\n  i \\<le> j\n  j \\<le> length as", "have *: \"rev (map ((!) as) [i - Suc 0..<j - Suc 0]) = rev (map ((!) (as@as')) [i - Suc 0..<j - Suc 0])\""], ["proof (prove)\nusing this:\n  0 < i\n  i \\<le> j\n  j \\<le> length as\n\ngoal (1 subgoal):\n 1. rev (map ((!) as) [i - Suc 0..<j - Suc 0]) =\n    rev (map ((!) (as @ as')) [i - Suc 0..<j - Suc 0])", "by (auto simp: nth_append)"], ["proof (state)\nthis:\n  rev (map ((!) as) [i - Suc 0..<j - Suc 0]) =\n  rev (map ((!) (as @ as')) [i - Suc 0..<j - Suc 0])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < i; i \\<le> j; j \\<le> length as\\<rbrakk>\n    \\<Longrightarrow> SWA.sum as i j = SWA.sum (as @ as') i j", "from assms"], ["proof (chain)\npicking this:\n  0 < i\n  i \\<le> j\n  j \\<le> length as", "have \"as ! (j - Suc 0) = (as @ as') ! (j - Suc 0)\""], ["proof (prove)\nusing this:\n  0 < i\n  i \\<le> j\n  j \\<le> length as\n\ngoal (1 subgoal):\n 1. as ! (j - Suc 0) = (as @ as') ! (j - Suc 0)", "by (auto simp: nth_append)"], ["proof (state)\nthis:\n  as ! (j - Suc 0) = (as @ as') ! (j - Suc 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < i; i \\<le> j; j \\<le> length as\\<rbrakk>\n    \\<Longrightarrow> SWA.sum as i j = SWA.sum (as @ as') i j", "then"], ["proof (chain)\npicking this:\n  as ! (j - Suc 0) = (as @ as') ! (j - Suc 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  as ! (j - Suc 0) = (as @ as') ! (j - Suc 0)\n\ngoal (1 subgoal):\n 1. SWA.sum as i j = SWA.sum (as @ as') i j", "by (simp add: *)"], ["proof (state)\nthis:\n  SWA.sum as i j = SWA.sum (as @ as') i j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma well_valued0_append: \"\\<lbrakk>well_shaped t; well_valued0 as t\\<rbrakk> \\<Longrightarrow> well_valued0 (as @ as') t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>well_shaped t; well_valued0 as t\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (as @ as') t", "proof (induction t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>well_shaped Leaf; well_valued0 as Leaf\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (as @ as') Leaf\n 2. \\<And>x1 x2 x3 t1 t2.\n       \\<lbrakk>\\<lbrakk>well_shaped t1; well_valued0 as t1\\<rbrakk>\n                \\<Longrightarrow> well_valued0 (as @ as') t1;\n        \\<lbrakk>well_shaped t2; well_valued0 as t2\\<rbrakk>\n        \\<Longrightarrow> well_valued0 (as @ as') t2;\n        well_shaped (Node x1 x2 x3 t1 t2);\n        well_valued0 as (Node x1 x2 x3 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (as @ as') (Node x1 x2 x3 t1 t2)", "case (Node i j a t1 t2)"], ["proof (state)\nthis:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (as @ as') t1\n  \\<lbrakk>well_shaped t2; well_valued0 as t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (as @ as') t2\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>well_shaped Leaf; well_valued0 as Leaf\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (as @ as') Leaf\n 2. \\<And>x1 x2 x3 t1 t2.\n       \\<lbrakk>\\<lbrakk>well_shaped t1; well_valued0 as t1\\<rbrakk>\n                \\<Longrightarrow> well_valued0 (as @ as') t1;\n        \\<lbrakk>well_shaped t2; well_valued0 as t2\\<rbrakk>\n        \\<Longrightarrow> well_valued0 (as @ as') t2;\n        well_shaped (Node x1 x2 x3 t1 t2);\n        well_valued0 as (Node x1 x2 x3 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (as @ as') (Node x1 x2 x3 t1 t2)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (as @ as') t1\n  \\<lbrakk>well_shaped t2; well_valued0 as t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (as @ as') t2\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (as @ as') t1\n  \\<lbrakk>well_shaped t2; well_valued0 as t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (as @ as') t2\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n\ngoal (1 subgoal):\n 1. well_valued0 (as @ as') (Node i j a t1 t2)", "using sum_eq_sum_append"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (as @ as') t1\n  \\<lbrakk>well_shaped t2; well_valued0 as t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (as @ as') t2\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n  \\<lbrakk>0 < ?i; ?i \\<le> ?j; ?j \\<le> length ?as\\<rbrakk>\n  \\<Longrightarrow> SWA.sum ?as ?i ?j = SWA.sum (?as @ ?as') ?i ?j\n\ngoal (1 subgoal):\n 1. well_valued0 (as @ as') (Node i j a t1 t2)", "by (auto 4 0)"], ["proof (state)\nthis:\n  well_valued0 (as @ as') (Node i j a t1 t2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>well_shaped Leaf; well_valued0 as Leaf\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (as @ as') Leaf", "qed simp"], ["", "lemma valid_append: \"valid as t \\<Longrightarrow> valid (as @ as') t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid as t \\<Longrightarrow> valid (as @ as') t", "unfolding valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. well_shaped t \\<and> well_valued as t \\<Longrightarrow>\n    well_shaped t \\<and> well_valued (as @ as') t", "by (auto intro: well_valued0_append)"], ["", "lemma valid_slide_append: \"\\<lbrakk>0 < fst w; fst w \\<le> snd w; valid as t; l t \\<le> fst w; r t \\<le> snd w; snd w \\<le> length as + length as'\\<rbrakk> \\<Longrightarrow>\n  valid (as @ as') (slide (as @ as') t w) \\<and> l (slide (as @ as') t w) = fst w \\<and> r (slide (as @ as') t w) = snd w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < fst w; fst w \\<le> snd w; valid as t; l t \\<le> fst w;\n     r t \\<le> snd w; snd w \\<le> length as + length as'\\<rbrakk>\n    \\<Longrightarrow> valid (as @ as') (slide (as @ as') t w) \\<and>\n                      l (slide (as @ as') t w) = fst w \\<and>\n                      r (slide (as @ as') t w) = snd w", "by (auto simp: valid_append valid_slide)"], ["", "(* correctness of alternative slide interface *)"], ["", "theorem valid_slide':\n  assumes \"0 < fst w\" \"fst w \\<le> snd w\" \"valid as t\" \"length as = r t\" \"length as' \\<ge> snd w - r t\" \"l t \\<le> fst w\" \"r t \\<le> snd w\"\n  shows \"valid (as @ as') (slide' as' t w) \\<and> l (slide' as' t w) = fst w \\<and> r (slide' as' t w) = snd w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (as @ as') (slide' as' t w) \\<and>\n    l (slide' as' t w) = fst w \\<and> r (slide' as' t w) = snd w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valid (as @ as') (slide' as' t w) \\<and>\n    l (slide' as' t w) = fst w \\<and> r (slide' as' t w) = snd w", "from assms"], ["proof (chain)\npicking this:\n  0 < fst w\n  fst w \\<le> snd w\n  valid as t\n  length as = r t\n  snd w - r t \\<le> length as'\n  l t \\<le> fst w\n  r t \\<le> snd w", "have \"valid (as @ as') (slide (as @ as') t w) \\<and> l (slide (as @ as') t w) = fst w \\<and> r (slide (as @ as') t w) = snd w\""], ["proof (prove)\nusing this:\n  0 < fst w\n  fst w \\<le> snd w\n  valid as t\n  length as = r t\n  snd w - r t \\<le> length as'\n  l t \\<le> fst w\n  r t \\<le> snd w\n\ngoal (1 subgoal):\n 1. valid (as @ as') (slide (as @ as') t w) \\<and>\n    l (slide (as @ as') t w) = fst w \\<and> r (slide (as @ as') t w) = snd w", "using valid_slide_append"], ["proof (prove)\nusing this:\n  0 < fst w\n  fst w \\<le> snd w\n  valid as t\n  length as = r t\n  snd w - r t \\<le> length as'\n  l t \\<le> fst w\n  r t \\<le> snd w\n  \\<lbrakk>0 < fst ?w; fst ?w \\<le> snd ?w; valid ?as ?t; l ?t \\<le> fst ?w;\n   r ?t \\<le> snd ?w; snd ?w \\<le> length ?as + length ?as'\\<rbrakk>\n  \\<Longrightarrow> valid (?as @ ?as') (slide (?as @ ?as') ?t ?w) \\<and>\n                    l (slide (?as @ ?as') ?t ?w) = fst ?w \\<and>\n                    r (slide (?as @ ?as') ?t ?w) = snd ?w\n\ngoal (1 subgoal):\n 1. valid (as @ as') (slide (as @ as') t w) \\<and>\n    l (slide (as @ as') t w) = fst w \\<and> r (slide (as @ as') t w) = snd w", "by (metis add_le_cancel_left le_add_diff_inverse)"], ["proof (state)\nthis:\n  valid (as @ as') (slide (as @ as') t w) \\<and>\n  l (slide (as @ as') t w) = fst w \\<and> r (slide (as @ as') t w) = snd w\n\ngoal (1 subgoal):\n 1. valid (as @ as') (slide' as' t w) \\<and>\n    l (slide' as' t w) = fst w \\<and> r (slide' as' t w) = snd w", "with assms"], ["proof (chain)\npicking this:\n  0 < fst w\n  fst w \\<le> snd w\n  valid as t\n  length as = r t\n  snd w - r t \\<le> length as'\n  l t \\<le> fst w\n  r t \\<le> snd w\n  valid (as @ as') (slide (as @ as') t w) \\<and>\n  l (slide (as @ as') t w) = fst w \\<and> r (slide (as @ as') t w) = snd w", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < fst w\n  fst w \\<le> snd w\n  valid as t\n  length as = r t\n  snd w - r t \\<le> length as'\n  l t \\<le> fst w\n  r t \\<le> snd w\n  valid (as @ as') (slide (as @ as') t w) \\<and>\n  l (slide (as @ as') t w) = fst w \\<and> r (slide (as @ as') t w) = snd w\n\ngoal (1 subgoal):\n 1. valid (as @ as') (slide' as' t w) \\<and>\n    l (slide' as' t w) = fst w \\<and> r (slide' as' t w) = snd w", "using slide_eq_slide'"], ["proof (prove)\nusing this:\n  0 < fst w\n  fst w \\<le> snd w\n  valid as t\n  length as = r t\n  snd w - r t \\<le> length as'\n  l t \\<le> fst w\n  r t \\<le> snd w\n  valid (as @ as') (slide (as @ as') t w) \\<and>\n  l (slide (as @ as') t w) = fst w \\<and> r (slide (as @ as') t w) = snd w\n  \\<lbrakk>0 < fst ?w; fst ?w \\<le> snd ?w; valid ?as ?t; r ?t = length ?as;\n   l ?t \\<le> fst ?w; r ?t \\<le> snd ?w;\n   snd ?w \\<le> length (?as @ ?as')\\<rbrakk>\n  \\<Longrightarrow> slide (?as @ ?as') ?t ?w = slide' ?as' ?t ?w\n\ngoal (1 subgoal):\n 1. valid (as @ as') (slide' as' t w) \\<and>\n    l (slide' as' t w) = fst w \\<and> r (slide' as' t w) = snd w", "by (metis add_le_cancel_left le_add_diff_inverse length_append)"], ["proof (state)\nthis:\n  valid (as @ as') (slide' as' t w) \\<and>\n  l (slide' as' t w) = fst w \\<and> r (slide' as' t w) = snd w\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Updating all Values in the Tree\\<close>"], ["", "text \\<open>\n  So far, we have assumed that the sequence is fixed. However, under certain conditions,\n  SWA can be applied even if the sequence changes. In particular, if a function that distributes\n  over the associative operation is mapped onto the sequence, validity of the tree can be preserved\n  by mapping the same function onto the tree using @{term map_tree}.\n\\<close>"], ["", "lemma map_tree_eq_Leaf_iff: \"map_tree f t = Leaf \\<longleftrightarrow> t = Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_tree f t = Leaf) = (t = Leaf)", "by simp"], ["", "lemma l_map_tree_eq_l[simp]: \"l (map_tree f t) = l t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l (map_tree f t) = l t", "by (cases t)\n    (auto split: option.splits)"], ["", "lemma r_map_tree_eq_r[simp]: \"r (map_tree f t) = r t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r (map_tree f t) = r t", "by (cases t)\n    (auto split: option.splits)"], ["", "lemma val_map_tree_neq_None: \"val t \\<noteq> None \\<Longrightarrow> val (map_tree f t) \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val t \\<noteq> None \\<Longrightarrow> val (map_tree f t) \\<noteq> None", "by (cases t) auto"], ["", "lemma well_shaped_map_tree: \"well_shaped t \\<Longrightarrow> well_shaped (map_tree f t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_shaped t \\<Longrightarrow> well_shaped (map_tree f t)", "by (induction t)\n    (auto split: option.split)"], ["", "lemma fold_distr: \"(\\<forall>x y. f (x + y) = f x + f y) \\<Longrightarrow> f (fold (+) list e) = fold (+) (map f list) (f e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. f (x + y) = f x + f y \\<Longrightarrow>\n    f (fold (+) list e) = fold (+) (map f list) (f e)", "by (induction list arbitrary: e) auto"], ["", "lemma map_rev_map_nth_eq: \"\\<forall>x \\<in> set xs. x < length as \\<Longrightarrow> map f (rev (map ((!) as) xs)) = rev (map ((!) (map f as)) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs. x < length as \\<Longrightarrow>\n    map f (rev (map ((!) as) xs)) = rev (map ((!) (map f as)) xs)", "by (simp add: rev_map)"], ["", "lemma f_nth_eq_map_f_nth: \"\\<lbrakk>as \\<noteq> []; length as \\<ge> n\\<rbrakk> \\<Longrightarrow> f (as ! (n - Suc 0)) = map f as ! (n - Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>as \\<noteq> []; n \\<le> length as\\<rbrakk>\n    \\<Longrightarrow> f (as ! (n - Suc 0)) = map f as ! (n - Suc 0)", "by (cases \"n = length as\") auto"], ["", "lemma well_valued0_map_map_tree:\n   \"\\<lbrakk>\\<forall>x y. f (x + y) = f x + f y; well_shaped t; well_valued0 as t; r t \\<le> length as; as \\<noteq> []\\<rbrakk> \\<Longrightarrow>\n     well_shaped (map_tree f t) \\<and> well_valued0 (map f as) (map_tree f t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x y. f (x + y) = f x + f y; well_shaped t;\n     well_valued0 as t; r t \\<le> length as; as \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> well_shaped (map_tree f t) \\<and>\n                      well_valued0 (map f as) (map_tree f t)", "proof (rule conjI[OF well_shaped_map_tree], assumption, induction t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x y. f (x + y) = f x + f y; well_shaped Leaf;\n     well_valued0 as Leaf; r Leaf \\<le> length as; as \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (map f as) (map_tree f Leaf)\n 2. \\<And>x1 x2 x3 t1 t2.\n       \\<lbrakk>\\<lbrakk>\\<forall>x y. f (x + y) = f x + f y;\n                 well_shaped t1; well_valued0 as t1; r t1 \\<le> length as;\n                 as \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> well_valued0 (map f as) (map_tree f t1);\n        \\<lbrakk>\\<forall>x y. f (x + y) = f x + f y; well_shaped t2;\n         well_valued0 as t2; r t2 \\<le> length as; as \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> well_valued0 (map f as) (map_tree f t2);\n        \\<forall>x y. f (x + y) = f x + f y;\n        well_shaped (Node x1 x2 x3 t1 t2);\n        well_valued0 as (Node x1 x2 x3 t1 t2);\n        r (Node x1 x2 x3 t1 t2) \\<le> length as; as \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (map f as)\n                          (map_tree f (Node x1 x2 x3 t1 t2))", "case (Node i j a t1 t2)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>x y. f (x + y) = f x + f y; well_shaped t1;\n   well_valued0 as t1; r t1 \\<le> length as; as \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (map f as) (map_tree f t1)\n  \\<lbrakk>\\<forall>x y. f (x + y) = f x + f y; well_shaped t2;\n   well_valued0 as t2; r t2 \\<le> length as; as \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (map f as) (map_tree f t2)\n  \\<forall>x y. f (x + y) = f x + f y\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n  r (Node i j a t1 t2) \\<le> length as\n  as \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x y. f (x + y) = f x + f y; well_shaped Leaf;\n     well_valued0 as Leaf; r Leaf \\<le> length as; as \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (map f as) (map_tree f Leaf)\n 2. \\<And>x1 x2 x3 t1 t2.\n       \\<lbrakk>\\<lbrakk>\\<forall>x y. f (x + y) = f x + f y;\n                 well_shaped t1; well_valued0 as t1; r t1 \\<le> length as;\n                 as \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> well_valued0 (map f as) (map_tree f t1);\n        \\<lbrakk>\\<forall>x y. f (x + y) = f x + f y; well_shaped t2;\n         well_valued0 as t2; r t2 \\<le> length as; as \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> well_valued0 (map f as) (map_tree f t2);\n        \\<forall>x y. f (x + y) = f x + f y;\n        well_shaped (Node x1 x2 x3 t1 t2);\n        well_valued0 as (Node x1 x2 x3 t1 t2);\n        r (Node x1 x2 x3 t1 t2) \\<le> length as; as \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (map f as)\n                          (map_tree f (Node x1 x2 x3 t1 t2))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>x y. f (x + y) = f x + f y; well_shaped t1;\n   well_valued0 as t1; r t1 \\<le> length as; as \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (map f as) (map_tree f t1)\n  \\<lbrakk>\\<forall>x y. f (x + y) = f x + f y; well_shaped t2;\n   well_valued0 as t2; r t2 \\<le> length as; as \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (map f as) (map_tree f t2)\n  \\<forall>x y. f (x + y) = f x + f y\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n  r (Node i j a t1 t2) \\<le> length as\n  as \\<noteq> []", "have \"map f (rev (map ((!) as) [l t1 - Suc 0..<r t2 - Suc 0])) =\n    rev (map ((!) (map f as)) [l t1 - Suc 0..<r t2 - Suc 0])\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>x y. f (x + y) = f x + f y; well_shaped t1;\n   well_valued0 as t1; r t1 \\<le> length as; as \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (map f as) (map_tree f t1)\n  \\<lbrakk>\\<forall>x y. f (x + y) = f x + f y; well_shaped t2;\n   well_valued0 as t2; r t2 \\<le> length as; as \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (map f as) (map_tree f t2)\n  \\<forall>x y. f (x + y) = f x + f y\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n  r (Node i j a t1 t2) \\<le> length as\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. map f (rev (map ((!) as) [l t1 - Suc 0..<r t2 - Suc 0])) =\n    rev (map ((!) (map f as)) [l t1 - Suc 0..<r t2 - Suc 0])", "by (subst map_rev_map_nth_eq) auto"], ["proof (state)\nthis:\n  map f (rev (map ((!) as) [l t1 - Suc 0..<r t2 - Suc 0])) =\n  rev (map ((!) (map f as)) [l t1 - Suc 0..<r t2 - Suc 0])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x y. f (x + y) = f x + f y; well_shaped Leaf;\n     well_valued0 as Leaf; r Leaf \\<le> length as; as \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (map f as) (map_tree f Leaf)\n 2. \\<And>x1 x2 x3 t1 t2.\n       \\<lbrakk>\\<lbrakk>\\<forall>x y. f (x + y) = f x + f y;\n                 well_shaped t1; well_valued0 as t1; r t1 \\<le> length as;\n                 as \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> well_valued0 (map f as) (map_tree f t1);\n        \\<lbrakk>\\<forall>x y. f (x + y) = f x + f y; well_shaped t2;\n         well_valued0 as t2; r t2 \\<le> length as; as \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> well_valued0 (map f as) (map_tree f t2);\n        \\<forall>x y. f (x + y) = f x + f y;\n        well_shaped (Node x1 x2 x3 t1 t2);\n        well_valued0 as (Node x1 x2 x3 t1 t2);\n        r (Node x1 x2 x3 t1 t2) \\<le> length as; as \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (map f as)\n                          (map_tree f (Node x1 x2 x3 t1 t2))", "moreover"], ["proof (state)\nthis:\n  map f (rev (map ((!) as) [l t1 - Suc 0..<r t2 - Suc 0])) =\n  rev (map ((!) (map f as)) [l t1 - Suc 0..<r t2 - Suc 0])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x y. f (x + y) = f x + f y; well_shaped Leaf;\n     well_valued0 as Leaf; r Leaf \\<le> length as; as \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (map f as) (map_tree f Leaf)\n 2. \\<And>x1 x2 x3 t1 t2.\n       \\<lbrakk>\\<lbrakk>\\<forall>x y. f (x + y) = f x + f y;\n                 well_shaped t1; well_valued0 as t1; r t1 \\<le> length as;\n                 as \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> well_valued0 (map f as) (map_tree f t1);\n        \\<lbrakk>\\<forall>x y. f (x + y) = f x + f y; well_shaped t2;\n         well_valued0 as t2; r t2 \\<le> length as; as \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> well_valued0 (map f as) (map_tree f t2);\n        \\<forall>x y. f (x + y) = f x + f y;\n        well_shaped (Node x1 x2 x3 t1 t2);\n        well_valued0 as (Node x1 x2 x3 t1 t2);\n        r (Node x1 x2 x3 t1 t2) \\<le> length as; as \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (map f as)\n                          (map_tree f (Node x1 x2 x3 t1 t2))", "from Node"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>x y. f (x + y) = f x + f y; well_shaped t1;\n   well_valued0 as t1; r t1 \\<le> length as; as \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (map f as) (map_tree f t1)\n  \\<lbrakk>\\<forall>x y. f (x + y) = f x + f y; well_shaped t2;\n   well_valued0 as t2; r t2 \\<le> length as; as \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (map f as) (map_tree f t2)\n  \\<forall>x y. f (x + y) = f x + f y\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n  r (Node i j a t1 t2) \\<le> length as\n  as \\<noteq> []", "have \"r t1 \\<le> length as\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>x y. f (x + y) = f x + f y; well_shaped t1;\n   well_valued0 as t1; r t1 \\<le> length as; as \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (map f as) (map_tree f t1)\n  \\<lbrakk>\\<forall>x y. f (x + y) = f x + f y; well_shaped t2;\n   well_valued0 as t2; r t2 \\<le> length as; as \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (map f as) (map_tree f t2)\n  \\<forall>x y. f (x + y) = f x + f y\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n  r (Node i j a t1 t2) \\<le> length as\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. r t1 \\<le> length as", "by (cases t1) auto"], ["proof (state)\nthis:\n  r t1 \\<le> length as\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x y. f (x + y) = f x + f y; well_shaped Leaf;\n     well_valued0 as Leaf; r Leaf \\<le> length as; as \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (map f as) (map_tree f Leaf)\n 2. \\<And>x1 x2 x3 t1 t2.\n       \\<lbrakk>\\<lbrakk>\\<forall>x y. f (x + y) = f x + f y;\n                 well_shaped t1; well_valued0 as t1; r t1 \\<le> length as;\n                 as \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> well_valued0 (map f as) (map_tree f t1);\n        \\<lbrakk>\\<forall>x y. f (x + y) = f x + f y; well_shaped t2;\n         well_valued0 as t2; r t2 \\<le> length as; as \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> well_valued0 (map f as) (map_tree f t2);\n        \\<forall>x y. f (x + y) = f x + f y;\n        well_shaped (Node x1 x2 x3 t1 t2);\n        well_valued0 as (Node x1 x2 x3 t1 t2);\n        r (Node x1 x2 x3 t1 t2) \\<le> length as; as \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (map f as)\n                          (map_tree f (Node x1 x2 x3 t1 t2))", "ultimately"], ["proof (chain)\npicking this:\n  map f (rev (map ((!) as) [l t1 - Suc 0..<r t2 - Suc 0])) =\n  rev (map ((!) (map f as)) [l t1 - Suc 0..<r t2 - Suc 0])\n  r t1 \\<le> length as", "show ?case"], ["proof (prove)\nusing this:\n  map f (rev (map ((!) as) [l t1 - Suc 0..<r t2 - Suc 0])) =\n  rev (map ((!) (map f as)) [l t1 - Suc 0..<r t2 - Suc 0])\n  r t1 \\<le> length as\n\ngoal (1 subgoal):\n 1. well_valued0 (map f as) (map_tree f (Node i j a t1 t2))", "using Node(3-7)"], ["proof (prove)\nusing this:\n  map f (rev (map ((!) as) [l t1 - Suc 0..<r t2 - Suc 0])) =\n  rev (map ((!) (map f as)) [l t1 - Suc 0..<r t2 - Suc 0])\n  r t1 \\<le> length as\n  \\<forall>x y. f (x + y) = f x + f y\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n  r (Node i j a t1 t2) \\<le> length as\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. well_valued0 (map f as) (map_tree f (Node i j a t1 t2))", "by (auto simp: fold_distr[of f] val_map_tree_neq_None\n      well_shaped_map_tree intro!: Node(1,2))"], ["proof (state)\nthis:\n  well_valued0 (map f as) (map_tree f (Node i j a t1 t2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x y. f (x + y) = f x + f y; well_shaped Leaf;\n     well_valued0 as Leaf; r Leaf \\<le> length as; as \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (map f as) (map_tree f Leaf)", "qed simp"], ["", "lemma valid_map_map_tree:\n  assumes \"\\<forall>x y. f (x + y) = f x + f y\" \"valid as t\" \"r t \\<le> length as\"\n  shows \"valid (map f as) (map_tree f t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (map f as) (map_tree f t)", "proof (cases \"as \\<noteq> []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. as \\<noteq> [] \\<Longrightarrow> valid (map f as) (map_tree f t)\n 2. \\<not> as \\<noteq> [] \\<Longrightarrow> valid (map f as) (map_tree f t)", "case True"], ["proof (state)\nthis:\n  as \\<noteq> []\n\ngoal (2 subgoals):\n 1. as \\<noteq> [] \\<Longrightarrow> valid (map f as) (map_tree f t)\n 2. \\<not> as \\<noteq> [] \\<Longrightarrow> valid (map f as) (map_tree f t)", "with assms"], ["proof (chain)\npicking this:\n  \\<forall>x y. f (x + y) = f x + f y\n  valid as t\n  r t \\<le> length as\n  as \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x y. f (x + y) = f x + f y\n  valid as t\n  r t \\<le> length as\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. valid (map f as) (map_tree f t)", "by (metis map_tree_eq_Leaf_iff val_map_tree_neq_None valid_def well_valued0_map_map_tree)"], ["proof (state)\nthis:\n  valid (map f as) (map_tree f t)\n\ngoal (1 subgoal):\n 1. \\<not> as \\<noteq> [] \\<Longrightarrow> valid (map f as) (map_tree f t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> as \\<noteq> [] \\<Longrightarrow> valid (map f as) (map_tree f t)", "case False"], ["proof (state)\nthis:\n  \\<not> as \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> as \\<noteq> [] \\<Longrightarrow> valid (map f as) (map_tree f t)", "with assms"], ["proof (chain)\npicking this:\n  \\<forall>x y. f (x + y) = f x + f y\n  valid as t\n  r t \\<le> length as\n  \\<not> as \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x y. f (x + y) = f x + f y\n  valid as t\n  r t \\<le> length as\n  \\<not> as \\<noteq> []\n\ngoal (1 subgoal):\n 1. valid (map f as) (map_tree f t)", "by (metis le_zero_eq list.size(3) tree.exhaust_sel map_tree_eq_Leaf_iff valid_Leaf valid_def well_shaped.simps(2) well_valued0.simps(2))"], ["proof (state)\nthis:\n  valid (map f as) (map_tree f t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_Nil_iff: \"valid [] t \\<longleftrightarrow> t = Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid [] t = (t = Leaf)", "unfolding valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (well_shaped t \\<and> well_valued [] t) = (t = Leaf)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. well_shaped t \\<and> well_valued [] t \\<Longrightarrow> t = Leaf\n 2. t = Leaf \\<Longrightarrow> well_shaped t \\<and> well_valued [] t", "assume \"well_shaped t \\<and> well_valued [] t\""], ["proof (state)\nthis:\n  well_shaped t \\<and> well_valued [] t\n\ngoal (2 subgoals):\n 1. well_shaped t \\<and> well_valued [] t \\<Longrightarrow> t = Leaf\n 2. t = Leaf \\<Longrightarrow> well_shaped t \\<and> well_valued [] t", "then"], ["proof (chain)\npicking this:\n  well_shaped t \\<and> well_valued [] t", "show \"t = Leaf\""], ["proof (prove)\nusing this:\n  well_shaped t \\<and> well_valued [] t\n\ngoal (1 subgoal):\n 1. t = Leaf", "by (metis le_neq_implies_less list.size(3) not_less_zero tree.collapse well_shaped.simps(2) well_valued0.simps(2))"], ["proof (state)\nthis:\n  t = Leaf\n\ngoal (1 subgoal):\n 1. t = Leaf \\<Longrightarrow> well_shaped t \\<and> well_valued [] t", "qed simp"], ["", "subsection \\<open>Updating the Rightmost Leaf of the Tree\\<close>"], ["", "text \\<open>\n  We provide a function to update the rightmost leaf of the tree. This may be used in an online\n  setting where the input sequence is not known in advance to update the latest observed element\n  using the same associative operation used in SWA. We show that validity of the tree is preserved\n  in this case.\n\\<close>"], ["", "fun update_rightmost :: \"('a \\<Rightarrow> 'a) \\<Rightarrow> 'a tree \\<Rightarrow> 'a tree\" where\n  \"update_rightmost _ Leaf = Leaf\"\n| \"update_rightmost f (Node i j a t u) = Node i j (map_option f a) t (update_rightmost f u)\""], ["", "lemma update_rightmost_eq_Leaf_iff: \"update_rightmost f t = Leaf \\<longleftrightarrow> t = Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (update_rightmost f t = Leaf) = (t = Leaf)", "by (cases t)\n    (auto split: option.splits)"], ["", "lemma l_update_rightmost_eq_l[simp]: \"l (update_rightmost f t) = l t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l (update_rightmost f t) = l t", "by (cases t)\n    (auto split: option.splits)"], ["", "lemma r_update_rightmost_eq_r[simp]: \"r (update_rightmost f t) = r t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r (update_rightmost f t) = r t", "by (cases t)\n    (auto split: option.splits)"], ["", "lemma val_update_rightmost_neq_None: \"val t \\<noteq> None \\<Longrightarrow> val (update_rightmost f t) \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val t \\<noteq> None \\<Longrightarrow>\n    val (update_rightmost f t) \\<noteq> None", "by (cases t) auto"], ["", "lemma well_shaped_update_rightmost: \"well_shaped t \\<Longrightarrow> well_shaped (update_rightmost f t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_shaped t \\<Longrightarrow> well_shaped (update_rightmost f t)", "by (induction t)\n    (auto simp: update_rightmost_eq_Leaf_iff split: option.split)"], ["", "lemma sum_eq_sum_prepend: \"\\<lbrakk>0 < i; i \\<le> j; length xs < i; length ys = length xs\\<rbrakk> \\<Longrightarrow> sum (xs @ as) i j = sum (ys @ as) i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < i; i \\<le> j; length xs < i; length ys = length xs\\<rbrakk>\n    \\<Longrightarrow> SWA.sum (xs @ as) i j = SWA.sum (ys @ as) i j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < i; i \\<le> j; length xs < i; length ys = length xs\\<rbrakk>\n    \\<Longrightarrow> SWA.sum (xs @ as) i j = SWA.sum (ys @ as) i j", "assume assms: \"0 < i\" \"i \\<le> j\" \"length xs < i\" \"length ys = length xs\""], ["proof (state)\nthis:\n  0 < i\n  i \\<le> j\n  length xs < i\n  length ys = length xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < i; i \\<le> j; length xs < i; length ys = length xs\\<rbrakk>\n    \\<Longrightarrow> SWA.sum (xs @ as) i j = SWA.sum (ys @ as) i j", "then"], ["proof (chain)\npicking this:\n  0 < i\n  i \\<le> j\n  length xs < i\n  length ys = length xs", "have *: \"rev (map ((!) (xs @ as)) [i - Suc 0..<j - Suc 0]) = rev (map ((!) (ys @ as)) [i - Suc 0..<j - Suc 0])\""], ["proof (prove)\nusing this:\n  0 < i\n  i \\<le> j\n  length xs < i\n  length ys = length xs\n\ngoal (1 subgoal):\n 1. rev (map ((!) (xs @ as)) [i - Suc 0..<j - Suc 0]) =\n    rev (map ((!) (ys @ as)) [i - Suc 0..<j - Suc 0])", "by (auto simp: nth_append)"], ["proof (state)\nthis:\n  rev (map ((!) (xs @ as)) [i - Suc 0..<j - Suc 0]) =\n  rev (map ((!) (ys @ as)) [i - Suc 0..<j - Suc 0])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < i; i \\<le> j; length xs < i; length ys = length xs\\<rbrakk>\n    \\<Longrightarrow> SWA.sum (xs @ as) i j = SWA.sum (ys @ as) i j", "from assms"], ["proof (chain)\npicking this:\n  0 < i\n  i \\<le> j\n  length xs < i\n  length ys = length xs", "have \"(xs @ as) ! (j - Suc 0) = (ys @ as) ! (j - Suc 0)\""], ["proof (prove)\nusing this:\n  0 < i\n  i \\<le> j\n  length xs < i\n  length ys = length xs\n\ngoal (1 subgoal):\n 1. (xs @ as) ! (j - Suc 0) = (ys @ as) ! (j - Suc 0)", "by (auto simp: nth_append)"], ["proof (state)\nthis:\n  (xs @ as) ! (j - Suc 0) = (ys @ as) ! (j - Suc 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < i; i \\<le> j; length xs < i; length ys = length xs\\<rbrakk>\n    \\<Longrightarrow> SWA.sum (xs @ as) i j = SWA.sum (ys @ as) i j", "then"], ["proof (chain)\npicking this:\n  (xs @ as) ! (j - Suc 0) = (ys @ as) ! (j - Suc 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  (xs @ as) ! (j - Suc 0) = (ys @ as) ! (j - Suc 0)\n\ngoal (1 subgoal):\n 1. SWA.sum (xs @ as) i j = SWA.sum (ys @ as) i j", "by (simp add: *)"], ["proof (state)\nthis:\n  SWA.sum (xs @ as) i j = SWA.sum (ys @ as) i j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma well_valued0_prepend: \"\\<lbrakk>length xs \\<le> l t - 1; length ys = length xs; well_shaped t; well_valued0 (xs @ as) t\\<rbrakk> \\<Longrightarrow> well_valued0 (ys @ as) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs \\<le> l t - 1; length ys = length xs; well_shaped t;\n     well_valued0 (xs @ as) t\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (ys @ as) t", "proof (induction t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>length xs \\<le> l Leaf - 1; length ys = length xs;\n     well_shaped Leaf; well_valued0 (xs @ as) Leaf\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (ys @ as) Leaf\n 2. \\<And>x1 x2 x3 t1 t2.\n       \\<lbrakk>\\<lbrakk>length xs \\<le> l t1 - 1; length ys = length xs;\n                 well_shaped t1; well_valued0 (xs @ as) t1\\<rbrakk>\n                \\<Longrightarrow> well_valued0 (ys @ as) t1;\n        \\<lbrakk>length xs \\<le> l t2 - 1; length ys = length xs;\n         well_shaped t2; well_valued0 (xs @ as) t2\\<rbrakk>\n        \\<Longrightarrow> well_valued0 (ys @ as) t2;\n        length xs \\<le> l (Node x1 x2 x3 t1 t2) - 1; length ys = length xs;\n        well_shaped (Node x1 x2 x3 t1 t2);\n        well_valued0 (xs @ as) (Node x1 x2 x3 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (ys @ as) (Node x1 x2 x3 t1 t2)", "case (Node i j a t1 t2)"], ["proof (state)\nthis:\n  \\<lbrakk>length xs \\<le> l t1 - 1; length ys = length xs; well_shaped t1;\n   well_valued0 (xs @ as) t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (ys @ as) t1\n  \\<lbrakk>length xs \\<le> l t2 - 1; length ys = length xs; well_shaped t2;\n   well_valued0 (xs @ as) t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (ys @ as) t2\n  length xs \\<le> l (Node i j a t1 t2) - 1\n  length ys = length xs\n  well_shaped (Node i j a t1 t2)\n  well_valued0 (xs @ as) (Node i j a t1 t2)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>length xs \\<le> l Leaf - 1; length ys = length xs;\n     well_shaped Leaf; well_valued0 (xs @ as) Leaf\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (ys @ as) Leaf\n 2. \\<And>x1 x2 x3 t1 t2.\n       \\<lbrakk>\\<lbrakk>length xs \\<le> l t1 - 1; length ys = length xs;\n                 well_shaped t1; well_valued0 (xs @ as) t1\\<rbrakk>\n                \\<Longrightarrow> well_valued0 (ys @ as) t1;\n        \\<lbrakk>length xs \\<le> l t2 - 1; length ys = length xs;\n         well_shaped t2; well_valued0 (xs @ as) t2\\<rbrakk>\n        \\<Longrightarrow> well_valued0 (ys @ as) t2;\n        length xs \\<le> l (Node x1 x2 x3 t1 t2) - 1; length ys = length xs;\n        well_shaped (Node x1 x2 x3 t1 t2);\n        well_valued0 (xs @ as) (Node x1 x2 x3 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (ys @ as) (Node x1 x2 x3 t1 t2)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>length xs \\<le> l t1 - 1; length ys = length xs; well_shaped t1;\n   well_valued0 (xs @ as) t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (ys @ as) t1\n  \\<lbrakk>length xs \\<le> l t2 - 1; length ys = length xs; well_shaped t2;\n   well_valued0 (xs @ as) t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (ys @ as) t2\n  length xs \\<le> l (Node i j a t1 t2) - 1\n  length ys = length xs\n  well_shaped (Node i j a t1 t2)\n  well_valued0 (xs @ as) (Node i j a t1 t2)", "have well_valued0_t1: \"well_valued0 (ys @ as) t1\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length xs \\<le> l t1 - 1; length ys = length xs; well_shaped t1;\n   well_valued0 (xs @ as) t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (ys @ as) t1\n  \\<lbrakk>length xs \\<le> l t2 - 1; length ys = length xs; well_shaped t2;\n   well_valued0 (xs @ as) t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (ys @ as) t2\n  length xs \\<le> l (Node i j a t1 t2) - 1\n  length ys = length xs\n  well_shaped (Node i j a t1 t2)\n  well_valued0 (xs @ as) (Node i j a t1 t2)\n\ngoal (1 subgoal):\n 1. well_valued0 (ys @ as) t1", "by auto"], ["proof (state)\nthis:\n  well_valued0 (ys @ as) t1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>length xs \\<le> l Leaf - 1; length ys = length xs;\n     well_shaped Leaf; well_valued0 (xs @ as) Leaf\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (ys @ as) Leaf\n 2. \\<And>x1 x2 x3 t1 t2.\n       \\<lbrakk>\\<lbrakk>length xs \\<le> l t1 - 1; length ys = length xs;\n                 well_shaped t1; well_valued0 (xs @ as) t1\\<rbrakk>\n                \\<Longrightarrow> well_valued0 (ys @ as) t1;\n        \\<lbrakk>length xs \\<le> l t2 - 1; length ys = length xs;\n         well_shaped t2; well_valued0 (xs @ as) t2\\<rbrakk>\n        \\<Longrightarrow> well_valued0 (ys @ as) t2;\n        length xs \\<le> l (Node x1 x2 x3 t1 t2) - 1; length ys = length xs;\n        well_shaped (Node x1 x2 x3 t1 t2);\n        well_valued0 (xs @ as) (Node x1 x2 x3 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (ys @ as) (Node x1 x2 x3 t1 t2)", "from Node"], ["proof (chain)\npicking this:\n  \\<lbrakk>length xs \\<le> l t1 - 1; length ys = length xs; well_shaped t1;\n   well_valued0 (xs @ as) t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (ys @ as) t1\n  \\<lbrakk>length xs \\<le> l t2 - 1; length ys = length xs; well_shaped t2;\n   well_valued0 (xs @ as) t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (ys @ as) t2\n  length xs \\<le> l (Node i j a t1 t2) - 1\n  length ys = length xs\n  well_shaped (Node i j a t1 t2)\n  well_valued0 (xs @ as) (Node i j a t1 t2)", "have \"well_valued0 (ys @ as) t2\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length xs \\<le> l t1 - 1; length ys = length xs; well_shaped t1;\n   well_valued0 (xs @ as) t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (ys @ as) t1\n  \\<lbrakk>length xs \\<le> l t2 - 1; length ys = length xs; well_shaped t2;\n   well_valued0 (xs @ as) t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (ys @ as) t2\n  length xs \\<le> l (Node i j a t1 t2) - 1\n  length ys = length xs\n  well_shaped (Node i j a t1 t2)\n  well_valued0 (xs @ as) (Node i j a t1 t2)\n\ngoal (1 subgoal):\n 1. well_valued0 (ys @ as) t2", "proof (cases a)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>length xs \\<le> l t1 - 1; length ys = length xs;\n              well_shaped t1; well_valued0 (xs @ as) t1\\<rbrakk>\n             \\<Longrightarrow> well_valued0 (ys @ as) t1;\n     \\<lbrakk>length xs \\<le> l t2 - 1; length ys = length xs;\n      well_shaped t2; well_valued0 (xs @ as) t2\\<rbrakk>\n     \\<Longrightarrow> well_valued0 (ys @ as) t2;\n     length xs \\<le> l (Node i j a t1 t2) - 1; length ys = length xs;\n     well_shaped (Node i j a t1 t2);\n     well_valued0 (xs @ as) (Node i j a t1 t2); a = None\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (ys @ as) t2\n 2. \\<And>aa.\n       \\<lbrakk>\\<lbrakk>length xs \\<le> l t1 - 1; length ys = length xs;\n                 well_shaped t1; well_valued0 (xs @ as) t1\\<rbrakk>\n                \\<Longrightarrow> well_valued0 (ys @ as) t1;\n        \\<lbrakk>length xs \\<le> l t2 - 1; length ys = length xs;\n         well_shaped t2; well_valued0 (xs @ as) t2\\<rbrakk>\n        \\<Longrightarrow> well_valued0 (ys @ as) t2;\n        length xs \\<le> l (Node i j a t1 t2) - 1; length ys = length xs;\n        well_shaped (Node i j a t1 t2);\n        well_valued0 (xs @ as) (Node i j a t1 t2); a = Some aa\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (ys @ as) t2", "case None"], ["proof (state)\nthis:\n  a = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>length xs \\<le> l t1 - 1; length ys = length xs;\n              well_shaped t1; well_valued0 (xs @ as) t1\\<rbrakk>\n             \\<Longrightarrow> well_valued0 (ys @ as) t1;\n     \\<lbrakk>length xs \\<le> l t2 - 1; length ys = length xs;\n      well_shaped t2; well_valued0 (xs @ as) t2\\<rbrakk>\n     \\<Longrightarrow> well_valued0 (ys @ as) t2;\n     length xs \\<le> l (Node i j a t1 t2) - 1; length ys = length xs;\n     well_shaped (Node i j a t1 t2);\n     well_valued0 (xs @ as) (Node i j a t1 t2); a = None\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (ys @ as) t2\n 2. \\<And>aa.\n       \\<lbrakk>\\<lbrakk>length xs \\<le> l t1 - 1; length ys = length xs;\n                 well_shaped t1; well_valued0 (xs @ as) t1\\<rbrakk>\n                \\<Longrightarrow> well_valued0 (ys @ as) t1;\n        \\<lbrakk>length xs \\<le> l t2 - 1; length ys = length xs;\n         well_shaped t2; well_valued0 (xs @ as) t2\\<rbrakk>\n        \\<Longrightarrow> well_valued0 (ys @ as) t2;\n        length xs \\<le> l (Node i j a t1 t2) - 1; length ys = length xs;\n        well_shaped (Node i j a t1 t2);\n        well_valued0 (xs @ as) (Node i j a t1 t2); a = Some aa\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (ys @ as) t2", "with Node"], ["proof (chain)\npicking this:\n  \\<lbrakk>length xs \\<le> l t1 - 1; length ys = length xs; well_shaped t1;\n   well_valued0 (xs @ as) t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (ys @ as) t1\n  \\<lbrakk>length xs \\<le> l t2 - 1; length ys = length xs; well_shaped t2;\n   well_valued0 (xs @ as) t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (ys @ as) t2\n  length xs \\<le> l (Node i j a t1 t2) - 1\n  length ys = length xs\n  well_shaped (Node i j a t1 t2)\n  well_valued0 (xs @ as) (Node i j a t1 t2)\n  a = None", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>length xs \\<le> l t1 - 1; length ys = length xs; well_shaped t1;\n   well_valued0 (xs @ as) t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (ys @ as) t1\n  \\<lbrakk>length xs \\<le> l t2 - 1; length ys = length xs; well_shaped t2;\n   well_valued0 (xs @ as) t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (ys @ as) t2\n  length xs \\<le> l (Node i j a t1 t2) - 1\n  length ys = length xs\n  well_shaped (Node i j a t1 t2)\n  well_valued0 (xs @ as) (Node i j a t1 t2)\n  a = None\n\ngoal (1 subgoal):\n 1. well_valued0 (ys @ as) t2", "by auto\n        (metis One_nat_def Suc_pred diff_Suc_1 le_Suc_eq le_Suc_ex trans_le_add1 tree.exhaust_sel well_shaped.simps(2))"], ["proof (state)\nthis:\n  well_valued0 (ys @ as) t2\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>\\<lbrakk>length xs \\<le> l t1 - 1; length ys = length xs;\n                 well_shaped t1; well_valued0 (xs @ as) t1\\<rbrakk>\n                \\<Longrightarrow> well_valued0 (ys @ as) t1;\n        \\<lbrakk>length xs \\<le> l t2 - 1; length ys = length xs;\n         well_shaped t2; well_valued0 (xs @ as) t2\\<rbrakk>\n        \\<Longrightarrow> well_valued0 (ys @ as) t2;\n        length xs \\<le> l (Node i j a t1 t2) - 1; length ys = length xs;\n        well_shaped (Node i j a t1 t2);\n        well_valued0 (xs @ as) (Node i j a t1 t2); a = Some aa\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (ys @ as) t2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>\\<lbrakk>length xs \\<le> l t1 - 1; length ys = length xs;\n                 well_shaped t1; well_valued0 (xs @ as) t1\\<rbrakk>\n                \\<Longrightarrow> well_valued0 (ys @ as) t1;\n        \\<lbrakk>length xs \\<le> l t2 - 1; length ys = length xs;\n         well_shaped t2; well_valued0 (xs @ as) t2\\<rbrakk>\n        \\<Longrightarrow> well_valued0 (ys @ as) t2;\n        length xs \\<le> l (Node i j a t1 t2) - 1; length ys = length xs;\n        well_shaped (Node i j a t1 t2);\n        well_valued0 (xs @ as) (Node i j a t1 t2); a = Some aa\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (ys @ as) t2", "case (Some a')"], ["proof (state)\nthis:\n  a = Some a'\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>\\<lbrakk>length xs \\<le> l t1 - 1; length ys = length xs;\n                 well_shaped t1; well_valued0 (xs @ as) t1\\<rbrakk>\n                \\<Longrightarrow> well_valued0 (ys @ as) t1;\n        \\<lbrakk>length xs \\<le> l t2 - 1; length ys = length xs;\n         well_shaped t2; well_valued0 (xs @ as) t2\\<rbrakk>\n        \\<Longrightarrow> well_valued0 (ys @ as) t2;\n        length xs \\<le> l (Node i j a t1 t2) - 1; length ys = length xs;\n        well_shaped (Node i j a t1 t2);\n        well_valued0 (xs @ as) (Node i j a t1 t2); a = Some aa\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (ys @ as) t2", "with Node"], ["proof (chain)\npicking this:\n  \\<lbrakk>length xs \\<le> l t1 - 1; length ys = length xs; well_shaped t1;\n   well_valued0 (xs @ as) t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (ys @ as) t1\n  \\<lbrakk>length xs \\<le> l t2 - 1; length ys = length xs; well_shaped t2;\n   well_valued0 (xs @ as) t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (ys @ as) t2\n  length xs \\<le> l (Node i j a t1 t2) - 1\n  length ys = length xs\n  well_shaped (Node i j a t1 t2)\n  well_valued0 (xs @ as) (Node i j a t1 t2)\n  a = Some a'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>length xs \\<le> l t1 - 1; length ys = length xs; well_shaped t1;\n   well_valued0 (xs @ as) t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (ys @ as) t1\n  \\<lbrakk>length xs \\<le> l t2 - 1; length ys = length xs; well_shaped t2;\n   well_valued0 (xs @ as) t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (ys @ as) t2\n  length xs \\<le> l (Node i j a t1 t2) - 1\n  length ys = length xs\n  well_shaped (Node i j a t1 t2)\n  well_valued0 (xs @ as) (Node i j a t1 t2)\n  a = Some a'\n\ngoal (1 subgoal):\n 1. well_valued0 (ys @ as) t2", "by auto\n        (metis One_nat_def diff_Suc_1 diff_le_self le_trans tree.exhaust_sel well_shaped.simps(2))"], ["proof (state)\nthis:\n  well_valued0 (ys @ as) t2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  well_valued0 (ys @ as) t2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>length xs \\<le> l Leaf - 1; length ys = length xs;\n     well_shaped Leaf; well_valued0 (xs @ as) Leaf\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (ys @ as) Leaf\n 2. \\<And>x1 x2 x3 t1 t2.\n       \\<lbrakk>\\<lbrakk>length xs \\<le> l t1 - 1; length ys = length xs;\n                 well_shaped t1; well_valued0 (xs @ as) t1\\<rbrakk>\n                \\<Longrightarrow> well_valued0 (ys @ as) t1;\n        \\<lbrakk>length xs \\<le> l t2 - 1; length ys = length xs;\n         well_shaped t2; well_valued0 (xs @ as) t2\\<rbrakk>\n        \\<Longrightarrow> well_valued0 (ys @ as) t2;\n        length xs \\<le> l (Node x1 x2 x3 t1 t2) - 1; length ys = length xs;\n        well_shaped (Node x1 x2 x3 t1 t2);\n        well_valued0 (xs @ as) (Node x1 x2 x3 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (ys @ as) (Node x1 x2 x3 t1 t2)", "with Node well_valued0_t1"], ["proof (chain)\npicking this:\n  \\<lbrakk>length xs \\<le> l t1 - 1; length ys = length xs; well_shaped t1;\n   well_valued0 (xs @ as) t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (ys @ as) t1\n  \\<lbrakk>length xs \\<le> l t2 - 1; length ys = length xs; well_shaped t2;\n   well_valued0 (xs @ as) t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (ys @ as) t2\n  length xs \\<le> l (Node i j a t1 t2) - 1\n  length ys = length xs\n  well_shaped (Node i j a t1 t2)\n  well_valued0 (xs @ as) (Node i j a t1 t2)\n  well_valued0 (ys @ as) t1\n  well_valued0 (ys @ as) t2", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>length xs \\<le> l t1 - 1; length ys = length xs; well_shaped t1;\n   well_valued0 (xs @ as) t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (ys @ as) t1\n  \\<lbrakk>length xs \\<le> l t2 - 1; length ys = length xs; well_shaped t2;\n   well_valued0 (xs @ as) t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (ys @ as) t2\n  length xs \\<le> l (Node i j a t1 t2) - 1\n  length ys = length xs\n  well_shaped (Node i j a t1 t2)\n  well_valued0 (xs @ as) (Node i j a t1 t2)\n  well_valued0 (ys @ as) t1\n  well_valued0 (ys @ as) t2\n\ngoal (1 subgoal):\n 1. well_valued0 (ys @ as) (Node i j a t1 t2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>length xs \\<le> l t1 - 1; length ys = length xs;\n              well_shaped t1; well_valued0 (xs @ as) t1\\<rbrakk>\n             \\<Longrightarrow> well_valued0 (ys @ as) t1;\n     \\<lbrakk>length xs \\<le> l t2 - 1; length ys = length xs;\n      well_shaped t2; well_valued0 (xs @ as) t2\\<rbrakk>\n     \\<Longrightarrow> well_valued0 (ys @ as) t2;\n     length xs \\<le> l (Node i j a t1 t2) - 1; length ys = length xs;\n     well_shaped (Node i j a t1 t2);\n     well_valued0 (xs @ as) (Node i j a t1 t2); well_valued0 (ys @ as) t1;\n     well_valued0 (ys @ as) t2\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (ys @ as) (Node i j a t1 t2)", "have f1: \"0 < i \\<and> j \\<le> length (xs @ as) \\<and> (a = None \\<or> a = Some (SWA.sum (xs @ as) i j)) \\<and> well_valued0 (xs @ as) t1 \\<and> well_valued0 (xs @ as) t2 \\<and> (t2 = Leaf \\<or> val t2 \\<noteq> None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < i \\<and>\n    j \\<le> length (xs @ as) \\<and>\n    (a = None \\<or> a = Some (SWA.sum (xs @ as) i j)) \\<and>\n    well_valued0 (xs @ as) t1 \\<and>\n    well_valued0 (xs @ as) t2 \\<and> (t2 = Leaf \\<or> val t2 \\<noteq> None)", "by (meson \\<open>well_valued0 (xs @ as) (Node i j a t1 t2)\\<close> well_valued0.simps(2))"], ["proof (state)\nthis:\n  0 < i \\<and>\n  j \\<le> length (xs @ as) \\<and>\n  (a = None \\<or> a = Some (SWA.sum (xs @ as) i j)) \\<and>\n  well_valued0 (xs @ as) t1 \\<and>\n  well_valued0 (xs @ as) t2 \\<and> (t2 = Leaf \\<or> val t2 \\<noteq> None)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>length xs \\<le> l t1 - 1; length ys = length xs;\n              well_shaped t1; well_valued0 (xs @ as) t1\\<rbrakk>\n             \\<Longrightarrow> well_valued0 (ys @ as) t1;\n     \\<lbrakk>length xs \\<le> l t2 - 1; length ys = length xs;\n      well_shaped t2; well_valued0 (xs @ as) t2\\<rbrakk>\n     \\<Longrightarrow> well_valued0 (ys @ as) t2;\n     length xs \\<le> l (Node i j a t1 t2) - 1; length ys = length xs;\n     well_shaped (Node i j a t1 t2);\n     well_valued0 (xs @ as) (Node i j a t1 t2); well_valued0 (ys @ as) t1;\n     well_valued0 (ys @ as) t2\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (ys @ as) (Node i j a t1 t2)", "then"], ["proof (chain)\npicking this:\n  0 < i \\<and>\n  j \\<le> length (xs @ as) \\<and>\n  (a = None \\<or> a = Some (SWA.sum (xs @ as) i j)) \\<and>\n  well_valued0 (xs @ as) t1 \\<and>\n  well_valued0 (xs @ as) t2 \\<and> (t2 = Leaf \\<or> val t2 \\<noteq> None)", "have f2: \"j \\<le> length (ys @ as)\""], ["proof (prove)\nusing this:\n  0 < i \\<and>\n  j \\<le> length (xs @ as) \\<and>\n  (a = None \\<or> a = Some (SWA.sum (xs @ as) i j)) \\<and>\n  well_valued0 (xs @ as) t1 \\<and>\n  well_valued0 (xs @ as) t2 \\<and> (t2 = Leaf \\<or> val t2 \\<noteq> None)\n\ngoal (1 subgoal):\n 1. j \\<le> length (ys @ as)", "by (simp add: \\<open>length ys = length xs\\<close>)"], ["proof (state)\nthis:\n  j \\<le> length (ys @ as)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>length xs \\<le> l t1 - 1; length ys = length xs;\n              well_shaped t1; well_valued0 (xs @ as) t1\\<rbrakk>\n             \\<Longrightarrow> well_valued0 (ys @ as) t1;\n     \\<lbrakk>length xs \\<le> l t2 - 1; length ys = length xs;\n      well_shaped t2; well_valued0 (xs @ as) t2\\<rbrakk>\n     \\<Longrightarrow> well_valued0 (ys @ as) t2;\n     length xs \\<le> l (Node i j a t1 t2) - 1; length ys = length xs;\n     well_shaped (Node i j a t1 t2);\n     well_valued0 (xs @ as) (Node i j a t1 t2); well_valued0 (ys @ as) t1;\n     well_valued0 (ys @ as) t2\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (ys @ as) (Node i j a t1 t2)", "have \"a = None \\<or> a = Some (SWA.sum (ys @ as) i j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = None \\<or> a = Some (SWA.sum (ys @ as) i j)", "using f1"], ["proof (prove)\nusing this:\n  0 < i \\<and>\n  j \\<le> length (xs @ as) \\<and>\n  (a = None \\<or> a = Some (SWA.sum (xs @ as) i j)) \\<and>\n  well_valued0 (xs @ as) t1 \\<and>\n  well_valued0 (xs @ as) t2 \\<and> (t2 = Leaf \\<or> val t2 \\<noteq> None)\n\ngoal (1 subgoal):\n 1. a = None \\<or> a = Some (SWA.sum (ys @ as) i j)", "by (metis Node.prems(1) Node.prems(2) Node.prems(3) One_nat_def Suc_pred le_imp_less_Suc sum_eq_sum_prepend tree.sel(2) well_shaped.simps(2))"], ["proof (state)\nthis:\n  a = None \\<or> a = Some (SWA.sum (ys @ as) i j)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>length xs \\<le> l t1 - 1; length ys = length xs;\n              well_shaped t1; well_valued0 (xs @ as) t1\\<rbrakk>\n             \\<Longrightarrow> well_valued0 (ys @ as) t1;\n     \\<lbrakk>length xs \\<le> l t2 - 1; length ys = length xs;\n      well_shaped t2; well_valued0 (xs @ as) t2\\<rbrakk>\n     \\<Longrightarrow> well_valued0 (ys @ as) t2;\n     length xs \\<le> l (Node i j a t1 t2) - 1; length ys = length xs;\n     well_shaped (Node i j a t1 t2);\n     well_valued0 (xs @ as) (Node i j a t1 t2); well_valued0 (ys @ as) t1;\n     well_valued0 (ys @ as) t2\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (ys @ as) (Node i j a t1 t2)", "then"], ["proof (chain)\npicking this:\n  a = None \\<or> a = Some (SWA.sum (ys @ as) i j)", "show ?thesis"], ["proof (prove)\nusing this:\n  a = None \\<or> a = Some (SWA.sum (ys @ as) i j)\n\ngoal (1 subgoal):\n 1. well_valued0 (ys @ as) (Node i j a t1 t2)", "using f2 f1 \\<open>well_valued0 (ys @ as) t2\\<close> well_valued0.simps(2) well_valued0_t1"], ["proof (prove)\nusing this:\n  a = None \\<or> a = Some (SWA.sum (ys @ as) i j)\n  j \\<le> length (ys @ as)\n  0 < i \\<and>\n  j \\<le> length (xs @ as) \\<and>\n  (a = None \\<or> a = Some (SWA.sum (xs @ as) i j)) \\<and>\n  well_valued0 (xs @ as) t1 \\<and>\n  well_valued0 (xs @ as) t2 \\<and> (t2 = Leaf \\<or> val t2 \\<noteq> None)\n  well_valued0 (ys @ as) t2\n  well_valued0 ?as (Node ?i ?j ?a ?t ?u) =\n  (0 < ?i \\<and>\n   ?j \\<le> length ?as \\<and>\n   (?a \\<noteq> None \\<longrightarrow> ?a = Some (SWA.sum ?as ?i ?j)) \\<and>\n   well_valued0 ?as ?t \\<and>\n   well_valued0 ?as ?u \\<and> (?u = Leaf \\<or> val ?u \\<noteq> None))\n  well_valued0 (ys @ as) t1\n\ngoal (1 subgoal):\n 1. well_valued0 (ys @ as) (Node i j a t1 t2)", "by blast"], ["proof (state)\nthis:\n  well_valued0 (ys @ as) (Node i j a t1 t2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  well_valued0 (ys @ as) (Node i j a t1 t2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs \\<le> l Leaf - 1; length ys = length xs;\n     well_shaped Leaf; well_valued0 (xs @ as) Leaf\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (ys @ as) Leaf", "qed simp"], ["", "lemma valid_prepend: \"\\<lbrakk>length xs \\<le> l t - 1; length ys = length xs; valid (xs @ as) t\\<rbrakk> \\<Longrightarrow> valid (ys @ as) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs \\<le> l t - 1; length ys = length xs;\n     valid (xs @ as) t\\<rbrakk>\n    \\<Longrightarrow> valid (ys @ as) t", "unfolding valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs \\<le> l t - 1; length ys = length xs;\n     well_shaped t \\<and> well_valued (xs @ as) t\\<rbrakk>\n    \\<Longrightarrow> well_shaped t \\<and> well_valued (ys @ as) t", "by (auto intro: well_valued0_prepend)"], ["", "lemma take_eq_append_take_take_drop: \"m \\<le> n \\<Longrightarrow> take n xs = take m xs @ take (n-m) (drop m xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow>\n    take n xs = take m xs @ take (n - m) (drop m xs)", "proof (induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. m \\<le> n \\<Longrightarrow>\n    take n [] = take m [] @ take (n - m) (drop m [])\n 2. \\<And>a xs.\n       \\<lbrakk>m \\<le> n \\<Longrightarrow>\n                take n xs = take m xs @ take (n - m) (drop m xs);\n        m \\<le> n\\<rbrakk>\n       \\<Longrightarrow> take n (a # xs) =\n                         take m (a # xs) @ take (n - m) (drop m (a # xs))", "case (Cons a xs)"], ["proof (state)\nthis:\n  m \\<le> n \\<Longrightarrow>\n  take n xs = take m xs @ take (n - m) (drop m xs)\n  m \\<le> n\n\ngoal (2 subgoals):\n 1. m \\<le> n \\<Longrightarrow>\n    take n [] = take m [] @ take (n - m) (drop m [])\n 2. \\<And>a xs.\n       \\<lbrakk>m \\<le> n \\<Longrightarrow>\n                take n xs = take m xs @ take (n - m) (drop m xs);\n        m \\<le> n\\<rbrakk>\n       \\<Longrightarrow> take n (a # xs) =\n                         take m (a # xs) @ take (n - m) (drop m (a # xs))", "then"], ["proof (chain)\npicking this:\n  m \\<le> n \\<Longrightarrow>\n  take n xs = take m xs @ take (n - m) (drop m xs)\n  m \\<le> n", "show ?case"], ["proof (prove)\nusing this:\n  m \\<le> n \\<Longrightarrow>\n  take n xs = take m xs @ take (n - m) (drop m xs)\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. take n (a # xs) = take m (a # xs) @ take (n - m) (drop m (a # xs))", "by (metis le_add_diff_inverse take_add)"], ["proof (state)\nthis:\n  take n (a # xs) = take m (a # xs) @ take (n - m) (drop m (a # xs))\n\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow>\n    take n [] = take m [] @ take (n - m) (drop m [])", "qed simp"], ["", "lemma well_valued0_take_r: \"\\<lbrakk>well_shaped t; well_valued0 as t\\<rbrakk> \\<Longrightarrow> well_valued0 (take (r t) as) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>well_shaped t; well_valued0 as t\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (take (r t) as) t", "proof (induction t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>well_shaped Leaf; well_valued0 as Leaf\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (take (r Leaf) as) Leaf\n 2. \\<And>x1 x2 x3 t1 t2.\n       \\<lbrakk>\\<lbrakk>well_shaped t1; well_valued0 as t1\\<rbrakk>\n                \\<Longrightarrow> well_valued0 (take (r t1) as) t1;\n        \\<lbrakk>well_shaped t2; well_valued0 as t2\\<rbrakk>\n        \\<Longrightarrow> well_valued0 (take (r t2) as) t2;\n        well_shaped (Node x1 x2 x3 t1 t2);\n        well_valued0 as (Node x1 x2 x3 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (take (r (Node x1 x2 x3 t1 t2)) as)\n                          (Node x1 x2 x3 t1 t2)", "case (Node i j a t1 t2)"], ["proof (state)\nthis:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (take (r t1) as) t1\n  \\<lbrakk>well_shaped t2; well_valued0 as t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (take (r t2) as) t2\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>well_shaped Leaf; well_valued0 as Leaf\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (take (r Leaf) as) Leaf\n 2. \\<And>x1 x2 x3 t1 t2.\n       \\<lbrakk>\\<lbrakk>well_shaped t1; well_valued0 as t1\\<rbrakk>\n                \\<Longrightarrow> well_valued0 (take (r t1) as) t1;\n        \\<lbrakk>well_shaped t2; well_valued0 as t2\\<rbrakk>\n        \\<Longrightarrow> well_valued0 (take (r t2) as) t2;\n        well_shaped (Node x1 x2 x3 t1 t2);\n        well_valued0 as (Node x1 x2 x3 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (take (r (Node x1 x2 x3 t1 t2)) as)\n                          (Node x1 x2 x3 t1 t2)", "from Node"], ["proof (chain)\npicking this:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (take (r t1) as) t1\n  \\<lbrakk>well_shaped t2; well_valued0 as t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (take (r t2) as) t2\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)", "have well_valued0_t1: \"well_valued0 (take j as) t1\""], ["proof (prove)\nusing this:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (take (r t1) as) t1\n  \\<lbrakk>well_shaped t2; well_valued0 as t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (take (r t2) as) t2\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n\ngoal (1 subgoal):\n 1. well_valued0 (take j as) t1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>well_shaped t1; well_valued0 as t1\\<rbrakk>\n             \\<Longrightarrow> well_valued0 (take (r t1) as) t1;\n     \\<lbrakk>well_shaped t2; well_valued0 as t2\\<rbrakk>\n     \\<Longrightarrow> well_valued0 (take (r t2) as) t2;\n     well_shaped (Node i j a t1 t2);\n     well_valued0 as (Node i j a t1 t2)\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (take j as) t1", "from Node"], ["proof (chain)\npicking this:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (take (r t1) as) t1\n  \\<lbrakk>well_shaped t2; well_valued0 as t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (take (r t2) as) t2\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)", "have \"r t1 \\<le> j\""], ["proof (prove)\nusing this:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (take (r t1) as) t1\n  \\<lbrakk>well_shaped t2; well_valued0 as t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (take (r t2) as) t2\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n\ngoal (1 subgoal):\n 1. r t1 \\<le> j", "using r_lchild_le_r"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (take (r t1) as) t1\n  \\<lbrakk>well_shaped t2; well_valued0 as t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (take (r t2) as) t2\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n  well_shaped ?t \\<Longrightarrow> r (lchild ?t) \\<le> r ?t\n\ngoal (1 subgoal):\n 1. r t1 \\<le> j", "by (metis tree.sel(4) tree.sel(8))"], ["proof (state)\nthis:\n  r t1 \\<le> j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>well_shaped t1; well_valued0 as t1\\<rbrakk>\n             \\<Longrightarrow> well_valued0 (take (r t1) as) t1;\n     \\<lbrakk>well_shaped t2; well_valued0 as t2\\<rbrakk>\n     \\<Longrightarrow> well_valued0 (take (r t2) as) t2;\n     well_shaped (Node i j a t1 t2);\n     well_valued0 as (Node i j a t1 t2)\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (take j as) t1", "with Node"], ["proof (chain)\npicking this:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (take (r t1) as) t1\n  \\<lbrakk>well_shaped t2; well_valued0 as t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (take (r t2) as) t2\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n  r t1 \\<le> j", "have \"take j as = take (r t1) as @ take (j - r t1) (drop (r t1) as)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (take (r t1) as) t1\n  \\<lbrakk>well_shaped t2; well_valued0 as t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (take (r t2) as) t2\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n  r t1 \\<le> j\n\ngoal (1 subgoal):\n 1. take j as = take (r t1) as @ take (j - r t1) (drop (r t1) as)", "using take_eq_append_take_take_drop[of \"r t1\" j as]"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (take (r t1) as) t1\n  \\<lbrakk>well_shaped t2; well_valued0 as t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (take (r t2) as) t2\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n  r t1 \\<le> j\n  r t1 \\<le> j \\<Longrightarrow>\n  take j as = take (r t1) as @ take (j - r t1) (drop (r t1) as)\n\ngoal (1 subgoal):\n 1. take j as = take (r t1) as @ take (j - r t1) (drop (r t1) as)", "by simp"], ["proof (state)\nthis:\n  take j as = take (r t1) as @ take (j - r t1) (drop (r t1) as)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>well_shaped t1; well_valued0 as t1\\<rbrakk>\n             \\<Longrightarrow> well_valued0 (take (r t1) as) t1;\n     \\<lbrakk>well_shaped t2; well_valued0 as t2\\<rbrakk>\n     \\<Longrightarrow> well_valued0 (take (r t2) as) t2;\n     well_shaped (Node i j a t1 t2);\n     well_valued0 as (Node i j a t1 t2)\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (take j as) t1", "with Node"], ["proof (chain)\npicking this:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (take (r t1) as) t1\n  \\<lbrakk>well_shaped t2; well_valued0 as t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (take (r t2) as) t2\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n  take j as = take (r t1) as @ take (j - r t1) (drop (r t1) as)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (take (r t1) as) t1\n  \\<lbrakk>well_shaped t2; well_valued0 as t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (take (r t2) as) t2\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n  take j as = take (r t1) as @ take (j - r t1) (drop (r t1) as)\n\ngoal (1 subgoal):\n 1. well_valued0 (take j as) t1", "by (auto intro!: well_valued0_append)"], ["proof (state)\nthis:\n  well_valued0 (take j as) t1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  well_valued0 (take j as) t1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>well_shaped Leaf; well_valued0 as Leaf\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (take (r Leaf) as) Leaf\n 2. \\<And>x1 x2 x3 t1 t2.\n       \\<lbrakk>\\<lbrakk>well_shaped t1; well_valued0 as t1\\<rbrakk>\n                \\<Longrightarrow> well_valued0 (take (r t1) as) t1;\n        \\<lbrakk>well_shaped t2; well_valued0 as t2\\<rbrakk>\n        \\<Longrightarrow> well_valued0 (take (r t2) as) t2;\n        well_shaped (Node x1 x2 x3 t1 t2);\n        well_valued0 as (Node x1 x2 x3 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (take (r (Node x1 x2 x3 t1 t2)) as)\n                          (Node x1 x2 x3 t1 t2)", "from Node"], ["proof (chain)\npicking this:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (take (r t1) as) t1\n  \\<lbrakk>well_shaped t2; well_valued0 as t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (take (r t2) as) t2\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)", "have well_valued0_t2: \"well_valued0 (take j as) t2\""], ["proof (prove)\nusing this:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (take (r t1) as) t1\n  \\<lbrakk>well_shaped t2; well_valued0 as t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (take (r t2) as) t2\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n\ngoal (1 subgoal):\n 1. well_valued0 (take j as) t2", "by auto"], ["proof (state)\nthis:\n  well_valued0 (take j as) t2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>well_shaped Leaf; well_valued0 as Leaf\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (take (r Leaf) as) Leaf\n 2. \\<And>x1 x2 x3 t1 t2.\n       \\<lbrakk>\\<lbrakk>well_shaped t1; well_valued0 as t1\\<rbrakk>\n                \\<Longrightarrow> well_valued0 (take (r t1) as) t1;\n        \\<lbrakk>well_shaped t2; well_valued0 as t2\\<rbrakk>\n        \\<Longrightarrow> well_valued0 (take (r t2) as) t2;\n        well_shaped (Node x1 x2 x3 t1 t2);\n        well_valued0 as (Node x1 x2 x3 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (take (r (Node x1 x2 x3 t1 t2)) as)\n                          (Node x1 x2 x3 t1 t2)", "from Node"], ["proof (chain)\npicking this:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (take (r t1) as) t1\n  \\<lbrakk>well_shaped t2; well_valued0 as t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (take (r t2) as) t2\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)", "have sum_eq: \"fold (+) (rev (map ((!) as) [l t1 - Suc 0..<r t2 - Suc 0])) (as ! (r t2 - Suc 0)) =\n      fold (+) (rev (map ((!) (take (r t2) as)) [l t1 - Suc 0..<r t2 - Suc 0])) (as ! (r t2 - Suc 0))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (take (r t1) as) t1\n  \\<lbrakk>well_shaped t2; well_valued0 as t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (take (r t2) as) t2\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n\ngoal (1 subgoal):\n 1. fold (+) (rev (map ((!) as) [l t1 - Suc 0..<r t2 - Suc 0]))\n     (as ! (r t2 - Suc 0)) =\n    fold (+)\n     (rev (map ((!) (take (r t2) as)) [l t1 - Suc 0..<r t2 - Suc 0]))\n     (as ! (r t2 - Suc 0))", "by (intro arg_cong[where f=\"\\<lambda>xs. fold _ xs _\"]) auto"], ["proof (state)\nthis:\n  fold (+) (rev (map ((!) as) [l t1 - Suc 0..<r t2 - Suc 0]))\n   (as ! (r t2 - Suc 0)) =\n  fold (+) (rev (map ((!) (take (r t2) as)) [l t1 - Suc 0..<r t2 - Suc 0]))\n   (as ! (r t2 - Suc 0))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>well_shaped Leaf; well_valued0 as Leaf\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (take (r Leaf) as) Leaf\n 2. \\<And>x1 x2 x3 t1 t2.\n       \\<lbrakk>\\<lbrakk>well_shaped t1; well_valued0 as t1\\<rbrakk>\n                \\<Longrightarrow> well_valued0 (take (r t1) as) t1;\n        \\<lbrakk>well_shaped t2; well_valued0 as t2\\<rbrakk>\n        \\<Longrightarrow> well_valued0 (take (r t2) as) t2;\n        well_shaped (Node x1 x2 x3 t1 t2);\n        well_valued0 as (Node x1 x2 x3 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (take (r (Node x1 x2 x3 t1 t2)) as)\n                          (Node x1 x2 x3 t1 t2)", "from Node well_valued0_t1 well_valued0_t2 sum_eq"], ["proof (chain)\npicking this:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (take (r t1) as) t1\n  \\<lbrakk>well_shaped t2; well_valued0 as t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (take (r t2) as) t2\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n  well_valued0 (take j as) t1\n  well_valued0 (take j as) t2\n  fold (+) (rev (map ((!) as) [l t1 - Suc 0..<r t2 - Suc 0]))\n   (as ! (r t2 - Suc 0)) =\n  fold (+) (rev (map ((!) (take (r t2) as)) [l t1 - Suc 0..<r t2 - Suc 0]))\n   (as ! (r t2 - Suc 0))", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (take (r t1) as) t1\n  \\<lbrakk>well_shaped t2; well_valued0 as t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (take (r t2) as) t2\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n  well_valued0 (take j as) t1\n  well_valued0 (take j as) t2\n  fold (+) (rev (map ((!) as) [l t1 - Suc 0..<r t2 - Suc 0]))\n   (as ! (r t2 - Suc 0)) =\n  fold (+) (rev (map ((!) (take (r t2) as)) [l t1 - Suc 0..<r t2 - Suc 0]))\n   (as ! (r t2 - Suc 0))\n\ngoal (1 subgoal):\n 1. well_valued0 (take (r (Node i j a t1 t2)) as) (Node i j a t1 t2)", "by auto"], ["proof (state)\nthis:\n  well_valued0 (take (r (Node i j a t1 t2)) as) (Node i j a t1 t2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>well_shaped Leaf; well_valued0 as Leaf\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (take (r Leaf) as) Leaf", "qed simp"], ["", "lemma valid_take_r: \"valid as t \\<Longrightarrow> valid (take (r t) as) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid as t \\<Longrightarrow> valid (take (r t) as) t", "unfolding valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. well_shaped t \\<and> well_valued as t \\<Longrightarrow>\n    well_shaped t \\<and> well_valued (take (r t) as) t", "by (auto intro: well_valued0_take_r)"], ["", "lemma well_valued0_butlast: \"\\<lbrakk>well_shaped t; well_valued0 as t; r t < length as\\<rbrakk> \\<Longrightarrow> well_valued0 (butlast as) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>well_shaped t; well_valued0 as t; r t < length as\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (butlast as) t", "proof (induction t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>well_shaped Leaf; well_valued0 as Leaf;\n     r Leaf < length as\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (butlast as) Leaf\n 2. \\<And>x1 x2 x3 t1 t2.\n       \\<lbrakk>\\<lbrakk>well_shaped t1; well_valued0 as t1;\n                 r t1 < length as\\<rbrakk>\n                \\<Longrightarrow> well_valued0 (butlast as) t1;\n        \\<lbrakk>well_shaped t2; well_valued0 as t2;\n         r t2 < length as\\<rbrakk>\n        \\<Longrightarrow> well_valued0 (butlast as) t2;\n        well_shaped (Node x1 x2 x3 t1 t2);\n        well_valued0 as (Node x1 x2 x3 t1 t2);\n        r (Node x1 x2 x3 t1 t2) < length as\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (butlast as) (Node x1 x2 x3 t1 t2)", "case (Node i j a t1 t2)"], ["proof (state)\nthis:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1; r t1 < length as\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as) t1\n  \\<lbrakk>well_shaped t2; well_valued0 as t2; r t2 < length as\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as) t2\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n  r (Node i j a t1 t2) < length as\n\ngoal (2 subgoals):\n 1. \\<lbrakk>well_shaped Leaf; well_valued0 as Leaf;\n     r Leaf < length as\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (butlast as) Leaf\n 2. \\<And>x1 x2 x3 t1 t2.\n       \\<lbrakk>\\<lbrakk>well_shaped t1; well_valued0 as t1;\n                 r t1 < length as\\<rbrakk>\n                \\<Longrightarrow> well_valued0 (butlast as) t1;\n        \\<lbrakk>well_shaped t2; well_valued0 as t2;\n         r t2 < length as\\<rbrakk>\n        \\<Longrightarrow> well_valued0 (butlast as) t2;\n        well_shaped (Node x1 x2 x3 t1 t2);\n        well_valued0 as (Node x1 x2 x3 t1 t2);\n        r (Node x1 x2 x3 t1 t2) < length as\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (butlast as) (Node x1 x2 x3 t1 t2)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1; r t1 < length as\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as) t1\n  \\<lbrakk>well_shaped t2; well_valued0 as t2; r t2 < length as\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as) t2\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n  r (Node i j a t1 t2) < length as", "have r_le_length: \"j \\<le> length (butlast as)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1; r t1 < length as\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as) t1\n  \\<lbrakk>well_shaped t2; well_valued0 as t2; r t2 < length as\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as) t2\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n  r (Node i j a t1 t2) < length as\n\ngoal (1 subgoal):\n 1. j \\<le> length (butlast as)", "by simp"], ["proof (state)\nthis:\n  j \\<le> length (butlast as)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>well_shaped Leaf; well_valued0 as Leaf;\n     r Leaf < length as\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (butlast as) Leaf\n 2. \\<And>x1 x2 x3 t1 t2.\n       \\<lbrakk>\\<lbrakk>well_shaped t1; well_valued0 as t1;\n                 r t1 < length as\\<rbrakk>\n                \\<Longrightarrow> well_valued0 (butlast as) t1;\n        \\<lbrakk>well_shaped t2; well_valued0 as t2;\n         r t2 < length as\\<rbrakk>\n        \\<Longrightarrow> well_valued0 (butlast as) t2;\n        well_shaped (Node x1 x2 x3 t1 t2);\n        well_valued0 as (Node x1 x2 x3 t1 t2);\n        r (Node x1 x2 x3 t1 t2) < length as\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (butlast as) (Node x1 x2 x3 t1 t2)", "from Node"], ["proof (chain)\npicking this:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1; r t1 < length as\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as) t1\n  \\<lbrakk>well_shaped t2; well_valued0 as t2; r t2 < length as\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as) t2\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n  r (Node i j a t1 t2) < length as", "have \"i > 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1; r t1 < length as\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as) t1\n  \\<lbrakk>well_shaped t2; well_valued0 as t2; r t2 < length as\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as) t2\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n  r (Node i j a t1 t2) < length as\n\ngoal (1 subgoal):\n 1. 0 < i", "by simp"], ["proof (state)\nthis:\n  0 < i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>well_shaped Leaf; well_valued0 as Leaf;\n     r Leaf < length as\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (butlast as) Leaf\n 2. \\<And>x1 x2 x3 t1 t2.\n       \\<lbrakk>\\<lbrakk>well_shaped t1; well_valued0 as t1;\n                 r t1 < length as\\<rbrakk>\n                \\<Longrightarrow> well_valued0 (butlast as) t1;\n        \\<lbrakk>well_shaped t2; well_valued0 as t2;\n         r t2 < length as\\<rbrakk>\n        \\<Longrightarrow> well_valued0 (butlast as) t2;\n        well_shaped (Node x1 x2 x3 t1 t2);\n        well_valued0 as (Node x1 x2 x3 t1 t2);\n        r (Node x1 x2 x3 t1 t2) < length as\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (butlast as) (Node x1 x2 x3 t1 t2)", "with r_le_length Node"], ["proof (chain)\npicking this:\n  j \\<le> length (butlast as)\n  \\<lbrakk>well_shaped t1; well_valued0 as t1; r t1 < length as\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as) t1\n  \\<lbrakk>well_shaped t2; well_valued0 as t2; r t2 < length as\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as) t2\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n  r (Node i j a t1 t2) < length as\n  0 < i", "have sum_eq: \"sum as i j = sum (butlast as) i j\""], ["proof (prove)\nusing this:\n  j \\<le> length (butlast as)\n  \\<lbrakk>well_shaped t1; well_valued0 as t1; r t1 < length as\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as) t1\n  \\<lbrakk>well_shaped t2; well_valued0 as t2; r t2 < length as\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as) t2\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n  r (Node i j a t1 t2) < length as\n  0 < i\n\ngoal (1 subgoal):\n 1. SWA.sum as i j = SWA.sum (butlast as) i j", "by (metis append_butlast_last_id le_zero_eq less_imp_le_nat list.size(3) neq_iff\n      sum_eq_sum_append well_shaped.simps(2))"], ["proof (state)\nthis:\n  SWA.sum as i j = SWA.sum (butlast as) i j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>well_shaped Leaf; well_valued0 as Leaf;\n     r Leaf < length as\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (butlast as) Leaf\n 2. \\<And>x1 x2 x3 t1 t2.\n       \\<lbrakk>\\<lbrakk>well_shaped t1; well_valued0 as t1;\n                 r t1 < length as\\<rbrakk>\n                \\<Longrightarrow> well_valued0 (butlast as) t1;\n        \\<lbrakk>well_shaped t2; well_valued0 as t2;\n         r t2 < length as\\<rbrakk>\n        \\<Longrightarrow> well_valued0 (butlast as) t2;\n        well_shaped (Node x1 x2 x3 t1 t2);\n        well_valued0 as (Node x1 x2 x3 t1 t2);\n        r (Node x1 x2 x3 t1 t2) < length as\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (butlast as) (Node x1 x2 x3 t1 t2)", "from Node"], ["proof (chain)\npicking this:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1; r t1 < length as\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as) t1\n  \\<lbrakk>well_shaped t2; well_valued0 as t2; r t2 < length as\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as) t2\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n  r (Node i j a t1 t2) < length as", "have \"r t1 < length as\""], ["proof (prove)\nusing this:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1; r t1 < length as\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as) t1\n  \\<lbrakk>well_shaped t2; well_valued0 as t2; r t2 < length as\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as) t2\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n  r (Node i j a t1 t2) < length as\n\ngoal (1 subgoal):\n 1. r t1 < length as", "by (metis dual_order.strict_trans2 r_lchild_le_r tree.sel(8))"], ["proof (state)\nthis:\n  r t1 < length as\n\ngoal (2 subgoals):\n 1. \\<lbrakk>well_shaped Leaf; well_valued0 as Leaf;\n     r Leaf < length as\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (butlast as) Leaf\n 2. \\<And>x1 x2 x3 t1 t2.\n       \\<lbrakk>\\<lbrakk>well_shaped t1; well_valued0 as t1;\n                 r t1 < length as\\<rbrakk>\n                \\<Longrightarrow> well_valued0 (butlast as) t1;\n        \\<lbrakk>well_shaped t2; well_valued0 as t2;\n         r t2 < length as\\<rbrakk>\n        \\<Longrightarrow> well_valued0 (butlast as) t2;\n        well_shaped (Node x1 x2 x3 t1 t2);\n        well_valued0 as (Node x1 x2 x3 t1 t2);\n        r (Node x1 x2 x3 t1 t2) < length as\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (butlast as) (Node x1 x2 x3 t1 t2)", "with Node r_le_length"], ["proof (chain)\npicking this:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1; r t1 < length as\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as) t1\n  \\<lbrakk>well_shaped t2; well_valued0 as t2; r t2 < length as\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as) t2\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n  r (Node i j a t1 t2) < length as\n  j \\<le> length (butlast as)\n  r t1 < length as", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1; r t1 < length as\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as) t1\n  \\<lbrakk>well_shaped t2; well_valued0 as t2; r t2 < length as\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as) t2\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n  r (Node i j a t1 t2) < length as\n  j \\<le> length (butlast as)\n  r t1 < length as\n\ngoal (1 subgoal):\n 1. well_valued0 (butlast as) (Node i j a t1 t2)", "by (metis (no_types, lifting) dual_order.strict_iff_order sum_eq tree.sel(10) tree.sel(4)\n      well_shaped.simps(2) well_shaped_rchild well_valued0.simps(2))"], ["proof (state)\nthis:\n  well_valued0 (butlast as) (Node i j a t1 t2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>well_shaped Leaf; well_valued0 as Leaf;\n     r Leaf < length as\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (butlast as) Leaf", "qed simp"], ["", "lemma well_valued0_append_butlast_lchild: \"\\<lbrakk>well_shaped t; well_valued0 as t\\<rbrakk> \\<Longrightarrow>\n  well_valued0 (butlast as @ [last as + x]) (lchild t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>well_shaped t; well_valued0 as t\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (butlast as @ [last as + x]) (lchild t)", "proof (cases t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>well_shaped t; well_valued0 as t; t = Leaf\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (butlast as @ [last as + x]) (lchild t)\n 2. \\<And>x21 x22 x23 x24 x25.\n       \\<lbrakk>well_shaped t; well_valued0 as t;\n        t = Node x21 x22 x23 x24 x25\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                          (lchild t)", "case (Node i j a t1 t2)"], ["proof (state)\nthis:\n  t = Node i j a t1 t2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>well_shaped t; well_valued0 as t; t = Leaf\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (butlast as @ [last as + x]) (lchild t)\n 2. \\<And>x21 x22 x23 x24 x25.\n       \\<lbrakk>well_shaped t; well_valued0 as t;\n        t = Node x21 x22 x23 x24 x25\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                          (lchild t)", "assume assms: \"well_shaped t\" \"well_valued0 as t\""], ["proof (state)\nthis:\n  well_shaped t\n  well_valued0 as t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>well_shaped t; well_valued0 as t; t = Leaf\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (butlast as @ [last as + x]) (lchild t)\n 2. \\<And>x21 x22 x23 x24 x25.\n       \\<lbrakk>well_shaped t; well_valued0 as t;\n        t = Node x21 x22 x23 x24 x25\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                          (lchild t)", "from Node assms"], ["proof (chain)\npicking this:\n  t = Node i j a t1 t2\n  well_shaped t\n  well_valued0 as t", "have \"r t1 < length as\""], ["proof (prove)\nusing this:\n  t = Node i j a t1 t2\n  well_shaped t\n  well_valued0 as t\n\ngoal (1 subgoal):\n 1. r t1 < length as", "by (fastforce dest: well_shaped_lr)"], ["proof (state)\nthis:\n  r t1 < length as\n\ngoal (2 subgoals):\n 1. \\<lbrakk>well_shaped t; well_valued0 as t; t = Leaf\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (butlast as @ [last as + x]) (lchild t)\n 2. \\<And>x21 x22 x23 x24 x25.\n       \\<lbrakk>well_shaped t; well_valued0 as t;\n        t = Node x21 x22 x23 x24 x25\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                          (lchild t)", "with Node assms"], ["proof (chain)\npicking this:\n  t = Node i j a t1 t2\n  well_shaped t\n  well_valued0 as t\n  r t1 < length as", "show ?thesis"], ["proof (prove)\nusing this:\n  t = Node i j a t1 t2\n  well_shaped t\n  well_valued0 as t\n  r t1 < length as\n\ngoal (1 subgoal):\n 1. well_valued0 (butlast as @ [last as + x]) (lchild t)", "by (auto simp: well_valued0_butlast well_valued0_append)"], ["proof (state)\nthis:\n  well_valued0 (butlast as @ [last as + x]) (lchild t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>well_shaped t; well_valued0 as t; t = Leaf\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (butlast as @ [last as + x]) (lchild t)", "qed simp"], ["", "lemma sum_update_rightmost: \"\\<lbrakk>0 < i; i \\<le> j; length as = j\\<rbrakk> \\<Longrightarrow>\n  sum as i j + x = sum (butlast as @ [last as + x]) i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < i; i \\<le> j; length as = j\\<rbrakk>\n    \\<Longrightarrow> SWA.sum as i j + x =\n                      SWA.sum (butlast as @ [last as + x]) i j", "by (cases as)\n    (auto simp: nth_append[abs_def] fold_add_add last_conv_nth nth_Cons' nth_butlast\n     intro!: arg_cong2[where f=\"(+)\"] arg_cong[where f=\"\\<lambda>xs. fold _ xs _\"])"], ["", "lemma well_valued0_update_rightmost: \"\\<lbrakk>well_shaped t; well_valued0 as t; length as = r t\\<rbrakk> \\<Longrightarrow>\n  well_valued0 (butlast as @ [last as + x]) (update_rightmost (\\<lambda>a. a + x) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>well_shaped t; well_valued0 as t; length as = r t\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                       (update_rightmost (\\<lambda>a. a + x) t)", "proof (induction t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>well_shaped Leaf; well_valued0 as Leaf;\n     length as = r Leaf\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                       (update_rightmost (\\<lambda>a. a + x) Leaf)\n 2. \\<And>x1 x2 x3 t1 t2.\n       \\<lbrakk>\\<lbrakk>well_shaped t1; well_valued0 as t1;\n                 length as = r t1\\<rbrakk>\n                \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                                   (update_rightmost (\\<lambda>a. a + x)\n                                     t1);\n        \\<lbrakk>well_shaped t2; well_valued0 as t2;\n         length as = r t2\\<rbrakk>\n        \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                           (update_rightmost (\\<lambda>a. a + x) t2);\n        well_shaped (Node x1 x2 x3 t1 t2);\n        well_valued0 as (Node x1 x2 x3 t1 t2);\n        length as = r (Node x1 x2 x3 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                          (update_rightmost (\\<lambda>a. a + x)\n                            (Node x1 x2 x3 t1 t2))", "case Leaf"], ["proof (state)\nthis:\n  well_shaped Leaf\n  well_valued0 as Leaf\n  length as = r Leaf\n\ngoal (2 subgoals):\n 1. \\<lbrakk>well_shaped Leaf; well_valued0 as Leaf;\n     length as = r Leaf\\<rbrakk>\n    \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                       (update_rightmost (\\<lambda>a. a + x) Leaf)\n 2. \\<And>x1 x2 x3 t1 t2.\n       \\<lbrakk>\\<lbrakk>well_shaped t1; well_valued0 as t1;\n                 length as = r t1\\<rbrakk>\n                \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                                   (update_rightmost (\\<lambda>a. a + x)\n                                     t1);\n        \\<lbrakk>well_shaped t2; well_valued0 as t2;\n         length as = r t2\\<rbrakk>\n        \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                           (update_rightmost (\\<lambda>a. a + x) t2);\n        well_shaped (Node x1 x2 x3 t1 t2);\n        well_valued0 as (Node x1 x2 x3 t1 t2);\n        length as = r (Node x1 x2 x3 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                          (update_rightmost (\\<lambda>a. a + x)\n                            (Node x1 x2 x3 t1 t2))", "then"], ["proof (chain)\npicking this:\n  well_shaped Leaf\n  well_valued0 as Leaf\n  length as = r Leaf", "show ?case"], ["proof (prove)\nusing this:\n  well_shaped Leaf\n  well_valued0 as Leaf\n  length as = r Leaf\n\ngoal (1 subgoal):\n 1. well_valued0 (butlast as @ [last as + x])\n     (update_rightmost (\\<lambda>a. a + x) Leaf)", "by (auto simp add: valid_Leaf)"], ["proof (state)\nthis:\n  well_valued0 (butlast as @ [last as + x])\n   (update_rightmost (\\<lambda>a. a + x) Leaf)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 t1 t2.\n       \\<lbrakk>\\<lbrakk>well_shaped t1; well_valued0 as t1;\n                 length as = r t1\\<rbrakk>\n                \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                                   (update_rightmost (\\<lambda>a. a + x)\n                                     t1);\n        \\<lbrakk>well_shaped t2; well_valued0 as t2;\n         length as = r t2\\<rbrakk>\n        \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                           (update_rightmost (\\<lambda>a. a + x) t2);\n        well_shaped (Node x1 x2 x3 t1 t2);\n        well_valued0 as (Node x1 x2 x3 t1 t2);\n        length as = r (Node x1 x2 x3 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                          (update_rightmost (\\<lambda>a. a + x)\n                            (Node x1 x2 x3 t1 t2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 t1 t2.\n       \\<lbrakk>\\<lbrakk>well_shaped t1; well_valued0 as t1;\n                 length as = r t1\\<rbrakk>\n                \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                                   (update_rightmost (\\<lambda>a. a + x)\n                                     t1);\n        \\<lbrakk>well_shaped t2; well_valued0 as t2;\n         length as = r t2\\<rbrakk>\n        \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                           (update_rightmost (\\<lambda>a. a + x) t2);\n        well_shaped (Node x1 x2 x3 t1 t2);\n        well_valued0 as (Node x1 x2 x3 t1 t2);\n        length as = r (Node x1 x2 x3 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                          (update_rightmost (\\<lambda>a. a + x)\n                            (Node x1 x2 x3 t1 t2))", "case (Node i j a t1 t2)"], ["proof (state)\nthis:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1; length as = r t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                     (update_rightmost (\\<lambda>a. a + x) t1)\n  \\<lbrakk>well_shaped t2; well_valued0 as t2; length as = r t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                     (update_rightmost (\\<lambda>a. a + x) t2)\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n  length as = r (Node i j a t1 t2)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 t1 t2.\n       \\<lbrakk>\\<lbrakk>well_shaped t1; well_valued0 as t1;\n                 length as = r t1\\<rbrakk>\n                \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                                   (update_rightmost (\\<lambda>a. a + x)\n                                     t1);\n        \\<lbrakk>well_shaped t2; well_valued0 as t2;\n         length as = r t2\\<rbrakk>\n        \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                           (update_rightmost (\\<lambda>a. a + x) t2);\n        well_shaped (Node x1 x2 x3 t1 t2);\n        well_valued0 as (Node x1 x2 x3 t1 t2);\n        length as = r (Node x1 x2 x3 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                          (update_rightmost (\\<lambda>a. a + x)\n                            (Node x1 x2 x3 t1 t2))", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1; length as = r t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                     (update_rightmost (\\<lambda>a. a + x) t1)\n  \\<lbrakk>well_shaped t2; well_valued0 as t2; length as = r t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                     (update_rightmost (\\<lambda>a. a + x) t2)\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n  length as = r (Node i j a t1 t2)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 t1 t2.\n       \\<lbrakk>\\<lbrakk>well_shaped t1; well_valued0 as t1;\n                 length as = r t1\\<rbrakk>\n                \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                                   (update_rightmost (\\<lambda>a. a + x)\n                                     t1);\n        \\<lbrakk>well_shaped t2; well_valued0 as t2;\n         length as = r t2\\<rbrakk>\n        \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                           (update_rightmost (\\<lambda>a. a + x) t2);\n        well_shaped (Node x1 x2 x3 t1 t2);\n        well_valued0 as (Node x1 x2 x3 t1 t2);\n        length as = r (Node x1 x2 x3 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                          (update_rightmost (\\<lambda>a. a + x)\n                            (Node x1 x2 x3 t1 t2))", "from Node"], ["proof (chain)\npicking this:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1; length as = r t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                     (update_rightmost (\\<lambda>a. a + x) t1)\n  \\<lbrakk>well_shaped t2; well_valued0 as t2; length as = r t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                     (update_rightmost (\\<lambda>a. a + x) t2)\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n  length as = r (Node i j a t1 t2)", "have well_valued0_t1: \"well_valued0 (butlast as @ [last as + x]) t1\""], ["proof (prove)\nusing this:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1; length as = r t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                     (update_rightmost (\\<lambda>a. a + x) t1)\n  \\<lbrakk>well_shaped t2; well_valued0 as t2; length as = r t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                     (update_rightmost (\\<lambda>a. a + x) t2)\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n  length as = r (Node i j a t1 t2)\n\ngoal (1 subgoal):\n 1. well_valued0 (butlast as @ [last as + x]) t1", "using well_valued0_append_butlast_lchild"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1; length as = r t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                     (update_rightmost (\\<lambda>a. a + x) t1)\n  \\<lbrakk>well_shaped t2; well_valued0 as t2; length as = r t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                     (update_rightmost (\\<lambda>a. a + x) t2)\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n  length as = r (Node i j a t1 t2)\n  \\<lbrakk>well_shaped ?t; well_valued0 ?as ?t\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast ?as @ [last ?as + ?x]) (lchild ?t)\n\ngoal (1 subgoal):\n 1. well_valued0 (butlast as @ [last as + x]) t1", "by (metis tree.sel(8))"], ["proof (state)\nthis:\n  well_valued0 (butlast as @ [last as + x]) t1\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 t1 t2.\n       \\<lbrakk>\\<lbrakk>well_shaped t1; well_valued0 as t1;\n                 length as = r t1\\<rbrakk>\n                \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                                   (update_rightmost (\\<lambda>a. a + x)\n                                     t1);\n        \\<lbrakk>well_shaped t2; well_valued0 as t2;\n         length as = r t2\\<rbrakk>\n        \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                           (update_rightmost (\\<lambda>a. a + x) t2);\n        well_shaped (Node x1 x2 x3 t1 t2);\n        well_valued0 as (Node x1 x2 x3 t1 t2);\n        length as = r (Node x1 x2 x3 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                          (update_rightmost (\\<lambda>a. a + x)\n                            (Node x1 x2 x3 t1 t2))", "moreover"], ["proof (state)\nthis:\n  well_valued0 (butlast as @ [last as + x]) t1\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 t1 t2.\n       \\<lbrakk>\\<lbrakk>well_shaped t1; well_valued0 as t1;\n                 length as = r t1\\<rbrakk>\n                \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                                   (update_rightmost (\\<lambda>a. a + x)\n                                     t1);\n        \\<lbrakk>well_shaped t2; well_valued0 as t2;\n         length as = r t2\\<rbrakk>\n        \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                           (update_rightmost (\\<lambda>a. a + x) t2);\n        well_shaped (Node x1 x2 x3 t1 t2);\n        well_valued0 as (Node x1 x2 x3 t1 t2);\n        length as = r (Node x1 x2 x3 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                          (update_rightmost (\\<lambda>a. a + x)\n                            (Node x1 x2 x3 t1 t2))", "from Node"], ["proof (chain)\npicking this:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1; length as = r t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                     (update_rightmost (\\<lambda>a. a + x) t1)\n  \\<lbrakk>well_shaped t2; well_valued0 as t2; length as = r t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                     (update_rightmost (\\<lambda>a. a + x) t2)\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n  length as = r (Node i j a t1 t2)", "have well_valued0_t2:\n    \"well_valued0 (butlast as @ [last as + x]) (update_rightmost ((\\<lambda>a. a + x)) t2)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1; length as = r t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                     (update_rightmost (\\<lambda>a. a + x) t1)\n  \\<lbrakk>well_shaped t2; well_valued0 as t2; length as = r t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                     (update_rightmost (\\<lambda>a. a + x) t2)\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n  length as = r (Node i j a t1 t2)\n\ngoal (1 subgoal):\n 1. well_valued0 (butlast as @ [last as + x])\n     (update_rightmost (\\<lambda>a. a + x) t2)", "by (metis \\<open>well_valued0 (butlast as @ [last as + x]) t1\\<close> dual_order.strict_iff_order\n      tree.sel(4) update_rightmost.simps(1) well_shaped.simps(2) well_valued0.simps(2))"], ["proof (state)\nthis:\n  well_valued0 (butlast as @ [last as + x])\n   (update_rightmost (\\<lambda>a. a + x) t2)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 t1 t2.\n       \\<lbrakk>\\<lbrakk>well_shaped t1; well_valued0 as t1;\n                 length as = r t1\\<rbrakk>\n                \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                                   (update_rightmost (\\<lambda>a. a + x)\n                                     t1);\n        \\<lbrakk>well_shaped t2; well_valued0 as t2;\n         length as = r t2\\<rbrakk>\n        \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                           (update_rightmost (\\<lambda>a. a + x) t2);\n        well_shaped (Node x1 x2 x3 t1 t2);\n        well_valued0 as (Node x1 x2 x3 t1 t2);\n        length as = r (Node x1 x2 x3 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                          (update_rightmost (\\<lambda>a. a + x)\n                            (Node x1 x2 x3 t1 t2))", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1; length as = r t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                     (update_rightmost (\\<lambda>a. a + x) t1)\n  \\<lbrakk>well_shaped t2; well_valued0 as t2; length as = r t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                     (update_rightmost (\\<lambda>a. a + x) t2)\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n  length as = r (Node i j a t1 t2)\n  well_valued0 (butlast as @ [last as + x]) t1\n  well_valued0 (butlast as @ [last as + x])\n   (update_rightmost (\\<lambda>a. a + x) t2)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1; length as = r t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                     (update_rightmost (\\<lambda>a. a + x) t1)\n  \\<lbrakk>well_shaped t2; well_valued0 as t2; length as = r t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                     (update_rightmost (\\<lambda>a. a + x) t2)\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n  length as = r (Node i j a t1 t2)\n  well_valued0 (butlast as @ [last as + x]) t1\n  well_valued0 (butlast as @ [last as + x])\n   (update_rightmost (\\<lambda>a. a + x) t2)\n\ngoal (1 subgoal):\n 1. well_valued0 (butlast as @ [last as + x])\n     (update_rightmost (\\<lambda>a. a + x) (Node i j a t1 t2))", "using sum_update_rightmost"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_shaped t1; well_valued0 as t1; length as = r t1\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                     (update_rightmost (\\<lambda>a. a + x) t1)\n  \\<lbrakk>well_shaped t2; well_valued0 as t2; length as = r t2\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast as @ [last as + x])\n                     (update_rightmost (\\<lambda>a. a + x) t2)\n  well_shaped (Node i j a t1 t2)\n  well_valued0 as (Node i j a t1 t2)\n  length as = r (Node i j a t1 t2)\n  well_valued0 (butlast as @ [last as + x]) t1\n  well_valued0 (butlast as @ [last as + x])\n   (update_rightmost (\\<lambda>a. a + x) t2)\n  \\<lbrakk>0 < ?i; ?i \\<le> ?j; length ?as = ?j\\<rbrakk>\n  \\<Longrightarrow> SWA.sum ?as ?i ?j + ?x =\n                    SWA.sum (butlast ?as @ [last ?as + ?x]) ?i ?j\n\ngoal (1 subgoal):\n 1. well_valued0 (butlast as @ [last as + x])\n     (update_rightmost (\\<lambda>a. a + x) (Node i j a t1 t2))", "by (cases a) (auto simp: val_update_rightmost_neq_None)"], ["proof (state)\nthis:\n  well_valued0 (butlast as @ [last as + x])\n   (update_rightmost (\\<lambda>a. a + x) (Node i j a t1 t2))\n\ngoal:\nNo subgoals!", "qed"], ["", "(* correctness of update_rightmost *)"], ["", "lemma valid_update_rightmost: \"\\<lbrakk>valid as t; length as = r t\\<rbrakk> \\<Longrightarrow>\n  valid (butlast as @ [last as + x]) (update_rightmost (\\<lambda>a. a + x) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid as t; length as = r t\\<rbrakk>\n    \\<Longrightarrow> valid (butlast as @ [last as + x])\n                       (update_rightmost (\\<lambda>a. a + x) t)", "unfolding valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>well_shaped t \\<and> well_valued as t; length as = r t\\<rbrakk>\n    \\<Longrightarrow> well_shaped\n                       (update_rightmost (\\<lambda>a. a + x) t) \\<and>\n                      well_valued (butlast as @ [last as + x])\n                       (update_rightmost (\\<lambda>a. a + x) t)", "using well_valued0_update_rightmost"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_shaped ?t; well_valued0 ?as ?t; length ?as = r ?t\\<rbrakk>\n  \\<Longrightarrow> well_valued0 (butlast ?as @ [last ?as + ?x])\n                     (update_rightmost (\\<lambda>a. a + ?x) ?t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>well_shaped t \\<and> well_valued as t; length as = r t\\<rbrakk>\n    \\<Longrightarrow> well_shaped\n                       (update_rightmost (\\<lambda>a. a + x) t) \\<and>\n                      well_valued (butlast as @ [last as + x])\n                       (update_rightmost (\\<lambda>a. a + x) t)", "by (metis update_rightmost.simps(1) val_update_rightmost_neq_None well_shaped_update_rightmost)"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}