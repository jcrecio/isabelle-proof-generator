{"file_name": "/home/qj213/afp-2021-10-22/thys/Derangements/Derangements.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Derangements", "problem_names": ["lemma card_product_dependent:\n  assumes \"finite S\" \"\\<forall>x \\<in> S. finite (T x)\"\n  shows \"card {(x, y). x \\<in> S \\<and> y \\<in> T x} = (\\<Sum>x \\<in> S. card (T x))\"", "lemma permutes_imp_bij':\n  assumes \"p permutes S\"\n  shows \"bij p\"", "lemma permutesE:\n  assumes \"p permutes S\"\n  obtains \"bij p\" \"\\<forall>x. x \\<notin> S \\<longrightarrow> p x = x\"", "lemma bij_imp_permutes':\n  assumes \"bij p\" \"\\<forall>x. x \\<notin> A \\<longrightarrow> p x = x\"\n  shows  \"p permutes A\"", "lemma permutes_swap:\n  assumes \"p permutes S\"\n  shows \"Fun.swap x y p permutes (insert x (insert y S))\"", "lemma bij_extends:\n  \"bij p \\<Longrightarrow> p x = x \\<Longrightarrow> bij (p(x := y, inv p y := x))\"", "lemma permutes_add_one:\n  assumes \"p permutes S\" \"x \\<notin> S\" \"y \\<in> S\"\n  shows \"p(x := y, inv p y := x) permutes (insert x S)\"", "lemma permutations_skip_one:\n  assumes \"p permutes S\" \"x : S\"\n  shows \"p(x := x, inv p x := p x) permutes (S - {x})\"", "lemma permutes_drop_cycle_size_two:\n  assumes \"p permutes S\" \"p (p x) = x\"\n  shows \"Fun.swap x (p x) p permutes (S - {x, p x})\"", "lemma derangementsI:\n  assumes \"p permutes S\" \"\\<And>x. x \\<in> S \\<Longrightarrow> p x \\<noteq> x\"\n  shows \"p \\<in> derangements S\"", "lemma derangementsE:\n  assumes \"d : derangements S\"\n  obtains \"d permutes S\" \"\\<forall>x\\<in>S. d x \\<noteq> x\"", "lemma derangements_inv:\n  assumes d: \"d \\<in> derangements S\"\n  shows \"inv d \\<in> derangements S\"", "lemma derangements_in_image:\n  assumes \"d \\<in> derangements A\" \"x \\<in> A\"\n  shows \"d x \\<in> A\"", "lemma derangements_in_image_strong:\n  assumes \"d \\<in> derangements A\" \"x \\<in> A\"\n  shows \"d x \\<in> A - {x}\"", "lemma derangements_inverse_in_image:\n  assumes \"d \\<in> derangements A\" \"x \\<in> A\"\n  shows \"inv d x \\<in> A\"", "lemma derangements_fixpoint:\n  assumes \"d \\<in> derangements A\" \"x \\<notin> A\"\n  shows \"d x = x\"", "lemma derangements_no_fixpoint:\n  assumes \"d \\<in> derangements A\" \"x \\<in> A\"\n  shows \"d x \\<noteq> x\"", "lemma finite_derangements:\n  assumes \"finite A\"\n  shows \"finite (derangements A)\"", "lemma derangements_empty[simp]:\n  \"derangements {} = {id}\"", "lemma derangements_singleton[simp]:\n  \"derangements {x} = {}\"", "lemma derangements_swap:\n  assumes \"d \\<in> derangements S\" \"x \\<notin> S\" \"y \\<notin> S\" \"x \\<noteq> y\"\n  shows \"Fun.swap x y d \\<in> derangements (insert x (insert y S))\"", "lemma derangements_skip_one:\n  assumes d: \"d \\<in> derangements S\" and \"x \\<in> S\" \"d (d x) \\<noteq> x\"\n  shows \"d(x := x, inv d x := d x) \\<in> derangements (S - {x})\"", "lemma derangements_add_one:\n  assumes \"d \\<in> derangements S\" \"x \\<notin> S\" \"y \\<in> S\"\n  shows \"d(x := y, inv d y := x) \\<in> derangements (insert x S)\"", "lemma derangements_drop_minimal_cycle:\n  assumes \"d \\<in> derangements S\" \"d (d x) = x\"\n  shows \"Fun.swap x (d x) d \\<in> derangements (S - {x, d x})\"", "lemma card_derangements:\n  assumes \"finite S\" \"card S = n\"\n  shows \"card (derangements S) = count_derangements n\"", "lemma count_derangements:\n  \"real (count_derangements n) = fact n * (\\<Sum>k \\<in> {0..n}. (-1) ^ k / fact k)\"", "lemma two_power_fact_le_fact:\n  assumes \"n \\<ge> 1\"\n  shows   \"2^k * fact n \\<le> (fact (n + k) :: 'a :: {semiring_char_0,linordered_semidom})\"", "lemma exp1_approx:\n  assumes \"n > 0\"\n  shows   \"exp (1::real) - (\\<Sum>k<n. 1 / fact k) \\<in> {0..2 / fact n}\"", "lemma exp1_bounds: \"exp 1 \\<in> {8 / 3..11 / 4 :: real}\"", "lemma count_derangements_approximation:\n  assumes \"n \\<noteq> 0\"\n  shows \"abs(real (count_derangements n) - fact n / exp 1) < 1 / 2\"", "theorem derangements_formula:\n  assumes \"n \\<noteq> 0\" \"finite S\" \"card S = n\"\n  shows \"int (card (derangements S)) = round (fact n / exp 1 :: real)\"", "theorem derangements_formula':\n  assumes \"n \\<noteq> 0\" \"finite S\" \"card S = n\"\n  shows \"card (derangements S) = nat (round (fact n / exp 1 :: real))\""], "translations": [["", "lemma card_product_dependent:\n  assumes \"finite S\" \"\\<forall>x \\<in> S. finite (T x)\"\n  shows \"card {(x, y). x \\<in> S \\<and> y \\<in> T x} = (\\<Sum>x \\<in> S. card (T x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {(x, y). x \\<in> S \\<and> y \\<in> T x} =\n    (\\<Sum>x\\<in>S. card (T x))", "using card_SigmaI[OF assms, symmetric]"], ["proof (prove)\nusing this:\n  (\\<Sum>a\\<in>S. card (T a)) = card (Sigma S T)\n\ngoal (1 subgoal):\n 1. card {(x, y). x \\<in> S \\<and> y \\<in> T x} =\n    (\\<Sum>x\\<in>S. card (T x))", "by (auto intro!: arg_cong[where f=card] simp add: Sigma_def)"], ["", "subsubsection \\<open>Additions to @{theory \"HOL-Library.Permutations\"} Theory\\<close>"], ["", "lemma permutes_imp_bij':\n  assumes \"p permutes S\"\n  shows \"bij p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij p", "using assms"], ["proof (prove)\nusing this:\n  p permutes S\n\ngoal (1 subgoal):\n 1. bij p", "by (meson bij_def permutes_inj permutes_surj)"], ["", "lemma permutesE:\n  assumes \"p permutes S\"\n  obtains \"bij p\" \"\\<forall>x. x \\<notin> S \\<longrightarrow> p x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>bij p;\n      \\<forall>x. x \\<notin> S \\<longrightarrow> p x = x\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  p permutes S\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>bij p;\n      \\<forall>x. x \\<notin> S \\<longrightarrow> p x = x\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: permutes_def permutes_imp_bij')"], ["", "lemma bij_imp_permutes':\n  assumes \"bij p\" \"\\<forall>x. x \\<notin> A \\<longrightarrow> p x = x\"\n  shows  \"p permutes A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p permutes A", "using assms bij_imp_permutes permutes_superset"], ["proof (prove)\nusing this:\n  bij p\n  \\<forall>x. x \\<notin> A \\<longrightarrow> p x = x\n  \\<lbrakk>bij_betw ?p ?S ?S;\n   \\<And>x. x \\<notin> ?S \\<Longrightarrow> ?p x = x\\<rbrakk>\n  \\<Longrightarrow> ?p permutes ?S\n  \\<lbrakk>?p permutes ?S; \\<forall>x\\<in>?S - ?T. ?p x = x\\<rbrakk>\n  \\<Longrightarrow> ?p permutes ?T\n\ngoal (1 subgoal):\n 1. p permutes A", "by force"], ["", "lemma permutes_swap:\n  assumes \"p permutes S\"\n  shows \"Fun.swap x y p permutes (insert x (insert y S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun.swap x y p permutes insert x (insert y S)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Fun.swap x y p permutes insert x (insert y S)", "from assms"], ["proof (chain)\npicking this:\n  p permutes S", "have \"p permutes (insert x (insert y S))\""], ["proof (prove)\nusing this:\n  p permutes S\n\ngoal (1 subgoal):\n 1. p permutes insert x (insert y S)", "by (meson permutes_subset subset_insertI)"], ["proof (state)\nthis:\n  p permutes insert x (insert y S)\n\ngoal (1 subgoal):\n 1. Fun.swap x y p permutes insert x (insert y S)", "moreover"], ["proof (state)\nthis:\n  p permutes insert x (insert y S)\n\ngoal (1 subgoal):\n 1. Fun.swap x y p permutes insert x (insert y S)", "have \"Fun.swap x y id permutes (insert x (insert y S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun.swap x y id permutes insert x (insert y S)", "by (simp add: permutes_swap_id)"], ["proof (state)\nthis:\n  Fun.swap x y id permutes insert x (insert y S)\n\ngoal (1 subgoal):\n 1. Fun.swap x y p permutes insert x (insert y S)", "ultimately"], ["proof (chain)\npicking this:\n  p permutes insert x (insert y S)\n  Fun.swap x y id permutes insert x (insert y S)", "show \"Fun.swap x y p permutes (insert x (insert y S))\""], ["proof (prove)\nusing this:\n  p permutes insert x (insert y S)\n  Fun.swap x y id permutes insert x (insert y S)\n\ngoal (1 subgoal):\n 1. Fun.swap x y p permutes insert x (insert y S)", "by (metis comp_id comp_swap permutes_compose)"], ["proof (state)\nthis:\n  Fun.swap x y p permutes insert x (insert y S)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bij_extends:\n  \"bij p \\<Longrightarrow> p x = x \\<Longrightarrow> bij (p(x := y, inv p y := x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bij p; p x = x\\<rbrakk>\n    \\<Longrightarrow> bij (p(x := y, inv p y := x))", "unfolding bij_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj p \\<and> surj p; p x = x\\<rbrakk>\n    \\<Longrightarrow> inj (p(x := y, inv p y := x)) \\<and>\n                      surj (p(x := y, inv p y := x))", "proof (rule conjI; erule conjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>p x = x; inj p; surj p\\<rbrakk>\n    \\<Longrightarrow> inj (p(x := y, inv p y := x))\n 2. \\<lbrakk>p x = x; inj p; surj p\\<rbrakk>\n    \\<Longrightarrow> surj (p(x := y, inv p y := x))", "assume a: \"inj p\" \"p x = x\""], ["proof (state)\nthis:\n  inj p\n  p x = x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>p x = x; inj p; surj p\\<rbrakk>\n    \\<Longrightarrow> inj (p(x := y, inv p y := x))\n 2. \\<lbrakk>p x = x; inj p; surj p\\<rbrakk>\n    \\<Longrightarrow> surj (p(x := y, inv p y := x))", "show \"inj (p(x := y, inv p y := x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (p(x := y, inv p y := x))", "proof (intro injI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa ya.\n       (p(x := y, inv p y := x)) xa =\n       (p(x := y, inv p y := x)) ya \\<Longrightarrow>\n       xa = ya", "fix z z'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa ya.\n       (p(x := y, inv p y := x)) xa =\n       (p(x := y, inv p y := x)) ya \\<Longrightarrow>\n       xa = ya", "assume \"(p(x := y, inv p y := x)) z = (p(x := y, inv p y := x)) z'\""], ["proof (state)\nthis:\n  (p(x := y, inv p y := x)) z = (p(x := y, inv p y := x)) z'\n\ngoal (1 subgoal):\n 1. \\<And>xa ya.\n       (p(x := y, inv p y := x)) xa =\n       (p(x := y, inv p y := x)) ya \\<Longrightarrow>\n       xa = ya", "from this a"], ["proof (chain)\npicking this:\n  (p(x := y, inv p y := x)) z = (p(x := y, inv p y := x)) z'\n  inj p\n  p x = x", "show \"z = z'\""], ["proof (prove)\nusing this:\n  (p(x := y, inv p y := x)) z = (p(x := y, inv p y := x)) z'\n  inj p\n  p x = x\n\ngoal (1 subgoal):\n 1. z = z'", "by (auto split: if_split_asm simp add: inv_f_eq inj_eq)"], ["proof (state)\nthis:\n  z = z'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj (p(x := y, inv p y := x))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p x = x; inj p; surj p\\<rbrakk>\n    \\<Longrightarrow> surj (p(x := y, inv p y := x))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>p x = x; inj p; surj p\\<rbrakk>\n    \\<Longrightarrow> surj (p(x := y, inv p y := x))", "assume a: \"inj p\" \"surj p\" \"p x = x\""], ["proof (state)\nthis:\n  inj p\n  surj p\n  p x = x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p x = x; inj p; surj p\\<rbrakk>\n    \\<Longrightarrow> surj (p(x := y, inv p y := x))", "{"], ["proof (state)\nthis:\n  inj p\n  surj p\n  p x = x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p x = x; inj p; surj p\\<rbrakk>\n    \\<Longrightarrow> surj (p(x := y, inv p y := x))", "fix x'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>p x = x; inj p; surj p\\<rbrakk>\n    \\<Longrightarrow> surj (p(x := y, inv p y := x))", "from a"], ["proof (chain)\npicking this:\n  inj p\n  surj p\n  p x = x", "have \"(p(x := y, inv p y := x)) (((inv p)(y := x, x := inv p y)) x') = x'\""], ["proof (prove)\nusing this:\n  inj p\n  surj p\n  p x = x\n\ngoal (1 subgoal):\n 1. (p(x := y, inv p y := x)) (((inv p)(y := x, x := inv p y)) x') = x'", "by (auto split: if_split_asm) (metis surj_f_inv_f)+"], ["proof (state)\nthis:\n  (p(x := y, inv p y := x)) (((inv p)(y := x, x := inv p y)) x') = x'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p x = x; inj p; surj p\\<rbrakk>\n    \\<Longrightarrow> surj (p(x := y, inv p y := x))", "}"], ["proof (state)\nthis:\n  (p(x := y, inv p y := x)) (((inv p)(y := x, x := inv p y)) ?x'2) = ?x'2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p x = x; inj p; surj p\\<rbrakk>\n    \\<Longrightarrow> surj (p(x := y, inv p y := x))", "from this"], ["proof (chain)\npicking this:\n  (p(x := y, inv p y := x)) (((inv p)(y := x, x := inv p y)) ?x'2) = ?x'2", "show \"surj (p(x := y, inv p y := x))\""], ["proof (prove)\nusing this:\n  (p(x := y, inv p y := x)) (((inv p)(y := x, x := inv p y)) ?x'2) = ?x'2\n\ngoal (1 subgoal):\n 1. surj (p(x := y, inv p y := x))", "by (metis surjI)"], ["proof (state)\nthis:\n  surj (p(x := y, inv p y := x))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma permutes_add_one:\n  assumes \"p permutes S\" \"x \\<notin> S\" \"y \\<in> S\"\n  shows \"p(x := y, inv p y := x) permutes (insert x S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p(x := y, inv p y := x) permutes insert x S", "proof (rule bij_imp_permutes')"], ["proof (state)\ngoal (2 subgoals):\n 1. bij (p(x := y, inv p y := x))\n 2. \\<forall>xa.\n       xa \\<notin> insert x S \\<longrightarrow>\n       (p(x := y, inv p y := x)) xa = xa", "from assms"], ["proof (chain)\npicking this:\n  p permutes S\n  x \\<notin> S\n  y \\<in> S", "show \"bij (p(x := y, inv p y := x))\""], ["proof (prove)\nusing this:\n  p permutes S\n  x \\<notin> S\n  y \\<in> S\n\ngoal (1 subgoal):\n 1. bij (p(x := y, inv p y := x))", "by (meson bij_extends permutes_def permutes_imp_bij')"], ["proof (state)\nthis:\n  bij (p(x := y, inv p y := x))\n\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       xa \\<notin> insert x S \\<longrightarrow>\n       (p(x := y, inv p y := x)) xa = xa", "from assms"], ["proof (chain)\npicking this:\n  p permutes S\n  x \\<notin> S\n  y \\<in> S", "show \"\\<forall>z. z \\<notin> insert x S \\<longrightarrow> (p(x := y, inv p y := x)) z = z\""], ["proof (prove)\nusing this:\n  p permutes S\n  x \\<notin> S\n  y \\<in> S\n\ngoal (1 subgoal):\n 1. \\<forall>z.\n       z \\<notin> insert x S \\<longrightarrow>\n       (p(x := y, inv p y := x)) z = z", "by (metis fun_upd_apply insertCI permutes_def permutes_inverses(1))"], ["proof (state)\nthis:\n  \\<forall>z.\n     z \\<notin> insert x S \\<longrightarrow> (p(x := y, inv p y := x)) z = z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma permutations_skip_one:\n  assumes \"p permutes S\" \"x : S\"\n  shows \"p(x := x, inv p x := p x) permutes (S - {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p(x := x, inv p x := p x) permutes S - {x}", "proof (rule bij_imp_permutes')"], ["proof (state)\ngoal (2 subgoals):\n 1. bij (p(x := x, inv p x := p x))\n 2. \\<forall>xa.\n       xa \\<notin> S - {x} \\<longrightarrow>\n       (p(x := x, inv p x := p x)) xa = xa", "from assms"], ["proof (chain)\npicking this:\n  p permutes S\n  x \\<in> S", "show \"\\<forall>z. z \\<notin> S - {x} \\<longrightarrow> (p(x := x, inv p x := p x)) z = z\""], ["proof (prove)\nusing this:\n  p permutes S\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. \\<forall>z.\n       z \\<notin> S - {x} \\<longrightarrow>\n       (p(x := x, inv p x := p x)) z = z", "by (auto elim: permutesE simp add: bij_inv_eq_iff)\n      (simp add: assms(1) permutes_in_image permutes_inv)"], ["proof (state)\nthis:\n  \\<forall>z.\n     z \\<notin> S - {x} \\<longrightarrow> (p(x := x, inv p x := p x)) z = z\n\ngoal (1 subgoal):\n 1. bij (p(x := x, inv p x := p x))", "from assms"], ["proof (chain)\npicking this:\n  p permutes S\n  x \\<in> S", "have \"inj (p(x := x, inv p x := p x))\""], ["proof (prove)\nusing this:\n  p permutes S\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. inj (p(x := x, inv p x := p x))", "by (intro injI) (auto split: if_split_asm; metis permutes_inverses(2))+"], ["proof (state)\nthis:\n  inj (p(x := x, inv p x := p x))\n\ngoal (1 subgoal):\n 1. bij (p(x := x, inv p x := p x))", "from assms this"], ["proof (chain)\npicking this:\n  p permutes S\n  x \\<in> S\n  inj (p(x := x, inv p x := p x))", "show \"bij (p(x := x, inv p x := p x))\""], ["proof (prove)\nusing this:\n  p permutes S\n  x \\<in> S\n  inj (p(x := x, inv p x := p x))\n\ngoal (1 subgoal):\n 1. bij (p(x := x, inv p x := p x))", "by (metis UNIV_I bij_betw_imageI bij_betw_swap_iff permutes_inj permutes_surj surj_f_inv_f swap_def)"], ["proof (state)\nthis:\n  bij (p(x := x, inv p x := p x))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma permutes_drop_cycle_size_two:\n  assumes \"p permutes S\" \"p (p x) = x\"\n  shows \"Fun.swap x (p x) p permutes (S - {x, p x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun.swap x (p x) p permutes S - {x, p x}", "using assms"], ["proof (prove)\nusing this:\n  p permutes S\n  p (p x) = x\n\ngoal (1 subgoal):\n 1. Fun.swap x (p x) p permutes S - {x, p x}", "by (auto intro!: bij_imp_permutes' elim!: permutesE) (metis swap_apply(1,3))"], ["", "subsection \\<open>Fixpoint-Free Permutations\\<close>"], ["", "definition derangements :: \"nat set \\<Rightarrow> (nat \\<Rightarrow> nat) set\"\nwhere\n  \"derangements S = {p. p permutes S \\<and> (\\<forall>x \\<in> S. p x \\<noteq> x)}\""], ["", "lemma derangementsI:\n  assumes \"p permutes S\" \"\\<And>x. x \\<in> S \\<Longrightarrow> p x \\<noteq> x\"\n  shows \"p \\<in> derangements S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> derangements S", "using assms"], ["proof (prove)\nusing this:\n  p permutes S\n  ?x \\<in> S \\<Longrightarrow> p ?x \\<noteq> ?x\n\ngoal (1 subgoal):\n 1. p \\<in> derangements S", "unfolding derangements_def"], ["proof (prove)\nusing this:\n  p permutes S\n  ?x \\<in> S \\<Longrightarrow> p ?x \\<noteq> ?x\n\ngoal (1 subgoal):\n 1. p \\<in> {p. p permutes S \\<and> (\\<forall>x\\<in>S. p x \\<noteq> x)}", "by auto"], ["", "lemma derangementsE:\n  assumes \"d : derangements S\"\n  obtains \"d permutes S\" \"\\<forall>x\\<in>S. d x \\<noteq> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>d permutes S; \\<forall>x\\<in>S. d x \\<noteq> x\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  d \\<in> derangements S\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>d permutes S; \\<forall>x\\<in>S. d x \\<noteq> x\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding derangements_def"], ["proof (prove)\nusing this:\n  d \\<in> {p. p permutes S \\<and> (\\<forall>x\\<in>S. p x \\<noteq> x)}\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>d permutes S; \\<forall>x\\<in>S. d x \\<noteq> x\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["", "subsection \\<open>Properties of Derangements\\<close>"], ["", "lemma derangements_inv:\n  assumes d: \"d \\<in> derangements S\"\n  shows \"inv d \\<in> derangements S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv d \\<in> derangements S", "using assms"], ["proof (prove)\nusing this:\n  d \\<in> derangements S\n\ngoal (1 subgoal):\n 1. inv d \\<in> derangements S", "by (auto intro!: derangementsI elim!: derangementsE simp add: permutes_inv permutes_inv_eq)"], ["", "lemma derangements_in_image:\n  assumes \"d \\<in> derangements A\" \"x \\<in> A\"\n  shows \"d x \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d x \\<in> A", "using assms"], ["proof (prove)\nusing this:\n  d \\<in> derangements A\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. d x \\<in> A", "by (auto elim: derangementsE simp add: permutes_in_image)"], ["", "lemma derangements_in_image_strong:\n  assumes \"d \\<in> derangements A\" \"x \\<in> A\"\n  shows \"d x \\<in> A - {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d x \\<in> A - {x}", "using assms"], ["proof (prove)\nusing this:\n  d \\<in> derangements A\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. d x \\<in> A - {x}", "by (auto elim: derangementsE simp add: permutes_in_image)"], ["", "lemma derangements_inverse_in_image:\n  assumes \"d \\<in> derangements A\" \"x \\<in> A\"\n  shows \"inv d x \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv d x \\<in> A", "using assms"], ["proof (prove)\nusing this:\n  d \\<in> derangements A\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. inv d x \\<in> A", "by (auto intro: derangements_in_image derangements_inv)"], ["", "lemma derangements_fixpoint:\n  assumes \"d \\<in> derangements A\" \"x \\<notin> A\"\n  shows \"d x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d x = x", "using assms"], ["proof (prove)\nusing this:\n  d \\<in> derangements A\n  x \\<notin> A\n\ngoal (1 subgoal):\n 1. d x = x", "by (auto elim!: derangementsE simp add: permutes_def)"], ["", "lemma derangements_no_fixpoint:\n  assumes \"d \\<in> derangements A\" \"x \\<in> A\"\n  shows \"d x \\<noteq> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d x \\<noteq> x", "using assms"], ["proof (prove)\nusing this:\n  d \\<in> derangements A\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. d x \\<noteq> x", "by (auto elim: derangementsE)"], ["", "lemma finite_derangements:\n  assumes \"finite A\"\n  shows \"finite (derangements A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (derangements A)", "using assms"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. finite (derangements A)", "unfolding derangements_def"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. finite {p. p permutes A \\<and> (\\<forall>x\\<in>A. p x \\<noteq> x)}", "by (auto simp add: finite_permutations)"], ["", "subsection \\<open>Construction of Derangements\\<close>"], ["", "lemma derangements_empty[simp]:\n  \"derangements {} = {id}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derangements {} = {id}", "unfolding derangements_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {p. p permutes {} \\<and> (\\<forall>x\\<in>{}. p x \\<noteq> x)} = {id}", "by auto"], ["", "lemma derangements_singleton[simp]:\n  \"derangements {x} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derangements {x} = {}", "unfolding derangements_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {p. p permutes {x} \\<and> (\\<forall>x\\<in>{x}. p x \\<noteq> x)} = {}", "by auto"], ["", "lemma derangements_swap:\n  assumes \"d \\<in> derangements S\" \"x \\<notin> S\" \"y \\<notin> S\" \"x \\<noteq> y\"\n  shows \"Fun.swap x y d \\<in> derangements (insert x (insert y S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun.swap x y d \\<in> derangements (insert x (insert y S))", "proof (rule derangementsI)"], ["proof (state)\ngoal (2 subgoals):\n 1. Fun.swap x y d permutes insert x (insert y S)\n 2. \\<And>xa.\n       xa \\<in> insert x (insert y S) \\<Longrightarrow>\n       Fun.swap x y d xa \\<noteq> xa", "from assms"], ["proof (chain)\npicking this:\n  d \\<in> derangements S\n  x \\<notin> S\n  y \\<notin> S\n  x \\<noteq> y", "show \"Fun.swap x y d permutes (insert x (insert y S))\""], ["proof (prove)\nusing this:\n  d \\<in> derangements S\n  x \\<notin> S\n  y \\<notin> S\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. Fun.swap x y d permutes insert x (insert y S)", "by (auto intro: permutes_swap elim: derangementsE)"], ["proof (state)\nthis:\n  Fun.swap x y d permutes insert x (insert y S)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> insert x (insert y S) \\<Longrightarrow>\n       Fun.swap x y d xa \\<noteq> xa", "from assms"], ["proof (chain)\npicking this:\n  d \\<in> derangements S\n  x \\<notin> S\n  y \\<notin> S\n  x \\<noteq> y", "have s: \"d x = x\" \"d y = y\""], ["proof (prove)\nusing this:\n  d \\<in> derangements S\n  x \\<notin> S\n  y \\<notin> S\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. d x = x &&& d y = y", "by (auto intro: derangements_fixpoint)"], ["proof (state)\nthis:\n  d x = x\n  d y = y\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> insert x (insert y S) \\<Longrightarrow>\n       Fun.swap x y d xa \\<noteq> xa", "{"], ["proof (state)\nthis:\n  d x = x\n  d y = y\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> insert x (insert y S) \\<Longrightarrow>\n       Fun.swap x y d xa \\<noteq> xa", "fix x'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> insert x (insert y S) \\<Longrightarrow>\n       Fun.swap x y d xa \\<noteq> xa", "assume \"x' : insert x (insert y S)\""], ["proof (state)\nthis:\n  x' \\<in> insert x (insert y S)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> insert x (insert y S) \\<Longrightarrow>\n       Fun.swap x y d xa \\<noteq> xa", "from s assms \\<open>x \\<noteq> y\\<close> this"], ["proof (chain)\npicking this:\n  d x = x\n  d y = y\n  d \\<in> derangements S\n  x \\<notin> S\n  y \\<notin> S\n  x \\<noteq> y\n  x \\<noteq> y\n  x' \\<in> insert x (insert y S)", "show \"Fun.swap x y d x' \\<noteq> x'\""], ["proof (prove)\nusing this:\n  d x = x\n  d y = y\n  d \\<in> derangements S\n  x \\<notin> S\n  y \\<notin> S\n  x \\<noteq> y\n  x \\<noteq> y\n  x' \\<in> insert x (insert y S)\n\ngoal (1 subgoal):\n 1. Fun.swap x y d x' \\<noteq> x'", "by (cases \"x' = x\"; cases \"x' = y\") (auto dest: derangements_no_fixpoint)"], ["proof (state)\nthis:\n  Fun.swap x y d x' \\<noteq> x'\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  ?x'2 \\<in> insert x (insert y S) \\<Longrightarrow>\n  Fun.swap x y d ?x'2 \\<noteq> ?x'2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma derangements_skip_one:\n  assumes d: \"d \\<in> derangements S\" and \"x \\<in> S\" \"d (d x) \\<noteq> x\"\n  shows \"d(x := x, inv d x := d x) \\<in> derangements (S - {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d(x := x, inv d x := d x) \\<in> derangements (S - {x})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d(x := x, inv d x := d x) \\<in> derangements (S - {x})", "from d"], ["proof (chain)\npicking this:\n  d \\<in> derangements S", "have bij: \"bij d\""], ["proof (prove)\nusing this:\n  d \\<in> derangements S\n\ngoal (1 subgoal):\n 1. bij d", "by (auto elim: derangementsE simp add: permutes_imp_bij')"], ["proof (state)\nthis:\n  bij d\n\ngoal (1 subgoal):\n 1. d(x := x, inv d x := d x) \\<in> derangements (S - {x})", "from d \\<open>x : S\\<close>"], ["proof (chain)\npicking this:\n  d \\<in> derangements S\n  x \\<in> S", "have that: \"d x : S - {x}\""], ["proof (prove)\nusing this:\n  d \\<in> derangements S\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. d x \\<in> S - {x}", "by (auto dest: derangements_in_image derangements_no_fixpoint)"], ["proof (state)\nthis:\n  d x \\<in> S - {x}\n\ngoal (1 subgoal):\n 1. d(x := x, inv d x := d x) \\<in> derangements (S - {x})", "from d \\<open>d (d x) \\<noteq> x\\<close> bij"], ["proof (chain)\npicking this:\n  d \\<in> derangements S\n  d (d x) \\<noteq> x\n  bij d", "have \"\\<forall>x'\\<in>S - {x}. (d(x := x, inv d x := d x)) x' \\<noteq> x'\""], ["proof (prove)\nusing this:\n  d \\<in> derangements S\n  d (d x) \\<noteq> x\n  bij d\n\ngoal (1 subgoal):\n 1. \\<forall>x'\\<in>S - {x}. (d(x := x, inv d x := d x)) x' \\<noteq> x'", "by (auto elim!: derangementsE simp add: bij_inv_eq_iff)"], ["proof (state)\nthis:\n  \\<forall>x'\\<in>S - {x}. (d(x := x, inv d x := d x)) x' \\<noteq> x'\n\ngoal (1 subgoal):\n 1. d(x := x, inv d x := d x) \\<in> derangements (S - {x})", "from d \\<open>x : S\\<close> this"], ["proof (chain)\npicking this:\n  d \\<in> derangements S\n  x \\<in> S\n  \\<forall>x'\\<in>S - {x}. (d(x := x, inv d x := d x)) x' \\<noteq> x'", "show derangements: \"d(x:=x, inv d x:= d x) : derangements (S - {x})\""], ["proof (prove)\nusing this:\n  d \\<in> derangements S\n  x \\<in> S\n  \\<forall>x'\\<in>S - {x}. (d(x := x, inv d x := d x)) x' \\<noteq> x'\n\ngoal (1 subgoal):\n 1. d(x := x, inv d x := d x) \\<in> derangements (S - {x})", "by (meson derangementsE derangementsI permutations_skip_one)"], ["proof (state)\nthis:\n  d(x := x, inv d x := d x) \\<in> derangements (S - {x})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma derangements_add_one:\n  assumes \"d \\<in> derangements S\" \"x \\<notin> S\" \"y \\<in> S\"\n  shows \"d(x := y, inv d y := x) \\<in> derangements (insert x S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d(x := y, inv d y := x) \\<in> derangements (insert x S)", "proof (rule derangementsI)"], ["proof (state)\ngoal (2 subgoals):\n 1. d(x := y, inv d y := x) permutes insert x S\n 2. \\<And>xa.\n       xa \\<in> insert x S \\<Longrightarrow>\n       (d(x := y, inv d y := x)) xa \\<noteq> xa", "from assms"], ["proof (chain)\npicking this:\n  d \\<in> derangements S\n  x \\<notin> S\n  y \\<in> S", "show \"d(x := y, inv d y := x) permutes (insert x S)\""], ["proof (prove)\nusing this:\n  d \\<in> derangements S\n  x \\<notin> S\n  y \\<in> S\n\ngoal (1 subgoal):\n 1. d(x := y, inv d y := x) permutes insert x S", "by (auto intro: permutes_add_one elim: derangementsE)"], ["proof (state)\nthis:\n  d(x := y, inv d y := x) permutes insert x S\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> insert x S \\<Longrightarrow>\n       (d(x := y, inv d y := x)) xa \\<noteq> xa", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> insert x S \\<Longrightarrow>\n       (d(x := y, inv d y := x)) xa \\<noteq> xa", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> insert x S \\<Longrightarrow>\n       (d(x := y, inv d y := x)) xa \\<noteq> xa", "assume \"z : insert x S\""], ["proof (state)\nthis:\n  z \\<in> insert x S\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> insert x S \\<Longrightarrow>\n       (d(x := y, inv d y := x)) xa \\<noteq> xa", "from assms this derangements_inverse_in_image[OF assms(1), of y]"], ["proof (chain)\npicking this:\n  d \\<in> derangements S\n  x \\<notin> S\n  y \\<in> S\n  z \\<in> insert x S\n  y \\<in> S \\<Longrightarrow> inv d y \\<in> S", "show \"(d(x := y, inv d y := x)) z \\<noteq> z\""], ["proof (prove)\nusing this:\n  d \\<in> derangements S\n  x \\<notin> S\n  y \\<in> S\n  z \\<in> insert x S\n  y \\<in> S \\<Longrightarrow> inv d y \\<in> S\n\ngoal (1 subgoal):\n 1. (d(x := y, inv d y := x)) z \\<noteq> z", "by (auto elim: derangementsE)"], ["proof (state)\nthis:\n  (d(x := y, inv d y := x)) z \\<noteq> z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma derangements_drop_minimal_cycle:\n  assumes \"d \\<in> derangements S\" \"d (d x) = x\"\n  shows \"Fun.swap x (d x) d \\<in> derangements (S - {x, d x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun.swap x (d x) d \\<in> derangements (S - {x, d x})", "proof (rule derangementsI)"], ["proof (state)\ngoal (2 subgoals):\n 1. Fun.swap x (d x) d permutes S - {x, d x}\n 2. \\<And>xa.\n       xa \\<in> S - {x, d x} \\<Longrightarrow>\n       Fun.swap x (d x) d xa \\<noteq> xa", "from assms"], ["proof (chain)\npicking this:\n  d \\<in> derangements S\n  d (d x) = x", "show \"Fun.swap x (d x) d permutes (S - {x, d x})\""], ["proof (prove)\nusing this:\n  d \\<in> derangements S\n  d (d x) = x\n\ngoal (1 subgoal):\n 1. Fun.swap x (d x) d permutes S - {x, d x}", "by (meson derangementsE permutes_drop_cycle_size_two)"], ["proof (state)\nthis:\n  Fun.swap x (d x) d permutes S - {x, d x}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> S - {x, d x} \\<Longrightarrow>\n       Fun.swap x (d x) d xa \\<noteq> xa", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> S - {x, d x} \\<Longrightarrow>\n       Fun.swap x (d x) d xa \\<noteq> xa", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> S - {x, d x} \\<Longrightarrow>\n       Fun.swap x (d x) d xa \\<noteq> xa", "assume \"y \\<in> S - {x, d x}\""], ["proof (state)\nthis:\n  y \\<in> S - {x, d x}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> S - {x, d x} \\<Longrightarrow>\n       Fun.swap x (d x) d xa \\<noteq> xa", "from assms this"], ["proof (chain)\npicking this:\n  d \\<in> derangements S\n  d (d x) = x\n  y \\<in> S - {x, d x}", "show \"Fun.swap x (d x) d y \\<noteq> y\""], ["proof (prove)\nusing this:\n  d \\<in> derangements S\n  d (d x) = x\n  y \\<in> S - {x, d x}\n\ngoal (1 subgoal):\n 1. Fun.swap x (d x) d y \\<noteq> y", "by (auto elim: derangementsE)"], ["proof (state)\nthis:\n  Fun.swap x (d x) d y \\<noteq> y\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Cardinality of Derangements\\<close>"], ["", "subsubsection \\<open>Recursive Characterization\\<close>"], ["", "fun count_derangements :: \"nat \\<Rightarrow> nat\"\nwhere\n  \"count_derangements 0 = 1\"\n| \"count_derangements (Suc 0) = 0\"\n| \"count_derangements (Suc (Suc n)) = (n + 1) * (count_derangements (Suc n) + count_derangements n)\""], ["", "lemma card_derangements:\n  assumes \"finite S\" \"card S = n\"\n  shows \"card (derangements S) = count_derangements n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (derangements S) = count_derangements n", "using assms"], ["proof (prove)\nusing this:\n  finite S\n  card S = n\n\ngoal (1 subgoal):\n 1. card (derangements S) = count_derangements n", "proof (induct n arbitrary: S rule: count_derangements.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>finite S; card S = 0\\<rbrakk>\n       \\<Longrightarrow> card (derangements S) = count_derangements 0\n 2. \\<And>S.\n       \\<lbrakk>finite S; card S = Suc 0\\<rbrakk>\n       \\<Longrightarrow> card (derangements S) = count_derangements (Suc 0)\n 3. \\<And>n S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>finite S; card S = Suc n\\<rbrakk>\n                   \\<Longrightarrow> card (derangements S) =\n                                     count_derangements (Suc n);\n        \\<And>S.\n           \\<lbrakk>finite S; card S = n\\<rbrakk>\n           \\<Longrightarrow> card (derangements S) = count_derangements n;\n        finite S; card S = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> card (derangements S) =\n                         count_derangements (Suc (Suc n))", "case 1"], ["proof (state)\nthis:\n  finite S\n  card S = 0\n\ngoal (3 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>finite S; card S = 0\\<rbrakk>\n       \\<Longrightarrow> card (derangements S) = count_derangements 0\n 2. \\<And>S.\n       \\<lbrakk>finite S; card S = Suc 0\\<rbrakk>\n       \\<Longrightarrow> card (derangements S) = count_derangements (Suc 0)\n 3. \\<And>n S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>finite S; card S = Suc n\\<rbrakk>\n                   \\<Longrightarrow> card (derangements S) =\n                                     count_derangements (Suc n);\n        \\<And>S.\n           \\<lbrakk>finite S; card S = n\\<rbrakk>\n           \\<Longrightarrow> card (derangements S) = count_derangements n;\n        finite S; card S = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> card (derangements S) =\n                         count_derangements (Suc (Suc n))", "from this"], ["proof (chain)\npicking this:\n  finite S\n  card S = 0", "show ?case"], ["proof (prove)\nusing this:\n  finite S\n  card S = 0\n\ngoal (1 subgoal):\n 1. card (derangements S) = count_derangements 0", "by auto"], ["proof (state)\nthis:\n  card (derangements S) = count_derangements 0\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>finite S; card S = Suc 0\\<rbrakk>\n       \\<Longrightarrow> card (derangements S) = count_derangements (Suc 0)\n 2. \\<And>n S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>finite S; card S = Suc n\\<rbrakk>\n                   \\<Longrightarrow> card (derangements S) =\n                                     count_derangements (Suc n);\n        \\<And>S.\n           \\<lbrakk>finite S; card S = n\\<rbrakk>\n           \\<Longrightarrow> card (derangements S) = count_derangements n;\n        finite S; card S = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> card (derangements S) =\n                         count_derangements (Suc (Suc n))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>finite S; card S = Suc 0\\<rbrakk>\n       \\<Longrightarrow> card (derangements S) = count_derangements (Suc 0)\n 2. \\<And>n S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>finite S; card S = Suc n\\<rbrakk>\n                   \\<Longrightarrow> card (derangements S) =\n                                     count_derangements (Suc n);\n        \\<And>S.\n           \\<lbrakk>finite S; card S = n\\<rbrakk>\n           \\<Longrightarrow> card (derangements S) = count_derangements n;\n        finite S; card S = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> card (derangements S) =\n                         count_derangements (Suc (Suc n))", "case 2"], ["proof (state)\nthis:\n  finite S\n  card S = Suc 0\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>finite S; card S = Suc 0\\<rbrakk>\n       \\<Longrightarrow> card (derangements S) = count_derangements (Suc 0)\n 2. \\<And>n S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>finite S; card S = Suc n\\<rbrakk>\n                   \\<Longrightarrow> card (derangements S) =\n                                     count_derangements (Suc n);\n        \\<And>S.\n           \\<lbrakk>finite S; card S = n\\<rbrakk>\n           \\<Longrightarrow> card (derangements S) = count_derangements n;\n        finite S; card S = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> card (derangements S) =\n                         count_derangements (Suc (Suc n))", "from this derangements_singleton finite_derangements"], ["proof (chain)\npicking this:\n  finite S\n  card S = Suc 0\n  derangements {?x} = {}\n  finite ?A \\<Longrightarrow> finite (derangements ?A)", "show ?case"], ["proof (prove)\nusing this:\n  finite S\n  card S = Suc 0\n  derangements {?x} = {}\n  finite ?A \\<Longrightarrow> finite (derangements ?A)\n\ngoal (1 subgoal):\n 1. card (derangements S) = count_derangements (Suc 0)", "using Finite_Set.card_0_eq card_eq_SucD count_derangements.simps(2)"], ["proof (prove)\nusing this:\n  finite S\n  card S = Suc 0\n  derangements {?x} = {}\n  finite ?A \\<Longrightarrow> finite (derangements ?A)\n  finite ?A \\<Longrightarrow> (card ?A = 0) = (?A = {})\n  card ?A = Suc ?k \\<Longrightarrow>\n  \\<exists>b B.\n     ?A = insert b B \\<and>\n     b \\<notin> B \\<and>\n     card B = ?k \\<and> (?k = 0 \\<longrightarrow> B = {})\n  count_derangements (Suc 0) = 0\n\ngoal (1 subgoal):\n 1. card (derangements S) = count_derangements (Suc 0)", "by fastforce"], ["proof (state)\nthis:\n  card (derangements S) = count_derangements (Suc 0)\n\ngoal (1 subgoal):\n 1. \\<And>n S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>finite S; card S = Suc n\\<rbrakk>\n                   \\<Longrightarrow> card (derangements S) =\n                                     count_derangements (Suc n);\n        \\<And>S.\n           \\<lbrakk>finite S; card S = n\\<rbrakk>\n           \\<Longrightarrow> card (derangements S) = count_derangements n;\n        finite S; card S = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> card (derangements S) =\n                         count_derangements (Suc (Suc n))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>finite S; card S = Suc n\\<rbrakk>\n                   \\<Longrightarrow> card (derangements S) =\n                                     count_derangements (Suc n);\n        \\<And>S.\n           \\<lbrakk>finite S; card S = n\\<rbrakk>\n           \\<Longrightarrow> card (derangements S) = count_derangements n;\n        finite S; card S = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> card (derangements S) =\n                         count_derangements (Suc (Suc n))", "case (3 n)"], ["proof (state)\nthis:\n  \\<lbrakk>finite ?S; card ?S = Suc n\\<rbrakk>\n  \\<Longrightarrow> card (derangements ?S) = count_derangements (Suc n)\n  \\<lbrakk>finite ?S; card ?S = n\\<rbrakk>\n  \\<Longrightarrow> card (derangements ?S) = count_derangements n\n  finite S\n  card S = Suc (Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>n S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>finite S; card S = Suc n\\<rbrakk>\n                   \\<Longrightarrow> card (derangements S) =\n                                     count_derangements (Suc n);\n        \\<And>S.\n           \\<lbrakk>finite S; card S = n\\<rbrakk>\n           \\<Longrightarrow> card (derangements S) = count_derangements n;\n        finite S; card S = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> card (derangements S) =\n                         count_derangements (Suc (Suc n))", "from 3(4)"], ["proof (chain)\npicking this:\n  card S = Suc (Suc n)", "obtain x where \"x \\<in> S\""], ["proof (prove)\nusing this:\n  card S = Suc (Suc n)\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> S \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using card_eq_SucD insertI1"], ["proof (prove)\nusing this:\n  card S = Suc (Suc n)\n  card ?A = Suc ?k \\<Longrightarrow>\n  \\<exists>b B.\n     ?A = insert b B \\<and>\n     b \\<notin> B \\<and>\n     card B = ?k \\<and> (?k = 0 \\<longrightarrow> B = {})\n  ?a \\<in> insert ?a ?B\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> S \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>n S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>finite S; card S = Suc n\\<rbrakk>\n                   \\<Longrightarrow> card (derangements S) =\n                                     count_derangements (Suc n);\n        \\<And>S.\n           \\<lbrakk>finite S; card S = n\\<rbrakk>\n           \\<Longrightarrow> card (derangements S) = count_derangements n;\n        finite S; card S = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> card (derangements S) =\n                         count_derangements (Suc (Suc n))", "let ?D1 = \"(\\<lambda>(y, d). Fun.swap x y d) ` {(y, d). y \\<in> S & y \\<noteq> x & d : derangements (S - {x, y})}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>finite S; card S = Suc n\\<rbrakk>\n                   \\<Longrightarrow> card (derangements S) =\n                                     count_derangements (Suc n);\n        \\<And>S.\n           \\<lbrakk>finite S; card S = n\\<rbrakk>\n           \\<Longrightarrow> card (derangements S) = count_derangements n;\n        finite S; card S = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> card (derangements S) =\n                         count_derangements (Suc (Suc n))", "let ?D2 = \"(\\<lambda>(y, f). f(x:=y, inv f y := x)) ` ((S - {x}) \\<times> derangements (S - {x}))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>finite S; card S = Suc n\\<rbrakk>\n                   \\<Longrightarrow> card (derangements S) =\n                                     count_derangements (Suc n);\n        \\<And>S.\n           \\<lbrakk>finite S; card S = n\\<rbrakk>\n           \\<Longrightarrow> card (derangements S) = count_derangements n;\n        finite S; card S = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> card (derangements S) =\n                         count_derangements (Suc (Suc n))", "from \\<open>x \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> S", "have subset1: \"?D1 \\<subseteq> derangements S\""], ["proof (prove)\nusing this:\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<lambda>(y, d). Fun.swap x y d) `\n    {(y, d).\n     y \\<in> S \\<and> y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})}\n    \\<subseteq> derangements S", "proof (auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>x \\<in> S; a \\<in> S; a \\<noteq> x;\n        b \\<in> derangements (S - {x, a})\\<rbrakk>\n       \\<Longrightarrow> Fun.swap x a b \\<in> derangements S", "fix y d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>x \\<in> S; a \\<in> S; a \\<noteq> x;\n        b \\<in> derangements (S - {x, a})\\<rbrakk>\n       \\<Longrightarrow> Fun.swap x a b \\<in> derangements S", "assume \"y \\<in> S\" \"y \\<noteq> x\""], ["proof (state)\nthis:\n  y \\<in> S\n  y \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>x \\<in> S; a \\<in> S; a \\<noteq> x;\n        b \\<in> derangements (S - {x, a})\\<rbrakk>\n       \\<Longrightarrow> Fun.swap x a b \\<in> derangements S", "assume d: \"d \\<in> derangements (S - {x, y})\""], ["proof (state)\nthis:\n  d \\<in> derangements (S - {x, y})\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>x \\<in> S; a \\<in> S; a \\<noteq> x;\n        b \\<in> derangements (S - {x, a})\\<rbrakk>\n       \\<Longrightarrow> Fun.swap x a b \\<in> derangements S", "from \\<open>x : S\\<close> \\<open>y : S\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> S\n  y \\<in> S", "have S: \"S = insert x (insert y (S - {x, y}))\""], ["proof (prove)\nusing this:\n  x \\<in> S\n  y \\<in> S\n\ngoal (1 subgoal):\n 1. S = insert x (insert y (S - {x, y}))", "by auto"], ["proof (state)\nthis:\n  S = insert x (insert y (S - {x, y}))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>x \\<in> S; a \\<in> S; a \\<noteq> x;\n        b \\<in> derangements (S - {x, a})\\<rbrakk>\n       \\<Longrightarrow> Fun.swap x a b \\<in> derangements S", "from d \\<open>x : S\\<close> \\<open>y : S\\<close> \\<open>y \\<noteq> x\\<close>"], ["proof (chain)\npicking this:\n  d \\<in> derangements (S - {x, y})\n  x \\<in> S\n  y \\<in> S\n  y \\<noteq> x", "show \"Fun.swap x y d \\<in> derangements S\""], ["proof (prove)\nusing this:\n  d \\<in> derangements (S - {x, y})\n  x \\<in> S\n  y \\<in> S\n  y \\<noteq> x\n\ngoal (1 subgoal):\n 1. Fun.swap x y d \\<in> derangements S", "by (subst S) (auto intro!: derangements_swap)"], ["proof (state)\nthis:\n  Fun.swap x y d \\<in> derangements S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>(y, d). Fun.swap x y d) `\n  {(y, d).\n   y \\<in> S \\<and> y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})}\n  \\<subseteq> derangements S\n\ngoal (1 subgoal):\n 1. \\<And>n S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>finite S; card S = Suc n\\<rbrakk>\n                   \\<Longrightarrow> card (derangements S) =\n                                     count_derangements (Suc n);\n        \\<And>S.\n           \\<lbrakk>finite S; card S = n\\<rbrakk>\n           \\<Longrightarrow> card (derangements S) = count_derangements n;\n        finite S; card S = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> card (derangements S) =\n                         count_derangements (Suc (Suc n))", "have subset2: \"?D2 \\<subseteq> derangements S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n    ((S - {x}) \\<times> derangements (S - {x}))\n    \\<subseteq> derangements S", "proof (rule subsetI, erule imageE, simp split: prod.split_asm, (erule conjE)+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xaa x1 x2.\n       \\<lbrakk>xaa = (x1, x2); xa = x2(x := x1, inv x2 x1 := x);\n        x1 \\<in> S; x1 \\<noteq> x; x2 \\<in> derangements (S - {x})\\<rbrakk>\n       \\<Longrightarrow> x2(x := x1, inv x2 x1 := x) \\<in> derangements S", "fix d y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xaa x1 x2.\n       \\<lbrakk>xaa = (x1, x2); xa = x2(x := x1, inv x2 x1 := x);\n        x1 \\<in> S; x1 \\<noteq> x; x2 \\<in> derangements (S - {x})\\<rbrakk>\n       \\<Longrightarrow> x2(x := x1, inv x2 x1 := x) \\<in> derangements S", "assume \"d : derangements (S - {x})\" \"y : S\" \"y \\<noteq> x\""], ["proof (state)\nthis:\n  d \\<in> derangements (S - {x})\n  y \\<in> S\n  y \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>xa xaa x1 x2.\n       \\<lbrakk>xaa = (x1, x2); xa = x2(x := x1, inv x2 x1 := x);\n        x1 \\<in> S; x1 \\<noteq> x; x2 \\<in> derangements (S - {x})\\<rbrakk>\n       \\<Longrightarrow> x2(x := x1, inv x2 x1 := x) \\<in> derangements S", "from this"], ["proof (chain)\npicking this:\n  d \\<in> derangements (S - {x})\n  y \\<in> S\n  y \\<noteq> x", "have \"d(x := y, inv d y := x) \\<in> derangements (insert x (S - {x}))\""], ["proof (prove)\nusing this:\n  d \\<in> derangements (S - {x})\n  y \\<in> S\n  y \\<noteq> x\n\ngoal (1 subgoal):\n 1. d(x := y, inv d y := x) \\<in> derangements (insert x (S - {x}))", "by (intro derangements_add_one) auto"], ["proof (state)\nthis:\n  d(x := y, inv d y := x) \\<in> derangements (insert x (S - {x}))\n\ngoal (1 subgoal):\n 1. \\<And>xa xaa x1 x2.\n       \\<lbrakk>xaa = (x1, x2); xa = x2(x := x1, inv x2 x1 := x);\n        x1 \\<in> S; x1 \\<noteq> x; x2 \\<in> derangements (S - {x})\\<rbrakk>\n       \\<Longrightarrow> x2(x := x1, inv x2 x1 := x) \\<in> derangements S", "from this \\<open>x : S\\<close>"], ["proof (chain)\npicking this:\n  d(x := y, inv d y := x) \\<in> derangements (insert x (S - {x}))\n  x \\<in> S", "show \"d(x := y, inv d y := x) \\<in> derangements S\""], ["proof (prove)\nusing this:\n  d(x := y, inv d y := x) \\<in> derangements (insert x (S - {x}))\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. d(x := y, inv d y := x) \\<in> derangements S", "using insert_Diff"], ["proof (prove)\nusing this:\n  d(x := y, inv d y := x) \\<in> derangements (insert x (S - {x}))\n  x \\<in> S\n  ?a \\<in> ?A \\<Longrightarrow> insert ?a (?A - {?a}) = ?A\n\ngoal (1 subgoal):\n 1. d(x := y, inv d y := x) \\<in> derangements S", "by fastforce"], ["proof (state)\nthis:\n  d(x := y, inv d y := x) \\<in> derangements S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n  ((S - {x}) \\<times> derangements (S - {x}))\n  \\<subseteq> derangements S\n\ngoal (1 subgoal):\n 1. \\<And>n S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>finite S; card S = Suc n\\<rbrakk>\n                   \\<Longrightarrow> card (derangements S) =\n                                     count_derangements (Suc n);\n        \\<And>S.\n           \\<lbrakk>finite S; card S = n\\<rbrakk>\n           \\<Longrightarrow> card (derangements S) = count_derangements n;\n        finite S; card S = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> card (derangements S) =\n                         count_derangements (Suc (Suc n))", "have split: \"derangements S = ?D1 \\<union> ?D2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derangements S =\n    (\\<lambda>(y, d). Fun.swap x y d) `\n    {(y, d).\n     y \\<in> S \\<and>\n     y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<union>\n    (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n    ((S - {x}) \\<times> derangements (S - {x}))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. derangements S\n    \\<subseteq> (\\<lambda>(y, d). Fun.swap x y d) `\n                {(y, d).\n                 y \\<in> S \\<and>\n                 y \\<noteq> x \\<and>\n                 d \\<in> derangements (S - {x, y})} \\<union>\n                (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n                ((S - {x}) \\<times> derangements (S - {x}))\n 2. (\\<lambda>(y, d). Fun.swap x y d) `\n    {(y, d).\n     y \\<in> S \\<and>\n     y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<union>\n    (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n    ((S - {x}) \\<times> derangements (S - {x}))\n    \\<subseteq> derangements S", "from subset1 subset2"], ["proof (chain)\npicking this:\n  (\\<lambda>(y, d). Fun.swap x y d) `\n  {(y, d).\n   y \\<in> S \\<and> y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})}\n  \\<subseteq> derangements S\n  (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n  ((S - {x}) \\<times> derangements (S - {x}))\n  \\<subseteq> derangements S", "show \"?D1 \\<union> ?D2 \\<subseteq> derangements S\""], ["proof (prove)\nusing this:\n  (\\<lambda>(y, d). Fun.swap x y d) `\n  {(y, d).\n   y \\<in> S \\<and> y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})}\n  \\<subseteq> derangements S\n  (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n  ((S - {x}) \\<times> derangements (S - {x}))\n  \\<subseteq> derangements S\n\ngoal (1 subgoal):\n 1. (\\<lambda>(y, d). Fun.swap x y d) `\n    {(y, d).\n     y \\<in> S \\<and>\n     y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<union>\n    (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n    ((S - {x}) \\<times> derangements (S - {x}))\n    \\<subseteq> derangements S", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>(y, d). Fun.swap x y d) `\n  {(y, d).\n   y \\<in> S \\<and>\n   y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<union>\n  (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n  ((S - {x}) \\<times> derangements (S - {x}))\n  \\<subseteq> derangements S\n\ngoal (1 subgoal):\n 1. derangements S\n    \\<subseteq> (\\<lambda>(y, d). Fun.swap x y d) `\n                {(y, d).\n                 y \\<in> S \\<and>\n                 y \\<noteq> x \\<and>\n                 d \\<in> derangements (S - {x, y})} \\<union>\n                (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n                ((S - {x}) \\<times> derangements (S - {x}))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. derangements S\n    \\<subseteq> (\\<lambda>(y, d). Fun.swap x y d) `\n                {(y, d).\n                 y \\<in> S \\<and>\n                 y \\<noteq> x \\<and>\n                 d \\<in> derangements (S - {x, y})} \\<union>\n                (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n                ((S - {x}) \\<times> derangements (S - {x}))", "show \"derangements S \\<subseteq> ?D1 \\<union> ?D2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derangements S\n    \\<subseteq> (\\<lambda>(y, d). Fun.swap x y d) `\n                {(y, d).\n                 y \\<in> S \\<and>\n                 y \\<noteq> x \\<and>\n                 d \\<in> derangements (S - {x, y})} \\<union>\n                (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n                ((S - {x}) \\<times> derangements (S - {x}))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> derangements S \\<Longrightarrow>\n       xa \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n                {(y, d).\n                 y \\<in> S \\<and>\n                 y \\<noteq> x \\<and>\n                 d \\<in> derangements (S - {x, y})} \\<union>\n                (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n                ((S - {x}) \\<times> derangements (S - {x}))", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> derangements S \\<Longrightarrow>\n       xa \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n                {(y, d).\n                 y \\<in> S \\<and>\n                 y \\<noteq> x \\<and>\n                 d \\<in> derangements (S - {x, y})} \\<union>\n                (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n                ((S - {x}) \\<times> derangements (S - {x}))", "assume d: \"d : derangements S\""], ["proof (state)\nthis:\n  d \\<in> derangements S\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> derangements S \\<Longrightarrow>\n       xa \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n                {(y, d).\n                 y \\<in> S \\<and>\n                 y \\<noteq> x \\<and>\n                 d \\<in> derangements (S - {x, y})} \\<union>\n                (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n                ((S - {x}) \\<times> derangements (S - {x}))", "show \"d : ?D1 \\<union> ?D2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n            {(y, d).\n             y \\<in> S \\<and>\n             y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<union>\n            (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n            ((S - {x}) \\<times> derangements (S - {x}))", "proof (cases \"d (d x) = x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. d (d x) = x \\<Longrightarrow>\n    d \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n            {(y, d).\n             y \\<in> S \\<and>\n             y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<union>\n            (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n            ((S - {x}) \\<times> derangements (S - {x}))\n 2. d (d x) \\<noteq> x \\<Longrightarrow>\n    d \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n            {(y, d).\n             y \\<in> S \\<and>\n             y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<union>\n            (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n            ((S - {x}) \\<times> derangements (S - {x}))", "case True"], ["proof (state)\nthis:\n  d (d x) = x\n\ngoal (2 subgoals):\n 1. d (d x) = x \\<Longrightarrow>\n    d \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n            {(y, d).\n             y \\<in> S \\<and>\n             y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<union>\n            (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n            ((S - {x}) \\<times> derangements (S - {x}))\n 2. d (d x) \\<noteq> x \\<Longrightarrow>\n    d \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n            {(y, d).\n             y \\<in> S \\<and>\n             y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<union>\n            (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n            ((S - {x}) \\<times> derangements (S - {x}))", "from \\<open>x : S\\<close> d"], ["proof (chain)\npicking this:\n  x \\<in> S\n  d \\<in> derangements S", "have \"d x \\<in> S\" \"d x \\<noteq> x\""], ["proof (prove)\nusing this:\n  x \\<in> S\n  d \\<in> derangements S\n\ngoal (1 subgoal):\n 1. d x \\<in> S &&& d x \\<noteq> x", "by (auto simp add: derangements_in_image derangements_no_fixpoint)"], ["proof (state)\nthis:\n  d x \\<in> S\n  d x \\<noteq> x\n\ngoal (2 subgoals):\n 1. d (d x) = x \\<Longrightarrow>\n    d \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n            {(y, d).\n             y \\<in> S \\<and>\n             y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<union>\n            (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n            ((S - {x}) \\<times> derangements (S - {x}))\n 2. d (d x) \\<noteq> x \\<Longrightarrow>\n    d \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n            {(y, d).\n             y \\<in> S \\<and>\n             y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<union>\n            (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n            ((S - {x}) \\<times> derangements (S - {x}))", "from d True"], ["proof (chain)\npicking this:\n  d \\<in> derangements S\n  d (d x) = x", "have \"Fun.swap x (d x) d \\<in> derangements (S - {x, d x})\""], ["proof (prove)\nusing this:\n  d \\<in> derangements S\n  d (d x) = x\n\ngoal (1 subgoal):\n 1. Fun.swap x (d x) d \\<in> derangements (S - {x, d x})", "by (rule derangements_drop_minimal_cycle)"], ["proof (state)\nthis:\n  Fun.swap x (d x) d \\<in> derangements (S - {x, d x})\n\ngoal (2 subgoals):\n 1. d (d x) = x \\<Longrightarrow>\n    d \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n            {(y, d).\n             y \\<in> S \\<and>\n             y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<union>\n            (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n            ((S - {x}) \\<times> derangements (S - {x}))\n 2. d (d x) \\<noteq> x \\<Longrightarrow>\n    d \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n            {(y, d).\n             y \\<in> S \\<and>\n             y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<union>\n            (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n            ((S - {x}) \\<times> derangements (S - {x}))", "from \\<open>d x \\<in> S\\<close> \\<open>d x \\<noteq> x\\<close> this"], ["proof (chain)\npicking this:\n  d x \\<in> S\n  d x \\<noteq> x\n  Fun.swap x (d x) d \\<in> derangements (S - {x, d x})", "have \"d : ?D1\""], ["proof (prove)\nusing this:\n  d x \\<in> S\n  d x \\<noteq> x\n  Fun.swap x (d x) d \\<in> derangements (S - {x, d x})\n\ngoal (1 subgoal):\n 1. d \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n            {(y, d).\n             y \\<in> S \\<and>\n             y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})}", "by (auto intro: image_eqI[where x = \"(d x, Fun.swap x (d x) d)\"])"], ["proof (state)\nthis:\n  d \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n          {(y, d).\n           y \\<in> S \\<and>\n           y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})}\n\ngoal (2 subgoals):\n 1. d (d x) = x \\<Longrightarrow>\n    d \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n            {(y, d).\n             y \\<in> S \\<and>\n             y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<union>\n            (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n            ((S - {x}) \\<times> derangements (S - {x}))\n 2. d (d x) \\<noteq> x \\<Longrightarrow>\n    d \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n            {(y, d).\n             y \\<in> S \\<and>\n             y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<union>\n            (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n            ((S - {x}) \\<times> derangements (S - {x}))", "from this"], ["proof (chain)\npicking this:\n  d \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n          {(y, d).\n           y \\<in> S \\<and>\n           y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})}", "show ?thesis"], ["proof (prove)\nusing this:\n  d \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n          {(y, d).\n           y \\<in> S \\<and>\n           y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})}\n\ngoal (1 subgoal):\n 1. d \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n            {(y, d).\n             y \\<in> S \\<and>\n             y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<union>\n            (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n            ((S - {x}) \\<times> derangements (S - {x}))", "by auto"], ["proof (state)\nthis:\n  d \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n          {(y, d).\n           y \\<in> S \\<and>\n           y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<union>\n          (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n          ((S - {x}) \\<times> derangements (S - {x}))\n\ngoal (1 subgoal):\n 1. d (d x) \\<noteq> x \\<Longrightarrow>\n    d \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n            {(y, d).\n             y \\<in> S \\<and>\n             y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<union>\n            (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n            ((S - {x}) \\<times> derangements (S - {x}))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. d (d x) \\<noteq> x \\<Longrightarrow>\n    d \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n            {(y, d).\n             y \\<in> S \\<and>\n             y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<union>\n            (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n            ((S - {x}) \\<times> derangements (S - {x}))", "case False"], ["proof (state)\nthis:\n  d (d x) \\<noteq> x\n\ngoal (1 subgoal):\n 1. d (d x) \\<noteq> x \\<Longrightarrow>\n    d \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n            {(y, d).\n             y \\<in> S \\<and>\n             y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<union>\n            (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n            ((S - {x}) \\<times> derangements (S - {x}))", "from d"], ["proof (chain)\npicking this:\n  d \\<in> derangements S", "have bij: \"bij d\""], ["proof (prove)\nusing this:\n  d \\<in> derangements S\n\ngoal (1 subgoal):\n 1. bij d", "by (auto elim: derangementsE simp add: permutes_imp_bij')"], ["proof (state)\nthis:\n  bij d\n\ngoal (1 subgoal):\n 1. d (d x) \\<noteq> x \\<Longrightarrow>\n    d \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n            {(y, d).\n             y \\<in> S \\<and>\n             y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<union>\n            (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n            ((S - {x}) \\<times> derangements (S - {x}))", "from d \\<open>x : S\\<close>"], ["proof (chain)\npicking this:\n  d \\<in> derangements S\n  x \\<in> S", "have that: \"d x : S - {x}\""], ["proof (prove)\nusing this:\n  d \\<in> derangements S\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. d x \\<in> S - {x}", "by (intro derangements_in_image_strong)"], ["proof (state)\nthis:\n  d x \\<in> S - {x}\n\ngoal (1 subgoal):\n 1. d (d x) \\<noteq> x \\<Longrightarrow>\n    d \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n            {(y, d).\n             y \\<in> S \\<and>\n             y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<union>\n            (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n            ((S - {x}) \\<times> derangements (S - {x}))", "from d \\<open>x : S\\<close> False"], ["proof (chain)\npicking this:\n  d \\<in> derangements S\n  x \\<in> S\n  d (d x) \\<noteq> x", "have derangements: \"d(x:=x, inv d x:= d x) : derangements (S - {x})\""], ["proof (prove)\nusing this:\n  d \\<in> derangements S\n  x \\<in> S\n  d (d x) \\<noteq> x\n\ngoal (1 subgoal):\n 1. d(x := x, inv d x := d x) \\<in> derangements (S - {x})", "by (auto intro: derangements_skip_one)"], ["proof (state)\nthis:\n  d(x := x, inv d x := d x) \\<in> derangements (S - {x})\n\ngoal (1 subgoal):\n 1. d (d x) \\<noteq> x \\<Longrightarrow>\n    d \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n            {(y, d).\n             y \\<in> S \\<and>\n             y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<union>\n            (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n            ((S - {x}) \\<times> derangements (S - {x}))", "from this"], ["proof (chain)\npicking this:\n  d(x := x, inv d x := d x) \\<in> derangements (S - {x})", "have \"bij (d(x := x, inv d x:= d x))\""], ["proof (prove)\nusing this:\n  d(x := x, inv d x := d x) \\<in> derangements (S - {x})\n\ngoal (1 subgoal):\n 1. bij (d(x := x, inv d x := d x))", "by (metis derangementsE permutes_imp_bij')+"], ["proof (state)\nthis:\n  bij (d(x := x, inv d x := d x))\n\ngoal (1 subgoal):\n 1. d (d x) \\<noteq> x \\<Longrightarrow>\n    d \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n            {(y, d).\n             y \\<in> S \\<and>\n             y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<union>\n            (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n            ((S - {x}) \\<times> derangements (S - {x}))", "from this"], ["proof (chain)\npicking this:\n  bij (d(x := x, inv d x := d x))", "have a: \"inv (d(x := x, inv d x := d x)) (d x) = inv d x\""], ["proof (prove)\nusing this:\n  bij (d(x := x, inv d x := d x))\n\ngoal (1 subgoal):\n 1. inv (d(x := x, inv d x := d x)) (d x) = inv d x", "by (metis bij_inv_eq_iff fun_upd_same)"], ["proof (state)\nthis:\n  inv (d(x := x, inv d x := d x)) (d x) = inv d x\n\ngoal (1 subgoal):\n 1. d (d x) \\<noteq> x \\<Longrightarrow>\n    d \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n            {(y, d).\n             y \\<in> S \\<and>\n             y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<union>\n            (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n            ((S - {x}) \\<times> derangements (S - {x}))", "from bij"], ["proof (chain)\npicking this:\n  bij d", "have x: \"d (inv d x) = x\""], ["proof (prove)\nusing this:\n  bij d\n\ngoal (1 subgoal):\n 1. d (inv d x) = x", "by (meson bij_inv_eq_iff)"], ["proof (state)\nthis:\n  d (inv d x) = x\n\ngoal (1 subgoal):\n 1. d (d x) \\<noteq> x \\<Longrightarrow>\n    d \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n            {(y, d).\n             y \\<in> S \\<and>\n             y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<union>\n            (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n            ((S - {x}) \\<times> derangements (S - {x}))", "from d derangements_inv[of d] \\<open>x : S\\<close>"], ["proof (chain)\npicking this:\n  d \\<in> derangements S\n  d \\<in> derangements ?S \\<Longrightarrow> inv d \\<in> derangements ?S\n  x \\<in> S", "have \"inv d x \\<noteq> x\" \"d x \\<noteq> x\""], ["proof (prove)\nusing this:\n  d \\<in> derangements S\n  d \\<in> derangements ?S \\<Longrightarrow> inv d \\<in> derangements ?S\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. inv d x \\<noteq> x &&& d x \\<noteq> x", "by (auto dest: derangements_no_fixpoint)"], ["proof (state)\nthis:\n  inv d x \\<noteq> x\n  d x \\<noteq> x\n\ngoal (1 subgoal):\n 1. d (d x) \\<noteq> x \\<Longrightarrow>\n    d \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n            {(y, d).\n             y \\<in> S \\<and>\n             y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<union>\n            (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n            ((S - {x}) \\<times> derangements (S - {x}))", "from this a x"], ["proof (chain)\npicking this:\n  inv d x \\<noteq> x\n  d x \\<noteq> x\n  inv (d(x := x, inv d x := d x)) (d x) = inv d x\n  d (inv d x) = x", "have d_eq: \"d = d(inv d x := d x, x := d x, inv (d(x := x, inv d x := d x)) (d x) := x)\""], ["proof (prove)\nusing this:\n  inv d x \\<noteq> x\n  d x \\<noteq> x\n  inv (d(x := x, inv d x := d x)) (d x) = inv d x\n  d (inv d x) = x\n\ngoal (1 subgoal):\n 1. d = d\n    (inv d x := d x, x := d x, inv (d(x := x, inv d x := d x)) (d x) := x)", "by auto"], ["proof (state)\nthis:\n  d = d\n  (inv d x := d x, x := d x, inv (d(x := x, inv d x := d x)) (d x) := x)\n\ngoal (1 subgoal):\n 1. d (d x) \\<noteq> x \\<Longrightarrow>\n    d \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n            {(y, d).\n             y \\<in> S \\<and>\n             y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<union>\n            (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n            ((S - {x}) \\<times> derangements (S - {x}))", "from derangements that"], ["proof (chain)\npicking this:\n  d(x := x, inv d x := d x) \\<in> derangements (S - {x})\n  d x \\<in> S - {x}", "have \"(d x, d(x:=x, inv d x:=d x)) : ((S - {x}) \\<times> derangements (S - {x}))\""], ["proof (prove)\nusing this:\n  d(x := x, inv d x := d x) \\<in> derangements (S - {x})\n  d x \\<in> S - {x}\n\ngoal (1 subgoal):\n 1. (d x, d(x := x, inv d x := d x))\n    \\<in> (S - {x}) \\<times> derangements (S - {x})", "by auto"], ["proof (state)\nthis:\n  (d x, d(x := x, inv d x := d x))\n  \\<in> (S - {x}) \\<times> derangements (S - {x})\n\ngoal (1 subgoal):\n 1. d (d x) \\<noteq> x \\<Longrightarrow>\n    d \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n            {(y, d).\n             y \\<in> S \\<and>\n             y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<union>\n            (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n            ((S - {x}) \\<times> derangements (S - {x}))", "from d_eq this"], ["proof (chain)\npicking this:\n  d = d\n  (inv d x := d x, x := d x, inv (d(x := x, inv d x := d x)) (d x) := x)\n  (d x, d(x := x, inv d x := d x))\n  \\<in> (S - {x}) \\<times> derangements (S - {x})", "have \"d : ?D2\""], ["proof (prove)\nusing this:\n  d = d\n  (inv d x := d x, x := d x, inv (d(x := x, inv d x := d x)) (d x) := x)\n  (d x, d(x := x, inv d x := d x))\n  \\<in> (S - {x}) \\<times> derangements (S - {x})\n\ngoal (1 subgoal):\n 1. d \\<in> (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n            ((S - {x}) \\<times> derangements (S - {x}))", "by (auto intro: image_eqI[where x = \"(d x, d(x:=x, inv d x:=d x))\"])"], ["proof (state)\nthis:\n  d \\<in> (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n          ((S - {x}) \\<times> derangements (S - {x}))\n\ngoal (1 subgoal):\n 1. d (d x) \\<noteq> x \\<Longrightarrow>\n    d \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n            {(y, d).\n             y \\<in> S \\<and>\n             y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<union>\n            (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n            ((S - {x}) \\<times> derangements (S - {x}))", "from this"], ["proof (chain)\npicking this:\n  d \\<in> (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n          ((S - {x}) \\<times> derangements (S - {x}))", "show ?thesis"], ["proof (prove)\nusing this:\n  d \\<in> (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n          ((S - {x}) \\<times> derangements (S - {x}))\n\ngoal (1 subgoal):\n 1. d \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n            {(y, d).\n             y \\<in> S \\<and>\n             y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<union>\n            (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n            ((S - {x}) \\<times> derangements (S - {x}))", "by auto"], ["proof (state)\nthis:\n  d \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n          {(y, d).\n           y \\<in> S \\<and>\n           y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<union>\n          (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n          ((S - {x}) \\<times> derangements (S - {x}))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n          {(y, d).\n           y \\<in> S \\<and>\n           y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<union>\n          (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n          ((S - {x}) \\<times> derangements (S - {x}))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  derangements S\n  \\<subseteq> (\\<lambda>(y, d). Fun.swap x y d) `\n              {(y, d).\n               y \\<in> S \\<and>\n               y \\<noteq> x \\<and>\n               d \\<in> derangements (S - {x, y})} \\<union>\n              (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n              ((S - {x}) \\<times> derangements (S - {x}))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  derangements S =\n  (\\<lambda>(y, d). Fun.swap x y d) `\n  {(y, d).\n   y \\<in> S \\<and>\n   y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<union>\n  (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n  ((S - {x}) \\<times> derangements (S - {x}))\n\ngoal (1 subgoal):\n 1. \\<And>n S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>finite S; card S = Suc n\\<rbrakk>\n                   \\<Longrightarrow> card (derangements S) =\n                                     count_derangements (Suc n);\n        \\<And>S.\n           \\<lbrakk>finite S; card S = n\\<rbrakk>\n           \\<Longrightarrow> card (derangements S) = count_derangements n;\n        finite S; card S = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> card (derangements S) =\n                         count_derangements (Suc (Suc n))", "have no_intersect: \"?D1 \\<inter> ?D2 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(y, d). Fun.swap x y d) `\n    {(y, d).\n     y \\<in> S \\<and>\n     y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<inter>\n    (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n    ((S - {x}) \\<times> derangements (S - {x})) =\n    {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>(y, d). Fun.swap x y d) `\n    {(y, d).\n     y \\<in> S \\<and>\n     y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<inter>\n    (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n    ((S - {x}) \\<times> derangements (S - {x})) =\n    {}", "have that: \"\\<And>d. d \\<in> ?D1 \\<Longrightarrow> d (d x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>d.\n       d \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n               {(y, d).\n                y \\<in> S \\<and>\n                y \\<noteq> x \\<and>\n                d \\<in> derangements (S - {x, y})} \\<Longrightarrow>\n       d (d x) = x", "using Diff_iff Diff_insert2 derangements_fixpoint insertI1 swap_apply(2)"], ["proof (prove)\nusing this:\n  (?c \\<in> ?A - ?B) = (?c \\<in> ?A \\<and> ?c \\<notin> ?B)\n  ?A - insert ?a ?B = ?A - {?a} - ?B\n  \\<lbrakk>?d \\<in> derangements ?A; ?x \\<notin> ?A\\<rbrakk>\n  \\<Longrightarrow> ?d ?x = ?x\n  ?a \\<in> insert ?a ?B\n  Fun.swap ?a ?b ?f ?b = ?f ?a\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       d \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n               {(y, d).\n                y \\<in> S \\<and>\n                y \\<noteq> x \\<and>\n                d \\<in> derangements (S - {x, y})} \\<Longrightarrow>\n       d (d x) = x", "by fastforce"], ["proof (state)\nthis:\n  ?d \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n           {(y, d).\n            y \\<in> S \\<and>\n            y \\<noteq> x \\<and>\n            d \\<in> derangements (S - {x, y})} \\<Longrightarrow>\n  ?d (?d x) = x\n\ngoal (1 subgoal):\n 1. (\\<lambda>(y, d). Fun.swap x y d) `\n    {(y, d).\n     y \\<in> S \\<and>\n     y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<inter>\n    (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n    ((S - {x}) \\<times> derangements (S - {x})) =\n    {}", "have \"\\<And>d. d \\<in> ?D2 \\<Longrightarrow> d (d x) \\<noteq> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>d.\n       d \\<in> (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n               ((S - {x}) \\<times> derangements (S - {x})) \\<Longrightarrow>\n       d (d x) \\<noteq> x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>d.\n       d \\<in> (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n               ((S - {x}) \\<times> derangements (S - {x})) \\<Longrightarrow>\n       d (d x) \\<noteq> x", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>d.\n       d \\<in> (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n               ((S - {x}) \\<times> derangements (S - {x})) \\<Longrightarrow>\n       d (d x) \\<noteq> x", "assume a: \"d \\<in> ?D2\""], ["proof (state)\nthis:\n  d \\<in> (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n          ((S - {x}) \\<times> derangements (S - {x}))\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       d \\<in> (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n               ((S - {x}) \\<times> derangements (S - {x})) \\<Longrightarrow>\n       d (d x) \\<noteq> x", "from a"], ["proof (chain)\npicking this:\n  d \\<in> (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n          ((S - {x}) \\<times> derangements (S - {x}))", "obtain y d' where d: \"d = d'(x := y, inv d' y := x)\"\n        \"d' \\<in> derangements (S - {x})\" \"y \\<in> S - {x}\""], ["proof (prove)\nusing this:\n  d \\<in> (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n          ((S - {x}) \\<times> derangements (S - {x}))\n\ngoal (1 subgoal):\n 1. (\\<And>d' y.\n        \\<lbrakk>d = d'(x := y, inv d' y := x);\n         d' \\<in> derangements (S - {x}); y \\<in> S - {x}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  d = d'(x := y, inv d' y := x)\n  d' \\<in> derangements (S - {x})\n  y \\<in> S - {x}\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       d \\<in> (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n               ((S - {x}) \\<times> derangements (S - {x})) \\<Longrightarrow>\n       d (d x) \\<noteq> x", "from d(2)"], ["proof (chain)\npicking this:\n  d' \\<in> derangements (S - {x})", "have inv: \"inv d' \\<in> derangements (S - {x})\""], ["proof (prove)\nusing this:\n  d' \\<in> derangements (S - {x})\n\ngoal (1 subgoal):\n 1. inv d' \\<in> derangements (S - {x})", "by (rule derangements_inv)"], ["proof (state)\nthis:\n  inv d' \\<in> derangements (S - {x})\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       d \\<in> (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n               ((S - {x}) \\<times> derangements (S - {x})) \\<Longrightarrow>\n       d (d x) \\<noteq> x", "from d"], ["proof (chain)\npicking this:\n  d = d'(x := y, inv d' y := x)\n  d' \\<in> derangements (S - {x})\n  y \\<in> S - {x}", "have inv_x: \"inv d' y \\<noteq> x\""], ["proof (prove)\nusing this:\n  d = d'(x := y, inv d' y := x)\n  d' \\<in> derangements (S - {x})\n  y \\<in> S - {x}\n\ngoal (1 subgoal):\n 1. inv d' y \\<noteq> x", "by (auto dest: derangements_inverse_in_image)"], ["proof (state)\nthis:\n  inv d' y \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       d \\<in> (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n               ((S - {x}) \\<times> derangements (S - {x})) \\<Longrightarrow>\n       d (d x) \\<noteq> x", "from inv"], ["proof (chain)\npicking this:\n  inv d' \\<in> derangements (S - {x})", "have inv_y: \"inv d' y \\<noteq> y\""], ["proof (prove)\nusing this:\n  inv d' \\<in> derangements (S - {x})\n\ngoal (1 subgoal):\n 1. inv d' y \\<noteq> y", "using d(3) derangements_no_fixpoint"], ["proof (prove)\nusing this:\n  inv d' \\<in> derangements (S - {x})\n  y \\<in> S - {x}\n  \\<lbrakk>?d \\<in> derangements ?A; ?x \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> ?d ?x \\<noteq> ?x\n\ngoal (1 subgoal):\n 1. inv d' y \\<noteq> y", "by blast"], ["proof (state)\nthis:\n  inv d' y \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       d \\<in> (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n               ((S - {x}) \\<times> derangements (S - {x})) \\<Longrightarrow>\n       d (d x) \\<noteq> x", "from d inv_x"], ["proof (chain)\npicking this:\n  d = d'(x := y, inv d' y := x)\n  d' \\<in> derangements (S - {x})\n  y \\<in> S - {x}\n  inv d' y \\<noteq> x", "have 1: \"d x = y\""], ["proof (prove)\nusing this:\n  d = d'(x := y, inv d' y := x)\n  d' \\<in> derangements (S - {x})\n  y \\<in> S - {x}\n  inv d' y \\<noteq> x\n\ngoal (1 subgoal):\n 1. d x = y", "by auto"], ["proof (state)\nthis:\n  d x = y\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       d \\<in> (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n               ((S - {x}) \\<times> derangements (S - {x})) \\<Longrightarrow>\n       d (d x) \\<noteq> x", "from d inv_y"], ["proof (chain)\npicking this:\n  d = d'(x := y, inv d' y := x)\n  d' \\<in> derangements (S - {x})\n  y \\<in> S - {x}\n  inv d' y \\<noteq> y", "have 2: \"d y = d' y\""], ["proof (prove)\nusing this:\n  d = d'(x := y, inv d' y := x)\n  d' \\<in> derangements (S - {x})\n  y \\<in> S - {x}\n  inv d' y \\<noteq> y\n\ngoal (1 subgoal):\n 1. d y = d' y", "by auto"], ["proof (state)\nthis:\n  d y = d' y\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       d \\<in> (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n               ((S - {x}) \\<times> derangements (S - {x})) \\<Longrightarrow>\n       d (d x) \\<noteq> x", "from d(2, 3)"], ["proof (chain)\npicking this:\n  d' \\<in> derangements (S - {x})\n  y \\<in> S - {x}", "have 3: \"d' y \\<in> S - {x}\""], ["proof (prove)\nusing this:\n  d' \\<in> derangements (S - {x})\n  y \\<in> S - {x}\n\ngoal (1 subgoal):\n 1. d' y \\<in> S - {x}", "by (auto dest: derangements_in_image)"], ["proof (state)\nthis:\n  d' y \\<in> S - {x}\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       d \\<in> (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n               ((S - {x}) \\<times> derangements (S - {x})) \\<Longrightarrow>\n       d (d x) \\<noteq> x", "from 1 2 3"], ["proof (chain)\npicking this:\n  d x = y\n  d y = d' y\n  d' y \\<in> S - {x}", "show \"d (d x) \\<noteq> x\""], ["proof (prove)\nusing this:\n  d x = y\n  d y = d' y\n  d' y \\<in> S - {x}\n\ngoal (1 subgoal):\n 1. d (d x) \\<noteq> x", "by auto"], ["proof (state)\nthis:\n  d (d x) \\<noteq> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?d \\<in> (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n           ((S - {x}) \\<times> derangements (S - {x})) \\<Longrightarrow>\n  ?d (?d x) \\<noteq> x\n\ngoal (1 subgoal):\n 1. (\\<lambda>(y, d). Fun.swap x y d) `\n    {(y, d).\n     y \\<in> S \\<and>\n     y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<inter>\n    (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n    ((S - {x}) \\<times> derangements (S - {x})) =\n    {}", "from this that"], ["proof (chain)\npicking this:\n  ?d \\<in> (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n           ((S - {x}) \\<times> derangements (S - {x})) \\<Longrightarrow>\n  ?d (?d x) \\<noteq> x\n  ?d \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n           {(y, d).\n            y \\<in> S \\<and>\n            y \\<noteq> x \\<and>\n            d \\<in> derangements (S - {x, y})} \\<Longrightarrow>\n  ?d (?d x) = x", "show ?thesis"], ["proof (prove)\nusing this:\n  ?d \\<in> (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n           ((S - {x}) \\<times> derangements (S - {x})) \\<Longrightarrow>\n  ?d (?d x) \\<noteq> x\n  ?d \\<in> (\\<lambda>(y, d). Fun.swap x y d) `\n           {(y, d).\n            y \\<in> S \\<and>\n            y \\<noteq> x \\<and>\n            d \\<in> derangements (S - {x, y})} \\<Longrightarrow>\n  ?d (?d x) = x\n\ngoal (1 subgoal):\n 1. (\\<lambda>(y, d). Fun.swap x y d) `\n    {(y, d).\n     y \\<in> S \\<and>\n     y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<inter>\n    (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n    ((S - {x}) \\<times> derangements (S - {x})) =\n    {}", "by blast"], ["proof (state)\nthis:\n  (\\<lambda>(y, d). Fun.swap x y d) `\n  {(y, d).\n   y \\<in> S \\<and>\n   y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<inter>\n  (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n  ((S - {x}) \\<times> derangements (S - {x})) =\n  {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>(y, d). Fun.swap x y d) `\n  {(y, d).\n   y \\<in> S \\<and>\n   y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})} \\<inter>\n  (\\<lambda>(y, f). f(x := y, inv f y := x)) `\n  ((S - {x}) \\<times> derangements (S - {x})) =\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>n S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>finite S; card S = Suc n\\<rbrakk>\n                   \\<Longrightarrow> card (derangements S) =\n                                     count_derangements (Suc n);\n        \\<And>S.\n           \\<lbrakk>finite S; card S = n\\<rbrakk>\n           \\<Longrightarrow> card (derangements S) = count_derangements n;\n        finite S; card S = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> card (derangements S) =\n                         count_derangements (Suc (Suc n))", "have inj: \"inj_on (\\<lambda>(y, f). Fun.swap x y f) {(y, f). y \\<in> S & y \\<noteq> x & f : derangements (S - {x, y})}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(y, f). Fun.swap x y f)\n     {(y, f).\n      y \\<in> S \\<and>\n      y \\<noteq> x \\<and> f \\<in> derangements (S - {x, y})}", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa\\<in>{(y, f).\n                     y \\<in> S \\<and>\n                     y \\<noteq> x \\<and> f \\<in> derangements (S - {x, y})}.\n       \\<forall>y\\<in>{(y, f).\n                       y \\<in> S \\<and>\n                       y \\<noteq> x \\<and>\n                       f \\<in> derangements (S - {x, y})}.\n          (case xa of (xa, xb) \\<Rightarrow> Fun.swap x xa xb) =\n          (case y of\n           (xa, xb) \\<Rightarrow> Fun.swap x xa xb) \\<longrightarrow>\n          xa = y", "by (clarify; metis DiffD2 derangements_fixpoint insertI1 insert_commute swap_apply(1) swap_nilpotent)"], ["proof (state)\nthis:\n  inj_on (\\<lambda>(y, f). Fun.swap x y f)\n   {(y, f).\n    y \\<in> S \\<and> y \\<noteq> x \\<and> f \\<in> derangements (S - {x, y})}\n\ngoal (1 subgoal):\n 1. \\<And>n S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>finite S; card S = Suc n\\<rbrakk>\n                   \\<Longrightarrow> card (derangements S) =\n                                     count_derangements (Suc n);\n        \\<And>S.\n           \\<lbrakk>finite S; card S = n\\<rbrakk>\n           \\<Longrightarrow> card (derangements S) = count_derangements n;\n        finite S; card S = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> card (derangements S) =\n                         count_derangements (Suc (Suc n))", "have eq: \"{(y, f). y \\<in> S & y \\<noteq> x & f : derangements (S - {x, y})} = {(y, f). y \\<in> S - {x} & f : derangements (S - {x, y})}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(y, f).\n     y \\<in> S \\<and>\n     y \\<noteq> x \\<and> f \\<in> derangements (S - {x, y})} =\n    {(y, f). y \\<in> S - {x} \\<and> f \\<in> derangements (S - {x, y})}", "by simp"], ["proof (state)\nthis:\n  {(y, f).\n   y \\<in> S \\<and> y \\<noteq> x \\<and> f \\<in> derangements (S - {x, y})} =\n  {(y, f). y \\<in> S - {x} \\<and> f \\<in> derangements (S - {x, y})}\n\ngoal (1 subgoal):\n 1. \\<And>n S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>finite S; card S = Suc n\\<rbrakk>\n                   \\<Longrightarrow> card (derangements S) =\n                                     count_derangements (Suc n);\n        \\<And>S.\n           \\<lbrakk>finite S; card S = n\\<rbrakk>\n           \\<Longrightarrow> card (derangements S) = count_derangements n;\n        finite S; card S = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> card (derangements S) =\n                         count_derangements (Suc (Suc n))", "have eq': \"{(y, f). y \\<in> S & y \\<noteq> x & f : derangements (S - {x, y})} = Sigma (S - {x}) (%y. derangements (S - {x, y}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(y, f).\n     y \\<in> S \\<and>\n     y \\<noteq> x \\<and> f \\<in> derangements (S - {x, y})} =\n    (SIGMA y:S - {x}. derangements (S - {x, y}))", "unfolding Sigma_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(y, f).\n     y \\<in> S \\<and>\n     y \\<noteq> x \\<and> f \\<in> derangements (S - {x, y})} =\n    (\\<Union>xa\\<in>S - {x}.\n        \\<Union>y\\<in>derangements (S - {x, xa}). {(xa, y)})", "by auto"], ["proof (state)\nthis:\n  {(y, f).\n   y \\<in> S \\<and> y \\<noteq> x \\<and> f \\<in> derangements (S - {x, y})} =\n  (SIGMA y:S - {x}. derangements (S - {x, y}))\n\ngoal (1 subgoal):\n 1. \\<And>n S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>finite S; card S = Suc n\\<rbrakk>\n                   \\<Longrightarrow> card (derangements S) =\n                                     count_derangements (Suc n);\n        \\<And>S.\n           \\<lbrakk>finite S; card S = n\\<rbrakk>\n           \\<Longrightarrow> card (derangements S) = count_derangements n;\n        finite S; card S = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> card (derangements S) =\n                         count_derangements (Suc (Suc n))", "have card: \"\\<And> y. y \\<in> S - {x} \\<Longrightarrow> card (derangements (S - {x, y})) = count_derangements n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> S - {x} \\<Longrightarrow>\n       card (derangements (S - {x, y})) = count_derangements n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> S - {x} \\<Longrightarrow>\n       card (derangements (S - {x, y})) = count_derangements n", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> S - {x} \\<Longrightarrow>\n       card (derangements (S - {x, y})) = count_derangements n", "assume \"y \\<in> S - {x}\""], ["proof (state)\nthis:\n  y \\<in> S - {x}\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> S - {x} \\<Longrightarrow>\n       card (derangements (S - {x, y})) = count_derangements n", "from 3(3, 4) \\<open>x \\<in> S\\<close> this"], ["proof (chain)\npicking this:\n  finite S\n  card S = Suc (Suc n)\n  x \\<in> S\n  y \\<in> S - {x}", "have \"card (S - {x, y}) = n\""], ["proof (prove)\nusing this:\n  finite S\n  card S = Suc (Suc n)\n  x \\<in> S\n  y \\<in> S - {x}\n\ngoal (1 subgoal):\n 1. card (S - {x, y}) = n", "by (metis Diff_insert2 card_Diff_singleton diff_Suc_1 finite_Diff)"], ["proof (state)\nthis:\n  card (S - {x, y}) = n\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> S - {x} \\<Longrightarrow>\n       card (derangements (S - {x, y})) = count_derangements n", "from 3(3) 3(2)[OF _ this]"], ["proof (chain)\npicking this:\n  finite S\n  finite (S - {x, y}) \\<Longrightarrow>\n  card (derangements (S - {x, y})) = count_derangements n", "show \"card (derangements (S - {x, y})) = count_derangements n\""], ["proof (prove)\nusing this:\n  finite S\n  finite (S - {x, y}) \\<Longrightarrow>\n  card (derangements (S - {x, y})) = count_derangements n\n\ngoal (1 subgoal):\n 1. card (derangements (S - {x, y})) = count_derangements n", "by auto"], ["proof (state)\nthis:\n  card (derangements (S - {x, y})) = count_derangements n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?y \\<in> S - {x} \\<Longrightarrow>\n  card (derangements (S - {x, ?y})) = count_derangements n\n\ngoal (1 subgoal):\n 1. \\<And>n S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>finite S; card S = Suc n\\<rbrakk>\n                   \\<Longrightarrow> card (derangements S) =\n                                     count_derangements (Suc n);\n        \\<And>S.\n           \\<lbrakk>finite S; card S = n\\<rbrakk>\n           \\<Longrightarrow> card (derangements S) = count_derangements n;\n        finite S; card S = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> card (derangements S) =\n                         count_derangements (Suc (Suc n))", "from 3(3, 4) \\<open>x : S\\<close>"], ["proof (chain)\npicking this:\n  finite S\n  card S = Suc (Suc n)\n  x \\<in> S", "have card2: \"card (S - {x}) = Suc n\""], ["proof (prove)\nusing this:\n  finite S\n  card S = Suc (Suc n)\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. card (S - {x}) = Suc n", "by (simp add: card.insert_remove insert_absorb)"], ["proof (state)\nthis:\n  card (S - {x}) = Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>finite S; card S = Suc n\\<rbrakk>\n                   \\<Longrightarrow> card (derangements S) =\n                                     count_derangements (Suc n);\n        \\<And>S.\n           \\<lbrakk>finite S; card S = n\\<rbrakk>\n           \\<Longrightarrow> card (derangements S) = count_derangements n;\n        finite S; card S = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> card (derangements S) =\n                         count_derangements (Suc (Suc n))", "from inj"], ["proof (chain)\npicking this:\n  inj_on (\\<lambda>(y, f). Fun.swap x y f)\n   {(y, f).\n    y \\<in> S \\<and> y \\<noteq> x \\<and> f \\<in> derangements (S - {x, y})}", "have \"card ?D1 = card {(y, f). y \\<in> S - {x} \\<and> f \\<in> derangements (S - {x, y})}\""], ["proof (prove)\nusing this:\n  inj_on (\\<lambda>(y, f). Fun.swap x y f)\n   {(y, f).\n    y \\<in> S \\<and> y \\<noteq> x \\<and> f \\<in> derangements (S - {x, y})}\n\ngoal (1 subgoal):\n 1. card\n     ((\\<lambda>(y, d). Fun.swap x y d) `\n      {(y, d).\n       y \\<in> S \\<and>\n       y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})}) =\n    card {(y, f). y \\<in> S - {x} \\<and> f \\<in> derangements (S - {x, y})}", "by (simp add: card_image)"], ["proof (state)\nthis:\n  card\n   ((\\<lambda>(y, d). Fun.swap x y d) `\n    {(y, d).\n     y \\<in> S \\<and>\n     y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})}) =\n  card {(y, f). y \\<in> S - {x} \\<and> f \\<in> derangements (S - {x, y})}\n\ngoal (1 subgoal):\n 1. \\<And>n S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>finite S; card S = Suc n\\<rbrakk>\n                   \\<Longrightarrow> card (derangements S) =\n                                     count_derangements (Suc n);\n        \\<And>S.\n           \\<lbrakk>finite S; card S = n\\<rbrakk>\n           \\<Longrightarrow> card (derangements S) = count_derangements n;\n        finite S; card S = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> card (derangements S) =\n                         count_derangements (Suc (Suc n))", "also"], ["proof (state)\nthis:\n  card\n   ((\\<lambda>(y, d). Fun.swap x y d) `\n    {(y, d).\n     y \\<in> S \\<and>\n     y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})}) =\n  card {(y, f). y \\<in> S - {x} \\<and> f \\<in> derangements (S - {x, y})}\n\ngoal (1 subgoal):\n 1. \\<And>n S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>finite S; card S = Suc n\\<rbrakk>\n                   \\<Longrightarrow> card (derangements S) =\n                                     count_derangements (Suc n);\n        \\<And>S.\n           \\<lbrakk>finite S; card S = n\\<rbrakk>\n           \\<Longrightarrow> card (derangements S) = count_derangements n;\n        finite S; card S = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> card (derangements S) =\n                         count_derangements (Suc (Suc n))", "from 3(3)"], ["proof (chain)\npicking this:\n  finite S", "have \"... = (\\<Sum>y\\<in>S - {x}. card (derangements (S - {x, y})))\""], ["proof (prove)\nusing this:\n  finite S\n\ngoal (1 subgoal):\n 1. card\n     {(y, f). y \\<in> S - {x} \\<and> f \\<in> derangements (S - {x, y})} =\n    (\\<Sum>y\\<in>S - {x}. card (derangements (S - {x, y})))", "by (subst card_product_dependent) (simp add: finite_derangements)+"], ["proof (state)\nthis:\n  card {(y, f). y \\<in> S - {x} \\<and> f \\<in> derangements (S - {x, y})} =\n  (\\<Sum>y\\<in>S - {x}. card (derangements (S - {x, y})))\n\ngoal (1 subgoal):\n 1. \\<And>n S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>finite S; card S = Suc n\\<rbrakk>\n                   \\<Longrightarrow> card (derangements S) =\n                                     count_derangements (Suc n);\n        \\<And>S.\n           \\<lbrakk>finite S; card S = n\\<rbrakk>\n           \\<Longrightarrow> card (derangements S) = count_derangements n;\n        finite S; card S = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> card (derangements S) =\n                         count_derangements (Suc (Suc n))", "finally"], ["proof (chain)\npicking this:\n  card\n   ((\\<lambda>(y, d). Fun.swap x y d) `\n    {(y, d).\n     y \\<in> S \\<and>\n     y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})}) =\n  (\\<Sum>y\\<in>S - {x}. card (derangements (S - {x, y})))", "have card_1: \"card ?D1 =(Suc n) * count_derangements n\""], ["proof (prove)\nusing this:\n  card\n   ((\\<lambda>(y, d). Fun.swap x y d) `\n    {(y, d).\n     y \\<in> S \\<and>\n     y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})}) =\n  (\\<Sum>y\\<in>S - {x}. card (derangements (S - {x, y})))\n\ngoal (1 subgoal):\n 1. card\n     ((\\<lambda>(y, d). Fun.swap x y d) `\n      {(y, d).\n       y \\<in> S \\<and>\n       y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})}) =\n    Suc n * count_derangements n", "using card card2"], ["proof (prove)\nusing this:\n  card\n   ((\\<lambda>(y, d). Fun.swap x y d) `\n    {(y, d).\n     y \\<in> S \\<and>\n     y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})}) =\n  (\\<Sum>y\\<in>S - {x}. card (derangements (S - {x, y})))\n  ?y \\<in> S - {x} \\<Longrightarrow>\n  card (derangements (S - {x, ?y})) = count_derangements n\n  card (S - {x}) = Suc n\n\ngoal (1 subgoal):\n 1. card\n     ((\\<lambda>(y, d). Fun.swap x y d) `\n      {(y, d).\n       y \\<in> S \\<and>\n       y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})}) =\n    Suc n * count_derangements n", "by auto"], ["proof (state)\nthis:\n  card\n   ((\\<lambda>(y, d). Fun.swap x y d) `\n    {(y, d).\n     y \\<in> S \\<and>\n     y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})}) =\n  Suc n * count_derangements n\n\ngoal (1 subgoal):\n 1. \\<And>n S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>finite S; card S = Suc n\\<rbrakk>\n                   \\<Longrightarrow> card (derangements S) =\n                                     count_derangements (Suc n);\n        \\<And>S.\n           \\<lbrakk>finite S; card S = n\\<rbrakk>\n           \\<Longrightarrow> card (derangements S) = count_derangements n;\n        finite S; card S = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> card (derangements S) =\n                         count_derangements (Suc (Suc n))", "have inj_2: \"inj_on (\\<lambda>(y, f). f(x := y, inv f y := x)) ((S - {x}) \\<times> derangements (S - {x}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(y, f). f(x := y, inv f y := x))\n     ((S - {x}) \\<times> derangements (S - {x}))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(y, f). f(x := y, inv f y := x))\n     ((S - {x}) \\<times> derangements (S - {x}))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(y, f). f(x := y, inv f y := x))\n     ((S - {x}) \\<times> derangements (S - {x}))", "fix d d' y y'"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(y, f). f(x := y, inv f y := x))\n     ((S - {x}) \\<times> derangements (S - {x}))", "assume 1: \"d \\<in> derangements (S - {x})\" \"d' \\<in> derangements (S - {x})\""], ["proof (state)\nthis:\n  d \\<in> derangements (S - {x})\n  d' \\<in> derangements (S - {x})\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(y, f). f(x := y, inv f y := x))\n     ((S - {x}) \\<times> derangements (S - {x}))", "assume 2: \"y \\<in> S\" \"y \\<noteq> x\" \"y' \\<in> S\" \"y' \\<noteq> x\""], ["proof (state)\nthis:\n  y \\<in> S\n  y \\<noteq> x\n  y' \\<in> S\n  y' \\<noteq> x\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(y, f). f(x := y, inv f y := x))\n     ((S - {x}) \\<times> derangements (S - {x}))", "assume eq: \"d(x := y, inv d y := x) = d'(x := y', inv d' y' := x)\""], ["proof (state)\nthis:\n  d(x := y, inv d y := x) = d'(x := y', inv d' y' := x)\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(y, f). f(x := y, inv f y := x))\n     ((S - {x}) \\<times> derangements (S - {x}))", "from 1 2 eq \\<open>x \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  d \\<in> derangements (S - {x})\n  d' \\<in> derangements (S - {x})\n  y \\<in> S\n  y \\<noteq> x\n  y' \\<in> S\n  y' \\<noteq> x\n  d(x := y, inv d y := x) = d'(x := y', inv d' y' := x)\n  x \\<in> S", "have y: \"y = y'\""], ["proof (prove)\nusing this:\n  d \\<in> derangements (S - {x})\n  d' \\<in> derangements (S - {x})\n  y \\<in> S\n  y \\<noteq> x\n  y' \\<in> S\n  y' \\<noteq> x\n  d(x := y, inv d y := x) = d'(x := y', inv d' y' := x)\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. y = y'", "by (metis Diff_insert_absorb derangements_in_image derangements_inv\n          fun_upd_same fun_upd_twist insert_iff mk_disjoint_insert)"], ["proof (state)\nthis:\n  y = y'\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(y, f). f(x := y, inv f y := x))\n     ((S - {x}) \\<times> derangements (S - {x}))", "have \"d = d'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d = d'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. d x = d' x", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. d x = d' x", "from 1"], ["proof (chain)\npicking this:\n  d \\<in> derangements (S - {x})\n  d' \\<in> derangements (S - {x})", "have d_x: \"d x = d' x\""], ["proof (prove)\nusing this:\n  d \\<in> derangements (S - {x})\n  d' \\<in> derangements (S - {x})\n\ngoal (1 subgoal):\n 1. d x = d' x", "by (auto dest!: derangements_fixpoint)"], ["proof (state)\nthis:\n  d x = d' x\n\ngoal (1 subgoal):\n 1. \\<And>x. d x = d' x", "from 1"], ["proof (chain)\npicking this:\n  d \\<in> derangements (S - {x})\n  d' \\<in> derangements (S - {x})", "have bij: \"bij d\" \"bij d'\""], ["proof (prove)\nusing this:\n  d \\<in> derangements (S - {x})\n  d' \\<in> derangements (S - {x})\n\ngoal (1 subgoal):\n 1. bij d &&& bij d'", "by (metis derangementsE permutes_imp_bij')+"], ["proof (state)\nthis:\n  bij d\n  bij d'\n\ngoal (1 subgoal):\n 1. \\<And>x. d x = d' x", "from this"], ["proof (chain)\npicking this:\n  bij d\n  bij d'", "have d_d: \"d (inv d y) = y\" \"d' (inv d' y') = y'\""], ["proof (prove)\nusing this:\n  bij d\n  bij d'\n\ngoal (1 subgoal):\n 1. d (inv d y) = y &&& d' (inv d' y') = y'", "by (simp add: bij_is_surj surj_f_inv_f)+"], ["proof (state)\nthis:\n  d (inv d y) = y\n  d' (inv d' y') = y'\n\ngoal (1 subgoal):\n 1. \\<And>x. d x = d' x", "from 1 2 bij"], ["proof (chain)\npicking this:\n  d \\<in> derangements (S - {x})\n  d' \\<in> derangements (S - {x})\n  y \\<in> S\n  y \\<noteq> x\n  y' \\<in> S\n  y' \\<noteq> x\n  bij d\n  bij d'", "have neq: \"d (inv d' y') \\<noteq> x \\<and> d' (inv d y) \\<noteq> x\""], ["proof (prove)\nusing this:\n  d \\<in> derangements (S - {x})\n  d' \\<in> derangements (S - {x})\n  y \\<in> S\n  y \\<noteq> x\n  y' \\<in> S\n  y' \\<noteq> x\n  bij d\n  bij d'\n\ngoal (1 subgoal):\n 1. d (inv d' y') \\<noteq> x \\<and> d' (inv d y) \\<noteq> x", "by (metis Diff_iff bij_inv_eq_iff derangements_fixpoint singletonI)"], ["proof (state)\nthis:\n  d (inv d' y') \\<noteq> x \\<and> d' (inv d y) \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>x. d x = d' x", "from eq"], ["proof (chain)\npicking this:\n  d(x := y, inv d y := x) = d'(x := y', inv d' y' := x)", "have \"(d(x := y, inv d y := x)) z = (d'(x := y', inv d' y' := x)) z\""], ["proof (prove)\nusing this:\n  d(x := y, inv d y := x) = d'(x := y', inv d' y' := x)\n\ngoal (1 subgoal):\n 1. (d(x := y, inv d y := x)) z = (d'(x := y', inv d' y' := x)) z", "by auto"], ["proof (state)\nthis:\n  (d(x := y, inv d y := x)) z = (d'(x := y', inv d' y' := x)) z\n\ngoal (1 subgoal):\n 1. \\<And>x. d x = d' x", "from y d_x d_d neq this"], ["proof (chain)\npicking this:\n  y = y'\n  d x = d' x\n  d (inv d y) = y\n  d' (inv d' y') = y'\n  d (inv d' y') \\<noteq> x \\<and> d' (inv d y) \\<noteq> x\n  (d(x := y, inv d y := x)) z = (d'(x := y', inv d' y' := x)) z", "show \"d z = d' z\""], ["proof (prove)\nusing this:\n  y = y'\n  d x = d' x\n  d (inv d y) = y\n  d' (inv d' y') = y'\n  d (inv d' y') \\<noteq> x \\<and> d' (inv d y) \\<noteq> x\n  (d(x := y, inv d y := x)) z = (d'(x := y', inv d' y' := x)) z\n\ngoal (1 subgoal):\n 1. d z = d' z", "by (auto split: if_split_asm)"], ["proof (state)\nthis:\n  d z = d' z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d = d'\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(y, f). f(x := y, inv f y := x))\n     ((S - {x}) \\<times> derangements (S - {x}))", "from y this"], ["proof (chain)\npicking this:\n  y = y'\n  d = d'", "have \"y = y' & d = d'\""], ["proof (prove)\nusing this:\n  y = y'\n  d = d'\n\ngoal (1 subgoal):\n 1. y = y' \\<and> d = d'", "by auto"], ["proof (state)\nthis:\n  y = y' \\<and> d = d'\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(y, f). f(x := y, inv f y := x))\n     ((S - {x}) \\<times> derangements (S - {x}))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?d2 \\<in> derangements (S - {x});\n   ?d'2 \\<in> derangements (S - {x}); ?y2 \\<in> S; ?y2 \\<noteq> x;\n   ?y'2 \\<in> S; ?y'2 \\<noteq> x;\n   ?d2(x := ?y2, inv ?d2 ?y2 := x) = ?d'2\n   (x := ?y'2, inv ?d'2 ?y'2 := x)\\<rbrakk>\n  \\<Longrightarrow> ?y2 = ?y'2 \\<and> ?d2 = ?d'2\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(y, f). f(x := y, inv f y := x))\n     ((S - {x}) \\<times> derangements (S - {x}))", "from this"], ["proof (chain)\npicking this:\n  \\<lbrakk>?d2 \\<in> derangements (S - {x});\n   ?d'2 \\<in> derangements (S - {x}); ?y2 \\<in> S; ?y2 \\<noteq> x;\n   ?y'2 \\<in> S; ?y'2 \\<noteq> x;\n   ?d2(x := ?y2, inv ?d2 ?y2 := x) = ?d'2\n   (x := ?y'2, inv ?d'2 ?y'2 := x)\\<rbrakk>\n  \\<Longrightarrow> ?y2 = ?y'2 \\<and> ?d2 = ?d'2", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?d2 \\<in> derangements (S - {x});\n   ?d'2 \\<in> derangements (S - {x}); ?y2 \\<in> S; ?y2 \\<noteq> x;\n   ?y'2 \\<in> S; ?y'2 \\<noteq> x;\n   ?d2(x := ?y2, inv ?d2 ?y2 := x) = ?d'2\n   (x := ?y'2, inv ?d'2 ?y'2 := x)\\<rbrakk>\n  \\<Longrightarrow> ?y2 = ?y'2 \\<and> ?d2 = ?d'2\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(y, f). f(x := y, inv f y := x))\n     ((S - {x}) \\<times> derangements (S - {x}))", "unfolding inj_on_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?d2 \\<in> derangements (S - {x});\n   ?d'2 \\<in> derangements (S - {x}); ?y2 \\<in> S; ?y2 \\<noteq> x;\n   ?y'2 \\<in> S; ?y'2 \\<noteq> x;\n   ?d2(x := ?y2, inv ?d2 ?y2 := x) = ?d'2\n   (x := ?y'2, inv ?d'2 ?y'2 := x)\\<rbrakk>\n  \\<Longrightarrow> ?y2 = ?y'2 \\<and> ?d2 = ?d'2\n\ngoal (1 subgoal):\n 1. \\<forall>xa\\<in>(S - {x}) \\<times> derangements (S - {x}).\n       \\<forall>y\\<in>(S - {x}) \\<times> derangements (S - {x}).\n          (case xa of (y, f) \\<Rightarrow> f(x := y, inv f y := x)) =\n          (case y of\n           (y, f) \\<Rightarrow> f(x := y, inv f y := x)) \\<longrightarrow>\n          xa = y", "by auto"], ["proof (state)\nthis:\n  inj_on (\\<lambda>(y, f). f(x := y, inv f y := x))\n   ((S - {x}) \\<times> derangements (S - {x}))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on (\\<lambda>(y, f). f(x := y, inv f y := x))\n   ((S - {x}) \\<times> derangements (S - {x}))\n\ngoal (1 subgoal):\n 1. \\<And>n S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>finite S; card S = Suc n\\<rbrakk>\n                   \\<Longrightarrow> card (derangements S) =\n                                     count_derangements (Suc n);\n        \\<And>S.\n           \\<lbrakk>finite S; card S = n\\<rbrakk>\n           \\<Longrightarrow> card (derangements S) = count_derangements n;\n        finite S; card S = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> card (derangements S) =\n                         count_derangements (Suc (Suc n))", "from 3(3) 3(1)[OF _ card2]"], ["proof (chain)\npicking this:\n  finite S\n  finite (S - {x}) \\<Longrightarrow>\n  card (derangements (S - {x})) = count_derangements (Suc n)", "have card3: \"card (derangements (S - {x})) = count_derangements (Suc n)\""], ["proof (prove)\nusing this:\n  finite S\n  finite (S - {x}) \\<Longrightarrow>\n  card (derangements (S - {x})) = count_derangements (Suc n)\n\ngoal (1 subgoal):\n 1. card (derangements (S - {x})) = count_derangements (Suc n)", "by auto"], ["proof (state)\nthis:\n  card (derangements (S - {x})) = count_derangements (Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>n S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>finite S; card S = Suc n\\<rbrakk>\n                   \\<Longrightarrow> card (derangements S) =\n                                     count_derangements (Suc n);\n        \\<And>S.\n           \\<lbrakk>finite S; card S = n\\<rbrakk>\n           \\<Longrightarrow> card (derangements S) = count_derangements n;\n        finite S; card S = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> card (derangements S) =\n                         count_derangements (Suc (Suc n))", "from 3(3) inj_2"], ["proof (chain)\npicking this:\n  finite S\n  inj_on (\\<lambda>(y, f). f(x := y, inv f y := x))\n   ((S - {x}) \\<times> derangements (S - {x}))", "have card_2: \"card ?D2 = (Suc n) * count_derangements (Suc n)\""], ["proof (prove)\nusing this:\n  finite S\n  inj_on (\\<lambda>(y, f). f(x := y, inv f y := x))\n   ((S - {x}) \\<times> derangements (S - {x}))\n\ngoal (1 subgoal):\n 1. card\n     ((\\<lambda>(y, f). f(x := y, inv f y := x)) `\n      ((S - {x}) \\<times> derangements (S - {x}))) =\n    Suc n * count_derangements (Suc n)", "by (simp only: card_image) (auto simp add: card_cartesian_product card3 card2)"], ["proof (state)\nthis:\n  card\n   ((\\<lambda>(y, f). f(x := y, inv f y := x)) `\n    ((S - {x}) \\<times> derangements (S - {x}))) =\n  Suc n * count_derangements (Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>n S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>finite S; card S = Suc n\\<rbrakk>\n                   \\<Longrightarrow> card (derangements S) =\n                                     count_derangements (Suc n);\n        \\<And>S.\n           \\<lbrakk>finite S; card S = n\\<rbrakk>\n           \\<Longrightarrow> card (derangements S) = count_derangements n;\n        finite S; card S = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> card (derangements S) =\n                         count_derangements (Suc (Suc n))", "from \\<open>finite S\\<close>"], ["proof (chain)\npicking this:\n  finite S", "have finite1: \"finite ?D1\""], ["proof (prove)\nusing this:\n  finite S\n\ngoal (1 subgoal):\n 1. finite\n     ((\\<lambda>(y, d). Fun.swap x y d) `\n      {(y, d).\n       y \\<in> S \\<and>\n       y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})})", "unfolding eq'"], ["proof (prove)\nusing this:\n  finite S\n\ngoal (1 subgoal):\n 1. finite\n     ((\\<lambda>(y, d). Fun.swap x y d) `\n      (SIGMA y:S - {x}. derangements (S - {x, y})))", "by (auto intro: finite_derangements)"], ["proof (state)\nthis:\n  finite\n   ((\\<lambda>(y, d). Fun.swap x y d) `\n    {(y, d).\n     y \\<in> S \\<and>\n     y \\<noteq> x \\<and> d \\<in> derangements (S - {x, y})})\n\ngoal (1 subgoal):\n 1. \\<And>n S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>finite S; card S = Suc n\\<rbrakk>\n                   \\<Longrightarrow> card (derangements S) =\n                                     count_derangements (Suc n);\n        \\<And>S.\n           \\<lbrakk>finite S; card S = n\\<rbrakk>\n           \\<Longrightarrow> card (derangements S) = count_derangements n;\n        finite S; card S = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> card (derangements S) =\n                         count_derangements (Suc (Suc n))", "from \\<open>finite S\\<close>"], ["proof (chain)\npicking this:\n  finite S", "have finite2: \"finite ?D2\""], ["proof (prove)\nusing this:\n  finite S\n\ngoal (1 subgoal):\n 1. finite\n     ((\\<lambda>(y, f). f(x := y, inv f y := x)) `\n      ((S - {x}) \\<times> derangements (S - {x})))", "by (auto intro: finite_cartesian_product finite_derangements)"], ["proof (state)\nthis:\n  finite\n   ((\\<lambda>(y, f). f(x := y, inv f y := x)) `\n    ((S - {x}) \\<times> derangements (S - {x})))\n\ngoal (1 subgoal):\n 1. \\<And>n S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>finite S; card S = Suc n\\<rbrakk>\n                   \\<Longrightarrow> card (derangements S) =\n                                     count_derangements (Suc n);\n        \\<And>S.\n           \\<lbrakk>finite S; card S = n\\<rbrakk>\n           \\<Longrightarrow> card (derangements S) = count_derangements n;\n        finite S; card S = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> card (derangements S) =\n                         count_derangements (Suc (Suc n))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (derangements S) = count_derangements (Suc (Suc n))", "by (simp add: split card_Un_disjoint finite1 finite2 no_intersect card_1 card_2 field_simps)"], ["proof (state)\nthis:\n  card (derangements S) = count_derangements (Suc (Suc n))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Closed-Form Characterization\\<close>"], ["", "lemma count_derangements:\n  \"real (count_derangements n) = fact n * (\\<Sum>k \\<in> {0..n}. (-1) ^ k / fact k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (count_derangements n) =\n    fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k)", "proof (induct n rule: count_derangements.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. real (count_derangements 0) =\n    fact 0 * (\\<Sum>k = 0..0. (- 1) ^ k / fact k)\n 2. real (count_derangements (Suc 0)) =\n    fact (Suc 0) * (\\<Sum>k = 0..Suc 0. (- 1) ^ k / fact k)\n 3. \\<And>n.\n       \\<lbrakk>real (count_derangements (Suc n)) =\n                fact (Suc n) * (\\<Sum>k = 0..Suc n. (- 1) ^ k / fact k);\n        real (count_derangements n) =\n        fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k)\\<rbrakk>\n       \\<Longrightarrow> real (count_derangements (Suc (Suc n))) =\n                         fact (Suc (Suc n)) *\n                         (\\<Sum>k = 0..Suc (Suc n). (- 1) ^ k / fact k)", "case (3 n)"], ["proof (state)\nthis:\n  real (count_derangements (Suc n)) =\n  fact (Suc n) * (\\<Sum>k = 0..Suc n. (- 1) ^ k / fact k)\n  real (count_derangements n) =\n  fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k)\n\ngoal (3 subgoals):\n 1. real (count_derangements 0) =\n    fact 0 * (\\<Sum>k = 0..0. (- 1) ^ k / fact k)\n 2. real (count_derangements (Suc 0)) =\n    fact (Suc 0) * (\\<Sum>k = 0..Suc 0. (- 1) ^ k / fact k)\n 3. \\<And>n.\n       \\<lbrakk>real (count_derangements (Suc n)) =\n                fact (Suc n) * (\\<Sum>k = 0..Suc n. (- 1) ^ k / fact k);\n        real (count_derangements n) =\n        fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k)\\<rbrakk>\n       \\<Longrightarrow> real (count_derangements (Suc (Suc n))) =\n                         fact (Suc (Suc n)) *\n                         (\\<Sum>k = 0..Suc (Suc n). (- 1) ^ k / fact k)", "let ?f = \"\\<lambda>n. fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k)\""], ["proof (state)\ngoal (3 subgoals):\n 1. real (count_derangements 0) =\n    fact 0 * (\\<Sum>k = 0..0. (- 1) ^ k / fact k)\n 2. real (count_derangements (Suc 0)) =\n    fact (Suc 0) * (\\<Sum>k = 0..Suc 0. (- 1) ^ k / fact k)\n 3. \\<And>n.\n       \\<lbrakk>real (count_derangements (Suc n)) =\n                fact (Suc n) * (\\<Sum>k = 0..Suc n. (- 1) ^ k / fact k);\n        real (count_derangements n) =\n        fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k)\\<rbrakk>\n       \\<Longrightarrow> real (count_derangements (Suc (Suc n))) =\n                         fact (Suc (Suc n)) *\n                         (\\<Sum>k = 0..Suc (Suc n). (- 1) ^ k / fact k)", "have \"real (count_derangements (Suc (Suc n))) = (n + 1) * (count_derangements (n + 1) + count_derangements n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (count_derangements (Suc (Suc n))) =\n    real ((n + 1) * (count_derangements (n + 1) + count_derangements n))", "unfolding count_derangements.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. real ((n + 1) * (count_derangements (Suc n) + count_derangements n)) =\n    real ((n + 1) * (count_derangements (n + 1) + count_derangements n))", "by simp"], ["proof (state)\nthis:\n  real (count_derangements (Suc (Suc n))) =\n  real ((n + 1) * (count_derangements (n + 1) + count_derangements n))\n\ngoal (3 subgoals):\n 1. real (count_derangements 0) =\n    fact 0 * (\\<Sum>k = 0..0. (- 1) ^ k / fact k)\n 2. real (count_derangements (Suc 0)) =\n    fact (Suc 0) * (\\<Sum>k = 0..Suc 0. (- 1) ^ k / fact k)\n 3. \\<And>n.\n       \\<lbrakk>real (count_derangements (Suc n)) =\n                fact (Suc n) * (\\<Sum>k = 0..Suc n. (- 1) ^ k / fact k);\n        real (count_derangements n) =\n        fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k)\\<rbrakk>\n       \\<Longrightarrow> real (count_derangements (Suc (Suc n))) =\n                         fact (Suc (Suc n)) *\n                         (\\<Sum>k = 0..Suc (Suc n). (- 1) ^ k / fact k)", "also"], ["proof (state)\nthis:\n  real (count_derangements (Suc (Suc n))) =\n  real ((n + 1) * (count_derangements (n + 1) + count_derangements n))\n\ngoal (3 subgoals):\n 1. real (count_derangements 0) =\n    fact 0 * (\\<Sum>k = 0..0. (- 1) ^ k / fact k)\n 2. real (count_derangements (Suc 0)) =\n    fact (Suc 0) * (\\<Sum>k = 0..Suc 0. (- 1) ^ k / fact k)\n 3. \\<And>n.\n       \\<lbrakk>real (count_derangements (Suc n)) =\n                fact (Suc n) * (\\<Sum>k = 0..Suc n. (- 1) ^ k / fact k);\n        real (count_derangements n) =\n        fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k)\\<rbrakk>\n       \\<Longrightarrow> real (count_derangements (Suc (Suc n))) =\n                         fact (Suc (Suc n)) *\n                         (\\<Sum>k = 0..Suc (Suc n). (- 1) ^ k / fact k)", "have \"... = real (n + 1) * (real (count_derangements (n + 1)) + real (count_derangements n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real ((n + 1) * (count_derangements (n + 1) + count_derangements n)) =\n    real (n + 1) *\n    (real (count_derangements (n + 1)) + real (count_derangements n))", "by (simp only: of_nat_mult of_nat_add)"], ["proof (state)\nthis:\n  real ((n + 1) * (count_derangements (n + 1) + count_derangements n)) =\n  real (n + 1) *\n  (real (count_derangements (n + 1)) + real (count_derangements n))\n\ngoal (3 subgoals):\n 1. real (count_derangements 0) =\n    fact 0 * (\\<Sum>k = 0..0. (- 1) ^ k / fact k)\n 2. real (count_derangements (Suc 0)) =\n    fact (Suc 0) * (\\<Sum>k = 0..Suc 0. (- 1) ^ k / fact k)\n 3. \\<And>n.\n       \\<lbrakk>real (count_derangements (Suc n)) =\n                fact (Suc n) * (\\<Sum>k = 0..Suc n. (- 1) ^ k / fact k);\n        real (count_derangements n) =\n        fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k)\\<rbrakk>\n       \\<Longrightarrow> real (count_derangements (Suc (Suc n))) =\n                         fact (Suc (Suc n)) *\n                         (\\<Sum>k = 0..Suc (Suc n). (- 1) ^ k / fact k)", "also"], ["proof (state)\nthis:\n  real ((n + 1) * (count_derangements (n + 1) + count_derangements n)) =\n  real (n + 1) *\n  (real (count_derangements (n + 1)) + real (count_derangements n))\n\ngoal (3 subgoals):\n 1. real (count_derangements 0) =\n    fact 0 * (\\<Sum>k = 0..0. (- 1) ^ k / fact k)\n 2. real (count_derangements (Suc 0)) =\n    fact (Suc 0) * (\\<Sum>k = 0..Suc 0. (- 1) ^ k / fact k)\n 3. \\<And>n.\n       \\<lbrakk>real (count_derangements (Suc n)) =\n                fact (Suc n) * (\\<Sum>k = 0..Suc n. (- 1) ^ k / fact k);\n        real (count_derangements n) =\n        fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k)\\<rbrakk>\n       \\<Longrightarrow> real (count_derangements (Suc (Suc n))) =\n                         fact (Suc (Suc n)) *\n                         (\\<Sum>k = 0..Suc (Suc n). (- 1) ^ k / fact k)", "have \"... = (n + 1) * (?f (n + 1) + ?f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (n + 1) *\n    (real (count_derangements (n + 1)) + real (count_derangements n)) =\n    real (n + 1) *\n    (fact (n + 1) * (\\<Sum>k = 0..n + 1. (- 1) ^ k / fact k) +\n     fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k))", "unfolding 3(2) 3(1)[unfolded Suc_eq_plus1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (n + 1) *\n    (fact (n + 1) * (\\<Sum>k = 0..n + 1. (- 1) ^ k / fact k) +\n     fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k)) =\n    real (n + 1) *\n    (fact (n + 1) * (\\<Sum>k = 0..n + 1. (- 1) ^ k / fact k) +\n     fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k))", ".."], ["proof (state)\nthis:\n  real (n + 1) *\n  (real (count_derangements (n + 1)) + real (count_derangements n)) =\n  real (n + 1) *\n  (fact (n + 1) * (\\<Sum>k = 0..n + 1. (- 1) ^ k / fact k) +\n   fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k))\n\ngoal (3 subgoals):\n 1. real (count_derangements 0) =\n    fact 0 * (\\<Sum>k = 0..0. (- 1) ^ k / fact k)\n 2. real (count_derangements (Suc 0)) =\n    fact (Suc 0) * (\\<Sum>k = 0..Suc 0. (- 1) ^ k / fact k)\n 3. \\<And>n.\n       \\<lbrakk>real (count_derangements (Suc n)) =\n                fact (Suc n) * (\\<Sum>k = 0..Suc n. (- 1) ^ k / fact k);\n        real (count_derangements n) =\n        fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k)\\<rbrakk>\n       \\<Longrightarrow> real (count_derangements (Suc (Suc n))) =\n                         fact (Suc (Suc n)) *\n                         (\\<Sum>k = 0..Suc (Suc n). (- 1) ^ k / fact k)", "also"], ["proof (state)\nthis:\n  real (n + 1) *\n  (real (count_derangements (n + 1)) + real (count_derangements n)) =\n  real (n + 1) *\n  (fact (n + 1) * (\\<Sum>k = 0..n + 1. (- 1) ^ k / fact k) +\n   fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k))\n\ngoal (3 subgoals):\n 1. real (count_derangements 0) =\n    fact 0 * (\\<Sum>k = 0..0. (- 1) ^ k / fact k)\n 2. real (count_derangements (Suc 0)) =\n    fact (Suc 0) * (\\<Sum>k = 0..Suc 0. (- 1) ^ k / fact k)\n 3. \\<And>n.\n       \\<lbrakk>real (count_derangements (Suc n)) =\n                fact (Suc n) * (\\<Sum>k = 0..Suc n. (- 1) ^ k / fact k);\n        real (count_derangements n) =\n        fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k)\\<rbrakk>\n       \\<Longrightarrow> real (count_derangements (Suc (Suc n))) =\n                         fact (Suc (Suc n)) *\n                         (\\<Sum>k = 0..Suc (Suc n). (- 1) ^ k / fact k)", "have \"(n + 1) * (?f (n + 1) + ?f n) = ?f (n + 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (n + 1) *\n    (fact (n + 1) * (\\<Sum>k = 0..n + 1. (- 1) ^ k / fact k) +\n     fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k)) =\n    fact (n + 2) * (\\<Sum>k = 0..n + 2. (- 1) ^ k / fact k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real (n + 1) *\n    (fact (n + 1) * (\\<Sum>k = 0..n + 1. (- 1) ^ k / fact k) +\n     fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k)) =\n    fact (n + 2) * (\\<Sum>k = 0..n + 2. (- 1) ^ k / fact k)", "define f where \"f n = ((fact n) :: real) * (\\<Sum>k = 0..n. (- 1) ^ k / fact k)\" for n"], ["proof (state)\nthis:\n  f ?n = fact ?n * (\\<Sum>k = 0..?n. (- 1) ^ k / fact k)\n\ngoal (1 subgoal):\n 1. real (n + 1) *\n    (fact (n + 1) * (\\<Sum>k = 0..n + 1. (- 1) ^ k / fact k) +\n     fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k)) =\n    fact (n + 2) * (\\<Sum>k = 0..n + 2. (- 1) ^ k / fact k)", "have f_eq: \"\\<And>n. f (n + 1) = (n + 1) * f n + (- 1) ^ (n + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. f (n + 1) = (real n + 1) * f n + (- 1) ^ (n + 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. f (n + 1) = (real n + 1) * f n + (- 1) ^ (n + 1)", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. f (n + 1) = (real n + 1) * f n + (- 1) ^ (n + 1)", "have \"?f (n + 1) = (n + 1) * fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k) + fact (n + 1) * ((- 1) ^ (n + 1) / fact (n + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fact (n + 1) * (\\<Sum>k = 0..n + 1. (- 1) ^ k / fact k) =\n    real ((n + 1) * fact n) * (\\<Sum>k = 0..n. (- 1) ^ k / fact k) +\n    fact (n + 1) * ((- 1) ^ (n + 1) / fact (n + 1))", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  fact (n + 1) * (\\<Sum>k = 0..n + 1. (- 1) ^ k / fact k) =\n  real ((n + 1) * fact n) * (\\<Sum>k = 0..n. (- 1) ^ k / fact k) +\n  fact (n + 1) * ((- 1) ^ (n + 1) / fact (n + 1))\n\ngoal (1 subgoal):\n 1. \\<And>n. f (n + 1) = (real n + 1) * f n + (- 1) ^ (n + 1)", "also"], ["proof (state)\nthis:\n  fact (n + 1) * (\\<Sum>k = 0..n + 1. (- 1) ^ k / fact k) =\n  real ((n + 1) * fact n) * (\\<Sum>k = 0..n. (- 1) ^ k / fact k) +\n  fact (n + 1) * ((- 1) ^ (n + 1) / fact (n + 1))\n\ngoal (1 subgoal):\n 1. \\<And>n. f (n + 1) = (real n + 1) * f n + (- 1) ^ (n + 1)", "have \"... = (n + 1) * ?f n + (- 1) ^ (n + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real ((n + 1) * fact n) * (\\<Sum>k = 0..n. (- 1) ^ k / fact k) +\n    fact (n + 1) * ((- 1) ^ (n + 1) / fact (n + 1)) =\n    real (n + 1) * (fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k)) +\n    (- 1) ^ (n + 1)", "by (simp del: One_nat_def)"], ["proof (state)\nthis:\n  real ((n + 1) * fact n) * (\\<Sum>k = 0..n. (- 1) ^ k / fact k) +\n  fact (n + 1) * ((- 1) ^ (n + 1) / fact (n + 1)) =\n  real (n + 1) * (fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k)) +\n  (- 1) ^ (n + 1)\n\ngoal (1 subgoal):\n 1. \\<And>n. f (n + 1) = (real n + 1) * f n + (- 1) ^ (n + 1)", "finally"], ["proof (chain)\npicking this:\n  fact (n + 1) * (\\<Sum>k = 0..n + 1. (- 1) ^ k / fact k) =\n  real (n + 1) * (fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k)) +\n  (- 1) ^ (n + 1)", "show \"?thesis n\""], ["proof (prove)\nusing this:\n  fact (n + 1) * (\\<Sum>k = 0..n + 1. (- 1) ^ k / fact k) =\n  real (n + 1) * (fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k)) +\n  (- 1) ^ (n + 1)\n\ngoal (1 subgoal):\n 1. f (n + 1) = (real n + 1) * f n + (- 1) ^ (n + 1)", "unfolding f_def"], ["proof (prove)\nusing this:\n  fact (n + 1) * (\\<Sum>k = 0..n + 1. (- 1) ^ k / fact k) =\n  real (n + 1) * (fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k)) +\n  (- 1) ^ (n + 1)\n\ngoal (1 subgoal):\n 1. fact (n + 1) * (\\<Sum>k = 0..n + 1. (- 1) ^ k / fact k) =\n    (real n + 1) * (fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k)) +\n    (- 1) ^ (n + 1)", "by simp"], ["proof (state)\nthis:\n  f (n + 1) = (real n + 1) * f n + (- 1) ^ (n + 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f (?n1 + 1) = (real ?n1 + 1) * f ?n1 + (- 1) ^ (?n1 + 1)\n\ngoal (1 subgoal):\n 1. real (n + 1) *\n    (fact (n + 1) * (\\<Sum>k = 0..n + 1. (- 1) ^ k / fact k) +\n     fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k)) =\n    fact (n + 2) * (\\<Sum>k = 0..n + 2. (- 1) ^ k / fact k)", "from this"], ["proof (chain)\npicking this:\n  f (?n1 + 1) = (real ?n1 + 1) * f ?n1 + (- 1) ^ (?n1 + 1)", "have f_eq': \"\\<And> n. (n + 1) * f n = f (n + 1) + (- 1) ^ n\""], ["proof (prove)\nusing this:\n  f (?n1 + 1) = (real ?n1 + 1) * f ?n1 + (- 1) ^ (?n1 + 1)\n\ngoal (1 subgoal):\n 1. \\<And>n. (real n + 1) * f n = f (n + 1) + (- 1) ^ n", "by auto"], ["proof (state)\nthis:\n  (real ?n1 + 1) * f ?n1 = f (?n1 + 1) + (- 1) ^ ?n1\n\ngoal (1 subgoal):\n 1. real (n + 1) *\n    (fact (n + 1) * (\\<Sum>k = 0..n + 1. (- 1) ^ k / fact k) +\n     fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k)) =\n    fact (n + 2) * (\\<Sum>k = 0..n + 2. (- 1) ^ k / fact k)", "from f_eq'[of n]"], ["proof (chain)\npicking this:\n  (real n + 1) * f n = f (n + 1) + (- 1) ^ n", "have \"(n + 1) * (f (n + 1) + f n) = ((n + 1) * f (n + 1)) + f (n + 1) + (- 1) ^ n\""], ["proof (prove)\nusing this:\n  (real n + 1) * f n = f (n + 1) + (- 1) ^ n\n\ngoal (1 subgoal):\n 1. real (n + 1) * (f (n + 1) + f n) =\n    real (n + 1) * f (n + 1) + f (n + 1) + (- 1) ^ n", "by (simp only: distrib_left of_nat_add of_nat_1)"], ["proof (state)\nthis:\n  real (n + 1) * (f (n + 1) + f n) =\n  real (n + 1) * f (n + 1) + f (n + 1) + (- 1) ^ n\n\ngoal (1 subgoal):\n 1. real (n + 1) *\n    (fact (n + 1) * (\\<Sum>k = 0..n + 1. (- 1) ^ k / fact k) +\n     fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k)) =\n    fact (n + 2) * (\\<Sum>k = 0..n + 2. (- 1) ^ k / fact k)", "also"], ["proof (state)\nthis:\n  real (n + 1) * (f (n + 1) + f n) =\n  real (n + 1) * f (n + 1) + f (n + 1) + (- 1) ^ n\n\ngoal (1 subgoal):\n 1. real (n + 1) *\n    (fact (n + 1) * (\\<Sum>k = 0..n + 1. (- 1) ^ k / fact k) +\n     fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k)) =\n    fact (n + 2) * (\\<Sum>k = 0..n + 2. (- 1) ^ k / fact k)", "have \"... = (n + 2) * f (n + 1) + (- 1) ^ (n + 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (n + 1) * f (n + 1) + f (n + 1) + (- 1) ^ n =\n    real (n + 2) * f (n + 1) + (- 1) ^ (n + 2)", "by (simp del: One_nat_def add_2_eq_Suc' add: algebra_simps) simp"], ["proof (state)\nthis:\n  real (n + 1) * f (n + 1) + f (n + 1) + (- 1) ^ n =\n  real (n + 2) * f (n + 1) + (- 1) ^ (n + 2)\n\ngoal (1 subgoal):\n 1. real (n + 1) *\n    (fact (n + 1) * (\\<Sum>k = 0..n + 1. (- 1) ^ k / fact k) +\n     fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k)) =\n    fact (n + 2) * (\\<Sum>k = 0..n + 2. (- 1) ^ k / fact k)", "also"], ["proof (state)\nthis:\n  real (n + 1) * f (n + 1) + f (n + 1) + (- 1) ^ n =\n  real (n + 2) * f (n + 1) + (- 1) ^ (n + 2)\n\ngoal (1 subgoal):\n 1. real (n + 1) *\n    (fact (n + 1) * (\\<Sum>k = 0..n + 1. (- 1) ^ k / fact k) +\n     fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k)) =\n    fact (n + 2) * (\\<Sum>k = 0..n + 2. (- 1) ^ k / fact k)", "from f_eq[of \"n + 1\"]"], ["proof (chain)\npicking this:\n  f (n + 1 + 1) = (real (n + 1) + 1) * f (n + 1) + (- 1) ^ (n + 1 + 1)", "have \"... = f (n + 2)\""], ["proof (prove)\nusing this:\n  f (n + 1 + 1) = (real (n + 1) + 1) * f (n + 1) + (- 1) ^ (n + 1 + 1)\n\ngoal (1 subgoal):\n 1. real (n + 2) * f (n + 1) + (- 1) ^ (n + 2) = f (n + 2)", "by simp"], ["proof (state)\nthis:\n  real (n + 2) * f (n + 1) + (- 1) ^ (n + 2) = f (n + 2)\n\ngoal (1 subgoal):\n 1. real (n + 1) *\n    (fact (n + 1) * (\\<Sum>k = 0..n + 1. (- 1) ^ k / fact k) +\n     fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k)) =\n    fact (n + 2) * (\\<Sum>k = 0..n + 2. (- 1) ^ k / fact k)", "finally"], ["proof (chain)\npicking this:\n  real (n + 1) * (f (n + 1) + f n) = f (n + 2)", "show ?thesis"], ["proof (prove)\nusing this:\n  real (n + 1) * (f (n + 1) + f n) = f (n + 2)\n\ngoal (1 subgoal):\n 1. real (n + 1) *\n    (fact (n + 1) * (\\<Sum>k = 0..n + 1. (- 1) ^ k / fact k) +\n     fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k)) =\n    fact (n + 2) * (\\<Sum>k = 0..n + 2. (- 1) ^ k / fact k)", "unfolding f_def"], ["proof (prove)\nusing this:\n  real (n + 1) *\n  (fact (n + 1) * (\\<Sum>k = 0..n + 1. (- 1) ^ k / fact k) +\n   fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k)) =\n  fact (n + 2) * (\\<Sum>k = 0..n + 2. (- 1) ^ k / fact k)\n\ngoal (1 subgoal):\n 1. real (n + 1) *\n    (fact (n + 1) * (\\<Sum>k = 0..n + 1. (- 1) ^ k / fact k) +\n     fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k)) =\n    fact (n + 2) * (\\<Sum>k = 0..n + 2. (- 1) ^ k / fact k)", "by simp"], ["proof (state)\nthis:\n  real (n + 1) *\n  (fact (n + 1) * (\\<Sum>k = 0..n + 1. (- 1) ^ k / fact k) +\n   fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k)) =\n  fact (n + 2) * (\\<Sum>k = 0..n + 2. (- 1) ^ k / fact k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real (n + 1) *\n  (fact (n + 1) * (\\<Sum>k = 0..n + 1. (- 1) ^ k / fact k) +\n   fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k)) =\n  fact (n + 2) * (\\<Sum>k = 0..n + 2. (- 1) ^ k / fact k)\n\ngoal (3 subgoals):\n 1. real (count_derangements 0) =\n    fact 0 * (\\<Sum>k = 0..0. (- 1) ^ k / fact k)\n 2. real (count_derangements (Suc 0)) =\n    fact (Suc 0) * (\\<Sum>k = 0..Suc 0. (- 1) ^ k / fact k)\n 3. \\<And>n.\n       \\<lbrakk>real (count_derangements (Suc n)) =\n                fact (Suc n) * (\\<Sum>k = 0..Suc n. (- 1) ^ k / fact k);\n        real (count_derangements n) =\n        fact n * (\\<Sum>k = 0..n. (- 1) ^ k / fact k)\\<rbrakk>\n       \\<Longrightarrow> real (count_derangements (Suc (Suc n))) =\n                         fact (Suc (Suc n)) *\n                         (\\<Sum>k = 0..Suc (Suc n). (- 1) ^ k / fact k)", "finally"], ["proof (chain)\npicking this:\n  real (count_derangements (Suc (Suc n))) =\n  fact (n + 2) * (\\<Sum>k = 0..n + 2. (- 1) ^ k / fact k)", "show ?case"], ["proof (prove)\nusing this:\n  real (count_derangements (Suc (Suc n))) =\n  fact (n + 2) * (\\<Sum>k = 0..n + 2. (- 1) ^ k / fact k)\n\ngoal (1 subgoal):\n 1. real (count_derangements (Suc (Suc n))) =\n    fact (Suc (Suc n)) * (\\<Sum>k = 0..Suc (Suc n). (- 1) ^ k / fact k)", "by simp"], ["proof (state)\nthis:\n  real (count_derangements (Suc (Suc n))) =\n  fact (Suc (Suc n)) * (\\<Sum>k = 0..Suc (Suc n). (- 1) ^ k / fact k)\n\ngoal (2 subgoals):\n 1. real (count_derangements 0) =\n    fact 0 * (\\<Sum>k = 0..0. (- 1) ^ k / fact k)\n 2. real (count_derangements (Suc 0)) =\n    fact (Suc 0) * (\\<Sum>k = 0..Suc 0. (- 1) ^ k / fact k)", "qed (auto)"], ["", "subsubsection \\<open>Approximation of Cardinality\\<close>"], ["", "lemma two_power_fact_le_fact:\n  assumes \"n \\<ge> 1\"\n  shows   \"2^k * fact n \\<le> (fact (n + k) :: 'a :: {semiring_char_0,linordered_semidom})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2::'a) ^ k * fact n \\<le> fact (n + k)", "proof (induction k)"], ["proof (state)\ngoal (2 subgoals):\n 1. (2::'a) ^ 0 * fact n \\<le> fact (n + 0)\n 2. \\<And>k.\n       (2::'a) ^ k * fact n \\<le> fact (n + k) \\<Longrightarrow>\n       (2::'a) ^ Suc k * fact n \\<le> fact (n + Suc k)", "case (Suc k)"], ["proof (state)\nthis:\n  (2::'a) ^ k * fact n \\<le> fact (n + k)\n\ngoal (2 subgoals):\n 1. (2::'a) ^ 0 * fact n \\<le> fact (n + 0)\n 2. \\<And>k.\n       (2::'a) ^ k * fact n \\<le> fact (n + k) \\<Longrightarrow>\n       (2::'a) ^ Suc k * fact n \\<le> fact (n + Suc k)", "have \"2 ^ Suc k * fact n = 2 * (2 ^ k * fact n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2::'b) ^ Suc k * fact n = (2::'b) * ((2::'b) ^ k * fact n)", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  (2::?'b1) ^ Suc k * fact n = (2::?'b1) * ((2::?'b1) ^ k * fact n)\n\ngoal (2 subgoals):\n 1. (2::'a) ^ 0 * fact n \\<le> fact (n + 0)\n 2. \\<And>k.\n       (2::'a) ^ k * fact n \\<le> fact (n + k) \\<Longrightarrow>\n       (2::'a) ^ Suc k * fact n \\<le> fact (n + Suc k)", "also"], ["proof (state)\nthis:\n  (2::?'b1) ^ Suc k * fact n = (2::?'b1) * ((2::?'b1) ^ k * fact n)\n\ngoal (2 subgoals):\n 1. (2::'a) ^ 0 * fact n \\<le> fact (n + 0)\n 2. \\<And>k.\n       (2::'a) ^ k * fact n \\<le> fact (n + k) \\<Longrightarrow>\n       (2::'a) ^ Suc k * fact n \\<le> fact (n + Suc k)", "note Suc.IH"], ["proof (state)\nthis:\n  (2::'a) ^ k * fact n \\<le> fact (n + k)\n\ngoal (2 subgoals):\n 1. (2::'a) ^ 0 * fact n \\<le> fact (n + 0)\n 2. \\<And>k.\n       (2::'a) ^ k * fact n \\<le> fact (n + k) \\<Longrightarrow>\n       (2::'a) ^ Suc k * fact n \\<le> fact (n + Suc k)", "also"], ["proof (state)\nthis:\n  (2::'a) ^ k * fact n \\<le> fact (n + k)\n\ngoal (2 subgoals):\n 1. (2::'a) ^ 0 * fact n \\<le> fact (n + 0)\n 2. \\<And>k.\n       (2::'a) ^ k * fact n \\<le> fact (n + k) \\<Longrightarrow>\n       (2::'a) ^ Suc k * fact n \\<le> fact (n + Suc k)", "from assms"], ["proof (chain)\npicking this:\n  1 \\<le> n", "have \"of_nat 1 + of_nat 1 \\<le> of_nat n + (of_nat (Suc k) :: 'a)\""], ["proof (prove)\nusing this:\n  1 \\<le> n\n\ngoal (1 subgoal):\n 1. of_nat 1 + of_nat 1 \\<le> of_nat n + of_nat (Suc k)", "by (intro add_mono) (unfold of_nat_le_iff, simp_all)"], ["proof (state)\nthis:\n  of_nat 1 + of_nat 1 \\<le> of_nat n + of_nat (Suc k)\n\ngoal (2 subgoals):\n 1. (2::'a) ^ 0 * fact n \\<le> fact (n + 0)\n 2. \\<And>k.\n       (2::'a) ^ k * fact n \\<le> fact (n + k) \\<Longrightarrow>\n       (2::'a) ^ Suc k * fact n \\<le> fact (n + Suc k)", "hence \"2 * (fact (n + k) :: 'a) \\<le> of_nat (n + Suc k) * fact (n + k)\""], ["proof (prove)\nusing this:\n  of_nat 1 + of_nat 1 \\<le> of_nat n + of_nat (Suc k)\n\ngoal (1 subgoal):\n 1. (2::'a) * fact (n + k) \\<le> of_nat (n + Suc k) * fact (n + k)", "by (intro mult_right_mono) (simp_all add: add_ac)"], ["proof (state)\nthis:\n  (2::'a) * fact (n + k) \\<le> of_nat (n + Suc k) * fact (n + k)\n\ngoal (2 subgoals):\n 1. (2::'a) ^ 0 * fact n \\<le> fact (n + 0)\n 2. \\<And>k.\n       (2::'a) ^ k * fact n \\<le> fact (n + k) \\<Longrightarrow>\n       (2::'a) ^ Suc k * fact n \\<le> fact (n + Suc k)", "also"], ["proof (state)\nthis:\n  (2::'a) * fact (n + k) \\<le> of_nat (n + Suc k) * fact (n + k)\n\ngoal (2 subgoals):\n 1. (2::'a) ^ 0 * fact n \\<le> fact (n + 0)\n 2. \\<And>k.\n       (2::'a) ^ k * fact n \\<le> fact (n + k) \\<Longrightarrow>\n       (2::'a) ^ Suc k * fact n \\<le> fact (n + Suc k)", "have \"\\<dots> = fact (n + Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (n + Suc k) * fact (n + k) = fact (n + Suc k)", "by simp"], ["proof (state)\nthis:\n  of_nat (n + Suc k) * fact (n + k) = fact (n + Suc k)\n\ngoal (2 subgoals):\n 1. (2::'a) ^ 0 * fact n \\<le> fact (n + 0)\n 2. \\<And>k.\n       (2::'a) ^ k * fact n \\<le> fact (n + k) \\<Longrightarrow>\n       (2::'a) ^ Suc k * fact n \\<le> fact (n + Suc k)", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      (2::'a) * x \\<le> (2::'a) * y) \\<Longrightarrow>\n  (2::'a) ^ Suc k * fact n \\<le> fact (n + Suc k)", "show ?case"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      (2::'a) * x \\<le> (2::'a) * y) \\<Longrightarrow>\n  (2::'a) ^ Suc k * fact n \\<le> fact (n + Suc k)\n\ngoal (1 subgoal):\n 1. (2::'a) ^ Suc k * fact n \\<le> fact (n + Suc k)", "by - (simp add: mult_left_mono)"], ["proof (state)\nthis:\n  (2::'a) ^ Suc k * fact n \\<le> fact (n + Suc k)\n\ngoal (1 subgoal):\n 1. (2::'a) ^ 0 * fact n \\<le> fact (n + 0)", "qed simp_all"], ["", "lemma exp1_approx:\n  assumes \"n > 0\"\n  shows   \"exp (1::real) - (\\<Sum>k<n. 1 / fact k) \\<in> {0..2 / fact n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp 1 - (\\<Sum>k<n. 1 / fact k) \\<in> {0..2 / fact n}", "proof (unfold atLeastAtMost_iff, safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> exp 1 - (\\<Sum>k<n. 1 / fact k)\n 2. exp 1 - (\\<Sum>k<n. 1 / fact k) \\<le> 2 / fact n", "have \"(\\<lambda>k. 1^k / fact k) sums exp (1::real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 ^ k / fact k) sums exp 1", "using exp_converges[of \"1::real\"]"], ["proof (prove)\nusing this:\n  (\\<lambda>n. 1 ^ n /\\<^sub>R fact n) sums exp 1\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 ^ k / fact k) sums exp 1", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  (\\<lambda>k. 1 ^ k / fact k) sums exp 1\n\ngoal (2 subgoals):\n 1. 0 \\<le> exp 1 - (\\<Sum>k<n. 1 / fact k)\n 2. exp 1 - (\\<Sum>k<n. 1 / fact k) \\<le> 2 / fact n", "from sums_split_initial_segment[OF this, of n]"], ["proof (chain)\npicking this:\n  (\\<lambda>i. 1 ^ (i + n) / fact (i + n)) sums\n  (exp 1 - (\\<Sum>i<n. 1 ^ i / fact i))", "have sums: \"(\\<lambda>k. 1 / fact (n+k)) sums (exp 1 - (\\<Sum>k<n. 1 / fact k :: real))\""], ["proof (prove)\nusing this:\n  (\\<lambda>i. 1 ^ (i + n) / fact (i + n)) sums\n  (exp 1 - (\\<Sum>i<n. 1 ^ i / fact i))\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / fact (n + k)) sums (exp 1 - (\\<Sum>k<n. 1 / fact k))", "by (simp add:  algebra_simps power_add)"], ["proof (state)\nthis:\n  (\\<lambda>k. 1 / fact (n + k)) sums (exp 1 - (\\<Sum>k<n. 1 / fact k))\n\ngoal (2 subgoals):\n 1. 0 \\<le> exp 1 - (\\<Sum>k<n. 1 / fact k)\n 2. exp 1 - (\\<Sum>k<n. 1 / fact k) \\<le> 2 / fact n", "from assms"], ["proof (chain)\npicking this:\n  0 < n", "show \"(exp 1 - (\\<Sum>k<n. 1 / fact k :: real)) \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. 0 \\<le> exp 1 - (\\<Sum>k<n. 1 / fact k)", "by (intro sums_le[OF _ sums_zero sums]) auto"], ["proof (state)\nthis:\n  0 \\<le> exp 1 - (\\<Sum>k<n. 1 / fact k)\n\ngoal (1 subgoal):\n 1. exp 1 - (\\<Sum>k<n. 1 / fact k) \\<le> 2 / fact n", "show \"(exp 1 - (\\<Sum>k<n. 1 / fact k :: real)) \\<le> 2 / fact n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp 1 - (\\<Sum>k<n. 1 / fact k) \\<le> 2 / fact n", "proof (rule sums_le)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n. ?f n \\<le> ?g n\n 2. ?f sums (exp 1 - (\\<Sum>k<n. 1 / fact k))\n 3. ?g sums (2 / fact n)", "from assms"], ["proof (chain)\npicking this:\n  0 < n", "have \"(\\<lambda>k. (1 / fact n) * (1 / 2)^k :: real) sums ((1 / fact n) * (1 / (1 - 1 / 2)))\""], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / fact n * (1 / 2) ^ k) sums\n    (1 / fact n * (1 / (1 - 1 / 2)))", "by (intro sums_mult geometric_sums) simp_all"], ["proof (state)\nthis:\n  (\\<lambda>k. 1 / fact n * (1 / 2) ^ k) sums\n  (1 / fact n * (1 / (1 - 1 / 2)))\n\ngoal (3 subgoals):\n 1. \\<And>n. ?f n \\<le> ?g n\n 2. ?f sums (exp 1 - (\\<Sum>k<n. 1 / fact k))\n 3. ?g sums (2 / fact n)", "also"], ["proof (state)\nthis:\n  (\\<lambda>k. 1 / fact n * (1 / 2) ^ k) sums\n  (1 / fact n * (1 / (1 - 1 / 2)))\n\ngoal (3 subgoals):\n 1. \\<And>n. ?f n \\<le> ?g n\n 2. ?f sums (exp 1 - (\\<Sum>k<n. 1 / fact k))\n 3. ?g sums (2 / fact n)", "have \"\\<dots> = 2 / fact n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / fact n * (1 / (1 - 1 / 2)) = 2 / fact n", "by simp"], ["proof (state)\nthis:\n  1 / fact n * (1 / (1 - 1 / 2)) = 2 / fact n\n\ngoal (3 subgoals):\n 1. \\<And>n. ?f n \\<le> ?g n\n 2. ?f sums (exp 1 - (\\<Sum>k<n. 1 / fact k))\n 3. ?g sums (2 / fact n)", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>k. 1 / fact n * (1 / 2) ^ k) sums (2 / fact n)", "show \"(\\<lambda>k. 1 / fact n * (1 / 2) ^ k) sums (2 / fact n :: real)\""], ["proof (prove)\nusing this:\n  (\\<lambda>k. 1 / fact n * (1 / 2) ^ k) sums (2 / fact n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / fact n * (1 / 2) ^ k) sums (2 / fact n)", "."], ["proof (state)\nthis:\n  (\\<lambda>k. 1 / fact n * (1 / 2) ^ k) sums (2 / fact n)\n\ngoal (2 subgoals):\n 1. \\<And>na. ?f na \\<le> 1 / fact n * (1 / 2) ^ na\n 2. ?f sums (exp 1 - (\\<Sum>k<n. 1 / fact k))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>na. ?f na \\<le> 1 / fact n * (1 / 2) ^ na\n 2. ?f sums (exp 1 - (\\<Sum>k<n. 1 / fact k))", "fix k"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>na. ?f na \\<le> 1 / fact n * (1 / 2) ^ na\n 2. ?f sums (exp 1 - (\\<Sum>k<n. 1 / fact k))", "show \"(1 / fact (n+k)) \\<le> (1 / fact n) * (1 / 2 :: real)^k\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / fact (n + k) \\<le> 1 / fact n * (1 / 2) ^ k", "using two_power_fact_le_fact[of n k] assms"], ["proof (prove)\nusing this:\n  1 \\<le> n \\<Longrightarrow> (2::?'a) ^ k * fact n \\<le> fact (n + k)\n  0 < n\n\ngoal (1 subgoal):\n 1. 1 / fact (n + k) \\<le> 1 / fact n * (1 / 2) ^ k", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  1 / fact (n + ?k) \\<le> 1 / fact n * (1 / 2) ^ ?k\n\ngoal (1 subgoal):\n 1. (\\<lambda>na. 1 / fact (n + na)) sums (exp 1 - (\\<Sum>k<n. 1 / fact k))", "qed fact+"], ["proof (state)\nthis:\n  exp 1 - (\\<Sum>k<n. 1 / fact k) \\<le> 2 / fact n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exp1_bounds: \"exp 1 \\<in> {8 / 3..11 / 4 :: real}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp 1 \\<in> {8 / 3..11 / 4}", "using exp1_approx[of 4]"], ["proof (prove)\nusing this:\n  0 < 4 \\<Longrightarrow>\n  exp 1 - (\\<Sum>k<4. 1 / fact k) \\<in> {0..2 / fact 4}\n\ngoal (1 subgoal):\n 1. exp 1 \\<in> {8 / 3..11 / 4}", "by (simp add: eval_nat_numeral)"], ["", "lemma count_derangements_approximation:\n  assumes \"n \\<noteq> 0\"\n  shows \"abs(real (count_derangements n) - fact n / exp 1) < 1 / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>real (count_derangements n) - fact n / exp 1\\<bar> < 1 / 2", "proof (cases \"n \\<ge> 5\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 5 \\<le> n \\<Longrightarrow>\n    \\<bar>real (count_derangements n) - fact n / exp 1\\<bar> < 1 / 2\n 2. \\<not> 5 \\<le> n \\<Longrightarrow>\n    \\<bar>real (count_derangements n) - fact n / exp 1\\<bar> < 1 / 2", "case False"], ["proof (state)\nthis:\n  \\<not> 5 \\<le> n\n\ngoal (2 subgoals):\n 1. 5 \\<le> n \\<Longrightarrow>\n    \\<bar>real (count_derangements n) - fact n / exp 1\\<bar> < 1 / 2\n 2. \\<not> 5 \\<le> n \\<Longrightarrow>\n    \\<bar>real (count_derangements n) - fact n / exp 1\\<bar> < 1 / 2", "from assms this"], ["proof (chain)\npicking this:\n  n \\<noteq> 0\n  \\<not> 5 \\<le> n", "have n: \"n = 1 \\<or> n = 2 \\<or> n = 3 \\<or> n = 4\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n  \\<not> 5 \\<le> n\n\ngoal (1 subgoal):\n 1. n = 1 \\<or> n = 2 \\<or> n = 3 \\<or> n = 4", "by auto"], ["proof (state)\nthis:\n  n = 1 \\<or> n = 2 \\<or> n = 3 \\<or> n = 4\n\ngoal (2 subgoals):\n 1. 5 \\<le> n \\<Longrightarrow>\n    \\<bar>real (count_derangements n) - fact n / exp 1\\<bar> < 1 / 2\n 2. \\<not> 5 \\<le> n \\<Longrightarrow>\n    \\<bar>real (count_derangements n) - fact n / exp 1\\<bar> < 1 / 2", "from exp1_bounds"], ["proof (chain)\npicking this:\n  exp 1 \\<in> {8 / 3..11 / 4}", "have 1: \"abs(real (count_derangements 1) - fact 1 / exp 1) < 1 / 2\""], ["proof (prove)\nusing this:\n  exp 1 \\<in> {8 / 3..11 / 4}\n\ngoal (1 subgoal):\n 1. \\<bar>real (count_derangements 1) - fact 1 / exp 1\\<bar> < 1 / 2", "by simp"], ["proof (state)\nthis:\n  \\<bar>real (count_derangements 1) - fact 1 / exp 1\\<bar> < 1 / 2\n\ngoal (2 subgoals):\n 1. 5 \\<le> n \\<Longrightarrow>\n    \\<bar>real (count_derangements n) - fact n / exp 1\\<bar> < 1 / 2\n 2. \\<not> 5 \\<le> n \\<Longrightarrow>\n    \\<bar>real (count_derangements n) - fact n / exp 1\\<bar> < 1 / 2", "from exp1_bounds"], ["proof (chain)\npicking this:\n  exp 1 \\<in> {8 / 3..11 / 4}", "have 2: \"abs(real (count_derangements 2) - fact 2 / exp 1) < 1 / 2\""], ["proof (prove)\nusing this:\n  exp 1 \\<in> {8 / 3..11 / 4}\n\ngoal (1 subgoal):\n 1. \\<bar>real (count_derangements 2) - fact 2 / exp 1\\<bar> < 1 / 2", "by (auto simp add: eval_nat_numeral abs_real_def)"], ["proof (state)\nthis:\n  \\<bar>real (count_derangements 2) - fact 2 / exp 1\\<bar> < 1 / 2\n\ngoal (2 subgoals):\n 1. 5 \\<le> n \\<Longrightarrow>\n    \\<bar>real (count_derangements n) - fact n / exp 1\\<bar> < 1 / 2\n 2. \\<not> 5 \\<le> n \\<Longrightarrow>\n    \\<bar>real (count_derangements n) - fact n / exp 1\\<bar> < 1 / 2", "from exp1_bounds"], ["proof (chain)\npicking this:\n  exp 1 \\<in> {8 / 3..11 / 4}", "have 3: \"abs(real (count_derangements 3) - fact 3 / exp 1) < 1 / 2\""], ["proof (prove)\nusing this:\n  exp 1 \\<in> {8 / 3..11 / 4}\n\ngoal (1 subgoal):\n 1. \\<bar>real (count_derangements 3) - fact 3 / exp 1\\<bar> < 1 / 2", "by (auto simp add: eval_nat_numeral abs_if field_simps)"], ["proof (state)\nthis:\n  \\<bar>real (count_derangements 3) - fact 3 / exp 1\\<bar> < 1 / 2\n\ngoal (2 subgoals):\n 1. 5 \\<le> n \\<Longrightarrow>\n    \\<bar>real (count_derangements n) - fact n / exp 1\\<bar> < 1 / 2\n 2. \\<not> 5 \\<le> n \\<Longrightarrow>\n    \\<bar>real (count_derangements n) - fact n / exp 1\\<bar> < 1 / 2", "from exp1_bounds"], ["proof (chain)\npicking this:\n  exp 1 \\<in> {8 / 3..11 / 4}", "have 4: \"abs(real (count_derangements 4) - fact 4 / exp 1) < 1 / 2\""], ["proof (prove)\nusing this:\n  exp 1 \\<in> {8 / 3..11 / 4}\n\ngoal (1 subgoal):\n 1. \\<bar>real (count_derangements 4) - fact 4 / exp 1\\<bar> < 1 / 2", "by (auto simp: abs_if field_simps eval_nat_numeral)"], ["proof (state)\nthis:\n  \\<bar>real (count_derangements 4) - fact 4 / exp 1\\<bar> < 1 / 2\n\ngoal (2 subgoals):\n 1. 5 \\<le> n \\<Longrightarrow>\n    \\<bar>real (count_derangements n) - fact n / exp 1\\<bar> < 1 / 2\n 2. \\<not> 5 \\<le> n \\<Longrightarrow>\n    \\<bar>real (count_derangements n) - fact n / exp 1\\<bar> < 1 / 2", "from 1 2 3 4 n"], ["proof (chain)\npicking this:\n  \\<bar>real (count_derangements 1) - fact 1 / exp 1\\<bar> < 1 / 2\n  \\<bar>real (count_derangements 2) - fact 2 / exp 1\\<bar> < 1 / 2\n  \\<bar>real (count_derangements 3) - fact 3 / exp 1\\<bar> < 1 / 2\n  \\<bar>real (count_derangements 4) - fact 4 / exp 1\\<bar> < 1 / 2\n  n = 1 \\<or> n = 2 \\<or> n = 3 \\<or> n = 4", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>real (count_derangements 1) - fact 1 / exp 1\\<bar> < 1 / 2\n  \\<bar>real (count_derangements 2) - fact 2 / exp 1\\<bar> < 1 / 2\n  \\<bar>real (count_derangements 3) - fact 3 / exp 1\\<bar> < 1 / 2\n  \\<bar>real (count_derangements 4) - fact 4 / exp 1\\<bar> < 1 / 2\n  n = 1 \\<or> n = 2 \\<or> n = 3 \\<or> n = 4\n\ngoal (1 subgoal):\n 1. \\<bar>real (count_derangements n) - fact n / exp 1\\<bar> < 1 / 2", "by auto"], ["proof (state)\nthis:\n  \\<bar>real (count_derangements n) - fact n / exp 1\\<bar> < 1 / 2\n\ngoal (1 subgoal):\n 1. 5 \\<le> n \\<Longrightarrow>\n    \\<bar>real (count_derangements n) - fact n / exp 1\\<bar> < 1 / 2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 5 \\<le> n \\<Longrightarrow>\n    \\<bar>real (count_derangements n) - fact n / exp 1\\<bar> < 1 / 2", "case True"], ["proof (state)\nthis:\n  5 \\<le> n\n\ngoal (1 subgoal):\n 1. 5 \\<le> n \\<Longrightarrow>\n    \\<bar>real (count_derangements n) - fact n / exp 1\\<bar> < 1 / 2", "from Maclaurin_exp_le[of \"- 1\" \"n + 1\"]"], ["proof (chain)\npicking this:\n  \\<exists>t.\n     \\<bar>t\\<bar> \\<le> \\<bar>- 1\\<bar> \\<and>\n     exp (- 1) =\n     (\\<Sum>m<n + 1. (- 1) ^ m / fact m) +\n     exp t / fact (n + 1) * (- 1) ^ (n + 1)", "obtain t where t: \"abs (t :: real) \\<le> abs (- 1)\"\n    and exp: \"exp (- 1) = (\\<Sum>m<n + 1. (- 1) ^ m / fact m) + exp t / fact (n + 1) * (- 1) ^ (n + 1)\""], ["proof (prove)\nusing this:\n  \\<exists>t.\n     \\<bar>t\\<bar> \\<le> \\<bar>- 1\\<bar> \\<and>\n     exp (- 1) =\n     (\\<Sum>m<n + 1. (- 1) ^ m / fact m) +\n     exp t / fact (n + 1) * (- 1) ^ (n + 1)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>\\<bar>t\\<bar> \\<le> \\<bar>- 1\\<bar>;\n         exp (- 1) =\n         (\\<Sum>m<n + 1. (- 1) ^ m / fact m) +\n         exp t / fact (n + 1) * (- 1) ^ (n + 1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<bar>t\\<bar> \\<le> \\<bar>- 1\\<bar>\n  exp (- 1) =\n  (\\<Sum>m<n + 1. (- 1) ^ m / fact m) +\n  exp t / fact (n + 1) * (- 1) ^ (n + 1)\n\ngoal (1 subgoal):\n 1. 5 \\<le> n \\<Longrightarrow>\n    \\<bar>real (count_derangements n) - fact n / exp 1\\<bar> < 1 / 2", "from exp"], ["proof (chain)\npicking this:\n  exp (- 1) =\n  (\\<Sum>m<n + 1. (- 1) ^ m / fact m) +\n  exp t / fact (n + 1) * (- 1) ^ (n + 1)", "have sum_eq_exp: \n    \"(\\<Sum>k = 0..n. (- 1) ^ k / fact k) = exp (- 1) - exp t / fact (n + 1) * (- 1) ^ (n + 1)\""], ["proof (prove)\nusing this:\n  exp (- 1) =\n  (\\<Sum>m<n + 1. (- 1) ^ m / fact m) +\n  exp t / fact (n + 1) * (- 1) ^ (n + 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..n. (- 1) ^ k / fact k) =\n    exp (- 1) - exp t / fact (n + 1) * (- 1) ^ (n + 1)", "by (simp add: atLeast0AtMost ivl_disj_un(2)[symmetric])"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..n. (- 1) ^ k / fact k) =\n  exp (- 1) - exp t / fact (n + 1) * (- 1) ^ (n + 1)\n\ngoal (1 subgoal):\n 1. 5 \\<le> n \\<Longrightarrow>\n    \\<bar>real (count_derangements n) - fact n / exp 1\\<bar> < 1 / 2", "have fact_plus1: \"fact (n + 1) = (n + 1) * fact n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fact (n + 1) = (n + 1) * fact n", "by simp"], ["proof (state)\nthis:\n  fact (n + 1) = (n + 1) * fact n\n\ngoal (1 subgoal):\n 1. 5 \\<le> n \\<Longrightarrow>\n    \\<bar>real (count_derangements n) - fact n / exp 1\\<bar> < 1 / 2", "have eq: \"\\<bar>real (count_derangements n) - fact n / exp 1\\<bar> = exp t / (n + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>real (count_derangements n) - fact n / exp 1\\<bar> =\n    exp t / real (n + 1)", "by (simp del: One_nat_def \n             add: count_derangements sum_eq_exp exp_minus inverse_eq_divide algebra_simps abs_mult)\n       (simp add: fact_plus1)"], ["proof (state)\nthis:\n  \\<bar>real (count_derangements n) - fact n / exp 1\\<bar> =\n  exp t / real (n + 1)\n\ngoal (1 subgoal):\n 1. 5 \\<le> n \\<Longrightarrow>\n    \\<bar>real (count_derangements n) - fact n / exp 1\\<bar> < 1 / 2", "from t"], ["proof (chain)\npicking this:\n  \\<bar>t\\<bar> \\<le> \\<bar>- 1\\<bar>", "have \"exp t \\<le> exp 1\""], ["proof (prove)\nusing this:\n  \\<bar>t\\<bar> \\<le> \\<bar>- 1\\<bar>\n\ngoal (1 subgoal):\n 1. exp t \\<le> exp 1", "by simp"], ["proof (state)\nthis:\n  exp t \\<le> exp 1\n\ngoal (1 subgoal):\n 1. 5 \\<le> n \\<Longrightarrow>\n    \\<bar>real (count_derangements n) - fact n / exp 1\\<bar> < 1 / 2", "also"], ["proof (state)\nthis:\n  exp t \\<le> exp 1\n\ngoal (1 subgoal):\n 1. 5 \\<le> n \\<Longrightarrow>\n    \\<bar>real (count_derangements n) - fact n / exp 1\\<bar> < 1 / 2", "from exp1_bounds"], ["proof (chain)\npicking this:\n  exp 1 \\<in> {8 / 3..11 / 4}", "have \"\\<dots> < 3\""], ["proof (prove)\nusing this:\n  exp 1 \\<in> {8 / 3..11 / 4}\n\ngoal (1 subgoal):\n 1. exp 1 < 3", "by simp"], ["proof (state)\nthis:\n  exp 1 < 3\n\ngoal (1 subgoal):\n 1. 5 \\<le> n \\<Longrightarrow>\n    \\<bar>real (count_derangements n) - fact n / exp 1\\<bar> < 1 / 2", "finally"], ["proof (chain)\npicking this:\n  exp t < 3", "show ?thesis"], ["proof (prove)\nusing this:\n  exp t < 3\n\ngoal (1 subgoal):\n 1. \\<bar>real (count_derangements n) - fact n / exp 1\\<bar> < 1 / 2", "using \\<open>n \\<ge> 5\\<close>"], ["proof (prove)\nusing this:\n  exp t < 3\n  5 \\<le> n\n\ngoal (1 subgoal):\n 1. \\<bar>real (count_derangements n) - fact n / exp 1\\<bar> < 1 / 2", "by (simp add: eq)"], ["proof (state)\nthis:\n  \\<bar>real (count_derangements n) - fact n / exp 1\\<bar> < 1 / 2\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem derangements_formula:\n  assumes \"n \\<noteq> 0\" \"finite S\" \"card S = n\"\n  shows \"int (card (derangements S)) = round (fact n / exp 1 :: real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card (derangements S)) = round (fact n / exp 1)", "using count_derangements_approximation[of n] assms"], ["proof (prove)\nusing this:\n  n \\<noteq> 0 \\<Longrightarrow>\n  \\<bar>real (count_derangements n) - fact n / exp 1\\<bar> < 1 / 2\n  n \\<noteq> 0\n  finite S\n  card S = n\n\ngoal (1 subgoal):\n 1. int (card (derangements S)) = round (fact n / exp 1)", "by (intro round_unique' [symmetric]) (auto simp: card_derangements abs_minus_commute)"], ["", "theorem derangements_formula':\n  assumes \"n \\<noteq> 0\" \"finite S\" \"card S = n\"\n  shows \"card (derangements S) = nat (round (fact n / exp 1 :: real))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (derangements S) = nat (round (fact n / exp 1))", "using derangements_formula[OF assms]"], ["proof (prove)\nusing this:\n  int (card (derangements S)) = round (fact n / exp 1)\n\ngoal (1 subgoal):\n 1. card (derangements S) = nat (round (fact n / exp 1))", "by simp"], ["", "end"]]}