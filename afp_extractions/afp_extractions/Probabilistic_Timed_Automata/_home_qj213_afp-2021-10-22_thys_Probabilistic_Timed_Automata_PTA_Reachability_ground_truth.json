{"file_name": "/home/qj213/afp-2021-10-22/thys/Probabilistic_Timed_Automata/PTA_Reachability.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Probabilistic_Timed_Automata", "problem_names": ["lemma pairwise_Suc:\n  \"pairwise P xs \\<Longrightarrow> P (xs !! i) (xs !! (Suc i))\"", "lemma Suc_pairwise:\n  \"\\<forall> i. P (xs !! i) (xs !! (Suc i)) \\<Longrightarrow> pairwise P xs\"", "lemma pairwise_iff:\n  \"pairwise P xs \\<longleftrightarrow> (\\<forall> i. P (xs !! i) (xs !! (Suc i)))\"", "lemma pairwise_stlD:\n  \"pairwise P xs \\<Longrightarrow> pairwise P (stl xs)\"", "lemma pairwise_pairD:\n  \"pairwise P xs \\<Longrightarrow> P (shd xs) (shd (stl xs))\"", "lemma pairwise_mp:\n  assumes \"pairwise P xs\" and lift: \"\\<And> x y. x \\<in> sset xs \\<Longrightarrow> y \\<in> sset xs \\<Longrightarrow> P x y \\<Longrightarrow> Q x y\"\n  shows \"pairwise Q xs\"", "lemma pairwise_sdropD:\n  \"pairwise P (sdrop i xs)\" if \"pairwise P xs\"", "lemma gt_GreaterD:\n  assumes \"u \\<in> region X I r\" \"valid_region X k I r\" \"c \\<in> X\" \"u c > k c\"\n  shows \"I c = Greater (k c)\"", "lemma const_ConstD:\n  assumes \"u \\<in> region X I r\" \"valid_region X k I r\" \"c \\<in> X\" \"u c = d\" \"d \\<le> k c\"\n  shows \"I c = Const d\"", "lemma not_Greater_bounded:\n  assumes \"I x \\<noteq> Greater (k x)\" \"x \\<in> X\" \"valid_region X k I r\" \"u \\<in> region X I r\"\n  shows \"u x \\<le> k x\"", "lemma Greater_closed:\n  fixes t :: \"real\"\n  assumes \"u \\<in> region X I r\" \"valid_region X k I r\" \"c \\<in> X\" \"I c = Greater (k c)\" \"t > k c\"\n  shows \"u(c := t) \\<in> region X I r\"", "lemma Greater_unbounded_aux:\n  assumes \"finite X\" \"valid_region X k I r\" \"c \\<in> X\" \"I c = Greater (k c)\"\n  shows \"\\<exists> u \\<in> region X I r. u c > t\"", "lemma Greater_unbounded:\n  assumes \"finite X\" \"valid_region X k I r\" \"c \\<in> X\" \"I c = Greater (k c)\"\n  shows \"unbounded c (region X I r)\"", "lemma unbounded_Greater:\n  assumes \"valid_region X k I r\" \"c \\<in> X\" \"unbounded c (region X I r)\"\n  shows \"I c = Greater (k c)\"", "lemma Const_zero:\n  assumes \"c \\<in> X\" \"I c = Const 0\"\n  shows \"zero c (region X I r)\"", "lemma zero_Const:\n  assumes \"finite X\" \"valid_region X k I r\" \"c \\<in> X\" \"zero c (region X I r)\"\n  shows \"I c = Const 0\"", "lemma zero_all:\n  assumes \"finite X\" \"valid_region X k I r\" \"c \\<in> X\" \"u \\<in> region X I r\" \"u c = 0\"\n  shows \"zero c (region X I r)\"", "lemma s_s'_cfg_on[intro]:\n  assumes \"cfg \\<in> MDP.cfg_on s\"\n  shows \"absc cfg \\<in> R_G.cfg_on s'\"", "lemma s'_\\<S>[simp, intro]:\n  \"s' \\<in> \\<S>\"", "lemma s'_s_cfg_on[intro]:\n  assumes \"cfg \\<in> R_G.cfg_on s'\"\n  shows \"repcs s cfg \\<in> MDP.cfg_on s\"", "lemma (in Probabilistic_Timed_Automaton_Regions) compatible_stream:\n  assumes \\<phi>: \"\\<And> x y. x \\<in> S \\<Longrightarrow> x ~ y \\<Longrightarrow> \\<phi> x \\<longleftrightarrow> \\<phi> y\"\n  assumes \"pred_stream (\\<lambda>s. s \\<in> S) xs\"\n      and [intro]: \"x \\<in> S\"\n    shows \"pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s) (x ## xs)\"", "lemma \\<phi>_stream':\n  \"pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s) (x ## xs)\" if \"pred_stream (\\<lambda>s. s \\<in> S) xs\" \"x \\<in> S\"", "lemma \\<psi>_stream':\n  \"pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s) (x ## xs)\" if \"pred_stream (\\<lambda>s. s \\<in> S) xs\" \"x \\<in> S\"", "lemmas \\<phi>_stream = compatible_stream[of \\<phi>, OF \\<phi>]", "lemmas \\<psi>_stream = compatible_stream[of \\<psi>, OF \\<psi>]", "lemma suntil_reps:\n  assumes\n    \"\\<forall>s\\<in>sset (smap abss y). s \\<in> \\<S>\"\n    \"(holds \\<phi>' suntil holds \\<psi>') (s' ## smap abss y)\"\n  shows \"(holds \\<phi> suntil holds \\<psi>) (s ## y)\"", "lemma suntil_abss:\n  assumes\n    \"\\<forall>s\\<in>sset y. s \\<in> S\"\n    \"(holds \\<phi> suntil holds \\<psi>) (s ## y)\"\n  shows\n    \"(holds \\<phi>' suntil holds \\<psi>') (s' ## smap abss y)\"", "theorem P_sup_sunitl_eq:\n  notes [measurable] = in_space_UNIV and [iff] = pred_stream_iff\n  shows\n    \"(MDP.P_sup s  (\\<lambda>x. (holds \\<phi> suntil holds \\<psi>)   (s  ## x)))\n   = (R_G.P_sup s' (\\<lambda>x. (holds \\<phi>' suntil holds \\<psi>') (s' ## x)))\"", "lemma measurable_\\<R>_div[measurable]: \"Measurable.pred MDP.MC.S \\<R>_div\"", "lemma elapsed_ge0[simp]: \"elapsed x y \\<ge> 0\"", "lemma dur_pos:\n  \"dur xs i \\<ge> 0\"", "lemma dur_mono:\n  \"i \\<le> j \\<Longrightarrow> dur xs i \\<le> dur xs j\"", "lemma dur_monoD:\n  assumes \"dur xs i < dur xs j\"\n  shows \"i < j\"", "lemma elapsed_0D:\n  assumes \"c \\<in> \\<X>\" \"elapsed u u' \\<le> 0\"\n  shows \"u' c - u c \\<le> 0\"", "lemma elapsed_ge:\n  assumes \"eq_elapsed u u'\" \"c \\<in> \\<X>\"\n  shows \"elapsed u u' \\<ge> u' c - u c\"", "lemma elapsed_eq:\n  assumes \"eq_elapsed u u'\" \"c \\<in> \\<X>\" \"u' c - u c \\<ge> 0\"\n  shows \"elapsed u u' = u' c - u c\"", "lemma dur_shift:\n  \"dur \\<omega> (i + j) = dur \\<omega> i + dur (sdrop i \\<omega>) j\"", "lemma dur_zero:\n  assumes\n    \"\\<forall> i. xs !! i \\<in> \\<omega> !! i\" \"\\<forall> j \\<le> i. zero x (\\<omega> !! j)\" \"x \\<in> \\<X>\"\n    \"\\<forall> i. eq_elapsed (xs !! i) (xs !! Suc i)\"\n  shows \"dur xs i = 0\"", "lemma dur_zero_tail:\n  assumes \"\\<forall> i. xs !! i \\<in> \\<omega> !! i\" \"\\<forall> k \\<ge> i. k \\<le> j \\<longrightarrow> zero x (\\<omega> !! k)\" \"x \\<in> \\<X>\" \"j \\<ge> i\"\n          \"\\<forall> i. eq_elapsed (xs !! i) (xs !! Suc i)\"\n  shows \"dur xs j = dur xs i\"", "lemma elapsed_ge_pos:\n  fixes u :: \"('c, t) cval\"\n  assumes \"eq_elapsed u u'\" \"c \\<in> \\<X>\" \"u \\<in> V\" \"u' \\<in> V\"\n  shows \"elapsed u u' \\<le> u' c\"", "lemma dur_Suc:\n  \"dur xs (Suc i) - dur xs i = elapsed (xs !! i) (xs !! Suc i)\"", "lemma K_cfg_trans:\n  assumes \"cfg \\<in> MDP.cfg_on (l, R)\" \"cfg' \\<in> K_cfg cfg\" \"state cfg' = (l', R')\"\n  shows \"trans R R'\"", "lemma enabled_stream_trans:\n  assumes \"cfg \\<in> valid_cfg\" \"MDP.MC.enabled cfg xs\"\n  shows \"stream_trans (smap (snd o state) xs)\"", "lemma stream_trans_trans:\n  assumes \"stream_trans xs\"\n  shows \"trans (xs !! i) (stl xs !! i)\"", "lemma trans_eq_elapsed:\n  assumes \"trans u u'\" \"u \\<in> V\"\n  shows \"eq_elapsed u u'\"", "lemma pairwise_trans_eq_elapsed:\n  assumes \"stream_trans xs\" \"pred_stream (\\<lambda> u. u \\<in> V) xs\"\n  shows \"pairwise eq_elapsed xs\"", "lemma not_reset_dur:\n  assumes \"\\<forall>k>i. k \\<le> j \\<longrightarrow> \\<not> zero c ([xs !! k]\\<^sub>\\<R>)\" \"j \\<ge> i\" \"c \\<in> \\<X>\" \"stream_trans xs\"\n    \"\\<forall> i. eq_elapsed (xs !! i) (xs !! Suc i)\" \"\\<forall> i. xs !! i \\<in> V\"\n  shows \"dur xs j - dur xs i = (xs !! j) c - (xs !! i) c\"", "lemma not_reset_dur':\n  assumes \"\\<forall>j\\<ge>i. \\<not> zero c ([xs !! j]\\<^sub>\\<R>)\" \"j \\<ge> i\" \"c \\<in> \\<X>\" \"stream_trans xs\"\n          \"\\<forall> i. eq_elapsed (xs !! i) (xs !! Suc i)\" \"\\<forall> j. xs !! j \\<in> V\"\n  shows \"dur xs j - dur xs i = (xs !! j) c - (xs !! i) c\"", "lemma not_reset_unbounded:\n  assumes \"\\<forall>j\\<ge>i. \\<not> zero c ([xs !! j]\\<^sub>\\<R>)\" \"j \\<ge> i\" \"c \\<in> \\<X>\" \"stream_trans xs\"\n          \"\\<forall> i. eq_elapsed (xs !! i) (xs !! Suc i)\" \"\\<forall> j. xs !! j \\<in> V\"\n          \"unbounded c ([xs !! i]\\<^sub>\\<R>)\"\n  shows \"unbounded c ([xs !! j]\\<^sub>\\<R>)\"", "lemma gt_unboundedD:\n  assumes \"u \\<in> R\"\n    and \"R \\<in> \\<R>\"\n    and \"c \\<in> \\<X>\"\n    and \"real (k c) < u c\"\n  shows \"unbounded c R\"", "lemma zeroI:\n  assumes \"c \\<in> \\<X>\" \"u \\<in> V\" \"u c = 0\"\n  shows \"zero c ([u]\\<^sub>\\<R>)\"", "lemma zeroD:\n  \"u x = 0\" if \"zero x ([u]\\<^sub>\\<R>)\" \"u \\<in> V\"", "lemma not_zeroD:\n  assumes \"\\<not> zero x ([u]\\<^sub>\\<R>)\" \"u \\<in> V\" \"x \\<in> \\<X>\"\n  shows \"u x > 0\"", "lemma not_const_intv:\n  assumes \"u \\<in> V\" \"\\<forall>c\\<in>\\<X>. \\<nexists>d. d \\<le> k c \\<and> u c = real d\"\n  shows \"\\<forall>c\\<in>\\<X>. \\<forall>u \\<in> [u]\\<^sub>\\<R>. \\<nexists>d. d \\<le> k c \\<and> u c = real d\"", "lemma K_cfg_trans':\n  assumes \"repcs (l, u) cfg \\<in> MDP.cfg_on (l, u)\" \"cfg' \\<in> K_cfg (repcs (l, u) cfg)\"\n          \"state cfg' = (l', u')\" \"(l, u) \\<in> S\" \"cfg \\<in> R_G.valid_cfg\" \"abss (l, u) = state cfg\"\n  shows \"trans' u u'\"", "lemma K_cfg_rept_in:\nassumes \"cfg \\<in> R_G.valid_cfg\"\n    and \"abss st = state cfg\"\n    and \"cfg' \\<in> K_cfg cfg\"\n  shows \"(THE s'. s' \\<in> set_pmf (rept st (action cfg)) \\<and> abss s' = state cfg')\n         \\<in> set_pmf (rept st (action cfg))\"", "lemma enabled_repcsI:\n  assumes \"cfg \\<in> R_G.valid_cfg\" \"abss st = state cfg\" \"MDP.MC.enabled (repcs st cfg) xs\"\n  shows \"enabled_repcs (repcs st cfg) xs\"", "lemma repcs_eq_rept:\n  \"rept st (action cfg) = rept st'' (action cfg'')\" if \"repcs st cfg = repcs st'' cfg''\"", "lemma enabled_stream_trans':\n  assumes \"cfg \\<in> R_G.valid_cfg\" \"abss st = state cfg\" \"MDP.MC.enabled (repcs st cfg) xs\"\n  shows \"pairwise trans' (smap (snd o state) xs)\"", "lemma divergent_\\<R>_divergent:\n  assumes in_S: \"pred_stream (\\<lambda> u. u \\<in> V) xs\"\n     and  div:  \"divergent xs\"\n     and trans: \"stream_trans xs\"\n  shows \"\\<R>_div (smap (\\<lambda> u. [u]\\<^sub>\\<R>) xs)\" (is \"\\<R>_div ?\\<omega>\")", "lemma (in -)\n  fixes f :: \"nat \\<Rightarrow> real\"\n  assumes \"\\<forall> i. f i \\<ge> 0\" \"\\<forall> i. \\<exists> j \\<ge> i. f j > d\" \"d > 0\"\n  shows \"\\<exists> n. (\\<Sum> i \\<le> n. f i) > t\"", "lemma dur_ev_exceedsI:\n  assumes \"\\<forall> i. \\<exists> j \\<ge> i. dur xs j - dur xs i \\<ge> d\" and \"d > 0\"\n  obtains i where \"dur xs i > t\"", "lemma not_reset_mono:\n  assumes \"stream_trans xs\" \"shd xs c1 \\<ge> shd xs c2\" \"stream_all (\\<lambda> u. u \\<in> V) xs\" \"c2 \\<in> \\<X>\"\n  shows \"(holds (\\<lambda> u. u c1 \\<ge> u c2) until holds (\\<lambda> u. u c1 = 0)) xs\"", "lemma \\<R>_divergent_divergent_aux:\n  fixes xs :: \"('c, t) cval stream\"\n  assumes \"stream_trans xs\" \"stream_all (\\<lambda> u. u \\<in> V) xs\"\n          \"(xs !! i) c1 = 0\" \"\\<exists> k > i. k \\<le> j \\<and> (xs !! k) c2 = 0\"\n          \"\\<forall> k > i. k \\<le> j \\<longrightarrow> (xs !! k) c1 \\<noteq> 0\"\n          \"c1 \\<in> \\<X>\" \"c2 \\<in> \\<X>\"\n  shows \"(xs !! j) c1 \\<ge> (xs !! j) c2\"", "lemma unbounded_all:\n  assumes \"R \\<in> \\<R>\" \"u \\<in> R\" \"unbounded x R\" \"x \\<in> \\<X>\"\n  shows \"u x > k x\"", "lemma trans_not_delay_mono:\n  \"u' c \\<le> u c\" if \"trans u u'\" \"u \\<in> V\" \"x \\<in> \\<X>\" \"u' x = 0\" \"c \\<in> \\<X>\"", "lemma dur_reset:\n  assumes \"pairwise eq_elapsed xs\" \"pred_stream (\\<lambda> u. u \\<in> V) xs\" \"zero x ([xs !! Suc i]\\<^sub>\\<R>)\" \"x \\<in> \\<X>\"\n  shows \"dur xs (Suc i) - dur xs i = 0\"", "lemma resets_mono_0':\n  assumes \"pairwise eq_elapsed xs\" \"stream_all (\\<lambda> u. u \\<in> V) xs\" \"stream_trans xs\"\n          \"\\<forall> j \\<le> i. zero x ([xs !! j]\\<^sub>\\<R>)\" \"x \\<in> \\<X>\" \"c \\<in> \\<X>\"\n  shows \"(xs !! i) c = (xs !! 0) c \\<or> (xs !! i) c = 0\"", "lemma resets_mono':\n  assumes \"pairwise eq_elapsed xs\" \"pred_stream (\\<lambda> u. u \\<in> V) xs\" \"stream_trans xs\"\n          \"\\<forall> k \\<ge> i. k \\<le> j \\<longrightarrow> zero x ([xs !! k]\\<^sub>\\<R>)\" \"x \\<in> \\<X>\" \"c \\<in> \\<X>\" \"i \\<le> j\"\n  shows \"(xs !! j) c = (xs !! i) c \\<or> (xs !! j) c = 0\"", "lemma resets_mono:\n  assumes \"pairwise eq_elapsed xs\" \"pred_stream (\\<lambda> u. u \\<in> V) xs\" \"stream_trans xs\"\n          \"\\<forall> k \\<ge> i. k \\<le> j \\<longrightarrow> zero x ([xs !! k]\\<^sub>\\<R>)\" \"x \\<in> \\<X>\" \"c \\<in> \\<X>\" \"i \\<le> j\"\n  shows \"(xs !! j) c \\<le> (xs !! i) c\"", "lemma \\<R>_divergent_divergent_aux2:\n  fixes M :: \"(nat \\<Rightarrow> bool) set\"\n  assumes \"\\<forall> i. \\<forall> P \\<in> M. \\<exists> j \\<ge> i. P j\" \"M \\<noteq> {}\" \"finite M\"\n  shows \"\\<forall>i.\\<exists>j\\<ge>i.\\<exists>k>j.\\<exists> P \\<in> M. P j \\<and> P k \\<and> (\\<forall> m < k. j < m \\<longrightarrow> \\<not> P m)\n       \\<and> (\\<forall> Q \\<in> M. \\<exists> m \\<le> k. j < m \\<and> Q m)\"", "lemma \\<R>_divergent_divergent:\n  assumes in_S: \"pred_stream (\\<lambda> u. u \\<in> V) xs\"\n    and div: \"\\<R>_div (smap (\\<lambda> u. [u]\\<^sub>\\<R>) xs)\"\n    and trans: \"stream_trans xs\"\n    and trans': \"pairwise trans' xs\"\n    and unbounded_not_const:\n    \"\\<forall>u. (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<longrightarrow> \\<not> ev (alw (\\<lambda>xs. shd xs = u)) xs\"\n  shows \"divergent xs\"", "lemma cfg_on_div_absc:\n  notes in_space_UNIV[measurable]\n  assumes \"cfg \\<in> cfg_on_div st\" \"st \\<in> S\"\n  shows \"absc cfg \\<in> R_G_cfg_on_div (abss st)\"", "lemma K_cfg_same_loc_iff:\n  \"(\\<forall>cfg'\\<in> K_cfg cfg. fst (state cfg') = fst (state cfg))\n  \\<longleftrightarrow> (\\<forall>cfg'\\<in> K_cfg (absc cfg). fst (state cfg') = fst (state (absc cfg)))\"\n  if \"cfg \\<in> valid_cfg\"", "lemma (in -) stream_all2_flip:\n  \"stream_all2 (\\<lambda>a b. R b a) xs ys = stream_all2 R ys xs\"", "lemma AE_alw_ev_same_loc_iff:\n  assumes \"cfg \\<in> valid_cfg\"\n  shows \"alternating cfg \\<longleftrightarrow> alternating (absc cfg)\"", "lemma AE_alw_ev_same_loc_iff':\n  assumes \"cfg \\<in> R_G.cfg_on (abss st)\" \"st \\<in> S\"\n  shows \"alternating cfg \\<longleftrightarrow> alternating (repcs st cfg)\"", "lemma (in -) cval_add_non_id:\n  False if \"b \\<oplus> d = b\" \"d > 0\" for d :: real", "lemma repcs_unbounded_AE_non_loop_end_strong:\n  assumes \"cfg \\<in> R_G.cfg_on (abss st)\" \"st \\<in> S\"\n    and \"alternating cfg\"\n  shows \"AE \\<omega> in MDP.MC.T (repcs st cfg).\n      (\\<forall> u :: ('c \\<Rightarrow> real). (\\<forall> c \\<in> \\<X>. u c > real (k c)) \\<longrightarrow>\n      \\<not> (ev (alw (\\<lambda> xs. shd xs = u))) (smap (snd o state) \\<omega>))\" (is \"AE \\<omega> in ?M. ?P \\<omega>\")", "lemma cfg_on_div_repcs_strong:\n  notes in_space_UNIV[measurable]\n  assumes \"cfg \\<in> R_G_cfg_on_div (abss st)\" \"st \\<in> S\" and \"alternating cfg\"\n  shows \"repcs st cfg \\<in> cfg_on_div st\"", "lemma repcs_unbounded_AE_non_loop_end:\n  assumes \"cfg \\<in> R_G.cfg_on (abss st)\" \"st \\<in> S\"\n  shows \"AE \\<omega> in MDP.MC.T (repcs st cfg).\n      (\\<forall> s :: ('s \\<times> ('c \\<Rightarrow> real)). (\\<forall> c \\<in> \\<X>. snd s c > k c) \\<longrightarrow>\n      \\<not> (ev (alw (\\<lambda> xs. shd xs = s))) (smap state \\<omega>))\" (is \"AE \\<omega> in ?M. ?P \\<omega>\")", "lemma R_G_cfg_on_valid:\n  \"cfg \\<in> R_G.valid_cfg\" if \"cfg \\<in> R_G_cfg_on_div s'\"", "lemma cfg_on_valid:\n  \"cfg \\<in> valid_cfg\" if \"cfg \\<in> cfg_on_div s\"", "lemma absc_valid_cfg_eq:\n  \"absc ` progressive s = R_G_progressive s'\"", "theorem Min_Max_reachability:\n  notes in_space_UNIV[measurable] and [iff] = pred_stream_iff\n  shows\n  \"(\\<Squnion>cfg\\<in> progressive s.      path_measure     (\\<lambda> x. (holds \\<phi>  suntil holds \\<psi>)  (s  ## x)) cfg)\n = (\\<Squnion>cfg\\<in> R_G_progressive s'. R_G_path_measure (\\<lambda> x. (holds \\<phi>' suntil holds \\<psi>') (s' ## x)) cfg)\n \\<and> (\\<Sqinter>cfg\\<in> progressive s.      path_measure     (\\<lambda> x. (holds \\<phi>  suntil holds \\<psi>)  (s  ## x)) cfg)\n = (\\<Sqinter>cfg\\<in> R_G_progressive s'. R_G_path_measure (\\<lambda> x. (holds \\<phi>' suntil holds \\<psi>') (s' ## x)) cfg)\""], "translations": [["", "lemma pairwise_Suc:\n  \"pairwise P xs \\<Longrightarrow> P (xs !! i) (xs !! (Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PTA_Reachability.pairwise P xs \\<Longrightarrow>\n    P (xs !! i) (xs !! Suc i)", "by (induction i arbitrary: xs) (force elim: pairwise.cases)+"], ["", "lemma Suc_pairwise:\n  \"\\<forall> i. P (xs !! i) (xs !! (Suc i)) \\<Longrightarrow> pairwise P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. P (xs !! i) (xs !! Suc i) \\<Longrightarrow>\n    PTA_Reachability.pairwise P xs", "apply (coinduction arbitrary: xs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<forall>i. P (xs !! i) (xs !! Suc i) \\<Longrightarrow>\n       \\<exists>a b xsa.\n          xs = a ## b ## xsa \\<and>\n          P a b \\<and>\n          ((\\<exists>xs.\n               b ## xsa = xs \\<and>\n               (\\<forall>i. P (xs !! i) (xs !! Suc i))) \\<or>\n           PTA_Reachability.pairwise P (b ## xsa))", "apply (subst stream.collapse[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<forall>i. P (xs !! i) (xs !! Suc i) \\<Longrightarrow>\n       \\<exists>a b xsa.\n          shd xs ## stl xs = a ## b ## xsa \\<and>\n          P a b \\<and>\n          ((\\<exists>xs.\n               b ## xsa = xs \\<and>\n               (\\<forall>i. P (xs !! i) (xs !! Suc i))) \\<or>\n           PTA_Reachability.pairwise P (b ## xsa))", "apply (rewrite in \"stl _\" stream.collapse[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<forall>i. P (xs !! i) (xs !! Suc i) \\<Longrightarrow>\n       \\<exists>a b xsa.\n          shd xs ## shd (stl xs) ## stl (stl xs) = a ## b ## xsa \\<and>\n          P a b \\<and>\n          ((\\<exists>xs.\n               b ## xsa = xs \\<and>\n               (\\<forall>i. P (xs !! i) (xs !! Suc i))) \\<or>\n           PTA_Reachability.pairwise P (b ## xsa))", "apply (intro exI conjI, rule HOL.refl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<forall>i. P (xs !! i) (xs !! Suc i) \\<Longrightarrow>\n       P (shd xs) (shd (stl xs))\n 2. \\<And>xs.\n       \\<forall>i. P (xs !! i) (xs !! Suc i) \\<Longrightarrow>\n       (\\<exists>xsa.\n           shd (stl xs) ## stl (stl xs) = xsa \\<and>\n           (\\<forall>i. P (xsa !! i) (xsa !! Suc i))) \\<or>\n       PTA_Reachability.pairwise P (shd (stl xs) ## stl (stl xs))", "apply (erule allE[where x = 0]; simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<forall>i. P (xs !! i) (xs !! Suc i) \\<Longrightarrow>\n       (\\<exists>xsa.\n           shd (stl xs) ## stl (stl xs) = xsa \\<and>\n           (\\<forall>i. P (xsa !! i) (xsa !! Suc i))) \\<or>\n       PTA_Reachability.pairwise P (shd (stl xs) ## stl (stl xs))", "by simp (metis snth.simps(2))"], ["", "lemma pairwise_iff:\n  \"pairwise P xs \\<longleftrightarrow> (\\<forall> i. P (xs !! i) (xs !! (Suc i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PTA_Reachability.pairwise P xs = (\\<forall>i. P (xs !! i) (xs !! Suc i))", "using pairwise_Suc Suc_pairwise"], ["proof (prove)\nusing this:\n  PTA_Reachability.pairwise ?P ?xs \\<Longrightarrow>\n  ?P (?xs !! ?i) (?xs !! Suc ?i)\n  \\<forall>i. ?P (?xs !! i) (?xs !! Suc i) \\<Longrightarrow>\n  PTA_Reachability.pairwise ?P ?xs\n\ngoal (1 subgoal):\n 1. PTA_Reachability.pairwise P xs = (\\<forall>i. P (xs !! i) (xs !! Suc i))", "by blast"], ["", "lemma pairwise_stlD:\n  \"pairwise P xs \\<Longrightarrow> pairwise P (stl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PTA_Reachability.pairwise P xs \\<Longrightarrow>\n    PTA_Reachability.pairwise P (stl xs)", "by (auto elim: pairwise.cases)"], ["", "lemma pairwise_pairD:\n  \"pairwise P xs \\<Longrightarrow> P (shd xs) (shd (stl xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PTA_Reachability.pairwise P xs \\<Longrightarrow>\n    P (shd xs) (shd (stl xs))", "by (auto elim: pairwise.cases)"], ["", "lemma pairwise_mp:\n  assumes \"pairwise P xs\" and lift: \"\\<And> x y. x \\<in> sset xs \\<Longrightarrow> y \\<in> sset xs \\<Longrightarrow> P x y \\<Longrightarrow> Q x y\"\n  shows \"pairwise Q xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PTA_Reachability.pairwise Q xs", "using assms"], ["proof (prove)\nusing this:\n  PTA_Reachability.pairwise P xs\n  \\<lbrakk>?x \\<in> sset xs; ?y \\<in> sset xs; P ?x ?y\\<rbrakk>\n  \\<Longrightarrow> Q ?x ?y\n\ngoal (1 subgoal):\n 1. PTA_Reachability.pairwise Q xs", "apply (coinduction arbitrary: xs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>PTA_Reachability.pairwise P xs;\n        \\<forall>x y.\n           x \\<in> sset xs \\<longrightarrow>\n           y \\<in> sset xs \\<longrightarrow>\n           P x y \\<longrightarrow> Q x y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b xsa.\n                            xs = a ## b ## xsa \\<and>\n                            Q a b \\<and>\n                            ((\\<exists>xs.\n                                 b ## xsa = xs \\<and>\n                                 PTA_Reachability.pairwise P xs \\<and>\n                                 (\\<forall>x y.\n                                     x \\<in> sset xs \\<longrightarrow>\n                                     y \\<in> sset xs \\<longrightarrow>\n                                     P x y \\<longrightarrow> Q x y)) \\<or>\n                             PTA_Reachability.pairwise Q (b ## xsa))", "subgoal for xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>PTA_Reachability.pairwise P xs;\n     \\<forall>x y.\n        x \\<in> sset xs \\<longrightarrow>\n        y \\<in> sset xs \\<longrightarrow>\n        P x y \\<longrightarrow> Q x y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b xs.\n                         xs = a ## b ## xs \\<and>\n                         Q a b \\<and>\n                         ((\\<exists>xsa.\n                              b ## xs = xsa \\<and>\n                              PTA_Reachability.pairwise P xsa \\<and>\n                              (\\<forall>x y.\n                                  x \\<in> sset xsa \\<longrightarrow>\n                                  y \\<in> sset xsa \\<longrightarrow>\n                                  P x y \\<longrightarrow> Q x y)) \\<or>\n                          PTA_Reachability.pairwise Q (b ## xs))", "apply (subst stream.collapse[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>PTA_Reachability.pairwise P xs;\n     \\<forall>x y.\n        x \\<in> sset xs \\<longrightarrow>\n        y \\<in> sset xs \\<longrightarrow>\n        P x y \\<longrightarrow> Q x y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b xs.\n                         shd xs ## stl xs = a ## b ## xs \\<and>\n                         Q a b \\<and>\n                         ((\\<exists>xsa.\n                              b ## xs = xsa \\<and>\n                              PTA_Reachability.pairwise P xsa \\<and>\n                              (\\<forall>x y.\n                                  x \\<in> sset xsa \\<longrightarrow>\n                                  y \\<in> sset xsa \\<longrightarrow>\n                                  P x y \\<longrightarrow> Q x y)) \\<or>\n                          PTA_Reachability.pairwise Q (b ## xs))", "apply (rewrite in \"stl _\" stream.collapse[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>PTA_Reachability.pairwise P xs;\n     \\<forall>x y.\n        x \\<in> sset xs \\<longrightarrow>\n        y \\<in> sset xs \\<longrightarrow>\n        P x y \\<longrightarrow> Q x y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b xs.\n                         shd xs ## shd (stl xs) ## stl (stl xs) =\n                         a ## b ## xs \\<and>\n                         Q a b \\<and>\n                         ((\\<exists>xsa.\n                              b ## xs = xsa \\<and>\n                              PTA_Reachability.pairwise P xsa \\<and>\n                              (\\<forall>x y.\n                                  x \\<in> sset xsa \\<longrightarrow>\n                                  y \\<in> sset xsa \\<longrightarrow>\n                                  P x y \\<longrightarrow> Q x y)) \\<or>\n                          PTA_Reachability.pairwise Q (b ## xs))", "apply (intro exI conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>PTA_Reachability.pairwise P xs;\n     \\<forall>x y.\n        x \\<in> sset xs \\<longrightarrow>\n        y \\<in> sset xs \\<longrightarrow>\n        P x y \\<longrightarrow> Q x y\\<rbrakk>\n    \\<Longrightarrow> shd xs ## shd (stl xs) ## stl (stl xs) =\n                      ?a3 ## ?b4 ## ?xs5\n 2. \\<lbrakk>PTA_Reachability.pairwise P xs;\n     \\<forall>x y.\n        x \\<in> sset xs \\<longrightarrow>\n        y \\<in> sset xs \\<longrightarrow>\n        P x y \\<longrightarrow> Q x y\\<rbrakk>\n    \\<Longrightarrow> Q ?a3 ?b4\n 3. \\<lbrakk>PTA_Reachability.pairwise P xs;\n     \\<forall>x y.\n        x \\<in> sset xs \\<longrightarrow>\n        y \\<in> sset xs \\<longrightarrow>\n        P x y \\<longrightarrow> Q x y\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>xs.\n                          ?b4 ## ?xs5 = xs \\<and>\n                          PTA_Reachability.pairwise P xs \\<and>\n                          (\\<forall>x y.\n                              x \\<in> sset xs \\<longrightarrow>\n                              y \\<in> sset xs \\<longrightarrow>\n                              P x y \\<longrightarrow> Q x y)) \\<or>\n                      PTA_Reachability.pairwise Q (?b4 ## ?xs5)", "apply (rule HOL.refl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>PTA_Reachability.pairwise P xs;\n     \\<forall>x y.\n        x \\<in> sset xs \\<longrightarrow>\n        y \\<in> sset xs \\<longrightarrow>\n        P x y \\<longrightarrow> Q x y\\<rbrakk>\n    \\<Longrightarrow> Q (shd xs) (shd (stl xs))\n 2. \\<lbrakk>PTA_Reachability.pairwise P xs;\n     \\<forall>x y.\n        x \\<in> sset xs \\<longrightarrow>\n        y \\<in> sset xs \\<longrightarrow>\n        P x y \\<longrightarrow> Q x y\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>xs.\n                          shd (stl xs) ## stl (stl xs) = xs \\<and>\n                          PTA_Reachability.pairwise P xs \\<and>\n                          (\\<forall>x y.\n                              x \\<in> sset xs \\<longrightarrow>\n                              y \\<in> sset xs \\<longrightarrow>\n                              P x y \\<longrightarrow> Q x y)) \\<or>\n                      PTA_Reachability.pairwise Q\n                       (shd (stl xs) ## stl (stl xs))", "by (auto intro: stl_sset dest: pairwise_pairD pairwise_stlD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pairwise_sdropD:\n  \"pairwise P (sdrop i xs)\" if \"pairwise P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PTA_Reachability.pairwise P (sdrop i xs)", "using that"], ["proof (prove)\nusing this:\n  PTA_Reachability.pairwise P xs\n\ngoal (1 subgoal):\n 1. PTA_Reachability.pairwise P (sdrop i xs)", "proof (coinduction arbitrary: i xs)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i xs.\n       PTA_Reachability.pairwise P xs \\<Longrightarrow>\n       \\<exists>a b xsa.\n          sdrop i xs = a ## b ## xsa \\<and>\n          P a b \\<and>\n          ((\\<exists>i xs.\n               b ## xsa = sdrop i xs \\<and>\n               PTA_Reachability.pairwise P xs) \\<or>\n           PTA_Reachability.pairwise P (b ## xsa))", "case (pairwise i xs)"], ["proof (state)\nthis:\n  PTA_Reachability.pairwise P xs\n\ngoal (1 subgoal):\n 1. \\<And>i xs.\n       PTA_Reachability.pairwise P xs \\<Longrightarrow>\n       \\<exists>a b xsa.\n          sdrop i xs = a ## b ## xsa \\<and>\n          P a b \\<and>\n          ((\\<exists>i xs.\n               b ## xsa = sdrop i xs \\<and>\n               PTA_Reachability.pairwise P xs) \\<or>\n           PTA_Reachability.pairwise P (b ## xsa))", "then"], ["proof (chain)\npicking this:\n  PTA_Reachability.pairwise P xs", "show ?case"], ["proof (prove)\nusing this:\n  PTA_Reachability.pairwise P xs\n\ngoal (1 subgoal):\n 1. \\<exists>a b xs.\n       sdrop i xs = a ## b ## xs \\<and>\n       P a b \\<and>\n       ((\\<exists>i xsa.\n            b ## xs = sdrop i xsa \\<and>\n            PTA_Reachability.pairwise P xsa) \\<or>\n        PTA_Reachability.pairwise P (b ## xs))", "apply (inst_existentials \"shd (sdrop i xs)\" \"shd (stl (sdrop i xs))\" \"stl (stl (sdrop i xs))\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. PTA_Reachability.pairwise P xs \\<Longrightarrow>\n    sdrop i xs =\n    shd (sdrop i xs) ## shd (stl (sdrop i xs)) ## stl (stl (sdrop i xs))\n 2. PTA_Reachability.pairwise P xs \\<Longrightarrow>\n    P (shd (sdrop i xs)) (shd (stl (sdrop i xs)))\n 3. PTA_Reachability.pairwise P xs \\<Longrightarrow>\n    (\\<exists>i xs.\n        shd (stl (sdrop i xs)) ## stl (stl (sdrop i xs)) = sdrop i xs \\<and>\n        PTA_Reachability.pairwise P xs) \\<or>\n    PTA_Reachability.pairwise P\n     (shd (stl (sdrop i xs)) ## stl (stl (sdrop i xs)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. PTA_Reachability.pairwise P xs \\<Longrightarrow>\n    sdrop i xs =\n    shd (sdrop i xs) ## shd (stl (sdrop i xs)) ## stl (stl (sdrop i xs))", "by (auto dest: pairwise_Suc) (metis sdrop_simps(1) sdrop_stl stream.collapse)"], ["proof (prove)\ngoal (2 subgoals):\n 1. PTA_Reachability.pairwise P xs \\<Longrightarrow>\n    P (shd (sdrop i xs)) (shd (stl (sdrop i xs)))\n 2. PTA_Reachability.pairwise P xs \\<Longrightarrow>\n    (\\<exists>i xs.\n        shd (stl (sdrop i xs)) ## stl (stl (sdrop i xs)) = sdrop i xs \\<and>\n        PTA_Reachability.pairwise P xs) \\<or>\n    PTA_Reachability.pairwise P\n     (shd (stl (sdrop i xs)) ## stl (stl (sdrop i xs)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. PTA_Reachability.pairwise P xs \\<Longrightarrow>\n    P (shd (sdrop i xs)) (shd (stl (sdrop i xs)))", "by (inst_existentials \"i - 1\" \"stl xs\") (auto dest: pairwise_Suc pairwise_stlD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. PTA_Reachability.pairwise P xs \\<Longrightarrow>\n    (\\<exists>i xs.\n        shd (stl (sdrop i xs)) ## stl (stl (sdrop i xs)) = sdrop i xs \\<and>\n        PTA_Reachability.pairwise P xs) \\<or>\n    PTA_Reachability.pairwise P\n     (shd (stl (sdrop i xs)) ## stl (stl (sdrop i xs)))", "by (metis sdrop_simps(2) stream.collapse)"], ["proof (state)\nthis:\n  \\<exists>a b xs.\n     sdrop i xs = a ## b ## xs \\<and>\n     P a b \\<and>\n     ((\\<exists>i xsa.\n          b ## xs = sdrop i xsa \\<and>\n          PTA_Reachability.pairwise P xsa) \\<or>\n      PTA_Reachability.pairwise P (b ## xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Regions\\<close>"], ["", "(* XXX Move. Rename? *)"], ["", "lemma gt_GreaterD:\n  assumes \"u \\<in> region X I r\" \"valid_region X k I r\" \"c \\<in> X\" \"u c > k c\"\n  shows \"I c = Greater (k c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I c = Regions.intv.Greater (k c)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. I c = Regions.intv.Greater (k c)", "from assms"], ["proof (chain)\npicking this:\n  u \\<in> Regions.region X I r\n  Regions.valid_region X k I r\n  c \\<in> X\n  real (k c) < u c", "have \"intv_elem c u (I c)\" \"valid_intv (k c) (I c)\""], ["proof (prove)\nusing this:\n  u \\<in> Regions.region X I r\n  Regions.valid_region X k I r\n  c \\<in> X\n  real (k c) < u c\n\ngoal (1 subgoal):\n 1. Regions.intv_elem c u (I c) &&& Regions.valid_intv (k c) (I c)", "by auto"], ["proof (state)\nthis:\n  Regions.intv_elem c u (I c)\n  Regions.valid_intv (k c) (I c)\n\ngoal (1 subgoal):\n 1. I c = Regions.intv.Greater (k c)", "with assms(4)"], ["proof (chain)\npicking this:\n  real (k c) < u c\n  Regions.intv_elem c u (I c)\n  Regions.valid_intv (k c) (I c)", "show ?thesis"], ["proof (prove)\nusing this:\n  real (k c) < u c\n  Regions.intv_elem c u (I c)\n  Regions.valid_intv (k c) (I c)\n\ngoal (1 subgoal):\n 1. I c = Regions.intv.Greater (k c)", "by (cases \"I c\") auto"], ["proof (state)\nthis:\n  I c = Regions.intv.Greater (k c)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma const_ConstD:\n  assumes \"u \\<in> region X I r\" \"valid_region X k I r\" \"c \\<in> X\" \"u c = d\" \"d \\<le> k c\"\n  shows \"I c = Const d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I c = Regions.intv.Const d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. I c = Regions.intv.Const d", "from assms"], ["proof (chain)\npicking this:\n  u \\<in> Regions.region X I r\n  Regions.valid_region X k I r\n  c \\<in> X\n  u c = real d\n  d \\<le> k c", "have \"intv_elem c u (I c)\" \"valid_intv (k c) (I c)\""], ["proof (prove)\nusing this:\n  u \\<in> Regions.region X I r\n  Regions.valid_region X k I r\n  c \\<in> X\n  u c = real d\n  d \\<le> k c\n\ngoal (1 subgoal):\n 1. Regions.intv_elem c u (I c) &&& Regions.valid_intv (k c) (I c)", "by auto"], ["proof (state)\nthis:\n  Regions.intv_elem c u (I c)\n  Regions.valid_intv (k c) (I c)\n\ngoal (1 subgoal):\n 1. I c = Regions.intv.Const d", "with assms(4,5)"], ["proof (chain)\npicking this:\n  u c = real d\n  d \\<le> k c\n  Regions.intv_elem c u (I c)\n  Regions.valid_intv (k c) (I c)", "show ?thesis"], ["proof (prove)\nusing this:\n  u c = real d\n  d \\<le> k c\n  Regions.intv_elem c u (I c)\n  Regions.valid_intv (k c) (I c)\n\ngoal (1 subgoal):\n 1. I c = Regions.intv.Const d", "by (cases \"I c\") auto"], ["proof (state)\nthis:\n  I c = Regions.intv.Const d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_Greater_bounded:\n  assumes \"I x \\<noteq> Greater (k x)\" \"x \\<in> X\" \"valid_region X k I r\" \"u \\<in> region X I r\"\n  shows \"u x \\<le> k x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u x \\<le> real (k x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u x \\<le> real (k x)", "from assms"], ["proof (chain)\npicking this:\n  I x \\<noteq> Regions.intv.Greater (k x)\n  x \\<in> X\n  Regions.valid_region X k I r\n  u \\<in> Regions.region X I r", "have \"intv_elem x u (I x)\" \"valid_intv (k x) (I x)\""], ["proof (prove)\nusing this:\n  I x \\<noteq> Regions.intv.Greater (k x)\n  x \\<in> X\n  Regions.valid_region X k I r\n  u \\<in> Regions.region X I r\n\ngoal (1 subgoal):\n 1. Regions.intv_elem x u (I x) &&& Regions.valid_intv (k x) (I x)", "by auto"], ["proof (state)\nthis:\n  Regions.intv_elem x u (I x)\n  Regions.valid_intv (k x) (I x)\n\ngoal (1 subgoal):\n 1. u x \\<le> real (k x)", "with assms(1)"], ["proof (chain)\npicking this:\n  I x \\<noteq> Regions.intv.Greater (k x)\n  Regions.intv_elem x u (I x)\n  Regions.valid_intv (k x) (I x)", "show \"u x \\<le> k x\""], ["proof (prove)\nusing this:\n  I x \\<noteq> Regions.intv.Greater (k x)\n  Regions.intv_elem x u (I x)\n  Regions.valid_intv (k x) (I x)\n\ngoal (1 subgoal):\n 1. u x \\<le> real (k x)", "by (cases \"I x\") auto"], ["proof (state)\nthis:\n  u x \\<le> real (k x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Greater_closed:\n  fixes t :: \"real\"\n  assumes \"u \\<in> region X I r\" \"valid_region X k I r\" \"c \\<in> X\" \"I c = Greater (k c)\" \"t > k c\"\n  shows \"u(c := t) \\<in> region X I r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u(c := t) \\<in> Regions.region X I r", "using assms"], ["proof (prove)\nusing this:\n  u \\<in> Regions.region X I r\n  Regions.valid_region X k I r\n  c \\<in> X\n  I c = Regions.intv.Greater (k c)\n  real (k c) < t\n\ngoal (1 subgoal):\n 1. u(c := t) \\<in> Regions.region X I r", "apply (intro region.intros)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>u \\<in> Regions.region X I r; Regions.valid_region X k I r;\n     c \\<in> X; I c = Regions.intv.Greater (k c); real (k c) < t\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>X. 0 \\<le> (u(c := t)) x\n 2. \\<lbrakk>u \\<in> Regions.region X I r; Regions.valid_region X k I r;\n     c \\<in> X; I c = Regions.intv.Greater (k c); real (k c) < t\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>X.\n                         Regions.intv_elem x (u(c := t)) (I x)\n 3. \\<lbrakk>u \\<in> Regions.region X I r; Regions.valid_region X k I r;\n     c \\<in> X; I c = Regions.intv.Greater (k c); real (k c) < t\\<rbrakk>\n    \\<Longrightarrow> ?X\\<^sub>05 =\n                      {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n 4. \\<lbrakk>u \\<in> Regions.region X I r; Regions.valid_region X k I r;\n     c \\<in> X; I c = Regions.intv.Greater (k c); real (k c) < t\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>?X\\<^sub>05.\n                         \\<forall>y\\<in>?X\\<^sub>05.\n                            ((x, y) \\<in> r) =\n                            (frac ((u(c := t)) x)\n                             \\<le> frac ((u(c := t)) y))", "apply (auto; fail)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>u \\<in> Regions.region X I r; Regions.valid_region X k I r;\n     c \\<in> X; I c = Regions.intv.Greater (k c); real (k c) < t\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>X.\n                         Regions.intv_elem x (u(c := t)) (I x)\n 2. \\<lbrakk>u \\<in> Regions.region X I r; Regions.valid_region X k I r;\n     c \\<in> X; I c = Regions.intv.Greater (k c); real (k c) < t\\<rbrakk>\n    \\<Longrightarrow> ?X\\<^sub>05 =\n                      {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n 3. \\<lbrakk>u \\<in> Regions.region X I r; Regions.valid_region X k I r;\n     c \\<in> X; I c = Regions.intv.Greater (k c); real (k c) < t\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>?X\\<^sub>05.\n                         \\<forall>y\\<in>?X\\<^sub>05.\n                            ((x, y) \\<in> r) =\n                            (frac ((u(c := t)) x)\n                             \\<le> frac ((u(c := t)) y))", "apply standard"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>u \\<in> Regions.region X I r; Regions.valid_region X k I r;\n        c \\<in> X; I c = Regions.intv.Greater (k c); real (k c) < t;\n        x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> Regions.intv_elem x (u(c := t)) (I x)\n 2. \\<lbrakk>u \\<in> Regions.region X I r; Regions.valid_region X k I r;\n     c \\<in> X; I c = Regions.intv.Greater (k c); real (k c) < t\\<rbrakk>\n    \\<Longrightarrow> ?X\\<^sub>05 =\n                      {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n 3. \\<lbrakk>u \\<in> Regions.region X I r; Regions.valid_region X k I r;\n     c \\<in> X; I c = Regions.intv.Greater (k c); real (k c) < t\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>?X\\<^sub>05.\n                         \\<forall>y\\<in>?X\\<^sub>05.\n                            ((x, y) \\<in> r) =\n                            (frac ((u(c := t)) x)\n                             \\<le> frac ((u(c := t)) y))", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> Regions.region X I r; Regions.valid_region X k I r;\n     c \\<in> X; I c = Regions.intv.Greater (k c); real (k c) < t;\n     x \\<in> X\\<rbrakk>\n    \\<Longrightarrow> Regions.intv_elem x (u(c := t)) (I x)", "by (cases \"x = c\"; cases \"I x\"; force intro!: intv_elem.intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>u \\<in> Regions.region X I r; Regions.valid_region X k I r;\n     c \\<in> X; I c = Regions.intv.Greater (k c); real (k c) < t\\<rbrakk>\n    \\<Longrightarrow> ?X\\<^sub>05 =\n                      {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n 2. \\<lbrakk>u \\<in> Regions.region X I r; Regions.valid_region X k I r;\n     c \\<in> X; I c = Regions.intv.Greater (k c); real (k c) < t\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>?X\\<^sub>05.\n                         \\<forall>y\\<in>?X\\<^sub>05.\n                            ((x, y) \\<in> r) =\n                            (frac ((u(c := t)) x)\n                             \\<le> frac ((u(c := t)) y))", "by auto"], ["", "lemma Greater_unbounded_aux:\n  assumes \"finite X\" \"valid_region X k I r\" \"c \\<in> X\" \"I c = Greater (k c)\"\n  shows \"\\<exists> u \\<in> region X I r. u c > t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>Regions.region X I r. t < u c", "using assms Greater_closed[OF _ assms(2-4)]"], ["proof (prove)\nusing this:\n  finite X\n  Regions.valid_region X k I r\n  c \\<in> X\n  I c = Regions.intv.Greater (k c)\n  \\<lbrakk>?u \\<in> Regions.region X I r; real (k c) < ?t\\<rbrakk>\n  \\<Longrightarrow> ?u(c := ?t) \\<in> Regions.region X I r\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>Regions.region X I r. t < u c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite X; Regions.valid_region X k I r; c \\<in> X;\n     I c = Regions.intv.Greater (k c);\n     \\<And>u t.\n        \\<lbrakk>u \\<in> Regions.region X I r; real (k c) < t\\<rbrakk>\n        \\<Longrightarrow> u(c := t) \\<in> Regions.region X I r\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u\\<in>Regions.region X I r. t < u c", "let ?R = \"region X I r\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite X; Regions.valid_region X k I r; c \\<in> X;\n     I c = Regions.intv.Greater (k c);\n     \\<And>u t.\n        \\<lbrakk>u \\<in> Regions.region X I r; real (k c) < t\\<rbrakk>\n        \\<Longrightarrow> u(c := t) \\<in> Regions.region X I r\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u\\<in>Regions.region X I r. t < u c", "let ?t = \"if t > k c then t + 1 else k c + 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite X; Regions.valid_region X k I r; c \\<in> X;\n     I c = Regions.intv.Greater (k c);\n     \\<And>u t.\n        \\<lbrakk>u \\<in> Regions.region X I r; real (k c) < t\\<rbrakk>\n        \\<Longrightarrow> u(c := t) \\<in> Regions.region X I r\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u\\<in>Regions.region X I r. t < u c", "have t: \"?t > k c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (k c) < (if real (k c) < t then t + 1 else real (k c + 1))", "by auto"], ["proof (state)\nthis:\n  real (k c) < (if real (k c) < t then t + 1 else real (k c + 1))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite X; Regions.valid_region X k I r; c \\<in> X;\n     I c = Regions.intv.Greater (k c);\n     \\<And>u t.\n        \\<lbrakk>u \\<in> Regions.region X I r; real (k c) < t\\<rbrakk>\n        \\<Longrightarrow> u(c := t) \\<in> Regions.region X I r\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u\\<in>Regions.region X I r. t < u c", "from region_not_empty[OF assms(1,2)]"], ["proof (chain)\npicking this:\n  \\<exists>u. u \\<in> Regions.region X I r", "obtain u where u: \"u \\<in> ?R\""], ["proof (prove)\nusing this:\n  \\<exists>u. u \\<in> Regions.region X I r\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        u \\<in> Regions.region X I r \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  u \\<in> Regions.region X I r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite X; Regions.valid_region X k I r; c \\<in> X;\n     I c = Regions.intv.Greater (k c);\n     \\<And>u t.\n        \\<lbrakk>u \\<in> Regions.region X I r; real (k c) < t\\<rbrakk>\n        \\<Longrightarrow> u(c := t) \\<in> Regions.region X I r\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u\\<in>Regions.region X I r. t < u c", "from Greater_closed[OF this assms(2-4) t]"], ["proof (chain)\npicking this:\n  u(c := if real (k c) < t then t + 1 else real (k c + 1))\n  \\<in> Regions.region X I r", "have \"u(c:=?t) \\<in> ?R\""], ["proof (prove)\nusing this:\n  u(c := if real (k c) < t then t + 1 else real (k c + 1))\n  \\<in> Regions.region X I r\n\ngoal (1 subgoal):\n 1. u(c := if real (k c) < t then t + 1 else real (k c + 1))\n    \\<in> Regions.region X I r", "by auto"], ["proof (state)\nthis:\n  u(c := if real (k c) < t then t + 1 else real (k c + 1))\n  \\<in> Regions.region X I r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite X; Regions.valid_region X k I r; c \\<in> X;\n     I c = Regions.intv.Greater (k c);\n     \\<And>u t.\n        \\<lbrakk>u \\<in> Regions.region X I r; real (k c) < t\\<rbrakk>\n        \\<Longrightarrow> u(c := t) \\<in> Regions.region X I r\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u\\<in>Regions.region X I r. t < u c", "with t"], ["proof (chain)\npicking this:\n  real (k c) < (if real (k c) < t then t + 1 else real (k c + 1))\n  u(c := if real (k c) < t then t + 1 else real (k c + 1))\n  \\<in> Regions.region X I r", "show ?thesis"], ["proof (prove)\nusing this:\n  real (k c) < (if real (k c) < t then t + 1 else real (k c + 1))\n  u(c := if real (k c) < t then t + 1 else real (k c + 1))\n  \\<in> Regions.region X I r\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>Regions.region X I r. t < u c", "by (inst_existentials \"u(c:=?t)\") auto"], ["proof (state)\nthis:\n  \\<exists>u\\<in>Regions.region X I r. t < u c\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Unbounded and Zero Regions\\<close>"], ["", "definition \"unbounded x R \\<equiv> \\<forall> t. \\<exists> u \\<in> R. u x > t\""], ["", "definition \"zero x R \\<equiv> \\<forall> u \\<in> R. u x = 0\""], ["", "lemma Greater_unbounded:\n  assumes \"finite X\" \"valid_region X k I r\" \"c \\<in> X\" \"I c = Greater (k c)\"\n  shows \"unbounded c (region X I r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unbounded c (Regions.region X I r)", "using Greater_unbounded_aux[OF assms]"], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>Regions.region X I r. ?t < u c\n\ngoal (1 subgoal):\n 1. unbounded c (Regions.region X I r)", "unfolding unbounded_def"], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>Regions.region X I r. ?t < u c\n\ngoal (1 subgoal):\n 1. \\<forall>t. \\<exists>u\\<in>Regions.region X I r. t < u c", "by blast"], ["", "lemma unbounded_Greater:\n  assumes \"valid_region X k I r\" \"c \\<in> X\" \"unbounded c (region X I r)\"\n  shows \"I c = Greater (k c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I c = Regions.intv.Greater (k c)", "using assms"], ["proof (prove)\nusing this:\n  Regions.valid_region X k I r\n  c \\<in> X\n  unbounded c (Regions.region X I r)\n\ngoal (1 subgoal):\n 1. I c = Regions.intv.Greater (k c)", "unfolding unbounded_def"], ["proof (prove)\nusing this:\n  Regions.valid_region X k I r\n  c \\<in> X\n  \\<forall>t. \\<exists>u\\<in>Regions.region X I r. t < u c\n\ngoal (1 subgoal):\n 1. I c = Regions.intv.Greater (k c)", "by (auto intro: gt_GreaterD)"], ["", "lemma Const_zero:\n  assumes \"c \\<in> X\" \"I c = Const 0\"\n  shows \"zero c (region X I r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero c (Regions.region X I r)", "using assms"], ["proof (prove)\nusing this:\n  c \\<in> X\n  I c = Regions.intv.Const 0\n\ngoal (1 subgoal):\n 1. zero c (Regions.region X I r)", "unfolding zero_def"], ["proof (prove)\nusing this:\n  c \\<in> X\n  I c = Regions.intv.Const 0\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>Regions.region X I r. u c = 0", "by force"], ["", "lemma zero_Const:\n  assumes \"finite X\" \"valid_region X k I r\" \"c \\<in> X\" \"zero c (region X I r)\"\n  shows \"I c = Const 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I c = Regions.intv.Const 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. I c = Regions.intv.Const 0", "from assms"], ["proof (chain)\npicking this:\n  finite X\n  Regions.valid_region X k I r\n  c \\<in> X\n  zero c (Regions.region X I r)", "obtain u where \"u \\<in> region X I r\""], ["proof (prove)\nusing this:\n  finite X\n  Regions.valid_region X k I r\n  c \\<in> X\n  zero c (Regions.region X I r)\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        u \\<in> Regions.region X I r \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by atomize_elim (auto intro: region_not_empty)"], ["proof (state)\nthis:\n  u \\<in> Regions.region X I r\n\ngoal (1 subgoal):\n 1. I c = Regions.intv.Const 0", "with assms"], ["proof (chain)\npicking this:\n  finite X\n  Regions.valid_region X k I r\n  c \\<in> X\n  zero c (Regions.region X I r)\n  u \\<in> Regions.region X I r", "show ?thesis"], ["proof (prove)\nusing this:\n  finite X\n  Regions.valid_region X k I r\n  c \\<in> X\n  zero c (Regions.region X I r)\n  u \\<in> Regions.region X I r\n\ngoal (1 subgoal):\n 1. I c = Regions.intv.Const 0", "unfolding zero_def"], ["proof (prove)\nusing this:\n  finite X\n  Regions.valid_region X k I r\n  c \\<in> X\n  \\<forall>u\\<in>Regions.region X I r. u c = 0\n  u \\<in> Regions.region X I r\n\ngoal (1 subgoal):\n 1. I c = Regions.intv.Const 0", "by (auto intro: const_ConstD)"], ["proof (state)\nthis:\n  I c = Regions.intv.Const 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zero_all:\n  assumes \"finite X\" \"valid_region X k I r\" \"c \\<in> X\" \"u \\<in> region X I r\" \"u c = 0\"\n  shows \"zero c (region X I r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero c (Regions.region X I r)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. zero c (Regions.region X I r)", "from assms"], ["proof (chain)\npicking this:\n  finite X\n  Regions.valid_region X k I r\n  c \\<in> X\n  u \\<in> Regions.region X I r\n  u c = 0", "have \"intv_elem c u (I c)\" \"valid_intv (k c) (I c)\""], ["proof (prove)\nusing this:\n  finite X\n  Regions.valid_region X k I r\n  c \\<in> X\n  u \\<in> Regions.region X I r\n  u c = 0\n\ngoal (1 subgoal):\n 1. Regions.intv_elem c u (I c) &&& Regions.valid_intv (k c) (I c)", "by auto"], ["proof (state)\nthis:\n  Regions.intv_elem c u (I c)\n  Regions.valid_intv (k c) (I c)\n\ngoal (1 subgoal):\n 1. zero c (Regions.region X I r)", "then"], ["proof (chain)\npicking this:\n  Regions.intv_elem c u (I c)\n  Regions.valid_intv (k c) (I c)", "have \"I c = Const 0\""], ["proof (prove)\nusing this:\n  Regions.intv_elem c u (I c)\n  Regions.valid_intv (k c) (I c)\n\ngoal (1 subgoal):\n 1. I c = Regions.intv.Const 0", "using assms(5)"], ["proof (prove)\nusing this:\n  Regions.intv_elem c u (I c)\n  Regions.valid_intv (k c) (I c)\n  u c = 0\n\ngoal (1 subgoal):\n 1. I c = Regions.intv.Const 0", "by cases auto"], ["proof (state)\nthis:\n  I c = Regions.intv.Const 0\n\ngoal (1 subgoal):\n 1. zero c (Regions.region X I r)", "with assms"], ["proof (chain)\npicking this:\n  finite X\n  Regions.valid_region X k I r\n  c \\<in> X\n  u \\<in> Regions.region X I r\n  u c = 0\n  I c = Regions.intv.Const 0", "have \"u' c = 0\" if \"u' \\<in> region X I r\" for u'"], ["proof (prove)\nusing this:\n  finite X\n  Regions.valid_region X k I r\n  c \\<in> X\n  u \\<in> Regions.region X I r\n  u c = 0\n  I c = Regions.intv.Const 0\n\ngoal (1 subgoal):\n 1. u' c = 0", "using that"], ["proof (prove)\nusing this:\n  finite X\n  Regions.valid_region X k I r\n  c \\<in> X\n  u \\<in> Regions.region X I r\n  u c = 0\n  I c = Regions.intv.Const 0\n  u' \\<in> Regions.region X I r\n\ngoal (1 subgoal):\n 1. u' c = 0", "by force"], ["proof (state)\nthis:\n  ?u' \\<in> Regions.region X I r \\<Longrightarrow> ?u' c = 0\n\ngoal (1 subgoal):\n 1. zero c (Regions.region X I r)", "then"], ["proof (chain)\npicking this:\n  ?u' \\<in> Regions.region X I r \\<Longrightarrow> ?u' c = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  ?u' \\<in> Regions.region X I r \\<Longrightarrow> ?u' c = 0\n\ngoal (1 subgoal):\n 1. zero c (Regions.region X I r)", "unfolding zero_def"], ["proof (prove)\nusing this:\n  ?u' \\<in> Regions.region X I r \\<Longrightarrow> ?u' c = 0\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>Regions.region X I r. u c = 0", "by blast"], ["proof (state)\nthis:\n  zero c (Regions.region X I r)\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Reachability\\<close>"], ["", "subsection \\<open>Definitions\\<close>"], ["", "locale Probabilistic_Timed_Automaton_Regions_Reachability =\n  Probabilistic_Timed_Automaton_Regions k v n not_in_X A\n    for k v n not_in_X and A :: \"('c, t, 's) pta\" +\n  fixes \\<phi> \\<psi> :: \"('s * ('c, t) cval) \\<Rightarrow> bool\" fixes s\n  assumes \\<phi>: \"\\<And> x y. x \\<in> S \\<Longrightarrow> x ~ y \\<Longrightarrow> \\<phi> x \\<longleftrightarrow> \\<phi> y\"\n  assumes \\<psi>: \"\\<And> x y. x \\<in> S \\<Longrightarrow> x ~ y \\<Longrightarrow> \\<psi> x \\<longleftrightarrow> \\<psi> y\"\n  assumes s[intro, simp]: \"s \\<in> S\"\nbegin"], ["", "definition \"\\<phi>' \\<equiv> absp \\<phi>\""], ["", "definition \"\\<psi>' \\<equiv> absp \\<psi>\""], ["", "definition \"s' \\<equiv> abss s\""], ["", "lemma s_s'_cfg_on[intro]:\n  assumes \"cfg \\<in> MDP.cfg_on s\"\n  shows \"absc cfg \\<in> R_G.cfg_on s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. absc cfg \\<in> R_G.cfg_on s'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. absc cfg \\<in> R_G.cfg_on s'", "from assms s"], ["proof (chain)\npicking this:\n  cfg \\<in> MDP.cfg_on s\n  s \\<in> S", "have \"cfg \\<in> valid_cfg\""], ["proof (prove)\nusing this:\n  cfg \\<in> MDP.cfg_on s\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. cfg \\<in> MDP.valid_cfg", "unfolding MDP.valid_cfg_def"], ["proof (prove)\nusing this:\n  cfg \\<in> MDP.cfg_on s\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. cfg \\<in> \\<Union> (MDP.cfg_on ` S)", "by auto"], ["proof (state)\nthis:\n  cfg \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. absc cfg \\<in> R_G.cfg_on s'", "then"], ["proof (chain)\npicking this:\n  cfg \\<in> MDP.valid_cfg", "have \"absc cfg \\<in> R_G.cfg_on (state (absc cfg))\""], ["proof (prove)\nusing this:\n  cfg \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. absc cfg \\<in> R_G.cfg_on (state (absc cfg))", "by (auto intro: R_G.valid_cfgD)"], ["proof (state)\nthis:\n  absc cfg \\<in> R_G.cfg_on (state (absc cfg))\n\ngoal (1 subgoal):\n 1. absc cfg \\<in> R_G.cfg_on s'", "with assms"], ["proof (chain)\npicking this:\n  cfg \\<in> MDP.cfg_on s\n  absc cfg \\<in> R_G.cfg_on (state (absc cfg))", "show ?thesis"], ["proof (prove)\nusing this:\n  cfg \\<in> MDP.cfg_on s\n  absc cfg \\<in> R_G.cfg_on (state (absc cfg))\n\ngoal (1 subgoal):\n 1. absc cfg \\<in> R_G.cfg_on s'", "unfolding s'_def"], ["proof (prove)\nusing this:\n  cfg \\<in> MDP.cfg_on s\n  absc cfg \\<in> R_G.cfg_on (state (absc cfg))\n\ngoal (1 subgoal):\n 1. absc cfg \\<in> R_G.cfg_on (abss s)", "by (auto simp: state_absc)"], ["proof (state)\nthis:\n  absc cfg \\<in> R_G.cfg_on s'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma s'_\\<S>[simp, intro]:\n  \"s' \\<in> \\<S>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s' \\<in> \\<S>", "unfolding s'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. abss s \\<in> \\<S>", "using s"], ["proof (prove)\nusing this:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. abss s \\<in> \\<S>", "by auto"], ["", "lemma s'_s_cfg_on[intro]:\n  assumes \"cfg \\<in> R_G.cfg_on s'\"\n  shows \"repcs s cfg \\<in> MDP.cfg_on s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. repcs s cfg \\<in> MDP.cfg_on s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. repcs s cfg \\<in> MDP.cfg_on s", "from assms s"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.cfg_on s'\n  s \\<in> S", "have \"cfg \\<in> R_G.valid_cfg\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.cfg_on s'\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. cfg \\<in> R_G.valid_cfg", "unfolding R_G.valid_cfg_def"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.cfg_on s'\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. cfg \\<in> \\<Union> (R_G.cfg_on ` \\<S>)", "by auto"], ["proof (state)\nthis:\n  cfg \\<in> R_G.valid_cfg\n\ngoal (1 subgoal):\n 1. repcs s cfg \\<in> MDP.cfg_on s", "with assms"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.cfg_on s'\n  cfg \\<in> R_G.valid_cfg", "have \"repcs s cfg \\<in> valid_cfg\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.cfg_on s'\n  cfg \\<in> R_G.valid_cfg\n\ngoal (1 subgoal):\n 1. repcs s cfg \\<in> MDP.valid_cfg", "by (auto simp: s'_def intro: R_G.valid_cfgD)"], ["proof (state)\nthis:\n  repcs s cfg \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. repcs s cfg \\<in> MDP.cfg_on s", "then"], ["proof (chain)\npicking this:\n  repcs s cfg \\<in> MDP.valid_cfg", "show ?thesis"], ["proof (prove)\nusing this:\n  repcs s cfg \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. repcs s cfg \\<in> MDP.cfg_on s", "by (auto dest: MDP.valid_cfgD)"], ["proof (state)\nthis:\n  repcs s cfg \\<in> MDP.cfg_on s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in Probabilistic_Timed_Automaton_Regions) compatible_stream:\n  assumes \\<phi>: \"\\<And> x y. x \\<in> S \\<Longrightarrow> x ~ y \\<Longrightarrow> \\<phi> x \\<longleftrightarrow> \\<phi> y\"\n  assumes \"pred_stream (\\<lambda>s. s \\<in> S) xs\"\n      and [intro]: \"x \\<in> S\"\n    shows \"pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s) (x ## xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s) (x ## xs)", "unfolding stream.pred_set"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>sset (x ## xs). \\<phi> (reps (abss s)) = \\<phi> s", "proof clarify"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> sset (x ## xs) \\<Longrightarrow>\n       \\<phi> (reps (abss (a, b))) = \\<phi> (a, b)", "fix l u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> sset (x ## xs) \\<Longrightarrow>\n       \\<phi> (reps (abss (a, b))) = \\<phi> (a, b)", "assume A: \"(l, u) \\<in> sset (x ## xs)\""], ["proof (state)\nthis:\n  (l, u) \\<in> sset (x ## xs)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> sset (x ## xs) \\<Longrightarrow>\n       \\<phi> (reps (abss (a, b))) = \\<phi> (a, b)", "from assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x5 \\<in> S; ?x5 ~ ?y5\\<rbrakk>\n  \\<Longrightarrow> \\<phi> ?x5 = \\<phi> ?y5\n  pred_stream (\\<lambda>s. s \\<in> S) xs\n  x \\<in> S", "have \"pred_stream (\\<lambda>s. s \\<in> S) (x ## xs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x5 \\<in> S; ?x5 ~ ?y5\\<rbrakk>\n  \\<Longrightarrow> \\<phi> ?x5 = \\<phi> ?y5\n  pred_stream (\\<lambda>s. s \\<in> S) xs\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>s. s \\<in> S) (x ## xs)", "by auto"], ["proof (state)\nthis:\n  pred_stream (\\<lambda>s. s \\<in> S) (x ## xs)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> sset (x ## xs) \\<Longrightarrow>\n       \\<phi> (reps (abss (a, b))) = \\<phi> (a, b)", "with A"], ["proof (chain)\npicking this:\n  (l, u) \\<in> sset (x ## xs)\n  pred_stream (\\<lambda>s. s \\<in> S) (x ## xs)", "have \"(l, u) \\<in> S\""], ["proof (prove)\nusing this:\n  (l, u) \\<in> sset (x ## xs)\n  pred_stream (\\<lambda>s. s \\<in> S) (x ## xs)\n\ngoal (1 subgoal):\n 1. (l, u) \\<in> S", "by (fastforce simp: stream.pred_set)"], ["proof (state)\nthis:\n  (l, u) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> sset (x ## xs) \\<Longrightarrow>\n       \\<phi> (reps (abss (a, b))) = \\<phi> (a, b)", "then"], ["proof (chain)\npicking this:\n  (l, u) \\<in> S", "have \"abss (l, u) \\<in> \\<S>\""], ["proof (prove)\nusing this:\n  (l, u) \\<in> S\n\ngoal (1 subgoal):\n 1. abss (l, u) \\<in> \\<S>", "by auto"], ["proof (state)\nthis:\n  abss (l, u) \\<in> \\<S>\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> sset (x ## xs) \\<Longrightarrow>\n       \\<phi> (reps (abss (a, b))) = \\<phi> (a, b)", "then"], ["proof (chain)\npicking this:\n  abss (l, u) \\<in> \\<S>", "have \"reps (abss (l, u)) ~ (l, u)\""], ["proof (prove)\nusing this:\n  abss (l, u) \\<in> \\<S>\n\ngoal (1 subgoal):\n 1. reps (abss (l, u)) ~ (l, u)", "by simp"], ["proof (state)\nthis:\n  reps (abss (l, u)) ~ (l, u)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> sset (x ## xs) \\<Longrightarrow>\n       \\<phi> (reps (abss (a, b))) = \\<phi> (a, b)", "with \\<phi> \\<open>(l, u) \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x5 \\<in> S; ?x5 ~ ?y5\\<rbrakk>\n  \\<Longrightarrow> \\<phi> ?x5 = \\<phi> ?y5\n  (l, u) \\<in> S\n  reps (abss (l, u)) ~ (l, u)", "show \"\\<phi> (reps (abss (l, u))) = \\<phi> (l, u)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x5 \\<in> S; ?x5 ~ ?y5\\<rbrakk>\n  \\<Longrightarrow> \\<phi> ?x5 = \\<phi> ?y5\n  (l, u) \\<in> S\n  reps (abss (l, u)) ~ (l, u)\n\ngoal (1 subgoal):\n 1. \\<phi> (reps (abss (l, u))) = \\<phi> (l, u)", "by blast"], ["proof (state)\nthis:\n  \\<phi> (reps (abss (l, u))) = \\<phi> (l, u)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<phi>_stream':\n  \"pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s) (x ## xs)\" if \"pred_stream (\\<lambda>s. s \\<in> S) xs\" \"x \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s) (x ## xs)", "using compatible_stream[of \\<phi>, OF \\<phi> that]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y.\n              \\<lbrakk>x \\<in> S; x ~ y\\<rbrakk>\n              \\<Longrightarrow> x \\<in> S;\n   \\<And>x y.\n      \\<lbrakk>x \\<in> S; x ~ y\\<rbrakk> \\<Longrightarrow> x ~ y\\<rbrakk>\n  \\<Longrightarrow> pred_stream\n                     (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s)\n                     (x ## xs)\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s) (x ## xs)", "."], ["", "lemma \\<psi>_stream':\n  \"pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s) (x ## xs)\" if \"pred_stream (\\<lambda>s. s \\<in> S) xs\" \"x \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s) (x ## xs)", "using compatible_stream[of \\<psi>, OF \\<psi> that]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y.\n              \\<lbrakk>x \\<in> S; x ~ y\\<rbrakk>\n              \\<Longrightarrow> x \\<in> S;\n   \\<And>x y.\n      \\<lbrakk>x \\<in> S; x ~ y\\<rbrakk> \\<Longrightarrow> x ~ y\\<rbrakk>\n  \\<Longrightarrow> pred_stream\n                     (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s)\n                     (x ## xs)\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s) (x ## xs)", "."], ["", "lemmas \\<phi>_stream = compatible_stream[of \\<phi>, OF \\<phi>]"], ["", "lemmas \\<psi>_stream = compatible_stream[of \\<psi>, OF \\<psi>]"], ["", "subsection \\<open>Easier Result on All Configurations\\<close>"], ["", "(* TODO: Rename *)"], ["", "lemma suntil_reps:\n  assumes\n    \"\\<forall>s\\<in>sset (smap abss y). s \\<in> \\<S>\"\n    \"(holds \\<phi>' suntil holds \\<psi>') (s' ## smap abss y)\"\n  shows \"(holds \\<phi> suntil holds \\<psi>) (s ## y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (holds \\<phi> suntil holds \\<psi>) (s ## y)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>s\\<in>sset (smap abss y). s \\<in> \\<S>\n  (holds \\<phi>' suntil holds \\<psi>') (s' ## smap abss y)\n\ngoal (1 subgoal):\n 1. (holds \\<phi> suntil holds \\<psi>) (s ## y)", "by (subst region_compatible_suntil[symmetric]; (intro \\<phi>_stream \\<psi>_stream)?)\n     (auto simp: \\<phi>'_def \\<psi>'_def absp_def stream.pred_set \\<S>_abss_S s'_def comp_def)"], ["", "(* TODO: Rename *)"], ["", "lemma suntil_abss:\n  assumes\n    \"\\<forall>s\\<in>sset y. s \\<in> S\"\n    \"(holds \\<phi> suntil holds \\<psi>) (s ## y)\"\n  shows\n    \"(holds \\<phi>' suntil holds \\<psi>') (s' ## smap abss y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (holds \\<phi>' suntil holds \\<psi>') (s' ## smap abss y)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>s\\<in>sset y. s \\<in> S\n  (holds \\<phi> suntil holds \\<psi>) (s ## y)\n\ngoal (1 subgoal):\n 1. (holds \\<phi>' suntil holds \\<psi>') (s' ## smap abss y)", "by (subst (asm) region_compatible_suntil[symmetric]; (intro \\<phi>_stream \\<psi>_stream)?)\n     (auto simp: \\<phi>'_def \\<psi>'_def absp_def stream.pred_set s'_def comp_def)"], ["", "(* TODO: Generalize to CTL formulae *)"], ["", "theorem P_sup_sunitl_eq:\n  notes [measurable] = in_space_UNIV and [iff] = pred_stream_iff\n  shows\n    \"(MDP.P_sup s  (\\<lambda>x. (holds \\<phi> suntil holds \\<psi>)   (s  ## x)))\n   = (R_G.P_sup s' (\\<lambda>x. (holds \\<phi>' suntil holds \\<psi>') (s' ## x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MDP.P_sup s (\\<lambda>x. (holds \\<phi> suntil holds \\<psi>) (s ## x)) =\n    R_G.P_sup s'\n     (\\<lambda>x. (holds \\<phi>' suntil holds \\<psi>') (s' ## x))", "unfolding MDP.P_sup_def R_G.P_sup_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>cfg\\<in>MDP.cfg_on s.\n        emeasure (MDP.T cfg)\n         {x \\<in> space MDP.St.\n          (holds \\<phi> suntil holds \\<psi>) (s ## x)}) =\n    (\\<Squnion>cfg\\<in>R_G.cfg_on s'.\n        emeasure (R_G.T cfg)\n         {x \\<in> space R_G.St.\n          (holds \\<phi>' suntil holds \\<psi>') (s' ## x)})", "proof (rule SUP_eq, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<in> MDP.cfg_on s \\<Longrightarrow>\n       \\<exists>j\\<in>R_G.cfg_on s'.\n          emeasure (MDP.T i)\n           {x \\<in> space MDP.St.\n            (holds \\<phi> suntil holds \\<psi>) (s ## x)}\n          \\<le> emeasure (R_G.T j)\n                 {x \\<in> space R_G.St.\n                  (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n 2. \\<And>j.\n       j \\<in> R_G.cfg_on s' \\<Longrightarrow>\n       \\<exists>i\\<in>MDP.cfg_on s.\n          emeasure (R_G.T j)\n           {x \\<in> space R_G.St.\n            (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n          \\<le> emeasure (MDP.T i)\n                 {x \\<in> space MDP.St.\n                  (holds \\<phi> suntil holds \\<psi>) (s ## x)}", "case prems: (1 cfg)"], ["proof (state)\nthis:\n  cfg \\<in> MDP.cfg_on s\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<in> MDP.cfg_on s \\<Longrightarrow>\n       \\<exists>j\\<in>R_G.cfg_on s'.\n          emeasure (MDP.T i)\n           {x \\<in> space MDP.St.\n            (holds \\<phi> suntil holds \\<psi>) (s ## x)}\n          \\<le> emeasure (R_G.T j)\n                 {x \\<in> space R_G.St.\n                  (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n 2. \\<And>j.\n       j \\<in> R_G.cfg_on s' \\<Longrightarrow>\n       \\<exists>i\\<in>MDP.cfg_on s.\n          emeasure (R_G.T j)\n           {x \\<in> space R_G.St.\n            (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n          \\<le> emeasure (MDP.T i)\n                 {x \\<in> space MDP.St.\n                  (holds \\<phi> suntil holds \\<psi>) (s ## x)}", "let ?cfg' = \"absc cfg\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<in> MDP.cfg_on s \\<Longrightarrow>\n       \\<exists>j\\<in>R_G.cfg_on s'.\n          emeasure (MDP.T i)\n           {x \\<in> space MDP.St.\n            (holds \\<phi> suntil holds \\<psi>) (s ## x)}\n          \\<le> emeasure (R_G.T j)\n                 {x \\<in> space R_G.St.\n                  (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n 2. \\<And>j.\n       j \\<in> R_G.cfg_on s' \\<Longrightarrow>\n       \\<exists>i\\<in>MDP.cfg_on s.\n          emeasure (R_G.T j)\n           {x \\<in> space R_G.St.\n            (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n          \\<le> emeasure (MDP.T i)\n                 {x \\<in> space MDP.St.\n                  (holds \\<phi> suntil holds \\<psi>) (s ## x)}", "from prems"], ["proof (chain)\npicking this:\n  cfg \\<in> MDP.cfg_on s", "have \"cfg \\<in> valid_cfg\""], ["proof (prove)\nusing this:\n  cfg \\<in> MDP.cfg_on s\n\ngoal (1 subgoal):\n 1. cfg \\<in> MDP.valid_cfg", "by (auto intro: MDP.valid_cfgI)"], ["proof (state)\nthis:\n  cfg \\<in> MDP.valid_cfg\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<in> MDP.cfg_on s \\<Longrightarrow>\n       \\<exists>j\\<in>R_G.cfg_on s'.\n          emeasure (MDP.T i)\n           {x \\<in> space MDP.St.\n            (holds \\<phi> suntil holds \\<psi>) (s ## x)}\n          \\<le> emeasure (R_G.T j)\n                 {x \\<in> space R_G.St.\n                  (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n 2. \\<And>j.\n       j \\<in> R_G.cfg_on s' \\<Longrightarrow>\n       \\<exists>i\\<in>MDP.cfg_on s.\n          emeasure (R_G.T j)\n           {x \\<in> space R_G.St.\n            (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n          \\<le> emeasure (MDP.T i)\n                 {x \\<in> space MDP.St.\n                  (holds \\<phi> suntil holds \\<psi>) (s ## x)}", "then"], ["proof (chain)\npicking this:\n  cfg \\<in> MDP.valid_cfg", "have \"?cfg' \\<in> R_G.valid_cfg\""], ["proof (prove)\nusing this:\n  cfg \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. absc cfg \\<in> R_G.valid_cfg", "by (auto intro: R_G.valid_cfgI)"], ["proof (state)\nthis:\n  absc cfg \\<in> R_G.valid_cfg\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<in> MDP.cfg_on s \\<Longrightarrow>\n       \\<exists>j\\<in>R_G.cfg_on s'.\n          emeasure (MDP.T i)\n           {x \\<in> space MDP.St.\n            (holds \\<phi> suntil holds \\<psi>) (s ## x)}\n          \\<le> emeasure (R_G.T j)\n                 {x \\<in> space R_G.St.\n                  (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n 2. \\<And>j.\n       j \\<in> R_G.cfg_on s' \\<Longrightarrow>\n       \\<exists>i\\<in>MDP.cfg_on s.\n          emeasure (R_G.T j)\n           {x \\<in> space R_G.St.\n            (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n          \\<le> emeasure (MDP.T i)\n                 {x \\<in> space MDP.St.\n                  (holds \\<phi> suntil holds \\<psi>) (s ## x)}", "from \\<open>cfg \\<in> valid_cfg\\<close>"], ["proof (chain)\npicking this:\n  cfg \\<in> MDP.valid_cfg", "have alw_S: \"almost_everywhere (MDP.T cfg) (pred_stream (\\<lambda>s. s \\<in> S))\""], ["proof (prove)\nusing this:\n  cfg \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. almost_everywhere (MDP.T cfg) (pred_stream (\\<lambda>s. s \\<in> S))", "by (rule MDP.alw_S)"], ["proof (state)\nthis:\n  almost_everywhere (MDP.T cfg) (pred_stream (\\<lambda>s. s \\<in> S))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<in> MDP.cfg_on s \\<Longrightarrow>\n       \\<exists>j\\<in>R_G.cfg_on s'.\n          emeasure (MDP.T i)\n           {x \\<in> space MDP.St.\n            (holds \\<phi> suntil holds \\<psi>) (s ## x)}\n          \\<le> emeasure (R_G.T j)\n                 {x \\<in> space R_G.St.\n                  (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n 2. \\<And>j.\n       j \\<in> R_G.cfg_on s' \\<Longrightarrow>\n       \\<exists>i\\<in>MDP.cfg_on s.\n          emeasure (R_G.T j)\n           {x \\<in> space R_G.St.\n            (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n          \\<le> emeasure (MDP.T i)\n                 {x \\<in> space MDP.St.\n                  (holds \\<phi> suntil holds \\<psi>) (s ## x)}", "from \\<open>?cfg'\\<in> R_G.valid_cfg\\<close>"], ["proof (chain)\npicking this:\n  absc cfg \\<in> R_G.valid_cfg", "have alw_\\<S>: \"almost_everywhere (R_G.T ?cfg') (pred_stream (\\<lambda>s. s \\<in> \\<S>))\""], ["proof (prove)\nusing this:\n  absc cfg \\<in> R_G.valid_cfg\n\ngoal (1 subgoal):\n 1. almost_everywhere (R_G.T (absc cfg))\n     (pred_stream (\\<lambda>s. s \\<in> \\<S>))", "by (rule R_G.alw_S)"], ["proof (state)\nthis:\n  almost_everywhere (R_G.T (absc cfg))\n   (pred_stream (\\<lambda>s. s \\<in> \\<S>))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<in> MDP.cfg_on s \\<Longrightarrow>\n       \\<exists>j\\<in>R_G.cfg_on s'.\n          emeasure (MDP.T i)\n           {x \\<in> space MDP.St.\n            (holds \\<phi> suntil holds \\<psi>) (s ## x)}\n          \\<le> emeasure (R_G.T j)\n                 {x \\<in> space R_G.St.\n                  (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n 2. \\<And>j.\n       j \\<in> R_G.cfg_on s' \\<Longrightarrow>\n       \\<exists>i\\<in>MDP.cfg_on s.\n          emeasure (R_G.T j)\n           {x \\<in> space R_G.St.\n            (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n          \\<le> emeasure (MDP.T i)\n                 {x \\<in> space MDP.St.\n                  (holds \\<phi> suntil holds \\<psi>) (s ## x)}", "have \"emeasure (MDP.T cfg) {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>) (s ## x)}\n       = emeasure (R_G.T ?cfg') {x \\<in> space R_G.St. (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (MDP.T cfg)\n     {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>) (s ## x)} =\n    emeasure (R_G.T (absc cfg))\n     {x \\<in> space R_G.St. (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}", "apply (rule path_measure_eq_absc1_new[symmetric, where P = \"pred_stream (\\<lambda> s. s \\<in> \\<S>)\"\n          and Q = \"pred_stream (\\<lambda> s. s \\<in> S)\"]\n        )"], ["proof (prove)\ngoal (9 subgoals):\n 1. cfg \\<in> MDP.valid_cfg\n 2. {x \\<in> space R_G.St. (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n    \\<in> sets R_G.St\n 3. {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>) (s ## x)}\n    \\<in> sets MDP.St\n 4. almost_everywhere (R_G.T (absc cfg))\n     (pred_stream (\\<lambda>s. s \\<in> \\<S>))\n 5. almost_everywhere (MDP.T cfg) (pred_stream (\\<lambda>s. s \\<in> S))\n 6. Measurable.pred R_G.St (pred_stream (\\<lambda>s. s \\<in> \\<S>))\n 7. Measurable.pred MDP.St (pred_stream (\\<lambda>s. s \\<in> S))\n 8. \\<And>x y.\n       \\<lbrakk>pred_stream (\\<lambda>s. s \\<in> \\<S>) x; smap abss y = x;\n        x \\<in> {x \\<in> space R_G.St.\n                 (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\\<rbrakk>\n       \\<Longrightarrow> y \\<in> {x \\<in> space MDP.St.\n                                  (holds \\<phi> suntil holds \\<psi>)\n                                   (s ## x)} \\<and>\n                         pred_stream (\\<lambda>s. s \\<in> S) y\n 9. \\<And>x y.\n       \\<lbrakk>pred_stream (\\<lambda>s. s \\<in> S) y; smap abss y = x;\n        y \\<in> {x \\<in> space MDP.St.\n                 (holds \\<phi> suntil holds \\<psi>) (s ## x)}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {x \\<in> space R_G.St.\n                                  (holds \\<phi>' suntil holds \\<psi>')\n                                   (s' ## x)} \\<and>\n                         pred_stream (\\<lambda>s. s \\<in> \\<S>) x", "using prems alw_S alw_\\<S>"], ["proof (prove)\nusing this:\n  cfg \\<in> MDP.cfg_on s\n  almost_everywhere (MDP.T cfg) (pred_stream (\\<lambda>s. s \\<in> S))\n  almost_everywhere (R_G.T (absc cfg))\n   (pred_stream (\\<lambda>s. s \\<in> \\<S>))\n\ngoal (9 subgoals):\n 1. cfg \\<in> MDP.valid_cfg\n 2. {x \\<in> space R_G.St. (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n    \\<in> sets R_G.St\n 3. {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>) (s ## x)}\n    \\<in> sets MDP.St\n 4. almost_everywhere (R_G.T (absc cfg))\n     (pred_stream (\\<lambda>s. s \\<in> \\<S>))\n 5. almost_everywhere (MDP.T cfg) (pred_stream (\\<lambda>s. s \\<in> S))\n 6. Measurable.pred R_G.St (pred_stream (\\<lambda>s. s \\<in> \\<S>))\n 7. Measurable.pred MDP.St (pred_stream (\\<lambda>s. s \\<in> S))\n 8. \\<And>x y.\n       \\<lbrakk>pred_stream (\\<lambda>s. s \\<in> \\<S>) x; smap abss y = x;\n        x \\<in> {x \\<in> space R_G.St.\n                 (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\\<rbrakk>\n       \\<Longrightarrow> y \\<in> {x \\<in> space MDP.St.\n                                  (holds \\<phi> suntil holds \\<psi>)\n                                   (s ## x)} \\<and>\n                         pred_stream (\\<lambda>s. s \\<in> S) y\n 9. \\<And>x y.\n       \\<lbrakk>pred_stream (\\<lambda>s. s \\<in> S) y; smap abss y = x;\n        y \\<in> {x \\<in> space MDP.St.\n                 (holds \\<phi> suntil holds \\<psi>) (s ## x)}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {x \\<in> space R_G.St.\n                                  (holds \\<phi>' suntil holds \\<psi>')\n                                   (s' ## x)} \\<and>\n                         pred_stream (\\<lambda>s. s \\<in> \\<S>) x", "apply (auto intro: MDP.valid_cfgI simp: )[7]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>pred_stream (\\<lambda>s. s \\<in> \\<S>) x; smap abss y = x;\n        x \\<in> {x \\<in> space R_G.St.\n                 (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\\<rbrakk>\n       \\<Longrightarrow> y \\<in> {x \\<in> space MDP.St.\n                                  (holds \\<phi> suntil holds \\<psi>)\n                                   (s ## x)} \\<and>\n                         pred_stream (\\<lambda>s. s \\<in> S) y\n 2. \\<And>x y.\n       \\<lbrakk>pred_stream (\\<lambda>s. s \\<in> S) y; smap abss y = x;\n        y \\<in> {x \\<in> space MDP.St.\n                 (holds \\<phi> suntil holds \\<psi>) (s ## x)}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {x \\<in> space R_G.St.\n                                  (holds \\<phi>' suntil holds \\<psi>')\n                                   (s' ## x)} \\<and>\n                         pred_stream (\\<lambda>s. s \\<in> \\<S>) x", "by (auto simp: S_abss_\\<S> intro: \\<S>_abss_S intro!: suntil_abss suntil_reps, measurable)"], ["proof (state)\nthis:\n  emeasure (MDP.T cfg)\n   {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>) (s ## x)} =\n  emeasure (R_G.T (absc cfg))\n   {x \\<in> space R_G.St. (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<in> MDP.cfg_on s \\<Longrightarrow>\n       \\<exists>j\\<in>R_G.cfg_on s'.\n          emeasure (MDP.T i)\n           {x \\<in> space MDP.St.\n            (holds \\<phi> suntil holds \\<psi>) (s ## x)}\n          \\<le> emeasure (R_G.T j)\n                 {x \\<in> space R_G.St.\n                  (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n 2. \\<And>j.\n       j \\<in> R_G.cfg_on s' \\<Longrightarrow>\n       \\<exists>i\\<in>MDP.cfg_on s.\n          emeasure (R_G.T j)\n           {x \\<in> space R_G.St.\n            (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n          \\<le> emeasure (MDP.T i)\n                 {x \\<in> space MDP.St.\n                  (holds \\<phi> suntil holds \\<psi>) (s ## x)}", "with prems"], ["proof (chain)\npicking this:\n  cfg \\<in> MDP.cfg_on s\n  emeasure (MDP.T cfg)\n   {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>) (s ## x)} =\n  emeasure (R_G.T (absc cfg))\n   {x \\<in> space R_G.St. (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}", "show ?case"], ["proof (prove)\nusing this:\n  cfg \\<in> MDP.cfg_on s\n  emeasure (MDP.T cfg)\n   {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>) (s ## x)} =\n  emeasure (R_G.T (absc cfg))\n   {x \\<in> space R_G.St. (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<in>R_G.cfg_on s'.\n       emeasure (MDP.T cfg)\n        {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>) (s ## x)}\n       \\<le> emeasure (R_G.T j)\n              {x \\<in> space R_G.St.\n               (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}", "by (inst_existentials ?cfg') auto"], ["proof (state)\nthis:\n  \\<exists>j\\<in>R_G.cfg_on s'.\n     emeasure (MDP.T cfg)\n      {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>) (s ## x)}\n     \\<le> emeasure (R_G.T j)\n            {x \\<in> space R_G.St.\n             (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> R_G.cfg_on s' \\<Longrightarrow>\n       \\<exists>i\\<in>MDP.cfg_on s.\n          emeasure (R_G.T j)\n           {x \\<in> space R_G.St.\n            (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n          \\<le> emeasure (MDP.T i)\n                 {x \\<in> space MDP.St.\n                  (holds \\<phi> suntil holds \\<psi>) (s ## x)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> R_G.cfg_on s' \\<Longrightarrow>\n       \\<exists>i\\<in>MDP.cfg_on s.\n          emeasure (R_G.T j)\n           {x \\<in> space R_G.St.\n            (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n          \\<le> emeasure (MDP.T i)\n                 {x \\<in> space MDP.St.\n                  (holds \\<phi> suntil holds \\<psi>) (s ## x)}", "case prems: (2 cfg)"], ["proof (state)\nthis:\n  cfg \\<in> R_G.cfg_on s'\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> R_G.cfg_on s' \\<Longrightarrow>\n       \\<exists>i\\<in>MDP.cfg_on s.\n          emeasure (R_G.T j)\n           {x \\<in> space R_G.St.\n            (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n          \\<le> emeasure (MDP.T i)\n                 {x \\<in> space MDP.St.\n                  (holds \\<phi> suntil holds \\<psi>) (s ## x)}", "let ?cfg' = \"repcs s cfg\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> R_G.cfg_on s' \\<Longrightarrow>\n       \\<exists>i\\<in>MDP.cfg_on s.\n          emeasure (R_G.T j)\n           {x \\<in> space R_G.St.\n            (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n          \\<le> emeasure (MDP.T i)\n                 {x \\<in> space MDP.St.\n                  (holds \\<phi> suntil holds \\<psi>) (s ## x)}", "have \"s = state ?cfg'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = state (repcs s cfg)", "by simp"], ["proof (state)\nthis:\n  s = state (repcs s cfg)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> R_G.cfg_on s' \\<Longrightarrow>\n       \\<exists>i\\<in>MDP.cfg_on s.\n          emeasure (R_G.T j)\n           {x \\<in> space R_G.St.\n            (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n          \\<le> emeasure (MDP.T i)\n                 {x \\<in> space MDP.St.\n                  (holds \\<phi> suntil holds \\<psi>) (s ## x)}", "from prems"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.cfg_on s'", "have \"s' = state cfg\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.cfg_on s'\n\ngoal (1 subgoal):\n 1. s' = state cfg", "by auto"], ["proof (state)\nthis:\n  s' = state cfg\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> R_G.cfg_on s' \\<Longrightarrow>\n       \\<exists>i\\<in>MDP.cfg_on s.\n          emeasure (R_G.T j)\n           {x \\<in> space R_G.St.\n            (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n          \\<le> emeasure (MDP.T i)\n                 {x \\<in> space MDP.St.\n                  (holds \\<phi> suntil holds \\<psi>) (s ## x)}", "have \"pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s) (state (repcs s cfg) ## x)\"\n    if \"pred_stream (\\<lambda>s. s \\<in> S) x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s)\n     (state (repcs s cfg) ## x)", "using prems that"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.cfg_on s'\n  pred_stream (\\<lambda>s. s \\<in> S) x\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s)\n     (state (repcs s cfg) ## x)", "by (intro \\<phi>_stream) auto"], ["proof (state)\nthis:\n  pred_stream (\\<lambda>s. s \\<in> S) ?x5 \\<Longrightarrow>\n  pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s)\n   (state (repcs s cfg) ## ?x5)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> R_G.cfg_on s' \\<Longrightarrow>\n       \\<exists>i\\<in>MDP.cfg_on s.\n          emeasure (R_G.T j)\n           {x \\<in> space R_G.St.\n            (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n          \\<le> emeasure (MDP.T i)\n                 {x \\<in> space MDP.St.\n                  (holds \\<phi> suntil holds \\<psi>) (s ## x)}", "moreover"], ["proof (state)\nthis:\n  pred_stream (\\<lambda>s. s \\<in> S) ?x5 \\<Longrightarrow>\n  pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s)\n   (state (repcs s cfg) ## ?x5)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> R_G.cfg_on s' \\<Longrightarrow>\n       \\<exists>i\\<in>MDP.cfg_on s.\n          emeasure (R_G.T j)\n           {x \\<in> space R_G.St.\n            (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n          \\<le> emeasure (MDP.T i)\n                 {x \\<in> space MDP.St.\n                  (holds \\<phi> suntil holds \\<psi>) (s ## x)}", "have \"pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s) (state (repcs s cfg) ## x)\"\n    if \"pred_stream (\\<lambda>s. s \\<in> S) x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s)\n     (state (repcs s cfg) ## x)", "using prems that"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.cfg_on s'\n  pred_stream (\\<lambda>s. s \\<in> S) x\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s)\n     (state (repcs s cfg) ## x)", "by (intro \\<psi>_stream) auto"], ["proof (state)\nthis:\n  pred_stream (\\<lambda>s. s \\<in> S) ?x5 \\<Longrightarrow>\n  pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s)\n   (state (repcs s cfg) ## ?x5)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> R_G.cfg_on s' \\<Longrightarrow>\n       \\<exists>i\\<in>MDP.cfg_on s.\n          emeasure (R_G.T j)\n           {x \\<in> space R_G.St.\n            (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n          \\<le> emeasure (MDP.T i)\n                 {x \\<in> space MDP.St.\n                  (holds \\<phi> suntil holds \\<psi>) (s ## x)}", "ultimately"], ["proof (chain)\npicking this:\n  pred_stream (\\<lambda>s. s \\<in> S) ?x5 \\<Longrightarrow>\n  pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s)\n   (state (repcs s cfg) ## ?x5)\n  pred_stream (\\<lambda>s. s \\<in> S) ?x5 \\<Longrightarrow>\n  pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s)\n   (state (repcs s cfg) ## ?x5)", "have \"emeasure (R_G.T cfg) {x \\<in> space R_G.St. (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n    = emeasure (MDP.T (repcs s cfg)) {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>) (s ## x)}\""], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>s. s \\<in> S) ?x5 \\<Longrightarrow>\n  pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s)\n   (state (repcs s cfg) ## ?x5)\n  pred_stream (\\<lambda>s. s \\<in> S) ?x5 \\<Longrightarrow>\n  pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s)\n   (state (repcs s cfg) ## ?x5)\n\ngoal (1 subgoal):\n 1. emeasure (R_G.T cfg)\n     {x \\<in> space R_G.St.\n      (holds \\<phi>' suntil holds \\<psi>') (s' ## x)} =\n    emeasure (MDP.T (repcs s cfg))\n     {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>) (s ## x)}", "apply (rewrite in \"s ## _\" \\<open>s = _\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                pred_stream (\\<lambda>s. s \\<in> S) x \\<Longrightarrow>\n                pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s)\n                 (state (repcs s cfg) ## x);\n     \\<And>x.\n        pred_stream (\\<lambda>s. s \\<in> S) x \\<Longrightarrow>\n        pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s)\n         (state (repcs s cfg) ## x)\\<rbrakk>\n    \\<Longrightarrow> emeasure (R_G.T cfg)\n                       {x \\<in> space R_G.St.\n                        (holds \\<phi>' suntil holds \\<psi>') (s' ## x)} =\n                      emeasure (MDP.T (repcs s cfg))\n                       {x \\<in> space MDP.St.\n                        (holds \\<phi> suntil holds \\<psi>)\n                         (state (repcs s cfg) ## x)}", "apply (subst \\<open>s' = _\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                pred_stream (\\<lambda>s. s \\<in> S) x \\<Longrightarrow>\n                pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s)\n                 (state (repcs s cfg) ## x);\n     \\<And>x.\n        pred_stream (\\<lambda>s. s \\<in> S) x \\<Longrightarrow>\n        pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s)\n         (state (repcs s cfg) ## x)\\<rbrakk>\n    \\<Longrightarrow> emeasure (R_G.T cfg)\n                       {x \\<in> space R_G.St.\n                        (holds \\<phi>' suntil holds \\<psi>')\n                         (state cfg ## x)} =\n                      emeasure (MDP.T (repcs s cfg))\n                       {x \\<in> space MDP.St.\n                        (holds \\<phi> suntil holds \\<psi>)\n                         (state (repcs s cfg) ## x)}", "unfolding \\<phi>'_def \\<psi>'_def s'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                pred_stream (\\<lambda>s. s \\<in> S) x \\<Longrightarrow>\n                pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s)\n                 (state (repcs s cfg) ## x);\n     \\<And>x.\n        pred_stream (\\<lambda>s. s \\<in> S) x \\<Longrightarrow>\n        pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s)\n         (state (repcs s cfg) ## x)\\<rbrakk>\n    \\<Longrightarrow> emeasure (R_G.T cfg)\n                       {x \\<in> space R_G.St.\n                        (holds (absp \\<phi>) suntil holds (absp \\<psi>))\n                         (state cfg ## x)} =\n                      emeasure (MDP.T (repcs s cfg))\n                       {x \\<in> space MDP.St.\n                        (holds \\<phi> suntil holds \\<psi>)\n                         (state (repcs s cfg) ## x)}", "apply (rule path_measure_eq_repcs''_new)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                pred_stream (\\<lambda>s. s \\<in> S) x \\<Longrightarrow>\n                pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s)\n                 (state (repcs s cfg) ## x);\n     \\<And>x.\n        pred_stream (\\<lambda>s. s \\<in> S) x \\<Longrightarrow>\n        pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s)\n         (state (repcs s cfg) ## x)\\<rbrakk>\n    \\<Longrightarrow> abss s = state cfg\n 2. \\<lbrakk>\\<And>x.\n                pred_stream (\\<lambda>s. s \\<in> S) x \\<Longrightarrow>\n                pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s)\n                 (state (repcs s cfg) ## x);\n     \\<And>x.\n        pred_stream (\\<lambda>s. s \\<in> S) x \\<Longrightarrow>\n        pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s)\n         (state (repcs s cfg) ## x)\\<rbrakk>\n    \\<Longrightarrow> cfg \\<in> R_G.valid_cfg\n 3. \\<lbrakk>\\<And>x.\n                pred_stream (\\<lambda>s. s \\<in> S) x \\<Longrightarrow>\n                pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s)\n                 (state (repcs s cfg) ## x);\n     \\<And>x.\n        pred_stream (\\<lambda>s. s \\<in> S) x \\<Longrightarrow>\n        pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s)\n         (state (repcs s cfg) ## x)\\<rbrakk>\n    \\<Longrightarrow> repcs s cfg \\<in> MDP.valid_cfg\n 4. \\<And>x.\n       \\<lbrakk>\\<And>x.\n                   pred_stream (\\<lambda>s. s \\<in> S) x \\<Longrightarrow>\n                   pred_stream\n                    (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s)\n                    (state (repcs s cfg) ## x);\n        \\<And>x.\n           pred_stream (\\<lambda>s. s \\<in> S) x \\<Longrightarrow>\n           pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s)\n            (state (repcs s cfg) ## x);\n        pred_stream (\\<lambda>s. s \\<in> S) x\\<rbrakk>\n       \\<Longrightarrow> pred_stream\n                          (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s)\n                          (state (repcs s cfg) ## x)\n 5. \\<And>x.\n       \\<lbrakk>\\<And>x.\n                   pred_stream (\\<lambda>s. s \\<in> S) x \\<Longrightarrow>\n                   pred_stream\n                    (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s)\n                    (state (repcs s cfg) ## x);\n        \\<And>x.\n           pred_stream (\\<lambda>s. s \\<in> S) x \\<Longrightarrow>\n           pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s)\n            (state (repcs s cfg) ## x);\n        pred_stream (\\<lambda>s. s \\<in> S) x\\<rbrakk>\n       \\<Longrightarrow> pred_stream\n                          (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s)\n                          (state (repcs s cfg) ## x)", "using prems"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.cfg_on s'\n\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                pred_stream (\\<lambda>s. s \\<in> S) x \\<Longrightarrow>\n                pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s)\n                 (state (repcs s cfg) ## x);\n     \\<And>x.\n        pred_stream (\\<lambda>s. s \\<in> S) x \\<Longrightarrow>\n        pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s)\n         (state (repcs s cfg) ## x)\\<rbrakk>\n    \\<Longrightarrow> abss s = state cfg\n 2. \\<lbrakk>\\<And>x.\n                pred_stream (\\<lambda>s. s \\<in> S) x \\<Longrightarrow>\n                pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s)\n                 (state (repcs s cfg) ## x);\n     \\<And>x.\n        pred_stream (\\<lambda>s. s \\<in> S) x \\<Longrightarrow>\n        pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s)\n         (state (repcs s cfg) ## x)\\<rbrakk>\n    \\<Longrightarrow> cfg \\<in> R_G.valid_cfg\n 3. \\<lbrakk>\\<And>x.\n                pred_stream (\\<lambda>s. s \\<in> S) x \\<Longrightarrow>\n                pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s)\n                 (state (repcs s cfg) ## x);\n     \\<And>x.\n        pred_stream (\\<lambda>s. s \\<in> S) x \\<Longrightarrow>\n        pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s)\n         (state (repcs s cfg) ## x)\\<rbrakk>\n    \\<Longrightarrow> repcs s cfg \\<in> MDP.valid_cfg\n 4. \\<And>x.\n       \\<lbrakk>\\<And>x.\n                   pred_stream (\\<lambda>s. s \\<in> S) x \\<Longrightarrow>\n                   pred_stream\n                    (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s)\n                    (state (repcs s cfg) ## x);\n        \\<And>x.\n           pred_stream (\\<lambda>s. s \\<in> S) x \\<Longrightarrow>\n           pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s)\n            (state (repcs s cfg) ## x);\n        pred_stream (\\<lambda>s. s \\<in> S) x\\<rbrakk>\n       \\<Longrightarrow> pred_stream\n                          (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s)\n                          (state (repcs s cfg) ## x)\n 5. \\<And>x.\n       \\<lbrakk>\\<And>x.\n                   pred_stream (\\<lambda>s. s \\<in> S) x \\<Longrightarrow>\n                   pred_stream\n                    (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s)\n                    (state (repcs s cfg) ## x);\n        \\<And>x.\n           pred_stream (\\<lambda>s. s \\<in> S) x \\<Longrightarrow>\n           pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s)\n            (state (repcs s cfg) ## x);\n        pred_stream (\\<lambda>s. s \\<in> S) x\\<rbrakk>\n       \\<Longrightarrow> pred_stream\n                          (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s)\n                          (state (repcs s cfg) ## x)", "by (auto 4 3 simp: s'_def intro: R_G.valid_cfgI MDP.valid_cfgI)"], ["proof (state)\nthis:\n  emeasure (R_G.T cfg)\n   {x \\<in> space R_G.St. (holds \\<phi>' suntil holds \\<psi>') (s' ## x)} =\n  emeasure (MDP.T (repcs s cfg))\n   {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>) (s ## x)}\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> R_G.cfg_on s' \\<Longrightarrow>\n       \\<exists>i\\<in>MDP.cfg_on s.\n          emeasure (R_G.T j)\n           {x \\<in> space R_G.St.\n            (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n          \\<le> emeasure (MDP.T i)\n                 {x \\<in> space MDP.St.\n                  (holds \\<phi> suntil holds \\<psi>) (s ## x)}", "with prems"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.cfg_on s'\n  emeasure (R_G.T cfg)\n   {x \\<in> space R_G.St. (holds \\<phi>' suntil holds \\<psi>') (s' ## x)} =\n  emeasure (MDP.T (repcs s cfg))\n   {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>) (s ## x)}", "show ?case"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.cfg_on s'\n  emeasure (R_G.T cfg)\n   {x \\<in> space R_G.St. (holds \\<phi>' suntil holds \\<psi>') (s' ## x)} =\n  emeasure (MDP.T (repcs s cfg))\n   {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>) (s ## x)}\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<in>MDP.cfg_on s.\n       emeasure (R_G.T cfg)\n        {x \\<in> space R_G.St.\n         (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n       \\<le> emeasure (MDP.T i)\n              {x \\<in> space MDP.St.\n               (holds \\<phi> suntil holds \\<psi>) (s ## x)}", "by (inst_existentials ?cfg') auto"], ["proof (state)\nthis:\n  \\<exists>i\\<in>MDP.cfg_on s.\n     emeasure (R_G.T cfg)\n      {x \\<in> space R_G.St. (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n     \\<le> emeasure (MDP.T i)\n            {x \\<in> space MDP.St.\n             (holds \\<phi> suntil holds \\<psi>) (s ## x)}\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* PTA Reachability Problem *)"], ["", "subsection \\<open>Divergent Adversaries\\<close>"], ["", "context Probabilistic_Timed_Automaton\nbegin"], ["", "definition \"elapsed u u' \\<equiv> Max ({u' c - u c | c. c \\<in> \\<X>} \\<union> {0})\""], ["", "definition \"eq_elapsed u u' \\<equiv> elapsed u u' > 0 \\<longrightarrow> (\\<forall> c \\<in> \\<X>. u' c - u c = elapsed u u')\""], ["", "fun dur :: \"('c, t) cval stream \\<Rightarrow> nat \\<Rightarrow> t\" where\n    \"dur _ 0 = 0\" |\n    \"dur (x ## y ## xs) (Suc i) = elapsed x y + dur (y ## xs) i\""], ["", "definition \"divergent \\<omega> \\<equiv> \\<forall> t. \\<exists> n. dur \\<omega> n > t\""], ["", "definition \"div_cfg cfg \\<equiv> AE \\<omega> in MDP.MC.T cfg. divergent (smap (snd o state) \\<omega>)\""], ["", "definition \"\\<R>_div \\<omega> \\<equiv>\n    \\<forall>x \\<in> \\<X>. (\\<forall> i. (\\<exists> j \\<ge> i. zero x (\\<omega> !! j)) \\<and> (\\<exists> j \\<ge> i. \\<not> zero x (\\<omega> !! j)))\n      \\<or> (\\<exists> i. \\<forall> j \\<ge> i. unbounded x (\\<omega> !! j))\""], ["", "definition \"R_G_div_cfg cfg \\<equiv> AE \\<omega> in MDP.MC.T cfg. \\<R>_div (smap (snd o state) \\<omega>)\""], ["", "end"], ["", "context Probabilistic_Timed_Automaton_Regions\nbegin"], ["", "definition \"cfg_on_div st \\<equiv> MDP.cfg_on st \\<inter> {cfg. div_cfg cfg}\""], ["", "definition \"R_G_cfg_on_div st \\<equiv> R_G.cfg_on st \\<inter> {cfg. R_G_div_cfg cfg}\""], ["", "lemma measurable_\\<R>_div[measurable]: \"Measurable.pred MDP.MC.S \\<R>_div\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Measurable.pred (stream_space (count_space UNIV)) \\<R>_div", "unfolding \\<R>_div_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>\\<omega>.\n         \\<forall>x\\<in>\\<X>.\n            (\\<forall>i.\n                (\\<exists>j\\<ge>i. zero x (\\<omega> !! j)) \\<and>\n                (\\<exists>j\\<ge>i. \\<not> zero x (\\<omega> !! j))) \\<or>\n            (\\<exists>i. \\<forall>j\\<ge>i. unbounded x (\\<omega> !! j)))", "by (intro\n        pred_intros_finite[OF beta_interp.finite]\n        pred_intros_logic pred_intros_countable\n        measurable_count_space_const measurable_compose[OF measurable_snth]\n     ) measurable"], ["", "lemma elapsed_ge0[simp]: \"elapsed x y \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> elapsed x y", "unfolding elapsed_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> Max ({y c - x c |c. c \\<in> \\<X>} \\<union> {0::'a})", "using finite(1)"], ["proof (prove)\nusing this:\n  finite \\<X>\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> Max ({y c - x c |c. c \\<in> \\<X>} \\<union> {0::'a})", "by auto"], ["", "lemma dur_pos:\n  \"dur xs i \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> dur xs i", "apply (induction i arbitrary: xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs. 0 \\<le> dur xs 0\n 2. \\<And>i xs.\n       (\\<And>xs. 0 \\<le> dur xs i) \\<Longrightarrow> 0 \\<le> dur xs (Suc i)", "apply (auto; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i xs.\n       (\\<And>xs. 0 \\<le> dur xs i) \\<Longrightarrow> 0 \\<le> dur xs (Suc i)", "subgoal for i xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs. 0 \\<le> dur xs i) \\<Longrightarrow> 0 \\<le> dur xs (Suc i)", "apply (subst stream.collapse[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs. 0 \\<le> dur xs i) \\<Longrightarrow>\n    0 \\<le> dur (shd xs ## stl xs) (Suc i)", "apply (rewrite at \"stl xs\" stream.collapse[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs. 0 \\<le> dur xs i) \\<Longrightarrow>\n    0 \\<le> dur (shd xs ## shd (stl xs) ## stl (stl xs)) (Suc i)", "apply (subst dur.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs. 0 \\<le> dur xs i) \\<Longrightarrow>\n    0 \\<le> elapsed (shd xs) (shd (stl xs)) +\n            dur (shd (stl xs) ## stl (stl xs)) i", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dur_mono:\n  \"i \\<le> j \\<Longrightarrow> dur xs i \\<le> dur xs j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow> dur xs i \\<le> dur xs j", "proof (induction i arbitrary: xs j)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs j. 0 \\<le> j \\<Longrightarrow> dur xs 0 \\<le> dur xs j\n 2. \\<And>i xs j.\n       \\<lbrakk>\\<And>xs j.\n                   i \\<le> j \\<Longrightarrow> dur xs i \\<le> dur xs j;\n        Suc i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> dur xs (Suc i) \\<le> dur xs j", "case 0"], ["proof (state)\nthis:\n  0 \\<le> j\n\ngoal (2 subgoals):\n 1. \\<And>xs j. 0 \\<le> j \\<Longrightarrow> dur xs 0 \\<le> dur xs j\n 2. \\<And>i xs j.\n       \\<lbrakk>\\<And>xs j.\n                   i \\<le> j \\<Longrightarrow> dur xs i \\<le> dur xs j;\n        Suc i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> dur xs (Suc i) \\<le> dur xs j", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. dur xs 0 \\<le> dur xs j", "by (auto intro: dur_pos)"], ["proof (state)\nthis:\n  dur xs 0 \\<le> dur xs j\n\ngoal (1 subgoal):\n 1. \\<And>i xs j.\n       \\<lbrakk>\\<And>xs j.\n                   i \\<le> j \\<Longrightarrow> dur xs i \\<le> dur xs j;\n        Suc i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> dur xs (Suc i) \\<le> dur xs j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i xs j.\n       \\<lbrakk>\\<And>xs j.\n                   i \\<le> j \\<Longrightarrow> dur xs i \\<le> dur xs j;\n        Suc i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> dur xs (Suc i) \\<le> dur xs j", "case (Suc i xs j)"], ["proof (state)\nthis:\n  i \\<le> ?j6 \\<Longrightarrow> dur ?xs6 i \\<le> dur ?xs6 ?j6\n  Suc i \\<le> j\n\ngoal (1 subgoal):\n 1. \\<And>i xs j.\n       \\<lbrakk>\\<And>xs j.\n                   i \\<le> j \\<Longrightarrow> dur xs i \\<le> dur xs j;\n        Suc i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> dur xs (Suc i) \\<le> dur xs j", "obtain x y ys where xs: \"xs = x ## y ## ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y ys.\n        xs = x ## y ## ys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using stream.collapse"], ["proof (prove)\nusing this:\n  shd ?stream ## stl ?stream = ?stream\n\ngoal (1 subgoal):\n 1. (\\<And>x y ys.\n        xs = x ## y ## ys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  xs = x ## y ## ys\n\ngoal (1 subgoal):\n 1. \\<And>i xs j.\n       \\<lbrakk>\\<And>xs j.\n                   i \\<le> j \\<Longrightarrow> dur xs i \\<le> dur xs j;\n        Suc i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> dur xs (Suc i) \\<le> dur xs j", "from Suc"], ["proof (chain)\npicking this:\n  i \\<le> ?j6 \\<Longrightarrow> dur ?xs6 i \\<le> dur ?xs6 ?j6\n  Suc i \\<le> j", "obtain j' where j': \"j = Suc j'\""], ["proof (prove)\nusing this:\n  i \\<le> ?j6 \\<Longrightarrow> dur ?xs6 i \\<le> dur ?xs6 ?j6\n  Suc i \\<le> j\n\ngoal (1 subgoal):\n 1. (\\<And>j'. j = Suc j' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases j) auto"], ["proof (state)\nthis:\n  j = Suc j'\n\ngoal (1 subgoal):\n 1. \\<And>i xs j.\n       \\<lbrakk>\\<And>xs j.\n                   i \\<le> j \\<Longrightarrow> dur xs i \\<le> dur xs j;\n        Suc i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> dur xs (Suc i) \\<le> dur xs j", "with xs"], ["proof (chain)\npicking this:\n  xs = x ## y ## ys\n  j = Suc j'", "have \"dur xs j = elapsed x y + dur (y ## ys) j'\""], ["proof (prove)\nusing this:\n  xs = x ## y ## ys\n  j = Suc j'\n\ngoal (1 subgoal):\n 1. dur xs j = elapsed x y + dur (y ## ys) j'", "by auto"], ["proof (state)\nthis:\n  dur xs j = elapsed x y + dur (y ## ys) j'\n\ngoal (1 subgoal):\n 1. \\<And>i xs j.\n       \\<lbrakk>\\<And>xs j.\n                   i \\<le> j \\<Longrightarrow> dur xs i \\<le> dur xs j;\n        Suc i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> dur xs (Suc i) \\<le> dur xs j", "also"], ["proof (state)\nthis:\n  dur xs j = elapsed x y + dur (y ## ys) j'\n\ngoal (1 subgoal):\n 1. \\<And>i xs j.\n       \\<lbrakk>\\<And>xs j.\n                   i \\<le> j \\<Longrightarrow> dur xs i \\<le> dur xs j;\n        Suc i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> dur xs (Suc i) \\<le> dur xs j", "from Suc j'"], ["proof (chain)\npicking this:\n  i \\<le> ?j6 \\<Longrightarrow> dur ?xs6 i \\<le> dur ?xs6 ?j6\n  Suc i \\<le> j\n  j = Suc j'", "have \"\\<dots> \\<ge> elapsed x y + dur (y ## ys) i\""], ["proof (prove)\nusing this:\n  i \\<le> ?j6 \\<Longrightarrow> dur ?xs6 i \\<le> dur ?xs6 ?j6\n  Suc i \\<le> j\n  j = Suc j'\n\ngoal (1 subgoal):\n 1. elapsed x y + dur (y ## ys) i \\<le> elapsed x y + dur (y ## ys) j'", "by auto"], ["proof (state)\nthis:\n  elapsed x y + dur (y ## ys) i \\<le> elapsed x y + dur (y ## ys) j'\n\ngoal (1 subgoal):\n 1. \\<And>i xs j.\n       \\<lbrakk>\\<And>xs j.\n                   i \\<le> j \\<Longrightarrow> dur xs i \\<le> dur xs j;\n        Suc i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> dur xs (Suc i) \\<le> dur xs j", "also"], ["proof (state)\nthis:\n  elapsed x y + dur (y ## ys) i \\<le> elapsed x y + dur (y ## ys) j'\n\ngoal (1 subgoal):\n 1. \\<And>i xs j.\n       \\<lbrakk>\\<And>xs j.\n                   i \\<le> j \\<Longrightarrow> dur xs i \\<le> dur xs j;\n        Suc i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> dur xs (Suc i) \\<le> dur xs j", "have \"elapsed x y + dur (y ## ys) i = dur xs (Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elapsed x y + dur (y ## ys) i = dur xs (Suc i)", "by (simp add: xs)"], ["proof (state)\nthis:\n  elapsed x y + dur (y ## ys) i = dur xs (Suc i)\n\ngoal (1 subgoal):\n 1. \\<And>i xs j.\n       \\<lbrakk>\\<And>xs j.\n                   i \\<le> j \\<Longrightarrow> dur xs i \\<le> dur xs j;\n        Suc i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> dur xs (Suc i) \\<le> dur xs j", "finally"], ["proof (chain)\npicking this:\n  dur xs (Suc i) \\<le> dur xs j", "show ?case"], ["proof (prove)\nusing this:\n  dur xs (Suc i) \\<le> dur xs j\n\ngoal (1 subgoal):\n 1. dur xs (Suc i) \\<le> dur xs j", "."], ["proof (state)\nthis:\n  dur xs (Suc i) \\<le> dur xs j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dur_monoD:\n  assumes \"dur xs i < dur xs j\"\n  shows \"i < j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < j", "using assms"], ["proof (prove)\nusing this:\n  dur xs i < dur xs j\n\ngoal (1 subgoal):\n 1. i < j", "by - (rule ccontr; auto 4 4 dest: leI dur_mono[where xs = xs])"], ["", "lemma elapsed_0D:\n  assumes \"c \\<in> \\<X>\" \"elapsed u u' \\<le> 0\"\n  shows \"u' c - u c \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u' c - u c \\<le> (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u' c - u c \\<le> (0::'a)", "from assms"], ["proof (chain)\npicking this:\n  c \\<in> \\<X>\n  elapsed u u' \\<le> (0::'a)", "have \"u' c - u c \\<in> {u' c - u c | c. c \\<in> \\<X>} \\<union> {0}\""], ["proof (prove)\nusing this:\n  c \\<in> \\<X>\n  elapsed u u' \\<le> (0::'a)\n\ngoal (1 subgoal):\n 1. u' c - u c \\<in> {u' c - u c |c. c \\<in> \\<X>} \\<union> {0::'a}", "by auto"], ["proof (state)\nthis:\n  u' c - u c \\<in> {u' c - u c |c. c \\<in> \\<X>} \\<union> {0::'a}\n\ngoal (1 subgoal):\n 1. u' c - u c \\<le> (0::'a)", "with finite(1)"], ["proof (chain)\npicking this:\n  finite \\<X>\n  u' c - u c \\<in> {u' c - u c |c. c \\<in> \\<X>} \\<union> {0::'a}", "have \"u' c - u c \\<le> Max ({u' c - u c | c. c \\<in> \\<X>} \\<union> {0})\""], ["proof (prove)\nusing this:\n  finite \\<X>\n  u' c - u c \\<in> {u' c - u c |c. c \\<in> \\<X>} \\<union> {0::'a}\n\ngoal (1 subgoal):\n 1. u' c - u c \\<le> Max ({u' c - u c |c. c \\<in> \\<X>} \\<union> {0::'a})", "by auto"], ["proof (state)\nthis:\n  u' c - u c \\<le> Max ({u' c - u c |c. c \\<in> \\<X>} \\<union> {0::'a})\n\ngoal (1 subgoal):\n 1. u' c - u c \\<le> (0::'a)", "with assms(2)"], ["proof (chain)\npicking this:\n  elapsed u u' \\<le> (0::'a)\n  u' c - u c \\<le> Max ({u' c - u c |c. c \\<in> \\<X>} \\<union> {0::'a})", "show ?thesis"], ["proof (prove)\nusing this:\n  elapsed u u' \\<le> (0::'a)\n  u' c - u c \\<le> Max ({u' c - u c |c. c \\<in> \\<X>} \\<union> {0::'a})\n\ngoal (1 subgoal):\n 1. u' c - u c \\<le> (0::'a)", "unfolding elapsed_def"], ["proof (prove)\nusing this:\n  Max ({u' c - u c |c. c \\<in> \\<X>} \\<union> {0::'a}) \\<le> (0::'a)\n  u' c - u c \\<le> Max ({u' c - u c |c. c \\<in> \\<X>} \\<union> {0::'a})\n\ngoal (1 subgoal):\n 1. u' c - u c \\<le> (0::'a)", "by auto"], ["proof (state)\nthis:\n  u' c - u c \\<le> (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma elapsed_ge:\n  assumes \"eq_elapsed u u'\" \"c \\<in> \\<X>\"\n  shows \"elapsed u u' \\<ge> u' c - u c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u' c - u c \\<le> elapsed u u'", "using assms"], ["proof (prove)\nusing this:\n  eq_elapsed u u'\n  c \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. u' c - u c \\<le> elapsed u u'", "unfolding eq_elapsed_def"], ["proof (prove)\nusing this:\n  (0::'a) < elapsed u u' \\<longrightarrow>\n  (\\<forall>c\\<in>\\<X>. u' c - u c = elapsed u u')\n  c \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. u' c - u c \\<le> elapsed u u'", "by (auto intro: elapsed_ge0 order.trans[OF elapsed_0D])"], ["", "lemma elapsed_eq:\n  assumes \"eq_elapsed u u'\" \"c \\<in> \\<X>\" \"u' c - u c \\<ge> 0\"\n  shows \"elapsed u u' = u' c - u c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elapsed u u' = u' c - u c", "using elapsed_ge[OF assms(1,2)] assms"], ["proof (prove)\nusing this:\n  u' c - u c \\<le> elapsed u u'\n  eq_elapsed u u'\n  c \\<in> \\<X>\n  (0::'a) \\<le> u' c - u c\n\ngoal (1 subgoal):\n 1. elapsed u u' = u' c - u c", "unfolding eq_elapsed_def"], ["proof (prove)\nusing this:\n  u' c - u c \\<le> elapsed u u'\n  (0::'a) < elapsed u u' \\<longrightarrow>\n  (\\<forall>c\\<in>\\<X>. u' c - u c = elapsed u u')\n  c \\<in> \\<X>\n  (0::'a) \\<le> u' c - u c\n\ngoal (1 subgoal):\n 1. elapsed u u' = u' c - u c", "by auto"], ["", "lemma dur_shift:\n  \"dur \\<omega> (i + j) = dur \\<omega> i + dur (sdrop i \\<omega>) j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dur \\<omega> (i + j) = dur \\<omega> i + dur (sdrop i \\<omega>) j", "apply (induction i arbitrary: \\<omega>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<omega>.\n       dur \\<omega> (0 + j) = dur \\<omega> 0 + dur (sdrop 0 \\<omega>) j\n 2. \\<And>i \\<omega>.\n       (\\<And>\\<omega>.\n           dur \\<omega> (i + j) =\n           dur \\<omega> i + dur (sdrop i \\<omega>) j) \\<Longrightarrow>\n       dur \\<omega> (Suc i + j) =\n       dur \\<omega> (Suc i) + dur (sdrop (Suc i) \\<omega>) j", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i \\<omega>.\n       (\\<And>\\<omega>.\n           dur \\<omega> (i + j) =\n           dur \\<omega> i + dur (sdrop i \\<omega>) j) \\<Longrightarrow>\n       dur \\<omega> (Suc i + j) =\n       dur \\<omega> (Suc i) + dur (sdrop (Suc i) \\<omega>) j", "subgoal for i \\<omega>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<omega>.\n        dur \\<omega> (i + j) =\n        dur \\<omega> i + dur (sdrop i \\<omega>) j) \\<Longrightarrow>\n    dur \\<omega> (Suc i + j) =\n    dur \\<omega> (Suc i) + dur (sdrop (Suc i) \\<omega>) j", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<omega>.\n        dur \\<omega> (i + j) =\n        dur \\<omega> i + dur (sdrop i \\<omega>) j) \\<Longrightarrow>\n    dur \\<omega> (Suc (i + j)) =\n    dur \\<omega> (Suc i) + dur (sdrop i (stl \\<omega>)) j", "apply (subst stream.collapse[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<omega>.\n        dur \\<omega> (i + j) =\n        dur \\<omega> i + dur (sdrop i \\<omega>) j) \\<Longrightarrow>\n    dur (shd \\<omega> ## stl \\<omega>) (Suc (i + j)) =\n    dur \\<omega> (Suc i) + dur (sdrop i (stl \\<omega>)) j", "apply (rewrite at \"stl \\<omega>\" stream.collapse[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<omega>.\n        dur \\<omega> (i + j) =\n        dur \\<omega> i + dur (sdrop i \\<omega>) j) \\<Longrightarrow>\n    dur (shd \\<omega> ## shd (stl \\<omega>) ## stl (stl \\<omega>))\n     (Suc (i + j)) =\n    dur \\<omega> (Suc i) + dur (sdrop i (stl \\<omega>)) j", "apply (subst dur.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<omega>.\n        dur \\<omega> (i + j) =\n        dur \\<omega> i + dur (sdrop i \\<omega>) j) \\<Longrightarrow>\n    elapsed (shd \\<omega>) (shd (stl \\<omega>)) +\n    dur (shd (stl \\<omega>) ## stl (stl \\<omega>)) (i + j) =\n    dur \\<omega> (Suc i) + dur (sdrop i (stl \\<omega>)) j", "apply (rewrite in \"dur \\<omega>\" stream.collapse[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<omega>.\n        dur \\<omega> (i + j) =\n        dur \\<omega> i + dur (sdrop i \\<omega>) j) \\<Longrightarrow>\n    elapsed (shd \\<omega>) (shd (stl \\<omega>)) +\n    dur (shd (stl \\<omega>) ## stl (stl \\<omega>)) (i + j) =\n    dur (shd \\<omega> ## stl \\<omega>) (Suc i) +\n    dur (sdrop i (stl \\<omega>)) j", "apply (rewrite in \"dur (_ ## \\<hole>) (Suc _)\" stream.collapse[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<omega>.\n        dur \\<omega> (i + j) =\n        dur \\<omega> i + dur (sdrop i \\<omega>) j) \\<Longrightarrow>\n    elapsed (shd \\<omega>) (shd (stl \\<omega>)) +\n    dur (shd (stl \\<omega>) ## stl (stl \\<omega>)) (i + j) =\n    dur (shd \\<omega> ## shd (stl \\<omega>) ## stl (stl \\<omega>)) (Suc i) +\n    dur (sdrop i (stl \\<omega>)) j", "apply (subst dur.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<omega>.\n        dur \\<omega> (i + j) =\n        dur \\<omega> i + dur (sdrop i \\<omega>) j) \\<Longrightarrow>\n    elapsed (shd \\<omega>) (shd (stl \\<omega>)) +\n    dur (shd (stl \\<omega>) ## stl (stl \\<omega>)) (i + j) =\n    elapsed (shd \\<omega>) (shd (stl \\<omega>)) +\n    dur (shd (stl \\<omega>) ## stl (stl \\<omega>)) i +\n    dur (sdrop i (stl \\<omega>)) j", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dur_zero:\n  assumes\n    \"\\<forall> i. xs !! i \\<in> \\<omega> !! i\" \"\\<forall> j \\<le> i. zero x (\\<omega> !! j)\" \"x \\<in> \\<X>\"\n    \"\\<forall> i. eq_elapsed (xs !! i) (xs !! Suc i)\"\n  shows \"dur xs i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dur xs i = 0", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>i. xs !! i \\<in> \\<omega> !! i\n  \\<forall>j\\<le>i. zero x (\\<omega> !! j)\n  x \\<in> \\<X>\n  \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\n\ngoal (1 subgoal):\n 1. dur xs i = 0", "proof (induction i arbitrary: xs \\<omega>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs \\<omega>.\n       \\<lbrakk>\\<forall>i. xs !! i \\<in> \\<omega> !! i;\n        \\<forall>j\\<le>0. zero x (\\<omega> !! j); x \\<in> \\<X>;\n        \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\\<rbrakk>\n       \\<Longrightarrow> dur xs 0 = 0\n 2. \\<And>i xs \\<omega>.\n       \\<lbrakk>\\<And>xs \\<omega>.\n                   \\<lbrakk>\\<forall>i. xs !! i \\<in> \\<omega> !! i;\n                    \\<forall>j\\<le>i. zero x (\\<omega> !! j); x \\<in> \\<X>;\n                    \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\\<rbrakk>\n                   \\<Longrightarrow> dur xs i = 0;\n        \\<forall>i. xs !! i \\<in> \\<omega> !! i;\n        \\<forall>j\\<le>Suc i. zero x (\\<omega> !! j); x \\<in> \\<X>;\n        \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\\<rbrakk>\n       \\<Longrightarrow> dur xs (Suc i) = 0", "case 0"], ["proof (state)\nthis:\n  \\<forall>i. xs !! i \\<in> \\<omega> !! i\n  \\<forall>j\\<le>0. zero x (\\<omega> !! j)\n  x \\<in> \\<X>\n  \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\n\ngoal (2 subgoals):\n 1. \\<And>xs \\<omega>.\n       \\<lbrakk>\\<forall>i. xs !! i \\<in> \\<omega> !! i;\n        \\<forall>j\\<le>0. zero x (\\<omega> !! j); x \\<in> \\<X>;\n        \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\\<rbrakk>\n       \\<Longrightarrow> dur xs 0 = 0\n 2. \\<And>i xs \\<omega>.\n       \\<lbrakk>\\<And>xs \\<omega>.\n                   \\<lbrakk>\\<forall>i. xs !! i \\<in> \\<omega> !! i;\n                    \\<forall>j\\<le>i. zero x (\\<omega> !! j); x \\<in> \\<X>;\n                    \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\\<rbrakk>\n                   \\<Longrightarrow> dur xs i = 0;\n        \\<forall>i. xs !! i \\<in> \\<omega> !! i;\n        \\<forall>j\\<le>Suc i. zero x (\\<omega> !! j); x \\<in> \\<X>;\n        \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\\<rbrakk>\n       \\<Longrightarrow> dur xs (Suc i) = 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>i. xs !! i \\<in> \\<omega> !! i\n  \\<forall>j\\<le>0. zero x (\\<omega> !! j)\n  x \\<in> \\<X>\n  \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>i. xs !! i \\<in> \\<omega> !! i\n  \\<forall>j\\<le>0. zero x (\\<omega> !! j)\n  x \\<in> \\<X>\n  \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\n\ngoal (1 subgoal):\n 1. dur xs 0 = 0", "by simp"], ["proof (state)\nthis:\n  dur xs 0 = 0\n\ngoal (1 subgoal):\n 1. \\<And>i xs \\<omega>.\n       \\<lbrakk>\\<And>xs \\<omega>.\n                   \\<lbrakk>\\<forall>i. xs !! i \\<in> \\<omega> !! i;\n                    \\<forall>j\\<le>i. zero x (\\<omega> !! j); x \\<in> \\<X>;\n                    \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\\<rbrakk>\n                   \\<Longrightarrow> dur xs i = 0;\n        \\<forall>i. xs !! i \\<in> \\<omega> !! i;\n        \\<forall>j\\<le>Suc i. zero x (\\<omega> !! j); x \\<in> \\<X>;\n        \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\\<rbrakk>\n       \\<Longrightarrow> dur xs (Suc i) = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i xs \\<omega>.\n       \\<lbrakk>\\<And>xs \\<omega>.\n                   \\<lbrakk>\\<forall>i. xs !! i \\<in> \\<omega> !! i;\n                    \\<forall>j\\<le>i. zero x (\\<omega> !! j); x \\<in> \\<X>;\n                    \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\\<rbrakk>\n                   \\<Longrightarrow> dur xs i = 0;\n        \\<forall>i. xs !! i \\<in> \\<omega> !! i;\n        \\<forall>j\\<le>Suc i. zero x (\\<omega> !! j); x \\<in> \\<X>;\n        \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\\<rbrakk>\n       \\<Longrightarrow> dur xs (Suc i) = 0", "case (Suc i xs \\<omega>)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>i. ?xs6 !! i \\<in> ?\\<omega>6 !! i;\n   \\<forall>j\\<le>i. zero x (?\\<omega>6 !! j); x \\<in> \\<X>;\n   \\<forall>i. eq_elapsed (?xs6 !! i) (?xs6 !! Suc i)\\<rbrakk>\n  \\<Longrightarrow> dur ?xs6 i = 0\n  \\<forall>i. xs !! i \\<in> \\<omega> !! i\n  \\<forall>j\\<le>Suc i. zero x (\\<omega> !! j)\n  x \\<in> \\<X>\n  \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\n\ngoal (1 subgoal):\n 1. \\<And>i xs \\<omega>.\n       \\<lbrakk>\\<And>xs \\<omega>.\n                   \\<lbrakk>\\<forall>i. xs !! i \\<in> \\<omega> !! i;\n                    \\<forall>j\\<le>i. zero x (\\<omega> !! j); x \\<in> \\<X>;\n                    \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\\<rbrakk>\n                   \\<Longrightarrow> dur xs i = 0;\n        \\<forall>i. xs !! i \\<in> \\<omega> !! i;\n        \\<forall>j\\<le>Suc i. zero x (\\<omega> !! j); x \\<in> \\<X>;\n        \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\\<rbrakk>\n       \\<Longrightarrow> dur xs (Suc i) = 0", "let ?x = \"xs !! 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i xs \\<omega>.\n       \\<lbrakk>\\<And>xs \\<omega>.\n                   \\<lbrakk>\\<forall>i. xs !! i \\<in> \\<omega> !! i;\n                    \\<forall>j\\<le>i. zero x (\\<omega> !! j); x \\<in> \\<X>;\n                    \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\\<rbrakk>\n                   \\<Longrightarrow> dur xs i = 0;\n        \\<forall>i. xs !! i \\<in> \\<omega> !! i;\n        \\<forall>j\\<le>Suc i. zero x (\\<omega> !! j); x \\<in> \\<X>;\n        \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\\<rbrakk>\n       \\<Longrightarrow> dur xs (Suc i) = 0", "let ?y = \"xs !! 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i xs \\<omega>.\n       \\<lbrakk>\\<And>xs \\<omega>.\n                   \\<lbrakk>\\<forall>i. xs !! i \\<in> \\<omega> !! i;\n                    \\<forall>j\\<le>i. zero x (\\<omega> !! j); x \\<in> \\<X>;\n                    \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\\<rbrakk>\n                   \\<Longrightarrow> dur xs i = 0;\n        \\<forall>i. xs !! i \\<in> \\<omega> !! i;\n        \\<forall>j\\<le>Suc i. zero x (\\<omega> !! j); x \\<in> \\<X>;\n        \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\\<rbrakk>\n       \\<Longrightarrow> dur xs (Suc i) = 0", "let ?ys = \"stl (stl xs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i xs \\<omega>.\n       \\<lbrakk>\\<And>xs \\<omega>.\n                   \\<lbrakk>\\<forall>i. xs !! i \\<in> \\<omega> !! i;\n                    \\<forall>j\\<le>i. zero x (\\<omega> !! j); x \\<in> \\<X>;\n                    \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\\<rbrakk>\n                   \\<Longrightarrow> dur xs i = 0;\n        \\<forall>i. xs !! i \\<in> \\<omega> !! i;\n        \\<forall>j\\<le>Suc i. zero x (\\<omega> !! j); x \\<in> \\<X>;\n        \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\\<rbrakk>\n       \\<Longrightarrow> dur xs (Suc i) = 0", "have xs: \"xs = ?x ## ?y ## ?ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = xs !! 0 ## xs !! 1 ## stl (stl xs)", "by auto"], ["proof (state)\nthis:\n  xs = xs !! 0 ## xs !! 1 ## stl (stl xs)\n\ngoal (1 subgoal):\n 1. \\<And>i xs \\<omega>.\n       \\<lbrakk>\\<And>xs \\<omega>.\n                   \\<lbrakk>\\<forall>i. xs !! i \\<in> \\<omega> !! i;\n                    \\<forall>j\\<le>i. zero x (\\<omega> !! j); x \\<in> \\<X>;\n                    \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\\<rbrakk>\n                   \\<Longrightarrow> dur xs i = 0;\n        \\<forall>i. xs !! i \\<in> \\<omega> !! i;\n        \\<forall>j\\<le>Suc i. zero x (\\<omega> !! j); x \\<in> \\<X>;\n        \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\\<rbrakk>\n       \\<Longrightarrow> dur xs (Suc i) = 0", "from Suc.prems"], ["proof (chain)\npicking this:\n  \\<forall>i. xs !! i \\<in> \\<omega> !! i\n  \\<forall>j\\<le>Suc i. zero x (\\<omega> !! j)\n  x \\<in> \\<X>\n  \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)", "have\n    \"\\<forall> i. (?y ## ?ys) !! i \\<in> stl \\<omega> !! i\" \"\\<forall> j \\<le> i. zero x (stl \\<omega> !! j)\"\n    \"\\<forall> i. eq_elapsed (stl xs !! i) (stl xs !! Suc i)\""], ["proof (prove)\nusing this:\n  \\<forall>i. xs !! i \\<in> \\<omega> !! i\n  \\<forall>j\\<le>Suc i. zero x (\\<omega> !! j)\n  x \\<in> \\<X>\n  \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\n\ngoal (1 subgoal):\n 1. \\<forall>i. (xs !! 1 ## stl (stl xs)) !! i \\<in> stl \\<omega> !! i &&&\n    \\<forall>j\\<le>i. zero x (stl \\<omega> !! j) &&&\n    \\<forall>i. eq_elapsed (stl xs !! i) (stl xs !! Suc i)", "by (metis snth.simps(2) | auto)+"], ["proof (state)\nthis:\n  \\<forall>i. (xs !! 1 ## stl (stl xs)) !! i \\<in> stl \\<omega> !! i\n  \\<forall>j\\<le>i. zero x (stl \\<omega> !! j)\n  \\<forall>i. eq_elapsed (stl xs !! i) (stl xs !! Suc i)\n\ngoal (1 subgoal):\n 1. \\<And>i xs \\<omega>.\n       \\<lbrakk>\\<And>xs \\<omega>.\n                   \\<lbrakk>\\<forall>i. xs !! i \\<in> \\<omega> !! i;\n                    \\<forall>j\\<le>i. zero x (\\<omega> !! j); x \\<in> \\<X>;\n                    \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\\<rbrakk>\n                   \\<Longrightarrow> dur xs i = 0;\n        \\<forall>i. xs !! i \\<in> \\<omega> !! i;\n        \\<forall>j\\<le>Suc i. zero x (\\<omega> !! j); x \\<in> \\<X>;\n        \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\\<rbrakk>\n       \\<Longrightarrow> dur xs (Suc i) = 0", "from Suc.IH[OF this(1,2) \\<open>x \\<in> _\\<close>] this(3)"], ["proof (chain)\npicking this:\n  \\<forall>i.\n     eq_elapsed ((xs !! 1 ## stl (stl xs)) !! i)\n      ((xs !! 1 ## stl (stl xs)) !! Suc i) \\<Longrightarrow>\n  dur (xs !! 1 ## stl (stl xs)) i = 0\n  \\<forall>i. eq_elapsed (stl xs !! i) (stl xs !! Suc i)", "have [simp]: \"dur (stl xs) i = 0\""], ["proof (prove)\nusing this:\n  \\<forall>i.\n     eq_elapsed ((xs !! 1 ## stl (stl xs)) !! i)\n      ((xs !! 1 ## stl (stl xs)) !! Suc i) \\<Longrightarrow>\n  dur (xs !! 1 ## stl (stl xs)) i = 0\n  \\<forall>i. eq_elapsed (stl xs !! i) (stl xs !! Suc i)\n\ngoal (1 subgoal):\n 1. dur (stl xs) i = 0", "by auto"], ["proof (state)\nthis:\n  dur (stl xs) i = 0\n\ngoal (1 subgoal):\n 1. \\<And>i xs \\<omega>.\n       \\<lbrakk>\\<And>xs \\<omega>.\n                   \\<lbrakk>\\<forall>i. xs !! i \\<in> \\<omega> !! i;\n                    \\<forall>j\\<le>i. zero x (\\<omega> !! j); x \\<in> \\<X>;\n                    \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\\<rbrakk>\n                   \\<Longrightarrow> dur xs i = 0;\n        \\<forall>i. xs !! i \\<in> \\<omega> !! i;\n        \\<forall>j\\<le>Suc i. zero x (\\<omega> !! j); x \\<in> \\<X>;\n        \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\\<rbrakk>\n       \\<Longrightarrow> dur xs (Suc i) = 0", "from Suc.prems(1,2)"], ["proof (chain)\npicking this:\n  \\<forall>i. xs !! i \\<in> \\<omega> !! i\n  \\<forall>j\\<le>Suc i. zero x (\\<omega> !! j)", "have \"?y x = 0\" \"?x x = 0\""], ["proof (prove)\nusing this:\n  \\<forall>i. xs !! i \\<in> \\<omega> !! i\n  \\<forall>j\\<le>Suc i. zero x (\\<omega> !! j)\n\ngoal (1 subgoal):\n 1. (xs !! 1) x = 0 &&& (xs !! 0) x = 0", "unfolding zero_def"], ["proof (prove)\nusing this:\n  \\<forall>i. xs !! i \\<in> \\<omega> !! i\n  \\<forall>j\\<le>Suc i. \\<forall>u\\<in>\\<omega> !! j. u x = 0\n\ngoal (1 subgoal):\n 1. (xs !! 1) x = 0 &&& (xs !! 0) x = 0", "by force+"], ["proof (state)\nthis:\n  (xs !! 1) x = 0\n  (xs !! 0) x = 0\n\ngoal (1 subgoal):\n 1. \\<And>i xs \\<omega>.\n       \\<lbrakk>\\<And>xs \\<omega>.\n                   \\<lbrakk>\\<forall>i. xs !! i \\<in> \\<omega> !! i;\n                    \\<forall>j\\<le>i. zero x (\\<omega> !! j); x \\<in> \\<X>;\n                    \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\\<rbrakk>\n                   \\<Longrightarrow> dur xs i = 0;\n        \\<forall>i. xs !! i \\<in> \\<omega> !! i;\n        \\<forall>j\\<le>Suc i. zero x (\\<omega> !! j); x \\<in> \\<X>;\n        \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\\<rbrakk>\n       \\<Longrightarrow> dur xs (Suc i) = 0", "then"], ["proof (chain)\npicking this:\n  (xs !! 1) x = 0\n  (xs !! 0) x = 0", "have *: \"?y x - ?x x = 0\""], ["proof (prove)\nusing this:\n  (xs !! 1) x = 0\n  (xs !! 0) x = 0\n\ngoal (1 subgoal):\n 1. (xs !! 1) x - (xs !! 0) x = 0", "by simp"], ["proof (state)\nthis:\n  (xs !! 1) x - (xs !! 0) x = 0\n\ngoal (1 subgoal):\n 1. \\<And>i xs \\<omega>.\n       \\<lbrakk>\\<And>xs \\<omega>.\n                   \\<lbrakk>\\<forall>i. xs !! i \\<in> \\<omega> !! i;\n                    \\<forall>j\\<le>i. zero x (\\<omega> !! j); x \\<in> \\<X>;\n                    \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\\<rbrakk>\n                   \\<Longrightarrow> dur xs i = 0;\n        \\<forall>i. xs !! i \\<in> \\<omega> !! i;\n        \\<forall>j\\<le>Suc i. zero x (\\<omega> !! j); x \\<in> \\<X>;\n        \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\\<rbrakk>\n       \\<Longrightarrow> dur xs (Suc i) = 0", "have \"dur xs (Suc i) = elapsed ?x ?y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dur xs (Suc i) = elapsed (xs !! 0) (xs !! 1)", "apply (subst xs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. dur (xs !! 0 ## xs !! 1 ## stl (stl xs)) (Suc i) =\n    elapsed (xs !! 0) (xs !! 1)", "apply (subst dur.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. elapsed (xs !! 0) (xs !! 1) + dur (xs !! 1 ## stl (stl xs)) i =\n    elapsed (xs !! 0) (xs !! 1)", "by simp"], ["proof (state)\nthis:\n  dur xs (Suc i) = elapsed (xs !! 0) (xs !! 1)\n\ngoal (1 subgoal):\n 1. \\<And>i xs \\<omega>.\n       \\<lbrakk>\\<And>xs \\<omega>.\n                   \\<lbrakk>\\<forall>i. xs !! i \\<in> \\<omega> !! i;\n                    \\<forall>j\\<le>i. zero x (\\<omega> !! j); x \\<in> \\<X>;\n                    \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\\<rbrakk>\n                   \\<Longrightarrow> dur xs i = 0;\n        \\<forall>i. xs !! i \\<in> \\<omega> !! i;\n        \\<forall>j\\<le>Suc i. zero x (\\<omega> !! j); x \\<in> \\<X>;\n        \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\\<rbrakk>\n       \\<Longrightarrow> dur xs (Suc i) = 0", "also"], ["proof (state)\nthis:\n  dur xs (Suc i) = elapsed (xs !! 0) (xs !! 1)\n\ngoal (1 subgoal):\n 1. \\<And>i xs \\<omega>.\n       \\<lbrakk>\\<And>xs \\<omega>.\n                   \\<lbrakk>\\<forall>i. xs !! i \\<in> \\<omega> !! i;\n                    \\<forall>j\\<le>i. zero x (\\<omega> !! j); x \\<in> \\<X>;\n                    \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\\<rbrakk>\n                   \\<Longrightarrow> dur xs i = 0;\n        \\<forall>i. xs !! i \\<in> \\<omega> !! i;\n        \\<forall>j\\<le>Suc i. zero x (\\<omega> !! j); x \\<in> \\<X>;\n        \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\\<rbrakk>\n       \\<Longrightarrow> dur xs (Suc i) = 0", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elapsed (xs !! 0) (xs !! 1) = 0", "apply (subst elapsed_eq[OF _ \\<open>x \\<in> _\\<close>])"], ["proof (prove)\ngoal (3 subgoals):\n 1. eq_elapsed (xs !! 0) (xs !! 1)\n 2. 0 \\<le> (xs !! 1) x - (xs !! 0) x\n 3. (xs !! 1) x - (xs !! 0) x = 0", "unfolding One_nat_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. eq_elapsed (xs !! 0) (xs !! Suc 0)\n 2. 0 \\<le> (xs !! Suc 0) x - (xs !! 0) x\n 3. (xs !! Suc 0) x - (xs !! 0) x = 0", "using Suc.prems(4)"], ["proof (prove)\nusing this:\n  \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\n\ngoal (3 subgoals):\n 1. eq_elapsed (xs !! 0) (xs !! Suc 0)\n 2. 0 \\<le> (xs !! Suc 0) x - (xs !! 0) x\n 3. (xs !! Suc 0) x - (xs !! 0) x = 0", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> (xs !! Suc 0) x - (xs !! 0) x\n 2. (xs !! Suc 0) x - (xs !! 0) x = 0", "using *"], ["proof (prove)\nusing this:\n  (xs !! 1) x - (xs !! 0) x = 0\n\ngoal (2 subgoals):\n 1. 0 \\<le> (xs !! Suc 0) x - (xs !! 0) x\n 2. (xs !! Suc 0) x - (xs !! 0) x = 0", "by auto"], ["proof (state)\nthis:\n  elapsed (xs !! 0) (xs !! 1) = 0\n\ngoal (1 subgoal):\n 1. \\<And>i xs \\<omega>.\n       \\<lbrakk>\\<And>xs \\<omega>.\n                   \\<lbrakk>\\<forall>i. xs !! i \\<in> \\<omega> !! i;\n                    \\<forall>j\\<le>i. zero x (\\<omega> !! j); x \\<in> \\<X>;\n                    \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\\<rbrakk>\n                   \\<Longrightarrow> dur xs i = 0;\n        \\<forall>i. xs !! i \\<in> \\<omega> !! i;\n        \\<forall>j\\<le>Suc i. zero x (\\<omega> !! j); x \\<in> \\<X>;\n        \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\\<rbrakk>\n       \\<Longrightarrow> dur xs (Suc i) = 0", "finally"], ["proof (chain)\npicking this:\n  dur xs (Suc i) = 0", "show ?case"], ["proof (prove)\nusing this:\n  dur xs (Suc i) = 0\n\ngoal (1 subgoal):\n 1. dur xs (Suc i) = 0", "."], ["proof (state)\nthis:\n  dur xs (Suc i) = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dur_zero_tail:\n  assumes \"\\<forall> i. xs !! i \\<in> \\<omega> !! i\" \"\\<forall> k \\<ge> i. k \\<le> j \\<longrightarrow> zero x (\\<omega> !! k)\" \"x \\<in> \\<X>\" \"j \\<ge> i\"\n          \"\\<forall> i. eq_elapsed (xs !! i) (xs !! Suc i)\"\n  shows \"dur xs j = dur xs i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dur xs j = dur xs i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dur xs j = dur xs i", "from \\<open>j \\<ge> i\\<close> dur_shift[of xs i \"j - i\"]"], ["proof (chain)\npicking this:\n  i \\<le> j\n  dur xs (i + (j - i)) = dur xs i + dur (sdrop i xs) (j - i)", "have\n    \"dur xs j = dur xs i + dur (sdrop i xs) (j - i)\""], ["proof (prove)\nusing this:\n  i \\<le> j\n  dur xs (i + (j - i)) = dur xs i + dur (sdrop i xs) (j - i)\n\ngoal (1 subgoal):\n 1. dur xs j = dur xs i + dur (sdrop i xs) (j - i)", "by simp"], ["proof (state)\nthis:\n  dur xs j = dur xs i + dur (sdrop i xs) (j - i)\n\ngoal (1 subgoal):\n 1. dur xs j = dur xs i", "also"], ["proof (state)\nthis:\n  dur xs j = dur xs i + dur (sdrop i xs) (j - i)\n\ngoal (1 subgoal):\n 1. dur xs j = dur xs i", "have \"\\<dots> = dur xs i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dur xs i + dur (sdrop i xs) (j - i) = dur xs i", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>i. xs !! i \\<in> \\<omega> !! i\n  \\<forall>k\\<ge>i. k \\<le> j \\<longrightarrow> zero x (\\<omega> !! k)\n  x \\<in> \\<X>\n  i \\<le> j\n  \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\n\ngoal (1 subgoal):\n 1. dur xs i + dur (sdrop i xs) (j - i) = dur xs i", "by (rewrite in \"dur (sdrop _ _) _\" dur_zero[where \\<omega> = \"sdrop i \\<omega>\"])\n       (auto dest: prop_nth_sdrop_pair[of eq_elapsed] prop_nth_sdrop prop_nth_sdrop_pair[of \"(\\<in>)\"])"], ["proof (state)\nthis:\n  dur xs i + dur (sdrop i xs) (j - i) = dur xs i\n\ngoal (1 subgoal):\n 1. dur xs j = dur xs i", "finally"], ["proof (chain)\npicking this:\n  dur xs j = dur xs i", "show ?thesis"], ["proof (prove)\nusing this:\n  dur xs j = dur xs i\n\ngoal (1 subgoal):\n 1. dur xs j = dur xs i", "."], ["proof (state)\nthis:\n  dur xs j = dur xs i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma elapsed_ge_pos:\n  fixes u :: \"('c, t) cval\"\n  assumes \"eq_elapsed u u'\" \"c \\<in> \\<X>\" \"u \\<in> V\" \"u' \\<in> V\"\n  shows \"elapsed u u' \\<le> u' c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elapsed u u' \\<le> u' c", "proof (cases \"elapsed u u' = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. elapsed u u' = 0 \\<Longrightarrow> elapsed u u' \\<le> u' c\n 2. elapsed u u' \\<noteq> 0 \\<Longrightarrow> elapsed u u' \\<le> u' c", "case True"], ["proof (state)\nthis:\n  elapsed u u' = 0\n\ngoal (2 subgoals):\n 1. elapsed u u' = 0 \\<Longrightarrow> elapsed u u' \\<le> u' c\n 2. elapsed u u' \\<noteq> 0 \\<Longrightarrow> elapsed u u' \\<le> u' c", "with assms"], ["proof (chain)\npicking this:\n  eq_elapsed u u'\n  c \\<in> \\<X>\n  u \\<in> V\n  u' \\<in> V\n  elapsed u u' = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  eq_elapsed u u'\n  c \\<in> \\<X>\n  u \\<in> V\n  u' \\<in> V\n  elapsed u u' = 0\n\ngoal (1 subgoal):\n 1. elapsed u u' \\<le> u' c", "by (auto simp: V_def)"], ["proof (state)\nthis:\n  elapsed u u' \\<le> u' c\n\ngoal (1 subgoal):\n 1. elapsed u u' \\<noteq> 0 \\<Longrightarrow> elapsed u u' \\<le> u' c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. elapsed u u' \\<noteq> 0 \\<Longrightarrow> elapsed u u' \\<le> u' c", "case False"], ["proof (state)\nthis:\n  elapsed u u' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. elapsed u u' \\<noteq> 0 \\<Longrightarrow> elapsed u u' \\<le> u' c", "from \\<open>u \\<in> V\\<close> \\<open>c \\<in> \\<X> \\<close>"], ["proof (chain)\npicking this:\n  u \\<in> V\n  c \\<in> \\<X>", "have \"u c \\<ge> 0\""], ["proof (prove)\nusing this:\n  u \\<in> V\n  c \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. 0 \\<le> u c", "by (auto simp: V_def)"], ["proof (state)\nthis:\n  0 \\<le> u c\n\ngoal (1 subgoal):\n 1. elapsed u u' \\<noteq> 0 \\<Longrightarrow> elapsed u u' \\<le> u' c", "from False assms"], ["proof (chain)\npicking this:\n  elapsed u u' \\<noteq> 0\n  eq_elapsed u u'\n  c \\<in> \\<X>\n  u \\<in> V\n  u' \\<in> V", "have \"elapsed u u' = u' c - u c\""], ["proof (prove)\nusing this:\n  elapsed u u' \\<noteq> 0\n  eq_elapsed u u'\n  c \\<in> \\<X>\n  u \\<in> V\n  u' \\<in> V\n\ngoal (1 subgoal):\n 1. elapsed u u' = u' c - u c", "unfolding eq_elapsed_def"], ["proof (prove)\nusing this:\n  elapsed u u' \\<noteq> 0\n  0 < elapsed u u' \\<longrightarrow>\n  (\\<forall>c\\<in>\\<X>. u' c - u c = elapsed u u')\n  c \\<in> \\<X>\n  u \\<in> V\n  u' \\<in> V\n\ngoal (1 subgoal):\n 1. elapsed u u' = u' c - u c", "by (auto simp add: less_le)"], ["proof (state)\nthis:\n  elapsed u u' = u' c - u c\n\ngoal (1 subgoal):\n 1. elapsed u u' \\<noteq> 0 \\<Longrightarrow> elapsed u u' \\<le> u' c", "also"], ["proof (state)\nthis:\n  elapsed u u' = u' c - u c\n\ngoal (1 subgoal):\n 1. elapsed u u' \\<noteq> 0 \\<Longrightarrow> elapsed u u' \\<le> u' c", "from \\<open>u c \\<ge> 0\\<close>"], ["proof (chain)\npicking this:\n  0 \\<le> u c", "have \"\\<dots> \\<le> u' c\""], ["proof (prove)\nusing this:\n  0 \\<le> u c\n\ngoal (1 subgoal):\n 1. u' c - u c \\<le> u' c", "by simp"], ["proof (state)\nthis:\n  u' c - u c \\<le> u' c\n\ngoal (1 subgoal):\n 1. elapsed u u' \\<noteq> 0 \\<Longrightarrow> elapsed u u' \\<le> u' c", "finally"], ["proof (chain)\npicking this:\n  elapsed u u' \\<le> u' c", "show ?thesis"], ["proof (prove)\nusing this:\n  elapsed u u' \\<le> u' c\n\ngoal (1 subgoal):\n 1. elapsed u u' \\<le> u' c", "."], ["proof (state)\nthis:\n  elapsed u u' \\<le> u' c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dur_Suc:\n  \"dur xs (Suc i) - dur xs i = elapsed (xs !! i) (xs !! Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dur xs (Suc i) - dur xs i = elapsed (xs !! i) (xs !! Suc i)", "apply (induction i arbitrary: xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs. dur xs (Suc 0) - dur xs 0 = elapsed (xs !! 0) (xs !! Suc 0)\n 2. \\<And>i xs.\n       (\\<And>xs.\n           dur xs (Suc i) - dur xs i =\n           elapsed (xs !! i) (xs !! Suc i)) \\<Longrightarrow>\n       dur xs (Suc (Suc i)) - dur xs (Suc i) =\n       elapsed (xs !! Suc i) (xs !! Suc (Suc i))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs. dur xs (Suc 0) = elapsed (shd xs) (shd (stl xs))\n 2. \\<And>i xs.\n       (\\<And>xs.\n           dur xs (Suc i) - dur xs i =\n           elapsed (xs !! i) (xs !! Suc i)) \\<Longrightarrow>\n       dur xs (Suc (Suc i)) - dur xs (Suc i) =\n       elapsed (xs !! Suc i) (xs !! Suc (Suc i))", "apply (subst stream.collapse[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       dur (shd xs ## stl xs) (Suc 0) = elapsed (shd xs) (shd (stl xs))\n 2. \\<And>i xs.\n       (\\<And>xs.\n           dur xs (Suc i) - dur xs i =\n           elapsed (xs !! i) (xs !! Suc i)) \\<Longrightarrow>\n       dur xs (Suc (Suc i)) - dur xs (Suc i) =\n       elapsed (xs !! Suc i) (xs !! Suc (Suc i))", "apply (rewrite in \"stl _\" stream.collapse[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       dur (shd xs ## shd (stl xs) ## stl (stl xs)) (Suc 0) =\n       elapsed (shd xs) (shd (stl xs))\n 2. \\<And>i xs.\n       (\\<And>xs.\n           dur xs (Suc i) - dur xs i =\n           elapsed (xs !! i) (xs !! Suc i)) \\<Longrightarrow>\n       dur xs (Suc (Suc i)) - dur xs (Suc i) =\n       elapsed (xs !! Suc i) (xs !! Suc (Suc i))", "apply (subst dur.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       elapsed (shd xs) (shd (stl xs)) +\n       dur (shd (stl xs) ## stl (stl xs)) 0 =\n       elapsed (shd xs) (shd (stl xs))\n 2. \\<And>i xs.\n       (\\<And>xs.\n           dur xs (Suc i) - dur xs i =\n           elapsed (xs !! i) (xs !! Suc i)) \\<Longrightarrow>\n       dur xs (Suc (Suc i)) - dur xs (Suc i) =\n       elapsed (xs !! Suc i) (xs !! Suc (Suc i))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i xs.\n       (\\<And>xs.\n           dur xs (Suc i) - dur xs i =\n           elapsed (xs !! i) (xs !! Suc i)) \\<Longrightarrow>\n       dur xs (Suc (Suc i)) - dur xs (Suc i) =\n       elapsed (xs !! Suc i) (xs !! Suc (Suc i))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i xs.\n       (\\<And>xs.\n           dur xs (Suc i) - dur xs i =\n           elapsed (xs !! i) (stl xs !! i)) \\<Longrightarrow>\n       dur xs (Suc (Suc i)) - dur xs (Suc i) =\n       elapsed (stl xs !! i) (stl (stl xs) !! i)", "subgoal for i xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        dur xs (Suc i) - dur xs i =\n        elapsed (xs !! i) (stl xs !! i)) \\<Longrightarrow>\n    dur xs (Suc (Suc i)) - dur xs (Suc i) =\n    elapsed (stl xs !! i) (stl (stl xs) !! i)", "apply (subst stream.collapse[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        dur xs (Suc i) - dur xs i =\n        elapsed (xs !! i) (stl xs !! i)) \\<Longrightarrow>\n    dur (shd xs ## stl xs) (Suc (Suc i)) - dur xs (Suc i) =\n    elapsed (stl xs !! i) (stl (stl xs) !! i)", "apply (rewrite in \"stl _\" stream.collapse[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        dur xs (Suc i) - dur xs i =\n        elapsed (xs !! i) (stl xs !! i)) \\<Longrightarrow>\n    dur (shd xs ## shd (stl xs) ## stl (stl xs)) (Suc (Suc i)) -\n    dur xs (Suc i) =\n    elapsed (stl xs !! i) (stl (stl xs) !! i)", "apply (subst dur.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        dur xs (Suc i) - dur xs i =\n        elapsed (xs !! i) (stl xs !! i)) \\<Longrightarrow>\n    elapsed (shd xs) (shd (stl xs)) +\n    dur (shd (stl xs) ## stl (stl xs)) (Suc i) -\n    dur xs (Suc i) =\n    elapsed (stl xs !! i) (stl (stl xs) !! i)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        dur xs (Suc i) - dur xs i =\n        elapsed (xs !! i) (stl xs !! i)) \\<Longrightarrow>\n    elapsed (shd xs) (shd (stl xs)) + dur (stl xs) (Suc i) -\n    dur xs (Suc i) =\n    elapsed (stl xs !! i) (stl (stl xs) !! i)", "apply (rewrite in \"dur xs (Suc _)\" stream.collapse[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        dur xs (Suc i) - dur xs i =\n        elapsed (xs !! i) (stl xs !! i)) \\<Longrightarrow>\n    elapsed (shd xs) (shd (stl xs)) + dur (stl xs) (Suc i) -\n    dur (shd xs ## stl xs) (Suc i) =\n    elapsed (stl xs !! i) (stl (stl xs) !! i)", "apply (rewrite at \"stl xs\" in \"_ ## stl xs\" stream.collapse[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        dur xs (Suc i) - dur xs i =\n        elapsed (xs !! i) (stl xs !! i)) \\<Longrightarrow>\n    elapsed (shd xs) (shd (stl xs)) + dur (stl xs) (Suc i) -\n    dur (shd xs ## shd (stl xs) ## stl (stl xs)) (Suc i) =\n    elapsed (stl xs !! i) (stl (stl xs) !! i)", "apply (subst dur.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        dur xs (Suc i) - dur xs i =\n        elapsed (xs !! i) (stl xs !! i)) \\<Longrightarrow>\n    elapsed (shd xs) (shd (stl xs)) + dur (stl xs) (Suc i) -\n    (elapsed (shd xs) (shd (stl xs)) +\n     dur (shd (stl xs) ## stl (stl xs)) i) =\n    elapsed (stl xs !! i) (stl (stl xs) !! i)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "inductive trans where\n  succ: \"t \\<ge> 0 \\<Longrightarrow> u' = u \\<oplus> t \\<Longrightarrow> trans u u'\" |\n  reset: \"set l \\<subseteq> \\<X> \\<Longrightarrow> u' = clock_set l 0 u \\<Longrightarrow> trans u u'\" |\n  id: \"u = u' \\<Longrightarrow> trans u u'\""], ["", "abbreviation \"stream_trans \\<equiv> pairwise trans\""], ["", "lemma K_cfg_trans:\n  assumes \"cfg \\<in> MDP.cfg_on (l, R)\" \"cfg' \\<in> K_cfg cfg\" \"state cfg' = (l', R')\"\n  shows \"trans R R'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.trans R R'", "using assms"], ["proof (prove)\nusing this:\n  cfg \\<in> MDP.cfg_on (l, R)\n  cfg' \\<in> set_pmf (K_cfg cfg)\n  state cfg' = (l', R')\n\ngoal (1 subgoal):\n 1. local.trans R R'", "apply (simp add: set_K_cfg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cfg \\<in> MDP.cfg_on (l, R);\n     cfg' \\<in> cont cfg ` set_pmf (action cfg);\n     state cfg' = (l', R')\\<rbrakk>\n    \\<Longrightarrow> local.trans R R'", "apply (drule MDP.cfg_onD_action)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cfg' \\<in> cont cfg ` set_pmf (action cfg);\n     state cfg' = (l', R'); action cfg \\<in> K (l, R)\\<rbrakk>\n    \\<Longrightarrow> local.trans R R'", "apply (cases rule: K.cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>cfg' \\<in> cont cfg ` set_pmf (action cfg);\n     state cfg' = (l', R'); action cfg \\<in> K (l, R)\\<rbrakk>\n    \\<Longrightarrow> ?a6 \\<in> K ?st6\n 2. \\<And>la u t.\n       \\<lbrakk>cfg' \\<in> cont cfg ` set_pmf (action cfg);\n        state cfg' = (l', R'); action cfg \\<in> K (l, R);\n        ?a6 = return_pmf (la, u \\<oplus> t); ?st6 \\<in> S; ?st6 = (la, u);\n        0 \\<le> t; u \\<oplus> t \\<turnstile> PTA.inv_of A la\\<rbrakk>\n       \\<Longrightarrow> local.trans R R'\n 3. \\<And>la u g \\<mu>.\n       \\<lbrakk>cfg' \\<in> cont cfg ` set_pmf (action cfg);\n        state cfg' = (l', R'); action cfg \\<in> K (l, R);\n        ?a6 =\n        map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n         \\<mu>;\n        ?st6 \\<in> S; ?st6 = (la, u); (la, g, \\<mu>) \\<in> PTA.trans_of A;\n        u \\<turnstile> g\\<rbrakk>\n       \\<Longrightarrow> local.trans R R'\n 4. \\<lbrakk>cfg' \\<in> cont cfg ` set_pmf (action cfg);\n     state cfg' = (l', R'); action cfg \\<in> K (l, R);\n     ?a6 = return_pmf ?st6\\<rbrakk>\n    \\<Longrightarrow> local.trans R R'", "apply (auto intro: trans.intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g \\<mu> a.\n       \\<lbrakk>map_pmf\n                 (\\<lambda>(X, l).\n                     (l, [(SOME r. set r = X)\\<rightarrow>0]R))\n                 \\<mu>\n                \\<in> K (l, R);\n        action cfg =\n        map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]R))\n         \\<mu>;\n        (l, R) \\<in> S; (l, g, \\<mu>) \\<in> PTA.trans_of A;\n        R \\<turnstile> g;\n        cfg' = cont cfg (l', [(SOME r. set r = a)\\<rightarrow>0]R);\n        (a, l') \\<in> set_pmf \\<mu>;\n        R' = [(SOME r. set r = a)\\<rightarrow>0]R\\<rbrakk>\n       \\<Longrightarrow> local.trans R\n                          ([(SOME r. set r = a)\\<rightarrow>0]R)", "using admissible_targets_clocks(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?l, ?g, ?\\<mu>) \\<in> PTA.trans_of A;\n   (?X, ?l') \\<in> set_pmf ?\\<mu>\\<rbrakk>\n  \\<Longrightarrow> set (SOME r. set r = ?X) \\<subseteq> \\<X>\n\ngoal (1 subgoal):\n 1. \\<And>g \\<mu> a.\n       \\<lbrakk>map_pmf\n                 (\\<lambda>(X, l).\n                     (l, [(SOME r. set r = X)\\<rightarrow>0]R))\n                 \\<mu>\n                \\<in> K (l, R);\n        action cfg =\n        map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]R))\n         \\<mu>;\n        (l, R) \\<in> S; (l, g, \\<mu>) \\<in> PTA.trans_of A;\n        R \\<turnstile> g;\n        cfg' = cont cfg (l', [(SOME r. set r = a)\\<rightarrow>0]R);\n        (a, l') \\<in> set_pmf \\<mu>;\n        R' = [(SOME r. set r = a)\\<rightarrow>0]R\\<rbrakk>\n       \\<Longrightarrow> local.trans R\n                          ([(SOME r. set r = a)\\<rightarrow>0]R)", "by (blast intro: trans.intros(2))"], ["", "lemma enabled_stream_trans:\n  assumes \"cfg \\<in> valid_cfg\" \"MDP.MC.enabled cfg xs\"\n  shows \"stream_trans (smap (snd o state) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_trans (smap (snd \\<circ> state) xs)", "using assms"], ["proof (prove)\nusing this:\n  cfg \\<in> MDP.valid_cfg\n  MDP.MC.enabled cfg xs\n\ngoal (1 subgoal):\n 1. stream_trans (smap (snd \\<circ> state) xs)", "proof (coinduction arbitrary: cfg xs)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg xs.\n       \\<lbrakk>cfg \\<in> MDP.valid_cfg; MDP.MC.enabled cfg xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b xsa.\n                            smap (snd \\<circ> state) xs =\n                            a ## b ## xsa \\<and>\n                            local.trans a b \\<and>\n                            ((\\<exists>cfg xs.\n                                 b ## xsa =\n                                 smap (snd \\<circ> state) xs \\<and>\n                                 cfg \\<in> MDP.valid_cfg \\<and>\n                                 MDP.MC.enabled cfg xs) \\<or>\n                             stream_trans (b ## xsa))", "case prems: (pairwise cfg xs)"], ["proof (state)\nthis:\n  cfg \\<in> MDP.valid_cfg\n  MDP.MC.enabled cfg xs\n\ngoal (1 subgoal):\n 1. \\<And>cfg xs.\n       \\<lbrakk>cfg \\<in> MDP.valid_cfg; MDP.MC.enabled cfg xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b xsa.\n                            smap (snd \\<circ> state) xs =\n                            a ## b ## xsa \\<and>\n                            local.trans a b \\<and>\n                            ((\\<exists>cfg xs.\n                                 b ## xsa =\n                                 smap (snd \\<circ> state) xs \\<and>\n                                 cfg \\<in> MDP.valid_cfg \\<and>\n                                 MDP.MC.enabled cfg xs) \\<or>\n                             stream_trans (b ## xsa))", "let ?xs = \"stl (stl xs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg xs.\n       \\<lbrakk>cfg \\<in> MDP.valid_cfg; MDP.MC.enabled cfg xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b xsa.\n                            smap (snd \\<circ> state) xs =\n                            a ## b ## xsa \\<and>\n                            local.trans a b \\<and>\n                            ((\\<exists>cfg xs.\n                                 b ## xsa =\n                                 smap (snd \\<circ> state) xs \\<and>\n                                 cfg \\<in> MDP.valid_cfg \\<and>\n                                 MDP.MC.enabled cfg xs) \\<or>\n                             stream_trans (b ## xsa))", "let ?x = \"shd xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg xs.\n       \\<lbrakk>cfg \\<in> MDP.valid_cfg; MDP.MC.enabled cfg xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b xsa.\n                            smap (snd \\<circ> state) xs =\n                            a ## b ## xsa \\<and>\n                            local.trans a b \\<and>\n                            ((\\<exists>cfg xs.\n                                 b ## xsa =\n                                 smap (snd \\<circ> state) xs \\<and>\n                                 cfg \\<in> MDP.valid_cfg \\<and>\n                                 MDP.MC.enabled cfg xs) \\<or>\n                             stream_trans (b ## xsa))", "let ?y = \"shd (stl xs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg xs.\n       \\<lbrakk>cfg \\<in> MDP.valid_cfg; MDP.MC.enabled cfg xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b xsa.\n                            smap (snd \\<circ> state) xs =\n                            a ## b ## xsa \\<and>\n                            local.trans a b \\<and>\n                            ((\\<exists>cfg xs.\n                                 b ## xsa =\n                                 smap (snd \\<circ> state) xs \\<and>\n                                 cfg \\<in> MDP.valid_cfg \\<and>\n                                 MDP.MC.enabled cfg xs) \\<or>\n                             stream_trans (b ## xsa))", "from MDP.pred_stream_cfg_on[OF prems]"], ["proof (chain)\npicking this:\n  pred_stream\n   (\\<lambda>cfg. state cfg \\<in> S \\<and> cfg \\<in> MDP.cfg_on (state cfg))\n   xs", "have *:\n    \"pred_stream (\\<lambda>cfg. state cfg \\<in> S \\<and> cfg \\<in> MDP.cfg_on (state cfg)) xs\""], ["proof (prove)\nusing this:\n  pred_stream\n   (\\<lambda>cfg. state cfg \\<in> S \\<and> cfg \\<in> MDP.cfg_on (state cfg))\n   xs\n\ngoal (1 subgoal):\n 1. pred_stream\n     (\\<lambda>cfg.\n         state cfg \\<in> S \\<and> cfg \\<in> MDP.cfg_on (state cfg))\n     xs", "."], ["proof (state)\nthis:\n  pred_stream\n   (\\<lambda>cfg. state cfg \\<in> S \\<and> cfg \\<in> MDP.cfg_on (state cfg))\n   xs\n\ngoal (1 subgoal):\n 1. \\<And>cfg xs.\n       \\<lbrakk>cfg \\<in> MDP.valid_cfg; MDP.MC.enabled cfg xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b xsa.\n                            smap (snd \\<circ> state) xs =\n                            a ## b ## xsa \\<and>\n                            local.trans a b \\<and>\n                            ((\\<exists>cfg xs.\n                                 b ## xsa =\n                                 smap (snd \\<circ> state) xs \\<and>\n                                 cfg \\<in> MDP.valid_cfg \\<and>\n                                 MDP.MC.enabled cfg xs) \\<or>\n                             stream_trans (b ## xsa))", "obtain l R l' R' where eq: \"state ?x = (l, R)\" \"state ?y = (l', R')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l R l' R'.\n        \\<lbrakk>state (shd xs) = (l, R);\n         state (shd (stl xs)) = (l', R')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  state (shd xs) = (l, R)\n  state (shd (stl xs)) = (l', R')\n\ngoal (1 subgoal):\n 1. \\<And>cfg xs.\n       \\<lbrakk>cfg \\<in> MDP.valid_cfg; MDP.MC.enabled cfg xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b xsa.\n                            smap (snd \\<circ> state) xs =\n                            a ## b ## xsa \\<and>\n                            local.trans a b \\<and>\n                            ((\\<exists>cfg xs.\n                                 b ## xsa =\n                                 smap (snd \\<circ> state) xs \\<and>\n                                 cfg \\<in> MDP.valid_cfg \\<and>\n                                 MDP.MC.enabled cfg xs) \\<or>\n                             stream_trans (b ## xsa))", "moreover"], ["proof (state)\nthis:\n  state (shd xs) = (l, R)\n  state (shd (stl xs)) = (l', R')\n\ngoal (1 subgoal):\n 1. \\<And>cfg xs.\n       \\<lbrakk>cfg \\<in> MDP.valid_cfg; MDP.MC.enabled cfg xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b xsa.\n                            smap (snd \\<circ> state) xs =\n                            a ## b ## xsa \\<and>\n                            local.trans a b \\<and>\n                            ((\\<exists>cfg xs.\n                                 b ## xsa =\n                                 smap (snd \\<circ> state) xs \\<and>\n                                 cfg \\<in> MDP.valid_cfg \\<and>\n                                 MDP.MC.enabled cfg xs) \\<or>\n                             stream_trans (b ## xsa))", "from *"], ["proof (chain)\npicking this:\n  pred_stream\n   (\\<lambda>cfg. state cfg \\<in> S \\<and> cfg \\<in> MDP.cfg_on (state cfg))\n   xs", "have \"?x \\<in> MDP.cfg_on (state ?x)\" \"?x \\<in> valid_cfg\""], ["proof (prove)\nusing this:\n  pred_stream\n   (\\<lambda>cfg. state cfg \\<in> S \\<and> cfg \\<in> MDP.cfg_on (state cfg))\n   xs\n\ngoal (1 subgoal):\n 1. shd xs \\<in> MDP.cfg_on (state (shd xs)) &&& shd xs \\<in> MDP.valid_cfg", "by (auto intro: MDP.valid_cfgI simp: stream.pred_set)"], ["proof (state)\nthis:\n  shd xs \\<in> MDP.cfg_on (state (shd xs))\n  shd xs \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. \\<And>cfg xs.\n       \\<lbrakk>cfg \\<in> MDP.valid_cfg; MDP.MC.enabled cfg xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b xsa.\n                            smap (snd \\<circ> state) xs =\n                            a ## b ## xsa \\<and>\n                            local.trans a b \\<and>\n                            ((\\<exists>cfg xs.\n                                 b ## xsa =\n                                 smap (snd \\<circ> state) xs \\<and>\n                                 cfg \\<in> MDP.valid_cfg \\<and>\n                                 MDP.MC.enabled cfg xs) \\<or>\n                             stream_trans (b ## xsa))", "moreover"], ["proof (state)\nthis:\n  shd xs \\<in> MDP.cfg_on (state (shd xs))\n  shd xs \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. \\<And>cfg xs.\n       \\<lbrakk>cfg \\<in> MDP.valid_cfg; MDP.MC.enabled cfg xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b xsa.\n                            smap (snd \\<circ> state) xs =\n                            a ## b ## xsa \\<and>\n                            local.trans a b \\<and>\n                            ((\\<exists>cfg xs.\n                                 b ## xsa =\n                                 smap (snd \\<circ> state) xs \\<and>\n                                 cfg \\<in> MDP.valid_cfg \\<and>\n                                 MDP.MC.enabled cfg xs) \\<or>\n                             stream_trans (b ## xsa))", "from prems(2)"], ["proof (chain)\npicking this:\n  MDP.MC.enabled cfg xs", "have \"?y \\<in> K_cfg ?x\""], ["proof (prove)\nusing this:\n  MDP.MC.enabled cfg xs\n\ngoal (1 subgoal):\n 1. shd (stl xs) \\<in> set_pmf (K_cfg (shd xs))", "by (auto elim: MDP.MC.enabled.cases)"], ["proof (state)\nthis:\n  shd (stl xs) \\<in> set_pmf (K_cfg (shd xs))\n\ngoal (1 subgoal):\n 1. \\<And>cfg xs.\n       \\<lbrakk>cfg \\<in> MDP.valid_cfg; MDP.MC.enabled cfg xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b xsa.\n                            smap (snd \\<circ> state) xs =\n                            a ## b ## xsa \\<and>\n                            local.trans a b \\<and>\n                            ((\\<exists>cfg xs.\n                                 b ## xsa =\n                                 smap (snd \\<circ> state) xs \\<and>\n                                 cfg \\<in> MDP.valid_cfg \\<and>\n                                 MDP.MC.enabled cfg xs) \\<or>\n                             stream_trans (b ## xsa))", "ultimately"], ["proof (chain)\npicking this:\n  state (shd xs) = (l, R)\n  state (shd (stl xs)) = (l', R')\n  shd xs \\<in> MDP.cfg_on (state (shd xs))\n  shd xs \\<in> MDP.valid_cfg\n  shd (stl xs) \\<in> set_pmf (K_cfg (shd xs))", "have \"trans R R'\""], ["proof (prove)\nusing this:\n  state (shd xs) = (l, R)\n  state (shd (stl xs)) = (l', R')\n  shd xs \\<in> MDP.cfg_on (state (shd xs))\n  shd xs \\<in> MDP.valid_cfg\n  shd (stl xs) \\<in> set_pmf (K_cfg (shd xs))\n\ngoal (1 subgoal):\n 1. local.trans R R'", "by (intro K_cfg_trans[where cfg = ?x and cfg' = ?y and l = l and l' = l']) metis+"], ["proof (state)\nthis:\n  local.trans R R'\n\ngoal (1 subgoal):\n 1. \\<And>cfg xs.\n       \\<lbrakk>cfg \\<in> MDP.valid_cfg; MDP.MC.enabled cfg xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b xsa.\n                            smap (snd \\<circ> state) xs =\n                            a ## b ## xsa \\<and>\n                            local.trans a b \\<and>\n                            ((\\<exists>cfg xs.\n                                 b ## xsa =\n                                 smap (snd \\<circ> state) xs \\<and>\n                                 cfg \\<in> MDP.valid_cfg \\<and>\n                                 MDP.MC.enabled cfg xs) \\<or>\n                             stream_trans (b ## xsa))", "with \\<open>?x \\<in> valid_cfg\\<close> prems(2)"], ["proof (chain)\npicking this:\n  shd xs \\<in> MDP.valid_cfg\n  MDP.MC.enabled cfg xs\n  local.trans R R'", "show ?case"], ["proof (prove)\nusing this:\n  shd xs \\<in> MDP.valid_cfg\n  MDP.MC.enabled cfg xs\n  local.trans R R'\n\ngoal (1 subgoal):\n 1. \\<exists>a b xs.\n       smap (snd \\<circ> state) xs = a ## b ## xs \\<and>\n       local.trans a b \\<and>\n       ((\\<exists>cfg xsa.\n            b ## xs = smap (snd \\<circ> state) xsa \\<and>\n            cfg \\<in> MDP.valid_cfg \\<and> MDP.MC.enabled cfg xsa) \\<or>\n        stream_trans (b ## xs))", "apply (inst_existentials R R' \"smap (snd o state) ?xs\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>shd xs \\<in> MDP.valid_cfg; MDP.MC.enabled cfg xs;\n     local.trans R R'\\<rbrakk>\n    \\<Longrightarrow> smap (snd \\<circ> state) xs =\n                      R ## R' ## smap (snd \\<circ> state) (stl (stl xs))\n 2. \\<lbrakk>shd xs \\<in> MDP.valid_cfg; MDP.MC.enabled cfg xs;\n     local.trans R R'\\<rbrakk>\n    \\<Longrightarrow> local.trans R R'\n 3. \\<lbrakk>shd xs \\<in> MDP.valid_cfg; MDP.MC.enabled cfg xs;\n     local.trans R R'\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>cfg xs.\n                          R' ## smap (snd \\<circ> state) (stl (stl xs)) =\n                          smap (snd \\<circ> state) xs \\<and>\n                          cfg \\<in> MDP.valid_cfg \\<and>\n                          MDP.MC.enabled cfg xs) \\<or>\n                      stream_trans\n                       (R' ## smap (snd \\<circ> state) (stl (stl xs)))", "apply (simp add: eq; fail)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>shd xs \\<in> MDP.valid_cfg; MDP.MC.enabled cfg xs;\n     local.trans R R'\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>cfg xs.\n                          R' ## smap (snd \\<circ> state) (stl (stl xs)) =\n                          smap (snd \\<circ> state) xs \\<and>\n                          cfg \\<in> MDP.valid_cfg \\<and>\n                          MDP.MC.enabled cfg xs) \\<or>\n                      stream_trans\n                       (R' ## smap (snd \\<circ> state) (stl (stl xs)))", "apply (rule disjI1, inst_existentials ?x \"stl xs\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>shd xs \\<in> MDP.valid_cfg; MDP.MC.enabled cfg xs;\n     local.trans R R'\\<rbrakk>\n    \\<Longrightarrow> R' ## smap (snd \\<circ> state) (stl (stl xs)) =\n                      smap (snd \\<circ> state) (stl xs)\n 2. \\<lbrakk>shd xs \\<in> MDP.valid_cfg; MDP.MC.enabled cfg xs;\n     local.trans R R'\\<rbrakk>\n    \\<Longrightarrow> shd xs \\<in> MDP.valid_cfg\n 3. \\<lbrakk>shd xs \\<in> MDP.valid_cfg; MDP.MC.enabled cfg xs;\n     local.trans R R'\\<rbrakk>\n    \\<Longrightarrow> MDP.MC.enabled (shd xs) (stl xs)", "by (auto simp: eq elim: MDP.MC.enabled.cases)"], ["proof (state)\nthis:\n  \\<exists>a b xs.\n     smap (snd \\<circ> state) xs = a ## b ## xs \\<and>\n     local.trans a b \\<and>\n     ((\\<exists>cfg xsa.\n          b ## xs = smap (snd \\<circ> state) xsa \\<and>\n          cfg \\<in> MDP.valid_cfg \\<and> MDP.MC.enabled cfg xsa) \\<or>\n      stream_trans (b ## xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma stream_trans_trans:\n  assumes \"stream_trans xs\"\n  shows \"trans (xs !! i) (stl xs !! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.trans (xs !! i) (stl xs !! i)", "using pairwise_Suc assms"], ["proof (prove)\nusing this:\n  PTA_Reachability.pairwise ?P ?xs \\<Longrightarrow>\n  ?P (?xs !! ?i) (?xs !! Suc ?i)\n  stream_trans xs\n\ngoal (1 subgoal):\n 1. local.trans (xs !! i) (stl xs !! i)", "by auto"], ["", "lemma trans_eq_elapsed:\n  assumes \"trans u u'\" \"u \\<in> V\"\n  shows \"eq_elapsed u u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_elapsed u u'", "using assms"], ["proof (prove)\nusing this:\n  local.trans u u'\n  u \\<in> V\n\ngoal (1 subgoal):\n 1. eq_elapsed u u'", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>u \\<in> V; (0::'a) \\<le> t; u' = u \\<oplus> t\\<rbrakk>\n       \\<Longrightarrow> eq_elapsed u u'\n 2. \\<And>l.\n       \\<lbrakk>u \\<in> V; set l \\<subseteq> \\<X>;\n        u' = [l\\<rightarrow>(0::'a)]u\\<rbrakk>\n       \\<Longrightarrow> eq_elapsed u u'\n 3. \\<lbrakk>u \\<in> V; u = u'\\<rbrakk> \\<Longrightarrow> eq_elapsed u u'", "case (succ t)"], ["proof (state)\nthis:\n  (0::'a) \\<le> t\n  u' = u \\<oplus> t\n\ngoal (3 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>u \\<in> V; (0::'a) \\<le> t; u' = u \\<oplus> t\\<rbrakk>\n       \\<Longrightarrow> eq_elapsed u u'\n 2. \\<And>l.\n       \\<lbrakk>u \\<in> V; set l \\<subseteq> \\<X>;\n        u' = [l\\<rightarrow>(0::'a)]u\\<rbrakk>\n       \\<Longrightarrow> eq_elapsed u u'\n 3. \\<lbrakk>u \\<in> V; u = u'\\<rbrakk> \\<Longrightarrow> eq_elapsed u u'", "with finite(1)"], ["proof (chain)\npicking this:\n  finite \\<X>\n  (0::'a) \\<le> t\n  u' = u \\<oplus> t", "show ?thesis"], ["proof (prove)\nusing this:\n  finite \\<X>\n  (0::'a) \\<le> t\n  u' = u \\<oplus> t\n\ngoal (1 subgoal):\n 1. eq_elapsed u u'", "by (auto simp: cval_add_def elapsed_def max_def eq_elapsed_def)"], ["proof (state)\nthis:\n  eq_elapsed u u'\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>u \\<in> V; set l \\<subseteq> \\<X>;\n        u' = [l\\<rightarrow>(0::'a)]u\\<rbrakk>\n       \\<Longrightarrow> eq_elapsed u u'\n 2. \\<lbrakk>u \\<in> V; u = u'\\<rbrakk> \\<Longrightarrow> eq_elapsed u u'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>u \\<in> V; set l \\<subseteq> \\<X>;\n        u' = [l\\<rightarrow>(0::'a)]u\\<rbrakk>\n       \\<Longrightarrow> eq_elapsed u u'\n 2. \\<lbrakk>u \\<in> V; u = u'\\<rbrakk> \\<Longrightarrow> eq_elapsed u u'", "case prems: (reset l)"], ["proof (state)\nthis:\n  set l \\<subseteq> \\<X>\n  u' = [l\\<rightarrow>(0::'a)]u\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>u \\<in> V; set l \\<subseteq> \\<X>;\n        u' = [l\\<rightarrow>(0::'a)]u\\<rbrakk>\n       \\<Longrightarrow> eq_elapsed u u'\n 2. \\<lbrakk>u \\<in> V; u = u'\\<rbrakk> \\<Longrightarrow> eq_elapsed u u'", "then"], ["proof (chain)\npicking this:\n  set l \\<subseteq> \\<X>\n  u' = [l\\<rightarrow>(0::'a)]u", "have \"u' c - u c \\<le> 0\" if \"c \\<in> \\<X>\" for c"], ["proof (prove)\nusing this:\n  set l \\<subseteq> \\<X>\n  u' = [l\\<rightarrow>(0::'a)]u\n\ngoal (1 subgoal):\n 1. u' c - u c \\<le> (0::'a)", "using that \\<open>u \\<in> V\\<close>"], ["proof (prove)\nusing this:\n  set l \\<subseteq> \\<X>\n  u' = [l\\<rightarrow>(0::'a)]u\n  c \\<in> \\<X>\n  u \\<in> V\n\ngoal (1 subgoal):\n 1. u' c - u c \\<le> (0::'a)", "by (cases \"c \\<in> set l\") (auto simp: V_def)"], ["proof (state)\nthis:\n  ?c8 \\<in> \\<X> \\<Longrightarrow> u' ?c8 - u ?c8 \\<le> (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>u \\<in> V; set l \\<subseteq> \\<X>;\n        u' = [l\\<rightarrow>(0::'a)]u\\<rbrakk>\n       \\<Longrightarrow> eq_elapsed u u'\n 2. \\<lbrakk>u \\<in> V; u = u'\\<rbrakk> \\<Longrightarrow> eq_elapsed u u'", "then"], ["proof (chain)\npicking this:\n  ?c8 \\<in> \\<X> \\<Longrightarrow> u' ?c8 - u ?c8 \\<le> (0::'a)", "have \"elapsed u u' = 0\""], ["proof (prove)\nusing this:\n  ?c8 \\<in> \\<X> \\<Longrightarrow> u' ?c8 - u ?c8 \\<le> (0::'a)\n\ngoal (1 subgoal):\n 1. elapsed u u' = (0::'a)", "unfolding elapsed_def"], ["proof (prove)\nusing this:\n  ?c8 \\<in> \\<X> \\<Longrightarrow> u' ?c8 - u ?c8 \\<le> (0::'a)\n\ngoal (1 subgoal):\n 1. Max ({u' c - u c |c. c \\<in> \\<X>} \\<union> {0::'a}) = (0::'a)", "using finite(1)"], ["proof (prove)\nusing this:\n  ?c8 \\<in> \\<X> \\<Longrightarrow> u' ?c8 - u ?c8 \\<le> (0::'a)\n  finite \\<X>\n\ngoal (1 subgoal):\n 1. Max ({u' c - u c |c. c \\<in> \\<X>} \\<union> {0::'a}) = (0::'a)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>c. c \\<in> \\<X> \\<Longrightarrow> u' c \\<le> u c;\n     finite \\<X>\\<rbrakk>\n    \\<Longrightarrow> Max (insert (0::'a) {u' c - u c |c. c \\<in> \\<X>}) =\n                      (0::'a)", "apply (subst Max_insert2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>c. c \\<in> \\<X> \\<Longrightarrow> u' c \\<le> u c;\n     finite \\<X>\\<rbrakk>\n    \\<Longrightarrow> finite {u' c - u c |c. c \\<in> \\<X>}\n 2. \\<And>b.\n       \\<lbrakk>\\<And>c. c \\<in> \\<X> \\<Longrightarrow> u' c \\<le> u c;\n        finite \\<X>; b \\<in> {u' c - u c |c. c \\<in> \\<X>}\\<rbrakk>\n       \\<Longrightarrow> b \\<le> (0::'a)\n 3. \\<lbrakk>\\<And>c. c \\<in> \\<X> \\<Longrightarrow> u' c \\<le> u c;\n     finite \\<X>\\<rbrakk>\n    \\<Longrightarrow> (0::'a) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  elapsed u u' = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>u \\<in> V; set l \\<subseteq> \\<X>;\n        u' = [l\\<rightarrow>(0::'a)]u\\<rbrakk>\n       \\<Longrightarrow> eq_elapsed u u'\n 2. \\<lbrakk>u \\<in> V; u = u'\\<rbrakk> \\<Longrightarrow> eq_elapsed u u'", "then"], ["proof (chain)\npicking this:\n  elapsed u u' = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  elapsed u u' = (0::'a)\n\ngoal (1 subgoal):\n 1. eq_elapsed u u'", "by (auto simp: eq_elapsed_def)"], ["proof (state)\nthis:\n  eq_elapsed u u'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> V; u = u'\\<rbrakk> \\<Longrightarrow> eq_elapsed u u'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> V; u = u'\\<rbrakk> \\<Longrightarrow> eq_elapsed u u'", "case id"], ["proof (state)\nthis:\n  u = u'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> V; u = u'\\<rbrakk> \\<Longrightarrow> eq_elapsed u u'", "then"], ["proof (chain)\npicking this:\n  u = u'", "show ?thesis"], ["proof (prove)\nusing this:\n  u = u'\n\ngoal (1 subgoal):\n 1. eq_elapsed u u'", "using finite(1)"], ["proof (prove)\nusing this:\n  u = u'\n  finite \\<X>\n\ngoal (1 subgoal):\n 1. eq_elapsed u u'", "by (auto simp: Max_gr_iff elapsed_def eq_elapsed_def)"], ["proof (state)\nthis:\n  eq_elapsed u u'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pairwise_trans_eq_elapsed:\n  assumes \"stream_trans xs\" \"pred_stream (\\<lambda> u. u \\<in> V) xs\"\n  shows \"pairwise eq_elapsed xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PTA_Reachability.pairwise eq_elapsed xs", "using trans_eq_elapsed assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>local.trans ?u ?u'; ?u \\<in> V\\<rbrakk>\n  \\<Longrightarrow> eq_elapsed ?u ?u'\n  stream_trans xs\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n\ngoal (1 subgoal):\n 1. PTA_Reachability.pairwise eq_elapsed xs", "by (auto intro: pairwise_mp simp: stream.pred_set)"], ["", "lemma not_reset_dur:\n  assumes \"\\<forall>k>i. k \\<le> j \\<longrightarrow> \\<not> zero c ([xs !! k]\\<^sub>\\<R>)\" \"j \\<ge> i\" \"c \\<in> \\<X>\" \"stream_trans xs\"\n    \"\\<forall> i. eq_elapsed (xs !! i) (xs !! Suc i)\" \"\\<forall> i. xs !! i \\<in> V\"\n  shows \"dur xs j - dur xs i = (xs !! j) c - (xs !! i) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dur xs j - dur xs i = (xs !! j) c - (xs !! i) c", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>k>i.\n     k \\<le> j \\<longrightarrow> \\<not> zero c ([xs !! k]\\<^sub>\\<R>)\n  i \\<le> j\n  c \\<in> \\<X>\n  stream_trans xs\n  \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\n  \\<forall>i. xs !! i \\<in> V\n\ngoal (1 subgoal):\n 1. dur xs j - dur xs i = (xs !! j) c - (xs !! i) c", "proof (induction j)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>k>i.\n                k \\<le> 0 \\<longrightarrow>\n                \\<not> zero c ([xs !! k]\\<^sub>\\<R>);\n     i \\<le> 0; c \\<in> \\<X>; stream_trans xs;\n     \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i);\n     \\<forall>i. xs !! i \\<in> V\\<rbrakk>\n    \\<Longrightarrow> dur xs 0 - dur xs i = (xs !! 0) c - (xs !! i) c\n 2. \\<And>j.\n       \\<lbrakk>\\<lbrakk>\\<forall>k>i.\n                            k \\<le> j \\<longrightarrow>\n                            \\<not> zero c ([xs !! k]\\<^sub>\\<R>);\n                 i \\<le> j; c \\<in> \\<X>; stream_trans xs;\n                 \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i);\n                 \\<forall>i. xs !! i \\<in> V\\<rbrakk>\n                \\<Longrightarrow> dur xs j - dur xs i =\n                                  (xs !! j) c - (xs !! i) c;\n        \\<forall>k>i.\n           k \\<le> Suc j \\<longrightarrow>\n           \\<not> zero c ([xs !! k]\\<^sub>\\<R>);\n        i \\<le> Suc j; c \\<in> \\<X>; stream_trans xs;\n        \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i);\n        \\<forall>i. xs !! i \\<in> V\\<rbrakk>\n       \\<Longrightarrow> dur xs (Suc j) - dur xs i =\n                         (xs !! Suc j) c - (xs !! i) c", "case 0"], ["proof (state)\nthis:\n  \\<forall>k>i.\n     k \\<le> 0 \\<longrightarrow> \\<not> zero c ([xs !! k]\\<^sub>\\<R>)\n  i \\<le> 0\n  c \\<in> \\<X>\n  stream_trans xs\n  \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\n  \\<forall>i. xs !! i \\<in> V\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>k>i.\n                k \\<le> 0 \\<longrightarrow>\n                \\<not> zero c ([xs !! k]\\<^sub>\\<R>);\n     i \\<le> 0; c \\<in> \\<X>; stream_trans xs;\n     \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i);\n     \\<forall>i. xs !! i \\<in> V\\<rbrakk>\n    \\<Longrightarrow> dur xs 0 - dur xs i = (xs !! 0) c - (xs !! i) c\n 2. \\<And>j.\n       \\<lbrakk>\\<lbrakk>\\<forall>k>i.\n                            k \\<le> j \\<longrightarrow>\n                            \\<not> zero c ([xs !! k]\\<^sub>\\<R>);\n                 i \\<le> j; c \\<in> \\<X>; stream_trans xs;\n                 \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i);\n                 \\<forall>i. xs !! i \\<in> V\\<rbrakk>\n                \\<Longrightarrow> dur xs j - dur xs i =\n                                  (xs !! j) c - (xs !! i) c;\n        \\<forall>k>i.\n           k \\<le> Suc j \\<longrightarrow>\n           \\<not> zero c ([xs !! k]\\<^sub>\\<R>);\n        i \\<le> Suc j; c \\<in> \\<X>; stream_trans xs;\n        \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i);\n        \\<forall>i. xs !! i \\<in> V\\<rbrakk>\n       \\<Longrightarrow> dur xs (Suc j) - dur xs i =\n                         (xs !! Suc j) c - (xs !! i) c", "then"], ["proof (chain)\npicking this:\n  \\<forall>k>i.\n     k \\<le> 0 \\<longrightarrow> \\<not> zero c ([xs !! k]\\<^sub>\\<R>)\n  i \\<le> 0\n  c \\<in> \\<X>\n  stream_trans xs\n  \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\n  \\<forall>i. xs !! i \\<in> V", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>k>i.\n     k \\<le> 0 \\<longrightarrow> \\<not> zero c ([xs !! k]\\<^sub>\\<R>)\n  i \\<le> 0\n  c \\<in> \\<X>\n  stream_trans xs\n  \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\n  \\<forall>i. xs !! i \\<in> V\n\ngoal (1 subgoal):\n 1. dur xs 0 - dur xs i = (xs !! 0) c - (xs !! i) c", "by simp"], ["proof (state)\nthis:\n  dur xs 0 - dur xs i = (xs !! 0) c - (xs !! i) c\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>\\<lbrakk>\\<forall>k>i.\n                            k \\<le> j \\<longrightarrow>\n                            \\<not> zero c ([xs !! k]\\<^sub>\\<R>);\n                 i \\<le> j; c \\<in> \\<X>; stream_trans xs;\n                 \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i);\n                 \\<forall>i. xs !! i \\<in> V\\<rbrakk>\n                \\<Longrightarrow> dur xs j - dur xs i =\n                                  (xs !! j) c - (xs !! i) c;\n        \\<forall>k>i.\n           k \\<le> Suc j \\<longrightarrow>\n           \\<not> zero c ([xs !! k]\\<^sub>\\<R>);\n        i \\<le> Suc j; c \\<in> \\<X>; stream_trans xs;\n        \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i);\n        \\<forall>i. xs !! i \\<in> V\\<rbrakk>\n       \\<Longrightarrow> dur xs (Suc j) - dur xs i =\n                         (xs !! Suc j) c - (xs !! i) c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>\\<lbrakk>\\<forall>k>i.\n                            k \\<le> j \\<longrightarrow>\n                            \\<not> zero c ([xs !! k]\\<^sub>\\<R>);\n                 i \\<le> j; c \\<in> \\<X>; stream_trans xs;\n                 \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i);\n                 \\<forall>i. xs !! i \\<in> V\\<rbrakk>\n                \\<Longrightarrow> dur xs j - dur xs i =\n                                  (xs !! j) c - (xs !! i) c;\n        \\<forall>k>i.\n           k \\<le> Suc j \\<longrightarrow>\n           \\<not> zero c ([xs !! k]\\<^sub>\\<R>);\n        i \\<le> Suc j; c \\<in> \\<X>; stream_trans xs;\n        \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i);\n        \\<forall>i. xs !! i \\<in> V\\<rbrakk>\n       \\<Longrightarrow> dur xs (Suc j) - dur xs i =\n                         (xs !! Suc j) c - (xs !! i) c", "case (Suc j)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>k>i.\n              k \\<le> j \\<longrightarrow>\n              \\<not> zero c ([xs !! k]\\<^sub>\\<R>);\n   i \\<le> j; c \\<in> \\<X>; stream_trans xs;\n   \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i);\n   \\<forall>i. xs !! i \\<in> V\\<rbrakk>\n  \\<Longrightarrow> dur xs j - dur xs i = (xs !! j) c - (xs !! i) c\n  \\<forall>k>i.\n     k \\<le> Suc j \\<longrightarrow> \\<not> zero c ([xs !! k]\\<^sub>\\<R>)\n  i \\<le> Suc j\n  c \\<in> \\<X>\n  stream_trans xs\n  \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\n  \\<forall>i. xs !! i \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>\\<lbrakk>\\<forall>k>i.\n                            k \\<le> j \\<longrightarrow>\n                            \\<not> zero c ([xs !! k]\\<^sub>\\<R>);\n                 i \\<le> j; c \\<in> \\<X>; stream_trans xs;\n                 \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i);\n                 \\<forall>i. xs !! i \\<in> V\\<rbrakk>\n                \\<Longrightarrow> dur xs j - dur xs i =\n                                  (xs !! j) c - (xs !! i) c;\n        \\<forall>k>i.\n           k \\<le> Suc j \\<longrightarrow>\n           \\<not> zero c ([xs !! k]\\<^sub>\\<R>);\n        i \\<le> Suc j; c \\<in> \\<X>; stream_trans xs;\n        \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i);\n        \\<forall>i. xs !! i \\<in> V\\<rbrakk>\n       \\<Longrightarrow> dur xs (Suc j) - dur xs i =\n                         (xs !! Suc j) c - (xs !! i) c", "from stream_trans_trans[OF Suc.prems(4)]"], ["proof (chain)\npicking this:\n  local.trans (xs !! ?i) (stl xs !! ?i)", "have trans: \"trans (xs !! j) (xs !! Suc j)\""], ["proof (prove)\nusing this:\n  local.trans (xs !! ?i) (stl xs !! ?i)\n\ngoal (1 subgoal):\n 1. local.trans (xs !! j) (xs !! Suc j)", "by auto"], ["proof (state)\nthis:\n  local.trans (xs !! j) (xs !! Suc j)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>\\<lbrakk>\\<forall>k>i.\n                            k \\<le> j \\<longrightarrow>\n                            \\<not> zero c ([xs !! k]\\<^sub>\\<R>);\n                 i \\<le> j; c \\<in> \\<X>; stream_trans xs;\n                 \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i);\n                 \\<forall>i. xs !! i \\<in> V\\<rbrakk>\n                \\<Longrightarrow> dur xs j - dur xs i =\n                                  (xs !! j) c - (xs !! i) c;\n        \\<forall>k>i.\n           k \\<le> Suc j \\<longrightarrow>\n           \\<not> zero c ([xs !! k]\\<^sub>\\<R>);\n        i \\<le> Suc j; c \\<in> \\<X>; stream_trans xs;\n        \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i);\n        \\<forall>i. xs !! i \\<in> V\\<rbrakk>\n       \\<Longrightarrow> dur xs (Suc j) - dur xs i =\n                         (xs !! Suc j) c - (xs !! i) c", "from Suc.prems"], ["proof (chain)\npicking this:\n  \\<forall>k>i.\n     k \\<le> Suc j \\<longrightarrow> \\<not> zero c ([xs !! k]\\<^sub>\\<R>)\n  i \\<le> Suc j\n  c \\<in> \\<X>\n  stream_trans xs\n  \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\n  \\<forall>i. xs !! i \\<in> V", "have *:\n    \"\\<not> zero c ([xs !! Suc j]\\<^sub>\\<R>)\" \"eq_elapsed (xs !! j) (xs !! Suc j)\" if \"Suc j > i\""], ["proof (prove)\nusing this:\n  \\<forall>k>i.\n     k \\<le> Suc j \\<longrightarrow> \\<not> zero c ([xs !! k]\\<^sub>\\<R>)\n  i \\<le> Suc j\n  c \\<in> \\<X>\n  stream_trans xs\n  \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\n  \\<forall>i. xs !! i \\<in> V\n\ngoal (1 subgoal):\n 1. \\<not> zero c ([xs !! Suc j]\\<^sub>\\<R>) &&&\n    eq_elapsed (xs !! j) (xs !! Suc j)", "using that"], ["proof (prove)\nusing this:\n  \\<forall>k>i.\n     k \\<le> Suc j \\<longrightarrow> \\<not> zero c ([xs !! k]\\<^sub>\\<R>)\n  i \\<le> Suc j\n  c \\<in> \\<X>\n  stream_trans xs\n  \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\n  \\<forall>i. xs !! i \\<in> V\n  i < Suc j\n\ngoal (1 subgoal):\n 1. \\<not> zero c ([xs !! Suc j]\\<^sub>\\<R>) &&&\n    eq_elapsed (xs !! j) (xs !! Suc j)", "by auto"], ["proof (state)\nthis:\n  i < Suc j \\<Longrightarrow> \\<not> zero c ([xs !! Suc j]\\<^sub>\\<R>)\n  i < Suc j \\<Longrightarrow> eq_elapsed (xs !! j) (xs !! Suc j)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>\\<lbrakk>\\<forall>k>i.\n                            k \\<le> j \\<longrightarrow>\n                            \\<not> zero c ([xs !! k]\\<^sub>\\<R>);\n                 i \\<le> j; c \\<in> \\<X>; stream_trans xs;\n                 \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i);\n                 \\<forall>i. xs !! i \\<in> V\\<rbrakk>\n                \\<Longrightarrow> dur xs j - dur xs i =\n                                  (xs !! j) c - (xs !! i) c;\n        \\<forall>k>i.\n           k \\<le> Suc j \\<longrightarrow>\n           \\<not> zero c ([xs !! k]\\<^sub>\\<R>);\n        i \\<le> Suc j; c \\<in> \\<X>; stream_trans xs;\n        \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i);\n        \\<forall>i. xs !! i \\<in> V\\<rbrakk>\n       \\<Longrightarrow> dur xs (Suc j) - dur xs i =\n                         (xs !! Suc j) c - (xs !! i) c", "from Suc.prems(6)"], ["proof (chain)\npicking this:\n  \\<forall>i. xs !! i \\<in> V", "have \"xs !! j \\<in> V\" \"xs !! Suc j \\<in> V\""], ["proof (prove)\nusing this:\n  \\<forall>i. xs !! i \\<in> V\n\ngoal (1 subgoal):\n 1. xs !! j \\<in> V &&& xs !! Suc j \\<in> V", "by blast+"], ["proof (state)\nthis:\n  xs !! j \\<in> V\n  xs !! Suc j \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>\\<lbrakk>\\<forall>k>i.\n                            k \\<le> j \\<longrightarrow>\n                            \\<not> zero c ([xs !! k]\\<^sub>\\<R>);\n                 i \\<le> j; c \\<in> \\<X>; stream_trans xs;\n                 \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i);\n                 \\<forall>i. xs !! i \\<in> V\\<rbrakk>\n                \\<Longrightarrow> dur xs j - dur xs i =\n                                  (xs !! j) c - (xs !! i) c;\n        \\<forall>k>i.\n           k \\<le> Suc j \\<longrightarrow>\n           \\<not> zero c ([xs !! k]\\<^sub>\\<R>);\n        i \\<le> Suc j; c \\<in> \\<X>; stream_trans xs;\n        \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i);\n        \\<forall>i. xs !! i \\<in> V\\<rbrakk>\n       \\<Longrightarrow> dur xs (Suc j) - dur xs i =\n                         (xs !! Suc j) c - (xs !! i) c", "then"], ["proof (chain)\npicking this:\n  xs !! j \\<in> V\n  xs !! Suc j \\<in> V", "have regions: \"[xs !! j]\\<^sub>\\<R> \\<in> \\<R>\" \"[xs !! Suc j]\\<^sub>\\<R> \\<in> \\<R>\""], ["proof (prove)\nusing this:\n  xs !! j \\<in> V\n  xs !! Suc j \\<in> V\n\ngoal (1 subgoal):\n 1. [xs !! j]\\<^sub>\\<R> \\<in> \\<R> &&& [xs !! Suc j]\\<^sub>\\<R> \\<in> \\<R>", "by auto"], ["proof (state)\nthis:\n  [xs !! j]\\<^sub>\\<R> \\<in> \\<R>\n  [xs !! Suc j]\\<^sub>\\<R> \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>\\<lbrakk>\\<forall>k>i.\n                            k \\<le> j \\<longrightarrow>\n                            \\<not> zero c ([xs !! k]\\<^sub>\\<R>);\n                 i \\<le> j; c \\<in> \\<X>; stream_trans xs;\n                 \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i);\n                 \\<forall>i. xs !! i \\<in> V\\<rbrakk>\n                \\<Longrightarrow> dur xs j - dur xs i =\n                                  (xs !! j) c - (xs !! i) c;\n        \\<forall>k>i.\n           k \\<le> Suc j \\<longrightarrow>\n           \\<not> zero c ([xs !! k]\\<^sub>\\<R>);\n        i \\<le> Suc j; c \\<in> \\<X>; stream_trans xs;\n        \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i);\n        \\<forall>i. xs !! i \\<in> V\\<rbrakk>\n       \\<Longrightarrow> dur xs (Suc j) - dur xs i =\n                         (xs !! Suc j) c - (xs !! i) c", "from trans"], ["proof (chain)\npicking this:\n  local.trans (xs !! j) (xs !! Suc j)", "have \"(xs !! Suc j) c - (xs !! j) c \\<ge> 0\" if \"Suc j > i\""], ["proof (prove)\nusing this:\n  local.trans (xs !! j) (xs !! Suc j)\n\ngoal (1 subgoal):\n 1. 0 \\<le> (xs !! Suc j) c - (xs !! j) c", "proof (cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>0 \\<le> t; xs !! Suc j = xs !! j \\<oplus> t\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> (xs !! Suc j) c - (xs !! j) c\n 2. \\<And>l.\n       \\<lbrakk>set l \\<subseteq> \\<X>;\n        xs !! Suc j = [l\\<rightarrow>0]xs !! j\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> (xs !! Suc j) c - (xs !! j) c\n 3. xs !! j = xs !! Suc j \\<Longrightarrow>\n    0 \\<le> (xs !! Suc j) c - (xs !! j) c", "case succ"], ["proof (state)\nthis:\n  0 \\<le> t_\n  xs !! Suc j = xs !! j \\<oplus> t_\n\ngoal (3 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>0 \\<le> t; xs !! Suc j = xs !! j \\<oplus> t\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> (xs !! Suc j) c - (xs !! j) c\n 2. \\<And>l.\n       \\<lbrakk>set l \\<subseteq> \\<X>;\n        xs !! Suc j = [l\\<rightarrow>0]xs !! j\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> (xs !! Suc j) c - (xs !! j) c\n 3. xs !! j = xs !! Suc j \\<Longrightarrow>\n    0 \\<le> (xs !! Suc j) c - (xs !! j) c", "with regions"], ["proof (chain)\npicking this:\n  [xs !! j]\\<^sub>\\<R> \\<in> \\<R>\n  [xs !! Suc j]\\<^sub>\\<R> \\<in> \\<R>\n  0 \\<le> t_\n  xs !! Suc j = xs !! j \\<oplus> t_", "show ?thesis"], ["proof (prove)\nusing this:\n  [xs !! j]\\<^sub>\\<R> \\<in> \\<R>\n  [xs !! Suc j]\\<^sub>\\<R> \\<in> \\<R>\n  0 \\<le> t_\n  xs !! Suc j = xs !! j \\<oplus> t_\n\ngoal (1 subgoal):\n 1. 0 \\<le> (xs !! Suc j) c - (xs !! j) c", "by (auto simp: cval_add_def)"], ["proof (state)\nthis:\n  0 \\<le> (xs !! Suc j) c - (xs !! j) c\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>set l \\<subseteq> \\<X>;\n        xs !! Suc j = [l\\<rightarrow>0]xs !! j\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> (xs !! Suc j) c - (xs !! j) c\n 2. xs !! j = xs !! Suc j \\<Longrightarrow>\n    0 \\<le> (xs !! Suc j) c - (xs !! j) c", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>set l \\<subseteq> \\<X>;\n        xs !! Suc j = [l\\<rightarrow>0]xs !! j\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> (xs !! Suc j) c - (xs !! j) c\n 2. xs !! j = xs !! Suc j \\<Longrightarrow>\n    0 \\<le> (xs !! Suc j) c - (xs !! j) c", "case prems: (reset l)"], ["proof (state)\nthis:\n  set l \\<subseteq> \\<X>\n  xs !! Suc j = [l\\<rightarrow>0]xs !! j\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>set l \\<subseteq> \\<X>;\n        xs !! Suc j = [l\\<rightarrow>0]xs !! j\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> (xs !! Suc j) c - (xs !! j) c\n 2. xs !! j = xs !! Suc j \\<Longrightarrow>\n    0 \\<le> (xs !! Suc j) c - (xs !! j) c", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (xs !! Suc j) c - (xs !! j) c", "proof (cases \"c \\<in> set l\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c \\<in> set l \\<Longrightarrow> 0 \\<le> (xs !! Suc j) c - (xs !! j) c\n 2. c \\<notin> set l \\<Longrightarrow> 0 \\<le> (xs !! Suc j) c - (xs !! j) c", "case False"], ["proof (state)\nthis:\n  c \\<notin> set l\n\ngoal (2 subgoals):\n 1. c \\<in> set l \\<Longrightarrow> 0 \\<le> (xs !! Suc j) c - (xs !! j) c\n 2. c \\<notin> set l \\<Longrightarrow> 0 \\<le> (xs !! Suc j) c - (xs !! j) c", "with prems"], ["proof (chain)\npicking this:\n  set l \\<subseteq> \\<X>\n  xs !! Suc j = [l\\<rightarrow>0]xs !! j\n  c \\<notin> set l", "show ?thesis"], ["proof (prove)\nusing this:\n  set l \\<subseteq> \\<X>\n  xs !! Suc j = [l\\<rightarrow>0]xs !! j\n  c \\<notin> set l\n\ngoal (1 subgoal):\n 1. 0 \\<le> (xs !! Suc j) c - (xs !! j) c", "by auto"], ["proof (state)\nthis:\n  0 \\<le> (xs !! Suc j) c - (xs !! j) c\n\ngoal (1 subgoal):\n 1. c \\<in> set l \\<Longrightarrow> 0 \\<le> (xs !! Suc j) c - (xs !! j) c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<in> set l \\<Longrightarrow> 0 \\<le> (xs !! Suc j) c - (xs !! j) c", "case True"], ["proof (state)\nthis:\n  c \\<in> set l\n\ngoal (1 subgoal):\n 1. c \\<in> set l \\<Longrightarrow> 0 \\<le> (xs !! Suc j) c - (xs !! j) c", "with prems"], ["proof (chain)\npicking this:\n  set l \\<subseteq> \\<X>\n  xs !! Suc j = [l\\<rightarrow>0]xs !! j\n  c \\<in> set l", "have \"(xs !! Suc j) c = 0\""], ["proof (prove)\nusing this:\n  set l \\<subseteq> \\<X>\n  xs !! Suc j = [l\\<rightarrow>0]xs !! j\n  c \\<in> set l\n\ngoal (1 subgoal):\n 1. (xs !! Suc j) c = 0", "by auto"], ["proof (state)\nthis:\n  (xs !! Suc j) c = 0\n\ngoal (1 subgoal):\n 1. c \\<in> set l \\<Longrightarrow> 0 \\<le> (xs !! Suc j) c - (xs !! j) c", "moreover"], ["proof (state)\nthis:\n  (xs !! Suc j) c = 0\n\ngoal (1 subgoal):\n 1. c \\<in> set l \\<Longrightarrow> 0 \\<le> (xs !! Suc j) c - (xs !! j) c", "from assms"], ["proof (chain)\npicking this:\n  \\<forall>k>i.\n     k \\<le> j \\<longrightarrow> \\<not> zero c ([xs !! k]\\<^sub>\\<R>)\n  i \\<le> j\n  c \\<in> \\<X>\n  stream_trans xs\n  \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\n  \\<forall>i. xs !! i \\<in> V", "have \"xs !! Suc j \\<in> [xs !! Suc j]\\<^sub>\\<R>\""], ["proof (prove)\nusing this:\n  \\<forall>k>i.\n     k \\<le> j \\<longrightarrow> \\<not> zero c ([xs !! k]\\<^sub>\\<R>)\n  i \\<le> j\n  c \\<in> \\<X>\n  stream_trans xs\n  \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\n  \\<forall>i. xs !! i \\<in> V\n\ngoal (1 subgoal):\n 1. xs !! Suc j \\<in> [xs !! Suc j]\\<^sub>\\<R>", "by blast"], ["proof (state)\nthis:\n  xs !! Suc j \\<in> [xs !! Suc j]\\<^sub>\\<R>\n\ngoal (1 subgoal):\n 1. c \\<in> set l \\<Longrightarrow> 0 \\<le> (xs !! Suc j) c - (xs !! j) c", "ultimately"], ["proof (chain)\npicking this:\n  (xs !! Suc j) c = 0\n  xs !! Suc j \\<in> [xs !! Suc j]\\<^sub>\\<R>", "have\n        \"zero c ([xs !! Suc j]\\<^sub>\\<R>)\""], ["proof (prove)\nusing this:\n  (xs !! Suc j) c = 0\n  xs !! Suc j \\<in> [xs !! Suc j]\\<^sub>\\<R>\n\ngoal (1 subgoal):\n 1. zero c ([xs !! Suc j]\\<^sub>\\<R>)", "using zero_all[OF finite(1) _ \\<open>c \\<in> \\<X>\\<close>] regions(2)"], ["proof (prove)\nusing this:\n  (xs !! Suc j) c = 0\n  xs !! Suc j \\<in> [xs !! Suc j]\\<^sub>\\<R>\n  \\<lbrakk>Regions.valid_region \\<X> ?k ?I ?r;\n   ?u \\<in> Regions.region \\<X> ?I ?r; ?u c = 0\\<rbrakk>\n  \\<Longrightarrow> zero c (Regions.region \\<X> ?I ?r)\n  [xs !! Suc j]\\<^sub>\\<R> \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. zero c ([xs !! Suc j]\\<^sub>\\<R>)", "by (auto simp: \\<R>_def)"], ["proof (state)\nthis:\n  zero c ([xs !! Suc j]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. c \\<in> set l \\<Longrightarrow> 0 \\<le> (xs !! Suc j) c - (xs !! j) c", "with * that"], ["proof (chain)\npicking this:\n  i < Suc j \\<Longrightarrow> \\<not> zero c ([xs !! Suc j]\\<^sub>\\<R>)\n  i < Suc j \\<Longrightarrow> eq_elapsed (xs !! j) (xs !! Suc j)\n  i < Suc j\n  zero c ([xs !! Suc j]\\<^sub>\\<R>)", "show ?thesis"], ["proof (prove)\nusing this:\n  i < Suc j \\<Longrightarrow> \\<not> zero c ([xs !! Suc j]\\<^sub>\\<R>)\n  i < Suc j \\<Longrightarrow> eq_elapsed (xs !! j) (xs !! Suc j)\n  i < Suc j\n  zero c ([xs !! Suc j]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. 0 \\<le> (xs !! Suc j) c - (xs !! j) c", "by auto"], ["proof (state)\nthis:\n  0 \\<le> (xs !! Suc j) c - (xs !! j) c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 \\<le> (xs !! Suc j) c - (xs !! j) c\n\ngoal (1 subgoal):\n 1. xs !! j = xs !! Suc j \\<Longrightarrow>\n    0 \\<le> (xs !! Suc j) c - (xs !! j) c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs !! j = xs !! Suc j \\<Longrightarrow>\n    0 \\<le> (xs !! Suc j) c - (xs !! j) c", "case id"], ["proof (state)\nthis:\n  xs !! j = xs !! Suc j\n\ngoal (1 subgoal):\n 1. xs !! j = xs !! Suc j \\<Longrightarrow>\n    0 \\<le> (xs !! Suc j) c - (xs !! j) c", "then"], ["proof (chain)\npicking this:\n  xs !! j = xs !! Suc j", "show ?thesis"], ["proof (prove)\nusing this:\n  xs !! j = xs !! Suc j\n\ngoal (1 subgoal):\n 1. 0 \\<le> (xs !! Suc j) c - (xs !! j) c", "by simp"], ["proof (state)\nthis:\n  0 \\<le> (xs !! Suc j) c - (xs !! j) c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i < Suc j \\<Longrightarrow> 0 \\<le> (xs !! Suc j) c - (xs !! j) c\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>\\<lbrakk>\\<forall>k>i.\n                            k \\<le> j \\<longrightarrow>\n                            \\<not> zero c ([xs !! k]\\<^sub>\\<R>);\n                 i \\<le> j; c \\<in> \\<X>; stream_trans xs;\n                 \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i);\n                 \\<forall>i. xs !! i \\<in> V\\<rbrakk>\n                \\<Longrightarrow> dur xs j - dur xs i =\n                                  (xs !! j) c - (xs !! i) c;\n        \\<forall>k>i.\n           k \\<le> Suc j \\<longrightarrow>\n           \\<not> zero c ([xs !! k]\\<^sub>\\<R>);\n        i \\<le> Suc j; c \\<in> \\<X>; stream_trans xs;\n        \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i);\n        \\<forall>i. xs !! i \\<in> V\\<rbrakk>\n       \\<Longrightarrow> dur xs (Suc j) - dur xs i =\n                         (xs !! Suc j) c - (xs !! i) c", "with * \\<open>c \\<in> \\<X>\\<close> elapsed_eq"], ["proof (chain)\npicking this:\n  i < Suc j \\<Longrightarrow> \\<not> zero c ([xs !! Suc j]\\<^sub>\\<R>)\n  i < Suc j \\<Longrightarrow> eq_elapsed (xs !! j) (xs !! Suc j)\n  c \\<in> \\<X>\n  \\<lbrakk>eq_elapsed ?u ?u'; ?c \\<in> \\<X>;\n   (0::?'a) \\<le> ?u' ?c - ?u ?c\\<rbrakk>\n  \\<Longrightarrow> elapsed ?u ?u' = ?u' ?c - ?u ?c\n  i < Suc j \\<Longrightarrow> 0 \\<le> (xs !! Suc j) c - (xs !! j) c", "have\n    *: \"elapsed (xs !! j) (xs !! Suc j) = (xs !! Suc j) c - (xs !! j) c\"\n    if \"Suc j > i\""], ["proof (prove)\nusing this:\n  i < Suc j \\<Longrightarrow> \\<not> zero c ([xs !! Suc j]\\<^sub>\\<R>)\n  i < Suc j \\<Longrightarrow> eq_elapsed (xs !! j) (xs !! Suc j)\n  c \\<in> \\<X>\n  \\<lbrakk>eq_elapsed ?u ?u'; ?c \\<in> \\<X>;\n   (0::?'a) \\<le> ?u' ?c - ?u ?c\\<rbrakk>\n  \\<Longrightarrow> elapsed ?u ?u' = ?u' ?c - ?u ?c\n  i < Suc j \\<Longrightarrow> 0 \\<le> (xs !! Suc j) c - (xs !! j) c\n\ngoal (1 subgoal):\n 1. elapsed (xs !! j) (xs !! Suc j) = (xs !! Suc j) c - (xs !! j) c", "using that"], ["proof (prove)\nusing this:\n  i < Suc j \\<Longrightarrow> \\<not> zero c ([xs !! Suc j]\\<^sub>\\<R>)\n  i < Suc j \\<Longrightarrow> eq_elapsed (xs !! j) (xs !! Suc j)\n  c \\<in> \\<X>\n  \\<lbrakk>eq_elapsed ?u ?u'; ?c \\<in> \\<X>;\n   (0::?'a) \\<le> ?u' ?c - ?u ?c\\<rbrakk>\n  \\<Longrightarrow> elapsed ?u ?u' = ?u' ?c - ?u ?c\n  i < Suc j \\<Longrightarrow> 0 \\<le> (xs !! Suc j) c - (xs !! j) c\n  i < Suc j\n\ngoal (1 subgoal):\n 1. elapsed (xs !! j) (xs !! Suc j) = (xs !! Suc j) c - (xs !! j) c", "by blast"], ["proof (state)\nthis:\n  i < Suc j \\<Longrightarrow>\n  elapsed (xs !! j) (xs !! Suc j) = (xs !! Suc j) c - (xs !! j) c\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>\\<lbrakk>\\<forall>k>i.\n                            k \\<le> j \\<longrightarrow>\n                            \\<not> zero c ([xs !! k]\\<^sub>\\<R>);\n                 i \\<le> j; c \\<in> \\<X>; stream_trans xs;\n                 \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i);\n                 \\<forall>i. xs !! i \\<in> V\\<rbrakk>\n                \\<Longrightarrow> dur xs j - dur xs i =\n                                  (xs !! j) c - (xs !! i) c;\n        \\<forall>k>i.\n           k \\<le> Suc j \\<longrightarrow>\n           \\<not> zero c ([xs !! k]\\<^sub>\\<R>);\n        i \\<le> Suc j; c \\<in> \\<X>; stream_trans xs;\n        \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i);\n        \\<forall>i. xs !! i \\<in> V\\<rbrakk>\n       \\<Longrightarrow> dur xs (Suc j) - dur xs i =\n                         (xs !! Suc j) c - (xs !! i) c", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. dur xs (Suc j) - dur xs i = (xs !! Suc j) c - (xs !! i) c", "proof (cases \"i = Suc j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = Suc j \\<Longrightarrow>\n    dur xs (Suc j) - dur xs i = (xs !! Suc j) c - (xs !! i) c\n 2. i \\<noteq> Suc j \\<Longrightarrow>\n    dur xs (Suc j) - dur xs i = (xs !! Suc j) c - (xs !! i) c", "case False"], ["proof (state)\nthis:\n  i \\<noteq> Suc j\n\ngoal (2 subgoals):\n 1. i = Suc j \\<Longrightarrow>\n    dur xs (Suc j) - dur xs i = (xs !! Suc j) c - (xs !! i) c\n 2. i \\<noteq> Suc j \\<Longrightarrow>\n    dur xs (Suc j) - dur xs i = (xs !! Suc j) c - (xs !! i) c", "with Suc"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>k>i.\n              k \\<le> j \\<longrightarrow>\n              \\<not> zero c ([xs !! k]\\<^sub>\\<R>);\n   i \\<le> j; c \\<in> \\<X>; stream_trans xs;\n   \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i);\n   \\<forall>i. xs !! i \\<in> V\\<rbrakk>\n  \\<Longrightarrow> dur xs j - dur xs i = (xs !! j) c - (xs !! i) c\n  \\<forall>k>i.\n     k \\<le> Suc j \\<longrightarrow> \\<not> zero c ([xs !! k]\\<^sub>\\<R>)\n  i \\<le> Suc j\n  c \\<in> \\<X>\n  stream_trans xs\n  \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\n  \\<forall>i. xs !! i \\<in> V\n  i \\<noteq> Suc j", "have\n      \"dur xs (Suc j) - dur xs i = dur xs (Suc j) - dur xs j + (xs !! j) c - (xs !! i) c\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>k>i.\n              k \\<le> j \\<longrightarrow>\n              \\<not> zero c ([xs !! k]\\<^sub>\\<R>);\n   i \\<le> j; c \\<in> \\<X>; stream_trans xs;\n   \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i);\n   \\<forall>i. xs !! i \\<in> V\\<rbrakk>\n  \\<Longrightarrow> dur xs j - dur xs i = (xs !! j) c - (xs !! i) c\n  \\<forall>k>i.\n     k \\<le> Suc j \\<longrightarrow> \\<not> zero c ([xs !! k]\\<^sub>\\<R>)\n  i \\<le> Suc j\n  c \\<in> \\<X>\n  stream_trans xs\n  \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\n  \\<forall>i. xs !! i \\<in> V\n  i \\<noteq> Suc j\n\ngoal (1 subgoal):\n 1. dur xs (Suc j) - dur xs i =\n    dur xs (Suc j) - dur xs j + (xs !! j) c - (xs !! i) c", "by auto"], ["proof (state)\nthis:\n  dur xs (Suc j) - dur xs i =\n  dur xs (Suc j) - dur xs j + (xs !! j) c - (xs !! i) c\n\ngoal (2 subgoals):\n 1. i = Suc j \\<Longrightarrow>\n    dur xs (Suc j) - dur xs i = (xs !! Suc j) c - (xs !! i) c\n 2. i \\<noteq> Suc j \\<Longrightarrow>\n    dur xs (Suc j) - dur xs i = (xs !! Suc j) c - (xs !! i) c", "also"], ["proof (state)\nthis:\n  dur xs (Suc j) - dur xs i =\n  dur xs (Suc j) - dur xs j + (xs !! j) c - (xs !! i) c\n\ngoal (2 subgoals):\n 1. i = Suc j \\<Longrightarrow>\n    dur xs (Suc j) - dur xs i = (xs !! Suc j) c - (xs !! i) c\n 2. i \\<noteq> Suc j \\<Longrightarrow>\n    dur xs (Suc j) - dur xs i = (xs !! Suc j) c - (xs !! i) c", "have \"\\<dots> = elapsed (xs !! j) (xs !! Suc j) + (xs !! j) c - (xs !! i) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dur xs (Suc j) - dur xs j + (xs !! j) c - (xs !! i) c =\n    elapsed (xs !! j) (xs !! Suc j) + (xs !! j) c - (xs !! i) c", "by (simp add: dur_Suc)"], ["proof (state)\nthis:\n  dur xs (Suc j) - dur xs j + (xs !! j) c - (xs !! i) c =\n  elapsed (xs !! j) (xs !! Suc j) + (xs !! j) c - (xs !! i) c\n\ngoal (2 subgoals):\n 1. i = Suc j \\<Longrightarrow>\n    dur xs (Suc j) - dur xs i = (xs !! Suc j) c - (xs !! i) c\n 2. i \\<noteq> Suc j \\<Longrightarrow>\n    dur xs (Suc j) - dur xs i = (xs !! Suc j) c - (xs !! i) c", "also"], ["proof (state)\nthis:\n  dur xs (Suc j) - dur xs j + (xs !! j) c - (xs !! i) c =\n  elapsed (xs !! j) (xs !! Suc j) + (xs !! j) c - (xs !! i) c\n\ngoal (2 subgoals):\n 1. i = Suc j \\<Longrightarrow>\n    dur xs (Suc j) - dur xs i = (xs !! Suc j) c - (xs !! i) c\n 2. i \\<noteq> Suc j \\<Longrightarrow>\n    dur xs (Suc j) - dur xs i = (xs !! Suc j) c - (xs !! i) c", "have\n      \"\\<dots> = (xs !! Suc j) c - (xs !! j) c  + (xs !! j) c - (xs !! i) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elapsed (xs !! j) (xs !! Suc j) + (xs !! j) c - (xs !! i) c =\n    (xs !! Suc j) c - (xs !! j) c + (xs !! j) c - (xs !! i) c", "using * False Suc.prems"], ["proof (prove)\nusing this:\n  i < Suc j \\<Longrightarrow>\n  elapsed (xs !! j) (xs !! Suc j) = (xs !! Suc j) c - (xs !! j) c\n  i \\<noteq> Suc j\n  \\<forall>k>i.\n     k \\<le> Suc j \\<longrightarrow> \\<not> zero c ([xs !! k]\\<^sub>\\<R>)\n  i \\<le> Suc j\n  c \\<in> \\<X>\n  stream_trans xs\n  \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\n  \\<forall>i. xs !! i \\<in> V\n\ngoal (1 subgoal):\n 1. elapsed (xs !! j) (xs !! Suc j) + (xs !! j) c - (xs !! i) c =\n    (xs !! Suc j) c - (xs !! j) c + (xs !! j) c - (xs !! i) c", "by auto"], ["proof (state)\nthis:\n  elapsed (xs !! j) (xs !! Suc j) + (xs !! j) c - (xs !! i) c =\n  (xs !! Suc j) c - (xs !! j) c + (xs !! j) c - (xs !! i) c\n\ngoal (2 subgoals):\n 1. i = Suc j \\<Longrightarrow>\n    dur xs (Suc j) - dur xs i = (xs !! Suc j) c - (xs !! i) c\n 2. i \\<noteq> Suc j \\<Longrightarrow>\n    dur xs (Suc j) - dur xs i = (xs !! Suc j) c - (xs !! i) c", "also"], ["proof (state)\nthis:\n  elapsed (xs !! j) (xs !! Suc j) + (xs !! j) c - (xs !! i) c =\n  (xs !! Suc j) c - (xs !! j) c + (xs !! j) c - (xs !! i) c\n\ngoal (2 subgoals):\n 1. i = Suc j \\<Longrightarrow>\n    dur xs (Suc j) - dur xs i = (xs !! Suc j) c - (xs !! i) c\n 2. i \\<noteq> Suc j \\<Longrightarrow>\n    dur xs (Suc j) - dur xs i = (xs !! Suc j) c - (xs !! i) c", "have \"\\<dots> = (xs !! Suc j) c - (xs !! i) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs !! Suc j) c - (xs !! j) c + (xs !! j) c - (xs !! i) c =\n    (xs !! Suc j) c - (xs !! i) c", "by simp"], ["proof (state)\nthis:\n  (xs !! Suc j) c - (xs !! j) c + (xs !! j) c - (xs !! i) c =\n  (xs !! Suc j) c - (xs !! i) c\n\ngoal (2 subgoals):\n 1. i = Suc j \\<Longrightarrow>\n    dur xs (Suc j) - dur xs i = (xs !! Suc j) c - (xs !! i) c\n 2. i \\<noteq> Suc j \\<Longrightarrow>\n    dur xs (Suc j) - dur xs i = (xs !! Suc j) c - (xs !! i) c", "finally"], ["proof (chain)\npicking this:\n  dur xs (Suc j) - dur xs i = (xs !! Suc j) c - (xs !! i) c", "show ?thesis"], ["proof (prove)\nusing this:\n  dur xs (Suc j) - dur xs i = (xs !! Suc j) c - (xs !! i) c\n\ngoal (1 subgoal):\n 1. dur xs (Suc j) - dur xs i = (xs !! Suc j) c - (xs !! i) c", "by auto"], ["proof (state)\nthis:\n  dur xs (Suc j) - dur xs i = (xs !! Suc j) c - (xs !! i) c\n\ngoal (1 subgoal):\n 1. i = Suc j \\<Longrightarrow>\n    dur xs (Suc j) - dur xs i = (xs !! Suc j) c - (xs !! i) c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i = Suc j \\<Longrightarrow>\n    dur xs (Suc j) - dur xs i = (xs !! Suc j) c - (xs !! i) c", "case True"], ["proof (state)\nthis:\n  i = Suc j\n\ngoal (1 subgoal):\n 1. i = Suc j \\<Longrightarrow>\n    dur xs (Suc j) - dur xs i = (xs !! Suc j) c - (xs !! i) c", "then"], ["proof (chain)\npicking this:\n  i = Suc j", "show ?thesis"], ["proof (prove)\nusing this:\n  i = Suc j\n\ngoal (1 subgoal):\n 1. dur xs (Suc j) - dur xs i = (xs !! Suc j) c - (xs !! i) c", "by simp"], ["proof (state)\nthis:\n  dur xs (Suc j) - dur xs i = (xs !! Suc j) c - (xs !! i) c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dur xs (Suc j) - dur xs i = (xs !! Suc j) c - (xs !! i) c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_reset_dur':\n  assumes \"\\<forall>j\\<ge>i. \\<not> zero c ([xs !! j]\\<^sub>\\<R>)\" \"j \\<ge> i\" \"c \\<in> \\<X>\" \"stream_trans xs\"\n          \"\\<forall> i. eq_elapsed (xs !! i) (xs !! Suc i)\" \"\\<forall> j. xs !! j \\<in> V\"\n  shows \"dur xs j - dur xs i = (xs !! j) c - (xs !! i) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dur xs j - dur xs i = (xs !! j) c - (xs !! i) c", "using assms not_reset_dur"], ["proof (prove)\nusing this:\n  \\<forall>j\\<ge>i. \\<not> zero c ([xs !! j]\\<^sub>\\<R>)\n  i \\<le> j\n  c \\<in> \\<X>\n  stream_trans xs\n  \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\n  \\<forall>j. xs !! j \\<in> V\n  \\<lbrakk>\\<forall>k>?i.\n              k \\<le> ?j \\<longrightarrow>\n              \\<not> zero ?c ([?xs !! k]\\<^sub>\\<R>);\n   ?i \\<le> ?j; ?c \\<in> \\<X>; stream_trans ?xs;\n   \\<forall>i. eq_elapsed (?xs !! i) (?xs !! Suc i);\n   \\<forall>i. ?xs !! i \\<in> V\\<rbrakk>\n  \\<Longrightarrow> dur ?xs ?j - dur ?xs ?i =\n                    (?xs !! ?j) ?c - (?xs !! ?i) ?c\n\ngoal (1 subgoal):\n 1. dur xs j - dur xs i = (xs !! j) c - (xs !! i) c", "by auto"], ["", "lemma not_reset_unbounded:\n  assumes \"\\<forall>j\\<ge>i. \\<not> zero c ([xs !! j]\\<^sub>\\<R>)\" \"j \\<ge> i\" \"c \\<in> \\<X>\" \"stream_trans xs\"\n          \"\\<forall> i. eq_elapsed (xs !! i) (xs !! Suc i)\" \"\\<forall> j. xs !! j \\<in> V\"\n          \"unbounded c ([xs !! i]\\<^sub>\\<R>)\"\n  shows \"unbounded c ([xs !! j]\\<^sub>\\<R>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unbounded c ([xs !! j]\\<^sub>\\<R>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. unbounded c ([xs !! j]\\<^sub>\\<R>)", "let ?u = \"xs !! i\""], ["proof (state)\ngoal (1 subgoal):\n 1. unbounded c ([xs !! j]\\<^sub>\\<R>)", "let ?u' = \"xs !! j\""], ["proof (state)\ngoal (1 subgoal):\n 1. unbounded c ([xs !! j]\\<^sub>\\<R>)", "let ?R = \"[xs !! i]\\<^sub>\\<R>\""], ["proof (state)\ngoal (1 subgoal):\n 1. unbounded c ([xs !! j]\\<^sub>\\<R>)", "from assms"], ["proof (chain)\npicking this:\n  \\<forall>j\\<ge>i. \\<not> zero c ([xs !! j]\\<^sub>\\<R>)\n  i \\<le> j\n  c \\<in> \\<X>\n  stream_trans xs\n  \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\n  \\<forall>j. xs !! j \\<in> V\n  unbounded c ([xs !! i]\\<^sub>\\<R>)", "have \"?u \\<in> ?R\""], ["proof (prove)\nusing this:\n  \\<forall>j\\<ge>i. \\<not> zero c ([xs !! j]\\<^sub>\\<R>)\n  i \\<le> j\n  c \\<in> \\<X>\n  stream_trans xs\n  \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\n  \\<forall>j. xs !! j \\<in> V\n  unbounded c ([xs !! i]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. xs !! i \\<in> [xs !! i]\\<^sub>\\<R>", "by auto"], ["proof (state)\nthis:\n  xs !! i \\<in> [xs !! i]\\<^sub>\\<R>\n\ngoal (1 subgoal):\n 1. unbounded c ([xs !! j]\\<^sub>\\<R>)", "from assms(6)"], ["proof (chain)\npicking this:\n  \\<forall>j. xs !! j \\<in> V", "have \"?R \\<in> \\<R>\""], ["proof (prove)\nusing this:\n  \\<forall>j. xs !! j \\<in> V\n\ngoal (1 subgoal):\n 1. [xs !! i]\\<^sub>\\<R> \\<in> \\<R>", "by auto"], ["proof (state)\nthis:\n  [xs !! i]\\<^sub>\\<R> \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. unbounded c ([xs !! j]\\<^sub>\\<R>)", "then"], ["proof (chain)\npicking this:\n  [xs !! i]\\<^sub>\\<R> \\<in> \\<R>", "obtain I r where \"?R = region \\<X> I r\" \"valid_region \\<X> k I r\""], ["proof (prove)\nusing this:\n  [xs !! i]\\<^sub>\\<R> \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. (\\<And>I r.\n        \\<lbrakk>[xs !! i]\\<^sub>\\<R> = Regions.region \\<X> I r;\n         Regions.valid_region \\<X> k I r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<R>_def"], ["proof (prove)\nusing this:\n  [xs !!\n   i]\\<^sub>{Regions.region \\<X> I r |I r. Regions.valid_region \\<X> k I r}\n  \\<in> {Regions.region \\<X> I r |I r. Regions.valid_region \\<X> k I r}\n\ngoal (1 subgoal):\n 1. (\\<And>I r.\n        \\<lbrakk>[xs !!\n                  i]\\<^sub>{Regions.region \\<X> I r |I r.\n                            Regions.valid_region \\<X> k I r} =\n                 Regions.region \\<X> I r;\n         Regions.valid_region \\<X> k I r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  [xs !! i]\\<^sub>\\<R> = Regions.region \\<X> I r\n  Regions.valid_region \\<X> k I r\n\ngoal (1 subgoal):\n 1. unbounded c ([xs !! j]\\<^sub>\\<R>)", "with assms(3,7) unbounded_Greater \\<open>?u \\<in> ?R\\<close>"], ["proof (chain)\npicking this:\n  c \\<in> \\<X>\n  unbounded c ([xs !! i]\\<^sub>\\<R>)\n  \\<lbrakk>Regions.valid_region ?X ?k ?I ?r; ?c \\<in> ?X;\n   unbounded ?c (Regions.region ?X ?I ?r)\\<rbrakk>\n  \\<Longrightarrow> ?I ?c = Regions.intv.Greater (?k ?c)\n  xs !! i \\<in> [xs !! i]\\<^sub>\\<R>\n  [xs !! i]\\<^sub>\\<R> = Regions.region \\<X> I r\n  Regions.valid_region \\<X> k I r", "have \"?u c > k c\""], ["proof (prove)\nusing this:\n  c \\<in> \\<X>\n  unbounded c ([xs !! i]\\<^sub>\\<R>)\n  \\<lbrakk>Regions.valid_region ?X ?k ?I ?r; ?c \\<in> ?X;\n   unbounded ?c (Regions.region ?X ?I ?r)\\<rbrakk>\n  \\<Longrightarrow> ?I ?c = Regions.intv.Greater (?k ?c)\n  xs !! i \\<in> [xs !! i]\\<^sub>\\<R>\n  [xs !! i]\\<^sub>\\<R> = Regions.region \\<X> I r\n  Regions.valid_region \\<X> k I r\n\ngoal (1 subgoal):\n 1. real (k c) < (xs !! i) c", "by force"], ["proof (state)\nthis:\n  real (k c) < (xs !! i) c\n\ngoal (1 subgoal):\n 1. unbounded c ([xs !! j]\\<^sub>\\<R>)", "also"], ["proof (state)\nthis:\n  real (k c) < (xs !! i) c\n\ngoal (1 subgoal):\n 1. unbounded c ([xs !! j]\\<^sub>\\<R>)", "from not_reset_dur'[OF assms(1-6)] dur_mono[OF \\<open>j \\<ge> i\\<close>, of xs]"], ["proof (chain)\npicking this:\n  dur xs j - dur xs i = (xs !! j) c - (xs !! i) c\n  dur xs i \\<le> dur xs j", "have \"?u' c \\<ge> ?u c\""], ["proof (prove)\nusing this:\n  dur xs j - dur xs i = (xs !! j) c - (xs !! i) c\n  dur xs i \\<le> dur xs j\n\ngoal (1 subgoal):\n 1. (xs !! i) c \\<le> (xs !! j) c", "by auto"], ["proof (state)\nthis:\n  (xs !! i) c \\<le> (xs !! j) c\n\ngoal (1 subgoal):\n 1. unbounded c ([xs !! j]\\<^sub>\\<R>)", "finally"], ["proof (chain)\npicking this:\n  real (k c) < (xs !! j) c", "have \"?u' c > k c\""], ["proof (prove)\nusing this:\n  real (k c) < (xs !! j) c\n\ngoal (1 subgoal):\n 1. real (k c) < (xs !! j) c", "by auto"], ["proof (state)\nthis:\n  real (k c) < (xs !! j) c\n\ngoal (1 subgoal):\n 1. unbounded c ([xs !! j]\\<^sub>\\<R>)", "let ?R' = \"[xs !! j]\\<^sub>\\<R>\""], ["proof (state)\ngoal (1 subgoal):\n 1. unbounded c ([xs !! j]\\<^sub>\\<R>)", "from assms"], ["proof (chain)\npicking this:\n  \\<forall>j\\<ge>i. \\<not> zero c ([xs !! j]\\<^sub>\\<R>)\n  i \\<le> j\n  c \\<in> \\<X>\n  stream_trans xs\n  \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\n  \\<forall>j. xs !! j \\<in> V\n  unbounded c ([xs !! i]\\<^sub>\\<R>)", "have \"?u' \\<in> ?R'\""], ["proof (prove)\nusing this:\n  \\<forall>j\\<ge>i. \\<not> zero c ([xs !! j]\\<^sub>\\<R>)\n  i \\<le> j\n  c \\<in> \\<X>\n  stream_trans xs\n  \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\n  \\<forall>j. xs !! j \\<in> V\n  unbounded c ([xs !! i]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. xs !! j \\<in> [xs !! j]\\<^sub>\\<R>", "by auto"], ["proof (state)\nthis:\n  xs !! j \\<in> [xs !! j]\\<^sub>\\<R>\n\ngoal (1 subgoal):\n 1. unbounded c ([xs !! j]\\<^sub>\\<R>)", "from assms(6)"], ["proof (chain)\npicking this:\n  \\<forall>j. xs !! j \\<in> V", "have \"?R' \\<in> \\<R>\""], ["proof (prove)\nusing this:\n  \\<forall>j. xs !! j \\<in> V\n\ngoal (1 subgoal):\n 1. [xs !! j]\\<^sub>\\<R> \\<in> \\<R>", "by auto"], ["proof (state)\nthis:\n  [xs !! j]\\<^sub>\\<R> \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. unbounded c ([xs !! j]\\<^sub>\\<R>)", "then"], ["proof (chain)\npicking this:\n  [xs !! j]\\<^sub>\\<R> \\<in> \\<R>", "obtain I r where \"?R' = region \\<X> I r\" \"valid_region \\<X> k I r\""], ["proof (prove)\nusing this:\n  [xs !! j]\\<^sub>\\<R> \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. (\\<And>I r.\n        \\<lbrakk>[xs !! j]\\<^sub>\\<R> = Regions.region \\<X> I r;\n         Regions.valid_region \\<X> k I r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<R>_def"], ["proof (prove)\nusing this:\n  [xs !!\n   j]\\<^sub>{Regions.region \\<X> I r |I r. Regions.valid_region \\<X> k I r}\n  \\<in> {Regions.region \\<X> I r |I r. Regions.valid_region \\<X> k I r}\n\ngoal (1 subgoal):\n 1. (\\<And>I r.\n        \\<lbrakk>[xs !!\n                  j]\\<^sub>{Regions.region \\<X> I r |I r.\n                            Regions.valid_region \\<X> k I r} =\n                 Regions.region \\<X> I r;\n         Regions.valid_region \\<X> k I r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  [xs !! j]\\<^sub>\\<R> = Regions.region \\<X> I r\n  Regions.valid_region \\<X> k I r\n\ngoal (1 subgoal):\n 1. unbounded c ([xs !! j]\\<^sub>\\<R>)", "moreover"], ["proof (state)\nthis:\n  [xs !! j]\\<^sub>\\<R> = Regions.region \\<X> I r\n  Regions.valid_region \\<X> k I r\n\ngoal (1 subgoal):\n 1. unbounded c ([xs !! j]\\<^sub>\\<R>)", "with \\<open>?u' c > _\\<close> \\<open>?u' \\<in> _\\<close> gt_GreaterD \\<open>c \\<in> \\<X>\\<close>"], ["proof (chain)\npicking this:\n  real (k c) < (xs !! j) c\n  xs !! j \\<in> [xs !! j]\\<^sub>\\<R>\n  \\<lbrakk>?u \\<in> Regions.region ?X ?I ?r;\n   Regions.valid_region ?X ?k ?I ?r; ?c \\<in> ?X;\n   real (?k ?c) < ?u ?c\\<rbrakk>\n  \\<Longrightarrow> ?I ?c = Regions.intv.Greater (?k ?c)\n  c \\<in> \\<X>\n  [xs !! j]\\<^sub>\\<R> = Regions.region \\<X> I r\n  Regions.valid_region \\<X> k I r", "have \"I c = Greater (k c)\""], ["proof (prove)\nusing this:\n  real (k c) < (xs !! j) c\n  xs !! j \\<in> [xs !! j]\\<^sub>\\<R>\n  \\<lbrakk>?u \\<in> Regions.region ?X ?I ?r;\n   Regions.valid_region ?X ?k ?I ?r; ?c \\<in> ?X;\n   real (?k ?c) < ?u ?c\\<rbrakk>\n  \\<Longrightarrow> ?I ?c = Regions.intv.Greater (?k ?c)\n  c \\<in> \\<X>\n  [xs !! j]\\<^sub>\\<R> = Regions.region \\<X> I r\n  Regions.valid_region \\<X> k I r\n\ngoal (1 subgoal):\n 1. I c = Regions.intv.Greater (k c)", "by auto"], ["proof (state)\nthis:\n  I c = Regions.intv.Greater (k c)\n\ngoal (1 subgoal):\n 1. unbounded c ([xs !! j]\\<^sub>\\<R>)", "ultimately"], ["proof (chain)\npicking this:\n  [xs !! j]\\<^sub>\\<R> = Regions.region \\<X> I r\n  Regions.valid_region \\<X> k I r\n  I c = Regions.intv.Greater (k c)", "show ?thesis"], ["proof (prove)\nusing this:\n  [xs !! j]\\<^sub>\\<R> = Regions.region \\<X> I r\n  Regions.valid_region \\<X> k I r\n  I c = Regions.intv.Greater (k c)\n\ngoal (1 subgoal):\n 1. unbounded c ([xs !! j]\\<^sub>\\<R>)", "using Greater_unbounded[OF finite(1) _ \\<open>c \\<in> \\<X>\\<close>]"], ["proof (prove)\nusing this:\n  [xs !! j]\\<^sub>\\<R> = Regions.region \\<X> I r\n  Regions.valid_region \\<X> k I r\n  I c = Regions.intv.Greater (k c)\n  \\<lbrakk>Regions.valid_region \\<X> ?k ?I ?r;\n   ?I c = Regions.intv.Greater (?k c)\\<rbrakk>\n  \\<Longrightarrow> unbounded c (Regions.region \\<X> ?I ?r)\n\ngoal (1 subgoal):\n 1. unbounded c ([xs !! j]\\<^sub>\\<R>)", "by auto"], ["proof (state)\nthis:\n  unbounded c ([xs !! j]\\<^sub>\\<R>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gt_unboundedD:\n  assumes \"u \\<in> R\"\n    and \"R \\<in> \\<R>\"\n    and \"c \\<in> \\<X>\"\n    and \"real (k c) < u c\"\n  shows \"unbounded c R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unbounded c R", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. unbounded c R", "from assms"], ["proof (chain)\npicking this:\n  u \\<in> R\n  R \\<in> \\<R>\n  c \\<in> \\<X>\n  real (k c) < u c", "obtain I r where \"R = region \\<X> I r\" \"valid_region \\<X> k I r\""], ["proof (prove)\nusing this:\n  u \\<in> R\n  R \\<in> \\<R>\n  c \\<in> \\<X>\n  real (k c) < u c\n\ngoal (1 subgoal):\n 1. (\\<And>I r.\n        \\<lbrakk>R = Regions.region \\<X> I r;\n         Regions.valid_region \\<X> k I r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<R>_def"], ["proof (prove)\nusing this:\n  u \\<in> R\n  R \\<in> {Regions.region \\<X> I r |I r. Regions.valid_region \\<X> k I r}\n  c \\<in> \\<X>\n  real (k c) < u c\n\ngoal (1 subgoal):\n 1. (\\<And>I r.\n        \\<lbrakk>R = Regions.region \\<X> I r;\n         Regions.valid_region \\<X> k I r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  R = Regions.region \\<X> I r\n  Regions.valid_region \\<X> k I r\n\ngoal (1 subgoal):\n 1. unbounded c R", "with Greater_unbounded[of \\<X> k I r c] gt_GreaterD[of u \\<X> I r k c] assms finite(1)"], ["proof (chain)\npicking this:\n  \\<lbrakk>finite \\<X>; Regions.valid_region \\<X> k I r; c \\<in> \\<X>;\n   I c = Regions.intv.Greater (k c)\\<rbrakk>\n  \\<Longrightarrow> unbounded c (Regions.region \\<X> I r)\n  \\<lbrakk>u \\<in> Regions.region \\<X> I r; Regions.valid_region \\<X> k I r;\n   c \\<in> \\<X>; real (k c) < u c\\<rbrakk>\n  \\<Longrightarrow> I c = Regions.intv.Greater (k c)\n  u \\<in> R\n  R \\<in> \\<R>\n  c \\<in> \\<X>\n  real (k c) < u c\n  finite \\<X>\n  R = Regions.region \\<X> I r\n  Regions.valid_region \\<X> k I r", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite \\<X>; Regions.valid_region \\<X> k I r; c \\<in> \\<X>;\n   I c = Regions.intv.Greater (k c)\\<rbrakk>\n  \\<Longrightarrow> unbounded c (Regions.region \\<X> I r)\n  \\<lbrakk>u \\<in> Regions.region \\<X> I r; Regions.valid_region \\<X> k I r;\n   c \\<in> \\<X>; real (k c) < u c\\<rbrakk>\n  \\<Longrightarrow> I c = Regions.intv.Greater (k c)\n  u \\<in> R\n  R \\<in> \\<R>\n  c \\<in> \\<X>\n  real (k c) < u c\n  finite \\<X>\n  R = Regions.region \\<X> I r\n  Regions.valid_region \\<X> k I r\n\ngoal (1 subgoal):\n 1. unbounded c R", "by auto"], ["proof (state)\nthis:\n  unbounded c R\n\ngoal:\nNo subgoals!", "qed"], ["", "definition trans' :: \"('c, t) cval \\<Rightarrow> ('c, t) cval \\<Rightarrow> bool\" where\n  \"trans' u u' \\<equiv>\n    ((\\<forall> c \\<in> \\<X>. u c > k c \\<and> u' c > k c \\<and> u \\<noteq> u') \\<longrightarrow> u' = u \\<oplus> 0.5) \\<and>\n    ((\\<exists> c \\<in> \\<X>. u c = 0 \\<and> u' c > 0 \\<and> (\\<forall>c\\<in>\\<X>. \\<nexists>d. d \\<le> k c \\<and> u' c = real d))\n    \\<longrightarrow> u' = delayedR ([u']\\<^sub>\\<R>) u)\""], ["", "(* XXX Move *)"], ["", "lemma zeroI:\n  assumes \"c \\<in> \\<X>\" \"u \\<in> V\" \"u c = 0\"\n  shows \"zero c ([u]\\<^sub>\\<R>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero c ([u]\\<^sub>\\<R>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. zero c ([u]\\<^sub>\\<R>)", "from assms"], ["proof (chain)\npicking this:\n  c \\<in> \\<X>\n  u \\<in> V\n  u c = 0", "have \"u \\<in> [u]\\<^sub>\\<R>\" \"[u]\\<^sub>\\<R> \\<in> \\<R>\""], ["proof (prove)\nusing this:\n  c \\<in> \\<X>\n  u \\<in> V\n  u c = 0\n\ngoal (1 subgoal):\n 1. u \\<in> [u]\\<^sub>\\<R> &&& [u]\\<^sub>\\<R> \\<in> \\<R>", "by auto"], ["proof (state)\nthis:\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. zero c ([u]\\<^sub>\\<R>)", "then"], ["proof (chain)\npicking this:\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>", "obtain I r where \"[u]\\<^sub>\\<R> = region \\<X> I r\" \"valid_region \\<X> k I r\""], ["proof (prove)\nusing this:\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. (\\<And>I r.\n        \\<lbrakk>[u]\\<^sub>\\<R> = Regions.region \\<X> I r;\n         Regions.valid_region \\<X> k I r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<R>_def"], ["proof (prove)\nusing this:\n  u \\<in> [u]\\<^sub>{Regions.region \\<X> I r |I r.\n                     Regions.valid_region \\<X> k I r}\n  [u]\\<^sub>{Regions.region \\<X> I r |I r. Regions.valid_region \\<X> k I r}\n  \\<in> {Regions.region \\<X> I r |I r. Regions.valid_region \\<X> k I r}\n\ngoal (1 subgoal):\n 1. (\\<And>I r.\n        \\<lbrakk>[u]\\<^sub>{Regions.region \\<X> I r |I r.\n                            Regions.valid_region \\<X> k I r} =\n                 Regions.region \\<X> I r;\n         Regions.valid_region \\<X> k I r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  [u]\\<^sub>\\<R> = Regions.region \\<X> I r\n  Regions.valid_region \\<X> k I r\n\ngoal (1 subgoal):\n 1. zero c ([u]\\<^sub>\\<R>)", "with zero_all[OF finite(1) this(2) \\<open>c \\<in> \\<X>\\<close>] \\<open>u \\<in> [u]\\<^sub>\\<R>\\<close> \\<open>u c = 0\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>?u \\<in> Regions.region \\<X> I r; ?u c = 0\\<rbrakk>\n  \\<Longrightarrow> zero c (Regions.region \\<X> I r)\n  u \\<in> [u]\\<^sub>\\<R>\n  u c = 0\n  [u]\\<^sub>\\<R> = Regions.region \\<X> I r\n  Regions.valid_region \\<X> k I r", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?u \\<in> Regions.region \\<X> I r; ?u c = 0\\<rbrakk>\n  \\<Longrightarrow> zero c (Regions.region \\<X> I r)\n  u \\<in> [u]\\<^sub>\\<R>\n  u c = 0\n  [u]\\<^sub>\\<R> = Regions.region \\<X> I r\n  Regions.valid_region \\<X> k I r\n\ngoal (1 subgoal):\n 1. zero c ([u]\\<^sub>\\<R>)", "by auto"], ["proof (state)\nthis:\n  zero c ([u]\\<^sub>\\<R>)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* XXX Move, rename *)"], ["", "lemma zeroD:\n  \"u x = 0\" if \"zero x ([u]\\<^sub>\\<R>)\" \"u \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u x = 0", "using that"], ["proof (prove)\nusing this:\n  zero x ([u]\\<^sub>\\<R>)\n  u \\<in> V\n\ngoal (1 subgoal):\n 1. u x = 0", "by (metis regions_part_ex(1) zero_def)"], ["", "lemma not_zeroD:\n  assumes \"\\<not> zero x ([u]\\<^sub>\\<R>)\" \"u \\<in> V\" \"x \\<in> \\<X>\"\n  shows \"u x > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < u x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < u x", "from zeroI assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>?c \\<in> \\<X>; ?u \\<in> V; ?u ?c = 0\\<rbrakk>\n  \\<Longrightarrow> zero ?c ([?u]\\<^sub>\\<R>)\n  \\<not> zero x ([u]\\<^sub>\\<R>)\n  u \\<in> V\n  x \\<in> \\<X>", "have \"u x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?c \\<in> \\<X>; ?u \\<in> V; ?u ?c = 0\\<rbrakk>\n  \\<Longrightarrow> zero ?c ([?u]\\<^sub>\\<R>)\n  \\<not> zero x ([u]\\<^sub>\\<R>)\n  u \\<in> V\n  x \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. u x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  u x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < u x", "moreover"], ["proof (state)\nthis:\n  u x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < u x", "from assms"], ["proof (chain)\npicking this:\n  \\<not> zero x ([u]\\<^sub>\\<R>)\n  u \\<in> V\n  x \\<in> \\<X>", "have \"u x \\<ge> 0\""], ["proof (prove)\nusing this:\n  \\<not> zero x ([u]\\<^sub>\\<R>)\n  u \\<in> V\n  x \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. 0 \\<le> u x", "unfolding V_def"], ["proof (prove)\nusing this:\n  \\<not> zero x ([u]\\<^sub>\\<R>)\n  u \\<in> {v. \\<forall>x\\<in>\\<X>. 0 \\<le> v x}\n  x \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. 0 \\<le> u x", "by auto"], ["proof (state)\nthis:\n  0 \\<le> u x\n\ngoal (1 subgoal):\n 1. 0 < u x", "ultimately"], ["proof (chain)\npicking this:\n  u x \\<noteq> 0\n  0 \\<le> u x", "show ?thesis"], ["proof (prove)\nusing this:\n  u x \\<noteq> 0\n  0 \\<le> u x\n\ngoal (1 subgoal):\n 1. 0 < u x", "by auto"], ["proof (state)\nthis:\n  0 < u x\n\ngoal:\nNo subgoals!", "qed"], ["", "(* XXX Move *)"], ["", "lemma not_const_intv:\n  assumes \"u \\<in> V\" \"\\<forall>c\\<in>\\<X>. \\<nexists>d. d \\<le> k c \\<and> u c = real d\"\n  shows \"\\<forall>c\\<in>\\<X>. \\<forall>u \\<in> [u]\\<^sub>\\<R>. \\<nexists>d. d \\<le> k c \\<and> u c = real d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>\\<X>.\n       \\<forall>u\\<in>[u]\\<^sub>\\<R>.\n          \\<not> (\\<exists>d\\<le>k c. u c = real d)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>\\<X>.\n       \\<forall>u\\<in>[u]\\<^sub>\\<R>.\n          \\<not> (\\<exists>d\\<le>k c. u c = real d)", "from assms"], ["proof (chain)\npicking this:\n  u \\<in> V\n  \\<forall>c\\<in>\\<X>. \\<not> (\\<exists>d\\<le>k c. u c = real d)", "have \"u \\<in> [u]\\<^sub>\\<R>\" \"[u]\\<^sub>\\<R> \\<in> \\<R>\""], ["proof (prove)\nusing this:\n  u \\<in> V\n  \\<forall>c\\<in>\\<X>. \\<not> (\\<exists>d\\<le>k c. u c = real d)\n\ngoal (1 subgoal):\n 1. u \\<in> [u]\\<^sub>\\<R> &&& [u]\\<^sub>\\<R> \\<in> \\<R>", "by auto"], ["proof (state)\nthis:\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>\\<X>.\n       \\<forall>u\\<in>[u]\\<^sub>\\<R>.\n          \\<not> (\\<exists>d\\<le>k c. u c = real d)", "then"], ["proof (chain)\npicking this:\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>", "obtain I r where I: \"[u]\\<^sub>\\<R> = region \\<X> I r\" \"valid_region \\<X> k I r\""], ["proof (prove)\nusing this:\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. (\\<And>I r.\n        \\<lbrakk>[u]\\<^sub>\\<R> = Regions.region \\<X> I r;\n         Regions.valid_region \\<X> k I r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<R>_def"], ["proof (prove)\nusing this:\n  u \\<in> [u]\\<^sub>{Regions.region \\<X> I r |I r.\n                     Regions.valid_region \\<X> k I r}\n  [u]\\<^sub>{Regions.region \\<X> I r |I r. Regions.valid_region \\<X> k I r}\n  \\<in> {Regions.region \\<X> I r |I r. Regions.valid_region \\<X> k I r}\n\ngoal (1 subgoal):\n 1. (\\<And>I r.\n        \\<lbrakk>[u]\\<^sub>{Regions.region \\<X> I r |I r.\n                            Regions.valid_region \\<X> k I r} =\n                 Regions.region \\<X> I r;\n         Regions.valid_region \\<X> k I r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  [u]\\<^sub>\\<R> = Regions.region \\<X> I r\n  Regions.valid_region \\<X> k I r\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>\\<X>.\n       \\<forall>u\\<in>[u]\\<^sub>\\<R>.\n          \\<not> (\\<exists>d\\<le>k c. u c = real d)", "have \"\\<nexists>d. d \\<le> k c \\<and> u' c = real d\" if \"c \\<in> \\<X>\" \"u' \\<in> [u]\\<^sub>\\<R>\" for c u'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>d\\<le>k c. u' c = real d)", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>d \\<le> k c; u' c = real d\\<rbrakk> \\<Longrightarrow> False", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>d \\<le> k c; u' c = real d\\<rbrakk> \\<Longrightarrow> False", "assume A: \"d \\<le> k c\" \"u' c = real d\""], ["proof (state)\nthis:\n  d \\<le> k c\n  u' c = real d\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>d \\<le> k c; u' c = real d\\<rbrakk> \\<Longrightarrow> False", "from I that"], ["proof (chain)\npicking this:\n  [u]\\<^sub>\\<R> = Regions.region \\<X> I r\n  Regions.valid_region \\<X> k I r\n  c \\<in> \\<X>\n  u' \\<in> [u]\\<^sub>\\<R>", "have \"intv_elem c u' (I c)\" \"valid_intv (k c) (I c)\""], ["proof (prove)\nusing this:\n  [u]\\<^sub>\\<R> = Regions.region \\<X> I r\n  Regions.valid_region \\<X> k I r\n  c \\<in> \\<X>\n  u' \\<in> [u]\\<^sub>\\<R>\n\ngoal (1 subgoal):\n 1. Regions.intv_elem c u' (I c) &&& Regions.valid_intv (k c) (I c)", "by auto"], ["proof (state)\nthis:\n  Regions.intv_elem c u' (I c)\n  Regions.valid_intv (k c) (I c)\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>d \\<le> k c; u' c = real d\\<rbrakk> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  Regions.intv_elem c u' (I c)\n  Regions.valid_intv (k c) (I c)", "show False"], ["proof (prove)\nusing this:\n  Regions.intv_elem c u' (I c)\n  Regions.valid_intv (k c) (I c)\n\ngoal (1 subgoal):\n 1. False", "using A I \\<open>u \\<in> [u]\\<^sub>\\<R>\\<close> \\<open>c \\<in> \\<X>\\<close> assms(2)"], ["proof (prove)\nusing this:\n  Regions.intv_elem c u' (I c)\n  Regions.valid_intv (k c) (I c)\n  d \\<le> k c\n  u' c = real d\n  [u]\\<^sub>\\<R> = Regions.region \\<X> I r\n  Regions.valid_region \\<X> k I r\n  u \\<in> [u]\\<^sub>\\<R>\n  c \\<in> \\<X>\n  \\<forall>c\\<in>\\<X>. \\<not> (\\<exists>d\\<le>k c. u c = real d)\n\ngoal (1 subgoal):\n 1. False", "by (cases; fastforce)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?c8 \\<in> \\<X>; ?u'8 \\<in> [u]\\<^sub>\\<R>\\<rbrakk>\n  \\<Longrightarrow> \\<not> (\\<exists>d\\<le>k ?c8. ?u'8 ?c8 = real d)\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>\\<X>.\n       \\<forall>u\\<in>[u]\\<^sub>\\<R>.\n          \\<not> (\\<exists>d\\<le>k c. u c = real d)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?c8 \\<in> \\<X>; ?u'8 \\<in> [u]\\<^sub>\\<R>\\<rbrakk>\n  \\<Longrightarrow> \\<not> (\\<exists>d\\<le>k ?c8. ?u'8 ?c8 = real d)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?c8 \\<in> \\<X>; ?u'8 \\<in> [u]\\<^sub>\\<R>\\<rbrakk>\n  \\<Longrightarrow> \\<not> (\\<exists>d\\<le>k ?c8. ?u'8 ?c8 = real d)\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>\\<X>.\n       \\<forall>u\\<in>[u]\\<^sub>\\<R>.\n          \\<not> (\\<exists>d\\<le>k c. u c = real d)", "by auto"], ["proof (state)\nthis:\n  \\<forall>c\\<in>\\<X>.\n     \\<forall>u\\<in>[u]\\<^sub>\\<R>.\n        \\<not> (\\<exists>d\\<le>k c. u c = real d)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma K_cfg_trans':\n  assumes \"repcs (l, u) cfg \\<in> MDP.cfg_on (l, u)\" \"cfg' \\<in> K_cfg (repcs (l, u) cfg)\"\n          \"state cfg' = (l', u')\" \"(l, u) \\<in> S\" \"cfg \\<in> R_G.valid_cfg\" \"abss (l, u) = state cfg\"\n  shows \"trans' u u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans' u u'", "using assms"], ["proof (prove)\nusing this:\n  repcs (l, u) cfg \\<in> MDP.cfg_on (l, u)\n  cfg' \\<in> set_pmf (K_cfg (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n\ngoal (1 subgoal):\n 1. trans' u u'", "apply (simp add: set_K_cfg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>repcs (l, u) cfg \\<in> MDP.cfg_on (l, u);\n     cfg'\n     \\<in> cont (repcs (l, u) cfg) ` set_pmf (action (repcs (l, u) cfg));\n     state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n     abss (l, u) = state cfg\\<rbrakk>\n    \\<Longrightarrow> trans' u u'", "apply (drule MDP.cfg_onD_action)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cfg'\n             \\<in> cont (repcs (l, u) cfg) `\n                   set_pmf (action (repcs (l, u) cfg));\n     state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n     abss (l, u) = state cfg;\n     action (repcs (l, u) cfg) \\<in> K (l, u)\\<rbrakk>\n    \\<Longrightarrow> trans' u u'", "apply (cases rule: K.cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>cfg'\n             \\<in> cont (repcs (l, u) cfg) `\n                   set_pmf (action (repcs (l, u) cfg));\n     state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n     abss (l, u) = state cfg;\n     action (repcs (l, u) cfg) \\<in> K (l, u)\\<rbrakk>\n    \\<Longrightarrow> ?a8 \\<in> K ?st8\n 2. \\<And>la ua t.\n       \\<lbrakk>cfg'\n                \\<in> cont (repcs (l, u) cfg) `\n                      set_pmf (action (repcs (l, u) cfg));\n        state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n        abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n        ?a8 = return_pmf (la, ua \\<oplus> t); ?st8 \\<in> S; ?st8 = (la, ua);\n        0 \\<le> t; ua \\<oplus> t \\<turnstile> PTA.inv_of A la\\<rbrakk>\n       \\<Longrightarrow> trans' u u'\n 3. \\<And>la ua g \\<mu>.\n       \\<lbrakk>cfg'\n                \\<in> cont (repcs (l, u) cfg) `\n                      set_pmf (action (repcs (l, u) cfg));\n        state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n        abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n        ?a8 =\n        map_pmf\n         (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]ua))\n         \\<mu>;\n        ?st8 \\<in> S; ?st8 = (la, ua); (la, g, \\<mu>) \\<in> PTA.trans_of A;\n        ua \\<turnstile> g\\<rbrakk>\n       \\<Longrightarrow> trans' u u'\n 4. \\<lbrakk>cfg'\n             \\<in> cont (repcs (l, u) cfg) `\n                   set_pmf (action (repcs (l, u) cfg));\n     state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n     abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n     ?a8 = return_pmf ?st8\\<rbrakk>\n    \\<Longrightarrow> trans' u u'", "apply assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>la ua t.\n       \\<lbrakk>cfg'\n                \\<in> cont (repcs (l, u) cfg) `\n                      set_pmf (action (repcs (l, u) cfg));\n        state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n        abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n        action (repcs (l, u) cfg) = return_pmf (la, ua \\<oplus> t);\n        (l, u) \\<in> S; (l, u) = (la, ua); 0 \\<le> t;\n        ua \\<oplus> t \\<turnstile> PTA.inv_of A la\\<rbrakk>\n       \\<Longrightarrow> trans' u u'\n 2. \\<And>la ua g \\<mu>.\n       \\<lbrakk>cfg'\n                \\<in> cont (repcs (l, u) cfg) `\n                      set_pmf (action (repcs (l, u) cfg));\n        state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n        abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n        action (repcs (l, u) cfg) =\n        map_pmf\n         (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]ua))\n         \\<mu>;\n        (l, u) \\<in> S; (l, u) = (la, ua);\n        (la, g, \\<mu>) \\<in> PTA.trans_of A; ua \\<turnstile> g\\<rbrakk>\n       \\<Longrightarrow> trans' u u'\n 3. \\<lbrakk>cfg'\n             \\<in> cont (repcs (l, u) cfg) `\n                   set_pmf (action (repcs (l, u) cfg));\n     state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n     abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n     action (repcs (l, u) cfg) = return_pmf (l, u)\\<rbrakk>\n    \\<Longrightarrow> trans' u u'", "proof goal_cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>la ua t.\n       \\<lbrakk>cfg'\n                \\<in> cont (repcs (l, u) cfg) `\n                      set_pmf (action (repcs (l, u) cfg));\n        state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n        abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n        action (repcs (l, u) cfg) = return_pmf (la, ua \\<oplus> t);\n        (l, u) \\<in> S; (l, u) = (la, ua); 0 \\<le> t;\n        ua \\<oplus> t \\<turnstile> PTA.inv_of A la\\<rbrakk>\n       \\<Longrightarrow> trans' u u'\n 2. \\<And>la ua g \\<mu>.\n       \\<lbrakk>cfg'\n                \\<in> cont (repcs (l, u) cfg) `\n                      set_pmf (action (repcs (l, u) cfg));\n        state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n        abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n        action (repcs (l, u) cfg) =\n        map_pmf\n         (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]ua))\n         \\<mu>;\n        (l, u) \\<in> S; (l, u) = (la, ua);\n        (la, g, \\<mu>) \\<in> PTA.trans_of A; ua \\<turnstile> g\\<rbrakk>\n       \\<Longrightarrow> trans' u u'\n 3. \\<lbrakk>cfg'\n             \\<in> cont (repcs (l, u) cfg) `\n                   set_pmf (action (repcs (l, u) cfg));\n     state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n     abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n     action (repcs (l, u) cfg) = return_pmf (l, u)\\<rbrakk>\n    \\<Longrightarrow> trans' u u'", "case prems: (1 l u t)"], ["proof (state)\nthis:\n  cfg' \\<in> cont (repcs (l, u) cfg) ` set_pmf (action (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  action (repcs (l, u) cfg) \\<in> K (l, u)\n  action (repcs (l, u) cfg) = return_pmf (l, u \\<oplus> t)\n  (l, u) \\<in> S\n  (l, u) = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l\n\ngoal (3 subgoals):\n 1. \\<And>la ua t.\n       \\<lbrakk>cfg'\n                \\<in> cont (repcs (l, u) cfg) `\n                      set_pmf (action (repcs (l, u) cfg));\n        state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n        abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n        action (repcs (l, u) cfg) = return_pmf (la, ua \\<oplus> t);\n        (l, u) \\<in> S; (l, u) = (la, ua); 0 \\<le> t;\n        ua \\<oplus> t \\<turnstile> PTA.inv_of A la\\<rbrakk>\n       \\<Longrightarrow> trans' u u'\n 2. \\<And>la ua g \\<mu>.\n       \\<lbrakk>cfg'\n                \\<in> cont (repcs (l, u) cfg) `\n                      set_pmf (action (repcs (l, u) cfg));\n        state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n        abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n        action (repcs (l, u) cfg) =\n        map_pmf\n         (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]ua))\n         \\<mu>;\n        (l, u) \\<in> S; (l, u) = (la, ua);\n        (la, g, \\<mu>) \\<in> PTA.trans_of A; ua \\<turnstile> g\\<rbrakk>\n       \\<Longrightarrow> trans' u u'\n 3. \\<lbrakk>cfg'\n             \\<in> cont (repcs (l, u) cfg) `\n                   set_pmf (action (repcs (l, u) cfg));\n     state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n     abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n     action (repcs (l, u) cfg) = return_pmf (l, u)\\<rbrakk>\n    \\<Longrightarrow> trans' u u'", "from assms \\<open>_ = (l, u)\\<close>"], ["proof (chain)\npicking this:\n  repcs (l, u) cfg \\<in> MDP.cfg_on (l, u)\n  cfg' \\<in> set_pmf (K_cfg (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  (l, u) = (l, u)", "have \"repcs (l, u) cfg \\<in> valid_cfg\""], ["proof (prove)\nusing this:\n  repcs (l, u) cfg \\<in> MDP.cfg_on (l, u)\n  cfg' \\<in> set_pmf (K_cfg (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  (l, u) = (l, u)\n\ngoal (1 subgoal):\n 1. repcs (l, u) cfg \\<in> MDP.valid_cfg", "by (auto intro: MDP.valid_cfgI)"], ["proof (state)\nthis:\n  repcs (l, u) cfg \\<in> MDP.valid_cfg\n\ngoal (3 subgoals):\n 1. \\<And>la ua t.\n       \\<lbrakk>cfg'\n                \\<in> cont (repcs (l, u) cfg) `\n                      set_pmf (action (repcs (l, u) cfg));\n        state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n        abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n        action (repcs (l, u) cfg) = return_pmf (la, ua \\<oplus> t);\n        (l, u) \\<in> S; (l, u) = (la, ua); 0 \\<le> t;\n        ua \\<oplus> t \\<turnstile> PTA.inv_of A la\\<rbrakk>\n       \\<Longrightarrow> trans' u u'\n 2. \\<And>la ua g \\<mu>.\n       \\<lbrakk>cfg'\n                \\<in> cont (repcs (l, u) cfg) `\n                      set_pmf (action (repcs (l, u) cfg));\n        state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n        abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n        action (repcs (l, u) cfg) =\n        map_pmf\n         (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]ua))\n         \\<mu>;\n        (l, u) \\<in> S; (l, u) = (la, ua);\n        (la, g, \\<mu>) \\<in> PTA.trans_of A; ua \\<turnstile> g\\<rbrakk>\n       \\<Longrightarrow> trans' u u'\n 3. \\<lbrakk>cfg'\n             \\<in> cont (repcs (l, u) cfg) `\n                   set_pmf (action (repcs (l, u) cfg));\n     state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n     abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n     action (repcs (l, u) cfg) = return_pmf (l, u)\\<rbrakk>\n    \\<Longrightarrow> trans' u u'", "then"], ["proof (chain)\npicking this:\n  repcs (l, u) cfg \\<in> MDP.valid_cfg", "have \"absc (repcs (l, u) cfg) \\<in> R_G.valid_cfg\""], ["proof (prove)\nusing this:\n  repcs (l, u) cfg \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. absc (repcs (l, u) cfg) \\<in> R_G.valid_cfg", "by auto"], ["proof (state)\nthis:\n  absc (repcs (l, u) cfg) \\<in> R_G.valid_cfg\n\ngoal (3 subgoals):\n 1. \\<And>la ua t.\n       \\<lbrakk>cfg'\n                \\<in> cont (repcs (l, u) cfg) `\n                      set_pmf (action (repcs (l, u) cfg));\n        state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n        abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n        action (repcs (l, u) cfg) = return_pmf (la, ua \\<oplus> t);\n        (l, u) \\<in> S; (l, u) = (la, ua); 0 \\<le> t;\n        ua \\<oplus> t \\<turnstile> PTA.inv_of A la\\<rbrakk>\n       \\<Longrightarrow> trans' u u'\n 2. \\<And>la ua g \\<mu>.\n       \\<lbrakk>cfg'\n                \\<in> cont (repcs (l, u) cfg) `\n                      set_pmf (action (repcs (l, u) cfg));\n        state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n        abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n        action (repcs (l, u) cfg) =\n        map_pmf\n         (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]ua))\n         \\<mu>;\n        (l, u) \\<in> S; (l, u) = (la, ua);\n        (la, g, \\<mu>) \\<in> PTA.trans_of A; ua \\<turnstile> g\\<rbrakk>\n       \\<Longrightarrow> trans' u u'\n 3. \\<lbrakk>cfg'\n             \\<in> cont (repcs (l, u) cfg) `\n                   set_pmf (action (repcs (l, u) cfg));\n     state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n     abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n     action (repcs (l, u) cfg) = return_pmf (l, u)\\<rbrakk>\n    \\<Longrightarrow> trans' u u'", "from prems"], ["proof (chain)\npicking this:\n  cfg' \\<in> cont (repcs (l, u) cfg) ` set_pmf (action (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  action (repcs (l, u) cfg) \\<in> K (l, u)\n  action (repcs (l, u) cfg) = return_pmf (l, u \\<oplus> t)\n  (l, u) \\<in> S\n  (l, u) = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l", "have *: \"rept (l, u) (action cfg) = return_pmf (l, u \\<oplus> t)\""], ["proof (prove)\nusing this:\n  cfg' \\<in> cont (repcs (l, u) cfg) ` set_pmf (action (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  action (repcs (l, u) cfg) \\<in> K (l, u)\n  action (repcs (l, u) cfg) = return_pmf (l, u \\<oplus> t)\n  (l, u) \\<in> S\n  (l, u) = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l\n\ngoal (1 subgoal):\n 1. rept (l, u) (action cfg) = return_pmf (l, u \\<oplus> t)", "unfolding repcs_def"], ["proof (prove)\nusing this:\n  cfg'\n  \\<in> cont\n         (cfg_corec (l, u) (\\<lambda>(s, cfg). rept s (action cfg))\n           (\\<lambda>(s, cfg) s'. (s', cont cfg (abss s'))) ((l, u), cfg)) `\n        set_pmf\n         (action\n           (cfg_corec (l, u) (\\<lambda>(s, cfg). rept s (action cfg))\n             (\\<lambda>(s, cfg) s'. (s', cont cfg (abss s')))\n             ((l, u), cfg)))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  action\n   (cfg_corec (l, u) (\\<lambda>(s, cfg). rept s (action cfg))\n     (\\<lambda>(s, cfg) s'. (s', cont cfg (abss s'))) ((l, u), cfg))\n  \\<in> K (l, u)\n  action\n   (cfg_corec (l, u) (\\<lambda>(s, cfg). rept s (action cfg))\n     (\\<lambda>(s, cfg) s'. (s', cont cfg (abss s'))) ((l, u), cfg)) =\n  return_pmf (l, u \\<oplus> t)\n  (l, u) \\<in> S\n  (l, u) = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l\n\ngoal (1 subgoal):\n 1. rept (l, u) (action cfg) = return_pmf (l, u \\<oplus> t)", "by auto"], ["proof (state)\nthis:\n  rept (l, u) (action cfg) = return_pmf (l, u \\<oplus> t)\n\ngoal (3 subgoals):\n 1. \\<And>la ua t.\n       \\<lbrakk>cfg'\n                \\<in> cont (repcs (l, u) cfg) `\n                      set_pmf (action (repcs (l, u) cfg));\n        state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n        abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n        action (repcs (l, u) cfg) = return_pmf (la, ua \\<oplus> t);\n        (l, u) \\<in> S; (l, u) = (la, ua); 0 \\<le> t;\n        ua \\<oplus> t \\<turnstile> PTA.inv_of A la\\<rbrakk>\n       \\<Longrightarrow> trans' u u'\n 2. \\<And>la ua g \\<mu>.\n       \\<lbrakk>cfg'\n                \\<in> cont (repcs (l, u) cfg) `\n                      set_pmf (action (repcs (l, u) cfg));\n        state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n        abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n        action (repcs (l, u) cfg) =\n        map_pmf\n         (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]ua))\n         \\<mu>;\n        (l, u) \\<in> S; (l, u) = (la, ua);\n        (la, g, \\<mu>) \\<in> PTA.trans_of A; ua \\<turnstile> g\\<rbrakk>\n       \\<Longrightarrow> trans' u u'\n 3. \\<lbrakk>cfg'\n             \\<in> cont (repcs (l, u) cfg) `\n                   set_pmf (action (repcs (l, u) cfg));\n     state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n     abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n     action (repcs (l, u) cfg) = return_pmf (l, u)\\<rbrakk>\n    \\<Longrightarrow> trans' u u'", "from \\<open>abss _ = _\\<close> \\<open>_ = (l, u)\\<close> \\<open>cfg \\<in> R_G.valid_cfg\\<close>"], ["proof (chain)\npicking this:\n  abss (l, u) = state cfg\n  (l, u) = (l, u)\n  cfg \\<in> R_G.valid_cfg", "have\n    \"action cfg \\<in> \\<K> (abss (l, u))\""], ["proof (prove)\nusing this:\n  abss (l, u) = state cfg\n  (l, u) = (l, u)\n  cfg \\<in> R_G.valid_cfg\n\ngoal (1 subgoal):\n 1. action cfg \\<in> \\<K> (abss (l, u))", "by (auto dest: R_G_I)"], ["proof (state)\nthis:\n  action cfg \\<in> \\<K> (abss (l, u))\n\ngoal (3 subgoals):\n 1. \\<And>la ua t.\n       \\<lbrakk>cfg'\n                \\<in> cont (repcs (l, u) cfg) `\n                      set_pmf (action (repcs (l, u) cfg));\n        state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n        abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n        action (repcs (l, u) cfg) = return_pmf (la, ua \\<oplus> t);\n        (l, u) \\<in> S; (l, u) = (la, ua); 0 \\<le> t;\n        ua \\<oplus> t \\<turnstile> PTA.inv_of A la\\<rbrakk>\n       \\<Longrightarrow> trans' u u'\n 2. \\<And>la ua g \\<mu>.\n       \\<lbrakk>cfg'\n                \\<in> cont (repcs (l, u) cfg) `\n                      set_pmf (action (repcs (l, u) cfg));\n        state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n        abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n        action (repcs (l, u) cfg) =\n        map_pmf\n         (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]ua))\n         \\<mu>;\n        (l, u) \\<in> S; (l, u) = (la, ua);\n        (la, g, \\<mu>) \\<in> PTA.trans_of A; ua \\<turnstile> g\\<rbrakk>\n       \\<Longrightarrow> trans' u u'\n 3. \\<lbrakk>cfg'\n             \\<in> cont (repcs (l, u) cfg) `\n                   set_pmf (action (repcs (l, u) cfg));\n     state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n     abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n     action (repcs (l, u) cfg) = return_pmf (l, u)\\<rbrakk>\n    \\<Longrightarrow> trans' u u'", "from abst_rept_id[OF this] *"], ["proof (chain)\npicking this:\n  abst (rept (l, u) (action cfg)) = action cfg\n  rept (l, u) (action cfg) = return_pmf (l, u \\<oplus> t)", "have \"action cfg = abst (return_pmf (l, u \\<oplus> t))\""], ["proof (prove)\nusing this:\n  abst (rept (l, u) (action cfg)) = action cfg\n  rept (l, u) (action cfg) = return_pmf (l, u \\<oplus> t)\n\ngoal (1 subgoal):\n 1. action cfg = abst (return_pmf (l, u \\<oplus> t))", "by auto"], ["proof (state)\nthis:\n  action cfg = abst (return_pmf (l, u \\<oplus> t))\n\ngoal (3 subgoals):\n 1. \\<And>la ua t.\n       \\<lbrakk>cfg'\n                \\<in> cont (repcs (l, u) cfg) `\n                      set_pmf (action (repcs (l, u) cfg));\n        state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n        abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n        action (repcs (l, u) cfg) = return_pmf (la, ua \\<oplus> t);\n        (l, u) \\<in> S; (l, u) = (la, ua); 0 \\<le> t;\n        ua \\<oplus> t \\<turnstile> PTA.inv_of A la\\<rbrakk>\n       \\<Longrightarrow> trans' u u'\n 2. \\<And>la ua g \\<mu>.\n       \\<lbrakk>cfg'\n                \\<in> cont (repcs (l, u) cfg) `\n                      set_pmf (action (repcs (l, u) cfg));\n        state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n        abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n        action (repcs (l, u) cfg) =\n        map_pmf\n         (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]ua))\n         \\<mu>;\n        (l, u) \\<in> S; (l, u) = (la, ua);\n        (la, g, \\<mu>) \\<in> PTA.trans_of A; ua \\<turnstile> g\\<rbrakk>\n       \\<Longrightarrow> trans' u u'\n 3. \\<lbrakk>cfg'\n             \\<in> cont (repcs (l, u) cfg) `\n                   set_pmf (action (repcs (l, u) cfg));\n     state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n     abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n     action (repcs (l, u) cfg) = return_pmf (l, u)\\<rbrakk>\n    \\<Longrightarrow> trans' u u'", "with prems"], ["proof (chain)\npicking this:\n  cfg' \\<in> cont (repcs (l, u) cfg) ` set_pmf (action (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  action (repcs (l, u) cfg) \\<in> K (l, u)\n  action (repcs (l, u) cfg) = return_pmf (l, u \\<oplus> t)\n  (l, u) \\<in> S\n  (l, u) = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l\n  action cfg = abst (return_pmf (l, u \\<oplus> t))", "have **: \"action cfg = return_pmf (l, [u \\<oplus> t]\\<^sub>\\<R>)\""], ["proof (prove)\nusing this:\n  cfg' \\<in> cont (repcs (l, u) cfg) ` set_pmf (action (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  action (repcs (l, u) cfg) \\<in> K (l, u)\n  action (repcs (l, u) cfg) = return_pmf (l, u \\<oplus> t)\n  (l, u) \\<in> S\n  (l, u) = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l\n  action cfg = abst (return_pmf (l, u \\<oplus> t))\n\ngoal (1 subgoal):\n 1. action cfg = return_pmf (l, [u \\<oplus> t]\\<^sub>\\<R>)", "unfolding abst_def"], ["proof (prove)\nusing this:\n  cfg' \\<in> cont (repcs (l, u) cfg) ` set_pmf (action (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  action (repcs (l, u) cfg) \\<in> K (l, u)\n  action (repcs (l, u) cfg) = return_pmf (l, u \\<oplus> t)\n  (l, u) \\<in> S\n  (l, u) = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l\n  action cfg = map_pmf abss (return_pmf (l, u \\<oplus> t))\n\ngoal (1 subgoal):\n 1. action cfg = return_pmf (l, [u \\<oplus> t]\\<^sub>\\<R>)", "by auto"], ["proof (state)\nthis:\n  action cfg = return_pmf (l, [u \\<oplus> t]\\<^sub>\\<R>)\n\ngoal (3 subgoals):\n 1. \\<And>la ua t.\n       \\<lbrakk>cfg'\n                \\<in> cont (repcs (l, u) cfg) `\n                      set_pmf (action (repcs (l, u) cfg));\n        state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n        abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n        action (repcs (l, u) cfg) = return_pmf (la, ua \\<oplus> t);\n        (l, u) \\<in> S; (l, u) = (la, ua); 0 \\<le> t;\n        ua \\<oplus> t \\<turnstile> PTA.inv_of A la\\<rbrakk>\n       \\<Longrightarrow> trans' u u'\n 2. \\<And>la ua g \\<mu>.\n       \\<lbrakk>cfg'\n                \\<in> cont (repcs (l, u) cfg) `\n                      set_pmf (action (repcs (l, u) cfg));\n        state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n        abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n        action (repcs (l, u) cfg) =\n        map_pmf\n         (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]ua))\n         \\<mu>;\n        (l, u) \\<in> S; (l, u) = (la, ua);\n        (la, g, \\<mu>) \\<in> PTA.trans_of A; ua \\<turnstile> g\\<rbrakk>\n       \\<Longrightarrow> trans' u u'\n 3. \\<lbrakk>cfg'\n             \\<in> cont (repcs (l, u) cfg) `\n                   set_pmf (action (repcs (l, u) cfg));\n     state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n     abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n     action (repcs (l, u) cfg) = return_pmf (l, u)\\<rbrakk>\n    \\<Longrightarrow> trans' u u'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. trans' u u'", "proof (cases \"\\<forall> c \\<in> \\<X>. u c > k c\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u c \\<Longrightarrow> trans' u u'\n 2. \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<Longrightarrow>\n    trans' u u'", "case True"], ["proof (state)\nthis:\n  \\<forall>c\\<in>\\<X>. real (k c) < u c\n\ngoal (2 subgoals):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u c \\<Longrightarrow> trans' u u'\n 2. \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<Longrightarrow>\n    trans' u u'", "from prems"], ["proof (chain)\npicking this:\n  cfg' \\<in> cont (repcs (l, u) cfg) ` set_pmf (action (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  action (repcs (l, u) cfg) \\<in> K (l, u)\n  action (repcs (l, u) cfg) = return_pmf (l, u \\<oplus> t)\n  (l, u) \\<in> S\n  (l, u) = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l", "have \"u \\<oplus> t \\<in> [u]\\<^sub>\\<R>\""], ["proof (prove)\nusing this:\n  cfg' \\<in> cont (repcs (l, u) cfg) ` set_pmf (action (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  action (repcs (l, u) cfg) \\<in> K (l, u)\n  action (repcs (l, u) cfg) = return_pmf (l, u \\<oplus> t)\n  (l, u) \\<in> S\n  (l, u) = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l\n\ngoal (1 subgoal):\n 1. u \\<oplus> t \\<in> [u]\\<^sub>\\<R>", "by (auto intro: upper_right_closed[OF True])"], ["proof (state)\nthis:\n  u \\<oplus> t \\<in> [u]\\<^sub>\\<R>\n\ngoal (2 subgoals):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u c \\<Longrightarrow> trans' u u'\n 2. \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<Longrightarrow>\n    trans' u u'", "with prems"], ["proof (chain)\npicking this:\n  cfg' \\<in> cont (repcs (l, u) cfg) ` set_pmf (action (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  action (repcs (l, u) cfg) \\<in> K (l, u)\n  action (repcs (l, u) cfg) = return_pmf (l, u \\<oplus> t)\n  (l, u) \\<in> S\n  (l, u) = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l\n  u \\<oplus> t \\<in> [u]\\<^sub>\\<R>", "have \"[u \\<oplus> t]\\<^sub>\\<R> = [u]\\<^sub>\\<R>\""], ["proof (prove)\nusing this:\n  cfg' \\<in> cont (repcs (l, u) cfg) ` set_pmf (action (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  action (repcs (l, u) cfg) \\<in> K (l, u)\n  action (repcs (l, u) cfg) = return_pmf (l, u \\<oplus> t)\n  (l, u) \\<in> S\n  (l, u) = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l\n  u \\<oplus> t \\<in> [u]\\<^sub>\\<R>\n\ngoal (1 subgoal):\n 1. [u \\<oplus> t]\\<^sub>\\<R> = [u]\\<^sub>\\<R>", "by (auto dest: alpha_interp.region_unique_spec)"], ["proof (state)\nthis:\n  [u \\<oplus> t]\\<^sub>\\<R> = [u]\\<^sub>\\<R>\n\ngoal (2 subgoals):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u c \\<Longrightarrow> trans' u u'\n 2. \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<Longrightarrow>\n    trans' u u'", "with **"], ["proof (chain)\npicking this:\n  action cfg = return_pmf (l, [u \\<oplus> t]\\<^sub>\\<R>)\n  [u \\<oplus> t]\\<^sub>\\<R> = [u]\\<^sub>\\<R>", "have \"action cfg = return_pmf (l, [u]\\<^sub>\\<R>)\""], ["proof (prove)\nusing this:\n  action cfg = return_pmf (l, [u \\<oplus> t]\\<^sub>\\<R>)\n  [u \\<oplus> t]\\<^sub>\\<R> = [u]\\<^sub>\\<R>\n\ngoal (1 subgoal):\n 1. action cfg = return_pmf (l, [u]\\<^sub>\\<R>)", "by simp"], ["proof (state)\nthis:\n  action cfg = return_pmf (l, [u]\\<^sub>\\<R>)\n\ngoal (2 subgoals):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u c \\<Longrightarrow> trans' u u'\n 2. \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<Longrightarrow>\n    trans' u u'", "with True"], ["proof (chain)\npicking this:\n  \\<forall>c\\<in>\\<X>. real (k c) < u c\n  action cfg = return_pmf (l, [u]\\<^sub>\\<R>)", "have \"rept (l, u) (action cfg) = return_pmf (l, u \\<oplus> 0.5)\""], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>\\<X>. real (k c) < u c\n  action cfg = return_pmf (l, [u]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. rept (l, u) (action cfg) = return_pmf (l, u \\<oplus> 5 / 10)", "unfolding rept_def"], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>\\<X>. real (k c) < u c\n  action cfg = return_pmf (l, [u]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. (let (l, u) = (l, u)\n     in if \\<exists>R'.\n              (l, u) \\<in> S \\<and>\n              action cfg = return_pmf (l, R') \\<and>\n              [u]\\<^sub>\\<R> = R' \\<and>\n              (\\<forall>c\\<in>\\<X>. real (k c) < u c)\n        then return_pmf (l, u \\<oplus> 5 / 10)\n        else if \\<exists>R'.\n                   (l, u) \\<in> S \\<and>\n                   action cfg = return_pmf (l, R') \\<and>\n                   R' \\<in> Succ \\<R> ([u]\\<^sub>\\<R>) \\<and>\n                   [u]\\<^sub>\\<R> \\<noteq> R' \\<and>\n                   (\\<forall>u\\<in>R'.\n                       \\<forall>c\\<in>\\<X>.\n                          \\<not> (\\<exists>d\\<le>k c. u c = real d))\n             then return_pmf\n                   (l, delayedR (SOME R'. action cfg = return_pmf (l, R'))\n                        u)\n             else SOME \\<mu>.\n                     \\<mu> \\<in> K (l, u) \\<and> abst \\<mu> = action cfg) =\n    return_pmf (l, u \\<oplus> 5 / 10)", "using prems"], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>\\<X>. real (k c) < u c\n  action cfg = return_pmf (l, [u]\\<^sub>\\<R>)\n  cfg' \\<in> cont (repcs (l, u) cfg) ` set_pmf (action (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  action (repcs (l, u) cfg) \\<in> K (l, u)\n  action (repcs (l, u) cfg) = return_pmf (l, u \\<oplus> t)\n  (l, u) \\<in> S\n  (l, u) = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l\n\ngoal (1 subgoal):\n 1. (let (l, u) = (l, u)\n     in if \\<exists>R'.\n              (l, u) \\<in> S \\<and>\n              action cfg = return_pmf (l, R') \\<and>\n              [u]\\<^sub>\\<R> = R' \\<and>\n              (\\<forall>c\\<in>\\<X>. real (k c) < u c)\n        then return_pmf (l, u \\<oplus> 5 / 10)\n        else if \\<exists>R'.\n                   (l, u) \\<in> S \\<and>\n                   action cfg = return_pmf (l, R') \\<and>\n                   R' \\<in> Succ \\<R> ([u]\\<^sub>\\<R>) \\<and>\n                   [u]\\<^sub>\\<R> \\<noteq> R' \\<and>\n                   (\\<forall>u\\<in>R'.\n                       \\<forall>c\\<in>\\<X>.\n                          \\<not> (\\<exists>d\\<le>k c. u c = real d))\n             then return_pmf\n                   (l, delayedR (SOME R'. action cfg = return_pmf (l, R'))\n                        u)\n             else SOME \\<mu>.\n                     \\<mu> \\<in> K (l, u) \\<and> abst \\<mu> = action cfg) =\n    return_pmf (l, u \\<oplus> 5 / 10)", "by auto"], ["proof (state)\nthis:\n  rept (l, u) (action cfg) = return_pmf (l, u \\<oplus> 5 / 10)\n\ngoal (2 subgoals):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u c \\<Longrightarrow> trans' u u'\n 2. \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<Longrightarrow>\n    trans' u u'", "with *"], ["proof (chain)\npicking this:\n  rept (l, u) (action cfg) = return_pmf (l, u \\<oplus> t)\n  rept (l, u) (action cfg) = return_pmf (l, u \\<oplus> 5 / 10)", "have \"u \\<oplus> t = u \\<oplus> 0.5\""], ["proof (prove)\nusing this:\n  rept (l, u) (action cfg) = return_pmf (l, u \\<oplus> t)\n  rept (l, u) (action cfg) = return_pmf (l, u \\<oplus> 5 / 10)\n\ngoal (1 subgoal):\n 1. u \\<oplus> t = u \\<oplus> 5 / 10", "by auto"], ["proof (state)\nthis:\n  u \\<oplus> t = u \\<oplus> 5 / 10\n\ngoal (2 subgoals):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u c \\<Longrightarrow> trans' u u'\n 2. \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<Longrightarrow>\n    trans' u u'", "moreover"], ["proof (state)\nthis:\n  u \\<oplus> t = u \\<oplus> 5 / 10\n\ngoal (2 subgoals):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u c \\<Longrightarrow> trans' u u'\n 2. \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<Longrightarrow>\n    trans' u u'", "from prems"], ["proof (chain)\npicking this:\n  cfg' \\<in> cont (repcs (l, u) cfg) ` set_pmf (action (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  action (repcs (l, u) cfg) \\<in> K (l, u)\n  action (repcs (l, u) cfg) = return_pmf (l, u \\<oplus> t)\n  (l, u) \\<in> S\n  (l, u) = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l", "have \"u' = u \\<oplus> t\""], ["proof (prove)\nusing this:\n  cfg' \\<in> cont (repcs (l, u) cfg) ` set_pmf (action (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  action (repcs (l, u) cfg) \\<in> K (l, u)\n  action (repcs (l, u) cfg) = return_pmf (l, u \\<oplus> t)\n  (l, u) \\<in> S\n  (l, u) = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l\n\ngoal (1 subgoal):\n 1. u' = u \\<oplus> t", "by auto"], ["proof (state)\nthis:\n  u' = u \\<oplus> t\n\ngoal (2 subgoals):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u c \\<Longrightarrow> trans' u u'\n 2. \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<Longrightarrow>\n    trans' u u'", "moreover"], ["proof (state)\nthis:\n  u' = u \\<oplus> t\n\ngoal (2 subgoals):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u c \\<Longrightarrow> trans' u u'\n 2. \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<Longrightarrow>\n    trans' u u'", "from prems True"], ["proof (chain)\npicking this:\n  cfg' \\<in> cont (repcs (l, u) cfg) ` set_pmf (action (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  action (repcs (l, u) cfg) \\<in> K (l, u)\n  action (repcs (l, u) cfg) = return_pmf (l, u \\<oplus> t)\n  (l, u) \\<in> S\n  (l, u) = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l\n  \\<forall>c\\<in>\\<X>. real (k c) < u c", "have \"\\<forall> c \\<in> \\<X>. u' c > k c\""], ["proof (prove)\nusing this:\n  cfg' \\<in> cont (repcs (l, u) cfg) ` set_pmf (action (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  action (repcs (l, u) cfg) \\<in> K (l, u)\n  action (repcs (l, u) cfg) = return_pmf (l, u \\<oplus> t)\n  (l, u) \\<in> S\n  (l, u) = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l\n  \\<forall>c\\<in>\\<X>. real (k c) < u c\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u' c", "by (auto simp: cval_add_def)"], ["proof (state)\nthis:\n  \\<forall>c\\<in>\\<X>. real (k c) < u' c\n\ngoal (2 subgoals):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u c \\<Longrightarrow> trans' u u'\n 2. \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<Longrightarrow>\n    trans' u u'", "ultimately"], ["proof (chain)\npicking this:\n  u \\<oplus> t = u \\<oplus> 5 / 10\n  u' = u \\<oplus> t\n  \\<forall>c\\<in>\\<X>. real (k c) < u' c", "show ?thesis"], ["proof (prove)\nusing this:\n  u \\<oplus> t = u \\<oplus> 5 / 10\n  u' = u \\<oplus> t\n  \\<forall>c\\<in>\\<X>. real (k c) < u' c\n\ngoal (1 subgoal):\n 1. trans' u u'", "using True \\<open>_ = (l, u)\\<close>"], ["proof (prove)\nusing this:\n  u \\<oplus> t = u \\<oplus> 5 / 10\n  u' = u \\<oplus> t\n  \\<forall>c\\<in>\\<X>. real (k c) < u' c\n  \\<forall>c\\<in>\\<X>. real (k c) < u c\n  (l, u) = (l, u)\n\ngoal (1 subgoal):\n 1. trans' u u'", "unfolding trans'_def"], ["proof (prove)\nusing this:\n  u \\<oplus> t = u \\<oplus> 5 / 10\n  u' = u \\<oplus> t\n  \\<forall>c\\<in>\\<X>. real (k c) < u' c\n  \\<forall>c\\<in>\\<X>. real (k c) < u c\n  (l, u) = (l, u)\n\ngoal (1 subgoal):\n 1. ((\\<forall>c\\<in>\\<X>.\n         real (k c) < u c \\<and>\n         real (k c) < u' c \\<and> u \\<noteq> u') \\<longrightarrow>\n     u' = u \\<oplus> 5 / 10) \\<and>\n    ((\\<exists>c\\<in>\\<X>.\n         u c = 0 \\<and>\n         0 < u' c \\<and>\n         (\\<forall>c\\<in>\\<X>.\n             \\<not> (\\<exists>d\\<le>k c. u' c = real d))) \\<longrightarrow>\n     u' = delayedR ([u']\\<^sub>\\<R>) u)", "by auto"], ["proof (state)\nthis:\n  trans' u u'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<Longrightarrow>\n    trans' u u'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<Longrightarrow>\n    trans' u u'", "case F: False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<Longrightarrow>\n    trans' u u'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. trans' u u'", "proof (cases \"\\<exists>c\\<in>\\<X>. u c = 0 \\<and> 0 < u' c \\<and> (\\<forall>c\\<in>\\<X>. \\<nexists>d. d \\<le> k c \\<and> u' c = real d)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>c\\<in>\\<X>.\n       u c = 0 \\<and>\n       0 < u' c \\<and>\n       (\\<forall>c\\<in>\\<X>.\n           \\<not> (\\<exists>d\\<le>k c. u' c = real d)) \\<Longrightarrow>\n    trans' u u'\n 2. \\<not> (\\<exists>c\\<in>\\<X>.\n               u c = 0 \\<and>\n               0 < u' c \\<and>\n               (\\<forall>c\\<in>\\<X>.\n                   \\<not> (\\<exists>d\\<le>k c.\n                              u' c = real d))) \\<Longrightarrow>\n    trans' u u'", "case True"], ["proof (state)\nthis:\n  \\<exists>c\\<in>\\<X>.\n     u c = 0 \\<and>\n     0 < u' c \\<and>\n     (\\<forall>c\\<in>\\<X>. \\<not> (\\<exists>d\\<le>k c. u' c = real d))\n\ngoal (2 subgoals):\n 1. \\<exists>c\\<in>\\<X>.\n       u c = 0 \\<and>\n       0 < u' c \\<and>\n       (\\<forall>c\\<in>\\<X>.\n           \\<not> (\\<exists>d\\<le>k c. u' c = real d)) \\<Longrightarrow>\n    trans' u u'\n 2. \\<not> (\\<exists>c\\<in>\\<X>.\n               u c = 0 \\<and>\n               0 < u' c \\<and>\n               (\\<forall>c\\<in>\\<X>.\n                   \\<not> (\\<exists>d\\<le>k c.\n                              u' c = real d))) \\<Longrightarrow>\n    trans' u u'", "from prems"], ["proof (chain)\npicking this:\n  cfg' \\<in> cont (repcs (l, u) cfg) ` set_pmf (action (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  action (repcs (l, u) cfg) \\<in> K (l, u)\n  action (repcs (l, u) cfg) = return_pmf (l, u \\<oplus> t)\n  (l, u) \\<in> S\n  (l, u) = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l", "have \"u' \\<in> [u']\\<^sub>\\<R>\""], ["proof (prove)\nusing this:\n  cfg' \\<in> cont (repcs (l, u) cfg) ` set_pmf (action (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  action (repcs (l, u) cfg) \\<in> K (l, u)\n  action (repcs (l, u) cfg) = return_pmf (l, u \\<oplus> t)\n  (l, u) \\<in> S\n  (l, u) = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l\n\ngoal (1 subgoal):\n 1. u' \\<in> [u']\\<^sub>\\<R>", "by auto"], ["proof (state)\nthis:\n  u' \\<in> [u']\\<^sub>\\<R>\n\ngoal (2 subgoals):\n 1. \\<exists>c\\<in>\\<X>.\n       u c = 0 \\<and>\n       0 < u' c \\<and>\n       (\\<forall>c\\<in>\\<X>.\n           \\<not> (\\<exists>d\\<le>k c. u' c = real d)) \\<Longrightarrow>\n    trans' u u'\n 2. \\<not> (\\<exists>c\\<in>\\<X>.\n               u c = 0 \\<and>\n               0 < u' c \\<and>\n               (\\<forall>c\\<in>\\<X>.\n                   \\<not> (\\<exists>d\\<le>k c.\n                              u' c = real d))) \\<Longrightarrow>\n    trans' u u'", "from prems"], ["proof (chain)\npicking this:\n  cfg' \\<in> cont (repcs (l, u) cfg) ` set_pmf (action (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  action (repcs (l, u) cfg) \\<in> K (l, u)\n  action (repcs (l, u) cfg) = return_pmf (l, u \\<oplus> t)\n  (l, u) \\<in> S\n  (l, u) = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l", "have \"[u \\<oplus> t]\\<^sub>\\<R> \\<in> Succ \\<R> ([u]\\<^sub>\\<R>)\""], ["proof (prove)\nusing this:\n  cfg' \\<in> cont (repcs (l, u) cfg) ` set_pmf (action (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  action (repcs (l, u) cfg) \\<in> K (l, u)\n  action (repcs (l, u) cfg) = return_pmf (l, u \\<oplus> t)\n  (l, u) \\<in> S\n  (l, u) = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l\n\ngoal (1 subgoal):\n 1. [u \\<oplus> t]\\<^sub>\\<R> \\<in> Succ \\<R> ([u]\\<^sub>\\<R>)", "by auto"], ["proof (state)\nthis:\n  [u \\<oplus> t]\\<^sub>\\<R> \\<in> Succ \\<R> ([u]\\<^sub>\\<R>)\n\ngoal (2 subgoals):\n 1. \\<exists>c\\<in>\\<X>.\n       u c = 0 \\<and>\n       0 < u' c \\<and>\n       (\\<forall>c\\<in>\\<X>.\n           \\<not> (\\<exists>d\\<le>k c. u' c = real d)) \\<Longrightarrow>\n    trans' u u'\n 2. \\<not> (\\<exists>c\\<in>\\<X>.\n               u c = 0 \\<and>\n               0 < u' c \\<and>\n               (\\<forall>c\\<in>\\<X>.\n                   \\<not> (\\<exists>d\\<le>k c.\n                              u' c = real d))) \\<Longrightarrow>\n    trans' u u'", "from True"], ["proof (chain)\npicking this:\n  \\<exists>c\\<in>\\<X>.\n     u c = 0 \\<and>\n     0 < u' c \\<and>\n     (\\<forall>c\\<in>\\<X>. \\<not> (\\<exists>d\\<le>k c. u' c = real d))", "obtain c where \"c \\<in> \\<X>\" \"u c = 0\" \"u' c > 0\""], ["proof (prove)\nusing this:\n  \\<exists>c\\<in>\\<X>.\n     u c = 0 \\<and>\n     0 < u' c \\<and>\n     (\\<forall>c\\<in>\\<X>. \\<not> (\\<exists>d\\<le>k c. u' c = real d))\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<in> \\<X>; u c = 0; 0 < u' c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c \\<in> \\<X>\n  u c = 0\n  0 < u' c\n\ngoal (2 subgoals):\n 1. \\<exists>c\\<in>\\<X>.\n       u c = 0 \\<and>\n       0 < u' c \\<and>\n       (\\<forall>c\\<in>\\<X>.\n           \\<not> (\\<exists>d\\<le>k c. u' c = real d)) \\<Longrightarrow>\n    trans' u u'\n 2. \\<not> (\\<exists>c\\<in>\\<X>.\n               u c = 0 \\<and>\n               0 < u' c \\<and>\n               (\\<forall>c\\<in>\\<X>.\n                   \\<not> (\\<exists>d\\<le>k c.\n                              u' c = real d))) \\<Longrightarrow>\n    trans' u u'", "with zeroI prems"], ["proof (chain)\npicking this:\n  \\<lbrakk>?c \\<in> \\<X>; ?u \\<in> V; ?u ?c = 0\\<rbrakk>\n  \\<Longrightarrow> zero ?c ([?u]\\<^sub>\\<R>)\n  cfg' \\<in> cont (repcs (l, u) cfg) ` set_pmf (action (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  action (repcs (l, u) cfg) \\<in> K (l, u)\n  action (repcs (l, u) cfg) = return_pmf (l, u \\<oplus> t)\n  (l, u) \\<in> S\n  (l, u) = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l\n  c \\<in> \\<X>\n  u c = 0\n  0 < u' c", "have \"zero c ([u]\\<^sub>\\<R>)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?c \\<in> \\<X>; ?u \\<in> V; ?u ?c = 0\\<rbrakk>\n  \\<Longrightarrow> zero ?c ([?u]\\<^sub>\\<R>)\n  cfg' \\<in> cont (repcs (l, u) cfg) ` set_pmf (action (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  action (repcs (l, u) cfg) \\<in> K (l, u)\n  action (repcs (l, u) cfg) = return_pmf (l, u \\<oplus> t)\n  (l, u) \\<in> S\n  (l, u) = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l\n  c \\<in> \\<X>\n  u c = 0\n  0 < u' c\n\ngoal (1 subgoal):\n 1. zero c ([u]\\<^sub>\\<R>)", "by auto"], ["proof (state)\nthis:\n  zero c ([u]\\<^sub>\\<R>)\n\ngoal (2 subgoals):\n 1. \\<exists>c\\<in>\\<X>.\n       u c = 0 \\<and>\n       0 < u' c \\<and>\n       (\\<forall>c\\<in>\\<X>.\n           \\<not> (\\<exists>d\\<le>k c. u' c = real d)) \\<Longrightarrow>\n    trans' u u'\n 2. \\<not> (\\<exists>c\\<in>\\<X>.\n               u c = 0 \\<and>\n               0 < u' c \\<and>\n               (\\<forall>c\\<in>\\<X>.\n                   \\<not> (\\<exists>d\\<le>k c.\n                              u' c = real d))) \\<Longrightarrow>\n    trans' u u'", "moreover"], ["proof (state)\nthis:\n  zero c ([u]\\<^sub>\\<R>)\n\ngoal (2 subgoals):\n 1. \\<exists>c\\<in>\\<X>.\n       u c = 0 \\<and>\n       0 < u' c \\<and>\n       (\\<forall>c\\<in>\\<X>.\n           \\<not> (\\<exists>d\\<le>k c. u' c = real d)) \\<Longrightarrow>\n    trans' u u'\n 2. \\<not> (\\<exists>c\\<in>\\<X>.\n               u c = 0 \\<and>\n               0 < u' c \\<and>\n               (\\<forall>c\\<in>\\<X>.\n                   \\<not> (\\<exists>d\\<le>k c.\n                              u' c = real d))) \\<Longrightarrow>\n    trans' u u'", "from \\<open>u' \\<in> _\\<close> \\<open>u' c > 0\\<close>"], ["proof (chain)\npicking this:\n  u' \\<in> [u']\\<^sub>\\<R>\n  0 < u' c", "have \"\\<not> zero c ([u']\\<^sub>\\<R>)\""], ["proof (prove)\nusing this:\n  u' \\<in> [u']\\<^sub>\\<R>\n  0 < u' c\n\ngoal (1 subgoal):\n 1. \\<not> zero c ([u']\\<^sub>\\<R>)", "unfolding zero_def"], ["proof (prove)\nusing this:\n  u' \\<in> [u']\\<^sub>\\<R>\n  0 < u' c\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>u\\<in>[u']\\<^sub>\\<R>. u c = 0)", "by fastforce"], ["proof (state)\nthis:\n  \\<not> zero c ([u']\\<^sub>\\<R>)\n\ngoal (2 subgoals):\n 1. \\<exists>c\\<in>\\<X>.\n       u c = 0 \\<and>\n       0 < u' c \\<and>\n       (\\<forall>c\\<in>\\<X>.\n           \\<not> (\\<exists>d\\<le>k c. u' c = real d)) \\<Longrightarrow>\n    trans' u u'\n 2. \\<not> (\\<exists>c\\<in>\\<X>.\n               u c = 0 \\<and>\n               0 < u' c \\<and>\n               (\\<forall>c\\<in>\\<X>.\n                   \\<not> (\\<exists>d\\<le>k c.\n                              u' c = real d))) \\<Longrightarrow>\n    trans' u u'", "ultimately"], ["proof (chain)\npicking this:\n  zero c ([u]\\<^sub>\\<R>)\n  \\<not> zero c ([u']\\<^sub>\\<R>)", "have \"[u \\<oplus> t]\\<^sub>\\<R> \\<noteq> [u]\\<^sub>\\<R>\""], ["proof (prove)\nusing this:\n  zero c ([u]\\<^sub>\\<R>)\n  \\<not> zero c ([u']\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. [u \\<oplus> t]\\<^sub>\\<R> \\<noteq> [u]\\<^sub>\\<R>", "using prems"], ["proof (prove)\nusing this:\n  zero c ([u]\\<^sub>\\<R>)\n  \\<not> zero c ([u']\\<^sub>\\<R>)\n  cfg' \\<in> cont (repcs (l, u) cfg) ` set_pmf (action (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  action (repcs (l, u) cfg) \\<in> K (l, u)\n  action (repcs (l, u) cfg) = return_pmf (l, u \\<oplus> t)\n  (l, u) \\<in> S\n  (l, u) = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l\n\ngoal (1 subgoal):\n 1. [u \\<oplus> t]\\<^sub>\\<R> \\<noteq> [u]\\<^sub>\\<R>", "by auto"], ["proof (state)\nthis:\n  [u \\<oplus> t]\\<^sub>\\<R> \\<noteq> [u]\\<^sub>\\<R>\n\ngoal (2 subgoals):\n 1. \\<exists>c\\<in>\\<X>.\n       u c = 0 \\<and>\n       0 < u' c \\<and>\n       (\\<forall>c\\<in>\\<X>.\n           \\<not> (\\<exists>d\\<le>k c. u' c = real d)) \\<Longrightarrow>\n    trans' u u'\n 2. \\<not> (\\<exists>c\\<in>\\<X>.\n               u c = 0 \\<and>\n               0 < u' c \\<and>\n               (\\<forall>c\\<in>\\<X>.\n                   \\<not> (\\<exists>d\\<le>k c.\n                              u' c = real d))) \\<Longrightarrow>\n    trans' u u'", "moreover"], ["proof (state)\nthis:\n  [u \\<oplus> t]\\<^sub>\\<R> \\<noteq> [u]\\<^sub>\\<R>\n\ngoal (2 subgoals):\n 1. \\<exists>c\\<in>\\<X>.\n       u c = 0 \\<and>\n       0 < u' c \\<and>\n       (\\<forall>c\\<in>\\<X>.\n           \\<not> (\\<exists>d\\<le>k c. u' c = real d)) \\<Longrightarrow>\n    trans' u u'\n 2. \\<not> (\\<exists>c\\<in>\\<X>.\n               u c = 0 \\<and>\n               0 < u' c \\<and>\n               (\\<forall>c\\<in>\\<X>.\n                   \\<not> (\\<exists>d\\<le>k c.\n                              u' c = real d))) \\<Longrightarrow>\n    trans' u u'", "from True not_const_intv prems"], ["proof (chain)\npicking this:\n  \\<exists>c\\<in>\\<X>.\n     u c = 0 \\<and>\n     0 < u' c \\<and>\n     (\\<forall>c\\<in>\\<X>. \\<not> (\\<exists>d\\<le>k c. u' c = real d))\n  \\<lbrakk>?u \\<in> V;\n   \\<forall>c\\<in>\\<X>. \\<not> (\\<exists>d\\<le>k c. ?u c = real d)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>c\\<in>\\<X>.\n                       \\<forall>u\\<in>[?u]\\<^sub>\\<R>.\n                          \\<not> (\\<exists>d\\<le>k c. u c = real d)\n  cfg' \\<in> cont (repcs (l, u) cfg) ` set_pmf (action (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  action (repcs (l, u) cfg) \\<in> K (l, u)\n  action (repcs (l, u) cfg) = return_pmf (l, u \\<oplus> t)\n  (l, u) \\<in> S\n  (l, u) = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l", "have\n        \"\\<forall> u \\<in> [u \\<oplus> t]\\<^sub>\\<R>. \\<forall>c\\<in>\\<X>. \\<nexists>d. d \\<le> k c \\<and> u c = real d\""], ["proof (prove)\nusing this:\n  \\<exists>c\\<in>\\<X>.\n     u c = 0 \\<and>\n     0 < u' c \\<and>\n     (\\<forall>c\\<in>\\<X>. \\<not> (\\<exists>d\\<le>k c. u' c = real d))\n  \\<lbrakk>?u \\<in> V;\n   \\<forall>c\\<in>\\<X>. \\<not> (\\<exists>d\\<le>k c. ?u c = real d)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>c\\<in>\\<X>.\n                       \\<forall>u\\<in>[?u]\\<^sub>\\<R>.\n                          \\<not> (\\<exists>d\\<le>k c. u c = real d)\n  cfg' \\<in> cont (repcs (l, u) cfg) ` set_pmf (action (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  action (repcs (l, u) cfg) \\<in> K (l, u)\n  action (repcs (l, u) cfg) = return_pmf (l, u \\<oplus> t)\n  (l, u) \\<in> S\n  (l, u) = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>[u \\<oplus> t]\\<^sub>\\<R>.\n       \\<forall>c\\<in>\\<X>. \\<not> (\\<exists>d\\<le>k c. u c = real d)", "by auto"], ["proof (state)\nthis:\n  \\<forall>u\\<in>[u \\<oplus> t]\\<^sub>\\<R>.\n     \\<forall>c\\<in>\\<X>. \\<not> (\\<exists>d\\<le>k c. u c = real d)\n\ngoal (2 subgoals):\n 1. \\<exists>c\\<in>\\<X>.\n       u c = 0 \\<and>\n       0 < u' c \\<and>\n       (\\<forall>c\\<in>\\<X>.\n           \\<not> (\\<exists>d\\<le>k c. u' c = real d)) \\<Longrightarrow>\n    trans' u u'\n 2. \\<not> (\\<exists>c\\<in>\\<X>.\n               u c = 0 \\<and>\n               0 < u' c \\<and>\n               (\\<forall>c\\<in>\\<X>.\n                   \\<not> (\\<exists>d\\<le>k c.\n                              u' c = real d))) \\<Longrightarrow>\n    trans' u u'", "ultimately"], ["proof (chain)\npicking this:\n  [u \\<oplus> t]\\<^sub>\\<R> \\<noteq> [u]\\<^sub>\\<R>\n  \\<forall>u\\<in>[u \\<oplus> t]\\<^sub>\\<R>.\n     \\<forall>c\\<in>\\<X>. \\<not> (\\<exists>d\\<le>k c. u c = real d)", "have \"\\<exists>R'. (l, u) \\<in> S \\<and>\n                     action cfg = return_pmf (l, R') \\<and>\n                     R' \\<in> Succ \\<R> ([u]\\<^sub>\\<R>) \\<and> [u]\\<^sub>\\<R> \\<noteq> R' \\<and> (\\<forall>u\\<in>R'. \\<forall>c\\<in>\\<X>. \\<nexists>d. d \\<le> k c \\<and> u c = real d)\""], ["proof (prove)\nusing this:\n  [u \\<oplus> t]\\<^sub>\\<R> \\<noteq> [u]\\<^sub>\\<R>\n  \\<forall>u\\<in>[u \\<oplus> t]\\<^sub>\\<R>.\n     \\<forall>c\\<in>\\<X>. \\<not> (\\<exists>d\\<le>k c. u c = real d)\n\ngoal (1 subgoal):\n 1. \\<exists>R'.\n       (l, u) \\<in> S \\<and>\n       action cfg = return_pmf (l, R') \\<and>\n       R' \\<in> Succ \\<R> ([u]\\<^sub>\\<R>) \\<and>\n       [u]\\<^sub>\\<R> \\<noteq> R' \\<and>\n       (\\<forall>u\\<in>R'.\n           \\<forall>c\\<in>\\<X>. \\<not> (\\<exists>d\\<le>k c. u c = real d))", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>[u \\<oplus> t]\\<^sub>\\<R> \\<noteq> [u]\\<^sub>\\<R>;\n     \\<forall>u\\<in>[u \\<oplus> t]\\<^sub>\\<R>.\n        \\<forall>c\\<in>\\<X>.\n           \\<not> (\\<exists>d\\<le>k c. u c = real d)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>R'.\n                         (l, u) \\<in> S \\<and>\n                         action cfg = return_pmf (l, R') \\<and>\n                         R' \\<in> Succ \\<R> ([u]\\<^sub>\\<R>) \\<and>\n                         [u]\\<^sub>\\<R> \\<noteq> R' \\<and>\n                         (\\<forall>u\\<in>R'.\n                             \\<forall>c\\<in>\\<X>.\n                                \\<not> (\\<exists>d\\<le>k c. u c = real d))", "apply (rule exI[where x = \"[u \\<oplus> t]\\<^sub>\\<R>\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>[u \\<oplus> t]\\<^sub>\\<R> \\<noteq> [u]\\<^sub>\\<R>;\n     \\<forall>u\\<in>[u \\<oplus> t]\\<^sub>\\<R>.\n        \\<forall>c\\<in>\\<X>.\n           \\<not> (\\<exists>d\\<le>k c. u c = real d)\\<rbrakk>\n    \\<Longrightarrow> (l, u) \\<in> S \\<and>\n                      action cfg =\n                      return_pmf (l, [u \\<oplus> t]\\<^sub>\\<R>) \\<and>\n                      [u \\<oplus> t]\\<^sub>\\<R>\n                      \\<in> Succ \\<R> ([u]\\<^sub>\\<R>) \\<and>\n                      [u]\\<^sub>\\<R> \\<noteq>\n                      [u \\<oplus> t]\\<^sub>\\<R> \\<and>\n                      (\\<forall>u\\<in>[u \\<oplus> t]\\<^sub>\\<R>.\n                          \\<forall>c\\<in>\\<X>.\n                             \\<not> (\\<exists>d\\<le>k c. u c = real d))", "apply safe"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>u\\<in>[u \\<oplus> t]\\<^sub>\\<R>.\n                   \\<forall>c\\<in>\\<X>.\n                      \\<not> (\\<exists>d\\<le>k c. u c = real d);\n        x \\<in> [u \\<oplus> t]\\<^sub>\\<R>;\n        x \\<notin> [u]\\<^sub>\\<R>\\<rbrakk>\n       \\<Longrightarrow> (l, u) \\<in> S\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>u\\<in>[u \\<oplus> t]\\<^sub>\\<R>.\n                   \\<forall>c\\<in>\\<X>.\n                      \\<not> (\\<exists>d\\<le>k c. u c = real d);\n        x \\<in> [u \\<oplus> t]\\<^sub>\\<R>;\n        x \\<notin> [u]\\<^sub>\\<R>\\<rbrakk>\n       \\<Longrightarrow> action cfg =\n                         return_pmf (l, [u \\<oplus> t]\\<^sub>\\<R>)\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>u\\<in>[u \\<oplus> t]\\<^sub>\\<R>.\n                   \\<forall>c\\<in>\\<X>.\n                      \\<not> (\\<exists>d\\<le>k c. u c = real d);\n        x \\<in> [u \\<oplus> t]\\<^sub>\\<R>;\n        x \\<notin> [u]\\<^sub>\\<R>\\<rbrakk>\n       \\<Longrightarrow> [u \\<oplus> t]\\<^sub>\\<R>\n                         \\<in> Succ \\<R> ([u]\\<^sub>\\<R>)\n 4. \\<And>x.\n       \\<lbrakk>\\<forall>u\\<in>[u \\<oplus> t]\\<^sub>\\<R>.\n                   \\<forall>c\\<in>\\<X>.\n                      \\<not> (\\<exists>d\\<le>k c. u c = real d);\n        x \\<in> [u \\<oplus> t]\\<^sub>\\<R>; x \\<notin> [u]\\<^sub>\\<R>;\n        [u]\\<^sub>\\<R> = [u \\<oplus> t]\\<^sub>\\<R>\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>x.\n       \\<lbrakk>\\<forall>u\\<in>[u \\<oplus> t]\\<^sub>\\<R>.\n                   \\<forall>c\\<in>\\<X>.\n                      \\<not> (\\<exists>d\\<le>k c. u c = real d);\n        x \\<in> [u]\\<^sub>\\<R>;\n        x \\<notin> [u \\<oplus> t]\\<^sub>\\<R>\\<rbrakk>\n       \\<Longrightarrow> (l, u) \\<in> S\n 6. \\<And>x.\n       \\<lbrakk>\\<forall>u\\<in>[u \\<oplus> t]\\<^sub>\\<R>.\n                   \\<forall>c\\<in>\\<X>.\n                      \\<not> (\\<exists>d\\<le>k c. u c = real d);\n        x \\<in> [u]\\<^sub>\\<R>;\n        x \\<notin> [u \\<oplus> t]\\<^sub>\\<R>\\<rbrakk>\n       \\<Longrightarrow> action cfg =\n                         return_pmf (l, [u \\<oplus> t]\\<^sub>\\<R>)\n 7. \\<And>x.\n       \\<lbrakk>\\<forall>u\\<in>[u \\<oplus> t]\\<^sub>\\<R>.\n                   \\<forall>c\\<in>\\<X>.\n                      \\<not> (\\<exists>d\\<le>k c. u c = real d);\n        x \\<in> [u]\\<^sub>\\<R>;\n        x \\<notin> [u \\<oplus> t]\\<^sub>\\<R>\\<rbrakk>\n       \\<Longrightarrow> [u \\<oplus> t]\\<^sub>\\<R>\n                         \\<in> Succ \\<R> ([u]\\<^sub>\\<R>)\n 8. \\<And>x.\n       \\<lbrakk>\\<forall>u\\<in>[u \\<oplus> t]\\<^sub>\\<R>.\n                   \\<forall>c\\<in>\\<X>.\n                      \\<not> (\\<exists>d\\<le>k c. u c = real d);\n        x \\<in> [u]\\<^sub>\\<R>; x \\<notin> [u \\<oplus> t]\\<^sub>\\<R>;\n        [u]\\<^sub>\\<R> = [u \\<oplus> t]\\<^sub>\\<R>\\<rbrakk>\n       \\<Longrightarrow> False", "using prems **"], ["proof (prove)\nusing this:\n  cfg' \\<in> cont (repcs (l, u) cfg) ` set_pmf (action (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  action (repcs (l, u) cfg) \\<in> K (l, u)\n  action (repcs (l, u) cfg) = return_pmf (l, u \\<oplus> t)\n  (l, u) \\<in> S\n  (l, u) = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l\n  action cfg = return_pmf (l, [u \\<oplus> t]\\<^sub>\\<R>)\n\ngoal (8 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>u\\<in>[u \\<oplus> t]\\<^sub>\\<R>.\n                   \\<forall>c\\<in>\\<X>.\n                      \\<not> (\\<exists>d\\<le>k c. u c = real d);\n        x \\<in> [u \\<oplus> t]\\<^sub>\\<R>;\n        x \\<notin> [u]\\<^sub>\\<R>\\<rbrakk>\n       \\<Longrightarrow> (l, u) \\<in> S\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>u\\<in>[u \\<oplus> t]\\<^sub>\\<R>.\n                   \\<forall>c\\<in>\\<X>.\n                      \\<not> (\\<exists>d\\<le>k c. u c = real d);\n        x \\<in> [u \\<oplus> t]\\<^sub>\\<R>;\n        x \\<notin> [u]\\<^sub>\\<R>\\<rbrakk>\n       \\<Longrightarrow> action cfg =\n                         return_pmf (l, [u \\<oplus> t]\\<^sub>\\<R>)\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>u\\<in>[u \\<oplus> t]\\<^sub>\\<R>.\n                   \\<forall>c\\<in>\\<X>.\n                      \\<not> (\\<exists>d\\<le>k c. u c = real d);\n        x \\<in> [u \\<oplus> t]\\<^sub>\\<R>;\n        x \\<notin> [u]\\<^sub>\\<R>\\<rbrakk>\n       \\<Longrightarrow> [u \\<oplus> t]\\<^sub>\\<R>\n                         \\<in> Succ \\<R> ([u]\\<^sub>\\<R>)\n 4. \\<And>x.\n       \\<lbrakk>\\<forall>u\\<in>[u \\<oplus> t]\\<^sub>\\<R>.\n                   \\<forall>c\\<in>\\<X>.\n                      \\<not> (\\<exists>d\\<le>k c. u c = real d);\n        x \\<in> [u \\<oplus> t]\\<^sub>\\<R>; x \\<notin> [u]\\<^sub>\\<R>;\n        [u]\\<^sub>\\<R> = [u \\<oplus> t]\\<^sub>\\<R>\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>x.\n       \\<lbrakk>\\<forall>u\\<in>[u \\<oplus> t]\\<^sub>\\<R>.\n                   \\<forall>c\\<in>\\<X>.\n                      \\<not> (\\<exists>d\\<le>k c. u c = real d);\n        x \\<in> [u]\\<^sub>\\<R>;\n        x \\<notin> [u \\<oplus> t]\\<^sub>\\<R>\\<rbrakk>\n       \\<Longrightarrow> (l, u) \\<in> S\n 6. \\<And>x.\n       \\<lbrakk>\\<forall>u\\<in>[u \\<oplus> t]\\<^sub>\\<R>.\n                   \\<forall>c\\<in>\\<X>.\n                      \\<not> (\\<exists>d\\<le>k c. u c = real d);\n        x \\<in> [u]\\<^sub>\\<R>;\n        x \\<notin> [u \\<oplus> t]\\<^sub>\\<R>\\<rbrakk>\n       \\<Longrightarrow> action cfg =\n                         return_pmf (l, [u \\<oplus> t]\\<^sub>\\<R>)\n 7. \\<And>x.\n       \\<lbrakk>\\<forall>u\\<in>[u \\<oplus> t]\\<^sub>\\<R>.\n                   \\<forall>c\\<in>\\<X>.\n                      \\<not> (\\<exists>d\\<le>k c. u c = real d);\n        x \\<in> [u]\\<^sub>\\<R>;\n        x \\<notin> [u \\<oplus> t]\\<^sub>\\<R>\\<rbrakk>\n       \\<Longrightarrow> [u \\<oplus> t]\\<^sub>\\<R>\n                         \\<in> Succ \\<R> ([u]\\<^sub>\\<R>)\n 8. \\<And>x.\n       \\<lbrakk>\\<forall>u\\<in>[u \\<oplus> t]\\<^sub>\\<R>.\n                   \\<forall>c\\<in>\\<X>.\n                      \\<not> (\\<exists>d\\<le>k c. u c = real d);\n        x \\<in> [u]\\<^sub>\\<R>; x \\<notin> [u \\<oplus> t]\\<^sub>\\<R>;\n        [u]\\<^sub>\\<R> = [u \\<oplus> t]\\<^sub>\\<R>\\<rbrakk>\n       \\<Longrightarrow> False", "by auto"], ["proof (state)\nthis:\n  \\<exists>R'.\n     (l, u) \\<in> S \\<and>\n     action cfg = return_pmf (l, R') \\<and>\n     R' \\<in> Succ \\<R> ([u]\\<^sub>\\<R>) \\<and>\n     [u]\\<^sub>\\<R> \\<noteq> R' \\<and>\n     (\\<forall>u\\<in>R'.\n         \\<forall>c\\<in>\\<X>. \\<not> (\\<exists>d\\<le>k c. u c = real d))\n\ngoal (2 subgoals):\n 1. \\<exists>c\\<in>\\<X>.\n       u c = 0 \\<and>\n       0 < u' c \\<and>\n       (\\<forall>c\\<in>\\<X>.\n           \\<not> (\\<exists>d\\<le>k c. u' c = real d)) \\<Longrightarrow>\n    trans' u u'\n 2. \\<not> (\\<exists>c\\<in>\\<X>.\n               u c = 0 \\<and>\n               0 < u' c \\<and>\n               (\\<forall>c\\<in>\\<X>.\n                   \\<not> (\\<exists>d\\<le>k c.\n                              u' c = real d))) \\<Longrightarrow>\n    trans' u u'", "then"], ["proof (chain)\npicking this:\n  \\<exists>R'.\n     (l, u) \\<in> S \\<and>\n     action cfg = return_pmf (l, R') \\<and>\n     R' \\<in> Succ \\<R> ([u]\\<^sub>\\<R>) \\<and>\n     [u]\\<^sub>\\<R> \\<noteq> R' \\<and>\n     (\\<forall>u\\<in>R'.\n         \\<forall>c\\<in>\\<X>. \\<not> (\\<exists>d\\<le>k c. u c = real d))", "have\n        \"rept (l, u) (action cfg)\n       = return_pmf (l, delayedR (SOME R'. action cfg = return_pmf (l, R')) u)\""], ["proof (prove)\nusing this:\n  \\<exists>R'.\n     (l, u) \\<in> S \\<and>\n     action cfg = return_pmf (l, R') \\<and>\n     R' \\<in> Succ \\<R> ([u]\\<^sub>\\<R>) \\<and>\n     [u]\\<^sub>\\<R> \\<noteq> R' \\<and>\n     (\\<forall>u\\<in>R'.\n         \\<forall>c\\<in>\\<X>. \\<not> (\\<exists>d\\<le>k c. u c = real d))\n\ngoal (1 subgoal):\n 1. rept (l, u) (action cfg) =\n    return_pmf (l, delayedR (SOME R'. action cfg = return_pmf (l, R')) u)", "unfolding rept_def"], ["proof (prove)\nusing this:\n  \\<exists>R'.\n     (l, u) \\<in> S \\<and>\n     action cfg = return_pmf (l, R') \\<and>\n     R' \\<in> Succ \\<R> ([u]\\<^sub>\\<R>) \\<and>\n     [u]\\<^sub>\\<R> \\<noteq> R' \\<and>\n     (\\<forall>u\\<in>R'.\n         \\<forall>c\\<in>\\<X>. \\<not> (\\<exists>d\\<le>k c. u c = real d))\n\ngoal (1 subgoal):\n 1. (let (l, u) = (l, u)\n     in if \\<exists>R'.\n              (l, u) \\<in> S \\<and>\n              action cfg = return_pmf (l, R') \\<and>\n              [u]\\<^sub>\\<R> = R' \\<and>\n              (\\<forall>c\\<in>\\<X>. real (k c) < u c)\n        then return_pmf (l, u \\<oplus> 5 / 10)\n        else if \\<exists>R'.\n                   (l, u) \\<in> S \\<and>\n                   action cfg = return_pmf (l, R') \\<and>\n                   R' \\<in> Succ \\<R> ([u]\\<^sub>\\<R>) \\<and>\n                   [u]\\<^sub>\\<R> \\<noteq> R' \\<and>\n                   (\\<forall>u\\<in>R'.\n                       \\<forall>c\\<in>\\<X>.\n                          \\<not> (\\<exists>d\\<le>k c. u c = real d))\n             then return_pmf\n                   (l, delayedR (SOME R'. action cfg = return_pmf (l, R'))\n                        u)\n             else SOME \\<mu>.\n                     \\<mu> \\<in> K (l, u) \\<and> abst \\<mu> = action cfg) =\n    return_pmf (l, delayedR (SOME R'. action cfg = return_pmf (l, R')) u)", "by auto"], ["proof (state)\nthis:\n  rept (l, u) (action cfg) =\n  return_pmf (l, delayedR (SOME R'. action cfg = return_pmf (l, R')) u)\n\ngoal (2 subgoals):\n 1. \\<exists>c\\<in>\\<X>.\n       u c = 0 \\<and>\n       0 < u' c \\<and>\n       (\\<forall>c\\<in>\\<X>.\n           \\<not> (\\<exists>d\\<le>k c. u' c = real d)) \\<Longrightarrow>\n    trans' u u'\n 2. \\<not> (\\<exists>c\\<in>\\<X>.\n               u c = 0 \\<and>\n               0 < u' c \\<and>\n               (\\<forall>c\\<in>\\<X>.\n                   \\<not> (\\<exists>d\\<le>k c.\n                              u' c = real d))) \\<Longrightarrow>\n    trans' u u'", "with * ** prems"], ["proof (chain)\npicking this:\n  rept (l, u) (action cfg) = return_pmf (l, u \\<oplus> t)\n  action cfg = return_pmf (l, [u \\<oplus> t]\\<^sub>\\<R>)\n  cfg' \\<in> cont (repcs (l, u) cfg) ` set_pmf (action (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  action (repcs (l, u) cfg) \\<in> K (l, u)\n  action (repcs (l, u) cfg) = return_pmf (l, u \\<oplus> t)\n  (l, u) \\<in> S\n  (l, u) = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l\n  rept (l, u) (action cfg) =\n  return_pmf (l, delayedR (SOME R'. action cfg = return_pmf (l, R')) u)", "have \"u' = delayedR ([u \\<oplus> t]\\<^sub>\\<R>) u\""], ["proof (prove)\nusing this:\n  rept (l, u) (action cfg) = return_pmf (l, u \\<oplus> t)\n  action cfg = return_pmf (l, [u \\<oplus> t]\\<^sub>\\<R>)\n  cfg' \\<in> cont (repcs (l, u) cfg) ` set_pmf (action (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  action (repcs (l, u) cfg) \\<in> K (l, u)\n  action (repcs (l, u) cfg) = return_pmf (l, u \\<oplus> t)\n  (l, u) \\<in> S\n  (l, u) = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l\n  rept (l, u) (action cfg) =\n  return_pmf (l, delayedR (SOME R'. action cfg = return_pmf (l, R')) u)\n\ngoal (1 subgoal):\n 1. u' = delayedR ([u \\<oplus> t]\\<^sub>\\<R>) u", "by auto"], ["proof (state)\nthis:\n  u' = delayedR ([u \\<oplus> t]\\<^sub>\\<R>) u\n\ngoal (2 subgoals):\n 1. \\<exists>c\\<in>\\<X>.\n       u c = 0 \\<and>\n       0 < u' c \\<and>\n       (\\<forall>c\\<in>\\<X>.\n           \\<not> (\\<exists>d\\<le>k c. u' c = real d)) \\<Longrightarrow>\n    trans' u u'\n 2. \\<not> (\\<exists>c\\<in>\\<X>.\n               u c = 0 \\<and>\n               0 < u' c \\<and>\n               (\\<forall>c\\<in>\\<X>.\n                   \\<not> (\\<exists>d\\<le>k c.\n                              u' c = real d))) \\<Longrightarrow>\n    trans' u u'", "with F True prems"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c)\n  \\<exists>c\\<in>\\<X>.\n     u c = 0 \\<and>\n     0 < u' c \\<and>\n     (\\<forall>c\\<in>\\<X>. \\<not> (\\<exists>d\\<le>k c. u' c = real d))\n  cfg' \\<in> cont (repcs (l, u) cfg) ` set_pmf (action (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  action (repcs (l, u) cfg) \\<in> K (l, u)\n  action (repcs (l, u) cfg) = return_pmf (l, u \\<oplus> t)\n  (l, u) \\<in> S\n  (l, u) = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l\n  u' = delayedR ([u \\<oplus> t]\\<^sub>\\<R>) u", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c)\n  \\<exists>c\\<in>\\<X>.\n     u c = 0 \\<and>\n     0 < u' c \\<and>\n     (\\<forall>c\\<in>\\<X>. \\<not> (\\<exists>d\\<le>k c. u' c = real d))\n  cfg' \\<in> cont (repcs (l, u) cfg) ` set_pmf (action (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  action (repcs (l, u) cfg) \\<in> K (l, u)\n  action (repcs (l, u) cfg) = return_pmf (l, u \\<oplus> t)\n  (l, u) \\<in> S\n  (l, u) = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l\n  u' = delayedR ([u \\<oplus> t]\\<^sub>\\<R>) u\n\ngoal (1 subgoal):\n 1. trans' u u'", "unfolding trans'_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c)\n  \\<exists>c\\<in>\\<X>.\n     u c = 0 \\<and>\n     0 < u' c \\<and>\n     (\\<forall>c\\<in>\\<X>. \\<not> (\\<exists>d\\<le>k c. u' c = real d))\n  cfg' \\<in> cont (repcs (l, u) cfg) ` set_pmf (action (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  action (repcs (l, u) cfg) \\<in> K (l, u)\n  action (repcs (l, u) cfg) = return_pmf (l, u \\<oplus> t)\n  (l, u) \\<in> S\n  (l, u) = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l\n  u' = delayedR ([u \\<oplus> t]\\<^sub>\\<R>) u\n\ngoal (1 subgoal):\n 1. ((\\<forall>c\\<in>\\<X>.\n         real (k c) < u c \\<and>\n         real (k c) < u' c \\<and> u \\<noteq> u') \\<longrightarrow>\n     u' = u \\<oplus> 5 / 10) \\<and>\n    ((\\<exists>c\\<in>\\<X>.\n         u c = 0 \\<and>\n         0 < u' c \\<and>\n         (\\<forall>c\\<in>\\<X>.\n             \\<not> (\\<exists>d\\<le>k c. u' c = real d))) \\<longrightarrow>\n     u' = delayedR ([u']\\<^sub>\\<R>) u)", "by auto"], ["proof (state)\nthis:\n  trans' u u'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>c\\<in>\\<X>.\n               u c = 0 \\<and>\n               0 < u' c \\<and>\n               (\\<forall>c\\<in>\\<X>.\n                   \\<not> (\\<exists>d\\<le>k c.\n                              u' c = real d))) \\<Longrightarrow>\n    trans' u u'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>c\\<in>\\<X>.\n               u c = 0 \\<and>\n               0 < u' c \\<and>\n               (\\<forall>c\\<in>\\<X>.\n                   \\<not> (\\<exists>d\\<le>k c.\n                              u' c = real d))) \\<Longrightarrow>\n    trans' u u'", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>c\\<in>\\<X>.\n             u c = 0 \\<and>\n             0 < u' c \\<and>\n             (\\<forall>c\\<in>\\<X>.\n                 \\<not> (\\<exists>d\\<le>k c. u' c = real d)))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>c\\<in>\\<X>.\n               u c = 0 \\<and>\n               0 < u' c \\<and>\n               (\\<forall>c\\<in>\\<X>.\n                   \\<not> (\\<exists>d\\<le>k c.\n                              u' c = real d))) \\<Longrightarrow>\n    trans' u u'", "with F \\<open>_ = (l, u)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c)\n  (l, u) = (l, u)\n  \\<not> (\\<exists>c\\<in>\\<X>.\n             u c = 0 \\<and>\n             0 < u' c \\<and>\n             (\\<forall>c\\<in>\\<X>.\n                 \\<not> (\\<exists>d\\<le>k c. u' c = real d)))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c)\n  (l, u) = (l, u)\n  \\<not> (\\<exists>c\\<in>\\<X>.\n             u c = 0 \\<and>\n             0 < u' c \\<and>\n             (\\<forall>c\\<in>\\<X>.\n                 \\<not> (\\<exists>d\\<le>k c. u' c = real d)))\n\ngoal (1 subgoal):\n 1. trans' u u'", "unfolding trans'_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c)\n  (l, u) = (l, u)\n  \\<not> (\\<exists>c\\<in>\\<X>.\n             u c = 0 \\<and>\n             0 < u' c \\<and>\n             (\\<forall>c\\<in>\\<X>.\n                 \\<not> (\\<exists>d\\<le>k c. u' c = real d)))\n\ngoal (1 subgoal):\n 1. ((\\<forall>c\\<in>\\<X>.\n         real (k c) < u c \\<and>\n         real (k c) < u' c \\<and> u \\<noteq> u') \\<longrightarrow>\n     u' = u \\<oplus> 5 / 10) \\<and>\n    ((\\<exists>c\\<in>\\<X>.\n         u c = 0 \\<and>\n         0 < u' c \\<and>\n         (\\<forall>c\\<in>\\<X>.\n             \\<not> (\\<exists>d\\<le>k c. u' c = real d))) \\<longrightarrow>\n     u' = delayedR ([u']\\<^sub>\\<R>) u)", "by auto"], ["proof (state)\nthis:\n  trans' u u'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trans' u u'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trans' u u'\n\ngoal (2 subgoals):\n 1. \\<And>la ua g \\<mu>.\n       \\<lbrakk>cfg'\n                \\<in> cont (repcs (l, u) cfg) `\n                      set_pmf (action (repcs (l, u) cfg));\n        state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n        abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n        action (repcs (l, u) cfg) =\n        map_pmf\n         (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]ua))\n         \\<mu>;\n        (l, u) \\<in> S; (l, u) = (la, ua);\n        (la, g, \\<mu>) \\<in> PTA.trans_of A; ua \\<turnstile> g\\<rbrakk>\n       \\<Longrightarrow> trans' u u'\n 2. \\<lbrakk>cfg'\n             \\<in> cont (repcs (l, u) cfg) `\n                   set_pmf (action (repcs (l, u) cfg));\n     state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n     abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n     action (repcs (l, u) cfg) = return_pmf (l, u)\\<rbrakk>\n    \\<Longrightarrow> trans' u u'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>la ua g \\<mu>.\n       \\<lbrakk>cfg'\n                \\<in> cont (repcs (l, u) cfg) `\n                      set_pmf (action (repcs (l, u) cfg));\n        state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n        abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n        action (repcs (l, u) cfg) =\n        map_pmf\n         (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]ua))\n         \\<mu>;\n        (l, u) \\<in> S; (l, u) = (la, ua);\n        (la, g, \\<mu>) \\<in> PTA.trans_of A; ua \\<turnstile> g\\<rbrakk>\n       \\<Longrightarrow> trans' u u'\n 2. \\<lbrakk>cfg'\n             \\<in> cont (repcs (l, u) cfg) `\n                   set_pmf (action (repcs (l, u) cfg));\n     state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n     abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n     action (repcs (l, u) cfg) = return_pmf (l, u)\\<rbrakk>\n    \\<Longrightarrow> trans' u u'", "case prems: (2 _ _ \\<tau> \\<mu>)"], ["proof (state)\nthis:\n  cfg' \\<in> cont (repcs (l, u) cfg) ` set_pmf (action (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  action (repcs (l, u) cfg) \\<in> K (l, u)\n  action (repcs (l, u) cfg) =\n  map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u_))\n   \\<mu>\n  (l, u) \\<in> S\n  (l, u) = (l_, u_)\n  (l_, \\<tau>, \\<mu>) \\<in> PTA.trans_of A\n  u_ \\<turnstile> \\<tau>\n\ngoal (2 subgoals):\n 1. \\<And>la ua g \\<mu>.\n       \\<lbrakk>cfg'\n                \\<in> cont (repcs (l, u) cfg) `\n                      set_pmf (action (repcs (l, u) cfg));\n        state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n        abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n        action (repcs (l, u) cfg) =\n        map_pmf\n         (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]ua))\n         \\<mu>;\n        (l, u) \\<in> S; (l, u) = (la, ua);\n        (la, g, \\<mu>) \\<in> PTA.trans_of A; ua \\<turnstile> g\\<rbrakk>\n       \\<Longrightarrow> trans' u u'\n 2. \\<lbrakk>cfg'\n             \\<in> cont (repcs (l, u) cfg) `\n                   set_pmf (action (repcs (l, u) cfg));\n     state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n     abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n     action (repcs (l, u) cfg) = return_pmf (l, u)\\<rbrakk>\n    \\<Longrightarrow> trans' u u'", "then"], ["proof (chain)\npicking this:\n  cfg' \\<in> cont (repcs (l, u) cfg) ` set_pmf (action (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  action (repcs (l, u) cfg) \\<in> K (l, u)\n  action (repcs (l, u) cfg) =\n  map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u_))\n   \\<mu>\n  (l, u) \\<in> S\n  (l, u) = (l_, u_)\n  (l_, \\<tau>, \\<mu>) \\<in> PTA.trans_of A\n  u_ \\<turnstile> \\<tau>", "obtain X where X: \"u' = ([X := 0]u)\" \"(X, l') \\<in> set_pmf \\<mu>\""], ["proof (prove)\nusing this:\n  cfg' \\<in> cont (repcs (l, u) cfg) ` set_pmf (action (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  action (repcs (l, u) cfg) \\<in> K (l, u)\n  action (repcs (l, u) cfg) =\n  map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u_))\n   \\<mu>\n  (l, u) \\<in> S\n  (l, u) = (l_, u_)\n  (l_, \\<tau>, \\<mu>) \\<in> PTA.trans_of A\n  u_ \\<turnstile> \\<tau>\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>u' = [(SOME r. set r = X)\\<rightarrow>0]u;\n         (X, l') \\<in> set_pmf \\<mu>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  u' = [(SOME r. set r = X)\\<rightarrow>0]u\n  (X, l') \\<in> set_pmf \\<mu>\n\ngoal (2 subgoals):\n 1. \\<And>la ua g \\<mu>.\n       \\<lbrakk>cfg'\n                \\<in> cont (repcs (l, u) cfg) `\n                      set_pmf (action (repcs (l, u) cfg));\n        state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n        abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n        action (repcs (l, u) cfg) =\n        map_pmf\n         (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]ua))\n         \\<mu>;\n        (l, u) \\<in> S; (l, u) = (la, ua);\n        (la, g, \\<mu>) \\<in> PTA.trans_of A; ua \\<turnstile> g\\<rbrakk>\n       \\<Longrightarrow> trans' u u'\n 2. \\<lbrakk>cfg'\n             \\<in> cont (repcs (l, u) cfg) `\n                   set_pmf (action (repcs (l, u) cfg));\n     state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n     abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n     action (repcs (l, u) cfg) = return_pmf (l, u)\\<rbrakk>\n    \\<Longrightarrow> trans' u u'", "from \\<open>_ \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  (l, u) \\<in> S", "have \"u \\<in> V\""], ["proof (prove)\nusing this:\n  (l, u) \\<in> S\n\ngoal (1 subgoal):\n 1. u \\<in> V", "by auto"], ["proof (state)\nthis:\n  u \\<in> V\n\ngoal (2 subgoals):\n 1. \\<And>la ua g \\<mu>.\n       \\<lbrakk>cfg'\n                \\<in> cont (repcs (l, u) cfg) `\n                      set_pmf (action (repcs (l, u) cfg));\n        state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n        abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n        action (repcs (l, u) cfg) =\n        map_pmf\n         (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]ua))\n         \\<mu>;\n        (l, u) \\<in> S; (l, u) = (la, ua);\n        (la, g, \\<mu>) \\<in> PTA.trans_of A; ua \\<turnstile> g\\<rbrakk>\n       \\<Longrightarrow> trans' u u'\n 2. \\<lbrakk>cfg'\n             \\<in> cont (repcs (l, u) cfg) `\n                   set_pmf (action (repcs (l, u) cfg));\n     state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n     abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n     action (repcs (l, u) cfg) = return_pmf (l, u)\\<rbrakk>\n    \\<Longrightarrow> trans' u u'", "let ?r = \"SOME r. set r = X\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>la ua g \\<mu>.\n       \\<lbrakk>cfg'\n                \\<in> cont (repcs (l, u) cfg) `\n                      set_pmf (action (repcs (l, u) cfg));\n        state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n        abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n        action (repcs (l, u) cfg) =\n        map_pmf\n         (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]ua))\n         \\<mu>;\n        (l, u) \\<in> S; (l, u) = (la, ua);\n        (la, g, \\<mu>) \\<in> PTA.trans_of A; ua \\<turnstile> g\\<rbrakk>\n       \\<Longrightarrow> trans' u u'\n 2. \\<lbrakk>cfg'\n             \\<in> cont (repcs (l, u) cfg) `\n                   set_pmf (action (repcs (l, u) cfg));\n     state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n     abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n     action (repcs (l, u) cfg) = return_pmf (l, u)\\<rbrakk>\n    \\<Longrightarrow> trans' u u'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. trans' u u'", "proof (cases \"X = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. X = {} \\<Longrightarrow> trans' u u'\n 2. X \\<noteq> {} \\<Longrightarrow> trans' u u'", "case True"], ["proof (state)\nthis:\n  X = {}\n\ngoal (2 subgoals):\n 1. X = {} \\<Longrightarrow> trans' u u'\n 2. X \\<noteq> {} \\<Longrightarrow> trans' u u'", "with X"], ["proof (chain)\npicking this:\n  u' = [(SOME r. set r = X)\\<rightarrow>0]u\n  (X, l') \\<in> set_pmf \\<mu>\n  X = {}", "have \"u = u'\""], ["proof (prove)\nusing this:\n  u' = [(SOME r. set r = X)\\<rightarrow>0]u\n  (X, l') \\<in> set_pmf \\<mu>\n  X = {}\n\ngoal (1 subgoal):\n 1. u = u'", "by auto"], ["proof (state)\nthis:\n  u = u'\n\ngoal (2 subgoals):\n 1. X = {} \\<Longrightarrow> trans' u u'\n 2. X \\<noteq> {} \\<Longrightarrow> trans' u u'", "with non_empty"], ["proof (chain)\npicking this:\n  \\<X> \\<noteq> {}\n  u = u'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<X> \\<noteq> {}\n  u = u'\n\ngoal (1 subgoal):\n 1. trans' u u'", "unfolding trans'_def"], ["proof (prove)\nusing this:\n  \\<X> \\<noteq> {}\n  u = u'\n\ngoal (1 subgoal):\n 1. ((\\<forall>c\\<in>\\<X>.\n         real (k c) < u c \\<and>\n         real (k c) < u' c \\<and> u \\<noteq> u') \\<longrightarrow>\n     u' = u \\<oplus> 5 / 10) \\<and>\n    ((\\<exists>c\\<in>\\<X>.\n         u c = 0 \\<and>\n         0 < u' c \\<and>\n         (\\<forall>c\\<in>\\<X>.\n             \\<not> (\\<exists>d\\<le>k c. u' c = real d))) \\<longrightarrow>\n     u' = delayedR ([u']\\<^sub>\\<R>) u)", "by auto"], ["proof (state)\nthis:\n  trans' u u'\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> trans' u u'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> trans' u u'", "case False"], ["proof (state)\nthis:\n  X \\<noteq> {}\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> trans' u u'", "then"], ["proof (chain)\npicking this:\n  X \\<noteq> {}", "obtain x where \"x \\<in> X\""], ["proof (prove)\nusing this:\n  X \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> X \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> trans' u u'", "moreover"], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> trans' u u'", "have \"X \\<subseteq> \\<X>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<subseteq> \\<X>", "using admissible_targets_clocks(1)[OF prems(10) X(2)]"], ["proof (prove)\nusing this:\n  X \\<subseteq> \\<X>\n\ngoal (1 subgoal):\n 1. X \\<subseteq> \\<X>", "by auto"], ["proof (state)\nthis:\n  X \\<subseteq> \\<X>\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> trans' u u'", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> X\n  X \\<subseteq> \\<X>", "have \"x \\<in> \\<X>\""], ["proof (prove)\nusing this:\n  x \\<in> X\n  X \\<subseteq> \\<X>\n\ngoal (1 subgoal):\n 1. x \\<in> \\<X>", "by auto"], ["proof (state)\nthis:\n  x \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> trans' u u'", "from \\<open>X \\<subseteq> \\<X>\\<close> finite(1)"], ["proof (chain)\npicking this:\n  X \\<subseteq> \\<X>\n  finite \\<X>", "obtain r where \"set r = X\""], ["proof (prove)\nusing this:\n  X \\<subseteq> \\<X>\n  finite \\<X>\n\ngoal (1 subgoal):\n 1. (\\<And>r. set r = X \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using finite_list finite_subset"], ["proof (prove)\nusing this:\n  X \\<subseteq> \\<X>\n  finite \\<X>\n  finite ?A \\<Longrightarrow> \\<exists>xs. set xs = ?A\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. (\\<And>r. set r = X \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  set r = X\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> trans' u u'", "then"], ["proof (chain)\npicking this:\n  set r = X", "have r: \"set ?r = X\""], ["proof (prove)\nusing this:\n  set r = X\n\ngoal (1 subgoal):\n 1. set (SOME r. set r = X) = X", "by (rule someI)"], ["proof (state)\nthis:\n  set (SOME r. set r = X) = X\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> trans' u u'", "with \\<open>x \\<in> X\\<close> X"], ["proof (chain)\npicking this:\n  x \\<in> X\n  u' = [(SOME r. set r = X)\\<rightarrow>0]u\n  (X, l') \\<in> set_pmf \\<mu>\n  set (SOME r. set r = X) = X", "have \"u' x = 0\""], ["proof (prove)\nusing this:\n  x \\<in> X\n  u' = [(SOME r. set r = X)\\<rightarrow>0]u\n  (X, l') \\<in> set_pmf \\<mu>\n  set (SOME r. set r = X) = X\n\ngoal (1 subgoal):\n 1. u' x = 0", "by auto"], ["proof (state)\nthis:\n  u' x = 0\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> trans' u u'", "from X r \\<open>u \\<in> V\\<close> \\<open>X \\<subseteq> \\<X>\\<close>"], ["proof (chain)\npicking this:\n  u' = [(SOME r. set r = X)\\<rightarrow>0]u\n  (X, l') \\<in> set_pmf \\<mu>\n  set (SOME r. set r = X) = X\n  u \\<in> V\n  X \\<subseteq> \\<X>", "have \"u' x \\<le> u x\" for x"], ["proof (prove)\nusing this:\n  u' = [(SOME r. set r = X)\\<rightarrow>0]u\n  (X, l') \\<in> set_pmf \\<mu>\n  set (SOME r. set r = X) = X\n  u \\<in> V\n  X \\<subseteq> \\<X>\n\ngoal (1 subgoal):\n 1. u' x \\<le> u x", "by (cases \"x \\<in> X\"; auto simp: V_def)"], ["proof (state)\nthis:\n  u' ?x8 \\<le> u ?x8\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> trans' u u'", "have False if \"u' x > 0 \\<and> u x = 0\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using \\<open>u' _ \\<le> _\\<close>[of x] that"], ["proof (prove)\nusing this:\n  u' x \\<le> u x\n  0 < u' x \\<and> u x = 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  0 < u' ?x8 \\<and> u ?x8 = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> trans' u u'", "with \\<open>u' x = 0\\<close>"], ["proof (chain)\npicking this:\n  u' x = 0\n  0 < u' ?x8 \\<and> u ?x8 = 0 \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  u' x = 0\n  0 < u' ?x8 \\<and> u ?x8 = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. trans' u u'", "using \\<open>x \\<in> \\<X>\\<close>"], ["proof (prove)\nusing this:\n  u' x = 0\n  0 < u' ?x8 \\<and> u ?x8 = 0 \\<Longrightarrow> False\n  x \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. trans' u u'", "unfolding trans'_def"], ["proof (prove)\nusing this:\n  u' x = 0\n  0 < u' ?x8 \\<and> u ?x8 = 0 \\<Longrightarrow> False\n  x \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. ((\\<forall>c\\<in>\\<X>.\n         real (k c) < u c \\<and>\n         real (k c) < u' c \\<and> u \\<noteq> u') \\<longrightarrow>\n     u' = u \\<oplus> 5 / 10) \\<and>\n    ((\\<exists>c\\<in>\\<X>.\n         u c = 0 \\<and>\n         0 < u' c \\<and>\n         (\\<forall>c\\<in>\\<X>.\n             \\<not> (\\<exists>d\\<le>k c. u' c = real d))) \\<longrightarrow>\n     u' = delayedR ([u']\\<^sub>\\<R>) u)", "by auto"], ["proof (state)\nthis:\n  trans' u u'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trans' u u'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cfg'\n             \\<in> cont (repcs (l, u) cfg) `\n                   set_pmf (action (repcs (l, u) cfg));\n     state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n     abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n     action (repcs (l, u) cfg) = return_pmf (l, u)\\<rbrakk>\n    \\<Longrightarrow> trans' u u'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>cfg'\n             \\<in> cont (repcs (l, u) cfg) `\n                   set_pmf (action (repcs (l, u) cfg));\n     state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n     abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n     action (repcs (l, u) cfg) = return_pmf (l, u)\\<rbrakk>\n    \\<Longrightarrow> trans' u u'", "case 3"], ["proof (state)\nthis:\n  cfg' \\<in> cont (repcs (l, u) cfg) ` set_pmf (action (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  action (repcs (l, u) cfg) \\<in> K (l, u)\n  action (repcs (l, u) cfg) = return_pmf (l, u)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cfg'\n             \\<in> cont (repcs (l, u) cfg) `\n                   set_pmf (action (repcs (l, u) cfg));\n     state cfg' = (l', u'); (l, u) \\<in> S; cfg \\<in> R_G.valid_cfg;\n     abss (l, u) = state cfg; action (repcs (l, u) cfg) \\<in> K (l, u);\n     action (repcs (l, u) cfg) = return_pmf (l, u)\\<rbrakk>\n    \\<Longrightarrow> trans' u u'", "with non_empty"], ["proof (chain)\npicking this:\n  \\<X> \\<noteq> {}\n  cfg' \\<in> cont (repcs (l, u) cfg) ` set_pmf (action (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  action (repcs (l, u) cfg) \\<in> K (l, u)\n  action (repcs (l, u) cfg) = return_pmf (l, u)", "show ?case"], ["proof (prove)\nusing this:\n  \\<X> \\<noteq> {}\n  cfg' \\<in> cont (repcs (l, u) cfg) ` set_pmf (action (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  action (repcs (l, u) cfg) \\<in> K (l, u)\n  action (repcs (l, u) cfg) = return_pmf (l, u)\n\ngoal (1 subgoal):\n 1. trans' u u'", "unfolding trans'_def"], ["proof (prove)\nusing this:\n  \\<X> \\<noteq> {}\n  cfg' \\<in> cont (repcs (l, u) cfg) ` set_pmf (action (repcs (l, u) cfg))\n  state cfg' = (l', u')\n  (l, u) \\<in> S\n  cfg \\<in> R_G.valid_cfg\n  abss (l, u) = state cfg\n  action (repcs (l, u) cfg) \\<in> K (l, u)\n  action (repcs (l, u) cfg) = return_pmf (l, u)\n\ngoal (1 subgoal):\n 1. ((\\<forall>c\\<in>\\<X>.\n         real (k c) < u c \\<and>\n         real (k c) < u' c \\<and> u \\<noteq> u') \\<longrightarrow>\n     u' = u \\<oplus> 5 / 10) \\<and>\n    ((\\<exists>c\\<in>\\<X>.\n         u c = 0 \\<and>\n         0 < u' c \\<and>\n         (\\<forall>c\\<in>\\<X>.\n             \\<not> (\\<exists>d\\<le>k c. u' c = real d))) \\<longrightarrow>\n     u' = delayedR ([u']\\<^sub>\\<R>) u)", "by auto"], ["proof (state)\nthis:\n  trans' u u'\n\ngoal:\nNo subgoals!", "qed"], ["", "coinductive enabled_repcs where\n  \"enabled_repcs (shd xs) (stl xs) \\<Longrightarrow> shd xs = repcs st' cfg' \\<Longrightarrow> st' \\<in> rept st (action cfg)\n  \\<Longrightarrow> abss st' = state cfg'\n  \\<Longrightarrow> cfg' \\<in> R_G.valid_cfg\n  \\<Longrightarrow> enabled_repcs (repcs st cfg) xs\""], ["", "(* XXX Move *)"], ["", "lemma K_cfg_rept_in:\nassumes \"cfg \\<in> R_G.valid_cfg\"\n    and \"abss st = state cfg\"\n    and \"cfg' \\<in> K_cfg cfg\"\n  shows \"(THE s'. s' \\<in> set_pmf (rept st (action cfg)) \\<and> abss s' = state cfg')\n         \\<in> set_pmf (rept st (action cfg))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE s'.\n        s' \\<in> set_pmf (rept st (action cfg)) \\<and> abss s' = state cfg')\n    \\<in> set_pmf (rept st (action cfg))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (THE s'.\n        s' \\<in> set_pmf (rept st (action cfg)) \\<and> abss s' = state cfg')\n    \\<in> set_pmf (rept st (action cfg))", "from assms(1,2)"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.valid_cfg\n  abss st = state cfg", "have \"action cfg \\<in> \\<K> (abss st)\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  abss st = state cfg\n\ngoal (1 subgoal):\n 1. action cfg \\<in> \\<K> (abss st)", "by (auto simp: R_G_I)"], ["proof (state)\nthis:\n  action cfg \\<in> \\<K> (abss st)\n\ngoal (1 subgoal):\n 1. (THE s'.\n        s' \\<in> set_pmf (rept st (action cfg)) \\<and> abss s' = state cfg')\n    \\<in> set_pmf (rept st (action cfg))", "from \\<open>cfg' \\<in> _\\<close>"], ["proof (chain)\npicking this:\n  cfg' \\<in> set_pmf (K_cfg cfg)", "have\n    \"cfg' = cont cfg (state cfg')\" \"state cfg' \\<in> action cfg\""], ["proof (prove)\nusing this:\n  cfg' \\<in> set_pmf (K_cfg cfg)\n\ngoal (1 subgoal):\n 1. cfg' = cont cfg (state cfg') &&& state cfg' \\<in> set_pmf (action cfg)", "by (auto simp: set_K_cfg)"], ["proof (state)\nthis:\n  cfg' = cont cfg (state cfg')\n  state cfg' \\<in> set_pmf (action cfg)\n\ngoal (1 subgoal):\n 1. (THE s'.\n        s' \\<in> set_pmf (rept st (action cfg)) \\<and> abss s' = state cfg')\n    \\<in> set_pmf (rept st (action cfg))", "with abst_rept_id[OF \\<open>action _ \\<in> _\\<close>] pmf.set_map"], ["proof (chain)\npicking this:\n  abst (rept st (action cfg)) = action cfg\n  set_pmf (map_pmf ?f ?v) = ?f ` set_pmf ?v\n  cfg' = cont cfg (state cfg')\n  state cfg' \\<in> set_pmf (action cfg)", "have\n    \"state cfg' \\<in> abss ` set_pmf (rept st (action cfg))\""], ["proof (prove)\nusing this:\n  abst (rept st (action cfg)) = action cfg\n  set_pmf (map_pmf ?f ?v) = ?f ` set_pmf ?v\n  cfg' = cont cfg (state cfg')\n  state cfg' \\<in> set_pmf (action cfg)\n\ngoal (1 subgoal):\n 1. state cfg' \\<in> abss ` set_pmf (rept st (action cfg))", "unfolding abst_def"], ["proof (prove)\nusing this:\n  map_pmf abss (rept st (action cfg)) = action cfg\n  set_pmf (map_pmf ?f ?v) = ?f ` set_pmf ?v\n  cfg' = cont cfg (state cfg')\n  state cfg' \\<in> set_pmf (action cfg)\n\ngoal (1 subgoal):\n 1. state cfg' \\<in> abss ` set_pmf (rept st (action cfg))", "by metis"], ["proof (state)\nthis:\n  state cfg' \\<in> abss ` set_pmf (rept st (action cfg))\n\ngoal (1 subgoal):\n 1. (THE s'.\n        s' \\<in> set_pmf (rept st (action cfg)) \\<and> abss s' = state cfg')\n    \\<in> set_pmf (rept st (action cfg))", "then"], ["proof (chain)\npicking this:\n  state cfg' \\<in> abss ` set_pmf (rept st (action cfg))", "obtain st' where\n    \"st' \\<in> rept st (action cfg)\" \"abss st' = state cfg'\""], ["proof (prove)\nusing this:\n  state cfg' \\<in> abss ` set_pmf (rept st (action cfg))\n\ngoal (1 subgoal):\n 1. (\\<And>st'.\n        \\<lbrakk>st' \\<in> set_pmf (rept st (action cfg));\n         abss st' = state cfg'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding abst_def"], ["proof (prove)\nusing this:\n  state cfg' \\<in> abss ` set_pmf (rept st (action cfg))\n\ngoal (1 subgoal):\n 1. (\\<And>st'.\n        \\<lbrakk>st' \\<in> set_pmf (rept st (action cfg));\n         abss st' = state cfg'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  st' \\<in> set_pmf (rept st (action cfg))\n  abss st' = state cfg'\n\ngoal (1 subgoal):\n 1. (THE s'.\n        s' \\<in> set_pmf (rept st (action cfg)) \\<and> abss s' = state cfg')\n    \\<in> set_pmf (rept st (action cfg))", "with K_cfg_rept_aux[OF assms(1,2) this(1)]"], ["proof (chain)\npicking this:\n  (THE s'. s' \\<in> set_pmf (rept st (action cfg)) \\<and> s' ~ st') = st'\n  st' \\<in> set_pmf (rept st (action cfg))\n  abss st' = state cfg'", "show ?thesis"], ["proof (prove)\nusing this:\n  (THE s'. s' \\<in> set_pmf (rept st (action cfg)) \\<and> s' ~ st') = st'\n  st' \\<in> set_pmf (rept st (action cfg))\n  abss st' = state cfg'\n\ngoal (1 subgoal):\n 1. (THE s'.\n        s' \\<in> set_pmf (rept st (action cfg)) \\<and> abss s' = state cfg')\n    \\<in> set_pmf (rept st (action cfg))", "by auto"], ["proof (state)\nthis:\n  (THE s'.\n      s' \\<in> set_pmf (rept st (action cfg)) \\<and> abss s' = state cfg')\n  \\<in> set_pmf (rept st (action cfg))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma enabled_repcsI:\n  assumes \"cfg \\<in> R_G.valid_cfg\" \"abss st = state cfg\" \"MDP.MC.enabled (repcs st cfg) xs\"\n  shows \"enabled_repcs (repcs st cfg) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enabled_repcs (repcs st cfg) xs", "using assms"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  abss st = state cfg\n  MDP.MC.enabled (repcs st cfg) xs\n\ngoal (1 subgoal):\n 1. enabled_repcs (repcs st cfg) xs", "proof (coinduction arbitrary: cfg xs st)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg xs st.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss st = state cfg;\n        MDP.MC.enabled (repcs st cfg) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa st' cfg' sta cfga.\n                            repcs st cfg = repcs sta cfga \\<and>\n                            xs = xsa \\<and>\n                            ((\\<exists>cfg xs st.\n                                 shd xsa = repcs st cfg \\<and>\n                                 stl xsa = xs \\<and>\n                                 cfg \\<in> R_G.valid_cfg \\<and>\n                                 abss st = state cfg \\<and>\n                                 MDP.MC.enabled (repcs st cfg) xs) \\<or>\n                             enabled_repcs (shd xsa) (stl xsa)) \\<and>\n                            shd xsa = repcs st' cfg' \\<and>\n                            st'\n                            \\<in> set_pmf (rept sta (action cfga)) \\<and>\n                            abss st' = state cfg' \\<and>\n                            cfg' \\<in> R_G.valid_cfg", "case prems: (enabled_repcs cfg xs st)"], ["proof (state)\nthis:\n  cfg \\<in> R_G.valid_cfg\n  abss st = state cfg\n  MDP.MC.enabled (repcs st cfg) xs\n\ngoal (1 subgoal):\n 1. \\<And>cfg xs st.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss st = state cfg;\n        MDP.MC.enabled (repcs st cfg) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa st' cfg' sta cfga.\n                            repcs st cfg = repcs sta cfga \\<and>\n                            xs = xsa \\<and>\n                            ((\\<exists>cfg xs st.\n                                 shd xsa = repcs st cfg \\<and>\n                                 stl xsa = xs \\<and>\n                                 cfg \\<in> R_G.valid_cfg \\<and>\n                                 abss st = state cfg \\<and>\n                                 MDP.MC.enabled (repcs st cfg) xs) \\<or>\n                             enabled_repcs (shd xsa) (stl xsa)) \\<and>\n                            shd xsa = repcs st' cfg' \\<and>\n                            st'\n                            \\<in> set_pmf (rept sta (action cfga)) \\<and>\n                            abss st' = state cfg' \\<and>\n                            cfg' \\<in> R_G.valid_cfg", "let ?x = \"shd xs\" and ?y = \"shd (stl xs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg xs st.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss st = state cfg;\n        MDP.MC.enabled (repcs st cfg) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa st' cfg' sta cfga.\n                            repcs st cfg = repcs sta cfga \\<and>\n                            xs = xsa \\<and>\n                            ((\\<exists>cfg xs st.\n                                 shd xsa = repcs st cfg \\<and>\n                                 stl xsa = xs \\<and>\n                                 cfg \\<in> R_G.valid_cfg \\<and>\n                                 abss st = state cfg \\<and>\n                                 MDP.MC.enabled (repcs st cfg) xs) \\<or>\n                             enabled_repcs (shd xsa) (stl xsa)) \\<and>\n                            shd xsa = repcs st' cfg' \\<and>\n                            st'\n                            \\<in> set_pmf (rept sta (action cfga)) \\<and>\n                            abss st' = state cfg' \\<and>\n                            cfg' \\<in> R_G.valid_cfg", "let ?st = \"THE s'. s' \\<in> set_pmf (rept st (action cfg)) \\<and> abss s' = state (absc ?x)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg xs st.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss st = state cfg;\n        MDP.MC.enabled (repcs st cfg) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa st' cfg' sta cfga.\n                            repcs st cfg = repcs sta cfga \\<and>\n                            xs = xsa \\<and>\n                            ((\\<exists>cfg xs st.\n                                 shd xsa = repcs st cfg \\<and>\n                                 stl xsa = xs \\<and>\n                                 cfg \\<in> R_G.valid_cfg \\<and>\n                                 abss st = state cfg \\<and>\n                                 MDP.MC.enabled (repcs st cfg) xs) \\<or>\n                             enabled_repcs (shd xsa) (stl xsa)) \\<and>\n                            shd xsa = repcs st' cfg' \\<and>\n                            st'\n                            \\<in> set_pmf (rept sta (action cfga)) \\<and>\n                            abss st' = state cfg' \\<and>\n                            cfg' \\<in> R_G.valid_cfg", "from prems(3)"], ["proof (chain)\npicking this:\n  MDP.MC.enabled (repcs st cfg) xs", "have \"?x \\<in> K_cfg (repcs st cfg)\""], ["proof (prove)\nusing this:\n  MDP.MC.enabled (repcs st cfg) xs\n\ngoal (1 subgoal):\n 1. shd xs \\<in> set_pmf (K_cfg (repcs st cfg))", "by cases"], ["proof (state)\nthis:\n  shd xs \\<in> set_pmf (K_cfg (repcs st cfg))\n\ngoal (1 subgoal):\n 1. \\<And>cfg xs st.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss st = state cfg;\n        MDP.MC.enabled (repcs st cfg) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa st' cfg' sta cfga.\n                            repcs st cfg = repcs sta cfga \\<and>\n                            xs = xsa \\<and>\n                            ((\\<exists>cfg xs st.\n                                 shd xsa = repcs st cfg \\<and>\n                                 stl xsa = xs \\<and>\n                                 cfg \\<in> R_G.valid_cfg \\<and>\n                                 abss st = state cfg \\<and>\n                                 MDP.MC.enabled (repcs st cfg) xs) \\<or>\n                             enabled_repcs (shd xsa) (stl xsa)) \\<and>\n                            shd xsa = repcs st' cfg' \\<and>\n                            st'\n                            \\<in> set_pmf (rept sta (action cfga)) \\<and>\n                            abss st' = state cfg' \\<and>\n                            cfg' \\<in> R_G.valid_cfg", "with K_cfg_map_repcs[OF prems(1,2)]"], ["proof (chain)\npicking this:\n  K_cfg (repcs st cfg) =\n  map_pmf\n   (\\<lambda>cfg'.\n       repcs\n        (THE s'.\n            s' \\<in> set_pmf (rept st (action cfg)) \\<and>\n            abss s' = state cfg')\n        cfg')\n   (K_cfg cfg)\n  shd xs \\<in> set_pmf (K_cfg (repcs st cfg))", "obtain cfg' where\n    \"cfg' \\<in> K_cfg cfg\" \"?x = repcs (THE s'. s' \\<in> rept st (action cfg) \\<and> abss s' = state cfg') cfg'\""], ["proof (prove)\nusing this:\n  K_cfg (repcs st cfg) =\n  map_pmf\n   (\\<lambda>cfg'.\n       repcs\n        (THE s'.\n            s' \\<in> set_pmf (rept st (action cfg)) \\<and>\n            abss s' = state cfg')\n        cfg')\n   (K_cfg cfg)\n  shd xs \\<in> set_pmf (K_cfg (repcs st cfg))\n\ngoal (1 subgoal):\n 1. (\\<And>cfg'.\n        \\<lbrakk>cfg' \\<in> set_pmf (K_cfg cfg);\n         shd xs =\n         repcs\n          (THE s'.\n              s' \\<in> set_pmf (rept st (action cfg)) \\<and>\n              abss s' = state cfg')\n          cfg'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  cfg' \\<in> set_pmf (K_cfg cfg)\n  shd xs =\n  repcs\n   (THE s'.\n       s' \\<in> set_pmf (rept st (action cfg)) \\<and> abss s' = state cfg')\n   cfg'\n\ngoal (1 subgoal):\n 1. \\<And>cfg xs st.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss st = state cfg;\n        MDP.MC.enabled (repcs st cfg) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa st' cfg' sta cfga.\n                            repcs st cfg = repcs sta cfga \\<and>\n                            xs = xsa \\<and>\n                            ((\\<exists>cfg xs st.\n                                 shd xsa = repcs st cfg \\<and>\n                                 stl xsa = xs \\<and>\n                                 cfg \\<in> R_G.valid_cfg \\<and>\n                                 abss st = state cfg \\<and>\n                                 MDP.MC.enabled (repcs st cfg) xs) \\<or>\n                             enabled_repcs (shd xsa) (stl xsa)) \\<and>\n                            shd xsa = repcs st' cfg' \\<and>\n                            st'\n                            \\<in> set_pmf (rept sta (action cfga)) \\<and>\n                            abss st' = state cfg' \\<and>\n                            cfg' \\<in> R_G.valid_cfg", "let ?st = \"THE s'. s' \\<in> rept st (action cfg) \\<and> abss s' = state cfg'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg xs st.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss st = state cfg;\n        MDP.MC.enabled (repcs st cfg) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa st' cfg' sta cfga.\n                            repcs st cfg = repcs sta cfga \\<and>\n                            xs = xsa \\<and>\n                            ((\\<exists>cfg xs st.\n                                 shd xsa = repcs st cfg \\<and>\n                                 stl xsa = xs \\<and>\n                                 cfg \\<in> R_G.valid_cfg \\<and>\n                                 abss st = state cfg \\<and>\n                                 MDP.MC.enabled (repcs st cfg) xs) \\<or>\n                             enabled_repcs (shd xsa) (stl xsa)) \\<and>\n                            shd xsa = repcs st' cfg' \\<and>\n                            st'\n                            \\<in> set_pmf (rept sta (action cfga)) \\<and>\n                            abss st' = state cfg' \\<and>\n                            cfg' \\<in> R_G.valid_cfg", "from K_cfg_rept_action[OF prems(1,2) \\<open>cfg' \\<in> _\\<close>]"], ["proof (chain)\npicking this:\n  abss\n   (THE s'.\n       s' \\<in> set_pmf (rept st (action cfg)) \\<and>\n       abss s' = state cfg') =\n  state cfg'", "have \"abss ?st = state cfg'\""], ["proof (prove)\nusing this:\n  abss\n   (THE s'.\n       s' \\<in> set_pmf (rept st (action cfg)) \\<and>\n       abss s' = state cfg') =\n  state cfg'\n\ngoal (1 subgoal):\n 1. abss\n     (THE s'.\n         s' \\<in> set_pmf (rept st (action cfg)) \\<and>\n         abss s' = state cfg') =\n    state cfg'", "."], ["proof (state)\nthis:\n  abss\n   (THE s'.\n       s' \\<in> set_pmf (rept st (action cfg)) \\<and>\n       abss s' = state cfg') =\n  state cfg'\n\ngoal (1 subgoal):\n 1. \\<And>cfg xs st.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss st = state cfg;\n        MDP.MC.enabled (repcs st cfg) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa st' cfg' sta cfga.\n                            repcs st cfg = repcs sta cfga \\<and>\n                            xs = xsa \\<and>\n                            ((\\<exists>cfg xs st.\n                                 shd xsa = repcs st cfg \\<and>\n                                 stl xsa = xs \\<and>\n                                 cfg \\<in> R_G.valid_cfg \\<and>\n                                 abss st = state cfg \\<and>\n                                 MDP.MC.enabled (repcs st cfg) xs) \\<or>\n                             enabled_repcs (shd xsa) (stl xsa)) \\<and>\n                            shd xsa = repcs st' cfg' \\<and>\n                            st'\n                            \\<in> set_pmf (rept sta (action cfga)) \\<and>\n                            abss st' = state cfg' \\<and>\n                            cfg' \\<in> R_G.valid_cfg", "moreover"], ["proof (state)\nthis:\n  abss\n   (THE s'.\n       s' \\<in> set_pmf (rept st (action cfg)) \\<and>\n       abss s' = state cfg') =\n  state cfg'\n\ngoal (1 subgoal):\n 1. \\<And>cfg xs st.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss st = state cfg;\n        MDP.MC.enabled (repcs st cfg) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa st' cfg' sta cfga.\n                            repcs st cfg = repcs sta cfga \\<and>\n                            xs = xsa \\<and>\n                            ((\\<exists>cfg xs st.\n                                 shd xsa = repcs st cfg \\<and>\n                                 stl xsa = xs \\<and>\n                                 cfg \\<in> R_G.valid_cfg \\<and>\n                                 abss st = state cfg \\<and>\n                                 MDP.MC.enabled (repcs st cfg) xs) \\<or>\n                             enabled_repcs (shd xsa) (stl xsa)) \\<and>\n                            shd xsa = repcs st' cfg' \\<and>\n                            st'\n                            \\<in> set_pmf (rept sta (action cfga)) \\<and>\n                            abss st' = state cfg' \\<and>\n                            cfg' \\<in> R_G.valid_cfg", "from K_cfg_rept_in[OF prems(1,2) \\<open>cfg' \\<in> _\\<close>]"], ["proof (chain)\npicking this:\n  (THE s'.\n      s' \\<in> set_pmf (rept st (action cfg)) \\<and> abss s' = state cfg')\n  \\<in> set_pmf (rept st (action cfg))", "have \"?st \\<in> rept st (action cfg)\""], ["proof (prove)\nusing this:\n  (THE s'.\n      s' \\<in> set_pmf (rept st (action cfg)) \\<and> abss s' = state cfg')\n  \\<in> set_pmf (rept st (action cfg))\n\ngoal (1 subgoal):\n 1. (THE s'.\n        s' \\<in> set_pmf (rept st (action cfg)) \\<and> abss s' = state cfg')\n    \\<in> set_pmf (rept st (action cfg))", "."], ["proof (state)\nthis:\n  (THE s'.\n      s' \\<in> set_pmf (rept st (action cfg)) \\<and> abss s' = state cfg')\n  \\<in> set_pmf (rept st (action cfg))\n\ngoal (1 subgoal):\n 1. \\<And>cfg xs st.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss st = state cfg;\n        MDP.MC.enabled (repcs st cfg) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa st' cfg' sta cfga.\n                            repcs st cfg = repcs sta cfga \\<and>\n                            xs = xsa \\<and>\n                            ((\\<exists>cfg xs st.\n                                 shd xsa = repcs st cfg \\<and>\n                                 stl xsa = xs \\<and>\n                                 cfg \\<in> R_G.valid_cfg \\<and>\n                                 abss st = state cfg \\<and>\n                                 MDP.MC.enabled (repcs st cfg) xs) \\<or>\n                             enabled_repcs (shd xsa) (stl xsa)) \\<and>\n                            shd xsa = repcs st' cfg' \\<and>\n                            st'\n                            \\<in> set_pmf (rept sta (action cfga)) \\<and>\n                            abss st' = state cfg' \\<and>\n                            cfg' \\<in> R_G.valid_cfg", "moreover"], ["proof (state)\nthis:\n  (THE s'.\n      s' \\<in> set_pmf (rept st (action cfg)) \\<and> abss s' = state cfg')\n  \\<in> set_pmf (rept st (action cfg))\n\ngoal (1 subgoal):\n 1. \\<And>cfg xs st.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss st = state cfg;\n        MDP.MC.enabled (repcs st cfg) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa st' cfg' sta cfga.\n                            repcs st cfg = repcs sta cfga \\<and>\n                            xs = xsa \\<and>\n                            ((\\<exists>cfg xs st.\n                                 shd xsa = repcs st cfg \\<and>\n                                 stl xsa = xs \\<and>\n                                 cfg \\<in> R_G.valid_cfg \\<and>\n                                 abss st = state cfg \\<and>\n                                 MDP.MC.enabled (repcs st cfg) xs) \\<or>\n                             enabled_repcs (shd xsa) (stl xsa)) \\<and>\n                            shd xsa = repcs st' cfg' \\<and>\n                            st'\n                            \\<in> set_pmf (rept sta (action cfga)) \\<and>\n                            abss st' = state cfg' \\<and>\n                            cfg' \\<in> R_G.valid_cfg", "have \"cfg' \\<in> R_G.valid_cfg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cfg' \\<in> R_G.valid_cfg", "using \\<open>cfg' \\<in> K_cfg cfg\\<close> prems(1)"], ["proof (prove)\nusing this:\n  cfg' \\<in> set_pmf (K_cfg cfg)\n  cfg \\<in> R_G.valid_cfg\n\ngoal (1 subgoal):\n 1. cfg' \\<in> R_G.valid_cfg", "by blast"], ["proof (state)\nthis:\n  cfg' \\<in> R_G.valid_cfg\n\ngoal (1 subgoal):\n 1. \\<And>cfg xs st.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss st = state cfg;\n        MDP.MC.enabled (repcs st cfg) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa st' cfg' sta cfga.\n                            repcs st cfg = repcs sta cfga \\<and>\n                            xs = xsa \\<and>\n                            ((\\<exists>cfg xs st.\n                                 shd xsa = repcs st cfg \\<and>\n                                 stl xsa = xs \\<and>\n                                 cfg \\<in> R_G.valid_cfg \\<and>\n                                 abss st = state cfg \\<and>\n                                 MDP.MC.enabled (repcs st cfg) xs) \\<or>\n                             enabled_repcs (shd xsa) (stl xsa)) \\<and>\n                            shd xsa = repcs st' cfg' \\<and>\n                            st'\n                            \\<in> set_pmf (rept sta (action cfga)) \\<and>\n                            abss st' = state cfg' \\<and>\n                            cfg' \\<in> R_G.valid_cfg", "moreover"], ["proof (state)\nthis:\n  cfg' \\<in> R_G.valid_cfg\n\ngoal (1 subgoal):\n 1. \\<And>cfg xs st.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss st = state cfg;\n        MDP.MC.enabled (repcs st cfg) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa st' cfg' sta cfga.\n                            repcs st cfg = repcs sta cfga \\<and>\n                            xs = xsa \\<and>\n                            ((\\<exists>cfg xs st.\n                                 shd xsa = repcs st cfg \\<and>\n                                 stl xsa = xs \\<and>\n                                 cfg \\<in> R_G.valid_cfg \\<and>\n                                 abss st = state cfg \\<and>\n                                 MDP.MC.enabled (repcs st cfg) xs) \\<or>\n                             enabled_repcs (shd xsa) (stl xsa)) \\<and>\n                            shd xsa = repcs st' cfg' \\<and>\n                            st'\n                            \\<in> set_pmf (rept sta (action cfga)) \\<and>\n                            abss st' = state cfg' \\<and>\n                            cfg' \\<in> R_G.valid_cfg", "from absc_repcs_id[OF this \\<open>abss ?st = state cfg'\\<close>] \\<open>?x = _\\<close>"], ["proof (chain)\npicking this:\n  absc\n   (repcs\n     (THE s'.\n         s' \\<in> set_pmf (rept st (action cfg)) \\<and>\n         abss s' = state cfg')\n     cfg') =\n  cfg'\n  shd xs =\n  repcs\n   (THE s'.\n       s' \\<in> set_pmf (rept st (action cfg)) \\<and> abss s' = state cfg')\n   cfg'", "have \"absc ?x = cfg'\""], ["proof (prove)\nusing this:\n  absc\n   (repcs\n     (THE s'.\n         s' \\<in> set_pmf (rept st (action cfg)) \\<and>\n         abss s' = state cfg')\n     cfg') =\n  cfg'\n  shd xs =\n  repcs\n   (THE s'.\n       s' \\<in> set_pmf (rept st (action cfg)) \\<and> abss s' = state cfg')\n   cfg'\n\ngoal (1 subgoal):\n 1. absc (shd xs) = cfg'", "by auto"], ["proof (state)\nthis:\n  absc (shd xs) = cfg'\n\ngoal (1 subgoal):\n 1. \\<And>cfg xs st.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss st = state cfg;\n        MDP.MC.enabled (repcs st cfg) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa st' cfg' sta cfga.\n                            repcs st cfg = repcs sta cfga \\<and>\n                            xs = xsa \\<and>\n                            ((\\<exists>cfg xs st.\n                                 shd xsa = repcs st cfg \\<and>\n                                 stl xsa = xs \\<and>\n                                 cfg \\<in> R_G.valid_cfg \\<and>\n                                 abss st = state cfg \\<and>\n                                 MDP.MC.enabled (repcs st cfg) xs) \\<or>\n                             enabled_repcs (shd xsa) (stl xsa)) \\<and>\n                            shd xsa = repcs st' cfg' \\<and>\n                            st'\n                            \\<in> set_pmf (rept sta (action cfga)) \\<and>\n                            abss st' = state cfg' \\<and>\n                            cfg' \\<in> R_G.valid_cfg", "moreover"], ["proof (state)\nthis:\n  absc (shd xs) = cfg'\n\ngoal (1 subgoal):\n 1. \\<And>cfg xs st.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss st = state cfg;\n        MDP.MC.enabled (repcs st cfg) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa st' cfg' sta cfga.\n                            repcs st cfg = repcs sta cfga \\<and>\n                            xs = xsa \\<and>\n                            ((\\<exists>cfg xs st.\n                                 shd xsa = repcs st cfg \\<and>\n                                 stl xsa = xs \\<and>\n                                 cfg \\<in> R_G.valid_cfg \\<and>\n                                 abss st = state cfg \\<and>\n                                 MDP.MC.enabled (repcs st cfg) xs) \\<or>\n                             enabled_repcs (shd xsa) (stl xsa)) \\<and>\n                            shd xsa = repcs st' cfg' \\<and>\n                            st'\n                            \\<in> set_pmf (rept sta (action cfga)) \\<and>\n                            abss st' = state cfg' \\<and>\n                            cfg' \\<in> R_G.valid_cfg", "from prems(3)"], ["proof (chain)\npicking this:\n  MDP.MC.enabled (repcs st cfg) xs", "have \"MDP.MC.enabled (shd xs) (stl xs)\""], ["proof (prove)\nusing this:\n  MDP.MC.enabled (repcs st cfg) xs\n\ngoal (1 subgoal):\n 1. MDP.MC.enabled (shd xs) (stl xs)", "by cases"], ["proof (state)\nthis:\n  MDP.MC.enabled (shd xs) (stl xs)\n\ngoal (1 subgoal):\n 1. \\<And>cfg xs st.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss st = state cfg;\n        MDP.MC.enabled (repcs st cfg) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa st' cfg' sta cfga.\n                            repcs st cfg = repcs sta cfga \\<and>\n                            xs = xsa \\<and>\n                            ((\\<exists>cfg xs st.\n                                 shd xsa = repcs st cfg \\<and>\n                                 stl xsa = xs \\<and>\n                                 cfg \\<in> R_G.valid_cfg \\<and>\n                                 abss st = state cfg \\<and>\n                                 MDP.MC.enabled (repcs st cfg) xs) \\<or>\n                             enabled_repcs (shd xsa) (stl xsa)) \\<and>\n                            shd xsa = repcs st' cfg' \\<and>\n                            st'\n                            \\<in> set_pmf (rept sta (action cfga)) \\<and>\n                            abss st' = state cfg' \\<and>\n                            cfg' \\<in> R_G.valid_cfg", "ultimately"], ["proof (chain)\npicking this:\n  abss\n   (THE s'.\n       s' \\<in> set_pmf (rept st (action cfg)) \\<and>\n       abss s' = state cfg') =\n  state cfg'\n  (THE s'.\n      s' \\<in> set_pmf (rept st (action cfg)) \\<and> abss s' = state cfg')\n  \\<in> set_pmf (rept st (action cfg))\n  cfg' \\<in> R_G.valid_cfg\n  absc (shd xs) = cfg'\n  MDP.MC.enabled (shd xs) (stl xs)", "show ?case"], ["proof (prove)\nusing this:\n  abss\n   (THE s'.\n       s' \\<in> set_pmf (rept st (action cfg)) \\<and>\n       abss s' = state cfg') =\n  state cfg'\n  (THE s'.\n      s' \\<in> set_pmf (rept st (action cfg)) \\<and> abss s' = state cfg')\n  \\<in> set_pmf (rept st (action cfg))\n  cfg' \\<in> R_G.valid_cfg\n  absc (shd xs) = cfg'\n  MDP.MC.enabled (shd xs) (stl xs)\n\ngoal (1 subgoal):\n 1. \\<exists>xs st' cfg' st cfg.\n       repcs st cfg = repcs st cfg \\<and>\n       xs = xs \\<and>\n       ((\\<exists>cfg xsa st.\n            shd xs = repcs st cfg \\<and>\n            stl xs = xsa \\<and>\n            cfg \\<in> R_G.valid_cfg \\<and>\n            abss st = state cfg \\<and>\n            MDP.MC.enabled (repcs st cfg) xsa) \\<or>\n        enabled_repcs (shd xs) (stl xs)) \\<and>\n       shd xs = repcs st' cfg' \\<and>\n       st' \\<in> set_pmf (rept st (action cfg)) \\<and>\n       abss st' = state cfg' \\<and> cfg' \\<in> R_G.valid_cfg", "using \\<open>?x = _\\<close>"], ["proof (prove)\nusing this:\n  abss\n   (THE s'.\n       s' \\<in> set_pmf (rept st (action cfg)) \\<and>\n       abss s' = state cfg') =\n  state cfg'\n  (THE s'.\n      s' \\<in> set_pmf (rept st (action cfg)) \\<and> abss s' = state cfg')\n  \\<in> set_pmf (rept st (action cfg))\n  cfg' \\<in> R_G.valid_cfg\n  absc (shd xs) = cfg'\n  MDP.MC.enabled (shd xs) (stl xs)\n  shd xs =\n  repcs\n   (THE s'.\n       s' \\<in> set_pmf (rept st (action cfg)) \\<and> abss s' = state cfg')\n   cfg'\n\ngoal (1 subgoal):\n 1. \\<exists>xs st' cfg' st cfg.\n       repcs st cfg = repcs st cfg \\<and>\n       xs = xs \\<and>\n       ((\\<exists>cfg xsa st.\n            shd xs = repcs st cfg \\<and>\n            stl xs = xsa \\<and>\n            cfg \\<in> R_G.valid_cfg \\<and>\n            abss st = state cfg \\<and>\n            MDP.MC.enabled (repcs st cfg) xsa) \\<or>\n        enabled_repcs (shd xs) (stl xs)) \\<and>\n       shd xs = repcs st' cfg' \\<and>\n       st' \\<in> set_pmf (rept st (action cfg)) \\<and>\n       abss st' = state cfg' \\<and> cfg' \\<in> R_G.valid_cfg", "by (inst_existentials xs ?st \"absc ?x\" st cfg) fastforce+"], ["proof (state)\nthis:\n  \\<exists>xs st' cfg' st cfg.\n     repcs st cfg = repcs st cfg \\<and>\n     xs = xs \\<and>\n     ((\\<exists>cfg xsa st.\n          shd xs = repcs st cfg \\<and>\n          stl xs = xsa \\<and>\n          cfg \\<in> R_G.valid_cfg \\<and>\n          abss st = state cfg \\<and>\n          MDP.MC.enabled (repcs st cfg) xsa) \\<or>\n      enabled_repcs (shd xs) (stl xs)) \\<and>\n     shd xs = repcs st' cfg' \\<and>\n     st' \\<in> set_pmf (rept st (action cfg)) \\<and>\n     abss st' = state cfg' \\<and> cfg' \\<in> R_G.valid_cfg\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma repcs_eq_rept:\n  \"rept st (action cfg) = rept st'' (action cfg'')\" if \"repcs st cfg = repcs st'' cfg''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rept st (action cfg) = rept st'' (action cfg'')", "by (metis (mono_tags, lifting) action_cfg_corec old.prod.case repcs_def that)"], ["", "lemma enabled_stream_trans':\n  assumes \"cfg \\<in> R_G.valid_cfg\" \"abss st = state cfg\" \"MDP.MC.enabled (repcs st cfg) xs\"\n  shows \"pairwise trans' (smap (snd o state) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PTA_Reachability.pairwise trans' (smap (snd \\<circ> state) xs)", "using assms"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  abss st = state cfg\n  MDP.MC.enabled (repcs st cfg) xs\n\ngoal (1 subgoal):\n 1. PTA_Reachability.pairwise trans' (smap (snd \\<circ> state) xs)", "proof (coinduction arbitrary: cfg xs st)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg xs st.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss st = state cfg;\n        MDP.MC.enabled (repcs st cfg) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b xsa.\n                            smap (snd \\<circ> state) xs =\n                            a ## b ## xsa \\<and>\n                            trans' a b \\<and>\n                            ((\\<exists>cfg xs st.\n                                 b ## xsa =\n                                 smap (snd \\<circ> state) xs \\<and>\n                                 cfg \\<in> R_G.valid_cfg \\<and>\n                                 abss st = state cfg \\<and>\n                                 MDP.MC.enabled (repcs st cfg) xs) \\<or>\n                             PTA_Reachability.pairwise trans' (b ## xsa))", "case prems: (pairwise cfg xs)"], ["proof (state)\nthis:\n  cfg \\<in> R_G.valid_cfg\n  abss st = state cfg\n  MDP.MC.enabled (repcs st cfg) xs\n\ngoal (1 subgoal):\n 1. \\<And>cfg xs st.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss st = state cfg;\n        MDP.MC.enabled (repcs st cfg) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b xsa.\n                            smap (snd \\<circ> state) xs =\n                            a ## b ## xsa \\<and>\n                            trans' a b \\<and>\n                            ((\\<exists>cfg xs st.\n                                 b ## xsa =\n                                 smap (snd \\<circ> state) xs \\<and>\n                                 cfg \\<in> R_G.valid_cfg \\<and>\n                                 abss st = state cfg \\<and>\n                                 MDP.MC.enabled (repcs st cfg) xs) \\<or>\n                             PTA_Reachability.pairwise trans' (b ## xsa))", "let ?xs = \"stl xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg xs st.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss st = state cfg;\n        MDP.MC.enabled (repcs st cfg) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b xsa.\n                            smap (snd \\<circ> state) xs =\n                            a ## b ## xsa \\<and>\n                            trans' a b \\<and>\n                            ((\\<exists>cfg xs st.\n                                 b ## xsa =\n                                 smap (snd \\<circ> state) xs \\<and>\n                                 cfg \\<in> R_G.valid_cfg \\<and>\n                                 abss st = state cfg \\<and>\n                                 MDP.MC.enabled (repcs st cfg) xs) \\<or>\n                             PTA_Reachability.pairwise trans' (b ## xsa))", "from prems"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.valid_cfg\n  abss st = state cfg\n  MDP.MC.enabled (repcs st cfg) xs", "have A: \"enabled_repcs (repcs st cfg) xs\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  abss st = state cfg\n  MDP.MC.enabled (repcs st cfg) xs\n\ngoal (1 subgoal):\n 1. enabled_repcs (repcs st cfg) xs", "by (auto intro: enabled_repcsI)"], ["proof (state)\nthis:\n  enabled_repcs (repcs st cfg) xs\n\ngoal (1 subgoal):\n 1. \\<And>cfg xs st.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss st = state cfg;\n        MDP.MC.enabled (repcs st cfg) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b xsa.\n                            smap (snd \\<circ> state) xs =\n                            a ## b ## xsa \\<and>\n                            trans' a b \\<and>\n                            ((\\<exists>cfg xs st.\n                                 b ## xsa =\n                                 smap (snd \\<circ> state) xs \\<and>\n                                 cfg \\<in> R_G.valid_cfg \\<and>\n                                 abss st = state cfg \\<and>\n                                 MDP.MC.enabled (repcs st cfg) xs) \\<or>\n                             PTA_Reachability.pairwise trans' (b ## xsa))", "then"], ["proof (chain)\npicking this:\n  enabled_repcs (repcs st cfg) xs", "obtain st' cfg' where\n    \"enabled_repcs (shd xs) (stl xs)\" \"shd xs = repcs st' cfg'\" \"st' \\<in> rept st (action cfg)\"\n    \"abss st' = state cfg'\" \"cfg' \\<in> R_G.valid_cfg\""], ["proof (prove)\nusing this:\n  enabled_repcs (repcs st cfg) xs\n\ngoal (1 subgoal):\n 1. (\\<And>st' cfg'.\n        \\<lbrakk>enabled_repcs (shd xs) (stl xs); shd xs = repcs st' cfg';\n         st' \\<in> set_pmf (rept st (action cfg)); abss st' = state cfg';\n         cfg' \\<in> R_G.valid_cfg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. enabled_repcs (repcs st cfg) xs \\<Longrightarrow>\n    \\<exists>st' cfg'.\n       enabled_repcs (shd xs) (stl xs) \\<and>\n       shd xs = repcs st' cfg' \\<and>\n       st' \\<in> set_pmf (rept st (action cfg)) \\<and>\n       abss st' = state cfg' \\<and> cfg' \\<in> R_G.valid_cfg", "apply (cases rule: enabled_repcs.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. enabled_repcs (repcs st cfg) xs \\<Longrightarrow>\n    enabled_repcs ?a1.11 ?a2.11\n 2. \\<And>st' cfg' st cfg.\n       \\<lbrakk>enabled_repcs (repcs st cfg) xs; ?a1.11 = repcs st cfg;\n        enabled_repcs (shd ?a2.11) (stl ?a2.11);\n        shd ?a2.11 = repcs st' cfg';\n        st' \\<in> set_pmf (rept st (action cfg)); abss st' = state cfg';\n        cfg' \\<in> R_G.valid_cfg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>st' cfg'.\n                            enabled_repcs (shd xs) (stl xs) \\<and>\n                            shd xs = repcs st' cfg' \\<and>\n                            st' \\<in> set_pmf (rept st (action cfg)) \\<and>\n                            abss st' = state cfg' \\<and>\n                            cfg' \\<in> R_G.valid_cfg", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>st' cfg' st cfg.\n       \\<lbrakk>enabled_repcs (repcs st cfg) xs;\n        repcs st cfg = repcs st cfg; enabled_repcs (shd xs) (stl xs);\n        shd xs = repcs st' cfg'; st' \\<in> set_pmf (rept st (action cfg));\n        abss st' = state cfg'; cfg' \\<in> R_G.valid_cfg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>st' cfg'.\n                            enabled_repcs (shd xs) (stl xs) \\<and>\n                            shd xs = repcs st' cfg' \\<and>\n                            st' \\<in> set_pmf (rept st (action cfg)) \\<and>\n                            abss st' = state cfg' \\<and>\n                            cfg' \\<in> R_G.valid_cfg", "subgoal for st' cfg' st'' cfg''"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>enabled_repcs (repcs st cfg) xs;\n     repcs st cfg = repcs st'' cfg''; enabled_repcs (shd xs) (stl xs);\n     shd xs = repcs st' cfg'; st' \\<in> set_pmf (rept st'' (action cfg''));\n     abss st' = state cfg'; cfg' \\<in> R_G.valid_cfg\\<rbrakk>\n    \\<Longrightarrow> \\<exists>st' cfg'.\n                         enabled_repcs (shd xs) (stl xs) \\<and>\n                         shd xs = repcs st' cfg' \\<and>\n                         st' \\<in> set_pmf (rept st (action cfg)) \\<and>\n                         abss st' = state cfg' \\<and>\n                         cfg' \\<in> R_G.valid_cfg", "by (inst_existentials st' cfg') (auto dest: repcs_eq_rept)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  enabled_repcs (shd xs) (stl xs)\n  shd xs = repcs st' cfg'\n  st' \\<in> set_pmf (rept st (action cfg))\n  abss st' = state cfg'\n  cfg' \\<in> R_G.valid_cfg\n\ngoal (1 subgoal):\n 1. \\<And>cfg xs st.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss st = state cfg;\n        MDP.MC.enabled (repcs st cfg) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b xsa.\n                            smap (snd \\<circ> state) xs =\n                            a ## b ## xsa \\<and>\n                            trans' a b \\<and>\n                            ((\\<exists>cfg xs st.\n                                 b ## xsa =\n                                 smap (snd \\<circ> state) xs \\<and>\n                                 cfg \\<in> R_G.valid_cfg \\<and>\n                                 abss st = state cfg \\<and>\n                                 MDP.MC.enabled (repcs st cfg) xs) \\<or>\n                             PTA_Reachability.pairwise trans' (b ## xsa))", "then"], ["proof (chain)\npicking this:\n  enabled_repcs (shd xs) (stl xs)\n  shd xs = repcs st' cfg'\n  st' \\<in> set_pmf (rept st (action cfg))\n  abss st' = state cfg'\n  cfg' \\<in> R_G.valid_cfg", "obtain st'' cfg'' where\n    \"enabled_repcs (shd ?xs) (stl ?xs)\"\n    \"shd ?xs = repcs st'' cfg''\" \"st'' \\<in> rept st' (action cfg')\" \"abss st'' = state cfg''\""], ["proof (prove)\nusing this:\n  enabled_repcs (shd xs) (stl xs)\n  shd xs = repcs st' cfg'\n  st' \\<in> set_pmf (rept st (action cfg))\n  abss st' = state cfg'\n  cfg' \\<in> R_G.valid_cfg\n\ngoal (1 subgoal):\n 1. (\\<And>st'' cfg''.\n        \\<lbrakk>enabled_repcs (shd (stl xs)) (stl (stl xs));\n         shd (stl xs) = repcs st'' cfg'';\n         st'' \\<in> set_pmf (rept st' (action cfg'));\n         abss st'' = state cfg''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by atomize_elim (subst (asm)enabled_repcs.simps, fastforce dest: repcs_eq_rept)"], ["proof (state)\nthis:\n  enabled_repcs (shd (stl xs)) (stl (stl xs))\n  shd (stl xs) = repcs st'' cfg''\n  st'' \\<in> set_pmf (rept st' (action cfg'))\n  abss st'' = state cfg''\n\ngoal (1 subgoal):\n 1. \\<And>cfg xs st.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss st = state cfg;\n        MDP.MC.enabled (repcs st cfg) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b xsa.\n                            smap (snd \\<circ> state) xs =\n                            a ## b ## xsa \\<and>\n                            trans' a b \\<and>\n                            ((\\<exists>cfg xs st.\n                                 b ## xsa =\n                                 smap (snd \\<circ> state) xs \\<and>\n                                 cfg \\<in> R_G.valid_cfg \\<and>\n                                 abss st = state cfg \\<and>\n                                 MDP.MC.enabled (repcs st cfg) xs) \\<or>\n                             PTA_Reachability.pairwise trans' (b ## xsa))", "let ?x = \"shd xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg xs st.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss st = state cfg;\n        MDP.MC.enabled (repcs st cfg) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b xsa.\n                            smap (snd \\<circ> state) xs =\n                            a ## b ## xsa \\<and>\n                            trans' a b \\<and>\n                            ((\\<exists>cfg xs st.\n                                 b ## xsa =\n                                 smap (snd \\<circ> state) xs \\<and>\n                                 cfg \\<in> R_G.valid_cfg \\<and>\n                                 abss st = state cfg \\<and>\n                                 MDP.MC.enabled (repcs st cfg) xs) \\<or>\n                             PTA_Reachability.pairwise trans' (b ## xsa))", "let ?y = \"shd (stl xs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg xs st.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss st = state cfg;\n        MDP.MC.enabled (repcs st cfg) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b xsa.\n                            smap (snd \\<circ> state) xs =\n                            a ## b ## xsa \\<and>\n                            trans' a b \\<and>\n                            ((\\<exists>cfg xs st.\n                                 b ## xsa =\n                                 smap (snd \\<circ> state) xs \\<and>\n                                 cfg \\<in> R_G.valid_cfg \\<and>\n                                 abss st = state cfg \\<and>\n                                 MDP.MC.enabled (repcs st cfg) xs) \\<or>\n                             PTA_Reachability.pairwise trans' (b ## xsa))", "let ?cfg = \"repcs st cfg\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg xs st.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss st = state cfg;\n        MDP.MC.enabled (repcs st cfg) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b xsa.\n                            smap (snd \\<circ> state) xs =\n                            a ## b ## xsa \\<and>\n                            trans' a b \\<and>\n                            ((\\<exists>cfg xs st.\n                                 b ## xsa =\n                                 smap (snd \\<circ> state) xs \\<and>\n                                 cfg \\<in> R_G.valid_cfg \\<and>\n                                 abss st = state cfg \\<and>\n                                 MDP.MC.enabled (repcs st cfg) xs) \\<or>\n                             PTA_Reachability.pairwise trans' (b ## xsa))", "from prems"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.valid_cfg\n  abss st = state cfg\n  MDP.MC.enabled (repcs st cfg) xs", "have \"?cfg \\<in> valid_cfg\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  abss st = state cfg\n  MDP.MC.enabled (repcs st cfg) xs\n\ngoal (1 subgoal):\n 1. repcs st cfg \\<in> MDP.valid_cfg", "by auto"], ["proof (state)\nthis:\n  repcs st cfg \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. \\<And>cfg xs st.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss st = state cfg;\n        MDP.MC.enabled (repcs st cfg) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b xsa.\n                            smap (snd \\<circ> state) xs =\n                            a ## b ## xsa \\<and>\n                            trans' a b \\<and>\n                            ((\\<exists>cfg xs st.\n                                 b ## xsa =\n                                 smap (snd \\<circ> state) xs \\<and>\n                                 cfg \\<in> R_G.valid_cfg \\<and>\n                                 abss st = state cfg \\<and>\n                                 MDP.MC.enabled (repcs st cfg) xs) \\<or>\n                             PTA_Reachability.pairwise trans' (b ## xsa))", "from MDP.pred_stream_cfg_on[OF \\<open>?cfg \\<in> valid_cfg\\<close> prems(3)]"], ["proof (chain)\npicking this:\n  pred_stream\n   (\\<lambda>cfg. state cfg \\<in> S \\<and> cfg \\<in> MDP.cfg_on (state cfg))\n   xs", "have *:\n    \"pred_stream (\\<lambda>cfg. state cfg \\<in> S \\<and> cfg \\<in> MDP.cfg_on (state cfg)) xs\""], ["proof (prove)\nusing this:\n  pred_stream\n   (\\<lambda>cfg. state cfg \\<in> S \\<and> cfg \\<in> MDP.cfg_on (state cfg))\n   xs\n\ngoal (1 subgoal):\n 1. pred_stream\n     (\\<lambda>cfg.\n         state cfg \\<in> S \\<and> cfg \\<in> MDP.cfg_on (state cfg))\n     xs", "."], ["proof (state)\nthis:\n  pred_stream\n   (\\<lambda>cfg. state cfg \\<in> S \\<and> cfg \\<in> MDP.cfg_on (state cfg))\n   xs\n\ngoal (1 subgoal):\n 1. \\<And>cfg xs st.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss st = state cfg;\n        MDP.MC.enabled (repcs st cfg) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b xsa.\n                            smap (snd \\<circ> state) xs =\n                            a ## b ## xsa \\<and>\n                            trans' a b \\<and>\n                            ((\\<exists>cfg xs st.\n                                 b ## xsa =\n                                 smap (snd \\<circ> state) xs \\<and>\n                                 cfg \\<in> R_G.valid_cfg \\<and>\n                                 abss st = state cfg \\<and>\n                                 MDP.MC.enabled (repcs st cfg) xs) \\<or>\n                             PTA_Reachability.pairwise trans' (b ## xsa))", "obtain l u l' u' where eq: \"st' = (l, u)\" \"st'' = (l', u')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l u l' u'.\n        \\<lbrakk>st' = (l, u); st'' = (l', u')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  st' = (l, u)\n  st'' = (l', u')\n\ngoal (1 subgoal):\n 1. \\<And>cfg xs st.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss st = state cfg;\n        MDP.MC.enabled (repcs st cfg) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b xsa.\n                            smap (snd \\<circ> state) xs =\n                            a ## b ## xsa \\<and>\n                            trans' a b \\<and>\n                            ((\\<exists>cfg xs st.\n                                 b ## xsa =\n                                 smap (snd \\<circ> state) xs \\<and>\n                                 cfg \\<in> R_G.valid_cfg \\<and>\n                                 abss st = state cfg \\<and>\n                                 MDP.MC.enabled (repcs st cfg) xs) \\<or>\n                             PTA_Reachability.pairwise trans' (b ## xsa))", "moreover"], ["proof (state)\nthis:\n  st' = (l, u)\n  st'' = (l', u')\n\ngoal (1 subgoal):\n 1. \\<And>cfg xs st.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss st = state cfg;\n        MDP.MC.enabled (repcs st cfg) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b xsa.\n                            smap (snd \\<circ> state) xs =\n                            a ## b ## xsa \\<and>\n                            trans' a b \\<and>\n                            ((\\<exists>cfg xs st.\n                                 b ## xsa =\n                                 smap (snd \\<circ> state) xs \\<and>\n                                 cfg \\<in> R_G.valid_cfg \\<and>\n                                 abss st = state cfg \\<and>\n                                 MDP.MC.enabled (repcs st cfg) xs) \\<or>\n                             PTA_Reachability.pairwise trans' (b ## xsa))", "from *"], ["proof (chain)\npicking this:\n  pred_stream\n   (\\<lambda>cfg. state cfg \\<in> S \\<and> cfg \\<in> MDP.cfg_on (state cfg))\n   xs", "have\n    \"?x \\<in> MDP.cfg_on (state ?x)\" \"?x \\<in> valid_cfg\""], ["proof (prove)\nusing this:\n  pred_stream\n   (\\<lambda>cfg. state cfg \\<in> S \\<and> cfg \\<in> MDP.cfg_on (state cfg))\n   xs\n\ngoal (1 subgoal):\n 1. shd xs \\<in> MDP.cfg_on (state (shd xs)) &&& shd xs \\<in> MDP.valid_cfg", "by (auto intro: MDP.valid_cfgI simp: stream.pred_set)"], ["proof (state)\nthis:\n  shd xs \\<in> MDP.cfg_on (state (shd xs))\n  shd xs \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. \\<And>cfg xs st.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss st = state cfg;\n        MDP.MC.enabled (repcs st cfg) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b xsa.\n                            smap (snd \\<circ> state) xs =\n                            a ## b ## xsa \\<and>\n                            trans' a b \\<and>\n                            ((\\<exists>cfg xs st.\n                                 b ## xsa =\n                                 smap (snd \\<circ> state) xs \\<and>\n                                 cfg \\<in> R_G.valid_cfg \\<and>\n                                 abss st = state cfg \\<and>\n                                 MDP.MC.enabled (repcs st cfg) xs) \\<or>\n                             PTA_Reachability.pairwise trans' (b ## xsa))", "moreover"], ["proof (state)\nthis:\n  shd xs \\<in> MDP.cfg_on (state (shd xs))\n  shd xs \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. \\<And>cfg xs st.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss st = state cfg;\n        MDP.MC.enabled (repcs st cfg) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b xsa.\n                            smap (snd \\<circ> state) xs =\n                            a ## b ## xsa \\<and>\n                            trans' a b \\<and>\n                            ((\\<exists>cfg xs st.\n                                 b ## xsa =\n                                 smap (snd \\<circ> state) xs \\<and>\n                                 cfg \\<in> R_G.valid_cfg \\<and>\n                                 abss st = state cfg \\<and>\n                                 MDP.MC.enabled (repcs st cfg) xs) \\<or>\n                             PTA_Reachability.pairwise trans' (b ## xsa))", "from prems(3)"], ["proof (chain)\npicking this:\n  MDP.MC.enabled (repcs st cfg) xs", "have \"?y \\<in> K_cfg ?x\""], ["proof (prove)\nusing this:\n  MDP.MC.enabled (repcs st cfg) xs\n\ngoal (1 subgoal):\n 1. shd (stl xs) \\<in> set_pmf (K_cfg (shd xs))", "by (auto elim: MDP.MC.enabled.cases)"], ["proof (state)\nthis:\n  shd (stl xs) \\<in> set_pmf (K_cfg (shd xs))\n\ngoal (1 subgoal):\n 1. \\<And>cfg xs st.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss st = state cfg;\n        MDP.MC.enabled (repcs st cfg) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b xsa.\n                            smap (snd \\<circ> state) xs =\n                            a ## b ## xsa \\<and>\n                            trans' a b \\<and>\n                            ((\\<exists>cfg xs st.\n                                 b ## xsa =\n                                 smap (snd \\<circ> state) xs \\<and>\n                                 cfg \\<in> R_G.valid_cfg \\<and>\n                                 abss st = state cfg \\<and>\n                                 MDP.MC.enabled (repcs st cfg) xs) \\<or>\n                             PTA_Reachability.pairwise trans' (b ## xsa))", "ultimately"], ["proof (chain)\npicking this:\n  st' = (l, u)\n  st'' = (l', u')\n  shd xs \\<in> MDP.cfg_on (state (shd xs))\n  shd xs \\<in> MDP.valid_cfg\n  shd (stl xs) \\<in> set_pmf (K_cfg (shd xs))", "have \"trans' u u'\""], ["proof (prove)\nusing this:\n  st' = (l, u)\n  st'' = (l', u')\n  shd xs \\<in> MDP.cfg_on (state (shd xs))\n  shd xs \\<in> MDP.valid_cfg\n  shd (stl xs) \\<in> set_pmf (K_cfg (shd xs))\n\ngoal (1 subgoal):\n 1. trans' u u'", "using \\<open>?x = _\\<close> \\<open>?y = _\\<close> \\<open>cfg' \\<in> _\\<close> \\<open>abss st' = _\\<close>"], ["proof (prove)\nusing this:\n  st' = (l, u)\n  st'' = (l', u')\n  shd xs \\<in> MDP.cfg_on (state (shd xs))\n  shd xs \\<in> MDP.valid_cfg\n  shd (stl xs) \\<in> set_pmf (K_cfg (shd xs))\n  shd xs = repcs st' cfg'\n  shd (stl xs) = repcs st'' cfg''\n  cfg' \\<in> R_G.valid_cfg\n  abss st' = state cfg'\n\ngoal (1 subgoal):\n 1. trans' u u'", "by (intro K_cfg_trans') (auto dest: MDP.valid_cfg_state_in_S)"], ["proof (state)\nthis:\n  trans' u u'\n\ngoal (1 subgoal):\n 1. \\<And>cfg xs st.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss st = state cfg;\n        MDP.MC.enabled (repcs st cfg) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b xsa.\n                            smap (snd \\<circ> state) xs =\n                            a ## b ## xsa \\<and>\n                            trans' a b \\<and>\n                            ((\\<exists>cfg xs st.\n                                 b ## xsa =\n                                 smap (snd \\<circ> state) xs \\<and>\n                                 cfg \\<in> R_G.valid_cfg \\<and>\n                                 abss st = state cfg \\<and>\n                                 MDP.MC.enabled (repcs st cfg) xs) \\<or>\n                             PTA_Reachability.pairwise trans' (b ## xsa))", "with \\<open>?x \\<in> valid_cfg\\<close> \\<open>cfg' \\<in> R_G.valid_cfg\\<close> prems(3) \\<open>abss _ = state cfg'\\<close>"], ["proof (chain)\npicking this:\n  shd xs \\<in> MDP.valid_cfg\n  cfg' \\<in> R_G.valid_cfg\n  MDP.MC.enabled (repcs st cfg) xs\n  abss st' = state cfg'\n  trans' u u'", "show ?case"], ["proof (prove)\nusing this:\n  shd xs \\<in> MDP.valid_cfg\n  cfg' \\<in> R_G.valid_cfg\n  MDP.MC.enabled (repcs st cfg) xs\n  abss st' = state cfg'\n  trans' u u'\n\ngoal (1 subgoal):\n 1. \\<exists>a b xs.\n       smap (snd \\<circ> state) xs = a ## b ## xs \\<and>\n       trans' a b \\<and>\n       ((\\<exists>cfg xsa st.\n            b ## xs = smap (snd \\<circ> state) xsa \\<and>\n            cfg \\<in> R_G.valid_cfg \\<and>\n            abss st = state cfg \\<and>\n            MDP.MC.enabled (repcs st cfg) xsa) \\<or>\n        PTA_Reachability.pairwise trans' (b ## xs))", "apply (inst_existentials u u' \"smap (snd o state) (stl ?xs)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>shd xs \\<in> MDP.valid_cfg; cfg' \\<in> R_G.valid_cfg;\n     MDP.MC.enabled (repcs st cfg) xs; abss st' = state cfg';\n     trans' u u'\\<rbrakk>\n    \\<Longrightarrow> smap (snd \\<circ> state) xs =\n                      u ## u' ## smap (snd \\<circ> state) (stl (stl xs))\n 2. \\<lbrakk>shd xs \\<in> MDP.valid_cfg; cfg' \\<in> R_G.valid_cfg;\n     MDP.MC.enabled (repcs st cfg) xs; abss st' = state cfg';\n     trans' u u'\\<rbrakk>\n    \\<Longrightarrow> trans' u u'\n 3. \\<lbrakk>shd xs \\<in> MDP.valid_cfg; cfg' \\<in> R_G.valid_cfg;\n     MDP.MC.enabled (repcs st cfg) xs; abss st' = state cfg';\n     trans' u u'\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>cfg xs st.\n                          u' ## smap (snd \\<circ> state) (stl (stl xs)) =\n                          smap (snd \\<circ> state) xs \\<and>\n                          cfg \\<in> R_G.valid_cfg \\<and>\n                          abss st = state cfg \\<and>\n                          MDP.MC.enabled (repcs st cfg) xs) \\<or>\n                      PTA_Reachability.pairwise trans'\n                       (u' ## smap (snd \\<circ> state) (stl (stl xs)))", "apply (simp add: eq \\<open>?x = _\\<close> \\<open>?y = _\\<close>; fail)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>shd xs \\<in> MDP.valid_cfg; cfg' \\<in> R_G.valid_cfg;\n     MDP.MC.enabled (repcs st cfg) xs; abss st' = state cfg';\n     trans' u u'\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>cfg xs st.\n                          u' ## smap (snd \\<circ> state) (stl (stl xs)) =\n                          smap (snd \\<circ> state) xs \\<and>\n                          cfg \\<in> R_G.valid_cfg \\<and>\n                          abss st = state cfg \\<and>\n                          MDP.MC.enabled (repcs st cfg) xs) \\<or>\n                      PTA_Reachability.pairwise trans'\n                       (u' ## smap (snd \\<circ> state) (stl (stl xs)))", "by ((intro disjI1 exI)?; auto simp: \\<open>?x = _\\<close> \\<open>?y = _\\<close> eq elim: MDP.MC.enabled.cases)"], ["proof (state)\nthis:\n  \\<exists>a b xs.\n     smap (snd \\<circ> state) xs = a ## b ## xs \\<and>\n     trans' a b \\<and>\n     ((\\<exists>cfg xsa st.\n          b ## xs = smap (snd \\<circ> state) xsa \\<and>\n          cfg \\<in> R_G.valid_cfg \\<and>\n          abss st = state cfg \\<and>\n          MDP.MC.enabled (repcs st cfg) xsa) \\<or>\n      PTA_Reachability.pairwise trans' (b ## xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma divergent_\\<R>_divergent:\n  assumes in_S: \"pred_stream (\\<lambda> u. u \\<in> V) xs\"\n     and  div:  \"divergent xs\"\n     and trans: \"stream_trans xs\"\n  shows \"\\<R>_div (smap (\\<lambda> u. [u]\\<^sub>\\<R>) xs)\" (is \"\\<R>_div ?\\<omega>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<R>_div (smap (\\<lambda>u. [u]\\<^sub>\\<R>) xs)", "unfolding \\<R>_div_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>\\<X>.\n       (\\<forall>i.\n           (\\<exists>j\\<ge>i.\n               zero x (smap (\\<lambda>u. [u]\\<^sub>\\<R>) xs !! j)) \\<and>\n           (\\<exists>j\\<ge>i.\n               \\<not> zero x\n                       (smap (\\<lambda>u. [u]\\<^sub>\\<R>) xs !! j))) \\<or>\n       (\\<exists>i.\n           \\<forall>j\\<ge>i.\n              unbounded x (smap (\\<lambda>u. [u]\\<^sub>\\<R>) xs !! j))", "proof (safe, simp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i. zero x ([xs !! j]\\<^sub>\\<R>)\n 2. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<not> zero x ([xs !! j]\\<^sub>\\<R>)", "fix x i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i. zero x ([xs !! j]\\<^sub>\\<R>)\n 2. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<not> zero x ([xs !! j]\\<^sub>\\<R>)", "assume x: \"x \\<in> \\<X>\" and bounded: \"\\<forall>i. \\<exists>j\\<ge>i. \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\""], ["proof (state)\nthis:\n  x \\<in> \\<X>\n  \\<forall>i. \\<exists>j\\<ge>i. \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\n\ngoal (2 subgoals):\n 1. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i. zero x ([xs !! j]\\<^sub>\\<R>)\n 2. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<not> zero x ([xs !! j]\\<^sub>\\<R>)", "from in_S"], ["proof (chain)\npicking this:\n  pred_stream (\\<lambda>u. u \\<in> V) xs", "have xs_\\<omega>: \"\\<forall>i. xs !! i \\<in> ?\\<omega> !! i\""], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n\ngoal (1 subgoal):\n 1. \\<forall>i. xs !! i \\<in> smap (\\<lambda>u. [u]\\<^sub>\\<R>) xs !! i", "by (auto simp: stream.pred_set)"], ["proof (state)\nthis:\n  \\<forall>i. xs !! i \\<in> smap (\\<lambda>u. [u]\\<^sub>\\<R>) xs !! i\n\ngoal (2 subgoals):\n 1. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i. zero x ([xs !! j]\\<^sub>\\<R>)\n 2. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<not> zero x ([xs !! j]\\<^sub>\\<R>)", "from trans in_S"], ["proof (chain)\npicking this:\n  stream_trans xs\n  pred_stream (\\<lambda>u. u \\<in> V) xs", "have elapsed:\n    \"\\<forall> i. eq_elapsed (xs !! i) (xs !! Suc i)\""], ["proof (prove)\nusing this:\n  stream_trans xs\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n\ngoal (1 subgoal):\n 1. \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)", "by (fastforce intro: pairwise_trans_eq_elapsed pairwise_Suc[where P = eq_elapsed])"], ["proof (state)\nthis:\n  \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\n\ngoal (2 subgoals):\n 1. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i. zero x ([xs !! j]\\<^sub>\\<R>)\n 2. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<not> zero x ([xs !! j]\\<^sub>\\<R>)", "{"], ["proof (state)\nthis:\n  \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\n\ngoal (2 subgoals):\n 1. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i. zero x ([xs !! j]\\<^sub>\\<R>)\n 2. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<not> zero x ([xs !! j]\\<^sub>\\<R>)", "assume A: \"\\<forall>j \\<ge> i. \\<not> zero x ([xs !! j]\\<^sub>\\<R>)\""], ["proof (state)\nthis:\n  \\<forall>j\\<ge>i. \\<not> zero x ([xs !! j]\\<^sub>\\<R>)\n\ngoal (2 subgoals):\n 1. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i. zero x ([xs !! j]\\<^sub>\\<R>)\n 2. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<not> zero x ([xs !! j]\\<^sub>\\<R>)", "let ?t = \"dur xs i + k x\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i. zero x ([xs !! j]\\<^sub>\\<R>)\n 2. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<not> zero x ([xs !! j]\\<^sub>\\<R>)", "from div"], ["proof (chain)\npicking this:\n  divergent xs", "obtain j where j: \"dur xs j > dur xs i + k x\""], ["proof (prove)\nusing this:\n  divergent xs\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        dur xs i + real (k x) < dur xs j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding divergent_def"], ["proof (prove)\nusing this:\n  \\<forall>t. \\<exists>n. t < dur xs n\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        dur xs i + real (k x) < dur xs j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  dur xs i + real (k x) < dur xs j\n\ngoal (2 subgoals):\n 1. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i. zero x ([xs !! j]\\<^sub>\\<R>)\n 2. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<not> zero x ([xs !! j]\\<^sub>\\<R>)", "then"], ["proof (chain)\npicking this:\n  dur xs i + real (k x) < dur xs j", "have \"k x < dur xs j - dur xs i\""], ["proof (prove)\nusing this:\n  dur xs i + real (k x) < dur xs j\n\ngoal (1 subgoal):\n 1. real (k x) < dur xs j - dur xs i", "by auto"], ["proof (state)\nthis:\n  real (k x) < dur xs j - dur xs i\n\ngoal (2 subgoals):\n 1. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i. zero x ([xs !! j]\\<^sub>\\<R>)\n 2. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<not> zero x ([xs !! j]\\<^sub>\\<R>)", "also"], ["proof (state)\nthis:\n  real (k x) < dur xs j - dur xs i\n\ngoal (2 subgoals):\n 1. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i. zero x ([xs !! j]\\<^sub>\\<R>)\n 2. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<not> zero x ([xs !! j]\\<^sub>\\<R>)", "with not_reset_dur'[OF A less_imp_le[OF dur_monoD], of xs] \\<open>x \\<in> \\<X>\\<close> assms elapsed"], ["proof (chain)\npicking this:\n  \\<lbrakk>dur xs i < dur xs ?j; x \\<in> \\<X>; stream_trans xs;\n   \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i);\n   \\<forall>j. xs !! j \\<in> V\\<rbrakk>\n  \\<Longrightarrow> dur xs ?j - dur xs i = (xs !! ?j) x - (xs !! i) x\n  x \\<in> \\<X>\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  divergent xs\n  stream_trans xs\n  \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\n  real (k x) < dur xs j - dur xs i", "have\n      \"\\<dots> = (xs !! j) x - (xs !! i) x\""], ["proof (prove)\nusing this:\n  \\<lbrakk>dur xs i < dur xs ?j; x \\<in> \\<X>; stream_trans xs;\n   \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i);\n   \\<forall>j. xs !! j \\<in> V\\<rbrakk>\n  \\<Longrightarrow> dur xs ?j - dur xs i = (xs !! ?j) x - (xs !! i) x\n  x \\<in> \\<X>\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  divergent xs\n  stream_trans xs\n  \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\n  real (k x) < dur xs j - dur xs i\n\ngoal (1 subgoal):\n 1. dur xs j - dur xs i = (xs !! j) x - (xs !! i) x", "by (auto simp: stream.pred_set)"], ["proof (state)\nthis:\n  dur xs j - dur xs i = (xs !! j) x - (xs !! i) x\n\ngoal (2 subgoals):\n 1. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i. zero x ([xs !! j]\\<^sub>\\<R>)\n 2. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<not> zero x ([xs !! j]\\<^sub>\\<R>)", "also"], ["proof (state)\nthis:\n  dur xs j - dur xs i = (xs !! j) x - (xs !! i) x\n\ngoal (2 subgoals):\n 1. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i. zero x ([xs !! j]\\<^sub>\\<R>)\n 2. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<not> zero x ([xs !! j]\\<^sub>\\<R>)", "have \"\\<dots> \\<le> (xs !! j) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs !! j) x - (xs !! i) x \\<le> (xs !! j) x", "using assms(1) \\<open>x \\<in> \\<X>\\<close>"], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  x \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. (xs !! j) x - (xs !! i) x \\<le> (xs !! j) x", "unfolding V_def"], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>u. u \\<in> {v. \\<forall>x\\<in>\\<X>. 0 \\<le> v x}) xs\n  x \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. (xs !! j) x - (xs !! i) x \\<le> (xs !! j) x", "by (auto simp: stream.pred_set)"], ["proof (state)\nthis:\n  (xs !! j) x - (xs !! i) x \\<le> (xs !! j) x\n\ngoal (2 subgoals):\n 1. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i. zero x ([xs !! j]\\<^sub>\\<R>)\n 2. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<not> zero x ([xs !! j]\\<^sub>\\<R>)", "finally"], ["proof (chain)\npicking this:\n  real (k x) < (xs !! j) x", "have \"unbounded x ([xs !! j]\\<^sub>\\<R>)\""], ["proof (prove)\nusing this:\n  real (k x) < (xs !! j) x\n\ngoal (1 subgoal):\n 1. unbounded x ([xs !! j]\\<^sub>\\<R>)", "using assms \\<open>x \\<in> \\<X>\\<close>"], ["proof (prove)\nusing this:\n  real (k x) < (xs !! j) x\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  divergent xs\n  stream_trans xs\n  x \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. unbounded x ([xs !! j]\\<^sub>\\<R>)", "by (intro gt_unboundedD) (auto simp: stream.pred_set)"], ["proof (state)\nthis:\n  unbounded x ([xs !! j]\\<^sub>\\<R>)\n\ngoal (2 subgoals):\n 1. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i. zero x ([xs !! j]\\<^sub>\\<R>)\n 2. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<not> zero x ([xs !! j]\\<^sub>\\<R>)", "moreover"], ["proof (state)\nthis:\n  unbounded x ([xs !! j]\\<^sub>\\<R>)\n\ngoal (2 subgoals):\n 1. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i. zero x ([xs !! j]\\<^sub>\\<R>)\n 2. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<not> zero x ([xs !! j]\\<^sub>\\<R>)", "from dur_monoD[of xs i j] j A"], ["proof (chain)\npicking this:\n  dur xs i < dur xs j \\<Longrightarrow> i < j\n  dur xs i + real (k x) < dur xs j\n  \\<forall>j\\<ge>i. \\<not> zero x ([xs !! j]\\<^sub>\\<R>)", "have \"\\<forall>j' \\<ge> j. \\<not> zero x ([xs !! j']\\<^sub>\\<R>)\""], ["proof (prove)\nusing this:\n  dur xs i < dur xs j \\<Longrightarrow> i < j\n  dur xs i + real (k x) < dur xs j\n  \\<forall>j\\<ge>i. \\<not> zero x ([xs !! j]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. \\<forall>j'\\<ge>j. \\<not> zero x ([xs !! j']\\<^sub>\\<R>)", "by auto"], ["proof (state)\nthis:\n  \\<forall>j'\\<ge>j. \\<not> zero x ([xs !! j']\\<^sub>\\<R>)\n\ngoal (2 subgoals):\n 1. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i. zero x ([xs !! j]\\<^sub>\\<R>)\n 2. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<not> zero x ([xs !! j]\\<^sub>\\<R>)", "ultimately"], ["proof (chain)\npicking this:\n  unbounded x ([xs !! j]\\<^sub>\\<R>)\n  \\<forall>j'\\<ge>j. \\<not> zero x ([xs !! j']\\<^sub>\\<R>)", "have \"\\<forall>i\\<ge>j. unbounded x ([xs !! i]\\<^sub>\\<R>)\""], ["proof (prove)\nusing this:\n  unbounded x ([xs !! j]\\<^sub>\\<R>)\n  \\<forall>j'\\<ge>j. \\<not> zero x ([xs !! j']\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<ge>j. unbounded x ([xs !! i]\\<^sub>\\<R>)", "using elapsed assms x"], ["proof (prove)\nusing this:\n  unbounded x ([xs !! j]\\<^sub>\\<R>)\n  \\<forall>j'\\<ge>j. \\<not> zero x ([xs !! j']\\<^sub>\\<R>)\n  \\<forall>i. eq_elapsed (xs !! i) (xs !! Suc i)\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  divergent xs\n  stream_trans xs\n  x \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<ge>j. unbounded x ([xs !! i]\\<^sub>\\<R>)", "by (auto intro: not_reset_unbounded simp: stream.pred_set)"], ["proof (state)\nthis:\n  \\<forall>i\\<ge>j. unbounded x ([xs !! i]\\<^sub>\\<R>)\n\ngoal (2 subgoals):\n 1. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i. zero x ([xs !! j]\\<^sub>\\<R>)\n 2. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<not> zero x ([xs !! j]\\<^sub>\\<R>)", "with bounded"], ["proof (chain)\npicking this:\n  \\<forall>i. \\<exists>j\\<ge>i. \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\n  \\<forall>i\\<ge>j. unbounded x ([xs !! i]\\<^sub>\\<R>)", "have False"], ["proof (prove)\nusing this:\n  \\<forall>i. \\<exists>j\\<ge>i. \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\n  \\<forall>i\\<ge>j. unbounded x ([xs !! i]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i. zero x ([xs !! j]\\<^sub>\\<R>)\n 2. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<not> zero x ([xs !! j]\\<^sub>\\<R>)", "}"], ["proof (state)\nthis:\n  \\<forall>j\\<ge>i. \\<not> zero x ([xs !! j]\\<^sub>\\<R>) \\<Longrightarrow>\n  False\n\ngoal (2 subgoals):\n 1. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i. zero x ([xs !! j]\\<^sub>\\<R>)\n 2. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<not> zero x ([xs !! j]\\<^sub>\\<R>)", "then"], ["proof (chain)\npicking this:\n  \\<forall>j\\<ge>i. \\<not> zero x ([xs !! j]\\<^sub>\\<R>) \\<Longrightarrow>\n  False", "show \"\\<exists>j\\<ge>i. zero x ([xs !! j]\\<^sub>\\<R>)\""], ["proof (prove)\nusing this:\n  \\<forall>j\\<ge>i. \\<not> zero x ([xs !! j]\\<^sub>\\<R>) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i. zero x ([xs !! j]\\<^sub>\\<R>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>j\\<ge>i. zero x ([xs !! j]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<not> zero x ([xs !! j]\\<^sub>\\<R>)", "{"], ["proof (state)\nthis:\n  \\<exists>j\\<ge>i. zero x ([xs !! j]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<not> zero x ([xs !! j]\\<^sub>\\<R>)", "assume A: \"\\<forall>j \\<ge> i. zero x ([xs !! j]\\<^sub>\\<R>)\""], ["proof (state)\nthis:\n  \\<forall>j\\<ge>i. zero x ([xs !! j]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<not> zero x ([xs !! j]\\<^sub>\\<R>)", "from div"], ["proof (chain)\npicking this:\n  divergent xs", "obtain j where j: \"dur xs j > dur xs i\""], ["proof (prove)\nusing this:\n  divergent xs\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        dur xs i < dur xs j \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding divergent_def"], ["proof (prove)\nusing this:\n  \\<forall>t. \\<exists>n. t < dur xs n\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        dur xs i < dur xs j \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  dur xs i < dur xs j\n\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<not> zero x ([xs !! j]\\<^sub>\\<R>)", "then"], ["proof (chain)\npicking this:\n  dur xs i < dur xs j", "have \"j \\<ge> i\""], ["proof (prove)\nusing this:\n  dur xs i < dur xs j\n\ngoal (1 subgoal):\n 1. i \\<le> j", "by (auto dest: dur_monoD)"], ["proof (state)\nthis:\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<not> zero x ([xs !! j]\\<^sub>\\<R>)", "from A"], ["proof (chain)\npicking this:\n  \\<forall>j\\<ge>i. zero x ([xs !! j]\\<^sub>\\<R>)", "have \"\\<forall>j \\<ge> i. zero x (?\\<omega> !! j)\""], ["proof (prove)\nusing this:\n  \\<forall>j\\<ge>i. zero x ([xs !! j]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. \\<forall>j\\<ge>i. zero x (smap (\\<lambda>u. [u]\\<^sub>\\<R>) xs !! j)", "by auto"], ["proof (state)\nthis:\n  \\<forall>j\\<ge>i. zero x (smap (\\<lambda>u. [u]\\<^sub>\\<R>) xs !! j)\n\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<not> zero x ([xs !! j]\\<^sub>\\<R>)", "with dur_zero_tail[OF xs_\\<omega> _ x \\<open>i \\<le> j\\<close> elapsed] j"], ["proof (chain)\npicking this:\n  \\<forall>k\\<ge>i.\n     k \\<le> j \\<longrightarrow>\n     zero x (smap (\\<lambda>u. [u]\\<^sub>\\<R>) xs !! k) \\<Longrightarrow>\n  dur xs j = dur xs i\n  dur xs i < dur xs j\n  \\<forall>j\\<ge>i. zero x (smap (\\<lambda>u. [u]\\<^sub>\\<R>) xs !! j)", "have False"], ["proof (prove)\nusing this:\n  \\<forall>k\\<ge>i.\n     k \\<le> j \\<longrightarrow>\n     zero x (smap (\\<lambda>u. [u]\\<^sub>\\<R>) xs !! k) \\<Longrightarrow>\n  dur xs j = dur xs i\n  dur xs i < dur xs j\n  \\<forall>j\\<ge>i. zero x (smap (\\<lambda>u. [u]\\<^sub>\\<R>) xs !! j)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<not> zero x ([xs !! j]\\<^sub>\\<R>)", "}"], ["proof (state)\nthis:\n  \\<forall>j\\<ge>i. zero x ([xs !! j]\\<^sub>\\<R>) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>x \\<in> \\<X>;\n        \\<forall>i.\n           \\<exists>j\\<ge>i.\n              \\<not> unbounded x ([xs !! j]\\<^sub>\\<R>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<not> zero x ([xs !! j]\\<^sub>\\<R>)", "then"], ["proof (chain)\npicking this:\n  \\<forall>j\\<ge>i. zero x ([xs !! j]\\<^sub>\\<R>) \\<Longrightarrow> False", "show \"\\<exists>j\\<ge>i. \\<not> zero x ([xs !! j]\\<^sub>\\<R>)\""], ["proof (prove)\nusing this:\n  \\<forall>j\\<ge>i. zero x ([xs !! j]\\<^sub>\\<R>) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i. \\<not> zero x ([xs !! j]\\<^sub>\\<R>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>j\\<ge>i. \\<not> zero x ([xs !! j]\\<^sub>\\<R>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in -)\n  fixes f :: \"nat \\<Rightarrow> real\"\n  assumes \"\\<forall> i. f i \\<ge> 0\" \"\\<forall> i. \\<exists> j \\<ge> i. f j > d\" \"d > 0\"\n  shows \"\\<exists> n. (\\<Sum> i \\<le> n. f i) > t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. t < sum f {..n}", "oops"], ["", "(* TODO: Reduce this proof to a more general theorem *)"], ["", "lemma dur_ev_exceedsI:\n  assumes \"\\<forall> i. \\<exists> j \\<ge> i. dur xs j - dur xs i \\<ge> d\" and \"d > 0\"\n  obtains i where \"dur xs i > t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. t < dur xs i \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>i. t < dur xs i \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have base: \"\\<exists> i. dur xs i > t\" if \"t < d\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. t < dur xs i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i. t < dur xs i", "from assms"], ["proof (chain)\npicking this:\n  \\<forall>i. \\<exists>j\\<ge>i. d \\<le> dur xs j - dur xs i\n  0 < d", "obtain j where \"dur xs j - dur xs 0 \\<ge> d\""], ["proof (prove)\nusing this:\n  \\<forall>i. \\<exists>j\\<ge>i. d \\<le> dur xs j - dur xs i\n  0 < d\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        d \\<le> dur xs j - dur xs 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  d \\<le> dur xs j - dur xs 0\n\ngoal (1 subgoal):\n 1. \\<exists>i. t < dur xs i", "with dur_pos[of xs 0]"], ["proof (chain)\npicking this:\n  0 \\<le> dur xs 0\n  d \\<le> dur xs j - dur xs 0", "have \"dur xs j \\<ge> d\""], ["proof (prove)\nusing this:\n  0 \\<le> dur xs 0\n  d \\<le> dur xs j - dur xs 0\n\ngoal (1 subgoal):\n 1. d \\<le> dur xs j", "by simp"], ["proof (state)\nthis:\n  d \\<le> dur xs j\n\ngoal (1 subgoal):\n 1. \\<exists>i. t < dur xs i", "with \\<open>d > 0\\<close> \\<open>t < d\\<close>"], ["proof (chain)\npicking this:\n  0 < d\n  t < d\n  d \\<le> dur xs j", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < d\n  t < d\n  d \\<le> dur xs j\n\ngoal (1 subgoal):\n 1. \\<exists>i. t < dur xs i", "by - (rule exI[where x = j]; auto)"], ["proof (state)\nthis:\n  \\<exists>i. t < dur xs i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?t8 < d \\<Longrightarrow> \\<exists>i. ?t8 < dur xs i\n\ngoal (1 subgoal):\n 1. (\\<And>i. t < dur xs i \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have base2: \"\\<exists> i. dur xs i > t\" if \"t \\<le> d\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. t < dur xs i", "proof (cases \"t = d\")"], ["proof (state)\ngoal (2 subgoals):\n 1. t = d \\<Longrightarrow> \\<exists>i. t < dur xs i\n 2. t \\<noteq> d \\<Longrightarrow> \\<exists>i. t < dur xs i", "case False"], ["proof (state)\nthis:\n  t \\<noteq> d\n\ngoal (2 subgoals):\n 1. t = d \\<Longrightarrow> \\<exists>i. t < dur xs i\n 2. t \\<noteq> d \\<Longrightarrow> \\<exists>i. t < dur xs i", "with \\<open>t \\<le> d\\<close> base"], ["proof (chain)\npicking this:\n  t \\<le> d\n  ?t8 < d \\<Longrightarrow> \\<exists>i. ?t8 < dur xs i\n  t \\<noteq> d", "show ?thesis"], ["proof (prove)\nusing this:\n  t \\<le> d\n  ?t8 < d \\<Longrightarrow> \\<exists>i. ?t8 < dur xs i\n  t \\<noteq> d\n\ngoal (1 subgoal):\n 1. \\<exists>i. t < dur xs i", "by simp"], ["proof (state)\nthis:\n  \\<exists>i. t < dur xs i\n\ngoal (1 subgoal):\n 1. t = d \\<Longrightarrow> \\<exists>i. t < dur xs i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t = d \\<Longrightarrow> \\<exists>i. t < dur xs i", "case True"], ["proof (state)\nthis:\n  t = d\n\ngoal (1 subgoal):\n 1. t = d \\<Longrightarrow> \\<exists>i. t < dur xs i", "from base \\<open>d > 0\\<close>"], ["proof (chain)\npicking this:\n  ?t8 < d \\<Longrightarrow> \\<exists>i. ?t8 < dur xs i\n  0 < d", "obtain i where \"dur xs i > 0\""], ["proof (prove)\nusing this:\n  ?t8 < d \\<Longrightarrow> \\<exists>i. ?t8 < dur xs i\n  0 < d\n\ngoal (1 subgoal):\n 1. (\\<And>i. 0 < dur xs i \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  0 < dur xs i\n\ngoal (1 subgoal):\n 1. t = d \\<Longrightarrow> \\<exists>i. t < dur xs i", "moreover"], ["proof (state)\nthis:\n  0 < dur xs i\n\ngoal (1 subgoal):\n 1. t = d \\<Longrightarrow> \\<exists>i. t < dur xs i", "from assms"], ["proof (chain)\npicking this:\n  \\<forall>i. \\<exists>j\\<ge>i. d \\<le> dur xs j - dur xs i\n  0 < d", "obtain j where \"dur xs j - dur xs i \\<ge> d\""], ["proof (prove)\nusing this:\n  \\<forall>i. \\<exists>j\\<ge>i. d \\<le> dur xs j - dur xs i\n  0 < d\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        d \\<le> dur xs j - dur xs i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  d \\<le> dur xs j - dur xs i\n\ngoal (1 subgoal):\n 1. t = d \\<Longrightarrow> \\<exists>i. t < dur xs i", "ultimately"], ["proof (chain)\npicking this:\n  0 < dur xs i\n  d \\<le> dur xs j - dur xs i", "have \"dur xs j > d\""], ["proof (prove)\nusing this:\n  0 < dur xs i\n  d \\<le> dur xs j - dur xs i\n\ngoal (1 subgoal):\n 1. d < dur xs j", "by auto"], ["proof (state)\nthis:\n  d < dur xs j\n\ngoal (1 subgoal):\n 1. t = d \\<Longrightarrow> \\<exists>i. t < dur xs i", "with \\<open>t = d\\<close>"], ["proof (chain)\npicking this:\n  t = d\n  d < dur xs j", "show ?thesis"], ["proof (prove)\nusing this:\n  t = d\n  d < dur xs j\n\ngoal (1 subgoal):\n 1. \\<exists>i. t < dur xs i", "by auto"], ["proof (state)\nthis:\n  \\<exists>i. t < dur xs i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?t8 \\<le> d \\<Longrightarrow> \\<exists>i. ?t8 < dur xs i\n\ngoal (1 subgoal):\n 1. (\\<And>i. t < dur xs i \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (cases \"t \\<ge> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> t \\<Longrightarrow> thesis\n 2. \\<not> 0 \\<le> t \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  \\<not> 0 \\<le> t\n\ngoal (2 subgoals):\n 1. 0 \\<le> t \\<Longrightarrow> thesis\n 2. \\<not> 0 \\<le> t \\<Longrightarrow> thesis", "with dur_pos"], ["proof (chain)\npicking this:\n  0 \\<le> dur ?xs ?i\n  \\<not> 0 \\<le> t", "have \"dur xs 0 > t\""], ["proof (prove)\nusing this:\n  0 \\<le> dur ?xs ?i\n  \\<not> 0 \\<le> t\n\ngoal (1 subgoal):\n 1. t < dur xs 0", "by auto"], ["proof (state)\nthis:\n  t < dur xs 0\n\ngoal (2 subgoals):\n 1. 0 \\<le> t \\<Longrightarrow> thesis\n 2. \\<not> 0 \\<le> t \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  t < dur xs 0", "show ?thesis"], ["proof (prove)\nusing this:\n  t < dur xs 0\n\ngoal (1 subgoal):\n 1. thesis", "by (fastforce intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. 0 \\<le> t \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<le> t \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  0 \\<le> t\n\ngoal (1 subgoal):\n 1. 0 \\<le> t \\<Longrightarrow> thesis", "let ?m = \"nat \\<lceil>t / d\\<rceil>\""], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<le> t \\<Longrightarrow> thesis", "from True"], ["proof (chain)\npicking this:\n  0 \\<le> t", "have \"\\<exists> i. dur xs i > ?m * d\""], ["proof (prove)\nusing this:\n  0 \\<le> t\n\ngoal (1 subgoal):\n 1. \\<exists>i. real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i", "proof (induction ?m arbitrary: t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>0 = nat \\<lceil>t / d\\<rceil>; 0 \\<le> t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i\n 2. \\<And>x t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>x = nat \\<lceil>t / d\\<rceil>;\n                    0 \\<le> t\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i.\n  real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i;\n        Suc x = nat \\<lceil>t / d\\<rceil>; 0 \\<le> t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i", "case 0"], ["proof (state)\nthis:\n  0 = nat \\<lceil>t / d\\<rceil>\n  0 \\<le> t\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>0 = nat \\<lceil>t / d\\<rceil>; 0 \\<le> t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i\n 2. \\<And>x t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>x = nat \\<lceil>t / d\\<rceil>;\n                    0 \\<le> t\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i.\n  real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i;\n        Suc x = nat \\<lceil>t / d\\<rceil>; 0 \\<le> t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i", "with base[OF \\<open>0 < d\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>i. 0 < dur xs i\n  0 = nat \\<lceil>t / d\\<rceil>\n  0 \\<le> t", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>i. 0 < dur xs i\n  0 = nat \\<lceil>t / d\\<rceil>\n  0 \\<le> t\n\ngoal (1 subgoal):\n 1. \\<exists>i. real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i", "by simp"], ["proof (state)\nthis:\n  \\<exists>i. real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i\n\ngoal (1 subgoal):\n 1. \\<And>x t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>x = nat \\<lceil>t / d\\<rceil>;\n                    0 \\<le> t\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i.\n  real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i;\n        Suc x = nat \\<lceil>t / d\\<rceil>; 0 \\<le> t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>x = nat \\<lceil>t / d\\<rceil>;\n                    0 \\<le> t\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i.\n  real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i;\n        Suc x = nat \\<lceil>t / d\\<rceil>; 0 \\<le> t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i", "case (Suc n t)"], ["proof (state)\nthis:\n  \\<lbrakk>n = nat \\<lceil>?t8 / d\\<rceil>; 0 \\<le> ?t8\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i.\n                       real (nat \\<lceil>?t8 / d\\<rceil>) * d < dur xs i\n  Suc n = nat \\<lceil>t / d\\<rceil>\n  0 \\<le> t\n\ngoal (1 subgoal):\n 1. \\<And>x t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>x = nat \\<lceil>t / d\\<rceil>;\n                    0 \\<le> t\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i.\n  real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i;\n        Suc x = nat \\<lceil>t / d\\<rceil>; 0 \\<le> t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i", "let ?t = \"t - d\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>x = nat \\<lceil>t / d\\<rceil>;\n                    0 \\<le> t\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i.\n  real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i;\n        Suc x = nat \\<lceil>t / d\\<rceil>; 0 \\<le> t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i", "proof (cases \"t \\<ge> d\")"], ["proof (state)\ngoal (2 subgoals):\n 1. d \\<le> t \\<Longrightarrow>\n    \\<exists>i. real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i\n 2. \\<not> d \\<le> t \\<Longrightarrow>\n    \\<exists>i. real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i", "case True"], ["proof (state)\nthis:\n  d \\<le> t\n\ngoal (2 subgoals):\n 1. d \\<le> t \\<Longrightarrow>\n    \\<exists>i. real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i\n 2. \\<not> d \\<le> t \\<Longrightarrow>\n    \\<exists>i. real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i", "have \"?t / d = t / d - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t - d) / d = t / d - 1", "(* Generated by sledgehammer *)\n        (* Alternative: by (smt assms(2) diff_divide_distrib divide_self_if) *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (t - d) / d = t / d - 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (t - d) / d = t / d - 1", "have \"t / d + - 1 * ((t + - 1 * d) / d) + - 1 * (d / d) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t / d + - 1 * ((t + - 1 * d) / d) + - 1 * (d / d) = 0", "by (simp add: diff_divide_distrib)"], ["proof (state)\nthis:\n  t / d + - 1 * ((t + - 1 * d) / d) + - 1 * (d / d) = 0\n\ngoal (1 subgoal):\n 1. (t - d) / d = t / d - 1", "then"], ["proof (chain)\npicking this:\n  t / d + - 1 * ((t + - 1 * d) / d) + - 1 * (d / d) = 0", "have \"t / d + - 1 * ((t + - 1 * d) / d) = 1\""], ["proof (prove)\nusing this:\n  t / d + - 1 * ((t + - 1 * d) / d) + - 1 * (d / d) = 0\n\ngoal (1 subgoal):\n 1. t / d + - 1 * ((t + - 1 * d) / d) = 1", "using assms(2)"], ["proof (prove)\nusing this:\n  t / d + - 1 * ((t + - 1 * d) / d) + - 1 * (d / d) = 0\n  0 < d\n\ngoal (1 subgoal):\n 1. t / d + - 1 * ((t + - 1 * d) / d) = 1", "by fastforce"], ["proof (state)\nthis:\n  t / d + - 1 * ((t + - 1 * d) / d) = 1\n\ngoal (1 subgoal):\n 1. (t - d) / d = t / d - 1", "then"], ["proof (chain)\npicking this:\n  t / d + - 1 * ((t + - 1 * d) / d) = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  t / d + - 1 * ((t + - 1 * d) / d) = 1\n\ngoal (1 subgoal):\n 1. (t - d) / d = t / d - 1", "by algebra"], ["proof (state)\nthis:\n  (t - d) / d = t / d - 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (t - d) / d = t / d - 1\n\ngoal (2 subgoals):\n 1. d \\<le> t \\<Longrightarrow>\n    \\<exists>i. real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i\n 2. \\<not> d \\<le> t \\<Longrightarrow>\n    \\<exists>i. real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i", "then"], ["proof (chain)\npicking this:\n  (t - d) / d = t / d - 1", "have \"\\<lceil>?t / d\\<rceil> = \\<lceil>t / d\\<rceil> - 1\""], ["proof (prove)\nusing this:\n  (t - d) / d = t / d - 1\n\ngoal (1 subgoal):\n 1. \\<lceil>(t - d) / d\\<rceil> = \\<lceil>t / d\\<rceil> - 1", "by simp"], ["proof (state)\nthis:\n  \\<lceil>(t - d) / d\\<rceil> = \\<lceil>t / d\\<rceil> - 1\n\ngoal (2 subgoals):\n 1. d \\<le> t \\<Longrightarrow>\n    \\<exists>i. real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i\n 2. \\<not> d \\<le> t \\<Longrightarrow>\n    \\<exists>i. real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i", "with \\<open>Suc n = _\\<close>"], ["proof (chain)\npicking this:\n  Suc n = nat \\<lceil>t / d\\<rceil>\n  \\<lceil>(t - d) / d\\<rceil> = \\<lceil>t / d\\<rceil> - 1", "have \"n = nat \\<lceil>?t / d\\<rceil>\""], ["proof (prove)\nusing this:\n  Suc n = nat \\<lceil>t / d\\<rceil>\n  \\<lceil>(t - d) / d\\<rceil> = \\<lceil>t / d\\<rceil> - 1\n\ngoal (1 subgoal):\n 1. n = nat \\<lceil>(t - d) / d\\<rceil>", "by simp"], ["proof (state)\nthis:\n  n = nat \\<lceil>(t - d) / d\\<rceil>\n\ngoal (2 subgoals):\n 1. d \\<le> t \\<Longrightarrow>\n    \\<exists>i. real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i\n 2. \\<not> d \\<le> t \\<Longrightarrow>\n    \\<exists>i. real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i", "with Suc \\<open>t \\<ge> d\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>n = nat \\<lceil>?t8 / d\\<rceil>; 0 \\<le> ?t8\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i.\n                       real (nat \\<lceil>?t8 / d\\<rceil>) * d < dur xs i\n  Suc n = nat \\<lceil>t / d\\<rceil>\n  0 \\<le> t\n  d \\<le> t\n  n = nat \\<lceil>(t - d) / d\\<rceil>", "obtain i where \"nat \\<lceil>?t / d\\<rceil> * d < dur xs i\""], ["proof (prove)\nusing this:\n  \\<lbrakk>n = nat \\<lceil>?t8 / d\\<rceil>; 0 \\<le> ?t8\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i.\n                       real (nat \\<lceil>?t8 / d\\<rceil>) * d < dur xs i\n  Suc n = nat \\<lceil>t / d\\<rceil>\n  0 \\<le> t\n  d \\<le> t\n  n = nat \\<lceil>(t - d) / d\\<rceil>\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        real (nat \\<lceil>(t - d) / d\\<rceil>) * d\n        < dur xs i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  real (nat \\<lceil>(t - d) / d\\<rceil>) * d < dur xs i\n\ngoal (2 subgoals):\n 1. d \\<le> t \\<Longrightarrow>\n    \\<exists>i. real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i\n 2. \\<not> d \\<le> t \\<Longrightarrow>\n    \\<exists>i. real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i", "from assms"], ["proof (chain)\npicking this:\n  \\<forall>i. \\<exists>j\\<ge>i. d \\<le> dur xs j - dur xs i\n  0 < d", "obtain j where \"dur xs j - dur xs i \\<ge> d\" \"j \\<ge> i\""], ["proof (prove)\nusing this:\n  \\<forall>i. \\<exists>j\\<ge>i. d \\<le> dur xs j - dur xs i\n  0 < d\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>d \\<le> dur xs j - dur xs i; i \\<le> j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  d \\<le> dur xs j - dur xs i\n  i \\<le> j\n\ngoal (2 subgoals):\n 1. d \\<le> t \\<Longrightarrow>\n    \\<exists>i. real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i\n 2. \\<not> d \\<le> t \\<Longrightarrow>\n    \\<exists>i. real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i", "with \\<open>dur xs i > _\\<close>"], ["proof (chain)\npicking this:\n  real (nat \\<lceil>(t - d) / d\\<rceil>) * d < dur xs i\n  d \\<le> dur xs j - dur xs i\n  i \\<le> j", "have \"nat \\<lceil>?t / d\\<rceil> * d + d < dur xs j\""], ["proof (prove)\nusing this:\n  real (nat \\<lceil>(t - d) / d\\<rceil>) * d < dur xs i\n  d \\<le> dur xs j - dur xs i\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. real (nat \\<lceil>(t - d) / d\\<rceil>) * d + d < dur xs j", "by simp"], ["proof (state)\nthis:\n  real (nat \\<lceil>(t - d) / d\\<rceil>) * d + d < dur xs j\n\ngoal (2 subgoals):\n 1. d \\<le> t \\<Longrightarrow>\n    \\<exists>i. real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i\n 2. \\<not> d \\<le> t \\<Longrightarrow>\n    \\<exists>i. real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i", "with True"], ["proof (chain)\npicking this:\n  d \\<le> t\n  real (nat \\<lceil>(t - d) / d\\<rceil>) * d + d < dur xs j", "have \"dur xs j > nat \\<lceil>t / d\\<rceil> * d\""], ["proof (prove)\nusing this:\n  d \\<le> t\n  real (nat \\<lceil>(t - d) / d\\<rceil>) * d + d < dur xs j\n\ngoal (1 subgoal):\n 1. real (nat \\<lceil>t / d\\<rceil>) * d < dur xs j", "by (metis Suc.hyps(2) \\<open>n = nat \\<lceil>(t - d) / d\\<rceil>\\<close> add.commute distrib_left mult.commute \n                  mult.right_neutral of_nat_Suc)"], ["proof (state)\nthis:\n  real (nat \\<lceil>t / d\\<rceil>) * d < dur xs j\n\ngoal (2 subgoals):\n 1. d \\<le> t \\<Longrightarrow>\n    \\<exists>i. real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i\n 2. \\<not> d \\<le> t \\<Longrightarrow>\n    \\<exists>i. real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i", "then"], ["proof (chain)\npicking this:\n  real (nat \\<lceil>t / d\\<rceil>) * d < dur xs j", "show ?thesis"], ["proof (prove)\nusing this:\n  real (nat \\<lceil>t / d\\<rceil>) * d < dur xs j\n\ngoal (1 subgoal):\n 1. \\<exists>i. real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i", "by blast"], ["proof (state)\nthis:\n  \\<exists>i. real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i\n\ngoal (1 subgoal):\n 1. \\<not> d \\<le> t \\<Longrightarrow>\n    \\<exists>i. real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> d \\<le> t \\<Longrightarrow>\n    \\<exists>i. real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i", "case False"], ["proof (state)\nthis:\n  \\<not> d \\<le> t\n\ngoal (1 subgoal):\n 1. \\<not> d \\<le> t \\<Longrightarrow>\n    \\<exists>i. real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i", "with \\<open>t \\<ge> 0\\<close> \\<open>d > 0\\<close>"], ["proof (chain)\npicking this:\n  0 \\<le> t\n  0 < d\n  \\<not> d \\<le> t", "have \"nat \\<lceil>t / d\\<rceil> \\<le> 1\""], ["proof (prove)\nusing this:\n  0 \\<le> t\n  0 < d\n  \\<not> d \\<le> t\n\ngoal (1 subgoal):\n 1. nat \\<lceil>t / d\\<rceil> \\<le> 1", "by simp"], ["proof (state)\nthis:\n  nat \\<lceil>t / d\\<rceil> \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<not> d \\<le> t \\<Longrightarrow>\n    \\<exists>i. real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i", "then"], ["proof (chain)\npicking this:\n  nat \\<lceil>t / d\\<rceil> \\<le> 1", "have \"nat \\<lceil>t / d\\<rceil> * d \\<le> d\""], ["proof (prove)\nusing this:\n  nat \\<lceil>t / d\\<rceil> \\<le> 1\n\ngoal (1 subgoal):\n 1. real (nat \\<lceil>t / d\\<rceil>) * d \\<le> d", "by (metis One_nat_def \\<open>Suc n = _\\<close> Suc_leI add.right_neutral le_antisym mult.commute\n                  mult.right_neutral of_nat_0 of_nat_Suc order_refl zero_less_Suc)"], ["proof (state)\nthis:\n  real (nat \\<lceil>t / d\\<rceil>) * d \\<le> d\n\ngoal (1 subgoal):\n 1. \\<not> d \\<le> t \\<Longrightarrow>\n    \\<exists>i. real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i", "with base2"], ["proof (chain)\npicking this:\n  ?t8 \\<le> d \\<Longrightarrow> \\<exists>i. ?t8 < dur xs i\n  real (nat \\<lceil>t / d\\<rceil>) * d \\<le> d", "show ?thesis"], ["proof (prove)\nusing this:\n  ?t8 \\<le> d \\<Longrightarrow> \\<exists>i. ?t8 < dur xs i\n  real (nat \\<lceil>t / d\\<rceil>) * d \\<le> d\n\ngoal (1 subgoal):\n 1. \\<exists>i. real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i", "by auto"], ["proof (state)\nthis:\n  \\<exists>i. real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>i. real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>i. real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i\n\ngoal (1 subgoal):\n 1. 0 \\<le> t \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<exists>i. real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i", "obtain i where \"dur xs i > ?m * d\""], ["proof (prove)\nusing this:\n  \\<exists>i. real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by atomize_elim"], ["proof (state)\nthis:\n  real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i\n\ngoal (1 subgoal):\n 1. 0 \\<le> t \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i\n\ngoal (1 subgoal):\n 1. 0 \\<le> t \\<Longrightarrow> thesis", "from \\<open>t \\<ge> 0\\<close> \\<open>d > 0\\<close>"], ["proof (chain)\npicking this:\n  0 \\<le> t\n  0 < d", "have \"?m * d \\<ge> t\""], ["proof (prove)\nusing this:\n  0 \\<le> t\n  0 < d\n\ngoal (1 subgoal):\n 1. t \\<le> real (nat \\<lceil>t / d\\<rceil>) * d", "using pos_divide_le_eq real_nat_ceiling_ge"], ["proof (prove)\nusing this:\n  0 \\<le> t\n  0 < d\n  (0::?'a) < ?c \\<Longrightarrow> (?b / ?c \\<le> ?a) = (?b \\<le> ?a * ?c)\n  ?x \\<le> real (nat \\<lceil>?x\\<rceil>)\n\ngoal (1 subgoal):\n 1. t \\<le> real (nat \\<lceil>t / d\\<rceil>) * d", "by blast"], ["proof (state)\nthis:\n  t \\<le> real (nat \\<lceil>t / d\\<rceil>) * d\n\ngoal (1 subgoal):\n 1. 0 \\<le> t \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i\n  t \\<le> real (nat \\<lceil>t / d\\<rceil>) * d", "show ?thesis"], ["proof (prove)\nusing this:\n  real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i\n  t \\<le> real (nat \\<lceil>t / d\\<rceil>) * d\n\ngoal (1 subgoal):\n 1. thesis", "using that[of i]"], ["proof (prove)\nusing this:\n  real (nat \\<lceil>t / d\\<rceil>) * d < dur xs i\n  t \\<le> real (nat \\<lceil>t / d\\<rceil>) * d\n  t < dur xs i \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_reset_mono:\n  assumes \"stream_trans xs\" \"shd xs c1 \\<ge> shd xs c2\" \"stream_all (\\<lambda> u. u \\<in> V) xs\" \"c2 \\<in> \\<X>\"\n  shows \"(holds (\\<lambda> u. u c1 \\<ge> u c2) until holds (\\<lambda> u. u c1 = 0)) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (holds (\\<lambda>u. u c2 \\<le> u c1) until\n     holds (\\<lambda>u. u c1 = (0::'a)))\n     xs", "using assms"], ["proof (prove)\nusing this:\n  stream_trans xs\n  shd xs c2 \\<le> shd xs c1\n  stream_all (\\<lambda>u. u \\<in> V) xs\n  c2 \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. (holds (\\<lambda>u. u c2 \\<le> u c1) until\n     holds (\\<lambda>u. u c1 = (0::'a)))\n     xs", "proof (coinduction arbitrary: xs)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>stream_trans xs; shd xs c2 \\<le> shd xs c1;\n        stream_all (\\<lambda>u. u \\<in> V) xs; c2 \\<in> \\<X>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xsa.\n                             xs = xsa \\<and>\n                             holds (\\<lambda>u. u c1 = (0::'a)) xsa) \\<or>\n                         (\\<exists>xsa.\n                             xs = xsa \\<and>\n                             holds (\\<lambda>u. u c2 \\<le> u c1) xsa \\<and>\n                             ((\\<exists>xs.\n                                  stl xsa = xs \\<and>\n                                  stream_trans xs \\<and>\n                                  shd xs c2 \\<le> shd xs c1 \\<and>\n                                  stream_all (\\<lambda>u. u \\<in> V)\n                                   xs \\<and>\n                                  c2 \\<in> \\<X>) \\<or>\n                              (holds (\\<lambda>u. u c2 \\<le> u c1) until\n                               holds (\\<lambda>u. u c1 = (0::'a)))\n                               (stl xsa)))", "case prems: (UNTIL xs)"], ["proof (state)\nthis:\n  stream_trans xs\n  shd xs c2 \\<le> shd xs c1\n  stream_all (\\<lambda>u. u \\<in> V) xs\n  c2 \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>stream_trans xs; shd xs c2 \\<le> shd xs c1;\n        stream_all (\\<lambda>u. u \\<in> V) xs; c2 \\<in> \\<X>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xsa.\n                             xs = xsa \\<and>\n                             holds (\\<lambda>u. u c1 = (0::'a)) xsa) \\<or>\n                         (\\<exists>xsa.\n                             xs = xsa \\<and>\n                             holds (\\<lambda>u. u c2 \\<le> u c1) xsa \\<and>\n                             ((\\<exists>xs.\n                                  stl xsa = xs \\<and>\n                                  stream_trans xs \\<and>\n                                  shd xs c2 \\<le> shd xs c1 \\<and>\n                                  stream_all (\\<lambda>u. u \\<in> V)\n                                   xs \\<and>\n                                  c2 \\<in> \\<X>) \\<or>\n                              (holds (\\<lambda>u. u c2 \\<le> u c1) until\n                               holds (\\<lambda>u. u c1 = (0::'a)))\n                               (stl xsa)))", "let ?xs = \"stl xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>stream_trans xs; shd xs c2 \\<le> shd xs c1;\n        stream_all (\\<lambda>u. u \\<in> V) xs; c2 \\<in> \\<X>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xsa.\n                             xs = xsa \\<and>\n                             holds (\\<lambda>u. u c1 = (0::'a)) xsa) \\<or>\n                         (\\<exists>xsa.\n                             xs = xsa \\<and>\n                             holds (\\<lambda>u. u c2 \\<le> u c1) xsa \\<and>\n                             ((\\<exists>xs.\n                                  stl xsa = xs \\<and>\n                                  stream_trans xs \\<and>\n                                  shd xs c2 \\<le> shd xs c1 \\<and>\n                                  stream_all (\\<lambda>u. u \\<in> V)\n                                   xs \\<and>\n                                  c2 \\<in> \\<X>) \\<or>\n                              (holds (\\<lambda>u. u c2 \\<le> u c1) until\n                               holds (\\<lambda>u. u c1 = (0::'a)))\n                               (stl xsa)))", "let ?x = \"shd xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>stream_trans xs; shd xs c2 \\<le> shd xs c1;\n        stream_all (\\<lambda>u. u \\<in> V) xs; c2 \\<in> \\<X>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xsa.\n                             xs = xsa \\<and>\n                             holds (\\<lambda>u. u c1 = (0::'a)) xsa) \\<or>\n                         (\\<exists>xsa.\n                             xs = xsa \\<and>\n                             holds (\\<lambda>u. u c2 \\<le> u c1) xsa \\<and>\n                             ((\\<exists>xs.\n                                  stl xsa = xs \\<and>\n                                  stream_trans xs \\<and>\n                                  shd xs c2 \\<le> shd xs c1 \\<and>\n                                  stream_all (\\<lambda>u. u \\<in> V)\n                                   xs \\<and>\n                                  c2 \\<in> \\<X>) \\<or>\n                              (holds (\\<lambda>u. u c2 \\<le> u c1) until\n                               holds (\\<lambda>u. u c1 = (0::'a)))\n                               (stl xsa)))", "let ?y = \"shd ?xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>stream_trans xs; shd xs c2 \\<le> shd xs c1;\n        stream_all (\\<lambda>u. u \\<in> V) xs; c2 \\<in> \\<X>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xsa.\n                             xs = xsa \\<and>\n                             holds (\\<lambda>u. u c1 = (0::'a)) xsa) \\<or>\n                         (\\<exists>xsa.\n                             xs = xsa \\<and>\n                             holds (\\<lambda>u. u c2 \\<le> u c1) xsa \\<and>\n                             ((\\<exists>xs.\n                                  stl xsa = xs \\<and>\n                                  stream_trans xs \\<and>\n                                  shd xs c2 \\<le> shd xs c1 \\<and>\n                                  stream_all (\\<lambda>u. u \\<in> V)\n                                   xs \\<and>\n                                  c2 \\<in> \\<X>) \\<or>\n                              (holds (\\<lambda>u. u c2 \\<le> u c1) until\n                               holds (\\<lambda>u. u c1 = (0::'a)))\n                               (stl xsa)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        xs = xs \\<and> holds (\\<lambda>u. u c1 = (0::'a)) xs) \\<or>\n    (\\<exists>xs.\n        xs = xs \\<and>\n        holds (\\<lambda>u. u c2 \\<le> u c1) xs \\<and>\n        ((\\<exists>xsa.\n             stl xs = xsa \\<and>\n             stream_trans xsa \\<and>\n             shd xsa c2 \\<le> shd xsa c1 \\<and>\n             stream_all (\\<lambda>u. u \\<in> V) xsa \\<and>\n             c2 \\<in> \\<X>) \\<or>\n         (holds (\\<lambda>u. u c2 \\<le> u c1) until\n          holds (\\<lambda>u. u c1 = (0::'a)))\n          (stl xs)))", "proof (cases \"?x c1 = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. shd xs c1 = (0::'a) \\<Longrightarrow>\n    (\\<exists>xs.\n        xs = xs \\<and> holds (\\<lambda>u. u c1 = (0::'a)) xs) \\<or>\n    (\\<exists>xs.\n        xs = xs \\<and>\n        holds (\\<lambda>u. u c2 \\<le> u c1) xs \\<and>\n        ((\\<exists>xsa.\n             stl xs = xsa \\<and>\n             stream_trans xsa \\<and>\n             shd xsa c2 \\<le> shd xsa c1 \\<and>\n             stream_all (\\<lambda>u. u \\<in> V) xsa \\<and>\n             c2 \\<in> \\<X>) \\<or>\n         (holds (\\<lambda>u. u c2 \\<le> u c1) until\n          holds (\\<lambda>u. u c1 = (0::'a)))\n          (stl xs)))\n 2. shd xs c1 \\<noteq> (0::'a) \\<Longrightarrow>\n    (\\<exists>xs.\n        xs = xs \\<and> holds (\\<lambda>u. u c1 = (0::'a)) xs) \\<or>\n    (\\<exists>xs.\n        xs = xs \\<and>\n        holds (\\<lambda>u. u c2 \\<le> u c1) xs \\<and>\n        ((\\<exists>xsa.\n             stl xs = xsa \\<and>\n             stream_trans xsa \\<and>\n             shd xsa c2 \\<le> shd xsa c1 \\<and>\n             stream_all (\\<lambda>u. u \\<in> V) xsa \\<and>\n             c2 \\<in> \\<X>) \\<or>\n         (holds (\\<lambda>u. u c2 \\<le> u c1) until\n          holds (\\<lambda>u. u c1 = (0::'a)))\n          (stl xs)))", "case False"], ["proof (state)\nthis:\n  shd xs c1 \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. shd xs c1 = (0::'a) \\<Longrightarrow>\n    (\\<exists>xs.\n        xs = xs \\<and> holds (\\<lambda>u. u c1 = (0::'a)) xs) \\<or>\n    (\\<exists>xs.\n        xs = xs \\<and>\n        holds (\\<lambda>u. u c2 \\<le> u c1) xs \\<and>\n        ((\\<exists>xsa.\n             stl xs = xsa \\<and>\n             stream_trans xsa \\<and>\n             shd xsa c2 \\<le> shd xsa c1 \\<and>\n             stream_all (\\<lambda>u. u \\<in> V) xsa \\<and>\n             c2 \\<in> \\<X>) \\<or>\n         (holds (\\<lambda>u. u c2 \\<le> u c1) until\n          holds (\\<lambda>u. u c1 = (0::'a)))\n          (stl xs)))\n 2. shd xs c1 \\<noteq> (0::'a) \\<Longrightarrow>\n    (\\<exists>xs.\n        xs = xs \\<and> holds (\\<lambda>u. u c1 = (0::'a)) xs) \\<or>\n    (\\<exists>xs.\n        xs = xs \\<and>\n        holds (\\<lambda>u. u c2 \\<le> u c1) xs \\<and>\n        ((\\<exists>xsa.\n             stl xs = xsa \\<and>\n             stream_trans xsa \\<and>\n             shd xsa c2 \\<le> shd xsa c1 \\<and>\n             stream_all (\\<lambda>u. u \\<in> V) xsa \\<and>\n             c2 \\<in> \\<X>) \\<or>\n         (holds (\\<lambda>u. u c2 \\<le> u c1) until\n          holds (\\<lambda>u. u c1 = (0::'a)))\n          (stl xs)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        xs = xs \\<and> holds (\\<lambda>u. u c1 = (0::'a)) xs) \\<or>\n    (\\<exists>xs.\n        xs = xs \\<and>\n        holds (\\<lambda>u. u c2 \\<le> u c1) xs \\<and>\n        ((\\<exists>xsa.\n             stl xs = xsa \\<and>\n             stream_trans xsa \\<and>\n             shd xsa c2 \\<le> shd xsa c1 \\<and>\n             stream_all (\\<lambda>u. u \\<in> V) xsa \\<and>\n             c2 \\<in> \\<X>) \\<or>\n         (holds (\\<lambda>u. u c2 \\<le> u c1) until\n          holds (\\<lambda>u. u c1 = (0::'a)))\n          (stl xs)))", "proof (cases \"?y c1 = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. shd (stl xs) c1 = (0::'a) \\<Longrightarrow>\n    (\\<exists>xs.\n        xs = xs \\<and> holds (\\<lambda>u. u c1 = (0::'a)) xs) \\<or>\n    (\\<exists>xs.\n        xs = xs \\<and>\n        holds (\\<lambda>u. u c2 \\<le> u c1) xs \\<and>\n        ((\\<exists>xsa.\n             stl xs = xsa \\<and>\n             stream_trans xsa \\<and>\n             shd xsa c2 \\<le> shd xsa c1 \\<and>\n             stream_all (\\<lambda>u. u \\<in> V) xsa \\<and>\n             c2 \\<in> \\<X>) \\<or>\n         (holds (\\<lambda>u. u c2 \\<le> u c1) until\n          holds (\\<lambda>u. u c1 = (0::'a)))\n          (stl xs)))\n 2. shd (stl xs) c1 \\<noteq> (0::'a) \\<Longrightarrow>\n    (\\<exists>xs.\n        xs = xs \\<and> holds (\\<lambda>u. u c1 = (0::'a)) xs) \\<or>\n    (\\<exists>xs.\n        xs = xs \\<and>\n        holds (\\<lambda>u. u c2 \\<le> u c1) xs \\<and>\n        ((\\<exists>xsa.\n             stl xs = xsa \\<and>\n             stream_trans xsa \\<and>\n             shd xsa c2 \\<le> shd xsa c1 \\<and>\n             stream_all (\\<lambda>u. u \\<in> V) xsa \\<and>\n             c2 \\<in> \\<X>) \\<or>\n         (holds (\\<lambda>u. u c2 \\<le> u c1) until\n          holds (\\<lambda>u. u c1 = (0::'a)))\n          (stl xs)))", "case False"], ["proof (state)\nthis:\n  shd (stl xs) c1 \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. shd (stl xs) c1 = (0::'a) \\<Longrightarrow>\n    (\\<exists>xs.\n        xs = xs \\<and> holds (\\<lambda>u. u c1 = (0::'a)) xs) \\<or>\n    (\\<exists>xs.\n        xs = xs \\<and>\n        holds (\\<lambda>u. u c2 \\<le> u c1) xs \\<and>\n        ((\\<exists>xsa.\n             stl xs = xsa \\<and>\n             stream_trans xsa \\<and>\n             shd xsa c2 \\<le> shd xsa c1 \\<and>\n             stream_all (\\<lambda>u. u \\<in> V) xsa \\<and>\n             c2 \\<in> \\<X>) \\<or>\n         (holds (\\<lambda>u. u c2 \\<le> u c1) until\n          holds (\\<lambda>u. u c1 = (0::'a)))\n          (stl xs)))\n 2. shd (stl xs) c1 \\<noteq> (0::'a) \\<Longrightarrow>\n    (\\<exists>xs.\n        xs = xs \\<and> holds (\\<lambda>u. u c1 = (0::'a)) xs) \\<or>\n    (\\<exists>xs.\n        xs = xs \\<and>\n        holds (\\<lambda>u. u c2 \\<le> u c1) xs \\<and>\n        ((\\<exists>xsa.\n             stl xs = xsa \\<and>\n             stream_trans xsa \\<and>\n             shd xsa c2 \\<le> shd xsa c1 \\<and>\n             stream_all (\\<lambda>u. u \\<in> V) xsa \\<and>\n             c2 \\<in> \\<X>) \\<or>\n         (holds (\\<lambda>u. u c2 \\<le> u c1) until\n          holds (\\<lambda>u. u c1 = (0::'a)))\n          (stl xs)))", "from prems"], ["proof (chain)\npicking this:\n  stream_trans xs\n  shd xs c2 \\<le> shd xs c1\n  stream_all (\\<lambda>u. u \\<in> V) xs\n  c2 \\<in> \\<X>", "have \"trans ?x ?y\""], ["proof (prove)\nusing this:\n  stream_trans xs\n  shd xs c2 \\<le> shd xs c1\n  stream_all (\\<lambda>u. u \\<in> V) xs\n  c2 \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. local.trans (shd xs) (shd (stl xs))", "by (intro pairwise_pairD[of trans])"], ["proof (state)\nthis:\n  local.trans (shd xs) (shd (stl xs))\n\ngoal (2 subgoals):\n 1. shd (stl xs) c1 = (0::'a) \\<Longrightarrow>\n    (\\<exists>xs.\n        xs = xs \\<and> holds (\\<lambda>u. u c1 = (0::'a)) xs) \\<or>\n    (\\<exists>xs.\n        xs = xs \\<and>\n        holds (\\<lambda>u. u c2 \\<le> u c1) xs \\<and>\n        ((\\<exists>xsa.\n             stl xs = xsa \\<and>\n             stream_trans xsa \\<and>\n             shd xsa c2 \\<le> shd xsa c1 \\<and>\n             stream_all (\\<lambda>u. u \\<in> V) xsa \\<and>\n             c2 \\<in> \\<X>) \\<or>\n         (holds (\\<lambda>u. u c2 \\<le> u c1) until\n          holds (\\<lambda>u. u c1 = (0::'a)))\n          (stl xs)))\n 2. shd (stl xs) c1 \\<noteq> (0::'a) \\<Longrightarrow>\n    (\\<exists>xs.\n        xs = xs \\<and> holds (\\<lambda>u. u c1 = (0::'a)) xs) \\<or>\n    (\\<exists>xs.\n        xs = xs \\<and>\n        holds (\\<lambda>u. u c2 \\<le> u c1) xs \\<and>\n        ((\\<exists>xsa.\n             stl xs = xsa \\<and>\n             stream_trans xsa \\<and>\n             shd xsa c2 \\<le> shd xsa c1 \\<and>\n             stream_all (\\<lambda>u. u \\<in> V) xsa \\<and>\n             c2 \\<in> \\<X>) \\<or>\n         (holds (\\<lambda>u. u c2 \\<le> u c1) until\n          holds (\\<lambda>u. u c1 = (0::'a)))\n          (stl xs)))", "then"], ["proof (chain)\npicking this:\n  local.trans (shd xs) (shd (stl xs))", "have \"?y c1 \\<ge> ?y c2\""], ["proof (prove)\nusing this:\n  local.trans (shd xs) (shd (stl xs))\n\ngoal (1 subgoal):\n 1. shd (stl xs) c2 \\<le> shd (stl xs) c1", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>(0::'a) \\<le> t; shd (stl xs) = shd xs \\<oplus> t\\<rbrakk>\n       \\<Longrightarrow> shd (stl xs) c2 \\<le> shd (stl xs) c1\n 2. \\<And>l.\n       \\<lbrakk>set l \\<subseteq> \\<X>;\n        shd (stl xs) = [l\\<rightarrow>(0::'a)]shd xs\\<rbrakk>\n       \\<Longrightarrow> shd (stl xs) c2 \\<le> shd (stl xs) c1\n 3. shd xs = shd (stl xs) \\<Longrightarrow>\n    shd (stl xs) c2 \\<le> shd (stl xs) c1", "case A: (reset t)"], ["proof (state)\nthis:\n  set t \\<subseteq> \\<X>\n  shd (stl xs) = [t\\<rightarrow>(0::'a)]shd xs\n\ngoal (3 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>(0::'a) \\<le> t; shd (stl xs) = shd xs \\<oplus> t\\<rbrakk>\n       \\<Longrightarrow> shd (stl xs) c2 \\<le> shd (stl xs) c1\n 2. \\<And>l.\n       \\<lbrakk>set l \\<subseteq> \\<X>;\n        shd (stl xs) = [l\\<rightarrow>(0::'a)]shd xs\\<rbrakk>\n       \\<Longrightarrow> shd (stl xs) c2 \\<le> shd (stl xs) c1\n 3. shd xs = shd (stl xs) \\<Longrightarrow>\n    shd (stl xs) c2 \\<le> shd (stl xs) c1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. shd (stl xs) c2 \\<le> shd (stl xs) c1", "proof (cases \"c1 \\<in> set t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c1 \\<in> set t \\<Longrightarrow> shd (stl xs) c2 \\<le> shd (stl xs) c1\n 2. c1 \\<notin> set t \\<Longrightarrow>\n    shd (stl xs) c2 \\<le> shd (stl xs) c1", "case True"], ["proof (state)\nthis:\n  c1 \\<in> set t\n\ngoal (2 subgoals):\n 1. c1 \\<in> set t \\<Longrightarrow> shd (stl xs) c2 \\<le> shd (stl xs) c1\n 2. c1 \\<notin> set t \\<Longrightarrow>\n    shd (stl xs) c2 \\<le> shd (stl xs) c1", "with A False"], ["proof (chain)\npicking this:\n  set t \\<subseteq> \\<X>\n  shd (stl xs) = [t\\<rightarrow>(0::'a)]shd xs\n  shd (stl xs) c1 \\<noteq> (0::'a)\n  c1 \\<in> set t", "show ?thesis"], ["proof (prove)\nusing this:\n  set t \\<subseteq> \\<X>\n  shd (stl xs) = [t\\<rightarrow>(0::'a)]shd xs\n  shd (stl xs) c1 \\<noteq> (0::'a)\n  c1 \\<in> set t\n\ngoal (1 subgoal):\n 1. shd (stl xs) c2 \\<le> shd (stl xs) c1", "by auto"], ["proof (state)\nthis:\n  shd (stl xs) c2 \\<le> shd (stl xs) c1\n\ngoal (1 subgoal):\n 1. c1 \\<notin> set t \\<Longrightarrow>\n    shd (stl xs) c2 \\<le> shd (stl xs) c1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c1 \\<notin> set t \\<Longrightarrow>\n    shd (stl xs) c2 \\<le> shd (stl xs) c1", "case False"], ["proof (state)\nthis:\n  c1 \\<notin> set t\n\ngoal (1 subgoal):\n 1. c1 \\<notin> set t \\<Longrightarrow>\n    shd (stl xs) c2 \\<le> shd (stl xs) c1", "from prems"], ["proof (chain)\npicking this:\n  stream_trans xs\n  shd xs c2 \\<le> shd xs c1\n  stream_all (\\<lambda>u. u \\<in> V) xs\n  c2 \\<in> \\<X>", "have \"?x c2 \\<ge> 0\""], ["proof (prove)\nusing this:\n  stream_trans xs\n  shd xs c2 \\<le> shd xs c1\n  stream_all (\\<lambda>u. u \\<in> V) xs\n  c2 \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> shd xs c2", "by (auto simp: V_def)"], ["proof (state)\nthis:\n  (0::'a) \\<le> shd xs c2\n\ngoal (1 subgoal):\n 1. c1 \\<notin> set t \\<Longrightarrow>\n    shd (stl xs) c2 \\<le> shd (stl xs) c1", "with A"], ["proof (chain)\npicking this:\n  set t \\<subseteq> \\<X>\n  shd (stl xs) = [t\\<rightarrow>(0::'a)]shd xs\n  (0::'a) \\<le> shd xs c2", "have \"?y c2 \\<le> ?x c2\""], ["proof (prove)\nusing this:\n  set t \\<subseteq> \\<X>\n  shd (stl xs) = [t\\<rightarrow>(0::'a)]shd xs\n  (0::'a) \\<le> shd xs c2\n\ngoal (1 subgoal):\n 1. shd (stl xs) c2 \\<le> shd xs c2", "by (cases \"c2 \\<in> set t\") auto"], ["proof (state)\nthis:\n  shd (stl xs) c2 \\<le> shd xs c2\n\ngoal (1 subgoal):\n 1. c1 \\<notin> set t \\<Longrightarrow>\n    shd (stl xs) c2 \\<le> shd (stl xs) c1", "with A False \\<open>?x c1 \\<ge> ?x c2\\<close>"], ["proof (chain)\npicking this:\n  set t \\<subseteq> \\<X>\n  shd (stl xs) = [t\\<rightarrow>(0::'a)]shd xs\n  c1 \\<notin> set t\n  shd xs c2 \\<le> shd xs c1\n  shd (stl xs) c2 \\<le> shd xs c2", "show ?thesis"], ["proof (prove)\nusing this:\n  set t \\<subseteq> \\<X>\n  shd (stl xs) = [t\\<rightarrow>(0::'a)]shd xs\n  c1 \\<notin> set t\n  shd xs c2 \\<le> shd xs c1\n  shd (stl xs) c2 \\<le> shd xs c2\n\ngoal (1 subgoal):\n 1. shd (stl xs) c2 \\<le> shd (stl xs) c1", "by auto"], ["proof (state)\nthis:\n  shd (stl xs) c2 \\<le> shd (stl xs) c1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  shd (stl xs) c2 \\<le> shd (stl xs) c1\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>(0::'a) \\<le> t; shd (stl xs) = shd xs \\<oplus> t\\<rbrakk>\n       \\<Longrightarrow> shd (stl xs) c2 \\<le> shd (stl xs) c1\n 2. shd xs = shd (stl xs) \\<Longrightarrow>\n    shd (stl xs) c2 \\<le> shd (stl xs) c1", "qed (use prems in \\<open>auto simp: cval_add_def\\<close>)"], ["proof (state)\nthis:\n  shd (stl xs) c2 \\<le> shd (stl xs) c1\n\ngoal (2 subgoals):\n 1. shd (stl xs) c1 = (0::'a) \\<Longrightarrow>\n    (\\<exists>xs.\n        xs = xs \\<and> holds (\\<lambda>u. u c1 = (0::'a)) xs) \\<or>\n    (\\<exists>xs.\n        xs = xs \\<and>\n        holds (\\<lambda>u. u c2 \\<le> u c1) xs \\<and>\n        ((\\<exists>xsa.\n             stl xs = xsa \\<and>\n             stream_trans xsa \\<and>\n             shd xsa c2 \\<le> shd xsa c1 \\<and>\n             stream_all (\\<lambda>u. u \\<in> V) xsa \\<and>\n             c2 \\<in> \\<X>) \\<or>\n         (holds (\\<lambda>u. u c2 \\<le> u c1) until\n          holds (\\<lambda>u. u c1 = (0::'a)))\n          (stl xs)))\n 2. shd (stl xs) c1 \\<noteq> (0::'a) \\<Longrightarrow>\n    (\\<exists>xs.\n        xs = xs \\<and> holds (\\<lambda>u. u c1 = (0::'a)) xs) \\<or>\n    (\\<exists>xs.\n        xs = xs \\<and>\n        holds (\\<lambda>u. u c2 \\<le> u c1) xs \\<and>\n        ((\\<exists>xsa.\n             stl xs = xsa \\<and>\n             stream_trans xsa \\<and>\n             shd xsa c2 \\<le> shd xsa c1 \\<and>\n             stream_all (\\<lambda>u. u \\<in> V) xsa \\<and>\n             c2 \\<in> \\<X>) \\<or>\n         (holds (\\<lambda>u. u c2 \\<le> u c1) until\n          holds (\\<lambda>u. u c1 = (0::'a)))\n          (stl xs)))", "moreover"], ["proof (state)\nthis:\n  shd (stl xs) c2 \\<le> shd (stl xs) c1\n\ngoal (2 subgoals):\n 1. shd (stl xs) c1 = (0::'a) \\<Longrightarrow>\n    (\\<exists>xs.\n        xs = xs \\<and> holds (\\<lambda>u. u c1 = (0::'a)) xs) \\<or>\n    (\\<exists>xs.\n        xs = xs \\<and>\n        holds (\\<lambda>u. u c2 \\<le> u c1) xs \\<and>\n        ((\\<exists>xsa.\n             stl xs = xsa \\<and>\n             stream_trans xsa \\<and>\n             shd xsa c2 \\<le> shd xsa c1 \\<and>\n             stream_all (\\<lambda>u. u \\<in> V) xsa \\<and>\n             c2 \\<in> \\<X>) \\<or>\n         (holds (\\<lambda>u. u c2 \\<le> u c1) until\n          holds (\\<lambda>u. u c1 = (0::'a)))\n          (stl xs)))\n 2. shd (stl xs) c1 \\<noteq> (0::'a) \\<Longrightarrow>\n    (\\<exists>xs.\n        xs = xs \\<and> holds (\\<lambda>u. u c1 = (0::'a)) xs) \\<or>\n    (\\<exists>xs.\n        xs = xs \\<and>\n        holds (\\<lambda>u. u c2 \\<le> u c1) xs \\<and>\n        ((\\<exists>xsa.\n             stl xs = xsa \\<and>\n             stream_trans xsa \\<and>\n             shd xsa c2 \\<le> shd xsa c1 \\<and>\n             stream_all (\\<lambda>u. u \\<in> V) xsa \\<and>\n             c2 \\<in> \\<X>) \\<or>\n         (holds (\\<lambda>u. u c2 \\<le> u c1) until\n          holds (\\<lambda>u. u c1 = (0::'a)))\n          (stl xs)))", "from prems"], ["proof (chain)\npicking this:\n  stream_trans xs\n  shd xs c2 \\<le> shd xs c1\n  stream_all (\\<lambda>u. u \\<in> V) xs\n  c2 \\<in> \\<X>", "have \"stream_trans ?xs\" \"stream_all (\\<lambda> u. u \\<in> V) ?xs\""], ["proof (prove)\nusing this:\n  stream_trans xs\n  shd xs c2 \\<le> shd xs c1\n  stream_all (\\<lambda>u. u \\<in> V) xs\n  c2 \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. stream_trans (stl xs) &&& stream_all (\\<lambda>u. u \\<in> V) (stl xs)", "by (auto intro: pairwise_stlD stl_sset)"], ["proof (state)\nthis:\n  stream_trans (stl xs)\n  stream_all (\\<lambda>u. u \\<in> V) (stl xs)\n\ngoal (2 subgoals):\n 1. shd (stl xs) c1 = (0::'a) \\<Longrightarrow>\n    (\\<exists>xs.\n        xs = xs \\<and> holds (\\<lambda>u. u c1 = (0::'a)) xs) \\<or>\n    (\\<exists>xs.\n        xs = xs \\<and>\n        holds (\\<lambda>u. u c2 \\<le> u c1) xs \\<and>\n        ((\\<exists>xsa.\n             stl xs = xsa \\<and>\n             stream_trans xsa \\<and>\n             shd xsa c2 \\<le> shd xsa c1 \\<and>\n             stream_all (\\<lambda>u. u \\<in> V) xsa \\<and>\n             c2 \\<in> \\<X>) \\<or>\n         (holds (\\<lambda>u. u c2 \\<le> u c1) until\n          holds (\\<lambda>u. u c1 = (0::'a)))\n          (stl xs)))\n 2. shd (stl xs) c1 \\<noteq> (0::'a) \\<Longrightarrow>\n    (\\<exists>xs.\n        xs = xs \\<and> holds (\\<lambda>u. u c1 = (0::'a)) xs) \\<or>\n    (\\<exists>xs.\n        xs = xs \\<and>\n        holds (\\<lambda>u. u c2 \\<le> u c1) xs \\<and>\n        ((\\<exists>xsa.\n             stl xs = xsa \\<and>\n             stream_trans xsa \\<and>\n             shd xsa c2 \\<le> shd xsa c1 \\<and>\n             stream_all (\\<lambda>u. u \\<in> V) xsa \\<and>\n             c2 \\<in> \\<X>) \\<or>\n         (holds (\\<lambda>u. u c2 \\<le> u c1) until\n          holds (\\<lambda>u. u c1 = (0::'a)))\n          (stl xs)))", "ultimately"], ["proof (chain)\npicking this:\n  shd (stl xs) c2 \\<le> shd (stl xs) c1\n  stream_trans (stl xs)\n  stream_all (\\<lambda>u. u \\<in> V) (stl xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  shd (stl xs) c2 \\<le> shd (stl xs) c1\n  stream_trans (stl xs)\n  stream_all (\\<lambda>u. u \\<in> V) (stl xs)\n\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        xs = xs \\<and> holds (\\<lambda>u. u c1 = (0::'a)) xs) \\<or>\n    (\\<exists>xs.\n        xs = xs \\<and>\n        holds (\\<lambda>u. u c2 \\<le> u c1) xs \\<and>\n        ((\\<exists>xsa.\n             stl xs = xsa \\<and>\n             stream_trans xsa \\<and>\n             shd xsa c2 \\<le> shd xsa c1 \\<and>\n             stream_all (\\<lambda>u. u \\<in> V) xsa \\<and>\n             c2 \\<in> \\<X>) \\<or>\n         (holds (\\<lambda>u. u c2 \\<le> u c1) until\n          holds (\\<lambda>u. u c1 = (0::'a)))\n          (stl xs)))", "using prems"], ["proof (prove)\nusing this:\n  shd (stl xs) c2 \\<le> shd (stl xs) c1\n  stream_trans (stl xs)\n  stream_all (\\<lambda>u. u \\<in> V) (stl xs)\n  stream_trans xs\n  shd xs c2 \\<le> shd xs c1\n  stream_all (\\<lambda>u. u \\<in> V) xs\n  c2 \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        xs = xs \\<and> holds (\\<lambda>u. u c1 = (0::'a)) xs) \\<or>\n    (\\<exists>xs.\n        xs = xs \\<and>\n        holds (\\<lambda>u. u c2 \\<le> u c1) xs \\<and>\n        ((\\<exists>xsa.\n             stl xs = xsa \\<and>\n             stream_trans xsa \\<and>\n             shd xsa c2 \\<le> shd xsa c1 \\<and>\n             stream_all (\\<lambda>u. u \\<in> V) xsa \\<and>\n             c2 \\<in> \\<X>) \\<or>\n         (holds (\\<lambda>u. u c2 \\<le> u c1) until\n          holds (\\<lambda>u. u c1 = (0::'a)))\n          (stl xs)))", "by auto"], ["proof (state)\nthis:\n  (\\<exists>xs. xs = xs \\<and> holds (\\<lambda>u. u c1 = (0::'a)) xs) \\<or>\n  (\\<exists>xs.\n      xs = xs \\<and>\n      holds (\\<lambda>u. u c2 \\<le> u c1) xs \\<and>\n      ((\\<exists>xsa.\n           stl xs = xsa \\<and>\n           stream_trans xsa \\<and>\n           shd xsa c2 \\<le> shd xsa c1 \\<and>\n           stream_all (\\<lambda>u. u \\<in> V) xsa \\<and>\n           c2 \\<in> \\<X>) \\<or>\n       (holds (\\<lambda>u. u c2 \\<le> u c1) until\n        holds (\\<lambda>u. u c1 = (0::'a)))\n        (stl xs)))\n\ngoal (1 subgoal):\n 1. shd (stl xs) c1 = (0::'a) \\<Longrightarrow>\n    (\\<exists>xs.\n        xs = xs \\<and> holds (\\<lambda>u. u c1 = (0::'a)) xs) \\<or>\n    (\\<exists>xs.\n        xs = xs \\<and>\n        holds (\\<lambda>u. u c2 \\<le> u c1) xs \\<and>\n        ((\\<exists>xsa.\n             stl xs = xsa \\<and>\n             stream_trans xsa \\<and>\n             shd xsa c2 \\<le> shd xsa c1 \\<and>\n             stream_all (\\<lambda>u. u \\<in> V) xsa \\<and>\n             c2 \\<in> \\<X>) \\<or>\n         (holds (\\<lambda>u. u c2 \\<le> u c1) until\n          holds (\\<lambda>u. u c1 = (0::'a)))\n          (stl xs)))", "qed (use prems in \\<open>auto intro: UNTIL.base\\<close>)"], ["proof (state)\nthis:\n  (\\<exists>xs. xs = xs \\<and> holds (\\<lambda>u. u c1 = (0::'a)) xs) \\<or>\n  (\\<exists>xs.\n      xs = xs \\<and>\n      holds (\\<lambda>u. u c2 \\<le> u c1) xs \\<and>\n      ((\\<exists>xsa.\n           stl xs = xsa \\<and>\n           stream_trans xsa \\<and>\n           shd xsa c2 \\<le> shd xsa c1 \\<and>\n           stream_all (\\<lambda>u. u \\<in> V) xsa \\<and>\n           c2 \\<in> \\<X>) \\<or>\n       (holds (\\<lambda>u. u c2 \\<le> u c1) until\n        holds (\\<lambda>u. u c1 = (0::'a)))\n        (stl xs)))\n\ngoal (1 subgoal):\n 1. shd xs c1 = (0::'a) \\<Longrightarrow>\n    (\\<exists>xs.\n        xs = xs \\<and> holds (\\<lambda>u. u c1 = (0::'a)) xs) \\<or>\n    (\\<exists>xs.\n        xs = xs \\<and>\n        holds (\\<lambda>u. u c2 \\<le> u c1) xs \\<and>\n        ((\\<exists>xsa.\n             stl xs = xsa \\<and>\n             stream_trans xsa \\<and>\n             shd xsa c2 \\<le> shd xsa c1 \\<and>\n             stream_all (\\<lambda>u. u \\<in> V) xsa \\<and>\n             c2 \\<in> \\<X>) \\<or>\n         (holds (\\<lambda>u. u c2 \\<le> u c1) until\n          holds (\\<lambda>u. u c1 = (0::'a)))\n          (stl xs)))", "qed auto"], ["proof (state)\nthis:\n  (\\<exists>xs. xs = xs \\<and> holds (\\<lambda>u. u c1 = (0::'a)) xs) \\<or>\n  (\\<exists>xs.\n      xs = xs \\<and>\n      holds (\\<lambda>u. u c2 \\<le> u c1) xs \\<and>\n      ((\\<exists>xsa.\n           stl xs = xsa \\<and>\n           stream_trans xsa \\<and>\n           shd xsa c2 \\<le> shd xsa c1 \\<and>\n           stream_all (\\<lambda>u. u \\<in> V) xsa \\<and>\n           c2 \\<in> \\<X>) \\<or>\n       (holds (\\<lambda>u. u c2 \\<le> u c1) until\n        holds (\\<lambda>u. u c1 = (0::'a)))\n        (stl xs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<R>_divergent_divergent_aux:\n  fixes xs :: \"('c, t) cval stream\"\n  assumes \"stream_trans xs\" \"stream_all (\\<lambda> u. u \\<in> V) xs\"\n          \"(xs !! i) c1 = 0\" \"\\<exists> k > i. k \\<le> j \\<and> (xs !! k) c2 = 0\"\n          \"\\<forall> k > i. k \\<le> j \\<longrightarrow> (xs !! k) c1 \\<noteq> 0\"\n          \"c1 \\<in> \\<X>\" \"c2 \\<in> \\<X>\"\n  shows \"(xs !! j) c1 \\<ge> (xs !! j) c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs !! j) c2 \\<le> (xs !! j) c1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (xs !! j) c2 \\<le> (xs !! j) c1", "from assms"], ["proof (chain)\npicking this:\n  stream_trans xs\n  stream_all (\\<lambda>u. u \\<in> V) xs\n  (xs !! i) c1 = 0\n  \\<exists>k>i. k \\<le> j \\<and> (xs !! k) c2 = 0\n  \\<forall>k>i. k \\<le> j \\<longrightarrow> (xs !! k) c1 \\<noteq> 0\n  c1 \\<in> \\<X>\n  c2 \\<in> \\<X>", "obtain k where k: \"k > i\" \"k \\<le> j\" \"(xs !! k) c2 = 0\""], ["proof (prove)\nusing this:\n  stream_trans xs\n  stream_all (\\<lambda>u. u \\<in> V) xs\n  (xs !! i) c1 = 0\n  \\<exists>k>i. k \\<le> j \\<and> (xs !! k) c2 = 0\n  \\<forall>k>i. k \\<le> j \\<longrightarrow> (xs !! k) c1 \\<noteq> 0\n  c1 \\<in> \\<X>\n  c2 \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>i < k; k \\<le> j; (xs !! k) c2 = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < k\n  k \\<le> j\n  (xs !! k) c2 = 0\n\ngoal (1 subgoal):\n 1. (xs !! j) c2 \\<le> (xs !! j) c1", "with assms(5) \\<open>k \\<le> j\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>k>i. k \\<le> j \\<longrightarrow> (xs !! k) c1 \\<noteq> 0\n  k \\<le> j\n  i < k\n  k \\<le> j\n  (xs !! k) c2 = 0", "have \"(xs !! k) c1 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<forall>k>i. k \\<le> j \\<longrightarrow> (xs !! k) c1 \\<noteq> 0\n  k \\<le> j\n  i < k\n  k \\<le> j\n  (xs !! k) c2 = 0\n\ngoal (1 subgoal):\n 1. (xs !! k) c1 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  (xs !! k) c1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (xs !! j) c2 \\<le> (xs !! j) c1", "moreover"], ["proof (state)\nthis:\n  (xs !! k) c1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (xs !! j) c2 \\<le> (xs !! j) c1", "from assms(2) \\<open>c1 \\<in> \\<X>\\<close>"], ["proof (chain)\npicking this:\n  stream_all (\\<lambda>u. u \\<in> V) xs\n  c1 \\<in> \\<X>", "have \"(xs !! k) c1 \\<ge> 0\""], ["proof (prove)\nusing this:\n  stream_all (\\<lambda>u. u \\<in> V) xs\n  c1 \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. 0 \\<le> (xs !! k) c1", "by (auto simp: V_def)"], ["proof (state)\nthis:\n  0 \\<le> (xs !! k) c1\n\ngoal (1 subgoal):\n 1. (xs !! j) c2 \\<le> (xs !! j) c1", "ultimately"], ["proof (chain)\npicking this:\n  (xs !! k) c1 \\<noteq> 0\n  0 \\<le> (xs !! k) c1", "have \"(xs !! k) c1 > 0\""], ["proof (prove)\nusing this:\n  (xs !! k) c1 \\<noteq> 0\n  0 \\<le> (xs !! k) c1\n\ngoal (1 subgoal):\n 1. 0 < (xs !! k) c1", "by auto"], ["proof (state)\nthis:\n  0 < (xs !! k) c1\n\ngoal (1 subgoal):\n 1. (xs !! j) c2 \\<le> (xs !! j) c1", "with \\<open>(xs !! k) c2 = 0\\<close>"], ["proof (chain)\npicking this:\n  (xs !! k) c2 = 0\n  0 < (xs !! k) c1", "have \"shd (sdrop k xs) c1 \\<ge> shd (sdrop k xs) c2\""], ["proof (prove)\nusing this:\n  (xs !! k) c2 = 0\n  0 < (xs !! k) c1\n\ngoal (1 subgoal):\n 1. shd (sdrop k xs) c2 \\<le> shd (sdrop k xs) c1", "by auto"], ["proof (state)\nthis:\n  shd (sdrop k xs) c2 \\<le> shd (sdrop k xs) c1\n\ngoal (1 subgoal):\n 1. (xs !! j) c2 \\<le> (xs !! j) c1", "from not_reset_mono[OF _ this] assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>stream_trans (sdrop k xs);\n   stream_all (\\<lambda>u. u \\<in> V) (sdrop k xs); c2 \\<in> \\<X>\\<rbrakk>\n  \\<Longrightarrow> (holds (\\<lambda>u. u c2 \\<le> u c1) until\n                     holds (\\<lambda>u. u c1 = 0))\n                     (sdrop k xs)\n  stream_trans xs\n  stream_all (\\<lambda>u. u \\<in> V) xs\n  (xs !! i) c1 = 0\n  \\<exists>k>i. k \\<le> j \\<and> (xs !! k) c2 = 0\n  \\<forall>k>i. k \\<le> j \\<longrightarrow> (xs !! k) c1 \\<noteq> 0\n  c1 \\<in> \\<X>\n  c2 \\<in> \\<X>", "have\n    \"(holds (\\<lambda>u. u c2 \\<le> u c1) until holds (\\<lambda>u. u c1 = 0)) (sdrop k xs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>stream_trans (sdrop k xs);\n   stream_all (\\<lambda>u. u \\<in> V) (sdrop k xs); c2 \\<in> \\<X>\\<rbrakk>\n  \\<Longrightarrow> (holds (\\<lambda>u. u c2 \\<le> u c1) until\n                     holds (\\<lambda>u. u c1 = 0))\n                     (sdrop k xs)\n  stream_trans xs\n  stream_all (\\<lambda>u. u \\<in> V) xs\n  (xs !! i) c1 = 0\n  \\<exists>k>i. k \\<le> j \\<and> (xs !! k) c2 = 0\n  \\<forall>k>i. k \\<le> j \\<longrightarrow> (xs !! k) c1 \\<noteq> 0\n  c1 \\<in> \\<X>\n  c2 \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. (holds (\\<lambda>u. u c2 \\<le> u c1) until holds (\\<lambda>u. u c1 = 0))\n     (sdrop k xs)", "by (auto intro: sset_sdrop pairwise_sdropD)"], ["proof (state)\nthis:\n  (holds (\\<lambda>u. u c2 \\<le> u c1) until holds (\\<lambda>u. u c1 = 0))\n   (sdrop k xs)\n\ngoal (1 subgoal):\n 1. (xs !! j) c2 \\<le> (xs !! j) c1", "from assms(5) k(2) \\<open>k > i\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>k>i. k \\<le> j \\<longrightarrow> (xs !! k) c1 \\<noteq> 0\n  k \\<le> j\n  i < k", "have \"\\<forall> m \\<le> j - k. (sdrop k xs !! m) c1 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<forall>k>i. k \\<le> j \\<longrightarrow> (xs !! k) c1 \\<noteq> 0\n  k \\<le> j\n  i < k\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<le>j - k. (sdrop k xs !! m) c1 \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  \\<forall>m\\<le>j - k. (sdrop k xs !! m) c1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (xs !! j) c2 \\<le> (xs !! j) c1", "with holds_untilD[OF \\<open>(_ until _) _\\<close>, of \"j - k\"]"], ["proof (chain)\npicking this:\n  \\<forall>i\\<le>j - k. (sdrop k xs !! i) c1 \\<noteq> 0 \\<Longrightarrow>\n  (sdrop k xs !! (j - k)) c2 \\<le> (sdrop k xs !! (j - k)) c1\n  \\<forall>m\\<le>j - k. (sdrop k xs !! m) c1 \\<noteq> 0", "have\n    \"(sdrop k xs !! (j - k)) c2 \\<le> (sdrop k xs !! (j - k)) c1\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>j - k. (sdrop k xs !! i) c1 \\<noteq> 0 \\<Longrightarrow>\n  (sdrop k xs !! (j - k)) c2 \\<le> (sdrop k xs !! (j - k)) c1\n  \\<forall>m\\<le>j - k. (sdrop k xs !! m) c1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (sdrop k xs !! (j - k)) c2 \\<le> (sdrop k xs !! (j - k)) c1", "."], ["proof (state)\nthis:\n  (sdrop k xs !! (j - k)) c2 \\<le> (sdrop k xs !! (j - k)) c1\n\ngoal (1 subgoal):\n 1. (xs !! j) c2 \\<le> (xs !! j) c1", "then"], ["proof (chain)\npicking this:\n  (sdrop k xs !! (j - k)) c2 \\<le> (sdrop k xs !! (j - k)) c1", "show \"(xs !! j) c2 \\<le> (xs !! j) c1\""], ["proof (prove)\nusing this:\n  (sdrop k xs !! (j - k)) c2 \\<le> (sdrop k xs !! (j - k)) c1\n\ngoal (1 subgoal):\n 1. (xs !! j) c2 \\<le> (xs !! j) c1", "using k(1,2)"], ["proof (prove)\nusing this:\n  (sdrop k xs !! (j - k)) c2 \\<le> (sdrop k xs !! (j - k)) c1\n  i < k\n  k \\<le> j\n\ngoal (1 subgoal):\n 1. (xs !! j) c2 \\<le> (xs !! j) c1", "by simp"], ["proof (state)\nthis:\n  (xs !! j) c2 \\<le> (xs !! j) c1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unbounded_all:\n  assumes \"R \\<in> \\<R>\" \"u \\<in> R\" \"unbounded x R\" \"x \\<in> \\<X>\"\n  shows \"u x > k x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (k x) < u x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real (k x) < u x", "from assms"], ["proof (chain)\npicking this:\n  R \\<in> \\<R>\n  u \\<in> R\n  unbounded x R\n  x \\<in> \\<X>", "obtain I r where R: \"R = region \\<X> I r\" \"valid_region \\<X> k I r\""], ["proof (prove)\nusing this:\n  R \\<in> \\<R>\n  u \\<in> R\n  unbounded x R\n  x \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. (\\<And>I r.\n        \\<lbrakk>R = Regions.region \\<X> I r;\n         Regions.valid_region \\<X> k I r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<R>_def"], ["proof (prove)\nusing this:\n  R \\<in> {Regions.region \\<X> I r |I r. Regions.valid_region \\<X> k I r}\n  u \\<in> R\n  unbounded x R\n  x \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. (\\<And>I r.\n        \\<lbrakk>R = Regions.region \\<X> I r;\n         Regions.valid_region \\<X> k I r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  R = Regions.region \\<X> I r\n  Regions.valid_region \\<X> k I r\n\ngoal (1 subgoal):\n 1. real (k x) < u x", "with unbounded_Greater \\<open>x \\<in> \\<X>\\<close> assms(3)"], ["proof (chain)\npicking this:\n  \\<lbrakk>Regions.valid_region ?X ?k ?I ?r; ?c \\<in> ?X;\n   unbounded ?c (Regions.region ?X ?I ?r)\\<rbrakk>\n  \\<Longrightarrow> ?I ?c = Regions.intv.Greater (?k ?c)\n  x \\<in> \\<X>\n  unbounded x R\n  R = Regions.region \\<X> I r\n  Regions.valid_region \\<X> k I r", "have \"I x = Greater (k x)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>Regions.valid_region ?X ?k ?I ?r; ?c \\<in> ?X;\n   unbounded ?c (Regions.region ?X ?I ?r)\\<rbrakk>\n  \\<Longrightarrow> ?I ?c = Regions.intv.Greater (?k ?c)\n  x \\<in> \\<X>\n  unbounded x R\n  R = Regions.region \\<X> I r\n  Regions.valid_region \\<X> k I r\n\ngoal (1 subgoal):\n 1. I x = Regions.intv.Greater (k x)", "by simp"], ["proof (state)\nthis:\n  I x = Regions.intv.Greater (k x)\n\ngoal (1 subgoal):\n 1. real (k x) < u x", "with \\<open>u \\<in> R\\<close> R \\<open>x \\<in> \\<X>\\<close>"], ["proof (chain)\npicking this:\n  u \\<in> R\n  R = Regions.region \\<X> I r\n  Regions.valid_region \\<X> k I r\n  x \\<in> \\<X>\n  I x = Regions.intv.Greater (k x)", "show ?thesis"], ["proof (prove)\nusing this:\n  u \\<in> R\n  R = Regions.region \\<X> I r\n  Regions.valid_region \\<X> k I r\n  x \\<in> \\<X>\n  I x = Regions.intv.Greater (k x)\n\ngoal (1 subgoal):\n 1. real (k x) < u x", "by force"], ["proof (state)\nthis:\n  real (k x) < u x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trans_not_delay_mono:\n  \"u' c \\<le> u c\" if \"trans u u'\" \"u \\<in> V\" \"x \\<in> \\<X>\" \"u' x = 0\" \"c \\<in> \\<X>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u' c \\<le> u c", "using \\<open>trans u u'\\<close>"], ["proof (prove)\nusing this:\n  local.trans u u'\n\ngoal (1 subgoal):\n 1. u' c \\<le> u c", "proof (cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>(0::'a) \\<le> t; u' = u \\<oplus> t\\<rbrakk>\n       \\<Longrightarrow> u' c \\<le> u c\n 2. \\<And>l.\n       \\<lbrakk>set l \\<subseteq> \\<X>;\n        u' = [l\\<rightarrow>(0::'a)]u\\<rbrakk>\n       \\<Longrightarrow> u' c \\<le> u c\n 3. u = u' \\<Longrightarrow> u' c \\<le> u c", "case (reset l)"], ["proof (state)\nthis:\n  set l \\<subseteq> \\<X>\n  u' = [l\\<rightarrow>(0::'a)]u\n\ngoal (3 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>(0::'a) \\<le> t; u' = u \\<oplus> t\\<rbrakk>\n       \\<Longrightarrow> u' c \\<le> u c\n 2. \\<And>l.\n       \\<lbrakk>set l \\<subseteq> \\<X>;\n        u' = [l\\<rightarrow>(0::'a)]u\\<rbrakk>\n       \\<Longrightarrow> u' c \\<le> u c\n 3. u = u' \\<Longrightarrow> u' c \\<le> u c", "with that"], ["proof (chain)\npicking this:\n  local.trans u u'\n  u \\<in> V\n  x \\<in> \\<X>\n  u' x = (0::'a)\n  c \\<in> \\<X>\n  set l \\<subseteq> \\<X>\n  u' = [l\\<rightarrow>(0::'a)]u", "show ?thesis"], ["proof (prove)\nusing this:\n  local.trans u u'\n  u \\<in> V\n  x \\<in> \\<X>\n  u' x = (0::'a)\n  c \\<in> \\<X>\n  set l \\<subseteq> \\<X>\n  u' = [l\\<rightarrow>(0::'a)]u\n\ngoal (1 subgoal):\n 1. u' c \\<le> u c", "by (cases \"c \\<in> set l\") (auto simp: V_def)"], ["proof (state)\nthis:\n  u' c \\<le> u c\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>(0::'a) \\<le> t; u' = u \\<oplus> t\\<rbrakk>\n       \\<Longrightarrow> u' c \\<le> u c\n 2. u = u' \\<Longrightarrow> u' c \\<le> u c", "qed (use that in \\<open>auto simp: cval_add_def V_def add_nonneg_eq_0_iff\\<close>)"], ["", "lemma dur_reset:\n  assumes \"pairwise eq_elapsed xs\" \"pred_stream (\\<lambda> u. u \\<in> V) xs\" \"zero x ([xs !! Suc i]\\<^sub>\\<R>)\" \"x \\<in> \\<X>\"\n  shows \"dur xs (Suc i) - dur xs i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dur xs (Suc i) - dur xs i = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dur xs (Suc i) - dur xs i = 0", "from assms(2)"], ["proof (chain)\npicking this:\n  pred_stream (\\<lambda>u. u \\<in> V) xs", "have in_V: \"xs !! Suc i \\<in> V\""], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n\ngoal (1 subgoal):\n 1. xs !! Suc i \\<in> V", "unfolding stream.pred_set"], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>sset xs. u \\<in> V\n\ngoal (1 subgoal):\n 1. xs !! Suc i \\<in> V", "by auto (metis snth.simps(2) snth_sset)"], ["proof (state)\nthis:\n  xs !! Suc i \\<in> V\n\ngoal (1 subgoal):\n 1. dur xs (Suc i) - dur xs i = 0", "with elapsed_ge_pos[of \"xs !! i\" \"xs !! Suc i\" x] pairwise_Suc[OF assms(1)] assms(2-)"], ["proof (chain)\npicking this:\n  \\<lbrakk>eq_elapsed (xs !! i) (xs !! Suc i); x \\<in> \\<X>;\n   xs !! i \\<in> V; xs !! Suc i \\<in> V\\<rbrakk>\n  \\<Longrightarrow> elapsed (xs !! i) (xs !! Suc i) \\<le> (xs !! Suc i) x\n  eq_elapsed (xs !! ?i) (xs !! Suc ?i)\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  zero x ([xs !! Suc i]\\<^sub>\\<R>)\n  x \\<in> \\<X>\n  xs !! Suc i \\<in> V", "have\n    \"elapsed (xs !! i) (xs !! Suc i) \\<le> (xs !! Suc i) x\""], ["proof (prove)\nusing this:\n  \\<lbrakk>eq_elapsed (xs !! i) (xs !! Suc i); x \\<in> \\<X>;\n   xs !! i \\<in> V; xs !! Suc i \\<in> V\\<rbrakk>\n  \\<Longrightarrow> elapsed (xs !! i) (xs !! Suc i) \\<le> (xs !! Suc i) x\n  eq_elapsed (xs !! ?i) (xs !! Suc ?i)\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  zero x ([xs !! Suc i]\\<^sub>\\<R>)\n  x \\<in> \\<X>\n  xs !! Suc i \\<in> V\n\ngoal (1 subgoal):\n 1. elapsed (xs !! i) (xs !! Suc i) \\<le> (xs !! Suc i) x", "unfolding stream.pred_set"], ["proof (prove)\nusing this:\n  \\<lbrakk>eq_elapsed (xs !! i) (xs !! Suc i); x \\<in> \\<X>;\n   xs !! i \\<in> V; xs !! Suc i \\<in> V\\<rbrakk>\n  \\<Longrightarrow> elapsed (xs !! i) (xs !! Suc i) \\<le> (xs !! Suc i) x\n  eq_elapsed (xs !! ?i) (xs !! Suc ?i)\n  \\<forall>u\\<in>sset xs. u \\<in> V\n  zero x ([xs !! Suc i]\\<^sub>\\<R>)\n  x \\<in> \\<X>\n  xs !! Suc i \\<in> V\n\ngoal (1 subgoal):\n 1. elapsed (xs !! i) (xs !! Suc i) \\<le> (xs !! Suc i) x", "by auto"], ["proof (state)\nthis:\n  elapsed (xs !! i) (xs !! Suc i) \\<le> (xs !! Suc i) x\n\ngoal (1 subgoal):\n 1. dur xs (Suc i) - dur xs i = 0", "with in_V assms(3)"], ["proof (chain)\npicking this:\n  xs !! Suc i \\<in> V\n  zero x ([xs !! Suc i]\\<^sub>\\<R>)\n  elapsed (xs !! i) (xs !! Suc i) \\<le> (xs !! Suc i) x", "have \"elapsed (xs !! i) (xs !! Suc i) \\<le> 0\""], ["proof (prove)\nusing this:\n  xs !! Suc i \\<in> V\n  zero x ([xs !! Suc i]\\<^sub>\\<R>)\n  elapsed (xs !! i) (xs !! Suc i) \\<le> (xs !! Suc i) x\n\ngoal (1 subgoal):\n 1. elapsed (xs !! i) (xs !! Suc i) \\<le> 0", "by (auto simp: zeroD)"], ["proof (state)\nthis:\n  elapsed (xs !! i) (xs !! Suc i) \\<le> 0\n\ngoal (1 subgoal):\n 1. dur xs (Suc i) - dur xs i = 0", "with elapsed_ge0[of \"xs !! i\" \"xs !! Suc i\"]"], ["proof (chain)\npicking this:\n  0 \\<le> elapsed (xs !! i) (xs !! Suc i)\n  elapsed (xs !! i) (xs !! Suc i) \\<le> 0", "have \"elapsed (xs !! i) (xs !! Suc i) = 0\""], ["proof (prove)\nusing this:\n  0 \\<le> elapsed (xs !! i) (xs !! Suc i)\n  elapsed (xs !! i) (xs !! Suc i) \\<le> 0\n\ngoal (1 subgoal):\n 1. elapsed (xs !! i) (xs !! Suc i) = 0", "by linarith"], ["proof (state)\nthis:\n  elapsed (xs !! i) (xs !! Suc i) = 0\n\ngoal (1 subgoal):\n 1. dur xs (Suc i) - dur xs i = 0", "then"], ["proof (chain)\npicking this:\n  elapsed (xs !! i) (xs !! Suc i) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  elapsed (xs !! i) (xs !! Suc i) = 0\n\ngoal (1 subgoal):\n 1. dur xs (Suc i) - dur xs i = 0", "by (subst dur_Suc)"], ["proof (state)\nthis:\n  dur xs (Suc i) - dur xs i = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma resets_mono_0':\n  assumes \"pairwise eq_elapsed xs\" \"stream_all (\\<lambda> u. u \\<in> V) xs\" \"stream_trans xs\"\n          \"\\<forall> j \\<le> i. zero x ([xs !! j]\\<^sub>\\<R>)\" \"x \\<in> \\<X>\" \"c \\<in> \\<X>\"\n  shows \"(xs !! i) c = (xs !! 0) c \\<or> (xs !! i) c = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs !! i) c = (xs !! 0) c \\<or> (xs !! i) c = 0", "using assms"], ["proof (prove)\nusing this:\n  PTA_Reachability.pairwise eq_elapsed xs\n  stream_all (\\<lambda>u. u \\<in> V) xs\n  stream_trans xs\n  \\<forall>j\\<le>i. zero x ([xs !! j]\\<^sub>\\<R>)\n  x \\<in> \\<X>\n  c \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. (xs !! i) c = (xs !! 0) c \\<or> (xs !! i) c = 0", "proof (induction i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>PTA_Reachability.pairwise eq_elapsed xs;\n     stream_all (\\<lambda>u. u \\<in> V) xs; stream_trans xs;\n     \\<forall>j\\<le>0. zero x ([xs !! j]\\<^sub>\\<R>); x \\<in> \\<X>;\n     c \\<in> \\<X>\\<rbrakk>\n    \\<Longrightarrow> (xs !! 0) c = (xs !! 0) c \\<or> (xs !! 0) c = 0\n 2. \\<And>i.\n       \\<lbrakk>\\<lbrakk>PTA_Reachability.pairwise eq_elapsed xs;\n                 stream_all (\\<lambda>u. u \\<in> V) xs; stream_trans xs;\n                 \\<forall>j\\<le>i. zero x ([xs !! j]\\<^sub>\\<R>);\n                 x \\<in> \\<X>; c \\<in> \\<X>\\<rbrakk>\n                \\<Longrightarrow> (xs !! i) c = (xs !! 0) c \\<or>\n                                  (xs !! i) c = 0;\n        PTA_Reachability.pairwise eq_elapsed xs;\n        stream_all (\\<lambda>u. u \\<in> V) xs; stream_trans xs;\n        \\<forall>j\\<le>Suc i. zero x ([xs !! j]\\<^sub>\\<R>); x \\<in> \\<X>;\n        c \\<in> \\<X>\\<rbrakk>\n       \\<Longrightarrow> (xs !! Suc i) c = (xs !! 0) c \\<or>\n                         (xs !! Suc i) c = 0", "case 0"], ["proof (state)\nthis:\n  PTA_Reachability.pairwise eq_elapsed xs\n  stream_all (\\<lambda>u. u \\<in> V) xs\n  stream_trans xs\n  \\<forall>j\\<le>0. zero x ([xs !! j]\\<^sub>\\<R>)\n  x \\<in> \\<X>\n  c \\<in> \\<X>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>PTA_Reachability.pairwise eq_elapsed xs;\n     stream_all (\\<lambda>u. u \\<in> V) xs; stream_trans xs;\n     \\<forall>j\\<le>0. zero x ([xs !! j]\\<^sub>\\<R>); x \\<in> \\<X>;\n     c \\<in> \\<X>\\<rbrakk>\n    \\<Longrightarrow> (xs !! 0) c = (xs !! 0) c \\<or> (xs !! 0) c = 0\n 2. \\<And>i.\n       \\<lbrakk>\\<lbrakk>PTA_Reachability.pairwise eq_elapsed xs;\n                 stream_all (\\<lambda>u. u \\<in> V) xs; stream_trans xs;\n                 \\<forall>j\\<le>i. zero x ([xs !! j]\\<^sub>\\<R>);\n                 x \\<in> \\<X>; c \\<in> \\<X>\\<rbrakk>\n                \\<Longrightarrow> (xs !! i) c = (xs !! 0) c \\<or>\n                                  (xs !! i) c = 0;\n        PTA_Reachability.pairwise eq_elapsed xs;\n        stream_all (\\<lambda>u. u \\<in> V) xs; stream_trans xs;\n        \\<forall>j\\<le>Suc i. zero x ([xs !! j]\\<^sub>\\<R>); x \\<in> \\<X>;\n        c \\<in> \\<X>\\<rbrakk>\n       \\<Longrightarrow> (xs !! Suc i) c = (xs !! 0) c \\<or>\n                         (xs !! Suc i) c = 0", "then"], ["proof (chain)\npicking this:\n  PTA_Reachability.pairwise eq_elapsed xs\n  stream_all (\\<lambda>u. u \\<in> V) xs\n  stream_trans xs\n  \\<forall>j\\<le>0. zero x ([xs !! j]\\<^sub>\\<R>)\n  x \\<in> \\<X>\n  c \\<in> \\<X>", "show ?case"], ["proof (prove)\nusing this:\n  PTA_Reachability.pairwise eq_elapsed xs\n  stream_all (\\<lambda>u. u \\<in> V) xs\n  stream_trans xs\n  \\<forall>j\\<le>0. zero x ([xs !! j]\\<^sub>\\<R>)\n  x \\<in> \\<X>\n  c \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. (xs !! 0) c = (xs !! 0) c \\<or> (xs !! 0) c = 0", "by auto"], ["proof (state)\nthis:\n  (xs !! 0) c = (xs !! 0) c \\<or> (xs !! 0) c = 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<lbrakk>PTA_Reachability.pairwise eq_elapsed xs;\n                 stream_all (\\<lambda>u. u \\<in> V) xs; stream_trans xs;\n                 \\<forall>j\\<le>i. zero x ([xs !! j]\\<^sub>\\<R>);\n                 x \\<in> \\<X>; c \\<in> \\<X>\\<rbrakk>\n                \\<Longrightarrow> (xs !! i) c = (xs !! 0) c \\<or>\n                                  (xs !! i) c = 0;\n        PTA_Reachability.pairwise eq_elapsed xs;\n        stream_all (\\<lambda>u. u \\<in> V) xs; stream_trans xs;\n        \\<forall>j\\<le>Suc i. zero x ([xs !! j]\\<^sub>\\<R>); x \\<in> \\<X>;\n        c \\<in> \\<X>\\<rbrakk>\n       \\<Longrightarrow> (xs !! Suc i) c = (xs !! 0) c \\<or>\n                         (xs !! Suc i) c = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<lbrakk>PTA_Reachability.pairwise eq_elapsed xs;\n                 stream_all (\\<lambda>u. u \\<in> V) xs; stream_trans xs;\n                 \\<forall>j\\<le>i. zero x ([xs !! j]\\<^sub>\\<R>);\n                 x \\<in> \\<X>; c \\<in> \\<X>\\<rbrakk>\n                \\<Longrightarrow> (xs !! i) c = (xs !! 0) c \\<or>\n                                  (xs !! i) c = 0;\n        PTA_Reachability.pairwise eq_elapsed xs;\n        stream_all (\\<lambda>u. u \\<in> V) xs; stream_trans xs;\n        \\<forall>j\\<le>Suc i. zero x ([xs !! j]\\<^sub>\\<R>); x \\<in> \\<X>;\n        c \\<in> \\<X>\\<rbrakk>\n       \\<Longrightarrow> (xs !! Suc i) c = (xs !! 0) c \\<or>\n                         (xs !! Suc i) c = 0", "case (Suc i)"], ["proof (state)\nthis:\n  \\<lbrakk>PTA_Reachability.pairwise eq_elapsed xs;\n   stream_all (\\<lambda>u. u \\<in> V) xs; stream_trans xs;\n   \\<forall>j\\<le>i. zero x ([xs !! j]\\<^sub>\\<R>); x \\<in> \\<X>;\n   c \\<in> \\<X>\\<rbrakk>\n  \\<Longrightarrow> (xs !! i) c = (xs !! 0) c \\<or> (xs !! i) c = 0\n  PTA_Reachability.pairwise eq_elapsed xs\n  stream_all (\\<lambda>u. u \\<in> V) xs\n  stream_trans xs\n  \\<forall>j\\<le>Suc i. zero x ([xs !! j]\\<^sub>\\<R>)\n  x \\<in> \\<X>\n  c \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<lbrakk>PTA_Reachability.pairwise eq_elapsed xs;\n                 stream_all (\\<lambda>u. u \\<in> V) xs; stream_trans xs;\n                 \\<forall>j\\<le>i. zero x ([xs !! j]\\<^sub>\\<R>);\n                 x \\<in> \\<X>; c \\<in> \\<X>\\<rbrakk>\n                \\<Longrightarrow> (xs !! i) c = (xs !! 0) c \\<or>\n                                  (xs !! i) c = 0;\n        PTA_Reachability.pairwise eq_elapsed xs;\n        stream_all (\\<lambda>u. u \\<in> V) xs; stream_trans xs;\n        \\<forall>j\\<le>Suc i. zero x ([xs !! j]\\<^sub>\\<R>); x \\<in> \\<X>;\n        c \\<in> \\<X>\\<rbrakk>\n       \\<Longrightarrow> (xs !! Suc i) c = (xs !! 0) c \\<or>\n                         (xs !! Suc i) c = 0", "from Suc.prems"], ["proof (chain)\npicking this:\n  PTA_Reachability.pairwise eq_elapsed xs\n  stream_all (\\<lambda>u. u \\<in> V) xs\n  stream_trans xs\n  \\<forall>j\\<le>Suc i. zero x ([xs !! j]\\<^sub>\\<R>)\n  x \\<in> \\<X>\n  c \\<in> \\<X>", "have *: \"(xs !! Suc i) x = 0\" \"(xs !! i) x = 0\""], ["proof (prove)\nusing this:\n  PTA_Reachability.pairwise eq_elapsed xs\n  stream_all (\\<lambda>u. u \\<in> V) xs\n  stream_trans xs\n  \\<forall>j\\<le>Suc i. zero x ([xs !! j]\\<^sub>\\<R>)\n  x \\<in> \\<X>\n  c \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. (xs !! Suc i) x = 0 &&& (xs !! i) x = 0", "by (blast intro: zeroD snth_sset, force intro: zeroD snth_sset)"], ["proof (state)\nthis:\n  (xs !! Suc i) x = 0\n  (xs !! i) x = 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<lbrakk>PTA_Reachability.pairwise eq_elapsed xs;\n                 stream_all (\\<lambda>u. u \\<in> V) xs; stream_trans xs;\n                 \\<forall>j\\<le>i. zero x ([xs !! j]\\<^sub>\\<R>);\n                 x \\<in> \\<X>; c \\<in> \\<X>\\<rbrakk>\n                \\<Longrightarrow> (xs !! i) c = (xs !! 0) c \\<or>\n                                  (xs !! i) c = 0;\n        PTA_Reachability.pairwise eq_elapsed xs;\n        stream_all (\\<lambda>u. u \\<in> V) xs; stream_trans xs;\n        \\<forall>j\\<le>Suc i. zero x ([xs !! j]\\<^sub>\\<R>); x \\<in> \\<X>;\n        c \\<in> \\<X>\\<rbrakk>\n       \\<Longrightarrow> (xs !! Suc i) c = (xs !! 0) c \\<or>\n                         (xs !! Suc i) c = 0", "from pairwise_Suc[OF Suc.prems(3)]"], ["proof (chain)\npicking this:\n  local.trans (xs !! ?i) (xs !! Suc ?i)", "have \"trans (xs !! i) (xs !! Suc i)\""], ["proof (prove)\nusing this:\n  local.trans (xs !! ?i) (xs !! Suc ?i)\n\ngoal (1 subgoal):\n 1. local.trans (xs !! i) (xs !! Suc i)", "."], ["proof (state)\nthis:\n  local.trans (xs !! i) (xs !! Suc i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<lbrakk>PTA_Reachability.pairwise eq_elapsed xs;\n                 stream_all (\\<lambda>u. u \\<in> V) xs; stream_trans xs;\n                 \\<forall>j\\<le>i. zero x ([xs !! j]\\<^sub>\\<R>);\n                 x \\<in> \\<X>; c \\<in> \\<X>\\<rbrakk>\n                \\<Longrightarrow> (xs !! i) c = (xs !! 0) c \\<or>\n                                  (xs !! i) c = 0;\n        PTA_Reachability.pairwise eq_elapsed xs;\n        stream_all (\\<lambda>u. u \\<in> V) xs; stream_trans xs;\n        \\<forall>j\\<le>Suc i. zero x ([xs !! j]\\<^sub>\\<R>); x \\<in> \\<X>;\n        c \\<in> \\<X>\\<rbrakk>\n       \\<Longrightarrow> (xs !! Suc i) c = (xs !! 0) c \\<or>\n                         (xs !! Suc i) c = 0", "then"], ["proof (chain)\npicking this:\n  local.trans (xs !! i) (xs !! Suc i)", "show ?case"], ["proof (prove)\nusing this:\n  local.trans (xs !! i) (xs !! Suc i)\n\ngoal (1 subgoal):\n 1. (xs !! Suc i) c = (xs !! 0) c \\<or> (xs !! Suc i) c = 0", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>0 \\<le> t; xs !! Suc i = xs !! i \\<oplus> t\\<rbrakk>\n       \\<Longrightarrow> (xs !! Suc i) c = (xs !! 0) c \\<or>\n                         (xs !! Suc i) c = 0\n 2. \\<And>l.\n       \\<lbrakk>set l \\<subseteq> \\<X>;\n        xs !! Suc i = [l\\<rightarrow>0]xs !! i\\<rbrakk>\n       \\<Longrightarrow> (xs !! Suc i) c = (xs !! 0) c \\<or>\n                         (xs !! Suc i) c = 0\n 3. xs !! i = xs !! Suc i \\<Longrightarrow>\n    (xs !! Suc i) c = (xs !! 0) c \\<or> (xs !! Suc i) c = 0", "case prems: (succ t)"], ["proof (state)\nthis:\n  0 \\<le> t\n  xs !! Suc i = xs !! i \\<oplus> t\n\ngoal (3 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>0 \\<le> t; xs !! Suc i = xs !! i \\<oplus> t\\<rbrakk>\n       \\<Longrightarrow> (xs !! Suc i) c = (xs !! 0) c \\<or>\n                         (xs !! Suc i) c = 0\n 2. \\<And>l.\n       \\<lbrakk>set l \\<subseteq> \\<X>;\n        xs !! Suc i = [l\\<rightarrow>0]xs !! i\\<rbrakk>\n       \\<Longrightarrow> (xs !! Suc i) c = (xs !! 0) c \\<or>\n                         (xs !! Suc i) c = 0\n 3. xs !! i = xs !! Suc i \\<Longrightarrow>\n    (xs !! Suc i) c = (xs !! 0) c \\<or> (xs !! Suc i) c = 0", "with *"], ["proof (chain)\npicking this:\n  (xs !! Suc i) x = 0\n  (xs !! i) x = 0\n  0 \\<le> t\n  xs !! Suc i = xs !! i \\<oplus> t", "have \"t = 0\""], ["proof (prove)\nusing this:\n  (xs !! Suc i) x = 0\n  (xs !! i) x = 0\n  0 \\<le> t\n  xs !! Suc i = xs !! i \\<oplus> t\n\ngoal (1 subgoal):\n 1. t = 0", "unfolding cval_add_def"], ["proof (prove)\nusing this:\n  (xs !! Suc i) x = 0\n  (xs !! i) x = 0\n  0 \\<le> t\n  xs !! Suc i = (\\<lambda>x. (xs !! i) x + t)\n\ngoal (1 subgoal):\n 1. t = 0", "by auto"], ["proof (state)\nthis:\n  t = 0\n\ngoal (3 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>0 \\<le> t; xs !! Suc i = xs !! i \\<oplus> t\\<rbrakk>\n       \\<Longrightarrow> (xs !! Suc i) c = (xs !! 0) c \\<or>\n                         (xs !! Suc i) c = 0\n 2. \\<And>l.\n       \\<lbrakk>set l \\<subseteq> \\<X>;\n        xs !! Suc i = [l\\<rightarrow>0]xs !! i\\<rbrakk>\n       \\<Longrightarrow> (xs !! Suc i) c = (xs !! 0) c \\<or>\n                         (xs !! Suc i) c = 0\n 3. xs !! i = xs !! Suc i \\<Longrightarrow>\n    (xs !! Suc i) c = (xs !! 0) c \\<or> (xs !! Suc i) c = 0", "with prems"], ["proof (chain)\npicking this:\n  0 \\<le> t\n  xs !! Suc i = xs !! i \\<oplus> t\n  t = 0", "have \"(xs !! Suc i) c = (xs !! i) c\""], ["proof (prove)\nusing this:\n  0 \\<le> t\n  xs !! Suc i = xs !! i \\<oplus> t\n  t = 0\n\ngoal (1 subgoal):\n 1. (xs !! Suc i) c = (xs !! i) c", "unfolding cval_add_def"], ["proof (prove)\nusing this:\n  0 \\<le> t\n  xs !! Suc i = (\\<lambda>x. (xs !! i) x + t)\n  t = 0\n\ngoal (1 subgoal):\n 1. (xs !! Suc i) c = (xs !! i) c", "by auto"], ["proof (state)\nthis:\n  (xs !! Suc i) c = (xs !! i) c\n\ngoal (3 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>0 \\<le> t; xs !! Suc i = xs !! i \\<oplus> t\\<rbrakk>\n       \\<Longrightarrow> (xs !! Suc i) c = (xs !! 0) c \\<or>\n                         (xs !! Suc i) c = 0\n 2. \\<And>l.\n       \\<lbrakk>set l \\<subseteq> \\<X>;\n        xs !! Suc i = [l\\<rightarrow>0]xs !! i\\<rbrakk>\n       \\<Longrightarrow> (xs !! Suc i) c = (xs !! 0) c \\<or>\n                         (xs !! Suc i) c = 0\n 3. xs !! i = xs !! Suc i \\<Longrightarrow>\n    (xs !! Suc i) c = (xs !! 0) c \\<or> (xs !! Suc i) c = 0", "with Suc"], ["proof (chain)\npicking this:\n  \\<lbrakk>PTA_Reachability.pairwise eq_elapsed xs;\n   stream_all (\\<lambda>u. u \\<in> V) xs; stream_trans xs;\n   \\<forall>j\\<le>i. zero x ([xs !! j]\\<^sub>\\<R>); x \\<in> \\<X>;\n   c \\<in> \\<X>\\<rbrakk>\n  \\<Longrightarrow> (xs !! i) c = (xs !! 0) c \\<or> (xs !! i) c = 0\n  PTA_Reachability.pairwise eq_elapsed xs\n  stream_all (\\<lambda>u. u \\<in> V) xs\n  stream_trans xs\n  \\<forall>j\\<le>Suc i. zero x ([xs !! j]\\<^sub>\\<R>)\n  x \\<in> \\<X>\n  c \\<in> \\<X>\n  (xs !! Suc i) c = (xs !! i) c", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>PTA_Reachability.pairwise eq_elapsed xs;\n   stream_all (\\<lambda>u. u \\<in> V) xs; stream_trans xs;\n   \\<forall>j\\<le>i. zero x ([xs !! j]\\<^sub>\\<R>); x \\<in> \\<X>;\n   c \\<in> \\<X>\\<rbrakk>\n  \\<Longrightarrow> (xs !! i) c = (xs !! 0) c \\<or> (xs !! i) c = 0\n  PTA_Reachability.pairwise eq_elapsed xs\n  stream_all (\\<lambda>u. u \\<in> V) xs\n  stream_trans xs\n  \\<forall>j\\<le>Suc i. zero x ([xs !! j]\\<^sub>\\<R>)\n  x \\<in> \\<X>\n  c \\<in> \\<X>\n  (xs !! Suc i) c = (xs !! i) c\n\ngoal (1 subgoal):\n 1. (xs !! Suc i) c = (xs !! 0) c \\<or> (xs !! Suc i) c = 0", "by auto"], ["proof (state)\nthis:\n  (xs !! Suc i) c = (xs !! 0) c \\<or> (xs !! Suc i) c = 0\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>set l \\<subseteq> \\<X>;\n        xs !! Suc i = [l\\<rightarrow>0]xs !! i\\<rbrakk>\n       \\<Longrightarrow> (xs !! Suc i) c = (xs !! 0) c \\<or>\n                         (xs !! Suc i) c = 0\n 2. xs !! i = xs !! Suc i \\<Longrightarrow>\n    (xs !! Suc i) c = (xs !! 0) c \\<or> (xs !! Suc i) c = 0", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>set l \\<subseteq> \\<X>;\n        xs !! Suc i = [l\\<rightarrow>0]xs !! i\\<rbrakk>\n       \\<Longrightarrow> (xs !! Suc i) c = (xs !! 0) c \\<or>\n                         (xs !! Suc i) c = 0\n 2. xs !! i = xs !! Suc i \\<Longrightarrow>\n    (xs !! Suc i) c = (xs !! 0) c \\<or> (xs !! Suc i) c = 0", "case prems: (reset l)"], ["proof (state)\nthis:\n  set l \\<subseteq> \\<X>\n  xs !! Suc i = [l\\<rightarrow>0]xs !! i\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>set l \\<subseteq> \\<X>;\n        xs !! Suc i = [l\\<rightarrow>0]xs !! i\\<rbrakk>\n       \\<Longrightarrow> (xs !! Suc i) c = (xs !! 0) c \\<or>\n                         (xs !! Suc i) c = 0\n 2. xs !! i = xs !! Suc i \\<Longrightarrow>\n    (xs !! Suc i) c = (xs !! 0) c \\<or> (xs !! Suc i) c = 0", "then"], ["proof (chain)\npicking this:\n  set l \\<subseteq> \\<X>\n  xs !! Suc i = [l\\<rightarrow>0]xs !! i", "have \"(xs !! Suc i) c = 0 \\<or> (xs !! Suc i) c = (xs !! i) c\""], ["proof (prove)\nusing this:\n  set l \\<subseteq> \\<X>\n  xs !! Suc i = [l\\<rightarrow>0]xs !! i\n\ngoal (1 subgoal):\n 1. (xs !! Suc i) c = 0 \\<or> (xs !! Suc i) c = (xs !! i) c", "by (cases \"c \\<in> set l\") auto"], ["proof (state)\nthis:\n  (xs !! Suc i) c = 0 \\<or> (xs !! Suc i) c = (xs !! i) c\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>set l \\<subseteq> \\<X>;\n        xs !! Suc i = [l\\<rightarrow>0]xs !! i\\<rbrakk>\n       \\<Longrightarrow> (xs !! Suc i) c = (xs !! 0) c \\<or>\n                         (xs !! Suc i) c = 0\n 2. xs !! i = xs !! Suc i \\<Longrightarrow>\n    (xs !! Suc i) c = (xs !! 0) c \\<or> (xs !! Suc i) c = 0", "with Suc"], ["proof (chain)\npicking this:\n  \\<lbrakk>PTA_Reachability.pairwise eq_elapsed xs;\n   stream_all (\\<lambda>u. u \\<in> V) xs; stream_trans xs;\n   \\<forall>j\\<le>i. zero x ([xs !! j]\\<^sub>\\<R>); x \\<in> \\<X>;\n   c \\<in> \\<X>\\<rbrakk>\n  \\<Longrightarrow> (xs !! i) c = (xs !! 0) c \\<or> (xs !! i) c = 0\n  PTA_Reachability.pairwise eq_elapsed xs\n  stream_all (\\<lambda>u. u \\<in> V) xs\n  stream_trans xs\n  \\<forall>j\\<le>Suc i. zero x ([xs !! j]\\<^sub>\\<R>)\n  x \\<in> \\<X>\n  c \\<in> \\<X>\n  (xs !! Suc i) c = 0 \\<or> (xs !! Suc i) c = (xs !! i) c", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>PTA_Reachability.pairwise eq_elapsed xs;\n   stream_all (\\<lambda>u. u \\<in> V) xs; stream_trans xs;\n   \\<forall>j\\<le>i. zero x ([xs !! j]\\<^sub>\\<R>); x \\<in> \\<X>;\n   c \\<in> \\<X>\\<rbrakk>\n  \\<Longrightarrow> (xs !! i) c = (xs !! 0) c \\<or> (xs !! i) c = 0\n  PTA_Reachability.pairwise eq_elapsed xs\n  stream_all (\\<lambda>u. u \\<in> V) xs\n  stream_trans xs\n  \\<forall>j\\<le>Suc i. zero x ([xs !! j]\\<^sub>\\<R>)\n  x \\<in> \\<X>\n  c \\<in> \\<X>\n  (xs !! Suc i) c = 0 \\<or> (xs !! Suc i) c = (xs !! i) c\n\ngoal (1 subgoal):\n 1. (xs !! Suc i) c = (xs !! 0) c \\<or> (xs !! Suc i) c = 0", "by auto"], ["proof (state)\nthis:\n  (xs !! Suc i) c = (xs !! 0) c \\<or> (xs !! Suc i) c = 0\n\ngoal (1 subgoal):\n 1. xs !! i = xs !! Suc i \\<Longrightarrow>\n    (xs !! Suc i) c = (xs !! 0) c \\<or> (xs !! Suc i) c = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs !! i = xs !! Suc i \\<Longrightarrow>\n    (xs !! Suc i) c = (xs !! 0) c \\<or> (xs !! Suc i) c = 0", "case id"], ["proof (state)\nthis:\n  xs !! i = xs !! Suc i\n\ngoal (1 subgoal):\n 1. xs !! i = xs !! Suc i \\<Longrightarrow>\n    (xs !! Suc i) c = (xs !! 0) c \\<or> (xs !! Suc i) c = 0", "with Suc"], ["proof (chain)\npicking this:\n  \\<lbrakk>PTA_Reachability.pairwise eq_elapsed xs;\n   stream_all (\\<lambda>u. u \\<in> V) xs; stream_trans xs;\n   \\<forall>j\\<le>i. zero x ([xs !! j]\\<^sub>\\<R>); x \\<in> \\<X>;\n   c \\<in> \\<X>\\<rbrakk>\n  \\<Longrightarrow> (xs !! i) c = (xs !! 0) c \\<or> (xs !! i) c = 0\n  PTA_Reachability.pairwise eq_elapsed xs\n  stream_all (\\<lambda>u. u \\<in> V) xs\n  stream_trans xs\n  \\<forall>j\\<le>Suc i. zero x ([xs !! j]\\<^sub>\\<R>)\n  x \\<in> \\<X>\n  c \\<in> \\<X>\n  xs !! i = xs !! Suc i", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>PTA_Reachability.pairwise eq_elapsed xs;\n   stream_all (\\<lambda>u. u \\<in> V) xs; stream_trans xs;\n   \\<forall>j\\<le>i. zero x ([xs !! j]\\<^sub>\\<R>); x \\<in> \\<X>;\n   c \\<in> \\<X>\\<rbrakk>\n  \\<Longrightarrow> (xs !! i) c = (xs !! 0) c \\<or> (xs !! i) c = 0\n  PTA_Reachability.pairwise eq_elapsed xs\n  stream_all (\\<lambda>u. u \\<in> V) xs\n  stream_trans xs\n  \\<forall>j\\<le>Suc i. zero x ([xs !! j]\\<^sub>\\<R>)\n  x \\<in> \\<X>\n  c \\<in> \\<X>\n  xs !! i = xs !! Suc i\n\ngoal (1 subgoal):\n 1. (xs !! Suc i) c = (xs !! 0) c \\<or> (xs !! Suc i) c = 0", "by auto"], ["proof (state)\nthis:\n  (xs !! Suc i) c = (xs !! 0) c \\<or> (xs !! Suc i) c = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (xs !! Suc i) c = (xs !! 0) c \\<or> (xs !! Suc i) c = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma resets_mono':\n  assumes \"pairwise eq_elapsed xs\" \"pred_stream (\\<lambda> u. u \\<in> V) xs\" \"stream_trans xs\"\n          \"\\<forall> k \\<ge> i. k \\<le> j \\<longrightarrow> zero x ([xs !! k]\\<^sub>\\<R>)\" \"x \\<in> \\<X>\" \"c \\<in> \\<X>\" \"i \\<le> j\"\n  shows \"(xs !! j) c = (xs !! i) c \\<or> (xs !! j) c = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs !! j) c = (xs !! i) c \\<or> (xs !! j) c = 0", "using assms"], ["proof (prove)\nusing this:\n  PTA_Reachability.pairwise eq_elapsed xs\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  stream_trans xs\n  \\<forall>k\\<ge>i.\n     k \\<le> j \\<longrightarrow> zero x ([xs !! k]\\<^sub>\\<R>)\n  x \\<in> \\<X>\n  c \\<in> \\<X>\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. (xs !! j) c = (xs !! i) c \\<or> (xs !! j) c = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>PTA_Reachability.pairwise eq_elapsed xs;\n     pred_stream (\\<lambda>u. u \\<in> V) xs; stream_trans xs;\n     \\<forall>k\\<ge>i.\n        k \\<le> j \\<longrightarrow> zero x ([xs !! k]\\<^sub>\\<R>);\n     x \\<in> \\<X>; c \\<in> \\<X>; i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> (xs !! j) c = (xs !! i) c \\<or> (xs !! j) c = 0", "from assms"], ["proof (chain)\npicking this:\n  PTA_Reachability.pairwise eq_elapsed xs\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  stream_trans xs\n  \\<forall>k\\<ge>i.\n     k \\<le> j \\<longrightarrow> zero x ([xs !! k]\\<^sub>\\<R>)\n  x \\<in> \\<X>\n  c \\<in> \\<X>\n  i \\<le> j", "have 1: \"stream_all (\\<lambda> u. u \\<in> V) (sdrop i xs)\""], ["proof (prove)\nusing this:\n  PTA_Reachability.pairwise eq_elapsed xs\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  stream_trans xs\n  \\<forall>k\\<ge>i.\n     k \\<le> j \\<longrightarrow> zero x ([xs !! k]\\<^sub>\\<R>)\n  x \\<in> \\<X>\n  c \\<in> \\<X>\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. stream_all (\\<lambda>u. u \\<in> V) (sdrop i xs)", "using sset_sdrop"], ["proof (prove)\nusing this:\n  PTA_Reachability.pairwise eq_elapsed xs\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  stream_trans xs\n  \\<forall>k\\<ge>i.\n     k \\<le> j \\<longrightarrow> zero x ([xs !! k]\\<^sub>\\<R>)\n  x \\<in> \\<X>\n  c \\<in> \\<X>\n  i \\<le> j\n  ?x \\<in> sset (sdrop ?i ?xs) \\<Longrightarrow> ?x \\<in> sset ?xs\n\ngoal (1 subgoal):\n 1. stream_all (\\<lambda>u. u \\<in> V) (sdrop i xs)", "unfolding stream.pred_set"], ["proof (prove)\nusing this:\n  PTA_Reachability.pairwise eq_elapsed xs\n  \\<forall>u\\<in>sset xs. u \\<in> V\n  stream_trans xs\n  \\<forall>k\\<ge>i.\n     k \\<le> j \\<longrightarrow> zero x ([xs !! k]\\<^sub>\\<R>)\n  x \\<in> \\<X>\n  c \\<in> \\<X>\n  i \\<le> j\n  ?x \\<in> sset (sdrop ?i ?xs) \\<Longrightarrow> ?x \\<in> sset ?xs\n\ngoal (1 subgoal):\n 1. stream_all (\\<lambda>u. u \\<in> V) (sdrop i xs)", "by force"], ["proof (state)\nthis:\n  stream_all (\\<lambda>u. u \\<in> V) (sdrop i xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>PTA_Reachability.pairwise eq_elapsed xs;\n     pred_stream (\\<lambda>u. u \\<in> V) xs; stream_trans xs;\n     \\<forall>k\\<ge>i.\n        k \\<le> j \\<longrightarrow> zero x ([xs !! k]\\<^sub>\\<R>);\n     x \\<in> \\<X>; c \\<in> \\<X>; i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> (xs !! j) c = (xs !! i) c \\<or> (xs !! j) c = 0", "from assms"], ["proof (chain)\npicking this:\n  PTA_Reachability.pairwise eq_elapsed xs\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  stream_trans xs\n  \\<forall>k\\<ge>i.\n     k \\<le> j \\<longrightarrow> zero x ([xs !! k]\\<^sub>\\<R>)\n  x \\<in> \\<X>\n  c \\<in> \\<X>\n  i \\<le> j", "have 2: \"pairwise eq_elapsed (sdrop i xs)\""], ["proof (prove)\nusing this:\n  PTA_Reachability.pairwise eq_elapsed xs\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  stream_trans xs\n  \\<forall>k\\<ge>i.\n     k \\<le> j \\<longrightarrow> zero x ([xs !! k]\\<^sub>\\<R>)\n  x \\<in> \\<X>\n  c \\<in> \\<X>\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. PTA_Reachability.pairwise eq_elapsed (sdrop i xs)", "by (intro pairwise_sdropD)"], ["proof (state)\nthis:\n  PTA_Reachability.pairwise eq_elapsed (sdrop i xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>PTA_Reachability.pairwise eq_elapsed xs;\n     pred_stream (\\<lambda>u. u \\<in> V) xs; stream_trans xs;\n     \\<forall>k\\<ge>i.\n        k \\<le> j \\<longrightarrow> zero x ([xs !! k]\\<^sub>\\<R>);\n     x \\<in> \\<X>; c \\<in> \\<X>; i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> (xs !! j) c = (xs !! i) c \\<or> (xs !! j) c = 0", "from assms"], ["proof (chain)\npicking this:\n  PTA_Reachability.pairwise eq_elapsed xs\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  stream_trans xs\n  \\<forall>k\\<ge>i.\n     k \\<le> j \\<longrightarrow> zero x ([xs !! k]\\<^sub>\\<R>)\n  x \\<in> \\<X>\n  c \\<in> \\<X>\n  i \\<le> j", "have 3: \"stream_trans (sdrop i xs)\""], ["proof (prove)\nusing this:\n  PTA_Reachability.pairwise eq_elapsed xs\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  stream_trans xs\n  \\<forall>k\\<ge>i.\n     k \\<le> j \\<longrightarrow> zero x ([xs !! k]\\<^sub>\\<R>)\n  x \\<in> \\<X>\n  c \\<in> \\<X>\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. stream_trans (sdrop i xs)", "by (intro pairwise_sdropD)"], ["proof (state)\nthis:\n  stream_trans (sdrop i xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>PTA_Reachability.pairwise eq_elapsed xs;\n     pred_stream (\\<lambda>u. u \\<in> V) xs; stream_trans xs;\n     \\<forall>k\\<ge>i.\n        k \\<le> j \\<longrightarrow> zero x ([xs !! k]\\<^sub>\\<R>);\n     x \\<in> \\<X>; c \\<in> \\<X>; i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> (xs !! j) c = (xs !! i) c \\<or> (xs !! j) c = 0", "from assms"], ["proof (chain)\npicking this:\n  PTA_Reachability.pairwise eq_elapsed xs\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  stream_trans xs\n  \\<forall>k\\<ge>i.\n     k \\<le> j \\<longrightarrow> zero x ([xs !! k]\\<^sub>\\<R>)\n  x \\<in> \\<X>\n  c \\<in> \\<X>\n  i \\<le> j", "have 4:\n    \"\\<forall>k\\<le>j - i. zero x ([sdrop i xs !! k]\\<^sub>\\<R>)\""], ["proof (prove)\nusing this:\n  PTA_Reachability.pairwise eq_elapsed xs\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  stream_trans xs\n  \\<forall>k\\<ge>i.\n     k \\<le> j \\<longrightarrow> zero x ([xs !! k]\\<^sub>\\<R>)\n  x \\<in> \\<X>\n  c \\<in> \\<X>\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. \\<forall>k\\<le>j - i. zero x ([sdrop i xs !! k]\\<^sub>\\<R>)", "by (simp add: le_diff_conv2 assms(6))"], ["proof (state)\nthis:\n  \\<forall>k\\<le>j - i. zero x ([sdrop i xs !! k]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>PTA_Reachability.pairwise eq_elapsed xs;\n     pred_stream (\\<lambda>u. u \\<in> V) xs; stream_trans xs;\n     \\<forall>k\\<ge>i.\n        k \\<le> j \\<longrightarrow> zero x ([xs !! k]\\<^sub>\\<R>);\n     x \\<in> \\<X>; c \\<in> \\<X>; i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> (xs !! j) c = (xs !! i) c \\<or> (xs !! j) c = 0", "from resets_mono_0'[OF 2 1 3 4 assms(5,6)] \\<open>i \\<le> j\\<close>"], ["proof (chain)\npicking this:\n  (sdrop i xs !! (j - i)) c = (sdrop i xs !! 0) c \\<or>\n  (sdrop i xs !! (j - i)) c = 0\n  i \\<le> j", "show ?thesis"], ["proof (prove)\nusing this:\n  (sdrop i xs !! (j - i)) c = (sdrop i xs !! 0) c \\<or>\n  (sdrop i xs !! (j - i)) c = 0\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. (xs !! j) c = (xs !! i) c \\<or> (xs !! j) c = 0", "by simp"], ["proof (state)\nthis:\n  (xs !! j) c = (xs !! i) c \\<or> (xs !! j) c = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma resets_mono:\n  assumes \"pairwise eq_elapsed xs\" \"pred_stream (\\<lambda> u. u \\<in> V) xs\" \"stream_trans xs\"\n          \"\\<forall> k \\<ge> i. k \\<le> j \\<longrightarrow> zero x ([xs !! k]\\<^sub>\\<R>)\" \"x \\<in> \\<X>\" \"c \\<in> \\<X>\" \"i \\<le> j\"\n  shows \"(xs !! j) c \\<le> (xs !! i) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs !! j) c \\<le> (xs !! i) c", "using assms"], ["proof (prove)\nusing this:\n  PTA_Reachability.pairwise eq_elapsed xs\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  stream_trans xs\n  \\<forall>k\\<ge>i.\n     k \\<le> j \\<longrightarrow> zero x ([xs !! k]\\<^sub>\\<R>)\n  x \\<in> \\<X>\n  c \\<in> \\<X>\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. (xs !! j) c \\<le> (xs !! i) c", "using assms"], ["proof (prove)\nusing this:\n  PTA_Reachability.pairwise eq_elapsed xs\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  stream_trans xs\n  \\<forall>k\\<ge>i.\n     k \\<le> j \\<longrightarrow> zero x ([xs !! k]\\<^sub>\\<R>)\n  x \\<in> \\<X>\n  c \\<in> \\<X>\n  i \\<le> j\n  PTA_Reachability.pairwise eq_elapsed xs\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  stream_trans xs\n  \\<forall>k\\<ge>i.\n     k \\<le> j \\<longrightarrow> zero x ([xs !! k]\\<^sub>\\<R>)\n  x \\<in> \\<X>\n  c \\<in> \\<X>\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. (xs !! j) c \\<le> (xs !! i) c", "by (auto simp: V_def dest: resets_mono'[where c = c] simp: stream.pred_set)"], ["", "lemma \\<R>_divergent_divergent_aux2:\n  fixes M :: \"(nat \\<Rightarrow> bool) set\"\n  assumes \"\\<forall> i. \\<forall> P \\<in> M. \\<exists> j \\<ge> i. P j\" \"M \\<noteq> {}\" \"finite M\"\n  shows \"\\<forall>i.\\<exists>j\\<ge>i.\\<exists>k>j.\\<exists> P \\<in> M. P j \\<and> P k \\<and> (\\<forall> m < k. j < m \\<longrightarrow> \\<not> P m)\n       \\<and> (\\<forall> Q \\<in> M. \\<exists> m \\<le> k. j < m \\<and> Q m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       \\<exists>j\\<ge>i.\n          \\<exists>k>j.\n             \\<exists>P\\<in>M.\n                P j \\<and>\n                P k \\<and>\n                (\\<forall>m<k. j < m \\<longrightarrow> \\<not> P m) \\<and>\n                (\\<forall>Q\\<in>M. \\<exists>m\\<le>k. j < m \\<and> Q m)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>j\\<ge>i.\n          \\<exists>k>j.\n             \\<exists>P\\<in>M.\n                P j \\<and>\n                P k \\<and>\n                (\\<forall>m<k. j < m \\<longrightarrow> \\<not> P m) \\<and>\n                (\\<forall>Q\\<in>M. \\<exists>m\\<le>k. j < m \\<and> Q m)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>j\\<ge>i.\n          \\<exists>k>j.\n             \\<exists>P\\<in>M.\n                P j \\<and>\n                P k \\<and>\n                (\\<forall>m<k. j < m \\<longrightarrow> \\<not> P m) \\<and>\n                (\\<forall>Q\\<in>M. \\<exists>m\\<le>k. j < m \\<and> Q m)", "let ?j1 = \"Max {LEAST m. m > i \\<and> P m | P. P \\<in> M}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>j\\<ge>i.\n          \\<exists>k>j.\n             \\<exists>P\\<in>M.\n                P j \\<and>\n                P k \\<and>\n                (\\<forall>m<k. j < m \\<longrightarrow> \\<not> P m) \\<and>\n                (\\<forall>Q\\<in>M. \\<exists>m\\<le>k. j < m \\<and> Q m)", "from \\<open>M \\<noteq> {}\\<close>"], ["proof (chain)\npicking this:\n  M \\<noteq> {}", "obtain P where \"P \\<in> M\""], ["proof (prove)\nusing this:\n  M \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>P. P \\<in> M \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  P \\<in> M\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>j\\<ge>i.\n          \\<exists>k>j.\n             \\<exists>P\\<in>M.\n                P j \\<and>\n                P k \\<and>\n                (\\<forall>m<k. j < m \\<longrightarrow> \\<not> P m) \\<and>\n                (\\<forall>Q\\<in>M. \\<exists>m\\<le>k. j < m \\<and> Q m)", "let ?m = \"LEAST m. m > i \\<and> P m\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>j\\<ge>i.\n          \\<exists>k>j.\n             \\<exists>P\\<in>M.\n                P j \\<and>\n                P k \\<and>\n                (\\<forall>m<k. j < m \\<longrightarrow> \\<not> P m) \\<and>\n                (\\<forall>Q\\<in>M. \\<exists>m\\<le>k. j < m \\<and> Q m)", "from assms(1) \\<open>P \\<in> M\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i. \\<forall>P\\<in>M. \\<exists>j\\<ge>i. P j\n  P \\<in> M", "obtain j where \"j \\<ge> Suc i\" \"P j\""], ["proof (prove)\nusing this:\n  \\<forall>i. \\<forall>P\\<in>M. \\<exists>j\\<ge>i. P j\n  P \\<in> M\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>Suc i \\<le> j; P j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Suc i \\<le> j\n  P j\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>j\\<ge>i.\n          \\<exists>k>j.\n             \\<exists>P\\<in>M.\n                P j \\<and>\n                P k \\<and>\n                (\\<forall>m<k. j < m \\<longrightarrow> \\<not> P m) \\<and>\n                (\\<forall>Q\\<in>M. \\<exists>m\\<le>k. j < m \\<and> Q m)", "then"], ["proof (chain)\npicking this:\n  Suc i \\<le> j\n  P j", "have \"j > i\" \"P j\""], ["proof (prove)\nusing this:\n  Suc i \\<le> j\n  P j\n\ngoal (1 subgoal):\n 1. i < j &&& P j", "by auto"], ["proof (state)\nthis:\n  i < j\n  P j\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>j\\<ge>i.\n          \\<exists>k>j.\n             \\<exists>P\\<in>M.\n                P j \\<and>\n                P k \\<and>\n                (\\<forall>m<k. j < m \\<longrightarrow> \\<not> P m) \\<and>\n                (\\<forall>Q\\<in>M. \\<exists>m\\<le>k. j < m \\<and> Q m)", "with \\<open>P \\<in> M\\<close>"], ["proof (chain)\npicking this:\n  P \\<in> M\n  i < j\n  P j", "have \"?m > i \\<and> P ?m\""], ["proof (prove)\nusing this:\n  P \\<in> M\n  i < j\n  P j\n\ngoal (1 subgoal):\n 1. i < (LEAST m. i < m \\<and> P m) \\<and> P (LEAST m. i < m \\<and> P m)", "by - (rule LeastI; auto)"], ["proof (state)\nthis:\n  i < (LEAST m. i < m \\<and> P m) \\<and> P (LEAST m. i < m \\<and> P m)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>j\\<ge>i.\n          \\<exists>k>j.\n             \\<exists>P\\<in>M.\n                P j \\<and>\n                P k \\<and>\n                (\\<forall>m<k. j < m \\<longrightarrow> \\<not> P m) \\<and>\n                (\\<forall>Q\\<in>M. \\<exists>m\\<le>k. j < m \\<and> Q m)", "moreover"], ["proof (state)\nthis:\n  i < (LEAST m. i < m \\<and> P m) \\<and> P (LEAST m. i < m \\<and> P m)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>j\\<ge>i.\n          \\<exists>k>j.\n             \\<exists>P\\<in>M.\n                P j \\<and>\n                P k \\<and>\n                (\\<forall>m<k. j < m \\<longrightarrow> \\<not> P m) \\<and>\n                (\\<forall>Q\\<in>M. \\<exists>m\\<le>k. j < m \\<and> Q m)", "with \\<open>finite M\\<close> \\<open>P \\<in> M\\<close>"], ["proof (chain)\npicking this:\n  finite M\n  P \\<in> M\n  i < (LEAST m. i < m \\<and> P m) \\<and> P (LEAST m. i < m \\<and> P m)", "have \"?j1 \\<ge> ?m\""], ["proof (prove)\nusing this:\n  finite M\n  P \\<in> M\n  i < (LEAST m. i < m \\<and> P m) \\<and> P (LEAST m. i < m \\<and> P m)\n\ngoal (1 subgoal):\n 1. (LEAST m. i < m \\<and> P m)\n    \\<le> Max {LEAST m. i < m \\<and> P m |P. P \\<in> M}", "by - (rule Max_ge; auto)"], ["proof (state)\nthis:\n  (LEAST m. i < m \\<and> P m)\n  \\<le> Max {LEAST m. i < m \\<and> P m |P. P \\<in> M}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>j\\<ge>i.\n          \\<exists>k>j.\n             \\<exists>P\\<in>M.\n                P j \\<and>\n                P k \\<and>\n                (\\<forall>m<k. j < m \\<longrightarrow> \\<not> P m) \\<and>\n                (\\<forall>Q\\<in>M. \\<exists>m\\<le>k. j < m \\<and> Q m)", "ultimately"], ["proof (chain)\npicking this:\n  i < (LEAST m. i < m \\<and> P m) \\<and> P (LEAST m. i < m \\<and> P m)\n  (LEAST m. i < m \\<and> P m)\n  \\<le> Max {LEAST m. i < m \\<and> P m |P. P \\<in> M}", "have \"?j1 \\<ge> i\""], ["proof (prove)\nusing this:\n  i < (LEAST m. i < m \\<and> P m) \\<and> P (LEAST m. i < m \\<and> P m)\n  (LEAST m. i < m \\<and> P m)\n  \\<le> Max {LEAST m. i < m \\<and> P m |P. P \\<in> M}\n\ngoal (1 subgoal):\n 1. i \\<le> Max {LEAST m. i < m \\<and> P m |P. P \\<in> M}", "by simp"], ["proof (state)\nthis:\n  i \\<le> Max {LEAST m. i < m \\<and> P m |P. P \\<in> M}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>j\\<ge>i.\n          \\<exists>k>j.\n             \\<exists>P\\<in>M.\n                P j \\<and>\n                P k \\<and>\n                (\\<forall>m<k. j < m \\<longrightarrow> \\<not> P m) \\<and>\n                (\\<forall>Q\\<in>M. \\<exists>m\\<le>k. j < m \\<and> Q m)", "moreover"], ["proof (state)\nthis:\n  i \\<le> Max {LEAST m. i < m \\<and> P m |P. P \\<in> M}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>j\\<ge>i.\n          \\<exists>k>j.\n             \\<exists>P\\<in>M.\n                P j \\<and>\n                P k \\<and>\n                (\\<forall>m<k. j < m \\<longrightarrow> \\<not> P m) \\<and>\n                (\\<forall>Q\\<in>M. \\<exists>m\\<le>k. j < m \\<and> Q m)", "have \"\\<exists> m > i. m \\<le> ?j1 \\<and> P m\" if \"P \\<in> M\" for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m>i.\n       m \\<le> Max {LEAST m. i < m \\<and> P m |P. P \\<in> M} \\<and> P m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>m>i.\n       m \\<le> Max {LEAST m. i < m \\<and> P m |P. P \\<in> M} \\<and> P m", "let ?m = \"LEAST m. m > i \\<and> P m\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>m>i.\n       m \\<le> Max {LEAST m. i < m \\<and> P m |P. P \\<in> M} \\<and> P m", "from assms(1) \\<open>P \\<in> M\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i. \\<forall>P\\<in>M. \\<exists>j\\<ge>i. P j\n  P \\<in> M", "obtain j where \"j \\<ge> Suc i\" \"P j\""], ["proof (prove)\nusing this:\n  \\<forall>i. \\<forall>P\\<in>M. \\<exists>j\\<ge>i. P j\n  P \\<in> M\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>Suc i \\<le> j; P j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Suc i \\<le> j\n  P j\n\ngoal (1 subgoal):\n 1. \\<exists>m>i.\n       m \\<le> Max {LEAST m. i < m \\<and> P m |P. P \\<in> M} \\<and> P m", "then"], ["proof (chain)\npicking this:\n  Suc i \\<le> j\n  P j", "have \"j > i\" \"P j\""], ["proof (prove)\nusing this:\n  Suc i \\<le> j\n  P j\n\ngoal (1 subgoal):\n 1. i < j &&& P j", "by auto"], ["proof (state)\nthis:\n  i < j\n  P j\n\ngoal (1 subgoal):\n 1. \\<exists>m>i.\n       m \\<le> Max {LEAST m. i < m \\<and> P m |P. P \\<in> M} \\<and> P m", "with \\<open>P \\<in> M\\<close>"], ["proof (chain)\npicking this:\n  P \\<in> M\n  i < j\n  P j", "have \"?m > i \\<and> P ?m\""], ["proof (prove)\nusing this:\n  P \\<in> M\n  i < j\n  P j\n\ngoal (1 subgoal):\n 1. i < (LEAST m. i < m \\<and> P m) \\<and> P (LEAST m. i < m \\<and> P m)", "by - (rule LeastI; auto)"], ["proof (state)\nthis:\n  i < (LEAST m. i < m \\<and> P m) \\<and> P (LEAST m. i < m \\<and> P m)\n\ngoal (1 subgoal):\n 1. \\<exists>m>i.\n       m \\<le> Max {LEAST m. i < m \\<and> P m |P. P \\<in> M} \\<and> P m", "moreover"], ["proof (state)\nthis:\n  i < (LEAST m. i < m \\<and> P m) \\<and> P (LEAST m. i < m \\<and> P m)\n\ngoal (1 subgoal):\n 1. \\<exists>m>i.\n       m \\<le> Max {LEAST m. i < m \\<and> P m |P. P \\<in> M} \\<and> P m", "with \\<open>finite M\\<close> \\<open>P \\<in> M\\<close>"], ["proof (chain)\npicking this:\n  finite M\n  P \\<in> M\n  i < (LEAST m. i < m \\<and> P m) \\<and> P (LEAST m. i < m \\<and> P m)", "have \"?j1 \\<ge> ?m\""], ["proof (prove)\nusing this:\n  finite M\n  P \\<in> M\n  i < (LEAST m. i < m \\<and> P m) \\<and> P (LEAST m. i < m \\<and> P m)\n\ngoal (1 subgoal):\n 1. (LEAST m. i < m \\<and> P m)\n    \\<le> Max {LEAST m. i < m \\<and> P m |P. P \\<in> M}", "by - (rule Max_ge; auto)"], ["proof (state)\nthis:\n  (LEAST m. i < m \\<and> P m)\n  \\<le> Max {LEAST m. i < m \\<and> P m |P. P \\<in> M}\n\ngoal (1 subgoal):\n 1. \\<exists>m>i.\n       m \\<le> Max {LEAST m. i < m \\<and> P m |P. P \\<in> M} \\<and> P m", "ultimately"], ["proof (chain)\npicking this:\n  i < (LEAST m. i < m \\<and> P m) \\<and> P (LEAST m. i < m \\<and> P m)\n  (LEAST m. i < m \\<and> P m)\n  \\<le> Max {LEAST m. i < m \\<and> P m |P. P \\<in> M}", "show ?thesis"], ["proof (prove)\nusing this:\n  i < (LEAST m. i < m \\<and> P m) \\<and> P (LEAST m. i < m \\<and> P m)\n  (LEAST m. i < m \\<and> P m)\n  \\<le> Max {LEAST m. i < m \\<and> P m |P. P \\<in> M}\n\ngoal (1 subgoal):\n 1. \\<exists>m>i.\n       m \\<le> Max {LEAST m. i < m \\<and> P m |P. P \\<in> M} \\<and> P m", "by auto"], ["proof (state)\nthis:\n  \\<exists>m>i.\n     m \\<le> Max {LEAST m. i < m \\<and> P m |P. P \\<in> M} \\<and> P m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?P8 \\<in> M \\<Longrightarrow>\n  \\<exists>m>i.\n     m \\<le> Max {LEAST m. i < m \\<and> P m |P. P \\<in> M} \\<and> ?P8 m\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>j\\<ge>i.\n          \\<exists>k>j.\n             \\<exists>P\\<in>M.\n                P j \\<and>\n                P k \\<and>\n                (\\<forall>m<k. j < m \\<longrightarrow> \\<not> P m) \\<and>\n                (\\<forall>Q\\<in>M. \\<exists>m\\<le>k. j < m \\<and> Q m)", "ultimately"], ["proof (chain)\npicking this:\n  i \\<le> Max {LEAST m. i < m \\<and> P m |P. P \\<in> M}\n  ?P8 \\<in> M \\<Longrightarrow>\n  \\<exists>m>i.\n     m \\<le> Max {LEAST m. i < m \\<and> P m |P. P \\<in> M} \\<and> ?P8 m", "obtain j1 where j1: \"j1 \\<ge> i\" \"\\<forall> P \\<in> M. \\<exists> m > i. j1 \\<ge> m \\<and> P m\""], ["proof (prove)\nusing this:\n  i \\<le> Max {LEAST m. i < m \\<and> P m |P. P \\<in> M}\n  ?P8 \\<in> M \\<Longrightarrow>\n  \\<exists>m>i.\n     m \\<le> Max {LEAST m. i < m \\<and> P m |P. P \\<in> M} \\<and> ?P8 m\n\ngoal (1 subgoal):\n 1. (\\<And>j1.\n        \\<lbrakk>i \\<le> j1;\n         \\<forall>P\\<in>M. \\<exists>m>i. m \\<le> j1 \\<and> P m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i \\<le> j1\n  \\<forall>P\\<in>M. \\<exists>m>i. m \\<le> j1 \\<and> P m\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>j\\<ge>i.\n          \\<exists>k>j.\n             \\<exists>P\\<in>M.\n                P j \\<and>\n                P k \\<and>\n                (\\<forall>m<k. j < m \\<longrightarrow> \\<not> P m) \\<and>\n                (\\<forall>Q\\<in>M. \\<exists>m\\<le>k. j < m \\<and> Q m)", "define k where \"k Q = (LEAST k. k > j1 \\<and> Q k)\" for Q"], ["proof (state)\nthis:\n  k ?Q = (LEAST k. j1 < k \\<and> ?Q k)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>j\\<ge>i.\n          \\<exists>k>j.\n             \\<exists>P\\<in>M.\n                P j \\<and>\n                P k \\<and>\n                (\\<forall>m<k. j < m \\<longrightarrow> \\<not> P m) \\<and>\n                (\\<forall>Q\\<in>M. \\<exists>m\\<le>k. j < m \\<and> Q m)", "let ?k = \"Max {k Q | Q. Q \\<in> M}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>j\\<ge>i.\n          \\<exists>k>j.\n             \\<exists>P\\<in>M.\n                P j \\<and>\n                P k \\<and>\n                (\\<forall>m<k. j < m \\<longrightarrow> \\<not> P m) \\<and>\n                (\\<forall>Q\\<in>M. \\<exists>m\\<le>k. j < m \\<and> Q m)", "let ?P = \"SOME P. P \\<in> M \\<and> k P = ?k\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>j\\<ge>i.\n          \\<exists>k>j.\n             \\<exists>P\\<in>M.\n                P j \\<and>\n                P k \\<and>\n                (\\<forall>m<k. j < m \\<longrightarrow> \\<not> P m) \\<and>\n                (\\<forall>Q\\<in>M. \\<exists>m\\<le>k. j < m \\<and> Q m)", "let ?j = \"Max {j. i \\<le> j \\<and> j \\<le> j1 \\<and> ?P j}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>j\\<ge>i.\n          \\<exists>k>j.\n             \\<exists>P\\<in>M.\n                P j \\<and>\n                P k \\<and>\n                (\\<forall>m<k. j < m \\<longrightarrow> \\<not> P m) \\<and>\n                (\\<forall>Q\\<in>M. \\<exists>m\\<le>k. j < m \\<and> Q m)", "have \"?k \\<in> {k Q | Q. Q \\<in> M}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max {k Q |Q. Q \\<in> M} \\<in> {k Q |Q. Q \\<in> M}", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>i. \\<forall>P\\<in>M. \\<exists>j\\<ge>i. P j\n  M \\<noteq> {}\n  finite M\n\ngoal (1 subgoal):\n 1. Max {k Q |Q. Q \\<in> M} \\<in> {k Q |Q. Q \\<in> M}", "by - (rule Max_in; auto)"], ["proof (state)\nthis:\n  Max {k Q |Q. Q \\<in> M} \\<in> {k Q |Q. Q \\<in> M}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>j\\<ge>i.\n          \\<exists>k>j.\n             \\<exists>P\\<in>M.\n                P j \\<and>\n                P k \\<and>\n                (\\<forall>m<k. j < m \\<longrightarrow> \\<not> P m) \\<and>\n                (\\<forall>Q\\<in>M. \\<exists>m\\<le>k. j < m \\<and> Q m)", "then"], ["proof (chain)\npicking this:\n  Max {k Q |Q. Q \\<in> M} \\<in> {k Q |Q. Q \\<in> M}", "obtain P where P: \"k P = ?k\" \"P \\<in> M\""], ["proof (prove)\nusing this:\n  Max {k Q |Q. Q \\<in> M} \\<in> {k Q |Q. Q \\<in> M}\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>k P = Max {k Q |Q. Q \\<in> M}; P \\<in> M\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  k P = Max {k Q |Q. Q \\<in> M}\n  P \\<in> M\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>j\\<ge>i.\n          \\<exists>k>j.\n             \\<exists>P\\<in>M.\n                P j \\<and>\n                P k \\<and>\n                (\\<forall>m<k. j < m \\<longrightarrow> \\<not> P m) \\<and>\n                (\\<forall>Q\\<in>M. \\<exists>m\\<le>k. j < m \\<and> Q m)", "have \"?k \\<ge> k Q\" if \"Q \\<in> M\" for Q"], ["proof (prove)\ngoal (1 subgoal):\n 1. k Q \\<le> Max {k Q |Q. Q \\<in> M}", "using assms that"], ["proof (prove)\nusing this:\n  \\<forall>i. \\<forall>P\\<in>M. \\<exists>j\\<ge>i. P j\n  M \\<noteq> {}\n  finite M\n  Q \\<in> M\n\ngoal (1 subgoal):\n 1. k Q \\<le> Max {k Q |Q. Q \\<in> M}", "by - (rule Max_ge; auto)"], ["proof (state)\nthis:\n  ?Q8 \\<in> M \\<Longrightarrow> k ?Q8 \\<le> Max {k Q |Q. Q \\<in> M}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>j\\<ge>i.\n          \\<exists>k>j.\n             \\<exists>P\\<in>M.\n                P j \\<and>\n                P k \\<and>\n                (\\<forall>m<k. j < m \\<longrightarrow> \\<not> P m) \\<and>\n                (\\<forall>Q\\<in>M. \\<exists>m\\<le>k. j < m \\<and> Q m)", "have *: \"?P \\<in> M \\<and> k ?P = ?k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) \\<in> M \\<and>\n    k (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) =\n    Max {k Q |Q. Q \\<in> M}", "using P"], ["proof (prove)\nusing this:\n  k P = Max {k Q |Q. Q \\<in> M}\n  P \\<in> M\n\ngoal (1 subgoal):\n 1. (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) \\<in> M \\<and>\n    k (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) =\n    Max {k Q |Q. Q \\<in> M}", "by - (rule someI[where x = P]; auto)"], ["proof (state)\nthis:\n  (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) \\<in> M \\<and>\n  k (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) =\n  Max {k Q |Q. Q \\<in> M}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>j\\<ge>i.\n          \\<exists>k>j.\n             \\<exists>P\\<in>M.\n                P j \\<and>\n                P k \\<and>\n                (\\<forall>m<k. j < m \\<longrightarrow> \\<not> P m) \\<and>\n                (\\<forall>Q\\<in>M. \\<exists>m\\<le>k. j < m \\<and> Q m)", "with j1"], ["proof (chain)\npicking this:\n  i \\<le> j1\n  \\<forall>P\\<in>M. \\<exists>m>i. m \\<le> j1 \\<and> P m\n  (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) \\<in> M \\<and>\n  k (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) =\n  Max {k Q |Q. Q \\<in> M}", "have \"\\<exists> m > i. j1 \\<ge> m \\<and> ?P m\""], ["proof (prove)\nusing this:\n  i \\<le> j1\n  \\<forall>P\\<in>M. \\<exists>m>i. m \\<le> j1 \\<and> P m\n  (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) \\<in> M \\<and>\n  k (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) =\n  Max {k Q |Q. Q \\<in> M}\n\ngoal (1 subgoal):\n 1. \\<exists>m>i.\n       m \\<le> j1 \\<and>\n       (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) m", "by auto"], ["proof (state)\nthis:\n  \\<exists>m>i.\n     m \\<le> j1 \\<and>\n     (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) m\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>j\\<ge>i.\n          \\<exists>k>j.\n             \\<exists>P\\<in>M.\n                P j \\<and>\n                P k \\<and>\n                (\\<forall>m<k. j < m \\<longrightarrow> \\<not> P m) \\<and>\n                (\\<forall>Q\\<in>M. \\<exists>m\\<le>k. j < m \\<and> Q m)", "with \\<open>finite _\\<close>"], ["proof (chain)\npicking this:\n  finite M\n  \\<exists>m>i.\n     m \\<le> j1 \\<and>\n     (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) m", "have \"?j \\<in> {j. i \\<le> j \\<and> j \\<le> j1 \\<and> ?P j}\""], ["proof (prove)\nusing this:\n  finite M\n  \\<exists>m>i.\n     m \\<le> j1 \\<and>\n     (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) m\n\ngoal (1 subgoal):\n 1. Max {j. i \\<le> j \\<and>\n            j \\<le> j1 \\<and>\n            (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n    \\<in> {j. i \\<le> j \\<and>\n              j \\<le> j1 \\<and>\n              (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}", "by - (rule Max_in; auto)"], ["proof (state)\nthis:\n  Max {j. i \\<le> j \\<and>\n          j \\<le> j1 \\<and>\n          (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n  \\<in> {j. i \\<le> j \\<and>\n            j \\<le> j1 \\<and>\n            (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>j\\<ge>i.\n          \\<exists>k>j.\n             \\<exists>P\\<in>M.\n                P j \\<and>\n                P k \\<and>\n                (\\<forall>m<k. j < m \\<longrightarrow> \\<not> P m) \\<and>\n                (\\<forall>Q\\<in>M. \\<exists>m\\<le>k. j < m \\<and> Q m)", "have k: \"k Q > j1 \\<and> Q (k Q)\" if \"Q \\<in> M\" for Q"], ["proof (prove)\ngoal (1 subgoal):\n 1. j1 < k Q \\<and> Q (k Q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. j1 < k Q \\<and> Q (k Q)", "from assms(1) \\<open>Q \\<in> M\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i. \\<forall>P\\<in>M. \\<exists>j\\<ge>i. P j\n  Q \\<in> M", "obtain m where \"m \\<ge> Suc j1\" \"Q m\""], ["proof (prove)\nusing this:\n  \\<forall>i. \\<forall>P\\<in>M. \\<exists>j\\<ge>i. P j\n  Q \\<in> M\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>Suc j1 \\<le> m; Q m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Suc j1 \\<le> m\n  Q m\n\ngoal (1 subgoal):\n 1. j1 < k Q \\<and> Q (k Q)", "then"], ["proof (chain)\npicking this:\n  Suc j1 \\<le> m\n  Q m", "have \"m > j1\" \"Q m\""], ["proof (prove)\nusing this:\n  Suc j1 \\<le> m\n  Q m\n\ngoal (1 subgoal):\n 1. j1 < m &&& Q m", "by auto"], ["proof (state)\nthis:\n  j1 < m\n  Q m\n\ngoal (1 subgoal):\n 1. j1 < k Q \\<and> Q (k Q)", "then"], ["proof (chain)\npicking this:\n  j1 < m\n  Q m", "show \"k Q > j1 \\<and> Q (k Q)\""], ["proof (prove)\nusing this:\n  j1 < m\n  Q m\n\ngoal (1 subgoal):\n 1. j1 < k Q \\<and> Q (k Q)", "unfolding k_def"], ["proof (prove)\nusing this:\n  j1 < m\n  Q m\n\ngoal (1 subgoal):\n 1. j1 < (LEAST k. j1 < k \\<and> Q k) \\<and> Q (LEAST k. j1 < k \\<and> Q k)", "by - (rule LeastI; blast)"], ["proof (state)\nthis:\n  j1 < k Q \\<and> Q (k Q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?Q8 \\<in> M \\<Longrightarrow> j1 < k ?Q8 \\<and> ?Q8 (k ?Q8)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>j\\<ge>i.\n          \\<exists>k>j.\n             \\<exists>P\\<in>M.\n                P j \\<and>\n                P k \\<and>\n                (\\<forall>m<k. j < m \\<longrightarrow> \\<not> P m) \\<and>\n                (\\<forall>Q\\<in>M. \\<exists>m\\<le>k. j < m \\<and> Q m)", "with * \\<open>?j \\<in> _\\<close>"], ["proof (chain)\npicking this:\n  (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) \\<in> M \\<and>\n  k (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) =\n  Max {k Q |Q. Q \\<in> M}\n  Max {j. i \\<le> j \\<and>\n          j \\<le> j1 \\<and>\n          (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n  \\<in> {j. i \\<le> j \\<and>\n            j \\<le> j1 \\<and>\n            (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n  ?Q8 \\<in> M \\<Longrightarrow> j1 < k ?Q8 \\<and> ?Q8 (k ?Q8)", "have \"?P ?k\" \"?j < ?k\""], ["proof (prove)\nusing this:\n  (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) \\<in> M \\<and>\n  k (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) =\n  Max {k Q |Q. Q \\<in> M}\n  Max {j. i \\<le> j \\<and>\n          j \\<le> j1 \\<and>\n          (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n  \\<in> {j. i \\<le> j \\<and>\n            j \\<le> j1 \\<and>\n            (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n  ?Q8 \\<in> M \\<Longrightarrow> j1 < k ?Q8 \\<and> ?Q8 (k ?Q8)\n\ngoal (1 subgoal):\n 1. (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M})\n     (Max {k Q |Q. Q \\<in> M}) &&&\n    Max {j. i \\<le> j \\<and>\n            j \\<le> j1 \\<and>\n            (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n    < Max {k Q |Q. Q \\<in> M}", "by fastforce+"], ["proof (state)\nthis:\n  (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M})\n   (Max {k Q |Q. Q \\<in> M})\n  Max {j. i \\<le> j \\<and>\n          j \\<le> j1 \\<and>\n          (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n  < Max {k Q |Q. Q \\<in> M}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>j\\<ge>i.\n          \\<exists>k>j.\n             \\<exists>P\\<in>M.\n                P j \\<and>\n                P k \\<and>\n                (\\<forall>m<k. j < m \\<longrightarrow> \\<not> P m) \\<and>\n                (\\<forall>Q\\<in>M. \\<exists>m\\<le>k. j < m \\<and> Q m)", "have \"\\<not> ?P m\" if \"?j < m\" \"m < ?k\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) m", "proof (rule ccontr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M})\n     m \\<Longrightarrow>\n    False", "assume \"?P m\""], ["proof (state)\nthis:\n  (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) m\n\ngoal (1 subgoal):\n 1. (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M})\n     m \\<Longrightarrow>\n    False", "have \"m > j1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j1 < m", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j1 < m \\<Longrightarrow> False", "assume \"\\<not> j1 < m\""], ["proof (state)\nthis:\n  \\<not> j1 < m\n\ngoal (1 subgoal):\n 1. \\<not> j1 < m \\<Longrightarrow> False", "with \\<open>?j < m\\<close> \\<open>?j \\<in> _\\<close>"], ["proof (chain)\npicking this:\n  Max {j. i \\<le> j \\<and>\n          j \\<le> j1 \\<and>\n          (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n  < m\n  Max {j. i \\<le> j \\<and>\n          j \\<le> j1 \\<and>\n          (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n  \\<in> {j. i \\<le> j \\<and>\n            j \\<le> j1 \\<and>\n            (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n  \\<not> j1 < m", "have \"i \\<le> m\" \"m \\<le> j1\""], ["proof (prove)\nusing this:\n  Max {j. i \\<le> j \\<and>\n          j \\<le> j1 \\<and>\n          (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n  < m\n  Max {j. i \\<le> j \\<and>\n          j \\<le> j1 \\<and>\n          (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n  \\<in> {j. i \\<le> j \\<and>\n            j \\<le> j1 \\<and>\n            (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n  \\<not> j1 < m\n\ngoal (1 subgoal):\n 1. i \\<le> m &&& m \\<le> j1", "by auto"], ["proof (state)\nthis:\n  i \\<le> m\n  m \\<le> j1\n\ngoal (1 subgoal):\n 1. \\<not> j1 < m \\<Longrightarrow> False", "with \\<open>?P m\\<close> \\<open>finite _\\<close>"], ["proof (chain)\npicking this:\n  (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) m\n  finite M\n  i \\<le> m\n  m \\<le> j1", "have \"?j \\<ge> m\""], ["proof (prove)\nusing this:\n  (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) m\n  finite M\n  i \\<le> m\n  m \\<le> j1\n\ngoal (1 subgoal):\n 1. m \\<le> Max {j. i \\<le> j \\<and>\n                    j \\<le> j1 \\<and>\n                    (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M})\n                     j}", "by - (rule Max_ge; auto)"], ["proof (state)\nthis:\n  m \\<le> Max {j. i \\<le> j \\<and>\n                  j \\<le> j1 \\<and>\n                  (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M})\n                   j}\n\ngoal (1 subgoal):\n 1. \\<not> j1 < m \\<Longrightarrow> False", "with \\<open>?j < m\\<close>"], ["proof (chain)\npicking this:\n  Max {j. i \\<le> j \\<and>\n          j \\<le> j1 \\<and>\n          (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n  < m\n  m \\<le> Max {j. i \\<le> j \\<and>\n                  j \\<le> j1 \\<and>\n                  (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M})\n                   j}", "show False"], ["proof (prove)\nusing this:\n  Max {j. i \\<le> j \\<and>\n          j \\<le> j1 \\<and>\n          (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n  < m\n  m \\<le> Max {j. i \\<le> j \\<and>\n                  j \\<le> j1 \\<and>\n                  (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M})\n                   j}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  j1 < m\n\ngoal (1 subgoal):\n 1. (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M})\n     m \\<Longrightarrow>\n    False", "with \\<open>?P m\\<close> \\<open>finite _\\<close>"], ["proof (chain)\npicking this:\n  (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) m\n  finite M\n  j1 < m", "have \"k ?P \\<le> m\""], ["proof (prove)\nusing this:\n  (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) m\n  finite M\n  j1 < m\n\ngoal (1 subgoal):\n 1. k (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) \\<le> m", "unfolding k_def"], ["proof (prove)\nusing this:\n  (SOME P.\n      P \\<in> M \\<and>\n      (LEAST k. j1 < k \\<and> P k) =\n      Max {LEAST k. j1 < k \\<and> Q k |Q. Q \\<in> M})\n   m\n  finite M\n  j1 < m\n\ngoal (1 subgoal):\n 1. (LEAST k.\n        j1 < k \\<and>\n        (SOME P.\n            P \\<in> M \\<and>\n            (LEAST k. j1 < k \\<and> P k) =\n            Max {LEAST k. j1 < k \\<and> Q k |Q. Q \\<in> M})\n         k)\n    \\<le> m", "by (auto intro: Least_le)"], ["proof (state)\nthis:\n  k (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) \\<le> m\n\ngoal (1 subgoal):\n 1. (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M})\n     m \\<Longrightarrow>\n    False", "with * \\<open>m < ?k\\<close>"], ["proof (chain)\npicking this:\n  (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) \\<in> M \\<and>\n  k (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) =\n  Max {k Q |Q. Q \\<in> M}\n  m < Max {k Q |Q. Q \\<in> M}\n  k (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) \\<le> m", "show False"], ["proof (prove)\nusing this:\n  (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) \\<in> M \\<and>\n  k (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) =\n  Max {k Q |Q. Q \\<in> M}\n  m < Max {k Q |Q. Q \\<in> M}\n  k (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) \\<le> m\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>Max {j. i \\<le> j \\<and>\n                   j \\<le> j1 \\<and>\n                   (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M})\n                    j}\n           < ?m8;\n   ?m8 < Max {k Q |Q. Q \\<in> M}\\<rbrakk>\n  \\<Longrightarrow> \\<not> (SOME P.\n                               P \\<in> M \\<and>\n                               k P = Max {k Q |Q. Q \\<in> M})\n                            ?m8\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>j\\<ge>i.\n          \\<exists>k>j.\n             \\<exists>P\\<in>M.\n                P j \\<and>\n                P k \\<and>\n                (\\<forall>m<k. j < m \\<longrightarrow> \\<not> P m) \\<and>\n                (\\<forall>Q\\<in>M. \\<exists>m\\<le>k. j < m \\<and> Q m)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>Max {j. i \\<le> j \\<and>\n                   j \\<le> j1 \\<and>\n                   (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M})\n                    j}\n           < ?m8;\n   ?m8 < Max {k Q |Q. Q \\<in> M}\\<rbrakk>\n  \\<Longrightarrow> \\<not> (SOME P.\n                               P \\<in> M \\<and>\n                               k P = Max {k Q |Q. Q \\<in> M})\n                            ?m8\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>j\\<ge>i.\n          \\<exists>k>j.\n             \\<exists>P\\<in>M.\n                P j \\<and>\n                P k \\<and>\n                (\\<forall>m<k. j < m \\<longrightarrow> \\<not> P m) \\<and>\n                (\\<forall>Q\\<in>M. \\<exists>m\\<le>k. j < m \\<and> Q m)", "have \"\\<exists> m \\<le> ?k. ?j < m \\<and> Q m\" if \"Q \\<in> M\" for Q"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>Max {k Q |Q. Q \\<in> M}.\n       Max {j. i \\<le> j \\<and>\n               j \\<le> j1 \\<and>\n               (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n       < m \\<and>\n       Q m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>Max {k Q |Q. Q \\<in> M}.\n       Max {j. i \\<le> j \\<and>\n               j \\<le> j1 \\<and>\n               (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n       < m \\<and>\n       Q m", "from k[OF \\<open>Q \\<in> M\\<close>]"], ["proof (chain)\npicking this:\n  j1 < k Q \\<and> Q (k Q)", "have \"k Q > j1 \\<and> Q (k Q)\""], ["proof (prove)\nusing this:\n  j1 < k Q \\<and> Q (k Q)\n\ngoal (1 subgoal):\n 1. j1 < k Q \\<and> Q (k Q)", "."], ["proof (state)\nthis:\n  j1 < k Q \\<and> Q (k Q)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>Max {k Q |Q. Q \\<in> M}.\n       Max {j. i \\<le> j \\<and>\n               j \\<le> j1 \\<and>\n               (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n       < m \\<and>\n       Q m", "moreover"], ["proof (state)\nthis:\n  j1 < k Q \\<and> Q (k Q)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>Max {k Q |Q. Q \\<in> M}.\n       Max {j. i \\<le> j \\<and>\n               j \\<le> j1 \\<and>\n               (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n       < m \\<and>\n       Q m", "with \\<open>finite _\\<close> \\<open>Q \\<in> M\\<close>"], ["proof (chain)\npicking this:\n  finite M\n  Q \\<in> M\n  j1 < k Q \\<and> Q (k Q)", "have \"k Q \\<le> ?k\""], ["proof (prove)\nusing this:\n  finite M\n  Q \\<in> M\n  j1 < k Q \\<and> Q (k Q)\n\ngoal (1 subgoal):\n 1. k Q \\<le> Max {k Q |Q. Q \\<in> M}", "by - (rule Max_ge; auto)"], ["proof (state)\nthis:\n  k Q \\<le> Max {k Q |Q. Q \\<in> M}\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>Max {k Q |Q. Q \\<in> M}.\n       Max {j. i \\<le> j \\<and>\n               j \\<le> j1 \\<and>\n               (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n       < m \\<and>\n       Q m", "moreover"], ["proof (state)\nthis:\n  k Q \\<le> Max {k Q |Q. Q \\<in> M}\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>Max {k Q |Q. Q \\<in> M}.\n       Max {j. i \\<le> j \\<and>\n               j \\<le> j1 \\<and>\n               (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n       < m \\<and>\n       Q m", "with \\<open>?j \\<in> _\\<close> \\<open>k Q > _ \\<and> _\\<close>"], ["proof (chain)\npicking this:\n  Max {j. i \\<le> j \\<and>\n          j \\<le> j1 \\<and>\n          (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n  \\<in> {j. i \\<le> j \\<and>\n            j \\<le> j1 \\<and>\n            (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n  j1 < k Q \\<and> Q (k Q)\n  k Q \\<le> Max {k Q |Q. Q \\<in> M}", "have \"?j < k Q\""], ["proof (prove)\nusing this:\n  Max {j. i \\<le> j \\<and>\n          j \\<le> j1 \\<and>\n          (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n  \\<in> {j. i \\<le> j \\<and>\n            j \\<le> j1 \\<and>\n            (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n  j1 < k Q \\<and> Q (k Q)\n  k Q \\<le> Max {k Q |Q. Q \\<in> M}\n\ngoal (1 subgoal):\n 1. Max {j. i \\<le> j \\<and>\n            j \\<le> j1 \\<and>\n            (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n    < k Q", "by auto"], ["proof (state)\nthis:\n  Max {j. i \\<le> j \\<and>\n          j \\<le> j1 \\<and>\n          (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n  < k Q\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>Max {k Q |Q. Q \\<in> M}.\n       Max {j. i \\<le> j \\<and>\n               j \\<le> j1 \\<and>\n               (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n       < m \\<and>\n       Q m", "ultimately"], ["proof (chain)\npicking this:\n  j1 < k Q \\<and> Q (k Q)\n  k Q \\<le> Max {k Q |Q. Q \\<in> M}\n  Max {j. i \\<le> j \\<and>\n          j \\<le> j1 \\<and>\n          (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n  < k Q", "show ?thesis"], ["proof (prove)\nusing this:\n  j1 < k Q \\<and> Q (k Q)\n  k Q \\<le> Max {k Q |Q. Q \\<in> M}\n  Max {j. i \\<le> j \\<and>\n          j \\<le> j1 \\<and>\n          (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n  < k Q\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>Max {k Q |Q. Q \\<in> M}.\n       Max {j. i \\<le> j \\<and>\n               j \\<le> j1 \\<and>\n               (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n       < m \\<and>\n       Q m", "by auto"], ["proof (state)\nthis:\n  \\<exists>m\\<le>Max {k Q |Q. Q \\<in> M}.\n     Max {j. i \\<le> j \\<and>\n             j \\<le> j1 \\<and>\n             (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n     < m \\<and>\n     Q m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?Q8 \\<in> M \\<Longrightarrow>\n  \\<exists>m\\<le>Max {k Q |Q. Q \\<in> M}.\n     Max {j. i \\<le> j \\<and>\n             j \\<le> j1 \\<and>\n             (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n     < m \\<and>\n     ?Q8 m\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>j\\<ge>i.\n          \\<exists>k>j.\n             \\<exists>P\\<in>M.\n                P j \\<and>\n                P k \\<and>\n                (\\<forall>m<k. j < m \\<longrightarrow> \\<not> P m) \\<and>\n                (\\<forall>Q\\<in>M. \\<exists>m\\<le>k. j < m \\<and> Q m)", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>Max {j. i \\<le> j \\<and>\n                   j \\<le> j1 \\<and>\n                   (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M})\n                    j}\n           < ?m8;\n   ?m8 < Max {k Q |Q. Q \\<in> M}\\<rbrakk>\n  \\<Longrightarrow> \\<not> (SOME P.\n                               P \\<in> M \\<and>\n                               k P = Max {k Q |Q. Q \\<in> M})\n                            ?m8\n  ?Q8 \\<in> M \\<Longrightarrow>\n  \\<exists>m\\<le>Max {k Q |Q. Q \\<in> M}.\n     Max {j. i \\<le> j \\<and>\n             j \\<le> j1 \\<and>\n             (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n     < m \\<and>\n     ?Q8 m", "show\n    \"\\<exists>j\\<ge>i.\\<exists>k>j.\\<exists> P \\<in> M. P j \\<and> P k \\<and> (\\<forall> m < k. j < m \\<longrightarrow> \\<not> P m)\n       \\<and> (\\<forall> Q \\<in> M. \\<exists> m \\<le> k. j < m \\<and> Q m)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>Max {j. i \\<le> j \\<and>\n                   j \\<le> j1 \\<and>\n                   (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M})\n                    j}\n           < ?m8;\n   ?m8 < Max {k Q |Q. Q \\<in> M}\\<rbrakk>\n  \\<Longrightarrow> \\<not> (SOME P.\n                               P \\<in> M \\<and>\n                               k P = Max {k Q |Q. Q \\<in> M})\n                            ?m8\n  ?Q8 \\<in> M \\<Longrightarrow>\n  \\<exists>m\\<le>Max {k Q |Q. Q \\<in> M}.\n     Max {j. i \\<le> j \\<and>\n             j \\<le> j1 \\<and>\n             (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n     < m \\<and>\n     ?Q8 m\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i.\n       \\<exists>k>j.\n          \\<exists>P\\<in>M.\n             P j \\<and>\n             P k \\<and>\n             (\\<forall>m<k. j < m \\<longrightarrow> \\<not> P m) \\<and>\n             (\\<forall>Q\\<in>M. \\<exists>m\\<le>k. j < m \\<and> Q m)", "using \\<open>?j < ?k\\<close> \\<open>?j \\<in> _\\<close> \\<open>?P ?k\\<close> *"], ["proof (prove)\nusing this:\n  \\<lbrakk>Max {j. i \\<le> j \\<and>\n                   j \\<le> j1 \\<and>\n                   (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M})\n                    j}\n           < ?m8;\n   ?m8 < Max {k Q |Q. Q \\<in> M}\\<rbrakk>\n  \\<Longrightarrow> \\<not> (SOME P.\n                               P \\<in> M \\<and>\n                               k P = Max {k Q |Q. Q \\<in> M})\n                            ?m8\n  ?Q8 \\<in> M \\<Longrightarrow>\n  \\<exists>m\\<le>Max {k Q |Q. Q \\<in> M}.\n     Max {j. i \\<le> j \\<and>\n             j \\<le> j1 \\<and>\n             (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n     < m \\<and>\n     ?Q8 m\n  Max {j. i \\<le> j \\<and>\n          j \\<le> j1 \\<and>\n          (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n  < Max {k Q |Q. Q \\<in> M}\n  Max {j. i \\<le> j \\<and>\n          j \\<le> j1 \\<and>\n          (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n  \\<in> {j. i \\<le> j \\<and>\n            j \\<le> j1 \\<and>\n            (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) j}\n  (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M})\n   (Max {k Q |Q. Q \\<in> M})\n  (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) \\<in> M \\<and>\n  k (SOME P. P \\<in> M \\<and> k P = Max {k Q |Q. Q \\<in> M}) =\n  Max {k Q |Q. Q \\<in> M}\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i.\n       \\<exists>k>j.\n          \\<exists>P\\<in>M.\n             P j \\<and>\n             P k \\<and>\n             (\\<forall>m<k. j < m \\<longrightarrow> \\<not> P m) \\<and>\n             (\\<forall>Q\\<in>M. \\<exists>m\\<le>k. j < m \\<and> Q m)", "by (inst_existentials ?j ?k ?P; blast)"], ["proof (state)\nthis:\n  \\<exists>j\\<ge>i.\n     \\<exists>k>j.\n        \\<exists>P\\<in>M.\n           P j \\<and>\n           P k \\<and>\n           (\\<forall>m<k. j < m \\<longrightarrow> \\<not> P m) \\<and>\n           (\\<forall>Q\\<in>M. \\<exists>m\\<le>k. j < m \\<and> Q m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<R>_divergent_divergent:\n  assumes in_S: \"pred_stream (\\<lambda> u. u \\<in> V) xs\"\n    and div: \"\\<R>_div (smap (\\<lambda> u. [u]\\<^sub>\\<R>) xs)\"\n    and trans: \"stream_trans xs\"\n    and trans': \"pairwise trans' xs\"\n    and unbounded_not_const:\n    \"\\<forall>u. (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<longrightarrow> \\<not> ev (alw (\\<lambda>xs. shd xs = u)) xs\"\n  shows \"divergent xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. divergent xs", "unfolding divergent_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t. \\<exists>n. t < dur xs n", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t. \\<exists>n. t < dur xs n", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t. \\<exists>n. t < dur xs n", "from pairwise_trans_eq_elapsed[OF trans in_S]"], ["proof (chain)\npicking this:\n  PTA_Reachability.pairwise eq_elapsed xs", "have eq_elapsed: \"pairwise eq_elapsed xs\""], ["proof (prove)\nusing this:\n  PTA_Reachability.pairwise eq_elapsed xs\n\ngoal (1 subgoal):\n 1. PTA_Reachability.pairwise eq_elapsed xs", "."], ["proof (state)\nthis:\n  PTA_Reachability.pairwise eq_elapsed xs\n\ngoal (1 subgoal):\n 1. \\<And>t. \\<exists>n. t < dur xs n", "define X1 where \"X1 = {x. x \\<in> \\<X> \\<and> (\\<exists>i. \\<forall> j \\<ge> i. unbounded x ([xs !! j]\\<^sub>\\<R>))}\""], ["proof (state)\nthis:\n  X1 =\n  {x \\<in> \\<X>.\n   \\<exists>i. \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>)}\n\ngoal (1 subgoal):\n 1. \\<And>t. \\<exists>n. t < dur xs n", "let ?i = \"Max {(SOME i. \\<forall> j \\<ge> i. unbounded x ([xs !! j]\\<^sub>\\<R>)) | x. x \\<in> \\<X>}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t. \\<exists>n. t < dur xs n", "from finite(1) non_empty"], ["proof (chain)\npicking this:\n  finite \\<X>\n  \\<X> \\<noteq> {}", "have\n    \"?i \\<in> {(SOME i. \\<forall> j \\<ge> i. unbounded x ([xs !! j]\\<^sub>\\<R>)) | x. x \\<in> \\<X>}\""], ["proof (prove)\nusing this:\n  finite \\<X>\n  \\<X> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Max {SOME i. \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>) |x.\n         x \\<in> \\<X>}\n    \\<in> {SOME i. \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>) |x.\n           x \\<in> \\<X>}", "by (intro Max_in) auto"], ["proof (state)\nthis:\n  Max {SOME i. \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>) |x.\n       x \\<in> \\<X>}\n  \\<in> {SOME i. \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>) |x.\n         x \\<in> \\<X>}\n\ngoal (1 subgoal):\n 1. \\<And>t. \\<exists>n. t < dur xs n", "have \"unbounded x ([xs !! j]\\<^sub>\\<R>)\" if \"x \\<in> X1\" \"j \\<ge> ?i\" for x j"], ["proof (prove)\ngoal (1 subgoal):\n 1. unbounded x ([xs !! j]\\<^sub>\\<R>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. unbounded x ([xs !! j]\\<^sub>\\<R>)", "have \"X1 \\<subseteq> \\<X>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X1 \\<subseteq> \\<X>", "unfolding X1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> \\<X>.\n     \\<exists>i. \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>)}\n    \\<subseteq> \\<X>", "by auto"], ["proof (state)\nthis:\n  X1 \\<subseteq> \\<X>\n\ngoal (1 subgoal):\n 1. unbounded x ([xs !! j]\\<^sub>\\<R>)", "with finite(1) non_empty \\<open>x \\<in> X1\\<close>"], ["proof (chain)\npicking this:\n  finite \\<X>\n  \\<X> \\<noteq> {}\n  x \\<in> X1\n  X1 \\<subseteq> \\<X>", "have *:\n      \"?i \\<ge> (SOME i. \\<forall> j \\<ge> i. unbounded x ([xs !! j]\\<^sub>\\<R>))\" (is \"?i \\<ge> ?k\")"], ["proof (prove)\nusing this:\n  finite \\<X>\n  \\<X> \\<noteq> {}\n  x \\<in> X1\n  X1 \\<subseteq> \\<X>\n\ngoal (1 subgoal):\n 1. (SOME i. \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>))\n    \\<le> Max {SOME i.\n                  \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>) |\n               x. x \\<in> \\<X>}", "by (intro Max_ge) auto"], ["proof (state)\nthis:\n  (SOME i. \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>))\n  \\<le> Max {SOME i. \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>) |\n             x. x \\<in> \\<X>}\n\ngoal (1 subgoal):\n 1. unbounded x ([xs !! j]\\<^sub>\\<R>)", "from \\<open>x \\<in> X1\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> X1", "have \"\\<exists> k. \\<forall> j \\<ge> k. unbounded x ([xs !! j]\\<^sub>\\<R>)\""], ["proof (prove)\nusing this:\n  x \\<in> X1\n\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>j\\<ge>k. unbounded x ([xs !! j]\\<^sub>\\<R>)", "by (auto simp: X1_def)"], ["proof (state)\nthis:\n  \\<exists>k. \\<forall>j\\<ge>k. unbounded x ([xs !! j]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. unbounded x ([xs !! j]\\<^sub>\\<R>)", "then"], ["proof (chain)\npicking this:\n  \\<exists>k. \\<forall>j\\<ge>k. unbounded x ([xs !! j]\\<^sub>\\<R>)", "have \"\\<forall> j \\<ge> ?k. unbounded x ([xs !! j]\\<^sub>\\<R>)\""], ["proof (prove)\nusing this:\n  \\<exists>k. \\<forall>j\\<ge>k. unbounded x ([xs !! j]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. \\<forall>j\\<ge>SOME i.\n                      \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>).\n       unbounded x ([xs !! j]\\<^sub>\\<R>)", "by (rule someI_ex)"], ["proof (state)\nthis:\n  \\<forall>j\\<ge>SOME i.\n                    \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>).\n     unbounded x ([xs !! j]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. unbounded x ([xs !! j]\\<^sub>\\<R>)", "moreover"], ["proof (state)\nthis:\n  \\<forall>j\\<ge>SOME i.\n                    \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>).\n     unbounded x ([xs !! j]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. unbounded x ([xs !! j]\\<^sub>\\<R>)", "from \\<open>j \\<ge> ?i\\<close> \\<open>?i \\<ge> _\\<close>"], ["proof (chain)\npicking this:\n  Max {SOME i. \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>) |x.\n       x \\<in> \\<X>}\n  \\<le> j\n  (SOME i. \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>))\n  \\<le> Max {SOME i. \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>) |\n             x. x \\<in> \\<X>}", "have \"j \\<ge> ?k\""], ["proof (prove)\nusing this:\n  Max {SOME i. \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>) |x.\n       x \\<in> \\<X>}\n  \\<le> j\n  (SOME i. \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>))\n  \\<le> Max {SOME i. \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>) |\n             x. x \\<in> \\<X>}\n\ngoal (1 subgoal):\n 1. (SOME i. \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>)) \\<le> j", "by auto"], ["proof (state)\nthis:\n  (SOME i. \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>)) \\<le> j\n\ngoal (1 subgoal):\n 1. unbounded x ([xs !! j]\\<^sub>\\<R>)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>j\\<ge>SOME i.\n                    \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>).\n     unbounded x ([xs !! j]\\<^sub>\\<R>)\n  (SOME i. \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>)) \\<le> j", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>j\\<ge>SOME i.\n                    \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>).\n     unbounded x ([xs !! j]\\<^sub>\\<R>)\n  (SOME i. \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>)) \\<le> j\n\ngoal (1 subgoal):\n 1. unbounded x ([xs !! j]\\<^sub>\\<R>)", "by blast"], ["proof (state)\nthis:\n  unbounded x ([xs !! j]\\<^sub>\\<R>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?x8 \\<in> X1;\n   Max {SOME i. \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>) |x.\n        x \\<in> \\<X>}\n   \\<le> ?j8\\<rbrakk>\n  \\<Longrightarrow> unbounded ?x8 ([xs !! ?j8]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. \\<And>t. \\<exists>n. t < dur xs n", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x8 \\<in> X1;\n   Max {SOME i. \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>) |x.\n        x \\<in> \\<X>}\n   \\<le> ?j8\\<rbrakk>\n  \\<Longrightarrow> unbounded ?x8 ([xs !! ?j8]\\<^sub>\\<R>)", "obtain i where unbounded: \"\\<forall> x \\<in> X1. \\<forall> j \\<ge> i. unbounded x ([xs !! j]\\<^sub>\\<R>)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x8 \\<in> X1;\n   Max {SOME i. \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>) |x.\n        x \\<in> \\<X>}\n   \\<le> ?j8\\<rbrakk>\n  \\<Longrightarrow> unbounded ?x8 ([xs !! ?j8]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<forall>x\\<in>X1.\n           \\<forall>j\\<ge>i.\n              unbounded x ([xs !! j]\\<^sub>\\<R>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using finite"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x8 \\<in> X1;\n   Max {SOME i. \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>) |x.\n        x \\<in> \\<X>}\n   \\<le> ?j8\\<rbrakk>\n  \\<Longrightarrow> unbounded ?x8 ([xs !! ?j8]\\<^sub>\\<R>)\n  finite \\<X>\n  finite L\n  finite (PTA.trans_of A)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<forall>x\\<in>X1.\n           \\<forall>j\\<ge>i.\n              unbounded x ([xs !! j]\\<^sub>\\<R>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>X1. \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. \\<And>t. \\<exists>n. t < dur xs n", "show \"\\<exists> n. t < dur xs n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. t < dur xs n", "proof (cases \"\\<forall> x \\<in> \\<X>. (\\<exists>i. \\<forall> j \\<ge> i. unbounded x ([xs !! j]\\<^sub>\\<R>))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>\\<X>.\n       \\<exists>i.\n          \\<forall>j\\<ge>i.\n             unbounded x ([xs !! j]\\<^sub>\\<R>) \\<Longrightarrow>\n    \\<exists>n. t < dur xs n\n 2. \\<not> (\\<forall>x\\<in>\\<X>.\n               \\<exists>i.\n                  \\<forall>j\\<ge>i.\n                     unbounded x ([xs !! j]\\<^sub>\\<R>)) \\<Longrightarrow>\n    \\<exists>n. t < dur xs n", "case True"], ["proof (state)\nthis:\n  \\<forall>x\\<in>\\<X>.\n     \\<exists>i. \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>)\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>\\<X>.\n       \\<exists>i.\n          \\<forall>j\\<ge>i.\n             unbounded x ([xs !! j]\\<^sub>\\<R>) \\<Longrightarrow>\n    \\<exists>n. t < dur xs n\n 2. \\<not> (\\<forall>x\\<in>\\<X>.\n               \\<exists>i.\n                  \\<forall>j\\<ge>i.\n                     unbounded x ([xs !! j]\\<^sub>\\<R>)) \\<Longrightarrow>\n    \\<exists>n. t < dur xs n", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>\\<X>.\n     \\<exists>i. \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>)", "have \"X1 = \\<X>\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>\\<X>.\n     \\<exists>i. \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. X1 = \\<X>", "unfolding X1_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>\\<X>.\n     \\<exists>i. \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. {x \\<in> \\<X>.\n     \\<exists>i. \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>)} =\n    \\<X>", "by auto"], ["proof (state)\nthis:\n  X1 = \\<X>\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>\\<X>.\n       \\<exists>i.\n          \\<forall>j\\<ge>i.\n             unbounded x ([xs !! j]\\<^sub>\\<R>) \\<Longrightarrow>\n    \\<exists>n. t < dur xs n\n 2. \\<not> (\\<forall>x\\<in>\\<X>.\n               \\<exists>i.\n                  \\<forall>j\\<ge>i.\n                     unbounded x ([xs !! j]\\<^sub>\\<R>)) \\<Longrightarrow>\n    \\<exists>n. t < dur xs n", "have \"\\<exists>k\\<ge>j. 0.5 \\<le> dur xs k - dur xs j\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k\\<ge>j. 5 / 10 \\<le> dur xs k - dur xs j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k\\<ge>j. 5 / 10 \\<le> dur xs k - dur xs j", "let ?u = \"xs !! max i j\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k\\<ge>j. 5 / 10 \\<le> dur xs k - dur xs j", "from in_S"], ["proof (chain)\npicking this:\n  pred_stream (\\<lambda>u. u \\<in> V) xs", "have \"?u \\<in> [?u]\\<^sub>\\<R>\" \"[?u]\\<^sub>\\<R> \\<in> \\<R>\""], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n\ngoal (1 subgoal):\n 1. xs !! max i j \\<in> [xs !! max i j]\\<^sub>\\<R> &&&\n    [xs !! max i j]\\<^sub>\\<R> \\<in> \\<R>", "by (auto simp: stream.pred_set)"], ["proof (state)\nthis:\n  xs !! max i j \\<in> [xs !! max i j]\\<^sub>\\<R>\n  [xs !! max i j]\\<^sub>\\<R> \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<ge>j. 5 / 10 \\<le> dur xs k - dur xs j", "moreover"], ["proof (state)\nthis:\n  xs !! max i j \\<in> [xs !! max i j]\\<^sub>\\<R>\n  [xs !! max i j]\\<^sub>\\<R> \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<ge>j. 5 / 10 \\<le> dur xs k - dur xs j", "from unbounded \\<open>X1 = \\<X>\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>X1. \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>)\n  X1 = \\<X>", "have\n        \"\\<forall> x \\<in> \\<X>. unbounded x ([?u]\\<^sub>\\<R>)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>X1. \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>)\n  X1 = \\<X>\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>\\<X>. unbounded x ([xs !! max i j]\\<^sub>\\<R>)", "by force"], ["proof (state)\nthis:\n  \\<forall>x\\<in>\\<X>. unbounded x ([xs !! max i j]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<ge>j. 5 / 10 \\<le> dur xs k - dur xs j", "ultimately"], ["proof (chain)\npicking this:\n  xs !! max i j \\<in> [xs !! max i j]\\<^sub>\\<R>\n  [xs !! max i j]\\<^sub>\\<R> \\<in> \\<R>\n  \\<forall>x\\<in>\\<X>. unbounded x ([xs !! max i j]\\<^sub>\\<R>)", "have \"\\<forall> x \\<in> \\<X>. ?u x > k x\""], ["proof (prove)\nusing this:\n  xs !! max i j \\<in> [xs !! max i j]\\<^sub>\\<R>\n  [xs !! max i j]\\<^sub>\\<R> \\<in> \\<R>\n  \\<forall>x\\<in>\\<X>. unbounded x ([xs !! max i j]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>\\<X>. real (k x) < (xs !! max i j) x", "by (auto intro: unbounded_all)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>\\<X>. real (k x) < (xs !! max i j) x\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<ge>j. 5 / 10 \\<le> dur xs k - dur xs j", "with unbounded_not_const"], ["proof (chain)\npicking this:\n  \\<forall>u.\n     (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<longrightarrow>\n     \\<not> ev (alw (\\<lambda>xs. shd xs = u)) xs\n  \\<forall>x\\<in>\\<X>. real (k x) < (xs !! max i j) x", "have \"\\<not> ev (alw (HLD {?u})) xs\""], ["proof (prove)\nusing this:\n  \\<forall>u.\n     (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<longrightarrow>\n     \\<not> ev (alw (\\<lambda>xs. shd xs = u)) xs\n  \\<forall>x\\<in>\\<X>. real (k x) < (xs !! max i j) x\n\ngoal (1 subgoal):\n 1. \\<not> ev (alw (HLD {xs !! max i j})) xs", "unfolding HLD_iff"], ["proof (prove)\nusing this:\n  \\<forall>u.\n     (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<longrightarrow>\n     \\<not> ev (alw (\\<lambda>xs. shd xs = u)) xs\n  \\<forall>x\\<in>\\<X>. real (k x) < (xs !! max i j) x\n\ngoal (1 subgoal):\n 1. \\<not> ev (alw (\\<lambda>\\<omega>. shd \\<omega> \\<in> {xs !! max i j}))\n            xs", "by simp"], ["proof (state)\nthis:\n  \\<not> ev (alw (HLD {xs !! max i j})) xs\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<ge>j. 5 / 10 \\<le> dur xs k - dur xs j", "then"], ["proof (chain)\npicking this:\n  \\<not> ev (alw (HLD {xs !! max i j})) xs", "obtain r where\n        \"r \\<ge> max i j\" \"xs !! r \\<noteq> xs !! Suc r\""], ["proof (prove)\nusing this:\n  \\<not> ev (alw (HLD {xs !! max i j})) xs\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>max i j \\<le> r; xs !! r \\<noteq> xs !! Suc r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> ev (alw (HLD {xs !! max i j})) xs \\<Longrightarrow>\n    \\<exists>r\\<ge>max i j. xs !! r \\<noteq> xs !! Suc r", "apply (simp add: not_ev_iff not_alw_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (ev (\\<lambda>xsa. \\<not> HLD {xs !! max i j} xsa))\n     xs \\<Longrightarrow>\n    \\<exists>r\\<ge>i. j \\<le> r \\<and> xs !! r \\<noteq> stl xs !! r", "apply (drule alw_sdrop[where n = \"max i j\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (ev (\\<lambda>xsa. \\<not> HLD {xs !! max i j} xsa))\n     (sdrop (max i j) xs) \\<Longrightarrow>\n    \\<exists>r\\<ge>i. j \\<le> r \\<and> xs !! r \\<noteq> stl xs !! r", "apply (drule alwD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ev (\\<lambda>xsa. \\<not> HLD {xs !! max i j} xsa)\n     (sdrop (max i j) xs) \\<Longrightarrow>\n    \\<exists>r\\<ge>i. j \\<le> r \\<and> xs !! r \\<noteq> stl xs !! r", "apply (subst (asm) (3) stream.collapse[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ev (\\<lambda>xsa. \\<not> HLD {xs !! max i j} xsa)\n     (shd (sdrop (max i j) xs) ##\n      stl (sdrop (max i j) xs)) \\<Longrightarrow>\n    \\<exists>r\\<ge>i. j \\<le> r \\<and> xs !! r \\<noteq> stl xs !! r", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. ev (\\<lambda>xsa. \\<not> HLD {xs !! max i j} xsa)\n     (xs !! max i j ## sdrop (max i j) (stl xs)) \\<Longrightarrow>\n    \\<exists>r\\<ge>i. j \\<le> r \\<and> xs !! r \\<noteq> stl xs !! r", "apply (drule ev_neq_start_implies_ev_neq[simplified comp_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ev (\\<lambda>xs. shd xs \\<noteq> shd (stl xs))\n     (xs !! max i j ## sdrop (max i j) (stl xs)) \\<Longrightarrow>\n    \\<exists>r\\<ge>i. j \\<le> r \\<and> xs !! r \\<noteq> stl xs !! r", "using stream.collapse[of \"sdrop (max i j) xs\"]"], ["proof (prove)\nusing this:\n  shd (sdrop (max i j) xs) ## stl (sdrop (max i j) xs) = sdrop (max i j) xs\n\ngoal (1 subgoal):\n 1. ev (\\<lambda>xs. shd xs \\<noteq> shd (stl xs))\n     (xs !! max i j ## sdrop (max i j) (stl xs)) \\<Longrightarrow>\n    \\<exists>r\\<ge>i. j \\<le> r \\<and> xs !! r \\<noteq> stl xs !! r", "by (auto 4 3 elim: ev_sdropD)"], ["proof (state)\nthis:\n  max i j \\<le> r\n  xs !! r \\<noteq> xs !! Suc r\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<ge>j. 5 / 10 \\<le> dur xs k - dur xs j", "let ?k = \"Suc r\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k\\<ge>j. 5 / 10 \\<le> dur xs k - dur xs j", "from in_S"], ["proof (chain)\npicking this:\n  pred_stream (\\<lambda>u. u \\<in> V) xs", "have \"xs !! ?k \\<in> V\""], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n\ngoal (1 subgoal):\n 1. xs !! Suc r \\<in> V", "using snth_sset"], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  ?s !! ?n \\<in> sset ?s\n\ngoal (1 subgoal):\n 1. xs !! Suc r \\<in> V", "unfolding stream.pred_set"], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>sset xs. u \\<in> V\n  ?s !! ?n \\<in> sset ?s\n\ngoal (1 subgoal):\n 1. xs !! Suc r \\<in> V", "by blast"], ["proof (state)\nthis:\n  xs !! Suc r \\<in> V\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<ge>j. 5 / 10 \\<le> dur xs k - dur xs j", "with in_S"], ["proof (chain)\npicking this:\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  xs !! Suc r \\<in> V", "have *:\n        \"xs !! r \\<in> [xs !! r]\\<^sub>\\<R>\" \"[xs !! r]\\<^sub>\\<R> \\<in> \\<R>\"\n        \"xs !! ?k \\<in> [xs !! ?k]\\<^sub>\\<R>\" \"[xs !! ?k]\\<^sub>\\<R> \\<in> \\<R>\""], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  xs !! Suc r \\<in> V\n\ngoal (1 subgoal):\n 1. (xs !! r \\<in> [xs !! r]\\<^sub>\\<R> &&&\n     [xs !! r]\\<^sub>\\<R> \\<in> \\<R>) &&&\n    xs !! Suc r \\<in> [xs !! Suc r]\\<^sub>\\<R> &&&\n    [xs !! Suc r]\\<^sub>\\<R> \\<in> \\<R>", "by (auto simp: stream.pred_set)"], ["proof (state)\nthis:\n  xs !! r \\<in> [xs !! r]\\<^sub>\\<R>\n  [xs !! r]\\<^sub>\\<R> \\<in> \\<R>\n  xs !! Suc r \\<in> [xs !! Suc r]\\<^sub>\\<R>\n  [xs !! Suc r]\\<^sub>\\<R> \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<ge>j. 5 / 10 \\<le> dur xs k - dur xs j", "from \\<open>r \\<ge> _\\<close>"], ["proof (chain)\npicking this:\n  max i j \\<le> r", "have \"r \\<ge> i\" \"?k \\<ge> i\""], ["proof (prove)\nusing this:\n  max i j \\<le> r\n\ngoal (1 subgoal):\n 1. i \\<le> r &&& i \\<le> Suc r", "by auto"], ["proof (state)\nthis:\n  i \\<le> r\n  i \\<le> Suc r\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<ge>j. 5 / 10 \\<le> dur xs k - dur xs j", "with unbounded \\<open>X1 = \\<X>\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>X1. \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>)\n  X1 = \\<X>\n  i \\<le> r\n  i \\<le> Suc r", "have\n        \"\\<forall> x \\<in> \\<X>. unbounded x ([xs !! r]\\<^sub>\\<R>)\" \"\\<forall> x \\<in> \\<X>. unbounded x ([xs !! ?k]\\<^sub>\\<R>)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>X1. \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>)\n  X1 = \\<X>\n  i \\<le> r\n  i \\<le> Suc r\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>\\<X>. unbounded x ([xs !! r]\\<^sub>\\<R>) &&&\n    \\<forall>x\\<in>\\<X>. unbounded x ([xs !! Suc r]\\<^sub>\\<R>)", "by (auto simp del: snth.simps(2))"], ["proof (state)\nthis:\n  \\<forall>x\\<in>\\<X>. unbounded x ([xs !! r]\\<^sub>\\<R>)\n  \\<forall>x\\<in>\\<X>. unbounded x ([xs !! Suc r]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<ge>j. 5 / 10 \\<le> dur xs k - dur xs j", "with in_S"], ["proof (chain)\npicking this:\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  \\<forall>x\\<in>\\<X>. unbounded x ([xs !! r]\\<^sub>\\<R>)\n  \\<forall>x\\<in>\\<X>. unbounded x ([xs !! Suc r]\\<^sub>\\<R>)", "have \"\\<forall> x \\<in> \\<X>. (xs !! r) x > k x\" \"\\<forall> x \\<in> \\<X>. (xs !! ?k) x > k x\""], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  \\<forall>x\\<in>\\<X>. unbounded x ([xs !! r]\\<^sub>\\<R>)\n  \\<forall>x\\<in>\\<X>. unbounded x ([xs !! Suc r]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>\\<X>. real (k x) < (xs !! r) x &&&\n    \\<forall>x\\<in>\\<X>. real (k x) < (xs !! Suc r) x", "using *"], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  \\<forall>x\\<in>\\<X>. unbounded x ([xs !! r]\\<^sub>\\<R>)\n  \\<forall>x\\<in>\\<X>. unbounded x ([xs !! Suc r]\\<^sub>\\<R>)\n  xs !! r \\<in> [xs !! r]\\<^sub>\\<R>\n  [xs !! r]\\<^sub>\\<R> \\<in> \\<R>\n  xs !! Suc r \\<in> [xs !! Suc r]\\<^sub>\\<R>\n  [xs !! Suc r]\\<^sub>\\<R> \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>\\<X>. real (k x) < (xs !! r) x &&&\n    \\<forall>x\\<in>\\<X>. real (k x) < (xs !! Suc r) x", "by (auto intro: unbounded_all)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>\\<X>. real (k x) < (xs !! r) x\n  \\<forall>x\\<in>\\<X>. real (k x) < (xs !! Suc r) x\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<ge>j. 5 / 10 \\<le> dur xs k - dur xs j", "moreover"], ["proof (state)\nthis:\n  \\<forall>x\\<in>\\<X>. real (k x) < (xs !! r) x\n  \\<forall>x\\<in>\\<X>. real (k x) < (xs !! Suc r) x\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<ge>j. 5 / 10 \\<le> dur xs k - dur xs j", "from trans'"], ["proof (chain)\npicking this:\n  PTA_Reachability.pairwise trans' xs", "have \"trans' (xs !! r) (xs !! ?k)\""], ["proof (prove)\nusing this:\n  PTA_Reachability.pairwise trans' xs\n\ngoal (1 subgoal):\n 1. trans' (xs !! r) (xs !! Suc r)", "using pairwise_Suc"], ["proof (prove)\nusing this:\n  PTA_Reachability.pairwise trans' xs\n  PTA_Reachability.pairwise ?P ?xs \\<Longrightarrow>\n  ?P (?xs !! ?i) (?xs !! Suc ?i)\n\ngoal (1 subgoal):\n 1. trans' (xs !! r) (xs !! Suc r)", "by auto"], ["proof (state)\nthis:\n  trans' (xs !! r) (xs !! Suc r)\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<ge>j. 5 / 10 \\<le> dur xs k - dur xs j", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>\\<X>. real (k x) < (xs !! r) x\n  \\<forall>x\\<in>\\<X>. real (k x) < (xs !! Suc r) x\n  trans' (xs !! r) (xs !! Suc r)", "have \"(xs !! ?k) = (xs !! r) \\<oplus> 0.5\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>\\<X>. real (k x) < (xs !! r) x\n  \\<forall>x\\<in>\\<X>. real (k x) < (xs !! Suc r) x\n  trans' (xs !! r) (xs !! Suc r)\n\ngoal (1 subgoal):\n 1. xs !! Suc r = xs !! r \\<oplus> 5 / 10", "unfolding trans'_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>\\<X>. real (k x) < (xs !! r) x\n  \\<forall>x\\<in>\\<X>. real (k x) < (xs !! Suc r) x\n  ((\\<forall>c\\<in>\\<X>.\n       real (k c) < (xs !! r) c \\<and>\n       real (k c) < (xs !! Suc r) c \\<and>\n       xs !! r \\<noteq> xs !! Suc r) \\<longrightarrow>\n   xs !! Suc r = xs !! r \\<oplus> 5 / 10) \\<and>\n  ((\\<exists>c\\<in>\\<X>.\n       (xs !! r) c = 0 \\<and>\n       0 < (xs !! Suc r) c \\<and>\n       (\\<forall>c\\<in>\\<X>.\n           \\<not> (\\<exists>d\\<le>k c.\n                      (xs !! Suc r) c = real d))) \\<longrightarrow>\n   xs !! Suc r = delayedR ([xs !! Suc r]\\<^sub>\\<R>) (xs !! r))\n\ngoal (1 subgoal):\n 1. xs !! Suc r = xs !! r \\<oplus> 5 / 10", "using \\<open>xs !! r \\<noteq> _\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>\\<X>. real (k x) < (xs !! r) x\n  \\<forall>x\\<in>\\<X>. real (k x) < (xs !! Suc r) x\n  ((\\<forall>c\\<in>\\<X>.\n       real (k c) < (xs !! r) c \\<and>\n       real (k c) < (xs !! Suc r) c \\<and>\n       xs !! r \\<noteq> xs !! Suc r) \\<longrightarrow>\n   xs !! Suc r = xs !! r \\<oplus> 5 / 10) \\<and>\n  ((\\<exists>c\\<in>\\<X>.\n       (xs !! r) c = 0 \\<and>\n       0 < (xs !! Suc r) c \\<and>\n       (\\<forall>c\\<in>\\<X>.\n           \\<not> (\\<exists>d\\<le>k c.\n                      (xs !! Suc r) c = real d))) \\<longrightarrow>\n   xs !! Suc r = delayedR ([xs !! Suc r]\\<^sub>\\<R>) (xs !! r))\n  xs !! r \\<noteq> xs !! Suc r\n\ngoal (1 subgoal):\n 1. xs !! Suc r = xs !! r \\<oplus> 5 / 10", "by auto"], ["proof (state)\nthis:\n  xs !! Suc r = xs !! r \\<oplus> 5 / 10\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<ge>j. 5 / 10 \\<le> dur xs k - dur xs j", "moreover"], ["proof (state)\nthis:\n  xs !! Suc r = xs !! r \\<oplus> 5 / 10\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<ge>j. 5 / 10 \\<le> dur xs k - dur xs j", "from pairwise_Suc[OF eq_elapsed]"], ["proof (chain)\npicking this:\n  eq_elapsed (xs !! ?i) (xs !! Suc ?i)", "have \"eq_elapsed (xs !! r) (xs !! ?k)\""], ["proof (prove)\nusing this:\n  eq_elapsed (xs !! ?i) (xs !! Suc ?i)\n\ngoal (1 subgoal):\n 1. eq_elapsed (xs !! r) (xs !! Suc r)", "by auto"], ["proof (state)\nthis:\n  eq_elapsed (xs !! r) (xs !! Suc r)\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<ge>j. 5 / 10 \\<le> dur xs k - dur xs j", "ultimately"], ["proof (chain)\npicking this:\n  xs !! Suc r = xs !! r \\<oplus> 5 / 10\n  eq_elapsed (xs !! r) (xs !! Suc r)", "have \n        \"dur xs ?k - dur xs r = 0.5\""], ["proof (prove)\nusing this:\n  xs !! Suc r = xs !! r \\<oplus> 5 / 10\n  eq_elapsed (xs !! r) (xs !! Suc r)\n\ngoal (1 subgoal):\n 1. dur xs (Suc r) - dur xs r = 5 / 10", "using non_empty"], ["proof (prove)\nusing this:\n  xs !! Suc r = xs !! r \\<oplus> 5 / 10\n  eq_elapsed (xs !! r) (xs !! Suc r)\n  \\<X> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. dur xs (Suc r) - dur xs r = 5 / 10", "by (auto simp: cval_add_def dur_Suc elapsed_eq)"], ["proof (state)\nthis:\n  dur xs (Suc r) - dur xs r = 5 / 10\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<ge>j. 5 / 10 \\<le> dur xs k - dur xs j", "with dur_mono[of j r xs] \\<open>r \\<ge> max i j\\<close>"], ["proof (chain)\npicking this:\n  j \\<le> r \\<Longrightarrow> dur xs j \\<le> dur xs r\n  max i j \\<le> r\n  dur xs (Suc r) - dur xs r = 5 / 10", "have \"dur xs ?k - dur xs j \\<ge> 0.5\""], ["proof (prove)\nusing this:\n  j \\<le> r \\<Longrightarrow> dur xs j \\<le> dur xs r\n  max i j \\<le> r\n  dur xs (Suc r) - dur xs r = 5 / 10\n\ngoal (1 subgoal):\n 1. 5 / 10 \\<le> dur xs (Suc r) - dur xs j", "by auto"], ["proof (state)\nthis:\n  5 / 10 \\<le> dur xs (Suc r) - dur xs j\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<ge>j. 5 / 10 \\<le> dur xs k - dur xs j", "with \\<open>r \\<ge> max i j\\<close>"], ["proof (chain)\npicking this:\n  max i j \\<le> r\n  5 / 10 \\<le> dur xs (Suc r) - dur xs j", "show ?thesis"], ["proof (prove)\nusing this:\n  max i j \\<le> r\n  5 / 10 \\<le> dur xs (Suc r) - dur xs j\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<ge>j. 5 / 10 \\<le> dur xs k - dur xs j", "by - (rule exI[where x = ?k]; auto)"], ["proof (state)\nthis:\n  \\<exists>k\\<ge>j. 5 / 10 \\<le> dur xs k - dur xs j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>k\\<ge>?j8. 5 / 10 \\<le> dur xs k - dur xs ?j8\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>\\<X>.\n       \\<exists>i.\n          \\<forall>j\\<ge>i.\n             unbounded x ([xs !! j]\\<^sub>\\<R>) \\<Longrightarrow>\n    \\<exists>n. t < dur xs n\n 2. \\<not> (\\<forall>x\\<in>\\<X>.\n               \\<exists>i.\n                  \\<forall>j\\<ge>i.\n                     unbounded x ([xs !! j]\\<^sub>\\<R>)) \\<Longrightarrow>\n    \\<exists>n. t < dur xs n", "then"], ["proof (chain)\npicking this:\n  \\<exists>k\\<ge>?j8. 5 / 10 \\<le> dur xs k - dur xs ?j8", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>k\\<ge>?j8. 5 / 10 \\<le> dur xs k - dur xs ?j8\n\ngoal (1 subgoal):\n 1. \\<exists>n. t < dur xs n", "by - (rule dur_ev_exceedsI[where d = \"0.5\"]; auto)"], ["proof (state)\nthis:\n  \\<exists>n. t < dur xs n\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>\\<X>.\n               \\<exists>i.\n                  \\<forall>j\\<ge>i.\n                     unbounded x ([xs !! j]\\<^sub>\\<R>)) \\<Longrightarrow>\n    \\<exists>n. t < dur xs n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>\\<X>.\n               \\<exists>i.\n                  \\<forall>j\\<ge>i.\n                     unbounded x ([xs !! j]\\<^sub>\\<R>)) \\<Longrightarrow>\n    \\<exists>n. t < dur xs n", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>x\\<in>\\<X>.\n             \\<exists>i.\n                \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>\\<X>.\n               \\<exists>i.\n                  \\<forall>j\\<ge>i.\n                     unbounded x ([xs !! j]\\<^sub>\\<R>)) \\<Longrightarrow>\n    \\<exists>n. t < dur xs n", "define X2 where \"X2 = \\<X> - X1\""], ["proof (state)\nthis:\n  X2 = \\<X> - X1\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>\\<X>.\n               \\<exists>i.\n                  \\<forall>j\\<ge>i.\n                     unbounded x ([xs !! j]\\<^sub>\\<R>)) \\<Longrightarrow>\n    \\<exists>n. t < dur xs n", "from False"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>x\\<in>\\<X>.\n             \\<exists>i.\n                \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>))", "have \"X2 \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x\\<in>\\<X>.\n             \\<exists>i.\n                \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>))\n\ngoal (1 subgoal):\n 1. X2 \\<noteq> {}", "unfolding X1_def X2_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x\\<in>\\<X>.\n             \\<exists>i.\n                \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>))\n\ngoal (1 subgoal):\n 1. \\<X> -\n    {x \\<in> \\<X>.\n     \\<exists>i.\n        \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>)} \\<noteq>\n    {}", "by fastforce"], ["proof (state)\nthis:\n  X2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>\\<X>.\n               \\<exists>i.\n                  \\<forall>j\\<ge>i.\n                     unbounded x ([xs !! j]\\<^sub>\\<R>)) \\<Longrightarrow>\n    \\<exists>n. t < dur xs n", "have inf_resets:\n      \"\\<forall>i. (\\<exists>j\\<ge>i. zero x ([xs !! j]\\<^sub>\\<R>)) \\<and> (\\<exists>j\\<ge>i. \\<not> zero x ([xs !! j]\\<^sub>\\<R>))\" if \"x \\<in> X2\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       (\\<exists>j\\<ge>i. zero x ([xs !! j]\\<^sub>\\<R>)) \\<and>\n       (\\<exists>j\\<ge>i. \\<not> zero x ([xs !! j]\\<^sub>\\<R>))", "using that div"], ["proof (prove)\nusing this:\n  x \\<in> X2\n  \\<R>_div (smap (\\<lambda>u. [u]\\<^sub>\\<R>) xs)\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       (\\<exists>j\\<ge>i. zero x ([xs !! j]\\<^sub>\\<R>)) \\<and>\n       (\\<exists>j\\<ge>i. \\<not> zero x ([xs !! j]\\<^sub>\\<R>))", "unfolding X1_def X2_def \\<R>_div_def"], ["proof (prove)\nusing this:\n  x \\<in> \\<X> -\n          {x \\<in> \\<X>.\n           \\<exists>i. \\<forall>j\\<ge>i. unbounded x ([xs !! j]\\<^sub>\\<R>)}\n  \\<forall>x\\<in>\\<X>.\n     (\\<forall>i.\n         (\\<exists>j\\<ge>i.\n             zero x (smap (\\<lambda>u. [u]\\<^sub>\\<R>) xs !! j)) \\<and>\n         (\\<exists>j\\<ge>i.\n             \\<not> zero x\n                     (smap (\\<lambda>u. [u]\\<^sub>\\<R>) xs !! j))) \\<or>\n     (\\<exists>i.\n         \\<forall>j\\<ge>i.\n            unbounded x (smap (\\<lambda>u. [u]\\<^sub>\\<R>) xs !! j))\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       (\\<exists>j\\<ge>i. zero x ([xs !! j]\\<^sub>\\<R>)) \\<and>\n       (\\<exists>j\\<ge>i. \\<not> zero x ([xs !! j]\\<^sub>\\<R>))", "by fastforce"], ["proof (state)\nthis:\n  ?x8 \\<in> X2 \\<Longrightarrow>\n  \\<forall>i.\n     (\\<exists>j\\<ge>i. zero ?x8 ([xs !! j]\\<^sub>\\<R>)) \\<and>\n     (\\<exists>j\\<ge>i. \\<not> zero ?x8 ([xs !! j]\\<^sub>\\<R>))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>\\<X>.\n               \\<exists>i.\n                  \\<forall>j\\<ge>i.\n                     unbounded x ([xs !! j]\\<^sub>\\<R>)) \\<Longrightarrow>\n    \\<exists>n. t < dur xs n", "have \"\\<exists> j \\<ge> i. \\<exists> k > j. \\<exists> x \\<in> X2. zero x ([xs !! j]\\<^sub>\\<R>) \\<and> zero x ([xs !! k]\\<^sub>\\<R>)\n          \\<and> (\\<forall> m. j < m \\<and> m < k \\<longrightarrow> \\<not> zero x ([xs !! m]\\<^sub>\\<R>))\n          \\<and> (\\<forall> x \\<in> X2. \\<exists> m. j < m \\<and> m \\<le> k \\<and> zero x ([xs !! m]\\<^sub>\\<R>))\n          \\<and> (\\<forall> x \\<in> X1. \\<forall> m \\<ge> j. unbounded x ([xs !! m]\\<^sub>\\<R>))\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i.\n       \\<exists>k>j.\n          \\<exists>x\\<in>X2.\n             zero x ([xs !! j]\\<^sub>\\<R>) \\<and>\n             zero x ([xs !! k]\\<^sub>\\<R>) \\<and>\n             (\\<forall>m.\n                 j < m \\<and> m < k \\<longrightarrow>\n                 \\<not> zero x ([xs !! m]\\<^sub>\\<R>)) \\<and>\n             (\\<forall>x\\<in>X2.\n                 \\<exists>m>j.\n                    m \\<le> k \\<and> zero x ([xs !! m]\\<^sub>\\<R>)) \\<and>\n             (\\<forall>x\\<in>X1.\n                 \\<forall>m\\<ge>j. unbounded x ([xs !! m]\\<^sub>\\<R>))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i.\n       \\<exists>k>j.\n          \\<exists>x\\<in>X2.\n             zero x ([xs !! j]\\<^sub>\\<R>) \\<and>\n             zero x ([xs !! k]\\<^sub>\\<R>) \\<and>\n             (\\<forall>m.\n                 j < m \\<and> m < k \\<longrightarrow>\n                 \\<not> zero x ([xs !! m]\\<^sub>\\<R>)) \\<and>\n             (\\<forall>x\\<in>X2.\n                 \\<exists>m>j.\n                    m \\<le> k \\<and> zero x ([xs !! m]\\<^sub>\\<R>)) \\<and>\n             (\\<forall>x\\<in>X1.\n                 \\<forall>m\\<ge>j. unbounded x ([xs !! m]\\<^sub>\\<R>))", "from unbounded"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>X1. \\<forall>j\\<ge>i__. unbounded x ([xs !! j]\\<^sub>\\<R>)", "obtain i' where i': \"\\<forall> x \\<in> X1. \\<forall> m \\<ge> i'. unbounded x ([xs !! m]\\<^sub>\\<R>)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>X1. \\<forall>j\\<ge>i__. unbounded x ([xs !! j]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. (\\<And>i'.\n        \\<forall>x\\<in>X1.\n           \\<forall>m\\<ge>i'.\n              unbounded x ([xs !! m]\\<^sub>\\<R>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>X1. \\<forall>m\\<ge>i'. unbounded x ([xs !! m]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i.\n       \\<exists>k>j.\n          \\<exists>x\\<in>X2.\n             zero x ([xs !! j]\\<^sub>\\<R>) \\<and>\n             zero x ([xs !! k]\\<^sub>\\<R>) \\<and>\n             (\\<forall>m.\n                 j < m \\<and> m < k \\<longrightarrow>\n                 \\<not> zero x ([xs !! m]\\<^sub>\\<R>)) \\<and>\n             (\\<forall>x\\<in>X2.\n                 \\<exists>m>j.\n                    m \\<le> k \\<and> zero x ([xs !! m]\\<^sub>\\<R>)) \\<and>\n             (\\<forall>x\\<in>X1.\n                 \\<forall>m\\<ge>j. unbounded x ([xs !! m]\\<^sub>\\<R>))", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>X1. \\<forall>m\\<ge>i'. unbounded x ([xs !! m]\\<^sub>\\<R>)", "obtain i' where i':\n        \"i' \\<ge> i\" \"\\<forall> x \\<in> X1. \\<forall> m \\<ge> i'. unbounded x ([xs !! m]\\<^sub>\\<R>)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>X1. \\<forall>m\\<ge>i'. unbounded x ([xs !! m]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. (\\<And>i'.\n        \\<lbrakk>i \\<le> i';\n         \\<forall>x\\<in>X1.\n            \\<forall>m\\<ge>i'. unbounded x ([xs !! m]\\<^sub>\\<R>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"i' \\<ge> i\"; auto)"], ["proof (state)\nthis:\n  i \\<le> i'\n  \\<forall>x\\<in>X1. \\<forall>m\\<ge>i'. unbounded x ([xs !! m]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i.\n       \\<exists>k>j.\n          \\<exists>x\\<in>X2.\n             zero x ([xs !! j]\\<^sub>\\<R>) \\<and>\n             zero x ([xs !! k]\\<^sub>\\<R>) \\<and>\n             (\\<forall>m.\n                 j < m \\<and> m < k \\<longrightarrow>\n                 \\<not> zero x ([xs !! m]\\<^sub>\\<R>)) \\<and>\n             (\\<forall>x\\<in>X2.\n                 \\<exists>m>j.\n                    m \\<le> k \\<and> zero x ([xs !! m]\\<^sub>\\<R>)) \\<and>\n             (\\<forall>x\\<in>X1.\n                 \\<forall>m\\<ge>j. unbounded x ([xs !! m]\\<^sub>\\<R>))", "from finite(1)"], ["proof (chain)\npicking this:\n  finite \\<X>", "have \"finite X2\""], ["proof (prove)\nusing this:\n  finite \\<X>\n\ngoal (1 subgoal):\n 1. finite X2", "unfolding X2_def"], ["proof (prove)\nusing this:\n  finite \\<X>\n\ngoal (1 subgoal):\n 1. finite (\\<X> - X1)", "by auto"], ["proof (state)\nthis:\n  finite X2\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i.\n       \\<exists>k>j.\n          \\<exists>x\\<in>X2.\n             zero x ([xs !! j]\\<^sub>\\<R>) \\<and>\n             zero x ([xs !! k]\\<^sub>\\<R>) \\<and>\n             (\\<forall>m.\n                 j < m \\<and> m < k \\<longrightarrow>\n                 \\<not> zero x ([xs !! m]\\<^sub>\\<R>)) \\<and>\n             (\\<forall>x\\<in>X2.\n                 \\<exists>m>j.\n                    m \\<le> k \\<and> zero x ([xs !! m]\\<^sub>\\<R>)) \\<and>\n             (\\<forall>x\\<in>X1.\n                 \\<forall>m\\<ge>j. unbounded x ([xs !! m]\\<^sub>\\<R>))", "with \\<open>X2 \\<noteq> {}\\<close> \\<R>_divergent_divergent_aux2[where M = \"{\\<lambda> i. zero x ([xs !! i]\\<^sub>\\<R>) | x. x \\<in> X2}\"]\n        inf_resets"], ["proof (chain)\npicking this:\n  X2 \\<noteq> {}\n  \\<lbrakk>\\<forall>i.\n              \\<forall>P\\<in>{\\<lambda>i. zero x ([xs !! i]\\<^sub>\\<R>) |x.\n                              x \\<in> X2}.\n                 \\<exists>j\\<ge>i. P j;\n   {\\<lambda>i. zero x ([xs !! i]\\<^sub>\\<R>) |x. x \\<in> X2} \\<noteq> {};\n   finite\n    {\\<lambda>i. zero x ([xs !! i]\\<^sub>\\<R>) |x. x \\<in> X2}\\<rbrakk>\n  \\<Longrightarrow> \\<forall>i.\n                       \\<exists>j\\<ge>i.\n                          \\<exists>k>j.\n                             \\<exists>P\n\\<in>{\\<lambda>i. zero x ([xs !! i]\\<^sub>\\<R>) |x. x \\<in> X2}.\n                                P j \\<and>\n                                P k \\<and>\n                                (\\<forall>m<k.\n                                    j < m \\<longrightarrow>\n                                    \\<not> P m) \\<and>\n                                (\\<forall>Q\n    \\<in>{\\<lambda>i. zero x ([xs !! i]\\<^sub>\\<R>) |x. x \\<in> X2}.\n                                    \\<exists>m\\<le>k. j < m \\<and> Q m)\n  ?x8 \\<in> X2 \\<Longrightarrow>\n  \\<forall>i.\n     (\\<exists>j\\<ge>i. zero ?x8 ([xs !! j]\\<^sub>\\<R>)) \\<and>\n     (\\<exists>j\\<ge>i. \\<not> zero ?x8 ([xs !! j]\\<^sub>\\<R>))\n  finite X2", "have \"\\<exists>j\\<ge>i'. \\<exists>k>j. \\<exists>P\\<in>{\\<lambda>i. zero x ([xs !! i]\\<^sub>\\<R>) |x. x \\<in> X2}. P j \\<and> P k\n        \\<and> (\\<forall>m<k. j < m \\<longrightarrow> \\<not> P m) \\<and> (\\<forall>Q\\<in>{\\<lambda>i. zero x ([xs !! i]\\<^sub>\\<R>) |x. x \\<in> X2}. \\<exists>m\\<le>k. j < m \\<and> Q m)\""], ["proof (prove)\nusing this:\n  X2 \\<noteq> {}\n  \\<lbrakk>\\<forall>i.\n              \\<forall>P\\<in>{\\<lambda>i. zero x ([xs !! i]\\<^sub>\\<R>) |x.\n                              x \\<in> X2}.\n                 \\<exists>j\\<ge>i. P j;\n   {\\<lambda>i. zero x ([xs !! i]\\<^sub>\\<R>) |x. x \\<in> X2} \\<noteq> {};\n   finite\n    {\\<lambda>i. zero x ([xs !! i]\\<^sub>\\<R>) |x. x \\<in> X2}\\<rbrakk>\n  \\<Longrightarrow> \\<forall>i.\n                       \\<exists>j\\<ge>i.\n                          \\<exists>k>j.\n                             \\<exists>P\n\\<in>{\\<lambda>i. zero x ([xs !! i]\\<^sub>\\<R>) |x. x \\<in> X2}.\n                                P j \\<and>\n                                P k \\<and>\n                                (\\<forall>m<k.\n                                    j < m \\<longrightarrow>\n                                    \\<not> P m) \\<and>\n                                (\\<forall>Q\n    \\<in>{\\<lambda>i. zero x ([xs !! i]\\<^sub>\\<R>) |x. x \\<in> X2}.\n                                    \\<exists>m\\<le>k. j < m \\<and> Q m)\n  ?x8 \\<in> X2 \\<Longrightarrow>\n  \\<forall>i.\n     (\\<exists>j\\<ge>i. zero ?x8 ([xs !! j]\\<^sub>\\<R>)) \\<and>\n     (\\<exists>j\\<ge>i. \\<not> zero ?x8 ([xs !! j]\\<^sub>\\<R>))\n  finite X2\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i'.\n       \\<exists>k>j.\n          \\<exists>P\\<in>{\\<lambda>i. zero x ([xs !! i]\\<^sub>\\<R>) |x.\n                          x \\<in> X2}.\n             P j \\<and>\n             P k \\<and>\n             (\\<forall>m<k. j < m \\<longrightarrow> \\<not> P m) \\<and>\n             (\\<forall>Q\\<in>{\\<lambda>i. zero x ([xs !! i]\\<^sub>\\<R>) |x.\n                              x \\<in> X2}.\n                 \\<exists>m\\<le>k. j < m \\<and> Q m)", "by force"], ["proof (state)\nthis:\n  \\<exists>j\\<ge>i'.\n     \\<exists>k>j.\n        \\<exists>P\\<in>{\\<lambda>i. zero x ([xs !! i]\\<^sub>\\<R>) |x.\n                        x \\<in> X2}.\n           P j \\<and>\n           P k \\<and>\n           (\\<forall>m<k. j < m \\<longrightarrow> \\<not> P m) \\<and>\n           (\\<forall>Q\\<in>{\\<lambda>i. zero x ([xs !! i]\\<^sub>\\<R>) |x.\n                            x \\<in> X2}.\n               \\<exists>m\\<le>k. j < m \\<and> Q m)\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i.\n       \\<exists>k>j.\n          \\<exists>x\\<in>X2.\n             zero x ([xs !! j]\\<^sub>\\<R>) \\<and>\n             zero x ([xs !! k]\\<^sub>\\<R>) \\<and>\n             (\\<forall>m.\n                 j < m \\<and> m < k \\<longrightarrow>\n                 \\<not> zero x ([xs !! m]\\<^sub>\\<R>)) \\<and>\n             (\\<forall>x\\<in>X2.\n                 \\<exists>m>j.\n                    m \\<le> k \\<and> zero x ([xs !! m]\\<^sub>\\<R>)) \\<and>\n             (\\<forall>x\\<in>X1.\n                 \\<forall>m\\<ge>j. unbounded x ([xs !! m]\\<^sub>\\<R>))", "then"], ["proof (chain)\npicking this:\n  \\<exists>j\\<ge>i'.\n     \\<exists>k>j.\n        \\<exists>P\\<in>{\\<lambda>i. zero x ([xs !! i]\\<^sub>\\<R>) |x.\n                        x \\<in> X2}.\n           P j \\<and>\n           P k \\<and>\n           (\\<forall>m<k. j < m \\<longrightarrow> \\<not> P m) \\<and>\n           (\\<forall>Q\\<in>{\\<lambda>i. zero x ([xs !! i]\\<^sub>\\<R>) |x.\n                            x \\<in> X2}.\n               \\<exists>m\\<le>k. j < m \\<and> Q m)", "obtain j k x where\n        \"j \\<ge> i'\" \"k > j\" \"x \\<in> X2\" \"zero x ([xs !! j]\\<^sub>\\<R>)\" \"zero x ([xs !! k]\\<^sub>\\<R>)\"\n        \"\\<forall>m. j < m \\<and> m < k \\<longrightarrow> \\<not> zero x ([xs !! m]\\<^sub>\\<R>)\"\n        \"\\<forall>Q\\<in>{\\<lambda>i. zero x ([xs !! i]\\<^sub>\\<R>) |x. x \\<in> X2}. \\<exists>m\\<le>k. j < m \\<and> Q m\""], ["proof (prove)\nusing this:\n  \\<exists>j\\<ge>i'.\n     \\<exists>k>j.\n        \\<exists>P\\<in>{\\<lambda>i. zero x ([xs !! i]\\<^sub>\\<R>) |x.\n                        x \\<in> X2}.\n           P j \\<and>\n           P k \\<and>\n           (\\<forall>m<k. j < m \\<longrightarrow> \\<not> P m) \\<and>\n           (\\<forall>Q\\<in>{\\<lambda>i. zero x ([xs !! i]\\<^sub>\\<R>) |x.\n                            x \\<in> X2}.\n               \\<exists>m\\<le>k. j < m \\<and> Q m)\n\ngoal (1 subgoal):\n 1. (\\<And>j k x.\n        \\<lbrakk>i' \\<le> j; j < k; x \\<in> X2;\n         zero x ([xs !! j]\\<^sub>\\<R>); zero x ([xs !! k]\\<^sub>\\<R>);\n         \\<forall>m.\n            j < m \\<and> m < k \\<longrightarrow>\n            \\<not> zero x ([xs !! m]\\<^sub>\\<R>);\n         \\<forall>Q\\<in>{\\<lambda>i. zero x ([xs !! i]\\<^sub>\\<R>) |x.\n                         x \\<in> X2}.\n            \\<exists>m\\<le>k. j < m \\<and> Q m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i' \\<le> j\n  j < k\n  x \\<in> X2\n  zero x ([xs !! j]\\<^sub>\\<R>)\n  zero x ([xs !! k]\\<^sub>\\<R>)\n  \\<forall>m.\n     j < m \\<and> m < k \\<longrightarrow>\n     \\<not> zero x ([xs !! m]\\<^sub>\\<R>)\n  \\<forall>Q\\<in>{\\<lambda>i. zero x ([xs !! i]\\<^sub>\\<R>) |x. x \\<in> X2}.\n     \\<exists>m\\<le>k. j < m \\<and> Q m\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i.\n       \\<exists>k>j.\n          \\<exists>x\\<in>X2.\n             zero x ([xs !! j]\\<^sub>\\<R>) \\<and>\n             zero x ([xs !! k]\\<^sub>\\<R>) \\<and>\n             (\\<forall>m.\n                 j < m \\<and> m < k \\<longrightarrow>\n                 \\<not> zero x ([xs !! m]\\<^sub>\\<R>)) \\<and>\n             (\\<forall>x\\<in>X2.\n                 \\<exists>m>j.\n                    m \\<le> k \\<and> zero x ([xs !! m]\\<^sub>\\<R>)) \\<and>\n             (\\<forall>x\\<in>X1.\n                 \\<forall>m\\<ge>j. unbounded x ([xs !! m]\\<^sub>\\<R>))", "moreover"], ["proof (state)\nthis:\n  i' \\<le> j\n  j < k\n  x \\<in> X2\n  zero x ([xs !! j]\\<^sub>\\<R>)\n  zero x ([xs !! k]\\<^sub>\\<R>)\n  \\<forall>m.\n     j < m \\<and> m < k \\<longrightarrow>\n     \\<not> zero x ([xs !! m]\\<^sub>\\<R>)\n  \\<forall>Q\\<in>{\\<lambda>i. zero x ([xs !! i]\\<^sub>\\<R>) |x. x \\<in> X2}.\n     \\<exists>m\\<le>k. j < m \\<and> Q m\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i.\n       \\<exists>k>j.\n          \\<exists>x\\<in>X2.\n             zero x ([xs !! j]\\<^sub>\\<R>) \\<and>\n             zero x ([xs !! k]\\<^sub>\\<R>) \\<and>\n             (\\<forall>m.\n                 j < m \\<and> m < k \\<longrightarrow>\n                 \\<not> zero x ([xs !! m]\\<^sub>\\<R>)) \\<and>\n             (\\<forall>x\\<in>X2.\n                 \\<exists>m>j.\n                    m \\<le> k \\<and> zero x ([xs !! m]\\<^sub>\\<R>)) \\<and>\n             (\\<forall>x\\<in>X1.\n                 \\<forall>m\\<ge>j. unbounded x ([xs !! m]\\<^sub>\\<R>))", "from this(7)"], ["proof (chain)\npicking this:\n  \\<forall>Q\\<in>{\\<lambda>i. zero x ([xs !! i]\\<^sub>\\<R>) |x. x \\<in> X2}.\n     \\<exists>m\\<le>k. j < m \\<and> Q m", "have \"\\<forall>x\\<in>X2. \\<exists>m \\<le> k. j < m \\<and> zero x ([xs !! m]\\<^sub>\\<R>)\""], ["proof (prove)\nusing this:\n  \\<forall>Q\\<in>{\\<lambda>i. zero x ([xs !! i]\\<^sub>\\<R>) |x. x \\<in> X2}.\n     \\<exists>m\\<le>k. j < m \\<and> Q m\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>X2.\n       \\<exists>m\\<le>k. j < m \\<and> zero x ([xs !! m]\\<^sub>\\<R>)", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>X2.\n     \\<exists>m\\<le>k. j < m \\<and> zero x ([xs !! m]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i.\n       \\<exists>k>j.\n          \\<exists>x\\<in>X2.\n             zero x ([xs !! j]\\<^sub>\\<R>) \\<and>\n             zero x ([xs !! k]\\<^sub>\\<R>) \\<and>\n             (\\<forall>m.\n                 j < m \\<and> m < k \\<longrightarrow>\n                 \\<not> zero x ([xs !! m]\\<^sub>\\<R>)) \\<and>\n             (\\<forall>x\\<in>X2.\n                 \\<exists>m>j.\n                    m \\<le> k \\<and> zero x ([xs !! m]\\<^sub>\\<R>)) \\<and>\n             (\\<forall>x\\<in>X1.\n                 \\<forall>m\\<ge>j. unbounded x ([xs !! m]\\<^sub>\\<R>))", "ultimately"], ["proof (chain)\npicking this:\n  i' \\<le> j\n  j < k\n  x \\<in> X2\n  zero x ([xs !! j]\\<^sub>\\<R>)\n  zero x ([xs !! k]\\<^sub>\\<R>)\n  \\<forall>m.\n     j < m \\<and> m < k \\<longrightarrow>\n     \\<not> zero x ([xs !! m]\\<^sub>\\<R>)\n  \\<forall>Q\\<in>{\\<lambda>i. zero x ([xs !! i]\\<^sub>\\<R>) |x. x \\<in> X2}.\n     \\<exists>m\\<le>k. j < m \\<and> Q m\n  \\<forall>x\\<in>X2.\n     \\<exists>m\\<le>k. j < m \\<and> zero x ([xs !! m]\\<^sub>\\<R>)", "show ?thesis"], ["proof (prove)\nusing this:\n  i' \\<le> j\n  j < k\n  x \\<in> X2\n  zero x ([xs !! j]\\<^sub>\\<R>)\n  zero x ([xs !! k]\\<^sub>\\<R>)\n  \\<forall>m.\n     j < m \\<and> m < k \\<longrightarrow>\n     \\<not> zero x ([xs !! m]\\<^sub>\\<R>)\n  \\<forall>Q\\<in>{\\<lambda>i. zero x ([xs !! i]\\<^sub>\\<R>) |x. x \\<in> X2}.\n     \\<exists>m\\<le>k. j < m \\<and> Q m\n  \\<forall>x\\<in>X2.\n     \\<exists>m\\<le>k. j < m \\<and> zero x ([xs !! m]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i.\n       \\<exists>k>j.\n          \\<exists>x\\<in>X2.\n             zero x ([xs !! j]\\<^sub>\\<R>) \\<and>\n             zero x ([xs !! k]\\<^sub>\\<R>) \\<and>\n             (\\<forall>m.\n                 j < m \\<and> m < k \\<longrightarrow>\n                 \\<not> zero x ([xs !! m]\\<^sub>\\<R>)) \\<and>\n             (\\<forall>x\\<in>X2.\n                 \\<exists>m>j.\n                    m \\<le> k \\<and> zero x ([xs !! m]\\<^sub>\\<R>)) \\<and>\n             (\\<forall>x\\<in>X1.\n                 \\<forall>m\\<ge>j. unbounded x ([xs !! m]\\<^sub>\\<R>))", "using i'"], ["proof (prove)\nusing this:\n  i' \\<le> j\n  j < k\n  x \\<in> X2\n  zero x ([xs !! j]\\<^sub>\\<R>)\n  zero x ([xs !! k]\\<^sub>\\<R>)\n  \\<forall>m.\n     j < m \\<and> m < k \\<longrightarrow>\n     \\<not> zero x ([xs !! m]\\<^sub>\\<R>)\n  \\<forall>Q\\<in>{\\<lambda>i. zero x ([xs !! i]\\<^sub>\\<R>) |x. x \\<in> X2}.\n     \\<exists>m\\<le>k. j < m \\<and> Q m\n  \\<forall>x\\<in>X2.\n     \\<exists>m\\<le>k. j < m \\<and> zero x ([xs !! m]\\<^sub>\\<R>)\n  i \\<le> i'\n  \\<forall>x\\<in>X1. \\<forall>m\\<ge>i'. unbounded x ([xs !! m]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i.\n       \\<exists>k>j.\n          \\<exists>x\\<in>X2.\n             zero x ([xs !! j]\\<^sub>\\<R>) \\<and>\n             zero x ([xs !! k]\\<^sub>\\<R>) \\<and>\n             (\\<forall>m.\n                 j < m \\<and> m < k \\<longrightarrow>\n                 \\<not> zero x ([xs !! m]\\<^sub>\\<R>)) \\<and>\n             (\\<forall>x\\<in>X2.\n                 \\<exists>m>j.\n                    m \\<le> k \\<and> zero x ([xs !! m]\\<^sub>\\<R>)) \\<and>\n             (\\<forall>x\\<in>X1.\n                 \\<forall>m\\<ge>j. unbounded x ([xs !! m]\\<^sub>\\<R>))", "by (inst_existentials j k x) auto"], ["proof (state)\nthis:\n  \\<exists>j\\<ge>i.\n     \\<exists>k>j.\n        \\<exists>x\\<in>X2.\n           zero x ([xs !! j]\\<^sub>\\<R>) \\<and>\n           zero x ([xs !! k]\\<^sub>\\<R>) \\<and>\n           (\\<forall>m.\n               j < m \\<and> m < k \\<longrightarrow>\n               \\<not> zero x ([xs !! m]\\<^sub>\\<R>)) \\<and>\n           (\\<forall>x\\<in>X2.\n               \\<exists>m>j.\n                  m \\<le> k \\<and> zero x ([xs !! m]\\<^sub>\\<R>)) \\<and>\n           (\\<forall>x\\<in>X1.\n               \\<forall>m\\<ge>j. unbounded x ([xs !! m]\\<^sub>\\<R>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>j\\<ge>?i8.\n     \\<exists>k>j.\n        \\<exists>x\\<in>X2.\n           zero x ([xs !! j]\\<^sub>\\<R>) \\<and>\n           zero x ([xs !! k]\\<^sub>\\<R>) \\<and>\n           (\\<forall>m.\n               j < m \\<and> m < k \\<longrightarrow>\n               \\<not> zero x ([xs !! m]\\<^sub>\\<R>)) \\<and>\n           (\\<forall>x\\<in>X2.\n               \\<exists>m>j.\n                  m \\<le> k \\<and> zero x ([xs !! m]\\<^sub>\\<R>)) \\<and>\n           (\\<forall>x\\<in>X1.\n               \\<forall>m\\<ge>j. unbounded x ([xs !! m]\\<^sub>\\<R>))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>\\<X>.\n               \\<exists>i.\n                  \\<forall>j\\<ge>i.\n                     unbounded x ([xs !! j]\\<^sub>\\<R>)) \\<Longrightarrow>\n    \\<exists>n. t < dur xs n", "moreover"], ["proof (state)\nthis:\n  \\<exists>j\\<ge>?i8.\n     \\<exists>k>j.\n        \\<exists>x\\<in>X2.\n           zero x ([xs !! j]\\<^sub>\\<R>) \\<and>\n           zero x ([xs !! k]\\<^sub>\\<R>) \\<and>\n           (\\<forall>m.\n               j < m \\<and> m < k \\<longrightarrow>\n               \\<not> zero x ([xs !! m]\\<^sub>\\<R>)) \\<and>\n           (\\<forall>x\\<in>X2.\n               \\<exists>m>j.\n                  m \\<le> k \\<and> zero x ([xs !! m]\\<^sub>\\<R>)) \\<and>\n           (\\<forall>x\\<in>X1.\n               \\<forall>m\\<ge>j. unbounded x ([xs !! m]\\<^sub>\\<R>))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>\\<X>.\n               \\<exists>i.\n                  \\<forall>j\\<ge>i.\n                     unbounded x ([xs !! j]\\<^sub>\\<R>)) \\<Longrightarrow>\n    \\<exists>n. t < dur xs n", "have \"\\<exists> j' \\<ge> j. dur xs j' - dur xs i \\<ge> 0.5\"\n      if  x: \"x \\<in> X2\" \"i < j\" \"zero x ([xs !! i]\\<^sub>\\<R>)\" \"zero x ([xs !! j]\\<^sub>\\<R>)\"\n        and not_reset: \"\\<forall> m. i < m \\<and> m < j \\<longrightarrow> \\<not> zero x ([xs !! m]\\<^sub>\\<R>)\"\n        and X2: \"\\<forall> x \\<in> X2. \\<exists> m. i < m \\<and> m \\<le> j \\<and> zero x ([xs !! m]\\<^sub>\\<R>)\"\n        and X1: \"\\<forall> x \\<in> X1. \\<forall> m \\<ge> i. unbounded x ([xs !! m]\\<^sub>\\<R>)\"\n      for x i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "have \"\\<exists>j'>j. \\<not> zero x ([xs !! j']\\<^sub>\\<R>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j'>j. \\<not> zero x ([xs !! j']\\<^sub>\\<R>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>j'>j. \\<not> zero x ([xs !! j']\\<^sub>\\<R>)", "from inf_resets[OF x(1)]"], ["proof (chain)\npicking this:\n  \\<forall>i.\n     (\\<exists>j\\<ge>i. zero x ([xs !! j]\\<^sub>\\<R>)) \\<and>\n     (\\<exists>j\\<ge>i. \\<not> zero x ([xs !! j]\\<^sub>\\<R>))", "obtain j' where \"j' \\<ge> Suc j\" \"\\<not> zero x ([xs !! j']\\<^sub>\\<R>)\""], ["proof (prove)\nusing this:\n  \\<forall>i.\n     (\\<exists>j\\<ge>i. zero x ([xs !! j]\\<^sub>\\<R>)) \\<and>\n     (\\<exists>j\\<ge>i. \\<not> zero x ([xs !! j]\\<^sub>\\<R>))\n\ngoal (1 subgoal):\n 1. (\\<And>j'.\n        \\<lbrakk>Suc j \\<le> j';\n         \\<not> zero x ([xs !! j']\\<^sub>\\<R>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Suc j \\<le> j'\n  \\<not> zero x ([xs !! j']\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. \\<exists>j'>j. \\<not> zero x ([xs !! j']\\<^sub>\\<R>)", "then"], ["proof (chain)\npicking this:\n  Suc j \\<le> j'\n  \\<not> zero x ([xs !! j']\\<^sub>\\<R>)", "show ?thesis"], ["proof (prove)\nusing this:\n  Suc j \\<le> j'\n  \\<not> zero x ([xs !! j']\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. \\<exists>j'>j. \\<not> zero x ([xs !! j']\\<^sub>\\<R>)", "by - (rule exI[where x = j']; auto)"], ["proof (state)\nthis:\n  \\<exists>j'>j. \\<not> zero x ([xs !! j']\\<^sub>\\<R>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>j'>j. \\<not> zero x ([xs !! j']\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "from inf_resets[OF x(1)]"], ["proof (chain)\npicking this:\n  \\<forall>i.\n     (\\<exists>j\\<ge>i. zero x ([xs !! j]\\<^sub>\\<R>)) \\<and>\n     (\\<exists>j\\<ge>i. \\<not> zero x ([xs !! j]\\<^sub>\\<R>))", "obtain j' where \"j' \\<ge> Suc j\" \"\\<not> zero x ([xs !! j']\\<^sub>\\<R>)\""], ["proof (prove)\nusing this:\n  \\<forall>i.\n     (\\<exists>j\\<ge>i. zero x ([xs !! j]\\<^sub>\\<R>)) \\<and>\n     (\\<exists>j\\<ge>i. \\<not> zero x ([xs !! j]\\<^sub>\\<R>))\n\ngoal (1 subgoal):\n 1. (\\<And>j'.\n        \\<lbrakk>Suc j \\<le> j';\n         \\<not> zero x ([xs !! j']\\<^sub>\\<R>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Suc j \\<le> j'\n  \\<not> zero x ([xs !! j']\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "with nat_eventually_critical_path[OF x(4) this(2)]"], ["proof (chain)\npicking this:\n  j < j' \\<Longrightarrow>\n  \\<exists>k>j.\n     k \\<le> j' \\<and>\n     \\<not> zero x ([xs !! k]\\<^sub>\\<R>) \\<and>\n     (\\<forall>m\\<ge>j.\n         m < k \\<longrightarrow> zero x ([xs !! m]\\<^sub>\\<R>))\n  Suc j \\<le> j'\n  \\<not> zero x ([xs !! j']\\<^sub>\\<R>)", "obtain j' where j':\n        \"j' > j\" \"\\<not> zero x ([xs !! j']\\<^sub>\\<R>)\" \"\\<forall> m \\<ge> j. m < j' \\<longrightarrow> zero x ([xs !! m]\\<^sub>\\<R>)\""], ["proof (prove)\nusing this:\n  j < j' \\<Longrightarrow>\n  \\<exists>k>j.\n     k \\<le> j' \\<and>\n     \\<not> zero x ([xs !! k]\\<^sub>\\<R>) \\<and>\n     (\\<forall>m\\<ge>j.\n         m < k \\<longrightarrow> zero x ([xs !! m]\\<^sub>\\<R>))\n  Suc j \\<le> j'\n  \\<not> zero x ([xs !! j']\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. (\\<And>j'.\n        \\<lbrakk>j < j'; \\<not> zero x ([xs !! j']\\<^sub>\\<R>);\n         \\<forall>m\\<ge>j.\n            m < j' \\<longrightarrow> zero x ([xs !! m]\\<^sub>\\<R>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  j < j'\n  \\<not> zero x ([xs !! j']\\<^sub>\\<R>)\n  \\<forall>m\\<ge>j. m < j' \\<longrightarrow> zero x ([xs !! m]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "from \\<open>x \\<in> X2\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> X2", "have \"x \\<in> \\<X>\""], ["proof (prove)\nusing this:\n  x \\<in> X2\n\ngoal (1 subgoal):\n 1. x \\<in> \\<X>", "unfolding X2_def"], ["proof (prove)\nusing this:\n  x \\<in> \\<X> - X1\n\ngoal (1 subgoal):\n 1. x \\<in> \\<X>", "by simp"], ["proof (state)\nthis:\n  x \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "with \\<open>i < j\\<close> not_reset not_reset_dur \\<open>stream_trans _\\<close> in_S pairwise_Suc[OF eq_elapsed]"], ["proof (chain)\npicking this:\n  i < j\n  \\<forall>m.\n     i < m \\<and> m < j \\<longrightarrow>\n     \\<not> zero x ([xs !! m]\\<^sub>\\<R>)\n  \\<lbrakk>\\<forall>k>?i.\n              k \\<le> ?j \\<longrightarrow>\n              \\<not> zero ?c ([?xs !! k]\\<^sub>\\<R>);\n   ?i \\<le> ?j; ?c \\<in> \\<X>; stream_trans ?xs;\n   \\<forall>i. eq_elapsed (?xs !! i) (?xs !! Suc i);\n   \\<forall>i. ?xs !! i \\<in> V\\<rbrakk>\n  \\<Longrightarrow> dur ?xs ?j - dur ?xs ?i =\n                    (?xs !! ?j) ?c - (?xs !! ?i) ?c\n  stream_trans xs\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  eq_elapsed (xs !! ?i) (xs !! Suc ?i)\n  x \\<in> \\<X>", "have\n        \"dur xs (j - 1) - dur xs i = (xs !! (j - 1)) x - (xs !! i) x\" (is \"?d1 = ?d2\")"], ["proof (prove)\nusing this:\n  i < j\n  \\<forall>m.\n     i < m \\<and> m < j \\<longrightarrow>\n     \\<not> zero x ([xs !! m]\\<^sub>\\<R>)\n  \\<lbrakk>\\<forall>k>?i.\n              k \\<le> ?j \\<longrightarrow>\n              \\<not> zero ?c ([?xs !! k]\\<^sub>\\<R>);\n   ?i \\<le> ?j; ?c \\<in> \\<X>; stream_trans ?xs;\n   \\<forall>i. eq_elapsed (?xs !! i) (?xs !! Suc i);\n   \\<forall>i. ?xs !! i \\<in> V\\<rbrakk>\n  \\<Longrightarrow> dur ?xs ?j - dur ?xs ?i =\n                    (?xs !! ?j) ?c - (?xs !! ?i) ?c\n  stream_trans xs\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  eq_elapsed (xs !! ?i) (xs !! Suc ?i)\n  x \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. dur xs (j - 1) - dur xs i = (xs !! (j - 1)) x - (xs !! i) x", "by (auto simp: stream.pred_set)"], ["proof (state)\nthis:\n  dur xs (j - 1) - dur xs i = (xs !! (j - 1)) x - (xs !! i) x\n\ngoal (1 subgoal):\n 1. \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "moreover"], ["proof (state)\nthis:\n  dur xs (j - 1) - dur xs i = (xs !! (j - 1)) x - (xs !! i) x\n\ngoal (1 subgoal):\n 1. \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "from \\<open>zero x ([xs !! i]\\<^sub>\\<R>)\\<close> in_S"], ["proof (chain)\npicking this:\n  zero x ([xs !! i]\\<^sub>\\<R>)\n  pred_stream (\\<lambda>u. u \\<in> V) xs", "have \"(xs !! i) x = 0\""], ["proof (prove)\nusing this:\n  zero x ([xs !! i]\\<^sub>\\<R>)\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n\ngoal (1 subgoal):\n 1. (xs !! i) x = 0", "by (auto intro: zeroD simp: stream.pred_set)"], ["proof (state)\nthis:\n  (xs !! i) x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "ultimately"], ["proof (chain)\npicking this:\n  dur xs (j - 1) - dur xs i = (xs !! (j - 1)) x - (xs !! i) x\n  (xs !! i) x = 0", "have\n        \"dur xs (j - 1) - dur xs i = (xs !! (j - 1)) x\" (is \"?d1 = ?d2\")"], ["proof (prove)\nusing this:\n  dur xs (j - 1) - dur xs i = (xs !! (j - 1)) x - (xs !! i) x\n  (xs !! i) x = 0\n\ngoal (1 subgoal):\n 1. dur xs (j - 1) - dur xs i = (xs !! (j - 1)) x", "by simp"], ["proof (state)\nthis:\n  dur xs (j - 1) - dur xs i = (xs !! (j - 1)) x\n\ngoal (1 subgoal):\n 1. \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "proof (cases \"?d1 \\<ge> 0.5\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 5 / 10 \\<le> dur xs (j - 1) - dur xs i \\<Longrightarrow>\n    \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i\n 2. \\<not> 5 / 10 \\<le> dur xs (j - 1) - dur xs i \\<Longrightarrow>\n    \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "case True"], ["proof (state)\nthis:\n  5 / 10 \\<le> dur xs (j - 1) - dur xs i\n\ngoal (2 subgoals):\n 1. 5 / 10 \\<le> dur xs (j - 1) - dur xs i \\<Longrightarrow>\n    \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i\n 2. \\<not> 5 / 10 \\<le> dur xs (j - 1) - dur xs i \\<Longrightarrow>\n    \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "(* XXX Fix SMT *)"], ["proof (state)\nthis:\n  5 / 10 \\<le> dur xs (j - 1) - dur xs i\n\ngoal (2 subgoals):\n 1. 5 / 10 \\<le> dur xs (j - 1) - dur xs i \\<Longrightarrow>\n    \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i\n 2. \\<not> 5 / 10 \\<le> dur xs (j - 1) - dur xs i \\<Longrightarrow>\n    \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "with dur_mono[of \"j - 1\" j xs]"], ["proof (chain)\npicking this:\n  j - 1 \\<le> j \\<Longrightarrow> dur xs (j - 1) \\<le> dur xs j\n  5 / 10 \\<le> dur xs (j - 1) - dur xs i", "have\n          \"5 / 10 \\<le> dur xs j - dur xs i\""], ["proof (prove)\nusing this:\n  j - 1 \\<le> j \\<Longrightarrow> dur xs (j - 1) \\<le> dur xs j\n  5 / 10 \\<le> dur xs (j - 1) - dur xs i\n\ngoal (1 subgoal):\n 1. 5 / 10 \\<le> dur xs j - dur xs i", "by simp"], ["proof (state)\nthis:\n  5 / 10 \\<le> dur xs j - dur xs i\n\ngoal (2 subgoals):\n 1. 5 / 10 \\<le> dur xs (j - 1) - dur xs i \\<Longrightarrow>\n    \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i\n 2. \\<not> 5 / 10 \\<le> dur xs (j - 1) - dur xs i \\<Longrightarrow>\n    \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "then"], ["proof (chain)\npicking this:\n  5 / 10 \\<le> dur xs j - dur xs i", "show ?thesis"], ["proof (prove)\nusing this:\n  5 / 10 \\<le> dur xs j - dur xs i\n\ngoal (1 subgoal):\n 1. \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "by blast"], ["proof (state)\nthis:\n  \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i\n\ngoal (1 subgoal):\n 1. \\<not> 5 / 10 \\<le> dur xs (j - 1) - dur xs i \\<Longrightarrow>\n    \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 5 / 10 \\<le> dur xs (j - 1) - dur xs i \\<Longrightarrow>\n    \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "case False"], ["proof (state)\nthis:\n  \\<not> 5 / 10 \\<le> dur xs (j - 1) - dur xs i\n\ngoal (1 subgoal):\n 1. \\<not> 5 / 10 \\<le> dur xs (j - 1) - dur xs i \\<Longrightarrow>\n    \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "have j_c_bound: \"(xs !! j) c \\<le> ?d2\" if \"c \\<in> X2\" for c"], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs !! j) c \\<le> (xs !! (j - 1)) x", "proof (cases \"(xs !! j) c = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (xs !! j) c = 0 \\<Longrightarrow> (xs !! j) c \\<le> (xs !! (j - 1)) x\n 2. (xs !! j) c \\<noteq> 0 \\<Longrightarrow>\n    (xs !! j) c \\<le> (xs !! (j - 1)) x", "case True"], ["proof (state)\nthis:\n  (xs !! j) c = 0\n\ngoal (2 subgoals):\n 1. (xs !! j) c = 0 \\<Longrightarrow> (xs !! j) c \\<le> (xs !! (j - 1)) x\n 2. (xs !! j) c \\<noteq> 0 \\<Longrightarrow>\n    (xs !! j) c \\<le> (xs !! (j - 1)) x", "from in_S \\<open>j > _\\<close> True \\<open>x \\<in> \\<X>\\<close>"], ["proof (chain)\npicking this:\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  i < j\n  (xs !! j) c = 0\n  x \\<in> \\<X>", "show ?thesis"], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  i < j\n  (xs !! j) c = 0\n  x \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. (xs !! j) c \\<le> (xs !! (j - 1)) x", "by (auto simp: V_def stream.pred_set)"], ["proof (state)\nthis:\n  (xs !! j) c \\<le> (xs !! (j - 1)) x\n\ngoal (1 subgoal):\n 1. (xs !! j) c \\<noteq> 0 \\<Longrightarrow>\n    (xs !! j) c \\<le> (xs !! (j - 1)) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (xs !! j) c \\<noteq> 0 \\<Longrightarrow>\n    (xs !! j) c \\<le> (xs !! (j - 1)) x", "case False"], ["proof (state)\nthis:\n  (xs !! j) c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (xs !! j) c \\<noteq> 0 \\<Longrightarrow>\n    (xs !! j) c \\<le> (xs !! (j - 1)) x", "from X2 \\<open>c \\<in> X2\\<close> in_S"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>X2.\n     \\<exists>m>i. m \\<le> j \\<and> zero x ([xs !! m]\\<^sub>\\<R>)\n  c \\<in> X2\n  pred_stream (\\<lambda>u. u \\<in> V) xs", "have \"\\<exists>k>i. k \\<le> j \\<and> (xs !! k) c = 0\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>X2.\n     \\<exists>m>i. m \\<le> j \\<and> zero x ([xs !! m]\\<^sub>\\<R>)\n  c \\<in> X2\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n\ngoal (1 subgoal):\n 1. \\<exists>k>i. k \\<le> j \\<and> (xs !! k) c = 0", "by (force simp: zeroD stream.pred_set)"], ["proof (state)\nthis:\n  \\<exists>k>i. k \\<le> j \\<and> (xs !! k) c = 0\n\ngoal (1 subgoal):\n 1. (xs !! j) c \\<noteq> 0 \\<Longrightarrow>\n    (xs !! j) c \\<le> (xs !! (j - 1)) x", "with False"], ["proof (chain)\npicking this:\n  (xs !! j) c \\<noteq> 0\n  \\<exists>k>i. k \\<le> j \\<and> (xs !! k) c = 0", "have\n            \"\\<exists>k>i. k \\<le> j - Suc 0 \\<and> (xs !! k) c = 0\""], ["proof (prove)\nusing this:\n  (xs !! j) c \\<noteq> 0\n  \\<exists>k>i. k \\<le> j \\<and> (xs !! k) c = 0\n\ngoal (1 subgoal):\n 1. \\<exists>k>i. k \\<le> j - Suc 0 \\<and> (xs !! k) c = 0", "by (metis Suc_le_eq Suc_pred linorder_neqE_nat not_less not_less_zero)"], ["proof (state)\nthis:\n  \\<exists>k>i. k \\<le> j - Suc 0 \\<and> (xs !! k) c = 0\n\ngoal (1 subgoal):\n 1. (xs !! j) c \\<noteq> 0 \\<Longrightarrow>\n    (xs !! j) c \\<le> (xs !! (j - 1)) x", "moreover"], ["proof (state)\nthis:\n  \\<exists>k>i. k \\<le> j - Suc 0 \\<and> (xs !! k) c = 0\n\ngoal (1 subgoal):\n 1. (xs !! j) c \\<noteq> 0 \\<Longrightarrow>\n    (xs !! j) c \\<le> (xs !! (j - 1)) x", "from that"], ["proof (chain)\npicking this:\n  c \\<in> X2", "have \"c \\<in> \\<X>\""], ["proof (prove)\nusing this:\n  c \\<in> X2\n\ngoal (1 subgoal):\n 1. c \\<in> \\<X>", "by (auto simp: X2_def)"], ["proof (state)\nthis:\n  c \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. (xs !! j) c \\<noteq> 0 \\<Longrightarrow>\n    (xs !! j) c \\<le> (xs !! (j - 1)) x", "moreover"], ["proof (state)\nthis:\n  c \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. (xs !! j) c \\<noteq> 0 \\<Longrightarrow>\n    (xs !! j) c \\<le> (xs !! (j - 1)) x", "from not_reset in_S \\<open>x \\<in> \\<X>\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>m.\n     i < m \\<and> m < j \\<longrightarrow>\n     \\<not> zero x ([xs !! m]\\<^sub>\\<R>)\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  x \\<in> \\<X>", "have\n            \"\\<forall>k>i. k \\<le> j - 1 \\<longrightarrow> (xs !! k) x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<forall>m.\n     i < m \\<and> m < j \\<longrightarrow>\n     \\<not> zero x ([xs !! m]\\<^sub>\\<R>)\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  x \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. \\<forall>k>i. k \\<le> j - 1 \\<longrightarrow> (xs !! k) x \\<noteq> 0", "by (auto simp: zeroI stream.pred_set)"], ["proof (state)\nthis:\n  \\<forall>k>i. k \\<le> j - 1 \\<longrightarrow> (xs !! k) x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (xs !! j) c \\<noteq> 0 \\<Longrightarrow>\n    (xs !! j) c \\<le> (xs !! (j - 1)) x", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>k>i. k \\<le> j - Suc 0 \\<and> (xs !! k) c = 0\n  c \\<in> \\<X>\n  \\<forall>k>i. k \\<le> j - 1 \\<longrightarrow> (xs !! k) x \\<noteq> 0", "have\n            \"(xs !! (j - 1)) c \\<le> ?d2\""], ["proof (prove)\nusing this:\n  \\<exists>k>i. k \\<le> j - Suc 0 \\<and> (xs !! k) c = 0\n  c \\<in> \\<X>\n  \\<forall>k>i. k \\<le> j - 1 \\<longrightarrow> (xs !! k) x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (xs !! (j - 1)) c \\<le> (xs !! (j - 1)) x", "using trans in_S \\<open>_ x = 0\\<close> \\<open>x \\<in> \\<X>\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>k>i. k \\<le> j - Suc 0 \\<and> (xs !! k) c = 0\n  c \\<in> \\<X>\n  \\<forall>k>i. k \\<le> j - 1 \\<longrightarrow> (xs !! k) x \\<noteq> 0\n  stream_trans xs\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  (xs !! i) x = 0\n  x \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. (xs !! (j - 1)) c \\<le> (xs !! (j - 1)) x", "by (auto intro: \\<R>_divergent_divergent_aux that simp: stream.pred_set)"], ["proof (state)\nthis:\n  (xs !! (j - 1)) c \\<le> (xs !! (j - 1)) x\n\ngoal (1 subgoal):\n 1. (xs !! j) c \\<noteq> 0 \\<Longrightarrow>\n    (xs !! j) c \\<le> (xs !! (j - 1)) x", "moreover"], ["proof (state)\nthis:\n  (xs !! (j - 1)) c \\<le> (xs !! (j - 1)) x\n\ngoal (1 subgoal):\n 1. (xs !! j) c \\<noteq> 0 \\<Longrightarrow>\n    (xs !! j) c \\<le> (xs !! (j - 1)) x", "from\n            trans_not_delay_mono[OF pairwise_Suc[OF trans], of \"j - 1\"]\n            \\<open>x \\<in> \\<X>\\<close> \\<open>c \\<in> \\<X>\\<close> \\<open>j > _\\<close> in_S x(4)"], ["proof (chain)\npicking this:\n  \\<lbrakk>xs !! (j - 1) \\<in> V; ?x \\<in> \\<X>; (xs !! Suc (j - 1)) ?x = 0;\n   ?c \\<in> \\<X>\\<rbrakk>\n  \\<Longrightarrow> (xs !! Suc (j - 1)) ?c \\<le> (xs !! (j - 1)) ?c\n  x \\<in> \\<X>\n  c \\<in> \\<X>\n  i < j\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  zero x ([xs !! j]\\<^sub>\\<R>)", "have \"(xs !! j) c \\<le> (xs !! (j - 1)) c\""], ["proof (prove)\nusing this:\n  \\<lbrakk>xs !! (j - 1) \\<in> V; ?x \\<in> \\<X>; (xs !! Suc (j - 1)) ?x = 0;\n   ?c \\<in> \\<X>\\<rbrakk>\n  \\<Longrightarrow> (xs !! Suc (j - 1)) ?c \\<le> (xs !! (j - 1)) ?c\n  x \\<in> \\<X>\n  c \\<in> \\<X>\n  i < j\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  zero x ([xs !! j]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. (xs !! j) c \\<le> (xs !! (j - 1)) c", "by (auto simp: zeroD stream.pred_set)"], ["proof (state)\nthis:\n  (xs !! j) c \\<le> (xs !! (j - 1)) c\n\ngoal (1 subgoal):\n 1. (xs !! j) c \\<noteq> 0 \\<Longrightarrow>\n    (xs !! j) c \\<le> (xs !! (j - 1)) x", "ultimately"], ["proof (chain)\npicking this:\n  (xs !! (j - 1)) c \\<le> (xs !! (j - 1)) x\n  (xs !! j) c \\<le> (xs !! (j - 1)) c", "show ?thesis"], ["proof (prove)\nusing this:\n  (xs !! (j - 1)) c \\<le> (xs !! (j - 1)) x\n  (xs !! j) c \\<le> (xs !! (j - 1)) c\n\ngoal (1 subgoal):\n 1. (xs !! j) c \\<le> (xs !! (j - 1)) x", "by auto"], ["proof (state)\nthis:\n  (xs !! j) c \\<le> (xs !! (j - 1)) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?c8 \\<in> X2 \\<Longrightarrow> (xs !! j) ?c8 \\<le> (xs !! (j - 1)) x\n\ngoal (1 subgoal):\n 1. \\<not> 5 / 10 \\<le> dur xs (j - 1) - dur xs i \\<Longrightarrow>\n    \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "moreover"], ["proof (state)\nthis:\n  ?c8 \\<in> X2 \\<Longrightarrow> (xs !! j) ?c8 \\<le> (xs !! (j - 1)) x\n\ngoal (1 subgoal):\n 1. \\<not> 5 / 10 \\<le> dur xs (j - 1) - dur xs i \\<Longrightarrow>\n    \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "from False \\<open>?d1 = ?d2\\<close>"], ["proof (chain)\npicking this:\n  \\<not> 5 / 10 \\<le> dur xs (j - 1) - dur xs i\n  dur xs (j - 1) - dur xs i = (xs !! (j - 1)) x", "have \"?d2 < 1\""], ["proof (prove)\nusing this:\n  \\<not> 5 / 10 \\<le> dur xs (j - 1) - dur xs i\n  dur xs (j - 1) - dur xs i = (xs !! (j - 1)) x\n\ngoal (1 subgoal):\n 1. (xs !! (j - 1)) x < 1", "by auto"], ["proof (state)\nthis:\n  (xs !! (j - 1)) x < 1\n\ngoal (1 subgoal):\n 1. \\<not> 5 / 10 \\<le> dur xs (j - 1) - dur xs i \\<Longrightarrow>\n    \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "moreover"], ["proof (state)\nthis:\n  (xs !! (j - 1)) x < 1\n\ngoal (1 subgoal):\n 1. \\<not> 5 / 10 \\<le> dur xs (j - 1) - dur xs i \\<Longrightarrow>\n    \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "from in_S"], ["proof (chain)\npicking this:\n  pred_stream (\\<lambda>u. u \\<in> V) xs", "have \"(xs !! j) c \\<ge> 0\" if \"c \\<in> \\<X>\" for c"], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n\ngoal (1 subgoal):\n 1. 0 \\<le> (xs !! j) c", "using that"], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  c \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. 0 \\<le> (xs !! j) c", "by (auto simp: V_def stream.pred_set)"], ["proof (state)\nthis:\n  ?c8 \\<in> \\<X> \\<Longrightarrow> 0 \\<le> (xs !! j) ?c8\n\ngoal (1 subgoal):\n 1. \\<not> 5 / 10 \\<le> dur xs (j - 1) - dur xs i \\<Longrightarrow>\n    \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "ultimately"], ["proof (chain)\npicking this:\n  ?c8 \\<in> X2 \\<Longrightarrow> (xs !! j) ?c8 \\<le> (xs !! (j - 1)) x\n  (xs !! (j - 1)) x < 1\n  ?c8 \\<in> \\<X> \\<Longrightarrow> 0 \\<le> (xs !! j) ?c8", "have frac_bound: \"frac ((xs !! j) c) \\<le> ?d2\" if \"c \\<in> X2\" for c"], ["proof (prove)\nusing this:\n  ?c8 \\<in> X2 \\<Longrightarrow> (xs !! j) ?c8 \\<le> (xs !! (j - 1)) x\n  (xs !! (j - 1)) x < 1\n  ?c8 \\<in> \\<X> \\<Longrightarrow> 0 \\<le> (xs !! j) ?c8\n\ngoal (1 subgoal):\n 1. frac ((xs !! j) c) \\<le> (xs !! (j - 1)) x", "using that frac_le_1I"], ["proof (prove)\nusing this:\n  ?c8 \\<in> X2 \\<Longrightarrow> (xs !! j) ?c8 \\<le> (xs !! (j - 1)) x\n  (xs !! (j - 1)) x < 1\n  ?c8 \\<in> \\<X> \\<Longrightarrow> 0 \\<le> (xs !! j) ?c8\n  c \\<in> X2\n  \\<lbrakk>(0::?'a) \\<le> ?x; ?x \\<le> (1::?'a); ?x \\<le> ?y\\<rbrakk>\n  \\<Longrightarrow> frac ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. frac ((xs !! j) c) \\<le> (xs !! (j - 1)) x", "by (force simp: X2_def)"], ["proof (state)\nthis:\n  ?c8 \\<in> X2 \\<Longrightarrow>\n  frac ((xs !! j) ?c8) \\<le> (xs !! (j - 1)) x\n\ngoal (1 subgoal):\n 1. \\<not> 5 / 10 \\<le> dur xs (j - 1) - dur xs i \\<Longrightarrow>\n    \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "let ?u = \"(xs !! j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 5 / 10 \\<le> dur xs (j - 1) - dur xs i \\<Longrightarrow>\n    \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "from in_S"], ["proof (chain)\npicking this:\n  pred_stream (\\<lambda>u. u \\<in> V) xs", "have \"[xs !! j]\\<^sub>\\<R> \\<in> \\<R>\""], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n\ngoal (1 subgoal):\n 1. [xs !! j]\\<^sub>\\<R> \\<in> \\<R>", "by (auto simp: stream.pred_set)"], ["proof (state)\nthis:\n  [xs !! j]\\<^sub>\\<R> \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<not> 5 / 10 \\<le> dur xs (j - 1) - dur xs i \\<Longrightarrow>\n    \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "then"], ["proof (chain)\npicking this:\n  [xs !! j]\\<^sub>\\<R> \\<in> \\<R>", "obtain I r where region:\n          \"[xs !! j]\\<^sub>\\<R> = region \\<X> I r\" \"valid_region \\<X> k I r\""], ["proof (prove)\nusing this:\n  [xs !! j]\\<^sub>\\<R> \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. (\\<And>I r.\n        \\<lbrakk>[xs !! j]\\<^sub>\\<R> = Regions.region \\<X> I r;\n         Regions.valid_region \\<X> k I r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<R>_def"], ["proof (prove)\nusing this:\n  [xs !!\n   j]\\<^sub>{Regions.region \\<X> I r |I r. Regions.valid_region \\<X> k I r}\n  \\<in> {Regions.region \\<X> I r |I r. Regions.valid_region \\<X> k I r}\n\ngoal (1 subgoal):\n 1. (\\<And>I r.\n        \\<lbrakk>[xs !!\n                  j]\\<^sub>{Regions.region \\<X> I r |I r.\n                            Regions.valid_region \\<X> k I r} =\n                 Regions.region \\<X> I r;\n         Regions.valid_region \\<X> k I r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  [xs !! j]\\<^sub>\\<R> = Regions.region \\<X> I r\n  Regions.valid_region \\<X> k I r\n\ngoal (1 subgoal):\n 1. \\<not> 5 / 10 \\<le> dur xs (j - 1) - dur xs i \\<Longrightarrow>\n    \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "let ?S = \"{frac (?u c) | c. c \\<in> \\<X> \\<and> isIntv (I c)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 5 / 10 \\<le> dur xs (j - 1) - dur xs i \\<Longrightarrow>\n    \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "have \\<X>_X2: \"c \\<in> X2\" if \"c \\<in> \\<X>\" \"isIntv (I c)\" for c"], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<in> X2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<in> X2", "from X1 \\<open>j > i\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>X1. \\<forall>m\\<ge>i. unbounded x ([xs !! m]\\<^sub>\\<R>)\n  i < j", "have \"\\<forall>x\\<in>X1. unbounded x ([xs !! j]\\<^sub>\\<R>)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>X1. \\<forall>m\\<ge>i. unbounded x ([xs !! m]\\<^sub>\\<R>)\n  i < j\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>X1. unbounded x ([xs !! j]\\<^sub>\\<R>)", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>X1. unbounded x ([xs !! j]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. c \\<in> X2", "with unbounded_Greater[OF region(2) \\<open>c \\<in> \\<X>\\<close>] region(1) that(2)"], ["proof (chain)\npicking this:\n  unbounded c (Regions.region \\<X> I r) \\<Longrightarrow>\n  I c = Regions.intv.Greater (k c)\n  [xs !! j]\\<^sub>\\<R> = Regions.region \\<X> I r\n  Regions.isIntv (I c)\n  \\<forall>x\\<in>X1. unbounded x ([xs !! j]\\<^sub>\\<R>)", "have \"c \\<notin> X1\""], ["proof (prove)\nusing this:\n  unbounded c (Regions.region \\<X> I r) \\<Longrightarrow>\n  I c = Regions.intv.Greater (k c)\n  [xs !! j]\\<^sub>\\<R> = Regions.region \\<X> I r\n  Regions.isIntv (I c)\n  \\<forall>x\\<in>X1. unbounded x ([xs !! j]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. c \\<notin> X1", "by auto"], ["proof (state)\nthis:\n  c \\<notin> X1\n\ngoal (1 subgoal):\n 1. c \\<in> X2", "with \\<open>c \\<in> \\<X>\\<close>"], ["proof (chain)\npicking this:\n  c \\<in> \\<X>\n  c \\<notin> X1", "show \"c \\<in> X2\""], ["proof (prove)\nusing this:\n  c \\<in> \\<X>\n  c \\<notin> X1\n\ngoal (1 subgoal):\n 1. c \\<in> X2", "unfolding X2_def"], ["proof (prove)\nusing this:\n  c \\<in> \\<X>\n  c \\<notin> X1\n\ngoal (1 subgoal):\n 1. c \\<in> \\<X> - X1", "by auto"], ["proof (state)\nthis:\n  c \\<in> X2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?c8 \\<in> \\<X>; Regions.isIntv (I ?c8)\\<rbrakk>\n  \\<Longrightarrow> ?c8 \\<in> X2\n\ngoal (1 subgoal):\n 1. \\<not> 5 / 10 \\<le> dur xs (j - 1) - dur xs i \\<Longrightarrow>\n    \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "have frac_bound: \"frac ((xs !! j) c) \\<le> ?d2\" if \"c \\<in> \\<X>\" \"isIntv (I c)\" for c"], ["proof (prove)\ngoal (1 subgoal):\n 1. frac ((xs !! j) c) \\<le> (xs !! (j - 1)) x", "using frac_bound[OF \\<X>_X2] that"], ["proof (prove)\nusing this:\n  \\<lbrakk>?c8 \\<in> \\<X>; Regions.isIntv (I ?c8)\\<rbrakk>\n  \\<Longrightarrow> frac ((xs !! j) ?c8) \\<le> (xs !! (j - 1)) x\n  c \\<in> \\<X>\n  Regions.isIntv (I c)\n\ngoal (1 subgoal):\n 1. frac ((xs !! j) c) \\<le> (xs !! (j - 1)) x", "."], ["proof (state)\nthis:\n  \\<lbrakk>?c8 \\<in> \\<X>; Regions.isIntv (I ?c8)\\<rbrakk>\n  \\<Longrightarrow> frac ((xs !! j) ?c8) \\<le> (xs !! (j - 1)) x\n\ngoal (1 subgoal):\n 1. \\<not> 5 / 10 \\<le> dur xs (j - 1) - dur xs i \\<Longrightarrow>\n    \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "have \"dur xs (j' - 1) = dur xs j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dur xs (j' - 1) = dur xs j", "using j' \\<open>x \\<in> \\<X>\\<close> in_S eq_elapsed"], ["proof (prove)\nusing this:\n  j < j'\n  \\<not> zero x ([xs !! j']\\<^sub>\\<R>)\n  \\<forall>m\\<ge>j. m < j' \\<longrightarrow> zero x ([xs !! m]\\<^sub>\\<R>)\n  x \\<in> \\<X>\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  PTA_Reachability.pairwise eq_elapsed xs\n\ngoal (1 subgoal):\n 1. dur xs (j' - 1) = dur xs j", "by (subst dur_zero_tail[where \\<omega> = \"smap (\\<lambda> u. [u]\\<^sub>\\<R>) xs\"])\n            (auto dest: pairwise_Suc simp: stream.pred_set)"], ["proof (state)\nthis:\n  dur xs (j' - 1) = dur xs j\n\ngoal (1 subgoal):\n 1. \\<not> 5 / 10 \\<le> dur xs (j - 1) - dur xs i \\<Longrightarrow>\n    \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "moreover"], ["proof (state)\nthis:\n  dur xs (j' - 1) = dur xs j\n\ngoal (1 subgoal):\n 1. \\<not> 5 / 10 \\<le> dur xs (j - 1) - dur xs i \\<Longrightarrow>\n    \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "from dur_reset[OF eq_elapsed in_S, of x \"j - 1\"] \\<open>x \\<in> \\<X>\\<close> x(4) \\<open>j > _\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>zero x ([xs !! Suc (j - 1)]\\<^sub>\\<R>); x \\<in> \\<X>\\<rbrakk>\n  \\<Longrightarrow> dur xs (Suc (j - 1)) - dur xs (j - 1) = 0\n  x \\<in> \\<X>\n  zero x ([xs !! j]\\<^sub>\\<R>)\n  i < j", "have\n          \"dur xs j = dur xs (j - 1)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>zero x ([xs !! Suc (j - 1)]\\<^sub>\\<R>); x \\<in> \\<X>\\<rbrakk>\n  \\<Longrightarrow> dur xs (Suc (j - 1)) - dur xs (j - 1) = 0\n  x \\<in> \\<X>\n  zero x ([xs !! j]\\<^sub>\\<R>)\n  i < j\n\ngoal (1 subgoal):\n 1. dur xs j = dur xs (j - 1)", "by (auto simp: stream.pred_set)"], ["proof (state)\nthis:\n  dur xs j = dur xs (j - 1)\n\ngoal (1 subgoal):\n 1. \\<not> 5 / 10 \\<le> dur xs (j - 1) - dur xs i \\<Longrightarrow>\n    \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "ultimately"], ["proof (chain)\npicking this:\n  dur xs (j' - 1) = dur xs j\n  dur xs j = dur xs (j - 1)", "have \"dur xs (j' - 1) = dur xs (j - 1)\""], ["proof (prove)\nusing this:\n  dur xs (j' - 1) = dur xs j\n  dur xs j = dur xs (j - 1)\n\ngoal (1 subgoal):\n 1. dur xs (j' - 1) = dur xs (j - 1)", "by auto"], ["proof (state)\nthis:\n  dur xs (j' - 1) = dur xs (j - 1)\n\ngoal (1 subgoal):\n 1. \\<not> 5 / 10 \\<le> dur xs (j - 1) - dur xs i \\<Longrightarrow>\n    \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "moreover"], ["proof (state)\nthis:\n  dur xs (j' - 1) = dur xs (j - 1)\n\ngoal (1 subgoal):\n 1. \\<not> 5 / 10 \\<le> dur xs (j - 1) - dur xs i \\<Longrightarrow>\n    \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "have \"dur xs j' - dur xs (j' - 1) \\<ge> (1 - ?d2) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - (xs !! (j - 1)) x) / 2 \\<le> dur xs j' - dur xs (j' - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (1 - (xs !! (j - 1)) x) / 2 \\<le> dur xs j' - dur xs (j' - 1)", "from \\<open>j' > _\\<close>"], ["proof (chain)\npicking this:\n  j < j'", "have \"j' > 0\""], ["proof (prove)\nusing this:\n  j < j'\n\ngoal (1 subgoal):\n 1. 0 < j'", "by auto"], ["proof (state)\nthis:\n  0 < j'\n\ngoal (1 subgoal):\n 1. (1 - (xs !! (j - 1)) x) / 2 \\<le> dur xs j' - dur xs (j' - 1)", "with pairwise_Suc[OF trans', of \"j' - 1\"]"], ["proof (chain)\npicking this:\n  trans' (xs !! (j' - 1)) (xs !! Suc (j' - 1))\n  0 < j'", "have\n            \"trans' (xs !! (j' - 1)) (xs !! j')\""], ["proof (prove)\nusing this:\n  trans' (xs !! (j' - 1)) (xs !! Suc (j' - 1))\n  0 < j'\n\ngoal (1 subgoal):\n 1. trans' (xs !! (j' - 1)) (xs !! j')", "by auto"], ["proof (state)\nthis:\n  trans' (xs !! (j' - 1)) (xs !! j')\n\ngoal (1 subgoal):\n 1. (1 - (xs !! (j - 1)) x) / 2 \\<le> dur xs j' - dur xs (j' - 1)", "moreover"], ["proof (state)\nthis:\n  trans' (xs !! (j' - 1)) (xs !! j')\n\ngoal (1 subgoal):\n 1. (1 - (xs !! (j - 1)) x) / 2 \\<le> dur xs j' - dur xs (j' - 1)", "from j'"], ["proof (chain)\npicking this:\n  j < j'\n  \\<not> zero x ([xs !! j']\\<^sub>\\<R>)\n  \\<forall>m\\<ge>j. m < j' \\<longrightarrow> zero x ([xs !! m]\\<^sub>\\<R>)", "have\n            \"(xs !! (j' - 1)) x = 0\" \"(xs !! j') x > 0\""], ["proof (prove)\nusing this:\n  j < j'\n  \\<not> zero x ([xs !! j']\\<^sub>\\<R>)\n  \\<forall>m\\<ge>j. m < j' \\<longrightarrow> zero x ([xs !! m]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. (xs !! (j' - 1)) x = 0 &&& 0 < (xs !! j') x", "using in_S \\<open>x \\<in> \\<X>\\<close>"], ["proof (prove)\nusing this:\n  j < j'\n  \\<not> zero x ([xs !! j']\\<^sub>\\<R>)\n  \\<forall>m\\<ge>j. m < j' \\<longrightarrow> zero x ([xs !! m]\\<^sub>\\<R>)\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  x \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. (xs !! (j' - 1)) x = 0 &&& 0 < (xs !! j') x", "by (force intro: zeroD dest: not_zeroD simp: stream.pred_set)+"], ["proof (state)\nthis:\n  (xs !! (j' - 1)) x = 0\n  0 < (xs !! j') x\n\ngoal (1 subgoal):\n 1. (1 - (xs !! (j - 1)) x) / 2 \\<le> dur xs j' - dur xs (j' - 1)", "moreover"], ["proof (state)\nthis:\n  (xs !! (j' - 1)) x = 0\n  0 < (xs !! j') x\n\ngoal (1 subgoal):\n 1. (1 - (xs !! (j - 1)) x) / 2 \\<le> dur xs j' - dur xs (j' - 1)", "note delayedR_aux = calculation"], ["proof (state)\nthis:\n  trans' (xs !! (j' - 1)) (xs !! j')\n  (xs !! (j' - 1)) x = 0\n  0 < (xs !! j') x\n\ngoal (1 subgoal):\n 1. (1 - (xs !! (j - 1)) x) / 2 \\<le> dur xs j' - dur xs (j' - 1)", "obtain t where\n            \"(xs !! j') = (xs !! (j' - 1)) \\<oplus> t\" \"t \\<ge> (1 - ?d2) / 2\" \"t \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>xs !! j' = xs !! (j' - 1) \\<oplus> t;\n         (1 - (xs !! (j - 1)) x) / 2 \\<le> t; 0 \\<le> t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>xs !! j' = xs !! (j' - 1) \\<oplus> t;\n         (1 - (xs !! (j - 1)) x) / 2 \\<le> t; 0 \\<le> t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from in_S"], ["proof (chain)\npicking this:\n  pred_stream (\\<lambda>u. u \\<in> V) xs", "have \"[xs !! j']\\<^sub>\\<R> \\<in> \\<R>\""], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n\ngoal (1 subgoal):\n 1. [xs !! j']\\<^sub>\\<R> \\<in> \\<R>", "by (auto simp: stream.pred_set)"], ["proof (state)\nthis:\n  [xs !! j']\\<^sub>\\<R> \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>xs !! j' = xs !! (j' - 1) \\<oplus> t;\n         (1 - (xs !! (j - 1)) x) / 2 \\<le> t; 0 \\<le> t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  [xs !! j']\\<^sub>\\<R> \\<in> \\<R>", "obtain I' r' where region':\n              \"[xs !! j']\\<^sub>\\<R> = region \\<X> I' r'\" \"valid_region \\<X> k I' r'\""], ["proof (prove)\nusing this:\n  [xs !! j']\\<^sub>\\<R> \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. (\\<And>I' r'.\n        \\<lbrakk>[xs !! j']\\<^sub>\\<R> = Regions.region \\<X> I' r';\n         Regions.valid_region \\<X> k I' r'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<R>_def"], ["proof (prove)\nusing this:\n  [xs !!\n   j']\\<^sub>{Regions.region \\<X> I r |I r. Regions.valid_region \\<X> k I r}\n  \\<in> {Regions.region \\<X> I r |I r. Regions.valid_region \\<X> k I r}\n\ngoal (1 subgoal):\n 1. (\\<And>I' r'.\n        \\<lbrakk>[xs !!\n                  j']\\<^sub>{Regions.region \\<X> I r |I r.\n                             Regions.valid_region \\<X> k I r} =\n                 Regions.region \\<X> I' r';\n         Regions.valid_region \\<X> k I' r'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  [xs !! j']\\<^sub>\\<R> = Regions.region \\<X> I' r'\n  Regions.valid_region \\<X> k I' r'\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>xs !! j' = xs !! (j' - 1) \\<oplus> t;\n         (1 - (xs !! (j - 1)) x) / 2 \\<le> t; 0 \\<le> t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?S' = \"{frac ((xs !! (j' - 1)) c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I' c)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>xs !! j' = xs !! (j' - 1) \\<oplus> t;\n         (1 - (xs !! (j - 1)) x) / 2 \\<le> t; 0 \\<le> t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from finite(1)"], ["proof (chain)\npicking this:\n  finite \\<X>", "have \"?d2 \\<ge> Max (?S' \\<union> {0})\""], ["proof (prove)\nusing this:\n  finite \\<X>\n\ngoal (1 subgoal):\n 1. Max ({frac ((xs !! (j' - 1)) c) |c.\n          c \\<in> \\<X> \\<and> Regions.isIntv (I' c)} \\<union>\n         {0})\n    \\<le> (xs !! (j - 1)) x", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite \\<X> \\<Longrightarrow>\n    Max ({frac ((xs !! (j' - 1)) c) |c.\n          c \\<in> \\<X> \\<and> Regions.isIntv (I' c)} \\<union>\n         {0})\n    \\<le> (xs !! (j - 1)) x", "apply (rule Max.boundedI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite \\<X> \\<Longrightarrow>\n    finite\n     ({frac ((xs !! (j' - 1)) c) |c.\n       c \\<in> \\<X> \\<and> Regions.isIntv (I' c)} \\<union>\n      {0})\n 2. finite \\<X> \\<Longrightarrow>\n    {frac ((xs !! (j' - 1)) c) |c.\n     c \\<in> \\<X> \\<and> Regions.isIntv (I' c)} \\<union>\n    {0} \\<noteq>\n    {}\n 3. \\<And>a.\n       \\<lbrakk>finite \\<X>;\n        a \\<in> {frac ((xs !! (j' - 1)) c) |c.\n                 c \\<in> \\<X> \\<and> Regions.isIntv (I' c)} \\<union>\n                {0}\\<rbrakk>\n       \\<Longrightarrow> a \\<le> (xs !! (j - 1)) x", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite \\<X> \\<Longrightarrow>\n    {frac ((xs !! (j' - 1)) c) |c.\n     c \\<in> \\<X> \\<and> Regions.isIntv (I' c)} \\<union>\n    {0} \\<noteq>\n    {}\n 2. \\<And>a.\n       \\<lbrakk>finite \\<X>;\n        a \\<in> {frac ((xs !! (j' - 1)) c) |c.\n                 c \\<in> \\<X> \\<and> Regions.isIntv (I' c)} \\<union>\n                {0}\\<rbrakk>\n       \\<Longrightarrow> a \\<le> (xs !! (j - 1)) x", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>finite \\<X>;\n        a \\<in> {frac ((xs !! (j' - 1)) c) |c.\n                 c \\<in> \\<X> \\<and> Regions.isIntv (I' c)} \\<union>\n                {0}\\<rbrakk>\n       \\<Longrightarrow> a \\<le> (xs !! (j - 1)) x", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a c uu_.\n       \\<lbrakk>finite \\<X>; c \\<in> \\<X>;\n        I' c = Regions.intv.Intv uu_\\<rbrakk>\n       \\<Longrightarrow> frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x\n 2. \\<And>a. finite \\<X> \\<Longrightarrow> 0 \\<le> (xs !! (j - 1)) x", "subgoal premises prems for _ c d"], ["proof (prove)\ngoal (1 subgoal):\n 1. frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x", "from j'"], ["proof (chain)\npicking this:\n  j < j'\n  \\<not> zero x ([xs !! j']\\<^sub>\\<R>)\n  \\<forall>m\\<ge>j. m < j' \\<longrightarrow> zero x ([xs !! m]\\<^sub>\\<R>)", "have \"(xs !! (j' - 1)) c = ?u c \\<or> (xs !! (j' - 1)) c = 0\""], ["proof (prove)\nusing this:\n  j < j'\n  \\<not> zero x ([xs !! j']\\<^sub>\\<R>)\n  \\<forall>m\\<ge>j. m < j' \\<longrightarrow> zero x ([xs !! m]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. (xs !! (j' - 1)) c = (xs !! j) c \\<or> (xs !! (j' - 1)) c = 0", "by (intro resets_mono'[OF eq_elapsed in_S trans _ \\<open>x \\<in> \\<X>\\<close> \\<open>c \\<in> \\<X>\\<close>]; auto)"], ["proof (state)\nthis:\n  (xs !! (j' - 1)) c = (xs !! j) c \\<or> (xs !! (j' - 1)) c = 0\n\ngoal (1 subgoal):\n 1. frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x", "then"], ["proof (chain)\npicking this:\n  (xs !! (j' - 1)) c = (xs !! j) c \\<or> (xs !! (j' - 1)) c = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  (xs !! (j' - 1)) c = (xs !! j) c \\<or> (xs !! (j' - 1)) c = 0\n\ngoal (1 subgoal):\n 1. frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x", "proof (standard, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. (xs !! (j' - 1)) c = (xs !! j) c \\<Longrightarrow>\n    frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x\n 2. (xs !! (j' - 1)) c = 0 \\<Longrightarrow>\n    frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x", "case A: 1"], ["proof (state)\nthis:\n  (xs !! (j' - 1)) c = (xs !! j) c\n\ngoal (2 subgoals):\n 1. (xs !! (j' - 1)) c = (xs !! j) c \\<Longrightarrow>\n    frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x\n 2. (xs !! (j' - 1)) c = 0 \\<Longrightarrow>\n    frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x", "proof (cases \"c \\<in> X1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c \\<in> X1 \\<Longrightarrow>\n    frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x\n 2. c \\<notin> X1 \\<Longrightarrow>\n    frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x", "case True"], ["proof (state)\nthis:\n  c \\<in> X1\n\ngoal (2 subgoals):\n 1. c \\<in> X1 \\<Longrightarrow>\n    frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x\n 2. c \\<notin> X1 \\<Longrightarrow>\n    frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x", "with X1 \\<open>j' > j\\<close> \\<open>j > i\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>X1. \\<forall>m\\<ge>i. unbounded x ([xs !! m]\\<^sub>\\<R>)\n  j < j'\n  i < j\n  c \\<in> X1", "have \"unbounded c ([xs !! j']\\<^sub>\\<R>)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>X1. \\<forall>m\\<ge>i. unbounded x ([xs !! m]\\<^sub>\\<R>)\n  j < j'\n  i < j\n  c \\<in> X1\n\ngoal (1 subgoal):\n 1. unbounded c ([xs !! j']\\<^sub>\\<R>)", "by auto"], ["proof (state)\nthis:\n  unbounded c ([xs !! j']\\<^sub>\\<R>)\n\ngoal (2 subgoals):\n 1. c \\<in> X1 \\<Longrightarrow>\n    frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x\n 2. c \\<notin> X1 \\<Longrightarrow>\n    frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x", "with region' \\<open>c \\<in> \\<X>\\<close>"], ["proof (chain)\npicking this:\n  [xs !! j']\\<^sub>\\<R> = Regions.region \\<X> I' r'\n  Regions.valid_region \\<X> k I' r'\n  c \\<in> \\<X>\n  unbounded c ([xs !! j']\\<^sub>\\<R>)", "have \"I' c = Greater (k c)\""], ["proof (prove)\nusing this:\n  [xs !! j']\\<^sub>\\<R> = Regions.region \\<X> I' r'\n  Regions.valid_region \\<X> k I' r'\n  c \\<in> \\<X>\n  unbounded c ([xs !! j']\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. I' c = Regions.intv.Greater (k c)", "by (auto intro: unbounded_Greater)"], ["proof (state)\nthis:\n  I' c = Regions.intv.Greater (k c)\n\ngoal (2 subgoals):\n 1. c \\<in> X1 \\<Longrightarrow>\n    frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x\n 2. c \\<notin> X1 \\<Longrightarrow>\n    frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x", "with prems"], ["proof (chain)\npicking this:\n  finite \\<X>\n  c \\<in> \\<X>\n  I' c = Regions.intv.Intv d\n  I' c = Regions.intv.Greater (k c)", "show ?thesis"], ["proof (prove)\nusing this:\n  finite \\<X>\n  c \\<in> \\<X>\n  I' c = Regions.intv.Intv d\n  I' c = Regions.intv.Greater (k c)\n\ngoal (1 subgoal):\n 1. frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x", "by auto"], ["proof (state)\nthis:\n  frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x\n\ngoal (1 subgoal):\n 1. c \\<notin> X1 \\<Longrightarrow>\n    frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<notin> X1 \\<Longrightarrow>\n    frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x", "case False"], ["proof (state)\nthis:\n  c \\<notin> X1\n\ngoal (1 subgoal):\n 1. c \\<notin> X1 \\<Longrightarrow>\n    frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x", "with \\<open>c \\<in> \\<X>\\<close>"], ["proof (chain)\npicking this:\n  c \\<in> \\<X>\n  c \\<notin> X1", "have \"c \\<in> X2\""], ["proof (prove)\nusing this:\n  c \\<in> \\<X>\n  c \\<notin> X1\n\ngoal (1 subgoal):\n 1. c \\<in> X2", "unfolding X2_def"], ["proof (prove)\nusing this:\n  c \\<in> \\<X>\n  c \\<notin> X1\n\ngoal (1 subgoal):\n 1. c \\<in> \\<X> - X1", "by auto"], ["proof (state)\nthis:\n  c \\<in> X2\n\ngoal (1 subgoal):\n 1. c \\<notin> X1 \\<Longrightarrow>\n    frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x", "with j_c_bound"], ["proof (chain)\npicking this:\n  ?c8 \\<in> X2 \\<Longrightarrow> (xs !! j) ?c8 \\<le> (xs !! (j - 1)) x\n  c \\<in> X2", "have mono: \"(xs !! j) c \\<le> (xs !! (j - 1)) x\""], ["proof (prove)\nusing this:\n  ?c8 \\<in> X2 \\<Longrightarrow> (xs !! j) ?c8 \\<le> (xs !! (j - 1)) x\n  c \\<in> X2\n\ngoal (1 subgoal):\n 1. (xs !! j) c \\<le> (xs !! (j - 1)) x", "."], ["proof (state)\nthis:\n  (xs !! j) c \\<le> (xs !! (j - 1)) x\n\ngoal (1 subgoal):\n 1. c \\<notin> X1 \\<Longrightarrow>\n    frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x", "from in_S \\<open>c \\<in> \\<X>\\<close>"], ["proof (chain)\npicking this:\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  c \\<in> \\<X>", "have \"(xs !! (j' - 1)) c \\<ge> 0\""], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  c \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. 0 \\<le> (xs !! (j' - 1)) c", "unfolding V_def stream.pred_set"], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>sset xs. u \\<in> {v. \\<forall>x\\<in>\\<X>. 0 \\<le> v x}\n  c \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. 0 \\<le> (xs !! (j' - 1)) c", "by auto"], ["proof (state)\nthis:\n  0 \\<le> (xs !! (j' - 1)) c\n\ngoal (1 subgoal):\n 1. c \\<notin> X1 \\<Longrightarrow>\n    frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x", "then"], ["proof (chain)\npicking this:\n  0 \\<le> (xs !! (j' - 1)) c", "have\n                      \"frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j' - 1)) c\""], ["proof (prove)\nusing this:\n  0 \\<le> (xs !! (j' - 1)) c\n\ngoal (1 subgoal):\n 1. frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j' - 1)) c", "using frac_le_self"], ["proof (prove)\nusing this:\n  0 \\<le> (xs !! (j' - 1)) c\n  (0::?'a) \\<le> ?x \\<Longrightarrow> frac ?x \\<le> ?x\n\ngoal (1 subgoal):\n 1. frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j' - 1)) c", "by auto"], ["proof (state)\nthis:\n  frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j' - 1)) c\n\ngoal (1 subgoal):\n 1. c \\<notin> X1 \\<Longrightarrow>\n    frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x", "with A mono"], ["proof (chain)\npicking this:\n  (xs !! (j' - 1)) c = (xs !! j) c\n  (xs !! j) c \\<le> (xs !! (j - 1)) x\n  frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j' - 1)) c", "show ?thesis"], ["proof (prove)\nusing this:\n  (xs !! (j' - 1)) c = (xs !! j) c\n  (xs !! j) c \\<le> (xs !! (j - 1)) x\n  frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j' - 1)) c\n\ngoal (1 subgoal):\n 1. frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x", "by auto"], ["proof (state)\nthis:\n  frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x\n\ngoal (1 subgoal):\n 1. (xs !! (j' - 1)) c = 0 \\<Longrightarrow>\n    frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (xs !! (j' - 1)) c = 0 \\<Longrightarrow>\n    frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x", "case prems: 2"], ["proof (state)\nthis:\n  (xs !! (j' - 1)) c = 0\n\ngoal (1 subgoal):\n 1. (xs !! (j' - 1)) c = 0 \\<Longrightarrow>\n    frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x", "(* XXX *)"], ["proof (state)\nthis:\n  (xs !! (j' - 1)) c = 0\n\ngoal (1 subgoal):\n 1. (xs !! (j' - 1)) c = 0 \\<Longrightarrow>\n    frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x", "have \"frac (0 :: real) = (0 :: real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frac 0 = 0", "by auto"], ["proof (state)\nthis:\n  frac 0 = 0\n\ngoal (1 subgoal):\n 1. (xs !! (j' - 1)) c = 0 \\<Longrightarrow>\n    frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x", "then"], ["proof (chain)\npicking this:\n  frac 0 = 0", "have \"frac (0 :: real) \\<le> (0 :: real)\""], ["proof (prove)\nusing this:\n  frac 0 = 0\n\ngoal (1 subgoal):\n 1. frac 0 \\<le> 0", "by linarith"], ["proof (state)\nthis:\n  frac 0 \\<le> 0\n\ngoal (1 subgoal):\n 1. (xs !! (j' - 1)) c = 0 \\<Longrightarrow>\n    frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x", "moreover"], ["proof (state)\nthis:\n  frac 0 \\<le> 0\n\ngoal (1 subgoal):\n 1. (xs !! (j' - 1)) c = 0 \\<Longrightarrow>\n    frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x", "from in_S \\<open>x \\<in> \\<X>\\<close>"], ["proof (chain)\npicking this:\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  x \\<in> \\<X>", "have \"(xs !! (j - 1)) x \\<ge> 0\""], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  x \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. 0 \\<le> (xs !! (j - 1)) x", "unfolding V_def stream.pred_set"], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>sset xs. u \\<in> {v. \\<forall>x\\<in>\\<X>. 0 \\<le> v x}\n  x \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. 0 \\<le> (xs !! (j - 1)) x", "by auto"], ["proof (state)\nthis:\n  0 \\<le> (xs !! (j - 1)) x\n\ngoal (1 subgoal):\n 1. (xs !! (j' - 1)) c = 0 \\<Longrightarrow>\n    frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x", "ultimately"], ["proof (chain)\npicking this:\n  frac 0 \\<le> 0\n  0 \\<le> (xs !! (j - 1)) x", "show ?thesis"], ["proof (prove)\nusing this:\n  frac 0 \\<le> 0\n  0 \\<le> (xs !! (j - 1)) x\n\ngoal (1 subgoal):\n 1. frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x", "using prems"], ["proof (prove)\nusing this:\n  frac 0 \\<le> 0\n  0 \\<le> (xs !! (j - 1)) x\n  (xs !! (j' - 1)) c = 0\n\ngoal (1 subgoal):\n 1. frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x", "by auto"], ["proof (state)\nthis:\n  frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  frac ((xs !! (j' - 1)) c) \\<le> (xs !! (j - 1)) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. finite \\<X> \\<Longrightarrow> 0 \\<le> (xs !! (j - 1)) x", "using in_S \\<open>x \\<in> \\<X>\\<close>"], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  x \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. \\<And>a. finite \\<X> \\<Longrightarrow> 0 \\<le> (xs !! (j - 1)) x", "by (auto simp: V_def stream.pred_set)"], ["proof (state)\nthis:\n  Max ({frac ((xs !! (j' - 1)) c) |c.\n        c \\<in> \\<X> \\<and> Regions.isIntv (I' c)} \\<union>\n       {0})\n  \\<le> (xs !! (j - 1)) x\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>xs !! j' = xs !! (j' - 1) \\<oplus> t;\n         (1 - (xs !! (j - 1)) x) / 2 \\<le> t; 0 \\<le> t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  Max ({frac ((xs !! (j' - 1)) c) |c.\n        c \\<in> \\<X> \\<and> Regions.isIntv (I' c)} \\<union>\n       {0})\n  \\<le> (xs !! (j - 1)) x", "have le: \"(1 - ?d2) / 2 \\<le> (1 - Max (?S' \\<union> {0})) / 2\""], ["proof (prove)\nusing this:\n  Max ({frac ((xs !! (j' - 1)) c) |c.\n        c \\<in> \\<X> \\<and> Regions.isIntv (I' c)} \\<union>\n       {0})\n  \\<le> (xs !! (j - 1)) x\n\ngoal (1 subgoal):\n 1. (1 - (xs !! (j - 1)) x) / 2\n    \\<le> (1 -\n           Max ({frac ((xs !! (j' - 1)) c) |c.\n                 c \\<in> \\<X> \\<and> Regions.isIntv (I' c)} \\<union>\n                {0})) /\n          2", "by simp"], ["proof (state)\nthis:\n  (1 - (xs !! (j - 1)) x) / 2\n  \\<le> (1 -\n         Max ({frac ((xs !! (j' - 1)) c) |c.\n               c \\<in> \\<X> \\<and> Regions.isIntv (I' c)} \\<union>\n              {0})) /\n        2\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>xs !! j' = xs !! (j' - 1) \\<oplus> t;\n         (1 - (xs !! (j - 1)) x) / 2 \\<le> t; 0 \\<le> t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?u = \"xs !! j'\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>xs !! j' = xs !! (j' - 1) \\<oplus> t;\n         (1 - (xs !! (j - 1)) x) / 2 \\<le> t; 0 \\<le> t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?u' = \"xs !! (j' - 1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>xs !! j' = xs !! (j' - 1) \\<oplus> t;\n         (1 - (xs !! (j - 1)) x) / 2 \\<le> t; 0 \\<le> t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from in_S"], ["proof (chain)\npicking this:\n  pred_stream (\\<lambda>u. u \\<in> V) xs", "have *: \"?u' \\<in> V\" \"[?u']\\<^sub>\\<R> \\<in> \\<R>\" \"?u \\<in> V\" \"[?u]\\<^sub>\\<R> \\<in> \\<R>\""], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n\ngoal (1 subgoal):\n 1. (xs !! (j' - 1) \\<in> V &&& [xs !! (j' - 1)]\\<^sub>\\<R> \\<in> \\<R>) &&&\n    xs !! j' \\<in> V &&& [xs !! j']\\<^sub>\\<R> \\<in> \\<R>", "by (auto simp: stream.pred_set)"], ["proof (state)\nthis:\n  xs !! (j' - 1) \\<in> V\n  [xs !! (j' - 1)]\\<^sub>\\<R> \\<in> \\<R>\n  xs !! j' \\<in> V\n  [xs !! j']\\<^sub>\\<R> \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>xs !! j' = xs !! (j' - 1) \\<oplus> t;\n         (1 - (xs !! (j - 1)) x) / 2 \\<le> t; 0 \\<le> t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from pairwise_Suc[OF trans, of \"j' - 1\"] \\<open>j' > j\\<close>"], ["proof (chain)\npicking this:\n  local.trans (xs !! (j' - 1)) (xs !! Suc (j' - 1))\n  j < j'", "have\n              \"trans (xs !! (j' - 1)) (xs !! j')\""], ["proof (prove)\nusing this:\n  local.trans (xs !! (j' - 1)) (xs !! Suc (j' - 1))\n  j < j'\n\ngoal (1 subgoal):\n 1. local.trans (xs !! (j' - 1)) (xs !! j')", "by auto"], ["proof (state)\nthis:\n  local.trans (xs !! (j' - 1)) (xs !! j')\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>xs !! j' = xs !! (j' - 1) \\<oplus> t;\n         (1 - (xs !! (j - 1)) x) / 2 \\<le> t; 0 \\<le> t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  local.trans (xs !! (j' - 1)) (xs !! j')", "have Succ:\n              \"[xs !! j']\\<^sub>\\<R> \\<in> Succ \\<R> ([xs !! (j' - 1)]\\<^sub>\\<R>) \\<and> (\\<exists> t\\<ge> 0. ?u = ?u' \\<oplus> t)\""], ["proof (prove)\nusing this:\n  local.trans (xs !! (j' - 1)) (xs !! j')\n\ngoal (1 subgoal):\n 1. [xs !! j']\\<^sub>\\<R>\n    \\<in> Succ \\<R> ([xs !! (j' - 1)]\\<^sub>\\<R>) \\<and>\n    (\\<exists>t\\<ge>0. xs !! j' = xs !! (j' - 1) \\<oplus> t)", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>0 \\<le> t; xs !! j' = xs !! (j' - 1) \\<oplus> t\\<rbrakk>\n       \\<Longrightarrow> [xs !! j']\\<^sub>\\<R>\n                         \\<in> Succ \\<R>\n                                ([xs !! (j' - 1)]\\<^sub>\\<R>) \\<and>\n                         (\\<exists>t\\<ge>0.\n                             xs !! j' = xs !! (j' - 1) \\<oplus> t)\n 2. \\<And>l.\n       \\<lbrakk>set l \\<subseteq> \\<X>;\n        xs !! j' = [l\\<rightarrow>0]xs !! (j' - 1)\\<rbrakk>\n       \\<Longrightarrow> [xs !! j']\\<^sub>\\<R>\n                         \\<in> Succ \\<R>\n                                ([xs !! (j' - 1)]\\<^sub>\\<R>) \\<and>\n                         (\\<exists>t\\<ge>0.\n                             xs !! j' = xs !! (j' - 1) \\<oplus> t)\n 3. xs !! (j' - 1) = xs !! j' \\<Longrightarrow>\n    [xs !! j']\\<^sub>\\<R>\n    \\<in> Succ \\<R> ([xs !! (j' - 1)]\\<^sub>\\<R>) \\<and>\n    (\\<exists>t\\<ge>0. xs !! j' = xs !! (j' - 1) \\<oplus> t)", "case prems: (succ t)"], ["proof (state)\nthis:\n  0 \\<le> t\n  xs !! j' = xs !! (j' - 1) \\<oplus> t\n\ngoal (3 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>0 \\<le> t; xs !! j' = xs !! (j' - 1) \\<oplus> t\\<rbrakk>\n       \\<Longrightarrow> [xs !! j']\\<^sub>\\<R>\n                         \\<in> Succ \\<R>\n                                ([xs !! (j' - 1)]\\<^sub>\\<R>) \\<and>\n                         (\\<exists>t\\<ge>0.\n                             xs !! j' = xs !! (j' - 1) \\<oplus> t)\n 2. \\<And>l.\n       \\<lbrakk>set l \\<subseteq> \\<X>;\n        xs !! j' = [l\\<rightarrow>0]xs !! (j' - 1)\\<rbrakk>\n       \\<Longrightarrow> [xs !! j']\\<^sub>\\<R>\n                         \\<in> Succ \\<R>\n                                ([xs !! (j' - 1)]\\<^sub>\\<R>) \\<and>\n                         (\\<exists>t\\<ge>0.\n                             xs !! j' = xs !! (j' - 1) \\<oplus> t)\n 3. xs !! (j' - 1) = xs !! j' \\<Longrightarrow>\n    [xs !! j']\\<^sub>\\<R>\n    \\<in> Succ \\<R> ([xs !! (j' - 1)]\\<^sub>\\<R>) \\<and>\n    (\\<exists>t\\<ge>0. xs !! j' = xs !! (j' - 1) \\<oplus> t)", "from *"], ["proof (chain)\npicking this:\n  xs !! (j' - 1) \\<in> V\n  [xs !! (j' - 1)]\\<^sub>\\<R> \\<in> \\<R>\n  xs !! j' \\<in> V\n  [xs !! j']\\<^sub>\\<R> \\<in> \\<R>", "have \"?u' \\<in> [?u']\\<^sub>\\<R>\""], ["proof (prove)\nusing this:\n  xs !! (j' - 1) \\<in> V\n  [xs !! (j' - 1)]\\<^sub>\\<R> \\<in> \\<R>\n  xs !! j' \\<in> V\n  [xs !! j']\\<^sub>\\<R> \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. xs !! (j' - 1) \\<in> [xs !! (j' - 1)]\\<^sub>\\<R>", "by auto"], ["proof (state)\nthis:\n  xs !! (j' - 1) \\<in> [xs !! (j' - 1)]\\<^sub>\\<R>\n\ngoal (3 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>0 \\<le> t; xs !! j' = xs !! (j' - 1) \\<oplus> t\\<rbrakk>\n       \\<Longrightarrow> [xs !! j']\\<^sub>\\<R>\n                         \\<in> Succ \\<R>\n                                ([xs !! (j' - 1)]\\<^sub>\\<R>) \\<and>\n                         (\\<exists>t\\<ge>0.\n                             xs !! j' = xs !! (j' - 1) \\<oplus> t)\n 2. \\<And>l.\n       \\<lbrakk>set l \\<subseteq> \\<X>;\n        xs !! j' = [l\\<rightarrow>0]xs !! (j' - 1)\\<rbrakk>\n       \\<Longrightarrow> [xs !! j']\\<^sub>\\<R>\n                         \\<in> Succ \\<R>\n                                ([xs !! (j' - 1)]\\<^sub>\\<R>) \\<and>\n                         (\\<exists>t\\<ge>0.\n                             xs !! j' = xs !! (j' - 1) \\<oplus> t)\n 3. xs !! (j' - 1) = xs !! j' \\<Longrightarrow>\n    [xs !! j']\\<^sub>\\<R>\n    \\<in> Succ \\<R> ([xs !! (j' - 1)]\\<^sub>\\<R>) \\<and>\n    (\\<exists>t\\<ge>0. xs !! j' = xs !! (j' - 1) \\<oplus> t)", "with prems *"], ["proof (chain)\npicking this:\n  0 \\<le> t\n  xs !! j' = xs !! (j' - 1) \\<oplus> t\n  xs !! (j' - 1) \\<in> V\n  [xs !! (j' - 1)]\\<^sub>\\<R> \\<in> \\<R>\n  xs !! j' \\<in> V\n  [xs !! j']\\<^sub>\\<R> \\<in> \\<R>\n  xs !! (j' - 1) \\<in> [xs !! (j' - 1)]\\<^sub>\\<R>", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> t\n  xs !! j' = xs !! (j' - 1) \\<oplus> t\n  xs !! (j' - 1) \\<in> V\n  [xs !! (j' - 1)]\\<^sub>\\<R> \\<in> \\<R>\n  xs !! j' \\<in> V\n  [xs !! j']\\<^sub>\\<R> \\<in> \\<R>\n  xs !! (j' - 1) \\<in> [xs !! (j' - 1)]\\<^sub>\\<R>\n\ngoal (1 subgoal):\n 1. [xs !! j']\\<^sub>\\<R>\n    \\<in> Succ \\<R> ([xs !! (j' - 1)]\\<^sub>\\<R>) \\<and>\n    (\\<exists>t\\<ge>0. xs !! j' = xs !! (j' - 1) \\<oplus> t)", "by auto"], ["proof (state)\nthis:\n  [xs !! j']\\<^sub>\\<R> \\<in> Succ \\<R> ([xs !! (j' - 1)]\\<^sub>\\<R>) \\<and>\n  (\\<exists>t\\<ge>0. xs !! j' = xs !! (j' - 1) \\<oplus> t)\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>set l \\<subseteq> \\<X>;\n        xs !! j' = [l\\<rightarrow>0]xs !! (j' - 1)\\<rbrakk>\n       \\<Longrightarrow> [xs !! j']\\<^sub>\\<R>\n                         \\<in> Succ \\<R>\n                                ([xs !! (j' - 1)]\\<^sub>\\<R>) \\<and>\n                         (\\<exists>t\\<ge>0.\n                             xs !! j' = xs !! (j' - 1) \\<oplus> t)\n 2. xs !! (j' - 1) = xs !! j' \\<Longrightarrow>\n    [xs !! j']\\<^sub>\\<R>\n    \\<in> Succ \\<R> ([xs !! (j' - 1)]\\<^sub>\\<R>) \\<and>\n    (\\<exists>t\\<ge>0. xs !! j' = xs !! (j' - 1) \\<oplus> t)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>set l \\<subseteq> \\<X>;\n        xs !! j' = [l\\<rightarrow>0]xs !! (j' - 1)\\<rbrakk>\n       \\<Longrightarrow> [xs !! j']\\<^sub>\\<R>\n                         \\<in> Succ \\<R>\n                                ([xs !! (j' - 1)]\\<^sub>\\<R>) \\<and>\n                         (\\<exists>t\\<ge>0.\n                             xs !! j' = xs !! (j' - 1) \\<oplus> t)\n 2. xs !! (j' - 1) = xs !! j' \\<Longrightarrow>\n    [xs !! j']\\<^sub>\\<R>\n    \\<in> Succ \\<R> ([xs !! (j' - 1)]\\<^sub>\\<R>) \\<and>\n    (\\<exists>t\\<ge>0. xs !! j' = xs !! (j' - 1) \\<oplus> t)", "case (reset l)"], ["proof (state)\nthis:\n  set l \\<subseteq> \\<X>\n  xs !! j' = [l\\<rightarrow>0]xs !! (j' - 1)\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>set l \\<subseteq> \\<X>;\n        xs !! j' = [l\\<rightarrow>0]xs !! (j' - 1)\\<rbrakk>\n       \\<Longrightarrow> [xs !! j']\\<^sub>\\<R>\n                         \\<in> Succ \\<R>\n                                ([xs !! (j' - 1)]\\<^sub>\\<R>) \\<and>\n                         (\\<exists>t\\<ge>0.\n                             xs !! j' = xs !! (j' - 1) \\<oplus> t)\n 2. xs !! (j' - 1) = xs !! j' \\<Longrightarrow>\n    [xs !! j']\\<^sub>\\<R>\n    \\<in> Succ \\<R> ([xs !! (j' - 1)]\\<^sub>\\<R>) \\<and>\n    (\\<exists>t\\<ge>0. xs !! j' = xs !! (j' - 1) \\<oplus> t)", "with \\<open>?u' \\<in> V\\<close>"], ["proof (chain)\npicking this:\n  xs !! (j' - 1) \\<in> V\n  set l \\<subseteq> \\<X>\n  xs !! j' = [l\\<rightarrow>0]xs !! (j' - 1)", "have \"?u x \\<le> ?u' x\""], ["proof (prove)\nusing this:\n  xs !! (j' - 1) \\<in> V\n  set l \\<subseteq> \\<X>\n  xs !! j' = [l\\<rightarrow>0]xs !! (j' - 1)\n\ngoal (1 subgoal):\n 1. (xs !! j') x \\<le> (xs !! (j' - 1)) x", "by (cases \"x \\<in> set l\") (auto simp: V_def)"], ["proof (state)\nthis:\n  (xs !! j') x \\<le> (xs !! (j' - 1)) x\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>set l \\<subseteq> \\<X>;\n        xs !! j' = [l\\<rightarrow>0]xs !! (j' - 1)\\<rbrakk>\n       \\<Longrightarrow> [xs !! j']\\<^sub>\\<R>\n                         \\<in> Succ \\<R>\n                                ([xs !! (j' - 1)]\\<^sub>\\<R>) \\<and>\n                         (\\<exists>t\\<ge>0.\n                             xs !! j' = xs !! (j' - 1) \\<oplus> t)\n 2. xs !! (j' - 1) = xs !! j' \\<Longrightarrow>\n    [xs !! j']\\<^sub>\\<R>\n    \\<in> Succ \\<R> ([xs !! (j' - 1)]\\<^sub>\\<R>) \\<and>\n    (\\<exists>t\\<ge>0. xs !! j' = xs !! (j' - 1) \\<oplus> t)", "from j'"], ["proof (chain)\npicking this:\n  j < j'\n  \\<not> zero x ([xs !! j']\\<^sub>\\<R>)\n  \\<forall>m\\<ge>j. m < j' \\<longrightarrow> zero x ([xs !! m]\\<^sub>\\<R>)", "have \"zero x ([?u']\\<^sub>\\<R>)\""], ["proof (prove)\nusing this:\n  j < j'\n  \\<not> zero x ([xs !! j']\\<^sub>\\<R>)\n  \\<forall>m\\<ge>j. m < j' \\<longrightarrow> zero x ([xs !! m]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. zero x ([xs !! (j' - 1)]\\<^sub>\\<R>)", "by auto"], ["proof (state)\nthis:\n  zero x ([xs !! (j' - 1)]\\<^sub>\\<R>)\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>set l \\<subseteq> \\<X>;\n        xs !! j' = [l\\<rightarrow>0]xs !! (j' - 1)\\<rbrakk>\n       \\<Longrightarrow> [xs !! j']\\<^sub>\\<R>\n                         \\<in> Succ \\<R>\n                                ([xs !! (j' - 1)]\\<^sub>\\<R>) \\<and>\n                         (\\<exists>t\\<ge>0.\n                             xs !! j' = xs !! (j' - 1) \\<oplus> t)\n 2. xs !! (j' - 1) = xs !! j' \\<Longrightarrow>\n    [xs !! j']\\<^sub>\\<R>\n    \\<in> Succ \\<R> ([xs !! (j' - 1)]\\<^sub>\\<R>) \\<and>\n    (\\<exists>t\\<ge>0. xs !! j' = xs !! (j' - 1) \\<oplus> t)", "with \\<open>?u' \\<in> V\\<close>"], ["proof (chain)\npicking this:\n  xs !! (j' - 1) \\<in> V\n  zero x ([xs !! (j' - 1)]\\<^sub>\\<R>)", "have \"?u' x = 0\""], ["proof (prove)\nusing this:\n  xs !! (j' - 1) \\<in> V\n  zero x ([xs !! (j' - 1)]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. (xs !! (j' - 1)) x = 0", "unfolding zero_def"], ["proof (prove)\nusing this:\n  xs !! (j' - 1) \\<in> V\n  \\<forall>u\\<in>[xs !! (j' - 1)]\\<^sub>\\<R>. u x = 0\n\ngoal (1 subgoal):\n 1. (xs !! (j' - 1)) x = 0", "by auto"], ["proof (state)\nthis:\n  (xs !! (j' - 1)) x = 0\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>set l \\<subseteq> \\<X>;\n        xs !! j' = [l\\<rightarrow>0]xs !! (j' - 1)\\<rbrakk>\n       \\<Longrightarrow> [xs !! j']\\<^sub>\\<R>\n                         \\<in> Succ \\<R>\n                                ([xs !! (j' - 1)]\\<^sub>\\<R>) \\<and>\n                         (\\<exists>t\\<ge>0.\n                             xs !! j' = xs !! (j' - 1) \\<oplus> t)\n 2. xs !! (j' - 1) = xs !! j' \\<Longrightarrow>\n    [xs !! j']\\<^sub>\\<R>\n    \\<in> Succ \\<R> ([xs !! (j' - 1)]\\<^sub>\\<R>) \\<and>\n    (\\<exists>t\\<ge>0. xs !! j' = xs !! (j' - 1) \\<oplus> t)", "with \\<open>?u x \\<le> _\\<close> \\<open>?u x > 0\\<close>"], ["proof (chain)\npicking this:\n  (xs !! j') x \\<le> (xs !! (j' - 1)) x\n  0 < (xs !! j') x\n  (xs !! (j' - 1)) x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  (xs !! j') x \\<le> (xs !! (j' - 1)) x\n  0 < (xs !! j') x\n  (xs !! (j' - 1)) x = 0\n\ngoal (1 subgoal):\n 1. [xs !! j']\\<^sub>\\<R>\n    \\<in> Succ \\<R> ([xs !! (j' - 1)]\\<^sub>\\<R>) \\<and>\n    (\\<exists>t\\<ge>0. xs !! j' = xs !! (j' - 1) \\<oplus> t)", "by auto"], ["proof (state)\nthis:\n  [xs !! j']\\<^sub>\\<R> \\<in> Succ \\<R> ([xs !! (j' - 1)]\\<^sub>\\<R>) \\<and>\n  (\\<exists>t\\<ge>0. xs !! j' = xs !! (j' - 1) \\<oplus> t)\n\ngoal (1 subgoal):\n 1. xs !! (j' - 1) = xs !! j' \\<Longrightarrow>\n    [xs !! j']\\<^sub>\\<R>\n    \\<in> Succ \\<R> ([xs !! (j' - 1)]\\<^sub>\\<R>) \\<and>\n    (\\<exists>t\\<ge>0. xs !! j' = xs !! (j' - 1) \\<oplus> t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs !! (j' - 1) = xs !! j' \\<Longrightarrow>\n    [xs !! j']\\<^sub>\\<R>\n    \\<in> Succ \\<R> ([xs !! (j' - 1)]\\<^sub>\\<R>) \\<and>\n    (\\<exists>t\\<ge>0. xs !! j' = xs !! (j' - 1) \\<oplus> t)", "case id"], ["proof (state)\nthis:\n  xs !! (j' - 1) = xs !! j'\n\ngoal (1 subgoal):\n 1. xs !! (j' - 1) = xs !! j' \\<Longrightarrow>\n    [xs !! j']\\<^sub>\\<R>\n    \\<in> Succ \\<R> ([xs !! (j' - 1)]\\<^sub>\\<R>) \\<and>\n    (\\<exists>t\\<ge>0. xs !! j' = xs !! (j' - 1) \\<oplus> t)", "with * Succ_refl[of \\<R> \\<X> k, folded \\<R>_def, OF _ finite(1)]"], ["proof (chain)\npicking this:\n  xs !! (j' - 1) \\<in> V\n  [xs !! (j' - 1)]\\<^sub>\\<R> \\<in> \\<R>\n  xs !! j' \\<in> V\n  [xs !! j']\\<^sub>\\<R> \\<in> \\<R>\n  \\<lbrakk>\\<R> = \\<R>; ?R \\<in> \\<R>\\<rbrakk>\n  \\<Longrightarrow> ?R \\<in> Succ \\<R> ?R\n  xs !! (j' - 1) = xs !! j'", "show ?thesis"], ["proof (prove)\nusing this:\n  xs !! (j' - 1) \\<in> V\n  [xs !! (j' - 1)]\\<^sub>\\<R> \\<in> \\<R>\n  xs !! j' \\<in> V\n  [xs !! j']\\<^sub>\\<R> \\<in> \\<R>\n  \\<lbrakk>\\<R> = \\<R>; ?R \\<in> \\<R>\\<rbrakk>\n  \\<Longrightarrow> ?R \\<in> Succ \\<R> ?R\n  xs !! (j' - 1) = xs !! j'\n\ngoal (1 subgoal):\n 1. [xs !! j']\\<^sub>\\<R>\n    \\<in> Succ \\<R> ([xs !! (j' - 1)]\\<^sub>\\<R>) \\<and>\n    (\\<exists>t\\<ge>0. xs !! j' = xs !! (j' - 1) \\<oplus> t)", "unfolding cval_add_def"], ["proof (prove)\nusing this:\n  xs !! (j' - 1) \\<in> V\n  [xs !! (j' - 1)]\\<^sub>\\<R> \\<in> \\<R>\n  xs !! j' \\<in> V\n  [xs !! j']\\<^sub>\\<R> \\<in> \\<R>\n  \\<lbrakk>\\<R> = \\<R>; ?R \\<in> \\<R>\\<rbrakk>\n  \\<Longrightarrow> ?R \\<in> Succ \\<R> ?R\n  xs !! (j' - 1) = xs !! j'\n\ngoal (1 subgoal):\n 1. [xs !! j']\\<^sub>\\<R>\n    \\<in> Succ \\<R> ([xs !! (j' - 1)]\\<^sub>\\<R>) \\<and>\n    (\\<exists>t\\<ge>0. xs !! j' = (\\<lambda>x. (xs !! (j' - 1)) x + t))", "by auto"], ["proof (state)\nthis:\n  [xs !! j']\\<^sub>\\<R> \\<in> Succ \\<R> ([xs !! (j' - 1)]\\<^sub>\\<R>) \\<and>\n  (\\<exists>t\\<ge>0. xs !! j' = xs !! (j' - 1) \\<oplus> t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [xs !! j']\\<^sub>\\<R> \\<in> Succ \\<R> ([xs !! (j' - 1)]\\<^sub>\\<R>) \\<and>\n  (\\<exists>t\\<ge>0. xs !! j' = xs !! (j' - 1) \\<oplus> t)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>xs !! j' = xs !! (j' - 1) \\<oplus> t;\n         (1 - (xs !! (j - 1)) x) / 2 \\<le> t; 0 \\<le> t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  [xs !! j']\\<^sub>\\<R> \\<in> Succ \\<R> ([xs !! (j' - 1)]\\<^sub>\\<R>) \\<and>\n  (\\<exists>t\\<ge>0. xs !! j' = xs !! (j' - 1) \\<oplus> t)", "obtain t where t: \"?u = xs !! (j' - 1) \\<oplus> t\" \"t \\<ge> 0\""], ["proof (prove)\nusing this:\n  [xs !! j']\\<^sub>\\<R> \\<in> Succ \\<R> ([xs !! (j' - 1)]\\<^sub>\\<R>) \\<and>\n  (\\<exists>t\\<ge>0. xs !! j' = xs !! (j' - 1) \\<oplus> t)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>xs !! j' = xs !! (j' - 1) \\<oplus> t; 0 \\<le> t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  xs !! j' = xs !! (j' - 1) \\<oplus> t\n  0 \\<le> t\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>xs !! j' = xs !! (j' - 1) \\<oplus> t;\n         (1 - (xs !! (j - 1)) x) / 2 \\<le> t; 0 \\<le> t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note Succ = Succ[THEN conjunct1]"], ["proof (state)\nthis:\n  [xs !! j']\\<^sub>\\<R> \\<in> Succ \\<R> ([xs !! (j' - 1)]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>xs !! j' = xs !! (j' - 1) \\<oplus> t;\n         (1 - (xs !! (j - 1)) x) / 2 \\<le> t; 0 \\<le> t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (cases \"\\<exists> c \\<in> X2. \\<exists> d :: nat. ?u c = d\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>c\\<in>X2. \\<exists>x. (xs !! j') c = real x \\<Longrightarrow>\n    thesis\n 2. \\<not> (\\<exists>c\\<in>X2.\n               \\<exists>x. (xs !! j') c = real x) \\<Longrightarrow>\n    thesis", "case True"], ["proof (state)\nthis:\n  \\<exists>c\\<in>X2. \\<exists>x. (xs !! j') c = real x\n\ngoal (2 subgoals):\n 1. \\<exists>c\\<in>X2. \\<exists>x. (xs !! j') c = real x \\<Longrightarrow>\n    thesis\n 2. \\<not> (\\<exists>c\\<in>X2.\n               \\<exists>x. (xs !! j') c = real x) \\<Longrightarrow>\n    thesis", "from True"], ["proof (chain)\npicking this:\n  \\<exists>c\\<in>X2. \\<exists>x. (xs !! j') c = real x", "obtain c and d :: nat where c:\n                \"c \\<in> \\<X>\" \"c \\<in> X2\" \"?u c = d\""], ["proof (prove)\nusing this:\n  \\<exists>c\\<in>X2. \\<exists>x. (xs !! j') c = real x\n\ngoal (1 subgoal):\n 1. (\\<And>c d.\n        \\<lbrakk>c \\<in> \\<X>; c \\<in> X2; (xs !! j') c = real d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: X2_def)"], ["proof (state)\nthis:\n  c \\<in> \\<X>\n  c \\<in> X2\n  (xs !! j') c = real d\n\ngoal (2 subgoals):\n 1. \\<exists>c\\<in>X2. \\<exists>x. (xs !! j') c = real x \\<Longrightarrow>\n    thesis\n 2. \\<not> (\\<exists>c\\<in>X2.\n               \\<exists>x. (xs !! j') c = real x) \\<Longrightarrow>\n    thesis", "have \"?u x > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < (xs !! j') x", "by fact"], ["proof (state)\nthis:\n  0 < (xs !! j') x\n\ngoal (2 subgoals):\n 1. \\<exists>c\\<in>X2. \\<exists>x. (xs !! j') c = real x \\<Longrightarrow>\n    thesis\n 2. \\<not> (\\<exists>c\\<in>X2.\n               \\<exists>x. (xs !! j') c = real x) \\<Longrightarrow>\n    thesis", "from pairwise_Suc[OF eq_elapsed, of \"j' - 1\"] \\<open>j' > j\\<close>"], ["proof (chain)\npicking this:\n  eq_elapsed (xs !! (j' - 1)) (xs !! Suc (j' - 1))\n  j < j'", "have\n                \"eq_elapsed (xs !! (j' - 1)) ?u\""], ["proof (prove)\nusing this:\n  eq_elapsed (xs !! (j' - 1)) (xs !! Suc (j' - 1))\n  j < j'\n\ngoal (1 subgoal):\n 1. eq_elapsed (xs !! (j' - 1)) (xs !! j')", "by auto"], ["proof (state)\nthis:\n  eq_elapsed (xs !! (j' - 1)) (xs !! j')\n\ngoal (2 subgoals):\n 1. \\<exists>c\\<in>X2. \\<exists>x. (xs !! j') c = real x \\<Longrightarrow>\n    thesis\n 2. \\<not> (\\<exists>c\\<in>X2.\n               \\<exists>x. (xs !! j') c = real x) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  eq_elapsed (xs !! (j' - 1)) (xs !! j')\n\ngoal (2 subgoals):\n 1. \\<exists>c\\<in>X2. \\<exists>x. (xs !! j') c = real x \\<Longrightarrow>\n    thesis\n 2. \\<not> (\\<exists>c\\<in>X2.\n               \\<exists>x. (xs !! j') c = real x) \\<Longrightarrow>\n    thesis", "from\n                elapsed_eq[OF this \\<open>x \\<in> \\<X>\\<close>] \\<open>(xs !! (j' - 1)) x = 0\\<close> \\<open>(xs !! j') x > 0\\<close>"], ["proof (chain)\npicking this:\n  0 \\<le> (xs !! j') x - (xs !! (j' - 1)) x \\<Longrightarrow>\n  elapsed (xs !! (j' - 1)) (xs !! j') = (xs !! j') x - (xs !! (j' - 1)) x\n  (xs !! (j' - 1)) x = 0\n  0 < (xs !! j') x", "have \"elapsed (xs !! (j' - 1)) (xs !! j') > 0\""], ["proof (prove)\nusing this:\n  0 \\<le> (xs !! j') x - (xs !! (j' - 1)) x \\<Longrightarrow>\n  elapsed (xs !! (j' - 1)) (xs !! j') = (xs !! j') x - (xs !! (j' - 1)) x\n  (xs !! (j' - 1)) x = 0\n  0 < (xs !! j') x\n\ngoal (1 subgoal):\n 1. 0 < elapsed (xs !! (j' - 1)) (xs !! j')", "by auto"], ["proof (state)\nthis:\n  0 < elapsed (xs !! (j' - 1)) (xs !! j')\n\ngoal (2 subgoals):\n 1. \\<exists>c\\<in>X2. \\<exists>x. (xs !! j') c = real x \\<Longrightarrow>\n    thesis\n 2. \\<not> (\\<exists>c\\<in>X2.\n               \\<exists>x. (xs !! j') c = real x) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  eq_elapsed (xs !! (j' - 1)) (xs !! j')\n  0 < elapsed (xs !! (j' - 1)) (xs !! j')", "have\n                \"?u c - (xs !! (j' - 1)) c > 0\""], ["proof (prove)\nusing this:\n  eq_elapsed (xs !! (j' - 1)) (xs !! j')\n  0 < elapsed (xs !! (j' - 1)) (xs !! j')\n\ngoal (1 subgoal):\n 1. 0 < (xs !! j') c - (xs !! (j' - 1)) c", "using \\<open>c \\<in> \\<X>\\<close>"], ["proof (prove)\nusing this:\n  eq_elapsed (xs !! (j' - 1)) (xs !! j')\n  0 < elapsed (xs !! (j' - 1)) (xs !! j')\n  c \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. 0 < (xs !! j') c - (xs !! (j' - 1)) c", "unfolding eq_elapsed_def"], ["proof (prove)\nusing this:\n  0 < elapsed (xs !! (j' - 1)) (xs !! j') \\<longrightarrow>\n  (\\<forall>c\\<in>\\<X>.\n      (xs !! j') c - (xs !! (j' - 1)) c =\n      elapsed (xs !! (j' - 1)) (xs !! j'))\n  0 < elapsed (xs !! (j' - 1)) (xs !! j')\n  c \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. 0 < (xs !! j') c - (xs !! (j' - 1)) c", "by auto"], ["proof (state)\nthis:\n  0 < (xs !! j') c - (xs !! (j' - 1)) c\n\ngoal (2 subgoals):\n 1. \\<exists>c\\<in>X2. \\<exists>x. (xs !! j') c = real x \\<Longrightarrow>\n    thesis\n 2. \\<not> (\\<exists>c\\<in>X2.\n               \\<exists>x. (xs !! j') c = real x) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  0 < (xs !! j') c - (xs !! (j' - 1)) c\n\ngoal (2 subgoals):\n 1. \\<exists>c\\<in>X2. \\<exists>x. (xs !! j') c = real x \\<Longrightarrow>\n    thesis\n 2. \\<not> (\\<exists>c\\<in>X2.\n               \\<exists>x. (xs !! j') c = real x) \\<Longrightarrow>\n    thesis", "from in_S"], ["proof (chain)\npicking this:\n  pred_stream (\\<lambda>u. u \\<in> V) xs", "have \"xs !! (j' - 1) \\<in> V\""], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n\ngoal (1 subgoal):\n 1. xs !! (j' - 1) \\<in> V", "by (auto simp: stream.pred_set)"], ["proof (state)\nthis:\n  xs !! (j' - 1) \\<in> V\n\ngoal (2 subgoals):\n 1. \\<exists>c\\<in>X2. \\<exists>x. (xs !! j') c = real x \\<Longrightarrow>\n    thesis\n 2. \\<not> (\\<exists>c\\<in>X2.\n               \\<exists>x. (xs !! j') c = real x) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  0 < (xs !! j') c - (xs !! (j' - 1)) c\n  xs !! (j' - 1) \\<in> V", "have \"?u c > 0\""], ["proof (prove)\nusing this:\n  0 < (xs !! j') c - (xs !! (j' - 1)) c\n  xs !! (j' - 1) \\<in> V\n\ngoal (1 subgoal):\n 1. 0 < (xs !! j') c", "using \\<open>c \\<in> \\<X>\\<close>"], ["proof (prove)\nusing this:\n  0 < (xs !! j') c - (xs !! (j' - 1)) c\n  xs !! (j' - 1) \\<in> V\n  c \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. 0 < (xs !! j') c", "unfolding V_def"], ["proof (prove)\nusing this:\n  0 < (xs !! j') c - (xs !! (j' - 1)) c\n  xs !! (j' - 1) \\<in> {v. \\<forall>x\\<in>\\<X>. 0 \\<le> v x}\n  c \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. 0 < (xs !! j') c", "by auto"], ["proof (state)\nthis:\n  0 < (xs !! j') c\n\ngoal (2 subgoals):\n 1. \\<exists>c\\<in>X2. \\<exists>x. (xs !! j') c = real x \\<Longrightarrow>\n    thesis\n 2. \\<not> (\\<exists>c\\<in>X2.\n               \\<exists>x. (xs !! j') c = real x) \\<Longrightarrow>\n    thesis", "from region' in_S \\<open>c \\<in> \\<X>\\<close>"], ["proof (chain)\npicking this:\n  [xs !! j']\\<^sub>\\<R> = Regions.region \\<X> I' r'\n  Regions.valid_region \\<X> k I' r'\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  c \\<in> \\<X>", "have \"intv_elem c ?u (I' c)\""], ["proof (prove)\nusing this:\n  [xs !! j']\\<^sub>\\<R> = Regions.region \\<X> I' r'\n  Regions.valid_region \\<X> k I' r'\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  c \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. Regions.intv_elem c (xs !! j') (I' c)", "by (force simp: stream.pred_set)"], ["proof (state)\nthis:\n  Regions.intv_elem c (xs !! j') (I' c)\n\ngoal (2 subgoals):\n 1. \\<exists>c\\<in>X2. \\<exists>x. (xs !! j') c = real x \\<Longrightarrow>\n    thesis\n 2. \\<not> (\\<exists>c\\<in>X2.\n               \\<exists>x. (xs !! j') c = real x) \\<Longrightarrow>\n    thesis", "with \\<open>?u c = d\\<close> \\<open>?u c > 0\\<close>"], ["proof (chain)\npicking this:\n  (xs !! j') c = real d\n  0 < (xs !! j') c\n  Regions.intv_elem c (xs !! j') (I' c)", "have \"?u c \\<ge> 1\""], ["proof (prove)\nusing this:\n  (xs !! j') c = real d\n  0 < (xs !! j') c\n  Regions.intv_elem c (xs !! j') (I' c)\n\ngoal (1 subgoal):\n 1. 1 \\<le> (xs !! j') c", "by auto"], ["proof (state)\nthis:\n  1 \\<le> (xs !! j') c\n\ngoal (2 subgoals):\n 1. \\<exists>c\\<in>X2. \\<exists>x. (xs !! j') c = real x \\<Longrightarrow>\n    thesis\n 2. \\<not> (\\<exists>c\\<in>X2.\n               \\<exists>x. (xs !! j') c = real x) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  1 \\<le> (xs !! j') c\n\ngoal (2 subgoals):\n 1. \\<exists>c\\<in>X2. \\<exists>x. (xs !! j') c = real x \\<Longrightarrow>\n    thesis\n 2. \\<not> (\\<exists>c\\<in>X2.\n               \\<exists>x. (xs !! j') c = real x) \\<Longrightarrow>\n    thesis", "have \"(xs !! (j' - 1)) c \\<le> 0.5\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs !! (j' - 1)) c \\<le> 5 / 10", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (xs !! (j' - 1)) c \\<le> 5 / 10", "have \"(xs !! (j' - 1)) c \\<le> (xs !! j) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs !! (j' - 1)) c \\<le> (xs !! j) c", "(* XXX This proof is duplicated at least once above *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs !! (j' - 1)) c \\<le> (xs !! j) c", "using j'(1,3)"], ["proof (prove)\nusing this:\n  j < j'\n  \\<forall>m\\<ge>j. m < j' \\<longrightarrow> zero x ([xs !! m]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. (xs !! (j' - 1)) c \\<le> (xs !! j) c", "by (auto intro: resets_mono[OF eq_elapsed in_S trans _ \\<open>x \\<in> \\<X>\\<close> \\<open>c \\<in> \\<X>\\<close>])"], ["proof (state)\nthis:\n  (xs !! (j' - 1)) c \\<le> (xs !! j) c\n\ngoal (1 subgoal):\n 1. (xs !! (j' - 1)) c \\<le> 5 / 10", "also"], ["proof (state)\nthis:\n  (xs !! (j' - 1)) c \\<le> (xs !! j) c\n\ngoal (1 subgoal):\n 1. (xs !! (j' - 1)) c \\<le> 5 / 10", "have \"\\<dots> \\<le> ?d2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs !! j) c \\<le> (xs !! (j - 1)) x", "using j_c_bound[OF \\<open>c \\<in> X2\\<close>]"], ["proof (prove)\nusing this:\n  (xs !! j) c \\<le> (xs !! (j - 1)) x\n\ngoal (1 subgoal):\n 1. (xs !! j) c \\<le> (xs !! (j - 1)) x", "."], ["proof (state)\nthis:\n  (xs !! j) c \\<le> (xs !! (j - 1)) x\n\ngoal (1 subgoal):\n 1. (xs !! (j' - 1)) c \\<le> 5 / 10", "also"], ["proof (state)\nthis:\n  (xs !! j) c \\<le> (xs !! (j - 1)) x\n\ngoal (1 subgoal):\n 1. (xs !! (j' - 1)) c \\<le> 5 / 10", "from \\<open>?d1 = ?d2\\<close> \\<open>\\<not> 5 / 10 \\<le> _\\<close>"], ["proof (chain)\npicking this:\n  dur xs (j - 1) - dur xs i = (xs !! (j - 1)) x\n  \\<not> 5 / 10 \\<le> dur xs (j - 1) - dur xs i", "have \"\\<dots> \\<le> 0.5\""], ["proof (prove)\nusing this:\n  dur xs (j - 1) - dur xs i = (xs !! (j - 1)) x\n  \\<not> 5 / 10 \\<le> dur xs (j - 1) - dur xs i\n\ngoal (1 subgoal):\n 1. (xs !! (j - 1)) x \\<le> 5 / 10", "by simp"], ["proof (state)\nthis:\n  (xs !! (j - 1)) x \\<le> 5 / 10\n\ngoal (1 subgoal):\n 1. (xs !! (j' - 1)) c \\<le> 5 / 10", "finally"], ["proof (chain)\npicking this:\n  (xs !! (j' - 1)) c \\<le> 5 / 10", "show ?thesis"], ["proof (prove)\nusing this:\n  (xs !! (j' - 1)) c \\<le> 5 / 10\n\ngoal (1 subgoal):\n 1. (xs !! (j' - 1)) c \\<le> 5 / 10", "."], ["proof (state)\nthis:\n  (xs !! (j' - 1)) c \\<le> 5 / 10\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (xs !! (j' - 1)) c \\<le> 5 / 10\n\ngoal (2 subgoals):\n 1. \\<exists>c\\<in>X2. \\<exists>x. (xs !! j') c = real x \\<Longrightarrow>\n    thesis\n 2. \\<not> (\\<exists>c\\<in>X2.\n               \\<exists>x. (xs !! j') c = real x) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  (xs !! (j' - 1)) c \\<le> 5 / 10\n\ngoal (2 subgoals):\n 1. \\<exists>c\\<in>X2. \\<exists>x. (xs !! j') c = real x \\<Longrightarrow>\n    thesis\n 2. \\<not> (\\<exists>c\\<in>X2.\n               \\<exists>x. (xs !! j') c = real x) \\<Longrightarrow>\n    thesis", "have \"?d2 \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (xs !! (j - 1)) x", "using in_S \\<open>x \\<in> \\<X>\\<close>"], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  x \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. 0 \\<le> (xs !! (j - 1)) x", "by (auto simp: V_def stream.pred_set)"], ["proof (state)\nthis:\n  0 \\<le> (xs !! (j - 1)) x\n\ngoal (2 subgoals):\n 1. \\<exists>c\\<in>X2. \\<exists>x. (xs !! j') c = real x \\<Longrightarrow>\n    thesis\n 2. \\<not> (\\<exists>c\\<in>X2.\n               \\<exists>x. (xs !! j') c = real x) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  1 \\<le> (xs !! j') c\n  (xs !! (j' - 1)) c \\<le> 5 / 10\n  0 \\<le> (xs !! (j - 1)) x", "have \"?u c - (xs !! (j' - 1)) c \\<ge> (1 - ?d2) / 2\""], ["proof (prove)\nusing this:\n  1 \\<le> (xs !! j') c\n  (xs !! (j' - 1)) c \\<le> 5 / 10\n  0 \\<le> (xs !! (j - 1)) x\n\ngoal (1 subgoal):\n 1. (1 - (xs !! (j - 1)) x) / 2 \\<le> (xs !! j') c - (xs !! (j' - 1)) c", "by auto"], ["proof (state)\nthis:\n  (1 - (xs !! (j - 1)) x) / 2 \\<le> (xs !! j') c - (xs !! (j' - 1)) c\n\ngoal (2 subgoals):\n 1. \\<exists>c\\<in>X2. \\<exists>x. (xs !! j') c = real x \\<Longrightarrow>\n    thesis\n 2. \\<not> (\\<exists>c\\<in>X2.\n               \\<exists>x. (xs !! j') c = real x) \\<Longrightarrow>\n    thesis", "with t"], ["proof (chain)\npicking this:\n  xs !! j' = xs !! (j' - 1) \\<oplus> t\n  0 \\<le> t\n  (1 - (xs !! (j - 1)) x) / 2 \\<le> (xs !! j') c - (xs !! (j' - 1)) c", "have \"t \\<ge> (1 - ?d2) / 2\""], ["proof (prove)\nusing this:\n  xs !! j' = xs !! (j' - 1) \\<oplus> t\n  0 \\<le> t\n  (1 - (xs !! (j - 1)) x) / 2 \\<le> (xs !! j') c - (xs !! (j' - 1)) c\n\ngoal (1 subgoal):\n 1. (1 - (xs !! (j - 1)) x) / 2 \\<le> t", "unfolding cval_add_def"], ["proof (prove)\nusing this:\n  xs !! j' = (\\<lambda>x. (xs !! (j' - 1)) x + t)\n  0 \\<le> t\n  (1 - (xs !! (j - 1)) x) / 2 \\<le> (xs !! j') c - (xs !! (j' - 1)) c\n\ngoal (1 subgoal):\n 1. (1 - (xs !! (j - 1)) x) / 2 \\<le> t", "by auto"], ["proof (state)\nthis:\n  (1 - (xs !! (j - 1)) x) / 2 \\<le> t\n\ngoal (2 subgoals):\n 1. \\<exists>c\\<in>X2. \\<exists>x. (xs !! j') c = real x \\<Longrightarrow>\n    thesis\n 2. \\<not> (\\<exists>c\\<in>X2.\n               \\<exists>x. (xs !! j') c = real x) \\<Longrightarrow>\n    thesis", "with t"], ["proof (chain)\npicking this:\n  xs !! j' = xs !! (j' - 1) \\<oplus> t\n  0 \\<le> t\n  (1 - (xs !! (j - 1)) x) / 2 \\<le> t", "show ?thesis"], ["proof (prove)\nusing this:\n  xs !! j' = xs !! (j' - 1) \\<oplus> t\n  0 \\<le> t\n  (1 - (xs !! (j - 1)) x) / 2 \\<le> t\n\ngoal (1 subgoal):\n 1. thesis", "by (auto intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>c\\<in>X2.\n               \\<exists>x. (xs !! j') c = real x) \\<Longrightarrow>\n    thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>c\\<in>X2.\n               \\<exists>x. (xs !! j') c = real x) \\<Longrightarrow>\n    thesis", "case F: False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>c\\<in>X2. \\<exists>x. (xs !! j') c = real x)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>c\\<in>X2.\n               \\<exists>x. (xs !! j') c = real x) \\<Longrightarrow>\n    thesis", "have not_const: \"\\<not> isConst (I' c)\" if \"c \\<in> \\<X>\" for c"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Regions.isConst (I' c)", "proof (rule ccontr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. Regions.isConst (I' c) \\<Longrightarrow> False", "assume A: \"isConst (I' c)\""], ["proof (state)\nthis:\n  Regions.isConst (I' c)\n\ngoal (1 subgoal):\n 1. Regions.isConst (I' c) \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases \"c \\<in> X1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c \\<in> X1 \\<Longrightarrow> False\n 2. c \\<notin> X1 \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  c \\<in> X1\n\ngoal (2 subgoals):\n 1. c \\<in> X1 \\<Longrightarrow> False\n 2. c \\<notin> X1 \\<Longrightarrow> False", "with X1 \\<open>j' > j\\<close> \\<open>j > _\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>X1. \\<forall>m\\<ge>i. unbounded x ([xs !! m]\\<^sub>\\<R>)\n  j < j'\n  i < j\n  c \\<in> X1", "have \"unbounded c ([xs !! j']\\<^sub>\\<R>)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>X1. \\<forall>m\\<ge>i. unbounded x ([xs !! m]\\<^sub>\\<R>)\n  j < j'\n  i < j\n  c \\<in> X1\n\ngoal (1 subgoal):\n 1. unbounded c ([xs !! j']\\<^sub>\\<R>)", "by auto"], ["proof (state)\nthis:\n  unbounded c ([xs !! j']\\<^sub>\\<R>)\n\ngoal (2 subgoals):\n 1. c \\<in> X1 \\<Longrightarrow> False\n 2. c \\<notin> X1 \\<Longrightarrow> False", "with unbounded_Greater \\<open>c \\<in> \\<X>\\<close> region'"], ["proof (chain)\npicking this:\n  \\<lbrakk>Regions.valid_region ?X ?k ?I ?r; ?c \\<in> ?X;\n   unbounded ?c (Regions.region ?X ?I ?r)\\<rbrakk>\n  \\<Longrightarrow> ?I ?c = Regions.intv.Greater (?k ?c)\n  c \\<in> \\<X>\n  [xs !! j']\\<^sub>\\<R> = Regions.region \\<X> I' r'\n  Regions.valid_region \\<X> k I' r'\n  unbounded c ([xs !! j']\\<^sub>\\<R>)", "have \"isGreater (I' c)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>Regions.valid_region ?X ?k ?I ?r; ?c \\<in> ?X;\n   unbounded ?c (Regions.region ?X ?I ?r)\\<rbrakk>\n  \\<Longrightarrow> ?I ?c = Regions.intv.Greater (?k ?c)\n  c \\<in> \\<X>\n  [xs !! j']\\<^sub>\\<R> = Regions.region \\<X> I' r'\n  Regions.valid_region \\<X> k I' r'\n  unbounded c ([xs !! j']\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. Regions.isGreater (I' c)", "by force"], ["proof (state)\nthis:\n  Regions.isGreater (I' c)\n\ngoal (2 subgoals):\n 1. c \\<in> X1 \\<Longrightarrow> False\n 2. c \\<notin> X1 \\<Longrightarrow> False", "with A"], ["proof (chain)\npicking this:\n  Regions.isConst (I' c)\n  Regions.isGreater (I' c)", "show False"], ["proof (prove)\nusing this:\n  Regions.isConst (I' c)\n  Regions.isGreater (I' c)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. c \\<notin> X1 \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<notin> X1 \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  c \\<notin> X1\n\ngoal (1 subgoal):\n 1. c \\<notin> X1 \\<Longrightarrow> False", "with \\<open>c \\<in> \\<X>\\<close>"], ["proof (chain)\npicking this:\n  c \\<in> \\<X>\n  c \\<notin> X1", "have \"c \\<in> X2\""], ["proof (prove)\nusing this:\n  c \\<in> \\<X>\n  c \\<notin> X1\n\ngoal (1 subgoal):\n 1. c \\<in> X2", "unfolding X2_def"], ["proof (prove)\nusing this:\n  c \\<in> \\<X>\n  c \\<notin> X1\n\ngoal (1 subgoal):\n 1. c \\<in> \\<X> - X1", "by auto"], ["proof (state)\nthis:\n  c \\<in> X2\n\ngoal (1 subgoal):\n 1. c \\<notin> X1 \\<Longrightarrow> False", "from region' in_S \\<open>c \\<in> \\<X>\\<close>"], ["proof (chain)\npicking this:\n  [xs !! j']\\<^sub>\\<R> = Regions.region \\<X> I' r'\n  Regions.valid_region \\<X> k I' r'\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  c \\<in> \\<X>", "have \"intv_elem c ?u (I' c)\""], ["proof (prove)\nusing this:\n  [xs !! j']\\<^sub>\\<R> = Regions.region \\<X> I' r'\n  Regions.valid_region \\<X> k I' r'\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  c \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. Regions.intv_elem c (xs !! j') (I' c)", "unfolding stream.pred_set"], ["proof (prove)\nusing this:\n  [xs !! j']\\<^sub>\\<R> = Regions.region \\<X> I' r'\n  Regions.valid_region \\<X> k I' r'\n  \\<forall>u\\<in>sset xs. u \\<in> V\n  c \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. Regions.intv_elem c (xs !! j') (I' c)", "by force"], ["proof (state)\nthis:\n  Regions.intv_elem c (xs !! j') (I' c)\n\ngoal (1 subgoal):\n 1. c \\<notin> X1 \\<Longrightarrow> False", "with \\<open>c \\<in> X2\\<close> A False F"], ["proof (chain)\npicking this:\n  c \\<in> X2\n  Regions.isConst (I' c)\n  c \\<notin> X1\n  \\<not> (\\<exists>c\\<in>X2. \\<exists>x. (xs !! j') c = real x)\n  Regions.intv_elem c (xs !! j') (I' c)", "show False"], ["proof (prove)\nusing this:\n  c \\<in> X2\n  Regions.isConst (I' c)\n  c \\<notin> X1\n  \\<not> (\\<exists>c\\<in>X2. \\<exists>x. (xs !! j') c = real x)\n  Regions.intv_elem c (xs !! j') (I' c)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?c8 \\<in> \\<X> \\<Longrightarrow> \\<not> Regions.isConst (I' ?c8)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>c\\<in>X2.\n               \\<exists>x. (xs !! j') c = real x) \\<Longrightarrow>\n    thesis", "have \"\\<nexists>x. x \\<le> k c \\<and> (xs !! j') c = real x\" if \"c \\<in> \\<X>\" for c"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x\\<le>k c. (xs !! j') c = real x)", "proof (cases \"c \\<in> X2\"; safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>c \\<in> X2; x \\<le> k c; (xs !! j') c = real x\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>c \\<notin> X2; x \\<le> k c; (xs !! j') c = real x\\<rbrakk>\n       \\<Longrightarrow> False", "fix d"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>c \\<in> X2; x \\<le> k c; (xs !! j') c = real x\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>c \\<notin> X2; x \\<le> k c; (xs !! j') c = real x\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"c \\<in> X2\" \"(xs !! j') c = real d\""], ["proof (state)\nthis:\n  c \\<in> X2\n  (xs !! j') c = real d\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>c \\<in> X2; x \\<le> k c; (xs !! j') c = real x\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>c \\<notin> X2; x \\<le> k c; (xs !! j') c = real x\\<rbrakk>\n       \\<Longrightarrow> False", "with F"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>c\\<in>X2. \\<exists>x. (xs !! j') c = real x)\n  c \\<in> X2\n  (xs !! j') c = real d", "show False"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>c\\<in>X2. \\<exists>x. (xs !! j') c = real x)\n  c \\<in> X2\n  (xs !! j') c = real d\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>c \\<notin> X2; x \\<le> k c; (xs !! j') c = real x\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>c \\<notin> X2; x \\<le> k c; (xs !! j') c = real x\\<rbrakk>\n       \\<Longrightarrow> False", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>c \\<notin> X2; x \\<le> k c; (xs !! j') c = real x\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"c \\<notin> X2\""], ["proof (state)\nthis:\n  c \\<notin> X2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>c \\<notin> X2; x \\<le> k c; (xs !! j') c = real x\\<rbrakk>\n       \\<Longrightarrow> False", "with that"], ["proof (chain)\npicking this:\n  c \\<in> \\<X>\n  c \\<notin> X2", "have \"c \\<in> X1\""], ["proof (prove)\nusing this:\n  c \\<in> \\<X>\n  c \\<notin> X2\n\ngoal (1 subgoal):\n 1. c \\<in> X1", "unfolding X2_def"], ["proof (prove)\nusing this:\n  c \\<in> \\<X>\n  c \\<notin> \\<X> - X1\n\ngoal (1 subgoal):\n 1. c \\<in> X1", "by auto"], ["proof (state)\nthis:\n  c \\<in> X1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>c \\<notin> X2; x \\<le> k c; (xs !! j') c = real x\\<rbrakk>\n       \\<Longrightarrow> False", "with X1 \\<open>j' > j\\<close> \\<open>j > i\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>X1. \\<forall>m\\<ge>i. unbounded x ([xs !! m]\\<^sub>\\<R>)\n  j < j'\n  i < j\n  c \\<in> X1", "have \"unbounded c ([?u]\\<^sub>\\<R>)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>X1. \\<forall>m\\<ge>i. unbounded x ([xs !! m]\\<^sub>\\<R>)\n  j < j'\n  i < j\n  c \\<in> X1\n\ngoal (1 subgoal):\n 1. unbounded c ([xs !! j']\\<^sub>\\<R>)", "by auto"], ["proof (state)\nthis:\n  unbounded c ([xs !! j']\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>c \\<notin> X2; x \\<le> k c; (xs !! j') c = real x\\<rbrakk>\n       \\<Longrightarrow> False", "from unbounded_all[OF _ _ this] \\<open>c \\<in> \\<X>\\<close> in_S"], ["proof (chain)\npicking this:\n  \\<lbrakk>[xs !! j']\\<^sub>\\<R> \\<in> \\<R>; ?u \\<in> [xs !! j']\\<^sub>\\<R>;\n   c \\<in> \\<X>\\<rbrakk>\n  \\<Longrightarrow> real (k c) < ?u c\n  c \\<in> \\<X>\n  pred_stream (\\<lambda>u. u \\<in> V) xs", "have \"?u c > k c\""], ["proof (prove)\nusing this:\n  \\<lbrakk>[xs !! j']\\<^sub>\\<R> \\<in> \\<R>; ?u \\<in> [xs !! j']\\<^sub>\\<R>;\n   c \\<in> \\<X>\\<rbrakk>\n  \\<Longrightarrow> real (k c) < ?u c\n  c \\<in> \\<X>\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n\ngoal (1 subgoal):\n 1. real (k c) < (xs !! j') c", "by (force simp: stream.pred_set)"], ["proof (state)\nthis:\n  real (k c) < (xs !! j') c\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>c \\<notin> X2; x \\<le> k c; (xs !! j') c = real x\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  real (k c) < (xs !! j') c\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>c \\<notin> X2; x \\<le> k c; (xs !! j') c = real x\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"?u c = real d\" \"d \\<le> k c\""], ["proof (state)\nthis:\n  (xs !! j') c = real d\n  d \\<le> k c\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>c \\<notin> X2; x \\<le> k c; (xs !! j') c = real x\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  real (k c) < (xs !! j') c\n  (xs !! j') c = real d\n  d \\<le> k c", "show False"], ["proof (prove)\nusing this:\n  real (k c) < (xs !! j') c\n  (xs !! j') c = real d\n  d \\<le> k c\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?c8 \\<in> \\<X> \\<Longrightarrow>\n  \\<not> (\\<exists>x\\<le>k ?c8. (xs !! j') ?c8 = real x)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>c\\<in>X2.\n               \\<exists>x. (xs !! j') c = real x) \\<Longrightarrow>\n    thesis", "with delayedR_aux"], ["proof (chain)\npicking this:\n  trans' (xs !! (j' - 1)) (xs !! j')\n  (xs !! (j' - 1)) x = 0\n  0 < (xs !! j') x\n  ?c8 \\<in> \\<X> \\<Longrightarrow>\n  \\<not> (\\<exists>x\\<le>k ?c8. (xs !! j') ?c8 = real x)", "have\n                \"(xs !! j') = delayedR ([xs !! j']\\<^sub>\\<R>) (xs !! (j' - 1))\""], ["proof (prove)\nusing this:\n  trans' (xs !! (j' - 1)) (xs !! j')\n  (xs !! (j' - 1)) x = 0\n  0 < (xs !! j') x\n  ?c8 \\<in> \\<X> \\<Longrightarrow>\n  \\<not> (\\<exists>x\\<le>k ?c8. (xs !! j') ?c8 = real x)\n\ngoal (1 subgoal):\n 1. xs !! j' = delayedR ([xs !! j']\\<^sub>\\<R>) (xs !! (j' - 1))", "using \\<open>x \\<in> \\<X>\\<close>"], ["proof (prove)\nusing this:\n  trans' (xs !! (j' - 1)) (xs !! j')\n  (xs !! (j' - 1)) x = 0\n  0 < (xs !! j') x\n  ?c8 \\<in> \\<X> \\<Longrightarrow>\n  \\<not> (\\<exists>x\\<le>k ?c8. (xs !! j') ?c8 = real x)\n  x \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. xs !! j' = delayedR ([xs !! j']\\<^sub>\\<R>) (xs !! (j' - 1))", "unfolding trans'_def"], ["proof (prove)\nusing this:\n  ((\\<forall>c\\<in>\\<X>.\n       real (k c) < (xs !! (j' - 1)) c \\<and>\n       real (k c) < (xs !! j') c \\<and>\n       xs !! (j' - 1) \\<noteq> xs !! j') \\<longrightarrow>\n   xs !! j' = xs !! (j' - 1) \\<oplus> 5 / 10) \\<and>\n  ((\\<exists>c\\<in>\\<X>.\n       (xs !! (j' - 1)) c = 0 \\<and>\n       0 < (xs !! j') c \\<and>\n       (\\<forall>c\\<in>\\<X>.\n           \\<not> (\\<exists>d\\<le>k c.\n                      (xs !! j') c = real d))) \\<longrightarrow>\n   xs !! j' = delayedR ([xs !! j']\\<^sub>\\<R>) (xs !! (j' - 1)))\n  (xs !! (j' - 1)) x = 0\n  0 < (xs !! j') x\n  ?c8 \\<in> \\<X> \\<Longrightarrow>\n  \\<not> (\\<exists>x\\<le>k ?c8. (xs !! j') ?c8 = real x)\n  x \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. xs !! j' = delayedR ([xs !! j']\\<^sub>\\<R>) (xs !! (j' - 1))", "by auto"], ["proof (state)\nthis:\n  xs !! j' = delayedR ([xs !! j']\\<^sub>\\<R>) (xs !! (j' - 1))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>c\\<in>X2.\n               \\<exists>x. (xs !! j') c = real x) \\<Longrightarrow>\n    thesis", "from not_const region'(1)  in_S Succ(1)"], ["proof (chain)\npicking this:\n  ?c8 \\<in> \\<X> \\<Longrightarrow> \\<not> Regions.isConst (I' ?c8)\n  [xs !! j']\\<^sub>\\<R> = Regions.region \\<X> I' r'\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  [xs !! j']\\<^sub>\\<R> \\<in> Succ \\<R> ([xs !! (j' - 1)]\\<^sub>\\<R>)", "have\n                \"\\<exists>t\\<ge>0. delayedR ([xs !! j']\\<^sub>\\<R>) (xs !! (j' - 1)) = xs !! (j' - 1) \\<oplus> t \\<and>\n                      (1 - Max (?S' \\<union> {0})) / 2 \\<le> t\""], ["proof (prove)\nusing this:\n  ?c8 \\<in> \\<X> \\<Longrightarrow> \\<not> Regions.isConst (I' ?c8)\n  [xs !! j']\\<^sub>\\<R> = Regions.region \\<X> I' r'\n  pred_stream (\\<lambda>u. u \\<in> V) xs\n  [xs !! j']\\<^sub>\\<R> \\<in> Succ \\<R> ([xs !! (j' - 1)]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<ge>0.\n       delayedR ([xs !! j']\\<^sub>\\<R>) (xs !! (j' - 1)) =\n       xs !! (j' - 1) \\<oplus> t \\<and>\n       (1 -\n        Max ({frac ((xs !! (j' - 1)) c) |c.\n              c \\<in> \\<X> \\<and> Regions.isIntv (I' c)} \\<union>\n             {0})) /\n       2\n       \\<le> t", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>c.\n                c \\<in> \\<X> \\<Longrightarrow>\n                \\<not> Regions.isConst (I' c);\n     [xs !! j']\\<^sub>\\<R> = Regions.region \\<X> I' r';\n     pred_stream (\\<lambda>u. u \\<in> V) xs;\n     Regions.region \\<X> I' r'\n     \\<in> Succ \\<R> ([xs !! (j' - Suc 0)]\\<^sub>\\<R>)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         delayedR (Regions.region \\<X> I' r')\n                          (xs !! (j' - Suc 0)) =\n                         xs !! (j' - Suc 0) \\<oplus> t \\<and>\n                         1 -\n                         Max (insert 0\n                               {frac ((xs !! (j' - Suc 0)) c) |c.\n                                c \\<in> \\<X> \\<and> Regions.isIntv (I' c)})\n                         \\<le> t * 2", "apply (rule delayedR_correct(2)[OF _ _ region'(2), simplified])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<And>c.\n                c \\<in> \\<X> \\<Longrightarrow>\n                \\<not> Regions.isConst (I' c);\n     [xs !! j']\\<^sub>\\<R> = Regions.region \\<X> I' r';\n     pred_stream (\\<lambda>u. u \\<in> V) xs;\n     Regions.region \\<X> I' r'\n     \\<in> Succ \\<R> ([xs !! (j' - Suc 0)]\\<^sub>\\<R>)\\<rbrakk>\n    \\<Longrightarrow> xs !! (j' - Suc 0) \\<in> ?R14\n 2. \\<lbrakk>\\<And>c.\n                c \\<in> \\<X> \\<Longrightarrow>\n                \\<not> Regions.isConst (I' c);\n     [xs !! j']\\<^sub>\\<R> = Regions.region \\<X> I' r';\n     pred_stream (\\<lambda>u. u \\<in> V) xs;\n     Regions.region \\<X> I' r'\n     \\<in> Succ \\<R> ([xs !! (j' - Suc 0)]\\<^sub>\\<R>)\\<rbrakk>\n    \\<Longrightarrow> ?R14 \\<in> \\<R>\n 3. \\<lbrakk>\\<And>c.\n                c \\<in> \\<X> \\<Longrightarrow>\n                \\<not> Regions.isConst (I' c);\n     [xs !! j']\\<^sub>\\<R> = Regions.region \\<X> I' r';\n     pred_stream (\\<lambda>u. u \\<in> V) xs;\n     Regions.region \\<X> I' r'\n     \\<in> Succ \\<R> ([xs !! (j' - Suc 0)]\\<^sub>\\<R>)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>c\\<in>\\<X>. \\<not> Regions.isConst (I' c)\n 4. \\<lbrakk>\\<And>c.\n                c \\<in> \\<X> \\<Longrightarrow>\n                \\<not> Regions.isConst (I' c);\n     [xs !! j']\\<^sub>\\<R> = Regions.region \\<X> I' r';\n     pred_stream (\\<lambda>u. u \\<in> V) xs;\n     Regions.region \\<X> I' r'\n     \\<in> Succ \\<R> ([xs !! (j' - Suc 0)]\\<^sub>\\<R>)\\<rbrakk>\n    \\<Longrightarrow> Regions.region \\<X> I' r' \\<in> Succ \\<R> ?R14", "by (auto simp: stream.pred_set)"], ["proof (state)\nthis:\n  \\<exists>t\\<ge>0.\n     delayedR ([xs !! j']\\<^sub>\\<R>) (xs !! (j' - 1)) =\n     xs !! (j' - 1) \\<oplus> t \\<and>\n     (1 -\n      Max ({frac ((xs !! (j' - 1)) c) |c.\n            c \\<in> \\<X> \\<and> Regions.isIntv (I' c)} \\<union>\n           {0})) /\n     2\n     \\<le> t\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>c\\<in>X2.\n               \\<exists>x. (xs !! j') c = real x) \\<Longrightarrow>\n    thesis", "with le \\<open>_ = delayedR _ _\\<close>"], ["proof (chain)\npicking this:\n  (1 - (xs !! (j - 1)) x) / 2\n  \\<le> (1 -\n         Max ({frac ((xs !! (j' - 1)) c) |c.\n               c \\<in> \\<X> \\<and> Regions.isIntv (I' c)} \\<union>\n              {0})) /\n        2\n  xs !! j' = delayedR ([xs !! j']\\<^sub>\\<R>) (xs !! (j' - 1))\n  \\<exists>t\\<ge>0.\n     delayedR ([xs !! j']\\<^sub>\\<R>) (xs !! (j' - 1)) =\n     xs !! (j' - 1) \\<oplus> t \\<and>\n     (1 -\n      Max ({frac ((xs !! (j' - 1)) c) |c.\n            c \\<in> \\<X> \\<and> Regions.isIntv (I' c)} \\<union>\n           {0})) /\n     2\n     \\<le> t", "show ?thesis"], ["proof (prove)\nusing this:\n  (1 - (xs !! (j - 1)) x) / 2\n  \\<le> (1 -\n         Max ({frac ((xs !! (j' - 1)) c) |c.\n               c \\<in> \\<X> \\<and> Regions.isIntv (I' c)} \\<union>\n              {0})) /\n        2\n  xs !! j' = delayedR ([xs !! j']\\<^sub>\\<R>) (xs !! (j' - 1))\n  \\<exists>t\\<ge>0.\n     delayedR ([xs !! j']\\<^sub>\\<R>) (xs !! (j' - 1)) =\n     xs !! (j' - 1) \\<oplus> t \\<and>\n     (1 -\n      Max ({frac ((xs !! (j' - 1)) c) |c.\n            c \\<in> \\<X> \\<and> Regions.isIntv (I' c)} \\<union>\n           {0})) /\n     2\n     \\<le> t\n\ngoal (1 subgoal):\n 1. thesis", "by (auto intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xs !! j' = xs !! (j' - 1) \\<oplus> t\n  (1 - (xs !! (j - 1)) x) / 2 \\<le> t\n  0 \\<le> t\n\ngoal (1 subgoal):\n 1. (1 - (xs !! (j - 1)) x) / 2 \\<le> dur xs j' - dur xs (j' - 1)", "moreover"], ["proof (state)\nthis:\n  xs !! j' = xs !! (j' - 1) \\<oplus> t\n  (1 - (xs !! (j - 1)) x) / 2 \\<le> t\n  0 \\<le> t\n\ngoal (1 subgoal):\n 1. (1 - (xs !! (j - 1)) x) / 2 \\<le> dur xs j' - dur xs (j' - 1)", "from pairwise_Suc[OF eq_elapsed, of \"j' - 1\"] \\<open>j' > 0\\<close>"], ["proof (chain)\npicking this:\n  eq_elapsed (xs !! (j' - 1)) (xs !! Suc (j' - 1))\n  0 < j'", "have\n            \"eq_elapsed (xs !! (j' - 1)) (xs !! j')\""], ["proof (prove)\nusing this:\n  eq_elapsed (xs !! (j' - 1)) (xs !! Suc (j' - 1))\n  0 < j'\n\ngoal (1 subgoal):\n 1. eq_elapsed (xs !! (j' - 1)) (xs !! j')", "by auto"], ["proof (state)\nthis:\n  eq_elapsed (xs !! (j' - 1)) (xs !! j')\n\ngoal (1 subgoal):\n 1. (1 - (xs !! (j - 1)) x) / 2 \\<le> dur xs j' - dur xs (j' - 1)", "ultimately"], ["proof (chain)\npicking this:\n  trans' (xs !! (j' - 1)) (xs !! j')\n  (xs !! (j' - 1)) x = 0\n  0 < (xs !! j') x\n  xs !! j' = xs !! (j' - 1) \\<oplus> t\n  (1 - (xs !! (j - 1)) x) / 2 \\<le> t\n  0 \\<le> t\n  eq_elapsed (xs !! (j' - 1)) (xs !! j')", "show \"dur xs j' - dur xs (j' - 1) \\<ge> (1 - ?d2) / 2\""], ["proof (prove)\nusing this:\n  trans' (xs !! (j' - 1)) (xs !! j')\n  (xs !! (j' - 1)) x = 0\n  0 < (xs !! j') x\n  xs !! j' = xs !! (j' - 1) \\<oplus> t\n  (1 - (xs !! (j - 1)) x) / 2 \\<le> t\n  0 \\<le> t\n  eq_elapsed (xs !! (j' - 1)) (xs !! j')\n\ngoal (1 subgoal):\n 1. (1 - (xs !! (j - 1)) x) / 2 \\<le> dur xs j' - dur xs (j' - 1)", "using \\<open>j' > 0\\<close> dur_Suc[of _ \"j' - 1\"] \\<open>x \\<in> \\<X>\\<close>"], ["proof (prove)\nusing this:\n  trans' (xs !! (j' - 1)) (xs !! j')\n  (xs !! (j' - 1)) x = 0\n  0 < (xs !! j') x\n  xs !! j' = xs !! (j' - 1) \\<oplus> t\n  (1 - (xs !! (j - 1)) x) / 2 \\<le> t\n  0 \\<le> t\n  eq_elapsed (xs !! (j' - 1)) (xs !! j')\n  0 < j'\n  dur ?xs (Suc (j' - 1)) - dur ?xs (j' - 1) =\n  elapsed (?xs !! (j' - 1)) (?xs !! Suc (j' - 1))\n  x \\<in> \\<X>\n\ngoal (1 subgoal):\n 1. (1 - (xs !! (j - 1)) x) / 2 \\<le> dur xs j' - dur xs (j' - 1)", "by (auto simp: cval_add_def elapsed_eq)"], ["proof (state)\nthis:\n  (1 - (xs !! (j - 1)) x) / 2 \\<le> dur xs j' - dur xs (j' - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (1 - (xs !! (j - 1)) x) / 2 \\<le> dur xs j' - dur xs (j' - 1)\n\ngoal (1 subgoal):\n 1. \\<not> 5 / 10 \\<le> dur xs (j - 1) - dur xs i \\<Longrightarrow>\n    \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "moreover"], ["proof (state)\nthis:\n  (1 - (xs !! (j - 1)) x) / 2 \\<le> dur xs j' - dur xs (j' - 1)\n\ngoal (1 subgoal):\n 1. \\<not> 5 / 10 \\<le> dur xs (j - 1) - dur xs i \\<Longrightarrow>\n    \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "from dur_mono[of i \"j - 1\" xs] \\<open>i < j\\<close>"], ["proof (chain)\npicking this:\n  i \\<le> j - 1 \\<Longrightarrow> dur xs i \\<le> dur xs (j - 1)\n  i < j", "have \"dur xs i \\<le> dur xs (j - 1)\""], ["proof (prove)\nusing this:\n  i \\<le> j - 1 \\<Longrightarrow> dur xs i \\<le> dur xs (j - 1)\n  i < j\n\ngoal (1 subgoal):\n 1. dur xs i \\<le> dur xs (j - 1)", "by simp"], ["proof (state)\nthis:\n  dur xs i \\<le> dur xs (j - 1)\n\ngoal (1 subgoal):\n 1. \\<not> 5 / 10 \\<le> dur xs (j - 1) - dur xs i \\<Longrightarrow>\n    \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "ultimately"], ["proof (chain)\npicking this:\n  dur xs (j' - 1) = dur xs (j - 1)\n  (1 - (xs !! (j - 1)) x) / 2 \\<le> dur xs j' - dur xs (j' - 1)\n  dur xs i \\<le> dur xs (j - 1)", "have \"dur xs j' - dur xs i \\<ge> 0.5\""], ["proof (prove)\nusing this:\n  dur xs (j' - 1) = dur xs (j - 1)\n  (1 - (xs !! (j - 1)) x) / 2 \\<le> dur xs j' - dur xs (j' - 1)\n  dur xs i \\<le> dur xs (j - 1)\n\ngoal (1 subgoal):\n 1. 5 / 10 \\<le> dur xs j' - dur xs i", "unfolding \\<open>?d1 = ?d2\\<close>[symmetric]"], ["proof (prove)\nusing this:\n  dur xs (j' - 1) = dur xs (j - 1)\n  (1 - (dur xs (j - 1) - dur xs i)) / 2 \\<le> dur xs j' - dur xs (j' - 1)\n  dur xs i \\<le> dur xs (j - 1)\n\ngoal (1 subgoal):\n 1. 5 / 10 \\<le> dur xs j' - dur xs i", "by auto"], ["proof (state)\nthis:\n  5 / 10 \\<le> dur xs j' - dur xs i\n\ngoal (1 subgoal):\n 1. \\<not> 5 / 10 \\<le> dur xs (j - 1) - dur xs i \\<Longrightarrow>\n    \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "then"], ["proof (chain)\npicking this:\n  5 / 10 \\<le> dur xs j' - dur xs i", "show ?thesis"], ["proof (prove)\nusing this:\n  5 / 10 \\<le> dur xs j' - dur xs i\n\ngoal (1 subgoal):\n 1. \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "using \\<open>j < j'\\<close>"], ["proof (prove)\nusing this:\n  5 / 10 \\<le> dur xs j' - dur xs i\n  j < j'\n\ngoal (1 subgoal):\n 1. \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i", "by - (rule exI[where x = j']; auto)"], ["proof (state)\nthis:\n  \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>j'\\<ge>j. 5 / 10 \\<le> dur xs j' - dur xs i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?x8 \\<in> X2; ?i8 < ?j8; zero ?x8 ([xs !! ?i8]\\<^sub>\\<R>);\n   zero ?x8 ([xs !! ?j8]\\<^sub>\\<R>);\n   \\<forall>m.\n      ?i8 < m \\<and> m < ?j8 \\<longrightarrow>\n      \\<not> zero ?x8 ([xs !! m]\\<^sub>\\<R>);\n   \\<forall>x\\<in>X2.\n      \\<exists>m>?i8. m \\<le> ?j8 \\<and> zero x ([xs !! m]\\<^sub>\\<R>);\n   \\<forall>x\\<in>X1.\n      \\<forall>m\\<ge>?i8. unbounded x ([xs !! m]\\<^sub>\\<R>)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>j'\\<ge>?j8. 5 / 10 \\<le> dur xs j' - dur xs ?i8\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>\\<X>.\n               \\<exists>i.\n                  \\<forall>j\\<ge>i.\n                     unbounded x ([xs !! j]\\<^sub>\\<R>)) \\<Longrightarrow>\n    \\<exists>n. t < dur xs n", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?x8 \\<in> X2; ?i8 < ?j8; zero ?x8 ([xs !! ?i8]\\<^sub>\\<R>);\n   zero ?x8 ([xs !! ?j8]\\<^sub>\\<R>);\n   \\<forall>m.\n      ?i8 < m \\<and> m < ?j8 \\<longrightarrow>\n      \\<not> zero ?x8 ([xs !! m]\\<^sub>\\<R>);\n   \\<forall>x\\<in>X2.\n      \\<exists>m>?i8. m \\<le> ?j8 \\<and> zero x ([xs !! m]\\<^sub>\\<R>);\n   \\<forall>x\\<in>X1.\n      \\<forall>m\\<ge>?i8. unbounded x ([xs !! m]\\<^sub>\\<R>)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>j'\\<ge>?j8. 5 / 10 \\<le> dur xs j' - dur xs ?i8\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>\\<X>.\n               \\<exists>i.\n                  \\<forall>j\\<ge>i.\n                     unbounded x ([xs !! j]\\<^sub>\\<R>)) \\<Longrightarrow>\n    \\<exists>n. t < dur xs n", "have \"\\<exists> j' \\<ge> i. dur xs j' - dur xs i \\<ge> 0.5\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j'\\<ge>i. 5 / 10 \\<le> dur xs j' - dur xs i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>j'\\<ge>i. 5 / 10 \\<le> dur xs j' - dur xs i", "from calculation(1)[of i]"], ["proof (chain)\npicking this:\n  \\<exists>j\\<ge>i.\n     \\<exists>k>j.\n        \\<exists>x\\<in>X2.\n           zero x ([xs !! j]\\<^sub>\\<R>) \\<and>\n           zero x ([xs !! k]\\<^sub>\\<R>) \\<and>\n           (\\<forall>m.\n               j < m \\<and> m < k \\<longrightarrow>\n               \\<not> zero x ([xs !! m]\\<^sub>\\<R>)) \\<and>\n           (\\<forall>x\\<in>X2.\n               \\<exists>m>j.\n                  m \\<le> k \\<and> zero x ([xs !! m]\\<^sub>\\<R>)) \\<and>\n           (\\<forall>x\\<in>X1.\n               \\<forall>m\\<ge>j. unbounded x ([xs !! m]\\<^sub>\\<R>))", "obtain j k x where\n        \"j\\<ge>i\" \"k>j\" \"x\\<in>X2\" \"zero x ([xs !! j]\\<^sub>\\<R>)\"\n        \"zero x ([xs !! k]\\<^sub>\\<R>)\"\n        \"\\<forall>m. j < m \\<and> m < k \\<longrightarrow> \\<not> zero x ([xs !! m]\\<^sub>\\<R>)\"\n        \"\\<forall>x\\<in>X2. \\<exists>m>j. m \\<le> k \\<and> zero x ([xs !! m]\\<^sub>\\<R>)\"\n        \"\\<forall>x\\<in>X1. \\<forall>m\\<ge>j. unbounded x ([xs !! m]\\<^sub>\\<R>)\""], ["proof (prove)\nusing this:\n  \\<exists>j\\<ge>i.\n     \\<exists>k>j.\n        \\<exists>x\\<in>X2.\n           zero x ([xs !! j]\\<^sub>\\<R>) \\<and>\n           zero x ([xs !! k]\\<^sub>\\<R>) \\<and>\n           (\\<forall>m.\n               j < m \\<and> m < k \\<longrightarrow>\n               \\<not> zero x ([xs !! m]\\<^sub>\\<R>)) \\<and>\n           (\\<forall>x\\<in>X2.\n               \\<exists>m>j.\n                  m \\<le> k \\<and> zero x ([xs !! m]\\<^sub>\\<R>)) \\<and>\n           (\\<forall>x\\<in>X1.\n               \\<forall>m\\<ge>j. unbounded x ([xs !! m]\\<^sub>\\<R>))\n\ngoal (1 subgoal):\n 1. (\\<And>j k x.\n        \\<lbrakk>i \\<le> j; j < k; x \\<in> X2;\n         zero x ([xs !! j]\\<^sub>\\<R>); zero x ([xs !! k]\\<^sub>\\<R>);\n         \\<forall>m.\n            j < m \\<and> m < k \\<longrightarrow>\n            \\<not> zero x ([xs !! m]\\<^sub>\\<R>);\n         \\<forall>x\\<in>X2.\n            \\<exists>m>j. m \\<le> k \\<and> zero x ([xs !! m]\\<^sub>\\<R>);\n         \\<forall>x\\<in>X1.\n            \\<forall>m\\<ge>j. unbounded x ([xs !! m]\\<^sub>\\<R>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i \\<le> j\n  j < k\n  x \\<in> X2\n  zero x ([xs !! j]\\<^sub>\\<R>)\n  zero x ([xs !! k]\\<^sub>\\<R>)\n  \\<forall>m.\n     j < m \\<and> m < k \\<longrightarrow>\n     \\<not> zero x ([xs !! m]\\<^sub>\\<R>)\n  \\<forall>x\\<in>X2.\n     \\<exists>m>j. m \\<le> k \\<and> zero x ([xs !! m]\\<^sub>\\<R>)\n  \\<forall>x\\<in>X1. \\<forall>m\\<ge>j. unbounded x ([xs !! m]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. \\<exists>j'\\<ge>i. 5 / 10 \\<le> dur xs j' - dur xs i", "from calculation(2)[OF this(3,2,4-8)]"], ["proof (chain)\npicking this:\n  \\<exists>j'\\<ge>k. 5 / 10 \\<le> dur xs j' - dur xs j", "obtain j' where\n        \"j'\\<ge>k\" \"5 / 10 \\<le> dur xs j' - dur xs j\""], ["proof (prove)\nusing this:\n  \\<exists>j'\\<ge>k. 5 / 10 \\<le> dur xs j' - dur xs j\n\ngoal (1 subgoal):\n 1. (\\<And>j'.\n        \\<lbrakk>k \\<le> j'; 5 / 10 \\<le> dur xs j' - dur xs j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  k \\<le> j'\n  5 / 10 \\<le> dur xs j' - dur xs j\n\ngoal (1 subgoal):\n 1. \\<exists>j'\\<ge>i. 5 / 10 \\<le> dur xs j' - dur xs i", "with dur_mono[of i j xs] \\<open>j \\<ge> i\\<close> \\<open>k > j\\<close>"], ["proof (chain)\npicking this:\n  i \\<le> j \\<Longrightarrow> dur xs i \\<le> dur xs j\n  i \\<le> j\n  j < k\n  k \\<le> j'\n  5 / 10 \\<le> dur xs j' - dur xs j", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<le> j \\<Longrightarrow> dur xs i \\<le> dur xs j\n  i \\<le> j\n  j < k\n  k \\<le> j'\n  5 / 10 \\<le> dur xs j' - dur xs j\n\ngoal (1 subgoal):\n 1. \\<exists>j'\\<ge>i. 5 / 10 \\<le> dur xs j' - dur xs i", "by (intro exI[where x = j']; auto)"], ["proof (state)\nthis:\n  \\<exists>j'\\<ge>i. 5 / 10 \\<le> dur xs j' - dur xs i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>j'\\<ge>?i8. 5 / 10 \\<le> dur xs j' - dur xs ?i8\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>\\<X>.\n               \\<exists>i.\n                  \\<forall>j\\<ge>i.\n                     unbounded x ([xs !! j]\\<^sub>\\<R>)) \\<Longrightarrow>\n    \\<exists>n. t < dur xs n", "then"], ["proof (chain)\npicking this:\n  \\<exists>j'\\<ge>?i8. 5 / 10 \\<le> dur xs j' - dur xs ?i8", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>j'\\<ge>?i8. 5 / 10 \\<le> dur xs j' - dur xs ?i8\n\ngoal (1 subgoal):\n 1. \\<exists>n. t < dur xs n", "by - (rule dur_ev_exceedsI[where d = \"0.5\"]; auto)"], ["proof (state)\nthis:\n  \\<exists>n. t < dur xs n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>n. t < dur xs n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cfg_on_div_absc:\n  notes in_space_UNIV[measurable]\n  assumes \"cfg \\<in> cfg_on_div st\" \"st \\<in> S\"\n  shows \"absc cfg \\<in> R_G_cfg_on_div (abss st)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. absc cfg \\<in> R_G_cfg_on_div (abss st)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. absc cfg \\<in> R_G_cfg_on_div (abss st)", "from assms"], ["proof (chain)\npicking this:\n  cfg \\<in> cfg_on_div st\n  st \\<in> S", "have *: \"cfg \\<in> MDP.cfg_on st\" \"state cfg = st\" \"div_cfg cfg\""], ["proof (prove)\nusing this:\n  cfg \\<in> cfg_on_div st\n  st \\<in> S\n\ngoal (1 subgoal):\n 1. cfg \\<in> MDP.cfg_on st &&& state cfg = st &&& div_cfg cfg", "unfolding cfg_on_div_def"], ["proof (prove)\nusing this:\n  cfg \\<in> MDP.cfg_on st \\<inter> Collect div_cfg\n  st \\<in> S\n\ngoal (1 subgoal):\n 1. cfg \\<in> MDP.cfg_on st &&& state cfg = st &&& div_cfg cfg", "by auto"], ["proof (state)\nthis:\n  cfg \\<in> MDP.cfg_on st\n  state cfg = st\n  div_cfg cfg\n\ngoal (1 subgoal):\n 1. absc cfg \\<in> R_G_cfg_on_div (abss st)", "with assms"], ["proof (chain)\npicking this:\n  cfg \\<in> cfg_on_div st\n  st \\<in> S\n  cfg \\<in> MDP.cfg_on st\n  state cfg = st\n  div_cfg cfg", "have \"cfg \\<in> valid_cfg\""], ["proof (prove)\nusing this:\n  cfg \\<in> cfg_on_div st\n  st \\<in> S\n  cfg \\<in> MDP.cfg_on st\n  state cfg = st\n  div_cfg cfg\n\ngoal (1 subgoal):\n 1. cfg \\<in> MDP.valid_cfg", "by (auto intro: MDP.valid_cfgI)"], ["proof (state)\nthis:\n  cfg \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. absc cfg \\<in> R_G_cfg_on_div (abss st)", "have \"almost_everywhere (MDP.MC.T cfg) (MDP.MC.enabled cfg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_everywhere (MDP.MC.T cfg) (MDP.MC.enabled cfg)", "by (rule MDP.MC.AE_T_enabled)"], ["proof (state)\nthis:\n  almost_everywhere (MDP.MC.T cfg) (MDP.MC.enabled cfg)\n\ngoal (1 subgoal):\n 1. absc cfg \\<in> R_G_cfg_on_div (abss st)", "moreover"], ["proof (state)\nthis:\n  almost_everywhere (MDP.MC.T cfg) (MDP.MC.enabled cfg)\n\ngoal (1 subgoal):\n 1. absc cfg \\<in> R_G_cfg_on_div (abss st)", "from *"], ["proof (chain)\npicking this:\n  cfg \\<in> MDP.cfg_on st\n  state cfg = st\n  div_cfg cfg", "have \"AE x in MDP.MC.T cfg. divergent (smap (snd \\<circ> state) x)\""], ["proof (prove)\nusing this:\n  cfg \\<in> MDP.cfg_on st\n  state cfg = st\n  div_cfg cfg\n\ngoal (1 subgoal):\n 1. AE x in MDP.MC.T cfg. divergent (smap (snd \\<circ> state) x)", "by (simp add: div_cfg_def)"], ["proof (state)\nthis:\n  AE x in MDP.MC.T cfg. divergent (smap (snd \\<circ> state) x)\n\ngoal (1 subgoal):\n 1. absc cfg \\<in> R_G_cfg_on_div (abss st)", "ultimately"], ["proof (chain)\npicking this:\n  almost_everywhere (MDP.MC.T cfg) (MDP.MC.enabled cfg)\n  AE x in MDP.MC.T cfg. divergent (smap (snd \\<circ> state) x)", "have \"AE x in MDP.MC.T cfg. \\<R>_div (smap (snd \\<circ> state) (smap absc x))\""], ["proof (prove)\nusing this:\n  almost_everywhere (MDP.MC.T cfg) (MDP.MC.enabled cfg)\n  AE x in MDP.MC.T cfg. divergent (smap (snd \\<circ> state) x)\n\ngoal (1 subgoal):\n 1. AE x in MDP.MC.T cfg. \\<R>_div (smap (snd \\<circ> state) (smap absc x))", "proof eventually_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>MDP.MC.enabled cfg x;\n        divergent (smap (snd \\<circ> state) x)\\<rbrakk>\n       \\<Longrightarrow> \\<R>_div (smap (snd \\<circ> state) (smap absc x))", "case (elim \\<omega>)"], ["proof (state)\nthis:\n  MDP.MC.enabled cfg \\<omega>\n  divergent (smap (snd \\<circ> state) \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>MDP.MC.enabled cfg x;\n        divergent (smap (snd \\<circ> state) x)\\<rbrakk>\n       \\<Longrightarrow> \\<R>_div (smap (snd \\<circ> state) (smap absc x))", "let ?xs = \"smap (snd o state) \\<omega>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>MDP.MC.enabled cfg x;\n        divergent (smap (snd \\<circ> state) x)\\<rbrakk>\n       \\<Longrightarrow> \\<R>_div (smap (snd \\<circ> state) (smap absc x))", "from MDP.pred_stream_cfg_on[OF \\<open>_ \\<in> valid_cfg\\<close> \\<open>MDP.MC.enabled _ _\\<close>]"], ["proof (chain)\npicking this:\n  pred_stream\n   (\\<lambda>cfg. state cfg \\<in> S \\<and> cfg \\<in> MDP.cfg_on (state cfg))\n   \\<omega>", "have *:\n      \"pred_stream (\\<lambda> x. x \\<in> S) (smap state \\<omega>)\""], ["proof (prove)\nusing this:\n  pred_stream\n   (\\<lambda>cfg. state cfg \\<in> S \\<and> cfg \\<in> MDP.cfg_on (state cfg))\n   \\<omega>\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>x. x \\<in> S) (smap state \\<omega>)", "by (auto simp: stream.pred_set)"], ["proof (state)\nthis:\n  pred_stream (\\<lambda>x. x \\<in> S) (smap state \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>MDP.MC.enabled cfg x;\n        divergent (smap (snd \\<circ> state) x)\\<rbrakk>\n       \\<Longrightarrow> \\<R>_div (smap (snd \\<circ> state) (smap absc x))", "have \"[snd (state x)]\\<^sub>\\<R> = snd (abss (state x))\" if \"x \\<in> sset \\<omega>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. [snd (state x)]\\<^sub>\\<R> = snd (abss (state x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [snd (state x)]\\<^sub>\\<R> = snd (abss (state x))", "from * that"], ["proof (chain)\npicking this:\n  pred_stream (\\<lambda>x. x \\<in> S) (smap state \\<omega>)\n  x \\<in> sset \\<omega>", "have \"state x \\<in> S\""], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>x. x \\<in> S) (smap state \\<omega>)\n  x \\<in> sset \\<omega>\n\ngoal (1 subgoal):\n 1. state x \\<in> S", "by (auto simp: stream.pred_set)"], ["proof (state)\nthis:\n  state x \\<in> S\n\ngoal (1 subgoal):\n 1. [snd (state x)]\\<^sub>\\<R> = snd (abss (state x))", "then"], ["proof (chain)\npicking this:\n  state x \\<in> S", "have \"snd (abss (state x)) = [snd (state x)]\\<^sub>\\<R>\""], ["proof (prove)\nusing this:\n  state x \\<in> S\n\ngoal (1 subgoal):\n 1. snd (abss (state x)) = [snd (state x)]\\<^sub>\\<R>", "by (metis abss_S snd_conv surj_pair)"], ["proof (state)\nthis:\n  snd (abss (state x)) = [snd (state x)]\\<^sub>\\<R>\n\ngoal (1 subgoal):\n 1. [snd (state x)]\\<^sub>\\<R> = snd (abss (state x))", "then"], ["proof (chain)\npicking this:\n  snd (abss (state x)) = [snd (state x)]\\<^sub>\\<R>", "show ?thesis"], ["proof (prove)\nusing this:\n  snd (abss (state x)) = [snd (state x)]\\<^sub>\\<R>\n\ngoal (1 subgoal):\n 1. [snd (state x)]\\<^sub>\\<R> = snd (abss (state x))", ".."], ["proof (state)\nthis:\n  [snd (state x)]\\<^sub>\\<R> = snd (abss (state x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x8 \\<in> sset \\<omega> \\<Longrightarrow>\n  [snd (state ?x8)]\\<^sub>\\<R> = snd (abss (state ?x8))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>MDP.MC.enabled cfg x;\n        divergent (smap (snd \\<circ> state) x)\\<rbrakk>\n       \\<Longrightarrow> \\<R>_div (smap (snd \\<circ> state) (smap absc x))", "then"], ["proof (chain)\npicking this:\n  ?x8 \\<in> sset \\<omega> \\<Longrightarrow>\n  [snd (state ?x8)]\\<^sub>\\<R> = snd (abss (state ?x8))", "have \"smap (\\<lambda>z. [snd (state z)]\\<^sub>\\<R>) \\<omega> = (smap (\\<lambda>z. snd (abss (state z))) \\<omega>)\""], ["proof (prove)\nusing this:\n  ?x8 \\<in> sset \\<omega> \\<Longrightarrow>\n  [snd (state ?x8)]\\<^sub>\\<R> = snd (abss (state ?x8))\n\ngoal (1 subgoal):\n 1. smap (\\<lambda>z. [snd (state z)]\\<^sub>\\<R>) \\<omega> =\n    smap (\\<lambda>z. snd (abss (state z))) \\<omega>", "by auto"], ["proof (state)\nthis:\n  smap (\\<lambda>z. [snd (state z)]\\<^sub>\\<R>) \\<omega> =\n  smap (\\<lambda>z. snd (abss (state z))) \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>MDP.MC.enabled cfg x;\n        divergent (smap (snd \\<circ> state) x)\\<rbrakk>\n       \\<Longrightarrow> \\<R>_div (smap (snd \\<circ> state) (smap absc x))", "from *"], ["proof (chain)\npicking this:\n  pred_stream (\\<lambda>x. x \\<in> S) (smap state \\<omega>)", "have  \"pred_stream (\\<lambda> u. u \\<in> V) ?xs\""], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>x. x \\<in> S) (smap state \\<omega>)\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>u. u \\<in> V) (smap (snd \\<circ> state) \\<omega>)", "apply (simp add: map_def stream.pred_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>sset \\<omega>. state x \\<in> S \\<Longrightarrow>\n    \\<forall>u\\<in>sset \\<omega>. snd (state u) \\<in> V", "apply (subst (asm) surjective_pairing)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>sset \\<omega>.\n       (fst (state x), snd (state x)) \\<in> S \\<Longrightarrow>\n    \\<forall>u\\<in>sset \\<omega>. snd (state u) \\<in> V", "using S_V"], ["proof (prove)\nusing this:\n  (?l, ?u) \\<in> S \\<Longrightarrow> ?u \\<in> V\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>sset \\<omega>.\n       (fst (state x), snd (state x)) \\<in> S \\<Longrightarrow>\n    \\<forall>u\\<in>sset \\<omega>. snd (state u) \\<in> V", "by blast"], ["proof (state)\nthis:\n  pred_stream (\\<lambda>u. u \\<in> V) (smap (snd \\<circ> state) \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>MDP.MC.enabled cfg x;\n        divergent (smap (snd \\<circ> state) x)\\<rbrakk>\n       \\<Longrightarrow> \\<R>_div (smap (snd \\<circ> state) (smap absc x))", "moreover"], ["proof (state)\nthis:\n  pred_stream (\\<lambda>u. u \\<in> V) (smap (snd \\<circ> state) \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>MDP.MC.enabled cfg x;\n        divergent (smap (snd \\<circ> state) x)\\<rbrakk>\n       \\<Longrightarrow> \\<R>_div (smap (snd \\<circ> state) (smap absc x))", "have \"stream_trans ?xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_trans (smap (snd \\<circ> state) \\<omega>)", "by (rule enabled_stream_trans \\<open>_ \\<in> valid_cfg\\<close> \\<open>MDP.MC.enabled _ _\\<close>)+"], ["proof (state)\nthis:\n  stream_trans (smap (snd \\<circ> state) \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>MDP.MC.enabled cfg x;\n        divergent (smap (snd \\<circ> state) x)\\<rbrakk>\n       \\<Longrightarrow> \\<R>_div (smap (snd \\<circ> state) (smap absc x))", "ultimately"], ["proof (chain)\npicking this:\n  pred_stream (\\<lambda>u. u \\<in> V) (smap (snd \\<circ> state) \\<omega>)\n  stream_trans (smap (snd \\<circ> state) \\<omega>)", "show ?case"], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>u. u \\<in> V) (smap (snd \\<circ> state) \\<omega>)\n  stream_trans (smap (snd \\<circ> state) \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<R>_div (smap (snd \\<circ> state) (smap absc \\<omega>))", "using \\<open>divergent _\\<close> \\<open>smap _ \\<omega> = _\\<close>"], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>u. u \\<in> V) (smap (snd \\<circ> state) \\<omega>)\n  stream_trans (smap (snd \\<circ> state) \\<omega>)\n  divergent (smap (snd \\<circ> state) \\<omega>)\n  smap (\\<lambda>z. [snd (state z)]\\<^sub>\\<R>) \\<omega> =\n  smap (\\<lambda>z. snd (abss (state z))) \\<omega>\n\ngoal (1 subgoal):\n 1. \\<R>_div (smap (snd \\<circ> state) (smap absc \\<omega>))", "by - (drule divergent_\\<R>_divergent, auto simp add: stream.map_comp state_absc)"], ["proof (state)\nthis:\n  \\<R>_div (smap (snd \\<circ> state) (smap absc \\<omega>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  AE x in MDP.MC.T cfg. \\<R>_div (smap (snd \\<circ> state) (smap absc x))\n\ngoal (1 subgoal):\n 1. absc cfg \\<in> R_G_cfg_on_div (abss st)", "with \\<open>cfg \\<in> valid_cfg\\<close>"], ["proof (chain)\npicking this:\n  cfg \\<in> MDP.valid_cfg\n  AE x in MDP.MC.T cfg. \\<R>_div (smap (snd \\<circ> state) (smap absc x))", "have \"R_G_div_cfg (absc cfg)\""], ["proof (prove)\nusing this:\n  cfg \\<in> MDP.valid_cfg\n  AE x in MDP.MC.T cfg. \\<R>_div (smap (snd \\<circ> state) (smap absc x))\n\ngoal (1 subgoal):\n 1. R_G_div_cfg (absc cfg)", "unfolding R_G_div_cfg_def"], ["proof (prove)\nusing this:\n  cfg \\<in> MDP.valid_cfg\n  AE x in MDP.MC.T cfg. \\<R>_div (smap (snd \\<circ> state) (smap absc x))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (absc cfg). \\<R>_div (smap (snd \\<circ> state) \\<omega>)", "by (subst absc_distr_self) (auto intro: MDP.valid_cfgI simp: AE_distr_iff)"], ["proof (state)\nthis:\n  R_G_div_cfg (absc cfg)\n\ngoal (1 subgoal):\n 1. absc cfg \\<in> R_G_cfg_on_div (abss st)", "with R_G.valid_cfgD \\<open>cfg \\<in> valid_cfg\\<close> *"], ["proof (chain)\npicking this:\n  ?cfg \\<in> R_G.valid_cfg \\<Longrightarrow>\n  ?cfg \\<in> R_G.cfg_on (state ?cfg)\n  cfg \\<in> MDP.valid_cfg\n  cfg \\<in> MDP.cfg_on st\n  state cfg = st\n  div_cfg cfg\n  R_G_div_cfg (absc cfg)", "show ?thesis"], ["proof (prove)\nusing this:\n  ?cfg \\<in> R_G.valid_cfg \\<Longrightarrow>\n  ?cfg \\<in> R_G.cfg_on (state ?cfg)\n  cfg \\<in> MDP.valid_cfg\n  cfg \\<in> MDP.cfg_on st\n  state cfg = st\n  div_cfg cfg\n  R_G_div_cfg (absc cfg)\n\ngoal (1 subgoal):\n 1. absc cfg \\<in> R_G_cfg_on_div (abss st)", "unfolding R_G_cfg_on_div_def"], ["proof (prove)\nusing this:\n  ?cfg \\<in> R_G.valid_cfg \\<Longrightarrow>\n  ?cfg \\<in> R_G.cfg_on (state ?cfg)\n  cfg \\<in> MDP.valid_cfg\n  cfg \\<in> MDP.cfg_on st\n  state cfg = st\n  div_cfg cfg\n  R_G_div_cfg (absc cfg)\n\ngoal (1 subgoal):\n 1. absc cfg \\<in> R_G.cfg_on (abss st) \\<inter> Collect R_G_div_cfg", "by auto force"], ["proof (state)\nthis:\n  absc cfg \\<in> R_G_cfg_on_div (abss st)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  \"alternating cfg = (AE \\<omega> in MDP.MC.T cfg.\n      alw (ev (HLD {cfg. \\<forall>cfg' \\<in> K_cfg cfg. fst (state cfg') = fst (state cfg)})) \\<omega>)\""], ["", "lemma K_cfg_same_loc_iff:\n  \"(\\<forall>cfg'\\<in> K_cfg cfg. fst (state cfg') = fst (state cfg))\n  \\<longleftrightarrow> (\\<forall>cfg'\\<in> K_cfg (absc cfg). fst (state cfg') = fst (state (absc cfg)))\"\n  if \"cfg \\<in> valid_cfg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n        fst (state cfg') = fst (state cfg)) =\n    (\\<forall>cfg'\\<in>set_pmf (K_cfg (absc cfg)).\n        fst (state cfg') = fst (state (absc cfg)))", "using that"], ["proof (prove)\nusing this:\n  cfg \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. (\\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n        fst (state cfg') = fst (state cfg)) =\n    (\\<forall>cfg'\\<in>set_pmf (K_cfg (absc cfg)).\n        fst (state cfg') = fst (state (absc cfg)))", "by (auto simp: state_absc fst_abss K_cfg_map_absc)"], ["", "lemma (in -) stream_all2_flip:\n  \"stream_all2 (\\<lambda>a b. R b a) xs ys = stream_all2 R ys xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_all2 (\\<lambda>a b. R b a) xs ys = stream_all2 R ys xs", "by (standard; coinduction arbitrary: xs ys; auto dest: sym)"], ["", "(* TODO: Lots of duplication here, e.g. with path_measure_eq_repcs1_new *)"], ["", "lemma AE_alw_ev_same_loc_iff:\n  assumes \"cfg \\<in> valid_cfg\"\n  shows \"alternating cfg \\<longleftrightarrow> alternating (absc cfg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alternating cfg = alternating (absc cfg)", "unfolding alternating_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_everywhere (MDP.MC.T cfg)\n     (infs\n       {cfg.\n        \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n           fst (state cfg') = fst (state cfg)}) =\n    almost_everywhere (MDP.MC.T (absc cfg))\n     (infs\n       {cfg.\n        \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n           fst (state cfg') = fst (state cfg)})", "apply (simp add: MDP.MC.T.AE_iff_emeasure_eq_1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (emeasure (MDP.MC.T cfg)\n      {x \\<in> space (stream_space (count_space UNIV)).\n       infs\n        {cfg.\n         \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n            fst (state cfg') = fst (state cfg)}\n        x} =\n     1) =\n    (emeasure (MDP.MC.T (absc cfg))\n      {x \\<in> space (stream_space (count_space UNIV)).\n       infs\n        {cfg.\n         \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n            fst (state cfg') = fst (state cfg)}\n        x} =\n     1)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (emeasure (MDP.MC.T cfg)\n      {x \\<in> space (stream_space (count_space UNIV)).\n       infs\n        {cfg.\n         \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n            fst (state cfg') = fst (state cfg)}\n        x} =\n     1) =\n    (emeasure (MDP.MC.T (absc cfg))\n      {x \\<in> space (stream_space (count_space UNIV)).\n       infs\n        {cfg.\n         \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n            fst (state cfg') = fst (state cfg)}\n        x} =\n     1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (emeasure (MDP.MC.T cfg)\n      {x \\<in> space (stream_space (count_space UNIV)).\n       infs\n        {cfg.\n         \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n            fst (state cfg') = fst (state cfg)}\n        x} =\n     1) =\n    (emeasure (MDP.MC.T (absc cfg))\n      {x \\<in> space (stream_space (count_space UNIV)).\n       infs\n        {cfg.\n         \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n            fst (state cfg') = fst (state cfg)}\n        x} =\n     1)", "show ?thesis (is \"(?x = 1) = (?y = 1)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (emeasure (MDP.MC.T cfg)\n      {x \\<in> space (stream_space (count_space UNIV)).\n       infs\n        {cfg.\n         \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n            fst (state cfg') = fst (state cfg)}\n        x} =\n     1) =\n    (emeasure (MDP.MC.T (absc cfg))\n      {x \\<in> space (stream_space (count_space UNIV)).\n       infs\n        {cfg.\n         \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n            fst (state cfg') = fst (state cfg)}\n        x} =\n     1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (emeasure (MDP.MC.T cfg)\n      {x \\<in> space (stream_space (count_space UNIV)).\n       infs\n        {cfg.\n         \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n            fst (state cfg') = fst (state cfg)}\n        x} =\n     1) =\n    (emeasure (MDP.MC.T (absc cfg))\n      {x \\<in> space (stream_space (count_space UNIV)).\n       infs\n        {cfg.\n         \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n            fst (state cfg') = fst (state cfg)}\n        x} =\n     1)", "have *: \"stream_all2 (\\<lambda>s t. t = absc s) x y = stream_all2 (=) y (smap absc x)\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_all2 (\\<lambda>s t. t = absc s) x y =\n    stream_all2 (=) y (smap absc x)", "by (subst stream_all2_flip) simp"], ["proof (state)\nthis:\n  stream_all2 (\\<lambda>s t. t = absc s) ?x8 ?y8 =\n  stream_all2 (=) ?y8 (smap absc ?x8)\n\ngoal (1 subgoal):\n 1. (emeasure (MDP.MC.T cfg)\n      {x \\<in> space (stream_space (count_space UNIV)).\n       infs\n        {cfg.\n         \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n            fst (state cfg') = fst (state cfg)}\n        x} =\n     1) =\n    (emeasure (MDP.MC.T (absc cfg))\n      {x \\<in> space (stream_space (count_space UNIV)).\n       infs\n        {cfg.\n         \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n            fst (state cfg') = fst (state cfg)}\n        x} =\n     1)", "have \"?x = ?y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (MDP.MC.T cfg)\n     {x \\<in> space (stream_space (count_space UNIV)).\n      infs\n       {cfg.\n        \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n           fst (state cfg') = fst (state cfg)}\n       x} =\n    emeasure (MDP.MC.T (absc cfg))\n     {x \\<in> space (stream_space (count_space UNIV)).\n      infs\n       {cfg.\n        \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n           fst (state cfg') = fst (state cfg)}\n       x}", "apply (rule T_eq_rel_half[where f = absc and S = valid_cfg, OF HOL.refl, rotated 2])"], ["proof (prove)\ngoal (5 subgoals):\n 1. PTA.rel_set_strong\n     (stream_all2 (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t))\n     {x \\<in> space (stream_space (count_space UNIV)).\n      infs\n       {cfg.\n        \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n           fst (state cfg') = fst (state cfg)}\n       x}\n     {x \\<in> space (stream_space (count_space UNIV)).\n      infs\n       {cfg.\n        \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n           fst (state cfg') = fst (state cfg)}\n       x}\n 2. rel_fun (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t)\n     (rel_pmf (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t)) K_cfg\n     K_cfg\n 3. cfg \\<in> MDP.valid_cfg \\<and> absc cfg = absc cfg\n 4. {x \\<in> space (stream_space (count_space UNIV)).\n     infs\n      {cfg.\n       \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n          fst (state cfg') = fst (state cfg)}\n      x}\n    \\<in> sets (stream_space (count_space UNIV))\n 5. {x \\<in> space (stream_space (count_space UNIV)).\n     infs\n      {cfg.\n       \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n          fst (state cfg') = fst (state cfg)}\n      x}\n    \\<in> sets (stream_space (count_space UNIV))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. PTA.rel_set_strong\n     (stream_all2 (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t))\n     {x \\<in> space (stream_space (count_space UNIV)).\n      infs\n       {cfg.\n        \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n           fst (state cfg') = fst (state cfg)}\n       x}\n     {x \\<in> space (stream_space (count_space UNIV)).\n      infs\n       {cfg.\n        \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n           fst (state cfg') = fst (state cfg)}\n       x}", "apply (simp add: space_stream_space rel_set_strong_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       stream_all2 (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t) x\n        y \\<longrightarrow>\n       infs\n        {cfg.\n         \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n            fst (state cfg') = fst (state cfg)}\n        x =\n       infs\n        {cfg.\n         \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n            fst (state cfg') = fst (state cfg)}\n        y", "apply (intro allI impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stream_all2 (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t) x\n        y \\<Longrightarrow>\n       infs\n        {cfg.\n         \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n            fst (state cfg') = fst (state cfg)}\n        x =\n       infs\n        {cfg.\n         \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n            fst (state cfg') = fst (state cfg)}\n        y", "apply (frule stream.rel_mono_strong[where Ra = \"\\<lambda>s t. t = absc s\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z yb.\n       \\<lbrakk>stream_all2\n                 (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t) x\n                 y;\n        z \\<in> sset x; yb \\<in> sset y;\n        z \\<in> MDP.valid_cfg \\<and> absc z = yb\\<rbrakk>\n       \\<Longrightarrow> yb = absc z\n 2. \\<And>x y.\n       \\<lbrakk>stream_all2\n                 (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t) x\n                 y;\n        stream_all2 (\\<lambda>s t. t = absc s) x y\\<rbrakk>\n       \\<Longrightarrow> infs\n                          {cfg.\n                           \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n                              fst (state cfg') = fst (state cfg)}\n                          x =\n                         infs\n                          {cfg.\n                           \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n                              fst (state cfg') = fst (state cfg)}\n                          y", "by (auto simp: * stream.rel_eq stream_all2_refl alw_holds_pred_stream_iff[symmetric]\n              K_cfg_same_loc_iff HLD_def elim!: alw_ev_cong)"], ["proof (prove)\ngoal (4 subgoals):\n 1. rel_fun (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t)\n     (rel_pmf (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t)) K_cfg\n     K_cfg\n 2. cfg \\<in> MDP.valid_cfg \\<and> absc cfg = absc cfg\n 3. {x \\<in> space (stream_space (count_space UNIV)).\n     infs\n      {cfg.\n       \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n          fst (state cfg') = fst (state cfg)}\n      x}\n    \\<in> sets (stream_space (count_space UNIV))\n 4. {x \\<in> space (stream_space (count_space UNIV)).\n     infs\n      {cfg.\n       \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n          fst (state cfg') = fst (state cfg)}\n      x}\n    \\<in> sets (stream_space (count_space UNIV))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t)\n     (rel_pmf (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t)) K_cfg\n     K_cfg", "by (rule rel_funI) (auto intro!: rel_pmf_reflI simp: pmf.rel_map(2) K_cfg_map_absc)"], ["proof (prove)\ngoal (3 subgoals):\n 1. cfg \\<in> MDP.valid_cfg \\<and> absc cfg = absc cfg\n 2. {x \\<in> space (stream_space (count_space UNIV)).\n     infs\n      {cfg.\n       \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n          fst (state cfg') = fst (state cfg)}\n      x}\n    \\<in> sets (stream_space (count_space UNIV))\n 3. {x \\<in> space (stream_space (count_space UNIV)).\n     infs\n      {cfg.\n       \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n          fst (state cfg') = fst (state cfg)}\n      x}\n    \\<in> sets (stream_space (count_space UNIV))", "using \\<open>cfg \\<in> valid_cfg\\<close>"], ["proof (prove)\nusing this:\n  cfg \\<in> MDP.valid_cfg\n\ngoal (3 subgoals):\n 1. cfg \\<in> MDP.valid_cfg \\<and> absc cfg = absc cfg\n 2. {x \\<in> space (stream_space (count_space UNIV)).\n     infs\n      {cfg.\n       \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n          fst (state cfg') = fst (state cfg)}\n      x}\n    \\<in> sets (stream_space (count_space UNIV))\n 3. {x \\<in> space (stream_space (count_space UNIV)).\n     infs\n      {cfg.\n       \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n          fst (state cfg') = fst (state cfg)}\n      x}\n    \\<in> sets (stream_space (count_space UNIV))", "by simp+"], ["proof (state)\nthis:\n  emeasure (MDP.MC.T cfg)\n   {x \\<in> space (stream_space (count_space UNIV)).\n    infs\n     {cfg.\n      \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n         fst (state cfg') = fst (state cfg)}\n     x} =\n  emeasure (MDP.MC.T (absc cfg))\n   {x \\<in> space (stream_space (count_space UNIV)).\n    infs\n     {cfg.\n      \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n         fst (state cfg') = fst (state cfg)}\n     x}\n\ngoal (1 subgoal):\n 1. (emeasure (MDP.MC.T cfg)\n      {x \\<in> space (stream_space (count_space UNIV)).\n       infs\n        {cfg.\n         \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n            fst (state cfg') = fst (state cfg)}\n        x} =\n     1) =\n    (emeasure (MDP.MC.T (absc cfg))\n      {x \\<in> space (stream_space (count_space UNIV)).\n       infs\n        {cfg.\n         \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n            fst (state cfg') = fst (state cfg)}\n        x} =\n     1)", "then"], ["proof (chain)\npicking this:\n  emeasure (MDP.MC.T cfg)\n   {x \\<in> space (stream_space (count_space UNIV)).\n    infs\n     {cfg.\n      \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n         fst (state cfg') = fst (state cfg)}\n     x} =\n  emeasure (MDP.MC.T (absc cfg))\n   {x \\<in> space (stream_space (count_space UNIV)).\n    infs\n     {cfg.\n      \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n         fst (state cfg') = fst (state cfg)}\n     x}", "show ?thesis"], ["proof (prove)\nusing this:\n  emeasure (MDP.MC.T cfg)\n   {x \\<in> space (stream_space (count_space UNIV)).\n    infs\n     {cfg.\n      \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n         fst (state cfg') = fst (state cfg)}\n     x} =\n  emeasure (MDP.MC.T (absc cfg))\n   {x \\<in> space (stream_space (count_space UNIV)).\n    infs\n     {cfg.\n      \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n         fst (state cfg') = fst (state cfg)}\n     x}\n\ngoal (1 subgoal):\n 1. (emeasure (MDP.MC.T cfg)\n      {x \\<in> space (stream_space (count_space UNIV)).\n       infs\n        {cfg.\n         \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n            fst (state cfg') = fst (state cfg)}\n        x} =\n     1) =\n    (emeasure (MDP.MC.T (absc cfg))\n      {x \\<in> space (stream_space (count_space UNIV)).\n       infs\n        {cfg.\n         \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n            fst (state cfg') = fst (state cfg)}\n        x} =\n     1)", "by simp"], ["proof (state)\nthis:\n  (emeasure (MDP.MC.T cfg)\n    {x \\<in> space (stream_space (count_space UNIV)).\n     infs\n      {cfg.\n       \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n          fst (state cfg') = fst (state cfg)}\n      x} =\n   1) =\n  (emeasure (MDP.MC.T (absc cfg))\n    {x \\<in> space (stream_space (count_space UNIV)).\n     infs\n      {cfg.\n       \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n          fst (state cfg') = fst (state cfg)}\n      x} =\n   1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (emeasure (MDP.MC.T cfg)\n    {x \\<in> space (stream_space (count_space UNIV)).\n     infs\n      {cfg.\n       \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n          fst (state cfg') = fst (state cfg)}\n      x} =\n   1) =\n  (emeasure (MDP.MC.T (absc cfg))\n    {x \\<in> space (stream_space (count_space UNIV)).\n     infs\n      {cfg.\n       \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n          fst (state cfg') = fst (state cfg)}\n      x} =\n   1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma AE_alw_ev_same_loc_iff':\n  assumes \"cfg \\<in> R_G.cfg_on (abss st)\" \"st \\<in> S\"\n  shows \"alternating cfg \\<longleftrightarrow> alternating (repcs st cfg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alternating cfg = alternating (repcs st cfg)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. alternating cfg = alternating (repcs st cfg)", "from assms"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.cfg_on (abss st)\n  st \\<in> S", "have \"cfg \\<in> R_G.valid_cfg\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.cfg_on (abss st)\n  st \\<in> S\n\ngoal (1 subgoal):\n 1. cfg \\<in> R_G.valid_cfg", "by (auto intro: R_G.valid_cfgI)"], ["proof (state)\nthis:\n  cfg \\<in> R_G.valid_cfg\n\ngoal (1 subgoal):\n 1. alternating cfg = alternating (repcs st cfg)", "with assms"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.cfg_on (abss st)\n  st \\<in> S\n  cfg \\<in> R_G.valid_cfg", "show ?thesis"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.cfg_on (abss st)\n  st \\<in> S\n  cfg \\<in> R_G.valid_cfg\n\ngoal (1 subgoal):\n 1. alternating cfg = alternating (repcs st cfg)", "by (subst AE_alw_ev_same_loc_iff) (auto simp: absc_repcs_id)"], ["proof (state)\nthis:\n  alternating cfg = alternating (repcs st cfg)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in -) cval_add_non_id:\n  False if \"b \\<oplus> d = b\" \"d > 0\" for d :: real"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "from that(1)"], ["proof (chain)\npicking this:\n  b \\<oplus> d = b", "have \"(b \\<oplus> d) x = b x\""], ["proof (prove)\nusing this:\n  b \\<oplus> d = b\n\ngoal (1 subgoal):\n 1. (b \\<oplus> d) x = b x", "by (rule fun_cong)"], ["proof (state)\nthis:\n  (b \\<oplus> d) x = b x\n\ngoal (1 subgoal):\n 1. False", "with \\<open>d > 0\\<close>"], ["proof (chain)\npicking this:\n  0 < d\n  (b \\<oplus> d) x = b x", "show False"], ["proof (prove)\nusing this:\n  0 < d\n  (b \\<oplus> d) x = b x\n\ngoal (1 subgoal):\n 1. False", "unfolding cval_add_def"], ["proof (prove)\nusing this:\n  0 < d\n  b x + d = b x\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma repcs_unbounded_AE_non_loop_end_strong:\n  assumes \"cfg \\<in> R_G.cfg_on (abss st)\" \"st \\<in> S\"\n    and \"alternating cfg\"\n  shows \"AE \\<omega> in MDP.MC.T (repcs st cfg).\n      (\\<forall> u :: ('c \\<Rightarrow> real). (\\<forall> c \\<in> \\<X>. u c > real (k c)) \\<longrightarrow>\n      \\<not> (ev (alw (\\<lambda> xs. shd xs = u))) (smap (snd o state) \\<omega>))\" (is \"AE \\<omega> in ?M. ?P \\<omega>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "from assms"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.cfg_on (abss st)\n  st \\<in> S\n  alternating cfg", "have \"cfg \\<in> R_G.valid_cfg\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.cfg_on (abss st)\n  st \\<in> S\n  alternating cfg\n\ngoal (1 subgoal):\n 1. cfg \\<in> R_G.valid_cfg", "by (auto intro: R_G.valid_cfgI)"], ["proof (state)\nthis:\n  cfg \\<in> R_G.valid_cfg\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "with assms(1)"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.cfg_on (abss st)\n  cfg \\<in> R_G.valid_cfg", "have \"repcs st cfg \\<in> valid_cfg\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.cfg_on (abss st)\n  cfg \\<in> R_G.valid_cfg\n\ngoal (1 subgoal):\n 1. repcs st cfg \\<in> MDP.valid_cfg", "by auto"], ["proof (state)\nthis:\n  repcs st cfg \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "from R_G.valid_cfgD[OF \\<open>cfg \\<in> R_G.valid_cfg\\<close>]"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.cfg_on (state cfg)", "have \"cfg \\<in> R_G.cfg_on (state cfg)\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.cfg_on (state cfg)\n\ngoal (1 subgoal):\n 1. cfg \\<in> R_G.cfg_on (state cfg)", "."], ["proof (state)\nthis:\n  cfg \\<in> R_G.cfg_on (state cfg)\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "let ?U = \"\\<lambda> u. \\<Union> l \\<in> L. {\\<mu> \\<in> K (l, u). \\<mu> \\<noteq> return_pmf (l, u) \\<and> (\\<forall> x \\<in> \\<mu>. fst x = l)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "let ?r = \"\\<lambda> u. Sup ({0} \\<union> (\\<lambda> \\<mu>. measure_pmf \\<mu> {x. snd x = u}) ` ?U u)\""], ["proof (state)\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "have lt_1: \"?r u < 1\" for u"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> ({0} \\<union>\n                (\\<lambda>\\<mu>.\n                    emeasure (measure_pmf \\<mu>) {x. snd x = u}) `\n                (\\<Union>l\\<in>L.\n                    {\\<mu> \\<in> K (l, u).\n                     \\<mu> \\<noteq> return_pmf (l, u) \\<and>\n                     (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)}))\n    < 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Squnion> ({0} \\<union>\n                (\\<lambda>\\<mu>.\n                    emeasure (measure_pmf \\<mu>) {x. snd x = u}) `\n                (\\<Union>l\\<in>L.\n                    {\\<mu> \\<in> K (l, u).\n                     \\<mu> \\<noteq> return_pmf (l, u) \\<and>\n                     (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)}))\n    < 1", "have *: \"emeasure (measure_pmf \\<mu>) {x. snd x = u} < 1\"\n      if \"\\<mu> \\<noteq> return_pmf (l, u)\" \"\\<forall>x\\<in>set_pmf \\<mu>. fst x = l\" for \\<mu> and l :: 's"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (measure_pmf \\<mu>) {x. snd x = u} < 1", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> emeasure (measure_pmf \\<mu>) {x. snd x = u} < 1 \\<Longrightarrow>\n    False", "assume \"\\<not> emeasure (measure_pmf \\<mu>) {x. snd x = u} < 1\""], ["proof (state)\nthis:\n  \\<not> emeasure (measure_pmf \\<mu>) {x. snd x = u} < 1\n\ngoal (1 subgoal):\n 1. \\<not> emeasure (measure_pmf \\<mu>) {x. snd x = u} < 1 \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> emeasure (measure_pmf \\<mu>) {x. snd x = u} < 1", "have \"1 = emeasure (measure_pmf \\<mu>) {x. snd x = u}\""], ["proof (prove)\nusing this:\n  \\<not> emeasure (measure_pmf \\<mu>) {x. snd x = u} < 1\n\ngoal (1 subgoal):\n 1. 1 = emeasure (measure_pmf \\<mu>) {x. snd x = u}", "using measure_pmf.emeasure_ge_1_iff"], ["proof (prove)\nusing this:\n  \\<not> emeasure (measure_pmf \\<mu>) {x. snd x = u} < 1\n  (1 \\<le> emeasure (measure_pmf ?M) ?A) =\n  (emeasure (measure_pmf ?M) ?A = 1)\n\ngoal (1 subgoal):\n 1. 1 = emeasure (measure_pmf \\<mu>) {x. snd x = u}", "by force"], ["proof (state)\nthis:\n  1 = emeasure (measure_pmf \\<mu>) {x. snd x = u}\n\ngoal (1 subgoal):\n 1. \\<not> emeasure (measure_pmf \\<mu>) {x. snd x = u} < 1 \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  1 = emeasure (measure_pmf \\<mu>) {x. snd x = u}\n\ngoal (1 subgoal):\n 1. \\<not> emeasure (measure_pmf \\<mu>) {x. snd x = u} < 1 \\<Longrightarrow>\n    False", "from that(2)"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set_pmf \\<mu>. fst x = l", "have \"\\<dots> \\<le> emeasure (measure_pmf \\<mu>) {(l, u)}\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set_pmf \\<mu>. fst x = l\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf \\<mu>) {x. snd x = u}\n    \\<le> emeasure (measure_pmf \\<mu>) {(l, u)}", "by (subst emeasure_Int_set_pmf[symmetric]) (auto intro!: emeasure_mono)"], ["proof (state)\nthis:\n  emeasure (measure_pmf \\<mu>) {x. snd x = u}\n  \\<le> emeasure (measure_pmf \\<mu>) {(l, u)}\n\ngoal (1 subgoal):\n 1. \\<not> emeasure (measure_pmf \\<mu>) {x. snd x = u} < 1 \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  1 \\<le> emeasure (measure_pmf \\<mu>) {(l, u)}", "show False"], ["proof (prove)\nusing this:\n  1 \\<le> emeasure (measure_pmf \\<mu>) {(l, u)}\n\ngoal (1 subgoal):\n 1. False", "by (simp add: measure_pmf.emeasure_ge_1_iff measure_pmf_eq_1_iff that(1))"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?\\<mu>8 \\<noteq> return_pmf (?l8, u);\n   \\<forall>x\\<in>set_pmf ?\\<mu>8. fst x = ?l8\\<rbrakk>\n  \\<Longrightarrow> emeasure (measure_pmf ?\\<mu>8) {x. snd x = u} < 1\n\ngoal (1 subgoal):\n 1. \\<Squnion> ({0} \\<union>\n                (\\<lambda>\\<mu>.\n                    emeasure (measure_pmf \\<mu>) {x. snd x = u}) `\n                (\\<Union>l\\<in>L.\n                    {\\<mu> \\<in> K (l, u).\n                     \\<mu> \\<noteq> return_pmf (l, u) \\<and>\n                     (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)}))\n    < 1", "let ?S =\n      \"{map_pmf (\\<lambda> (X, l). (l, ([X := 0]u))) \\<mu> | \\<mu> l g. (l, g, \\<mu>) \\<in> trans_of A}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Squnion> ({0} \\<union>\n                (\\<lambda>\\<mu>.\n                    emeasure (measure_pmf \\<mu>) {x. snd x = u}) `\n                (\\<Union>l\\<in>L.\n                    {\\<mu> \\<in> K (l, u).\n                     \\<mu> \\<noteq> return_pmf (l, u) \\<and>\n                     (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)}))\n    < 1", "have \"(\\<lambda> \\<mu>. measure_pmf \\<mu> {x. snd x = u}) ` ?U u\n      \\<subseteq> {0, 1} \\<union> (\\<lambda> \\<mu>. measure_pmf \\<mu> {x. snd x = u}) ` ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>\\<mu>. emeasure (measure_pmf \\<mu>) {x. snd x = u}) `\n    (\\<Union>l\\<in>L.\n        {\\<mu> \\<in> K (l, u).\n         \\<mu> \\<noteq> return_pmf (l, u) \\<and>\n         (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)})\n    \\<subseteq> {0, 1} \\<union>\n                (\\<lambda>\\<mu>.\n                    emeasure (measure_pmf \\<mu>) {x. snd x = u}) `\n                {uu_.\n                 \\<exists>\\<mu> l g.\n                    uu_ =\n                    map_pmf\n                     (\\<lambda>(X, l).\n                         (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n                     \\<mu> \\<and>\n                    (l, g, \\<mu>) \\<in> PTA.trans_of A}", "by (force elim!: K.cases)"], ["proof (state)\nthis:\n  (\\<lambda>\\<mu>. emeasure (measure_pmf \\<mu>) {x. snd x = u}) `\n  (\\<Union>l\\<in>L.\n      {\\<mu> \\<in> K (l, u).\n       \\<mu> \\<noteq> return_pmf (l, u) \\<and>\n       (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)})\n  \\<subseteq> {0, 1} \\<union>\n              (\\<lambda>\\<mu>.\n                  emeasure (measure_pmf \\<mu>) {x. snd x = u}) `\n              {uu_.\n               \\<exists>\\<mu> l g.\n                  uu_ =\n                  map_pmf\n                   (\\<lambda>(X, l).\n                       (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n                   \\<mu> \\<and>\n                  (l, g, \\<mu>) \\<in> PTA.trans_of A}\n\ngoal (1 subgoal):\n 1. \\<Squnion> ({0} \\<union>\n                (\\<lambda>\\<mu>.\n                    emeasure (measure_pmf \\<mu>) {x. snd x = u}) `\n                (\\<Union>l\\<in>L.\n                    {\\<mu> \\<in> K (l, u).\n                     \\<mu> \\<noteq> return_pmf (l, u) \\<and>\n                     (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)}))\n    < 1", "moreover"], ["proof (state)\nthis:\n  (\\<lambda>\\<mu>. emeasure (measure_pmf \\<mu>) {x. snd x = u}) `\n  (\\<Union>l\\<in>L.\n      {\\<mu> \\<in> K (l, u).\n       \\<mu> \\<noteq> return_pmf (l, u) \\<and>\n       (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)})\n  \\<subseteq> {0, 1} \\<union>\n              (\\<lambda>\\<mu>.\n                  emeasure (measure_pmf \\<mu>) {x. snd x = u}) `\n              {uu_.\n               \\<exists>\\<mu> l g.\n                  uu_ =\n                  map_pmf\n                   (\\<lambda>(X, l).\n                       (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n                   \\<mu> \\<and>\n                  (l, g, \\<mu>) \\<in> PTA.trans_of A}\n\ngoal (1 subgoal):\n 1. \\<Squnion> ({0} \\<union>\n                (\\<lambda>\\<mu>.\n                    emeasure (measure_pmf \\<mu>) {x. snd x = u}) `\n                (\\<Union>l\\<in>L.\n                    {\\<mu> \\<in> K (l, u).\n                     \\<mu> \\<noteq> return_pmf (l, u) \\<and>\n                     (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)}))\n    < 1", "have \"finite ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {uu_.\n      \\<exists>\\<mu> l g.\n         uu_ =\n         map_pmf\n          (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n          \\<mu> \\<and>\n         (l, g, \\<mu>) \\<in> PTA.trans_of A}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     {uu_.\n      \\<exists>\\<mu> l g.\n         uu_ =\n         map_pmf\n          (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n          \\<mu> \\<and>\n         (l, g, \\<mu>) \\<in> PTA.trans_of A}", "have \"?S \\<subseteq> (\\<lambda> (l, g, \\<mu>). map_pmf (\\<lambda> (X, l). (l, ([X := 0]u))) \\<mu>) ` trans_of A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {uu_.\n     \\<exists>\\<mu> l g.\n        uu_ =\n        map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n         \\<mu> \\<and>\n        (l, g, \\<mu>) \\<in> PTA.trans_of A}\n    \\<subseteq> (\\<lambda>(l, g, \\<mu>).\n                    map_pmf\n                     (\\<lambda>(X, l).\n                         (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n                     \\<mu>) `\n                PTA.trans_of A", "by force"], ["proof (state)\nthis:\n  {uu_.\n   \\<exists>\\<mu> l g.\n      uu_ =\n      map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n       \\<mu> \\<and>\n      (l, g, \\<mu>) \\<in> PTA.trans_of A}\n  \\<subseteq> (\\<lambda>(l, g, \\<mu>).\n                  map_pmf\n                   (\\<lambda>(X, l).\n                       (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n                   \\<mu>) `\n              PTA.trans_of A\n\ngoal (1 subgoal):\n 1. finite\n     {uu_.\n      \\<exists>\\<mu> l g.\n         uu_ =\n         map_pmf\n          (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n          \\<mu> \\<and>\n         (l, g, \\<mu>) \\<in> PTA.trans_of A}", "also"], ["proof (state)\nthis:\n  {uu_.\n   \\<exists>\\<mu> l g.\n      uu_ =\n      map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n       \\<mu> \\<and>\n      (l, g, \\<mu>) \\<in> PTA.trans_of A}\n  \\<subseteq> (\\<lambda>(l, g, \\<mu>).\n                  map_pmf\n                   (\\<lambda>(X, l).\n                       (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n                   \\<mu>) `\n              PTA.trans_of A\n\ngoal (1 subgoal):\n 1. finite\n     {uu_.\n      \\<exists>\\<mu> l g.\n         uu_ =\n         map_pmf\n          (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n          \\<mu> \\<and>\n         (l, g, \\<mu>) \\<in> PTA.trans_of A}", "from finite(3)"], ["proof (chain)\npicking this:\n  finite (PTA.trans_of A)", "have \"finite \\<dots>\""], ["proof (prove)\nusing this:\n  finite (PTA.trans_of A)\n\ngoal (1 subgoal):\n 1. finite\n     ((\\<lambda>(l, g, \\<mu>).\n          map_pmf\n           (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n           \\<mu>) `\n      PTA.trans_of A)", ".."], ["proof (state)\nthis:\n  finite\n   ((\\<lambda>(l, g, \\<mu>).\n        map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n         \\<mu>) `\n    PTA.trans_of A)\n\ngoal (1 subgoal):\n 1. finite\n     {uu_.\n      \\<exists>\\<mu> l g.\n         uu_ =\n         map_pmf\n          (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n          \\<mu> \\<and>\n         (l, g, \\<mu>) \\<in> PTA.trans_of A}", "finally"], ["proof (chain)\npicking this:\n  finite\n   {uu_.\n    \\<exists>\\<mu> l g.\n       uu_ =\n       map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n        \\<mu> \\<and>\n       (l, g, \\<mu>) \\<in> PTA.trans_of A}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite\n   {uu_.\n    \\<exists>\\<mu> l g.\n       uu_ =\n       map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n        \\<mu> \\<and>\n       (l, g, \\<mu>) \\<in> PTA.trans_of A}\n\ngoal (1 subgoal):\n 1. finite\n     {uu_.\n      \\<exists>\\<mu> l g.\n         uu_ =\n         map_pmf\n          (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n          \\<mu> \\<and>\n         (l, g, \\<mu>) \\<in> PTA.trans_of A}", "."], ["proof (state)\nthis:\n  finite\n   {uu_.\n    \\<exists>\\<mu> l g.\n       uu_ =\n       map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n        \\<mu> \\<and>\n       (l, g, \\<mu>) \\<in> PTA.trans_of A}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite\n   {uu_.\n    \\<exists>\\<mu> l g.\n       uu_ =\n       map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n        \\<mu> \\<and>\n       (l, g, \\<mu>) \\<in> PTA.trans_of A}\n\ngoal (1 subgoal):\n 1. \\<Squnion> ({0} \\<union>\n                (\\<lambda>\\<mu>.\n                    emeasure (measure_pmf \\<mu>) {x. snd x = u}) `\n                (\\<Union>l\\<in>L.\n                    {\\<mu> \\<in> K (l, u).\n                     \\<mu> \\<noteq> return_pmf (l, u) \\<and>\n                     (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)}))\n    < 1", "ultimately"], ["proof (chain)\npicking this:\n  (\\<lambda>\\<mu>. emeasure (measure_pmf \\<mu>) {x. snd x = u}) `\n  (\\<Union>l\\<in>L.\n      {\\<mu> \\<in> K (l, u).\n       \\<mu> \\<noteq> return_pmf (l, u) \\<and>\n       (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)})\n  \\<subseteq> {0, 1} \\<union>\n              (\\<lambda>\\<mu>.\n                  emeasure (measure_pmf \\<mu>) {x. snd x = u}) `\n              {uu_.\n               \\<exists>\\<mu> l g.\n                  uu_ =\n                  map_pmf\n                   (\\<lambda>(X, l).\n                       (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n                   \\<mu> \\<and>\n                  (l, g, \\<mu>) \\<in> PTA.trans_of A}\n  finite\n   {uu_.\n    \\<exists>\\<mu> l g.\n       uu_ =\n       map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n        \\<mu> \\<and>\n       (l, g, \\<mu>) \\<in> PTA.trans_of A}", "have \"finite ((\\<lambda> \\<mu>. measure_pmf \\<mu> {x. snd x = u}) ` ?U u)\""], ["proof (prove)\nusing this:\n  (\\<lambda>\\<mu>. emeasure (measure_pmf \\<mu>) {x. snd x = u}) `\n  (\\<Union>l\\<in>L.\n      {\\<mu> \\<in> K (l, u).\n       \\<mu> \\<noteq> return_pmf (l, u) \\<and>\n       (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)})\n  \\<subseteq> {0, 1} \\<union>\n              (\\<lambda>\\<mu>.\n                  emeasure (measure_pmf \\<mu>) {x. snd x = u}) `\n              {uu_.\n               \\<exists>\\<mu> l g.\n                  uu_ =\n                  map_pmf\n                   (\\<lambda>(X, l).\n                       (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n                   \\<mu> \\<and>\n                  (l, g, \\<mu>) \\<in> PTA.trans_of A}\n  finite\n   {uu_.\n    \\<exists>\\<mu> l g.\n       uu_ =\n       map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n        \\<mu> \\<and>\n       (l, g, \\<mu>) \\<in> PTA.trans_of A}\n\ngoal (1 subgoal):\n 1. finite\n     ((\\<lambda>\\<mu>. emeasure (measure_pmf \\<mu>) {x. snd x = u}) `\n      (\\<Union>l\\<in>L.\n          {\\<mu> \\<in> K (l, u).\n           \\<mu> \\<noteq> return_pmf (l, u) \\<and>\n           (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)}))", "by (auto intro: finite_subset)"], ["proof (state)\nthis:\n  finite\n   ((\\<lambda>\\<mu>. emeasure (measure_pmf \\<mu>) {x. snd x = u}) `\n    (\\<Union>l\\<in>L.\n        {\\<mu> \\<in> K (l, u).\n         \\<mu> \\<noteq> return_pmf (l, u) \\<and>\n         (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)}))\n\ngoal (1 subgoal):\n 1. \\<Squnion> ({0} \\<union>\n                (\\<lambda>\\<mu>.\n                    emeasure (measure_pmf \\<mu>) {x. snd x = u}) `\n                (\\<Union>l\\<in>L.\n                    {\\<mu> \\<in> K (l, u).\n                     \\<mu> \\<noteq> return_pmf (l, u) \\<and>\n                     (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)}))\n    < 1", "then"], ["proof (chain)\npicking this:\n  finite\n   ((\\<lambda>\\<mu>. emeasure (measure_pmf \\<mu>) {x. snd x = u}) `\n    (\\<Union>l\\<in>L.\n        {\\<mu> \\<in> K (l, u).\n         \\<mu> \\<noteq> return_pmf (l, u) \\<and>\n         (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)}))", "show ?thesis"], ["proof (prove)\nusing this:\n  finite\n   ((\\<lambda>\\<mu>. emeasure (measure_pmf \\<mu>) {x. snd x = u}) `\n    (\\<Union>l\\<in>L.\n        {\\<mu> \\<in> K (l, u).\n         \\<mu> \\<noteq> return_pmf (l, u) \\<and>\n         (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)}))\n\ngoal (1 subgoal):\n 1. \\<Squnion> ({0} \\<union>\n                (\\<lambda>\\<mu>.\n                    emeasure (measure_pmf \\<mu>) {x. snd x = u}) `\n                (\\<Union>l\\<in>L.\n                    {\\<mu> \\<in> K (l, u).\n                     \\<mu> \\<noteq> return_pmf (l, u) \\<and>\n                     (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)}))\n    < 1", "by (fastforce intro: * finite_imp_Sup_less)"], ["proof (state)\nthis:\n  \\<Squnion> ({0} \\<union>\n              (\\<lambda>\\<mu>.\n                  emeasure (measure_pmf \\<mu>) {x. snd x = u}) `\n              (\\<Union>l\\<in>L.\n                  {\\<mu> \\<in> K (l, u).\n                   \\<mu> \\<noteq> return_pmf (l, u) \\<and>\n                   (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)}))\n  < 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Squnion> ({0} \\<union>\n              (\\<lambda>\\<mu>.\n                  emeasure (measure_pmf \\<mu>) {x. snd x = ?u8}) `\n              (\\<Union>l\\<in>L.\n                  {\\<mu> \\<in> K (l, ?u8).\n                   \\<mu> \\<noteq> return_pmf (l, ?u8) \\<and>\n                   (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)}))\n  < 1\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "{"], ["proof (state)\nthis:\n  \\<Squnion> ({0} \\<union>\n              (\\<lambda>\\<mu>.\n                  emeasure (measure_pmf \\<mu>) {x. snd x = ?u8}) `\n              (\\<Union>l\\<in>L.\n                  {\\<mu> \\<in> K (l, ?u8).\n                   \\<mu> \\<noteq> return_pmf (l, ?u8) \\<and>\n                   (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)}))\n  < 1\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "fix l :: 's and u :: \"'c \\<Rightarrow> real\" and cfg :: \"('s \\<times> ('c \\<Rightarrow> real) set) cfg\""], ["proof (state)\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "assume unbounded: \"\\<forall> c \\<in> \\<X>. u c > k c\" and \"cfg \\<in> R_G.cfg_on (abss (l, u))\" \"abss (l, u) \\<in> \\<S>\"\n      and same_loc: \"\\<forall> cfg' \\<in> K_cfg cfg. fst (state cfg') = l\""], ["proof (state)\nthis:\n  \\<forall>c\\<in>\\<X>. real (k c) < u c\n  cfg \\<in> R_G.cfg_on (abss (l, u))\n  abss (l, u) \\<in> \\<S>\n  \\<forall>cfg'\\<in>set_pmf (K_cfg cfg). fst (state cfg') = l\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "then"], ["proof (chain)\npicking this:\n  \\<forall>c\\<in>\\<X>. real (k c) < u c\n  cfg \\<in> R_G.cfg_on (abss (l, u))\n  abss (l, u) \\<in> \\<S>\n  \\<forall>cfg'\\<in>set_pmf (K_cfg cfg). fst (state cfg') = l", "have \"cfg \\<in> R_G.valid_cfg\" \"repcs (l, u) cfg \\<in> valid_cfg\""], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>\\<X>. real (k c) < u c\n  cfg \\<in> R_G.cfg_on (abss (l, u))\n  abss (l, u) \\<in> \\<S>\n  \\<forall>cfg'\\<in>set_pmf (K_cfg cfg). fst (state cfg') = l\n\ngoal (1 subgoal):\n 1. cfg \\<in> R_G.valid_cfg &&& repcs (l, u) cfg \\<in> MDP.valid_cfg", "by (auto intro: R_G.valid_cfgI)"], ["proof (state)\nthis:\n  cfg \\<in> R_G.valid_cfg\n  repcs (l, u) cfg \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "then"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.valid_cfg\n  repcs (l, u) cfg \\<in> MDP.valid_cfg", "have cfg_on: \"repcs (l, u) cfg \\<in> MDP.cfg_on (l, u)\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  repcs (l, u) cfg \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. repcs (l, u) cfg \\<in> MDP.cfg_on (l, u)", "by (auto dest: MDP.valid_cfgD)"], ["proof (state)\nthis:\n  repcs (l, u) cfg \\<in> MDP.cfg_on (l, u)\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "from \\<open>cfg \\<in> R_G.cfg_on _\\<close>"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.cfg_on (abss (l, u))", "have \"action cfg \\<in> \\<K> (abss (l, u))\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.cfg_on (abss (l, u))\n\ngoal (1 subgoal):\n 1. action cfg \\<in> \\<K> (abss (l, u))", "by (rule R_G.cfg_onD_action)"], ["proof (state)\nthis:\n  action cfg \\<in> \\<K> (abss (l, u))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "(* TODO: Pull out? *)"], ["proof (state)\nthis:\n  action cfg \\<in> \\<K> (abss (l, u))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "have K_cfg_rept: \"state ` K_cfg (repcs (l, u) cfg) = rept (l, u) (action cfg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state ` set_pmf (K_cfg (repcs (l, u) cfg)) =\n    set_pmf (rept (l, u) (action cfg))", "unfolding K_cfg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. state `\n    set_pmf\n     (map_pmf (cont (repcs (l, u) cfg)) (action (repcs (l, u) cfg))) =\n    set_pmf (rept (l, u) (action cfg))", "by (force simp: action_repcs)"], ["proof (state)\nthis:\n  state ` set_pmf (K_cfg (repcs (l, u) cfg)) =\n  set_pmf (rept (l, u) (action cfg))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "have \"l \\<in> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<in> L", "using MDP.valid_cfg_state_in_S \\<open>repcs (l, u) cfg \\<in> MDP.valid_cfg\\<close>"], ["proof (prove)\nusing this:\n  ?cfg \\<in> MDP.valid_cfg \\<Longrightarrow> state ?cfg \\<in> S\n  repcs (l, u) cfg \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. l \\<in> L", "by fastforce"], ["proof (state)\nthis:\n  l \\<in> L\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "moreover"], ["proof (state)\nthis:\n  l \\<in> L\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "have \"rept (l, u) (action cfg) \\<noteq> return_pmf (l, u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rept (l, u) (action cfg) \\<noteq> return_pmf (l, u)", "proof (rule ccontr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. rept (l, u) (action cfg) = return_pmf (l, u) \\<Longrightarrow> False", "assume \"rept (l, u) (action cfg) = return_pmf (l, u)\""], ["proof (state)\nthis:\n  rept (l, u) (action cfg) = return_pmf (l, u)\n\ngoal (1 subgoal):\n 1. rept (l, u) (action cfg) = return_pmf (l, u) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  rept (l, u) (action cfg) = return_pmf (l, u)", "have \"action cfg = return_pmf (abss (l, u))\""], ["proof (prove)\nusing this:\n  rept (l, u) (action cfg) = return_pmf (l, u)\n\ngoal (1 subgoal):\n 1. action cfg = return_pmf (abss (l, u))", "using abst_rept_id[OF \\<open>action cfg \\<in> _\\<close>]"], ["proof (prove)\nusing this:\n  rept (l, u) (action cfg) = return_pmf (l, u)\n  abst (rept (l, u) (action cfg)) = action cfg\n\ngoal (1 subgoal):\n 1. action cfg = return_pmf (abss (l, u))", "by (simp add: abst_def)"], ["proof (state)\nthis:\n  action cfg = return_pmf (abss (l, u))\n\ngoal (1 subgoal):\n 1. rept (l, u) (action cfg) = return_pmf (l, u) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  action cfg = return_pmf (abss (l, u))\n\ngoal (1 subgoal):\n 1. rept (l, u) (action cfg) = return_pmf (l, u) \\<Longrightarrow> False", "have \"(l, u) \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l, u) \\<in> S", "using \\<open>_ \\<in> \\<S>\\<close>"], ["proof (prove)\nusing this:\n  abss (l, u) \\<in> \\<S>\n\ngoal (1 subgoal):\n 1. (l, u) \\<in> S", "by (auto dest: \\<S>_abss_S)"], ["proof (state)\nthis:\n  (l, u) \\<in> S\n\ngoal (1 subgoal):\n 1. rept (l, u) (action cfg) = return_pmf (l, u) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  (l, u) \\<in> S\n\ngoal (1 subgoal):\n 1. rept (l, u) (action cfg) = return_pmf (l, u) \\<Longrightarrow> False", "have \"abss (l, u) = (l, [u]\\<^sub>\\<R>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abss (l, u) = (l, [u]\\<^sub>\\<R>)", "by (metis abss_S calculation(2))"], ["proof (state)\nthis:\n  abss (l, u) = (l, [u]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. rept (l, u) (action cfg) = return_pmf (l, u) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  action cfg = return_pmf (abss (l, u))\n  (l, u) \\<in> S\n  abss (l, u) = (l, [u]\\<^sub>\\<R>)", "show False"], ["proof (prove)\nusing this:\n  action cfg = return_pmf (abss (l, u))\n  (l, u) \\<in> S\n  abss (l, u) = (l, [u]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. False", "using \\<open>rept (l, u) _ = _\\<close> unbounded"], ["proof (prove)\nusing this:\n  action cfg = return_pmf (abss (l, u))\n  (l, u) \\<in> S\n  abss (l, u) = (l, [u]\\<^sub>\\<R>)\n  rept (l, u) (action cfg) = return_pmf (l, u)\n  \\<forall>c\\<in>\\<X>. real (k c) < u c\n\ngoal (1 subgoal):\n 1. False", "unfolding rept_def"], ["proof (prove)\nusing this:\n  action cfg = return_pmf (abss (l, u))\n  (l, u) \\<in> S\n  abss (l, u) = (l, [u]\\<^sub>\\<R>)\n  (let (la, ua) = (l, u)\n   in if \\<exists>R'.\n            (la, ua) \\<in> S \\<and>\n            action cfg = return_pmf (la, R') \\<and>\n            [ua]\\<^sub>\\<R> = R' \\<and>\n            (\\<forall>c\\<in>\\<X>. real (k c) < ua c)\n      then return_pmf (la, ua \\<oplus> 5 / 10)\n      else if \\<exists>R'.\n                 (la, ua) \\<in> S \\<and>\n                 action cfg = return_pmf (la, R') \\<and>\n                 R' \\<in> Succ \\<R> ([ua]\\<^sub>\\<R>) \\<and>\n                 [ua]\\<^sub>\\<R> \\<noteq> R' \\<and>\n                 (\\<forall>u\\<in>R'.\n                     \\<forall>c\\<in>\\<X>.\n                        \\<not> (\\<exists>d\\<le>k c. u c = real d))\n           then return_pmf\n                 (la,\n                  delayedR (SOME R'. action cfg = return_pmf (la, R')) ua)\n           else SOME \\<mu>.\n                   \\<mu> \\<in> K (l, u) \\<and> abst \\<mu> = action cfg) =\n  return_pmf (l, u)\n  \\<forall>c\\<in>\\<X>. real (k c) < u c\n\ngoal (1 subgoal):\n 1. False", "by (auto dest: cval_add_non_id)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rept (l, u) (action cfg) \\<noteq> return_pmf (l, u)\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "moreover"], ["proof (state)\nthis:\n  rept (l, u) (action cfg) \\<noteq> return_pmf (l, u)\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "have \"rept (l, u) (action cfg) \\<in> K (l, u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rept (l, u) (action cfg) \\<in> K (l, u)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rept (l, u) (action cfg) \\<in> K (l, u)", "have \"action (repcs (l, u) cfg) \\<in> K (l, u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. action (repcs (l, u) cfg) \\<in> K (l, u)", "using cfg_on"], ["proof (prove)\nusing this:\n  repcs (l, u) cfg \\<in> MDP.cfg_on (l, u)\n\ngoal (1 subgoal):\n 1. action (repcs (l, u) cfg) \\<in> K (l, u)", "by blast"], ["proof (state)\nthis:\n  action (repcs (l, u) cfg) \\<in> K (l, u)\n\ngoal (1 subgoal):\n 1. rept (l, u) (action cfg) \\<in> K (l, u)", "then"], ["proof (chain)\npicking this:\n  action (repcs (l, u) cfg) \\<in> K (l, u)", "show ?thesis"], ["proof (prove)\nusing this:\n  action (repcs (l, u) cfg) \\<in> K (l, u)\n\ngoal (1 subgoal):\n 1. rept (l, u) (action cfg) \\<in> K (l, u)", "by (simp add: repcs_def)"], ["proof (state)\nthis:\n  rept (l, u) (action cfg) \\<in> K (l, u)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rept (l, u) (action cfg) \\<in> K (l, u)\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "moreover"], ["proof (state)\nthis:\n  rept (l, u) (action cfg) \\<in> K (l, u)\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "have \"\\<forall>x\\<in>set_pmf (rept (l, u) (action cfg)). fst x = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_pmf (rept (l, u) (action cfg)). fst x = l", "using same_loc K_cfg_same_loc_iff[of \"repcs (l, u) cfg\"]\n        \\<open>repcs (l, u) _ \\<in> valid_cfg\\<close> \\<open>cfg \\<in> R_G.valid_cfg\\<close> \\<open>cfg \\<in> R_G.cfg_on _\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>cfg'\\<in>set_pmf (K_cfg cfg). fst (state cfg') = l\n  repcs (l, u) cfg \\<in> MDP.valid_cfg \\<Longrightarrow>\n  (\\<forall>cfg'\\<in>set_pmf (K_cfg (repcs (l, u) cfg)).\n      fst (state cfg') = fst (state (repcs (l, u) cfg))) =\n  (\\<forall>cfg'\\<in>set_pmf (K_cfg (absc (repcs (l, u) cfg))).\n      fst (state cfg') = fst (state (absc (repcs (l, u) cfg))))\n  repcs (l, u) cfg \\<in> MDP.valid_cfg\n  cfg \\<in> R_G.valid_cfg\n  cfg \\<in> R_G.cfg_on (abss (l, u))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_pmf (rept (l, u) (action cfg)). fst x = l", "by (simp add: absc_repcs_id fst_abss K_cfg_rept[symmetric])"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set_pmf (rept (l, u) (action cfg)). fst x = l\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "ultimately"], ["proof (chain)\npicking this:\n  l \\<in> L\n  rept (l, u) (action cfg) \\<noteq> return_pmf (l, u)\n  rept (l, u) (action cfg) \\<in> K (l, u)\n  \\<forall>x\\<in>set_pmf (rept (l, u) (action cfg)). fst x = l", "have \"rept (l, u) (action cfg) \\<in> ?U u\""], ["proof (prove)\nusing this:\n  l \\<in> L\n  rept (l, u) (action cfg) \\<noteq> return_pmf (l, u)\n  rept (l, u) (action cfg) \\<in> K (l, u)\n  \\<forall>x\\<in>set_pmf (rept (l, u) (action cfg)). fst x = l\n\ngoal (1 subgoal):\n 1. rept (l, u) (action cfg)\n    \\<in> (\\<Union>l\\<in>L.\n              {\\<mu> \\<in> K (l, u).\n               \\<mu> \\<noteq> return_pmf (l, u) \\<and>\n               (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)})", "by blast"], ["proof (state)\nthis:\n  rept (l, u) (action cfg)\n  \\<in> (\\<Union>l\\<in>L.\n            {\\<mu> \\<in> K (l, u).\n             \\<mu> \\<noteq> return_pmf (l, u) \\<and>\n             (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)})\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "then"], ["proof (chain)\npicking this:\n  rept (l, u) (action cfg)\n  \\<in> (\\<Union>l\\<in>L.\n            {\\<mu> \\<in> K (l, u).\n             \\<mu> \\<noteq> return_pmf (l, u) \\<and>\n             (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)})", "have \"measure_pmf (rept (l, u) (action cfg)) {x. snd x = u} \\<le> ?r u\""], ["proof (prove)\nusing this:\n  rept (l, u) (action cfg)\n  \\<in> (\\<Union>l\\<in>L.\n            {\\<mu> \\<in> K (l, u).\n             \\<mu> \\<noteq> return_pmf (l, u) \\<and>\n             (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)})\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (rept (l, u) (action cfg))) {x. snd x = u}\n    \\<le> \\<Squnion> ({0} \\<union>\n                      (\\<lambda>\\<mu>.\n                          emeasure (measure_pmf \\<mu>) {x. snd x = u}) `\n                      (\\<Union>l\\<in>L.\n                          {\\<mu> \\<in> K (l, u).\n                           \\<mu> \\<noteq> return_pmf (l, u) \\<and>\n                           (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)}))", "by (fastforce intro: Sup_upper)"], ["proof (state)\nthis:\n  emeasure (measure_pmf (rept (l, u) (action cfg))) {x. snd x = u}\n  \\<le> \\<Squnion> ({0} \\<union>\n                    (\\<lambda>\\<mu>.\n                        emeasure (measure_pmf \\<mu>) {x. snd x = u}) `\n                    (\\<Union>l\\<in>L.\n                        {\\<mu> \\<in> K (l, u).\n                         \\<mu> \\<noteq> return_pmf (l, u) \\<and>\n                         (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)}))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "moreover"], ["proof (state)\nthis:\n  emeasure (measure_pmf (rept (l, u) (action cfg))) {x. snd x = u}\n  \\<le> \\<Squnion> ({0} \\<union>\n                    (\\<lambda>\\<mu>.\n                        emeasure (measure_pmf \\<mu>) {x. snd x = u}) `\n                    (\\<Union>l\\<in>L.\n                        {\\<mu> \\<in> K (l, u).\n                         \\<mu> \\<noteq> return_pmf (l, u) \\<and>\n                         (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)}))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "have \"rept (l, u) (action cfg) = action (repcs (l, u) cfg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rept (l, u) (action cfg) = action (repcs (l, u) cfg)", "by (simp add: repcs_def)"], ["proof (state)\nthis:\n  rept (l, u) (action cfg) = action (repcs (l, u) cfg)\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "ultimately"], ["proof (chain)\npicking this:\n  emeasure (measure_pmf (rept (l, u) (action cfg))) {x. snd x = u}\n  \\<le> \\<Squnion> ({0} \\<union>\n                    (\\<lambda>\\<mu>.\n                        emeasure (measure_pmf \\<mu>) {x. snd x = u}) `\n                    (\\<Union>l\\<in>L.\n                        {\\<mu> \\<in> K (l, u).\n                         \\<mu> \\<noteq> return_pmf (l, u) \\<and>\n                         (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)}))\n  rept (l, u) (action cfg) = action (repcs (l, u) cfg)", "have \"measure_pmf (action (repcs (l, u) cfg)) {x. snd x = u} \\<le> ?r u\""], ["proof (prove)\nusing this:\n  emeasure (measure_pmf (rept (l, u) (action cfg))) {x. snd x = u}\n  \\<le> \\<Squnion> ({0} \\<union>\n                    (\\<lambda>\\<mu>.\n                        emeasure (measure_pmf \\<mu>) {x. snd x = u}) `\n                    (\\<Union>l\\<in>L.\n                        {\\<mu> \\<in> K (l, u).\n                         \\<mu> \\<noteq> return_pmf (l, u) \\<and>\n                         (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)}))\n  rept (l, u) (action cfg) = action (repcs (l, u) cfg)\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (action (repcs (l, u) cfg))) {x. snd x = u}\n    \\<le> \\<Squnion> ({0} \\<union>\n                      (\\<lambda>\\<mu>.\n                          emeasure (measure_pmf \\<mu>) {x. snd x = u}) `\n                      (\\<Union>l\\<in>L.\n                          {\\<mu> \\<in> K (l, u).\n                           \\<mu> \\<noteq> return_pmf (l, u) \\<and>\n                           (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)}))", "by auto"], ["proof (state)\nthis:\n  emeasure (measure_pmf (action (repcs (l, u) cfg))) {x. snd x = u}\n  \\<le> \\<Squnion> ({0} \\<union>\n                    (\\<lambda>\\<mu>.\n                        emeasure (measure_pmf \\<mu>) {x. snd x = u}) `\n                    (\\<Union>l\\<in>L.\n                        {\\<mu> \\<in> K (l, u).\n                         \\<mu> \\<noteq> return_pmf (l, u) \\<and>\n                         (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)}))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < ?u10 c;\n   ?cfga10 \\<in> R_G.cfg_on (abss (?l10, ?u10));\n   abss (?l10, ?u10) \\<in> \\<S>;\n   \\<forall>cfg'\\<in>set_pmf (K_cfg ?cfga10).\n      fst (state cfg') = ?l10\\<rbrakk>\n  \\<Longrightarrow> emeasure\n                     (measure_pmf (action (repcs (?l10, ?u10) ?cfga10)))\n                     {x. snd x = ?u10}\n                    \\<le> \\<Squnion> ({0} \\<union>\n(\\<lambda>\\<mu>. emeasure (measure_pmf \\<mu>) {x. snd x = ?u10}) `\n(\\<Union>l\\<in>L.\n    {\\<mu> \\<in> K (l, ?u10).\n     \\<mu> \\<noteq> return_pmf (l, ?u10) \\<and>\n     (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)}))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "note * = this"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < ?u10 c;\n   ?cfga10 \\<in> R_G.cfg_on (abss (?l10, ?u10));\n   abss (?l10, ?u10) \\<in> \\<S>;\n   \\<forall>cfg'\\<in>set_pmf (K_cfg ?cfga10).\n      fst (state cfg') = ?l10\\<rbrakk>\n  \\<Longrightarrow> emeasure\n                     (measure_pmf (action (repcs (?l10, ?u10) ?cfga10)))\n                     {x. snd x = ?u10}\n                    \\<le> \\<Squnion> ({0} \\<union>\n(\\<lambda>\\<mu>. emeasure (measure_pmf \\<mu>) {x. snd x = ?u10}) `\n(\\<Union>l\\<in>L.\n    {\\<mu> \\<in> K (l, ?u10).\n     \\<mu> \\<noteq> return_pmf (l, ?u10) \\<and>\n     (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)}))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "let ?S = \"{cfg. \\<exists> cfg' s. cfg' \\<in> R_G.valid_cfg \\<and> cfg = repcs s cfg' \\<and> abss s = state cfg'}\""], ["proof (state)\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "have start: \"repcs st cfg \\<in> ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. repcs st cfg\n    \\<in> {cfg.\n           \\<exists>cfg' s.\n              cfg' \\<in> R_G.valid_cfg \\<and>\n              cfg = repcs s cfg' \\<and> abss s = state cfg'}", "using \\<open>cfg \\<in> R_G.valid_cfg\\<close> assms"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  cfg \\<in> R_G.cfg_on (abss st)\n  st \\<in> S\n  alternating cfg\n\ngoal (1 subgoal):\n 1. repcs st cfg\n    \\<in> {cfg.\n           \\<exists>cfg' s.\n              cfg' \\<in> R_G.valid_cfg \\<and>\n              cfg = repcs s cfg' \\<and> abss s = state cfg'}", "unfolding R_G_cfg_on_div_def"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  cfg \\<in> R_G.cfg_on (abss st)\n  st \\<in> S\n  alternating cfg\n\ngoal (1 subgoal):\n 1. repcs st cfg\n    \\<in> {cfg.\n           \\<exists>cfg' s.\n              cfg' \\<in> R_G.valid_cfg \\<and>\n              cfg = repcs s cfg' \\<and> abss s = state cfg'}", "by clarsimp (inst_existentials cfg \"fst st\" \"snd st\", auto)"], ["proof (state)\nthis:\n  repcs st cfg\n  \\<in> {cfg.\n         \\<exists>cfg' s.\n            cfg' \\<in> R_G.valid_cfg \\<and>\n            cfg = repcs s cfg' \\<and> abss s = state cfg'}\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "have step: \"y \\<in> ?S\" if \"y \\<in> K_cfg x\" \"x \\<in> ?S\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> {cfg.\n             \\<exists>cfg' s.\n                cfg' \\<in> R_G.valid_cfg \\<and>\n                cfg = repcs s cfg' \\<and> abss s = state cfg'}", "using that"], ["proof (prove)\nusing this:\n  y \\<in> set_pmf (K_cfg x)\n  x \\<in> {cfg.\n           \\<exists>cfg' s.\n              cfg' \\<in> R_G.valid_cfg \\<and>\n              cfg = repcs s cfg' \\<and> abss s = state cfg'}\n\ngoal (1 subgoal):\n 1. y \\<in> {cfg.\n             \\<exists>cfg' s.\n                cfg' \\<in> R_G.valid_cfg \\<and>\n                cfg = repcs s cfg' \\<and> abss s = state cfg'}", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cfg' a b.\n       \\<lbrakk>y \\<in> set_pmf (K_cfg (repcs (a, b) cfg'));\n        cfg' \\<in> R_G.valid_cfg; abss (a, b) = state cfg';\n        x = repcs (a, b) cfg'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg' s.\n                            cfg' \\<in> R_G.valid_cfg \\<and>\n                            y = repcs s cfg' \\<and> abss s = state cfg'", "subgoal for cfg' l u"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> set_pmf (K_cfg (repcs (l, u) cfg'));\n     cfg' \\<in> R_G.valid_cfg; abss (l, u) = state cfg';\n     x = repcs (l, u) cfg'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>cfg' s.\n                         cfg' \\<in> R_G.valid_cfg \\<and>\n                         y = repcs s cfg' \\<and> abss s = state cfg'", "apply (inst_existentials \"absc y\" \"state y\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y \\<in> set_pmf (K_cfg (repcs (l, u) cfg'));\n     cfg' \\<in> R_G.valid_cfg; abss (l, u) = state cfg';\n     x = repcs (l, u) cfg'\\<rbrakk>\n    \\<Longrightarrow> absc y \\<in> R_G.valid_cfg\n 2. \\<lbrakk>y \\<in> set_pmf (K_cfg (repcs (l, u) cfg'));\n     cfg' \\<in> R_G.valid_cfg; abss (l, u) = state cfg';\n     x = repcs (l, u) cfg'\\<rbrakk>\n    \\<Longrightarrow> y = repcs (state y) (absc y)\n 3. \\<lbrakk>y \\<in> set_pmf (K_cfg (repcs (l, u) cfg'));\n     cfg' \\<in> R_G.valid_cfg; abss (l, u) = state cfg';\n     x = repcs (l, u) cfg'\\<rbrakk>\n    \\<Longrightarrow> abss (state y) = state (absc y)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> set_pmf (K_cfg (repcs (l, u) cfg'));\n     cfg' \\<in> R_G.valid_cfg; abss (l, u) = state cfg';\n     x = repcs (l, u) cfg'\\<rbrakk>\n    \\<Longrightarrow> absc y \\<in> R_G.valid_cfg", "by blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y \\<in> set_pmf (K_cfg (repcs (l, u) cfg'));\n     cfg' \\<in> R_G.valid_cfg; abss (l, u) = state cfg';\n     x = repcs (l, u) cfg'\\<rbrakk>\n    \\<Longrightarrow> y = repcs (state y) (absc y)\n 2. \\<lbrakk>y \\<in> set_pmf (K_cfg (repcs (l, u) cfg'));\n     cfg' \\<in> R_G.valid_cfg; abss (l, u) = state cfg';\n     x = repcs (l, u) cfg'\\<rbrakk>\n    \\<Longrightarrow> abss (state y) = state (absc y)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> set_pmf (K_cfg (repcs (l, u) cfg'));\n     cfg' \\<in> R_G.valid_cfg; abss (l, u) = state cfg';\n     x = repcs (l, u) cfg'\\<rbrakk>\n    \\<Longrightarrow> y = repcs (state y) (absc y)", "by (metis\n            K_cfg_valid_cfgD R_G.valid_cfgD R_G.valid_cfg_state_in_S absc_repcs_id cont_absc_1\n            cont_repcs1 repcs_valid\n            )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> set_pmf (K_cfg (repcs (l, u) cfg'));\n     cfg' \\<in> R_G.valid_cfg; abss (l, u) = state cfg';\n     x = repcs (l, u) cfg'\\<rbrakk>\n    \\<Longrightarrow> abss (state y) = state (absc y)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> set_pmf (K_cfg (repcs (l, u) cfg'));\n     cfg' \\<in> R_G.valid_cfg; abss (l, u) = state cfg';\n     x = repcs (l, u) cfg'\\<rbrakk>\n    \\<Longrightarrow> abss (state y) = state (absc y)", "by (simp add: state_absc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>?y8 \\<in> set_pmf (K_cfg ?x8);\n   ?x8\n   \\<in> {cfg.\n          \\<exists>cfg' s.\n             cfg' \\<in> R_G.valid_cfg \\<and>\n             cfg = repcs s cfg' \\<and> abss s = state cfg'}\\<rbrakk>\n  \\<Longrightarrow> ?y8\n                    \\<in> {cfg.\n                           \\<exists>cfg' s.\n                              cfg' \\<in> R_G.valid_cfg \\<and>\n                              cfg = repcs s cfg' \\<and> abss s = state cfg'}\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "have **: \"x \\<in> ?S\" if \"(repcs st cfg, x) \\<in> MDP.MC.acc\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {cfg.\n             \\<exists>cfg' s.\n                cfg' \\<in> R_G.valid_cfg \\<and>\n                cfg = repcs s cfg' \\<and> abss s = state cfg'}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> {cfg.\n             \\<exists>cfg' s.\n                cfg' \\<in> R_G.valid_cfg \\<and>\n                cfg = repcs s cfg' \\<and> abss s = state cfg'}", "from MDP.MC.acc_relfunD[OF that]"], ["proof (chain)\npicking this:\n  (\\<And>n.\n      ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ n) (repcs st cfg)\n       x \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain n where \"((\\<lambda> a b. b \\<in> K_cfg a) ^^ n) (repcs st cfg) x\""], ["proof (prove)\nusing this:\n  (\\<And>n.\n      ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ n) (repcs st cfg)\n       x \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ n) (repcs st cfg)\n         x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ n) (repcs st cfg) x\n\ngoal (1 subgoal):\n 1. x \\<in> {cfg.\n             \\<exists>cfg' s.\n                cfg' \\<in> R_G.valid_cfg \\<and>\n                cfg = repcs s cfg' \\<and> abss s = state cfg'}", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ n) (repcs st cfg) x", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ n) (repcs st cfg) x\n\ngoal (1 subgoal):\n 1. x \\<in> {cfg.\n             \\<exists>cfg' s.\n                cfg' \\<in> R_G.valid_cfg \\<and>\n                cfg = repcs s cfg' \\<and> abss s = state cfg'}", "proof (induction n arbitrary: x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ 0) (repcs st cfg)\n        x \\<Longrightarrow>\n       x \\<in> {cfg.\n                \\<exists>cfg' s.\n                   cfg' \\<in> R_G.valid_cfg \\<and>\n                   cfg = repcs s cfg' \\<and> abss s = state cfg'}\n 2. \\<And>n x.\n       \\<lbrakk>\\<And>x.\n                   ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ n)\n                    (repcs st cfg) x \\<Longrightarrow>\n                   x \\<in> {cfg.\n                            \\<exists>cfg' s.\n                               cfg' \\<in> R_G.valid_cfg \\<and>\n                               cfg = repcs s cfg' \\<and>\n                               abss s = state cfg'};\n        ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ Suc n) (repcs st cfg)\n         x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {cfg.\n                                  \\<exists>cfg' s.\n                                     cfg' \\<in> R_G.valid_cfg \\<and>\n                                     cfg = repcs s cfg' \\<and>\n                                     abss s = state cfg'}", "(* XXX Extract induction rule *)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ 0) (repcs st cfg)\n        x \\<Longrightarrow>\n       x \\<in> {cfg.\n                \\<exists>cfg' s.\n                   cfg' \\<in> R_G.valid_cfg \\<and>\n                   cfg = repcs s cfg' \\<and> abss s = state cfg'}\n 2. \\<And>n x.\n       \\<lbrakk>\\<And>x.\n                   ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ n)\n                    (repcs st cfg) x \\<Longrightarrow>\n                   x \\<in> {cfg.\n                            \\<exists>cfg' s.\n                               cfg' \\<in> R_G.valid_cfg \\<and>\n                               cfg = repcs s cfg' \\<and>\n                               abss s = state cfg'};\n        ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ Suc n) (repcs st cfg)\n         x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {cfg.\n                                  \\<exists>cfg' s.\n                                     cfg' \\<in> R_G.valid_cfg \\<and>\n                                     cfg = repcs s cfg' \\<and>\n                                     abss s = state cfg'}", "case 0"], ["proof (state)\nthis:\n  ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ 0) (repcs st cfg) x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ 0) (repcs st cfg)\n        x \\<Longrightarrow>\n       x \\<in> {cfg.\n                \\<exists>cfg' s.\n                   cfg' \\<in> R_G.valid_cfg \\<and>\n                   cfg = repcs s cfg' \\<and> abss s = state cfg'}\n 2. \\<And>n x.\n       \\<lbrakk>\\<And>x.\n                   ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ n)\n                    (repcs st cfg) x \\<Longrightarrow>\n                   x \\<in> {cfg.\n                            \\<exists>cfg' s.\n                               cfg' \\<in> R_G.valid_cfg \\<and>\n                               cfg = repcs s cfg' \\<and>\n                               abss s = state cfg'};\n        ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ Suc n) (repcs st cfg)\n         x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {cfg.\n                                  \\<exists>cfg' s.\n                                     cfg' \\<in> R_G.valid_cfg \\<and>\n                                     cfg = repcs s cfg' \\<and>\n                                     abss s = state cfg'}", "with start"], ["proof (chain)\npicking this:\n  repcs st cfg\n  \\<in> {cfg.\n         \\<exists>cfg' s.\n            cfg' \\<in> R_G.valid_cfg \\<and>\n            cfg = repcs s cfg' \\<and> abss s = state cfg'}\n  ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ 0) (repcs st cfg) x", "show ?case"], ["proof (prove)\nusing this:\n  repcs st cfg\n  \\<in> {cfg.\n         \\<exists>cfg' s.\n            cfg' \\<in> R_G.valid_cfg \\<and>\n            cfg = repcs s cfg' \\<and> abss s = state cfg'}\n  ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ 0) (repcs st cfg) x\n\ngoal (1 subgoal):\n 1. x \\<in> {cfg.\n             \\<exists>cfg' s.\n                cfg' \\<in> R_G.valid_cfg \\<and>\n                cfg = repcs s cfg' \\<and> abss s = state cfg'}", "by simp"], ["proof (state)\nthis:\n  x \\<in> {cfg.\n           \\<exists>cfg' s.\n              cfg' \\<in> R_G.valid_cfg \\<and>\n              cfg = repcs s cfg' \\<and> abss s = state cfg'}\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       \\<lbrakk>\\<And>x.\n                   ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ n)\n                    (repcs st cfg) x \\<Longrightarrow>\n                   x \\<in> {cfg.\n                            \\<exists>cfg' s.\n                               cfg' \\<in> R_G.valid_cfg \\<and>\n                               cfg = repcs s cfg' \\<and>\n                               abss s = state cfg'};\n        ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ Suc n) (repcs st cfg)\n         x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {cfg.\n                                  \\<exists>cfg' s.\n                                     cfg' \\<in> R_G.valid_cfg \\<and>\n                                     cfg = repcs s cfg' \\<and>\n                                     abss s = state cfg'}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n x.\n       \\<lbrakk>\\<And>x.\n                   ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ n)\n                    (repcs st cfg) x \\<Longrightarrow>\n                   x \\<in> {cfg.\n                            \\<exists>cfg' s.\n                               cfg' \\<in> R_G.valid_cfg \\<and>\n                               cfg = repcs s cfg' \\<and>\n                               abss s = state cfg'};\n        ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ Suc n) (repcs st cfg)\n         x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {cfg.\n                                  \\<exists>cfg' s.\n                                     cfg' \\<in> R_G.valid_cfg \\<and>\n                                     cfg = repcs s cfg' \\<and>\n                                     abss s = state cfg'}", "case (Suc n)"], ["proof (state)\nthis:\n  ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ n) (repcs st cfg)\n   ?x8 \\<Longrightarrow>\n  ?x8\n  \\<in> {cfg.\n         \\<exists>cfg' s.\n            cfg' \\<in> R_G.valid_cfg \\<and>\n            cfg = repcs s cfg' \\<and> abss s = state cfg'}\n  ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ Suc n) (repcs st cfg) x\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       \\<lbrakk>\\<And>x.\n                   ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ n)\n                    (repcs st cfg) x \\<Longrightarrow>\n                   x \\<in> {cfg.\n                            \\<exists>cfg' s.\n                               cfg' \\<in> R_G.valid_cfg \\<and>\n                               cfg = repcs s cfg' \\<and>\n                               abss s = state cfg'};\n        ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ Suc n) (repcs st cfg)\n         x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {cfg.\n                                  \\<exists>cfg' s.\n                                     cfg' \\<in> R_G.valid_cfg \\<and>\n                                     cfg = repcs s cfg' \\<and>\n                                     abss s = state cfg'}", "from this(2)[simplified]"], ["proof (chain)\npicking this:\n  ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ n OO\n   (\\<lambda>a b. b \\<in> set_pmf (K_cfg a)))\n   (repcs st cfg) x", "show ?case"], ["proof (prove)\nusing this:\n  ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ n OO\n   (\\<lambda>a b. b \\<in> set_pmf (K_cfg a)))\n   (repcs st cfg) x\n\ngoal (1 subgoal):\n 1. x \\<in> {cfg.\n             \\<exists>cfg' s.\n                cfg' \\<in> R_G.valid_cfg \\<and>\n                cfg = repcs s cfg' \\<and> abss s = state cfg'}", "apply (rule relcomppE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ n)\n                 (repcs st cfg) b;\n        x \\<in> set_pmf (K_cfg b)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {cfg.\n                                  \\<exists>cfg' s.\n                                     cfg' \\<in> R_G.valid_cfg \\<and>\n                                     cfg = repcs s cfg' \\<and>\n                                     abss s = state cfg'}", "apply (erule step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ n) (repcs st cfg)\n        b \\<Longrightarrow>\n       b \\<in> {cfg.\n                \\<exists>cfg' s.\n                   cfg' \\<in> R_G.valid_cfg \\<and>\n                   cfg = repcs s cfg' \\<and> abss s = state cfg'}", "apply (erule Suc.IH)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  x \\<in> {cfg.\n           \\<exists>cfg' s.\n              cfg' \\<in> R_G.valid_cfg \\<and>\n              cfg = repcs s cfg' \\<and> abss s = state cfg'}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> {cfg.\n           \\<exists>cfg' s.\n              cfg' \\<in> R_G.valid_cfg \\<and>\n              cfg = repcs s cfg' \\<and> abss s = state cfg'}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (repcs st cfg, ?x8) \\<in> MDP.MC.acc \\<Longrightarrow>\n  ?x8\n  \\<in> {cfg.\n         \\<exists>cfg' s.\n            cfg' \\<in> R_G.valid_cfg \\<and>\n            cfg = repcs s cfg' \\<and> abss s = state cfg'}\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "have ***: \"almost_everywhere (MDP.MC.T (repcs st cfg)) (alw (HLD ?S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_everywhere (MDP.MC.T (repcs st cfg))\n     (alw (HLD {cfg.\n                \\<exists>cfg' s.\n                   cfg' \\<in> R_G.valid_cfg \\<and>\n                   cfg = repcs s cfg' \\<and> abss s = state cfg'}))", "by (rule AE_mp[OF MDP.MC.AE_T_reachable]) (fastforce dest: ** simp: HLD_iff elim: alw_mono)"], ["proof (state)\nthis:\n  almost_everywhere (MDP.MC.T (repcs st cfg))\n   (alw (HLD {cfg.\n              \\<exists>cfg' s.\n                 cfg' \\<in> R_G.valid_cfg \\<and>\n                 cfg = repcs s cfg' \\<and> abss s = state cfg'}))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "from \\<open>alternating cfg\\<close> assms"], ["proof (chain)\npicking this:\n  alternating cfg\n  cfg \\<in> R_G.cfg_on (abss st)\n  st \\<in> S\n  alternating cfg", "have \"alternating (repcs st cfg)\""], ["proof (prove)\nusing this:\n  alternating cfg\n  cfg \\<in> R_G.cfg_on (abss st)\n  st \\<in> S\n  alternating cfg\n\ngoal (1 subgoal):\n 1. alternating (repcs st cfg)", "by (simp add: AE_alw_ev_same_loc_iff'[of _ st])"], ["proof (state)\nthis:\n  alternating (repcs st cfg)\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "then"], ["proof (chain)\npicking this:\n  alternating (repcs st cfg)", "have alw_ev_same2: \"almost_everywhere (MDP.MC.T (repcs st cfg))\n     (alw (\\<lambda>\\<omega>. HLD (state -` snd -` {u}) \\<omega> \\<longrightarrow>\n      ev (HLD {cfg. \\<forall>cfg'\\<in>set_pmf (K_cfg cfg). fst (state cfg') = fst (state cfg)}) \\<omega>))\"\n    for u"], ["proof (prove)\nusing this:\n  alternating (repcs st cfg)\n\ngoal (1 subgoal):\n 1. almost_everywhere (MDP.MC.T (repcs st cfg))\n     (alw (\\<lambda>\\<omega>.\n              HLD (state -` snd -` {u}) \\<omega> \\<longrightarrow>\n              ev (HLD {cfg.\n                       \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n                          fst (state cfg') = fst (state cfg)})\n               \\<omega>))", "unfolding alternating_def"], ["proof (prove)\nusing this:\n  almost_everywhere (MDP.MC.T (repcs st cfg))\n   (infs\n     {cfg.\n      \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n         fst (state cfg') = fst (state cfg)})\n\ngoal (1 subgoal):\n 1. almost_everywhere (MDP.MC.T (repcs st cfg))\n     (alw (\\<lambda>\\<omega>.\n              HLD (state -` snd -` {u}) \\<omega> \\<longrightarrow>\n              ev (HLD {cfg.\n                       \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n                          fst (state cfg') = fst (state cfg)})\n               \\<omega>))", "by (auto elim: alw_mono)"], ["proof (state)\nthis:\n  almost_everywhere (MDP.MC.T (repcs st cfg))\n   (alw (\\<lambda>\\<omega>.\n            HLD (state -` snd -` {?u8}) \\<omega> \\<longrightarrow>\n            ev (HLD {cfg.\n                     \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n                        fst (state cfg') = fst (state cfg)})\n             \\<omega>))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "let ?X = \"{cfg :: ('s \\<times> ('c \\<Rightarrow> real)) cfg. \\<forall> c \\<in> \\<X>. snd (state cfg) c > k c}\""], ["proof (state)\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "let ?Y = \"{cfg. \\<forall> cfg' \\<in> K_cfg cfg. fst (state cfg') = fst (state cfg)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "have \"(AE \\<omega> in ?M. ?P \\<omega>) \\<longleftrightarrow>\n    (AE \\<omega> in ?M. \\<forall> u :: ('c \\<Rightarrow> real).\n      (\\<forall> c \\<in> \\<X>. u c > k c) \\<and> u \\<in> snd ` state ` (MDP.MC.acc `` {repcs st cfg}) \\<longrightarrow>\n      \\<not> (ev (alw (\\<lambda> xs. shd xs = u))) (smap (snd o state) \\<omega>))\" (is \"?L \\<longleftrightarrow> ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (AE \\<omega> in MDP.MC.T\n                     (repcs st\n                       cfg). \\<forall>u.\n                                (\\<forall>c\\<in>\\<X>.\n                                    real (k c) < u c) \\<longrightarrow>\n                                \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n  (smap (snd \\<circ> state) \\<omega>)) =\n    (AE \\<omega> in MDP.MC.T\n                     (repcs st\n                       cfg). \\<forall>u.\n                                (\\<forall>c\\<in>\\<X>.\n                                    real (k c) < u c) \\<and>\n                                u \\<in> snd `\n  state ` MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n                                \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n  (smap (snd \\<circ> state) \\<omega>))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>) \\<Longrightarrow>\n    AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<and>\n                               u \\<in> snd `\n state ` MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)\n 2. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<and>\n                               u \\<in> snd `\n state ` MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>) \\<Longrightarrow>\n    AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "assume ?L"], ["proof (state)\nthis:\n  AE \\<omega> in MDP.MC.T\n                  (repcs st\n                    cfg). \\<forall>u.\n                             (\\<forall>c\\<in>\\<X>.\n                                 real (k c) < u c) \\<longrightarrow>\n                             \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                                     (smap (snd \\<circ> state) \\<omega>)\n\ngoal (2 subgoals):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>) \\<Longrightarrow>\n    AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<and>\n                               u \\<in> snd `\n state ` MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)\n 2. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<and>\n                               u \\<in> snd `\n state ` MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>) \\<Longrightarrow>\n    AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "then"], ["proof (chain)\npicking this:\n  AE \\<omega> in MDP.MC.T\n                  (repcs st\n                    cfg). \\<forall>u.\n                             (\\<forall>c\\<in>\\<X>.\n                                 real (k c) < u c) \\<longrightarrow>\n                             \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                                     (smap (snd \\<circ> state) \\<omega>)", "show ?R"], ["proof (prove)\nusing this:\n  AE \\<omega> in MDP.MC.T\n                  (repcs st\n                    cfg). \\<forall>u.\n                             (\\<forall>c\\<in>\\<X>.\n                                 real (k c) < u c) \\<longrightarrow>\n                             \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                                     (smap (snd \\<circ> state) \\<omega>)\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<and>\n                               u \\<in> snd `\n state ` MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "by eventually_elim auto"], ["proof (state)\nthis:\n  AE \\<omega> in MDP.MC.T\n                  (repcs st\n                    cfg). \\<forall>u.\n                             (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<and>\n                             u \\<in> snd `\n                                     state `\n                                     MDP.MC.acc ``\n                                     {repcs st cfg} \\<longrightarrow>\n                             \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                                     (smap (snd \\<circ> state) \\<omega>)\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<and>\n                               u \\<in> snd `\n state ` MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>) \\<Longrightarrow>\n    AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<and>\n                               u \\<in> snd `\n state ` MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>) \\<Longrightarrow>\n    AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "assume ?R"], ["proof (state)\nthis:\n  AE \\<omega> in MDP.MC.T\n                  (repcs st\n                    cfg). \\<forall>u.\n                             (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<and>\n                             u \\<in> snd `\n                                     state `\n                                     MDP.MC.acc ``\n                                     {repcs st cfg} \\<longrightarrow>\n                             \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                                     (smap (snd \\<circ> state) \\<omega>)\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<and>\n                               u \\<in> snd `\n state ` MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>) \\<Longrightarrow>\n    AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "with MDP.MC.AE_T_reachable[of \"repcs st cfg\"]"], ["proof (chain)\npicking this:\n  almost_everywhere (MDP.MC.T (repcs st cfg))\n   (alw (HLD (MDP.MC.acc `` {repcs st cfg})))\n  AE \\<omega> in MDP.MC.T\n                  (repcs st\n                    cfg). \\<forall>u.\n                             (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<and>\n                             u \\<in> snd `\n                                     state `\n                                     MDP.MC.acc ``\n                                     {repcs st cfg} \\<longrightarrow>\n                             \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                                     (smap (snd \\<circ> state) \\<omega>)", "show ?L"], ["proof (prove)\nusing this:\n  almost_everywhere (MDP.MC.T (repcs st cfg))\n   (alw (HLD (MDP.MC.acc `` {repcs st cfg})))\n  AE \\<omega> in MDP.MC.T\n                  (repcs st\n                    cfg). \\<forall>u.\n                             (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<and>\n                             u \\<in> snd `\n                                     state `\n                                     MDP.MC.acc ``\n                                     {repcs st cfg} \\<longrightarrow>\n                             \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                                     (smap (snd \\<circ> state) \\<omega>)\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "proof (eventually_elim, intro allI impI notI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<omega> u.\n       \\<lbrakk>alw (HLD (MDP.MC.acc `` {repcs st cfg})) \\<omega>;\n        \\<forall>u.\n           (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<and>\n           u \\<in> snd `\n                   state ` MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n           \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                   (smap (snd \\<circ> state) \\<omega>);\n        almost_everywhere (MDP.MC.T (repcs st cfg))\n         (alw (HLD (MDP.MC.acc `` {repcs st cfg})));\n        AE \\<omega> in MDP.MC.T\n                        (repcs st\n                          cfg). \\<forall>u.\n                                   (\\<forall>c\\<in>\\<X>.\n real (k c) < u c) \\<and>\n                                   u \\<in> snd `\n     state ` MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n                                   \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n     (smap (snd \\<circ> state) \\<omega>);\n        \\<forall>c\\<in>\\<X>. real (k c) < u c;\n        ev (alw (\\<lambda>xs. shd xs = u))\n         (smap (snd \\<circ> state) \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> False", "case (1 \\<omega> u)"], ["proof (state)\nthis:\n  alw (HLD (MDP.MC.acc `` {repcs st cfg})) \\<omega>\n  \\<forall>u.\n     (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<and>\n     u \\<in> snd ` state ` MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n     \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n             (smap (snd \\<circ> state) \\<omega>)\n  almost_everywhere (MDP.MC.T (repcs st cfg))\n   (alw (HLD (MDP.MC.acc `` {repcs st cfg})))\n  AE \\<omega> in MDP.MC.T\n                  (repcs st\n                    cfg). \\<forall>u.\n                             (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<and>\n                             u \\<in> snd `\n                                     state `\n                                     MDP.MC.acc ``\n                                     {repcs st cfg} \\<longrightarrow>\n                             \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                                     (smap (snd \\<circ> state) \\<omega>)\n  \\<forall>c\\<in>\\<X>. real (k c) < u c\n  ev (alw (\\<lambda>xs. shd xs = u)) (smap (snd \\<circ> state) \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega> u.\n       \\<lbrakk>alw (HLD (MDP.MC.acc `` {repcs st cfg})) \\<omega>;\n        \\<forall>u.\n           (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<and>\n           u \\<in> snd `\n                   state ` MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n           \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                   (smap (snd \\<circ> state) \\<omega>);\n        almost_everywhere (MDP.MC.T (repcs st cfg))\n         (alw (HLD (MDP.MC.acc `` {repcs st cfg})));\n        AE \\<omega> in MDP.MC.T\n                        (repcs st\n                          cfg). \\<forall>u.\n                                   (\\<forall>c\\<in>\\<X>.\n real (k c) < u c) \\<and>\n                                   u \\<in> snd `\n     state ` MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n                                   \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n     (smap (snd \\<circ> state) \\<omega>);\n        \\<forall>c\\<in>\\<X>. real (k c) < u c;\n        ev (alw (\\<lambda>xs. shd xs = u))\n         (smap (snd \\<circ> state) \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  alw (HLD (MDP.MC.acc `` {repcs st cfg})) \\<omega>\n  \\<forall>u.\n     (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<and>\n     u \\<in> snd ` state ` MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n     \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n             (smap (snd \\<circ> state) \\<omega>)\n  almost_everywhere (MDP.MC.T (repcs st cfg))\n   (alw (HLD (MDP.MC.acc `` {repcs st cfg})))\n  AE \\<omega> in MDP.MC.T\n                  (repcs st\n                    cfg). \\<forall>u.\n                             (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<and>\n                             u \\<in> snd `\n                                     state `\n                                     MDP.MC.acc ``\n                                     {repcs st cfg} \\<longrightarrow>\n                             \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                                     (smap (snd \\<circ> state) \\<omega>)\n  \\<forall>c\\<in>\\<X>. real (k c) < u c\n  ev (alw (\\<lambda>xs. shd xs = u)) (smap (snd \\<circ> state) \\<omega>)", "show ?case"], ["proof (prove)\nusing this:\n  alw (HLD (MDP.MC.acc `` {repcs st cfg})) \\<omega>\n  \\<forall>u.\n     (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<and>\n     u \\<in> snd ` state ` MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n     \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n             (smap (snd \\<circ> state) \\<omega>)\n  almost_everywhere (MDP.MC.T (repcs st cfg))\n   (alw (HLD (MDP.MC.acc `` {repcs st cfg})))\n  AE \\<omega> in MDP.MC.T\n                  (repcs st\n                    cfg). \\<forall>u.\n                             (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<and>\n                             u \\<in> snd `\n                                     state `\n                                     MDP.MC.acc ``\n                                     {repcs st cfg} \\<longrightarrow>\n                             \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                                     (smap (snd \\<circ> state) \\<omega>)\n  \\<forall>c\\<in>\\<X>. real (k c) < u c\n  ev (alw (\\<lambda>xs. shd xs = u)) (smap (snd \\<circ> state) \\<omega>)\n\ngoal (1 subgoal):\n 1. False", "by - (intro alw_HLD_smap alw_disjoint_ccontr[where\n              S = \"(snd o state) ` MDP.MC.acc `` {repcs st cfg}\"\n              and R = \"{u}\" and \\<omega> = \"smap (snd o state) \\<omega>\"\n              ]; auto simp: HLD_iff)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  AE \\<omega> in MDP.MC.T\n                  (repcs st\n                    cfg). \\<forall>u.\n                             (\\<forall>c\\<in>\\<X>.\n                                 real (k c) < u c) \\<longrightarrow>\n                             \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                                     (smap (snd \\<circ> state) \\<omega>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (AE \\<omega> in MDP.MC.T\n                   (repcs st\n                     cfg). \\<forall>u.\n                              (\\<forall>c\\<in>\\<X>.\n                                  real (k c) < u c) \\<longrightarrow>\n                              \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n(smap (snd \\<circ> state) \\<omega>)) =\n  (AE \\<omega> in MDP.MC.T\n                   (repcs st\n                     cfg). \\<forall>u.\n                              (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<and>\n                              u \\<in> snd `\nstate ` MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n                              \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n(smap (snd \\<circ> state) \\<omega>))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "also"], ["proof (state)\nthis:\n  (AE \\<omega> in MDP.MC.T\n                   (repcs st\n                     cfg). \\<forall>u.\n                              (\\<forall>c\\<in>\\<X>.\n                                  real (k c) < u c) \\<longrightarrow>\n                              \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n(smap (snd \\<circ> state) \\<omega>)) =\n  (AE \\<omega> in MDP.MC.T\n                   (repcs st\n                     cfg). \\<forall>u.\n                              (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<and>\n                              u \\<in> snd `\nstate ` MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n                              \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n(smap (snd \\<circ> state) \\<omega>))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "have \"\\<dots> \\<longleftrightarrow>\n      (\\<forall> u :: ('c \\<Rightarrow> real).\n        (\\<forall> c \\<in> \\<X>. u c > k c) \\<and> u \\<in> snd ` state ` (MDP.MC.acc `` {repcs st cfg}) \\<longrightarrow>\n        (AE \\<omega> in ?M. \\<not> (ev (alw (\\<lambda> xs. shd xs = u))) (smap (snd o state) \\<omega>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (AE \\<omega> in MDP.MC.T\n                     (repcs st\n                       cfg). \\<forall>u.\n                                (\\<forall>c\\<in>\\<X>.\n                                    real (k c) < u c) \\<and>\n                                u \\<in> snd `\n  state ` MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n                                \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n  (smap (snd \\<circ> state) \\<omega>)) =\n    (\\<forall>u.\n        (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<and>\n        u \\<in> snd ` state ` MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n        (AE \\<omega> in MDP.MC.T\n                         (repcs st\n                           cfg). \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n   (smap (snd \\<circ> state) \\<omega>)))", "using MDP.MC.countable_reachable[of \"repcs st cfg\"]"], ["proof (prove)\nusing this:\n  countable (MDP.MC.acc `` {repcs st cfg})\n\ngoal (1 subgoal):\n 1. (AE \\<omega> in MDP.MC.T\n                     (repcs st\n                       cfg). \\<forall>u.\n                                (\\<forall>c\\<in>\\<X>.\n                                    real (k c) < u c) \\<and>\n                                u \\<in> snd `\n  state ` MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n                                \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n  (smap (snd \\<circ> state) \\<omega>)) =\n    (\\<forall>u.\n        (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<and>\n        u \\<in> snd ` state ` MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n        (AE \\<omega> in MDP.MC.T\n                         (repcs st\n                           cfg). \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n   (smap (snd \\<circ> state) \\<omega>)))", "by - (rule AE_all_imp_countable,\n        auto intro: countable_subset[where B = \"snd ` state ` MDP.MC.acc `` {repcs st cfg}\"])"], ["proof (state)\nthis:\n  (AE \\<omega> in MDP.MC.T\n                   (repcs st\n                     cfg). \\<forall>u.\n                              (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<and>\n                              u \\<in> snd `\nstate ` MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n                              \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n(smap (snd \\<circ> state) \\<omega>)) =\n  (\\<forall>u.\n      (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<and>\n      u \\<in> snd ` state ` MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n      (AE \\<omega> in MDP.MC.T\n                       (repcs st\n                         cfg). \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "also"], ["proof (state)\nthis:\n  (AE \\<omega> in MDP.MC.T\n                   (repcs st\n                     cfg). \\<forall>u.\n                              (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<and>\n                              u \\<in> snd `\nstate ` MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n                              \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n(smap (snd \\<circ> state) \\<omega>)) =\n  (\\<forall>u.\n      (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<and>\n      u \\<in> snd ` state ` MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n      (AE \\<omega> in MDP.MC.T\n                       (repcs st\n                         cfg). \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "unfolding calculation"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u.\n       (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<and>\n       u \\<in> snd ` state ` MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n       (AE \\<omega> in MDP.MC.T\n                        (repcs st\n                          cfg). \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n  (smap (snd \\<circ> state) \\<omega>))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x.\n       \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < snd (state x) c;\n        (a, b) = state x; (repcs st cfg, x) \\<in> MDP.MC.acc\\<rbrakk>\n       \\<Longrightarrow> AE \\<omega> in MDP.MC.T\n   (repcs st\n     cfg). \\<not> ev (alw (\\<lambda>xa.\n                              snd (state (shd xa)) = snd (state x)))\n                   \\<omega>", "subgoal for l u x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < snd (state x) c;\n     (l, u) = state x; (repcs st cfg, x) \\<in> MDP.MC.acc\\<rbrakk>\n    \\<Longrightarrow> AE \\<omega> in MDP.MC.T\n(repcs st\n  cfg). \\<not> ev (alw (\\<lambda>xa. snd (state (shd xa)) = snd (state x)))\n                \\<omega>", "apply (rule\n          MDP.non_loop_tail_strong[simplified, of snd \"snd (state x)\" ?Y ?S \"?r (snd (state x))\"]\n          )"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < snd (state x) c;\n     (l, u) = state x; (repcs st cfg, x) \\<in> MDP.MC.acc\\<rbrakk>\n    \\<Longrightarrow> \\<forall>cfg\\<in>\\<Union>\n  (MDP.cfg_on ` snd -` {snd (state x)}) \\<inter>\n {cfg.\n  \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n     fst (state cfg') = fst (state cfg)} \\<inter>\n {cfg.\n  \\<exists>cfg' s.\n     cfg' \\<in> R_G.valid_cfg \\<and>\n     cfg = repcs s cfg' \\<and> abss s = state cfg'}.\n                         emeasure (measure_pmf (action cfg))\n                          (snd -` {snd (state x)})\n                         \\<le> \\<Squnion> ({0} \\<union>\n     (\\<lambda>\\<mu>.\n         emeasure (measure_pmf \\<mu>) {xa. snd xa = snd (state x)}) `\n     (\\<Union>l\\<in>L.\n         {\\<mu> \\<in> K (l, snd (state x)).\n          \\<mu> \\<noteq> return_pmf (l, snd (state x)) \\<and>\n          (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)}))\n 2. \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < snd (state x) c;\n     (l, u) = state x; (repcs st cfg, x) \\<in> MDP.MC.acc\\<rbrakk>\n    \\<Longrightarrow> \\<Squnion> ({0} \\<union>\n                                  (\\<lambda>\\<mu>.\nemeasure (measure_pmf \\<mu>) {xa. snd xa = snd (state x)}) `\n                                  (\\<Union>l\\<in>L.\n{\\<mu> \\<in> K (l, snd (state x)).\n \\<mu> \\<noteq> return_pmf (l, snd (state x)) \\<and>\n (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)}))\n                      < 1\n 3. \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < snd (state x) c;\n     (l, u) = state x; (repcs st cfg, x) \\<in> MDP.MC.acc\\<rbrakk>\n    \\<Longrightarrow> repcs st cfg \\<in> MDP.cfg_on ?x\n 4. \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < snd (state x) c;\n     (l, u) = state x; (repcs st cfg, x) \\<in> MDP.MC.acc\\<rbrakk>\n    \\<Longrightarrow> almost_everywhere (MDP.MC.T (repcs st cfg))\n                       (pred_stream\n                         (\\<lambda>x.\n                             x \\<in> {cfg.\n\\<exists>cfg' s.\n   cfg' \\<in> R_G.valid_cfg \\<and>\n   cfg = repcs s cfg' \\<and> abss s = state cfg'}))\n 5. \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < snd (state x) c;\n     (l, u) = state x; (repcs st cfg, x) \\<in> MDP.MC.acc\\<rbrakk>\n    \\<Longrightarrow> almost_everywhere (MDP.MC.T (repcs st cfg))\n                       (alw (\\<lambda>\\<omega>.\n                                HLD (state -` snd -` {snd (state x)})\n                                 \\<omega> \\<longrightarrow>\n                                ev (HLD {cfg.\n   \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n      fst (state cfg') = fst (state cfg)})\n                                 \\<omega>))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < snd (state x) c;\n     (l, u) = state x; (repcs st cfg, x) \\<in> MDP.MC.acc\\<rbrakk>\n    \\<Longrightarrow> \\<forall>cfg\\<in>\\<Union>\n  (MDP.cfg_on ` snd -` {snd (state x)}) \\<inter>\n {cfg.\n  \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n     fst (state cfg') = fst (state cfg)} \\<inter>\n {cfg.\n  \\<exists>cfg' s.\n     cfg' \\<in> R_G.valid_cfg \\<and>\n     cfg = repcs s cfg' \\<and> abss s = state cfg'}.\n                         emeasure (measure_pmf (action cfg))\n                          (snd -` {snd (state x)})\n                         \\<le> \\<Squnion> ({0} \\<union>\n     (\\<lambda>\\<mu>.\n         emeasure (measure_pmf \\<mu>) {xa. snd xa = snd (state x)}) `\n     (\\<Union>l\\<in>L.\n         {\\<mu> \\<in> K (l, snd (state x)).\n          \\<mu> \\<noteq> return_pmf (l, snd (state x)) \\<and>\n          (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)}))", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cfga a b xa cfg' aa ba.\n       \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < snd (state x) c;\n        (l, u) = state x; (repcs st cfg, x) \\<in> MDP.MC.acc;\n        repcs (aa, ba) cfg' \\<in> MDP.cfg_on (a, b);\n        snd (a, b) = snd (state x);\n        \\<forall>cfg'a\\<in>set_pmf (K_cfg (repcs (aa, ba) cfg')).\n           fst (state cfg'a) = fst (state (repcs (aa, ba) cfg'));\n        cfg' \\<in> R_G.valid_cfg; abss (aa, ba) = state cfg'\\<rbrakk>\n       \\<Longrightarrow> emeasure\n                          (measure_pmf (action (repcs (aa, ba) cfg')))\n                          (snd -` {snd (state x)})\n                         \\<le> \\<Squnion> ({0} \\<union>\n     (\\<lambda>\\<mu>.\n         emeasure (measure_pmf \\<mu>) {xa. snd xa = snd (state x)}) `\n     (\\<Union>l\\<in>L.\n         {\\<mu> \\<in> K (l, snd (state x)).\n          \\<mu> \\<noteq> return_pmf (l, snd (state x)) \\<and>\n          (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)}))", "subgoal premises prems for cfg l1 u1 _ cfg' l2 u2"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (action (repcs (l2, u2) cfg')))\n     (snd -` {snd (state x)})\n    \\<le> \\<Squnion> ({0} \\<union>\n                      (\\<lambda>\\<mu>.\n                          emeasure (measure_pmf \\<mu>)\n                           {xa. snd xa = snd (state x)}) `\n                      (\\<Union>l\\<in>L.\n                          {\\<mu> \\<in> K (l, snd (state x)).\n                           \\<mu> \\<noteq>\n                           return_pmf (l, snd (state x)) \\<and>\n                           (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)}))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (action (repcs (l2, u2) cfg')))\n     (snd -` {snd (state x)})\n    \\<le> \\<Squnion> ({0} \\<union>\n                      (\\<lambda>\\<mu>.\n                          emeasure (measure_pmf \\<mu>)\n                           {xa. snd xa = snd (state x)}) `\n                      (\\<Union>l\\<in>L.\n                          {\\<mu> \\<in> K (l, snd (state x)).\n                           \\<mu> \\<noteq>\n                           return_pmf (l, snd (state x)) \\<and>\n                           (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)}))", "have [simp]: \"l2 = l1\" \"u2 = u1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l2 = l1 &&& u2 = u1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. l2 = l1", "by (metis MDP.cfg_onD_state Pair_inject prems(4) state_repcs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. u2 = u1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. u2 = u1", "by (metis MDP.cfg_onD_state prems(4) snd_conv state_repcs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  l2 = l1\n  u2 = u1\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (action (repcs (l2, u2) cfg')))\n     (snd -` {snd (state x)})\n    \\<le> \\<Squnion> ({0} \\<union>\n                      (\\<lambda>\\<mu>.\n                          emeasure (measure_pmf \\<mu>)\n                           {xa. snd xa = snd (state x)}) `\n                      (\\<Union>l\\<in>L.\n                          {\\<mu> \\<in> K (l, snd (state x)).\n                           \\<mu> \\<noteq>\n                           return_pmf (l, snd (state x)) \\<and>\n                           (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)}))", "with prems"], ["proof (chain)\npicking this:\n  \\<forall>c\\<in>\\<X>. real (k c) < snd (state x) c\n  (l, u) = state x\n  (repcs st cfg, x) \\<in> MDP.MC.acc\n  repcs (l2, u2) cfg' \\<in> MDP.cfg_on (l1, u1)\n  snd (l1, u1) = snd (state x)\n  \\<forall>cfg'a\\<in>set_pmf (K_cfg (repcs (l2, u2) cfg')).\n     fst (state cfg'a) = fst (state (repcs (l2, u2) cfg'))\n  cfg' \\<in> R_G.valid_cfg\n  abss (l2, u2) = state cfg'\n  l2 = l1\n  u2 = u1", "have [simp]: \"u2 = u\""], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>\\<X>. real (k c) < snd (state x) c\n  (l, u) = state x\n  (repcs st cfg, x) \\<in> MDP.MC.acc\n  repcs (l2, u2) cfg' \\<in> MDP.cfg_on (l1, u1)\n  snd (l1, u1) = snd (state x)\n  \\<forall>cfg'a\\<in>set_pmf (K_cfg (repcs (l2, u2) cfg')).\n     fst (state cfg'a) = fst (state (repcs (l2, u2) cfg'))\n  cfg' \\<in> R_G.valid_cfg\n  abss (l2, u2) = state cfg'\n  l2 = l1\n  u2 = u1\n\ngoal (1 subgoal):\n 1. u2 = u", "by (metis \\<open>(l, u) = state x\\<close> \\<open>snd (l1, u1) = snd (state x)\\<close> \\<open>u2 = u1\\<close> snd_conv)"], ["proof (state)\nthis:\n  u2 = u\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (action (repcs (l2, u2) cfg')))\n     (snd -` {snd (state x)})\n    \\<le> \\<Squnion> ({0} \\<union>\n                      (\\<lambda>\\<mu>.\n                          emeasure (measure_pmf \\<mu>)\n                           {xa. snd xa = snd (state x)}) `\n                      (\\<Union>l\\<in>L.\n                          {\\<mu> \\<in> K (l, snd (state x)).\n                           \\<mu> \\<noteq>\n                           return_pmf (l, snd (state x)) \\<and>\n                           (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)}))", "have [simp]: \"snd -` {snd (state x)} = {y. snd y = snd (state x)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd -` {snd (state x)} = {y. snd y = snd (state x)}", "by (simp add: vimage_def)"], ["proof (state)\nthis:\n  snd -` {snd (state x)} = {y. snd y = snd (state x)}\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (action (repcs (l2, u2) cfg')))\n     (snd -` {snd (state x)})\n    \\<le> \\<Squnion> ({0} \\<union>\n                      (\\<lambda>\\<mu>.\n                          emeasure (measure_pmf \\<mu>)\n                           {xa. snd xa = snd (state x)}) `\n                      (\\<Union>l\\<in>L.\n                          {\\<mu> \\<in> K (l, snd (state x)).\n                           \\<mu> \\<noteq>\n                           return_pmf (l, snd (state x)) \\<and>\n                           (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)}))", "from prems"], ["proof (chain)\npicking this:\n  \\<forall>c\\<in>\\<X>. real (k c) < snd (state x) c\n  (l, u) = state x\n  (repcs st cfg, x) \\<in> MDP.MC.acc\n  repcs (l2, u2) cfg' \\<in> MDP.cfg_on (l1, u1)\n  snd (l1, u1) = snd (state x)\n  \\<forall>cfg'a\\<in>set_pmf (K_cfg (repcs (l2, u2) cfg')).\n     fst (state cfg'a) = fst (state (repcs (l2, u2) cfg'))\n  cfg' \\<in> R_G.valid_cfg\n  abss (l2, u2) = state cfg'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>\\<X>. real (k c) < snd (state x) c\n  (l, u) = state x\n  (repcs st cfg, x) \\<in> MDP.MC.acc\n  repcs (l2, u2) cfg' \\<in> MDP.cfg_on (l1, u1)\n  snd (l1, u1) = snd (state x)\n  \\<forall>cfg'a\\<in>set_pmf (K_cfg (repcs (l2, u2) cfg')).\n     fst (state cfg'a) = fst (state (repcs (l2, u2) cfg'))\n  cfg' \\<in> R_G.valid_cfg\n  abss (l2, u2) = state cfg'\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (action (repcs (l2, u2) cfg')))\n     (snd -` {snd (state x)})\n    \\<le> \\<Squnion> ({0} \\<union>\n                      (\\<lambda>\\<mu>.\n                          emeasure (measure_pmf \\<mu>)\n                           {xa. snd xa = snd (state x)}) `\n                      (\\<Union>l\\<in>L.\n                          {\\<mu> \\<in> K (l, snd (state x)).\n                           \\<mu> \\<noteq>\n                           return_pmf (l, snd (state x)) \\<and>\n                           (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)}))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < snd (state x) c;\n     (l, u) = state x; (repcs st cfg, x) \\<in> MDP.MC.acc;\n     repcs (l1, snd (state x)) cfg' \\<in> MDP.cfg_on (l1, snd (state x));\n     u1 = snd (state x);\n     \\<forall>cfg'\\<in>set_pmf (K_cfg (repcs (l1, snd (state x)) cfg')).\n        fst (state cfg') = l1;\n     cfg' \\<in> R_G.valid_cfg;\n     abss (l1, snd (state x)) = state cfg'\\<rbrakk>\n    \\<Longrightarrow> emeasure\n                       (measure_pmf\n                         (action (repcs (l1, snd (state x)) cfg')))\n                       {y. snd y = snd (state x)}\n                      \\<le> 0 \\<squnion>\n                            (\\<Squnion>\\<mu>\\<in>\\<Union>l\\<in>L.\n              {\\<mu> \\<in> K (l, snd (state x)).\n               \\<mu> \\<noteq> return_pmf (l, snd (state x)) \\<and>\n               (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)}.\n                                emeasure (measure_pmf \\<mu>)\n                                 {xa. snd xa = snd (state x)})", "apply (erule *[simplified])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>(l, u) = state x; (repcs st cfg, x) \\<in> MDP.MC.acc;\n     repcs (l1, snd (state x)) cfg' \\<in> MDP.cfg_on (l1, snd (state x));\n     u1 = snd (state x);\n     \\<forall>cfg'\\<in>set_pmf (K_cfg (repcs (l1, snd (state x)) cfg')).\n        fst (state cfg') = l1;\n     cfg' \\<in> R_G.valid_cfg;\n     abss (l1, snd (state x)) = state cfg'\\<rbrakk>\n    \\<Longrightarrow> cfg' \\<in> R_G.cfg_on (abss (l1, snd (state x)))\n 2. \\<lbrakk>(l, u) = state x; (repcs st cfg, x) \\<in> MDP.MC.acc;\n     repcs (l1, snd (state x)) cfg' \\<in> MDP.cfg_on (l1, snd (state x));\n     u1 = snd (state x);\n     \\<forall>cfg'\\<in>set_pmf (K_cfg (repcs (l1, snd (state x)) cfg')).\n        fst (state cfg') = l1;\n     cfg' \\<in> R_G.valid_cfg;\n     abss (l1, snd (state x)) = state cfg'\\<rbrakk>\n    \\<Longrightarrow> abss (l1, snd (state x)) \\<in> \\<S>\n 3. \\<lbrakk>(l, u) = state x; (repcs st cfg, x) \\<in> MDP.MC.acc;\n     repcs (l1, snd (state x)) cfg' \\<in> MDP.cfg_on (l1, snd (state x));\n     u1 = snd (state x);\n     \\<forall>cfg'\\<in>set_pmf (K_cfg (repcs (l1, snd (state x)) cfg')).\n        fst (state cfg') = l1;\n     cfg' \\<in> R_G.valid_cfg;\n     abss (l1, snd (state x)) = state cfg'\\<rbrakk>\n    \\<Longrightarrow> \\<forall>cfg'\\<in>set_pmf (K_cfg cfg').\n                         fst (state cfg') = l1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(l, u) = state x; (repcs st cfg, x) \\<in> MDP.MC.acc;\n     repcs (l1, snd (state x)) cfg' \\<in> MDP.cfg_on (l1, snd (state x));\n     u1 = snd (state x);\n     \\<forall>cfg'\\<in>set_pmf (K_cfg (repcs (l1, snd (state x)) cfg')).\n        fst (state cfg') = l1;\n     cfg' \\<in> R_G.valid_cfg;\n     abss (l1, snd (state x)) = state cfg'\\<rbrakk>\n    \\<Longrightarrow> cfg' \\<in> R_G.cfg_on (abss (l1, snd (state x)))", "using prems(1) prems(2)[symmetric] prems(3-)"], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>\\<X>. real (k c) < snd (state x) c\n  state x = (l, u)\n  (repcs st cfg, x) \\<in> MDP.MC.acc\n  repcs (l2, u2) cfg' \\<in> MDP.cfg_on (l1, u1)\n  snd (l1, u1) = snd (state x)\n  \\<forall>cfg'a\\<in>set_pmf (K_cfg (repcs (l2, u2) cfg')).\n     fst (state cfg'a) = fst (state (repcs (l2, u2) cfg'))\n  cfg' \\<in> R_G.valid_cfg\n  abss (l2, u2) = state cfg'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(l, u) = state x; (repcs st cfg, x) \\<in> MDP.MC.acc;\n     repcs (l1, snd (state x)) cfg' \\<in> MDP.cfg_on (l1, snd (state x));\n     u1 = snd (state x);\n     \\<forall>cfg'\\<in>set_pmf (K_cfg (repcs (l1, snd (state x)) cfg')).\n        fst (state cfg') = l1;\n     cfg' \\<in> R_G.valid_cfg;\n     abss (l1, snd (state x)) = state cfg'\\<rbrakk>\n    \\<Longrightarrow> cfg' \\<in> R_G.cfg_on (abss (l1, snd (state x)))", "by (auto simp: R_G.valid_cfg_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(l, u) = state x; (repcs st cfg, x) \\<in> MDP.MC.acc;\n     repcs (l1, snd (state x)) cfg' \\<in> MDP.cfg_on (l1, snd (state x));\n     u1 = snd (state x);\n     \\<forall>cfg'\\<in>set_pmf (K_cfg (repcs (l1, snd (state x)) cfg')).\n        fst (state cfg') = l1;\n     cfg' \\<in> R_G.valid_cfg;\n     abss (l1, snd (state x)) = state cfg'\\<rbrakk>\n    \\<Longrightarrow> abss (l1, snd (state x)) \\<in> \\<S>\n 2. \\<lbrakk>(l, u) = state x; (repcs st cfg, x) \\<in> MDP.MC.acc;\n     repcs (l1, snd (state x)) cfg' \\<in> MDP.cfg_on (l1, snd (state x));\n     u1 = snd (state x);\n     \\<forall>cfg'\\<in>set_pmf (K_cfg (repcs (l1, snd (state x)) cfg')).\n        fst (state cfg') = l1;\n     cfg' \\<in> R_G.valid_cfg;\n     abss (l1, snd (state x)) = state cfg'\\<rbrakk>\n    \\<Longrightarrow> \\<forall>cfg'\\<in>set_pmf (K_cfg cfg').\n                         fst (state cfg') = l1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(l, u) = state x; (repcs st cfg, x) \\<in> MDP.MC.acc;\n     repcs (l1, snd (state x)) cfg' \\<in> MDP.cfg_on (l1, snd (state x));\n     u1 = snd (state x);\n     \\<forall>cfg'\\<in>set_pmf (K_cfg (repcs (l1, snd (state x)) cfg')).\n        fst (state cfg') = l1;\n     cfg' \\<in> R_G.valid_cfg;\n     abss (l1, snd (state x)) = state cfg'\\<rbrakk>\n    \\<Longrightarrow> abss (l1, snd (state x)) \\<in> \\<S>", "using prems(1) prems(2)[symmetric] prems(3-)"], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>\\<X>. real (k c) < snd (state x) c\n  state x = (l, u)\n  (repcs st cfg, x) \\<in> MDP.MC.acc\n  repcs (l2, u2) cfg' \\<in> MDP.cfg_on (l1, u1)\n  snd (l1, u1) = snd (state x)\n  \\<forall>cfg'a\\<in>set_pmf (K_cfg (repcs (l2, u2) cfg')).\n     fst (state cfg'a) = fst (state (repcs (l2, u2) cfg'))\n  cfg' \\<in> R_G.valid_cfg\n  abss (l2, u2) = state cfg'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(l, u) = state x; (repcs st cfg, x) \\<in> MDP.MC.acc;\n     repcs (l1, snd (state x)) cfg' \\<in> MDP.cfg_on (l1, snd (state x));\n     u1 = snd (state x);\n     \\<forall>cfg'\\<in>set_pmf (K_cfg (repcs (l1, snd (state x)) cfg')).\n        fst (state cfg') = l1;\n     cfg' \\<in> R_G.valid_cfg;\n     abss (l1, snd (state x)) = state cfg'\\<rbrakk>\n    \\<Longrightarrow> abss (l1, snd (state x)) \\<in> \\<S>", "by (auto simp: R_G.valid_cfg_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(l, u) = state x; (repcs st cfg, x) \\<in> MDP.MC.acc;\n     repcs (l1, snd (state x)) cfg' \\<in> MDP.cfg_on (l1, snd (state x));\n     u1 = snd (state x);\n     \\<forall>cfg'\\<in>set_pmf (K_cfg (repcs (l1, snd (state x)) cfg')).\n        fst (state cfg') = l1;\n     cfg' \\<in> R_G.valid_cfg;\n     abss (l1, snd (state x)) = state cfg'\\<rbrakk>\n    \\<Longrightarrow> \\<forall>cfg'\\<in>set_pmf (K_cfg cfg').\n                         fst (state cfg') = l1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(l, u) = state x; (repcs st cfg, x) \\<in> MDP.MC.acc;\n     repcs (l1, snd (state x)) cfg' \\<in> MDP.cfg_on (l1, snd (state x));\n     u1 = snd (state x);\n     \\<forall>cfg'\\<in>set_pmf (K_cfg (repcs (l1, snd (state x)) cfg')).\n        fst (state cfg') = l1;\n     cfg' \\<in> R_G.valid_cfg;\n     abss (l1, snd (state x)) = state cfg'\\<rbrakk>\n    \\<Longrightarrow> \\<forall>cfg'\\<in>set_pmf (K_cfg cfg').\n                         fst (state cfg') = l1", "using K_cfg_same_loc_iff[of \"repcs (l1, snd (state x)) cfg'\"]"], ["proof (prove)\nusing this:\n  repcs (l1, snd (state x)) cfg' \\<in> MDP.valid_cfg \\<Longrightarrow>\n  (\\<forall>cfg'a\\<in>set_pmf (K_cfg (repcs (l1, snd (state x)) cfg')).\n      fst (state cfg'a) = fst (state (repcs (l1, snd (state x)) cfg'))) =\n  (\\<forall>cfg'a\n            \\<in>set_pmf (K_cfg (absc (repcs (l1, snd (state x)) cfg'))).\n      fst (state cfg'a) =\n      fst (state (absc (repcs (l1, snd (state x)) cfg'))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(l, u) = state x; (repcs st cfg, x) \\<in> MDP.MC.acc;\n     repcs (l1, snd (state x)) cfg' \\<in> MDP.cfg_on (l1, snd (state x));\n     u1 = snd (state x);\n     \\<forall>cfg'\\<in>set_pmf (K_cfg (repcs (l1, snd (state x)) cfg')).\n        fst (state cfg') = l1;\n     cfg' \\<in> R_G.valid_cfg;\n     abss (l1, snd (state x)) = state cfg'\\<rbrakk>\n    \\<Longrightarrow> \\<forall>cfg'\\<in>set_pmf (K_cfg cfg').\n                         fst (state cfg') = l1", "by (simp add: absc_repcs_id) (metis fst_abss fst_conv repcs_valid)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  emeasure (measure_pmf (action (repcs (l2, u2) cfg')))\n   (snd -` {snd (state x)})\n  \\<le> \\<Squnion> ({0} \\<union>\n                    (\\<lambda>\\<mu>.\n                        emeasure (measure_pmf \\<mu>)\n                         {xa. snd xa = snd (state x)}) `\n                    (\\<Union>l\\<in>L.\n                        {\\<mu> \\<in> K (l, snd (state x)).\n                         \\<mu> \\<noteq> return_pmf (l, snd (state x)) \\<and>\n                         (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)}))\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < snd (state x) c;\n     (l, u) = state x; (repcs st cfg, x) \\<in> MDP.MC.acc\\<rbrakk>\n    \\<Longrightarrow> \\<Squnion> ({0} \\<union>\n                                  (\\<lambda>\\<mu>.\nemeasure (measure_pmf \\<mu>) {xa. snd xa = snd (state x)}) `\n                                  (\\<Union>l\\<in>L.\n{\\<mu> \\<in> K (l, snd (state x)).\n \\<mu> \\<noteq> return_pmf (l, snd (state x)) \\<and>\n (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)}))\n                      < 1\n 2. \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < snd (state x) c;\n     (l, u) = state x; (repcs st cfg, x) \\<in> MDP.MC.acc\\<rbrakk>\n    \\<Longrightarrow> repcs st cfg \\<in> MDP.cfg_on ?x\n 3. \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < snd (state x) c;\n     (l, u) = state x; (repcs st cfg, x) \\<in> MDP.MC.acc\\<rbrakk>\n    \\<Longrightarrow> almost_everywhere (MDP.MC.T (repcs st cfg))\n                       (pred_stream\n                         (\\<lambda>x.\n                             x \\<in> {cfg.\n\\<exists>cfg' s.\n   cfg' \\<in> R_G.valid_cfg \\<and>\n   cfg = repcs s cfg' \\<and> abss s = state cfg'}))\n 4. \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < snd (state x) c;\n     (l, u) = state x; (repcs st cfg, x) \\<in> MDP.MC.acc\\<rbrakk>\n    \\<Longrightarrow> almost_everywhere (MDP.MC.T (repcs st cfg))\n                       (alw (\\<lambda>\\<omega>.\n                                HLD (state -` snd -` {snd (state x)})\n                                 \\<omega> \\<longrightarrow>\n                                ev (HLD {cfg.\n   \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n      fst (state cfg') = fst (state cfg)})\n                                 \\<omega>))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < snd (state x) c;\n     (l, u) = state x; (repcs st cfg, x) \\<in> MDP.MC.acc\\<rbrakk>\n    \\<Longrightarrow> \\<Squnion> ({0} \\<union>\n                                  (\\<lambda>\\<mu>.\nemeasure (measure_pmf \\<mu>) {xa. snd xa = snd (state x)}) `\n                                  (\\<Union>l\\<in>L.\n{\\<mu> \\<in> K (l, snd (state x)).\n \\<mu> \\<noteq> return_pmf (l, snd (state x)) \\<and>\n (\\<forall>x\\<in>set_pmf \\<mu>. fst x = l)}))\n                      < 1", "by (auto intro: lt_1[simplified])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < snd (state x) c;\n     (l, u) = state x; (repcs st cfg, x) \\<in> MDP.MC.acc\\<rbrakk>\n    \\<Longrightarrow> repcs st cfg \\<in> MDP.cfg_on ?x\n 2. \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < snd (state x) c;\n     (l, u) = state x; (repcs st cfg, x) \\<in> MDP.MC.acc\\<rbrakk>\n    \\<Longrightarrow> almost_everywhere (MDP.MC.T (repcs st cfg))\n                       (pred_stream\n                         (\\<lambda>x.\n                             x \\<in> {cfg.\n\\<exists>cfg' s.\n   cfg' \\<in> R_G.valid_cfg \\<and>\n   cfg = repcs s cfg' \\<and> abss s = state cfg'}))\n 3. \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < snd (state x) c;\n     (l, u) = state x; (repcs st cfg, x) \\<in> MDP.MC.acc\\<rbrakk>\n    \\<Longrightarrow> almost_everywhere (MDP.MC.T (repcs st cfg))\n                       (alw (\\<lambda>\\<omega>.\n                                HLD (state -` snd -` {snd (state x)})\n                                 \\<omega> \\<longrightarrow>\n                                ev (HLD {cfg.\n   \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n      fst (state cfg') = fst (state cfg)})\n                                 \\<omega>))", "apply (rule MDP.valid_cfgD[OF \\<open>repcs st cfg \\<in> valid_cfg\\<close>]; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < snd (state x) c;\n     (l, u) = state x; (repcs st cfg, x) \\<in> MDP.MC.acc\\<rbrakk>\n    \\<Longrightarrow> almost_everywhere (MDP.MC.T (repcs st cfg))\n                       (pred_stream\n                         (\\<lambda>x.\n                             x \\<in> {cfg.\n\\<exists>cfg' s.\n   cfg' \\<in> R_G.valid_cfg \\<and>\n   cfg = repcs s cfg' \\<and> abss s = state cfg'}))\n 2. \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < snd (state x) c;\n     (l, u) = state x; (repcs st cfg, x) \\<in> MDP.MC.acc\\<rbrakk>\n    \\<Longrightarrow> almost_everywhere (MDP.MC.T (repcs st cfg))\n                       (alw (\\<lambda>\\<omega>.\n                                HLD (state -` snd -` {snd (state x)})\n                                 \\<omega> \\<longrightarrow>\n                                ev (HLD {cfg.\n   \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n      fst (state cfg') = fst (state cfg)})\n                                 \\<omega>))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < snd (state x) c;\n     (l, u) = state x; (repcs st cfg, x) \\<in> MDP.MC.acc\\<rbrakk>\n    \\<Longrightarrow> almost_everywhere (MDP.MC.T (repcs st cfg))\n                       (pred_stream\n                         (\\<lambda>x.\n                             x \\<in> {cfg.\n\\<exists>cfg' s.\n   cfg' \\<in> R_G.valid_cfg \\<and>\n   cfg = repcs s cfg' \\<and> abss s = state cfg'}))", "using ***"], ["proof (prove)\nusing this:\n  almost_everywhere (MDP.MC.T (repcs st cfg))\n   (alw (HLD {cfg.\n              \\<exists>cfg' s.\n                 cfg' \\<in> R_G.valid_cfg \\<and>\n                 cfg = repcs s cfg' \\<and> abss s = state cfg'}))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < snd (state x) c;\n     (l, u) = state x; (repcs st cfg, x) \\<in> MDP.MC.acc\\<rbrakk>\n    \\<Longrightarrow> almost_everywhere (MDP.MC.T (repcs st cfg))\n                       (pred_stream\n                         (\\<lambda>x.\n                             x \\<in> {cfg.\n\\<exists>cfg' s.\n   cfg' \\<in> R_G.valid_cfg \\<and>\n   cfg = repcs s cfg' \\<and> abss s = state cfg'}))", "unfolding alw_holds_pred_stream_iff[symmetric] HLD_def"], ["proof (prove)\nusing this:\n  almost_everywhere (MDP.MC.T (repcs st cfg))\n   (alw (holds\n          (\\<lambda>x.\n              x \\<in> {cfg.\n                       \\<exists>cfg' s.\n                          cfg' \\<in> R_G.valid_cfg \\<and>\n                          cfg = repcs s cfg' \\<and> abss s = state cfg'})))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < snd (state x) c;\n     (l, u) = state x; (repcs st cfg, x) \\<in> MDP.MC.acc\\<rbrakk>\n    \\<Longrightarrow> almost_everywhere (MDP.MC.T (repcs st cfg))\n                       (alw (holds\n                              (\\<lambda>x.\n                                  x \\<in> {cfg.\n     \\<exists>cfg' s.\n        cfg' \\<in> R_G.valid_cfg \\<and>\n        cfg = repcs s cfg' \\<and> abss s = state cfg'})))", "."], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < snd (state x) c;\n     (l, u) = state x; (repcs st cfg, x) \\<in> MDP.MC.acc\\<rbrakk>\n    \\<Longrightarrow> almost_everywhere (MDP.MC.T (repcs st cfg))\n                       (alw (\\<lambda>\\<omega>.\n                                HLD (state -` snd -` {snd (state x)})\n                                 \\<omega> \\<longrightarrow>\n                                ev (HLD {cfg.\n   \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n      fst (state cfg') = fst (state cfg)})\n                                 \\<omega>))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < snd (state x) c;\n     (l, u) = state x; (repcs st cfg, x) \\<in> MDP.MC.acc\\<rbrakk>\n    \\<Longrightarrow> almost_everywhere (MDP.MC.T (repcs st cfg))\n                       (alw (\\<lambda>\\<omega>.\n                                HLD (state -` snd -` {snd (state x)})\n                                 \\<omega> \\<longrightarrow>\n                                ev (HLD {cfg.\n   \\<forall>cfg'\\<in>set_pmf (K_cfg cfg).\n      fst (state cfg') = fst (state cfg)})\n                                 \\<omega>))", "by (rule alw_ev_same2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  AE \\<omega> in MDP.MC.T\n                  (repcs st\n                    cfg). \\<forall>u.\n                             (\\<forall>c\\<in>\\<X>.\n                                 real (k c) < u c) \\<longrightarrow>\n                             \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                                     (smap (snd \\<circ> state) \\<omega>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cfg_on_div_repcs_strong:\n  notes in_space_UNIV[measurable]\n  assumes \"cfg \\<in> R_G_cfg_on_div (abss st)\" \"st \\<in> S\" and \"alternating cfg\"\n  shows \"repcs st cfg \\<in> cfg_on_div st\""], ["proof (prove)\ngoal (1 subgoal):\n 1. repcs st cfg \\<in> cfg_on_div st", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. repcs st cfg \\<in> cfg_on_div st", "let ?st = \"abss st\""], ["proof (state)\ngoal (1 subgoal):\n 1. repcs st cfg \\<in> cfg_on_div st", "let ?cfg = \"repcs st cfg\""], ["proof (state)\ngoal (1 subgoal):\n 1. repcs st cfg \\<in> cfg_on_div st", "from assms"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G_cfg_on_div (abss st)\n  st \\<in> S\n  alternating cfg", "have *:\n    \"cfg \\<in> R_G.cfg_on ?st\" \"state cfg = ?st\" \"R_G_div_cfg cfg\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G_cfg_on_div (abss st)\n  st \\<in> S\n  alternating cfg\n\ngoal (1 subgoal):\n 1. cfg \\<in> R_G.cfg_on (abss st) &&&\n    state cfg = abss st &&& R_G_div_cfg cfg", "unfolding R_G_cfg_on_div_def"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.cfg_on (abss st) \\<inter> Collect R_G_div_cfg\n  st \\<in> S\n  alternating cfg\n\ngoal (1 subgoal):\n 1. cfg \\<in> R_G.cfg_on (abss st) &&&\n    state cfg = abss st &&& R_G_div_cfg cfg", "by auto"], ["proof (state)\nthis:\n  cfg \\<in> R_G.cfg_on (abss st)\n  state cfg = abss st\n  R_G_div_cfg cfg\n\ngoal (1 subgoal):\n 1. repcs st cfg \\<in> cfg_on_div st", "with assms"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G_cfg_on_div (abss st)\n  st \\<in> S\n  alternating cfg\n  cfg \\<in> R_G.cfg_on (abss st)\n  state cfg = abss st\n  R_G_div_cfg cfg", "have \"cfg \\<in> R_G.valid_cfg\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G_cfg_on_div (abss st)\n  st \\<in> S\n  alternating cfg\n  cfg \\<in> R_G.cfg_on (abss st)\n  state cfg = abss st\n  R_G_div_cfg cfg\n\ngoal (1 subgoal):\n 1. cfg \\<in> R_G.valid_cfg", "by (auto intro: R_G.valid_cfgI)"], ["proof (state)\nthis:\n  cfg \\<in> R_G.valid_cfg\n\ngoal (1 subgoal):\n 1. repcs st cfg \\<in> cfg_on_div st", "with \\<open>st \\<in> S\\<close> \\<open>_ = ?st\\<close>"], ["proof (chain)\npicking this:\n  st \\<in> S\n  state cfg = abss st\n  cfg \\<in> R_G.valid_cfg", "have \"?cfg \\<in> valid_cfg\""], ["proof (prove)\nusing this:\n  st \\<in> S\n  state cfg = abss st\n  cfg \\<in> R_G.valid_cfg\n\ngoal (1 subgoal):\n 1. repcs st cfg \\<in> MDP.valid_cfg", "by auto"], ["proof (state)\nthis:\n  repcs st cfg \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. repcs st cfg \\<in> cfg_on_div st", "from *(1) \\<open>st \\<in> S\\<close> \\<open>alternating cfg\\<close>"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.cfg_on (abss st)\n  st \\<in> S\n  alternating cfg", "have\n    \"AE \\<omega> in MDP.MC.T ?cfg. \\<forall>u. (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<longrightarrow>\n                          \\<not> ev (alw (\\<lambda>xs. shd xs = u)) (smap (snd \\<circ> state) \\<omega>)\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.cfg_on (abss st)\n  st \\<in> S\n  alternating cfg\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>u.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < u c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n (smap (snd \\<circ> state) \\<omega>)", "by (rule repcs_unbounded_AE_non_loop_end_strong)\n  \\<comment> \\<open>Move to lower level\\<close>"], ["proof (state)\nthis:\n  AE \\<omega> in MDP.MC.T\n                  (repcs st\n                    cfg). \\<forall>u.\n                             (\\<forall>c\\<in>\\<X>.\n                                 real (k c) < u c) \\<longrightarrow>\n                             \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                                     (smap (snd \\<circ> state) \\<omega>)\n\ngoal (1 subgoal):\n 1. repcs st cfg \\<in> cfg_on_div st", "moreover"], ["proof (state)\nthis:\n  AE \\<omega> in MDP.MC.T\n                  (repcs st\n                    cfg). \\<forall>u.\n                             (\\<forall>c\\<in>\\<X>.\n                                 real (k c) < u c) \\<longrightarrow>\n                             \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                                     (smap (snd \\<circ> state) \\<omega>)\n\ngoal (1 subgoal):\n 1. repcs st cfg \\<in> cfg_on_div st", "from *(2,3)"], ["proof (chain)\npicking this:\n  state cfg = abss st\n  R_G_div_cfg cfg", "have \"AE \\<omega> in MDP.MC.T ?cfg. \\<R>_div (smap (snd \\<circ> state) (smap absc \\<omega>))\""], ["proof (prove)\nusing this:\n  state cfg = abss st\n  R_G_div_cfg cfg\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<R>_div\n                             (smap (snd \\<circ> state) (smap absc \\<omega>))", "unfolding R_G_div_cfg_def"], ["proof (prove)\nusing this:\n  state cfg = abss st\n  AE \\<omega> in MDP.MC.T cfg. \\<R>_div (smap (snd \\<circ> state) \\<omega>)\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<R>_div\n                             (smap (snd \\<circ> state) (smap absc \\<omega>))", "by (subst (asm) R_G_trace_space_distr_eq[OF \\<open>cfg \\<in> R_G.valid_cfg\\<close>]; simp add: AE_distr_iff)"], ["proof (state)\nthis:\n  AE \\<omega> in MDP.MC.T\n                  (repcs st\n                    cfg). \\<R>_div\n                           (smap (snd \\<circ> state) (smap absc \\<omega>))\n\ngoal (1 subgoal):\n 1. repcs st cfg \\<in> cfg_on_div st", "ultimately"], ["proof (chain)\npicking this:\n  AE \\<omega> in MDP.MC.T\n                  (repcs st\n                    cfg). \\<forall>u.\n                             (\\<forall>c\\<in>\\<X>.\n                                 real (k c) < u c) \\<longrightarrow>\n                             \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                                     (smap (snd \\<circ> state) \\<omega>)\n  AE \\<omega> in MDP.MC.T\n                  (repcs st\n                    cfg). \\<R>_div\n                           (smap (snd \\<circ> state) (smap absc \\<omega>))", "have \"div_cfg ?cfg\""], ["proof (prove)\nusing this:\n  AE \\<omega> in MDP.MC.T\n                  (repcs st\n                    cfg). \\<forall>u.\n                             (\\<forall>c\\<in>\\<X>.\n                                 real (k c) < u c) \\<longrightarrow>\n                             \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                                     (smap (snd \\<circ> state) \\<omega>)\n  AE \\<omega> in MDP.MC.T\n                  (repcs st\n                    cfg). \\<R>_div\n                           (smap (snd \\<circ> state) (smap absc \\<omega>))\n\ngoal (1 subgoal):\n 1. div_cfg (repcs st cfg)", "unfolding div_cfg_def"], ["proof (prove)\nusing this:\n  AE \\<omega> in MDP.MC.T\n                  (repcs st\n                    cfg). \\<forall>u.\n                             (\\<forall>c\\<in>\\<X>.\n                                 real (k c) < u c) \\<longrightarrow>\n                             \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                                     (smap (snd \\<circ> state) \\<omega>)\n  AE \\<omega> in MDP.MC.T\n                  (repcs st\n                    cfg). \\<R>_div\n                           (smap (snd \\<circ> state) (smap absc \\<omega>))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). divergent (smap (snd \\<circ> state) \\<omega>)", "using MDP.MC.AE_T_enabled[of ?cfg]"], ["proof (prove)\nusing this:\n  AE \\<omega> in MDP.MC.T\n                  (repcs st\n                    cfg). \\<forall>u.\n                             (\\<forall>c\\<in>\\<X>.\n                                 real (k c) < u c) \\<longrightarrow>\n                             \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                                     (smap (snd \\<circ> state) \\<omega>)\n  AE \\<omega> in MDP.MC.T\n                  (repcs st\n                    cfg). \\<R>_div\n                           (smap (snd \\<circ> state) (smap absc \\<omega>))\n  almost_everywhere (MDP.MC.T (repcs st cfg))\n   (MDP.MC.enabled (repcs st cfg))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). divergent (smap (snd \\<circ> state) \\<omega>)", "proof eventually_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>\\<forall>u.\n                   (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<longrightarrow>\n                   \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                           (smap (snd \\<circ> state) \\<omega>);\n        \\<R>_div (smap (snd \\<circ> state) (smap absc \\<omega>));\n        MDP.MC.enabled (repcs st cfg) \\<omega>\\<rbrakk>\n       \\<Longrightarrow> divergent (smap (snd \\<circ> state) \\<omega>)", "case prems: (elim \\<omega>)"], ["proof (state)\nthis:\n  \\<forall>u.\n     (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<longrightarrow>\n     \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n             (smap (snd \\<circ> state) \\<omega>)\n  \\<R>_div (smap (snd \\<circ> state) (smap absc \\<omega>))\n  MDP.MC.enabled (repcs st cfg) \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>\\<forall>u.\n                   (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<longrightarrow>\n                   \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                           (smap (snd \\<circ> state) \\<omega>);\n        \\<R>_div (smap (snd \\<circ> state) (smap absc \\<omega>));\n        MDP.MC.enabled (repcs st cfg) \\<omega>\\<rbrakk>\n       \\<Longrightarrow> divergent (smap (snd \\<circ> state) \\<omega>)", "let ?xs = \"smap (snd o state) \\<omega>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>\\<forall>u.\n                   (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<longrightarrow>\n                   \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                           (smap (snd \\<circ> state) \\<omega>);\n        \\<R>_div (smap (snd \\<circ> state) (smap absc \\<omega>));\n        MDP.MC.enabled (repcs st cfg) \\<omega>\\<rbrakk>\n       \\<Longrightarrow> divergent (smap (snd \\<circ> state) \\<omega>)", "from MDP.pred_stream_cfg_on[OF \\<open>_ \\<in> valid_cfg\\<close> \\<open>MDP.MC.enabled _ _\\<close>]"], ["proof (chain)\npicking this:\n  pred_stream\n   (\\<lambda>cfg. state cfg \\<in> S \\<and> cfg \\<in> MDP.cfg_on (state cfg))\n   \\<omega>", "have *:\n        \"pred_stream (\\<lambda> x. x \\<in> S) (smap state \\<omega>)\""], ["proof (prove)\nusing this:\n  pred_stream\n   (\\<lambda>cfg. state cfg \\<in> S \\<and> cfg \\<in> MDP.cfg_on (state cfg))\n   \\<omega>\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>x. x \\<in> S) (smap state \\<omega>)", "by (auto simp: stream.pred_set)"], ["proof (state)\nthis:\n  pred_stream (\\<lambda>x. x \\<in> S) (smap state \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>\\<forall>u.\n                   (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<longrightarrow>\n                   \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                           (smap (snd \\<circ> state) \\<omega>);\n        \\<R>_div (smap (snd \\<circ> state) (smap absc \\<omega>));\n        MDP.MC.enabled (repcs st cfg) \\<omega>\\<rbrakk>\n       \\<Longrightarrow> divergent (smap (snd \\<circ> state) \\<omega>)", "have \"[snd (state x)]\\<^sub>\\<R> = snd (abss (state x))\" if \"x \\<in> sset \\<omega>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. [snd (state x)]\\<^sub>\\<R> = snd (abss (state x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [snd (state x)]\\<^sub>\\<R> = snd (abss (state x))", "from * that"], ["proof (chain)\npicking this:\n  pred_stream (\\<lambda>x. x \\<in> S) (smap state \\<omega>)\n  x \\<in> sset \\<omega>", "have \"state x \\<in> S\""], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>x. x \\<in> S) (smap state \\<omega>)\n  x \\<in> sset \\<omega>\n\ngoal (1 subgoal):\n 1. state x \\<in> S", "by (auto simp: stream.pred_set)"], ["proof (state)\nthis:\n  state x \\<in> S\n\ngoal (1 subgoal):\n 1. [snd (state x)]\\<^sub>\\<R> = snd (abss (state x))", "then"], ["proof (chain)\npicking this:\n  state x \\<in> S", "have \"snd (abss (state x)) = [snd (state x)]\\<^sub>\\<R>\""], ["proof (prove)\nusing this:\n  state x \\<in> S\n\ngoal (1 subgoal):\n 1. snd (abss (state x)) = [snd (state x)]\\<^sub>\\<R>", "by (metis abss_S snd_conv surj_pair)"], ["proof (state)\nthis:\n  snd (abss (state x)) = [snd (state x)]\\<^sub>\\<R>\n\ngoal (1 subgoal):\n 1. [snd (state x)]\\<^sub>\\<R> = snd (abss (state x))", "then"], ["proof (chain)\npicking this:\n  snd (abss (state x)) = [snd (state x)]\\<^sub>\\<R>", "show ?thesis"], ["proof (prove)\nusing this:\n  snd (abss (state x)) = [snd (state x)]\\<^sub>\\<R>\n\ngoal (1 subgoal):\n 1. [snd (state x)]\\<^sub>\\<R> = snd (abss (state x))", ".."], ["proof (state)\nthis:\n  [snd (state x)]\\<^sub>\\<R> = snd (abss (state x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x8 \\<in> sset \\<omega> \\<Longrightarrow>\n  [snd (state ?x8)]\\<^sub>\\<R> = snd (abss (state ?x8))\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>\\<forall>u.\n                   (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<longrightarrow>\n                   \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                           (smap (snd \\<circ> state) \\<omega>);\n        \\<R>_div (smap (snd \\<circ> state) (smap absc \\<omega>));\n        MDP.MC.enabled (repcs st cfg) \\<omega>\\<rbrakk>\n       \\<Longrightarrow> divergent (smap (snd \\<circ> state) \\<omega>)", "then"], ["proof (chain)\npicking this:\n  ?x8 \\<in> sset \\<omega> \\<Longrightarrow>\n  [snd (state ?x8)]\\<^sub>\\<R> = snd (abss (state ?x8))", "have \"smap (\\<lambda>z. [snd (state z)]\\<^sub>\\<R>) \\<omega> = (smap (\\<lambda>z. snd (abss (state z))) \\<omega>)\""], ["proof (prove)\nusing this:\n  ?x8 \\<in> sset \\<omega> \\<Longrightarrow>\n  [snd (state ?x8)]\\<^sub>\\<R> = snd (abss (state ?x8))\n\ngoal (1 subgoal):\n 1. smap (\\<lambda>z. [snd (state z)]\\<^sub>\\<R>) \\<omega> =\n    smap (\\<lambda>z. snd (abss (state z))) \\<omega>", "by auto"], ["proof (state)\nthis:\n  smap (\\<lambda>z. [snd (state z)]\\<^sub>\\<R>) \\<omega> =\n  smap (\\<lambda>z. snd (abss (state z))) \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>\\<forall>u.\n                   (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<longrightarrow>\n                   \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                           (smap (snd \\<circ> state) \\<omega>);\n        \\<R>_div (smap (snd \\<circ> state) (smap absc \\<omega>));\n        MDP.MC.enabled (repcs st cfg) \\<omega>\\<rbrakk>\n       \\<Longrightarrow> divergent (smap (snd \\<circ> state) \\<omega>)", "from *"], ["proof (chain)\npicking this:\n  pred_stream (\\<lambda>x. x \\<in> S) (smap state \\<omega>)", "have  \"pred_stream (\\<lambda> u. u \\<in> V) ?xs\""], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>x. x \\<in> S) (smap state \\<omega>)\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>u. u \\<in> V) (smap (snd \\<circ> state) \\<omega>)", "by (simp add: map_def stream.pred_set, subst (asm) surjective_pairing, blast)"], ["proof (state)\nthis:\n  pred_stream (\\<lambda>u. u \\<in> V) (smap (snd \\<circ> state) \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>\\<forall>u.\n                   (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<longrightarrow>\n                   \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                           (smap (snd \\<circ> state) \\<omega>);\n        \\<R>_div (smap (snd \\<circ> state) (smap absc \\<omega>));\n        MDP.MC.enabled (repcs st cfg) \\<omega>\\<rbrakk>\n       \\<Longrightarrow> divergent (smap (snd \\<circ> state) \\<omega>)", "moreover"], ["proof (state)\nthis:\n  pred_stream (\\<lambda>u. u \\<in> V) (smap (snd \\<circ> state) \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>\\<forall>u.\n                   (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<longrightarrow>\n                   \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                           (smap (snd \\<circ> state) \\<omega>);\n        \\<R>_div (smap (snd \\<circ> state) (smap absc \\<omega>));\n        MDP.MC.enabled (repcs st cfg) \\<omega>\\<rbrakk>\n       \\<Longrightarrow> divergent (smap (snd \\<circ> state) \\<omega>)", "have \"stream_trans ?xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_trans (smap (snd \\<circ> state) \\<omega>)", "by (rule enabled_stream_trans \\<open>_ \\<in> valid_cfg\\<close> \\<open>MDP.MC.enabled _ _\\<close>)+"], ["proof (state)\nthis:\n  stream_trans (smap (snd \\<circ> state) \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>\\<forall>u.\n                   (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<longrightarrow>\n                   \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                           (smap (snd \\<circ> state) \\<omega>);\n        \\<R>_div (smap (snd \\<circ> state) (smap absc \\<omega>));\n        MDP.MC.enabled (repcs st cfg) \\<omega>\\<rbrakk>\n       \\<Longrightarrow> divergent (smap (snd \\<circ> state) \\<omega>)", "moreover"], ["proof (state)\nthis:\n  stream_trans (smap (snd \\<circ> state) \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>\\<forall>u.\n                   (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<longrightarrow>\n                   \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                           (smap (snd \\<circ> state) \\<omega>);\n        \\<R>_div (smap (snd \\<circ> state) (smap absc \\<omega>));\n        MDP.MC.enabled (repcs st cfg) \\<omega>\\<rbrakk>\n       \\<Longrightarrow> divergent (smap (snd \\<circ> state) \\<omega>)", "have \"pairwise trans' ?xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PTA_Reachability.pairwise trans' (smap (snd \\<circ> state) \\<omega>)", "using \\<open>_ \\<in> R_G.valid_cfg\\<close> \\<open>state cfg = _\\<close>[symmetric] \\<open>MDP.MC.enabled _ _\\<close>"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  abss st = state cfg\n  MDP.MC.enabled (repcs st cfg) \\<omega>\n\ngoal (1 subgoal):\n 1. PTA_Reachability.pairwise trans' (smap (snd \\<circ> state) \\<omega>)", "by (rule enabled_stream_trans')"], ["proof (state)\nthis:\n  PTA_Reachability.pairwise trans' (smap (snd \\<circ> state) \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>\\<forall>u.\n                   (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<longrightarrow>\n                   \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                           (smap (snd \\<circ> state) \\<omega>);\n        \\<R>_div (smap (snd \\<circ> state) (smap absc \\<omega>));\n        MDP.MC.enabled (repcs st cfg) \\<omega>\\<rbrakk>\n       \\<Longrightarrow> divergent (smap (snd \\<circ> state) \\<omega>)", "moreover"], ["proof (state)\nthis:\n  PTA_Reachability.pairwise trans' (smap (snd \\<circ> state) \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>\\<forall>u.\n                   (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<longrightarrow>\n                   \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                           (smap (snd \\<circ> state) \\<omega>);\n        \\<R>_div (smap (snd \\<circ> state) (smap absc \\<omega>));\n        MDP.MC.enabled (repcs st cfg) \\<omega>\\<rbrakk>\n       \\<Longrightarrow> divergent (smap (snd \\<circ> state) \\<omega>)", "from prems(1)"], ["proof (chain)\npicking this:\n  \\<forall>u.\n     (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<longrightarrow>\n     \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n             (smap (snd \\<circ> state) \\<omega>)", "have\n        \"\\<forall>u. (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<longrightarrow> \\<not> ev (alw (\\<lambda>xs. snd (shd xs) = u)) (smap state \\<omega>)\""], ["proof (prove)\nusing this:\n  \\<forall>u.\n     (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<longrightarrow>\n     \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n             (smap (snd \\<circ> state) \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<longrightarrow>\n       \\<not> ev (alw (\\<lambda>xs. snd (shd xs) = u)) (smap state \\<omega>)", "by simp"], ["proof (state)\nthis:\n  \\<forall>u.\n     (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<longrightarrow>\n     \\<not> ev (alw (\\<lambda>xs. snd (shd xs) = u)) (smap state \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>\\<forall>u.\n                   (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<longrightarrow>\n                   \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                           (smap (snd \\<circ> state) \\<omega>);\n        \\<R>_div (smap (snd \\<circ> state) (smap absc \\<omega>));\n        MDP.MC.enabled (repcs st cfg) \\<omega>\\<rbrakk>\n       \\<Longrightarrow> divergent (smap (snd \\<circ> state) \\<omega>)", "ultimately"], ["proof (chain)\npicking this:\n  pred_stream (\\<lambda>u. u \\<in> V) (smap (snd \\<circ> state) \\<omega>)\n  stream_trans (smap (snd \\<circ> state) \\<omega>)\n  PTA_Reachability.pairwise trans' (smap (snd \\<circ> state) \\<omega>)\n  \\<forall>u.\n     (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<longrightarrow>\n     \\<not> ev (alw (\\<lambda>xs. snd (shd xs) = u)) (smap state \\<omega>)", "show ?case"], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>u. u \\<in> V) (smap (snd \\<circ> state) \\<omega>)\n  stream_trans (smap (snd \\<circ> state) \\<omega>)\n  PTA_Reachability.pairwise trans' (smap (snd \\<circ> state) \\<omega>)\n  \\<forall>u.\n     (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<longrightarrow>\n     \\<not> ev (alw (\\<lambda>xs. snd (shd xs) = u)) (smap state \\<omega>)\n\ngoal (1 subgoal):\n 1. divergent (smap (snd \\<circ> state) \\<omega>)", "using \\<open>\\<R>_div _\\<close>"], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>u. u \\<in> V) (smap (snd \\<circ> state) \\<omega>)\n  stream_trans (smap (snd \\<circ> state) \\<omega>)\n  PTA_Reachability.pairwise trans' (smap (snd \\<circ> state) \\<omega>)\n  \\<forall>u.\n     (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<longrightarrow>\n     \\<not> ev (alw (\\<lambda>xs. snd (shd xs) = u)) (smap state \\<omega>)\n  \\<R>_div (smap (snd \\<circ> state) (smap absc \\<omega>))\n\ngoal (1 subgoal):\n 1. divergent (smap (snd \\<circ> state) \\<omega>)", "by (simp add: stream.map_comp state_absc \\<open>smap _ \\<omega> = _\\<close> \\<R>_divergent_divergent)"], ["proof (state)\nthis:\n  divergent (smap (snd \\<circ> state) \\<omega>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  div_cfg (repcs st cfg)\n\ngoal (1 subgoal):\n 1. repcs st cfg \\<in> cfg_on_div st", "with MDP.valid_cfgD \\<open>cfg \\<in> R_G.valid_cfg\\<close> *"], ["proof (chain)\npicking this:\n  ?cfg \\<in> MDP.valid_cfg \\<Longrightarrow>\n  ?cfg \\<in> MDP.cfg_on (state ?cfg)\n  cfg \\<in> R_G.valid_cfg\n  cfg \\<in> R_G.cfg_on (abss st)\n  state cfg = abss st\n  R_G_div_cfg cfg\n  div_cfg (repcs st cfg)", "show ?thesis"], ["proof (prove)\nusing this:\n  ?cfg \\<in> MDP.valid_cfg \\<Longrightarrow>\n  ?cfg \\<in> MDP.cfg_on (state ?cfg)\n  cfg \\<in> R_G.valid_cfg\n  cfg \\<in> R_G.cfg_on (abss st)\n  state cfg = abss st\n  R_G_div_cfg cfg\n  div_cfg (repcs st cfg)\n\ngoal (1 subgoal):\n 1. repcs st cfg \\<in> cfg_on_div st", "unfolding cfg_on_div_def"], ["proof (prove)\nusing this:\n  ?cfg \\<in> MDP.valid_cfg \\<Longrightarrow>\n  ?cfg \\<in> MDP.cfg_on (state ?cfg)\n  cfg \\<in> R_G.valid_cfg\n  cfg \\<in> R_G.cfg_on (abss st)\n  state cfg = abss st\n  R_G_div_cfg cfg\n  div_cfg (repcs st cfg)\n\ngoal (1 subgoal):\n 1. repcs st cfg \\<in> MDP.cfg_on st \\<inter> Collect div_cfg", "by auto force"], ["proof (state)\nthis:\n  repcs st cfg \\<in> cfg_on_div st\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma repcs_unbounded_AE_non_loop_end:\n  assumes \"cfg \\<in> R_G.cfg_on (abss st)\" \"st \\<in> S\"\n  shows \"AE \\<omega> in MDP.MC.T (repcs st cfg).\n      (\\<forall> s :: ('s \\<times> ('c \\<Rightarrow> real)). (\\<forall> c \\<in> \\<X>. snd s c > k c) \\<longrightarrow>\n      \\<not> (ev (alw (\\<lambda> xs. shd xs = s))) (smap state \\<omega>))\" (is \"AE \\<omega> in ?M. ?P \\<omega>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "from assms"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.cfg_on (abss st)\n  st \\<in> S", "have \"cfg \\<in> R_G.valid_cfg\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.cfg_on (abss st)\n  st \\<in> S\n\ngoal (1 subgoal):\n 1. cfg \\<in> R_G.valid_cfg", "by (auto intro: R_G.valid_cfgI)"], ["proof (state)\nthis:\n  cfg \\<in> R_G.valid_cfg\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "with assms(1)"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.cfg_on (abss st)\n  cfg \\<in> R_G.valid_cfg", "have \"repcs st cfg \\<in> valid_cfg\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.cfg_on (abss st)\n  cfg \\<in> R_G.valid_cfg\n\ngoal (1 subgoal):\n 1. repcs st cfg \\<in> MDP.valid_cfg", "by auto"], ["proof (state)\nthis:\n  repcs st cfg \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "from R_G.valid_cfgD[OF \\<open>cfg \\<in> R_G.valid_cfg\\<close>]"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.cfg_on (state cfg)", "have \"cfg \\<in> R_G.cfg_on (state cfg)\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.cfg_on (state cfg)\n\ngoal (1 subgoal):\n 1. cfg \\<in> R_G.cfg_on (state cfg)", "."], ["proof (state)\nthis:\n  cfg \\<in> R_G.cfg_on (state cfg)\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "let ?K = \"\\<lambda> x. {\\<mu> \\<in> K x. \\<mu> \\<noteq> return_pmf x}\""], ["proof (state)\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "let ?r = \"\\<lambda> x. Sup ((\\<lambda> \\<mu>. measure_pmf \\<mu> {x}) ` ?K x)\""], ["proof (state)\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "have lt_1: \"?r x < 1\" if \"\\<mu> \\<in> ?K x\" for \\<mu> x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>\\<mu>\\<in>{\\<mu> \\<in> K x. \\<mu> \\<noteq> return_pmf x}.\n        emeasure (measure_pmf \\<mu>) {x})\n    < 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Squnion>\\<mu>\\<in>{\\<mu> \\<in> K x. \\<mu> \\<noteq> return_pmf x}.\n        emeasure (measure_pmf \\<mu>) {x})\n    < 1", "have *: \"emeasure (measure_pmf \\<mu>) {x} < 1\" if \"\\<mu> \\<noteq> return_pmf x\" for \\<mu>"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (measure_pmf \\<mu>) {x} < 1", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> emeasure (measure_pmf \\<mu>) {x} < 1 \\<Longrightarrow> False", "assume \"\\<not> emeasure (measure_pmf \\<mu>) {x} < 1\""], ["proof (state)\nthis:\n  \\<not> emeasure (measure_pmf \\<mu>) {x} < 1\n\ngoal (1 subgoal):\n 1. \\<not> emeasure (measure_pmf \\<mu>) {x} < 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> emeasure (measure_pmf \\<mu>) {x} < 1", "have \"emeasure (measure_pmf \\<mu>) {x} = 1\""], ["proof (prove)\nusing this:\n  \\<not> emeasure (measure_pmf \\<mu>) {x} < 1\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf \\<mu>) {x} = 1", "using measure_pmf.emeasure_ge_1_iff"], ["proof (prove)\nusing this:\n  \\<not> emeasure (measure_pmf \\<mu>) {x} < 1\n  (1 \\<le> emeasure (measure_pmf ?M) ?A) =\n  (emeasure (measure_pmf ?M) ?A = 1)\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf \\<mu>) {x} = 1", "by force"], ["proof (state)\nthis:\n  emeasure (measure_pmf \\<mu>) {x} = 1\n\ngoal (1 subgoal):\n 1. \\<not> emeasure (measure_pmf \\<mu>) {x} < 1 \\<Longrightarrow> False", "with that"], ["proof (chain)\npicking this:\n  \\<mu> \\<noteq> return_pmf x\n  emeasure (measure_pmf \\<mu>) {x} = 1", "show False"], ["proof (prove)\nusing this:\n  \\<mu> \\<noteq> return_pmf x\n  emeasure (measure_pmf \\<mu>) {x} = 1\n\ngoal (1 subgoal):\n 1. False", "by (simp add: measure_pmf_eq_1_iff)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?\\<mu>8 \\<noteq> return_pmf x \\<Longrightarrow>\n  emeasure (measure_pmf ?\\<mu>8) {x} < 1\n\ngoal (1 subgoal):\n 1. (\\<Squnion>\\<mu>\\<in>{\\<mu> \\<in> K x. \\<mu> \\<noteq> return_pmf x}.\n        emeasure (measure_pmf \\<mu>) {x})\n    < 1", "let ?S =\n      \"{map_pmf (\\<lambda> (X, l). (l, ([X := 0]u))) \\<mu> | \\<mu> l u g.\n          x = (l, u) \\<and> (l, g, \\<mu>) \\<in> trans_of A}\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Squnion>\\<mu>\\<in>{\\<mu> \\<in> K x. \\<mu> \\<noteq> return_pmf x}.\n        emeasure (measure_pmf \\<mu>) {x})\n    < 1", "have \"(\\<lambda> \\<mu>. measure_pmf \\<mu> {x}) ` ?K x\n      \\<subseteq> {0, 1} \\<union> (\\<lambda> \\<mu>. measure_pmf \\<mu> {x}) ` ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>\\<mu>. emeasure (measure_pmf \\<mu>) {x}) `\n    {\\<mu> \\<in> K x. \\<mu> \\<noteq> return_pmf x}\n    \\<subseteq> {0, 1} \\<union>\n                (\\<lambda>\\<mu>. emeasure (measure_pmf \\<mu>) {x}) `\n                {uu_.\n                 \\<exists>\\<mu> l u g.\n                    uu_ =\n                    map_pmf\n                     (\\<lambda>(X, l).\n                         (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n                     \\<mu> \\<and>\n                    x = (l, u) \\<and> (l, g, \\<mu>) \\<in> PTA.trans_of A}", "by (force elim!: K.cases)"], ["proof (state)\nthis:\n  (\\<lambda>\\<mu>. emeasure (measure_pmf \\<mu>) {x}) `\n  {\\<mu> \\<in> K x. \\<mu> \\<noteq> return_pmf x}\n  \\<subseteq> {0, 1} \\<union>\n              (\\<lambda>\\<mu>. emeasure (measure_pmf \\<mu>) {x}) `\n              {uu_.\n               \\<exists>\\<mu> l u g.\n                  uu_ =\n                  map_pmf\n                   (\\<lambda>(X, l).\n                       (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n                   \\<mu> \\<and>\n                  x = (l, u) \\<and> (l, g, \\<mu>) \\<in> PTA.trans_of A}\n\ngoal (1 subgoal):\n 1. (\\<Squnion>\\<mu>\\<in>{\\<mu> \\<in> K x. \\<mu> \\<noteq> return_pmf x}.\n        emeasure (measure_pmf \\<mu>) {x})\n    < 1", "moreover"], ["proof (state)\nthis:\n  (\\<lambda>\\<mu>. emeasure (measure_pmf \\<mu>) {x}) `\n  {\\<mu> \\<in> K x. \\<mu> \\<noteq> return_pmf x}\n  \\<subseteq> {0, 1} \\<union>\n              (\\<lambda>\\<mu>. emeasure (measure_pmf \\<mu>) {x}) `\n              {uu_.\n               \\<exists>\\<mu> l u g.\n                  uu_ =\n                  map_pmf\n                   (\\<lambda>(X, l).\n                       (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n                   \\<mu> \\<and>\n                  x = (l, u) \\<and> (l, g, \\<mu>) \\<in> PTA.trans_of A}\n\ngoal (1 subgoal):\n 1. (\\<Squnion>\\<mu>\\<in>{\\<mu> \\<in> K x. \\<mu> \\<noteq> return_pmf x}.\n        emeasure (measure_pmf \\<mu>) {x})\n    < 1", "have \"finite ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {uu_.\n      \\<exists>\\<mu> l u g.\n         uu_ =\n         map_pmf\n          (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n          \\<mu> \\<and>\n         x = (l, u) \\<and> (l, g, \\<mu>) \\<in> PTA.trans_of A}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     {uu_.\n      \\<exists>\\<mu> l u g.\n         uu_ =\n         map_pmf\n          (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n          \\<mu> \\<and>\n         x = (l, u) \\<and> (l, g, \\<mu>) \\<in> PTA.trans_of A}", "have \"?S \\<subseteq> (\\<lambda> (l, g, \\<mu>). map_pmf (\\<lambda> (X, l). (l, ([X := 0](snd x)))) \\<mu>) ` trans_of A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {uu_.\n     \\<exists>\\<mu> l u g.\n        uu_ =\n        map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n         \\<mu> \\<and>\n        x = (l, u) \\<and> (l, g, \\<mu>) \\<in> PTA.trans_of A}\n    \\<subseteq> (\\<lambda>(l, g, \\<mu>).\n                    map_pmf\n                     (\\<lambda>(X, l).\n                         (l, [(SOME r. set r = X)\\<rightarrow>0]snd x))\n                     \\<mu>) `\n                PTA.trans_of A", "by force"], ["proof (state)\nthis:\n  {uu_.\n   \\<exists>\\<mu> l u g.\n      uu_ =\n      map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n       \\<mu> \\<and>\n      x = (l, u) \\<and> (l, g, \\<mu>) \\<in> PTA.trans_of A}\n  \\<subseteq> (\\<lambda>(l, g, \\<mu>).\n                  map_pmf\n                   (\\<lambda>(X, l).\n                       (l, [(SOME r. set r = X)\\<rightarrow>0]snd x))\n                   \\<mu>) `\n              PTA.trans_of A\n\ngoal (1 subgoal):\n 1. finite\n     {uu_.\n      \\<exists>\\<mu> l u g.\n         uu_ =\n         map_pmf\n          (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n          \\<mu> \\<and>\n         x = (l, u) \\<and> (l, g, \\<mu>) \\<in> PTA.trans_of A}", "also"], ["proof (state)\nthis:\n  {uu_.\n   \\<exists>\\<mu> l u g.\n      uu_ =\n      map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n       \\<mu> \\<and>\n      x = (l, u) \\<and> (l, g, \\<mu>) \\<in> PTA.trans_of A}\n  \\<subseteq> (\\<lambda>(l, g, \\<mu>).\n                  map_pmf\n                   (\\<lambda>(X, l).\n                       (l, [(SOME r. set r = X)\\<rightarrow>0]snd x))\n                   \\<mu>) `\n              PTA.trans_of A\n\ngoal (1 subgoal):\n 1. finite\n     {uu_.\n      \\<exists>\\<mu> l u g.\n         uu_ =\n         map_pmf\n          (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n          \\<mu> \\<and>\n         x = (l, u) \\<and> (l, g, \\<mu>) \\<in> PTA.trans_of A}", "from finite(3)"], ["proof (chain)\npicking this:\n  finite (PTA.trans_of A)", "have \"finite \\<dots>\""], ["proof (prove)\nusing this:\n  finite (PTA.trans_of A)\n\ngoal (1 subgoal):\n 1. finite\n     ((\\<lambda>(l, g, \\<mu>).\n          map_pmf\n           (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]snd x))\n           \\<mu>) `\n      PTA.trans_of A)", ".."], ["proof (state)\nthis:\n  finite\n   ((\\<lambda>(l, g, \\<mu>).\n        map_pmf\n         (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]snd x))\n         \\<mu>) `\n    PTA.trans_of A)\n\ngoal (1 subgoal):\n 1. finite\n     {uu_.\n      \\<exists>\\<mu> l u g.\n         uu_ =\n         map_pmf\n          (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n          \\<mu> \\<and>\n         x = (l, u) \\<and> (l, g, \\<mu>) \\<in> PTA.trans_of A}", "finally"], ["proof (chain)\npicking this:\n  finite\n   {uu_.\n    \\<exists>\\<mu> l u g.\n       uu_ =\n       map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n        \\<mu> \\<and>\n       x = (l, u) \\<and> (l, g, \\<mu>) \\<in> PTA.trans_of A}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite\n   {uu_.\n    \\<exists>\\<mu> l u g.\n       uu_ =\n       map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n        \\<mu> \\<and>\n       x = (l, u) \\<and> (l, g, \\<mu>) \\<in> PTA.trans_of A}\n\ngoal (1 subgoal):\n 1. finite\n     {uu_.\n      \\<exists>\\<mu> l u g.\n         uu_ =\n         map_pmf\n          (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n          \\<mu> \\<and>\n         x = (l, u) \\<and> (l, g, \\<mu>) \\<in> PTA.trans_of A}", "."], ["proof (state)\nthis:\n  finite\n   {uu_.\n    \\<exists>\\<mu> l u g.\n       uu_ =\n       map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n        \\<mu> \\<and>\n       x = (l, u) \\<and> (l, g, \\<mu>) \\<in> PTA.trans_of A}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite\n   {uu_.\n    \\<exists>\\<mu> l u g.\n       uu_ =\n       map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n        \\<mu> \\<and>\n       x = (l, u) \\<and> (l, g, \\<mu>) \\<in> PTA.trans_of A}\n\ngoal (1 subgoal):\n 1. (\\<Squnion>\\<mu>\\<in>{\\<mu> \\<in> K x. \\<mu> \\<noteq> return_pmf x}.\n        emeasure (measure_pmf \\<mu>) {x})\n    < 1", "ultimately"], ["proof (chain)\npicking this:\n  (\\<lambda>\\<mu>. emeasure (measure_pmf \\<mu>) {x}) `\n  {\\<mu> \\<in> K x. \\<mu> \\<noteq> return_pmf x}\n  \\<subseteq> {0, 1} \\<union>\n              (\\<lambda>\\<mu>. emeasure (measure_pmf \\<mu>) {x}) `\n              {uu_.\n               \\<exists>\\<mu> l u g.\n                  uu_ =\n                  map_pmf\n                   (\\<lambda>(X, l).\n                       (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n                   \\<mu> \\<and>\n                  x = (l, u) \\<and> (l, g, \\<mu>) \\<in> PTA.trans_of A}\n  finite\n   {uu_.\n    \\<exists>\\<mu> l u g.\n       uu_ =\n       map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n        \\<mu> \\<and>\n       x = (l, u) \\<and> (l, g, \\<mu>) \\<in> PTA.trans_of A}", "have \"finite ((\\<lambda> \\<mu>. measure_pmf \\<mu> {x}) ` ?K x)\""], ["proof (prove)\nusing this:\n  (\\<lambda>\\<mu>. emeasure (measure_pmf \\<mu>) {x}) `\n  {\\<mu> \\<in> K x. \\<mu> \\<noteq> return_pmf x}\n  \\<subseteq> {0, 1} \\<union>\n              (\\<lambda>\\<mu>. emeasure (measure_pmf \\<mu>) {x}) `\n              {uu_.\n               \\<exists>\\<mu> l u g.\n                  uu_ =\n                  map_pmf\n                   (\\<lambda>(X, l).\n                       (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n                   \\<mu> \\<and>\n                  x = (l, u) \\<and> (l, g, \\<mu>) \\<in> PTA.trans_of A}\n  finite\n   {uu_.\n    \\<exists>\\<mu> l u g.\n       uu_ =\n       map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n        \\<mu> \\<and>\n       x = (l, u) \\<and> (l, g, \\<mu>) \\<in> PTA.trans_of A}\n\ngoal (1 subgoal):\n 1. finite\n     ((\\<lambda>\\<mu>. emeasure (measure_pmf \\<mu>) {x}) `\n      {\\<mu> \\<in> K x. \\<mu> \\<noteq> return_pmf x})", "by (auto intro: finite_subset)"], ["proof (state)\nthis:\n  finite\n   ((\\<lambda>\\<mu>. emeasure (measure_pmf \\<mu>) {x}) `\n    {\\<mu> \\<in> K x. \\<mu> \\<noteq> return_pmf x})\n\ngoal (1 subgoal):\n 1. (\\<Squnion>\\<mu>\\<in>{\\<mu> \\<in> K x. \\<mu> \\<noteq> return_pmf x}.\n        emeasure (measure_pmf \\<mu>) {x})\n    < 1", "then"], ["proof (chain)\npicking this:\n  finite\n   ((\\<lambda>\\<mu>. emeasure (measure_pmf \\<mu>) {x}) `\n    {\\<mu> \\<in> K x. \\<mu> \\<noteq> return_pmf x})", "show ?thesis"], ["proof (prove)\nusing this:\n  finite\n   ((\\<lambda>\\<mu>. emeasure (measure_pmf \\<mu>) {x}) `\n    {\\<mu> \\<in> K x. \\<mu> \\<noteq> return_pmf x})\n\ngoal (1 subgoal):\n 1. (\\<Squnion>\\<mu>\\<in>{\\<mu> \\<in> K x. \\<mu> \\<noteq> return_pmf x}.\n        emeasure (measure_pmf \\<mu>) {x})\n    < 1", "using that"], ["proof (prove)\nusing this:\n  finite\n   ((\\<lambda>\\<mu>. emeasure (measure_pmf \\<mu>) {x}) `\n    {\\<mu> \\<in> K x. \\<mu> \\<noteq> return_pmf x})\n  \\<mu> \\<in> {\\<mu> \\<in> K x. \\<mu> \\<noteq> return_pmf x}\n\ngoal (1 subgoal):\n 1. (\\<Squnion>\\<mu>\\<in>{\\<mu> \\<in> K x. \\<mu> \\<noteq> return_pmf x}.\n        emeasure (measure_pmf \\<mu>) {x})\n    < 1", "by (auto intro: * finite_imp_Sup_less)"], ["proof (state)\nthis:\n  (\\<Squnion>\\<mu>\\<in>{\\<mu> \\<in> K x. \\<mu> \\<noteq> return_pmf x}.\n      emeasure (measure_pmf \\<mu>) {x})\n  < 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?\\<mu>8\n  \\<in> {\\<mu> \\<in> K ?x8. \\<mu> \\<noteq> return_pmf ?x8} \\<Longrightarrow>\n  (\\<Squnion>\\<mu>\\<in>{\\<mu> \\<in> K ?x8. \\<mu> \\<noteq> return_pmf ?x8}.\n      emeasure (measure_pmf \\<mu>) {?x8})\n  < 1\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "{"], ["proof (state)\nthis:\n  ?\\<mu>8\n  \\<in> {\\<mu> \\<in> K ?x8. \\<mu> \\<noteq> return_pmf ?x8} \\<Longrightarrow>\n  (\\<Squnion>\\<mu>\\<in>{\\<mu> \\<in> K ?x8. \\<mu> \\<noteq> return_pmf ?x8}.\n      emeasure (measure_pmf \\<mu>) {?x8})\n  < 1\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "fix s :: \"'s \\<times> ('c \\<Rightarrow> real)\" and cfg :: \"('s \\<times> ('c \\<Rightarrow> real) set) cfg\""], ["proof (state)\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "assume unbounded: \"\\<forall> c \\<in> \\<X>. snd s c > k c\" and \"cfg \\<in> R_G.cfg_on (abss s)\" \"abss s \\<in> \\<S>\""], ["proof (state)\nthis:\n  \\<forall>c\\<in>\\<X>. real (k c) < snd s c\n  cfg \\<in> R_G.cfg_on (abss s)\n  abss s \\<in> \\<S>\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "then"], ["proof (chain)\npicking this:\n  \\<forall>c\\<in>\\<X>. real (k c) < snd s c\n  cfg \\<in> R_G.cfg_on (abss s)\n  abss s \\<in> \\<S>", "have \"repcs s cfg \\<in> valid_cfg\""], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>\\<X>. real (k c) < snd s c\n  cfg \\<in> R_G.cfg_on (abss s)\n  abss s \\<in> \\<S>\n\ngoal (1 subgoal):\n 1. repcs s cfg \\<in> MDP.valid_cfg", "by (auto intro: R_G.valid_cfgI)"], ["proof (state)\nthis:\n  repcs s cfg \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "then"], ["proof (chain)\npicking this:\n  repcs s cfg \\<in> MDP.valid_cfg", "have cfg_on: \"repcs s cfg \\<in> MDP.cfg_on s\""], ["proof (prove)\nusing this:\n  repcs s cfg \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. repcs s cfg \\<in> MDP.cfg_on s", "by (auto dest: MDP.valid_cfgD)"], ["proof (state)\nthis:\n  repcs s cfg \\<in> MDP.cfg_on s\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "from \\<open>cfg \\<in> _\\<close>"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.cfg_on (abss s)", "have \"action cfg \\<in> \\<K> (abss s)\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.cfg_on (abss s)\n\ngoal (1 subgoal):\n 1. action cfg \\<in> \\<K> (abss s)", "by (rule R_G.cfg_onD_action)"], ["proof (state)\nthis:\n  action cfg \\<in> \\<K> (abss s)\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "have \"rept s (action cfg) \\<noteq> return_pmf s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rept s (action cfg) \\<noteq> return_pmf s", "proof (rule ccontr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. rept s (action cfg) = return_pmf s \\<Longrightarrow> False", "assume \"rept s (action cfg) = return_pmf s\""], ["proof (state)\nthis:\n  rept s (action cfg) = return_pmf s\n\ngoal (1 subgoal):\n 1. rept s (action cfg) = return_pmf s \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  rept s (action cfg) = return_pmf s", "have \"action cfg = return_pmf (abss s)\""], ["proof (prove)\nusing this:\n  rept s (action cfg) = return_pmf s\n\ngoal (1 subgoal):\n 1. action cfg = return_pmf (abss s)", "using abst_rept_id[OF \\<open>action cfg \\<in> _\\<close>]"], ["proof (prove)\nusing this:\n  rept s (action cfg) = return_pmf s\n  abst (rept s (action cfg)) = action cfg\n\ngoal (1 subgoal):\n 1. action cfg = return_pmf (abss s)", "by (simp add: abst_def)"], ["proof (state)\nthis:\n  action cfg = return_pmf (abss s)\n\ngoal (1 subgoal):\n 1. rept s (action cfg) = return_pmf s \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  action cfg = return_pmf (abss s)\n\ngoal (1 subgoal):\n 1. rept s (action cfg) = return_pmf s \\<Longrightarrow> False", "have \"(fst s, snd s) \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst s, snd s) \\<in> S", "using \\<open>_ \\<in> \\<S>\\<close>"], ["proof (prove)\nusing this:\n  abss s \\<in> \\<S>\n\ngoal (1 subgoal):\n 1. (fst s, snd s) \\<in> S", "by (auto dest: \\<S>_abss_S)"], ["proof (state)\nthis:\n  (fst s, snd s) \\<in> S\n\ngoal (1 subgoal):\n 1. rept s (action cfg) = return_pmf s \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  (fst s, snd s) \\<in> S\n\ngoal (1 subgoal):\n 1. rept s (action cfg) = return_pmf s \\<Longrightarrow> False", "have \"abss s = (fst s, [snd s]\\<^sub>\\<R>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abss s = (fst s, [snd s]\\<^sub>\\<R>)", "by (metis abss_S calculation(2) prod.collapse)"], ["proof (state)\nthis:\n  abss s = (fst s, [snd s]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. rept s (action cfg) = return_pmf s \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  action cfg = return_pmf (abss s)\n  (fst s, snd s) \\<in> S\n  abss s = (fst s, [snd s]\\<^sub>\\<R>)", "show False"], ["proof (prove)\nusing this:\n  action cfg = return_pmf (abss s)\n  (fst s, snd s) \\<in> S\n  abss s = (fst s, [snd s]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. False", "using \\<open>rept s _ = _\\<close> unbounded"], ["proof (prove)\nusing this:\n  action cfg = return_pmf (abss s)\n  (fst s, snd s) \\<in> S\n  abss s = (fst s, [snd s]\\<^sub>\\<R>)\n  rept s (action cfg) = return_pmf s\n  \\<forall>c\\<in>\\<X>. real (k c) < snd s c\n\ngoal (1 subgoal):\n 1. False", "unfolding rept_def"], ["proof (prove)\nusing this:\n  action cfg = return_pmf (abss s)\n  (fst s, snd s) \\<in> S\n  abss s = (fst s, [snd s]\\<^sub>\\<R>)\n  (let (l, u) = s\n   in if \\<exists>R'.\n            (l, u) \\<in> S \\<and>\n            action cfg = return_pmf (l, R') \\<and>\n            [u]\\<^sub>\\<R> = R' \\<and>\n            (\\<forall>c\\<in>\\<X>. real (k c) < u c)\n      then return_pmf (l, u \\<oplus> 5 / 10)\n      else if \\<exists>R'.\n                 (l, u) \\<in> S \\<and>\n                 action cfg = return_pmf (l, R') \\<and>\n                 R' \\<in> Succ \\<R> ([u]\\<^sub>\\<R>) \\<and>\n                 [u]\\<^sub>\\<R> \\<noteq> R' \\<and>\n                 (\\<forall>u\\<in>R'.\n                     \\<forall>c\\<in>\\<X>.\n                        \\<not> (\\<exists>d\\<le>k c. u c = real d))\n           then return_pmf\n                 (l, delayedR (SOME R'. action cfg = return_pmf (l, R')) u)\n           else SOME \\<mu>.\n                   \\<mu> \\<in> K s \\<and> abst \\<mu> = action cfg) =\n  return_pmf s\n  \\<forall>c\\<in>\\<X>. real (k c) < snd s c\n\ngoal (1 subgoal):\n 1. False", "by (cases s) (auto dest: cval_add_non_id)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rept s (action cfg) \\<noteq> return_pmf s\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "moreover"], ["proof (state)\nthis:\n  rept s (action cfg) \\<noteq> return_pmf s\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "have \"rept s (action cfg) \\<in> K s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rept s (action cfg) \\<in> K s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rept s (action cfg) \\<in> K s", "have \"action (repcs s cfg) \\<in> K s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. action (repcs s cfg) \\<in> K s", "using cfg_on"], ["proof (prove)\nusing this:\n  repcs s cfg \\<in> MDP.cfg_on s\n\ngoal (1 subgoal):\n 1. action (repcs s cfg) \\<in> K s", "by blast"], ["proof (state)\nthis:\n  action (repcs s cfg) \\<in> K s\n\ngoal (1 subgoal):\n 1. rept s (action cfg) \\<in> K s", "then"], ["proof (chain)\npicking this:\n  action (repcs s cfg) \\<in> K s", "show ?thesis"], ["proof (prove)\nusing this:\n  action (repcs s cfg) \\<in> K s\n\ngoal (1 subgoal):\n 1. rept s (action cfg) \\<in> K s", "by (simp add: repcs_def)"], ["proof (state)\nthis:\n  rept s (action cfg) \\<in> K s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rept s (action cfg) \\<in> K s\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "ultimately"], ["proof (chain)\npicking this:\n  rept s (action cfg) \\<noteq> return_pmf s\n  rept s (action cfg) \\<in> K s", "have \"rept s (action cfg) \\<in> ?K s\""], ["proof (prove)\nusing this:\n  rept s (action cfg) \\<noteq> return_pmf s\n  rept s (action cfg) \\<in> K s\n\ngoal (1 subgoal):\n 1. rept s (action cfg) \\<in> {\\<mu> \\<in> K s. \\<mu> \\<noteq> return_pmf s}", "by blast"], ["proof (state)\nthis:\n  rept s (action cfg) \\<in> {\\<mu> \\<in> K s. \\<mu> \\<noteq> return_pmf s}\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "then"], ["proof (chain)\npicking this:\n  rept s (action cfg) \\<in> {\\<mu> \\<in> K s. \\<mu> \\<noteq> return_pmf s}", "have \"measure_pmf (rept s (action cfg)) {s} \\<le> ?r s\""], ["proof (prove)\nusing this:\n  rept s (action cfg) \\<in> {\\<mu> \\<in> K s. \\<mu> \\<noteq> return_pmf s}\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (rept s (action cfg))) {s}\n    \\<le> (\\<Squnion>\\<mu>\\<in>{\\<mu> \\<in> K s.\n                                \\<mu> \\<noteq> return_pmf s}.\n              emeasure (measure_pmf \\<mu>) {s})", "by (auto intro: Sup_upper)"], ["proof (state)\nthis:\n  emeasure (measure_pmf (rept s (action cfg))) {s}\n  \\<le> (\\<Squnion>\\<mu>\\<in>{\\<mu> \\<in> K s. \\<mu> \\<noteq> return_pmf s}.\n            emeasure (measure_pmf \\<mu>) {s})\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "moreover"], ["proof (state)\nthis:\n  emeasure (measure_pmf (rept s (action cfg))) {s}\n  \\<le> (\\<Squnion>\\<mu>\\<in>{\\<mu> \\<in> K s. \\<mu> \\<noteq> return_pmf s}.\n            emeasure (measure_pmf \\<mu>) {s})\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "have \"rept s (action cfg) = action (repcs s cfg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rept s (action cfg) = action (repcs s cfg)", "by (simp add: repcs_def)"], ["proof (state)\nthis:\n  rept s (action cfg) = action (repcs s cfg)\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "ultimately"], ["proof (chain)\npicking this:\n  emeasure (measure_pmf (rept s (action cfg))) {s}\n  \\<le> (\\<Squnion>\\<mu>\\<in>{\\<mu> \\<in> K s. \\<mu> \\<noteq> return_pmf s}.\n            emeasure (measure_pmf \\<mu>) {s})\n  rept s (action cfg) = action (repcs s cfg)", "have \"measure_pmf (action (repcs s cfg)) {s} \\<le> ?r s\""], ["proof (prove)\nusing this:\n  emeasure (measure_pmf (rept s (action cfg))) {s}\n  \\<le> (\\<Squnion>\\<mu>\\<in>{\\<mu> \\<in> K s. \\<mu> \\<noteq> return_pmf s}.\n            emeasure (measure_pmf \\<mu>) {s})\n  rept s (action cfg) = action (repcs s cfg)\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (action (repcs s cfg))) {s}\n    \\<le> (\\<Squnion>\\<mu>\\<in>{\\<mu> \\<in> K s.\n                                \\<mu> \\<noteq> return_pmf s}.\n              emeasure (measure_pmf \\<mu>) {s})", "by auto"], ["proof (state)\nthis:\n  emeasure (measure_pmf (action (repcs s cfg))) {s}\n  \\<le> (\\<Squnion>\\<mu>\\<in>{\\<mu> \\<in> K s. \\<mu> \\<noteq> return_pmf s}.\n            emeasure (measure_pmf \\<mu>) {s})\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "note this \\<open>rept s (action cfg) \\<in> ?K s\\<close>"], ["proof (state)\nthis:\n  emeasure (measure_pmf (action (repcs s cfg))) {s}\n  \\<le> (\\<Squnion>\\<mu>\\<in>{\\<mu> \\<in> K s. \\<mu> \\<noteq> return_pmf s}.\n            emeasure (measure_pmf \\<mu>) {s})\n  rept s (action cfg) \\<in> {\\<mu> \\<in> K s. \\<mu> \\<noteq> return_pmf s}\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < snd ?s10 c;\n   ?cfga10 \\<in> R_G.cfg_on (abss ?s10); abss ?s10 \\<in> \\<S>\\<rbrakk>\n  \\<Longrightarrow> emeasure (measure_pmf (action (repcs ?s10 ?cfga10)))\n                     {?s10}\n                    \\<le> (\\<Squnion>\\<mu>\\<in>{\\<mu> \\<in> K ?s10.\n          \\<mu> \\<noteq> return_pmf ?s10}.\n                              emeasure (measure_pmf \\<mu>) {?s10})\n  \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < snd ?s10 c;\n   ?cfga10 \\<in> R_G.cfg_on (abss ?s10); abss ?s10 \\<in> \\<S>\\<rbrakk>\n  \\<Longrightarrow> rept ?s10 (action ?cfga10)\n                    \\<in> {\\<mu> \\<in> K ?s10.\n                           \\<mu> \\<noteq> return_pmf ?s10}\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "note * = this"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < snd ?s10 c;\n   ?cfga10 \\<in> R_G.cfg_on (abss ?s10); abss ?s10 \\<in> \\<S>\\<rbrakk>\n  \\<Longrightarrow> emeasure (measure_pmf (action (repcs ?s10 ?cfga10)))\n                     {?s10}\n                    \\<le> (\\<Squnion>\\<mu>\\<in>{\\<mu> \\<in> K ?s10.\n          \\<mu> \\<noteq> return_pmf ?s10}.\n                              emeasure (measure_pmf \\<mu>) {?s10})\n  \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < snd ?s10 c;\n   ?cfga10 \\<in> R_G.cfg_on (abss ?s10); abss ?s10 \\<in> \\<S>\\<rbrakk>\n  \\<Longrightarrow> rept ?s10 (action ?cfga10)\n                    \\<in> {\\<mu> \\<in> K ?s10.\n                           \\<mu> \\<noteq> return_pmf ?s10}\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "let ?S = \"{cfg. \\<exists> cfg' s. cfg' \\<in> R_G.valid_cfg \\<and> cfg = repcs s cfg' \\<and> abss s = state cfg'}\""], ["proof (state)\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "have start: \"repcs st cfg \\<in> ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. repcs st cfg\n    \\<in> {cfg.\n           \\<exists>cfg' s.\n              cfg' \\<in> R_G.valid_cfg \\<and>\n              cfg = repcs s cfg' \\<and> abss s = state cfg'}", "using \\<open>cfg \\<in> R_G.valid_cfg\\<close> assms"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  cfg \\<in> R_G.cfg_on (abss st)\n  st \\<in> S\n\ngoal (1 subgoal):\n 1. repcs st cfg\n    \\<in> {cfg.\n           \\<exists>cfg' s.\n              cfg' \\<in> R_G.valid_cfg \\<and>\n              cfg = repcs s cfg' \\<and> abss s = state cfg'}", "unfolding R_G_cfg_on_div_def"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  cfg \\<in> R_G.cfg_on (abss st)\n  st \\<in> S\n\ngoal (1 subgoal):\n 1. repcs st cfg\n    \\<in> {cfg.\n           \\<exists>cfg' s.\n              cfg' \\<in> R_G.valid_cfg \\<and>\n              cfg = repcs s cfg' \\<and> abss s = state cfg'}", "by clarsimp (inst_existentials cfg \"fst st\" \"snd st\", auto)"], ["proof (state)\nthis:\n  repcs st cfg\n  \\<in> {cfg.\n         \\<exists>cfg' s.\n            cfg' \\<in> R_G.valid_cfg \\<and>\n            cfg = repcs s cfg' \\<and> abss s = state cfg'}\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "have step: \"y \\<in> ?S\" if \"y \\<in> K_cfg x\" \"x \\<in> ?S\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> {cfg.\n             \\<exists>cfg' s.\n                cfg' \\<in> R_G.valid_cfg \\<and>\n                cfg = repcs s cfg' \\<and> abss s = state cfg'}", "using that"], ["proof (prove)\nusing this:\n  y \\<in> set_pmf (K_cfg x)\n  x \\<in> {cfg.\n           \\<exists>cfg' s.\n              cfg' \\<in> R_G.valid_cfg \\<and>\n              cfg = repcs s cfg' \\<and> abss s = state cfg'}\n\ngoal (1 subgoal):\n 1. y \\<in> {cfg.\n             \\<exists>cfg' s.\n                cfg' \\<in> R_G.valid_cfg \\<and>\n                cfg = repcs s cfg' \\<and> abss s = state cfg'}", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cfg' a b.\n       \\<lbrakk>y \\<in> set_pmf (K_cfg (repcs (a, b) cfg'));\n        cfg' \\<in> R_G.valid_cfg; abss (a, b) = state cfg';\n        x = repcs (a, b) cfg'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg' s.\n                            cfg' \\<in> R_G.valid_cfg \\<and>\n                            y = repcs s cfg' \\<and> abss s = state cfg'", "subgoal for cfg' l u"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> set_pmf (K_cfg (repcs (l, u) cfg'));\n     cfg' \\<in> R_G.valid_cfg; abss (l, u) = state cfg';\n     x = repcs (l, u) cfg'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>cfg' s.\n                         cfg' \\<in> R_G.valid_cfg \\<and>\n                         y = repcs s cfg' \\<and> abss s = state cfg'", "apply (inst_existentials \"absc y\" \"state y\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y \\<in> set_pmf (K_cfg (repcs (l, u) cfg'));\n     cfg' \\<in> R_G.valid_cfg; abss (l, u) = state cfg';\n     x = repcs (l, u) cfg'\\<rbrakk>\n    \\<Longrightarrow> absc y \\<in> R_G.valid_cfg\n 2. \\<lbrakk>y \\<in> set_pmf (K_cfg (repcs (l, u) cfg'));\n     cfg' \\<in> R_G.valid_cfg; abss (l, u) = state cfg';\n     x = repcs (l, u) cfg'\\<rbrakk>\n    \\<Longrightarrow> y = repcs (state y) (absc y)\n 3. \\<lbrakk>y \\<in> set_pmf (K_cfg (repcs (l, u) cfg'));\n     cfg' \\<in> R_G.valid_cfg; abss (l, u) = state cfg';\n     x = repcs (l, u) cfg'\\<rbrakk>\n    \\<Longrightarrow> abss (state y) = state (absc y)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> set_pmf (K_cfg (repcs (l, u) cfg'));\n     cfg' \\<in> R_G.valid_cfg; abss (l, u) = state cfg';\n     x = repcs (l, u) cfg'\\<rbrakk>\n    \\<Longrightarrow> absc y \\<in> R_G.valid_cfg", "by blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y \\<in> set_pmf (K_cfg (repcs (l, u) cfg'));\n     cfg' \\<in> R_G.valid_cfg; abss (l, u) = state cfg';\n     x = repcs (l, u) cfg'\\<rbrakk>\n    \\<Longrightarrow> y = repcs (state y) (absc y)\n 2. \\<lbrakk>y \\<in> set_pmf (K_cfg (repcs (l, u) cfg'));\n     cfg' \\<in> R_G.valid_cfg; abss (l, u) = state cfg';\n     x = repcs (l, u) cfg'\\<rbrakk>\n    \\<Longrightarrow> abss (state y) = state (absc y)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> set_pmf (K_cfg (repcs (l, u) cfg'));\n     cfg' \\<in> R_G.valid_cfg; abss (l, u) = state cfg';\n     x = repcs (l, u) cfg'\\<rbrakk>\n    \\<Longrightarrow> y = repcs (state y) (absc y)", "by (metis\n            K_cfg_valid_cfgD R_G.valid_cfgD R_G.valid_cfg_state_in_S absc_repcs_id cont_absc_1\n            cont_repcs1 repcs_valid\n            )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> set_pmf (K_cfg (repcs (l, u) cfg'));\n     cfg' \\<in> R_G.valid_cfg; abss (l, u) = state cfg';\n     x = repcs (l, u) cfg'\\<rbrakk>\n    \\<Longrightarrow> abss (state y) = state (absc y)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> set_pmf (K_cfg (repcs (l, u) cfg'));\n     cfg' \\<in> R_G.valid_cfg; abss (l, u) = state cfg';\n     x = repcs (l, u) cfg'\\<rbrakk>\n    \\<Longrightarrow> abss (state y) = state (absc y)", "by (simp add: state_absc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>?y8 \\<in> set_pmf (K_cfg ?x8);\n   ?x8\n   \\<in> {cfg.\n          \\<exists>cfg' s.\n             cfg' \\<in> R_G.valid_cfg \\<and>\n             cfg = repcs s cfg' \\<and> abss s = state cfg'}\\<rbrakk>\n  \\<Longrightarrow> ?y8\n                    \\<in> {cfg.\n                           \\<exists>cfg' s.\n                              cfg' \\<in> R_G.valid_cfg \\<and>\n                              cfg = repcs s cfg' \\<and> abss s = state cfg'}\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "have **: \"x \\<in> ?S\" if \"(repcs st cfg, x) \\<in> MDP.MC.acc\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {cfg.\n             \\<exists>cfg' s.\n                cfg' \\<in> R_G.valid_cfg \\<and>\n                cfg = repcs s cfg' \\<and> abss s = state cfg'}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> {cfg.\n             \\<exists>cfg' s.\n                cfg' \\<in> R_G.valid_cfg \\<and>\n                cfg = repcs s cfg' \\<and> abss s = state cfg'}", "from MDP.MC.acc_relfunD[OF that]"], ["proof (chain)\npicking this:\n  (\\<And>n.\n      ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ n) (repcs st cfg)\n       x \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain n where \"((\\<lambda> a b. b \\<in> K_cfg a) ^^ n) (repcs st cfg) x\""], ["proof (prove)\nusing this:\n  (\\<And>n.\n      ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ n) (repcs st cfg)\n       x \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ n) (repcs st cfg)\n         x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ n) (repcs st cfg) x\n\ngoal (1 subgoal):\n 1. x \\<in> {cfg.\n             \\<exists>cfg' s.\n                cfg' \\<in> R_G.valid_cfg \\<and>\n                cfg = repcs s cfg' \\<and> abss s = state cfg'}", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ n) (repcs st cfg) x", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ n) (repcs st cfg) x\n\ngoal (1 subgoal):\n 1. x \\<in> {cfg.\n             \\<exists>cfg' s.\n                cfg' \\<in> R_G.valid_cfg \\<and>\n                cfg = repcs s cfg' \\<and> abss s = state cfg'}", "proof (induction n arbitrary: x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ 0) (repcs st cfg)\n        x \\<Longrightarrow>\n       x \\<in> {cfg.\n                \\<exists>cfg' s.\n                   cfg' \\<in> R_G.valid_cfg \\<and>\n                   cfg = repcs s cfg' \\<and> abss s = state cfg'}\n 2. \\<And>n x.\n       \\<lbrakk>\\<And>x.\n                   ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ n)\n                    (repcs st cfg) x \\<Longrightarrow>\n                   x \\<in> {cfg.\n                            \\<exists>cfg' s.\n                               cfg' \\<in> R_G.valid_cfg \\<and>\n                               cfg = repcs s cfg' \\<and>\n                               abss s = state cfg'};\n        ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ Suc n) (repcs st cfg)\n         x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {cfg.\n                                  \\<exists>cfg' s.\n                                     cfg' \\<in> R_G.valid_cfg \\<and>\n                                     cfg = repcs s cfg' \\<and>\n                                     abss s = state cfg'}", "(* XXX Extract induction rule *)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ 0) (repcs st cfg)\n        x \\<Longrightarrow>\n       x \\<in> {cfg.\n                \\<exists>cfg' s.\n                   cfg' \\<in> R_G.valid_cfg \\<and>\n                   cfg = repcs s cfg' \\<and> abss s = state cfg'}\n 2. \\<And>n x.\n       \\<lbrakk>\\<And>x.\n                   ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ n)\n                    (repcs st cfg) x \\<Longrightarrow>\n                   x \\<in> {cfg.\n                            \\<exists>cfg' s.\n                               cfg' \\<in> R_G.valid_cfg \\<and>\n                               cfg = repcs s cfg' \\<and>\n                               abss s = state cfg'};\n        ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ Suc n) (repcs st cfg)\n         x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {cfg.\n                                  \\<exists>cfg' s.\n                                     cfg' \\<in> R_G.valid_cfg \\<and>\n                                     cfg = repcs s cfg' \\<and>\n                                     abss s = state cfg'}", "case 0"], ["proof (state)\nthis:\n  ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ 0) (repcs st cfg) x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ 0) (repcs st cfg)\n        x \\<Longrightarrow>\n       x \\<in> {cfg.\n                \\<exists>cfg' s.\n                   cfg' \\<in> R_G.valid_cfg \\<and>\n                   cfg = repcs s cfg' \\<and> abss s = state cfg'}\n 2. \\<And>n x.\n       \\<lbrakk>\\<And>x.\n                   ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ n)\n                    (repcs st cfg) x \\<Longrightarrow>\n                   x \\<in> {cfg.\n                            \\<exists>cfg' s.\n                               cfg' \\<in> R_G.valid_cfg \\<and>\n                               cfg = repcs s cfg' \\<and>\n                               abss s = state cfg'};\n        ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ Suc n) (repcs st cfg)\n         x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {cfg.\n                                  \\<exists>cfg' s.\n                                     cfg' \\<in> R_G.valid_cfg \\<and>\n                                     cfg = repcs s cfg' \\<and>\n                                     abss s = state cfg'}", "with start"], ["proof (chain)\npicking this:\n  repcs st cfg\n  \\<in> {cfg.\n         \\<exists>cfg' s.\n            cfg' \\<in> R_G.valid_cfg \\<and>\n            cfg = repcs s cfg' \\<and> abss s = state cfg'}\n  ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ 0) (repcs st cfg) x", "show ?case"], ["proof (prove)\nusing this:\n  repcs st cfg\n  \\<in> {cfg.\n         \\<exists>cfg' s.\n            cfg' \\<in> R_G.valid_cfg \\<and>\n            cfg = repcs s cfg' \\<and> abss s = state cfg'}\n  ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ 0) (repcs st cfg) x\n\ngoal (1 subgoal):\n 1. x \\<in> {cfg.\n             \\<exists>cfg' s.\n                cfg' \\<in> R_G.valid_cfg \\<and>\n                cfg = repcs s cfg' \\<and> abss s = state cfg'}", "by simp"], ["proof (state)\nthis:\n  x \\<in> {cfg.\n           \\<exists>cfg' s.\n              cfg' \\<in> R_G.valid_cfg \\<and>\n              cfg = repcs s cfg' \\<and> abss s = state cfg'}\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       \\<lbrakk>\\<And>x.\n                   ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ n)\n                    (repcs st cfg) x \\<Longrightarrow>\n                   x \\<in> {cfg.\n                            \\<exists>cfg' s.\n                               cfg' \\<in> R_G.valid_cfg \\<and>\n                               cfg = repcs s cfg' \\<and>\n                               abss s = state cfg'};\n        ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ Suc n) (repcs st cfg)\n         x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {cfg.\n                                  \\<exists>cfg' s.\n                                     cfg' \\<in> R_G.valid_cfg \\<and>\n                                     cfg = repcs s cfg' \\<and>\n                                     abss s = state cfg'}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n x.\n       \\<lbrakk>\\<And>x.\n                   ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ n)\n                    (repcs st cfg) x \\<Longrightarrow>\n                   x \\<in> {cfg.\n                            \\<exists>cfg' s.\n                               cfg' \\<in> R_G.valid_cfg \\<and>\n                               cfg = repcs s cfg' \\<and>\n                               abss s = state cfg'};\n        ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ Suc n) (repcs st cfg)\n         x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {cfg.\n                                  \\<exists>cfg' s.\n                                     cfg' \\<in> R_G.valid_cfg \\<and>\n                                     cfg = repcs s cfg' \\<and>\n                                     abss s = state cfg'}", "case (Suc n)"], ["proof (state)\nthis:\n  ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ n) (repcs st cfg)\n   ?x8 \\<Longrightarrow>\n  ?x8\n  \\<in> {cfg.\n         \\<exists>cfg' s.\n            cfg' \\<in> R_G.valid_cfg \\<and>\n            cfg = repcs s cfg' \\<and> abss s = state cfg'}\n  ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ Suc n) (repcs st cfg) x\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       \\<lbrakk>\\<And>x.\n                   ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ n)\n                    (repcs st cfg) x \\<Longrightarrow>\n                   x \\<in> {cfg.\n                            \\<exists>cfg' s.\n                               cfg' \\<in> R_G.valid_cfg \\<and>\n                               cfg = repcs s cfg' \\<and>\n                               abss s = state cfg'};\n        ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ Suc n) (repcs st cfg)\n         x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {cfg.\n                                  \\<exists>cfg' s.\n                                     cfg' \\<in> R_G.valid_cfg \\<and>\n                                     cfg = repcs s cfg' \\<and>\n                                     abss s = state cfg'}", "from this(2)[simplified]"], ["proof (chain)\npicking this:\n  ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ n OO\n   (\\<lambda>a b. b \\<in> set_pmf (K_cfg a)))\n   (repcs st cfg) x", "show ?case"], ["proof (prove)\nusing this:\n  ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ n OO\n   (\\<lambda>a b. b \\<in> set_pmf (K_cfg a)))\n   (repcs st cfg) x\n\ngoal (1 subgoal):\n 1. x \\<in> {cfg.\n             \\<exists>cfg' s.\n                cfg' \\<in> R_G.valid_cfg \\<and>\n                cfg = repcs s cfg' \\<and> abss s = state cfg'}", "by (elim relcomppE step Suc.IH)"], ["proof (state)\nthis:\n  x \\<in> {cfg.\n           \\<exists>cfg' s.\n              cfg' \\<in> R_G.valid_cfg \\<and>\n              cfg = repcs s cfg' \\<and> abss s = state cfg'}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> {cfg.\n           \\<exists>cfg' s.\n              cfg' \\<in> R_G.valid_cfg \\<and>\n              cfg = repcs s cfg' \\<and> abss s = state cfg'}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (repcs st cfg, ?x8) \\<in> MDP.MC.acc \\<Longrightarrow>\n  ?x8\n  \\<in> {cfg.\n         \\<exists>cfg' s.\n            cfg' \\<in> R_G.valid_cfg \\<and>\n            cfg = repcs s cfg' \\<and> abss s = state cfg'}\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "have ***: \"almost_everywhere (MDP.MC.T (repcs st cfg)) (alw (HLD ?S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_everywhere (MDP.MC.T (repcs st cfg))\n     (alw (HLD {cfg.\n                \\<exists>cfg' s.\n                   cfg' \\<in> R_G.valid_cfg \\<and>\n                   cfg = repcs s cfg' \\<and> abss s = state cfg'}))", "by (rule AE_mp[OF MDP.MC.AE_T_reachable]) (fastforce dest: ** simp: HLD_iff elim: alw_mono)"], ["proof (state)\nthis:\n  almost_everywhere (MDP.MC.T (repcs st cfg))\n   (alw (HLD {cfg.\n              \\<exists>cfg' s.\n                 cfg' \\<in> R_G.valid_cfg \\<and>\n                 cfg = repcs s cfg' \\<and> abss s = state cfg'}))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "have \"(AE \\<omega> in ?M. ?P \\<omega>) \\<longleftrightarrow>\n    (AE \\<omega> in ?M. \\<forall> s :: ('s \\<times> ('c \\<Rightarrow> real)).\n      (\\<forall> c \\<in> \\<X>. snd s c > k c) \\<and> s \\<in> state ` (MDP.MC.acc `` {repcs st cfg}) \\<longrightarrow>\n      \\<not> (ev (alw (\\<lambda> xs. shd xs = s))) (smap state \\<omega>))\" (is \"?L \\<longleftrightarrow> ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (AE \\<omega> in MDP.MC.T\n                     (repcs st\n                       cfg). \\<forall>s.\n                                (\\<forall>c\\<in>\\<X>.\n                                    real (k c) < snd s c) \\<longrightarrow>\n                                \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n  (smap state \\<omega>)) =\n    (AE \\<omega> in MDP.MC.T\n                     (repcs st\n                       cfg). \\<forall>s.\n                                (\\<forall>c\\<in>\\<X>.\n                                    real (k c) < snd s c) \\<and>\n                                s \\<in> state `\n  MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n                                \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n  (smap state \\<omega>))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>) \\<Longrightarrow>\n    AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<and>\n                               s \\<in> state `\n MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)\n 2. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<and>\n                               s \\<in> state `\n MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>) \\<Longrightarrow>\n    AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "assume ?L"], ["proof (state)\nthis:\n  AE \\<omega> in MDP.MC.T\n                  (repcs st\n                    cfg). \\<forall>s.\n                             (\\<forall>c\\<in>\\<X>.\n                                 real (k c) < snd s c) \\<longrightarrow>\n                             \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n                                     (smap state \\<omega>)\n\ngoal (2 subgoals):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>) \\<Longrightarrow>\n    AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<and>\n                               s \\<in> state `\n MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)\n 2. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<and>\n                               s \\<in> state `\n MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>) \\<Longrightarrow>\n    AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "then"], ["proof (chain)\npicking this:\n  AE \\<omega> in MDP.MC.T\n                  (repcs st\n                    cfg). \\<forall>s.\n                             (\\<forall>c\\<in>\\<X>.\n                                 real (k c) < snd s c) \\<longrightarrow>\n                             \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n                                     (smap state \\<omega>)", "show ?R"], ["proof (prove)\nusing this:\n  AE \\<omega> in MDP.MC.T\n                  (repcs st\n                    cfg). \\<forall>s.\n                             (\\<forall>c\\<in>\\<X>.\n                                 real (k c) < snd s c) \\<longrightarrow>\n                             \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n                                     (smap state \\<omega>)\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<and>\n                               s \\<in> state `\n MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "by eventually_elim auto"], ["proof (state)\nthis:\n  AE \\<omega> in MDP.MC.T\n                  (repcs st\n                    cfg). \\<forall>s.\n                             (\\<forall>c\\<in>\\<X>.\n                                 real (k c) < snd s c) \\<and>\n                             s \\<in> state `\n                                     MDP.MC.acc ``\n                                     {repcs st cfg} \\<longrightarrow>\n                             \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n                                     (smap state \\<omega>)\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<and>\n                               s \\<in> state `\n MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>) \\<Longrightarrow>\n    AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<and>\n                               s \\<in> state `\n MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>) \\<Longrightarrow>\n    AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "assume ?R"], ["proof (state)\nthis:\n  AE \\<omega> in MDP.MC.T\n                  (repcs st\n                    cfg). \\<forall>s.\n                             (\\<forall>c\\<in>\\<X>.\n                                 real (k c) < snd s c) \\<and>\n                             s \\<in> state `\n                                     MDP.MC.acc ``\n                                     {repcs st cfg} \\<longrightarrow>\n                             \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n                                     (smap state \\<omega>)\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<and>\n                               s \\<in> state `\n MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>) \\<Longrightarrow>\n    AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "with MDP.MC.AE_T_reachable[of \"repcs st cfg\"]"], ["proof (chain)\npicking this:\n  almost_everywhere (MDP.MC.T (repcs st cfg))\n   (alw (HLD (MDP.MC.acc `` {repcs st cfg})))\n  AE \\<omega> in MDP.MC.T\n                  (repcs st\n                    cfg). \\<forall>s.\n                             (\\<forall>c\\<in>\\<X>.\n                                 real (k c) < snd s c) \\<and>\n                             s \\<in> state `\n                                     MDP.MC.acc ``\n                                     {repcs st cfg} \\<longrightarrow>\n                             \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n                                     (smap state \\<omega>)", "show ?L"], ["proof (prove)\nusing this:\n  almost_everywhere (MDP.MC.T (repcs st cfg))\n   (alw (HLD (MDP.MC.acc `` {repcs st cfg})))\n  AE \\<omega> in MDP.MC.T\n                  (repcs st\n                    cfg). \\<forall>s.\n                             (\\<forall>c\\<in>\\<X>.\n                                 real (k c) < snd s c) \\<and>\n                             s \\<in> state `\n                                     MDP.MC.acc ``\n                                     {repcs st cfg} \\<longrightarrow>\n                             \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n                                     (smap state \\<omega>)\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "proof (eventually_elim, intro allI impI notI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<omega> s.\n       \\<lbrakk>alw (HLD (MDP.MC.acc `` {repcs st cfg})) \\<omega>;\n        \\<forall>s.\n           (\\<forall>c\\<in>\\<X>. real (k c) < snd s c) \\<and>\n           s \\<in> state ` MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n           \\<not> ev (alw (\\<lambda>xs. shd xs = s)) (smap state \\<omega>);\n        almost_everywhere (MDP.MC.T (repcs st cfg))\n         (alw (HLD (MDP.MC.acc `` {repcs st cfg})));\n        AE \\<omega> in MDP.MC.T\n                        (repcs st\n                          cfg). \\<forall>s.\n                                   (\\<forall>c\\<in>\\<X>.\n real (k c) < snd s c) \\<and>\n                                   s \\<in> state `\n     MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n                                   \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n     (smap state \\<omega>);\n        \\<forall>c\\<in>\\<X>. real (k c) < snd s c;\n        ev (alw (\\<lambda>xs. shd xs = s)) (smap state \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> False", "case (1 \\<omega> s)"], ["proof (state)\nthis:\n  alw (HLD (MDP.MC.acc `` {repcs st cfg})) \\<omega>\n  \\<forall>s.\n     (\\<forall>c\\<in>\\<X>. real (k c) < snd s c) \\<and>\n     s \\<in> state ` MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n     \\<not> ev (alw (\\<lambda>xs. shd xs = s)) (smap state \\<omega>)\n  almost_everywhere (MDP.MC.T (repcs st cfg))\n   (alw (HLD (MDP.MC.acc `` {repcs st cfg})))\n  AE \\<omega> in MDP.MC.T\n                  (repcs st\n                    cfg). \\<forall>s.\n                             (\\<forall>c\\<in>\\<X>.\n                                 real (k c) < snd s c) \\<and>\n                             s \\<in> state `\n                                     MDP.MC.acc ``\n                                     {repcs st cfg} \\<longrightarrow>\n                             \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n                                     (smap state \\<omega>)\n  \\<forall>c\\<in>\\<X>. real (k c) < snd s c\n  ev (alw (\\<lambda>xs. shd xs = s)) (smap state \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega> s.\n       \\<lbrakk>alw (HLD (MDP.MC.acc `` {repcs st cfg})) \\<omega>;\n        \\<forall>s.\n           (\\<forall>c\\<in>\\<X>. real (k c) < snd s c) \\<and>\n           s \\<in> state ` MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n           \\<not> ev (alw (\\<lambda>xs. shd xs = s)) (smap state \\<omega>);\n        almost_everywhere (MDP.MC.T (repcs st cfg))\n         (alw (HLD (MDP.MC.acc `` {repcs st cfg})));\n        AE \\<omega> in MDP.MC.T\n                        (repcs st\n                          cfg). \\<forall>s.\n                                   (\\<forall>c\\<in>\\<X>.\n real (k c) < snd s c) \\<and>\n                                   s \\<in> state `\n     MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n                                   \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n     (smap state \\<omega>);\n        \\<forall>c\\<in>\\<X>. real (k c) < snd s c;\n        ev (alw (\\<lambda>xs. shd xs = s)) (smap state \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> False", "from this(1,2,5,6)"], ["proof (chain)\npicking this:\n  alw (HLD (MDP.MC.acc `` {repcs st cfg})) \\<omega>\n  \\<forall>s.\n     (\\<forall>c\\<in>\\<X>. real (k c) < snd s c) \\<and>\n     s \\<in> state ` MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n     \\<not> ev (alw (\\<lambda>xs. shd xs = s)) (smap state \\<omega>)\n  \\<forall>c\\<in>\\<X>. real (k c) < snd s c\n  ev (alw (\\<lambda>xs. shd xs = s)) (smap state \\<omega>)", "show ?case"], ["proof (prove)\nusing this:\n  alw (HLD (MDP.MC.acc `` {repcs st cfg})) \\<omega>\n  \\<forall>s.\n     (\\<forall>c\\<in>\\<X>. real (k c) < snd s c) \\<and>\n     s \\<in> state ` MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n     \\<not> ev (alw (\\<lambda>xs. shd xs = s)) (smap state \\<omega>)\n  \\<forall>c\\<in>\\<X>. real (k c) < snd s c\n  ev (alw (\\<lambda>xs. shd xs = s)) (smap state \\<omega>)\n\ngoal (1 subgoal):\n 1. False", "by (intro alw_HLD_smap alw_disjoint_ccontr[where\n              S = \"state ` MDP.MC.acc `` {repcs st cfg}\" and R = \"{s}\" and \\<omega> = \"smap state \\<omega>\"\n              ]; simp add: HLD_iff; blast)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  AE \\<omega> in MDP.MC.T\n                  (repcs st\n                    cfg). \\<forall>s.\n                             (\\<forall>c\\<in>\\<X>.\n                                 real (k c) < snd s c) \\<longrightarrow>\n                             \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n                                     (smap state \\<omega>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (AE \\<omega> in MDP.MC.T\n                   (repcs st\n                     cfg). \\<forall>s.\n                              (\\<forall>c\\<in>\\<X>.\n                                  real (k c) < snd s c) \\<longrightarrow>\n                              \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n(smap state \\<omega>)) =\n  (AE \\<omega> in MDP.MC.T\n                   (repcs st\n                     cfg). \\<forall>s.\n                              (\\<forall>c\\<in>\\<X>.\n                                  real (k c) < snd s c) \\<and>\n                              s \\<in> state `\nMDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n                              \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n(smap state \\<omega>))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "also"], ["proof (state)\nthis:\n  (AE \\<omega> in MDP.MC.T\n                   (repcs st\n                     cfg). \\<forall>s.\n                              (\\<forall>c\\<in>\\<X>.\n                                  real (k c) < snd s c) \\<longrightarrow>\n                              \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n(smap state \\<omega>)) =\n  (AE \\<omega> in MDP.MC.T\n                   (repcs st\n                     cfg). \\<forall>s.\n                              (\\<forall>c\\<in>\\<X>.\n                                  real (k c) < snd s c) \\<and>\n                              s \\<in> state `\nMDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n                              \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n(smap state \\<omega>))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "have \"\\<dots> \\<longleftrightarrow>\n      (\\<forall> s :: ('s \\<times> ('c \\<Rightarrow> real)).\n        (\\<forall> c \\<in> \\<X>. snd s c > k c) \\<and> s \\<in> state ` (MDP.MC.acc `` {repcs st cfg}) \\<longrightarrow>\n        (AE \\<omega> in ?M. \\<not> (ev (alw (\\<lambda> xs. shd xs = s))) (smap state \\<omega>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (AE \\<omega> in MDP.MC.T\n                     (repcs st\n                       cfg). \\<forall>s.\n                                (\\<forall>c\\<in>\\<X>.\n                                    real (k c) < snd s c) \\<and>\n                                s \\<in> state `\n  MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n                                \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n  (smap state \\<omega>)) =\n    (\\<forall>s.\n        (\\<forall>c\\<in>\\<X>. real (k c) < snd s c) \\<and>\n        s \\<in> state ` MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n        (AE \\<omega> in MDP.MC.T\n                         (repcs st\n                           cfg). \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n   (smap state \\<omega>)))", "using MDP.MC.countable_reachable[of \"repcs st cfg\"]"], ["proof (prove)\nusing this:\n  countable (MDP.MC.acc `` {repcs st cfg})\n\ngoal (1 subgoal):\n 1. (AE \\<omega> in MDP.MC.T\n                     (repcs st\n                       cfg). \\<forall>s.\n                                (\\<forall>c\\<in>\\<X>.\n                                    real (k c) < snd s c) \\<and>\n                                s \\<in> state `\n  MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n                                \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n  (smap state \\<omega>)) =\n    (\\<forall>s.\n        (\\<forall>c\\<in>\\<X>. real (k c) < snd s c) \\<and>\n        s \\<in> state ` MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n        (AE \\<omega> in MDP.MC.T\n                         (repcs st\n                           cfg). \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n   (smap state \\<omega>)))", "by - (rule AE_all_imp_countable,\n        auto intro: countable_subset[where B = \"state ` MDP.MC.acc `` {repcs st cfg}\"])"], ["proof (state)\nthis:\n  (AE \\<omega> in MDP.MC.T\n                   (repcs st\n                     cfg). \\<forall>s.\n                              (\\<forall>c\\<in>\\<X>.\n                                  real (k c) < snd s c) \\<and>\n                              s \\<in> state `\nMDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n                              \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n(smap state \\<omega>)) =\n  (\\<forall>s.\n      (\\<forall>c\\<in>\\<X>. real (k c) < snd s c) \\<and>\n      s \\<in> state ` MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n      (AE \\<omega> in MDP.MC.T\n                       (repcs st\n                         cfg). \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "also"], ["proof (state)\nthis:\n  (AE \\<omega> in MDP.MC.T\n                   (repcs st\n                     cfg). \\<forall>s.\n                              (\\<forall>c\\<in>\\<X>.\n                                  real (k c) < snd s c) \\<and>\n                              s \\<in> state `\nMDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n                              \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n(smap state \\<omega>)) =\n  (\\<forall>s.\n      (\\<forall>c\\<in>\\<X>. real (k c) < snd s c) \\<and>\n      s \\<in> state ` MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n      (AE \\<omega> in MDP.MC.T\n                       (repcs st\n                         cfg). \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE \\<omega> in MDP.MC.T\n                    (repcs st\n                      cfg). \\<forall>s.\n                               (\\<forall>c\\<in>\\<X>.\n                                   real (k c) < snd s c) \\<longrightarrow>\n                               \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n (smap state \\<omega>)", "unfolding calculation"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s.\n       (\\<forall>c\\<in>\\<X>. real (k c) < snd s c) \\<and>\n       s \\<in> state ` MDP.MC.acc `` {repcs st cfg} \\<longrightarrow>\n       (AE \\<omega> in MDP.MC.T\n                        (repcs st\n                          cfg). \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n  (smap state \\<omega>))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x.\n       \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < b c; (a, b) = state x;\n        (repcs st cfg, x) \\<in> MDP.MC.acc\\<rbrakk>\n       \\<Longrightarrow> AE \\<omega> in MDP.MC.T\n   (repcs st\n     cfg). \\<not> ev (alw (\\<lambda>xa. state (shd xa) = state x)) \\<omega>", "subgoal for l u x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < u c; (l, u) = state x;\n     (repcs st cfg, x) \\<in> MDP.MC.acc\\<rbrakk>\n    \\<Longrightarrow> AE \\<omega> in MDP.MC.T\n(repcs st\n  cfg). \\<not> ev (alw (\\<lambda>xa. state (shd xa) = state x)) \\<omega>", "apply (rule MDP.non_loop_tail'[simplified, of \"state x\" ?S \"?r (state x)\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < u c; (l, u) = state x;\n     (repcs st cfg, x) \\<in> MDP.MC.acc\\<rbrakk>\n    \\<Longrightarrow> \\<forall>cfg\\<in>MDP.cfg_on (state x) \\<inter>\n {cfg.\n  \\<exists>cfg' s.\n     cfg' \\<in> R_G.valid_cfg \\<and>\n     cfg = repcs s cfg' \\<and> abss s = state cfg'}.\n                         emeasure (measure_pmf (action cfg)) {state x}\n                         \\<le> (\\<Squnion>\\<mu>\\<in>{\\<mu>\n               \\<in> K (state x).\n               \\<mu> \\<noteq> return_pmf (state x)}.\n                                   emeasure (measure_pmf \\<mu>) {state x})\n 2. \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < u c; (l, u) = state x;\n     (repcs st cfg, x) \\<in> MDP.MC.acc\\<rbrakk>\n    \\<Longrightarrow> (\\<Squnion>\\<mu>\\<in>{\\<mu> \\<in> K (state x).\n      \\<mu> \\<noteq> return_pmf (state x)}.\n                          emeasure (measure_pmf \\<mu>) {state x})\n                      < 1\n 3. \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < u c; (l, u) = state x;\n     (repcs st cfg, x) \\<in> MDP.MC.acc\\<rbrakk>\n    \\<Longrightarrow> repcs st cfg \\<in> MDP.cfg_on ?y\n 4. \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < u c; (l, u) = state x;\n     (repcs st cfg, x) \\<in> MDP.MC.acc\\<rbrakk>\n    \\<Longrightarrow> almost_everywhere (MDP.MC.T (repcs st cfg))\n                       (pred_stream\n                         (\\<lambda>x.\n                             x \\<in> {cfg.\n\\<exists>cfg' s.\n   cfg' \\<in> R_G.valid_cfg \\<and>\n   cfg = repcs s cfg' \\<and> abss s = state cfg'}))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < u c; (l, u) = state x;\n     (repcs st cfg, x) \\<in> MDP.MC.acc\\<rbrakk>\n    \\<Longrightarrow> \\<forall>cfg\\<in>MDP.cfg_on (state x) \\<inter>\n {cfg.\n  \\<exists>cfg' s.\n     cfg' \\<in> R_G.valid_cfg \\<and>\n     cfg = repcs s cfg' \\<and> abss s = state cfg'}.\n                         emeasure (measure_pmf (action cfg)) {state x}\n                         \\<le> (\\<Squnion>\\<mu>\\<in>{\\<mu>\n               \\<in> K (state x).\n               \\<mu> \\<noteq> return_pmf (state x)}.\n                                   emeasure (measure_pmf \\<mu>) {state x})", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cfga cfg' a b.\n       \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < u c; (l, u) = state x;\n        (repcs st cfg, x) \\<in> MDP.MC.acc;\n        repcs (a, b) cfg' \\<in> MDP.cfg_on (state x);\n        cfg' \\<in> R_G.valid_cfg; abss (a, b) = state cfg'\\<rbrakk>\n       \\<Longrightarrow> emeasure (measure_pmf (action (repcs (a, b) cfg')))\n                          {state x}\n                         \\<le> (\\<Squnion>\\<mu>\\<in>{\\<mu>\n               \\<in> K (state x).\n               \\<mu> \\<noteq> return_pmf (state x)}.\n                                   emeasure (measure_pmf \\<mu>) {state x})", "subgoal premises prems for cfg cfg' l' u'"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (action (repcs (l', u') cfg'))) {state x}\n    \\<le> (\\<Squnion>\\<mu>\\<in>{\\<mu> \\<in> K (state x).\n                                \\<mu> \\<noteq> return_pmf (state x)}.\n              emeasure (measure_pmf \\<mu>) {state x})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (action (repcs (l', u') cfg'))) {state x}\n    \\<le> (\\<Squnion>\\<mu>\\<in>{\\<mu> \\<in> K (state x).\n                                \\<mu> \\<noteq> return_pmf (state x)}.\n              emeasure (measure_pmf \\<mu>) {state x})", "from prems"], ["proof (chain)\npicking this:\n  \\<forall>c\\<in>\\<X>. real (k c) < u c\n  (l, u) = state x\n  (repcs st cfg, x) \\<in> MDP.MC.acc\n  repcs (l', u') cfg' \\<in> MDP.cfg_on (state x)\n  cfg' \\<in> R_G.valid_cfg\n  abss (l', u') = state cfg'", "have \"state x = (l', u')\""], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>\\<X>. real (k c) < u c\n  (l, u) = state x\n  (repcs st cfg, x) \\<in> MDP.MC.acc\n  repcs (l', u') cfg' \\<in> MDP.cfg_on (state x)\n  cfg' \\<in> R_G.valid_cfg\n  abss (l', u') = state cfg'\n\ngoal (1 subgoal):\n 1. state x = (l', u')", "by (metis MDP.cfg_onD_state state_repcs)"], ["proof (state)\nthis:\n  state x = (l', u')\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (action (repcs (l', u') cfg'))) {state x}\n    \\<le> (\\<Squnion>\\<mu>\\<in>{\\<mu> \\<in> K (state x).\n                                \\<mu> \\<noteq> return_pmf (state x)}.\n              emeasure (measure_pmf \\<mu>) {state x})", "with \\<open>_ = state x\\<close>"], ["proof (chain)\npicking this:\n  (l, u) = state x\n  state x = (l', u')", "have [simp]: \"l = l'\" \"u = u'\""], ["proof (prove)\nusing this:\n  (l, u) = state x\n  state x = (l', u')\n\ngoal (1 subgoal):\n 1. l = l' &&& u = u'", "by auto"], ["proof (state)\nthis:\n  l = l'\n  u = u'\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (action (repcs (l', u') cfg'))) {state x}\n    \\<le> (\\<Squnion>\\<mu>\\<in>{\\<mu> \\<in> K (state x).\n                                \\<mu> \\<noteq> return_pmf (state x)}.\n              emeasure (measure_pmf \\<mu>) {state x})", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (action (repcs (l', u') cfg'))) {state x}\n    \\<le> (\\<Squnion>\\<mu>\\<in>{\\<mu> \\<in> K (state x).\n                                \\<mu> \\<noteq> return_pmf (state x)}.\n              emeasure (measure_pmf \\<mu>) {state x})", "unfolding \\<open>state x = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (action (repcs (l', u') cfg'))) {(l', u')}\n    \\<le> (\\<Squnion>\\<mu>\\<in>{\\<mu> \\<in> K (l', u').\n                                \\<mu> \\<noteq> return_pmf (l', u')}.\n              emeasure (measure_pmf \\<mu>) {(l', u')})", "using prems(1,3-)"], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>\\<X>. real (k c) < u c\n  (repcs st cfg, x) \\<in> MDP.MC.acc\n  repcs (l', u') cfg' \\<in> MDP.cfg_on (state x)\n  cfg' \\<in> R_G.valid_cfg\n  abss (l', u') = state cfg'\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (action (repcs (l', u') cfg'))) {(l', u')}\n    \\<le> (\\<Squnion>\\<mu>\\<in>{\\<mu> \\<in> K (l', u').\n                                \\<mu> \\<noteq> return_pmf (l', u')}.\n              emeasure (measure_pmf \\<mu>) {(l', u')})", "by (auto simp: R_G.valid_cfg_def intro: *)"], ["proof (state)\nthis:\n  emeasure (measure_pmf (action (repcs (l', u') cfg'))) {state x}\n  \\<le> (\\<Squnion>\\<mu>\\<in>{\\<mu> \\<in> K (state x).\n                              \\<mu> \\<noteq> return_pmf (state x)}.\n            emeasure (measure_pmf \\<mu>) {state x})\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < u c; (l, u) = state x;\n     (repcs st cfg, x) \\<in> MDP.MC.acc\\<rbrakk>\n    \\<Longrightarrow> (\\<Squnion>\\<mu>\\<in>{\\<mu> \\<in> K (state x).\n      \\<mu> \\<noteq> return_pmf (state x)}.\n                          emeasure (measure_pmf \\<mu>) {state x})\n                      < 1\n 2. \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < u c; (l, u) = state x;\n     (repcs st cfg, x) \\<in> MDP.MC.acc\\<rbrakk>\n    \\<Longrightarrow> repcs st cfg \\<in> MDP.cfg_on ?y\n 3. \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < u c; (l, u) = state x;\n     (repcs st cfg, x) \\<in> MDP.MC.acc\\<rbrakk>\n    \\<Longrightarrow> almost_everywhere (MDP.MC.T (repcs st cfg))\n                       (pred_stream\n                         (\\<lambda>x.\n                             x \\<in> {cfg.\n\\<exists>cfg' s.\n   cfg' \\<in> R_G.valid_cfg \\<and>\n   cfg = repcs s cfg' \\<and> abss s = state cfg'}))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < u c; (l, u) = state x;\n     (repcs st cfg, x) \\<in> MDP.MC.acc\\<rbrakk>\n    \\<Longrightarrow> (\\<Squnion>\\<mu>\\<in>{\\<mu> \\<in> K (state x).\n      \\<mu> \\<noteq> return_pmf (state x)}.\n                          emeasure (measure_pmf \\<mu>) {state x})\n                      < 1", "apply (drule **)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < u c; (l, u) = state x;\n     x \\<in> {cfg.\n              \\<exists>cfg' s.\n                 cfg' \\<in> R_G.valid_cfg \\<and>\n                 cfg = repcs s cfg' \\<and> abss s = state cfg'}\\<rbrakk>\n    \\<Longrightarrow> (\\<Squnion>\\<mu>\\<in>{\\<mu> \\<in> K (state x).\n      \\<mu> \\<noteq> return_pmf (state x)}.\n                          emeasure (measure_pmf \\<mu>) {state x})\n                      < 1", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cfg'.\n       \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < u c;\n        cfg' \\<in> R_G.valid_cfg; abss (l, u) = state cfg';\n        x = repcs (l, u) cfg'\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>x\\<in>{\\<mu> \\<in> K (l, u).\n     \\<mu> \\<noteq> return_pmf (l, u)}.\n                             emeasure (measure_pmf x) {(l, u)})\n                         < 1", "apply (rule lt_1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cfg'.\n       \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < u c;\n        cfg' \\<in> R_G.valid_cfg; abss (l, u) = state cfg';\n        x = repcs (l, u) cfg'\\<rbrakk>\n       \\<Longrightarrow> ?\\<mu>18 cfg'\n                         \\<in> {x \\<in> K (l, u).\n                                x \\<noteq> return_pmf (l, u)}", "apply (rule *)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>cfg'.\n       \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < u c;\n        cfg' \\<in> R_G.valid_cfg; abss (l, u) = state cfg';\n        x = repcs (l, u) cfg'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>c\\<in>\\<X>. real (k c) < snd (l, u) c\n 2. \\<And>cfg'.\n       \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < u c;\n        cfg' \\<in> R_G.valid_cfg; abss (l, u) = state cfg';\n        x = repcs (l, u) cfg'\\<rbrakk>\n       \\<Longrightarrow> ?cfga30 cfg' \\<in> R_G.cfg_on (abss (l, u))\n 3. \\<And>cfg'.\n       \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < u c;\n        cfg' \\<in> R_G.valid_cfg; abss (l, u) = state cfg';\n        x = repcs (l, u) cfg'\\<rbrakk>\n       \\<Longrightarrow> abss (l, u) \\<in> \\<S>", "apply (auto dest: R_G.valid_cfg_state_in_S R_G.valid_cfgD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < u c; (l, u) = state x;\n     (repcs st cfg, x) \\<in> MDP.MC.acc\\<rbrakk>\n    \\<Longrightarrow> repcs st cfg \\<in> MDP.cfg_on ?y\n 2. \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < u c; (l, u) = state x;\n     (repcs st cfg, x) \\<in> MDP.MC.acc\\<rbrakk>\n    \\<Longrightarrow> almost_everywhere (MDP.MC.T (repcs st cfg))\n                       (pred_stream\n                         (\\<lambda>x.\n                             x \\<in> {cfg.\n\\<exists>cfg' s.\n   cfg' \\<in> R_G.valid_cfg \\<and>\n   cfg = repcs s cfg' \\<and> abss s = state cfg'}))", "apply (rule MDP.valid_cfgD[OF \\<open>repcs st cfg \\<in> valid_cfg\\<close>]; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < u c; (l, u) = state x;\n     (repcs st cfg, x) \\<in> MDP.MC.acc\\<rbrakk>\n    \\<Longrightarrow> almost_everywhere (MDP.MC.T (repcs st cfg))\n                       (pred_stream\n                         (\\<lambda>x.\n                             x \\<in> {cfg.\n\\<exists>cfg' s.\n   cfg' \\<in> R_G.valid_cfg \\<and>\n   cfg = repcs s cfg' \\<and> abss s = state cfg'}))", "using ***"], ["proof (prove)\nusing this:\n  almost_everywhere (MDP.MC.T (repcs st cfg))\n   (alw (HLD {cfg.\n              \\<exists>cfg' s.\n                 cfg' \\<in> R_G.valid_cfg \\<and>\n                 cfg = repcs s cfg' \\<and> abss s = state cfg'}))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < u c; (l, u) = state x;\n     (repcs st cfg, x) \\<in> MDP.MC.acc\\<rbrakk>\n    \\<Longrightarrow> almost_everywhere (MDP.MC.T (repcs st cfg))\n                       (pred_stream\n                         (\\<lambda>x.\n                             x \\<in> {cfg.\n\\<exists>cfg' s.\n   cfg' \\<in> R_G.valid_cfg \\<and>\n   cfg = repcs s cfg' \\<and> abss s = state cfg'}))", "unfolding alw_holds_pred_stream_iff[symmetric] HLD_def"], ["proof (prove)\nusing this:\n  almost_everywhere (MDP.MC.T (repcs st cfg))\n   (alw (holds\n          (\\<lambda>x.\n              x \\<in> {cfg.\n                       \\<exists>cfg' s.\n                          cfg' \\<in> R_G.valid_cfg \\<and>\n                          cfg = repcs s cfg' \\<and> abss s = state cfg'})))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>c\\<in>\\<X>. real (k c) < u c; (l, u) = state x;\n     (repcs st cfg, x) \\<in> MDP.MC.acc\\<rbrakk>\n    \\<Longrightarrow> almost_everywhere (MDP.MC.T (repcs st cfg))\n                       (alw (holds\n                              (\\<lambda>x.\n                                  x \\<in> {cfg.\n     \\<exists>cfg' s.\n        cfg' \\<in> R_G.valid_cfg \\<and>\n        cfg = repcs s cfg' \\<and> abss s = state cfg'})))", "."], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  AE \\<omega> in MDP.MC.T\n                  (repcs st\n                    cfg). \\<forall>s.\n                             (\\<forall>c\\<in>\\<X>.\n                                 real (k c) < snd s c) \\<longrightarrow>\n                             \\<not> ev (alw (\\<lambda>xs. shd xs = s))\n                                     (smap state \\<omega>)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* PTA Regions *)"], ["", "subsection \\<open>Main Result\\<close>"], ["", "text_raw \\<open> \\label{thm:minmax} \\<close>"], ["", "context Probabilistic_Timed_Automaton_Regions_Reachability\nbegin"], ["", "lemma R_G_cfg_on_valid:\n  \"cfg \\<in> R_G.valid_cfg\" if \"cfg \\<in> R_G_cfg_on_div s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cfg \\<in> R_G.valid_cfg", "using that"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G_cfg_on_div s'\n\ngoal (1 subgoal):\n 1. cfg \\<in> R_G.valid_cfg", "unfolding R_G_cfg_on_div_def R_G.valid_cfg_def"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.cfg_on s' \\<inter> Collect R_G_div_cfg\n\ngoal (1 subgoal):\n 1. cfg \\<in> \\<Union> (R_G.cfg_on ` \\<S>)", "by auto"], ["", "lemma cfg_on_valid:\n  \"cfg \\<in> valid_cfg\" if \"cfg \\<in> cfg_on_div s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cfg \\<in> MDP.valid_cfg", "using that"], ["proof (prove)\nusing this:\n  cfg \\<in> cfg_on_div s\n\ngoal (1 subgoal):\n 1. cfg \\<in> MDP.valid_cfg", "unfolding cfg_on_div_def MDP.valid_cfg_def"], ["proof (prove)\nusing this:\n  cfg \\<in> MDP.cfg_on s \\<inter> Collect div_cfg\n\ngoal (1 subgoal):\n 1. cfg \\<in> \\<Union> (MDP.cfg_on ` S)", "by auto"], ["", "abbreviation \"path_measure P cfg \\<equiv> emeasure (MDP.T cfg) {x\\<in>space MDP.St. P x}\""], ["", "abbreviation \"R_G_path_measure P cfg \\<equiv> emeasure (R_G.T cfg) {x\\<in>space R_G.St. P x}\""], ["", "abbreviation \"progressive st \\<equiv> cfg_on_div st \\<inter> {cfg. alternating cfg}\""], ["", "abbreviation \"R_G_progressive st \\<equiv> R_G_cfg_on_div st \\<inter> {cfg. alternating cfg}\""], ["", "text \\<open>Summary of our results on divergent configurations:\\<close>"], ["", "lemma absc_valid_cfg_eq:\n  \"absc ` progressive s = R_G_progressive s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. absc ` (cfg_on_div s \\<inter> {cfg. alternating cfg}) =\n    R_G_cfg_on_div s' \\<inter> {cfg. alternating cfg}", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> cfg_on_div s; alternating xa\\<rbrakk>\n       \\<Longrightarrow> absc xa \\<in> R_G_cfg_on_div s'\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> cfg_on_div s; alternating xa\\<rbrakk>\n       \\<Longrightarrow> alternating (absc xa)\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> R_G_cfg_on_div s'; alternating x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> absc `\n                                 (cfg_on_div s \\<inter>\n                                  {cfg. alternating cfg})", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xa_ \\<in> cfg_on_div s; alternating xa_\\<rbrakk>\n    \\<Longrightarrow> absc xa_ \\<in> R_G_cfg_on_div s'", "unfolding s'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xa_ \\<in> cfg_on_div s; alternating xa_\\<rbrakk>\n    \\<Longrightarrow> absc xa_ \\<in> R_G_cfg_on_div (abss s)", "by (rule cfg_on_div_absc) auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> cfg_on_div s; alternating xa\\<rbrakk>\n       \\<Longrightarrow> alternating (absc xa)\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> R_G_cfg_on_div s'; alternating x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> absc `\n                                 (cfg_on_div s \\<inter>\n                                  {cfg. alternating cfg})", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xa_ \\<in> cfg_on_div s; alternating xa_\\<rbrakk>\n    \\<Longrightarrow> alternating (absc xa_)", "by (simp add: AE_alw_ev_same_loc_iff cfg_on_valid)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> R_G_cfg_on_div s'; alternating x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> absc `\n                                 (cfg_on_div s \\<inter>\n                                  {cfg. alternating cfg})", "subgoal for cfg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cfg \\<in> R_G_cfg_on_div s'; alternating cfg\\<rbrakk>\n    \\<Longrightarrow> cfg\n                      \\<in> absc `\n                            (cfg_on_div s \\<inter> {cfg. alternating cfg})", "unfolding s'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cfg \\<in> R_G_cfg_on_div (abss s); alternating cfg\\<rbrakk>\n    \\<Longrightarrow> cfg\n                      \\<in> absc `\n                            (cfg_on_div s \\<inter> {cfg. alternating cfg})", "by (frule cfg_on_div_repcs_strong)\n       (auto 4 4\n          simp: s'_def R_G_cfg_on_div_def AE_alw_ev_same_loc_iff'[symmetric]\n          intro: R_G_cfg_on_valid absc_repcs_id[symmetric]\n       )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Main theorem:\\<close>"], ["", "theorem Min_Max_reachability:\n  notes in_space_UNIV[measurable] and [iff] = pred_stream_iff\n  shows\n  \"(\\<Squnion>cfg\\<in> progressive s.      path_measure     (\\<lambda> x. (holds \\<phi>  suntil holds \\<psi>)  (s  ## x)) cfg)\n = (\\<Squnion>cfg\\<in> R_G_progressive s'. R_G_path_measure (\\<lambda> x. (holds \\<phi>' suntil holds \\<psi>') (s' ## x)) cfg)\n \\<and> (\\<Sqinter>cfg\\<in> progressive s.      path_measure     (\\<lambda> x. (holds \\<phi>  suntil holds \\<psi>)  (s  ## x)) cfg)\n = (\\<Sqinter>cfg\\<in> R_G_progressive s'. R_G_path_measure (\\<lambda> x. (holds \\<phi>' suntil holds \\<psi>') (s' ## x)) cfg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>cfg\\<in>cfg_on_div s \\<inter> {cfg. alternating cfg}.\n        emeasure (MDP.T cfg)\n         {x \\<in> space MDP.St.\n          (holds \\<phi> suntil holds \\<psi>) (s ## x)}) =\n    (\\<Squnion>cfg\\<in>R_G_cfg_on_div s' \\<inter> {cfg. alternating cfg}.\n        emeasure (R_G.T cfg)\n         {x \\<in> space R_G.St.\n          (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}) \\<and>\n    (\\<Sqinter>cfg\\<in>cfg_on_div s \\<inter> {cfg. alternating cfg}.\n        emeasure (MDP.T cfg)\n         {x \\<in> space MDP.St.\n          (holds \\<phi> suntil holds \\<psi>) (s ## x)}) =\n    (\\<Sqinter>cfg\\<in>R_G_cfg_on_div s' \\<inter> {cfg. alternating cfg}.\n        emeasure (R_G.T cfg)\n         {x \\<in> space R_G.St.\n          (holds \\<phi>' suntil holds \\<psi>') (s' ## x)})", "proof (rule SUP_eq_and_INF_eq; rule bexI[rotated]; erule IntE)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<in> cfg_on_div s;\n        i \\<in> {cfg. alternating cfg}\\<rbrakk>\n       \\<Longrightarrow> ?j11 i\n                         \\<in> R_G_cfg_on_div s' \\<inter>\n                               {cfg. alternating cfg}\n 2. \\<And>i.\n       \\<lbrakk>i \\<in> cfg_on_div s;\n        i \\<in> {cfg. alternating cfg}\\<rbrakk>\n       \\<Longrightarrow> emeasure (MDP.T i)\n                          {x \\<in> space MDP.St.\n                           (holds \\<phi> suntil holds \\<psi>) (s ## x)} =\n                         emeasure (R_G.T (?j11 i))\n                          {x \\<in> space R_G.St.\n                           (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n 3. \\<And>j.\n       \\<lbrakk>j \\<in> R_G_cfg_on_div s';\n        j \\<in> {cfg. alternating cfg}\\<rbrakk>\n       \\<Longrightarrow> ?i6 j\n                         \\<in> cfg_on_div s \\<inter> {cfg. alternating cfg}\n 4. \\<And>j.\n       \\<lbrakk>j \\<in> R_G_cfg_on_div s';\n        j \\<in> {cfg. alternating cfg}\\<rbrakk>\n       \\<Longrightarrow> emeasure (R_G.T j)\n                          {x \\<in> space R_G.St.\n                           (holds \\<phi>' suntil holds \\<psi>') (s' ## x)} =\n                         emeasure (MDP.T (?i6 j))\n                          {x \\<in> space MDP.St.\n                           (holds \\<phi> suntil holds \\<psi>) (s ## x)}", "fix cfg"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<in> cfg_on_div s;\n        i \\<in> {cfg. alternating cfg}\\<rbrakk>\n       \\<Longrightarrow> ?j11 i\n                         \\<in> R_G_cfg_on_div s' \\<inter>\n                               {cfg. alternating cfg}\n 2. \\<And>i.\n       \\<lbrakk>i \\<in> cfg_on_div s;\n        i \\<in> {cfg. alternating cfg}\\<rbrakk>\n       \\<Longrightarrow> emeasure (MDP.T i)\n                          {x \\<in> space MDP.St.\n                           (holds \\<phi> suntil holds \\<psi>) (s ## x)} =\n                         emeasure (R_G.T (?j11 i))\n                          {x \\<in> space R_G.St.\n                           (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n 3. \\<And>j.\n       \\<lbrakk>j \\<in> R_G_cfg_on_div s';\n        j \\<in> {cfg. alternating cfg}\\<rbrakk>\n       \\<Longrightarrow> ?i6 j\n                         \\<in> cfg_on_div s \\<inter> {cfg. alternating cfg}\n 4. \\<And>j.\n       \\<lbrakk>j \\<in> R_G_cfg_on_div s';\n        j \\<in> {cfg. alternating cfg}\\<rbrakk>\n       \\<Longrightarrow> emeasure (R_G.T j)\n                          {x \\<in> space R_G.St.\n                           (holds \\<phi>' suntil holds \\<psi>') (s' ## x)} =\n                         emeasure (MDP.T (?i6 j))\n                          {x \\<in> space MDP.St.\n                           (holds \\<phi> suntil holds \\<psi>) (s ## x)}", "assume cfg_div: \"cfg \\<in> R_G_cfg_on_div s'\" and \"cfg \\<in> Collect alternating\""], ["proof (state)\nthis:\n  cfg \\<in> R_G_cfg_on_div s'\n  cfg \\<in> Collect alternating\n\ngoal (4 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<in> cfg_on_div s;\n        i \\<in> {cfg. alternating cfg}\\<rbrakk>\n       \\<Longrightarrow> ?j11 i\n                         \\<in> R_G_cfg_on_div s' \\<inter>\n                               {cfg. alternating cfg}\n 2. \\<And>i.\n       \\<lbrakk>i \\<in> cfg_on_div s;\n        i \\<in> {cfg. alternating cfg}\\<rbrakk>\n       \\<Longrightarrow> emeasure (MDP.T i)\n                          {x \\<in> space MDP.St.\n                           (holds \\<phi> suntil holds \\<psi>) (s ## x)} =\n                         emeasure (R_G.T (?j11 i))\n                          {x \\<in> space R_G.St.\n                           (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n 3. \\<And>j.\n       \\<lbrakk>j \\<in> R_G_cfg_on_div s';\n        j \\<in> {cfg. alternating cfg}\\<rbrakk>\n       \\<Longrightarrow> ?i6 j\n                         \\<in> cfg_on_div s \\<inter> {cfg. alternating cfg}\n 4. \\<And>j.\n       \\<lbrakk>j \\<in> R_G_cfg_on_div s';\n        j \\<in> {cfg. alternating cfg}\\<rbrakk>\n       \\<Longrightarrow> emeasure (R_G.T j)\n                          {x \\<in> space R_G.St.\n                           (holds \\<phi>' suntil holds \\<psi>') (s' ## x)} =\n                         emeasure (MDP.T (?i6 j))\n                          {x \\<in> space MDP.St.\n                           (holds \\<phi> suntil holds \\<psi>) (s ## x)}", "then"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G_cfg_on_div s'\n  cfg \\<in> Collect alternating", "have \"alternating cfg\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G_cfg_on_div s'\n  cfg \\<in> Collect alternating\n\ngoal (1 subgoal):\n 1. alternating cfg", "by auto"], ["proof (state)\nthis:\n  alternating cfg\n\ngoal (4 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<in> cfg_on_div s;\n        i \\<in> {cfg. alternating cfg}\\<rbrakk>\n       \\<Longrightarrow> ?j11 i\n                         \\<in> R_G_cfg_on_div s' \\<inter>\n                               {cfg. alternating cfg}\n 2. \\<And>i.\n       \\<lbrakk>i \\<in> cfg_on_div s;\n        i \\<in> {cfg. alternating cfg}\\<rbrakk>\n       \\<Longrightarrow> emeasure (MDP.T i)\n                          {x \\<in> space MDP.St.\n                           (holds \\<phi> suntil holds \\<psi>) (s ## x)} =\n                         emeasure (R_G.T (?j11 i))\n                          {x \\<in> space R_G.St.\n                           (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n 3. \\<And>j.\n       \\<lbrakk>j \\<in> R_G_cfg_on_div s';\n        j \\<in> {cfg. alternating cfg}\\<rbrakk>\n       \\<Longrightarrow> ?i6 j\n                         \\<in> cfg_on_div s \\<inter> {cfg. alternating cfg}\n 4. \\<And>j.\n       \\<lbrakk>j \\<in> R_G_cfg_on_div s';\n        j \\<in> {cfg. alternating cfg}\\<rbrakk>\n       \\<Longrightarrow> emeasure (R_G.T j)\n                          {x \\<in> space R_G.St.\n                           (holds \\<phi>' suntil holds \\<psi>') (s' ## x)} =\n                         emeasure (MDP.T (?i6 j))\n                          {x \\<in> space MDP.St.\n                           (holds \\<phi> suntil holds \\<psi>) (s ## x)}", "let ?cfg' = \"repcs s cfg\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<in> cfg_on_div s;\n        i \\<in> {cfg. alternating cfg}\\<rbrakk>\n       \\<Longrightarrow> ?j11 i\n                         \\<in> R_G_cfg_on_div s' \\<inter>\n                               {cfg. alternating cfg}\n 2. \\<And>i.\n       \\<lbrakk>i \\<in> cfg_on_div s;\n        i \\<in> {cfg. alternating cfg}\\<rbrakk>\n       \\<Longrightarrow> emeasure (MDP.T i)\n                          {x \\<in> space MDP.St.\n                           (holds \\<phi> suntil holds \\<psi>) (s ## x)} =\n                         emeasure (R_G.T (?j11 i))\n                          {x \\<in> space R_G.St.\n                           (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n 3. \\<And>j.\n       \\<lbrakk>j \\<in> R_G_cfg_on_div s';\n        j \\<in> {cfg. alternating cfg}\\<rbrakk>\n       \\<Longrightarrow> ?i6 j\n                         \\<in> cfg_on_div s \\<inter> {cfg. alternating cfg}\n 4. \\<And>j.\n       \\<lbrakk>j \\<in> R_G_cfg_on_div s';\n        j \\<in> {cfg. alternating cfg}\\<rbrakk>\n       \\<Longrightarrow> emeasure (R_G.T j)\n                          {x \\<in> space R_G.St.\n                           (holds \\<phi>' suntil holds \\<psi>') (s' ## x)} =\n                         emeasure (MDP.T (?i6 j))\n                          {x \\<in> space MDP.St.\n                           (holds \\<phi> suntil holds \\<psi>) (s ## x)}", "from \\<open>alternating cfg\\<close> cfg_div"], ["proof (chain)\npicking this:\n  alternating cfg\n  cfg \\<in> R_G_cfg_on_div s'", "have \"alternating ?cfg'\""], ["proof (prove)\nusing this:\n  alternating cfg\n  cfg \\<in> R_G_cfg_on_div s'\n\ngoal (1 subgoal):\n 1. alternating (repcs s cfg)", "by (simp add: R_G_cfg_on_div_def s'_def AE_alw_ev_same_loc_iff'[of _ s])"], ["proof (state)\nthis:\n  alternating (repcs s cfg)\n\ngoal (4 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<in> cfg_on_div s;\n        i \\<in> {cfg. alternating cfg}\\<rbrakk>\n       \\<Longrightarrow> ?j11 i\n                         \\<in> R_G_cfg_on_div s' \\<inter>\n                               {cfg. alternating cfg}\n 2. \\<And>i.\n       \\<lbrakk>i \\<in> cfg_on_div s;\n        i \\<in> {cfg. alternating cfg}\\<rbrakk>\n       \\<Longrightarrow> emeasure (MDP.T i)\n                          {x \\<in> space MDP.St.\n                           (holds \\<phi> suntil holds \\<psi>) (s ## x)} =\n                         emeasure (R_G.T (?j11 i))\n                          {x \\<in> space R_G.St.\n                           (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n 3. \\<And>j.\n       \\<lbrakk>j \\<in> R_G_cfg_on_div s';\n        j \\<in> {cfg. alternating cfg}\\<rbrakk>\n       \\<Longrightarrow> ?i6 j\n                         \\<in> cfg_on_div s \\<inter> {cfg. alternating cfg}\n 4. \\<And>j.\n       \\<lbrakk>j \\<in> R_G_cfg_on_div s';\n        j \\<in> {cfg. alternating cfg}\\<rbrakk>\n       \\<Longrightarrow> emeasure (R_G.T j)\n                          {x \\<in> space R_G.St.\n                           (holds \\<phi>' suntil holds \\<psi>') (s' ## x)} =\n                         emeasure (MDP.T (?i6 j))\n                          {x \\<in> space MDP.St.\n                           (holds \\<phi> suntil holds \\<psi>) (s ## x)}", "with cfg_div \\<open>alternating cfg\\<close>"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G_cfg_on_div s'\n  alternating cfg\n  alternating (repcs s cfg)", "show \"?cfg' \\<in> cfg_on_div s \\<inter> Collect alternating\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G_cfg_on_div s'\n  alternating cfg\n  alternating (repcs s cfg)\n\ngoal (1 subgoal):\n 1. repcs s cfg \\<in> cfg_on_div s \\<inter> Collect alternating", "by (auto intro: cfg_on_div_repcs_strong simp: s'_def)"], ["proof (state)\nthis:\n  repcs s cfg \\<in> cfg_on_div s \\<inter> Collect alternating\n\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<in> cfg_on_div s;\n        i \\<in> {cfg. alternating cfg}\\<rbrakk>\n       \\<Longrightarrow> ?j11 i\n                         \\<in> R_G_cfg_on_div s' \\<inter>\n                               {cfg. alternating cfg}\n 2. \\<And>i.\n       \\<lbrakk>i \\<in> cfg_on_div s;\n        i \\<in> {cfg. alternating cfg}\\<rbrakk>\n       \\<Longrightarrow> emeasure (MDP.T i)\n                          {x \\<in> space MDP.St.\n                           (holds \\<phi> suntil holds \\<psi>) (s ## x)} =\n                         emeasure (R_G.T (?j11 i))\n                          {x \\<in> space R_G.St.\n                           (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n 3. \\<And>j.\n       \\<lbrakk>j \\<in> R_G_cfg_on_div s';\n        j \\<in> {cfg. alternating cfg}\\<rbrakk>\n       \\<Longrightarrow> emeasure (R_G.T j)\n                          {x \\<in> space R_G.St.\n                           (holds \\<phi>' suntil holds \\<psi>') (s' ## x)} =\n                         emeasure (MDP.T (repcs s j))\n                          {x \\<in> space MDP.St.\n                           (holds \\<phi> suntil holds \\<psi>) (s ## x)}", "show \"emeasure (R_G.T cfg)   {x \\<in> space R_G.St. (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n      = emeasure (MDP.T ?cfg') {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>)   (s ## x)}\"\n     (is \"?a = ?b\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (R_G.T cfg)\n     {x \\<in> space R_G.St.\n      (holds \\<phi>' suntil holds \\<psi>') (s' ## x)} =\n    emeasure (MDP.T (repcs s cfg))\n     {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>) (s ## x)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure (R_G.T cfg)\n     {x \\<in> space R_G.St.\n      (holds \\<phi>' suntil holds \\<psi>') (s' ## x)} =\n    emeasure (MDP.T (repcs s cfg))\n     {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>) (s ## x)}", "from cfg_div"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G_cfg_on_div s'", "have \"cfg \\<in> R_G.valid_cfg\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G_cfg_on_div s'\n\ngoal (1 subgoal):\n 1. cfg \\<in> R_G.valid_cfg", "by (rule R_G_cfg_on_valid)"], ["proof (state)\nthis:\n  cfg \\<in> R_G.valid_cfg\n\ngoal (1 subgoal):\n 1. emeasure (R_G.T cfg)\n     {x \\<in> space R_G.St.\n      (holds \\<phi>' suntil holds \\<psi>') (s' ## x)} =\n    emeasure (MDP.T (repcs s cfg))\n     {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>) (s ## x)}", "from cfg_div"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G_cfg_on_div s'", "have \"cfg \\<in> R_G.cfg_on s'\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G_cfg_on_div s'\n\ngoal (1 subgoal):\n 1. cfg \\<in> R_G.cfg_on s'", "unfolding R_G_cfg_on_div_def"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.cfg_on s' \\<inter> Collect R_G_div_cfg\n\ngoal (1 subgoal):\n 1. cfg \\<in> R_G.cfg_on s'", "by auto"], ["proof (state)\nthis:\n  cfg \\<in> R_G.cfg_on s'\n\ngoal (1 subgoal):\n 1. emeasure (R_G.T cfg)\n     {x \\<in> space R_G.St.\n      (holds \\<phi>' suntil holds \\<psi>') (s' ## x)} =\n    emeasure (MDP.T (repcs s cfg))\n     {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>) (s ## x)}", "then"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.cfg_on s'", "have \"state cfg = s'\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.cfg_on s'\n\ngoal (1 subgoal):\n 1. state cfg = s'", "by auto"], ["proof (state)\nthis:\n  state cfg = s'\n\ngoal (1 subgoal):\n 1. emeasure (R_G.T cfg)\n     {x \\<in> space R_G.St.\n      (holds \\<phi>' suntil holds \\<psi>') (s' ## x)} =\n    emeasure (MDP.T (repcs s cfg))\n     {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>) (s ## x)}", "have \"?a = ?b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (R_G.T cfg)\n     {x \\<in> space R_G.St.\n      (holds \\<phi>' suntil holds \\<psi>') (s' ## x)} =\n    emeasure (MDP.T (repcs s cfg))\n     {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>) (s ## x)}", "apply (rule\n          path_measure_eq_repcs''_new[\n            of s cfg \\<phi> \\<psi>, folded \\<phi>'_def \\<psi>'_def, unfolded \\<open>_ = s'\\<close> state_repcs\n            ]\n          )"], ["proof (prove)\ngoal (5 subgoals):\n 1. abss s = s'\n 2. cfg \\<in> R_G.valid_cfg\n 3. repcs s cfg \\<in> MDP.valid_cfg\n 4. \\<And>x.\n       pred_stream (\\<lambda>s. s \\<in> S) x \\<Longrightarrow>\n       pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s) (s ## x)\n 5. \\<And>x.\n       pred_stream (\\<lambda>s. s \\<in> S) x \\<Longrightarrow>\n       pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s) (s ## x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. abss s = s'", "unfolding s'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. s ~ s", ".."], ["proof (prove)\ngoal (4 subgoals):\n 1. cfg \\<in> R_G.valid_cfg\n 2. repcs s cfg \\<in> MDP.valid_cfg\n 3. \\<And>x.\n       pred_stream (\\<lambda>s. s \\<in> S) x \\<Longrightarrow>\n       pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s) (s ## x)\n 4. \\<And>x.\n       pred_stream (\\<lambda>s. s \\<in> S) x \\<Longrightarrow>\n       pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s) (s ## x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. cfg \\<in> R_G.valid_cfg", "by fact"], ["proof (prove)\ngoal (3 subgoals):\n 1. repcs s cfg \\<in> MDP.valid_cfg\n 2. \\<And>x.\n       pred_stream (\\<lambda>s. s \\<in> S) x \\<Longrightarrow>\n       pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s) (s ## x)\n 3. \\<And>x.\n       pred_stream (\\<lambda>s. s \\<in> S) x \\<Longrightarrow>\n       pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s) (s ## x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. repcs s cfg \\<in> MDP.valid_cfg", "using \\<open>?cfg' \\<in> cfg_on_div s \\<inter> _\\<close>"], ["proof (prove)\nusing this:\n  repcs s cfg \\<in> cfg_on_div s \\<inter> Collect alternating\n\ngoal (1 subgoal):\n 1. repcs s cfg \\<in> MDP.valid_cfg", "by (blast intro: cfg_on_valid)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       pred_stream (\\<lambda>s. s \\<in> S) x \\<Longrightarrow>\n       pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s) (s ## x)\n 2. \\<And>x.\n       pred_stream (\\<lambda>s. s \\<in> S) x \\<Longrightarrow>\n       pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s) (s ## x)", "subgoal premises prems for xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s) (s ## xs)", "using prems s"], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>s. s \\<in> S) xs\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s) (s ## xs)", "by (intro \\<phi>_stream)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       pred_stream (\\<lambda>s. s \\<in> S) x \\<Longrightarrow>\n       pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s) (s ## x)", "subgoal premises prems"], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s) (s ## x_)", "using prems s"], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>s. s \\<in> S) x_\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s) (s ## x_)", "by (intro \\<psi>_stream)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  emeasure (R_G.T cfg)\n   {x \\<in> space R_G.St. (holds \\<phi>' suntil holds \\<psi>') (s' ## x)} =\n  emeasure (MDP.T (repcs s cfg))\n   {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>) (s ## x)}\n\ngoal (1 subgoal):\n 1. emeasure (R_G.T cfg)\n     {x \\<in> space R_G.St.\n      (holds \\<phi>' suntil holds \\<psi>') (s' ## x)} =\n    emeasure (MDP.T (repcs s cfg))\n     {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>) (s ## x)}", "then"], ["proof (chain)\npicking this:\n  emeasure (R_G.T cfg)\n   {x \\<in> space R_G.St. (holds \\<phi>' suntil holds \\<psi>') (s' ## x)} =\n  emeasure (MDP.T (repcs s cfg))\n   {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>) (s ## x)}", "show ?thesis"], ["proof (prove)\nusing this:\n  emeasure (R_G.T cfg)\n   {x \\<in> space R_G.St. (holds \\<phi>' suntil holds \\<psi>') (s' ## x)} =\n  emeasure (MDP.T (repcs s cfg))\n   {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>) (s ## x)}\n\ngoal (1 subgoal):\n 1. emeasure (R_G.T cfg)\n     {x \\<in> space R_G.St.\n      (holds \\<phi>' suntil holds \\<psi>') (s' ## x)} =\n    emeasure (MDP.T (repcs s cfg))\n     {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>) (s ## x)}", "by simp"], ["proof (state)\nthis:\n  emeasure (R_G.T cfg)\n   {x \\<in> space R_G.St. (holds \\<phi>' suntil holds \\<psi>') (s' ## x)} =\n  emeasure (MDP.T (repcs s cfg))\n   {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>) (s ## x)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  emeasure (R_G.T cfg)\n   {x \\<in> space R_G.St. (holds \\<phi>' suntil holds \\<psi>') (s' ## x)} =\n  emeasure (MDP.T (repcs s cfg))\n   {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>) (s ## x)}\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<in> cfg_on_div s;\n        i \\<in> {cfg. alternating cfg}\\<rbrakk>\n       \\<Longrightarrow> ?j11 i\n                         \\<in> R_G_cfg_on_div s' \\<inter>\n                               {cfg. alternating cfg}\n 2. \\<And>i.\n       \\<lbrakk>i \\<in> cfg_on_div s;\n        i \\<in> {cfg. alternating cfg}\\<rbrakk>\n       \\<Longrightarrow> emeasure (MDP.T i)\n                          {x \\<in> space MDP.St.\n                           (holds \\<phi> suntil holds \\<psi>) (s ## x)} =\n                         emeasure (R_G.T (?j11 i))\n                          {x \\<in> space R_G.St.\n                           (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<in> cfg_on_div s;\n        i \\<in> {cfg. alternating cfg}\\<rbrakk>\n       \\<Longrightarrow> ?j11 i\n                         \\<in> R_G_cfg_on_div s' \\<inter>\n                               {cfg. alternating cfg}\n 2. \\<And>i.\n       \\<lbrakk>i \\<in> cfg_on_div s;\n        i \\<in> {cfg. alternating cfg}\\<rbrakk>\n       \\<Longrightarrow> emeasure (MDP.T i)\n                          {x \\<in> space MDP.St.\n                           (holds \\<phi> suntil holds \\<psi>) (s ## x)} =\n                         emeasure (R_G.T (?j11 i))\n                          {x \\<in> space R_G.St.\n                           (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}", "fix cfg"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<in> cfg_on_div s;\n        i \\<in> {cfg. alternating cfg}\\<rbrakk>\n       \\<Longrightarrow> ?j11 i\n                         \\<in> R_G_cfg_on_div s' \\<inter>\n                               {cfg. alternating cfg}\n 2. \\<And>i.\n       \\<lbrakk>i \\<in> cfg_on_div s;\n        i \\<in> {cfg. alternating cfg}\\<rbrakk>\n       \\<Longrightarrow> emeasure (MDP.T i)\n                          {x \\<in> space MDP.St.\n                           (holds \\<phi> suntil holds \\<psi>) (s ## x)} =\n                         emeasure (R_G.T (?j11 i))\n                          {x \\<in> space R_G.St.\n                           (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}", "assume cfg_div: \"cfg \\<in> cfg_on_div s\" and \"cfg \\<in> Collect alternating\""], ["proof (state)\nthis:\n  cfg \\<in> cfg_on_div s\n  cfg \\<in> Collect alternating\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<in> cfg_on_div s;\n        i \\<in> {cfg. alternating cfg}\\<rbrakk>\n       \\<Longrightarrow> ?j11 i\n                         \\<in> R_G_cfg_on_div s' \\<inter>\n                               {cfg. alternating cfg}\n 2. \\<And>i.\n       \\<lbrakk>i \\<in> cfg_on_div s;\n        i \\<in> {cfg. alternating cfg}\\<rbrakk>\n       \\<Longrightarrow> emeasure (MDP.T i)\n                          {x \\<in> space MDP.St.\n                           (holds \\<phi> suntil holds \\<psi>) (s ## x)} =\n                         emeasure (R_G.T (?j11 i))\n                          {x \\<in> space R_G.St.\n                           (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}", "with absc_valid_cfg_eq"], ["proof (chain)\npicking this:\n  absc ` (cfg_on_div s \\<inter> {cfg. alternating cfg}) =\n  R_G_cfg_on_div s' \\<inter> {cfg. alternating cfg}\n  cfg \\<in> cfg_on_div s\n  cfg \\<in> Collect alternating", "show \"absc cfg \\<in> R_G_cfg_on_div s' \\<inter> Collect alternating\""], ["proof (prove)\nusing this:\n  absc ` (cfg_on_div s \\<inter> {cfg. alternating cfg}) =\n  R_G_cfg_on_div s' \\<inter> {cfg. alternating cfg}\n  cfg \\<in> cfg_on_div s\n  cfg \\<in> Collect alternating\n\ngoal (1 subgoal):\n 1. absc cfg \\<in> R_G_cfg_on_div s' \\<inter> Collect alternating", "by auto"], ["proof (state)\nthis:\n  absc cfg \\<in> R_G_cfg_on_div s' \\<inter> Collect alternating\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<in> cfg_on_div s;\n        i \\<in> {cfg. alternating cfg}\\<rbrakk>\n       \\<Longrightarrow> emeasure (MDP.T i)\n                          {x \\<in> space MDP.St.\n                           (holds \\<phi> suntil holds \\<psi>) (s ## x)} =\n                         emeasure (R_G.T (absc i))\n                          {x \\<in> space R_G.St.\n                           (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}", "show \"emeasure (MDP.T cfg)        {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>)   (s ## x)}\n      = emeasure (R_G.T (absc cfg)) {x \\<in> space R_G.St. (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\"\n    (is \"?a = ?b\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (MDP.T cfg)\n     {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>) (s ## x)} =\n    emeasure (R_G.T (absc cfg))\n     {x \\<in> space R_G.St. (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure (MDP.T cfg)\n     {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>) (s ## x)} =\n    emeasure (R_G.T (absc cfg))\n     {x \\<in> space R_G.St. (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}", "have \"absc cfg \\<in> R_G.valid_cfg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. absc cfg \\<in> R_G.valid_cfg", "using R_G_cfg_on_valid \\<open>absc cfg \\<in> R_G_cfg_on_div s' \\<inter> _\\<close>"], ["proof (prove)\nusing this:\n  ?cfg \\<in> R_G_cfg_on_div s' \\<Longrightarrow> ?cfg \\<in> R_G.valid_cfg\n  absc cfg \\<in> R_G_cfg_on_div s' \\<inter> Collect alternating\n\ngoal (1 subgoal):\n 1. absc cfg \\<in> R_G.valid_cfg", "by blast"], ["proof (state)\nthis:\n  absc cfg \\<in> R_G.valid_cfg\n\ngoal (1 subgoal):\n 1. emeasure (MDP.T cfg)\n     {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>) (s ## x)} =\n    emeasure (R_G.T (absc cfg))\n     {x \\<in> space R_G.St. (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}", "from cfg_div"], ["proof (chain)\npicking this:\n  cfg \\<in> cfg_on_div s", "have \"cfg \\<in> valid_cfg\""], ["proof (prove)\nusing this:\n  cfg \\<in> cfg_on_div s\n\ngoal (1 subgoal):\n 1. cfg \\<in> MDP.valid_cfg", "by (simp add: cfg_on_valid)"], ["proof (state)\nthis:\n  cfg \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. emeasure (MDP.T cfg)\n     {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>) (s ## x)} =\n    emeasure (R_G.T (absc cfg))\n     {x \\<in> space R_G.St. (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}", "with \\<open>absc cfg \\<in> R_G.valid_cfg\\<close>"], ["proof (chain)\npicking this:\n  absc cfg \\<in> R_G.valid_cfg\n  cfg \\<in> MDP.valid_cfg", "have \"?b = ?a\""], ["proof (prove)\nusing this:\n  absc cfg \\<in> R_G.valid_cfg\n  cfg \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. emeasure (R_G.T (absc cfg))\n     {x \\<in> space R_G.St.\n      (holds \\<phi>' suntil holds \\<psi>') (s' ## x)} =\n    emeasure (MDP.T cfg)\n     {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>) (s ## x)}", "by (intro MDP.alw_S R_G.alw_S path_measure_eq_absc1_new\n            [where P = \"pred_stream (\\<lambda>s. s \\<in> \\<S>)\" and Q = \"pred_stream (\\<lambda>s. s \\<in> S)\"]\n         )\n         (auto simp: S_abss_\\<S> intro: \\<S>_abss_S intro!: suntil_abss suntil_reps, measurable)"], ["proof (state)\nthis:\n  emeasure (R_G.T (absc cfg))\n   {x \\<in> space R_G.St. (holds \\<phi>' suntil holds \\<psi>') (s' ## x)} =\n  emeasure (MDP.T cfg)\n   {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>) (s ## x)}\n\ngoal (1 subgoal):\n 1. emeasure (MDP.T cfg)\n     {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>) (s ## x)} =\n    emeasure (R_G.T (absc cfg))\n     {x \\<in> space R_G.St. (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}", "then"], ["proof (chain)\npicking this:\n  emeasure (R_G.T (absc cfg))\n   {x \\<in> space R_G.St. (holds \\<phi>' suntil holds \\<psi>') (s' ## x)} =\n  emeasure (MDP.T cfg)\n   {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>) (s ## x)}", "show \"?a = ?b\""], ["proof (prove)\nusing this:\n  emeasure (R_G.T (absc cfg))\n   {x \\<in> space R_G.St. (holds \\<phi>' suntil holds \\<psi>') (s' ## x)} =\n  emeasure (MDP.T cfg)\n   {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>) (s ## x)}\n\ngoal (1 subgoal):\n 1. emeasure (MDP.T cfg)\n     {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>) (s ## x)} =\n    emeasure (R_G.T (absc cfg))\n     {x \\<in> space R_G.St. (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}", "by simp"], ["proof (state)\nthis:\n  emeasure (MDP.T cfg)\n   {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>) (s ## x)} =\n  emeasure (R_G.T (absc cfg))\n   {x \\<in> space R_G.St. (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  emeasure (MDP.T cfg)\n   {x \\<in> space MDP.St. (holds \\<phi> suntil holds \\<psi>) (s ## x)} =\n  emeasure (R_G.T (absc cfg))\n   {x \\<in> space R_G.St. (holds \\<phi>' suntil holds \\<psi>') (s' ## x)}\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* PTA Reachability Problem *)"], ["", "end"], ["", "(* Theory *)"]]}