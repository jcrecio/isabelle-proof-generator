{"file_name": "/home/qj213/afp-2021-10-22/thys/Probabilistic_Timed_Automata/library/Lib.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Probabilistic_Timed_Automata", "problem_names": ["lemma measurable_pred_stream[measurable]:\n  fixes P shows \"Measurable.pred (stream_space (count_space UNIV)) (pred_stream P)\"", "lemma pmf_map_pmf_cong:\n  fixes f g and \\<mu> :: \"'a pmf\"\n  assumes \"\\<And> x. x \\<in> \\<mu> \\<Longrightarrow> f x = y1 \\<longleftrightarrow> g x = y2\"\n  shows \"pmf (map_pmf f \\<mu>) y1 = pmf (map_pmf g \\<mu>) y2\"", "lemma collect_pair_finite[intro]:\n  notes finite_subset[intro]\n  assumes \"finite {x. P x}\" \"finite {x. Q x}\"\n  shows \"finite {(x, y) . P x \\<and> Q y \\<and> R x y}\"", "lemma collect_pair_finite'[intro]:\n  notes finite_subset[intro]\n  assumes \"finite {(x, y). P x y}\"\n  shows \"finite {(x, y) . P x y \\<and> R x y}\"", "lemma collect_pair_finite''[intro]:\n  notes finite_subset[intro]\n  assumes \"finite {(x, y). P x \\<and> Q y}\"\n  shows \"finite {(x, y) . P x \\<and> Q y \\<and> R x y}\"", "lemma finite_imageI'[intro]:\n  assumes \"finite {(x, y). P x y}\"\n  shows \"finite {f x y | x y. P x y}\"", "lemma finite_imageI''[intro]:\n  assumes \"finite (A \\<times> B)\"\n  shows \"finite {f x y | x y. x \\<in> A \\<and> y \\<in> B \\<and> R x y}\"", "lemma pred_stream_stl: \"pred_stream \\<phi> xs \\<longrightarrow> pred_stream \\<phi> (stl xs)\"", "lemma stream_all_pred_stream:\n  \"stream_all = pred_stream\"", "lemma pred_stream_iff: \"pred_stream P s \\<longleftrightarrow> Ball (sset s) P\"", "lemma measure_pmf_eq_1_iff:\n  \"emeasure (measure_pmf \\<mu>) {x} = 1 \\<longleftrightarrow> \\<mu> = return_pmf x\"", "lemma HLD_mono:\n  \"HLD S \\<omega>\" if \"HLD R \\<omega>\" \"R \\<subseteq> S\"", "lemma alw_HLD_smap:\n  \"alw (HLD (f ` S)) (smap f \\<omega>)\" if \"alw (HLD S) \\<omega>\"", "lemma alw_disjoint_ccontr:\n  assumes \"alw (HLD S) \\<omega>\" \"ev (alw (HLD R)) \\<omega>\" \"R \\<inter> S = {}\"\n  shows False", "lemma stream_all2_refl: \"stream_all2 P x x = pred_stream (\\<lambda> x. P x x) x\"", "lemma AE_all_imp_countable:\n  assumes \"countable {x. Q x}\"\n  shows \"(AE x in M. \\<forall>y. Q y \\<longrightarrow> P x y) = (\\<forall>y. Q y \\<longrightarrow> (AE x in M. P x y))\"", "lemma AE_conj:\n  \"almost_everywhere M P = almost_everywhere M (\\<lambda> x. P x \\<and> Q x)\" if \"almost_everywhere M Q\"", "lemma list_hd_lastD:\n  assumes \"length xs > 1\"\n  obtains x y ys where \"xs = x # ys @ [y]\"", "lemma SUP_eq_and_INF_eq:\n  assumes \"\\<And>i. i \\<in> A \\<Longrightarrow> \\<exists>j\\<in>B. f i = g j\"\n      and \"\\<And>j. j \\<in> B \\<Longrightarrow> \\<exists>i\\<in>A. g j = f i\"\n    shows \"\\<Squnion>((f :: _ \\<Rightarrow> _ :: complete_lattice) ` A) = \\<Squnion>(g ` B) \\<and> \\<Sqinter>(f ` A) = \\<Sqinter>(g ` B)\"", "lemma measurable_alw_stream[measurable]:\n  fixes P assumes [measurable]: \"Measurable.pred (stream_space (count_space UNIV)) P\"\n  shows \"Measurable.pred (stream_space (count_space UNIV)) (alw P)\"", "lemma ev_neq_start_implies_ev_neq:\n  assumes \"ev (Not o HLD {y}) (y ## xs)\"\n  shows \"ev (\\<lambda> xs. shd xs \\<noteq> shd (stl xs)) (y ## xs)\"", "lemma ev_sdropD:\n  assumes \"ev P xs\"\n  obtains i where \"P (sdrop i xs)\"", "lemma pred_stream_sconst:\n  \"pred_stream ((=) x) (sconst x)\"", "lemma alw_Stream: \"alw P (x ## s) \\<longleftrightarrow> P (x ## s) \\<and> alw P s\"", "lemma alw_True: \"alw (\\<lambda>x. True) \\<omega>\"", "lemma alw_conjI:\n  \"alw (P aand Q) xs\" if \"alw P xs\" \"alw Q xs\"", "lemma alw_ev_cong:\n  \"alw (ev S) xs = alw (ev R) xs\" if \"alw P xs\" \"\\<And> x. P x \\<Longrightarrow> S x \\<longleftrightarrow> R x\"", "lemma alw_ev_HLD_cong:\n  \"alw (ev (HLD S)) xs = alw (ev (HLD R)) xs\" if \"alw (HLD P) xs\" \"\\<And> x. x \\<in> P \\<Longrightarrow> x \\<in> S \\<longleftrightarrow> x \\<in> R\"", "lemma measurable_eq_stream_space[measurable (raw)]:\n  assumes [measurable]: \"f \\<in> M \\<rightarrow>\\<^sub>M stream_space (count_space UNIV)\"\n  shows \"Measurable.pred M (\\<lambda>x. f x = c)\"", "lemma prop_nth_sdrop:\n  assumes \"\\<forall> i\\<ge>j. P (\\<omega> !! i)\"\n  shows \"\\<forall> i. P (sdrop j \\<omega> !! i)\"", "lemma prop_nth_sdrop_pair:\n  assumes \"\\<forall> i. P (\\<omega> !! i) (\\<omega>' !! i)\"\n  shows \"\\<forall> i. P (sdrop j \\<omega> !! i) (sdrop j \\<omega>' !! i)\"", "lemma prop_nth_stl:\n  \"\\<forall> i. P (xs !! i) \\<Longrightarrow> \\<forall> i. P (stl xs !! i)\"", "lemma steps_SCons_iff:\n  \"steps (x # y # xs) \\<longleftrightarrow> E x y \\<and> steps (y # xs)\"", "lemma steps_Single_True:\n  \"steps [x] = True\"", "lemma add_step_iff:\n  \"(\\<forall> xs y. steps (x # xs @ [y]) \\<and> length xs = Suc n \\<longrightarrow> P xs y)\n  \\<longleftrightarrow> (\\<forall> z xs y. steps (x # z # xs @ [y]) \\<and> length xs = n \\<longrightarrow> P (z # xs) y)\"", "lemma compower_stepsD:\n  assumes \"(E ^^ n) s s'\"\n  obtains xs where \"steps xs\" \"hd xs = s\" \"last xs = s'\" \"length xs = n + 1\"", "lemma compower_stepsD':\n  assumes \"(E ^^ n) s s'\" \"n > 0\"\n  obtains xs where \"steps (s # xs @ [s'])\" \"length xs + 1 = n\"", "theorem AE_T_iff_n:\n  fixes P :: \"'s stream \\<Rightarrow> bool\" \n    and x :: \"'s\" \n  assumes \"Measurable.pred (stream_space (count_space UNIV)) P\" \"n > 0\"\n  shows \"almost_everywhere (T x) P =\n    (\\<forall>xs y. Graph_Defs.steps (\\<lambda> a b. b \\<in> K a) (x # xs @ [y]) \\<and> length xs + 1 = n\n      \\<longrightarrow> (AE \\<omega> in T y. P (xs @- y ## \\<omega>)))\"", "lemma AE_alw_accD:\n  fixes P assumes P: \"Measurable.pred (stream_space (count_space UNIV)) P\"\n  assumes *: \"almost_everywhere (T s) (alw P)\" \"(s, s') \\<in> acc\"\n  shows \"almost_everywhere (T s') (alw P)\"", "lemma acc_relfunD:\n  assumes \"(s, s') \\<in> acc\"\n  obtains n where \"((\\<lambda> a b. b \\<in> K a) ^^ n) s s'\"", "lemma AE_all_accD:\n  assumes \"almost_everywhere (T s) (pred_stream P)\" \"(s, s') \\<in> acc\"\n  shows \"almost_everywhere (T s') (pred_stream P)\"", "lemma AE_T_ev_HLD_infinite_strong':\n  assumes \"0 \\<le> r\" \"r < 1\"\n    and r: \"\\<And>x. x \\<in> X \\<inter> Y \\<Longrightarrow> measure_pmf.prob (K x) Y \\<le> r\"\n    and ae: \"AE \\<omega> in T x. alw (\\<lambda> \\<omega>. HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>) \\<omega>\"\n  shows \"AE \\<omega> in T x. ev (HLD (- Y)) \\<omega>\"", "lemma cfg_on_inv:\n  \"pred_stream (\\<lambda> cfg. cfg \\<in> cfg_on (state cfg)) \\<omega>\" if\n  \"MC.enabled cfg \\<omega>\" \"cfg \\<in> cfg_on s\"", "lemma MC_T_not_sconst_strong:\n  assumes\n    \"\\<forall> l. \\<forall> cfg \\<in> (\\<Union> x \\<in> f -` {u}. cfg_on x) \\<inter> Y \\<inter> X. measure_pmf (action cfg) (f -` {u}) \\<le> r\"\n    \"r < 1\" \"cfg \\<in> cfg_on x\"\n    \"AE \\<omega> in MC.T cfg. pred_stream (\\<lambda> x. x \\<in> X) \\<omega>\"\n    \"AE \\<omega> in MC.T cfg. alw (\\<lambda> \\<omega>. HLD (f -` {u}) (smap state \\<omega>) \\<longrightarrow> ev (HLD Y) \\<omega>) \\<omega>\"\n  shows \"AE \\<omega> in MC.T cfg. smap (f o state) \\<omega> \\<noteq> sconst u\"", "lemma MC_T_not_sconst:\n  assumes\n    \"\\<forall> l. \\<forall> cfg \\<in> (\\<Union> x \\<in> f -` {u}. cfg_on x) \\<inter> X. measure_pmf (action cfg) (f -` {u}) \\<le> r\"\n    \"r < 1\" \"cfg \\<in> cfg_on x\"\n    \"AE \\<omega> in MC.T cfg. pred_stream (\\<lambda> x. x \\<in> X) \\<omega>\"\n  shows \"AE \\<omega> in MC.T cfg. smap (f o state) \\<omega> \\<noteq> sconst u\"", "lemma MC_T_not_sconst':\n  assumes\n    \"\\<forall> cfg \\<in> cfg_on x \\<inter> X. measure_pmf (action cfg) {x} \\<le> r\" \"r < 1\" \"cfg \\<in> cfg_on x'\"\n    \"AE \\<omega> in MC.T cfg. pred_stream (\\<lambda> x. x \\<in> X) \\<omega>\"\n  shows \"AE \\<omega> in MC.T cfg. smap state \\<omega> \\<noteq> sconst x\"", "lemma K_cfg_cfg_onI:\n  \"cfg' \\<in> cfg_on (state cfg')\" if \"cfg \\<in> cfg_on x\" \"cfg' \\<in> K_cfg cfg\"", "lemma MC_acc_cfg_onI:\n  \"cfg' \\<in> cfg_on (state cfg')\" if \"(cfg, cfg') \\<in> MC.acc\" \"cfg \\<in> cfg_on x\"", "lemma non_loop_tail_strong:\n  assumes\n    \"\\<forall> l. \\<forall> cfg \\<in> (\\<Union> x \\<in> f -` {u}. cfg_on x) \\<inter> Y \\<inter> X. measure_pmf (action cfg) (f -` {u}) \\<le> r\"\n    \"r < 1\" \"cfg \\<in> cfg_on x\"\n    \"AE \\<omega> in MC.T cfg. pred_stream (\\<lambda> x. x \\<in> X) \\<omega>\"\n    \"AE \\<omega> in MC.T cfg. alw (\\<lambda> \\<omega>. HLD (f -` {u}) (smap state \\<omega>) \\<longrightarrow> ev (HLD Y) \\<omega>) \\<omega>\"\n  shows \"AE \\<omega> in MC.T cfg. \\<not> (ev (alw (\\<lambda> xs. shd xs = u))) (smap (f o state) \\<omega>)\"\n    (is \"AE \\<omega> in ?M. ?P \\<omega>\")", "lemma non_loop_tail:\n  assumes\n    \"\\<forall> l. \\<forall> cfg \\<in> (\\<Union> x \\<in> f -` {u}. cfg_on x) \\<inter> X. measure_pmf (action cfg) (f -` {u}) \\<le> r\"\n    \"r < 1\" \"cfg \\<in> cfg_on x\"\n    \"AE \\<omega> in MC.T cfg. pred_stream (\\<lambda> x. x \\<in> X) \\<omega>\"\n  shows \"AE \\<omega> in MC.T cfg. \\<not> (ev (alw (\\<lambda> xs. shd xs = u))) (smap (f o state) \\<omega>)\"\n    (is \"AE \\<omega> in ?M. ?P \\<omega>\")", "lemma non_loop_tail':\n  assumes\n    \"\\<forall> cfg \\<in> cfg_on x \\<inter> X. measure_pmf (action cfg) {x} \\<le> r\" \"r < 1\"\n    \"cfg \\<in> cfg_on y\"\n    \"AE \\<omega> in MC.T cfg. pred_stream (\\<lambda> x. x \\<in> X) \\<omega>\"\n  shows \"AE \\<omega> in MC.T cfg. \\<not> (ev (alw (\\<lambda> xs. shd xs = x))) (smap state \\<omega>)\"", "lemma (in Regions) intv_const_mono:\n  assumes \"u \\<in> region X I r\" \"c1 \\<in> X\" \"c2 \\<in> X\" \"u c1 \\<le> u c2\" \"\\<not> isGreater (I c2)\"\n  shows \"intv_const (I c1) \\<le> intv_const (I c2)\"", "lemma sset_sdrop:\n  assumes \"x \\<in> sset (sdrop i xs)\"\n  shows \"x \\<in> sset xs\"", "lemma holds_untilD:\n  assumes \"(holds P until holds Q) xs\" \"\\<forall> i \\<le> j. \\<not> Q (xs !! i)\"\n  shows \"P (xs !! j)\"", "lemma frac_le_self:\n  assumes \"x \\<ge> 0\"\n  shows \"frac x \\<le> x\"", "lemma frac_le_1I:\n  assumes \"0 \\<le> x\" \"x \\<le> 1\" \"x \\<le> y\"\n  shows \"frac x \\<le> y\"", "lemma frac_le_1I':\n  assumes \"0 \\<le> x\" \"x \\<le> y\" \"y < 1\"\n  shows \"frac x \\<le> frac y\"", "lemmas [intro] = order.strict_implies_order[OF frac_lt_1]", "lemma nat_eventually_critical:\n  assumes \"P i\" \"\\<not> P j\" \"i < j\"\n  shows \"\\<exists> k \\<ge> i. P k \\<and> \\<not> P (Suc k)\"", "lemma nat_eventually_critical_path:\n  fixes i :: nat\n  assumes \"P i\" \"\\<not> P j\" \"i < j\"\n  shows \"\\<exists> k > i. k \\<le> j \\<and> \\<not> P k \\<and> (\\<forall> m \\<ge> i. m < k \\<longrightarrow> P m)\"", "lemma E_invariant:\n  \"{s'. (s, s') \\<in> E} \\<subseteq> S\" if \"s \\<in> S\"", "lemma valid_cfgI: \"s \\<in> S \\<Longrightarrow> cfg \\<in> cfg_on s \\<Longrightarrow> cfg \\<in> valid_cfg\"", "lemma valid_cfgD: \"cfg \\<in> valid_cfg \\<Longrightarrow> cfg \\<in> cfg_on (state cfg)\"", "lemma action_closed: \"s \\<in> S \\<Longrightarrow> cfg \\<in> cfg_on s \\<Longrightarrow> t \\<in> action cfg \\<Longrightarrow> t \\<in> S\"", "lemma\n  shows valid_cfg_state_in_S: \"cfg \\<in> valid_cfg \\<Longrightarrow> state cfg \\<in> S\"\n    and valid_cfg_action: \"cfg \\<in> valid_cfg \\<Longrightarrow> s \\<in> action cfg \\<Longrightarrow> s \\<in> S\"\n    and valid_cfg_cont: \"cfg \\<in> valid_cfg \\<Longrightarrow> s \\<in> action cfg \\<Longrightarrow> cont cfg s \\<in> valid_cfg\"", "lemma valid_K_cfg[intro]: \"cfg \\<in> valid_cfg \\<Longrightarrow> cfg' \\<in> K_cfg cfg \\<Longrightarrow> cfg' \\<in> valid_cfg\"", "lemma pred_stream_valid_cfg:\n  assumes valid: \"cfg \\<in> valid_cfg\"\n  assumes enabled: \"MC.enabled cfg xs\"\n  shows \"pred_stream (\\<lambda> cfg. cfg \\<in> valid_cfg) xs\"", "lemma pred_stream_cfg_on:\n  assumes valid: \"cfg \\<in> valid_cfg\"\n  assumes enabled: \"MC.enabled cfg xs\"\n  shows \"pred_stream (\\<lambda> cfg. state cfg \\<in> S \\<and> cfg \\<in> cfg_on (state cfg)) xs\"", "lemma alw_S: \"almost_everywhere (T cfg) (pred_stream (\\<lambda>s. s \\<in> S))\" if \"cfg \\<in> valid_cfg\"", "lemmas pred_stream_cfg_on = Invariant.pred_stream_cfg_on\n   and pred_stream_valid_cfg = Invariant.pred_stream_valid_cfg\n   and alw_S = Invariant.alw_S\n   and valid_cfg_state_in_S = Invariant.valid_cfg_state_in_S"], "translations": [["", "lemma measurable_pred_stream[measurable]:\n  fixes P shows \"Measurable.pred (stream_space (count_space UNIV)) (pred_stream P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Measurable.pred (stream_space (count_space UNIV)) (pred_stream P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Measurable.pred (stream_space (count_space UNIV)) (pred_stream P)", "have [measurable]: \"Measurable.pred (count_space UNIV) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Measurable.pred (count_space UNIV) P", "by measurable"], ["proof (state)\nthis:\n  Measurable.pred (count_space UNIV) P\n\ngoal (1 subgoal):\n 1. Measurable.pred (stream_space (count_space UNIV)) (pred_stream P)", "then"], ["proof (chain)\npicking this:\n  Measurable.pred (count_space UNIV) P", "show ?thesis"], ["proof (prove)\nusing this:\n  Measurable.pred (count_space UNIV) P\n\ngoal (1 subgoal):\n 1. Measurable.pred (stream_space (count_space UNIV)) (pred_stream P)", "unfolding stream.pred_set sset_range"], ["proof (prove)\nusing this:\n  Measurable.pred (count_space UNIV) P\n\ngoal (1 subgoal):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>x. Ball (range ((!!) x)) P)", "by simp"], ["proof (state)\nthis:\n  Measurable.pred (stream_space (count_space UNIV)) (pred_stream P)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pmf_map_pmf_cong:\n  fixes f g and \\<mu> :: \"'a pmf\"\n  assumes \"\\<And> x. x \\<in> \\<mu> \\<Longrightarrow> f x = y1 \\<longleftrightarrow> g x = y2\"\n  shows \"pmf (map_pmf f \\<mu>) y1 = pmf (map_pmf g \\<mu>) y2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf (map_pmf f \\<mu>) y1 = pmf (map_pmf g \\<mu>) y2", "unfolding pmf_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.prob \\<mu> (f -` {y1}) = measure_pmf.prob \\<mu> (g -` {y2})", "by (rule measure_pmf.finite_measure_eq_AE;\n      simp add: AE_measure_pmf_iff assms split: split_indicator\n     )"], ["", "lemma collect_pair_finite[intro]:\n  notes finite_subset[intro]\n  assumes \"finite {x. P x}\" \"finite {x. Q x}\"\n  shows \"finite {(x, y) . P x \\<and> Q y \\<and> R x y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {(x, y). P x \\<and> Q y \\<and> R x y}", "using assms"], ["proof (prove)\nusing this:\n  finite {x. P x}\n  finite {x. Q x}\n\ngoal (1 subgoal):\n 1. finite {(x, y). P x \\<and> Q y \\<and> R x y}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite {x. P x}; finite {x. Q x}\\<rbrakk>\n    \\<Longrightarrow> finite {(x, y). P x \\<and> Q y \\<and> R x y}", "from assms"], ["proof (chain)\npicking this:\n  finite {x. P x}\n  finite {x. Q x}", "have \"finite {(x, y) . P x \\<and> Q y}\""], ["proof (prove)\nusing this:\n  finite {x. P x}\n  finite {x. Q x}\n\ngoal (1 subgoal):\n 1. finite {(x, y). P x \\<and> Q y}", "by auto"], ["proof (state)\nthis:\n  finite {(x, y). P x \\<and> Q y}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite {x. P x}; finite {x. Q x}\\<rbrakk>\n    \\<Longrightarrow> finite {(x, y). P x \\<and> Q y \\<and> R x y}", "moreover"], ["proof (state)\nthis:\n  finite {(x, y). P x \\<and> Q y}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite {x. P x}; finite {x. Q x}\\<rbrakk>\n    \\<Longrightarrow> finite {(x, y). P x \\<and> Q y \\<and> R x y}", "have \"{(x, y) . P x \\<and> (Q y \\<and> R x y)} \\<subseteq> {(x, y) . P x \\<and> Q y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). P x \\<and> Q y \\<and> R x y}\n    \\<subseteq> {(x, y). P x \\<and> Q y}", "by auto"], ["proof (state)\nthis:\n  {(x, y). P x \\<and> Q y \\<and> R x y} \\<subseteq> {(x, y). P x \\<and> Q y}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite {x. P x}; finite {x. Q x}\\<rbrakk>\n    \\<Longrightarrow> finite {(x, y). P x \\<and> Q y \\<and> R x y}", "ultimately"], ["proof (chain)\npicking this:\n  finite {(x, y). P x \\<and> Q y}\n  {(x, y). P x \\<and> Q y \\<and> R x y} \\<subseteq> {(x, y). P x \\<and> Q y}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite {(x, y). P x \\<and> Q y}\n  {(x, y). P x \\<and> Q y \\<and> R x y} \\<subseteq> {(x, y). P x \\<and> Q y}\n\ngoal (1 subgoal):\n 1. finite {(x, y). P x \\<and> Q y \\<and> R x y}", "by blast"], ["proof (state)\nthis:\n  finite {(x, y). P x \\<and> Q y \\<and> R x y}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma collect_pair_finite'[intro]:\n  notes finite_subset[intro]\n  assumes \"finite {(x, y). P x y}\"\n  shows \"finite {(x, y) . P x y \\<and> R x y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {(x, y). P x y \\<and> R x y}", "using assms"], ["proof (prove)\nusing this:\n  finite {(x, y). P x y}\n\ngoal (1 subgoal):\n 1. finite {(x, y). P x y \\<and> R x y}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {(x, y). P x y} \\<Longrightarrow>\n    finite {(x, y). P x y \\<and> R x y}", "from assms"], ["proof (chain)\npicking this:\n  finite {(x, y). P x y}", "have \"finite {(x, y) . P x y}\""], ["proof (prove)\nusing this:\n  finite {(x, y). P x y}\n\ngoal (1 subgoal):\n 1. finite {(x, y). P x y}", "by auto"], ["proof (state)\nthis:\n  finite {(x, y). P x y}\n\ngoal (1 subgoal):\n 1. finite {(x, y). P x y} \\<Longrightarrow>\n    finite {(x, y). P x y \\<and> R x y}", "moreover"], ["proof (state)\nthis:\n  finite {(x, y). P x y}\n\ngoal (1 subgoal):\n 1. finite {(x, y). P x y} \\<Longrightarrow>\n    finite {(x, y). P x y \\<and> R x y}", "have \"{(x, y) . P x y \\<and> R x y} \\<subseteq> {(x, y) . P x y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). P x y \\<and> R x y} \\<subseteq> {(x, y). P x y}", "by auto"], ["proof (state)\nthis:\n  {(x, y). P x y \\<and> R x y} \\<subseteq> {(x, y). P x y}\n\ngoal (1 subgoal):\n 1. finite {(x, y). P x y} \\<Longrightarrow>\n    finite {(x, y). P x y \\<and> R x y}", "ultimately"], ["proof (chain)\npicking this:\n  finite {(x, y). P x y}\n  {(x, y). P x y \\<and> R x y} \\<subseteq> {(x, y). P x y}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite {(x, y). P x y}\n  {(x, y). P x y \\<and> R x y} \\<subseteq> {(x, y). P x y}\n\ngoal (1 subgoal):\n 1. finite {(x, y). P x y \\<and> R x y}", "by blast"], ["proof (state)\nthis:\n  finite {(x, y). P x y \\<and> R x y}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>This is what we actually need in this theory\\<close>"], ["", "lemma collect_pair_finite''[intro]:\n  notes finite_subset[intro]\n  assumes \"finite {(x, y). P x \\<and> Q y}\"\n  shows \"finite {(x, y) . P x \\<and> Q y \\<and> R x y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {(x, y). P x \\<and> Q y \\<and> R x y}", "using assms"], ["proof (prove)\nusing this:\n  finite {(x, y). P x \\<and> Q y}\n\ngoal (1 subgoal):\n 1. finite {(x, y). P x \\<and> Q y \\<and> R x y}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {(x, y). P x \\<and> Q y} \\<Longrightarrow>\n    finite {(x, y). P x \\<and> Q y \\<and> R x y}", "from assms"], ["proof (chain)\npicking this:\n  finite {(x, y). P x \\<and> Q y}", "have \"finite {(x, y) . P x \\<and> Q y}\""], ["proof (prove)\nusing this:\n  finite {(x, y). P x \\<and> Q y}\n\ngoal (1 subgoal):\n 1. finite {(x, y). P x \\<and> Q y}", "by auto"], ["proof (state)\nthis:\n  finite {(x, y). P x \\<and> Q y}\n\ngoal (1 subgoal):\n 1. finite {(x, y). P x \\<and> Q y} \\<Longrightarrow>\n    finite {(x, y). P x \\<and> Q y \\<and> R x y}", "moreover"], ["proof (state)\nthis:\n  finite {(x, y). P x \\<and> Q y}\n\ngoal (1 subgoal):\n 1. finite {(x, y). P x \\<and> Q y} \\<Longrightarrow>\n    finite {(x, y). P x \\<and> Q y \\<and> R x y}", "have \"{(x, y) . P x \\<and> Q y \\<and> R x y} \\<subseteq> {(x, y) . P x \\<and> Q y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). P x \\<and> Q y \\<and> R x y}\n    \\<subseteq> {(x, y). P x \\<and> Q y}", "by auto"], ["proof (state)\nthis:\n  {(x, y). P x \\<and> Q y \\<and> R x y} \\<subseteq> {(x, y). P x \\<and> Q y}\n\ngoal (1 subgoal):\n 1. finite {(x, y). P x \\<and> Q y} \\<Longrightarrow>\n    finite {(x, y). P x \\<and> Q y \\<and> R x y}", "ultimately"], ["proof (chain)\npicking this:\n  finite {(x, y). P x \\<and> Q y}\n  {(x, y). P x \\<and> Q y \\<and> R x y} \\<subseteq> {(x, y). P x \\<and> Q y}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite {(x, y). P x \\<and> Q y}\n  {(x, y). P x \\<and> Q y \\<and> R x y} \\<subseteq> {(x, y). P x \\<and> Q y}\n\ngoal (1 subgoal):\n 1. finite {(x, y). P x \\<and> Q y \\<and> R x y}", "by blast"], ["proof (state)\nthis:\n  finite {(x, y). P x \\<and> Q y \\<and> R x y}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_imageI'[intro]:\n  assumes \"finite {(x, y). P x y}\"\n  shows \"finite {f x y | x y. P x y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {f x y |x y. P x y}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {f x y |x y. P x y}", "from assms"], ["proof (chain)\npicking this:\n  finite {(x, y). P x y}", "have \"finite ((\\<lambda> (x, y). f x y) ` {(x, y). P x y})\""], ["proof (prove)\nusing this:\n  finite {(x, y). P x y}\n\ngoal (1 subgoal):\n 1. finite ((\\<lambda>(x, y). f x y) ` {(x, y). P x y})", "by auto"], ["proof (state)\nthis:\n  finite ((\\<lambda>(x, y). f x y) ` {(x, y). P x y})\n\ngoal (1 subgoal):\n 1. finite {f x y |x y. P x y}", "moreover"], ["proof (state)\nthis:\n  finite ((\\<lambda>(x, y). f x y) ` {(x, y). P x y})\n\ngoal (1 subgoal):\n 1. finite {f x y |x y. P x y}", "have \"((\\<lambda> (x, y). f x y) ` {(x, y). P x y}) = {f x y | x y. P x y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). f x y) ` {(x, y). P x y} = {f x y |x y. P x y}", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>(x, y). f x y) ` {(x, y). P x y} = {f x y |x y. P x y}\n\ngoal (1 subgoal):\n 1. finite {f x y |x y. P x y}", "ultimately"], ["proof (chain)\npicking this:\n  finite ((\\<lambda>(x, y). f x y) ` {(x, y). P x y})\n  (\\<lambda>(x, y). f x y) ` {(x, y). P x y} = {f x y |x y. P x y}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite ((\\<lambda>(x, y). f x y) ` {(x, y). P x y})\n  (\\<lambda>(x, y). f x y) ` {(x, y). P x y} = {f x y |x y. P x y}\n\ngoal (1 subgoal):\n 1. finite {f x y |x y. P x y}", "by auto"], ["proof (state)\nthis:\n  finite {f x y |x y. P x y}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_imageI''[intro]:\n  assumes \"finite (A \\<times> B)\"\n  shows \"finite {f x y | x y. x \\<in> A \\<and> y \\<in> B \\<and> R x y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {f x y |x y. x \\<in> A \\<and> y \\<in> B \\<and> R x y}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {f x y |x y. x \\<in> A \\<and> y \\<in> B \\<and> R x y}", "from assms"], ["proof (chain)\npicking this:\n  finite (A \\<times> B)", "have \"finite {f x y | x y. x \\<in> A \\<and> y \\<in> B}\""], ["proof (prove)\nusing this:\n  finite (A \\<times> B)\n\ngoal (1 subgoal):\n 1. finite {f x y |x y. x \\<in> A \\<and> y \\<in> B}", "by auto"], ["proof (state)\nthis:\n  finite {f x y |x y. x \\<in> A \\<and> y \\<in> B}\n\ngoal (1 subgoal):\n 1. finite {f x y |x y. x \\<in> A \\<and> y \\<in> B \\<and> R x y}", "moreover"], ["proof (state)\nthis:\n  finite {f x y |x y. x \\<in> A \\<and> y \\<in> B}\n\ngoal (1 subgoal):\n 1. finite {f x y |x y. x \\<in> A \\<and> y \\<in> B \\<and> R x y}", "have \"{f x y | x y. x \\<in> A \\<and> y \\<in> B \\<and> R x y} \\<subseteq> {f x y | x y. x \\<in> A \\<and> y \\<in> B}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {f x y |x y. x \\<in> A \\<and> y \\<in> B \\<and> R x y}\n    \\<subseteq> {f x y |x y. x \\<in> A \\<and> y \\<in> B}", "by auto"], ["proof (state)\nthis:\n  {f x y |x y. x \\<in> A \\<and> y \\<in> B \\<and> R x y}\n  \\<subseteq> {f x y |x y. x \\<in> A \\<and> y \\<in> B}\n\ngoal (1 subgoal):\n 1. finite {f x y |x y. x \\<in> A \\<and> y \\<in> B \\<and> R x y}", "ultimately"], ["proof (chain)\npicking this:\n  finite {f x y |x y. x \\<in> A \\<and> y \\<in> B}\n  {f x y |x y. x \\<in> A \\<and> y \\<in> B \\<and> R x y}\n  \\<subseteq> {f x y |x y. x \\<in> A \\<and> y \\<in> B}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite {f x y |x y. x \\<in> A \\<and> y \\<in> B}\n  {f x y |x y. x \\<in> A \\<and> y \\<in> B \\<and> R x y}\n  \\<subseteq> {f x y |x y. x \\<in> A \\<and> y \\<in> B}\n\ngoal (1 subgoal):\n 1. finite {f x y |x y. x \\<in> A \\<and> y \\<in> B \\<and> R x y}", "by (blast intro: finite_subset)"], ["proof (state)\nthis:\n  finite {f x y |x y. x \\<in> A \\<and> y \\<in> B \\<and> R x y}\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: Move/should be somewhere already *)"], ["", "lemma pred_stream_stl: \"pred_stream \\<phi> xs \\<longrightarrow> pred_stream \\<phi> (stl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream \\<phi> xs \\<longrightarrow> pred_stream \\<phi> (stl xs)", "by (cases xs) auto"], ["", "(* TODO: Should be somewhere already *)"], ["", "lemma stream_all_pred_stream:\n  \"stream_all = pred_stream\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_all = pred_stream", "by (intro ext) (simp add: stream.pred_set)"], ["", "lemma pred_stream_iff: \"pred_stream P s \\<longleftrightarrow> Ball (sset s) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream P s = Ball (sset s) P", "using stream_all_iff[unfolded stream_all_pred_stream]"], ["proof (prove)\nusing this:\n  pred_stream ?P ?s = Ball (sset ?s) ?P\n\ngoal (1 subgoal):\n 1. pred_stream P s = Ball (sset s) P", "."], ["", "(* TODO: Move *)"], ["", "lemma measure_pmf_eq_1_iff:\n  \"emeasure (measure_pmf \\<mu>) {x} = 1 \\<longleftrightarrow> \\<mu> = return_pmf x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (emeasure (measure_pmf \\<mu>) {x} = 1) = (\\<mu> = return_pmf x)", "using measure_pmf.prob_eq_1[of \"{x}\" \\<mu>] set_pmf_subset_singleton[of \\<mu> x]"], ["proof (prove)\nusing this:\n  {x} \\<in> measure_pmf.events \\<mu> \\<Longrightarrow>\n  (measure_pmf.prob \\<mu> {x} = 1) =\n  (AE xa in measure_pmf \\<mu>. xa \\<in> {x})\n  (set_pmf \\<mu> \\<subseteq> {x}) = (\\<mu> = return_pmf x)\n\ngoal (1 subgoal):\n 1. (emeasure (measure_pmf \\<mu>) {x} = 1) = (\\<mu> = return_pmf x)", "by (auto simp: measure_pmf.emeasure_eq_measure AE_measure_pmf_iff)"], ["", "lemma HLD_mono:\n  \"HLD S \\<omega>\" if \"HLD R \\<omega>\" \"R \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HLD S \\<omega>", "using that"], ["proof (prove)\nusing this:\n  HLD R \\<omega>\n  R \\<subseteq> S\n\ngoal (1 subgoal):\n 1. HLD S \\<omega>", "unfolding HLD_iff"], ["proof (prove)\nusing this:\n  shd \\<omega> \\<in> R\n  R \\<subseteq> S\n\ngoal (1 subgoal):\n 1. shd \\<omega> \\<in> S", "by auto"], ["", "lemma alw_HLD_smap:\n  \"alw (HLD (f ` S)) (smap f \\<omega>)\" if \"alw (HLD S) \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (HLD (f ` S)) (smap f \\<omega>)", "using that"], ["proof (prove)\nusing this:\n  alw (HLD S) \\<omega>\n\ngoal (1 subgoal):\n 1. alw (HLD (f ` S)) (smap f \\<omega>)", "by (auto 4 3 elim: HLD_mono alw_mono)"], ["", "lemma alw_disjoint_ccontr:\n  assumes \"alw (HLD S) \\<omega>\" \"ev (alw (HLD R)) \\<omega>\" \"R \\<inter> S = {}\"\n  shows False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "from assms(1,2)"], ["proof (chain)\npicking this:\n  alw (HLD S) \\<omega>\n  ev (alw (HLD R)) \\<omega>", "obtain \\<omega> where \"alw (HLD S) \\<omega>\" \"alw (HLD R) \\<omega>\""], ["proof (prove)\nusing this:\n  alw (HLD S) \\<omega>\n  ev (alw (HLD R)) \\<omega>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<omega>.\n        \\<lbrakk>alw (HLD S) \\<omega>; alw (HLD R) \\<omega>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto intro: alw_sdrop sdrop_wait)"], ["proof (state)\nthis:\n  alw (HLD S) \\<omega>\n  alw (HLD R) \\<omega>\n\ngoal (1 subgoal):\n 1. False", "with \\<open>R \\<inter> S = {}\\<close>"], ["proof (chain)\npicking this:\n  R \\<inter> S = {}\n  alw (HLD S) \\<omega>\n  alw (HLD R) \\<omega>", "show False"], ["proof (prove)\nusing this:\n  R \\<inter> S = {}\n  alw (HLD S) \\<omega>\n  alw (HLD R) \\<omega>\n\ngoal (1 subgoal):\n 1. False", "by (auto 4 3 simp: HLD_iff dest: alwD)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: Move *)"], ["", "lemma stream_all2_refl: \"stream_all2 P x x = pred_stream (\\<lambda> x. P x x) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_all2 P x x = pred_stream (\\<lambda>x. P x x) x", "by (simp add: stream.pred_rel eq_onp_def) (standard; coinduction arbitrary: x; auto)"], ["", "lemma AE_all_imp_countable:\n  assumes \"countable {x. Q x}\"\n  shows \"(AE x in M. \\<forall>y. Q y \\<longrightarrow> P x y) = (\\<forall>y. Q y \\<longrightarrow> (AE x in M. P x y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (AE x in M. \\<forall>y. Q y \\<longrightarrow> P x y) =\n    (\\<forall>y. Q y \\<longrightarrow> (AE x in M. P x y))", "using assms"], ["proof (prove)\nusing this:\n  countable {x. Q x}\n\ngoal (1 subgoal):\n 1. (AE x in M. \\<forall>y. Q y \\<longrightarrow> P x y) =\n    (\\<forall>y. Q y \\<longrightarrow> (AE x in M. P x y))", "by (auto dest: AE_ball_countable)"], ["", "lemma AE_conj:\n  \"almost_everywhere M P = almost_everywhere M (\\<lambda> x. P x \\<and> Q x)\" if \"almost_everywhere M Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_everywhere M P = (AE x in M. P x \\<and> Q x)", "by (auto intro: AE_mp[OF that])"], ["", "(* TODO: move *)"], ["", "lemma list_hd_lastD:\n  assumes \"length xs > 1\"\n  obtains x y ys where \"xs = x # ys @ [y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x ys y.\n        xs = x # ys @ [y] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  1 < length xs\n\ngoal (1 subgoal):\n 1. (\\<And>x ys y.\n        xs = x # ys @ [y] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by atomize_elim (cases xs; simp; metis rev_exhaust)"], ["", "(* TODO: Move *)"], ["", "lemma SUP_eq_and_INF_eq:\n  assumes \"\\<And>i. i \\<in> A \\<Longrightarrow> \\<exists>j\\<in>B. f i = g j\"\n      and \"\\<And>j. j \\<in> B \\<Longrightarrow> \\<exists>i\\<in>A. g j = f i\"\n    shows \"\\<Squnion>((f :: _ \\<Rightarrow> _ :: complete_lattice) ` A) = \\<Squnion>(g ` B) \\<and> \\<Sqinter>(f ` A) = \\<Sqinter>(g ` B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> (f ` A) = \\<Squnion> (g ` B) \\<and>\n    \\<Sqinter> (f ` A) = \\<Sqinter> (g ` B)", "by (auto 4 3 intro!: INF_eq SUP_eq dest: assms)"], ["", "(* TODO: Move *)"], ["", "lemma measurable_alw_stream[measurable]:\n  fixes P assumes [measurable]: \"Measurable.pred (stream_space (count_space UNIV)) P\"\n  shows \"Measurable.pred (stream_space (count_space UNIV)) (alw P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Measurable.pred (stream_space (count_space UNIV)) (alw P)", "unfolding alw_iff_sdrop"], ["proof (prove)\ngoal (1 subgoal):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>\\<omega>. \\<forall>m. P (sdrop m \\<omega>))", "by measurable"], ["", "(* TODO: Move *)"], ["", "lemma ev_neq_start_implies_ev_neq:\n  assumes \"ev (Not o HLD {y}) (y ## xs)\"\n  shows \"ev (\\<lambda> xs. shd xs \\<noteq> shd (stl xs)) (y ## xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ev (\\<lambda>xs. shd xs \\<noteq> shd (stl xs)) (y ## xs)", "using assms"], ["proof (prove)\nusing this:\n  ev (Not \\<circ> HLD {y}) (y ## xs)\n\ngoal (1 subgoal):\n 1. ev (\\<lambda>xs. shd xs \\<noteq> shd (stl xs)) (y ## xs)", "apply (induction \"y ## xs\" arbitrary: xs rule: ev.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       (Not \\<circ> HLD {y}) (y ## xs) \\<Longrightarrow>\n       ev (\\<lambda>xs. shd xs \\<noteq> shd (stl xs)) (y ## xs)\n 2. \\<And>xs.\n       \\<lbrakk>ev (Not \\<circ> HLD {y}) (stl (y ## xs));\n        \\<And>xsa.\n           stl (y ## xs) = y ## xsa \\<Longrightarrow>\n           ev (\\<lambda>xs. shd xs \\<noteq> shd (stl xs))\n            (y ## xsa)\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>xs. shd xs \\<noteq> shd (stl xs))\n                          (y ## xs)", "apply (simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>ev (Not \\<circ> HLD {y}) (stl (y ## xs));\n        \\<And>xsa.\n           stl (y ## xs) = y ## xsa \\<Longrightarrow>\n           ev (\\<lambda>xs. shd xs \\<noteq> shd (stl xs))\n            (y ## xsa)\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>xs. shd xs \\<noteq> shd (stl xs))\n                          (y ## xs)", "subgoal for xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ev (Not \\<circ> HLD {y}) (stl (y ## xs));\n     \\<And>xs.\n        stl (y ## xs) = y ## xs \\<Longrightarrow>\n        ev (\\<lambda>xs. shd xs \\<noteq> shd (stl xs)) (y ## xs)\\<rbrakk>\n    \\<Longrightarrow> ev (\\<lambda>xs. shd xs \\<noteq> shd (stl xs))\n                       (y ## xs)", "apply (cases \"shd xs = y\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ev (Not \\<circ> HLD {y}) (stl (y ## xs));\n     \\<And>xs.\n        stl (y ## xs) = y ## xs \\<Longrightarrow>\n        ev (\\<lambda>xs. shd xs \\<noteq> shd (stl xs)) (y ## xs);\n     shd xs = y\\<rbrakk>\n    \\<Longrightarrow> ev (\\<lambda>xs. shd xs \\<noteq> shd (stl xs))\n                       (y ## xs)\n 2. \\<lbrakk>ev (Not \\<circ> HLD {y}) (stl (y ## xs));\n     \\<And>xs.\n        stl (y ## xs) = y ## xs \\<Longrightarrow>\n        ev (\\<lambda>xs. shd xs \\<noteq> shd (stl xs)) (y ## xs);\n     shd xs \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> ev (\\<lambda>xs. shd xs \\<noteq> shd (stl xs))\n                       (y ## xs)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ev (Not \\<circ> HLD {y}) (stl (y ## xs));\n     \\<And>xs.\n        stl (y ## xs) = y ## xs \\<Longrightarrow>\n        ev (\\<lambda>xs. shd xs \\<noteq> shd (stl xs)) (y ## xs);\n     shd xs = y\\<rbrakk>\n    \\<Longrightarrow> ev (\\<lambda>xs. shd xs \\<noteq> shd (stl xs))\n                       (y ## xs)", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ev (Not \\<circ> HLD {shd xs}) (stl (shd xs ## xs));\n     \\<And>xs.\n        stl (shd xs ## xs) = shd xs ## xs \\<Longrightarrow>\n        ev (\\<lambda>xs. shd xs \\<noteq> shd (stl xs)) (shd xs ## xs);\n     y = shd xs\\<rbrakk>\n    \\<Longrightarrow> ev (\\<lambda>xs. shd xs \\<noteq> shd (stl xs))\n                       (shd xs ## xs)", "apply (rule ev.step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ev (Not \\<circ> HLD {shd xs}) (stl (shd xs ## xs));\n     \\<And>xs.\n        stl (shd xs ## xs) = shd xs ## xs \\<Longrightarrow>\n        ev (\\<lambda>xs. shd xs \\<noteq> shd (stl xs)) (shd xs ## xs);\n     y = shd xs\\<rbrakk>\n    \\<Longrightarrow> ev (\\<lambda>xs. shd xs \\<noteq> shd (stl xs))\n                       (stl (shd xs ## xs))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ev (Not \\<circ> HLD {shd xs}) xs;\n     \\<And>xs.\n        xs = shd xs ## xs \\<Longrightarrow>\n        ev (\\<lambda>xs. shd xs \\<noteq> shd (stl xs)) xs;\n     y = shd xs\\<rbrakk>\n    \\<Longrightarrow> ev (\\<lambda>xs. shd xs \\<noteq> shd (stl xs)) xs", "using stream.collapse[of xs, symmetric]"], ["proof (prove)\nusing this:\n  xs = shd xs ## stl xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ev (Not \\<circ> HLD {shd xs}) xs;\n     \\<And>xs.\n        xs = shd xs ## xs \\<Longrightarrow>\n        ev (\\<lambda>xs. shd xs \\<noteq> shd (stl xs)) xs;\n     y = shd xs\\<rbrakk>\n    \\<Longrightarrow> ev (\\<lambda>xs. shd xs \\<noteq> shd (stl xs)) xs", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ev (Not \\<circ> HLD {y}) (stl (y ## xs));\n     \\<And>xs.\n        stl (y ## xs) = y ## xs \\<Longrightarrow>\n        ev (\\<lambda>xs. shd xs \\<noteq> shd (stl xs)) (y ## xs);\n     shd xs \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> ev (\\<lambda>xs. shd xs \\<noteq> shd (stl xs))\n                       (y ## xs)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ev (Not \\<circ> HLD {y}) (stl (y ## xs));\n     \\<And>xs.\n        stl (y ## xs) = y ## xs \\<Longrightarrow>\n        ev (\\<lambda>xs. shd xs \\<noteq> shd (stl xs)) (y ## xs);\n     shd xs \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> ev (\\<lambda>xs. shd xs \\<noteq> shd (stl xs))\n                       (y ## xs)", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* TODO: Move *)"], ["", "lemma ev_sdropD:\n  assumes \"ev P xs\"\n  obtains i where \"P (sdrop i xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. P (sdrop i xs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  ev P xs\n\ngoal (1 subgoal):\n 1. (\\<And>i. P (sdrop i xs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. ev P xs \\<Longrightarrow> \\<exists>i. P (sdrop i xs)", "apply (induction rule: ev.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs. P xs \\<Longrightarrow> \\<exists>i. P (sdrop i xs)\n 2. \\<And>xs.\n       \\<lbrakk>ev P (stl xs); \\<exists>i. P (sdrop i (stl xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. P (sdrop i xs)", "apply (inst_existentials \"0 :: nat\"; simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>ev P (stl xs); \\<exists>i. P (sdrop i (stl xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. P (sdrop i xs)", "apply (erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs i.\n       \\<lbrakk>ev P (stl xs); P (sdrop i (stl xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. P (sdrop i xs)", "subgoal for xs i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ev P (stl xs); P (sdrop i (stl xs))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. P (sdrop i xs)", "by (inst_existentials \"i + 1\") simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* TODO: Move *)"], ["", "lemma pred_stream_sconst:\n  \"pred_stream ((=) x) (sconst x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream ((=) x) (sconst x)", "by coinduction simp"], ["", "(* TODO: Move *)"], ["", "lemma alw_Stream: \"alw P (x ## s) \\<longleftrightarrow> P (x ## s) \\<and> alw P s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw P (x ## s) = (P (x ## s) \\<and> alw P s)", "by (subst alw.simps) simp"], ["", "(* TODO: Move *)"], ["", "lemma alw_True: \"alw (\\<lambda>x. True) \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (\\<lambda>x. True) \\<omega>", "by (auto intro: all_imp_alw)"], ["", "(* TODO: Move *)"], ["", "lemma alw_conjI:\n  \"alw (P aand Q) xs\" if \"alw P xs\" \"alw Q xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (\\<lambda>xs. P xs \\<and> Q xs) xs", "using that"], ["proof (prove)\nusing this:\n  alw P xs\n  alw Q xs\n\ngoal (1 subgoal):\n 1. alw (\\<lambda>xs. P xs \\<and> Q xs) xs", "by (simp add: alw_aand)"], ["", "(* TODO: Move *)"], ["", "lemma alw_ev_cong:\n  \"alw (ev S) xs = alw (ev R) xs\" if \"alw P xs\" \"\\<And> x. P x \\<Longrightarrow> S x \\<longleftrightarrow> R x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (ev S) xs = alw (ev R) xs", "by (rule alw_cong[where P = \"alw P\"]) (auto simp: HLD_iff that elim!: ev_cong)"], ["", "lemma alw_ev_HLD_cong:\n  \"alw (ev (HLD S)) xs = alw (ev (HLD R)) xs\" if \"alw (HLD P) xs\" \"\\<And> x. x \\<in> P \\<Longrightarrow> x \\<in> S \\<longleftrightarrow> x \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infs S xs = infs R xs", "by (rule alw_ev_cong, rule that; simp add: HLD_iff that)"], ["", "(* TODO: Move *)"], ["", "lemma measurable_eq_stream_space[measurable (raw)]:\n  assumes [measurable]: \"f \\<in> M \\<rightarrow>\\<^sub>M stream_space (count_space UNIV)\"\n  shows \"Measurable.pred M (\\<lambda>x. f x = c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Measurable.pred M (\\<lambda>x. f x = c)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Measurable.pred M (\\<lambda>x. f x = c)", "have *: \"(\\<lambda>x. f x = c) = (\\<lambda>x. \\<forall>i. f x !! i = c !! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. f x = c) = (\\<lambda>x. \\<forall>i. f x !! i = c !! i)", "by (auto intro: eqI_snth simp: fun_eq_iff)"], ["proof (state)\nthis:\n  (\\<lambda>x. f x = c) = (\\<lambda>x. \\<forall>i. f x !! i = c !! i)\n\ngoal (1 subgoal):\n 1. Measurable.pred M (\\<lambda>x. f x = c)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Measurable.pred M (\\<lambda>x. f x = c)", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. Measurable.pred M (\\<lambda>x. \\<forall>i. f x !! i = c !! i)", "by measurable"], ["proof (state)\nthis:\n  Measurable.pred M (\\<lambda>x. f x = c)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: rename, and change to LTL constants i.e. HLD, aand, nxt etc. *)"], ["", "lemma prop_nth_sdrop:\n  assumes \"\\<forall> i\\<ge>j. P (\\<omega> !! i)\"\n  shows \"\\<forall> i. P (sdrop j \\<omega> !! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. P (sdrop j \\<omega> !! i)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>i\\<ge>j. P (\\<omega> !! i)\n\ngoal (1 subgoal):\n 1. \\<forall>i. P (sdrop j \\<omega> !! i)", "by (induction j arbitrary: \\<omega>) fastforce+"], ["", "lemma prop_nth_sdrop_pair:\n  assumes \"\\<forall> i. P (\\<omega> !! i) (\\<omega>' !! i)\"\n  shows \"\\<forall> i. P (sdrop j \\<omega> !! i) (sdrop j \\<omega>' !! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. P (sdrop j \\<omega> !! i) (sdrop j \\<omega>' !! i)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>i. P (\\<omega> !! i) (\\<omega>' !! i)\n\ngoal (1 subgoal):\n 1. \\<forall>i. P (sdrop j \\<omega> !! i) (sdrop j \\<omega>' !! i)", "by (induction j arbitrary: \\<omega> \\<omega>') (auto, metis snth.simps(2))"], ["", "lemma prop_nth_stl:\n  \"\\<forall> i. P (xs !! i) \\<Longrightarrow> \\<forall> i. P (stl xs !! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. P (xs !! i) \\<Longrightarrow> \\<forall>i. P (stl xs !! i)", "by (metis snth.simps(2))"], ["", "context Graph_Defs\nbegin"], ["", "lemma steps_SCons_iff:\n  \"steps (x # y # xs) \\<longleftrightarrow> E x y \\<and> steps (y # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.steps (x # y # xs) =\n    (x \\<rightarrow> y \\<and> local.steps (y # xs))", "by (auto elim: steps.cases)"], ["", "lemma steps_Single_True:\n  \"steps [x] = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.steps [x] = True", "by auto"], ["", "lemma add_step_iff:\n  \"(\\<forall> xs y. steps (x # xs @ [y]) \\<and> length xs = Suc n \\<longrightarrow> P xs y)\n  \\<longleftrightarrow> (\\<forall> z xs y. steps (x # z # xs @ [y]) \\<and> length xs = n \\<longrightarrow> P (z # xs) y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>xs y.\n        local.steps (x # xs @ [y]) \\<and>\n        length xs = Suc n \\<longrightarrow>\n        P xs y) =\n    (\\<forall>z xs y.\n        local.steps (x # z # xs @ [y]) \\<and>\n        length xs = n \\<longrightarrow>\n        P (z # xs) y)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>z xs y.\n       \\<lbrakk>\\<forall>xsa y.\n                   local.steps (x # xsa @ [y]) \\<and>\n                   length xsa = Suc (length xs) \\<longrightarrow>\n                   P xsa y;\n        local.steps (x # z # xs @ [y]); n = length xs\\<rbrakk>\n       \\<Longrightarrow> P (z # xs) y\n 2. \\<And>xs y.\n       \\<lbrakk>\\<forall>z xs y.\n                   local.steps (x # z # xs @ [y]) \\<and>\n                   length xs = n \\<longrightarrow>\n                   P (z # xs) y;\n        local.steps (x # xs @ [y]); length xs = Suc n\\<rbrakk>\n       \\<Longrightarrow> P xs y", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs y.\n       \\<lbrakk>\\<forall>z xs y.\n                   local.steps (x # z # xs @ [y]) \\<and>\n                   length xs = n \\<longrightarrow>\n                   P (z # xs) y;\n        local.steps (x # xs @ [y]); length xs = Suc n\\<rbrakk>\n       \\<Longrightarrow> P xs y", "subgoal for xs y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>z xs y.\n                local.steps (x # z # xs @ [y]) \\<and>\n                length xs = n \\<longrightarrow>\n                P (z # xs) y;\n     local.steps (x # xs @ [y]); length xs = Suc n\\<rbrakk>\n    \\<Longrightarrow> P xs y", "by (cases xs) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma compower_stepsD:\n  assumes \"(E ^^ n) s s'\"\n  obtains xs where \"steps xs\" \"hd xs = s\" \"last xs = s'\" \"length xs = n + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>local.steps xs; hd xs = s; last xs = s';\n         length xs = n + 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  (E ^^ n) s s'\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>local.steps xs; hd xs = s; last xs = s';\n         length xs = n + 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. (E ^^ n) s s' \\<Longrightarrow>\n    \\<exists>xs.\n       local.steps xs \\<and>\n       hd xs = s \\<and> last xs = s' \\<and> length xs = n + 1", "proof (induction n arbitrary: s')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s'.\n       (E ^^ 0) s s' \\<Longrightarrow>\n       \\<exists>xs.\n          local.steps xs \\<and>\n          hd xs = s \\<and> last xs = s' \\<and> length xs = 0 + 1\n 2. \\<And>n s'.\n       \\<lbrakk>\\<And>s'.\n                   (E ^^ n) s s' \\<Longrightarrow>\n                   \\<exists>xs.\n                      local.steps xs \\<and>\n                      hd xs = s \\<and>\n                      last xs = s' \\<and> length xs = n + 1;\n        (E ^^ Suc n) s s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.steps xs \\<and>\n                            hd xs = s \\<and>\n                            last xs = s' \\<and> length xs = Suc n + 1", "case 0"], ["proof (state)\nthis:\n  (E ^^ 0) s s'\n\ngoal (2 subgoals):\n 1. \\<And>s'.\n       (E ^^ 0) s s' \\<Longrightarrow>\n       \\<exists>xs.\n          local.steps xs \\<and>\n          hd xs = s \\<and> last xs = s' \\<and> length xs = 0 + 1\n 2. \\<And>n s'.\n       \\<lbrakk>\\<And>s'.\n                   (E ^^ n) s s' \\<Longrightarrow>\n                   \\<exists>xs.\n                      local.steps xs \\<and>\n                      hd xs = s \\<and>\n                      last xs = s' \\<and> length xs = n + 1;\n        (E ^^ Suc n) s s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.steps xs \\<and>\n                            hd xs = s \\<and>\n                            last xs = s' \\<and> length xs = Suc n + 1", "then"], ["proof (chain)\npicking this:\n  (E ^^ 0) s s'", "show ?case"], ["proof (prove)\nusing this:\n  (E ^^ 0) s s'\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       local.steps xs \\<and>\n       hd xs = s \\<and> last xs = s' \\<and> length xs = 0 + 1", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs.\n     local.steps xs \\<and>\n     hd xs = s \\<and> last xs = s' \\<and> length xs = 0 + 1\n\ngoal (1 subgoal):\n 1. \\<And>n s'.\n       \\<lbrakk>\\<And>s'.\n                   (E ^^ n) s s' \\<Longrightarrow>\n                   \\<exists>xs.\n                      local.steps xs \\<and>\n                      hd xs = s \\<and>\n                      last xs = s' \\<and> length xs = n + 1;\n        (E ^^ Suc n) s s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.steps xs \\<and>\n                            hd xs = s \\<and>\n                            last xs = s' \\<and> length xs = Suc n + 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n s'.\n       \\<lbrakk>\\<And>s'.\n                   (E ^^ n) s s' \\<Longrightarrow>\n                   \\<exists>xs.\n                      local.steps xs \\<and>\n                      hd xs = s \\<and>\n                      last xs = s' \\<and> length xs = n + 1;\n        (E ^^ Suc n) s s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.steps xs \\<and>\n                            hd xs = s \\<and>\n                            last xs = s' \\<and> length xs = Suc n + 1", "case (Suc n)"], ["proof (state)\nthis:\n  (E ^^ n) s ?s' \\<Longrightarrow>\n  \\<exists>xs.\n     local.steps xs \\<and>\n     hd xs = s \\<and> last xs = ?s' \\<and> length xs = n + 1\n  (E ^^ Suc n) s s'\n\ngoal (1 subgoal):\n 1. \\<And>n s'.\n       \\<lbrakk>\\<And>s'.\n                   (E ^^ n) s s' \\<Longrightarrow>\n                   \\<exists>xs.\n                      local.steps xs \\<and>\n                      hd xs = s \\<and>\n                      last xs = s' \\<and> length xs = n + 1;\n        (E ^^ Suc n) s s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.steps xs \\<and>\n                            hd xs = s \\<and>\n                            last xs = s' \\<and> length xs = Suc n + 1", "from Suc.prems"], ["proof (chain)\npicking this:\n  (E ^^ Suc n) s s'", "show ?case"], ["proof (prove)\nusing this:\n  (E ^^ Suc n) s s'\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       local.steps xs \\<and>\n       hd xs = s \\<and> last xs = s' \\<and> length xs = Suc n + 1", "by (auto 4 4 intro: steps_append_single dest: Suc.IH)"], ["proof (state)\nthis:\n  \\<exists>xs.\n     local.steps xs \\<and>\n     hd xs = s \\<and> last xs = s' \\<and> length xs = Suc n + 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma compower_stepsD':\n  assumes \"(E ^^ n) s s'\" \"n > 0\"\n  obtains xs where \"steps (s # xs @ [s'])\" \"length xs + 1 = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>local.steps (s # xs @ [s']); length xs + 1 = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (rule compower_stepsD[OF assms(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>local.steps (s # xs @ [s']);\n                    length xs + 1 = n\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        local.steps xs; hd xs = s; last xs = s'; length xs = n + 1\\<rbrakk>\n       \\<Longrightarrow> thesis", "subgoal for xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs.\n                \\<lbrakk>local.steps (s # xs @ [s']);\n                 length xs + 1 = n\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     local.steps xs; hd xs = s; last xs = s'; length xs = n + 1\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (auto simp: \\<open>n > 0\\<close> intro: list_hd_lastD[of xs])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "context MC_syntax\nbegin"], ["", "theorem AE_T_iff_n:\n  fixes P :: \"'s stream \\<Rightarrow> bool\" \n    and x :: \"'s\" \n  assumes \"Measurable.pred (stream_space (count_space UNIV)) P\" \"n > 0\"\n  shows \"almost_everywhere (T x) P =\n    (\\<forall>xs y. Graph_Defs.steps (\\<lambda> a b. b \\<in> K a) (x # xs @ [y]) \\<and> length xs + 1 = n\n      \\<longrightarrow> (AE \\<omega> in T y. P (xs @- y ## \\<omega>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_everywhere (T x) P =\n    (\\<forall>xs y.\n        Graph_Defs.steps (\\<lambda>a b. b \\<in> set_pmf (K a))\n         (x # xs @ [y]) \\<and>\n        length xs + 1 = n \\<longrightarrow>\n        (AE \\<omega> in T y. P (xs @- y ## \\<omega>)))", "using assms"], ["proof (prove)\nusing this:\n  Measurable.pred (stream_space (count_space UNIV)) P\n  0 < n\n\ngoal (1 subgoal):\n 1. almost_everywhere (T x) P =\n    (\\<forall>xs y.\n        Graph_Defs.steps (\\<lambda>a b. b \\<in> set_pmf (K a))\n         (x # xs @ [y]) \\<and>\n        length xs + 1 = n \\<longrightarrow>\n        (AE \\<omega> in T y. P (xs @- y ## \\<omega>)))", "apply (induction n arbitrary: x P)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x P.\n       \\<lbrakk>Measurable.pred (stream_space (count_space UNIV)) P;\n        0 < 0\\<rbrakk>\n       \\<Longrightarrow> almost_everywhere (T x) P =\n                         (\\<forall>xs y.\n                             Graph_Defs.steps\n                              (\\<lambda>a b. b \\<in> set_pmf (K a))\n                              (x # xs @ [y]) \\<and>\n                             length xs + 1 = 0 \\<longrightarrow>\n                             (AE \\<omega> in T y. P (xs @- y ## \\<omega>)))\n 2. \\<And>n x P.\n       \\<lbrakk>\\<And>x P.\n                   \\<lbrakk>Measurable.pred\n                             (stream_space (count_space UNIV)) P;\n                    0 < n\\<rbrakk>\n                   \\<Longrightarrow> almost_everywhere (T x) P =\n                                     (\\<forall>xs y.\n   Graph_Defs.steps (\\<lambda>a b. b \\<in> set_pmf (K a))\n    (x # xs @ [y]) \\<and>\n   length xs + 1 = n \\<longrightarrow>\n   (AE \\<omega> in T y. P (xs @- y ## \\<omega>)));\n        Measurable.pred (stream_space (count_space UNIV)) P;\n        0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> almost_everywhere (T x) P =\n                         (\\<forall>xs y.\n                             Graph_Defs.steps\n                              (\\<lambda>a b. b \\<in> set_pmf (K a))\n                              (x # xs @ [y]) \\<and>\n                             length xs + 1 = Suc n \\<longrightarrow>\n                             (AE \\<omega> in T y. P (xs @- y ## \\<omega>)))", "apply (simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n x P.\n       \\<lbrakk>\\<And>x P.\n                   \\<lbrakk>Measurable.pred\n                             (stream_space (count_space UNIV)) P;\n                    0 < n\\<rbrakk>\n                   \\<Longrightarrow> almost_everywhere (T x) P =\n                                     (\\<forall>xs y.\n   Graph_Defs.steps (\\<lambda>a b. b \\<in> set_pmf (K a))\n    (x # xs @ [y]) \\<and>\n   length xs + 1 = n \\<longrightarrow>\n   (AE \\<omega> in T y. P (xs @- y ## \\<omega>)));\n        Measurable.pred (stream_space (count_space UNIV)) P;\n        0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> almost_everywhere (T x) P =\n                         (\\<forall>xs y.\n                             Graph_Defs.steps\n                              (\\<lambda>a b. b \\<in> set_pmf (K a))\n                              (x # xs @ [y]) \\<and>\n                             length xs + 1 = Suc n \\<longrightarrow>\n                             (AE \\<omega> in T y. P (xs @- y ## \\<omega>)))", "subgoal for n x P"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x P.\n                \\<lbrakk>Measurable.pred (stream_space (count_space UNIV))\n                          P;\n                 0 < n\\<rbrakk>\n                \\<Longrightarrow> almost_everywhere (T x) P =\n                                  (\\<forall>xs y.\nGraph_Defs.steps (\\<lambda>a b. b \\<in> set_pmf (K a)) (x # xs @ [y]) \\<and>\nlength xs + 1 = n \\<longrightarrow>\n(AE \\<omega> in T y. P (xs @- y ## \\<omega>)));\n     Measurable.pred (stream_space (count_space UNIV)) P; 0 < Suc n\\<rbrakk>\n    \\<Longrightarrow> almost_everywhere (T x) P =\n                      (\\<forall>xs y.\n                          Graph_Defs.steps\n                           (\\<lambda>a b. b \\<in> set_pmf (K a))\n                           (x # xs @ [y]) \\<and>\n                          length xs + 1 = Suc n \\<longrightarrow>\n                          (AE \\<omega> in T y. P (xs @- y ## \\<omega>)))", "apply (cases n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x P.\n                \\<lbrakk>Measurable.pred (stream_space (count_space UNIV))\n                          P;\n                 0 < n\\<rbrakk>\n                \\<Longrightarrow> almost_everywhere (T x) P =\n                                  (\\<forall>xs y.\nGraph_Defs.steps (\\<lambda>a b. b \\<in> set_pmf (K a)) (x # xs @ [y]) \\<and>\nlength xs + 1 = n \\<longrightarrow>\n(AE \\<omega> in T y. P (xs @- y ## \\<omega>)));\n     Measurable.pred (stream_space (count_space UNIV)) P; 0 < Suc n;\n     n = 0\\<rbrakk>\n    \\<Longrightarrow> almost_everywhere (T x) P =\n                      (\\<forall>xs y.\n                          Graph_Defs.steps\n                           (\\<lambda>a b. b \\<in> set_pmf (K a))\n                           (x # xs @ [y]) \\<and>\n                          length xs + 1 = Suc n \\<longrightarrow>\n                          (AE \\<omega> in T y. P (xs @- y ## \\<omega>)))\n 2. \\<And>nat.\n       \\<lbrakk>\\<And>x P.\n                   \\<lbrakk>Measurable.pred\n                             (stream_space (count_space UNIV)) P;\n                    0 < n\\<rbrakk>\n                   \\<Longrightarrow> almost_everywhere (T x) P =\n                                     (\\<forall>xs y.\n   Graph_Defs.steps (\\<lambda>a b. b \\<in> set_pmf (K a))\n    (x # xs @ [y]) \\<and>\n   length xs + 1 = n \\<longrightarrow>\n   (AE \\<omega> in T y. P (xs @- y ## \\<omega>)));\n        Measurable.pred (stream_space (count_space UNIV)) P; 0 < Suc n;\n        n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> almost_everywhere (T x) P =\n                         (\\<forall>xs y.\n                             Graph_Defs.steps\n                              (\\<lambda>a b. b \\<in> set_pmf (K a))\n                              (x # xs @ [y]) \\<and>\n                             length xs + 1 = Suc n \\<longrightarrow>\n                             (AE \\<omega> in T y. P (xs @- y ## \\<omega>)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x P.\n                \\<lbrakk>Measurable.pred (stream_space (count_space UNIV))\n                          P;\n                 0 < n\\<rbrakk>\n                \\<Longrightarrow> almost_everywhere (T x) P =\n                                  (\\<forall>xs y.\nGraph_Defs.steps (\\<lambda>a b. b \\<in> set_pmf (K a)) (x # xs @ [y]) \\<and>\nlength xs + 1 = n \\<longrightarrow>\n(AE \\<omega> in T y. P (xs @- y ## \\<omega>)));\n     Measurable.pred (stream_space (count_space UNIV)) P; 0 < Suc n;\n     n = 0\\<rbrakk>\n    \\<Longrightarrow> almost_everywhere (T x) P =\n                      (\\<forall>xs y.\n                          Graph_Defs.steps\n                           (\\<lambda>a b. b \\<in> set_pmf (K a))\n                           (x # xs @ [y]) \\<and>\n                          length xs + 1 = Suc n \\<longrightarrow>\n                          (AE \\<omega> in T y. P (xs @- y ## \\<omega>)))", "by (subst AE_T_iff) (auto simp: Graph_Defs.steps_SCons_iff Graph_Defs.steps_Single_True)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>x P.\n                   \\<lbrakk>Measurable.pred\n                             (stream_space (count_space UNIV)) P;\n                    0 < n\\<rbrakk>\n                   \\<Longrightarrow> almost_everywhere (T x) P =\n                                     (\\<forall>xs y.\n   Graph_Defs.steps (\\<lambda>a b. b \\<in> set_pmf (K a))\n    (x # xs @ [y]) \\<and>\n   length xs + 1 = n \\<longrightarrow>\n   (AE \\<omega> in T y. P (xs @- y ## \\<omega>)));\n        Measurable.pred (stream_space (count_space UNIV)) P; 0 < Suc n;\n        n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> almost_everywhere (T x) P =\n                         (\\<forall>xs y.\n                             Graph_Defs.steps\n                              (\\<lambda>a b. b \\<in> set_pmf (K a))\n                              (x # xs @ [y]) \\<and>\n                             length xs + 1 = Suc n \\<longrightarrow>\n                             (AE \\<omega> in T y. P (xs @- y ## \\<omega>)))", "subgoal premises prems for n'"], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_everywhere (T x) P =\n    (\\<forall>xs y.\n        Graph_Defs.steps (\\<lambda>a b. b \\<in> set_pmf (K a))\n         (x # xs @ [y]) \\<and>\n        length xs + 1 = Suc n \\<longrightarrow>\n        (AE \\<omega> in T y. P (xs @- y ## \\<omega>)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. almost_everywhere (T x) P =\n    (\\<forall>xs y.\n        Graph_Defs.steps (\\<lambda>a b. b \\<in> set_pmf (K a))\n         (x # xs @ [y]) \\<and>\n        length xs + 1 = Suc n \\<longrightarrow>\n        (AE \\<omega> in T y. P (xs @- y ## \\<omega>)))", "have *: \"Measurable.pred (stream_space (count_space UNIV)) (\\<lambda> \\<omega>. P (y ## \\<omega>))\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>\\<omega>. P (y ## \\<omega>))", "using prems(2)"], ["proof (prove)\nusing this:\n  Measurable.pred (stream_space (count_space UNIV)) P\n\ngoal (1 subgoal):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>\\<omega>. P (y ## \\<omega>))", "by measurable"], ["proof (state)\nthis:\n  Measurable.pred (stream_space (count_space UNIV))\n   (\\<lambda>\\<omega>. P (?y1 ## \\<omega>))\n\ngoal (1 subgoal):\n 1. almost_everywhere (T x) P =\n    (\\<forall>xs y.\n        Graph_Defs.steps (\\<lambda>a b. b \\<in> set_pmf (K a))\n         (x # xs @ [y]) \\<and>\n        length xs + 1 = Suc n \\<longrightarrow>\n        (AE \\<omega> in T y. P (xs @- y ## \\<omega>)))", "with prems(1)[OF *] prems(3-)"], ["proof (chain)\npicking this:\n  0 < n \\<Longrightarrow>\n  (AE \\<omega> in T ?x1. P (?y3 ## \\<omega>)) =\n  (\\<forall>xs y.\n      Graph_Defs.steps (\\<lambda>a b. b \\<in> set_pmf (K a))\n       (?x1 # xs @ [y]) \\<and>\n      length xs + 1 = n \\<longrightarrow>\n      (AE \\<omega> in T y. P (?y3 ## xs @- y ## \\<omega>)))\n  0 < Suc n\n  n = Suc n'\n  Measurable.pred (stream_space (count_space UNIV))\n   (\\<lambda>\\<omega>. P (?y1 ## \\<omega>))", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < n \\<Longrightarrow>\n  (AE \\<omega> in T ?x1. P (?y3 ## \\<omega>)) =\n  (\\<forall>xs y.\n      Graph_Defs.steps (\\<lambda>a b. b \\<in> set_pmf (K a))\n       (?x1 # xs @ [y]) \\<and>\n      length xs + 1 = n \\<longrightarrow>\n      (AE \\<omega> in T y. P (?y3 ## xs @- y ## \\<omega>)))\n  0 < Suc n\n  n = Suc n'\n  Measurable.pred (stream_space (count_space UNIV))\n   (\\<lambda>\\<omega>. P (?y1 ## \\<omega>))\n\ngoal (1 subgoal):\n 1. almost_everywhere (T x) P =\n    (\\<forall>xs y.\n        Graph_Defs.steps (\\<lambda>a b. b \\<in> set_pmf (K a))\n         (x # xs @ [y]) \\<and>\n        length xs + 1 = Suc n \\<longrightarrow>\n        (AE \\<omega> in T y. P (xs @- y ## \\<omega>)))", "by (auto simp: AE_T_iff[OF prems(2)] Graph_Defs.steps_SCons_iff Graph_Defs.add_step_iff)"], ["proof (state)\nthis:\n  almost_everywhere (T x) P =\n  (\\<forall>xs y.\n      Graph_Defs.steps (\\<lambda>a b. b \\<in> set_pmf (K a))\n       (x # xs @ [y]) \\<and>\n      length xs + 1 = Suc n \\<longrightarrow>\n      (AE \\<omega> in T y. P (xs @- y ## \\<omega>)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma AE_alw_accD:\n  fixes P assumes P: \"Measurable.pred (stream_space (count_space UNIV)) P\"\n  assumes *: \"almost_everywhere (T s) (alw P)\" \"(s, s') \\<in> acc\"\n  shows \"almost_everywhere (T s') (alw P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_everywhere (T s') (alw P)", "using *(2,1)"], ["proof (prove)\nusing this:\n  (s, s') \\<in> acc\n  almost_everywhere (T s) (alw P)\n\ngoal (1 subgoal):\n 1. almost_everywhere (T s') (alw P)", "proof induction"], ["proof (state)\ngoal (2 subgoals):\n 1. almost_everywhere (T s) (alw P) \\<Longrightarrow>\n    almost_everywhere (T s) (alw P)\n 2. \\<And>y z.\n       \\<lbrakk>(s, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x));\n        almost_everywhere (T s) (alw P) \\<Longrightarrow>\n        almost_everywhere (T y) (alw P);\n        almost_everywhere (T s) (alw P)\\<rbrakk>\n       \\<Longrightarrow> almost_everywhere (T z) (alw P)", "case (step y z)"], ["proof (state)\nthis:\n  (s, y) \\<in> acc\n  (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x))\n  almost_everywhere (T s) (alw P) \\<Longrightarrow>\n  almost_everywhere (T y) (alw P)\n  almost_everywhere (T s) (alw P)\n\ngoal (2 subgoals):\n 1. almost_everywhere (T s) (alw P) \\<Longrightarrow>\n    almost_everywhere (T s) (alw P)\n 2. \\<And>y z.\n       \\<lbrakk>(s, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x));\n        almost_everywhere (T s) (alw P) \\<Longrightarrow>\n        almost_everywhere (T y) (alw P);\n        almost_everywhere (T s) (alw P)\\<rbrakk>\n       \\<Longrightarrow> almost_everywhere (T z) (alw P)", "then"], ["proof (chain)\npicking this:\n  (s, y) \\<in> acc\n  (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x))\n  almost_everywhere (T s) (alw P) \\<Longrightarrow>\n  almost_everywhere (T y) (alw P)\n  almost_everywhere (T s) (alw P)", "have \"almost_everywhere (T y) (alw P)\" \"z \\<in> K y\""], ["proof (prove)\nusing this:\n  (s, y) \\<in> acc\n  (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x))\n  almost_everywhere (T s) (alw P) \\<Longrightarrow>\n  almost_everywhere (T y) (alw P)\n  almost_everywhere (T s) (alw P)\n\ngoal (1 subgoal):\n 1. almost_everywhere (T y) (alw P) &&& z \\<in> set_pmf (K y)", "by auto"], ["proof (state)\nthis:\n  almost_everywhere (T y) (alw P)\n  z \\<in> set_pmf (K y)\n\ngoal (2 subgoals):\n 1. almost_everywhere (T s) (alw P) \\<Longrightarrow>\n    almost_everywhere (T s) (alw P)\n 2. \\<And>y z.\n       \\<lbrakk>(s, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x));\n        almost_everywhere (T s) (alw P) \\<Longrightarrow>\n        almost_everywhere (T y) (alw P);\n        almost_everywhere (T s) (alw P)\\<rbrakk>\n       \\<Longrightarrow> almost_everywhere (T z) (alw P)", "then"], ["proof (chain)\npicking this:\n  almost_everywhere (T y) (alw P)\n  z \\<in> set_pmf (K y)", "have \"AE \\<omega> in T z. alw P (z ## \\<omega>)\""], ["proof (prove)\nusing this:\n  almost_everywhere (T y) (alw P)\n  z \\<in> set_pmf (K y)\n\ngoal (1 subgoal):\n 1. AE \\<omega> in T z. alw P (z ## \\<omega>)", "unfolding AE_T_iff[OF measurable_alw_stream[OF P], of y]"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>set_pmf (K y). AE \\<omega> in T y. alw P (y ## \\<omega>)\n  z \\<in> set_pmf (K y)\n\ngoal (1 subgoal):\n 1. AE \\<omega> in T z. alw P (z ## \\<omega>)", "by auto"], ["proof (state)\nthis:\n  AE \\<omega> in T z. alw P (z ## \\<omega>)\n\ngoal (2 subgoals):\n 1. almost_everywhere (T s) (alw P) \\<Longrightarrow>\n    almost_everywhere (T s) (alw P)\n 2. \\<And>y z.\n       \\<lbrakk>(s, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x));\n        almost_everywhere (T s) (alw P) \\<Longrightarrow>\n        almost_everywhere (T y) (alw P);\n        almost_everywhere (T s) (alw P)\\<rbrakk>\n       \\<Longrightarrow> almost_everywhere (T z) (alw P)", "then"], ["proof (chain)\npicking this:\n  AE \\<omega> in T z. alw P (z ## \\<omega>)", "show ?case"], ["proof (prove)\nusing this:\n  AE \\<omega> in T z. alw P (z ## \\<omega>)\n\ngoal (1 subgoal):\n 1. almost_everywhere (T z) (alw P)", "by eventually_elim auto"], ["proof (state)\nthis:\n  almost_everywhere (T z) (alw P)\n\ngoal (1 subgoal):\n 1. almost_everywhere (T s) (alw P) \\<Longrightarrow>\n    almost_everywhere (T s) (alw P)", "qed"], ["", "lemma acc_relfunD:\n  assumes \"(s, s') \\<in> acc\"\n  obtains n where \"((\\<lambda> a b. b \\<in> K a) ^^ n) s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        ((\\<lambda>a b. b \\<in> set_pmf (K a)) ^^ n) s s' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  (s, s') \\<in> acc\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        ((\\<lambda>a b. b \\<in> set_pmf (K a)) ^^ n) s s' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, s') \\<in> acc \\<Longrightarrow>\n    \\<exists>n. ((\\<lambda>a b. b \\<in> set_pmf (K a)) ^^ n) s s'", "apply (drule rtrancl_imp_relpow)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       (s, s') \\<in> (SIGMA x:UNIV. set_pmf (K x)) ^^ n \\<Longrightarrow>\n    \\<exists>n. ((\\<lambda>a b. b \\<in> set_pmf (K a)) ^^ n) s s'", "apply (erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       (s, s') \\<in> (SIGMA x:UNIV. set_pmf (K x)) ^^ n \\<Longrightarrow>\n       \\<exists>n. ((\\<lambda>a b. b \\<in> set_pmf (K a)) ^^ n) s s'", "subgoal for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, s') \\<in> (SIGMA x:UNIV. set_pmf (K x)) ^^ n \\<Longrightarrow>\n    \\<exists>n. ((\\<lambda>a b. b \\<in> set_pmf (K a)) ^^ n) s s'", "by (inst_existentials n) (induction n arbitrary: s'; auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* TODO: If we can show measurable_alw_stream, then this subsumed by the lemma above *)"], ["", "lemma AE_all_accD:\n  assumes \"almost_everywhere (T s) (pred_stream P)\" \"(s, s') \\<in> acc\"\n  shows \"almost_everywhere (T s') (pred_stream P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_everywhere (T s') (pred_stream P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. almost_everywhere (T s') (pred_stream P)", "from acc_relfunD[OF \\<open>_ \\<in> acc\\<close>]"], ["proof (chain)\npicking this:\n  (\\<And>n.\n      ((\\<lambda>a b. b \\<in> set_pmf (K a)) ^^ n) s s' \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain n where *: \"((\\<lambda> a b. b \\<in> K a) ^^ n) s s'\""], ["proof (prove)\nusing this:\n  (\\<And>n.\n      ((\\<lambda>a b. b \\<in> set_pmf (K a)) ^^ n) s s' \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        ((\\<lambda>a b. b \\<in> set_pmf (K a)) ^^ n) s s' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  ((\\<lambda>a b. b \\<in> set_pmf (K a)) ^^ n) s s'\n\ngoal (1 subgoal):\n 1. almost_everywhere (T s') (pred_stream P)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_everywhere (T s') (pred_stream P)", "proof (cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> almost_everywhere (T s') (pred_stream P)\n 2. n \\<noteq> 0 \\<Longrightarrow> almost_everywhere (T s') (pred_stream P)", "case True"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> almost_everywhere (T s') (pred_stream P)\n 2. n \\<noteq> 0 \\<Longrightarrow> almost_everywhere (T s') (pred_stream P)", "with * assms(1)"], ["proof (chain)\npicking this:\n  ((\\<lambda>a b. b \\<in> set_pmf (K a)) ^^ n) s s'\n  almost_everywhere (T s) (pred_stream P)\n  n = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>a b. b \\<in> set_pmf (K a)) ^^ n) s s'\n  almost_everywhere (T s) (pred_stream P)\n  n = 0\n\ngoal (1 subgoal):\n 1. almost_everywhere (T s') (pred_stream P)", "by auto"], ["proof (state)\nthis:\n  almost_everywhere (T s') (pred_stream P)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> almost_everywhere (T s') (pred_stream P)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> almost_everywhere (T s') (pred_stream P)", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> almost_everywhere (T s') (pred_stream P)", "then"], ["proof (chain)\npicking this:\n  n \\<noteq> 0", "have \"n > 0\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < n", "by simp"], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> almost_everywhere (T s') (pred_stream P)", "with *"], ["proof (chain)\npicking this:\n  ((\\<lambda>a b. b \\<in> set_pmf (K a)) ^^ n) s s'\n  0 < n", "obtain xs where\n      \"Graph_Defs.steps (\\<lambda>a b. b \\<in> set_pmf (K a)) (s # xs @ [s'])\" \"Suc (length xs) = n\""], ["proof (prove)\nusing this:\n  ((\\<lambda>a b. b \\<in> set_pmf (K a)) ^^ n) s s'\n  0 < n\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>Graph_Defs.steps (\\<lambda>a b. b \\<in> set_pmf (K a))\n                  (s # xs @ [s']);\n         Suc (length xs) = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: Graph_Defs.compower_stepsD')"], ["proof (state)\nthis:\n  Graph_Defs.steps (\\<lambda>a b. b \\<in> set_pmf (K a)) (s # xs @ [s'])\n  Suc (length xs) = n\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> almost_everywhere (T s') (pred_stream P)", "with assms(1)[unfolded AE_T_iff_n[OF measurable_pred_stream \\<open>n > 0\\<close>, of P s]]"], ["proof (chain)\npicking this:\n  \\<forall>xs y.\n     Graph_Defs.steps (\\<lambda>a b. b \\<in> set_pmf (K a))\n      (s # xs @ [y]) \\<and>\n     length xs + 1 = n \\<longrightarrow>\n     (AE \\<omega> in T y. pred_stream P (xs @- y ## \\<omega>))\n  Graph_Defs.steps (\\<lambda>a b. b \\<in> set_pmf (K a)) (s # xs @ [s'])\n  Suc (length xs) = n", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>xs y.\n     Graph_Defs.steps (\\<lambda>a b. b \\<in> set_pmf (K a))\n      (s # xs @ [y]) \\<and>\n     length xs + 1 = n \\<longrightarrow>\n     (AE \\<omega> in T y. pred_stream P (xs @- y ## \\<omega>))\n  Graph_Defs.steps (\\<lambda>a b. b \\<in> set_pmf (K a)) (s # xs @ [s'])\n  Suc (length xs) = n\n\ngoal (1 subgoal):\n 1. almost_everywhere (T s') (pred_stream P)", "by auto"], ["proof (state)\nthis:\n  almost_everywhere (T s') (pred_stream P)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  almost_everywhere (T s') (pred_stream P)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma AE_T_ev_HLD_infinite_strong':\n  assumes \"0 \\<le> r\" \"r < 1\"\n    and r: \"\\<And>x. x \\<in> X \\<inter> Y \\<Longrightarrow> measure_pmf.prob (K x) Y \\<le> r\"\n    and ae: \"AE \\<omega> in T x. alw (\\<lambda> \\<omega>. HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>) \\<omega>\"\n  shows \"AE \\<omega> in T x. ev (HLD (- Y)) \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_everywhere (T x) (ev (HLD (- Y)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. almost_everywhere (T x) (ev (HLD (- Y)))", "define run where \"run F = (HLD (Y - X)) suntil ((X \\<inter> Y) \\<cdot> Y \\<cdot> F)\" for F"], ["proof (state)\nthis:\n  run ?F =\n  HLD (Y - X) suntil\n  (\\<lambda>xs.\n      HLD (X \\<inter> Y) xs \\<and>\n      nxt (\\<lambda>xs. HLD Y xs \\<and> nxt ?F xs) xs)\n\ngoal (1 subgoal):\n 1. almost_everywhere (T x) (ev (HLD (- Y)))", "have le_gfp: \"alw (HLD Y) aand alw (\\<lambda> \\<omega>. HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>) \\<le> gfp run\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>xs.\n        alw (HLD Y) xs \\<and>\n        alw (\\<lambda>\\<omega>.\n                HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n         xs)\n    \\<le> gfp run", "proof (rule gfp_upperbound; clarsimp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>alw (HLD Y) x;\n        alw (\\<lambda>\\<omega>.\n                HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n         x\\<rbrakk>\n       \\<Longrightarrow> run (\\<lambda>xs.\n                                 alw (HLD Y) xs \\<and>\n                                 alw (\\<lambda>\\<omega>.\n   HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n                                  xs)\n                          x", "fix \\<omega>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>alw (HLD Y) x;\n        alw (\\<lambda>\\<omega>.\n                HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n         x\\<rbrakk>\n       \\<Longrightarrow> run (\\<lambda>xs.\n                                 alw (HLD Y) xs \\<and>\n                                 alw (\\<lambda>\\<omega>.\n   HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n                                  xs)\n                          x", "assume \"alw (HLD Y) \\<omega>\" \"alw (\\<lambda>\\<omega>. HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>) \\<omega>\""], ["proof (state)\nthis:\n  alw (HLD Y) \\<omega>\n  alw (\\<lambda>\\<omega>.\n          HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n   \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>alw (HLD Y) x;\n        alw (\\<lambda>\\<omega>.\n                HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n         x\\<rbrakk>\n       \\<Longrightarrow> run (\\<lambda>xs.\n                                 alw (HLD Y) xs \\<and>\n                                 alw (\\<lambda>\\<omega>.\n   HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n                                  xs)\n                          x", "then"], ["proof (chain)\npicking this:\n  alw (HLD Y) \\<omega>\n  alw (\\<lambda>\\<omega>.\n          HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n   \\<omega>", "have \"ev (HLD X) \\<omega>\" \"alw (HLD Y) \\<omega>\" \"alw (\\<lambda>\\<omega>. HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>) \\<omega>\""], ["proof (prove)\nusing this:\n  alw (HLD Y) \\<omega>\n  alw (\\<lambda>\\<omega>.\n          HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n   \\<omega>\n\ngoal (1 subgoal):\n 1. ev (HLD X) \\<omega> &&&\n    alw (HLD Y) \\<omega> &&&\n    alw (\\<lambda>\\<omega>.\n            HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n     \\<omega>", "by auto"], ["proof (state)\nthis:\n  ev (HLD X) \\<omega>\n  alw (HLD Y) \\<omega>\n  alw (\\<lambda>\\<omega>.\n          HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n   \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>alw (HLD Y) x;\n        alw (\\<lambda>\\<omega>.\n                HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n         x\\<rbrakk>\n       \\<Longrightarrow> run (\\<lambda>xs.\n                                 alw (HLD Y) xs \\<and>\n                                 alw (\\<lambda>\\<omega>.\n   HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n                                  xs)\n                          x", "then"], ["proof (chain)\npicking this:\n  ev (HLD X) \\<omega>\n  alw (HLD Y) \\<omega>\n  alw (\\<lambda>\\<omega>.\n          HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n   \\<omega>", "show \"run (\\<lambda>xs. alw (HLD Y) xs \\<and> alw (\\<lambda>\\<omega>. HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>) xs) \\<omega>\""], ["proof (prove)\nusing this:\n  ev (HLD X) \\<omega>\n  alw (HLD Y) \\<omega>\n  alw (\\<lambda>\\<omega>.\n          HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n   \\<omega>\n\ngoal (1 subgoal):\n 1. run (\\<lambda>xs.\n            alw (HLD Y) xs \\<and>\n            alw (\\<lambda>\\<omega>.\n                    HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n             xs)\n     \\<omega>", "proof (induction \\<omega> rule: ev_induct_strong)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>HLD X xs; alw (HLD Y) xs;\n        alw (\\<lambda>\\<omega>.\n                HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n         xs\\<rbrakk>\n       \\<Longrightarrow> run (\\<lambda>xs.\n                                 alw (HLD Y) xs \\<and>\n                                 alw (\\<lambda>\\<omega>.\n   HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n                                  xs)\n                          xs\n 2. \\<And>xs.\n       \\<lbrakk>ev (HLD X) (stl xs); \\<not> HLD X xs;\n        \\<lbrakk>alw (HLD Y) (stl xs);\n         alw (\\<lambda>\\<omega>.\n                 HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n          (stl xs)\\<rbrakk>\n        \\<Longrightarrow> run (\\<lambda>xs.\n                                  alw (HLD Y) xs \\<and>\n                                  alw (\\<lambda>\\<omega>.\n    HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n                                   xs)\n                           (stl xs);\n        alw (HLD Y) xs;\n        alw (\\<lambda>\\<omega>.\n                HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n         xs\\<rbrakk>\n       \\<Longrightarrow> run (\\<lambda>xs.\n                                 alw (HLD Y) xs \\<and>\n                                 alw (\\<lambda>\\<omega>.\n   HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n                                  xs)\n                          xs", "case (base \\<omega>)"], ["proof (state)\nthis:\n  HLD X \\<omega>\n  alw (HLD Y) \\<omega>\n  alw (\\<lambda>\\<omega>.\n          HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n   \\<omega>\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>HLD X xs; alw (HLD Y) xs;\n        alw (\\<lambda>\\<omega>.\n                HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n         xs\\<rbrakk>\n       \\<Longrightarrow> run (\\<lambda>xs.\n                                 alw (HLD Y) xs \\<and>\n                                 alw (\\<lambda>\\<omega>.\n   HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n                                  xs)\n                          xs\n 2. \\<And>xs.\n       \\<lbrakk>ev (HLD X) (stl xs); \\<not> HLD X xs;\n        \\<lbrakk>alw (HLD Y) (stl xs);\n         alw (\\<lambda>\\<omega>.\n                 HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n          (stl xs)\\<rbrakk>\n        \\<Longrightarrow> run (\\<lambda>xs.\n                                  alw (HLD Y) xs \\<and>\n                                  alw (\\<lambda>\\<omega>.\n    HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n                                   xs)\n                           (stl xs);\n        alw (HLD Y) xs;\n        alw (\\<lambda>\\<omega>.\n                HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n         xs\\<rbrakk>\n       \\<Longrightarrow> run (\\<lambda>xs.\n                                 alw (HLD Y) xs \\<and>\n                                 alw (\\<lambda>\\<omega>.\n   HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n                                  xs)\n                          xs", "then"], ["proof (chain)\npicking this:\n  HLD X \\<omega>\n  alw (HLD Y) \\<omega>\n  alw (\\<lambda>\\<omega>.\n          HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n   \\<omega>", "show ?case"], ["proof (prove)\nusing this:\n  HLD X \\<omega>\n  alw (HLD Y) \\<omega>\n  alw (\\<lambda>\\<omega>.\n          HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n   \\<omega>\n\ngoal (1 subgoal):\n 1. run (\\<lambda>xs.\n            alw (HLD Y) xs \\<and>\n            alw (\\<lambda>\\<omega>.\n                    HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n             xs)\n     \\<omega>", "by (cases \\<omega>) (auto intro!: suntil.base simp: alw_Stream run_def)"], ["proof (state)\nthis:\n  run (\\<lambda>xs.\n          alw (HLD Y) xs \\<and>\n          alw (\\<lambda>\\<omega>.\n                  HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n           xs)\n   \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>ev (HLD X) (stl xs); \\<not> HLD X xs;\n        \\<lbrakk>alw (HLD Y) (stl xs);\n         alw (\\<lambda>\\<omega>.\n                 HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n          (stl xs)\\<rbrakk>\n        \\<Longrightarrow> run (\\<lambda>xs.\n                                  alw (HLD Y) xs \\<and>\n                                  alw (\\<lambda>\\<omega>.\n    HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n                                   xs)\n                           (stl xs);\n        alw (HLD Y) xs;\n        alw (\\<lambda>\\<omega>.\n                HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n         xs\\<rbrakk>\n       \\<Longrightarrow> run (\\<lambda>xs.\n                                 alw (HLD Y) xs \\<and>\n                                 alw (\\<lambda>\\<omega>.\n   HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n                                  xs)\n                          xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>ev (HLD X) (stl xs); \\<not> HLD X xs;\n        \\<lbrakk>alw (HLD Y) (stl xs);\n         alw (\\<lambda>\\<omega>.\n                 HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n          (stl xs)\\<rbrakk>\n        \\<Longrightarrow> run (\\<lambda>xs.\n                                  alw (HLD Y) xs \\<and>\n                                  alw (\\<lambda>\\<omega>.\n    HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n                                   xs)\n                           (stl xs);\n        alw (HLD Y) xs;\n        alw (\\<lambda>\\<omega>.\n                HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n         xs\\<rbrakk>\n       \\<Longrightarrow> run (\\<lambda>xs.\n                                 alw (HLD Y) xs \\<and>\n                                 alw (\\<lambda>\\<omega>.\n   HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n                                  xs)\n                          xs", "case (step \\<omega>)"], ["proof (state)\nthis:\n  ev (HLD X) (stl \\<omega>)\n  \\<not> HLD X \\<omega>\n  \\<lbrakk>alw (HLD Y) (stl \\<omega>);\n   alw (\\<lambda>\\<omega>.\n           HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n    (stl \\<omega>)\\<rbrakk>\n  \\<Longrightarrow> run (\\<lambda>xs.\n                            alw (HLD Y) xs \\<and>\n                            alw (\\<lambda>\\<omega>.\n                                    HLD Y \\<omega> \\<longrightarrow>\n                                    ev (HLD X) \\<omega>)\n                             xs)\n                     (stl \\<omega>)\n  alw (HLD Y) \\<omega>\n  alw (\\<lambda>\\<omega>.\n          HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n   \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>ev (HLD X) (stl xs); \\<not> HLD X xs;\n        \\<lbrakk>alw (HLD Y) (stl xs);\n         alw (\\<lambda>\\<omega>.\n                 HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n          (stl xs)\\<rbrakk>\n        \\<Longrightarrow> run (\\<lambda>xs.\n                                  alw (HLD Y) xs \\<and>\n                                  alw (\\<lambda>\\<omega>.\n    HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n                                   xs)\n                           (stl xs);\n        alw (HLD Y) xs;\n        alw (\\<lambda>\\<omega>.\n                HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n         xs\\<rbrakk>\n       \\<Longrightarrow> run (\\<lambda>xs.\n                                 alw (HLD Y) xs \\<and>\n                                 alw (\\<lambda>\\<omega>.\n   HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n                                  xs)\n                          xs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. run (\\<lambda>xs.\n            alw (HLD Y) xs \\<and>\n            alw (\\<lambda>\\<omega>.\n                    HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n             xs)\n     \\<omega>", "unfolding run_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (HLD (Y - X) suntil\n     (\\<lambda>xs.\n         HLD (X \\<inter> Y) xs \\<and>\n         nxt (\\<lambda>xs.\n                 HLD Y xs \\<and>\n                 nxt (\\<lambda>xs.\n                         alw (HLD Y) xs \\<and>\n                         alw (\\<lambda>\\<omega>.\n                                 HLD Y \\<omega> \\<longrightarrow>\n                                 ev (HLD X) \\<omega>)\n                          xs)\n                  xs)\n          xs))\n     \\<omega>", "using \\<open>\\<not> HLD X \\<omega>\\<close> \\<open>alw (HLD Y) \\<omega>\\<close> step(3)[unfolded run_def] step(4,5)"], ["proof (prove)\nusing this:\n  \\<not> HLD X \\<omega>\n  alw (HLD Y) \\<omega>\n  \\<lbrakk>alw (HLD Y) (stl \\<omega>);\n   alw (\\<lambda>\\<omega>.\n           HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n    (stl \\<omega>)\\<rbrakk>\n  \\<Longrightarrow> (HLD (Y - X) suntil\n                     (\\<lambda>xs.\n                         HLD (X \\<inter> Y) xs \\<and>\n                         nxt (\\<lambda>xs.\n                                 HLD Y xs \\<and>\n                                 nxt (\\<lambda>xs.\n   alw (HLD Y) xs \\<and>\n   alw (\\<lambda>\\<omega>.\n           HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n    xs)\n                                  xs)\n                          xs))\n                     (stl \\<omega>)\n  alw (HLD Y) \\<omega>\n  alw (\\<lambda>\\<omega>.\n          HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n   \\<omega>\n\ngoal (1 subgoal):\n 1. (HLD (Y - X) suntil\n     (\\<lambda>xs.\n         HLD (X \\<inter> Y) xs \\<and>\n         nxt (\\<lambda>xs.\n                 HLD Y xs \\<and>\n                 nxt (\\<lambda>xs.\n                         alw (HLD Y) xs \\<and>\n                         alw (\\<lambda>\\<omega>.\n                                 HLD Y \\<omega> \\<longrightarrow>\n                                 ev (HLD X) \\<omega>)\n                          xs)\n                  xs)\n          xs))\n     \\<omega>", "by (auto 0 4 simp: HLD_def intro: suntil.step)"], ["proof (state)\nthis:\n  run (\\<lambda>xs.\n          alw (HLD Y) xs \\<and>\n          alw (\\<lambda>\\<omega>.\n                  HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n           xs)\n   \\<omega>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  run (\\<lambda>xs.\n          alw (HLD Y) xs \\<and>\n          alw (\\<lambda>\\<omega>.\n                  HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n           xs)\n   \\<omega>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>xs.\n      alw (HLD Y) xs \\<and>\n      alw (\\<lambda>\\<omega>.\n              HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n       xs)\n  \\<le> gfp run\n\ngoal (1 subgoal):\n 1. almost_everywhere (T x) (ev (HLD (- Y)))", "have cont_run: \"inf_continuous run\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_continuous run", "apply (auto simp: inf_continuous_def fun_eq_iff run_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>M x f.\n       \\<lbrakk>decseq M;\n        (HLD (Y - X) suntil\n         (\\<lambda>xs.\n             HLD (X \\<inter> Y) xs \\<and>\n             HLD Y (stl xs) \\<and> (\\<forall>x. M x (stl (stl xs)))))\n         x\\<rbrakk>\n       \\<Longrightarrow> (HLD (Y - X) suntil\n                          (\\<lambda>xs.\n                              HLD (X \\<inter> Y) xs \\<and>\n                              HLD Y (stl xs) \\<and> M f (stl (stl xs))))\n                          x\n 2. \\<And>M x.\n       \\<lbrakk>decseq M;\n        \\<forall>f.\n           (HLD (Y - X) suntil\n            (\\<lambda>xs.\n                HLD (X \\<inter> Y) xs \\<and>\n                HLD Y (stl xs) \\<and> M f (stl (stl xs))))\n            x\\<rbrakk>\n       \\<Longrightarrow> (HLD (Y - X) suntil\n                          (\\<lambda>xs.\n                              HLD (X \\<inter> Y) xs \\<and>\n                              HLD Y (stl xs) \\<and>\n                              (\\<forall>x. M x (stl (stl xs)))))\n                          x", "subgoal premises that for M x f"], ["proof (prove)\ngoal (1 subgoal):\n 1. (HLD (Y - X) suntil\n     (\\<lambda>xs.\n         HLD (X \\<inter> Y) xs \\<and>\n         HLD Y (stl xs) \\<and> M f (stl (stl xs))))\n     x", "by (rule suntil_mono[OF _ _ that(2) alw_True]) auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M x.\n       \\<lbrakk>decseq M;\n        \\<forall>f.\n           (HLD (Y - X) suntil\n            (\\<lambda>xs.\n                HLD (X \\<inter> Y) xs \\<and>\n                HLD Y (stl xs) \\<and> M f (stl (stl xs))))\n            x\\<rbrakk>\n       \\<Longrightarrow> (HLD (Y - X) suntil\n                          (\\<lambda>xs.\n                              HLD (X \\<inter> Y) xs \\<and>\n                              HLD Y (stl xs) \\<and>\n                              (\\<forall>x. M x (stl (stl xs)))))\n                          x", "subgoal premises that for M x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (HLD (Y - X) suntil\n     (\\<lambda>xs.\n         HLD (X \\<inter> Y) xs \\<and>\n         HLD Y (stl xs) \\<and> (\\<forall>x. M x (stl (stl xs)))))\n     x", "using that(2)[THEN spec, of 0] that(2)"], ["proof (prove)\nusing this:\n  (HLD (Y - X) suntil\n   (\\<lambda>xs.\n       HLD (X \\<inter> Y) xs \\<and>\n       HLD Y (stl xs) \\<and> M 0 (stl (stl xs))))\n   x\n  \\<forall>f.\n     (HLD (Y - X) suntil\n      (\\<lambda>xs.\n          HLD (X \\<inter> Y) xs \\<and>\n          HLD Y (stl xs) \\<and> M f (stl (stl xs))))\n      x\n\ngoal (1 subgoal):\n 1. (HLD (Y - X) suntil\n     (\\<lambda>xs.\n         HLD (X \\<inter> Y) xs \\<and>\n         HLD Y (stl xs) \\<and> (\\<forall>x. M x (stl (stl xs)))))\n     x", "proof (induction rule: suntil_induct_strong)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>HLD (X \\<inter> Y) \\<omega> \\<and>\n                HLD Y (stl \\<omega>) \\<and> M 0 (stl (stl \\<omega>));\n        \\<forall>f.\n           (HLD (Y - X) suntil\n            (\\<lambda>xs.\n                HLD (X \\<inter> Y) xs \\<and>\n                HLD Y (stl xs) \\<and> M f (stl (stl xs))))\n            \\<omega>\\<rbrakk>\n       \\<Longrightarrow> (HLD (Y - X) suntil\n                          (\\<lambda>xs.\n                              HLD (X \\<inter> Y) xs \\<and>\n                              HLD Y (stl xs) \\<and>\n                              (\\<forall>x. M x (stl (stl xs)))))\n                          \\<omega>\n 2. \\<And>\\<omega>.\n       \\<lbrakk>HLD (Y - X) \\<omega>;\n        \\<not> (HLD (X \\<inter> Y) \\<omega> \\<and>\n                HLD Y (stl \\<omega>) \\<and> M 0 (stl (stl \\<omega>)));\n        (HLD (Y - X) suntil\n         (\\<lambda>xs.\n             HLD (X \\<inter> Y) xs \\<and>\n             HLD Y (stl xs) \\<and> M 0 (stl (stl xs))))\n         (stl \\<omega>);\n        \\<forall>f.\n           (HLD (Y - X) suntil\n            (\\<lambda>xs.\n                HLD (X \\<inter> Y) xs \\<and>\n                HLD Y (stl xs) \\<and> M f (stl (stl xs))))\n            (stl \\<omega>) \\<Longrightarrow>\n        (HLD (Y - X) suntil\n         (\\<lambda>xs.\n             HLD (X \\<inter> Y) xs \\<and>\n             HLD Y (stl xs) \\<and> (\\<forall>x. M x (stl (stl xs)))))\n         (stl \\<omega>);\n        \\<forall>f.\n           (HLD (Y - X) suntil\n            (\\<lambda>xs.\n                HLD (X \\<inter> Y) xs \\<and>\n                HLD Y (stl xs) \\<and> M f (stl (stl xs))))\n            \\<omega>\\<rbrakk>\n       \\<Longrightarrow> (HLD (Y - X) suntil\n                          (\\<lambda>xs.\n                              HLD (X \\<inter> Y) xs \\<and>\n                              HLD Y (stl xs) \\<and>\n                              (\\<forall>x. M x (stl (stl xs)))))\n                          \\<omega>", "case (base \\<omega>)"], ["proof (state)\nthis:\n  HLD (X \\<inter> Y) \\<omega> \\<and>\n  HLD Y (stl \\<omega>) \\<and> M 0 (stl (stl \\<omega>))\n  \\<forall>f.\n     (HLD (Y - X) suntil\n      (\\<lambda>xs.\n          HLD (X \\<inter> Y) xs \\<and>\n          HLD Y (stl xs) \\<and> M f (stl (stl xs))))\n      \\<omega>\n\ngoal (2 subgoals):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>HLD (X \\<inter> Y) \\<omega> \\<and>\n                HLD Y (stl \\<omega>) \\<and> M 0 (stl (stl \\<omega>));\n        \\<forall>f.\n           (HLD (Y - X) suntil\n            (\\<lambda>xs.\n                HLD (X \\<inter> Y) xs \\<and>\n                HLD Y (stl xs) \\<and> M f (stl (stl xs))))\n            \\<omega>\\<rbrakk>\n       \\<Longrightarrow> (HLD (Y - X) suntil\n                          (\\<lambda>xs.\n                              HLD (X \\<inter> Y) xs \\<and>\n                              HLD Y (stl xs) \\<and>\n                              (\\<forall>x. M x (stl (stl xs)))))\n                          \\<omega>\n 2. \\<And>\\<omega>.\n       \\<lbrakk>HLD (Y - X) \\<omega>;\n        \\<not> (HLD (X \\<inter> Y) \\<omega> \\<and>\n                HLD Y (stl \\<omega>) \\<and> M 0 (stl (stl \\<omega>)));\n        (HLD (Y - X) suntil\n         (\\<lambda>xs.\n             HLD (X \\<inter> Y) xs \\<and>\n             HLD Y (stl xs) \\<and> M 0 (stl (stl xs))))\n         (stl \\<omega>);\n        \\<forall>f.\n           (HLD (Y - X) suntil\n            (\\<lambda>xs.\n                HLD (X \\<inter> Y) xs \\<and>\n                HLD Y (stl xs) \\<and> M f (stl (stl xs))))\n            (stl \\<omega>) \\<Longrightarrow>\n        (HLD (Y - X) suntil\n         (\\<lambda>xs.\n             HLD (X \\<inter> Y) xs \\<and>\n             HLD Y (stl xs) \\<and> (\\<forall>x. M x (stl (stl xs)))))\n         (stl \\<omega>);\n        \\<forall>f.\n           (HLD (Y - X) suntil\n            (\\<lambda>xs.\n                HLD (X \\<inter> Y) xs \\<and>\n                HLD Y (stl xs) \\<and> M f (stl (stl xs))))\n            \\<omega>\\<rbrakk>\n       \\<Longrightarrow> (HLD (Y - X) suntil\n                          (\\<lambda>xs.\n                              HLD (X \\<inter> Y) xs \\<and>\n                              HLD Y (stl xs) \\<and>\n                              (\\<forall>x. M x (stl (stl xs)))))\n                          \\<omega>", "then"], ["proof (chain)\npicking this:\n  HLD (X \\<inter> Y) \\<omega> \\<and>\n  HLD Y (stl \\<omega>) \\<and> M 0 (stl (stl \\<omega>))\n  \\<forall>f.\n     (HLD (Y - X) suntil\n      (\\<lambda>xs.\n          HLD (X \\<inter> Y) xs \\<and>\n          HLD Y (stl xs) \\<and> M f (stl (stl xs))))\n      \\<omega>", "show ?case"], ["proof (prove)\nusing this:\n  HLD (X \\<inter> Y) \\<omega> \\<and>\n  HLD Y (stl \\<omega>) \\<and> M 0 (stl (stl \\<omega>))\n  \\<forall>f.\n     (HLD (Y - X) suntil\n      (\\<lambda>xs.\n          HLD (X \\<inter> Y) xs \\<and>\n          HLD Y (stl xs) \\<and> M f (stl (stl xs))))\n      \\<omega>\n\ngoal (1 subgoal):\n 1. (HLD (Y - X) suntil\n     (\\<lambda>xs.\n         HLD (X \\<inter> Y) xs \\<and>\n         HLD Y (stl xs) \\<and> (\\<forall>x. M x (stl (stl xs)))))\n     \\<omega>", "by (cases \\<omega>) (simp add: suntil_Stream)"], ["proof (state)\nthis:\n  (HLD (Y - X) suntil\n   (\\<lambda>xs.\n       HLD (X \\<inter> Y) xs \\<and>\n       HLD Y (stl xs) \\<and> (\\<forall>x. M x (stl (stl xs)))))\n   \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>HLD (Y - X) \\<omega>;\n        \\<not> (HLD (X \\<inter> Y) \\<omega> \\<and>\n                HLD Y (stl \\<omega>) \\<and> M 0 (stl (stl \\<omega>)));\n        (HLD (Y - X) suntil\n         (\\<lambda>xs.\n             HLD (X \\<inter> Y) xs \\<and>\n             HLD Y (stl xs) \\<and> M 0 (stl (stl xs))))\n         (stl \\<omega>);\n        \\<forall>f.\n           (HLD (Y - X) suntil\n            (\\<lambda>xs.\n                HLD (X \\<inter> Y) xs \\<and>\n                HLD Y (stl xs) \\<and> M f (stl (stl xs))))\n            (stl \\<omega>) \\<Longrightarrow>\n        (HLD (Y - X) suntil\n         (\\<lambda>xs.\n             HLD (X \\<inter> Y) xs \\<and>\n             HLD Y (stl xs) \\<and> (\\<forall>x. M x (stl (stl xs)))))\n         (stl \\<omega>);\n        \\<forall>f.\n           (HLD (Y - X) suntil\n            (\\<lambda>xs.\n                HLD (X \\<inter> Y) xs \\<and>\n                HLD Y (stl xs) \\<and> M f (stl (stl xs))))\n            \\<omega>\\<rbrakk>\n       \\<Longrightarrow> (HLD (Y - X) suntil\n                          (\\<lambda>xs.\n                              HLD (X \\<inter> Y) xs \\<and>\n                              HLD Y (stl xs) \\<and>\n                              (\\<forall>x. M x (stl (stl xs)))))\n                          \\<omega>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>HLD (Y - X) \\<omega>;\n        \\<not> (HLD (X \\<inter> Y) \\<omega> \\<and>\n                HLD Y (stl \\<omega>) \\<and> M 0 (stl (stl \\<omega>)));\n        (HLD (Y - X) suntil\n         (\\<lambda>xs.\n             HLD (X \\<inter> Y) xs \\<and>\n             HLD Y (stl xs) \\<and> M 0 (stl (stl xs))))\n         (stl \\<omega>);\n        \\<forall>f.\n           (HLD (Y - X) suntil\n            (\\<lambda>xs.\n                HLD (X \\<inter> Y) xs \\<and>\n                HLD Y (stl xs) \\<and> M f (stl (stl xs))))\n            (stl \\<omega>) \\<Longrightarrow>\n        (HLD (Y - X) suntil\n         (\\<lambda>xs.\n             HLD (X \\<inter> Y) xs \\<and>\n             HLD Y (stl xs) \\<and> (\\<forall>x. M x (stl (stl xs)))))\n         (stl \\<omega>);\n        \\<forall>f.\n           (HLD (Y - X) suntil\n            (\\<lambda>xs.\n                HLD (X \\<inter> Y) xs \\<and>\n                HLD Y (stl xs) \\<and> M f (stl (stl xs))))\n            \\<omega>\\<rbrakk>\n       \\<Longrightarrow> (HLD (Y - X) suntil\n                          (\\<lambda>xs.\n                              HLD (X \\<inter> Y) xs \\<and>\n                              HLD Y (stl xs) \\<and>\n                              (\\<forall>x. M x (stl (stl xs)))))\n                          \\<omega>", "case (step \\<omega>)"], ["proof (state)\nthis:\n  HLD (Y - X) \\<omega>\n  \\<not> (HLD (X \\<inter> Y) \\<omega> \\<and>\n          HLD Y (stl \\<omega>) \\<and> M 0 (stl (stl \\<omega>)))\n  (HLD (Y - X) suntil\n   (\\<lambda>xs.\n       HLD (X \\<inter> Y) xs \\<and>\n       HLD Y (stl xs) \\<and> M 0 (stl (stl xs))))\n   (stl \\<omega>)\n  \\<forall>f.\n     (HLD (Y - X) suntil\n      (\\<lambda>xs.\n          HLD (X \\<inter> Y) xs \\<and>\n          HLD Y (stl xs) \\<and> M f (stl (stl xs))))\n      (stl \\<omega>) \\<Longrightarrow>\n  (HLD (Y - X) suntil\n   (\\<lambda>xs.\n       HLD (X \\<inter> Y) xs \\<and>\n       HLD Y (stl xs) \\<and> (\\<forall>x. M x (stl (stl xs)))))\n   (stl \\<omega>)\n  \\<forall>f.\n     (HLD (Y - X) suntil\n      (\\<lambda>xs.\n          HLD (X \\<inter> Y) xs \\<and>\n          HLD Y (stl xs) \\<and> M f (stl (stl xs))))\n      \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>HLD (Y - X) \\<omega>;\n        \\<not> (HLD (X \\<inter> Y) \\<omega> \\<and>\n                HLD Y (stl \\<omega>) \\<and> M 0 (stl (stl \\<omega>)));\n        (HLD (Y - X) suntil\n         (\\<lambda>xs.\n             HLD (X \\<inter> Y) xs \\<and>\n             HLD Y (stl xs) \\<and> M 0 (stl (stl xs))))\n         (stl \\<omega>);\n        \\<forall>f.\n           (HLD (Y - X) suntil\n            (\\<lambda>xs.\n                HLD (X \\<inter> Y) xs \\<and>\n                HLD Y (stl xs) \\<and> M f (stl (stl xs))))\n            (stl \\<omega>) \\<Longrightarrow>\n        (HLD (Y - X) suntil\n         (\\<lambda>xs.\n             HLD (X \\<inter> Y) xs \\<and>\n             HLD Y (stl xs) \\<and> (\\<forall>x. M x (stl (stl xs)))))\n         (stl \\<omega>);\n        \\<forall>f.\n           (HLD (Y - X) suntil\n            (\\<lambda>xs.\n                HLD (X \\<inter> Y) xs \\<and>\n                HLD Y (stl xs) \\<and> M f (stl (stl xs))))\n            \\<omega>\\<rbrakk>\n       \\<Longrightarrow> (HLD (Y - X) suntil\n                          (\\<lambda>xs.\n                              HLD (X \\<inter> Y) xs \\<and>\n                              HLD Y (stl xs) \\<and>\n                              (\\<forall>x. M x (stl (stl xs)))))\n                          \\<omega>", "then"], ["proof (chain)\npicking this:\n  HLD (Y - X) \\<omega>\n  \\<not> (HLD (X \\<inter> Y) \\<omega> \\<and>\n          HLD Y (stl \\<omega>) \\<and> M 0 (stl (stl \\<omega>)))\n  (HLD (Y - X) suntil\n   (\\<lambda>xs.\n       HLD (X \\<inter> Y) xs \\<and>\n       HLD Y (stl xs) \\<and> M 0 (stl (stl xs))))\n   (stl \\<omega>)\n  \\<forall>f.\n     (HLD (Y - X) suntil\n      (\\<lambda>xs.\n          HLD (X \\<inter> Y) xs \\<and>\n          HLD Y (stl xs) \\<and> M f (stl (stl xs))))\n      (stl \\<omega>) \\<Longrightarrow>\n  (HLD (Y - X) suntil\n   (\\<lambda>xs.\n       HLD (X \\<inter> Y) xs \\<and>\n       HLD Y (stl xs) \\<and> (\\<forall>x. M x (stl (stl xs)))))\n   (stl \\<omega>)\n  \\<forall>f.\n     (HLD (Y - X) suntil\n      (\\<lambda>xs.\n          HLD (X \\<inter> Y) xs \\<and>\n          HLD Y (stl xs) \\<and> M f (stl (stl xs))))\n      \\<omega>", "show ?case"], ["proof (prove)\nusing this:\n  HLD (Y - X) \\<omega>\n  \\<not> (HLD (X \\<inter> Y) \\<omega> \\<and>\n          HLD Y (stl \\<omega>) \\<and> M 0 (stl (stl \\<omega>)))\n  (HLD (Y - X) suntil\n   (\\<lambda>xs.\n       HLD (X \\<inter> Y) xs \\<and>\n       HLD Y (stl xs) \\<and> M 0 (stl (stl xs))))\n   (stl \\<omega>)\n  \\<forall>f.\n     (HLD (Y - X) suntil\n      (\\<lambda>xs.\n          HLD (X \\<inter> Y) xs \\<and>\n          HLD Y (stl xs) \\<and> M f (stl (stl xs))))\n      (stl \\<omega>) \\<Longrightarrow>\n  (HLD (Y - X) suntil\n   (\\<lambda>xs.\n       HLD (X \\<inter> Y) xs \\<and>\n       HLD Y (stl xs) \\<and> (\\<forall>x. M x (stl (stl xs)))))\n   (stl \\<omega>)\n  \\<forall>f.\n     (HLD (Y - X) suntil\n      (\\<lambda>xs.\n          HLD (X \\<inter> Y) xs \\<and>\n          HLD Y (stl xs) \\<and> M f (stl (stl xs))))\n      \\<omega>\n\ngoal (1 subgoal):\n 1. (HLD (Y - X) suntil\n     (\\<lambda>xs.\n         HLD (X \\<inter> Y) xs \\<and>\n         HLD Y (stl xs) \\<and> (\\<forall>x. M x (stl (stl xs)))))\n     \\<omega>", "by (cases \\<omega>) (simp add: suntil_Stream)"], ["proof (state)\nthis:\n  (HLD (Y - X) suntil\n   (\\<lambda>xs.\n       HLD (X \\<inter> Y) xs \\<and>\n       HLD Y (stl xs) \\<and> (\\<forall>x. M x (stl (stl xs)))))\n   \\<omega>\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  inf_continuous run\n\ngoal (1 subgoal):\n 1. almost_everywhere (T x) (ev (HLD (- Y)))", "have [measurable]: \"Measurable.pred (stream_space (count_space UNIV)) (gfp run)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Measurable.pred (stream_space (count_space UNIV)) (gfp run)", "apply measurable"], ["proof (prove)\ngoal (1 subgoal):\n 1. Measurable.pred (stream_space (count_space UNIV)) (gfp run)", "apply (rule measurable_gfp[OF cont_run])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A.\n       Measurable.pred (stream_space (count_space UNIV)) A \\<Longrightarrow>\n       Measurable.pred (stream_space (count_space UNIV)) (run A)", "apply (auto simp: run_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Measurable.pred (stream_space (count_space UNIV)) (gfp run)\n\ngoal (1 subgoal):\n 1. almost_everywhere (T x) (ev (HLD (- Y)))", "have \"emeasure (T x) {\\<omega> \\<in> space (T x). alw (HLD Y) \\<omega>} \\<le>\n    emeasure (T x) {\\<omega> \\<in> space (T x). ((alw (HLD Y)) aand (alw (\\<lambda> \\<omega>. HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>))) \\<omega>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (T x) {\\<omega> \\<in> space (T x). alw (HLD Y) \\<omega>}\n    \\<le> emeasure (T x)\n           {\\<omega> \\<in> space (T x).\n            alw (HLD Y) \\<omega> \\<and>\n            alw (\\<lambda>\\<omega>.\n                    HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n             \\<omega>}", "apply (rule emeasure_mono_AE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. AE xa\\<in>{\\<omega> \\<in> space (T x). alw (HLD Y) \\<omega>} in T x.\n    xa \\<in> {\\<omega> \\<in> space (T x).\n              alw (HLD Y) \\<omega> \\<and>\n              alw (\\<lambda>\\<omega>.\n                      HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n               \\<omega>}\n 2. {\\<omega> \\<in> space (T x).\n     alw (HLD Y) \\<omega> \\<and>\n     alw (\\<lambda>\\<omega>.\n             HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n      \\<omega>}\n    \\<in> T.events x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE xa\\<in>{\\<omega> \\<in> space (T x). alw (HLD Y) \\<omega>} in T x.\n    xa \\<in> {\\<omega> \\<in> space (T x).\n              alw (HLD Y) \\<omega> \\<and>\n              alw (\\<lambda>\\<omega>.\n                      HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n               \\<omega>}", "using ae"], ["proof (prove)\nusing this:\n  almost_everywhere (T x)\n   (alw (\\<lambda>\\<omega>.\n            HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>))\n\ngoal (1 subgoal):\n 1. AE xa\\<in>{\\<omega> \\<in> space (T x). alw (HLD Y) \\<omega>} in T x.\n    xa \\<in> {\\<omega> \\<in> space (T x).\n              alw (HLD Y) \\<omega> \\<and>\n              alw (\\<lambda>\\<omega>.\n                      HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n               \\<omega>}", "by eventually_elim auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<omega> \\<in> space (T x).\n     alw (HLD Y) \\<omega> \\<and>\n     alw (\\<lambda>\\<omega>.\n             HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n      \\<omega>}\n    \\<in> T.events x", "by measurable"], ["proof (state)\nthis:\n  emeasure (T x) {\\<omega> \\<in> space (T x). alw (HLD Y) \\<omega>}\n  \\<le> emeasure (T x)\n         {\\<omega> \\<in> space (T x).\n          alw (HLD Y) \\<omega> \\<and>\n          alw (\\<lambda>\\<omega>.\n                  HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n           \\<omega>}\n\ngoal (1 subgoal):\n 1. almost_everywhere (T x) (ev (HLD (- Y)))", "also"], ["proof (state)\nthis:\n  emeasure (T x) {\\<omega> \\<in> space (T x). alw (HLD Y) \\<omega>}\n  \\<le> emeasure (T x)\n         {\\<omega> \\<in> space (T x).\n          alw (HLD Y) \\<omega> \\<and>\n          alw (\\<lambda>\\<omega>.\n                  HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n           \\<omega>}\n\ngoal (1 subgoal):\n 1. almost_everywhere (T x) (ev (HLD (- Y)))", "have \"\\<dots> \\<le> emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (T x)\n     {\\<omega> \\<in> space (T x).\n      alw (HLD Y) \\<omega> \\<and>\n      alw (\\<lambda>\\<omega>.\n              HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n       \\<omega>}\n    \\<le> emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}", "apply (rule emeasure_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {\\<omega> \\<in> space (T x).\n     alw (HLD Y) \\<omega> \\<and>\n     alw (\\<lambda>\\<omega>.\n             HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n      \\<omega>}\n    \\<subseteq> {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n 2. {\\<omega> \\<in> space (T x). gfp run \\<omega>} \\<in> T.events x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<omega> \\<in> space (T x).\n     alw (HLD Y) \\<omega> \\<and>\n     alw (\\<lambda>\\<omega>.\n             HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n      \\<omega>}\n    \\<subseteq> {\\<omega> \\<in> space (T x). gfp run \\<omega>}", "using le_gfp"], ["proof (prove)\nusing this:\n  (\\<lambda>xs.\n      alw (HLD Y) xs \\<and>\n      alw (\\<lambda>\\<omega>.\n              HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n       xs)\n  \\<le> gfp run\n\ngoal (1 subgoal):\n 1. {\\<omega> \\<in> space (T x).\n     alw (HLD Y) \\<omega> \\<and>\n     alw (\\<lambda>\\<omega>.\n             HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n      \\<omega>}\n    \\<subseteq> {\\<omega> \\<in> space (T x). gfp run \\<omega>}", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<omega> \\<in> space (T x). gfp run \\<omega>} \\<in> T.events x", "by measurable"], ["proof (state)\nthis:\n  emeasure (T x)\n   {\\<omega> \\<in> space (T x).\n    alw (HLD Y) \\<omega> \\<and>\n    alw (\\<lambda>\\<omega>.\n            HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n     \\<omega>}\n  \\<le> emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n\ngoal (1 subgoal):\n 1. almost_everywhere (T x) (ev (HLD (- Y)))", "also"], ["proof (state)\nthis:\n  emeasure (T x)\n   {\\<omega> \\<in> space (T x).\n    alw (HLD Y) \\<omega> \\<and>\n    alw (\\<lambda>\\<omega>.\n            HLD Y \\<omega> \\<longrightarrow> ev (HLD X) \\<omega>)\n     \\<omega>}\n  \\<le> emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n\ngoal (1 subgoal):\n 1. almost_everywhere (T x) (ev (HLD (- Y)))", "have \"\\<dots> \\<le> r ^ n\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n    \\<le> ennreal (r ^ n)", "proof (induction n arbitrary: x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n       \\<le> ennreal (r ^ 0)\n 2. \\<And>n x.\n       (\\<And>x.\n           emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n           \\<le> ennreal (r ^ n)) \\<Longrightarrow>\n       emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n       \\<le> ennreal (r ^ Suc n)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>x.\n       emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n       \\<le> ennreal (r ^ 0)\n 2. \\<And>n x.\n       (\\<And>x.\n           emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n           \\<le> ennreal (r ^ n)) \\<Longrightarrow>\n       emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n       \\<le> ennreal (r ^ Suc n)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n    \\<le> ennreal (r ^ 0)", "by (simp add: T.emeasure_le_1)"], ["proof (state)\nthis:\n  emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n  \\<le> ennreal (r ^ 0)\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n           \\<le> ennreal (r ^ n)) \\<Longrightarrow>\n       emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n       \\<le> ennreal (r ^ Suc n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n           \\<le> ennreal (r ^ n)) \\<Longrightarrow>\n       emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n       \\<le> ennreal (r ^ Suc n)", "case (Suc n)"], ["proof (state)\nthis:\n  emeasure (T ?x1) {\\<omega> \\<in> space (T ?x1). gfp run \\<omega>}\n  \\<le> ennreal (r ^ n)\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n           \\<le> ennreal (r ^ n)) \\<Longrightarrow>\n       emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n       \\<le> ennreal (r ^ Suc n)", "{"], ["proof (state)\nthis:\n  emeasure (T ?x1) {\\<omega> \\<in> space (T ?x1). gfp run \\<omega>}\n  \\<le> ennreal (r ^ n)\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n           \\<le> ennreal (r ^ n)) \\<Longrightarrow>\n       emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n       \\<le> ennreal (r ^ Suc n)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n           \\<le> ennreal (r ^ n)) \\<Longrightarrow>\n       emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n       \\<le> ennreal (r ^ Suc n)", "have \"(\\<integral>\\<^sup>+ t. \\<integral>\\<^sup>+ t'. emeasure (T t') {x\\<in>space S. t\\<in>X \\<and> t\\<in>Y \\<and> t'\\<in>Y \\<and> gfp run x} \\<partial>K t \\<partial>K x) \\<le>\n        (\\<integral>\\<^sup>+ t. indicator (X \\<inter> Y) t * \\<integral>\\<^sup>+ t'. indicator Y t' * ennreal (r ^ n) \\<partial>K t \\<partial>K x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ t. \\<integral>\\<^sup>+ t'.\n          emeasure (T t')\n           {x \\<in> space (stream_space (count_space UNIV)).\n            t \\<in> X \\<and> t \\<in> Y \\<and> t' \\<in> Y \\<and> gfp run x}\n        \\<partial>measure_pmf (K t)\n                       \\<partial>measure_pmf (K x)\n    \\<le> \\<integral>\\<^sup>+ t. indicator (X \\<inter> Y) t *\n                                 \\<integral>\\<^sup>+ t'.\n                indicator Y t' * ennreal (r ^ n)\n              \\<partial>measure_pmf (K t)\n                             \\<partial>measure_pmf (K x)", "using Suc"], ["proof (prove)\nusing this:\n  emeasure (T ?x1) {\\<omega> \\<in> space (T ?x1). gfp run \\<omega>}\n  \\<le> ennreal (r ^ n)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ t. \\<integral>\\<^sup>+ t'.\n          emeasure (T t')\n           {x \\<in> space (stream_space (count_space UNIV)).\n            t \\<in> X \\<and> t \\<in> Y \\<and> t' \\<in> Y \\<and> gfp run x}\n        \\<partial>measure_pmf (K t)\n                       \\<partial>measure_pmf (K x)\n    \\<le> \\<integral>\\<^sup>+ t. indicator (X \\<inter> Y) t *\n                                 \\<integral>\\<^sup>+ t'.\n                indicator Y t' * ennreal (r ^ n)\n              \\<partial>measure_pmf (K t)\n                             \\<partial>measure_pmf (K x)", "by (auto intro!: nn_integral_mono split: split_indicator)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ t. \\<integral>\\<^sup>+ t'.\n        emeasure (T t')\n         {x \\<in> space (stream_space (count_space UNIV)).\n          t \\<in> X \\<and> t \\<in> Y \\<and> t' \\<in> Y \\<and> gfp run x}\n      \\<partial>measure_pmf (K t)\n                     \\<partial>measure_pmf (K x)\n  \\<le> \\<integral>\\<^sup>+ t. indicator (X \\<inter> Y) t *\n                               \\<integral>\\<^sup>+ t'.\n              indicator Y t' * ennreal (r ^ n)\n            \\<partial>measure_pmf (K t)\n                           \\<partial>measure_pmf (K x)\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n           \\<le> ennreal (r ^ n)) \\<Longrightarrow>\n       emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n       \\<le> ennreal (r ^ Suc n)", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ t. \\<integral>\\<^sup>+ t'.\n        emeasure (T t')\n         {x \\<in> space (stream_space (count_space UNIV)).\n          t \\<in> X \\<and> t \\<in> Y \\<and> t' \\<in> Y \\<and> gfp run x}\n      \\<partial>measure_pmf (K t)\n                     \\<partial>measure_pmf (K x)\n  \\<le> \\<integral>\\<^sup>+ t. indicator (X \\<inter> Y) t *\n                               \\<integral>\\<^sup>+ t'.\n              indicator Y t' * ennreal (r ^ n)\n            \\<partial>measure_pmf (K t)\n                           \\<partial>measure_pmf (K x)\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n           \\<le> ennreal (r ^ n)) \\<Longrightarrow>\n       emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n       \\<le> ennreal (r ^ Suc n)", "have \"\\<dots> \\<le> (\\<integral>\\<^sup>+ t. indicator (X \\<inter> Y) t * r \\<partial>K x) * ennreal (r^n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ t. indicator (X \\<inter> Y) t *\n                           \\<integral>\\<^sup>+ t'.\n          indicator Y t' * ennreal (r ^ n)\n        \\<partial>measure_pmf (K t)\n                       \\<partial>measure_pmf (K x)\n    \\<le> \\<integral>\\<^sup>+ x. ennreal (indicat_real (X \\<inter> Y) x * r)\n                             \\<partial>measure_pmf (K x) *\n          ennreal (r ^ n)", "by (auto intro!: nn_integral_mono mult_right_mono r ennreal_leI split: split_indicator\n                 simp: nn_integral_multc mult.assoc[symmetric] measure_pmf.emeasure_eq_measure)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ t. indicator (X \\<inter> Y) t *\n                         \\<integral>\\<^sup>+ t'.\n        indicator Y t' * ennreal (r ^ n)\n      \\<partial>measure_pmf (K t)\n                     \\<partial>measure_pmf (K x)\n  \\<le> \\<integral>\\<^sup>+ x. ennreal (indicat_real (X \\<inter> Y) x * r)\n                           \\<partial>measure_pmf (K x) *\n        ennreal (r ^ n)\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n           \\<le> ennreal (r ^ n)) \\<Longrightarrow>\n       emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n       \\<le> ennreal (r ^ Suc n)", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ t. indicator (X \\<inter> Y) t *\n                         \\<integral>\\<^sup>+ t'.\n        indicator Y t' * ennreal (r ^ n)\n      \\<partial>measure_pmf (K t)\n                     \\<partial>measure_pmf (K x)\n  \\<le> \\<integral>\\<^sup>+ x. ennreal (indicat_real (X \\<inter> Y) x * r)\n                           \\<partial>measure_pmf (K x) *\n        ennreal (r ^ n)\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n           \\<le> ennreal (r ^ n)) \\<Longrightarrow>\n       emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n       \\<le> ennreal (r ^ Suc n)", "have \"\\<dots> = emeasure (K x) (X \\<inter> Y) * r^(Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (indicat_real (X \\<inter> Y) x * r)\n                       \\<partial>measure_pmf (K x) *\n    ennreal (r ^ n) =\n    emeasure (measure_pmf (K x)) (X \\<inter> Y) * ennreal (r ^ Suc n)", "by (simp add: ennreal_mult \\<open>0 \\<le> r\\<close> nn_integral_multc ennreal_indicator mult.assoc)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal (indicat_real (X \\<inter> Y) x * r)\n                     \\<partial>measure_pmf (K x) *\n  ennreal (r ^ n) =\n  emeasure (measure_pmf (K x)) (X \\<inter> Y) * ennreal (r ^ Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n           \\<le> ennreal (r ^ n)) \\<Longrightarrow>\n       emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n       \\<le> ennreal (r ^ Suc n)", "finally"], ["proof (chain)\npicking this:\n  \\<integral>\\<^sup>+ t. \\<integral>\\<^sup>+ t'.\n        emeasure (T t')\n         {x \\<in> space (stream_space (count_space UNIV)).\n          t \\<in> X \\<and> t \\<in> Y \\<and> t' \\<in> Y \\<and> gfp run x}\n      \\<partial>measure_pmf (K t)\n                     \\<partial>measure_pmf (K x)\n  \\<le> emeasure (measure_pmf (K x)) (X \\<inter> Y) * ennreal (r ^ Suc n)", "have *: \"(\\<integral>\\<^sup>+ t. \\<integral>\\<^sup>+ t'. emeasure (T t') {x\\<in>space S. t \\<in> X \\<and> t \\<in> Y \\<and> t' \\<in> Y \\<and> gfp run x} \\<partial>K t \\<partial>K x) \\<le>\n        emeasure (K x) (X \\<inter> Y) * r^Suc n\""], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ t. \\<integral>\\<^sup>+ t'.\n        emeasure (T t')\n         {x \\<in> space (stream_space (count_space UNIV)).\n          t \\<in> X \\<and> t \\<in> Y \\<and> t' \\<in> Y \\<and> gfp run x}\n      \\<partial>measure_pmf (K t)\n                     \\<partial>measure_pmf (K x)\n  \\<le> emeasure (measure_pmf (K x)) (X \\<inter> Y) * ennreal (r ^ Suc n)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ t. \\<integral>\\<^sup>+ t'.\n          emeasure (T t')\n           {x \\<in> space (stream_space (count_space UNIV)).\n            t \\<in> X \\<and> t \\<in> Y \\<and> t' \\<in> Y \\<and> gfp run x}\n        \\<partial>measure_pmf (K t)\n                       \\<partial>measure_pmf (K x)\n    \\<le> emeasure (measure_pmf (K x)) (X \\<inter> Y) * ennreal (r ^ Suc n)", "."], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ t. \\<integral>\\<^sup>+ t'.\n        emeasure (T t')\n         {x \\<in> space (stream_space (count_space UNIV)).\n          t \\<in> X \\<and> t \\<in> Y \\<and> t' \\<in> Y \\<and> gfp run x}\n      \\<partial>measure_pmf (K t)\n                     \\<partial>measure_pmf (K x)\n  \\<le> emeasure (measure_pmf (K x)) (X \\<inter> Y) * ennreal (r ^ Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n           \\<le> ennreal (r ^ n)) \\<Longrightarrow>\n       emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n       \\<le> ennreal (r ^ Suc n)", "have \"(\\<integral>\\<^sup>+ t. \\<integral>\\<^sup>+ t'. emeasure (T t') {x \\<in> space S. t \\<in> X \\<and> t \\<in> Y \\<and> t' \\<in> Y \\<and> gfp run x} \\<partial>K t \\<partial>K x) +\n           ennreal (r^Suc n) * emeasure (measure_pmf (K x)) (Y - X) \\<le>\n        emeasure (K x) (X \\<inter> Y) * ennreal (r^Suc n) + ennreal (r^Suc n) * emeasure (measure_pmf (K x)) (Y - X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ t. \\<integral>\\<^sup>+ t'.\n          emeasure (T t')\n           {x \\<in> space (stream_space (count_space UNIV)).\n            t \\<in> X \\<and> t \\<in> Y \\<and> t' \\<in> Y \\<and> gfp run x}\n        \\<partial>measure_pmf (K t)\n                       \\<partial>measure_pmf (K x) +\n    ennreal (r ^ Suc n) * emeasure (measure_pmf (K x)) (Y - X)\n    \\<le> emeasure (measure_pmf (K x)) (X \\<inter> Y) *\n          ennreal (r ^ Suc n) +\n          ennreal (r ^ Suc n) * emeasure (measure_pmf (K x)) (Y - X)", "by (intro add_mono_left *)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ t. \\<integral>\\<^sup>+ t'.\n        emeasure (T t')\n         {x \\<in> space (stream_space (count_space UNIV)).\n          t \\<in> X \\<and> t \\<in> Y \\<and> t' \\<in> Y \\<and> gfp run x}\n      \\<partial>measure_pmf (K t)\n                     \\<partial>measure_pmf (K x) +\n  ennreal (r ^ Suc n) * emeasure (measure_pmf (K x)) (Y - X)\n  \\<le> emeasure (measure_pmf (K x)) (X \\<inter> Y) * ennreal (r ^ Suc n) +\n        ennreal (r ^ Suc n) * emeasure (measure_pmf (K x)) (Y - X)\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n           \\<le> ennreal (r ^ n)) \\<Longrightarrow>\n       emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n       \\<le> ennreal (r ^ Suc n)", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ t. \\<integral>\\<^sup>+ t'.\n        emeasure (T t')\n         {x \\<in> space (stream_space (count_space UNIV)).\n          t \\<in> X \\<and> t \\<in> Y \\<and> t' \\<in> Y \\<and> gfp run x}\n      \\<partial>measure_pmf (K t)\n                     \\<partial>measure_pmf (K x) +\n  ennreal (r ^ Suc n) * emeasure (measure_pmf (K x)) (Y - X)\n  \\<le> emeasure (measure_pmf (K x)) (X \\<inter> Y) * ennreal (r ^ Suc n) +\n        ennreal (r ^ Suc n) * emeasure (measure_pmf (K x)) (Y - X)\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n           \\<le> ennreal (r ^ n)) \\<Longrightarrow>\n       emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n       \\<le> ennreal (r ^ Suc n)", "have \"\\<dots> = emeasure (K x) ((X \\<inter> Y) \\<union> (Y - X)) * ennreal (r^Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (K x)) (X \\<inter> Y) * ennreal (r ^ Suc n) +\n    ennreal (r ^ Suc n) * emeasure (measure_pmf (K x)) (Y - X) =\n    emeasure (measure_pmf (K x)) (X \\<inter> Y \\<union> (Y - X)) *\n    ennreal (r ^ Suc n)", "by (subst plus_emeasure[symmetric]) (auto simp: field_simps)"], ["proof (state)\nthis:\n  emeasure (measure_pmf (K x)) (X \\<inter> Y) * ennreal (r ^ Suc n) +\n  ennreal (r ^ Suc n) * emeasure (measure_pmf (K x)) (Y - X) =\n  emeasure (measure_pmf (K x)) (X \\<inter> Y \\<union> (Y - X)) *\n  ennreal (r ^ Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n           \\<le> ennreal (r ^ n)) \\<Longrightarrow>\n       emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n       \\<le> ennreal (r ^ Suc n)", "also"], ["proof (state)\nthis:\n  emeasure (measure_pmf (K x)) (X \\<inter> Y) * ennreal (r ^ Suc n) +\n  ennreal (r ^ Suc n) * emeasure (measure_pmf (K x)) (Y - X) =\n  emeasure (measure_pmf (K x)) (X \\<inter> Y \\<union> (Y - X)) *\n  ennreal (r ^ Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n           \\<le> ennreal (r ^ n)) \\<Longrightarrow>\n       emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n       \\<le> ennreal (r ^ Suc n)", "have \"\\<dots> \\<le> 1 * ennreal (r^Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (K x)) (X \\<inter> Y \\<union> (Y - X)) *\n    ennreal (r ^ Suc n)\n    \\<le> 1 * ennreal (r ^ Suc n)", "by (intro mult_right_mono measure_pmf.emeasure_le_1) simp"], ["proof (state)\nthis:\n  emeasure (measure_pmf (K x)) (X \\<inter> Y \\<union> (Y - X)) *\n  ennreal (r ^ Suc n)\n  \\<le> 1 * ennreal (r ^ Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n           \\<le> ennreal (r ^ n)) \\<Longrightarrow>\n       emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n       \\<le> ennreal (r ^ Suc n)", "finally"], ["proof (chain)\npicking this:\n  \\<integral>\\<^sup>+ t. \\<integral>\\<^sup>+ t'.\n        emeasure (T t')\n         {x \\<in> space (stream_space (count_space UNIV)).\n          t \\<in> X \\<and> t \\<in> Y \\<and> t' \\<in> Y \\<and> gfp run x}\n      \\<partial>measure_pmf (K t)\n                     \\<partial>measure_pmf (K x) +\n  ennreal (r ^ Suc n) * emeasure (measure_pmf (K x)) (Y - X)\n  \\<le> 1 * ennreal (r ^ Suc n)", "have \"(\\<integral>\\<^sup>+ t. \\<integral>\\<^sup>+ t'. emeasure (T t') {x \\<in> space MC_syntax.S. t \\<in> X \\<and> t \\<in> Y \\<and> t' \\<in> Y \\<and> gfp run x} \\<partial>K t \\<partial>K x) +\n           ennreal (r^Suc n) * emeasure (measure_pmf (K x)) (Y - X) \\<le> 1 * ennreal (r^Suc n)\""], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ t. \\<integral>\\<^sup>+ t'.\n        emeasure (T t')\n         {x \\<in> space (stream_space (count_space UNIV)).\n          t \\<in> X \\<and> t \\<in> Y \\<and> t' \\<in> Y \\<and> gfp run x}\n      \\<partial>measure_pmf (K t)\n                     \\<partial>measure_pmf (K x) +\n  ennreal (r ^ Suc n) * emeasure (measure_pmf (K x)) (Y - X)\n  \\<le> 1 * ennreal (r ^ Suc n)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ t. \\<integral>\\<^sup>+ t'.\n          emeasure (T t')\n           {x \\<in> space (stream_space (count_space UNIV)).\n            t \\<in> X \\<and> t \\<in> Y \\<and> t' \\<in> Y \\<and> gfp run x}\n        \\<partial>measure_pmf (K t)\n                       \\<partial>measure_pmf (K x) +\n    ennreal (r ^ Suc n) * emeasure (measure_pmf (K x)) (Y - X)\n    \\<le> 1 * ennreal (r ^ Suc n)", "by simp"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ t. \\<integral>\\<^sup>+ t'.\n        emeasure (T t')\n         {x \\<in> space (stream_space (count_space UNIV)).\n          t \\<in> X \\<and> t \\<in> Y \\<and> t' \\<in> Y \\<and> gfp run x}\n      \\<partial>measure_pmf (K t)\n                     \\<partial>measure_pmf (K x) +\n  ennreal (r ^ Suc n) * emeasure (measure_pmf (K x)) (Y - X)\n  \\<le> 1 * ennreal (r ^ Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n           \\<le> ennreal (r ^ n)) \\<Longrightarrow>\n       emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n       \\<le> ennreal (r ^ Suc n)", "}"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ t. \\<integral>\\<^sup>+ t'.\n        emeasure (T t')\n         {x \\<in> space (stream_space (count_space UNIV)).\n          t \\<in> X \\<and> t \\<in> Y \\<and> t' \\<in> Y \\<and> gfp run x}\n      \\<partial>measure_pmf (K t)\n                     \\<partial>measure_pmf (K ?xb3) +\n  ennreal (r ^ Suc n) * emeasure (measure_pmf (K ?xb3)) (Y - X)\n  \\<le> 1 * ennreal (r ^ Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n           \\<le> ennreal (r ^ n)) \\<Longrightarrow>\n       emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n       \\<le> ennreal (r ^ Suc n)", "note * = this"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ t. \\<integral>\\<^sup>+ t'.\n        emeasure (T t')\n         {x \\<in> space (stream_space (count_space UNIV)).\n          t \\<in> X \\<and> t \\<in> Y \\<and> t' \\<in> Y \\<and> gfp run x}\n      \\<partial>measure_pmf (K t)\n                     \\<partial>measure_pmf (K ?xb3) +\n  ennreal (r ^ Suc n) * emeasure (measure_pmf (K ?xb3)) (Y - X)\n  \\<le> 1 * ennreal (r ^ Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n           \\<le> ennreal (r ^ n)) \\<Longrightarrow>\n       emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n       \\<le> ennreal (r ^ Suc n)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n    \\<le> ennreal (r ^ Suc n)", "apply (subst gfp_unfold[OF inf_continuous_mono[OF cont_run]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (T x) {\\<omega> \\<in> space (T x). run (gfp run) \\<omega>}\n    \\<le> ennreal (r ^ Suc n)", "apply (subst run_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (T x)\n     {\\<omega> \\<in> space (T x).\n      (HLD (Y - X) suntil\n       (\\<lambda>xs.\n           HLD (X \\<inter> Y) xs \\<and>\n           nxt (\\<lambda>xs. HLD Y xs \\<and> nxt (gfp run) xs) xs))\n       \\<omega>}\n    \\<le> ennreal (r ^ Suc n)", "apply (subst emeasure_suntil_disj)"], ["proof (prove)\ngoal (3 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>xs.\n         HLD (X \\<inter> Y) xs \\<and>\n         nxt (\\<lambda>xs. HLD Y xs \\<and> nxt (gfp run) xs) xs)\n 2. \\<And>t.\n       AE \\<omega> in T t. \\<not> ((\\<lambda>xs.\n HLD (X \\<inter> Y) xs \\<and>\n nxt (\\<lambda>xs. HLD Y xs \\<and> nxt (gfp run) xs) xs) \\<sqinter>\n                                   (HLD (Y - X) \\<sqinter>\n                                    nxt (HLD (Y - X) suntil\n   (\\<lambda>xs.\n       HLD (X \\<inter> Y) xs \\<and>\n       nxt (\\<lambda>xs. HLD Y xs \\<and> nxt (gfp run) xs) xs))))\n                                   \\<omega>\n 3. lfp (\\<lambda>F s.\n            emeasure (T s)\n             {\\<omega> \\<in> space (T s).\n              HLD (X \\<inter> Y) \\<omega> \\<and>\n              nxt (\\<lambda>xs. HLD Y xs \\<and> nxt (gfp run) xs)\n               \\<omega>} +\n            set_nn_integral (measure_pmf (K s)) (Y - X) F)\n     x\n    \\<le> ennreal (r ^ Suc n)", "apply measurable []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t.\n       AE \\<omega> in T t. \\<not> ((\\<lambda>xs.\n HLD (X \\<inter> Y) xs \\<and>\n nxt (\\<lambda>xs. HLD Y xs \\<and> nxt (gfp run) xs) xs) \\<sqinter>\n                                   (HLD (Y - X) \\<sqinter>\n                                    nxt (HLD (Y - X) suntil\n   (\\<lambda>xs.\n       HLD (X \\<inter> Y) xs \\<and>\n       nxt (\\<lambda>xs. HLD Y xs \\<and> nxt (gfp run) xs) xs))))\n                                   \\<omega>\n 2. lfp (\\<lambda>F s.\n            emeasure (T s)\n             {\\<omega> \\<in> space (T s).\n              HLD (X \\<inter> Y) \\<omega> \\<and>\n              nxt (\\<lambda>xs. HLD Y xs \\<and> nxt (gfp run) xs)\n               \\<omega>} +\n            set_nn_integral (measure_pmf (K s)) (Y - X) F)\n     x\n    \\<le> ennreal (r ^ Suc n)", "subgoal for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE \\<omega> in T s. \\<not> ((\\<lambda>xs.\n                                    HLD (X \\<inter> Y) xs \\<and>\n                                    nxt (\\<lambda>xs.\n      HLD Y xs \\<and> nxt (gfp run) xs)\n                                     xs) \\<sqinter>\n                                (HLD (Y - X) \\<sqinter>\n                                 nxt (HLD (Y - X) suntil\n(\\<lambda>xs.\n    HLD (X \\<inter> Y) xs \\<and>\n    nxt (\\<lambda>xs. HLD Y xs \\<and> nxt (gfp run) xs) xs))))\n                                \\<omega>", "by (rule AE_I2) (auto simp: HLD_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp (\\<lambda>F s.\n            emeasure (T s)\n             {\\<omega> \\<in> space (T s).\n              HLD (X \\<inter> Y) \\<omega> \\<and>\n              nxt (\\<lambda>xs. HLD Y xs \\<and> nxt (gfp run) xs)\n               \\<omega>} +\n            set_nn_integral (measure_pmf (K s)) (Y - X) F)\n     x\n    \\<le> ennreal (r ^ Suc n)", "apply (rule le_funD[of _ _ x])"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp (\\<lambda>F s.\n            emeasure (T s)\n             {\\<omega> \\<in> space (T s).\n              HLD (X \\<inter> Y) \\<omega> \\<and>\n              nxt (\\<lambda>xs. HLD Y xs \\<and> nxt (gfp run) xs)\n               \\<omega>} +\n            set_nn_integral (measure_pmf (K s)) (Y - X) F)\n    \\<le> (\\<lambda>a. ennreal (r ^ Suc n))", "apply (rule lfp_lowerbound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s.\n        emeasure (T s)\n         {\\<omega> \\<in> space (T s).\n          HLD (X \\<inter> Y) \\<omega> \\<and>\n          nxt (\\<lambda>xs. HLD Y xs \\<and> nxt (gfp run) xs) \\<omega>} +\n        (\\<integral>\\<^sup>+t\\<in>Y - X. ennreal (r ^ Suc n)\n         \\<partial>measure_pmf (K s)))\n    \\<le> (\\<lambda>a. ennreal (r ^ Suc n))", "apply (rule le_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       emeasure (T x)\n        {\\<omega> \\<in> space (T x).\n         HLD (X \\<inter> Y) \\<omega> \\<and>\n         nxt (\\<lambda>xs. HLD Y xs \\<and> nxt (gfp run) xs) \\<omega>} +\n       (\\<integral>\\<^sup>+t\\<in>Y - X. ennreal (r ^ Suc n)\n        \\<partial>measure_pmf (K x))\n       \\<le> ennreal (r ^ Suc n)", "apply (subst emeasure_Collect_T)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       Measurable.pred (stream_space (count_space UNIV))\n        (\\<lambda>\\<omega>.\n            HLD (X \\<inter> Y) \\<omega> \\<and>\n            nxt (\\<lambda>xs. HLD Y xs \\<and> nxt (gfp run) xs) \\<omega>)\n 2. \\<And>x.\n       \\<integral>\\<^sup>+ t. emeasure (T t)\n                               {x \\<in> space (T t).\n                                HLD (X \\<inter> Y) (t ## x) \\<and>\n                                nxt (\\<lambda>xs.\n  HLD Y xs \\<and> nxt (gfp run) xs)\n                                 (t ## x)}\n                          \\<partial>measure_pmf (K x) +\n       (\\<integral>\\<^sup>+t\\<in>Y - X. ennreal (r ^ Suc n)\n        \\<partial>measure_pmf (K x))\n       \\<le> ennreal (r ^ Suc n)", "apply measurable []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<integral>\\<^sup>+ t. emeasure (T t)\n                               {x \\<in> space (T t).\n                                HLD (X \\<inter> Y) (t ## x) \\<and>\n                                nxt (\\<lambda>xs.\n  HLD Y xs \\<and> nxt (gfp run) xs)\n                                 (t ## x)}\n                          \\<partial>measure_pmf (K x) +\n       (\\<integral>\\<^sup>+t\\<in>Y - X. ennreal (r ^ Suc n)\n        \\<partial>measure_pmf (K x))\n       \\<le> ennreal (r ^ Suc n)", "apply (subst emeasure_Collect_T)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x t.\n       Measurable.pred (stream_space (count_space UNIV))\n        (\\<lambda>x.\n            HLD (X \\<inter> Y) (t ## x) \\<and>\n            nxt (\\<lambda>xs. HLD Y xs \\<and> nxt (gfp run) xs) (t ## x))\n 2. \\<And>x.\n       \\<integral>\\<^sup>+ t. \\<integral>\\<^sup>+ ta.\n             emeasure (T ta)\n              {x \\<in> space (T ta).\n               HLD (X \\<inter> Y) (t ## ta ## x) \\<and>\n               nxt (\\<lambda>xs. HLD Y xs \\<and> nxt (gfp run) xs)\n                (t ## ta ## x)}\n           \\<partial>measure_pmf (K t)\n                          \\<partial>measure_pmf (K x) +\n       (\\<integral>\\<^sup>+t\\<in>Y - X. ennreal (r ^ Suc n)\n        \\<partial>measure_pmf (K x))\n       \\<le> ennreal (r ^ Suc n)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<integral>\\<^sup>+ t. \\<integral>\\<^sup>+ ta.\n             emeasure (T ta)\n              {x \\<in> space (T ta).\n               HLD (X \\<inter> Y) (t ## ta ## x) \\<and>\n               nxt (\\<lambda>xs. HLD Y xs \\<and> nxt (gfp run) xs)\n                (t ## ta ## x)}\n           \\<partial>measure_pmf (K t)\n                          \\<partial>measure_pmf (K x) +\n       (\\<integral>\\<^sup>+t\\<in>Y - X. ennreal (r ^ Suc n)\n        \\<partial>measure_pmf (K x))\n       \\<le> ennreal (r ^ Suc n)", "apply (simp add: nn_integral_cmult)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<integral>\\<^sup>+ t. \\<integral>\\<^sup>+ ta.\n             emeasure (T ta)\n              {x \\<in> space (stream_space (count_space UNIV)).\n               t \\<in> X \\<and>\n               t \\<in> Y \\<and> ta \\<in> Y \\<and> gfp run x}\n           \\<partial>measure_pmf (K t)\n                          \\<partial>measure_pmf (K x) +\n       ennreal (r * r ^ n) * emeasure (measure_pmf (K x)) (Y - X)\n       \\<le> ennreal (r * r ^ n)", "using *"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ t. \\<integral>\\<^sup>+ t'.\n        emeasure (T t')\n         {x \\<in> space (stream_space (count_space UNIV)).\n          t \\<in> X \\<and> t \\<in> Y \\<and> t' \\<in> Y \\<and> gfp run x}\n      \\<partial>measure_pmf (K t)\n                     \\<partial>measure_pmf (K ?xb3) +\n  ennreal (r ^ Suc n) * emeasure (measure_pmf (K ?xb3)) (Y - X)\n  \\<le> 1 * ennreal (r ^ Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<integral>\\<^sup>+ t. \\<integral>\\<^sup>+ ta.\n             emeasure (T ta)\n              {x \\<in> space (stream_space (count_space UNIV)).\n               t \\<in> X \\<and>\n               t \\<in> Y \\<and> ta \\<in> Y \\<and> gfp run x}\n           \\<partial>measure_pmf (K t)\n                          \\<partial>measure_pmf (K x) +\n       ennreal (r * r ^ n) * emeasure (measure_pmf (K x)) (Y - X)\n       \\<le> ennreal (r * r ^ n)", "by simp"], ["proof (state)\nthis:\n  emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n  \\<le> ennreal (r ^ Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  emeasure (T x) {\\<omega> \\<in> space (T x). gfp run \\<omega>}\n  \\<le> ennreal (r ^ ?n1)\n\ngoal (1 subgoal):\n 1. almost_everywhere (T x) (ev (HLD (- Y)))", "finally"], ["proof (chain)\npicking this:\n  emeasure (T x) {\\<omega> \\<in> space (T x). alw (HLD Y) \\<omega>}\n  \\<le> ennreal (r ^ ?n2)", "have \"emeasure (T x) {\\<omega> \\<in> space (T x). alw (HLD Y) \\<omega>} \\<le> r^n\" for n"], ["proof (prove)\nusing this:\n  emeasure (T x) {\\<omega> \\<in> space (T x). alw (HLD Y) \\<omega>}\n  \\<le> ennreal (r ^ ?n2)\n\ngoal (1 subgoal):\n 1. emeasure (T x) {\\<omega> \\<in> space (T x). alw (HLD Y) \\<omega>}\n    \\<le> ennreal (r ^ n)", "."], ["proof (state)\nthis:\n  emeasure (T x) {\\<omega> \\<in> space (T x). alw (HLD Y) \\<omega>}\n  \\<le> ennreal (r ^ ?n1)\n\ngoal (1 subgoal):\n 1. almost_everywhere (T x) (ev (HLD (- Y)))", "then"], ["proof (chain)\npicking this:\n  emeasure (T x) {\\<omega> \\<in> space (T x). alw (HLD Y) \\<omega>}\n  \\<le> ennreal (r ^ ?n1)", "have \"emeasure (T x) {\\<omega> \\<in> space (T x). alw (HLD Y) \\<omega>} \\<le> ennreal 0\""], ["proof (prove)\nusing this:\n  emeasure (T x) {\\<omega> \\<in> space (T x). alw (HLD Y) \\<omega>}\n  \\<le> ennreal (r ^ ?n1)\n\ngoal (1 subgoal):\n 1. emeasure (T x) {\\<omega> \\<in> space (T x). alw (HLD Y) \\<omega>}\n    \\<le> ennreal 0", "using \\<open>0 \\<le> r\\<close> \\<open>r < 1\\<close>"], ["proof (prove)\nusing this:\n  emeasure (T x) {\\<omega> \\<in> space (T x). alw (HLD Y) \\<omega>}\n  \\<le> ennreal (r ^ ?n1)\n  0 \\<le> r\n  r < 1\n\ngoal (1 subgoal):\n 1. emeasure (T x) {\\<omega> \\<in> space (T x). alw (HLD Y) \\<omega>}\n    \\<le> ennreal 0", "by (intro LIMSEQ_le_const[OF tendsto_ennrealI[OF LIMSEQ_power_zero[of r]]]) auto"], ["proof (state)\nthis:\n  emeasure (T x) {\\<omega> \\<in> space (T x). alw (HLD Y) \\<omega>}\n  \\<le> ennreal 0\n\ngoal (1 subgoal):\n 1. almost_everywhere (T x) (ev (HLD (- Y)))", "then"], ["proof (chain)\npicking this:\n  emeasure (T x) {\\<omega> \\<in> space (T x). alw (HLD Y) \\<omega>}\n  \\<le> ennreal 0", "have *: \"emeasure (T x) {\\<omega> \\<in> space (T x). alw (HLD Y) \\<omega>} = 0\""], ["proof (prove)\nusing this:\n  emeasure (T x) {\\<omega> \\<in> space (T x). alw (HLD Y) \\<omega>}\n  \\<le> ennreal 0\n\ngoal (1 subgoal):\n 1. emeasure (T x) {\\<omega> \\<in> space (T x). alw (HLD Y) \\<omega>} = 0", "by simp"], ["proof (state)\nthis:\n  emeasure (T x) {\\<omega> \\<in> space (T x). alw (HLD Y) \\<omega>} = 0\n\ngoal (1 subgoal):\n 1. almost_everywhere (T x) (ev (HLD (- Y)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_everywhere (T x) (ev (HLD (- Y)))", "by (rule AE_I[OF _ *]) (auto simp: not_ev_iff not_HLD[symmetric])"], ["proof (state)\nthis:\n  almost_everywhere (T x) (ev (HLD (- Y)))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context Markov_Decision_Process\nbegin"], ["", "lemma cfg_on_inv:\n  \"pred_stream (\\<lambda> cfg. cfg \\<in> cfg_on (state cfg)) \\<omega>\" if\n  \"MC.enabled cfg \\<omega>\" \"cfg \\<in> cfg_on s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>cfg. cfg \\<in> cfg_on (state cfg)) \\<omega>", "using that"], ["proof (prove)\nusing this:\n  MC.enabled cfg \\<omega>\n  cfg \\<in> cfg_on s\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>cfg. cfg \\<in> cfg_on (state cfg)) \\<omega>", "proof (coinduction arbitrary: \\<omega> cfg s)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a w \\<omega> cfg s.\n       \\<lbrakk>a ## w = \\<omega>; MC.enabled cfg \\<omega>;\n        cfg \\<in> cfg_on s\\<rbrakk>\n       \\<Longrightarrow> a \\<in> cfg_on (state a) \\<and>\n                         (\\<exists>\\<omega> cfg s.\n                             w = \\<omega> \\<and>\n                             MC.enabled cfg \\<omega> \\<and>\n                             cfg \\<in> cfg_on s)", "case prems: stream_pred"], ["proof (state)\nthis:\n  a ## w = \\<omega>\n  MC.enabled cfg \\<omega>\n  cfg \\<in> cfg_on s\n\ngoal (1 subgoal):\n 1. \\<And>a w \\<omega> cfg s.\n       \\<lbrakk>a ## w = \\<omega>; MC.enabled cfg \\<omega>;\n        cfg \\<in> cfg_on s\\<rbrakk>\n       \\<Longrightarrow> a \\<in> cfg_on (state a) \\<and>\n                         (\\<exists>\\<omega> cfg s.\n                             w = \\<omega> \\<and>\n                             MC.enabled cfg \\<omega> \\<and>\n                             cfg \\<in> cfg_on s)", "note [simp] = \\<open>_ = \\<omega>\\<close>[symmetric]"], ["proof (state)\nthis:\n  \\<omega> = a ## w\n\ngoal (1 subgoal):\n 1. \\<And>a w \\<omega> cfg s.\n       \\<lbrakk>a ## w = \\<omega>; MC.enabled cfg \\<omega>;\n        cfg \\<in> cfg_on s\\<rbrakk>\n       \\<Longrightarrow> a \\<in> cfg_on (state a) \\<and>\n                         (\\<exists>\\<omega> cfg s.\n                             w = \\<omega> \\<and>\n                             MC.enabled cfg \\<omega> \\<and>\n                             cfg \\<in> cfg_on s)", "from prems(2)"], ["proof (chain)\npicking this:\n  MC.enabled cfg \\<omega>", "have \"a \\<in> set_pmf (K_cfg cfg)\" \"MC.enabled a w\""], ["proof (prove)\nusing this:\n  MC.enabled cfg \\<omega>\n\ngoal (1 subgoal):\n 1. a \\<in> set_pmf (K_cfg cfg) &&& MC.enabled a w", "by (auto simp: MC.enabled_Stream)"], ["proof (state)\nthis:\n  a \\<in> set_pmf (K_cfg cfg)\n  MC.enabled a w\n\ngoal (1 subgoal):\n 1. \\<And>a w \\<omega> cfg s.\n       \\<lbrakk>a ## w = \\<omega>; MC.enabled cfg \\<omega>;\n        cfg \\<in> cfg_on s\\<rbrakk>\n       \\<Longrightarrow> a \\<in> cfg_on (state a) \\<and>\n                         (\\<exists>\\<omega> cfg s.\n                             w = \\<omega> \\<and>\n                             MC.enabled cfg \\<omega> \\<and>\n                             cfg \\<in> cfg_on s)", "moreover"], ["proof (state)\nthis:\n  a \\<in> set_pmf (K_cfg cfg)\n  MC.enabled a w\n\ngoal (1 subgoal):\n 1. \\<And>a w \\<omega> cfg s.\n       \\<lbrakk>a ## w = \\<omega>; MC.enabled cfg \\<omega>;\n        cfg \\<in> cfg_on s\\<rbrakk>\n       \\<Longrightarrow> a \\<in> cfg_on (state a) \\<and>\n                         (\\<exists>\\<omega> cfg s.\n                             w = \\<omega> \\<and>\n                             MC.enabled cfg \\<omega> \\<and>\n                             cfg \\<in> cfg_on s)", "from \\<open>a \\<in> _\\<close>"], ["proof (chain)\npicking this:\n  a \\<in> set_pmf (K_cfg cfg)", "have \"a \\<in> cont cfg ` set_pmf (action cfg)\""], ["proof (prove)\nusing this:\n  a \\<in> set_pmf (K_cfg cfg)\n\ngoal (1 subgoal):\n 1. a \\<in> cont cfg ` set_pmf (action cfg)", "by (simp add: set_K_cfg)"], ["proof (state)\nthis:\n  a \\<in> cont cfg ` set_pmf (action cfg)\n\ngoal (1 subgoal):\n 1. \\<And>a w \\<omega> cfg s.\n       \\<lbrakk>a ## w = \\<omega>; MC.enabled cfg \\<omega>;\n        cfg \\<in> cfg_on s\\<rbrakk>\n       \\<Longrightarrow> a \\<in> cfg_on (state a) \\<and>\n                         (\\<exists>\\<omega> cfg s.\n                             w = \\<omega> \\<and>\n                             MC.enabled cfg \\<omega> \\<and>\n                             cfg \\<in> cfg_on s)", "ultimately"], ["proof (chain)\npicking this:\n  a \\<in> set_pmf (K_cfg cfg)\n  MC.enabled a w\n  a \\<in> cont cfg ` set_pmf (action cfg)", "show ?case"], ["proof (prove)\nusing this:\n  a \\<in> set_pmf (K_cfg cfg)\n  MC.enabled a w\n  a \\<in> cont cfg ` set_pmf (action cfg)\n\ngoal (1 subgoal):\n 1. a \\<in> cfg_on (state a) \\<and>\n    (\\<exists>\\<omega> cfg s.\n        w = \\<omega> \\<and>\n        MC.enabled cfg \\<omega> \\<and> cfg \\<in> cfg_on s)", "using \\<open>cfg \\<in> _\\<close>"], ["proof (prove)\nusing this:\n  a \\<in> set_pmf (K_cfg cfg)\n  MC.enabled a w\n  a \\<in> cont cfg ` set_pmf (action cfg)\n  cfg \\<in> cfg_on s\n\ngoal (1 subgoal):\n 1. a \\<in> cfg_on (state a) \\<and>\n    (\\<exists>\\<omega> cfg s.\n        w = \\<omega> \\<and>\n        MC.enabled cfg \\<omega> \\<and> cfg \\<in> cfg_on s)", "by auto"], ["proof (state)\nthis:\n  a \\<in> cfg_on (state a) \\<and>\n  (\\<exists>\\<omega> cfg s.\n      w = \\<omega> \\<and> MC.enabled cfg \\<omega> \\<and> cfg \\<in> cfg_on s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma MC_T_not_sconst_strong:\n  assumes\n    \"\\<forall> l. \\<forall> cfg \\<in> (\\<Union> x \\<in> f -` {u}. cfg_on x) \\<inter> Y \\<inter> X. measure_pmf (action cfg) (f -` {u}) \\<le> r\"\n    \"r < 1\" \"cfg \\<in> cfg_on x\"\n    \"AE \\<omega> in MC.T cfg. pred_stream (\\<lambda> x. x \\<in> X) \\<omega>\"\n    \"AE \\<omega> in MC.T cfg. alw (\\<lambda> \\<omega>. HLD (f -` {u}) (smap state \\<omega>) \\<longrightarrow> ev (HLD Y) \\<omega>) \\<omega>\"\n  shows \"AE \\<omega> in MC.T cfg. smap (f o state) \\<omega> \\<noteq> sconst u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE \\<omega> in MC.T\n                    cfg. smap (f \\<circ> state) \\<omega> \\<noteq> sconst u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. AE \\<omega> in MC.T\n                    cfg. smap (f \\<circ> state) \\<omega> \\<noteq> sconst u", "let ?U = \"f -` {u}\""], ["proof (state)\ngoal (1 subgoal):\n 1. AE \\<omega> in MC.T\n                    cfg. smap (f \\<circ> state) \\<omega> \\<noteq> sconst u", "let ?S = \"(\\<Union> x \\<in> f -` {u}. cfg_on x) \\<inter> X\""], ["proof (state)\ngoal (1 subgoal):\n 1. AE \\<omega> in MC.T\n                    cfg. smap (f \\<circ> state) \\<omega> \\<noteq> sconst u", "let ?T = \"Y \\<inter> ((\\<Union> x \\<in> f -` {u}. cfg_on x) \\<inter> X)\""], ["proof (state)\ngoal (1 subgoal):\n 1. AE \\<omega> in MC.T\n                    cfg. smap (f \\<circ> state) \\<omega> \\<noteq> sconst u", "have *: \"emeasure (K_cfg cfg) ?S \\<le> r\" if \"cfg \\<in> ?T\" for cfg"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (K_cfg cfg))\n     (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n    \\<le> r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (K_cfg cfg))\n     (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n    \\<le> r", "have \"emeasure (K_cfg cfg) ?S \\<le> emeasure (measure_pmf (action cfg)) ?U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (K_cfg cfg))\n     (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n    \\<le> emeasure (measure_pmf (action cfg)) (f -` {u})", "unfolding K_cfg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (map_pmf (cont cfg) (action cfg)))\n     (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n    \\<le> emeasure (measure_pmf (action cfg)) (f -` {u})", "by (auto dest: cfg_onD_state intro!: emeasure_mono)"], ["proof (state)\nthis:\n  emeasure (measure_pmf (K_cfg cfg))\n   (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n  \\<le> emeasure (measure_pmf (action cfg)) (f -` {u})\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (K_cfg cfg))\n     (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n    \\<le> r", "also"], ["proof (state)\nthis:\n  emeasure (measure_pmf (K_cfg cfg))\n   (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n  \\<le> emeasure (measure_pmf (action cfg)) (f -` {u})\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (K_cfg cfg))\n     (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n    \\<le> r", "from assms(1) \\<open>cfg \\<in> ?T\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>l.\n     \\<forall>cfg\\<in>\\<Union> (cfg_on ` f -` {u}) \\<inter> Y \\<inter> X.\n        emeasure (measure_pmf (action cfg)) (f -` {u}) \\<le> r\n  cfg \\<in> Y \\<inter> (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)", "have \"\\<dots> \\<le> r\""], ["proof (prove)\nusing this:\n  \\<forall>l.\n     \\<forall>cfg\\<in>\\<Union> (cfg_on ` f -` {u}) \\<inter> Y \\<inter> X.\n        emeasure (measure_pmf (action cfg)) (f -` {u}) \\<le> r\n  cfg \\<in> Y \\<inter> (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (action cfg)) (f -` {u}) \\<le> r", "by auto"], ["proof (state)\nthis:\n  emeasure (measure_pmf (action cfg)) (f -` {u}) \\<le> r\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (K_cfg cfg))\n     (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n    \\<le> r", "finally"], ["proof (chain)\npicking this:\n  emeasure (measure_pmf (K_cfg cfg))\n   (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n  \\<le> r", "show ?thesis"], ["proof (prove)\nusing this:\n  emeasure (measure_pmf (K_cfg cfg))\n   (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n  \\<le> r\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (K_cfg cfg))\n     (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n    \\<le> r", "."], ["proof (state)\nthis:\n  emeasure (measure_pmf (K_cfg cfg))\n   (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n  \\<le> r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?cfg1\n  \\<in> Y \\<inter>\n        (\\<Union> (cfg_on ` f -` {u}) \\<inter> X) \\<Longrightarrow>\n  emeasure (measure_pmf (K_cfg ?cfg1))\n   (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n  \\<le> r\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MC.T\n                    cfg. smap (f \\<circ> state) \\<omega> \\<noteq> sconst u", "have \"AE \\<omega> in MC.T cfg. ev (HLD (- ?S)) \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_everywhere (MC.T cfg)\n     (ev (HLD (- (\\<Union> (cfg_on ` f -` {u}) \\<inter> X))))", "apply (rule MC.AE_T_ev_HLD_infinite_strong'[where r = \"enn2real r\" and ?X = Y])"], ["proof (prove)\ngoal (4 subgoals):\n 1. 0 \\<le> enn2real r\n 2. enn2real r < 1\n 3. \\<And>x.\n       x \\<in> Y \\<inter>\n               (\\<Union> (cfg_on ` f -` {u}) \\<inter> X) \\<Longrightarrow>\n       measure_pmf.prob (K_cfg x) (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n       \\<le> enn2real r\n 4. almost_everywhere (MC.T cfg)\n     (alw (\\<lambda>\\<omega>.\n              HLD (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n               \\<omega> \\<longrightarrow>\n              ev (HLD Y) \\<omega>))", "apply (simp; fail)"], ["proof (prove)\ngoal (3 subgoals):\n 1. enn2real r < 1\n 2. \\<And>x.\n       x \\<in> Y \\<inter>\n               (\\<Union> (cfg_on ` f -` {u}) \\<inter> X) \\<Longrightarrow>\n       measure_pmf.prob (K_cfg x) (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n       \\<le> enn2real r\n 3. almost_everywhere (MC.T cfg)\n     (alw (\\<lambda>\\<omega>.\n              HLD (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n               \\<omega> \\<longrightarrow>\n              ev (HLD Y) \\<omega>))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. enn2real r < 1", "using \\<open>r < 1\\<close>"], ["proof (prove)\nusing this:\n  r < 1\n\ngoal (1 subgoal):\n 1. enn2real r < 1", "by (metis ennreal_enn2real_if ennreal_less_one_iff zero_less_one)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Y \\<inter>\n               (\\<Union> (cfg_on ` f -` {u}) \\<inter> X) \\<Longrightarrow>\n       measure_pmf.prob (K_cfg x) (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n       \\<le> enn2real r\n 2. almost_everywhere (MC.T cfg)\n     (alw (\\<lambda>\\<omega>.\n              HLD (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n               \\<omega> \\<longrightarrow>\n              ev (HLD Y) \\<omega>))", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Y \\<inter>\n            (\\<Union> (cfg_on ` f -` {u}) \\<inter> X) \\<Longrightarrow>\n    measure_pmf.prob (K_cfg x) (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n    \\<le> enn2real r", "by (drule *)\n        (metis Sigma_Algebra.measure_def assms(2) enn2real_mono ennreal_one_less_top less_trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_everywhere (MC.T cfg)\n     (alw (\\<lambda>\\<omega>.\n              HLD (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n               \\<omega> \\<longrightarrow>\n              ev (HLD Y) \\<omega>))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_everywhere (MC.T cfg)\n     (alw (\\<lambda>\\<omega>.\n              HLD (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n               \\<omega> \\<longrightarrow>\n              ev (HLD Y) \\<omega>))", "using assms(5)"], ["proof (prove)\nusing this:\n  almost_everywhere (MC.T cfg)\n   (alw (\\<lambda>\\<omega>.\n            HLD (f -` {u}) (smap state \\<omega>) \\<longrightarrow>\n            ev (HLD Y) \\<omega>))\n\ngoal (1 subgoal):\n 1. almost_everywhere (MC.T cfg)\n     (alw (\\<lambda>\\<omega>.\n              HLD (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n               \\<omega> \\<longrightarrow>\n              ev (HLD Y) \\<omega>))", "by (rule AE_mp) (rule AE_I2, intro impI, auto simp: HLD_iff elim: alw_mono)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  almost_everywhere (MC.T cfg)\n   (ev (HLD (- (\\<Union> (cfg_on ` f -` {u}) \\<inter> X))))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MC.T\n                    cfg. smap (f \\<circ> state) \\<omega> \\<noteq> sconst u", "then"], ["proof (chain)\npicking this:\n  almost_everywhere (MC.T cfg)\n   (ev (HLD (- (\\<Union> (cfg_on ` f -` {u}) \\<inter> X))))", "show ?thesis"], ["proof (prove)\nusing this:\n  almost_everywhere (MC.T cfg)\n   (ev (HLD (- (\\<Union> (cfg_on ` f -` {u}) \\<inter> X))))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MC.T\n                    cfg. smap (f \\<circ> state) \\<omega> \\<noteq> sconst u", "apply (rule AE_mp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE \\<omega> in MC.T\n                    cfg. ev (HLD (- (\\<Union> (cfg_on ` f -` {u}) \\<inter>\n                                     X)))\n                          \\<omega> \\<longrightarrow>\n                         smap (f \\<circ> state) \\<omega> \\<noteq> sconst u", "proof (rule AE_mp[OF assms(4)], rule AE_mp[OF MC.AE_T_enabled], rule AE_I2, safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>\\<omega> \\<in> space (MC.T cfg); MC.enabled cfg \\<omega>;\n        pred_stream (\\<lambda>\\<omega>. \\<omega> \\<in> X) \\<omega>;\n        ev (HLD (- (\\<Union> (cfg_on ` f -` {u}) \\<inter> X))) \\<omega>;\n        smap (f \\<circ> state) \\<omega> = sconst u\\<rbrakk>\n       \\<Longrightarrow> False", "fix \\<omega>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>\\<omega> \\<in> space (MC.T cfg); MC.enabled cfg \\<omega>;\n        pred_stream (\\<lambda>\\<omega>. \\<omega> \\<in> X) \\<omega>;\n        ev (HLD (- (\\<Union> (cfg_on ` f -` {u}) \\<inter> X))) \\<omega>;\n        smap (f \\<circ> state) \\<omega> = sconst u\\<rbrakk>\n       \\<Longrightarrow> False", "assume\n      \"\\<omega> \\<in> space (MC.T cfg)\" \"pred_stream (\\<lambda>\\<omega>. \\<omega> \\<in> X) \\<omega>\"\n      \"MC.enabled cfg \\<omega>\" \"ev (HLD (- ?S)) \\<omega>\" \"smap (f \\<circ> state) \\<omega> = sconst u\""], ["proof (state)\nthis:\n  \\<omega> \\<in> space (MC.T cfg)\n  pred_stream (\\<lambda>\\<omega>. \\<omega> \\<in> X) \\<omega>\n  MC.enabled cfg \\<omega>\n  ev (HLD (- (\\<Union> (cfg_on ` f -` {u}) \\<inter> X))) \\<omega>\n  smap (f \\<circ> state) \\<omega> = sconst u\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>\\<omega> \\<in> space (MC.T cfg); MC.enabled cfg \\<omega>;\n        pred_stream (\\<lambda>\\<omega>. \\<omega> \\<in> X) \\<omega>;\n        ev (HLD (- (\\<Union> (cfg_on ` f -` {u}) \\<inter> X))) \\<omega>;\n        smap (f \\<circ> state) \\<omega> = sconst u\\<rbrakk>\n       \\<Longrightarrow> False", "from this(2,3) \\<open>cfg \\<in> _\\<close>"], ["proof (chain)\npicking this:\n  pred_stream (\\<lambda>\\<omega>. \\<omega> \\<in> X) \\<omega>\n  MC.enabled cfg \\<omega>\n  cfg \\<in> cfg_on x", "have \"pred_stream (\\<lambda> x. x \\<in> cfg_on (state x)) \\<omega>\""], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>\\<omega>. \\<omega> \\<in> X) \\<omega>\n  MC.enabled cfg \\<omega>\n  cfg \\<in> cfg_on x\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>x. x \\<in> cfg_on (state x)) \\<omega>", "by (auto dest: cfg_onD_state intro!: cfg_on_inv)"], ["proof (state)\nthis:\n  pred_stream (\\<lambda>x. x \\<in> cfg_on (state x)) \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>\\<omega> \\<in> space (MC.T cfg); MC.enabled cfg \\<omega>;\n        pred_stream (\\<lambda>\\<omega>. \\<omega> \\<in> X) \\<omega>;\n        ev (HLD (- (\\<Union> (cfg_on ` f -` {u}) \\<inter> X))) \\<omega>;\n        smap (f \\<circ> state) \\<omega> = sconst u\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>smap _ \\<omega> = _\\<close>"], ["proof (chain)\npicking this:\n  smap (f \\<circ> state) \\<omega> = sconst u", "have \"pred_stream (\\<lambda> y. y \\<in> (\\<Union> x \\<in> ?U. cfg_on x)) \\<omega>\""], ["proof (prove)\nusing this:\n  smap (f \\<circ> state) \\<omega> = sconst u\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>y. y \\<in> \\<Union> (cfg_on ` f -` {u})) \\<omega>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. smap (f \\<circ> state) \\<omega> = sconst u \\<Longrightarrow>\n    pred_stream (\\<lambda>y. y \\<in> \\<Union> (cfg_on ` f -` {u})) \\<omega>", "have \"(f o state) cfg = u\" if \"cfg \\<in> sset \\<omega>\" for cfg"], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<circ> state) cfg = u", "using stream.set_map[of \"f o state\" \\<omega>] that \\<open>smap _ \\<omega> = _\\<close>"], ["proof (prove)\nusing this:\n  sset (smap (f \\<circ> state) \\<omega>) = (f \\<circ> state) ` sset \\<omega>\n  cfg \\<in> sset \\<omega>\n  smap (f \\<circ> state) \\<omega> = sconst u\n\ngoal (1 subgoal):\n 1. (f \\<circ> state) cfg = u", "by fastforce"], ["proof (state)\nthis:\n  ?cfg1 \\<in> sset \\<omega> \\<Longrightarrow> (f \\<circ> state) ?cfg1 = u\n\ngoal (1 subgoal):\n 1. smap (f \\<circ> state) \\<omega> = sconst u \\<Longrightarrow>\n    pred_stream (\\<lambda>y. y \\<in> \\<Union> (cfg_on ` f -` {u})) \\<omega>", "with \\<open>pred_stream (\\<lambda> x. x \\<in> cfg_on (state x)) \\<omega>\\<close>"], ["proof (chain)\npicking this:\n  pred_stream (\\<lambda>x. x \\<in> cfg_on (state x)) \\<omega>\n  ?cfg1 \\<in> sset \\<omega> \\<Longrightarrow> (f \\<circ> state) ?cfg1 = u", "show ?thesis"], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>x. x \\<in> cfg_on (state x)) \\<omega>\n  ?cfg1 \\<in> sset \\<omega> \\<Longrightarrow> (f \\<circ> state) ?cfg1 = u\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>y. y \\<in> \\<Union> (cfg_on ` f -` {u})) \\<omega>", "by (auto elim!: stream.pred_mono_strong)"], ["proof (state)\nthis:\n  pred_stream (\\<lambda>y. y \\<in> \\<Union> (cfg_on ` f -` {u})) \\<omega>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pred_stream (\\<lambda>y. y \\<in> \\<Union> (cfg_on ` f -` {u})) \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>\\<omega> \\<in> space (MC.T cfg); MC.enabled cfg \\<omega>;\n        pred_stream (\\<lambda>\\<omega>. \\<omega> \\<in> X) \\<omega>;\n        ev (HLD (- (\\<Union> (cfg_on ` f -` {u}) \\<inter> X))) \\<omega>;\n        smap (f \\<circ> state) \\<omega> = sconst u\\<rbrakk>\n       \\<Longrightarrow> False", "with \\<open>pred_stream (\\<lambda>\\<omega>. \\<omega> \\<in> X) \\<omega>\\<close>"], ["proof (chain)\npicking this:\n  pred_stream (\\<lambda>\\<omega>. \\<omega> \\<in> X) \\<omega>\n  pred_stream (\\<lambda>y. y \\<in> \\<Union> (cfg_on ` f -` {u})) \\<omega>", "have \"pred_stream (\\<lambda> x. x \\<in> ?S) \\<omega>\""], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>\\<omega>. \\<omega> \\<in> X) \\<omega>\n  pred_stream (\\<lambda>y. y \\<in> \\<Union> (cfg_on ` f -` {u})) \\<omega>\n\ngoal (1 subgoal):\n 1. pred_stream\n     (\\<lambda>x. x \\<in> \\<Union> (cfg_on ` f -` {u}) \\<inter> X) \\<omega>", "by (coinduction arbitrary: \\<omega>) auto"], ["proof (state)\nthis:\n  pred_stream (\\<lambda>x. x \\<in> \\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n   \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>\\<omega> \\<in> space (MC.T cfg); MC.enabled cfg \\<omega>;\n        pred_stream (\\<lambda>\\<omega>. \\<omega> \\<in> X) \\<omega>;\n        ev (HLD (- (\\<Union> (cfg_on ` f -` {u}) \\<inter> X))) \\<omega>;\n        smap (f \\<circ> state) \\<omega> = sconst u\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  pred_stream (\\<lambda>x. x \\<in> \\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n   \\<omega>", "have \"alw (HLD ?S) \\<omega>\""], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>x. x \\<in> \\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n   \\<omega>\n\ngoal (1 subgoal):\n 1. alw (HLD (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)) \\<omega>", "by (simp add: alw_holds_pred_stream_iff HLD_def)"], ["proof (state)\nthis:\n  alw (HLD (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)) \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>\\<omega> \\<in> space (MC.T cfg); MC.enabled cfg \\<omega>;\n        pred_stream (\\<lambda>\\<omega>. \\<omega> \\<in> X) \\<omega>;\n        ev (HLD (- (\\<Union> (cfg_on ` f -` {u}) \\<inter> X))) \\<omega>;\n        smap (f \\<circ> state) \\<omega> = sconst u\\<rbrakk>\n       \\<Longrightarrow> False", "with \\<open>ev (HLD (- ?S)) \\<omega>\\<close>"], ["proof (chain)\npicking this:\n  ev (HLD (- (\\<Union> (cfg_on ` f -` {u}) \\<inter> X))) \\<omega>\n  alw (HLD (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)) \\<omega>", "show False"], ["proof (prove)\nusing this:\n  ev (HLD (- (\\<Union> (cfg_on ` f -` {u}) \\<inter> X))) \\<omega>\n  alw (HLD (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)) \\<omega>\n\ngoal (1 subgoal):\n 1. False", "unfolding not_ev_not[symmetric] not_HLD"], ["proof (prove)\nusing this:\n  ev (HLD (- (\\<Union> (cfg_on ` f -` {u}) \\<inter> X))) \\<omega>\n  \\<not> ev (HLD (- (\\<Union> (cfg_on ` f -` {u}) \\<inter> X))) \\<omega>\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  AE \\<omega> in MC.T cfg. smap (f \\<circ> state) \\<omega> \\<noteq> sconst u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma MC_T_not_sconst:\n  assumes\n    \"\\<forall> l. \\<forall> cfg \\<in> (\\<Union> x \\<in> f -` {u}. cfg_on x) \\<inter> X. measure_pmf (action cfg) (f -` {u}) \\<le> r\"\n    \"r < 1\" \"cfg \\<in> cfg_on x\"\n    \"AE \\<omega> in MC.T cfg. pred_stream (\\<lambda> x. x \\<in> X) \\<omega>\"\n  shows \"AE \\<omega> in MC.T cfg. smap (f o state) \\<omega> \\<noteq> sconst u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE \\<omega> in MC.T\n                    cfg. smap (f \\<circ> state) \\<omega> \\<noteq> sconst u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. AE \\<omega> in MC.T\n                    cfg. smap (f \\<circ> state) \\<omega> \\<noteq> sconst u", "let ?U = \"f -` {u}\""], ["proof (state)\ngoal (1 subgoal):\n 1. AE \\<omega> in MC.T\n                    cfg. smap (f \\<circ> state) \\<omega> \\<noteq> sconst u", "let ?S = \"(\\<Union> x \\<in> f -` {u}. cfg_on x) \\<inter> X\""], ["proof (state)\ngoal (1 subgoal):\n 1. AE \\<omega> in MC.T\n                    cfg. smap (f \\<circ> state) \\<omega> \\<noteq> sconst u", "have *: \"emeasure (K_cfg cfg) ?S \\<le> r\" if \"cfg \\<in> ?S\" for cfg"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (K_cfg cfg))\n     (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n    \\<le> r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (K_cfg cfg))\n     (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n    \\<le> r", "have \"emeasure (K_cfg cfg) ?S \\<le> emeasure (measure_pmf (action cfg)) ?U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (K_cfg cfg))\n     (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n    \\<le> emeasure (measure_pmf (action cfg)) (f -` {u})", "unfolding K_cfg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (map_pmf (cont cfg) (action cfg)))\n     (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n    \\<le> emeasure (measure_pmf (action cfg)) (f -` {u})", "by (auto dest: cfg_onD_state intro!: emeasure_mono)"], ["proof (state)\nthis:\n  emeasure (measure_pmf (K_cfg cfg))\n   (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n  \\<le> emeasure (measure_pmf (action cfg)) (f -` {u})\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (K_cfg cfg))\n     (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n    \\<le> r", "also"], ["proof (state)\nthis:\n  emeasure (measure_pmf (K_cfg cfg))\n   (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n  \\<le> emeasure (measure_pmf (action cfg)) (f -` {u})\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (K_cfg cfg))\n     (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n    \\<le> r", "from assms(1) \\<open>cfg \\<in> ?S\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>l.\n     \\<forall>cfg\\<in>\\<Union> (cfg_on ` f -` {u}) \\<inter> X.\n        emeasure (measure_pmf (action cfg)) (f -` {u}) \\<le> r\n  cfg \\<in> \\<Union> (cfg_on ` f -` {u}) \\<inter> X", "have \"\\<dots> \\<le> r\""], ["proof (prove)\nusing this:\n  \\<forall>l.\n     \\<forall>cfg\\<in>\\<Union> (cfg_on ` f -` {u}) \\<inter> X.\n        emeasure (measure_pmf (action cfg)) (f -` {u}) \\<le> r\n  cfg \\<in> \\<Union> (cfg_on ` f -` {u}) \\<inter> X\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (action cfg)) (f -` {u}) \\<le> r", "by auto"], ["proof (state)\nthis:\n  emeasure (measure_pmf (action cfg)) (f -` {u}) \\<le> r\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (K_cfg cfg))\n     (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n    \\<le> r", "finally"], ["proof (chain)\npicking this:\n  emeasure (measure_pmf (K_cfg cfg))\n   (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n  \\<le> r", "show ?thesis"], ["proof (prove)\nusing this:\n  emeasure (measure_pmf (K_cfg cfg))\n   (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n  \\<le> r\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (K_cfg cfg))\n     (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n    \\<le> r", "."], ["proof (state)\nthis:\n  emeasure (measure_pmf (K_cfg cfg))\n   (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n  \\<le> r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?cfg1 \\<in> \\<Union> (cfg_on ` f -` {u}) \\<inter> X \\<Longrightarrow>\n  emeasure (measure_pmf (K_cfg ?cfg1))\n   (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n  \\<le> r\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MC.T\n                    cfg. smap (f \\<circ> state) \\<omega> \\<noteq> sconst u", "have \"AE \\<omega> in MC.T cfg. ev (HLD (- ?S)) \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_everywhere (MC.T cfg)\n     (ev (HLD (- (\\<Union> (cfg_on ` f -` {u}) \\<inter> X))))", "apply (rule MC.AE_T_ev_HLD_infinite[where r = \"enn2real r\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. enn2real r < 1\n 2. \\<And>x.\n       x \\<in> \\<Union> (cfg_on ` f -` {u}) \\<inter> X \\<Longrightarrow>\n       measure_pmf.prob (K_cfg x) (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n       \\<le> enn2real r", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. enn2real r < 1", "using \\<open>r < 1\\<close>"], ["proof (prove)\nusing this:\n  r < 1\n\ngoal (1 subgoal):\n 1. enn2real r < 1", "by (metis ennreal_enn2real_if ennreal_less_one_iff zero_less_one)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (cfg_on ` f -` {u}) \\<inter> X \\<Longrightarrow>\n       measure_pmf.prob (K_cfg x) (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n       \\<le> enn2real r", "apply (drule *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       emeasure (measure_pmf (K_cfg x))\n        (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n       \\<le> r \\<Longrightarrow>\n       measure_pmf.prob (K_cfg x) (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n       \\<le> enn2real r", "by (metis Sigma_Algebra.measure_def assms(2) enn2real_mono ennreal_one_less_top less_trans)"], ["proof (state)\nthis:\n  almost_everywhere (MC.T cfg)\n   (ev (HLD (- (\\<Union> (cfg_on ` f -` {u}) \\<inter> X))))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MC.T\n                    cfg. smap (f \\<circ> state) \\<omega> \\<noteq> sconst u", "then"], ["proof (chain)\npicking this:\n  almost_everywhere (MC.T cfg)\n   (ev (HLD (- (\\<Union> (cfg_on ` f -` {u}) \\<inter> X))))", "show ?thesis"], ["proof (prove)\nusing this:\n  almost_everywhere (MC.T cfg)\n   (ev (HLD (- (\\<Union> (cfg_on ` f -` {u}) \\<inter> X))))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MC.T\n                    cfg. smap (f \\<circ> state) \\<omega> \\<noteq> sconst u", "apply (rule AE_mp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE \\<omega> in MC.T\n                    cfg. ev (HLD (- (\\<Union> (cfg_on ` f -` {u}) \\<inter>\n                                     X)))\n                          \\<omega> \\<longrightarrow>\n                         smap (f \\<circ> state) \\<omega> \\<noteq> sconst u", "proof (rule AE_mp[OF assms(4)], rule AE_mp[OF MC.AE_T_enabled], rule AE_I2, safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>\\<omega> \\<in> space (MC.T cfg); MC.enabled cfg \\<omega>;\n        pred_stream (\\<lambda>\\<omega>. \\<omega> \\<in> X) \\<omega>;\n        ev (HLD (- (\\<Union> (cfg_on ` f -` {u}) \\<inter> X))) \\<omega>;\n        smap (f \\<circ> state) \\<omega> = sconst u\\<rbrakk>\n       \\<Longrightarrow> False", "fix \\<omega>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>\\<omega> \\<in> space (MC.T cfg); MC.enabled cfg \\<omega>;\n        pred_stream (\\<lambda>\\<omega>. \\<omega> \\<in> X) \\<omega>;\n        ev (HLD (- (\\<Union> (cfg_on ` f -` {u}) \\<inter> X))) \\<omega>;\n        smap (f \\<circ> state) \\<omega> = sconst u\\<rbrakk>\n       \\<Longrightarrow> False", "assume\n      \"\\<omega> \\<in> space (MC.T cfg)\" \"pred_stream (\\<lambda>\\<omega>. \\<omega> \\<in> X) \\<omega>\"\n      \"MC.enabled cfg \\<omega>\" \"ev (HLD (- ?S)) \\<omega>\" \"smap (f \\<circ> state) \\<omega> = sconst u\""], ["proof (state)\nthis:\n  \\<omega> \\<in> space (MC.T cfg)\n  pred_stream (\\<lambda>\\<omega>. \\<omega> \\<in> X) \\<omega>\n  MC.enabled cfg \\<omega>\n  ev (HLD (- (\\<Union> (cfg_on ` f -` {u}) \\<inter> X))) \\<omega>\n  smap (f \\<circ> state) \\<omega> = sconst u\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>\\<omega> \\<in> space (MC.T cfg); MC.enabled cfg \\<omega>;\n        pred_stream (\\<lambda>\\<omega>. \\<omega> \\<in> X) \\<omega>;\n        ev (HLD (- (\\<Union> (cfg_on ` f -` {u}) \\<inter> X))) \\<omega>;\n        smap (f \\<circ> state) \\<omega> = sconst u\\<rbrakk>\n       \\<Longrightarrow> False", "from this(2,3) \\<open>cfg \\<in> _\\<close>"], ["proof (chain)\npicking this:\n  pred_stream (\\<lambda>\\<omega>. \\<omega> \\<in> X) \\<omega>\n  MC.enabled cfg \\<omega>\n  cfg \\<in> cfg_on x", "have \"pred_stream (\\<lambda> x. x \\<in> cfg_on (state x)) \\<omega>\""], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>\\<omega>. \\<omega> \\<in> X) \\<omega>\n  MC.enabled cfg \\<omega>\n  cfg \\<in> cfg_on x\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>x. x \\<in> cfg_on (state x)) \\<omega>", "by (auto dest: cfg_onD_state intro!: cfg_on_inv)"], ["proof (state)\nthis:\n  pred_stream (\\<lambda>x. x \\<in> cfg_on (state x)) \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>\\<omega> \\<in> space (MC.T cfg); MC.enabled cfg \\<omega>;\n        pred_stream (\\<lambda>\\<omega>. \\<omega> \\<in> X) \\<omega>;\n        ev (HLD (- (\\<Union> (cfg_on ` f -` {u}) \\<inter> X))) \\<omega>;\n        smap (f \\<circ> state) \\<omega> = sconst u\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>smap _ \\<omega> = _\\<close>"], ["proof (chain)\npicking this:\n  smap (f \\<circ> state) \\<omega> = sconst u", "have \"pred_stream (\\<lambda> y. y \\<in> (\\<Union> x \\<in> ?U. cfg_on x)) \\<omega>\""], ["proof (prove)\nusing this:\n  smap (f \\<circ> state) \\<omega> = sconst u\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>y. y \\<in> \\<Union> (cfg_on ` f -` {u})) \\<omega>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. smap (f \\<circ> state) \\<omega> = sconst u \\<Longrightarrow>\n    pred_stream (\\<lambda>y. y \\<in> \\<Union> (cfg_on ` f -` {u})) \\<omega>", "have \"(f o state) cfg = u\" if \"cfg \\<in> sset \\<omega>\" for cfg"], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<circ> state) cfg = u", "using stream.set_map[of \"f o state\" \\<omega>] that \\<open>smap _ \\<omega> = _\\<close>"], ["proof (prove)\nusing this:\n  sset (smap (f \\<circ> state) \\<omega>) = (f \\<circ> state) ` sset \\<omega>\n  cfg \\<in> sset \\<omega>\n  smap (f \\<circ> state) \\<omega> = sconst u\n\ngoal (1 subgoal):\n 1. (f \\<circ> state) cfg = u", "by fastforce"], ["proof (state)\nthis:\n  ?cfg1 \\<in> sset \\<omega> \\<Longrightarrow> (f \\<circ> state) ?cfg1 = u\n\ngoal (1 subgoal):\n 1. smap (f \\<circ> state) \\<omega> = sconst u \\<Longrightarrow>\n    pred_stream (\\<lambda>y. y \\<in> \\<Union> (cfg_on ` f -` {u})) \\<omega>", "with \\<open>pred_stream (\\<lambda> x. x \\<in> cfg_on (state x)) \\<omega>\\<close>"], ["proof (chain)\npicking this:\n  pred_stream (\\<lambda>x. x \\<in> cfg_on (state x)) \\<omega>\n  ?cfg1 \\<in> sset \\<omega> \\<Longrightarrow> (f \\<circ> state) ?cfg1 = u", "show ?thesis"], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>x. x \\<in> cfg_on (state x)) \\<omega>\n  ?cfg1 \\<in> sset \\<omega> \\<Longrightarrow> (f \\<circ> state) ?cfg1 = u\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>y. y \\<in> \\<Union> (cfg_on ` f -` {u})) \\<omega>", "by (auto elim!: stream.pred_mono_strong)"], ["proof (state)\nthis:\n  pred_stream (\\<lambda>y. y \\<in> \\<Union> (cfg_on ` f -` {u})) \\<omega>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pred_stream (\\<lambda>y. y \\<in> \\<Union> (cfg_on ` f -` {u})) \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>\\<omega> \\<in> space (MC.T cfg); MC.enabled cfg \\<omega>;\n        pred_stream (\\<lambda>\\<omega>. \\<omega> \\<in> X) \\<omega>;\n        ev (HLD (- (\\<Union> (cfg_on ` f -` {u}) \\<inter> X))) \\<omega>;\n        smap (f \\<circ> state) \\<omega> = sconst u\\<rbrakk>\n       \\<Longrightarrow> False", "with \\<open>pred_stream (\\<lambda>\\<omega>. \\<omega> \\<in> X) \\<omega>\\<close>"], ["proof (chain)\npicking this:\n  pred_stream (\\<lambda>\\<omega>. \\<omega> \\<in> X) \\<omega>\n  pred_stream (\\<lambda>y. y \\<in> \\<Union> (cfg_on ` f -` {u})) \\<omega>", "have \"pred_stream (\\<lambda> x. x \\<in> ?S) \\<omega>\""], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>\\<omega>. \\<omega> \\<in> X) \\<omega>\n  pred_stream (\\<lambda>y. y \\<in> \\<Union> (cfg_on ` f -` {u})) \\<omega>\n\ngoal (1 subgoal):\n 1. pred_stream\n     (\\<lambda>x. x \\<in> \\<Union> (cfg_on ` f -` {u}) \\<inter> X) \\<omega>", "by (coinduction arbitrary: \\<omega>) auto"], ["proof (state)\nthis:\n  pred_stream (\\<lambda>x. x \\<in> \\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n   \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>\\<omega> \\<in> space (MC.T cfg); MC.enabled cfg \\<omega>;\n        pred_stream (\\<lambda>\\<omega>. \\<omega> \\<in> X) \\<omega>;\n        ev (HLD (- (\\<Union> (cfg_on ` f -` {u}) \\<inter> X))) \\<omega>;\n        smap (f \\<circ> state) \\<omega> = sconst u\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  pred_stream (\\<lambda>x. x \\<in> \\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n   \\<omega>", "have \"alw (HLD ?S) \\<omega>\""], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>x. x \\<in> \\<Union> (cfg_on ` f -` {u}) \\<inter> X)\n   \\<omega>\n\ngoal (1 subgoal):\n 1. alw (HLD (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)) \\<omega>", "by (simp add: alw_holds_pred_stream_iff HLD_def)"], ["proof (state)\nthis:\n  alw (HLD (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)) \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>\\<omega> \\<in> space (MC.T cfg); MC.enabled cfg \\<omega>;\n        pred_stream (\\<lambda>\\<omega>. \\<omega> \\<in> X) \\<omega>;\n        ev (HLD (- (\\<Union> (cfg_on ` f -` {u}) \\<inter> X))) \\<omega>;\n        smap (f \\<circ> state) \\<omega> = sconst u\\<rbrakk>\n       \\<Longrightarrow> False", "with \\<open>ev (HLD (- ?S)) \\<omega>\\<close>"], ["proof (chain)\npicking this:\n  ev (HLD (- (\\<Union> (cfg_on ` f -` {u}) \\<inter> X))) \\<omega>\n  alw (HLD (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)) \\<omega>", "show False"], ["proof (prove)\nusing this:\n  ev (HLD (- (\\<Union> (cfg_on ` f -` {u}) \\<inter> X))) \\<omega>\n  alw (HLD (\\<Union> (cfg_on ` f -` {u}) \\<inter> X)) \\<omega>\n\ngoal (1 subgoal):\n 1. False", "unfolding not_ev_not[symmetric] not_HLD"], ["proof (prove)\nusing this:\n  ev (HLD (- (\\<Union> (cfg_on ` f -` {u}) \\<inter> X))) \\<omega>\n  \\<not> ev (HLD (- (\\<Union> (cfg_on ` f -` {u}) \\<inter> X))) \\<omega>\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  AE \\<omega> in MC.T cfg. smap (f \\<circ> state) \\<omega> \\<noteq> sconst u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma MC_T_not_sconst':\n  assumes\n    \"\\<forall> cfg \\<in> cfg_on x \\<inter> X. measure_pmf (action cfg) {x} \\<le> r\" \"r < 1\" \"cfg \\<in> cfg_on x'\"\n    \"AE \\<omega> in MC.T cfg. pred_stream (\\<lambda> x. x \\<in> X) \\<omega>\"\n  shows \"AE \\<omega> in MC.T cfg. smap state \\<omega> \\<noteq> sconst x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE \\<omega> in MC.T cfg. smap state \\<omega> \\<noteq> sconst x", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>cfg\\<in>cfg_on x \\<inter> X.\n     emeasure (measure_pmf (action cfg)) {x} \\<le> r\n  r < 1\n  cfg \\<in> cfg_on x'\n  almost_everywhere (MC.T cfg) (pred_stream (\\<lambda>x. x \\<in> X))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MC.T cfg. smap state \\<omega> \\<noteq> sconst x", "by (rule MC_T_not_sconst[where f = id, simplified])"], ["", "lemma K_cfg_cfg_onI:\n  \"cfg' \\<in> cfg_on (state cfg')\" if \"cfg \\<in> cfg_on x\" \"cfg' \\<in> K_cfg cfg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cfg' \\<in> cfg_on (state cfg')", "using that"], ["proof (prove)\nusing this:\n  cfg \\<in> cfg_on x\n  cfg' \\<in> set_pmf (K_cfg cfg)\n\ngoal (1 subgoal):\n 1. cfg' \\<in> cfg_on (state cfg')", "by (force simp: set_K_cfg)"], ["", "lemma MC_acc_cfg_onI:\n  \"cfg' \\<in> cfg_on (state cfg')\" if \"(cfg, cfg') \\<in> MC.acc\" \"cfg \\<in> cfg_on x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cfg' \\<in> cfg_on (state cfg')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cfg' \\<in> cfg_on (state cfg')", "from that(1)"], ["proof (chain)\npicking this:\n  (cfg, cfg') \\<in> MC.acc", "obtain n where \"((\\<lambda> a b. b \\<in> K_cfg a) ^^ n) cfg cfg'\""], ["proof (prove)\nusing this:\n  (cfg, cfg') \\<in> MC.acc\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ n) cfg\n         cfg' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (erule MC.acc_relfunD)"], ["proof (state)\nthis:\n  ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ n) cfg cfg'\n\ngoal (1 subgoal):\n 1. cfg' \\<in> cfg_on (state cfg')", "with \\<open>cfg \\<in> cfg_on x\\<close>"], ["proof (chain)\npicking this:\n  cfg \\<in> cfg_on x\n  ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ n) cfg cfg'", "show ?thesis"], ["proof (prove)\nusing this:\n  cfg \\<in> cfg_on x\n  ((\\<lambda>a b. b \\<in> set_pmf (K_cfg a)) ^^ n) cfg cfg'\n\ngoal (1 subgoal):\n 1. cfg' \\<in> cfg_on (state cfg')", "by (induction n arbitrary: cfg') (auto intro: K_cfg_cfg_onI)"], ["proof (state)\nthis:\n  cfg' \\<in> cfg_on (state cfg')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma non_loop_tail_strong:\n  assumes\n    \"\\<forall> l. \\<forall> cfg \\<in> (\\<Union> x \\<in> f -` {u}. cfg_on x) \\<inter> Y \\<inter> X. measure_pmf (action cfg) (f -` {u}) \\<le> r\"\n    \"r < 1\" \"cfg \\<in> cfg_on x\"\n    \"AE \\<omega> in MC.T cfg. pred_stream (\\<lambda> x. x \\<in> X) \\<omega>\"\n    \"AE \\<omega> in MC.T cfg. alw (\\<lambda> \\<omega>. HLD (f -` {u}) (smap state \\<omega>) \\<longrightarrow> ev (HLD Y) \\<omega>) \\<omega>\"\n  shows \"AE \\<omega> in MC.T cfg. \\<not> (ev (alw (\\<lambda> xs. shd xs = u))) (smap (f o state) \\<omega>)\"\n    (is \"AE \\<omega> in ?M. ?P \\<omega>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE \\<omega> in MC.T\n                    cfg. \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                                 (smap (f \\<circ> state) \\<omega>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. AE \\<omega> in MC.T\n                    cfg. \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                                 (smap (f \\<circ> state) \\<omega>)", "have *: \"?P \\<omega> \\<longleftrightarrow> alw (\\<lambda> xs. smap (f o state) xs \\<noteq> sconst u) \\<omega>\" for \\<omega>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> ev (alw (\\<lambda>xs. shd xs = u))\n             (smap (f \\<circ> state) \\<omega>)) =\n    alw (\\<lambda>xs. smap (f \\<circ> state) xs \\<noteq> sconst u) \\<omega>", "apply (simp add: not_ev_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (\\<lambda>xs. \\<not> alw (\\<lambda>x. f (state (shd x)) = u) xs)\n     \\<omega> =\n    alw (\\<lambda>xs. smap (\\<lambda>z. f (state z)) xs \\<noteq> sconst u)\n     \\<omega>", "apply (rule arg_cong2[where f = alw])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>xs. \\<not> alw (\\<lambda>x. f (state (shd x)) = u) xs) =\n    (\\<lambda>xs. smap (\\<lambda>z. f (state z)) xs \\<noteq> sconst u)\n 2. \\<omega> = \\<omega>", "apply (rule ext)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       (\\<not> alw (\\<lambda>x. f (state (shd x)) = u) xs) =\n       (smap (\\<lambda>z. f (state z)) xs \\<noteq> sconst u)\n 2. \\<omega> = \\<omega>", "subgoal for xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> alw (\\<lambda>x. f (state (shd x)) = u) xs) =\n    (smap (\\<lambda>z. f (state z)) xs \\<noteq> sconst u)", "using MC.alw_HLD_iff_sconst[of u \"smap (f o state) xs\"]"], ["proof (prove)\nusing this:\n  alw (HLD {u}) (smap (f \\<circ> state) xs) =\n  (smap (f \\<circ> state) xs = sconst u)\n\ngoal (1 subgoal):\n 1. (\\<not> alw (\\<lambda>x. f (state (shd x)) = u) xs) =\n    (smap (\\<lambda>z. f (state z)) xs \\<noteq> sconst u)", "by (simp add: HLD_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> = \\<omega>", "by (rule HOL.refl)"], ["proof (state)\nthis:\n  (\\<not> ev (alw (\\<lambda>xs. shd xs = u))\n           (smap (f \\<circ> state) ?\\<omega>1)) =\n  alw (\\<lambda>xs. smap (f \\<circ> state) xs \\<noteq> sconst u) ?\\<omega>1\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MC.T\n                    cfg. \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                                 (smap (f \\<circ> state) \\<omega>)", "have \"AE \\<omega> in ?M. alw (\\<lambda> xs. smap (f o state) xs \\<noteq> sconst u) \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_everywhere (MC.T cfg)\n     (alw (\\<lambda>xs. smap (f \\<circ> state) xs \\<noteq> sconst u))", "apply (rule MC.AE_T_alw)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>xs. smap (f \\<circ> state) xs \\<noteq> sconst u)\n 2. \\<And>s.\n       (cfg, s) \\<in> MC.acc \\<Longrightarrow>\n       AE \\<omega> in MC.T\n                       s. smap (f \\<circ> state) \\<omega> \\<noteq> sconst u", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>xs. smap (f \\<circ> state) xs \\<noteq> sconst u)", "by (intro pred_intros_logic measurable_eq_stream_space) measurable"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       (cfg, s) \\<in> MC.acc \\<Longrightarrow>\n       AE \\<omega> in MC.T\n                       s. smap (f \\<circ> state) \\<omega> \\<noteq> sconst u", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>l.\n     \\<forall>cfg\\<in>\\<Union> (cfg_on ` f -` {u}) \\<inter> Y \\<inter> X.\n        emeasure (measure_pmf (action cfg)) (f -` {u}) \\<le> r\n  r < 1\n  cfg \\<in> cfg_on x\n  almost_everywhere (MC.T cfg) (pred_stream (\\<lambda>x. x \\<in> X))\n  almost_everywhere (MC.T cfg)\n   (alw (\\<lambda>\\<omega>.\n            HLD (f -` {u}) (smap state \\<omega>) \\<longrightarrow>\n            ev (HLD Y) \\<omega>))\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       (cfg, s) \\<in> MC.acc \\<Longrightarrow>\n       AE \\<omega> in MC.T\n                       s. smap (f \\<circ> state) \\<omega> \\<noteq> sconst u", "by - (erule MC_T_not_sconst_strong,\n        auto intro: MC.AE_all_accD MC.AE_alw_accD elim: MC_acc_cfg_onI\n        )"], ["proof (state)\nthis:\n  almost_everywhere (MC.T cfg)\n   (alw (\\<lambda>xs. smap (f \\<circ> state) xs \\<noteq> sconst u))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MC.T\n                    cfg. \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                                 (smap (f \\<circ> state) \\<omega>)", "with *"], ["proof (chain)\npicking this:\n  (\\<not> ev (alw (\\<lambda>xs. shd xs = u))\n           (smap (f \\<circ> state) ?\\<omega>1)) =\n  alw (\\<lambda>xs. smap (f \\<circ> state) xs \\<noteq> sconst u) ?\\<omega>1\n  almost_everywhere (MC.T cfg)\n   (alw (\\<lambda>xs. smap (f \\<circ> state) xs \\<noteq> sconst u))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<not> ev (alw (\\<lambda>xs. shd xs = u))\n           (smap (f \\<circ> state) ?\\<omega>1)) =\n  alw (\\<lambda>xs. smap (f \\<circ> state) xs \\<noteq> sconst u) ?\\<omega>1\n  almost_everywhere (MC.T cfg)\n   (alw (\\<lambda>xs. smap (f \\<circ> state) xs \\<noteq> sconst u))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MC.T\n                    cfg. \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                                 (smap (f \\<circ> state) \\<omega>)", "by simp"], ["proof (state)\nthis:\n  AE \\<omega> in MC.T\n                  cfg. \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                               (smap (f \\<circ> state) \\<omega>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma non_loop_tail:\n  assumes\n    \"\\<forall> l. \\<forall> cfg \\<in> (\\<Union> x \\<in> f -` {u}. cfg_on x) \\<inter> X. measure_pmf (action cfg) (f -` {u}) \\<le> r\"\n    \"r < 1\" \"cfg \\<in> cfg_on x\"\n    \"AE \\<omega> in MC.T cfg. pred_stream (\\<lambda> x. x \\<in> X) \\<omega>\"\n  shows \"AE \\<omega> in MC.T cfg. \\<not> (ev (alw (\\<lambda> xs. shd xs = u))) (smap (f o state) \\<omega>)\"\n    (is \"AE \\<omega> in ?M. ?P \\<omega>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE \\<omega> in MC.T\n                    cfg. \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                                 (smap (f \\<circ> state) \\<omega>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. AE \\<omega> in MC.T\n                    cfg. \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                                 (smap (f \\<circ> state) \\<omega>)", "have *: \"?P \\<omega> \\<longleftrightarrow> alw (\\<lambda> xs. smap (f o state) xs \\<noteq> sconst u) \\<omega>\" for \\<omega>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> ev (alw (\\<lambda>xs. shd xs = u))\n             (smap (f \\<circ> state) \\<omega>)) =\n    alw (\\<lambda>xs. smap (f \\<circ> state) xs \\<noteq> sconst u) \\<omega>", "apply (simp add: not_ev_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (\\<lambda>xs. \\<not> alw (\\<lambda>x. f (state (shd x)) = u) xs)\n     \\<omega> =\n    alw (\\<lambda>xs. smap (\\<lambda>z. f (state z)) xs \\<noteq> sconst u)\n     \\<omega>", "apply (rule arg_cong2[where f = alw])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>xs. \\<not> alw (\\<lambda>x. f (state (shd x)) = u) xs) =\n    (\\<lambda>xs. smap (\\<lambda>z. f (state z)) xs \\<noteq> sconst u)\n 2. \\<omega> = \\<omega>", "apply (rule ext)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       (\\<not> alw (\\<lambda>x. f (state (shd x)) = u) xs) =\n       (smap (\\<lambda>z. f (state z)) xs \\<noteq> sconst u)\n 2. \\<omega> = \\<omega>", "subgoal for xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> alw (\\<lambda>x. f (state (shd x)) = u) xs) =\n    (smap (\\<lambda>z. f (state z)) xs \\<noteq> sconst u)", "using MC.alw_HLD_iff_sconst[of u \"smap (f o state) xs\"]"], ["proof (prove)\nusing this:\n  alw (HLD {u}) (smap (f \\<circ> state) xs) =\n  (smap (f \\<circ> state) xs = sconst u)\n\ngoal (1 subgoal):\n 1. (\\<not> alw (\\<lambda>x. f (state (shd x)) = u) xs) =\n    (smap (\\<lambda>z. f (state z)) xs \\<noteq> sconst u)", "by (simp add: HLD_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> = \\<omega>", "by (rule HOL.refl)"], ["proof (state)\nthis:\n  (\\<not> ev (alw (\\<lambda>xs. shd xs = u))\n           (smap (f \\<circ> state) ?\\<omega>1)) =\n  alw (\\<lambda>xs. smap (f \\<circ> state) xs \\<noteq> sconst u) ?\\<omega>1\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MC.T\n                    cfg. \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                                 (smap (f \\<circ> state) \\<omega>)", "have \"AE \\<omega> in ?M. alw (\\<lambda> xs. smap (f o state) xs \\<noteq> sconst u) \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_everywhere (MC.T cfg)\n     (alw (\\<lambda>xs. smap (f \\<circ> state) xs \\<noteq> sconst u))", "apply (rule MC.AE_T_alw)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>xs. smap (f \\<circ> state) xs \\<noteq> sconst u)\n 2. \\<And>s.\n       (cfg, s) \\<in> MC.acc \\<Longrightarrow>\n       AE \\<omega> in MC.T\n                       s. smap (f \\<circ> state) \\<omega> \\<noteq> sconst u", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>xs. smap (f \\<circ> state) xs \\<noteq> sconst u)", "by (intro pred_intros_logic measurable_eq_stream_space) measurable"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       (cfg, s) \\<in> MC.acc \\<Longrightarrow>\n       AE \\<omega> in MC.T\n                       s. smap (f \\<circ> state) \\<omega> \\<noteq> sconst u", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>l.\n     \\<forall>cfg\\<in>\\<Union> (cfg_on ` f -` {u}) \\<inter> X.\n        emeasure (measure_pmf (action cfg)) (f -` {u}) \\<le> r\n  r < 1\n  cfg \\<in> cfg_on x\n  almost_everywhere (MC.T cfg) (pred_stream (\\<lambda>x. x \\<in> X))\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       (cfg, s) \\<in> MC.acc \\<Longrightarrow>\n       AE \\<omega> in MC.T\n                       s. smap (f \\<circ> state) \\<omega> \\<noteq> sconst u", "by - (erule MC_T_not_sconst, auto intro: MC.AE_all_accD elim: MC_acc_cfg_onI)"], ["proof (state)\nthis:\n  almost_everywhere (MC.T cfg)\n   (alw (\\<lambda>xs. smap (f \\<circ> state) xs \\<noteq> sconst u))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MC.T\n                    cfg. \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                                 (smap (f \\<circ> state) \\<omega>)", "with *"], ["proof (chain)\npicking this:\n  (\\<not> ev (alw (\\<lambda>xs. shd xs = u))\n           (smap (f \\<circ> state) ?\\<omega>1)) =\n  alw (\\<lambda>xs. smap (f \\<circ> state) xs \\<noteq> sconst u) ?\\<omega>1\n  almost_everywhere (MC.T cfg)\n   (alw (\\<lambda>xs. smap (f \\<circ> state) xs \\<noteq> sconst u))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<not> ev (alw (\\<lambda>xs. shd xs = u))\n           (smap (f \\<circ> state) ?\\<omega>1)) =\n  alw (\\<lambda>xs. smap (f \\<circ> state) xs \\<noteq> sconst u) ?\\<omega>1\n  almost_everywhere (MC.T cfg)\n   (alw (\\<lambda>xs. smap (f \\<circ> state) xs \\<noteq> sconst u))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MC.T\n                    cfg. \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                                 (smap (f \\<circ> state) \\<omega>)", "by simp"], ["proof (state)\nthis:\n  AE \\<omega> in MC.T\n                  cfg. \\<not> ev (alw (\\<lambda>xs. shd xs = u))\n                               (smap (f \\<circ> state) \\<omega>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma non_loop_tail':\n  assumes\n    \"\\<forall> cfg \\<in> cfg_on x \\<inter> X. measure_pmf (action cfg) {x} \\<le> r\" \"r < 1\"\n    \"cfg \\<in> cfg_on y\"\n    \"AE \\<omega> in MC.T cfg. pred_stream (\\<lambda> x. x \\<in> X) \\<omega>\"\n  shows \"AE \\<omega> in MC.T cfg. \\<not> (ev (alw (\\<lambda> xs. shd xs = x))) (smap state \\<omega>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE \\<omega> in MC.T\n                    cfg. \\<not> ev (alw (\\<lambda>xs. shd xs = x))\n                                 (smap state \\<omega>)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>cfg\\<in>cfg_on x \\<inter> X.\n     emeasure (measure_pmf (action cfg)) {x} \\<le> r\n  r < 1\n  cfg \\<in> cfg_on y\n  almost_everywhere (MC.T cfg) (pred_stream (\\<lambda>x. x \\<in> X))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in MC.T\n                    cfg. \\<not> ev (alw (\\<lambda>xs. shd xs = x))\n                                 (smap state \\<omega>)", "by simp (erule non_loop_tail[where f = id, simplified])"], ["", "end"], ["", "lemma (in Regions) intv_const_mono:\n  assumes \"u \\<in> region X I r\" \"c1 \\<in> X\" \"c2 \\<in> X\" \"u c1 \\<le> u c2\" \"\\<not> isGreater (I c2)\"\n  shows \"intv_const (I c1) \\<le> intv_const (I c2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intv_const (I c1) \\<le> intv_const (I c2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. intv_const (I c1) \\<le> intv_const (I c2)", "from assms"], ["proof (chain)\npicking this:\n  u \\<in> Regions.region X I r\n  c1 \\<in> X\n  c2 \\<in> X\n  u c1 \\<le> u c2\n  \\<not> Regions.isGreater (I c2)", "have \"intv_elem c1 u (I c1)\" \"intv_elem c2 u (I c2)\""], ["proof (prove)\nusing this:\n  u \\<in> Regions.region X I r\n  c1 \\<in> X\n  c2 \\<in> X\n  u c1 \\<le> u c2\n  \\<not> Regions.isGreater (I c2)\n\ngoal (1 subgoal):\n 1. Regions.intv_elem c1 u (I c1) &&& Regions.intv_elem c2 u (I c2)", "by auto"], ["proof (state)\nthis:\n  Regions.intv_elem c1 u (I c1)\n  Regions.intv_elem c2 u (I c2)\n\ngoal (1 subgoal):\n 1. intv_const (I c1) \\<le> intv_const (I c2)", "with \\<open>u c1 \\<le> u c2\\<close> \\<open>\\<not> _\\<close>"], ["proof (chain)\npicking this:\n  u c1 \\<le> u c2\n  \\<not> Regions.isGreater (I c2)\n  Regions.intv_elem c1 u (I c1)\n  Regions.intv_elem c2 u (I c2)", "show ?thesis"], ["proof (prove)\nusing this:\n  u c1 \\<le> u c2\n  \\<not> Regions.isGreater (I c2)\n  Regions.intv_elem c1 u (I c1)\n  Regions.intv_elem c2 u (I c2)\n\ngoal (1 subgoal):\n 1. intv_const (I c1) \\<le> intv_const (I c2)", "by (cases \"I c1\"; cases \"I c2\"; auto)"], ["proof (state)\nthis:\n  intv_const (I c1) \\<le> intv_const (I c2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sset_sdrop:\n  assumes \"x \\<in> sset (sdrop i xs)\"\n  shows \"x \\<in> sset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> sset xs", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> sset (sdrop i xs)\n\ngoal (1 subgoal):\n 1. x \\<in> sset xs", "by (auto simp: sset_range)"], ["", "lemma holds_untilD:\n  assumes \"(holds P until holds Q) xs\" \"\\<forall> i \\<le> j. \\<not> Q (xs !! i)\"\n  shows \"P (xs !! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (xs !! j)", "using assms"], ["proof (prove)\nusing this:\n  (holds P until holds Q) xs\n  \\<forall>i\\<le>j. \\<not> Q (xs !! i)\n\ngoal (1 subgoal):\n 1. P (xs !! j)", "proof (induction j arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>(holds P until holds Q) xs;\n        \\<forall>i\\<le>0. \\<not> Q (xs !! i)\\<rbrakk>\n       \\<Longrightarrow> P (xs !! 0)\n 2. \\<And>j xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>(holds P until holds Q) xs;\n                    \\<forall>i\\<le>j. \\<not> Q (xs !! i)\\<rbrakk>\n                   \\<Longrightarrow> P (xs !! j);\n        (holds P until holds Q) xs;\n        \\<forall>i\\<le>Suc j. \\<not> Q (xs !! i)\\<rbrakk>\n       \\<Longrightarrow> P (xs !! Suc j)", "case 0"], ["proof (state)\nthis:\n  (holds P until holds Q) xs\n  \\<forall>i\\<le>0. \\<not> Q (xs !! i)\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>(holds P until holds Q) xs;\n        \\<forall>i\\<le>0. \\<not> Q (xs !! i)\\<rbrakk>\n       \\<Longrightarrow> P (xs !! 0)\n 2. \\<And>j xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>(holds P until holds Q) xs;\n                    \\<forall>i\\<le>j. \\<not> Q (xs !! i)\\<rbrakk>\n                   \\<Longrightarrow> P (xs !! j);\n        (holds P until holds Q) xs;\n        \\<forall>i\\<le>Suc j. \\<not> Q (xs !! i)\\<rbrakk>\n       \\<Longrightarrow> P (xs !! Suc j)", "then"], ["proof (chain)\npicking this:\n  (holds P until holds Q) xs\n  \\<forall>i\\<le>0. \\<not> Q (xs !! i)", "show ?case"], ["proof (prove)\nusing this:\n  (holds P until holds Q) xs\n  \\<forall>i\\<le>0. \\<not> Q (xs !! i)\n\ngoal (1 subgoal):\n 1. P (xs !! 0)", "by cases auto"], ["proof (state)\nthis:\n  P (xs !! 0)\n\ngoal (1 subgoal):\n 1. \\<And>j xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>(holds P until holds Q) xs;\n                    \\<forall>i\\<le>j. \\<not> Q (xs !! i)\\<rbrakk>\n                   \\<Longrightarrow> P (xs !! j);\n        (holds P until holds Q) xs;\n        \\<forall>i\\<le>Suc j. \\<not> Q (xs !! i)\\<rbrakk>\n       \\<Longrightarrow> P (xs !! Suc j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>(holds P until holds Q) xs;\n                    \\<forall>i\\<le>j. \\<not> Q (xs !! i)\\<rbrakk>\n                   \\<Longrightarrow> P (xs !! j);\n        (holds P until holds Q) xs;\n        \\<forall>i\\<le>Suc j. \\<not> Q (xs !! i)\\<rbrakk>\n       \\<Longrightarrow> P (xs !! Suc j)", "case (Suc j)"], ["proof (state)\nthis:\n  \\<lbrakk>(holds P until holds Q) ?xs;\n   \\<forall>i\\<le>j. \\<not> Q (?xs !! i)\\<rbrakk>\n  \\<Longrightarrow> P (?xs !! j)\n  (holds P until holds Q) xs\n  \\<forall>i\\<le>Suc j. \\<not> Q (xs !! i)\n\ngoal (1 subgoal):\n 1. \\<And>j xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>(holds P until holds Q) xs;\n                    \\<forall>i\\<le>j. \\<not> Q (xs !! i)\\<rbrakk>\n                   \\<Longrightarrow> P (xs !! j);\n        (holds P until holds Q) xs;\n        \\<forall>i\\<le>Suc j. \\<not> Q (xs !! i)\\<rbrakk>\n       \\<Longrightarrow> P (xs !! Suc j)", "from Suc.prems"], ["proof (chain)\npicking this:\n  (holds P until holds Q) xs\n  \\<forall>i\\<le>Suc j. \\<not> Q (xs !! i)", "show ?case"], ["proof (prove)\nusing this:\n  (holds P until holds Q) xs\n  \\<forall>i\\<le>Suc j. \\<not> Q (xs !! i)\n\ngoal (1 subgoal):\n 1. P (xs !! Suc j)", "by cases (auto dest!: Suc.IH)"], ["proof (state)\nthis:\n  P (xs !! Suc j)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: Move *)"], ["", "lemma frac_le_self:\n  assumes \"x \\<ge> 0\"\n  shows \"frac x \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frac x \\<le> x", "using assms less_trans [of \"frac x\" 1 x]"], ["proof (prove)\nusing this:\n  (0::'a) \\<le> x\n  \\<lbrakk>frac x < (1::'a); (1::'a) < x\\<rbrakk>\n  \\<Longrightarrow> frac x < x\n\ngoal (1 subgoal):\n 1. frac x \\<le> x", "by (auto simp add: le_less frac_eq not_less frac_lt_1)"], ["", "lemma frac_le_1I:\n  assumes \"0 \\<le> x\" \"x \\<le> 1\" \"x \\<le> y\"\n  shows \"frac x \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frac x \\<le> y", "using assms dual_order.trans frac_le_self"], ["proof (prove)\nusing this:\n  (0::'a) \\<le> x\n  x \\<le> (1::'a)\n  x \\<le> y\n  \\<lbrakk>?b \\<le> ?a; ?c \\<le> ?b\\<rbrakk> \\<Longrightarrow> ?c \\<le> ?a\n  (0::?'a) \\<le> ?x \\<Longrightarrow> frac ?x \\<le> ?x\n\ngoal (1 subgoal):\n 1. frac x \\<le> y", "by auto"], ["", "lemma frac_le_1I':\n  assumes \"0 \\<le> x\" \"x \\<le> y\" \"y < 1\"\n  shows \"frac x \\<le> frac y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frac x \\<le> frac y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. frac x \\<le> frac y", "from assms"], ["proof (chain)\npicking this:\n  (0::'a) \\<le> x\n  x \\<le> y\n  y < (1::'a)", "have \"frac y = y\""], ["proof (prove)\nusing this:\n  (0::'a) \\<le> x\n  x \\<le> y\n  y < (1::'a)\n\ngoal (1 subgoal):\n 1. frac y = y", "by (simp add: frac_eq)"], ["proof (state)\nthis:\n  frac y = y\n\ngoal (1 subgoal):\n 1. frac x \\<le> frac y", "moreover"], ["proof (state)\nthis:\n  frac y = y\n\ngoal (1 subgoal):\n 1. frac x \\<le> frac y", "from assms"], ["proof (chain)\npicking this:\n  (0::'a) \\<le> x\n  x \\<le> y\n  y < (1::'a)", "have \"frac x \\<le> y\""], ["proof (prove)\nusing this:\n  (0::'a) \\<le> x\n  x \\<le> y\n  y < (1::'a)\n\ngoal (1 subgoal):\n 1. frac x \\<le> y", "by (auto intro: frac_le_1I)"], ["proof (state)\nthis:\n  frac x \\<le> y\n\ngoal (1 subgoal):\n 1. frac x \\<le> frac y", "ultimately"], ["proof (chain)\npicking this:\n  frac y = y\n  frac x \\<le> y", "show ?thesis"], ["proof (prove)\nusing this:\n  frac y = y\n  frac x \\<le> y\n\ngoal (1 subgoal):\n 1. frac x \\<le> frac y", "by simp"], ["proof (state)\nthis:\n  frac x \\<le> frac y\n\ngoal:\nNo subgoals!", "qed"], ["", "(* XXX Move *)"], ["", "lemmas [intro] = order.strict_implies_order[OF frac_lt_1]"], ["", "lemma nat_eventually_critical:\n  assumes \"P i\" \"\\<not> P j\" \"i < j\"\n  shows \"\\<exists> k \\<ge> i. P k \\<and> \\<not> P (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k\\<ge>i. P k \\<and> \\<not> P (Suc k)", "using assms"], ["proof (prove)\nusing this:\n  P i\n  \\<not> P j\n  i < j\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<ge>i. P k \\<and> \\<not> P (Suc k)", "by (metis dec_induct less_le)"], ["", "lemma nat_eventually_critical_path:\n  fixes i :: nat\n  assumes \"P i\" \"\\<not> P j\" \"i < j\"\n  shows \"\\<exists> k > i. k \\<le> j \\<and> \\<not> P k \\<and> (\\<forall> m \\<ge> i. m < k \\<longrightarrow> P m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k>i.\n       k \\<le> j \\<and>\n       \\<not> P k \\<and> (\\<forall>m\\<ge>i. m < k \\<longrightarrow> P m)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k>i.\n       k \\<le> j \\<and>\n       \\<not> P k \\<and> (\\<forall>m\\<ge>i. m < k \\<longrightarrow> P m)", "let ?S = \"{k. i < k \\<and> k \\<le> j \\<and> \\<not> P k}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k>i.\n       k \\<le> j \\<and>\n       \\<not> P k \\<and> (\\<forall>m\\<ge>i. m < k \\<longrightarrow> P m)", "let ?k = \"Min ?S\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k>i.\n       k \\<le> j \\<and>\n       \\<not> P k \\<and> (\\<forall>m\\<ge>i. m < k \\<longrightarrow> P m)", "from assms"], ["proof (chain)\npicking this:\n  P i\n  \\<not> P j\n  i < j", "have \"j \\<in> ?S\""], ["proof (prove)\nusing this:\n  P i\n  \\<not> P j\n  i < j\n\ngoal (1 subgoal):\n 1. j \\<in> {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k}", "by auto"], ["proof (state)\nthis:\n  j \\<in> {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k}\n\ngoal (1 subgoal):\n 1. \\<exists>k>i.\n       k \\<le> j \\<and>\n       \\<not> P k \\<and> (\\<forall>m\\<ge>i. m < k \\<longrightarrow> P m)", "moreover"], ["proof (state)\nthis:\n  j \\<in> {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k}\n\ngoal (1 subgoal):\n 1. \\<exists>k>i.\n       k \\<le> j \\<and>\n       \\<not> P k \\<and> (\\<forall>m\\<ge>i. m < k \\<longrightarrow> P m)", "have \"finite ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k}", "by auto"], ["proof (state)\nthis:\n  finite {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k}\n\ngoal (1 subgoal):\n 1. \\<exists>k>i.\n       k \\<le> j \\<and>\n       \\<not> P k \\<and> (\\<forall>m\\<ge>i. m < k \\<longrightarrow> P m)", "ultimately"], ["proof (chain)\npicking this:\n  j \\<in> {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k}\n  finite {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k}", "have \"i < ?k\" \"?k \\<le> j\" \"\\<not> P ?k\""], ["proof (prove)\nusing this:\n  j \\<in> {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k}\n  finite {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k}\n\ngoal (1 subgoal):\n 1. i < Min {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k} &&&\n    Min {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k} \\<le> j &&&\n    \\<not> P (Min {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k})", "using Min_in[of ?S]"], ["proof (prove)\nusing this:\n  j \\<in> {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k}\n  finite {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k}\n  \\<lbrakk>finite {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k};\n   {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k} \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> Min {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k}\n                    \\<in> {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k}\n\ngoal (1 subgoal):\n 1. i < Min {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k} &&&\n    Min {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k} \\<le> j &&&\n    \\<not> P (Min {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k})", "by blast+"], ["proof (state)\nthis:\n  i < Min {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k}\n  Min {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k} \\<le> j\n  \\<not> P (Min {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k})\n\ngoal (1 subgoal):\n 1. \\<exists>k>i.\n       k \\<le> j \\<and>\n       \\<not> P k \\<and> (\\<forall>m\\<ge>i. m < k \\<longrightarrow> P m)", "moreover"], ["proof (state)\nthis:\n  i < Min {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k}\n  Min {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k} \\<le> j\n  \\<not> P (Min {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k})\n\ngoal (1 subgoal):\n 1. \\<exists>k>i.\n       k \\<le> j \\<and>\n       \\<not> P k \\<and> (\\<forall>m\\<ge>i. m < k \\<longrightarrow> P m)", "have \"P m\" if \"i \\<le> m\" \"m < ?k\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. P m", "proof (cases \"i = m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = m \\<Longrightarrow> P m\n 2. i \\<noteq> m \\<Longrightarrow> P m", "case True"], ["proof (state)\nthis:\n  i = m\n\ngoal (2 subgoals):\n 1. i = m \\<Longrightarrow> P m\n 2. i \\<noteq> m \\<Longrightarrow> P m", "with \\<open>P i\\<close>"], ["proof (chain)\npicking this:\n  P i\n  i = m", "show ?thesis"], ["proof (prove)\nusing this:\n  P i\n  i = m\n\ngoal (1 subgoal):\n 1. P m", "by simp"], ["proof (state)\nthis:\n  P m\n\ngoal (1 subgoal):\n 1. i \\<noteq> m \\<Longrightarrow> P m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> m \\<Longrightarrow> P m", "case False"], ["proof (state)\nthis:\n  i \\<noteq> m\n\ngoal (1 subgoal):\n 1. i \\<noteq> m \\<Longrightarrow> P m", "with \\<open>i \\<le> m\\<close>"], ["proof (chain)\npicking this:\n  i \\<le> m\n  i \\<noteq> m", "have \"i < m\""], ["proof (prove)\nusing this:\n  i \\<le> m\n  i \\<noteq> m\n\ngoal (1 subgoal):\n 1. i < m", "by simp"], ["proof (state)\nthis:\n  i < m\n\ngoal (1 subgoal):\n 1. i \\<noteq> m \\<Longrightarrow> P m", "with Min_le[OF \\<open>finite _\\<close>] \\<open>m < ?k\\<close> \\<open>?k \\<le> j\\<close>"], ["proof (chain)\npicking this:\n  ?x \\<in> {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k} \\<Longrightarrow>\n  Min {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k} \\<le> ?x\n  m < Min {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k}\n  Min {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k} \\<le> j\n  i < m", "show ?thesis"], ["proof (prove)\nusing this:\n  ?x \\<in> {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k} \\<Longrightarrow>\n  Min {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k} \\<le> ?x\n  m < Min {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k}\n  Min {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k} \\<le> j\n  i < m\n\ngoal (1 subgoal):\n 1. P m", "by fastforce"], ["proof (state)\nthis:\n  P m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>i \\<le> ?m;\n   ?m < Min {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k}\\<rbrakk>\n  \\<Longrightarrow> P ?m\n\ngoal (1 subgoal):\n 1. \\<exists>k>i.\n       k \\<le> j \\<and>\n       \\<not> P k \\<and> (\\<forall>m\\<ge>i. m < k \\<longrightarrow> P m)", "ultimately"], ["proof (chain)\npicking this:\n  i < Min {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k}\n  Min {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k} \\<le> j\n  \\<not> P (Min {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k})\n  \\<lbrakk>i \\<le> ?m;\n   ?m < Min {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k}\\<rbrakk>\n  \\<Longrightarrow> P ?m", "show ?thesis"], ["proof (prove)\nusing this:\n  i < Min {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k}\n  Min {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k} \\<le> j\n  \\<not> P (Min {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k})\n  \\<lbrakk>i \\<le> ?m;\n   ?m < Min {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k}\\<rbrakk>\n  \\<Longrightarrow> P ?m\n\ngoal (1 subgoal):\n 1. \\<exists>k>i.\n       k \\<le> j \\<and>\n       \\<not> P k \\<and> (\\<forall>m\\<ge>i. m < k \\<longrightarrow> P m)", "using \\<open>P i\\<close>"], ["proof (prove)\nusing this:\n  i < Min {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k}\n  Min {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k} \\<le> j\n  \\<not> P (Min {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k})\n  \\<lbrakk>i \\<le> ?m;\n   ?m < Min {k. i < k \\<and> k \\<le> j \\<and> \\<not> P k}\\<rbrakk>\n  \\<Longrightarrow> P ?m\n  P i\n\ngoal (1 subgoal):\n 1. \\<exists>k>i.\n       k \\<le> j \\<and>\n       \\<not> P k \\<and> (\\<forall>m\\<ge>i. m < k \\<longrightarrow> P m)", "by - (rule exI[where x = ?k]; blast)"], ["proof (state)\nthis:\n  \\<exists>k>i.\n     k \\<le> j \\<and>\n     \\<not> P k \\<and> (\\<forall>m\\<ge>i. m < k \\<longrightarrow> P m)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>MDP Invariant\\<close>"], ["", "locale Markov_Decision_Process_Invariant =\n  Markov_Decision_Process K for K :: \"'s \\<Rightarrow> 's pmf set\"+\nfixes S :: \"'s set\"\nassumes invariant: \"\\<And> s D. s \\<in> S \\<Longrightarrow> D \\<in> K s \\<Longrightarrow> (\\<forall>s' \\<in> D. s' \\<in> S)\"\nbegin"], ["", "lemma E_invariant:\n  \"{s'. (s, s') \\<in> E} \\<subseteq> S\" if \"s \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {s'. (s, s') \\<in> E} \\<subseteq> S", "using that"], ["proof (prove)\nusing this:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. {s'. (s, s') \\<in> E} \\<subseteq> S", "by (auto dest: invariant simp: E_def)"], ["", "definition \"valid_cfg = (\\<Union>s\\<in>S. cfg_on s)\""], ["", "lemma valid_cfgI: \"s \\<in> S \\<Longrightarrow> cfg \\<in> cfg_on s \\<Longrightarrow> cfg \\<in> valid_cfg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> S; cfg \\<in> cfg_on s\\<rbrakk>\n    \\<Longrightarrow> cfg \\<in> valid_cfg", "by (auto simp: valid_cfg_def)"], ["", "lemma valid_cfgD: \"cfg \\<in> valid_cfg \\<Longrightarrow> cfg \\<in> cfg_on (state cfg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cfg \\<in> valid_cfg \\<Longrightarrow> cfg \\<in> cfg_on (state cfg)", "by (auto simp: valid_cfg_def)"], ["", "lemma action_closed: \"s \\<in> S \\<Longrightarrow> cfg \\<in> cfg_on s \\<Longrightarrow> t \\<in> action cfg \\<Longrightarrow> t \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> S; cfg \\<in> cfg_on s;\n     t \\<in> set_pmf (action cfg)\\<rbrakk>\n    \\<Longrightarrow> t \\<in> S", "using cfg_onD_action[of cfg s] invariant[of s]"], ["proof (prove)\nusing this:\n  cfg \\<in> cfg_on s \\<Longrightarrow> action cfg \\<in> K s\n  \\<lbrakk>s \\<in> S; ?D \\<in> K s\\<rbrakk>\n  \\<Longrightarrow> \\<forall>s'\\<in>set_pmf ?D. s' \\<in> S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> S; cfg \\<in> cfg_on s;\n     t \\<in> set_pmf (action cfg)\\<rbrakk>\n    \\<Longrightarrow> t \\<in> S", "by auto"], ["", "lemma\n  shows valid_cfg_state_in_S: \"cfg \\<in> valid_cfg \\<Longrightarrow> state cfg \\<in> S\"\n    and valid_cfg_action: \"cfg \\<in> valid_cfg \\<Longrightarrow> s \\<in> action cfg \\<Longrightarrow> s \\<in> S\"\n    and valid_cfg_cont: \"cfg \\<in> valid_cfg \\<Longrightarrow> s \\<in> action cfg \\<Longrightarrow> cont cfg s \\<in> valid_cfg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cfg \\<in> valid_cfg \\<Longrightarrow> state cfg \\<in> S) &&&\n    (\\<lbrakk>cfg \\<in> valid_cfg; s \\<in> set_pmf (action cfg)\\<rbrakk>\n     \\<Longrightarrow> s \\<in> S) &&&\n    (\\<lbrakk>cfg \\<in> valid_cfg; s \\<in> set_pmf (action cfg)\\<rbrakk>\n     \\<Longrightarrow> cont cfg s \\<in> valid_cfg)", "by (auto simp: valid_cfg_def intro!: bexI[of _ s] intro: action_closed)"], ["", "lemma valid_K_cfg[intro]: \"cfg \\<in> valid_cfg \\<Longrightarrow> cfg' \\<in> K_cfg cfg \\<Longrightarrow> cfg' \\<in> valid_cfg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cfg \\<in> valid_cfg; cfg' \\<in> set_pmf (K_cfg cfg)\\<rbrakk>\n    \\<Longrightarrow> cfg' \\<in> valid_cfg", "by (auto simp add: K_cfg_def valid_cfg_cont)"], ["", "lemma pred_stream_valid_cfg:\n  assumes valid: \"cfg \\<in> valid_cfg\"\n  assumes enabled: \"MC.enabled cfg xs\"\n  shows \"pred_stream (\\<lambda> cfg. cfg \\<in> valid_cfg) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>cfg. cfg \\<in> valid_cfg) xs", "using assms"], ["proof (prove)\nusing this:\n  cfg \\<in> valid_cfg\n  MC.enabled cfg xs\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>cfg. cfg \\<in> valid_cfg) xs", "by (coinduction arbitrary: cfg xs) (subst (asm) MC.enabled_iff; auto)"], ["", "lemma pred_stream_cfg_on:\n  assumes valid: \"cfg \\<in> valid_cfg\"\n  assumes enabled: \"MC.enabled cfg xs\"\n  shows \"pred_stream (\\<lambda> cfg. state cfg \\<in> S \\<and> cfg \\<in> cfg_on (state cfg)) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream\n     (\\<lambda>cfg. state cfg \\<in> S \\<and> cfg \\<in> cfg_on (state cfg))\n     xs", "using valid pred_stream_valid_cfg[OF _ enabled]"], ["proof (prove)\nusing this:\n  cfg \\<in> valid_cfg\n  cfg \\<in> valid_cfg \\<Longrightarrow>\n  pred_stream (\\<lambda>cfg. cfg \\<in> valid_cfg) xs\n\ngoal (1 subgoal):\n 1. pred_stream\n     (\\<lambda>cfg. state cfg \\<in> S \\<and> cfg \\<in> cfg_on (state cfg))\n     xs", "unfolding stream.pred_set"], ["proof (prove)\nusing this:\n  cfg \\<in> valid_cfg\n  cfg \\<in> valid_cfg \\<Longrightarrow>\n  \\<forall>cfg\\<in>sset xs. cfg \\<in> valid_cfg\n\ngoal (1 subgoal):\n 1. \\<forall>cfg\\<in>sset xs.\n       state cfg \\<in> S \\<and> cfg \\<in> cfg_on (state cfg)", "by (auto intro: valid_cfgI dest: valid_cfgD valid_cfg_state_in_S)"], ["", "lemma alw_S: \"almost_everywhere (T cfg) (pred_stream (\\<lambda>s. s \\<in> S))\" if \"cfg \\<in> valid_cfg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_everywhere (T cfg) (pred_stream (\\<lambda>s. s \\<in> S))", "unfolding T_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_everywhere (distr (MC.T cfg) St (smap state))\n     (pred_stream (\\<lambda>s. s \\<in> S))", "using pred_stream_cfg_on \\<open>cfg \\<in> valid_cfg\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?cfg \\<in> valid_cfg; MC.enabled ?cfg ?xs\\<rbrakk>\n  \\<Longrightarrow> pred_stream\n                     (\\<lambda>cfg.\n                         state cfg \\<in> S \\<and>\n                         cfg \\<in> cfg_on (state cfg))\n                     ?xs\n  cfg \\<in> valid_cfg\n\ngoal (1 subgoal):\n 1. almost_everywhere (distr (MC.T cfg) St (smap state))\n     (pred_stream (\\<lambda>s. s \\<in> S))", "by (subst AE_distr_iff) (measurable, auto simp: stream.pred_set intro: AE_mp[OF MC.AE_T_enabled])"], ["", "end"], ["", "context Finite_Markov_Decision_Process\nbegin"], ["", "sublocale Invariant: Markov_Decision_Process_Invariant\n  rewrites \"Invariant.valid_cfg = valid_cfg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Markov_Decision_Process_Invariant K S &&&\n    Markov_Decision_Process_Invariant.valid_cfg K S = valid_cfg", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. Markov_Decision_Process_Invariant K S\n 2. Markov_Decision_Process_Invariant.valid_cfg K S = valid_cfg", "show \"Markov_Decision_Process_Invariant K S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Markov_Decision_Process_Invariant K S", "by standard (auto dest: set_pmf_closed)"], ["proof (state)\nthis:\n  Markov_Decision_Process_Invariant K S\n\ngoal (1 subgoal):\n 1. Markov_Decision_Process_Invariant.valid_cfg K S = valid_cfg", "then"], ["proof (chain)\npicking this:\n  Markov_Decision_Process_Invariant K S", "show \"Markov_Decision_Process_Invariant.valid_cfg K S = valid_cfg\""], ["proof (prove)\nusing this:\n  Markov_Decision_Process_Invariant K S\n\ngoal (1 subgoal):\n 1. Markov_Decision_Process_Invariant.valid_cfg K S = valid_cfg", "by (subst Markov_Decision_Process_Invariant.valid_cfg_def; simp add: valid_cfg_def)"], ["proof (state)\nthis:\n  Markov_Decision_Process_Invariant.valid_cfg K S = valid_cfg\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas pred_stream_cfg_on = Invariant.pred_stream_cfg_on\n   and pred_stream_valid_cfg = Invariant.pred_stream_valid_cfg\n   and alw_S = Invariant.alw_S\n   and valid_cfg_state_in_S = Invariant.valid_cfg_state_in_S"], ["", "end"], ["", "end"]]}