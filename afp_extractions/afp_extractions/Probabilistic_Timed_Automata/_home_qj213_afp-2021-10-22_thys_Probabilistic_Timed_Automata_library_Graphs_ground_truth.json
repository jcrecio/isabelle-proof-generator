{"file_name": "/home/qj213/afp-2021-10-22/thys/Probabilistic_Timed_Automata/library/Graphs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Probabilistic_Timed_Automata", "problem_names": ["lemmas [intro] = steps.intros", "lemma steps_append:\n  \"steps (xs @ tl ys)\" if \"steps xs\" \"steps ys\" \"last xs = hd ys\"", "lemma steps_append':\n  \"steps xs\" if \"steps as\" \"steps bs\" \"last as = hd bs\" \"as @ tl bs = xs\"", "lemmas [intro] = run.intros", "lemma steps_appendD1:\n  \"steps xs\" if \"steps (xs @ ys)\" \"xs \\<noteq> []\"", "lemma steps_appendD2:\n  \"steps ys\" if \"steps (xs @ ys)\" \"ys \\<noteq> []\"", "lemma steps_appendD3:\n  \"steps (xs @ [x]) \\<and> E x y\" if \"steps (xs @ [x, y])\"", "lemma steps_ConsD:\n  \"steps xs\" if \"steps (x # xs)\" \"xs \\<noteq> []\"", "lemmas stepsD = steps_ConsD steps_appendD1 steps_appendD2", "lemma steps_alt_induct[consumes 1, case_names Single Snoc]:\n  assumes\n    \"steps x\" \"(\\<And>x. P [x])\"\n    \"\\<And>y x xs. E y x \\<Longrightarrow> steps (xs @ [y]) \\<Longrightarrow> P (xs @ [y]) \\<Longrightarrow> P (xs @ [y,x])\"\n  shows \"P x\"", "lemma steps_appendI:\n  \"steps (xs @ [x, y])\" if \"steps (xs @ [x])\" \"E x y\"", "lemma steps_append_single:\n  assumes\n    \"steps xs\" \"E (last xs) x\" \"xs \\<noteq> []\"\n  shows \"steps (xs @ [x])\"", "lemma extend_run:\n  assumes\n    \"steps xs\" \"E (last xs) x\" \"run (x ## ys)\" \"xs \\<noteq> []\"\n  shows \"run (xs @- x ## ys)\"", "lemma run_cycle:\n  assumes \"steps xs\" \"E (last xs) (hd xs)\" \"xs \\<noteq> []\"\n  shows \"run (cycle xs)\"", "lemma run_stl:\n  \"run (stl xs)\" if \"run xs\"", "lemma run_sdrop:\n  \"run (sdrop n xs)\" if \"run xs\"", "lemma run_reachable':\n  assumes \"run (x ## xs)\" \"E\\<^sup>*\\<^sup>* x\\<^sub>0 x\"\n  shows \"pred_stream (\\<lambda> x. E\\<^sup>*\\<^sup>* x\\<^sub>0 x) xs\"", "lemma run_reachable:\n  assumes \"run (x\\<^sub>0 ## xs)\"\n  shows \"pred_stream (\\<lambda> x. E\\<^sup>*\\<^sup>* x\\<^sub>0 x) xs\"", "lemma run_decomp:\n  assumes \"run (xs @- ys)\" \"xs \\<noteq> []\"\n  shows \"steps xs \\<and> run ys \\<and> E (last xs) (shd ys)\"", "lemma steps_decomp:\n  assumes \"steps (xs @ ys)\" \"xs \\<noteq> []\" \"ys \\<noteq> []\"\n  shows \"steps xs \\<and> steps ys \\<and> E (last xs) (hd ys)\"", "lemma steps_rotate:\n  assumes \"steps (x # xs @ y # ys @ [x])\"\n  shows \"steps (y # ys @ x # xs @ [y])\"", "lemma run_shift_coinduct[case_names run_shift, consumes 1]:\n  assumes \"R w\"\n      and \"\\<And> w. R w \\<Longrightarrow> \\<exists> u v x y. w = u @- x ## y ## v \\<and> steps (u @ [x]) \\<and> E x y \\<and> R (y ## v)\"\n  shows \"run w\"", "lemma run_flat_coinduct[case_names run_shift, consumes 1]:\n  assumes \"R xss\"\n    and\n    \"\\<And> xs ys xss.\n    R (xs ## ys ## xss) \\<Longrightarrow> xs \\<noteq> [] \\<and> steps xs \\<and> E (last xs) (hd ys) \\<and> R (ys ## xss)\"\n  shows \"run (flat xss)\"", "lemma steps_non_empty[simp]:\n  \"\\<not> steps []\"", "lemma steps_non_empty'[simp]:\n  \"xs \\<noteq> []\" if \"steps xs\"", "lemma steps_replicate:\n  \"steps (hd xs # concat (replicate n (tl xs)))\" if \"last xs = hd xs\" \"steps xs\" \"n > 0\"", "lemma steps_reaches:\n  \"hd xs \\<rightarrow>* last xs\" if \"steps xs\"", "lemma steps_reaches':\n  \"x \\<rightarrow>* y\" if \"steps xs\" \"hd xs = x\" \"last xs = y\"", "lemma reaches_steps:\n  \"\\<exists> xs. hd xs = x \\<and> last xs = y \\<and> steps xs\" if \"x \\<rightarrow>* y\"", "lemma reaches_steps_iff:\n  \"x \\<rightarrow>* y \\<longleftrightarrow> (\\<exists> xs. hd xs = x \\<and> last xs = y \\<and> steps xs)\"", "lemma steps_reaches1:\n  \"x \\<rightarrow>\\<^sup>+ y\" if \"steps (x # xs @ [y])\"", "lemma stepsI:\n  \"steps (x # xs)\" if \"x \\<rightarrow> hd xs\" \"steps xs\"", "lemma reaches1_steps:\n  \"\\<exists> xs. steps (x # xs @ [y])\" if \"x \\<rightarrow>\\<^sup>+ y\"", "lemma reaches1_steps_iff:\n  \"x \\<rightarrow>\\<^sup>+ y \\<longleftrightarrow> (\\<exists> xs. steps (x # xs @ [y]))\"", "lemma reaches1_reaches_iff1:\n  \"x \\<rightarrow>\\<^sup>+ y \\<longleftrightarrow> (\\<exists> z. x \\<rightarrow> z \\<and> z \\<rightarrow>* y)\"", "lemma reaches1_reaches_iff2:\n  \"x \\<rightarrow>\\<^sup>+ y \\<longleftrightarrow> (\\<exists> z. x \\<rightarrow>* z \\<and> z \\<rightarrow> y)\"", "lemma\n  \"x \\<rightarrow>\\<^sup>+ z\" if \"x \\<rightarrow>* y\" \"y \\<rightarrow>\\<^sup>+ z\"", "lemma\n  \"x \\<rightarrow>\\<^sup>+ z\" if \"x \\<rightarrow>\\<^sup>+ y\" \"y \\<rightarrow>* z\"", "lemma steps_append2:\n  \"steps (xs @ x # ys)\" if \"steps (xs @ [x])\" \"steps (x # ys)\"", "lemma reaches1_steps_append:\n  assumes \"a \\<rightarrow>\\<^sup>+ b\" \"steps xs\" \"hd xs = b\"\n  shows \"\\<exists> ys. steps (a # ys @ xs)\"", "lemma steps_last_step:\n  \"\\<exists> a. a \\<rightarrow> last xs\" if \"steps xs\" \"length xs > 1\"", "lemmas graphI =\n  steps.intros\n  steps_append_single\n  steps_reaches'\n  stepsI", "lemma start_reachable[intro!, simp]:\n  \"reachable s\\<^sub>0\"", "lemma reachable_step:\n  \"reachable b\" if \"reachable a\" \"E a b\"", "lemma reachable_reaches:\n  \"reachable b\" if \"reachable a\" \"a \\<rightarrow>* b\"", "lemma reachable_steps_append:\n  assumes \"reachable a\" \"steps xs\" \"hd xs = a\" \"last xs = b\"\n  shows \"reachable b\"", "lemmas steps_reachable = reachable_steps_append[of s\\<^sub>0, simplified]", "lemma reachable_steps_elem:\n  \"reachable y\" if \"reachable x\" \"steps xs\" \"y \\<in> set xs\" \"hd xs = x\"", "lemma reachable_steps:\n  \"\\<exists> xs. steps xs \\<and> hd xs = s\\<^sub>0 \\<and> last xs = x\" if \"reachable x\"", "lemma reachable_cycle_iff:\n  \"reachable x \\<and> x \\<rightarrow>\\<^sup>+ x \\<longleftrightarrow> (\\<exists> ws xs. steps (s\\<^sub>0 # ws @ [x] @ xs @ [x]))\"", "lemma reachable_induct[consumes 1, case_names start step, induct pred: reachable]:\n  assumes \"reachable x\"\n    and \"P s\\<^sub>0\"\n    and \"\\<And> a b. reachable a \\<Longrightarrow> P a \\<Longrightarrow> a \\<rightarrow> b \\<Longrightarrow> P b\"\n  shows \"P x\"", "lemmas graphI_aggressive =\n  tranclp_into_rtranclp\n  rtranclp.rtrancl_into_rtrancl\n  tranclp.trancl_into_trancl\n  rtranclp_into_tranclp2", "lemmas graphI_aggressive1 =\n  graphI_aggressive\n  steps_append'", "lemmas graphI_aggressive2 =\n  graphI_aggressive\n  stepsD\n  steps_reaches1\n  steps_reachable", "lemmas graphD =\n  reaches1_steps", "lemmas graphD_aggressive =\n  tranclpD", "lemmas graph_startI =\n  reachable_reaches\n  start_reachable", "lemma non_subgraph_cycle_decomp:\n  \"\\<exists> c d. G.reaches a c \\<and> E c d \\<and> \\<not> E' c d \\<and> G.reaches d b\" if\n  \"G.reaches1 a b\" \"\\<not> G'.reaches1 a b\" for a b", "lemma reaches:\n  \"G.reaches a b\" if \"G'.reaches a b\"", "lemma reaches1:\n  \"G.reaches1 a b\" if \"G'.reaches1 a b\"", "lemma reachable_subgraph[intro]: \"G.reachable b\" if \\<open>G.reachable a\\<close> \\<open>G'.reaches a b\\<close> for a b", "lemma reachable:\n  \"G.reachable x\" if \"G'.reachable x\"", "lemma subgraph':\n  \"E' x y\" if \"E x y\" \"V x\" \"V y\"", "lemma E'_V1:\n  \"V x\" if \"E' x y\"", "lemma E'_V2:\n  \"V y\" if \"E' x y\"", "lemma G'_reaches_V:\n  \"V y\" if \"G'.reaches x y\" \"V x\"", "lemma G'_steps_V_all:\n  \"list_all V xs\" if \"G'.steps xs\" \"V (hd xs)\"", "lemma G'_steps_V_last:\n  \"V (last xs)\" if \"G'.steps xs\" \"V (hd xs)\"", "lemmas subgraphI = E'_V1 E'_V2 G'_reaches_V", "lemmas subgraphD = E'_V1 E'_V2 G'_reaches_V", "lemma reachable_supgraph:\n  \"x \\<rightarrow> y\" if \"E x y\" \"reachable x\"", "lemma reachable_reaches_equiv: \"reaches x y \\<longleftrightarrow> x \\<rightarrow>* y\" if \"reachable x\" for x y", "lemma reachable_reaches1_equiv: \"reaches1 x y \\<longleftrightarrow> x \\<rightarrow>\\<^sup>+ y\" if \"reachable x\" for x y", "lemma reachable_steps_equiv:\n  \"steps (x # xs) \\<longleftrightarrow> G'.steps (x # xs)\" if \"reachable x\"", "lemmas [intro] = Graph_Defs.graphI Graph_Start_Defs.graph_startI", "lemmas [dest]  = Graph_Start_Defs.graphD", "lemmas [intro] = Graph_Start_Defs.graphI_aggressive", "lemmas [dest]  = Graph_Start_Defs.graphD_aggressive", "lemmas [intro] = Subgraph_Node_Defs.subgraphI", "lemmas [dest]  = Subgraph_Node_Defs.subgraphD", "lemma invariant_steps:\n  \"list_all P as\" if \"steps (a # as)\" \"P a\"", "lemma invariant_reaches:\n  \"P b\" if \"a \\<rightarrow>* b\" \"P a\"", "lemma invariant_run:\n  assumes run: \"run (x ## xs)\" and P: \"P x\"\n  shows \"pred_stream P (x ## xs)\"", "lemma invariant_steps:\n  \"list_all Q as\" if \"steps (a # as)\" \"P a\"", "lemma invariant_run:\n  assumes run: \"run (x ## xs)\" and P: \"P x\"\n  shows \"pred_stream Q xs\"", "lemma invariant_reaches1:\n  \"Q b\" if \"a \\<rightarrow>\\<^sup>+ b\" \"P a\"", "lemma invariant_steps:\n  \"list_all P as\" if \"steps (s\\<^sub>0 # as)\"", "lemma invariant_reaches:\n  \"P b\" if \"s\\<^sub>0 \\<rightarrow>* b\"", "lemmas invariant_run = invariant_run[OF _ P_s\\<^sub>0]", "lemma P_invariant_steps:\n  \"list_all P as\" if \"steps (a # as)\"", "lemma steps_last_invariant:\n  \"P (last xs)\" if \"steps (x # xs)\" \"xs \\<noteq> []\"", "lemmas invariant_reaches = inv.invariant_reaches", "lemma invariant_reaches1:\n  \"P b\" if \"a \\<rightarrow>\\<^sup>+ b\"", "lemma simulation_reaches:\n  \"\\<exists> b'. B\\<^sup>*\\<^sup>* b b' \\<and> a' \\<sim> b'\" if \"A\\<^sup>*\\<^sup>* a a'\" \"a \\<sim> b\"", "lemma simulation_reaches1:\n  \"\\<exists> b'. B\\<^sup>+\\<^sup>+ b b' \\<and> a' \\<sim> b'\" if \"A\\<^sup>+\\<^sup>+ a a'\" \"a \\<sim> b\"", "lemma simulation_steps:\n  \"\\<exists> bs. B.steps (b # bs) \\<and> list_all2 (\\<lambda> a b. a \\<sim> b) as bs\" if \"A.steps (a # as)\" \"a \\<sim> b\"", "lemma simulation_run:\n  \"\\<exists> ys. B.run (y ## ys) \\<and> stream_all2 (\\<sim>) xs ys\" if \"A.run (x ## xs)\" \"x \\<sim> y\"", "lemma (in Subgraph) Subgraph_Simulation:\n  \"Simulation E' E (=)\"", "lemma simulation_reaches:\n  \"\\<exists> b'. B\\<^sup>*\\<^sup>* b b' \\<and> a' \\<sim> b' \\<and> PA a' \\<and> PB b'\" if \"A\\<^sup>*\\<^sup>* a a'\" \"a \\<sim> b\" \"PA a\" \"PB b\"", "lemma simulation_steps:\n  \"\\<exists> bs. B.steps (b # bs) \\<and> list_all2 (\\<lambda> a b. a \\<sim> b \\<and> PA a \\<and> PB b) as bs\"\n  if \"A.steps (a # as)\" \"a \\<sim> b\" \"PA a\" \"PB b\"", "lemma simulation_steps':\n  \"\\<exists> bs. B.steps (b # bs) \\<and> list_all2 (\\<lambda> a b. a \\<sim> b) as bs \\<and> list_all PA as \\<and> list_all PB bs\"\n  if \"A.steps (a # as)\" \"a \\<sim> b\" \"PA a\" \"PB b\"", "lemma simulation_steps'_map:\n  \"\\<exists> bs.\n    B.steps (b # bs) \\<and> bs = map f as\n    \\<and> list_all2 (\\<lambda> a b. a \\<sim> b) as bs\n    \\<and> list_all PA as \\<and> list_all PB bs\"\n  if \"A.steps (a # as)\" \"a \\<sim> b\" \"PA a\" \"PB b\"", "lemma simulation_reaches1:\n  \"\\<exists> b2. B.reaches1 b1 b2 \\<and> a2 \\<sim> b2 \\<and> QB b2\" if \"A.reaches1 a1 a2\" \"a1 \\<sim> b1\" \"PA a1\" \"PB b1\"", "lemma reaches1_unique:\n  assumes unique: \"\\<And> b2. a \\<sim> b2 \\<Longrightarrow> QB b2 \\<Longrightarrow> b2 = b\"\n    and that: \"A.reaches1 a a\" \"a \\<sim> b\" \"PA a\" \"PB b\"\n  shows \"B.reaches1 b b\"", "lemma A_B_reaches:\n  \"\\<exists> b'. B\\<^sup>*\\<^sup>* b b' \\<and> a' \\<sim> b'\" if \"A\\<^sup>*\\<^sup>* a a'\" \"a \\<sim> b\"", "lemma B_A_reaches:\n  \"\\<exists> b'. A\\<^sup>*\\<^sup>* b b' \\<and> b' \\<sim> a'\" if \"B\\<^sup>*\\<^sup>* a a'\" \"b \\<sim> a\"", "lemmas B_steps_invariant[intro] = PB_invariant.invariant_reaches", "lemma list_all2_inj_map_eq:\n  \"as = bs\" if \"list_all2 (\\<lambda>a b. a = f b) (map f as) bs\" \"list_all PB (map f as)\" \"list_all PA bs\"", "lemma steps_map_equiv:\n  \"A.steps (a # as) \\<longleftrightarrow> B.steps (b # map f as)\" if \"a \\<sim> b\" \"PA a\" \"PB b\"", "lemma steps_map:\n  \"\\<exists> as. bs = map f as\" if \"B.steps (f a # bs)\" \"PA a\" \"PB (f a)\"", "lemma reaches_equiv:\n  \"A.reaches a a' \\<longleftrightarrow> B.reaches (f a) (f a')\" if \"PA a\" \"PB (f a)\"", "lemma equiv'_D:\n  \"a \\<sim> b\" if \"A_B.equiv' a b\"", "lemma equiv'_rotate_1:\n  \"B_A.equiv' b a\" if \"A_B.equiv' a b\"", "lemma equiv'_rotate_2:\n  \"A_B.equiv' a b\" if \"B_A.equiv' b a\"", "lemma stream_all2_equiv'_D:\n  \"stream_all2 (\\<sim>) xs ys\" if \"stream_all2 A_B.equiv' xs ys\"", "lemma stream_all2_equiv'_D2:\n  \"stream_all2 B_A.equiv' ys xs \\<Longrightarrow> stream_all2 (\\<sim>)\\<inverse>\\<inverse> ys xs\"", "lemma stream_all2_rotate_1:\n  \"stream_all2 B_A.equiv' ys xs \\<Longrightarrow> stream_all2 A_B.equiv' xs ys\"", "lemma stream_all2_rotate_2:\n  \"stream_all2 A_B.equiv' xs ys \\<Longrightarrow> stream_all2 B_A.equiv' ys xs\"", "lemmas list_all2_inj_map_eq = Post_Bisim.list_all2_inj_map_eq[OF eq inj]", "lemmas steps_map_equiv' = Post_Bisim.steps_map_equiv[OF eq inj]", "lemma list_all2_inj_map_eq':\n  \"as = bs\" if \"list_all2 (\\<lambda>a b. a = f b) (map f as) bs\" \"list_all QB (map f as)\" \"list_all QA bs\"", "lemma steps_map_equiv:\n  \"A.steps (a # as) \\<longleftrightarrow> B.steps (b # map f as)\" if \"a \\<sim> b\" \"PA a\" \"PB b\"", "lemma steps_map:\n  \"\\<exists> as. bs = map f as\" if \"B.steps (f a # bs)\" \"PA a\" \"PB (f a)\"", "lemma reaches1_equiv:\n  \"A.reaches1 a a' \\<longleftrightarrow> B.reaches1 (f a) (f a')\" if \"PA a\" \"PB (f a)\"", "lemma Bisimulation_Invariant_composition:\n  assumes\n    \"Bisimulation_Invariant A B sim1 PA PB\"\n    \"Bisimulation_Invariant B C sim2 PB PC\"\n  shows\n    \"Bisimulation_Invariant A C (\\<lambda> a c. \\<exists> b. PB b \\<and> sim1 a b \\<and> sim2 b c) PA PC\"", "lemma Bisimulation_Invariant_filter:\n  assumes\n    \"Bisimulation_Invariant A B sim PA PB\"\n    \"\\<And> a b. sim a b \\<Longrightarrow> PA a \\<Longrightarrow> PB b \\<Longrightarrow> FA a \\<longleftrightarrow> FB b\"\n    \"\\<And> a b. A a b \\<and> FA b \\<longleftrightarrow> A' a b\"\n    \"\\<And> a b. B a b \\<and> FB b \\<longleftrightarrow> B' a b\"\n  shows\n    \"Bisimulation_Invariant A' B' sim PA PB\"", "lemma Bisimulation_Invariants_filter:\n  assumes\n    \"Bisimulation_Invariants A B sim PA QA PB QB\"\n    \"\\<And> a b. QA a \\<Longrightarrow> QB b \\<Longrightarrow> FA a \\<longleftrightarrow> FB b\"\n    \"\\<And> a b. A a b \\<and> FA b \\<longleftrightarrow> A' a b\"\n    \"\\<And> a b. B a b \\<and> FB b \\<longleftrightarrow> B' a b\"\n  shows\n    \"Bisimulation_Invariants A' B' sim PA QA PB QB\"", "lemma Bisimulation_Invariants_composition:\n  assumes\n    \"Bisimulation_Invariants A B sim1 PA QA PB QB\"\n    \"Bisimulation_Invariants B C sim2 PB QB PC QC\"\n  shows\n    \"Bisimulation_Invariants A C (\\<lambda> a c. \\<exists> b. PB b \\<and> sim1 a b \\<and> sim2 b c) PA QA PC QC\"", "lemma Bisimulation_Invariant_Invariants_composition:\n  assumes\n    \"Bisimulation_Invariant A B sim1 PA PB\"\n    \"Bisimulation_Invariants B C sim2 PB QB PC QC\"\n  shows\n    \"Bisimulation_Invariants A C (\\<lambda> a c. \\<exists> b. PB b \\<and> sim1 a b \\<and> sim2 b c) PA PA PC QC\"", "lemma Bisimulation_Invariant_Bisimulation_Invariants:\n  assumes \"Bisimulation_Invariant A B sim PA PB\"\n  shows \"Bisimulation_Invariants A B sim PA PA PB PB\"", "lemma Bisimulation_Invariant_strengthen_post:\n  assumes\n    \"Bisimulation_Invariant A B sim PA PB\"\n    \"\\<And> a b. PA' a \\<Longrightarrow> PA b \\<Longrightarrow> A a b \\<Longrightarrow> PA' b\"\n    \"\\<And> a. PA' a \\<Longrightarrow> PA a\"\n  shows \"Bisimulation_Invariant A B sim PA' PB\"", "lemma Bisimulation_Invariant_strengthen_post':\n  assumes\n    \"Bisimulation_Invariant A B sim PA PB\"\n    \"\\<And> a b. PB' a \\<Longrightarrow> PB b \\<Longrightarrow> B a b \\<Longrightarrow> PB' b\"\n    \"\\<And> a. PB' a \\<Longrightarrow> PB a\"\n  shows \"Bisimulation_Invariant A B sim PA PB'\"", "lemma Simulation_Invariant_strengthen_post:\n  assumes\n    \"Simulation_Invariant A B sim PA PB\"\n    \"\\<And> a b. PA a \\<Longrightarrow> PA b \\<Longrightarrow> A a b \\<Longrightarrow> PA' b\"\n    \"\\<And> a. PA' a \\<Longrightarrow> PA a\"\n  shows \"Simulation_Invariant A B sim PA' PB\"", "lemma Simulation_Invariant_strengthen_post':\n  assumes\n    \"Simulation_Invariant A B sim PA PB\"\n    \"\\<And> a b. PB a \\<Longrightarrow> PB b \\<Longrightarrow> B a b \\<Longrightarrow> PB' b\"\n    \"\\<And> a. PB' a \\<Longrightarrow> PB a\"\n  shows \"Simulation_Invariant A B sim PA PB'\"", "lemma Simulation_Invariants_strengthen_post:\n  assumes\n    \"Simulation_Invariants A B sim PA QA PB QB\"\n    \"\\<And> a b. PA a \\<Longrightarrow> QA b \\<Longrightarrow> A a b \\<Longrightarrow> QA' b\"\n    \"\\<And> a. QA' a \\<Longrightarrow> QA a\"\n  shows \"Simulation_Invariants A B sim PA QA' PB QB\"", "lemma Simulation_Invariants_strengthen_post':\n  assumes\n    \"Simulation_Invariants A B sim PA QA PB QB\"\n    \"\\<And> a b. PB a \\<Longrightarrow> QB b \\<Longrightarrow> B a b \\<Longrightarrow> QB' b\"\n    \"\\<And> a. QB' a \\<Longrightarrow> QB a\"\n  shows \"Simulation_Invariants A B sim PA QA PB QB'\"", "lemma Bisimulation_Invariant_sim_replace:\n  assumes \"Bisimulation_Invariant A B sim PA PB\"\n      and \"\\<And> a b. PA a \\<Longrightarrow> PB b \\<Longrightarrow> sim a b \\<longleftrightarrow> sim' a b\"\n    shows \"Bisimulation_Invariant A B sim' PA PB\""], "translations": [["", "lemmas [intro] = steps.intros"], ["", "lemma steps_append:\n  \"steps (xs @ tl ys)\" if \"steps xs\" \"steps ys\" \"last xs = hd ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps (xs @ tl ys)", "using that"], ["proof (prove)\nusing this:\n  steps xs\n  steps ys\n  last xs = hd ys\n\ngoal (1 subgoal):\n 1. steps (xs @ tl ys)", "by induction (auto 4 4 elim: steps.cases)"], ["", "lemma steps_append':\n  \"steps xs\" if \"steps as\" \"steps bs\" \"last as = hd bs\" \"as @ tl bs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps xs", "using steps_append that"], ["proof (prove)\nusing this:\n  \\<lbrakk>steps ?xs; steps ?ys; last ?xs = hd ?ys\\<rbrakk>\n  \\<Longrightarrow> steps (?xs @ tl ?ys)\n  steps as\n  steps bs\n  last as = hd bs\n  as @ tl bs = xs\n\ngoal (1 subgoal):\n 1. steps xs", "by blast"], ["", "coinductive run where\n  \"run (x ## y ## xs)\" if \"E x y\" \"run (y ## xs)\""], ["", "lemmas [intro] = run.intros"], ["", "lemma steps_appendD1:\n  \"steps xs\" if \"steps (xs @ ys)\" \"xs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps xs", "using that"], ["proof (prove)\nusing this:\n  steps (xs @ ys)\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. steps xs", "proof (induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>steps ([] @ ys); [] \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> steps []\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>steps (xs @ ys); xs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> steps xs;\n        steps ((a # xs) @ ys); a # xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> steps (a # xs)", "case Nil"], ["proof (state)\nthis:\n  steps ([] @ ys)\n  [] \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>steps ([] @ ys); [] \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> steps []\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>steps (xs @ ys); xs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> steps xs;\n        steps ((a # xs) @ ys); a # xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> steps (a # xs)", "then"], ["proof (chain)\npicking this:\n  steps ([] @ ys)\n  [] \\<noteq> []", "show ?case"], ["proof (prove)\nusing this:\n  steps ([] @ ys)\n  [] \\<noteq> []\n\ngoal (1 subgoal):\n 1. steps []", "by auto"], ["proof (state)\nthis:\n  steps []\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>steps (xs @ ys); xs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> steps xs;\n        steps ((a # xs) @ ys); a # xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> steps (a # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>steps (xs @ ys); xs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> steps xs;\n        steps ((a # xs) @ ys); a # xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> steps (a # xs)", "case (Cons a xs)"], ["proof (state)\nthis:\n  \\<lbrakk>steps (xs @ ys); xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> steps xs\n  steps ((a # xs) @ ys)\n  a # xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>steps (xs @ ys); xs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> steps xs;\n        steps ((a # xs) @ ys); a # xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> steps (a # xs)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>steps (xs @ ys); xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> steps xs\n  steps ((a # xs) @ ys)\n  a # xs \\<noteq> []", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>steps (xs @ ys); xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> steps xs\n  steps ((a # xs) @ ys)\n  a # xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. steps (a # xs)", "by - (cases xs; auto elim: steps.cases)"], ["proof (state)\nthis:\n  steps (a # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma steps_appendD2:\n  \"steps ys\" if \"steps (xs @ ys)\" \"ys \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps ys", "using that"], ["proof (prove)\nusing this:\n  steps (xs @ ys)\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. steps ys", "by (induction xs) (auto elim: steps.cases)"], ["", "lemma steps_appendD3:\n  \"steps (xs @ [x]) \\<and> E x y\" if \"steps (xs @ [x, y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps (xs @ [x]) \\<and> E x y", "using that"], ["proof (prove)\nusing this:\n  steps (xs @ [x, y])\n\ngoal (1 subgoal):\n 1. steps (xs @ [x]) \\<and> E x y", "proof (induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. steps ([] @ [x, y]) \\<Longrightarrow> steps ([] @ [x]) \\<and> E x y\n 2. \\<And>a xs.\n       \\<lbrakk>steps (xs @ [x, y]) \\<Longrightarrow>\n                steps (xs @ [x]) \\<and> E x y;\n        steps ((a # xs) @ [x, y])\\<rbrakk>\n       \\<Longrightarrow> steps ((a # xs) @ [x]) \\<and> E x y", "case Nil"], ["proof (state)\nthis:\n  steps ([] @ [x, y])\n\ngoal (2 subgoals):\n 1. steps ([] @ [x, y]) \\<Longrightarrow> steps ([] @ [x]) \\<and> E x y\n 2. \\<And>a xs.\n       \\<lbrakk>steps (xs @ [x, y]) \\<Longrightarrow>\n                steps (xs @ [x]) \\<and> E x y;\n        steps ((a # xs) @ [x, y])\\<rbrakk>\n       \\<Longrightarrow> steps ((a # xs) @ [x]) \\<and> E x y", "then"], ["proof (chain)\npicking this:\n  steps ([] @ [x, y])", "show ?case"], ["proof (prove)\nusing this:\n  steps ([] @ [x, y])\n\ngoal (1 subgoal):\n 1. steps ([] @ [x]) \\<and> E x y", "by (auto elim!: steps.cases)"], ["proof (state)\nthis:\n  steps ([] @ [x]) \\<and> E x y\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>steps (xs @ [x, y]) \\<Longrightarrow>\n                steps (xs @ [x]) \\<and> E x y;\n        steps ((a # xs) @ [x, y])\\<rbrakk>\n       \\<Longrightarrow> steps ((a # xs) @ [x]) \\<and> E x y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>steps (xs @ [x, y]) \\<Longrightarrow>\n                steps (xs @ [x]) \\<and> E x y;\n        steps ((a # xs) @ [x, y])\\<rbrakk>\n       \\<Longrightarrow> steps ((a # xs) @ [x]) \\<and> E x y", "case prems: (Cons a xs)"], ["proof (state)\nthis:\n  steps (xs @ [x, y]) \\<Longrightarrow> steps (xs @ [x]) \\<and> E x y\n  steps ((a # xs) @ [x, y])\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>steps (xs @ [x, y]) \\<Longrightarrow>\n                steps (xs @ [x]) \\<and> E x y;\n        steps ((a # xs) @ [x, y])\\<rbrakk>\n       \\<Longrightarrow> steps ((a # xs) @ [x]) \\<and> E x y", "then"], ["proof (chain)\npicking this:\n  steps (xs @ [x, y]) \\<Longrightarrow> steps (xs @ [x]) \\<and> E x y\n  steps ((a # xs) @ [x, y])", "show ?case"], ["proof (prove)\nusing this:\n  steps (xs @ [x, y]) \\<Longrightarrow> steps (xs @ [x]) \\<and> E x y\n  steps ((a # xs) @ [x, y])\n\ngoal (1 subgoal):\n 1. steps ((a # xs) @ [x]) \\<and> E x y", "by (cases xs) (auto elim: steps.cases)"], ["proof (state)\nthis:\n  steps ((a # xs) @ [x]) \\<and> E x y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma steps_ConsD:\n  \"steps xs\" if \"steps (x # xs)\" \"xs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps xs", "using that"], ["proof (prove)\nusing this:\n  steps (x # xs)\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. steps xs", "by (auto elim: steps.cases)"], ["", "lemmas stepsD = steps_ConsD steps_appendD1 steps_appendD2"], ["", "lemma steps_alt_induct[consumes 1, case_names Single Snoc]:\n  assumes\n    \"steps x\" \"(\\<And>x. P [x])\"\n    \"\\<And>y x xs. E y x \\<Longrightarrow> steps (xs @ [y]) \\<Longrightarrow> P (xs @ [y]) \\<Longrightarrow> P (xs @ [y,x])\"\n  shows \"P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x", "using assms(1)"], ["proof (prove)\nusing this:\n  steps x\n\ngoal (1 subgoal):\n 1. P x", "proof (induction rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. steps [] \\<Longrightarrow> P []\n 2. \\<And>x xs.\n       \\<lbrakk>steps xs \\<Longrightarrow> P xs; steps (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> P (xs @ [x])", "case Nil"], ["proof (state)\nthis:\n  steps []\n\ngoal (2 subgoals):\n 1. steps [] \\<Longrightarrow> P []\n 2. \\<And>x xs.\n       \\<lbrakk>steps xs \\<Longrightarrow> P xs; steps (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> P (xs @ [x])", "then"], ["proof (chain)\npicking this:\n  steps []", "show ?case"], ["proof (prove)\nusing this:\n  steps []\n\ngoal (1 subgoal):\n 1. P []", "by (auto elim: steps.cases)"], ["proof (state)\nthis:\n  P []\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>steps xs \\<Longrightarrow> P xs; steps (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> P (xs @ [x])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>steps xs \\<Longrightarrow> P xs; steps (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> P (xs @ [x])", "case prems: (snoc x xs)"], ["proof (state)\nthis:\n  steps xs \\<Longrightarrow> P xs\n  steps (xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>steps xs \\<Longrightarrow> P xs; steps (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> P (xs @ [x])", "then"], ["proof (chain)\npicking this:\n  steps xs \\<Longrightarrow> P xs\n  steps (xs @ [x])", "show ?case"], ["proof (prove)\nusing this:\n  steps xs \\<Longrightarrow> P xs\n  steps (xs @ [x])\n\ngoal (1 subgoal):\n 1. P (xs @ [x])", "by (cases xs rule: rev_cases) (auto intro: assms(2,3) dest!: steps_appendD3)"], ["proof (state)\nthis:\n  P (xs @ [x])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma steps_appendI:\n  \"steps (xs @ [x, y])\" if \"steps (xs @ [x])\" \"E x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps (xs @ [x, y])", "using that"], ["proof (prove)\nusing this:\n  steps (xs @ [x])\n  E x y\n\ngoal (1 subgoal):\n 1. steps (xs @ [x, y])", "proof (induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>steps ([] @ [x]); E x y\\<rbrakk>\n    \\<Longrightarrow> steps ([] @ [x, y])\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>steps (xs @ [x]); E x y\\<rbrakk>\n                \\<Longrightarrow> steps (xs @ [x, y]);\n        steps ((a # xs) @ [x]); E x y\\<rbrakk>\n       \\<Longrightarrow> steps ((a # xs) @ [x, y])", "case Nil"], ["proof (state)\nthis:\n  steps ([] @ [x])\n  E x y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>steps ([] @ [x]); E x y\\<rbrakk>\n    \\<Longrightarrow> steps ([] @ [x, y])\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>steps (xs @ [x]); E x y\\<rbrakk>\n                \\<Longrightarrow> steps (xs @ [x, y]);\n        steps ((a # xs) @ [x]); E x y\\<rbrakk>\n       \\<Longrightarrow> steps ((a # xs) @ [x, y])", "then"], ["proof (chain)\npicking this:\n  steps ([] @ [x])\n  E x y", "show ?case"], ["proof (prove)\nusing this:\n  steps ([] @ [x])\n  E x y\n\ngoal (1 subgoal):\n 1. steps ([] @ [x, y])", "by auto"], ["proof (state)\nthis:\n  steps ([] @ [x, y])\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>steps (xs @ [x]); E x y\\<rbrakk>\n                \\<Longrightarrow> steps (xs @ [x, y]);\n        steps ((a # xs) @ [x]); E x y\\<rbrakk>\n       \\<Longrightarrow> steps ((a # xs) @ [x, y])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>steps (xs @ [x]); E x y\\<rbrakk>\n                \\<Longrightarrow> steps (xs @ [x, y]);\n        steps ((a # xs) @ [x]); E x y\\<rbrakk>\n       \\<Longrightarrow> steps ((a # xs) @ [x, y])", "case (Cons a xs)"], ["proof (state)\nthis:\n  \\<lbrakk>steps (xs @ [x]); E x y\\<rbrakk>\n  \\<Longrightarrow> steps (xs @ [x, y])\n  steps ((a # xs) @ [x])\n  E x y\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>steps (xs @ [x]); E x y\\<rbrakk>\n                \\<Longrightarrow> steps (xs @ [x, y]);\n        steps ((a # xs) @ [x]); E x y\\<rbrakk>\n       \\<Longrightarrow> steps ((a # xs) @ [x, y])", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>steps (xs @ [x]); E x y\\<rbrakk>\n  \\<Longrightarrow> steps (xs @ [x, y])\n  steps ((a # xs) @ [x])\n  E x y", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>steps (xs @ [x]); E x y\\<rbrakk>\n  \\<Longrightarrow> steps (xs @ [x, y])\n  steps ((a # xs) @ [x])\n  E x y\n\ngoal (1 subgoal):\n 1. steps ((a # xs) @ [x, y])", "by (cases xs; auto elim: steps.cases)"], ["proof (state)\nthis:\n  steps ((a # xs) @ [x, y])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma steps_append_single:\n  assumes\n    \"steps xs\" \"E (last xs) x\" \"xs \\<noteq> []\"\n  shows \"steps (xs @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps (xs @ [x])", "using assms(3,1,2)"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  steps xs\n  E (last xs) x\n\ngoal (1 subgoal):\n 1. steps (xs @ [x])", "by (induction xs rule: list_nonempty_induct) (auto 4 4 elim: steps.cases)"], ["", "lemma extend_run:\n  assumes\n    \"steps xs\" \"E (last xs) x\" \"run (x ## ys)\" \"xs \\<noteq> []\"\n  shows \"run (xs @- x ## ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run (xs @- x ## ys)", "using assms(4,1-3)"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  steps xs\n  E (last xs) x\n  run (x ## ys)\n\ngoal (1 subgoal):\n 1. run (xs @- x ## ys)", "by (induction xs rule: list_nonempty_induct) (auto 4 3 elim: steps.cases)"], ["", "lemma run_cycle:\n  assumes \"steps xs\" \"E (last xs) (hd xs)\" \"xs \\<noteq> []\"\n  shows \"run (cycle xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run (cycle xs)", "using assms"], ["proof (prove)\nusing this:\n  steps xs\n  E (last xs) (hd xs)\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. run (cycle xs)", "proof (coinduction arbitrary: xs)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>steps xs; E (last xs) (hd xs); xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y xsa.\n                            cycle xs = x ## y ## xsa \\<and>\n                            E x y \\<and>\n                            ((\\<exists>xs.\n                                 y ## xsa = cycle xs \\<and>\n                                 steps xs \\<and>\n                                 E (last xs) (hd xs) \\<and>\n                                 xs \\<noteq> []) \\<or>\n                             run (y ## xsa))", "case run"], ["proof (state)\nthis:\n  steps xs\n  E (last xs) (hd xs)\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>steps xs; E (last xs) (hd xs); xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y xsa.\n                            cycle xs = x ## y ## xsa \\<and>\n                            E x y \\<and>\n                            ((\\<exists>xs.\n                                 y ## xsa = cycle xs \\<and>\n                                 steps xs \\<and>\n                                 E (last xs) (hd xs) \\<and>\n                                 xs \\<noteq> []) \\<or>\n                             run (y ## xsa))", "then"], ["proof (chain)\npicking this:\n  steps xs\n  E (last xs) (hd xs)\n  xs \\<noteq> []", "show ?case"], ["proof (prove)\nusing this:\n  steps xs\n  E (last xs) (hd xs)\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>x y xs.\n       cycle xs = x ## y ## xs \\<and>\n       E x y \\<and>\n       ((\\<exists>xsa.\n            y ## xs = cycle xsa \\<and>\n            steps xsa \\<and>\n            E (last xsa) (hd xsa) \\<and> xsa \\<noteq> []) \\<or>\n        run (y ## xs))", "apply (rewrite at \\<open>cycle xs\\<close> stream.collapse[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>steps xs; E (last xs) (hd xs); xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x y xs.\n                         shd (cycle xs) ## stl (cycle xs) =\n                         x ## y ## xs \\<and>\n                         E x y \\<and>\n                         ((\\<exists>xsa.\n                              y ## xs = cycle xsa \\<and>\n                              steps xsa \\<and>\n                              E (last xsa) (hd xsa) \\<and>\n                              xsa \\<noteq> []) \\<or>\n                          run (y ## xs))", "apply (rewrite at \\<open>stl (cycle xs)\\<close> stream.collapse[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>steps xs; E (last xs) (hd xs); xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x y xs.\n                         shd (cycle xs) ##\n                         shd (stl (cycle xs)) ## stl (stl (cycle xs)) =\n                         x ## y ## xs \\<and>\n                         E x y \\<and>\n                         ((\\<exists>xsa.\n                              y ## xs = cycle xsa \\<and>\n                              steps xsa \\<and>\n                              E (last xsa) (hd xsa) \\<and>\n                              xsa \\<noteq> []) \\<or>\n                          run (y ## xs))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>steps xs; E (last xs) (hd xs); xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> E (hd xs) (hd (tl xs @ [hd xs])) \\<and>\n                      ((\\<exists>xs.\n                           hd (tl xs @ [hd xs]) ##\n                           cycle\n                            (tl (tl xs @ [hd xs]) @\n                             [hd (tl xs @ [hd xs])]) =\n                           cycle xs \\<and>\n                           steps xs \\<and>\n                           E (last xs) (hd xs) \\<and> xs \\<noteq> []) \\<or>\n                       run (hd (tl xs @ [hd xs]) ##\n                            cycle\n                             (tl (tl xs @ [hd xs]) @\n                              [hd (tl xs @ [hd xs])])))", "apply (erule steps.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>E (last xs) (hd xs); xs \\<noteq> []; xs = [x]\\<rbrakk>\n       \\<Longrightarrow> E (hd xs) (hd (tl xs @ [hd xs])) \\<and>\n                         ((\\<exists>xs.\n                              hd (tl xs @ [hd xs]) ##\n                              cycle\n                               (tl (tl xs @ [hd xs]) @\n                                [hd (tl xs @ [hd xs])]) =\n                              cycle xs \\<and>\n                              steps xs \\<and>\n                              E (last xs) (hd xs) \\<and>\n                              xs \\<noteq> []) \\<or>\n                          run (hd (tl xs @ [hd xs]) ##\n                               cycle\n                                (tl (tl xs @ [hd xs]) @\n                                 [hd (tl xs @ [hd xs])])))\n 2. \\<And>x y xs.\n       \\<lbrakk>E (last xs) (hd xs); xs \\<noteq> []; xs = x # y # xs; E x y;\n        steps (y # xs)\\<rbrakk>\n       \\<Longrightarrow> E (hd xs) (hd (tl xs @ [hd xs])) \\<and>\n                         ((\\<exists>xs.\n                              hd (tl xs @ [hd xs]) ##\n                              cycle\n                               (tl (tl xs @ [hd xs]) @\n                                [hd (tl xs @ [hd xs])]) =\n                              cycle xs \\<and>\n                              steps xs \\<and>\n                              E (last xs) (hd xs) \\<and>\n                              xs \\<noteq> []) \\<or>\n                          run (hd (tl xs @ [hd xs]) ##\n                               cycle\n                                (tl (tl xs @ [hd xs]) @\n                                 [hd (tl xs @ [hd xs])])))", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>E (last xs) (hd xs); xs \\<noteq> []; xs = [x]\\<rbrakk>\n    \\<Longrightarrow> E (hd xs) (hd (tl xs @ [hd xs])) \\<and>\n                      ((\\<exists>xs.\n                           hd (tl xs @ [hd xs]) ##\n                           cycle\n                            (tl (tl xs @ [hd xs]) @\n                             [hd (tl xs @ [hd xs])]) =\n                           cycle xs \\<and>\n                           steps xs \\<and>\n                           E (last xs) (hd xs) \\<and> xs \\<noteq> []) \\<or>\n                       run (hd (tl xs @ [hd xs]) ##\n                            cycle\n                             (tl (tl xs @ [hd xs]) @\n                              [hd (tl xs @ [hd xs])])))", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>E (last xs) (hd xs); xs \\<noteq> []; xs = [x]\\<rbrakk>\n    \\<Longrightarrow> E (hd xs) (hd (tl xs @ [hd xs]))\n 2. \\<lbrakk>E (last xs) (hd xs); xs \\<noteq> []; xs = [x]\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>xs.\n                          hd (tl xs @ [hd xs]) ##\n                          cycle\n                           (tl (tl xs @ [hd xs]) @ [hd (tl xs @ [hd xs])]) =\n                          cycle xs \\<and>\n                          steps xs \\<and>\n                          E (last xs) (hd xs) \\<and> xs \\<noteq> []) \\<or>\n                      run (hd (tl xs @ [hd xs]) ##\n                           cycle\n                            (tl (tl xs @ [hd xs]) @ [hd (tl xs @ [hd xs])]))", "apply (simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>E (last xs) (hd xs); xs \\<noteq> []; xs = [x]\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>xs.\n                          hd (tl xs @ [hd xs]) ##\n                          cycle\n                           (tl (tl xs @ [hd xs]) @ [hd (tl xs @ [hd xs])]) =\n                          cycle xs \\<and>\n                          steps xs \\<and>\n                          E (last xs) (hd xs) \\<and> xs \\<noteq> []) \\<or>\n                      run (hd (tl xs @ [hd xs]) ##\n                           cycle\n                            (tl (tl xs @ [hd xs]) @ [hd (tl xs @ [hd xs])]))", "apply (rule disjI1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>E (last xs) (hd xs); xs \\<noteq> []; xs = [x]\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         hd (tl xs @ [hd xs]) ##\n                         cycle\n                          (tl (tl xs @ [hd xs]) @ [hd (tl xs @ [hd xs])]) =\n                         cycle xs \\<and>\n                         steps xs \\<and>\n                         E (last xs) (hd xs) \\<and> xs \\<noteq> []", "apply (inst_existentials xs)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>E (last xs) (hd xs); xs \\<noteq> []; xs = [x]\\<rbrakk>\n    \\<Longrightarrow> hd (tl xs @ [hd xs]) ##\n                      cycle\n                       (tl (tl xs @ [hd xs]) @ [hd (tl xs @ [hd xs])]) =\n                      cycle xs\n 2. \\<lbrakk>E (last xs) (hd xs); xs \\<noteq> []; xs = [x]\\<rbrakk>\n    \\<Longrightarrow> steps xs\n 3. \\<lbrakk>E (last xs) (hd xs); xs \\<noteq> []; xs = [x]\\<rbrakk>\n    \\<Longrightarrow> E (last xs) (hd xs)\n 4. \\<lbrakk>E (last xs) (hd xs); xs \\<noteq> []; xs = [x]\\<rbrakk>\n    \\<Longrightarrow> xs \\<noteq> []", "apply (simp, metis cycle_Cons[of x \"[]\", simplified])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>E (last xs) (hd xs); xs \\<noteq> []; xs = [x]\\<rbrakk>\n    \\<Longrightarrow> steps xs\n 2. \\<lbrakk>E (last xs) (hd xs); xs \\<noteq> []; xs = [x]\\<rbrakk>\n    \\<Longrightarrow> E (last xs) (hd xs)\n 3. \\<lbrakk>E (last xs) (hd xs); xs \\<noteq> []; xs = [x]\\<rbrakk>\n    \\<Longrightarrow> xs \\<noteq> []", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xs.\n       \\<lbrakk>E (last xs) (hd xs); xs \\<noteq> []; xs = x # y # xs; E x y;\n        steps (y # xs)\\<rbrakk>\n       \\<Longrightarrow> E (hd xs) (hd (tl xs @ [hd xs])) \\<and>\n                         ((\\<exists>xs.\n                              hd (tl xs @ [hd xs]) ##\n                              cycle\n                               (tl (tl xs @ [hd xs]) @\n                                [hd (tl xs @ [hd xs])]) =\n                              cycle xs \\<and>\n                              steps xs \\<and>\n                              E (last xs) (hd xs) \\<and>\n                              xs \\<noteq> []) \\<or>\n                          run (hd (tl xs @ [hd xs]) ##\n                               cycle\n                                (tl (tl xs @ [hd xs]) @\n                                 [hd (tl xs @ [hd xs])])))", "subgoal for x y xs'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>E (last xs) (hd xs); xs \\<noteq> []; xs = x # y # xs'; E x y;\n     steps (y # xs')\\<rbrakk>\n    \\<Longrightarrow> E (hd xs) (hd (tl xs @ [hd xs])) \\<and>\n                      ((\\<exists>xs.\n                           hd (tl xs @ [hd xs]) ##\n                           cycle\n                            (tl (tl xs @ [hd xs]) @\n                             [hd (tl xs @ [hd xs])]) =\n                           cycle xs \\<and>\n                           steps xs \\<and>\n                           E (last xs) (hd xs) \\<and> xs \\<noteq> []) \\<or>\n                       run (hd (tl xs @ [hd xs]) ##\n                            cycle\n                             (tl (tl xs @ [hd xs]) @\n                              [hd (tl xs @ [hd xs])])))", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>E (last xs) (hd xs); xs \\<noteq> []; xs = x # y # xs'; E x y;\n     steps (y # xs')\\<rbrakk>\n    \\<Longrightarrow> E (hd xs) (hd (tl xs @ [hd xs]))\n 2. \\<lbrakk>E (last xs) (hd xs); xs \\<noteq> []; xs = x # y # xs'; E x y;\n     steps (y # xs')\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>xs.\n                          hd (tl xs @ [hd xs]) ##\n                          cycle\n                           (tl (tl xs @ [hd xs]) @ [hd (tl xs @ [hd xs])]) =\n                          cycle xs \\<and>\n                          steps xs \\<and>\n                          E (last xs) (hd xs) \\<and> xs \\<noteq> []) \\<or>\n                      run (hd (tl xs @ [hd xs]) ##\n                           cycle\n                            (tl (tl xs @ [hd xs]) @ [hd (tl xs @ [hd xs])]))", "apply (simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>E (last xs) (hd xs); xs \\<noteq> []; xs = x # y # xs'; E x y;\n     steps (y # xs')\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>xs.\n                          hd (tl xs @ [hd xs]) ##\n                          cycle\n                           (tl (tl xs @ [hd xs]) @ [hd (tl xs @ [hd xs])]) =\n                          cycle xs \\<and>\n                          steps xs \\<and>\n                          E (last xs) (hd xs) \\<and> xs \\<noteq> []) \\<or>\n                      run (hd (tl xs @ [hd xs]) ##\n                           cycle\n                            (tl (tl xs @ [hd xs]) @ [hd (tl xs @ [hd xs])]))", "apply (rule disjI1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>E (last xs) (hd xs); xs \\<noteq> []; xs = x # y # xs'; E x y;\n     steps (y # xs')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         hd (tl xs @ [hd xs]) ##\n                         cycle\n                          (tl (tl xs @ [hd xs]) @ [hd (tl xs @ [hd xs])]) =\n                         cycle xs \\<and>\n                         steps xs \\<and>\n                         E (last xs) (hd xs) \\<and> xs \\<noteq> []", "apply (inst_existentials \"y # xs' @ [x]\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>E (last xs) (hd xs); xs \\<noteq> []; xs = x # y # xs'; E x y;\n     steps (y # xs')\\<rbrakk>\n    \\<Longrightarrow> hd (tl xs @ [hd xs]) ##\n                      cycle\n                       (tl (tl xs @ [hd xs]) @ [hd (tl xs @ [hd xs])]) =\n                      cycle (y # xs' @ [x])\n 2. \\<lbrakk>E (last xs) (hd xs); xs \\<noteq> []; xs = x # y # xs'; E x y;\n     steps (y # xs')\\<rbrakk>\n    \\<Longrightarrow> steps (y # xs' @ [x])\n 3. \\<lbrakk>E (last xs) (hd xs); xs \\<noteq> []; xs = x # y # xs'; E x y;\n     steps (y # xs')\\<rbrakk>\n    \\<Longrightarrow> E (last (y # xs' @ [x])) (hd (y # xs' @ [x]))\n 4. \\<lbrakk>E (last xs) (hd xs); xs \\<noteq> []; xs = x # y # xs'; E x y;\n     steps (y # xs')\\<rbrakk>\n    \\<Longrightarrow> y # xs' @ [x] \\<noteq> []", "using steps_append_single[of \"y # xs'\" x]"], ["proof (prove)\nusing this:\n  \\<lbrakk>steps (y # xs'); E (last (y # xs')) x;\n   y # xs' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> steps ((y # xs') @ [x])\n\ngoal (4 subgoals):\n 1. \\<lbrakk>E (last xs) (hd xs); xs \\<noteq> []; xs = x # y # xs'; E x y;\n     steps (y # xs')\\<rbrakk>\n    \\<Longrightarrow> hd (tl xs @ [hd xs]) ##\n                      cycle\n                       (tl (tl xs @ [hd xs]) @ [hd (tl xs @ [hd xs])]) =\n                      cycle (y # xs' @ [x])\n 2. \\<lbrakk>E (last xs) (hd xs); xs \\<noteq> []; xs = x # y # xs'; E x y;\n     steps (y # xs')\\<rbrakk>\n    \\<Longrightarrow> steps (y # xs' @ [x])\n 3. \\<lbrakk>E (last xs) (hd xs); xs \\<noteq> []; xs = x # y # xs'; E x y;\n     steps (y # xs')\\<rbrakk>\n    \\<Longrightarrow> E (last (y # xs' @ [x])) (hd (y # xs' @ [x]))\n 4. \\<lbrakk>E (last xs) (hd xs); xs \\<noteq> []; xs = x # y # xs'; E x y;\n     steps (y # xs')\\<rbrakk>\n    \\<Longrightarrow> y # xs' @ [x] \\<noteq> []", "apply (auto elim: steps.cases split: if_split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>xs = [x, y]; E x y; steps [y]; steps [y, x]; xs' = [];\n     E y x\\<rbrakk>\n    \\<Longrightarrow> y ## cycle [x, y] = cycle [y, x]\n 2. \\<lbrakk>xs = x # y # xs'; E x y; steps (y # xs');\n     steps (y # xs' @ [x]); xs' \\<noteq> []; E (last xs') x\\<rbrakk>\n    \\<Longrightarrow> y ## cycle (xs' @ [x, y]) = cycle (y # xs' @ [x])", "apply (subst (2) cycle_Cons, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs = x # y # xs'; E x y; steps (y # xs');\n     steps (y # xs' @ [x]); xs' \\<noteq> []; E (last xs') x\\<rbrakk>\n    \\<Longrightarrow> y ## cycle (xs' @ [x, y]) = cycle (y # xs' @ [x])", "(* XXX Automate forward reasoning *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs = x # y # xs'; E x y; steps (y # xs');\n     steps (y # xs' @ [x]); xs' \\<noteq> []; E (last xs') x\\<rbrakk>\n    \\<Longrightarrow> y ## cycle (xs' @ [x, y]) = cycle (y # xs' @ [x])", "apply (subst cycle_Cons, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>x y xs.\n     cycle xs = x ## y ## xs \\<and>\n     E x y \\<and>\n     ((\\<exists>xsa.\n          y ## xs = cycle xsa \\<and>\n          steps xsa \\<and>\n          E (last xsa) (hd xsa) \\<and> xsa \\<noteq> []) \\<or>\n      run (y ## xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma run_stl:\n  \"run (stl xs)\" if \"run xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run (stl xs)", "using that"], ["proof (prove)\nusing this:\n  run xs\n\ngoal (1 subgoal):\n 1. run (stl xs)", "by (auto elim: run.cases)"], ["", "lemma run_sdrop:\n  \"run (sdrop n xs)\" if \"run xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run (sdrop n xs)", "using that"], ["proof (prove)\nusing this:\n  run xs\n\ngoal (1 subgoal):\n 1. run (sdrop n xs)", "by (induction n arbitrary: xs) (auto intro: run_stl)"], ["", "lemma run_reachable':\n  assumes \"run (x ## xs)\" \"E\\<^sup>*\\<^sup>* x\\<^sub>0 x\"\n  shows \"pred_stream (\\<lambda> x. E\\<^sup>*\\<^sup>* x\\<^sub>0 x) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream (E\\<^sup>*\\<^sup>* x\\<^sub>0) xs", "using assms"], ["proof (prove)\nusing this:\n  run (x ## xs)\n  E\\<^sup>*\\<^sup>* x\\<^sub>0 x\n\ngoal (1 subgoal):\n 1. pred_stream (E\\<^sup>*\\<^sup>* x\\<^sub>0) xs", "by (coinduction arbitrary: x xs) (auto 4 3 elim: run.cases)"], ["", "lemma run_reachable:\n  assumes \"run (x\\<^sub>0 ## xs)\"\n  shows \"pred_stream (\\<lambda> x. E\\<^sup>*\\<^sup>* x\\<^sub>0 x) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream (E\\<^sup>*\\<^sup>* x\\<^sub>0) xs", "by (rule run_reachable'[OF assms]) blast"], ["", "lemma run_decomp:\n  assumes \"run (xs @- ys)\" \"xs \\<noteq> []\"\n  shows \"steps xs \\<and> run ys \\<and> E (last xs) (shd ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps xs \\<and> run ys \\<and> E (last xs) (shd ys)", "using assms(2,1)"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  run (xs @- ys)\n\ngoal (1 subgoal):\n 1. steps xs \\<and> run ys \\<and> E (last xs) (shd ys)", "proof (induction xs rule: list_nonempty_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       run ([x] @- ys) \\<Longrightarrow>\n       steps [x] \\<and> run ys \\<and> E (last [x]) (shd ys)\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        run (xs @- ys) \\<Longrightarrow>\n        steps xs \\<and> run ys \\<and> E (last xs) (shd ys);\n        run ((x # xs) @- ys)\\<rbrakk>\n       \\<Longrightarrow> steps (x # xs) \\<and>\n                         run ys \\<and> E (last (x # xs)) (shd ys)", "case (single x)"], ["proof (state)\nthis:\n  run ([x] @- ys)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       run ([x] @- ys) \\<Longrightarrow>\n       steps [x] \\<and> run ys \\<and> E (last [x]) (shd ys)\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        run (xs @- ys) \\<Longrightarrow>\n        steps xs \\<and> run ys \\<and> E (last xs) (shd ys);\n        run ((x # xs) @- ys)\\<rbrakk>\n       \\<Longrightarrow> steps (x # xs) \\<and>\n                         run ys \\<and> E (last (x # xs)) (shd ys)", "then"], ["proof (chain)\npicking this:\n  run ([x] @- ys)", "show ?case"], ["proof (prove)\nusing this:\n  run ([x] @- ys)\n\ngoal (1 subgoal):\n 1. steps [x] \\<and> run ys \\<and> E (last [x]) (shd ys)", "by (auto elim: run.cases)"], ["proof (state)\nthis:\n  steps [x] \\<and> run ys \\<and> E (last [x]) (shd ys)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        run (xs @- ys) \\<Longrightarrow>\n        steps xs \\<and> run ys \\<and> E (last xs) (shd ys);\n        run ((x # xs) @- ys)\\<rbrakk>\n       \\<Longrightarrow> steps (x # xs) \\<and>\n                         run ys \\<and> E (last (x # xs)) (shd ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        run (xs @- ys) \\<Longrightarrow>\n        steps xs \\<and> run ys \\<and> E (last xs) (shd ys);\n        run ((x # xs) @- ys)\\<rbrakk>\n       \\<Longrightarrow> steps (x # xs) \\<and>\n                         run ys \\<and> E (last (x # xs)) (shd ys)", "case (cons x xs)"], ["proof (state)\nthis:\n  xs \\<noteq> []\n  run (xs @- ys) \\<Longrightarrow>\n  steps xs \\<and> run ys \\<and> E (last xs) (shd ys)\n  run ((x # xs) @- ys)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        run (xs @- ys) \\<Longrightarrow>\n        steps xs \\<and> run ys \\<and> E (last xs) (shd ys);\n        run ((x # xs) @- ys)\\<rbrakk>\n       \\<Longrightarrow> steps (x # xs) \\<and>\n                         run ys \\<and> E (last (x # xs)) (shd ys)", "then"], ["proof (chain)\npicking this:\n  xs \\<noteq> []\n  run (xs @- ys) \\<Longrightarrow>\n  steps xs \\<and> run ys \\<and> E (last xs) (shd ys)\n  run ((x # xs) @- ys)", "show ?case"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  run (xs @- ys) \\<Longrightarrow>\n  steps xs \\<and> run ys \\<and> E (last xs) (shd ys)\n  run ((x # xs) @- ys)\n\ngoal (1 subgoal):\n 1. steps (x # xs) \\<and> run ys \\<and> E (last (x # xs)) (shd ys)", "by (cases xs; auto 4 4 elim: run.cases)"], ["proof (state)\nthis:\n  steps (x # xs) \\<and> run ys \\<and> E (last (x # xs)) (shd ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma steps_decomp:\n  assumes \"steps (xs @ ys)\" \"xs \\<noteq> []\" \"ys \\<noteq> []\"\n  shows \"steps xs \\<and> steps ys \\<and> E (last xs) (hd ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps xs \\<and> steps ys \\<and> E (last xs) (hd ys)", "using assms(2,1,3)"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  steps (xs @ ys)\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. steps xs \\<and> steps ys \\<and> E (last xs) (hd ys)", "proof (induction xs rule: list_nonempty_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>steps ([x] @ ys); ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> steps [x] \\<and>\n                         steps ys \\<and> E (last [x]) (hd ys)\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>steps (xs @ ys); ys \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> steps xs \\<and>\n                          steps ys \\<and> E (last xs) (hd ys);\n        steps ((x # xs) @ ys); ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> steps (x # xs) \\<and>\n                         steps ys \\<and> E (last (x # xs)) (hd ys)", "case (single x)"], ["proof (state)\nthis:\n  steps ([x] @ ys)\n  ys \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>steps ([x] @ ys); ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> steps [x] \\<and>\n                         steps ys \\<and> E (last [x]) (hd ys)\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>steps (xs @ ys); ys \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> steps xs \\<and>\n                          steps ys \\<and> E (last xs) (hd ys);\n        steps ((x # xs) @ ys); ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> steps (x # xs) \\<and>\n                         steps ys \\<and> E (last (x # xs)) (hd ys)", "then"], ["proof (chain)\npicking this:\n  steps ([x] @ ys)\n  ys \\<noteq> []", "show ?case"], ["proof (prove)\nusing this:\n  steps ([x] @ ys)\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. steps [x] \\<and> steps ys \\<and> E (last [x]) (hd ys)", "by (auto elim: steps.cases)"], ["proof (state)\nthis:\n  steps [x] \\<and> steps ys \\<and> E (last [x]) (hd ys)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>steps (xs @ ys); ys \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> steps xs \\<and>\n                          steps ys \\<and> E (last xs) (hd ys);\n        steps ((x # xs) @ ys); ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> steps (x # xs) \\<and>\n                         steps ys \\<and> E (last (x # xs)) (hd ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>steps (xs @ ys); ys \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> steps xs \\<and>\n                          steps ys \\<and> E (last xs) (hd ys);\n        steps ((x # xs) @ ys); ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> steps (x # xs) \\<and>\n                         steps ys \\<and> E (last (x # xs)) (hd ys)", "case (cons x xs)"], ["proof (state)\nthis:\n  xs \\<noteq> []\n  \\<lbrakk>steps (xs @ ys); ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> steps xs \\<and> steps ys \\<and> E (last xs) (hd ys)\n  steps ((x # xs) @ ys)\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<lbrakk>steps (xs @ ys); ys \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> steps xs \\<and>\n                          steps ys \\<and> E (last xs) (hd ys);\n        steps ((x # xs) @ ys); ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> steps (x # xs) \\<and>\n                         steps ys \\<and> E (last (x # xs)) (hd ys)", "then"], ["proof (chain)\npicking this:\n  xs \\<noteq> []\n  \\<lbrakk>steps (xs @ ys); ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> steps xs \\<and> steps ys \\<and> E (last xs) (hd ys)\n  steps ((x # xs) @ ys)\n  ys \\<noteq> []", "show ?case"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  \\<lbrakk>steps (xs @ ys); ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> steps xs \\<and> steps ys \\<and> E (last xs) (hd ys)\n  steps ((x # xs) @ ys)\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. steps (x # xs) \\<and> steps ys \\<and> E (last (x # xs)) (hd ys)", "by (cases xs; auto 4 4 elim: steps.cases)"], ["proof (state)\nthis:\n  steps (x # xs) \\<and> steps ys \\<and> E (last (x # xs)) (hd ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma steps_rotate:\n  assumes \"steps (x # xs @ y # ys @ [x])\"\n  shows \"steps (y # ys @ x # xs @ [y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps (y # ys @ x # xs @ [y])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. steps (y # ys @ x # xs @ [y])", "from steps_decomp[of \"x # xs\" \"y # ys @ [x]\"] assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>steps ((x # xs) @ y # ys @ [x]); x # xs \\<noteq> [];\n   y # ys @ [x] \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> steps (x # xs) \\<and>\n                    steps (y # ys @ [x]) \\<and>\n                    E (last (x # xs)) (hd (y # ys @ [x]))\n  steps (x # xs @ y # ys @ [x])", "have\n    \"steps (x # xs)\" \"steps (y # ys @ [x])\" \"E (last (x # xs)) y\""], ["proof (prove)\nusing this:\n  \\<lbrakk>steps ((x # xs) @ y # ys @ [x]); x # xs \\<noteq> [];\n   y # ys @ [x] \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> steps (x # xs) \\<and>\n                    steps (y # ys @ [x]) \\<and>\n                    E (last (x # xs)) (hd (y # ys @ [x]))\n  steps (x # xs @ y # ys @ [x])\n\ngoal (1 subgoal):\n 1. steps (x # xs) &&& steps (y # ys @ [x]) &&& E (last (x # xs)) y", "by auto"], ["proof (state)\nthis:\n  steps (x # xs)\n  steps (y # ys @ [x])\n  E (last (x # xs)) y\n\ngoal (1 subgoal):\n 1. steps (y # ys @ x # xs @ [y])", "then"], ["proof (chain)\npicking this:\n  steps (x # xs)\n  steps (y # ys @ [x])\n  E (last (x # xs)) y", "have \"steps ((x # xs) @ [y])\""], ["proof (prove)\nusing this:\n  steps (x # xs)\n  steps (y # ys @ [x])\n  E (last (x # xs)) y\n\ngoal (1 subgoal):\n 1. steps ((x # xs) @ [y])", "by (blast intro: steps_append_single)"], ["proof (state)\nthis:\n  steps ((x # xs) @ [y])\n\ngoal (1 subgoal):\n 1. steps (y # ys @ x # xs @ [y])", "from steps_append[OF \\<open>steps (y # ys @ [x])\\<close> this]"], ["proof (chain)\npicking this:\n  last (y # ys @ [x]) = hd ((x # xs) @ [y]) \\<Longrightarrow>\n  steps ((y # ys @ [x]) @ tl ((x # xs) @ [y]))", "show ?thesis"], ["proof (prove)\nusing this:\n  last (y # ys @ [x]) = hd ((x # xs) @ [y]) \\<Longrightarrow>\n  steps ((y # ys @ [x]) @ tl ((x # xs) @ [y]))\n\ngoal (1 subgoal):\n 1. steps (y # ys @ x # xs @ [y])", "by auto"], ["proof (state)\nthis:\n  steps (y # ys @ x # xs @ [y])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma run_shift_coinduct[case_names run_shift, consumes 1]:\n  assumes \"R w\"\n      and \"\\<And> w. R w \\<Longrightarrow> \\<exists> u v x y. w = u @- x ## y ## v \\<and> steps (u @ [x]) \\<and> E x y \\<and> R (y ## v)\"\n  shows \"run w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run w", "using assms(2)[OF \\<open>R w\\<close>]"], ["proof (prove)\nusing this:\n  \\<exists>u v x y.\n     w = u @- x ## y ## v \\<and>\n     steps (u @ [x]) \\<and> E x y \\<and> R (y ## v)\n\ngoal (1 subgoal):\n 1. run w", "proof (coinduction arbitrary: w)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<exists>u v x y.\n          w = u @- x ## y ## v \\<and>\n          steps (u @ [x]) \\<and> E x y \\<and> R (y ## v) \\<Longrightarrow>\n       \\<exists>x y xs.\n          w = x ## y ## xs \\<and>\n          E x y \\<and>\n          ((\\<exists>w.\n               y ## xs = w \\<and>\n               (\\<exists>u v x y.\n                   w = u @- x ## y ## v \\<and>\n                   steps (u @ [x]) \\<and> E x y \\<and> R (y ## v))) \\<or>\n           run (y ## xs))", "case (run w)"], ["proof (state)\nthis:\n  \\<exists>u v x y.\n     w = u @- x ## y ## v \\<and>\n     steps (u @ [x]) \\<and> E x y \\<and> R (y ## v)\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<exists>u v x y.\n          w = u @- x ## y ## v \\<and>\n          steps (u @ [x]) \\<and> E x y \\<and> R (y ## v) \\<Longrightarrow>\n       \\<exists>x y xs.\n          w = x ## y ## xs \\<and>\n          E x y \\<and>\n          ((\\<exists>w.\n               y ## xs = w \\<and>\n               (\\<exists>u v x y.\n                   w = u @- x ## y ## v \\<and>\n                   steps (u @ [x]) \\<and> E x y \\<and> R (y ## v))) \\<or>\n           run (y ## xs))", "then"], ["proof (chain)\npicking this:\n  \\<exists>u v x y.\n     w = u @- x ## y ## v \\<and>\n     steps (u @ [x]) \\<and> E x y \\<and> R (y ## v)", "obtain u v x y where \"w = u @- x ## y ## v\" \"steps (u @ [x])\" \"E x y\" \"R (y ## v)\""], ["proof (prove)\nusing this:\n  \\<exists>u v x y.\n     w = u @- x ## y ## v \\<and>\n     steps (u @ [x]) \\<and> E x y \\<and> R (y ## v)\n\ngoal (1 subgoal):\n 1. (\\<And>u x y v.\n        \\<lbrakk>w = u @- x ## y ## v; steps (u @ [x]); E x y;\n         R (y ## v)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  w = u @- x ## y ## v\n  steps (u @ [x])\n  E x y\n  R (y ## v)\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<exists>u v x y.\n          w = u @- x ## y ## v \\<and>\n          steps (u @ [x]) \\<and> E x y \\<and> R (y ## v) \\<Longrightarrow>\n       \\<exists>x y xs.\n          w = x ## y ## xs \\<and>\n          E x y \\<and>\n          ((\\<exists>w.\n               y ## xs = w \\<and>\n               (\\<exists>u v x y.\n                   w = u @- x ## y ## v \\<and>\n                   steps (u @ [x]) \\<and> E x y \\<and> R (y ## v))) \\<or>\n           run (y ## xs))", "then"], ["proof (chain)\npicking this:\n  w = u @- x ## y ## v\n  steps (u @ [x])\n  E x y\n  R (y ## v)", "show ?case"], ["proof (prove)\nusing this:\n  w = u @- x ## y ## v\n  steps (u @ [x])\n  E x y\n  R (y ## v)\n\ngoal (1 subgoal):\n 1. \\<exists>x y xs.\n       w = x ## y ## xs \\<and>\n       E x y \\<and>\n       ((\\<exists>w.\n            y ## xs = w \\<and>\n            (\\<exists>u v x y.\n                w = u @- x ## y ## v \\<and>\n                steps (u @ [x]) \\<and> E x y \\<and> R (y ## v))) \\<or>\n        run (y ## xs))", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w = u @- x ## y ## v; steps (u @ [x]); E x y;\n     R (y ## v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x y xs.\n                         w = x ## y ## xs \\<and>\n                         E x y \\<and>\n                         ((\\<exists>w.\n                              y ## xs = w \\<and>\n                              (\\<exists>u v x y.\n                                  w = u @- x ## y ## v \\<and>\n                                  steps (u @ [x]) \\<and>\n                                  E x y \\<and> R (y ## v))) \\<or>\n                          run (y ## xs))", "apply (drule assms(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w = u @- x ## y ## v; steps (u @ [x]); E x y;\n     \\<exists>u va x ya.\n        y ## v = u @- x ## ya ## va \\<and>\n        steps (u @ [x]) \\<and> E x ya \\<and> R (ya ## va)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x y xs.\n                         w = x ## y ## xs \\<and>\n                         E x y \\<and>\n                         ((\\<exists>w.\n                              y ## xs = w \\<and>\n                              (\\<exists>u v x y.\n                                  w = u @- x ## y ## v \\<and>\n                                  steps (u @ [x]) \\<and>\n                                  E x y \\<and> R (y ## v))) \\<or>\n                          run (y ## xs))", "apply (cases u)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>w = u @- x ## y ## v; steps (u @ [x]); E x y;\n     \\<exists>u va x ya.\n        y ## v = u @- x ## ya ## va \\<and>\n        steps (u @ [x]) \\<and> E x ya \\<and> R (ya ## va);\n     u = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x y xs.\n                         w = x ## y ## xs \\<and>\n                         E x y \\<and>\n                         ((\\<exists>w.\n                              y ## xs = w \\<and>\n                              (\\<exists>u v x y.\n                                  w = u @- x ## y ## v \\<and>\n                                  steps (u @ [x]) \\<and>\n                                  E x y \\<and> R (y ## v))) \\<or>\n                          run (y ## xs))\n 2. \\<And>a list.\n       \\<lbrakk>w = u @- x ## y ## v; steps (u @ [x]); E x y;\n        \\<exists>u va x ya.\n           y ## v = u @- x ## ya ## va \\<and>\n           steps (u @ [x]) \\<and> E x ya \\<and> R (ya ## va);\n        u = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y xs.\n                            w = x ## y ## xs \\<and>\n                            E x y \\<and>\n                            ((\\<exists>w.\n                                 y ## xs = w \\<and>\n                                 (\\<exists>u v x y.\n                                     w = u @- x ## y ## v \\<and>\n                                     steps (u @ [x]) \\<and>\n                                     E x y \\<and> R (y ## v))) \\<or>\n                             run (y ## xs))", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>w = u @- x ## y ## v; steps (u @ [x]); E x y;\n        \\<exists>u va x ya.\n           y ## v = u @- x ## ya ## va \\<and>\n           steps (u @ [x]) \\<and> E x ya \\<and> R (ya ## va);\n        u = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y xs.\n                            w = x ## y ## xs \\<and>\n                            E x y \\<and>\n                            ((\\<exists>w.\n                                 y ## xs = w \\<and>\n                                 (\\<exists>u v x y.\n                                     w = u @- x ## y ## v \\<and>\n                                     steps (u @ [x]) \\<and>\n                                     E x y \\<and> R (y ## v))) \\<or>\n                             run (y ## xs))", "subgoal for z zs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w = u @- x ## y ## v; steps (u @ [x]); E x y;\n     \\<exists>u va x ya.\n        y ## v = u @- x ## ya ## va \\<and>\n        steps (u @ [x]) \\<and> E x ya \\<and> R (ya ## va);\n     u = z # zs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x y xs.\n                         w = x ## y ## xs \\<and>\n                         E x y \\<and>\n                         ((\\<exists>w.\n                              y ## xs = w \\<and>\n                              (\\<exists>u v x y.\n                                  w = u @- x ## y ## v \\<and>\n                                  steps (u @ [x]) \\<and>\n                                  E x y \\<and> R (y ## v))) \\<or>\n                          run (y ## xs))", "apply (cases zs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>w = u @- x ## y ## v; steps (u @ [x]); E x y;\n     \\<exists>u va x ya.\n        y ## v = u @- x ## ya ## va \\<and>\n        steps (u @ [x]) \\<and> E x ya \\<and> R (ya ## va);\n     u = z # zs; zs = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x y xs.\n                         w = x ## y ## xs \\<and>\n                         E x y \\<and>\n                         ((\\<exists>w.\n                              y ## xs = w \\<and>\n                              (\\<exists>u v x y.\n                                  w = u @- x ## y ## v \\<and>\n                                  steps (u @ [x]) \\<and>\n                                  E x y \\<and> R (y ## v))) \\<or>\n                          run (y ## xs))\n 2. \\<And>a list.\n       \\<lbrakk>w = u @- x ## y ## v; steps (u @ [x]); E x y;\n        \\<exists>u va x ya.\n           y ## v = u @- x ## ya ## va \\<and>\n           steps (u @ [x]) \\<and> E x ya \\<and> R (ya ## va);\n        u = z # zs; zs = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y xs.\n                            w = x ## y ## xs \\<and>\n                            E x y \\<and>\n                            ((\\<exists>w.\n                                 y ## xs = w \\<and>\n                                 (\\<exists>u v x y.\n                                     w = u @- x ## y ## v \\<and>\n                                     steps (u @ [x]) \\<and>\n                                     E x y \\<and> R (y ## v))) \\<or>\n                             run (y ## xs))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w = u @- x ## y ## v; steps (u @ [x]); E x y;\n     \\<exists>u va x ya.\n        y ## v = u @- x ## ya ## va \\<and>\n        steps (u @ [x]) \\<and> E x ya \\<and> R (ya ## va);\n     u = z # zs; zs = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x y xs.\n                         w = x ## y ## xs \\<and>\n                         E x y \\<and>\n                         ((\\<exists>w.\n                              y ## xs = w \\<and>\n                              (\\<exists>u v x y.\n                                  w = u @- x ## y ## v \\<and>\n                                  steps (u @ [x]) \\<and>\n                                  E x y \\<and> R (y ## v))) \\<or>\n                          run (y ## xs))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w = z ## x ## y ## v; steps [z, x]; E x y;\n     \\<exists>u va x ya.\n        y ## v = u @- x ## ya ## va \\<and>\n        steps (u @ [x]) \\<and> E x ya \\<and> R (ya ## va);\n     u = [z]; zs = []\\<rbrakk>\n    \\<Longrightarrow> E z x \\<and>\n                      ((\\<exists>u va xa ya.\n                           x ## y ## v = u @- xa ## ya ## va \\<and>\n                           steps (u @ [xa]) \\<and>\n                           E xa ya \\<and> R (ya ## va)) \\<or>\n                       run (x ## y ## v))", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ua va xa ya.\n       \\<lbrakk>w = z ## x ## y ## v; steps [z, x]; E x y; u = [z]; zs = [];\n        y ## v = ua @- xa ## ya ## va; steps (ua @ [xa]); E xa ya;\n        R (ya ## va)\\<rbrakk>\n       \\<Longrightarrow> E z x\n 2. \\<And>ua va xa ya.\n       \\<lbrakk>w = z ## x ## y ## v; steps [z, x]; E x y; u = [z]; zs = [];\n        y ## v = ua @- xa ## ya ## va; steps (ua @ [xa]); E xa ya;\n        R (ya ## va); \\<not> run (x ## y ## v)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u va xa ya.\n                            x ## y ## v = u @- xa ## ya ## va \\<and>\n                            steps (u @ [xa]) \\<and>\n                            E xa ya \\<and> R (ya ## va)", "apply (force elim: steps.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ua va xa ya.\n       \\<lbrakk>w = z ## x ## y ## v; steps [z, x]; E x y; u = [z]; zs = [];\n        y ## v = ua @- xa ## ya ## va; steps (ua @ [xa]); E xa ya;\n        R (ya ## va); \\<not> run (x ## y ## v)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u va xa ya.\n                            x ## y ## v = u @- xa ## ya ## va \\<and>\n                            steps (u @ [xa]) \\<and>\n                            E xa ya \\<and> R (ya ## va)", "subgoal for u' v' x' y'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w = z ## x ## y ## v; steps [z, x]; E x y; u = [z]; zs = [];\n     y ## v = u' @- x' ## y' ## v'; steps (u' @ [x']); E x' y';\n     R (y' ## v'); \\<not> run (x ## y ## v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u va xa ya.\n                         x ## y ## v = u @- xa ## ya ## va \\<and>\n                         steps (u @ [xa]) \\<and> E xa ya \\<and> R (ya ## va)", "by (inst_existentials \"x # u'\") (cases u'; auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>w = u @- x ## y ## v; steps (u @ [x]); E x y;\n        \\<exists>u va x ya.\n           y ## v = u @- x ## ya ## va \\<and>\n           steps (u @ [x]) \\<and> E x ya \\<and> R (ya ## va);\n        u = z # zs; zs = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y xs.\n                            w = x ## y ## xs \\<and>\n                            E x y \\<and>\n                            ((\\<exists>w.\n                                 y ## xs = w \\<and>\n                                 (\\<exists>u v x y.\n                                     w = u @- x ## y ## v \\<and>\n                                     steps (u @ [x]) \\<and>\n                                     E x y \\<and> R (y ## v))) \\<or>\n                             run (y ## xs))", "subgoal for a as"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w = u @- x ## y ## v; steps (u @ [x]); E x y;\n     \\<exists>u va x ya.\n        y ## v = u @- x ## ya ## va \\<and>\n        steps (u @ [x]) \\<and> E x ya \\<and> R (ya ## va);\n     u = z # zs; zs = a # as\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x y xs.\n                         w = x ## y ## xs \\<and>\n                         E x y \\<and>\n                         ((\\<exists>w.\n                              y ## xs = w \\<and>\n                              (\\<exists>u v x y.\n                                  w = u @- x ## y ## v \\<and>\n                                  steps (u @ [x]) \\<and>\n                                  E x y \\<and> R (y ## v))) \\<or>\n                          run (y ## xs))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w = z ## a ## as @- x ## y ## v; steps (z # a # as @ [x]);\n     E x y;\n     \\<exists>u va x ya.\n        y ## v = u @- x ## ya ## va \\<and>\n        steps (u @ [x]) \\<and> E x ya \\<and> R (ya ## va);\n     u = z # a # as; zs = a # as\\<rbrakk>\n    \\<Longrightarrow> E z a \\<and>\n                      ((\\<exists>u va xa ya.\n                           a ## as @- x ## y ## v =\n                           u @- xa ## ya ## va \\<and>\n                           steps (u @ [xa]) \\<and>\n                           E xa ya \\<and> R (ya ## va)) \\<or>\n                       run (a ## as @- x ## y ## v))", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ua va xa ya.\n       \\<lbrakk>w = z ## a ## as @- x ## y ## v; steps (z # a # as @ [x]);\n        E x y; u = z # a # as; zs = a # as; y ## v = ua @- xa ## ya ## va;\n        steps (ua @ [xa]); E xa ya; R (ya ## va)\\<rbrakk>\n       \\<Longrightarrow> E z a\n 2. \\<And>ua va xa ya.\n       \\<lbrakk>w = z ## a ## as @- x ## y ## v; steps (z # a # as @ [x]);\n        E x y; u = z # a # as; zs = a # as; y ## v = ua @- xa ## ya ## va;\n        steps (ua @ [xa]); E xa ya; R (ya ## va);\n        \\<not> run (a ## as @- x ## y ## v)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u va xa ya.\n                            a ## as @- x ## y ## v =\n                            u @- xa ## ya ## va \\<and>\n                            steps (u @ [xa]) \\<and>\n                            E xa ya \\<and> R (ya ## va)", "apply (force elim: steps.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ua va xa ya.\n       \\<lbrakk>w = z ## a ## as @- x ## y ## v; steps (z # a # as @ [x]);\n        E x y; u = z # a # as; zs = a # as; y ## v = ua @- xa ## ya ## va;\n        steps (ua @ [xa]); E xa ya; R (ya ## va);\n        \\<not> run (a ## as @- x ## y ## v)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u va xa ya.\n                            a ## as @- x ## y ## v =\n                            u @- xa ## ya ## va \\<and>\n                            steps (u @ [xa]) \\<and>\n                            E xa ya \\<and> R (ya ## va)", "subgoal for u' v' x' y'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w = z ## a ## as @- x ## y ## v; steps (z # a # as @ [x]);\n     E x y; u = z # a # as; zs = a # as; y ## v = u' @- x' ## y' ## v';\n     steps (u' @ [x']); E x' y'; R (y' ## v');\n     \\<not> run (a ## as @- x ## y ## v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u va xa ya.\n                         a ## as @- x ## y ## v = u @- xa ## ya ## va \\<and>\n                         steps (u @ [xa]) \\<and> E xa ya \\<and> R (ya ## va)", "apply (inst_existentials \"a # as @ x # u'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w = z ## a ## as @- x ## y ## v; steps (z # a # as @ [x]);\n     E x y; u = z # a # as; zs = a # as; y ## v = u' @- x' ## y' ## v';\n     steps (u' @ [x']); E x' y'; R (y' ## v');\n     \\<not> run (a ## as @- x ## y ## v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>va xa ya.\n                         a ## as @- x ## y ## v =\n                         (a # as @ x # u') @- xa ## ya ## va \\<and>\n                         steps ((a # as @ x # u') @ [xa]) \\<and>\n                         E xa ya \\<and> R (ya ## va)", "using steps_append[of \"a # as @ [x, y]\" \"u' @ [x']\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>steps (a # as @ [x, y]); steps (u' @ [x']);\n   last (a # as @ [x, y]) = hd (u' @ [x'])\\<rbrakk>\n  \\<Longrightarrow> steps ((a # as @ [x, y]) @ tl (u' @ [x']))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w = z ## a ## as @- x ## y ## v; steps (z # a # as @ [x]);\n     E x y; u = z # a # as; zs = a # as; y ## v = u' @- x' ## y' ## v';\n     steps (u' @ [x']); E x' y'; R (y' ## v');\n     \\<not> run (a ## as @- x ## y ## v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>va xa ya.\n                         a ## as @- x ## y ## v =\n                         (a # as @ x # u') @- xa ## ya ## va \\<and>\n                         steps ((a # as @ x # u') @ [xa]) \\<and>\n                         E xa ya \\<and> R (ya ## va)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w = z ## a ## as @- x ## u' @- x' ## y' ## v';\n     steps (z # a # as @ [x]); E x y; u = z # a # as; zs = a # as;\n     y ## v = u' @- x' ## y' ## v'; steps (u' @ [x']); E x' y';\n     R (y' ## v'); \\<not> run (a ## as @- x ## u' @- x' ## y' ## v');\n     \\<lbrakk>steps (a # as @ [x, hd (u' @ [x'])]);\n      y = hd (u' @ [x'])\\<rbrakk>\n     \\<Longrightarrow> steps (a # as @ x # u' @ [x'])\\<rbrakk>\n    \\<Longrightarrow> steps (a # as @ x # u' @ [x'])", "apply (drule steps_appendI[of \"a # as\" x, rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>w = z ## a ## as @- x ## u' @- x' ## y' ## v';\n     steps (z # a # as @ [x]); u = z # a # as; zs = a # as;\n     y ## v = u' @- x' ## y' ## v'; steps (u' @ [x']); E x' y';\n     R (y' ## v'); \\<not> run (a ## as @- x ## u' @- x' ## y' ## v');\n     \\<lbrakk>steps (a # as @ [x, hd (u' @ [x'])]);\n      y = hd (u' @ [x'])\\<rbrakk>\n     \\<Longrightarrow> steps (a # as @ x # u' @ [x'])\\<rbrakk>\n    \\<Longrightarrow> steps ((a # as) @ [x])\n 2. \\<lbrakk>w = z ## a ## as @- x ## u' @- x' ## y' ## v';\n     steps (z # a # as @ [x]); u = z # a # as; zs = a # as;\n     y ## v = u' @- x' ## y' ## v'; steps (u' @ [x']); E x' y';\n     R (y' ## v'); \\<not> run (a ## as @- x ## u' @- x' ## y' ## v');\n     \\<lbrakk>steps (a # as @ [x, hd (u' @ [x'])]);\n      y = hd (u' @ [x'])\\<rbrakk>\n     \\<Longrightarrow> steps (a # as @ x # u' @ [x']);\n     steps ((a # as) @ [x, y])\\<rbrakk>\n    \\<Longrightarrow> steps (a # as @ x # u' @ [x'])", "by (cases u'; force elim: steps.cases)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>x y xs.\n     w = x ## y ## xs \\<and>\n     E x y \\<and>\n     ((\\<exists>w.\n          y ## xs = w \\<and>\n          (\\<exists>u v x y.\n              w = u @- x ## y ## v \\<and>\n              steps (u @ [x]) \\<and> E x y \\<and> R (y ## v))) \\<or>\n      run (y ## xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma run_flat_coinduct[case_names run_shift, consumes 1]:\n  assumes \"R xss\"\n    and\n    \"\\<And> xs ys xss.\n    R (xs ## ys ## xss) \\<Longrightarrow> xs \\<noteq> [] \\<and> steps xs \\<and> E (last xs) (hd ys) \\<and> R (ys ## xss)\"\n  shows \"run (flat xss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run (flat xss)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. run (flat xss)", "obtain xs ys xss' where \"xss = xs ## ys ## xss'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs ys xss'.\n        xss = xs ## ys ## xss' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis stream.collapse)"], ["proof (state)\nthis:\n  xss = xs ## ys ## xss'\n\ngoal (1 subgoal):\n 1. run (flat xss)", "with assms(2)[OF assms(1)[unfolded this]]"], ["proof (chain)\npicking this:\n  xs \\<noteq> [] \\<and>\n  steps xs \\<and> E (last xs) (hd ys) \\<and> R (ys ## xss')\n  xss = xs ## ys ## xss'", "show ?thesis"], ["proof (prove)\nusing this:\n  xs \\<noteq> [] \\<and>\n  steps xs \\<and> E (last xs) (hd ys) \\<and> R (ys ## xss')\n  xss = xs ## ys ## xss'\n\ngoal (1 subgoal):\n 1. run (flat xss)", "proof (coinduction arbitrary: xs ys xss' xss rule: run_shift_coinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs ys xss' xss.\n       \\<lbrakk>xs \\<noteq> [] \\<and>\n                steps xs \\<and> E (last xs) (hd ys) \\<and> R (ys ## xss');\n        xss = xs ## ys ## xss'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u v x y.\n                            flat xss = u @- x ## y ## v \\<and>\n                            steps (u @ [x]) \\<and>\n                            E x y \\<and>\n                            (\\<exists>xs ys xss' xss.\n                                y ## v = flat xss \\<and>\n                                (xs \\<noteq> [] \\<and>\n                                 steps xs \\<and>\n                                 E (last xs) (hd ys) \\<and>\n                                 R (ys ## xss')) \\<and>\n                                xss = xs ## ys ## xss')", "case (run_shift xs ys xss' xss)"], ["proof (state)\nthis:\n  xs \\<noteq> [] \\<and>\n  steps xs \\<and> E (last xs) (hd ys) \\<and> R (ys ## xss')\n  xss = xs ## ys ## xss'\n\ngoal (1 subgoal):\n 1. \\<And>xs ys xss' xss.\n       \\<lbrakk>xs \\<noteq> [] \\<and>\n                steps xs \\<and> E (last xs) (hd ys) \\<and> R (ys ## xss');\n        xss = xs ## ys ## xss'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u v x y.\n                            flat xss = u @- x ## y ## v \\<and>\n                            steps (u @ [x]) \\<and>\n                            E x y \\<and>\n                            (\\<exists>xs ys xss' xss.\n                                y ## v = flat xss \\<and>\n                                (xs \\<noteq> [] \\<and>\n                                 steps xs \\<and>\n                                 E (last xs) (hd ys) \\<and>\n                                 R (ys ## xss')) \\<and>\n                                xss = xs ## ys ## xss')", "from run_shift"], ["proof (chain)\npicking this:\n  xs \\<noteq> [] \\<and>\n  steps xs \\<and> E (last xs) (hd ys) \\<and> R (ys ## xss')\n  xss = xs ## ys ## xss'", "show ?case"], ["proof (prove)\nusing this:\n  xs \\<noteq> [] \\<and>\n  steps xs \\<and> E (last xs) (hd ys) \\<and> R (ys ## xss')\n  xss = xs ## ys ## xss'\n\ngoal (1 subgoal):\n 1. \\<exists>u v x y.\n       flat xss = u @- x ## y ## v \\<and>\n       steps (u @ [x]) \\<and>\n       E x y \\<and>\n       (\\<exists>xs ys xss' xss.\n           y ## v = flat xss \\<and>\n           (xs \\<noteq> [] \\<and>\n            steps xs \\<and>\n            E (last xs) (hd ys) \\<and> R (ys ## xss')) \\<and>\n           xss = xs ## ys ## xss')", "apply (cases xss')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>xs \\<noteq> [] \\<and>\n                steps xs \\<and> E (last xs) (hd ys) \\<and> R (ys ## xss');\n        xss = xs ## ys ## xss'; xss' = x1 ## x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u v x y.\n                            flat xss = u @- x ## y ## v \\<and>\n                            steps (u @ [x]) \\<and>\n                            E x y \\<and>\n                            (\\<exists>xs ys xss' xss.\n                                y ## v = flat xss \\<and>\n                                (xs \\<noteq> [] \\<and>\n                                 steps xs \\<and>\n                                 E (last xs) (hd ys) \\<and>\n                                 R (ys ## xss')) \\<and>\n                                xss = xs ## ys ## xss')", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>xss = xs ## ys ## x1 ## x2; xss' = x1 ## x2; xs \\<noteq> [];\n        steps xs; E (last xs) (hd ys); R (ys ## x1 ## x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u v x y.\n                            flat (xs ## ys ## x1 ## x2) =\n                            u @- x ## y ## v \\<and>\n                            steps (u @ [x]) \\<and>\n                            E x y \\<and>\n                            (\\<exists>xs ys xss' xss.\n                                y ## v = flat xss \\<and>\n                                (xs \\<noteq> [] \\<and>\n                                 steps xs \\<and>\n                                 E (last xs) (hd ys) \\<and>\n                                 R (ys ## xss')) \\<and>\n                                xss = xs ## ys ## xss')", "apply (drule assms(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>xss = xs ## ys ## x1 ## x2; xss' = x1 ## x2; xs \\<noteq> [];\n        steps xs; E (last xs) (hd ys);\n        ys \\<noteq> [] \\<and>\n        steps ys \\<and> E (last ys) (hd x1) \\<and> R (x1 ## x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u v x y.\n                            flat (xs ## ys ## x1 ## x2) =\n                            u @- x ## y ## v \\<and>\n                            steps (u @ [x]) \\<and>\n                            E x y \\<and>\n                            (\\<exists>xs ys xss' xss.\n                                y ## v = flat xss \\<and>\n                                (xs \\<noteq> [] \\<and>\n                                 steps xs \\<and>\n                                 E (last xs) (hd ys) \\<and>\n                                 R (ys ## xss')) \\<and>\n                                xss = xs ## ys ## xss')", "apply (inst_existentials \"butlast xs\" \"tl ys @- flat xss'\" \"last xs\" \"hd ys\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>xss = xs ## ys ## x1 ## x2; xss' = x1 ## x2; xs \\<noteq> [];\n        steps xs; E (last xs) (hd ys);\n        ys \\<noteq> [] \\<and>\n        steps ys \\<and> E (last ys) (hd x1) \\<and> R (x1 ## x2)\\<rbrakk>\n       \\<Longrightarrow> flat (xs ## ys ## x1 ## x2) =\n                         butlast xs @-\n                         last xs ## hd ys ## tl ys @- flat xss'\n 2. \\<And>x1 x2.\n       \\<lbrakk>xss = xs ## ys ## x1 ## x2; xss' = x1 ## x2; xs \\<noteq> [];\n        steps xs; E (last xs) (hd ys);\n        ys \\<noteq> [] \\<and>\n        steps ys \\<and> E (last ys) (hd x1) \\<and> R (x1 ## x2)\\<rbrakk>\n       \\<Longrightarrow> steps (butlast xs @ [last xs])\n 3. \\<And>x1 x2.\n       \\<lbrakk>xss = xs ## ys ## x1 ## x2; xss' = x1 ## x2; xs \\<noteq> [];\n        steps xs; E (last xs) (hd ys);\n        ys \\<noteq> [] \\<and>\n        steps ys \\<and> E (last ys) (hd x1) \\<and> R (x1 ## x2)\\<rbrakk>\n       \\<Longrightarrow> E (last xs) (hd ys)\n 4. \\<And>x1 x2.\n       \\<lbrakk>xss = xs ## ys ## x1 ## x2; xss' = x1 ## x2; xs \\<noteq> [];\n        steps xs; E (last xs) (hd ys);\n        ys \\<noteq> [] \\<and>\n        steps ys \\<and> E (last ys) (hd x1) \\<and> R (x1 ## x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys xss' xss.\n                            hd ys ## tl ys @- flat xss' = flat xss \\<and>\n                            (xs \\<noteq> [] \\<and>\n                             steps xs \\<and>\n                             E (last xs) (hd ys) \\<and>\n                             R (ys ## xss')) \\<and>\n                            xss = xs ## ys ## xss'", "apply (cases ys)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>xss = xs ## ys ## x1 ## x2; xss' = x1 ## x2; xs \\<noteq> [];\n        steps xs; E (last xs) (hd ys);\n        ys \\<noteq> [] \\<and>\n        steps ys \\<and> E (last ys) (hd x1) \\<and> R (x1 ## x2);\n        ys = []\\<rbrakk>\n       \\<Longrightarrow> flat (xs ## ys ## x1 ## x2) =\n                         butlast xs @-\n                         last xs ## hd ys ## tl ys @- flat xss'\n 2. \\<And>x1 x2 a list.\n       \\<lbrakk>xss = xs ## ys ## x1 ## x2; xss' = x1 ## x2; xs \\<noteq> [];\n        steps xs; E (last xs) (hd ys);\n        ys \\<noteq> [] \\<and>\n        steps ys \\<and> E (last ys) (hd x1) \\<and> R (x1 ## x2);\n        ys = a # list\\<rbrakk>\n       \\<Longrightarrow> flat (xs ## ys ## x1 ## x2) =\n                         butlast xs @-\n                         last xs ## hd ys ## tl ys @- flat xss'\n 3. \\<And>x1 x2.\n       \\<lbrakk>xss = xs ## ys ## x1 ## x2; xss' = x1 ## x2; xs \\<noteq> [];\n        steps xs; E (last xs) (hd ys);\n        ys \\<noteq> [] \\<and>\n        steps ys \\<and> E (last ys) (hd x1) \\<and> R (x1 ## x2)\\<rbrakk>\n       \\<Longrightarrow> steps (butlast xs @ [last xs])\n 4. \\<And>x1 x2.\n       \\<lbrakk>xss = xs ## ys ## x1 ## x2; xss' = x1 ## x2; xs \\<noteq> [];\n        steps xs; E (last xs) (hd ys);\n        ys \\<noteq> [] \\<and>\n        steps ys \\<and> E (last ys) (hd x1) \\<and> R (x1 ## x2)\\<rbrakk>\n       \\<Longrightarrow> E (last xs) (hd ys)\n 5. \\<And>x1 x2.\n       \\<lbrakk>xss = xs ## ys ## x1 ## x2; xss' = x1 ## x2; xs \\<noteq> [];\n        steps xs; E (last xs) (hd ys);\n        ys \\<noteq> [] \\<and>\n        steps ys \\<and> E (last ys) (hd x1) \\<and> R (x1 ## x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys xss' xss.\n                            hd ys ## tl ys @- flat xss' = flat xss \\<and>\n                            (xs \\<noteq> [] \\<and>\n                             steps xs \\<and>\n                             E (last xs) (hd ys) \\<and>\n                             R (ys ## xss')) \\<and>\n                            xss = xs ## ys ## xss'", "apply (simp; fail)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1 x2 a list.\n       \\<lbrakk>xss = xs ## ys ## x1 ## x2; xss' = x1 ## x2; xs \\<noteq> [];\n        steps xs; E (last xs) (hd ys);\n        ys \\<noteq> [] \\<and>\n        steps ys \\<and> E (last ys) (hd x1) \\<and> R (x1 ## x2);\n        ys = a # list\\<rbrakk>\n       \\<Longrightarrow> flat (xs ## ys ## x1 ## x2) =\n                         butlast xs @-\n                         last xs ## hd ys ## tl ys @- flat xss'\n 2. \\<And>x1 x2.\n       \\<lbrakk>xss = xs ## ys ## x1 ## x2; xss' = x1 ## x2; xs \\<noteq> [];\n        steps xs; E (last xs) (hd ys);\n        ys \\<noteq> [] \\<and>\n        steps ys \\<and> E (last ys) (hd x1) \\<and> R (x1 ## x2)\\<rbrakk>\n       \\<Longrightarrow> steps (butlast xs @ [last xs])\n 3. \\<And>x1 x2.\n       \\<lbrakk>xss = xs ## ys ## x1 ## x2; xss' = x1 ## x2; xs \\<noteq> [];\n        steps xs; E (last xs) (hd ys);\n        ys \\<noteq> [] \\<and>\n        steps ys \\<and> E (last ys) (hd x1) \\<and> R (x1 ## x2)\\<rbrakk>\n       \\<Longrightarrow> E (last xs) (hd ys)\n 4. \\<And>x1 x2.\n       \\<lbrakk>xss = xs ## ys ## x1 ## x2; xss' = x1 ## x2; xs \\<noteq> [];\n        steps xs; E (last xs) (hd ys);\n        ys \\<noteq> [] \\<and>\n        steps ys \\<and> E (last ys) (hd x1) \\<and> R (x1 ## x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys xss' xss.\n                            hd ys ## tl ys @- flat xss' = flat xss \\<and>\n                            (xs \\<noteq> [] \\<and>\n                             steps xs \\<and>\n                             E (last xs) (hd ys) \\<and>\n                             R (ys ## xss')) \\<and>\n                            xss = xs ## ys ## xss'", "subgoal premises prems for x1 x2 z zs"], ["proof (prove)\ngoal (1 subgoal):\n 1. flat (xs ## ys ## x1 ## x2) =\n    butlast xs @- last xs ## hd ys ## tl ys @- flat xss'", "proof (cases \"xs = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    flat (xs ## ys ## x1 ## x2) =\n    butlast xs @- last xs ## hd ys ## tl ys @- flat xss'\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    flat (xs ## ys ## x1 ## x2) =\n    butlast xs @- last xs ## hd ys ## tl ys @- flat xss'", "case True"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    flat (xs ## ys ## x1 ## x2) =\n    butlast xs @- last xs ## hd ys ## tl ys @- flat xss'\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    flat (xs ## ys ## x1 ## x2) =\n    butlast xs @- last xs ## hd ys ## tl ys @- flat xss'", "with prems"], ["proof (chain)\npicking this:\n  xss = xs ## ys ## x1 ## x2\n  xss' = x1 ## x2\n  xs \\<noteq> []\n  steps xs\n  E (last xs) (hd ys)\n  ys \\<noteq> [] \\<and>\n  steps ys \\<and> E (last ys) (hd x1) \\<and> R (x1 ## x2)\n  ys = z # zs\n  xs = []", "show ?thesis"], ["proof (prove)\nusing this:\n  xss = xs ## ys ## x1 ## x2\n  xss' = x1 ## x2\n  xs \\<noteq> []\n  steps xs\n  E (last xs) (hd ys)\n  ys \\<noteq> [] \\<and>\n  steps ys \\<and> E (last ys) (hd x1) \\<and> R (x1 ## x2)\n  ys = z # zs\n  xs = []\n\ngoal (1 subgoal):\n 1. flat (xs ## ys ## x1 ## x2) =\n    butlast xs @- last xs ## hd ys ## tl ys @- flat xss'", "by auto"], ["proof (state)\nthis:\n  flat (xs ## ys ## x1 ## x2) =\n  butlast xs @- last xs ## hd ys ## tl ys @- flat xss'\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    flat (xs ## ys ## x1 ## x2) =\n    butlast xs @- last xs ## hd ys ## tl ys @- flat xss'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    flat (xs ## ys ## x1 ## x2) =\n    butlast xs @- last xs ## hd ys ## tl ys @- flat xss'", "case False"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    flat (xs ## ys ## x1 ## x2) =\n    butlast xs @- last xs ## hd ys ## tl ys @- flat xss'", "then"], ["proof (chain)\npicking this:\n  xs \\<noteq> []", "have \"xs = butlast xs @ [last xs]\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs = butlast xs @ [last xs]", "by auto"], ["proof (state)\nthis:\n  xs = butlast xs @ [last xs]\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    flat (xs ## ys ## x1 ## x2) =\n    butlast xs @- last xs ## hd ys ## tl ys @- flat xss'", "then"], ["proof (chain)\npicking this:\n  xs = butlast xs @ [last xs]", "have \"butlast xs @- last xs ## tail = xs @- tail\" for tail"], ["proof (prove)\nusing this:\n  xs = butlast xs @ [last xs]\n\ngoal (1 subgoal):\n 1. butlast xs @- last xs ## tail = xs @- tail", "by (metis shift.simps(1,2) shift_append)"], ["proof (state)\nthis:\n  butlast xs @- last xs ## ?tail = xs @- ?tail\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    flat (xs ## ys ## x1 ## x2) =\n    butlast xs @- last xs ## hd ys ## tl ys @- flat xss'", "with prems"], ["proof (chain)\npicking this:\n  xss = xs ## ys ## x1 ## x2\n  xss' = x1 ## x2\n  xs \\<noteq> []\n  steps xs\n  E (last xs) (hd ys)\n  ys \\<noteq> [] \\<and>\n  steps ys \\<and> E (last ys) (hd x1) \\<and> R (x1 ## x2)\n  ys = z # zs\n  butlast xs @- last xs ## ?tail = xs @- ?tail", "show ?thesis"], ["proof (prove)\nusing this:\n  xss = xs ## ys ## x1 ## x2\n  xss' = x1 ## x2\n  xs \\<noteq> []\n  steps xs\n  E (last xs) (hd ys)\n  ys \\<noteq> [] \\<and>\n  steps ys \\<and> E (last ys) (hd x1) \\<and> R (x1 ## x2)\n  ys = z # zs\n  butlast xs @- last xs ## ?tail = xs @- ?tail\n\ngoal (1 subgoal):\n 1. flat (xs ## ys ## x1 ## x2) =\n    butlast xs @- last xs ## hd ys ## tl ys @- flat xss'", "by simp"], ["proof (state)\nthis:\n  flat (xs ## ys ## x1 ## x2) =\n  butlast xs @- last xs ## hd ys ## tl ys @- flat xss'\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>xss = xs ## ys ## x1 ## x2; xss' = x1 ## x2; xs \\<noteq> [];\n        steps xs; E (last xs) (hd ys);\n        ys \\<noteq> [] \\<and>\n        steps ys \\<and> E (last ys) (hd x1) \\<and> R (x1 ## x2)\\<rbrakk>\n       \\<Longrightarrow> steps (butlast xs @ [last xs])\n 2. \\<And>x1 x2.\n       \\<lbrakk>xss = xs ## ys ## x1 ## x2; xss' = x1 ## x2; xs \\<noteq> [];\n        steps xs; E (last xs) (hd ys);\n        ys \\<noteq> [] \\<and>\n        steps ys \\<and> E (last ys) (hd x1) \\<and> R (x1 ## x2)\\<rbrakk>\n       \\<Longrightarrow> E (last xs) (hd ys)\n 3. \\<And>x1 x2.\n       \\<lbrakk>xss = xs ## ys ## x1 ## x2; xss' = x1 ## x2; xs \\<noteq> [];\n        steps xs; E (last xs) (hd ys);\n        ys \\<noteq> [] \\<and>\n        steps ys \\<and> E (last ys) (hd x1) \\<and> R (x1 ## x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys xss' xss.\n                            hd ys ## tl ys @- flat xss' = flat xss \\<and>\n                            (xs \\<noteq> [] \\<and>\n                             steps xs \\<and>\n                             E (last xs) (hd ys) \\<and>\n                             R (ys ## xss')) \\<and>\n                            xss = xs ## ys ## xss'", "apply (simp; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>xss = xs ## ys ## x1 ## x2; xss' = x1 ## x2; xs \\<noteq> [];\n        steps xs; E (last xs) (hd ys);\n        ys \\<noteq> [] \\<and>\n        steps ys \\<and> E (last ys) (hd x1) \\<and> R (x1 ## x2)\\<rbrakk>\n       \\<Longrightarrow> E (last xs) (hd ys)\n 2. \\<And>x1 x2.\n       \\<lbrakk>xss = xs ## ys ## x1 ## x2; xss' = x1 ## x2; xs \\<noteq> [];\n        steps xs; E (last xs) (hd ys);\n        ys \\<noteq> [] \\<and>\n        steps ys \\<and> E (last ys) (hd x1) \\<and> R (x1 ## x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys xss' xss.\n                            hd ys ## tl ys @- flat xss' = flat xss \\<and>\n                            (xs \\<noteq> [] \\<and>\n                             steps xs \\<and>\n                             E (last xs) (hd ys) \\<and>\n                             R (ys ## xss')) \\<and>\n                            xss = xs ## ys ## xss'", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>xss = xs ## ys ## x1 ## x2; xss' = x1 ## x2; xs \\<noteq> [];\n        steps xs; E (last xs) (hd ys);\n        ys \\<noteq> [] \\<and>\n        steps ys \\<and> E (last ys) (hd x1) \\<and> R (x1 ## x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys xss' xss.\n                            hd ys ## tl ys @- flat xss' = flat xss \\<and>\n                            (xs \\<noteq> [] \\<and>\n                             steps xs \\<and>\n                             E (last xs) (hd ys) \\<and>\n                             R (ys ## xss')) \\<and>\n                            xss = xs ## ys ## xss'", "subgoal for ws wss"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xss = xs ## ys ## ws ## wss; xss' = ws ## wss; xs \\<noteq> [];\n     steps xs; E (last xs) (hd ys);\n     ys \\<noteq> [] \\<and>\n     steps ys \\<and> E (last ys) (hd ws) \\<and> R (ws ## wss)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs ys xss' xss.\n                         hd ys ## tl ys @- flat xss' = flat xss \\<and>\n                         (xs \\<noteq> [] \\<and>\n                          steps xs \\<and>\n                          E (last xs) (hd ys) \\<and> R (ys ## xss')) \\<and>\n                         xss = xs ## ys ## xss'", "by (inst_existentials ys ws wss) (cases ys, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>u v x y.\n     flat xss = u @- x ## y ## v \\<and>\n     steps (u @ [x]) \\<and>\n     E x y \\<and>\n     (\\<exists>xs ys xss' xss.\n         y ## v = flat xss \\<and>\n         (xs \\<noteq> [] \\<and>\n          steps xs \\<and> E (last xs) (hd ys) \\<and> R (ys ## xss')) \\<and>\n         xss = xs ## ys ## xss')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  run (flat xss)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma steps_non_empty[simp]:\n  \"\\<not> steps []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> steps []", "by (auto elim: steps.cases)"], ["", "lemma steps_non_empty'[simp]:\n  \"xs \\<noteq> []\" if \"steps xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "using that"], ["proof (prove)\nusing this:\n  steps xs\n\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "by auto"], ["", "(* XXX Generalize *)"], ["", "lemma steps_replicate:\n  \"steps (hd xs # concat (replicate n (tl xs)))\" if \"last xs = hd xs\" \"steps xs\" \"n > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps (hd xs # concat (replicate n (tl xs)))", "using that"], ["proof (prove)\nusing this:\n  last xs = hd xs\n  steps xs\n  0 < n\n\ngoal (1 subgoal):\n 1. steps (hd xs # concat (replicate n (tl xs)))", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>last xs = hd xs; steps xs; 0 < 0\\<rbrakk>\n    \\<Longrightarrow> steps (hd xs # concat (replicate 0 (tl xs)))\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>last xs = hd xs; steps xs; 0 < n\\<rbrakk>\n                \\<Longrightarrow> steps\n                                   (hd xs # concat (replicate n (tl xs)));\n        last xs = hd xs; steps xs; 0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> steps (hd xs # concat (replicate (Suc n) (tl xs)))", "case 0"], ["proof (state)\nthis:\n  last xs = hd xs\n  steps xs\n  0 < 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>last xs = hd xs; steps xs; 0 < 0\\<rbrakk>\n    \\<Longrightarrow> steps (hd xs # concat (replicate 0 (tl xs)))\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>last xs = hd xs; steps xs; 0 < n\\<rbrakk>\n                \\<Longrightarrow> steps\n                                   (hd xs # concat (replicate n (tl xs)));\n        last xs = hd xs; steps xs; 0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> steps (hd xs # concat (replicate (Suc n) (tl xs)))", "then"], ["proof (chain)\npicking this:\n  last xs = hd xs\n  steps xs\n  0 < 0", "show ?case"], ["proof (prove)\nusing this:\n  last xs = hd xs\n  steps xs\n  0 < 0\n\ngoal (1 subgoal):\n 1. steps (hd xs # concat (replicate 0 (tl xs)))", "by simp"], ["proof (state)\nthis:\n  steps (hd xs # concat (replicate 0 (tl xs)))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>last xs = hd xs; steps xs; 0 < n\\<rbrakk>\n                \\<Longrightarrow> steps\n                                   (hd xs # concat (replicate n (tl xs)));\n        last xs = hd xs; steps xs; 0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> steps (hd xs # concat (replicate (Suc n) (tl xs)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>last xs = hd xs; steps xs; 0 < n\\<rbrakk>\n                \\<Longrightarrow> steps\n                                   (hd xs # concat (replicate n (tl xs)));\n        last xs = hd xs; steps xs; 0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> steps (hd xs # concat (replicate (Suc n) (tl xs)))", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>last xs = hd xs; steps xs; 0 < n\\<rbrakk>\n  \\<Longrightarrow> steps (hd xs # concat (replicate n (tl xs)))\n  last xs = hd xs\n  steps xs\n  0 < Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>last xs = hd xs; steps xs; 0 < n\\<rbrakk>\n                \\<Longrightarrow> steps\n                                   (hd xs # concat (replicate n (tl xs)));\n        last xs = hd xs; steps xs; 0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> steps (hd xs # concat (replicate (Suc n) (tl xs)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. steps (hd xs # concat (replicate (Suc n) (tl xs)))", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    steps (hd xs # concat (replicate (Suc n) (tl xs)))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       steps (hd xs # concat (replicate (Suc n) (tl xs)))", "case 0"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    steps (hd xs # concat (replicate (Suc n) (tl xs)))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       steps (hd xs # concat (replicate (Suc n) (tl xs)))", "with Suc.prems"], ["proof (chain)\npicking this:\n  last xs = hd xs\n  steps xs\n  0 < Suc n\n  n = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  last xs = hd xs\n  steps xs\n  0 < Suc n\n  n = 0\n\ngoal (1 subgoal):\n 1. steps (hd xs # concat (replicate (Suc n) (tl xs)))", "by (cases xs; auto)"], ["proof (state)\nthis:\n  steps (hd xs # concat (replicate (Suc n) (tl xs)))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       steps (hd xs # concat (replicate (Suc n) (tl xs)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       steps (hd xs # concat (replicate (Suc n) (tl xs)))", "case prems: (Suc nat)"], ["proof (state)\nthis:\n  n = Suc nat\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       steps (hd xs # concat (replicate (Suc n) (tl xs)))", "from Suc.prems"], ["proof (chain)\npicking this:\n  last xs = hd xs\n  steps xs\n  0 < Suc n", "have [simp]: \"hd xs # tl xs @ ys = xs @ ys\" for ys"], ["proof (prove)\nusing this:\n  last xs = hd xs\n  steps xs\n  0 < Suc n\n\ngoal (1 subgoal):\n 1. hd xs # tl xs @ ys = xs @ ys", "by (cases xs; auto)"], ["proof (state)\nthis:\n  hd xs # tl xs @ ?ys = xs @ ?ys\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       steps (hd xs # concat (replicate (Suc n) (tl xs)))", "from Suc.prems"], ["proof (chain)\npicking this:\n  last xs = hd xs\n  steps xs\n  0 < Suc n", "have **: \"tl xs @ ys = tl (xs @ ys)\" for ys"], ["proof (prove)\nusing this:\n  last xs = hd xs\n  steps xs\n  0 < Suc n\n\ngoal (1 subgoal):\n 1. tl xs @ ys = tl (xs @ ys)", "by (cases xs; auto)"], ["proof (state)\nthis:\n  tl xs @ ?ys = tl (xs @ ?ys)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       steps (hd xs # concat (replicate (Suc n) (tl xs)))", "from prems Suc"], ["proof (chain)\npicking this:\n  n = Suc nat\n  \\<lbrakk>last xs = hd xs; steps xs; 0 < n\\<rbrakk>\n  \\<Longrightarrow> steps (hd xs # concat (replicate n (tl xs)))\n  last xs = hd xs\n  steps xs\n  0 < Suc n", "show ?thesis"], ["proof (prove)\nusing this:\n  n = Suc nat\n  \\<lbrakk>last xs = hd xs; steps xs; 0 < n\\<rbrakk>\n  \\<Longrightarrow> steps (hd xs # concat (replicate n (tl xs)))\n  last xs = hd xs\n  steps xs\n  0 < Suc n\n\ngoal (1 subgoal):\n 1. steps (hd xs # concat (replicate (Suc n) (tl xs)))", "by (fastforce intro: steps_append')"], ["proof (state)\nthis:\n  steps (hd xs # concat (replicate (Suc n) (tl xs)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  steps (hd xs # concat (replicate (Suc n) (tl xs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "notation E (\"_ \\<rightarrow> _\" [100, 100] 40)"], ["", "abbreviation reaches (\"_ \\<rightarrow>* _\" [100, 100] 40) where \"reaches x y \\<equiv> E\\<^sup>*\\<^sup>* x y\""], ["", "abbreviation reaches1 (\"_ \\<rightarrow>\\<^sup>+ _\" [100, 100] 40) where \"reaches1 x y \\<equiv> E\\<^sup>+\\<^sup>+ x y\""], ["", "lemma steps_reaches:\n  \"hd xs \\<rightarrow>* last xs\" if \"steps xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd xs \\<rightarrow>* last xs", "using that"], ["proof (prove)\nusing this:\n  steps xs\n\ngoal (1 subgoal):\n 1. hd xs \\<rightarrow>* last xs", "by (induction xs) auto"], ["", "lemma steps_reaches':\n  \"x \\<rightarrow>* y\" if \"steps xs\" \"hd xs = x\" \"last xs = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<rightarrow>* y", "using that steps_reaches"], ["proof (prove)\nusing this:\n  steps xs\n  hd xs = x\n  last xs = y\n  steps ?xs \\<Longrightarrow> hd ?xs \\<rightarrow>* last ?xs\n\ngoal (1 subgoal):\n 1. x \\<rightarrow>* y", "by auto"], ["", "lemma reaches_steps:\n  \"\\<exists> xs. hd xs = x \\<and> last xs = y \\<and> steps xs\" if \"x \\<rightarrow>* y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs. hd xs = x \\<and> last xs = y \\<and> steps xs", "using that"], ["proof (prove)\nusing this:\n  x \\<rightarrow>* y\n\ngoal (1 subgoal):\n 1. \\<exists>xs. hd xs = x \\<and> last xs = y \\<and> steps xs", "apply (induction)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>xs. hd xs = x \\<and> last xs = x \\<and> steps xs\n 2. \\<And>y z.\n       \\<lbrakk>x \\<rightarrow>* y; y \\<rightarrow> z;\n        \\<exists>xs. hd xs = x \\<and> last xs = y \\<and> steps xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            hd xs = x \\<and> last xs = z \\<and> steps xs", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>x \\<rightarrow>* y; y \\<rightarrow> z;\n        \\<exists>xs. hd xs = x \\<and> last xs = y \\<and> steps xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            hd xs = x \\<and> last xs = z \\<and> steps xs", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z xs.\n       \\<lbrakk>hd xs \\<rightarrow>* last xs; last xs \\<rightarrow> z;\n        x = hd xs; steps xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa.\n                            hd xsa = hd xs \\<and>\n                            last xsa = z \\<and> steps xsa", "subgoal for z xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hd xs \\<rightarrow>* last xs; last xs \\<rightarrow> z;\n     x = hd xs; steps xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xsa.\n                         hd xsa = hd xs \\<and> last xsa = z \\<and> steps xsa", "by (inst_existentials \"xs @ [z]\", (cases xs; simp), auto intro: steps_append_single)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma reaches_steps_iff:\n  \"x \\<rightarrow>* y \\<longleftrightarrow> (\\<exists> xs. hd xs = x \\<and> last xs = y \\<and> steps xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<rightarrow>* y) =\n    (\\<exists>xs. hd xs = x \\<and> last xs = y \\<and> steps xs)", "using steps_reaches reaches_steps"], ["proof (prove)\nusing this:\n  steps ?xs \\<Longrightarrow> hd ?xs \\<rightarrow>* last ?xs\n  ?x \\<rightarrow>* ?y \\<Longrightarrow>\n  \\<exists>xs. hd xs = ?x \\<and> last xs = ?y \\<and> steps xs\n\ngoal (1 subgoal):\n 1. (x \\<rightarrow>* y) =\n    (\\<exists>xs. hd xs = x \\<and> last xs = y \\<and> steps xs)", "by fast"], ["", "lemma steps_reaches1:\n  \"x \\<rightarrow>\\<^sup>+ y\" if \"steps (x # xs @ [y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<rightarrow>\\<^sup>+ y", "by (metis list.sel(1,3) rtranclp_into_tranclp2 snoc_eq_iff_butlast steps.cases steps_reaches that)"], ["", "lemma stepsI:\n  \"steps (x # xs)\" if \"x \\<rightarrow> hd xs\" \"steps xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps (x # xs)", "using that"], ["proof (prove)\nusing this:\n  x \\<rightarrow> hd xs\n  steps xs\n\ngoal (1 subgoal):\n 1. steps (x # xs)", "by (cases xs) auto"], ["", "lemma reaches1_steps:\n  \"\\<exists> xs. steps (x # xs @ [y])\" if \"x \\<rightarrow>\\<^sup>+ y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs. steps (x # xs @ [y])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xs. steps (x # xs @ [y])", "from that"], ["proof (chain)\npicking this:\n  x \\<rightarrow>\\<^sup>+ y", "obtain z where \"x \\<rightarrow> z\" \"z \\<rightarrow>* y\""], ["proof (prove)\nusing this:\n  x \\<rightarrow>\\<^sup>+ y\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>x \\<rightarrow> z; z \\<rightarrow>* y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by atomize_elim (simp add: tranclpD)"], ["proof (state)\nthis:\n  x \\<rightarrow> z\n  z \\<rightarrow>* y\n\ngoal (1 subgoal):\n 1. \\<exists>xs. steps (x # xs @ [y])", "from reaches_steps[OF this(2)]"], ["proof (chain)\npicking this:\n  \\<exists>xs. hd xs = z \\<and> last xs = y \\<and> steps xs", "obtain xs where *: \"hd xs = z\" \"last xs = y\" \"steps xs\""], ["proof (prove)\nusing this:\n  \\<exists>xs. hd xs = z \\<and> last xs = y \\<and> steps xs\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>hd xs = z; last xs = y; steps xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  hd xs = z\n  last xs = y\n  steps xs\n\ngoal (1 subgoal):\n 1. \\<exists>xs. steps (x # xs @ [y])", "then"], ["proof (chain)\npicking this:\n  hd xs = z\n  last xs = y\n  steps xs", "obtain xs' where [simp]: \"xs = xs' @ [y]\""], ["proof (prove)\nusing this:\n  hd xs = z\n  last xs = y\n  steps xs\n\ngoal (1 subgoal):\n 1. (\\<And>xs'. xs = xs' @ [y] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by atomize_elim (auto 4 3 intro: append_butlast_last_id[symmetric])"], ["proof (state)\nthis:\n  xs = xs' @ [y]\n\ngoal (1 subgoal):\n 1. \\<exists>xs. steps (x # xs @ [y])", "with \\<open>x \\<rightarrow> z\\<close> *"], ["proof (chain)\npicking this:\n  x \\<rightarrow> z\n  hd xs = z\n  last xs = y\n  steps xs\n  xs = xs' @ [y]", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<rightarrow> z\n  hd xs = z\n  last xs = y\n  steps xs\n  xs = xs' @ [y]\n\ngoal (1 subgoal):\n 1. \\<exists>xs. steps (x # xs @ [y])", "by (auto intro: stepsI)"], ["proof (state)\nthis:\n  \\<exists>xs. steps (x # xs @ [y])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reaches1_steps_iff:\n  \"x \\<rightarrow>\\<^sup>+ y \\<longleftrightarrow> (\\<exists> xs. steps (x # xs @ [y]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<rightarrow>\\<^sup>+ y) = (\\<exists>xs. steps (x # xs @ [y]))", "using steps_reaches1 reaches1_steps"], ["proof (prove)\nusing this:\n  steps (?x # ?xs @ [?y]) \\<Longrightarrow> ?x \\<rightarrow>\\<^sup>+ ?y\n  ?x \\<rightarrow>\\<^sup>+ ?y \\<Longrightarrow>\n  \\<exists>xs. steps (?x # xs @ [?y])\n\ngoal (1 subgoal):\n 1. (x \\<rightarrow>\\<^sup>+ y) = (\\<exists>xs. steps (x # xs @ [y]))", "by fast"], ["", "lemma reaches1_reaches_iff1:\n  \"x \\<rightarrow>\\<^sup>+ y \\<longleftrightarrow> (\\<exists> z. x \\<rightarrow> z \\<and> z \\<rightarrow>* y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<rightarrow>\\<^sup>+ y) =\n    (\\<exists>z. x \\<rightarrow> z \\<and> z \\<rightarrow>* y)", "by (auto dest: tranclpD)"], ["", "lemma reaches1_reaches_iff2:\n  \"x \\<rightarrow>\\<^sup>+ y \\<longleftrightarrow> (\\<exists> z. x \\<rightarrow>* z \\<and> z \\<rightarrow> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<rightarrow>\\<^sup>+ y) =\n    (\\<exists>z. x \\<rightarrow>* z \\<and> z \\<rightarrow> y)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<rightarrow>\\<^sup>+ y \\<Longrightarrow>\n    \\<exists>z. x \\<rightarrow>* z \\<and> z \\<rightarrow> y\n 2. \\<And>z.\n       \\<lbrakk>x \\<rightarrow>* z; z \\<rightarrow> y\\<rbrakk>\n       \\<Longrightarrow> x \\<rightarrow>\\<^sup>+ y", "apply (metis Nitpick.rtranclp_unfold tranclp.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>x \\<rightarrow>* z; z \\<rightarrow> y\\<rbrakk>\n       \\<Longrightarrow> x \\<rightarrow>\\<^sup>+ y", "by auto"], ["", "lemma\n  \"x \\<rightarrow>\\<^sup>+ z\" if \"x \\<rightarrow>* y\" \"y \\<rightarrow>\\<^sup>+ z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<rightarrow>\\<^sup>+ z", "using that"], ["proof (prove)\nusing this:\n  x \\<rightarrow>* y\n  y \\<rightarrow>\\<^sup>+ z\n\ngoal (1 subgoal):\n 1. x \\<rightarrow>\\<^sup>+ z", "by auto"], ["", "lemma\n  \"x \\<rightarrow>\\<^sup>+ z\" if \"x \\<rightarrow>\\<^sup>+ y\" \"y \\<rightarrow>* z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<rightarrow>\\<^sup>+ z", "using that"], ["proof (prove)\nusing this:\n  x \\<rightarrow>\\<^sup>+ y\n  y \\<rightarrow>* z\n\ngoal (1 subgoal):\n 1. x \\<rightarrow>\\<^sup>+ z", "by auto"], ["", "lemma steps_append2:\n  \"steps (xs @ x # ys)\" if \"steps (xs @ [x])\" \"steps (x # ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps (xs @ x # ys)", "using that"], ["proof (prove)\nusing this:\n  steps (xs @ [x])\n  steps (x # ys)\n\ngoal (1 subgoal):\n 1. steps (xs @ x # ys)", "by (auto dest: steps_append)"], ["", "lemma reaches1_steps_append:\n  assumes \"a \\<rightarrow>\\<^sup>+ b\" \"steps xs\" \"hd xs = b\"\n  shows \"\\<exists> ys. steps (a # ys @ xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ys. steps (a # ys @ xs)", "using assms"], ["proof (prove)\nusing this:\n  a \\<rightarrow>\\<^sup>+ b\n  steps xs\n  hd xs = b\n\ngoal (1 subgoal):\n 1. \\<exists>ys. steps (a # ys @ xs)", "by (fastforce intro: steps_append' dest: reaches1_steps)"], ["", "lemma steps_last_step:\n  \"\\<exists> a. a \\<rightarrow> last xs\" if \"steps xs\" \"length xs > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. a \\<rightarrow> last xs", "using that"], ["proof (prove)\nusing this:\n  steps xs\n  1 < length xs\n\ngoal (1 subgoal):\n 1. \\<exists>a. a \\<rightarrow> last xs", "by induction auto"], ["", "lemmas graphI =\n  steps.intros\n  steps_append_single\n  steps_reaches'\n  stepsI"], ["", "end"], ["", "(* Graph Defs *)"], ["", "subsection \\<open>Graphs with a Start Node\\<close>"], ["", "locale Graph_Start_Defs = Graph_Defs +\n  fixes s\\<^sub>0 :: 'a\nbegin"], ["", "definition reachable where\n  \"reachable = E\\<^sup>*\\<^sup>* s\\<^sub>0\""], ["", "lemma start_reachable[intro!, simp]:\n  \"reachable s\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable s\\<^sub>0", "unfolding reachable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<^sub>0 \\<rightarrow>* s\\<^sub>0", "by auto"], ["", "lemma reachable_step:\n  \"reachable b\" if \"reachable a\" \"E a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable b", "using that"], ["proof (prove)\nusing this:\n  reachable a\n  a \\<rightarrow> b\n\ngoal (1 subgoal):\n 1. reachable b", "unfolding reachable_def"], ["proof (prove)\nusing this:\n  s\\<^sub>0 \\<rightarrow>* a\n  a \\<rightarrow> b\n\ngoal (1 subgoal):\n 1. s\\<^sub>0 \\<rightarrow>* b", "by auto"], ["", "lemma reachable_reaches:\n  \"reachable b\" if \"reachable a\" \"a \\<rightarrow>* b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable b", "using that(2,1)"], ["proof (prove)\nusing this:\n  a \\<rightarrow>* b\n  reachable a\n\ngoal (1 subgoal):\n 1. reachable b", "by induction (auto intro: reachable_step)"], ["", "lemma reachable_steps_append:\n  assumes \"reachable a\" \"steps xs\" \"hd xs = a\" \"last xs = b\"\n  shows \"reachable b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable b", "using assms"], ["proof (prove)\nusing this:\n  reachable a\n  steps xs\n  hd xs = a\n  last xs = b\n\ngoal (1 subgoal):\n 1. reachable b", "by (auto intro: graphI reachable_reaches)"], ["", "lemmas steps_reachable = reachable_steps_append[of s\\<^sub>0, simplified]"], ["", "lemma reachable_steps_elem:\n  \"reachable y\" if \"reachable x\" \"steps xs\" \"y \\<in> set xs\" \"hd xs = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. reachable y", "from \\<open>y \\<in> set xs\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> set xs", "obtain as bs where [simp]: \"xs = as @ y # bs\""], ["proof (prove)\nusing this:\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>as bs.\n        xs = as @ y # bs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: in_set_conv_decomp)"], ["proof (state)\nthis:\n  xs = as @ y # bs\n\ngoal (1 subgoal):\n 1. reachable y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable y", "proof (cases \"as = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow> reachable y\n 2. as \\<noteq> [] \\<Longrightarrow> reachable y", "case True"], ["proof (state)\nthis:\n  as = []\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow> reachable y\n 2. as \\<noteq> [] \\<Longrightarrow> reachable y", "with that"], ["proof (chain)\npicking this:\n  reachable x\n  steps xs\n  y \\<in> set xs\n  hd xs = x\n  as = []", "show ?thesis"], ["proof (prove)\nusing this:\n  reachable x\n  steps xs\n  y \\<in> set xs\n  hd xs = x\n  as = []\n\ngoal (1 subgoal):\n 1. reachable y", "by simp"], ["proof (state)\nthis:\n  reachable y\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow> reachable y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow> reachable y", "case False"], ["proof (state)\nthis:\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow> reachable y", "(* XXX *)"], ["proof (state)\nthis:\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow> reachable y", "from \\<open>steps xs\\<close>"], ["proof (chain)\npicking this:\n  steps xs", "have \"steps (as @ [y])\""], ["proof (prove)\nusing this:\n  steps xs\n\ngoal (1 subgoal):\n 1. steps (as @ [y])", "by (auto intro: stepsD)"], ["proof (state)\nthis:\n  steps (as @ [y])\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow> reachable y", "with \\<open>as \\<noteq> []\\<close> \\<open>hd xs = x\\<close> \\<open>reachable x\\<close>"], ["proof (chain)\npicking this:\n  as \\<noteq> []\n  hd xs = x\n  reachable x\n  steps (as @ [y])", "show ?thesis"], ["proof (prove)\nusing this:\n  as \\<noteq> []\n  hd xs = x\n  reachable x\n  steps (as @ [y])\n\ngoal (1 subgoal):\n 1. reachable y", "by (auto 4 3 intro: reachable_reaches graphI)"], ["proof (state)\nthis:\n  reachable y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  reachable y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reachable_steps:\n  \"\\<exists> xs. steps xs \\<and> hd xs = s\\<^sub>0 \\<and> last xs = x\" if \"reachable x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs. steps xs \\<and> hd xs = s\\<^sub>0 \\<and> last xs = x", "using that"], ["proof (prove)\nusing this:\n  reachable x\n\ngoal (1 subgoal):\n 1. \\<exists>xs. steps xs \\<and> hd xs = s\\<^sub>0 \\<and> last xs = x", "unfolding reachable_def"], ["proof (prove)\nusing this:\n  s\\<^sub>0 \\<rightarrow>* x\n\ngoal (1 subgoal):\n 1. \\<exists>xs. steps xs \\<and> hd xs = s\\<^sub>0 \\<and> last xs = x", "proof induction"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>xs.\n       steps xs \\<and> hd xs = s\\<^sub>0 \\<and> last xs = s\\<^sub>0\n 2. \\<And>y z.\n       \\<lbrakk>s\\<^sub>0 \\<rightarrow>* y; y \\<rightarrow> z;\n        \\<exists>xs.\n           steps xs \\<and> hd xs = s\\<^sub>0 \\<and> last xs = y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            steps xs \\<and>\n                            hd xs = s\\<^sub>0 \\<and> last xs = z", "case base"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<exists>xs.\n       steps xs \\<and> hd xs = s\\<^sub>0 \\<and> last xs = s\\<^sub>0\n 2. \\<And>y z.\n       \\<lbrakk>s\\<^sub>0 \\<rightarrow>* y; y \\<rightarrow> z;\n        \\<exists>xs.\n           steps xs \\<and> hd xs = s\\<^sub>0 \\<and> last xs = y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            steps xs \\<and>\n                            hd xs = s\\<^sub>0 \\<and> last xs = z", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       steps xs \\<and> hd xs = s\\<^sub>0 \\<and> last xs = s\\<^sub>0", "by (inst_existentials \"[s\\<^sub>0]\"; force)"], ["proof (state)\nthis:\n  \\<exists>xs. steps xs \\<and> hd xs = s\\<^sub>0 \\<and> last xs = s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>s\\<^sub>0 \\<rightarrow>* y; y \\<rightarrow> z;\n        \\<exists>xs.\n           steps xs \\<and> hd xs = s\\<^sub>0 \\<and> last xs = y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            steps xs \\<and>\n                            hd xs = s\\<^sub>0 \\<and> last xs = z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>s\\<^sub>0 \\<rightarrow>* y; y \\<rightarrow> z;\n        \\<exists>xs.\n           steps xs \\<and> hd xs = s\\<^sub>0 \\<and> last xs = y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            steps xs \\<and>\n                            hd xs = s\\<^sub>0 \\<and> last xs = z", "case (step y z)"], ["proof (state)\nthis:\n  s\\<^sub>0 \\<rightarrow>* y\n  y \\<rightarrow> z\n  \\<exists>xs. steps xs \\<and> hd xs = s\\<^sub>0 \\<and> last xs = y\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>s\\<^sub>0 \\<rightarrow>* y; y \\<rightarrow> z;\n        \\<exists>xs.\n           steps xs \\<and> hd xs = s\\<^sub>0 \\<and> last xs = y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            steps xs \\<and>\n                            hd xs = s\\<^sub>0 \\<and> last xs = z", "from step.IH"], ["proof (chain)\npicking this:\n  \\<exists>xs. steps xs \\<and> hd xs = s\\<^sub>0 \\<and> last xs = y", "guess xs"], ["proof (prove)\nusing this:\n  \\<exists>xs. steps xs \\<and> hd xs = s\\<^sub>0 \\<and> last xs = y\n\ngoal (1 subgoal):\n 1. thesis", "by clarify"], ["proof (state)\nthis:\n  steps xs\n  s\\<^sub>0 = hd xs\n  y = last xs\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>s\\<^sub>0 \\<rightarrow>* y; y \\<rightarrow> z;\n        \\<exists>xs.\n           steps xs \\<and> hd xs = s\\<^sub>0 \\<and> last xs = y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            steps xs \\<and>\n                            hd xs = s\\<^sub>0 \\<and> last xs = z", "with step.hyps"], ["proof (chain)\npicking this:\n  s\\<^sub>0 \\<rightarrow>* y\n  y \\<rightarrow> z\n  steps xs\n  s\\<^sub>0 = hd xs\n  y = last xs", "show ?case"], ["proof (prove)\nusing this:\n  s\\<^sub>0 \\<rightarrow>* y\n  y \\<rightarrow> z\n  steps xs\n  s\\<^sub>0 = hd xs\n  y = last xs\n\ngoal (1 subgoal):\n 1. \\<exists>xs. steps xs \\<and> hd xs = s\\<^sub>0 \\<and> last xs = z", "apply (inst_existentials \"xs @ [z]\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>s\\<^sub>0 \\<rightarrow>* y; y \\<rightarrow> z; steps xs;\n     s\\<^sub>0 = hd xs; y = last xs\\<rbrakk>\n    \\<Longrightarrow> steps (xs @ [z])\n 2. \\<lbrakk>s\\<^sub>0 \\<rightarrow>* y; y \\<rightarrow> z; steps xs;\n     s\\<^sub>0 = hd xs; y = last xs\\<rbrakk>\n    \\<Longrightarrow> hd (xs @ [z]) = s\\<^sub>0\n 3. \\<lbrakk>s\\<^sub>0 \\<rightarrow>* y; y \\<rightarrow> z; steps xs;\n     s\\<^sub>0 = hd xs; y = last xs\\<rbrakk>\n    \\<Longrightarrow> last (xs @ [z]) = z", "apply (force intro: graphI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>s\\<^sub>0 \\<rightarrow>* y; y \\<rightarrow> z; steps xs;\n     s\\<^sub>0 = hd xs; y = last xs\\<rbrakk>\n    \\<Longrightarrow> hd (xs @ [z]) = s\\<^sub>0\n 2. \\<lbrakk>s\\<^sub>0 \\<rightarrow>* y; y \\<rightarrow> z; steps xs;\n     s\\<^sub>0 = hd xs; y = last xs\\<rbrakk>\n    \\<Longrightarrow> last (xs @ [z]) = z", "by (cases xs; auto)+"], ["proof (state)\nthis:\n  \\<exists>xs. steps xs \\<and> hd xs = s\\<^sub>0 \\<and> last xs = z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reachable_cycle_iff:\n  \"reachable x \\<and> x \\<rightarrow>\\<^sup>+ x \\<longleftrightarrow> (\\<exists> ws xs. steps (s\\<^sub>0 # ws @ [x] @ xs @ [x]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (reachable x \\<and> x \\<rightarrow>\\<^sup>+ x) =\n    (\\<exists>ws xs. steps (s\\<^sub>0 # ws @ [x] @ xs @ [x]))", "proof (safe, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>reachable x; x \\<rightarrow>\\<^sup>+ x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ws xs.\n                         steps (s\\<^sub>0 # ws @ [x] @ xs @ [x])\n 2. \\<And>ws xs.\n       steps (s\\<^sub>0 # ws @ [x] @ xs @ [x]) \\<Longrightarrow> reachable x\n 3. \\<And>ws xs.\n       steps (s\\<^sub>0 # ws @ [x] @ xs @ [x]) \\<Longrightarrow>\n       x \\<rightarrow>\\<^sup>+ x", "case (2 ws)"], ["proof (state)\nthis:\n  steps (s\\<^sub>0 # ws @ [x] @ xs_ @ [x])\n\ngoal (3 subgoals):\n 1. \\<lbrakk>reachable x; x \\<rightarrow>\\<^sup>+ x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ws xs.\n                         steps (s\\<^sub>0 # ws @ [x] @ xs @ [x])\n 2. \\<And>ws xs.\n       steps (s\\<^sub>0 # ws @ [x] @ xs @ [x]) \\<Longrightarrow> reachable x\n 3. \\<And>ws xs.\n       steps (s\\<^sub>0 # ws @ [x] @ xs @ [x]) \\<Longrightarrow>\n       x \\<rightarrow>\\<^sup>+ x", "then"], ["proof (chain)\npicking this:\n  steps (s\\<^sub>0 # ws @ [x] @ xs_ @ [x])", "show ?case"], ["proof (prove)\nusing this:\n  steps (s\\<^sub>0 # ws @ [x] @ xs_ @ [x])\n\ngoal (1 subgoal):\n 1. reachable x", "by (auto intro: steps_reachable stepsD)"], ["proof (state)\nthis:\n  reachable x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>reachable x; x \\<rightarrow>\\<^sup>+ x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ws xs.\n                         steps (s\\<^sub>0 # ws @ [x] @ xs @ [x])\n 2. \\<And>ws xs.\n       steps (s\\<^sub>0 # ws @ [x] @ xs @ [x]) \\<Longrightarrow>\n       x \\<rightarrow>\\<^sup>+ x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>reachable x; x \\<rightarrow>\\<^sup>+ x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ws xs.\n                         steps (s\\<^sub>0 # ws @ [x] @ xs @ [x])\n 2. \\<And>ws xs.\n       steps (s\\<^sub>0 # ws @ [x] @ xs @ [x]) \\<Longrightarrow>\n       x \\<rightarrow>\\<^sup>+ x", "case (3 ws xs)"], ["proof (state)\nthis:\n  steps (s\\<^sub>0 # ws @ [x] @ xs @ [x])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>reachable x; x \\<rightarrow>\\<^sup>+ x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ws xs.\n                         steps (s\\<^sub>0 # ws @ [x] @ xs @ [x])\n 2. \\<And>ws xs.\n       steps (s\\<^sub>0 # ws @ [x] @ xs @ [x]) \\<Longrightarrow>\n       x \\<rightarrow>\\<^sup>+ x", "then"], ["proof (chain)\npicking this:\n  steps (s\\<^sub>0 # ws @ [x] @ xs @ [x])", "show ?case"], ["proof (prove)\nusing this:\n  steps (s\\<^sub>0 # ws @ [x] @ xs @ [x])\n\ngoal (1 subgoal):\n 1. x \\<rightarrow>\\<^sup>+ x", "by (auto intro: stepsD steps_reaches1)"], ["proof (state)\nthis:\n  x \\<rightarrow>\\<^sup>+ x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>reachable x; x \\<rightarrow>\\<^sup>+ x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ws xs.\n                         steps (s\\<^sub>0 # ws @ [x] @ xs @ [x])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>reachable x; x \\<rightarrow>\\<^sup>+ x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ws xs.\n                         steps (s\\<^sub>0 # ws @ [x] @ xs @ [x])", "case prems: 1"], ["proof (state)\nthis:\n  reachable x\n  x \\<rightarrow>\\<^sup>+ x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>reachable x; x \\<rightarrow>\\<^sup>+ x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ws xs.\n                         steps (s\\<^sub>0 # ws @ [x] @ xs @ [x])", "from \\<open>reachable x\\<close> prems(2)"], ["proof (chain)\npicking this:\n  reachable x\n  x \\<rightarrow>\\<^sup>+ x", "have \"s\\<^sub>0 \\<rightarrow>\\<^sup>+ x\""], ["proof (prove)\nusing this:\n  reachable x\n  x \\<rightarrow>\\<^sup>+ x\n\ngoal (1 subgoal):\n 1. s\\<^sub>0 \\<rightarrow>\\<^sup>+ x", "unfolding reachable_def"], ["proof (prove)\nusing this:\n  s\\<^sub>0 \\<rightarrow>* x\n  x \\<rightarrow>\\<^sup>+ x\n\ngoal (1 subgoal):\n 1. s\\<^sub>0 \\<rightarrow>\\<^sup>+ x", "by auto"], ["proof (state)\nthis:\n  s\\<^sub>0 \\<rightarrow>\\<^sup>+ x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>reachable x; x \\<rightarrow>\\<^sup>+ x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ws xs.\n                         steps (s\\<^sub>0 # ws @ [x] @ xs @ [x])", "with \\<open>x \\<rightarrow>\\<^sup>+ x\\<close>"], ["proof (chain)\npicking this:\n  x \\<rightarrow>\\<^sup>+ x\n  s\\<^sub>0 \\<rightarrow>\\<^sup>+ x", "show ?case"], ["proof (prove)\nusing this:\n  x \\<rightarrow>\\<^sup>+ x\n  s\\<^sub>0 \\<rightarrow>\\<^sup>+ x\n\ngoal (1 subgoal):\n 1. \\<exists>ws xs. steps (s\\<^sub>0 # ws @ [x] @ xs @ [x])", "by (fastforce intro: steps_append' dest: reaches1_steps)"], ["proof (state)\nthis:\n  \\<exists>ws xs. steps (s\\<^sub>0 # ws @ [x] @ xs @ [x])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reachable_induct[consumes 1, case_names start step, induct pred: reachable]:\n  assumes \"reachable x\"\n    and \"P s\\<^sub>0\"\n    and \"\\<And> a b. reachable a \\<Longrightarrow> P a \\<Longrightarrow> a \\<rightarrow> b \\<Longrightarrow> P b\"\n  shows \"P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x", "using assms(1)"], ["proof (prove)\nusing this:\n  reachable x\n\ngoal (1 subgoal):\n 1. P x", "unfolding reachable_def"], ["proof (prove)\nusing this:\n  s\\<^sub>0 \\<rightarrow>* x\n\ngoal (1 subgoal):\n 1. P x", "by induction (auto intro: assms(2-)[unfolded reachable_def])"], ["", "lemmas graphI_aggressive =\n  tranclp_into_rtranclp\n  rtranclp.rtrancl_into_rtrancl\n  tranclp.trancl_into_trancl\n  rtranclp_into_tranclp2"], ["", "lemmas graphI_aggressive1 =\n  graphI_aggressive\n  steps_append'"], ["", "lemmas graphI_aggressive2 =\n  graphI_aggressive\n  stepsD\n  steps_reaches1\n  steps_reachable"], ["", "lemmas graphD =\n  reaches1_steps"], ["", "lemmas graphD_aggressive =\n  tranclpD"], ["", "lemmas graph_startI =\n  reachable_reaches\n  start_reachable"], ["", "end"], ["", "(* Graph Start Defs *)"], ["", "subsection \\<open>Subgraphs\\<close>"], ["", "subsubsection \\<open>Edge-induced Subgraphs\\<close>"], ["", "locale Subgraph_Defs = G: Graph_Defs +\n  fixes E' :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\"\nbegin"], ["", "sublocale G': Graph_Defs E'"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "(* Subgraph Defs *)"], ["", "locale Subgraph_Start_Defs = G: Graph_Start_Defs +\n  fixes E' :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\"\nbegin"], ["", "sublocale G': Graph_Start_Defs E' s\\<^sub>0"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "(* Subgraph Start Defs *)"], ["", "locale Subgraph = Subgraph_Defs +\n  assumes subgraph[intro]: \"E' a b \\<Longrightarrow> E a b\"\nbegin"], ["", "lemma non_subgraph_cycle_decomp:\n  \"\\<exists> c d. G.reaches a c \\<and> E c d \\<and> \\<not> E' c d \\<and> G.reaches d b\" if\n  \"G.reaches1 a b\" \"\\<not> G'.reaches1 a b\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c d.\n       a \\<rightarrow>* c \\<and>\n       c \\<rightarrow> d \\<and> \\<not> E' c d \\<and> d \\<rightarrow>* b", "using that"], ["proof (prove)\nusing this:\n  a \\<rightarrow>\\<^sup>+ b\n  \\<not> G'.reaches1 a b\n\ngoal (1 subgoal):\n 1. \\<exists>c d.\n       a \\<rightarrow>* c \\<and>\n       c \\<rightarrow> d \\<and> \\<not> E' c d \\<and> d \\<rightarrow>* b", "proof induction"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>a \\<rightarrow> y; \\<not> G'.reaches1 a y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c d.\n                            a \\<rightarrow>* c \\<and>\n                            c \\<rightarrow> d \\<and>\n                            \\<not> E' c d \\<and> d \\<rightarrow>* y\n 2. \\<And>y z.\n       \\<lbrakk>a \\<rightarrow>\\<^sup>+ y; y \\<rightarrow> z;\n        \\<not> G'.reaches1 a y \\<Longrightarrow>\n        \\<exists>c d.\n           a \\<rightarrow>* c \\<and>\n           c \\<rightarrow> d \\<and> \\<not> E' c d \\<and> d \\<rightarrow>* y;\n        \\<not> G'.reaches1 a z\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c d.\n                            a \\<rightarrow>* c \\<and>\n                            c \\<rightarrow> d \\<and>\n                            \\<not> E' c d \\<and> d \\<rightarrow>* z", "case (base y)"], ["proof (state)\nthis:\n  a \\<rightarrow> y\n  \\<not> G'.reaches1 a y\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>a \\<rightarrow> y; \\<not> G'.reaches1 a y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c d.\n                            a \\<rightarrow>* c \\<and>\n                            c \\<rightarrow> d \\<and>\n                            \\<not> E' c d \\<and> d \\<rightarrow>* y\n 2. \\<And>y z.\n       \\<lbrakk>a \\<rightarrow>\\<^sup>+ y; y \\<rightarrow> z;\n        \\<not> G'.reaches1 a y \\<Longrightarrow>\n        \\<exists>c d.\n           a \\<rightarrow>* c \\<and>\n           c \\<rightarrow> d \\<and> \\<not> E' c d \\<and> d \\<rightarrow>* y;\n        \\<not> G'.reaches1 a z\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c d.\n                            a \\<rightarrow>* c \\<and>\n                            c \\<rightarrow> d \\<and>\n                            \\<not> E' c d \\<and> d \\<rightarrow>* z", "then"], ["proof (chain)\npicking this:\n  a \\<rightarrow> y\n  \\<not> G'.reaches1 a y", "show ?case"], ["proof (prove)\nusing this:\n  a \\<rightarrow> y\n  \\<not> G'.reaches1 a y\n\ngoal (1 subgoal):\n 1. \\<exists>c d.\n       a \\<rightarrow>* c \\<and>\n       c \\<rightarrow> d \\<and> \\<not> E' c d \\<and> d \\<rightarrow>* y", "by auto"], ["proof (state)\nthis:\n  \\<exists>c d.\n     a \\<rightarrow>* c \\<and>\n     c \\<rightarrow> d \\<and> \\<not> E' c d \\<and> d \\<rightarrow>* y\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>a \\<rightarrow>\\<^sup>+ y; y \\<rightarrow> z;\n        \\<not> G'.reaches1 a y \\<Longrightarrow>\n        \\<exists>c d.\n           a \\<rightarrow>* c \\<and>\n           c \\<rightarrow> d \\<and> \\<not> E' c d \\<and> d \\<rightarrow>* y;\n        \\<not> G'.reaches1 a z\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c d.\n                            a \\<rightarrow>* c \\<and>\n                            c \\<rightarrow> d \\<and>\n                            \\<not> E' c d \\<and> d \\<rightarrow>* z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>a \\<rightarrow>\\<^sup>+ y; y \\<rightarrow> z;\n        \\<not> G'.reaches1 a y \\<Longrightarrow>\n        \\<exists>c d.\n           a \\<rightarrow>* c \\<and>\n           c \\<rightarrow> d \\<and> \\<not> E' c d \\<and> d \\<rightarrow>* y;\n        \\<not> G'.reaches1 a z\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c d.\n                            a \\<rightarrow>* c \\<and>\n                            c \\<rightarrow> d \\<and>\n                            \\<not> E' c d \\<and> d \\<rightarrow>* z", "case (step y z)"], ["proof (state)\nthis:\n  a \\<rightarrow>\\<^sup>+ y\n  y \\<rightarrow> z\n  \\<not> G'.reaches1 a y \\<Longrightarrow>\n  \\<exists>c d.\n     a \\<rightarrow>* c \\<and>\n     c \\<rightarrow> d \\<and> \\<not> E' c d \\<and> d \\<rightarrow>* y\n  \\<not> G'.reaches1 a z\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>a \\<rightarrow>\\<^sup>+ y; y \\<rightarrow> z;\n        \\<not> G'.reaches1 a y \\<Longrightarrow>\n        \\<exists>c d.\n           a \\<rightarrow>* c \\<and>\n           c \\<rightarrow> d \\<and> \\<not> E' c d \\<and> d \\<rightarrow>* y;\n        \\<not> G'.reaches1 a z\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c d.\n                            a \\<rightarrow>* c \\<and>\n                            c \\<rightarrow> d \\<and>\n                            \\<not> E' c d \\<and> d \\<rightarrow>* z", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c d.\n       a \\<rightarrow>* c \\<and>\n       c \\<rightarrow> d \\<and> \\<not> E' c d \\<and> d \\<rightarrow>* z", "proof (cases \"E' y z\")"], ["proof (state)\ngoal (2 subgoals):\n 1. E' y z \\<Longrightarrow>\n    \\<exists>c d.\n       a \\<rightarrow>* c \\<and>\n       c \\<rightarrow> d \\<and> \\<not> E' c d \\<and> d \\<rightarrow>* z\n 2. \\<not> E' y z \\<Longrightarrow>\n    \\<exists>c d.\n       a \\<rightarrow>* c \\<and>\n       c \\<rightarrow> d \\<and> \\<not> E' c d \\<and> d \\<rightarrow>* z", "case True"], ["proof (state)\nthis:\n  E' y z\n\ngoal (2 subgoals):\n 1. E' y z \\<Longrightarrow>\n    \\<exists>c d.\n       a \\<rightarrow>* c \\<and>\n       c \\<rightarrow> d \\<and> \\<not> E' c d \\<and> d \\<rightarrow>* z\n 2. \\<not> E' y z \\<Longrightarrow>\n    \\<exists>c d.\n       a \\<rightarrow>* c \\<and>\n       c \\<rightarrow> d \\<and> \\<not> E' c d \\<and> d \\<rightarrow>* z", "with step"], ["proof (chain)\npicking this:\n  a \\<rightarrow>\\<^sup>+ y\n  y \\<rightarrow> z\n  \\<not> G'.reaches1 a y \\<Longrightarrow>\n  \\<exists>c d.\n     a \\<rightarrow>* c \\<and>\n     c \\<rightarrow> d \\<and> \\<not> E' c d \\<and> d \\<rightarrow>* y\n  \\<not> G'.reaches1 a z\n  E' y z", "have \"\\<not> G'.reaches1 a y\""], ["proof (prove)\nusing this:\n  a \\<rightarrow>\\<^sup>+ y\n  y \\<rightarrow> z\n  \\<not> G'.reaches1 a y \\<Longrightarrow>\n  \\<exists>c d.\n     a \\<rightarrow>* c \\<and>\n     c \\<rightarrow> d \\<and> \\<not> E' c d \\<and> d \\<rightarrow>* y\n  \\<not> G'.reaches1 a z\n  E' y z\n\ngoal (1 subgoal):\n 1. \\<not> G'.reaches1 a y", "by (auto intro: tranclp.trancl_into_trancl)"], ["proof (state)\nthis:\n  \\<not> G'.reaches1 a y\n\ngoal (2 subgoals):\n 1. E' y z \\<Longrightarrow>\n    \\<exists>c d.\n       a \\<rightarrow>* c \\<and>\n       c \\<rightarrow> d \\<and> \\<not> E' c d \\<and> d \\<rightarrow>* z\n 2. \\<not> E' y z \\<Longrightarrow>\n    \\<exists>c d.\n       a \\<rightarrow>* c \\<and>\n       c \\<rightarrow> d \\<and> \\<not> E' c d \\<and> d \\<rightarrow>* z", "(* XXX *)"], ["proof (state)\nthis:\n  \\<not> G'.reaches1 a y\n\ngoal (2 subgoals):\n 1. E' y z \\<Longrightarrow>\n    \\<exists>c d.\n       a \\<rightarrow>* c \\<and>\n       c \\<rightarrow> d \\<and> \\<not> E' c d \\<and> d \\<rightarrow>* z\n 2. \\<not> E' y z \\<Longrightarrow>\n    \\<exists>c d.\n       a \\<rightarrow>* c \\<and>\n       c \\<rightarrow> d \\<and> \\<not> E' c d \\<and> d \\<rightarrow>* z", "with step"], ["proof (chain)\npicking this:\n  a \\<rightarrow>\\<^sup>+ y\n  y \\<rightarrow> z\n  \\<not> G'.reaches1 a y \\<Longrightarrow>\n  \\<exists>c d.\n     a \\<rightarrow>* c \\<and>\n     c \\<rightarrow> d \\<and> \\<not> E' c d \\<and> d \\<rightarrow>* y\n  \\<not> G'.reaches1 a z\n  \\<not> G'.reaches1 a y", "obtain c d where\n        \"G.reaches a c\" \"E c d\" \"\\<not> E' c d\" \"G.reaches d y\""], ["proof (prove)\nusing this:\n  a \\<rightarrow>\\<^sup>+ y\n  y \\<rightarrow> z\n  \\<not> G'.reaches1 a y \\<Longrightarrow>\n  \\<exists>c d.\n     a \\<rightarrow>* c \\<and>\n     c \\<rightarrow> d \\<and> \\<not> E' c d \\<and> d \\<rightarrow>* y\n  \\<not> G'.reaches1 a z\n  \\<not> G'.reaches1 a y\n\ngoal (1 subgoal):\n 1. (\\<And>c d.\n        \\<lbrakk>a \\<rightarrow>* c; c \\<rightarrow> d; \\<not> E' c d;\n         d \\<rightarrow>* y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a \\<rightarrow>* c\n  c \\<rightarrow> d\n  \\<not> E' c d\n  d \\<rightarrow>* y\n\ngoal (2 subgoals):\n 1. E' y z \\<Longrightarrow>\n    \\<exists>c d.\n       a \\<rightarrow>* c \\<and>\n       c \\<rightarrow> d \\<and> \\<not> E' c d \\<and> d \\<rightarrow>* z\n 2. \\<not> E' y z \\<Longrightarrow>\n    \\<exists>c d.\n       a \\<rightarrow>* c \\<and>\n       c \\<rightarrow> d \\<and> \\<not> E' c d \\<and> d \\<rightarrow>* z", "with \\<open>E' y z\\<close>"], ["proof (chain)\npicking this:\n  E' y z\n  a \\<rightarrow>* c\n  c \\<rightarrow> d\n  \\<not> E' c d\n  d \\<rightarrow>* y", "show ?thesis"], ["proof (prove)\nusing this:\n  E' y z\n  a \\<rightarrow>* c\n  c \\<rightarrow> d\n  \\<not> E' c d\n  d \\<rightarrow>* y\n\ngoal (1 subgoal):\n 1. \\<exists>c d.\n       a \\<rightarrow>* c \\<and>\n       c \\<rightarrow> d \\<and> \\<not> E' c d \\<and> d \\<rightarrow>* z", "by (blast intro: rtranclp.rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  \\<exists>c d.\n     a \\<rightarrow>* c \\<and>\n     c \\<rightarrow> d \\<and> \\<not> E' c d \\<and> d \\<rightarrow>* z\n\ngoal (1 subgoal):\n 1. \\<not> E' y z \\<Longrightarrow>\n    \\<exists>c d.\n       a \\<rightarrow>* c \\<and>\n       c \\<rightarrow> d \\<and> \\<not> E' c d \\<and> d \\<rightarrow>* z", "(* XXX *)"], ["proof (state)\nthis:\n  \\<exists>c d.\n     a \\<rightarrow>* c \\<and>\n     c \\<rightarrow> d \\<and> \\<not> E' c d \\<and> d \\<rightarrow>* z\n\ngoal (1 subgoal):\n 1. \\<not> E' y z \\<Longrightarrow>\n    \\<exists>c d.\n       a \\<rightarrow>* c \\<and>\n       c \\<rightarrow> d \\<and> \\<not> E' c d \\<and> d \\<rightarrow>* z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> E' y z \\<Longrightarrow>\n    \\<exists>c d.\n       a \\<rightarrow>* c \\<and>\n       c \\<rightarrow> d \\<and> \\<not> E' c d \\<and> d \\<rightarrow>* z", "case False"], ["proof (state)\nthis:\n  \\<not> E' y z\n\ngoal (1 subgoal):\n 1. \\<not> E' y z \\<Longrightarrow>\n    \\<exists>c d.\n       a \\<rightarrow>* c \\<and>\n       c \\<rightarrow> d \\<and> \\<not> E' c d \\<and> d \\<rightarrow>* z", "with step"], ["proof (chain)\npicking this:\n  a \\<rightarrow>\\<^sup>+ y\n  y \\<rightarrow> z\n  \\<not> G'.reaches1 a y \\<Longrightarrow>\n  \\<exists>c d.\n     a \\<rightarrow>* c \\<and>\n     c \\<rightarrow> d \\<and> \\<not> E' c d \\<and> d \\<rightarrow>* y\n  \\<not> G'.reaches1 a z\n  \\<not> E' y z", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<rightarrow>\\<^sup>+ y\n  y \\<rightarrow> z\n  \\<not> G'.reaches1 a y \\<Longrightarrow>\n  \\<exists>c d.\n     a \\<rightarrow>* c \\<and>\n     c \\<rightarrow> d \\<and> \\<not> E' c d \\<and> d \\<rightarrow>* y\n  \\<not> G'.reaches1 a z\n  \\<not> E' y z\n\ngoal (1 subgoal):\n 1. \\<exists>c d.\n       a \\<rightarrow>* c \\<and>\n       c \\<rightarrow> d \\<and> \\<not> E' c d \\<and> d \\<rightarrow>* z", "by (intro exI conjI) auto"], ["proof (state)\nthis:\n  \\<exists>c d.\n     a \\<rightarrow>* c \\<and>\n     c \\<rightarrow> d \\<and> \\<not> E' c d \\<and> d \\<rightarrow>* z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>c d.\n     a \\<rightarrow>* c \\<and>\n     c \\<rightarrow> d \\<and> \\<not> E' c d \\<and> d \\<rightarrow>* z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reaches:\n  \"G.reaches a b\" if \"G'.reaches a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<rightarrow>* b", "using that"], ["proof (prove)\nusing this:\n  G'.reaches a b\n\ngoal (1 subgoal):\n 1. a \\<rightarrow>* b", "by induction (auto intro: rtranclp.intros(2))"], ["", "lemma reaches1:\n  \"G.reaches1 a b\" if \"G'.reaches1 a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<rightarrow>\\<^sup>+ b", "using that"], ["proof (prove)\nusing this:\n  G'.reaches1 a b\n\ngoal (1 subgoal):\n 1. a \\<rightarrow>\\<^sup>+ b", "by induction (auto intro: tranclp.intros(2))"], ["", "end"], ["", "(* Subgraph *)"], ["", "locale Subgraph_Start = Subgraph_Start_Defs + Subgraph\nbegin"], ["", "lemma reachable_subgraph[intro]: \"G.reachable b\" if \\<open>G.reachable a\\<close> \\<open>G'.reaches a b\\<close> for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. G.reachable b", "using that"], ["proof (prove)\nusing this:\n  G.reachable a\n  G'.reaches a b\n\ngoal (1 subgoal):\n 1. G.reachable b", "by (auto intro: G.graph_startI mono_rtranclp[rule_format, of E'])"], ["", "lemma reachable:\n  \"G.reachable x\" if \"G'.reachable x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G.reachable x", "using that"], ["proof (prove)\nusing this:\n  G'.reachable x\n\ngoal (1 subgoal):\n 1. G.reachable x", "by (fastforce simp: G.reachable_def G'.reachable_def)"], ["", "end"], ["", "(* Subgraph Start *)"], ["", "subsubsection \\<open>Node-induced Subgraphs\\<close>"], ["", "locale Subgraph_Node_Defs = Graph_Defs +\n  fixes V :: \"'a \\<Rightarrow> bool\"\nbegin"], ["", "definition E' where \"E' x y \\<equiv> E x y \\<and> V x \\<and> V y\""], ["", "sublocale Subgraph E E'"], ["proof (prove)\ngoal (1 subgoal):\n 1. Subgraph E E'", "by standard (auto simp: E'_def)"], ["", "lemma subgraph':\n  \"E' x y\" if \"E x y\" \"V x\" \"V y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E' x y", "using that"], ["proof (prove)\nusing this:\n  x \\<rightarrow> y\n  V x\n  V y\n\ngoal (1 subgoal):\n 1. E' x y", "unfolding E'_def"], ["proof (prove)\nusing this:\n  x \\<rightarrow> y\n  V x\n  V y\n\ngoal (1 subgoal):\n 1. x \\<rightarrow> y \\<and> V x \\<and> V y", "by auto"], ["", "lemma E'_V1:\n  \"V x\" if \"E' x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V x", "using that"], ["proof (prove)\nusing this:\n  E' x y\n\ngoal (1 subgoal):\n 1. V x", "unfolding E'_def"], ["proof (prove)\nusing this:\n  x \\<rightarrow> y \\<and> V x \\<and> V y\n\ngoal (1 subgoal):\n 1. V x", "by auto"], ["", "lemma E'_V2:\n  \"V y\" if \"E' x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V y", "using that"], ["proof (prove)\nusing this:\n  E' x y\n\ngoal (1 subgoal):\n 1. V y", "unfolding E'_def"], ["proof (prove)\nusing this:\n  x \\<rightarrow> y \\<and> V x \\<and> V y\n\ngoal (1 subgoal):\n 1. V y", "by auto"], ["", "lemma G'_reaches_V:\n  \"V y\" if \"G'.reaches x y\" \"V x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V y", "using that"], ["proof (prove)\nusing this:\n  G'.reaches x y\n  V x\n\ngoal (1 subgoal):\n 1. V y", "by (cases) (auto intro: E'_V2)"], ["", "lemma G'_steps_V_all:\n  \"list_all V xs\" if \"G'.steps xs\" \"V (hd xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all V xs", "using that"], ["proof (prove)\nusing this:\n  G'.steps xs\n  V (hd xs)\n\ngoal (1 subgoal):\n 1. list_all V xs", "by induction (auto intro: E'_V2)"], ["", "lemma G'_steps_V_last:\n  \"V (last xs)\" if \"G'.steps xs\" \"V (hd xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V (last xs)", "using that"], ["proof (prove)\nusing this:\n  G'.steps xs\n  V (hd xs)\n\ngoal (1 subgoal):\n 1. V (last xs)", "by induction (auto dest: E'_V2)"], ["", "lemmas subgraphI = E'_V1 E'_V2 G'_reaches_V"], ["", "lemmas subgraphD = E'_V1 E'_V2 G'_reaches_V"], ["", "end"], ["", "(* Subgraph Node *)"], ["", "locale Subgraph_Node_Defs_Notation = Subgraph_Node_Defs\nbegin"], ["", "no_notation E (\"_ \\<rightarrow> _\" [100, 100] 40)"], ["", "notation E' (\"_ \\<rightarrow> _\" [100, 100] 40)"], ["", "no_notation reaches (\"_ \\<rightarrow>* _\" [100, 100] 40)"], ["", "notation G'.reaches (\"_ \\<rightarrow>* _\" [100, 100] 40)"], ["", "no_notation reaches1 (\"_ \\<rightarrow>\\<^sup>+ _\" [100, 100] 40)"], ["", "notation G'.reaches1 (\"_ \\<rightarrow>\\<^sup>+ _\" [100, 100] 40)"], ["", "end"], ["", "(* Subgraph_Node_Defs_Notation *)"], ["", "subsubsection \\<open>The Reachable Subgraph\\<close>"], ["", "context Graph_Start_Defs\nbegin"], ["", "interpretation Subgraph_Node_Defs_Notation E reachable"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sublocale reachable_subgraph: Subgraph_Node_Defs E reachable"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma reachable_supgraph:\n  \"x \\<rightarrow> y\" if \"E x y\" \"reachable x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<rightarrow> y", "using that"], ["proof (prove)\nusing this:\n  E x y\n  reachable x\n\ngoal (1 subgoal):\n 1. x \\<rightarrow> y", "unfolding E'_def"], ["proof (prove)\nusing this:\n  E x y\n  reachable x\n\ngoal (1 subgoal):\n 1. E x y \\<and> reachable x \\<and> reachable y", "by (auto intro: graph_startI)"], ["", "lemma reachable_reaches_equiv: \"reaches x y \\<longleftrightarrow> x \\<rightarrow>* y\" if \"reachable x\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. reaches x y = (x \\<rightarrow>* y)", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. reaches x y \\<Longrightarrow> x \\<rightarrow>* y\n 2. x \\<rightarrow>* y \\<Longrightarrow> reaches x y", "subgoal premises prems"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<rightarrow>* y", "using prems \\<open>reachable x\\<close>"], ["proof (prove)\nusing this:\n  reaches x y\n  reachable x\n\ngoal (1 subgoal):\n 1. x \\<rightarrow>* y", "by induction (auto dest: reachable_supgraph intro: graph_startI graphI_aggressive)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<rightarrow>* y \\<Longrightarrow> reaches x y", "subgoal premises prems"], ["proof (prove)\ngoal (1 subgoal):\n 1. reaches x y", "using prems \\<open>reachable x\\<close>"], ["proof (prove)\nusing this:\n  x \\<rightarrow>* y\n  reachable x\n\ngoal (1 subgoal):\n 1. reaches x y", "by induction (auto dest: subgraph)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma reachable_reaches1_equiv: \"reaches1 x y \\<longleftrightarrow> x \\<rightarrow>\\<^sup>+ y\" if \"reachable x\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. reaches1 x y = (x \\<rightarrow>\\<^sup>+ y)", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. reaches1 x y \\<Longrightarrow> x \\<rightarrow>\\<^sup>+ y\n 2. x \\<rightarrow>\\<^sup>+ y \\<Longrightarrow> reaches1 x y", "subgoal premises prems"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<rightarrow>\\<^sup>+ y", "using prems \\<open>reachable x\\<close>"], ["proof (prove)\nusing this:\n  reaches1 x y\n  reachable x\n\ngoal (1 subgoal):\n 1. x \\<rightarrow>\\<^sup>+ y", "by induction (auto dest: reachable_supgraph intro: graph_startI graphI_aggressive)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<rightarrow>\\<^sup>+ y \\<Longrightarrow> reaches1 x y", "subgoal premises prems"], ["proof (prove)\ngoal (1 subgoal):\n 1. reaches1 x y", "using prems \\<open>reachable x\\<close>"], ["proof (prove)\nusing this:\n  x \\<rightarrow>\\<^sup>+ y\n  reachable x\n\ngoal (1 subgoal):\n 1. reaches1 x y", "by induction (auto dest: subgraph)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma reachable_steps_equiv:\n  \"steps (x # xs) \\<longleftrightarrow> G'.steps (x # xs)\" if \"reachable x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps (x # xs) = G'.steps (x # xs)", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. steps (x # xs) \\<Longrightarrow> G'.steps (x # xs)\n 2. G'.steps (x # xs) \\<Longrightarrow> steps (x # xs)", "subgoal premises prems"], ["proof (prove)\ngoal (1 subgoal):\n 1. G'.steps (x # xs)", "using prems \\<open>reachable x\\<close>"], ["proof (prove)\nusing this:\n  steps (x # xs)\n  reachable x\n\ngoal (1 subgoal):\n 1. G'.steps (x # xs)", "by (induction \"x # xs\" arbitrary: x xs) (auto dest: reachable_supgraph intro: graph_startI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. G'.steps (x # xs) \\<Longrightarrow> steps (x # xs)", "subgoal premises prems"], ["proof (prove)\ngoal (1 subgoal):\n 1. steps (x # xs)", "using prems"], ["proof (prove)\nusing this:\n  G'.steps (x # xs)\n\ngoal (1 subgoal):\n 1. steps (x # xs)", "by induction auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "(* Graph Start Defs *)"], ["", "subsection \\<open>Bundles\\<close>"], ["", "bundle graph_automation\nbegin"], ["", "lemmas [intro] = Graph_Defs.graphI Graph_Start_Defs.graph_startI"], ["", "lemmas [dest]  = Graph_Start_Defs.graphD"], ["", "end"], ["", "(* Bundle *)"], ["", "bundle reaches_steps_iff =\n  Graph_Defs.reaches1_steps_iff [iff]\n  Graph_Defs.reaches_steps_iff  [iff]"], ["", "bundle graph_automation_aggressive\nbegin"], ["", "unbundle graph_automation"], ["", "lemmas [intro] = Graph_Start_Defs.graphI_aggressive"], ["", "lemmas [dest]  = Graph_Start_Defs.graphD_aggressive"], ["", "end"], ["", "(* Bundle *)"], ["", "bundle subgraph_automation\nbegin"], ["", "unbundle graph_automation"], ["", "lemmas [intro] = Subgraph_Node_Defs.subgraphI"], ["", "lemmas [dest]  = Subgraph_Node_Defs.subgraphD"], ["", "end"], ["", "(* Bundle *)"], ["", "subsection \\<open>Simulations and Bisimulations\\<close>"], ["", "locale Graph_Invariant = Graph_Defs +\n  fixes P :: \"'a \\<Rightarrow> bool\"\n  assumes invariant: \"P a \\<Longrightarrow> a \\<rightarrow> b \\<Longrightarrow> P b\"\nbegin"], ["", "lemma invariant_steps:\n  \"list_all P as\" if \"steps (a # as)\" \"P a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all P as", "using that"], ["proof (prove)\nusing this:\n  steps (a # as)\n  P a\n\ngoal (1 subgoal):\n 1. list_all P as", "by (induction \"a # as\" arbitrary: as a) (auto intro: invariant)"], ["", "lemma invariant_reaches:\n  \"P b\" if \"a \\<rightarrow>* b\" \"P a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P b", "using that"], ["proof (prove)\nusing this:\n  a \\<rightarrow>* b\n  P a\n\ngoal (1 subgoal):\n 1. P b", "by (induction; blast intro: invariant)"], ["", "lemma invariant_run:\n  assumes run: \"run (x ## xs)\" and P: \"P x\"\n  shows \"pred_stream P (x ## xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream P (x ## xs)", "using run P"], ["proof (prove)\nusing this:\n  run (x ## xs)\n  P x\n\ngoal (1 subgoal):\n 1. pred_stream P (x ## xs)", "by (coinduction arbitrary: x xs) (auto 4 3 elim: invariant run.cases)"], ["", "end"], ["", "(* Graph Invariant *)"], ["", "locale Graph_Invariants = Graph_Defs +\n  fixes P Q :: \"'a \\<Rightarrow> bool\"\n  assumes invariant: \"P a \\<Longrightarrow> a \\<rightarrow> b \\<Longrightarrow> Q b\" and Q_P: \"Q a \\<Longrightarrow> P a\"\nbegin"], ["", "sublocale Pre: Graph_Invariant E P"], ["proof (prove)\ngoal (1 subgoal):\n 1. Graph_Invariant E P", "by standard (blast intro: invariant Q_P)"], ["", "sublocale Post: Graph_Invariant E Q"], ["proof (prove)\ngoal (1 subgoal):\n 1. Graph_Invariant E Q", "by standard (blast intro: invariant Q_P)"], ["", "lemma invariant_steps:\n  \"list_all Q as\" if \"steps (a # as)\" \"P a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all Q as", "using that"], ["proof (prove)\nusing this:\n  steps (a # as)\n  P a\n\ngoal (1 subgoal):\n 1. list_all Q as", "by (induction \"a # as\" arbitrary: as a) (auto intro: invariant Q_P)"], ["", "lemma invariant_run:\n  assumes run: \"run (x ## xs)\" and P: \"P x\"\n  shows \"pred_stream Q xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream Q xs", "using run P"], ["proof (prove)\nusing this:\n  run (x ## xs)\n  P x\n\ngoal (1 subgoal):\n 1. pred_stream Q xs", "by (coinduction arbitrary: x xs) (auto 4 4 elim: invariant run.cases intro: Q_P)"], ["", "lemma invariant_reaches1:\n  \"Q b\" if \"a \\<rightarrow>\\<^sup>+ b\" \"P a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q b", "using that"], ["proof (prove)\nusing this:\n  a \\<rightarrow>\\<^sup>+ b\n  P a\n\ngoal (1 subgoal):\n 1. Q b", "by (induction; blast intro: invariant Q_P)"], ["", "end"], ["", "(* Graph Invariants *)"], ["", "locale Graph_Invariant_Start = Graph_Start_Defs + Graph_Invariant +\n  assumes P_s\\<^sub>0: \"P s\\<^sub>0\"\nbegin"], ["", "lemma invariant_steps:\n  \"list_all P as\" if \"steps (s\\<^sub>0 # as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all P as", "using that P_s\\<^sub>0"], ["proof (prove)\nusing this:\n  steps (s\\<^sub>0 # as)\n  P s\\<^sub>0\n\ngoal (1 subgoal):\n 1. list_all P as", "by (rule invariant_steps)"], ["", "lemma invariant_reaches:\n  \"P b\" if \"s\\<^sub>0 \\<rightarrow>* b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P b", "using invariant_reaches[OF that P_s\\<^sub>0]"], ["proof (prove)\nusing this:\n  P b\n\ngoal (1 subgoal):\n 1. P b", "."], ["", "lemmas invariant_run = invariant_run[OF _ P_s\\<^sub>0]"], ["", "end"], ["", "(* Graph Invariant Start *)"], ["", "locale Graph_Invariant_Strong = Graph_Defs +\n  fixes P :: \"'a \\<Rightarrow> bool\"\n  assumes invariant: \"a \\<rightarrow> b \\<Longrightarrow> P b\"\nbegin"], ["", "sublocale inv: Graph_Invariant"], ["proof (prove)\ngoal (1 subgoal):\n 1. Graph_Invariant E P", "by standard (rule invariant)"], ["", "lemma P_invariant_steps:\n  \"list_all P as\" if \"steps (a # as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all P as", "using that"], ["proof (prove)\nusing this:\n  steps (a # as)\n\ngoal (1 subgoal):\n 1. list_all P as", "by (induction \"a # as\" arbitrary: as a) (auto intro: invariant)"], ["", "lemma steps_last_invariant:\n  \"P (last xs)\" if \"steps (x # xs)\" \"xs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (last xs)", "using steps_last_step[of \"x # xs\"] that"], ["proof (prove)\nusing this:\n  \\<lbrakk>steps (x # xs); 1 < length (x # xs)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a. a \\<rightarrow> last (x # xs)\n  steps (x # xs)\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. P (last xs)", "by (auto intro: invariant)"], ["", "lemmas invariant_reaches = inv.invariant_reaches"], ["", "lemma invariant_reaches1:\n  \"P b\" if \"a \\<rightarrow>\\<^sup>+ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P b", "using that"], ["proof (prove)\nusing this:\n  a \\<rightarrow>\\<^sup>+ b\n\ngoal (1 subgoal):\n 1. P b", "by (induction; blast intro: invariant)"], ["", "end"], ["", "(* Graph Invariant *)"], ["", "locale Simulation_Defs =\n  fixes A :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" and B :: \"'b \\<Rightarrow> 'b \\<Rightarrow> bool\"\n    and sim :: \"'a \\<Rightarrow> 'b \\<Rightarrow> bool\" (infixr \"\\<sim>\" 60)\nbegin"], ["", "sublocale A: Graph_Defs A"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sublocale B: Graph_Defs B"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "(* Simulation Defs *)"], ["", "locale Simulation = Simulation_Defs +\n  assumes A_B_step: \"\\<And> a b a'. A a b \\<Longrightarrow> a \\<sim> a' \\<Longrightarrow> (\\<exists> b'. B a' b' \\<and> b \\<sim> b')\"\nbegin"], ["", "lemma simulation_reaches:\n  \"\\<exists> b'. B\\<^sup>*\\<^sup>* b b' \\<and> a' \\<sim> b'\" if \"A\\<^sup>*\\<^sup>* a a'\" \"a \\<sim> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b'. B.reaches b b' \\<and> a' \\<sim> b'", "using that"], ["proof (prove)\nusing this:\n  A.reaches a a'\n  a \\<sim> b\n\ngoal (1 subgoal):\n 1. \\<exists>b'. B.reaches b b' \\<and> a' \\<sim> b'", "by (induction rule: rtranclp_induct) (auto intro: rtranclp.intros(2) dest: A_B_step)"], ["", "lemma simulation_reaches1:\n  \"\\<exists> b'. B\\<^sup>+\\<^sup>+ b b' \\<and> a' \\<sim> b'\" if \"A\\<^sup>+\\<^sup>+ a a'\" \"a \\<sim> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b'. B.reaches1 b b' \\<and> a' \\<sim> b'", "using that"], ["proof (prove)\nusing this:\n  A.reaches1 a a'\n  a \\<sim> b\n\ngoal (1 subgoal):\n 1. \\<exists>b'. B.reaches1 b b' \\<and> a' \\<sim> b'", "by (induction rule: tranclp_induct) (auto 4 3 intro: tranclp.intros(2) dest: A_B_step)"], ["", "lemma simulation_steps:\n  \"\\<exists> bs. B.steps (b # bs) \\<and> list_all2 (\\<lambda> a b. a \\<sim> b) as bs\" if \"A.steps (a # as)\" \"a \\<sim> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>bs. B.steps (b # bs) \\<and> list_all2 (\\<sim>) as bs", "using that"], ["proof (prove)\nusing this:\n  A.steps (a # as)\n  a \\<sim> b\n\ngoal (1 subgoal):\n 1. \\<exists>bs. B.steps (b # bs) \\<and> list_all2 (\\<sim>) as bs", "apply (induction \"a # as\" arbitrary: a b as)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x b.\n       x \\<sim> b \\<Longrightarrow>\n       \\<exists>bs. B.steps (b # bs) \\<and> list_all2 (\\<sim>) [] bs\n 2. \\<And>x y xs b.\n       \\<lbrakk>A x y; A.steps (y # xs);\n        \\<And>b.\n           y \\<sim> b \\<Longrightarrow>\n           \\<exists>bs. B.steps (b # bs) \\<and> list_all2 (\\<sim>) xs bs;\n        x \\<sim> b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs.\n                            B.steps (b # bs) \\<and>\n                            list_all2 (\\<sim>) (y # xs) bs", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xs b.\n       \\<lbrakk>A x y; A.steps (y # xs);\n        \\<And>b.\n           y \\<sim> b \\<Longrightarrow>\n           \\<exists>bs. B.steps (b # bs) \\<and> list_all2 (\\<sim>) xs bs;\n        x \\<sim> b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs.\n                            B.steps (b # bs) \\<and>\n                            list_all2 (\\<sim>) (y # xs) bs", "apply (frule A_B_step, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma simulation_run:\n  \"\\<exists> ys. B.run (y ## ys) \\<and> stream_all2 (\\<sim>) xs ys\" if \"A.run (x ## xs)\" \"x \\<sim> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ys. B.run (y ## ys) \\<and> stream_all2 (\\<sim>) xs ys", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ys. B.run (y ## ys) \\<and> stream_all2 (\\<sim>) xs ys", "let ?ys = \"sscan (\\<lambda> a' b. SOME b'. B b b' \\<and> a' \\<sim> b') xs y\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ys. B.run (y ## ys) \\<and> stream_all2 (\\<sim>) xs ys", "have \"B.run (y ## ?ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B.run\n     (y ## sscan (\\<lambda>a' b. SOME b'. B b b' \\<and> a' \\<sim> b') xs y)", "using that"], ["proof (prove)\nusing this:\n  A.run (x ## xs)\n  x \\<sim> y\n\ngoal (1 subgoal):\n 1. B.run\n     (y ## sscan (\\<lambda>a' b. SOME b'. B b b' \\<and> a' \\<sim> b') xs y)", "by (coinduction arbitrary: x y xs) (force dest!: someI_ex A_B_step elim: A.run.cases)"], ["proof (state)\nthis:\n  B.run\n   (y ## sscan (\\<lambda>a' b. SOME b'. B b b' \\<and> a' \\<sim> b') xs y)\n\ngoal (1 subgoal):\n 1. \\<exists>ys. B.run (y ## ys) \\<and> stream_all2 (\\<sim>) xs ys", "moreover"], ["proof (state)\nthis:\n  B.run\n   (y ## sscan (\\<lambda>a' b. SOME b'. B b b' \\<and> a' \\<sim> b') xs y)\n\ngoal (1 subgoal):\n 1. \\<exists>ys. B.run (y ## ys) \\<and> stream_all2 (\\<sim>) xs ys", "have \"stream_all2 (\\<sim>) xs ?ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_all2 (\\<sim>) xs\n     (sscan (\\<lambda>a' b. SOME b'. B b b' \\<and> a' \\<sim> b') xs y)", "using that"], ["proof (prove)\nusing this:\n  A.run (x ## xs)\n  x \\<sim> y\n\ngoal (1 subgoal):\n 1. stream_all2 (\\<sim>) xs\n     (sscan (\\<lambda>a' b. SOME b'. B b b' \\<and> a' \\<sim> b') xs y)", "by (coinduction arbitrary: x y xs) (force dest!: someI_ex A_B_step elim: A.run.cases)"], ["proof (state)\nthis:\n  stream_all2 (\\<sim>) xs\n   (sscan (\\<lambda>a' b. SOME b'. B b b' \\<and> a' \\<sim> b') xs y)\n\ngoal (1 subgoal):\n 1. \\<exists>ys. B.run (y ## ys) \\<and> stream_all2 (\\<sim>) xs ys", "ultimately"], ["proof (chain)\npicking this:\n  B.run\n   (y ## sscan (\\<lambda>a' b. SOME b'. B b b' \\<and> a' \\<sim> b') xs y)\n  stream_all2 (\\<sim>) xs\n   (sscan (\\<lambda>a' b. SOME b'. B b b' \\<and> a' \\<sim> b') xs y)", "show ?thesis"], ["proof (prove)\nusing this:\n  B.run\n   (y ## sscan (\\<lambda>a' b. SOME b'. B b b' \\<and> a' \\<sim> b') xs y)\n  stream_all2 (\\<sim>) xs\n   (sscan (\\<lambda>a' b. SOME b'. B b b' \\<and> a' \\<sim> b') xs y)\n\ngoal (1 subgoal):\n 1. \\<exists>ys. B.run (y ## ys) \\<and> stream_all2 (\\<sim>) xs ys", "by blast"], ["proof (state)\nthis:\n  \\<exists>ys. B.run (y ## ys) \\<and> stream_all2 (\\<sim>) xs ys\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* Simulation *)"], ["", "lemma (in Subgraph) Subgraph_Simulation:\n  \"Simulation E' E (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Simulation E' E (=)", "by standard auto"], ["", "locale Simulation_Invariant = Simulation_Defs +\n  fixes PA :: \"'a \\<Rightarrow> bool\" and PB :: \"'b \\<Rightarrow> bool\"\n  assumes A_B_step: \"\\<And> a b a'. A a b \\<Longrightarrow> PA a \\<Longrightarrow> PB a' \\<Longrightarrow> a \\<sim> a' \\<Longrightarrow> (\\<exists> b'. B a' b' \\<and> b \\<sim> b')\"\n  assumes A_invariant[intro]: \"\\<And> a b. PA a \\<Longrightarrow> A a b \\<Longrightarrow> PA b\"\n  assumes B_invariant[intro]: \"\\<And> a b. PB a \\<Longrightarrow> B a b \\<Longrightarrow> PB b\"\nbegin"], ["", "definition \"equiv' \\<equiv> \\<lambda> a b. a \\<sim> b \\<and> PA a \\<and> PB b\""], ["", "sublocale Simulation A B equiv'"], ["proof (prove)\ngoal (1 subgoal):\n 1. Simulation A B equiv'", "by standard (auto dest: A_B_step simp: equiv'_def)"], ["", "sublocale PA_invariant: Graph_Invariant A PA"], ["proof (prove)\ngoal (1 subgoal):\n 1. Graph_Invariant A PA", "by standard blast"], ["", "lemma simulation_reaches:\n  \"\\<exists> b'. B\\<^sup>*\\<^sup>* b b' \\<and> a' \\<sim> b' \\<and> PA a' \\<and> PB b'\" if \"A\\<^sup>*\\<^sup>* a a'\" \"a \\<sim> b\" \"PA a\" \"PB b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b'.\n       B.reaches b b' \\<and> a' \\<sim> b' \\<and> PA a' \\<and> PB b'", "using simulation_reaches[of a a' b] that"], ["proof (prove)\nusing this:\n  \\<lbrakk>A.reaches a a'; equiv' a b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>b'. B.reaches b b' \\<and> equiv' a' b'\n  A.reaches a a'\n  a \\<sim> b\n  PA a\n  PB b\n\ngoal (1 subgoal):\n 1. \\<exists>b'.\n       B.reaches b b' \\<and> a' \\<sim> b' \\<and> PA a' \\<and> PB b'", "unfolding equiv'_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>A.reaches a a'; a \\<sim> b \\<and> PA a \\<and> PB b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>b'.\n                       B.reaches b b' \\<and>\n                       a' \\<sim> b' \\<and> PA a' \\<and> PB b'\n  A.reaches a a'\n  a \\<sim> b\n  PA a\n  PB b\n\ngoal (1 subgoal):\n 1. \\<exists>b'.\n       B.reaches b b' \\<and> a' \\<sim> b' \\<and> PA a' \\<and> PB b'", "by simp"], ["", "lemma simulation_steps:\n  \"\\<exists> bs. B.steps (b # bs) \\<and> list_all2 (\\<lambda> a b. a \\<sim> b \\<and> PA a \\<and> PB b) as bs\"\n  if \"A.steps (a # as)\" \"a \\<sim> b\" \"PA a\" \"PB b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       B.steps (b # bs) \\<and>\n       list_all2 (\\<lambda>a b. a \\<sim> b \\<and> PA a \\<and> PB b) as bs", "using simulation_steps[of a as b] that"], ["proof (prove)\nusing this:\n  \\<lbrakk>A.steps (a # as); equiv' a b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>bs.\n                       B.steps (b # bs) \\<and> list_all2 equiv' as bs\n  A.steps (a # as)\n  a \\<sim> b\n  PA a\n  PB b\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       B.steps (b # bs) \\<and>\n       list_all2 (\\<lambda>a b. a \\<sim> b \\<and> PA a \\<and> PB b) as bs", "unfolding equiv'_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>A.steps (a # as); a \\<sim> b \\<and> PA a \\<and> PB b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>bs.\n                       B.steps (b # bs) \\<and>\n                       list_all2\n                        (\\<lambda>a b. a \\<sim> b \\<and> PA a \\<and> PB b)\n                        as bs\n  A.steps (a # as)\n  a \\<sim> b\n  PA a\n  PB b\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       B.steps (b # bs) \\<and>\n       list_all2 (\\<lambda>a b. a \\<sim> b \\<and> PA a \\<and> PB b) as bs", "by simp"], ["", "lemma simulation_steps':\n  \"\\<exists> bs. B.steps (b # bs) \\<and> list_all2 (\\<lambda> a b. a \\<sim> b) as bs \\<and> list_all PA as \\<and> list_all PB bs\"\n  if \"A.steps (a # as)\" \"a \\<sim> b\" \"PA a\" \"PB b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       B.steps (b # bs) \\<and>\n       list_all2 (\\<sim>) as bs \\<and> list_all PA as \\<and> list_all PB bs", "using simulation_steps[OF that]"], ["proof (prove)\nusing this:\n  \\<exists>bs.\n     B.steps (b # bs) \\<and>\n     list_all2 (\\<lambda>a b. a \\<sim> b \\<and> PA a \\<and> PB b) as bs\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       B.steps (b # bs) \\<and>\n       list_all2 (\\<sim>) as bs \\<and> list_all PA as \\<and> list_all PB bs", "by (metis (mono_tags, lifting) list_all2_conv_all_nth list_all_length)"], ["", "context\n  fixes f\n  assumes eq: \"a \\<sim> b \\<Longrightarrow> b = f a\"\nbegin"], ["", "lemma simulation_steps'_map:\n  \"\\<exists> bs.\n    B.steps (b # bs) \\<and> bs = map f as\n    \\<and> list_all2 (\\<lambda> a b. a \\<sim> b) as bs\n    \\<and> list_all PA as \\<and> list_all PB bs\"\n  if \"A.steps (a # as)\" \"a \\<sim> b\" \"PA a\" \"PB b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       B.steps (b # bs) \\<and>\n       bs = map f as \\<and>\n       list_all2 (\\<sim>) as bs \\<and> list_all PA as \\<and> list_all PB bs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       B.steps (b # bs) \\<and>\n       bs = map f as \\<and>\n       list_all2 (\\<sim>) as bs \\<and> list_all PA as \\<and> list_all PB bs", "from simulation_steps'[OF that]"], ["proof (chain)\npicking this:\n  \\<exists>bs.\n     B.steps (b # bs) \\<and>\n     list_all2 (\\<sim>) as bs \\<and> list_all PA as \\<and> list_all PB bs", "guess bs"], ["proof (prove)\nusing this:\n  \\<exists>bs.\n     B.steps (b # bs) \\<and>\n     list_all2 (\\<sim>) as bs \\<and> list_all PA as \\<and> list_all PB bs\n\ngoal (1 subgoal):\n 1. thesis", "by clarify"], ["proof (state)\nthis:\n  B.steps (b # bs)\n  list_all2 (\\<sim>) as bs\n  list_all PA as\n  list_all PB bs\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       B.steps (b # bs) \\<and>\n       bs = map f as \\<and>\n       list_all2 (\\<sim>) as bs \\<and> list_all PA as \\<and> list_all PB bs", "note guessed = this"], ["proof (state)\nthis:\n  B.steps (b # bs)\n  list_all2 (\\<sim>) as bs\n  list_all PA as\n  list_all PB bs\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       B.steps (b # bs) \\<and>\n       bs = map f as \\<and>\n       list_all2 (\\<sim>) as bs \\<and> list_all PA as \\<and> list_all PB bs", "from this(2)"], ["proof (chain)\npicking this:\n  list_all2 (\\<sim>) as bs", "have \"bs = map f as\""], ["proof (prove)\nusing this:\n  list_all2 (\\<sim>) as bs\n\ngoal (1 subgoal):\n 1. bs = map f as", "by (induction; simp add: eq)"], ["proof (state)\nthis:\n  bs = map f as\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       B.steps (b # bs) \\<and>\n       bs = map f as \\<and>\n       list_all2 (\\<sim>) as bs \\<and> list_all PA as \\<and> list_all PB bs", "with guessed"], ["proof (chain)\npicking this:\n  B.steps (b # bs)\n  list_all2 (\\<sim>) as bs\n  list_all PA as\n  list_all PB bs\n  bs = map f as", "show ?thesis"], ["proof (prove)\nusing this:\n  B.steps (b # bs)\n  list_all2 (\\<sim>) as bs\n  list_all PA as\n  list_all PB bs\n  bs = map f as\n\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       B.steps (b # bs) \\<and>\n       bs = map f as \\<and>\n       list_all2 (\\<sim>) as bs \\<and> list_all PA as \\<and> list_all PB bs", "by auto"], ["proof (state)\nthis:\n  \\<exists>bs.\n     B.steps (b # bs) \\<and>\n     bs = map f as \\<and>\n     list_all2 (\\<sim>) as bs \\<and> list_all PA as \\<and> list_all PB bs\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* Context for Equality Relation *)"], ["", "end"], ["", "(* Simulation Invariant *)"], ["", "locale Simulation_Invariants = Simulation_Defs +\n  fixes PA QA :: \"'a \\<Rightarrow> bool\" and PB QB :: \"'b \\<Rightarrow> bool\"\n  assumes A_B_step: \"\\<And> a b a'. A a b \\<Longrightarrow> PA a \\<Longrightarrow> PB a' \\<Longrightarrow> a \\<sim> a' \\<Longrightarrow> (\\<exists> b'. B a' b' \\<and> b \\<sim> b')\"\n  assumes A_invariant[intro]: \"\\<And> a b. PA a \\<Longrightarrow> A a b \\<Longrightarrow> QA b\"\n  assumes B_invariant[intro]: \"\\<And> a b. PB a \\<Longrightarrow> B a b \\<Longrightarrow> QB b\"\n  assumes PA_QA[intro]: \"\\<And> a. QA a \\<Longrightarrow> PA a\" and PB_QB[intro]: \"\\<And> a. QB a \\<Longrightarrow> PB a\"\nbegin"], ["", "sublocale Pre: Simulation_Invariant A B \"(\\<sim>)\" PA PB"], ["proof (prove)\ngoal (1 subgoal):\n 1. Simulation_Invariant A B (\\<sim>) PA PB", "by standard (auto intro: A_B_step)"], ["", "sublocale Post: Simulation_Invariant A B \"(\\<sim>)\" QA QB"], ["proof (prove)\ngoal (1 subgoal):\n 1. Simulation_Invariant A B (\\<sim>) QA QB", "by standard (auto intro: A_B_step)"], ["", "sublocale A_invs: Graph_Invariants A PA QA"], ["proof (prove)\ngoal (1 subgoal):\n 1. Graph_Invariants A PA QA", "by standard auto"], ["", "sublocale B_invs: Graph_Invariants B PB QB"], ["proof (prove)\ngoal (1 subgoal):\n 1. Graph_Invariants B PB QB", "by standard auto"], ["", "lemma simulation_reaches1:\n  \"\\<exists> b2. B.reaches1 b1 b2 \\<and> a2 \\<sim> b2 \\<and> QB b2\" if \"A.reaches1 a1 a2\" \"a1 \\<sim> b1\" \"PA a1\" \"PB b1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b2. B.reaches1 b1 b2 \\<and> a2 \\<sim> b2 \\<and> QB b2", "using that"], ["proof (prove)\nusing this:\n  A.reaches1 a1 a2\n  a1 \\<sim> b1\n  PA a1\n  PB b1\n\ngoal (1 subgoal):\n 1. \\<exists>b2. B.reaches1 b1 b2 \\<and> a2 \\<sim> b2 \\<and> QB b2", "by - (drule Pre.simulation_reaches1, auto intro: B_invs.invariant_reaches1 simp: Pre.equiv'_def)"], ["", "lemma reaches1_unique:\n  assumes unique: \"\\<And> b2. a \\<sim> b2 \\<Longrightarrow> QB b2 \\<Longrightarrow> b2 = b\"\n    and that: \"A.reaches1 a a\" \"a \\<sim> b\" \"PA a\" \"PB b\"\n  shows \"B.reaches1 b b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B.reaches1 b b", "using that"], ["proof (prove)\nusing this:\n  A.reaches1 a a\n  a \\<sim> b\n  PA a\n  PB b\n\ngoal (1 subgoal):\n 1. B.reaches1 b b", "by (auto dest: unique simulation_reaches1)"], ["", "end"], ["", "(* Simualation Invariants *)"], ["", "locale Bisimulation = Simulation_Defs +\n  assumes A_B_step: \"\\<And> a b a'. A a b \\<Longrightarrow> a \\<sim> a' \\<Longrightarrow> (\\<exists> b'. B a' b' \\<and> b \\<sim> b')\"\n  assumes B_A_step: \"\\<And> a a' b'. B a' b' \\<Longrightarrow> a \\<sim> a' \\<Longrightarrow> (\\<exists> b. A a b \\<and> b \\<sim> b')\"\nbegin"], ["", "sublocale A_B: Simulation A B \"(\\<sim>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Simulation A B (\\<sim>)", "by standard (rule A_B_step)"], ["", "sublocale B_A: Simulation B A \"\\<lambda> x y. y \\<sim> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Simulation B A (\\<lambda>x y. y \\<sim> x)", "by standard (rule B_A_step)"], ["", "lemma A_B_reaches:\n  \"\\<exists> b'. B\\<^sup>*\\<^sup>* b b' \\<and> a' \\<sim> b'\" if \"A\\<^sup>*\\<^sup>* a a'\" \"a \\<sim> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b'. B.reaches b b' \\<and> a' \\<sim> b'", "using A_B.simulation_reaches[OF that]"], ["proof (prove)\nusing this:\n  \\<exists>b'. B.reaches b b' \\<and> a' \\<sim> b'\n\ngoal (1 subgoal):\n 1. \\<exists>b'. B.reaches b b' \\<and> a' \\<sim> b'", "."], ["", "lemma B_A_reaches:\n  \"\\<exists> b'. A\\<^sup>*\\<^sup>* b b' \\<and> b' \\<sim> a'\" if \"B\\<^sup>*\\<^sup>* a a'\" \"b \\<sim> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b'. A.reaches b b' \\<and> b' \\<sim> a'", "using B_A.simulation_reaches[OF that]"], ["proof (prove)\nusing this:\n  \\<exists>b'. A.reaches b b' \\<and> b' \\<sim> a'\n\ngoal (1 subgoal):\n 1. \\<exists>b'. A.reaches b b' \\<and> b' \\<sim> a'", "."], ["", "end"], ["", "(* Bisim *)"], ["", "locale Bisimulation_Invariant = Simulation_Defs +\n  fixes PA :: \"'a \\<Rightarrow> bool\" and PB :: \"'b \\<Rightarrow> bool\"\n  assumes A_B_step: \"\\<And> a b a'. A a b \\<Longrightarrow> a \\<sim> a' \\<Longrightarrow> PA a \\<Longrightarrow> PB a' \\<Longrightarrow> (\\<exists> b'. B a' b' \\<and> b \\<sim> b')\"\n  assumes B_A_step: \"\\<And> a a' b'. B a' b' \\<Longrightarrow> a \\<sim> a' \\<Longrightarrow> PA a \\<Longrightarrow> PB a' \\<Longrightarrow> (\\<exists> b. A a b \\<and> b \\<sim> b')\"\n  assumes A_invariant[intro]: \"\\<And> a b. PA a \\<Longrightarrow> A a b \\<Longrightarrow> PA b\"\n  assumes B_invariant[intro]: \"\\<And> a b. PB a \\<Longrightarrow> B a b \\<Longrightarrow> PB b\"\nbegin"], ["", "sublocale PA_invariant: Graph_Invariant A PA"], ["proof (prove)\ngoal (1 subgoal):\n 1. Graph_Invariant A PA", "by standard blast"], ["", "sublocale PB_invariant: Graph_Invariant B PB"], ["proof (prove)\ngoal (1 subgoal):\n 1. Graph_Invariant B PB", "by standard blast"], ["", "lemmas B_steps_invariant[intro] = PB_invariant.invariant_reaches"], ["", "definition \"equiv' \\<equiv> \\<lambda> a b. a \\<sim> b \\<and> PA a \\<and> PB b\""], ["", "sublocale bisim: Bisimulation A B equiv'"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bisimulation A B equiv'", "by standard (clarsimp simp add: equiv'_def, frule A_B_step B_A_step, assumption; auto)+"], ["", "sublocale A_B: Simulation_Invariant A B \"(\\<sim>)\" PA PB"], ["proof (prove)\ngoal (1 subgoal):\n 1. Simulation_Invariant A B (\\<sim>) PA PB", "by (standard; blast intro: A_B_step B_A_step)"], ["", "sublocale B_A: Simulation_Invariant B A \"\\<lambda> x y. y \\<sim> x\" PB PA"], ["proof (prove)\ngoal (1 subgoal):\n 1. Simulation_Invariant B A (\\<lambda>x y. y \\<sim> x) PB PA", "by (standard; blast intro: A_B_step B_A_step)"], ["", "context\n  fixes f\n  assumes eq: \"a \\<sim> b \\<longleftrightarrow> b = f a\"\n    and inj: \"\\<forall> a b. PB (f a) \\<and> PA b \\<and> f a = f b \\<longrightarrow> a = b\"\nbegin"], ["", "lemma list_all2_inj_map_eq:\n  \"as = bs\" if \"list_all2 (\\<lambda>a b. a = f b) (map f as) bs\" \"list_all PB (map f as)\" \"list_all PA bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as = bs", "using that inj"], ["proof (prove)\nusing this:\n  list_all2 (\\<lambda>a b. a = f b) (map f as) bs\n  list_all PB (map f as)\n  list_all PA bs\n  \\<forall>a b.\n     PB (f a) \\<and> PA b \\<and> f a = f b \\<longrightarrow> a = b\n\ngoal (1 subgoal):\n 1. as = bs", "by (induction \"map f as\" bs arbitrary: as rule: list_all2_induct) (auto simp: inj_on_def)"], ["", "lemma steps_map_equiv:\n  \"A.steps (a # as) \\<longleftrightarrow> B.steps (b # map f as)\" if \"a \\<sim> b\" \"PA a\" \"PB b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A.steps (a # as) = B.steps (b # map f as)", "using A_B.simulation_steps'_map[of f a as b] B_A.simulation_steps'[of b \"map f as\" a] that eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>a b. a \\<sim> b \\<Longrightarrow> b = f a;\n   A.steps (a # as); a \\<sim> b; PA a; PB b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>bs.\n                       B.steps (b # bs) \\<and>\n                       bs = map f as \\<and>\n                       list_all2 (\\<sim>) as bs \\<and>\n                       list_all PA as \\<and> list_all PB bs\n  \\<lbrakk>B.steps (b # map f as); a \\<sim> b; PB b; PA a\\<rbrakk>\n  \\<Longrightarrow> \\<exists>bs.\n                       A.steps (a # bs) \\<and>\n                       list_all2 (\\<lambda>a b. b \\<sim> a) (map f as)\n                        bs \\<and>\n                       list_all PB (map f as) \\<and> list_all PA bs\n  a \\<sim> b\n  PA a\n  PB b\n  ?a \\<sim> ?b = (?b = f ?a)\n\ngoal (1 subgoal):\n 1. A.steps (a # as) = B.steps (b # map f as)", "by (auto dest: list_all2_inj_map_eq)"], ["", "lemma steps_map:\n  \"\\<exists> as. bs = map f as\" if \"B.steps (f a # bs)\" \"PA a\" \"PB (f a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as. bs = map f as", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as. bs = map f as", "have \"a \\<sim> f a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sim> f a", "unfolding eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. f a = f a", ".."], ["proof (state)\nthis:\n  a \\<sim> f a\n\ngoal (1 subgoal):\n 1. \\<exists>as. bs = map f as", "from B_A.simulation_steps'[OF that(1) this \\<open>PB _\\<close> \\<open>PA _\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>bsa.\n     A.steps (a # bsa) \\<and>\n     list_all2 (\\<lambda>a b. b \\<sim> a) bs bsa \\<and>\n     list_all PB bs \\<and> list_all PA bsa", "guess as"], ["proof (prove)\nusing this:\n  \\<exists>bsa.\n     A.steps (a # bsa) \\<and>\n     list_all2 (\\<lambda>a b. b \\<sim> a) bs bsa \\<and>\n     list_all PB bs \\<and> list_all PA bsa\n\ngoal (1 subgoal):\n 1. thesis", "by clarify"], ["proof (state)\nthis:\n  A.steps (a # as)\n  list_all2 (\\<lambda>a b. b \\<sim> a) bs as\n  list_all PB bs\n  list_all PA as\n\ngoal (1 subgoal):\n 1. \\<exists>as. bs = map f as", "from this(2)"], ["proof (chain)\npicking this:\n  list_all2 (\\<lambda>a b. b \\<sim> a) bs as", "show ?thesis"], ["proof (prove)\nusing this:\n  list_all2 (\\<lambda>a b. b \\<sim> a) bs as\n\ngoal (1 subgoal):\n 1. \\<exists>as. bs = map f as", "unfolding eq"], ["proof (prove)\nusing this:\n  list_all2 (\\<lambda>a b. a = f b) bs as\n\ngoal (1 subgoal):\n 1. \\<exists>as. bs = map f as", "by (inst_existentials as, induction rule: list_all2_induct, auto)"], ["proof (state)\nthis:\n  \\<exists>as. bs = map f as\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reaches_equiv:\n  \"A.reaches a a' \\<longleftrightarrow> B.reaches (f a) (f a')\" if \"PA a\" \"PB (f a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A.reaches a a' = B.reaches (f a) (f a')", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. A.reaches a a' \\<Longrightarrow> B.reaches (f a) (f a')\n 2. B.reaches (f a) (f a') \\<Longrightarrow> A.reaches a a'", "apply (drule A_B.simulation_reaches[of a a' \"f a\"]; simp add: eq that)"], ["proof (prove)\ngoal (1 subgoal):\n 1. B.reaches (f a) (f a') \\<Longrightarrow> A.reaches a a'", "apply (drule B_A.simulation_reaches)"], ["proof (prove)\ngoal (4 subgoals):\n 1. ?b16 \\<sim> f a\n 2. PB (f a)\n 3. PA ?b16\n 4. \\<exists>b'.\n       A.reaches ?b16 b' \\<and>\n       b' \\<sim> f a' \\<and> PB (f a') \\<and> PA b' \\<Longrightarrow>\n    A.reaches a a'", "defer"], ["proof (prove)\ngoal (4 subgoals):\n 1. PB (f a)\n 2. PA ?b16\n 3. \\<exists>b'.\n       A.reaches ?b16 b' \\<and>\n       b' \\<sim> f a' \\<and> PB (f a') \\<and> PA b' \\<Longrightarrow>\n    A.reaches a a'\n 4. ?b16 \\<sim> f a", "apply (rule that | clarsimp simp: eq | metis inj)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "(* Context for Equality Relation *)"], ["", "lemma equiv'_D:\n  \"a \\<sim> b\" if \"A_B.equiv' a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sim> b", "using that"], ["proof (prove)\nusing this:\n  A_B.equiv' a b\n\ngoal (1 subgoal):\n 1. a \\<sim> b", "unfolding A_B.equiv'_def"], ["proof (prove)\nusing this:\n  a \\<sim> b \\<and> PA a \\<and> PB b\n\ngoal (1 subgoal):\n 1. a \\<sim> b", "by auto"], ["", "lemma equiv'_rotate_1:\n  \"B_A.equiv' b a\" if \"A_B.equiv' a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B_A.equiv' b a", "using that"], ["proof (prove)\nusing this:\n  A_B.equiv' a b\n\ngoal (1 subgoal):\n 1. B_A.equiv' b a", "by (auto simp: B_A.equiv'_def A_B.equiv'_def)"], ["", "lemma equiv'_rotate_2:\n  \"A_B.equiv' a b\" if \"B_A.equiv' b a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A_B.equiv' a b", "using that"], ["proof (prove)\nusing this:\n  B_A.equiv' b a\n\ngoal (1 subgoal):\n 1. A_B.equiv' a b", "by (auto simp: B_A.equiv'_def A_B.equiv'_def)"], ["", "lemma stream_all2_equiv'_D:\n  \"stream_all2 (\\<sim>) xs ys\" if \"stream_all2 A_B.equiv' xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_all2 (\\<sim>) xs ys", "using stream_all2_weaken[OF that equiv'_D]"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      A_B.equiv' x y \\<Longrightarrow>\n      A_B.equiv' (?a1 x y) (?b1 x y)) \\<Longrightarrow>\n  stream_all2 (\\<lambda>x y. ?a1 x y \\<sim> ?b1 x y) xs ys\n\ngoal (1 subgoal):\n 1. stream_all2 (\\<sim>) xs ys", "by fast"], ["", "lemma stream_all2_equiv'_D2:\n  \"stream_all2 B_A.equiv' ys xs \\<Longrightarrow> stream_all2 (\\<sim>)\\<inverse>\\<inverse> ys xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_all2 B_A.equiv' ys xs \\<Longrightarrow>\n    stream_all2 (\\<sim>)\\<inverse>\\<inverse> ys xs", "by (coinduction arbitrary: xs ys) (auto simp: B_A.equiv'_def)"], ["", "lemma stream_all2_rotate_1:\n  \"stream_all2 B_A.equiv' ys xs \\<Longrightarrow> stream_all2 A_B.equiv' xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_all2 B_A.equiv' ys xs \\<Longrightarrow>\n    stream_all2 A_B.equiv' xs ys", "by (coinduction arbitrary: xs ys) (auto simp: B_A.equiv'_def A_B.equiv'_def)"], ["", "lemma stream_all2_rotate_2:\n  \"stream_all2 A_B.equiv' xs ys \\<Longrightarrow> stream_all2 B_A.equiv' ys xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_all2 A_B.equiv' xs ys \\<Longrightarrow>\n    stream_all2 B_A.equiv' ys xs", "by (coinduction arbitrary: xs ys) (auto simp: B_A.equiv'_def A_B.equiv'_def)"], ["", "end"], ["", "(* Bisim Invariant *)"], ["", "locale Bisimulation_Invariants = Simulation_Defs +\n  fixes PA QA :: \"'a \\<Rightarrow> bool\" and PB QB :: \"'b \\<Rightarrow> bool\"\n  assumes A_B_step: \"\\<And> a b a'. A a b \\<Longrightarrow> a \\<sim> a' \\<Longrightarrow> PA a \\<Longrightarrow> PB a' \\<Longrightarrow> (\\<exists> b'. B a' b' \\<and> b \\<sim> b')\"\n  assumes B_A_step: \"\\<And> a a' b'. B a' b' \\<Longrightarrow> a \\<sim> a' \\<Longrightarrow> PA a \\<Longrightarrow> PB a' \\<Longrightarrow> (\\<exists> b. A a b \\<and> b \\<sim> b')\"\n  assumes A_invariant[intro]: \"\\<And> a b. PA a \\<Longrightarrow> A a b \\<Longrightarrow> QA b\"\n  assumes B_invariant[intro]: \"\\<And> a b. PB a \\<Longrightarrow> B a b \\<Longrightarrow> QB b\"\n  assumes PA_QA[intro]: \"\\<And> a. QA a \\<Longrightarrow> PA a\" and PB_QB[intro]: \"\\<And> a. QB a \\<Longrightarrow> PB a\"\nbegin"], ["", "sublocale PA_invariant: Graph_Invariant A PA"], ["proof (prove)\ngoal (1 subgoal):\n 1. Graph_Invariant A PA", "by standard blast"], ["", "sublocale PB_invariant: Graph_Invariant B PB"], ["proof (prove)\ngoal (1 subgoal):\n 1. Graph_Invariant B PB", "by standard blast"], ["", "sublocale QA_invariant: Graph_Invariant A QA"], ["proof (prove)\ngoal (1 subgoal):\n 1. Graph_Invariant A QA", "by standard blast"], ["", "sublocale QB_invariant: Graph_Invariant B QB"], ["proof (prove)\ngoal (1 subgoal):\n 1. Graph_Invariant B QB", "by standard blast"], ["", "sublocale Pre_Bisim: Bisimulation_Invariant A B \"(\\<sim>)\" PA PB"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bisimulation_Invariant A B (\\<sim>) PA PB", "by standard (auto intro: A_B_step B_A_step)"], ["", "sublocale Post_Bisim: Bisimulation_Invariant A B \"(\\<sim>)\" QA QB"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bisimulation_Invariant A B (\\<sim>) QA QB", "by standard (auto intro: A_B_step B_A_step)"], ["", "sublocale A_B: Simulation_Invariants A B \"(\\<sim>)\" PA QA PB QB"], ["proof (prove)\ngoal (1 subgoal):\n 1. Simulation_Invariants A B (\\<sim>) PA QA PB QB", "by standard (blast intro: A_B_step)+"], ["", "sublocale B_A: Simulation_Invariants B A \"\\<lambda> x y. y \\<sim> x\" PB QB PA QA"], ["proof (prove)\ngoal (1 subgoal):\n 1. Simulation_Invariants B A (\\<lambda>x y. y \\<sim> x) PB QB PA QA", "by standard (blast intro: B_A_step)+"], ["", "context\n  fixes f\n  assumes eq[simp]: \"a \\<sim> b \\<longleftrightarrow> b = f a\"\n    and inj: \"\\<forall> a b. QB (f a) \\<and> QA b \\<and> f a = f b \\<longrightarrow> a = b\"\nbegin"], ["", "lemmas list_all2_inj_map_eq = Post_Bisim.list_all2_inj_map_eq[OF eq inj]"], ["", "lemmas steps_map_equiv' = Post_Bisim.steps_map_equiv[OF eq inj]"], ["", "lemma list_all2_inj_map_eq':\n  \"as = bs\" if \"list_all2 (\\<lambda>a b. a = f b) (map f as) bs\" \"list_all QB (map f as)\" \"list_all QA bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as = bs", "using that"], ["proof (prove)\nusing this:\n  list_all2 (\\<lambda>a b. a = f b) (map f as) bs\n  list_all QB (map f as)\n  list_all QA bs\n\ngoal (1 subgoal):\n 1. as = bs", "by (rule list_all2_inj_map_eq)"], ["", "lemma steps_map_equiv:\n  \"A.steps (a # as) \\<longleftrightarrow> B.steps (b # map f as)\" if \"a \\<sim> b\" \"PA a\" \"PB b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A.steps (a # as) = B.steps (b # map f as)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. A.steps (a # as) \\<Longrightarrow> B.steps (b # map f as)\n 2. B.steps (b # map f as) \\<Longrightarrow> A.steps (a # as)", "assume \"A.steps (a # as)\""], ["proof (state)\nthis:\n  A.steps (a # as)\n\ngoal (2 subgoals):\n 1. A.steps (a # as) \\<Longrightarrow> B.steps (b # map f as)\n 2. B.steps (b # map f as) \\<Longrightarrow> A.steps (a # as)", "then"], ["proof (chain)\npicking this:\n  A.steps (a # as)", "show \"B.steps (b # map f as)\""], ["proof (prove)\nusing this:\n  A.steps (a # as)\n\ngoal (1 subgoal):\n 1. B.steps (b # map f as)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow> B.steps (b # map f as)\n 2. \\<And>y xs.\n       \\<lbrakk>as = y # xs; A a y; A.steps (y # xs)\\<rbrakk>\n       \\<Longrightarrow> B.steps (b # map f as)", "case Single"], ["proof (state)\nthis:\n  as = []\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow> B.steps (b # map f as)\n 2. \\<And>y xs.\n       \\<lbrakk>as = y # xs; A a y; A.steps (y # xs)\\<rbrakk>\n       \\<Longrightarrow> B.steps (b # map f as)", "then"], ["proof (chain)\npicking this:\n  as = []", "show ?thesis"], ["proof (prove)\nusing this:\n  as = []\n\ngoal (1 subgoal):\n 1. B.steps (b # map f as)", "by auto"], ["proof (state)\nthis:\n  B.steps (b # map f as)\n\ngoal (1 subgoal):\n 1. \\<And>y xs.\n       \\<lbrakk>as = y # xs; A a y; A.steps (y # xs)\\<rbrakk>\n       \\<Longrightarrow> B.steps (b # map f as)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y xs.\n       \\<lbrakk>as = y # xs; A a y; A.steps (y # xs)\\<rbrakk>\n       \\<Longrightarrow> B.steps (b # map f as)", "case prems: (Cons a' xs)"], ["proof (state)\nthis:\n  as = a' # xs\n  A a a'\n  A.steps (a' # xs)\n\ngoal (1 subgoal):\n 1. \\<And>y xs.\n       \\<lbrakk>as = y # xs; A a y; A.steps (y # xs)\\<rbrakk>\n       \\<Longrightarrow> B.steps (b # map f as)", "from A_B_step[OF \\<open>A a a'\\<close> \\<open>a \\<sim> b\\<close> \\<open>PA a\\<close> \\<open>PB b\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>b'. B b b' \\<and> a' \\<sim> b'", "obtain b' where \"B b b'\" \"a' \\<sim> b'\""], ["proof (prove)\nusing this:\n  \\<exists>b'. B b b' \\<and> a' \\<sim> b'\n\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<lbrakk>B b b'; a' \\<sim> b'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  B b b'\n  a' \\<sim> b'\n\ngoal (1 subgoal):\n 1. \\<And>y xs.\n       \\<lbrakk>as = y # xs; A a y; A.steps (y # xs)\\<rbrakk>\n       \\<Longrightarrow> B.steps (b # map f as)", "with steps_map_equiv'[OF \\<open>a' \\<sim> b'\\<close>, of xs] prems that"], ["proof (chain)\npicking this:\n  \\<lbrakk>QA a'; QB b'\\<rbrakk>\n  \\<Longrightarrow> A.steps (a' # xs) = B.steps (b' # map f xs)\n  as = a' # xs\n  A a a'\n  A.steps (a' # xs)\n  a \\<sim> b\n  PA a\n  PB b\n  B b b'\n  a' \\<sim> b'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>QA a'; QB b'\\<rbrakk>\n  \\<Longrightarrow> A.steps (a' # xs) = B.steps (b' # map f xs)\n  as = a' # xs\n  A a a'\n  A.steps (a' # xs)\n  a \\<sim> b\n  PA a\n  PB b\n  B b b'\n  a' \\<sim> b'\n\ngoal (1 subgoal):\n 1. B.steps (b # map f as)", "by auto"], ["proof (state)\nthis:\n  B.steps (b # map f as)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  B.steps (b # map f as)\n\ngoal (1 subgoal):\n 1. B.steps (b # map f as) \\<Longrightarrow> A.steps (a # as)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. B.steps (b # map f as) \\<Longrightarrow> A.steps (a # as)", "assume \"B.steps (b # map f as)\""], ["proof (state)\nthis:\n  B.steps (b # map f as)\n\ngoal (1 subgoal):\n 1. B.steps (b # map f as) \\<Longrightarrow> A.steps (a # as)", "then"], ["proof (chain)\npicking this:\n  B.steps (b # map f as)", "show \"A.steps (a # as)\""], ["proof (prove)\nusing this:\n  B.steps (b # map f as)\n\ngoal (1 subgoal):\n 1. A.steps (a # as)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. map f as = [] \\<Longrightarrow> A.steps (a # as)\n 2. \\<And>y xs.\n       \\<lbrakk>map f as = y # xs; B b y; B.steps (y # xs)\\<rbrakk>\n       \\<Longrightarrow> A.steps (a # as)", "case Single"], ["proof (state)\nthis:\n  map f as = []\n\ngoal (2 subgoals):\n 1. map f as = [] \\<Longrightarrow> A.steps (a # as)\n 2. \\<And>y xs.\n       \\<lbrakk>map f as = y # xs; B b y; B.steps (y # xs)\\<rbrakk>\n       \\<Longrightarrow> A.steps (a # as)", "then"], ["proof (chain)\npicking this:\n  map f as = []", "show ?thesis"], ["proof (prove)\nusing this:\n  map f as = []\n\ngoal (1 subgoal):\n 1. A.steps (a # as)", "by auto"], ["proof (state)\nthis:\n  A.steps (a # as)\n\ngoal (1 subgoal):\n 1. \\<And>y xs.\n       \\<lbrakk>map f as = y # xs; B b y; B.steps (y # xs)\\<rbrakk>\n       \\<Longrightarrow> A.steps (a # as)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y xs.\n       \\<lbrakk>map f as = y # xs; B b y; B.steps (y # xs)\\<rbrakk>\n       \\<Longrightarrow> A.steps (a # as)", "case prems: (Cons b' xs)"], ["proof (state)\nthis:\n  map f as = b' # xs\n  B b b'\n  B.steps (b' # xs)\n\ngoal (1 subgoal):\n 1. \\<And>y xs.\n       \\<lbrakk>map f as = y # xs; B b y; B.steps (y # xs)\\<rbrakk>\n       \\<Longrightarrow> A.steps (a # as)", "from B_A_step[OF \\<open>B b b'\\<close> \\<open>a \\<sim> b\\<close> \\<open>PA a\\<close> \\<open>PB b\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>b. A a b \\<and> b \\<sim> b'", "obtain a' where \"A a a'\" \"a' \\<sim> b'\""], ["proof (prove)\nusing this:\n  \\<exists>b. A a b \\<and> b \\<sim> b'\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>A a a'; a' \\<sim> b'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A a a'\n  a' \\<sim> b'\n\ngoal (1 subgoal):\n 1. \\<And>y xs.\n       \\<lbrakk>map f as = y # xs; B b y; B.steps (y # xs)\\<rbrakk>\n       \\<Longrightarrow> A.steps (a # as)", "with that prems"], ["proof (chain)\npicking this:\n  a \\<sim> b\n  PA a\n  PB b\n  map f as = b' # xs\n  B b b'\n  B.steps (b' # xs)\n  A a a'\n  a' \\<sim> b'", "have \"QA a'\" \"QB b'\""], ["proof (prove)\nusing this:\n  a \\<sim> b\n  PA a\n  PB b\n  map f as = b' # xs\n  B b b'\n  B.steps (b' # xs)\n  A a a'\n  a' \\<sim> b'\n\ngoal (1 subgoal):\n 1. QA a' &&& QB b'", "by auto"], ["proof (state)\nthis:\n  QA a'\n  QB b'\n\ngoal (1 subgoal):\n 1. \\<And>y xs.\n       \\<lbrakk>map f as = y # xs; B b y; B.steps (y # xs)\\<rbrakk>\n       \\<Longrightarrow> A.steps (a # as)", "with \\<open>A a a'\\<close> \\<open>a' \\<sim> b'\\<close> steps_map_equiv'[OF \\<open>a' \\<sim> b'\\<close>, of \"tl as\"] prems that"], ["proof (chain)\npicking this:\n  A a a'\n  a' \\<sim> b'\n  \\<lbrakk>QA a'; QB b'\\<rbrakk>\n  \\<Longrightarrow> A.steps (a' # tl as) = B.steps (b' # map f (tl as))\n  map f as = b' # xs\n  B b b'\n  B.steps (b' # xs)\n  a \\<sim> b\n  PA a\n  PB b\n  QA a'\n  QB b'", "show ?thesis"], ["proof (prove)\nusing this:\n  A a a'\n  a' \\<sim> b'\n  \\<lbrakk>QA a'; QB b'\\<rbrakk>\n  \\<Longrightarrow> A.steps (a' # tl as) = B.steps (b' # map f (tl as))\n  map f as = b' # xs\n  B b b'\n  B.steps (b' # xs)\n  a \\<sim> b\n  PA a\n  PB b\n  QA a'\n  QB b'\n\ngoal (1 subgoal):\n 1. A.steps (a # as)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z zs.\n       \\<lbrakk>A a a'; b' = f a'; A.steps (a' # zs); B (f a) (f a');\n        B.steps (f a' # map f zs); b = f a; PA a; PB (f a); QA a';\n        QB (f a'); as = z # zs; f z = f a'; xs = map f zs\\<rbrakk>\n       \\<Longrightarrow> A.steps (a # z # zs)", "subgoal for z zs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A a a'; b' = f a'; A.steps (a' # zs); B (f a) (f a');\n     B.steps (f a' # map f zs); b = f a; PA a; PB (f a); QA a'; QB (f a');\n     as = z # zs; f z = f a'; xs = map f zs\\<rbrakk>\n    \\<Longrightarrow> A.steps (a # z # zs)", "using inj[rule_format, of z a']"], ["proof (prove)\nusing this:\n  QB (f z) \\<and> QA a' \\<and> f z = f a' \\<Longrightarrow> z = a'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A a a'; b' = f a'; A.steps (a' # zs); B (f a) (f a');\n     B.steps (f a' # map f zs); b = f a; PA a; PB (f a); QA a'; QB (f a');\n     as = z # zs; f z = f a'; xs = map f zs\\<rbrakk>\n    \\<Longrightarrow> A.steps (a # z # zs)", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  A.steps (a # as)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A.steps (a # as)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma steps_map:\n  \"\\<exists> as. bs = map f as\" if \"B.steps (f a # bs)\" \"PA a\" \"PB (f a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as. bs = map f as", "using that"], ["proof (prove)\nusing this:\n  B.steps (f a # bs)\n  PA a\n  PB (f a)\n\ngoal (1 subgoal):\n 1. \\<exists>as. bs = map f as", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>PA a; PB (f a); bs = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as. bs = map f as\n 2. \\<And>y xs.\n       \\<lbrakk>PA a; PB (f a); bs = y # xs; B (f a) y;\n        B.steps (y # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as. bs = map f as", "case Single"], ["proof (state)\nthis:\n  bs = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>PA a; PB (f a); bs = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as. bs = map f as\n 2. \\<And>y xs.\n       \\<lbrakk>PA a; PB (f a); bs = y # xs; B (f a) y;\n        B.steps (y # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as. bs = map f as", "then"], ["proof (chain)\npicking this:\n  bs = []", "show ?thesis"], ["proof (prove)\nusing this:\n  bs = []\n\ngoal (1 subgoal):\n 1. \\<exists>as. bs = map f as", "by simp"], ["proof (state)\nthis:\n  \\<exists>as. bs = map f as\n\ngoal (1 subgoal):\n 1. \\<And>y xs.\n       \\<lbrakk>PA a; PB (f a); bs = y # xs; B (f a) y;\n        B.steps (y # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as. bs = map f as", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y xs.\n       \\<lbrakk>PA a; PB (f a); bs = y # xs; B (f a) y;\n        B.steps (y # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as. bs = map f as", "case prems: (Cons b' xs)"], ["proof (state)\nthis:\n  bs = b' # xs\n  B (f a) b'\n  B.steps (b' # xs)\n\ngoal (1 subgoal):\n 1. \\<And>y xs.\n       \\<lbrakk>PA a; PB (f a); bs = y # xs; B (f a) y;\n        B.steps (y # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as. bs = map f as", "from B_A_step[OF \\<open>B _ b'\\<close> _ \\<open>PA a\\<close> \\<open>PB (f a)\\<close>]"], ["proof (chain)\npicking this:\n  a \\<sim> f a \\<Longrightarrow> \\<exists>b. A a b \\<and> b \\<sim> b'", "obtain a' where \"A a a'\" \"a' \\<sim> b'\""], ["proof (prove)\nusing this:\n  a \\<sim> f a \\<Longrightarrow> \\<exists>b. A a b \\<and> b \\<sim> b'\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>A a a'; a' \\<sim> b'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A a a'\n  a' \\<sim> b'\n\ngoal (1 subgoal):\n 1. \\<And>y xs.\n       \\<lbrakk>PA a; PB (f a); bs = y # xs; B (f a) y;\n        B.steps (y # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as. bs = map f as", "with that prems"], ["proof (chain)\npicking this:\n  B.steps (f a # bs)\n  PA a\n  PB (f a)\n  bs = b' # xs\n  B (f a) b'\n  B.steps (b' # xs)\n  A a a'\n  a' \\<sim> b'", "have \"QA a'\" \"QB b'\""], ["proof (prove)\nusing this:\n  B.steps (f a # bs)\n  PA a\n  PB (f a)\n  bs = b' # xs\n  B (f a) b'\n  B.steps (b' # xs)\n  A a a'\n  a' \\<sim> b'\n\ngoal (1 subgoal):\n 1. QA a' &&& QB b'", "by auto"], ["proof (state)\nthis:\n  QA a'\n  QB b'\n\ngoal (1 subgoal):\n 1. \\<And>y xs.\n       \\<lbrakk>PA a; PB (f a); bs = y # xs; B (f a) y;\n        B.steps (y # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as. bs = map f as", "with Post_Bisim.steps_map[OF eq inj, of a' xs] prems \\<open>a' \\<sim> b'\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>B.steps (f a' # xs); QA a'; QB (f a')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as. xs = map f as\n  bs = b' # xs\n  B (f a) b'\n  B.steps (b' # xs)\n  a' \\<sim> b'\n  QA a'\n  QB b'", "obtain ys where \"xs = map f ys\""], ["proof (prove)\nusing this:\n  \\<lbrakk>B.steps (f a' # xs); QA a'; QB (f a')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as. xs = map f as\n  bs = b' # xs\n  B (f a) b'\n  B.steps (b' # xs)\n  a' \\<sim> b'\n  QA a'\n  QB b'\n\ngoal (1 subgoal):\n 1. (\\<And>ys. xs = map f ys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  xs = map f ys\n\ngoal (1 subgoal):\n 1. \\<And>y xs.\n       \\<lbrakk>PA a; PB (f a); bs = y # xs; B (f a) y;\n        B.steps (y # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as. bs = map f as", "with \\<open>bs = _\\<close> \\<open>a' \\<sim> b'\\<close>"], ["proof (chain)\npicking this:\n  bs = b' # xs\n  a' \\<sim> b'\n  xs = map f ys", "show ?thesis"], ["proof (prove)\nusing this:\n  bs = b' # xs\n  a' \\<sim> b'\n  xs = map f ys\n\ngoal (1 subgoal):\n 1. \\<exists>as. bs = map f as", "by (inst_existentials \"a' # ys\") auto"], ["proof (state)\nthis:\n  \\<exists>as. bs = map f as\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  @{thm Post_Bisim.reaches_equiv} cannot be lifted directly:\n  injectivity cannot be applied for the reflexive case.\n\\<close>"], ["", "lemma reaches1_equiv:\n  \"A.reaches1 a a' \\<longleftrightarrow> B.reaches1 (f a) (f a')\" if \"PA a\" \"PB (f a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A.reaches1 a a' = B.reaches1 (f a) (f a')", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. A.reaches1 a a' \\<Longrightarrow> B.reaches1 (f a) (f a')\n 2. B.reaches1 (f a) (f a') \\<Longrightarrow> A.reaches1 a a'", "assume \"A.reaches1 a a'\""], ["proof (state)\nthis:\n  A.reaches1 a a'\n\ngoal (2 subgoals):\n 1. A.reaches1 a a' \\<Longrightarrow> B.reaches1 (f a) (f a')\n 2. B.reaches1 (f a) (f a') \\<Longrightarrow> A.reaches1 a a'", "then"], ["proof (chain)\npicking this:\n  A.reaches1 a a'", "obtain a'' where prems: \"A a a''\" \"A.reaches a'' a'\""], ["proof (prove)\nusing this:\n  A.reaches1 a a'\n\ngoal (1 subgoal):\n 1. (\\<And>a''.\n        \\<lbrakk>A a a''; A.reaches a'' a'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "including graph_automation_aggressive"], ["proof (prove)\nusing this:\n  A.reaches1 a a'\n\ngoal (1 subgoal):\n 1. (\\<And>a''.\n        \\<lbrakk>A a a''; A.reaches a'' a'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  A a a''\n  A.reaches a'' a'\n\ngoal (2 subgoals):\n 1. A.reaches1 a a' \\<Longrightarrow> B.reaches1 (f a) (f a')\n 2. B.reaches1 (f a) (f a') \\<Longrightarrow> A.reaches1 a a'", "from A_B_step[OF \\<open>A a _\\<close> _ that]"], ["proof (chain)\npicking this:\n  a \\<sim> f a \\<Longrightarrow>\n  \\<exists>b'. B (f a) b' \\<and> a'' \\<sim> b'", "obtain b where \"B (f a) b\" \"a'' \\<sim> b\""], ["proof (prove)\nusing this:\n  a \\<sim> f a \\<Longrightarrow>\n  \\<exists>b'. B (f a) b' \\<and> a'' \\<sim> b'\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>B (f a) b; a'' \\<sim> b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  B (f a) b\n  a'' \\<sim> b\n\ngoal (2 subgoals):\n 1. A.reaches1 a a' \\<Longrightarrow> B.reaches1 (f a) (f a')\n 2. B.reaches1 (f a) (f a') \\<Longrightarrow> A.reaches1 a a'", "with that prems"], ["proof (chain)\npicking this:\n  PA a\n  PB (f a)\n  A a a''\n  A.reaches a'' a'\n  B (f a) b\n  a'' \\<sim> b", "have \"QA a''\" \"QB b\""], ["proof (prove)\nusing this:\n  PA a\n  PB (f a)\n  A a a''\n  A.reaches a'' a'\n  B (f a) b\n  a'' \\<sim> b\n\ngoal (1 subgoal):\n 1. QA a'' &&& QB b", "by auto"], ["proof (state)\nthis:\n  QA a''\n  QB b\n\ngoal (2 subgoals):\n 1. A.reaches1 a a' \\<Longrightarrow> B.reaches1 (f a) (f a')\n 2. B.reaches1 (f a) (f a') \\<Longrightarrow> A.reaches1 a a'", "with Post_Bisim.reaches_equiv[OF eq inj, of a'' a'] prems \\<open>B (f a) b\\<close> \\<open>a'' \\<sim> b\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>QA a''; QB (f a'')\\<rbrakk>\n  \\<Longrightarrow> A.reaches a'' a' = B.reaches (f a'') (f a')\n  A a a''\n  A.reaches a'' a'\n  B (f a) b\n  a'' \\<sim> b\n  QA a''\n  QB b", "show \"B.reaches1 (f a) (f a')\""], ["proof (prove)\nusing this:\n  \\<lbrakk>QA a''; QB (f a'')\\<rbrakk>\n  \\<Longrightarrow> A.reaches a'' a' = B.reaches (f a'') (f a')\n  A a a''\n  A.reaches a'' a'\n  B (f a) b\n  a'' \\<sim> b\n  QA a''\n  QB b\n\ngoal (1 subgoal):\n 1. B.reaches1 (f a) (f a')", "by auto"], ["proof (state)\nthis:\n  B.reaches1 (f a) (f a')\n\ngoal (1 subgoal):\n 1. B.reaches1 (f a) (f a') \\<Longrightarrow> A.reaches1 a a'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. B.reaches1 (f a) (f a') \\<Longrightarrow> A.reaches1 a a'", "assume \"B.reaches1 (f a) (f a')\""], ["proof (state)\nthis:\n  B.reaches1 (f a) (f a')\n\ngoal (1 subgoal):\n 1. B.reaches1 (f a) (f a') \\<Longrightarrow> A.reaches1 a a'", "then"], ["proof (chain)\npicking this:\n  B.reaches1 (f a) (f a')", "obtain b where prems: \"B (f a) b\" \"B.reaches b (f a')\""], ["proof (prove)\nusing this:\n  B.reaches1 (f a) (f a')\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>B (f a) b; B.reaches b (f a')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "including graph_automation_aggressive"], ["proof (prove)\nusing this:\n  B.reaches1 (f a) (f a')\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>B (f a) b; B.reaches b (f a')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  B (f a) b\n  B.reaches b (f a')\n\ngoal (1 subgoal):\n 1. B.reaches1 (f a) (f a') \\<Longrightarrow> A.reaches1 a a'", "from B_A_step[OF \\<open>B _ b\\<close> _ \\<open>PA a\\<close> \\<open>PB (f a)\\<close>]"], ["proof (chain)\npicking this:\n  a \\<sim> f a \\<Longrightarrow> \\<exists>ba. A a ba \\<and> ba \\<sim> b", "obtain a'' where \"A a a''\" \"a'' \\<sim> b\""], ["proof (prove)\nusing this:\n  a \\<sim> f a \\<Longrightarrow> \\<exists>ba. A a ba \\<and> ba \\<sim> b\n\ngoal (1 subgoal):\n 1. (\\<And>a''.\n        \\<lbrakk>A a a''; a'' \\<sim> b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A a a''\n  a'' \\<sim> b\n\ngoal (1 subgoal):\n 1. B.reaches1 (f a) (f a') \\<Longrightarrow> A.reaches1 a a'", "with that prems"], ["proof (chain)\npicking this:\n  PA a\n  PB (f a)\n  B (f a) b\n  B.reaches b (f a')\n  A a a''\n  a'' \\<sim> b", "have \"QA a''\" \"QB b\""], ["proof (prove)\nusing this:\n  PA a\n  PB (f a)\n  B (f a) b\n  B.reaches b (f a')\n  A a a''\n  a'' \\<sim> b\n\ngoal (1 subgoal):\n 1. QA a'' &&& QB b", "by auto"], ["proof (state)\nthis:\n  QA a''\n  QB b\n\ngoal (1 subgoal):\n 1. B.reaches1 (f a) (f a') \\<Longrightarrow> A.reaches1 a a'", "with Post_Bisim.reaches_equiv[OF eq inj, of a'' a'] prems \\<open>A a a''\\<close> \\<open>a'' \\<sim> b\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>QA a''; QB (f a'')\\<rbrakk>\n  \\<Longrightarrow> A.reaches a'' a' = B.reaches (f a'') (f a')\n  B (f a) b\n  B.reaches b (f a')\n  A a a''\n  a'' \\<sim> b\n  QA a''\n  QB b", "show \"A.reaches1 a a'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>QA a''; QB (f a'')\\<rbrakk>\n  \\<Longrightarrow> A.reaches a'' a' = B.reaches (f a'') (f a')\n  B (f a) b\n  B.reaches b (f a')\n  A a a''\n  a'' \\<sim> b\n  QA a''\n  QB b\n\ngoal (1 subgoal):\n 1. A.reaches1 a a'", "by auto"], ["proof (state)\nthis:\n  A.reaches1 a a'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* Context for Equality Relation *)"], ["", "end"], ["", "(* Bisim Invariant *)"], ["", "lemma Bisimulation_Invariant_composition:\n  assumes\n    \"Bisimulation_Invariant A B sim1 PA PB\"\n    \"Bisimulation_Invariant B C sim2 PB PC\"\n  shows\n    \"Bisimulation_Invariant A C (\\<lambda> a c. \\<exists> b. PB b \\<and> sim1 a b \\<and> sim2 b c) PA PC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Bisimulation_Invariant A C\n     (\\<lambda>a c. \\<exists>b. PB b \\<and> sim1 a b \\<and> sim2 b c) PA PC", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Bisimulation_Invariant A C\n     (\\<lambda>a c. \\<exists>b. PB b \\<and> sim1 a b \\<and> sim2 b c) PA PC", "interpret A: Bisimulation_Invariant A B sim1 PA PB"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bisimulation_Invariant A B sim1 PA PB", "by (rule assms(1))"], ["proof (state)\ngoal (1 subgoal):\n 1. Bisimulation_Invariant A C\n     (\\<lambda>a c. \\<exists>b. PB b \\<and> sim1 a b \\<and> sim2 b c) PA PC", "interpret B: Bisimulation_Invariant B C sim2 PB PC"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bisimulation_Invariant B C sim2 PB PC", "by (rule assms(2))"], ["proof (state)\ngoal (1 subgoal):\n 1. Bisimulation_Invariant A C\n     (\\<lambda>a c. \\<exists>b. PB b \\<and> sim1 a b \\<and> sim2 b c) PA PC", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bisimulation_Invariant A C\n     (\\<lambda>a c. \\<exists>b. PB b \\<and> sim1 a b \\<and> sim2 b c) PA PC", "by (standard; (blast dest: A.A_B_step B.A_B_step | blast dest: A.B_A_step B.B_A_step))"], ["proof (state)\nthis:\n  Bisimulation_Invariant A C\n   (\\<lambda>a c. \\<exists>b. PB b \\<and> sim1 a b \\<and> sim2 b c) PA PC\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Bisimulation_Invariant_filter:\n  assumes\n    \"Bisimulation_Invariant A B sim PA PB\"\n    \"\\<And> a b. sim a b \\<Longrightarrow> PA a \\<Longrightarrow> PB b \\<Longrightarrow> FA a \\<longleftrightarrow> FB b\"\n    \"\\<And> a b. A a b \\<and> FA b \\<longleftrightarrow> A' a b\"\n    \"\\<And> a b. B a b \\<and> FB b \\<longleftrightarrow> B' a b\"\n  shows\n    \"Bisimulation_Invariant A' B' sim PA PB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Bisimulation_Invariant A' B' sim PA PB", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Bisimulation_Invariant A' B' sim PA PB", "interpret Bisimulation_Invariant A B sim PA PB"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bisimulation_Invariant A B sim PA PB", "by (rule assms(1))"], ["proof (state)\ngoal (1 subgoal):\n 1. Bisimulation_Invariant A' B' sim PA PB", "have unfold:\n    \"A' = (\\<lambda> a b. A a b \\<and> FA b)\" \"B' = (\\<lambda> a b. B a b \\<and> FB b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A' = (\\<lambda>a b. A a b \\<and> FA b) &&&\n    B' = (\\<lambda>a b. B a b \\<and> FB b)", "using assms(3,4)"], ["proof (prove)\nusing this:\n  (A ?a ?b \\<and> FA ?b) = A' ?a ?b\n  (B ?a ?b \\<and> FB ?b) = B' ?a ?b\n\ngoal (1 subgoal):\n 1. A' = (\\<lambda>a b. A a b \\<and> FA b) &&&\n    B' = (\\<lambda>a b. B a b \\<and> FB b)", "by auto"], ["proof (state)\nthis:\n  A' = (\\<lambda>a b. A a b \\<and> FA b)\n  B' = (\\<lambda>a b. B a b \\<and> FB b)\n\ngoal (1 subgoal):\n 1. Bisimulation_Invariant A' B' sim PA PB", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bisimulation_Invariant A' B' sim PA PB", "unfolding unfold"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bisimulation_Invariant (\\<lambda>a b. A a b \\<and> FA b)\n     (\\<lambda>a b. B a b \\<and> FB b) sim PA PB", "apply standard"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b a'.\n       \\<lbrakk>A a b \\<and> FA b; sim a a'; PA a; PB a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. (B a' b' \\<and> FB b') \\<and> sim b b'\n 2. \\<And>a a' b'.\n       \\<lbrakk>B a' b' \\<and> FB b'; sim a a'; PA a; PB a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. (A a b \\<and> FA b) \\<and> sim b b'\n 3. \\<And>a b.\n       \\<lbrakk>PA a; A a b \\<and> FA b\\<rbrakk> \\<Longrightarrow> PA b\n 4. \\<And>a b.\n       \\<lbrakk>PB a; B a b \\<and> FB b\\<rbrakk> \\<Longrightarrow> PB b", "using assms(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>sim ?a ?b; PA ?a; PB ?b\\<rbrakk> \\<Longrightarrow> FA ?a = FB ?b\n\ngoal (4 subgoals):\n 1. \\<And>a b a'.\n       \\<lbrakk>A a b \\<and> FA b; sim a a'; PA a; PB a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. (B a' b' \\<and> FB b') \\<and> sim b b'\n 2. \\<And>a a' b'.\n       \\<lbrakk>B a' b' \\<and> FB b'; sim a a'; PA a; PB a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. (A a b \\<and> FA b) \\<and> sim b b'\n 3. \\<And>a b.\n       \\<lbrakk>PA a; A a b \\<and> FA b\\<rbrakk> \\<Longrightarrow> PA b\n 4. \\<And>a b.\n       \\<lbrakk>PB a; B a b \\<and> FB b\\<rbrakk> \\<Longrightarrow> PB b", "apply (blast dest: A_B_step)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a a' b'.\n       \\<lbrakk>B a' b' \\<and> FB b'; sim a a'; PA a; PB a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. (A a b \\<and> FA b) \\<and> sim b b'\n 2. \\<And>a b.\n       \\<lbrakk>PA a; A a b \\<and> FA b\\<rbrakk> \\<Longrightarrow> PA b\n 3. \\<And>a b.\n       \\<lbrakk>PB a; B a b \\<and> FB b\\<rbrakk> \\<Longrightarrow> PB b", "using assms(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>sim ?a ?b; PA ?a; PB ?b\\<rbrakk> \\<Longrightarrow> FA ?a = FB ?b\n\ngoal (3 subgoals):\n 1. \\<And>a a' b'.\n       \\<lbrakk>B a' b' \\<and> FB b'; sim a a'; PA a; PB a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. (A a b \\<and> FA b) \\<and> sim b b'\n 2. \\<And>a b.\n       \\<lbrakk>PA a; A a b \\<and> FA b\\<rbrakk> \\<Longrightarrow> PA b\n 3. \\<And>a b.\n       \\<lbrakk>PB a; B a b \\<and> FB b\\<rbrakk> \\<Longrightarrow> PB b", "apply (blast dest: B_A_step)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>PA a; A a b \\<and> FA b\\<rbrakk> \\<Longrightarrow> PA b\n 2. \\<And>a b.\n       \\<lbrakk>PB a; B a b \\<and> FB b\\<rbrakk> \\<Longrightarrow> PB b", "by blast+"], ["proof (state)\nthis:\n  Bisimulation_Invariant A' B' sim PA PB\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Bisimulation_Invariants_filter:\n  assumes\n    \"Bisimulation_Invariants A B sim PA QA PB QB\"\n    \"\\<And> a b. QA a \\<Longrightarrow> QB b \\<Longrightarrow> FA a \\<longleftrightarrow> FB b\"\n    \"\\<And> a b. A a b \\<and> FA b \\<longleftrightarrow> A' a b\"\n    \"\\<And> a b. B a b \\<and> FB b \\<longleftrightarrow> B' a b\"\n  shows\n    \"Bisimulation_Invariants A' B' sim PA QA PB QB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Bisimulation_Invariants A' B' sim PA QA PB QB", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Bisimulation_Invariants A' B' sim PA QA PB QB", "interpret Bisimulation_Invariants A B sim PA QA PB QB"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bisimulation_Invariants A B sim PA QA PB QB", "by (rule assms(1))"], ["proof (state)\ngoal (1 subgoal):\n 1. Bisimulation_Invariants A' B' sim PA QA PB QB", "have unfold:\n    \"A' = (\\<lambda> a b. A a b \\<and> FA b)\" \"B' = (\\<lambda> a b. B a b \\<and> FB b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A' = (\\<lambda>a b. A a b \\<and> FA b) &&&\n    B' = (\\<lambda>a b. B a b \\<and> FB b)", "using assms(3,4)"], ["proof (prove)\nusing this:\n  (A ?a ?b \\<and> FA ?b) = A' ?a ?b\n  (B ?a ?b \\<and> FB ?b) = B' ?a ?b\n\ngoal (1 subgoal):\n 1. A' = (\\<lambda>a b. A a b \\<and> FA b) &&&\n    B' = (\\<lambda>a b. B a b \\<and> FB b)", "by auto"], ["proof (state)\nthis:\n  A' = (\\<lambda>a b. A a b \\<and> FA b)\n  B' = (\\<lambda>a b. B a b \\<and> FB b)\n\ngoal (1 subgoal):\n 1. Bisimulation_Invariants A' B' sim PA QA PB QB", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bisimulation_Invariants A' B' sim PA QA PB QB", "unfolding unfold"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bisimulation_Invariants (\\<lambda>a b. A a b \\<and> FA b)\n     (\\<lambda>a b. B a b \\<and> FB b) sim PA QA PB QB", "apply standard"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a b a'.\n       \\<lbrakk>A a b \\<and> FA b; sim a a'; PA a; PB a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. (B a' b' \\<and> FB b') \\<and> sim b b'\n 2. \\<And>a a' b'.\n       \\<lbrakk>B a' b' \\<and> FB b'; sim a a'; PA a; PB a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. (A a b \\<and> FA b) \\<and> sim b b'\n 3. \\<And>a b.\n       \\<lbrakk>PA a; A a b \\<and> FA b\\<rbrakk> \\<Longrightarrow> QA b\n 4. \\<And>a b.\n       \\<lbrakk>PB a; B a b \\<and> FB b\\<rbrakk> \\<Longrightarrow> QB b\n 5. \\<And>a. QA a \\<Longrightarrow> PA a\n 6. \\<And>a. QB a \\<Longrightarrow> PB a", "using assms(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>QA ?a; QB ?b\\<rbrakk> \\<Longrightarrow> FA ?a = FB ?b\n\ngoal (6 subgoals):\n 1. \\<And>a b a'.\n       \\<lbrakk>A a b \\<and> FA b; sim a a'; PA a; PB a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. (B a' b' \\<and> FB b') \\<and> sim b b'\n 2. \\<And>a a' b'.\n       \\<lbrakk>B a' b' \\<and> FB b'; sim a a'; PA a; PB a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. (A a b \\<and> FA b) \\<and> sim b b'\n 3. \\<And>a b.\n       \\<lbrakk>PA a; A a b \\<and> FA b\\<rbrakk> \\<Longrightarrow> QA b\n 4. \\<And>a b.\n       \\<lbrakk>PB a; B a b \\<and> FB b\\<rbrakk> \\<Longrightarrow> QB b\n 5. \\<And>a. QA a \\<Longrightarrow> PA a\n 6. \\<And>a. QB a \\<Longrightarrow> PB a", "apply (blast dest: A_B_step)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a a' b'.\n       \\<lbrakk>B a' b' \\<and> FB b'; sim a a'; PA a; PB a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. (A a b \\<and> FA b) \\<and> sim b b'\n 2. \\<And>a b.\n       \\<lbrakk>PA a; A a b \\<and> FA b\\<rbrakk> \\<Longrightarrow> QA b\n 3. \\<And>a b.\n       \\<lbrakk>PB a; B a b \\<and> FB b\\<rbrakk> \\<Longrightarrow> QB b\n 4. \\<And>a. QA a \\<Longrightarrow> PA a\n 5. \\<And>a. QB a \\<Longrightarrow> PB a", "using assms(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>QA ?a; QB ?b\\<rbrakk> \\<Longrightarrow> FA ?a = FB ?b\n\ngoal (5 subgoals):\n 1. \\<And>a a' b'.\n       \\<lbrakk>B a' b' \\<and> FB b'; sim a a'; PA a; PB a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. (A a b \\<and> FA b) \\<and> sim b b'\n 2. \\<And>a b.\n       \\<lbrakk>PA a; A a b \\<and> FA b\\<rbrakk> \\<Longrightarrow> QA b\n 3. \\<And>a b.\n       \\<lbrakk>PB a; B a b \\<and> FB b\\<rbrakk> \\<Longrightarrow> QB b\n 4. \\<And>a. QA a \\<Longrightarrow> PA a\n 5. \\<And>a. QB a \\<Longrightarrow> PB a", "apply (blast dest: B_A_step)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>PA a; A a b \\<and> FA b\\<rbrakk> \\<Longrightarrow> QA b\n 2. \\<And>a b.\n       \\<lbrakk>PB a; B a b \\<and> FB b\\<rbrakk> \\<Longrightarrow> QB b\n 3. \\<And>a. QA a \\<Longrightarrow> PA a\n 4. \\<And>a. QB a \\<Longrightarrow> PB a", "by blast+"], ["proof (state)\nthis:\n  Bisimulation_Invariants A' B' sim PA QA PB QB\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Bisimulation_Invariants_composition:\n  assumes\n    \"Bisimulation_Invariants A B sim1 PA QA PB QB\"\n    \"Bisimulation_Invariants B C sim2 PB QB PC QC\"\n  shows\n    \"Bisimulation_Invariants A C (\\<lambda> a c. \\<exists> b. PB b \\<and> sim1 a b \\<and> sim2 b c) PA QA PC QC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Bisimulation_Invariants A C\n     (\\<lambda>a c. \\<exists>b. PB b \\<and> sim1 a b \\<and> sim2 b c) PA QA\n     PC QC", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Bisimulation_Invariants A C\n     (\\<lambda>a c. \\<exists>b. PB b \\<and> sim1 a b \\<and> sim2 b c) PA QA\n     PC QC", "interpret A: Bisimulation_Invariants A B sim1 PA QA PB QB"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bisimulation_Invariants A B sim1 PA QA PB QB", "by (rule assms(1))"], ["proof (state)\ngoal (1 subgoal):\n 1. Bisimulation_Invariants A C\n     (\\<lambda>a c. \\<exists>b. PB b \\<and> sim1 a b \\<and> sim2 b c) PA QA\n     PC QC", "interpret B: Bisimulation_Invariants B C sim2 PB QB PC QC"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bisimulation_Invariants B C sim2 PB QB PC QC", "by (rule assms(2))"], ["proof (state)\ngoal (1 subgoal):\n 1. Bisimulation_Invariants A C\n     (\\<lambda>a c. \\<exists>b. PB b \\<and> sim1 a b \\<and> sim2 b c) PA QA\n     PC QC", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bisimulation_Invariants A C\n     (\\<lambda>a c. \\<exists>b. PB b \\<and> sim1 a b \\<and> sim2 b c) PA QA\n     PC QC", "by (standard; (blast dest: A.A_B_step B.A_B_step | blast dest: A.B_A_step B.B_A_step))"], ["proof (state)\nthis:\n  Bisimulation_Invariants A C\n   (\\<lambda>a c. \\<exists>b. PB b \\<and> sim1 a b \\<and> sim2 b c) PA QA PC\n   QC\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Bisimulation_Invariant_Invariants_composition:\n  assumes\n    \"Bisimulation_Invariant A B sim1 PA PB\"\n    \"Bisimulation_Invariants B C sim2 PB QB PC QC\"\n  shows\n    \"Bisimulation_Invariants A C (\\<lambda> a c. \\<exists> b. PB b \\<and> sim1 a b \\<and> sim2 b c) PA PA PC QC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Bisimulation_Invariants A C\n     (\\<lambda>a c. \\<exists>b. PB b \\<and> sim1 a b \\<and> sim2 b c) PA PA\n     PC QC", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Bisimulation_Invariants A C\n     (\\<lambda>a c. \\<exists>b. PB b \\<and> sim1 a b \\<and> sim2 b c) PA PA\n     PC QC", "interpret Bisimulation_Invariant A B sim1 PA PB"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bisimulation_Invariant A B sim1 PA PB", "by (rule assms(1))"], ["proof (state)\ngoal (1 subgoal):\n 1. Bisimulation_Invariants A C\n     (\\<lambda>a c. \\<exists>b. PB b \\<and> sim1 a b \\<and> sim2 b c) PA PA\n     PC QC", "interpret B: Bisimulation_Invariants B C sim2 PB QB PC QC"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bisimulation_Invariants B C sim2 PB QB PC QC", "by (rule assms(2))"], ["proof (state)\ngoal (1 subgoal):\n 1. Bisimulation_Invariants A C\n     (\\<lambda>a c. \\<exists>b. PB b \\<and> sim1 a b \\<and> sim2 b c) PA PA\n     PC QC", "interpret A: Bisimulation_Invariants A B sim1 PA PA PB QB"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bisimulation_Invariants A B sim1 PA PA PB QB", "by (standard; blast intro: A_B_step B_A_step)+"], ["proof (state)\ngoal (1 subgoal):\n 1. Bisimulation_Invariants A C\n     (\\<lambda>a c. \\<exists>b. PB b \\<and> sim1 a b \\<and> sim2 b c) PA PA\n     PC QC", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bisimulation_Invariants A C\n     (\\<lambda>a c. \\<exists>b. PB b \\<and> sim1 a b \\<and> sim2 b c) PA PA\n     PC QC", "by (standard; (blast dest: A.A_B_step B.A_B_step | blast dest: A.B_A_step B.B_A_step))"], ["proof (state)\nthis:\n  Bisimulation_Invariants A C\n   (\\<lambda>a c. \\<exists>b. PB b \\<and> sim1 a b \\<and> sim2 b c) PA PA PC\n   QC\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Bisimulation_Invariant_Bisimulation_Invariants:\n  assumes \"Bisimulation_Invariant A B sim PA PB\"\n  shows \"Bisimulation_Invariants A B sim PA PA PB PB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Bisimulation_Invariants A B sim PA PA PB PB", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Bisimulation_Invariants A B sim PA PA PB PB", "interpret Bisimulation_Invariant A B sim PA PB"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bisimulation_Invariant A B sim PA PB", "by (rule assms)"], ["proof (state)\ngoal (1 subgoal):\n 1. Bisimulation_Invariants A B sim PA PA PB PB", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bisimulation_Invariants A B sim PA PA PB PB", "by (standard; blast intro: A_B_step B_A_step)"], ["proof (state)\nthis:\n  Bisimulation_Invariants A B sim PA PA PB PB\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Bisimulation_Invariant_strengthen_post:\n  assumes\n    \"Bisimulation_Invariant A B sim PA PB\"\n    \"\\<And> a b. PA' a \\<Longrightarrow> PA b \\<Longrightarrow> A a b \\<Longrightarrow> PA' b\"\n    \"\\<And> a. PA' a \\<Longrightarrow> PA a\"\n  shows \"Bisimulation_Invariant A B sim PA' PB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Bisimulation_Invariant A B sim PA' PB", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Bisimulation_Invariant A B sim PA' PB", "interpret Bisimulation_Invariant A B sim PA PB"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bisimulation_Invariant A B sim PA PB", "by (rule assms)"], ["proof (state)\ngoal (1 subgoal):\n 1. Bisimulation_Invariant A B sim PA' PB", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bisimulation_Invariant A B sim PA' PB", "by (standard; blast intro: A_B_step B_A_step assms)"], ["proof (state)\nthis:\n  Bisimulation_Invariant A B sim PA' PB\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Bisimulation_Invariant_strengthen_post':\n  assumes\n    \"Bisimulation_Invariant A B sim PA PB\"\n    \"\\<And> a b. PB' a \\<Longrightarrow> PB b \\<Longrightarrow> B a b \\<Longrightarrow> PB' b\"\n    \"\\<And> a. PB' a \\<Longrightarrow> PB a\"\n  shows \"Bisimulation_Invariant A B sim PA PB'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Bisimulation_Invariant A B sim PA PB'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Bisimulation_Invariant A B sim PA PB'", "interpret Bisimulation_Invariant A B sim PA PB"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bisimulation_Invariant A B sim PA PB", "by (rule assms)"], ["proof (state)\ngoal (1 subgoal):\n 1. Bisimulation_Invariant A B sim PA PB'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bisimulation_Invariant A B sim PA PB'", "by (standard; blast intro: A_B_step B_A_step assms)"], ["proof (state)\nthis:\n  Bisimulation_Invariant A B sim PA PB'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Simulation_Invariant_strengthen_post:\n  assumes\n    \"Simulation_Invariant A B sim PA PB\"\n    \"\\<And> a b. PA a \\<Longrightarrow> PA b \\<Longrightarrow> A a b \\<Longrightarrow> PA' b\"\n    \"\\<And> a. PA' a \\<Longrightarrow> PA a\"\n  shows \"Simulation_Invariant A B sim PA' PB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Simulation_Invariant A B sim PA' PB", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Simulation_Invariant A B sim PA' PB", "interpret Simulation_Invariant A B sim PA PB"], ["proof (prove)\ngoal (1 subgoal):\n 1. Simulation_Invariant A B sim PA PB", "by (rule assms)"], ["proof (state)\ngoal (1 subgoal):\n 1. Simulation_Invariant A B sim PA' PB", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Simulation_Invariant A B sim PA' PB", "by (standard; blast intro: A_B_step assms)"], ["proof (state)\nthis:\n  Simulation_Invariant A B sim PA' PB\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Simulation_Invariant_strengthen_post':\n  assumes\n    \"Simulation_Invariant A B sim PA PB\"\n    \"\\<And> a b. PB a \\<Longrightarrow> PB b \\<Longrightarrow> B a b \\<Longrightarrow> PB' b\"\n    \"\\<And> a. PB' a \\<Longrightarrow> PB a\"\n  shows \"Simulation_Invariant A B sim PA PB'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Simulation_Invariant A B sim PA PB'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Simulation_Invariant A B sim PA PB'", "interpret Simulation_Invariant A B sim PA PB"], ["proof (prove)\ngoal (1 subgoal):\n 1. Simulation_Invariant A B sim PA PB", "by (rule assms)"], ["proof (state)\ngoal (1 subgoal):\n 1. Simulation_Invariant A B sim PA PB'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Simulation_Invariant A B sim PA PB'", "by (standard; blast intro: A_B_step assms)"], ["proof (state)\nthis:\n  Simulation_Invariant A B sim PA PB'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Simulation_Invariants_strengthen_post:\n  assumes\n    \"Simulation_Invariants A B sim PA QA PB QB\"\n    \"\\<And> a b. PA a \\<Longrightarrow> QA b \\<Longrightarrow> A a b \\<Longrightarrow> QA' b\"\n    \"\\<And> a. QA' a \\<Longrightarrow> QA a\"\n  shows \"Simulation_Invariants A B sim PA QA' PB QB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Simulation_Invariants A B sim PA QA' PB QB", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Simulation_Invariants A B sim PA QA' PB QB", "interpret Simulation_Invariants A B sim PA QA PB QB"], ["proof (prove)\ngoal (1 subgoal):\n 1. Simulation_Invariants A B sim PA QA PB QB", "by (rule assms)"], ["proof (state)\ngoal (1 subgoal):\n 1. Simulation_Invariants A B sim PA QA' PB QB", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Simulation_Invariants A B sim PA QA' PB QB", "by (standard; blast intro: A_B_step assms)"], ["proof (state)\nthis:\n  Simulation_Invariants A B sim PA QA' PB QB\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Simulation_Invariants_strengthen_post':\n  assumes\n    \"Simulation_Invariants A B sim PA QA PB QB\"\n    \"\\<And> a b. PB a \\<Longrightarrow> QB b \\<Longrightarrow> B a b \\<Longrightarrow> QB' b\"\n    \"\\<And> a. QB' a \\<Longrightarrow> QB a\"\n  shows \"Simulation_Invariants A B sim PA QA PB QB'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Simulation_Invariants A B sim PA QA PB QB'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Simulation_Invariants A B sim PA QA PB QB'", "interpret Simulation_Invariants A B sim PA QA PB QB"], ["proof (prove)\ngoal (1 subgoal):\n 1. Simulation_Invariants A B sim PA QA PB QB", "by (rule assms)"], ["proof (state)\ngoal (1 subgoal):\n 1. Simulation_Invariants A B sim PA QA PB QB'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Simulation_Invariants A B sim PA QA PB QB'", "by (standard; blast intro: A_B_step assms)"], ["proof (state)\nthis:\n  Simulation_Invariants A B sim PA QA PB QB'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Bisimulation_Invariant_sim_replace:\n  assumes \"Bisimulation_Invariant A B sim PA PB\"\n      and \"\\<And> a b. PA a \\<Longrightarrow> PB b \\<Longrightarrow> sim a b \\<longleftrightarrow> sim' a b\"\n    shows \"Bisimulation_Invariant A B sim' PA PB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Bisimulation_Invariant A B sim' PA PB", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Bisimulation_Invariant A B sim' PA PB", "interpret Bisimulation_Invariant A B sim PA PB"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bisimulation_Invariant A B sim PA PB", "by (rule assms(1))"], ["proof (state)\ngoal (1 subgoal):\n 1. Bisimulation_Invariant A B sim' PA PB", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bisimulation_Invariant A B sim' PA PB", "apply standard"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b a'.\n       \\<lbrakk>A a b; sim' a a'; PA a; PB a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. B a' b' \\<and> sim' b b'\n 2. \\<And>a a' b'.\n       \\<lbrakk>B a' b'; sim' a a'; PA a; PB a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. A a b \\<and> sim' b b'\n 3. \\<And>a b. \\<lbrakk>PA a; A a b\\<rbrakk> \\<Longrightarrow> PA b\n 4. \\<And>a b. \\<lbrakk>PB a; B a b\\<rbrakk> \\<Longrightarrow> PB b", "using assms(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>PA ?a; PB ?b\\<rbrakk> \\<Longrightarrow> sim ?a ?b = sim' ?a ?b\n\ngoal (4 subgoals):\n 1. \\<And>a b a'.\n       \\<lbrakk>A a b; sim' a a'; PA a; PB a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. B a' b' \\<and> sim' b b'\n 2. \\<And>a a' b'.\n       \\<lbrakk>B a' b'; sim' a a'; PA a; PB a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. A a b \\<and> sim' b b'\n 3. \\<And>a b. \\<lbrakk>PA a; A a b\\<rbrakk> \\<Longrightarrow> PA b\n 4. \\<And>a b. \\<lbrakk>PB a; B a b\\<rbrakk> \\<Longrightarrow> PB b", "apply (blast dest: A_B_step)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a a' b'.\n       \\<lbrakk>B a' b'; sim' a a'; PA a; PB a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. A a b \\<and> sim' b b'\n 2. \\<And>a b. \\<lbrakk>PA a; A a b\\<rbrakk> \\<Longrightarrow> PA b\n 3. \\<And>a b. \\<lbrakk>PB a; B a b\\<rbrakk> \\<Longrightarrow> PB b", "using assms(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>PA ?a; PB ?b\\<rbrakk> \\<Longrightarrow> sim ?a ?b = sim' ?a ?b\n\ngoal (3 subgoals):\n 1. \\<And>a a' b'.\n       \\<lbrakk>B a' b'; sim' a a'; PA a; PB a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. A a b \\<and> sim' b b'\n 2. \\<And>a b. \\<lbrakk>PA a; A a b\\<rbrakk> \\<Longrightarrow> PA b\n 3. \\<And>a b. \\<lbrakk>PB a; B a b\\<rbrakk> \\<Longrightarrow> PB b", "apply (blast dest: B_A_step)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b. \\<lbrakk>PA a; A a b\\<rbrakk> \\<Longrightarrow> PA b\n 2. \\<And>a b. \\<lbrakk>PB a; B a b\\<rbrakk> \\<Longrightarrow> PB b", "by blast+"], ["proof (state)\nthis:\n  Bisimulation_Invariant A B sim' PA PB\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* Theory *)"]]}