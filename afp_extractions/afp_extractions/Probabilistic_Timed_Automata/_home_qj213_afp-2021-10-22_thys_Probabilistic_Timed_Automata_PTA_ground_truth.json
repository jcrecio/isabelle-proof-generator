{"file_name": "/home/qj213/afp-2021-10-22/thys/Probabilistic_Timed_Automata/PTA.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Probabilistic_Timed_Automata", "problem_names": ["lemma T_eq_rel_half[consumes 4, case_names prob sets cont]:\n  fixes R :: \"'s \\<Rightarrow> 't \\<Rightarrow> bool\" and f :: \"'s \\<Rightarrow> 't\" and S :: \"'s set\"\n  assumes R_def: \"\\<And>s t. R s t \\<longleftrightarrow> (s \\<in> S \\<and> f s = t)\"\n  assumes A[measurable]: \"A \\<in> sets (stream_space (count_space UNIV))\"\n    and B[measurable]: \"B \\<in> sets (stream_space (count_space UNIV))\"\n    and AB: \"rel_set_strong (stream_all2 R) A B\" and KL: \"rel_fun R (rel_pmf R) K L\" and xy: \"R x y\"\n  shows \"MC_syntax.T K x A = MC_syntax.T L y B\"", "lemma region_continuous:\n  assumes \"valid_region X k I r\"\n  defines R: \"R \\<equiv> region X I r\"\n  assumes between: \"0 \\<le> t1\" \"t1 \\<le> t2\"\n  assumes elem: \"u \\<in> R\" \"u \\<oplus> t2 \\<in> R\"\n  shows \"u \\<oplus> t1 \\<in> R\"", "lemma upper_right_eq:\n  assumes \"finite X\" \"valid_region X k I r\"\n  shows \"(\\<forall> x \\<in> X. isGreater (I x)) \\<longleftrightarrow> is_upper_right (region X I r)\"", "lemma bounded_region:\n  assumes \"finite X\" \"valid_region X k I r\"\n  defines R: \"R \\<equiv> region X I r\"\n  assumes \"\\<not> is_upper_right R\" \"u \\<in> R\"\n  shows \"u \\<oplus> 1 \\<notin> R\"", "lemma succ_ex:\n  assumes \"R \\<in> \\<R>\"\n  shows \"succ \\<R> R \\<in> \\<R>\" (is \"?G1\") and \"succ \\<R> R \\<in> Succ \\<R> R\" (is \"?G2\")\n  and \"\\<forall> u \\<in> R. \\<forall> t \\<ge> 0. (u \\<oplus> t) \\<notin> R \\<longrightarrow> (\\<exists> t' \\<le> t. (u \\<oplus> t') \\<in> succ \\<R> R \\<and> 0 \\<le> t')\" (is \"?G3\")", "lemma region_set'_closed:\n  fixes d :: nat\n  assumes \"R \\<in> \\<R>\" \"d \\<ge> 0\" \"\\<forall>x\\<in>set r. d \\<le> k x\" \"set r \\<subseteq> X\"\n  shows \"region_set' R r d \\<in> \\<R>\"", "lemma clock_set_cong[simp]:\n  assumes \"\\<forall> c \\<in> set r. u c = d\"\n  shows \"[r \\<rightarrow> d]u = u\"", "lemma region_reset_not_Succ:\n  (* XXX Declare globally? *)\n  notes regions_closed'_spec[intro]\n  assumes \"R \\<in> \\<R>\" \"set r \\<subseteq> X\"\n  shows \"region_set' R r 0 = R \\<or> region_set' R r 0 \\<notin> Succ \\<R> R\" (is \"?R = R \\<or> _\")", "lemma guard_continuous:\n  assumes \"u \\<turnstile> g\" \"u \\<oplus> t \\<turnstile> g\" \"0 \\<le> (t'::'t::time)\" \"t' \\<le> t\"\n  shows \"u \\<oplus> t' \\<turnstile> g\"", "lemma valid_abstractionD[dest]:\n  assumes \"valid_abstraction A X k\"\n  shows \"(\\<forall>(x,m) \\<in> clkp_set A. m \\<le> k x \\<and> x \\<in> X \\<and> m \\<in> \\<nat>)\" \"collect_clkvt A \\<subseteq> X\" \"finite X\"", "lemma valid_abstractionI[intro]:\n  assumes \"(\\<forall>(x,m) \\<in> clkp_set A. m \\<le> k x \\<and> x \\<in> X \\<and> m \\<in> \\<nat>)\" \"collect_clkvt A \\<subseteq> X\" \"finite X\"\n  shows \"valid_abstraction A X k\"", "lemmas finite_\\<R> = finite_\\<R>[OF finite(1), of k, folded \\<R>_def]", "lemma S_alt_def: \"S = {(l, u) . l \\<in> L \\<and> u \\<in> V \\<and> u \\<turnstile> inv_of A l}\"", "lemmas [intro] = \\<K>.intros", "lemma transition_def:\n  \"(A \\<turnstile> l \\<longrightarrow>\\<^bsup>g,\\<mu>,X\\<^esup> l') = ((l, g, \\<mu>) \\<in> trans_of A \\<and> (X, l') \\<in> \\<mu>)\"", "lemma transitionI[intro]:\n  \"A \\<turnstile> l \\<longrightarrow>\\<^bsup>g,\\<mu>,X\\<^esup> l'\" if \"(l, g, \\<mu>) \\<in> trans_of A\" \"(X, l') \\<in> \\<mu>\"", "lemma transitionD[dest]:\n  \"(l, g, \\<mu>) \\<in> trans_of A\" \"(X, l') \\<in> \\<mu>\" if \"A \\<turnstile> l \\<longrightarrow>\\<^bsup>g,\\<mu>,X\\<^esup> l'\"", "lemma bex_Edges:\n  \"(\\<exists> x \\<in> Edges A. P x) = (\\<exists> l g \\<mu> X l'. A \\<turnstile> l \\<longrightarrow>\\<^bsup>g,\\<mu>,X\\<^esup> l' \\<and> P (l, g, \\<mu>, X, l'))\"", "lemma L_trans[intro]:\n  assumes \"(l, g, \\<mu>) \\<in> trans_of A\" \"(X, l') \\<in> \\<mu>\"\n  shows \"l \\<in> L\" \"l' \\<in> L\"", "lemma transition_\\<X>:\n  \"X \\<subseteq> \\<X>\" if \"A \\<turnstile> l \\<longrightarrow>\\<^bsup>g,\\<mu>,X\\<^esup> l'\"", "lemma admissible_targets_alt:\n  \"A \\<turnstile> l \\<longrightarrow>\\<^bsup>g,\\<mu>,X\\<^esup> l' \\<Longrightarrow> \\<lbrace>g\\<rbrace>\\<^bsub>X \\<rightarrow> 0\\<^esub> \\<subseteq> \\<lbrace>inv_of A l'\\<rbrace>\"\n  \"A \\<turnstile> l \\<longrightarrow>\\<^bsup>g,\\<mu>,X\\<^esup> l' \\<Longrightarrow> X \\<subseteq> clocks A\"", "lemma V_reset_closed[intro]:\n  assumes \"u \\<in> V\"\n  shows \"[r \\<rightarrow> (d::nat)]u \\<in> V\"", "lemmas V_reset_closed'[intro] = V_reset_closed[of _ _ 0, simplified]", "lemma regions_part_ex[intro]:\n  assumes \"u \\<in> V\"\n  shows \"u \\<in> [u]\\<^sub>\\<R>\" \"[u]\\<^sub>\\<R> \\<in> \\<R>\"", "lemma rep_\\<R>_ex[intro]:\n  assumes \"R \\<in> \\<R>\"\n  shows \"(SOME u. u \\<in> R) \\<in> R\"", "lemma V_nn_closed[intro]:\n  \"u \\<in> V \\<Longrightarrow> t \\<ge> 0 \\<Longrightarrow> u \\<oplus> t \\<in> V\"", "lemma K_S_closed[intro]:\n  assumes \"\\<mu> \\<in> K s\" \"s' \\<in> \\<mu>\" \"s \\<in> S\"\n  shows \"s' \\<in> S\"", "lemma S_V[intro]:\n  \"(l, u) \\<in> S \\<Longrightarrow> u \\<in> V\"", "lemma L_V[intro]:\n  \"(l, u) \\<in> S \\<Longrightarrow> l \\<in> L\"", "lemma \\<S>_V[intro]:\n  \"(l, R) \\<in> \\<S> \\<Longrightarrow> R \\<in> \\<R>\"", "lemma admissible_targets':\n  assumes \"(l, g, \\<mu>) \\<in> trans_of A\" \"(X, l') \\<in> \\<mu>\" \"R \\<subseteq> \\<lbrace>g\\<rbrace>\"\n  shows \"region_set' R (SOME r. set r = X) 0 \\<subseteq> \\<lbrace>inv_of A l'\\<rbrace>\"", "lemma \\<S>_finite:\n  \"finite \\<S>\"", "lemma \\<K>_finite:\n  \"finite (\\<K> st)\"", "lemma \\<R>_not_empty:\n  \"\\<R> \\<noteq> {}\"", "lemma \\<S>_not_empty:\n  \"\\<S> \\<noteq> {}\"", "lemma \\<K>_\\<S>_closed:\n  assumes \"s \\<in> \\<S>\"\n  shows \"(\\<Union>D\\<in>\\<K> s. set_pmf D) \\<subseteq> \\<S>\"", "lemmas \\<K>_\\<S>_closed'[intro] = R_G.set_pmf_closed", "lemma ccompatible_inv:\n  shows \"ccompatible \\<R> (inv_of A l)\"", "lemma ccompatible_guard:\n  assumes \"(l, g, \\<mu>) \\<in> trans_of A\"\n  shows \"ccompatible \\<R> g\"", "lemmas ccompatible_def = ccompatible_def[unfolded ccval_def]", "lemma region_set'_eq:\n  fixes X :: \"'c set\"\n  assumes \"R \\<in> \\<R>\" \"u \\<in> R\"\n      and \"A \\<turnstile> l \\<longrightarrow>\\<^bsup>g,\\<mu>,X\\<^esup> l'\"\n  shows\n    \"[[X:=0]u]\\<^sub>\\<R> = region_set' R (SOME r. set r = X) 0\" \"[[X:=0]u]\\<^sub>\\<R> \\<in> \\<R>\" \"[X:=0]u \\<in> [[X:=0]u]\\<^sub>\\<R>\"", "lemma regions_part_ex_reset:\n  assumes \"u \\<in> V\"\n  shows  \"[r \\<rightarrow> (d::nat)]u \\<in> [[r \\<rightarrow> d]u]\\<^sub>\\<R>\" \"[[r \\<rightarrow> d]u]\\<^sub>\\<R> \\<in> \\<R>\"", "lemma reset_sets_all_equiv:\n  assumes \"u \\<in> V\" \"u' \\<in> [[r \\<rightarrow> (d :: nat)]u]\\<^sub>\\<R>\" \"x \\<in> set r\" \"set r \\<subseteq> \\<X>\" \"d \\<le> k x\"\n  shows \"u' x = d\"", "lemma reset_eq:\n  assumes \"u \\<in> V\" \"([[r \\<rightarrow> 0]u]\\<^sub>\\<R>) = ([[r' \\<rightarrow> 0]u]\\<^sub>\\<R>)\" \"set r \\<subseteq> \\<X>\" \"set r' \\<subseteq> \\<X>\"\n  shows \"[r \\<rightarrow> 0]u = [r' \\<rightarrow> 0]u\"", "lemma admissible_targets_clocks:\n  assumes \"(l, g, \\<mu>) \\<in> trans_of A\" \"(X, l') \\<in> \\<mu>\"\n  shows \"X \\<subseteq> \\<X>\" \"set (SOME r. set r = X) \\<subseteq> \\<X>\"", "lemma\n  \"rel_pmf (\\<lambda> a b. f a = b) \\<mu> (map_pmf f \\<mu>)\"", "lemma K_pmf_rel:\n  defines \"f \\<equiv> \\<lambda> (l, u). (l, [u]\\<^sub>\\<R>)\"\n  shows \"rel_pmf (\\<lambda> (l, u) st. (l, [u]\\<^sub>\\<R>) = st) \\<mu> (map_pmf f \\<mu>)\"", "lemma \\<K>_pmf_rel:\n  assumes A: \"\\<mu> \\<in> \\<K> (l, R)\"\n  defines \"f \\<equiv> \\<lambda> (l, u). (l, SOME u. u \\<in> R)\"\n  shows \"rel_pmf (\\<lambda> (l, u) st. (l, SOME u. u \\<in> R) = st) \\<mu> (map_pmf f \\<mu>)\"", "lemma K_elem_abs_inj:\n  assumes A: \"\\<mu> \\<in> K (l, u)\"\n  defines \"f \\<equiv> \\<lambda> (l, u). (l, [u]\\<^sub>\\<R>)\"\n  shows \"inj_on f \\<mu>\"", "lemma K_elem_repr_inj:\n  notes alpha_interp.valid_regions_distinct_spec[intro] (* XXX Declare somewhere else *)\n  assumes A: \"\\<mu> \\<in> \\<K> (l, R)\"\n  defines \"f \\<equiv> \\<lambda> (l, R). (l, SOME u. u \\<in> R)\"\n  shows \"inj_on f \\<mu>\"", "lemma K_elem_pmf_map_abs:\n  assumes A: \"\\<mu> \\<in> K (l, u)\" \"(l', u') \\<in> \\<mu>\"\n  defines \"f \\<equiv> \\<lambda> (l, u). (l, [u]\\<^sub>\\<R>)\"\n  shows \"pmf (map_pmf f \\<mu>) (f (l', u')) = pmf \\<mu> (l', u')\"", "lemma K_elem_pmf_map_repr:\n  assumes A: \"\\<mu> \\<in> \\<K> (l, R)\" \"(l', R') \\<in> \\<mu>\"\n  defines \"f \\<equiv> \\<lambda> (l, R). (l, SOME u. u \\<in> R)\"\n  shows \"pmf (map_pmf f \\<mu>) (f (l', R')) = pmf \\<mu> (l', R')\"", "lemma \\<S>_reps_S[intro]:\n  assumes \"s \\<in> \\<S>\"\n  shows \"reps s \\<in> S\"", "lemma S_abss_\\<S>[intro]:\n  assumes \"s \\<in> S\"\n  shows \"abss s \\<in> \\<S>\"", "lemma \\<S>_abss_reps[simp]:\n  \"s \\<in> \\<S> \\<Longrightarrow> abss (reps s) = s\"", "lemma map_pmf_abs_reps:\n  assumes \"s \\<in> \\<S>\" \"\\<mu> \\<in> \\<K> s\"\n  shows \"map_pmf abss (map_pmf reps \\<mu>) = \\<mu>\"", "lemma abss_reps_id:\n  notes R_G.cfg_onD_state[simp del]\n  assumes \"s' \\<in> \\<S>\" \"s \\<in> set_pmf (action cfg)\" \"cfg \\<in> R_G.cfg_on s'\"\n  shows \"abss (reps s) = s\"", "lemma abss_S[intro]:\n  assumes \"(l, u) \\<in> S\"\n  shows \"abss (l, u) = (l, [u]\\<^sub>\\<R>)\"", "lemma reps_\\<S>[intro]:\n  assumes \"(l, R) \\<in> \\<S>\"\n  shows \"reps (l, R) = (l, SOME u. u \\<in> R)\"", "lemma fst_abss:\n  \"fst (abss st) = fst st\" for st", "lemma K_elem_abss_inj:\n  assumes A: \"\\<mu> \\<in> K (l, u)\" \"(l, u) \\<in> S\"\n  shows \"inj_on abss \\<mu>\"", "lemma \\<K>_elem_reps_inj:\n  assumes A: \"\\<mu> \\<in> \\<K> (l, R)\" \"(l, R) \\<in> \\<S>\"\n  shows \"inj_on reps \\<mu>\"", "lemma P_elem_pmf_map_abss:\n  assumes A: \"\\<mu> \\<in> K (l, u)\" \"(l, u) \\<in> S\" \"s' \\<in> \\<mu>\"\n  shows \"pmf (map_pmf abss \\<mu>) (abss s') = pmf \\<mu> s'\"", "lemma \\<K>_elem_pmf_map_reps:\n  assumes A: \"\\<mu> \\<in> \\<K> (l, R)\" \"(l, R) \\<in> \\<S>\" \"(l', R') \\<in> \\<mu>\"\n  shows \"pmf (map_pmf reps \\<mu>) (reps (l', R')) = pmf \\<mu> (l', R')\"", "lemma not_\\<S>_reps:\n  \"(l, R) \\<notin> \\<S> \\<Longrightarrow> reps (l, R) \\<notin> S\"", "lemma neq_V_not_region:\n  \"-V \\<notin> \\<R>\"", "lemma \\<S>_abss_S:\n  \"abss s \\<in> \\<S> \\<Longrightarrow> s \\<in> S\"", "lemma S_pred_stream_abss_\\<S>:\n  \"pred_stream (\\<lambda> s. s \\<in> S) xs \\<longleftrightarrow> pred_stream (\\<lambda> s. s \\<in> \\<S>) (smap abss xs)\"", "lemma K_closed:\n  \"s \\<in> S \\<Longrightarrow> (\\<Union>D\\<in>K s. set_pmf D) \\<subseteq> S\"", "lemma bisim_loc_id[intro]:\n  \"(l, u) ~ (l', u') \\<Longrightarrow> l = l'\"", "lemma bisim_val_id[intro]:\n  \"[u]\\<^sub>\\<R> = [u']\\<^sub>\\<R>\" if \"u \\<in> V\" \"(l, u) ~ (l', u')\"", "lemma bisim_symmetric:\n  \"(l, u) ~ (l', u') = (l', u') ~ (l, u)\"", "lemma bisim_val_id2[intro]:\n  \"u' \\<in> V \\<Longrightarrow> (l, u) ~ (l', u') \\<Longrightarrow> [u]\\<^sub>\\<R> = [u']\\<^sub>\\<R>\"", "lemma K_bisim_unique:\n  assumes \"s \\<in> S\" \"\\<mu> \\<in> K s\" \"x \\<in> \\<mu>\" \"x' \\<in> \\<mu>\" \"x ~ x'\"\n  shows \"x = x'\"", "lemma abss_\\<S>D:\n  assumes \"abss s \\<in> \\<S>\"\n  obtains l u where \"s = (l, u)\" \"u \\<in> [u]\\<^sub>\\<R>\" \"[u]\\<^sub>\\<R> \\<in> \\<R>\"", "lemma abss_\\<S>D':\n  assumes \"abss s \\<in> \\<S>\" \"abss s = (l, R)\"\n  obtains u where \"s = (l, u)\" \"u \\<in> [u]\\<^sub>\\<R>\" \"[u]\\<^sub>\\<R> \\<in> \\<R>\" \"R = [u]\\<^sub>\\<R>\"", "lemma delayedR_correct_aux_aux:\n  fixes c :: nat\n  fixes a b :: real\n  assumes \"c < a\" \"a < Suc c\" \"b \\<ge> 0\" \"a + b < Suc c\"\n  shows \"frac (a + b) = frac a + b\"", "lemma delayedR_correct_aux:\n  fixes I r\n  defines \"R \\<equiv> region \\<X> I r\"\n  assumes \"u \\<in> R\" \"valid_region \\<X> k I r\" \"\\<forall> c \\<in> \\<X>. \\<not> isConst (I c)\"\n          \"\\<forall> c \\<in> \\<X>. isIntv (I c) \\<longrightarrow> (u \\<oplus> t) c < intv_const (I c) + 1\"\n          \"t \\<ge> 0\"\n  shows \"u \\<oplus> t \\<in> R\"", "lemma delayedR_correct_aux':\n  fixes I r\n  defines \"R \\<equiv> region \\<X> I r\"\n  assumes \"u \\<oplus> t1 \\<in> R\" \"valid_region \\<X> k I r\" \"\\<forall> c \\<in> \\<X>. \\<not> isConst (I c)\"\n          \"\\<forall> c \\<in> \\<X>. isIntv (I c) \\<longrightarrow> (u \\<oplus> t2) c < intv_const (I c) + 1\"\n          \"t1 \\<le> t2\"\n  shows \"u \\<oplus> t2 \\<in> R\"", "lemma valid_regions_intv_distinct:\n  \"valid_region X k I r \\<Longrightarrow> valid_region X k I' r' \\<Longrightarrow> u \\<in> region X I r \\<Longrightarrow> u \\<in> region X I' r'\n  \\<Longrightarrow> x \\<in> X \\<Longrightarrow> I x = I' x\"", "lemma delayedR_correct:\n  fixes I r\n  defines \"R' \\<equiv> region \\<X> I r\"\n  assumes \"u \\<in> R\" \"R \\<in> \\<R>\" \"valid_region \\<X> k I r\" \"\\<forall> c \\<in> \\<X>. \\<not> isConst (I c)\" \"R' \\<in> Succ \\<R> R\"\n  shows\n    \"delayedR R' u \\<in> R'\"\n    \"\\<exists> t \\<ge> 0. delayedR R' u = u \\<oplus> t\n            \\<and> t \\<ge> (1 - Max ({frac (u c) | c. c \\<in> \\<X> \\<and> isIntv (I c)} \\<union> {0})) / 2\"", "lemma \\<S>_L:\n  \"l \\<in> L\" if \"(l, R) \\<in> \\<S>\"", "lemma \\<S>_inv:\n  \"(l, R) \\<in> \\<S> \\<Longrightarrow> R \\<subseteq> \\<lbrace>inv_of A l\\<rbrace>\"", "lemma upper_right_closed:\n  assumes \"\\<forall>c\\<in>\\<X>. real (k c) < u c\" \"u \\<in> R\" \"R \\<in> \\<R>\" \"t \\<ge> 0\"\n  shows \"u \\<oplus> t \\<in> R\"", "lemma S_I[intro]:\n  \"(l, u) \\<in> S\" if \"l \\<in> L\" \"u \\<in> V\" \"u \\<turnstile> inv_of A l\"", "lemma rept_ex:\n  assumes \"\\<mu> \\<in> \\<K> (abss s)\"\n  shows \"rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\"", "lemmas rept_K[intro]       = rept_ex[THEN conjunct1]", "lemmas abst_rept_id[simp]  = rept_ex[THEN conjunct2]", "lemma abst_rept2:\n  assumes \"\\<mu> \\<in> \\<K> s\" \"s \\<in> \\<S>\"\n  shows \"abst (rept (reps s) \\<mu>) = \\<mu>\"", "lemma rept_K2:\n  assumes \"\\<mu> \\<in> \\<K> s\" \"s \\<in> \\<S>\"\n  shows \"rept (reps s) \\<mu> \\<in> K (reps s)\"", "lemma theI':\n  assumes \"P a\"\n    and \"\\<And>x. P x \\<Longrightarrow> x = a\"\n  shows \"P (THE x. P x) \\<and> (\\<forall> y. P y \\<longrightarrow> y = (THE x. P x))\"", "lemma cont_cfg_defined:\n  fixes cfg s\n  assumes \"cfg \\<in> valid_cfg\" \"s \\<in> abst (action cfg)\"\n  defines \"x \\<equiv> THE x. abss x = s \\<and> x \\<in> action cfg\"\n  shows \"(abss x = s \\<and> x \\<in> action cfg) \\<and> (\\<forall> y. abss y = s \\<and> y \\<in> action cfg \\<longrightarrow> y = x)\"", "lemma \\<S>_state_absc_repc[simp]:\n  \"state cfg \\<in> \\<S> \\<Longrightarrow> state (absc (repc cfg)) = state cfg\"", "lemma action_repc:\n  \"action (repc cfg) = rept (reps (state cfg)) (action cfg)\"", "lemma action_absc:\n  \"action (absc cfg) = abst (action cfg)\"", "lemma action_absc':\n  \"action (absc cfg) = map_pmf abss (action cfg)\"", "lemma\n  notes R_G.cfg_onD_state[simp del]\n  assumes \"state cfg \\<in> \\<S>\" \"s' \\<in> set_pmf (action (repc cfg))\" \"cfg \\<in> R_G.cfg_on (state cfg)\"\n  shows \"cont (repc cfg) s' = repcs s' (cont cfg (abss s'))\"", "lemma cont_repcs1:\n  notes R_G.cfg_onD_state[simp del]\n  assumes \"abss s \\<in> \\<S>\" \"s' \\<in> set_pmf (action (repcs s cfg))\" \"cfg \\<in> R_G.cfg_on (abss s)\"\n  shows \"cont (repcs s cfg) s' = repcs s' (cont cfg (abss s'))\"", "lemma cont_absc_1:\n  notes MDP.cfg_onD_state[simp del]\n  assumes \"cfg \\<in> valid_cfg\" \"s' \\<in> set_pmf (action cfg)\"\n  shows \"cont (absc cfg) (abss s') = absc (cont cfg s')\"", "lemma state_repc:\n  \"state (repc cfg) = reps (state cfg)\"", "lemma abss_reps_id':\n  notes R_G.cfg_onD_state[simp del]\n  assumes \"cfg \\<in> R_G.valid_cfg\" \"s \\<in> set_pmf (action cfg)\"\n  shows \"abss (reps s) = s\"", "lemma valid_cfg_coinduct[coinduct set: valid_cfg]:\n  assumes \"P cfg\"\n  assumes \"\\<And>cfg. P cfg \\<Longrightarrow> state cfg \\<in> S\"\n  assumes \"\\<And>cfg. P cfg \\<Longrightarrow> action cfg \\<in> K (state cfg)\"\n  assumes \"\\<And>cfg t. P cfg \\<Longrightarrow> t \\<in> action cfg \\<Longrightarrow> P (cont cfg t)\"\n  shows \"cfg \\<in> valid_cfg\"", "lemma state_repcD[simp]:\n  assumes \"cfg \\<in> R_G.cfg_on s\"\n  shows \"state (repc cfg) = reps s\"", "lemma ccompatible_subs[intro]:\n  assumes \"ccompatible \\<R> g\" \"R \\<in> \\<R>\" \"u \\<in> R\" \"u \\<turnstile> g\"\n  shows \"R \\<subseteq> {u. u \\<turnstile> g}\"", "lemma action_abscD[dest]:\n  \"cfg \\<in> MDP.cfg_on s \\<Longrightarrow> action (absc cfg) \\<in> \\<K> (abss s)\"", "lemma repcs_valid[intro]:\n  assumes \"cfg \\<in> R_G.valid_cfg\" \"abss s = state cfg\"\n  shows \"repcs s cfg \\<in> valid_cfg\"", "lemma repc_valid[intro]:\n  assumes \"cfg \\<in> R_G.valid_cfg\"\n  shows \"repc cfg \\<in> valid_cfg\"", "lemma action_abst_repcs:\n  assumes \"cfg \\<in> R_G.valid_cfg\" \"abss s = state cfg\"\n  shows \"abst (action (repcs s cfg)) = action cfg\"", "lemma action_abst_repc:\n  assumes \"cfg \\<in> R_G.valid_cfg\"\n  shows \"abst (action (repc cfg)) = action cfg\"", "lemma state_absc:\n  \"state (absc cfg) = abss (state cfg)\"", "lemma state_repcs[simp]:\n  \"state (repcs s cfg) = s\"", "lemma repcs_bisim:\n  notes R_G.cfg_onD_state[simp del]\n  assumes \"cfg \\<in> R_G.valid_cfg\" \"x \\<in> S\" \"x ~ x'\" \"abss x = state cfg\"\n  shows \"absc (repcs x cfg) = absc (repcs x' cfg)\"", "lemmas R_G.valid_cfg_state_in_S[R_G_I] R_G.valid_cfgD[R_G_I] R_G.valid_cfg_action", "lemma absc_repcs_id:\n  notes R_G.cfg_onD_state[simp del]\n  assumes \"cfg \\<in> R_G.valid_cfg\" \"abss s = state cfg\"\n  shows \"absc (repcs s cfg) = cfg\"", "lemma absc_repc_id:\n  notes R_G.cfg_onD_state[simp del]\n  assumes \"cfg \\<in> R_G.valid_cfg\"\n  shows \"absc (repc cfg) = cfg\"", "lemma K_cfg_map_absc:\n  \"cfg \\<in> valid_cfg \\<Longrightarrow> K_cfg (absc cfg) = map_pmf absc (K_cfg cfg)\"", "lemma smap_comp:\n  \"(smap f o smap g) = smap (f o g)\"", "lemma state_abscD[simp]:\n  assumes \"cfg \\<in> MDP.cfg_on s\"\n  shows \"state (absc cfg) = abss s\"", "lemma R_G_valid_cfg_coinduct[coinduct set: valid_cfg]:\n  assumes \"P cfg\"\n  assumes \"\\<And>cfg. P cfg \\<Longrightarrow> state cfg \\<in> \\<S>\"\n  assumes \"\\<And>cfg. P cfg \\<Longrightarrow> action cfg \\<in> \\<K> (state cfg)\"\n  assumes \"\\<And>cfg t. P cfg \\<Longrightarrow> t \\<in> action cfg \\<Longrightarrow> P (cont cfg t)\"\n  shows \"cfg \\<in> R_G.valid_cfg\"", "lemma absc_valid[intro]:\n  assumes \"cfg \\<in> valid_cfg\"\n  shows \"absc cfg \\<in> R_G.valid_cfg\"", "lemma K_cfg_set_absc:\n  assumes \"cfg \\<in> valid_cfg\" \"cfg' \\<in> K_cfg cfg\"\n  shows \"absc cfg' \\<in> K_cfg (absc cfg)\"", "lemma abst_action_repcs:\n  assumes \"cfg \\<in> R_G.valid_cfg\" \"abss s = state cfg\"\n  shows \"abst (action (repcs s cfg)) = action cfg\"", "lemma abst_action_repc:\n  assumes \"cfg \\<in> R_G.valid_cfg\"\n  shows \"abst (action (repc cfg)) = action cfg\"", "lemma K_elem_abss_inj':\n  assumes \"\\<mu> \\<in> K s\"\n    and \"s \\<in> S\"\n  shows \"inj_on abss (set_pmf \\<mu>)\"", "lemma K_cfg_rept_aux:\n  assumes \"cfg \\<in> R_G.valid_cfg\" \"abss s = state cfg\" \"x \\<in> rept s (action cfg)\"\n  defines \"t \\<equiv> \\<lambda> cfg'. THE s'. s' \\<in> rept s (action cfg) \\<and> s' ~ x\"\n  shows \"t cfg' = x\"", "lemma K_cfg_rept_action:\n  assumes \"cfg \\<in> R_G.valid_cfg\" \"abss s = state cfg\" \"cfg' \\<in> set_pmf (K_cfg cfg)\"\n  shows \"abss (THE s'. s' \\<in> rept s (action cfg) \\<and> abss s' = state cfg') = state cfg'\"", "lemma K_cfg_map_repcs:\n  assumes \"cfg \\<in> R_G.valid_cfg\" \"abss s = state cfg\"\n  defines \"repc' \\<equiv> (\\<lambda> cfg'. repcs (THE s'. s' \\<in> rept s (action cfg) \\<and> abss s' = state cfg') cfg')\"\n  shows \"K_cfg (repcs s cfg) = map_pmf repc' (K_cfg cfg)\"", "lemma K_cfg_map_repc:\n  assumes \"cfg \\<in> R_G.valid_cfg\"\n  defines\n    \"repc' cfg' \\<equiv> repcs (THE s. s \\<in> rept (reps (state cfg)) (action cfg) \\<and> abss s = state cfg') cfg'\"\n  shows \n    \"K_cfg (repc cfg) = map_pmf repc' (K_cfg cfg)\"", "lemma R_G_K_cfg_valid_cfgD:\n  assumes \"cfg \\<in> R_G.valid_cfg\" \"cfg' \\<in> K_cfg cfg\"\n  shows \"cfg' = cont cfg (state cfg')\" \"state cfg' \\<in> action cfg\"", "lemma K_cfg_valid_cfgD:\n  assumes \"cfg \\<in> valid_cfg\" \"cfg' \\<in> K_cfg cfg\"\n  shows \"cfg' = cont cfg (state cfg')\" \"state cfg' \\<in> action cfg\"", "lemma absc_bisim_abss:\n  assumes \"absc x = absc x'\"\n  shows \"state x ~ state x'\"", "lemma K_cfg_bisim_unique:\n  assumes \"cfg \\<in> valid_cfg\" and \"x \\<in> K_cfg cfg\" \"x' \\<in> K_cfg cfg\" and \"state x ~ state x'\"\n  shows \"x = x'\"", "lemma absc_distr_self:\n  \"MDP.MC.T (absc cfg) = distr (MDP.MC.T cfg) MDP.MC.S (smap absc)\" if \"cfg \\<in> valid_cfg\"", "lemma R_G_trace_space_distr_eq:\n  assumes \"cfg \\<in> R_G.valid_cfg\" \"abss s = state cfg\"\n  shows \"MDP.MC.T cfg = distr (MDP.MC.T (repcs s cfg)) MDP.MC.S (smap absc)\"", "lemma repc_inj_on_K_cfg:\n  assumes \"cfg \\<in> R_G.cfg_on s\" \"s \\<in> \\<S>\"\n  shows \"inj_on repc (set_pmf (K_cfg cfg))\"", "lemma smap_absc_iff:\n  assumes \"\\<And> x y. x \\<in> X \\<Longrightarrow> smap abss x = smap abss y \\<Longrightarrow> y \\<in> X\"\n  shows \"(smap state xs \\<in> X) = (smap (\\<lambda>z. abss (state z)) xs \\<in> smap abss ` X)\"", "lemma valid_abss_reps[simp]:\n  assumes \"cfg \\<in> R_G.valid_cfg\"\n  shows \"abss (reps (state cfg)) = state cfg\"", "lemma in_space_UNIV: \"x \\<in> space (count_space UNIV)\"", "lemma S_reps_\\<S>_aux:\n  \"reps (l, R) \\<in> S \\<Longrightarrow> (l, R) \\<in> \\<S>\"", "lemma S_reps_\\<S>[intro]:\n  \"reps s \\<in> S \\<Longrightarrow> s \\<in> \\<S>\"", "lemma absc_valid_cfg_eq:\n  \"absc ` valid_cfg = R_G.valid_cfg\"", "lemma action_repcs:\n  \"action (repcs (l, u) cfg) = rept (l, u) (action cfg)\"", "lemma path_measure_eq_absc1_new:\n  fixes cfg s\n  defines \"cfg' \\<equiv> absc cfg\"\n  assumes valid: \"cfg \\<in> valid_cfg\"\n  assumes X[measurable]: \"X \\<in> R_G.St\" and Y[measurable]: \"Y \\<in> MDP.St\"\n  assumes P: \"AE x in (R_G.T cfg'). P x\" and Q: \"AE x in (MDP.T cfg). Q x\"\n  assumes P'[measurable]: \"Measurable.pred R_G.St P\"\n      and Q'[measurable]: \"Measurable.pred MDP.St Q\"\n  assumes X_Y_closed: \"\\<And> x y. P x \\<Longrightarrow> smap abss y = x \\<Longrightarrow> x \\<in> X \\<Longrightarrow> y \\<in> Y \\<and> Q y\"\n  assumes Y_X_closed: \"\\<And> x y. Q y \\<Longrightarrow> smap abss y = x \\<Longrightarrow> y \\<in> Y \\<Longrightarrow> x \\<in> X \\<and> P x\"\n  shows\n    \"emeasure (R_G.T cfg') X = emeasure (MDP.T cfg) Y\"", "lemma path_measure_eq_repcs1_new:\n  fixes cfg s\n  defines \"cfg' \\<equiv> repcs s cfg\"\n  assumes s: \"abss s = state cfg\"\n  assumes valid: \"cfg \\<in> R_G.valid_cfg\"\n  assumes X[measurable]: \"X \\<in> R_G.St\" and Y[measurable]: \"Y \\<in> MDP.St\"\n  assumes P: \"AE x in (R_G.T cfg). P x\" and Q: \"AE x in (MDP.T cfg'). Q x\"\n  assumes P'[measurable]: \"Measurable.pred R_G.St P\"\n      and Q'[measurable]: \"Measurable.pred MDP.St Q\"\n  assumes X_Y_closed: \"\\<And> x y. P x \\<Longrightarrow> smap abss y = x \\<Longrightarrow> x \\<in> X \\<Longrightarrow> y \\<in> Y \\<and> Q y\"\n  assumes Y_X_closed: \"\\<And> x y. Q y \\<Longrightarrow> smap abss y = x \\<Longrightarrow> y \\<in> Y \\<Longrightarrow> x \\<in> X \\<and> P x\"\n  shows\n    \"emeasure (R_G.T cfg) X = emeasure (MDP.T cfg') Y\"", "lemma region_compatible_suntil1:\n  assumes \"(holds (\\<lambda>x. \\<phi> (reps x)) suntil holds (\\<lambda>x. \\<psi> (reps x))) (smap abss x)\"\n      and \"pred_stream (\\<lambda> s. \\<phi> (reps (abss s)) \\<longrightarrow> \\<phi> s) x\"\n      and \"pred_stream (\\<lambda> s. \\<psi> (reps (abss s)) \\<longrightarrow> \\<psi> s) x\"\n  shows \"(holds \\<phi> suntil holds \\<psi>) x\"", "lemma region_compatible_suntil2:\n  assumes \"(holds \\<phi> suntil holds \\<psi>) x\"\n      and \"pred_stream (\\<lambda> s. \\<phi> s \\<longrightarrow> \\<phi> (reps (abss s))) x\"\n      and \"pred_stream (\\<lambda> s. \\<psi> s \\<longrightarrow> \\<psi> (reps (abss s))) x\"\n  shows \"(holds (\\<lambda>x. \\<phi> (reps x)) suntil holds (\\<lambda>x. \\<psi> (reps x))) (smap abss x)\"", "lemma region_compatible_suntil:\n  assumes \"pred_stream (\\<lambda> s. \\<phi> (reps (abss s)) \\<longleftrightarrow> \\<phi> s) x\"\n      and \"pred_stream (\\<lambda> s. \\<psi> (reps (abss s)) \\<longleftrightarrow> \\<psi> s) x\"\n  shows \"(holds (\\<lambda>x. \\<phi> (reps x)) suntil holds (\\<lambda>x. \\<psi> (reps x))) (smap abss x)\n     \\<longleftrightarrow> (holds \\<phi> suntil holds \\<psi>) x\"", "lemma reps_abss_S:\n  assumes \"reps (abss s) \\<in> S\"\n  shows \"s \\<in> S\"", "lemma measurable_sset[measurable (raw)]:\n  assumes f[measurable]: \"f \\<in> N \\<rightarrow>\\<^sub>M stream_space M\" and P[measurable]: \"Measurable.pred M P\"\n  shows \"Measurable.pred N (\\<lambda>x. \\<forall>s\\<in>sset (f x). P s)\"", "lemma path_measure_eq_repcs''_new:\n  notes in_space_UNIV[measurable]\n  fixes cfg \\<phi> \\<psi> s\n  defines \"cfg' \\<equiv> repcs s cfg\"\n  defines \"\\<phi>' \\<equiv> absp \\<phi>\" and \"\\<psi>' \\<equiv> absp \\<psi>\"\n  assumes s: \"abss s = state cfg\"\n  assumes valid: \"cfg \\<in> R_G.valid_cfg\"\n  assumes valid': \"cfg' \\<in> valid_cfg\"\n  assumes equiv_\\<phi>: \"\\<And> x. pred_stream (\\<lambda> s. s \\<in> S) x\n                    \\<Longrightarrow> pred_stream (\\<lambda> s. \\<phi> (reps (abss s)) \\<longleftrightarrow> \\<phi> s) (state cfg' ## x)\"\n    and equiv_\\<psi>: \"\\<And> x. pred_stream (\\<lambda> s. s \\<in> S) x\n                    \\<Longrightarrow> pred_stream (\\<lambda> s. \\<psi> (reps (abss s)) \\<longleftrightarrow> \\<psi> s) (state cfg' ## x)\"\n  shows\n    \"emeasure (R_G.T cfg)  {x\\<in>space R_G.St. (holds \\<phi>' suntil holds \\<psi>') (state cfg  ## x)} =\n     emeasure (MDP.T cfg') {x\\<in>space MDP.St. (holds \\<phi>  suntil holds \\<psi>)  (state cfg' ## x)}\""], "translations": [["", "lemma T_eq_rel_half[consumes 4, case_names prob sets cont]:\n  fixes R :: \"'s \\<Rightarrow> 't \\<Rightarrow> bool\" and f :: \"'s \\<Rightarrow> 't\" and S :: \"'s set\"\n  assumes R_def: \"\\<And>s t. R s t \\<longleftrightarrow> (s \\<in> S \\<and> f s = t)\"\n  assumes A[measurable]: \"A \\<in> sets (stream_space (count_space UNIV))\"\n    and B[measurable]: \"B \\<in> sets (stream_space (count_space UNIV))\"\n    and AB: \"rel_set_strong (stream_all2 R) A B\" and KL: \"rel_fun R (rel_pmf R) K L\" and xy: \"R x y\"\n  shows \"MC_syntax.T K x A = MC_syntax.T L y B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (MC_syntax.T K x) A = emeasure (MC_syntax.T L y) B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure (MC_syntax.T K x) A = emeasure (MC_syntax.T L y) B", "interpret K: MC_syntax K"], ["proof (prove)\ngoal:\nNo subgoals!", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure (K.T x) A = emeasure (MC_syntax.T L y) B", "interpret L: MC_syntax L"], ["proof (prove)\ngoal:\nNo subgoals!", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure (K.T x) A = emeasure (L.T y) B", "have \"x \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> S", "using \\<open>R x y\\<close>"], ["proof (prove)\nusing this:\n  R x y\n\ngoal (1 subgoal):\n 1. x \\<in> S", "by (auto simp: R_def)"], ["proof (state)\nthis:\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. emeasure (K.T x) A = emeasure (L.T y) B", "define g where \"g t = (SOME s. R s t)\" for t"], ["proof (state)\nthis:\n  g ?t = (SOME s. R s ?t)\n\ngoal (1 subgoal):\n 1. emeasure (K.T x) A = emeasure (L.T y) B", "have measurable_g: \"g \\<in> count_space UNIV \\<rightarrow>\\<^sub>M count_space UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<in> count_space UNIV \\<rightarrow>\\<^sub>M count_space UNIV", "by auto"], ["proof (state)\nthis:\n  g \\<in> count_space UNIV \\<rightarrow>\\<^sub>M count_space UNIV\n\ngoal (1 subgoal):\n 1. emeasure (K.T x) A = emeasure (L.T y) B", "have g: \"R i j \\<Longrightarrow> R (g j) j\" for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. R i j \\<Longrightarrow> R (g j) j", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. R i j \\<Longrightarrow> R (SOME s. R s j) j", "by (rule someI)"], ["proof (state)\nthis:\n  R ?i1 ?j1 \\<Longrightarrow> R (g ?j1) ?j1\n\ngoal (1 subgoal):\n 1. emeasure (K.T x) A = emeasure (L.T y) B", "have K_subset: \"x \\<in> S \\<Longrightarrow> K x \\<subseteq> S\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> S \\<Longrightarrow> set_pmf (K x) \\<subseteq> S", "using KL[THEN rel_funD, of x \"f x\", THEN rel_pmf_imp_rel_set]"], ["proof (prove)\nusing this:\n  R x (f x) \\<Longrightarrow> rel_set R (set_pmf (K x)) (set_pmf (L (f x)))\n\ngoal (1 subgoal):\n 1. x \\<in> S \\<Longrightarrow> set_pmf (K x) \\<subseteq> S", "by (auto simp: rel_set_def R_def)"], ["proof (state)\nthis:\n  ?x1 \\<in> S \\<Longrightarrow> set_pmf (K ?x1) \\<subseteq> S\n\ngoal (1 subgoal):\n 1. emeasure (K.T x) A = emeasure (L.T y) B", "have in_S: \"AE \\<omega> in K.T x. \\<omega> \\<in> streams S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE \\<omega> in K.T x. \\<omega> \\<in> streams S", "using K.AE_T_enabled"], ["proof (prove)\nusing this:\n  almost_everywhere (K.T ?s) (K.enabled ?s)\n\ngoal (1 subgoal):\n 1. AE \\<omega> in K.T x. \\<omega> \\<in> streams S", "proof eventually_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       K.enabled x \\<omega> \\<Longrightarrow> \\<omega> \\<in> streams S", "case (elim \\<omega>)"], ["proof (state)\nthis:\n  K.enabled x \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       K.enabled x \\<omega> \\<Longrightarrow> \\<omega> \\<in> streams S", "with \\<open>x \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> S\n  K.enabled x \\<omega>", "show ?case"], ["proof (prove)\nusing this:\n  x \\<in> S\n  K.enabled x \\<omega>\n\ngoal (1 subgoal):\n 1. \\<omega> \\<in> streams S", "apply (coinduction arbitrary: x \\<omega>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa \\<omega>.\n       \\<lbrakk>xa \\<in> S; K.enabled xa \\<omega>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s.\n                            \\<omega> = a ## s \\<and>\n                            a \\<in> S \\<and>\n                            ((\\<exists>x \\<omega>.\n                                 s = \\<omega> \\<and>\n                                 x \\<in> S \\<and>\n                                 K.enabled x \\<omega>) \\<or>\n                             s \\<in> streams S)", "subgoal for x \\<omega>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> S; K.enabled x \\<omega>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s.\n                         \\<omega> = a ## s \\<and>\n                         a \\<in> S \\<and>\n                         ((\\<exists>x \\<omega>.\n                              s = \\<omega> \\<and>\n                              x \\<in> S \\<and> K.enabled x \\<omega>) \\<or>\n                          s \\<in> streams S)", "using K_subset"], ["proof (prove)\nusing this:\n  ?x1 \\<in> S \\<Longrightarrow> set_pmf (K ?x1) \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> S; K.enabled x \\<omega>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s.\n                         \\<omega> = a ## s \\<and>\n                         a \\<in> S \\<and>\n                         ((\\<exists>x \\<omega>.\n                              s = \\<omega> \\<and>\n                              x \\<in> S \\<and> K.enabled x \\<omega>) \\<or>\n                          s \\<in> streams S)", "by (cases \\<omega>) (auto simp: K.enabled_Stream)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<omega> \\<in> streams S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  AE \\<omega> in K.T x. \\<omega> \\<in> streams S\n\ngoal (1 subgoal):\n 1. emeasure (K.T x) A = emeasure (L.T y) B", "have L_eq: \"L y = map_pmf f (K x)\" if xy: \"R x y\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. L y = map_pmf f (K x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. L y = map_pmf f (K x)", "have \"rel_pmf (\\<lambda>x y. x = y) (map_pmf f (K x)) (L y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_pmf (=) (map_pmf f (K x)) (L y)", "using KL[THEN rel_funD, OF xy]"], ["proof (prove)\nusing this:\n  rel_pmf R (K x) (L y)\n\ngoal (1 subgoal):\n 1. rel_pmf (=) (map_pmf f (K x)) (L y)", "by (auto intro: pmf.rel_mono_strong simp: R_def pmf.rel_map)"], ["proof (state)\nthis:\n  rel_pmf (=) (map_pmf f (K x)) (L y)\n\ngoal (1 subgoal):\n 1. L y = map_pmf f (K x)", "then"], ["proof (chain)\npicking this:\n  rel_pmf (=) (map_pmf f (K x)) (L y)", "show ?thesis"], ["proof (prove)\nusing this:\n  rel_pmf (=) (map_pmf f (K x)) (L y)\n\ngoal (1 subgoal):\n 1. L y = map_pmf f (K x)", "unfolding pmf.rel_eq"], ["proof (prove)\nusing this:\n  map_pmf f (K x) = L y\n\ngoal (1 subgoal):\n 1. L y = map_pmf f (K x)", "by simp"], ["proof (state)\nthis:\n  L y = map_pmf f (K x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R ?x1 ?y1 \\<Longrightarrow> L ?y1 = map_pmf f (K ?x1)\n\ngoal (1 subgoal):\n 1. emeasure (K.T x) A = emeasure (L.T y) B", "let ?D = \"\\<lambda>x. distr (K.T x) K.S (smap f)\""], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure (K.T x) A = emeasure (L.T y) B", "have prob_space_D: \"?D x \\<in> space (prob_algebra K.S)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. distr (K.T x) (stream_space (count_space UNIV)) (smap f)\n    \\<in> space (prob_algebra (stream_space (count_space UNIV)))", "by (auto simp: space_prob_algebra K.T.prob_space_distr)"], ["proof (state)\nthis:\n  distr (K.T ?x1) (stream_space (count_space UNIV)) (smap f)\n  \\<in> space (prob_algebra (stream_space (count_space UNIV)))\n\ngoal (1 subgoal):\n 1. emeasure (K.T x) A = emeasure (L.T y) B", "have D_eq_D: \"?D x = ?D x'\" if \"R x y\" \"R x' y\" for x x' y"], ["proof (prove)\ngoal (1 subgoal):\n 1. distr (K.T x) (stream_space (count_space UNIV)) (smap f) =\n    distr (K.T x') (stream_space (count_space UNIV)) (smap f)", "proof (rule stream_space_eq_sstart)"], ["proof (state)\ngoal (8 subgoals):\n 1. countable ?S\n 2. prob_space (distr (K.T x) (stream_space (count_space UNIV)) (smap f))\n 3. prob_space (distr (K.T x') (stream_space (count_space UNIV)) (smap f))\n 4. AE x in distr (K.T x) (stream_space (count_space UNIV))\n             (smap f). x \\<in> streams ?S\n 5. AE x in distr (K.T x') (stream_space (count_space UNIV))\n             (smap f). x \\<in> streams ?S\n 6. sets (distr (K.T x) (stream_space (count_space UNIV)) (smap f)) =\n    sets (stream_space (count_space UNIV))\n 7. sets (distr (K.T x') (stream_space (count_space UNIV)) (smap f)) =\n    sets (stream_space (count_space UNIV))\n 8. \\<And>xs.\n       \\<lbrakk>xs \\<noteq> []; xs \\<in> lists ?S\\<rbrakk>\n       \\<Longrightarrow> emeasure\n                          (distr (K.T x) (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart ?S xs) =\n                         emeasure\n                          (distr (K.T x') (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart ?S xs)", "define A where \"A = K.acc `` {x, x'}\""], ["proof (state)\nthis:\n  A = K.acc `` {x, x'}\n\ngoal (8 subgoals):\n 1. countable ?S\n 2. prob_space (distr (K.T x) (stream_space (count_space UNIV)) (smap f))\n 3. prob_space (distr (K.T x') (stream_space (count_space UNIV)) (smap f))\n 4. AE x in distr (K.T x) (stream_space (count_space UNIV))\n             (smap f). x \\<in> streams ?S\n 5. AE x in distr (K.T x') (stream_space (count_space UNIV))\n             (smap f). x \\<in> streams ?S\n 6. sets (distr (K.T x) (stream_space (count_space UNIV)) (smap f)) =\n    sets (stream_space (count_space UNIV))\n 7. sets (distr (K.T x') (stream_space (count_space UNIV)) (smap f)) =\n    sets (stream_space (count_space UNIV))\n 8. \\<And>xs.\n       \\<lbrakk>xs \\<noteq> []; xs \\<in> lists ?S\\<rbrakk>\n       \\<Longrightarrow> emeasure\n                          (distr (K.T x) (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart ?S xs) =\n                         emeasure\n                          (distr (K.T x') (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart ?S xs)", "have x_A: \"x \\<in> A\" \"x' \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> A &&& x' \\<in> A", "by (auto simp: A_def)"], ["proof (state)\nthis:\n  x \\<in> A\n  x' \\<in> A\n\ngoal (8 subgoals):\n 1. countable ?S\n 2. prob_space (distr (K.T x) (stream_space (count_space UNIV)) (smap f))\n 3. prob_space (distr (K.T x') (stream_space (count_space UNIV)) (smap f))\n 4. AE x in distr (K.T x) (stream_space (count_space UNIV))\n             (smap f). x \\<in> streams ?S\n 5. AE x in distr (K.T x') (stream_space (count_space UNIV))\n             (smap f). x \\<in> streams ?S\n 6. sets (distr (K.T x) (stream_space (count_space UNIV)) (smap f)) =\n    sets (stream_space (count_space UNIV))\n 7. sets (distr (K.T x') (stream_space (count_space UNIV)) (smap f)) =\n    sets (stream_space (count_space UNIV))\n 8. \\<And>xs.\n       \\<lbrakk>xs \\<noteq> []; xs \\<in> lists ?S\\<rbrakk>\n       \\<Longrightarrow> emeasure\n                          (distr (K.T x) (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart ?S xs) =\n                         emeasure\n                          (distr (K.T x') (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart ?S xs)", "let ?\\<Omega> = \"f ` A\""], ["proof (state)\ngoal (8 subgoals):\n 1. countable ?S\n 2. prob_space (distr (K.T x) (stream_space (count_space UNIV)) (smap f))\n 3. prob_space (distr (K.T x') (stream_space (count_space UNIV)) (smap f))\n 4. AE x in distr (K.T x) (stream_space (count_space UNIV))\n             (smap f). x \\<in> streams ?S\n 5. AE x in distr (K.T x') (stream_space (count_space UNIV))\n             (smap f). x \\<in> streams ?S\n 6. sets (distr (K.T x) (stream_space (count_space UNIV)) (smap f)) =\n    sets (stream_space (count_space UNIV))\n 7. sets (distr (K.T x') (stream_space (count_space UNIV)) (smap f)) =\n    sets (stream_space (count_space UNIV))\n 8. \\<And>xs.\n       \\<lbrakk>xs \\<noteq> []; xs \\<in> lists ?S\\<rbrakk>\n       \\<Longrightarrow> emeasure\n                          (distr (K.T x) (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart ?S xs) =\n                         emeasure\n                          (distr (K.T x') (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart ?S xs)", "show \"countable ?\\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable (f ` A)", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. countable (f ` K.acc `` {x, x'})", "by (intro countable_image K.countable_acc) auto"], ["proof (state)\nthis:\n  countable (f ` A)\n\ngoal (7 subgoals):\n 1. prob_space (distr (K.T x) (stream_space (count_space UNIV)) (smap f))\n 2. prob_space (distr (K.T x') (stream_space (count_space UNIV)) (smap f))\n 3. AE x in distr (K.T x) (stream_space (count_space UNIV))\n             (smap f). x \\<in> streams (f ` K.acc `` {x, x'})\n 4. AE x in distr (K.T x') (stream_space (count_space UNIV))\n             (smap f). x \\<in> streams (f ` K.acc `` {x, x'})\n 5. sets (distr (K.T x) (stream_space (count_space UNIV)) (smap f)) =\n    sets (stream_space (count_space UNIV))\n 6. sets (distr (K.T x') (stream_space (count_space UNIV)) (smap f)) =\n    sets (stream_space (count_space UNIV))\n 7. \\<And>xs.\n       \\<lbrakk>xs \\<noteq> [];\n        xs \\<in> lists (f ` K.acc `` {x, x'})\\<rbrakk>\n       \\<Longrightarrow> emeasure\n                          (distr (K.T x) (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` K.acc `` {x, x'}) xs) =\n                         emeasure\n                          (distr (K.T x') (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` K.acc `` {x, x'}) xs)", "show \"prob_space (?D x)\" \"prob_space (?D x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prob_space\n     (distr (K.T x) (stream_space (count_space UNIV)) (smap f)) &&&\n    prob_space (distr (K.T x') (stream_space (count_space UNIV)) (smap f))", "by (auto intro!: K.T.prob_space_distr)"], ["proof (state)\nthis:\n  prob_space (distr (K.T x) (stream_space (count_space UNIV)) (smap f))\n  prob_space (distr (K.T x') (stream_space (count_space UNIV)) (smap f))\n\ngoal (5 subgoals):\n 1. AE x in distr (K.T x) (stream_space (count_space UNIV))\n             (smap f). x \\<in> streams (f ` K.acc `` {x, x'})\n 2. AE x in distr (K.T x') (stream_space (count_space UNIV))\n             (smap f). x \\<in> streams (f ` K.acc `` {x, x'})\n 3. sets (distr (K.T x) (stream_space (count_space UNIV)) (smap f)) =\n    sets (stream_space (count_space UNIV))\n 4. sets (distr (K.T x') (stream_space (count_space UNIV)) (smap f)) =\n    sets (stream_space (count_space UNIV))\n 5. \\<And>xs.\n       \\<lbrakk>xs \\<noteq> [];\n        xs \\<in> lists (f ` K.acc `` {x, x'})\\<rbrakk>\n       \\<Longrightarrow> emeasure\n                          (distr (K.T x) (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` K.acc `` {x, x'}) xs) =\n                         emeasure\n                          (distr (K.T x') (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` K.acc `` {x, x'}) xs)", "show \"sets (?D x) = sets L.S\" \"sets (?D x') = sets L.S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sets (distr (K.T x) (stream_space (count_space UNIV)) (smap f)) =\n    sets (stream_space (count_space UNIV)) &&&\n    sets (distr (K.T x') (stream_space (count_space UNIV)) (smap f)) =\n    sets (stream_space (count_space UNIV))", "by auto"], ["proof (state)\nthis:\n  sets (distr (K.T x) (stream_space (count_space UNIV)) (smap f)) =\n  sets (stream_space (count_space UNIV))\n  sets (distr (K.T x') (stream_space (count_space UNIV)) (smap f)) =\n  sets (stream_space (count_space UNIV))\n\ngoal (3 subgoals):\n 1. AE x in distr (K.T x) (stream_space (count_space UNIV))\n             (smap f). x \\<in> streams (f ` K.acc `` {x, x'})\n 2. AE x in distr (K.T x') (stream_space (count_space UNIV))\n             (smap f). x \\<in> streams (f ` K.acc `` {x, x'})\n 3. \\<And>xs.\n       \\<lbrakk>xs \\<noteq> [];\n        xs \\<in> lists (f ` K.acc `` {x, x'})\\<rbrakk>\n       \\<Longrightarrow> emeasure\n                          (distr (K.T x) (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` K.acc `` {x, x'}) xs) =\n                         emeasure\n                          (distr (K.T x') (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` K.acc `` {x, x'}) xs)", "have AE_streams: \"AE x in ?D x''. x \\<in> streams ?\\<Omega>\" if \"x'' \\<in> A\" for x''"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE x in distr (K.T x'') (stream_space (count_space UNIV))\n             (smap f). x \\<in> streams (f ` A)", "apply (simp add: space_stream_space streams_sets AE_distr_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE x in K.T x''. smap f x \\<in> streams (f ` A)", "using K.AE_T_reachable[of x'']"], ["proof (prove)\nusing this:\n  almost_everywhere (K.T x'') (alw (HLD (K.acc `` {x''})))\n\ngoal (1 subgoal):\n 1. AE x in K.T x''. smap f x \\<in> streams (f ` A)", "unfolding alw_HLD_iff_streams"], ["proof (prove)\nusing this:\n  AE \\<omega> in K.T x''. \\<omega> \\<in> streams (K.acc `` {x''})\n\ngoal (1 subgoal):\n 1. AE x in K.T x''. smap f x \\<in> streams (f ` A)", "proof eventually_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> streams (K.acc `` {x''}) \\<Longrightarrow>\n       smap f x \\<in> streams (f ` A)", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> streams (K.acc `` {x''}) \\<Longrightarrow>\n       smap f x \\<in> streams (f ` A)", "assume \"s \\<in> streams (K.acc `` {x''})\""], ["proof (state)\nthis:\n  s \\<in> streams (K.acc `` {x''})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> streams (K.acc `` {x''}) \\<Longrightarrow>\n       smap f x \\<in> streams (f ` A)", "moreover"], ["proof (state)\nthis:\n  s \\<in> streams (K.acc `` {x''})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> streams (K.acc `` {x''}) \\<Longrightarrow>\n       smap f x \\<in> streams (f ` A)", "have \"K.acc `` {x''} \\<subseteq> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K.acc `` {x''} \\<subseteq> A", "using \\<open>x'' \\<in> A\\<close>"], ["proof (prove)\nusing this:\n  x'' \\<in> A\n\ngoal (1 subgoal):\n 1. K.acc `` {x''} \\<subseteq> A", "by (auto simp: A_def Image_def intro: rtrancl_trans)"], ["proof (state)\nthis:\n  K.acc `` {x''} \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> streams (K.acc `` {x''}) \\<Longrightarrow>\n       smap f x \\<in> streams (f ` A)", "ultimately"], ["proof (chain)\npicking this:\n  s \\<in> streams (K.acc `` {x''})\n  K.acc `` {x''} \\<subseteq> A", "show \"smap f s \\<in> streams (f ` A)\""], ["proof (prove)\nusing this:\n  s \\<in> streams (K.acc `` {x''})\n  K.acc `` {x''} \\<subseteq> A\n\ngoal (1 subgoal):\n 1. smap f s \\<in> streams (f ` A)", "by (auto intro: smap_streams)"], ["proof (state)\nthis:\n  smap f s \\<in> streams (f ` A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x''1 \\<in> A \\<Longrightarrow>\n  AE x in distr (K.T ?x''1) (stream_space (count_space UNIV))\n           (smap f). x \\<in> streams (f ` A)\n\ngoal (3 subgoals):\n 1. AE x in distr (K.T x) (stream_space (count_space UNIV))\n             (smap f). x \\<in> streams (f ` K.acc `` {x, x'})\n 2. AE x in distr (K.T x') (stream_space (count_space UNIV))\n             (smap f). x \\<in> streams (f ` K.acc `` {x, x'})\n 3. \\<And>xs.\n       \\<lbrakk>xs \\<noteq> [];\n        xs \\<in> lists (f ` K.acc `` {x, x'})\\<rbrakk>\n       \\<Longrightarrow> emeasure\n                          (distr (K.T x) (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` K.acc `` {x, x'}) xs) =\n                         emeasure\n                          (distr (K.T x') (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` K.acc `` {x, x'}) xs)", "with x_A"], ["proof (chain)\npicking this:\n  x \\<in> A\n  x' \\<in> A\n  ?x''1 \\<in> A \\<Longrightarrow>\n  AE x in distr (K.T ?x''1) (stream_space (count_space UNIV))\n           (smap f). x \\<in> streams (f ` A)", "show \"AE x in ?D x'. x \\<in> streams ?\\<Omega>\" \"AE x in ?D x. x \\<in> streams ?\\<Omega>\""], ["proof (prove)\nusing this:\n  x \\<in> A\n  x' \\<in> A\n  ?x''1 \\<in> A \\<Longrightarrow>\n  AE x in distr (K.T ?x''1) (stream_space (count_space UNIV))\n           (smap f). x \\<in> streams (f ` A)\n\ngoal (1 subgoal):\n 1. AE x in distr (K.T x') (stream_space (count_space UNIV))\n             (smap f). x \\<in> streams (f ` A) &&&\n    AE x in distr (K.T x) (stream_space (count_space UNIV))\n             (smap f). x \\<in> streams (f ` A)", "by auto"], ["proof (state)\nthis:\n  AE x in distr (K.T x') (stream_space (count_space UNIV))\n           (smap f). x \\<in> streams (f ` A)\n  AE x in distr (K.T x) (stream_space (count_space UNIV))\n           (smap f). x \\<in> streams (f ` A)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<noteq> [];\n        xs \\<in> lists (f ` K.acc `` {x, x'})\\<rbrakk>\n       \\<Longrightarrow> emeasure\n                          (distr (K.T x) (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` K.acc `` {x, x'}) xs) =\n                         emeasure\n                          (distr (K.T x') (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` K.acc `` {x, x'}) xs)", "from \\<open>x \\<in> A\\<close> \\<open>x' \\<in> A\\<close> that"], ["proof (chain)\npicking this:\n  x \\<in> A\n  x' \\<in> A\n  R x y\n  R x' y", "show \"?D x (sstart (f ` A) xs) = ?D x' (sstart (f ` A) xs)\" for xs"], ["proof (prove)\nusing this:\n  x \\<in> A\n  x' \\<in> A\n  R x y\n  R x' y\n\ngoal (1 subgoal):\n 1. emeasure (distr (K.T x) (stream_space (count_space UNIV)) (smap f))\n     (sstart (f ` A) xs) =\n    emeasure (distr (K.T x') (stream_space (count_space UNIV)) (smap f))\n     (sstart (f ` A) xs)", "proof (induction xs arbitrary: x x' y)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x x' y.\n       \\<lbrakk>x \\<in> A; x' \\<in> A; R x y; R x' y\\<rbrakk>\n       \\<Longrightarrow> emeasure\n                          (distr (K.T x) (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` A) []) =\n                         emeasure\n                          (distr (K.T x') (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` A) [])\n 2. \\<And>a xs x x' y.\n       \\<lbrakk>\\<And>x x' y.\n                   \\<lbrakk>x \\<in> A; x' \\<in> A; R x y; R x' y\\<rbrakk>\n                   \\<Longrightarrow> emeasure\n(distr (K.T x) (stream_space (count_space UNIV)) (smap f))\n(sstart (f ` A) xs) =\n                                     emeasure\n(distr (K.T x') (stream_space (count_space UNIV)) (smap f))\n(sstart (f ` A) xs);\n        x \\<in> A; x' \\<in> A; R x y; R x' y\\<rbrakk>\n       \\<Longrightarrow> emeasure\n                          (distr (K.T x) (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` A) (a # xs)) =\n                         emeasure\n                          (distr (K.T x') (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` A) (a # xs))", "case Nil"], ["proof (state)\nthis:\n  x \\<in> A\n  x' \\<in> A\n  R x y\n  R x' y\n\ngoal (2 subgoals):\n 1. \\<And>x x' y.\n       \\<lbrakk>x \\<in> A; x' \\<in> A; R x y; R x' y\\<rbrakk>\n       \\<Longrightarrow> emeasure\n                          (distr (K.T x) (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` A) []) =\n                         emeasure\n                          (distr (K.T x') (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` A) [])\n 2. \\<And>a xs x x' y.\n       \\<lbrakk>\\<And>x x' y.\n                   \\<lbrakk>x \\<in> A; x' \\<in> A; R x y; R x' y\\<rbrakk>\n                   \\<Longrightarrow> emeasure\n(distr (K.T x) (stream_space (count_space UNIV)) (smap f))\n(sstart (f ` A) xs) =\n                                     emeasure\n(distr (K.T x') (stream_space (count_space UNIV)) (smap f))\n(sstart (f ` A) xs);\n        x \\<in> A; x' \\<in> A; R x y; R x' y\\<rbrakk>\n       \\<Longrightarrow> emeasure\n                          (distr (K.T x) (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` A) (a # xs)) =\n                         emeasure\n                          (distr (K.T x') (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` A) (a # xs))", "moreover"], ["proof (state)\nthis:\n  x \\<in> A\n  x' \\<in> A\n  R x y\n  R x' y\n\ngoal (2 subgoals):\n 1. \\<And>x x' y.\n       \\<lbrakk>x \\<in> A; x' \\<in> A; R x y; R x' y\\<rbrakk>\n       \\<Longrightarrow> emeasure\n                          (distr (K.T x) (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` A) []) =\n                         emeasure\n                          (distr (K.T x') (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` A) [])\n 2. \\<And>a xs x x' y.\n       \\<lbrakk>\\<And>x x' y.\n                   \\<lbrakk>x \\<in> A; x' \\<in> A; R x y; R x' y\\<rbrakk>\n                   \\<Longrightarrow> emeasure\n(distr (K.T x) (stream_space (count_space UNIV)) (smap f))\n(sstart (f ` A) xs) =\n                                     emeasure\n(distr (K.T x') (stream_space (count_space UNIV)) (smap f))\n(sstart (f ` A) xs);\n        x \\<in> A; x' \\<in> A; R x y; R x' y\\<rbrakk>\n       \\<Longrightarrow> emeasure\n                          (distr (K.T x) (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` A) (a # xs)) =\n                         emeasure\n                          (distr (K.T x') (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` A) (a # xs))", "have \"?D x (streams (f ` A)) = 1\" if \"x \\<in> A\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (distr (K.T x) (stream_space (count_space UNIV)) (smap f))\n     (streams (f ` A)) =\n    1", "using AE_streams[of x] that"], ["proof (prove)\nusing this:\n  x \\<in> A \\<Longrightarrow>\n  AE x in distr (K.T x) (stream_space (count_space UNIV))\n           (smap f). x \\<in> streams (f ` A)\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. emeasure (distr (K.T x) (stream_space (count_space UNIV)) (smap f))\n     (streams (f ` A)) =\n    1", "by (intro prob_space.emeasure_eq_1_AE[OF K.T.prob_space_distr]) (auto simp: streams_sets)"], ["proof (state)\nthis:\n  ?x1 \\<in> A \\<Longrightarrow>\n  emeasure (distr (K.T ?x1) (stream_space (count_space UNIV)) (smap f))\n   (streams (f ` A)) =\n  1\n\ngoal (2 subgoals):\n 1. \\<And>x x' y.\n       \\<lbrakk>x \\<in> A; x' \\<in> A; R x y; R x' y\\<rbrakk>\n       \\<Longrightarrow> emeasure\n                          (distr (K.T x) (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` A) []) =\n                         emeasure\n                          (distr (K.T x') (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` A) [])\n 2. \\<And>a xs x x' y.\n       \\<lbrakk>\\<And>x x' y.\n                   \\<lbrakk>x \\<in> A; x' \\<in> A; R x y; R x' y\\<rbrakk>\n                   \\<Longrightarrow> emeasure\n(distr (K.T x) (stream_space (count_space UNIV)) (smap f))\n(sstart (f ` A) xs) =\n                                     emeasure\n(distr (K.T x') (stream_space (count_space UNIV)) (smap f))\n(sstart (f ` A) xs);\n        x \\<in> A; x' \\<in> A; R x y; R x' y\\<rbrakk>\n       \\<Longrightarrow> emeasure\n                          (distr (K.T x) (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` A) (a # xs)) =\n                         emeasure\n                          (distr (K.T x') (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` A) (a # xs))", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> A\n  x' \\<in> A\n  R x y\n  R x' y\n  ?x1 \\<in> A \\<Longrightarrow>\n  emeasure (distr (K.T ?x1) (stream_space (count_space UNIV)) (smap f))\n   (streams (f ` A)) =\n  1", "show ?case"], ["proof (prove)\nusing this:\n  x \\<in> A\n  x' \\<in> A\n  R x y\n  R x' y\n  ?x1 \\<in> A \\<Longrightarrow>\n  emeasure (distr (K.T ?x1) (stream_space (count_space UNIV)) (smap f))\n   (streams (f ` A)) =\n  1\n\ngoal (1 subgoal):\n 1. emeasure (distr (K.T x) (stream_space (count_space UNIV)) (smap f))\n     (sstart (f ` A) []) =\n    emeasure (distr (K.T x') (stream_space (count_space UNIV)) (smap f))\n     (sstart (f ` A) [])", "by simp"], ["proof (state)\nthis:\n  emeasure (distr (K.T x) (stream_space (count_space UNIV)) (smap f))\n   (sstart (f ` A) []) =\n  emeasure (distr (K.T x') (stream_space (count_space UNIV)) (smap f))\n   (sstart (f ` A) [])\n\ngoal (1 subgoal):\n 1. \\<And>a xs x x' y.\n       \\<lbrakk>\\<And>x x' y.\n                   \\<lbrakk>x \\<in> A; x' \\<in> A; R x y; R x' y\\<rbrakk>\n                   \\<Longrightarrow> emeasure\n(distr (K.T x) (stream_space (count_space UNIV)) (smap f))\n(sstart (f ` A) xs) =\n                                     emeasure\n(distr (K.T x') (stream_space (count_space UNIV)) (smap f))\n(sstart (f ` A) xs);\n        x \\<in> A; x' \\<in> A; R x y; R x' y\\<rbrakk>\n       \\<Longrightarrow> emeasure\n                          (distr (K.T x) (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` A) (a # xs)) =\n                         emeasure\n                          (distr (K.T x') (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` A) (a # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs x x' y.\n       \\<lbrakk>\\<And>x x' y.\n                   \\<lbrakk>x \\<in> A; x' \\<in> A; R x y; R x' y\\<rbrakk>\n                   \\<Longrightarrow> emeasure\n(distr (K.T x) (stream_space (count_space UNIV)) (smap f))\n(sstart (f ` A) xs) =\n                                     emeasure\n(distr (K.T x') (stream_space (count_space UNIV)) (smap f))\n(sstart (f ` A) xs);\n        x \\<in> A; x' \\<in> A; R x y; R x' y\\<rbrakk>\n       \\<Longrightarrow> emeasure\n                          (distr (K.T x) (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` A) (a # xs)) =\n                         emeasure\n                          (distr (K.T x') (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` A) (a # xs))", "case (Cons z zs x x' y)"], ["proof (state)\nthis:\n  \\<lbrakk>?x1 \\<in> A; ?x'1 \\<in> A; R ?x1 ?y1; R ?x'1 ?y1\\<rbrakk>\n  \\<Longrightarrow> emeasure\n                     (distr (K.T ?x1) (stream_space (count_space UNIV))\n                       (smap f))\n                     (sstart (f ` A) zs) =\n                    emeasure\n                     (distr (K.T ?x'1) (stream_space (count_space UNIV))\n                       (smap f))\n                     (sstart (f ` A) zs)\n  x \\<in> A\n  x' \\<in> A\n  R x y\n  R x' y\n\ngoal (1 subgoal):\n 1. \\<And>a xs x x' y.\n       \\<lbrakk>\\<And>x x' y.\n                   \\<lbrakk>x \\<in> A; x' \\<in> A; R x y; R x' y\\<rbrakk>\n                   \\<Longrightarrow> emeasure\n(distr (K.T x) (stream_space (count_space UNIV)) (smap f))\n(sstart (f ` A) xs) =\n                                     emeasure\n(distr (K.T x') (stream_space (count_space UNIV)) (smap f))\n(sstart (f ` A) xs);\n        x \\<in> A; x' \\<in> A; R x y; R x' y\\<rbrakk>\n       \\<Longrightarrow> emeasure\n                          (distr (K.T x) (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` A) (a # xs)) =\n                         emeasure\n                          (distr (K.T x') (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` A) (a # xs))", "have \"rel_pmf (R OO R\\<inverse>\\<inverse>) (K x) (K x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_pmf (R OO R\\<inverse>\\<inverse>) (K x) (K x')", "using KL[THEN rel_funD, OF Cons(4)] KL[THEN rel_funD, OF Cons(5)]"], ["proof (prove)\nusing this:\n  rel_pmf R (K x) (L y)\n  rel_pmf R (K x') (L y)\n\ngoal (1 subgoal):\n 1. rel_pmf (R OO R\\<inverse>\\<inverse>) (K x) (K x')", "unfolding pmf.rel_compp pmf.rel_flip"], ["proof (prove)\nusing this:\n  rel_pmf R (K x) (L y)\n  rel_pmf R (K x') (L y)\n\ngoal (1 subgoal):\n 1. (rel_pmf R OO (\\<lambda>a b. rel_pmf R b a)) (K x) (K x')", "by auto"], ["proof (state)\nthis:\n  rel_pmf (R OO R\\<inverse>\\<inverse>) (K x) (K x')\n\ngoal (1 subgoal):\n 1. \\<And>a xs x x' y.\n       \\<lbrakk>\\<And>x x' y.\n                   \\<lbrakk>x \\<in> A; x' \\<in> A; R x y; R x' y\\<rbrakk>\n                   \\<Longrightarrow> emeasure\n(distr (K.T x) (stream_space (count_space UNIV)) (smap f))\n(sstart (f ` A) xs) =\n                                     emeasure\n(distr (K.T x') (stream_space (count_space UNIV)) (smap f))\n(sstart (f ` A) xs);\n        x \\<in> A; x' \\<in> A; R x y; R x' y\\<rbrakk>\n       \\<Longrightarrow> emeasure\n                          (distr (K.T x) (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` A) (a # xs)) =\n                         emeasure\n                          (distr (K.T x') (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` A) (a # xs))", "then"], ["proof (chain)\npicking this:\n  rel_pmf (R OO R\\<inverse>\\<inverse>) (K x) (K x')", "obtain p :: \"('s \\<times> 's) pmf\" where p: \"\\<And>a b. (a, b) \\<in> p \\<Longrightarrow> (R OO R\\<inverse>\\<inverse>) a b\" and\n        eq: \"map_pmf fst p = K x\" \"map_pmf snd p = K x'\""], ["proof (prove)\nusing this:\n  rel_pmf (R OO R\\<inverse>\\<inverse>) (K x) (K x')\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>\\<And>a b.\n                    (a, b) \\<in> set_pmf p \\<Longrightarrow>\n                    (R OO R\\<inverse>\\<inverse>) a b;\n         map_pmf fst p = K x; map_pmf snd p = K x'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: pmf.in_rel)"], ["proof (state)\nthis:\n  (?a1, ?b1) \\<in> set_pmf p \\<Longrightarrow>\n  (R OO R\\<inverse>\\<inverse>) ?a1 ?b1\n  map_pmf fst p = K x\n  map_pmf snd p = K x'\n\ngoal (1 subgoal):\n 1. \\<And>a xs x x' y.\n       \\<lbrakk>\\<And>x x' y.\n                   \\<lbrakk>x \\<in> A; x' \\<in> A; R x y; R x' y\\<rbrakk>\n                   \\<Longrightarrow> emeasure\n(distr (K.T x) (stream_space (count_space UNIV)) (smap f))\n(sstart (f ` A) xs) =\n                                     emeasure\n(distr (K.T x') (stream_space (count_space UNIV)) (smap f))\n(sstart (f ` A) xs);\n        x \\<in> A; x' \\<in> A; R x y; R x' y\\<rbrakk>\n       \\<Longrightarrow> emeasure\n                          (distr (K.T x) (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` A) (a # xs)) =\n                         emeasure\n                          (distr (K.T x') (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` A) (a # xs))", "let ?S = \"stream_space (count_space UNIV)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs x x' y.\n       \\<lbrakk>\\<And>x x' y.\n                   \\<lbrakk>x \\<in> A; x' \\<in> A; R x y; R x' y\\<rbrakk>\n                   \\<Longrightarrow> emeasure\n(distr (K.T x) (stream_space (count_space UNIV)) (smap f))\n(sstart (f ` A) xs) =\n                                     emeasure\n(distr (K.T x') (stream_space (count_space UNIV)) (smap f))\n(sstart (f ` A) xs);\n        x \\<in> A; x' \\<in> A; R x y; R x' y\\<rbrakk>\n       \\<Longrightarrow> emeasure\n                          (distr (K.T x) (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` A) (a # xs)) =\n                         emeasure\n                          (distr (K.T x') (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` A) (a # xs))", "have *: \"(##) y -` smap f -` sstart (f ` A) (z # zs) = (if f y = z then smap f -` sstart (f ` A) zs else {})\" for y z zs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (##) y -` smap f -` sstart (f ` A) (z # zs) =\n    (if f y = z then smap f -` sstart (f ` A) zs else {})", "by auto"], ["proof (state)\nthis:\n  (##) ?y2 -` smap f -` sstart (f ` A) (?z2 # ?zs2) =\n  (if f ?y2 = ?z2 then smap f -` sstart (f ` A) ?zs2 else {})\n\ngoal (1 subgoal):\n 1. \\<And>a xs x x' y.\n       \\<lbrakk>\\<And>x x' y.\n                   \\<lbrakk>x \\<in> A; x' \\<in> A; R x y; R x' y\\<rbrakk>\n                   \\<Longrightarrow> emeasure\n(distr (K.T x) (stream_space (count_space UNIV)) (smap f))\n(sstart (f ` A) xs) =\n                                     emeasure\n(distr (K.T x') (stream_space (count_space UNIV)) (smap f))\n(sstart (f ` A) xs);\n        x \\<in> A; x' \\<in> A; R x y; R x' y\\<rbrakk>\n       \\<Longrightarrow> emeasure\n                          (distr (K.T x) (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` A) (a # xs)) =\n                         emeasure\n                          (distr (K.T x') (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` A) (a # xs))", "have **: \"?D x (sstart (f ` A) (z # zs)) = (\\<integral>\\<^sup>+ y'. (if f y' = z then ?D y' (sstart (f ` A) zs) else 0) \\<partial>K x)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (distr (K.T x) (stream_space (count_space UNIV)) (smap f))\n     (sstart (f ` A) (z # zs)) =\n    \\<integral>\\<^sup>+ y'. (if f y' = z\n                             then emeasure\n                                   (distr (K.T y')\n                                     (stream_space (count_space UNIV))\n                                     (smap f))\n                                   (sstart (f ` A) zs)\n                             else 0)\n                       \\<partial>measure_pmf (K x)", "apply (simp add: emeasure_distr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (K.T x)\n     (smap f -` sstart (f ` A) (z # zs) \\<inter>\n      space (stream_space (count_space UNIV))) =\n    \\<integral>\\<^sup>+ y'. (if f y' = z\n                             then emeasure\n                                   (distr (K.T y')\n                                     (stream_space (count_space UNIV))\n                                     (smap f))\n                                   (sstart (f ` A) zs)\n                             else 0)\n                       \\<partial>measure_pmf (K x)", "apply (subst K.T_eq_bind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure\n     (measure_pmf (K x) \\<bind>\n      (\\<lambda>t.\n          distr (K.T t) (stream_space (count_space UNIV)) ((##) t)))\n     (smap f -` sstart (f ` A) (z # zs) \\<inter>\n      space (stream_space (count_space UNIV))) =\n    \\<integral>\\<^sup>+ y'. (if f y' = z\n                             then emeasure\n                                   (distr (K.T y')\n                                     (stream_space (count_space UNIV))\n                                     (smap f))\n                                   (sstart (f ` A) zs)\n                             else 0)\n                       \\<partial>measure_pmf (K x)", "apply (subst emeasure_bind[where N=\"?S\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. space (measure_pmf (K x)) \\<noteq> {}\n 2. measure_pmf.random_variable (K x)\n     (subprob_algebra (stream_space (count_space UNIV)))\n     (\\<lambda>t. distr (K.T t) (stream_space (count_space UNIV)) ((##) t))\n 3. smap f -` sstart (f ` A) (z # zs) \\<inter>\n    space (stream_space (count_space UNIV))\n    \\<in> sets (stream_space (count_space UNIV))\n 4. \\<integral>\\<^sup>+ x. emeasure\n                            (distr (K.T x) (stream_space (count_space UNIV))\n                              ((##) x))\n                            (smap f -` sstart (f ` A) (z # zs) \\<inter>\n                             space (stream_space (count_space UNIV)))\n                       \\<partial>measure_pmf (K x) =\n    \\<integral>\\<^sup>+ y'. (if f y' = z\n                             then emeasure\n                                   (distr (K.T y')\n                                     (stream_space (count_space UNIV))\n                                     (smap f))\n                                   (sstart (f ` A) zs)\n                             else 0)\n                       \\<partial>measure_pmf (K x)", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. measure_pmf.random_variable (K x)\n     (subprob_algebra (stream_space (count_space UNIV)))\n     (\\<lambda>t. distr (K.T t) (stream_space (count_space UNIV)) ((##) t))\n 2. smap f -` sstart (f ` A) (z # zs) \\<inter>\n    space (stream_space (count_space UNIV))\n    \\<in> sets (stream_space (count_space UNIV))\n 3. \\<integral>\\<^sup>+ x. emeasure\n                            (distr (K.T x) (stream_space (count_space UNIV))\n                              ((##) x))\n                            (smap f -` sstart (f ` A) (z # zs) \\<inter>\n                             space (stream_space (count_space UNIV)))\n                       \\<partial>measure_pmf (K x) =\n    \\<integral>\\<^sup>+ y'. (if f y' = z\n                             then emeasure\n                                   (distr (K.T y')\n                                     (stream_space (count_space UNIV))\n                                     (smap f))\n                                   (sstart (f ` A) zs)\n                             else 0)\n                       \\<partial>measure_pmf (K x)", "apply (rule measurable_distr2[where M=\"?S\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. (\\<lambda>(x, y). x ## y)\n    \\<in> measure_pmf (K x) \\<Otimes>\\<^sub>M\n          stream_space (count_space UNIV) \\<rightarrow>\\<^sub>M\n          stream_space (count_space UNIV)\n 2. measure_pmf.random_variable (K x)\n     (subprob_algebra (stream_space (count_space UNIV))) K.T\n 3. smap f -` sstart (f ` A) (z # zs) \\<inter>\n    space (stream_space (count_space UNIV))\n    \\<in> sets (stream_space (count_space UNIV))\n 4. \\<integral>\\<^sup>+ x. emeasure\n                            (distr (K.T x) (stream_space (count_space UNIV))\n                              ((##) x))\n                            (smap f -` sstart (f ` A) (z # zs) \\<inter>\n                             space (stream_space (count_space UNIV)))\n                       \\<partial>measure_pmf (K x) =\n    \\<integral>\\<^sup>+ y'. (if f y' = z\n                             then emeasure\n                                   (distr (K.T y')\n                                     (stream_space (count_space UNIV))\n                                     (smap f))\n                                   (sstart (f ` A) zs)\n                             else 0)\n                       \\<partial>measure_pmf (K x)", "apply measurable"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. emeasure\n                            (distr (K.T x) (stream_space (count_space UNIV))\n                              ((##) x))\n                            (smap f -` sstart (f ` A) (z # zs) \\<inter>\n                             space (stream_space (count_space UNIV)))\n                       \\<partial>measure_pmf (K x) =\n    \\<integral>\\<^sup>+ y'. (if f y' = z\n                             then emeasure\n                                   (distr (K.T y')\n                                     (stream_space (count_space UNIV))\n                                     (smap f))\n                                   (sstart (f ` A) zs)\n                             else 0)\n                       \\<partial>measure_pmf (K x)", "apply (intro nn_integral_cong_AE AE_pmfI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> set_pmf (K x) \\<Longrightarrow>\n       emeasure (distr (K.T y) (stream_space (count_space UNIV)) ((##) y))\n        (smap f -` sstart (f ` A) (z # zs) \\<inter>\n         space (stream_space (count_space UNIV))) =\n       (if f y = z\n        then emeasure\n              (distr (K.T y) (stream_space (count_space UNIV)) (smap f))\n              (sstart (f ` A) zs)\n        else 0)", "apply (auto simp add: emeasure_distr)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>y \\<in> set_pmf (K x); z = f y\\<rbrakk>\n       \\<Longrightarrow> emeasure (K.T y)\n                          ((##) y -`\n                           smap f -` sstart (f ` A) (f y # zs) \\<inter>\n                           (##) y -`\n                           space (stream_space (count_space UNIV)) \\<inter>\n                           space (stream_space (count_space UNIV))) =\n                         emeasure (K.T y)\n                          (smap f -` sstart (f ` A) zs \\<inter>\n                           space (stream_space (count_space UNIV)))\n 2. \\<And>y.\n       \\<lbrakk>y \\<in> set_pmf (K x); f y \\<noteq> z\\<rbrakk>\n       \\<Longrightarrow> emeasure (K.T y)\n                          ((##) y -`\n                           smap f -` sstart (f ` A) (z # zs) \\<inter>\n                           (##) y -`\n                           space (stream_space (count_space UNIV)) \\<inter>\n                           space (stream_space (count_space UNIV))) =\n                         0", "apply (simp_all add: * space_stream_space)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  emeasure (distr (K.T ?x2) (stream_space (count_space UNIV)) (smap f))\n   (sstart (f ` A) (z # zs)) =\n  \\<integral>\\<^sup>+ y'. (if f y' = z\n                           then emeasure\n                                 (distr (K.T y')\n                                   (stream_space (count_space UNIV))\n                                   (smap f))\n                                 (sstart (f ` A) zs)\n                           else 0)\n                     \\<partial>measure_pmf (K ?x2)\n\ngoal (1 subgoal):\n 1. \\<And>a xs x x' y.\n       \\<lbrakk>\\<And>x x' y.\n                   \\<lbrakk>x \\<in> A; x' \\<in> A; R x y; R x' y\\<rbrakk>\n                   \\<Longrightarrow> emeasure\n(distr (K.T x) (stream_space (count_space UNIV)) (smap f))\n(sstart (f ` A) xs) =\n                                     emeasure\n(distr (K.T x') (stream_space (count_space UNIV)) (smap f))\n(sstart (f ` A) xs);\n        x \\<in> A; x' \\<in> A; R x y; R x' y\\<rbrakk>\n       \\<Longrightarrow> emeasure\n                          (distr (K.T x) (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` A) (a # xs)) =\n                         emeasure\n                          (distr (K.T x') (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` A) (a # xs))", "have fst_A: \"fst ab \\<in> A\" if \"ab \\<in> p\" for ab"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ab \\<in> A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fst ab \\<in> A", "have \"fst ab \\<in> K x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ab \\<in> set_pmf (K x)", "using \\<open>ab \\<in> p\\<close> set_map_pmf [of fst p]"], ["proof (prove)\nusing this:\n  ab \\<in> set_pmf p\n  set_pmf (map_pmf fst p) = fst ` set_pmf p\n\ngoal (1 subgoal):\n 1. fst ab \\<in> set_pmf (K x)", "by (auto simp: eq)"], ["proof (state)\nthis:\n  fst ab \\<in> set_pmf (K x)\n\ngoal (1 subgoal):\n 1. fst ab \\<in> A", "with \\<open>x \\<in> A\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> A\n  fst ab \\<in> set_pmf (K x)", "show \"fst ab \\<in> A\""], ["proof (prove)\nusing this:\n  x \\<in> A\n  fst ab \\<in> set_pmf (K x)\n\ngoal (1 subgoal):\n 1. fst ab \\<in> A", "by (auto simp: A_def intro: rtrancl.rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  fst ab \\<in> A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?ab2 \\<in> set_pmf p \\<Longrightarrow> fst ?ab2 \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>a xs x x' y.\n       \\<lbrakk>\\<And>x x' y.\n                   \\<lbrakk>x \\<in> A; x' \\<in> A; R x y; R x' y\\<rbrakk>\n                   \\<Longrightarrow> emeasure\n(distr (K.T x) (stream_space (count_space UNIV)) (smap f))\n(sstart (f ` A) xs) =\n                                     emeasure\n(distr (K.T x') (stream_space (count_space UNIV)) (smap f))\n(sstart (f ` A) xs);\n        x \\<in> A; x' \\<in> A; R x y; R x' y\\<rbrakk>\n       \\<Longrightarrow> emeasure\n                          (distr (K.T x) (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` A) (a # xs)) =\n                         emeasure\n                          (distr (K.T x') (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` A) (a # xs))", "have snd_A: \"snd ab \\<in> A\" if \"ab \\<in> p\" for ab"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd ab \\<in> A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. snd ab \\<in> A", "have \"snd ab \\<in> K x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd ab \\<in> set_pmf (K x')", "using \\<open>ab \\<in> p\\<close> set_map_pmf [of snd p]"], ["proof (prove)\nusing this:\n  ab \\<in> set_pmf p\n  set_pmf (map_pmf snd p) = snd ` set_pmf p\n\ngoal (1 subgoal):\n 1. snd ab \\<in> set_pmf (K x')", "by (auto simp: eq)"], ["proof (state)\nthis:\n  snd ab \\<in> set_pmf (K x')\n\ngoal (1 subgoal):\n 1. snd ab \\<in> A", "with \\<open>x' \\<in> A\\<close>"], ["proof (chain)\npicking this:\n  x' \\<in> A\n  snd ab \\<in> set_pmf (K x')", "show \"snd ab \\<in> A\""], ["proof (prove)\nusing this:\n  x' \\<in> A\n  snd ab \\<in> set_pmf (K x')\n\ngoal (1 subgoal):\n 1. snd ab \\<in> A", "by (auto simp: A_def intro: rtrancl.rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  snd ab \\<in> A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?ab2 \\<in> set_pmf p \\<Longrightarrow> snd ?ab2 \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>a xs x x' y.\n       \\<lbrakk>\\<And>x x' y.\n                   \\<lbrakk>x \\<in> A; x' \\<in> A; R x y; R x' y\\<rbrakk>\n                   \\<Longrightarrow> emeasure\n(distr (K.T x) (stream_space (count_space UNIV)) (smap f))\n(sstart (f ` A) xs) =\n                                     emeasure\n(distr (K.T x') (stream_space (count_space UNIV)) (smap f))\n(sstart (f ` A) xs);\n        x \\<in> A; x' \\<in> A; R x y; R x' y\\<rbrakk>\n       \\<Longrightarrow> emeasure\n                          (distr (K.T x) (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` A) (a # xs)) =\n                         emeasure\n                          (distr (K.T x') (stream_space (count_space UNIV))\n                            (smap f))\n                          (sstart (f ` A) (a # xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (distr (K.T x) (stream_space (count_space UNIV)) (smap f))\n     (sstart (f ` A) (z # zs)) =\n    emeasure (distr (K.T x') (stream_space (count_space UNIV)) (smap f))\n     (sstart (f ` A) (z # zs))", "unfolding ** eq[symmetric] nn_integral_map_pmf"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. (if f (fst x) = z\n                            then emeasure\n                                  (distr (K.T (fst x))\n                                    (stream_space (count_space UNIV))\n                                    (smap f))\n                                  (sstart (f ` A) zs)\n                            else 0)\n                       \\<partial>measure_pmf p =\n    \\<integral>\\<^sup>+ x. (if f (snd x) = z\n                            then emeasure\n                                  (distr (K.T (snd x))\n                                    (stream_space (count_space UNIV))\n                                    (smap f))\n                                  (sstart (f ` A) zs)\n                            else 0)\n                       \\<partial>measure_pmf p", "apply (intro nn_integral_cong_AE AE_pmfI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> set_pmf p \\<Longrightarrow>\n       (if f (fst y) = z\n        then emeasure\n              (distr (K.T (fst y)) (stream_space (count_space UNIV))\n                (smap f))\n              (sstart (f ` A) zs)\n        else 0) =\n       (if f (snd y) = z\n        then emeasure\n              (distr (K.T (snd y)) (stream_space (count_space UNIV))\n                (smap f))\n              (sstart (f ` A) zs)\n        else 0)", "subgoal for ab"], ["proof (prove)\ngoal (1 subgoal):\n 1. ab \\<in> set_pmf p \\<Longrightarrow>\n    (if f (fst ab) = z\n     then emeasure\n           (distr (K.T (fst ab)) (stream_space (count_space UNIV)) (smap f))\n           (sstart (f ` A) zs)\n     else 0) =\n    (if f (snd ab) = z\n     then emeasure\n           (distr (K.T (snd ab)) (stream_space (count_space UNIV)) (smap f))\n           (sstart (f ` A) zs)\n     else 0)", "using p[of \"fst ab\" \"snd ab\"]"], ["proof (prove)\nusing this:\n  (fst ab, snd ab) \\<in> set_pmf p \\<Longrightarrow>\n  (R OO R\\<inverse>\\<inverse>) (fst ab) (snd ab)\n\ngoal (1 subgoal):\n 1. ab \\<in> set_pmf p \\<Longrightarrow>\n    (if f (fst ab) = z\n     then emeasure\n           (distr (K.T (fst ab)) (stream_space (count_space UNIV)) (smap f))\n           (sstart (f ` A) zs)\n     else 0) =\n    (if f (snd ab) = z\n     then emeasure\n           (distr (K.T (snd ab)) (stream_space (count_space UNIV)) (smap f))\n           (sstart (f ` A) zs)\n     else 0)", "by (auto simp: R_def intro!: Cons(1) fst_A snd_A)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  emeasure (distr (K.T x) (stream_space (count_space UNIV)) (smap f))\n   (sstart (f ` A) (z # zs)) =\n  emeasure (distr (K.T x') (stream_space (count_space UNIV)) (smap f))\n   (sstart (f ` A) (z # zs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  emeasure (distr (K.T x) (stream_space (count_space UNIV)) (smap f))\n   (sstart (f ` A) ?xs1) =\n  emeasure (distr (K.T x') (stream_space (count_space UNIV)) (smap f))\n   (sstart (f ` A) ?xs1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>R ?x1 ?y1; R ?x'1 ?y1\\<rbrakk>\n  \\<Longrightarrow> distr (K.T ?x1) (stream_space (count_space UNIV))\n                     (smap f) =\n                    distr (K.T ?x'1) (stream_space (count_space UNIV))\n                     (smap f)\n\ngoal (1 subgoal):\n 1. emeasure (K.T x) A = emeasure (L.T y) B", "have L_eq_D: \"L.T y = ?D x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L.T y = distr (K.T x) (stream_space (count_space UNIV)) (smap f)", "using \\<open>R x y\\<close>"], ["proof (prove)\nusing this:\n  R x y\n\ngoal (1 subgoal):\n 1. L.T y = distr (K.T x) (stream_space (count_space UNIV)) (smap f)", "proof (coinduction arbitrary: x y rule: L.T_coinduct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xa y.\n       R xa y \\<Longrightarrow>\n       prob_space\n        (distr (K.T xa) (stream_space (count_space UNIV)) (smap f))\n 2. \\<And>xa y.\n       R xa y \\<Longrightarrow>\n       sets (distr (K.T xa) (stream_space (count_space UNIV)) (smap f)) =\n       sets (stream_space (count_space UNIV))\n 3. \\<And>xa y.\n       R xa y \\<Longrightarrow>\n       \\<exists>M'.\n          (\\<forall>y\\<in>set_pmf (L y).\n              \\<exists>x ya.\n                 y = ya \\<and>\n                 M' y =\n                 distr (K.T x) (stream_space (count_space UNIV))\n                  (smap f) \\<and>\n                 R x ya) \\<and>\n          (\\<forall>y.\n              sets (M' y) = sets (stream_space (count_space UNIV)) \\<and>\n              prob_space (M' y)) \\<and>\n          distr (K.T xa) (stream_space (count_space UNIV)) (smap f) =\n          measure_pmf (L y) \\<bind>\n          (\\<lambda>y.\n              distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "case (cont x y)"], ["proof (state)\nthis:\n  R x y\n\ngoal (3 subgoals):\n 1. \\<And>xa y.\n       R xa y \\<Longrightarrow>\n       prob_space\n        (distr (K.T xa) (stream_space (count_space UNIV)) (smap f))\n 2. \\<And>xa y.\n       R xa y \\<Longrightarrow>\n       sets (distr (K.T xa) (stream_space (count_space UNIV)) (smap f)) =\n       sets (stream_space (count_space UNIV))\n 3. \\<And>xa y.\n       R xa y \\<Longrightarrow>\n       \\<exists>M'.\n          (\\<forall>y\\<in>set_pmf (L y).\n              \\<exists>x ya.\n                 y = ya \\<and>\n                 M' y =\n                 distr (K.T x) (stream_space (count_space UNIV))\n                  (smap f) \\<and>\n                 R x ya) \\<and>\n          (\\<forall>y.\n              sets (M' y) = sets (stream_space (count_space UNIV)) \\<and>\n              prob_space (M' y)) \\<and>\n          distr (K.T xa) (stream_space (count_space UNIV)) (smap f) =\n          measure_pmf (L y) \\<bind>\n          (\\<lambda>y.\n              distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "then"], ["proof (chain)\npicking this:\n  R x y", "have Kx_Ly: \"rel_pmf R (K x) (L y)\""], ["proof (prove)\nusing this:\n  R x y\n\ngoal (1 subgoal):\n 1. rel_pmf R (K x) (L y)", "by (rule KL[THEN rel_funD])"], ["proof (state)\nthis:\n  rel_pmf R (K x) (L y)\n\ngoal (3 subgoals):\n 1. \\<And>xa y.\n       R xa y \\<Longrightarrow>\n       prob_space\n        (distr (K.T xa) (stream_space (count_space UNIV)) (smap f))\n 2. \\<And>xa y.\n       R xa y \\<Longrightarrow>\n       sets (distr (K.T xa) (stream_space (count_space UNIV)) (smap f)) =\n       sets (stream_space (count_space UNIV))\n 3. \\<And>xa y.\n       R xa y \\<Longrightarrow>\n       \\<exists>M'.\n          (\\<forall>y\\<in>set_pmf (L y).\n              \\<exists>x ya.\n                 y = ya \\<and>\n                 M' y =\n                 distr (K.T x) (stream_space (count_space UNIV))\n                  (smap f) \\<and>\n                 R x ya) \\<and>\n          (\\<forall>y.\n              sets (M' y) = sets (stream_space (count_space UNIV)) \\<and>\n              prob_space (M' y)) \\<and>\n          distr (K.T xa) (stream_space (count_space UNIV)) (smap f) =\n          measure_pmf (L y) \\<bind>\n          (\\<lambda>y.\n              distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "then"], ["proof (chain)\npicking this:\n  rel_pmf R (K x) (L y)", "have *: \"y' \\<in> L y \\<Longrightarrow> \\<exists>x'\\<in>K x. R x' y'\" for y'"], ["proof (prove)\nusing this:\n  rel_pmf R (K x) (L y)\n\ngoal (1 subgoal):\n 1. y' \\<in> set_pmf (L y) \\<Longrightarrow>\n    \\<exists>x'\\<in>set_pmf (K x). R x' y'", "by (auto dest!: rel_pmf_imp_rel_set simp: rel_set_def)"], ["proof (state)\nthis:\n  ?y'1 \\<in> set_pmf (L y) \\<Longrightarrow>\n  \\<exists>x'\\<in>set_pmf (K x). R x' ?y'1\n\ngoal (3 subgoals):\n 1. \\<And>xa y.\n       R xa y \\<Longrightarrow>\n       prob_space\n        (distr (K.T xa) (stream_space (count_space UNIV)) (smap f))\n 2. \\<And>xa y.\n       R xa y \\<Longrightarrow>\n       sets (distr (K.T xa) (stream_space (count_space UNIV)) (smap f)) =\n       sets (stream_space (count_space UNIV))\n 3. \\<And>xa y.\n       R xa y \\<Longrightarrow>\n       \\<exists>M'.\n          (\\<forall>y\\<in>set_pmf (L y).\n              \\<exists>x ya.\n                 y = ya \\<and>\n                 M' y =\n                 distr (K.T x) (stream_space (count_space UNIV))\n                  (smap f) \\<and>\n                 R x ya) \\<and>\n          (\\<forall>y.\n              sets (M' y) = sets (stream_space (count_space UNIV)) \\<and>\n              prob_space (M' y)) \\<and>\n          distr (K.T xa) (stream_space (count_space UNIV)) (smap f) =\n          measure_pmf (L y) \\<bind>\n          (\\<lambda>y.\n              distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "have **: \"y' \\<in> L y \\<Longrightarrow> R (g y') y'\" for y'"], ["proof (prove)\ngoal (1 subgoal):\n 1. y' \\<in> set_pmf (L y) \\<Longrightarrow> R (g y') y'", "using *[of y']"], ["proof (prove)\nusing this:\n  y' \\<in> set_pmf (L y) \\<Longrightarrow>\n  \\<exists>x'\\<in>set_pmf (K x). R x' y'\n\ngoal (1 subgoal):\n 1. y' \\<in> set_pmf (L y) \\<Longrightarrow> R (g y') y'", "unfolding g_def"], ["proof (prove)\nusing this:\n  y' \\<in> set_pmf (L y) \\<Longrightarrow>\n  \\<exists>x'\\<in>set_pmf (K x). R x' y'\n\ngoal (1 subgoal):\n 1. y' \\<in> set_pmf (L y) \\<Longrightarrow> R (SOME s. R s y') y'", "by (auto intro: someI)"], ["proof (state)\nthis:\n  ?y'1 \\<in> set_pmf (L y) \\<Longrightarrow> R (g ?y'1) ?y'1\n\ngoal (3 subgoals):\n 1. \\<And>xa y.\n       R xa y \\<Longrightarrow>\n       prob_space\n        (distr (K.T xa) (stream_space (count_space UNIV)) (smap f))\n 2. \\<And>xa y.\n       R xa y \\<Longrightarrow>\n       sets (distr (K.T xa) (stream_space (count_space UNIV)) (smap f)) =\n       sets (stream_space (count_space UNIV))\n 3. \\<And>xa y.\n       R xa y \\<Longrightarrow>\n       \\<exists>M'.\n          (\\<forall>y\\<in>set_pmf (L y).\n              \\<exists>x ya.\n                 y = ya \\<and>\n                 M' y =\n                 distr (K.T x) (stream_space (count_space UNIV))\n                  (smap f) \\<and>\n                 R x ya) \\<and>\n          (\\<forall>y.\n              sets (M' y) = sets (stream_space (count_space UNIV)) \\<and>\n              prob_space (M' y)) \\<and>\n          distr (K.T xa) (stream_space (count_space UNIV)) (smap f) =\n          measure_pmf (L y) \\<bind>\n          (\\<lambda>y.\n              distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "have D_SCons_eq_D_D: \"distr (K.T i) K.S (\\<lambda>x. z ## smap f x) = distr (?D i) K.S (\\<lambda>x. z ## x)\" for i z"], ["proof (prove)\ngoal (1 subgoal):\n 1. distr (K.T i) (stream_space (count_space UNIV))\n     (\\<lambda>x. z ## smap f x) =\n    distr (distr (K.T i) (stream_space (count_space UNIV)) (smap f))\n     (stream_space (count_space UNIV)) ((##) z)", "by (subst distr_distr) (auto simp: comp_def)"], ["proof (state)\nthis:\n  distr (K.T ?i1) (stream_space (count_space UNIV))\n   (\\<lambda>x. ?z1 ## smap f x) =\n  distr (distr (K.T ?i1) (stream_space (count_space UNIV)) (smap f))\n   (stream_space (count_space UNIV)) ((##) ?z1)\n\ngoal (3 subgoals):\n 1. \\<And>xa y.\n       R xa y \\<Longrightarrow>\n       prob_space\n        (distr (K.T xa) (stream_space (count_space UNIV)) (smap f))\n 2. \\<And>xa y.\n       R xa y \\<Longrightarrow>\n       sets (distr (K.T xa) (stream_space (count_space UNIV)) (smap f)) =\n       sets (stream_space (count_space UNIV))\n 3. \\<And>xa y.\n       R xa y \\<Longrightarrow>\n       \\<exists>M'.\n          (\\<forall>y\\<in>set_pmf (L y).\n              \\<exists>x ya.\n                 y = ya \\<and>\n                 M' y =\n                 distr (K.T x) (stream_space (count_space UNIV))\n                  (smap f) \\<and>\n                 R x ya) \\<and>\n          (\\<forall>y.\n              sets (M' y) = sets (stream_space (count_space UNIV)) \\<and>\n              prob_space (M' y)) \\<and>\n          distr (K.T xa) (stream_space (count_space UNIV)) (smap f) =\n          measure_pmf (L y) \\<bind>\n          (\\<lambda>y.\n              distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "have D_eq_D_gi: \"?D i = ?D (g (f i))\" if i: \"i \\<in> K x\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. distr (K.T i) (stream_space (count_space UNIV)) (smap f) =\n    distr (K.T (g (f i))) (stream_space (count_space UNIV)) (smap f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distr (K.T i) (stream_space (count_space UNIV)) (smap f) =\n    distr (K.T (g (f i))) (stream_space (count_space UNIV)) (smap f)", "obtain j where \"j \\<in> L y\" \"R i j\" \"f i = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j \\<in> set_pmf (L y); R i j; f i = j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Kx_Ly i"], ["proof (prove)\nusing this:\n  rel_pmf R (K x) (L y)\n  i \\<in> set_pmf (K x)\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j \\<in> set_pmf (L y); R i j; f i = j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (force dest!: rel_pmf_imp_rel_set simp: rel_set_def R_def)"], ["proof (state)\nthis:\n  j \\<in> set_pmf (L y)\n  R i j\n  f i = j\n\ngoal (1 subgoal):\n 1. distr (K.T i) (stream_space (count_space UNIV)) (smap f) =\n    distr (K.T (g (f i))) (stream_space (count_space UNIV)) (smap f)", "then"], ["proof (chain)\npicking this:\n  j \\<in> set_pmf (L y)\n  R i j\n  f i = j", "show ?thesis"], ["proof (prove)\nusing this:\n  j \\<in> set_pmf (L y)\n  R i j\n  f i = j\n\ngoal (1 subgoal):\n 1. distr (K.T i) (stream_space (count_space UNIV)) (smap f) =\n    distr (K.T (g (f i))) (stream_space (count_space UNIV)) (smap f)", "by (auto intro!: D_eq_D[OF \\<open>R i j\\<close>] g)"], ["proof (state)\nthis:\n  distr (K.T i) (stream_space (count_space UNIV)) (smap f) =\n  distr (K.T (g (f i))) (stream_space (count_space UNIV)) (smap f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i1 \\<in> set_pmf (K x) \\<Longrightarrow>\n  distr (K.T ?i1) (stream_space (count_space UNIV)) (smap f) =\n  distr (K.T (g (f ?i1))) (stream_space (count_space UNIV)) (smap f)\n\ngoal (3 subgoals):\n 1. \\<And>xa y.\n       R xa y \\<Longrightarrow>\n       prob_space\n        (distr (K.T xa) (stream_space (count_space UNIV)) (smap f))\n 2. \\<And>xa y.\n       R xa y \\<Longrightarrow>\n       sets (distr (K.T xa) (stream_space (count_space UNIV)) (smap f)) =\n       sets (stream_space (count_space UNIV))\n 3. \\<And>xa y.\n       R xa y \\<Longrightarrow>\n       \\<exists>M'.\n          (\\<forall>y\\<in>set_pmf (L y).\n              \\<exists>x ya.\n                 y = ya \\<and>\n                 M' y =\n                 distr (K.T x) (stream_space (count_space UNIV))\n                  (smap f) \\<and>\n                 R x ya) \\<and>\n          (\\<forall>y.\n              sets (M' y) = sets (stream_space (count_space UNIV)) \\<and>\n              prob_space (M' y)) \\<and>\n          distr (K.T xa) (stream_space (count_space UNIV)) (smap f) =\n          measure_pmf (L y) \\<bind>\n          (\\<lambda>y.\n              distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "have ***: \"?D x = measure_pmf (L y) \\<bind> (\\<lambda>y. distr (?D (g y)) K.S ((##) y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distr (K.T x) (stream_space (count_space UNIV)) (smap f) =\n    measure_pmf (L y) \\<bind>\n    (\\<lambda>y.\n        distr (distr (K.T (g y)) (stream_space (count_space UNIV)) (smap f))\n         (stream_space (count_space UNIV)) ((##) y))", "apply (subst K.T_eq_bind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distr\n     (measure_pmf (K x) \\<bind>\n      (\\<lambda>t.\n          distr (K.T t) (stream_space (count_space UNIV)) ((##) t)))\n     (stream_space (count_space UNIV)) (smap f) =\n    measure_pmf (L y) \\<bind>\n    (\\<lambda>y.\n        distr (distr (K.T (g y)) (stream_space (count_space UNIV)) (smap f))\n         (stream_space (count_space UNIV)) ((##) y))", "apply (subst distr_bind[of _ _ K.S])"], ["proof (prove)\ngoal (4 subgoals):\n 1. measure_pmf.random_variable (K x)\n     (subprob_algebra (stream_space (count_space UNIV)))\n     (\\<lambda>t. distr (K.T t) (stream_space (count_space UNIV)) ((##) t))\n 2. space (measure_pmf (K x)) \\<noteq> {}\n 3. smap f\n    \\<in> stream_space (count_space UNIV) \\<rightarrow>\\<^sub>M\n          stream_space (count_space UNIV)\n 4. measure_pmf (K x) \\<bind>\n    (\\<lambda>x.\n        distr (distr (K.T x) (stream_space (count_space UNIV)) ((##) x))\n         (stream_space (count_space UNIV)) (smap f)) =\n    measure_pmf (L y) \\<bind>\n    (\\<lambda>y.\n        distr (distr (K.T (g y)) (stream_space (count_space UNIV)) (smap f))\n         (stream_space (count_space UNIV)) ((##) y))", "apply (rule measurable_distr2[of _  _ \"K.S\"])"], ["proof (prove)\ngoal (5 subgoals):\n 1. (\\<lambda>(x, y). x ## y)\n    \\<in> measure_pmf (K x) \\<Otimes>\\<^sub>M\n          stream_space (count_space UNIV) \\<rightarrow>\\<^sub>M\n          stream_space (count_space UNIV)\n 2. measure_pmf.random_variable (K x)\n     (subprob_algebra (stream_space (count_space UNIV))) K.T\n 3. space (measure_pmf (K x)) \\<noteq> {}\n 4. smap f\n    \\<in> stream_space (count_space UNIV) \\<rightarrow>\\<^sub>M\n          stream_space (count_space UNIV)\n 5. measure_pmf (K x) \\<bind>\n    (\\<lambda>x.\n        distr (distr (K.T x) (stream_space (count_space UNIV)) ((##) x))\n         (stream_space (count_space UNIV)) (smap f)) =\n    measure_pmf (L y) \\<bind>\n    (\\<lambda>y.\n        distr (distr (K.T (g y)) (stream_space (count_space UNIV)) (smap f))\n         (stream_space (count_space UNIV)) ((##) y))", "apply (simp_all add: Pi_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf (K x) \\<bind>\n    (\\<lambda>x.\n        distr (distr (K.T x) (stream_space (count_space UNIV)) ((##) x))\n         (stream_space (count_space UNIV)) (smap f)) =\n    measure_pmf (L y) \\<bind>\n    (\\<lambda>y.\n        distr (distr (K.T (g y)) (stream_space (count_space UNIV)) (smap f))\n         (stream_space (count_space UNIV)) ((##) y))", "apply (simp add: distr_distr comp_def L_eq[OF cont] map_pmf_rep_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf (K x) \\<bind>\n    (\\<lambda>x.\n        distr (K.T x) (stream_space (count_space UNIV))\n         (\\<lambda>xa. f x ## smap f xa)) =\n    distr (measure_pmf (K x)) (count_space UNIV) f \\<bind>\n    (\\<lambda>y.\n        distr (K.T (g y)) (stream_space (count_space UNIV))\n         (\\<lambda>x. y ## smap f x))", "apply (subst bind_distr[where K=K.S])"], ["proof (prove)\ngoal (4 subgoals):\n 1. measure_pmf.random_variable (K x) (count_space UNIV) f\n 2. (\\<lambda>y.\n        distr (K.T (g y)) (stream_space (count_space UNIV))\n         (\\<lambda>x. y ## smap f x))\n    \\<in> count_space UNIV \\<rightarrow>\\<^sub>M\n          subprob_algebra (stream_space (count_space UNIV))\n 3. space (measure_pmf (K x)) \\<noteq> {}\n 4. measure_pmf (K x) \\<bind>\n    (\\<lambda>x.\n        distr (K.T x) (stream_space (count_space UNIV))\n         (\\<lambda>xa. f x ## smap f xa)) =\n    measure_pmf (K x) \\<bind>\n    (\\<lambda>x.\n        distr (K.T (g (f x))) (stream_space (count_space UNIV))\n         (\\<lambda>xa. f x ## smap f xa))", "apply measurable []"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<lambda>y.\n        distr (K.T (g y)) (stream_space (count_space UNIV))\n         (\\<lambda>x. y ## smap f x))\n    \\<in> count_space UNIV \\<rightarrow>\\<^sub>M\n          subprob_algebra (stream_space (count_space UNIV))\n 2. space (measure_pmf (K x)) \\<noteq> {}\n 3. measure_pmf (K x) \\<bind>\n    (\\<lambda>x.\n        distr (K.T x) (stream_space (count_space UNIV))\n         (\\<lambda>xa. f x ## smap f xa)) =\n    measure_pmf (K x) \\<bind>\n    (\\<lambda>x.\n        distr (K.T (g (f x))) (stream_space (count_space UNIV))\n         (\\<lambda>xa. f x ## smap f xa))", "apply (rule measurable_distr2[of _  _ \"K.S\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. (\\<lambda>(xa, x). xa ## smap f x)\n    \\<in> count_space UNIV \\<Otimes>\\<^sub>M\n          stream_space (count_space UNIV) \\<rightarrow>\\<^sub>M\n          stream_space (count_space UNIV)\n 2. (\\<lambda>x. K.T (g x))\n    \\<in> count_space UNIV \\<rightarrow>\\<^sub>M\n          subprob_algebra (stream_space (count_space UNIV))\n 3. space (measure_pmf (K x)) \\<noteq> {}\n 4. measure_pmf (K x) \\<bind>\n    (\\<lambda>x.\n        distr (K.T x) (stream_space (count_space UNIV))\n         (\\<lambda>xa. f x ## smap f xa)) =\n    measure_pmf (K x) \\<bind>\n    (\\<lambda>x.\n        distr (K.T (g (f x))) (stream_space (count_space UNIV))\n         (\\<lambda>xa. f x ## smap f xa))", "apply measurable []"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<lambda>x. K.T (g x))\n    \\<in> count_space UNIV \\<rightarrow>\\<^sub>M\n          subprob_algebra (stream_space (count_space UNIV))\n 2. space (measure_pmf (K x)) \\<noteq> {}\n 3. measure_pmf (K x) \\<bind>\n    (\\<lambda>x.\n        distr (K.T x) (stream_space (count_space UNIV))\n         (\\<lambda>xa. f x ## smap f xa)) =\n    measure_pmf (K x) \\<bind>\n    (\\<lambda>x.\n        distr (K.T (g (f x))) (stream_space (count_space UNIV))\n         (\\<lambda>xa. f x ## smap f xa))", "apply (rule measurable_compose[OF measurable_g])"], ["proof (prove)\ngoal (3 subgoals):\n 1. K.T\n    \\<in> count_space UNIV \\<rightarrow>\\<^sub>M\n          subprob_algebra (stream_space (count_space UNIV))\n 2. space (measure_pmf (K x)) \\<noteq> {}\n 3. measure_pmf (K x) \\<bind>\n    (\\<lambda>x.\n        distr (K.T x) (stream_space (count_space UNIV))\n         (\\<lambda>xa. f x ## smap f xa)) =\n    measure_pmf (K x) \\<bind>\n    (\\<lambda>x.\n        distr (K.T (g (f x))) (stream_space (count_space UNIV))\n         (\\<lambda>xa. f x ## smap f xa))", "apply measurable []"], ["proof (prove)\ngoal (2 subgoals):\n 1. space (measure_pmf (K x)) \\<noteq> {}\n 2. measure_pmf (K x) \\<bind>\n    (\\<lambda>x.\n        distr (K.T x) (stream_space (count_space UNIV))\n         (\\<lambda>xa. f x ## smap f xa)) =\n    measure_pmf (K x) \\<bind>\n    (\\<lambda>x.\n        distr (K.T (g (f x))) (stream_space (count_space UNIV))\n         (\\<lambda>xa. f x ## smap f xa))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf (K x) \\<bind>\n    (\\<lambda>x.\n        distr (K.T x) (stream_space (count_space UNIV))\n         (\\<lambda>xa. f x ## smap f xa)) =\n    measure_pmf (K x) \\<bind>\n    (\\<lambda>x.\n        distr (K.T (g (f x))) (stream_space (count_space UNIV))\n         (\\<lambda>xa. f x ## smap f xa))", "apply (rule bind_measure_pmf_cong[where N=\"K.S\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       distr (K.T x) (stream_space (count_space UNIV))\n        (\\<lambda>xa. f x ## smap f xa)\n       \\<in> space (subprob_algebra (stream_space (count_space UNIV)))\n 2. \\<And>x.\n       distr (K.T (g (f x))) (stream_space (count_space UNIV))\n        (\\<lambda>xa. f x ## smap f xa)\n       \\<in> space (subprob_algebra (stream_space (count_space UNIV)))\n 3. \\<And>i.\n       i \\<in> set_pmf (K x) \\<Longrightarrow>\n       distr (K.T i) (stream_space (count_space UNIV))\n        (\\<lambda>x. f i ## smap f x) =\n       distr (K.T (g (f i))) (stream_space (count_space UNIV))\n        (\\<lambda>x. f i ## smap f x)", "apply (auto simp: space_subprob_algebra space_stream_space intro!: K.T.subprob_space_distr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> set_pmf (K x) \\<Longrightarrow>\n       distr (K.T i) (stream_space (count_space UNIV))\n        (\\<lambda>x. f i ## smap f x) =\n       distr (K.T (g (f i))) (stream_space (count_space UNIV))\n        (\\<lambda>x. f i ## smap f x)", "unfolding D_SCons_eq_D_D D_eq_D_gi"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> set_pmf (K x) \\<Longrightarrow>\n       distr\n        (distr (K.T (g (f i))) (stream_space (count_space UNIV)) (smap f))\n        (stream_space (count_space UNIV)) ((##) (f i)) =\n       distr\n        (distr (K.T (g (f i))) (stream_space (count_space UNIV)) (smap f))\n        (stream_space (count_space UNIV)) ((##) (f i))", ".."], ["proof (state)\nthis:\n  distr (K.T x) (stream_space (count_space UNIV)) (smap f) =\n  measure_pmf (L y) \\<bind>\n  (\\<lambda>y.\n      distr (distr (K.T (g y)) (stream_space (count_space UNIV)) (smap f))\n       (stream_space (count_space UNIV)) ((##) y))\n\ngoal (3 subgoals):\n 1. \\<And>xa y.\n       R xa y \\<Longrightarrow>\n       prob_space\n        (distr (K.T xa) (stream_space (count_space UNIV)) (smap f))\n 2. \\<And>xa y.\n       R xa y \\<Longrightarrow>\n       sets (distr (K.T xa) (stream_space (count_space UNIV)) (smap f)) =\n       sets (stream_space (count_space UNIV))\n 3. \\<And>xa y.\n       R xa y \\<Longrightarrow>\n       \\<exists>M'.\n          (\\<forall>y\\<in>set_pmf (L y).\n              \\<exists>x ya.\n                 y = ya \\<and>\n                 M' y =\n                 distr (K.T x) (stream_space (count_space UNIV))\n                  (smap f) \\<and>\n                 R x ya) \\<and>\n          (\\<forall>y.\n              sets (M' y) = sets (stream_space (count_space UNIV)) \\<and>\n              prob_space (M' y)) \\<and>\n          distr (K.T xa) (stream_space (count_space UNIV)) (smap f) =\n          measure_pmf (L y) \\<bind>\n          (\\<lambda>y.\n              distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>M'.\n       (\\<forall>y\\<in>set_pmf (L y).\n           \\<exists>x ya.\n              y = ya \\<and>\n              M' y =\n              distr (K.T x) (stream_space (count_space UNIV))\n               (smap f) \\<and>\n              R x ya) \\<and>\n       (\\<forall>y.\n           sets (M' y) = sets (stream_space (count_space UNIV)) \\<and>\n           prob_space (M' y)) \\<and>\n       distr (K.T x) (stream_space (count_space UNIV)) (smap f) =\n       measure_pmf (L y) \\<bind>\n       (\\<lambda>y. distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "by (intro exI[of _ \"\\<lambda>t. distr (K.T (g t)) (stream_space (count_space UNIV)) (smap f)\"])\n         (auto simp add: K.T.prob_space_distr *** dest: **)"], ["proof (state)\nthis:\n  \\<exists>M'.\n     (\\<forall>y\\<in>set_pmf (L y).\n         \\<exists>x ya.\n            y = ya \\<and>\n            M' y =\n            distr (K.T x) (stream_space (count_space UNIV)) (smap f) \\<and>\n            R x ya) \\<and>\n     (\\<forall>y.\n         sets (M' y) = sets (stream_space (count_space UNIV)) \\<and>\n         prob_space (M' y)) \\<and>\n     distr (K.T x) (stream_space (count_space UNIV)) (smap f) =\n     measure_pmf (L y) \\<bind>\n     (\\<lambda>y. distr (M' y) (stream_space (count_space UNIV)) ((##) y))\n\ngoal (2 subgoals):\n 1. \\<And>xa y.\n       R xa y \\<Longrightarrow>\n       prob_space\n        (distr (K.T xa) (stream_space (count_space UNIV)) (smap f))\n 2. \\<And>xa y.\n       R xa y \\<Longrightarrow>\n       sets (distr (K.T xa) (stream_space (count_space UNIV)) (smap f)) =\n       sets (stream_space (count_space UNIV))", "qed (auto intro: K.T.prob_space_distr)"], ["proof (state)\nthis:\n  L.T y = distr (K.T x) (stream_space (count_space UNIV)) (smap f)\n\ngoal (1 subgoal):\n 1. emeasure (K.T x) A = emeasure (L.T y) B", "have \"stream_all2 R s t \\<longleftrightarrow> (s \\<in> streams S \\<and> smap f s = t)\" for s t"], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_all2 R s t = (s \\<in> streams S \\<and> smap f s = t)", "proof safe"], ["proof (state)\ngoal (3 subgoals):\n 1. stream_all2 R s t \\<Longrightarrow> s \\<in> streams S\n 2. stream_all2 R s t \\<Longrightarrow> smap f s = t\n 3. \\<lbrakk>s \\<in> streams S; t = smap f s\\<rbrakk>\n    \\<Longrightarrow> stream_all2 (\\<lambda>x y. R x (f y)) s s", "show \"stream_all2 R s t \\<Longrightarrow> s \\<in> streams S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_all2 R s t \\<Longrightarrow> s \\<in> streams S", "apply (coinduction arbitrary: s t)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       stream_all2 R s t \\<Longrightarrow>\n       \\<exists>a sa.\n          s = a ## sa \\<and>\n          a \\<in> S \\<and>\n          ((\\<exists>s t. sa = s \\<and> stream_all2 R s t) \\<or>\n           sa \\<in> streams S)", "subgoal for s t"], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_all2 R s t \\<Longrightarrow>\n    \\<exists>a s.\n       s = a ## s \\<and>\n       a \\<in> S \\<and>\n       ((\\<exists>sa t. s = sa \\<and> stream_all2 R sa t) \\<or>\n        s \\<in> streams S)", "by (cases s; cases t) (auto simp: R_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  stream_all2 R s t \\<Longrightarrow> s \\<in> streams S\n\ngoal (2 subgoals):\n 1. stream_all2 R s t \\<Longrightarrow> smap f s = t\n 2. \\<lbrakk>s \\<in> streams S; t = smap f s\\<rbrakk>\n    \\<Longrightarrow> stream_all2 (\\<lambda>x y. R x (f y)) s s", "show \"stream_all2 R s t \\<Longrightarrow> smap f s = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_all2 R s t \\<Longrightarrow> smap f s = t", "apply (coinduction arbitrary: s t rule: stream.coinduct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       stream_all2 R s t \\<Longrightarrow>\n       shd (smap f s) = shd t \\<and>\n       (\\<exists>sa ta.\n           stl (smap f s) = smap f sa \\<and>\n           stl t = ta \\<and> stream_all2 R sa ta)", "subgoal for s t"], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_all2 R s t \\<Longrightarrow>\n    shd (smap f s) = shd t \\<and>\n    (\\<exists>s t.\n        stl (smap f s) = smap f s \\<and> stl t = t \\<and> stream_all2 R s t)", "by (cases s; cases t) (auto simp: R_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  stream_all2 R s t \\<Longrightarrow> smap f s = t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> streams S; t = smap f s\\<rbrakk>\n    \\<Longrightarrow> stream_all2 (\\<lambda>x y. R x (f y)) s s", "qed (auto intro!: stream.rel_refl_strong simp: stream.rel_map R_def streams_iff_sset)"], ["proof (state)\nthis:\n  stream_all2 R ?s1 ?t1 = (?s1 \\<in> streams S \\<and> smap f ?s1 = ?t1)\n\ngoal (1 subgoal):\n 1. emeasure (K.T x) A = emeasure (L.T y) B", "then"], ["proof (chain)\npicking this:\n  stream_all2 R ?s1 ?t1 = (?s1 \\<in> streams S \\<and> smap f ?s1 = ?t1)", "have \"\\<omega> \\<in> streams S \\<Longrightarrow> \\<omega> \\<in> A \\<longleftrightarrow> smap f \\<omega> \\<in> B\" for \\<omega>"], ["proof (prove)\nusing this:\n  stream_all2 R ?s1 ?t1 = (?s1 \\<in> streams S \\<and> smap f ?s1 = ?t1)\n\ngoal (1 subgoal):\n 1. \\<omega> \\<in> streams S \\<Longrightarrow>\n    (\\<omega> \\<in> A) = (smap f \\<omega> \\<in> B)", "using AB"], ["proof (prove)\nusing this:\n  stream_all2 R ?s1 ?t1 = (?s1 \\<in> streams S \\<and> smap f ?s1 = ?t1)\n  PTA.rel_set_strong (stream_all2 R) A B\n\ngoal (1 subgoal):\n 1. \\<omega> \\<in> streams S \\<Longrightarrow>\n    (\\<omega> \\<in> A) = (smap f \\<omega> \\<in> B)", "by (auto simp: rel_set_strong_def)"], ["proof (state)\nthis:\n  ?\\<omega>1 \\<in> streams S \\<Longrightarrow>\n  (?\\<omega>1 \\<in> A) = (smap f ?\\<omega>1 \\<in> B)\n\ngoal (1 subgoal):\n 1. emeasure (K.T x) A = emeasure (L.T y) B", "with in_S"], ["proof (chain)\npicking this:\n  AE \\<omega> in K.T x. \\<omega> \\<in> streams S\n  ?\\<omega>1 \\<in> streams S \\<Longrightarrow>\n  (?\\<omega>1 \\<in> A) = (smap f ?\\<omega>1 \\<in> B)", "have \"K.T x A = K.T x (smap f -` B \\<inter> space (K.T x))\""], ["proof (prove)\nusing this:\n  AE \\<omega> in K.T x. \\<omega> \\<in> streams S\n  ?\\<omega>1 \\<in> streams S \\<Longrightarrow>\n  (?\\<omega>1 \\<in> A) = (smap f ?\\<omega>1 \\<in> B)\n\ngoal (1 subgoal):\n 1. emeasure (K.T x) A =\n    emeasure (K.T x) (smap f -` B \\<inter> space (K.T x))", "by (auto intro!: emeasure_eq_AE streams_sets)"], ["proof (state)\nthis:\n  emeasure (K.T x) A = emeasure (K.T x) (smap f -` B \\<inter> space (K.T x))\n\ngoal (1 subgoal):\n 1. emeasure (K.T x) A = emeasure (L.T y) B", "also"], ["proof (state)\nthis:\n  emeasure (K.T x) A = emeasure (K.T x) (smap f -` B \\<inter> space (K.T x))\n\ngoal (1 subgoal):\n 1. emeasure (K.T x) A = emeasure (L.T y) B", "have \"\\<dots> = (distr (K.T x) K.S (smap f)) B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (K.T x) (smap f -` B \\<inter> space (K.T x)) =\n    emeasure (distr (K.T x) (stream_space (count_space UNIV)) (smap f)) B", "by (intro emeasure_distr[symmetric]) auto"], ["proof (state)\nthis:\n  emeasure (K.T x) (smap f -` B \\<inter> space (K.T x)) =\n  emeasure (distr (K.T x) (stream_space (count_space UNIV)) (smap f)) B\n\ngoal (1 subgoal):\n 1. emeasure (K.T x) A = emeasure (L.T y) B", "also"], ["proof (state)\nthis:\n  emeasure (K.T x) (smap f -` B \\<inter> space (K.T x)) =\n  emeasure (distr (K.T x) (stream_space (count_space UNIV)) (smap f)) B\n\ngoal (1 subgoal):\n 1. emeasure (K.T x) A = emeasure (L.T y) B", "have \"\\<dots> = (L.T y) B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (distr (K.T x) (stream_space (count_space UNIV)) (smap f)) B =\n    emeasure (L.T y) B", "unfolding L_eq_D"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (distr (K.T x) (stream_space (count_space UNIV)) (smap f)) B =\n    emeasure (distr (K.T x) (stream_space (count_space UNIV)) (smap f)) B", ".."], ["proof (state)\nthis:\n  emeasure (distr (K.T x) (stream_space (count_space UNIV)) (smap f)) B =\n  emeasure (L.T y) B\n\ngoal (1 subgoal):\n 1. emeasure (K.T x) A = emeasure (L.T y) B", "finally"], ["proof (chain)\npicking this:\n  emeasure (K.T x) A = emeasure (L.T y) B", "show ?thesis"], ["proof (prove)\nusing this:\n  emeasure (K.T x) A = emeasure (L.T y) B\n\ngoal (1 subgoal):\n 1. emeasure (K.T x) A = emeasure (L.T y) B", "."], ["proof (state)\nthis:\n  emeasure (K.T x) A = emeasure (L.T y) B\n\ngoal:\nNo subgoals!", "qed"], ["", "no_notation ccval (\"\\<lbrace>_\\<rbrace>\" [100])"], ["", "hide_const succ"], ["", "section \\<open>Additional Facts on Regions\\<close>"], ["", "(* XXX Move this to a theory on Timed Automata *)"], ["", "declare reset_set11[simp] reset_set1[simp]"], ["", "text \\<open>\n  Defining the closest successor of a region. Only exists if at least one interval is upper-bounded.\n\\<close>"], ["", "abbreviation is_upper_right where\n  \"is_upper_right R \\<equiv> (\\<forall> t \\<ge> 0. \\<forall> u \\<in> R. u \\<oplus> t \\<in> R)\""], ["", "(* XXX Remove old successor definition *)"], ["", "definition\n  \"succ \\<R> R \\<equiv>\n  if is_upper_right R then R else\n  (THE R'. R' \\<noteq> R \\<and> R' \\<in> Succ \\<R> R \\<and> (\\<forall> u \\<in> R. \\<forall> t \\<ge> 0. (u \\<oplus> t) \\<notin> R \\<longrightarrow> (\\<exists> t' \\<le> t. (u \\<oplus> t') \\<in> R' \\<and> 0 \\<le> t')))\""], ["", "lemma region_continuous:\n  assumes \"valid_region X k I r\"\n  defines R: \"R \\<equiv> region X I r\"\n  assumes between: \"0 \\<le> t1\" \"t1 \\<le> t2\"\n  assumes elem: \"u \\<in> R\" \"u \\<oplus> t2 \\<in> R\"\n  shows \"u \\<oplus> t1 \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<oplus> t1 \\<in> R", "unfolding R"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<oplus> t1 \\<in> Regions.region X I r", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<forall>x\\<in>X. 0 \\<le> (u \\<oplus> t1) x\n 2. \\<forall>x\\<in>X. Regions.intv_elem x (u \\<oplus> t1) (I x)\n 3. ?X\\<^sub>0 = {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n 4. \\<forall>x\\<in>?X\\<^sub>0.\n       \\<forall>y\\<in>?X\\<^sub>0.\n          ((x, y) \\<in> r) =\n          (frac ((u \\<oplus> t1) x) \\<le> frac ((u \\<oplus> t1) y))", "from \\<open>0 \\<le> t1\\<close> \\<open>u \\<in> R\\<close>"], ["proof (chain)\npicking this:\n  0 \\<le> t1\n  u \\<in> R", "show \"\\<forall>x\\<in>X. 0 \\<le> (u \\<oplus> t1) x\""], ["proof (prove)\nusing this:\n  0 \\<le> t1\n  u \\<in> R\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>X. 0 \\<le> (u \\<oplus> t1) x", "by (auto simp: R cval_add_def)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>X. 0 \\<le> (u \\<oplus> t1) x\n\ngoal (3 subgoals):\n 1. \\<forall>x\\<in>X. Regions.intv_elem x (u \\<oplus> t1) (I x)\n 2. ?X\\<^sub>0 = {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n 3. \\<forall>x\\<in>?X\\<^sub>0.\n       \\<forall>y\\<in>?X\\<^sub>0.\n          ((x, y) \\<in> r) =\n          (frac ((u \\<oplus> t1) x) \\<le> frac ((u \\<oplus> t1) y))", "have \"intv_elem x (u \\<oplus> t1) (I x)\" if \"x \\<in> X\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. Regions.intv_elem x (u \\<oplus> t1) (I x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Regions.intv_elem x (u \\<oplus> t1) (I x)", "from elem that"], ["proof (chain)\npicking this:\n  u \\<in> R\n  u \\<oplus> t2 \\<in> R\n  x \\<in> X", "have \"intv_elem x u (I x)\" \"intv_elem x (u \\<oplus> t2) (I x)\""], ["proof (prove)\nusing this:\n  u \\<in> R\n  u \\<oplus> t2 \\<in> R\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. Regions.intv_elem x u (I x) &&&\n    Regions.intv_elem x (u \\<oplus> t2) (I x)", "by (auto simp: R)"], ["proof (state)\nthis:\n  Regions.intv_elem x u (I x)\n  Regions.intv_elem x (u \\<oplus> t2) (I x)\n\ngoal (1 subgoal):\n 1. Regions.intv_elem x (u \\<oplus> t1) (I x)", "with between"], ["proof (chain)\npicking this:\n  0 \\<le> t1\n  t1 \\<le> t2\n  Regions.intv_elem x u (I x)\n  Regions.intv_elem x (u \\<oplus> t2) (I x)", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> t1\n  t1 \\<le> t2\n  Regions.intv_elem x u (I x)\n  Regions.intv_elem x (u \\<oplus> t2) (I x)\n\ngoal (1 subgoal):\n 1. Regions.intv_elem x (u \\<oplus> t1) (I x)", "by (cases \"I x\", auto simp: cval_add_def)"], ["proof (state)\nthis:\n  Regions.intv_elem x (u \\<oplus> t1) (I x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> X \\<Longrightarrow> Regions.intv_elem ?x (u \\<oplus> t1) (I ?x)\n\ngoal (3 subgoals):\n 1. \\<forall>x\\<in>X. Regions.intv_elem x (u \\<oplus> t1) (I x)\n 2. ?X\\<^sub>0 = {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n 3. \\<forall>x\\<in>?X\\<^sub>0.\n       \\<forall>y\\<in>?X\\<^sub>0.\n          ((x, y) \\<in> r) =\n          (frac ((u \\<oplus> t1) x) \\<le> frac ((u \\<oplus> t1) y))", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> X \\<Longrightarrow> Regions.intv_elem ?x (u \\<oplus> t1) (I ?x)", "show \"\\<forall> x \\<in> X. intv_elem x (u \\<oplus> t1) (I x)\""], ["proof (prove)\nusing this:\n  ?x \\<in> X \\<Longrightarrow> Regions.intv_elem ?x (u \\<oplus> t1) (I ?x)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>X. Regions.intv_elem x (u \\<oplus> t1) (I x)", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>X. Regions.intv_elem x (u \\<oplus> t1) (I x)\n\ngoal (2 subgoals):\n 1. ?X\\<^sub>0 = {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n 2. \\<forall>x\\<in>?X\\<^sub>0.\n       \\<forall>y\\<in>?X\\<^sub>0.\n          ((x, y) \\<in> r) =\n          (frac ((u \\<oplus> t1) x) \\<le> frac ((u \\<oplus> t1) y))", "let ?X\\<^sub>0 = \"{x \\<in> X. \\<exists>d. I x = Intv d}\""], ["proof (state)\ngoal (2 subgoals):\n 1. ?X\\<^sub>0 = {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n 2. \\<forall>x\\<in>?X\\<^sub>0.\n       \\<forall>y\\<in>?X\\<^sub>0.\n          ((x, y) \\<in> r) =\n          (frac ((u \\<oplus> t1) x) \\<le> frac ((u \\<oplus> t1) y))", "show \"?X\\<^sub>0 = ?X\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d} =\n    {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}", ".."], ["proof (state)\nthis:\n  {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d} =\n  {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n       \\<forall>y\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n          ((x, y) \\<in> r) =\n          (frac ((u \\<oplus> t1) x) \\<le> frac ((u \\<oplus> t1) y))", "from elem"], ["proof (chain)\npicking this:\n  u \\<in> R\n  u \\<oplus> t2 \\<in> R", "have \"\\<forall> x \\<in> ?X\\<^sub>0. \\<forall> y \\<in> ?X\\<^sub>0. (x, y) \\<in> r \\<longleftrightarrow> frac (u x) \\<le> frac (u y)\""], ["proof (prove)\nusing this:\n  u \\<in> R\n  u \\<oplus> t2 \\<in> R\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n       \\<forall>y\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n          ((x, y) \\<in> r) = (frac (u x) \\<le> frac (u y))", "by (auto simp: R)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n     \\<forall>y\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n        ((x, y) \\<in> r) = (frac (u x) \\<le> frac (u y))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n       \\<forall>y\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n          ((x, y) \\<in> r) =\n          (frac ((u \\<oplus> t1) x) \\<le> frac ((u \\<oplus> t1) y))", "moreover"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n     \\<forall>y\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n        ((x, y) \\<in> r) = (frac (u x) \\<le> frac (u y))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n       \\<forall>y\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n          ((x, y) \\<in> r) =\n          (frac ((u \\<oplus> t1) x) \\<le> frac ((u \\<oplus> t1) y))", "{"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n     \\<forall>y\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n        ((x, y) \\<in> r) = (frac (u x) \\<le> frac (u y))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n       \\<forall>y\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n          ((x, y) \\<in> r) =\n          (frac ((u \\<oplus> t1) x) \\<le> frac ((u \\<oplus> t1) y))", "fix x y c d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n       \\<forall>y\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n          ((x, y) \\<in> r) =\n          (frac ((u \\<oplus> t1) x) \\<le> frac ((u \\<oplus> t1) y))", "assume A: \"x \\<in> X\" \"y \\<in> X\" \"I x = Intv c\" \"I y = Intv d\""], ["proof (state)\nthis:\n  x \\<in> X\n  y \\<in> X\n  I x = Regions.intv.Intv c\n  I y = Regions.intv.Intv d\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n       \\<forall>y\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n          ((x, y) \\<in> r) =\n          (frac ((u \\<oplus> t1) x) \\<le> frac ((u \\<oplus> t1) y))", "from A elem between"], ["proof (chain)\npicking this:\n  x \\<in> X\n  y \\<in> X\n  I x = Regions.intv.Intv c\n  I y = Regions.intv.Intv d\n  u \\<in> R\n  u \\<oplus> t2 \\<in> R\n  0 \\<le> t1\n  t1 \\<le> t2", "have *:\n      \"c < u x\" \"u x < c + 1\" \"c < u x + t1\" \"u x + t1 < c + 1\""], ["proof (prove)\nusing this:\n  x \\<in> X\n  y \\<in> X\n  I x = Regions.intv.Intv c\n  I y = Regions.intv.Intv d\n  u \\<in> R\n  u \\<oplus> t2 \\<in> R\n  0 \\<le> t1\n  t1 \\<le> t2\n\ngoal (1 subgoal):\n 1. (real c < u x &&& u x < real (c + 1)) &&&\n    real c < u x + t1 &&& u x + t1 < real (c + 1)", "by (fastforce simp: cval_add_def R)+"], ["proof (state)\nthis:\n  real c < u x\n  u x < real (c + 1)\n  real c < u x + t1\n  u x + t1 < real (c + 1)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n       \\<forall>y\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n          ((x, y) \\<in> r) =\n          (frac ((u \\<oplus> t1) x) \\<le> frac ((u \\<oplus> t1) y))", "moreover"], ["proof (state)\nthis:\n  real c < u x\n  u x < real (c + 1)\n  real c < u x + t1\n  u x + t1 < real (c + 1)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n       \\<forall>y\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n          ((x, y) \\<in> r) =\n          (frac ((u \\<oplus> t1) x) \\<le> frac ((u \\<oplus> t1) y))", "from A(2,4) elem between"], ["proof (chain)\npicking this:\n  y \\<in> X\n  I y = Regions.intv.Intv d\n  u \\<in> R\n  u \\<oplus> t2 \\<in> R\n  0 \\<le> t1\n  t1 \\<le> t2", "have **:\n      \"d < u y\" \"u y < d + 1\" \"d < u y + t1\" \"u y + t1 < d + 1\""], ["proof (prove)\nusing this:\n  y \\<in> X\n  I y = Regions.intv.Intv d\n  u \\<in> R\n  u \\<oplus> t2 \\<in> R\n  0 \\<le> t1\n  t1 \\<le> t2\n\ngoal (1 subgoal):\n 1. (real d < u y &&& u y < real (d + 1)) &&&\n    real d < u y + t1 &&& u y + t1 < real (d + 1)", "by (fastforce simp: cval_add_def R)+"], ["proof (state)\nthis:\n  real d < u y\n  u y < real (d + 1)\n  real d < u y + t1\n  u y + t1 < real (d + 1)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n       \\<forall>y\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n          ((x, y) \\<in> r) =\n          (frac ((u \\<oplus> t1) x) \\<le> frac ((u \\<oplus> t1) y))", "ultimately"], ["proof (chain)\npicking this:\n  real c < u x\n  u x < real (c + 1)\n  real c < u x + t1\n  u x + t1 < real (c + 1)\n  real d < u y\n  u y < real (d + 1)\n  real d < u y + t1\n  u y + t1 < real (d + 1)", "have \"u x = c + frac (u x)\" \"u y = d + frac (u y)\""], ["proof (prove)\nusing this:\n  real c < u x\n  u x < real (c + 1)\n  real c < u x + t1\n  u x + t1 < real (c + 1)\n  real d < u y\n  u y < real (d + 1)\n  real d < u y + t1\n  u y + t1 < real (d + 1)\n\ngoal (1 subgoal):\n 1. u x = real c + frac (u x) &&& u y = real d + frac (u y)", "using nat_intv_frac_decomp"], ["proof (prove)\nusing this:\n  real c < u x\n  u x < real (c + 1)\n  real c < u x + t1\n  u x + t1 < real (c + 1)\n  real d < u y\n  u y < real (d + 1)\n  real d < u y + t1\n  u y + t1 < real (d + 1)\n  \\<lbrakk>real ?c < ?d; ?d < real (?c + 1)\\<rbrakk>\n  \\<Longrightarrow> ?d = real ?c + frac ?d\n\ngoal (1 subgoal):\n 1. u x = real c + frac (u x) &&& u y = real d + frac (u y)", "by auto"], ["proof (state)\nthis:\n  u x = real c + frac (u x)\n  u y = real d + frac (u y)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n       \\<forall>y\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n          ((x, y) \\<in> r) =\n          (frac ((u \\<oplus> t1) x) \\<le> frac ((u \\<oplus> t1) y))", "then"], ["proof (chain)\npicking this:\n  u x = real c + frac (u x)\n  u y = real d + frac (u y)", "have\n      \"frac (u x + t1) = frac (u x) + t1\" \"frac (u y + t1) = frac (u y) + t1\""], ["proof (prove)\nusing this:\n  u x = real c + frac (u x)\n  u y = real d + frac (u y)\n\ngoal (1 subgoal):\n 1. frac (u x + t1) = frac (u x) + t1 &&& frac (u y + t1) = frac (u y) + t1", "using *(3,4) **(3,4) nat_intv_frac_decomp"], ["proof (prove)\nusing this:\n  u x = real c + frac (u x)\n  u y = real d + frac (u y)\n  real c < u x + t1\n  u x + t1 < real (c + 1)\n  real d < u y + t1\n  u y + t1 < real (d + 1)\n  \\<lbrakk>real ?c < ?d; ?d < real (?c + 1)\\<rbrakk>\n  \\<Longrightarrow> ?d = real ?c + frac ?d\n\ngoal (1 subgoal):\n 1. frac (u x + t1) = frac (u x) + t1 &&& frac (u y + t1) = frac (u y) + t1", "by force+"], ["proof (state)\nthis:\n  frac (u x + t1) = frac (u x) + t1\n  frac (u y + t1) = frac (u y) + t1\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n       \\<forall>y\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n          ((x, y) \\<in> r) =\n          (frac ((u \\<oplus> t1) x) \\<le> frac ((u \\<oplus> t1) y))", "then"], ["proof (chain)\npicking this:\n  frac (u x + t1) = frac (u x) + t1\n  frac (u y + t1) = frac (u y) + t1", "have\n      \"frac (u x) \\<le> frac (u y) \\<longleftrightarrow> frac ((u \\<oplus> t1) x) \\<le> frac ((u \\<oplus> t1) y)\""], ["proof (prove)\nusing this:\n  frac (u x + t1) = frac (u x) + t1\n  frac (u y + t1) = frac (u y) + t1\n\ngoal (1 subgoal):\n 1. (frac (u x) \\<le> frac (u y)) =\n    (frac ((u \\<oplus> t1) x) \\<le> frac ((u \\<oplus> t1) y))", "by (auto simp: cval_add_def)"], ["proof (state)\nthis:\n  (frac (u x) \\<le> frac (u y)) =\n  (frac ((u \\<oplus> t1) x) \\<le> frac ((u \\<oplus> t1) y))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n       \\<forall>y\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n          ((x, y) \\<in> r) =\n          (frac ((u \\<oplus> t1) x) \\<le> frac ((u \\<oplus> t1) y))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?x2 \\<in> X; ?y2 \\<in> X; I ?x2 = Regions.intv.Intv ?c2;\n   I ?y2 = Regions.intv.Intv ?d2\\<rbrakk>\n  \\<Longrightarrow> (frac (u ?x2) \\<le> frac (u ?y2)) =\n                    (frac ((u \\<oplus> t1) ?x2)\n                     \\<le> frac ((u \\<oplus> t1) ?y2))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n       \\<forall>y\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n          ((x, y) \\<in> r) =\n          (frac ((u \\<oplus> t1) x) \\<le> frac ((u \\<oplus> t1) y))", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n     \\<forall>y\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n        ((x, y) \\<in> r) = (frac (u x) \\<le> frac (u y))\n  \\<lbrakk>?x2 \\<in> X; ?y2 \\<in> X; I ?x2 = Regions.intv.Intv ?c2;\n   I ?y2 = Regions.intv.Intv ?d2\\<rbrakk>\n  \\<Longrightarrow> (frac (u ?x2) \\<le> frac (u ?y2)) =\n                    (frac ((u \\<oplus> t1) ?x2)\n                     \\<le> frac ((u \\<oplus> t1) ?y2))", "show\n    \"\\<forall> x \\<in> ?X\\<^sub>0. \\<forall> y \\<in> ?X\\<^sub>0. (x, y) \\<in> r \\<longleftrightarrow> frac ((u \\<oplus> t1) x) \\<le> frac ((u \\<oplus> t1) y)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n     \\<forall>y\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n        ((x, y) \\<in> r) = (frac (u x) \\<le> frac (u y))\n  \\<lbrakk>?x2 \\<in> X; ?y2 \\<in> X; I ?x2 = Regions.intv.Intv ?c2;\n   I ?y2 = Regions.intv.Intv ?d2\\<rbrakk>\n  \\<Longrightarrow> (frac (u ?x2) \\<le> frac (u ?y2)) =\n                    (frac ((u \\<oplus> t1) ?x2)\n                     \\<le> frac ((u \\<oplus> t1) ?y2))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n       \\<forall>y\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n          ((x, y) \\<in> r) =\n          (frac ((u \\<oplus> t1) x) \\<le> frac ((u \\<oplus> t1) y))", "by (auto simp: cval_add_def)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n     \\<forall>y\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n        ((x, y) \\<in> r) =\n        (frac ((u \\<oplus> t1) x) \\<le> frac ((u \\<oplus> t1) y))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma upper_right_eq:\n  assumes \"finite X\" \"valid_region X k I r\"\n  shows \"(\\<forall> x \\<in> X. isGreater (I x)) \\<longleftrightarrow> is_upper_right (region X I r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>X. Regions.isGreater (I x)) =\n    (\\<forall>t\\<ge>0.\n        \\<forall>u\\<in>Regions.region X I r.\n           u \\<oplus> t \\<in> Regions.region X I r)", "using assms"], ["proof (prove)\nusing this:\n  finite X\n  Regions.valid_region X k I r\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>X. Regions.isGreater (I x)) =\n    (\\<forall>t\\<ge>0.\n        \\<forall>u\\<in>Regions.region X I r.\n           u \\<oplus> t \\<in> Regions.region X I r)", "proof (safe, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t u.\n       \\<lbrakk>finite X; Regions.valid_region X k I r;\n        \\<forall>x\\<in>X. Regions.isGreater (I x); 0 \\<le> t;\n        u \\<in> Regions.region X I r\\<rbrakk>\n       \\<Longrightarrow> u \\<oplus> t \\<in> Regions.region X I r\n 2. \\<And>x.\n       \\<lbrakk>finite X; Regions.valid_region X k I r;\n        \\<forall>t\\<ge>0.\n           \\<forall>u\\<in>Regions.region X I r.\n              u \\<oplus> t \\<in> Regions.region X I r;\n        x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> Regions.isGreater (I x)", "case (1 t u)"], ["proof (state)\nthis:\n  finite X\n  Regions.valid_region X k I r\n  \\<forall>x\\<in>X. Regions.isGreater (I x)\n  0 \\<le> t\n  u \\<in> Regions.region X I r\n\ngoal (2 subgoals):\n 1. \\<And>t u.\n       \\<lbrakk>finite X; Regions.valid_region X k I r;\n        \\<forall>x\\<in>X. Regions.isGreater (I x); 0 \\<le> t;\n        u \\<in> Regions.region X I r\\<rbrakk>\n       \\<Longrightarrow> u \\<oplus> t \\<in> Regions.region X I r\n 2. \\<And>x.\n       \\<lbrakk>finite X; Regions.valid_region X k I r;\n        \\<forall>t\\<ge>0.\n           \\<forall>u\\<in>Regions.region X I r.\n              u \\<oplus> t \\<in> Regions.region X I r;\n        x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> Regions.isGreater (I x)", "then"], ["proof (chain)\npicking this:\n  finite X\n  Regions.valid_region X k I r\n  \\<forall>x\\<in>X. Regions.isGreater (I x)\n  0 \\<le> t\n  u \\<in> Regions.region X I r", "show ?case"], ["proof (prove)\nusing this:\n  finite X\n  Regions.valid_region X k I r\n  \\<forall>x\\<in>X. Regions.isGreater (I x)\n  0 \\<le> t\n  u \\<in> Regions.region X I r\n\ngoal (1 subgoal):\n 1. u \\<oplus> t \\<in> Regions.region X I r", "by - (standard, force simp: cval_add_def)+"], ["proof (state)\nthis:\n  u \\<oplus> t \\<in> Regions.region X I r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>finite X; Regions.valid_region X k I r;\n        \\<forall>t\\<ge>0.\n           \\<forall>u\\<in>Regions.region X I r.\n              u \\<oplus> t \\<in> Regions.region X I r;\n        x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> Regions.isGreater (I x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>finite X; Regions.valid_region X k I r;\n        \\<forall>t\\<ge>0.\n           \\<forall>u\\<in>Regions.region X I r.\n              u \\<oplus> t \\<in> Regions.region X I r;\n        x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> Regions.isGreater (I x)", "case (2 x)"], ["proof (state)\nthis:\n  finite X\n  Regions.valid_region X k I r\n  \\<forall>t\\<ge>0.\n     \\<forall>u\\<in>Regions.region X I r.\n        u \\<oplus> t \\<in> Regions.region X I r\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>finite X; Regions.valid_region X k I r;\n        \\<forall>t\\<ge>0.\n           \\<forall>u\\<in>Regions.region X I r.\n              u \\<oplus> t \\<in> Regions.region X I r;\n        x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> Regions.isGreater (I x)", "(* XXX Does this lemma actually need the finiteness assumption? *)"], ["proof (state)\nthis:\n  finite X\n  Regions.valid_region X k I r\n  \\<forall>t\\<ge>0.\n     \\<forall>u\\<in>Regions.region X I r.\n        u \\<oplus> t \\<in> Regions.region X I r\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>finite X; Regions.valid_region X k I r;\n        \\<forall>t\\<ge>0.\n           \\<forall>u\\<in>Regions.region X I r.\n              u \\<oplus> t \\<in> Regions.region X I r;\n        x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> Regions.isGreater (I x)", "from region_not_empty[OF assms]"], ["proof (chain)\npicking this:\n  \\<exists>u. u \\<in> Regions.region X I r", "obtain u where u: \"u \\<in> region X I r\""], ["proof (prove)\nusing this:\n  \\<exists>u. u \\<in> Regions.region X I r\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        u \\<in> Regions.region X I r \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  u \\<in> Regions.region X I r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>finite X; Regions.valid_region X k I r;\n        \\<forall>t\\<ge>0.\n           \\<forall>u\\<in>Regions.region X I r.\n              u \\<oplus> t \\<in> Regions.region X I r;\n        x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> Regions.isGreater (I x)", "moreover"], ["proof (state)\nthis:\n  u \\<in> Regions.region X I r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>finite X; Regions.valid_region X k I r;\n        \\<forall>t\\<ge>0.\n           \\<forall>u\\<in>Regions.region X I r.\n              u \\<oplus> t \\<in> Regions.region X I r;\n        x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> Regions.isGreater (I x)", "have \"(1 :: real) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> 1", "by auto"], ["proof (state)\nthis:\n  0 \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>finite X; Regions.valid_region X k I r;\n        \\<forall>t\\<ge>0.\n           \\<forall>u\\<in>Regions.region X I r.\n              u \\<oplus> t \\<in> Regions.region X I r;\n        x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> Regions.isGreater (I x)", "ultimately"], ["proof (chain)\npicking this:\n  u \\<in> Regions.region X I r\n  0 \\<le> 1", "have \"(u \\<oplus> 1) \\<in> region X I r\""], ["proof (prove)\nusing this:\n  u \\<in> Regions.region X I r\n  0 \\<le> 1\n\ngoal (1 subgoal):\n 1. u \\<oplus> 1 \\<in> Regions.region X I r", "using 2"], ["proof (prove)\nusing this:\n  u \\<in> Regions.region X I r\n  0 \\<le> 1\n  finite X\n  Regions.valid_region X k I r\n  \\<forall>t\\<ge>0.\n     \\<forall>u\\<in>Regions.region X I r.\n        u \\<oplus> t \\<in> Regions.region X I r\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. u \\<oplus> 1 \\<in> Regions.region X I r", "by auto"], ["proof (state)\nthis:\n  u \\<oplus> 1 \\<in> Regions.region X I r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>finite X; Regions.valid_region X k I r;\n        \\<forall>t\\<ge>0.\n           \\<forall>u\\<in>Regions.region X I r.\n              u \\<oplus> t \\<in> Regions.region X I r;\n        x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> Regions.isGreater (I x)", "with \\<open>x \\<in> X\\<close> u"], ["proof (chain)\npicking this:\n  x \\<in> X\n  u \\<in> Regions.region X I r\n  u \\<oplus> 1 \\<in> Regions.region X I r", "have \"intv_elem x u (I x)\" \"intv_elem x (u \\<oplus> 1) (I x)\""], ["proof (prove)\nusing this:\n  x \\<in> X\n  u \\<in> Regions.region X I r\n  u \\<oplus> 1 \\<in> Regions.region X I r\n\ngoal (1 subgoal):\n 1. Regions.intv_elem x u (I x) &&& Regions.intv_elem x (u \\<oplus> 1) (I x)", "by auto"], ["proof (state)\nthis:\n  Regions.intv_elem x u (I x)\n  Regions.intv_elem x (u \\<oplus> 1) (I x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>finite X; Regions.valid_region X k I r;\n        \\<forall>t\\<ge>0.\n           \\<forall>u\\<in>Regions.region X I r.\n              u \\<oplus> t \\<in> Regions.region X I r;\n        x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> Regions.isGreater (I x)", "then"], ["proof (chain)\npicking this:\n  Regions.intv_elem x u (I x)\n  Regions.intv_elem x (u \\<oplus> 1) (I x)", "show ?case"], ["proof (prove)\nusing this:\n  Regions.intv_elem x u (I x)\n  Regions.intv_elem x (u \\<oplus> 1) (I x)\n\ngoal (1 subgoal):\n 1. Regions.isGreater (I x)", "by (cases \"I x\", auto simp: cval_add_def)"], ["proof (state)\nthis:\n  Regions.isGreater (I x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bounded_region:\n  assumes \"finite X\" \"valid_region X k I r\"\n  defines R: \"R \\<equiv> region X I r\"\n  assumes \"\\<not> is_upper_right R\" \"u \\<in> R\"\n  shows \"u \\<oplus> 1 \\<notin> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<oplus> 1 \\<notin> R", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<oplus> 1 \\<notin> R", "from upper_right_eq[OF assms(1,2)] assms(4)"], ["proof (chain)\npicking this:\n  (\\<forall>x\\<in>X. Regions.isGreater (I x)) =\n  (\\<forall>t\\<ge>0.\n      \\<forall>u\\<in>Regions.region X I r.\n         u \\<oplus> t \\<in> Regions.region X I r)\n  \\<not> (\\<forall>t\\<ge>0. \\<forall>u\\<in>R. u \\<oplus> t \\<in> R)", "obtain x where x:\n    \"x \\<in> X\" \"\\<not> isGreater (I x)\""], ["proof (prove)\nusing this:\n  (\\<forall>x\\<in>X. Regions.isGreater (I x)) =\n  (\\<forall>t\\<ge>0.\n      \\<forall>u\\<in>Regions.region X I r.\n         u \\<oplus> t \\<in> Regions.region X I r)\n  \\<not> (\\<forall>t\\<ge>0. \\<forall>u\\<in>R. u \\<oplus> t \\<in> R)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> X; \\<not> Regions.isGreater (I x)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: R)"], ["proof (state)\nthis:\n  x \\<in> X\n  \\<not> Regions.isGreater (I x)\n\ngoal (1 subgoal):\n 1. u \\<oplus> 1 \\<notin> R", "with assms"], ["proof (chain)\npicking this:\n  finite X\n  Regions.valid_region X k I r\n  R \\<equiv> Regions.region X I r\n  \\<not> (\\<forall>t\\<ge>0. \\<forall>u\\<in>R. u \\<oplus> t \\<in> R)\n  u \\<in> R\n  x \\<in> X\n  \\<not> Regions.isGreater (I x)", "have \"intv_elem x u (I x)\""], ["proof (prove)\nusing this:\n  finite X\n  Regions.valid_region X k I r\n  R \\<equiv> Regions.region X I r\n  \\<not> (\\<forall>t\\<ge>0. \\<forall>u\\<in>R. u \\<oplus> t \\<in> R)\n  u \\<in> R\n  x \\<in> X\n  \\<not> Regions.isGreater (I x)\n\ngoal (1 subgoal):\n 1. Regions.intv_elem x u (I x)", "by auto"], ["proof (state)\nthis:\n  Regions.intv_elem x u (I x)\n\ngoal (1 subgoal):\n 1. u \\<oplus> 1 \\<notin> R", "with x(2)"], ["proof (chain)\npicking this:\n  \\<not> Regions.isGreater (I x)\n  Regions.intv_elem x u (I x)", "have \"\\<not> intv_elem x (u \\<oplus> 1) (I x)\""], ["proof (prove)\nusing this:\n  \\<not> Regions.isGreater (I x)\n  Regions.intv_elem x u (I x)\n\ngoal (1 subgoal):\n 1. \\<not> Regions.intv_elem x (u \\<oplus> 1) (I x)", "by (cases \"I x\", auto simp: cval_add_def)"], ["proof (state)\nthis:\n  \\<not> Regions.intv_elem x (u \\<oplus> 1) (I x)\n\ngoal (1 subgoal):\n 1. u \\<oplus> 1 \\<notin> R", "with x(1) assms"], ["proof (chain)\npicking this:\n  x \\<in> X\n  finite X\n  Regions.valid_region X k I r\n  R \\<equiv> Regions.region X I r\n  \\<not> (\\<forall>t\\<ge>0. \\<forall>u\\<in>R. u \\<oplus> t \\<in> R)\n  u \\<in> R\n  \\<not> Regions.intv_elem x (u \\<oplus> 1) (I x)", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> X\n  finite X\n  Regions.valid_region X k I r\n  R \\<equiv> Regions.region X I r\n  \\<not> (\\<forall>t\\<ge>0. \\<forall>u\\<in>R. u \\<oplus> t \\<in> R)\n  u \\<in> R\n  \\<not> Regions.intv_elem x (u \\<oplus> 1) (I x)\n\ngoal (1 subgoal):\n 1. u \\<oplus> 1 \\<notin> R", "by auto"], ["proof (state)\nthis:\n  u \\<oplus> 1 \\<notin> R\n\ngoal:\nNo subgoals!", "qed"], ["", "(* XXX Remove Caml case *)"], ["", "context AlphaClosure\nbegin"], ["", "(* XXX Clean *)"], ["", "no_notation Regions_Beta.part (\"[_]\\<^sub>_\" [61,61] 61)"], ["", "lemma succ_ex:\n  assumes \"R \\<in> \\<R>\"\n  shows \"succ \\<R> R \\<in> \\<R>\" (is \"?G1\") and \"succ \\<R> R \\<in> Succ \\<R> R\" (is \"?G2\")\n  and \"\\<forall> u \\<in> R. \\<forall> t \\<ge> 0. (u \\<oplus> t) \\<notin> R \\<longrightarrow> (\\<exists> t' \\<le> t. (u \\<oplus> t') \\<in> succ \\<R> R \\<and> 0 \\<le> t')\" (is \"?G3\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. succ \\<R> R \\<in> \\<R> &&&\n    succ \\<R> R \\<in> Succ \\<R> R &&&\n    \\<forall>u\\<in>R.\n       \\<forall>t\\<ge>0.\n          u \\<oplus> t \\<notin> R \\<longrightarrow>\n          (\\<exists>t'\\<le>t.\n              u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t')", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. succ \\<R> R \\<in> \\<R>\n 2. succ \\<R> R \\<in> Succ \\<R> R\n 3. \\<forall>u\\<in>R.\n       \\<forall>t\\<ge>0.\n          u \\<oplus> t \\<notin> R \\<longrightarrow>\n          (\\<exists>t'\\<le>t.\n              u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t')", "from \\<open>R \\<in> \\<R>\\<close>"], ["proof (chain)\npicking this:\n  R \\<in> \\<R>", "obtain I r where R: \"R = region X I r\" \"valid_region X k I r\""], ["proof (prove)\nusing this:\n  R \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. (\\<And>I r.\n        \\<lbrakk>R = Regions.region X I r;\n         Regions.valid_region X k I r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<R>_def"], ["proof (prove)\nusing this:\n  R \\<in> {Regions.region X I r |I r. Regions.valid_region X k I r}\n\ngoal (1 subgoal):\n 1. (\\<And>I r.\n        \\<lbrakk>R = Regions.region X I r;\n         Regions.valid_region X k I r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  R = Regions.region X I r\n  Regions.valid_region X k I r\n\ngoal (3 subgoals):\n 1. succ \\<R> R \\<in> \\<R>\n 2. succ \\<R> R \\<in> Succ \\<R> R\n 3. \\<forall>u\\<in>R.\n       \\<forall>t\\<ge>0.\n          u \\<oplus> t \\<notin> R \\<longrightarrow>\n          (\\<exists>t'\\<le>t.\n              u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t')", "from region_not_empty[OF finite] R"], ["proof (chain)\npicking this:\n  Regions.valid_region X ?k ?I ?r \\<Longrightarrow>\n  \\<exists>u. u \\<in> Regions.region X ?I ?r\n  R = Regions.region X I r\n  Regions.valid_region X k I r", "obtain u where u: \"u \\<in> R\""], ["proof (prove)\nusing this:\n  Regions.valid_region X ?k ?I ?r \\<Longrightarrow>\n  \\<exists>u. u \\<in> Regions.region X ?I ?r\n  R = Regions.region X I r\n  Regions.valid_region X k I r\n\ngoal (1 subgoal):\n 1. (\\<And>u. u \\<in> R \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  u \\<in> R\n\ngoal (3 subgoals):\n 1. succ \\<R> R \\<in> \\<R>\n 2. succ \\<R> R \\<in> Succ \\<R> R\n 3. \\<forall>u\\<in>R.\n       \\<forall>t\\<ge>0.\n          u \\<oplus> t \\<notin> R \\<longrightarrow>\n          (\\<exists>t'\\<le>t.\n              u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t')", "let ?Z = \"{x \\<in> X . \\<exists> c. I x = Const c}\""], ["proof (state)\ngoal (3 subgoals):\n 1. succ \\<R> R \\<in> \\<R>\n 2. succ \\<R> R \\<in> Succ \\<R> R\n 3. \\<forall>u\\<in>R.\n       \\<forall>t\\<ge>0.\n          u \\<oplus> t \\<notin> R \\<longrightarrow>\n          (\\<exists>t'\\<le>t.\n              u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t')", "let ?succ =\n    \"\\<lambda> R'. R' \\<noteq> R \\<and> R' \\<in> Succ \\<R> R\n     \\<and> (\\<forall> u \\<in> R. \\<forall> t \\<ge> 0. (u \\<oplus> t) \\<notin> R \\<longrightarrow> (\\<exists> t' \\<le> t. (u \\<oplus> t') \\<in> R' \\<and> 0 \\<le> t'))\""], ["proof (state)\ngoal (3 subgoals):\n 1. succ \\<R> R \\<in> \\<R>\n 2. succ \\<R> R \\<in> Succ \\<R> R\n 3. \\<forall>u\\<in>R.\n       \\<forall>t\\<ge>0.\n          u \\<oplus> t \\<notin> R \\<longrightarrow>\n          (\\<exists>t'\\<le>t.\n              u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t')", "consider (upper_right) \"\\<forall> x \\<in> X. isGreater (I x)\" | (intv) \"\\<exists> x \\<in> X. \\<exists> d. I x = Intv d \\<and> ?Z = {}\"\n         | (const) \"?Z \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n             thesis;\n     \\<exists>x\\<in>X.\n        \\<exists>d.\n           I x = Regions.intv.Intv d \\<and>\n           {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n           {} \\<Longrightarrow>\n     thesis;\n     {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} \\<noteq>\n     {} \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (cases \"\\<forall> x \\<in> X. isGreater (I x)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n             thesis;\n     \\<exists>x\\<in>X.\n        \\<exists>d.\n           I x = Regions.intv.Intv d \\<and>\n           {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n           {} \\<Longrightarrow>\n     thesis;\n     {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} \\<noteq>\n     {} \\<Longrightarrow>\n     thesis;\n     \\<forall>x\\<in>X. Regions.isGreater (I x)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n             thesis;\n     \\<exists>x\\<in>X.\n        \\<exists>d.\n           I x = Regions.intv.Intv d \\<and>\n           {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n           {} \\<Longrightarrow>\n     thesis;\n     {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} \\<noteq>\n     {} \\<Longrightarrow>\n     thesis;\n     \\<not> (\\<forall>x\\<in>X. Regions.isGreater (I x))\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply fast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n             thesis;\n     \\<exists>x\\<in>X.\n        \\<exists>d.\n           I x = Regions.intv.Intv d \\<and>\n           {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n           {} \\<Longrightarrow>\n     thesis;\n     {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} \\<noteq>\n     {} \\<Longrightarrow>\n     thesis;\n     \\<not> (\\<forall>x\\<in>X. Regions.isGreater (I x))\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (cases \"?Z = {}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n             thesis;\n     \\<exists>x\\<in>X.\n        \\<exists>d.\n           I x = Regions.intv.Intv d \\<and>\n           {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n           {} \\<Longrightarrow>\n     thesis;\n     {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} \\<noteq>\n     {} \\<Longrightarrow>\n     thesis;\n     \\<not> (\\<forall>x\\<in>X. Regions.isGreater (I x));\n     {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} = {}\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n             thesis;\n     \\<exists>x\\<in>X.\n        \\<exists>d.\n           I x = Regions.intv.Intv d \\<and>\n           {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n           {} \\<Longrightarrow>\n     thesis;\n     {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} \\<noteq>\n     {} \\<Longrightarrow>\n     thesis;\n     \\<not> (\\<forall>x\\<in>X. Regions.isGreater (I x));\n     {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n                thesis;\n        \\<exists>x\\<in>X.\n           \\<exists>d.\n              I x = Regions.intv.Intv d \\<and>\n              {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n              {} \\<Longrightarrow>\n        thesis;\n        {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} \\<noteq>\n        {} \\<Longrightarrow>\n        thesis;\n        {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} = {};\n        \\<not> thesis; x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> Regions.isGreater (I x)\n 2. \\<And>x xa c.\n       \\<lbrakk>\\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n                thesis;\n        \\<exists>x\\<in>X.\n           \\<exists>d.\n              I x = Regions.intv.Intv d \\<and>\n              {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n              {} \\<Longrightarrow>\n        thesis;\n        {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} \\<noteq>\n        {} \\<Longrightarrow>\n        thesis;\n        \\<not> thesis; x \\<in> X; \\<not> Regions.isGreater (I x);\n        xa \\<in> X; I xa = Regions.intv.Const c\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> {}", "apply (rename_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n                thesis;\n        \\<exists>x\\<in>X.\n           \\<exists>d.\n              I x = Regions.intv.Intv d \\<and>\n              {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n              {} \\<Longrightarrow>\n        thesis;\n        {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} \\<noteq>\n        {} \\<Longrightarrow>\n        thesis;\n        {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} = {};\n        \\<not> thesis; x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> Regions.isGreater (I x)\n 2. \\<And>x xa c.\n       \\<lbrakk>\\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n                thesis;\n        \\<exists>x\\<in>X.\n           \\<exists>d.\n              I x = Regions.intv.Intv d \\<and>\n              {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n              {} \\<Longrightarrow>\n        thesis;\n        {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} \\<noteq>\n        {} \\<Longrightarrow>\n        thesis;\n        \\<not> thesis; x \\<in> X; \\<not> Regions.isGreater (I x);\n        xa \\<in> X; I xa = Regions.intv.Const c\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> {}", "apply (case_tac \"I x\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x x1.\n       \\<lbrakk>\\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n                thesis;\n        \\<exists>x\\<in>X.\n           \\<exists>d.\n              I x = Regions.intv.Intv d \\<and>\n              {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n              {} \\<Longrightarrow>\n        thesis;\n        {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} \\<noteq>\n        {} \\<Longrightarrow>\n        thesis;\n        {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} = {};\n        \\<not> thesis; x \\<in> X; I x = Regions.intv.Const x1\\<rbrakk>\n       \\<Longrightarrow> Regions.isGreater (I x)\n 2. \\<And>x x2.\n       \\<lbrakk>\\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n                thesis;\n        \\<exists>x\\<in>X.\n           \\<exists>d.\n              I x = Regions.intv.Intv d \\<and>\n              {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n              {} \\<Longrightarrow>\n        thesis;\n        {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} \\<noteq>\n        {} \\<Longrightarrow>\n        thesis;\n        {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} = {};\n        \\<not> thesis; x \\<in> X; I x = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> Regions.isGreater (I x)\n 3. \\<And>x x3.\n       \\<lbrakk>\\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n                thesis;\n        \\<exists>x\\<in>X.\n           \\<exists>d.\n              I x = Regions.intv.Intv d \\<and>\n              {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n              {} \\<Longrightarrow>\n        thesis;\n        {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} \\<noteq>\n        {} \\<Longrightarrow>\n        thesis;\n        {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} = {};\n        \\<not> thesis; x \\<in> X; I x = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> Regions.isGreater (I x)\n 4. \\<And>x xa c.\n       \\<lbrakk>\\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n                thesis;\n        \\<exists>x\\<in>X.\n           \\<exists>d.\n              I x = Regions.intv.Intv d \\<and>\n              {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n              {} \\<Longrightarrow>\n        thesis;\n        {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} \\<noteq>\n        {} \\<Longrightarrow>\n        thesis;\n        \\<not> thesis; x \\<in> X; \\<not> Regions.isGreater (I x);\n        xa \\<in> X; I xa = Regions.intv.Const c\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> {}", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n           ?thesis2;\n   \\<exists>x\\<in>X.\n      \\<exists>d.\n         I x = Regions.intv.Intv d \\<and>\n         {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n         {} \\<Longrightarrow>\n   ?thesis2;\n   {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} \\<noteq>\n   {} \\<Longrightarrow>\n   ?thesis2\\<rbrakk>\n  \\<Longrightarrow> ?thesis2\n\ngoal (3 subgoals):\n 1. succ \\<R> R \\<in> \\<R>\n 2. succ \\<R> R \\<in> Succ \\<R> R\n 3. \\<forall>u\\<in>R.\n       \\<forall>t\\<ge>0.\n          u \\<oplus> t \\<notin> R \\<longrightarrow>\n          (\\<exists>t'\\<le>t.\n              u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t')", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n           ?thesis2;\n   \\<exists>x\\<in>X.\n      \\<exists>d.\n         I x = Regions.intv.Intv d \\<and>\n         {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n         {} \\<Longrightarrow>\n   ?thesis2;\n   {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} \\<noteq>\n   {} \\<Longrightarrow>\n   ?thesis2\\<rbrakk>\n  \\<Longrightarrow> ?thesis2", "have \"?G1 \\<and> ?G2 \\<and> ?G3\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n           ?thesis2;\n   \\<exists>x\\<in>X.\n      \\<exists>d.\n         I x = Regions.intv.Intv d \\<and>\n         {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n         {} \\<Longrightarrow>\n   ?thesis2;\n   {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} \\<noteq>\n   {} \\<Longrightarrow>\n   ?thesis2\\<rbrakk>\n  \\<Longrightarrow> ?thesis2\n\ngoal (1 subgoal):\n 1. succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 2. \\<exists>x\\<in>X.\n       \\<exists>d.\n          I x = Regions.intv.Intv d \\<and>\n          {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n          {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 3. {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} \\<noteq>\n    {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "case const"], ["proof (state)\nthis:\n  {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} \\<noteq> {}\n\ngoal (3 subgoals):\n 1. \\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 2. \\<exists>x\\<in>X.\n       \\<exists>d.\n          I x = Regions.intv.Intv d \\<and>\n          {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n          {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 3. {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} \\<noteq>\n    {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "with upper_right_eq[OF finite R(2)]"], ["proof (chain)\npicking this:\n  (\\<forall>x\\<in>X. Regions.isGreater (I x)) =\n  (\\<forall>t\\<ge>0.\n      \\<forall>u\\<in>Regions.region X I r.\n         u \\<oplus> t \\<in> Regions.region X I r)\n  {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} \\<noteq> {}", "have \"\\<not> is_upper_right R\""], ["proof (prove)\nusing this:\n  (\\<forall>x\\<in>X. Regions.isGreater (I x)) =\n  (\\<forall>t\\<ge>0.\n      \\<forall>u\\<in>Regions.region X I r.\n         u \\<oplus> t \\<in> Regions.region X I r)\n  {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t\\<ge>0. \\<forall>u\\<in>R. u \\<oplus> t \\<in> R)", "by (auto simp: R(1))"], ["proof (state)\nthis:\n  \\<not> (\\<forall>t\\<ge>0. \\<forall>u\\<in>R. u \\<oplus> t \\<in> R)\n\ngoal (3 subgoals):\n 1. \\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 2. \\<exists>x\\<in>X.\n       \\<exists>d.\n          I x = Regions.intv.Intv d \\<and>\n          {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n          {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 3. {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} \\<noteq>\n    {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "from closest_prestable_1(1,2)[OF const finite R(2)] closest_valid_1[OF const finite R(2)] R(1)"], ["proof (chain)\npicking this:\n  \\<forall>v\\<in>Regions.region X I r.\n     \\<forall>t>0.\n        \\<exists>t'\\<le>t.\n           v \\<oplus> t'\n           \\<in> Regions.region X\n                  (\\<lambda>x.\n                      if x \\<notin> {x \\<in> X.\n                                     \\<exists>c. I x = Regions.intv.Const c}\n                      then I x\n                      else if intv_const (I x) = k x\n                           then Regions.intv.Greater (k x)\n                           else Regions.intv.Intv (intv_const (I x)))\n                  (r \\<union>\n                   {(x, y).\n                    x \\<in> {x \\<in> X.\n                             \\<exists>c. I x = Regions.intv.Const c} \\<and>\n                    y \\<in> X \\<and>\n                    intv_const (I x) < k x \\<and>\n                    Regions.isIntv\n                     (if y \\<notin> {x \\<in> X.\n                                     \\<exists>c. I x = Regions.intv.Const c}\n                      then I y\n                      else if intv_const (I y) = k y\n                           then Regions.intv.Greater (k y)\n                           else Regions.intv.Intv\n                                 (intv_const (I y)))}) \\<and>\n           0 \\<le> t'\n  \\<forall>v\\<in>Regions.region X\n                  (\\<lambda>x.\n                      if x \\<notin> {x \\<in> X.\n                                     \\<exists>c. I x = Regions.intv.Const c}\n                      then I x\n                      else if intv_const (I x) = k x\n                           then Regions.intv.Greater (k x)\n                           else Regions.intv.Intv (intv_const (I x)))\n                  (r \\<union>\n                   {(x, y).\n                    x \\<in> {x \\<in> X.\n                             \\<exists>c. I x = Regions.intv.Const c} \\<and>\n                    y \\<in> X \\<and>\n                    intv_const (I x) < k x \\<and>\n                    Regions.isIntv\n                     (if y \\<notin> {x \\<in> X.\n                                     \\<exists>c. I x = Regions.intv.Const c}\n                      then I y\n                      else if intv_const (I y) = k y\n                           then Regions.intv.Greater (k y)\n                           else Regions.intv.Intv (intv_const (I y)))}).\n     \\<forall>t\\<ge>0. v \\<oplus> t \\<notin> Regions.region X I r\n  Regions.valid_region X k\n   (\\<lambda>x.\n       if x \\<notin> {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c}\n       then I x\n       else if intv_const (I x) = k x then Regions.intv.Greater (k x)\n            else Regions.intv.Intv (intv_const (I x)))\n   (r \\<union>\n    {(x, y).\n     x \\<in> {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} \\<and>\n     y \\<in> X \\<and>\n     intv_const (I x) < k x \\<and>\n     Regions.isIntv\n      (if y \\<notin> {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c}\n       then I y\n       else if intv_const (I y) = k y then Regions.intv.Greater (k y)\n            else Regions.intv.Intv (intv_const (I y)))})\n  R = Regions.region X I r", "obtain R' where R':\n      \"\\<forall> u \\<in> R. \\<forall> t>0. \\<exists>t'\\<le>t. (u \\<oplus> t') \\<in> R' \\<and> t' \\<ge> 0\" \"R' \\<in> \\<R>\" \"\\<forall> u \\<in> R'. \\<forall> t\\<ge>0. (u \\<oplus> t) \\<notin> R\""], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>Regions.region X I r.\n     \\<forall>t>0.\n        \\<exists>t'\\<le>t.\n           v \\<oplus> t'\n           \\<in> Regions.region X\n                  (\\<lambda>x.\n                      if x \\<notin> {x \\<in> X.\n                                     \\<exists>c. I x = Regions.intv.Const c}\n                      then I x\n                      else if intv_const (I x) = k x\n                           then Regions.intv.Greater (k x)\n                           else Regions.intv.Intv (intv_const (I x)))\n                  (r \\<union>\n                   {(x, y).\n                    x \\<in> {x \\<in> X.\n                             \\<exists>c. I x = Regions.intv.Const c} \\<and>\n                    y \\<in> X \\<and>\n                    intv_const (I x) < k x \\<and>\n                    Regions.isIntv\n                     (if y \\<notin> {x \\<in> X.\n                                     \\<exists>c. I x = Regions.intv.Const c}\n                      then I y\n                      else if intv_const (I y) = k y\n                           then Regions.intv.Greater (k y)\n                           else Regions.intv.Intv\n                                 (intv_const (I y)))}) \\<and>\n           0 \\<le> t'\n  \\<forall>v\\<in>Regions.region X\n                  (\\<lambda>x.\n                      if x \\<notin> {x \\<in> X.\n                                     \\<exists>c. I x = Regions.intv.Const c}\n                      then I x\n                      else if intv_const (I x) = k x\n                           then Regions.intv.Greater (k x)\n                           else Regions.intv.Intv (intv_const (I x)))\n                  (r \\<union>\n                   {(x, y).\n                    x \\<in> {x \\<in> X.\n                             \\<exists>c. I x = Regions.intv.Const c} \\<and>\n                    y \\<in> X \\<and>\n                    intv_const (I x) < k x \\<and>\n                    Regions.isIntv\n                     (if y \\<notin> {x \\<in> X.\n                                     \\<exists>c. I x = Regions.intv.Const c}\n                      then I y\n                      else if intv_const (I y) = k y\n                           then Regions.intv.Greater (k y)\n                           else Regions.intv.Intv (intv_const (I y)))}).\n     \\<forall>t\\<ge>0. v \\<oplus> t \\<notin> Regions.region X I r\n  Regions.valid_region X k\n   (\\<lambda>x.\n       if x \\<notin> {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c}\n       then I x\n       else if intv_const (I x) = k x then Regions.intv.Greater (k x)\n            else Regions.intv.Intv (intv_const (I x)))\n   (r \\<union>\n    {(x, y).\n     x \\<in> {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} \\<and>\n     y \\<in> X \\<and>\n     intv_const (I x) < k x \\<and>\n     Regions.isIntv\n      (if y \\<notin> {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c}\n       then I y\n       else if intv_const (I y) = k y then Regions.intv.Greater (k y)\n            else Regions.intv.Intv (intv_const (I y)))})\n  R = Regions.region X I r\n\ngoal (1 subgoal):\n 1. (\\<And>R'.\n        \\<lbrakk>\\<forall>u\\<in>R.\n                    \\<forall>t>0.\n                       \\<exists>t'\\<le>t.\n                          u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t';\n         R' \\<in> \\<R>;\n         \\<forall>u\\<in>R'.\n            \\<forall>t\\<ge>0. u \\<oplus> t \\<notin> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<R>_def"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>Regions.region X I r.\n     \\<forall>t>0.\n        \\<exists>t'\\<le>t.\n           v \\<oplus> t'\n           \\<in> Regions.region X\n                  (\\<lambda>x.\n                      if x \\<notin> {x \\<in> X.\n                                     \\<exists>c. I x = Regions.intv.Const c}\n                      then I x\n                      else if intv_const (I x) = k x\n                           then Regions.intv.Greater (k x)\n                           else Regions.intv.Intv (intv_const (I x)))\n                  (r \\<union>\n                   {(x, y).\n                    x \\<in> {x \\<in> X.\n                             \\<exists>c. I x = Regions.intv.Const c} \\<and>\n                    y \\<in> X \\<and>\n                    intv_const (I x) < k x \\<and>\n                    Regions.isIntv\n                     (if y \\<notin> {x \\<in> X.\n                                     \\<exists>c. I x = Regions.intv.Const c}\n                      then I y\n                      else if intv_const (I y) = k y\n                           then Regions.intv.Greater (k y)\n                           else Regions.intv.Intv\n                                 (intv_const (I y)))}) \\<and>\n           0 \\<le> t'\n  \\<forall>v\\<in>Regions.region X\n                  (\\<lambda>x.\n                      if x \\<notin> {x \\<in> X.\n                                     \\<exists>c. I x = Regions.intv.Const c}\n                      then I x\n                      else if intv_const (I x) = k x\n                           then Regions.intv.Greater (k x)\n                           else Regions.intv.Intv (intv_const (I x)))\n                  (r \\<union>\n                   {(x, y).\n                    x \\<in> {x \\<in> X.\n                             \\<exists>c. I x = Regions.intv.Const c} \\<and>\n                    y \\<in> X \\<and>\n                    intv_const (I x) < k x \\<and>\n                    Regions.isIntv\n                     (if y \\<notin> {x \\<in> X.\n                                     \\<exists>c. I x = Regions.intv.Const c}\n                      then I y\n                      else if intv_const (I y) = k y\n                           then Regions.intv.Greater (k y)\n                           else Regions.intv.Intv (intv_const (I y)))}).\n     \\<forall>t\\<ge>0. v \\<oplus> t \\<notin> Regions.region X I r\n  Regions.valid_region X k\n   (\\<lambda>x.\n       if x \\<notin> {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c}\n       then I x\n       else if intv_const (I x) = k x then Regions.intv.Greater (k x)\n            else Regions.intv.Intv (intv_const (I x)))\n   (r \\<union>\n    {(x, y).\n     x \\<in> {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} \\<and>\n     y \\<in> X \\<and>\n     intv_const (I x) < k x \\<and>\n     Regions.isIntv\n      (if y \\<notin> {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c}\n       then I y\n       else if intv_const (I y) = k y then Regions.intv.Greater (k y)\n            else Regions.intv.Intv (intv_const (I y)))})\n  R = Regions.region X I r\n\ngoal (1 subgoal):\n 1. (\\<And>R'.\n        \\<lbrakk>\\<forall>u\\<in>R.\n                    \\<forall>t>0.\n                       \\<exists>t'\\<le>t.\n                          u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t';\n         R' \\<in> {Regions.region X I r |I r. Regions.valid_region X k I r};\n         \\<forall>u\\<in>R'.\n            \\<forall>t\\<ge>0. u \\<oplus> t \\<notin> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>u\\<in>R.\n     \\<forall>t>0.\n        \\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t'\n  R' \\<in> \\<R>\n  \\<forall>u\\<in>R'. \\<forall>t\\<ge>0. u \\<oplus> t \\<notin> R\n\ngoal (3 subgoals):\n 1. \\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 2. \\<exists>x\\<in>X.\n       \\<exists>d.\n          I x = Regions.intv.Intv d \\<and>\n          {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n          {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 3. {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} \\<noteq>\n    {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "with region_not_empty[OF finite]"], ["proof (chain)\npicking this:\n  Regions.valid_region X ?k ?I ?r \\<Longrightarrow>\n  \\<exists>u. u \\<in> Regions.region X ?I ?r\n  \\<forall>u\\<in>R.\n     \\<forall>t>0.\n        \\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t'\n  R' \\<in> \\<R>\n  \\<forall>u\\<in>R'. \\<forall>t\\<ge>0. u \\<oplus> t \\<notin> R", "obtain u' where \"u' \\<in> R'\""], ["proof (prove)\nusing this:\n  Regions.valid_region X ?k ?I ?r \\<Longrightarrow>\n  \\<exists>u. u \\<in> Regions.region X ?I ?r\n  \\<forall>u\\<in>R.\n     \\<forall>t>0.\n        \\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t'\n  R' \\<in> \\<R>\n  \\<forall>u\\<in>R'. \\<forall>t\\<ge>0. u \\<oplus> t \\<notin> R\n\ngoal (1 subgoal):\n 1. (\\<And>u'. u' \\<in> R' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<R>_def"], ["proof (prove)\nusing this:\n  Regions.valid_region X ?k ?I ?r \\<Longrightarrow>\n  \\<exists>u. u \\<in> Regions.region X ?I ?r\n  \\<forall>u\\<in>R.\n     \\<forall>t>0.\n        \\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t'\n  R' \\<in> {Regions.region X I r |I r. Regions.valid_region X k I r}\n  \\<forall>u\\<in>R'. \\<forall>t\\<ge>0. u \\<oplus> t \\<notin> R\n\ngoal (1 subgoal):\n 1. (\\<And>u'. u' \\<in> R' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  u' \\<in> R'\n\ngoal (3 subgoals):\n 1. \\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 2. \\<exists>x\\<in>X.\n       \\<exists>d.\n          I x = Regions.intv.Intv d \\<and>\n          {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n          {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 3. {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} \\<noteq>\n    {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "with R'(3)"], ["proof (chain)\npicking this:\n  \\<forall>u\\<in>R'. \\<forall>t\\<ge>0. u \\<oplus> t \\<notin> R\n  u' \\<in> R'", "have neq: \"R' \\<noteq> R\""], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>R'. \\<forall>t\\<ge>0. u \\<oplus> t \\<notin> R\n  u' \\<in> R'\n\ngoal (1 subgoal):\n 1. R' \\<noteq> R", "by (fastforce simp: cval_add_def)"], ["proof (state)\nthis:\n  R' \\<noteq> R\n\ngoal (3 subgoals):\n 1. \\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 2. \\<exists>x\\<in>X.\n       \\<exists>d.\n          I x = Regions.intv.Intv d \\<and>\n          {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n          {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 3. {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} \\<noteq>\n    {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "obtain t:: real where \"t > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t. 0 < t \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (auto intro: that[of 1])"], ["proof (state)\nthis:\n  0 < t\n\ngoal (3 subgoals):\n 1. \\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 2. \\<exists>x\\<in>X.\n       \\<exists>d.\n          I x = Regions.intv.Intv d \\<and>\n          {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n          {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 3. {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} \\<noteq>\n    {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "with R'(1,2) \\<open>u \\<in> R\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>u\\<in>R.\n     \\<forall>t>0.\n        \\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t'\n  R' \\<in> \\<R>\n  u \\<in> R\n  0 < t", "obtain t where \"t \\<ge> 0\" \"u \\<oplus> t \\<in> R'\""], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>R.\n     \\<forall>t>0.\n        \\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t'\n  R' \\<in> \\<R>\n  u \\<in> R\n  0 < t\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>0 \\<le> t; u \\<oplus> t \\<in> R'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  0 \\<le> t\n  u \\<oplus> t \\<in> R'\n\ngoal (3 subgoals):\n 1. \\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 2. \\<exists>x\\<in>X.\n       \\<exists>d.\n          I x = Regions.intv.Intv d \\<and>\n          {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n          {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 3. {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} \\<noteq>\n    {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "with \\<open>R \\<in> \\<R>\\<close> \\<open>R' \\<in> \\<R>\\<close> \\<open>u \\<in> R\\<close>"], ["proof (chain)\npicking this:\n  R \\<in> \\<R>\n  R' \\<in> \\<R>\n  u \\<in> R\n  0 \\<le> t\n  u \\<oplus> t \\<in> R'", "have \"R' \\<in> Succ \\<R> R\""], ["proof (prove)\nusing this:\n  R \\<in> \\<R>\n  R' \\<in> \\<R>\n  u \\<in> R\n  0 \\<le> t\n  u \\<oplus> t \\<in> R'\n\ngoal (1 subgoal):\n 1. R' \\<in> Succ \\<R> R", "by (intro SuccI3)"], ["proof (state)\nthis:\n  R' \\<in> Succ \\<R> R\n\ngoal (3 subgoals):\n 1. \\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 2. \\<exists>x\\<in>X.\n       \\<exists>d.\n          I x = Regions.intv.Intv d \\<and>\n          {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n          {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 3. {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} \\<noteq>\n    {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "moreover"], ["proof (state)\nthis:\n  R' \\<in> Succ \\<R> R\n\ngoal (3 subgoals):\n 1. \\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 2. \\<exists>x\\<in>X.\n       \\<exists>d.\n          I x = Regions.intv.Intv d \\<and>\n          {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n          {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 3. {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} \\<noteq>\n    {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "have \"(\\<forall> u \\<in> R. \\<forall> t \\<ge> 0. (u \\<oplus> t) \\<notin> R \\<longrightarrow> (\\<exists> t' \\<le> t. (u \\<oplus> t') \\<in> R' \\<and> 0 \\<le> t'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>R.\n       \\<forall>t\\<ge>0.\n          u \\<oplus> t \\<notin> R \\<longrightarrow>\n          (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t')", "using R'(1)"], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>R.\n     \\<forall>t>0.\n        \\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t'\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>R.\n       \\<forall>t\\<ge>0.\n          u \\<oplus> t \\<notin> R \\<longrightarrow>\n          (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t')", "unfolding cval_add_def"], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>R.\n     \\<forall>t>0.\n        \\<exists>t'\\<le>t. (\\<lambda>x. u x + t') \\<in> R' \\<and> 0 \\<le> t'\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>R.\n       \\<forall>t\\<ge>0.\n          (\\<lambda>x. u x + t) \\<notin> R \\<longrightarrow>\n          (\\<exists>t'\\<le>t.\n              (\\<lambda>x. u x + t') \\<in> R' \\<and> 0 \\<le> t')", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u t.\n       \\<lbrakk>\\<forall>u\\<in>R.\n                   \\<forall>t>0.\n                      \\<exists>t'\\<le>t.\n                         (\\<lambda>x. u x + t') \\<in> R' \\<and> 0 \\<le> t';\n        u \\<in> R; 0 \\<le> t; (\\<lambda>x. u x + t) \\<notin> R\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'\\<le>t.\n                            (\\<lambda>x. u x + t') \\<in> R' \\<and>\n                            0 \\<le> t'", "subgoal for u t"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>u\\<in>R.\n                \\<forall>t>0.\n                   \\<exists>t'\\<le>t.\n                      (\\<lambda>x. u x + t') \\<in> R' \\<and> 0 \\<le> t';\n     u \\<in> R; 0 \\<le> t; (\\<lambda>x. u x + t) \\<notin> R\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'\\<le>t.\n                         (\\<lambda>x. u x + t') \\<in> R' \\<and> 0 \\<le> t'", "by (cases \"t = 0\") auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>u\\<in>R.\n     \\<forall>t\\<ge>0.\n        u \\<oplus> t \\<notin> R \\<longrightarrow>\n        (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t')\n\ngoal (3 subgoals):\n 1. \\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 2. \\<exists>x\\<in>X.\n       \\<exists>d.\n          I x = Regions.intv.Intv d \\<and>\n          {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n          {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 3. {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} \\<noteq>\n    {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "ultimately"], ["proof (chain)\npicking this:\n  R' \\<in> Succ \\<R> R\n  \\<forall>u\\<in>R.\n     \\<forall>t\\<ge>0.\n        u \\<oplus> t \\<notin> R \\<longrightarrow>\n        (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t')", "have *: \"?succ R'\""], ["proof (prove)\nusing this:\n  R' \\<in> Succ \\<R> R\n  \\<forall>u\\<in>R.\n     \\<forall>t\\<ge>0.\n        u \\<oplus> t \\<notin> R \\<longrightarrow>\n        (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t')\n\ngoal (1 subgoal):\n 1. R' \\<noteq> R \\<and>\n    R' \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t'))", "using neq"], ["proof (prove)\nusing this:\n  R' \\<in> Succ \\<R> R\n  \\<forall>u\\<in>R.\n     \\<forall>t\\<ge>0.\n        u \\<oplus> t \\<notin> R \\<longrightarrow>\n        (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t')\n  R' \\<noteq> R\n\ngoal (1 subgoal):\n 1. R' \\<noteq> R \\<and>\n    R' \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t'))", "by auto"], ["proof (state)\nthis:\n  R' \\<noteq> R \\<and>\n  R' \\<in> Succ \\<R> R \\<and>\n  (\\<forall>u\\<in>R.\n      \\<forall>t\\<ge>0.\n         u \\<oplus> t \\<notin> R \\<longrightarrow>\n         (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t'))\n\ngoal (3 subgoals):\n 1. \\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 2. \\<exists>x\\<in>X.\n       \\<exists>d.\n          I x = Regions.intv.Intv d \\<and>\n          {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n          {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 3. {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} \\<noteq>\n    {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "have \"succ \\<R> R = R'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ \\<R> R = R'", "unfolding succ_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<forall>t\\<ge>0. \\<forall>u\\<in>R. u \\<oplus> t \\<in> R then R\n     else THE R'.\n             R' \\<noteq> R \\<and>\n             R' \\<in> Succ \\<R> R \\<and>\n             (\\<forall>u\\<in>R.\n                 \\<forall>t\\<ge>0.\n                    u \\<oplus> t \\<notin> R \\<longrightarrow>\n                    (\\<exists>t'\\<le>t.\n                        u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t'))) =\n    R'", "proof (simp add: \\<open>\\<not> is_upper_right R\\<close>, intro the_equality, rule *, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>R'a.\n       R'a \\<noteq> R \\<and>\n       R'a \\<in> Succ \\<R> R \\<and>\n       (\\<forall>u\\<in>R.\n           \\<forall>t\\<ge>0.\n              u \\<oplus> t \\<notin> R \\<longrightarrow>\n              (\\<exists>t'\\<le>t.\n                  u \\<oplus> t' \\<in> R'a \\<and>\n                  0 \\<le> t')) \\<Longrightarrow>\n       R'a = R'", "case prems: (1 R'')"], ["proof (state)\nthis:\n  R'' \\<noteq> R \\<and>\n  R'' \\<in> Succ \\<R> R \\<and>\n  (\\<forall>u\\<in>R.\n      \\<forall>t\\<ge>0.\n         u \\<oplus> t \\<notin> R \\<longrightarrow>\n         (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R'' \\<and> 0 \\<le> t'))\n\ngoal (1 subgoal):\n 1. \\<And>R'a.\n       R'a \\<noteq> R \\<and>\n       R'a \\<in> Succ \\<R> R \\<and>\n       (\\<forall>u\\<in>R.\n           \\<forall>t\\<ge>0.\n              u \\<oplus> t \\<notin> R \\<longrightarrow>\n              (\\<exists>t'\\<le>t.\n                  u \\<oplus> t' \\<in> R'a \\<and>\n                  0 \\<le> t')) \\<Longrightarrow>\n       R'a = R'", "from prems"], ["proof (chain)\npicking this:\n  R'' \\<noteq> R \\<and>\n  R'' \\<in> Succ \\<R> R \\<and>\n  (\\<forall>u\\<in>R.\n      \\<forall>t\\<ge>0.\n         u \\<oplus> t \\<notin> R \\<longrightarrow>\n         (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R'' \\<and> 0 \\<le> t'))", "obtain t' u' where R'':\n        \"R'' \\<in> \\<R>\" \"R'' \\<noteq> R\" \"t' \\<ge> 0\" \"R'' = [u' \\<oplus> t']\\<^sub>\\<R>\" \"u' \\<in> R\""], ["proof (prove)\nusing this:\n  R'' \\<noteq> R \\<and>\n  R'' \\<in> Succ \\<R> R \\<and>\n  (\\<forall>u\\<in>R.\n      \\<forall>t\\<ge>0.\n         u \\<oplus> t \\<notin> R \\<longrightarrow>\n         (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R'' \\<and> 0 \\<le> t'))\n\ngoal (1 subgoal):\n 1. (\\<And>t' u'.\n        \\<lbrakk>R'' \\<in> \\<R>; R'' \\<noteq> R; 0 \\<le> t';\n         R'' = [u' \\<oplus> t']\\<^sub>\\<R>; u' \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using R'(1)"], ["proof (prove)\nusing this:\n  R'' \\<noteq> R \\<and>\n  R'' \\<in> Succ \\<R> R \\<and>\n  (\\<forall>u\\<in>R.\n      \\<forall>t\\<ge>0.\n         u \\<oplus> t \\<notin> R \\<longrightarrow>\n         (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R'' \\<and> 0 \\<le> t'))\n  \\<forall>u\\<in>R.\n     \\<forall>t>0.\n        \\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t'\n\ngoal (1 subgoal):\n 1. (\\<And>t' u'.\n        \\<lbrakk>R'' \\<in> \\<R>; R'' \\<noteq> R; 0 \\<le> t';\n         R'' = [u' \\<oplus> t']\\<^sub>\\<R>; u' \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  R'' \\<in> \\<R>\n  R'' \\<noteq> R\n  0 \\<le> t'\n  R'' = [u' \\<oplus> t']\\<^sub>\\<R>\n  u' \\<in> R\n\ngoal (1 subgoal):\n 1. \\<And>R'a.\n       R'a \\<noteq> R \\<and>\n       R'a \\<in> Succ \\<R> R \\<and>\n       (\\<forall>u\\<in>R.\n           \\<forall>t\\<ge>0.\n              u \\<oplus> t \\<notin> R \\<longrightarrow>\n              (\\<exists>t'\\<le>t.\n                  u \\<oplus> t' \\<in> R'a \\<and>\n                  0 \\<le> t')) \\<Longrightarrow>\n       R'a = R'", "from this(1)"], ["proof (chain)\npicking this:\n  R'' \\<in> \\<R>", "obtain I r where R''2:\n        \"R'' = region X I r\" \"valid_region X k I r\""], ["proof (prove)\nusing this:\n  R'' \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. (\\<And>I r.\n        \\<lbrakk>R'' = Regions.region X I r;\n         Regions.valid_region X k I r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: \\<R>_def)"], ["proof (state)\nthis:\n  R'' = Regions.region X I r\n  Regions.valid_region X k I r\n\ngoal (1 subgoal):\n 1. \\<And>R'a.\n       R'a \\<noteq> R \\<and>\n       R'a \\<in> Succ \\<R> R \\<and>\n       (\\<forall>u\\<in>R.\n           \\<forall>t\\<ge>0.\n              u \\<oplus> t \\<notin> R \\<longrightarrow>\n              (\\<exists>t'\\<le>t.\n                  u \\<oplus> t' \\<in> R'a \\<and>\n                  0 \\<le> t')) \\<Longrightarrow>\n       R'a = R'", "from R''"], ["proof (chain)\npicking this:\n  R'' \\<in> \\<R>\n  R'' \\<noteq> R\n  0 \\<le> t'\n  R'' = [u' \\<oplus> t']\\<^sub>\\<R>\n  u' \\<in> R", "have \"u' \\<oplus> t' \\<notin> R\""], ["proof (prove)\nusing this:\n  R'' \\<in> \\<R>\n  R'' \\<noteq> R\n  0 \\<le> t'\n  R'' = [u' \\<oplus> t']\\<^sub>\\<R>\n  u' \\<in> R\n\ngoal (1 subgoal):\n 1. u' \\<oplus> t' \\<notin> R", "using assms region_unique_spec"], ["proof (prove)\nusing this:\n  R'' \\<in> \\<R>\n  R'' \\<noteq> R\n  0 \\<le> t'\n  R'' = [u' \\<oplus> t']\\<^sub>\\<R>\n  u' \\<in> R\n  R \\<in> \\<R>\n  \\<lbrakk>?u \\<in> ?R; ?R \\<in> \\<R>\\<rbrakk>\n  \\<Longrightarrow> [?u]\\<^sub>\\<R> = ?R\n\ngoal (1 subgoal):\n 1. u' \\<oplus> t' \\<notin> R", "by blast"], ["proof (state)\nthis:\n  u' \\<oplus> t' \\<notin> R\n\ngoal (1 subgoal):\n 1. \\<And>R'a.\n       R'a \\<noteq> R \\<and>\n       R'a \\<in> Succ \\<R> R \\<and>\n       (\\<forall>u\\<in>R.\n           \\<forall>t\\<ge>0.\n              u \\<oplus> t \\<notin> R \\<longrightarrow>\n              (\\<exists>t'\\<le>t.\n                  u \\<oplus> t' \\<in> R'a \\<and>\n                  0 \\<le> t')) \\<Longrightarrow>\n       R'a = R'", "with * \\<open>t' \\<ge> 0\\<close> \\<open>u' \\<in> R\\<close>"], ["proof (chain)\npicking this:\n  R' \\<noteq> R \\<and>\n  R' \\<in> Succ \\<R> R \\<and>\n  (\\<forall>u\\<in>R.\n      \\<forall>t\\<ge>0.\n         u \\<oplus> t \\<notin> R \\<longrightarrow>\n         (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t'))\n  0 \\<le> t'\n  u' \\<in> R\n  u' \\<oplus> t' \\<notin> R", "obtain t'' where t'': \"t'' \\<le> t'\" \"u' \\<oplus> t'' \\<in> R'\" \"t'' \\<ge> 0\""], ["proof (prove)\nusing this:\n  R' \\<noteq> R \\<and>\n  R' \\<in> Succ \\<R> R \\<and>\n  (\\<forall>u\\<in>R.\n      \\<forall>t\\<ge>0.\n         u \\<oplus> t \\<notin> R \\<longrightarrow>\n         (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t'))\n  0 \\<le> t'\n  u' \\<in> R\n  u' \\<oplus> t' \\<notin> R\n\ngoal (1 subgoal):\n 1. (\\<And>t''.\n        \\<lbrakk>t'' \\<le> t'; u' \\<oplus> t'' \\<in> R';\n         0 \\<le> t''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t'' \\<le> t'\n  u' \\<oplus> t'' \\<in> R'\n  0 \\<le> t''\n\ngoal (1 subgoal):\n 1. \\<And>R'a.\n       R'a \\<noteq> R \\<and>\n       R'a \\<in> Succ \\<R> R \\<and>\n       (\\<forall>u\\<in>R.\n           \\<forall>t\\<ge>0.\n              u \\<oplus> t \\<notin> R \\<longrightarrow>\n              (\\<exists>t'\\<le>t.\n                  u \\<oplus> t' \\<in> R'a \\<and>\n                  0 \\<le> t')) \\<Longrightarrow>\n       R'a = R'", "from this(2) neq"], ["proof (chain)\npicking this:\n  u' \\<oplus> t'' \\<in> R'\n  R' \\<noteq> R", "have \"u' \\<oplus> t'' \\<notin> R\""], ["proof (prove)\nusing this:\n  u' \\<oplus> t'' \\<in> R'\n  R' \\<noteq> R\n\ngoal (1 subgoal):\n 1. u' \\<oplus> t'' \\<notin> R", "using R'(2) assms region_unique_spec"], ["proof (prove)\nusing this:\n  u' \\<oplus> t'' \\<in> R'\n  R' \\<noteq> R\n  R' \\<in> \\<R>\n  R \\<in> \\<R>\n  \\<lbrakk>?u \\<in> ?R; ?R \\<in> \\<R>\\<rbrakk>\n  \\<Longrightarrow> [?u]\\<^sub>\\<R> = ?R\n\ngoal (1 subgoal):\n 1. u' \\<oplus> t'' \\<notin> R", "by auto"], ["proof (state)\nthis:\n  u' \\<oplus> t'' \\<notin> R\n\ngoal (1 subgoal):\n 1. \\<And>R'a.\n       R'a \\<noteq> R \\<and>\n       R'a \\<in> Succ \\<R> R \\<and>\n       (\\<forall>u\\<in>R.\n           \\<forall>t\\<ge>0.\n              u \\<oplus> t \\<notin> R \\<longrightarrow>\n              (\\<exists>t'\\<le>t.\n                  u \\<oplus> t' \\<in> R'a \\<and>\n                  0 \\<le> t')) \\<Longrightarrow>\n       R'a = R'", "with t'' prems \\<open>u' \\<in> R\\<close>"], ["proof (chain)\npicking this:\n  t'' \\<le> t'\n  u' \\<oplus> t'' \\<in> R'\n  0 \\<le> t''\n  R'' \\<noteq> R \\<and>\n  R'' \\<in> Succ \\<R> R \\<and>\n  (\\<forall>u\\<in>R.\n      \\<forall>t\\<ge>0.\n         u \\<oplus> t \\<notin> R \\<longrightarrow>\n         (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R'' \\<and> 0 \\<le> t'))\n  u' \\<in> R\n  u' \\<oplus> t'' \\<notin> R", "obtain t''' where t''':\n        \"t''' \\<le> t''\" \"u' \\<oplus> t''' \\<in> R''\" \"t''' \\<ge> 0\""], ["proof (prove)\nusing this:\n  t'' \\<le> t'\n  u' \\<oplus> t'' \\<in> R'\n  0 \\<le> t''\n  R'' \\<noteq> R \\<and>\n  R'' \\<in> Succ \\<R> R \\<and>\n  (\\<forall>u\\<in>R.\n      \\<forall>t\\<ge>0.\n         u \\<oplus> t \\<notin> R \\<longrightarrow>\n         (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R'' \\<and> 0 \\<le> t'))\n  u' \\<in> R\n  u' \\<oplus> t'' \\<notin> R\n\ngoal (1 subgoal):\n 1. (\\<And>t'''.\n        \\<lbrakk>t''' \\<le> t''; u' \\<oplus> t''' \\<in> R'';\n         0 \\<le> t'''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t''' \\<le> t''\n  u' \\<oplus> t''' \\<in> R''\n  0 \\<le> t'''\n\ngoal (1 subgoal):\n 1. \\<And>R'a.\n       R'a \\<noteq> R \\<and>\n       R'a \\<in> Succ \\<R> R \\<and>\n       (\\<forall>u\\<in>R.\n           \\<forall>t\\<ge>0.\n              u \\<oplus> t \\<notin> R \\<longrightarrow>\n              (\\<exists>t'\\<le>t.\n                  u \\<oplus> t' \\<in> R'a \\<and>\n                  0 \\<le> t')) \\<Longrightarrow>\n       R'a = R'", "with region_continuous[OF R''2(2) _ _ t'''(2)[unfolded R''2(1)], of \"t'' - t'''\" \"t' - t'''\"]\n           t'' R'' regions_closed'_spec[OF \\<open>R \\<in> \\<R>\\<close> R''(5,3)]"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 \\<le> t'' - t'''; t'' - t''' \\<le> t' - t''';\n   (u' \\<oplus> t''') \\<oplus> t' - t''' \\<in> Regions.region X I r\\<rbrakk>\n  \\<Longrightarrow> (u' \\<oplus> t''') \\<oplus> t'' - t'''\n                    \\<in> Regions.region X I r\n  t'' \\<le> t'\n  u' \\<oplus> t'' \\<in> R'\n  0 \\<le> t''\n  R'' \\<in> \\<R>\n  R'' \\<noteq> R\n  0 \\<le> t'\n  R'' = [u' \\<oplus> t']\\<^sub>\\<R>\n  u' \\<in> R\n  u' \\<oplus> t' \\<in> [u' \\<oplus> t']\\<^sub>\\<R>\n  t''' \\<le> t''\n  u' \\<oplus> t''' \\<in> R''\n  0 \\<le> t'''", "have \"u' \\<oplus> t'' \\<in> R''\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> t'' - t'''; t'' - t''' \\<le> t' - t''';\n   (u' \\<oplus> t''') \\<oplus> t' - t''' \\<in> Regions.region X I r\\<rbrakk>\n  \\<Longrightarrow> (u' \\<oplus> t''') \\<oplus> t'' - t'''\n                    \\<in> Regions.region X I r\n  t'' \\<le> t'\n  u' \\<oplus> t'' \\<in> R'\n  0 \\<le> t''\n  R'' \\<in> \\<R>\n  R'' \\<noteq> R\n  0 \\<le> t'\n  R'' = [u' \\<oplus> t']\\<^sub>\\<R>\n  u' \\<in> R\n  u' \\<oplus> t' \\<in> [u' \\<oplus> t']\\<^sub>\\<R>\n  t''' \\<le> t''\n  u' \\<oplus> t''' \\<in> R''\n  0 \\<le> t'''\n\ngoal (1 subgoal):\n 1. u' \\<oplus> t'' \\<in> R''", "by (auto simp: R''2 cval_add_def)"], ["proof (state)\nthis:\n  u' \\<oplus> t'' \\<in> R''\n\ngoal (1 subgoal):\n 1. \\<And>R'a.\n       R'a \\<noteq> R \\<and>\n       R'a \\<in> Succ \\<R> R \\<and>\n       (\\<forall>u\\<in>R.\n           \\<forall>t\\<ge>0.\n              u \\<oplus> t \\<notin> R \\<longrightarrow>\n              (\\<exists>t'\\<le>t.\n                  u \\<oplus> t' \\<in> R'a \\<and>\n                  0 \\<le> t')) \\<Longrightarrow>\n       R'a = R'", "with t''(2)"], ["proof (chain)\npicking this:\n  u' \\<oplus> t'' \\<in> R'\n  u' \\<oplus> t'' \\<in> R''", "show ?case"], ["proof (prove)\nusing this:\n  u' \\<oplus> t'' \\<in> R'\n  u' \\<oplus> t'' \\<in> R''\n\ngoal (1 subgoal):\n 1. R'' = R'", "using R''(1) R'(2) region_unique_spec"], ["proof (prove)\nusing this:\n  u' \\<oplus> t'' \\<in> R'\n  u' \\<oplus> t'' \\<in> R''\n  R'' \\<in> \\<R>\n  R' \\<in> \\<R>\n  \\<lbrakk>?u \\<in> ?R; ?R \\<in> \\<R>\\<rbrakk>\n  \\<Longrightarrow> [?u]\\<^sub>\\<R> = ?R\n\ngoal (1 subgoal):\n 1. R'' = R'", "by blast"], ["proof (state)\nthis:\n  R'' = R'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  succ \\<R> R = R'\n\ngoal (3 subgoals):\n 1. \\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 2. \\<exists>x\\<in>X.\n       \\<exists>d.\n          I x = Regions.intv.Intv d \\<and>\n          {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n          {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 3. {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} \\<noteq>\n    {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "with R' *"], ["proof (chain)\npicking this:\n  \\<forall>u\\<in>R.\n     \\<forall>t>0.\n        \\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t'\n  R' \\<in> \\<R>\n  \\<forall>u\\<in>R'. \\<forall>t\\<ge>0. u \\<oplus> t \\<notin> R\n  R' \\<noteq> R \\<and>\n  R' \\<in> Succ \\<R> R \\<and>\n  (\\<forall>u\\<in>R.\n      \\<forall>t\\<ge>0.\n         u \\<oplus> t \\<notin> R \\<longrightarrow>\n         (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t'))\n  succ \\<R> R = R'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>R.\n     \\<forall>t>0.\n        \\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t'\n  R' \\<in> \\<R>\n  \\<forall>u\\<in>R'. \\<forall>t\\<ge>0. u \\<oplus> t \\<notin> R\n  R' \\<noteq> R \\<and>\n  R' \\<in> Succ \\<R> R \\<and>\n  (\\<forall>u\\<in>R.\n      \\<forall>t\\<ge>0.\n         u \\<oplus> t \\<notin> R \\<longrightarrow>\n         (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t'))\n  succ \\<R> R = R'\n\ngoal (1 subgoal):\n 1. succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "by auto"], ["proof (state)\nthis:\n  succ \\<R> R \\<in> \\<R> \\<and>\n  succ \\<R> R \\<in> Succ \\<R> R \\<and>\n  (\\<forall>u\\<in>R.\n      \\<forall>t\\<ge>0.\n         u \\<oplus> t \\<notin> R \\<longrightarrow>\n         (\\<exists>t'\\<le>t.\n             u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 2. \\<exists>x\\<in>X.\n       \\<exists>d.\n          I x = Regions.intv.Intv d \\<and>\n          {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n          {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 2. \\<exists>x\\<in>X.\n       \\<exists>d.\n          I x = Regions.intv.Intv d \\<and>\n          {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n          {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "case intv"], ["proof (state)\nthis:\n  \\<exists>x\\<in>X.\n     \\<exists>d.\n        I x = Regions.intv.Intv d \\<and>\n        {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} = {}\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 2. \\<exists>x\\<in>X.\n       \\<exists>d.\n          I x = Regions.intv.Intv d \\<and>\n          {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n          {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "then"], ["proof (chain)\npicking this:\n  \\<exists>x\\<in>X.\n     \\<exists>d.\n        I x = Regions.intv.Intv d \\<and>\n        {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} = {}", "have *: \"\\<forall>x\\<in>X. \\<not> Regions.isConst (I x)\""], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>X.\n     \\<exists>d.\n        I x = Regions.intv.Intv d \\<and>\n        {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} = {}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>X. \\<not> Regions.isConst (I x)", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>X. \\<not> Regions.isConst (I x)\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 2. \\<exists>x\\<in>X.\n       \\<exists>d.\n          I x = Regions.intv.Intv d \\<and>\n          {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n          {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "let ?X\\<^sub>0 = \"{x \\<in> X. isIntv (I x)}\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 2. \\<exists>x\\<in>X.\n       \\<exists>d.\n          I x = Regions.intv.Intv d \\<and>\n          {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n          {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "let ?M = \"{x \\<in> ?X\\<^sub>0. \\<forall>y\\<in>?X\\<^sub>0. (x, y) \\<in> r \\<longrightarrow> (y, x) \\<in> r}\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 2. \\<exists>x\\<in>X.\n       \\<exists>d.\n          I x = Regions.intv.Intv d \\<and>\n          {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n          {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "from intv"], ["proof (chain)\npicking this:\n  \\<exists>x\\<in>X.\n     \\<exists>d.\n        I x = Regions.intv.Intv d \\<and>\n        {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} = {}", "obtain x c where x: \"x \\<in> X\" \"\\<not> isGreater (I x)\" and c: \"I x = Intv c\""], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>X.\n     \\<exists>d.\n        I x = Regions.intv.Intv d \\<and>\n        {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} = {}\n\ngoal (1 subgoal):\n 1. (\\<And>x c.\n        \\<lbrakk>x \\<in> X; \\<not> Regions.isGreater (I x);\n         I x = Regions.intv.Intv c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> X\n  \\<not> Regions.isGreater (I x)\n  I x = Regions.intv.Intv c\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 2. \\<exists>x\\<in>X.\n       \\<exists>d.\n          I x = Regions.intv.Intv d \\<and>\n          {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n          {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "with \\<open>x \\<in> X\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> X\n  x \\<in> X\n  \\<not> Regions.isGreater (I x)\n  I x = Regions.intv.Intv c", "have \"?X\\<^sub>0 \\<noteq> {}\""], ["proof (prove)\nusing this:\n  x \\<in> X\n  x \\<in> X\n  \\<not> Regions.isGreater (I x)\n  I x = Regions.intv.Intv c\n\ngoal (1 subgoal):\n 1. {x \\<in> X. Regions.isIntv (I x)} \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  {x \\<in> X. Regions.isIntv (I x)} \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 2. \\<exists>x\\<in>X.\n       \\<exists>d.\n          I x = Regions.intv.Intv d \\<and>\n          {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n          {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "have \"?X\\<^sub>0 = {x \\<in> X. \\<exists>d. I x = Intv d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> X. Regions.isIntv (I x)} =\n    {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}", "by auto"], ["proof (state)\nthis:\n  {x \\<in> X. Regions.isIntv (I x)} =\n  {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 2. \\<exists>x\\<in>X.\n       \\<exists>d.\n          I x = Regions.intv.Intv d \\<and>\n          {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n          {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "with R(2)"], ["proof (chain)\npicking this:\n  Regions.valid_region X k I r\n  {x \\<in> X. Regions.isIntv (I x)} =\n  {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}", "have r: \"total_on ?X\\<^sub>0 r\" \"trans r\""], ["proof (prove)\nusing this:\n  Regions.valid_region X k I r\n  {x \\<in> X. Regions.isIntv (I x)} =\n  {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n\ngoal (1 subgoal):\n 1. total_on {x \\<in> X. Regions.isIntv (I x)} r &&& trans r", "by auto"], ["proof (state)\nthis:\n  total_on {x \\<in> X. Regions.isIntv (I x)} r\n  trans r\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 2. \\<exists>x\\<in>X.\n       \\<exists>d.\n          I x = Regions.intv.Intv d \\<and>\n          {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n          {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "from total_finite_trans_max[OF \\<open>?X\\<^sub>0 \\<noteq> {}\\<close> _ this] finite"], ["proof (chain)\npicking this:\n  finite {x \\<in> X. Regions.isIntv (I x)} \\<Longrightarrow>\n  \\<exists>x\\<in>{x \\<in> X. Regions.isIntv (I x)}.\n     \\<forall>y\\<in>{x \\<in> X. Regions.isIntv (I x)}.\n        x \\<noteq> y \\<longrightarrow> (y, x) \\<in> r\n  finite X", "obtain x' where x': \"x' \\<in> ?X\\<^sub>0\" \"\\<forall> y \\<in> ?X\\<^sub>0. x' \\<noteq> y \\<longrightarrow> (y, x') \\<in> r\""], ["proof (prove)\nusing this:\n  finite {x \\<in> X. Regions.isIntv (I x)} \\<Longrightarrow>\n  \\<exists>x\\<in>{x \\<in> X. Regions.isIntv (I x)}.\n     \\<forall>y\\<in>{x \\<in> X. Regions.isIntv (I x)}.\n        x \\<noteq> y \\<longrightarrow> (y, x) \\<in> r\n  finite X\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>x' \\<in> {x \\<in> X. Regions.isIntv (I x)};\n         \\<forall>y\\<in>{x \\<in> X. Regions.isIntv (I x)}.\n            x' \\<noteq> y \\<longrightarrow> (y, x') \\<in> r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  x' \\<in> {x \\<in> X. Regions.isIntv (I x)}\n  \\<forall>y\\<in>{x \\<in> X. Regions.isIntv (I x)}.\n     x' \\<noteq> y \\<longrightarrow> (y, x') \\<in> r\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 2. \\<exists>x\\<in>X.\n       \\<exists>d.\n          I x = Regions.intv.Intv d \\<and>\n          {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n          {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "from this(2)"], ["proof (chain)\npicking this:\n  \\<forall>y\\<in>{x \\<in> X. Regions.isIntv (I x)}.\n     x' \\<noteq> y \\<longrightarrow> (y, x') \\<in> r", "have \"\\<forall>y\\<in>?X\\<^sub>0. (x', y) \\<in> r \\<longrightarrow> (y, x') \\<in> r\""], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>{x \\<in> X. Regions.isIntv (I x)}.\n     x' \\<noteq> y \\<longrightarrow> (y, x') \\<in> r\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>{x \\<in> X. Regions.isIntv (I x)}.\n       (x', y) \\<in> r \\<longrightarrow> (y, x') \\<in> r", "by auto"], ["proof (state)\nthis:\n  \\<forall>y\\<in>{x \\<in> X. Regions.isIntv (I x)}.\n     (x', y) \\<in> r \\<longrightarrow> (y, x') \\<in> r\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 2. \\<exists>x\\<in>X.\n       \\<exists>d.\n          I x = Regions.intv.Intv d \\<and>\n          {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n          {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "with x'(1)"], ["proof (chain)\npicking this:\n  x' \\<in> {x \\<in> X. Regions.isIntv (I x)}\n  \\<forall>y\\<in>{x \\<in> X. Regions.isIntv (I x)}.\n     (x', y) \\<in> r \\<longrightarrow> (y, x') \\<in> r", "have **: \"?M \\<noteq> {}\""], ["proof (prove)\nusing this:\n  x' \\<in> {x \\<in> X. Regions.isIntv (I x)}\n  \\<forall>y\\<in>{x \\<in> X. Regions.isIntv (I x)}.\n     (x', y) \\<in> r \\<longrightarrow> (y, x') \\<in> r\n\ngoal (1 subgoal):\n 1. {x \\<in> {x \\<in> X. Regions.isIntv (I x)}.\n     \\<forall>y\\<in>{x \\<in> X. Regions.isIntv (I x)}.\n        (x, y) \\<in> r \\<longrightarrow> (y, x) \\<in> r} \\<noteq>\n    {}", "by fastforce"], ["proof (state)\nthis:\n  {x \\<in> {x \\<in> X. Regions.isIntv (I x)}.\n   \\<forall>y\\<in>{x \\<in> X. Regions.isIntv (I x)}.\n      (x, y) \\<in> r \\<longrightarrow> (y, x) \\<in> r} \\<noteq>\n  {}\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 2. \\<exists>x\\<in>X.\n       \\<exists>d.\n          I x = Regions.intv.Intv d \\<and>\n          {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n          {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "with upper_right_eq[OF finite R(2)]"], ["proof (chain)\npicking this:\n  (\\<forall>x\\<in>X. Regions.isGreater (I x)) =\n  (\\<forall>t\\<ge>0.\n      \\<forall>u\\<in>Regions.region X I r.\n         u \\<oplus> t \\<in> Regions.region X I r)\n  {x \\<in> {x \\<in> X. Regions.isIntv (I x)}.\n   \\<forall>y\\<in>{x \\<in> X. Regions.isIntv (I x)}.\n      (x, y) \\<in> r \\<longrightarrow> (y, x) \\<in> r} \\<noteq>\n  {}", "have \"\\<not> is_upper_right R\""], ["proof (prove)\nusing this:\n  (\\<forall>x\\<in>X. Regions.isGreater (I x)) =\n  (\\<forall>t\\<ge>0.\n      \\<forall>u\\<in>Regions.region X I r.\n         u \\<oplus> t \\<in> Regions.region X I r)\n  {x \\<in> {x \\<in> X. Regions.isIntv (I x)}.\n   \\<forall>y\\<in>{x \\<in> X. Regions.isIntv (I x)}.\n      (x, y) \\<in> r \\<longrightarrow> (y, x) \\<in> r} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t\\<ge>0. \\<forall>u\\<in>R. u \\<oplus> t \\<in> R)", "by (auto simp: R(1))"], ["proof (state)\nthis:\n  \\<not> (\\<forall>t\\<ge>0. \\<forall>u\\<in>R. u \\<oplus> t \\<in> R)\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 2. \\<exists>x\\<in>X.\n       \\<exists>d.\n          I x = Regions.intv.Intv d \\<and>\n          {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n          {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "from closest_prestable_2(1,2)[OF * finite R(2) **] closest_valid_2[OF * finite R(2) **] R(1)"], ["proof (chain)\npicking this:\n  \\<forall>v\\<in>Regions.region X I r.\n     \\<forall>t\\<ge>0.\n        v \\<oplus> t \\<notin> Regions.region X I r \\<longrightarrow>\n        (\\<exists>t'\\<le>t.\n            v \\<oplus> t'\n            \\<in> Regions.region X\n                   (\\<lambda>x.\n                       if x \\<notin> {x\n\\<in> {x \\<in> X. Regions.isIntv (I x)}.\n\\<forall>y\\<in>{x \\<in> X. Regions.isIntv (I x)}.\n   (x, y) \\<in> r \\<longrightarrow> (y, x) \\<in> r}\n                       then I x\n                       else Regions.intv.Const (intv_const (I x) + 1))\n                   {(x, y).\n                    (x, y) \\<in> r \\<and>\n                    x \\<notin> {x \\<in> {x \\<in> X. Regions.isIntv (I x)}.\n                                \\<forall>y\n   \\<in>{x \\<in> X. Regions.isIntv (I x)}.\n                                   (x, y) \\<in> r \\<longrightarrow>\n                                   (y, x) \\<in> r} \\<and>\n                    y \\<notin> {x \\<in> {x \\<in> X. Regions.isIntv (I x)}.\n                                \\<forall>y\n   \\<in>{x \\<in> X. Regions.isIntv (I x)}.\n                                   (x, y) \\<in> r \\<longrightarrow>\n                                   (y, x) \\<in> r}} \\<and>\n            0 \\<le> t')\n  \\<forall>v\\<in>Regions.region X\n                  (\\<lambda>x.\n                      if x \\<notin> {x \\<in> {x \\<in> X.\n        Regions.isIntv (I x)}.\n                                     \\<forall>y\n        \\<in>{x \\<in> X. Regions.isIntv (I x)}.\n  (x, y) \\<in> r \\<longrightarrow> (y, x) \\<in> r}\n                      then I x\n                      else Regions.intv.Const (intv_const (I x) + 1))\n                  {(x, y).\n                   (x, y) \\<in> r \\<and>\n                   x \\<notin> {x \\<in> {x \\<in> X. Regions.isIntv (I x)}.\n                               \\<forall>y\n  \\<in>{x \\<in> X. Regions.isIntv (I x)}.\n                                  (x, y) \\<in> r \\<longrightarrow>\n                                  (y, x) \\<in> r} \\<and>\n                   y \\<notin> {x \\<in> {x \\<in> X. Regions.isIntv (I x)}.\n                               \\<forall>y\n  \\<in>{x \\<in> X. Regions.isIntv (I x)}.\n                                  (x, y) \\<in> r \\<longrightarrow>\n                                  (y, x) \\<in> r}}.\n     \\<forall>t\\<ge>0. v \\<oplus> t \\<notin> Regions.region X I r\n  Regions.valid_region X k\n   (\\<lambda>x.\n       if x \\<notin> {x \\<in> {x \\<in> X. Regions.isIntv (I x)}.\n                      \\<forall>y\\<in>{x \\<in> X. Regions.isIntv (I x)}.\n                         (x, y) \\<in> r \\<longrightarrow> (y, x) \\<in> r}\n       then I x else Regions.intv.Const (intv_const (I x) + 1))\n   {(x, y).\n    (x, y) \\<in> r \\<and>\n    x \\<notin> {x \\<in> {x \\<in> X. Regions.isIntv (I x)}.\n                \\<forall>y\\<in>{x \\<in> X. Regions.isIntv (I x)}.\n                   (x, y) \\<in> r \\<longrightarrow> (y, x) \\<in> r} \\<and>\n    y \\<notin> {x \\<in> {x \\<in> X. Regions.isIntv (I x)}.\n                \\<forall>y\\<in>{x \\<in> X. Regions.isIntv (I x)}.\n                   (x, y) \\<in> r \\<longrightarrow> (y, x) \\<in> r}}\n  R = Regions.region X I r", "obtain R' where R':\n      \"(\\<forall> u \\<in> R. \\<forall> t \\<ge> 0. (u \\<oplus> t) \\<notin> R \\<longrightarrow> (\\<exists> t' \\<le> t. (u \\<oplus> t') \\<in> R' \\<and> 0 \\<le> t'))\" \"R' \\<in> \\<R>\"\n      \"\\<forall> u \\<in> R'. \\<forall> t\\<ge>0. (u \\<oplus> t) \\<notin> R\""], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>Regions.region X I r.\n     \\<forall>t\\<ge>0.\n        v \\<oplus> t \\<notin> Regions.region X I r \\<longrightarrow>\n        (\\<exists>t'\\<le>t.\n            v \\<oplus> t'\n            \\<in> Regions.region X\n                   (\\<lambda>x.\n                       if x \\<notin> {x\n\\<in> {x \\<in> X. Regions.isIntv (I x)}.\n\\<forall>y\\<in>{x \\<in> X. Regions.isIntv (I x)}.\n   (x, y) \\<in> r \\<longrightarrow> (y, x) \\<in> r}\n                       then I x\n                       else Regions.intv.Const (intv_const (I x) + 1))\n                   {(x, y).\n                    (x, y) \\<in> r \\<and>\n                    x \\<notin> {x \\<in> {x \\<in> X. Regions.isIntv (I x)}.\n                                \\<forall>y\n   \\<in>{x \\<in> X. Regions.isIntv (I x)}.\n                                   (x, y) \\<in> r \\<longrightarrow>\n                                   (y, x) \\<in> r} \\<and>\n                    y \\<notin> {x \\<in> {x \\<in> X. Regions.isIntv (I x)}.\n                                \\<forall>y\n   \\<in>{x \\<in> X. Regions.isIntv (I x)}.\n                                   (x, y) \\<in> r \\<longrightarrow>\n                                   (y, x) \\<in> r}} \\<and>\n            0 \\<le> t')\n  \\<forall>v\\<in>Regions.region X\n                  (\\<lambda>x.\n                      if x \\<notin> {x \\<in> {x \\<in> X.\n        Regions.isIntv (I x)}.\n                                     \\<forall>y\n        \\<in>{x \\<in> X. Regions.isIntv (I x)}.\n  (x, y) \\<in> r \\<longrightarrow> (y, x) \\<in> r}\n                      then I x\n                      else Regions.intv.Const (intv_const (I x) + 1))\n                  {(x, y).\n                   (x, y) \\<in> r \\<and>\n                   x \\<notin> {x \\<in> {x \\<in> X. Regions.isIntv (I x)}.\n                               \\<forall>y\n  \\<in>{x \\<in> X. Regions.isIntv (I x)}.\n                                  (x, y) \\<in> r \\<longrightarrow>\n                                  (y, x) \\<in> r} \\<and>\n                   y \\<notin> {x \\<in> {x \\<in> X. Regions.isIntv (I x)}.\n                               \\<forall>y\n  \\<in>{x \\<in> X. Regions.isIntv (I x)}.\n                                  (x, y) \\<in> r \\<longrightarrow>\n                                  (y, x) \\<in> r}}.\n     \\<forall>t\\<ge>0. v \\<oplus> t \\<notin> Regions.region X I r\n  Regions.valid_region X k\n   (\\<lambda>x.\n       if x \\<notin> {x \\<in> {x \\<in> X. Regions.isIntv (I x)}.\n                      \\<forall>y\\<in>{x \\<in> X. Regions.isIntv (I x)}.\n                         (x, y) \\<in> r \\<longrightarrow> (y, x) \\<in> r}\n       then I x else Regions.intv.Const (intv_const (I x) + 1))\n   {(x, y).\n    (x, y) \\<in> r \\<and>\n    x \\<notin> {x \\<in> {x \\<in> X. Regions.isIntv (I x)}.\n                \\<forall>y\\<in>{x \\<in> X. Regions.isIntv (I x)}.\n                   (x, y) \\<in> r \\<longrightarrow> (y, x) \\<in> r} \\<and>\n    y \\<notin> {x \\<in> {x \\<in> X. Regions.isIntv (I x)}.\n                \\<forall>y\\<in>{x \\<in> X. Regions.isIntv (I x)}.\n                   (x, y) \\<in> r \\<longrightarrow> (y, x) \\<in> r}}\n  R = Regions.region X I r\n\ngoal (1 subgoal):\n 1. (\\<And>R'.\n        \\<lbrakk>\\<forall>u\\<in>R.\n                    \\<forall>t\\<ge>0.\n                       u \\<oplus> t \\<notin> R \\<longrightarrow>\n                       (\\<exists>t'\\<le>t.\n                           u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t');\n         R' \\<in> \\<R>;\n         \\<forall>u\\<in>R'.\n            \\<forall>t\\<ge>0. u \\<oplus> t \\<notin> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<R>_def"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>Regions.region X I r.\n     \\<forall>t\\<ge>0.\n        v \\<oplus> t \\<notin> Regions.region X I r \\<longrightarrow>\n        (\\<exists>t'\\<le>t.\n            v \\<oplus> t'\n            \\<in> Regions.region X\n                   (\\<lambda>x.\n                       if x \\<notin> {x\n\\<in> {x \\<in> X. Regions.isIntv (I x)}.\n\\<forall>y\\<in>{x \\<in> X. Regions.isIntv (I x)}.\n   (x, y) \\<in> r \\<longrightarrow> (y, x) \\<in> r}\n                       then I x\n                       else Regions.intv.Const (intv_const (I x) + 1))\n                   {(x, y).\n                    (x, y) \\<in> r \\<and>\n                    x \\<notin> {x \\<in> {x \\<in> X. Regions.isIntv (I x)}.\n                                \\<forall>y\n   \\<in>{x \\<in> X. Regions.isIntv (I x)}.\n                                   (x, y) \\<in> r \\<longrightarrow>\n                                   (y, x) \\<in> r} \\<and>\n                    y \\<notin> {x \\<in> {x \\<in> X. Regions.isIntv (I x)}.\n                                \\<forall>y\n   \\<in>{x \\<in> X. Regions.isIntv (I x)}.\n                                   (x, y) \\<in> r \\<longrightarrow>\n                                   (y, x) \\<in> r}} \\<and>\n            0 \\<le> t')\n  \\<forall>v\\<in>Regions.region X\n                  (\\<lambda>x.\n                      if x \\<notin> {x \\<in> {x \\<in> X.\n        Regions.isIntv (I x)}.\n                                     \\<forall>y\n        \\<in>{x \\<in> X. Regions.isIntv (I x)}.\n  (x, y) \\<in> r \\<longrightarrow> (y, x) \\<in> r}\n                      then I x\n                      else Regions.intv.Const (intv_const (I x) + 1))\n                  {(x, y).\n                   (x, y) \\<in> r \\<and>\n                   x \\<notin> {x \\<in> {x \\<in> X. Regions.isIntv (I x)}.\n                               \\<forall>y\n  \\<in>{x \\<in> X. Regions.isIntv (I x)}.\n                                  (x, y) \\<in> r \\<longrightarrow>\n                                  (y, x) \\<in> r} \\<and>\n                   y \\<notin> {x \\<in> {x \\<in> X. Regions.isIntv (I x)}.\n                               \\<forall>y\n  \\<in>{x \\<in> X. Regions.isIntv (I x)}.\n                                  (x, y) \\<in> r \\<longrightarrow>\n                                  (y, x) \\<in> r}}.\n     \\<forall>t\\<ge>0. v \\<oplus> t \\<notin> Regions.region X I r\n  Regions.valid_region X k\n   (\\<lambda>x.\n       if x \\<notin> {x \\<in> {x \\<in> X. Regions.isIntv (I x)}.\n                      \\<forall>y\\<in>{x \\<in> X. Regions.isIntv (I x)}.\n                         (x, y) \\<in> r \\<longrightarrow> (y, x) \\<in> r}\n       then I x else Regions.intv.Const (intv_const (I x) + 1))\n   {(x, y).\n    (x, y) \\<in> r \\<and>\n    x \\<notin> {x \\<in> {x \\<in> X. Regions.isIntv (I x)}.\n                \\<forall>y\\<in>{x \\<in> X. Regions.isIntv (I x)}.\n                   (x, y) \\<in> r \\<longrightarrow> (y, x) \\<in> r} \\<and>\n    y \\<notin> {x \\<in> {x \\<in> X. Regions.isIntv (I x)}.\n                \\<forall>y\\<in>{x \\<in> X. Regions.isIntv (I x)}.\n                   (x, y) \\<in> r \\<longrightarrow> (y, x) \\<in> r}}\n  R = Regions.region X I r\n\ngoal (1 subgoal):\n 1. (\\<And>R'.\n        \\<lbrakk>\\<forall>u\\<in>R.\n                    \\<forall>t\\<ge>0.\n                       u \\<oplus> t \\<notin> R \\<longrightarrow>\n                       (\\<exists>t'\\<le>t.\n                           u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t');\n         R' \\<in> {Regions.region X I r |I r. Regions.valid_region X k I r};\n         \\<forall>u\\<in>R'.\n            \\<forall>t\\<ge>0. u \\<oplus> t \\<notin> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>u\\<in>R.\n     \\<forall>t\\<ge>0.\n        u \\<oplus> t \\<notin> R \\<longrightarrow>\n        (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t')\n  R' \\<in> \\<R>\n  \\<forall>u\\<in>R'. \\<forall>t\\<ge>0. u \\<oplus> t \\<notin> R\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 2. \\<exists>x\\<in>X.\n       \\<exists>d.\n          I x = Regions.intv.Intv d \\<and>\n          {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n          {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "with region_not_empty[OF finite]"], ["proof (chain)\npicking this:\n  Regions.valid_region X ?k ?I ?r \\<Longrightarrow>\n  \\<exists>u. u \\<in> Regions.region X ?I ?r\n  \\<forall>u\\<in>R.\n     \\<forall>t\\<ge>0.\n        u \\<oplus> t \\<notin> R \\<longrightarrow>\n        (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t')\n  R' \\<in> \\<R>\n  \\<forall>u\\<in>R'. \\<forall>t\\<ge>0. u \\<oplus> t \\<notin> R", "obtain u' where \"u' \\<in> R'\""], ["proof (prove)\nusing this:\n  Regions.valid_region X ?k ?I ?r \\<Longrightarrow>\n  \\<exists>u. u \\<in> Regions.region X ?I ?r\n  \\<forall>u\\<in>R.\n     \\<forall>t\\<ge>0.\n        u \\<oplus> t \\<notin> R \\<longrightarrow>\n        (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t')\n  R' \\<in> \\<R>\n  \\<forall>u\\<in>R'. \\<forall>t\\<ge>0. u \\<oplus> t \\<notin> R\n\ngoal (1 subgoal):\n 1. (\\<And>u'. u' \\<in> R' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<R>_def"], ["proof (prove)\nusing this:\n  Regions.valid_region X ?k ?I ?r \\<Longrightarrow>\n  \\<exists>u. u \\<in> Regions.region X ?I ?r\n  \\<forall>u\\<in>R.\n     \\<forall>t\\<ge>0.\n        u \\<oplus> t \\<notin> R \\<longrightarrow>\n        (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t')\n  R' \\<in> {Regions.region X I r |I r. Regions.valid_region X k I r}\n  \\<forall>u\\<in>R'. \\<forall>t\\<ge>0. u \\<oplus> t \\<notin> R\n\ngoal (1 subgoal):\n 1. (\\<And>u'. u' \\<in> R' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  u' \\<in> R'\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 2. \\<exists>x\\<in>X.\n       \\<exists>d.\n          I x = Regions.intv.Intv d \\<and>\n          {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n          {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "with R'(3)"], ["proof (chain)\npicking this:\n  \\<forall>u\\<in>R'. \\<forall>t\\<ge>0. u \\<oplus> t \\<notin> R\n  u' \\<in> R'", "have neq: \"R' \\<noteq> R\""], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>R'. \\<forall>t\\<ge>0. u \\<oplus> t \\<notin> R\n  u' \\<in> R'\n\ngoal (1 subgoal):\n 1. R' \\<noteq> R", "by (fastforce simp: cval_add_def)"], ["proof (state)\nthis:\n  R' \\<noteq> R\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 2. \\<exists>x\\<in>X.\n       \\<exists>d.\n          I x = Regions.intv.Intv d \\<and>\n          {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n          {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "from bounded_region[OF finite R(2), folded R(1), OF \\<open>\\<not> is_upper_right R\\<close> u]"], ["proof (chain)\npicking this:\n  u \\<oplus> 1 \\<notin> R", "have\n      \"u \\<oplus> (1 :: t) \\<notin> R\" \"(1 :: t) \\<ge> 0\""], ["proof (prove)\nusing this:\n  u \\<oplus> 1 \\<notin> R\n\ngoal (1 subgoal):\n 1. u \\<oplus> 1 \\<notin> R &&& 0 \\<le> 1", "by auto"], ["proof (state)\nthis:\n  u \\<oplus> 1 \\<notin> R\n  0 \\<le> 1\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 2. \\<exists>x\\<in>X.\n       \\<exists>d.\n          I x = Regions.intv.Intv d \\<and>\n          {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n          {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "with R'(1) u"], ["proof (chain)\npicking this:\n  \\<forall>u\\<in>R.\n     \\<forall>t\\<ge>0.\n        u \\<oplus> t \\<notin> R \\<longrightarrow>\n        (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t')\n  u \\<in> R\n  u \\<oplus> 1 \\<notin> R\n  0 \\<le> 1", "obtain t' where \"t' \\<le> (1 :: t)\" \"(u \\<oplus> t') \\<in> R'\" \"0 \\<le> t'\""], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>R.\n     \\<forall>t\\<ge>0.\n        u \\<oplus> t \\<notin> R \\<longrightarrow>\n        (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t')\n  u \\<in> R\n  u \\<oplus> 1 \\<notin> R\n  0 \\<le> 1\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>t' \\<le> 1; u \\<oplus> t' \\<in> R'; 0 \\<le> t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  t' \\<le> 1\n  u \\<oplus> t' \\<in> R'\n  0 \\<le> t'\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 2. \\<exists>x\\<in>X.\n       \\<exists>d.\n          I x = Regions.intv.Intv d \\<and>\n          {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n          {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "with \\<open>R \\<in> \\<R>\\<close> \\<open>R' \\<in> \\<R>\\<close> \\<open>u \\<in> R\\<close>"], ["proof (chain)\npicking this:\n  R \\<in> \\<R>\n  R' \\<in> \\<R>\n  u \\<in> R\n  t' \\<le> 1\n  u \\<oplus> t' \\<in> R'\n  0 \\<le> t'", "have \"R' \\<in> Succ \\<R> R\""], ["proof (prove)\nusing this:\n  R \\<in> \\<R>\n  R' \\<in> \\<R>\n  u \\<in> R\n  t' \\<le> 1\n  u \\<oplus> t' \\<in> R'\n  0 \\<le> t'\n\ngoal (1 subgoal):\n 1. R' \\<in> Succ \\<R> R", "by (intro SuccI3)"], ["proof (state)\nthis:\n  R' \\<in> Succ \\<R> R\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 2. \\<exists>x\\<in>X.\n       \\<exists>d.\n          I x = Regions.intv.Intv d \\<and>\n          {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n          {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "with R'(1) neq"], ["proof (chain)\npicking this:\n  \\<forall>u\\<in>R.\n     \\<forall>t\\<ge>0.\n        u \\<oplus> t \\<notin> R \\<longrightarrow>\n        (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t')\n  R' \\<noteq> R\n  R' \\<in> Succ \\<R> R", "have *: \"?succ R'\""], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>R.\n     \\<forall>t\\<ge>0.\n        u \\<oplus> t \\<notin> R \\<longrightarrow>\n        (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t')\n  R' \\<noteq> R\n  R' \\<in> Succ \\<R> R\n\ngoal (1 subgoal):\n 1. R' \\<noteq> R \\<and>\n    R' \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t'))", "by auto"], ["proof (state)\nthis:\n  R' \\<noteq> R \\<and>\n  R' \\<in> Succ \\<R> R \\<and>\n  (\\<forall>u\\<in>R.\n      \\<forall>t\\<ge>0.\n         u \\<oplus> t \\<notin> R \\<longrightarrow>\n         (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t'))\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 2. \\<exists>x\\<in>X.\n       \\<exists>d.\n          I x = Regions.intv.Intv d \\<and>\n          {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n          {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "have \"succ \\<R> R = R'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ \\<R> R = R'", "unfolding succ_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<forall>t\\<ge>0. \\<forall>u\\<in>R. u \\<oplus> t \\<in> R then R\n     else THE R'.\n             R' \\<noteq> R \\<and>\n             R' \\<in> Succ \\<R> R \\<and>\n             (\\<forall>u\\<in>R.\n                 \\<forall>t\\<ge>0.\n                    u \\<oplus> t \\<notin> R \\<longrightarrow>\n                    (\\<exists>t'\\<le>t.\n                        u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t'))) =\n    R'", "proof (simp add: \\<open>\\<not> is_upper_right R\\<close>, intro the_equality, rule *, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>R'a.\n       R'a \\<noteq> R \\<and>\n       R'a \\<in> Succ \\<R> R \\<and>\n       (\\<forall>u\\<in>R.\n           \\<forall>t\\<ge>0.\n              u \\<oplus> t \\<notin> R \\<longrightarrow>\n              (\\<exists>t'\\<le>t.\n                  u \\<oplus> t' \\<in> R'a \\<and>\n                  0 \\<le> t')) \\<Longrightarrow>\n       R'a = R'", "case prems: (1 R'')"], ["proof (state)\nthis:\n  R'' \\<noteq> R \\<and>\n  R'' \\<in> Succ \\<R> R \\<and>\n  (\\<forall>u\\<in>R.\n      \\<forall>t\\<ge>0.\n         u \\<oplus> t \\<notin> R \\<longrightarrow>\n         (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R'' \\<and> 0 \\<le> t'))\n\ngoal (1 subgoal):\n 1. \\<And>R'a.\n       R'a \\<noteq> R \\<and>\n       R'a \\<in> Succ \\<R> R \\<and>\n       (\\<forall>u\\<in>R.\n           \\<forall>t\\<ge>0.\n              u \\<oplus> t \\<notin> R \\<longrightarrow>\n              (\\<exists>t'\\<le>t.\n                  u \\<oplus> t' \\<in> R'a \\<and>\n                  0 \\<le> t')) \\<Longrightarrow>\n       R'a = R'", "from prems"], ["proof (chain)\npicking this:\n  R'' \\<noteq> R \\<and>\n  R'' \\<in> Succ \\<R> R \\<and>\n  (\\<forall>u\\<in>R.\n      \\<forall>t\\<ge>0.\n         u \\<oplus> t \\<notin> R \\<longrightarrow>\n         (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R'' \\<and> 0 \\<le> t'))", "obtain t' u' where R'':\n        \"R'' \\<in> \\<R>\" \"R'' \\<noteq> R\" \"t' \\<ge> 0\" \"R'' = [u' \\<oplus> t']\\<^sub>\\<R>\" \"u' \\<in> R\""], ["proof (prove)\nusing this:\n  R'' \\<noteq> R \\<and>\n  R'' \\<in> Succ \\<R> R \\<and>\n  (\\<forall>u\\<in>R.\n      \\<forall>t\\<ge>0.\n         u \\<oplus> t \\<notin> R \\<longrightarrow>\n         (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R'' \\<and> 0 \\<le> t'))\n\ngoal (1 subgoal):\n 1. (\\<And>t' u'.\n        \\<lbrakk>R'' \\<in> \\<R>; R'' \\<noteq> R; 0 \\<le> t';\n         R'' = [u' \\<oplus> t']\\<^sub>\\<R>; u' \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using R'(1)"], ["proof (prove)\nusing this:\n  R'' \\<noteq> R \\<and>\n  R'' \\<in> Succ \\<R> R \\<and>\n  (\\<forall>u\\<in>R.\n      \\<forall>t\\<ge>0.\n         u \\<oplus> t \\<notin> R \\<longrightarrow>\n         (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R'' \\<and> 0 \\<le> t'))\n  \\<forall>u\\<in>R.\n     \\<forall>t\\<ge>0.\n        u \\<oplus> t \\<notin> R \\<longrightarrow>\n        (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t')\n\ngoal (1 subgoal):\n 1. (\\<And>t' u'.\n        \\<lbrakk>R'' \\<in> \\<R>; R'' \\<noteq> R; 0 \\<le> t';\n         R'' = [u' \\<oplus> t']\\<^sub>\\<R>; u' \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  R'' \\<in> \\<R>\n  R'' \\<noteq> R\n  0 \\<le> t'\n  R'' = [u' \\<oplus> t']\\<^sub>\\<R>\n  u' \\<in> R\n\ngoal (1 subgoal):\n 1. \\<And>R'a.\n       R'a \\<noteq> R \\<and>\n       R'a \\<in> Succ \\<R> R \\<and>\n       (\\<forall>u\\<in>R.\n           \\<forall>t\\<ge>0.\n              u \\<oplus> t \\<notin> R \\<longrightarrow>\n              (\\<exists>t'\\<le>t.\n                  u \\<oplus> t' \\<in> R'a \\<and>\n                  0 \\<le> t')) \\<Longrightarrow>\n       R'a = R'", "from this(1)"], ["proof (chain)\npicking this:\n  R'' \\<in> \\<R>", "obtain I r where R''2:\n        \"R'' = region X I r\" \"valid_region X k I r\""], ["proof (prove)\nusing this:\n  R'' \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. (\\<And>I r.\n        \\<lbrakk>R'' = Regions.region X I r;\n         Regions.valid_region X k I r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: \\<R>_def)"], ["proof (state)\nthis:\n  R'' = Regions.region X I r\n  Regions.valid_region X k I r\n\ngoal (1 subgoal):\n 1. \\<And>R'a.\n       R'a \\<noteq> R \\<and>\n       R'a \\<in> Succ \\<R> R \\<and>\n       (\\<forall>u\\<in>R.\n           \\<forall>t\\<ge>0.\n              u \\<oplus> t \\<notin> R \\<longrightarrow>\n              (\\<exists>t'\\<le>t.\n                  u \\<oplus> t' \\<in> R'a \\<and>\n                  0 \\<le> t')) \\<Longrightarrow>\n       R'a = R'", "from R''"], ["proof (chain)\npicking this:\n  R'' \\<in> \\<R>\n  R'' \\<noteq> R\n  0 \\<le> t'\n  R'' = [u' \\<oplus> t']\\<^sub>\\<R>\n  u' \\<in> R", "have \"u' \\<oplus> t' \\<notin> R\""], ["proof (prove)\nusing this:\n  R'' \\<in> \\<R>\n  R'' \\<noteq> R\n  0 \\<le> t'\n  R'' = [u' \\<oplus> t']\\<^sub>\\<R>\n  u' \\<in> R\n\ngoal (1 subgoal):\n 1. u' \\<oplus> t' \\<notin> R", "using assms region_unique_spec"], ["proof (prove)\nusing this:\n  R'' \\<in> \\<R>\n  R'' \\<noteq> R\n  0 \\<le> t'\n  R'' = [u' \\<oplus> t']\\<^sub>\\<R>\n  u' \\<in> R\n  R \\<in> \\<R>\n  \\<lbrakk>?u \\<in> ?R; ?R \\<in> \\<R>\\<rbrakk>\n  \\<Longrightarrow> [?u]\\<^sub>\\<R> = ?R\n\ngoal (1 subgoal):\n 1. u' \\<oplus> t' \\<notin> R", "by blast"], ["proof (state)\nthis:\n  u' \\<oplus> t' \\<notin> R\n\ngoal (1 subgoal):\n 1. \\<And>R'a.\n       R'a \\<noteq> R \\<and>\n       R'a \\<in> Succ \\<R> R \\<and>\n       (\\<forall>u\\<in>R.\n           \\<forall>t\\<ge>0.\n              u \\<oplus> t \\<notin> R \\<longrightarrow>\n              (\\<exists>t'\\<le>t.\n                  u \\<oplus> t' \\<in> R'a \\<and>\n                  0 \\<le> t')) \\<Longrightarrow>\n       R'a = R'", "with * \\<open>t' \\<ge> 0\\<close> \\<open>u' \\<in> R\\<close>"], ["proof (chain)\npicking this:\n  R' \\<noteq> R \\<and>\n  R' \\<in> Succ \\<R> R \\<and>\n  (\\<forall>u\\<in>R.\n      \\<forall>t\\<ge>0.\n         u \\<oplus> t \\<notin> R \\<longrightarrow>\n         (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t'))\n  0 \\<le> t'\n  u' \\<in> R\n  u' \\<oplus> t' \\<notin> R", "obtain t'' where t'': \"t'' \\<le> t'\" \"u' \\<oplus> t'' \\<in> R'\" \"t'' \\<ge> 0\""], ["proof (prove)\nusing this:\n  R' \\<noteq> R \\<and>\n  R' \\<in> Succ \\<R> R \\<and>\n  (\\<forall>u\\<in>R.\n      \\<forall>t\\<ge>0.\n         u \\<oplus> t \\<notin> R \\<longrightarrow>\n         (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t'))\n  0 \\<le> t'\n  u' \\<in> R\n  u' \\<oplus> t' \\<notin> R\n\ngoal (1 subgoal):\n 1. (\\<And>t''.\n        \\<lbrakk>t'' \\<le> t'; u' \\<oplus> t'' \\<in> R';\n         0 \\<le> t''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t'' \\<le> t'\n  u' \\<oplus> t'' \\<in> R'\n  0 \\<le> t''\n\ngoal (1 subgoal):\n 1. \\<And>R'a.\n       R'a \\<noteq> R \\<and>\n       R'a \\<in> Succ \\<R> R \\<and>\n       (\\<forall>u\\<in>R.\n           \\<forall>t\\<ge>0.\n              u \\<oplus> t \\<notin> R \\<longrightarrow>\n              (\\<exists>t'\\<le>t.\n                  u \\<oplus> t' \\<in> R'a \\<and>\n                  0 \\<le> t')) \\<Longrightarrow>\n       R'a = R'", "from this(2) neq"], ["proof (chain)\npicking this:\n  u' \\<oplus> t'' \\<in> R'\n  R' \\<noteq> R", "have \"u' \\<oplus> t'' \\<notin> R\""], ["proof (prove)\nusing this:\n  u' \\<oplus> t'' \\<in> R'\n  R' \\<noteq> R\n\ngoal (1 subgoal):\n 1. u' \\<oplus> t'' \\<notin> R", "using R'(2) assms region_unique_spec"], ["proof (prove)\nusing this:\n  u' \\<oplus> t'' \\<in> R'\n  R' \\<noteq> R\n  R' \\<in> \\<R>\n  R \\<in> \\<R>\n  \\<lbrakk>?u \\<in> ?R; ?R \\<in> \\<R>\\<rbrakk>\n  \\<Longrightarrow> [?u]\\<^sub>\\<R> = ?R\n\ngoal (1 subgoal):\n 1. u' \\<oplus> t'' \\<notin> R", "by auto"], ["proof (state)\nthis:\n  u' \\<oplus> t'' \\<notin> R\n\ngoal (1 subgoal):\n 1. \\<And>R'a.\n       R'a \\<noteq> R \\<and>\n       R'a \\<in> Succ \\<R> R \\<and>\n       (\\<forall>u\\<in>R.\n           \\<forall>t\\<ge>0.\n              u \\<oplus> t \\<notin> R \\<longrightarrow>\n              (\\<exists>t'\\<le>t.\n                  u \\<oplus> t' \\<in> R'a \\<and>\n                  0 \\<le> t')) \\<Longrightarrow>\n       R'a = R'", "with t'' prems \\<open>u' \\<in> R\\<close>"], ["proof (chain)\npicking this:\n  t'' \\<le> t'\n  u' \\<oplus> t'' \\<in> R'\n  0 \\<le> t''\n  R'' \\<noteq> R \\<and>\n  R'' \\<in> Succ \\<R> R \\<and>\n  (\\<forall>u\\<in>R.\n      \\<forall>t\\<ge>0.\n         u \\<oplus> t \\<notin> R \\<longrightarrow>\n         (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R'' \\<and> 0 \\<le> t'))\n  u' \\<in> R\n  u' \\<oplus> t'' \\<notin> R", "obtain t''' where t''':\n        \"t''' \\<le> t''\" \"u' \\<oplus> t''' \\<in> R''\" \"t''' \\<ge> 0\""], ["proof (prove)\nusing this:\n  t'' \\<le> t'\n  u' \\<oplus> t'' \\<in> R'\n  0 \\<le> t''\n  R'' \\<noteq> R \\<and>\n  R'' \\<in> Succ \\<R> R \\<and>\n  (\\<forall>u\\<in>R.\n      \\<forall>t\\<ge>0.\n         u \\<oplus> t \\<notin> R \\<longrightarrow>\n         (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R'' \\<and> 0 \\<le> t'))\n  u' \\<in> R\n  u' \\<oplus> t'' \\<notin> R\n\ngoal (1 subgoal):\n 1. (\\<And>t'''.\n        \\<lbrakk>t''' \\<le> t''; u' \\<oplus> t''' \\<in> R'';\n         0 \\<le> t'''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t''' \\<le> t''\n  u' \\<oplus> t''' \\<in> R''\n  0 \\<le> t'''\n\ngoal (1 subgoal):\n 1. \\<And>R'a.\n       R'a \\<noteq> R \\<and>\n       R'a \\<in> Succ \\<R> R \\<and>\n       (\\<forall>u\\<in>R.\n           \\<forall>t\\<ge>0.\n              u \\<oplus> t \\<notin> R \\<longrightarrow>\n              (\\<exists>t'\\<le>t.\n                  u \\<oplus> t' \\<in> R'a \\<and>\n                  0 \\<le> t')) \\<Longrightarrow>\n       R'a = R'", "with region_continuous[OF R''2(2) _ _ t'''(2)[unfolded R''2(1)], of \"t'' - t'''\" \"t' - t'''\"]\n           t'' R'' regions_closed'_spec[OF \\<open>R \\<in> \\<R>\\<close> R''(5,3)]"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 \\<le> t'' - t'''; t'' - t''' \\<le> t' - t''';\n   (u' \\<oplus> t''') \\<oplus> t' - t''' \\<in> Regions.region X I r\\<rbrakk>\n  \\<Longrightarrow> (u' \\<oplus> t''') \\<oplus> t'' - t'''\n                    \\<in> Regions.region X I r\n  t'' \\<le> t'\n  u' \\<oplus> t'' \\<in> R'\n  0 \\<le> t''\n  R'' \\<in> \\<R>\n  R'' \\<noteq> R\n  0 \\<le> t'\n  R'' = [u' \\<oplus> t']\\<^sub>\\<R>\n  u' \\<in> R\n  u' \\<oplus> t' \\<in> [u' \\<oplus> t']\\<^sub>\\<R>\n  t''' \\<le> t''\n  u' \\<oplus> t''' \\<in> R''\n  0 \\<le> t'''", "have \"u' \\<oplus> t'' \\<in> R''\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> t'' - t'''; t'' - t''' \\<le> t' - t''';\n   (u' \\<oplus> t''') \\<oplus> t' - t''' \\<in> Regions.region X I r\\<rbrakk>\n  \\<Longrightarrow> (u' \\<oplus> t''') \\<oplus> t'' - t'''\n                    \\<in> Regions.region X I r\n  t'' \\<le> t'\n  u' \\<oplus> t'' \\<in> R'\n  0 \\<le> t''\n  R'' \\<in> \\<R>\n  R'' \\<noteq> R\n  0 \\<le> t'\n  R'' = [u' \\<oplus> t']\\<^sub>\\<R>\n  u' \\<in> R\n  u' \\<oplus> t' \\<in> [u' \\<oplus> t']\\<^sub>\\<R>\n  t''' \\<le> t''\n  u' \\<oplus> t''' \\<in> R''\n  0 \\<le> t'''\n\ngoal (1 subgoal):\n 1. u' \\<oplus> t'' \\<in> R''", "by (auto simp: cval_add_def R''2)"], ["proof (state)\nthis:\n  u' \\<oplus> t'' \\<in> R''\n\ngoal (1 subgoal):\n 1. \\<And>R'a.\n       R'a \\<noteq> R \\<and>\n       R'a \\<in> Succ \\<R> R \\<and>\n       (\\<forall>u\\<in>R.\n           \\<forall>t\\<ge>0.\n              u \\<oplus> t \\<notin> R \\<longrightarrow>\n              (\\<exists>t'\\<le>t.\n                  u \\<oplus> t' \\<in> R'a \\<and>\n                  0 \\<le> t')) \\<Longrightarrow>\n       R'a = R'", "with t''(2)"], ["proof (chain)\npicking this:\n  u' \\<oplus> t'' \\<in> R'\n  u' \\<oplus> t'' \\<in> R''", "show ?case"], ["proof (prove)\nusing this:\n  u' \\<oplus> t'' \\<in> R'\n  u' \\<oplus> t'' \\<in> R''\n\ngoal (1 subgoal):\n 1. R'' = R'", "using R''(1) R'(2) region_unique_spec"], ["proof (prove)\nusing this:\n  u' \\<oplus> t'' \\<in> R'\n  u' \\<oplus> t'' \\<in> R''\n  R'' \\<in> \\<R>\n  R' \\<in> \\<R>\n  \\<lbrakk>?u \\<in> ?R; ?R \\<in> \\<R>\\<rbrakk>\n  \\<Longrightarrow> [?u]\\<^sub>\\<R> = ?R\n\ngoal (1 subgoal):\n 1. R'' = R'", "by blast"], ["proof (state)\nthis:\n  R'' = R'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  succ \\<R> R = R'\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n 2. \\<exists>x\\<in>X.\n       \\<exists>d.\n          I x = Regions.intv.Intv d \\<and>\n          {x \\<in> X. \\<exists>c. I x = Regions.intv.Const c} =\n          {} \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "with R' *"], ["proof (chain)\npicking this:\n  \\<forall>u\\<in>R.\n     \\<forall>t\\<ge>0.\n        u \\<oplus> t \\<notin> R \\<longrightarrow>\n        (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t')\n  R' \\<in> \\<R>\n  \\<forall>u\\<in>R'. \\<forall>t\\<ge>0. u \\<oplus> t \\<notin> R\n  R' \\<noteq> R \\<and>\n  R' \\<in> Succ \\<R> R \\<and>\n  (\\<forall>u\\<in>R.\n      \\<forall>t\\<ge>0.\n         u \\<oplus> t \\<notin> R \\<longrightarrow>\n         (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t'))\n  succ \\<R> R = R'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>R.\n     \\<forall>t\\<ge>0.\n        u \\<oplus> t \\<notin> R \\<longrightarrow>\n        (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t')\n  R' \\<in> \\<R>\n  \\<forall>u\\<in>R'. \\<forall>t\\<ge>0. u \\<oplus> t \\<notin> R\n  R' \\<noteq> R \\<and>\n  R' \\<in> Succ \\<R> R \\<and>\n  (\\<forall>u\\<in>R.\n      \\<forall>t\\<ge>0.\n         u \\<oplus> t \\<notin> R \\<longrightarrow>\n         (\\<exists>t'\\<le>t. u \\<oplus> t' \\<in> R' \\<and> 0 \\<le> t'))\n  succ \\<R> R = R'\n\ngoal (1 subgoal):\n 1. succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "by auto"], ["proof (state)\nthis:\n  succ \\<R> R \\<in> \\<R> \\<and>\n  succ \\<R> R \\<in> Succ \\<R> R \\<and>\n  (\\<forall>u\\<in>R.\n      \\<forall>t\\<ge>0.\n         u \\<oplus> t \\<notin> R \\<longrightarrow>\n         (\\<exists>t'\\<le>t.\n             u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "case upper_right"], ["proof (state)\nthis:\n  \\<forall>x\\<in>X. Regions.isGreater (I x)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "with upper_right_eq[OF finite R(2)]"], ["proof (chain)\npicking this:\n  (\\<forall>x\\<in>X. Regions.isGreater (I x)) =\n  (\\<forall>t\\<ge>0.\n      \\<forall>u\\<in>Regions.region X I r.\n         u \\<oplus> t \\<in> Regions.region X I r)\n  \\<forall>x\\<in>X. Regions.isGreater (I x)", "have \"succ \\<R> R = R\""], ["proof (prove)\nusing this:\n  (\\<forall>x\\<in>X. Regions.isGreater (I x)) =\n  (\\<forall>t\\<ge>0.\n      \\<forall>u\\<in>Regions.region X I r.\n         u \\<oplus> t \\<in> Regions.region X I r)\n  \\<forall>x\\<in>X. Regions.isGreater (I x)\n\ngoal (1 subgoal):\n 1. succ \\<R> R = R", "by (auto simp: R succ_def)"], ["proof (state)\nthis:\n  succ \\<R> R = R\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>X. Regions.isGreater (I x) \\<Longrightarrow>\n    succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "with \\<open>R \\<in> \\<R>\\<close> u"], ["proof (chain)\npicking this:\n  R \\<in> \\<R>\n  u \\<in> R\n  succ \\<R> R = R", "show ?thesis"], ["proof (prove)\nusing this:\n  R \\<in> \\<R>\n  u \\<in> R\n  succ \\<R> R = R\n\ngoal (1 subgoal):\n 1. succ \\<R> R \\<in> \\<R> \\<and>\n    succ \\<R> R \\<in> Succ \\<R> R \\<and>\n    (\\<forall>u\\<in>R.\n        \\<forall>t\\<ge>0.\n           u \\<oplus> t \\<notin> R \\<longrightarrow>\n           (\\<exists>t'\\<le>t.\n               u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "by (fastforce simp: cval_add_def intro: SuccI3)"], ["proof (state)\nthis:\n  succ \\<R> R \\<in> \\<R> \\<and>\n  succ \\<R> R \\<in> Succ \\<R> R \\<and>\n  (\\<forall>u\\<in>R.\n      \\<forall>t\\<ge>0.\n         u \\<oplus> t \\<notin> R \\<longrightarrow>\n         (\\<exists>t'\\<le>t.\n             u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  succ \\<R> R \\<in> \\<R> \\<and>\n  succ \\<R> R \\<in> Succ \\<R> R \\<and>\n  (\\<forall>u\\<in>R.\n      \\<forall>t\\<ge>0.\n         u \\<oplus> t \\<notin> R \\<longrightarrow>\n         (\\<exists>t'\\<le>t.\n             u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n\ngoal (3 subgoals):\n 1. succ \\<R> R \\<in> \\<R>\n 2. succ \\<R> R \\<in> Succ \\<R> R\n 3. \\<forall>u\\<in>R.\n       \\<forall>t\\<ge>0.\n          u \\<oplus> t \\<notin> R \\<longrightarrow>\n          (\\<exists>t'\\<le>t.\n              u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t')", "then"], ["proof (chain)\npicking this:\n  succ \\<R> R \\<in> \\<R> \\<and>\n  succ \\<R> R \\<in> Succ \\<R> R \\<and>\n  (\\<forall>u\\<in>R.\n      \\<forall>t\\<ge>0.\n         u \\<oplus> t \\<notin> R \\<longrightarrow>\n         (\\<exists>t'\\<le>t.\n             u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))", "show ?G1 ?G2 ?G3"], ["proof (prove)\nusing this:\n  succ \\<R> R \\<in> \\<R> \\<and>\n  succ \\<R> R \\<in> Succ \\<R> R \\<and>\n  (\\<forall>u\\<in>R.\n      \\<forall>t\\<ge>0.\n         u \\<oplus> t \\<notin> R \\<longrightarrow>\n         (\\<exists>t'\\<le>t.\n             u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t'))\n\ngoal (1 subgoal):\n 1. succ \\<R> R \\<in> \\<R> &&&\n    succ \\<R> R \\<in> Succ \\<R> R &&&\n    \\<forall>u\\<in>R.\n       \\<forall>t\\<ge>0.\n          u \\<oplus> t \\<notin> R \\<longrightarrow>\n          (\\<exists>t'\\<le>t.\n              u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t')", "by auto"], ["proof (state)\nthis:\n  succ \\<R> R \\<in> \\<R>\n  succ \\<R> R \\<in> Succ \\<R> R\n  \\<forall>u\\<in>R.\n     \\<forall>t\\<ge>0.\n        u \\<oplus> t \\<notin> R \\<longrightarrow>\n        (\\<exists>t'\\<le>t.\n            u \\<oplus> t' \\<in> succ \\<R> R \\<and> 0 \\<le> t')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma region_set'_closed:\n  fixes d :: nat\n  assumes \"R \\<in> \\<R>\" \"d \\<ge> 0\" \"\\<forall>x\\<in>set r. d \\<le> k x\" \"set r \\<subseteq> X\"\n  shows \"region_set' R r d \\<in> \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. region_set' R r (real d) \\<in> \\<R>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. region_set' R r (real d) \\<in> \\<R>", "from region_not_empty[OF finite] assms(1)"], ["proof (chain)\npicking this:\n  Regions.valid_region X ?k ?I ?r \\<Longrightarrow>\n  \\<exists>u. u \\<in> Regions.region X ?I ?r\n  R \\<in> \\<R>", "obtain u where \"u \\<in> R\""], ["proof (prove)\nusing this:\n  Regions.valid_region X ?k ?I ?r \\<Longrightarrow>\n  \\<exists>u. u \\<in> Regions.region X ?I ?r\n  R \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. (\\<And>u. u \\<in> R \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using \\<R>_def"], ["proof (prove)\nusing this:\n  Regions.valid_region X ?k ?I ?r \\<Longrightarrow>\n  \\<exists>u. u \\<in> Regions.region X ?I ?r\n  R \\<in> \\<R>\n  \\<R> \\<equiv> {Regions.region X I r |I r. Regions.valid_region X k I r}\n\ngoal (1 subgoal):\n 1. (\\<And>u. u \\<in> R \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  u \\<in> R\n\ngoal (1 subgoal):\n 1. region_set' R r (real d) \\<in> \\<R>", "from region_set'_id[OF _ _  finite, of _ k, folded \\<R>_def] assms this"], ["proof (chain)\npicking this:\n  \\<lbrakk>?R \\<in> \\<R>; ?v \\<in> ?R; 0 \\<le> ?c;\n   \\<forall>x\\<in>set ?r. ?c \\<le> k x; set ?r \\<subseteq> X\\<rbrakk>\n  \\<Longrightarrow> [[?r\\<rightarrow>real ?c]?v]\\<^sub>\\<R> =\n                    region_set' ?R ?r (real ?c) \\<and>\n                    [[?r\\<rightarrow>real ?c]?v]\\<^sub>\\<R>\n                    \\<in> \\<R> \\<and>\n                    [?r\\<rightarrow>real ?c]?v\n                    \\<in> [[?r\\<rightarrow>real ?c]?v]\\<^sub>\\<R>\n  R \\<in> \\<R>\n  0 \\<le> d\n  \\<forall>x\\<in>set r. d \\<le> k x\n  set r \\<subseteq> X\n  u \\<in> R", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?R \\<in> \\<R>; ?v \\<in> ?R; 0 \\<le> ?c;\n   \\<forall>x\\<in>set ?r. ?c \\<le> k x; set ?r \\<subseteq> X\\<rbrakk>\n  \\<Longrightarrow> [[?r\\<rightarrow>real ?c]?v]\\<^sub>\\<R> =\n                    region_set' ?R ?r (real ?c) \\<and>\n                    [[?r\\<rightarrow>real ?c]?v]\\<^sub>\\<R>\n                    \\<in> \\<R> \\<and>\n                    [?r\\<rightarrow>real ?c]?v\n                    \\<in> [[?r\\<rightarrow>real ?c]?v]\\<^sub>\\<R>\n  R \\<in> \\<R>\n  0 \\<le> d\n  \\<forall>x\\<in>set r. d \\<le> k x\n  set r \\<subseteq> X\n  u \\<in> R\n\ngoal (1 subgoal):\n 1. region_set' R r (real d) \\<in> \\<R>", "by fastforce"], ["proof (state)\nthis:\n  region_set' R r (real d) \\<in> \\<R>\n\ngoal:\nNo subgoals!", "qed"], ["", "(* XXX Move *)"], ["", "lemma clock_set_cong[simp]:\n  assumes \"\\<forall> c \\<in> set r. u c = d\"\n  shows \"[r \\<rightarrow> d]u = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [r\\<rightarrow>d]u = u", "proof standard"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. ([r\\<rightarrow>d]u) x = u x", "fix c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. ([r\\<rightarrow>d]u) x = u x", "from assms"], ["proof (chain)\npicking this:\n  \\<forall>c\\<in>set r. u c = d", "show \"([r \\<rightarrow> d]u) c = u c\""], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>set r. u c = d\n\ngoal (1 subgoal):\n 1. ([r\\<rightarrow>d]u) c = u c", "by (cases \"c \\<in> set r\"; auto)"], ["proof (state)\nthis:\n  ([r\\<rightarrow>d]u) c = u c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma region_reset_not_Succ:\n  (* XXX Declare globally? *)\n  notes regions_closed'_spec[intro]\n  assumes \"R \\<in> \\<R>\" \"set r \\<subseteq> X\"\n  shows \"region_set' R r 0 = R \\<or> region_set' R r 0 \\<notin> Succ \\<R> R\" (is \"?R = R \\<or> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. region_set' R r 0 = R \\<or> region_set' R r 0 \\<notin> Succ \\<R> R", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. region_set' R r 0 = R \\<or> region_set' R r 0 \\<notin> Succ \\<R> R", "from assms finite"], ["proof (chain)\npicking this:\n  R \\<in> \\<R>\n  set r \\<subseteq> X\n  finite X", "obtain u where \"u \\<in> R\""], ["proof (prove)\nusing this:\n  R \\<in> \\<R>\n  set r \\<subseteq> X\n  finite X\n\ngoal (1 subgoal):\n 1. (\\<And>u. u \\<in> R \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (meson Succ.cases succ_ex(2))"], ["proof (state)\nthis:\n  u \\<in> R\n\ngoal (1 subgoal):\n 1. region_set' R r 0 = R \\<or> region_set' R r 0 \\<notin> Succ \\<R> R", "with \\<open>R \\<in> \\<R>\\<close>"], ["proof (chain)\npicking this:\n  R \\<in> \\<R>\n  u \\<in> R", "have \"u \\<in> V\" \"[u]\\<^sub>\\<R> = R\""], ["proof (prove)\nusing this:\n  R \\<in> \\<R>\n  u \\<in> R\n\ngoal (1 subgoal):\n 1. u \\<in> V &&& [u]\\<^sub>\\<R> = R", "by (auto simp: region_unique_spec dest: region_V)"], ["proof (state)\nthis:\n  u \\<in> V\n  [u]\\<^sub>\\<R> = R\n\ngoal (1 subgoal):\n 1. region_set' R r 0 = R \\<or> region_set' R r 0 \\<notin> Succ \\<R> R", "with region_set'_id[OF \\<open>R \\<in> \\<R>\\<close>[unfolded \\<R>_def] \\<open>u \\<in> R\\<close> finite] assms(2)"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 \\<le> ?c; \\<forall>x\\<in>set ?r. ?c \\<le> k x;\n   set ?r \\<subseteq> X\\<rbrakk>\n  \\<Longrightarrow> [[?r\\<rightarrow>real\n?c]u]\\<^sub>{Regions.region X I r |I r. Regions.valid_region X k I r} =\n                    region_set' R ?r (real ?c) \\<and>\n                    [[?r\\<rightarrow>real\n?c]u]\\<^sub>{Regions.region X I r |I r. Regions.valid_region X k I r}\n                    \\<in> {Regions.region X I r |I r.\n                           Regions.valid_region X k I r} \\<and>\n                    [?r\\<rightarrow>real ?c]u\n                    \\<in> [[?r\\<rightarrow>real\n      ?c]u]\\<^sub>{Regions.region X I r |I r. Regions.valid_region X k I r}\n  set r \\<subseteq> X\n  u \\<in> V\n  [u]\\<^sub>\\<R> = R", "have\n    \"?R = [[r\\<rightarrow>0]u]\\<^sub>\\<R>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?c; \\<forall>x\\<in>set ?r. ?c \\<le> k x;\n   set ?r \\<subseteq> X\\<rbrakk>\n  \\<Longrightarrow> [[?r\\<rightarrow>real\n?c]u]\\<^sub>{Regions.region X I r |I r. Regions.valid_region X k I r} =\n                    region_set' R ?r (real ?c) \\<and>\n                    [[?r\\<rightarrow>real\n?c]u]\\<^sub>{Regions.region X I r |I r. Regions.valid_region X k I r}\n                    \\<in> {Regions.region X I r |I r.\n                           Regions.valid_region X k I r} \\<and>\n                    [?r\\<rightarrow>real ?c]u\n                    \\<in> [[?r\\<rightarrow>real\n      ?c]u]\\<^sub>{Regions.region X I r |I r. Regions.valid_region X k I r}\n  set r \\<subseteq> X\n  u \\<in> V\n  [u]\\<^sub>\\<R> = R\n\ngoal (1 subgoal):\n 1. region_set' R r 0 = [[r\\<rightarrow>0]u]\\<^sub>\\<R>", "by (force simp: \\<R>_def)"], ["proof (state)\nthis:\n  region_set' R r 0 = [[r\\<rightarrow>0]u]\\<^sub>\\<R>\n\ngoal (1 subgoal):\n 1. region_set' R r 0 = R \\<or> region_set' R r 0 \\<notin> Succ \\<R> R", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. region_set' R r 0 = R \\<or> region_set' R r 0 \\<notin> Succ \\<R> R", "proof (cases \"\\<forall> x \\<in> set r. u x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set r. u x = 0 \\<Longrightarrow>\n    region_set' R r 0 = R \\<or> region_set' R r 0 \\<notin> Succ \\<R> R\n 2. \\<not> (\\<forall>x\\<in>set r. u x = 0) \\<Longrightarrow>\n    region_set' R r 0 = R \\<or> region_set' R r 0 \\<notin> Succ \\<R> R", "case True"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set r. u x = 0\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set r. u x = 0 \\<Longrightarrow>\n    region_set' R r 0 = R \\<or> region_set' R r 0 \\<notin> Succ \\<R> R\n 2. \\<not> (\\<forall>x\\<in>set r. u x = 0) \\<Longrightarrow>\n    region_set' R r 0 = R \\<or> region_set' R r 0 \\<notin> Succ \\<R> R", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set r. u x = 0", "have \"[r\\<rightarrow>0]u = u\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set r. u x = 0\n\ngoal (1 subgoal):\n 1. [r\\<rightarrow>0]u = u", "by simp"], ["proof (state)\nthis:\n  [r\\<rightarrow>0]u = u\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set r. u x = 0 \\<Longrightarrow>\n    region_set' R r 0 = R \\<or> region_set' R r 0 \\<notin> Succ \\<R> R\n 2. \\<not> (\\<forall>x\\<in>set r. u x = 0) \\<Longrightarrow>\n    region_set' R r 0 = R \\<or> region_set' R r 0 \\<notin> Succ \\<R> R", "with \\<open>?R = _\\<close> \\<open>_ = R\\<close>"], ["proof (chain)\npicking this:\n  region_set' R r 0 = [[r\\<rightarrow>0]u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> = R\n  [r\\<rightarrow>0]u = u", "have \"?R = R\""], ["proof (prove)\nusing this:\n  region_set' R r 0 = [[r\\<rightarrow>0]u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> = R\n  [r\\<rightarrow>0]u = u\n\ngoal (1 subgoal):\n 1. region_set' R r 0 = R", "by (force simp: \\<R>_def)"], ["proof (state)\nthis:\n  region_set' R r 0 = R\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set r. u x = 0 \\<Longrightarrow>\n    region_set' R r 0 = R \\<or> region_set' R r 0 \\<notin> Succ \\<R> R\n 2. \\<not> (\\<forall>x\\<in>set r. u x = 0) \\<Longrightarrow>\n    region_set' R r 0 = R \\<or> region_set' R r 0 \\<notin> Succ \\<R> R", "then"], ["proof (chain)\npicking this:\n  region_set' R r 0 = R", "show ?thesis"], ["proof (prove)\nusing this:\n  region_set' R r 0 = R\n\ngoal (1 subgoal):\n 1. region_set' R r 0 = R \\<or> region_set' R r 0 \\<notin> Succ \\<R> R", ".."], ["proof (state)\nthis:\n  region_set' R r 0 = R \\<or> region_set' R r 0 \\<notin> Succ \\<R> R\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>set r. u x = 0) \\<Longrightarrow>\n    region_set' R r 0 = R \\<or> region_set' R r 0 \\<notin> Succ \\<R> R", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>set r. u x = 0) \\<Longrightarrow>\n    region_set' R r 0 = R \\<or> region_set' R r 0 \\<notin> Succ \\<R> R", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>x\\<in>set r. u x = 0)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>set r. u x = 0) \\<Longrightarrow>\n    region_set' R r 0 = R \\<or> region_set' R r 0 \\<notin> Succ \\<R> R", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>x\\<in>set r. u x = 0)", "obtain x where x: \"x \\<in> set r\" \"u x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x\\<in>set r. u x = 0)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> set r; u x \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> set r\n  u x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>set r. u x = 0) \\<Longrightarrow>\n    region_set' R r 0 = R \\<or> region_set' R r 0 \\<notin> Succ \\<R> R", "{"], ["proof (state)\nthis:\n  x \\<in> set r\n  u x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>set r. u x = 0) \\<Longrightarrow>\n    region_set' R r 0 = R \\<or> region_set' R r 0 \\<notin> Succ \\<R> R", "assume \"?R \\<in> Succ \\<R> R\""], ["proof (state)\nthis:\n  region_set' R r 0 \\<in> Succ \\<R> R\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>set r. u x = 0) \\<Longrightarrow>\n    region_set' R r 0 = R \\<or> region_set' R r 0 \\<notin> Succ \\<R> R", "with \\<open>u \\<in> R\\<close> \\<open>R \\<in> \\<R>\\<close>"], ["proof (chain)\npicking this:\n  u \\<in> R\n  R \\<in> \\<R>\n  region_set' R r 0 \\<in> Succ \\<R> R", "obtain t where\n        \"t \\<ge> 0\" \"[u \\<oplus> t]\\<^sub>\\<R> = ?R\" \"?R \\<in> \\<R>\""], ["proof (prove)\nusing this:\n  u \\<in> R\n  R \\<in> \\<R>\n  region_set' R r 0 \\<in> Succ \\<R> R\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>0 \\<le> t; [u \\<oplus> t]\\<^sub>\\<R> = region_set' R r 0;\n         region_set' R r 0 \\<in> \\<R>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson Succ.cases set_of_regions_spec)"], ["proof (state)\nthis:\n  0 \\<le> t\n  [u \\<oplus> t]\\<^sub>\\<R> = region_set' R r 0\n  region_set' R r 0 \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>set r. u x = 0) \\<Longrightarrow>\n    region_set' R r 0 = R \\<or> region_set' R r 0 \\<notin> Succ \\<R> R", "with \\<open>u \\<in> R\\<close> assms(1)"], ["proof (chain)\npicking this:\n  u \\<in> R\n  R \\<in> \\<R>\n  0 \\<le> t\n  [u \\<oplus> t]\\<^sub>\\<R> = region_set' R r 0\n  region_set' R r 0 \\<in> \\<R>", "have \"u \\<oplus> t \\<in> ?R\""], ["proof (prove)\nusing this:\n  u \\<in> R\n  R \\<in> \\<R>\n  0 \\<le> t\n  [u \\<oplus> t]\\<^sub>\\<R> = region_set' R r 0\n  region_set' R r 0 \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. u \\<oplus> t \\<in> region_set' R r 0", "by blast"], ["proof (state)\nthis:\n  u \\<oplus> t \\<in> region_set' R r 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>set r. u x = 0) \\<Longrightarrow>\n    region_set' R r 0 = R \\<or> region_set' R r 0 \\<notin> Succ \\<R> R", "moreover"], ["proof (state)\nthis:\n  u \\<oplus> t \\<in> region_set' R r 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>set r. u x = 0) \\<Longrightarrow>\n    region_set' R r 0 = R \\<or> region_set' R r 0 \\<notin> Succ \\<R> R", "from \\<open>?R = _\\<close> \\<open>u \\<in> R\\<close>"], ["proof (chain)\npicking this:\n  region_set' R r 0 = [[r\\<rightarrow>0]u]\\<^sub>\\<R>\n  u \\<in> R", "have \"[r\\<rightarrow>0]u \\<in> ?R\""], ["proof (prove)\nusing this:\n  region_set' R r 0 = [[r\\<rightarrow>0]u]\\<^sub>\\<R>\n  u \\<in> R\n\ngoal (1 subgoal):\n 1. [r\\<rightarrow>0]u \\<in> region_set' R r 0", "by (fastforce simp: region_set'_def)"], ["proof (state)\nthis:\n  [r\\<rightarrow>0]u \\<in> region_set' R r 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>set r. u x = 0) \\<Longrightarrow>\n    region_set' R r 0 = R \\<or> region_set' R r 0 \\<notin> Succ \\<R> R", "moreover"], ["proof (state)\nthis:\n  [r\\<rightarrow>0]u \\<in> region_set' R r 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>set r. u x = 0) \\<Longrightarrow>\n    region_set' R r 0 = R \\<or> region_set' R r 0 \\<notin> Succ \\<R> R", "from x \\<open>t \\<ge> 0\\<close> \\<open>u \\<in> V\\<close> assms"], ["proof (chain)\npicking this:\n  x \\<in> set r\n  u x \\<noteq> 0\n  0 \\<le> t\n  u \\<in> V\n  R \\<in> \\<R>\n  set r \\<subseteq> X", "have \"(u \\<oplus> t) x > 0\""], ["proof (prove)\nusing this:\n  x \\<in> set r\n  u x \\<noteq> 0\n  0 \\<le> t\n  u \\<in> V\n  R \\<in> \\<R>\n  set r \\<subseteq> X\n\ngoal (1 subgoal):\n 1. 0 < (u \\<oplus> t) x", "by (force simp: cval_add_def V_def)"], ["proof (state)\nthis:\n  0 < (u \\<oplus> t) x\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>set r. u x = 0) \\<Longrightarrow>\n    region_set' R r 0 = R \\<or> region_set' R r 0 \\<notin> Succ \\<R> R", "moreover"], ["proof (state)\nthis:\n  0 < (u \\<oplus> t) x\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>set r. u x = 0) \\<Longrightarrow>\n    region_set' R r 0 = R \\<or> region_set' R r 0 \\<notin> Succ \\<R> R", "from x"], ["proof (chain)\npicking this:\n  x \\<in> set r\n  u x \\<noteq> 0", "have \"([r\\<rightarrow>0]u) x = 0\""], ["proof (prove)\nusing this:\n  x \\<in> set r\n  u x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ([r\\<rightarrow>0]u) x = 0", "by auto"], ["proof (state)\nthis:\n  ([r\\<rightarrow>0]u) x = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>set r. u x = 0) \\<Longrightarrow>\n    region_set' R r 0 = R \\<or> region_set' R r 0 \\<notin> Succ \\<R> R", "ultimately"], ["proof (chain)\npicking this:\n  u \\<oplus> t \\<in> region_set' R r 0\n  [r\\<rightarrow>0]u \\<in> region_set' R r 0\n  0 < (u \\<oplus> t) x\n  ([r\\<rightarrow>0]u) x = 0", "have False"], ["proof (prove)\nusing this:\n  u \\<oplus> t \\<in> region_set' R r 0\n  [r\\<rightarrow>0]u \\<in> region_set' R r 0\n  0 < (u \\<oplus> t) x\n  ([r\\<rightarrow>0]u) x = 0\n\ngoal (1 subgoal):\n 1. False", "using \\<open>?R \\<in> \\<R>\\<close> x(1)"], ["proof (prove)\nusing this:\n  u \\<oplus> t \\<in> region_set' R r 0\n  [r\\<rightarrow>0]u \\<in> region_set' R r 0\n  0 < (u \\<oplus> t) x\n  ([r\\<rightarrow>0]u) x = 0\n  region_set' R r 0 \\<in> \\<R>\n  x \\<in> set r\n\ngoal (1 subgoal):\n 1. False", "by (fastforce simp: region_set'_def)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>set r. u x = 0) \\<Longrightarrow>\n    region_set' R r 0 = R \\<or> region_set' R r 0 \\<notin> Succ \\<R> R", "}"], ["proof (state)\nthis:\n  region_set' R r 0 \\<in> Succ \\<R> R \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>set r. u x = 0) \\<Longrightarrow>\n    region_set' R r 0 = R \\<or> region_set' R r 0 \\<notin> Succ \\<R> R", "then"], ["proof (chain)\npicking this:\n  region_set' R r 0 \\<in> Succ \\<R> R \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  region_set' R r 0 \\<in> Succ \\<R> R \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. region_set' R r 0 = R \\<or> region_set' R r 0 \\<notin> Succ \\<R> R", "by auto"], ["proof (state)\nthis:\n  region_set' R r 0 = R \\<or> region_set' R r 0 \\<notin> Succ \\<R> R\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  region_set' R r 0 = R \\<or> region_set' R r 0 \\<notin> Succ \\<R> R\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* Alpha Closure global *)"], ["", "subsection \\<open>Justifying Timed Until vs \\<^emph>\\<open>suntil\\<close>\\<close>"], ["", "(* XXX Move *)"], ["", "lemma guard_continuous:\n  assumes \"u \\<turnstile> g\" \"u \\<oplus> t \\<turnstile> g\" \"0 \\<le> (t'::'t::time)\" \"t' \\<le> t\"\n  shows \"u \\<oplus> t' \\<turnstile> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<oplus> t' \\<turnstile> g", "using assms"], ["proof (prove)\nusing this:\n  u \\<turnstile> g\n  u \\<oplus> t \\<turnstile> g\n  (0::'t) \\<le> t'\n  t' \\<le> t\n\ngoal (1 subgoal):\n 1. u \\<oplus> t' \\<turnstile> g", "by (induction g;\n      auto 4 3\n        simp: cval_add_def order_le_less_subst2 order_subst2 add_increasing2\n        intro: less_le_trans\n     )"], ["", "(* XXX Move *)\n(*\nlemma guard_continuous:\n  assumes \"u \\<turnstile> g\" \"u \\<oplus> t \\<turnstile> g\" \"0 \\<le> t'\" \"t' \\<le> t\"\n  shows \"u \\<oplus> t' \\<turnstile> g\"\n  using assms by (auto 4 4 intro: atomic_guard_continuous simp: list_all_iff)\n*)"], ["", "section \\<open>Definition and Semantics\\<close>"], ["", "subsection \\<open>Syntactic Definition\\<close>"], ["", "text \\<open>\n  We do not include:\n  \\<^item> a labelling function, as we will assume that atomic propositions are simply sets of states\n  \\<^item> a fixed set of locations or clocks, as we will implicitly derive it from the set of transitions\n  \\<^item> start or end locations, as we will primarily study reachability\n\\<close>"], ["", "type_synonym\n  ('c, 't, 's) transition = \"'s * ('c, 't) cconstraint * ('c set * 's) pmf\""], ["", "type_synonym\n  ('c, 't, 's) pta = \"('c, 't, 's) transition set * ('c, 't, 's) invassn\""], ["", "definition\n  edges :: \"('c, 't, 's) transition \\<Rightarrow> ('s * ('c, 't) cconstraint * ('c set * 's) pmf * 'c set * 's) set\"\nwhere\n  \"edges \\<equiv> \\<lambda> (l, g, p). {(l, g, p, X, l') | X l'. (X, l') \\<in> set_pmf p}\""], ["", "definition\n  \"Edges A \\<equiv> \\<Union> {edges t | t. t \\<in> fst A}\""], ["", "definition\n  trans_of :: \"('c, 't, 's) pta \\<Rightarrow> ('c, 't, 's) transition set\"\nwhere\n  \"trans_of \\<equiv> fst\""], ["", "definition\n  inv_of  :: \"('c, 'time, 's) pta \\<Rightarrow> ('c, 'time, 's) invassn\"\nwhere\n  \"inv_of \\<equiv> snd\""], ["", "no_notation transition (\"_ \\<turnstile> _ \\<longrightarrow>\\<^bsup>_,_,_\\<^esup> _\" [61,61,61,61,61,61] 61)"], ["", "abbreviation transition ::\n  \"('c, 'time, 's) pta \\<Rightarrow> 's \\<Rightarrow> ('c, 'time) cconstraint \\<Rightarrow> ('c set * 's) pmf \\<Rightarrow> 'c set \\<Rightarrow> 's \\<Rightarrow> bool\"\n(\"_ \\<turnstile> _ \\<longrightarrow>\\<^bsup>_,_,_\\<^esup> _\" [61,61,61,61,61,61] 61) where\n  \"(A \\<turnstile> l \\<longrightarrow>\\<^bsup>g,p,X\\<^esup> l') \\<equiv> (l, g, p, X, l') \\<in> Edges A\""], ["", "definition\n  locations  :: \"('c, 't, 's) pta \\<Rightarrow> 's set\"\nwhere\n  \"locations A \\<equiv> (fst ` Edges A) \\<union> ((snd o snd o snd o snd) ` Edges A)\""], ["", "subsubsection \\<open>Collecting Information About Clocks\\<close>"], ["", "(* XXX Remove sort constraints *)"], ["", "definition collect_clkt :: \"('c, 't::time, 's) transition set \\<Rightarrow> ('c *'t) set\"\nwhere\n  \"collect_clkt S = \\<Union> {collect_clock_pairs (fst (snd t)) | t . t \\<in> S}\""], ["", "definition collect_clki :: \"('c, 't :: time, 's) invassn \\<Rightarrow> ('c *'t) set\"\nwhere\n  \"collect_clki I = \\<Union> {collect_clock_pairs (I x) | x. True}\""], ["", "definition clkp_set :: \"('c, 't :: time, 's) pta \\<Rightarrow> ('c * 't) set\"\nwhere\n  \"clkp_set A = collect_clki (inv_of A) \\<union> collect_clkt (trans_of A)\""], ["", "definition collect_clkvt :: \"('c, 't :: time, 's) pta \\<Rightarrow> 'c set\"\nwhere\n  \"collect_clkvt A = \\<Union> ((fst o snd o snd o snd) ` Edges A)\""], ["", "abbreviation clocks where \"clocks A \\<equiv> fst ` clkp_set A \\<union> collect_clkvt A\""], ["", "definition valid_abstraction\nwhere\n  \"valid_abstraction A X k \\<equiv>\n  (\\<forall>(x,m) \\<in> clkp_set A. m \\<le> k x \\<and> x \\<in> X \\<and> m \\<in> \\<nat>) \\<and> collect_clkvt A \\<subseteq> X \\<and> finite X\""], ["", "lemma valid_abstractionD[dest]:\n  assumes \"valid_abstraction A X k\"\n  shows \"(\\<forall>(x,m) \\<in> clkp_set A. m \\<le> k x \\<and> x \\<in> X \\<and> m \\<in> \\<nat>)\" \"collect_clkvt A \\<subseteq> X\" \"finite X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(x, m)\\<in>PTA.clkp_set A.\n       m \\<le> k x \\<and> x \\<in> X \\<and> m \\<in> \\<nat> &&&\n    PTA.collect_clkvt A \\<subseteq> X &&& finite X", "using assms"], ["proof (prove)\nusing this:\n  PTA.valid_abstraction A X k\n\ngoal (1 subgoal):\n 1. \\<forall>(x, m)\\<in>PTA.clkp_set A.\n       m \\<le> k x \\<and> x \\<in> X \\<and> m \\<in> \\<nat> &&&\n    PTA.collect_clkvt A \\<subseteq> X &&& finite X", "unfolding valid_abstraction_def"], ["proof (prove)\nusing this:\n  (\\<forall>(x, m)\\<in>PTA.clkp_set A.\n      m \\<le> k x \\<and> x \\<in> X \\<and> m \\<in> \\<nat>) \\<and>\n  PTA.collect_clkvt A \\<subseteq> X \\<and> finite X\n\ngoal (1 subgoal):\n 1. \\<forall>(x, m)\\<in>PTA.clkp_set A.\n       m \\<le> k x \\<and> x \\<in> X \\<and> m \\<in> \\<nat> &&&\n    PTA.collect_clkvt A \\<subseteq> X &&& finite X", "by auto"], ["", "lemma valid_abstractionI[intro]:\n  assumes \"(\\<forall>(x,m) \\<in> clkp_set A. m \\<le> k x \\<and> x \\<in> X \\<and> m \\<in> \\<nat>)\" \"collect_clkvt A \\<subseteq> X\" \"finite X\"\n  shows \"valid_abstraction A X k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PTA.valid_abstraction A X k", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>(x, m)\\<in>PTA.clkp_set A.\n     m \\<le> k x \\<and> x \\<in> X \\<and> m \\<in> \\<nat>\n  PTA.collect_clkvt A \\<subseteq> X\n  finite X\n\ngoal (1 subgoal):\n 1. PTA.valid_abstraction A X k", "unfolding valid_abstraction_def"], ["proof (prove)\nusing this:\n  \\<forall>(x, m)\\<in>PTA.clkp_set A.\n     m \\<le> k x \\<and> x \\<in> X \\<and> m \\<in> \\<nat>\n  PTA.collect_clkvt A \\<subseteq> X\n  finite X\n\ngoal (1 subgoal):\n 1. (\\<forall>(x, m)\\<in>PTA.clkp_set A.\n        m \\<le> k x \\<and> x \\<in> X \\<and> m \\<in> \\<nat>) \\<and>\n    PTA.collect_clkvt A \\<subseteq> X \\<and> finite X", "by auto"], ["", "subsection \\<open>Operational Semantics as an MDP\\<close>"], ["", "abbreviation (input) clock_set_set :: \"'c set \\<Rightarrow> 't::time \\<Rightarrow> ('c,'t) cval \\<Rightarrow> ('c,'t) cval\"\n(\"[_:=_]_\" [65,65,65] 65)\nwhere\n  \"[X:=t]u \\<equiv> clock_set (SOME r. set r = X) t u\""], ["", "term region_set'"], ["", "abbreviation region_set_set :: \"'c set \\<Rightarrow> 't::time \\<Rightarrow> ('c,'t) zone \\<Rightarrow> ('c,'t) zone\"\n(\"[_::=_]_\" [65,65,65] 65)\nwhere\n  \"[X::=t]R \\<equiv> region_set' R (SOME r. set r = X) t\""], ["", "no_notation zone_set (\"_\\<^bsub>_ \\<rightarrow> 0\\<^esub>\" [71] 71)"], ["", "abbreviation zone_set_set :: \"('c, 't::time) zone \\<Rightarrow> 'c set \\<Rightarrow> ('c, 't) zone\"\n(\"_\\<^bsub>_ \\<rightarrow> 0\\<^esub>\" [71] 71)\nwhere\n  \"Z\\<^bsub>X \\<rightarrow> 0\\<^esub> \\<equiv> zone_set Z (SOME r. set r = X)\""], ["", "abbreviation (input) ccval (\"\\<lbrace>_\\<rbrace>\" [100]) where \"ccval cc \\<equiv> {v. v \\<turnstile> cc}\""], ["", "locale Probabilistic_Timed_Automaton =\n  fixes A :: \"('c, 't :: time, 's) pta\"\n  assumes admissible_targets:\n    \"(l, g, \\<mu>) \\<in> trans_of A \\<Longrightarrow> (X, l') \\<in> \\<mu> \\<Longrightarrow> \\<lbrace>g\\<rbrace>\\<^bsub>X \\<rightarrow> 0\\<^esub> \\<subseteq> \\<lbrace>inv_of A l'\\<rbrace>\"\n    \"(l, g, \\<mu>) \\<in> trans_of A \\<Longrightarrow> (X, l') \\<in> \\<mu> \\<Longrightarrow> X \\<subseteq> clocks A\"\n  \\<comment> \\<open>Not necessarily what we want to have\\<close>\nbegin"], ["", "subsection \\<open>Syntactic Definition\\<close>"], ["", "text_raw \\<open> \\label{sem:mdp} \\<close>"], ["", "definition \"L = locations A\""], ["", "definition \"\\<X> = clocks A\""], ["", "definition \"S \\<equiv> {(l, u) . l \\<in> L \\<and> (\\<forall> x \\<in> \\<X>. u x \\<ge> 0) \\<and> u \\<turnstile> inv_of A l}\""], ["", "inductive_set\n  K :: \"('s * ('c, 't) cval) \\<Rightarrow> ('s * ('c, 't) cval) pmf set\" for st :: \"('s * ('c, 't) cval)\"\nwhere\n  \\<comment> \\<open>Passage of time\\<close> delay:\n  \"st \\<in> S \\<Longrightarrow> st = (l, u) \\<Longrightarrow> t \\<ge> 0 \\<Longrightarrow> u \\<oplus> t \\<turnstile> inv_of A l \\<Longrightarrow> return_pmf (l, u \\<oplus> t) \\<in> K st\" |\n  \\<comment> \\<open>Discrete transitions\\<close> action:\n  \"st \\<in> S \\<Longrightarrow> st = (l, u) \\<Longrightarrow> (l, g, \\<mu>) \\<in> trans_of A \\<Longrightarrow> u \\<turnstile> g\n  \\<Longrightarrow> map_pmf (\\<lambda> (X, l). (l, ([X := 0]u))) \\<mu> \\<in> K st\" |\n  \\<comment> \\<open>Self loops -- Note that this does not assume \\<open>st \\<in> S\\<close>\\<close> loop:\n  \"return_pmf st \\<in> K st\""], ["", "declare K.intros[intro]"], ["", "sublocale MDP: Markov_Decision_Process K"], ["proof (prove)\ngoal (1 subgoal):\n 1. Markov_Decision_Process K", "by (standard, auto)"], ["", "end"], ["", "(* Probabilistic Timed Automaton *)"], ["", "section \\<open>Constructing the Corresponding Finite MDP on Regions\\<close>"], ["", "locale Probabilistic_Timed_Automaton_Regions =\n  Probabilistic_Timed_Automaton A + Regions \\<X>\n  for A :: \"('c, t, 's) pta\" +\n  \\<comment> \\<open>The following are necessary to obtain a \\<open>finite\\<close> MDP\\<close>\n  assumes finite: \"finite \\<X>\" \"finite L\" \"finite (trans_of A)\"\n  assumes not_trivial: \"\\<exists> l \\<in> L. \\<exists> u \\<in> V. u \\<turnstile> inv_of A l\"\n  assumes valid: \"valid_abstraction A \\<X> k\"\nbegin"], ["", "lemmas finite_\\<R> = finite_\\<R>[OF finite(1), of k, folded \\<R>_def]"], ["", "subsection \\<open>Syntactic Definition\\<close>"], ["", "text_raw \\<open> \\label{sem:mdprg} \\<close>"], ["", "definition \"\\<S> \\<equiv> {(l, R) . l \\<in> L \\<and> R \\<in> \\<R> \\<and> R \\<subseteq> {u. u \\<turnstile> inv_of A l}}\""], ["", "(* XXX Move definition of V somewhere else *)"], ["", "lemma S_alt_def: \"S = {(l, u) . l \\<in> L \\<and> u \\<in> V \\<and> u \\<turnstile> inv_of A l}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S =\n    {(l, u).\n     l \\<in> L \\<and> u \\<in> V \\<and> u \\<turnstile> PTA.inv_of A l}", "unfolding V_def S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(l, u).\n     l \\<in> L \\<and>\n     (\\<forall>x\\<in>\\<X>. 0 \\<le> u x) \\<and>\n     u \\<turnstile> PTA.inv_of A l} =\n    {(l, u).\n     l \\<in> L \\<and>\n     u \\<in> {v. \\<forall>x\\<in>\\<X>. 0 \\<le> v x} \\<and>\n     u \\<turnstile> PTA.inv_of A l}", "by auto"], ["", "text \\<open>\n  Note how we relax the definition to allow more transitions in the first case.\n  To obtain a more compact MDP the commented out version can be used an proved equivalent.\n\\<close>"], ["", "inductive_set\n \\<K> :: \"('s * ('c, t) cval set) \\<Rightarrow> ('s * ('c, t) cval set) pmf set\" for st :: \"('s * ('c, t) cval set)\"\nwhere\n  (* \n  -- \"Passage of time\" delay:\n  \"st \\<in> \\<S> \\<Longrightarrow> st = (l,R) \\<Longrightarrow> succ \\<R> R \\<subseteq> \\<lbrace>inv_of A l\\<rbrace> \\<Longrightarrow> return_pmf (l, succ \\<R> R) \\<in> \\<K> st\" |\n  *)\n   \\<comment> \\<open>Passage of time\\<close> delay:\n  \"st \\<in> \\<S> \\<Longrightarrow> st = (l,R) \\<Longrightarrow> R' \\<in> Succ \\<R> R \\<Longrightarrow> R' \\<subseteq> \\<lbrace>inv_of A l\\<rbrace> \\<Longrightarrow> return_pmf (l, R') \\<in> \\<K> st\" |\n  \\<comment> \\<open>Discrete transitions\\<close> action:\n  \"st \\<in> \\<S> \\<Longrightarrow> st = (l, R ) \\<Longrightarrow> (l, g, \\<mu>) \\<in> trans_of A \\<Longrightarrow> R \\<subseteq> \\<lbrace>g\\<rbrace>\n  \\<Longrightarrow> map_pmf (\\<lambda> (X, l). (l, region_set' R (SOME r. set r = X) 0)) \\<mu> \\<in> \\<K> st\" |\n  \\<comment> \\<open>Self loops -- Note that this does not assume \\<open>st \\<in> \\<S>\\<close>\\<close> loop:\n  \"return_pmf st \\<in> \\<K> st\""], ["", "lemmas [intro] = \\<K>.intros"], ["", "subsection \\<open>Many Closure Properties\\<close>"], ["", "lemma transition_def:\n  \"(A \\<turnstile> l \\<longrightarrow>\\<^bsup>g,\\<mu>,X\\<^esup> l') = ((l, g, \\<mu>) \\<in> trans_of A \\<and> (X, l') \\<in> \\<mu>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<turnstile> l \\<longrightarrow>\\<^bsup>g,\\<mu>,X\\<^esup> l' =\n    ((l, g, \\<mu>) \\<in> PTA.trans_of A \\<and> (X, l') \\<in> set_pmf \\<mu>)", "unfolding Edges_def edges_def trans_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((l, g, \\<mu>, X, l')\n     \\<in> \\<Union>\n            {case t of\n             (l, g, p) \\<Rightarrow>\n               {(l, g, p, X, l') |X l'. (X, l') \\<in> set_pmf p} |\n             t. t \\<in> fst A}) =\n    ((l, g, \\<mu>) \\<in> fst A \\<and> (X, l') \\<in> set_pmf \\<mu>)", "by auto"], ["", "lemma transitionI[intro]:\n  \"A \\<turnstile> l \\<longrightarrow>\\<^bsup>g,\\<mu>,X\\<^esup> l'\" if \"(l, g, \\<mu>) \\<in> trans_of A\" \"(X, l') \\<in> \\<mu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<turnstile> l \\<longrightarrow>\\<^bsup>g,\\<mu>,X\\<^esup> l'", "using that"], ["proof (prove)\nusing this:\n  (l, g, \\<mu>) \\<in> PTA.trans_of A\n  (X, l') \\<in> set_pmf \\<mu>\n\ngoal (1 subgoal):\n 1. A \\<turnstile> l \\<longrightarrow>\\<^bsup>g,\\<mu>,X\\<^esup> l'", "unfolding transition_def"], ["proof (prove)\nusing this:\n  (l, g, \\<mu>) \\<in> PTA.trans_of A\n  (X, l') \\<in> set_pmf \\<mu>\n\ngoal (1 subgoal):\n 1. (l, g, \\<mu>) \\<in> PTA.trans_of A \\<and> (X, l') \\<in> set_pmf \\<mu>", ".."], ["", "lemma transitionD[dest]:\n  \"(l, g, \\<mu>) \\<in> trans_of A\" \"(X, l') \\<in> \\<mu>\" if \"A \\<turnstile> l \\<longrightarrow>\\<^bsup>g,\\<mu>,X\\<^esup> l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l, g, \\<mu>) \\<in> PTA.trans_of A &&& (X, l') \\<in> set_pmf \\<mu>", "using that"], ["proof (prove)\nusing this:\n  A \\<turnstile> l \\<longrightarrow>\\<^bsup>g,\\<mu>,X\\<^esup> l'\n\ngoal (1 subgoal):\n 1. (l, g, \\<mu>) \\<in> PTA.trans_of A &&& (X, l') \\<in> set_pmf \\<mu>", "unfolding transition_def"], ["proof (prove)\nusing this:\n  (l, g, \\<mu>) \\<in> PTA.trans_of A \\<and> (X, l') \\<in> set_pmf \\<mu>\n\ngoal (1 subgoal):\n 1. (l, g, \\<mu>) \\<in> PTA.trans_of A &&& (X, l') \\<in> set_pmf \\<mu>", "by auto"], ["", "lemma bex_Edges:\n  \"(\\<exists> x \\<in> Edges A. P x) = (\\<exists> l g \\<mu> X l'. A \\<turnstile> l \\<longrightarrow>\\<^bsup>g,\\<mu>,X\\<^esup> l' \\<and> P (l, g, \\<mu>, X, l'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x\\<in>Edges A. P x) =\n    (\\<exists>l g \\<mu> X l'.\n        A \\<turnstile> l \\<longrightarrow>\\<^bsup>g,\\<mu>,X\\<^esup> l' \\<and>\n        P (l, g, \\<mu>, X, l'))", "by fastforce"], ["", "(* XXX Move *)"], ["", "lemma L_trans[intro]:\n  assumes \"(l, g, \\<mu>) \\<in> trans_of A\" \"(X, l') \\<in> \\<mu>\"\n  shows \"l \\<in> L\" \"l' \\<in> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<in> L &&& l' \\<in> L", "using assms"], ["proof (prove)\nusing this:\n  (l, g, \\<mu>) \\<in> PTA.trans_of A\n  (X, l') \\<in> set_pmf \\<mu>\n\ngoal (1 subgoal):\n 1. l \\<in> L &&& l' \\<in> L", "unfolding L_def locations_def"], ["proof (prove)\nusing this:\n  (l, g, \\<mu>) \\<in> PTA.trans_of A\n  (X, l') \\<in> set_pmf \\<mu>\n\ngoal (1 subgoal):\n 1. l \\<in> fst ` Edges A \\<union>\n            (snd \\<circ> snd \\<circ> snd \\<circ> snd) ` Edges A &&&\n    l' \\<in> fst ` Edges A \\<union>\n             (snd \\<circ> snd \\<circ> snd \\<circ> snd) ` Edges A", "by (auto simp: image_iff bex_Edges transition_def)"], ["", "lemma transition_\\<X>:\n  \"X \\<subseteq> \\<X>\" if \"A \\<turnstile> l \\<longrightarrow>\\<^bsup>g,\\<mu>,X\\<^esup> l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<subseteq> \\<X>", "using that"], ["proof (prove)\nusing this:\n  A \\<turnstile> l \\<longrightarrow>\\<^bsup>g,\\<mu>,X\\<^esup> l'\n\ngoal (1 subgoal):\n 1. X \\<subseteq> \\<X>", "unfolding \\<X>_def collect_clkvt_def clkp_set_def"], ["proof (prove)\nusing this:\n  A \\<turnstile> l \\<longrightarrow>\\<^bsup>g,\\<mu>,X\\<^esup> l'\n\ngoal (1 subgoal):\n 1. X \\<subseteq> fst `\n                  (PTA.collect_clki (PTA.inv_of A) \\<union>\n                   PTA.collect_clkt (PTA.trans_of A)) \\<union>\n                  \\<Union>\n                   ((fst \\<circ> snd \\<circ> snd \\<circ> snd) ` Edges A)", "by auto"], ["", "lemma admissible_targets_alt:\n  \"A \\<turnstile> l \\<longrightarrow>\\<^bsup>g,\\<mu>,X\\<^esup> l' \\<Longrightarrow> \\<lbrace>g\\<rbrace>\\<^bsub>X \\<rightarrow> 0\\<^esub> \\<subseteq> \\<lbrace>inv_of A l'\\<rbrace>\"\n  \"A \\<turnstile> l \\<longrightarrow>\\<^bsup>g,\\<mu>,X\\<^esup> l' \\<Longrightarrow> X \\<subseteq> clocks A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<turnstile> l \\<longrightarrow>\\<^bsup>g,\\<mu>,X\\<^esup> l' \\<Longrightarrow>\n     {v. v \\<turnstile> g}\\<^bsub>X \\<rightarrow> 0\\<^esub>\n     \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l'}) &&&\n    (A \\<turnstile> l \\<longrightarrow>\\<^bsup>g,\\<mu>,X\\<^esup> l' \\<Longrightarrow>\n     X \\<subseteq> clocks A)", "by (intro admissible_targets; blast)+"], ["", "lemma V_reset_closed[intro]:\n  assumes \"u \\<in> V\"\n  shows \"[r \\<rightarrow> (d::nat)]u \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [r\\<rightarrow>real d]u \\<in> V", "using assms"], ["proof (prove)\nusing this:\n  u \\<in> V\n\ngoal (1 subgoal):\n 1. [r\\<rightarrow>real d]u \\<in> V", "unfolding V_def"], ["proof (prove)\nusing this:\n  u \\<in> {v. \\<forall>x\\<in>\\<X>. 0 \\<le> v x}\n\ngoal (1 subgoal):\n 1. [r\\<rightarrow>real d]u \\<in> {v. \\<forall>x\\<in>\\<X>. 0 \\<le> v x}", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>\\<X>. 0 \\<le> u x; x \\<in> \\<X>\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> ([r\\<rightarrow>real d]u) x", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>\\<X>. 0 \\<le> u x; x \\<in> \\<X>\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> ([r\\<rightarrow>real d]u) x", "by (cases \"x \\<in> set r\"; auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas V_reset_closed'[intro] = V_reset_closed[of _ _ 0, simplified]"], ["", "lemma regions_part_ex[intro]:\n  assumes \"u \\<in> V\"\n  shows \"u \\<in> [u]\\<^sub>\\<R>\" \"[u]\\<^sub>\\<R> \\<in> \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> [u]\\<^sub>\\<R> &&& [u]\\<^sub>\\<R> \\<in> \\<R>", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. u \\<in> [u]\\<^sub>\\<R>\n 2. [u]\\<^sub>\\<R> \\<in> \\<R>", "from assms regions_partition[OF meta_eq_to_obj_eq[OF \\<R>_def]]"], ["proof (chain)\npicking this:\n  u \\<in> V\n  \\<forall>x\\<in>\\<X>. 0 \\<le> ?u x \\<Longrightarrow>\n  \\<exists>!R. R \\<in> \\<R> \\<and> ?u \\<in> R", "have\n    \"\\<exists>!R. R \\<in> \\<R> \\<and> u \\<in> R\""], ["proof (prove)\nusing this:\n  u \\<in> V\n  \\<forall>x\\<in>\\<X>. 0 \\<le> ?u x \\<Longrightarrow>\n  \\<exists>!R. R \\<in> \\<R> \\<and> ?u \\<in> R\n\ngoal (1 subgoal):\n 1. \\<exists>!R. R \\<in> \\<R> \\<and> u \\<in> R", "unfolding V_def"], ["proof (prove)\nusing this:\n  u \\<in> {v. \\<forall>x\\<in>\\<X>. 0 \\<le> v x}\n  \\<forall>x\\<in>\\<X>. 0 \\<le> ?u x \\<Longrightarrow>\n  \\<exists>!R. R \\<in> \\<R> \\<and> ?u \\<in> R\n\ngoal (1 subgoal):\n 1. \\<exists>!R. R \\<in> \\<R> \\<and> u \\<in> R", "by auto"], ["proof (state)\nthis:\n  \\<exists>!R. R \\<in> \\<R> \\<and> u \\<in> R\n\ngoal (2 subgoals):\n 1. u \\<in> [u]\\<^sub>\\<R>\n 2. [u]\\<^sub>\\<R> \\<in> \\<R>", "then"], ["proof (chain)\npicking this:\n  \\<exists>!R. R \\<in> \\<R> \\<and> u \\<in> R", "show \"[u]\\<^sub>\\<R> \\<in> \\<R>\" \"u \\<in> [u]\\<^sub>\\<R>\""], ["proof (prove)\nusing this:\n  \\<exists>!R. R \\<in> \\<R> \\<and> u \\<in> R\n\ngoal (1 subgoal):\n 1. [u]\\<^sub>\\<R> \\<in> \\<R> &&& u \\<in> [u]\\<^sub>\\<R>", "using alpha_interp.region_unique_spec"], ["proof (prove)\nusing this:\n  \\<exists>!R. R \\<in> \\<R> \\<and> u \\<in> R\n  \\<lbrakk>?u \\<in> ?R; ?R \\<in> \\<R>\\<rbrakk>\n  \\<Longrightarrow> [?u]\\<^sub>\\<R> = ?R\n\ngoal (1 subgoal):\n 1. [u]\\<^sub>\\<R> \\<in> \\<R> &&& u \\<in> [u]\\<^sub>\\<R>", "by auto"], ["proof (state)\nthis:\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  u \\<in> [u]\\<^sub>\\<R>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rep_\\<R>_ex[intro]:\n  assumes \"R \\<in> \\<R>\"\n  shows \"(SOME u. u \\<in> R) \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME u. u \\<in> R) \\<in> R", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (SOME u. u \\<in> R) \\<in> R", "from assms region_not_empty[OF finite(1)]"], ["proof (chain)\npicking this:\n  R \\<in> \\<R>\n  Regions.valid_region \\<X> ?k ?I ?r \\<Longrightarrow>\n  \\<exists>u. u \\<in> Regions.region \\<X> ?I ?r", "have \"\\<exists> u. u \\<in> R\""], ["proof (prove)\nusing this:\n  R \\<in> \\<R>\n  Regions.valid_region \\<X> ?k ?I ?r \\<Longrightarrow>\n  \\<exists>u. u \\<in> Regions.region \\<X> ?I ?r\n\ngoal (1 subgoal):\n 1. \\<exists>u. u \\<in> R", "unfolding \\<R>_def"], ["proof (prove)\nusing this:\n  R \\<in> {Regions.region \\<X> I r |I r. Regions.valid_region \\<X> k I r}\n  Regions.valid_region \\<X> ?k ?I ?r \\<Longrightarrow>\n  \\<exists>u. u \\<in> Regions.region \\<X> ?I ?r\n\ngoal (1 subgoal):\n 1. \\<exists>u. u \\<in> R", "by auto"], ["proof (state)\nthis:\n  \\<exists>u. u \\<in> R\n\ngoal (1 subgoal):\n 1. (SOME u. u \\<in> R) \\<in> R", "then"], ["proof (chain)\npicking this:\n  \\<exists>u. u \\<in> R", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>u. u \\<in> R\n\ngoal (1 subgoal):\n 1. (SOME u. u \\<in> R) \\<in> R", ".."], ["proof (state)\nthis:\n  (SOME u. u \\<in> R) \\<in> R\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma V_nn_closed[intro]:\n  \"u \\<in> V \\<Longrightarrow> t \\<ge> 0 \\<Longrightarrow> u \\<oplus> t \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> V; (0::'a) \\<le> t\\<rbrakk>\n    \\<Longrightarrow> u \\<oplus> t \\<in> V", "unfolding V_def cval_add_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> {v. \\<forall>x\\<in>\\<X>. (0::'a) \\<le> v x};\n     (0::'a) \\<le> t\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x. u x + t)\n                      \\<in> {v. \\<forall>x\\<in>\\<X>. (0::'a) \\<le> v x}", "by auto"], ["", "lemma K_S_closed[intro]:\n  assumes \"\\<mu> \\<in> K s\" \"s' \\<in> \\<mu>\" \"s \\<in> S\"\n  shows \"s' \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s' \\<in> S", "using assms"], ["proof (prove)\nusing this:\n  \\<mu> \\<in> K s\n  s' \\<in> set_pmf \\<mu>\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. s' \\<in> S", "by (cases rule: K.cases, auto simp: S_alt_def dest: admissible_targets[unfolded zone_set_def])"], ["", "lemma S_V[intro]:\n  \"(l, u) \\<in> S \\<Longrightarrow> u \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l, u) \\<in> S \\<Longrightarrow> u \\<in> V", "unfolding S_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (l, u)\n    \\<in> {(l, u).\n           l \\<in> L \\<and>\n           u \\<in> V \\<and> u \\<turnstile> PTA.inv_of A l} \\<Longrightarrow>\n    u \\<in> V", "by auto"], ["", "lemma L_V[intro]:\n  \"(l, u) \\<in> S \\<Longrightarrow> l \\<in> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l, u) \\<in> S \\<Longrightarrow> l \\<in> L", "unfolding S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (l, u)\n    \\<in> {(l, u).\n           l \\<in> L \\<and>\n           (\\<forall>x\\<in>\\<X>. 0 \\<le> u x) \\<and>\n           u \\<turnstile> PTA.inv_of A l} \\<Longrightarrow>\n    l \\<in> L", "by auto"], ["", "lemma \\<S>_V[intro]:\n  \"(l, R) \\<in> \\<S> \\<Longrightarrow> R \\<in> \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l, R) \\<in> \\<S> \\<Longrightarrow> R \\<in> \\<R>", "unfolding \\<S>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (l, R)\n    \\<in> {(l, R).\n           l \\<in> L \\<and>\n           R \\<in> \\<R> \\<and>\n           R \\<subseteq> {u. u \\<turnstile> PTA.inv_of A\n       l}} \\<Longrightarrow>\n    R \\<in> \\<R>", "by auto"], ["", "lemma admissible_targets':\n  assumes \"(l, g, \\<mu>) \\<in> trans_of A\" \"(X, l') \\<in> \\<mu>\" \"R \\<subseteq> \\<lbrace>g\\<rbrace>\"\n  shows \"region_set' R (SOME r. set r = X) 0 \\<subseteq> \\<lbrace>inv_of A l'\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [X::=0]R \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l'}", "using admissible_targets(1)[OF assms(1,2)] assms(3)"], ["proof (prove)\nusing this:\n  {v. v \\<turnstile> g}\\<^bsub>X \\<rightarrow> 0\\<^esub>\n  \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l'}\n  R \\<subseteq> {v. v \\<turnstile> g}\n\ngoal (1 subgoal):\n 1. [X::=0]R \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l'}", "unfolding region_set'_def zone_set_def"], ["proof (prove)\nusing this:\n  {[(SOME r. set r = X)\\<rightarrow>0]u |u. u \\<in> {v. v \\<turnstile> g}}\n  \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l'}\n  R \\<subseteq> {v. v \\<turnstile> g}\n\ngoal (1 subgoal):\n 1. {[(SOME r. set r = X)\\<rightarrow>0]v |v. v \\<in> R}\n    \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l'}", "by auto"], ["", "subsection \\<open>The Region Graph is a Finite MDP\\<close>"], ["", "lemma \\<S>_finite:\n  \"finite \\<S>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite \\<S>", "using finite finite_\\<R>"], ["proof (prove)\nusing this:\n  finite \\<X>\n  finite L\n  finite (PTA.trans_of A)\n  finite \\<R>\n\ngoal (1 subgoal):\n 1. finite \\<S>", "unfolding \\<S>_def"], ["proof (prove)\nusing this:\n  finite \\<X>\n  finite L\n  finite (PTA.trans_of A)\n  finite \\<R>\n\ngoal (1 subgoal):\n 1. finite\n     {(l, R).\n      l \\<in> L \\<and>\n      R \\<in> \\<R> \\<and> R \\<subseteq> {u. u \\<turnstile> PTA.inv_of A l}}", "by auto"], ["", "lemma \\<K>_finite:\n  \"finite (\\<K> st)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<K> st)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (\\<K> st)", "let ?B1 = \"{(R', l, R). st \\<in> \\<S> \\<and> st = (l, R) \\<and> R' \\<in> Succ \\<R> R \\<and> R' \\<subseteq> \\<lbrace>inv_of A l\\<rbrace>}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite (\\<K> st)", "let ?S1 = \"(\\<lambda>(R', l, R). return_pmf (l, R')) ` ?B1\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite (\\<K> st)", "let ?S1 = \"{return_pmf (l, R') | R' l R. st \\<in> \\<S> \\<and> st = (l, R) \\<and> R' \\<in> Succ \\<R> R \\<and> R' \\<subseteq> \\<lbrace>inv_of A l\\<rbrace>}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite (\\<K> st)", "let ?S2 = \"{map_pmf (\\<lambda> (X, l). (l, region_set' R (SOME r. set r = X) 0)) \\<mu>\n             | R \\<mu>. \\<exists> l g. st \\<in> \\<S> \\<and> st = (l, R ) \\<and> (l, g, \\<mu>) \\<in> trans_of A \\<and> R \\<subseteq> \\<lbrace>g\\<rbrace>}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite (\\<K> st)", "have \"?B1 \\<subseteq> {(R', l, R). R' \\<in> \\<R> \\<and> (l, R) \\<in> \\<S> }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(R', l, R).\n     st \\<in> \\<S> \\<and>\n     st = (l, R) \\<and>\n     R' \\<in> Succ \\<R> R \\<and>\n     R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}}\n    \\<subseteq> {(R', l, R). R' \\<in> \\<R> \\<and> (l, R) \\<in> \\<S>}", "unfolding \\<S>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(R', l, R).\n     st \\<in> {(l, R).\n               l \\<in> L \\<and>\n               R \\<in> \\<R> \\<and>\n               R \\<subseteq> {u. u \\<turnstile> PTA.inv_of A l}} \\<and>\n     st = (l, R) \\<and>\n     R' \\<in> Succ \\<R> R \\<and>\n     R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}}\n    \\<subseteq> {(R', l, R).\n                 R' \\<in> \\<R> \\<and>\n                 (l, R)\n                 \\<in> {(l, R).\n                        l \\<in> L \\<and>\n                        R \\<in> \\<R> \\<and>\n                        R \\<subseteq> {u. u \\<turnstile> PTA.inv_of A l}}}", "by auto"], ["proof (state)\nthis:\n  {(R', l, R).\n   st \\<in> \\<S> \\<and>\n   st = (l, R) \\<and>\n   R' \\<in> Succ \\<R> R \\<and>\n   R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}}\n  \\<subseteq> {(R', l, R). R' \\<in> \\<R> \\<and> (l, R) \\<in> \\<S>}\n\ngoal (1 subgoal):\n 1. finite (\\<K> st)", "with \\<S>_finite finite_\\<R>"], ["proof (chain)\npicking this:\n  finite \\<S>\n  finite \\<R>\n  {(R', l, R).\n   st \\<in> \\<S> \\<and>\n   st = (l, R) \\<and>\n   R' \\<in> Succ \\<R> R \\<and>\n   R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}}\n  \\<subseteq> {(R', l, R). R' \\<in> \\<R> \\<and> (l, R) \\<in> \\<S>}", "have \"finite ?B1\""], ["proof (prove)\nusing this:\n  finite \\<S>\n  finite \\<R>\n  {(R', l, R).\n   st \\<in> \\<S> \\<and>\n   st = (l, R) \\<and>\n   R' \\<in> Succ \\<R> R \\<and>\n   R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}}\n  \\<subseteq> {(R', l, R). R' \\<in> \\<R> \\<and> (l, R) \\<in> \\<S>}\n\ngoal (1 subgoal):\n 1. finite\n     {(R', l, R).\n      st \\<in> \\<S> \\<and>\n      st = (l, R) \\<and>\n      R' \\<in> Succ \\<R> R \\<and>\n      R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}}", "by - (rule finite_subset, auto)"], ["proof (state)\nthis:\n  finite\n   {(R', l, R).\n    st \\<in> \\<S> \\<and>\n    st = (l, R) \\<and>\n    R' \\<in> Succ \\<R> R \\<and>\n    R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}}\n\ngoal (1 subgoal):\n 1. finite (\\<K> st)", "moreover"], ["proof (state)\nthis:\n  finite\n   {(R', l, R).\n    st \\<in> \\<S> \\<and>\n    st = (l, R) \\<and>\n    R' \\<in> Succ \\<R> R \\<and>\n    R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}}\n\ngoal (1 subgoal):\n 1. finite (\\<K> st)", "have \"?S1 = (\\<lambda>(R', l, R). return_pmf (l, R')) ` ?B1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {uu_.\n     \\<exists>R' l R.\n        uu_ = return_pmf (l, R') \\<and>\n        st \\<in> \\<S> \\<and>\n        st = (l, R) \\<and>\n        R' \\<in> Succ \\<R> R \\<and>\n        R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}} =\n    (\\<lambda>(R', l, R). return_pmf (l, R')) `\n    {(R', l, R).\n     st \\<in> \\<S> \\<and>\n     st = (l, R) \\<and>\n     R' \\<in> Succ \\<R> R \\<and>\n     R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}}", "by (auto simp: image_def)"], ["proof (state)\nthis:\n  {uu_.\n   \\<exists>R' l R.\n      uu_ = return_pmf (l, R') \\<and>\n      st \\<in> \\<S> \\<and>\n      st = (l, R) \\<and>\n      R' \\<in> Succ \\<R> R \\<and>\n      R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}} =\n  (\\<lambda>(R', l, R). return_pmf (l, R')) `\n  {(R', l, R).\n   st \\<in> \\<S> \\<and>\n   st = (l, R) \\<and>\n   R' \\<in> Succ \\<R> R \\<and>\n   R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}}\n\ngoal (1 subgoal):\n 1. finite (\\<K> st)", "ultimately"], ["proof (chain)\npicking this:\n  finite\n   {(R', l, R).\n    st \\<in> \\<S> \\<and>\n    st = (l, R) \\<and>\n    R' \\<in> Succ \\<R> R \\<and>\n    R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}}\n  {uu_.\n   \\<exists>R' l R.\n      uu_ = return_pmf (l, R') \\<and>\n      st \\<in> \\<S> \\<and>\n      st = (l, R) \\<and>\n      R' \\<in> Succ \\<R> R \\<and>\n      R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}} =\n  (\\<lambda>(R', l, R). return_pmf (l, R')) `\n  {(R', l, R).\n   st \\<in> \\<S> \\<and>\n   st = (l, R) \\<and>\n   R' \\<in> Succ \\<R> R \\<and>\n   R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}}", "have *: \"finite ?S1\""], ["proof (prove)\nusing this:\n  finite\n   {(R', l, R).\n    st \\<in> \\<S> \\<and>\n    st = (l, R) \\<and>\n    R' \\<in> Succ \\<R> R \\<and>\n    R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}}\n  {uu_.\n   \\<exists>R' l R.\n      uu_ = return_pmf (l, R') \\<and>\n      st \\<in> \\<S> \\<and>\n      st = (l, R) \\<and>\n      R' \\<in> Succ \\<R> R \\<and>\n      R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}} =\n  (\\<lambda>(R', l, R). return_pmf (l, R')) `\n  {(R', l, R).\n   st \\<in> \\<S> \\<and>\n   st = (l, R) \\<and>\n   R' \\<in> Succ \\<R> R \\<and>\n   R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}}\n\ngoal (1 subgoal):\n 1. finite\n     {uu_.\n      \\<exists>R' l R.\n         uu_ = return_pmf (l, R') \\<and>\n         st \\<in> \\<S> \\<and>\n         st = (l, R) \\<and>\n         R' \\<in> Succ \\<R> R \\<and>\n         R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}}", "by auto"], ["proof (state)\nthis:\n  finite\n   {uu_.\n    \\<exists>R' l R.\n       uu_ = return_pmf (l, R') \\<and>\n       st \\<in> \\<S> \\<and>\n       st = (l, R) \\<and>\n       R' \\<in> Succ \\<R> R \\<and>\n       R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}}\n\ngoal (1 subgoal):\n 1. finite (\\<K> st)", "have \"{\\<mu>. \\<exists>l g. (l, g, \\<mu>) \\<in> PTA.trans_of A} = ((\\<lambda> (l, g, \\<mu>). \\<mu>) ` PTA.trans_of A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<mu>. \\<exists>l g. (l, g, \\<mu>) \\<in> PTA.trans_of A} =\n    (\\<lambda>(l, g, \\<mu>). \\<mu>) ` PTA.trans_of A", "by force"], ["proof (state)\nthis:\n  {\\<mu>. \\<exists>l g. (l, g, \\<mu>) \\<in> PTA.trans_of A} =\n  (\\<lambda>(l, g, \\<mu>). \\<mu>) ` PTA.trans_of A\n\ngoal (1 subgoal):\n 1. finite (\\<K> st)", "with finite(3) finite_\\<R>"], ["proof (chain)\npicking this:\n  finite (PTA.trans_of A)\n  finite \\<R>\n  {\\<mu>. \\<exists>l g. (l, g, \\<mu>) \\<in> PTA.trans_of A} =\n  (\\<lambda>(l, g, \\<mu>). \\<mu>) ` PTA.trans_of A", "have \"finite {(R, \\<mu>). \\<exists> l g. R \\<in> \\<R> \\<and> (l, g, \\<mu>) \\<in> trans_of A}\""], ["proof (prove)\nusing this:\n  finite (PTA.trans_of A)\n  finite \\<R>\n  {\\<mu>. \\<exists>l g. (l, g, \\<mu>) \\<in> PTA.trans_of A} =\n  (\\<lambda>(l, g, \\<mu>). \\<mu>) ` PTA.trans_of A\n\ngoal (1 subgoal):\n 1. finite\n     {(R, \\<mu>).\n      \\<exists>l g. R \\<in> \\<R> \\<and> (l, g, \\<mu>) \\<in> PTA.trans_of A}", "by auto"], ["proof (state)\nthis:\n  finite\n   {(R, \\<mu>).\n    \\<exists>l g. R \\<in> \\<R> \\<and> (l, g, \\<mu>) \\<in> PTA.trans_of A}\n\ngoal (1 subgoal):\n 1. finite (\\<K> st)", "moreover"], ["proof (state)\nthis:\n  finite\n   {(R, \\<mu>).\n    \\<exists>l g. R \\<in> \\<R> \\<and> (l, g, \\<mu>) \\<in> PTA.trans_of A}\n\ngoal (1 subgoal):\n 1. finite (\\<K> st)", "have\n    \"{(R, \\<mu>). \\<exists> l g. st \\<in> \\<S> \\<and> st = (l, R ) \\<and> (l, g, \\<mu>) \\<in> trans_of A \\<and> R \\<subseteq> \\<lbrace>g\\<rbrace>} \\<subseteq> \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(R, \\<mu>).\n     \\<exists>l g.\n        st \\<in> \\<S> \\<and>\n        st = (l, R) \\<and>\n        (l, g, \\<mu>) \\<in> PTA.trans_of A \\<and>\n        R \\<subseteq> {v. v \\<turnstile> g}}\n    \\<subseteq> {(R, \\<mu>).\n                 \\<exists>l g.\n                    R \\<in> \\<R> \\<and> (l, g, \\<mu>) \\<in> PTA.trans_of A}", "unfolding \\<S>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(R, \\<mu>).\n     \\<exists>l g.\n        st \\<in> {(l, R).\n                  l \\<in> L \\<and>\n                  R \\<in> \\<R> \\<and>\n                  R \\<subseteq> {u. u \\<turnstile> PTA.inv_of A l}} \\<and>\n        st = (l, R) \\<and>\n        (l, g, \\<mu>) \\<in> PTA.trans_of A \\<and>\n        R \\<subseteq> {v. v \\<turnstile> g}}\n    \\<subseteq> {(R, \\<mu>).\n                 \\<exists>l g.\n                    R \\<in> \\<R> \\<and> (l, g, \\<mu>) \\<in> PTA.trans_of A}", "by fastforce"], ["proof (state)\nthis:\n  {(R, \\<mu>).\n   \\<exists>l g.\n      st \\<in> \\<S> \\<and>\n      st = (l, R) \\<and>\n      (l, g, \\<mu>) \\<in> PTA.trans_of A \\<and>\n      R \\<subseteq> {v. v \\<turnstile> g}}\n  \\<subseteq> {(R, \\<mu>).\n               \\<exists>l g.\n                  R \\<in> \\<R> \\<and> (l, g, \\<mu>) \\<in> PTA.trans_of A}\n\ngoal (1 subgoal):\n 1. finite (\\<K> st)", "ultimately"], ["proof (chain)\npicking this:\n  finite\n   {(R, \\<mu>).\n    \\<exists>l g. R \\<in> \\<R> \\<and> (l, g, \\<mu>) \\<in> PTA.trans_of A}\n  {(R, \\<mu>).\n   \\<exists>l g.\n      st \\<in> \\<S> \\<and>\n      st = (l, R) \\<and>\n      (l, g, \\<mu>) \\<in> PTA.trans_of A \\<and>\n      R \\<subseteq> {v. v \\<turnstile> g}}\n  \\<subseteq> {(R, \\<mu>).\n               \\<exists>l g.\n                  R \\<in> \\<R> \\<and> (l, g, \\<mu>) \\<in> PTA.trans_of A}", "have **:\n    \"finite {(R, \\<mu>). \\<exists> l g. st \\<in> \\<S> \\<and> st = (l, R ) \\<and> (l, g, \\<mu>) \\<in> trans_of A \\<and> R \\<subseteq> \\<lbrace>g\\<rbrace>}\""], ["proof (prove)\nusing this:\n  finite\n   {(R, \\<mu>).\n    \\<exists>l g. R \\<in> \\<R> \\<and> (l, g, \\<mu>) \\<in> PTA.trans_of A}\n  {(R, \\<mu>).\n   \\<exists>l g.\n      st \\<in> \\<S> \\<and>\n      st = (l, R) \\<and>\n      (l, g, \\<mu>) \\<in> PTA.trans_of A \\<and>\n      R \\<subseteq> {v. v \\<turnstile> g}}\n  \\<subseteq> {(R, \\<mu>).\n               \\<exists>l g.\n                  R \\<in> \\<R> \\<and> (l, g, \\<mu>) \\<in> PTA.trans_of A}\n\ngoal (1 subgoal):\n 1. finite\n     {(R, \\<mu>).\n      \\<exists>l g.\n         st \\<in> \\<S> \\<and>\n         st = (l, R) \\<and>\n         (l, g, \\<mu>) \\<in> PTA.trans_of A \\<and>\n         R \\<subseteq> {v. v \\<turnstile> g}}", "unfolding \\<S>_def"], ["proof (prove)\nusing this:\n  finite\n   {(R, \\<mu>).\n    \\<exists>l g. R \\<in> \\<R> \\<and> (l, g, \\<mu>) \\<in> PTA.trans_of A}\n  {(R, \\<mu>).\n   \\<exists>l g.\n      st \\<in> {(l, R).\n                l \\<in> L \\<and>\n                R \\<in> \\<R> \\<and>\n                R \\<subseteq> {u. u \\<turnstile> PTA.inv_of A l}} \\<and>\n      st = (l, R) \\<and>\n      (l, g, \\<mu>) \\<in> PTA.trans_of A \\<and>\n      R \\<subseteq> {v. v \\<turnstile> g}}\n  \\<subseteq> {(R, \\<mu>).\n               \\<exists>l g.\n                  R \\<in> \\<R> \\<and> (l, g, \\<mu>) \\<in> PTA.trans_of A}\n\ngoal (1 subgoal):\n 1. finite\n     {(R, \\<mu>).\n      \\<exists>l g.\n         st \\<in> {(l, R).\n                   l \\<in> L \\<and>\n                   R \\<in> \\<R> \\<and>\n                   R \\<subseteq> {u. u \\<turnstile> PTA.inv_of A l}} \\<and>\n         st = (l, R) \\<and>\n         (l, g, \\<mu>) \\<in> PTA.trans_of A \\<and>\n         R \\<subseteq> {v. v \\<turnstile> g}}", "by (blast intro: finite_subset)"], ["proof (state)\nthis:\n  finite\n   {(R, \\<mu>).\n    \\<exists>l g.\n       st \\<in> \\<S> \\<and>\n       st = (l, R) \\<and>\n       (l, g, \\<mu>) \\<in> PTA.trans_of A \\<and>\n       R \\<subseteq> {v. v \\<turnstile> g}}\n\ngoal (1 subgoal):\n 1. finite (\\<K> st)", "then"], ["proof (chain)\npicking this:\n  finite\n   {(R, \\<mu>).\n    \\<exists>l g.\n       st \\<in> \\<S> \\<and>\n       st = (l, R) \\<and>\n       (l, g, \\<mu>) \\<in> PTA.trans_of A \\<and>\n       R \\<subseteq> {v. v \\<turnstile> g}}", "have \"finite ?S2\""], ["proof (prove)\nusing this:\n  finite\n   {(R, \\<mu>).\n    \\<exists>l g.\n       st \\<in> \\<S> \\<and>\n       st = (l, R) \\<and>\n       (l, g, \\<mu>) \\<in> PTA.trans_of A \\<and>\n       R \\<subseteq> {v. v \\<turnstile> g}}\n\ngoal (1 subgoal):\n 1. finite\n     {map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu> |R \\<mu>.\n      \\<exists>l g.\n         st \\<in> \\<S> \\<and>\n         st = (l, R) \\<and>\n         (l, g, \\<mu>) \\<in> PTA.trans_of A \\<and>\n         R \\<subseteq> {v. v \\<turnstile> g}}", "unfolding \\<S>_def"], ["proof (prove)\nusing this:\n  finite\n   {(R, \\<mu>).\n    \\<exists>l g.\n       st \\<in> {(l, R).\n                 l \\<in> L \\<and>\n                 R \\<in> \\<R> \\<and>\n                 R \\<subseteq> {u. u \\<turnstile> PTA.inv_of A l}} \\<and>\n       st = (l, R) \\<and>\n       (l, g, \\<mu>) \\<in> PTA.trans_of A \\<and>\n       R \\<subseteq> {v. v \\<turnstile> g}}\n\ngoal (1 subgoal):\n 1. finite\n     {map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu> |R \\<mu>.\n      \\<exists>l g.\n         st \\<in> {(l, R).\n                   l \\<in> L \\<and>\n                   R \\<in> \\<R> \\<and>\n                   R \\<subseteq> {u. u \\<turnstile> PTA.inv_of A l}} \\<and>\n         st = (l, R) \\<and>\n         (l, g, \\<mu>) \\<in> PTA.trans_of A \\<and>\n         R \\<subseteq> {v. v \\<turnstile> g}}", "by auto"], ["proof (state)\nthis:\n  finite\n   {map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu> |R \\<mu>.\n    \\<exists>l g.\n       st \\<in> \\<S> \\<and>\n       st = (l, R) \\<and>\n       (l, g, \\<mu>) \\<in> PTA.trans_of A \\<and>\n       R \\<subseteq> {v. v \\<turnstile> g}}\n\ngoal (1 subgoal):\n 1. finite (\\<K> st)", "have \"\\<K> st = ?S1 \\<union> ?S2 \\<union> {return_pmf st}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<K> st =\n    {uu_.\n     \\<exists>R' l R.\n        uu_ = return_pmf (l, R') \\<and>\n        st \\<in> \\<S> \\<and>\n        st = (l, R) \\<and>\n        R' \\<in> Succ \\<R> R \\<and>\n        R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}} \\<union>\n    {map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu> |R \\<mu>.\n     \\<exists>l g.\n        st \\<in> \\<S> \\<and>\n        st = (l, R) \\<and>\n        (l, g, \\<mu>) \\<in> PTA.trans_of A \\<and>\n        R \\<subseteq> {v. v \\<turnstile> g}} \\<union>\n    {return_pmf st}", "by (safe, cases rule: \\<K>.cases, auto)"], ["proof (state)\nthis:\n  \\<K> st =\n  {uu_.\n   \\<exists>R' l R.\n      uu_ = return_pmf (l, R') \\<and>\n      st \\<in> \\<S> \\<and>\n      st = (l, R) \\<and>\n      R' \\<in> Succ \\<R> R \\<and>\n      R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}} \\<union>\n  {map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu> |R \\<mu>.\n   \\<exists>l g.\n      st \\<in> \\<S> \\<and>\n      st = (l, R) \\<and>\n      (l, g, \\<mu>) \\<in> PTA.trans_of A \\<and>\n      R \\<subseteq> {v. v \\<turnstile> g}} \\<union>\n  {return_pmf st}\n\ngoal (1 subgoal):\n 1. finite (\\<K> st)", "with * **"], ["proof (chain)\npicking this:\n  finite\n   {uu_.\n    \\<exists>R' l R.\n       uu_ = return_pmf (l, R') \\<and>\n       st \\<in> \\<S> \\<and>\n       st = (l, R) \\<and>\n       R' \\<in> Succ \\<R> R \\<and>\n       R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}}\n  finite\n   {(R, \\<mu>).\n    \\<exists>l g.\n       st \\<in> \\<S> \\<and>\n       st = (l, R) \\<and>\n       (l, g, \\<mu>) \\<in> PTA.trans_of A \\<and>\n       R \\<subseteq> {v. v \\<turnstile> g}}\n  \\<K> st =\n  {uu_.\n   \\<exists>R' l R.\n      uu_ = return_pmf (l, R') \\<and>\n      st \\<in> \\<S> \\<and>\n      st = (l, R) \\<and>\n      R' \\<in> Succ \\<R> R \\<and>\n      R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}} \\<union>\n  {map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu> |R \\<mu>.\n   \\<exists>l g.\n      st \\<in> \\<S> \\<and>\n      st = (l, R) \\<and>\n      (l, g, \\<mu>) \\<in> PTA.trans_of A \\<and>\n      R \\<subseteq> {v. v \\<turnstile> g}} \\<union>\n  {return_pmf st}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite\n   {uu_.\n    \\<exists>R' l R.\n       uu_ = return_pmf (l, R') \\<and>\n       st \\<in> \\<S> \\<and>\n       st = (l, R) \\<and>\n       R' \\<in> Succ \\<R> R \\<and>\n       R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}}\n  finite\n   {(R, \\<mu>).\n    \\<exists>l g.\n       st \\<in> \\<S> \\<and>\n       st = (l, R) \\<and>\n       (l, g, \\<mu>) \\<in> PTA.trans_of A \\<and>\n       R \\<subseteq> {v. v \\<turnstile> g}}\n  \\<K> st =\n  {uu_.\n   \\<exists>R' l R.\n      uu_ = return_pmf (l, R') \\<and>\n      st \\<in> \\<S> \\<and>\n      st = (l, R) \\<and>\n      R' \\<in> Succ \\<R> R \\<and>\n      R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}} \\<union>\n  {map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu> |R \\<mu>.\n   \\<exists>l g.\n      st \\<in> \\<S> \\<and>\n      st = (l, R) \\<and>\n      (l, g, \\<mu>) \\<in> PTA.trans_of A \\<and>\n      R \\<subseteq> {v. v \\<turnstile> g}} \\<union>\n  {return_pmf st}\n\ngoal (1 subgoal):\n 1. finite (\\<K> st)", "by auto"], ["proof (state)\nthis:\n  finite (\\<K> st)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* XXX Obsolete in here, move to Regions *)"], ["", "lemma \\<R>_not_empty:\n  \"\\<R> \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<R> \\<noteq> {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<R> \\<noteq> {}", "let ?r = \"{}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<R> \\<noteq> {}", "let ?I = \"\\<lambda> c. Const 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<R> \\<noteq> {}", "let ?R = \"region \\<X> ?I ?r\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<R> \\<noteq> {}", "have \"valid_region \\<X> k ?I ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Regions.valid_region \\<X> k (\\<lambda>c. Regions.intv.Const 0) {}", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. ?X\\<^sub>0 =\n    {x \\<in> \\<X>. \\<exists>d. Regions.intv.Const 0 = Regions.intv.Intv d}\n 2. refl_on ?X\\<^sub>0 {}\n 3. trans {}\n 4. total_on ?X\\<^sub>0 {}\n 5. \\<forall>x\\<in>\\<X>. Regions.valid_intv (k x) (Regions.intv.Const 0)", "show \"{} = {x \\<in> \\<X>. \\<exists>d. Const 0 = Intv d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} =\n    {x \\<in> \\<X>. \\<exists>d. Regions.intv.Const 0 = Regions.intv.Intv d}", "by auto"], ["proof (state)\nthis:\n  {} =\n  {x \\<in> \\<X>. \\<exists>d. Regions.intv.Const 0 = Regions.intv.Intv d}\n\ngoal (4 subgoals):\n 1. refl_on {} {}\n 2. trans {}\n 3. total_on {} {}\n 4. \\<forall>x\\<in>\\<X>. Regions.valid_intv (k x) (Regions.intv.Const 0)", "show \"refl_on {} {}\" and \"trans {}\" and \"total_on {} {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refl_on {} {} &&& trans {} &&& total_on {} {}", "unfolding trans_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. refl_on {} {} &&&\n    \\<forall>x y z.\n       (x, y) \\<in> {} \\<longrightarrow>\n       (y, z) \\<in> {} \\<longrightarrow> (x, z) \\<in> {} &&&\n    total_on {} {}", "by auto"], ["proof (state)\nthis:\n  refl_on {} {}\n  trans {}\n  total_on {} {}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>\\<X>. Regions.valid_intv (k x) (Regions.intv.Const 0)", "show \"\\<forall>x \\<in> \\<X>. Regions.valid_intv (k x) (Const 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>\\<X>. Regions.valid_intv (k x) (Regions.intv.Const 0)", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>\\<X>. Regions.valid_intv (k x) (Regions.intv.Const 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Regions.valid_region \\<X> k (\\<lambda>c. Regions.intv.Const 0) {}\n\ngoal (1 subgoal):\n 1. \\<R> \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  Regions.valid_region \\<X> k (\\<lambda>c. Regions.intv.Const 0) {}", "have \"?R \\<in> \\<R>\""], ["proof (prove)\nusing this:\n  Regions.valid_region \\<X> k (\\<lambda>c. Regions.intv.Const 0) {}\n\ngoal (1 subgoal):\n 1. Regions.region \\<X> (\\<lambda>c. Regions.intv.Const 0) {} \\<in> \\<R>", "unfolding \\<R>_def"], ["proof (prove)\nusing this:\n  Regions.valid_region \\<X> k (\\<lambda>c. Regions.intv.Const 0) {}\n\ngoal (1 subgoal):\n 1. Regions.region \\<X> (\\<lambda>c. Regions.intv.Const 0) {}\n    \\<in> {Regions.region \\<X> I r |I r. Regions.valid_region \\<X> k I r}", "by auto"], ["proof (state)\nthis:\n  Regions.region \\<X> (\\<lambda>c. Regions.intv.Const 0) {} \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<R> \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  Regions.region \\<X> (\\<lambda>c. Regions.intv.Const 0) {} \\<in> \\<R>", "show \"\\<R> \\<noteq> {}\""], ["proof (prove)\nusing this:\n  Regions.region \\<X> (\\<lambda>c. Regions.intv.Const 0) {} \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<R> \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  \\<R> \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<S>_not_empty:\n  \"\\<S> \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S> \\<noteq> {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<S> \\<noteq> {}", "from not_trivial"], ["proof (chain)\npicking this:\n  \\<exists>l\\<in>L. \\<exists>u\\<in>V. u \\<turnstile> PTA.inv_of A l", "obtain l u where st: \"l \\<in> L\" \"u \\<in> V\" \"u \\<turnstile> inv_of A l\""], ["proof (prove)\nusing this:\n  \\<exists>l\\<in>L. \\<exists>u\\<in>V. u \\<turnstile> PTA.inv_of A l\n\ngoal (1 subgoal):\n 1. (\\<And>l u.\n        \\<lbrakk>l \\<in> L; u \\<in> V;\n         u \\<turnstile> PTA.inv_of A l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  l \\<in> L\n  u \\<in> V\n  u \\<turnstile> PTA.inv_of A l\n\ngoal (1 subgoal):\n 1. \\<S> \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  l \\<in> L\n  u \\<in> V\n  u \\<turnstile> PTA.inv_of A l", "obtain R where R: \"R \\<in> \\<R>\" \"u \\<in> R\""], ["proof (prove)\nusing this:\n  l \\<in> L\n  u \\<in> V\n  u \\<turnstile> PTA.inv_of A l\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>R \\<in> \\<R>; u \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<R>_V"], ["proof (prove)\nusing this:\n  l \\<in> L\n  u \\<in> V\n  u \\<turnstile> PTA.inv_of A l\n  \\<Union> \\<R> = V\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>R \\<in> \\<R>; u \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  R \\<in> \\<R>\n  u \\<in> R\n\ngoal (1 subgoal):\n 1. \\<S> \\<noteq> {}", "from valid"], ["proof (chain)\npicking this:\n  PTA.valid_abstraction A \\<X> (\\<lambda>x. real (k x))", "have\n    \"\\<forall>(x, m)\\<in>collect_clock_pairs (inv_of A l). m \\<le> real (k x) \\<and> x \\<in> \\<X> \\<and> m \\<in> \\<nat>\""], ["proof (prove)\nusing this:\n  PTA.valid_abstraction A \\<X> (\\<lambda>x. real (k x))\n\ngoal (1 subgoal):\n 1. \\<forall>(x, m)\\<in>collect_clock_pairs (PTA.inv_of A l).\n       m \\<le> real (k x) \\<and> x \\<in> \\<X> \\<and> m \\<in> \\<nat>", "by (fastforce simp: clkp_set_def collect_clki_def)"], ["proof (state)\nthis:\n  \\<forall>(x, m)\\<in>collect_clock_pairs (PTA.inv_of A l).\n     m \\<le> real (k x) \\<and> x \\<in> \\<X> \\<and> m \\<in> \\<nat>\n\ngoal (1 subgoal):\n 1. \\<S> \\<noteq> {}", "from ccompatible[OF this, folded \\<R>_def] R st(3)"], ["proof (chain)\npicking this:\n  ccompatible \\<R> (PTA.inv_of A l)\n  R \\<in> \\<R>\n  u \\<in> R\n  u \\<turnstile> PTA.inv_of A l", "have\n    \"R \\<subseteq> \\<lbrace>inv_of A l\\<rbrace>\""], ["proof (prove)\nusing this:\n  ccompatible \\<R> (PTA.inv_of A l)\n  R \\<in> \\<R>\n  u \\<in> R\n  u \\<turnstile> PTA.inv_of A l\n\ngoal (1 subgoal):\n 1. R \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}", "unfolding ccompatible_def ccval_def"], ["proof (prove)\nusing this:\n  \\<forall>R\\<in>\\<R>.\n     R \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l} \\<or>\n     {v. v \\<turnstile> PTA.inv_of A l} \\<inter> R = {}\n  R \\<in> \\<R>\n  u \\<in> R\n  u \\<turnstile> PTA.inv_of A l\n\ngoal (1 subgoal):\n 1. R \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}", "by auto"], ["proof (state)\nthis:\n  R \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\n\ngoal (1 subgoal):\n 1. \\<S> \\<noteq> {}", "with st(1) R(1)"], ["proof (chain)\npicking this:\n  l \\<in> L\n  R \\<in> \\<R>\n  R \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}", "show ?thesis"], ["proof (prove)\nusing this:\n  l \\<in> L\n  R \\<in> \\<R>\n  R \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\n\ngoal (1 subgoal):\n 1. \\<S> \\<noteq> {}", "unfolding \\<S>_def"], ["proof (prove)\nusing this:\n  l \\<in> L\n  R \\<in> \\<R>\n  R \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\n\ngoal (1 subgoal):\n 1. {(l, R).\n     l \\<in> L \\<and>\n     R \\<in> \\<R> \\<and>\n     R \\<subseteq> {u. u \\<turnstile> PTA.inv_of A l}} \\<noteq>\n    {}", "by auto"], ["proof (state)\nthis:\n  \\<S> \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<K>_\\<S>_closed:\n  assumes \"s \\<in> \\<S>\"\n  shows \"(\\<Union>D\\<in>\\<K> s. set_pmf D) \\<subseteq> \\<S>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (set_pmf ` \\<K> s) \\<subseteq> \\<S>", "proof (safe, cases rule: \\<K>.cases, blast, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b x l R R'.\n       \\<lbrakk>x \\<in> \\<K> s; (a, b) \\<in> set_pmf x;\n        x = return_pmf (l, R'); s \\<in> \\<S>; s = (l, R);\n        R' \\<in> Succ \\<R> R;\n        R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> \\<S>\n 2. \\<And>a b x l R g \\<mu>.\n       \\<lbrakk>x \\<in> \\<K> s; (a, b) \\<in> set_pmf x;\n        x = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>; s \\<in> \\<S>;\n        s = (l, R); (l, g, \\<mu>) \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> \\<S>\n 3. \\<And>a b x.\n       \\<lbrakk>x \\<in> \\<K> s; (a, b) \\<in> set_pmf x;\n        x = return_pmf s\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> \\<S>", "case (1 x a b l R)"], ["proof (state)\nthis:\n  b \\<in> \\<K> s\n  (x, a) \\<in> set_pmf b\n  b = return_pmf (l, R'_)\n  s \\<in> \\<S>\n  s = (l, R)\n  R'_ \\<in> Succ \\<R> R\n  R'_ \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\n\ngoal (3 subgoals):\n 1. \\<And>a b x l R R'.\n       \\<lbrakk>x \\<in> \\<K> s; (a, b) \\<in> set_pmf x;\n        x = return_pmf (l, R'); s \\<in> \\<S>; s = (l, R);\n        R' \\<in> Succ \\<R> R;\n        R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> \\<S>\n 2. \\<And>a b x l R g \\<mu>.\n       \\<lbrakk>x \\<in> \\<K> s; (a, b) \\<in> set_pmf x;\n        x = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>; s \\<in> \\<S>;\n        s = (l, R); (l, g, \\<mu>) \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> \\<S>\n 3. \\<And>a b x.\n       \\<lbrakk>x \\<in> \\<K> s; (a, b) \\<in> set_pmf x;\n        x = return_pmf s\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> \\<S>", "then"], ["proof (chain)\npicking this:\n  b \\<in> \\<K> s\n  (x, a) \\<in> set_pmf b\n  b = return_pmf (l, R'_)\n  s \\<in> \\<S>\n  s = (l, R)\n  R'_ \\<in> Succ \\<R> R\n  R'_ \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}", "show ?case"], ["proof (prove)\nusing this:\n  b \\<in> \\<K> s\n  (x, a) \\<in> set_pmf b\n  b = return_pmf (l, R'_)\n  s \\<in> \\<S>\n  s = (l, R)\n  R'_ \\<in> Succ \\<R> R\n  R'_ \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\n\ngoal (1 subgoal):\n 1. (x, a) \\<in> \\<S>", "unfolding \\<S>_def"], ["proof (prove)\nusing this:\n  b \\<in> \\<K> s\n  (x, a) \\<in> set_pmf b\n  b = return_pmf (l, R'_)\n  s \\<in> {(l, R).\n           l \\<in> L \\<and>\n           R \\<in> \\<R> \\<and>\n           R \\<subseteq> {u. u \\<turnstile> PTA.inv_of A l}}\n  s = (l, R)\n  R'_ \\<in> Succ \\<R> R\n  R'_ \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\n\ngoal (1 subgoal):\n 1. (x, a)\n    \\<in> {(l, R).\n           l \\<in> L \\<and>\n           R \\<in> \\<R> \\<and>\n           R \\<subseteq> {u. u \\<turnstile> PTA.inv_of A l}}", "by (auto intro: alpha_interp.succ_ex(1))"], ["proof (state)\nthis:\n  (x, a) \\<in> \\<S>\n\ngoal (2 subgoals):\n 1. \\<And>a b x l R g \\<mu>.\n       \\<lbrakk>x \\<in> \\<K> s; (a, b) \\<in> set_pmf x;\n        x = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>; s \\<in> \\<S>;\n        s = (l, R); (l, g, \\<mu>) \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> \\<S>\n 2. \\<And>a b x.\n       \\<lbrakk>x \\<in> \\<K> s; (a, b) \\<in> set_pmf x;\n        x = return_pmf s\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> \\<S>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b x l R g \\<mu>.\n       \\<lbrakk>x \\<in> \\<K> s; (a, b) \\<in> set_pmf x;\n        x = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>; s \\<in> \\<S>;\n        s = (l, R); (l, g, \\<mu>) \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> \\<S>\n 2. \\<And>a b x.\n       \\<lbrakk>x \\<in> \\<K> s; (a, b) \\<in> set_pmf x;\n        x = return_pmf s\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> \\<S>", "case (3 a b x)"], ["proof (state)\nthis:\n  x \\<in> \\<K> s\n  (a, b) \\<in> set_pmf x\n  x = return_pmf s\n\ngoal (2 subgoals):\n 1. \\<And>a b x l R g \\<mu>.\n       \\<lbrakk>x \\<in> \\<K> s; (a, b) \\<in> set_pmf x;\n        x = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>; s \\<in> \\<S>;\n        s = (l, R); (l, g, \\<mu>) \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> \\<S>\n 2. \\<And>a b x.\n       \\<lbrakk>x \\<in> \\<K> s; (a, b) \\<in> set_pmf x;\n        x = return_pmf s\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> \\<S>", "with \\<open>s \\<in> \\<S>\\<close>"], ["proof (chain)\npicking this:\n  s \\<in> \\<S>\n  x \\<in> \\<K> s\n  (a, b) \\<in> set_pmf x\n  x = return_pmf s", "show ?case"], ["proof (prove)\nusing this:\n  s \\<in> \\<S>\n  x \\<in> \\<K> s\n  (a, b) \\<in> set_pmf x\n  x = return_pmf s\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> \\<S>", "by auto"], ["proof (state)\nthis:\n  (a, b) \\<in> \\<S>\n\ngoal (1 subgoal):\n 1. \\<And>a b x l R g \\<mu>.\n       \\<lbrakk>x \\<in> \\<K> s; (a, b) \\<in> set_pmf x;\n        x = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>; s \\<in> \\<S>;\n        s = (l, R); (l, g, \\<mu>) \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> \\<S>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b x l R g \\<mu>.\n       \\<lbrakk>x \\<in> \\<K> s; (a, b) \\<in> set_pmf x;\n        x = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>; s \\<in> \\<S>;\n        s = (l, R); (l, g, \\<mu>) \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> \\<S>", "case prems: (2 l' R' p l R g \\<mu>)"], ["proof (state)\nthis:\n  p \\<in> \\<K> s\n  (l', R') \\<in> set_pmf p\n  p = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>\n  s \\<in> \\<S>\n  s = (l, R)\n  (l, g, \\<mu>) \\<in> PTA.trans_of A\n  R \\<subseteq> {v. v \\<turnstile> g}\n\ngoal (1 subgoal):\n 1. \\<And>a b x l R g \\<mu>.\n       \\<lbrakk>x \\<in> \\<K> s; (a, b) \\<in> set_pmf x;\n        x = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>; s \\<in> \\<S>;\n        s = (l, R); (l, g, \\<mu>) \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> \\<S>", "then"], ["proof (chain)\npicking this:\n  p \\<in> \\<K> s\n  (l', R') \\<in> set_pmf p\n  p = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>\n  s \\<in> \\<S>\n  s = (l, R)\n  (l, g, \\<mu>) \\<in> PTA.trans_of A\n  R \\<subseteq> {v. v \\<turnstile> g}", "obtain X where *: \"(X, l') \\<in> set_pmf \\<mu>\" \"R' = region_set' R (SOME r. set r = X) 0\""], ["proof (prove)\nusing this:\n  p \\<in> \\<K> s\n  (l', R') \\<in> set_pmf p\n  p = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>\n  s \\<in> \\<S>\n  s = (l, R)\n  (l, g, \\<mu>) \\<in> PTA.trans_of A\n  R \\<subseteq> {v. v \\<turnstile> g}\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>(X, l') \\<in> set_pmf \\<mu>; R' = [X::=0]R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (X, l') \\<in> set_pmf \\<mu>\n  R' = [X::=0]R\n\ngoal (1 subgoal):\n 1. \\<And>a b x l R g \\<mu>.\n       \\<lbrakk>x \\<in> \\<K> s; (a, b) \\<in> set_pmf x;\n        x = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>; s \\<in> \\<S>;\n        s = (l, R); (l, g, \\<mu>) \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> \\<S>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (l', R') \\<in> \\<S>", "unfolding \\<S>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (l', R')\n    \\<in> {(l, R).\n           l \\<in> L \\<and>\n           R \\<in> \\<R> \\<and>\n           R \\<subseteq> {u. u \\<turnstile> PTA.inv_of A l}}", "proof safe"], ["proof (state)\ngoal (3 subgoals):\n 1. l' \\<in> L\n 2. R' \\<in> \\<R>\n 3. \\<And>x. x \\<in> R' \\<Longrightarrow> x \\<turnstile> PTA.inv_of A l'", "from *(1)"], ["proof (chain)\npicking this:\n  (X, l') \\<in> set_pmf \\<mu>", "have \"(l, g, \\<mu>, X, l') \\<in> edges (l,g, \\<mu>)\""], ["proof (prove)\nusing this:\n  (X, l') \\<in> set_pmf \\<mu>\n\ngoal (1 subgoal):\n 1. (l, g, \\<mu>, X, l') \\<in> edges (l, g, \\<mu>)", "unfolding edges_def"], ["proof (prove)\nusing this:\n  (X, l') \\<in> set_pmf \\<mu>\n\ngoal (1 subgoal):\n 1. (l, g, \\<mu>, X, l')\n    \\<in> (case (l, g, \\<mu>) of\n           (l, g, p) \\<Rightarrow>\n             {(l, g, p, X, l') |X l'. (X, l') \\<in> set_pmf p})", "by auto"], ["proof (state)\nthis:\n  (l, g, \\<mu>, X, l') \\<in> edges (l, g, \\<mu>)\n\ngoal (3 subgoals):\n 1. l' \\<in> L\n 2. R' \\<in> \\<R>\n 3. \\<And>x. x \\<in> R' \\<Longrightarrow> x \\<turnstile> PTA.inv_of A l'", "with prems(6)"], ["proof (chain)\npicking this:\n  (l, g, \\<mu>) \\<in> PTA.trans_of A\n  (l, g, \\<mu>, X, l') \\<in> edges (l, g, \\<mu>)", "have \"(l, g, \\<mu>, X, l') \\<in> Edges A\""], ["proof (prove)\nusing this:\n  (l, g, \\<mu>) \\<in> PTA.trans_of A\n  (l, g, \\<mu>, X, l') \\<in> edges (l, g, \\<mu>)\n\ngoal (1 subgoal):\n 1. A \\<turnstile> l \\<longrightarrow>\\<^bsup>g,\\<mu>,X\\<^esup> l'", "unfolding Edges_def trans_of_def"], ["proof (prove)\nusing this:\n  (l, g, \\<mu>) \\<in> fst A\n  (l, g, \\<mu>, X, l') \\<in> edges (l, g, \\<mu>)\n\ngoal (1 subgoal):\n 1. (l, g, \\<mu>, X, l') \\<in> \\<Union> {edges t |t. t \\<in> fst A}", "by auto"], ["proof (state)\nthis:\n  A \\<turnstile> l \\<longrightarrow>\\<^bsup>g,\\<mu>,X\\<^esup> l'\n\ngoal (3 subgoals):\n 1. l' \\<in> L\n 2. R' \\<in> \\<R>\n 3. \\<And>x. x \\<in> R' \\<Longrightarrow> x \\<turnstile> PTA.inv_of A l'", "then"], ["proof (chain)\npicking this:\n  A \\<turnstile> l \\<longrightarrow>\\<^bsup>g,\\<mu>,X\\<^esup> l'", "show \"l' \\<in> L\""], ["proof (prove)\nusing this:\n  A \\<turnstile> l \\<longrightarrow>\\<^bsup>g,\\<mu>,X\\<^esup> l'\n\ngoal (1 subgoal):\n 1. l' \\<in> L", "unfolding L_def locations_def"], ["proof (prove)\nusing this:\n  A \\<turnstile> l \\<longrightarrow>\\<^bsup>g,\\<mu>,X\\<^esup> l'\n\ngoal (1 subgoal):\n 1. l' \\<in> fst ` Edges A \\<union>\n             (snd \\<circ> snd \\<circ> snd \\<circ> snd) ` Edges A", "by force"], ["proof (state)\nthis:\n  l' \\<in> L\n\ngoal (2 subgoals):\n 1. R' \\<in> \\<R>\n 2. \\<And>x. x \\<in> R' \\<Longrightarrow> x \\<turnstile> PTA.inv_of A l'", "show \"u \\<turnstile> inv_of A l'\" if \"u \\<in> R'\" for u"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<turnstile> PTA.inv_of A l'", "using admissible_targets'[OF prems(6) *(1) prems(7)] *(2) that"], ["proof (prove)\nusing this:\n  [X::=0]R \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l'}\n  R' = [X::=0]R\n  u \\<in> R'\n\ngoal (1 subgoal):\n 1. u \\<turnstile> PTA.inv_of A l'", "by auto"], ["proof (state)\nthis:\n  ?u3 \\<in> R' \\<Longrightarrow> ?u3 \\<turnstile> PTA.inv_of A l'\n\ngoal (1 subgoal):\n 1. R' \\<in> \\<R>", "from admissible_targets(2)[OF prems(6) *(1)]"], ["proof (chain)\npicking this:\n  X \\<subseteq> clocks A", "have \"X \\<subseteq> \\<X>\""], ["proof (prove)\nusing this:\n  X \\<subseteq> clocks A\n\ngoal (1 subgoal):\n 1. X \\<subseteq> \\<X>", "unfolding \\<X>_def"], ["proof (prove)\nusing this:\n  X \\<subseteq> clocks A\n\ngoal (1 subgoal):\n 1. X \\<subseteq> clocks A", "by auto"], ["proof (state)\nthis:\n  X \\<subseteq> \\<X>\n\ngoal (1 subgoal):\n 1. R' \\<in> \\<R>", "with finite(1)"], ["proof (chain)\npicking this:\n  finite \\<X>\n  X \\<subseteq> \\<X>", "have \"finite X\""], ["proof (prove)\nusing this:\n  finite \\<X>\n  X \\<subseteq> \\<X>\n\ngoal (1 subgoal):\n 1. finite X", "by (blast intro: finite_subset)"], ["proof (state)\nthis:\n  finite X\n\ngoal (1 subgoal):\n 1. R' \\<in> \\<R>", "then"], ["proof (chain)\npicking this:\n  finite X", "obtain r where \"set r = X\""], ["proof (prove)\nusing this:\n  finite X\n\ngoal (1 subgoal):\n 1. (\\<And>r. set r = X \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using finite_list"], ["proof (prove)\nusing this:\n  finite X\n  finite ?A \\<Longrightarrow> \\<exists>xs. set xs = ?A\n\ngoal (1 subgoal):\n 1. (\\<And>r. set r = X \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  set r = X\n\ngoal (1 subgoal):\n 1. R' \\<in> \\<R>", "then"], ["proof (chain)\npicking this:\n  set r = X", "have \"set (SOME r. set r = X) = X\""], ["proof (prove)\nusing this:\n  set r = X\n\ngoal (1 subgoal):\n 1. set (SOME r. set r = X) = X", "by (rule someI)"], ["proof (state)\nthis:\n  set (SOME r. set r = X) = X\n\ngoal (1 subgoal):\n 1. R' \\<in> \\<R>", "with \\<open>X \\<subseteq> \\<X>\\<close>"], ["proof (chain)\npicking this:\n  X \\<subseteq> \\<X>\n  set (SOME r. set r = X) = X", "have \"set (SOME r. set r = X) \\<subseteq> \\<X>\""], ["proof (prove)\nusing this:\n  X \\<subseteq> \\<X>\n  set (SOME r. set r = X) = X\n\ngoal (1 subgoal):\n 1. set (SOME r. set r = X) \\<subseteq> \\<X>", "by auto"], ["proof (state)\nthis:\n  set (SOME r. set r = X) \\<subseteq> \\<X>\n\ngoal (1 subgoal):\n 1. R' \\<in> \\<R>", "with alpha_interp.region_set'_closed[of R 0 \"SOME r. set r = X\"] prems(4,5) *(2)"], ["proof (chain)\npicking this:\n  \\<lbrakk>R \\<in> \\<R>; 0 \\<le> 0;\n   \\<forall>x\\<in>set (SOME r. set r = X). 0 \\<le> k x;\n   set (SOME r. set r = X) \\<subseteq> \\<X>\\<rbrakk>\n  \\<Longrightarrow> [X::=real 0]R \\<in> \\<R>\n  s \\<in> \\<S>\n  s = (l, R)\n  R' = [X::=0]R\n  set (SOME r. set r = X) \\<subseteq> \\<X>", "show \"R' \\<in> \\<R>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>R \\<in> \\<R>; 0 \\<le> 0;\n   \\<forall>x\\<in>set (SOME r. set r = X). 0 \\<le> k x;\n   set (SOME r. set r = X) \\<subseteq> \\<X>\\<rbrakk>\n  \\<Longrightarrow> [X::=real 0]R \\<in> \\<R>\n  s \\<in> \\<S>\n  s = (l, R)\n  R' = [X::=0]R\n  set (SOME r. set r = X) \\<subseteq> \\<X>\n\ngoal (1 subgoal):\n 1. R' \\<in> \\<R>", "unfolding \\<S>_def \\<X>_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>R \\<in> Regions.\\<R> (clocks A) k; 0 \\<le> 0;\n   \\<forall>x\\<in>set (SOME r. set r = X). 0 \\<le> k x;\n   set (SOME r. set r = X) \\<subseteq> clocks A\\<rbrakk>\n  \\<Longrightarrow> [X::=real 0]R \\<in> Regions.\\<R> (clocks A) k\n  s \\<in> {(l, R).\n           l \\<in> L \\<and>\n           R \\<in> Regions.\\<R> (clocks A) k \\<and>\n           R \\<subseteq> {u. u \\<turnstile> PTA.inv_of A l}}\n  s = (l, R)\n  R' = [X::=0]R\n  set (SOME r. set r = X) \\<subseteq> clocks A\n\ngoal (1 subgoal):\n 1. R' \\<in> Regions.\\<R> (clocks A) k", "by auto"], ["proof (state)\nthis:\n  R' \\<in> \\<R>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (l', R') \\<in> \\<S>\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale R_G: Finite_Markov_Decision_Process \\<K> \\<S>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Markov_Decision_Process \\<K> \\<S>", "by (standard, auto simp: \\<S>_finite \\<S>_not_empty \\<K>_finite \\<K>_\\<S>_closed)"], ["", "lemmas \\<K>_\\<S>_closed'[intro] = R_G.set_pmf_closed"], ["", "section \\<open>Relating the MDPs\\<close>"], ["", "subsection \\<open>Translating From K to \\<open>\\<K>\\<close>\\<close>"], ["", "(* XXX Clean this for regular automata too *)\n(* Assumption of valid too strong? i.e. do not need l \\<in> L here *)"], ["", "lemma ccompatible_inv:\n  shows \"ccompatible \\<R> (inv_of A l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccompatible \\<R> (PTA.inv_of A l)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ccompatible \\<R> (PTA.inv_of A l)", "from valid"], ["proof (chain)\npicking this:\n  PTA.valid_abstraction A \\<X> (\\<lambda>x. real (k x))", "have\n    \"\\<forall>(x, m)\\<in>collect_clock_pairs (inv_of A l). m \\<le> real (k x) \\<and> x \\<in> \\<X> \\<and> m \\<in> \\<nat>\""], ["proof (prove)\nusing this:\n  PTA.valid_abstraction A \\<X> (\\<lambda>x. real (k x))\n\ngoal (1 subgoal):\n 1. \\<forall>(x, m)\\<in>collect_clock_pairs (PTA.inv_of A l).\n       m \\<le> real (k x) \\<and> x \\<in> \\<X> \\<and> m \\<in> \\<nat>", "unfolding valid_abstraction_def clkp_set_def collect_clki_def"], ["proof (prove)\nusing this:\n  (\\<forall>(x, m)\n            \\<in>\\<Union>\n                  {collect_clock_pairs (PTA.inv_of A x) |x. True} \\<union>\n                 PTA.collect_clkt (PTA.trans_of A).\n      m \\<le> real (k x) \\<and> x \\<in> \\<X> \\<and> m \\<in> \\<nat>) \\<and>\n  PTA.collect_clkvt A \\<subseteq> \\<X> \\<and> finite \\<X>\n\ngoal (1 subgoal):\n 1. \\<forall>(x, m)\\<in>collect_clock_pairs (PTA.inv_of A l).\n       m \\<le> real (k x) \\<and> x \\<in> \\<X> \\<and> m \\<in> \\<nat>", "by auto"], ["proof (state)\nthis:\n  \\<forall>(x, m)\\<in>collect_clock_pairs (PTA.inv_of A l).\n     m \\<le> real (k x) \\<and> x \\<in> \\<X> \\<and> m \\<in> \\<nat>\n\ngoal (1 subgoal):\n 1. ccompatible \\<R> (PTA.inv_of A l)", "with ccompatible[of _ k \\<X>, folded \\<R>_def]"], ["proof (chain)\npicking this:\n  \\<forall>(x, m)\\<in>collect_clock_pairs ?cc.\n     m \\<le> real (k x) \\<and>\n     x \\<in> \\<X> \\<and> m \\<in> \\<nat> \\<Longrightarrow>\n  ccompatible \\<R> ?cc\n  \\<forall>(x, m)\\<in>collect_clock_pairs (PTA.inv_of A l).\n     m \\<le> real (k x) \\<and> x \\<in> \\<X> \\<and> m \\<in> \\<nat>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>(x, m)\\<in>collect_clock_pairs ?cc.\n     m \\<le> real (k x) \\<and>\n     x \\<in> \\<X> \\<and> m \\<in> \\<nat> \\<Longrightarrow>\n  ccompatible \\<R> ?cc\n  \\<forall>(x, m)\\<in>collect_clock_pairs (PTA.inv_of A l).\n     m \\<le> real (k x) \\<and> x \\<in> \\<X> \\<and> m \\<in> \\<nat>\n\ngoal (1 subgoal):\n 1. ccompatible \\<R> (PTA.inv_of A l)", "by auto"], ["proof (state)\nthis:\n  ccompatible \\<R> (PTA.inv_of A l)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ccompatible_guard:\n  assumes \"(l, g, \\<mu>) \\<in> trans_of A\"\n  shows \"ccompatible \\<R> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccompatible \\<R> g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ccompatible \\<R> g", "from assms valid"], ["proof (chain)\npicking this:\n  (l, g, \\<mu>) \\<in> PTA.trans_of A\n  PTA.valid_abstraction A \\<X> (\\<lambda>x. real (k x))", "have\n    \"\\<forall>(x, m)\\<in>collect_clock_pairs g. m \\<le> real (k x) \\<and> x \\<in> \\<X> \\<and> m \\<in> \\<nat>\""], ["proof (prove)\nusing this:\n  (l, g, \\<mu>) \\<in> PTA.trans_of A\n  PTA.valid_abstraction A \\<X> (\\<lambda>x. real (k x))\n\ngoal (1 subgoal):\n 1. \\<forall>(x, m)\\<in>collect_clock_pairs g.\n       m \\<le> real (k x) \\<and> x \\<in> \\<X> \\<and> m \\<in> \\<nat>", "unfolding valid_abstraction_def clkp_set_def collect_clkt_def trans_of_def"], ["proof (prove)\nusing this:\n  (l, g, \\<mu>) \\<in> fst A\n  (\\<forall>(x, m)\n            \\<in>PTA.collect_clki (PTA.inv_of A) \\<union>\n                 \\<Union>\n                  {collect_clock_pairs (fst (snd t)) |t. t \\<in> fst A}.\n      m \\<le> real (k x) \\<and> x \\<in> \\<X> \\<and> m \\<in> \\<nat>) \\<and>\n  PTA.collect_clkvt A \\<subseteq> \\<X> \\<and> finite \\<X>\n\ngoal (1 subgoal):\n 1. \\<forall>(x, m)\\<in>collect_clock_pairs g.\n       m \\<le> real (k x) \\<and> x \\<in> \\<X> \\<and> m \\<in> \\<nat>", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>(x, m)\\<in>collect_clock_pairs g.\n     m \\<le> real (k x) \\<and> x \\<in> \\<X> \\<and> m \\<in> \\<nat>\n\ngoal (1 subgoal):\n 1. ccompatible \\<R> g", "with assms ccompatible[of _ k \\<X>, folded \\<R>_def]"], ["proof (chain)\npicking this:\n  (l, g, \\<mu>) \\<in> PTA.trans_of A\n  \\<forall>(x, m)\\<in>collect_clock_pairs ?cc.\n     m \\<le> real (k x) \\<and>\n     x \\<in> \\<X> \\<and> m \\<in> \\<nat> \\<Longrightarrow>\n  ccompatible \\<R> ?cc\n  \\<forall>(x, m)\\<in>collect_clock_pairs g.\n     m \\<le> real (k x) \\<and> x \\<in> \\<X> \\<and> m \\<in> \\<nat>", "show ?thesis"], ["proof (prove)\nusing this:\n  (l, g, \\<mu>) \\<in> PTA.trans_of A\n  \\<forall>(x, m)\\<in>collect_clock_pairs ?cc.\n     m \\<le> real (k x) \\<and>\n     x \\<in> \\<X> \\<and> m \\<in> \\<nat> \\<Longrightarrow>\n  ccompatible \\<R> ?cc\n  \\<forall>(x, m)\\<in>collect_clock_pairs g.\n     m \\<le> real (k x) \\<and> x \\<in> \\<X> \\<and> m \\<in> \\<nat>\n\ngoal (1 subgoal):\n 1. ccompatible \\<R> g", "by auto"], ["proof (state)\nthis:\n  ccompatible \\<R> g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas ccompatible_def = ccompatible_def[unfolded ccval_def]"], ["", "lemma region_set'_eq:\n  fixes X :: \"'c set\"\n  assumes \"R \\<in> \\<R>\" \"u \\<in> R\"\n      and \"A \\<turnstile> l \\<longrightarrow>\\<^bsup>g,\\<mu>,X\\<^esup> l'\"\n  shows\n    \"[[X:=0]u]\\<^sub>\\<R> = region_set' R (SOME r. set r = X) 0\" \"[[X:=0]u]\\<^sub>\\<R> \\<in> \\<R>\" \"[X:=0]u \\<in> [[X:=0]u]\\<^sub>\\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [[(SOME r. set r = X)\\<rightarrow>0]u]\\<^sub>\\<R> = [X::=0]R &&&\n    [[(SOME r. set r = X)\\<rightarrow>0]u]\\<^sub>\\<R> \\<in> \\<R> &&&\n    [(SOME r. set r = X)\\<rightarrow>0]u\n    \\<in> [[(SOME r. set r = X)\\<rightarrow>0]u]\\<^sub>\\<R>", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. [[(SOME r. set r = X)\\<rightarrow>0]u]\\<^sub>\\<R> = [X::=0]R\n 2. [[(SOME r. set r = X)\\<rightarrow>0]u]\\<^sub>\\<R> \\<in> \\<R>\n 3. [(SOME r. set r = X)\\<rightarrow>0]u\n    \\<in> [[(SOME r. set r = X)\\<rightarrow>0]u]\\<^sub>\\<R>", "let ?r = \"(SOME r. set r = X)\""], ["proof (state)\ngoal (3 subgoals):\n 1. [[(SOME r. set r = X)\\<rightarrow>0]u]\\<^sub>\\<R> = [X::=0]R\n 2. [[(SOME r. set r = X)\\<rightarrow>0]u]\\<^sub>\\<R> \\<in> \\<R>\n 3. [(SOME r. set r = X)\\<rightarrow>0]u\n    \\<in> [[(SOME r. set r = X)\\<rightarrow>0]u]\\<^sub>\\<R>", "from admissible_targets_alt[OF assms(3)] \\<X>_def finite"], ["proof (chain)\npicking this:\n  {v. v \\<turnstile> g}\\<^bsub>X \\<rightarrow> 0\\<^esub>\n  \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l'}\n  X \\<subseteq> clocks A\n  \\<X> = clocks A\n  finite \\<X>\n  finite L\n  finite (PTA.trans_of A)", "have \"finite X\""], ["proof (prove)\nusing this:\n  {v. v \\<turnstile> g}\\<^bsub>X \\<rightarrow> 0\\<^esub>\n  \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l'}\n  X \\<subseteq> clocks A\n  \\<X> = clocks A\n  finite \\<X>\n  finite L\n  finite (PTA.trans_of A)\n\ngoal (1 subgoal):\n 1. finite X", "by (auto intro: finite_subset)"], ["proof (state)\nthis:\n  finite X\n\ngoal (3 subgoals):\n 1. [[(SOME r. set r = X)\\<rightarrow>0]u]\\<^sub>\\<R> = [X::=0]R\n 2. [[(SOME r. set r = X)\\<rightarrow>0]u]\\<^sub>\\<R> \\<in> \\<R>\n 3. [(SOME r. set r = X)\\<rightarrow>0]u\n    \\<in> [[(SOME r. set r = X)\\<rightarrow>0]u]\\<^sub>\\<R>", "then"], ["proof (chain)\npicking this:\n  finite X", "obtain r where \"set r = X\""], ["proof (prove)\nusing this:\n  finite X\n\ngoal (1 subgoal):\n 1. (\\<And>r. set r = X \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using finite_list"], ["proof (prove)\nusing this:\n  finite X\n  finite ?A \\<Longrightarrow> \\<exists>xs. set xs = ?A\n\ngoal (1 subgoal):\n 1. (\\<And>r. set r = X \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  set r = X\n\ngoal (3 subgoals):\n 1. [[(SOME r. set r = X)\\<rightarrow>0]u]\\<^sub>\\<R> = [X::=0]R\n 2. [[(SOME r. set r = X)\\<rightarrow>0]u]\\<^sub>\\<R> \\<in> \\<R>\n 3. [(SOME r. set r = X)\\<rightarrow>0]u\n    \\<in> [[(SOME r. set r = X)\\<rightarrow>0]u]\\<^sub>\\<R>", "then"], ["proof (chain)\npicking this:\n  set r = X", "have \"set ?r = X\""], ["proof (prove)\nusing this:\n  set r = X\n\ngoal (1 subgoal):\n 1. set (SOME r. set r = X) = X", "by (intro someI)"], ["proof (state)\nthis:\n  set (SOME r. set r = X) = X\n\ngoal (3 subgoals):\n 1. [[(SOME r. set r = X)\\<rightarrow>0]u]\\<^sub>\\<R> = [X::=0]R\n 2. [[(SOME r. set r = X)\\<rightarrow>0]u]\\<^sub>\\<R> \\<in> \\<R>\n 3. [(SOME r. set r = X)\\<rightarrow>0]u\n    \\<in> [[(SOME r. set r = X)\\<rightarrow>0]u]\\<^sub>\\<R>", "with valid assms(3)"], ["proof (chain)\npicking this:\n  PTA.valid_abstraction A \\<X> (\\<lambda>x. real (k x))\n  A \\<turnstile> l \\<longrightarrow>\\<^bsup>g,\\<mu>,X\\<^esup> l'\n  set (SOME r. set r = X) = X", "have \"set ?r \\<subseteq> \\<X>\""], ["proof (prove)\nusing this:\n  PTA.valid_abstraction A \\<X> (\\<lambda>x. real (k x))\n  A \\<turnstile> l \\<longrightarrow>\\<^bsup>g,\\<mu>,X\\<^esup> l'\n  set (SOME r. set r = X) = X\n\ngoal (1 subgoal):\n 1. set (SOME r. set r = X) \\<subseteq> \\<X>", "by (simp add: transition_\\<X>)"], ["proof (state)\nthis:\n  set (SOME r. set r = X) \\<subseteq> \\<X>\n\ngoal (3 subgoals):\n 1. [[(SOME r. set r = X)\\<rightarrow>0]u]\\<^sub>\\<R> = [X::=0]R\n 2. [[(SOME r. set r = X)\\<rightarrow>0]u]\\<^sub>\\<R> \\<in> \\<R>\n 3. [(SOME r. set r = X)\\<rightarrow>0]u\n    \\<in> [[(SOME r. set r = X)\\<rightarrow>0]u]\\<^sub>\\<R>", "from region_set'_id[of _ \\<X> k, folded \\<R>_def, OF assms(1,2) finite(1) _ _ this]"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 \\<le> ?c;\n   \\<forall>x\\<in>set (SOME r. set r = X). ?c \\<le> k x\\<rbrakk>\n  \\<Longrightarrow> [[(SOME r.\n                          set r = X)\\<rightarrow>real ?c]u]\\<^sub>\\<R> =\n                    [X::=real ?c]R \\<and>\n                    [[(SOME r. set r = X)\\<rightarrow>real ?c]u]\\<^sub>\\<R>\n                    \\<in> \\<R> \\<and>\n                    [(SOME r. set r = X)\\<rightarrow>real ?c]u\n                    \\<in> [[(SOME r.\n                                set r = X)\\<rightarrow>real ?c]u]\\<^sub>\\<R>", "show\n    \"[[X:=0]u]\\<^sub>\\<R> = region_set' R (SOME r. set r = X) 0\" \"[[X:=0]u]\\<^sub>\\<R> \\<in> \\<R>\" \"[X:=0]u \\<in> [[X:=0]u]\\<^sub>\\<R>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?c;\n   \\<forall>x\\<in>set (SOME r. set r = X). ?c \\<le> k x\\<rbrakk>\n  \\<Longrightarrow> [[(SOME r.\n                          set r = X)\\<rightarrow>real ?c]u]\\<^sub>\\<R> =\n                    [X::=real ?c]R \\<and>\n                    [[(SOME r. set r = X)\\<rightarrow>real ?c]u]\\<^sub>\\<R>\n                    \\<in> \\<R> \\<and>\n                    [(SOME r. set r = X)\\<rightarrow>real ?c]u\n                    \\<in> [[(SOME r.\n                                set r = X)\\<rightarrow>real ?c]u]\\<^sub>\\<R>\n\ngoal (1 subgoal):\n 1. [[(SOME r. set r = X)\\<rightarrow>0]u]\\<^sub>\\<R> = [X::=0]R &&&\n    [[(SOME r. set r = X)\\<rightarrow>0]u]\\<^sub>\\<R> \\<in> \\<R> &&&\n    [(SOME r. set r = X)\\<rightarrow>0]u\n    \\<in> [[(SOME r. set r = X)\\<rightarrow>0]u]\\<^sub>\\<R>", "by force+"], ["proof (state)\nthis:\n  [[(SOME r. set r = X)\\<rightarrow>0]u]\\<^sub>\\<R> = [X::=0]R\n  [[(SOME r. set r = X)\\<rightarrow>0]u]\\<^sub>\\<R> \\<in> \\<R>\n  [(SOME r. set r = X)\\<rightarrow>0]u\n  \\<in> [[(SOME r. set r = X)\\<rightarrow>0]u]\\<^sub>\\<R>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma regions_part_ex_reset:\n  assumes \"u \\<in> V\"\n  shows  \"[r \\<rightarrow> (d::nat)]u \\<in> [[r \\<rightarrow> d]u]\\<^sub>\\<R>\" \"[[r \\<rightarrow> d]u]\\<^sub>\\<R> \\<in> \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [r\\<rightarrow>real d]u \\<in> [[r\\<rightarrow>real d]u]\\<^sub>\\<R> &&&\n    [[r\\<rightarrow>real d]u]\\<^sub>\\<R> \\<in> \\<R>", "using assms"], ["proof (prove)\nusing this:\n  u \\<in> V\n\ngoal (1 subgoal):\n 1. [r\\<rightarrow>real d]u \\<in> [[r\\<rightarrow>real d]u]\\<^sub>\\<R> &&&\n    [[r\\<rightarrow>real d]u]\\<^sub>\\<R> \\<in> \\<R>", "by auto"], ["", "lemma reset_sets_all_equiv:\n  assumes \"u \\<in> V\" \"u' \\<in> [[r \\<rightarrow> (d :: nat)]u]\\<^sub>\\<R>\" \"x \\<in> set r\" \"set r \\<subseteq> \\<X>\" \"d \\<le> k x\"\n  shows \"u' x = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u' x = real d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u' x = real d", "from assms(1)"], ["proof (chain)\npicking this:\n  u \\<in> V", "have u: \"[r \\<rightarrow> d]u \\<in> [[r \\<rightarrow> d]u]\\<^sub>\\<R>\" \"[[r \\<rightarrow> d]u]\\<^sub>\\<R> \\<in> \\<R>\""], ["proof (prove)\nusing this:\n  u \\<in> V\n\ngoal (1 subgoal):\n 1. [r\\<rightarrow>real d]u \\<in> [[r\\<rightarrow>real d]u]\\<^sub>\\<R> &&&\n    [[r\\<rightarrow>real d]u]\\<^sub>\\<R> \\<in> \\<R>", "by auto"], ["proof (state)\nthis:\n  [r\\<rightarrow>real d]u \\<in> [[r\\<rightarrow>real d]u]\\<^sub>\\<R>\n  [[r\\<rightarrow>real d]u]\\<^sub>\\<R> \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. u' x = real d", "then"], ["proof (chain)\npicking this:\n  [r\\<rightarrow>real d]u \\<in> [[r\\<rightarrow>real d]u]\\<^sub>\\<R>\n  [[r\\<rightarrow>real d]u]\\<^sub>\\<R> \\<in> \\<R>", "obtain I \\<rho> where I: \"[[r \\<rightarrow> d]u]\\<^sub>\\<R> = region \\<X> I \\<rho>\" \"valid_region \\<X> k I \\<rho>\""], ["proof (prove)\nusing this:\n  [r\\<rightarrow>real d]u \\<in> [[r\\<rightarrow>real d]u]\\<^sub>\\<R>\n  [[r\\<rightarrow>real d]u]\\<^sub>\\<R> \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. (\\<And>I \\<rho>.\n        \\<lbrakk>[[r\\<rightarrow>real d]u]\\<^sub>\\<R> =\n                 Regions.region \\<X> I \\<rho>;\n         Regions.valid_region \\<X> k I \\<rho>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: \\<R>_def)"], ["proof (state)\nthis:\n  [[r\\<rightarrow>real d]u]\\<^sub>\\<R> = Regions.region \\<X> I \\<rho>\n  Regions.valid_region \\<X> k I \\<rho>\n\ngoal (1 subgoal):\n 1. u' x = real d", "with u(1) assms(3-)"], ["proof (chain)\npicking this:\n  [r\\<rightarrow>real d]u \\<in> [[r\\<rightarrow>real d]u]\\<^sub>\\<R>\n  x \\<in> set r\n  set r \\<subseteq> \\<X>\n  d \\<le> k x\n  [[r\\<rightarrow>real d]u]\\<^sub>\\<R> = Regions.region \\<X> I \\<rho>\n  Regions.valid_region \\<X> k I \\<rho>", "have \"intv_elem x ([r \\<rightarrow> d]u) (I x)\" \"valid_intv (k x) (I x)\""], ["proof (prove)\nusing this:\n  [r\\<rightarrow>real d]u \\<in> [[r\\<rightarrow>real d]u]\\<^sub>\\<R>\n  x \\<in> set r\n  set r \\<subseteq> \\<X>\n  d \\<le> k x\n  [[r\\<rightarrow>real d]u]\\<^sub>\\<R> = Regions.region \\<X> I \\<rho>\n  Regions.valid_region \\<X> k I \\<rho>\n\ngoal (1 subgoal):\n 1. Regions.intv_elem x ([r\\<rightarrow>real d]u) (I x) &&&\n    Regions.valid_intv (k x) (I x)", "by fastforce+"], ["proof (state)\nthis:\n  Regions.intv_elem x ([r\\<rightarrow>real d]u) (I x)\n  Regions.valid_intv (k x) (I x)\n\ngoal (1 subgoal):\n 1. u' x = real d", "moreover"], ["proof (state)\nthis:\n  Regions.intv_elem x ([r\\<rightarrow>real d]u) (I x)\n  Regions.valid_intv (k x) (I x)\n\ngoal (1 subgoal):\n 1. u' x = real d", "from assms"], ["proof (chain)\npicking this:\n  u \\<in> V\n  u' \\<in> [[r\\<rightarrow>real d]u]\\<^sub>\\<R>\n  x \\<in> set r\n  set r \\<subseteq> \\<X>\n  d \\<le> k x", "have \"([r \\<rightarrow> d]u) x = d\""], ["proof (prove)\nusing this:\n  u \\<in> V\n  u' \\<in> [[r\\<rightarrow>real d]u]\\<^sub>\\<R>\n  x \\<in> set r\n  set r \\<subseteq> \\<X>\n  d \\<le> k x\n\ngoal (1 subgoal):\n 1. ([r\\<rightarrow>real d]u) x = real d", "by simp"], ["proof (state)\nthis:\n  ([r\\<rightarrow>real d]u) x = real d\n\ngoal (1 subgoal):\n 1. u' x = real d", "ultimately"], ["proof (chain)\npicking this:\n  Regions.intv_elem x ([r\\<rightarrow>real d]u) (I x)\n  Regions.valid_intv (k x) (I x)\n  ([r\\<rightarrow>real d]u) x = real d", "have \"I x = Const d\""], ["proof (prove)\nusing this:\n  Regions.intv_elem x ([r\\<rightarrow>real d]u) (I x)\n  Regions.valid_intv (k x) (I x)\n  ([r\\<rightarrow>real d]u) x = real d\n\ngoal (1 subgoal):\n 1. I x = Regions.intv.Const d", "using assms(5)"], ["proof (prove)\nusing this:\n  Regions.intv_elem x ([r\\<rightarrow>real d]u) (I x)\n  Regions.valid_intv (k x) (I x)\n  ([r\\<rightarrow>real d]u) x = real d\n  d \\<le> k x\n\ngoal (1 subgoal):\n 1. I x = Regions.intv.Const d", "by (cases \"I x\") auto"], ["proof (state)\nthis:\n  I x = Regions.intv.Const d\n\ngoal (1 subgoal):\n 1. u' x = real d", "moreover"], ["proof (state)\nthis:\n  I x = Regions.intv.Const d\n\ngoal (1 subgoal):\n 1. u' x = real d", "from I assms(2-)"], ["proof (chain)\npicking this:\n  [[r\\<rightarrow>real d]u]\\<^sub>\\<R> = Regions.region \\<X> I \\<rho>\n  Regions.valid_region \\<X> k I \\<rho>\n  u' \\<in> [[r\\<rightarrow>real d]u]\\<^sub>\\<R>\n  x \\<in> set r\n  set r \\<subseteq> \\<X>\n  d \\<le> k x", "have \"intv_elem x u' (I x)\""], ["proof (prove)\nusing this:\n  [[r\\<rightarrow>real d]u]\\<^sub>\\<R> = Regions.region \\<X> I \\<rho>\n  Regions.valid_region \\<X> k I \\<rho>\n  u' \\<in> [[r\\<rightarrow>real d]u]\\<^sub>\\<R>\n  x \\<in> set r\n  set r \\<subseteq> \\<X>\n  d \\<le> k x\n\ngoal (1 subgoal):\n 1. Regions.intv_elem x u' (I x)", "by fastforce"], ["proof (state)\nthis:\n  Regions.intv_elem x u' (I x)\n\ngoal (1 subgoal):\n 1. u' x = real d", "ultimately"], ["proof (chain)\npicking this:\n  I x = Regions.intv.Const d\n  Regions.intv_elem x u' (I x)", "show \"u' x = d\""], ["proof (prove)\nusing this:\n  I x = Regions.intv.Const d\n  Regions.intv_elem x u' (I x)\n\ngoal (1 subgoal):\n 1. u' x = real d", "by auto"], ["proof (state)\nthis:\n  u' x = real d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reset_eq:\n  assumes \"u \\<in> V\" \"([[r \\<rightarrow> 0]u]\\<^sub>\\<R>) = ([[r' \\<rightarrow> 0]u]\\<^sub>\\<R>)\" \"set r \\<subseteq> \\<X>\" \"set r' \\<subseteq> \\<X>\"\n  shows \"[r \\<rightarrow> 0]u = [r' \\<rightarrow> 0]u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [r\\<rightarrow>0]u = [r'\\<rightarrow>0]u", "using assms"], ["proof (prove)\nusing this:\n  u \\<in> V\n  [[r\\<rightarrow>0]u]\\<^sub>\\<R> = [[r'\\<rightarrow>0]u]\\<^sub>\\<R>\n  set r \\<subseteq> \\<X>\n  set r' \\<subseteq> \\<X>\n\ngoal (1 subgoal):\n 1. [r\\<rightarrow>0]u = [r'\\<rightarrow>0]u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> V;\n     [[r\\<rightarrow>0]u]\\<^sub>\\<R> = [[r'\\<rightarrow>0]u]\\<^sub>\\<R>;\n     set r \\<subseteq> \\<X>; set r' \\<subseteq> \\<X>\\<rbrakk>\n    \\<Longrightarrow> [r\\<rightarrow>0]u = [r'\\<rightarrow>0]u", "have *: \"u' x = 0\" if \"u' \\<in> [[r \\<rightarrow> 0]u]\\<^sub>\\<R>\" \"x \\<in> set r\" for u' x"], ["proof (prove)\ngoal (1 subgoal):\n 1. u' x = 0", "using reset_sets_all_equiv[of u u' r 0 x] that assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>u \\<in> V; u' \\<in> [[r\\<rightarrow>real 0]u]\\<^sub>\\<R>;\n   x \\<in> set r; set r \\<subseteq> \\<X>; 0 \\<le> k x\\<rbrakk>\n  \\<Longrightarrow> u' x = real 0\n  u' \\<in> [[r\\<rightarrow>0]u]\\<^sub>\\<R>\n  x \\<in> set r\n  u \\<in> V\n  [[r\\<rightarrow>0]u]\\<^sub>\\<R> = [[r'\\<rightarrow>0]u]\\<^sub>\\<R>\n  set r \\<subseteq> \\<X>\n  set r' \\<subseteq> \\<X>\n\ngoal (1 subgoal):\n 1. u' x = 0", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?u'3 \\<in> [[r\\<rightarrow>0]u]\\<^sub>\\<R>;\n   ?x3 \\<in> set r\\<rbrakk>\n  \\<Longrightarrow> ?u'3 ?x3 = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> V;\n     [[r\\<rightarrow>0]u]\\<^sub>\\<R> = [[r'\\<rightarrow>0]u]\\<^sub>\\<R>;\n     set r \\<subseteq> \\<X>; set r' \\<subseteq> \\<X>\\<rbrakk>\n    \\<Longrightarrow> [r\\<rightarrow>0]u = [r'\\<rightarrow>0]u", "have \"u' x = 0\" if \"u' \\<in> [[r' \\<rightarrow> 0]u]\\<^sub>\\<R>\" \"x \\<in> set r'\" for u' x"], ["proof (prove)\ngoal (1 subgoal):\n 1. u' x = 0", "using reset_sets_all_equiv[of u u' r' 0 x] that assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>u \\<in> V; u' \\<in> [[r'\\<rightarrow>real 0]u]\\<^sub>\\<R>;\n   x \\<in> set r'; set r' \\<subseteq> \\<X>; 0 \\<le> k x\\<rbrakk>\n  \\<Longrightarrow> u' x = real 0\n  u' \\<in> [[r'\\<rightarrow>0]u]\\<^sub>\\<R>\n  x \\<in> set r'\n  u \\<in> V\n  [[r\\<rightarrow>0]u]\\<^sub>\\<R> = [[r'\\<rightarrow>0]u]\\<^sub>\\<R>\n  set r \\<subseteq> \\<X>\n  set r' \\<subseteq> \\<X>\n\ngoal (1 subgoal):\n 1. u' x = 0", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?u'3 \\<in> [[r'\\<rightarrow>0]u]\\<^sub>\\<R>;\n   ?x3 \\<in> set r'\\<rbrakk>\n  \\<Longrightarrow> ?u'3 ?x3 = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> V;\n     [[r\\<rightarrow>0]u]\\<^sub>\\<R> = [[r'\\<rightarrow>0]u]\\<^sub>\\<R>;\n     set r \\<subseteq> \\<X>; set r' \\<subseteq> \\<X>\\<rbrakk>\n    \\<Longrightarrow> [r\\<rightarrow>0]u = [r'\\<rightarrow>0]u", "from regions_part_ex_reset[OF assms(1), of _ 0] assms(2)"], ["proof (chain)\npicking this:\n  [?r\\<rightarrow>real 0]u \\<in> [[?r\\<rightarrow>real 0]u]\\<^sub>\\<R>\n  [[?r\\<rightarrow>real 0]u]\\<^sub>\\<R> \\<in> \\<R>\n  [[r\\<rightarrow>0]u]\\<^sub>\\<R> = [[r'\\<rightarrow>0]u]\\<^sub>\\<R>", "have **:\n    \"([r' \\<rightarrow> 0]u) \\<in> [[r \\<rightarrow> 0]u]\\<^sub>\\<R>\" \"([r \\<rightarrow> 0]u) \\<in> [[r \\<rightarrow> 0]u]\\<^sub>\\<R>\" \"[[r \\<rightarrow> 0]u]\\<^sub>\\<R> \\<in> \\<R>\""], ["proof (prove)\nusing this:\n  [?r\\<rightarrow>real 0]u \\<in> [[?r\\<rightarrow>real 0]u]\\<^sub>\\<R>\n  [[?r\\<rightarrow>real 0]u]\\<^sub>\\<R> \\<in> \\<R>\n  [[r\\<rightarrow>0]u]\\<^sub>\\<R> = [[r'\\<rightarrow>0]u]\\<^sub>\\<R>\n\ngoal (1 subgoal):\n 1. [r'\\<rightarrow>0]u \\<in> [[r\\<rightarrow>0]u]\\<^sub>\\<R> &&&\n    [r\\<rightarrow>0]u \\<in> [[r\\<rightarrow>0]u]\\<^sub>\\<R> &&&\n    [[r\\<rightarrow>0]u]\\<^sub>\\<R> \\<in> \\<R>", "by auto"], ["proof (state)\nthis:\n  [r'\\<rightarrow>0]u \\<in> [[r\\<rightarrow>0]u]\\<^sub>\\<R>\n  [r\\<rightarrow>0]u \\<in> [[r\\<rightarrow>0]u]\\<^sub>\\<R>\n  [[r\\<rightarrow>0]u]\\<^sub>\\<R> \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> V;\n     [[r\\<rightarrow>0]u]\\<^sub>\\<R> = [[r'\\<rightarrow>0]u]\\<^sub>\\<R>;\n     set r \\<subseteq> \\<X>; set r' \\<subseteq> \\<X>\\<rbrakk>\n    \\<Longrightarrow> [r\\<rightarrow>0]u = [r'\\<rightarrow>0]u", "have \"(([r \\<rightarrow> 0]u) x) = (([r' \\<rightarrow> 0]u) x)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x", "proof (cases \"x \\<in> set r\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> set r \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x\n 2. x \\<notin> set r \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x", "case True"], ["proof (state)\nthis:\n  x \\<in> set r\n\ngoal (2 subgoals):\n 1. x \\<in> set r \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x\n 2. x \\<notin> set r \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x", "then"], ["proof (chain)\npicking this:\n  x \\<in> set r", "have \"([r \\<rightarrow> 0]u) x = 0\""], ["proof (prove)\nusing this:\n  x \\<in> set r\n\ngoal (1 subgoal):\n 1. ([r\\<rightarrow>0]u) x = 0", "by simp"], ["proof (state)\nthis:\n  ([r\\<rightarrow>0]u) x = 0\n\ngoal (2 subgoals):\n 1. x \\<in> set r \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x\n 2. x \\<notin> set r \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x", "moreover"], ["proof (state)\nthis:\n  ([r\\<rightarrow>0]u) x = 0\n\ngoal (2 subgoals):\n 1. x \\<in> set r \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x\n 2. x \\<notin> set r \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x", "from * ** True"], ["proof (chain)\npicking this:\n  \\<lbrakk>?u'3 \\<in> [[r\\<rightarrow>0]u]\\<^sub>\\<R>;\n   ?x3 \\<in> set r\\<rbrakk>\n  \\<Longrightarrow> ?u'3 ?x3 = 0\n  [r'\\<rightarrow>0]u \\<in> [[r\\<rightarrow>0]u]\\<^sub>\\<R>\n  [r\\<rightarrow>0]u \\<in> [[r\\<rightarrow>0]u]\\<^sub>\\<R>\n  [[r\\<rightarrow>0]u]\\<^sub>\\<R> \\<in> \\<R>\n  x \\<in> set r", "have \"([r' \\<rightarrow> 0]u) x = 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?u'3 \\<in> [[r\\<rightarrow>0]u]\\<^sub>\\<R>;\n   ?x3 \\<in> set r\\<rbrakk>\n  \\<Longrightarrow> ?u'3 ?x3 = 0\n  [r'\\<rightarrow>0]u \\<in> [[r\\<rightarrow>0]u]\\<^sub>\\<R>\n  [r\\<rightarrow>0]u \\<in> [[r\\<rightarrow>0]u]\\<^sub>\\<R>\n  [[r\\<rightarrow>0]u]\\<^sub>\\<R> \\<in> \\<R>\n  x \\<in> set r\n\ngoal (1 subgoal):\n 1. ([r'\\<rightarrow>0]u) x = 0", "by auto"], ["proof (state)\nthis:\n  ([r'\\<rightarrow>0]u) x = 0\n\ngoal (2 subgoals):\n 1. x \\<in> set r \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x\n 2. x \\<notin> set r \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x", "ultimately"], ["proof (chain)\npicking this:\n  ([r\\<rightarrow>0]u) x = 0\n  ([r'\\<rightarrow>0]u) x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  ([r\\<rightarrow>0]u) x = 0\n  ([r'\\<rightarrow>0]u) x = 0\n\ngoal (1 subgoal):\n 1. ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x", ".."], ["proof (state)\nthis:\n  ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x\n\ngoal (1 subgoal):\n 1. x \\<notin> set r \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> set r \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x", "case False"], ["proof (state)\nthis:\n  x \\<notin> set r\n\ngoal (1 subgoal):\n 1. x \\<notin> set r \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x", "then"], ["proof (chain)\npicking this:\n  x \\<notin> set r", "have id: \"([r\\<rightarrow>0]u) x = u x\""], ["proof (prove)\nusing this:\n  x \\<notin> set r\n\ngoal (1 subgoal):\n 1. ([r\\<rightarrow>0]u) x = u x", "by simp"], ["proof (state)\nthis:\n  ([r\\<rightarrow>0]u) x = u x\n\ngoal (1 subgoal):\n 1. x \\<notin> set r \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x", "proof (cases \"x \\<in> set r'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> set r' \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x\n 2. x \\<notin> set r' \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x", "case True"], ["proof (state)\nthis:\n  x \\<in> set r'\n\ngoal (2 subgoals):\n 1. x \\<in> set r' \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x\n 2. x \\<notin> set r' \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x", "then"], ["proof (chain)\npicking this:\n  x \\<in> set r'", "have reset: \"([r' \\<rightarrow> 0]u) x = 0\""], ["proof (prove)\nusing this:\n  x \\<in> set r'\n\ngoal (1 subgoal):\n 1. ([r'\\<rightarrow>0]u) x = 0", "by simp"], ["proof (state)\nthis:\n  ([r'\\<rightarrow>0]u) x = 0\n\ngoal (2 subgoals):\n 1. x \\<in> set r' \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x\n 2. x \\<notin> set r' \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x", "proof (cases \"x \\<in> \\<X>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> \\<X> \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x\n 2. x \\<notin> \\<X> \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x", "case True"], ["proof (state)\nthis:\n  x \\<in> \\<X>\n\ngoal (2 subgoals):\n 1. x \\<in> \\<X> \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x\n 2. x \\<notin> \\<X> \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x", "from **(3)"], ["proof (chain)\npicking this:\n  [[r\\<rightarrow>0]u]\\<^sub>\\<R> \\<in> \\<R>", "obtain I \\<rho> where\n          \"([([r \\<rightarrow> 0]u)]\\<^sub>\\<R>) = Regions.region \\<X> I \\<rho>\" \"Regions.valid_region \\<X> k I \\<rho>\""], ["proof (prove)\nusing this:\n  [[r\\<rightarrow>0]u]\\<^sub>\\<R> \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. (\\<And>I \\<rho>.\n        \\<lbrakk>[[r\\<rightarrow>0]u]\\<^sub>\\<R> =\n                 Regions.region \\<X> I \\<rho>;\n         Regions.valid_region \\<X> k I \\<rho>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: \\<R>_def)"], ["proof (state)\nthis:\n  [[r\\<rightarrow>0]u]\\<^sub>\\<R> = Regions.region \\<X> I \\<rho>\n  Regions.valid_region \\<X> k I \\<rho>\n\ngoal (2 subgoals):\n 1. x \\<in> \\<X> \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x\n 2. x \\<notin> \\<X> \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x", "with ** \\<open>x \\<in> \\<X>\\<close>"], ["proof (chain)\npicking this:\n  [r'\\<rightarrow>0]u \\<in> [[r\\<rightarrow>0]u]\\<^sub>\\<R>\n  [r\\<rightarrow>0]u \\<in> [[r\\<rightarrow>0]u]\\<^sub>\\<R>\n  [[r\\<rightarrow>0]u]\\<^sub>\\<R> \\<in> \\<R>\n  x \\<in> \\<X>\n  [[r\\<rightarrow>0]u]\\<^sub>\\<R> = Regions.region \\<X> I \\<rho>\n  Regions.valid_region \\<X> k I \\<rho>", "have ***:\n          \"intv_elem x ([r' \\<rightarrow> 0]u) (I x)\" \"intv_elem x ([r \\<rightarrow> 0]u) (I x)\""], ["proof (prove)\nusing this:\n  [r'\\<rightarrow>0]u \\<in> [[r\\<rightarrow>0]u]\\<^sub>\\<R>\n  [r\\<rightarrow>0]u \\<in> [[r\\<rightarrow>0]u]\\<^sub>\\<R>\n  [[r\\<rightarrow>0]u]\\<^sub>\\<R> \\<in> \\<R>\n  x \\<in> \\<X>\n  [[r\\<rightarrow>0]u]\\<^sub>\\<R> = Regions.region \\<X> I \\<rho>\n  Regions.valid_region \\<X> k I \\<rho>\n\ngoal (1 subgoal):\n 1. Regions.intv_elem x ([r'\\<rightarrow>0]u) (I x) &&&\n    Regions.intv_elem x ([r\\<rightarrow>0]u) (I x)", "by auto"], ["proof (state)\nthis:\n  Regions.intv_elem x ([r'\\<rightarrow>0]u) (I x)\n  Regions.intv_elem x ([r\\<rightarrow>0]u) (I x)\n\ngoal (2 subgoals):\n 1. x \\<in> \\<X> \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x\n 2. x \\<notin> \\<X> \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x", "with reset"], ["proof (chain)\npicking this:\n  ([r'\\<rightarrow>0]u) x = 0\n  Regions.intv_elem x ([r'\\<rightarrow>0]u) (I x)\n  Regions.intv_elem x ([r\\<rightarrow>0]u) (I x)", "have \"I x = Const 0\""], ["proof (prove)\nusing this:\n  ([r'\\<rightarrow>0]u) x = 0\n  Regions.intv_elem x ([r'\\<rightarrow>0]u) (I x)\n  Regions.intv_elem x ([r\\<rightarrow>0]u) (I x)\n\ngoal (1 subgoal):\n 1. I x = Regions.intv.Const 0", "by (cases \"I x\", auto)"], ["proof (state)\nthis:\n  I x = Regions.intv.Const 0\n\ngoal (2 subgoals):\n 1. x \\<in> \\<X> \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x\n 2. x \\<notin> \\<X> \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x", "with ***(2)"], ["proof (chain)\npicking this:\n  Regions.intv_elem x ([r\\<rightarrow>0]u) (I x)\n  I x = Regions.intv.Const 0", "have \"([r \\<rightarrow> 0]u) x = 0\""], ["proof (prove)\nusing this:\n  Regions.intv_elem x ([r\\<rightarrow>0]u) (I x)\n  I x = Regions.intv.Const 0\n\ngoal (1 subgoal):\n 1. ([r\\<rightarrow>0]u) x = 0", "by auto"], ["proof (state)\nthis:\n  ([r\\<rightarrow>0]u) x = 0\n\ngoal (2 subgoals):\n 1. x \\<in> \\<X> \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x\n 2. x \\<notin> \\<X> \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x", "with reset"], ["proof (chain)\npicking this:\n  ([r'\\<rightarrow>0]u) x = 0\n  ([r\\<rightarrow>0]u) x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  ([r'\\<rightarrow>0]u) x = 0\n  ([r\\<rightarrow>0]u) x = 0\n\ngoal (1 subgoal):\n 1. ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x", "by auto"], ["proof (state)\nthis:\n  ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<X> \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> \\<X> \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x", "case False"], ["proof (state)\nthis:\n  x \\<notin> \\<X>\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<X> \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x", "with assms(3-)"], ["proof (chain)\npicking this:\n  set r \\<subseteq> \\<X>\n  set r' \\<subseteq> \\<X>\n  x \\<notin> \\<X>", "have \"x \\<notin> set r\" \"x \\<notin> set r'\""], ["proof (prove)\nusing this:\n  set r \\<subseteq> \\<X>\n  set r' \\<subseteq> \\<X>\n  x \\<notin> \\<X>\n\ngoal (1 subgoal):\n 1. x \\<notin> set r &&& x \\<notin> set r'", "by auto"], ["proof (state)\nthis:\n  x \\<notin> set r\n  x \\<notin> set r'\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<X> \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x", "then"], ["proof (chain)\npicking this:\n  x \\<notin> set r\n  x \\<notin> set r'", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<notin> set r\n  x \\<notin> set r'\n\ngoal (1 subgoal):\n 1. ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x", "by simp"], ["proof (state)\nthis:\n  ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x\n\ngoal (1 subgoal):\n 1. x \\<notin> set r' \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> set r' \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x", "case False"], ["proof (state)\nthis:\n  x \\<notin> set r'\n\ngoal (1 subgoal):\n 1. x \\<notin> set r' \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x", "then"], ["proof (chain)\npicking this:\n  x \\<notin> set r'", "have reset: \"([r' \\<rightarrow> 0]u) x = u x\""], ["proof (prove)\nusing this:\n  x \\<notin> set r'\n\ngoal (1 subgoal):\n 1. ([r'\\<rightarrow>0]u) x = u x", "by simp"], ["proof (state)\nthis:\n  ([r'\\<rightarrow>0]u) x = u x\n\ngoal (1 subgoal):\n 1. x \\<notin> set r' \\<Longrightarrow>\n    ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x", "with id"], ["proof (chain)\npicking this:\n  ([r\\<rightarrow>0]u) x = u x\n  ([r'\\<rightarrow>0]u) x = u x", "show ?thesis"], ["proof (prove)\nusing this:\n  ([r\\<rightarrow>0]u) x = u x\n  ([r'\\<rightarrow>0]u) x = u x\n\ngoal (1 subgoal):\n 1. ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x", "by simp"], ["proof (state)\nthis:\n  ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ([r\\<rightarrow>0]u) x = ([r'\\<rightarrow>0]u) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ([r\\<rightarrow>0]u) ?x3 = ([r'\\<rightarrow>0]u) ?x3\n\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> V;\n     [[r\\<rightarrow>0]u]\\<^sub>\\<R> = [[r'\\<rightarrow>0]u]\\<^sub>\\<R>;\n     set r \\<subseteq> \\<X>; set r' \\<subseteq> \\<X>\\<rbrakk>\n    \\<Longrightarrow> [r\\<rightarrow>0]u = [r'\\<rightarrow>0]u", "then"], ["proof (chain)\npicking this:\n  ([r\\<rightarrow>0]u) ?x3 = ([r'\\<rightarrow>0]u) ?x3", "show ?thesis"], ["proof (prove)\nusing this:\n  ([r\\<rightarrow>0]u) ?x3 = ([r'\\<rightarrow>0]u) ?x3\n\ngoal (1 subgoal):\n 1. [r\\<rightarrow>0]u = [r'\\<rightarrow>0]u", ".."], ["proof (state)\nthis:\n  [r\\<rightarrow>0]u = [r'\\<rightarrow>0]u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma admissible_targets_clocks:\n  assumes \"(l, g, \\<mu>) \\<in> trans_of A\" \"(X, l') \\<in> \\<mu>\"\n  shows \"X \\<subseteq> \\<X>\" \"set (SOME r. set r = X) \\<subseteq> \\<X>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<subseteq> \\<X> &&& set (SOME r. set r = X) \\<subseteq> \\<X>", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. X \\<subseteq> \\<X>\n 2. set (SOME r. set r = X) \\<subseteq> \\<X>", "from admissible_targets(2)[OF assms] finite"], ["proof (chain)\npicking this:\n  X \\<subseteq> clocks A\n  finite \\<X>\n  finite L\n  finite (PTA.trans_of A)", "have\n    \"finite X\" \"X \\<subseteq> \\<X>\""], ["proof (prove)\nusing this:\n  X \\<subseteq> clocks A\n  finite \\<X>\n  finite L\n  finite (PTA.trans_of A)\n\ngoal (1 subgoal):\n 1. finite X &&& X \\<subseteq> \\<X>", "by (auto intro: finite_subset simp: \\<X>_def)"], ["proof (state)\nthis:\n  finite X\n  X \\<subseteq> \\<X>\n\ngoal (2 subgoals):\n 1. X \\<subseteq> \\<X>\n 2. set (SOME r. set r = X) \\<subseteq> \\<X>", "then"], ["proof (chain)\npicking this:\n  finite X\n  X \\<subseteq> \\<X>", "obtain r where \"set r = X\""], ["proof (prove)\nusing this:\n  finite X\n  X \\<subseteq> \\<X>\n\ngoal (1 subgoal):\n 1. (\\<And>r. set r = X \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using finite_list"], ["proof (prove)\nusing this:\n  finite X\n  X \\<subseteq> \\<X>\n  finite ?A \\<Longrightarrow> \\<exists>xs. set xs = ?A\n\ngoal (1 subgoal):\n 1. (\\<And>r. set r = X \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  set r = X\n\ngoal (2 subgoals):\n 1. X \\<subseteq> \\<X>\n 2. set (SOME r. set r = X) \\<subseteq> \\<X>", "with \\<open>X \\<subseteq> \\<X>\\<close>"], ["proof (chain)\npicking this:\n  X \\<subseteq> \\<X>\n  set r = X", "show \"X \\<subseteq> \\<X>\" \"set (SOME r. set r = X) \\<subseteq> \\<X>\""], ["proof (prove)\nusing this:\n  X \\<subseteq> \\<X>\n  set r = X\n\ngoal (1 subgoal):\n 1. X \\<subseteq> \\<X> &&& set (SOME r. set r = X) \\<subseteq> \\<X>", "by (metis (mono_tags, lifting) someI_ex)+"], ["proof (state)\nthis:\n  X \\<subseteq> \\<X>\n  set (SOME r. set r = X) \\<subseteq> \\<X>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  \"rel_pmf (\\<lambda> a b. f a = b) \\<mu> (map_pmf f \\<mu>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_pmf (\\<lambda>a. (=) (f a)) \\<mu> (map_pmf f \\<mu>)", "by (subst pmf.rel_map(2)) (rule rel_pmf_reflI, auto)"], ["", "lemma K_pmf_rel:\n  defines \"f \\<equiv> \\<lambda> (l, u). (l, [u]\\<^sub>\\<R>)\"\n  shows \"rel_pmf (\\<lambda> (l, u) st. (l, [u]\\<^sub>\\<R>) = st) \\<mu> (map_pmf f \\<mu>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_pmf (\\<lambda>(l, u). (=) (l, [u]\\<^sub>\\<R>)) \\<mu>\n     (map_pmf f \\<mu>)", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_pmf (\\<lambda>(l, u). (=) (l, [u]\\<^sub>\\<R>)) \\<mu>\n     (map_pmf (\\<lambda>(l, u). (l, [u]\\<^sub>\\<R>)) \\<mu>)", "by (subst pmf.rel_map(2)) (rule rel_pmf_reflI, auto)"], ["", "lemma \\<K>_pmf_rel:\n  assumes A: \"\\<mu> \\<in> \\<K> (l, R)\"\n  defines \"f \\<equiv> \\<lambda> (l, u). (l, SOME u. u \\<in> R)\"\n  shows \"rel_pmf (\\<lambda> (l, u) st. (l, SOME u. u \\<in> R) = st) \\<mu> (map_pmf f \\<mu>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_pmf (\\<lambda>(l, u). (=) (l, SOME u. u \\<in> R)) \\<mu>\n     (map_pmf f \\<mu>)", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_pmf (\\<lambda>(l, u). (=) (l, SOME u. u \\<in> R)) \\<mu>\n     (map_pmf (\\<lambda>(l, u). (l, SOME u. u \\<in> R)) \\<mu>)", "by (subst pmf.rel_map(2)) (rule rel_pmf_reflI, auto)"], ["", "lemma K_elem_abs_inj:\n  assumes A: \"\\<mu> \\<in> K (l, u)\"\n  defines \"f \\<equiv> \\<lambda> (l, u). (l, [u]\\<^sub>\\<R>)\"\n  shows \"inj_on f \\<mu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f (set_pmf \\<mu>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on f (set_pmf \\<mu>)", "have \"(l1, u1) = (l2, u2)\"\n    if id: \"(l1, [u1]\\<^sub>\\<R>) = (l2, [u2]\\<^sub>\\<R>)\" and elem: \"(l1, u1) \\<in> \\<mu>\" \"(l2, u2) \\<in> \\<mu>\" for l1 l2 u1 u2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (l1, u1) = (l2, u2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (l1, u1) = (l2, u2)", "from id"], ["proof (chain)\npicking this:\n  (l1, [u1]\\<^sub>\\<R>) = (l2, [u2]\\<^sub>\\<R>)", "have [simp]: \"l2 = l1\""], ["proof (prove)\nusing this:\n  (l1, [u1]\\<^sub>\\<R>) = (l2, [u2]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. l2 = l1", "by auto"], ["proof (state)\nthis:\n  l2 = l1\n\ngoal (1 subgoal):\n 1. (l1, u1) = (l2, u2)", "from A"], ["proof (chain)\npicking this:\n  \\<mu> \\<in> K (l, u)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<mu> \\<in> K (l, u)\n\ngoal (1 subgoal):\n 1. (l1, u1) = (l2, u2)", "proof (cases, safe, goal_cases)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>la ua t.\n       \\<lbrakk>(l, u) \\<in> S; 0 \\<le> t;\n        u \\<oplus> t \\<turnstile> PTA.inv_of A l;\n        return_pmf (l, u \\<oplus> t) \\<in> K (l, u);\n        \\<mu> = return_pmf (l, u \\<oplus> t)\\<rbrakk>\n       \\<Longrightarrow> l1 = l2\n 2. \\<And>la ua t.\n       \\<lbrakk>(l, u) \\<in> S; 0 \\<le> t;\n        u \\<oplus> t \\<turnstile> PTA.inv_of A l;\n        return_pmf (l, u \\<oplus> t) \\<in> K (l, u);\n        \\<mu> = return_pmf (l, u \\<oplus> t)\\<rbrakk>\n       \\<Longrightarrow> u1 = u2\n 3. \\<And>la ua g \\<mu>'.\n       \\<lbrakk>(l, u) \\<in> S; (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        u \\<turnstile> g;\n        map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n         \\<mu>'\n        \\<in> K (l, u);\n        \\<mu> =\n        map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n         \\<mu>'\\<rbrakk>\n       \\<Longrightarrow> l1 = l2\n 4. \\<And>la ua g \\<mu>'.\n       \\<lbrakk>(l, u) \\<in> S; (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        u \\<turnstile> g;\n        map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n         \\<mu>'\n        \\<in> K (l, u);\n        \\<mu> =\n        map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n         \\<mu>'\\<rbrakk>\n       \\<Longrightarrow> u1 = u2\n 5. \\<lbrakk>return_pmf (l, u) \\<in> K (l, u);\n     \\<mu> = return_pmf (l, u)\\<rbrakk>\n    \\<Longrightarrow> l1 = l2\n 6. \\<lbrakk>return_pmf (l, u) \\<in> K (l, u);\n     \\<mu> = return_pmf (l, u)\\<rbrakk>\n    \\<Longrightarrow> u1 = u2", "case (4 _ _ \\<tau> \\<mu>')"], ["proof (state)\nthis:\n  (l, u) \\<in> S\n  (l, \\<tau>, \\<mu>') \\<in> PTA.trans_of A\n  u \\<turnstile> \\<tau>\n  map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n   \\<mu>'\n  \\<in> K (l, u)\n  \\<mu> =\n  map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n   \\<mu>'\n\ngoal (6 subgoals):\n 1. \\<And>la ua t.\n       \\<lbrakk>(l, u) \\<in> S; 0 \\<le> t;\n        u \\<oplus> t \\<turnstile> PTA.inv_of A l;\n        return_pmf (l, u \\<oplus> t) \\<in> K (l, u);\n        \\<mu> = return_pmf (l, u \\<oplus> t)\\<rbrakk>\n       \\<Longrightarrow> l1 = l2\n 2. \\<And>la ua t.\n       \\<lbrakk>(l, u) \\<in> S; 0 \\<le> t;\n        u \\<oplus> t \\<turnstile> PTA.inv_of A l;\n        return_pmf (l, u \\<oplus> t) \\<in> K (l, u);\n        \\<mu> = return_pmf (l, u \\<oplus> t)\\<rbrakk>\n       \\<Longrightarrow> u1 = u2\n 3. \\<And>la ua g \\<mu>'.\n       \\<lbrakk>(l, u) \\<in> S; (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        u \\<turnstile> g;\n        map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n         \\<mu>'\n        \\<in> K (l, u);\n        \\<mu> =\n        map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n         \\<mu>'\\<rbrakk>\n       \\<Longrightarrow> l1 = l2\n 4. \\<And>la ua g \\<mu>'.\n       \\<lbrakk>(l, u) \\<in> S; (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        u \\<turnstile> g;\n        map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n         \\<mu>'\n        \\<in> K (l, u);\n        \\<mu> =\n        map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n         \\<mu>'\\<rbrakk>\n       \\<Longrightarrow> u1 = u2\n 5. \\<lbrakk>return_pmf (l, u) \\<in> K (l, u);\n     \\<mu> = return_pmf (l, u)\\<rbrakk>\n    \\<Longrightarrow> l1 = l2\n 6. \\<lbrakk>return_pmf (l, u) \\<in> K (l, u);\n     \\<mu> = return_pmf (l, u)\\<rbrakk>\n    \\<Longrightarrow> u1 = u2", "from \\<open>\\<mu> = _\\<close> elem"], ["proof (chain)\npicking this:\n  \\<mu> =\n  map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n   \\<mu>'\n  (l1, u1) \\<in> set_pmf \\<mu>\n  (l2, u2) \\<in> set_pmf \\<mu>", "obtain X1 X2 where\n        \"u1 = [(SOME r. set r = X1)\\<rightarrow>0]u\" \"(X1, l1) \\<in> \\<mu>'\"\n        \"u2 = [(SOME r. set r = X2)\\<rightarrow>0]u\" \"(X2, l1) \\<in> \\<mu>'\""], ["proof (prove)\nusing this:\n  \\<mu> =\n  map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n   \\<mu>'\n  (l1, u1) \\<in> set_pmf \\<mu>\n  (l2, u2) \\<in> set_pmf \\<mu>\n\ngoal (1 subgoal):\n 1. (\\<And>X1 X2.\n        \\<lbrakk>u1 = [(SOME r. set r = X1)\\<rightarrow>0]u;\n         (X1, l1) \\<in> set_pmf \\<mu>';\n         u2 = [(SOME r. set r = X2)\\<rightarrow>0]u;\n         (X2, l1) \\<in> set_pmf \\<mu>'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  u1 = [(SOME r. set r = X1)\\<rightarrow>0]u\n  (X1, l1) \\<in> set_pmf \\<mu>'\n  u2 = [(SOME r. set r = X2)\\<rightarrow>0]u\n  (X2, l1) \\<in> set_pmf \\<mu>'\n\ngoal (6 subgoals):\n 1. \\<And>la ua t.\n       \\<lbrakk>(l, u) \\<in> S; 0 \\<le> t;\n        u \\<oplus> t \\<turnstile> PTA.inv_of A l;\n        return_pmf (l, u \\<oplus> t) \\<in> K (l, u);\n        \\<mu> = return_pmf (l, u \\<oplus> t)\\<rbrakk>\n       \\<Longrightarrow> l1 = l2\n 2. \\<And>la ua t.\n       \\<lbrakk>(l, u) \\<in> S; 0 \\<le> t;\n        u \\<oplus> t \\<turnstile> PTA.inv_of A l;\n        return_pmf (l, u \\<oplus> t) \\<in> K (l, u);\n        \\<mu> = return_pmf (l, u \\<oplus> t)\\<rbrakk>\n       \\<Longrightarrow> u1 = u2\n 3. \\<And>la ua g \\<mu>'.\n       \\<lbrakk>(l, u) \\<in> S; (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        u \\<turnstile> g;\n        map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n         \\<mu>'\n        \\<in> K (l, u);\n        \\<mu> =\n        map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n         \\<mu>'\\<rbrakk>\n       \\<Longrightarrow> l1 = l2\n 4. \\<And>la ua g \\<mu>'.\n       \\<lbrakk>(l, u) \\<in> S; (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        u \\<turnstile> g;\n        map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n         \\<mu>'\n        \\<in> K (l, u);\n        \\<mu> =\n        map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n         \\<mu>'\\<rbrakk>\n       \\<Longrightarrow> u1 = u2\n 5. \\<lbrakk>return_pmf (l, u) \\<in> K (l, u);\n     \\<mu> = return_pmf (l, u)\\<rbrakk>\n    \\<Longrightarrow> l1 = l2\n 6. \\<lbrakk>return_pmf (l, u) \\<in> K (l, u);\n     \\<mu> = return_pmf (l, u)\\<rbrakk>\n    \\<Longrightarrow> u1 = u2", "with \\<open>_ \\<in> trans_of _\\<close> admissible_targets_clocks"], ["proof (chain)\npicking this:\n  (l, \\<tau>, \\<mu>') \\<in> PTA.trans_of A\n  \\<lbrakk>(?l, ?g, ?\\<mu>) \\<in> PTA.trans_of A;\n   (?X, ?l') \\<in> set_pmf ?\\<mu>\\<rbrakk>\n  \\<Longrightarrow> ?X \\<subseteq> \\<X>\n  \\<lbrakk>(?l, ?g, ?\\<mu>) \\<in> PTA.trans_of A;\n   (?X, ?l') \\<in> set_pmf ?\\<mu>\\<rbrakk>\n  \\<Longrightarrow> set (SOME r. set r = ?X) \\<subseteq> \\<X>\n  u1 = [(SOME r. set r = X1)\\<rightarrow>0]u\n  (X1, l1) \\<in> set_pmf \\<mu>'\n  u2 = [(SOME r. set r = X2)\\<rightarrow>0]u\n  (X2, l1) \\<in> set_pmf \\<mu>'", "have\n        \"set (SOME r. set r = X1) \\<subseteq> \\<X>\" \"set (SOME r. set r = X2) \\<subseteq> \\<X>\""], ["proof (prove)\nusing this:\n  (l, \\<tau>, \\<mu>') \\<in> PTA.trans_of A\n  \\<lbrakk>(?l, ?g, ?\\<mu>) \\<in> PTA.trans_of A;\n   (?X, ?l') \\<in> set_pmf ?\\<mu>\\<rbrakk>\n  \\<Longrightarrow> ?X \\<subseteq> \\<X>\n  \\<lbrakk>(?l, ?g, ?\\<mu>) \\<in> PTA.trans_of A;\n   (?X, ?l') \\<in> set_pmf ?\\<mu>\\<rbrakk>\n  \\<Longrightarrow> set (SOME r. set r = ?X) \\<subseteq> \\<X>\n  u1 = [(SOME r. set r = X1)\\<rightarrow>0]u\n  (X1, l1) \\<in> set_pmf \\<mu>'\n  u2 = [(SOME r. set r = X2)\\<rightarrow>0]u\n  (X2, l1) \\<in> set_pmf \\<mu>'\n\ngoal (1 subgoal):\n 1. set (SOME r. set r = X1) \\<subseteq> \\<X> &&&\n    set (SOME r. set r = X2) \\<subseteq> \\<X>", "by auto"], ["proof (state)\nthis:\n  set (SOME r. set r = X1) \\<subseteq> \\<X>\n  set (SOME r. set r = X2) \\<subseteq> \\<X>\n\ngoal (6 subgoals):\n 1. \\<And>la ua t.\n       \\<lbrakk>(l, u) \\<in> S; 0 \\<le> t;\n        u \\<oplus> t \\<turnstile> PTA.inv_of A l;\n        return_pmf (l, u \\<oplus> t) \\<in> K (l, u);\n        \\<mu> = return_pmf (l, u \\<oplus> t)\\<rbrakk>\n       \\<Longrightarrow> l1 = l2\n 2. \\<And>la ua t.\n       \\<lbrakk>(l, u) \\<in> S; 0 \\<le> t;\n        u \\<oplus> t \\<turnstile> PTA.inv_of A l;\n        return_pmf (l, u \\<oplus> t) \\<in> K (l, u);\n        \\<mu> = return_pmf (l, u \\<oplus> t)\\<rbrakk>\n       \\<Longrightarrow> u1 = u2\n 3. \\<And>la ua g \\<mu>'.\n       \\<lbrakk>(l, u) \\<in> S; (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        u \\<turnstile> g;\n        map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n         \\<mu>'\n        \\<in> K (l, u);\n        \\<mu> =\n        map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n         \\<mu>'\\<rbrakk>\n       \\<Longrightarrow> l1 = l2\n 4. \\<And>la ua g \\<mu>'.\n       \\<lbrakk>(l, u) \\<in> S; (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        u \\<turnstile> g;\n        map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n         \\<mu>'\n        \\<in> K (l, u);\n        \\<mu> =\n        map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n         \\<mu>'\\<rbrakk>\n       \\<Longrightarrow> u1 = u2\n 5. \\<lbrakk>return_pmf (l, u) \\<in> K (l, u);\n     \\<mu> = return_pmf (l, u)\\<rbrakk>\n    \\<Longrightarrow> l1 = l2\n 6. \\<lbrakk>return_pmf (l, u) \\<in> K (l, u);\n     \\<mu> = return_pmf (l, u)\\<rbrakk>\n    \\<Longrightarrow> u1 = u2", "with id \\<open>u1 = _\\<close> \\<open>u2 = _\\<close> reset_eq[of u] \\<open>_ \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  (l1, [u1]\\<^sub>\\<R>) = (l2, [u2]\\<^sub>\\<R>)\n  u1 = [(SOME r. set r = X1)\\<rightarrow>0]u\n  u2 = [(SOME r. set r = X2)\\<rightarrow>0]u\n  \\<lbrakk>u \\<in> V;\n   [[?r\\<rightarrow>0]u]\\<^sub>\\<R> = [[?r'\\<rightarrow>0]u]\\<^sub>\\<R>;\n   set ?r \\<subseteq> \\<X>; set ?r' \\<subseteq> \\<X>\\<rbrakk>\n  \\<Longrightarrow> [?r\\<rightarrow>0]u = [?r'\\<rightarrow>0]u\n  (l, u) \\<in> S\n  set (SOME r. set r = X1) \\<subseteq> \\<X>\n  set (SOME r. set r = X2) \\<subseteq> \\<X>", "show ?case"], ["proof (prove)\nusing this:\n  (l1, [u1]\\<^sub>\\<R>) = (l2, [u2]\\<^sub>\\<R>)\n  u1 = [(SOME r. set r = X1)\\<rightarrow>0]u\n  u2 = [(SOME r. set r = X2)\\<rightarrow>0]u\n  \\<lbrakk>u \\<in> V;\n   [[?r\\<rightarrow>0]u]\\<^sub>\\<R> = [[?r'\\<rightarrow>0]u]\\<^sub>\\<R>;\n   set ?r \\<subseteq> \\<X>; set ?r' \\<subseteq> \\<X>\\<rbrakk>\n  \\<Longrightarrow> [?r\\<rightarrow>0]u = [?r'\\<rightarrow>0]u\n  (l, u) \\<in> S\n  set (SOME r. set r = X1) \\<subseteq> \\<X>\n  set (SOME r. set r = X2) \\<subseteq> \\<X>\n\ngoal (1 subgoal):\n 1. u1 = u2", "by (auto simp: S_def V_def)"], ["proof (state)\nthis:\n  u1 = u2\n\ngoal (5 subgoals):\n 1. \\<And>la ua t.\n       \\<lbrakk>(l, u) \\<in> S; 0 \\<le> t;\n        u \\<oplus> t \\<turnstile> PTA.inv_of A l;\n        return_pmf (l, u \\<oplus> t) \\<in> K (l, u);\n        \\<mu> = return_pmf (l, u \\<oplus> t)\\<rbrakk>\n       \\<Longrightarrow> l1 = l2\n 2. \\<And>la ua t.\n       \\<lbrakk>(l, u) \\<in> S; 0 \\<le> t;\n        u \\<oplus> t \\<turnstile> PTA.inv_of A l;\n        return_pmf (l, u \\<oplus> t) \\<in> K (l, u);\n        \\<mu> = return_pmf (l, u \\<oplus> t)\\<rbrakk>\n       \\<Longrightarrow> u1 = u2\n 3. \\<And>la ua g \\<mu>'.\n       \\<lbrakk>(l, u) \\<in> S; (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        u \\<turnstile> g;\n        map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n         \\<mu>'\n        \\<in> K (l, u);\n        \\<mu> =\n        map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n         \\<mu>'\\<rbrakk>\n       \\<Longrightarrow> l1 = l2\n 4. \\<lbrakk>return_pmf (l, u) \\<in> K (l, u);\n     \\<mu> = return_pmf (l, u)\\<rbrakk>\n    \\<Longrightarrow> l1 = l2\n 5. \\<lbrakk>return_pmf (l, u) \\<in> K (l, u);\n     \\<mu> = return_pmf (l, u)\\<rbrakk>\n    \\<Longrightarrow> u1 = u2", "qed (-, insert elem, simp)+"], ["proof (state)\nthis:\n  (l1, u1) = (l2, u2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>(?l1.3, [?u1.3]\\<^sub>\\<R>) = (?l2.3, [?u2.3]\\<^sub>\\<R>);\n   (?l1.3, ?u1.3) \\<in> set_pmf \\<mu>;\n   (?l2.3, ?u2.3) \\<in> set_pmf \\<mu>\\<rbrakk>\n  \\<Longrightarrow> (?l1.3, ?u1.3) = (?l2.3, ?u2.3)\n\ngoal (1 subgoal):\n 1. inj_on f (set_pmf \\<mu>)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?l1.3, [?u1.3]\\<^sub>\\<R>) = (?l2.3, [?u2.3]\\<^sub>\\<R>);\n   (?l1.3, ?u1.3) \\<in> set_pmf \\<mu>;\n   (?l2.3, ?u2.3) \\<in> set_pmf \\<mu>\\<rbrakk>\n  \\<Longrightarrow> (?l1.3, ?u1.3) = (?l2.3, ?u2.3)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?l1.3, [?u1.3]\\<^sub>\\<R>) = (?l2.3, [?u2.3]\\<^sub>\\<R>);\n   (?l1.3, ?u1.3) \\<in> set_pmf \\<mu>;\n   (?l2.3, ?u2.3) \\<in> set_pmf \\<mu>\\<rbrakk>\n  \\<Longrightarrow> (?l1.3, ?u1.3) = (?l2.3, ?u2.3)\n\ngoal (1 subgoal):\n 1. inj_on f (set_pmf \\<mu>)", "unfolding f_def inj_on_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?l1.3, [?u1.3]\\<^sub>\\<R>) = (?l2.3, [?u2.3]\\<^sub>\\<R>);\n   (?l1.3, ?u1.3) \\<in> set_pmf \\<mu>;\n   (?l2.3, ?u2.3) \\<in> set_pmf \\<mu>\\<rbrakk>\n  \\<Longrightarrow> (?l1.3, ?u1.3) = (?l2.3, ?u2.3)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_pmf \\<mu>.\n       \\<forall>y\\<in>set_pmf \\<mu>.\n          (case x of (l, u) \\<Rightarrow> (l, [u]\\<^sub>\\<R>)) =\n          (case y of\n           (l, u) \\<Rightarrow> (l, [u]\\<^sub>\\<R>)) \\<longrightarrow>\n          x = y", "by auto"], ["proof (state)\nthis:\n  inj_on f (set_pmf \\<mu>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma K_elem_repr_inj:\n  notes alpha_interp.valid_regions_distinct_spec[intro] (* XXX Declare somewhere else *)\n  assumes A: \"\\<mu> \\<in> \\<K> (l, R)\"\n  defines \"f \\<equiv> \\<lambda> (l, R). (l, SOME u. u \\<in> R)\"\n  shows \"inj_on f \\<mu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f (set_pmf \\<mu>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on f (set_pmf \\<mu>)", "have \"(l1, R1) = (l2, R2)\"\n    if id: \"(l1, SOME u. u \\<in> R1) = (l2, SOME u. u \\<in> R2)\" and elem: \"(l1, R1) \\<in> \\<mu>\" \"(l2, R2) \\<in> \\<mu>\"\n    for l1 l2 R1 R2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (l1, R1) = (l2, R2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (l1, R1) = (l2, R2)", "let ?r1 = \"SOME u. u \\<in> R1\" and ?r2 = \"SOME u. u \\<in> R2\""], ["proof (state)\ngoal (1 subgoal):\n 1. (l1, R1) = (l2, R2)", "from id"], ["proof (chain)\npicking this:\n  (l1, SOME u. u \\<in> R1) = (l2, SOME u. u \\<in> R2)", "have [simp]: \"l2 = l1\" \"?r2 = ?r1\""], ["proof (prove)\nusing this:\n  (l1, SOME u. u \\<in> R1) = (l2, SOME u. u \\<in> R2)\n\ngoal (1 subgoal):\n 1. l2 = l1 &&& (SOME u. u \\<in> R2) = (SOME u. u \\<in> R1)", "by auto"], ["proof (state)\nthis:\n  l2 = l1\n  (SOME u. u \\<in> R2) = (SOME u. u \\<in> R1)\n\ngoal (1 subgoal):\n 1. (l1, R1) = (l2, R2)", "{"], ["proof (state)\nthis:\n  l2 = l1\n  (SOME u. u \\<in> R2) = (SOME u. u \\<in> R1)\n\ngoal (1 subgoal):\n 1. (l1, R1) = (l2, R2)", "fix g \\<mu>' x"], ["proof (state)\ngoal (1 subgoal):\n 1. (l1, R1) = (l2, R2)", "assume \"(l, R) \\<in> \\<S>\" \"(l, g, \\<mu>') \\<in> PTA.trans_of A\" \"R \\<subseteq> {v. v \\<turnstile> g}\"\n         and \"\\<mu> = map_pmf (\\<lambda>(X, l). (l, region_set' R (SOME r. set r = X) 0)) \\<mu>'\""], ["proof (state)\nthis:\n  (l, R) \\<in> \\<S>\n  (l, g, \\<mu>') \\<in> PTA.trans_of A\n  R \\<subseteq> {v. v \\<turnstile> g}\n  \\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>'\n\ngoal (1 subgoal):\n 1. (l1, R1) = (l2, R2)", "from \\<open>\\<mu> = _\\<close> elem"], ["proof (chain)\npicking this:\n  \\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>'\n  (l1, R1) \\<in> set_pmf \\<mu>\n  (l2, R2) \\<in> set_pmf \\<mu>", "obtain X1 X2 where\n        \"R1 = region_set' R (SOME r. set r = X1) 0\" \"(X1, l1) \\<in> \\<mu>'\"\n        \"R2 = region_set' R (SOME r. set r = X2) 0\" \"(X2, l1) \\<in> \\<mu>'\""], ["proof (prove)\nusing this:\n  \\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>'\n  (l1, R1) \\<in> set_pmf \\<mu>\n  (l2, R2) \\<in> set_pmf \\<mu>\n\ngoal (1 subgoal):\n 1. (\\<And>X1 X2.\n        \\<lbrakk>R1 = [X1::=0]R; (X1, l1) \\<in> set_pmf \\<mu>';\n         R2 = [X2::=0]R; (X2, l1) \\<in> set_pmf \\<mu>'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  R1 = [X1::=0]R\n  (X1, l1) \\<in> set_pmf \\<mu>'\n  R2 = [X2::=0]R\n  (X2, l1) \\<in> set_pmf \\<mu>'\n\ngoal (1 subgoal):\n 1. (l1, R1) = (l2, R2)", "with \\<open>_ \\<in> trans_of _\\<close> admissible_targets_clocks"], ["proof (chain)\npicking this:\n  (l, g, \\<mu>') \\<in> PTA.trans_of A\n  \\<lbrakk>(?l, ?g, ?\\<mu>) \\<in> PTA.trans_of A;\n   (?X, ?l') \\<in> set_pmf ?\\<mu>\\<rbrakk>\n  \\<Longrightarrow> ?X \\<subseteq> \\<X>\n  \\<lbrakk>(?l, ?g, ?\\<mu>) \\<in> PTA.trans_of A;\n   (?X, ?l') \\<in> set_pmf ?\\<mu>\\<rbrakk>\n  \\<Longrightarrow> set (SOME r. set r = ?X) \\<subseteq> \\<X>\n  R1 = [X1::=0]R\n  (X1, l1) \\<in> set_pmf \\<mu>'\n  R2 = [X2::=0]R\n  (X2, l1) \\<in> set_pmf \\<mu>'", "have\n        \"set (SOME r. set r = X1) \\<subseteq> \\<X>\" \"set (SOME r. set r = X2) \\<subseteq> \\<X>\""], ["proof (prove)\nusing this:\n  (l, g, \\<mu>') \\<in> PTA.trans_of A\n  \\<lbrakk>(?l, ?g, ?\\<mu>) \\<in> PTA.trans_of A;\n   (?X, ?l') \\<in> set_pmf ?\\<mu>\\<rbrakk>\n  \\<Longrightarrow> ?X \\<subseteq> \\<X>\n  \\<lbrakk>(?l, ?g, ?\\<mu>) \\<in> PTA.trans_of A;\n   (?X, ?l') \\<in> set_pmf ?\\<mu>\\<rbrakk>\n  \\<Longrightarrow> set (SOME r. set r = ?X) \\<subseteq> \\<X>\n  R1 = [X1::=0]R\n  (X1, l1) \\<in> set_pmf \\<mu>'\n  R2 = [X2::=0]R\n  (X2, l1) \\<in> set_pmf \\<mu>'\n\ngoal (1 subgoal):\n 1. set (SOME r. set r = X1) \\<subseteq> \\<X> &&&\n    set (SOME r. set r = X2) \\<subseteq> \\<X>", "by auto"], ["proof (state)\nthis:\n  set (SOME r. set r = X1) \\<subseteq> \\<X>\n  set (SOME r. set r = X2) \\<subseteq> \\<X>\n\ngoal (1 subgoal):\n 1. (l1, R1) = (l2, R2)", "with alpha_interp.region_set'_closed[of _ 0] \\<open>R1 = _\\<close> \\<open>R2 = _\\<close> \\<open>_ \\<in> \\<S>\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>?R \\<in> \\<R>; 0 \\<le> 0; \\<forall>x\\<in>set ?r. 0 \\<le> k x;\n   set ?r \\<subseteq> \\<X>\\<rbrakk>\n  \\<Longrightarrow> region_set' ?R ?r (real 0) \\<in> \\<R>\n  R1 = [X1::=0]R\n  R2 = [X2::=0]R\n  (l, R) \\<in> \\<S>\n  set (SOME r. set r = X1) \\<subseteq> \\<X>\n  set (SOME r. set r = X2) \\<subseteq> \\<X>", "have\n        \"R1 \\<in> \\<R>\" \"R2 \\<in> \\<R>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?R \\<in> \\<R>; 0 \\<le> 0; \\<forall>x\\<in>set ?r. 0 \\<le> k x;\n   set ?r \\<subseteq> \\<X>\\<rbrakk>\n  \\<Longrightarrow> region_set' ?R ?r (real 0) \\<in> \\<R>\n  R1 = [X1::=0]R\n  R2 = [X2::=0]R\n  (l, R) \\<in> \\<S>\n  set (SOME r. set r = X1) \\<subseteq> \\<X>\n  set (SOME r. set r = X2) \\<subseteq> \\<X>\n\ngoal (1 subgoal):\n 1. R1 \\<in> \\<R> &&& R2 \\<in> \\<R>", "unfolding \\<S>_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?R \\<in> \\<R>; 0 \\<le> 0; \\<forall>x\\<in>set ?r. 0 \\<le> k x;\n   set ?r \\<subseteq> \\<X>\\<rbrakk>\n  \\<Longrightarrow> region_set' ?R ?r (real 0) \\<in> \\<R>\n  R1 = [X1::=0]R\n  R2 = [X2::=0]R\n  (l, R)\n  \\<in> {(l, R).\n         l \\<in> L \\<and>\n         R \\<in> \\<R> \\<and>\n         R \\<subseteq> {u. u \\<turnstile> PTA.inv_of A l}}\n  set (SOME r. set r = X1) \\<subseteq> \\<X>\n  set (SOME r. set r = X2) \\<subseteq> \\<X>\n\ngoal (1 subgoal):\n 1. R1 \\<in> \\<R> &&& R2 \\<in> \\<R>", "by auto"], ["proof (state)\nthis:\n  R1 \\<in> \\<R>\n  R2 \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. (l1, R1) = (l2, R2)", "with region_not_empty[OF finite(1)]"], ["proof (chain)\npicking this:\n  Regions.valid_region \\<X> ?k ?I ?r \\<Longrightarrow>\n  \\<exists>u. u \\<in> Regions.region \\<X> ?I ?r\n  R1 \\<in> \\<R>\n  R2 \\<in> \\<R>", "have\n        \"R1 \\<noteq> {}\" \"R2 \\<noteq> {}\" \"\\<exists>u. u \\<in> R1\" \"\\<exists>u. u \\<in> R2\""], ["proof (prove)\nusing this:\n  Regions.valid_region \\<X> ?k ?I ?r \\<Longrightarrow>\n  \\<exists>u. u \\<in> Regions.region \\<X> ?I ?r\n  R1 \\<in> \\<R>\n  R2 \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. (R1 \\<noteq> {} &&& R2 \\<noteq> {}) &&&\n    \\<exists>u. u \\<in> R1 &&& \\<exists>u. u \\<in> R2", "by (auto simp: \\<R>_def)"], ["proof (state)\nthis:\n  R1 \\<noteq> {}\n  R2 \\<noteq> {}\n  \\<exists>u. u \\<in> R1\n  \\<exists>u. u \\<in> R2\n\ngoal (1 subgoal):\n 1. (l1, R1) = (l2, R2)", "from someI_ex[OF this(3)] someI_ex[OF this(4)]"], ["proof (chain)\npicking this:\n  (SOME x. x \\<in> R1) \\<in> R1\n  (SOME x. x \\<in> R2) \\<in> R2", "have \"?r1 \\<in> R1\" \"?r1 \\<in> R2\""], ["proof (prove)\nusing this:\n  (SOME x. x \\<in> R1) \\<in> R1\n  (SOME x. x \\<in> R2) \\<in> R2\n\ngoal (1 subgoal):\n 1. (SOME u. u \\<in> R1) \\<in> R1 &&& (SOME u. u \\<in> R1) \\<in> R2", "by simp+"], ["proof (state)\nthis:\n  (SOME u. u \\<in> R1) \\<in> R1\n  (SOME u. u \\<in> R1) \\<in> R2\n\ngoal (1 subgoal):\n 1. (l1, R1) = (l2, R2)", "with \\<open>R1 \\<in> \\<R>\\<close> \\<open>R2 \\<in> \\<R>\\<close>"], ["proof (chain)\npicking this:\n  R1 \\<in> \\<R>\n  R2 \\<in> \\<R>\n  (SOME u. u \\<in> R1) \\<in> R1\n  (SOME u. u \\<in> R1) \\<in> R2", "have \"R1 = R2\""], ["proof (prove)\nusing this:\n  R1 \\<in> \\<R>\n  R2 \\<in> \\<R>\n  (SOME u. u \\<in> R1) \\<in> R1\n  (SOME u. u \\<in> R1) \\<in> R2\n\ngoal (1 subgoal):\n 1. R1 = R2", ".."], ["proof (state)\nthis:\n  R1 = R2\n\ngoal (1 subgoal):\n 1. (l1, R1) = (l2, R2)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(l, R) \\<in> \\<S>; (l, ?g5, ?\\<mu>'5) \\<in> PTA.trans_of A;\n   R \\<subseteq> {v. v \\<turnstile> ?g5};\n   \\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) ?\\<mu>'5\\<rbrakk>\n  \\<Longrightarrow> R1 = R2\n\ngoal (1 subgoal):\n 1. (l1, R1) = (l2, R2)", "from A elem this"], ["proof (chain)\npicking this:\n  \\<mu> \\<in> \\<K> (l, R)\n  (l1, R1) \\<in> set_pmf \\<mu>\n  (l2, R2) \\<in> set_pmf \\<mu>\n  \\<lbrakk>(l, R) \\<in> \\<S>; (l, ?g5, ?\\<mu>'5) \\<in> PTA.trans_of A;\n   R \\<subseteq> {v. v \\<turnstile> ?g5};\n   \\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) ?\\<mu>'5\\<rbrakk>\n  \\<Longrightarrow> R1 = R2", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<mu> \\<in> \\<K> (l, R)\n  (l1, R1) \\<in> set_pmf \\<mu>\n  (l2, R2) \\<in> set_pmf \\<mu>\n  \\<lbrakk>(l, R) \\<in> \\<S>; (l, ?g5, ?\\<mu>'5) \\<in> PTA.trans_of A;\n   R \\<subseteq> {v. v \\<turnstile> ?g5};\n   \\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) ?\\<mu>'5\\<rbrakk>\n  \\<Longrightarrow> R1 = R2\n\ngoal (1 subgoal):\n 1. (l1, R1) = (l2, R2)", "by (cases, auto)"], ["proof (state)\nthis:\n  (l1, R1) = (l2, R2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>(?l1.3, SOME u. u \\<in> ?R1.3) = (?l2.3, SOME u. u \\<in> ?R2.3);\n   (?l1.3, ?R1.3) \\<in> set_pmf \\<mu>;\n   (?l2.3, ?R2.3) \\<in> set_pmf \\<mu>\\<rbrakk>\n  \\<Longrightarrow> (?l1.3, ?R1.3) = (?l2.3, ?R2.3)\n\ngoal (1 subgoal):\n 1. inj_on f (set_pmf \\<mu>)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?l1.3, SOME u. u \\<in> ?R1.3) = (?l2.3, SOME u. u \\<in> ?R2.3);\n   (?l1.3, ?R1.3) \\<in> set_pmf \\<mu>;\n   (?l2.3, ?R2.3) \\<in> set_pmf \\<mu>\\<rbrakk>\n  \\<Longrightarrow> (?l1.3, ?R1.3) = (?l2.3, ?R2.3)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?l1.3, SOME u. u \\<in> ?R1.3) = (?l2.3, SOME u. u \\<in> ?R2.3);\n   (?l1.3, ?R1.3) \\<in> set_pmf \\<mu>;\n   (?l2.3, ?R2.3) \\<in> set_pmf \\<mu>\\<rbrakk>\n  \\<Longrightarrow> (?l1.3, ?R1.3) = (?l2.3, ?R2.3)\n\ngoal (1 subgoal):\n 1. inj_on f (set_pmf \\<mu>)", "unfolding f_def inj_on_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?l1.3, SOME u. u \\<in> ?R1.3) = (?l2.3, SOME u. u \\<in> ?R2.3);\n   (?l1.3, ?R1.3) \\<in> set_pmf \\<mu>;\n   (?l2.3, ?R2.3) \\<in> set_pmf \\<mu>\\<rbrakk>\n  \\<Longrightarrow> (?l1.3, ?R1.3) = (?l2.3, ?R2.3)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_pmf \\<mu>.\n       \\<forall>y\\<in>set_pmf \\<mu>.\n          (case x of (l, R) \\<Rightarrow> (l, SOME u. u \\<in> R)) =\n          (case y of\n           (l, R) \\<Rightarrow> (l, SOME u. u \\<in> R)) \\<longrightarrow>\n          x = y", "by auto"], ["proof (state)\nthis:\n  inj_on f (set_pmf \\<mu>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma K_elem_pmf_map_abs:\n  assumes A: \"\\<mu> \\<in> K (l, u)\" \"(l', u') \\<in> \\<mu>\"\n  defines \"f \\<equiv> \\<lambda> (l, u). (l, [u]\\<^sub>\\<R>)\"\n  shows \"pmf (map_pmf f \\<mu>) (f (l', u')) = pmf \\<mu> (l', u')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf (map_pmf f \\<mu>) (f (l', u')) = pmf \\<mu> (l', u')", "using A"], ["proof (prove)\nusing this:\n  \\<mu> \\<in> K (l, u)\n  (l', u') \\<in> set_pmf \\<mu>\n\ngoal (1 subgoal):\n 1. pmf (map_pmf f \\<mu>) (f (l', u')) = pmf \\<mu> (l', u')", "unfolding f_def"], ["proof (prove)\nusing this:\n  \\<mu> \\<in> K (l, u)\n  (l', u') \\<in> set_pmf \\<mu>\n\ngoal (1 subgoal):\n 1. pmf (map_pmf (\\<lambda>(l, u). (l, [u]\\<^sub>\\<R>)) \\<mu>)\n     (case (l', u') of (l, u) \\<Rightarrow> (l, [u]\\<^sub>\\<R>)) =\n    pmf \\<mu> (l', u')", "by (blast intro: pmf_map_inj K_elem_abs_inj)"], ["", "lemma K_elem_pmf_map_repr:\n  assumes A: \"\\<mu> \\<in> \\<K> (l, R)\" \"(l', R') \\<in> \\<mu>\"\n  defines \"f \\<equiv> \\<lambda> (l, R). (l, SOME u. u \\<in> R)\"\n  shows \"pmf (map_pmf f \\<mu>) (f (l', R')) = pmf \\<mu> (l', R')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf (map_pmf f \\<mu>) (f (l', R')) = pmf \\<mu> (l', R')", "using A"], ["proof (prove)\nusing this:\n  \\<mu> \\<in> \\<K> (l, R)\n  (l', R') \\<in> set_pmf \\<mu>\n\ngoal (1 subgoal):\n 1. pmf (map_pmf f \\<mu>) (f (l', R')) = pmf \\<mu> (l', R')", "unfolding f_def"], ["proof (prove)\nusing this:\n  \\<mu> \\<in> \\<K> (l, R)\n  (l', R') \\<in> set_pmf \\<mu>\n\ngoal (1 subgoal):\n 1. pmf (map_pmf (\\<lambda>(l, R). (l, SOME u. u \\<in> R)) \\<mu>)\n     (case (l', R') of (l, R) \\<Rightarrow> (l, SOME u. u \\<in> R)) =\n    pmf \\<mu> (l', R')", "by (blast intro: pmf_map_inj K_elem_repr_inj)"], ["", "definition transp :: \"('s * ('c, t) cval \\<Rightarrow> bool) \\<Rightarrow> 's * ('c, t) cval set \\<Rightarrow> bool\" where\n  \"transp \\<phi> \\<equiv> \\<lambda> (l, R). \\<forall> u \\<in> R. \\<phi> (l, u)\""], ["", "subsection \\<open>Translating Configurations\\<close>"], ["", "subsubsection \\<open>States\\<close>"], ["", "definition\n  abss :: \"'s * ('c, t) cval \\<Rightarrow> 's * ('c, t) cval set\"\nwhere\n  \"abss \\<equiv> \\<lambda> (l, u). if u \\<in> V then (l, [u]\\<^sub>\\<R>) else (l, -V)\""], ["", "definition\n  reps :: \"'s * ('c, t) cval set \\<Rightarrow> 's * ('c, t) cval\"\nwhere\n  \"reps \\<equiv> \\<lambda> (l, R). if R \\<in> \\<R> then (l, SOME u. u \\<in> R) else (l, \\<lambda>_. -1)\""], ["", "lemma \\<S>_reps_S[intro]:\n  assumes \"s \\<in> \\<S>\"\n  shows \"reps s \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reps s \\<in> S", "using assms \\<R>_V"], ["proof (prove)\nusing this:\n  s \\<in> \\<S>\n  \\<Union> \\<R> = V\n\ngoal (1 subgoal):\n 1. reps s \\<in> S", "unfolding S_def \\<S>_def reps_def V_def"], ["proof (prove)\nusing this:\n  s \\<in> {(l, R).\n           l \\<in> L \\<and>\n           R \\<in> \\<R> \\<and>\n           R \\<subseteq> {u. u \\<turnstile> PTA.inv_of A l}}\n  \\<Union> \\<R> = {v. \\<forall>x\\<in>\\<X>. 0 \\<le> v x}\n\ngoal (1 subgoal):\n 1. (case s of\n     (l, R) \\<Rightarrow>\n       if R \\<in> \\<R> then (l, SOME u. u \\<in> R)\n       else (l, \\<lambda>_. - 1))\n    \\<in> {(l, u).\n           l \\<in> L \\<and>\n           (\\<forall>x\\<in>\\<X>. 0 \\<le> u x) \\<and>\n           u \\<turnstile> PTA.inv_of A l}", "by force"], ["", "lemma S_abss_\\<S>[intro]:\n  assumes \"s \\<in> S\"\n  shows \"abss s \\<in> \\<S>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abss s \\<in> \\<S>", "using assms ccompatible_inv"], ["proof (prove)\nusing this:\n  s \\<in> S\n  ccompatible \\<R> (PTA.inv_of A ?l)\n\ngoal (1 subgoal):\n 1. abss s \\<in> \\<S>", "unfolding \\<S>_def S_alt_def abss_def ccompatible_def"], ["proof (prove)\nusing this:\n  s \\<in> {(l, u).\n           l \\<in> L \\<and> u \\<in> V \\<and> u \\<turnstile> PTA.inv_of A l}\n  \\<forall>R\\<in>\\<R>.\n     R \\<subseteq> {v. v \\<turnstile> PTA.inv_of A ?l} \\<or>\n     {v. v \\<turnstile> PTA.inv_of A ?l} \\<inter> R = {}\n\ngoal (1 subgoal):\n 1. (case s of\n     (l, u) \\<Rightarrow>\n       if u \\<in> V then (l, [u]\\<^sub>\\<R>) else (l, - V))\n    \\<in> {(l, R).\n           l \\<in> L \\<and>\n           R \\<in> \\<R> \\<and>\n           R \\<subseteq> {u. u \\<turnstile> PTA.inv_of A l}}", "by force"], ["", "lemma \\<S>_abss_reps[simp]:\n  \"s \\<in> \\<S> \\<Longrightarrow> abss (reps s) = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> \\<S> \\<Longrightarrow> abss (reps s) = s", "using \\<R>_V alpha_interp.region_unique_spec"], ["proof (prove)\nusing this:\n  \\<Union> \\<R> = V\n  \\<lbrakk>?u \\<in> ?R; ?R \\<in> \\<R>\\<rbrakk>\n  \\<Longrightarrow> [?u]\\<^sub>\\<R> = ?R\n\ngoal (1 subgoal):\n 1. s \\<in> \\<S> \\<Longrightarrow> abss (reps s) = s", "by (auto simp: S_def \\<S>_def reps_def abss_def; blast)"], ["", "lemma map_pmf_abs_reps:\n  assumes \"s \\<in> \\<S>\" \"\\<mu> \\<in> \\<K> s\"\n  shows \"map_pmf abss (map_pmf reps \\<mu>) = \\<mu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf abss (map_pmf reps \\<mu>) = \\<mu>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_pmf abss (map_pmf reps \\<mu>) = \\<mu>", "have \"map_pmf abss (map_pmf reps \\<mu>) = map_pmf (abss o reps) \\<mu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf abss (map_pmf reps \\<mu>) = map_pmf (abss \\<circ> reps) \\<mu>", "by (simp add: pmf.map_comp)"], ["proof (state)\nthis:\n  map_pmf abss (map_pmf reps \\<mu>) = map_pmf (abss \\<circ> reps) \\<mu>\n\ngoal (1 subgoal):\n 1. map_pmf abss (map_pmf reps \\<mu>) = \\<mu>", "also"], ["proof (state)\nthis:\n  map_pmf abss (map_pmf reps \\<mu>) = map_pmf (abss \\<circ> reps) \\<mu>\n\ngoal (1 subgoal):\n 1. map_pmf abss (map_pmf reps \\<mu>) = \\<mu>", "have \"\\<dots> = \\<mu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (abss \\<circ> reps) \\<mu> = \\<mu>", "proof (rule map_pmf_idI, safe, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set_pmf \\<mu> \\<Longrightarrow>\n       (abss \\<circ> reps) (a, b) = (a, b)", "case prems: (1 l' R')"], ["proof (state)\nthis:\n  (l', R') \\<in> set_pmf \\<mu>\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set_pmf \\<mu> \\<Longrightarrow>\n       (abss \\<circ> reps) (a, b) = (a, b)", "with assms"], ["proof (chain)\npicking this:\n  s \\<in> \\<S>\n  \\<mu> \\<in> \\<K> s\n  (l', R') \\<in> set_pmf \\<mu>", "have \"(l', R') \\<in> \\<S>\" \"reps (l', R') \\<in> S\""], ["proof (prove)\nusing this:\n  s \\<in> \\<S>\n  \\<mu> \\<in> \\<K> s\n  (l', R') \\<in> set_pmf \\<mu>\n\ngoal (1 subgoal):\n 1. (l', R') \\<in> \\<S> &&& reps (l', R') \\<in> S", "by auto"], ["proof (state)\nthis:\n  (l', R') \\<in> \\<S>\n  reps (l', R') \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set_pmf \\<mu> \\<Longrightarrow>\n       (abss \\<circ> reps) (a, b) = (a, b)", "then"], ["proof (chain)\npicking this:\n  (l', R') \\<in> \\<S>\n  reps (l', R') \\<in> S", "show ?case"], ["proof (prove)\nusing this:\n  (l', R') \\<in> \\<S>\n  reps (l', R') \\<in> S\n\ngoal (1 subgoal):\n 1. (abss \\<circ> reps) (l', R') = (l', R')", "by auto"], ["proof (state)\nthis:\n  (abss \\<circ> reps) (l', R') = (l', R')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_pmf (abss \\<circ> reps) \\<mu> = \\<mu>\n\ngoal (1 subgoal):\n 1. map_pmf abss (map_pmf reps \\<mu>) = \\<mu>", "finally"], ["proof (chain)\npicking this:\n  map_pmf abss (map_pmf reps \\<mu>) = \\<mu>", "show ?thesis"], ["proof (prove)\nusing this:\n  map_pmf abss (map_pmf reps \\<mu>) = \\<mu>\n\ngoal (1 subgoal):\n 1. map_pmf abss (map_pmf reps \\<mu>) = \\<mu>", "by auto"], ["proof (state)\nthis:\n  map_pmf abss (map_pmf reps \\<mu>) = \\<mu>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma abss_reps_id:\n  notes R_G.cfg_onD_state[simp del]\n  assumes \"s' \\<in> \\<S>\" \"s \\<in> set_pmf (action cfg)\" \"cfg \\<in> R_G.cfg_on s'\"\n  shows \"abss (reps s) = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abss (reps s) = s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. abss (reps s) = s", "from assms"], ["proof (chain)\npicking this:\n  s' \\<in> \\<S>\n  s \\<in> set_pmf (action cfg)\n  cfg \\<in> R_G.cfg_on s'", "have \"s \\<in> \\<S>\""], ["proof (prove)\nusing this:\n  s' \\<in> \\<S>\n  s \\<in> set_pmf (action cfg)\n  cfg \\<in> R_G.cfg_on s'\n\ngoal (1 subgoal):\n 1. s \\<in> \\<S>", "by auto"], ["proof (state)\nthis:\n  s \\<in> \\<S>\n\ngoal (1 subgoal):\n 1. abss (reps s) = s", "then"], ["proof (chain)\npicking this:\n  s \\<in> \\<S>", "show ?thesis"], ["proof (prove)\nusing this:\n  s \\<in> \\<S>\n\ngoal (1 subgoal):\n 1. abss (reps s) = s", "by auto"], ["proof (state)\nthis:\n  abss (reps s) = s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma abss_S[intro]:\n  assumes \"(l, u) \\<in> S\"\n  shows \"abss (l, u) = (l, [u]\\<^sub>\\<R>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abss (l, u) = (l, [u]\\<^sub>\\<R>)", "using assms"], ["proof (prove)\nusing this:\n  (l, u) \\<in> S\n\ngoal (1 subgoal):\n 1. abss (l, u) = (l, [u]\\<^sub>\\<R>)", "unfolding abss_def"], ["proof (prove)\nusing this:\n  (l, u) \\<in> S\n\ngoal (1 subgoal):\n 1. (case (l, u) of\n     (l, u) \\<Rightarrow>\n       if u \\<in> V then (l, [u]\\<^sub>\\<R>) else (l, - V)) =\n    (l, [u]\\<^sub>\\<R>)", "by auto"], ["", "lemma reps_\\<S>[intro]:\n  assumes \"(l, R) \\<in> \\<S>\"\n  shows \"reps (l, R) = (l, SOME u. u \\<in> R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reps (l, R) = (l, SOME u. u \\<in> R)", "using assms"], ["proof (prove)\nusing this:\n  (l, R) \\<in> \\<S>\n\ngoal (1 subgoal):\n 1. reps (l, R) = (l, SOME u. u \\<in> R)", "unfolding reps_def"], ["proof (prove)\nusing this:\n  (l, R) \\<in> \\<S>\n\ngoal (1 subgoal):\n 1. (case (l, R) of\n     (l, R) \\<Rightarrow>\n       if R \\<in> \\<R> then (l, SOME u. u \\<in> R)\n       else (l, \\<lambda>_. - 1)) =\n    (l, SOME u. u \\<in> R)", "by auto"], ["", "lemma fst_abss:\n  \"fst (abss st) = fst st\" for st"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (abss st) = fst st", "by (cases st) (auto simp: abss_def)"], ["", "lemma K_elem_abss_inj:\n  assumes A: \"\\<mu> \\<in> K (l, u)\" \"(l, u) \\<in> S\"\n  shows \"inj_on abss \\<mu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on abss (set_pmf \\<mu>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on abss (set_pmf \\<mu>)", "from assms"], ["proof (chain)\npicking this:\n  \\<mu> \\<in> K (l, u)\n  (l, u) \\<in> S", "have \"abss s' = (\\<lambda> (l, u). (l, [u]\\<^sub>\\<R>)) s'\" if \"s' \\<in> \\<mu>\" for s'"], ["proof (prove)\nusing this:\n  \\<mu> \\<in> K (l, u)\n  (l, u) \\<in> S\n\ngoal (1 subgoal):\n 1. abss s' = (case s' of (l, u) \\<Rightarrow> (l, [u]\\<^sub>\\<R>))", "using that"], ["proof (prove)\nusing this:\n  \\<mu> \\<in> K (l, u)\n  (l, u) \\<in> S\n  s' \\<in> set_pmf \\<mu>\n\ngoal (1 subgoal):\n 1. abss s' = (case s' of (l, u) \\<Rightarrow> (l, [u]\\<^sub>\\<R>))", "by (auto split: prod.split)"], ["proof (state)\nthis:\n  ?s'3 \\<in> set_pmf \\<mu> \\<Longrightarrow>\n  abss ?s'3 = (case ?s'3 of (l, u) \\<Rightarrow> (l, [u]\\<^sub>\\<R>))\n\ngoal (1 subgoal):\n 1. inj_on abss (set_pmf \\<mu>)", "from inj_on_cong[OF this] K_elem_abs_inj[OF A(1)]"], ["proof (chain)\npicking this:\n  (\\<And>a.\n      a \\<in> ?A \\<Longrightarrow>\n      ?s'4 a \\<in> set_pmf \\<mu>) \\<Longrightarrow>\n  inj_on (\\<lambda>a. abss (?s'4 a)) ?A =\n  inj_on\n   (\\<lambda>a. case ?s'4 a of (l, u) \\<Rightarrow> (l, [u]\\<^sub>\\<R>)) ?A\n  inj_on (\\<lambda>(l, u). (l, [u]\\<^sub>\\<R>)) (set_pmf \\<mu>)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>a.\n      a \\<in> ?A \\<Longrightarrow>\n      ?s'4 a \\<in> set_pmf \\<mu>) \\<Longrightarrow>\n  inj_on (\\<lambda>a. abss (?s'4 a)) ?A =\n  inj_on\n   (\\<lambda>a. case ?s'4 a of (l, u) \\<Rightarrow> (l, [u]\\<^sub>\\<R>)) ?A\n  inj_on (\\<lambda>(l, u). (l, [u]\\<^sub>\\<R>)) (set_pmf \\<mu>)\n\ngoal (1 subgoal):\n 1. inj_on abss (set_pmf \\<mu>)", "by force"], ["proof (state)\nthis:\n  inj_on abss (set_pmf \\<mu>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<K>_elem_reps_inj:\n  assumes A: \"\\<mu> \\<in> \\<K> (l, R)\" \"(l, R) \\<in> \\<S>\"\n  shows \"inj_on reps \\<mu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on reps (set_pmf \\<mu>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on reps (set_pmf \\<mu>)", "from assms"], ["proof (chain)\npicking this:\n  \\<mu> \\<in> \\<K> (l, R)\n  (l, R) \\<in> \\<S>", "have \"reps s' = (\\<lambda> (l, R). (l, SOME u. u \\<in> R)) s'\" if \"s' \\<in> \\<mu>\" for s'"], ["proof (prove)\nusing this:\n  \\<mu> \\<in> \\<K> (l, R)\n  (l, R) \\<in> \\<S>\n\ngoal (1 subgoal):\n 1. reps s' = (case s' of (l, R) \\<Rightarrow> (l, SOME u. u \\<in> R))", "using that"], ["proof (prove)\nusing this:\n  \\<mu> \\<in> \\<K> (l, R)\n  (l, R) \\<in> \\<S>\n  s' \\<in> set_pmf \\<mu>\n\ngoal (1 subgoal):\n 1. reps s' = (case s' of (l, R) \\<Rightarrow> (l, SOME u. u \\<in> R))", "by (auto split: prod.split)"], ["proof (state)\nthis:\n  ?s'3 \\<in> set_pmf \\<mu> \\<Longrightarrow>\n  reps ?s'3 = (case ?s'3 of (l, R) \\<Rightarrow> (l, SOME u. u \\<in> R))\n\ngoal (1 subgoal):\n 1. inj_on reps (set_pmf \\<mu>)", "from inj_on_cong[OF this] K_elem_repr_inj[OF A(1)]"], ["proof (chain)\npicking this:\n  (\\<And>a.\n      a \\<in> ?A \\<Longrightarrow>\n      ?s'4 a \\<in> set_pmf \\<mu>) \\<Longrightarrow>\n  inj_on (\\<lambda>a. reps (?s'4 a)) ?A =\n  inj_on\n   (\\<lambda>a. case ?s'4 a of (l, R) \\<Rightarrow> (l, SOME u. u \\<in> R))\n   ?A\n  inj_on (\\<lambda>(l, R). (l, SOME u. u \\<in> R)) (set_pmf \\<mu>)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>a.\n      a \\<in> ?A \\<Longrightarrow>\n      ?s'4 a \\<in> set_pmf \\<mu>) \\<Longrightarrow>\n  inj_on (\\<lambda>a. reps (?s'4 a)) ?A =\n  inj_on\n   (\\<lambda>a. case ?s'4 a of (l, R) \\<Rightarrow> (l, SOME u. u \\<in> R))\n   ?A\n  inj_on (\\<lambda>(l, R). (l, SOME u. u \\<in> R)) (set_pmf \\<mu>)\n\ngoal (1 subgoal):\n 1. inj_on reps (set_pmf \\<mu>)", "by force"], ["proof (state)\nthis:\n  inj_on reps (set_pmf \\<mu>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma P_elem_pmf_map_abss:\n  assumes A: \"\\<mu> \\<in> K (l, u)\" \"(l, u) \\<in> S\" \"s' \\<in> \\<mu>\"\n  shows \"pmf (map_pmf abss \\<mu>) (abss s') = pmf \\<mu> s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf (map_pmf abss \\<mu>) (abss s') = pmf \\<mu> s'", "using A"], ["proof (prove)\nusing this:\n  \\<mu> \\<in> K (l, u)\n  (l, u) \\<in> S\n  s' \\<in> set_pmf \\<mu>\n\ngoal (1 subgoal):\n 1. pmf (map_pmf abss \\<mu>) (abss s') = pmf \\<mu> s'", "by (blast intro: pmf_map_inj K_elem_abss_inj)"], ["", "lemma \\<K>_elem_pmf_map_reps:\n  assumes A: \"\\<mu> \\<in> \\<K> (l, R)\" \"(l, R) \\<in> \\<S>\" \"(l', R') \\<in> \\<mu>\"\n  shows \"pmf (map_pmf reps \\<mu>) (reps (l', R')) = pmf \\<mu> (l', R')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf (map_pmf reps \\<mu>) (reps (l', R')) = pmf \\<mu> (l', R')", "using A"], ["proof (prove)\nusing this:\n  \\<mu> \\<in> \\<K> (l, R)\n  (l, R) \\<in> \\<S>\n  (l', R') \\<in> set_pmf \\<mu>\n\ngoal (1 subgoal):\n 1. pmf (map_pmf reps \\<mu>) (reps (l', R')) = pmf \\<mu> (l', R')", "by (blast intro: pmf_map_inj \\<K>_elem_reps_inj)"], ["", "text \\<open>We need that \\<open>\\<X>\\<close> is non-trivial here\\<close>"], ["", "lemma not_\\<S>_reps:\n  \"(l, R) \\<notin> \\<S> \\<Longrightarrow> reps (l, R) \\<notin> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l, R) \\<notin> \\<S> \\<Longrightarrow> reps (l, R) \\<notin> S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (l, R) \\<notin> \\<S> \\<Longrightarrow> reps (l, R) \\<notin> S", "assume \"(l, R) \\<notin> \\<S>\""], ["proof (state)\nthis:\n  (l, R) \\<notin> \\<S>\n\ngoal (1 subgoal):\n 1. (l, R) \\<notin> \\<S> \\<Longrightarrow> reps (l, R) \\<notin> S", "let ?u = \"SOME u. u \\<in> R\""], ["proof (state)\ngoal (1 subgoal):\n 1. (l, R) \\<notin> \\<S> \\<Longrightarrow> reps (l, R) \\<notin> S", "have \"\\<not> ?u \\<turnstile> inv_of A l\" if \"R \\<in> \\<R>\" \"l \\<in> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (SOME u. u \\<in> R) \\<turnstile> PTA.inv_of A l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (SOME u. u \\<in> R) \\<turnstile> PTA.inv_of A l", "(* XXX Refactor -- doing that kind of proof at other places too *)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (SOME u. u \\<in> R) \\<turnstile> PTA.inv_of A l", "from region_not_empty[OF finite(1)] \\<open>R \\<in> \\<R>\\<close>"], ["proof (chain)\npicking this:\n  Regions.valid_region \\<X> ?k ?I ?r \\<Longrightarrow>\n  \\<exists>u. u \\<in> Regions.region \\<X> ?I ?r\n  R \\<in> \\<R>", "have \"\\<exists>u. u \\<in> R\""], ["proof (prove)\nusing this:\n  Regions.valid_region \\<X> ?k ?I ?r \\<Longrightarrow>\n  \\<exists>u. u \\<in> Regions.region \\<X> ?I ?r\n  R \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<exists>u. u \\<in> R", "by (auto simp: \\<R>_def)"], ["proof (state)\nthis:\n  \\<exists>u. u \\<in> R\n\ngoal (1 subgoal):\n 1. \\<not> (SOME u. u \\<in> R) \\<turnstile> PTA.inv_of A l", "from someI_ex[OF this]"], ["proof (chain)\npicking this:\n  (SOME x. x \\<in> R) \\<in> R", "have \"?u \\<in> R\""], ["proof (prove)\nusing this:\n  (SOME x. x \\<in> R) \\<in> R\n\ngoal (1 subgoal):\n 1. (SOME u. u \\<in> R) \\<in> R", "."], ["proof (state)\nthis:\n  (SOME u. u \\<in> R) \\<in> R\n\ngoal (1 subgoal):\n 1. \\<not> (SOME u. u \\<in> R) \\<turnstile> PTA.inv_of A l", "moreover"], ["proof (state)\nthis:\n  (SOME u. u \\<in> R) \\<in> R\n\ngoal (1 subgoal):\n 1. \\<not> (SOME u. u \\<in> R) \\<turnstile> PTA.inv_of A l", "from \\<open>(l, R) \\<notin> \\<S>\\<close> that"], ["proof (chain)\npicking this:\n  (l, R) \\<notin> \\<S>\n  R \\<in> \\<R>\n  l \\<in> L", "have \"\\<not> R \\<subseteq> \\<lbrace>inv_of A l\\<rbrace>\""], ["proof (prove)\nusing this:\n  (l, R) \\<notin> \\<S>\n  R \\<in> \\<R>\n  l \\<in> L\n\ngoal (1 subgoal):\n 1. \\<not> R \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}", "by (auto simp: \\<S>_def)"], ["proof (state)\nthis:\n  \\<not> R \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\n\ngoal (1 subgoal):\n 1. \\<not> (SOME u. u \\<in> R) \\<turnstile> PTA.inv_of A l", "ultimately"], ["proof (chain)\npicking this:\n  (SOME u. u \\<in> R) \\<in> R\n  \\<not> R \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}", "show ?thesis"], ["proof (prove)\nusing this:\n  (SOME u. u \\<in> R) \\<in> R\n  \\<not> R \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\n\ngoal (1 subgoal):\n 1. \\<not> (SOME u. u \\<in> R) \\<turnstile> PTA.inv_of A l", "using ccompatible_inv[of l] \\<open>R \\<in> \\<R>\\<close>"], ["proof (prove)\nusing this:\n  (SOME u. u \\<in> R) \\<in> R\n  \\<not> R \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\n  ccompatible \\<R> (PTA.inv_of A l)\n  R \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<not> (SOME u. u \\<in> R) \\<turnstile> PTA.inv_of A l", "unfolding ccompatible_def"], ["proof (prove)\nusing this:\n  (SOME u. u \\<in> R) \\<in> R\n  \\<not> R \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\n  \\<forall>R\\<in>\\<R>.\n     R \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l} \\<or>\n     {v. v \\<turnstile> PTA.inv_of A l} \\<inter> R = {}\n  R \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<not> (SOME u. u \\<in> R) \\<turnstile> PTA.inv_of A l", "by fastforce"], ["proof (state)\nthis:\n  \\<not> (SOME u. u \\<in> R) \\<turnstile> PTA.inv_of A l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>R \\<in> \\<R>; l \\<in> L\\<rbrakk>\n  \\<Longrightarrow> \\<not> (SOME u. u \\<in> R) \\<turnstile> PTA.inv_of A l\n\ngoal (1 subgoal):\n 1. (l, R) \\<notin> \\<S> \\<Longrightarrow> reps (l, R) \\<notin> S", "with non_empty \\<open>(l, R) \\<notin> \\<S>\\<close>"], ["proof (chain)\npicking this:\n  \\<X> \\<noteq> {}\n  (l, R) \\<notin> \\<S>\n  \\<lbrakk>R \\<in> \\<R>; l \\<in> L\\<rbrakk>\n  \\<Longrightarrow> \\<not> (SOME u. u \\<in> R) \\<turnstile> PTA.inv_of A l", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<X> \\<noteq> {}\n  (l, R) \\<notin> \\<S>\n  \\<lbrakk>R \\<in> \\<R>; l \\<in> L\\<rbrakk>\n  \\<Longrightarrow> \\<not> (SOME u. u \\<in> R) \\<turnstile> PTA.inv_of A l\n\ngoal (1 subgoal):\n 1. reps (l, R) \\<notin> S", "unfolding \\<S>_def S_def reps_def"], ["proof (prove)\nusing this:\n  \\<X> \\<noteq> {}\n  (l, R)\n  \\<notin> {(l, R).\n            l \\<in> L \\<and>\n            R \\<in> \\<R> \\<and>\n            R \\<subseteq> {u. u \\<turnstile> PTA.inv_of A l}}\n  \\<lbrakk>R \\<in> \\<R>; l \\<in> L\\<rbrakk>\n  \\<Longrightarrow> \\<not> (SOME u. u \\<in> R) \\<turnstile> PTA.inv_of A l\n\ngoal (1 subgoal):\n 1. (case (l, R) of\n     (l, R) \\<Rightarrow>\n       if R \\<in> \\<R> then (l, SOME u. u \\<in> R)\n       else (l, \\<lambda>_. - 1))\n    \\<notin> {(l, u).\n              l \\<in> L \\<and>\n              (\\<forall>x\\<in>\\<X>. 0 \\<le> u x) \\<and>\n              u \\<turnstile> PTA.inv_of A l}", "by auto"], ["proof (state)\nthis:\n  reps (l, R) \\<notin> S\n\ngoal:\nNo subgoals!", "qed"], ["", "(* XXX Move up *)"], ["", "lemma neq_V_not_region:\n  \"-V \\<notin> \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - V \\<notin> \\<R>", "using \\<R>_V rep_\\<R>_ex"], ["proof (prove)\nusing this:\n  \\<Union> \\<R> = V\n  ?R \\<in> \\<R> \\<Longrightarrow> (SOME u. u \\<in> ?R) \\<in> ?R\n\ngoal (1 subgoal):\n 1. - V \\<notin> \\<R>", "by auto"], ["", "lemma \\<S>_abss_S:\n  \"abss s \\<in> \\<S> \\<Longrightarrow> s \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abss s \\<in> \\<S> \\<Longrightarrow> s \\<in> S", "unfolding abss_def \\<S>_def S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case s of\n     (l, u) \\<Rightarrow>\n       if u \\<in> V then (l, [u]\\<^sub>\\<R>) else (l, - V))\n    \\<in> {(l, R).\n           l \\<in> L \\<and>\n           R \\<in> \\<R> \\<and>\n           R \\<subseteq> {u. u \\<turnstile> PTA.inv_of A\n       l}} \\<Longrightarrow>\n    s \\<in> {(l, u).\n             l \\<in> L \\<and>\n             (\\<forall>x\\<in>\\<X>. 0 \\<le> u x) \\<and>\n             u \\<turnstile> PTA.inv_of A l}", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y l u.\n       \\<lbrakk>(if u \\<in> V then (l, [u]\\<^sub>\\<R>) else (l, - V)) =\n                (x, y);\n        s = (l, u); x \\<in> L; y \\<in> \\<R>;\n        y \\<subseteq> {u. u \\<turnstile> PTA.inv_of A x}\\<rbrakk>\n       \\<Longrightarrow> l \\<in> L\n 2. \\<And>x y l u xa.\n       \\<lbrakk>(if u \\<in> V then (l, [u]\\<^sub>\\<R>) else (l, - V)) =\n                (x, y);\n        s = (l, u); x \\<in> L; y \\<in> \\<R>;\n        y \\<subseteq> {u. u \\<turnstile> PTA.inv_of A x};\n        xa \\<in> \\<X>\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> u xa\n 3. \\<And>x y l u.\n       \\<lbrakk>(if u \\<in> V then (l, [u]\\<^sub>\\<R>) else (l, - V)) =\n                (x, y);\n        s = (l, u); x \\<in> L; y \\<in> \\<R>;\n        y \\<subseteq> {u. u \\<turnstile> PTA.inv_of A x}\\<rbrakk>\n       \\<Longrightarrow> u \\<turnstile> PTA.inv_of A l", "subgoal for _ _ _ u"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(if u \\<in> V then (l_, [u]\\<^sub>\\<R>) else (l_, - V)) =\n             (x_, y_);\n     s = (l_, u); x_ \\<in> L; y_ \\<in> \\<R>;\n     y_ \\<subseteq> {u. u \\<turnstile> PTA.inv_of A x_}\\<rbrakk>\n    \\<Longrightarrow> l_ \\<in> L", "by (cases \"u \\<in> V\") auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y l u xa.\n       \\<lbrakk>(if u \\<in> V then (l, [u]\\<^sub>\\<R>) else (l, - V)) =\n                (x, y);\n        s = (l, u); x \\<in> L; y \\<in> \\<R>;\n        y \\<subseteq> {u. u \\<turnstile> PTA.inv_of A x};\n        xa \\<in> \\<X>\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> u xa\n 2. \\<And>x y l u.\n       \\<lbrakk>(if u \\<in> V then (l, [u]\\<^sub>\\<R>) else (l, - V)) =\n                (x, y);\n        s = (l, u); x \\<in> L; y \\<in> \\<R>;\n        y \\<subseteq> {u. u \\<turnstile> PTA.inv_of A x}\\<rbrakk>\n       \\<Longrightarrow> u \\<turnstile> PTA.inv_of A l", "subgoal for _ _ _ u"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(if u \\<in> V then (l_, [u]\\<^sub>\\<R>) else (l_, - V)) =\n             (x_, y_);\n     s = (l_, u); x_ \\<in> L; y_ \\<in> \\<R>;\n     y_ \\<subseteq> {u. u \\<turnstile> PTA.inv_of A x_};\n     xa_ \\<in> \\<X>\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> u xa_", "using neq_V_not_region"], ["proof (prove)\nusing this:\n  - V \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(if u \\<in> V then (l_, [u]\\<^sub>\\<R>) else (l_, - V)) =\n             (x_, y_);\n     s = (l_, u); x_ \\<in> L; y_ \\<in> \\<R>;\n     y_ \\<subseteq> {u. u \\<turnstile> PTA.inv_of A x_};\n     xa_ \\<in> \\<X>\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> u xa_", "by (cases \"u \\<in> V\", (auto simp: V_def; fail), auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y l u.\n       \\<lbrakk>(if u \\<in> V then (l, [u]\\<^sub>\\<R>) else (l, - V)) =\n                (x, y);\n        s = (l, u); x \\<in> L; y \\<in> \\<R>;\n        y \\<subseteq> {u. u \\<turnstile> PTA.inv_of A x}\\<rbrakk>\n       \\<Longrightarrow> u \\<turnstile> PTA.inv_of A l", "subgoal for l' y l u"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(if u \\<in> V then (l, [u]\\<^sub>\\<R>) else (l, - V)) =\n             (l', y);\n     s = (l, u); l' \\<in> L; y \\<in> \\<R>;\n     y \\<subseteq> {u. u \\<turnstile> PTA.inv_of A l'}\\<rbrakk>\n    \\<Longrightarrow> u \\<turnstile> PTA.inv_of A l", "using neq_V_not_region"], ["proof (prove)\nusing this:\n  - V \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(if u \\<in> V then (l, [u]\\<^sub>\\<R>) else (l, - V)) =\n             (l', y);\n     s = (l, u); l' \\<in> L; y \\<in> \\<R>;\n     y \\<subseteq> {u. u \\<turnstile> PTA.inv_of A l'}\\<rbrakk>\n    \\<Longrightarrow> u \\<turnstile> PTA.inv_of A l", "by (cases \"u \\<in> V\"; auto dest: regions_part_ex)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma S_pred_stream_abss_\\<S>:\n  \"pred_stream (\\<lambda> s. s \\<in> S) xs \\<longleftrightarrow> pred_stream (\\<lambda> s. s \\<in> \\<S>) (smap abss xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>s. s \\<in> S) xs =\n    pred_stream (\\<lambda>s. s \\<in> \\<S>) (smap abss xs)", "using S_abss_\\<S> \\<S>_abss_S"], ["proof (prove)\nusing this:\n  ?s \\<in> S \\<Longrightarrow> abss ?s \\<in> \\<S>\n  abss ?s \\<in> \\<S> \\<Longrightarrow> ?s \\<in> S\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>s. s \\<in> S) xs =\n    pred_stream (\\<lambda>s. s \\<in> \\<S>) (smap abss xs)", "by (auto simp: stream.pred_set)"], ["", "sublocale MDP: Markov_Decision_Process_Invariant K S"], ["proof (prove)\ngoal (1 subgoal):\n 1. Markov_Decision_Process_Invariant K S", "by (standard, auto)"], ["", "abbreviation (input) \"valid_cfg \\<equiv> MDP.valid_cfg\""], ["", "lemma K_closed:\n  \"s \\<in> S \\<Longrightarrow> (\\<Union>D\\<in>K s. set_pmf D) \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> S \\<Longrightarrow> \\<Union> (set_pmf ` K s) \\<subseteq> S", "by auto"], ["", "subsubsection \\<open>Intermezzo\\<close>"], ["", "(* XXX Correct binding strength *)"], ["", "abbreviation timed_bisim (infixr \"~\" 60) where\n  \"s ~ s' \\<equiv> abss s = abss s'\""], ["", "lemma bisim_loc_id[intro]:\n  \"(l, u) ~ (l', u') \\<Longrightarrow> l = l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l, u) ~ (l', u') \\<Longrightarrow> l = l'", "unfolding abss_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (l, u) of\n     (l, u) \\<Rightarrow>\n       if u \\<in> V then (l, [u]\\<^sub>\\<R>) else (l, - V)) =\n    (case (l', u') of\n     (l, u) \\<Rightarrow>\n       if u \\<in> V then (l, [u]\\<^sub>\\<R>)\n       else (l, - V)) \\<Longrightarrow>\n    l = l'", "by (cases \"u \\<in> V\"; cases \"u' \\<in> V\"; simp)"], ["", "lemma bisim_val_id[intro]:\n  \"[u]\\<^sub>\\<R> = [u']\\<^sub>\\<R>\" if \"u \\<in> V\" \"(l, u) ~ (l', u')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [u]\\<^sub>\\<R> = [u']\\<^sub>\\<R>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [u]\\<^sub>\\<R> = [u']\\<^sub>\\<R>", "have \"(l', - V) \\<noteq> (l, [u]\\<^sub>\\<R>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l', - V) \\<noteq> (l, [u]\\<^sub>\\<R>)", "using that"], ["proof (prove)\nusing this:\n  u \\<in> V\n  (l, u) ~ (l', u')\n\ngoal (1 subgoal):\n 1. (l', - V) \\<noteq> (l, [u]\\<^sub>\\<R>)", "by blast"], ["proof (state)\nthis:\n  (l', - V) \\<noteq> (l, [u]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. [u]\\<^sub>\\<R> = [u']\\<^sub>\\<R>", "with that"], ["proof (chain)\npicking this:\n  u \\<in> V\n  (l, u) ~ (l', u')\n  (l', - V) \\<noteq> (l, [u]\\<^sub>\\<R>)", "have \"u' \\<in> V\""], ["proof (prove)\nusing this:\n  u \\<in> V\n  (l, u) ~ (l', u')\n  (l', - V) \\<noteq> (l, [u]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. u' \\<in> V", "by (force simp: abss_def)"], ["proof (state)\nthis:\n  u' \\<in> V\n\ngoal (1 subgoal):\n 1. [u]\\<^sub>\\<R> = [u']\\<^sub>\\<R>", "with that"], ["proof (chain)\npicking this:\n  u \\<in> V\n  (l, u) ~ (l', u')\n  u' \\<in> V", "show ?thesis"], ["proof (prove)\nusing this:\n  u \\<in> V\n  (l, u) ~ (l', u')\n  u' \\<in> V\n\ngoal (1 subgoal):\n 1. [u]\\<^sub>\\<R> = [u']\\<^sub>\\<R>", "by (simp add: abss_def)"], ["proof (state)\nthis:\n  [u]\\<^sub>\\<R> = [u']\\<^sub>\\<R>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bisim_symmetric:\n  \"(l, u) ~ (l', u') = (l', u') ~ (l, u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l, u) ~ (l', u') = (l', u') ~ (l, u)", "by (rule eq_commute)"], ["", "lemma bisim_val_id2[intro]:\n  \"u' \\<in> V \\<Longrightarrow> (l, u) ~ (l', u') \\<Longrightarrow> [u]\\<^sub>\\<R> = [u']\\<^sub>\\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u' \\<in> V; (l, u) ~ (l', u')\\<rbrakk>\n    \\<Longrightarrow> [u]\\<^sub>\\<R> = [u']\\<^sub>\\<R>", "apply (subst (asm) eq_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u' \\<in> V; (l', u') ~ (l, u)\\<rbrakk>\n    \\<Longrightarrow> [u]\\<^sub>\\<R> = [u']\\<^sub>\\<R>", "apply (subst eq_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u' \\<in> V; (l', u') ~ (l, u)\\<rbrakk>\n    \\<Longrightarrow> [u']\\<^sub>\\<R> = [u]\\<^sub>\\<R>", "apply (rule bisim_val_id)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>u' \\<in> V; (l', u') ~ (l, u)\\<rbrakk>\n    \\<Longrightarrow> u' \\<in> V\n 2. \\<lbrakk>u' \\<in> V; (l', u') ~ (l, u)\\<rbrakk>\n    \\<Longrightarrow> (?l1, u') ~ (?l'1, u)", "by auto"], ["", "lemma K_bisim_unique:\n  assumes \"s \\<in> S\" \"\\<mu> \\<in> K s\" \"x \\<in> \\<mu>\" \"x' \\<in> \\<mu>\" \"x ~ x'\"\n  shows \"x = x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = x'", "using assms(2,1,3-)"], ["proof (prove)\nusing this:\n  \\<mu> \\<in> K s\n  s \\<in> S\n  x \\<in> set_pmf \\<mu>\n  x' \\<in> set_pmf \\<mu>\n  x ~ x'\n\ngoal (1 subgoal):\n 1. x = x'", "proof (cases rule: K.cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>l u t.\n       \\<lbrakk>s \\<in> S; x \\<in> set_pmf \\<mu>; x' \\<in> set_pmf \\<mu>;\n        x ~ x'; \\<mu> = return_pmf (l, u \\<oplus> t); s \\<in> S; s = (l, u);\n        0 \\<le> t; u \\<oplus> t \\<turnstile> PTA.inv_of A l\\<rbrakk>\n       \\<Longrightarrow> x = x'\n 2. \\<And>l u g \\<mu>'.\n       \\<lbrakk>s \\<in> S; x \\<in> set_pmf \\<mu>; x' \\<in> set_pmf \\<mu>;\n        x ~ x';\n        \\<mu> =\n        map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n         \\<mu>';\n        s \\<in> S; s = (l, u); (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        u \\<turnstile> g\\<rbrakk>\n       \\<Longrightarrow> x = x'\n 3. \\<lbrakk>s \\<in> S; x \\<in> set_pmf \\<mu>; x' \\<in> set_pmf \\<mu>;\n     x ~ x'; \\<mu> = return_pmf s\\<rbrakk>\n    \\<Longrightarrow> x = x'", "case prems: (action l u \\<tau> \\<mu>')"], ["proof (state)\nthis:\n  \\<mu> =\n  map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n   \\<mu>'\n  s \\<in> S\n  s = (l, u)\n  (l, \\<tau>, \\<mu>') \\<in> PTA.trans_of A\n  u \\<turnstile> \\<tau>\n\ngoal (3 subgoals):\n 1. \\<And>l u t.\n       \\<lbrakk>s \\<in> S; x \\<in> set_pmf \\<mu>; x' \\<in> set_pmf \\<mu>;\n        x ~ x'; \\<mu> = return_pmf (l, u \\<oplus> t); s \\<in> S; s = (l, u);\n        0 \\<le> t; u \\<oplus> t \\<turnstile> PTA.inv_of A l\\<rbrakk>\n       \\<Longrightarrow> x = x'\n 2. \\<And>l u g \\<mu>'.\n       \\<lbrakk>s \\<in> S; x \\<in> set_pmf \\<mu>; x' \\<in> set_pmf \\<mu>;\n        x ~ x';\n        \\<mu> =\n        map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n         \\<mu>';\n        s \\<in> S; s = (l, u); (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        u \\<turnstile> g\\<rbrakk>\n       \\<Longrightarrow> x = x'\n 3. \\<lbrakk>s \\<in> S; x \\<in> set_pmf \\<mu>; x' \\<in> set_pmf \\<mu>;\n     x ~ x'; \\<mu> = return_pmf s\\<rbrakk>\n    \\<Longrightarrow> x = x'", "with assms"], ["proof (chain)\npicking this:\n  s \\<in> S\n  \\<mu> \\<in> K s\n  x \\<in> set_pmf \\<mu>\n  x' \\<in> set_pmf \\<mu>\n  x ~ x'\n  \\<mu> =\n  map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n   \\<mu>'\n  s \\<in> S\n  s = (l, u)\n  (l, \\<tau>, \\<mu>') \\<in> PTA.trans_of A\n  u \\<turnstile> \\<tau>", "obtain l1 l2 X1 X2 where A:\n    \"(X1, l1) \\<in> set_pmf \\<mu>'\" \"(X2, l2) \\<in> set_pmf \\<mu>'\"\n    \"x = (l1, [X1:=0]u)\" \"x' = (l2, [X2:=0]u)\""], ["proof (prove)\nusing this:\n  s \\<in> S\n  \\<mu> \\<in> K s\n  x \\<in> set_pmf \\<mu>\n  x' \\<in> set_pmf \\<mu>\n  x ~ x'\n  \\<mu> =\n  map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n   \\<mu>'\n  s \\<in> S\n  s = (l, u)\n  (l, \\<tau>, \\<mu>') \\<in> PTA.trans_of A\n  u \\<turnstile> \\<tau>\n\ngoal (1 subgoal):\n 1. (\\<And>X1 l1 X2 l2.\n        \\<lbrakk>(X1, l1) \\<in> set_pmf \\<mu>';\n         (X2, l2) \\<in> set_pmf \\<mu>';\n         x = (l1, [(SOME r. set r = X1)\\<rightarrow>0]u);\n         x' = (l2, [(SOME r. set r = X2)\\<rightarrow>0]u)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (X1, l1) \\<in> set_pmf \\<mu>'\n  (X2, l2) \\<in> set_pmf \\<mu>'\n  x = (l1, [(SOME r. set r = X1)\\<rightarrow>0]u)\n  x' = (l2, [(SOME r. set r = X2)\\<rightarrow>0]u)\n\ngoal (3 subgoals):\n 1. \\<And>l u t.\n       \\<lbrakk>s \\<in> S; x \\<in> set_pmf \\<mu>; x' \\<in> set_pmf \\<mu>;\n        x ~ x'; \\<mu> = return_pmf (l, u \\<oplus> t); s \\<in> S; s = (l, u);\n        0 \\<le> t; u \\<oplus> t \\<turnstile> PTA.inv_of A l\\<rbrakk>\n       \\<Longrightarrow> x = x'\n 2. \\<And>l u g \\<mu>'.\n       \\<lbrakk>s \\<in> S; x \\<in> set_pmf \\<mu>; x' \\<in> set_pmf \\<mu>;\n        x ~ x';\n        \\<mu> =\n        map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n         \\<mu>';\n        s \\<in> S; s = (l, u); (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        u \\<turnstile> g\\<rbrakk>\n       \\<Longrightarrow> x = x'\n 3. \\<lbrakk>s \\<in> S; x \\<in> set_pmf \\<mu>; x' \\<in> set_pmf \\<mu>;\n     x ~ x'; \\<mu> = return_pmf s\\<rbrakk>\n    \\<Longrightarrow> x = x'", "from \\<open>x ~ x'\\<close> A \\<open>s \\<in> S\\<close> \\<open>s = (l, u)\\<close>"], ["proof (chain)\npicking this:\n  x ~ x'\n  (X1, l1) \\<in> set_pmf \\<mu>'\n  (X2, l2) \\<in> set_pmf \\<mu>'\n  x = (l1, [(SOME r. set r = X1)\\<rightarrow>0]u)\n  x' = (l2, [(SOME r. set r = X2)\\<rightarrow>0]u)\n  s \\<in> S\n  s = (l, u)", "have \"[[X1:=0]u]\\<^sub>\\<R> = [[X2:=0]u]\\<^sub>\\<R>\""], ["proof (prove)\nusing this:\n  x ~ x'\n  (X1, l1) \\<in> set_pmf \\<mu>'\n  (X2, l2) \\<in> set_pmf \\<mu>'\n  x = (l1, [(SOME r. set r = X1)\\<rightarrow>0]u)\n  x' = (l2, [(SOME r. set r = X2)\\<rightarrow>0]u)\n  s \\<in> S\n  s = (l, u)\n\ngoal (1 subgoal):\n 1. [[(SOME r. set r = X1)\\<rightarrow>0]u]\\<^sub>\\<R> =\n    [[(SOME r. set r = X2)\\<rightarrow>0]u]\\<^sub>\\<R>", "using bisim_val_id[OF S_V] K_S_closed assms(2-4)"], ["proof (prove)\nusing this:\n  x ~ x'\n  (X1, l1) \\<in> set_pmf \\<mu>'\n  (X2, l2) \\<in> set_pmf \\<mu>'\n  x = (l1, [(SOME r. set r = X1)\\<rightarrow>0]u)\n  x' = (l2, [(SOME r. set r = X2)\\<rightarrow>0]u)\n  s \\<in> S\n  s = (l, u)\n  \\<lbrakk>(?l1, ?u) \\<in> S; (?l, ?u) ~ (?l', ?u')\\<rbrakk>\n  \\<Longrightarrow> [?u]\\<^sub>\\<R> = [?u']\\<^sub>\\<R>\n  \\<lbrakk>?\\<mu> \\<in> K ?s; ?s' \\<in> set_pmf ?\\<mu>; ?s \\<in> S\\<rbrakk>\n  \\<Longrightarrow> ?s' \\<in> S\n  \\<mu> \\<in> K s\n  x \\<in> set_pmf \\<mu>\n  x' \\<in> set_pmf \\<mu>\n\ngoal (1 subgoal):\n 1. [[(SOME r. set r = X1)\\<rightarrow>0]u]\\<^sub>\\<R> =\n    [[(SOME r. set r = X2)\\<rightarrow>0]u]\\<^sub>\\<R>", "by (auto intro!: bisim_val_id[OF S_V])"], ["proof (state)\nthis:\n  [[(SOME r. set r = X1)\\<rightarrow>0]u]\\<^sub>\\<R> =\n  [[(SOME r. set r = X2)\\<rightarrow>0]u]\\<^sub>\\<R>\n\ngoal (3 subgoals):\n 1. \\<And>l u t.\n       \\<lbrakk>s \\<in> S; x \\<in> set_pmf \\<mu>; x' \\<in> set_pmf \\<mu>;\n        x ~ x'; \\<mu> = return_pmf (l, u \\<oplus> t); s \\<in> S; s = (l, u);\n        0 \\<le> t; u \\<oplus> t \\<turnstile> PTA.inv_of A l\\<rbrakk>\n       \\<Longrightarrow> x = x'\n 2. \\<And>l u g \\<mu>'.\n       \\<lbrakk>s \\<in> S; x \\<in> set_pmf \\<mu>; x' \\<in> set_pmf \\<mu>;\n        x ~ x';\n        \\<mu> =\n        map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n         \\<mu>';\n        s \\<in> S; s = (l, u); (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        u \\<turnstile> g\\<rbrakk>\n       \\<Longrightarrow> x = x'\n 3. \\<lbrakk>s \\<in> S; x \\<in> set_pmf \\<mu>; x' \\<in> set_pmf \\<mu>;\n     x ~ x'; \\<mu> = return_pmf s\\<rbrakk>\n    \\<Longrightarrow> x = x'", "then"], ["proof (chain)\npicking this:\n  [[(SOME r. set r = X1)\\<rightarrow>0]u]\\<^sub>\\<R> =\n  [[(SOME r. set r = X2)\\<rightarrow>0]u]\\<^sub>\\<R>", "have \"[X1:=0]u = [X2:=0]u\""], ["proof (prove)\nusing this:\n  [[(SOME r. set r = X1)\\<rightarrow>0]u]\\<^sub>\\<R> =\n  [[(SOME r. set r = X2)\\<rightarrow>0]u]\\<^sub>\\<R>\n\ngoal (1 subgoal):\n 1. [(SOME r. set r = X1)\\<rightarrow>0]u =\n    [(SOME r. set r = X2)\\<rightarrow>0]u", "using A admissible_targets_clocks(2)[OF prems(4)] prems(2,3)"], ["proof (prove)\nusing this:\n  [[(SOME r. set r = X1)\\<rightarrow>0]u]\\<^sub>\\<R> =\n  [[(SOME r. set r = X2)\\<rightarrow>0]u]\\<^sub>\\<R>\n  (X1, l1) \\<in> set_pmf \\<mu>'\n  (X2, l2) \\<in> set_pmf \\<mu>'\n  x = (l1, [(SOME r. set r = X1)\\<rightarrow>0]u)\n  x' = (l2, [(SOME r. set r = X2)\\<rightarrow>0]u)\n  (?X, ?l') \\<in> set_pmf \\<mu>' \\<Longrightarrow>\n  set (SOME r. set r = ?X) \\<subseteq> \\<X>\n  s \\<in> S\n  s = (l, u)\n\ngoal (1 subgoal):\n 1. [(SOME r. set r = X1)\\<rightarrow>0]u =\n    [(SOME r. set r = X2)\\<rightarrow>0]u", "by - (rule reset_eq, force)"], ["proof (state)\nthis:\n  [(SOME r. set r = X1)\\<rightarrow>0]u =\n  [(SOME r. set r = X2)\\<rightarrow>0]u\n\ngoal (3 subgoals):\n 1. \\<And>l u t.\n       \\<lbrakk>s \\<in> S; x \\<in> set_pmf \\<mu>; x' \\<in> set_pmf \\<mu>;\n        x ~ x'; \\<mu> = return_pmf (l, u \\<oplus> t); s \\<in> S; s = (l, u);\n        0 \\<le> t; u \\<oplus> t \\<turnstile> PTA.inv_of A l\\<rbrakk>\n       \\<Longrightarrow> x = x'\n 2. \\<And>l u g \\<mu>'.\n       \\<lbrakk>s \\<in> S; x \\<in> set_pmf \\<mu>; x' \\<in> set_pmf \\<mu>;\n        x ~ x';\n        \\<mu> =\n        map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n         \\<mu>';\n        s \\<in> S; s = (l, u); (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        u \\<turnstile> g\\<rbrakk>\n       \\<Longrightarrow> x = x'\n 3. \\<lbrakk>s \\<in> S; x \\<in> set_pmf \\<mu>; x' \\<in> set_pmf \\<mu>;\n     x ~ x'; \\<mu> = return_pmf s\\<rbrakk>\n    \\<Longrightarrow> x = x'", "with A \\<open>x ~ x'\\<close>"], ["proof (chain)\npicking this:\n  (X1, l1) \\<in> set_pmf \\<mu>'\n  (X2, l2) \\<in> set_pmf \\<mu>'\n  x = (l1, [(SOME r. set r = X1)\\<rightarrow>0]u)\n  x' = (l2, [(SOME r. set r = X2)\\<rightarrow>0]u)\n  x ~ x'\n  [(SOME r. set r = X1)\\<rightarrow>0]u =\n  [(SOME r. set r = X2)\\<rightarrow>0]u", "show ?thesis"], ["proof (prove)\nusing this:\n  (X1, l1) \\<in> set_pmf \\<mu>'\n  (X2, l2) \\<in> set_pmf \\<mu>'\n  x = (l1, [(SOME r. set r = X1)\\<rightarrow>0]u)\n  x' = (l2, [(SOME r. set r = X2)\\<rightarrow>0]u)\n  x ~ x'\n  [(SOME r. set r = X1)\\<rightarrow>0]u =\n  [(SOME r. set r = X2)\\<rightarrow>0]u\n\ngoal (1 subgoal):\n 1. x = x'", "by auto"], ["proof (state)\nthis:\n  x = x'\n\ngoal (2 subgoals):\n 1. \\<And>l u t.\n       \\<lbrakk>s \\<in> S; x \\<in> set_pmf \\<mu>; x' \\<in> set_pmf \\<mu>;\n        x ~ x'; \\<mu> = return_pmf (l, u \\<oplus> t); s \\<in> S; s = (l, u);\n        0 \\<le> t; u \\<oplus> t \\<turnstile> PTA.inv_of A l\\<rbrakk>\n       \\<Longrightarrow> x = x'\n 2. \\<lbrakk>s \\<in> S; x \\<in> set_pmf \\<mu>; x' \\<in> set_pmf \\<mu>;\n     x ~ x'; \\<mu> = return_pmf s\\<rbrakk>\n    \\<Longrightarrow> x = x'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l u t.\n       \\<lbrakk>s \\<in> S; x \\<in> set_pmf \\<mu>; x' \\<in> set_pmf \\<mu>;\n        x ~ x'; \\<mu> = return_pmf (l, u \\<oplus> t); s \\<in> S; s = (l, u);\n        0 \\<le> t; u \\<oplus> t \\<turnstile> PTA.inv_of A l\\<rbrakk>\n       \\<Longrightarrow> x = x'\n 2. \\<lbrakk>s \\<in> S; x \\<in> set_pmf \\<mu>; x' \\<in> set_pmf \\<mu>;\n     x ~ x'; \\<mu> = return_pmf s\\<rbrakk>\n    \\<Longrightarrow> x = x'", "case delay"], ["proof (state)\nthis:\n  \\<mu> = return_pmf (l_, u_ \\<oplus> t_)\n  s \\<in> S\n  s = (l_, u_)\n  0 \\<le> t_\n  u_ \\<oplus> t_ \\<turnstile> PTA.inv_of A l_\n\ngoal (2 subgoals):\n 1. \\<And>l u t.\n       \\<lbrakk>s \\<in> S; x \\<in> set_pmf \\<mu>; x' \\<in> set_pmf \\<mu>;\n        x ~ x'; \\<mu> = return_pmf (l, u \\<oplus> t); s \\<in> S; s = (l, u);\n        0 \\<le> t; u \\<oplus> t \\<turnstile> PTA.inv_of A l\\<rbrakk>\n       \\<Longrightarrow> x = x'\n 2. \\<lbrakk>s \\<in> S; x \\<in> set_pmf \\<mu>; x' \\<in> set_pmf \\<mu>;\n     x ~ x'; \\<mu> = return_pmf s\\<rbrakk>\n    \\<Longrightarrow> x = x'", "with assms(3-)"], ["proof (chain)\npicking this:\n  x \\<in> set_pmf \\<mu>\n  x' \\<in> set_pmf \\<mu>\n  x ~ x'\n  \\<mu> = return_pmf (l_, u_ \\<oplus> t_)\n  s \\<in> S\n  s = (l_, u_)\n  0 \\<le> t_\n  u_ \\<oplus> t_ \\<turnstile> PTA.inv_of A l_", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> set_pmf \\<mu>\n  x' \\<in> set_pmf \\<mu>\n  x ~ x'\n  \\<mu> = return_pmf (l_, u_ \\<oplus> t_)\n  s \\<in> S\n  s = (l_, u_)\n  0 \\<le> t_\n  u_ \\<oplus> t_ \\<turnstile> PTA.inv_of A l_\n\ngoal (1 subgoal):\n 1. x = x'", "by auto"], ["proof (state)\nthis:\n  x = x'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> S; x \\<in> set_pmf \\<mu>; x' \\<in> set_pmf \\<mu>;\n     x ~ x'; \\<mu> = return_pmf s\\<rbrakk>\n    \\<Longrightarrow> x = x'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> S; x \\<in> set_pmf \\<mu>; x' \\<in> set_pmf \\<mu>;\n     x ~ x'; \\<mu> = return_pmf s\\<rbrakk>\n    \\<Longrightarrow> x = x'", "case loop"], ["proof (state)\nthis:\n  \\<mu> = return_pmf s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> S; x \\<in> set_pmf \\<mu>; x' \\<in> set_pmf \\<mu>;\n     x ~ x'; \\<mu> = return_pmf s\\<rbrakk>\n    \\<Longrightarrow> x = x'", "with assms(3-)"], ["proof (chain)\npicking this:\n  x \\<in> set_pmf \\<mu>\n  x' \\<in> set_pmf \\<mu>\n  x ~ x'\n  \\<mu> = return_pmf s", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> set_pmf \\<mu>\n  x' \\<in> set_pmf \\<mu>\n  x ~ x'\n  \\<mu> = return_pmf s\n\ngoal (1 subgoal):\n 1. x = x'", "by auto"], ["proof (state)\nthis:\n  x = x'\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Predicates\\<close>"], ["", "definition absp where\n  \"absp \\<phi> \\<equiv> \\<phi> o reps\""], ["", "definition repp where\n  \"repp \\<phi> \\<equiv> \\<phi> o absp\""], ["", "subsubsection \\<open>Distributions\\<close>"], ["", "definition\n  abst :: \"('s * ('c, t) cval) pmf \\<Rightarrow> ('s * ('c, t) cval set) pmf\"\nwhere\n  \"abst = map_pmf abss\""], ["", "lemma abss_\\<S>D:\n  assumes \"abss s \\<in> \\<S>\"\n  obtains l u where \"s = (l, u)\" \"u \\<in> [u]\\<^sub>\\<R>\" \"[u]\\<^sub>\\<R> \\<in> \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l u.\n        \\<lbrakk>s = (l, u); u \\<in> [u]\\<^sub>\\<R>;\n         [u]\\<^sub>\\<R> \\<in> \\<R>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>l u.\n        \\<lbrakk>s = (l, u); u \\<in> [u]\\<^sub>\\<R>;\n         [u]\\<^sub>\\<R> \\<in> \\<R>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain l u where \"s = (l, u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l u. s = (l, u) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  s = (l, u)\n\ngoal (1 subgoal):\n 1. (\\<And>l u.\n        \\<lbrakk>s = (l, u); u \\<in> [u]\\<^sub>\\<R>;\n         [u]\\<^sub>\\<R> \\<in> \\<R>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  s = (l, u)\n\ngoal (1 subgoal):\n 1. (\\<And>l u.\n        \\<lbrakk>s = (l, u); u \\<in> [u]\\<^sub>\\<R>;\n         [u]\\<^sub>\\<R> \\<in> \\<R>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<S>_abss_S[OF assms]"], ["proof (chain)\npicking this:\n  s \\<in> S", "have \"s \\<in> S\""], ["proof (prove)\nusing this:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. s \\<in> S", "."], ["proof (state)\nthis:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<And>l u.\n        \\<lbrakk>s = (l, u); u \\<in> [u]\\<^sub>\\<R>;\n         [u]\\<^sub>\\<R> \\<in> \\<R>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  s = (l, u)\n  s \\<in> S", "have \"abss s = (l, [u]\\<^sub>\\<R>)\" \"u \\<in> V\" \"u \\<in> [u]\\<^sub>\\<R>\" \"[u]\\<^sub>\\<R> \\<in> \\<R>\""], ["proof (prove)\nusing this:\n  s = (l, u)\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. (abss s = (l, [u]\\<^sub>\\<R>) &&& u \\<in> V) &&&\n    u \\<in> [u]\\<^sub>\\<R> &&& [u]\\<^sub>\\<R> \\<in> \\<R>", "by auto"], ["proof (state)\nthis:\n  abss s = (l, [u]\\<^sub>\\<R>)\n  u \\<in> V\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. (\\<And>l u.\n        \\<lbrakk>s = (l, u); u \\<in> [u]\\<^sub>\\<R>;\n         [u]\\<^sub>\\<R> \\<in> \\<R>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with \\<open>s = _\\<close>"], ["proof (chain)\npicking this:\n  s = (l, u)\n  abss s = (l, [u]\\<^sub>\\<R>)\n  u \\<in> V\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>", "show ?thesis"], ["proof (prove)\nusing this:\n  s = (l, u)\n  abss s = (l, [u]\\<^sub>\\<R>)\n  u \\<in> V\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. thesis", "by (auto intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma abss_\\<S>D':\n  assumes \"abss s \\<in> \\<S>\" \"abss s = (l, R)\"\n  obtains u where \"s = (l, u)\" \"u \\<in> [u]\\<^sub>\\<R>\" \"[u]\\<^sub>\\<R> \\<in> \\<R>\" \"R = [u]\\<^sub>\\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>s = (l, u); u \\<in> [u]\\<^sub>\\<R>;\n         [u]\\<^sub>\\<R> \\<in> \\<R>; R = [u]\\<^sub>\\<R>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>s = (l, u); u \\<in> [u]\\<^sub>\\<R>;\n         [u]\\<^sub>\\<R> \\<in> \\<R>; R = [u]\\<^sub>\\<R>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from abss_\\<S>D[OF assms(1)]"], ["proof (chain)\npicking this:\n  (\\<And>l u.\n      \\<lbrakk>s = (l, u); u \\<in> [u]\\<^sub>\\<R>;\n       [u]\\<^sub>\\<R> \\<in> \\<R>\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain l' u where u:\n    \"s = (l', u)\" \"u \\<in> [u]\\<^sub>\\<R>\" \"[u]\\<^sub>\\<R> \\<in> \\<R>\""], ["proof (prove)\nusing this:\n  (\\<And>l u.\n      \\<lbrakk>s = (l, u); u \\<in> [u]\\<^sub>\\<R>;\n       [u]\\<^sub>\\<R> \\<in> \\<R>\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>l' u.\n        \\<lbrakk>s = (l', u); u \\<in> [u]\\<^sub>\\<R>;\n         [u]\\<^sub>\\<R> \\<in> \\<R>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast+"], ["proof (state)\nthis:\n  s = (l', u)\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>s = (l, u); u \\<in> [u]\\<^sub>\\<R>;\n         [u]\\<^sub>\\<R> \\<in> \\<R>; R = [u]\\<^sub>\\<R>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with \\<R>_V"], ["proof (chain)\npicking this:\n  \\<Union> \\<R> = V\n  s = (l', u)\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>", "have \"u \\<in> V\""], ["proof (prove)\nusing this:\n  \\<Union> \\<R> = V\n  s = (l', u)\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. u \\<in> V", "by auto"], ["proof (state)\nthis:\n  u \\<in> V\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>s = (l, u); u \\<in> [u]\\<^sub>\\<R>;\n         [u]\\<^sub>\\<R> \\<in> \\<R>; R = [u]\\<^sub>\\<R>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with \\<open>s = _\\<close> assms(2)"], ["proof (chain)\npicking this:\n  s = (l', u)\n  abss s = (l, R)\n  u \\<in> V", "have \"l' = l\" \"R = [u]\\<^sub>\\<R>\""], ["proof (prove)\nusing this:\n  s = (l', u)\n  abss s = (l, R)\n  u \\<in> V\n\ngoal (1 subgoal):\n 1. l' = l &&& R = [u]\\<^sub>\\<R>", "unfolding abss_def"], ["proof (prove)\nusing this:\n  s = (l', u)\n  (case s of\n   (l, u) \\<Rightarrow>\n     if u \\<in> V then (l, [u]\\<^sub>\\<R>) else (l, - V)) =\n  (l, R)\n  u \\<in> V\n\ngoal (1 subgoal):\n 1. l' = l &&& R = [u]\\<^sub>\\<R>", "by auto"], ["proof (state)\nthis:\n  l' = l\n  R = [u]\\<^sub>\\<R>\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>s = (l, u); u \\<in> [u]\\<^sub>\\<R>;\n         [u]\\<^sub>\\<R> \\<in> \\<R>; R = [u]\\<^sub>\\<R>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with u"], ["proof (chain)\npicking this:\n  s = (l', u)\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  l' = l\n  R = [u]\\<^sub>\\<R>", "show ?thesis"], ["proof (prove)\nusing this:\n  s = (l', u)\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  l' = l\n  R = [u]\\<^sub>\\<R>\n\ngoal (1 subgoal):\n 1. thesis", "by (auto intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "(*\ndefinition\n  rept :: \"'s * ('c, t) cval \\<Rightarrow> ('s * ('c, t) cval set) pmf \\<Rightarrow> ('s * ('c, t) cval) pmf\"\nwhere\n  \"rept s \\<mu>_abs \\<equiv> let (l, u) = s in\n    if \\<mu>_abs = return_pmf (abss s)\n    then if (\\<exists> c \\<in> \\<X>. \\<exists> d. u c = real d)\n         then return_pmf s\n         else return_pmf (l, u \\<oplus> 0.5)\n    else SOME \\<mu>. \\<mu> \\<in> K s \\<and> abst \\<mu> = \\<mu>_abs\"\n*)"], ["", "definition \"infR R \\<equiv> \\<lambda> c. of_int \\<lfloor>(SOME u. u \\<in> R) c\\<rfloor>\""], ["", "term \"let a = 3 in b\""], ["", "(* definition \"shiftedR R \\<equiv> let u = (SOME u. u \\<in> R) in (u \\<oplus> max 0 (0.1 - Max {frac (u c) | c. c \\<in> \\<X>}))\" *)\n(*\ndefinition \"delayedR R u \\<equiv>\n  u \\<oplus> (\n    let (I, r) = (SOME x. \\<exists> I r. x = (I, r) \\<and> valid_region \\<X> k I r \\<and> R = region \\<X> I r);\n        m = Min {of_nat (intv_const (I c)) + 1 - u c | c. c \\<in> \\<X> \\<and> isConst (I c)}\n    in if m \\<ge> 1 then SOME t. u \\<oplus> t \\<in> R else m / 2\n  )\"\n*)\n\n(*\ndefinition \"delayedR R u \\<equiv>\n  u \\<oplus> (\n    let (I, r) = (SOME x. \\<exists> I r. x = (I, r) \\<and> valid_region \\<X> k I r \\<and> R = region \\<X> I r);\n        m = 1 - Max ({frac (u c) | c. c \\<in> \\<X> \\<and> isIntv (I c) \\<and> intv_const (I c) = 0} \\<union> {0})\n    in if m \\<ge> 1 then SOME t. u \\<oplus> t \\<in> R else m / 2\n  )\"\n*)"], ["", "definition \"delayedR R u \\<equiv>\n  u \\<oplus> (\n    let I = (SOME I. \\<exists> r. valid_region \\<X> k I r \\<and> R = region \\<X> I r);\n        m = 1 - Max ({frac (u c) | c. c \\<in> \\<X> \\<and> isIntv (I c)} \\<union> {0})\n    in SOME t. u \\<oplus> t \\<in> R \\<and> t \\<ge> m / 2\n  )\""], ["", "(* XXX Move, generated by sledgehammer *)"], ["", "lemma delayedR_correct_aux_aux:\n  fixes c :: nat\n  fixes a b :: real\n  assumes \"c < a\" \"a < Suc c\" \"b \\<ge> 0\" \"a + b < Suc c\"\n  shows \"frac (a + b) = frac a + b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frac (a + b) = frac a + b", "(* Working alternative:\nby (smt One_nat_def add.right_neutral add_Suc_right assms nat_intv_frac_decomp)\n*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. frac (a + b) = frac a + b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. frac (a + b) = frac a + b", "have f1: \"a + b < real (c + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b < real (c + 1)", "using assms(4)"], ["proof (prove)\nusing this:\n  a + b < real (Suc c)\n\ngoal (1 subgoal):\n 1. a + b < real (c + 1)", "by auto"], ["proof (state)\nthis:\n  a + b < real (c + 1)\n\ngoal (1 subgoal):\n 1. frac (a + b) = frac a + b", "have f2: \"\\<And>r ra. (r::real) + (- r + ra) = ra\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r ra. r + (- r + ra) = ra", "by linarith"], ["proof (state)\nthis:\n  ?r5 + (- ?r5 + ?ra5) = ?ra5\n\ngoal (1 subgoal):\n 1. frac (a + b) = frac a + b", "have f3: \"\\<And>r. (r::real) = - (- r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r. r = - (- r)", "by linarith"], ["proof (state)\nthis:\n  ?r5 = - (- ?r5)\n\ngoal (1 subgoal):\n 1. frac (a + b) = frac a + b", "have f4: \"\\<And>r ra. - (r::real) + (ra + r) = ra\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r ra. - r + (ra + r) = ra", "by linarith"], ["proof (state)\nthis:\n  - ?r5 + (?ra5 + ?r5) = ?ra5\n\ngoal (1 subgoal):\n 1. frac (a + b) = frac a + b", "then"], ["proof (chain)\npicking this:\n  - ?r5 + (?ra5 + ?r5) = ?ra5", "have f5: \"\\<And>r n. r + - frac r = real n \\<or> \\<not> r < real (n + 1) \\<or> \\<not> real n < r\""], ["proof (prove)\nusing this:\n  - ?r5 + (?ra5 + ?r5) = ?ra5\n\ngoal (1 subgoal):\n 1. \\<And>r n.\n       r + - frac r = real n \\<or>\n       \\<not> r < real (n + 1) \\<or> \\<not> real n < r", "using f2"], ["proof (prove)\nusing this:\n  - ?r5 + (?ra5 + ?r5) = ?ra5\n  ?r5 + (- ?r5 + ?ra5) = ?ra5\n\ngoal (1 subgoal):\n 1. \\<And>r n.\n       r + - frac r = real n \\<or>\n       \\<not> r < real (n + 1) \\<or> \\<not> real n < r", "by (metis nat_intv_frac_decomp)"], ["proof (state)\nthis:\n  ?r5 + - frac ?r5 = real ?n5 \\<or>\n  \\<not> ?r5 < real (?n5 + 1) \\<or> \\<not> real ?n5 < ?r5\n\ngoal (1 subgoal):\n 1. frac (a + b) = frac a + b", "then"], ["proof (chain)\npicking this:\n  ?r5 + - frac ?r5 = real ?n5 \\<or>\n  \\<not> ?r5 < real (?n5 + 1) \\<or> \\<not> real ?n5 < ?r5", "have \"frac a + real c = a\""], ["proof (prove)\nusing this:\n  ?r5 + - frac ?r5 = real ?n5 \\<or>\n  \\<not> ?r5 < real (?n5 + 1) \\<or> \\<not> real ?n5 < ?r5\n\ngoal (1 subgoal):\n 1. frac a + real c = a", "using f4 f3"], ["proof (prove)\nusing this:\n  ?r5 + - frac ?r5 = real ?n5 \\<or>\n  \\<not> ?r5 < real (?n5 + 1) \\<or> \\<not> real ?n5 < ?r5\n  - ?r5 + (?ra5 + ?r5) = ?ra5\n  ?r5 = - (- ?r5)\n\ngoal (1 subgoal):\n 1. frac a + real c = a", "by (metis One_nat_def add.right_neutral add_Suc_right assms(1) assms(2))"], ["proof (state)\nthis:\n  frac a + real c = a\n\ngoal (1 subgoal):\n 1. frac (a + b) = frac a + b", "then"], ["proof (chain)\npicking this:\n  frac a + real c = a", "show ?thesis"], ["proof (prove)\nusing this:\n  frac a + real c = a\n\ngoal (1 subgoal):\n 1. frac (a + b) = frac a + b", "using f5 f1 assms(1) assms(3)"], ["proof (prove)\nusing this:\n  frac a + real c = a\n  ?r5 + - frac ?r5 = real ?n5 \\<or>\n  \\<not> ?r5 < real (?n5 + 1) \\<or> \\<not> real ?n5 < ?r5\n  a + b < real (c + 1)\n  real c < a\n  0 \\<le> b\n\ngoal (1 subgoal):\n 1. frac (a + b) = frac a + b", "by fastforce"], ["proof (state)\nthis:\n  frac (a + b) = frac a + b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma delayedR_correct_aux:\n  fixes I r\n  defines \"R \\<equiv> region \\<X> I r\"\n  assumes \"u \\<in> R\" \"valid_region \\<X> k I r\" \"\\<forall> c \\<in> \\<X>. \\<not> isConst (I c)\"\n          \"\\<forall> c \\<in> \\<X>. isIntv (I c) \\<longrightarrow> (u \\<oplus> t) c < intv_const (I c) + 1\"\n          \"t \\<ge> 0\"\n  shows \"u \\<oplus> t \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<oplus> t \\<in> R", "unfolding R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<oplus> t \\<in> Regions.region \\<X> I r", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<forall>x\\<in>\\<X>. 0 \\<le> (u \\<oplus> t) x\n 2. \\<forall>x\\<in>\\<X>. Regions.intv_elem x (u \\<oplus> t) (I x)\n 3. ?X\\<^sub>0 = {x \\<in> \\<X>. \\<exists>d. I x = Regions.intv.Intv d}\n 4. \\<forall>x\\<in>?X\\<^sub>0.\n       \\<forall>y\\<in>?X\\<^sub>0.\n          ((x, y) \\<in> r) =\n          (frac ((u \\<oplus> t) x) \\<le> frac ((u \\<oplus> t) y))", "from assms"], ["proof (chain)\npicking this:\n  R \\<equiv> Regions.region \\<X> I r\n  u \\<in> R\n  Regions.valid_region \\<X> k I r\n  \\<forall>c\\<in>\\<X>. \\<not> Regions.isConst (I c)\n  \\<forall>c\\<in>\\<X>.\n     Regions.isIntv (I c) \\<longrightarrow>\n     (u \\<oplus> t) c < real (intv_const (I c) + 1)\n  0 \\<le> t", "have \"R \\<in> \\<R>\""], ["proof (prove)\nusing this:\n  R \\<equiv> Regions.region \\<X> I r\n  u \\<in> R\n  Regions.valid_region \\<X> k I r\n  \\<forall>c\\<in>\\<X>. \\<not> Regions.isConst (I c)\n  \\<forall>c\\<in>\\<X>.\n     Regions.isIntv (I c) \\<longrightarrow>\n     (u \\<oplus> t) c < real (intv_const (I c) + 1)\n  0 \\<le> t\n\ngoal (1 subgoal):\n 1. R \\<in> \\<R>", "unfolding \\<R>_def"], ["proof (prove)\nusing this:\n  R \\<equiv> Regions.region \\<X> I r\n  u \\<in> R\n  Regions.valid_region \\<X> k I r\n  \\<forall>c\\<in>\\<X>. \\<not> Regions.isConst (I c)\n  \\<forall>c\\<in>\\<X>.\n     Regions.isIntv (I c) \\<longrightarrow>\n     (u \\<oplus> t) c < real (intv_const (I c) + 1)\n  0 \\<le> t\n\ngoal (1 subgoal):\n 1. R \\<in> {Regions.region \\<X> I r |I r. Regions.valid_region \\<X> k I r}", "by auto"], ["proof (state)\nthis:\n  R \\<in> \\<R>\n\ngoal (4 subgoals):\n 1. \\<forall>x\\<in>\\<X>. 0 \\<le> (u \\<oplus> t) x\n 2. \\<forall>x\\<in>\\<X>. Regions.intv_elem x (u \\<oplus> t) (I x)\n 3. ?X\\<^sub>0 = {x \\<in> \\<X>. \\<exists>d. I x = Regions.intv.Intv d}\n 4. \\<forall>x\\<in>?X\\<^sub>0.\n       \\<forall>y\\<in>?X\\<^sub>0.\n          ((x, y) \\<in> r) =\n          (frac ((u \\<oplus> t) x) \\<le> frac ((u \\<oplus> t) y))", "with \\<open>u \\<in> R\\<close> \\<R>_V"], ["proof (chain)\npicking this:\n  u \\<in> R\n  \\<Union> \\<R> = V\n  R \\<in> \\<R>", "have \"u \\<in> V\""], ["proof (prove)\nusing this:\n  u \\<in> R\n  \\<Union> \\<R> = V\n  R \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. u \\<in> V", "by auto"], ["proof (state)\nthis:\n  u \\<in> V\n\ngoal (4 subgoals):\n 1. \\<forall>x\\<in>\\<X>. 0 \\<le> (u \\<oplus> t) x\n 2. \\<forall>x\\<in>\\<X>. Regions.intv_elem x (u \\<oplus> t) (I x)\n 3. ?X\\<^sub>0 = {x \\<in> \\<X>. \\<exists>d. I x = Regions.intv.Intv d}\n 4. \\<forall>x\\<in>?X\\<^sub>0.\n       \\<forall>y\\<in>?X\\<^sub>0.\n          ((x, y) \\<in> r) =\n          (frac ((u \\<oplus> t) x) \\<le> frac ((u \\<oplus> t) y))", "with \\<open>t \\<ge> 0\\<close>"], ["proof (chain)\npicking this:\n  0 \\<le> t\n  u \\<in> V", "show \"\\<forall>x\\<in>\\<X>. 0 \\<le> (u \\<oplus> t) x\""], ["proof (prove)\nusing this:\n  0 \\<le> t\n  u \\<in> V\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>\\<X>. 0 \\<le> (u \\<oplus> t) x", "unfolding V_def"], ["proof (prove)\nusing this:\n  0 \\<le> t\n  u \\<in> {v. \\<forall>x\\<in>\\<X>. 0 \\<le> v x}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>\\<X>. 0 \\<le> (u \\<oplus> t) x", "by (auto simp: cval_add_def)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>\\<X>. 0 \\<le> (u \\<oplus> t) x\n\ngoal (3 subgoals):\n 1. \\<forall>x\\<in>\\<X>. Regions.intv_elem x (u \\<oplus> t) (I x)\n 2. ?X\\<^sub>0 = {x \\<in> \\<X>. \\<exists>d. I x = Regions.intv.Intv d}\n 3. \\<forall>x\\<in>?X\\<^sub>0.\n       \\<forall>y\\<in>?X\\<^sub>0.\n          ((x, y) \\<in> r) =\n          (frac ((u \\<oplus> t) x) \\<le> frac ((u \\<oplus> t) y))", "have \"intv_elem x (u \\<oplus> t) (I x)\" if \"x \\<in> \\<X>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. Regions.intv_elem x (u \\<oplus> t) (I x)", "proof (cases \"I x\")"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       I x = Regions.intv.Const x1 \\<Longrightarrow>\n       Regions.intv_elem x (u \\<oplus> t) (I x)\n 2. \\<And>x2.\n       I x = Regions.intv.Intv x2 \\<Longrightarrow>\n       Regions.intv_elem x (u \\<oplus> t) (I x)\n 3. \\<And>x3.\n       I x = Regions.intv.Greater x3 \\<Longrightarrow>\n       Regions.intv_elem x (u \\<oplus> t) (I x)", "case Const"], ["proof (state)\nthis:\n  I x = Regions.intv.Const x1_\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       I x = Regions.intv.Const x1 \\<Longrightarrow>\n       Regions.intv_elem x (u \\<oplus> t) (I x)\n 2. \\<And>x2.\n       I x = Regions.intv.Intv x2 \\<Longrightarrow>\n       Regions.intv_elem x (u \\<oplus> t) (I x)\n 3. \\<And>x3.\n       I x = Regions.intv.Greater x3 \\<Longrightarrow>\n       Regions.intv_elem x (u \\<oplus> t) (I x)", "with assms \\<open>x \\<in> \\<X>\\<close>"], ["proof (chain)\npicking this:\n  R \\<equiv> Regions.region \\<X> I r\n  u \\<in> R\n  Regions.valid_region \\<X> k I r\n  \\<forall>c\\<in>\\<X>. \\<not> Regions.isConst (I c)\n  \\<forall>c\\<in>\\<X>.\n     Regions.isIntv (I c) \\<longrightarrow>\n     (u \\<oplus> t) c < real (intv_const (I c) + 1)\n  0 \\<le> t\n  x \\<in> \\<X>\n  I x = Regions.intv.Const x1_", "show ?thesis"], ["proof (prove)\nusing this:\n  R \\<equiv> Regions.region \\<X> I r\n  u \\<in> R\n  Regions.valid_region \\<X> k I r\n  \\<forall>c\\<in>\\<X>. \\<not> Regions.isConst (I c)\n  \\<forall>c\\<in>\\<X>.\n     Regions.isIntv (I c) \\<longrightarrow>\n     (u \\<oplus> t) c < real (intv_const (I c) + 1)\n  0 \\<le> t\n  x \\<in> \\<X>\n  I x = Regions.intv.Const x1_\n\ngoal (1 subgoal):\n 1. Regions.intv_elem x (u \\<oplus> t) (I x)", "by auto"], ["proof (state)\nthis:\n  Regions.intv_elem x (u \\<oplus> t) (I x)\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       I x = Regions.intv.Intv x2 \\<Longrightarrow>\n       Regions.intv_elem x (u \\<oplus> t) (I x)\n 2. \\<And>x3.\n       I x = Regions.intv.Greater x3 \\<Longrightarrow>\n       Regions.intv_elem x (u \\<oplus> t) (I x)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       I x = Regions.intv.Intv x2 \\<Longrightarrow>\n       Regions.intv_elem x (u \\<oplus> t) (I x)\n 2. \\<And>x3.\n       I x = Regions.intv.Greater x3 \\<Longrightarrow>\n       Regions.intv_elem x (u \\<oplus> t) (I x)", "case (Intv c)"], ["proof (state)\nthis:\n  I x = Regions.intv.Intv c\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       I x = Regions.intv.Intv x2 \\<Longrightarrow>\n       Regions.intv_elem x (u \\<oplus> t) (I x)\n 2. \\<And>x3.\n       I x = Regions.intv.Greater x3 \\<Longrightarrow>\n       Regions.intv_elem x (u \\<oplus> t) (I x)", "with assms \\<open>x \\<in> \\<X>\\<close>"], ["proof (chain)\npicking this:\n  R \\<equiv> Regions.region \\<X> I r\n  u \\<in> R\n  Regions.valid_region \\<X> k I r\n  \\<forall>c\\<in>\\<X>. \\<not> Regions.isConst (I c)\n  \\<forall>c\\<in>\\<X>.\n     Regions.isIntv (I c) \\<longrightarrow>\n     (u \\<oplus> t) c < real (intv_const (I c) + 1)\n  0 \\<le> t\n  x \\<in> \\<X>\n  I x = Regions.intv.Intv c", "show ?thesis"], ["proof (prove)\nusing this:\n  R \\<equiv> Regions.region \\<X> I r\n  u \\<in> R\n  Regions.valid_region \\<X> k I r\n  \\<forall>c\\<in>\\<X>. \\<not> Regions.isConst (I c)\n  \\<forall>c\\<in>\\<X>.\n     Regions.isIntv (I c) \\<longrightarrow>\n     (u \\<oplus> t) c < real (intv_const (I c) + 1)\n  0 \\<le> t\n  x \\<in> \\<X>\n  I x = Regions.intv.Intv c\n\ngoal (1 subgoal):\n 1. Regions.intv_elem x (u \\<oplus> t) (I x)", "by (simp add: cval_add_def) (rule; force)"], ["proof (state)\nthis:\n  Regions.intv_elem x (u \\<oplus> t) (I x)\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       I x = Regions.intv.Greater x3 \\<Longrightarrow>\n       Regions.intv_elem x (u \\<oplus> t) (I x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x3.\n       I x = Regions.intv.Greater x3 \\<Longrightarrow>\n       Regions.intv_elem x (u \\<oplus> t) (I x)", "case (Greater c)"], ["proof (state)\nthis:\n  I x = Regions.intv.Greater c\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       I x = Regions.intv.Greater x3 \\<Longrightarrow>\n       Regions.intv_elem x (u \\<oplus> t) (I x)", "with assms \\<open>x \\<in> \\<X>\\<close>"], ["proof (chain)\npicking this:\n  R \\<equiv> Regions.region \\<X> I r\n  u \\<in> R\n  Regions.valid_region \\<X> k I r\n  \\<forall>c\\<in>\\<X>. \\<not> Regions.isConst (I c)\n  \\<forall>c\\<in>\\<X>.\n     Regions.isIntv (I c) \\<longrightarrow>\n     (u \\<oplus> t) c < real (intv_const (I c) + 1)\n  0 \\<le> t\n  x \\<in> \\<X>\n  I x = Regions.intv.Greater c", "show ?thesis"], ["proof (prove)\nusing this:\n  R \\<equiv> Regions.region \\<X> I r\n  u \\<in> R\n  Regions.valid_region \\<X> k I r\n  \\<forall>c\\<in>\\<X>. \\<not> Regions.isConst (I c)\n  \\<forall>c\\<in>\\<X>.\n     Regions.isIntv (I c) \\<longrightarrow>\n     (u \\<oplus> t) c < real (intv_const (I c) + 1)\n  0 \\<le> t\n  x \\<in> \\<X>\n  I x = Regions.intv.Greater c\n\ngoal (1 subgoal):\n 1. Regions.intv_elem x (u \\<oplus> t) (I x)", "by (fastforce simp add: cval_add_def)"], ["proof (state)\nthis:\n  Regions.intv_elem x (u \\<oplus> t) (I x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x5 \\<in> \\<X> \\<Longrightarrow>\n  Regions.intv_elem ?x5 (u \\<oplus> t) (I ?x5)\n\ngoal (3 subgoals):\n 1. \\<forall>x\\<in>\\<X>. Regions.intv_elem x (u \\<oplus> t) (I x)\n 2. ?X\\<^sub>0 = {x \\<in> \\<X>. \\<exists>d. I x = Regions.intv.Intv d}\n 3. \\<forall>x\\<in>?X\\<^sub>0.\n       \\<forall>y\\<in>?X\\<^sub>0.\n          ((x, y) \\<in> r) =\n          (frac ((u \\<oplus> t) x) \\<le> frac ((u \\<oplus> t) y))", "then"], ["proof (chain)\npicking this:\n  ?x5 \\<in> \\<X> \\<Longrightarrow>\n  Regions.intv_elem ?x5 (u \\<oplus> t) (I ?x5)", "show \"\\<forall>x\\<in>\\<X>. intv_elem x (u \\<oplus> t) (I x)\""], ["proof (prove)\nusing this:\n  ?x5 \\<in> \\<X> \\<Longrightarrow>\n  Regions.intv_elem ?x5 (u \\<oplus> t) (I ?x5)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>\\<X>. Regions.intv_elem x (u \\<oplus> t) (I x)", ".."], ["proof (state)\nthis:\n  \\<forall>x\\<in>\\<X>. Regions.intv_elem x (u \\<oplus> t) (I x)\n\ngoal (2 subgoals):\n 1. ?X\\<^sub>0 = {x \\<in> \\<X>. \\<exists>d. I x = Regions.intv.Intv d}\n 2. \\<forall>x\\<in>?X\\<^sub>0.\n       \\<forall>y\\<in>?X\\<^sub>0.\n          ((x, y) \\<in> r) =\n          (frac ((u \\<oplus> t) x) \\<le> frac ((u \\<oplus> t) y))", "let ?X\\<^sub>0 = \"{x \\<in> \\<X>. \\<exists>d. I x = Intv d}\""], ["proof (state)\ngoal (2 subgoals):\n 1. ?X\\<^sub>0 = {x \\<in> \\<X>. \\<exists>d. I x = Regions.intv.Intv d}\n 2. \\<forall>x\\<in>?X\\<^sub>0.\n       \\<forall>y\\<in>?X\\<^sub>0.\n          ((x, y) \\<in> r) =\n          (frac ((u \\<oplus> t) x) \\<le> frac ((u \\<oplus> t) y))", "show \"?X\\<^sub>0 = ?X\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> \\<X>. \\<exists>d. I x = Regions.intv.Intv d} =\n    {x \\<in> \\<X>. \\<exists>d. I x = Regions.intv.Intv d}", "by auto"], ["proof (state)\nthis:\n  {x \\<in> \\<X>. \\<exists>d. I x = Regions.intv.Intv d} =\n  {x \\<in> \\<X>. \\<exists>d. I x = Regions.intv.Intv d}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x \\<in> \\<X>. \\<exists>d. I x = Regions.intv.Intv d}.\n       \\<forall>y\\<in>{x \\<in> \\<X>. \\<exists>d. I x = Regions.intv.Intv d}.\n          ((x, y) \\<in> r) =\n          (frac ((u \\<oplus> t) x) \\<le> frac ((u \\<oplus> t) y))", "have \"frac (u x + t) = frac (u x) + t\" if \"x \\<in> ?X\\<^sub>0\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. frac (u x + t) = frac (u x) + t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. frac (u x + t) = frac (u x) + t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. frac (u x + t) = frac (u x) + t", "apply (rule delayedR_correct_aux_aux[where c = \"intv_const (I x)\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. real (intv_const (I x)) < u x\n 2. u x < real (Suc (intv_const (I x)))\n 3. 0 \\<le> t\n 4. u x + t < real (Suc (intv_const (I x)))", "using assms \\<open>x \\<in> ?X\\<^sub>0\\<close>"], ["proof (prove)\nusing this:\n  R \\<equiv> Regions.region \\<X> I r\n  u \\<in> R\n  Regions.valid_region \\<X> k I r\n  \\<forall>c\\<in>\\<X>. \\<not> Regions.isConst (I c)\n  \\<forall>c\\<in>\\<X>.\n     Regions.isIntv (I c) \\<longrightarrow>\n     (u \\<oplus> t) c < real (intv_const (I c) + 1)\n  0 \\<le> t\n  x \\<in> {x \\<in> \\<X>. \\<exists>d. I x = Regions.intv.Intv d}\n\ngoal (4 subgoals):\n 1. real (intv_const (I x)) < u x\n 2. u x < real (Suc (intv_const (I x)))\n 3. 0 \\<le> t\n 4. u x + t < real (Suc (intv_const (I x)))", "by (force simp add: cval_add_def)+"], ["proof (state)\nthis:\n  frac (u x + t) = frac (u x) + t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x5\n  \\<in> {x \\<in> \\<X>.\n         \\<exists>d. I x = Regions.intv.Intv d} \\<Longrightarrow>\n  frac (u ?x5 + t) = frac (u ?x5) + t\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x \\<in> \\<X>. \\<exists>d. I x = Regions.intv.Intv d}.\n       \\<forall>y\\<in>{x \\<in> \\<X>. \\<exists>d. I x = Regions.intv.Intv d}.\n          ((x, y) \\<in> r) =\n          (frac ((u \\<oplus> t) x) \\<le> frac ((u \\<oplus> t) y))", "then"], ["proof (chain)\npicking this:\n  ?x5\n  \\<in> {x \\<in> \\<X>.\n         \\<exists>d. I x = Regions.intv.Intv d} \\<Longrightarrow>\n  frac (u ?x5 + t) = frac (u ?x5) + t", "have \"frac (u x) \\<le> frac (u y) \\<longleftrightarrow> frac (u x + t) \\<le> frac (u y + t)\" if \"x \\<in> ?X\\<^sub>0\" \"y \\<in> ?X\\<^sub>0\" for x y"], ["proof (prove)\nusing this:\n  ?x5\n  \\<in> {x \\<in> \\<X>.\n         \\<exists>d. I x = Regions.intv.Intv d} \\<Longrightarrow>\n  frac (u ?x5 + t) = frac (u ?x5) + t\n\ngoal (1 subgoal):\n 1. (frac (u x) \\<le> frac (u y)) = (frac (u x + t) \\<le> frac (u y + t))", "using that"], ["proof (prove)\nusing this:\n  ?x5\n  \\<in> {x \\<in> \\<X>.\n         \\<exists>d. I x = Regions.intv.Intv d} \\<Longrightarrow>\n  frac (u ?x5 + t) = frac (u ?x5) + t\n  x \\<in> {x \\<in> \\<X>. \\<exists>d. I x = Regions.intv.Intv d}\n  y \\<in> {x \\<in> \\<X>. \\<exists>d. I x = Regions.intv.Intv d}\n\ngoal (1 subgoal):\n 1. (frac (u x) \\<le> frac (u y)) = (frac (u x + t) \\<le> frac (u y + t))", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?x5 \\<in> {x \\<in> \\<X>. \\<exists>d. I x = Regions.intv.Intv d};\n   ?y5 \\<in> {x \\<in> \\<X>. \\<exists>d. I x = Regions.intv.Intv d}\\<rbrakk>\n  \\<Longrightarrow> (frac (u ?x5) \\<le> frac (u ?y5)) =\n                    (frac (u ?x5 + t) \\<le> frac (u ?y5 + t))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x \\<in> \\<X>. \\<exists>d. I x = Regions.intv.Intv d}.\n       \\<forall>y\\<in>{x \\<in> \\<X>. \\<exists>d. I x = Regions.intv.Intv d}.\n          ((x, y) \\<in> r) =\n          (frac ((u \\<oplus> t) x) \\<le> frac ((u \\<oplus> t) y))", "with assms"], ["proof (chain)\npicking this:\n  R \\<equiv> Regions.region \\<X> I r\n  u \\<in> R\n  Regions.valid_region \\<X> k I r\n  \\<forall>c\\<in>\\<X>. \\<not> Regions.isConst (I c)\n  \\<forall>c\\<in>\\<X>.\n     Regions.isIntv (I c) \\<longrightarrow>\n     (u \\<oplus> t) c < real (intv_const (I c) + 1)\n  0 \\<le> t\n  \\<lbrakk>?x5 \\<in> {x \\<in> \\<X>. \\<exists>d. I x = Regions.intv.Intv d};\n   ?y5 \\<in> {x \\<in> \\<X>. \\<exists>d. I x = Regions.intv.Intv d}\\<rbrakk>\n  \\<Longrightarrow> (frac (u ?x5) \\<le> frac (u ?y5)) =\n                    (frac (u ?x5 + t) \\<le> frac (u ?y5 + t))", "show\n    \"\\<forall>x\\<in>?X\\<^sub>0. \\<forall>y\\<in>?X\\<^sub>0. ((x, y) \\<in> r) = (frac ((u \\<oplus> t) x) \\<le> frac ((u \\<oplus> t) y))\""], ["proof (prove)\nusing this:\n  R \\<equiv> Regions.region \\<X> I r\n  u \\<in> R\n  Regions.valid_region \\<X> k I r\n  \\<forall>c\\<in>\\<X>. \\<not> Regions.isConst (I c)\n  \\<forall>c\\<in>\\<X>.\n     Regions.isIntv (I c) \\<longrightarrow>\n     (u \\<oplus> t) c < real (intv_const (I c) + 1)\n  0 \\<le> t\n  \\<lbrakk>?x5 \\<in> {x \\<in> \\<X>. \\<exists>d. I x = Regions.intv.Intv d};\n   ?y5 \\<in> {x \\<in> \\<X>. \\<exists>d. I x = Regions.intv.Intv d}\\<rbrakk>\n  \\<Longrightarrow> (frac (u ?x5) \\<le> frac (u ?y5)) =\n                    (frac (u ?x5 + t) \\<le> frac (u ?y5 + t))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x \\<in> \\<X>. \\<exists>d. I x = Regions.intv.Intv d}.\n       \\<forall>y\\<in>{x \\<in> \\<X>. \\<exists>d. I x = Regions.intv.Intv d}.\n          ((x, y) \\<in> r) =\n          (frac ((u \\<oplus> t) x) \\<le> frac ((u \\<oplus> t) y))", "unfolding cval_add_def"], ["proof (prove)\nusing this:\n  R \\<equiv> Regions.region \\<X> I r\n  u \\<in> R\n  Regions.valid_region \\<X> k I r\n  \\<forall>c\\<in>\\<X>. \\<not> Regions.isConst (I c)\n  \\<forall>c\\<in>\\<X>.\n     Regions.isIntv (I c) \\<longrightarrow>\n     u c + t < real (intv_const (I c) + 1)\n  0 \\<le> t\n  \\<lbrakk>?x5 \\<in> {x \\<in> \\<X>. \\<exists>d. I x = Regions.intv.Intv d};\n   ?y5 \\<in> {x \\<in> \\<X>. \\<exists>d. I x = Regions.intv.Intv d}\\<rbrakk>\n  \\<Longrightarrow> (frac (u ?x5) \\<le> frac (u ?y5)) =\n                    (frac (u ?x5 + t) \\<le> frac (u ?y5 + t))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x \\<in> \\<X>. \\<exists>d. I x = Regions.intv.Intv d}.\n       \\<forall>y\\<in>{x \\<in> \\<X>. \\<exists>d. I x = Regions.intv.Intv d}.\n          ((x, y) \\<in> r) = (frac (u x + t) \\<le> frac (u y + t))", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{x \\<in> \\<X>. \\<exists>d. I x = Regions.intv.Intv d}.\n     \\<forall>y\\<in>{x \\<in> \\<X>. \\<exists>d. I x = Regions.intv.Intv d}.\n        ((x, y) \\<in> r) =\n        (frac ((u \\<oplus> t) x) \\<le> frac ((u \\<oplus> t) y))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma delayedR_correct_aux':\n  fixes I r\n  defines \"R \\<equiv> region \\<X> I r\"\n  assumes \"u \\<oplus> t1 \\<in> R\" \"valid_region \\<X> k I r\" \"\\<forall> c \\<in> \\<X>. \\<not> isConst (I c)\"\n          \"\\<forall> c \\<in> \\<X>. isIntv (I c) \\<longrightarrow> (u \\<oplus> t2) c < intv_const (I c) + 1\"\n          \"t1 \\<le> t2\"\n  shows \"u \\<oplus> t2 \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<oplus> t2 \\<in> R", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<oplus> t2 \\<in> R", "have \"(u \\<oplus> t1) \\<oplus> (t2 - t1) \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u \\<oplus> t1) \\<oplus> t2 - t1 \\<in> R", "unfolding R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (u \\<oplus> t1) \\<oplus> t2 - t1 \\<in> Regions.region \\<X> I r", "using assms"], ["proof (prove)\nusing this:\n  R \\<equiv> Regions.region \\<X> I r\n  u \\<oplus> t1 \\<in> R\n  Regions.valid_region \\<X> k I r\n  \\<forall>c\\<in>\\<X>. \\<not> Regions.isConst (I c)\n  \\<forall>c\\<in>\\<X>.\n     Regions.isIntv (I c) \\<longrightarrow>\n     (u \\<oplus> t2) c < real (intv_const (I c) + 1)\n  t1 \\<le> t2\n\ngoal (1 subgoal):\n 1. (u \\<oplus> t1) \\<oplus> t2 - t1 \\<in> Regions.region \\<X> I r", "by - (rule delayedR_correct_aux, auto simp: cval_add_def)"], ["proof (state)\nthis:\n  (u \\<oplus> t1) \\<oplus> t2 - t1 \\<in> R\n\ngoal (1 subgoal):\n 1. u \\<oplus> t2 \\<in> R", "then"], ["proof (chain)\npicking this:\n  (u \\<oplus> t1) \\<oplus> t2 - t1 \\<in> R", "show \"u \\<oplus> t2 \\<in> R\""], ["proof (prove)\nusing this:\n  (u \\<oplus> t1) \\<oplus> t2 - t1 \\<in> R\n\ngoal (1 subgoal):\n 1. u \\<oplus> t2 \\<in> R", "by (simp add: cval_add_def)"], ["proof (state)\nthis:\n  u \\<oplus> t2 \\<in> R\n\ngoal:\nNo subgoals!", "qed"], ["", "(* XXX Move to valid_regions_distinct *)"], ["", "lemma valid_regions_intv_distinct:\n  \"valid_region X k I r \\<Longrightarrow> valid_region X k I' r' \\<Longrightarrow> u \\<in> region X I r \\<Longrightarrow> u \\<in> region X I' r'\n  \\<Longrightarrow> x \\<in> X \\<Longrightarrow> I x = I' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Regions.valid_region X k I r; Regions.valid_region X k I' r';\n     u \\<in> Regions.region X I r; u \\<in> Regions.region X I' r';\n     x \\<in> X\\<rbrakk>\n    \\<Longrightarrow> I x = I' x", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Regions.valid_region X k I r; Regions.valid_region X k I' r';\n     u \\<in> Regions.region X I r; u \\<in> Regions.region X I' r';\n     x \\<in> X\\<rbrakk>\n    \\<Longrightarrow> I x = I' x", "case A: 1"], ["proof (state)\nthis:\n  Regions.valid_region X k I r\n  Regions.valid_region X k I' r'\n  u \\<in> Regions.region X I r\n  u \\<in> Regions.region X I' r'\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Regions.valid_region X k I r; Regions.valid_region X k I' r';\n     u \\<in> Regions.region X I r; u \\<in> Regions.region X I' r';\n     x \\<in> X\\<rbrakk>\n    \\<Longrightarrow> I x = I' x", "note x = \\<open>x \\<in> X\\<close>"], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Regions.valid_region X k I r; Regions.valid_region X k I' r';\n     u \\<in> Regions.region X I r; u \\<in> Regions.region X I' r';\n     x \\<in> X\\<rbrakk>\n    \\<Longrightarrow> I x = I' x", "with A"], ["proof (chain)\npicking this:\n  Regions.valid_region X k I r\n  Regions.valid_region X k I' r'\n  u \\<in> Regions.region X I r\n  u \\<in> Regions.region X I' r'\n  x \\<in> X\n  x \\<in> X", "have \"valid_intv (k x) (I x)\""], ["proof (prove)\nusing this:\n  Regions.valid_region X k I r\n  Regions.valid_region X k I' r'\n  u \\<in> Regions.region X I r\n  u \\<in> Regions.region X I' r'\n  x \\<in> X\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. Regions.valid_intv (k x) (I x)", "by auto"], ["proof (state)\nthis:\n  Regions.valid_intv (k x) (I x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Regions.valid_region X k I r; Regions.valid_region X k I' r';\n     u \\<in> Regions.region X I r; u \\<in> Regions.region X I' r';\n     x \\<in> X\\<rbrakk>\n    \\<Longrightarrow> I x = I' x", "moreover"], ["proof (state)\nthis:\n  Regions.valid_intv (k x) (I x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Regions.valid_region X k I r; Regions.valid_region X k I' r';\n     u \\<in> Regions.region X I r; u \\<in> Regions.region X I' r';\n     x \\<in> X\\<rbrakk>\n    \\<Longrightarrow> I x = I' x", "from A(2) x"], ["proof (chain)\npicking this:\n  Regions.valid_region X k I' r'\n  x \\<in> X", "have \"valid_intv (k x) (I' x)\""], ["proof (prove)\nusing this:\n  Regions.valid_region X k I' r'\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. Regions.valid_intv (k x) (I' x)", "by auto"], ["proof (state)\nthis:\n  Regions.valid_intv (k x) (I' x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Regions.valid_region X k I r; Regions.valid_region X k I' r';\n     u \\<in> Regions.region X I r; u \\<in> Regions.region X I' r';\n     x \\<in> X\\<rbrakk>\n    \\<Longrightarrow> I x = I' x", "moreover"], ["proof (state)\nthis:\n  Regions.valid_intv (k x) (I' x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Regions.valid_region X k I r; Regions.valid_region X k I' r';\n     u \\<in> Regions.region X I r; u \\<in> Regions.region X I' r';\n     x \\<in> X\\<rbrakk>\n    \\<Longrightarrow> I x = I' x", "from A(3) x"], ["proof (chain)\npicking this:\n  u \\<in> Regions.region X I r\n  x \\<in> X", "have \"intv_elem x u (I x)\""], ["proof (prove)\nusing this:\n  u \\<in> Regions.region X I r\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. Regions.intv_elem x u (I x)", "by auto"], ["proof (state)\nthis:\n  Regions.intv_elem x u (I x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Regions.valid_region X k I r; Regions.valid_region X k I' r';\n     u \\<in> Regions.region X I r; u \\<in> Regions.region X I' r';\n     x \\<in> X\\<rbrakk>\n    \\<Longrightarrow> I x = I' x", "moreover"], ["proof (state)\nthis:\n  Regions.intv_elem x u (I x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Regions.valid_region X k I r; Regions.valid_region X k I' r';\n     u \\<in> Regions.region X I r; u \\<in> Regions.region X I' r';\n     x \\<in> X\\<rbrakk>\n    \\<Longrightarrow> I x = I' x", "from A(4) x"], ["proof (chain)\npicking this:\n  u \\<in> Regions.region X I' r'\n  x \\<in> X", "have \"intv_elem x u (I' x)\""], ["proof (prove)\nusing this:\n  u \\<in> Regions.region X I' r'\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. Regions.intv_elem x u (I' x)", "by auto"], ["proof (state)\nthis:\n  Regions.intv_elem x u (I' x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Regions.valid_region X k I r; Regions.valid_region X k I' r';\n     u \\<in> Regions.region X I r; u \\<in> Regions.region X I' r';\n     x \\<in> X\\<rbrakk>\n    \\<Longrightarrow> I x = I' x", "ultimately"], ["proof (chain)\npicking this:\n  Regions.valid_intv (k x) (I x)\n  Regions.valid_intv (k x) (I' x)\n  Regions.intv_elem x u (I x)\n  Regions.intv_elem x u (I' x)", "show \"I x = I' x\""], ["proof (prove)\nusing this:\n  Regions.valid_intv (k x) (I x)\n  Regions.valid_intv (k x) (I' x)\n  Regions.intv_elem x u (I x)\n  Regions.intv_elem x u (I' x)\n\ngoal (1 subgoal):\n 1. I x = I' x", "using valid_intv_distinct"], ["proof (prove)\nusing this:\n  Regions.valid_intv (k x) (I x)\n  Regions.valid_intv (k x) (I' x)\n  Regions.intv_elem x u (I x)\n  Regions.intv_elem x u (I' x)\n  \\<lbrakk>Regions.valid_intv ?c ?I; Regions.valid_intv ?c ?I';\n   Regions.intv_elem ?x ?u ?I; Regions.intv_elem ?x ?u ?I'\\<rbrakk>\n  \\<Longrightarrow> ?I = ?I'\n\ngoal (1 subgoal):\n 1. I x = I' x", "by fastforce"], ["proof (state)\nthis:\n  I x = I' x\n\ngoal:\nNo subgoals!", "qed"], ["", "(* XXX Move *)"], ["", "lemma delayedR_correct:\n  fixes I r\n  defines \"R' \\<equiv> region \\<X> I r\"\n  assumes \"u \\<in> R\" \"R \\<in> \\<R>\" \"valid_region \\<X> k I r\" \"\\<forall> c \\<in> \\<X>. \\<not> isConst (I c)\" \"R' \\<in> Succ \\<R> R\"\n  shows\n    \"delayedR R' u \\<in> R'\"\n    \"\\<exists> t \\<ge> 0. delayedR R' u = u \\<oplus> t\n            \\<and> t \\<ge> (1 - Max ({frac (u c) | c. c \\<in> \\<X> \\<and> isIntv (I c)} \\<union> {0})) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delayedR R' u \\<in> R' &&&\n    \\<exists>t\\<ge>0.\n       delayedR R' u = u \\<oplus> t \\<and>\n       (1 -\n        Max ({frac (u c) |c.\n              c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n             {0})) /\n       2\n       \\<le> t", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. delayedR R' u \\<in> R'\n 2. \\<exists>t\\<ge>0.\n       delayedR R' u = u \\<oplus> t \\<and>\n       (1 -\n        Max ({frac (u c) |c.\n              c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n             {0})) /\n       2\n       \\<le> t", "let ?u = \"SOME u. u \\<in> R\""], ["proof (state)\ngoal (2 subgoals):\n 1. delayedR R' u \\<in> R'\n 2. \\<exists>t\\<ge>0.\n       delayedR R' u = u \\<oplus> t \\<and>\n       (1 -\n        Max ({frac (u c) |c.\n              c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n             {0})) /\n       2\n       \\<le> t", "let ?I = \"SOME I. \\<exists> r. valid_region \\<X> k I r \\<and> R' = region \\<X> I r\""], ["proof (state)\ngoal (2 subgoals):\n 1. delayedR R' u \\<in> R'\n 2. \\<exists>t\\<ge>0.\n       delayedR R' u = u \\<oplus> t \\<and>\n       (1 -\n        Max ({frac (u c) |c.\n              c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n             {0})) /\n       2\n       \\<le> t", "let ?S = \"{frac (u c) | c. c \\<in> \\<X> \\<and> isIntv (I c)}\""], ["proof (state)\ngoal (2 subgoals):\n 1. delayedR R' u \\<in> R'\n 2. \\<exists>t\\<ge>0.\n       delayedR R' u = u \\<oplus> t \\<and>\n       (1 -\n        Max ({frac (u c) |c.\n              c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n             {0})) /\n       2\n       \\<le> t", "let ?m = \"1 - Max (?S \\<union> {0})\""], ["proof (state)\ngoal (2 subgoals):\n 1. delayedR R' u \\<in> R'\n 2. \\<exists>t\\<ge>0.\n       delayedR R' u = u \\<oplus> t \\<and>\n       (1 -\n        Max ({frac (u c) |c.\n              c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n             {0})) /\n       2\n       \\<le> t", "let ?t = \"SOME t. u \\<oplus> t \\<in> R' \\<and> t \\<ge> ?m / 2\""], ["proof (state)\ngoal (2 subgoals):\n 1. delayedR R' u \\<in> R'\n 2. \\<exists>t\\<ge>0.\n       delayedR R' u = u \\<oplus> t \\<and>\n       (1 -\n        Max ({frac (u c) |c.\n              c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n             {0})) /\n       2\n       \\<le> t", "have \"Max (?S \\<union> {0}) \\<ge> 0\" \"?m \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> Max ({frac (u c) |c.\n                  c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                 {0}) &&&\n    1 -\n    Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n         {0})\n    \\<le> 1", "using finite(1)"], ["proof (prove)\nusing this:\n  finite \\<X>\n\ngoal (1 subgoal):\n 1. 0 \\<le> Max ({frac (u c) |c.\n                  c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                 {0}) &&&\n    1 -\n    Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n         {0})\n    \\<le> 1", "by auto"], ["proof (state)\nthis:\n  0 \\<le> Max ({frac (u c) |c.\n                c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n               {0})\n  1 -\n  Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n       {0})\n  \\<le> 1\n\ngoal (2 subgoals):\n 1. delayedR R' u \\<in> R'\n 2. \\<exists>t\\<ge>0.\n       delayedR R' u = u \\<oplus> t \\<and>\n       (1 -\n        Max ({frac (u c) |c.\n              c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n             {0})) /\n       2\n       \\<le> t", "have \"Max (?S \\<union> {0}) \\<in> ?S \\<union> {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n         {0})\n    \\<in> {frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n          {0}", "using finite(1)"], ["proof (prove)\nusing this:\n  finite \\<X>\n\ngoal (1 subgoal):\n 1. Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n         {0})\n    \\<in> {frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n          {0}", "by - (rule Max_in; auto)"], ["proof (state)\nthis:\n  Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n       {0})\n  \\<in> {frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n        {0}\n\ngoal (2 subgoals):\n 1. delayedR R' u \\<in> R'\n 2. \\<exists>t\\<ge>0.\n       delayedR R' u = u \\<oplus> t \\<and>\n       (1 -\n        Max ({frac (u c) |c.\n              c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n             {0})) /\n       2\n       \\<le> t", "with frac_lt_1"], ["proof (chain)\npicking this:\n  frac ?x < (1::?'a)\n  Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n       {0})\n  \\<in> {frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n        {0}", "have \"Max (?S \\<union> {0}) \\<le> 1\" \"?m \\<ge> 0\""], ["proof (prove)\nusing this:\n  frac ?x < (1::?'a)\n  Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n       {0})\n  \\<in> {frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n        {0}\n\ngoal (1 subgoal):\n 1. Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n         {0})\n    \\<le> 1 &&&\n    0 \\<le> 1 -\n            Max ({frac (u c) |c.\n                  c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                 {0})", "by auto"], ["proof (state)\nthis:\n  Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n       {0})\n  \\<le> 1\n  0 \\<le> 1 -\n          Max ({frac (u c) |c.\n                c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n               {0})\n\ngoal (2 subgoals):\n 1. delayedR R' u \\<in> R'\n 2. \\<exists>t\\<ge>0.\n       delayedR R' u = u \\<oplus> t \\<and>\n       (1 -\n        Max ({frac (u c) |c.\n              c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n             {0})) /\n       2\n       \\<le> t", "from assms(3, 6) \\<open>u \\<in> R\\<close>"], ["proof (chain)\npicking this:\n  R \\<in> \\<R>\n  R' \\<in> Succ \\<R> R\n  u \\<in> R", "obtain t where t:\n    \"u \\<oplus> t \\<in> R'\" \"t \\<ge> 0\""], ["proof (prove)\nusing this:\n  R \\<in> \\<R>\n  R' \\<in> Succ \\<R> R\n  u \\<in> R\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>u \\<oplus> t \\<in> R'; 0 \\<le> t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis alpha_interp.regions_closed'_spec alpha_interp.set_of_regions_spec)"], ["proof (state)\nthis:\n  u \\<oplus> t \\<in> R'\n  0 \\<le> t\n\ngoal (2 subgoals):\n 1. delayedR R' u \\<in> R'\n 2. \\<exists>t\\<ge>0.\n       delayedR R' u = u \\<oplus> t \\<and>\n       (1 -\n        Max ({frac (u c) |c.\n              c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n             {0})) /\n       2\n       \\<le> t", "have I_cong: \"\\<forall> c \\<in> \\<X>. I' c = I c\" if \"valid_region \\<X> k I' r'\" \"R' = region \\<X> I' r'\" for I' r'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>\\<X>. I' c = I c", "using valid_regions_intv_distinct assms(4) t(1) that"], ["proof (prove)\nusing this:\n  \\<lbrakk>Regions.valid_region ?X k ?I ?r;\n   Regions.valid_region ?X k ?I' ?r'; ?u \\<in> Regions.region ?X ?I ?r;\n   ?u \\<in> Regions.region ?X ?I' ?r'; ?x \\<in> ?X\\<rbrakk>\n  \\<Longrightarrow> ?I ?x = ?I' ?x\n  Regions.valid_region \\<X> k I r\n  u \\<oplus> t \\<in> R'\n  Regions.valid_region \\<X> k I' r'\n  R' = Regions.region \\<X> I' r'\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>\\<X>. I' c = I c", "unfolding R'_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>Regions.valid_region ?X k ?I ?r;\n   Regions.valid_region ?X k ?I' ?r'; ?u \\<in> Regions.region ?X ?I ?r;\n   ?u \\<in> Regions.region ?X ?I' ?r'; ?x \\<in> ?X\\<rbrakk>\n  \\<Longrightarrow> ?I ?x = ?I' ?x\n  Regions.valid_region \\<X> k I r\n  u \\<oplus> t \\<in> Regions.region \\<X> I r\n  Regions.valid_region \\<X> k I' r'\n  Regions.region \\<X> I r = Regions.region \\<X> I' r'\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>\\<X>. I' c = I c", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>Regions.valid_region \\<X> k ?I'5 ?r'5;\n   R' = Regions.region \\<X> ?I'5 ?r'5\\<rbrakk>\n  \\<Longrightarrow> \\<forall>c\\<in>\\<X>. ?I'5 c = I c\n\ngoal (2 subgoals):\n 1. delayedR R' u \\<in> R'\n 2. \\<exists>t\\<ge>0.\n       delayedR R' u = u \\<oplus> t \\<and>\n       (1 -\n        Max ({frac (u c) |c.\n              c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n             {0})) /\n       2\n       \\<le> t", "have I_cong: \"?I c = I c\" if \"c \\<in> \\<X>\" for c"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME I.\n        \\<exists>r.\n           Regions.valid_region \\<X> k I r \\<and>\n           R' = Regions.region \\<X> I r)\n     c =\n    I c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (SOME I.\n        \\<exists>r.\n           Regions.valid_region \\<X> k I r \\<and>\n           R' = Regions.region \\<X> I r)\n     c =\n    I c", "from assms"], ["proof (chain)\npicking this:\n  R' \\<equiv> Regions.region \\<X> I r\n  u \\<in> R\n  R \\<in> \\<R>\n  Regions.valid_region \\<X> k I r\n  \\<forall>c\\<in>\\<X>. \\<not> Regions.isConst (I c)\n  R' \\<in> Succ \\<R> R", "have\n      \"\\<exists> r. valid_region \\<X> k ?I r \\<and> R' = region \\<X> ?I r\""], ["proof (prove)\nusing this:\n  R' \\<equiv> Regions.region \\<X> I r\n  u \\<in> R\n  R \\<in> \\<R>\n  Regions.valid_region \\<X> k I r\n  \\<forall>c\\<in>\\<X>. \\<not> Regions.isConst (I c)\n  R' \\<in> Succ \\<R> R\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       Regions.valid_region \\<X> k\n        (SOME I.\n            \\<exists>r.\n               Regions.valid_region \\<X> k I r \\<and>\n               R' = Regions.region \\<X> I r)\n        r \\<and>\n       R' =\n       Regions.region \\<X>\n        (SOME I.\n            \\<exists>r.\n               Regions.valid_region \\<X> k I r \\<and>\n               R' = Regions.region \\<X> I r)\n        r", "by - (rule someI[where P = \"\\<lambda> I. \\<exists> r. valid_region \\<X> k I r \\<and> R' = region \\<X> I r\"]; auto)"], ["proof (state)\nthis:\n  \\<exists>r.\n     Regions.valid_region \\<X> k\n      (SOME I.\n          \\<exists>r.\n             Regions.valid_region \\<X> k I r \\<and>\n             R' = Regions.region \\<X> I r)\n      r \\<and>\n     R' =\n     Regions.region \\<X>\n      (SOME I.\n          \\<exists>r.\n             Regions.valid_region \\<X> k I r \\<and>\n             R' = Regions.region \\<X> I r)\n      r\n\ngoal (1 subgoal):\n 1. (SOME I.\n        \\<exists>r.\n           Regions.valid_region \\<X> k I r \\<and>\n           R' = Regions.region \\<X> I r)\n     c =\n    I c", "with I_cong that"], ["proof (chain)\npicking this:\n  \\<lbrakk>Regions.valid_region \\<X> k ?I'5 ?r'5;\n   R' = Regions.region \\<X> ?I'5 ?r'5\\<rbrakk>\n  \\<Longrightarrow> \\<forall>c\\<in>\\<X>. ?I'5 c = I c\n  c \\<in> \\<X>\n  \\<exists>r.\n     Regions.valid_region \\<X> k\n      (SOME I.\n          \\<exists>r.\n             Regions.valid_region \\<X> k I r \\<and>\n             R' = Regions.region \\<X> I r)\n      r \\<and>\n     R' =\n     Regions.region \\<X>\n      (SOME I.\n          \\<exists>r.\n             Regions.valid_region \\<X> k I r \\<and>\n             R' = Regions.region \\<X> I r)\n      r", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>Regions.valid_region \\<X> k ?I'5 ?r'5;\n   R' = Regions.region \\<X> ?I'5 ?r'5\\<rbrakk>\n  \\<Longrightarrow> \\<forall>c\\<in>\\<X>. ?I'5 c = I c\n  c \\<in> \\<X>\n  \\<exists>r.\n     Regions.valid_region \\<X> k\n      (SOME I.\n          \\<exists>r.\n             Regions.valid_region \\<X> k I r \\<and>\n             R' = Regions.region \\<X> I r)\n      r \\<and>\n     R' =\n     Regions.region \\<X>\n      (SOME I.\n          \\<exists>r.\n             Regions.valid_region \\<X> k I r \\<and>\n             R' = Regions.region \\<X> I r)\n      r\n\ngoal (1 subgoal):\n 1. (SOME I.\n        \\<exists>r.\n           Regions.valid_region \\<X> k I r \\<and>\n           R' = Regions.region \\<X> I r)\n     c =\n    I c", "by auto"], ["proof (state)\nthis:\n  (SOME I.\n      \\<exists>r.\n         Regions.valid_region \\<X> k I r \\<and>\n         R' = Regions.region \\<X> I r)\n   c =\n  I c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?c5 \\<in> \\<X> \\<Longrightarrow>\n  (SOME I.\n      \\<exists>r.\n         Regions.valid_region \\<X> k I r \\<and>\n         R' = Regions.region \\<X> I r)\n   ?c5 =\n  I ?c5\n\ngoal (2 subgoals):\n 1. delayedR R' u \\<in> R'\n 2. \\<exists>t\\<ge>0.\n       delayedR R' u = u \\<oplus> t \\<and>\n       (1 -\n        Max ({frac (u c) |c.\n              c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n             {0})) /\n       2\n       \\<le> t", "then"], ["proof (chain)\npicking this:\n  ?c5 \\<in> \\<X> \\<Longrightarrow>\n  (SOME I.\n      \\<exists>r.\n         Regions.valid_region \\<X> k I r \\<and>\n         R' = Regions.region \\<X> I r)\n   ?c5 =\n  I ?c5", "have \"?S = {frac (u c) | c. c \\<in> \\<X> \\<and> isIntv (?I c)}\""], ["proof (prove)\nusing this:\n  ?c5 \\<in> \\<X> \\<Longrightarrow>\n  (SOME I.\n      \\<exists>r.\n         Regions.valid_region \\<X> k I r \\<and>\n         R' = Regions.region \\<X> I r)\n   ?c5 =\n  I ?c5\n\ngoal (1 subgoal):\n 1. {frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} =\n    {frac (u c) |c.\n     c \\<in> \\<X> \\<and>\n     Regions.isIntv\n      ((SOME I.\n           \\<exists>r.\n              Regions.valid_region \\<X> k I r \\<and>\n              R' = Regions.region \\<X> I r)\n        c)}", "by auto"], ["proof (state)\nthis:\n  {frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} =\n  {frac (u c) |c.\n   c \\<in> \\<X> \\<and>\n   Regions.isIntv\n    ((SOME I.\n         \\<exists>r.\n            Regions.valid_region \\<X> k I r \\<and>\n            R' = Regions.region \\<X> I r)\n      c)}\n\ngoal (2 subgoals):\n 1. delayedR R' u \\<in> R'\n 2. \\<exists>t\\<ge>0.\n       delayedR R' u = u \\<oplus> t \\<and>\n       (1 -\n        Max ({frac (u c) |c.\n              c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n             {0})) /\n       2\n       \\<le> t", "have upper_bound: \"(u \\<oplus> ?m / 2) c < intv_const (I c) + 1\" if \"c \\<in> \\<X>\" \"isIntv (I c)\" for c"], ["proof (prove)\ngoal (1 subgoal):\n 1. (u \\<oplus>\n     (1 -\n      Max ({frac (u c) |c.\n            c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n           {0})) /\n     2)\n     c\n    < real (intv_const (I c) + 1)", "proof (cases \"u c > intv_const (I c)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. real (intv_const (I c)) < u c \\<Longrightarrow>\n    (u \\<oplus>\n     (1 -\n      Max ({frac (u c) |c.\n            c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n           {0})) /\n     2)\n     c\n    < real (intv_const (I c) + 1)\n 2. \\<not> real (intv_const (I c)) < u c \\<Longrightarrow>\n    (u \\<oplus>\n     (1 -\n      Max ({frac (u c) |c.\n            c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n           {0})) /\n     2)\n     c\n    < real (intv_const (I c) + 1)", "case True"], ["proof (state)\nthis:\n  real (intv_const (I c)) < u c\n\ngoal (2 subgoals):\n 1. real (intv_const (I c)) < u c \\<Longrightarrow>\n    (u \\<oplus>\n     (1 -\n      Max ({frac (u c) |c.\n            c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n           {0})) /\n     2)\n     c\n    < real (intv_const (I c) + 1)\n 2. \\<not> real (intv_const (I c)) < u c \\<Longrightarrow>\n    (u \\<oplus>\n     (1 -\n      Max ({frac (u c) |c.\n            c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n           {0})) /\n     2)\n     c\n    < real (intv_const (I c) + 1)", "from t that assms"], ["proof (chain)\npicking this:\n  u \\<oplus> t \\<in> R'\n  0 \\<le> t\n  c \\<in> \\<X>\n  Regions.isIntv (I c)\n  R' \\<equiv> Regions.region \\<X> I r\n  u \\<in> R\n  R \\<in> \\<R>\n  Regions.valid_region \\<X> k I r\n  \\<forall>c\\<in>\\<X>. \\<not> Regions.isConst (I c)\n  R' \\<in> Succ \\<R> R", "have \"u c + t < intv_const (I c) + 1\""], ["proof (prove)\nusing this:\n  u \\<oplus> t \\<in> R'\n  0 \\<le> t\n  c \\<in> \\<X>\n  Regions.isIntv (I c)\n  R' \\<equiv> Regions.region \\<X> I r\n  u \\<in> R\n  R \\<in> \\<R>\n  Regions.valid_region \\<X> k I r\n  \\<forall>c\\<in>\\<X>. \\<not> Regions.isConst (I c)\n  R' \\<in> Succ \\<R> R\n\ngoal (1 subgoal):\n 1. u c + t < real (intv_const (I c) + 1)", "unfolding cval_add_def"], ["proof (prove)\nusing this:\n  (\\<lambda>x. u x + t) \\<in> R'\n  0 \\<le> t\n  c \\<in> \\<X>\n  Regions.isIntv (I c)\n  R' \\<equiv> Regions.region \\<X> I r\n  u \\<in> R\n  R \\<in> \\<R>\n  Regions.valid_region \\<X> k I r\n  \\<forall>c\\<in>\\<X>. \\<not> Regions.isConst (I c)\n  R' \\<in> Succ \\<R> R\n\ngoal (1 subgoal):\n 1. u c + t < real (intv_const (I c) + 1)", "by fastforce"], ["proof (state)\nthis:\n  u c + t < real (intv_const (I c) + 1)\n\ngoal (2 subgoals):\n 1. real (intv_const (I c)) < u c \\<Longrightarrow>\n    (u \\<oplus>\n     (1 -\n      Max ({frac (u c) |c.\n            c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n           {0})) /\n     2)\n     c\n    < real (intv_const (I c) + 1)\n 2. \\<not> real (intv_const (I c)) < u c \\<Longrightarrow>\n    (u \\<oplus>\n     (1 -\n      Max ({frac (u c) |c.\n            c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n           {0})) /\n     2)\n     c\n    < real (intv_const (I c) + 1)", "with \\<open>t \\<ge> 0\\<close> True"], ["proof (chain)\npicking this:\n  0 \\<le> t\n  real (intv_const (I c)) < u c\n  u c + t < real (intv_const (I c) + 1)", "have *: \"intv_const (I c) < u c\" \"u c < intv_const (I c) + 1\""], ["proof (prove)\nusing this:\n  0 \\<le> t\n  real (intv_const (I c)) < u c\n  u c + t < real (intv_const (I c) + 1)\n\ngoal (1 subgoal):\n 1. real (intv_const (I c)) < u c &&& u c < real (intv_const (I c) + 1)", "by auto"], ["proof (state)\nthis:\n  real (intv_const (I c)) < u c\n  u c < real (intv_const (I c) + 1)\n\ngoal (2 subgoals):\n 1. real (intv_const (I c)) < u c \\<Longrightarrow>\n    (u \\<oplus>\n     (1 -\n      Max ({frac (u c) |c.\n            c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n           {0})) /\n     2)\n     c\n    < real (intv_const (I c) + 1)\n 2. \\<not> real (intv_const (I c)) < u c \\<Longrightarrow>\n    (u \\<oplus>\n     (1 -\n      Max ({frac (u c) |c.\n            c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n           {0})) /\n     2)\n     c\n    < real (intv_const (I c) + 1)", "have \"frac (u c) \\<le> Max (?S \\<union> {0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frac (u c)\n    \\<le> Max ({frac (u c) |c.\n                c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n               {0})", "using finite(1) that"], ["proof (prove)\nusing this:\n  finite \\<X>\n  c \\<in> \\<X>\n  Regions.isIntv (I c)\n\ngoal (1 subgoal):\n 1. frac (u c)\n    \\<le> Max ({frac (u c) |c.\n                c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n               {0})", "by - (rule Max_ge; auto)"], ["proof (state)\nthis:\n  frac (u c)\n  \\<le> Max ({frac (u c) |c.\n              c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n             {0})\n\ngoal (2 subgoals):\n 1. real (intv_const (I c)) < u c \\<Longrightarrow>\n    (u \\<oplus>\n     (1 -\n      Max ({frac (u c) |c.\n            c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n           {0})) /\n     2)\n     c\n    < real (intv_const (I c) + 1)\n 2. \\<not> real (intv_const (I c)) < u c \\<Longrightarrow>\n    (u \\<oplus>\n     (1 -\n      Max ({frac (u c) |c.\n            c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n           {0})) /\n     2)\n     c\n    < real (intv_const (I c) + 1)", "then"], ["proof (chain)\npicking this:\n  frac (u c)\n  \\<le> Max ({frac (u c) |c.\n              c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n             {0})", "have \"?m \\<le> 1 - frac (u c)\""], ["proof (prove)\nusing this:\n  frac (u c)\n  \\<le> Max ({frac (u c) |c.\n              c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n             {0})\n\ngoal (1 subgoal):\n 1. 1 -\n    Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n         {0})\n    \\<le> 1 - frac (u c)", "by auto"], ["proof (state)\nthis:\n  1 -\n  Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n       {0})\n  \\<le> 1 - frac (u c)\n\ngoal (2 subgoals):\n 1. real (intv_const (I c)) < u c \\<Longrightarrow>\n    (u \\<oplus>\n     (1 -\n      Max ({frac (u c) |c.\n            c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n           {0})) /\n     2)\n     c\n    < real (intv_const (I c) + 1)\n 2. \\<not> real (intv_const (I c)) < u c \\<Longrightarrow>\n    (u \\<oplus>\n     (1 -\n      Max ({frac (u c) |c.\n            c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n           {0})) /\n     2)\n     c\n    < real (intv_const (I c) + 1)", "then"], ["proof (chain)\npicking this:\n  1 -\n  Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n       {0})\n  \\<le> 1 - frac (u c)", "have \"?m / 2 < 1 - frac (u c)\""], ["proof (prove)\nusing this:\n  1 -\n  Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n       {0})\n  \\<le> 1 - frac (u c)\n\ngoal (1 subgoal):\n 1. (1 -\n     Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n          {0})) /\n    2\n    < 1 - frac (u c)", "using * nat_intv_frac_decomp"], ["proof (prove)\nusing this:\n  1 -\n  Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n       {0})\n  \\<le> 1 - frac (u c)\n  real (intv_const (I c)) < u c\n  u c < real (intv_const (I c) + 1)\n  \\<lbrakk>real ?c < ?d; ?d < real (?c + 1)\\<rbrakk>\n  \\<Longrightarrow> ?d = real ?c + frac ?d\n\ngoal (1 subgoal):\n 1. (1 -\n     Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n          {0})) /\n    2\n    < 1 - frac (u c)", "by fastforce"], ["proof (state)\nthis:\n  (1 -\n   Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n        {0})) /\n  2\n  < 1 - frac (u c)\n\ngoal (2 subgoals):\n 1. real (intv_const (I c)) < u c \\<Longrightarrow>\n    (u \\<oplus>\n     (1 -\n      Max ({frac (u c) |c.\n            c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n           {0})) /\n     2)\n     c\n    < real (intv_const (I c) + 1)\n 2. \\<not> real (intv_const (I c)) < u c \\<Longrightarrow>\n    (u \\<oplus>\n     (1 -\n      Max ({frac (u c) |c.\n            c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n           {0})) /\n     2)\n     c\n    < real (intv_const (I c) + 1)", "then"], ["proof (chain)\npicking this:\n  (1 -\n   Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n        {0})) /\n  2\n  < 1 - frac (u c)", "have \"(u \\<oplus> ?m / 2) c < u c + 1 - frac (u c)\""], ["proof (prove)\nusing this:\n  (1 -\n   Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n        {0})) /\n  2\n  < 1 - frac (u c)\n\ngoal (1 subgoal):\n 1. (u \\<oplus>\n     (1 -\n      Max ({frac (u c) |c.\n            c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n           {0})) /\n     2)\n     c\n    < u c + 1 - frac (u c)", "unfolding cval_add_def"], ["proof (prove)\nusing this:\n  (1 -\n   Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n        {0})) /\n  2\n  < 1 - frac (u c)\n\ngoal (1 subgoal):\n 1. u c +\n    (1 -\n     Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n          {0})) /\n    2\n    < u c + 1 - frac (u c)", "by auto"], ["proof (state)\nthis:\n  (u \\<oplus>\n   (1 -\n    Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n         {0})) /\n   2)\n   c\n  < u c + 1 - frac (u c)\n\ngoal (2 subgoals):\n 1. real (intv_const (I c)) < u c \\<Longrightarrow>\n    (u \\<oplus>\n     (1 -\n      Max ({frac (u c) |c.\n            c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n           {0})) /\n     2)\n     c\n    < real (intv_const (I c) + 1)\n 2. \\<not> real (intv_const (I c)) < u c \\<Longrightarrow>\n    (u \\<oplus>\n     (1 -\n      Max ({frac (u c) |c.\n            c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n           {0})) /\n     2)\n     c\n    < real (intv_const (I c) + 1)", "also"], ["proof (state)\nthis:\n  (u \\<oplus>\n   (1 -\n    Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n         {0})) /\n   2)\n   c\n  < u c + 1 - frac (u c)\n\ngoal (2 subgoals):\n 1. real (intv_const (I c)) < u c \\<Longrightarrow>\n    (u \\<oplus>\n     (1 -\n      Max ({frac (u c) |c.\n            c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n           {0})) /\n     2)\n     c\n    < real (intv_const (I c) + 1)\n 2. \\<not> real (intv_const (I c)) < u c \\<Longrightarrow>\n    (u \\<oplus>\n     (1 -\n      Max ({frac (u c) |c.\n            c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n           {0})) /\n     2)\n     c\n    < real (intv_const (I c) + 1)", "from *"], ["proof (chain)\npicking this:\n  real (intv_const (I c)) < u c\n  u c < real (intv_const (I c) + 1)", "have\n      \"\\<dots> = intv_const (I c) + 1\""], ["proof (prove)\nusing this:\n  real (intv_const (I c)) < u c\n  u c < real (intv_const (I c) + 1)\n\ngoal (1 subgoal):\n 1. u c + 1 - frac (u c) = real (intv_const (I c) + 1)", "using nat_intv_frac_decomp of_nat_1 of_nat_add"], ["proof (prove)\nusing this:\n  real (intv_const (I c)) < u c\n  u c < real (intv_const (I c) + 1)\n  \\<lbrakk>real ?c < ?d; ?d < real (?c + 1)\\<rbrakk>\n  \\<Longrightarrow> ?d = real ?c + frac ?d\n  of_nat 1 = (1::?'a)\n  of_nat (?m + ?n) = of_nat ?m + of_nat ?n\n\ngoal (1 subgoal):\n 1. u c + 1 - frac (u c) = real (intv_const (I c) + 1)", "by fastforce"], ["proof (state)\nthis:\n  u c + 1 - frac (u c) = real (intv_const (I c) + 1)\n\ngoal (2 subgoals):\n 1. real (intv_const (I c)) < u c \\<Longrightarrow>\n    (u \\<oplus>\n     (1 -\n      Max ({frac (u c) |c.\n            c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n           {0})) /\n     2)\n     c\n    < real (intv_const (I c) + 1)\n 2. \\<not> real (intv_const (I c)) < u c \\<Longrightarrow>\n    (u \\<oplus>\n     (1 -\n      Max ({frac (u c) |c.\n            c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n           {0})) /\n     2)\n     c\n    < real (intv_const (I c) + 1)", "finally"], ["proof (chain)\npicking this:\n  (u \\<oplus>\n   (1 -\n    Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n         {0})) /\n   2)\n   c\n  < real (intv_const (I c) + 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  (u \\<oplus>\n   (1 -\n    Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n         {0})) /\n   2)\n   c\n  < real (intv_const (I c) + 1)\n\ngoal (1 subgoal):\n 1. (u \\<oplus>\n     (1 -\n      Max ({frac (u c) |c.\n            c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n           {0})) /\n     2)\n     c\n    < real (intv_const (I c) + 1)", "."], ["proof (state)\nthis:\n  (u \\<oplus>\n   (1 -\n    Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n         {0})) /\n   2)\n   c\n  < real (intv_const (I c) + 1)\n\ngoal (1 subgoal):\n 1. \\<not> real (intv_const (I c)) < u c \\<Longrightarrow>\n    (u \\<oplus>\n     (1 -\n      Max ({frac (u c) |c.\n            c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n           {0})) /\n     2)\n     c\n    < real (intv_const (I c) + 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> real (intv_const (I c)) < u c \\<Longrightarrow>\n    (u \\<oplus>\n     (1 -\n      Max ({frac (u c) |c.\n            c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n           {0})) /\n     2)\n     c\n    < real (intv_const (I c) + 1)", "case False"], ["proof (state)\nthis:\n  \\<not> real (intv_const (I c)) < u c\n\ngoal (1 subgoal):\n 1. \\<not> real (intv_const (I c)) < u c \\<Longrightarrow>\n    (u \\<oplus>\n     (1 -\n      Max ({frac (u c) |c.\n            c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n           {0})) /\n     2)\n     c\n    < real (intv_const (I c) + 1)", "then"], ["proof (chain)\npicking this:\n  \\<not> real (intv_const (I c)) < u c", "have \"u c \\<le> intv_const (I c)\""], ["proof (prove)\nusing this:\n  \\<not> real (intv_const (I c)) < u c\n\ngoal (1 subgoal):\n 1. u c \\<le> real (intv_const (I c))", "by auto"], ["proof (state)\nthis:\n  u c \\<le> real (intv_const (I c))\n\ngoal (1 subgoal):\n 1. \\<not> real (intv_const (I c)) < u c \\<Longrightarrow>\n    (u \\<oplus>\n     (1 -\n      Max ({frac (u c) |c.\n            c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n           {0})) /\n     2)\n     c\n    < real (intv_const (I c) + 1)", "moreover"], ["proof (state)\nthis:\n  u c \\<le> real (intv_const (I c))\n\ngoal (1 subgoal):\n 1. \\<not> real (intv_const (I c)) < u c \\<Longrightarrow>\n    (u \\<oplus>\n     (1 -\n      Max ({frac (u c) |c.\n            c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n           {0})) /\n     2)\n     c\n    < real (intv_const (I c) + 1)", "from \\<open>0 \\<le> ?m\\<close> \\<open>?m \\<le> 1\\<close>"], ["proof (chain)\npicking this:\n  0 \\<le> 1 -\n          Max ({frac (u c) |c.\n                c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n               {0})\n  1 -\n  Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n       {0})\n  \\<le> 1", "have \"?m / 2 < 1\""], ["proof (prove)\nusing this:\n  0 \\<le> 1 -\n          Max ({frac (u c) |c.\n                c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n               {0})\n  1 -\n  Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n       {0})\n  \\<le> 1\n\ngoal (1 subgoal):\n 1. (1 -\n     Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n          {0})) /\n    2\n    < 1", "by auto"], ["proof (state)\nthis:\n  (1 -\n   Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n        {0})) /\n  2\n  < 1\n\ngoal (1 subgoal):\n 1. \\<not> real (intv_const (I c)) < u c \\<Longrightarrow>\n    (u \\<oplus>\n     (1 -\n      Max ({frac (u c) |c.\n            c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n           {0})) /\n     2)\n     c\n    < real (intv_const (I c) + 1)", "ultimately"], ["proof (chain)\npicking this:\n  u c \\<le> real (intv_const (I c))\n  (1 -\n   Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n        {0})) /\n  2\n  < 1", "have \"u c + ?m / 2 < intv_const (I c) + 1\""], ["proof (prove)\nusing this:\n  u c \\<le> real (intv_const (I c))\n  (1 -\n   Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n        {0})) /\n  2\n  < 1\n\ngoal (1 subgoal):\n 1. u c +\n    (1 -\n     Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n          {0})) /\n    2\n    < real (intv_const (I c) + 1)", "by linarith"], ["proof (state)\nthis:\n  u c +\n  (1 -\n   Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n        {0})) /\n  2\n  < real (intv_const (I c) + 1)\n\ngoal (1 subgoal):\n 1. \\<not> real (intv_const (I c)) < u c \\<Longrightarrow>\n    (u \\<oplus>\n     (1 -\n      Max ({frac (u c) |c.\n            c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n           {0})) /\n     2)\n     c\n    < real (intv_const (I c) + 1)", "then"], ["proof (chain)\npicking this:\n  u c +\n  (1 -\n   Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n        {0})) /\n  2\n  < real (intv_const (I c) + 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  u c +\n  (1 -\n   Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n        {0})) /\n  2\n  < real (intv_const (I c) + 1)\n\ngoal (1 subgoal):\n 1. (u \\<oplus>\n     (1 -\n      Max ({frac (u c) |c.\n            c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n           {0})) /\n     2)\n     c\n    < real (intv_const (I c) + 1)", "by (simp add: cval_add_def)"], ["proof (state)\nthis:\n  (u \\<oplus>\n   (1 -\n    Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n         {0})) /\n   2)\n   c\n  < real (intv_const (I c) + 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?c5 \\<in> \\<X>; Regions.isIntv (I ?c5)\\<rbrakk>\n  \\<Longrightarrow> (u \\<oplus>\n                     (1 -\n                      Max ({frac (u c) |c.\n                            c \\<in> \\<X> \\<and>\n                            Regions.isIntv (I c)} \\<union>\n                           {0})) /\n                     2)\n                     ?c5\n                    < real (intv_const (I ?c5) + 1)\n\ngoal (2 subgoals):\n 1. delayedR R' u \\<in> R'\n 2. \\<exists>t\\<ge>0.\n       delayedR R' u = u \\<oplus> t \\<and>\n       (1 -\n        Max ({frac (u c) |c.\n              c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n             {0})) /\n       2\n       \\<le> t", "have \"?t \\<ge> 0 \\<and> u \\<oplus> ?t \\<in> R' \\<and> ?t \\<ge> ?m / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (SOME t.\n                u \\<oplus> t \\<in> R' \\<and>\n                (1 -\n                 Max ({frac (u c) |c.\n                       c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                      {0})) /\n                2\n                \\<le> t) \\<and>\n    u \\<oplus>\n    (SOME t.\n        u \\<oplus> t \\<in> R' \\<and>\n        (1 -\n         Max ({frac (u c) |c.\n               c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n              {0})) /\n        2\n        \\<le> t)\n    \\<in> R' \\<and>\n    (1 -\n     Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n          {0})) /\n    2\n    \\<le> (SOME t.\n              u \\<oplus> t \\<in> R' \\<and>\n              (1 -\n               Max ({frac (u c) |c.\n                     c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                    {0})) /\n              2\n              \\<le> t)", "proof (cases \"t \\<ge> ?m / 2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (1 -\n     Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n          {0})) /\n    2\n    \\<le> t \\<Longrightarrow>\n    0 \\<le> (SOME t.\n                u \\<oplus> t \\<in> R' \\<and>\n                (1 -\n                 Max ({frac (u c) |c.\n                       c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                      {0})) /\n                2\n                \\<le> t) \\<and>\n    u \\<oplus>\n    (SOME t.\n        u \\<oplus> t \\<in> R' \\<and>\n        (1 -\n         Max ({frac (u c) |c.\n               c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n              {0})) /\n        2\n        \\<le> t)\n    \\<in> R' \\<and>\n    (1 -\n     Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n          {0})) /\n    2\n    \\<le> (SOME t.\n              u \\<oplus> t \\<in> R' \\<and>\n              (1 -\n               Max ({frac (u c) |c.\n                     c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                    {0})) /\n              2\n              \\<le> t)\n 2. \\<not> (1 -\n            Max ({frac (u c) |c.\n                  c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                 {0})) /\n           2\n           \\<le> t \\<Longrightarrow>\n    0 \\<le> (SOME t.\n                u \\<oplus> t \\<in> R' \\<and>\n                (1 -\n                 Max ({frac (u c) |c.\n                       c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                      {0})) /\n                2\n                \\<le> t) \\<and>\n    u \\<oplus>\n    (SOME t.\n        u \\<oplus> t \\<in> R' \\<and>\n        (1 -\n         Max ({frac (u c) |c.\n               c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n              {0})) /\n        2\n        \\<le> t)\n    \\<in> R' \\<and>\n    (1 -\n     Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n          {0})) /\n    2\n    \\<le> (SOME t.\n              u \\<oplus> t \\<in> R' \\<and>\n              (1 -\n               Max ({frac (u c) |c.\n                     c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                    {0})) /\n              2\n              \\<le> t)", "case True"], ["proof (state)\nthis:\n  (1 -\n   Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n        {0})) /\n  2\n  \\<le> t\n\ngoal (2 subgoals):\n 1. (1 -\n     Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n          {0})) /\n    2\n    \\<le> t \\<Longrightarrow>\n    0 \\<le> (SOME t.\n                u \\<oplus> t \\<in> R' \\<and>\n                (1 -\n                 Max ({frac (u c) |c.\n                       c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                      {0})) /\n                2\n                \\<le> t) \\<and>\n    u \\<oplus>\n    (SOME t.\n        u \\<oplus> t \\<in> R' \\<and>\n        (1 -\n         Max ({frac (u c) |c.\n               c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n              {0})) /\n        2\n        \\<le> t)\n    \\<in> R' \\<and>\n    (1 -\n     Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n          {0})) /\n    2\n    \\<le> (SOME t.\n              u \\<oplus> t \\<in> R' \\<and>\n              (1 -\n               Max ({frac (u c) |c.\n                     c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                    {0})) /\n              2\n              \\<le> t)\n 2. \\<not> (1 -\n            Max ({frac (u c) |c.\n                  c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                 {0})) /\n           2\n           \\<le> t \\<Longrightarrow>\n    0 \\<le> (SOME t.\n                u \\<oplus> t \\<in> R' \\<and>\n                (1 -\n                 Max ({frac (u c) |c.\n                       c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                      {0})) /\n                2\n                \\<le> t) \\<and>\n    u \\<oplus>\n    (SOME t.\n        u \\<oplus> t \\<in> R' \\<and>\n        (1 -\n         Max ({frac (u c) |c.\n               c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n              {0})) /\n        2\n        \\<le> t)\n    \\<in> R' \\<and>\n    (1 -\n     Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n          {0})) /\n    2\n    \\<le> (SOME t.\n              u \\<oplus> t \\<in> R' \\<and>\n              (1 -\n               Max ({frac (u c) |c.\n                     c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                    {0})) /\n              2\n              \\<le> t)", "from \\<open>t \\<ge> ?m / 2\\<close> t \\<open>Max (?S \\<union> {0}) \\<le> 1\\<close>"], ["proof (chain)\npicking this:\n  (1 -\n   Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n        {0})) /\n  2\n  \\<le> t\n  u \\<oplus> t \\<in> R'\n  0 \\<le> t\n  Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n       {0})\n  \\<le> 1", "have \"u \\<oplus> ?t \\<in> R' \\<and> ?t \\<ge> ?m / 2\""], ["proof (prove)\nusing this:\n  (1 -\n   Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n        {0})) /\n  2\n  \\<le> t\n  u \\<oplus> t \\<in> R'\n  0 \\<le> t\n  Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n       {0})\n  \\<le> 1\n\ngoal (1 subgoal):\n 1. u \\<oplus>\n    (SOME t.\n        u \\<oplus> t \\<in> R' \\<and>\n        (1 -\n         Max ({frac (u c) |c.\n               c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n              {0})) /\n        2\n        \\<le> t)\n    \\<in> R' \\<and>\n    (1 -\n     Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n          {0})) /\n    2\n    \\<le> (SOME t.\n              u \\<oplus> t \\<in> R' \\<and>\n              (1 -\n               Max ({frac (u c) |c.\n                     c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                    {0})) /\n              2\n              \\<le> t)", "by - (rule someI; auto)"], ["proof (state)\nthis:\n  u \\<oplus>\n  (SOME t.\n      u \\<oplus> t \\<in> R' \\<and>\n      (1 -\n       Max ({frac (u c) |c.\n             c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n            {0})) /\n      2\n      \\<le> t)\n  \\<in> R' \\<and>\n  (1 -\n   Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n        {0})) /\n  2\n  \\<le> (SOME t.\n            u \\<oplus> t \\<in> R' \\<and>\n            (1 -\n             Max ({frac (u c) |c.\n                   c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                  {0})) /\n            2\n            \\<le> t)\n\ngoal (2 subgoals):\n 1. (1 -\n     Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n          {0})) /\n    2\n    \\<le> t \\<Longrightarrow>\n    0 \\<le> (SOME t.\n                u \\<oplus> t \\<in> R' \\<and>\n                (1 -\n                 Max ({frac (u c) |c.\n                       c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                      {0})) /\n                2\n                \\<le> t) \\<and>\n    u \\<oplus>\n    (SOME t.\n        u \\<oplus> t \\<in> R' \\<and>\n        (1 -\n         Max ({frac (u c) |c.\n               c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n              {0})) /\n        2\n        \\<le> t)\n    \\<in> R' \\<and>\n    (1 -\n     Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n          {0})) /\n    2\n    \\<le> (SOME t.\n              u \\<oplus> t \\<in> R' \\<and>\n              (1 -\n               Max ({frac (u c) |c.\n                     c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                    {0})) /\n              2\n              \\<le> t)\n 2. \\<not> (1 -\n            Max ({frac (u c) |c.\n                  c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                 {0})) /\n           2\n           \\<le> t \\<Longrightarrow>\n    0 \\<le> (SOME t.\n                u \\<oplus> t \\<in> R' \\<and>\n                (1 -\n                 Max ({frac (u c) |c.\n                       c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                      {0})) /\n                2\n                \\<le> t) \\<and>\n    u \\<oplus>\n    (SOME t.\n        u \\<oplus> t \\<in> R' \\<and>\n        (1 -\n         Max ({frac (u c) |c.\n               c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n              {0})) /\n        2\n        \\<le> t)\n    \\<in> R' \\<and>\n    (1 -\n     Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n          {0})) /\n    2\n    \\<le> (SOME t.\n              u \\<oplus> t \\<in> R' \\<and>\n              (1 -\n               Max ({frac (u c) |c.\n                     c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                    {0})) /\n              2\n              \\<le> t)", "with \\<open>?m \\<ge> 0\\<close>"], ["proof (chain)\npicking this:\n  0 \\<le> 1 -\n          Max ({frac (u c) |c.\n                c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n               {0})\n  u \\<oplus>\n  (SOME t.\n      u \\<oplus> t \\<in> R' \\<and>\n      (1 -\n       Max ({frac (u c) |c.\n             c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n            {0})) /\n      2\n      \\<le> t)\n  \\<in> R' \\<and>\n  (1 -\n   Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n        {0})) /\n  2\n  \\<le> (SOME t.\n            u \\<oplus> t \\<in> R' \\<and>\n            (1 -\n             Max ({frac (u c) |c.\n                   c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                  {0})) /\n            2\n            \\<le> t)", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> 1 -\n          Max ({frac (u c) |c.\n                c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n               {0})\n  u \\<oplus>\n  (SOME t.\n      u \\<oplus> t \\<in> R' \\<and>\n      (1 -\n       Max ({frac (u c) |c.\n             c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n            {0})) /\n      2\n      \\<le> t)\n  \\<in> R' \\<and>\n  (1 -\n   Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n        {0})) /\n  2\n  \\<le> (SOME t.\n            u \\<oplus> t \\<in> R' \\<and>\n            (1 -\n             Max ({frac (u c) |c.\n                   c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                  {0})) /\n            2\n            \\<le> t)\n\ngoal (1 subgoal):\n 1. 0 \\<le> (SOME t.\n                u \\<oplus> t \\<in> R' \\<and>\n                (1 -\n                 Max ({frac (u c) |c.\n                       c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                      {0})) /\n                2\n                \\<le> t) \\<and>\n    u \\<oplus>\n    (SOME t.\n        u \\<oplus> t \\<in> R' \\<and>\n        (1 -\n         Max ({frac (u c) |c.\n               c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n              {0})) /\n        2\n        \\<le> t)\n    \\<in> R' \\<and>\n    (1 -\n     Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n          {0})) /\n    2\n    \\<le> (SOME t.\n              u \\<oplus> t \\<in> R' \\<and>\n              (1 -\n               Max ({frac (u c) |c.\n                     c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                    {0})) /\n              2\n              \\<le> t)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> (SOME t.\n              u \\<oplus> t \\<in> R' \\<and>\n              (1 -\n               Max ({frac (u c) |c.\n                     c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                    {0})) /\n              2\n              \\<le> t) \\<and>\n  u \\<oplus>\n  (SOME t.\n      u \\<oplus> t \\<in> R' \\<and>\n      (1 -\n       Max ({frac (u c) |c.\n             c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n            {0})) /\n      2\n      \\<le> t)\n  \\<in> R' \\<and>\n  (1 -\n   Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n        {0})) /\n  2\n  \\<le> (SOME t.\n            u \\<oplus> t \\<in> R' \\<and>\n            (1 -\n             Max ({frac (u c) |c.\n                   c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                  {0})) /\n            2\n            \\<le> t)\n\ngoal (1 subgoal):\n 1. \\<not> (1 -\n            Max ({frac (u c) |c.\n                  c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                 {0})) /\n           2\n           \\<le> t \\<Longrightarrow>\n    0 \\<le> (SOME t.\n                u \\<oplus> t \\<in> R' \\<and>\n                (1 -\n                 Max ({frac (u c) |c.\n                       c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                      {0})) /\n                2\n                \\<le> t) \\<and>\n    u \\<oplus>\n    (SOME t.\n        u \\<oplus> t \\<in> R' \\<and>\n        (1 -\n         Max ({frac (u c) |c.\n               c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n              {0})) /\n        2\n        \\<le> t)\n    \\<in> R' \\<and>\n    (1 -\n     Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n          {0})) /\n    2\n    \\<le> (SOME t.\n              u \\<oplus> t \\<in> R' \\<and>\n              (1 -\n               Max ({frac (u c) |c.\n                     c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                    {0})) /\n              2\n              \\<le> t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (1 -\n            Max ({frac (u c) |c.\n                  c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                 {0})) /\n           2\n           \\<le> t \\<Longrightarrow>\n    0 \\<le> (SOME t.\n                u \\<oplus> t \\<in> R' \\<and>\n                (1 -\n                 Max ({frac (u c) |c.\n                       c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                      {0})) /\n                2\n                \\<le> t) \\<and>\n    u \\<oplus>\n    (SOME t.\n        u \\<oplus> t \\<in> R' \\<and>\n        (1 -\n         Max ({frac (u c) |c.\n               c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n              {0})) /\n        2\n        \\<le> t)\n    \\<in> R' \\<and>\n    (1 -\n     Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n          {0})) /\n    2\n    \\<le> (SOME t.\n              u \\<oplus> t \\<in> R' \\<and>\n              (1 -\n               Max ({frac (u c) |c.\n                     c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                    {0})) /\n              2\n              \\<le> t)", "case False"], ["proof (state)\nthis:\n  \\<not> (1 -\n          Max ({frac (u c) |c.\n                c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n               {0})) /\n         2\n         \\<le> t\n\ngoal (1 subgoal):\n 1. \\<not> (1 -\n            Max ({frac (u c) |c.\n                  c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                 {0})) /\n           2\n           \\<le> t \\<Longrightarrow>\n    0 \\<le> (SOME t.\n                u \\<oplus> t \\<in> R' \\<and>\n                (1 -\n                 Max ({frac (u c) |c.\n                       c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                      {0})) /\n                2\n                \\<le> t) \\<and>\n    u \\<oplus>\n    (SOME t.\n        u \\<oplus> t \\<in> R' \\<and>\n        (1 -\n         Max ({frac (u c) |c.\n               c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n              {0})) /\n        2\n        \\<le> t)\n    \\<in> R' \\<and>\n    (1 -\n     Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n          {0})) /\n    2\n    \\<le> (SOME t.\n              u \\<oplus> t \\<in> R' \\<and>\n              (1 -\n               Max ({frac (u c) |c.\n                     c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                    {0})) /\n              2\n              \\<le> t)", "have \"u \\<oplus> ?m / 2 \\<in> R'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<oplus>\n    (1 -\n     Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n          {0})) /\n    2\n    \\<in> R'", "unfolding R'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<oplus>\n    (1 -\n     Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n          {0})) /\n    2\n    \\<in> Regions.region \\<X> I r", "apply (rule delayedR_correct_aux')"], ["proof (prove)\ngoal (5 subgoals):\n 1. u \\<oplus> ?t1.0 \\<in> Regions.region \\<X> I r\n 2. Regions.valid_region \\<X> k I r\n 3. \\<forall>c\\<in>\\<X>. \\<not> Regions.isConst (I c)\n 4. \\<forall>c\\<in>\\<X>.\n       Regions.isIntv (I c) \\<longrightarrow>\n       (u \\<oplus>\n        (1 -\n         Max ({frac (u c) |c.\n               c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n              {0})) /\n        2)\n        c\n       < real (intv_const (I c) + 1)\n 5. ?t1.0\n    \\<le> (1 -\n           Max ({frac (u c) |c.\n                 c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                {0})) /\n          2", "apply (rule t[unfolded R'_def])"], ["proof (prove)\ngoal (4 subgoals):\n 1. Regions.valid_region \\<X> k I r\n 2. \\<forall>c\\<in>\\<X>. \\<not> Regions.isConst (I c)\n 3. \\<forall>c\\<in>\\<X>.\n       Regions.isIntv (I c) \\<longrightarrow>\n       (u \\<oplus>\n        (1 -\n         Max ({frac (u c) |c.\n               c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n              {0})) /\n        2)\n        c\n       < real (intv_const (I c) + 1)\n 4. t \\<le> (1 -\n             Max ({frac (u c) |c.\n                   c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                  {0})) /\n            2", "apply (rule assms)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>c\\<in>\\<X>.\n       Regions.isIntv (I c) \\<longrightarrow>\n       (u \\<oplus>\n        (1 -\n         Max ({frac (u c) |c.\n               c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n              {0})) /\n        2)\n        c\n       < real (intv_const (I c) + 1)\n 2. t \\<le> (1 -\n             Max ({frac (u c) |c.\n                   c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                  {0})) /\n            2", "using upper_bound False"], ["proof (prove)\nusing this:\n  \\<lbrakk>?c5 \\<in> \\<X>; Regions.isIntv (I ?c5)\\<rbrakk>\n  \\<Longrightarrow> (u \\<oplus>\n                     (1 -\n                      Max ({frac (u c) |c.\n                            c \\<in> \\<X> \\<and>\n                            Regions.isIntv (I c)} \\<union>\n                           {0})) /\n                     2)\n                     ?c5\n                    < real (intv_const (I ?c5) + 1)\n  \\<not> (1 -\n          Max ({frac (u c) |c.\n                c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n               {0})) /\n         2\n         \\<le> t\n\ngoal (2 subgoals):\n 1. \\<forall>c\\<in>\\<X>.\n       Regions.isIntv (I c) \\<longrightarrow>\n       (u \\<oplus>\n        (1 -\n         Max ({frac (u c) |c.\n               c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n              {0})) /\n        2)\n        c\n       < real (intv_const (I c) + 1)\n 2. t \\<le> (1 -\n             Max ({frac (u c) |c.\n                   c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                  {0})) /\n            2", "by auto"], ["proof (state)\nthis:\n  u \\<oplus>\n  (1 -\n   Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n        {0})) /\n  2\n  \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<not> (1 -\n            Max ({frac (u c) |c.\n                  c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                 {0})) /\n           2\n           \\<le> t \\<Longrightarrow>\n    0 \\<le> (SOME t.\n                u \\<oplus> t \\<in> R' \\<and>\n                (1 -\n                 Max ({frac (u c) |c.\n                       c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                      {0})) /\n                2\n                \\<le> t) \\<and>\n    u \\<oplus>\n    (SOME t.\n        u \\<oplus> t \\<in> R' \\<and>\n        (1 -\n         Max ({frac (u c) |c.\n               c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n              {0})) /\n        2\n        \\<le> t)\n    \\<in> R' \\<and>\n    (1 -\n     Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n          {0})) /\n    2\n    \\<le> (SOME t.\n              u \\<oplus> t \\<in> R' \\<and>\n              (1 -\n               Max ({frac (u c) |c.\n                     c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                    {0})) /\n              2\n              \\<le> t)", "with \\<open>?m \\<ge> 0\\<close>"], ["proof (chain)\npicking this:\n  0 \\<le> 1 -\n          Max ({frac (u c) |c.\n                c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n               {0})\n  u \\<oplus>\n  (1 -\n   Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n        {0})) /\n  2\n  \\<in> R'", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> 1 -\n          Max ({frac (u c) |c.\n                c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n               {0})\n  u \\<oplus>\n  (1 -\n   Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n        {0})) /\n  2\n  \\<in> R'\n\ngoal (1 subgoal):\n 1. 0 \\<le> (SOME t.\n                u \\<oplus> t \\<in> R' \\<and>\n                (1 -\n                 Max ({frac (u c) |c.\n                       c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                      {0})) /\n                2\n                \\<le> t) \\<and>\n    u \\<oplus>\n    (SOME t.\n        u \\<oplus> t \\<in> R' \\<and>\n        (1 -\n         Max ({frac (u c) |c.\n               c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n              {0})) /\n        2\n        \\<le> t)\n    \\<in> R' \\<and>\n    (1 -\n     Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n          {0})) /\n    2\n    \\<le> (SOME t.\n              u \\<oplus> t \\<in> R' \\<and>\n              (1 -\n               Max ({frac (u c) |c.\n                     c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                    {0})) /\n              2\n              \\<le> t)", "by - (rule someI2; fastforce)"], ["proof (state)\nthis:\n  0 \\<le> (SOME t.\n              u \\<oplus> t \\<in> R' \\<and>\n              (1 -\n               Max ({frac (u c) |c.\n                     c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                    {0})) /\n              2\n              \\<le> t) \\<and>\n  u \\<oplus>\n  (SOME t.\n      u \\<oplus> t \\<in> R' \\<and>\n      (1 -\n       Max ({frac (u c) |c.\n             c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n            {0})) /\n      2\n      \\<le> t)\n  \\<in> R' \\<and>\n  (1 -\n   Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n        {0})) /\n  2\n  \\<le> (SOME t.\n            u \\<oplus> t \\<in> R' \\<and>\n            (1 -\n             Max ({frac (u c) |c.\n                   c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                  {0})) /\n            2\n            \\<le> t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 \\<le> (SOME t.\n              u \\<oplus> t \\<in> R' \\<and>\n              (1 -\n               Max ({frac (u c) |c.\n                     c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                    {0})) /\n              2\n              \\<le> t) \\<and>\n  u \\<oplus>\n  (SOME t.\n      u \\<oplus> t \\<in> R' \\<and>\n      (1 -\n       Max ({frac (u c) |c.\n             c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n            {0})) /\n      2\n      \\<le> t)\n  \\<in> R' \\<and>\n  (1 -\n   Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n        {0})) /\n  2\n  \\<le> (SOME t.\n            u \\<oplus> t \\<in> R' \\<and>\n            (1 -\n             Max ({frac (u c) |c.\n                   c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                  {0})) /\n            2\n            \\<le> t)\n\ngoal (2 subgoals):\n 1. delayedR R' u \\<in> R'\n 2. \\<exists>t\\<ge>0.\n       delayedR R' u = u \\<oplus> t \\<and>\n       (1 -\n        Max ({frac (u c) |c.\n              c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n             {0})) /\n       2\n       \\<le> t", "then"], ["proof (chain)\npicking this:\n  0 \\<le> (SOME t.\n              u \\<oplus> t \\<in> R' \\<and>\n              (1 -\n               Max ({frac (u c) |c.\n                     c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                    {0})) /\n              2\n              \\<le> t) \\<and>\n  u \\<oplus>\n  (SOME t.\n      u \\<oplus> t \\<in> R' \\<and>\n      (1 -\n       Max ({frac (u c) |c.\n             c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n            {0})) /\n      2\n      \\<le> t)\n  \\<in> R' \\<and>\n  (1 -\n   Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n        {0})) /\n  2\n  \\<le> (SOME t.\n            u \\<oplus> t \\<in> R' \\<and>\n            (1 -\n             Max ({frac (u c) |c.\n                   c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                  {0})) /\n            2\n            \\<le> t)", "show \"delayedR R' u \\<in> R'\" \"\\<exists>t\\<ge>0. delayedR R' u = u \\<oplus> t \\<and> t \\<ge> ?m / 2\""], ["proof (prove)\nusing this:\n  0 \\<le> (SOME t.\n              u \\<oplus> t \\<in> R' \\<and>\n              (1 -\n               Max ({frac (u c) |c.\n                     c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                    {0})) /\n              2\n              \\<le> t) \\<and>\n  u \\<oplus>\n  (SOME t.\n      u \\<oplus> t \\<in> R' \\<and>\n      (1 -\n       Max ({frac (u c) |c.\n             c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n            {0})) /\n      2\n      \\<le> t)\n  \\<in> R' \\<and>\n  (1 -\n   Max ({frac (u c) |c. c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n        {0})) /\n  2\n  \\<le> (SOME t.\n            u \\<oplus> t \\<in> R' \\<and>\n            (1 -\n             Max ({frac (u c) |c.\n                   c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n                  {0})) /\n            2\n            \\<le> t)\n\ngoal (1 subgoal):\n 1. delayedR R' u \\<in> R' &&&\n    \\<exists>t\\<ge>0.\n       delayedR R' u = u \\<oplus> t \\<and>\n       (1 -\n        Max ({frac (u c) |c.\n              c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n             {0})) /\n       2\n       \\<le> t", "by (auto simp: delayedR_def \\<open>?S = _\\<close>)"], ["proof (state)\nthis:\n  delayedR R' u \\<in> R'\n  \\<exists>t\\<ge>0.\n     delayedR R' u = u \\<oplus> t \\<and>\n     (1 -\n      Max ({frac (u c) |c.\n            c \\<in> \\<X> \\<and> Regions.isIntv (I c)} \\<union>\n           {0})) /\n     2\n     \\<le> t\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  rept :: \"'s * ('c, t) cval \\<Rightarrow> ('s * ('c, t) cval set) pmf \\<Rightarrow> ('s * ('c, t) cval) pmf\"\nwhere\n  \"rept s \\<mu>_abs \\<equiv> let (l, u) = s in\n    if (\\<exists> R'. (l, u) \\<in> S \\<and> \\<mu>_abs = return_pmf (l, R') \\<and>\n        (([u]\\<^sub>\\<R> = R' \\<and> (\\<forall> c \\<in> \\<X>. u c > k c))))\n    then return_pmf (l, u \\<oplus> 0.5)\n    else if\n      (\\<exists> R'. (l, u) \\<in> S \\<and> \\<mu>_abs = return_pmf (l, R') \\<and> R' \\<in> Succ \\<R> ([u]\\<^sub>\\<R>) \\<and> [u]\\<^sub>\\<R> \\<noteq> R'\n           \\<and> (\\<forall> u \\<in> R'. \\<forall> c \\<in> \\<X>. \\<nexists> d. d \\<le> k c \\<and>  u c = real d))\n    then return_pmf (l, delayedR (SOME R'. \\<mu>_abs = return_pmf (l, R')) u)\n    else SOME \\<mu>. \\<mu> \\<in> K s \\<and> abst \\<mu> = \\<mu>_abs\""], ["", "(* XXX Move *)"], ["", "lemma \\<S>_L:\n  \"l \\<in> L\" if \"(l, R) \\<in> \\<S>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<in> L", "using that"], ["proof (prove)\nusing this:\n  (l, R) \\<in> \\<S>\n\ngoal (1 subgoal):\n 1. l \\<in> L", "unfolding \\<S>_def"], ["proof (prove)\nusing this:\n  (l, R)\n  \\<in> {(l, R).\n         l \\<in> L \\<and>\n         R \\<in> \\<R> \\<and>\n         R \\<subseteq> {u. u \\<turnstile> PTA.inv_of A l}}\n\ngoal (1 subgoal):\n 1. l \\<in> L", "by auto"], ["", "lemma \\<S>_inv:\n  \"(l, R) \\<in> \\<S> \\<Longrightarrow> R \\<subseteq> \\<lbrace>inv_of A l\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l, R) \\<in> \\<S> \\<Longrightarrow>\n    R \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}", "unfolding \\<S>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (l, R)\n    \\<in> {(l, R).\n           l \\<in> L \\<and>\n           R \\<in> \\<R> \\<and>\n           R \\<subseteq> {u. u \\<turnstile> PTA.inv_of A\n       l}} \\<Longrightarrow>\n    R \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}", "by auto"], ["", "lemma upper_right_closed:\n  assumes \"\\<forall>c\\<in>\\<X>. real (k c) < u c\" \"u \\<in> R\" \"R \\<in> \\<R>\" \"t \\<ge> 0\"\n  shows \"u \\<oplus> t \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<oplus> t \\<in> R", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<oplus> t \\<in> R", "from \\<open>R \\<in> \\<R>\\<close>"], ["proof (chain)\npicking this:\n  R \\<in> \\<R>", "obtain I r where R:\n    \"R = region \\<X> I r\" \"valid_region \\<X> k I r\""], ["proof (prove)\nusing this:\n  R \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. (\\<And>I r.\n        \\<lbrakk>R = Regions.region \\<X> I r;\n         Regions.valid_region \\<X> k I r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<R>_def"], ["proof (prove)\nusing this:\n  R \\<in> {Regions.region \\<X> I r |I r. Regions.valid_region \\<X> k I r}\n\ngoal (1 subgoal):\n 1. (\\<And>I r.\n        \\<lbrakk>R = Regions.region \\<X> I r;\n         Regions.valid_region \\<X> k I r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  R = Regions.region \\<X> I r\n  Regions.valid_region \\<X> k I r\n\ngoal (1 subgoal):\n 1. u \\<oplus> t \\<in> R", "from assms \\<R>_V"], ["proof (chain)\npicking this:\n  \\<forall>c\\<in>\\<X>. real (k c) < u c\n  u \\<in> R\n  R \\<in> \\<R>\n  0 \\<le> t\n  \\<Union> \\<R> = V", "have \"u \\<in> V\""], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>\\<X>. real (k c) < u c\n  u \\<in> R\n  R \\<in> \\<R>\n  0 \\<le> t\n  \\<Union> \\<R> = V\n\ngoal (1 subgoal):\n 1. u \\<in> V", "by auto"], ["proof (state)\nthis:\n  u \\<in> V\n\ngoal (1 subgoal):\n 1. u \\<oplus> t \\<in> R", "from assms R"], ["proof (chain)\npicking this:\n  \\<forall>c\\<in>\\<X>. real (k c) < u c\n  u \\<in> R\n  R \\<in> \\<R>\n  0 \\<le> t\n  R = Regions.region \\<X> I r\n  Regions.valid_region \\<X> k I r", "have \"\\<forall> c \\<in> \\<X>. I c = Greater (k c)\""], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>\\<X>. real (k c) < u c\n  u \\<in> R\n  R \\<in> \\<R>\n  0 \\<le> t\n  R = Regions.region \\<X> I r\n  Regions.valid_region \\<X> k I r\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>\\<X>. I c = Regions.intv.Greater (k c)", "by safe (case_tac \"I c\"; fastforce)"], ["proof (state)\nthis:\n  \\<forall>c\\<in>\\<X>. I c = Regions.intv.Greater (k c)\n\ngoal (1 subgoal):\n 1. u \\<oplus> t \\<in> R", "with R \\<open>u \\<in> V\\<close> assms"], ["proof (chain)\npicking this:\n  R = Regions.region \\<X> I r\n  Regions.valid_region \\<X> k I r\n  u \\<in> V\n  \\<forall>c\\<in>\\<X>. real (k c) < u c\n  u \\<in> R\n  R \\<in> \\<R>\n  0 \\<le> t\n  \\<forall>c\\<in>\\<X>. I c = Regions.intv.Greater (k c)", "show\n    \"u \\<oplus> t \\<in> R\""], ["proof (prove)\nusing this:\n  R = Regions.region \\<X> I r\n  Regions.valid_region \\<X> k I r\n  u \\<in> V\n  \\<forall>c\\<in>\\<X>. real (k c) < u c\n  u \\<in> R\n  R \\<in> \\<R>\n  0 \\<le> t\n  \\<forall>c\\<in>\\<X>. I c = Regions.intv.Greater (k c)\n\ngoal (1 subgoal):\n 1. u \\<oplus> t \\<in> R", "unfolding V_def"], ["proof (prove)\nusing this:\n  R = Regions.region \\<X> I r\n  Regions.valid_region \\<X> k I r\n  u \\<in> {v. \\<forall>x\\<in>\\<X>. 0 \\<le> v x}\n  \\<forall>c\\<in>\\<X>. real (k c) < u c\n  u \\<in> R\n  R \\<in> \\<R>\n  0 \\<le> t\n  \\<forall>c\\<in>\\<X>. I c = Regions.intv.Greater (k c)\n\ngoal (1 subgoal):\n 1. u \\<oplus> t \\<in> R", "by safe (rule; force simp: cval_add_def)"], ["proof (state)\nthis:\n  u \\<oplus> t \\<in> R\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma S_I[intro]:\n  \"(l, u) \\<in> S\" if \"l \\<in> L\" \"u \\<in> V\" \"u \\<turnstile> inv_of A l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l, u) \\<in> S", "using that"], ["proof (prove)\nusing this:\n  l \\<in> L\n  u \\<in> V\n  u \\<turnstile> PTA.inv_of A l\n\ngoal (1 subgoal):\n 1. (l, u) \\<in> S", "by (auto simp: S_def V_def)"], ["", "lemma rept_ex:\n  assumes \"\\<mu> \\<in> \\<K> (abss s)\"\n  shows \"rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "using assms"], ["proof (prove)\nusing this:\n  \\<mu> \\<in> \\<K> (abss s)\n\ngoal (1 subgoal):\n 1. rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>l R R'.\n       \\<lbrakk>\\<mu> = return_pmf (l, R'); abss s \\<in> \\<S>;\n        abss s = (l, R); R' \\<in> Succ \\<R> R;\n        R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 2. \\<And>l R g \\<mu>'.\n       \\<lbrakk>\\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>';\n        abss s \\<in> \\<S>; abss s = (l, R);\n        (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 3. \\<mu> = return_pmf (abss s) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "case prems: (delay l R R')"], ["proof (state)\nthis:\n  \\<mu> = return_pmf (l, R')\n  abss s \\<in> \\<S>\n  abss s = (l, R)\n  R' \\<in> Succ \\<R> R\n  R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\n\ngoal (3 subgoals):\n 1. \\<And>l R R'.\n       \\<lbrakk>\\<mu> = return_pmf (l, R'); abss s \\<in> \\<S>;\n        abss s = (l, R); R' \\<in> Succ \\<R> R;\n        R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 2. \\<And>l R g \\<mu>'.\n       \\<lbrakk>\\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>';\n        abss s \\<in> \\<S>; abss s = (l, R);\n        (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 3. \\<mu> = return_pmf (abss s) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "then"], ["proof (chain)\npicking this:\n  \\<mu> = return_pmf (l, R')\n  abss s \\<in> \\<S>\n  abss s = (l, R)\n  R' \\<in> Succ \\<R> R\n  R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}", "have \"R \\<in> \\<R>\""], ["proof (prove)\nusing this:\n  \\<mu> = return_pmf (l, R')\n  abss s \\<in> \\<S>\n  abss s = (l, R)\n  R' \\<in> Succ \\<R> R\n  R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\n\ngoal (1 subgoal):\n 1. R \\<in> \\<R>", "by auto"], ["proof (state)\nthis:\n  R \\<in> \\<R>\n\ngoal (3 subgoals):\n 1. \\<And>l R R'.\n       \\<lbrakk>\\<mu> = return_pmf (l, R'); abss s \\<in> \\<S>;\n        abss s = (l, R); R' \\<in> Succ \\<R> R;\n        R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 2. \\<And>l R g \\<mu>'.\n       \\<lbrakk>\\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>';\n        abss s \\<in> \\<S>; abss s = (l, R);\n        (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 3. \\<mu> = return_pmf (abss s) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "from prems(2)"], ["proof (chain)\npicking this:\n  abss s \\<in> \\<S>", "have \"s \\<in> S\""], ["proof (prove)\nusing this:\n  abss s \\<in> \\<S>\n\ngoal (1 subgoal):\n 1. s \\<in> S", "by (auto intro: \\<S>_abss_S)"], ["proof (state)\nthis:\n  s \\<in> S\n\ngoal (3 subgoals):\n 1. \\<And>l R R'.\n       \\<lbrakk>\\<mu> = return_pmf (l, R'); abss s \\<in> \\<S>;\n        abss s = (l, R); R' \\<in> Succ \\<R> R;\n        R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 2. \\<And>l R g \\<mu>'.\n       \\<lbrakk>\\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>';\n        abss s \\<in> \\<S>; abss s = (l, R);\n        (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 3. \\<mu> = return_pmf (abss s) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "from abss_\\<S>D[OF prems(2)]"], ["proof (chain)\npicking this:\n  (\\<And>l u.\n      \\<lbrakk>s = (l, u); u \\<in> [u]\\<^sub>\\<R>;\n       [u]\\<^sub>\\<R> \\<in> \\<R>\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain l' u' where \"s = (l', u')\" \"u' \\<in> [u']\\<^sub>\\<R>\""], ["proof (prove)\nusing this:\n  (\\<And>l u.\n      \\<lbrakk>s = (l, u); u \\<in> [u]\\<^sub>\\<R>;\n       [u]\\<^sub>\\<R> \\<in> \\<R>\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>l' u'.\n        \\<lbrakk>s = (l', u'); u' \\<in> [u']\\<^sub>\\<R>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  s = (l', u')\n  u' \\<in> [u']\\<^sub>\\<R>\n\ngoal (3 subgoals):\n 1. \\<And>l R R'.\n       \\<lbrakk>\\<mu> = return_pmf (l, R'); abss s \\<in> \\<S>;\n        abss s = (l, R); R' \\<in> Succ \\<R> R;\n        R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 2. \\<And>l R g \\<mu>'.\n       \\<lbrakk>\\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>';\n        abss s \\<in> \\<S>; abss s = (l, R);\n        (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 3. \\<mu> = return_pmf (abss s) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "with prems(3)"], ["proof (chain)\npicking this:\n  abss s = (l, R)\n  s = (l', u')\n  u' \\<in> [u']\\<^sub>\\<R>", "have *: \"s = (l, u') \\<and> u' \\<in> R\""], ["proof (prove)\nusing this:\n  abss s = (l, R)\n  s = (l', u')\n  u' \\<in> [u']\\<^sub>\\<R>\n\ngoal (1 subgoal):\n 1. s = (l, u') \\<and> u' \\<in> R", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abss (l', u') = (l, R); s = (l', u');\n     u' \\<in> [u']\\<^sub>\\<R>\\<rbrakk>\n    \\<Longrightarrow> l' = l \\<and> u' \\<in> R", "apply (subst (asm) abss_S[OF \\<S>_abss_S])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>s = (l', u'); u' \\<in> [u']\\<^sub>\\<R>\\<rbrakk>\n    \\<Longrightarrow> abss (l', u') \\<in> \\<S>\n 2. \\<lbrakk>(l', [u']\\<^sub>\\<R>) = (l, R); s = (l', u');\n     u' \\<in> [u']\\<^sub>\\<R>\\<rbrakk>\n    \\<Longrightarrow> l' = l \\<and> u' \\<in> R", "using prems(2)"], ["proof (prove)\nusing this:\n  abss s \\<in> \\<S>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>s = (l', u'); u' \\<in> [u']\\<^sub>\\<R>\\<rbrakk>\n    \\<Longrightarrow> abss (l', u') \\<in> \\<S>\n 2. \\<lbrakk>(l', [u']\\<^sub>\\<R>) = (l, R); s = (l', u');\n     u' \\<in> [u']\\<^sub>\\<R>\\<rbrakk>\n    \\<Longrightarrow> l' = l \\<and> u' \\<in> R", "by auto"], ["proof (state)\nthis:\n  s = (l, u') \\<and> u' \\<in> R\n\ngoal (3 subgoals):\n 1. \\<And>l R R'.\n       \\<lbrakk>\\<mu> = return_pmf (l, R'); abss s \\<in> \\<S>;\n        abss s = (l, R); R' \\<in> Succ \\<R> R;\n        R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 2. \\<And>l R g \\<mu>'.\n       \\<lbrakk>\\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>';\n        abss s \\<in> \\<S>; abss s = (l, R);\n        (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 3. \\<mu> = return_pmf (abss s) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "with prems(4) alpha_interp.set_of_regions_spec[OF \\<open>R \\<in> \\<R>\\<close>]"], ["proof (chain)\npicking this:\n  R' \\<in> Succ \\<R> R\n  \\<lbrakk>?v \\<in> R; ?R' \\<in> Succ \\<R> R\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t\\<ge>0. [?v \\<oplus> t]\\<^sub>\\<R> = ?R'\n  s = (l, u') \\<and> u' \\<in> R", "obtain t where R':\n    \"t \\<ge> 0\" \"R' = [u' \\<oplus> t]\\<^sub>\\<R>\""], ["proof (prove)\nusing this:\n  R' \\<in> Succ \\<R> R\n  \\<lbrakk>?v \\<in> R; ?R' \\<in> Succ \\<R> R\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t\\<ge>0. [?v \\<oplus> t]\\<^sub>\\<R> = ?R'\n  s = (l, u') \\<and> u' \\<in> R\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>0 \\<le> t; R' = [u' \\<oplus> t]\\<^sub>\\<R>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  0 \\<le> t\n  R' = [u' \\<oplus> t]\\<^sub>\\<R>\n\ngoal (3 subgoals):\n 1. \\<And>l R R'.\n       \\<lbrakk>\\<mu> = return_pmf (l, R'); abss s \\<in> \\<S>;\n        abss s = (l, R); R' \\<in> Succ \\<R> R;\n        R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 2. \\<And>l R g \\<mu>'.\n       \\<lbrakk>\\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>';\n        abss s \\<in> \\<S>; abss s = (l, R);\n        (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 3. \\<mu> = return_pmf (abss s) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "with \\<open>s \\<in> S\\<close> *"], ["proof (chain)\npicking this:\n  s \\<in> S\n  s = (l, u') \\<and> u' \\<in> R\n  0 \\<le> t\n  R' = [u' \\<oplus> t]\\<^sub>\\<R>", "have \"u' \\<oplus> t \\<in> R'\" \"u' \\<oplus> t \\<in> V\" \"l \\<in> L\""], ["proof (prove)\nusing this:\n  s \\<in> S\n  s = (l, u') \\<and> u' \\<in> R\n  0 \\<le> t\n  R' = [u' \\<oplus> t]\\<^sub>\\<R>\n\ngoal (1 subgoal):\n 1. u' \\<oplus> t \\<in> R' &&& u' \\<oplus> t \\<in> V &&& l \\<in> L", "by auto"], ["proof (state)\nthis:\n  u' \\<oplus> t \\<in> R'\n  u' \\<oplus> t \\<in> V\n  l \\<in> L\n\ngoal (3 subgoals):\n 1. \\<And>l R R'.\n       \\<lbrakk>\\<mu> = return_pmf (l, R'); abss s \\<in> \\<S>;\n        abss s = (l, R); R' \\<in> Succ \\<R> R;\n        R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 2. \\<And>l R g \\<mu>'.\n       \\<lbrakk>\\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>';\n        abss s \\<in> \\<S>; abss s = (l, R);\n        (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 3. \\<mu> = return_pmf (abss s) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "with prems(5)"], ["proof (chain)\npicking this:\n  R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\n  u' \\<oplus> t \\<in> R'\n  u' \\<oplus> t \\<in> V\n  l \\<in> L", "have \"(l, u' \\<oplus> t) \\<in> S\""], ["proof (prove)\nusing this:\n  R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\n  u' \\<oplus> t \\<in> R'\n  u' \\<oplus> t \\<in> V\n  l \\<in> L\n\ngoal (1 subgoal):\n 1. (l, u' \\<oplus> t) \\<in> S", "unfolding S_def V_def"], ["proof (prove)\nusing this:\n  R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\n  u' \\<oplus> t \\<in> R'\n  u' \\<oplus> t \\<in> {v. \\<forall>x\\<in>\\<X>. 0 \\<le> v x}\n  l \\<in> L\n\ngoal (1 subgoal):\n 1. (l, u' \\<oplus> t)\n    \\<in> {(l, u).\n           l \\<in> L \\<and>\n           (\\<forall>x\\<in>\\<X>. 0 \\<le> u x) \\<and>\n           u \\<turnstile> PTA.inv_of A l}", "by auto"], ["proof (state)\nthis:\n  (l, u' \\<oplus> t) \\<in> S\n\ngoal (3 subgoals):\n 1. \\<And>l R R'.\n       \\<lbrakk>\\<mu> = return_pmf (l, R'); abss s \\<in> \\<S>;\n        abss s = (l, R); R' \\<in> Succ \\<R> R;\n        R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 2. \\<And>l R g \\<mu>'.\n       \\<lbrakk>\\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>';\n        abss s \\<in> \\<S>; abss s = (l, R);\n        (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 3. \\<mu> = return_pmf (abss s) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "with \\<open>R' = [u' \\<oplus> t]\\<^sub>\\<R>\\<close>"], ["proof (chain)\npicking this:\n  R' = [u' \\<oplus> t]\\<^sub>\\<R>\n  (l, u' \\<oplus> t) \\<in> S", "have **: \"abss (l, u' \\<oplus> t) = (l, R')\""], ["proof (prove)\nusing this:\n  R' = [u' \\<oplus> t]\\<^sub>\\<R>\n  (l, u' \\<oplus> t) \\<in> S\n\ngoal (1 subgoal):\n 1. abss (l, u' \\<oplus> t) = (l, R')", "by (auto simp: abss_S)"], ["proof (state)\nthis:\n  abss (l, u' \\<oplus> t) = (l, R')\n\ngoal (3 subgoals):\n 1. \\<And>l R R'.\n       \\<lbrakk>\\<mu> = return_pmf (l, R'); abss s \\<in> \\<S>;\n        abss s = (l, R); R' \\<in> Succ \\<R> R;\n        R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 2. \\<And>l R g \\<mu>'.\n       \\<lbrakk>\\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>';\n        abss s \\<in> \\<S>; abss s = (l, R);\n        (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 3. \\<mu> = return_pmf (abss s) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "let ?\\<mu> = \"return_pmf (l, u' \\<oplus> t)\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>l R R'.\n       \\<lbrakk>\\<mu> = return_pmf (l, R'); abss s \\<in> \\<S>;\n        abss s = (l, R); R' \\<in> Succ \\<R> R;\n        R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 2. \\<And>l R g \\<mu>'.\n       \\<lbrakk>\\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>';\n        abss s \\<in> \\<S>; abss s = (l, R);\n        (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 3. \\<mu> = return_pmf (abss s) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "have \"?\\<mu> \\<in> K s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. return_pmf (l, u' \\<oplus> t) \\<in> K s", "using * \\<open>s \\<in> S\\<close> \\<open>t \\<ge> 0\\<close> \\<open>u' \\<oplus> t \\<in> R'\\<close> prems"], ["proof (prove)\nusing this:\n  s = (l, u') \\<and> u' \\<in> R\n  s \\<in> S\n  0 \\<le> t\n  u' \\<oplus> t \\<in> R'\n  \\<mu> = return_pmf (l, R')\n  abss s \\<in> \\<S>\n  abss s = (l, R)\n  R' \\<in> Succ \\<R> R\n  R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\n\ngoal (1 subgoal):\n 1. return_pmf (l, u' \\<oplus> t) \\<in> K s", "by blast"], ["proof (state)\nthis:\n  return_pmf (l, u' \\<oplus> t) \\<in> K s\n\ngoal (3 subgoals):\n 1. \\<And>l R R'.\n       \\<lbrakk>\\<mu> = return_pmf (l, R'); abss s \\<in> \\<S>;\n        abss s = (l, R); R' \\<in> Succ \\<R> R;\n        R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 2. \\<And>l R g \\<mu>'.\n       \\<lbrakk>\\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>';\n        abss s \\<in> \\<S>; abss s = (l, R);\n        (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 3. \\<mu> = return_pmf (abss s) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "moreover"], ["proof (state)\nthis:\n  return_pmf (l, u' \\<oplus> t) \\<in> K s\n\ngoal (3 subgoals):\n 1. \\<And>l R R'.\n       \\<lbrakk>\\<mu> = return_pmf (l, R'); abss s \\<in> \\<S>;\n        abss s = (l, R); R' \\<in> Succ \\<R> R;\n        R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 2. \\<And>l R g \\<mu>'.\n       \\<lbrakk>\\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>';\n        abss s \\<in> \\<S>; abss s = (l, R);\n        (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 3. \\<mu> = return_pmf (abss s) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "have \"abst ?\\<mu> = \\<mu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abst (return_pmf (l, u' \\<oplus> t)) = \\<mu>", "by (simp add: ** abst_def prems(1))"], ["proof (state)\nthis:\n  abst (return_pmf (l, u' \\<oplus> t)) = \\<mu>\n\ngoal (3 subgoals):\n 1. \\<And>l R R'.\n       \\<lbrakk>\\<mu> = return_pmf (l, R'); abss s \\<in> \\<S>;\n        abss s = (l, R); R' \\<in> Succ \\<R> R;\n        R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 2. \\<And>l R g \\<mu>'.\n       \\<lbrakk>\\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>';\n        abss s \\<in> \\<S>; abss s = (l, R);\n        (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 3. \\<mu> = return_pmf (abss s) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "moreover"], ["proof (state)\nthis:\n  abst (return_pmf (l, u' \\<oplus> t)) = \\<mu>\n\ngoal (3 subgoals):\n 1. \\<And>l R R'.\n       \\<lbrakk>\\<mu> = return_pmf (l, R'); abss s \\<in> \\<S>;\n        abss s = (l, R); R' \\<in> Succ \\<R> R;\n        R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 2. \\<And>l R g \\<mu>'.\n       \\<lbrakk>\\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>';\n        abss s \\<in> \\<S>; abss s = (l, R);\n        (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 3. \\<mu> = return_pmf (abss s) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "note default = calculation"], ["proof (state)\nthis:\n  return_pmf (l, u' \\<oplus> t) \\<in> K s\n  abst (return_pmf (l, u' \\<oplus> t)) = \\<mu>\n\ngoal (3 subgoals):\n 1. \\<And>l R R'.\n       \\<lbrakk>\\<mu> = return_pmf (l, R'); abss s \\<in> \\<S>;\n        abss s = (l, R); R' \\<in> Succ \\<R> R;\n        R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 2. \\<And>l R g \\<mu>'.\n       \\<lbrakk>\\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>';\n        abss s \\<in> \\<S>; abss s = (l, R);\n        (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 3. \\<mu> = return_pmf (abss s) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "have \"R' \\<in> \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R' \\<in> \\<R>", "using prems(4)"], ["proof (prove)\nusing this:\n  R' \\<in> Succ \\<R> R\n\ngoal (1 subgoal):\n 1. R' \\<in> \\<R>", "by auto"], ["proof (state)\nthis:\n  R' \\<in> \\<R>\n\ngoal (3 subgoals):\n 1. \\<And>l R R'.\n       \\<lbrakk>\\<mu> = return_pmf (l, R'); abss s \\<in> \\<S>;\n        abss s = (l, R); R' \\<in> Succ \\<R> R;\n        R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 2. \\<And>l R g \\<mu>'.\n       \\<lbrakk>\\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>';\n        abss s \\<in> \\<S>; abss s = (l, R);\n        (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 3. \\<mu> = return_pmf (abss s) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "have R: \"[u']\\<^sub>\\<R> = R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [u']\\<^sub>\\<R> = R", "by (simp add: * \\<open>R \\<in> \\<R>\\<close> alpha_interp.region_unique_spec)"], ["proof (state)\nthis:\n  [u']\\<^sub>\\<R> = R\n\ngoal (3 subgoals):\n 1. \\<And>l R R'.\n       \\<lbrakk>\\<mu> = return_pmf (l, R'); abss s \\<in> \\<S>;\n        abss s = (l, R); R' \\<in> Succ \\<R> R;\n        R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 2. \\<And>l R g \\<mu>'.\n       \\<lbrakk>\\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>';\n        abss s \\<in> \\<S>; abss s = (l, R);\n        (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 3. \\<mu> = return_pmf (abss s) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "from \\<open>R' \\<in> \\<R>\\<close>"], ["proof (chain)\npicking this:\n  R' \\<in> \\<R>", "obtain I r where R':\n    \"R' = region \\<X> I r\" \"valid_region \\<X> k I r\""], ["proof (prove)\nusing this:\n  R' \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. (\\<And>I r.\n        \\<lbrakk>R' = Regions.region \\<X> I r;\n         Regions.valid_region \\<X> k I r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<R>_def"], ["proof (prove)\nusing this:\n  R' \\<in> {Regions.region \\<X> I r |I r. Regions.valid_region \\<X> k I r}\n\ngoal (1 subgoal):\n 1. (\\<And>I r.\n        \\<lbrakk>R' = Regions.region \\<X> I r;\n         Regions.valid_region \\<X> k I r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  R' = Regions.region \\<X> I r\n  Regions.valid_region \\<X> k I r\n\ngoal (3 subgoals):\n 1. \\<And>l R R'.\n       \\<lbrakk>\\<mu> = return_pmf (l, R'); abss s \\<in> \\<S>;\n        abss s = (l, R); R' \\<in> Succ \\<R> R;\n        R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 2. \\<And>l R g \\<mu>'.\n       \\<lbrakk>\\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>';\n        abss s \\<in> \\<S>; abss s = (l, R);\n        (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 3. \\<mu> = return_pmf (abss s) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "have \"u' \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u' \\<in> V", "using * prems \\<R>_V"], ["proof (prove)\nusing this:\n  s = (l, u') \\<and> u' \\<in> R\n  \\<mu> = return_pmf (l, R')\n  abss s \\<in> \\<S>\n  abss s = (l, R)\n  R' \\<in> Succ \\<R> R\n  R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\n  \\<Union> \\<R> = V\n\ngoal (1 subgoal):\n 1. u' \\<in> V", "by force"], ["proof (state)\nthis:\n  u' \\<in> V\n\ngoal (3 subgoals):\n 1. \\<And>l R R'.\n       \\<lbrakk>\\<mu> = return_pmf (l, R'); abss s \\<in> \\<S>;\n        abss s = (l, R); R' \\<in> Succ \\<R> R;\n        R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 2. \\<And>l R g \\<mu>'.\n       \\<lbrakk>\\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>';\n        abss s \\<in> \\<S>; abss s = (l, R);\n        (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 3. \\<mu> = return_pmf (abss s) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "let ?\\<mu>' = \"return_pmf (l, u' \\<oplus> 0.5)\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>l R R'.\n       \\<lbrakk>\\<mu> = return_pmf (l, R'); abss s \\<in> \\<S>;\n        abss s = (l, R); R' \\<in> Succ \\<R> R;\n        R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 2. \\<And>l R g \\<mu>'.\n       \\<lbrakk>\\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>';\n        abss s \\<in> \\<S>; abss s = (l, R);\n        (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 3. \\<mu> = return_pmf (abss s) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "have elapsed: \"abst (return_pmf (l, u' \\<oplus> t)) = \\<mu>\" \"return_pmf (l, u' \\<oplus> t) \\<in> K s\"\n    if \"u' \\<oplus> t \\<in> R'\" \"t \\<ge> 0\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. abst (return_pmf (l, u' \\<oplus> t)) = \\<mu> &&&\n    return_pmf (l, u' \\<oplus> t) \\<in> K s", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. abst (return_pmf (l, u' \\<oplus> t)) = \\<mu>\n 2. return_pmf (l, u' \\<oplus> t) \\<in> K s", "let ?u = \"u' \\<oplus> t\""], ["proof (state)\ngoal (2 subgoals):\n 1. abst (return_pmf (l, u' \\<oplus> t)) = \\<mu>\n 2. return_pmf (l, u' \\<oplus> t) \\<in> K s", "let ?\\<mu>' = \"return_pmf (l, u' \\<oplus> t)\""], ["proof (state)\ngoal (2 subgoals):\n 1. abst (return_pmf (l, u' \\<oplus> t)) = \\<mu>\n 2. return_pmf (l, u' \\<oplus> t) \\<in> K s", "from \\<open>?u \\<in> R'\\<close> \\<open>R' \\<in> \\<R>\\<close> \\<R>_V"], ["proof (chain)\npicking this:\n  u' \\<oplus> t \\<in> R'\n  R' \\<in> \\<R>\n  \\<Union> \\<R> = V", "have \"?u \\<in> V\""], ["proof (prove)\nusing this:\n  u' \\<oplus> t \\<in> R'\n  R' \\<in> \\<R>\n  \\<Union> \\<R> = V\n\ngoal (1 subgoal):\n 1. u' \\<oplus> t \\<in> V", "by auto"], ["proof (state)\nthis:\n  u' \\<oplus> t \\<in> V\n\ngoal (2 subgoals):\n 1. abst (return_pmf (l, u' \\<oplus> t)) = \\<mu>\n 2. return_pmf (l, u' \\<oplus> t) \\<in> K s", "with \\<open>?u \\<in> R'\\<close> \\<open>R' \\<in> \\<R>\\<close>"], ["proof (chain)\npicking this:\n  u' \\<oplus> t \\<in> R'\n  R' \\<in> \\<R>\n  u' \\<oplus> t \\<in> V", "have \"[?u]\\<^sub>\\<R> = R'\""], ["proof (prove)\nusing this:\n  u' \\<oplus> t \\<in> R'\n  R' \\<in> \\<R>\n  u' \\<oplus> t \\<in> V\n\ngoal (1 subgoal):\n 1. [u' \\<oplus> t]\\<^sub>\\<R> = R'", "using alpha_interp.region_unique_spec"], ["proof (prove)\nusing this:\n  u' \\<oplus> t \\<in> R'\n  R' \\<in> \\<R>\n  u' \\<oplus> t \\<in> V\n  \\<lbrakk>?u \\<in> ?R; ?R \\<in> \\<R>\\<rbrakk>\n  \\<Longrightarrow> [?u]\\<^sub>\\<R> = ?R\n\ngoal (1 subgoal):\n 1. [u' \\<oplus> t]\\<^sub>\\<R> = R'", "by auto"], ["proof (state)\nthis:\n  [u' \\<oplus> t]\\<^sub>\\<R> = R'\n\ngoal (2 subgoals):\n 1. abst (return_pmf (l, u' \\<oplus> t)) = \\<mu>\n 2. return_pmf (l, u' \\<oplus> t) \\<in> K s", "with \\<open>?u \\<in> V\\<close> \\<open>?u \\<in> R'\\<close> \\<open>l \\<in> L\\<close> prems(4,5)"], ["proof (chain)\npicking this:\n  u' \\<oplus> t \\<in> V\n  u' \\<oplus> t \\<in> R'\n  l \\<in> L\n  R' \\<in> Succ \\<R> R\n  R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\n  [u' \\<oplus> t]\\<^sub>\\<R> = R'", "have \"abss (l, ?u) = (l, R')\""], ["proof (prove)\nusing this:\n  u' \\<oplus> t \\<in> V\n  u' \\<oplus> t \\<in> R'\n  l \\<in> L\n  R' \\<in> Succ \\<R> R\n  R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\n  [u' \\<oplus> t]\\<^sub>\\<R> = R'\n\ngoal (1 subgoal):\n 1. abss (l, u' \\<oplus> t) = (l, R')", "by (subst abss_S) auto"], ["proof (state)\nthis:\n  abss (l, u' \\<oplus> t) = (l, R')\n\ngoal (2 subgoals):\n 1. abst (return_pmf (l, u' \\<oplus> t)) = \\<mu>\n 2. return_pmf (l, u' \\<oplus> t) \\<in> K s", "with prems(1)"], ["proof (chain)\npicking this:\n  \\<mu> = return_pmf (l, R')\n  abss (l, u' \\<oplus> t) = (l, R')", "have \"abst ?\\<mu>' = \\<mu>\""], ["proof (prove)\nusing this:\n  \\<mu> = return_pmf (l, R')\n  abss (l, u' \\<oplus> t) = (l, R')\n\ngoal (1 subgoal):\n 1. abst (return_pmf (l, u' \\<oplus> t)) = \\<mu>", "by (auto simp: abst_def)"], ["proof (state)\nthis:\n  abst (return_pmf (l, u' \\<oplus> t)) = \\<mu>\n\ngoal (2 subgoals):\n 1. abst (return_pmf (l, u' \\<oplus> t)) = \\<mu>\n 2. return_pmf (l, u' \\<oplus> t) \\<in> K s", "moreover"], ["proof (state)\nthis:\n  abst (return_pmf (l, u' \\<oplus> t)) = \\<mu>\n\ngoal (2 subgoals):\n 1. abst (return_pmf (l, u' \\<oplus> t)) = \\<mu>\n 2. return_pmf (l, u' \\<oplus> t) \\<in> K s", "from * \\<open>?u \\<in> R'\\<close> \\<open>s \\<in> S\\<close> prems \\<open>t \\<ge> 0\\<close>"], ["proof (chain)\npicking this:\n  s = (l, u') \\<and> u' \\<in> R\n  u' \\<oplus> t \\<in> R'\n  s \\<in> S\n  \\<mu> = return_pmf (l, R')\n  abss s \\<in> \\<S>\n  abss s = (l, R)\n  R' \\<in> Succ \\<R> R\n  R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\n  0 \\<le> t", "have \"?\\<mu>' \\<in> K s\""], ["proof (prove)\nusing this:\n  s = (l, u') \\<and> u' \\<in> R\n  u' \\<oplus> t \\<in> R'\n  s \\<in> S\n  \\<mu> = return_pmf (l, R')\n  abss s \\<in> \\<S>\n  abss s = (l, R)\n  R' \\<in> Succ \\<R> R\n  R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\n  0 \\<le> t\n\ngoal (1 subgoal):\n 1. return_pmf (l, u' \\<oplus> t) \\<in> K s", "by auto"], ["proof (state)\nthis:\n  return_pmf (l, u' \\<oplus> t) \\<in> K s\n\ngoal (2 subgoals):\n 1. abst (return_pmf (l, u' \\<oplus> t)) = \\<mu>\n 2. return_pmf (l, u' \\<oplus> t) \\<in> K s", "ultimately"], ["proof (chain)\npicking this:\n  abst (return_pmf (l, u' \\<oplus> t)) = \\<mu>\n  return_pmf (l, u' \\<oplus> t) \\<in> K s", "show \"abst ?\\<mu>' = \\<mu>\" \"?\\<mu>' \\<in> K s\""], ["proof (prove)\nusing this:\n  abst (return_pmf (l, u' \\<oplus> t)) = \\<mu>\n  return_pmf (l, u' \\<oplus> t) \\<in> K s\n\ngoal (1 subgoal):\n 1. abst (return_pmf (l, u' \\<oplus> t)) = \\<mu> &&&\n    return_pmf (l, u' \\<oplus> t) \\<in> K s", "by auto"], ["proof (state)\nthis:\n  abst (return_pmf (l, u' \\<oplus> t)) = \\<mu>\n  return_pmf (l, u' \\<oplus> t) \\<in> K s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>u' \\<oplus> ?t5 \\<in> R'; 0 \\<le> ?t5\\<rbrakk>\n  \\<Longrightarrow> abst (return_pmf (l, u' \\<oplus> ?t5)) = \\<mu>\n  \\<lbrakk>u' \\<oplus> ?t5 \\<in> R'; 0 \\<le> ?t5\\<rbrakk>\n  \\<Longrightarrow> return_pmf (l, u' \\<oplus> ?t5) \\<in> K s\n\ngoal (3 subgoals):\n 1. \\<And>l R R'.\n       \\<lbrakk>\\<mu> = return_pmf (l, R'); abss s \\<in> \\<S>;\n        abss s = (l, R); R' \\<in> Succ \\<R> R;\n        R' \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 2. \\<And>l R g \\<mu>'.\n       \\<lbrakk>\\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>';\n        abss s \\<in> \\<S>; abss s = (l, R);\n        (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 3. \\<mu> = return_pmf (abss s) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "proof (cases \"R = R'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. R = R' \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. R \\<noteq> R' \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "case T: True"], ["proof (state)\nthis:\n  R = R'\n\ngoal (2 subgoals):\n 1. R = R' \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. R \\<noteq> R' \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "proof (cases \"\\<forall> c \\<in> \\<X>. u' c > k c\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u' c \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u' c) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "case True"], ["proof (state)\nthis:\n  \\<forall>c\\<in>\\<X>. real (k c) < u' c\n\ngoal (2 subgoals):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u' c \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u' c) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "with T * R prems(1,4) \\<open>s \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  R = R'\n  s = (l, u') \\<and> u' \\<in> R\n  [u']\\<^sub>\\<R> = R\n  \\<mu> = return_pmf (l, R')\n  R' \\<in> Succ \\<R> R\n  s \\<in> S\n  \\<forall>c\\<in>\\<X>. real (k c) < u' c", "have\n        \"rept s \\<mu> = return_pmf (l, u' \\<oplus> 0.5)\" (is \"_ = ?\\<mu>\")"], ["proof (prove)\nusing this:\n  R = R'\n  s = (l, u') \\<and> u' \\<in> R\n  [u']\\<^sub>\\<R> = R\n  \\<mu> = return_pmf (l, R')\n  R' \\<in> Succ \\<R> R\n  s \\<in> S\n  \\<forall>c\\<in>\\<X>. real (k c) < u' c\n\ngoal (1 subgoal):\n 1. rept s \\<mu> = return_pmf (l, u' \\<oplus> 5 / 10)", "unfolding rept_def"], ["proof (prove)\nusing this:\n  R = R'\n  s = (l, u') \\<and> u' \\<in> R\n  [u']\\<^sub>\\<R> = R\n  \\<mu> = return_pmf (l, R')\n  R' \\<in> Succ \\<R> R\n  s \\<in> S\n  \\<forall>c\\<in>\\<X>. real (k c) < u' c\n\ngoal (1 subgoal):\n 1. (let (l, u) = s\n     in if \\<exists>R'.\n              (l, u) \\<in> S \\<and>\n              \\<mu> = return_pmf (l, R') \\<and>\n              [u]\\<^sub>\\<R> = R' \\<and>\n              (\\<forall>c\\<in>\\<X>. real (k c) < u c)\n        then return_pmf (l, u \\<oplus> 5 / 10)\n        else if \\<exists>R'.\n                   (l, u) \\<in> S \\<and>\n                   \\<mu> = return_pmf (l, R') \\<and>\n                   R' \\<in> Succ \\<R> ([u]\\<^sub>\\<R>) \\<and>\n                   [u]\\<^sub>\\<R> \\<noteq> R' \\<and>\n                   (\\<forall>u\\<in>R'.\n                       \\<forall>c\\<in>\\<X>.\n                          \\<not> (\\<exists>d\\<le>k c. u c = real d))\n             then return_pmf\n                   (l, delayedR (SOME R'. \\<mu> = return_pmf (l, R')) u)\n             else SOME \\<mu>'.\n                     \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>) =\n    return_pmf (l, u' \\<oplus> 5 / 10)", "by auto"], ["proof (state)\nthis:\n  rept s \\<mu> = return_pmf (l, u' \\<oplus> 5 / 10)\n\ngoal (2 subgoals):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u' c \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u' c) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "from upper_right_closed[OF True] * \\<open>R' \\<in> \\<R>\\<close> T"], ["proof (chain)\npicking this:\n  \\<lbrakk>u' \\<in> ?R; ?R \\<in> \\<R>; 0 \\<le> ?t\\<rbrakk>\n  \\<Longrightarrow> u' \\<oplus> ?t \\<in> ?R\n  s = (l, u') \\<and> u' \\<in> R\n  R' \\<in> \\<R>\n  R = R'", "have \"u' \\<oplus> 0.5 \\<in> R'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>u' \\<in> ?R; ?R \\<in> \\<R>; 0 \\<le> ?t\\<rbrakk>\n  \\<Longrightarrow> u' \\<oplus> ?t \\<in> ?R\n  s = (l, u') \\<and> u' \\<in> R\n  R' \\<in> \\<R>\n  R = R'\n\ngoal (1 subgoal):\n 1. u' \\<oplus> 5 / 10 \\<in> R'", "by auto"], ["proof (state)\nthis:\n  u' \\<oplus> 5 / 10 \\<in> R'\n\ngoal (2 subgoals):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u' c \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u' c) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "with elapsed \\<open>rept _ _ = _\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>u' \\<oplus> ?t5 \\<in> R'; 0 \\<le> ?t5\\<rbrakk>\n  \\<Longrightarrow> abst (return_pmf (l, u' \\<oplus> ?t5)) = \\<mu>\n  \\<lbrakk>u' \\<oplus> ?t5 \\<in> R'; 0 \\<le> ?t5\\<rbrakk>\n  \\<Longrightarrow> return_pmf (l, u' \\<oplus> ?t5) \\<in> K s\n  rept s \\<mu> = return_pmf (l, u' \\<oplus> 5 / 10)\n  u' \\<oplus> 5 / 10 \\<in> R'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>u' \\<oplus> ?t5 \\<in> R'; 0 \\<le> ?t5\\<rbrakk>\n  \\<Longrightarrow> abst (return_pmf (l, u' \\<oplus> ?t5)) = \\<mu>\n  \\<lbrakk>u' \\<oplus> ?t5 \\<in> R'; 0 \\<le> ?t5\\<rbrakk>\n  \\<Longrightarrow> return_pmf (l, u' \\<oplus> ?t5) \\<in> K s\n  rept s \\<mu> = return_pmf (l, u' \\<oplus> 5 / 10)\n  u' \\<oplus> 5 / 10 \\<in> R'\n\ngoal (1 subgoal):\n 1. rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "by auto"], ["proof (state)\nthis:\n  rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u' c) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u' c) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u' c)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u' c) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "with T * R prems(1)"], ["proof (chain)\npicking this:\n  R = R'\n  s = (l, u') \\<and> u' \\<in> R\n  [u']\\<^sub>\\<R> = R\n  \\<mu> = return_pmf (l, R')\n  \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u' c)", "have\n        \"rept s \\<mu> = (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)\""], ["proof (prove)\nusing this:\n  R = R'\n  s = (l, u') \\<and> u' \\<in> R\n  [u']\\<^sub>\\<R> = R\n  \\<mu> = return_pmf (l, R')\n  \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u' c)\n\ngoal (1 subgoal):\n 1. rept s \\<mu> =\n    (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)", "unfolding rept_def"], ["proof (prove)\nusing this:\n  R = R'\n  s = (l, u') \\<and> u' \\<in> R\n  [u']\\<^sub>\\<R> = R\n  \\<mu> = return_pmf (l, R')\n  \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u' c)\n\ngoal (1 subgoal):\n 1. (let (l, u) = s\n     in if \\<exists>R'.\n              (l, u) \\<in> S \\<and>\n              \\<mu> = return_pmf (l, R') \\<and>\n              [u]\\<^sub>\\<R> = R' \\<and>\n              (\\<forall>c\\<in>\\<X>. real (k c) < u c)\n        then return_pmf (l, u \\<oplus> 5 / 10)\n        else if \\<exists>R'.\n                   (l, u) \\<in> S \\<and>\n                   \\<mu> = return_pmf (l, R') \\<and>\n                   R' \\<in> Succ \\<R> ([u]\\<^sub>\\<R>) \\<and>\n                   [u]\\<^sub>\\<R> \\<noteq> R' \\<and>\n                   (\\<forall>u\\<in>R'.\n                       \\<forall>c\\<in>\\<X>.\n                          \\<not> (\\<exists>d\\<le>k c. u c = real d))\n             then return_pmf\n                   (l, delayedR (SOME R'. \\<mu> = return_pmf (l, R')) u)\n             else SOME \\<mu>'.\n                     \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>) =\n    (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)", "by auto"], ["proof (state)\nthis:\n  rept s \\<mu> = (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u' c) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "with default"], ["proof (chain)\npicking this:\n  return_pmf (l, u' \\<oplus> t) \\<in> K s\n  abst (return_pmf (l, u' \\<oplus> t)) = \\<mu>\n  rept s \\<mu> = (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)", "show ?thesis"], ["proof (prove)\nusing this:\n  return_pmf (l, u' \\<oplus> t) \\<in> K s\n  abst (return_pmf (l, u' \\<oplus> t)) = \\<mu>\n  rept s \\<mu> = (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)\n\ngoal (1 subgoal):\n 1. rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "by simp (rule someI; auto)"], ["proof (state)\nthis:\n  rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n\ngoal (1 subgoal):\n 1. R \\<noteq> R' \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. R \\<noteq> R' \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "case F: False"], ["proof (state)\nthis:\n  R \\<noteq> R'\n\ngoal (1 subgoal):\n 1. R \\<noteq> R' \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "proof (cases \"\\<forall> u \\<in> R'. \\<forall> c \\<in> \\<X>. \\<nexists> d. d \\<le> k c \\<and> u c = real d\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>u\\<in>R'.\n       \\<forall>c\\<in>\\<X>.\n          \\<not> (\\<exists>d\\<le>k c. u c = real d) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. \\<not> (\\<forall>u\\<in>R'.\n               \\<forall>c\\<in>\\<X>.\n                  \\<not> (\\<exists>d\\<le>k c.\n                             u c = real d)) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>u\\<in>R'.\n             \\<forall>c\\<in>\\<X>. \\<not> (\\<exists>d\\<le>k c. u c = real d))\n\ngoal (2 subgoals):\n 1. \\<forall>u\\<in>R'.\n       \\<forall>c\\<in>\\<X>.\n          \\<not> (\\<exists>d\\<le>k c. u c = real d) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. \\<not> (\\<forall>u\\<in>R'.\n               \\<forall>c\\<in>\\<X>.\n                  \\<not> (\\<exists>d\\<le>k c.\n                             u c = real d)) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "with F * R prems(1)"], ["proof (chain)\npicking this:\n  R \\<noteq> R'\n  s = (l, u') \\<and> u' \\<in> R\n  [u']\\<^sub>\\<R> = R\n  \\<mu> = return_pmf (l, R')\n  \\<not> (\\<forall>u\\<in>R'.\n             \\<forall>c\\<in>\\<X>. \\<not> (\\<exists>d\\<le>k c. u c = real d))", "have\n        \"rept s \\<mu> = (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)\""], ["proof (prove)\nusing this:\n  R \\<noteq> R'\n  s = (l, u') \\<and> u' \\<in> R\n  [u']\\<^sub>\\<R> = R\n  \\<mu> = return_pmf (l, R')\n  \\<not> (\\<forall>u\\<in>R'.\n             \\<forall>c\\<in>\\<X>. \\<not> (\\<exists>d\\<le>k c. u c = real d))\n\ngoal (1 subgoal):\n 1. rept s \\<mu> =\n    (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)", "unfolding rept_def"], ["proof (prove)\nusing this:\n  R \\<noteq> R'\n  s = (l, u') \\<and> u' \\<in> R\n  [u']\\<^sub>\\<R> = R\n  \\<mu> = return_pmf (l, R')\n  \\<not> (\\<forall>u\\<in>R'.\n             \\<forall>c\\<in>\\<X>. \\<not> (\\<exists>d\\<le>k c. u c = real d))\n\ngoal (1 subgoal):\n 1. (let (l, u) = s\n     in if \\<exists>R'.\n              (l, u) \\<in> S \\<and>\n              \\<mu> = return_pmf (l, R') \\<and>\n              [u]\\<^sub>\\<R> = R' \\<and>\n              (\\<forall>c\\<in>\\<X>. real (k c) < u c)\n        then return_pmf (l, u \\<oplus> 5 / 10)\n        else if \\<exists>R'.\n                   (l, u) \\<in> S \\<and>\n                   \\<mu> = return_pmf (l, R') \\<and>\n                   R' \\<in> Succ \\<R> ([u]\\<^sub>\\<R>) \\<and>\n                   [u]\\<^sub>\\<R> \\<noteq> R' \\<and>\n                   (\\<forall>u\\<in>R'.\n                       \\<forall>c\\<in>\\<X>.\n                          \\<not> (\\<exists>d\\<le>k c. u c = real d))\n             then return_pmf\n                   (l, delayedR (SOME R'. \\<mu> = return_pmf (l, R')) u)\n             else SOME \\<mu>'.\n                     \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>) =\n    (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)", "by auto"], ["proof (state)\nthis:\n  rept s \\<mu> = (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)\n\ngoal (2 subgoals):\n 1. \\<forall>u\\<in>R'.\n       \\<forall>c\\<in>\\<X>.\n          \\<not> (\\<exists>d\\<le>k c. u c = real d) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. \\<not> (\\<forall>u\\<in>R'.\n               \\<forall>c\\<in>\\<X>.\n                  \\<not> (\\<exists>d\\<le>k c.\n                             u c = real d)) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "with default"], ["proof (chain)\npicking this:\n  return_pmf (l, u' \\<oplus> t) \\<in> K s\n  abst (return_pmf (l, u' \\<oplus> t)) = \\<mu>\n  rept s \\<mu> = (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)", "show ?thesis"], ["proof (prove)\nusing this:\n  return_pmf (l, u' \\<oplus> t) \\<in> K s\n  abst (return_pmf (l, u' \\<oplus> t)) = \\<mu>\n  rept s \\<mu> = (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)\n\ngoal (1 subgoal):\n 1. rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "by simp (rule someI; auto)"], ["proof (state)\nthis:\n  rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>R'.\n       \\<forall>c\\<in>\\<X>.\n          \\<not> (\\<exists>d\\<le>k c. u c = real d) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>R'.\n       \\<forall>c\\<in>\\<X>.\n          \\<not> (\\<exists>d\\<le>k c. u c = real d) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "case True"], ["proof (state)\nthis:\n  \\<forall>u\\<in>R'.\n     \\<forall>c\\<in>\\<X>. \\<not> (\\<exists>d\\<le>k c. u c = real d)\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>R'.\n       \\<forall>c\\<in>\\<X>.\n          \\<not> (\\<exists>d\\<le>k c. u c = real d) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "from True F * R prems(1,4) \\<open>s \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>u\\<in>R'.\n     \\<forall>c\\<in>\\<X>. \\<not> (\\<exists>d\\<le>k c. u c = real d)\n  R \\<noteq> R'\n  s = (l, u') \\<and> u' \\<in> R\n  [u']\\<^sub>\\<R> = R\n  \\<mu> = return_pmf (l, R')\n  R' \\<in> Succ \\<R> R\n  s \\<in> S", "have\n        \"rept s \\<mu> = return_pmf (l, delayedR (SOME R'. \\<mu> = return_pmf (l, R')) u')\"\n        (is \"_ = return_pmf (l, delayedR ?R u')\")"], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>R'.\n     \\<forall>c\\<in>\\<X>. \\<not> (\\<exists>d\\<le>k c. u c = real d)\n  R \\<noteq> R'\n  s = (l, u') \\<and> u' \\<in> R\n  [u']\\<^sub>\\<R> = R\n  \\<mu> = return_pmf (l, R')\n  R' \\<in> Succ \\<R> R\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. rept s \\<mu> =\n    return_pmf (l, delayedR (SOME R'. \\<mu> = return_pmf (l, R')) u')", "unfolding rept_def"], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>R'.\n     \\<forall>c\\<in>\\<X>. \\<not> (\\<exists>d\\<le>k c. u c = real d)\n  R \\<noteq> R'\n  s = (l, u') \\<and> u' \\<in> R\n  [u']\\<^sub>\\<R> = R\n  \\<mu> = return_pmf (l, R')\n  R' \\<in> Succ \\<R> R\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. (let (l, u) = s\n     in if \\<exists>R'.\n              (l, u) \\<in> S \\<and>\n              \\<mu> = return_pmf (l, R') \\<and>\n              [u]\\<^sub>\\<R> = R' \\<and>\n              (\\<forall>c\\<in>\\<X>. real (k c) < u c)\n        then return_pmf (l, u \\<oplus> 5 / 10)\n        else if \\<exists>R'.\n                   (l, u) \\<in> S \\<and>\n                   \\<mu> = return_pmf (l, R') \\<and>\n                   R' \\<in> Succ \\<R> ([u]\\<^sub>\\<R>) \\<and>\n                   [u]\\<^sub>\\<R> \\<noteq> R' \\<and>\n                   (\\<forall>u\\<in>R'.\n                       \\<forall>c\\<in>\\<X>.\n                          \\<not> (\\<exists>d\\<le>k c. u c = real d))\n             then return_pmf\n                   (l, delayedR (SOME R'. \\<mu> = return_pmf (l, R')) u)\n             else SOME \\<mu>'.\n                     \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>) =\n    return_pmf (l, delayedR (SOME R'. \\<mu> = return_pmf (l, R')) u')", "by auto"], ["proof (state)\nthis:\n  rept s \\<mu> =\n  return_pmf (l, delayedR (SOME R'. \\<mu> = return_pmf (l, R')) u')\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>R'.\n       \\<forall>c\\<in>\\<X>.\n          \\<not> (\\<exists>d\\<le>k c. u c = real d) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "let ?u = \"delayedR ?R u'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>R'.\n       \\<forall>c\\<in>\\<X>.\n          \\<not> (\\<exists>d\\<le>k c. u c = real d) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "from prems(1)"], ["proof (chain)\npicking this:\n  \\<mu> = return_pmf (l, R')", "have \"\\<mu> = return_pmf (l, ?R)\""], ["proof (prove)\nusing this:\n  \\<mu> = return_pmf (l, R')\n\ngoal (1 subgoal):\n 1. \\<mu> = return_pmf (l, SOME R'. \\<mu> = return_pmf (l, R'))", "by auto"], ["proof (state)\nthis:\n  \\<mu> = return_pmf (l, SOME R'. \\<mu> = return_pmf (l, R'))\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>R'.\n       \\<forall>c\\<in>\\<X>.\n          \\<not> (\\<exists>d\\<le>k c. u c = real d) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "with prems(1)"], ["proof (chain)\npicking this:\n  \\<mu> = return_pmf (l, R')\n  \\<mu> = return_pmf (l, SOME R'. \\<mu> = return_pmf (l, R'))", "have \"?R = R'\""], ["proof (prove)\nusing this:\n  \\<mu> = return_pmf (l, R')\n  \\<mu> = return_pmf (l, SOME R'. \\<mu> = return_pmf (l, R'))\n\ngoal (1 subgoal):\n 1. (SOME R'. \\<mu> = return_pmf (l, R')) = R'", "by auto"], ["proof (state)\nthis:\n  (SOME R'. \\<mu> = return_pmf (l, R')) = R'\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>R'.\n       \\<forall>c\\<in>\\<X>.\n          \\<not> (\\<exists>d\\<le>k c. u c = real d) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "moreover"], ["proof (state)\nthis:\n  (SOME R'. \\<mu> = return_pmf (l, R')) = R'\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>R'.\n       \\<forall>c\\<in>\\<X>.\n          \\<not> (\\<exists>d\\<le>k c. u c = real d) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "from R' True \\<open>_ \\<in> R'\\<close>"], ["proof (chain)\npicking this:\n  R' = Regions.region \\<X> I r\n  Regions.valid_region \\<X> k I r\n  \\<forall>u\\<in>R'.\n     \\<forall>c\\<in>\\<X>. \\<not> (\\<exists>d\\<le>k c. u c = real d)\n  u' \\<oplus> t \\<in> R'", "have \"\\<forall>c\\<in>\\<X>. \\<not> Regions.isConst (I c)\""], ["proof (prove)\nusing this:\n  R' = Regions.region \\<X> I r\n  Regions.valid_region \\<X> k I r\n  \\<forall>u\\<in>R'.\n     \\<forall>c\\<in>\\<X>. \\<not> (\\<exists>d\\<le>k c. u c = real d)\n  u' \\<oplus> t \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>\\<X>. \\<not> Regions.isConst (I c)", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>c\\<in>\\<X>. \\<not> Regions.isConst (I c)\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>R'.\n       \\<forall>c\\<in>\\<X>.\n          \\<not> (\\<exists>d\\<le>k c. u c = real d) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "moreover"], ["proof (state)\nthis:\n  \\<forall>c\\<in>\\<X>. \\<not> Regions.isConst (I c)\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>R'.\n       \\<forall>c\\<in>\\<X>.\n          \\<not> (\\<exists>d\\<le>k c. u c = real d) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "note delayedR_correct[of u' R I r] * \\<open>R \\<in> \\<R>\\<close> R' True \\<open>R' \\<in> Succ \\<R> R\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>u' \\<in> R; R \\<in> \\<R>; Regions.valid_region \\<X> k I r;\n   \\<forall>c\\<in>\\<X>. \\<not> Regions.isConst (I c);\n   Regions.region \\<X> I r \\<in> Succ \\<R> R\\<rbrakk>\n  \\<Longrightarrow> delayedR (Regions.region \\<X> I r) u'\n                    \\<in> Regions.region \\<X> I r\n  \\<lbrakk>u' \\<in> R; R \\<in> \\<R>; Regions.valid_region \\<X> k I r;\n   \\<forall>c\\<in>\\<X>. \\<not> Regions.isConst (I c);\n   Regions.region \\<X> I r \\<in> Succ \\<R> R\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t\\<ge>0.\n                       delayedR (Regions.region \\<X> I r) u' =\n                       u' \\<oplus> t \\<and>\n                       (1 -\n                        Max ({frac (u' c) |c.\n                              c \\<in> \\<X> \\<and>\n                              Regions.isIntv (I c)} \\<union>\n                             {0})) /\n                       2\n                       \\<le> t\n  s = (l, u') \\<and> u' \\<in> R\n  R \\<in> \\<R>\n  R' = Regions.region \\<X> I r\n  Regions.valid_region \\<X> k I r\n  \\<forall>u\\<in>R'.\n     \\<forall>c\\<in>\\<X>. \\<not> (\\<exists>d\\<le>k c. u c = real d)\n  R' \\<in> Succ \\<R> R\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>R'.\n       \\<forall>c\\<in>\\<X>.\n          \\<not> (\\<exists>d\\<le>k c. u c = real d) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "ultimately"], ["proof (chain)\npicking this:\n  (SOME R'. \\<mu> = return_pmf (l, R')) = R'\n  \\<forall>c\\<in>\\<X>. \\<not> Regions.isConst (I c)\n  \\<lbrakk>u' \\<in> R; R \\<in> \\<R>; Regions.valid_region \\<X> k I r;\n   \\<forall>c\\<in>\\<X>. \\<not> Regions.isConst (I c);\n   Regions.region \\<X> I r \\<in> Succ \\<R> R\\<rbrakk>\n  \\<Longrightarrow> delayedR (Regions.region \\<X> I r) u'\n                    \\<in> Regions.region \\<X> I r\n  \\<lbrakk>u' \\<in> R; R \\<in> \\<R>; Regions.valid_region \\<X> k I r;\n   \\<forall>c\\<in>\\<X>. \\<not> Regions.isConst (I c);\n   Regions.region \\<X> I r \\<in> Succ \\<R> R\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t\\<ge>0.\n                       delayedR (Regions.region \\<X> I r) u' =\n                       u' \\<oplus> t \\<and>\n                       (1 -\n                        Max ({frac (u' c) |c.\n                              c \\<in> \\<X> \\<and>\n                              Regions.isIntv (I c)} \\<union>\n                             {0})) /\n                       2\n                       \\<le> t\n  s = (l, u') \\<and> u' \\<in> R\n  R \\<in> \\<R>\n  R' = Regions.region \\<X> I r\n  Regions.valid_region \\<X> k I r\n  \\<forall>u\\<in>R'.\n     \\<forall>c\\<in>\\<X>. \\<not> (\\<exists>d\\<le>k c. u c = real d)\n  R' \\<in> Succ \\<R> R", "obtain t where **: \"delayedR R' u' \\<in> R'\" \"t \\<ge> 0\" \"delayedR R' u' = u' \\<oplus> t\""], ["proof (prove)\nusing this:\n  (SOME R'. \\<mu> = return_pmf (l, R')) = R'\n  \\<forall>c\\<in>\\<X>. \\<not> Regions.isConst (I c)\n  \\<lbrakk>u' \\<in> R; R \\<in> \\<R>; Regions.valid_region \\<X> k I r;\n   \\<forall>c\\<in>\\<X>. \\<not> Regions.isConst (I c);\n   Regions.region \\<X> I r \\<in> Succ \\<R> R\\<rbrakk>\n  \\<Longrightarrow> delayedR (Regions.region \\<X> I r) u'\n                    \\<in> Regions.region \\<X> I r\n  \\<lbrakk>u' \\<in> R; R \\<in> \\<R>; Regions.valid_region \\<X> k I r;\n   \\<forall>c\\<in>\\<X>. \\<not> Regions.isConst (I c);\n   Regions.region \\<X> I r \\<in> Succ \\<R> R\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t\\<ge>0.\n                       delayedR (Regions.region \\<X> I r) u' =\n                       u' \\<oplus> t \\<and>\n                       (1 -\n                        Max ({frac (u' c) |c.\n                              c \\<in> \\<X> \\<and>\n                              Regions.isIntv (I c)} \\<union>\n                             {0})) /\n                       2\n                       \\<le> t\n  s = (l, u') \\<and> u' \\<in> R\n  R \\<in> \\<R>\n  R' = Regions.region \\<X> I r\n  Regions.valid_region \\<X> k I r\n  \\<forall>u\\<in>R'.\n     \\<forall>c\\<in>\\<X>. \\<not> (\\<exists>d\\<le>k c. u c = real d)\n  R' \\<in> Succ \\<R> R\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>delayedR R' u' \\<in> R'; 0 \\<le> t;\n         delayedR R' u' = u' \\<oplus> t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  delayedR R' u' \\<in> R'\n  0 \\<le> t\n  delayedR R' u' = u' \\<oplus> t\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>R'.\n       \\<forall>c\\<in>\\<X>.\n          \\<not> (\\<exists>d\\<le>k c. u c = real d) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "moreover"], ["proof (state)\nthis:\n  delayedR R' u' \\<in> R'\n  0 \\<le> t\n  delayedR R' u' = u' \\<oplus> t\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>R'.\n       \\<forall>c\\<in>\\<X>.\n          \\<not> (\\<exists>d\\<le>k c. u c = real d) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "from \\<open>?R =_ \\<close>\\<open>rept _ _ = _\\<close>"], ["proof (chain)\npicking this:\n  (SOME R'. \\<mu> = return_pmf (l, R')) = R'\n  rept s \\<mu> =\n  return_pmf (l, delayedR (SOME R'. \\<mu> = return_pmf (l, R')) u')", "have \"rept s \\<mu> = return_pmf (l, delayedR R' u')\""], ["proof (prove)\nusing this:\n  (SOME R'. \\<mu> = return_pmf (l, R')) = R'\n  rept s \\<mu> =\n  return_pmf (l, delayedR (SOME R'. \\<mu> = return_pmf (l, R')) u')\n\ngoal (1 subgoal):\n 1. rept s \\<mu> = return_pmf (l, delayedR R' u')", "by auto"], ["proof (state)\nthis:\n  rept s \\<mu> = return_pmf (l, delayedR R' u')\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>R'.\n       \\<forall>c\\<in>\\<X>.\n          \\<not> (\\<exists>d\\<le>k c. u c = real d) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "ultimately"], ["proof (chain)\npicking this:\n  delayedR R' u' \\<in> R'\n  0 \\<le> t\n  delayedR R' u' = u' \\<oplus> t\n  rept s \\<mu> = return_pmf (l, delayedR R' u')", "show ?thesis"], ["proof (prove)\nusing this:\n  delayedR R' u' \\<in> R'\n  0 \\<le> t\n  delayedR R' u' = u' \\<oplus> t\n  rept s \\<mu> = return_pmf (l, delayedR R' u')\n\ngoal (1 subgoal):\n 1. rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "using elapsed"], ["proof (prove)\nusing this:\n  delayedR R' u' \\<in> R'\n  0 \\<le> t\n  delayedR R' u' = u' \\<oplus> t\n  rept s \\<mu> = return_pmf (l, delayedR R' u')\n  \\<lbrakk>u' \\<oplus> ?t5 \\<in> R'; 0 \\<le> ?t5\\<rbrakk>\n  \\<Longrightarrow> abst (return_pmf (l, u' \\<oplus> ?t5)) = \\<mu>\n  \\<lbrakk>u' \\<oplus> ?t5 \\<in> R'; 0 \\<le> ?t5\\<rbrakk>\n  \\<Longrightarrow> return_pmf (l, u' \\<oplus> ?t5) \\<in> K s\n\ngoal (1 subgoal):\n 1. rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "by auto"], ["proof (state)\nthis:\n  rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n\ngoal (2 subgoals):\n 1. \\<And>l R g \\<mu>'.\n       \\<lbrakk>\\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>';\n        abss s \\<in> \\<S>; abss s = (l, R);\n        (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 2. \\<mu> = return_pmf (abss s) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l R g \\<mu>'.\n       \\<lbrakk>\\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>';\n        abss s \\<in> \\<S>; abss s = (l, R);\n        (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 2. \\<mu> = return_pmf (abss s) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "case prems: (action l R \\<tau> \\<mu>')"], ["proof (state)\nthis:\n  \\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>'\n  abss s \\<in> \\<S>\n  abss s = (l, R)\n  (l, \\<tau>, \\<mu>') \\<in> PTA.trans_of A\n  R \\<subseteq> {v. v \\<turnstile> \\<tau>}\n\ngoal (2 subgoals):\n 1. \\<And>l R g \\<mu>'.\n       \\<lbrakk>\\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>';\n        abss s \\<in> \\<S>; abss s = (l, R);\n        (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 2. \\<mu> = return_pmf (abss s) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "from abss_\\<S>D'[OF prems(2,3)]"], ["proof (chain)\npicking this:\n  (\\<And>u.\n      \\<lbrakk>s = (l, u); u \\<in> [u]\\<^sub>\\<R>;\n       [u]\\<^sub>\\<R> \\<in> \\<R>; R = [u]\\<^sub>\\<R>\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain u where u:\n    \"s = (l, u)\" \"u \\<in> [u]\\<^sub>\\<R>\" \"[u]\\<^sub>\\<R> \\<in> \\<R>\" \"R = [u]\\<^sub>\\<R>\""], ["proof (prove)\nusing this:\n  (\\<And>u.\n      \\<lbrakk>s = (l, u); u \\<in> [u]\\<^sub>\\<R>;\n       [u]\\<^sub>\\<R> \\<in> \\<R>; R = [u]\\<^sub>\\<R>\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>s = (l, u); u \\<in> [u]\\<^sub>\\<R>;\n         [u]\\<^sub>\\<R> \\<in> \\<R>; R = [u]\\<^sub>\\<R>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s = (l, u)\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  R = [u]\\<^sub>\\<R>\n\ngoal (2 subgoals):\n 1. \\<And>l R g \\<mu>'.\n       \\<lbrakk>\\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>';\n        abss s \\<in> \\<S>; abss s = (l, R);\n        (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 2. \\<mu> = return_pmf (abss s) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "with \\<open>_ \\<in> \\<S>\\<close>"], ["proof (chain)\npicking this:\n  abss s \\<in> \\<S>\n  s = (l, u)\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  R = [u]\\<^sub>\\<R>", "have \"(l, u) \\<in> S\""], ["proof (prove)\nusing this:\n  abss s \\<in> \\<S>\n  s = (l, u)\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  R = [u]\\<^sub>\\<R>\n\ngoal (1 subgoal):\n 1. (l, u) \\<in> S", "by (auto intro: \\<S>_abss_S)"], ["proof (state)\nthis:\n  (l, u) \\<in> S\n\ngoal (2 subgoals):\n 1. \\<And>l R g \\<mu>'.\n       \\<lbrakk>\\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>';\n        abss s \\<in> \\<S>; abss s = (l, R);\n        (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 2. \\<mu> = return_pmf (abss s) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "let ?\\<mu> = \"map_pmf (\\<lambda>(X, l). (l, [X:=0]u)) \\<mu>'\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l R g \\<mu>'.\n       \\<lbrakk>\\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>';\n        abss s \\<in> \\<S>; abss s = (l, R);\n        (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 2. \\<mu> = return_pmf (abss s) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "from u prems"], ["proof (chain)\npicking this:\n  s = (l, u)\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  R = [u]\\<^sub>\\<R>\n  \\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>'\n  abss s \\<in> \\<S>\n  abss s = (l, R)\n  (l, \\<tau>, \\<mu>') \\<in> PTA.trans_of A\n  R \\<subseteq> {v. v \\<turnstile> \\<tau>}", "have \"?\\<mu> \\<in> K s\""], ["proof (prove)\nusing this:\n  s = (l, u)\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  R = [u]\\<^sub>\\<R>\n  \\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>'\n  abss s \\<in> \\<S>\n  abss s = (l, R)\n  (l, \\<tau>, \\<mu>') \\<in> PTA.trans_of A\n  R \\<subseteq> {v. v \\<turnstile> \\<tau>}\n\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n     \\<mu>'\n    \\<in> K s", "by (fastforce intro: \\<S>_abss_S)"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n   \\<mu>'\n  \\<in> K s\n\ngoal (2 subgoals):\n 1. \\<And>l R g \\<mu>'.\n       \\<lbrakk>\\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>';\n        abss s \\<in> \\<S>; abss s = (l, R);\n        (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 2. \\<mu> = return_pmf (abss s) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "moreover"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n   \\<mu>'\n  \\<in> K s\n\ngoal (2 subgoals):\n 1. \\<And>l R g \\<mu>'.\n       \\<lbrakk>\\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>';\n        abss s \\<in> \\<S>; abss s = (l, R);\n        (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 2. \\<mu> = return_pmf (abss s) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "have \"abst ?\\<mu> = \\<mu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abst\n     (map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n       \\<mu>') =\n    \\<mu>", "unfolding prems(1) abst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf abss\n     (map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n       \\<mu>') =\n    map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>'", "proof (subst map_pmf_comp, rule pmf.map_cong, safe, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set_pmf \\<mu>' \\<Longrightarrow>\n       abss (b, [(SOME r. set r = a)\\<rightarrow>0]u) = (b, [a::=0]R)", "case A: (1 X l')"], ["proof (state)\nthis:\n  (X, l') \\<in> set_pmf \\<mu>'\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set_pmf \\<mu>' \\<Longrightarrow>\n       abss (b, [(SOME r. set r = a)\\<rightarrow>0]u) = (b, [a::=0]R)", "from u"], ["proof (chain)\npicking this:\n  s = (l, u)\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  R = [u]\\<^sub>\\<R>", "have \"u \\<in> V\""], ["proof (prove)\nusing this:\n  s = (l, u)\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  R = [u]\\<^sub>\\<R>\n\ngoal (1 subgoal):\n 1. u \\<in> V", "using \\<R>_V"], ["proof (prove)\nusing this:\n  s = (l, u)\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  R = [u]\\<^sub>\\<R>\n  \\<Union> \\<R> = V\n\ngoal (1 subgoal):\n 1. u \\<in> V", "by auto"], ["proof (state)\nthis:\n  u \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set_pmf \\<mu>' \\<Longrightarrow>\n       abss (b, [(SOME r. set r = a)\\<rightarrow>0]u) = (b, [a::=0]R)", "then"], ["proof (chain)\npicking this:\n  u \\<in> V", "have \"[X:=0]u \\<in> V\""], ["proof (prove)\nusing this:\n  u \\<in> V\n\ngoal (1 subgoal):\n 1. [(SOME r. set r = X)\\<rightarrow>0]u \\<in> V", "by auto"], ["proof (state)\nthis:\n  [(SOME r. set r = X)\\<rightarrow>0]u \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set_pmf \\<mu>' \\<Longrightarrow>\n       abss (b, [(SOME r. set r = a)\\<rightarrow>0]u) = (b, [a::=0]R)", "from prems(1) A"], ["proof (chain)\npicking this:\n  \\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>'\n  (X, l') \\<in> set_pmf \\<mu>'", "have \"(l', region_set' R (SOME r. set r = X) 0) \\<in> \\<mu>\""], ["proof (prove)\nusing this:\n  \\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>'\n  (X, l') \\<in> set_pmf \\<mu>'\n\ngoal (1 subgoal):\n 1. (l', [X::=0]R) \\<in> set_pmf \\<mu>", "by auto"], ["proof (state)\nthis:\n  (l', [X::=0]R) \\<in> set_pmf \\<mu>\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set_pmf \\<mu>' \\<Longrightarrow>\n       abss (b, [(SOME r. set r = a)\\<rightarrow>0]u) = (b, [a::=0]R)", "from A prems R_G.K_closed \\<open>\\<mu> \\<in> _\\<close>"], ["proof (chain)\npicking this:\n  (X, l') \\<in> set_pmf \\<mu>'\n  \\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>'\n  abss s \\<in> \\<S>\n  abss s = (l, R)\n  (l, \\<tau>, \\<mu>') \\<in> PTA.trans_of A\n  R \\<subseteq> {v. v \\<turnstile> \\<tau>}\n  ?s \\<in> \\<S> \\<Longrightarrow>\n  \\<Union> (set_pmf ` \\<K> ?s) \\<subseteq> \\<S>\n  \\<mu> \\<in> \\<K> (abss s)", "have\n        \"l' \\<in> L\" \"region_set' R (SOME r. set r = X) 0 \\<subseteq> \\<lbrace>inv_of A l'\\<rbrace>\""], ["proof (prove)\nusing this:\n  (X, l') \\<in> set_pmf \\<mu>'\n  \\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>'\n  abss s \\<in> \\<S>\n  abss s = (l, R)\n  (l, \\<tau>, \\<mu>') \\<in> PTA.trans_of A\n  R \\<subseteq> {v. v \\<turnstile> \\<tau>}\n  ?s \\<in> \\<S> \\<Longrightarrow>\n  \\<Union> (set_pmf ` \\<K> ?s) \\<subseteq> \\<S>\n  \\<mu> \\<in> \\<K> (abss s)\n\ngoal (1 subgoal):\n 1. l' \\<in> L &&& [X::=0]R \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l'}", "by (force dest: \\<S>_L \\<S>_inv)+"], ["proof (state)\nthis:\n  l' \\<in> L\n  [X::=0]R \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l'}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set_pmf \\<mu>' \\<Longrightarrow>\n       abss (b, [(SOME r. set r = a)\\<rightarrow>0]u) = (b, [a::=0]R)", "with u"], ["proof (chain)\npicking this:\n  s = (l, u)\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  R = [u]\\<^sub>\\<R>\n  l' \\<in> L\n  [X::=0]R \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l'}", "have \"[X:=0]u \\<turnstile> inv_of A l'\""], ["proof (prove)\nusing this:\n  s = (l, u)\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  R = [u]\\<^sub>\\<R>\n  l' \\<in> L\n  [X::=0]R \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l'}\n\ngoal (1 subgoal):\n 1. [(SOME r. set r = X)\\<rightarrow>0]u \\<turnstile> PTA.inv_of A l'", "unfolding region_set'_def"], ["proof (prove)\nusing this:\n  s = (l, u)\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  R = [u]\\<^sub>\\<R>\n  l' \\<in> L\n  {[(SOME r. set r = X)\\<rightarrow>0]v |v. v \\<in> R}\n  \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l'}\n\ngoal (1 subgoal):\n 1. [(SOME r. set r = X)\\<rightarrow>0]u \\<turnstile> PTA.inv_of A l'", "by auto"], ["proof (state)\nthis:\n  [(SOME r. set r = X)\\<rightarrow>0]u \\<turnstile> PTA.inv_of A l'\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set_pmf \\<mu>' \\<Longrightarrow>\n       abss (b, [(SOME r. set r = a)\\<rightarrow>0]u) = (b, [a::=0]R)", "with \\<open>l' \\<in> L\\<close> \\<open>[X:=0]u \\<in> V\\<close>"], ["proof (chain)\npicking this:\n  l' \\<in> L\n  [(SOME r. set r = X)\\<rightarrow>0]u \\<in> V\n  [(SOME r. set r = X)\\<rightarrow>0]u \\<turnstile> PTA.inv_of A l'", "have \"(l', [X:=0]u) \\<in> S\""], ["proof (prove)\nusing this:\n  l' \\<in> L\n  [(SOME r. set r = X)\\<rightarrow>0]u \\<in> V\n  [(SOME r. set r = X)\\<rightarrow>0]u \\<turnstile> PTA.inv_of A l'\n\ngoal (1 subgoal):\n 1. (l', [(SOME r. set r = X)\\<rightarrow>0]u) \\<in> S", "unfolding S_def V_def"], ["proof (prove)\nusing this:\n  l' \\<in> L\n  [(SOME r. set r = X)\\<rightarrow>0]u\n  \\<in> {v. \\<forall>x\\<in>\\<X>. 0 \\<le> v x}\n  [(SOME r. set r = X)\\<rightarrow>0]u \\<turnstile> PTA.inv_of A l'\n\ngoal (1 subgoal):\n 1. (l', [(SOME r. set r = X)\\<rightarrow>0]u)\n    \\<in> {(l, u).\n           l \\<in> L \\<and>\n           (\\<forall>x\\<in>\\<X>. 0 \\<le> u x) \\<and>\n           u \\<turnstile> PTA.inv_of A l}", "by auto"], ["proof (state)\nthis:\n  (l', [(SOME r. set r = X)\\<rightarrow>0]u) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set_pmf \\<mu>' \\<Longrightarrow>\n       abss (b, [(SOME r. set r = a)\\<rightarrow>0]u) = (b, [a::=0]R)", "then"], ["proof (chain)\npicking this:\n  (l', [(SOME r. set r = X)\\<rightarrow>0]u) \\<in> S", "have \"abss (l', [X:=0]u) = (l', [[X:=0]u]\\<^sub>\\<R>)\""], ["proof (prove)\nusing this:\n  (l', [(SOME r. set r = X)\\<rightarrow>0]u) \\<in> S\n\ngoal (1 subgoal):\n 1. abss (l', [(SOME r. set r = X)\\<rightarrow>0]u) =\n    (l', [[(SOME r. set r = X)\\<rightarrow>0]u]\\<^sub>\\<R>)", "by auto"], ["proof (state)\nthis:\n  abss (l', [(SOME r. set r = X)\\<rightarrow>0]u) =\n  (l', [[(SOME r. set r = X)\\<rightarrow>0]u]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set_pmf \\<mu>' \\<Longrightarrow>\n       abss (b, [(SOME r. set r = a)\\<rightarrow>0]u) = (b, [a::=0]R)", "also"], ["proof (state)\nthis:\n  abss (l', [(SOME r. set r = X)\\<rightarrow>0]u) =\n  (l', [[(SOME r. set r = X)\\<rightarrow>0]u]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set_pmf \\<mu>' \\<Longrightarrow>\n       abss (b, [(SOME r. set r = a)\\<rightarrow>0]u) = (b, [a::=0]R)", "have\n       \"\\<dots> = (l', region_set' R (SOME r. set r = X) 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l', [[(SOME r. set r = X)\\<rightarrow>0]u]\\<^sub>\\<R>) = (l', [X::=0]R)", "using region_set'_eq(1)[unfolded transition_def] prems A u"], ["proof (prove)\nusing this:\n  \\<lbrakk>?R \\<in> \\<R>; ?u \\<in> ?R;\n   (?l, ?g, ?\\<mu>) \\<in> PTA.trans_of A \\<and>\n   (?X, ?l') \\<in> set_pmf ?\\<mu>\\<rbrakk>\n  \\<Longrightarrow> [[(SOME r. set r = ?X)\\<rightarrow>0]?u]\\<^sub>\\<R> =\n                    [?X::=0]?R\n  \\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>'\n  abss s \\<in> \\<S>\n  abss s = (l, R)\n  (l, \\<tau>, \\<mu>') \\<in> PTA.trans_of A\n  R \\<subseteq> {v. v \\<turnstile> \\<tau>}\n  (X, l') \\<in> set_pmf \\<mu>'\n  s = (l, u)\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  R = [u]\\<^sub>\\<R>\n\ngoal (1 subgoal):\n 1. (l', [[(SOME r. set r = X)\\<rightarrow>0]u]\\<^sub>\\<R>) = (l', [X::=0]R)", "by force"], ["proof (state)\nthis:\n  (l', [[(SOME r. set r = X)\\<rightarrow>0]u]\\<^sub>\\<R>) = (l', [X::=0]R)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set_pmf \\<mu>' \\<Longrightarrow>\n       abss (b, [(SOME r. set r = a)\\<rightarrow>0]u) = (b, [a::=0]R)", "finally"], ["proof (chain)\npicking this:\n  abss (l', [(SOME r. set r = X)\\<rightarrow>0]u) = (l', [X::=0]R)", "show ?case"], ["proof (prove)\nusing this:\n  abss (l', [(SOME r. set r = X)\\<rightarrow>0]u) = (l', [X::=0]R)\n\ngoal (1 subgoal):\n 1. abss (l', [(SOME r. set r = X)\\<rightarrow>0]u) = (l', [X::=0]R)", "."], ["proof (state)\nthis:\n  abss (l', [(SOME r. set r = X)\\<rightarrow>0]u) = (l', [X::=0]R)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  abst\n   (map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n     \\<mu>') =\n  \\<mu>\n\ngoal (2 subgoals):\n 1. \\<And>l R g \\<mu>'.\n       \\<lbrakk>\\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>';\n        abss s \\<in> \\<S>; abss s = (l, R);\n        (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 2. \\<mu> = return_pmf (abss s) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "ultimately"], ["proof (chain)\npicking this:\n  map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n   \\<mu>'\n  \\<in> K s\n  abst\n   (map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n     \\<mu>') =\n  \\<mu>", "have default: ?thesis if \"rept s \\<mu> = (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)\""], ["proof (prove)\nusing this:\n  map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n   \\<mu>'\n  \\<in> K s\n  abst\n   (map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n     \\<mu>') =\n  \\<mu>\n\ngoal (1 subgoal):\n 1. rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "using that"], ["proof (prove)\nusing this:\n  map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n   \\<mu>'\n  \\<in> K s\n  abst\n   (map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n     \\<mu>') =\n  \\<mu>\n  rept s \\<mu> = (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)\n\ngoal (1 subgoal):\n 1. rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "by simp (rule someI; auto)"], ["proof (state)\nthis:\n  rept s \\<mu> =\n  (SOME \\<mu>'.\n      \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>) \\<Longrightarrow>\n  rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n\ngoal (2 subgoals):\n 1. \\<And>l R g \\<mu>'.\n       \\<lbrakk>\\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>';\n        abss s \\<in> \\<S>; abss s = (l, R);\n        (l, g, \\<mu>') \\<in> PTA.trans_of A;\n        R \\<subseteq> {v. v \\<turnstile> g}\\<rbrakk>\n       \\<Longrightarrow> rept s \\<mu> \\<in> K s \\<and>\n                         abst (rept s \\<mu>) = \\<mu>\n 2. \\<mu> = return_pmf (abss s) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "proof (cases \"\\<exists> R. \\<mu> = return_pmf (l, R)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>R. \\<mu> = return_pmf (l, R) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. \\<nexists>R. \\<mu> = return_pmf (l, R) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "case False"], ["proof (state)\nthis:\n  \\<nexists>R. \\<mu> = return_pmf (l, R)\n\ngoal (2 subgoals):\n 1. \\<exists>R. \\<mu> = return_pmf (l, R) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. \\<nexists>R. \\<mu> = return_pmf (l, R) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "with \\<open>s = (l, u)\\<close>"], ["proof (chain)\npicking this:\n  s = (l, u)\n  \\<nexists>R. \\<mu> = return_pmf (l, R)", "have \"rept s \\<mu> = (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)\""], ["proof (prove)\nusing this:\n  s = (l, u)\n  \\<nexists>R. \\<mu> = return_pmf (l, R)\n\ngoal (1 subgoal):\n 1. rept s \\<mu> =\n    (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)", "unfolding rept_def"], ["proof (prove)\nusing this:\n  s = (l, u)\n  \\<nexists>R. \\<mu> = return_pmf (l, R)\n\ngoal (1 subgoal):\n 1. (let (l, u) = s\n     in if \\<exists>R'.\n              (l, u) \\<in> S \\<and>\n              \\<mu> = return_pmf (l, R') \\<and>\n              [u]\\<^sub>\\<R> = R' \\<and>\n              (\\<forall>c\\<in>\\<X>. real (k c) < u c)\n        then return_pmf (l, u \\<oplus> 5 / 10)\n        else if \\<exists>R'.\n                   (l, u) \\<in> S \\<and>\n                   \\<mu> = return_pmf (l, R') \\<and>\n                   R' \\<in> Succ \\<R> ([u]\\<^sub>\\<R>) \\<and>\n                   [u]\\<^sub>\\<R> \\<noteq> R' \\<and>\n                   (\\<forall>u\\<in>R'.\n                       \\<forall>c\\<in>\\<X>.\n                          \\<not> (\\<exists>d\\<le>k c. u c = real d))\n             then return_pmf\n                   (l, delayedR (SOME R'. \\<mu> = return_pmf (l, R')) u)\n             else SOME \\<mu>'.\n                     \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>) =\n    (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)", "by auto"], ["proof (state)\nthis:\n  rept s \\<mu> = (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)\n\ngoal (2 subgoals):\n 1. \\<exists>R. \\<mu> = return_pmf (l, R) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. \\<nexists>R. \\<mu> = return_pmf (l, R) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "with default"], ["proof (chain)\npicking this:\n  rept s \\<mu> =\n  (SOME \\<mu>'.\n      \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>) \\<Longrightarrow>\n  rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n  rept s \\<mu> = (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)", "show ?thesis"], ["proof (prove)\nusing this:\n  rept s \\<mu> =\n  (SOME \\<mu>'.\n      \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>) \\<Longrightarrow>\n  rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n  rept s \\<mu> = (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)\n\ngoal (1 subgoal):\n 1. rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "by auto"], ["proof (state)\nthis:\n  rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n\ngoal (1 subgoal):\n 1. \\<exists>R. \\<mu> = return_pmf (l, R) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>R. \\<mu> = return_pmf (l, R) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "case True"], ["proof (state)\nthis:\n  \\<exists>R. \\<mu> = return_pmf (l, R)\n\ngoal (1 subgoal):\n 1. \\<exists>R. \\<mu> = return_pmf (l, R) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "then"], ["proof (chain)\npicking this:\n  \\<exists>R. \\<mu> = return_pmf (l, R)", "obtain R' where R': \"\\<mu> = return_pmf (l, R')\""], ["proof (prove)\nusing this:\n  \\<exists>R. \\<mu> = return_pmf (l, R)\n\ngoal (1 subgoal):\n 1. (\\<And>R'.\n        \\<mu> = return_pmf (l, R') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<mu> = return_pmf (l, R')\n\ngoal (1 subgoal):\n 1. \\<exists>R. \\<mu> = return_pmf (l, R) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "proof (cases \"R = R'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. R = R' \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. R \\<noteq> R' \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "case False"], ["proof (state)\nthis:\n  R \\<noteq> R'\n\ngoal (2 subgoals):\n 1. R = R' \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. R \\<noteq> R' \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "from R' prems(1)"], ["proof (chain)\npicking this:\n  \\<mu> = return_pmf (l, R')\n  \\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>'", "have\n        \"\\<forall> (X, l') \\<in> \\<mu>'. (l', region_set' R (SOME r. set r = X) 0) = (l, R')\""], ["proof (prove)\nusing this:\n  \\<mu> = return_pmf (l, R')\n  \\<mu> = map_pmf (\\<lambda>(X, l). (l, [X::=0]R)) \\<mu>'\n\ngoal (1 subgoal):\n 1. \\<forall>(X, l')\\<in>set_pmf \\<mu>'. (l', [X::=0]R) = (l, R')", "by (auto simp: map_pmf_eq_return_pmf_iff[of _ \\<mu>' \"(l, R')\"])"], ["proof (state)\nthis:\n  \\<forall>(X, l')\\<in>set_pmf \\<mu>'. (l', [X::=0]R) = (l, R')\n\ngoal (2 subgoals):\n 1. R = R' \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. R \\<noteq> R' \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "then"], ["proof (chain)\npicking this:\n  \\<forall>(X, l')\\<in>set_pmf \\<mu>'. (l', [X::=0]R) = (l, R')", "obtain X where\n        \"region_set' R (SOME r. set r = X) 0 = R'\" \"(X, l) \\<in> \\<mu>'\""], ["proof (prove)\nusing this:\n  \\<forall>(X, l')\\<in>set_pmf \\<mu>'. (l', [X::=0]R) = (l, R')\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>[X::=0]R = R'; (X, l) \\<in> set_pmf \\<mu>'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using set_pmf_not_empty"], ["proof (prove)\nusing this:\n  \\<forall>(X, l')\\<in>set_pmf \\<mu>'. (l', [X::=0]R) = (l, R')\n  set_pmf ?M \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>[X::=0]R = R'; (X, l) \\<in> set_pmf \\<mu>'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  [X::=0]R = R'\n  (X, l) \\<in> set_pmf \\<mu>'\n\ngoal (2 subgoals):\n 1. R = R' \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. R \\<noteq> R' \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "with prems(4)"], ["proof (chain)\npicking this:\n  (l, \\<tau>, \\<mu>') \\<in> PTA.trans_of A\n  [X::=0]R = R'\n  (X, l) \\<in> set_pmf \\<mu>'", "have \"X \\<subseteq> \\<X>\""], ["proof (prove)\nusing this:\n  (l, \\<tau>, \\<mu>') \\<in> PTA.trans_of A\n  [X::=0]R = R'\n  (X, l) \\<in> set_pmf \\<mu>'\n\ngoal (1 subgoal):\n 1. X \\<subseteq> \\<X>", "by (simp add: admissible_targets_clocks(1))"], ["proof (state)\nthis:\n  X \\<subseteq> \\<X>\n\ngoal (2 subgoals):\n 1. R = R' \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. R \\<noteq> R' \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "moreover"], ["proof (state)\nthis:\n  X \\<subseteq> \\<X>\n\ngoal (2 subgoals):\n 1. R = R' \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. R \\<noteq> R' \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "then"], ["proof (chain)\npicking this:\n  X \\<subseteq> \\<X>", "have\n        \"set (SOME r. set r = X) = X\""], ["proof (prove)\nusing this:\n  X \\<subseteq> \\<X>\n\ngoal (1 subgoal):\n 1. set (SOME r. set r = X) = X", "by - (rule someI_ex, metis finite_list finite(1) finite_subset)"], ["proof (state)\nthis:\n  set (SOME r. set r = X) = X\n\ngoal (2 subgoals):\n 1. R = R' \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. R \\<noteq> R' \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "ultimately"], ["proof (chain)\npicking this:\n  X \\<subseteq> \\<X>\n  set (SOME r. set r = X) = X", "have \"set (SOME r. set r = X) \\<subseteq> \\<X>\""], ["proof (prove)\nusing this:\n  X \\<subseteq> \\<X>\n  set (SOME r. set r = X) = X\n\ngoal (1 subgoal):\n 1. set (SOME r. set r = X) \\<subseteq> \\<X>", "by auto"], ["proof (state)\nthis:\n  set (SOME r. set r = X) \\<subseteq> \\<X>\n\ngoal (2 subgoals):\n 1. R = R' \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. R \\<noteq> R' \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "with alpha_interp.region_reset_not_Succ False \\<open>_ = R'\\<close> u(3,4)"], ["proof (chain)\npicking this:\n  \\<lbrakk>?R \\<in> \\<R>; set ?r \\<subseteq> \\<X>\\<rbrakk>\n  \\<Longrightarrow> region_set' ?R ?r 0 = ?R \\<or>\n                    region_set' ?R ?r 0 \\<notin> Succ \\<R> ?R\n  R \\<noteq> R'\n  [X::=0]R = R'\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  R = [u]\\<^sub>\\<R>\n  set (SOME r. set r = X) \\<subseteq> \\<X>", "have \"R' \\<notin> Succ \\<R> R\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?R \\<in> \\<R>; set ?r \\<subseteq> \\<X>\\<rbrakk>\n  \\<Longrightarrow> region_set' ?R ?r 0 = ?R \\<or>\n                    region_set' ?R ?r 0 \\<notin> Succ \\<R> ?R\n  R \\<noteq> R'\n  [X::=0]R = R'\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  R = [u]\\<^sub>\\<R>\n  set (SOME r. set r = X) \\<subseteq> \\<X>\n\ngoal (1 subgoal):\n 1. R' \\<notin> Succ \\<R> R", "by auto"], ["proof (state)\nthis:\n  R' \\<notin> Succ \\<R> R\n\ngoal (2 subgoals):\n 1. R = R' \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. R \\<noteq> R' \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "with \\<open>s = (l, u)\\<close> R' u(4) False"], ["proof (chain)\npicking this:\n  s = (l, u)\n  \\<mu> = return_pmf (l, R')\n  R = [u]\\<^sub>\\<R>\n  R \\<noteq> R'\n  R' \\<notin> Succ \\<R> R", "have\n        \"rept s \\<mu> = (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)\""], ["proof (prove)\nusing this:\n  s = (l, u)\n  \\<mu> = return_pmf (l, R')\n  R = [u]\\<^sub>\\<R>\n  R \\<noteq> R'\n  R' \\<notin> Succ \\<R> R\n\ngoal (1 subgoal):\n 1. rept s \\<mu> =\n    (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)", "unfolding rept_def"], ["proof (prove)\nusing this:\n  s = (l, u)\n  \\<mu> = return_pmf (l, R')\n  R = [u]\\<^sub>\\<R>\n  R \\<noteq> R'\n  R' \\<notin> Succ \\<R> R\n\ngoal (1 subgoal):\n 1. (let (l, u) = s\n     in if \\<exists>R'.\n              (l, u) \\<in> S \\<and>\n              \\<mu> = return_pmf (l, R') \\<and>\n              [u]\\<^sub>\\<R> = R' \\<and>\n              (\\<forall>c\\<in>\\<X>. real (k c) < u c)\n        then return_pmf (l, u \\<oplus> 5 / 10)\n        else if \\<exists>R'.\n                   (l, u) \\<in> S \\<and>\n                   \\<mu> = return_pmf (l, R') \\<and>\n                   R' \\<in> Succ \\<R> ([u]\\<^sub>\\<R>) \\<and>\n                   [u]\\<^sub>\\<R> \\<noteq> R' \\<and>\n                   (\\<forall>u\\<in>R'.\n                       \\<forall>c\\<in>\\<X>.\n                          \\<not> (\\<exists>d\\<le>k c. u c = real d))\n             then return_pmf\n                   (l, delayedR (SOME R'. \\<mu> = return_pmf (l, R')) u)\n             else SOME \\<mu>'.\n                     \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>) =\n    (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)", "by auto"], ["proof (state)\nthis:\n  rept s \\<mu> = (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)\n\ngoal (2 subgoals):\n 1. R = R' \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. R \\<noteq> R' \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "with default"], ["proof (chain)\npicking this:\n  rept s \\<mu> =\n  (SOME \\<mu>'.\n      \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>) \\<Longrightarrow>\n  rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n  rept s \\<mu> = (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)", "show ?thesis"], ["proof (prove)\nusing this:\n  rept s \\<mu> =\n  (SOME \\<mu>'.\n      \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>) \\<Longrightarrow>\n  rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n  rept s \\<mu> = (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)\n\ngoal (1 subgoal):\n 1. rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "by auto"], ["proof (state)\nthis:\n  rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n\ngoal (1 subgoal):\n 1. R = R' \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. R = R' \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "case T: True"], ["proof (state)\nthis:\n  R = R'\n\ngoal (1 subgoal):\n 1. R = R' \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "proof (cases \"\\<forall>c\\<in>\\<X>. real (k c) < u c\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u c \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c)\n\ngoal (2 subgoals):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u c \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "with T \\<open>s = (l, u)\\<close> R' u(4)"], ["proof (chain)\npicking this:\n  R = R'\n  s = (l, u)\n  \\<mu> = return_pmf (l, R')\n  R = [u]\\<^sub>\\<R>\n  \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c)", "have\n          \"rept s \\<mu> = (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)\""], ["proof (prove)\nusing this:\n  R = R'\n  s = (l, u)\n  \\<mu> = return_pmf (l, R')\n  R = [u]\\<^sub>\\<R>\n  \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c)\n\ngoal (1 subgoal):\n 1. rept s \\<mu> =\n    (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)", "unfolding rept_def"], ["proof (prove)\nusing this:\n  R = R'\n  s = (l, u)\n  \\<mu> = return_pmf (l, R')\n  R = [u]\\<^sub>\\<R>\n  \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c)\n\ngoal (1 subgoal):\n 1. (let (l, u) = s\n     in if \\<exists>R'.\n              (l, u) \\<in> S \\<and>\n              \\<mu> = return_pmf (l, R') \\<and>\n              [u]\\<^sub>\\<R> = R' \\<and>\n              (\\<forall>c\\<in>\\<X>. real (k c) < u c)\n        then return_pmf (l, u \\<oplus> 5 / 10)\n        else if \\<exists>R'.\n                   (l, u) \\<in> S \\<and>\n                   \\<mu> = return_pmf (l, R') \\<and>\n                   R' \\<in> Succ \\<R> ([u]\\<^sub>\\<R>) \\<and>\n                   [u]\\<^sub>\\<R> \\<noteq> R' \\<and>\n                   (\\<forall>u\\<in>R'.\n                       \\<forall>c\\<in>\\<X>.\n                          \\<not> (\\<exists>d\\<le>k c. u c = real d))\n             then return_pmf\n                   (l, delayedR (SOME R'. \\<mu> = return_pmf (l, R')) u)\n             else SOME \\<mu>'.\n                     \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>) =\n    (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)", "by auto"], ["proof (state)\nthis:\n  rept s \\<mu> = (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)\n\ngoal (2 subgoals):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u c \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "with default"], ["proof (chain)\npicking this:\n  rept s \\<mu> =\n  (SOME \\<mu>'.\n      \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>) \\<Longrightarrow>\n  rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n  rept s \\<mu> = (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)", "show ?thesis"], ["proof (prove)\nusing this:\n  rept s \\<mu> =\n  (SOME \\<mu>'.\n      \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>) \\<Longrightarrow>\n  rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n  rept s \\<mu> = (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)\n\ngoal (1 subgoal):\n 1. rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "by auto"], ["proof (state)\nthis:\n  rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u c \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u c \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "case True"], ["proof (state)\nthis:\n  \\<forall>c\\<in>\\<X>. real (k c) < u c\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u c \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "with T \\<open>s = (l, u)\\<close> R' u(4) \\<open>(l, u) \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  R = R'\n  s = (l, u)\n  \\<mu> = return_pmf (l, R')\n  R = [u]\\<^sub>\\<R>\n  (l, u) \\<in> S\n  \\<forall>c\\<in>\\<X>. real (k c) < u c", "have\n          \"rept s \\<mu> = return_pmf (l, u \\<oplus> 0.5)\""], ["proof (prove)\nusing this:\n  R = R'\n  s = (l, u)\n  \\<mu> = return_pmf (l, R')\n  R = [u]\\<^sub>\\<R>\n  (l, u) \\<in> S\n  \\<forall>c\\<in>\\<X>. real (k c) < u c\n\ngoal (1 subgoal):\n 1. rept s \\<mu> = return_pmf (l, u \\<oplus> 5 / 10)", "unfolding rept_def"], ["proof (prove)\nusing this:\n  R = R'\n  s = (l, u)\n  \\<mu> = return_pmf (l, R')\n  R = [u]\\<^sub>\\<R>\n  (l, u) \\<in> S\n  \\<forall>c\\<in>\\<X>. real (k c) < u c\n\ngoal (1 subgoal):\n 1. (let (l, u) = s\n     in if \\<exists>R'.\n              (l, u) \\<in> S \\<and>\n              \\<mu> = return_pmf (l, R') \\<and>\n              [u]\\<^sub>\\<R> = R' \\<and>\n              (\\<forall>c\\<in>\\<X>. real (k c) < u c)\n        then return_pmf (l, u \\<oplus> 5 / 10)\n        else if \\<exists>R'.\n                   (l, u) \\<in> S \\<and>\n                   \\<mu> = return_pmf (l, R') \\<and>\n                   R' \\<in> Succ \\<R> ([u]\\<^sub>\\<R>) \\<and>\n                   [u]\\<^sub>\\<R> \\<noteq> R' \\<and>\n                   (\\<forall>u\\<in>R'.\n                       \\<forall>c\\<in>\\<X>.\n                          \\<not> (\\<exists>d\\<le>k c. u c = real d))\n             then return_pmf\n                   (l, delayedR (SOME R'. \\<mu> = return_pmf (l, R')) u)\n             else SOME \\<mu>'.\n                     \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>) =\n    return_pmf (l, u \\<oplus> 5 / 10)", "by auto"], ["proof (state)\nthis:\n  rept s \\<mu> = return_pmf (l, u \\<oplus> 5 / 10)\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u c \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "from upper_right_closed[OF True] T u \\<R>_V"], ["proof (chain)\npicking this:\n  \\<lbrakk>u \\<in> ?R; ?R \\<in> \\<R>; 0 \\<le> ?t\\<rbrakk>\n  \\<Longrightarrow> u \\<oplus> ?t \\<in> ?R\n  R = R'\n  s = (l, u)\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  R = [u]\\<^sub>\\<R>\n  \\<Union> \\<R> = V", "have \"u \\<oplus> 0.5 \\<in> R'\" \"u \\<oplus> 0.5 \\<in> V\""], ["proof (prove)\nusing this:\n  \\<lbrakk>u \\<in> ?R; ?R \\<in> \\<R>; 0 \\<le> ?t\\<rbrakk>\n  \\<Longrightarrow> u \\<oplus> ?t \\<in> ?R\n  R = R'\n  s = (l, u)\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  R = [u]\\<^sub>\\<R>\n  \\<Union> \\<R> = V\n\ngoal (1 subgoal):\n 1. u \\<oplus> 5 / 10 \\<in> R' &&& u \\<oplus> 5 / 10 \\<in> V", "by force+"], ["proof (state)\nthis:\n  u \\<oplus> 5 / 10 \\<in> R'\n  u \\<oplus> 5 / 10 \\<in> V\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u c \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "moreover"], ["proof (state)\nthis:\n  u \\<oplus> 5 / 10 \\<in> R'\n  u \\<oplus> 5 / 10 \\<in> V\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u c \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "then"], ["proof (chain)\npicking this:\n  u \\<oplus> 5 / 10 \\<in> R'\n  u \\<oplus> 5 / 10 \\<in> V", "have \"[u \\<oplus> 0.5]\\<^sub>\\<R> = R'\""], ["proof (prove)\nusing this:\n  u \\<oplus> 5 / 10 \\<in> R'\n  u \\<oplus> 5 / 10 \\<in> V\n\ngoal (1 subgoal):\n 1. [u \\<oplus> 5 / 10]\\<^sub>\\<R> = R'", "using T alpha_interp.region_unique_spec u(3,4)"], ["proof (prove)\nusing this:\n  u \\<oplus> 5 / 10 \\<in> R'\n  u \\<oplus> 5 / 10 \\<in> V\n  R = R'\n  \\<lbrakk>?u \\<in> ?R; ?R \\<in> \\<R>\\<rbrakk>\n  \\<Longrightarrow> [?u]\\<^sub>\\<R> = ?R\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  R = [u]\\<^sub>\\<R>\n\ngoal (1 subgoal):\n 1. [u \\<oplus> 5 / 10]\\<^sub>\\<R> = R'", "by blast"], ["proof (state)\nthis:\n  [u \\<oplus> 5 / 10]\\<^sub>\\<R> = R'\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u c \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "moreover"], ["proof (state)\nthis:\n  [u \\<oplus> 5 / 10]\\<^sub>\\<R> = R'\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u c \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "note * = \\<open>rept _ _ = _\\<close> R' \\<open>abss s \\<in> \\<S>\\<close> \\<open>abss s = _\\<close> prems(5)"], ["proof (state)\nthis:\n  rept s \\<mu> = return_pmf (l, u \\<oplus> 5 / 10)\n  \\<mu> = return_pmf (l, R')\n  abss s \\<in> \\<S>\n  abss s = (l, R)\n  R \\<subseteq> {v. v \\<turnstile> \\<tau>}\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u c \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "ultimately"], ["proof (chain)\npicking this:\n  u \\<oplus> 5 / 10 \\<in> R'\n  u \\<oplus> 5 / 10 \\<in> V\n  [u \\<oplus> 5 / 10]\\<^sub>\\<R> = R'\n  rept s \\<mu> = return_pmf (l, u \\<oplus> 5 / 10)\n  \\<mu> = return_pmf (l, R')\n  abss s \\<in> \\<S>\n  abss s = (l, R)\n  R \\<subseteq> {v. v \\<turnstile> \\<tau>}", "have \"abst (rept s \\<mu>) = \\<mu>\""], ["proof (prove)\nusing this:\n  u \\<oplus> 5 / 10 \\<in> R'\n  u \\<oplus> 5 / 10 \\<in> V\n  [u \\<oplus> 5 / 10]\\<^sub>\\<R> = R'\n  rept s \\<mu> = return_pmf (l, u \\<oplus> 5 / 10)\n  \\<mu> = return_pmf (l, R')\n  abss s \\<in> \\<S>\n  abss s = (l, R)\n  R \\<subseteq> {v. v \\<turnstile> \\<tau>}\n\ngoal (1 subgoal):\n 1. abst (rept s \\<mu>) = \\<mu>", "apply (simp add: abst_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<oplus> 1 / 2 \\<in> R'; u \\<oplus> 1 / 2 \\<in> V;\n     [u \\<oplus> 1 / 2]\\<^sub>\\<R> = R';\n     rept s (return_pmf (l, R')) = return_pmf (l, u \\<oplus> 1 / 2);\n     \\<mu> = return_pmf (l, R'); (l, R) \\<in> \\<S>; abss s = (l, R);\n     R \\<subseteq> {v. v \\<turnstile> \\<tau>}\\<rbrakk>\n    \\<Longrightarrow> abss (l, u \\<oplus> 1 / 2) = (l, R')", "apply (subst abss_S)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>u \\<oplus> 1 / 2 \\<in> R'; u \\<oplus> 1 / 2 \\<in> V;\n     [u \\<oplus> 1 / 2]\\<^sub>\\<R> = R';\n     rept s (return_pmf (l, R')) = return_pmf (l, u \\<oplus> 1 / 2);\n     \\<mu> = return_pmf (l, R'); (l, R) \\<in> \\<S>; abss s = (l, R);\n     R \\<subseteq> {v. v \\<turnstile> \\<tau>}\\<rbrakk>\n    \\<Longrightarrow> (l, u \\<oplus> 1 / 2) \\<in> S\n 2. \\<lbrakk>u \\<oplus> 1 / 2 \\<in> R'; u \\<oplus> 1 / 2 \\<in> V;\n     [u \\<oplus> 1 / 2]\\<^sub>\\<R> = R';\n     rept s (return_pmf (l, R')) = return_pmf (l, u \\<oplus> 1 / 2);\n     \\<mu> = return_pmf (l, R'); (l, R) \\<in> \\<S>; abss s = (l, R);\n     R \\<subseteq> {v. v \\<turnstile> \\<tau>}\\<rbrakk>\n    \\<Longrightarrow> (l, [u \\<oplus> 1 / 2]\\<^sub>\\<R>) = (l, R')", "by (auto simp: \\<S>_L S_def V_def T dest: \\<S>_inv)"], ["proof (state)\nthis:\n  abst (rept s \\<mu>) = \\<mu>\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u c \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "moreover"], ["proof (state)\nthis:\n  abst (rept s \\<mu>) = \\<mu>\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u c \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "from * \\<open>s = _\\<close> \\<open>(l, u) \\<in> S\\<close> \\<open>_ \\<in> R'\\<close>"], ["proof (chain)\npicking this:\n  rept s \\<mu> = return_pmf (l, u \\<oplus> 5 / 10)\n  \\<mu> = return_pmf (l, R')\n  abss s \\<in> \\<S>\n  abss s = (l, R)\n  R \\<subseteq> {v. v \\<turnstile> \\<tau>}\n  s = (l, u)\n  (l, u) \\<in> S\n  u \\<oplus> 5 / 10 \\<in> R'", "have\n          \"rept s \\<mu> \\<in> K s\""], ["proof (prove)\nusing this:\n  rept s \\<mu> = return_pmf (l, u \\<oplus> 5 / 10)\n  \\<mu> = return_pmf (l, R')\n  abss s \\<in> \\<S>\n  abss s = (l, R)\n  R \\<subseteq> {v. v \\<turnstile> \\<tau>}\n  s = (l, u)\n  (l, u) \\<in> S\n  u \\<oplus> 5 / 10 \\<in> R'\n\ngoal (1 subgoal):\n 1. rept s \\<mu> \\<in> K s", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rept (l, u) (return_pmf (l, R')) =\n             return_pmf (l, u \\<oplus> 1 / 2);\n     \\<mu> = return_pmf (l, R'); (l, R) \\<in> \\<S>; abss (l, u) = (l, R);\n     R \\<subseteq> {v. v \\<turnstile> \\<tau>}; s = (l, u); (l, u) \\<in> S;\n     u \\<oplus> 1 / 2 \\<in> R'\\<rbrakk>\n    \\<Longrightarrow> return_pmf (l, u \\<oplus> 1 / 2) \\<in> K (l, u)", "apply (rule K.delay)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>rept (l, u) (return_pmf (l, R')) =\n             return_pmf (l, u \\<oplus> 1 / 2);\n     \\<mu> = return_pmf (l, R'); (l, R) \\<in> \\<S>; abss (l, u) = (l, R);\n     R \\<subseteq> {v. v \\<turnstile> \\<tau>}; s = (l, u); (l, u) \\<in> S;\n     u \\<oplus> 1 / 2 \\<in> R'\\<rbrakk>\n    \\<Longrightarrow> (l, u) \\<in> S\n 2. \\<lbrakk>rept (l, u) (return_pmf (l, R')) =\n             return_pmf (l, u \\<oplus> 1 / 2);\n     \\<mu> = return_pmf (l, R'); (l, R) \\<in> \\<S>; abss (l, u) = (l, R);\n     R \\<subseteq> {v. v \\<turnstile> \\<tau>}; s = (l, u); (l, u) \\<in> S;\n     u \\<oplus> 1 / 2 \\<in> R'\\<rbrakk>\n    \\<Longrightarrow> (l, u) = (l, u)\n 3. \\<lbrakk>rept (l, u) (return_pmf (l, R')) =\n             return_pmf (l, u \\<oplus> 1 / 2);\n     \\<mu> = return_pmf (l, R'); (l, R) \\<in> \\<S>; abss (l, u) = (l, R);\n     R \\<subseteq> {v. v \\<turnstile> \\<tau>}; s = (l, u); (l, u) \\<in> S;\n     u \\<oplus> 1 / 2 \\<in> R'\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> 1 / 2\n 4. \\<lbrakk>rept (l, u) (return_pmf (l, R')) =\n             return_pmf (l, u \\<oplus> 1 / 2);\n     \\<mu> = return_pmf (l, R'); (l, R) \\<in> \\<S>; abss (l, u) = (l, R);\n     R \\<subseteq> {v. v \\<turnstile> \\<tau>}; s = (l, u); (l, u) \\<in> S;\n     u \\<oplus> 1 / 2 \\<in> R'\\<rbrakk>\n    \\<Longrightarrow> u \\<oplus> 1 / 2 \\<turnstile> PTA.inv_of A l", "by (auto simp: T dest: \\<S>_inv)"], ["proof (state)\nthis:\n  rept s \\<mu> \\<in> K s\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u c \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "ultimately"], ["proof (chain)\npicking this:\n  abst (rept s \\<mu>) = \\<mu>\n  rept s \\<mu> \\<in> K s", "show ?thesis"], ["proof (prove)\nusing this:\n  abst (rept s \\<mu>) = \\<mu>\n  rept s \\<mu> \\<in> K s\n\ngoal (1 subgoal):\n 1. rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "by auto"], ["proof (state)\nthis:\n  rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n\ngoal (1 subgoal):\n 1. \\<mu> = return_pmf (abss s) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<mu> = return_pmf (abss s) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "case loop"], ["proof (state)\nthis:\n  \\<mu> = return_pmf (abss s)\n\ngoal (1 subgoal):\n 1. \\<mu> = return_pmf (abss s) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "obtain l u where \"s = (l, u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l u. s = (l, u) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  s = (l, u)\n\ngoal (1 subgoal):\n 1. \\<mu> = return_pmf (abss s) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "proof (cases \"s \\<in> S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. s \\<in> S \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. s \\<notin> S \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "case T: True"], ["proof (state)\nthis:\n  s \\<in> S\n\ngoal (2 subgoals):\n 1. s \\<in> S \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. s \\<notin> S \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "with \\<open>s = _\\<close>"], ["proof (chain)\npicking this:\n  s = (l, u)\n  s \\<in> S", "have *: \"l \\<in> L\" \"u \\<in> [u]\\<^sub>\\<R>\" \"[u]\\<^sub>\\<R> \\<in> \\<R>\" \"abss s = (l, [u]\\<^sub>\\<R>)\""], ["proof (prove)\nusing this:\n  s = (l, u)\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. (l \\<in> L &&& u \\<in> [u]\\<^sub>\\<R>) &&&\n    [u]\\<^sub>\\<R> \\<in> \\<R> &&& abss s = (l, [u]\\<^sub>\\<R>)", "by auto"], ["proof (state)\nthis:\n  l \\<in> L\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  abss s = (l, [u]\\<^sub>\\<R>)\n\ngoal (2 subgoals):\n 1. s \\<in> S \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. s \\<notin> S \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "then"], ["proof (chain)\npicking this:\n  l \\<in> L\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  abss s = (l, [u]\\<^sub>\\<R>)", "have \"abss s = (l, [u]\\<^sub>\\<R>)\""], ["proof (prove)\nusing this:\n  l \\<in> L\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  abss s = (l, [u]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. abss s = (l, [u]\\<^sub>\\<R>)", "by auto"], ["proof (state)\nthis:\n  abss s = (l, [u]\\<^sub>\\<R>)\n\ngoal (2 subgoals):\n 1. s \\<in> S \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. s \\<notin> S \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "with \\<open>s \\<in> S\\<close> S_abss_\\<S>"], ["proof (chain)\npicking this:\n  s \\<in> S\n  ?s \\<in> S \\<Longrightarrow> abss ?s \\<in> \\<S>\n  abss s = (l, [u]\\<^sub>\\<R>)", "have \"(l, [u]\\<^sub>\\<R>) \\<in> \\<S>\""], ["proof (prove)\nusing this:\n  s \\<in> S\n  ?s \\<in> S \\<Longrightarrow> abss ?s \\<in> \\<S>\n  abss s = (l, [u]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. (l, [u]\\<^sub>\\<R>) \\<in> \\<S>", "by auto"], ["proof (state)\nthis:\n  (l, [u]\\<^sub>\\<R>) \\<in> \\<S>\n\ngoal (2 subgoals):\n 1. s \\<in> S \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. s \\<notin> S \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "with \\<S>_inv"], ["proof (chain)\npicking this:\n  (?l, ?R) \\<in> \\<S> \\<Longrightarrow>\n  ?R \\<subseteq> {v. v \\<turnstile> PTA.inv_of A ?l}\n  (l, [u]\\<^sub>\\<R>) \\<in> \\<S>", "have \"[u]\\<^sub>\\<R> \\<subseteq> {u. u \\<turnstile> inv_of A l}\""], ["proof (prove)\nusing this:\n  (?l, ?R) \\<in> \\<S> \\<Longrightarrow>\n  ?R \\<subseteq> {v. v \\<turnstile> PTA.inv_of A ?l}\n  (l, [u]\\<^sub>\\<R>) \\<in> \\<S>\n\ngoal (1 subgoal):\n 1. [u]\\<^sub>\\<R> \\<subseteq> {u. u \\<turnstile> PTA.inv_of A l}", "by auto"], ["proof (state)\nthis:\n  [u]\\<^sub>\\<R> \\<subseteq> {u. u \\<turnstile> PTA.inv_of A l}\n\ngoal (2 subgoals):\n 1. s \\<in> S \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. s \\<notin> S \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "proof (cases \"\\<forall>c\\<in>\\<X>. real (k c) < u c\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u c \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "case True"], ["proof (state)\nthis:\n  \\<forall>c\\<in>\\<X>. real (k c) < u c\n\ngoal (2 subgoals):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u c \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "with * \\<open>\\<mu> = _\\<close> \\<open>s = _\\<close> \\<open>s \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  l \\<in> L\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  abss s = (l, [u]\\<^sub>\\<R>)\n  \\<mu> = return_pmf (abss s)\n  s = (l, u)\n  s \\<in> S\n  \\<forall>c\\<in>\\<X>. real (k c) < u c", "have\n        \"rept s \\<mu> = return_pmf (l, u \\<oplus> 0.5)\""], ["proof (prove)\nusing this:\n  l \\<in> L\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  abss s = (l, [u]\\<^sub>\\<R>)\n  \\<mu> = return_pmf (abss s)\n  s = (l, u)\n  s \\<in> S\n  \\<forall>c\\<in>\\<X>. real (k c) < u c\n\ngoal (1 subgoal):\n 1. rept s \\<mu> = return_pmf (l, u \\<oplus> 5 / 10)", "unfolding rept_def"], ["proof (prove)\nusing this:\n  l \\<in> L\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  abss s = (l, [u]\\<^sub>\\<R>)\n  \\<mu> = return_pmf (abss s)\n  s = (l, u)\n  s \\<in> S\n  \\<forall>c\\<in>\\<X>. real (k c) < u c\n\ngoal (1 subgoal):\n 1. (let (l, u) = s\n     in if \\<exists>R'.\n              (l, u) \\<in> S \\<and>\n              \\<mu> = return_pmf (l, R') \\<and>\n              [u]\\<^sub>\\<R> = R' \\<and>\n              (\\<forall>c\\<in>\\<X>. real (k c) < u c)\n        then return_pmf (l, u \\<oplus> 5 / 10)\n        else if \\<exists>R'.\n                   (l, u) \\<in> S \\<and>\n                   \\<mu> = return_pmf (l, R') \\<and>\n                   R' \\<in> Succ \\<R> ([u]\\<^sub>\\<R>) \\<and>\n                   [u]\\<^sub>\\<R> \\<noteq> R' \\<and>\n                   (\\<forall>u\\<in>R'.\n                       \\<forall>c\\<in>\\<X>.\n                          \\<not> (\\<exists>d\\<le>k c. u c = real d))\n             then return_pmf\n                   (l, delayedR (SOME R'. \\<mu> = return_pmf (l, R')) u)\n             else SOME \\<mu>'.\n                     \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>) =\n    return_pmf (l, u \\<oplus> 5 / 10)", "by auto"], ["proof (state)\nthis:\n  rept s \\<mu> = return_pmf (l, u \\<oplus> 5 / 10)\n\ngoal (2 subgoals):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u c \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "from upper_right_closed[OF True] *"], ["proof (chain)\npicking this:\n  \\<lbrakk>u \\<in> ?R; ?R \\<in> \\<R>; 0 \\<le> ?t\\<rbrakk>\n  \\<Longrightarrow> u \\<oplus> ?t \\<in> ?R\n  l \\<in> L\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  abss s = (l, [u]\\<^sub>\\<R>)", "have \"u \\<oplus> 0.5 \\<in> [u]\\<^sub>\\<R>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>u \\<in> ?R; ?R \\<in> \\<R>; 0 \\<le> ?t\\<rbrakk>\n  \\<Longrightarrow> u \\<oplus> ?t \\<in> ?R\n  l \\<in> L\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  abss s = (l, [u]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. u \\<oplus> 5 / 10 \\<in> [u]\\<^sub>\\<R>", "by auto"], ["proof (state)\nthis:\n  u \\<oplus> 5 / 10 \\<in> [u]\\<^sub>\\<R>\n\ngoal (2 subgoals):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u c \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "moreover"], ["proof (state)\nthis:\n  u \\<oplus> 5 / 10 \\<in> [u]\\<^sub>\\<R>\n\ngoal (2 subgoals):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u c \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "with * \\<R>_V"], ["proof (chain)\npicking this:\n  l \\<in> L\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  abss s = (l, [u]\\<^sub>\\<R>)\n  \\<Union> \\<R> = V\n  u \\<oplus> 5 / 10 \\<in> [u]\\<^sub>\\<R>", "have \"u \\<oplus> 0.5 \\<in> V\""], ["proof (prove)\nusing this:\n  l \\<in> L\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  abss s = (l, [u]\\<^sub>\\<R>)\n  \\<Union> \\<R> = V\n  u \\<oplus> 5 / 10 \\<in> [u]\\<^sub>\\<R>\n\ngoal (1 subgoal):\n 1. u \\<oplus> 5 / 10 \\<in> V", "by auto"], ["proof (state)\nthis:\n  u \\<oplus> 5 / 10 \\<in> V\n\ngoal (2 subgoals):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u c \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "moreover"], ["proof (state)\nthis:\n  u \\<oplus> 5 / 10 \\<in> V\n\ngoal (2 subgoals):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u c \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "with calculation * alpha_interp.region_unique_spec"], ["proof (chain)\npicking this:\n  u \\<oplus> 5 / 10 \\<in> [u]\\<^sub>\\<R>\n  u \\<oplus> 5 / 10 \\<in> V\n  l \\<in> L\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  abss s = (l, [u]\\<^sub>\\<R>)\n  \\<lbrakk>?u \\<in> ?R; ?R \\<in> \\<R>\\<rbrakk>\n  \\<Longrightarrow> [?u]\\<^sub>\\<R> = ?R\n  u \\<oplus> 5 / 10 \\<in> V", "have \"[u \\<oplus> 0.5]\\<^sub>\\<R> = [u]\\<^sub>\\<R>\""], ["proof (prove)\nusing this:\n  u \\<oplus> 5 / 10 \\<in> [u]\\<^sub>\\<R>\n  u \\<oplus> 5 / 10 \\<in> V\n  l \\<in> L\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  abss s = (l, [u]\\<^sub>\\<R>)\n  \\<lbrakk>?u \\<in> ?R; ?R \\<in> \\<R>\\<rbrakk>\n  \\<Longrightarrow> [?u]\\<^sub>\\<R> = ?R\n  u \\<oplus> 5 / 10 \\<in> V\n\ngoal (1 subgoal):\n 1. [u \\<oplus> 5 / 10]\\<^sub>\\<R> = [u]\\<^sub>\\<R>", "by blast"], ["proof (state)\nthis:\n  [u \\<oplus> 5 / 10]\\<^sub>\\<R> = [u]\\<^sub>\\<R>\n\ngoal (2 subgoals):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u c \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "moreover"], ["proof (state)\nthis:\n  [u \\<oplus> 5 / 10]\\<^sub>\\<R> = [u]\\<^sub>\\<R>\n\ngoal (2 subgoals):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u c \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "note * \\<open>rept _ _ = _\\<close> \\<open>s = _\\<close> T \\<open>\\<mu> = _\\<close> \\<open>(l, _) \\<in> \\<S>\\<close> \\<S>_inv"], ["proof (state)\nthis:\n  l \\<in> L\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  abss s = (l, [u]\\<^sub>\\<R>)\n  rept s \\<mu> = return_pmf (l, u \\<oplus> 5 / 10)\n  s = (l, u)\n  s \\<in> S\n  \\<mu> = return_pmf (abss s)\n  (l, [u]\\<^sub>\\<R>) \\<in> \\<S>\n  (?l, ?R) \\<in> \\<S> \\<Longrightarrow>\n  ?R \\<subseteq> {v. v \\<turnstile> PTA.inv_of A ?l}\n\ngoal (2 subgoals):\n 1. \\<forall>c\\<in>\\<X>. real (k c) < u c \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n 2. \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "ultimately"], ["proof (chain)\npicking this:\n  u \\<oplus> 5 / 10 \\<in> [u]\\<^sub>\\<R>\n  u \\<oplus> 5 / 10 \\<in> V\n  [u \\<oplus> 5 / 10]\\<^sub>\\<R> = [u]\\<^sub>\\<R>\n  l \\<in> L\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  abss s = (l, [u]\\<^sub>\\<R>)\n  rept s \\<mu> = return_pmf (l, u \\<oplus> 5 / 10)\n  s = (l, u)\n  s \\<in> S\n  \\<mu> = return_pmf (abss s)\n  (l, [u]\\<^sub>\\<R>) \\<in> \\<S>\n  (?l, ?R) \\<in> \\<S> \\<Longrightarrow>\n  ?R \\<subseteq> {v. v \\<turnstile> PTA.inv_of A ?l}", "show ?thesis"], ["proof (prove)\nusing this:\n  u \\<oplus> 5 / 10 \\<in> [u]\\<^sub>\\<R>\n  u \\<oplus> 5 / 10 \\<in> V\n  [u \\<oplus> 5 / 10]\\<^sub>\\<R> = [u]\\<^sub>\\<R>\n  l \\<in> L\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  abss s = (l, [u]\\<^sub>\\<R>)\n  rept s \\<mu> = return_pmf (l, u \\<oplus> 5 / 10)\n  s = (l, u)\n  s \\<in> S\n  \\<mu> = return_pmf (abss s)\n  (l, [u]\\<^sub>\\<R>) \\<in> \\<S>\n  (?l, ?R) \\<in> \\<S> \\<Longrightarrow>\n  ?R \\<subseteq> {v. v \\<turnstile> PTA.inv_of A ?l}\n\ngoal (1 subgoal):\n 1. rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "unfolding rept_def"], ["proof (prove)\nusing this:\n  u \\<oplus> 5 / 10 \\<in> [u]\\<^sub>\\<R>\n  u \\<oplus> 5 / 10 \\<in> V\n  [u \\<oplus> 5 / 10]\\<^sub>\\<R> = [u]\\<^sub>\\<R>\n  l \\<in> L\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  abss s = (l, [u]\\<^sub>\\<R>)\n  (let (l, u) = s\n   in if \\<exists>R'.\n            (l, u) \\<in> S \\<and>\n            \\<mu> = return_pmf (l, R') \\<and>\n            [u]\\<^sub>\\<R> = R' \\<and>\n            (\\<forall>c\\<in>\\<X>. real (k c) < u c)\n      then return_pmf (l, u \\<oplus> 5 / 10)\n      else if \\<exists>R'.\n                 (l, u) \\<in> S \\<and>\n                 \\<mu> = return_pmf (l, R') \\<and>\n                 R' \\<in> Succ \\<R> ([u]\\<^sub>\\<R>) \\<and>\n                 [u]\\<^sub>\\<R> \\<noteq> R' \\<and>\n                 (\\<forall>u\\<in>R'.\n                     \\<forall>c\\<in>\\<X>.\n                        \\<not> (\\<exists>d\\<le>k c. u c = real d))\n           then return_pmf\n                 (l, delayedR (SOME R'. \\<mu> = return_pmf (l, R')) u)\n           else SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>) =\n  return_pmf (l, u \\<oplus> 5 / 10)\n  s = (l, u)\n  s \\<in> S\n  \\<mu> = return_pmf (abss s)\n  (l, [u]\\<^sub>\\<R>) \\<in> \\<S>\n  (?l, ?R) \\<in> \\<S> \\<Longrightarrow>\n  ?R \\<subseteq> {v. v \\<turnstile> PTA.inv_of A ?l}\n\ngoal (1 subgoal):\n 1. (let (l, u) = s\n     in if \\<exists>R'.\n              (l, u) \\<in> S \\<and>\n              \\<mu> = return_pmf (l, R') \\<and>\n              [u]\\<^sub>\\<R> = R' \\<and>\n              (\\<forall>c\\<in>\\<X>. real (k c) < u c)\n        then return_pmf (l, u \\<oplus> 5 / 10)\n        else if \\<exists>R'.\n                   (l, u) \\<in> S \\<and>\n                   \\<mu> = return_pmf (l, R') \\<and>\n                   R' \\<in> Succ \\<R> ([u]\\<^sub>\\<R>) \\<and>\n                   [u]\\<^sub>\\<R> \\<noteq> R' \\<and>\n                   (\\<forall>u\\<in>R'.\n                       \\<forall>c\\<in>\\<X>.\n                          \\<not> (\\<exists>d\\<le>k c. u c = real d))\n             then return_pmf\n                   (l, delayedR (SOME R'. \\<mu> = return_pmf (l, R')) u)\n             else SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)\n    \\<in> K s \\<and>\n    abst\n     (let (l, u) = s\n      in if \\<exists>R'.\n               (l, u) \\<in> S \\<and>\n               \\<mu> = return_pmf (l, R') \\<and>\n               [u]\\<^sub>\\<R> = R' \\<and>\n               (\\<forall>c\\<in>\\<X>. real (k c) < u c)\n         then return_pmf (l, u \\<oplus> 5 / 10)\n         else if \\<exists>R'.\n                    (l, u) \\<in> S \\<and>\n                    \\<mu> = return_pmf (l, R') \\<and>\n                    R' \\<in> Succ \\<R> ([u]\\<^sub>\\<R>) \\<and>\n                    [u]\\<^sub>\\<R> \\<noteq> R' \\<and>\n                    (\\<forall>u\\<in>R'.\n                        \\<forall>c\\<in>\\<X>.\n                           \\<not> (\\<exists>d\\<le>k c. u c = real d))\n              then return_pmf\n                    (l, delayedR (SOME R'. \\<mu> = return_pmf (l, R')) u)\n              else SOME \\<mu>'.\n                      \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>) =\n    \\<mu>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<oplus> 1 / 2 \\<in> [u]\\<^sub>\\<R>;\n     u \\<oplus> 1 / 2 \\<in> V;\n     [u \\<oplus> 1 / 2]\\<^sub>\\<R> = [u]\\<^sub>\\<R>; l \\<in> L;\n     u \\<in> [u]\\<^sub>\\<R>; [u]\\<^sub>\\<R> \\<in> \\<R>;\n     abss (l, u) = (l, [u]\\<^sub>\\<R>);\n     (if \\<forall>c\\<in>\\<X>. real (k c) < u c\n      then return_pmf (l, u \\<oplus> 5 / 10)\n      else if \\<exists>R'.\n                 (l, u) \\<in> S \\<and>\n                 \\<mu> = return_pmf (l, R') \\<and>\n                 R' \\<in> Succ \\<R> ([u]\\<^sub>\\<R>) \\<and>\n                 [u]\\<^sub>\\<R> \\<noteq> R' \\<and>\n                 (\\<forall>u\\<in>R'.\n                     \\<forall>c\\<in>\\<X>.\n                        \\<not> (\\<exists>d\\<le>k c. u c = real d))\n           then return_pmf\n                 (l, delayedR (SOME R'. \\<mu> = return_pmf (l, R')) u)\n           else SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>) =\n     return_pmf (l, u \\<oplus> 1 / 2);\n     s = (l, u); (l, u) \\<in> S; \\<mu> = return_pmf (l, [u]\\<^sub>\\<R>);\n     (l, [u]\\<^sub>\\<R>) \\<in> \\<S>;\n     \\<And>l R.\n        (l, R) \\<in> \\<S> \\<Longrightarrow>\n        R \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\\<rbrakk>\n    \\<Longrightarrow> return_pmf (l, u \\<oplus> 1 / 2) \\<in> K (l, u) \\<and>\n                      abst (return_pmf (l, u \\<oplus> 1 / 2)) =\n                      return_pmf (l, [u]\\<^sub>\\<R>)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>u \\<oplus> 1 / 2 \\<in> [u]\\<^sub>\\<R>;\n     u \\<oplus> 1 / 2 \\<in> V;\n     [u \\<oplus> 1 / 2]\\<^sub>\\<R> = [u]\\<^sub>\\<R>; l \\<in> L;\n     u \\<in> [u]\\<^sub>\\<R>; [u]\\<^sub>\\<R> \\<in> \\<R>;\n     abss (l, u) = (l, [u]\\<^sub>\\<R>);\n     (if \\<forall>c\\<in>\\<X>. real (k c) < u c\n      then return_pmf (l, u \\<oplus> 5 / 10)\n      else if \\<exists>R'.\n                 (l, u) \\<in> S \\<and>\n                 return_pmf (l, [u]\\<^sub>\\<R>) = return_pmf (l, R') \\<and>\n                 R' \\<in> Succ \\<R> ([u]\\<^sub>\\<R>) \\<and>\n                 [u]\\<^sub>\\<R> \\<noteq> R' \\<and>\n                 (\\<forall>u\\<in>R'.\n                     \\<forall>c\\<in>\\<X>.\n                        \\<not> (\\<exists>d\\<le>k c. u c = real d))\n           then return_pmf\n                 (l, delayedR\n                      (SOME R'.\n                          return_pmf (l, [u]\\<^sub>\\<R>) =\n                          return_pmf (l, R'))\n                      u)\n           else SOME \\<mu>.\n                   \\<mu> \\<in> K (l, u) \\<and>\n                   abst \\<mu> = return_pmf (l, [u]\\<^sub>\\<R>)) =\n     return_pmf (l, u \\<oplus> 1 / 2);\n     (l, u) \\<in> S; \\<mu> = return_pmf (l, [u]\\<^sub>\\<R>);\n     (l, [u]\\<^sub>\\<R>) \\<in> \\<S>;\n     \\<And>l R.\n        (l, R) \\<in> \\<S> \\<Longrightarrow>\n        R \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l};\n     s = (l, u)\\<rbrakk>\n    \\<Longrightarrow> return_pmf (l, u \\<oplus> 1 / 2) \\<in> K (l, u)\n 2. \\<lbrakk>u \\<oplus> 1 / 2 \\<in> [u]\\<^sub>\\<R>;\n     u \\<oplus> 1 / 2 \\<in> V;\n     [u \\<oplus> 1 / 2]\\<^sub>\\<R> = [u]\\<^sub>\\<R>; l \\<in> L;\n     u \\<in> [u]\\<^sub>\\<R>; [u]\\<^sub>\\<R> \\<in> \\<R>;\n     abss (l, u) = (l, [u]\\<^sub>\\<R>);\n     (if \\<forall>c\\<in>\\<X>. real (k c) < u c\n      then return_pmf (l, u \\<oplus> 5 / 10)\n      else if \\<exists>R'.\n                 (l, u) \\<in> S \\<and>\n                 return_pmf (l, [u]\\<^sub>\\<R>) = return_pmf (l, R') \\<and>\n                 R' \\<in> Succ \\<R> ([u]\\<^sub>\\<R>) \\<and>\n                 [u]\\<^sub>\\<R> \\<noteq> R' \\<and>\n                 (\\<forall>u\\<in>R'.\n                     \\<forall>c\\<in>\\<X>.\n                        \\<not> (\\<exists>d\\<le>k c. u c = real d))\n           then return_pmf\n                 (l, delayedR\n                      (SOME R'.\n                          return_pmf (l, [u]\\<^sub>\\<R>) =\n                          return_pmf (l, R'))\n                      u)\n           else SOME \\<mu>.\n                   \\<mu> \\<in> K (l, u) \\<and>\n                   abst \\<mu> = return_pmf (l, [u]\\<^sub>\\<R>)) =\n     return_pmf (l, u \\<oplus> 1 / 2);\n     (l, u) \\<in> S; \\<mu> = return_pmf (l, [u]\\<^sub>\\<R>);\n     (l, [u]\\<^sub>\\<R>) \\<in> \\<S>;\n     \\<And>l R.\n        (l, R) \\<in> \\<S> \\<Longrightarrow>\n        R \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l};\n     s = (l, u)\\<rbrakk>\n    \\<Longrightarrow> abst (return_pmf (l, u \\<oplus> 1 / 2)) =\n                      return_pmf (l, [u]\\<^sub>\\<R>)", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<oplus> 1 / 2 \\<in> [u]\\<^sub>\\<R>;\n     u \\<oplus> 1 / 2 \\<in> V;\n     [u \\<oplus> 1 / 2]\\<^sub>\\<R> = [u]\\<^sub>\\<R>; l \\<in> L;\n     u \\<in> [u]\\<^sub>\\<R>; [u]\\<^sub>\\<R> \\<in> \\<R>;\n     abss (l, u) = (l, [u]\\<^sub>\\<R>);\n     (if \\<forall>c\\<in>\\<X>. real (k c) < u c\n      then return_pmf (l, u \\<oplus> 5 / 10)\n      else if \\<exists>R'.\n                 (l, u) \\<in> S \\<and>\n                 return_pmf (l, [u]\\<^sub>\\<R>) = return_pmf (l, R') \\<and>\n                 R' \\<in> Succ \\<R> ([u]\\<^sub>\\<R>) \\<and>\n                 [u]\\<^sub>\\<R> \\<noteq> R' \\<and>\n                 (\\<forall>u\\<in>R'.\n                     \\<forall>c\\<in>\\<X>.\n                        \\<not> (\\<exists>d\\<le>k c. u c = real d))\n           then return_pmf\n                 (l, delayedR\n                      (SOME R'.\n                          return_pmf (l, [u]\\<^sub>\\<R>) =\n                          return_pmf (l, R'))\n                      u)\n           else SOME \\<mu>.\n                   \\<mu> \\<in> K (l, u) \\<and>\n                   abst \\<mu> = return_pmf (l, [u]\\<^sub>\\<R>)) =\n     return_pmf (l, u \\<oplus> 1 / 2);\n     (l, u) \\<in> S; \\<mu> = return_pmf (l, [u]\\<^sub>\\<R>);\n     (l, [u]\\<^sub>\\<R>) \\<in> \\<S>;\n     \\<And>l R.\n        (l, R) \\<in> \\<S> \\<Longrightarrow>\n        R \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l};\n     s = (l, u)\\<rbrakk>\n    \\<Longrightarrow> abst (return_pmf (l, u \\<oplus> 1 / 2)) =\n                      return_pmf (l, [u]\\<^sub>\\<R>)", "apply (simp add: abst_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<oplus> 1 / 2 \\<in> [u]\\<^sub>\\<R>;\n     u \\<oplus> 1 / 2 \\<in> V;\n     [u \\<oplus> 1 / 2]\\<^sub>\\<R> = [u]\\<^sub>\\<R>; l \\<in> L;\n     u \\<in> [u]\\<^sub>\\<R>; [u]\\<^sub>\\<R> \\<in> \\<R>;\n     abss (l, u) = (l, [u]\\<^sub>\\<R>);\n     (if \\<forall>c\\<in>\\<X>. real (k c) < u c\n      then return_pmf (l, u \\<oplus> 5 / 10)\n      else if \\<exists>R'.\n                 (l, u) \\<in> S \\<and>\n                 return_pmf (l, [u]\\<^sub>\\<R>) = return_pmf (l, R') \\<and>\n                 R' \\<in> Succ \\<R> ([u]\\<^sub>\\<R>) \\<and>\n                 [u]\\<^sub>\\<R> \\<noteq> R' \\<and>\n                 (\\<forall>u\\<in>R'.\n                     \\<forall>c\\<in>\\<X>.\n                        \\<not> (\\<exists>d\\<le>k c. u c = real d))\n           then return_pmf\n                 (l, delayedR\n                      (SOME R'.\n                          return_pmf (l, [u]\\<^sub>\\<R>) =\n                          return_pmf (l, R'))\n                      u)\n           else SOME \\<mu>.\n                   \\<mu> \\<in> K (l, u) \\<and>\n                   abst \\<mu> = return_pmf (l, [u]\\<^sub>\\<R>)) =\n     return_pmf (l, u \\<oplus> 1 / 2);\n     (l, u) \\<in> S; \\<mu> = return_pmf (l, [u]\\<^sub>\\<R>);\n     (l, [u]\\<^sub>\\<R>) \\<in> \\<S>;\n     \\<And>l R.\n        (l, R) \\<in> \\<S> \\<Longrightarrow>\n        R \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l};\n     s = (l, u)\\<rbrakk>\n    \\<Longrightarrow> abss (l, u \\<oplus> 1 / 2) = (l, [u]\\<^sub>\\<R>)", "apply (subst abst_def abss_S)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>u \\<oplus> 1 / 2 \\<in> [u]\\<^sub>\\<R>;\n     u \\<oplus> 1 / 2 \\<in> V;\n     [u \\<oplus> 1 / 2]\\<^sub>\\<R> = [u]\\<^sub>\\<R>; l \\<in> L;\n     u \\<in> [u]\\<^sub>\\<R>; [u]\\<^sub>\\<R> \\<in> \\<R>;\n     abss (l, u) = (l, [u]\\<^sub>\\<R>);\n     (if \\<forall>c\\<in>\\<X>. real (k c) < u c\n      then return_pmf (l, u \\<oplus> 5 / 10)\n      else if \\<exists>R'.\n                 (l, u) \\<in> S \\<and>\n                 return_pmf (l, [u]\\<^sub>\\<R>) = return_pmf (l, R') \\<and>\n                 R' \\<in> Succ \\<R> ([u]\\<^sub>\\<R>) \\<and>\n                 [u]\\<^sub>\\<R> \\<noteq> R' \\<and>\n                 (\\<forall>u\\<in>R'.\n                     \\<forall>c\\<in>\\<X>.\n                        \\<not> (\\<exists>d\\<le>k c. u c = real d))\n           then return_pmf\n                 (l, delayedR\n                      (SOME R'.\n                          return_pmf (l, [u]\\<^sub>\\<R>) =\n                          return_pmf (l, R'))\n                      u)\n           else SOME \\<mu>.\n                   \\<mu> \\<in> K (l, u) \\<and>\n                   abst \\<mu> = return_pmf (l, [u]\\<^sub>\\<R>)) =\n     return_pmf (l, u \\<oplus> 1 / 2);\n     (l, u) \\<in> S; \\<mu> = return_pmf (l, [u]\\<^sub>\\<R>);\n     (l, [u]\\<^sub>\\<R>) \\<in> \\<S>;\n     \\<And>l R.\n        (l, R) \\<in> \\<S> \\<Longrightarrow>\n        R \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l};\n     s = (l, u)\\<rbrakk>\n    \\<Longrightarrow> (l, u \\<oplus> 1 / 2) \\<in> S\n 2. \\<lbrakk>u \\<oplus> 1 / 2 \\<in> [u]\\<^sub>\\<R>;\n     u \\<oplus> 1 / 2 \\<in> V;\n     [u \\<oplus> 1 / 2]\\<^sub>\\<R> = [u]\\<^sub>\\<R>; l \\<in> L;\n     u \\<in> [u]\\<^sub>\\<R>; [u]\\<^sub>\\<R> \\<in> \\<R>;\n     abss (l, u) = (l, [u]\\<^sub>\\<R>);\n     (if \\<forall>c\\<in>\\<X>. real (k c) < u c\n      then return_pmf (l, u \\<oplus> 5 / 10)\n      else if \\<exists>R'.\n                 (l, u) \\<in> S \\<and>\n                 return_pmf (l, [u]\\<^sub>\\<R>) = return_pmf (l, R') \\<and>\n                 R' \\<in> Succ \\<R> ([u]\\<^sub>\\<R>) \\<and>\n                 [u]\\<^sub>\\<R> \\<noteq> R' \\<and>\n                 (\\<forall>u\\<in>R'.\n                     \\<forall>c\\<in>\\<X>.\n                        \\<not> (\\<exists>d\\<le>k c. u c = real d))\n           then return_pmf\n                 (l, delayedR\n                      (SOME R'.\n                          return_pmf (l, [u]\\<^sub>\\<R>) =\n                          return_pmf (l, R'))\n                      u)\n           else SOME \\<mu>.\n                   \\<mu> \\<in> K (l, u) \\<and>\n                   abst \\<mu> = return_pmf (l, [u]\\<^sub>\\<R>)) =\n     return_pmf (l, u \\<oplus> 1 / 2);\n     (l, u) \\<in> S; \\<mu> = return_pmf (l, [u]\\<^sub>\\<R>);\n     (l, [u]\\<^sub>\\<R>) \\<in> \\<S>;\n     \\<And>l R.\n        (l, R) \\<in> \\<S> \\<Longrightarrow>\n        R \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l};\n     s = (l, u)\\<rbrakk>\n    \\<Longrightarrow> (l, [u \\<oplus> 1 / 2]\\<^sub>\\<R>) =\n                      (l, [u]\\<^sub>\\<R>)", "by fastforce+"], ["proof (state)\nthis:\n  rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "with * \\<open>s = _\\<close> \\<open>\\<mu> = _\\<close>"], ["proof (chain)\npicking this:\n  l \\<in> L\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  abss s = (l, [u]\\<^sub>\\<R>)\n  s = (l, u)\n  \\<mu> = return_pmf (abss s)\n  \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c)", "have\n        \"rept s \\<mu> = (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)\""], ["proof (prove)\nusing this:\n  l \\<in> L\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  abss s = (l, [u]\\<^sub>\\<R>)\n  s = (l, u)\n  \\<mu> = return_pmf (abss s)\n  \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c)\n\ngoal (1 subgoal):\n 1. rept s \\<mu> =\n    (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)", "unfolding rept_def"], ["proof (prove)\nusing this:\n  l \\<in> L\n  u \\<in> [u]\\<^sub>\\<R>\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  abss s = (l, [u]\\<^sub>\\<R>)\n  s = (l, u)\n  \\<mu> = return_pmf (abss s)\n  \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c)\n\ngoal (1 subgoal):\n 1. (let (l, u) = s\n     in if \\<exists>R'.\n              (l, u) \\<in> S \\<and>\n              \\<mu> = return_pmf (l, R') \\<and>\n              [u]\\<^sub>\\<R> = R' \\<and>\n              (\\<forall>c\\<in>\\<X>. real (k c) < u c)\n        then return_pmf (l, u \\<oplus> 5 / 10)\n        else if \\<exists>R'.\n                   (l, u) \\<in> S \\<and>\n                   \\<mu> = return_pmf (l, R') \\<and>\n                   R' \\<in> Succ \\<R> ([u]\\<^sub>\\<R>) \\<and>\n                   [u]\\<^sub>\\<R> \\<noteq> R' \\<and>\n                   (\\<forall>u\\<in>R'.\n                       \\<forall>c\\<in>\\<X>.\n                          \\<not> (\\<exists>d\\<le>k c. u c = real d))\n             then return_pmf\n                   (l, delayedR (SOME R'. \\<mu> = return_pmf (l, R')) u)\n             else SOME \\<mu>'.\n                     \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>) =\n    (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)", "by auto"], ["proof (state)\nthis:\n  rept s \\<mu> = (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>c\\<in>\\<X>. real (k c) < u c) \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "with \\<open>\\<mu> = _\\<close>"], ["proof (chain)\npicking this:\n  \\<mu> = return_pmf (abss s)\n  rept s \\<mu> = (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<mu> = return_pmf (abss s)\n  rept s \\<mu> = (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)\n\ngoal (1 subgoal):\n 1. rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "by simp (rule someI[where x = \"return_pmf s\"], auto simp: abst_def)"], ["proof (state)\nthis:\n  rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n\ngoal (1 subgoal):\n 1. s \\<notin> S \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<notin> S \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "case False"], ["proof (state)\nthis:\n  s \\<notin> S\n\ngoal (1 subgoal):\n 1. s \\<notin> S \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "with \\<open>s = _\\<close> \\<open>\\<mu> = _\\<close>"], ["proof (chain)\npicking this:\n  s = (l, u)\n  \\<mu> = return_pmf (abss s)\n  s \\<notin> S", "have\n        \"rept s \\<mu> = (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)\""], ["proof (prove)\nusing this:\n  s = (l, u)\n  \\<mu> = return_pmf (abss s)\n  s \\<notin> S\n\ngoal (1 subgoal):\n 1. rept s \\<mu> =\n    (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)", "unfolding rept_def"], ["proof (prove)\nusing this:\n  s = (l, u)\n  \\<mu> = return_pmf (abss s)\n  s \\<notin> S\n\ngoal (1 subgoal):\n 1. (let (l, u) = s\n     in if \\<exists>R'.\n              (l, u) \\<in> S \\<and>\n              \\<mu> = return_pmf (l, R') \\<and>\n              [u]\\<^sub>\\<R> = R' \\<and>\n              (\\<forall>c\\<in>\\<X>. real (k c) < u c)\n        then return_pmf (l, u \\<oplus> 5 / 10)\n        else if \\<exists>R'.\n                   (l, u) \\<in> S \\<and>\n                   \\<mu> = return_pmf (l, R') \\<and>\n                   R' \\<in> Succ \\<R> ([u]\\<^sub>\\<R>) \\<and>\n                   [u]\\<^sub>\\<R> \\<noteq> R' \\<and>\n                   (\\<forall>u\\<in>R'.\n                       \\<forall>c\\<in>\\<X>.\n                          \\<not> (\\<exists>d\\<le>k c. u c = real d))\n             then return_pmf\n                   (l, delayedR (SOME R'. \\<mu> = return_pmf (l, R')) u)\n             else SOME \\<mu>'.\n                     \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>) =\n    (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)", "by auto"], ["proof (state)\nthis:\n  rept s \\<mu> = (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)\n\ngoal (1 subgoal):\n 1. s \\<notin> S \\<Longrightarrow>\n    rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "with \\<open>\\<mu> = _\\<close>"], ["proof (chain)\npicking this:\n  \\<mu> = return_pmf (abss s)\n  rept s \\<mu> = (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<mu> = return_pmf (abss s)\n  rept s \\<mu> = (SOME \\<mu>'. \\<mu>' \\<in> K s \\<and> abst \\<mu>' = \\<mu>)\n\ngoal (1 subgoal):\n 1. rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>", "by simp (rule someI[where x = \"return_pmf s\"], auto simp: abst_def)"], ["proof (state)\nthis:\n  rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rept s \\<mu> \\<in> K s \\<and> abst (rept s \\<mu>) = \\<mu>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas rept_K[intro]       = rept_ex[THEN conjunct1]"], ["", "lemmas abst_rept_id[simp]  = rept_ex[THEN conjunct2]"], ["", "lemma abst_rept2:\n  assumes \"\\<mu> \\<in> \\<K> s\" \"s \\<in> \\<S>\"\n  shows \"abst (rept (reps s) \\<mu>) = \\<mu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abst (rept (reps s) \\<mu>) = \\<mu>", "using assms"], ["proof (prove)\nusing this:\n  \\<mu> \\<in> \\<K> s\n  s \\<in> \\<S>\n\ngoal (1 subgoal):\n 1. abst (rept (reps s) \\<mu>) = \\<mu>", "by auto"], ["", "lemma rept_K2:\n  assumes \"\\<mu> \\<in> \\<K> s\" \"s \\<in> \\<S>\"\n  shows \"rept (reps s) \\<mu> \\<in> K (reps s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rept (reps s) \\<mu> \\<in> K (reps s)", "using assms"], ["proof (prove)\nusing this:\n  \\<mu> \\<in> \\<K> s\n  s \\<in> \\<S>\n\ngoal (1 subgoal):\n 1. rept (reps s) \\<mu> \\<in> K (reps s)", "by auto"], ["", "(* XXX Move this. Does this exist anywhere? More elegant pattern? *)"], ["", "lemma theI':\n  assumes \"P a\"\n    and \"\\<And>x. P x \\<Longrightarrow> x = a\"\n  shows \"P (THE x. P x) \\<and> (\\<forall> y. P y \\<longrightarrow> y = (THE x. P x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (THE x. P x) \\<and>\n    (\\<forall>y. P y \\<longrightarrow> y = (THE x. P x))", "using theI assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?P ?a; \\<And>x. ?P x \\<Longrightarrow> x = ?a\\<rbrakk>\n  \\<Longrightarrow> ?P (THE x. ?P x)\n  P a\n  P ?x5 \\<Longrightarrow> ?x5 = a\n\ngoal (1 subgoal):\n 1. P (THE x. P x) \\<and>\n    (\\<forall>y. P y \\<longrightarrow> y = (THE x. P x))", "by metis"], ["", "lemma cont_cfg_defined:\n  fixes cfg s\n  assumes \"cfg \\<in> valid_cfg\" \"s \\<in> abst (action cfg)\"\n  defines \"x \\<equiv> THE x. abss x = s \\<and> x \\<in> action cfg\"\n  shows \"(abss x = s \\<and> x \\<in> action cfg) \\<and> (\\<forall> y. abss y = s \\<and> y \\<in> action cfg \\<longrightarrow> y = x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (abss x = s \\<and> x \\<in> set_pmf (action cfg)) \\<and>\n    (\\<forall>y.\n        abss y = s \\<and> y \\<in> set_pmf (action cfg) \\<longrightarrow>\n        y = x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (abss x = s \\<and> x \\<in> set_pmf (action cfg)) \\<and>\n    (\\<forall>y.\n        abss y = s \\<and> y \\<in> set_pmf (action cfg) \\<longrightarrow>\n        y = x)", "from assms(2)"], ["proof (chain)\npicking this:\n  s \\<in> set_pmf (abst (action cfg))", "obtain s' where \"s' \\<in> action cfg\" \"s = abss s'\""], ["proof (prove)\nusing this:\n  s \\<in> set_pmf (abst (action cfg))\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>s' \\<in> set_pmf (action cfg); s = abss s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding abst_def"], ["proof (prove)\nusing this:\n  s \\<in> set_pmf (map_pmf abss (action cfg))\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>s' \\<in> set_pmf (action cfg); s = abss s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s' \\<in> set_pmf (action cfg)\n  s = abss s'\n\ngoal (1 subgoal):\n 1. (abss x = s \\<and> x \\<in> set_pmf (action cfg)) \\<and>\n    (\\<forall>y.\n        abss y = s \\<and> y \\<in> set_pmf (action cfg) \\<longrightarrow>\n        y = x)", "with assms"], ["proof (chain)\npicking this:\n  cfg \\<in> MDP.valid_cfg\n  s \\<in> set_pmf (abst (action cfg))\n  x \\<equiv> THE x. abss x = s \\<and> x \\<in> set_pmf (action cfg)\n  s' \\<in> set_pmf (action cfg)\n  s = abss s'", "show ?thesis"], ["proof (prove)\nusing this:\n  cfg \\<in> MDP.valid_cfg\n  s \\<in> set_pmf (abst (action cfg))\n  x \\<equiv> THE x. abss x = s \\<and> x \\<in> set_pmf (action cfg)\n  s' \\<in> set_pmf (action cfg)\n  s = abss s'\n\ngoal (1 subgoal):\n 1. (abss x = s \\<and> x \\<in> set_pmf (action cfg)) \\<and>\n    (\\<forall>y.\n        abss y = s \\<and> y \\<in> set_pmf (action cfg) \\<longrightarrow>\n        y = x)", "unfolding x_def"], ["proof (prove)\nusing this:\n  cfg \\<in> MDP.valid_cfg\n  s \\<in> set_pmf (abst (action cfg))\n  THE x. abss x = s \\<and> x \\<in> set_pmf (action cfg) \\<equiv>\n  THE x. abss x = s \\<and> x \\<in> set_pmf (action cfg)\n  s' \\<in> set_pmf (action cfg)\n  s = abss s'\n\ngoal (1 subgoal):\n 1. (abss (THE x. abss x = s \\<and> x \\<in> set_pmf (action cfg)) = s \\<and>\n     (THE x. abss x = s \\<and> x \\<in> set_pmf (action cfg))\n     \\<in> set_pmf (action cfg)) \\<and>\n    (\\<forall>y.\n        abss y = s \\<and> y \\<in> set_pmf (action cfg) \\<longrightarrow>\n        y = (THE x. abss x = s \\<and> x \\<in> set_pmf (action cfg)))", "by -(rule theI'[of _ s'],auto intro: K_bisim_unique MDP.valid_cfg_state_in_S dest: MDP.valid_cfgD)"], ["proof (state)\nthis:\n  (abss x = s \\<and> x \\<in> set_pmf (action cfg)) \\<and>\n  (\\<forall>y.\n      abss y = s \\<and> y \\<in> set_pmf (action cfg) \\<longrightarrow>\n      y = x)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  absc' :: \"('s * ('c, t) cval) cfg \\<Rightarrow> ('s * ('c, t) cval set) cfg\"\nwhere\n  \"absc' cfg = cfg_corec\n    (abss (state cfg))\n    (abst o action)\n    (\\<lambda> cfg s. cont cfg (THE x. abss x = s \\<and> x \\<in> action cfg)) cfg\""], ["", "subsubsection \\<open>Configuration\\<close>"], ["", "definition\n  absc :: \"('s * ('c, t) cval) cfg \\<Rightarrow> ('s * ('c, t) cval set) cfg\"\nwhere\n  \"absc cfg = cfg_corec\n    (abss (state cfg))\n    (abst o action)\n    (\\<lambda> cfg s. cont cfg (THE x. abss x = s \\<and> x \\<in> action cfg)) cfg\""], ["", "definition\n  repcs :: \"'s * ('c, t) cval \\<Rightarrow> ('s * ('c, t) cval set) cfg \\<Rightarrow> ('s * ('c, t) cval) cfg\"\nwhere\n  \"repcs s cfg = cfg_corec\n    s\n    (\\<lambda> (s, cfg). rept s (action cfg))\n    (\\<lambda> (s, cfg) s'. (s', cont cfg (abss s'))) (s, cfg)\""], ["", "definition\n  \"repc cfg = repcs (reps (state cfg)) cfg\""], ["", "lemma \\<S>_state_absc_repc[simp]:\n  \"state cfg \\<in> \\<S> \\<Longrightarrow> state (absc (repc cfg)) = state cfg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state cfg \\<in> \\<S> \\<Longrightarrow>\n    state (absc (repc cfg)) = state cfg", "by (simp add: absc_def repc_def repcs_def)"], ["", "lemma action_repc:\n  \"action (repc cfg) = rept (reps (state cfg)) (action cfg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. action (repc cfg) = rept (reps (state cfg)) (action cfg)", "unfolding repc_def repcs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. action\n     (cfg_corec (reps (state cfg)) (\\<lambda>(s, cfg). rept s (action cfg))\n       (\\<lambda>(s, cfg) s'. (s', cont cfg (abss s')))\n       (reps (state cfg), cfg)) =\n    rept (reps (state cfg)) (action cfg)", "by simp"], ["", "(* XXX Declare simp? *)"], ["", "lemma action_absc:\n  \"action (absc cfg) = abst (action cfg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. action (absc cfg) = abst (action cfg)", "unfolding absc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. action\n     (cfg_corec (abss (state cfg)) (abst \\<circ> action)\n       (\\<lambda>cfg s.\n           cont cfg (THE x. abss x = s \\<and> x \\<in> set_pmf (action cfg)))\n       cfg) =\n    abst (action cfg)", "by simp"], ["", "lemma action_absc':\n  \"action (absc cfg) = map_pmf abss (action cfg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. action (absc cfg) = map_pmf abss (action cfg)", "unfolding absc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. action\n     (cfg_corec (abss (state cfg)) (abst \\<circ> action)\n       (\\<lambda>cfg s.\n           cont cfg (THE x. abss x = s \\<and> x \\<in> set_pmf (action cfg)))\n       cfg) =\n    map_pmf abss (action cfg)", "unfolding abst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. action\n     (cfg_corec (abss (state cfg)) (map_pmf abss \\<circ> action)\n       (\\<lambda>cfg s.\n           cont cfg (THE x. abss x = s \\<and> x \\<in> set_pmf (action cfg)))\n       cfg) =\n    map_pmf abss (action cfg)", "by simp"], ["", "lemma\n  notes R_G.cfg_onD_state[simp del]\n  assumes \"state cfg \\<in> \\<S>\" \"s' \\<in> set_pmf (action (repc cfg))\" \"cfg \\<in> R_G.cfg_on (state cfg)\"\n  shows \"cont (repc cfg) s' = repcs s' (cont cfg (abss s'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (repc cfg) s' = repcs s' (cont cfg (abss s'))", "using assms"], ["proof (prove)\nusing this:\n  state cfg \\<in> \\<S>\n  s' \\<in> set_pmf (action (repc cfg))\n  cfg \\<in> R_G.cfg_on (state cfg)\n\ngoal (1 subgoal):\n 1. cont (repc cfg) s' = repcs s' (cont cfg (abss s'))", "by (auto simp: repc_def repcs_def abss_reps_id)"], ["", "lemma cont_repcs1:\n  notes R_G.cfg_onD_state[simp del]\n  assumes \"abss s \\<in> \\<S>\" \"s' \\<in> set_pmf (action (repcs s cfg))\" \"cfg \\<in> R_G.cfg_on (abss s)\"\n  shows \"cont (repcs s cfg) s' = repcs s' (cont cfg (abss s'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (repcs s cfg) s' = repcs s' (cont cfg (abss s'))", "using assms"], ["proof (prove)\nusing this:\n  abss s \\<in> \\<S>\n  s' \\<in> set_pmf (action (repcs s cfg))\n  cfg \\<in> R_G.cfg_on (abss s)\n\ngoal (1 subgoal):\n 1. cont (repcs s cfg) s' = repcs s' (cont cfg (abss s'))", "by (auto simp: repc_def repcs_def abss_reps_id)"], ["", "lemma cont_absc_1:\n  notes MDP.cfg_onD_state[simp del]\n  assumes \"cfg \\<in> valid_cfg\" \"s' \\<in> set_pmf (action cfg)\"\n  shows \"cont (absc cfg) (abss s') = absc (cont cfg s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (absc cfg) (abss s') = absc (cont cfg s')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cont (absc cfg) (abss s') = absc (cont cfg s')", "define x where \"x \\<equiv> THE x. x ~ s' \\<and> x \\<in> set_pmf (action cfg)\""], ["proof (state)\nthis:\n  x \\<equiv> THE x. x ~ s' \\<and> x \\<in> set_pmf (action cfg)\n\ngoal (1 subgoal):\n 1. cont (absc cfg) (abss s') = absc (cont cfg s')", "from assms(2)"], ["proof (chain)\npicking this:\n  s' \\<in> set_pmf (action cfg)", "have \"abss s' \\<in> set_pmf (abst (action cfg))\""], ["proof (prove)\nusing this:\n  s' \\<in> set_pmf (action cfg)\n\ngoal (1 subgoal):\n 1. abss s' \\<in> set_pmf (abst (action cfg))", "unfolding abst_def"], ["proof (prove)\nusing this:\n  s' \\<in> set_pmf (action cfg)\n\ngoal (1 subgoal):\n 1. abss s' \\<in> set_pmf (map_pmf abss (action cfg))", "by auto"], ["proof (state)\nthis:\n  abss s' \\<in> set_pmf (abst (action cfg))\n\ngoal (1 subgoal):\n 1. cont (absc cfg) (abss s') = absc (cont cfg s')", "from cont_cfg_defined[OF assms(1) this]"], ["proof (chain)\npicking this:\n  ((THE x. x ~ s' \\<and> x \\<in> set_pmf (action cfg)) ~ s' \\<and>\n   (THE x. x ~ s' \\<and> x \\<in> set_pmf (action cfg))\n   \\<in> set_pmf (action cfg)) \\<and>\n  (\\<forall>y.\n      y ~ s' \\<and> y \\<in> set_pmf (action cfg) \\<longrightarrow>\n      y = (THE x. x ~ s' \\<and> x \\<in> set_pmf (action cfg)))", "have\n    \"(x ~ s' \\<and> x \\<in> set_pmf (action cfg)) \\<and> (\\<forall>y. y ~ s' \\<and> y \\<in> set_pmf (action cfg) \\<longrightarrow> y = x)\""], ["proof (prove)\nusing this:\n  ((THE x. x ~ s' \\<and> x \\<in> set_pmf (action cfg)) ~ s' \\<and>\n   (THE x. x ~ s' \\<and> x \\<in> set_pmf (action cfg))\n   \\<in> set_pmf (action cfg)) \\<and>\n  (\\<forall>y.\n      y ~ s' \\<and> y \\<in> set_pmf (action cfg) \\<longrightarrow>\n      y = (THE x. x ~ s' \\<and> x \\<in> set_pmf (action cfg)))\n\ngoal (1 subgoal):\n 1. (x ~ s' \\<and> x \\<in> set_pmf (action cfg)) \\<and>\n    (\\<forall>y.\n        y ~ s' \\<and> y \\<in> set_pmf (action cfg) \\<longrightarrow> y = x)", "unfolding x_def"], ["proof (prove)\nusing this:\n  ((THE x. x ~ s' \\<and> x \\<in> set_pmf (action cfg)) ~ s' \\<and>\n   (THE x. x ~ s' \\<and> x \\<in> set_pmf (action cfg))\n   \\<in> set_pmf (action cfg)) \\<and>\n  (\\<forall>y.\n      y ~ s' \\<and> y \\<in> set_pmf (action cfg) \\<longrightarrow>\n      y = (THE x. x ~ s' \\<and> x \\<in> set_pmf (action cfg)))\n\ngoal (1 subgoal):\n 1. ((THE x. x ~ s' \\<and> x \\<in> set_pmf (action cfg)) ~ s' \\<and>\n     (THE x. x ~ s' \\<and> x \\<in> set_pmf (action cfg))\n     \\<in> set_pmf (action cfg)) \\<and>\n    (\\<forall>y.\n        y ~ s' \\<and> y \\<in> set_pmf (action cfg) \\<longrightarrow>\n        y = (THE x. x ~ s' \\<and> x \\<in> set_pmf (action cfg)))", "."], ["proof (state)\nthis:\n  (x ~ s' \\<and> x \\<in> set_pmf (action cfg)) \\<and>\n  (\\<forall>y.\n      y ~ s' \\<and> y \\<in> set_pmf (action cfg) \\<longrightarrow> y = x)\n\ngoal (1 subgoal):\n 1. cont (absc cfg) (abss s') = absc (cont cfg s')", "with assms"], ["proof (chain)\npicking this:\n  cfg \\<in> MDP.valid_cfg\n  s' \\<in> set_pmf (action cfg)\n  (x ~ s' \\<and> x \\<in> set_pmf (action cfg)) \\<and>\n  (\\<forall>y.\n      y ~ s' \\<and> y \\<in> set_pmf (action cfg) \\<longrightarrow> y = x)", "have \"s' = x\""], ["proof (prove)\nusing this:\n  cfg \\<in> MDP.valid_cfg\n  s' \\<in> set_pmf (action cfg)\n  (x ~ s' \\<and> x \\<in> set_pmf (action cfg)) \\<and>\n  (\\<forall>y.\n      y ~ s' \\<and> y \\<in> set_pmf (action cfg) \\<longrightarrow> y = x)\n\ngoal (1 subgoal):\n 1. s' = x", "by fastforce"], ["proof (state)\nthis:\n  s' = x\n\ngoal (1 subgoal):\n 1. cont (absc cfg) (abss s') = absc (cont cfg s')", "then"], ["proof (chain)\npicking this:\n  s' = x", "show ?thesis"], ["proof (prove)\nusing this:\n  s' = x\n\ngoal (1 subgoal):\n 1. cont (absc cfg) (abss s') = absc (cont cfg s')", "unfolding absc_def abst_def repc_def x_def"], ["proof (prove)\nusing this:\n  s' = (THE x. x ~ s' \\<and> x \\<in> set_pmf (action cfg))\n\ngoal (1 subgoal):\n 1. cont\n     (cfg_corec (abss (state cfg)) (map_pmf abss \\<circ> action)\n       (\\<lambda>cfg s.\n           cont cfg (THE x. abss x = s \\<and> x \\<in> set_pmf (action cfg)))\n       cfg)\n     (abss s') =\n    cfg_corec (abss (state (cont cfg s'))) (map_pmf abss \\<circ> action)\n     (\\<lambda>cfg s.\n         cont cfg (THE x. abss x = s \\<and> x \\<in> set_pmf (action cfg)))\n     (cont cfg s')", "using assms(2)"], ["proof (prove)\nusing this:\n  s' = (THE x. x ~ s' \\<and> x \\<in> set_pmf (action cfg))\n  s' \\<in> set_pmf (action cfg)\n\ngoal (1 subgoal):\n 1. cont\n     (cfg_corec (abss (state cfg)) (map_pmf abss \\<circ> action)\n       (\\<lambda>cfg s.\n           cont cfg (THE x. abss x = s \\<and> x \\<in> set_pmf (action cfg)))\n       cfg)\n     (abss s') =\n    cfg_corec (abss (state (cont cfg s'))) (map_pmf abss \\<circ> action)\n     (\\<lambda>cfg s.\n         cont cfg (THE x. abss x = s \\<and> x \\<in> set_pmf (action cfg)))\n     (cont cfg s')", "by auto"], ["proof (state)\nthis:\n  cont (absc cfg) (abss s') = absc (cont cfg s')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma state_repc:\n  \"state (repc cfg) = reps (state cfg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state (repc cfg) = reps (state cfg)", "unfolding repc_def repcs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. state\n     (cfg_corec (reps (state cfg)) (\\<lambda>(s, cfg). rept s (action cfg))\n       (\\<lambda>(s, cfg) s'. (s', cont cfg (abss s')))\n       (reps (state cfg), cfg)) =\n    reps (state cfg)", "by simp"], ["", "lemma abss_reps_id':\n  notes R_G.cfg_onD_state[simp del]\n  assumes \"cfg \\<in> R_G.valid_cfg\" \"s \\<in> set_pmf (action cfg)\"\n  shows \"abss (reps s) = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abss (reps s) = s", "using assms"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  s \\<in> set_pmf (action cfg)\n\ngoal (1 subgoal):\n 1. abss (reps s) = s", "by (auto intro: abss_reps_id R_G.valid_cfg_state_in_S R_G.valid_cfgD)"], ["", "(* XXX Move to different locale *)"], ["", "lemma valid_cfg_coinduct[coinduct set: valid_cfg]:\n  assumes \"P cfg\"\n  assumes \"\\<And>cfg. P cfg \\<Longrightarrow> state cfg \\<in> S\"\n  assumes \"\\<And>cfg. P cfg \\<Longrightarrow> action cfg \\<in> K (state cfg)\"\n  assumes \"\\<And>cfg t. P cfg \\<Longrightarrow> t \\<in> action cfg \\<Longrightarrow> P (cont cfg t)\"\n  shows \"cfg \\<in> valid_cfg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cfg \\<in> MDP.valid_cfg", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cfg \\<in> MDP.valid_cfg", "from assms"], ["proof (chain)\npicking this:\n  P cfg\n  P ?cfg5 \\<Longrightarrow> state ?cfg5 \\<in> S\n  P ?cfg5 \\<Longrightarrow> action ?cfg5 \\<in> K (state ?cfg5)\n  \\<lbrakk>P ?cfg5; ?t5 \\<in> set_pmf (action ?cfg5)\\<rbrakk>\n  \\<Longrightarrow> P (cont ?cfg5 ?t5)", "have \"cfg \\<in> MDP.cfg_on (state cfg)\""], ["proof (prove)\nusing this:\n  P cfg\n  P ?cfg5 \\<Longrightarrow> state ?cfg5 \\<in> S\n  P ?cfg5 \\<Longrightarrow> action ?cfg5 \\<in> K (state ?cfg5)\n  \\<lbrakk>P ?cfg5; ?t5 \\<in> set_pmf (action ?cfg5)\\<rbrakk>\n  \\<Longrightarrow> P (cont ?cfg5 ?t5)\n\ngoal (1 subgoal):\n 1. cfg \\<in> MDP.cfg_on (state cfg)", "by (coinduction arbitrary: cfg) auto"], ["proof (state)\nthis:\n  cfg \\<in> MDP.cfg_on (state cfg)\n\ngoal (1 subgoal):\n 1. cfg \\<in> MDP.valid_cfg", "moreover"], ["proof (state)\nthis:\n  cfg \\<in> MDP.cfg_on (state cfg)\n\ngoal (1 subgoal):\n 1. cfg \\<in> MDP.valid_cfg", "from assms"], ["proof (chain)\npicking this:\n  P cfg\n  P ?cfg5 \\<Longrightarrow> state ?cfg5 \\<in> S\n  P ?cfg5 \\<Longrightarrow> action ?cfg5 \\<in> K (state ?cfg5)\n  \\<lbrakk>P ?cfg5; ?t5 \\<in> set_pmf (action ?cfg5)\\<rbrakk>\n  \\<Longrightarrow> P (cont ?cfg5 ?t5)", "have \"state cfg \\<in> S\""], ["proof (prove)\nusing this:\n  P cfg\n  P ?cfg5 \\<Longrightarrow> state ?cfg5 \\<in> S\n  P ?cfg5 \\<Longrightarrow> action ?cfg5 \\<in> K (state ?cfg5)\n  \\<lbrakk>P ?cfg5; ?t5 \\<in> set_pmf (action ?cfg5)\\<rbrakk>\n  \\<Longrightarrow> P (cont ?cfg5 ?t5)\n\ngoal (1 subgoal):\n 1. state cfg \\<in> S", "by auto"], ["proof (state)\nthis:\n  state cfg \\<in> S\n\ngoal (1 subgoal):\n 1. cfg \\<in> MDP.valid_cfg", "ultimately"], ["proof (chain)\npicking this:\n  cfg \\<in> MDP.cfg_on (state cfg)\n  state cfg \\<in> S", "show ?thesis"], ["proof (prove)\nusing this:\n  cfg \\<in> MDP.cfg_on (state cfg)\n  state cfg \\<in> S\n\ngoal (1 subgoal):\n 1. cfg \\<in> MDP.valid_cfg", "by (intro MDP.valid_cfgI)"], ["proof (state)\nthis:\n  cfg \\<in> MDP.valid_cfg\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma state_repcD[simp]:\n  assumes \"cfg \\<in> R_G.cfg_on s\"\n  shows \"state (repc cfg) = reps s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state (repc cfg) = reps s", "using assms"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.cfg_on s\n\ngoal (1 subgoal):\n 1. state (repc cfg) = reps s", "unfolding repc_def repcs_def"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.cfg_on s\n\ngoal (1 subgoal):\n 1. state\n     (cfg_corec (reps (state cfg)) (\\<lambda>(s, cfg). rept s (action cfg))\n       (\\<lambda>(s, cfg) s'. (s', cont cfg (abss s')))\n       (reps (state cfg), cfg)) =\n    reps s", "by auto"], ["", "(* XXX Move *)"], ["", "lemma ccompatible_subs[intro]:\n  assumes \"ccompatible \\<R> g\" \"R \\<in> \\<R>\" \"u \\<in> R\" \"u \\<turnstile> g\"\n  shows \"R \\<subseteq> {u. u \\<turnstile> g}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<subseteq> {u. u \\<turnstile> g}", "using assms"], ["proof (prove)\nusing this:\n  ccompatible \\<R> g\n  R \\<in> \\<R>\n  u \\<in> R\n  u \\<turnstile> g\n\ngoal (1 subgoal):\n 1. R \\<subseteq> {u. u \\<turnstile> g}", "unfolding ccompatible_def"], ["proof (prove)\nusing this:\n  \\<forall>R\\<in>\\<R>.\n     R \\<subseteq> {v. v \\<turnstile> g} \\<or>\n     {v. v \\<turnstile> g} \\<inter> R = {}\n  R \\<in> \\<R>\n  u \\<in> R\n  u \\<turnstile> g\n\ngoal (1 subgoal):\n 1. R \\<subseteq> {u. u \\<turnstile> g}", "by auto"], ["", "lemma action_abscD[dest]:\n  \"cfg \\<in> MDP.cfg_on s \\<Longrightarrow> action (absc cfg) \\<in> \\<K> (abss s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cfg \\<in> MDP.cfg_on s \\<Longrightarrow>\n    action (absc cfg) \\<in> \\<K> (abss s)", "unfolding absc_def abst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cfg \\<in> MDP.cfg_on s \\<Longrightarrow>\n    action\n     (cfg_corec (abss (state cfg)) (map_pmf abss \\<circ> action)\n       (\\<lambda>cfg s.\n           cont cfg (THE x. abss x = s \\<and> x \\<in> set_pmf (action cfg)))\n       cfg)\n    \\<in> \\<K> (abss s)", "proof simp"], ["proof (state)\ngoal (1 subgoal):\n 1. cfg \\<in> MDP.cfg_on s \\<Longrightarrow>\n    map_pmf abss (action cfg) \\<in> \\<K> (abss s)", "assume cfg: \"cfg \\<in> MDP.cfg_on s\""], ["proof (state)\nthis:\n  cfg \\<in> MDP.cfg_on s\n\ngoal (1 subgoal):\n 1. cfg \\<in> MDP.cfg_on s \\<Longrightarrow>\n    map_pmf abss (action cfg) \\<in> \\<K> (abss s)", "then"], ["proof (chain)\npicking this:\n  cfg \\<in> MDP.cfg_on s", "have \"action cfg \\<in> K s\""], ["proof (prove)\nusing this:\n  cfg \\<in> MDP.cfg_on s\n\ngoal (1 subgoal):\n 1. action cfg \\<in> K s", "by auto"], ["proof (state)\nthis:\n  action cfg \\<in> K s\n\ngoal (1 subgoal):\n 1. cfg \\<in> MDP.cfg_on s \\<Longrightarrow>\n    map_pmf abss (action cfg) \\<in> \\<K> (abss s)", "then"], ["proof (chain)\npicking this:\n  action cfg \\<in> K s", "show \"map_pmf abss (action cfg) \\<in> \\<K> (abss s)\""], ["proof (prove)\nusing this:\n  action cfg \\<in> K s\n\ngoal (1 subgoal):\n 1. map_pmf abss (action cfg) \\<in> \\<K> (abss s)", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>l u t.\n       \\<lbrakk>action cfg = return_pmf (l, u \\<oplus> t); s \\<in> S;\n        s = (l, u); 0 \\<le> t;\n        u \\<oplus> t \\<turnstile> PTA.inv_of A l\\<rbrakk>\n       \\<Longrightarrow> map_pmf abss (action cfg) \\<in> \\<K> (abss s)\n 2. \\<And>l u g \\<mu>.\n       \\<lbrakk>action cfg =\n                map_pmf\n                 (\\<lambda>(X, l).\n                     (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n                 \\<mu>;\n        s \\<in> S; s = (l, u); (l, g, \\<mu>) \\<in> PTA.trans_of A;\n        u \\<turnstile> g\\<rbrakk>\n       \\<Longrightarrow> map_pmf abss (action cfg) \\<in> \\<K> (abss s)\n 3. action cfg = return_pmf s \\<Longrightarrow>\n    map_pmf abss (action cfg) \\<in> \\<K> (abss s)", "case prems: (delay l u t)"], ["proof (state)\nthis:\n  action cfg = return_pmf (l, u \\<oplus> t)\n  s \\<in> S\n  s = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l\n\ngoal (3 subgoals):\n 1. \\<And>l u t.\n       \\<lbrakk>action cfg = return_pmf (l, u \\<oplus> t); s \\<in> S;\n        s = (l, u); 0 \\<le> t;\n        u \\<oplus> t \\<turnstile> PTA.inv_of A l\\<rbrakk>\n       \\<Longrightarrow> map_pmf abss (action cfg) \\<in> \\<K> (abss s)\n 2. \\<And>l u g \\<mu>.\n       \\<lbrakk>action cfg =\n                map_pmf\n                 (\\<lambda>(X, l).\n                     (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n                 \\<mu>;\n        s \\<in> S; s = (l, u); (l, g, \\<mu>) \\<in> PTA.trans_of A;\n        u \\<turnstile> g\\<rbrakk>\n       \\<Longrightarrow> map_pmf abss (action cfg) \\<in> \\<K> (abss s)\n 3. action cfg = return_pmf s \\<Longrightarrow>\n    map_pmf abss (action cfg) \\<in> \\<K> (abss s)", "then"], ["proof (chain)\npicking this:\n  action cfg = return_pmf (l, u \\<oplus> t)\n  s \\<in> S\n  s = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l", "have \"[u \\<oplus> t]\\<^sub>\\<R> \\<in> \\<R>\""], ["proof (prove)\nusing this:\n  action cfg = return_pmf (l, u \\<oplus> t)\n  s \\<in> S\n  s = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l\n\ngoal (1 subgoal):\n 1. [u \\<oplus> t]\\<^sub>\\<R> \\<in> \\<R>", "by auto"], ["proof (state)\nthis:\n  [u \\<oplus> t]\\<^sub>\\<R> \\<in> \\<R>\n\ngoal (3 subgoals):\n 1. \\<And>l u t.\n       \\<lbrakk>action cfg = return_pmf (l, u \\<oplus> t); s \\<in> S;\n        s = (l, u); 0 \\<le> t;\n        u \\<oplus> t \\<turnstile> PTA.inv_of A l\\<rbrakk>\n       \\<Longrightarrow> map_pmf abss (action cfg) \\<in> \\<K> (abss s)\n 2. \\<And>l u g \\<mu>.\n       \\<lbrakk>action cfg =\n                map_pmf\n                 (\\<lambda>(X, l).\n                     (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n                 \\<mu>;\n        s \\<in> S; s = (l, u); (l, g, \\<mu>) \\<in> PTA.trans_of A;\n        u \\<turnstile> g\\<rbrakk>\n       \\<Longrightarrow> map_pmf abss (action cfg) \\<in> \\<K> (abss s)\n 3. action cfg = return_pmf s \\<Longrightarrow>\n    map_pmf abss (action cfg) \\<in> \\<K> (abss s)", "moreover"], ["proof (state)\nthis:\n  [u \\<oplus> t]\\<^sub>\\<R> \\<in> \\<R>\n\ngoal (3 subgoals):\n 1. \\<And>l u t.\n       \\<lbrakk>action cfg = return_pmf (l, u \\<oplus> t); s \\<in> S;\n        s = (l, u); 0 \\<le> t;\n        u \\<oplus> t \\<turnstile> PTA.inv_of A l\\<rbrakk>\n       \\<Longrightarrow> map_pmf abss (action cfg) \\<in> \\<K> (abss s)\n 2. \\<And>l u g \\<mu>.\n       \\<lbrakk>action cfg =\n                map_pmf\n                 (\\<lambda>(X, l).\n                     (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n                 \\<mu>;\n        s \\<in> S; s = (l, u); (l, g, \\<mu>) \\<in> PTA.trans_of A;\n        u \\<turnstile> g\\<rbrakk>\n       \\<Longrightarrow> map_pmf abss (action cfg) \\<in> \\<K> (abss s)\n 3. action cfg = return_pmf s \\<Longrightarrow>\n    map_pmf abss (action cfg) \\<in> \\<K> (abss s)", "with prems ccompatible_inv[of l]"], ["proof (chain)\npicking this:\n  action cfg = return_pmf (l, u \\<oplus> t)\n  s \\<in> S\n  s = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l\n  ccompatible \\<R> (PTA.inv_of A l)\n  [u \\<oplus> t]\\<^sub>\\<R> \\<in> \\<R>", "have\n      \"[u \\<oplus> t]\\<^sub>\\<R> \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\""], ["proof (prove)\nusing this:\n  action cfg = return_pmf (l, u \\<oplus> t)\n  s \\<in> S\n  s = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l\n  ccompatible \\<R> (PTA.inv_of A l)\n  [u \\<oplus> t]\\<^sub>\\<R> \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. [u \\<oplus> t]\\<^sub>\\<R> \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}", "unfolding ccompatible_def"], ["proof (prove)\nusing this:\n  action cfg = return_pmf (l, u \\<oplus> t)\n  s \\<in> S\n  s = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l\n  \\<forall>R\\<in>\\<R>.\n     R \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l} \\<or>\n     {v. v \\<turnstile> PTA.inv_of A l} \\<inter> R = {}\n  [u \\<oplus> t]\\<^sub>\\<R> \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. [u \\<oplus> t]\\<^sub>\\<R> \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}", "by force"], ["proof (state)\nthis:\n  [u \\<oplus> t]\\<^sub>\\<R> \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\n\ngoal (3 subgoals):\n 1. \\<And>l u t.\n       \\<lbrakk>action cfg = return_pmf (l, u \\<oplus> t); s \\<in> S;\n        s = (l, u); 0 \\<le> t;\n        u \\<oplus> t \\<turnstile> PTA.inv_of A l\\<rbrakk>\n       \\<Longrightarrow> map_pmf abss (action cfg) \\<in> \\<K> (abss s)\n 2. \\<And>l u g \\<mu>.\n       \\<lbrakk>action cfg =\n                map_pmf\n                 (\\<lambda>(X, l).\n                     (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n                 \\<mu>;\n        s \\<in> S; s = (l, u); (l, g, \\<mu>) \\<in> PTA.trans_of A;\n        u \\<turnstile> g\\<rbrakk>\n       \\<Longrightarrow> map_pmf abss (action cfg) \\<in> \\<K> (abss s)\n 3. action cfg = return_pmf s \\<Longrightarrow>\n    map_pmf abss (action cfg) \\<in> \\<K> (abss s)", "moreover"], ["proof (state)\nthis:\n  [u \\<oplus> t]\\<^sub>\\<R> \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\n\ngoal (3 subgoals):\n 1. \\<And>l u t.\n       \\<lbrakk>action cfg = return_pmf (l, u \\<oplus> t); s \\<in> S;\n        s = (l, u); 0 \\<le> t;\n        u \\<oplus> t \\<turnstile> PTA.inv_of A l\\<rbrakk>\n       \\<Longrightarrow> map_pmf abss (action cfg) \\<in> \\<K> (abss s)\n 2. \\<And>l u g \\<mu>.\n       \\<lbrakk>action cfg =\n                map_pmf\n                 (\\<lambda>(X, l).\n                     (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n                 \\<mu>;\n        s \\<in> S; s = (l, u); (l, g, \\<mu>) \\<in> PTA.trans_of A;\n        u \\<turnstile> g\\<rbrakk>\n       \\<Longrightarrow> map_pmf abss (action cfg) \\<in> \\<K> (abss s)\n 3. action cfg = return_pmf s \\<Longrightarrow>\n    map_pmf abss (action cfg) \\<in> \\<K> (abss s)", "from prems"], ["proof (chain)\npicking this:\n  action cfg = return_pmf (l, u \\<oplus> t)\n  s \\<in> S\n  s = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l", "have \"abss (l, u \\<oplus> t) = (l, [u \\<oplus> t]\\<^sub>\\<R>)\""], ["proof (prove)\nusing this:\n  action cfg = return_pmf (l, u \\<oplus> t)\n  s \\<in> S\n  s = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l\n\ngoal (1 subgoal):\n 1. abss (l, u \\<oplus> t) = (l, [u \\<oplus> t]\\<^sub>\\<R>)", "by (subst abss_S) auto"], ["proof (state)\nthis:\n  abss (l, u \\<oplus> t) = (l, [u \\<oplus> t]\\<^sub>\\<R>)\n\ngoal (3 subgoals):\n 1. \\<And>l u t.\n       \\<lbrakk>action cfg = return_pmf (l, u \\<oplus> t); s \\<in> S;\n        s = (l, u); 0 \\<le> t;\n        u \\<oplus> t \\<turnstile> PTA.inv_of A l\\<rbrakk>\n       \\<Longrightarrow> map_pmf abss (action cfg) \\<in> \\<K> (abss s)\n 2. \\<And>l u g \\<mu>.\n       \\<lbrakk>action cfg =\n                map_pmf\n                 (\\<lambda>(X, l).\n                     (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n                 \\<mu>;\n        s \\<in> S; s = (l, u); (l, g, \\<mu>) \\<in> PTA.trans_of A;\n        u \\<turnstile> g\\<rbrakk>\n       \\<Longrightarrow> map_pmf abss (action cfg) \\<in> \\<K> (abss s)\n 3. action cfg = return_pmf s \\<Longrightarrow>\n    map_pmf abss (action cfg) \\<in> \\<K> (abss s)", "ultimately"], ["proof (chain)\npicking this:\n  [u \\<oplus> t]\\<^sub>\\<R> \\<in> \\<R>\n  [u \\<oplus> t]\\<^sub>\\<R> \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\n  abss (l, u \\<oplus> t) = (l, [u \\<oplus> t]\\<^sub>\\<R>)", "show ?thesis"], ["proof (prove)\nusing this:\n  [u \\<oplus> t]\\<^sub>\\<R> \\<in> \\<R>\n  [u \\<oplus> t]\\<^sub>\\<R> \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\n  abss (l, u \\<oplus> t) = (l, [u \\<oplus> t]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. map_pmf abss (action cfg) \\<in> \\<K> (abss s)", "using prems"], ["proof (prove)\nusing this:\n  [u \\<oplus> t]\\<^sub>\\<R> \\<in> \\<R>\n  [u \\<oplus> t]\\<^sub>\\<R> \\<subseteq> {v. v \\<turnstile> PTA.inv_of A l}\n  abss (l, u \\<oplus> t) = (l, [u \\<oplus> t]\\<^sub>\\<R>)\n  action cfg = return_pmf (l, u \\<oplus> t)\n  s \\<in> S\n  s = (l, u)\n  0 \\<le> t\n  u \\<oplus> t \\<turnstile> PTA.inv_of A l\n\ngoal (1 subgoal):\n 1. map_pmf abss (action cfg) \\<in> \\<K> (abss s)", "by auto"], ["proof (state)\nthis:\n  map_pmf abss (action cfg) \\<in> \\<K> (abss s)\n\ngoal (2 subgoals):\n 1. \\<And>l u g \\<mu>.\n       \\<lbrakk>action cfg =\n                map_pmf\n                 (\\<lambda>(X, l).\n                     (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n                 \\<mu>;\n        s \\<in> S; s = (l, u); (l, g, \\<mu>) \\<in> PTA.trans_of A;\n        u \\<turnstile> g\\<rbrakk>\n       \\<Longrightarrow> map_pmf abss (action cfg) \\<in> \\<K> (abss s)\n 2. action cfg = return_pmf s \\<Longrightarrow>\n    map_pmf abss (action cfg) \\<in> \\<K> (abss s)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l u g \\<mu>.\n       \\<lbrakk>action cfg =\n                map_pmf\n                 (\\<lambda>(X, l).\n                     (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n                 \\<mu>;\n        s \\<in> S; s = (l, u); (l, g, \\<mu>) \\<in> PTA.trans_of A;\n        u \\<turnstile> g\\<rbrakk>\n       \\<Longrightarrow> map_pmf abss (action cfg) \\<in> \\<K> (abss s)\n 2. action cfg = return_pmf s \\<Longrightarrow>\n    map_pmf abss (action cfg) \\<in> \\<K> (abss s)", "case prems: (action l u g \\<mu>)"], ["proof (state)\nthis:\n  action cfg =\n  map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u)) \\<mu>\n  s \\<in> S\n  s = (l, u)\n  (l, g, \\<mu>) \\<in> PTA.trans_of A\n  u \\<turnstile> g\n\ngoal (2 subgoals):\n 1. \\<And>l u g \\<mu>.\n       \\<lbrakk>action cfg =\n                map_pmf\n                 (\\<lambda>(X, l).\n                     (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n                 \\<mu>;\n        s \\<in> S; s = (l, u); (l, g, \\<mu>) \\<in> PTA.trans_of A;\n        u \\<turnstile> g\\<rbrakk>\n       \\<Longrightarrow> map_pmf abss (action cfg) \\<in> \\<K> (abss s)\n 2. action cfg = return_pmf s \\<Longrightarrow>\n    map_pmf abss (action cfg) \\<in> \\<K> (abss s)", "then"], ["proof (chain)\npicking this:\n  action cfg =\n  map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u)) \\<mu>\n  s \\<in> S\n  s = (l, u)\n  (l, g, \\<mu>) \\<in> PTA.trans_of A\n  u \\<turnstile> g", "have \"[u]\\<^sub>\\<R> \\<in> \\<R>\""], ["proof (prove)\nusing this:\n  action cfg =\n  map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u)) \\<mu>\n  s \\<in> S\n  s = (l, u)\n  (l, g, \\<mu>) \\<in> PTA.trans_of A\n  u \\<turnstile> g\n\ngoal (1 subgoal):\n 1. [u]\\<^sub>\\<R> \\<in> \\<R>", "by auto"], ["proof (state)\nthis:\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n\ngoal (2 subgoals):\n 1. \\<And>l u g \\<mu>.\n       \\<lbrakk>action cfg =\n                map_pmf\n                 (\\<lambda>(X, l).\n                     (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n                 \\<mu>;\n        s \\<in> S; s = (l, u); (l, g, \\<mu>) \\<in> PTA.trans_of A;\n        u \\<turnstile> g\\<rbrakk>\n       \\<Longrightarrow> map_pmf abss (action cfg) \\<in> \\<K> (abss s)\n 2. action cfg = return_pmf s \\<Longrightarrow>\n    map_pmf abss (action cfg) \\<in> \\<K> (abss s)", "moreover"], ["proof (state)\nthis:\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n\ngoal (2 subgoals):\n 1. \\<And>l u g \\<mu>.\n       \\<lbrakk>action cfg =\n                map_pmf\n                 (\\<lambda>(X, l).\n                     (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n                 \\<mu>;\n        s \\<in> S; s = (l, u); (l, g, \\<mu>) \\<in> PTA.trans_of A;\n        u \\<turnstile> g\\<rbrakk>\n       \\<Longrightarrow> map_pmf abss (action cfg) \\<in> \\<K> (abss s)\n 2. action cfg = return_pmf s \\<Longrightarrow>\n    map_pmf abss (action cfg) \\<in> \\<K> (abss s)", "with prems ccompatible_guard"], ["proof (chain)\npicking this:\n  action cfg =\n  map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u)) \\<mu>\n  s \\<in> S\n  s = (l, u)\n  (l, g, \\<mu>) \\<in> PTA.trans_of A\n  u \\<turnstile> g\n  (?l, ?g, ?\\<mu>) \\<in> PTA.trans_of A \\<Longrightarrow>\n  ccompatible \\<R> ?g\n  [u]\\<^sub>\\<R> \\<in> \\<R>", "have \"[u]\\<^sub>\\<R> \\<subseteq> {u. u \\<turnstile> g}\""], ["proof (prove)\nusing this:\n  action cfg =\n  map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u)) \\<mu>\n  s \\<in> S\n  s = (l, u)\n  (l, g, \\<mu>) \\<in> PTA.trans_of A\n  u \\<turnstile> g\n  (?l, ?g, ?\\<mu>) \\<in> PTA.trans_of A \\<Longrightarrow>\n  ccompatible \\<R> ?g\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. [u]\\<^sub>\\<R> \\<subseteq> {u. u \\<turnstile> g}", "by (intro ccompatible_subs) auto"], ["proof (state)\nthis:\n  [u]\\<^sub>\\<R> \\<subseteq> {u. u \\<turnstile> g}\n\ngoal (2 subgoals):\n 1. \\<And>l u g \\<mu>.\n       \\<lbrakk>action cfg =\n                map_pmf\n                 (\\<lambda>(X, l).\n                     (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n                 \\<mu>;\n        s \\<in> S; s = (l, u); (l, g, \\<mu>) \\<in> PTA.trans_of A;\n        u \\<turnstile> g\\<rbrakk>\n       \\<Longrightarrow> map_pmf abss (action cfg) \\<in> \\<K> (abss s)\n 2. action cfg = return_pmf s \\<Longrightarrow>\n    map_pmf abss (action cfg) \\<in> \\<K> (abss s)", "moreover"], ["proof (state)\nthis:\n  [u]\\<^sub>\\<R> \\<subseteq> {u. u \\<turnstile> g}\n\ngoal (2 subgoals):\n 1. \\<And>l u g \\<mu>.\n       \\<lbrakk>action cfg =\n                map_pmf\n                 (\\<lambda>(X, l).\n                     (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n                 \\<mu>;\n        s \\<in> S; s = (l, u); (l, g, \\<mu>) \\<in> PTA.trans_of A;\n        u \\<turnstile> g\\<rbrakk>\n       \\<Longrightarrow> map_pmf abss (action cfg) \\<in> \\<K> (abss s)\n 2. action cfg = return_pmf s \\<Longrightarrow>\n    map_pmf abss (action cfg) \\<in> \\<K> (abss s)", "have\n      \"map_pmf abss (action cfg)\n      = map_pmf (\\<lambda>(X, l). (l, region_set' ([u]\\<^sub>\\<R>) (SOME r. set r = X) 0)) \\<mu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf abss (action cfg) =\n    map_pmf (\\<lambda>(X, l). (l, [X::=0]([u]\\<^sub>\\<R>))) \\<mu>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_pmf abss (action cfg) =\n    map_pmf (\\<lambda>(X, l). (l, [X::=0]([u]\\<^sub>\\<R>))) \\<mu>", "have \"abss (l', [X:=0]u) = (l', region_set' ([u]\\<^sub>\\<R>) (SOME r. set r = X) 0)\"\n        if \"(X, l') \\<in> \\<mu>\" for X l'"], ["proof (prove)\ngoal (1 subgoal):\n 1. abss (l', [(SOME r. set r = X)\\<rightarrow>0]u) =\n    (l', [X::=0]([u]\\<^sub>\\<R>))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. abss (l', [(SOME r. set r = X)\\<rightarrow>0]u) =\n    (l', [X::=0]([u]\\<^sub>\\<R>))", "from that prems"], ["proof (chain)\npicking this:\n  (X, l') \\<in> set_pmf \\<mu>\n  action cfg =\n  map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u)) \\<mu>\n  s \\<in> S\n  s = (l, u)\n  (l, g, \\<mu>) \\<in> PTA.trans_of A\n  u \\<turnstile> g", "have \"A \\<turnstile> l \\<longrightarrow>\\<^bsup>g,\\<mu>,X\\<^esup> l'\""], ["proof (prove)\nusing this:\n  (X, l') \\<in> set_pmf \\<mu>\n  action cfg =\n  map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u)) \\<mu>\n  s \\<in> S\n  s = (l, u)\n  (l, g, \\<mu>) \\<in> PTA.trans_of A\n  u \\<turnstile> g\n\ngoal (1 subgoal):\n 1. A \\<turnstile> l \\<longrightarrow>\\<^bsup>g,\\<mu>,X\\<^esup> l'", "by auto"], ["proof (state)\nthis:\n  A \\<turnstile> l \\<longrightarrow>\\<^bsup>g,\\<mu>,X\\<^esup> l'\n\ngoal (1 subgoal):\n 1. abss (l', [(SOME r. set r = X)\\<rightarrow>0]u) =\n    (l', [X::=0]([u]\\<^sub>\\<R>))", "from that prems MDP.action_closed[OF _ cfg]"], ["proof (chain)\npicking this:\n  (X, l') \\<in> set_pmf \\<mu>\n  action cfg =\n  map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u)) \\<mu>\n  s \\<in> S\n  s = (l, u)\n  (l, g, \\<mu>) \\<in> PTA.trans_of A\n  u \\<turnstile> g\n  \\<lbrakk>s \\<in> S; ?t \\<in> set_pmf (action cfg)\\<rbrakk>\n  \\<Longrightarrow> ?t \\<in> S", "have \"(l', [X:=0]u) \\<in> S\""], ["proof (prove)\nusing this:\n  (X, l') \\<in> set_pmf \\<mu>\n  action cfg =\n  map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u)) \\<mu>\n  s \\<in> S\n  s = (l, u)\n  (l, g, \\<mu>) \\<in> PTA.trans_of A\n  u \\<turnstile> g\n  \\<lbrakk>s \\<in> S; ?t \\<in> set_pmf (action cfg)\\<rbrakk>\n  \\<Longrightarrow> ?t \\<in> S\n\ngoal (1 subgoal):\n 1. (l', [(SOME r. set r = X)\\<rightarrow>0]u) \\<in> S", "by force"], ["proof (state)\nthis:\n  (l', [(SOME r. set r = X)\\<rightarrow>0]u) \\<in> S\n\ngoal (1 subgoal):\n 1. abss (l', [(SOME r. set r = X)\\<rightarrow>0]u) =\n    (l', [X::=0]([u]\\<^sub>\\<R>))", "then"], ["proof (chain)\npicking this:\n  (l', [(SOME r. set r = X)\\<rightarrow>0]u) \\<in> S", "have \"abss (l', [X:=0]u) = (l', [[X:=0]u]\\<^sub>\\<R>)\""], ["proof (prove)\nusing this:\n  (l', [(SOME r. set r = X)\\<rightarrow>0]u) \\<in> S\n\ngoal (1 subgoal):\n 1. abss (l', [(SOME r. set r = X)\\<rightarrow>0]u) =\n    (l', [[(SOME r. set r = X)\\<rightarrow>0]u]\\<^sub>\\<R>)", "by auto"], ["proof (state)\nthis:\n  abss (l', [(SOME r. set r = X)\\<rightarrow>0]u) =\n  (l', [[(SOME r. set r = X)\\<rightarrow>0]u]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. abss (l', [(SOME r. set r = X)\\<rightarrow>0]u) =\n    (l', [X::=0]([u]\\<^sub>\\<R>))", "also"], ["proof (state)\nthis:\n  abss (l', [(SOME r. set r = X)\\<rightarrow>0]u) =\n  (l', [[(SOME r. set r = X)\\<rightarrow>0]u]\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. abss (l', [(SOME r. set r = X)\\<rightarrow>0]u) =\n    (l', [X::=0]([u]\\<^sub>\\<R>))", "have\n          \"\\<dots> = (l', region_set' ([u]\\<^sub>\\<R>) (SOME r. set r = X) 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l', [[(SOME r. set r = X)\\<rightarrow>0]u]\\<^sub>\\<R>) =\n    (l', [X::=0]([u]\\<^sub>\\<R>))", "using region_set'_eq(1)[OF _ _ \\<open>A \\<turnstile> l \\<longrightarrow>\\<^bsup>g,\\<mu>,X\\<^esup> l'\\<close>] prems"], ["proof (prove)\nusing this:\n  \\<lbrakk>?R \\<in> \\<R>; ?u \\<in> ?R\\<rbrakk>\n  \\<Longrightarrow> [[(SOME r. set r = X)\\<rightarrow>0]?u]\\<^sub>\\<R> =\n                    [X::=0]?R\n  action cfg =\n  map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u)) \\<mu>\n  s \\<in> S\n  s = (l, u)\n  (l, g, \\<mu>) \\<in> PTA.trans_of A\n  u \\<turnstile> g\n\ngoal (1 subgoal):\n 1. (l', [[(SOME r. set r = X)\\<rightarrow>0]u]\\<^sub>\\<R>) =\n    (l', [X::=0]([u]\\<^sub>\\<R>))", "by auto"], ["proof (state)\nthis:\n  (l', [[(SOME r. set r = X)\\<rightarrow>0]u]\\<^sub>\\<R>) =\n  (l', [X::=0]([u]\\<^sub>\\<R>))\n\ngoal (1 subgoal):\n 1. abss (l', [(SOME r. set r = X)\\<rightarrow>0]u) =\n    (l', [X::=0]([u]\\<^sub>\\<R>))", "finally"], ["proof (chain)\npicking this:\n  abss (l', [(SOME r. set r = X)\\<rightarrow>0]u) =\n  (l', [X::=0]([u]\\<^sub>\\<R>))", "show ?thesis"], ["proof (prove)\nusing this:\n  abss (l', [(SOME r. set r = X)\\<rightarrow>0]u) =\n  (l', [X::=0]([u]\\<^sub>\\<R>))\n\ngoal (1 subgoal):\n 1. abss (l', [(SOME r. set r = X)\\<rightarrow>0]u) =\n    (l', [X::=0]([u]\\<^sub>\\<R>))", "."], ["proof (state)\nthis:\n  abss (l', [(SOME r. set r = X)\\<rightarrow>0]u) =\n  (l', [X::=0]([u]\\<^sub>\\<R>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?X5, ?l'5) \\<in> set_pmf \\<mu> \\<Longrightarrow>\n  abss (?l'5, [(SOME r. set r = ?X5)\\<rightarrow>0]u) =\n  (?l'5, [?X5::=0]([u]\\<^sub>\\<R>))\n\ngoal (1 subgoal):\n 1. map_pmf abss (action cfg) =\n    map_pmf (\\<lambda>(X, l). (l, [X::=0]([u]\\<^sub>\\<R>))) \\<mu>", "then"], ["proof (chain)\npicking this:\n  (?X5, ?l'5) \\<in> set_pmf \\<mu> \\<Longrightarrow>\n  abss (?l'5, [(SOME r. set r = ?X5)\\<rightarrow>0]u) =\n  (?l'5, [?X5::=0]([u]\\<^sub>\\<R>))", "show ?thesis"], ["proof (prove)\nusing this:\n  (?X5, ?l'5) \\<in> set_pmf \\<mu> \\<Longrightarrow>\n  abss (?l'5, [(SOME r. set r = ?X5)\\<rightarrow>0]u) =\n  (?l'5, [?X5::=0]([u]\\<^sub>\\<R>))\n\ngoal (1 subgoal):\n 1. map_pmf abss (action cfg) =\n    map_pmf (\\<lambda>(X, l). (l, [X::=0]([u]\\<^sub>\\<R>))) \\<mu>", "unfolding prems(1)"], ["proof (prove)\nusing this:\n  (?X5, ?l'5) \\<in> set_pmf \\<mu> \\<Longrightarrow>\n  abss (?l'5, [(SOME r. set r = ?X5)\\<rightarrow>0]u) =\n  (?l'5, [?X5::=0]([u]\\<^sub>\\<R>))\n\ngoal (1 subgoal):\n 1. map_pmf abss\n     (map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n       \\<mu>) =\n    map_pmf (\\<lambda>(X, l). (l, [X::=0]([u]\\<^sub>\\<R>))) \\<mu>", "by (auto intro: pmf.map_cong simp: map_pmf_comp)"], ["proof (state)\nthis:\n  map_pmf abss (action cfg) =\n  map_pmf (\\<lambda>(X, l). (l, [X::=0]([u]\\<^sub>\\<R>))) \\<mu>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_pmf abss (action cfg) =\n  map_pmf (\\<lambda>(X, l). (l, [X::=0]([u]\\<^sub>\\<R>))) \\<mu>\n\ngoal (2 subgoals):\n 1. \\<And>l u g \\<mu>.\n       \\<lbrakk>action cfg =\n                map_pmf\n                 (\\<lambda>(X, l).\n                     (l, [(SOME r. set r = X)\\<rightarrow>0]u))\n                 \\<mu>;\n        s \\<in> S; s = (l, u); (l, g, \\<mu>) \\<in> PTA.trans_of A;\n        u \\<turnstile> g\\<rbrakk>\n       \\<Longrightarrow> map_pmf abss (action cfg) \\<in> \\<K> (abss s)\n 2. action cfg = return_pmf s \\<Longrightarrow>\n    map_pmf abss (action cfg) \\<in> \\<K> (abss s)", "ultimately"], ["proof (chain)\npicking this:\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  [u]\\<^sub>\\<R> \\<subseteq> {u. u \\<turnstile> g}\n  map_pmf abss (action cfg) =\n  map_pmf (\\<lambda>(X, l). (l, [X::=0]([u]\\<^sub>\\<R>))) \\<mu>", "show ?thesis"], ["proof (prove)\nusing this:\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  [u]\\<^sub>\\<R> \\<subseteq> {u. u \\<turnstile> g}\n  map_pmf abss (action cfg) =\n  map_pmf (\\<lambda>(X, l). (l, [X::=0]([u]\\<^sub>\\<R>))) \\<mu>\n\ngoal (1 subgoal):\n 1. map_pmf abss (action cfg) \\<in> \\<K> (abss s)", "using prems"], ["proof (prove)\nusing this:\n  [u]\\<^sub>\\<R> \\<in> \\<R>\n  [u]\\<^sub>\\<R> \\<subseteq> {u. u \\<turnstile> g}\n  map_pmf abss (action cfg) =\n  map_pmf (\\<lambda>(X, l). (l, [X::=0]([u]\\<^sub>\\<R>))) \\<mu>\n  action cfg =\n  map_pmf (\\<lambda>(X, l). (l, [(SOME r. set r = X)\\<rightarrow>0]u)) \\<mu>\n  s \\<in> S\n  s = (l, u)\n  (l, g, \\<mu>) \\<in> PTA.trans_of A\n  u \\<turnstile> g\n\ngoal (1 subgoal):\n 1. map_pmf abss (action cfg) \\<in> \\<K> (abss s)", "by auto"], ["proof (state)\nthis:\n  map_pmf abss (action cfg) \\<in> \\<K> (abss s)\n\ngoal (1 subgoal):\n 1. action cfg = return_pmf s \\<Longrightarrow>\n    map_pmf abss (action cfg) \\<in> \\<K> (abss s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. action cfg = return_pmf s \\<Longrightarrow>\n    map_pmf abss (action cfg) \\<in> \\<K> (abss s)", "case prems: loop"], ["proof (state)\nthis:\n  action cfg = return_pmf s\n\ngoal (1 subgoal):\n 1. action cfg = return_pmf s \\<Longrightarrow>\n    map_pmf abss (action cfg) \\<in> \\<K> (abss s)", "then"], ["proof (chain)\npicking this:\n  action cfg = return_pmf s", "show ?thesis"], ["proof (prove)\nusing this:\n  action cfg = return_pmf s\n\ngoal (1 subgoal):\n 1. map_pmf abss (action cfg) \\<in> \\<K> (abss s)", "by auto"], ["proof (state)\nthis:\n  map_pmf abss (action cfg) \\<in> \\<K> (abss s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_pmf abss (action cfg) \\<in> \\<K> (abss s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma repcs_valid[intro]:\n  assumes \"cfg \\<in> R_G.valid_cfg\" \"abss s = state cfg\"\n  shows \"repcs s cfg \\<in> valid_cfg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. repcs s cfg \\<in> MDP.valid_cfg", "using assms"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n\ngoal (1 subgoal):\n 1. repcs s cfg \\<in> MDP.valid_cfg", "proof (coinduction arbitrary: cfg s)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cfga s.\n       \\<lbrakk>cfga \\<in> R_G.valid_cfg; abss s = state cfga\\<rbrakk>\n       \\<Longrightarrow> state (repcs s cfga) \\<in> S\n 2. \\<And>cfga s.\n       \\<lbrakk>cfga \\<in> R_G.valid_cfg; abss s = state cfga\\<rbrakk>\n       \\<Longrightarrow> action (repcs s cfga)\n                         \\<in> K (state (repcs s cfga))\n 3. \\<And>t cfga s.\n       \\<lbrakk>cfga \\<in> R_G.valid_cfg; abss s = state cfga;\n        t \\<in> set_pmf (action (repcs s cfga))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg sa.\n                            cont (repcs s cfga) t = repcs sa cfg \\<and>\n                            cfg \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfg", "case 1"], ["proof (state)\nthis:\n  cfga \\<in> R_G.valid_cfg\n  abss s = state cfga\n\ngoal (3 subgoals):\n 1. \\<And>cfga s.\n       \\<lbrakk>cfga \\<in> R_G.valid_cfg; abss s = state cfga\\<rbrakk>\n       \\<Longrightarrow> state (repcs s cfga) \\<in> S\n 2. \\<And>cfga s.\n       \\<lbrakk>cfga \\<in> R_G.valid_cfg; abss s = state cfga\\<rbrakk>\n       \\<Longrightarrow> action (repcs s cfga)\n                         \\<in> K (state (repcs s cfga))\n 3. \\<And>t cfga s.\n       \\<lbrakk>cfga \\<in> R_G.valid_cfg; abss s = state cfga;\n        t \\<in> set_pmf (action (repcs s cfga))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg sa.\n                            cont (repcs s cfga) t = repcs sa cfg \\<and>\n                            cfg \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfg", "then"], ["proof (chain)\npicking this:\n  cfga \\<in> R_G.valid_cfg\n  abss s = state cfga", "show ?case"], ["proof (prove)\nusing this:\n  cfga \\<in> R_G.valid_cfg\n  abss s = state cfga\n\ngoal (1 subgoal):\n 1. state (repcs s cfga) \\<in> S", "by (auto simp: repcs_def \\<S>_abss_S dest: R_G.valid_cfg_state_in_S)"], ["proof (state)\nthis:\n  state (repcs s cfga) \\<in> S\n\ngoal (2 subgoals):\n 1. \\<And>cfga s.\n       \\<lbrakk>cfga \\<in> R_G.valid_cfg; abss s = state cfga\\<rbrakk>\n       \\<Longrightarrow> action (repcs s cfga)\n                         \\<in> K (state (repcs s cfga))\n 2. \\<And>t cfga s.\n       \\<lbrakk>cfga \\<in> R_G.valid_cfg; abss s = state cfga;\n        t \\<in> set_pmf (action (repcs s cfga))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg sa.\n                            cont (repcs s cfga) t = repcs sa cfg \\<and>\n                            cfg \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfg", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cfga s.\n       \\<lbrakk>cfga \\<in> R_G.valid_cfg; abss s = state cfga\\<rbrakk>\n       \\<Longrightarrow> action (repcs s cfga)\n                         \\<in> K (state (repcs s cfga))\n 2. \\<And>t cfga s.\n       \\<lbrakk>cfga \\<in> R_G.valid_cfg; abss s = state cfga;\n        t \\<in> set_pmf (action (repcs s cfga))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg sa.\n                            cont (repcs s cfga) t = repcs sa cfg \\<and>\n                            cfg \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfg", "case (2 cfg' s)"], ["proof (state)\nthis:\n  cfg' \\<in> R_G.valid_cfg\n  abss s = state cfg'\n\ngoal (2 subgoals):\n 1. \\<And>cfga s.\n       \\<lbrakk>cfga \\<in> R_G.valid_cfg; abss s = state cfga\\<rbrakk>\n       \\<Longrightarrow> action (repcs s cfga)\n                         \\<in> K (state (repcs s cfga))\n 2. \\<And>t cfga s.\n       \\<lbrakk>cfga \\<in> R_G.valid_cfg; abss s = state cfga;\n        t \\<in> set_pmf (action (repcs s cfga))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg sa.\n                            cont (repcs s cfga) t = repcs sa cfg \\<and>\n                            cfg \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfg", "then"], ["proof (chain)\npicking this:\n  cfg' \\<in> R_G.valid_cfg\n  abss s = state cfg'", "show ?case"], ["proof (prove)\nusing this:\n  cfg' \\<in> R_G.valid_cfg\n  abss s = state cfg'\n\ngoal (1 subgoal):\n 1. action (repcs s cfg') \\<in> K (state (repcs s cfg'))", "by (simp add: repcs_def) (rule rept_K, auto dest: R_G.valid_cfgD)"], ["proof (state)\nthis:\n  action (repcs s cfg') \\<in> K (state (repcs s cfg'))\n\ngoal (1 subgoal):\n 1. \\<And>t cfga s.\n       \\<lbrakk>cfga \\<in> R_G.valid_cfg; abss s = state cfga;\n        t \\<in> set_pmf (action (repcs s cfga))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg sa.\n                            cont (repcs s cfga) t = repcs sa cfg \\<and>\n                            cfg \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfg", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t cfga s.\n       \\<lbrakk>cfga \\<in> R_G.valid_cfg; abss s = state cfga;\n        t \\<in> set_pmf (action (repcs s cfga))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg sa.\n                            cont (repcs s cfga) t = repcs sa cfg \\<and>\n                            cfg \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfg", "case prems: (3 s' cfg)"], ["proof (state)\nthis:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  s' \\<in> set_pmf (action (repcs s cfg))\n\ngoal (1 subgoal):\n 1. \\<And>t cfga s.\n       \\<lbrakk>cfga \\<in> R_G.valid_cfg; abss s = state cfga;\n        t \\<in> set_pmf (action (repcs s cfga))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg sa.\n                            cont (repcs s cfga) t = repcs sa cfg \\<and>\n                            cfg \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfg", "let ?cfg = \"cont cfg (abss s')\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t cfga s.\n       \\<lbrakk>cfga \\<in> R_G.valid_cfg; abss s = state cfga;\n        t \\<in> set_pmf (action (repcs s cfga))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg sa.\n                            cont (repcs s cfga) t = repcs sa cfg \\<and>\n                            cfg \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfg", "from prems"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  s' \\<in> set_pmf (action (repcs s cfg))", "have \"abss s' \\<in> abst (rept s (action cfg))\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  s' \\<in> set_pmf (action (repcs s cfg))\n\ngoal (1 subgoal):\n 1. abss s' \\<in> set_pmf (abst (rept s (action cfg)))", "unfolding repcs_def abst_def"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  s' \\<in> set_pmf\n            (action\n              (cfg_corec s (\\<lambda>(s, cfg). rept s (action cfg))\n                (\\<lambda>(s, cfg) s'. (s', cont cfg (abss s'))) (s, cfg)))\n\ngoal (1 subgoal):\n 1. abss s' \\<in> set_pmf (map_pmf abss (rept s (action cfg)))", "by auto"], ["proof (state)\nthis:\n  abss s' \\<in> set_pmf (abst (rept s (action cfg)))\n\ngoal (1 subgoal):\n 1. \\<And>t cfga s.\n       \\<lbrakk>cfga \\<in> R_G.valid_cfg; abss s = state cfga;\n        t \\<in> set_pmf (action (repcs s cfga))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg sa.\n                            cont (repcs s cfga) t = repcs sa cfg \\<and>\n                            cfg \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfg", "with prems"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  s' \\<in> set_pmf (action (repcs s cfg))\n  abss s' \\<in> set_pmf (abst (rept s (action cfg)))", "have\n    \"abss s' \\<in> action cfg\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  s' \\<in> set_pmf (action (repcs s cfg))\n  abss s' \\<in> set_pmf (abst (rept s (action cfg)))\n\ngoal (1 subgoal):\n 1. abss s' \\<in> set_pmf (action cfg)", "by (subst (asm) abst_rept_id) (auto dest: R_G.valid_cfgD)"], ["proof (state)\nthis:\n  abss s' \\<in> set_pmf (action cfg)\n\ngoal (1 subgoal):\n 1. \\<And>t cfga s.\n       \\<lbrakk>cfga \\<in> R_G.valid_cfg; abss s = state cfga;\n        t \\<in> set_pmf (action (repcs s cfga))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg sa.\n                            cont (repcs s cfga) t = repcs sa cfg \\<and>\n                            cfg \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfg", "with prems"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  s' \\<in> set_pmf (action (repcs s cfg))\n  abss s' \\<in> set_pmf (action cfg)", "show ?case"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  s' \\<in> set_pmf (action (repcs s cfg))\n  abss s' \\<in> set_pmf (action cfg)\n\ngoal (1 subgoal):\n 1. \\<exists>cfg s.\n       cont (repcs s cfg) s' = repcs s cfg \\<and>\n       cfg \\<in> R_G.valid_cfg \\<and> abss s = state cfg", "by (inst_existentials ?cfg s', subst cont_repcs1)\n       (auto dest: R_G.valid_cfg_state_in_S intro: R_G.valid_cfgD R_G.valid_cfg_cont)"], ["proof (state)\nthis:\n  \\<exists>cfg s.\n     cont (repcs s cfg) s' = repcs s cfg \\<and>\n     cfg \\<in> R_G.valid_cfg \\<and> abss s = state cfg\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma repc_valid[intro]:\n  assumes \"cfg \\<in> R_G.valid_cfg\"\n  shows \"repc cfg \\<in> valid_cfg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. repc cfg \\<in> MDP.valid_cfg", "using assms"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n\ngoal (1 subgoal):\n 1. repc cfg \\<in> MDP.valid_cfg", "unfolding repc_def"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n\ngoal (1 subgoal):\n 1. repcs (reps (state cfg)) cfg \\<in> MDP.valid_cfg", "by (force dest: R_G.valid_cfg_state_in_S)"], ["", "lemma action_abst_repcs:\n  assumes \"cfg \\<in> R_G.valid_cfg\" \"abss s = state cfg\"\n  shows \"abst (action (repcs s cfg)) = action cfg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abst (action (repcs s cfg)) = action cfg", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. abst (action (repcs s cfg)) = action cfg", "from assms"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg", "show ?thesis"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n\ngoal (1 subgoal):\n 1. abst (action (repcs s cfg)) = action cfg", "unfolding repc_def repcs_def"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n\ngoal (1 subgoal):\n 1. abst\n     (action\n       (cfg_corec s (\\<lambda>(s, cfg). rept s (action cfg))\n         (\\<lambda>(s, cfg) s'. (s', cont cfg (abss s'))) (s, cfg))) =\n    action cfg", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n    \\<Longrightarrow> abst (rept s (action cfg)) = action cfg", "apply (subst abst_rept_id)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n    \\<Longrightarrow> action cfg \\<in> \\<K> (abss s)\n 2. \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n    \\<Longrightarrow> action cfg = action cfg", "by (auto dest: R_G.cfg_onD_action R_G.valid_cfgD)"], ["proof (state)\nthis:\n  abst (action (repcs s cfg)) = action cfg\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma action_abst_repc:\n  assumes \"cfg \\<in> R_G.valid_cfg\"\n  shows \"abst (action (repc cfg)) = action cfg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abst (action (repc cfg)) = action cfg", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. abst (action (repc cfg)) = action cfg", "from assms"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.valid_cfg", "have \"abss (reps (state cfg)) = state cfg\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n\ngoal (1 subgoal):\n 1. abss (reps (state cfg)) = state cfg", "by (auto dest: R_G.valid_cfg_state_in_S)"], ["proof (state)\nthis:\n  abss (reps (state cfg)) = state cfg\n\ngoal (1 subgoal):\n 1. abst (action (repc cfg)) = action cfg", "with action_abst_repcs[OF assms]"], ["proof (chain)\npicking this:\n  abss ?s = state cfg \\<Longrightarrow>\n  abst (action (repcs ?s cfg)) = action cfg\n  abss (reps (state cfg)) = state cfg", "show ?thesis"], ["proof (prove)\nusing this:\n  abss ?s = state cfg \\<Longrightarrow>\n  abst (action (repcs ?s cfg)) = action cfg\n  abss (reps (state cfg)) = state cfg\n\ngoal (1 subgoal):\n 1. abst (action (repc cfg)) = action cfg", "unfolding repc_def"], ["proof (prove)\nusing this:\n  abss ?s = state cfg \\<Longrightarrow>\n  abst (action (repcs ?s cfg)) = action cfg\n  abss (reps (state cfg)) = state cfg\n\ngoal (1 subgoal):\n 1. abst (action (repcs (reps (state cfg)) cfg)) = action cfg", "by auto"], ["proof (state)\nthis:\n  abst (action (repc cfg)) = action cfg\n\ngoal:\nNo subgoals!", "qed"], ["", "(* XXX Move *)"], ["", "lemma state_absc:\n  \"state (absc cfg) = abss (state cfg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state (absc cfg) = abss (state cfg)", "unfolding absc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. state\n     (cfg_corec (abss (state cfg)) (abst \\<circ> action)\n       (\\<lambda>cfg s.\n           cont cfg (THE x. abss x = s \\<and> x \\<in> set_pmf (action cfg)))\n       cfg) =\n    abss (state cfg)", "by auto"], ["", "lemma state_repcs[simp]:\n  \"state (repcs s cfg) = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state (repcs s cfg) = s", "unfolding repcs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. state\n     (cfg_corec s (\\<lambda>(s, cfg). rept s (action cfg))\n       (\\<lambda>(s, cfg) s'. (s', cont cfg (abss s'))) (s, cfg)) =\n    s", "by auto"], ["", "lemma repcs_bisim:\n  notes R_G.cfg_onD_state[simp del]\n  assumes \"cfg \\<in> R_G.valid_cfg\" \"x \\<in> S\" \"x ~ x'\" \"abss x = state cfg\"\n  shows \"absc (repcs x cfg) = absc (repcs x' cfg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. absc (repcs x cfg) = absc (repcs x' cfg)", "using assms"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  x \\<in> S\n  x ~ x'\n  abss x = state cfg\n\ngoal (1 subgoal):\n 1. absc (repcs x cfg) = absc (repcs x' cfg)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n     abss x = state cfg\\<rbrakk>\n    \\<Longrightarrow> absc (repcs x cfg) = absc (repcs x' cfg)", "from assms"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.valid_cfg\n  x \\<in> S\n  x ~ x'\n  abss x = state cfg", "have \"abss x' = state cfg\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  x \\<in> S\n  x ~ x'\n  abss x = state cfg\n\ngoal (1 subgoal):\n 1. abss x' = state cfg", "by auto"], ["proof (state)\nthis:\n  abss x' = state cfg\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n     abss x = state cfg\\<rbrakk>\n    \\<Longrightarrow> absc (repcs x cfg) = absc (repcs x' cfg)", "from assms"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.valid_cfg\n  x \\<in> S\n  x ~ x'\n  abss x = state cfg", "have \"abss x' \\<in> \\<S>\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  x \\<in> S\n  x ~ x'\n  abss x = state cfg\n\ngoal (1 subgoal):\n 1. abss x' \\<in> \\<S>", "by auto"], ["proof (state)\nthis:\n  abss x' \\<in> \\<S>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n     abss x = state cfg\\<rbrakk>\n    \\<Longrightarrow> absc (repcs x cfg) = absc (repcs x' cfg)", "then"], ["proof (chain)\npicking this:\n  abss x' \\<in> \\<S>", "have \"x' \\<in> S\""], ["proof (prove)\nusing this:\n  abss x' \\<in> \\<S>\n\ngoal (1 subgoal):\n 1. x' \\<in> S", "by (auto intro: \\<S>_abss_S)"], ["proof (state)\nthis:\n  x' \\<in> S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n     abss x = state cfg\\<rbrakk>\n    \\<Longrightarrow> absc (repcs x cfg) = absc (repcs x' cfg)", "with assms"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.valid_cfg\n  x \\<in> S\n  x ~ x'\n  abss x = state cfg\n  x' \\<in> S", "show ?thesis"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  x \\<in> S\n  x ~ x'\n  abss x = state cfg\n  x' \\<in> S\n\ngoal (1 subgoal):\n 1. absc (repcs x cfg) = absc (repcs x' cfg)", "proof (coinduction arbitrary: cfg x x')"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cfg x x'.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n        abss x = state cfg; x' \\<in> S\\<rbrakk>\n       \\<Longrightarrow> state (absc (repcs x cfg)) =\n                         state (absc (repcs x' cfg))\n 2. \\<And>cfg x x'.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n        abss x = state cfg; x' \\<in> S\\<rbrakk>\n       \\<Longrightarrow> action (absc (repcs x cfg)) =\n                         action (absc (repcs x' cfg))\n 3. \\<And>t cfg x x'.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n        abss x = state cfg; x' \\<in> S;\n        t \\<in> set_pmf (action (absc (repcs x cfg)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga xa x'a.\n                            cont (absc (repcs x cfg)) t =\n                            absc (repcs xa cfga) \\<and>\n                            cont (absc (repcs x' cfg)) t =\n                            absc (repcs x'a cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            xa \\<in> S \\<and>\n                            xa ~ x'a \\<and>\n                            abss xa = state cfga \\<and> x'a \\<in> S", "case state"], ["proof (state)\nthis:\n  cfg \\<in> R_G.valid_cfg\n  x \\<in> S\n  x ~ x'\n  abss x = state cfg\n  x' \\<in> S\n\ngoal (3 subgoals):\n 1. \\<And>cfg x x'.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n        abss x = state cfg; x' \\<in> S\\<rbrakk>\n       \\<Longrightarrow> state (absc (repcs x cfg)) =\n                         state (absc (repcs x' cfg))\n 2. \\<And>cfg x x'.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n        abss x = state cfg; x' \\<in> S\\<rbrakk>\n       \\<Longrightarrow> action (absc (repcs x cfg)) =\n                         action (absc (repcs x' cfg))\n 3. \\<And>t cfg x x'.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n        abss x = state cfg; x' \\<in> S;\n        t \\<in> set_pmf (action (absc (repcs x cfg)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga xa x'a.\n                            cont (absc (repcs x cfg)) t =\n                            absc (repcs xa cfga) \\<and>\n                            cont (absc (repcs x' cfg)) t =\n                            absc (repcs x'a cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            xa \\<in> S \\<and>\n                            xa ~ x'a \\<and>\n                            abss xa = state cfga \\<and> x'a \\<in> S", "then"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.valid_cfg\n  x \\<in> S\n  x ~ x'\n  abss x = state cfg\n  x' \\<in> S", "show ?case"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  x \\<in> S\n  x ~ x'\n  abss x = state cfg\n  x' \\<in> S\n\ngoal (1 subgoal):\n 1. state (absc (repcs x cfg)) = state (absc (repcs x' cfg))", "by (simp add: state_absc)"], ["proof (state)\nthis:\n  state (absc (repcs x cfg)) = state (absc (repcs x' cfg))\n\ngoal (2 subgoals):\n 1. \\<And>cfg x x'.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n        abss x = state cfg; x' \\<in> S\\<rbrakk>\n       \\<Longrightarrow> action (absc (repcs x cfg)) =\n                         action (absc (repcs x' cfg))\n 2. \\<And>t cfg x x'.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n        abss x = state cfg; x' \\<in> S;\n        t \\<in> set_pmf (action (absc (repcs x cfg)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga xa x'a.\n                            cont (absc (repcs x cfg)) t =\n                            absc (repcs xa cfga) \\<and>\n                            cont (absc (repcs x' cfg)) t =\n                            absc (repcs x'a cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            xa \\<in> S \\<and>\n                            xa ~ x'a \\<and>\n                            abss xa = state cfga \\<and> x'a \\<in> S", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cfg x x'.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n        abss x = state cfg; x' \\<in> S\\<rbrakk>\n       \\<Longrightarrow> action (absc (repcs x cfg)) =\n                         action (absc (repcs x' cfg))\n 2. \\<And>t cfg x x'.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n        abss x = state cfg; x' \\<in> S;\n        t \\<in> set_pmf (action (absc (repcs x cfg)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga xa x'a.\n                            cont (absc (repcs x cfg)) t =\n                            absc (repcs xa cfga) \\<and>\n                            cont (absc (repcs x' cfg)) t =\n                            absc (repcs x'a cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            xa \\<in> S \\<and>\n                            xa ~ x'a \\<and>\n                            abss xa = state cfga \\<and> x'a \\<in> S", "case action"], ["proof (state)\nthis:\n  cfg \\<in> R_G.valid_cfg\n  x \\<in> S\n  x ~ x'\n  abss x = state cfg\n  x' \\<in> S\n\ngoal (2 subgoals):\n 1. \\<And>cfg x x'.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n        abss x = state cfg; x' \\<in> S\\<rbrakk>\n       \\<Longrightarrow> action (absc (repcs x cfg)) =\n                         action (absc (repcs x' cfg))\n 2. \\<And>t cfg x x'.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n        abss x = state cfg; x' \\<in> S;\n        t \\<in> set_pmf (action (absc (repcs x cfg)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga xa x'a.\n                            cont (absc (repcs x cfg)) t =\n                            absc (repcs xa cfga) \\<and>\n                            cont (absc (repcs x' cfg)) t =\n                            absc (repcs x'a cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            xa \\<in> S \\<and>\n                            xa ~ x'a \\<and>\n                            abss xa = state cfga \\<and> x'a \\<in> S", "then"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.valid_cfg\n  x \\<in> S\n  x ~ x'\n  abss x = state cfg\n  x' \\<in> S", "show ?case"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  x \\<in> S\n  x ~ x'\n  abss x = state cfg\n  x' \\<in> S\n\ngoal (1 subgoal):\n 1. action (absc (repcs x cfg)) = action (absc (repcs x' cfg))", "unfolding absc_def repcs_def"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  x \\<in> S\n  x ~ x'\n  abss x = state cfg\n  x' \\<in> S\n\ngoal (1 subgoal):\n 1. action\n     (cfg_corec\n       (abss\n         (state\n           (cfg_corec x (\\<lambda>(s, cfg). rept s (action cfg))\n             (\\<lambda>(s, cfg) s'. (s', cont cfg (abss s'))) (x, cfg))))\n       (abst \\<circ> action)\n       (\\<lambda>cfg s.\n           cont cfg (THE x. abss x = s \\<and> x \\<in> set_pmf (action cfg)))\n       (cfg_corec x (\\<lambda>(s, cfg). rept s (action cfg))\n         (\\<lambda>(s, cfg) s'. (s', cont cfg (abss s'))) (x, cfg))) =\n    action\n     (cfg_corec\n       (abss\n         (state\n           (cfg_corec x' (\\<lambda>(s, cfg). rept s (action cfg))\n             (\\<lambda>(s, cfg) s'. (s', cont cfg (abss s'))) (x', cfg))))\n       (abst \\<circ> action)\n       (\\<lambda>cfg s.\n           cont cfg (THE x. abss x = s \\<and> x \\<in> set_pmf (action cfg)))\n       (cfg_corec x' (\\<lambda>(s, cfg). rept s (action cfg))\n         (\\<lambda>(s, cfg) s'. (s', cont cfg (abss s'))) (x', cfg)))", "by (auto dest: R_G.valid_cfgD)"], ["proof (state)\nthis:\n  action (absc (repcs x cfg)) = action (absc (repcs x' cfg))\n\ngoal (1 subgoal):\n 1. \\<And>t cfg x x'.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n        abss x = state cfg; x' \\<in> S;\n        t \\<in> set_pmf (action (absc (repcs x cfg)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga xa x'a.\n                            cont (absc (repcs x cfg)) t =\n                            absc (repcs xa cfga) \\<and>\n                            cont (absc (repcs x' cfg)) t =\n                            absc (repcs x'a cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            xa \\<in> S \\<and>\n                            xa ~ x'a \\<and>\n                            abss xa = state cfga \\<and> x'a \\<in> S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t cfg x x'.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n        abss x = state cfg; x' \\<in> S;\n        t \\<in> set_pmf (action (absc (repcs x cfg)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga xa x'a.\n                            cont (absc (repcs x cfg)) t =\n                            absc (repcs xa cfga) \\<and>\n                            cont (absc (repcs x' cfg)) t =\n                            absc (repcs x'a cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            xa \\<in> S \\<and>\n                            xa ~ x'a \\<and>\n                            abss xa = state cfga \\<and> x'a \\<in> S", "case prems: (cont s cfg x x')"], ["proof (state)\nthis:\n  cfg \\<in> R_G.valid_cfg\n  x \\<in> S\n  x ~ x'\n  abss x = state cfg\n  x' \\<in> S\n  s \\<in> set_pmf (action (absc (repcs x cfg)))\n\ngoal (1 subgoal):\n 1. \\<And>t cfg x x'.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n        abss x = state cfg; x' \\<in> S;\n        t \\<in> set_pmf (action (absc (repcs x cfg)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga xa x'a.\n                            cont (absc (repcs x cfg)) t =\n                            absc (repcs xa cfga) \\<and>\n                            cont (absc (repcs x' cfg)) t =\n                            absc (repcs x'a cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            xa \\<in> S \\<and>\n                            xa ~ x'a \\<and>\n                            abss xa = state cfga \\<and> x'a \\<in> S", "define cfg' where \"cfg' = cont cfg s\""], ["proof (state)\nthis:\n  cfg' = cont cfg s\n\ngoal (1 subgoal):\n 1. \\<And>t cfg x x'.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n        abss x = state cfg; x' \\<in> S;\n        t \\<in> set_pmf (action (absc (repcs x cfg)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga xa x'a.\n                            cont (absc (repcs x cfg)) t =\n                            absc (repcs xa cfga) \\<and>\n                            cont (absc (repcs x' cfg)) t =\n                            absc (repcs x'a cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            xa \\<in> S \\<and>\n                            xa ~ x'a \\<and>\n                            abss xa = state cfga \\<and> x'a \\<in> S", "define t    where \"t \\<equiv> THE y. abss y = s \\<and> y \\<in> action (repcs x cfg)\""], ["proof (state)\nthis:\n  t \\<equiv> THE y. abss y = s \\<and> y \\<in> set_pmf (action (repcs x cfg))\n\ngoal (1 subgoal):\n 1. \\<And>t cfg x x'.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n        abss x = state cfg; x' \\<in> S;\n        t \\<in> set_pmf (action (absc (repcs x cfg)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga xa x'a.\n                            cont (absc (repcs x cfg)) t =\n                            absc (repcs xa cfga) \\<and>\n                            cont (absc (repcs x' cfg)) t =\n                            absc (repcs x'a cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            xa \\<in> S \\<and>\n                            xa ~ x'a \\<and>\n                            abss xa = state cfga \\<and> x'a \\<in> S", "define t'   where \"t' \\<equiv>THE y. abss y = s \\<and> y \\<in> action (repcs x' cfg)\""], ["proof (state)\nthis:\n  t' \\<equiv>\n  THE y. abss y = s \\<and> y \\<in> set_pmf (action (repcs x' cfg))\n\ngoal (1 subgoal):\n 1. \\<And>t cfg x x'.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n        abss x = state cfg; x' \\<in> S;\n        t \\<in> set_pmf (action (absc (repcs x cfg)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga xa x'a.\n                            cont (absc (repcs x cfg)) t =\n                            absc (repcs xa cfga) \\<and>\n                            cont (absc (repcs x' cfg)) t =\n                            absc (repcs x'a cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            xa \\<in> S \\<and>\n                            xa ~ x'a \\<and>\n                            abss xa = state cfga \\<and> x'a \\<in> S", "from prems"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.valid_cfg\n  x \\<in> S\n  x ~ x'\n  abss x = state cfg\n  x' \\<in> S\n  s \\<in> set_pmf (action (absc (repcs x cfg)))", "have valid: \"repcs x cfg \\<in> valid_cfg\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  x \\<in> S\n  x ~ x'\n  abss x = state cfg\n  x' \\<in> S\n  s \\<in> set_pmf (action (absc (repcs x cfg)))\n\ngoal (1 subgoal):\n 1. repcs x cfg \\<in> MDP.valid_cfg", "by (intro repcs_valid)"], ["proof (state)\nthis:\n  repcs x cfg \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. \\<And>t cfg x x'.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n        abss x = state cfg; x' \\<in> S;\n        t \\<in> set_pmf (action (absc (repcs x cfg)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga xa x'a.\n                            cont (absc (repcs x cfg)) t =\n                            absc (repcs xa cfga) \\<and>\n                            cont (absc (repcs x' cfg)) t =\n                            absc (repcs x'a cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            xa \\<in> S \\<and>\n                            xa ~ x'a \\<and>\n                            abss xa = state cfga \\<and> x'a \\<in> S", "from prems"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.valid_cfg\n  x \\<in> S\n  x ~ x'\n  abss x = state cfg\n  x' \\<in> S\n  s \\<in> set_pmf (action (absc (repcs x cfg)))", "have *: \"s \\<in> abst (action (repcs x cfg))\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  x \\<in> S\n  x ~ x'\n  abss x = state cfg\n  x' \\<in> S\n  s \\<in> set_pmf (action (absc (repcs x cfg)))\n\ngoal (1 subgoal):\n 1. s \\<in> set_pmf (abst (action (repcs x cfg)))", "unfolding cfg'_def"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  x \\<in> S\n  x ~ x'\n  abss x = state cfg\n  x' \\<in> S\n  s \\<in> set_pmf (action (absc (repcs x cfg)))\n\ngoal (1 subgoal):\n 1. s \\<in> set_pmf (abst (action (repcs x cfg)))", "by (simp add: action_absc)"], ["proof (state)\nthis:\n  s \\<in> set_pmf (abst (action (repcs x cfg)))\n\ngoal (1 subgoal):\n 1. \\<And>t cfg x x'.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n        abss x = state cfg; x' \\<in> S;\n        t \\<in> set_pmf (action (absc (repcs x cfg)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga xa x'a.\n                            cont (absc (repcs x cfg)) t =\n                            absc (repcs xa cfga) \\<and>\n                            cont (absc (repcs x' cfg)) t =\n                            absc (repcs x'a cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            xa \\<in> S \\<and>\n                            xa ~ x'a \\<and>\n                            abss xa = state cfga \\<and> x'a \\<in> S", "with prems"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.valid_cfg\n  x \\<in> S\n  x ~ x'\n  abss x = state cfg\n  x' \\<in> S\n  s \\<in> set_pmf (action (absc (repcs x cfg)))\n  s \\<in> set_pmf (abst (action (repcs x cfg)))", "have \"s \\<in> action cfg\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  x \\<in> S\n  x ~ x'\n  abss x = state cfg\n  x' \\<in> S\n  s \\<in> set_pmf (action (absc (repcs x cfg)))\n  s \\<in> set_pmf (abst (action (repcs x cfg)))\n\ngoal (1 subgoal):\n 1. s \\<in> set_pmf (action cfg)", "by (auto dest: R_G.valid_cfgD simp: repcs_def)"], ["proof (state)\nthis:\n  s \\<in> set_pmf (action cfg)\n\ngoal (1 subgoal):\n 1. \\<And>t cfg x x'.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n        abss x = state cfg; x' \\<in> S;\n        t \\<in> set_pmf (action (absc (repcs x cfg)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga xa x'a.\n                            cont (absc (repcs x cfg)) t =\n                            absc (repcs xa cfga) \\<and>\n                            cont (absc (repcs x' cfg)) t =\n                            absc (repcs x'a cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            xa \\<in> S \\<and>\n                            xa ~ x'a \\<and>\n                            abss xa = state cfga \\<and> x'a \\<in> S", "with prems"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.valid_cfg\n  x \\<in> S\n  x ~ x'\n  abss x = state cfg\n  x' \\<in> S\n  s \\<in> set_pmf (action (absc (repcs x cfg)))\n  s \\<in> set_pmf (action cfg)", "have \"s \\<in> \\<S>\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  x \\<in> S\n  x ~ x'\n  abss x = state cfg\n  x' \\<in> S\n  s \\<in> set_pmf (action (absc (repcs x cfg)))\n  s \\<in> set_pmf (action cfg)\n\ngoal (1 subgoal):\n 1. s \\<in> \\<S>", "by (auto intro: R_G.valid_cfg_action)"], ["proof (state)\nthis:\n  s \\<in> \\<S>\n\ngoal (1 subgoal):\n 1. \\<And>t cfg x x'.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n        abss x = state cfg; x' \\<in> S;\n        t \\<in> set_pmf (action (absc (repcs x cfg)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga xa x'a.\n                            cont (absc (repcs x cfg)) t =\n                            absc (repcs xa cfga) \\<and>\n                            cont (absc (repcs x' cfg)) t =\n                            absc (repcs x'a cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            xa \\<in> S \\<and>\n                            xa ~ x'a \\<and>\n                            abss xa = state cfga \\<and> x'a \\<in> S", "from cont_cfg_defined[OF valid *]"], ["proof (chain)\npicking this:\n  (abss (THE x. abss x = s \\<and> x \\<in> set_pmf (action (repcs x cfg))) =\n   s \\<and>\n   (THE x. abss x = s \\<and> x \\<in> set_pmf (action (repcs x cfg)))\n   \\<in> set_pmf (action (repcs x cfg))) \\<and>\n  (\\<forall>y.\n      abss y = s \\<and>\n      y \\<in> set_pmf (action (repcs x cfg)) \\<longrightarrow>\n      y = (THE x. abss x = s \\<and> x \\<in> set_pmf (action (repcs x cfg))))", "have t:\n      \"abss t = s\" \"t \\<in> action (repcs x cfg)\""], ["proof (prove)\nusing this:\n  (abss (THE x. abss x = s \\<and> x \\<in> set_pmf (action (repcs x cfg))) =\n   s \\<and>\n   (THE x. abss x = s \\<and> x \\<in> set_pmf (action (repcs x cfg)))\n   \\<in> set_pmf (action (repcs x cfg))) \\<and>\n  (\\<forall>y.\n      abss y = s \\<and>\n      y \\<in> set_pmf (action (repcs x cfg)) \\<longrightarrow>\n      y = (THE x. abss x = s \\<and> x \\<in> set_pmf (action (repcs x cfg))))\n\ngoal (1 subgoal):\n 1. abss t = s &&& t \\<in> set_pmf (action (repcs x cfg))", "unfolding t_def"], ["proof (prove)\nusing this:\n  (abss (THE x. abss x = s \\<and> x \\<in> set_pmf (action (repcs x cfg))) =\n   s \\<and>\n   (THE x. abss x = s \\<and> x \\<in> set_pmf (action (repcs x cfg)))\n   \\<in> set_pmf (action (repcs x cfg))) \\<and>\n  (\\<forall>y.\n      abss y = s \\<and>\n      y \\<in> set_pmf (action (repcs x cfg)) \\<longrightarrow>\n      y = (THE x. abss x = s \\<and> x \\<in> set_pmf (action (repcs x cfg))))\n\ngoal (1 subgoal):\n 1. abss (THE y. abss y = s \\<and> y \\<in> set_pmf (action (repcs x cfg))) =\n    s &&&\n    (THE y. abss y = s \\<and> y \\<in> set_pmf (action (repcs x cfg)))\n    \\<in> set_pmf (action (repcs x cfg))", "by auto"], ["proof (state)\nthis:\n  abss t = s\n  t \\<in> set_pmf (action (repcs x cfg))\n\ngoal (1 subgoal):\n 1. \\<And>t cfg x x'.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n        abss x = state cfg; x' \\<in> S;\n        t \\<in> set_pmf (action (absc (repcs x cfg)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga xa x'a.\n                            cont (absc (repcs x cfg)) t =\n                            absc (repcs xa cfga) \\<and>\n                            cont (absc (repcs x' cfg)) t =\n                            absc (repcs x'a cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            xa \\<in> S \\<and>\n                            xa ~ x'a \\<and>\n                            abss xa = state cfga \\<and> x'a \\<in> S", "have \"cont (absc (repcs x cfg)) s = cont (absc (repcs x cfg)) (abss t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (absc (repcs x cfg)) s = cont (absc (repcs x cfg)) (abss t)", "using t"], ["proof (prove)\nusing this:\n  abss t = s\n  t \\<in> set_pmf (action (repcs x cfg))\n\ngoal (1 subgoal):\n 1. cont (absc (repcs x cfg)) s = cont (absc (repcs x cfg)) (abss t)", "by auto"], ["proof (state)\nthis:\n  cont (absc (repcs x cfg)) s = cont (absc (repcs x cfg)) (abss t)\n\ngoal (1 subgoal):\n 1. \\<And>t cfg x x'.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n        abss x = state cfg; x' \\<in> S;\n        t \\<in> set_pmf (action (absc (repcs x cfg)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga xa x'a.\n                            cont (absc (repcs x cfg)) t =\n                            absc (repcs xa cfga) \\<and>\n                            cont (absc (repcs x' cfg)) t =\n                            absc (repcs x'a cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            xa \\<in> S \\<and>\n                            xa ~ x'a \\<and>\n                            abss xa = state cfga \\<and> x'a \\<in> S", "have \"cont (absc (repcs x cfg)) s = absc (cont (repcs x cfg) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (absc (repcs x cfg)) s = absc (cont (repcs x cfg) t)", "using t valid"], ["proof (prove)\nusing this:\n  abss t = s\n  t \\<in> set_pmf (action (repcs x cfg))\n  repcs x cfg \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. cont (absc (repcs x cfg)) s = absc (cont (repcs x cfg) t)", "by (auto simp: cont_absc_1)"], ["proof (state)\nthis:\n  cont (absc (repcs x cfg)) s = absc (cont (repcs x cfg) t)\n\ngoal (1 subgoal):\n 1. \\<And>t cfg x x'.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n        abss x = state cfg; x' \\<in> S;\n        t \\<in> set_pmf (action (absc (repcs x cfg)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga xa x'a.\n                            cont (absc (repcs x cfg)) t =\n                            absc (repcs xa cfga) \\<and>\n                            cont (absc (repcs x' cfg)) t =\n                            absc (repcs x'a cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            xa \\<in> S \\<and>\n                            xa ~ x'a \\<and>\n                            abss xa = state cfga \\<and> x'a \\<in> S", "also"], ["proof (state)\nthis:\n  cont (absc (repcs x cfg)) s = absc (cont (repcs x cfg) t)\n\ngoal (1 subgoal):\n 1. \\<And>t cfg x x'.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n        abss x = state cfg; x' \\<in> S;\n        t \\<in> set_pmf (action (absc (repcs x cfg)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga xa x'a.\n                            cont (absc (repcs x cfg)) t =\n                            absc (repcs xa cfga) \\<and>\n                            cont (absc (repcs x' cfg)) t =\n                            absc (repcs x'a cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            xa \\<in> S \\<and>\n                            xa ~ x'a \\<and>\n                            abss xa = state cfga \\<and> x'a \\<in> S", "have \"\\<dots> = absc (repcs t (cont cfg s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. absc (cont (repcs x cfg) t) = absc (repcs t (cont cfg s))", "using prems t"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  x \\<in> S\n  x ~ x'\n  abss x = state cfg\n  x' \\<in> S\n  s \\<in> set_pmf (action (absc (repcs x cfg)))\n  abss t = s\n  t \\<in> set_pmf (action (repcs x cfg))\n\ngoal (1 subgoal):\n 1. absc (cont (repcs x cfg) t) = absc (repcs t (cont cfg s))", "by (subst cont_repcs1) (auto dest: R_G.valid_cfgD)"], ["proof (state)\nthis:\n  absc (cont (repcs x cfg) t) = absc (repcs t (cont cfg s))\n\ngoal (1 subgoal):\n 1. \\<And>t cfg x x'.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n        abss x = state cfg; x' \\<in> S;\n        t \\<in> set_pmf (action (absc (repcs x cfg)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga xa x'a.\n                            cont (absc (repcs x cfg)) t =\n                            absc (repcs xa cfga) \\<and>\n                            cont (absc (repcs x' cfg)) t =\n                            absc (repcs x'a cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            xa \\<in> S \\<and>\n                            xa ~ x'a \\<and>\n                            abss xa = state cfga \\<and> x'a \\<in> S", "finally"], ["proof (chain)\npicking this:\n  cont (absc (repcs x cfg)) s = absc (repcs t (cont cfg s))", "have cont_x: \"cont (absc (repcs x cfg)) s = absc (repcs t (cont cfg s))\""], ["proof (prove)\nusing this:\n  cont (absc (repcs x cfg)) s = absc (repcs t (cont cfg s))\n\ngoal (1 subgoal):\n 1. cont (absc (repcs x cfg)) s = absc (repcs t (cont cfg s))", "."], ["proof (state)\nthis:\n  cont (absc (repcs x cfg)) s = absc (repcs t (cont cfg s))\n\ngoal (1 subgoal):\n 1. \\<And>t cfg x x'.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n        abss x = state cfg; x' \\<in> S;\n        t \\<in> set_pmf (action (absc (repcs x cfg)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga xa x'a.\n                            cont (absc (repcs x cfg)) t =\n                            absc (repcs xa cfga) \\<and>\n                            cont (absc (repcs x' cfg)) t =\n                            absc (repcs x'a cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            xa \\<in> S \\<and>\n                            xa ~ x'a \\<and>\n                            abss xa = state cfga \\<and> x'a \\<in> S", "from prems"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.valid_cfg\n  x \\<in> S\n  x ~ x'\n  abss x = state cfg\n  x' \\<in> S\n  s \\<in> set_pmf (action (absc (repcs x cfg)))", "have valid: \"repcs x' cfg \\<in> valid_cfg\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  x \\<in> S\n  x ~ x'\n  abss x = state cfg\n  x' \\<in> S\n  s \\<in> set_pmf (action (absc (repcs x cfg)))\n\ngoal (1 subgoal):\n 1. repcs x' cfg \\<in> MDP.valid_cfg", "by auto"], ["proof (state)\nthis:\n  repcs x' cfg \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. \\<And>t cfg x x'.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n        abss x = state cfg; x' \\<in> S;\n        t \\<in> set_pmf (action (absc (repcs x cfg)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga xa x'a.\n                            cont (absc (repcs x cfg)) t =\n                            absc (repcs xa cfga) \\<and>\n                            cont (absc (repcs x' cfg)) t =\n                            absc (repcs x'a cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            xa \\<in> S \\<and>\n                            xa ~ x'a \\<and>\n                            abss xa = state cfga \\<and> x'a \\<in> S", "from \\<open>s \\<in> action cfg\\<close> prems"], ["proof (chain)\npicking this:\n  s \\<in> set_pmf (action cfg)\n  cfg \\<in> R_G.valid_cfg\n  x \\<in> S\n  x ~ x'\n  abss x = state cfg\n  x' \\<in> S\n  s \\<in> set_pmf (action (absc (repcs x cfg)))", "have \"s \\<in> abst (action (repcs x' cfg))\""], ["proof (prove)\nusing this:\n  s \\<in> set_pmf (action cfg)\n  cfg \\<in> R_G.valid_cfg\n  x \\<in> S\n  x ~ x'\n  abss x = state cfg\n  x' \\<in> S\n  s \\<in> set_pmf (action (absc (repcs x cfg)))\n\ngoal (1 subgoal):\n 1. s \\<in> set_pmf (abst (action (repcs x' cfg)))", "by (auto dest: R_G.valid_cfgD simp: repcs_def)"], ["proof (state)\nthis:\n  s \\<in> set_pmf (abst (action (repcs x' cfg)))\n\ngoal (1 subgoal):\n 1. \\<And>t cfg x x'.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n        abss x = state cfg; x' \\<in> S;\n        t \\<in> set_pmf (action (absc (repcs x cfg)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga xa x'a.\n                            cont (absc (repcs x cfg)) t =\n                            absc (repcs xa cfga) \\<and>\n                            cont (absc (repcs x' cfg)) t =\n                            absc (repcs x'a cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            xa \\<in> S \\<and>\n                            xa ~ x'a \\<and>\n                            abss xa = state cfga \\<and> x'a \\<in> S", "from cont_cfg_defined[OF valid this]"], ["proof (chain)\npicking this:\n  (abss (THE x. abss x = s \\<and> x \\<in> set_pmf (action (repcs x' cfg))) =\n   s \\<and>\n   (THE x. abss x = s \\<and> x \\<in> set_pmf (action (repcs x' cfg)))\n   \\<in> set_pmf (action (repcs x' cfg))) \\<and>\n  (\\<forall>y.\n      abss y = s \\<and>\n      y \\<in> set_pmf (action (repcs x' cfg)) \\<longrightarrow>\n      y =\n      (THE x. abss x = s \\<and> x \\<in> set_pmf (action (repcs x' cfg))))", "have t':\n      \"abss t' = s\" \"t' \\<in> action (repcs x' cfg)\""], ["proof (prove)\nusing this:\n  (abss (THE x. abss x = s \\<and> x \\<in> set_pmf (action (repcs x' cfg))) =\n   s \\<and>\n   (THE x. abss x = s \\<and> x \\<in> set_pmf (action (repcs x' cfg)))\n   \\<in> set_pmf (action (repcs x' cfg))) \\<and>\n  (\\<forall>y.\n      abss y = s \\<and>\n      y \\<in> set_pmf (action (repcs x' cfg)) \\<longrightarrow>\n      y =\n      (THE x. abss x = s \\<and> x \\<in> set_pmf (action (repcs x' cfg))))\n\ngoal (1 subgoal):\n 1. abss t' = s &&& t' \\<in> set_pmf (action (repcs x' cfg))", "unfolding t'_def"], ["proof (prove)\nusing this:\n  (abss (THE x. abss x = s \\<and> x \\<in> set_pmf (action (repcs x' cfg))) =\n   s \\<and>\n   (THE x. abss x = s \\<and> x \\<in> set_pmf (action (repcs x' cfg)))\n   \\<in> set_pmf (action (repcs x' cfg))) \\<and>\n  (\\<forall>y.\n      abss y = s \\<and>\n      y \\<in> set_pmf (action (repcs x' cfg)) \\<longrightarrow>\n      y =\n      (THE x. abss x = s \\<and> x \\<in> set_pmf (action (repcs x' cfg))))\n\ngoal (1 subgoal):\n 1. abss\n     (THE y. abss y = s \\<and> y \\<in> set_pmf (action (repcs x' cfg))) =\n    s &&&\n    (THE y. abss y = s \\<and> y \\<in> set_pmf (action (repcs x' cfg)))\n    \\<in> set_pmf (action (repcs x' cfg))", "by auto"], ["proof (state)\nthis:\n  abss t' = s\n  t' \\<in> set_pmf (action (repcs x' cfg))\n\ngoal (1 subgoal):\n 1. \\<And>t cfg x x'.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n        abss x = state cfg; x' \\<in> S;\n        t \\<in> set_pmf (action (absc (repcs x cfg)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga xa x'a.\n                            cont (absc (repcs x cfg)) t =\n                            absc (repcs xa cfga) \\<and>\n                            cont (absc (repcs x' cfg)) t =\n                            absc (repcs x'a cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            xa \\<in> S \\<and>\n                            xa ~ x'a \\<and>\n                            abss xa = state cfga \\<and> x'a \\<in> S", "have \"cont (absc (repcs x' cfg)) s = cont (absc (repcs x' cfg)) (abss t')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (absc (repcs x' cfg)) s = cont (absc (repcs x' cfg)) (abss t')", "using t'"], ["proof (prove)\nusing this:\n  abss t' = s\n  t' \\<in> set_pmf (action (repcs x' cfg))\n\ngoal (1 subgoal):\n 1. cont (absc (repcs x' cfg)) s = cont (absc (repcs x' cfg)) (abss t')", "by auto"], ["proof (state)\nthis:\n  cont (absc (repcs x' cfg)) s = cont (absc (repcs x' cfg)) (abss t')\n\ngoal (1 subgoal):\n 1. \\<And>t cfg x x'.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n        abss x = state cfg; x' \\<in> S;\n        t \\<in> set_pmf (action (absc (repcs x cfg)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga xa x'a.\n                            cont (absc (repcs x cfg)) t =\n                            absc (repcs xa cfga) \\<and>\n                            cont (absc (repcs x' cfg)) t =\n                            absc (repcs x'a cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            xa \\<in> S \\<and>\n                            xa ~ x'a \\<and>\n                            abss xa = state cfga \\<and> x'a \\<in> S", "have \"cont (absc (repcs x' cfg)) s = absc (cont (repcs x' cfg) t')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (absc (repcs x' cfg)) s = absc (cont (repcs x' cfg) t')", "using t' valid"], ["proof (prove)\nusing this:\n  abss t' = s\n  t' \\<in> set_pmf (action (repcs x' cfg))\n  repcs x' cfg \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. cont (absc (repcs x' cfg)) s = absc (cont (repcs x' cfg) t')", "by (auto simp: cont_absc_1)"], ["proof (state)\nthis:\n  cont (absc (repcs x' cfg)) s = absc (cont (repcs x' cfg) t')\n\ngoal (1 subgoal):\n 1. \\<And>t cfg x x'.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n        abss x = state cfg; x' \\<in> S;\n        t \\<in> set_pmf (action (absc (repcs x cfg)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga xa x'a.\n                            cont (absc (repcs x cfg)) t =\n                            absc (repcs xa cfga) \\<and>\n                            cont (absc (repcs x' cfg)) t =\n                            absc (repcs x'a cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            xa \\<in> S \\<and>\n                            xa ~ x'a \\<and>\n                            abss xa = state cfga \\<and> x'a \\<in> S", "also"], ["proof (state)\nthis:\n  cont (absc (repcs x' cfg)) s = absc (cont (repcs x' cfg) t')\n\ngoal (1 subgoal):\n 1. \\<And>t cfg x x'.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n        abss x = state cfg; x' \\<in> S;\n        t \\<in> set_pmf (action (absc (repcs x cfg)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga xa x'a.\n                            cont (absc (repcs x cfg)) t =\n                            absc (repcs xa cfga) \\<and>\n                            cont (absc (repcs x' cfg)) t =\n                            absc (repcs x'a cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            xa \\<in> S \\<and>\n                            xa ~ x'a \\<and>\n                            abss xa = state cfga \\<and> x'a \\<in> S", "have \"\\<dots> = absc (repcs t' (cont cfg s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. absc (cont (repcs x' cfg) t') = absc (repcs t' (cont cfg s))", "using prems t'"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  x \\<in> S\n  x ~ x'\n  abss x = state cfg\n  x' \\<in> S\n  s \\<in> set_pmf (action (absc (repcs x cfg)))\n  abss t' = s\n  t' \\<in> set_pmf (action (repcs x' cfg))\n\ngoal (1 subgoal):\n 1. absc (cont (repcs x' cfg) t') = absc (repcs t' (cont cfg s))", "by (subst cont_repcs1) (auto dest: R_G.valid_cfgD)"], ["proof (state)\nthis:\n  absc (cont (repcs x' cfg) t') = absc (repcs t' (cont cfg s))\n\ngoal (1 subgoal):\n 1. \\<And>t cfg x x'.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n        abss x = state cfg; x' \\<in> S;\n        t \\<in> set_pmf (action (absc (repcs x cfg)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga xa x'a.\n                            cont (absc (repcs x cfg)) t =\n                            absc (repcs xa cfga) \\<and>\n                            cont (absc (repcs x' cfg)) t =\n                            absc (repcs x'a cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            xa \\<in> S \\<and>\n                            xa ~ x'a \\<and>\n                            abss xa = state cfga \\<and> x'a \\<in> S", "finally"], ["proof (chain)\npicking this:\n  cont (absc (repcs x' cfg)) s = absc (repcs t' (cont cfg s))", "have \"cont (absc (repcs x' cfg)) s = absc (repcs t' (cont cfg s))\""], ["proof (prove)\nusing this:\n  cont (absc (repcs x' cfg)) s = absc (repcs t' (cont cfg s))\n\ngoal (1 subgoal):\n 1. cont (absc (repcs x' cfg)) s = absc (repcs t' (cont cfg s))", "."], ["proof (state)\nthis:\n  cont (absc (repcs x' cfg)) s = absc (repcs t' (cont cfg s))\n\ngoal (1 subgoal):\n 1. \\<And>t cfg x x'.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; x \\<in> S; x ~ x';\n        abss x = state cfg; x' \\<in> S;\n        t \\<in> set_pmf (action (absc (repcs x cfg)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga xa x'a.\n                            cont (absc (repcs x cfg)) t =\n                            absc (repcs xa cfga) \\<and>\n                            cont (absc (repcs x' cfg)) t =\n                            absc (repcs x'a cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            xa \\<in> S \\<and>\n                            xa ~ x'a \\<and>\n                            abss xa = state cfga \\<and> x'a \\<in> S", "with cont_x \\<open>s \\<in> action cfg\\<close> prems(1) t t' \\<open>s \\<in> \\<S>\\<close>"], ["proof (chain)\npicking this:\n  cont (absc (repcs x cfg)) s = absc (repcs t (cont cfg s))\n  s \\<in> set_pmf (action cfg)\n  cfg \\<in> R_G.valid_cfg\n  abss t = s\n  t \\<in> set_pmf (action (repcs x cfg))\n  abss t' = s\n  t' \\<in> set_pmf (action (repcs x' cfg))\n  s \\<in> \\<S>\n  cont (absc (repcs x' cfg)) s = absc (repcs t' (cont cfg s))", "show ?case"], ["proof (prove)\nusing this:\n  cont (absc (repcs x cfg)) s = absc (repcs t (cont cfg s))\n  s \\<in> set_pmf (action cfg)\n  cfg \\<in> R_G.valid_cfg\n  abss t = s\n  t \\<in> set_pmf (action (repcs x cfg))\n  abss t' = s\n  t' \\<in> set_pmf (action (repcs x' cfg))\n  s \\<in> \\<S>\n  cont (absc (repcs x' cfg)) s = absc (repcs t' (cont cfg s))\n\ngoal (1 subgoal):\n 1. \\<exists>cfg x x'.\n       cont (absc (repcs x cfg)) s = absc (repcs x cfg) \\<and>\n       cont (absc (repcs x' cfg)) s = absc (repcs x' cfg) \\<and>\n       cfg \\<in> R_G.valid_cfg \\<and>\n       x \\<in> S \\<and> x ~ x' \\<and> abss x = state cfg \\<and> x' \\<in> S", "by (inst_existentials \"cont cfg s\" t t')\n         (auto intro: \\<S>_abss_S R_G.valid_cfg_action R_G.valid_cfg_cont)"], ["proof (state)\nthis:\n  \\<exists>cfg x x'.\n     cont (absc (repcs x cfg)) s = absc (repcs x cfg) \\<and>\n     cont (absc (repcs x' cfg)) s = absc (repcs x' cfg) \\<and>\n     cfg \\<in> R_G.valid_cfg \\<and>\n     x \\<in> S \\<and> x ~ x' \\<and> abss x = state cfg \\<and> x' \\<in> S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  absc (repcs x cfg) = absc (repcs x' cfg)\n\ngoal:\nNo subgoals!", "qed"], ["", "named_theorems R_G_I"], ["", "lemmas R_G.valid_cfg_state_in_S[R_G_I] R_G.valid_cfgD[R_G_I] R_G.valid_cfg_action"], ["", "(* XXX Simplifier looping problems on cfg_on\n   If R_G.cfg_onD_state is not removed from simpset, the simplifier rewrites state cfg = state cfg.\n*)"], ["", "lemma absc_repcs_id:\n  notes R_G.cfg_onD_state[simp del]\n  assumes \"cfg \\<in> R_G.valid_cfg\" \"abss s = state cfg\"\n  shows \"absc (repcs s cfg) = cfg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. absc (repcs s cfg) = cfg", "using assms"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n\ngoal (1 subgoal):\n 1. absc (repcs s cfg) = cfg", "proof (subst eq_commute, coinduction arbitrary: cfg s)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n       \\<Longrightarrow> state cfg = state (absc (repcs s cfg))\n 2. \\<And>cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n       \\<Longrightarrow> action cfg = action (absc (repcs s cfg))\n 3. \\<And>t cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        t \\<in> set_pmf (action cfg)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga sa.\n                            cont cfg t = cfga \\<and>\n                            cont (absc (repcs s cfg)) t =\n                            absc (repcs sa cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga", "case state"], ["proof (state)\nthis:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n\ngoal (3 subgoals):\n 1. \\<And>cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n       \\<Longrightarrow> state cfg = state (absc (repcs s cfg))\n 2. \\<And>cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n       \\<Longrightarrow> action cfg = action (absc (repcs s cfg))\n 3. \\<And>t cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        t \\<in> set_pmf (action cfg)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga sa.\n                            cont cfg t = cfga \\<and>\n                            cont (absc (repcs s cfg)) t =\n                            absc (repcs sa cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga", "then"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg", "show ?case"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n\ngoal (1 subgoal):\n 1. state cfg = state (absc (repcs s cfg))", "by (simp add: absc_def repc_def repcs_def)"], ["proof (state)\nthis:\n  state cfg = state (absc (repcs s cfg))\n\ngoal (2 subgoals):\n 1. \\<And>cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n       \\<Longrightarrow> action cfg = action (absc (repcs s cfg))\n 2. \\<And>t cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        t \\<in> set_pmf (action cfg)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga sa.\n                            cont cfg t = cfga \\<and>\n                            cont (absc (repcs s cfg)) t =\n                            absc (repcs sa cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n       \\<Longrightarrow> action cfg = action (absc (repcs s cfg))\n 2. \\<And>t cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        t \\<in> set_pmf (action cfg)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga sa.\n                            cont cfg t = cfga \\<and>\n                            cont (absc (repcs s cfg)) t =\n                            absc (repcs sa cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga", "case prems: (action cfg)"], ["proof (state)\nthis:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n\ngoal (2 subgoals):\n 1. \\<And>cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n       \\<Longrightarrow> action cfg = action (absc (repcs s cfg))\n 2. \\<And>t cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        t \\<in> set_pmf (action cfg)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga sa.\n                            cont cfg t = cfga \\<and>\n                            cont (absc (repcs s cfg)) t =\n                            absc (repcs sa cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga", "then"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg", "show ?case"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n\ngoal (1 subgoal):\n 1. action cfg = action (absc (repcs s cfg))", "by (auto simp: action_abst_repcs action_absc)"], ["proof (state)\nthis:\n  action cfg = action (absc (repcs s cfg))\n\ngoal (1 subgoal):\n 1. \\<And>t cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        t \\<in> set_pmf (action cfg)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga sa.\n                            cont cfg t = cfga \\<and>\n                            cont (absc (repcs s cfg)) t =\n                            absc (repcs sa cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        t \\<in> set_pmf (action cfg)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga sa.\n                            cont cfg t = cfga \\<and>\n                            cont (absc (repcs s cfg)) t =\n                            absc (repcs sa cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga", "case prems: (cont s')"], ["proof (state)\nthis:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  s' \\<in> set_pmf (action cfg)\n\ngoal (1 subgoal):\n 1. \\<And>t cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        t \\<in> set_pmf (action cfg)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga sa.\n                            cont cfg t = cfga \\<and>\n                            cont (absc (repcs s cfg)) t =\n                            absc (repcs sa cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga", "define cfg' where \"cfg' \\<equiv> repcs s cfg\""], ["proof (state)\nthis:\n  cfg' \\<equiv> repcs s cfg\n\ngoal (1 subgoal):\n 1. \\<And>t cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        t \\<in> set_pmf (action cfg)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga sa.\n                            cont cfg t = cfga \\<and>\n                            cont (absc (repcs s cfg)) t =\n                            absc (repcs sa cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga", "define t    where \"t    \\<equiv> THE x. abss x = s' \\<and> x \\<in> set_pmf (action cfg')\""], ["proof (state)\nthis:\n  t \\<equiv> THE x. abss x = s' \\<and> x \\<in> set_pmf (action cfg')\n\ngoal (1 subgoal):\n 1. \\<And>t cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        t \\<in> set_pmf (action cfg)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga sa.\n                            cont cfg t = cfga \\<and>\n                            cont (absc (repcs s cfg)) t =\n                            absc (repcs sa cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga", "from prems"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  s' \\<in> set_pmf (action cfg)", "have \"cfg \\<in> R_G.cfg_on (state cfg)\" \"state cfg \\<in> \\<S>\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  s' \\<in> set_pmf (action cfg)\n\ngoal (1 subgoal):\n 1. cfg \\<in> R_G.cfg_on (state cfg) &&& state cfg \\<in> \\<S>", "by (auto dest: R_G_I)"], ["proof (state)\nthis:\n  cfg \\<in> R_G.cfg_on (state cfg)\n  state cfg \\<in> \\<S>\n\ngoal (1 subgoal):\n 1. \\<And>t cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        t \\<in> set_pmf (action cfg)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga sa.\n                            cont cfg t = cfga \\<and>\n                            cont (absc (repcs s cfg)) t =\n                            absc (repcs sa cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga", "then"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.cfg_on (state cfg)\n  state cfg \\<in> \\<S>", "have *: \"cfg \\<in> R_G.cfg_on (abss (reps (state cfg)))\" \"abss (reps (state cfg)) \\<in> \\<S>\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.cfg_on (state cfg)\n  state cfg \\<in> \\<S>\n\ngoal (1 subgoal):\n 1. cfg \\<in> R_G.cfg_on (abss (reps (state cfg))) &&&\n    abss (reps (state cfg)) \\<in> \\<S>", "by auto"], ["proof (state)\nthis:\n  cfg \\<in> R_G.cfg_on (abss (reps (state cfg)))\n  abss (reps (state cfg)) \\<in> \\<S>\n\ngoal (1 subgoal):\n 1. \\<And>t cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        t \\<in> set_pmf (action cfg)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga sa.\n                            cont cfg t = cfga \\<and>\n                            cont (absc (repcs s cfg)) t =\n                            absc (repcs sa cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga", "from prems"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  s' \\<in> set_pmf (action cfg)", "have \"s' \\<in> \\<S>\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  s' \\<in> set_pmf (action cfg)\n\ngoal (1 subgoal):\n 1. s' \\<in> \\<S>", "by (auto intro: R_G.valid_cfg_action)"], ["proof (state)\nthis:\n  s' \\<in> \\<S>\n\ngoal (1 subgoal):\n 1. \\<And>t cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        t \\<in> set_pmf (action cfg)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga sa.\n                            cont cfg t = cfga \\<and>\n                            cont (absc (repcs s cfg)) t =\n                            absc (repcs sa cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga", "from prems"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  s' \\<in> set_pmf (action cfg)", "have valid: \"cfg' \\<in> valid_cfg\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  s' \\<in> set_pmf (action cfg)\n\ngoal (1 subgoal):\n 1. cfg' \\<in> MDP.valid_cfg", "unfolding cfg'_def"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  s' \\<in> set_pmf (action cfg)\n\ngoal (1 subgoal):\n 1. repcs s cfg \\<in> MDP.valid_cfg", "by (intro repcs_valid)"], ["proof (state)\nthis:\n  cfg' \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. \\<And>t cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        t \\<in> set_pmf (action cfg)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga sa.\n                            cont cfg t = cfga \\<and>\n                            cont (absc (repcs s cfg)) t =\n                            absc (repcs sa cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga", "from prems"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  s' \\<in> set_pmf (action cfg)", "have \"s' \\<in> abst (action cfg')\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  s' \\<in> set_pmf (action cfg)\n\ngoal (1 subgoal):\n 1. s' \\<in> set_pmf (abst (action cfg'))", "unfolding cfg'_def"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  s' \\<in> set_pmf (action cfg)\n\ngoal (1 subgoal):\n 1. s' \\<in> set_pmf (abst (action (repcs s cfg)))", "by (subst action_abst_repcs)"], ["proof (state)\nthis:\n  s' \\<in> set_pmf (abst (action cfg'))\n\ngoal (1 subgoal):\n 1. \\<And>t cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        t \\<in> set_pmf (action cfg)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga sa.\n                            cont cfg t = cfga \\<and>\n                            cont (absc (repcs s cfg)) t =\n                            absc (repcs sa cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga", "from cont_cfg_defined[OF valid this]"], ["proof (chain)\npicking this:\n  (abss (THE x. abss x = s' \\<and> x \\<in> set_pmf (action cfg')) =\n   s' \\<and>\n   (THE x. abss x = s' \\<and> x \\<in> set_pmf (action cfg'))\n   \\<in> set_pmf (action cfg')) \\<and>\n  (\\<forall>y.\n      abss y = s' \\<and> y \\<in> set_pmf (action cfg') \\<longrightarrow>\n      y = (THE x. abss x = s' \\<and> x \\<in> set_pmf (action cfg')))", "have t:\n    \"abss t = s'\" \"t \\<in> action cfg'\""], ["proof (prove)\nusing this:\n  (abss (THE x. abss x = s' \\<and> x \\<in> set_pmf (action cfg')) =\n   s' \\<and>\n   (THE x. abss x = s' \\<and> x \\<in> set_pmf (action cfg'))\n   \\<in> set_pmf (action cfg')) \\<and>\n  (\\<forall>y.\n      abss y = s' \\<and> y \\<in> set_pmf (action cfg') \\<longrightarrow>\n      y = (THE x. abss x = s' \\<and> x \\<in> set_pmf (action cfg')))\n\ngoal (1 subgoal):\n 1. abss t = s' &&& t \\<in> set_pmf (action cfg')", "unfolding t_def cfg'_def"], ["proof (prove)\nusing this:\n  (abss (THE x. abss x = s' \\<and> x \\<in> set_pmf (action (repcs s cfg))) =\n   s' \\<and>\n   (THE x. abss x = s' \\<and> x \\<in> set_pmf (action (repcs s cfg)))\n   \\<in> set_pmf (action (repcs s cfg))) \\<and>\n  (\\<forall>y.\n      abss y = s' \\<and>\n      y \\<in> set_pmf (action (repcs s cfg)) \\<longrightarrow>\n      y =\n      (THE x. abss x = s' \\<and> x \\<in> set_pmf (action (repcs s cfg))))\n\ngoal (1 subgoal):\n 1. abss\n     (THE x. abss x = s' \\<and> x \\<in> set_pmf (action (repcs s cfg))) =\n    s' &&&\n    (THE x. abss x = s' \\<and> x \\<in> set_pmf (action (repcs s cfg)))\n    \\<in> set_pmf (action (repcs s cfg))", "by auto"], ["proof (state)\nthis:\n  abss t = s'\n  t \\<in> set_pmf (action cfg')\n\ngoal (1 subgoal):\n 1. \\<And>t cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        t \\<in> set_pmf (action cfg)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga sa.\n                            cont cfg t = cfga \\<and>\n                            cont (absc (repcs s cfg)) t =\n                            absc (repcs sa cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga", "with prems"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  s' \\<in> set_pmf (action cfg)\n  abss t = s'\n  t \\<in> set_pmf (action cfg')", "have \"t ~ reps (abss t)\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  s' \\<in> set_pmf (action cfg)\n  abss t = s'\n  t \\<in> set_pmf (action cfg')\n\ngoal (1 subgoal):\n 1. t ~ reps (abss t)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n     cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n     s' \\<in> set_pmf (action cfg); abss t = s';\n     t \\<in> set_pmf (action cfg')\\<rbrakk>\n    \\<Longrightarrow> t ~ reps (abss t)", "apply (subst \\<S>_abss_reps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n     cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n     s' \\<in> set_pmf (action cfg); abss t = s';\n     t \\<in> set_pmf (action cfg')\\<rbrakk>\n    \\<Longrightarrow> abss t \\<in> \\<S>\n 2. \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n     cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n     s' \\<in> set_pmf (action cfg); abss t = s';\n     t \\<in> set_pmf (action cfg')\\<rbrakk>\n    \\<Longrightarrow> t ~ t", "by (auto intro: R_G.valid_cfg_action)"], ["proof (state)\nthis:\n  t ~ reps (abss t)\n\ngoal (1 subgoal):\n 1. \\<And>t cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        t \\<in> set_pmf (action cfg)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga sa.\n                            cont cfg t = cfga \\<and>\n                            cont (absc (repcs s cfg)) t =\n                            absc (repcs sa cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga", "have \"cont (absc cfg') s' = cont (absc cfg') (abss t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (absc cfg') s' = cont (absc cfg') (abss t)", "using t"], ["proof (prove)\nusing this:\n  abss t = s'\n  t \\<in> set_pmf (action cfg')\n\ngoal (1 subgoal):\n 1. cont (absc cfg') s' = cont (absc cfg') (abss t)", "by auto"], ["proof (state)\nthis:\n  cont (absc cfg') s' = cont (absc cfg') (abss t)\n\ngoal (1 subgoal):\n 1. \\<And>t cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        t \\<in> set_pmf (action cfg)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga sa.\n                            cont cfg t = cfga \\<and>\n                            cont (absc (repcs s cfg)) t =\n                            absc (repcs sa cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga", "have \"cont (absc cfg') s' = absc (cont cfg' t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (absc cfg') s' = absc (cont cfg' t)", "using t valid"], ["proof (prove)\nusing this:\n  abss t = s'\n  t \\<in> set_pmf (action cfg')\n  cfg' \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. cont (absc cfg') s' = absc (cont cfg' t)", "by (auto simp: cont_absc_1)"], ["proof (state)\nthis:\n  cont (absc cfg') s' = absc (cont cfg' t)\n\ngoal (1 subgoal):\n 1. \\<And>t cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        t \\<in> set_pmf (action cfg)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga sa.\n                            cont cfg t = cfga \\<and>\n                            cont (absc (repcs s cfg)) t =\n                            absc (repcs sa cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga", "also"], ["proof (state)\nthis:\n  cont (absc cfg') s' = absc (cont cfg' t)\n\ngoal (1 subgoal):\n 1. \\<And>t cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        t \\<in> set_pmf (action cfg)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga sa.\n                            cont cfg t = cfga \\<and>\n                            cont (absc (repcs s cfg)) t =\n                            absc (repcs sa cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga", "have \"\\<dots> = absc (repcs t (cont cfg s'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. absc (cont cfg' t) = absc (repcs t (cont cfg s'))", "using prems t * \\<open>t ~ _\\<close> valid"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  s' \\<in> set_pmf (action cfg)\n  abss t = s'\n  t \\<in> set_pmf (action cfg')\n  cfg \\<in> R_G.cfg_on (abss (reps (state cfg)))\n  abss (reps (state cfg)) \\<in> \\<S>\n  t ~ reps (abss t)\n  cfg' \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. absc (cont cfg' t) = absc (repcs t (cont cfg s'))", "by (fastforce dest: R_G_I intro: repcs_bisim simp: cont_repcs1 cfg'_def)"], ["proof (state)\nthis:\n  absc (cont cfg' t) = absc (repcs t (cont cfg s'))\n\ngoal (1 subgoal):\n 1. \\<And>t cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        cfg \\<in> R_G.valid_cfg; abss s = state cfg;\n        t \\<in> set_pmf (action cfg)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfga sa.\n                            cont cfg t = cfga \\<and>\n                            cont (absc (repcs s cfg)) t =\n                            absc (repcs sa cfga) \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga \\<and>\n                            cfga \\<in> R_G.valid_cfg \\<and>\n                            abss sa = state cfga", "finally"], ["proof (chain)\npicking this:\n  cont (absc cfg') s' = absc (repcs t (cont cfg s'))", "show ?case"], ["proof (prove)\nusing this:\n  cont (absc cfg') s' = absc (repcs t (cont cfg s'))\n\ngoal (1 subgoal):\n 1. \\<exists>cfg s.\n       cont cfg s' = cfg \\<and>\n       cont (absc (repcs s cfg)) s' = absc (repcs s cfg) \\<and>\n       cfg \\<in> R_G.valid_cfg \\<and>\n       abss s = state cfg \\<and>\n       cfg \\<in> R_G.valid_cfg \\<and> abss s = state cfg", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (absc cfg') s' = absc (repcs t (cont cfg s')) \\<Longrightarrow>\n    \\<exists>cfg s.\n       cont cfg s' = cfg \\<and>\n       cont (absc (repcs s cfg)) s' = absc (repcs s cfg) \\<and>\n       cfg \\<in> R_G.valid_cfg \\<and>\n       abss s = state cfg \\<and>\n       cfg \\<in> R_G.valid_cfg \\<and> abss s = state cfg", "apply (rule exI[where x = \"cont cfg s'\"], rule exI[where x = t])"], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (absc cfg') s' = absc (repcs t (cont cfg s')) \\<Longrightarrow>\n    cont cfg s' = cont cfg s' \\<and>\n    cont (absc (repcs s cfg)) s' = absc (repcs t (cont cfg s')) \\<and>\n    cont cfg s' \\<in> R_G.valid_cfg \\<and>\n    abss t = state (cont cfg s') \\<and>\n    cont cfg s' \\<in> R_G.valid_cfg \\<and> abss t = state (cont cfg s')", "unfolding cfg'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (absc (repcs s cfg)) s' =\n    absc (repcs t (cont cfg s')) \\<Longrightarrow>\n    cont cfg s' = cont cfg s' \\<and>\n    cont (absc (repcs s cfg)) s' = absc (repcs t (cont cfg s')) \\<and>\n    cont cfg s' \\<in> R_G.valid_cfg \\<and>\n    abss t = state (cont cfg s') \\<and>\n    cont cfg s' \\<in> R_G.valid_cfg \\<and> abss t = state (cont cfg s')", "using prems t"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  s' \\<in> set_pmf (action cfg)\n  abss t = s'\n  t \\<in> set_pmf (action cfg')\n\ngoal (1 subgoal):\n 1. cont (absc (repcs s cfg)) s' =\n    absc (repcs t (cont cfg s')) \\<Longrightarrow>\n    cont cfg s' = cont cfg s' \\<and>\n    cont (absc (repcs s cfg)) s' = absc (repcs t (cont cfg s')) \\<and>\n    cont cfg s' \\<in> R_G.valid_cfg \\<and>\n    abss t = state (cont cfg s') \\<and>\n    cont cfg s' \\<in> R_G.valid_cfg \\<and> abss t = state (cont cfg s')", "by (auto intro: R_G.valid_cfg_cont)"], ["proof (state)\nthis:\n  \\<exists>cfg s.\n     cont cfg s' = cfg \\<and>\n     cont (absc (repcs s cfg)) s' = absc (repcs s cfg) \\<and>\n     cfg \\<in> R_G.valid_cfg \\<and>\n     abss s = state cfg \\<and>\n     cfg \\<in> R_G.valid_cfg \\<and> abss s = state cfg\n\ngoal:\nNo subgoals!", "qed"], ["", "(* XXX Simplifier looping problems on cfg_on\n   If R_G.cfg_onD_state is not removed from simpset, the simplifier rewrites state cfg = state cfg.\n*)"], ["", "lemma absc_repc_id:\n  notes R_G.cfg_onD_state[simp del]\n  assumes \"cfg \\<in> R_G.valid_cfg\"\n  shows \"absc (repc cfg) = cfg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. absc (repc cfg) = cfg", "using assms"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n\ngoal (1 subgoal):\n 1. absc (repc cfg) = cfg", "unfolding repc_def"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n\ngoal (1 subgoal):\n 1. absc (repcs (reps (state cfg)) cfg) = cfg", "using assms"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  cfg \\<in> R_G.valid_cfg\n\ngoal (1 subgoal):\n 1. absc (repcs (reps (state cfg)) cfg) = cfg", "by (subst absc_repcs_id) (auto dest: R_G_I)"], ["", "lemma K_cfg_map_absc:\n  \"cfg \\<in> valid_cfg \\<Longrightarrow> K_cfg (absc cfg) = map_pmf absc (K_cfg cfg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cfg \\<in> MDP.valid_cfg \\<Longrightarrow>\n    K_cfg (absc cfg) = map_pmf absc (K_cfg cfg)", "by (auto simp: K_cfg_def map_pmf_comp action_absc abst_def cont_absc_1 intro: map_pmf_cong)"], ["", "(* XXX Move *)"], ["", "lemma smap_comp:\n  \"(smap f o smap g) = smap (f o g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap f \\<circ> smap g = smap (f \\<circ> g)", "by (auto simp: stream.map_comp)"], ["", "lemma state_abscD[simp]:\n  assumes \"cfg \\<in> MDP.cfg_on s\"\n  shows \"state (absc cfg) = abss s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state (absc cfg) = abss s", "using assms"], ["proof (prove)\nusing this:\n  cfg \\<in> MDP.cfg_on s\n\ngoal (1 subgoal):\n 1. state (absc cfg) = abss s", "unfolding absc_def"], ["proof (prove)\nusing this:\n  cfg \\<in> MDP.cfg_on s\n\ngoal (1 subgoal):\n 1. state\n     (cfg_corec (abss (state cfg)) (abst \\<circ> action)\n       (\\<lambda>cfg s.\n           cont cfg (THE x. abss x = s \\<and> x \\<in> set_pmf (action cfg)))\n       cfg) =\n    abss s", "by auto"], ["", "(* XXX Move to different locale *)"], ["", "lemma R_G_valid_cfg_coinduct[coinduct set: valid_cfg]:\n  assumes \"P cfg\"\n  assumes \"\\<And>cfg. P cfg \\<Longrightarrow> state cfg \\<in> \\<S>\"\n  assumes \"\\<And>cfg. P cfg \\<Longrightarrow> action cfg \\<in> \\<K> (state cfg)\"\n  assumes \"\\<And>cfg t. P cfg \\<Longrightarrow> t \\<in> action cfg \\<Longrightarrow> P (cont cfg t)\"\n  shows \"cfg \\<in> R_G.valid_cfg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cfg \\<in> R_G.valid_cfg", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cfg \\<in> R_G.valid_cfg", "from assms"], ["proof (chain)\npicking this:\n  P cfg\n  P ?cfg5 \\<Longrightarrow> state ?cfg5 \\<in> \\<S>\n  P ?cfg5 \\<Longrightarrow> action ?cfg5 \\<in> \\<K> (state ?cfg5)\n  \\<lbrakk>P ?cfg5; ?t5 \\<in> set_pmf (action ?cfg5)\\<rbrakk>\n  \\<Longrightarrow> P (cont ?cfg5 ?t5)", "have \"cfg \\<in> R_G.cfg_on (state cfg)\""], ["proof (prove)\nusing this:\n  P cfg\n  P ?cfg5 \\<Longrightarrow> state ?cfg5 \\<in> \\<S>\n  P ?cfg5 \\<Longrightarrow> action ?cfg5 \\<in> \\<K> (state ?cfg5)\n  \\<lbrakk>P ?cfg5; ?t5 \\<in> set_pmf (action ?cfg5)\\<rbrakk>\n  \\<Longrightarrow> P (cont ?cfg5 ?t5)\n\ngoal (1 subgoal):\n 1. cfg \\<in> R_G.cfg_on (state cfg)", "by (coinduction arbitrary: cfg) auto"], ["proof (state)\nthis:\n  cfg \\<in> R_G.cfg_on (state cfg)\n\ngoal (1 subgoal):\n 1. cfg \\<in> R_G.valid_cfg", "moreover"], ["proof (state)\nthis:\n  cfg \\<in> R_G.cfg_on (state cfg)\n\ngoal (1 subgoal):\n 1. cfg \\<in> R_G.valid_cfg", "from assms"], ["proof (chain)\npicking this:\n  P cfg\n  P ?cfg5 \\<Longrightarrow> state ?cfg5 \\<in> \\<S>\n  P ?cfg5 \\<Longrightarrow> action ?cfg5 \\<in> \\<K> (state ?cfg5)\n  \\<lbrakk>P ?cfg5; ?t5 \\<in> set_pmf (action ?cfg5)\\<rbrakk>\n  \\<Longrightarrow> P (cont ?cfg5 ?t5)", "have \"state cfg \\<in> \\<S>\""], ["proof (prove)\nusing this:\n  P cfg\n  P ?cfg5 \\<Longrightarrow> state ?cfg5 \\<in> \\<S>\n  P ?cfg5 \\<Longrightarrow> action ?cfg5 \\<in> \\<K> (state ?cfg5)\n  \\<lbrakk>P ?cfg5; ?t5 \\<in> set_pmf (action ?cfg5)\\<rbrakk>\n  \\<Longrightarrow> P (cont ?cfg5 ?t5)\n\ngoal (1 subgoal):\n 1. state cfg \\<in> \\<S>", "by auto"], ["proof (state)\nthis:\n  state cfg \\<in> \\<S>\n\ngoal (1 subgoal):\n 1. cfg \\<in> R_G.valid_cfg", "ultimately"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.cfg_on (state cfg)\n  state cfg \\<in> \\<S>", "show ?thesis"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.cfg_on (state cfg)\n  state cfg \\<in> \\<S>\n\ngoal (1 subgoal):\n 1. cfg \\<in> R_G.valid_cfg", "by (intro R_G.valid_cfgI)"], ["proof (state)\nthis:\n  cfg \\<in> R_G.valid_cfg\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma absc_valid[intro]:\n  assumes \"cfg \\<in> valid_cfg\"\n  shows \"absc cfg \\<in> R_G.valid_cfg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. absc cfg \\<in> R_G.valid_cfg", "using assms"], ["proof (prove)\nusing this:\n  cfg \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. absc cfg \\<in> R_G.valid_cfg", "proof (coinduction arbitrary: cfg)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cfga.\n       cfga \\<in> MDP.valid_cfg \\<Longrightarrow>\n       state (absc cfga) \\<in> \\<S>\n 2. \\<And>cfga.\n       cfga \\<in> MDP.valid_cfg \\<Longrightarrow>\n       action (absc cfga) \\<in> \\<K> (state (absc cfga))\n 3. \\<And>t cfga.\n       \\<lbrakk>cfga \\<in> MDP.valid_cfg;\n        t \\<in> set_pmf (action (absc cfga))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg.\n                            cont (absc cfga) t = absc cfg \\<and>\n                            cfg \\<in> MDP.valid_cfg", "case 1"], ["proof (state)\nthis:\n  cfga \\<in> MDP.valid_cfg\n\ngoal (3 subgoals):\n 1. \\<And>cfga.\n       cfga \\<in> MDP.valid_cfg \\<Longrightarrow>\n       state (absc cfga) \\<in> \\<S>\n 2. \\<And>cfga.\n       cfga \\<in> MDP.valid_cfg \\<Longrightarrow>\n       action (absc cfga) \\<in> \\<K> (state (absc cfga))\n 3. \\<And>t cfga.\n       \\<lbrakk>cfga \\<in> MDP.valid_cfg;\n        t \\<in> set_pmf (action (absc cfga))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg.\n                            cont (absc cfga) t = absc cfg \\<and>\n                            cfg \\<in> MDP.valid_cfg", "then"], ["proof (chain)\npicking this:\n  cfga \\<in> MDP.valid_cfg", "show ?case"], ["proof (prove)\nusing this:\n  cfga \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. state (absc cfga) \\<in> \\<S>", "by (auto simp: absc_def dest: MDP.valid_cfg_state_in_S)"], ["proof (state)\nthis:\n  state (absc cfga) \\<in> \\<S>\n\ngoal (2 subgoals):\n 1. \\<And>cfga.\n       cfga \\<in> MDP.valid_cfg \\<Longrightarrow>\n       action (absc cfga) \\<in> \\<K> (state (absc cfga))\n 2. \\<And>t cfga.\n       \\<lbrakk>cfga \\<in> MDP.valid_cfg;\n        t \\<in> set_pmf (action (absc cfga))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg.\n                            cont (absc cfga) t = absc cfg \\<and>\n                            cfg \\<in> MDP.valid_cfg", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cfga.\n       cfga \\<in> MDP.valid_cfg \\<Longrightarrow>\n       action (absc cfga) \\<in> \\<K> (state (absc cfga))\n 2. \\<And>t cfga.\n       \\<lbrakk>cfga \\<in> MDP.valid_cfg;\n        t \\<in> set_pmf (action (absc cfga))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg.\n                            cont (absc cfga) t = absc cfg \\<and>\n                            cfg \\<in> MDP.valid_cfg", "case (2 cfg')"], ["proof (state)\nthis:\n  cfg' \\<in> MDP.valid_cfg\n\ngoal (2 subgoals):\n 1. \\<And>cfga.\n       cfga \\<in> MDP.valid_cfg \\<Longrightarrow>\n       action (absc cfga) \\<in> \\<K> (state (absc cfga))\n 2. \\<And>t cfga.\n       \\<lbrakk>cfga \\<in> MDP.valid_cfg;\n        t \\<in> set_pmf (action (absc cfga))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg.\n                            cont (absc cfga) t = absc cfg \\<and>\n                            cfg \\<in> MDP.valid_cfg", "then"], ["proof (chain)\npicking this:\n  cfg' \\<in> MDP.valid_cfg", "show ?case"], ["proof (prove)\nusing this:\n  cfg' \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. action (absc cfg') \\<in> \\<K> (state (absc cfg'))", "by (subst state_abscD) (auto intro: MDP.valid_cfgD action_abscD)"], ["proof (state)\nthis:\n  action (absc cfg') \\<in> \\<K> (state (absc cfg'))\n\ngoal (1 subgoal):\n 1. \\<And>t cfga.\n       \\<lbrakk>cfga \\<in> MDP.valid_cfg;\n        t \\<in> set_pmf (action (absc cfga))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg.\n                            cont (absc cfga) t = absc cfg \\<and>\n                            cfg \\<in> MDP.valid_cfg", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t cfga.\n       \\<lbrakk>cfga \\<in> MDP.valid_cfg;\n        t \\<in> set_pmf (action (absc cfga))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg.\n                            cont (absc cfga) t = absc cfg \\<and>\n                            cfg \\<in> MDP.valid_cfg", "case prems: (3 s' cfg)"], ["proof (state)\nthis:\n  cfg \\<in> MDP.valid_cfg\n  s' \\<in> set_pmf (action (absc cfg))\n\ngoal (1 subgoal):\n 1. \\<And>t cfga.\n       \\<lbrakk>cfga \\<in> MDP.valid_cfg;\n        t \\<in> set_pmf (action (absc cfga))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg.\n                            cont (absc cfga) t = absc cfg \\<and>\n                            cfg \\<in> MDP.valid_cfg", "define t where \"t \\<equiv> THE x. abss x = s' \\<and> x \\<in> set_pmf (action cfg)\""], ["proof (state)\nthis:\n  t \\<equiv> THE x. abss x = s' \\<and> x \\<in> set_pmf (action cfg)\n\ngoal (1 subgoal):\n 1. \\<And>t cfga.\n       \\<lbrakk>cfga \\<in> MDP.valid_cfg;\n        t \\<in> set_pmf (action (absc cfga))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg.\n                            cont (absc cfga) t = absc cfg \\<and>\n                            cfg \\<in> MDP.valid_cfg", "let ?cfg = \"cont cfg t\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t cfga.\n       \\<lbrakk>cfga \\<in> MDP.valid_cfg;\n        t \\<in> set_pmf (action (absc cfga))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg.\n                            cont (absc cfga) t = absc cfg \\<and>\n                            cfg \\<in> MDP.valid_cfg", "from prems"], ["proof (chain)\npicking this:\n  cfg \\<in> MDP.valid_cfg\n  s' \\<in> set_pmf (action (absc cfg))", "obtain s where \"s' = abss s\" \"s \\<in> action cfg\""], ["proof (prove)\nusing this:\n  cfg \\<in> MDP.valid_cfg\n  s' \\<in> set_pmf (action (absc cfg))\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s' = abss s; s \\<in> set_pmf (action cfg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: action_absc')"], ["proof (state)\nthis:\n  s' = abss s\n  s \\<in> set_pmf (action cfg)\n\ngoal (1 subgoal):\n 1. \\<And>t cfga.\n       \\<lbrakk>cfga \\<in> MDP.valid_cfg;\n        t \\<in> set_pmf (action (absc cfga))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg.\n                            cont (absc cfga) t = absc cfg \\<and>\n                            cfg \\<in> MDP.valid_cfg", "with cont_cfg_defined[OF prems(1), of s']"], ["proof (chain)\npicking this:\n  s' \\<in> set_pmf (abst (action cfg)) \\<Longrightarrow>\n  (abss (THE x. abss x = s' \\<and> x \\<in> set_pmf (action cfg)) = s' \\<and>\n   (THE x. abss x = s' \\<and> x \\<in> set_pmf (action cfg))\n   \\<in> set_pmf (action cfg)) \\<and>\n  (\\<forall>y.\n      abss y = s' \\<and> y \\<in> set_pmf (action cfg) \\<longrightarrow>\n      y = (THE x. abss x = s' \\<and> x \\<in> set_pmf (action cfg)))\n  s' = abss s\n  s \\<in> set_pmf (action cfg)", "have\n    \"abss t = s'\" \"t \\<in> set_pmf (action cfg)\"\n    \"\\<forall>y. abss y = s' \\<and> y \\<in> set_pmf (action cfg) \\<longrightarrow> y = t\""], ["proof (prove)\nusing this:\n  s' \\<in> set_pmf (abst (action cfg)) \\<Longrightarrow>\n  (abss (THE x. abss x = s' \\<and> x \\<in> set_pmf (action cfg)) = s' \\<and>\n   (THE x. abss x = s' \\<and> x \\<in> set_pmf (action cfg))\n   \\<in> set_pmf (action cfg)) \\<and>\n  (\\<forall>y.\n      abss y = s' \\<and> y \\<in> set_pmf (action cfg) \\<longrightarrow>\n      y = (THE x. abss x = s' \\<and> x \\<in> set_pmf (action cfg)))\n  s' = abss s\n  s \\<in> set_pmf (action cfg)\n\ngoal (1 subgoal):\n 1. abss t = s' &&&\n    t \\<in> set_pmf (action cfg) &&&\n    \\<forall>y.\n       abss y = s' \\<and> y \\<in> set_pmf (action cfg) \\<longrightarrow>\n       y = t", "unfolding t_def abst_def"], ["proof (prove)\nusing this:\n  s' \\<in> set_pmf (map_pmf abss (action cfg)) \\<Longrightarrow>\n  (abss (THE x. abss x = s' \\<and> x \\<in> set_pmf (action cfg)) = s' \\<and>\n   (THE x. abss x = s' \\<and> x \\<in> set_pmf (action cfg))\n   \\<in> set_pmf (action cfg)) \\<and>\n  (\\<forall>y.\n      abss y = s' \\<and> y \\<in> set_pmf (action cfg) \\<longrightarrow>\n      y = (THE x. abss x = s' \\<and> x \\<in> set_pmf (action cfg)))\n  s' = abss s\n  s \\<in> set_pmf (action cfg)\n\ngoal (1 subgoal):\n 1. abss (THE x. abss x = s' \\<and> x \\<in> set_pmf (action cfg)) = s' &&&\n    (THE x. abss x = s' \\<and> x \\<in> set_pmf (action cfg))\n    \\<in> set_pmf (action cfg) &&&\n    \\<forall>y.\n       abss y = s' \\<and> y \\<in> set_pmf (action cfg) \\<longrightarrow>\n       y = (THE x. abss x = s' \\<and> x \\<in> set_pmf (action cfg))", "by auto"], ["proof (state)\nthis:\n  abss t = s'\n  t \\<in> set_pmf (action cfg)\n  \\<forall>y.\n     abss y = s' \\<and> y \\<in> set_pmf (action cfg) \\<longrightarrow> y = t\n\ngoal (1 subgoal):\n 1. \\<And>t cfga.\n       \\<lbrakk>cfga \\<in> MDP.valid_cfg;\n        t \\<in> set_pmf (action (absc cfga))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg.\n                            cont (absc cfga) t = absc cfg \\<and>\n                            cfg \\<in> MDP.valid_cfg", "with prems"], ["proof (chain)\npicking this:\n  cfg \\<in> MDP.valid_cfg\n  s' \\<in> set_pmf (action (absc cfg))\n  abss t = s'\n  t \\<in> set_pmf (action cfg)\n  \\<forall>y.\n     abss y = s' \\<and> y \\<in> set_pmf (action cfg) \\<longrightarrow> y = t", "show ?case"], ["proof (prove)\nusing this:\n  cfg \\<in> MDP.valid_cfg\n  s' \\<in> set_pmf (action (absc cfg))\n  abss t = s'\n  t \\<in> set_pmf (action cfg)\n  \\<forall>y.\n     abss y = s' \\<and> y \\<in> set_pmf (action cfg) \\<longrightarrow> y = t\n\ngoal (1 subgoal):\n 1. \\<exists>cfg.\n       cont (absc cfg) s' = absc cfg \\<and> cfg \\<in> MDP.valid_cfg", "by (inst_existentials ?cfg)\n       (auto intro: MDP.valid_cfg_cont simp: abst_def action_absc absc_def t_def)"], ["proof (state)\nthis:\n  \\<exists>cfg. cont (absc cfg) s' = absc cfg \\<and> cfg \\<in> MDP.valid_cfg\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma K_cfg_set_absc:\n  assumes \"cfg \\<in> valid_cfg\" \"cfg' \\<in> K_cfg cfg\"\n  shows \"absc cfg' \\<in> K_cfg (absc cfg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. absc cfg' \\<in> set_pmf (K_cfg (absc cfg))", "using assms"], ["proof (prove)\nusing this:\n  cfg \\<in> MDP.valid_cfg\n  cfg' \\<in> set_pmf (K_cfg cfg)\n\ngoal (1 subgoal):\n 1. absc cfg' \\<in> set_pmf (K_cfg (absc cfg))", "by (auto simp: K_cfg_map_absc)"], ["", "lemma abst_action_repcs:\n  assumes \"cfg \\<in> R_G.valid_cfg\" \"abss s = state cfg\"\n  shows \"abst (action (repcs s cfg)) = action cfg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abst (action (repcs s cfg)) = action cfg", "unfolding repc_def repcs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. abst\n     (action\n       (cfg_corec s (\\<lambda>(s, cfg). rept s (action cfg))\n         (\\<lambda>(s, cfg) s'. (s', cont cfg (abss s'))) (s, cfg))) =\n    action cfg", "using assms"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n\ngoal (1 subgoal):\n 1. abst\n     (action\n       (cfg_corec s (\\<lambda>(s, cfg). rept s (action cfg))\n         (\\<lambda>(s, cfg) s'. (s', cont cfg (abss s'))) (s, cfg))) =\n    action cfg", "by (simp, subst abst_rept_id) (auto intro: R_G_I)"], ["", "lemma abst_action_repc:\n  assumes \"cfg \\<in> R_G.valid_cfg\"\n  shows \"abst (action (repc cfg)) = action cfg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abst (action (repc cfg)) = action cfg", "using assms"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n\ngoal (1 subgoal):\n 1. abst (action (repc cfg)) = action cfg", "unfolding repc_def"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n\ngoal (1 subgoal):\n 1. abst (action (repcs (reps (state cfg)) cfg)) = action cfg", "by (auto intro: abst_action_repcs simp: R_G_I)"], ["", "lemma K_elem_abss_inj':\n  assumes \"\\<mu> \\<in> K s\"\n    and \"s \\<in> S\"\n  shows \"inj_on abss (set_pmf \\<mu>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on abss (set_pmf \\<mu>)", "using assms K_elem_abss_inj"], ["proof (prove)\nusing this:\n  \\<mu> \\<in> K s\n  s \\<in> S\n  \\<lbrakk>?\\<mu> \\<in> K (?l, ?u); (?l, ?u) \\<in> S\\<rbrakk>\n  \\<Longrightarrow> inj_on abss (set_pmf ?\\<mu>)\n\ngoal (1 subgoal):\n 1. inj_on abss (set_pmf \\<mu>)", "by (simp add: K_bisim_unique inj_onI)"], ["", "lemma K_cfg_rept_aux:\n  assumes \"cfg \\<in> R_G.valid_cfg\" \"abss s = state cfg\" \"x \\<in> rept s (action cfg)\"\n  defines \"t \\<equiv> \\<lambda> cfg'. THE s'. s' \\<in> rept s (action cfg) \\<and> s' ~ x\"\n  shows \"t cfg' = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t cfg' = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t cfg' = x", "from assms"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  x \\<in> set_pmf (rept s (action cfg))\n  t \\<equiv>\n  \\<lambda>cfg'.\n     THE s'. s' \\<in> set_pmf (rept s (action cfg)) \\<and> s' ~ x", "have \"rept s (action cfg) \\<in> K s\" \"s \\<in> S\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  x \\<in> set_pmf (rept s (action cfg))\n  t \\<equiv>\n  \\<lambda>cfg'.\n     THE s'. s' \\<in> set_pmf (rept s (action cfg)) \\<and> s' ~ x\n\ngoal (1 subgoal):\n 1. rept s (action cfg) \\<in> K s &&& s \\<in> S", "by (auto simp: R_G_I \\<S>_abss_S)"], ["proof (state)\nthis:\n  rept s (action cfg) \\<in> K s\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. t cfg' = x", "from K_bisim_unique[OF this(2,1) _ assms(3)] assms(3)"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<in> set_pmf (rept s (action cfg)); ?x ~ x\\<rbrakk>\n  \\<Longrightarrow> ?x = x\n  x \\<in> set_pmf (rept s (action cfg))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set_pmf (rept s (action cfg)); ?x ~ x\\<rbrakk>\n  \\<Longrightarrow> ?x = x\n  x \\<in> set_pmf (rept s (action cfg))\n\ngoal (1 subgoal):\n 1. t cfg' = x", "unfolding t_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set_pmf (rept s (action cfg)); ?x ~ x\\<rbrakk>\n  \\<Longrightarrow> ?x = x\n  x \\<in> set_pmf (rept s (action cfg))\n\ngoal (1 subgoal):\n 1. (THE s'. s' \\<in> set_pmf (rept s (action cfg)) \\<and> s' ~ x) = x", "by blast"], ["proof (state)\nthis:\n  t cfg' = x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma K_cfg_rept_action:\n  assumes \"cfg \\<in> R_G.valid_cfg\" \"abss s = state cfg\" \"cfg' \\<in> set_pmf (K_cfg cfg)\"\n  shows \"abss (THE s'. s' \\<in> rept s (action cfg) \\<and> abss s' = state cfg') = state cfg'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abss\n     (THE s'.\n         s' \\<in> set_pmf (rept s (action cfg)) \\<and>\n         abss s' = state cfg') =\n    state cfg'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. abss\n     (THE s'.\n         s' \\<in> set_pmf (rept s (action cfg)) \\<and>\n         abss s' = state cfg') =\n    state cfg'", "let ?\\<mu> = \"rept s (action cfg)\""], ["proof (state)\ngoal (1 subgoal):\n 1. abss\n     (THE s'.\n         s' \\<in> set_pmf (rept s (action cfg)) \\<and>\n         abss s' = state cfg') =\n    state cfg'", "from abst_rept_id assms"], ["proof (chain)\npicking this:\n  ?\\<mu> \\<in> \\<K> (abss ?s) \\<Longrightarrow>\n  abst (rept ?s ?\\<mu>) = ?\\<mu>\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  cfg' \\<in> set_pmf (K_cfg cfg)", "have \"action cfg = abst ?\\<mu>\""], ["proof (prove)\nusing this:\n  ?\\<mu> \\<in> \\<K> (abss ?s) \\<Longrightarrow>\n  abst (rept ?s ?\\<mu>) = ?\\<mu>\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  cfg' \\<in> set_pmf (K_cfg cfg)\n\ngoal (1 subgoal):\n 1. action cfg = abst (rept s (action cfg))", "by (auto simp: R_G_I)"], ["proof (state)\nthis:\n  action cfg = abst (rept s (action cfg))\n\ngoal (1 subgoal):\n 1. abss\n     (THE s'.\n         s' \\<in> set_pmf (rept s (action cfg)) \\<and>\n         abss s' = state cfg') =\n    state cfg'", "moreover"], ["proof (state)\nthis:\n  action cfg = abst (rept s (action cfg))\n\ngoal (1 subgoal):\n 1. abss\n     (THE s'.\n         s' \\<in> set_pmf (rept s (action cfg)) \\<and>\n         abss s' = state cfg') =\n    state cfg'", "from assms"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  cfg' \\<in> set_pmf (K_cfg cfg)", "have \"state cfg' \\<in> action cfg\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  cfg' \\<in> set_pmf (K_cfg cfg)\n\ngoal (1 subgoal):\n 1. state cfg' \\<in> set_pmf (action cfg)", "by (auto simp: set_K_cfg)"], ["proof (state)\nthis:\n  state cfg' \\<in> set_pmf (action cfg)\n\ngoal (1 subgoal):\n 1. abss\n     (THE s'.\n         s' \\<in> set_pmf (rept s (action cfg)) \\<and>\n         abss s' = state cfg') =\n    state cfg'", "ultimately"], ["proof (chain)\npicking this:\n  action cfg = abst (rept s (action cfg))\n  state cfg' \\<in> set_pmf (action cfg)", "have \"state cfg' \\<in> abst ?\\<mu>\""], ["proof (prove)\nusing this:\n  action cfg = abst (rept s (action cfg))\n  state cfg' \\<in> set_pmf (action cfg)\n\ngoal (1 subgoal):\n 1. state cfg' \\<in> set_pmf (abst (rept s (action cfg)))", "by simp"], ["proof (state)\nthis:\n  state cfg' \\<in> set_pmf (abst (rept s (action cfg)))\n\ngoal (1 subgoal):\n 1. abss\n     (THE s'.\n         s' \\<in> set_pmf (rept s (action cfg)) \\<and>\n         abss s' = state cfg') =\n    state cfg'", "then"], ["proof (chain)\npicking this:\n  state cfg' \\<in> set_pmf (abst (rept s (action cfg)))", "obtain s' where \"s' \\<in> ?\\<mu>\" \"abss s' = state cfg'\""], ["proof (prove)\nusing this:\n  state cfg' \\<in> set_pmf (abst (rept s (action cfg)))\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>s' \\<in> set_pmf (rept s (action cfg));\n         abss s' = state cfg'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: abst_def pmf.set_map)"], ["proof (state)\nthis:\n  s' \\<in> set_pmf (rept s (action cfg))\n  abss s' = state cfg'\n\ngoal (1 subgoal):\n 1. abss\n     (THE s'.\n         s' \\<in> set_pmf (rept s (action cfg)) \\<and>\n         abss s' = state cfg') =\n    state cfg'", "with K_cfg_rept_aux[OF assms(1,2) this(1)]"], ["proof (chain)\npicking this:\n  (THE s'a. s'a \\<in> set_pmf (rept s (action cfg)) \\<and> s'a ~ s') = s'\n  s' \\<in> set_pmf (rept s (action cfg))\n  abss s' = state cfg'", "show ?thesis"], ["proof (prove)\nusing this:\n  (THE s'a. s'a \\<in> set_pmf (rept s (action cfg)) \\<and> s'a ~ s') = s'\n  s' \\<in> set_pmf (rept s (action cfg))\n  abss s' = state cfg'\n\ngoal (1 subgoal):\n 1. abss\n     (THE s'.\n         s' \\<in> set_pmf (rept s (action cfg)) \\<and>\n         abss s' = state cfg') =\n    state cfg'", "by auto"], ["proof (state)\nthis:\n  abss\n   (THE s'.\n       s' \\<in> set_pmf (rept s (action cfg)) \\<and> abss s' = state cfg') =\n  state cfg'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma K_cfg_map_repcs:\n  assumes \"cfg \\<in> R_G.valid_cfg\" \"abss s = state cfg\"\n  defines \"repc' \\<equiv> (\\<lambda> cfg'. repcs (THE s'. s' \\<in> rept s (action cfg) \\<and> abss s' = state cfg') cfg')\"\n  shows \"K_cfg (repcs s cfg) = map_pmf repc' (K_cfg cfg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K_cfg (repcs s cfg) = map_pmf repc' (K_cfg cfg)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. K_cfg (repcs s cfg) = map_pmf repc' (K_cfg cfg)", "let ?\\<mu> = \"rept s (action cfg)\""], ["proof (state)\ngoal (1 subgoal):\n 1. K_cfg (repcs s cfg) = map_pmf repc' (K_cfg cfg)", "define t where \"t \\<equiv> \\<lambda> cfg'. THE s. s \\<in> ?\\<mu> \\<and> abss s = state cfg'\""], ["proof (state)\nthis:\n  t \\<equiv>\n  \\<lambda>cfg'.\n     THE sa.\n        sa \\<in> set_pmf (rept s (action cfg)) \\<and> abss sa = state cfg'\n\ngoal (1 subgoal):\n 1. K_cfg (repcs s cfg) = map_pmf repc' (K_cfg cfg)", "have t: \"t (cont cfg (abss s')) = s'\" if \"s' \\<in> ?\\<mu>\" for s'"], ["proof (prove)\ngoal (1 subgoal):\n 1. t (cont cfg (abss s')) = s'", "using K_cfg_rept_aux[OF assms(1,2) that]"], ["proof (prove)\nusing this:\n  (THE s'a. s'a \\<in> set_pmf (rept s (action cfg)) \\<and> s'a ~ s') = s'\n\ngoal (1 subgoal):\n 1. t (cont cfg (abss s')) = s'", "unfolding t_def"], ["proof (prove)\nusing this:\n  (THE s'a. s'a \\<in> set_pmf (rept s (action cfg)) \\<and> s'a ~ s') = s'\n\ngoal (1 subgoal):\n 1. (THE sa.\n        sa \\<in> set_pmf (rept s (action cfg)) \\<and>\n        abss sa = state (cont cfg (abss s'))) =\n    s'", "by auto"], ["proof (state)\nthis:\n  ?s'5 \\<in> set_pmf (rept s (action cfg)) \\<Longrightarrow>\n  t (cont cfg (abss ?s'5)) = ?s'5\n\ngoal (1 subgoal):\n 1. K_cfg (repcs s cfg) = map_pmf repc' (K_cfg cfg)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. K_cfg (repcs s cfg) = map_pmf repc' (K_cfg cfg)", "unfolding K_cfg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (cont (repcs s cfg)) (action (repcs s cfg)) =\n    map_pmf repc' (map_pmf (cont cfg) (action cfg))", "using t"], ["proof (prove)\nusing this:\n  ?s'5 \\<in> set_pmf (rept s (action cfg)) \\<Longrightarrow>\n  t (cont cfg (abss ?s'5)) = ?s'5\n\ngoal (1 subgoal):\n 1. map_pmf (cont (repcs s cfg)) (action (repcs s cfg)) =\n    map_pmf repc' (map_pmf (cont cfg) (action cfg))", "by (subst abst_action_repcs[symmetric])\n       (auto simp: repc_def repcs_def t_def map_pmf_comp abst_def assms intro: map_pmf_cong)"], ["proof (state)\nthis:\n  K_cfg (repcs s cfg) = map_pmf repc' (K_cfg cfg)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma K_cfg_map_repc:\n  assumes \"cfg \\<in> R_G.valid_cfg\"\n  defines\n    \"repc' cfg' \\<equiv> repcs (THE s. s \\<in> rept (reps (state cfg)) (action cfg) \\<and> abss s = state cfg') cfg'\"\n  shows \n    \"K_cfg (repc cfg) = map_pmf repc' (K_cfg cfg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K_cfg (repc cfg) = map_pmf repc' (K_cfg cfg)", "using assms"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  repc' ?cfg'5 \\<equiv>\n  repcs\n   (THE s.\n       s \\<in> set_pmf (rept (reps (state cfg)) (action cfg)) \\<and>\n       abss s = state ?cfg'5)\n   ?cfg'5\n\ngoal (1 subgoal):\n 1. K_cfg (repc cfg) = map_pmf repc' (K_cfg cfg)", "unfolding repc'_def repc_def"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  repcs\n   (THE s.\n       s \\<in> set_pmf (rept (reps (state cfg)) (action cfg)) \\<and>\n       abss s = state ?cfg'5)\n   ?cfg'5 \\<equiv>\n  repcs\n   (THE s.\n       s \\<in> set_pmf (rept (reps (state cfg)) (action cfg)) \\<and>\n       abss s = state ?cfg'5)\n   ?cfg'5\n\ngoal (1 subgoal):\n 1. K_cfg (repcs (reps (state cfg)) cfg) =\n    map_pmf\n     (\\<lambda>cfg'.\n         repcs\n          (THE s.\n              s \\<in> set_pmf (rept (reps (state cfg)) (action cfg)) \\<and>\n              abss s = state cfg')\n          cfg')\n     (K_cfg cfg)", "by (auto simp: R_G_I K_cfg_map_repcs)"], ["", "lemma R_G_K_cfg_valid_cfgD:\n  assumes \"cfg \\<in> R_G.valid_cfg\" \"cfg' \\<in> K_cfg cfg\"\n  shows \"cfg' = cont cfg (state cfg')\" \"state cfg' \\<in> action cfg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cfg' = cont cfg (state cfg') &&& state cfg' \\<in> set_pmf (action cfg)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. cfg' = cont cfg (state cfg')\n 2. state cfg' \\<in> set_pmf (action cfg)", "from assms(2)"], ["proof (chain)\npicking this:\n  cfg' \\<in> set_pmf (K_cfg cfg)", "obtain s where \"s \\<in> action cfg\" \"cfg' = cont cfg s\""], ["proof (prove)\nusing this:\n  cfg' \\<in> set_pmf (K_cfg cfg)\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> set_pmf (action cfg); cfg' = cont cfg s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: set_K_cfg)"], ["proof (state)\nthis:\n  s \\<in> set_pmf (action cfg)\n  cfg' = cont cfg s\n\ngoal (2 subgoals):\n 1. cfg' = cont cfg (state cfg')\n 2. state cfg' \\<in> set_pmf (action cfg)", "with assms"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.valid_cfg\n  cfg' \\<in> set_pmf (K_cfg cfg)\n  s \\<in> set_pmf (action cfg)\n  cfg' = cont cfg s", "show\n    \"cfg' = cont cfg (state cfg')\" \"state cfg' \\<in> action cfg\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  cfg' \\<in> set_pmf (K_cfg cfg)\n  s \\<in> set_pmf (action cfg)\n  cfg' = cont cfg s\n\ngoal (1 subgoal):\n 1. cfg' = cont cfg (state cfg') &&& state cfg' \\<in> set_pmf (action cfg)", "by (auto intro: R_G.valid_cfg_state_in_S R_G.valid_cfgD)"], ["proof (state)\nthis:\n  cfg' = cont cfg (state cfg')\n  state cfg' \\<in> set_pmf (action cfg)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma K_cfg_valid_cfgD:\n  assumes \"cfg \\<in> valid_cfg\" \"cfg' \\<in> K_cfg cfg\"\n  shows \"cfg' = cont cfg (state cfg')\" \"state cfg' \\<in> action cfg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cfg' = cont cfg (state cfg') &&& state cfg' \\<in> set_pmf (action cfg)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. cfg' = cont cfg (state cfg')\n 2. state cfg' \\<in> set_pmf (action cfg)", "from assms(2)"], ["proof (chain)\npicking this:\n  cfg' \\<in> set_pmf (K_cfg cfg)", "obtain s where \"s \\<in> action cfg\" \"cfg' = cont cfg s\""], ["proof (prove)\nusing this:\n  cfg' \\<in> set_pmf (K_cfg cfg)\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> set_pmf (action cfg); cfg' = cont cfg s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: set_K_cfg)"], ["proof (state)\nthis:\n  s \\<in> set_pmf (action cfg)\n  cfg' = cont cfg s\n\ngoal (2 subgoals):\n 1. cfg' = cont cfg (state cfg')\n 2. state cfg' \\<in> set_pmf (action cfg)", "with assms"], ["proof (chain)\npicking this:\n  cfg \\<in> MDP.valid_cfg\n  cfg' \\<in> set_pmf (K_cfg cfg)\n  s \\<in> set_pmf (action cfg)\n  cfg' = cont cfg s", "show\n    \"cfg' = cont cfg (state cfg')\" \"state cfg' \\<in> action cfg\""], ["proof (prove)\nusing this:\n  cfg \\<in> MDP.valid_cfg\n  cfg' \\<in> set_pmf (K_cfg cfg)\n  s \\<in> set_pmf (action cfg)\n  cfg' = cont cfg s\n\ngoal (1 subgoal):\n 1. cfg' = cont cfg (state cfg') &&& state cfg' \\<in> set_pmf (action cfg)", "by auto"], ["proof (state)\nthis:\n  cfg' = cont cfg (state cfg')\n  state cfg' \\<in> set_pmf (action cfg)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* XXX Move *)"], ["", "lemma absc_bisim_abss:\n  assumes \"absc x = absc x'\"\n  shows \"state x ~ state x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state x ~ state x'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. state x ~ state x'", "from assms"], ["proof (chain)\npicking this:\n  absc x = absc x'", "have \"state (absc x) = state (absc x')\""], ["proof (prove)\nusing this:\n  absc x = absc x'\n\ngoal (1 subgoal):\n 1. state (absc x) = state (absc x')", "by simp"], ["proof (state)\nthis:\n  state (absc x) = state (absc x')\n\ngoal (1 subgoal):\n 1. state x ~ state x'", "then"], ["proof (chain)\npicking this:\n  state (absc x) = state (absc x')", "show ?thesis"], ["proof (prove)\nusing this:\n  state (absc x) = state (absc x')\n\ngoal (1 subgoal):\n 1. state x ~ state x'", "by (simp add: state_absc)"], ["proof (state)\nthis:\n  state x ~ state x'\n\ngoal:\nNo subgoals!", "qed"], ["", "(* XXX Move *)"], ["", "lemma K_cfg_bisim_unique:\n  assumes \"cfg \\<in> valid_cfg\" and \"x \\<in> K_cfg cfg\" \"x' \\<in> K_cfg cfg\" and \"state x ~ state x'\"\n  shows \"x = x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = x'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x = x'", "define t where \"t \\<equiv> THE x'. x' ~ state x \\<and> x' \\<in> set_pmf (action cfg)\""], ["proof (state)\nthis:\n  t \\<equiv> THE x'. x' ~ state x \\<and> x' \\<in> set_pmf (action cfg)\n\ngoal (1 subgoal):\n 1. x = x'", "from K_cfg_valid_cfgD assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>?cfg \\<in> MDP.valid_cfg;\n   ?cfg' \\<in> set_pmf (K_cfg ?cfg)\\<rbrakk>\n  \\<Longrightarrow> ?cfg' = cont ?cfg (state ?cfg')\n  \\<lbrakk>?cfg \\<in> MDP.valid_cfg;\n   ?cfg' \\<in> set_pmf (K_cfg ?cfg)\\<rbrakk>\n  \\<Longrightarrow> state ?cfg' \\<in> set_pmf (action ?cfg)\n  cfg \\<in> MDP.valid_cfg\n  x \\<in> set_pmf (K_cfg cfg)\n  x' \\<in> set_pmf (K_cfg cfg)\n  state x ~ state x'", "have *:\n    \"x  = cont cfg (state x)\"  \"state x \\<in> action cfg\"\n    \"x' = cont cfg (state x')\" \"state x' \\<in> action cfg\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?cfg \\<in> MDP.valid_cfg;\n   ?cfg' \\<in> set_pmf (K_cfg ?cfg)\\<rbrakk>\n  \\<Longrightarrow> ?cfg' = cont ?cfg (state ?cfg')\n  \\<lbrakk>?cfg \\<in> MDP.valid_cfg;\n   ?cfg' \\<in> set_pmf (K_cfg ?cfg)\\<rbrakk>\n  \\<Longrightarrow> state ?cfg' \\<in> set_pmf (action ?cfg)\n  cfg \\<in> MDP.valid_cfg\n  x \\<in> set_pmf (K_cfg cfg)\n  x' \\<in> set_pmf (K_cfg cfg)\n  state x ~ state x'\n\ngoal (1 subgoal):\n 1. (x = cont cfg (state x) &&& state x \\<in> set_pmf (action cfg)) &&&\n    x' = cont cfg (state x') &&& state x' \\<in> set_pmf (action cfg)", "by auto"], ["proof (state)\nthis:\n  x = cont cfg (state x)\n  state x \\<in> set_pmf (action cfg)\n  x' = cont cfg (state x')\n  state x' \\<in> set_pmf (action cfg)\n\ngoal (1 subgoal):\n 1. x = x'", "with assms"], ["proof (chain)\npicking this:\n  cfg \\<in> MDP.valid_cfg\n  x \\<in> set_pmf (K_cfg cfg)\n  x' \\<in> set_pmf (K_cfg cfg)\n  state x ~ state x'\n  x = cont cfg (state x)\n  state x \\<in> set_pmf (action cfg)\n  x' = cont cfg (state x')\n  state x' \\<in> set_pmf (action cfg)", "have\n    \"cfg \\<in> valid_cfg\" \"abss (state x) \\<in> set_pmf (abst (action cfg))\""], ["proof (prove)\nusing this:\n  cfg \\<in> MDP.valid_cfg\n  x \\<in> set_pmf (K_cfg cfg)\n  x' \\<in> set_pmf (K_cfg cfg)\n  state x ~ state x'\n  x = cont cfg (state x)\n  state x \\<in> set_pmf (action cfg)\n  x' = cont cfg (state x')\n  state x' \\<in> set_pmf (action cfg)\n\ngoal (1 subgoal):\n 1. cfg \\<in> MDP.valid_cfg &&&\n    abss (state x) \\<in> set_pmf (abst (action cfg))", "unfolding abst_def"], ["proof (prove)\nusing this:\n  cfg \\<in> MDP.valid_cfg\n  x \\<in> set_pmf (K_cfg cfg)\n  x' \\<in> set_pmf (K_cfg cfg)\n  state x ~ state x'\n  x = cont cfg (state x)\n  state x \\<in> set_pmf (action cfg)\n  x' = cont cfg (state x')\n  state x' \\<in> set_pmf (action cfg)\n\ngoal (1 subgoal):\n 1. cfg \\<in> MDP.valid_cfg &&&\n    abss (state x) \\<in> set_pmf (map_pmf abss (action cfg))", "by auto"], ["proof (state)\nthis:\n  cfg \\<in> MDP.valid_cfg\n  abss (state x) \\<in> set_pmf (abst (action cfg))\n\ngoal (1 subgoal):\n 1. x = x'", "with cont_cfg_defined[of cfg \"abss (state x)\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>cfg \\<in> MDP.valid_cfg;\n   abss (state x) \\<in> set_pmf (abst (action cfg))\\<rbrakk>\n  \\<Longrightarrow> ((THE xa.\n                         xa ~ state x \\<and>\n                         xa \\<in> set_pmf (action cfg)) ~\n                     state x \\<and>\n                     (THE xa.\n                         xa ~ state x \\<and> xa \\<in> set_pmf (action cfg))\n                     \\<in> set_pmf (action cfg)) \\<and>\n                    (\\<forall>y.\n                        y ~ state x \\<and>\n                        y \\<in> set_pmf (action cfg) \\<longrightarrow>\n                        y =\n                        (THE xa.\n                            xa ~ state x \\<and>\n                            xa \\<in> set_pmf (action cfg)))\n  cfg \\<in> MDP.valid_cfg\n  abss (state x) \\<in> set_pmf (abst (action cfg))", "have\n    \"\\<forall>y. y ~ state x \\<and> y \\<in> set_pmf (action cfg) \\<longrightarrow> y = t\""], ["proof (prove)\nusing this:\n  \\<lbrakk>cfg \\<in> MDP.valid_cfg;\n   abss (state x) \\<in> set_pmf (abst (action cfg))\\<rbrakk>\n  \\<Longrightarrow> ((THE xa.\n                         xa ~ state x \\<and>\n                         xa \\<in> set_pmf (action cfg)) ~\n                     state x \\<and>\n                     (THE xa.\n                         xa ~ state x \\<and> xa \\<in> set_pmf (action cfg))\n                     \\<in> set_pmf (action cfg)) \\<and>\n                    (\\<forall>y.\n                        y ~ state x \\<and>\n                        y \\<in> set_pmf (action cfg) \\<longrightarrow>\n                        y =\n                        (THE xa.\n                            xa ~ state x \\<and>\n                            xa \\<in> set_pmf (action cfg)))\n  cfg \\<in> MDP.valid_cfg\n  abss (state x) \\<in> set_pmf (abst (action cfg))\n\ngoal (1 subgoal):\n 1. \\<forall>y.\n       y ~ state x \\<and> y \\<in> set_pmf (action cfg) \\<longrightarrow>\n       y = t", "unfolding t_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>cfg \\<in> MDP.valid_cfg;\n   abss (state x) \\<in> set_pmf (abst (action cfg))\\<rbrakk>\n  \\<Longrightarrow> ((THE xa.\n                         xa ~ state x \\<and>\n                         xa \\<in> set_pmf (action cfg)) ~\n                     state x \\<and>\n                     (THE xa.\n                         xa ~ state x \\<and> xa \\<in> set_pmf (action cfg))\n                     \\<in> set_pmf (action cfg)) \\<and>\n                    (\\<forall>y.\n                        y ~ state x \\<and>\n                        y \\<in> set_pmf (action cfg) \\<longrightarrow>\n                        y =\n                        (THE xa.\n                            xa ~ state x \\<and>\n                            xa \\<in> set_pmf (action cfg)))\n  cfg \\<in> MDP.valid_cfg\n  abss (state x) \\<in> set_pmf (abst (action cfg))\n\ngoal (1 subgoal):\n 1. \\<forall>y.\n       y ~ state x \\<and> y \\<in> set_pmf (action cfg) \\<longrightarrow>\n       y = (THE x'. x' ~ state x \\<and> x' \\<in> set_pmf (action cfg))", "by auto"], ["proof (state)\nthis:\n  \\<forall>y.\n     y ~ state x \\<and> y \\<in> set_pmf (action cfg) \\<longrightarrow> y = t\n\ngoal (1 subgoal):\n 1. x = x'", "with * assms(4)"], ["proof (chain)\npicking this:\n  x = cont cfg (state x)\n  state x \\<in> set_pmf (action cfg)\n  x' = cont cfg (state x')\n  state x' \\<in> set_pmf (action cfg)\n  state x ~ state x'\n  \\<forall>y.\n     y ~ state x \\<and> y \\<in> set_pmf (action cfg) \\<longrightarrow> y = t", "have \"state x' = t\" \"state x = t\""], ["proof (prove)\nusing this:\n  x = cont cfg (state x)\n  state x \\<in> set_pmf (action cfg)\n  x' = cont cfg (state x')\n  state x' \\<in> set_pmf (action cfg)\n  state x ~ state x'\n  \\<forall>y.\n     y ~ state x \\<and> y \\<in> set_pmf (action cfg) \\<longrightarrow> y = t\n\ngoal (1 subgoal):\n 1. state x' = t &&& state x = t", "by fastforce+"], ["proof (state)\nthis:\n  state x' = t\n  state x = t\n\ngoal (1 subgoal):\n 1. x = x'", "with *"], ["proof (chain)\npicking this:\n  x = cont cfg (state x)\n  state x \\<in> set_pmf (action cfg)\n  x' = cont cfg (state x')\n  state x' \\<in> set_pmf (action cfg)\n  state x' = t\n  state x = t", "show ?thesis"], ["proof (prove)\nusing this:\n  x = cont cfg (state x)\n  state x \\<in> set_pmf (action cfg)\n  x' = cont cfg (state x')\n  state x' \\<in> set_pmf (action cfg)\n  state x' = t\n  state x = t\n\ngoal (1 subgoal):\n 1. x = x'", "by simp"], ["proof (state)\nthis:\n  x = x'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma absc_distr_self:\n  \"MDP.MC.T (absc cfg) = distr (MDP.MC.T cfg) MDP.MC.S (smap absc)\" if \"cfg \\<in> valid_cfg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MDP.MC.T (absc cfg) =\n    distr (MDP.MC.T cfg) (stream_space (count_space UNIV)) (smap absc)", "using \\<open>cfg \\<in> _\\<close>"], ["proof (prove)\nusing this:\n  cfg \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. MDP.MC.T (absc cfg) =\n    distr (MDP.MC.T cfg) (stream_space (count_space UNIV)) (smap absc)", "proof (coinduction arbitrary: cfg rule: MDP.MC.T_coinduct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cfg.\n       cfg \\<in> MDP.valid_cfg \\<Longrightarrow>\n       prob_space\n        (distr (MDP.MC.T cfg) (stream_space (count_space UNIV)) (smap absc))\n 2. \\<And>cfg.\n       cfg \\<in> MDP.valid_cfg \\<Longrightarrow>\n       sets\n        (distr (MDP.MC.T cfg) (stream_space (count_space UNIV))\n          (smap absc)) =\n       sets (stream_space (count_space UNIV))\n 3. \\<And>cfg.\n       cfg \\<in> MDP.valid_cfg \\<Longrightarrow>\n       \\<exists>M'.\n          (\\<forall>y\\<in>set_pmf (K_cfg (absc cfg)).\n              \\<exists>cfg.\n                 y = absc cfg \\<and>\n                 M' y =\n                 distr (MDP.MC.T cfg) (stream_space (count_space UNIV))\n                  (smap absc) \\<and>\n                 cfg \\<in> MDP.valid_cfg) \\<and>\n          (\\<forall>y.\n              sets (M' y) = sets (stream_space (count_space UNIV)) \\<and>\n              prob_space (M' y)) \\<and>\n          distr (MDP.MC.T cfg) (stream_space (count_space UNIV))\n           (smap absc) =\n          measure_pmf (K_cfg (absc cfg)) \\<bind>\n          (\\<lambda>y.\n              distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "case prob"], ["proof (state)\nthis:\n  cfg \\<in> MDP.valid_cfg\n\ngoal (3 subgoals):\n 1. \\<And>cfg.\n       cfg \\<in> MDP.valid_cfg \\<Longrightarrow>\n       prob_space\n        (distr (MDP.MC.T cfg) (stream_space (count_space UNIV)) (smap absc))\n 2. \\<And>cfg.\n       cfg \\<in> MDP.valid_cfg \\<Longrightarrow>\n       sets\n        (distr (MDP.MC.T cfg) (stream_space (count_space UNIV))\n          (smap absc)) =\n       sets (stream_space (count_space UNIV))\n 3. \\<And>cfg.\n       cfg \\<in> MDP.valid_cfg \\<Longrightarrow>\n       \\<exists>M'.\n          (\\<forall>y\\<in>set_pmf (K_cfg (absc cfg)).\n              \\<exists>cfg.\n                 y = absc cfg \\<and>\n                 M' y =\n                 distr (MDP.MC.T cfg) (stream_space (count_space UNIV))\n                  (smap absc) \\<and>\n                 cfg \\<in> MDP.valid_cfg) \\<and>\n          (\\<forall>y.\n              sets (M' y) = sets (stream_space (count_space UNIV)) \\<and>\n              prob_space (M' y)) \\<and>\n          distr (MDP.MC.T cfg) (stream_space (count_space UNIV))\n           (smap absc) =\n          measure_pmf (K_cfg (absc cfg)) \\<bind>\n          (\\<lambda>y.\n              distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. prob_space\n     (distr (MDP.MC.T cfg) (stream_space (count_space UNIV)) (smap absc))", "by (rule MDP.MC.T.prob_space_distr, simp)"], ["proof (state)\nthis:\n  prob_space\n   (distr (MDP.MC.T cfg) (stream_space (count_space UNIV)) (smap absc))\n\ngoal (2 subgoals):\n 1. \\<And>cfg.\n       cfg \\<in> MDP.valid_cfg \\<Longrightarrow>\n       sets\n        (distr (MDP.MC.T cfg) (stream_space (count_space UNIV))\n          (smap absc)) =\n       sets (stream_space (count_space UNIV))\n 2. \\<And>cfg.\n       cfg \\<in> MDP.valid_cfg \\<Longrightarrow>\n       \\<exists>M'.\n          (\\<forall>y\\<in>set_pmf (K_cfg (absc cfg)).\n              \\<exists>cfg.\n                 y = absc cfg \\<and>\n                 M' y =\n                 distr (MDP.MC.T cfg) (stream_space (count_space UNIV))\n                  (smap absc) \\<and>\n                 cfg \\<in> MDP.valid_cfg) \\<and>\n          (\\<forall>y.\n              sets (M' y) = sets (stream_space (count_space UNIV)) \\<and>\n              prob_space (M' y)) \\<and>\n          distr (MDP.MC.T cfg) (stream_space (count_space UNIV))\n           (smap absc) =\n          measure_pmf (K_cfg (absc cfg)) \\<bind>\n          (\\<lambda>y.\n              distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cfg.\n       cfg \\<in> MDP.valid_cfg \\<Longrightarrow>\n       sets\n        (distr (MDP.MC.T cfg) (stream_space (count_space UNIV))\n          (smap absc)) =\n       sets (stream_space (count_space UNIV))\n 2. \\<And>cfg.\n       cfg \\<in> MDP.valid_cfg \\<Longrightarrow>\n       \\<exists>M'.\n          (\\<forall>y\\<in>set_pmf (K_cfg (absc cfg)).\n              \\<exists>cfg.\n                 y = absc cfg \\<and>\n                 M' y =\n                 distr (MDP.MC.T cfg) (stream_space (count_space UNIV))\n                  (smap absc) \\<and>\n                 cfg \\<in> MDP.valid_cfg) \\<and>\n          (\\<forall>y.\n              sets (M' y) = sets (stream_space (count_space UNIV)) \\<and>\n              prob_space (M' y)) \\<and>\n          distr (MDP.MC.T cfg) (stream_space (count_space UNIV))\n           (smap absc) =\n          measure_pmf (K_cfg (absc cfg)) \\<bind>\n          (\\<lambda>y.\n              distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "case sets"], ["proof (state)\nthis:\n  cfg \\<in> MDP.valid_cfg\n\ngoal (2 subgoals):\n 1. \\<And>cfg.\n       cfg \\<in> MDP.valid_cfg \\<Longrightarrow>\n       sets\n        (distr (MDP.MC.T cfg) (stream_space (count_space UNIV))\n          (smap absc)) =\n       sets (stream_space (count_space UNIV))\n 2. \\<And>cfg.\n       cfg \\<in> MDP.valid_cfg \\<Longrightarrow>\n       \\<exists>M'.\n          (\\<forall>y\\<in>set_pmf (K_cfg (absc cfg)).\n              \\<exists>cfg.\n                 y = absc cfg \\<and>\n                 M' y =\n                 distr (MDP.MC.T cfg) (stream_space (count_space UNIV))\n                  (smap absc) \\<and>\n                 cfg \\<in> MDP.valid_cfg) \\<and>\n          (\\<forall>y.\n              sets (M' y) = sets (stream_space (count_space UNIV)) \\<and>\n              prob_space (M' y)) \\<and>\n          distr (MDP.MC.T cfg) (stream_space (count_space UNIV))\n           (smap absc) =\n          measure_pmf (K_cfg (absc cfg)) \\<bind>\n          (\\<lambda>y.\n              distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sets\n     (distr (MDP.MC.T cfg) (stream_space (count_space UNIV)) (smap absc)) =\n    sets (stream_space (count_space UNIV))", "by auto"], ["proof (state)\nthis:\n  sets\n   (distr (MDP.MC.T cfg) (stream_space (count_space UNIV)) (smap absc)) =\n  sets (stream_space (count_space UNIV))\n\ngoal (1 subgoal):\n 1. \\<And>cfg.\n       cfg \\<in> MDP.valid_cfg \\<Longrightarrow>\n       \\<exists>M'.\n          (\\<forall>y\\<in>set_pmf (K_cfg (absc cfg)).\n              \\<exists>cfg.\n                 y = absc cfg \\<and>\n                 M' y =\n                 distr (MDP.MC.T cfg) (stream_space (count_space UNIV))\n                  (smap absc) \\<and>\n                 cfg \\<in> MDP.valid_cfg) \\<and>\n          (\\<forall>y.\n              sets (M' y) = sets (stream_space (count_space UNIV)) \\<and>\n              prob_space (M' y)) \\<and>\n          distr (MDP.MC.T cfg) (stream_space (count_space UNIV))\n           (smap absc) =\n          measure_pmf (K_cfg (absc cfg)) \\<bind>\n          (\\<lambda>y.\n              distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg.\n       cfg \\<in> MDP.valid_cfg \\<Longrightarrow>\n       \\<exists>M'.\n          (\\<forall>y\\<in>set_pmf (K_cfg (absc cfg)).\n              \\<exists>cfg.\n                 y = absc cfg \\<and>\n                 M' y =\n                 distr (MDP.MC.T cfg) (stream_space (count_space UNIV))\n                  (smap absc) \\<and>\n                 cfg \\<in> MDP.valid_cfg) \\<and>\n          (\\<forall>y.\n              sets (M' y) = sets (stream_space (count_space UNIV)) \\<and>\n              prob_space (M' y)) \\<and>\n          distr (MDP.MC.T cfg) (stream_space (count_space UNIV))\n           (smap absc) =\n          measure_pmf (K_cfg (absc cfg)) \\<bind>\n          (\\<lambda>y.\n              distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "case prems: (cont cfg)"], ["proof (state)\nthis:\n  cfg \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. \\<And>cfg.\n       cfg \\<in> MDP.valid_cfg \\<Longrightarrow>\n       \\<exists>M'.\n          (\\<forall>y\\<in>set_pmf (K_cfg (absc cfg)).\n              \\<exists>cfg.\n                 y = absc cfg \\<and>\n                 M' y =\n                 distr (MDP.MC.T cfg) (stream_space (count_space UNIV))\n                  (smap absc) \\<and>\n                 cfg \\<in> MDP.valid_cfg) \\<and>\n          (\\<forall>y.\n              sets (M' y) = sets (stream_space (count_space UNIV)) \\<and>\n              prob_space (M' y)) \\<and>\n          distr (MDP.MC.T cfg) (stream_space (count_space UNIV))\n           (smap absc) =\n          measure_pmf (K_cfg (absc cfg)) \\<bind>\n          (\\<lambda>y.\n              distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "define t  where \"t  \\<equiv> \\<lambda> y. THE x. y = absc x \\<and> x \\<in> K_cfg cfg\""], ["proof (state)\nthis:\n  t \\<equiv>\n  \\<lambda>y. THE x. y = absc x \\<and> x \\<in> set_pmf (K_cfg cfg)\n\ngoal (1 subgoal):\n 1. \\<And>cfg.\n       cfg \\<in> MDP.valid_cfg \\<Longrightarrow>\n       \\<exists>M'.\n          (\\<forall>y\\<in>set_pmf (K_cfg (absc cfg)).\n              \\<exists>cfg.\n                 y = absc cfg \\<and>\n                 M' y =\n                 distr (MDP.MC.T cfg) (stream_space (count_space UNIV))\n                  (smap absc) \\<and>\n                 cfg \\<in> MDP.valid_cfg) \\<and>\n          (\\<forall>y.\n              sets (M' y) = sets (stream_space (count_space UNIV)) \\<and>\n              prob_space (M' y)) \\<and>\n          distr (MDP.MC.T cfg) (stream_space (count_space UNIV))\n           (smap absc) =\n          measure_pmf (K_cfg (absc cfg)) \\<bind>\n          (\\<lambda>y.\n              distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "define M' where \"M' \\<equiv> \\<lambda> cfg. distr (MDP.MC.T (t cfg)) MDP.MC.S (smap absc)\""], ["proof (state)\nthis:\n  M' \\<equiv>\n  \\<lambda>cfg.\n     distr (MDP.MC.T (t cfg)) (stream_space (count_space UNIV)) (smap absc)\n\ngoal (1 subgoal):\n 1. \\<And>cfg.\n       cfg \\<in> MDP.valid_cfg \\<Longrightarrow>\n       \\<exists>M'.\n          (\\<forall>y\\<in>set_pmf (K_cfg (absc cfg)).\n              \\<exists>cfg.\n                 y = absc cfg \\<and>\n                 M' y =\n                 distr (MDP.MC.T cfg) (stream_space (count_space UNIV))\n                  (smap absc) \\<and>\n                 cfg \\<in> MDP.valid_cfg) \\<and>\n          (\\<forall>y.\n              sets (M' y) = sets (stream_space (count_space UNIV)) \\<and>\n              prob_space (M' y)) \\<and>\n          distr (MDP.MC.T cfg) (stream_space (count_space UNIV))\n           (smap absc) =\n          measure_pmf (K_cfg (absc cfg)) \\<bind>\n          (\\<lambda>y.\n              distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>M'.\n       (\\<forall>y\\<in>set_pmf (K_cfg (absc cfg)).\n           \\<exists>cfg.\n              y = absc cfg \\<and>\n              M' y =\n              distr (MDP.MC.T cfg) (stream_space (count_space UNIV))\n               (smap absc) \\<and>\n              cfg \\<in> MDP.valid_cfg) \\<and>\n       (\\<forall>y.\n           sets (M' y) = sets (stream_space (count_space UNIV)) \\<and>\n           prob_space (M' y)) \\<and>\n       distr (MDP.MC.T cfg) (stream_space (count_space UNIV)) (smap absc) =\n       measure_pmf (K_cfg (absc cfg)) \\<bind>\n       (\\<lambda>y. distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "proof (rule exI[where x = M'], safe, goal_cases)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>y.\n       y \\<in> set_pmf (K_cfg (absc cfg)) \\<Longrightarrow>\n       \\<exists>cfg.\n          y = absc cfg \\<and>\n          M' y =\n          distr (MDP.MC.T cfg) (stream_space (count_space UNIV))\n           (smap absc) \\<and>\n          cfg \\<in> MDP.valid_cfg\n 2. \\<And>y x.\n       x \\<in> sets (M' y) \\<Longrightarrow>\n       x \\<in> sets (stream_space (count_space UNIV))\n 3. \\<And>y x.\n       x \\<in> sets (stream_space (count_space UNIV)) \\<Longrightarrow>\n       x \\<in> sets (M' y)\n 4. \\<And>y. prob_space (M' y)\n 5. distr (MDP.MC.T cfg) (stream_space (count_space UNIV)) (smap absc) =\n    measure_pmf (K_cfg (absc cfg)) \\<bind>\n    (\\<lambda>y. distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "case A: (1 y)"], ["proof (state)\nthis:\n  y \\<in> set_pmf (K_cfg (absc cfg))\n\ngoal (5 subgoals):\n 1. \\<And>y.\n       y \\<in> set_pmf (K_cfg (absc cfg)) \\<Longrightarrow>\n       \\<exists>cfg.\n          y = absc cfg \\<and>\n          M' y =\n          distr (MDP.MC.T cfg) (stream_space (count_space UNIV))\n           (smap absc) \\<and>\n          cfg \\<in> MDP.valid_cfg\n 2. \\<And>y x.\n       x \\<in> sets (M' y) \\<Longrightarrow>\n       x \\<in> sets (stream_space (count_space UNIV))\n 3. \\<And>y x.\n       x \\<in> sets (stream_space (count_space UNIV)) \\<Longrightarrow>\n       x \\<in> sets (M' y)\n 4. \\<And>y. prob_space (M' y)\n 5. distr (MDP.MC.T cfg) (stream_space (count_space UNIV)) (smap absc) =\n    measure_pmf (K_cfg (absc cfg)) \\<bind>\n    (\\<lambda>y. distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "from A prems"], ["proof (chain)\npicking this:\n  y \\<in> set_pmf (K_cfg (absc cfg))\n  cfg \\<in> MDP.valid_cfg", "obtain x' where \"y = absc x'\" \"x' \\<in> K_cfg cfg\""], ["proof (prove)\nusing this:\n  y \\<in> set_pmf (K_cfg (absc cfg))\n  cfg \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>y = absc x'; x' \\<in> set_pmf (K_cfg cfg)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: K_cfg_map_absc)"], ["proof (state)\nthis:\n  y = absc x'\n  x' \\<in> set_pmf (K_cfg cfg)\n\ngoal (5 subgoals):\n 1. \\<And>y.\n       y \\<in> set_pmf (K_cfg (absc cfg)) \\<Longrightarrow>\n       \\<exists>cfg.\n          y = absc cfg \\<and>\n          M' y =\n          distr (MDP.MC.T cfg) (stream_space (count_space UNIV))\n           (smap absc) \\<and>\n          cfg \\<in> MDP.valid_cfg\n 2. \\<And>y x.\n       x \\<in> sets (M' y) \\<Longrightarrow>\n       x \\<in> sets (stream_space (count_space UNIV))\n 3. \\<And>y x.\n       x \\<in> sets (stream_space (count_space UNIV)) \\<Longrightarrow>\n       x \\<in> sets (M' y)\n 4. \\<And>y. prob_space (M' y)\n 5. distr (MDP.MC.T cfg) (stream_space (count_space UNIV)) (smap absc) =\n    measure_pmf (K_cfg (absc cfg)) \\<bind>\n    (\\<lambda>y. distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "with K_cfg_bisim_unique[OF prems _ _ absc_bisim_abss]"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<in> set_pmf (K_cfg cfg); ?x' \\<in> set_pmf (K_cfg cfg);\n   absc ?x = absc ?x'\\<rbrakk>\n  \\<Longrightarrow> ?x = ?x'\n  y = absc x'\n  x' \\<in> set_pmf (K_cfg cfg)", "have\n      \"y = absc (t y)\" \"x' = t y\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set_pmf (K_cfg cfg); ?x' \\<in> set_pmf (K_cfg cfg);\n   absc ?x = absc ?x'\\<rbrakk>\n  \\<Longrightarrow> ?x = ?x'\n  y = absc x'\n  x' \\<in> set_pmf (K_cfg cfg)\n\ngoal (1 subgoal):\n 1. y = absc (t y) &&& x' = t y", "unfolding t_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set_pmf (K_cfg cfg); ?x' \\<in> set_pmf (K_cfg cfg);\n   absc ?x = absc ?x'\\<rbrakk>\n  \\<Longrightarrow> ?x = ?x'\n  y = absc x'\n  x' \\<in> set_pmf (K_cfg cfg)\n\ngoal (1 subgoal):\n 1. y = absc (THE x. y = absc x \\<and> x \\<in> set_pmf (K_cfg cfg)) &&&\n    x' = (THE x. y = absc x \\<and> x \\<in> set_pmf (K_cfg cfg))", "by (auto intro: theI2)"], ["proof (state)\nthis:\n  y = absc (t y)\n  x' = t y\n\ngoal (5 subgoals):\n 1. \\<And>y.\n       y \\<in> set_pmf (K_cfg (absc cfg)) \\<Longrightarrow>\n       \\<exists>cfg.\n          y = absc cfg \\<and>\n          M' y =\n          distr (MDP.MC.T cfg) (stream_space (count_space UNIV))\n           (smap absc) \\<and>\n          cfg \\<in> MDP.valid_cfg\n 2. \\<And>y x.\n       x \\<in> sets (M' y) \\<Longrightarrow>\n       x \\<in> sets (stream_space (count_space UNIV))\n 3. \\<And>y x.\n       x \\<in> sets (stream_space (count_space UNIV)) \\<Longrightarrow>\n       x \\<in> sets (M' y)\n 4. \\<And>y. prob_space (M' y)\n 5. distr (MDP.MC.T cfg) (stream_space (count_space UNIV)) (smap absc) =\n    measure_pmf (K_cfg (absc cfg)) \\<bind>\n    (\\<lambda>y. distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "moreover"], ["proof (state)\nthis:\n  y = absc (t y)\n  x' = t y\n\ngoal (5 subgoals):\n 1. \\<And>y.\n       y \\<in> set_pmf (K_cfg (absc cfg)) \\<Longrightarrow>\n       \\<exists>cfg.\n          y = absc cfg \\<and>\n          M' y =\n          distr (MDP.MC.T cfg) (stream_space (count_space UNIV))\n           (smap absc) \\<and>\n          cfg \\<in> MDP.valid_cfg\n 2. \\<And>y x.\n       x \\<in> sets (M' y) \\<Longrightarrow>\n       x \\<in> sets (stream_space (count_space UNIV))\n 3. \\<And>y x.\n       x \\<in> sets (stream_space (count_space UNIV)) \\<Longrightarrow>\n       x \\<in> sets (M' y)\n 4. \\<And>y. prob_space (M' y)\n 5. distr (MDP.MC.T cfg) (stream_space (count_space UNIV)) (smap absc) =\n    measure_pmf (K_cfg (absc cfg)) \\<bind>\n    (\\<lambda>y. distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "have \"x' \\<in> valid_cfg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x' \\<in> MDP.valid_cfg", "using \\<open>x' \\<in> _\\<close> prems"], ["proof (prove)\nusing this:\n  x' \\<in> set_pmf (K_cfg cfg)\n  cfg \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. x' \\<in> MDP.valid_cfg", "by auto"], ["proof (state)\nthis:\n  x' \\<in> MDP.valid_cfg\n\ngoal (5 subgoals):\n 1. \\<And>y.\n       y \\<in> set_pmf (K_cfg (absc cfg)) \\<Longrightarrow>\n       \\<exists>cfg.\n          y = absc cfg \\<and>\n          M' y =\n          distr (MDP.MC.T cfg) (stream_space (count_space UNIV))\n           (smap absc) \\<and>\n          cfg \\<in> MDP.valid_cfg\n 2. \\<And>y x.\n       x \\<in> sets (M' y) \\<Longrightarrow>\n       x \\<in> sets (stream_space (count_space UNIV))\n 3. \\<And>y x.\n       x \\<in> sets (stream_space (count_space UNIV)) \\<Longrightarrow>\n       x \\<in> sets (M' y)\n 4. \\<And>y. prob_space (M' y)\n 5. distr (MDP.MC.T cfg) (stream_space (count_space UNIV)) (smap absc) =\n    measure_pmf (K_cfg (absc cfg)) \\<bind>\n    (\\<lambda>y. distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "ultimately"], ["proof (chain)\npicking this:\n  y = absc (t y)\n  x' = t y\n  x' \\<in> MDP.valid_cfg", "show ?case"], ["proof (prove)\nusing this:\n  y = absc (t y)\n  x' = t y\n  x' \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. \\<exists>cfg.\n       y = absc cfg \\<and>\n       M' y =\n       distr (MDP.MC.T cfg) (stream_space (count_space UNIV))\n        (smap absc) \\<and>\n       cfg \\<in> MDP.valid_cfg", "unfolding M'_def"], ["proof (prove)\nusing this:\n  y = absc (t y)\n  x' = t y\n  x' \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. \\<exists>cfg.\n       y = absc cfg \\<and>\n       distr (MDP.MC.T (t y)) (stream_space (count_space UNIV))\n        (smap absc) =\n       distr (MDP.MC.T cfg) (stream_space (count_space UNIV))\n        (smap absc) \\<and>\n       cfg \\<in> MDP.valid_cfg", "by auto"], ["proof (state)\nthis:\n  \\<exists>cfg.\n     y = absc cfg \\<and>\n     M' y =\n     distr (MDP.MC.T cfg) (stream_space (count_space UNIV))\n      (smap absc) \\<and>\n     cfg \\<in> MDP.valid_cfg\n\ngoal (4 subgoals):\n 1. \\<And>y x.\n       x \\<in> sets (M' y) \\<Longrightarrow>\n       x \\<in> sets (stream_space (count_space UNIV))\n 2. \\<And>y x.\n       x \\<in> sets (stream_space (count_space UNIV)) \\<Longrightarrow>\n       x \\<in> sets (M' y)\n 3. \\<And>y. prob_space (M' y)\n 4. distr (MDP.MC.T cfg) (stream_space (count_space UNIV)) (smap absc) =\n    measure_pmf (K_cfg (absc cfg)) \\<bind>\n    (\\<lambda>y. distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>y x.\n       x \\<in> sets (M' y) \\<Longrightarrow>\n       x \\<in> sets (stream_space (count_space UNIV))\n 2. \\<And>y x.\n       x \\<in> sets (stream_space (count_space UNIV)) \\<Longrightarrow>\n       x \\<in> sets (M' y)\n 3. \\<And>y. prob_space (M' y)\n 4. distr (MDP.MC.T cfg) (stream_space (count_space UNIV)) (smap absc) =\n    measure_pmf (K_cfg (absc cfg)) \\<bind>\n    (\\<lambda>y. distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "case 5"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>y x.\n       x \\<in> sets (M' y) \\<Longrightarrow>\n       x \\<in> sets (stream_space (count_space UNIV))\n 2. \\<And>y x.\n       x \\<in> sets (stream_space (count_space UNIV)) \\<Longrightarrow>\n       x \\<in> sets (M' y)\n 3. \\<And>y. prob_space (M' y)\n 4. distr (MDP.MC.T cfg) (stream_space (count_space UNIV)) (smap absc) =\n    measure_pmf (K_cfg (absc cfg)) \\<bind>\n    (\\<lambda>y. distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. distr (MDP.MC.T cfg) (stream_space (count_space UNIV)) (smap absc) =\n    measure_pmf (K_cfg (absc cfg)) \\<bind>\n    (\\<lambda>y. distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "unfolding M'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distr (MDP.MC.T cfg) (stream_space (count_space UNIV)) (smap absc) =\n    measure_pmf (K_cfg (absc cfg)) \\<bind>\n    (\\<lambda>y.\n        distr\n         (distr (MDP.MC.T (t y)) (stream_space (count_space UNIV))\n           (smap absc))\n         (stream_space (count_space UNIV)) ((##) y))", "apply (subst distr_distr)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y.\n       (##) y\n       \\<in> stream_space (count_space UNIV) \\<rightarrow>\\<^sub>M\n             stream_space (count_space UNIV)\n 2. \\<And>y.\n       MDP.MC.T.random_variable (t y) (stream_space (count_space UNIV))\n        (smap absc)\n 3. distr (MDP.MC.T cfg) (stream_space (count_space UNIV)) (smap absc) =\n    measure_pmf (K_cfg (absc cfg)) \\<bind>\n    (\\<lambda>y.\n        distr (MDP.MC.T (t y)) (stream_space (count_space UNIV))\n         ((##) y \\<circ> smap absc))", "prefer 3"], ["proof (prove)\ngoal (3 subgoals):\n 1. distr (MDP.MC.T cfg) (stream_space (count_space UNIV)) (smap absc) =\n    measure_pmf (K_cfg (absc cfg)) \\<bind>\n    (\\<lambda>y.\n        distr (MDP.MC.T (t y)) (stream_space (count_space UNIV))\n         ((##) y \\<circ> smap absc))\n 2. \\<And>y.\n       (##) y\n       \\<in> stream_space (count_space UNIV) \\<rightarrow>\\<^sub>M\n             stream_space (count_space UNIV)\n 3. \\<And>y.\n       MDP.MC.T.random_variable (t y) (stream_space (count_space UNIV))\n        (smap absc)", "apply (subst MDP.MC.T_eq_bind)"], ["proof (prove)\ngoal (3 subgoals):\n 1. distr\n     (measure_pmf (K_cfg cfg) \\<bind>\n      (\\<lambda>t.\n          distr (MDP.MC.T t) (stream_space (count_space UNIV)) ((##) t)))\n     (stream_space (count_space UNIV)) (smap absc) =\n    measure_pmf (K_cfg (absc cfg)) \\<bind>\n    (\\<lambda>y.\n        distr (MDP.MC.T (t y)) (stream_space (count_space UNIV))\n         ((##) y \\<circ> smap absc))\n 2. \\<And>y.\n       (##) y\n       \\<in> stream_space (count_space UNIV) \\<rightarrow>\\<^sub>M\n             stream_space (count_space UNIV)\n 3. \\<And>y.\n       MDP.MC.T.random_variable (t y) (stream_space (count_space UNIV))\n        (smap absc)", "apply (subst distr_bind)"], ["proof (prove)\ngoal (6 subgoals):\n 1. measure_pmf.random_variable (K_cfg cfg) (subprob_algebra ?K3)\n     (\\<lambda>t.\n         distr (MDP.MC.T t) (stream_space (count_space UNIV)) ((##) t))\n 2. space (measure_pmf (K_cfg cfg)) \\<noteq> {}\n 3. smap absc\n    \\<in> ?K3 \\<rightarrow>\\<^sub>M stream_space (count_space UNIV)\n 4. measure_pmf (K_cfg cfg) \\<bind>\n    (\\<lambda>x.\n        distr\n         (distr (MDP.MC.T x) (stream_space (count_space UNIV)) ((##) x))\n         (stream_space (count_space UNIV)) (smap absc)) =\n    measure_pmf (K_cfg (absc cfg)) \\<bind>\n    (\\<lambda>y.\n        distr (MDP.MC.T (t y)) (stream_space (count_space UNIV))\n         ((##) y \\<circ> smap absc))\n 5. \\<And>y.\n       (##) y\n       \\<in> stream_space (count_space UNIV) \\<rightarrow>\\<^sub>M\n             stream_space (count_space UNIV)\n 6. \\<And>y.\n       MDP.MC.T.random_variable (t y) (stream_space (count_space UNIV))\n        (smap absc)", "prefer 4"], ["proof (prove)\ngoal (6 subgoals):\n 1. measure_pmf (K_cfg cfg) \\<bind>\n    (\\<lambda>x.\n        distr\n         (distr (MDP.MC.T x) (stream_space (count_space UNIV)) ((##) x))\n         (stream_space (count_space UNIV)) (smap absc)) =\n    measure_pmf (K_cfg (absc cfg)) \\<bind>\n    (\\<lambda>y.\n        distr (MDP.MC.T (t y)) (stream_space (count_space UNIV))\n         ((##) y \\<circ> smap absc))\n 2. measure_pmf.random_variable (K_cfg cfg) (subprob_algebra ?K3)\n     (\\<lambda>t.\n         distr (MDP.MC.T t) (stream_space (count_space UNIV)) ((##) t))\n 3. space (measure_pmf (K_cfg cfg)) \\<noteq> {}\n 4. smap absc\n    \\<in> ?K3 \\<rightarrow>\\<^sub>M stream_space (count_space UNIV)\n 5. \\<And>y.\n       (##) y\n       \\<in> stream_space (count_space UNIV) \\<rightarrow>\\<^sub>M\n             stream_space (count_space UNIV)\n 6. \\<And>y.\n       MDP.MC.T.random_variable (t y) (stream_space (count_space UNIV))\n        (smap absc)", "apply (subst distr_distr)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x.\n       smap absc\n       \\<in> stream_space (count_space UNIV) \\<rightarrow>\\<^sub>M\n             stream_space (count_space UNIV)\n 2. \\<And>x.\n       MDP.MC.T.random_variable x (stream_space (count_space UNIV)) ((##) x)\n 3. measure_pmf (K_cfg cfg) \\<bind>\n    (\\<lambda>x.\n        distr (MDP.MC.T x) (stream_space (count_space UNIV))\n         (smap absc \\<circ> (##) x)) =\n    measure_pmf (K_cfg (absc cfg)) \\<bind>\n    (\\<lambda>y.\n        distr (MDP.MC.T (t y)) (stream_space (count_space UNIV))\n         ((##) y \\<circ> smap absc))\n 4. measure_pmf.random_variable (K_cfg cfg) (subprob_algebra ?K3)\n     (\\<lambda>t.\n         distr (MDP.MC.T t) (stream_space (count_space UNIV)) ((##) t))\n 5. space (measure_pmf (K_cfg cfg)) \\<noteq> {}\n 6. smap absc\n    \\<in> ?K3 \\<rightarrow>\\<^sub>M stream_space (count_space UNIV)\n 7. \\<And>y.\n       (##) y\n       \\<in> stream_space (count_space UNIV) \\<rightarrow>\\<^sub>M\n             stream_space (count_space UNIV)\n 8. \\<And>y.\n       MDP.MC.T.random_variable (t y) (stream_space (count_space UNIV))\n        (smap absc)", "prefer 3"], ["proof (prove)\ngoal (8 subgoals):\n 1. measure_pmf (K_cfg cfg) \\<bind>\n    (\\<lambda>x.\n        distr (MDP.MC.T x) (stream_space (count_space UNIV))\n         (smap absc \\<circ> (##) x)) =\n    measure_pmf (K_cfg (absc cfg)) \\<bind>\n    (\\<lambda>y.\n        distr (MDP.MC.T (t y)) (stream_space (count_space UNIV))\n         ((##) y \\<circ> smap absc))\n 2. \\<And>x.\n       smap absc\n       \\<in> stream_space (count_space UNIV) \\<rightarrow>\\<^sub>M\n             stream_space (count_space UNIV)\n 3. \\<And>x.\n       MDP.MC.T.random_variable x (stream_space (count_space UNIV)) ((##) x)\n 4. measure_pmf.random_variable (K_cfg cfg) (subprob_algebra ?K3)\n     (\\<lambda>t.\n         distr (MDP.MC.T t) (stream_space (count_space UNIV)) ((##) t))\n 5. space (measure_pmf (K_cfg cfg)) \\<noteq> {}\n 6. smap absc\n    \\<in> ?K3 \\<rightarrow>\\<^sub>M stream_space (count_space UNIV)\n 7. \\<And>y.\n       (##) y\n       \\<in> stream_space (count_space UNIV) \\<rightarrow>\\<^sub>M\n             stream_space (count_space UNIV)\n 8. \\<And>y.\n       MDP.MC.T.random_variable (t y) (stream_space (count_space UNIV))\n        (smap absc)", "apply (subst K_cfg_map_absc)"], ["proof (prove)\ngoal (9 subgoals):\n 1. cfg \\<in> MDP.valid_cfg\n 2. measure_pmf (K_cfg cfg) \\<bind>\n    (\\<lambda>x.\n        distr (MDP.MC.T x) (stream_space (count_space UNIV))\n         (smap absc \\<circ> (##) x)) =\n    measure_pmf (map_pmf absc (K_cfg cfg)) \\<bind>\n    (\\<lambda>y.\n        distr (MDP.MC.T (t y)) (stream_space (count_space UNIV))\n         ((##) y \\<circ> smap absc))\n 3. \\<And>x.\n       smap absc\n       \\<in> stream_space (count_space UNIV) \\<rightarrow>\\<^sub>M\n             stream_space (count_space UNIV)\n 4. \\<And>x.\n       MDP.MC.T.random_variable x (stream_space (count_space UNIV)) ((##) x)\n 5. measure_pmf.random_variable (K_cfg cfg) (subprob_algebra ?K3)\n     (\\<lambda>t.\n         distr (MDP.MC.T t) (stream_space (count_space UNIV)) ((##) t))\n 6. space (measure_pmf (K_cfg cfg)) \\<noteq> {}\n 7. smap absc\n    \\<in> ?K3 \\<rightarrow>\\<^sub>M stream_space (count_space UNIV)\n 8. \\<And>y.\n       (##) y\n       \\<in> stream_space (count_space UNIV) \\<rightarrow>\\<^sub>M\n             stream_space (count_space UNIV)\n 9. \\<And>y.\n       MDP.MC.T.random_variable (t y) (stream_space (count_space UNIV))\n        (smap absc)", "apply (rule prems)"], ["proof (prove)\ngoal (8 subgoals):\n 1. measure_pmf (K_cfg cfg) \\<bind>\n    (\\<lambda>x.\n        distr (MDP.MC.T x) (stream_space (count_space UNIV))\n         (smap absc \\<circ> (##) x)) =\n    measure_pmf (map_pmf absc (K_cfg cfg)) \\<bind>\n    (\\<lambda>y.\n        distr (MDP.MC.T (t y)) (stream_space (count_space UNIV))\n         ((##) y \\<circ> smap absc))\n 2. \\<And>x.\n       smap absc\n       \\<in> stream_space (count_space UNIV) \\<rightarrow>\\<^sub>M\n             stream_space (count_space UNIV)\n 3. \\<And>x.\n       MDP.MC.T.random_variable x (stream_space (count_space UNIV)) ((##) x)\n 4. measure_pmf.random_variable (K_cfg cfg) (subprob_algebra ?K3)\n     (\\<lambda>t.\n         distr (MDP.MC.T t) (stream_space (count_space UNIV)) ((##) t))\n 5. space (measure_pmf (K_cfg cfg)) \\<noteq> {}\n 6. smap absc\n    \\<in> ?K3 \\<rightarrow>\\<^sub>M stream_space (count_space UNIV)\n 7. \\<And>y.\n       (##) y\n       \\<in> stream_space (count_space UNIV) \\<rightarrow>\\<^sub>M\n             stream_space (count_space UNIV)\n 8. \\<And>y.\n       MDP.MC.T.random_variable (t y) (stream_space (count_space UNIV))\n        (smap absc)", "apply (subst map_pmf_rep_eq)"], ["proof (prove)\ngoal (8 subgoals):\n 1. measure_pmf (K_cfg cfg) \\<bind>\n    (\\<lambda>x.\n        distr (MDP.MC.T x) (stream_space (count_space UNIV))\n         (smap absc \\<circ> (##) x)) =\n    distr (measure_pmf (K_cfg cfg)) (count_space UNIV) absc \\<bind>\n    (\\<lambda>y.\n        distr (MDP.MC.T (t y)) (stream_space (count_space UNIV))\n         ((##) y \\<circ> smap absc))\n 2. \\<And>x.\n       smap absc\n       \\<in> stream_space (count_space UNIV) \\<rightarrow>\\<^sub>M\n             stream_space (count_space UNIV)\n 3. \\<And>x.\n       MDP.MC.T.random_variable x (stream_space (count_space UNIV)) ((##) x)\n 4. measure_pmf.random_variable (K_cfg cfg) (subprob_algebra ?K3)\n     (\\<lambda>t.\n         distr (MDP.MC.T t) (stream_space (count_space UNIV)) ((##) t))\n 5. space (measure_pmf (K_cfg cfg)) \\<noteq> {}\n 6. smap absc\n    \\<in> ?K3 \\<rightarrow>\\<^sub>M stream_space (count_space UNIV)\n 7. \\<And>y.\n       (##) y\n       \\<in> stream_space (count_space UNIV) \\<rightarrow>\\<^sub>M\n             stream_space (count_space UNIV)\n 8. \\<And>y.\n       MDP.MC.T.random_variable (t y) (stream_space (count_space UNIV))\n        (smap absc)", "apply (subst bind_distr)"], ["proof (prove)\ngoal (11 subgoals):\n 1. measure_pmf.random_variable (K_cfg cfg) (count_space UNIV) absc\n 2. (\\<lambda>y.\n        distr (MDP.MC.T (t y)) (stream_space (count_space UNIV))\n         ((##) y \\<circ> smap absc))\n    \\<in> count_space UNIV \\<rightarrow>\\<^sub>M subprob_algebra ?K12\n 3. space (measure_pmf (K_cfg cfg)) \\<noteq> {}\n 4. measure_pmf (K_cfg cfg) \\<bind>\n    (\\<lambda>x.\n        distr (MDP.MC.T x) (stream_space (count_space UNIV))\n         (smap absc \\<circ> (##) x)) =\n    measure_pmf (K_cfg cfg) \\<bind>\n    (\\<lambda>x.\n        distr (MDP.MC.T (t (absc x))) (stream_space (count_space UNIV))\n         ((##) (absc x) \\<circ> smap absc))\n 5. \\<And>x.\n       smap absc\n       \\<in> stream_space (count_space UNIV) \\<rightarrow>\\<^sub>M\n             stream_space (count_space UNIV)\n 6. \\<And>x.\n       MDP.MC.T.random_variable x (stream_space (count_space UNIV)) ((##) x)\n 7. measure_pmf.random_variable (K_cfg cfg) (subprob_algebra ?K3)\n     (\\<lambda>t.\n         distr (MDP.MC.T t) (stream_space (count_space UNIV)) ((##) t))\n 8. space (measure_pmf (K_cfg cfg)) \\<noteq> {}\n 9. smap absc\n    \\<in> ?K3 \\<rightarrow>\\<^sub>M stream_space (count_space UNIV)\n 10. \\<And>y.\n        (##) y\n        \\<in> stream_space (count_space UNIV) \\<rightarrow>\\<^sub>M\n              stream_space (count_space UNIV)\nA total of 11 subgoals...", "prefer 4"], ["proof (prove)\ngoal (11 subgoals):\n 1. measure_pmf (K_cfg cfg) \\<bind>\n    (\\<lambda>x.\n        distr (MDP.MC.T x) (stream_space (count_space UNIV))\n         (smap absc \\<circ> (##) x)) =\n    measure_pmf (K_cfg cfg) \\<bind>\n    (\\<lambda>x.\n        distr (MDP.MC.T (t (absc x))) (stream_space (count_space UNIV))\n         ((##) (absc x) \\<circ> smap absc))\n 2. measure_pmf.random_variable (K_cfg cfg) (count_space UNIV) absc\n 3. (\\<lambda>y.\n        distr (MDP.MC.T (t y)) (stream_space (count_space UNIV))\n         ((##) y \\<circ> smap absc))\n    \\<in> count_space UNIV \\<rightarrow>\\<^sub>M subprob_algebra ?K12\n 4. space (measure_pmf (K_cfg cfg)) \\<noteq> {}\n 5. \\<And>x.\n       smap absc\n       \\<in> stream_space (count_space UNIV) \\<rightarrow>\\<^sub>M\n             stream_space (count_space UNIV)\n 6. \\<And>x.\n       MDP.MC.T.random_variable x (stream_space (count_space UNIV)) ((##) x)\n 7. measure_pmf.random_variable (K_cfg cfg) (subprob_algebra ?K3)\n     (\\<lambda>t.\n         distr (MDP.MC.T t) (stream_space (count_space UNIV)) ((##) t))\n 8. space (measure_pmf (K_cfg cfg)) \\<noteq> {}\n 9. smap absc\n    \\<in> ?K3 \\<rightarrow>\\<^sub>M stream_space (count_space UNIV)\n 10. \\<And>y.\n        (##) y\n        \\<in> stream_space (count_space UNIV) \\<rightarrow>\\<^sub>M\n              stream_space (count_space UNIV)\nA total of 11 subgoals...", "apply (rule bind_measure_pmf_cong)"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>x.\n       distr (MDP.MC.T x) (stream_space (count_space UNIV))\n        (smap absc \\<circ> (##) x)\n       \\<in> space (subprob_algebra ?N14)\n 2. \\<And>x.\n       distr (MDP.MC.T (t (absc x))) (stream_space (count_space UNIV))\n        ((##) (absc x) \\<circ> smap absc)\n       \\<in> space (subprob_algebra ?N14)\n 3. \\<And>i.\n       i \\<in> set_pmf (K_cfg cfg) \\<Longrightarrow>\n       distr (MDP.MC.T i) (stream_space (count_space UNIV))\n        (smap absc \\<circ> (##) i) =\n       distr (MDP.MC.T (t (absc i))) (stream_space (count_space UNIV))\n        ((##) (absc i) \\<circ> smap absc)\n 4. measure_pmf.random_variable (K_cfg cfg) (count_space UNIV) absc\n 5. (\\<lambda>y.\n        distr (MDP.MC.T (t y)) (stream_space (count_space UNIV))\n         ((##) y \\<circ> smap absc))\n    \\<in> count_space UNIV \\<rightarrow>\\<^sub>M subprob_algebra ?K12\n 6. space (measure_pmf (K_cfg cfg)) \\<noteq> {}\n 7. \\<And>x.\n       smap absc\n       \\<in> stream_space (count_space UNIV) \\<rightarrow>\\<^sub>M\n             stream_space (count_space UNIV)\n 8. \\<And>x.\n       MDP.MC.T.random_variable x (stream_space (count_space UNIV)) ((##) x)\n 9. measure_pmf.random_variable (K_cfg cfg) (subprob_algebra ?K3)\n     (\\<lambda>t.\n         distr (MDP.MC.T t) (stream_space (count_space UNIV)) ((##) t))\n 10. space (measure_pmf (K_cfg cfg)) \\<noteq> {}\nA total of 13 subgoals...", "prefer 3"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>i.\n       i \\<in> set_pmf (K_cfg cfg) \\<Longrightarrow>\n       distr (MDP.MC.T i) (stream_space (count_space UNIV))\n        (smap absc \\<circ> (##) i) =\n       distr (MDP.MC.T (t (absc i))) (stream_space (count_space UNIV))\n        ((##) (absc i) \\<circ> smap absc)\n 2. \\<And>x.\n       distr (MDP.MC.T x) (stream_space (count_space UNIV))\n        (smap absc \\<circ> (##) x)\n       \\<in> space (subprob_algebra ?N14)\n 3. \\<And>x.\n       distr (MDP.MC.T (t (absc x))) (stream_space (count_space UNIV))\n        ((##) (absc x) \\<circ> smap absc)\n       \\<in> space (subprob_algebra ?N14)\n 4. measure_pmf.random_variable (K_cfg cfg) (count_space UNIV) absc\n 5. (\\<lambda>y.\n        distr (MDP.MC.T (t y)) (stream_space (count_space UNIV))\n         ((##) y \\<circ> smap absc))\n    \\<in> count_space UNIV \\<rightarrow>\\<^sub>M subprob_algebra ?K12\n 6. space (measure_pmf (K_cfg cfg)) \\<noteq> {}\n 7. \\<And>x.\n       smap absc\n       \\<in> stream_space (count_space UNIV) \\<rightarrow>\\<^sub>M\n             stream_space (count_space UNIV)\n 8. \\<And>x.\n       MDP.MC.T.random_variable x (stream_space (count_space UNIV)) ((##) x)\n 9. measure_pmf.random_variable (K_cfg cfg) (subprob_algebra ?K3)\n     (\\<lambda>t.\n         distr (MDP.MC.T t) (stream_space (count_space UNIV)) ((##) t))\n 10. space (measure_pmf (K_cfg cfg)) \\<noteq> {}\nA total of 13 subgoals...", "subgoal premises A for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. distr (MDP.MC.T x) (stream_space (count_space UNIV))\n     (smap absc \\<circ> (##) x) =\n    distr (MDP.MC.T (t (absc x))) (stream_space (count_space UNIV))\n     ((##) (absc x) \\<circ> smap absc)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distr (MDP.MC.T x) (stream_space (count_space UNIV))\n     (smap absc \\<circ> (##) x) =\n    distr (MDP.MC.T (t (absc x))) (stream_space (count_space UNIV))\n     ((##) (absc x) \\<circ> smap absc)", "have \"t (absc x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t (absc x) = x", "unfolding t_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE xa. absc x = absc xa \\<and> xa \\<in> set_pmf (K_cfg cfg)) = x", "proof (rule the_equality, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. absc x = absc x \\<and> x \\<in> set_pmf (K_cfg cfg)\n 2. \\<And>xa.\n       absc x = absc xa \\<and>\n       xa \\<in> set_pmf (K_cfg cfg) \\<Longrightarrow>\n       xa = x", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. absc x = absc x \\<and> x \\<in> set_pmf (K_cfg cfg)\n 2. \\<And>xa.\n       absc x = absc xa \\<and>\n       xa \\<in> set_pmf (K_cfg cfg) \\<Longrightarrow>\n       xa = x", "with A"], ["proof (chain)\npicking this:\n  x \\<in> set_pmf (K_cfg cfg)", "show ?case"], ["proof (prove)\nusing this:\n  x \\<in> set_pmf (K_cfg cfg)\n\ngoal (1 subgoal):\n 1. absc x = absc x \\<and> x \\<in> set_pmf (K_cfg cfg)", "by simp"], ["proof (state)\nthis:\n  absc x = absc x \\<and> x \\<in> set_pmf (K_cfg cfg)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       absc x = absc xa \\<and>\n       xa \\<in> set_pmf (K_cfg cfg) \\<Longrightarrow>\n       xa = x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       absc x = absc xa \\<and>\n       xa \\<in> set_pmf (K_cfg cfg) \\<Longrightarrow>\n       xa = x", "case (2 x')"], ["proof (state)\nthis:\n  absc x = absc x' \\<and> x' \\<in> set_pmf (K_cfg cfg)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       absc x = absc xa \\<and>\n       xa \\<in> set_pmf (K_cfg cfg) \\<Longrightarrow>\n       xa = x", "with K_cfg_bisim_unique[OF prems _ A absc_bisim_abss]"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<in> set_pmf (K_cfg cfg); absc ?x = absc x\\<rbrakk>\n  \\<Longrightarrow> ?x = x\n  absc x = absc x' \\<and> x' \\<in> set_pmf (K_cfg cfg)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set_pmf (K_cfg cfg); absc ?x = absc x\\<rbrakk>\n  \\<Longrightarrow> ?x = x\n  absc x = absc x' \\<and> x' \\<in> set_pmf (K_cfg cfg)\n\ngoal (1 subgoal):\n 1. x' = x", "by simp"], ["proof (state)\nthis:\n  x' = x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t (absc x) = x\n\ngoal (1 subgoal):\n 1. distr (MDP.MC.T x) (stream_space (count_space UNIV))\n     (smap absc \\<circ> (##) x) =\n    distr (MDP.MC.T (t (absc x))) (stream_space (count_space UNIV))\n     ((##) (absc x) \\<circ> smap absc)", "then"], ["proof (chain)\npicking this:\n  t (absc x) = x", "show ?thesis"], ["proof (prove)\nusing this:\n  t (absc x) = x\n\ngoal (1 subgoal):\n 1. distr (MDP.MC.T x) (stream_space (count_space UNIV))\n     (smap absc \\<circ> (##) x) =\n    distr (MDP.MC.T (t (absc x))) (stream_space (count_space UNIV))\n     ((##) (absc x) \\<circ> smap absc)", "by (auto simp: comp_def)"], ["proof (state)\nthis:\n  distr (MDP.MC.T x) (stream_space (count_space UNIV))\n   (smap absc \\<circ> (##) x) =\n  distr (MDP.MC.T (t (absc x))) (stream_space (count_space UNIV))\n   ((##) (absc x) \\<circ> smap absc)\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>x.\n       distr (MDP.MC.T x) (stream_space (count_space UNIV))\n        (smap absc \\<circ> (##) x)\n       \\<in> space (subprob_algebra ?N14)\n 2. \\<And>x.\n       distr (MDP.MC.T (t (absc x))) (stream_space (count_space UNIV))\n        ((##) (absc x) \\<circ> smap absc)\n       \\<in> space (subprob_algebra ?N14)\n 3. measure_pmf.random_variable (K_cfg cfg) (count_space UNIV) absc\n 4. (\\<lambda>y.\n        distr (MDP.MC.T (t y)) (stream_space (count_space UNIV))\n         ((##) y \\<circ> smap absc))\n    \\<in> count_space UNIV \\<rightarrow>\\<^sub>M subprob_algebra ?K12\n 5. space (measure_pmf (K_cfg cfg)) \\<noteq> {}\n 6. \\<And>x.\n       smap absc\n       \\<in> stream_space (count_space UNIV) \\<rightarrow>\\<^sub>M\n             stream_space (count_space UNIV)\n 7. \\<And>x.\n       MDP.MC.T.random_variable x (stream_space (count_space UNIV)) ((##) x)\n 8. measure_pmf.random_variable (K_cfg cfg) (subprob_algebra ?K3)\n     (\\<lambda>t.\n         distr (MDP.MC.T t) (stream_space (count_space UNIV)) ((##) t))\n 9. space (measure_pmf (K_cfg cfg)) \\<noteq> {}\n 10. smap absc\n     \\<in> ?K3 \\<rightarrow>\\<^sub>M stream_space (count_space UNIV)\nA total of 12 subgoals...", "by (fastforce\n          simp:  space_subprob_algebra MC_syntax.in_S\n          intro: bind_measure_pmf_cong MDP.MC.T.subprob_space_distr MDP.MC.T.prob_space_distr\n          )+"], ["proof (state)\nthis:\n  distr (MDP.MC.T cfg) (stream_space (count_space UNIV)) (smap absc) =\n  measure_pmf (K_cfg (absc cfg)) \\<bind>\n  (\\<lambda>y. distr (M' y) (stream_space (count_space UNIV)) ((##) y))\n\ngoal (3 subgoals):\n 1. \\<And>y x.\n       x \\<in> sets (M' y) \\<Longrightarrow>\n       x \\<in> sets (stream_space (count_space UNIV))\n 2. \\<And>y x.\n       x \\<in> sets (stream_space (count_space UNIV)) \\<Longrightarrow>\n       x \\<in> sets (M' y)\n 3. \\<And>y. prob_space (M' y)", "qed (auto simp: M'_def intro: MDP.MC.T.prob_space_distr)"], ["proof (state)\nthis:\n  \\<exists>M'.\n     (\\<forall>y\\<in>set_pmf (K_cfg (absc cfg)).\n         \\<exists>cfg.\n            y = absc cfg \\<and>\n            M' y =\n            distr (MDP.MC.T cfg) (stream_space (count_space UNIV))\n             (smap absc) \\<and>\n            cfg \\<in> MDP.valid_cfg) \\<and>\n     (\\<forall>y.\n         sets (M' y) = sets (stream_space (count_space UNIV)) \\<and>\n         prob_space (M' y)) \\<and>\n     distr (MDP.MC.T cfg) (stream_space (count_space UNIV)) (smap absc) =\n     measure_pmf (K_cfg (absc cfg)) \\<bind>\n     (\\<lambda>y. distr (M' y) (stream_space (count_space UNIV)) ((##) y))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma R_G_trace_space_distr_eq:\n  assumes \"cfg \\<in> R_G.valid_cfg\" \"abss s = state cfg\"\n  shows \"MDP.MC.T cfg = distr (MDP.MC.T (repcs s cfg)) MDP.MC.S (smap absc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MDP.MC.T cfg =\n    distr (MDP.MC.T (repcs s cfg)) (stream_space (count_space UNIV))\n     (smap absc)", "using assms"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n\ngoal (1 subgoal):\n 1. MDP.MC.T cfg =\n    distr (MDP.MC.T (repcs s cfg)) (stream_space (count_space UNIV))\n     (smap absc)", "proof (coinduction arbitrary: cfg s rule: MDP.MC.T_coinduct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n       \\<Longrightarrow> prob_space\n                          (distr (MDP.MC.T (repcs s cfg))\n                            (stream_space (count_space UNIV)) (smap absc))\n 2. \\<And>cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n       \\<Longrightarrow> sets\n                          (distr (MDP.MC.T (repcs s cfg))\n                            (stream_space (count_space UNIV)) (smap absc)) =\n                         sets (stream_space (count_space UNIV))\n 3. \\<And>cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M'.\n                            (\\<forall>y\\<in>set_pmf (K_cfg cfg).\n                                \\<exists>cfg s.\n                                   y = cfg \\<and>\n                                   M' y =\n                                   distr (MDP.MC.T (repcs s cfg))\n                                    (stream_space (count_space UNIV))\n                                    (smap absc) \\<and>\n                                   cfg \\<in> R_G.valid_cfg \\<and>\n                                   abss s = state cfg) \\<and>\n                            (\\<forall>y.\n                                sets (M' y) =\n                                sets\n                                 (stream_space (count_space UNIV)) \\<and>\n                                prob_space (M' y)) \\<and>\n                            distr (MDP.MC.T (repcs s cfg))\n                             (stream_space (count_space UNIV)) (smap absc) =\n                            measure_pmf (K_cfg cfg) \\<bind>\n                            (\\<lambda>y.\n                                distr (M' y)\n                                 (stream_space (count_space UNIV)) ((##) y))", "case prob"], ["proof (state)\nthis:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n\ngoal (3 subgoals):\n 1. \\<And>cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n       \\<Longrightarrow> prob_space\n                          (distr (MDP.MC.T (repcs s cfg))\n                            (stream_space (count_space UNIV)) (smap absc))\n 2. \\<And>cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n       \\<Longrightarrow> sets\n                          (distr (MDP.MC.T (repcs s cfg))\n                            (stream_space (count_space UNIV)) (smap absc)) =\n                         sets (stream_space (count_space UNIV))\n 3. \\<And>cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M'.\n                            (\\<forall>y\\<in>set_pmf (K_cfg cfg).\n                                \\<exists>cfg s.\n                                   y = cfg \\<and>\n                                   M' y =\n                                   distr (MDP.MC.T (repcs s cfg))\n                                    (stream_space (count_space UNIV))\n                                    (smap absc) \\<and>\n                                   cfg \\<in> R_G.valid_cfg \\<and>\n                                   abss s = state cfg) \\<and>\n                            (\\<forall>y.\n                                sets (M' y) =\n                                sets\n                                 (stream_space (count_space UNIV)) \\<and>\n                                prob_space (M' y)) \\<and>\n                            distr (MDP.MC.T (repcs s cfg))\n                             (stream_space (count_space UNIV)) (smap absc) =\n                            measure_pmf (K_cfg cfg) \\<bind>\n                            (\\<lambda>y.\n                                distr (M' y)\n                                 (stream_space (count_space UNIV)) ((##) y))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. prob_space\n     (distr (MDP.MC.T (repcs s cfg)) (stream_space (count_space UNIV))\n       (smap absc))", "by (rule MDP.MC.T.prob_space_distr, simp)"], ["proof (state)\nthis:\n  prob_space\n   (distr (MDP.MC.T (repcs s cfg)) (stream_space (count_space UNIV))\n     (smap absc))\n\ngoal (2 subgoals):\n 1. \\<And>cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n       \\<Longrightarrow> sets\n                          (distr (MDP.MC.T (repcs s cfg))\n                            (stream_space (count_space UNIV)) (smap absc)) =\n                         sets (stream_space (count_space UNIV))\n 2. \\<And>cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M'.\n                            (\\<forall>y\\<in>set_pmf (K_cfg cfg).\n                                \\<exists>cfg s.\n                                   y = cfg \\<and>\n                                   M' y =\n                                   distr (MDP.MC.T (repcs s cfg))\n                                    (stream_space (count_space UNIV))\n                                    (smap absc) \\<and>\n                                   cfg \\<in> R_G.valid_cfg \\<and>\n                                   abss s = state cfg) \\<and>\n                            (\\<forall>y.\n                                sets (M' y) =\n                                sets\n                                 (stream_space (count_space UNIV)) \\<and>\n                                prob_space (M' y)) \\<and>\n                            distr (MDP.MC.T (repcs s cfg))\n                             (stream_space (count_space UNIV)) (smap absc) =\n                            measure_pmf (K_cfg cfg) \\<bind>\n                            (\\<lambda>y.\n                                distr (M' y)\n                                 (stream_space (count_space UNIV)) ((##) y))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n       \\<Longrightarrow> sets\n                          (distr (MDP.MC.T (repcs s cfg))\n                            (stream_space (count_space UNIV)) (smap absc)) =\n                         sets (stream_space (count_space UNIV))\n 2. \\<And>cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M'.\n                            (\\<forall>y\\<in>set_pmf (K_cfg cfg).\n                                \\<exists>cfg s.\n                                   y = cfg \\<and>\n                                   M' y =\n                                   distr (MDP.MC.T (repcs s cfg))\n                                    (stream_space (count_space UNIV))\n                                    (smap absc) \\<and>\n                                   cfg \\<in> R_G.valid_cfg \\<and>\n                                   abss s = state cfg) \\<and>\n                            (\\<forall>y.\n                                sets (M' y) =\n                                sets\n                                 (stream_space (count_space UNIV)) \\<and>\n                                prob_space (M' y)) \\<and>\n                            distr (MDP.MC.T (repcs s cfg))\n                             (stream_space (count_space UNIV)) (smap absc) =\n                            measure_pmf (K_cfg cfg) \\<bind>\n                            (\\<lambda>y.\n                                distr (M' y)\n                                 (stream_space (count_space UNIV)) ((##) y))", "case sets"], ["proof (state)\nthis:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n\ngoal (2 subgoals):\n 1. \\<And>cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n       \\<Longrightarrow> sets\n                          (distr (MDP.MC.T (repcs s cfg))\n                            (stream_space (count_space UNIV)) (smap absc)) =\n                         sets (stream_space (count_space UNIV))\n 2. \\<And>cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M'.\n                            (\\<forall>y\\<in>set_pmf (K_cfg cfg).\n                                \\<exists>cfg s.\n                                   y = cfg \\<and>\n                                   M' y =\n                                   distr (MDP.MC.T (repcs s cfg))\n                                    (stream_space (count_space UNIV))\n                                    (smap absc) \\<and>\n                                   cfg \\<in> R_G.valid_cfg \\<and>\n                                   abss s = state cfg) \\<and>\n                            (\\<forall>y.\n                                sets (M' y) =\n                                sets\n                                 (stream_space (count_space UNIV)) \\<and>\n                                prob_space (M' y)) \\<and>\n                            distr (MDP.MC.T (repcs s cfg))\n                             (stream_space (count_space UNIV)) (smap absc) =\n                            measure_pmf (K_cfg cfg) \\<bind>\n                            (\\<lambda>y.\n                                distr (M' y)\n                                 (stream_space (count_space UNIV)) ((##) y))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sets\n     (distr (MDP.MC.T (repcs s cfg)) (stream_space (count_space UNIV))\n       (smap absc)) =\n    sets (stream_space (count_space UNIV))", "by auto"], ["proof (state)\nthis:\n  sets\n   (distr (MDP.MC.T (repcs s cfg)) (stream_space (count_space UNIV))\n     (smap absc)) =\n  sets (stream_space (count_space UNIV))\n\ngoal (1 subgoal):\n 1. \\<And>cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M'.\n                            (\\<forall>y\\<in>set_pmf (K_cfg cfg).\n                                \\<exists>cfg s.\n                                   y = cfg \\<and>\n                                   M' y =\n                                   distr (MDP.MC.T (repcs s cfg))\n                                    (stream_space (count_space UNIV))\n                                    (smap absc) \\<and>\n                                   cfg \\<in> R_G.valid_cfg \\<and>\n                                   abss s = state cfg) \\<and>\n                            (\\<forall>y.\n                                sets (M' y) =\n                                sets\n                                 (stream_space (count_space UNIV)) \\<and>\n                                prob_space (M' y)) \\<and>\n                            distr (MDP.MC.T (repcs s cfg))\n                             (stream_space (count_space UNIV)) (smap absc) =\n                            measure_pmf (K_cfg cfg) \\<bind>\n                            (\\<lambda>y.\n                                distr (M' y)\n                                 (stream_space (count_space UNIV)) ((##) y))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M'.\n                            (\\<forall>y\\<in>set_pmf (K_cfg cfg).\n                                \\<exists>cfg s.\n                                   y = cfg \\<and>\n                                   M' y =\n                                   distr (MDP.MC.T (repcs s cfg))\n                                    (stream_space (count_space UNIV))\n                                    (smap absc) \\<and>\n                                   cfg \\<in> R_G.valid_cfg \\<and>\n                                   abss s = state cfg) \\<and>\n                            (\\<forall>y.\n                                sets (M' y) =\n                                sets\n                                 (stream_space (count_space UNIV)) \\<and>\n                                prob_space (M' y)) \\<and>\n                            distr (MDP.MC.T (repcs s cfg))\n                             (stream_space (count_space UNIV)) (smap absc) =\n                            measure_pmf (K_cfg cfg) \\<bind>\n                            (\\<lambda>y.\n                                distr (M' y)\n                                 (stream_space (count_space UNIV)) ((##) y))", "case prems: (cont cfg s)"], ["proof (state)\nthis:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n\ngoal (1 subgoal):\n 1. \\<And>cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M'.\n                            (\\<forall>y\\<in>set_pmf (K_cfg cfg).\n                                \\<exists>cfg s.\n                                   y = cfg \\<and>\n                                   M' y =\n                                   distr (MDP.MC.T (repcs s cfg))\n                                    (stream_space (count_space UNIV))\n                                    (smap absc) \\<and>\n                                   cfg \\<in> R_G.valid_cfg \\<and>\n                                   abss s = state cfg) \\<and>\n                            (\\<forall>y.\n                                sets (M' y) =\n                                sets\n                                 (stream_space (count_space UNIV)) \\<and>\n                                prob_space (M' y)) \\<and>\n                            distr (MDP.MC.T (repcs s cfg))\n                             (stream_space (count_space UNIV)) (smap absc) =\n                            measure_pmf (K_cfg cfg) \\<bind>\n                            (\\<lambda>y.\n                                distr (M' y)\n                                 (stream_space (count_space UNIV)) ((##) y))", "let ?\\<mu> = \"rept s (action cfg)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M'.\n                            (\\<forall>y\\<in>set_pmf (K_cfg cfg).\n                                \\<exists>cfg s.\n                                   y = cfg \\<and>\n                                   M' y =\n                                   distr (MDP.MC.T (repcs s cfg))\n                                    (stream_space (count_space UNIV))\n                                    (smap absc) \\<and>\n                                   cfg \\<in> R_G.valid_cfg \\<and>\n                                   abss s = state cfg) \\<and>\n                            (\\<forall>y.\n                                sets (M' y) =\n                                sets\n                                 (stream_space (count_space UNIV)) \\<and>\n                                prob_space (M' y)) \\<and>\n                            distr (MDP.MC.T (repcs s cfg))\n                             (stream_space (count_space UNIV)) (smap absc) =\n                            measure_pmf (K_cfg cfg) \\<bind>\n                            (\\<lambda>y.\n                                distr (M' y)\n                                 (stream_space (count_space UNIV)) ((##) y))", "define repc' where \"repc' \\<equiv> \\<lambda> cfg'. repcs (THE s. s \\<in> ?\\<mu> \\<and> abss s = state cfg') cfg'\""], ["proof (state)\nthis:\n  repc' \\<equiv>\n  \\<lambda>cfg'.\n     repcs\n      (THE s.\n          s \\<in> set_pmf (rept s (action cfg)) \\<and> abss s = state cfg')\n      cfg'\n\ngoal (1 subgoal):\n 1. \\<And>cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M'.\n                            (\\<forall>y\\<in>set_pmf (K_cfg cfg).\n                                \\<exists>cfg s.\n                                   y = cfg \\<and>\n                                   M' y =\n                                   distr (MDP.MC.T (repcs s cfg))\n                                    (stream_space (count_space UNIV))\n                                    (smap absc) \\<and>\n                                   cfg \\<in> R_G.valid_cfg \\<and>\n                                   abss s = state cfg) \\<and>\n                            (\\<forall>y.\n                                sets (M' y) =\n                                sets\n                                 (stream_space (count_space UNIV)) \\<and>\n                                prob_space (M' y)) \\<and>\n                            distr (MDP.MC.T (repcs s cfg))\n                             (stream_space (count_space UNIV)) (smap absc) =\n                            measure_pmf (K_cfg cfg) \\<bind>\n                            (\\<lambda>y.\n                                distr (M' y)\n                                 (stream_space (count_space UNIV)) ((##) y))", "define M' where \"M' \\<equiv> \\<lambda> cfg. distr (MDP.MC.T (repc' cfg)) MDP.MC.S (smap absc)\""], ["proof (state)\nthis:\n  M' \\<equiv>\n  \\<lambda>cfg.\n     distr (MDP.MC.T (repc' cfg)) (stream_space (count_space UNIV))\n      (smap absc)\n\ngoal (1 subgoal):\n 1. \\<And>cfg s.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M'.\n                            (\\<forall>y\\<in>set_pmf (K_cfg cfg).\n                                \\<exists>cfg s.\n                                   y = cfg \\<and>\n                                   M' y =\n                                   distr (MDP.MC.T (repcs s cfg))\n                                    (stream_space (count_space UNIV))\n                                    (smap absc) \\<and>\n                                   cfg \\<in> R_G.valid_cfg \\<and>\n                                   abss s = state cfg) \\<and>\n                            (\\<forall>y.\n                                sets (M' y) =\n                                sets\n                                 (stream_space (count_space UNIV)) \\<and>\n                                prob_space (M' y)) \\<and>\n                            distr (MDP.MC.T (repcs s cfg))\n                             (stream_space (count_space UNIV)) (smap absc) =\n                            measure_pmf (K_cfg cfg) \\<bind>\n                            (\\<lambda>y.\n                                distr (M' y)\n                                 (stream_space (count_space UNIV)) ((##) y))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>M'.\n       (\\<forall>y\\<in>set_pmf (K_cfg cfg).\n           \\<exists>cfg s.\n              y = cfg \\<and>\n              M' y =\n              distr (MDP.MC.T (repcs s cfg))\n               (stream_space (count_space UNIV)) (smap absc) \\<and>\n              cfg \\<in> R_G.valid_cfg \\<and> abss s = state cfg) \\<and>\n       (\\<forall>y.\n           sets (M' y) = sets (stream_space (count_space UNIV)) \\<and>\n           prob_space (M' y)) \\<and>\n       distr (MDP.MC.T (repcs s cfg)) (stream_space (count_space UNIV))\n        (smap absc) =\n       measure_pmf (K_cfg cfg) \\<bind>\n       (\\<lambda>y. distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "proof (intro exI[where x = M'], safe, goal_cases)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>y.\n       y \\<in> set_pmf (K_cfg cfg) \\<Longrightarrow>\n       \\<exists>cfg s.\n          y = cfg \\<and>\n          M' y =\n          distr (MDP.MC.T (repcs s cfg)) (stream_space (count_space UNIV))\n           (smap absc) \\<and>\n          cfg \\<in> R_G.valid_cfg \\<and> abss s = state cfg\n 2. \\<And>y x.\n       x \\<in> sets (M' y) \\<Longrightarrow>\n       x \\<in> sets (stream_space (count_space UNIV))\n 3. \\<And>y x.\n       x \\<in> sets (stream_space (count_space UNIV)) \\<Longrightarrow>\n       x \\<in> sets (M' y)\n 4. \\<And>y. prob_space (M' y)\n 5. distr (MDP.MC.T (repcs s cfg)) (stream_space (count_space UNIV))\n     (smap absc) =\n    measure_pmf (K_cfg cfg) \\<bind>\n    (\\<lambda>y. distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "case A: (1 cfg')"], ["proof (state)\nthis:\n  cfg' \\<in> set_pmf (K_cfg cfg)\n\ngoal (5 subgoals):\n 1. \\<And>y.\n       y \\<in> set_pmf (K_cfg cfg) \\<Longrightarrow>\n       \\<exists>cfg s.\n          y = cfg \\<and>\n          M' y =\n          distr (MDP.MC.T (repcs s cfg)) (stream_space (count_space UNIV))\n           (smap absc) \\<and>\n          cfg \\<in> R_G.valid_cfg \\<and> abss s = state cfg\n 2. \\<And>y x.\n       x \\<in> sets (M' y) \\<Longrightarrow>\n       x \\<in> sets (stream_space (count_space UNIV))\n 3. \\<And>y x.\n       x \\<in> sets (stream_space (count_space UNIV)) \\<Longrightarrow>\n       x \\<in> sets (M' y)\n 4. \\<And>y. prob_space (M' y)\n 5. distr (MDP.MC.T (repcs s cfg)) (stream_space (count_space UNIV))\n     (smap absc) =\n    measure_pmf (K_cfg cfg) \\<bind>\n    (\\<lambda>y. distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "with K_cfg_rept_action[OF prems]"], ["proof (chain)\npicking this:\n  ?cfg' \\<in> set_pmf (K_cfg cfg) \\<Longrightarrow>\n  abss\n   (THE s'.\n       s' \\<in> set_pmf (rept s (action cfg)) \\<and>\n       abss s' = state ?cfg') =\n  state ?cfg'\n  cfg' \\<in> set_pmf (K_cfg cfg)", "have\n      \"abss (THE s. s \\<in> ?\\<mu> \\<and> abss s = state cfg') = state cfg'\""], ["proof (prove)\nusing this:\n  ?cfg' \\<in> set_pmf (K_cfg cfg) \\<Longrightarrow>\n  abss\n   (THE s'.\n       s' \\<in> set_pmf (rept s (action cfg)) \\<and>\n       abss s' = state ?cfg') =\n  state ?cfg'\n  cfg' \\<in> set_pmf (K_cfg cfg)\n\ngoal (1 subgoal):\n 1. abss\n     (THE s.\n         s \\<in> set_pmf (rept s (action cfg)) \\<and> abss s = state cfg') =\n    state cfg'", "by auto"], ["proof (state)\nthis:\n  abss\n   (THE s.\n       s \\<in> set_pmf (rept s (action cfg)) \\<and> abss s = state cfg') =\n  state cfg'\n\ngoal (5 subgoals):\n 1. \\<And>y.\n       y \\<in> set_pmf (K_cfg cfg) \\<Longrightarrow>\n       \\<exists>cfg s.\n          y = cfg \\<and>\n          M' y =\n          distr (MDP.MC.T (repcs s cfg)) (stream_space (count_space UNIV))\n           (smap absc) \\<and>\n          cfg \\<in> R_G.valid_cfg \\<and> abss s = state cfg\n 2. \\<And>y x.\n       x \\<in> sets (M' y) \\<Longrightarrow>\n       x \\<in> sets (stream_space (count_space UNIV))\n 3. \\<And>y x.\n       x \\<in> sets (stream_space (count_space UNIV)) \\<Longrightarrow>\n       x \\<in> sets (M' y)\n 4. \\<And>y. prob_space (M' y)\n 5. distr (MDP.MC.T (repcs s cfg)) (stream_space (count_space UNIV))\n     (smap absc) =\n    measure_pmf (K_cfg cfg) \\<bind>\n    (\\<lambda>y. distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "moreover"], ["proof (state)\nthis:\n  abss\n   (THE s.\n       s \\<in> set_pmf (rept s (action cfg)) \\<and> abss s = state cfg') =\n  state cfg'\n\ngoal (5 subgoals):\n 1. \\<And>y.\n       y \\<in> set_pmf (K_cfg cfg) \\<Longrightarrow>\n       \\<exists>cfg s.\n          y = cfg \\<and>\n          M' y =\n          distr (MDP.MC.T (repcs s cfg)) (stream_space (count_space UNIV))\n           (smap absc) \\<and>\n          cfg \\<in> R_G.valid_cfg \\<and> abss s = state cfg\n 2. \\<And>y x.\n       x \\<in> sets (M' y) \\<Longrightarrow>\n       x \\<in> sets (stream_space (count_space UNIV))\n 3. \\<And>y x.\n       x \\<in> sets (stream_space (count_space UNIV)) \\<Longrightarrow>\n       x \\<in> sets (M' y)\n 4. \\<And>y. prob_space (M' y)\n 5. distr (MDP.MC.T (repcs s cfg)) (stream_space (count_space UNIV))\n     (smap absc) =\n    measure_pmf (K_cfg cfg) \\<bind>\n    (\\<lambda>y. distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "from A prems"], ["proof (chain)\npicking this:\n  cfg' \\<in> set_pmf (K_cfg cfg)\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg", "have \"cfg' \\<in> R_G.valid_cfg\""], ["proof (prove)\nusing this:\n  cfg' \\<in> set_pmf (K_cfg cfg)\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n\ngoal (1 subgoal):\n 1. cfg' \\<in> R_G.valid_cfg", "by auto"], ["proof (state)\nthis:\n  cfg' \\<in> R_G.valid_cfg\n\ngoal (5 subgoals):\n 1. \\<And>y.\n       y \\<in> set_pmf (K_cfg cfg) \\<Longrightarrow>\n       \\<exists>cfg s.\n          y = cfg \\<and>\n          M' y =\n          distr (MDP.MC.T (repcs s cfg)) (stream_space (count_space UNIV))\n           (smap absc) \\<and>\n          cfg \\<in> R_G.valid_cfg \\<and> abss s = state cfg\n 2. \\<And>y x.\n       x \\<in> sets (M' y) \\<Longrightarrow>\n       x \\<in> sets (stream_space (count_space UNIV))\n 3. \\<And>y x.\n       x \\<in> sets (stream_space (count_space UNIV)) \\<Longrightarrow>\n       x \\<in> sets (M' y)\n 4. \\<And>y. prob_space (M' y)\n 5. distr (MDP.MC.T (repcs s cfg)) (stream_space (count_space UNIV))\n     (smap absc) =\n    measure_pmf (K_cfg cfg) \\<bind>\n    (\\<lambda>y. distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "ultimately"], ["proof (chain)\npicking this:\n  abss\n   (THE s.\n       s \\<in> set_pmf (rept s (action cfg)) \\<and> abss s = state cfg') =\n  state cfg'\n  cfg' \\<in> R_G.valid_cfg", "show ?case"], ["proof (prove)\nusing this:\n  abss\n   (THE s.\n       s \\<in> set_pmf (rept s (action cfg)) \\<and> abss s = state cfg') =\n  state cfg'\n  cfg' \\<in> R_G.valid_cfg\n\ngoal (1 subgoal):\n 1. \\<exists>cfg s.\n       cfg' = cfg \\<and>\n       M' cfg' =\n       distr (MDP.MC.T (repcs s cfg)) (stream_space (count_space UNIV))\n        (smap absc) \\<and>\n       cfg \\<in> R_G.valid_cfg \\<and> abss s = state cfg", "unfolding M'_def repc'_def"], ["proof (prove)\nusing this:\n  abss\n   (THE s.\n       s \\<in> set_pmf (rept s (action cfg)) \\<and> abss s = state cfg') =\n  state cfg'\n  cfg' \\<in> R_G.valid_cfg\n\ngoal (1 subgoal):\n 1. \\<exists>cfg s.\n       cfg' = cfg \\<and>\n       distr\n        (MDP.MC.T\n          (repcs\n            (THE s.\n                s \\<in> set_pmf (rept s (action cfg)) \\<and>\n                abss s = state cfg')\n            cfg'))\n        (stream_space (count_space UNIV)) (smap absc) =\n       distr (MDP.MC.T (repcs s cfg)) (stream_space (count_space UNIV))\n        (smap absc) \\<and>\n       cfg \\<in> R_G.valid_cfg \\<and> abss s = state cfg", "by best"], ["proof (state)\nthis:\n  \\<exists>cfg s.\n     cfg' = cfg \\<and>\n     M' cfg' =\n     distr (MDP.MC.T (repcs s cfg)) (stream_space (count_space UNIV))\n      (smap absc) \\<and>\n     cfg \\<in> R_G.valid_cfg \\<and> abss s = state cfg\n\ngoal (4 subgoals):\n 1. \\<And>y x.\n       x \\<in> sets (M' y) \\<Longrightarrow>\n       x \\<in> sets (stream_space (count_space UNIV))\n 2. \\<And>y x.\n       x \\<in> sets (stream_space (count_space UNIV)) \\<Longrightarrow>\n       x \\<in> sets (M' y)\n 3. \\<And>y. prob_space (M' y)\n 4. distr (MDP.MC.T (repcs s cfg)) (stream_space (count_space UNIV))\n     (smap absc) =\n    measure_pmf (K_cfg cfg) \\<bind>\n    (\\<lambda>y. distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>y x.\n       x \\<in> sets (M' y) \\<Longrightarrow>\n       x \\<in> sets (stream_space (count_space UNIV))\n 2. \\<And>y x.\n       x \\<in> sets (stream_space (count_space UNIV)) \\<Longrightarrow>\n       x \\<in> sets (M' y)\n 3. \\<And>y. prob_space (M' y)\n 4. distr (MDP.MC.T (repcs s cfg)) (stream_space (count_space UNIV))\n     (smap absc) =\n    measure_pmf (K_cfg cfg) \\<bind>\n    (\\<lambda>y. distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "case 4"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>y x.\n       x \\<in> sets (M' y) \\<Longrightarrow>\n       x \\<in> sets (stream_space (count_space UNIV))\n 2. \\<And>y x.\n       x \\<in> sets (stream_space (count_space UNIV)) \\<Longrightarrow>\n       x \\<in> sets (M' y)\n 3. \\<And>y. prob_space (M' y)\n 4. distr (MDP.MC.T (repcs s cfg)) (stream_space (count_space UNIV))\n     (smap absc) =\n    measure_pmf (K_cfg cfg) \\<bind>\n    (\\<lambda>y. distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. prob_space (M' y_)", "unfolding M'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prob_space\n     (distr (MDP.MC.T (repc' y_)) (stream_space (count_space UNIV))\n       (smap absc))", "by (rule MDP.MC.T.prob_space_distr, simp)"], ["proof (state)\nthis:\n  prob_space (M' y_)\n\ngoal (3 subgoals):\n 1. \\<And>y x.\n       x \\<in> sets (M' y) \\<Longrightarrow>\n       x \\<in> sets (stream_space (count_space UNIV))\n 2. \\<And>y x.\n       x \\<in> sets (stream_space (count_space UNIV)) \\<Longrightarrow>\n       x \\<in> sets (M' y)\n 3. distr (MDP.MC.T (repcs s cfg)) (stream_space (count_space UNIV))\n     (smap absc) =\n    measure_pmf (K_cfg cfg) \\<bind>\n    (\\<lambda>y. distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>y x.\n       x \\<in> sets (M' y) \\<Longrightarrow>\n       x \\<in> sets (stream_space (count_space UNIV))\n 2. \\<And>y x.\n       x \\<in> sets (stream_space (count_space UNIV)) \\<Longrightarrow>\n       x \\<in> sets (M' y)\n 3. distr (MDP.MC.T (repcs s cfg)) (stream_space (count_space UNIV))\n     (smap absc) =\n    measure_pmf (K_cfg cfg) \\<bind>\n    (\\<lambda>y. distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "case 5"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>y x.\n       x \\<in> sets (M' y) \\<Longrightarrow>\n       x \\<in> sets (stream_space (count_space UNIV))\n 2. \\<And>y x.\n       x \\<in> sets (stream_space (count_space UNIV)) \\<Longrightarrow>\n       x \\<in> sets (M' y)\n 3. distr (MDP.MC.T (repcs s cfg)) (stream_space (count_space UNIV))\n     (smap absc) =\n    measure_pmf (K_cfg cfg) \\<bind>\n    (\\<lambda>y. distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "have *: \"smap absc \\<circ> (##) (repc' cfg') = (##) cfg' \\<circ> smap absc\"\n    if \"cfg' \\<in> set_pmf (K_cfg cfg)\" for cfg'"], ["proof (prove)\ngoal (1 subgoal):\n 1. smap absc \\<circ> (##) (repc' cfg') = (##) cfg' \\<circ> smap absc", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. smap absc \\<circ> (##) (repc' cfg') = (##) cfg' \\<circ> smap absc", "from K_cfg_rept_action[OF prems that]"], ["proof (chain)\npicking this:\n  abss\n   (THE s'.\n       s' \\<in> set_pmf (rept s (action cfg)) \\<and> abss s' = state cfg') =\n  state cfg'", "have\n        \"abss (THE s. s \\<in> ?\\<mu> \\<and> abss s = state cfg') = state cfg'\""], ["proof (prove)\nusing this:\n  abss\n   (THE s'.\n       s' \\<in> set_pmf (rept s (action cfg)) \\<and> abss s' = state cfg') =\n  state cfg'\n\ngoal (1 subgoal):\n 1. abss\n     (THE s.\n         s \\<in> set_pmf (rept s (action cfg)) \\<and> abss s = state cfg') =\n    state cfg'", "."], ["proof (state)\nthis:\n  abss\n   (THE s.\n       s \\<in> set_pmf (rept s (action cfg)) \\<and> abss s = state cfg') =\n  state cfg'\n\ngoal (1 subgoal):\n 1. smap absc \\<circ> (##) (repc' cfg') = (##) cfg' \\<circ> smap absc", "with prems that"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  cfg' \\<in> set_pmf (K_cfg cfg)\n  abss\n   (THE s.\n       s \\<in> set_pmf (rept s (action cfg)) \\<and> abss s = state cfg') =\n  state cfg'", "have *:\n        \"absc (repc' cfg') = cfg'\""], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  cfg' \\<in> set_pmf (K_cfg cfg)\n  abss\n   (THE s.\n       s \\<in> set_pmf (rept s (action cfg)) \\<and> abss s = state cfg') =\n  state cfg'\n\ngoal (1 subgoal):\n 1. absc (repc' cfg') = cfg'", "unfolding repc'_def"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n  cfg' \\<in> set_pmf (K_cfg cfg)\n  abss\n   (THE s.\n       s \\<in> set_pmf (rept s (action cfg)) \\<and> abss s = state cfg') =\n  state cfg'\n\ngoal (1 subgoal):\n 1. absc\n     (repcs\n       (THE s.\n           s \\<in> set_pmf (rept s (action cfg)) \\<and> abss s = state cfg')\n       cfg') =\n    cfg'", "by (subst absc_repcs_id, auto)"], ["proof (state)\nthis:\n  absc (repc' cfg') = cfg'\n\ngoal (1 subgoal):\n 1. smap absc \\<circ> (##) (repc' cfg') = (##) cfg' \\<circ> smap absc", "then"], ["proof (chain)\npicking this:\n  absc (repc' cfg') = cfg'", "show \"(smap absc \\<circ> (##) (repc' cfg')) = ((##) cfg' \\<circ> smap absc)\""], ["proof (prove)\nusing this:\n  absc (repc' cfg') = cfg'\n\ngoal (1 subgoal):\n 1. smap absc \\<circ> (##) (repc' cfg') = (##) cfg' \\<circ> smap absc", "by auto"], ["proof (state)\nthis:\n  smap absc \\<circ> (##) (repc' cfg') = (##) cfg' \\<circ> smap absc\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?cfg'5 \\<in> set_pmf (K_cfg cfg) \\<Longrightarrow>\n  smap absc \\<circ> (##) (repc' ?cfg'5) = (##) ?cfg'5 \\<circ> smap absc\n\ngoal (3 subgoals):\n 1. \\<And>y x.\n       x \\<in> sets (M' y) \\<Longrightarrow>\n       x \\<in> sets (stream_space (count_space UNIV))\n 2. \\<And>y x.\n       x \\<in> sets (stream_space (count_space UNIV)) \\<Longrightarrow>\n       x \\<in> sets (M' y)\n 3. distr (MDP.MC.T (repcs s cfg)) (stream_space (count_space UNIV))\n     (smap absc) =\n    measure_pmf (K_cfg cfg) \\<bind>\n    (\\<lambda>y. distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "from prems"], ["proof (chain)\npicking this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg", "show ?case"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n\ngoal (1 subgoal):\n 1. distr (MDP.MC.T (repcs s cfg)) (stream_space (count_space UNIV))\n     (smap absc) =\n    measure_pmf (K_cfg cfg) \\<bind>\n    (\\<lambda>y. distr (M' y) (stream_space (count_space UNIV)) ((##) y))", "unfolding M'_def"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  abss s = state cfg\n\ngoal (1 subgoal):\n 1. distr (MDP.MC.T (repcs s cfg)) (stream_space (count_space UNIV))\n     (smap absc) =\n    measure_pmf (K_cfg cfg) \\<bind>\n    (\\<lambda>y.\n        distr\n         (distr (MDP.MC.T (repc' y)) (stream_space (count_space UNIV))\n           (smap absc))\n         (stream_space (count_space UNIV)) ((##) y))", "apply (subst distr_distr)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n       \\<Longrightarrow> (##) y\n                         \\<in> stream_space\n                                (count_space UNIV) \\<rightarrow>\\<^sub>M\n                               stream_space (count_space UNIV)\n 2. \\<And>y.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n       \\<Longrightarrow> MDP.MC.T.random_variable (repc' y)\n                          (stream_space (count_space UNIV)) (smap absc)\n 3. \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n    \\<Longrightarrow> distr (MDP.MC.T (repcs s cfg))\n                       (stream_space (count_space UNIV)) (smap absc) =\n                      measure_pmf (K_cfg cfg) \\<bind>\n                      (\\<lambda>y.\n                          distr (MDP.MC.T (repc' y))\n                           (stream_space (count_space UNIV))\n                           ((##) y \\<circ> smap absc))", "apply simp+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n    \\<Longrightarrow> distr (MDP.MC.T (repcs s cfg))\n                       (stream_space (count_space UNIV)) (smap absc) =\n                      measure_pmf (K_cfg cfg) \\<bind>\n                      (\\<lambda>y.\n                          distr (MDP.MC.T (repc' y))\n                           (stream_space (count_space UNIV))\n                           ((##) y \\<circ> smap absc))", "apply (subst MDP.MC.T_eq_bind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n    \\<Longrightarrow> distr\n                       (measure_pmf (K_cfg (repcs s cfg)) \\<bind>\n                        (\\<lambda>t.\n                            distr (MDP.MC.T t)\n                             (stream_space (count_space UNIV)) ((##) t)))\n                       (stream_space (count_space UNIV)) (smap absc) =\n                      measure_pmf (K_cfg cfg) \\<bind>\n                      (\\<lambda>y.\n                          distr (MDP.MC.T (repc' y))\n                           (stream_space (count_space UNIV))\n                           ((##) y \\<circ> smap absc))", "apply (subst distr_bind)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n    \\<Longrightarrow> measure_pmf.random_variable (K_cfg (repcs s cfg))\n                       (subprob_algebra ?K2)\n                       (\\<lambda>t.\n                           distr (MDP.MC.T t)\n                            (stream_space (count_space UNIV)) ((##) t))\n 2. \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n    \\<Longrightarrow> space (measure_pmf (K_cfg (repcs s cfg))) \\<noteq> {}\n 3. \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n    \\<Longrightarrow> smap absc\n                      \\<in> ?K2 \\<rightarrow>\\<^sub>M\n                            stream_space (count_space UNIV)\n 4. \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n    \\<Longrightarrow> measure_pmf (K_cfg (repcs s cfg)) \\<bind>\n                      (\\<lambda>x.\n                          distr\n                           (distr (MDP.MC.T x)\n                             (stream_space (count_space UNIV)) ((##) x))\n                           (stream_space (count_space UNIV)) (smap absc)) =\n                      measure_pmf (K_cfg cfg) \\<bind>\n                      (\\<lambda>y.\n                          distr (MDP.MC.T (repc' y))\n                           (stream_space (count_space UNIV))\n                           ((##) y \\<circ> smap absc))", "prefer 2"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n    \\<Longrightarrow> space (measure_pmf (K_cfg (repcs s cfg))) \\<noteq> {}\n 2. \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n    \\<Longrightarrow> measure_pmf.random_variable (K_cfg (repcs s cfg))\n                       (subprob_algebra ?K2)\n                       (\\<lambda>t.\n                           distr (MDP.MC.T t)\n                            (stream_space (count_space UNIV)) ((##) t))\n 3. \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n    \\<Longrightarrow> smap absc\n                      \\<in> ?K2 \\<rightarrow>\\<^sub>M\n                            stream_space (count_space UNIV)\n 4. \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n    \\<Longrightarrow> measure_pmf (K_cfg (repcs s cfg)) \\<bind>\n                      (\\<lambda>x.\n                          distr\n                           (distr (MDP.MC.T x)\n                             (stream_space (count_space UNIV)) ((##) x))\n                           (stream_space (count_space UNIV)) (smap absc)) =\n                      measure_pmf (K_cfg cfg) \\<bind>\n                      (\\<lambda>y.\n                          distr (MDP.MC.T (repc' y))\n                           (stream_space (count_space UNIV))\n                           ((##) y \\<circ> smap absc))", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n    \\<Longrightarrow> measure_pmf.random_variable (K_cfg (repcs s cfg))\n                       (subprob_algebra ?K2)\n                       (\\<lambda>t.\n                           distr (MDP.MC.T t)\n                            (stream_space (count_space UNIV)) ((##) t))\n 2. \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n    \\<Longrightarrow> smap absc\n                      \\<in> ?K2 \\<rightarrow>\\<^sub>M\n                            stream_space (count_space UNIV)\n 3. \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n    \\<Longrightarrow> measure_pmf (K_cfg (repcs s cfg)) \\<bind>\n                      (\\<lambda>x.\n                          distr\n                           (distr (MDP.MC.T x)\n                             (stream_space (count_space UNIV)) ((##) x))\n                           (stream_space (count_space UNIV)) (smap absc)) =\n                      measure_pmf (K_cfg cfg) \\<bind>\n                      (\\<lambda>y.\n                          distr (MDP.MC.T (repc' y))\n                           (stream_space (count_space UNIV))\n                           ((##) y \\<circ> smap absc))", "apply (rule MDP.MC.distr_Stream_subprob)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n    \\<Longrightarrow> smap absc\n                      \\<in> stream_space\n                             (count_space UNIV) \\<rightarrow>\\<^sub>M\n                            stream_space (count_space UNIV)\n 2. \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n    \\<Longrightarrow> measure_pmf (K_cfg (repcs s cfg)) \\<bind>\n                      (\\<lambda>x.\n                          distr\n                           (distr (MDP.MC.T x)\n                             (stream_space (count_space UNIV)) ((##) x))\n                           (stream_space (count_space UNIV)) (smap absc)) =\n                      measure_pmf (K_cfg cfg) \\<bind>\n                      (\\<lambda>y.\n                          distr (MDP.MC.T (repc' y))\n                           (stream_space (count_space UNIV))\n                           ((##) y \\<circ> smap absc))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n    \\<Longrightarrow> measure_pmf (K_cfg (repcs s cfg)) \\<bind>\n                      (\\<lambda>x.\n                          distr\n                           (distr (MDP.MC.T x)\n                             (stream_space (count_space UNIV)) ((##) x))\n                           (stream_space (count_space UNIV)) (smap absc)) =\n                      measure_pmf (K_cfg cfg) \\<bind>\n                      (\\<lambda>y.\n                          distr (MDP.MC.T (repc' y))\n                           (stream_space (count_space UNIV))\n                           ((##) y \\<circ> smap absc))", "apply (subst distr_distr)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n       \\<Longrightarrow> smap absc\n                         \\<in> stream_space\n                                (count_space UNIV) \\<rightarrow>\\<^sub>M\n                               stream_space (count_space UNIV)\n 2. \\<And>x.\n       \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n       \\<Longrightarrow> MDP.MC.T.random_variable x\n                          (stream_space (count_space UNIV)) ((##) x)\n 3. \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n    \\<Longrightarrow> measure_pmf (K_cfg (repcs s cfg)) \\<bind>\n                      (\\<lambda>x.\n                          distr (MDP.MC.T x)\n                           (stream_space (count_space UNIV))\n                           (smap absc \\<circ> (##) x)) =\n                      measure_pmf (K_cfg cfg) \\<bind>\n                      (\\<lambda>y.\n                          distr (MDP.MC.T (repc' y))\n                           (stream_space (count_space UNIV))\n                           ((##) y \\<circ> smap absc))", "apply simp+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n    \\<Longrightarrow> measure_pmf (K_cfg (repcs s cfg)) \\<bind>\n                      (\\<lambda>x.\n                          distr (MDP.MC.T x)\n                           (stream_space (count_space UNIV))\n                           (smap absc \\<circ> (##) x)) =\n                      measure_pmf (K_cfg cfg) \\<bind>\n                      (\\<lambda>y.\n                          distr (MDP.MC.T (repc' y))\n                           (stream_space (count_space UNIV))\n                           ((##) y \\<circ> smap absc))", "apply (subst K_cfg_map_repcs[OF prems])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n    \\<Longrightarrow> measure_pmf\n                       (map_pmf\n                         (\\<lambda>cfg'.\n                             repcs\n                              (THE s'.\n                                  s' \\<in> set_pmf\n      (rept s (action cfg)) \\<and>\n                                  abss s' = state cfg')\n                              cfg')\n                         (K_cfg cfg)) \\<bind>\n                      (\\<lambda>x.\n                          distr (MDP.MC.T x)\n                           (stream_space (count_space UNIV))\n                           (smap absc \\<circ> (##) x)) =\n                      measure_pmf (K_cfg cfg) \\<bind>\n                      (\\<lambda>y.\n                          distr (MDP.MC.T (repc' y))\n                           (stream_space (count_space UNIV))\n                           ((##) y \\<circ> smap absc))", "apply (subst map_pmf_rep_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n    \\<Longrightarrow> distr (measure_pmf (K_cfg cfg)) (count_space UNIV)\n                       (\\<lambda>cfg'.\n                           repcs\n                            (THE s'.\n                                s' \\<in> set_pmf\n    (rept s (action cfg)) \\<and>\n                                abss s' = state cfg')\n                            cfg') \\<bind>\n                      (\\<lambda>x.\n                          distr (MDP.MC.T x)\n                           (stream_space (count_space UNIV))\n                           (smap absc \\<circ> (##) x)) =\n                      measure_pmf (K_cfg cfg) \\<bind>\n                      (\\<lambda>y.\n                          distr (MDP.MC.T (repc' y))\n                           (stream_space (count_space UNIV))\n                           ((##) y \\<circ> smap absc))", "apply (subst bind_distr)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n    \\<Longrightarrow> measure_pmf.random_variable (K_cfg cfg)\n                       (count_space UNIV)\n                       (\\<lambda>cfg'.\n                           repcs\n                            (THE s'.\n                                s' \\<in> set_pmf\n    (rept s (action cfg)) \\<and>\n                                abss s' = state cfg')\n                            cfg')\n 2. \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x.\n                          distr (MDP.MC.T x)\n                           (stream_space (count_space UNIV))\n                           (smap absc \\<circ> (##) x))\n                      \\<in> count_space UNIV \\<rightarrow>\\<^sub>M\n                            subprob_algebra ?K4\n 3. \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n    \\<Longrightarrow> space (measure_pmf (K_cfg cfg)) \\<noteq> {}\n 4. \\<lbrakk>cfg \\<in> R_G.valid_cfg; abss s = state cfg\\<rbrakk>\n    \\<Longrightarrow> measure_pmf (K_cfg cfg) \\<bind>\n                      (\\<lambda>x.\n                          distr\n                           (MDP.MC.T\n                             (repcs\n                               (THE s'.\n                                   s' \\<in> set_pmf\n       (rept s (action cfg)) \\<and>\n                                   abss s' = state x)\n                               x))\n                           (stream_space (count_space UNIV))\n                           (smap absc \\<circ>\n                            (##)\n                             (repcs\n                               (THE s'.\n                                   s' \\<in> set_pmf\n       (rept s (action cfg)) \\<and>\n                                   abss s' = state x)\n                               x))) =\n                      measure_pmf (K_cfg cfg) \\<bind>\n                      (\\<lambda>y.\n                          distr (MDP.MC.T (repc' y))\n                           (stream_space (count_space UNIV))\n                           ((##) y \\<circ> smap absc))", "by (fastforce simp: *[unfolded repc'_def] repc'_def space_subprob_algebra MC_syntax.in_S\n                  intro: bind_measure_pmf_cong MDP.MC.T.subprob_space_distr)+"], ["proof (state)\nthis:\n  distr (MDP.MC.T (repcs s cfg)) (stream_space (count_space UNIV))\n   (smap absc) =\n  measure_pmf (K_cfg cfg) \\<bind>\n  (\\<lambda>y. distr (M' y) (stream_space (count_space UNIV)) ((##) y))\n\ngoal (2 subgoals):\n 1. \\<And>y x.\n       x \\<in> sets (M' y) \\<Longrightarrow>\n       x \\<in> sets (stream_space (count_space UNIV))\n 2. \\<And>y x.\n       x \\<in> sets (stream_space (count_space UNIV)) \\<Longrightarrow>\n       x \\<in> sets (M' y)", "qed (simp add: M'_def)+"], ["proof (state)\nthis:\n  \\<exists>M'.\n     (\\<forall>y\\<in>set_pmf (K_cfg cfg).\n         \\<exists>cfg s.\n            y = cfg \\<and>\n            M' y =\n            distr (MDP.MC.T (repcs s cfg)) (stream_space (count_space UNIV))\n             (smap absc) \\<and>\n            cfg \\<in> R_G.valid_cfg \\<and> abss s = state cfg) \\<and>\n     (\\<forall>y.\n         sets (M' y) = sets (stream_space (count_space UNIV)) \\<and>\n         prob_space (M' y)) \\<and>\n     distr (MDP.MC.T (repcs s cfg)) (stream_space (count_space UNIV))\n      (smap absc) =\n     measure_pmf (K_cfg cfg) \\<bind>\n     (\\<lambda>y. distr (M' y) (stream_space (count_space UNIV)) ((##) y))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma repc_inj_on_K_cfg:\n  assumes \"cfg \\<in> R_G.cfg_on s\" \"s \\<in> \\<S>\"\n  shows \"inj_on repc (set_pmf (K_cfg cfg))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on repc (set_pmf (K_cfg cfg))", "using assms"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.cfg_on s\n  s \\<in> \\<S>\n\ngoal (1 subgoal):\n 1. inj_on repc (set_pmf (K_cfg cfg))", "by (intro inj_on_inverseI[where g = absc], subst absc_repc_id)\n     (auto intro: R_G.valid_cfgD R_G.valid_cfgI R_G.valid_cfg_state_in_S)"], ["", "lemma smap_absc_iff:\n  assumes \"\\<And> x y. x \\<in> X \\<Longrightarrow> smap abss x = smap abss y \\<Longrightarrow> y \\<in> X\"\n  shows \"(smap state xs \\<in> X) = (smap (\\<lambda>z. abss (state z)) xs \\<in> smap abss ` X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (smap state xs \\<in> X) =\n    (smap (\\<lambda>z. abss (state z)) xs \\<in> smap abss ` X)", "proof (safe, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. smap state xs \\<in> X \\<Longrightarrow>\n    smap (\\<lambda>z. abss (state z)) xs \\<in> smap abss ` X\n 2. \\<And>x.\n       \\<lbrakk>smap (\\<lambda>z. abss (state z)) xs = smap abss x;\n        x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> smap state xs \\<in> X", "case 1"], ["proof (state)\nthis:\n  smap state xs \\<in> X\n\ngoal (2 subgoals):\n 1. smap state xs \\<in> X \\<Longrightarrow>\n    smap (\\<lambda>z. abss (state z)) xs \\<in> smap abss ` X\n 2. \\<And>x.\n       \\<lbrakk>smap (\\<lambda>z. abss (state z)) xs = smap abss x;\n        x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> smap state xs \\<in> X", "then"], ["proof (chain)\npicking this:\n  smap state xs \\<in> X", "show ?case"], ["proof (prove)\nusing this:\n  smap state xs \\<in> X\n\ngoal (1 subgoal):\n 1. smap (\\<lambda>z. abss (state z)) xs \\<in> smap abss ` X", "unfolding image_def"], ["proof (prove)\nusing this:\n  smap state xs \\<in> X\n\ngoal (1 subgoal):\n 1. smap (\\<lambda>z. abss (state z)) xs\n    \\<in> {y. \\<exists>x\\<in>X. y = smap abss x}", "by clarify (inst_existentials \"smap state xs\", auto simp: stream.map_comp)"], ["proof (state)\nthis:\n  smap (\\<lambda>z. abss (state z)) xs \\<in> smap abss ` X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>smap (\\<lambda>z. abss (state z)) xs = smap abss x;\n        x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> smap state xs \\<in> X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>smap (\\<lambda>z. abss (state z)) xs = smap abss x;\n        x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> smap state xs \\<in> X", "case prems: (2 xs')"], ["proof (state)\nthis:\n  smap (\\<lambda>z. abss (state z)) xs = smap abss xs'\n  xs' \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>smap (\\<lambda>z. abss (state z)) xs = smap abss x;\n        x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> smap state xs \\<in> X", "have\n    \"smap (\\<lambda>z. abss (state z)) xs = smap abss (smap state xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap (\\<lambda>z. abss (state z)) xs = smap abss (smap state xs)", "by (auto simp: comp_def stream.map_comp)"], ["proof (state)\nthis:\n  smap (\\<lambda>z. abss (state z)) xs = smap abss (smap state xs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>smap (\\<lambda>z. abss (state z)) xs = smap abss x;\n        x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> smap state xs \\<in> X", "with prems"], ["proof (chain)\npicking this:\n  smap (\\<lambda>z. abss (state z)) xs = smap abss xs'\n  xs' \\<in> X\n  smap (\\<lambda>z. abss (state z)) xs = smap abss (smap state xs)", "have \"smap abss (smap state xs) = smap abss xs'\""], ["proof (prove)\nusing this:\n  smap (\\<lambda>z. abss (state z)) xs = smap abss xs'\n  xs' \\<in> X\n  smap (\\<lambda>z. abss (state z)) xs = smap abss (smap state xs)\n\ngoal (1 subgoal):\n 1. smap abss (smap state xs) = smap abss xs'", "by simp"], ["proof (state)\nthis:\n  smap abss (smap state xs) = smap abss xs'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>smap (\\<lambda>z. abss (state z)) xs = smap abss x;\n        x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> smap state xs \\<in> X", "with prems(2) assms"], ["proof (chain)\npicking this:\n  xs' \\<in> X\n  \\<lbrakk>?x5 \\<in> X; smap abss ?x5 = smap abss ?y5\\<rbrakk>\n  \\<Longrightarrow> ?y5 \\<in> X\n  smap abss (smap state xs) = smap abss xs'", "show ?case"], ["proof (prove)\nusing this:\n  xs' \\<in> X\n  \\<lbrakk>?x5 \\<in> X; smap abss ?x5 = smap abss ?y5\\<rbrakk>\n  \\<Longrightarrow> ?y5 \\<in> X\n  smap abss (smap state xs) = smap abss xs'\n\ngoal (1 subgoal):\n 1. smap state xs \\<in> X", "by auto"], ["proof (state)\nthis:\n  smap state xs \\<in> X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_abss_reps[simp]:\n  assumes \"cfg \\<in> R_G.valid_cfg\"\n  shows \"abss (reps (state cfg)) = state cfg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abss (reps (state cfg)) = state cfg", "using assms"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n\ngoal (1 subgoal):\n 1. abss (reps (state cfg)) = state cfg", "by (subst \\<S>_abss_reps) (auto intro: R_G.valid_cfg_state_in_S)"], ["", "lemma in_space_UNIV: \"x \\<in> space (count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> space (count_space UNIV)", "by simp"], ["", "lemma S_reps_\\<S>_aux:\n  \"reps (l, R) \\<in> S \\<Longrightarrow> (l, R) \\<in> \\<S>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reps (l, R) \\<in> S \\<Longrightarrow> (l, R) \\<in> \\<S>", "using ccompatible_inv"], ["proof (prove)\nusing this:\n  ccompatible \\<R> (PTA.inv_of A ?l)\n\ngoal (1 subgoal):\n 1. reps (l, R) \\<in> S \\<Longrightarrow> (l, R) \\<in> \\<S>", "unfolding reps_def ccompatible_def \\<S>_def S_def"], ["proof (prove)\nusing this:\n  \\<forall>R\\<in>\\<R>.\n     R \\<subseteq> {v. v \\<turnstile> PTA.inv_of A ?l} \\<or>\n     {v. v \\<turnstile> PTA.inv_of A ?l} \\<inter> R = {}\n\ngoal (1 subgoal):\n 1. (case (l, R) of\n     (l, R) \\<Rightarrow>\n       if R \\<in> \\<R> then (l, SOME u. u \\<in> R)\n       else (l, \\<lambda>_. - 1))\n    \\<in> {(l, u).\n           l \\<in> L \\<and>\n           (\\<forall>x\\<in>\\<X>. 0 \\<le> u x) \\<and>\n           u \\<turnstile> PTA.inv_of A l} \\<Longrightarrow>\n    (l, R)\n    \\<in> {(l, R).\n           l \\<in> L \\<and>\n           R \\<in> \\<R> \\<and>\n           R \\<subseteq> {u. u \\<turnstile> PTA.inv_of A l}}", "by (cases \"R \\<in> \\<R>\"; auto simp: non_empty)"], ["", "(* XXX Move *)"], ["", "lemma S_reps_\\<S>[intro]:\n  \"reps s \\<in> S \\<Longrightarrow> s \\<in> \\<S>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reps s \\<in> S \\<Longrightarrow> s \\<in> \\<S>", "using S_reps_\\<S>_aux"], ["proof (prove)\nusing this:\n  reps (?l, ?R) \\<in> S \\<Longrightarrow> (?l, ?R) \\<in> \\<S>\n\ngoal (1 subgoal):\n 1. reps s \\<in> S \\<Longrightarrow> s \\<in> \\<S>", "by (metis surj_pair)"], ["", "lemma absc_valid_cfg_eq:\n  \"absc ` valid_cfg = R_G.valid_cfg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. absc ` MDP.valid_cfg = R_G.valid_cfg", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> MDP.valid_cfg \\<Longrightarrow> absc xa \\<in> R_G.valid_cfg\n 2. \\<And>x.\n       x \\<in> R_G.valid_cfg \\<Longrightarrow> x \\<in> absc ` MDP.valid_cfg", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. xa_ \\<in> MDP.valid_cfg \\<Longrightarrow> absc xa_ \\<in> R_G.valid_cfg", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> R_G.valid_cfg \\<Longrightarrow> x \\<in> absc ` MDP.valid_cfg", "subgoal for cfg"], ["proof (prove)\ngoal (1 subgoal):\n 1. cfg \\<in> R_G.valid_cfg \\<Longrightarrow> cfg \\<in> absc ` MDP.valid_cfg", "using absc_repcs_id[where s = \"reps (state cfg)\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?cfg \\<in> R_G.valid_cfg;\n   abss (reps (state cfg)) = state ?cfg\\<rbrakk>\n  \\<Longrightarrow> absc (repcs (reps (state cfg)) ?cfg) = ?cfg\n\ngoal (1 subgoal):\n 1. cfg \\<in> R_G.valid_cfg \\<Longrightarrow> cfg \\<in> absc ` MDP.valid_cfg", "by - (frule repcs_valid[where s = \"reps (state cfg)\"]; force intro: imageI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma action_repcs:\n  \"action (repcs (l, u) cfg) = rept (l, u) (action cfg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. action (repcs (l, u) cfg) = rept (l, u) (action cfg)", "by (simp add: repcs_def)"], ["", "subsection \\<open>Equalities Between Measures of Trace Spaces\\<close>"], ["", "(* TODO: Clean *)"], ["", "lemma path_measure_eq_absc1_new:\n  fixes cfg s\n  defines \"cfg' \\<equiv> absc cfg\"\n  assumes valid: \"cfg \\<in> valid_cfg\"\n  assumes X[measurable]: \"X \\<in> R_G.St\" and Y[measurable]: \"Y \\<in> MDP.St\"\n  assumes P: \"AE x in (R_G.T cfg'). P x\" and Q: \"AE x in (MDP.T cfg). Q x\"\n  assumes P'[measurable]: \"Measurable.pred R_G.St P\"\n      and Q'[measurable]: \"Measurable.pred MDP.St Q\"\n  assumes X_Y_closed: \"\\<And> x y. P x \\<Longrightarrow> smap abss y = x \\<Longrightarrow> x \\<in> X \\<Longrightarrow> y \\<in> Y \\<and> Q y\"\n  assumes Y_X_closed: \"\\<And> x y. Q y \\<Longrightarrow> smap abss y = x \\<Longrightarrow> y \\<in> Y \\<Longrightarrow> x \\<in> X \\<and> P x\"\n  shows\n    \"emeasure (R_G.T cfg') X = emeasure (MDP.T cfg) Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (R_G.T cfg') X = emeasure (MDP.T cfg) Y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure (R_G.T cfg') X = emeasure (MDP.T cfg) Y", "have *: \"stream_all2 (\\<lambda>s. (=) (absc s)) x y = stream_all2 (=) (smap absc x) y\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_all2 (\\<lambda>s. (=) (absc s)) x y =\n    stream_all2 (=) (smap absc x) y", "by simp"], ["proof (state)\nthis:\n  stream_all2 (\\<lambda>s. (=) (absc s)) ?x5 ?y5 =\n  stream_all2 (=) (smap absc ?x5) ?y5\n\ngoal (1 subgoal):\n 1. emeasure (R_G.T cfg') X = emeasure (MDP.T cfg) Y", "have *: \"stream_all2 (\\<lambda>s t. t = absc s) x y = stream_all2 (=) y (smap absc x)\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_all2 (\\<lambda>s t. t = absc s) x y =\n    stream_all2 (=) y (smap absc x)", "using stream.rel_conversep[of \"\\<lambda>s t. t = absc s\"]"], ["proof (prove)\nusing this:\n  stream_all2 (\\<lambda>s t. t = absc s)\\<inverse>\\<inverse> =\n  (stream_all2 (\\<lambda>s t. t = absc s))\\<inverse>\\<inverse>\n\ngoal (1 subgoal):\n 1. stream_all2 (\\<lambda>s t. t = absc s) x y =\n    stream_all2 (=) y (smap absc x)", "by (simp add: conversep_iff[abs_def])"], ["proof (state)\nthis:\n  stream_all2 (\\<lambda>s t. t = absc s) ?x5 ?y5 =\n  stream_all2 (=) ?y5 (smap absc ?x5)\n\ngoal (1 subgoal):\n 1. emeasure (R_G.T cfg') X = emeasure (MDP.T cfg) Y", "from P"], ["proof (chain)\npicking this:\n  almost_everywhere (R_G.T cfg') P", "have \"emeasure (R_G.T cfg') X = emeasure (R_G.T cfg') {x \\<in> X. P x}\""], ["proof (prove)\nusing this:\n  almost_everywhere (R_G.T cfg') P\n\ngoal (1 subgoal):\n 1. emeasure (R_G.T cfg') X = emeasure (R_G.T cfg') {x \\<in> X. P x}", "by (auto intro: emeasure_eq_AE)"], ["proof (state)\nthis:\n  emeasure (R_G.T cfg') X = emeasure (R_G.T cfg') {x \\<in> X. P x}\n\ngoal (1 subgoal):\n 1. emeasure (R_G.T cfg') X = emeasure (MDP.T cfg) Y", "moreover"], ["proof (state)\nthis:\n  emeasure (R_G.T cfg') X = emeasure (R_G.T cfg') {x \\<in> X. P x}\n\ngoal (1 subgoal):\n 1. emeasure (R_G.T cfg') X = emeasure (MDP.T cfg) Y", "from Q"], ["proof (chain)\npicking this:\n  almost_everywhere (MDP.T cfg) Q", "have \"emeasure (MDP.T cfg) Y = emeasure (MDP.T cfg) {y \\<in> Y. Q y}\""], ["proof (prove)\nusing this:\n  almost_everywhere (MDP.T cfg) Q\n\ngoal (1 subgoal):\n 1. emeasure (MDP.T cfg) Y = emeasure (MDP.T cfg) {y \\<in> Y. Q y}", "by (auto intro: emeasure_eq_AE)"], ["proof (state)\nthis:\n  emeasure (MDP.T cfg) Y = emeasure (MDP.T cfg) {y \\<in> Y. Q y}\n\ngoal (1 subgoal):\n 1. emeasure (R_G.T cfg') X = emeasure (MDP.T cfg) Y", "moreover"], ["proof (state)\nthis:\n  emeasure (MDP.T cfg) Y = emeasure (MDP.T cfg) {y \\<in> Y. Q y}\n\ngoal (1 subgoal):\n 1. emeasure (R_G.T cfg') X = emeasure (MDP.T cfg) Y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (R_G.T cfg') X = emeasure (MDP.T cfg) Y", "apply (simp only: calculation)"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (R_G.T cfg') {x \\<in> X. P x} =\n    emeasure (MDP.T cfg) {y \\<in> Y. Q y}", "unfolding R_G.T_def MDP.T_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (distr (MDP.MC.T cfg') R_G.St (smap state)) {x \\<in> X. P x} =\n    emeasure (distr (MDP.MC.T cfg) MDP.St (smap state)) {y \\<in> Y. Q y}", "apply (simp add: emeasure_distr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (MDP.MC.T cfg')\n     ({y. smap state y \\<in> X \\<and> P (smap state y)} \\<inter>\n      space (stream_space (count_space UNIV))) =\n    emeasure (MDP.MC.T cfg)\n     ({y. smap state y \\<in> Y \\<and> Q (smap state y)} \\<inter>\n      space (stream_space (count_space UNIV)))", "apply (rule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (MDP.MC.T cfg)\n     ({y. smap state y \\<in> Y \\<and> Q (smap state y)} \\<inter>\n      space (stream_space (count_space UNIV))) =\n    emeasure (MDP.MC.T cfg')\n     ({y. smap state y \\<in> X \\<and> P (smap state y)} \\<inter>\n      space (stream_space (count_space UNIV)))", "apply (rule T_eq_rel_half[where f = absc and S = valid_cfg])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>s t. ?R5 s t = (s \\<in> MDP.valid_cfg \\<and> absc s = t)\n 2. {y. smap state y \\<in> Y \\<and> Q (smap state y)} \\<inter>\n    space (stream_space (count_space UNIV))\n    \\<in> sets (stream_space (count_space UNIV))\n 3. {y. smap state y \\<in> X \\<and> P (smap state y)} \\<inter>\n    space (stream_space (count_space UNIV))\n    \\<in> sets (stream_space (count_space UNIV))\n 4. PTA.rel_set_strong (stream_all2 ?R5)\n     ({y. smap state y \\<in> Y \\<and> Q (smap state y)} \\<inter>\n      space (stream_space (count_space UNIV)))\n     ({y. smap state y \\<in> X \\<and> P (smap state y)} \\<inter>\n      space (stream_space (count_space UNIV)))\n 5. rel_fun ?R5 (rel_pmf ?R5) K_cfg K_cfg\n 6. ?R5 cfg cfg'", "apply (rule HOL.refl)"], ["proof (prove)\ngoal (5 subgoals):\n 1. {y. smap state y \\<in> Y \\<and> Q (smap state y)} \\<inter>\n    space (stream_space (count_space UNIV))\n    \\<in> sets (stream_space (count_space UNIV))\n 2. {y. smap state y \\<in> X \\<and> P (smap state y)} \\<inter>\n    space (stream_space (count_space UNIV))\n    \\<in> sets (stream_space (count_space UNIV))\n 3. PTA.rel_set_strong\n     (stream_all2 (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t))\n     ({y. smap state y \\<in> Y \\<and> Q (smap state y)} \\<inter>\n      space (stream_space (count_space UNIV)))\n     ({y. smap state y \\<in> X \\<and> P (smap state y)} \\<inter>\n      space (stream_space (count_space UNIV)))\n 4. rel_fun (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t)\n     (rel_pmf (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t)) K_cfg\n     K_cfg\n 5. cfg \\<in> MDP.valid_cfg \\<and> absc cfg = cfg'", "apply measurable"], ["proof (prove)\ngoal (3 subgoals):\n 1. PTA.rel_set_strong\n     (stream_all2 (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t))\n     ({y. smap state y \\<in> Y \\<and> Q (smap state y)} \\<inter>\n      space (stream_space (count_space UNIV)))\n     ({y. smap state y \\<in> X \\<and> P (smap state y)} \\<inter>\n      space (stream_space (count_space UNIV)))\n 2. rel_fun (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t)\n     (rel_pmf (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t)) K_cfg\n     K_cfg\n 3. cfg \\<in> MDP.valid_cfg \\<and> absc cfg = cfg'", "apply (simp add: space_stream_space)"], ["proof (prove)\ngoal (3 subgoals):\n 1. PTA.rel_set_strong\n     (stream_all2 (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t))\n     {y. smap state y \\<in> Y \\<and> Q (smap state y)}\n     {y. smap state y \\<in> X \\<and> P (smap state y)}\n 2. rel_fun (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t)\n     (rel_pmf (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t)) K_cfg\n     K_cfg\n 3. cfg \\<in> MDP.valid_cfg \\<and> absc cfg = cfg'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. PTA.rel_set_strong\n     (stream_all2 (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t))\n     {y. smap state y \\<in> Y \\<and> Q (smap state y)}\n     {y. smap state y \\<in> X \\<and> P (smap state y)}", "unfolding rel_set_strong_def stream.rel_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       stream_all2 (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t) x\n        y \\<longrightarrow>\n       (x \\<in> {y. smap state y \\<in> Y \\<and> Q (smap state y)}) =\n       (y \\<in> {y. smap state y \\<in> X \\<and> P (smap state y)})", "apply (intro allI impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stream_all2 (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t) x\n        y \\<Longrightarrow>\n       (x \\<in> {y. smap state y \\<in> Y \\<and> Q (smap state y)}) =\n       (y \\<in> {y. smap state y \\<in> X \\<and> P (smap state y)})", "apply (drule stream.rel_mono_strong[where Ra = \"\\<lambda>s t. t = absc s\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z yb.\n       \\<lbrakk>z \\<in> sset x; yb \\<in> sset y;\n        z \\<in> MDP.valid_cfg \\<and> absc z = yb\\<rbrakk>\n       \\<Longrightarrow> yb = absc z\n 2. \\<And>x y.\n       stream_all2 (\\<lambda>s t. t = absc s) x y \\<Longrightarrow>\n       (x \\<in> {y. smap state y \\<in> Y \\<and> Q (smap state y)}) =\n       (y \\<in> {y. smap state y \\<in> X \\<and> P (smap state y)})", "apply (simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stream_all2 (\\<lambda>s t. t = absc s) x y \\<Longrightarrow>\n       (x \\<in> {y. smap state y \\<in> Y \\<and> Q (smap state y)}) =\n       (y \\<in> {y. smap state y \\<in> X \\<and> P (smap state y)})", "subgoal for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_all2 (\\<lambda>s t. t = absc s) x y \\<Longrightarrow>\n    (x \\<in> {y. smap state y \\<in> Y \\<and> Q (smap state y)}) =\n    (y \\<in> {y. smap state y \\<in> X \\<and> P (smap state y)})", "using Y_X_closed[of \"smap state x\" \"smap state (smap absc x)\" for x y]"], ["proof (prove)\nusing this:\n  \\<lbrakk>Q (smap state ?xa7);\n   smap abss (smap state ?xa7) = smap state (smap absc ?xa7);\n   smap state ?xa7 \\<in> Y\\<rbrakk>\n  \\<Longrightarrow> smap state (smap absc ?xa7) \\<in> X \\<and>\n                    P (smap state (smap absc ?xa7))\n\ngoal (1 subgoal):\n 1. stream_all2 (\\<lambda>s t. t = absc s) x y \\<Longrightarrow>\n    (x \\<in> {y. smap state y \\<in> Y \\<and> Q (smap state y)}) =\n    (y \\<in> {y. smap state y \\<in> X \\<and> P (smap state y)})", "using X_Y_closed[of \"smap state (smap absc x)\" \"smap state x\" for x y]"], ["proof (prove)\nusing this:\n  \\<lbrakk>Q (smap state ?xa7);\n   smap abss (smap state ?xa7) = smap state (smap absc ?xa7);\n   smap state ?xa7 \\<in> Y\\<rbrakk>\n  \\<Longrightarrow> smap state (smap absc ?xa7) \\<in> X \\<and>\n                    P (smap state (smap absc ?xa7))\n  \\<lbrakk>P (smap state (smap absc ?xa7));\n   smap abss (smap state ?xa7) = smap state (smap absc ?xa7);\n   smap state (smap absc ?xa7) \\<in> X\\<rbrakk>\n  \\<Longrightarrow> smap state ?xa7 \\<in> Y \\<and> Q (smap state ?xa7)\n\ngoal (1 subgoal):\n 1. stream_all2 (\\<lambda>s t. t = absc s) x y \\<Longrightarrow>\n    (x \\<in> {y. smap state y \\<in> Y \\<and> Q (smap state y)}) =\n    (y \\<in> {y. smap state y \\<in> X \\<and> P (smap state y)})", "by (auto simp: * stream.rel_eq stream.map_comp state_absc)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (2 subgoals):\n 1. rel_fun (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t)\n     (rel_pmf (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t)) K_cfg\n     K_cfg\n 2. cfg \\<in> MDP.valid_cfg \\<and> absc cfg = cfg'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t)\n     (rel_pmf (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t)) K_cfg\n     K_cfg", "apply (auto intro!: rel_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> MDP.valid_cfg \\<Longrightarrow>\n       rel_pmf (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t)\n        (K_cfg x) (K_cfg (absc x))", "apply (subst K_cfg_map_absc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> MDP.valid_cfg \\<Longrightarrow> x \\<in> MDP.valid_cfg\n 2. \\<And>x.\n       x \\<in> MDP.valid_cfg \\<Longrightarrow>\n       rel_pmf (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t)\n        (K_cfg x) (map_pmf absc (K_cfg x))", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> MDP.valid_cfg \\<Longrightarrow>\n       rel_pmf (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t)\n        (K_cfg x) (map_pmf absc (K_cfg x))\n 2. \\<And>x. x \\<in> MDP.valid_cfg \\<Longrightarrow> x \\<in> MDP.valid_cfg", "apply (subst pmf.rel_map(2))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> MDP.valid_cfg \\<Longrightarrow>\n       rel_pmf (\\<lambda>x y. x \\<in> MDP.valid_cfg \\<and> absc x = absc y)\n        (K_cfg x) (K_cfg x)\n 2. \\<And>x. x \\<in> MDP.valid_cfg \\<Longrightarrow> x \\<in> MDP.valid_cfg", "apply (rule rel_pmf_reflI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> MDP.valid_cfg; xa \\<in> set_pmf (K_cfg x)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> MDP.valid_cfg \\<and> absc xa = absc xa\n 2. \\<And>x. x \\<in> MDP.valid_cfg \\<Longrightarrow> x \\<in> MDP.valid_cfg", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. cfg \\<in> MDP.valid_cfg \\<and> absc cfg = cfg'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. cfg \\<in> MDP.valid_cfg \\<and> absc cfg = cfg'", "using valid"], ["proof (prove)\nusing this:\n  cfg \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. cfg \\<in> MDP.valid_cfg \\<and> absc cfg = cfg'", "unfolding cfg'_def"], ["proof (prove)\nusing this:\n  cfg \\<in> MDP.valid_cfg\n\ngoal (1 subgoal):\n 1. cfg \\<in> MDP.valid_cfg \\<and> absc cfg = absc cfg", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  emeasure (R_G.T cfg') X = emeasure (MDP.T cfg) Y\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: Clean duplication *)"], ["", "lemma path_measure_eq_repcs1_new:\n  fixes cfg s\n  defines \"cfg' \\<equiv> repcs s cfg\"\n  assumes s: \"abss s = state cfg\"\n  assumes valid: \"cfg \\<in> R_G.valid_cfg\"\n  assumes X[measurable]: \"X \\<in> R_G.St\" and Y[measurable]: \"Y \\<in> MDP.St\"\n  assumes P: \"AE x in (R_G.T cfg). P x\" and Q: \"AE x in (MDP.T cfg'). Q x\"\n  assumes P'[measurable]: \"Measurable.pred R_G.St P\"\n      and Q'[measurable]: \"Measurable.pred MDP.St Q\"\n  assumes X_Y_closed: \"\\<And> x y. P x \\<Longrightarrow> smap abss y = x \\<Longrightarrow> x \\<in> X \\<Longrightarrow> y \\<in> Y \\<and> Q y\"\n  assumes Y_X_closed: \"\\<And> x y. Q y \\<Longrightarrow> smap abss y = x \\<Longrightarrow> y \\<in> Y \\<Longrightarrow> x \\<in> X \\<and> P x\"\n  shows\n    \"emeasure (R_G.T cfg) X = emeasure (MDP.T cfg') Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (R_G.T cfg) X = emeasure (MDP.T cfg') Y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure (R_G.T cfg) X = emeasure (MDP.T cfg') Y", "have *: \"stream_all2 (\\<lambda>s t. t = absc s) x y = stream_all2 (=) y (smap absc x)\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_all2 (\\<lambda>s t. t = absc s) x y =\n    stream_all2 (=) y (smap absc x)", "using stream.rel_conversep[of \"\\<lambda>s t. t = absc s\"]"], ["proof (prove)\nusing this:\n  stream_all2 (\\<lambda>s t. t = absc s)\\<inverse>\\<inverse> =\n  (stream_all2 (\\<lambda>s t. t = absc s))\\<inverse>\\<inverse>\n\ngoal (1 subgoal):\n 1. stream_all2 (\\<lambda>s t. t = absc s) x y =\n    stream_all2 (=) y (smap absc x)", "by (simp add: conversep_iff[abs_def])"], ["proof (state)\nthis:\n  stream_all2 (\\<lambda>s t. t = absc s) ?x5 ?y5 =\n  stream_all2 (=) ?y5 (smap absc ?x5)\n\ngoal (1 subgoal):\n 1. emeasure (R_G.T cfg) X = emeasure (MDP.T cfg') Y", "from P X"], ["proof (chain)\npicking this:\n  almost_everywhere (R_G.T cfg) P\n  X \\<in> sets R_G.St", "have\n    \"emeasure (R_G.T cfg) X = emeasure (R_G.T cfg) {x \\<in> X. P x}\""], ["proof (prove)\nusing this:\n  almost_everywhere (R_G.T cfg) P\n  X \\<in> sets R_G.St\n\ngoal (1 subgoal):\n 1. emeasure (R_G.T cfg) X = emeasure (R_G.T cfg) {x \\<in> X. P x}", "by (auto intro: emeasure_eq_AE)"], ["proof (state)\nthis:\n  emeasure (R_G.T cfg) X = emeasure (R_G.T cfg) {x \\<in> X. P x}\n\ngoal (1 subgoal):\n 1. emeasure (R_G.T cfg) X = emeasure (MDP.T cfg') Y", "moreover"], ["proof (state)\nthis:\n  emeasure (R_G.T cfg) X = emeasure (R_G.T cfg) {x \\<in> X. P x}\n\ngoal (1 subgoal):\n 1. emeasure (R_G.T cfg) X = emeasure (MDP.T cfg') Y", "from Q Y"], ["proof (chain)\npicking this:\n  almost_everywhere (MDP.T cfg') Q\n  Y \\<in> sets MDP.St", "have\n    \"emeasure (MDP.T cfg') Y = emeasure (MDP.T cfg') {y \\<in> Y. Q y}\""], ["proof (prove)\nusing this:\n  almost_everywhere (MDP.T cfg') Q\n  Y \\<in> sets MDP.St\n\ngoal (1 subgoal):\n 1. emeasure (MDP.T cfg') Y = emeasure (MDP.T cfg') {y \\<in> Y. Q y}", "by (auto intro: emeasure_eq_AE)"], ["proof (state)\nthis:\n  emeasure (MDP.T cfg') Y = emeasure (MDP.T cfg') {y \\<in> Y. Q y}\n\ngoal (1 subgoal):\n 1. emeasure (R_G.T cfg) X = emeasure (MDP.T cfg') Y", "moreover"], ["proof (state)\nthis:\n  emeasure (MDP.T cfg') Y = emeasure (MDP.T cfg') {y \\<in> Y. Q y}\n\ngoal (1 subgoal):\n 1. emeasure (R_G.T cfg) X = emeasure (MDP.T cfg') Y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (R_G.T cfg) X = emeasure (MDP.T cfg') Y", "apply (simp only: calculation)"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (R_G.T cfg) {x \\<in> X. P x} =\n    emeasure (MDP.T cfg') {y \\<in> Y. Q y}", "unfolding R_G.T_def MDP.T_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (distr (MDP.MC.T cfg) R_G.St (smap state)) {x \\<in> X. P x} =\n    emeasure (distr (MDP.MC.T cfg') MDP.St (smap state)) {y \\<in> Y. Q y}", "apply (simp add: emeasure_distr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (MDP.MC.T cfg)\n     ({y. smap state y \\<in> X \\<and> P (smap state y)} \\<inter>\n      space (stream_space (count_space UNIV))) =\n    emeasure (MDP.MC.T cfg')\n     ({y. smap state y \\<in> Y \\<and> Q (smap state y)} \\<inter>\n      space (stream_space (count_space UNIV)))", "apply (rule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (MDP.MC.T cfg')\n     ({y. smap state y \\<in> Y \\<and> Q (smap state y)} \\<inter>\n      space (stream_space (count_space UNIV))) =\n    emeasure (MDP.MC.T cfg)\n     ({y. smap state y \\<in> X \\<and> P (smap state y)} \\<inter>\n      space (stream_space (count_space UNIV)))", "apply (rule T_eq_rel_half[where f = absc and S = valid_cfg])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>s t. ?R5 s t = (s \\<in> MDP.valid_cfg \\<and> absc s = t)\n 2. {y. smap state y \\<in> Y \\<and> Q (smap state y)} \\<inter>\n    space (stream_space (count_space UNIV))\n    \\<in> sets (stream_space (count_space UNIV))\n 3. {y. smap state y \\<in> X \\<and> P (smap state y)} \\<inter>\n    space (stream_space (count_space UNIV))\n    \\<in> sets (stream_space (count_space UNIV))\n 4. PTA.rel_set_strong (stream_all2 ?R5)\n     ({y. smap state y \\<in> Y \\<and> Q (smap state y)} \\<inter>\n      space (stream_space (count_space UNIV)))\n     ({y. smap state y \\<in> X \\<and> P (smap state y)} \\<inter>\n      space (stream_space (count_space UNIV)))\n 5. rel_fun ?R5 (rel_pmf ?R5) K_cfg K_cfg\n 6. ?R5 cfg' cfg", "apply (rule HOL.refl)"], ["proof (prove)\ngoal (5 subgoals):\n 1. {y. smap state y \\<in> Y \\<and> Q (smap state y)} \\<inter>\n    space (stream_space (count_space UNIV))\n    \\<in> sets (stream_space (count_space UNIV))\n 2. {y. smap state y \\<in> X \\<and> P (smap state y)} \\<inter>\n    space (stream_space (count_space UNIV))\n    \\<in> sets (stream_space (count_space UNIV))\n 3. PTA.rel_set_strong\n     (stream_all2 (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t))\n     ({y. smap state y \\<in> Y \\<and> Q (smap state y)} \\<inter>\n      space (stream_space (count_space UNIV)))\n     ({y. smap state y \\<in> X \\<and> P (smap state y)} \\<inter>\n      space (stream_space (count_space UNIV)))\n 4. rel_fun (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t)\n     (rel_pmf (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t)) K_cfg\n     K_cfg\n 5. cfg' \\<in> MDP.valid_cfg \\<and> absc cfg' = cfg", "apply measurable"], ["proof (prove)\ngoal (3 subgoals):\n 1. PTA.rel_set_strong\n     (stream_all2 (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t))\n     ({y. smap state y \\<in> Y \\<and> Q (smap state y)} \\<inter>\n      space (stream_space (count_space UNIV)))\n     ({y. smap state y \\<in> X \\<and> P (smap state y)} \\<inter>\n      space (stream_space (count_space UNIV)))\n 2. rel_fun (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t)\n     (rel_pmf (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t)) K_cfg\n     K_cfg\n 3. cfg' \\<in> MDP.valid_cfg \\<and> absc cfg' = cfg", "apply (simp add: space_stream_space)"], ["proof (prove)\ngoal (3 subgoals):\n 1. PTA.rel_set_strong\n     (stream_all2 (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t))\n     {y. smap state y \\<in> Y \\<and> Q (smap state y)}\n     {y. smap state y \\<in> X \\<and> P (smap state y)}\n 2. rel_fun (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t)\n     (rel_pmf (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t)) K_cfg\n     K_cfg\n 3. cfg' \\<in> MDP.valid_cfg \\<and> absc cfg' = cfg", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. PTA.rel_set_strong\n     (stream_all2 (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t))\n     {y. smap state y \\<in> Y \\<and> Q (smap state y)}\n     {y. smap state y \\<in> X \\<and> P (smap state y)}", "unfolding rel_set_strong_def stream.rel_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       stream_all2 (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t) x\n        y \\<longrightarrow>\n       (x \\<in> {y. smap state y \\<in> Y \\<and> Q (smap state y)}) =\n       (y \\<in> {y. smap state y \\<in> X \\<and> P (smap state y)})", "apply (intro allI impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stream_all2 (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t) x\n        y \\<Longrightarrow>\n       (x \\<in> {y. smap state y \\<in> Y \\<and> Q (smap state y)}) =\n       (y \\<in> {y. smap state y \\<in> X \\<and> P (smap state y)})", "apply (drule stream.rel_mono_strong[where Ra = \"\\<lambda>s t. t = absc s\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z yb.\n       \\<lbrakk>z \\<in> sset x; yb \\<in> sset y;\n        z \\<in> MDP.valid_cfg \\<and> absc z = yb\\<rbrakk>\n       \\<Longrightarrow> yb = absc z\n 2. \\<And>x y.\n       stream_all2 (\\<lambda>s t. t = absc s) x y \\<Longrightarrow>\n       (x \\<in> {y. smap state y \\<in> Y \\<and> Q (smap state y)}) =\n       (y \\<in> {y. smap state y \\<in> X \\<and> P (smap state y)})", "apply (simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stream_all2 (\\<lambda>s t. t = absc s) x y \\<Longrightarrow>\n       (x \\<in> {y. smap state y \\<in> Y \\<and> Q (smap state y)}) =\n       (y \\<in> {y. smap state y \\<in> X \\<and> P (smap state y)})", "subgoal for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_all2 (\\<lambda>s t. t = absc s) x y \\<Longrightarrow>\n    (x \\<in> {y. smap state y \\<in> Y \\<and> Q (smap state y)}) =\n    (y \\<in> {y. smap state y \\<in> X \\<and> P (smap state y)})", "using Y_X_closed[of \"smap state x\" \"smap state (smap absc x)\" for x y]"], ["proof (prove)\nusing this:\n  \\<lbrakk>Q (smap state ?xa7);\n   smap abss (smap state ?xa7) = smap state (smap absc ?xa7);\n   smap state ?xa7 \\<in> Y\\<rbrakk>\n  \\<Longrightarrow> smap state (smap absc ?xa7) \\<in> X \\<and>\n                    P (smap state (smap absc ?xa7))\n\ngoal (1 subgoal):\n 1. stream_all2 (\\<lambda>s t. t = absc s) x y \\<Longrightarrow>\n    (x \\<in> {y. smap state y \\<in> Y \\<and> Q (smap state y)}) =\n    (y \\<in> {y. smap state y \\<in> X \\<and> P (smap state y)})", "using X_Y_closed[of \"smap state (smap absc x)\" \"smap state x\" for x y]"], ["proof (prove)\nusing this:\n  \\<lbrakk>Q (smap state ?xa7);\n   smap abss (smap state ?xa7) = smap state (smap absc ?xa7);\n   smap state ?xa7 \\<in> Y\\<rbrakk>\n  \\<Longrightarrow> smap state (smap absc ?xa7) \\<in> X \\<and>\n                    P (smap state (smap absc ?xa7))\n  \\<lbrakk>P (smap state (smap absc ?xa7));\n   smap abss (smap state ?xa7) = smap state (smap absc ?xa7);\n   smap state (smap absc ?xa7) \\<in> X\\<rbrakk>\n  \\<Longrightarrow> smap state ?xa7 \\<in> Y \\<and> Q (smap state ?xa7)\n\ngoal (1 subgoal):\n 1. stream_all2 (\\<lambda>s t. t = absc s) x y \\<Longrightarrow>\n    (x \\<in> {y. smap state y \\<in> Y \\<and> Q (smap state y)}) =\n    (y \\<in> {y. smap state y \\<in> X \\<and> P (smap state y)})", "by (auto simp: * stream.rel_eq stream.map_comp state_absc)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (2 subgoals):\n 1. rel_fun (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t)\n     (rel_pmf (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t)) K_cfg\n     K_cfg\n 2. cfg' \\<in> MDP.valid_cfg \\<and> absc cfg' = cfg", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t)\n     (rel_pmf (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t)) K_cfg\n     K_cfg", "apply (auto intro!: rel_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> MDP.valid_cfg \\<Longrightarrow>\n       rel_pmf (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t)\n        (K_cfg x) (K_cfg (absc x))", "apply (subst K_cfg_map_absc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> MDP.valid_cfg \\<Longrightarrow> x \\<in> MDP.valid_cfg\n 2. \\<And>x.\n       x \\<in> MDP.valid_cfg \\<Longrightarrow>\n       rel_pmf (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t)\n        (K_cfg x) (map_pmf absc (K_cfg x))", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> MDP.valid_cfg \\<Longrightarrow>\n       rel_pmf (\\<lambda>s t. s \\<in> MDP.valid_cfg \\<and> absc s = t)\n        (K_cfg x) (map_pmf absc (K_cfg x))\n 2. \\<And>x. x \\<in> MDP.valid_cfg \\<Longrightarrow> x \\<in> MDP.valid_cfg", "apply (subst pmf.rel_map(2))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> MDP.valid_cfg \\<Longrightarrow>\n       rel_pmf (\\<lambda>x y. x \\<in> MDP.valid_cfg \\<and> absc x = absc y)\n        (K_cfg x) (K_cfg x)\n 2. \\<And>x. x \\<in> MDP.valid_cfg \\<Longrightarrow> x \\<in> MDP.valid_cfg", "apply (rule rel_pmf_reflI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> MDP.valid_cfg; xa \\<in> set_pmf (K_cfg x)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> MDP.valid_cfg \\<and> absc xa = absc xa\n 2. \\<And>x. x \\<in> MDP.valid_cfg \\<Longrightarrow> x \\<in> MDP.valid_cfg", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. cfg' \\<in> MDP.valid_cfg \\<and> absc cfg' = cfg", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. cfg' \\<in> MDP.valid_cfg \\<and> absc cfg' = cfg", "using valid"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n\ngoal (1 subgoal):\n 1. cfg' \\<in> MDP.valid_cfg \\<and> absc cfg' = cfg", "unfolding cfg'_def"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n\ngoal (1 subgoal):\n 1. repcs s cfg \\<in> MDP.valid_cfg \\<and> absc (repcs s cfg) = cfg", "by (auto simp: s absc_repcs_id)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  emeasure (R_G.T cfg) X = emeasure (MDP.T cfg') Y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma region_compatible_suntil1:\n  assumes \"(holds (\\<lambda>x. \\<phi> (reps x)) suntil holds (\\<lambda>x. \\<psi> (reps x))) (smap abss x)\"\n      and \"pred_stream (\\<lambda> s. \\<phi> (reps (abss s)) \\<longrightarrow> \\<phi> s) x\"\n      and \"pred_stream (\\<lambda> s. \\<psi> (reps (abss s)) \\<longrightarrow> \\<psi> s) x\"\n  shows \"(holds \\<phi> suntil holds \\<psi>) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (holds \\<phi> suntil holds \\<psi>) x", "using assms"], ["proof (prove)\nusing this:\n  (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n   holds (\\<lambda>x. \\<psi> (reps x)))\n   (smap abss x)\n  pred_stream\n   (\\<lambda>s. \\<phi> (reps (abss s)) \\<longrightarrow> \\<phi> s) x\n  pred_stream\n   (\\<lambda>s. \\<psi> (reps (abss s)) \\<longrightarrow> \\<psi> s) x\n\ngoal (1 subgoal):\n 1. (holds \\<phi> suntil holds \\<psi>) x", "proof (induction \"smap abss x\" arbitrary: x rule: suntil.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>holds (\\<lambda>x. \\<psi> (reps x)) (smap abss x);\n        pred_stream\n         (\\<lambda>s. \\<phi> (reps (abss s)) \\<longrightarrow> \\<phi> s) x;\n        pred_stream\n         (\\<lambda>s. \\<psi> (reps (abss s)) \\<longrightarrow> \\<psi> s)\n         x\\<rbrakk>\n       \\<Longrightarrow> (holds \\<phi> suntil holds \\<psi>) x\n 2. \\<And>x.\n       \\<lbrakk>holds (\\<lambda>x. \\<phi> (reps x)) (smap abss x);\n        (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n         holds (\\<lambda>x. \\<psi> (reps x)))\n         (stl (smap abss x));\n        \\<And>xa.\n           \\<lbrakk>stl (smap abss x) = smap abss xa;\n            pred_stream\n             (\\<lambda>s. \\<phi> (reps (abss s)) \\<longrightarrow> \\<phi> s)\n             xa;\n            pred_stream\n             (\\<lambda>s. \\<psi> (reps (abss s)) \\<longrightarrow> \\<psi> s)\n             xa\\<rbrakk>\n           \\<Longrightarrow> (holds \\<phi> suntil holds \\<psi>) xa;\n        pred_stream\n         (\\<lambda>s. \\<phi> (reps (abss s)) \\<longrightarrow> \\<phi> s) x;\n        pred_stream\n         (\\<lambda>s. \\<psi> (reps (abss s)) \\<longrightarrow> \\<psi> s)\n         x\\<rbrakk>\n       \\<Longrightarrow> (holds \\<phi> suntil holds \\<psi>) x", "case base"], ["proof (state)\nthis:\n  holds (\\<lambda>x. \\<psi> (reps x)) (smap abss x)\n  pred_stream\n   (\\<lambda>s. \\<phi> (reps (abss s)) \\<longrightarrow> \\<phi> s) x\n  pred_stream\n   (\\<lambda>s. \\<psi> (reps (abss s)) \\<longrightarrow> \\<psi> s) x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>holds (\\<lambda>x. \\<psi> (reps x)) (smap abss x);\n        pred_stream\n         (\\<lambda>s. \\<phi> (reps (abss s)) \\<longrightarrow> \\<phi> s) x;\n        pred_stream\n         (\\<lambda>s. \\<psi> (reps (abss s)) \\<longrightarrow> \\<psi> s)\n         x\\<rbrakk>\n       \\<Longrightarrow> (holds \\<phi> suntil holds \\<psi>) x\n 2. \\<And>x.\n       \\<lbrakk>holds (\\<lambda>x. \\<phi> (reps x)) (smap abss x);\n        (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n         holds (\\<lambda>x. \\<psi> (reps x)))\n         (stl (smap abss x));\n        \\<And>xa.\n           \\<lbrakk>stl (smap abss x) = smap abss xa;\n            pred_stream\n             (\\<lambda>s. \\<phi> (reps (abss s)) \\<longrightarrow> \\<phi> s)\n             xa;\n            pred_stream\n             (\\<lambda>s. \\<psi> (reps (abss s)) \\<longrightarrow> \\<psi> s)\n             xa\\<rbrakk>\n           \\<Longrightarrow> (holds \\<phi> suntil holds \\<psi>) xa;\n        pred_stream\n         (\\<lambda>s. \\<phi> (reps (abss s)) \\<longrightarrow> \\<phi> s) x;\n        pred_stream\n         (\\<lambda>s. \\<psi> (reps (abss s)) \\<longrightarrow> \\<psi> s)\n         x\\<rbrakk>\n       \\<Longrightarrow> (holds \\<phi> suntil holds \\<psi>) x", "then"], ["proof (chain)\npicking this:\n  holds (\\<lambda>x. \\<psi> (reps x)) (smap abss x)\n  pred_stream\n   (\\<lambda>s. \\<phi> (reps (abss s)) \\<longrightarrow> \\<phi> s) x\n  pred_stream\n   (\\<lambda>s. \\<psi> (reps (abss s)) \\<longrightarrow> \\<psi> s) x", "show ?case"], ["proof (prove)\nusing this:\n  holds (\\<lambda>x. \\<psi> (reps x)) (smap abss x)\n  pred_stream\n   (\\<lambda>s. \\<phi> (reps (abss s)) \\<longrightarrow> \\<phi> s) x\n  pred_stream\n   (\\<lambda>s. \\<psi> (reps (abss s)) \\<longrightarrow> \\<psi> s) x\n\ngoal (1 subgoal):\n 1. (holds \\<phi> suntil holds \\<psi>) x", "by (auto intro: suntil.base simp: stream.pred_set)"], ["proof (state)\nthis:\n  (holds \\<phi> suntil holds \\<psi>) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>holds (\\<lambda>x. \\<phi> (reps x)) (smap abss x);\n        (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n         holds (\\<lambda>x. \\<psi> (reps x)))\n         (stl (smap abss x));\n        \\<And>xa.\n           \\<lbrakk>stl (smap abss x) = smap abss xa;\n            pred_stream\n             (\\<lambda>s. \\<phi> (reps (abss s)) \\<longrightarrow> \\<phi> s)\n             xa;\n            pred_stream\n             (\\<lambda>s. \\<psi> (reps (abss s)) \\<longrightarrow> \\<psi> s)\n             xa\\<rbrakk>\n           \\<Longrightarrow> (holds \\<phi> suntil holds \\<psi>) xa;\n        pred_stream\n         (\\<lambda>s. \\<phi> (reps (abss s)) \\<longrightarrow> \\<phi> s) x;\n        pred_stream\n         (\\<lambda>s. \\<psi> (reps (abss s)) \\<longrightarrow> \\<psi> s)\n         x\\<rbrakk>\n       \\<Longrightarrow> (holds \\<phi> suntil holds \\<psi>) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>holds (\\<lambda>x. \\<phi> (reps x)) (smap abss x);\n        (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n         holds (\\<lambda>x. \\<psi> (reps x)))\n         (stl (smap abss x));\n        \\<And>xa.\n           \\<lbrakk>stl (smap abss x) = smap abss xa;\n            pred_stream\n             (\\<lambda>s. \\<phi> (reps (abss s)) \\<longrightarrow> \\<phi> s)\n             xa;\n            pred_stream\n             (\\<lambda>s. \\<psi> (reps (abss s)) \\<longrightarrow> \\<psi> s)\n             xa\\<rbrakk>\n           \\<Longrightarrow> (holds \\<phi> suntil holds \\<psi>) xa;\n        pred_stream\n         (\\<lambda>s. \\<phi> (reps (abss s)) \\<longrightarrow> \\<phi> s) x;\n        pred_stream\n         (\\<lambda>s. \\<psi> (reps (abss s)) \\<longrightarrow> \\<psi> s)\n         x\\<rbrakk>\n       \\<Longrightarrow> (holds \\<phi> suntil holds \\<psi>) x", "case step"], ["proof (state)\nthis:\n  holds (\\<lambda>x. \\<phi> (reps x)) (smap abss x)\n  (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n   holds (\\<lambda>x. \\<psi> (reps x)))\n   (stl (smap abss x))\n  \\<lbrakk>stl (smap abss x) = smap abss ?x5;\n   pred_stream\n    (\\<lambda>s. \\<phi> (reps (abss s)) \\<longrightarrow> \\<phi> s) ?x5;\n   pred_stream\n    (\\<lambda>s. \\<psi> (reps (abss s)) \\<longrightarrow> \\<psi> s)\n    ?x5\\<rbrakk>\n  \\<Longrightarrow> (holds \\<phi> suntil holds \\<psi>) ?x5\n  pred_stream\n   (\\<lambda>s. \\<phi> (reps (abss s)) \\<longrightarrow> \\<phi> s) x\n  pred_stream\n   (\\<lambda>s. \\<psi> (reps (abss s)) \\<longrightarrow> \\<psi> s) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>holds (\\<lambda>x. \\<phi> (reps x)) (smap abss x);\n        (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n         holds (\\<lambda>x. \\<psi> (reps x)))\n         (stl (smap abss x));\n        \\<And>xa.\n           \\<lbrakk>stl (smap abss x) = smap abss xa;\n            pred_stream\n             (\\<lambda>s. \\<phi> (reps (abss s)) \\<longrightarrow> \\<phi> s)\n             xa;\n            pred_stream\n             (\\<lambda>s. \\<psi> (reps (abss s)) \\<longrightarrow> \\<psi> s)\n             xa\\<rbrakk>\n           \\<Longrightarrow> (holds \\<phi> suntil holds \\<psi>) xa;\n        pred_stream\n         (\\<lambda>s. \\<phi> (reps (abss s)) \\<longrightarrow> \\<phi> s) x;\n        pred_stream\n         (\\<lambda>s. \\<psi> (reps (abss s)) \\<longrightarrow> \\<psi> s)\n         x\\<rbrakk>\n       \\<Longrightarrow> (holds \\<phi> suntil holds \\<psi>) x", "have\n    \"pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) \\<longrightarrow> \\<phi> s) (stl x)\"\n    \"pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) \\<longrightarrow> \\<psi> s) (stl x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream\n     (\\<lambda>s. \\<phi> (reps (abss s)) \\<longrightarrow> \\<phi> s)\n     (stl x) &&&\n    pred_stream\n     (\\<lambda>s. \\<psi> (reps (abss s)) \\<longrightarrow> \\<psi> s) (stl x)", "using step.prems"], ["proof (prove)\nusing this:\n  pred_stream\n   (\\<lambda>s. \\<phi> (reps (abss s)) \\<longrightarrow> \\<phi> s) x\n  pred_stream\n   (\\<lambda>s. \\<psi> (reps (abss s)) \\<longrightarrow> \\<psi> s) x\n\ngoal (1 subgoal):\n 1. pred_stream\n     (\\<lambda>s. \\<phi> (reps (abss s)) \\<longrightarrow> \\<phi> s)\n     (stl x) &&&\n    pred_stream\n     (\\<lambda>s. \\<psi> (reps (abss s)) \\<longrightarrow> \\<psi> s) (stl x)", "apply (cases x; auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream\n     (\\<lambda>s. \\<psi> (reps (abss s)) \\<longrightarrow> \\<psi> s) (stl x)", "using step.prems"], ["proof (prove)\nusing this:\n  pred_stream\n   (\\<lambda>s. \\<phi> (reps (abss s)) \\<longrightarrow> \\<phi> s) x\n  pred_stream\n   (\\<lambda>s. \\<psi> (reps (abss s)) \\<longrightarrow> \\<psi> s) x\n\ngoal (1 subgoal):\n 1. pred_stream\n     (\\<lambda>s. \\<psi> (reps (abss s)) \\<longrightarrow> \\<psi> s) (stl x)", "apply (cases x; auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  pred_stream\n   (\\<lambda>s. \\<phi> (reps (abss s)) \\<longrightarrow> \\<phi> s) (stl x)\n  pred_stream\n   (\\<lambda>s. \\<psi> (reps (abss s)) \\<longrightarrow> \\<psi> s) (stl x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>holds (\\<lambda>x. \\<phi> (reps x)) (smap abss x);\n        (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n         holds (\\<lambda>x. \\<psi> (reps x)))\n         (stl (smap abss x));\n        \\<And>xa.\n           \\<lbrakk>stl (smap abss x) = smap abss xa;\n            pred_stream\n             (\\<lambda>s. \\<phi> (reps (abss s)) \\<longrightarrow> \\<phi> s)\n             xa;\n            pred_stream\n             (\\<lambda>s. \\<psi> (reps (abss s)) \\<longrightarrow> \\<psi> s)\n             xa\\<rbrakk>\n           \\<Longrightarrow> (holds \\<phi> suntil holds \\<psi>) xa;\n        pred_stream\n         (\\<lambda>s. \\<phi> (reps (abss s)) \\<longrightarrow> \\<phi> s) x;\n        pred_stream\n         (\\<lambda>s. \\<psi> (reps (abss s)) \\<longrightarrow> \\<psi> s)\n         x\\<rbrakk>\n       \\<Longrightarrow> (holds \\<phi> suntil holds \\<psi>) x", "with step.hyps(3)[of \"stl x\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>stl (smap abss x) = smap abss (stl x);\n   pred_stream\n    (\\<lambda>s. \\<phi> (reps (abss s)) \\<longrightarrow> \\<phi> s) (stl x);\n   pred_stream\n    (\\<lambda>s. \\<psi> (reps (abss s)) \\<longrightarrow> \\<psi> s)\n    (stl x)\\<rbrakk>\n  \\<Longrightarrow> (holds \\<phi> suntil holds \\<psi>) (stl x)\n  pred_stream\n   (\\<lambda>s. \\<phi> (reps (abss s)) \\<longrightarrow> \\<phi> s) (stl x)\n  pred_stream\n   (\\<lambda>s. \\<psi> (reps (abss s)) \\<longrightarrow> \\<psi> s) (stl x)", "have \"(holds \\<phi> suntil holds \\<psi>) (stl x)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>stl (smap abss x) = smap abss (stl x);\n   pred_stream\n    (\\<lambda>s. \\<phi> (reps (abss s)) \\<longrightarrow> \\<phi> s) (stl x);\n   pred_stream\n    (\\<lambda>s. \\<psi> (reps (abss s)) \\<longrightarrow> \\<psi> s)\n    (stl x)\\<rbrakk>\n  \\<Longrightarrow> (holds \\<phi> suntil holds \\<psi>) (stl x)\n  pred_stream\n   (\\<lambda>s. \\<phi> (reps (abss s)) \\<longrightarrow> \\<phi> s) (stl x)\n  pred_stream\n   (\\<lambda>s. \\<psi> (reps (abss s)) \\<longrightarrow> \\<psi> s) (stl x)\n\ngoal (1 subgoal):\n 1. (holds \\<phi> suntil holds \\<psi>) (stl x)", "by auto"], ["proof (state)\nthis:\n  (holds \\<phi> suntil holds \\<psi>) (stl x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>holds (\\<lambda>x. \\<phi> (reps x)) (smap abss x);\n        (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n         holds (\\<lambda>x. \\<psi> (reps x)))\n         (stl (smap abss x));\n        \\<And>xa.\n           \\<lbrakk>stl (smap abss x) = smap abss xa;\n            pred_stream\n             (\\<lambda>s. \\<phi> (reps (abss s)) \\<longrightarrow> \\<phi> s)\n             xa;\n            pred_stream\n             (\\<lambda>s. \\<psi> (reps (abss s)) \\<longrightarrow> \\<psi> s)\n             xa\\<rbrakk>\n           \\<Longrightarrow> (holds \\<phi> suntil holds \\<psi>) xa;\n        pred_stream\n         (\\<lambda>s. \\<phi> (reps (abss s)) \\<longrightarrow> \\<phi> s) x;\n        pred_stream\n         (\\<lambda>s. \\<psi> (reps (abss s)) \\<longrightarrow> \\<psi> s)\n         x\\<rbrakk>\n       \\<Longrightarrow> (holds \\<phi> suntil holds \\<psi>) x", "with step.prems step.hyps(1-2)"], ["proof (chain)\npicking this:\n  pred_stream\n   (\\<lambda>s. \\<phi> (reps (abss s)) \\<longrightarrow> \\<phi> s) x\n  pred_stream\n   (\\<lambda>s. \\<psi> (reps (abss s)) \\<longrightarrow> \\<psi> s) x\n  holds (\\<lambda>x. \\<phi> (reps x)) (smap abss x)\n  (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n   holds (\\<lambda>x. \\<psi> (reps x)))\n   (stl (smap abss x))\n  (holds \\<phi> suntil holds \\<psi>) (stl x)", "show ?case"], ["proof (prove)\nusing this:\n  pred_stream\n   (\\<lambda>s. \\<phi> (reps (abss s)) \\<longrightarrow> \\<phi> s) x\n  pred_stream\n   (\\<lambda>s. \\<psi> (reps (abss s)) \\<longrightarrow> \\<psi> s) x\n  holds (\\<lambda>x. \\<phi> (reps x)) (smap abss x)\n  (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n   holds (\\<lambda>x. \\<psi> (reps x)))\n   (stl (smap abss x))\n  (holds \\<phi> suntil holds \\<psi>) (stl x)\n\ngoal (1 subgoal):\n 1. (holds \\<phi> suntil holds \\<psi>) x", "by (auto intro: suntil.step simp: stream.pred_set)"], ["proof (state)\nthis:\n  (holds \\<phi> suntil holds \\<psi>) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma region_compatible_suntil2:\n  assumes \"(holds \\<phi> suntil holds \\<psi>) x\"\n      and \"pred_stream (\\<lambda> s. \\<phi> s \\<longrightarrow> \\<phi> (reps (abss s))) x\"\n      and \"pred_stream (\\<lambda> s. \\<psi> s \\<longrightarrow> \\<psi> (reps (abss s))) x\"\n  shows \"(holds (\\<lambda>x. \\<phi> (reps x)) suntil holds (\\<lambda>x. \\<psi> (reps x))) (smap abss x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n     holds (\\<lambda>x. \\<psi> (reps x)))\n     (smap abss x)", "using assms"], ["proof (prove)\nusing this:\n  (holds \\<phi> suntil holds \\<psi>) x\n  pred_stream\n   (\\<lambda>s. \\<phi> s \\<longrightarrow> \\<phi> (reps (abss s))) x\n  pred_stream\n   (\\<lambda>s. \\<psi> s \\<longrightarrow> \\<psi> (reps (abss s))) x\n\ngoal (1 subgoal):\n 1. (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n     holds (\\<lambda>x. \\<psi> (reps x)))\n     (smap abss x)", "proof (induction x rule: suntil.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>holds \\<psi> \\<omega>;\n        pred_stream\n         (\\<lambda>s. \\<phi> s \\<longrightarrow> \\<phi> (reps (abss s)))\n         \\<omega>;\n        pred_stream\n         (\\<lambda>s. \\<psi> s \\<longrightarrow> \\<psi> (reps (abss s)))\n         \\<omega>\\<rbrakk>\n       \\<Longrightarrow> (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n                          holds (\\<lambda>x. \\<psi> (reps x)))\n                          (smap abss \\<omega>)\n 2. \\<And>\\<omega>.\n       \\<lbrakk>holds \\<phi> \\<omega>;\n        (holds \\<phi> suntil holds \\<psi>) (stl \\<omega>);\n        \\<lbrakk>pred_stream\n                  (\\<lambda>s.\n                      \\<phi> s \\<longrightarrow> \\<phi> (reps (abss s)))\n                  (stl \\<omega>);\n         pred_stream\n          (\\<lambda>s. \\<psi> s \\<longrightarrow> \\<psi> (reps (abss s)))\n          (stl \\<omega>)\\<rbrakk>\n        \\<Longrightarrow> (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n                           holds (\\<lambda>x. \\<psi> (reps x)))\n                           (smap abss (stl \\<omega>));\n        pred_stream\n         (\\<lambda>s. \\<phi> s \\<longrightarrow> \\<phi> (reps (abss s)))\n         \\<omega>;\n        pred_stream\n         (\\<lambda>s. \\<psi> s \\<longrightarrow> \\<psi> (reps (abss s)))\n         \\<omega>\\<rbrakk>\n       \\<Longrightarrow> (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n                          holds (\\<lambda>x. \\<psi> (reps x)))\n                          (smap abss \\<omega>)", "case (base x)"], ["proof (state)\nthis:\n  holds \\<psi> x\n  pred_stream\n   (\\<lambda>s. \\<phi> s \\<longrightarrow> \\<phi> (reps (abss s))) x\n  pred_stream\n   (\\<lambda>s. \\<psi> s \\<longrightarrow> \\<psi> (reps (abss s))) x\n\ngoal (2 subgoals):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>holds \\<psi> \\<omega>;\n        pred_stream\n         (\\<lambda>s. \\<phi> s \\<longrightarrow> \\<phi> (reps (abss s)))\n         \\<omega>;\n        pred_stream\n         (\\<lambda>s. \\<psi> s \\<longrightarrow> \\<psi> (reps (abss s)))\n         \\<omega>\\<rbrakk>\n       \\<Longrightarrow> (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n                          holds (\\<lambda>x. \\<psi> (reps x)))\n                          (smap abss \\<omega>)\n 2. \\<And>\\<omega>.\n       \\<lbrakk>holds \\<phi> \\<omega>;\n        (holds \\<phi> suntil holds \\<psi>) (stl \\<omega>);\n        \\<lbrakk>pred_stream\n                  (\\<lambda>s.\n                      \\<phi> s \\<longrightarrow> \\<phi> (reps (abss s)))\n                  (stl \\<omega>);\n         pred_stream\n          (\\<lambda>s. \\<psi> s \\<longrightarrow> \\<psi> (reps (abss s)))\n          (stl \\<omega>)\\<rbrakk>\n        \\<Longrightarrow> (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n                           holds (\\<lambda>x. \\<psi> (reps x)))\n                           (smap abss (stl \\<omega>));\n        pred_stream\n         (\\<lambda>s. \\<phi> s \\<longrightarrow> \\<phi> (reps (abss s)))\n         \\<omega>;\n        pred_stream\n         (\\<lambda>s. \\<psi> s \\<longrightarrow> \\<psi> (reps (abss s)))\n         \\<omega>\\<rbrakk>\n       \\<Longrightarrow> (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n                          holds (\\<lambda>x. \\<psi> (reps x)))\n                          (smap abss \\<omega>)", "then"], ["proof (chain)\npicking this:\n  holds \\<psi> x\n  pred_stream\n   (\\<lambda>s. \\<phi> s \\<longrightarrow> \\<phi> (reps (abss s))) x\n  pred_stream\n   (\\<lambda>s. \\<psi> s \\<longrightarrow> \\<psi> (reps (abss s))) x", "show ?case"], ["proof (prove)\nusing this:\n  holds \\<psi> x\n  pred_stream\n   (\\<lambda>s. \\<phi> s \\<longrightarrow> \\<phi> (reps (abss s))) x\n  pred_stream\n   (\\<lambda>s. \\<psi> s \\<longrightarrow> \\<psi> (reps (abss s))) x\n\ngoal (1 subgoal):\n 1. (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n     holds (\\<lambda>x. \\<psi> (reps x)))\n     (smap abss x)", "by (auto intro: suntil.base simp: stream.pred_set)"], ["proof (state)\nthis:\n  (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n   holds (\\<lambda>x. \\<psi> (reps x)))\n   (smap abss x)\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>holds \\<phi> \\<omega>;\n        (holds \\<phi> suntil holds \\<psi>) (stl \\<omega>);\n        \\<lbrakk>pred_stream\n                  (\\<lambda>s.\n                      \\<phi> s \\<longrightarrow> \\<phi> (reps (abss s)))\n                  (stl \\<omega>);\n         pred_stream\n          (\\<lambda>s. \\<psi> s \\<longrightarrow> \\<psi> (reps (abss s)))\n          (stl \\<omega>)\\<rbrakk>\n        \\<Longrightarrow> (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n                           holds (\\<lambda>x. \\<psi> (reps x)))\n                           (smap abss (stl \\<omega>));\n        pred_stream\n         (\\<lambda>s. \\<phi> s \\<longrightarrow> \\<phi> (reps (abss s)))\n         \\<omega>;\n        pred_stream\n         (\\<lambda>s. \\<psi> s \\<longrightarrow> \\<psi> (reps (abss s)))\n         \\<omega>\\<rbrakk>\n       \\<Longrightarrow> (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n                          holds (\\<lambda>x. \\<psi> (reps x)))\n                          (smap abss \\<omega>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>holds \\<phi> \\<omega>;\n        (holds \\<phi> suntil holds \\<psi>) (stl \\<omega>);\n        \\<lbrakk>pred_stream\n                  (\\<lambda>s.\n                      \\<phi> s \\<longrightarrow> \\<phi> (reps (abss s)))\n                  (stl \\<omega>);\n         pred_stream\n          (\\<lambda>s. \\<psi> s \\<longrightarrow> \\<psi> (reps (abss s)))\n          (stl \\<omega>)\\<rbrakk>\n        \\<Longrightarrow> (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n                           holds (\\<lambda>x. \\<psi> (reps x)))\n                           (smap abss (stl \\<omega>));\n        pred_stream\n         (\\<lambda>s. \\<phi> s \\<longrightarrow> \\<phi> (reps (abss s)))\n         \\<omega>;\n        pred_stream\n         (\\<lambda>s. \\<psi> s \\<longrightarrow> \\<psi> (reps (abss s)))\n         \\<omega>\\<rbrakk>\n       \\<Longrightarrow> (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n                          holds (\\<lambda>x. \\<psi> (reps x)))\n                          (smap abss \\<omega>)", "case (step x)"], ["proof (state)\nthis:\n  holds \\<phi> x\n  (holds \\<phi> suntil holds \\<psi>) (stl x)\n  \\<lbrakk>pred_stream\n            (\\<lambda>s. \\<phi> s \\<longrightarrow> \\<phi> (reps (abss s)))\n            (stl x);\n   pred_stream\n    (\\<lambda>s. \\<psi> s \\<longrightarrow> \\<psi> (reps (abss s)))\n    (stl x)\\<rbrakk>\n  \\<Longrightarrow> (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n                     holds (\\<lambda>x. \\<psi> (reps x)))\n                     (smap abss (stl x))\n  pred_stream\n   (\\<lambda>s. \\<phi> s \\<longrightarrow> \\<phi> (reps (abss s))) x\n  pred_stream\n   (\\<lambda>s. \\<psi> s \\<longrightarrow> \\<psi> (reps (abss s))) x\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>holds \\<phi> \\<omega>;\n        (holds \\<phi> suntil holds \\<psi>) (stl \\<omega>);\n        \\<lbrakk>pred_stream\n                  (\\<lambda>s.\n                      \\<phi> s \\<longrightarrow> \\<phi> (reps (abss s)))\n                  (stl \\<omega>);\n         pred_stream\n          (\\<lambda>s. \\<psi> s \\<longrightarrow> \\<psi> (reps (abss s)))\n          (stl \\<omega>)\\<rbrakk>\n        \\<Longrightarrow> (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n                           holds (\\<lambda>x. \\<psi> (reps x)))\n                           (smap abss (stl \\<omega>));\n        pred_stream\n         (\\<lambda>s. \\<phi> s \\<longrightarrow> \\<phi> (reps (abss s)))\n         \\<omega>;\n        pred_stream\n         (\\<lambda>s. \\<psi> s \\<longrightarrow> \\<psi> (reps (abss s)))\n         \\<omega>\\<rbrakk>\n       \\<Longrightarrow> (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n                          holds (\\<lambda>x. \\<psi> (reps x)))\n                          (smap abss \\<omega>)", "have\n    \"pred_stream (\\<lambda>s. \\<phi> s \\<longrightarrow> \\<phi> (reps (abss s))) (stl x)\"\n    \"pred_stream (\\<lambda>s. \\<psi> s \\<longrightarrow> \\<psi> (reps (abss s))) (stl x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream\n     (\\<lambda>s. \\<phi> s \\<longrightarrow> \\<phi> (reps (abss s)))\n     (stl x) &&&\n    pred_stream\n     (\\<lambda>s. \\<psi> s \\<longrightarrow> \\<psi> (reps (abss s))) (stl x)", "using step.prems"], ["proof (prove)\nusing this:\n  pred_stream\n   (\\<lambda>s. \\<phi> s \\<longrightarrow> \\<phi> (reps (abss s))) x\n  pred_stream\n   (\\<lambda>s. \\<psi> s \\<longrightarrow> \\<psi> (reps (abss s))) x\n\ngoal (1 subgoal):\n 1. pred_stream\n     (\\<lambda>s. \\<phi> s \\<longrightarrow> \\<phi> (reps (abss s)))\n     (stl x) &&&\n    pred_stream\n     (\\<lambda>s. \\<psi> s \\<longrightarrow> \\<psi> (reps (abss s))) (stl x)", "apply (cases x; auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream\n     (\\<lambda>s. \\<psi> s \\<longrightarrow> \\<psi> (reps (abss s))) (stl x)", "using step.prems"], ["proof (prove)\nusing this:\n  pred_stream\n   (\\<lambda>s. \\<phi> s \\<longrightarrow> \\<phi> (reps (abss s))) x\n  pred_stream\n   (\\<lambda>s. \\<psi> s \\<longrightarrow> \\<psi> (reps (abss s))) x\n\ngoal (1 subgoal):\n 1. pred_stream\n     (\\<lambda>s. \\<psi> s \\<longrightarrow> \\<psi> (reps (abss s))) (stl x)", "apply (cases x; auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  pred_stream\n   (\\<lambda>s. \\<phi> s \\<longrightarrow> \\<phi> (reps (abss s))) (stl x)\n  pred_stream\n   (\\<lambda>s. \\<psi> s \\<longrightarrow> \\<psi> (reps (abss s))) (stl x)\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>holds \\<phi> \\<omega>;\n        (holds \\<phi> suntil holds \\<psi>) (stl \\<omega>);\n        \\<lbrakk>pred_stream\n                  (\\<lambda>s.\n                      \\<phi> s \\<longrightarrow> \\<phi> (reps (abss s)))\n                  (stl \\<omega>);\n         pred_stream\n          (\\<lambda>s. \\<psi> s \\<longrightarrow> \\<psi> (reps (abss s)))\n          (stl \\<omega>)\\<rbrakk>\n        \\<Longrightarrow> (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n                           holds (\\<lambda>x. \\<psi> (reps x)))\n                           (smap abss (stl \\<omega>));\n        pred_stream\n         (\\<lambda>s. \\<phi> s \\<longrightarrow> \\<phi> (reps (abss s)))\n         \\<omega>;\n        pred_stream\n         (\\<lambda>s. \\<psi> s \\<longrightarrow> \\<psi> (reps (abss s)))\n         \\<omega>\\<rbrakk>\n       \\<Longrightarrow> (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n                          holds (\\<lambda>x. \\<psi> (reps x)))\n                          (smap abss \\<omega>)", "with step"], ["proof (chain)\npicking this:\n  holds \\<phi> x\n  (holds \\<phi> suntil holds \\<psi>) (stl x)\n  \\<lbrakk>pred_stream\n            (\\<lambda>s. \\<phi> s \\<longrightarrow> \\<phi> (reps (abss s)))\n            (stl x);\n   pred_stream\n    (\\<lambda>s. \\<psi> s \\<longrightarrow> \\<psi> (reps (abss s)))\n    (stl x)\\<rbrakk>\n  \\<Longrightarrow> (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n                     holds (\\<lambda>x. \\<psi> (reps x)))\n                     (smap abss (stl x))\n  pred_stream\n   (\\<lambda>s. \\<phi> s \\<longrightarrow> \\<phi> (reps (abss s))) x\n  pred_stream\n   (\\<lambda>s. \\<psi> s \\<longrightarrow> \\<psi> (reps (abss s))) x\n  pred_stream\n   (\\<lambda>s. \\<phi> s \\<longrightarrow> \\<phi> (reps (abss s))) (stl x)\n  pred_stream\n   (\\<lambda>s. \\<psi> s \\<longrightarrow> \\<psi> (reps (abss s))) (stl x)", "show ?case"], ["proof (prove)\nusing this:\n  holds \\<phi> x\n  (holds \\<phi> suntil holds \\<psi>) (stl x)\n  \\<lbrakk>pred_stream\n            (\\<lambda>s. \\<phi> s \\<longrightarrow> \\<phi> (reps (abss s)))\n            (stl x);\n   pred_stream\n    (\\<lambda>s. \\<psi> s \\<longrightarrow> \\<psi> (reps (abss s)))\n    (stl x)\\<rbrakk>\n  \\<Longrightarrow> (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n                     holds (\\<lambda>x. \\<psi> (reps x)))\n                     (smap abss (stl x))\n  pred_stream\n   (\\<lambda>s. \\<phi> s \\<longrightarrow> \\<phi> (reps (abss s))) x\n  pred_stream\n   (\\<lambda>s. \\<psi> s \\<longrightarrow> \\<psi> (reps (abss s))) x\n  pred_stream\n   (\\<lambda>s. \\<phi> s \\<longrightarrow> \\<phi> (reps (abss s))) (stl x)\n  pred_stream\n   (\\<lambda>s. \\<psi> s \\<longrightarrow> \\<psi> (reps (abss s))) (stl x)\n\ngoal (1 subgoal):\n 1. (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n     holds (\\<lambda>x. \\<psi> (reps x)))\n     (smap abss x)", "by (auto intro: suntil.step simp: stream.pred_set)"], ["proof (state)\nthis:\n  (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n   holds (\\<lambda>x. \\<psi> (reps x)))\n   (smap abss x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma region_compatible_suntil:\n  assumes \"pred_stream (\\<lambda> s. \\<phi> (reps (abss s)) \\<longleftrightarrow> \\<phi> s) x\"\n      and \"pred_stream (\\<lambda> s. \\<psi> (reps (abss s)) \\<longleftrightarrow> \\<psi> s) x\"\n  shows \"(holds (\\<lambda>x. \\<phi> (reps x)) suntil holds (\\<lambda>x. \\<psi> (reps x))) (smap abss x)\n     \\<longleftrightarrow> (holds \\<phi> suntil holds \\<psi>) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n     holds (\\<lambda>x. \\<psi> (reps x)))\n     (smap abss x) =\n    (holds \\<phi> suntil holds \\<psi>) x", "using assms"], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s) x\n  pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s) x\n\ngoal (1 subgoal):\n 1. (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n     holds (\\<lambda>x. \\<psi> (reps x)))\n     (smap abss x) =\n    (holds \\<phi> suntil holds \\<psi>) x", "using assms region_compatible_suntil1 region_compatible_suntil2"], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s) x\n  pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s) x\n  pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s) x\n  pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s) x\n  \\<lbrakk>(holds (\\<lambda>x. ?\\<phi> (reps x)) suntil\n            holds (\\<lambda>x. ?\\<psi> (reps x)))\n            (smap abss ?x);\n   pred_stream\n    (\\<lambda>s. ?\\<phi> (reps (abss s)) \\<longrightarrow> ?\\<phi> s) ?x;\n   pred_stream\n    (\\<lambda>s. ?\\<psi> (reps (abss s)) \\<longrightarrow> ?\\<psi> s)\n    ?x\\<rbrakk>\n  \\<Longrightarrow> (holds ?\\<phi> suntil holds ?\\<psi>) ?x\n  \\<lbrakk>(holds ?\\<phi> suntil holds ?\\<psi>) ?x;\n   pred_stream\n    (\\<lambda>s. ?\\<phi> s \\<longrightarrow> ?\\<phi> (reps (abss s))) ?x;\n   pred_stream\n    (\\<lambda>s. ?\\<psi> s \\<longrightarrow> ?\\<psi> (reps (abss s)))\n    ?x\\<rbrakk>\n  \\<Longrightarrow> (holds (\\<lambda>x. ?\\<phi> (reps x)) suntil\n                     holds (\\<lambda>x. ?\\<psi> (reps x)))\n                     (smap abss ?x)\n\ngoal (1 subgoal):\n 1. (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n     holds (\\<lambda>x. \\<psi> (reps x)))\n     (smap abss x) =\n    (holds \\<phi> suntil holds \\<psi>) x", "unfolding stream.pred_set"], ["proof (prove)\nusing this:\n  \\<forall>s\\<in>sset x. \\<phi> (reps (abss s)) = \\<phi> s\n  \\<forall>s\\<in>sset x. \\<psi> (reps (abss s)) = \\<psi> s\n  \\<forall>s\\<in>sset x. \\<phi> (reps (abss s)) = \\<phi> s\n  \\<forall>s\\<in>sset x. \\<psi> (reps (abss s)) = \\<psi> s\n  \\<lbrakk>(holds (\\<lambda>x. ?\\<phi> (reps x)) suntil\n            holds (\\<lambda>x. ?\\<psi> (reps x)))\n            (smap abss ?x);\n   \\<forall>s\\<in>sset ?x.\n      ?\\<phi> (reps (abss s)) \\<longrightarrow> ?\\<phi> s;\n   \\<forall>s\\<in>sset ?x.\n      ?\\<psi> (reps (abss s)) \\<longrightarrow> ?\\<psi> s\\<rbrakk>\n  \\<Longrightarrow> (holds ?\\<phi> suntil holds ?\\<psi>) ?x\n  \\<lbrakk>(holds ?\\<phi> suntil holds ?\\<psi>) ?x;\n   \\<forall>s\\<in>sset ?x.\n      ?\\<phi> s \\<longrightarrow> ?\\<phi> (reps (abss s));\n   \\<forall>s\\<in>sset ?x.\n      ?\\<psi> s \\<longrightarrow> ?\\<psi> (reps (abss s))\\<rbrakk>\n  \\<Longrightarrow> (holds (\\<lambda>x. ?\\<phi> (reps x)) suntil\n                     holds (\\<lambda>x. ?\\<psi> (reps x)))\n                     (smap abss ?x)\n\ngoal (1 subgoal):\n 1. (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n     holds (\\<lambda>x. \\<psi> (reps x)))\n     (smap abss x) =\n    (holds \\<phi> suntil holds \\<psi>) x", "by blast"], ["", "lemma reps_abss_S:\n  assumes \"reps (abss s) \\<in> S\"\n  shows \"s \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> S", "by (simp add: S_reps_\\<S> \\<S>_abss_S assms)"], ["", "lemma measurable_sset[measurable (raw)]:\n  assumes f[measurable]: \"f \\<in> N \\<rightarrow>\\<^sub>M stream_space M\" and P[measurable]: \"Measurable.pred M P\"\n  shows \"Measurable.pred N (\\<lambda>x. \\<forall>s\\<in>sset (f x). P s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Measurable.pred N (\\<lambda>x. \\<forall>s\\<in>sset (f x). P s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Measurable.pred N (\\<lambda>x. \\<forall>s\\<in>sset (f x). P s)", "have *: \"(\\<lambda>x. \\<forall>s\\<in>sset (f x). P s) = (\\<lambda>x. \\<forall>i. P (f x !! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<forall>s\\<in>sset (f x). P s) =\n    (\\<lambda>x. \\<forall>i. P (f x !! i))", "by (simp add: sset_range)"], ["proof (state)\nthis:\n  (\\<lambda>x. \\<forall>s\\<in>sset (f x). P s) =\n  (\\<lambda>x. \\<forall>i. P (f x !! i))\n\ngoal (1 subgoal):\n 1. Measurable.pred N (\\<lambda>x. \\<forall>s\\<in>sset (f x). P s)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Measurable.pred N (\\<lambda>x. \\<forall>s\\<in>sset (f x). P s)", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. Measurable.pred N (\\<lambda>x. \\<forall>i. P (f x !! i))", "by measurable"], ["proof (state)\nthis:\n  Measurable.pred N (\\<lambda>x. \\<forall>s\\<in>sset (f x). P s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_measure_eq_repcs''_new:\n  notes in_space_UNIV[measurable]\n  fixes cfg \\<phi> \\<psi> s\n  defines \"cfg' \\<equiv> repcs s cfg\"\n  defines \"\\<phi>' \\<equiv> absp \\<phi>\" and \"\\<psi>' \\<equiv> absp \\<psi>\"\n  assumes s: \"abss s = state cfg\"\n  assumes valid: \"cfg \\<in> R_G.valid_cfg\"\n  assumes valid': \"cfg' \\<in> valid_cfg\"\n  assumes equiv_\\<phi>: \"\\<And> x. pred_stream (\\<lambda> s. s \\<in> S) x\n                    \\<Longrightarrow> pred_stream (\\<lambda> s. \\<phi> (reps (abss s)) \\<longleftrightarrow> \\<phi> s) (state cfg' ## x)\"\n    and equiv_\\<psi>: \"\\<And> x. pred_stream (\\<lambda> s. s \\<in> S) x\n                    \\<Longrightarrow> pred_stream (\\<lambda> s. \\<psi> (reps (abss s)) \\<longleftrightarrow> \\<psi> s) (state cfg' ## x)\"\n  shows\n    \"emeasure (R_G.T cfg)  {x\\<in>space R_G.St. (holds \\<phi>' suntil holds \\<psi>') (state cfg  ## x)} =\n     emeasure (MDP.T cfg') {x\\<in>space MDP.St. (holds \\<phi>  suntil holds \\<psi>)  (state cfg' ## x)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (R_G.T cfg)\n     {x \\<in> space R_G.St.\n      (holds \\<phi>' suntil holds \\<psi>') (state cfg ## x)} =\n    emeasure (MDP.T cfg')\n     {x \\<in> space MDP.St.\n      (holds \\<phi> suntil holds \\<psi>) (state cfg' ## x)}", "unfolding cfg'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (R_G.T cfg)\n     {x \\<in> space R_G.St.\n      (holds \\<phi>' suntil holds \\<psi>') (state cfg ## x)} =\n    emeasure (MDP.T (repcs s cfg))\n     {x \\<in> space MDP.St.\n      (holds \\<phi> suntil holds \\<psi>) (state (repcs s cfg) ## x)}", "apply (rule path_measure_eq_repcs1_new[where P = \"pred_stream (\\<lambda> s. s \\<in> \\<S>)\" and Q = \"pred_stream (\\<lambda> s. s \\<in> S)\"])"], ["proof (prove)\ngoal (10 subgoals):\n 1. abss s = state cfg\n 2. cfg \\<in> R_G.valid_cfg\n 3. {x \\<in> space R_G.St.\n     (holds \\<phi>' suntil holds \\<psi>') (state cfg ## x)}\n    \\<in> sets R_G.St\n 4. {x \\<in> space MDP.St.\n     (holds \\<phi> suntil holds \\<psi>) (state (repcs s cfg) ## x)}\n    \\<in> sets MDP.St\n 5. almost_everywhere (R_G.T cfg) (pred_stream (\\<lambda>s. s \\<in> \\<S>))\n 6. almost_everywhere (MDP.T (repcs s cfg))\n     (pred_stream (\\<lambda>s. s \\<in> S))\n 7. Measurable.pred R_G.St (pred_stream (\\<lambda>s. s \\<in> \\<S>))\n 8. Measurable.pred MDP.St (pred_stream (\\<lambda>s. s \\<in> S))\n 9. \\<And>x y.\n       \\<lbrakk>pred_stream (\\<lambda>s. s \\<in> \\<S>) x; smap abss y = x;\n        x \\<in> {x \\<in> space R_G.St.\n                 (holds \\<phi>' suntil holds \\<psi>')\n                  (state cfg ## x)}\\<rbrakk>\n       \\<Longrightarrow> y \\<in> {x \\<in> space MDP.St.\n                                  (holds \\<phi> suntil holds \\<psi>)\n                                   (state (repcs s cfg) ## x)} \\<and>\n                         pred_stream (\\<lambda>s. s \\<in> S) y\n 10. \\<And>x y.\n        \\<lbrakk>pred_stream (\\<lambda>s. s \\<in> S) y; smap abss y = x;\n         y \\<in> {x \\<in> space MDP.St.\n                  (holds \\<phi> suntil holds \\<psi>)\n                   (state (repcs s cfg) ## x)}\\<rbrakk>\n        \\<Longrightarrow> x \\<in> {x \\<in> space R_G.St.\n                                   (holds \\<phi>' suntil holds \\<psi>')\n                                    (state cfg ## x)} \\<and>\n                          pred_stream (\\<lambda>s. s \\<in> \\<S>) x", "apply fact"], ["proof (prove)\ngoal (9 subgoals):\n 1. cfg \\<in> R_G.valid_cfg\n 2. {x \\<in> space R_G.St.\n     (holds \\<phi>' suntil holds \\<psi>') (state cfg ## x)}\n    \\<in> sets R_G.St\n 3. {x \\<in> space MDP.St.\n     (holds \\<phi> suntil holds \\<psi>) (state (repcs s cfg) ## x)}\n    \\<in> sets MDP.St\n 4. almost_everywhere (R_G.T cfg) (pred_stream (\\<lambda>s. s \\<in> \\<S>))\n 5. almost_everywhere (MDP.T (repcs s cfg))\n     (pred_stream (\\<lambda>s. s \\<in> S))\n 6. Measurable.pred R_G.St (pred_stream (\\<lambda>s. s \\<in> \\<S>))\n 7. Measurable.pred MDP.St (pred_stream (\\<lambda>s. s \\<in> S))\n 8. \\<And>x y.\n       \\<lbrakk>pred_stream (\\<lambda>s. s \\<in> \\<S>) x; smap abss y = x;\n        x \\<in> {x \\<in> space R_G.St.\n                 (holds \\<phi>' suntil holds \\<psi>')\n                  (state cfg ## x)}\\<rbrakk>\n       \\<Longrightarrow> y \\<in> {x \\<in> space MDP.St.\n                                  (holds \\<phi> suntil holds \\<psi>)\n                                   (state (repcs s cfg) ## x)} \\<and>\n                         pred_stream (\\<lambda>s. s \\<in> S) y\n 9. \\<And>x y.\n       \\<lbrakk>pred_stream (\\<lambda>s. s \\<in> S) y; smap abss y = x;\n        y \\<in> {x \\<in> space MDP.St.\n                 (holds \\<phi> suntil holds \\<psi>)\n                  (state (repcs s cfg) ## x)}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {x \\<in> space R_G.St.\n                                  (holds \\<phi>' suntil holds \\<psi>')\n                                   (state cfg ## x)} \\<and>\n                         pred_stream (\\<lambda>s. s \\<in> \\<S>) x", "apply fact"], ["proof (prove)\ngoal (8 subgoals):\n 1. {x \\<in> space R_G.St.\n     (holds \\<phi>' suntil holds \\<psi>') (state cfg ## x)}\n    \\<in> sets R_G.St\n 2. {x \\<in> space MDP.St.\n     (holds \\<phi> suntil holds \\<psi>) (state (repcs s cfg) ## x)}\n    \\<in> sets MDP.St\n 3. almost_everywhere (R_G.T cfg) (pred_stream (\\<lambda>s. s \\<in> \\<S>))\n 4. almost_everywhere (MDP.T (repcs s cfg))\n     (pred_stream (\\<lambda>s. s \\<in> S))\n 5. Measurable.pred R_G.St (pred_stream (\\<lambda>s. s \\<in> \\<S>))\n 6. Measurable.pred MDP.St (pred_stream (\\<lambda>s. s \\<in> S))\n 7. \\<And>x y.\n       \\<lbrakk>pred_stream (\\<lambda>s. s \\<in> \\<S>) x; smap abss y = x;\n        x \\<in> {x \\<in> space R_G.St.\n                 (holds \\<phi>' suntil holds \\<psi>')\n                  (state cfg ## x)}\\<rbrakk>\n       \\<Longrightarrow> y \\<in> {x \\<in> space MDP.St.\n                                  (holds \\<phi> suntil holds \\<psi>)\n                                   (state (repcs s cfg) ## x)} \\<and>\n                         pred_stream (\\<lambda>s. s \\<in> S) y\n 8. \\<And>x y.\n       \\<lbrakk>pred_stream (\\<lambda>s. s \\<in> S) y; smap abss y = x;\n        y \\<in> {x \\<in> space MDP.St.\n                 (holds \\<phi> suntil holds \\<psi>)\n                  (state (repcs s cfg) ## x)}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {x \\<in> space R_G.St.\n                                  (holds \\<phi>' suntil holds \\<psi>')\n                                   (state cfg ## x)} \\<and>\n                         pred_stream (\\<lambda>s. s \\<in> \\<S>) x", "apply measurable"], ["proof (prove)\ngoal (6 subgoals):\n 1. almost_everywhere (R_G.T cfg) (pred_stream (\\<lambda>s. s \\<in> \\<S>))\n 2. almost_everywhere (MDP.T (repcs s cfg))\n     (pred_stream (\\<lambda>s. s \\<in> S))\n 3. Measurable.pred R_G.St (pred_stream (\\<lambda>s. s \\<in> \\<S>))\n 4. Measurable.pred MDP.St (pred_stream (\\<lambda>s. s \\<in> S))\n 5. \\<And>x y.\n       \\<lbrakk>pred_stream (\\<lambda>s. s \\<in> \\<S>) x; smap abss y = x;\n        x \\<in> {x \\<in> space R_G.St.\n                 (holds \\<phi>' suntil holds \\<psi>')\n                  (state cfg ## x)}\\<rbrakk>\n       \\<Longrightarrow> y \\<in> {x \\<in> space MDP.St.\n                                  (holds \\<phi> suntil holds \\<psi>)\n                                   (state (repcs s cfg) ## x)} \\<and>\n                         pred_stream (\\<lambda>s. s \\<in> S) y\n 6. \\<And>x y.\n       \\<lbrakk>pred_stream (\\<lambda>s. s \\<in> S) y; smap abss y = x;\n        y \\<in> {x \\<in> space MDP.St.\n                 (holds \\<phi> suntil holds \\<psi>)\n                  (state (repcs s cfg) ## x)}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {x \\<in> space R_G.St.\n                                  (holds \\<phi>' suntil holds \\<psi>')\n                                   (state cfg ## x)} \\<and>\n                         pred_stream (\\<lambda>s. s \\<in> \\<S>) x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_everywhere (R_G.T cfg) (pred_stream (\\<lambda>s. s \\<in> \\<S>))", "unfolding R_G.T_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_everywhere (distr (MDP.MC.T cfg) R_G.St (smap state))\n     (pred_stream (\\<lambda>s. s \\<in> \\<S>))", "apply (subst AE_distr_iff)"], ["proof (prove)\ngoal (3 subgoals):\n 1. MDP.MC.T.random_variable cfg R_G.St (smap state)\n 2. {x \\<in> space R_G.St. pred_stream (\\<lambda>s. s \\<in> \\<S>) x}\n    \\<in> sets R_G.St\n 3. AE x in MDP.MC.T\n             cfg. pred_stream (\\<lambda>s. s \\<in> \\<S>) (smap state x)", "apply (auto; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {x \\<in> space R_G.St. pred_stream (\\<lambda>s. s \\<in> \\<S>) x}\n    \\<in> sets R_G.St\n 2. AE x in MDP.MC.T\n             cfg. pred_stream (\\<lambda>s. s \\<in> \\<S>) (smap state x)", "apply (auto simp: stream.pred_set; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE x in MDP.MC.T\n             cfg. pred_stream (\\<lambda>s. s \\<in> \\<S>) (smap state x)", "apply (rule AE_mp[OF MDP.MC.AE_T_enabled AE_I2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (MDP.MC.T cfg) \\<Longrightarrow>\n       MDP.MC.enabled cfg x \\<longrightarrow>\n       pred_stream (\\<lambda>s. s \\<in> \\<S>) (smap state x)", "using R_G.pred_stream_cfg_on[OF valid]"], ["proof (prove)\nusing this:\n  MDP.MC.enabled cfg ?xs \\<Longrightarrow>\n  pred_stream\n   (\\<lambda>cfg.\n       state cfg \\<in> \\<S> \\<and> cfg \\<in> R_G.cfg_on (state cfg))\n   ?xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (MDP.MC.T cfg) \\<Longrightarrow>\n       MDP.MC.enabled cfg x \\<longrightarrow>\n       pred_stream (\\<lambda>s. s \\<in> \\<S>) (smap state x)", "by (auto simp: stream.pred_set)"], ["proof (prove)\ngoal (5 subgoals):\n 1. almost_everywhere (MDP.T (repcs s cfg))\n     (pred_stream (\\<lambda>s. s \\<in> S))\n 2. Measurable.pred R_G.St (pred_stream (\\<lambda>s. s \\<in> \\<S>))\n 3. Measurable.pred MDP.St (pred_stream (\\<lambda>s. s \\<in> S))\n 4. \\<And>x y.\n       \\<lbrakk>pred_stream (\\<lambda>s. s \\<in> \\<S>) x; smap abss y = x;\n        x \\<in> {x \\<in> space R_G.St.\n                 (holds \\<phi>' suntil holds \\<psi>')\n                  (state cfg ## x)}\\<rbrakk>\n       \\<Longrightarrow> y \\<in> {x \\<in> space MDP.St.\n                                  (holds \\<phi> suntil holds \\<psi>)\n                                   (state (repcs s cfg) ## x)} \\<and>\n                         pred_stream (\\<lambda>s. s \\<in> S) y\n 5. \\<And>x y.\n       \\<lbrakk>pred_stream (\\<lambda>s. s \\<in> S) y; smap abss y = x;\n        y \\<in> {x \\<in> space MDP.St.\n                 (holds \\<phi> suntil holds \\<psi>)\n                  (state (repcs s cfg) ## x)}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {x \\<in> space R_G.St.\n                                  (holds \\<phi>' suntil holds \\<psi>')\n                                   (state cfg ## x)} \\<and>\n                         pred_stream (\\<lambda>s. s \\<in> \\<S>) x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_everywhere (MDP.T (repcs s cfg))\n     (pred_stream (\\<lambda>s. s \\<in> S))", "unfolding MDP.T_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_everywhere (distr (MDP.MC.T (repcs s cfg)) MDP.St (smap state))\n     (pred_stream (\\<lambda>s. s \\<in> S))", "apply (subst AE_distr_iff)"], ["proof (prove)\ngoal (3 subgoals):\n 1. MDP.MC.T.random_variable (repcs s cfg) MDP.St (smap state)\n 2. {x \\<in> space MDP.St. pred_stream (\\<lambda>s. s \\<in> S) x}\n    \\<in> sets MDP.St\n 3. AE x in MDP.MC.T\n             (repcs s\n               cfg). pred_stream (\\<lambda>s. s \\<in> S) (smap state x)", "apply (auto; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {x \\<in> space MDP.St. pred_stream (\\<lambda>s. s \\<in> S) x}\n    \\<in> sets MDP.St\n 2. AE x in MDP.MC.T\n             (repcs s\n               cfg). pred_stream (\\<lambda>s. s \\<in> S) (smap state x)", "apply (auto simp: stream.pred_set; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE x in MDP.MC.T\n             (repcs s\n               cfg). pred_stream (\\<lambda>s. s \\<in> S) (smap state x)", "apply (rule AE_mp[OF MDP.MC.AE_T_enabled AE_I2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (MDP.MC.T (repcs s cfg)) \\<Longrightarrow>\n       MDP.MC.enabled (repcs s cfg) x \\<longrightarrow>\n       pred_stream (\\<lambda>s. s \\<in> S) (smap state x)", "using MDP.pred_stream_cfg_on[OF valid', unfolded cfg'_def]"], ["proof (prove)\nusing this:\n  MDP.MC.enabled (repcs s cfg) ?xs \\<Longrightarrow>\n  pred_stream\n   (\\<lambda>cfg. state cfg \\<in> S \\<and> cfg \\<in> MDP.cfg_on (state cfg))\n   ?xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (MDP.MC.T (repcs s cfg)) \\<Longrightarrow>\n       MDP.MC.enabled (repcs s cfg) x \\<longrightarrow>\n       pred_stream (\\<lambda>s. s \\<in> S) (smap state x)", "by (auto simp: stream.pred_set)"], ["proof (prove)\ngoal (4 subgoals):\n 1. Measurable.pred R_G.St (pred_stream (\\<lambda>s. s \\<in> \\<S>))\n 2. Measurable.pred MDP.St (pred_stream (\\<lambda>s. s \\<in> S))\n 3. \\<And>x y.\n       \\<lbrakk>pred_stream (\\<lambda>s. s \\<in> \\<S>) x; smap abss y = x;\n        x \\<in> {x \\<in> space R_G.St.\n                 (holds \\<phi>' suntil holds \\<psi>')\n                  (state cfg ## x)}\\<rbrakk>\n       \\<Longrightarrow> y \\<in> {x \\<in> space MDP.St.\n                                  (holds \\<phi> suntil holds \\<psi>)\n                                   (state (repcs s cfg) ## x)} \\<and>\n                         pred_stream (\\<lambda>s. s \\<in> S) y\n 4. \\<And>x y.\n       \\<lbrakk>pred_stream (\\<lambda>s. s \\<in> S) y; smap abss y = x;\n        y \\<in> {x \\<in> space MDP.St.\n                 (holds \\<phi> suntil holds \\<psi>)\n                  (state (repcs s cfg) ## x)}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {x \\<in> space R_G.St.\n                                  (holds \\<phi>' suntil holds \\<psi>')\n                                   (state cfg ## x)} \\<and>\n                         pred_stream (\\<lambda>s. s \\<in> \\<S>) x", "apply measurable"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>pred_stream (\\<lambda>s. s \\<in> \\<S>) x; smap abss y = x;\n        x \\<in> {x \\<in> space R_G.St.\n                 (holds \\<phi>' suntil holds \\<psi>')\n                  (state cfg ## x)}\\<rbrakk>\n       \\<Longrightarrow> y \\<in> {x \\<in> space MDP.St.\n                                  (holds \\<phi> suntil holds \\<psi>)\n                                   (state (repcs s cfg) ## x)} \\<and>\n                         pred_stream (\\<lambda>s. s \\<in> S) y\n 2. \\<And>x y.\n       \\<lbrakk>pred_stream (\\<lambda>s. s \\<in> S) y; smap abss y = x;\n        y \\<in> {x \\<in> space MDP.St.\n                 (holds \\<phi> suntil holds \\<psi>)\n                  (state (repcs s cfg) ## x)}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {x \\<in> space R_G.St.\n                                  (holds \\<phi>' suntil holds \\<psi>')\n                                   (state cfg ## x)} \\<and>\n                         pred_stream (\\<lambda>s. s \\<in> \\<S>) x", "subgoal premises prems for ys xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> {x \\<in> space MDP.St.\n              (holds \\<phi> suntil holds \\<psi>)\n               (state (repcs s cfg) ## x)} \\<and>\n    pred_stream (\\<lambda>s. s \\<in> S) xs", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. xs \\<in> space MDP.St\n 2. (holds \\<phi> suntil holds \\<psi>) (state (repcs s cfg) ## xs)\n 3. pred_stream (\\<lambda>s. s \\<in> S) xs", "apply measurable"], ["proof (prove)\ngoal (2 subgoals):\n 1. (holds \\<phi> suntil holds \\<psi>) (state (repcs s cfg) ## xs)\n 2. pred_stream (\\<lambda>s. s \\<in> S) xs", "unfolding \\<phi>'_def \\<psi>'_def absp_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. (holds \\<phi> suntil holds \\<psi>) (state (repcs s cfg) ## xs)\n 2. pred_stream (\\<lambda>s. s \\<in> S) xs", "apply (subst region_compatible_suntil[symmetric])"], ["proof (prove)\ngoal (4 subgoals):\n 1. pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s)\n     (state (repcs s cfg) ## xs)\n 2. pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s)\n     (state (repcs s cfg) ## xs)\n 3. (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n     holds (\\<lambda>x. \\<psi> (reps x)))\n     (smap abss (state (repcs s cfg) ## xs))\n 4. pred_stream (\\<lambda>s. s \\<in> S) xs", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s)\n     (state (repcs s cfg) ## xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s)\n     (state (repcs s cfg) ## xs)", "from prems"], ["proof (chain)\npicking this:\n  pred_stream (\\<lambda>s. s \\<in> \\<S>) ys\n  smap abss xs = ys\n  ys \\<in> {x \\<in> space R_G.St.\n            (holds \\<phi>' suntil holds \\<psi>') (state cfg ## x)}", "have \"pred_stream (\\<lambda>s. s \\<in> S) xs\""], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>s. s \\<in> \\<S>) ys\n  smap abss xs = ys\n  ys \\<in> {x \\<in> space R_G.St.\n            (holds \\<phi>' suntil holds \\<psi>') (state cfg ## x)}\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>s. s \\<in> S) xs", "using \\<S>_abss_S"], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>s. s \\<in> \\<S>) ys\n  smap abss xs = ys\n  ys \\<in> {x \\<in> space R_G.St.\n            (holds \\<phi>' suntil holds \\<psi>') (state cfg ## x)}\n  abss ?s \\<in> \\<S> \\<Longrightarrow> ?s \\<in> S\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>s. s \\<in> S) xs", "by (auto simp: stream.pred_set)"], ["proof (state)\nthis:\n  pred_stream (\\<lambda>s. s \\<in> S) xs\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s)\n     (state (repcs s cfg) ## xs)", "with equiv_\\<phi>"], ["proof (chain)\npicking this:\n  pred_stream (\\<lambda>s. s \\<in> S) ?x5 \\<Longrightarrow>\n  pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s)\n   (state cfg' ## ?x5)\n  pred_stream (\\<lambda>s. s \\<in> S) xs", "show ?thesis"], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>s. s \\<in> S) ?x5 \\<Longrightarrow>\n  pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s)\n   (state cfg' ## ?x5)\n  pred_stream (\\<lambda>s. s \\<in> S) xs\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s)\n     (state (repcs s cfg) ## xs)", "by (simp add: cfg'_def)"], ["proof (state)\nthis:\n  pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s)\n   (state (repcs s cfg) ## xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal (3 subgoals):\n 1. pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s)\n     (state (repcs s cfg) ## xs)\n 2. (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n     holds (\\<lambda>x. \\<psi> (reps x)))\n     (smap abss (state (repcs s cfg) ## xs))\n 3. pred_stream (\\<lambda>s. s \\<in> S) xs", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s)\n     (state (repcs s cfg) ## xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s)\n     (state (repcs s cfg) ## xs)", "from prems"], ["proof (chain)\npicking this:\n  pred_stream (\\<lambda>s. s \\<in> \\<S>) ys\n  smap abss xs = ys\n  ys \\<in> {x \\<in> space R_G.St.\n            (holds \\<phi>' suntil holds \\<psi>') (state cfg ## x)}", "have \"pred_stream (\\<lambda>s. s \\<in> S) xs\""], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>s. s \\<in> \\<S>) ys\n  smap abss xs = ys\n  ys \\<in> {x \\<in> space R_G.St.\n            (holds \\<phi>' suntil holds \\<psi>') (state cfg ## x)}\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>s. s \\<in> S) xs", "using \\<S>_abss_S"], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>s. s \\<in> \\<S>) ys\n  smap abss xs = ys\n  ys \\<in> {x \\<in> space R_G.St.\n            (holds \\<phi>' suntil holds \\<psi>') (state cfg ## x)}\n  abss ?s \\<in> \\<S> \\<Longrightarrow> ?s \\<in> S\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>s. s \\<in> S) xs", "by (auto simp: stream.pred_set)"], ["proof (state)\nthis:\n  pred_stream (\\<lambda>s. s \\<in> S) xs\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s)\n     (state (repcs s cfg) ## xs)", "with equiv_\\<psi>"], ["proof (chain)\npicking this:\n  pred_stream (\\<lambda>s. s \\<in> S) ?x5 \\<Longrightarrow>\n  pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s)\n   (state cfg' ## ?x5)\n  pred_stream (\\<lambda>s. s \\<in> S) xs", "show ?thesis"], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>s. s \\<in> S) ?x5 \\<Longrightarrow>\n  pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s)\n   (state cfg' ## ?x5)\n  pred_stream (\\<lambda>s. s \\<in> S) xs\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s)\n     (state (repcs s cfg) ## xs)", "by (simp add: cfg'_def)"], ["proof (state)\nthis:\n  pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s)\n   (state (repcs s cfg) ## xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal (2 subgoals):\n 1. (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n     holds (\\<lambda>x. \\<psi> (reps x)))\n     (smap abss (state (repcs s cfg) ## xs))\n 2. pred_stream (\\<lambda>s. s \\<in> S) xs", "using valid prems"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  pred_stream (\\<lambda>s. s \\<in> \\<S>) ys\n  smap abss xs = ys\n  ys \\<in> {x \\<in> space R_G.St.\n            (holds \\<phi>' suntil holds \\<psi>') (state cfg ## x)}\n\ngoal (2 subgoals):\n 1. (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n     holds (\\<lambda>x. \\<psi> (reps x)))\n     (smap abss (state (repcs s cfg) ## xs))\n 2. pred_stream (\\<lambda>s. s \\<in> S) xs", "apply (auto simp: s comp_def \\<phi>'_def \\<psi>'_def absp_def dest: R_G.valid_cfg_state_in_S)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cfg \\<in> R_G.valid_cfg; ys = smap abss xs;\n     pred_stream (\\<lambda>x. abss x \\<in> \\<S>) xs;\n     smap abss xs \\<in> space R_G.St;\n     (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n      holds (\\<lambda>x. \\<psi> (reps x)))\n      (state cfg ## smap abss xs)\\<rbrakk>\n    \\<Longrightarrow> pred_stream (\\<lambda>s. s \\<in> S) xs", "apply (auto simp: stream.pred_set intro: \\<S>_abss_S dest: R_G.valid_cfg_state_in_S)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>pred_stream (\\<lambda>s. s \\<in> S) y; smap abss y = x;\n        y \\<in> {x \\<in> space MDP.St.\n                 (holds \\<phi> suntil holds \\<psi>)\n                  (state (repcs s cfg) ## x)}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {x \\<in> space R_G.St.\n                                  (holds \\<phi>' suntil holds \\<psi>')\n                                   (state cfg ## x)} \\<and>\n                         pred_stream (\\<lambda>s. s \\<in> \\<S>) x", "subgoal premises prems for ys xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. ys \\<in> {x \\<in> space R_G.St.\n              (holds \\<phi>' suntil holds \\<psi>') (state cfg ## x)} \\<and>\n    pred_stream (\\<lambda>s. s \\<in> \\<S>) ys", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. ys \\<in> space R_G.St\n 2. (holds \\<phi>' suntil holds \\<psi>') (state cfg ## ys)\n 3. pred_stream (\\<lambda>s. s \\<in> \\<S>) ys", "using prems"], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>s. s \\<in> S) xs\n  smap abss xs = ys\n  xs \\<in> {x \\<in> space MDP.St.\n            (holds \\<phi> suntil holds \\<psi>) (state (repcs s cfg) ## x)}\n\ngoal (3 subgoals):\n 1. ys \\<in> space R_G.St\n 2. (holds \\<phi>' suntil holds \\<psi>') (state cfg ## ys)\n 3. pred_stream (\\<lambda>s. s \\<in> \\<S>) ys", "apply (auto simp: stream.pred_set \\<S>_abss_S; measurable; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (holds \\<phi>' suntil holds \\<psi>') (state cfg ## ys)\n 2. pred_stream (\\<lambda>s. s \\<in> \\<S>) ys", "using prems"], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>s. s \\<in> S) xs\n  smap abss xs = ys\n  xs \\<in> {x \\<in> space MDP.St.\n            (holds \\<phi> suntil holds \\<psi>) (state (repcs s cfg) ## x)}\n\ngoal (2 subgoals):\n 1. (holds \\<phi>' suntil holds \\<psi>') (state cfg ## ys)\n 2. pred_stream (\\<lambda>s. s \\<in> \\<S>) ys", "unfolding \\<phi>'_def \\<psi>'_def absp_def comp_def"], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>s. s \\<in> S) xs\n  smap abss xs = ys\n  xs \\<in> {x \\<in> space MDP.St.\n            (holds \\<phi> suntil holds \\<psi>) (state (repcs s cfg) ## x)}\n\ngoal (2 subgoals):\n 1. (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n     holds (\\<lambda>x. \\<psi> (reps x)))\n     (state cfg ## ys)\n 2. pred_stream (\\<lambda>s. s \\<in> \\<S>) ys", "apply (simp add: stream.map_comp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>pred_stream (\\<lambda>s. s \\<in> S) xs; smap abss xs = ys;\n     xs \\<in> space MDP.St \\<and>\n     (holds \\<phi> suntil holds \\<psi>) (s ## xs)\\<rbrakk>\n    \\<Longrightarrow> (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n                       holds (\\<lambda>x. \\<psi> (reps x)))\n                       (state cfg ## ys)\n 2. pred_stream (\\<lambda>s. s \\<in> \\<S>) ys", "apply (subst (asm) region_compatible_suntil[symmetric])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>pred_stream (\\<lambda>s. s \\<in> S) xs;\n     smap abss xs = ys\\<rbrakk>\n    \\<Longrightarrow> pred_stream\n                       (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s)\n                       (s ## xs)\n 2. \\<lbrakk>pred_stream (\\<lambda>s. s \\<in> S) xs;\n     smap abss xs = ys\\<rbrakk>\n    \\<Longrightarrow> pred_stream\n                       (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s)\n                       (s ## xs)\n 3. \\<lbrakk>pred_stream (\\<lambda>s. s \\<in> S) xs; smap abss xs = ys;\n     xs \\<in> space MDP.St \\<and>\n     (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n      holds (\\<lambda>x. \\<psi> (reps x)))\n      (smap abss (s ## xs))\\<rbrakk>\n    \\<Longrightarrow> (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n                       holds (\\<lambda>x. \\<psi> (reps x)))\n                       (state cfg ## ys)\n 4. pred_stream (\\<lambda>s. s \\<in> \\<S>) ys", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pred_stream (\\<lambda>s. s \\<in> S) xs;\n     smap abss xs = ys\\<rbrakk>\n    \\<Longrightarrow> pred_stream\n                       (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s)\n                       (s ## xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>pred_stream (\\<lambda>s. s \\<in> S) xs;\n     smap abss xs = ys\\<rbrakk>\n    \\<Longrightarrow> pred_stream\n                       (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s)\n                       (s ## xs)", "from prems"], ["proof (chain)\npicking this:\n  pred_stream (\\<lambda>s. s \\<in> S) xs\n  smap abss xs = ys\n  xs \\<in> {x \\<in> space MDP.St.\n            (holds \\<phi> suntil holds \\<psi>) (state (repcs s cfg) ## x)}", "have \"pred_stream (\\<lambda>s. s \\<in> S) xs\""], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>s. s \\<in> S) xs\n  smap abss xs = ys\n  xs \\<in> {x \\<in> space MDP.St.\n            (holds \\<phi> suntil holds \\<psi>) (state (repcs s cfg) ## x)}\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>s. s \\<in> S) xs", "using \\<S>_abss_S"], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>s. s \\<in> S) xs\n  smap abss xs = ys\n  xs \\<in> {x \\<in> space MDP.St.\n            (holds \\<phi> suntil holds \\<psi>) (state (repcs s cfg) ## x)}\n  abss ?s \\<in> \\<S> \\<Longrightarrow> ?s \\<in> S\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>s. s \\<in> S) xs", "by auto"], ["proof (state)\nthis:\n  pred_stream (\\<lambda>s. s \\<in> S) xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>pred_stream (\\<lambda>s. s \\<in> S) xs;\n     smap abss xs = ys\\<rbrakk>\n    \\<Longrightarrow> pred_stream\n                       (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s)\n                       (s ## xs)", "with equiv_\\<phi>"], ["proof (chain)\npicking this:\n  pred_stream (\\<lambda>s. s \\<in> S) ?x5 \\<Longrightarrow>\n  pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s)\n   (state cfg' ## ?x5)\n  pred_stream (\\<lambda>s. s \\<in> S) xs", "show ?thesis"], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>s. s \\<in> S) ?x5 \\<Longrightarrow>\n  pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s)\n   (state cfg' ## ?x5)\n  pred_stream (\\<lambda>s. s \\<in> S) xs\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s) (s ## xs)", "using valid"], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>s. s \\<in> S) ?x5 \\<Longrightarrow>\n  pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s)\n   (state cfg' ## ?x5)\n  pred_stream (\\<lambda>s. s \\<in> S) xs\n  cfg \\<in> R_G.valid_cfg\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s) (s ## xs)", "by (simp add: cfg'_def repc_def)"], ["proof (state)\nthis:\n  pred_stream (\\<lambda>s. \\<phi> (reps (abss s)) = \\<phi> s) (s ## xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>pred_stream (\\<lambda>s. s \\<in> S) xs;\n     smap abss xs = ys\\<rbrakk>\n    \\<Longrightarrow> pred_stream\n                       (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s)\n                       (s ## xs)\n 2. \\<lbrakk>pred_stream (\\<lambda>s. s \\<in> S) xs; smap abss xs = ys;\n     xs \\<in> space MDP.St \\<and>\n     (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n      holds (\\<lambda>x. \\<psi> (reps x)))\n      (smap abss (s ## xs))\\<rbrakk>\n    \\<Longrightarrow> (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n                       holds (\\<lambda>x. \\<psi> (reps x)))\n                       (state cfg ## ys)\n 3. pred_stream (\\<lambda>s. s \\<in> \\<S>) ys", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pred_stream (\\<lambda>s. s \\<in> S) xs;\n     smap abss xs = ys\\<rbrakk>\n    \\<Longrightarrow> pred_stream\n                       (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s)\n                       (s ## xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>pred_stream (\\<lambda>s. s \\<in> S) xs;\n     smap abss xs = ys\\<rbrakk>\n    \\<Longrightarrow> pred_stream\n                       (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s)\n                       (s ## xs)", "from prems"], ["proof (chain)\npicking this:\n  pred_stream (\\<lambda>s. s \\<in> S) xs\n  smap abss xs = ys\n  xs \\<in> {x \\<in> space MDP.St.\n            (holds \\<phi> suntil holds \\<psi>) (state (repcs s cfg) ## x)}", "have \"pred_stream (\\<lambda>s. s \\<in> S) xs\""], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>s. s \\<in> S) xs\n  smap abss xs = ys\n  xs \\<in> {x \\<in> space MDP.St.\n            (holds \\<phi> suntil holds \\<psi>) (state (repcs s cfg) ## x)}\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>s. s \\<in> S) xs", "using \\<S>_abss_S"], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>s. s \\<in> S) xs\n  smap abss xs = ys\n  xs \\<in> {x \\<in> space MDP.St.\n            (holds \\<phi> suntil holds \\<psi>) (state (repcs s cfg) ## x)}\n  abss ?s \\<in> \\<S> \\<Longrightarrow> ?s \\<in> S\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>s. s \\<in> S) xs", "by auto"], ["proof (state)\nthis:\n  pred_stream (\\<lambda>s. s \\<in> S) xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>pred_stream (\\<lambda>s. s \\<in> S) xs;\n     smap abss xs = ys\\<rbrakk>\n    \\<Longrightarrow> pred_stream\n                       (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s)\n                       (s ## xs)", "with equiv_\\<psi>"], ["proof (chain)\npicking this:\n  pred_stream (\\<lambda>s. s \\<in> S) ?x5 \\<Longrightarrow>\n  pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s)\n   (state cfg' ## ?x5)\n  pred_stream (\\<lambda>s. s \\<in> S) xs", "show ?thesis"], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>s. s \\<in> S) ?x5 \\<Longrightarrow>\n  pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s)\n   (state cfg' ## ?x5)\n  pred_stream (\\<lambda>s. s \\<in> S) xs\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s) (s ## xs)", "using valid"], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>s. s \\<in> S) ?x5 \\<Longrightarrow>\n  pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s)\n   (state cfg' ## ?x5)\n  pred_stream (\\<lambda>s. s \\<in> S) xs\n  cfg \\<in> R_G.valid_cfg\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s) (s ## xs)", "by (simp add: cfg'_def)"], ["proof (state)\nthis:\n  pred_stream (\\<lambda>s. \\<psi> (reps (abss s)) = \\<psi> s) (s ## xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>pred_stream (\\<lambda>s. s \\<in> S) xs; smap abss xs = ys;\n     xs \\<in> space MDP.St \\<and>\n     (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n      holds (\\<lambda>x. \\<psi> (reps x)))\n      (smap abss (s ## xs))\\<rbrakk>\n    \\<Longrightarrow> (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n                       holds (\\<lambda>x. \\<psi> (reps x)))\n                       (state cfg ## ys)\n 2. pred_stream (\\<lambda>s. s \\<in> \\<S>) ys", "using valid prems"], ["proof (prove)\nusing this:\n  cfg \\<in> R_G.valid_cfg\n  pred_stream (\\<lambda>s. s \\<in> S) xs\n  smap abss xs = ys\n  xs \\<in> {x \\<in> space MDP.St.\n            (holds \\<phi> suntil holds \\<psi>) (state (repcs s cfg) ## x)}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>pred_stream (\\<lambda>s. s \\<in> S) xs; smap abss xs = ys;\n     xs \\<in> space MDP.St \\<and>\n     (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n      holds (\\<lambda>x. \\<psi> (reps x)))\n      (smap abss (s ## xs))\\<rbrakk>\n    \\<Longrightarrow> (holds (\\<lambda>x. \\<phi> (reps x)) suntil\n                       holds (\\<lambda>x. \\<psi> (reps x)))\n                       (state cfg ## ys)\n 2. pred_stream (\\<lambda>s. s \\<in> \\<S>) ys", "by (auto simp: s S_abss_\\<S> stream.pred_set dest: R_G.valid_cfg_state_in_S)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "(* Probabilistic Timed Automaton Regions *)"], ["", "end"], ["", "(* Theory *)"]]}