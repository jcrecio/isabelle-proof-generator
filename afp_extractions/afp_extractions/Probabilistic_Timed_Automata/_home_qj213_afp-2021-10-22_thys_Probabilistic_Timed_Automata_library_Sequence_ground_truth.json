{"file_name": "/home/qj213/afp-2021-10-22/thys/Probabilistic_Timed_Automata/library/Sequence.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Probabilistic_Timed_Automata", "problem_names": ["lemma list_pred_cases:\n    assumes \"list_all P xs\"\n    obtains (nil) \"xs = []\" | (cons) y ys where \"xs = y # ys\" \"P y\" \"list_all P ys\"", "lemma fold_const: \"fold const xs a = last (a # xs)\"", "lemma take_Suc: \"take (Suc n) xs = (if xs = [] then [] else hd xs # take n (tl xs))\"", "lemma stream_pred_cases:\n    assumes \"pred_stream P xs\"\n    obtains (scons) y ys where \"xs = y ## ys\" \"P y\" \"pred_stream P ys\"", "lemma stream_rel_coinduct[case_names stream_rel, coinduct pred: stream_all2]:\n    assumes \"R u v\"\n    assumes \"\\<And> a u b v. R (a ## u) (b ## v) \\<Longrightarrow> P a b \\<and> R u v\"\n    shows \"stream_all2 P u v\"", "lemma stream_rel_coinduct_shift[case_names stream_rel, consumes 1]:\n    assumes \"R u v\"\n    assumes \"\\<And> u v. R u v \\<Longrightarrow>\n      \\<exists> u\\<^sub>1 u\\<^sub>2 v\\<^sub>1 v\\<^sub>2. u = u\\<^sub>1 @- u\\<^sub>2 \\<and> v = v\\<^sub>1 @- v\\<^sub>2 \\<and> u\\<^sub>1 \\<noteq> [] \\<and> v\\<^sub>1 \\<noteq> [] \\<and> list_all2 P u\\<^sub>1 v\\<^sub>1 \\<and> R u\\<^sub>2 v\\<^sub>2\"\n    shows \"stream_all2 P u v\"", "lemma stream_pred_coinduct[case_names stream_pred, coinduct pred: pred_stream]:\n    assumes \"R w\"\n    assumes \"\\<And> a w. R (a ## w) \\<Longrightarrow> P a \\<and> R w\"\n    shows \"pred_stream P w\"", "lemma stream_pred_coinduct_shift[case_names stream_pred, consumes 1]:\n    assumes \"R w\"\n    assumes \"\\<And> w. R w \\<Longrightarrow> \\<exists> u v. w = u @- v \\<and> u \\<noteq> [] \\<and> list_all P u \\<and> R v\"\n    shows \"pred_stream P w\"", "lemma stream_pred_flat_coinduct[case_names stream_pred, consumes 1]:\n    assumes \"R ws\"\n    assumes \"\\<And> w ws. R (w ## ws) \\<Longrightarrow> w \\<noteq> [] \\<and> list_all P w \\<and> R ws\"\n    shows \"pred_stream P (flat ws)\"", "lemmas stream_eq_coinduct[case_names stream_eq, coinduct pred: HOL.eq] =\n    stream_rel_coinduct[where ?P = HOL.eq, unfolded stream.rel_eq]", "lemmas stream_eq_coinduct_shift[case_names stream_eq, consumes 1] =\n    stream_rel_coinduct_shift[where ?P = HOL.eq, unfolded stream.rel_eq list.rel_eq]", "lemma sset_subset_stream_pred: \"sset w \\<subseteq> A \\<longleftrightarrow> pred_stream (\\<lambda> a. a \\<in> A) w\"", "lemma stream_pred_snth: \"pred_stream P w \\<longleftrightarrow> (\\<forall> i. P (w !! i))\"", "lemma stream_pred_shift[iff]: \"pred_stream P (u @- v) \\<longleftrightarrow> list_all P u \\<and> pred_stream P v\"", "lemma stream_rel_shift[iff]:\n    assumes \"length u\\<^sub>1 = length v\\<^sub>1\"\n    shows \"stream_all2 P (u\\<^sub>1 @- u\\<^sub>2) (v\\<^sub>1 @- v\\<^sub>2) \\<longleftrightarrow> list_all2 P u\\<^sub>1 v\\<^sub>1 \\<and> stream_all2 P u\\<^sub>2 v\\<^sub>2\"", "lemma eq_scons: \"w = a ## v \\<longleftrightarrow> a = shd w \\<and> v = stl w\"", "lemma scons_eq: \"a ## v = w \\<longleftrightarrow> shd w = a \\<and> stl w = v\"", "lemma eq_shift: \"w = u @- v \\<longleftrightarrow> stake (length u) w = u \\<and> sdrop (length u) w = v\"", "lemma shift_eq: \"u @- v = w \\<longleftrightarrow> u = stake (length u) w \\<and> v = sdrop (length u) w\"", "lemma scons_eq_shift: \"a ## w = u @- v \\<longleftrightarrow> ([] = u \\<and> a ## w = v) \\<or> (\\<exists> u'. a # u' = u \\<and> w = u' @- v)\"", "lemma shift_eq_scons: \"u @- v = a ## w \\<longleftrightarrow> (u = [] \\<and> v = a ## w) \\<or> (\\<exists> u'. u = a # u' \\<and> u' @- v = w)\"", "lemma stream_all2_sset1:\n    assumes \"stream_all2 P xs ys\"\n    shows \"\\<forall> x \\<in> sset xs. \\<exists> y \\<in> sset ys. P x y\"", "lemma stream_all2_sset2:\n    assumes \"stream_all2 P xs ys\"\n    shows \"\\<forall> y \\<in> sset ys. \\<exists> x \\<in> sset xs. P x y\"", "lemma smap_eq_scons[iff]: \"smap f xs = y ## ys \\<longleftrightarrow> f (shd xs) = y \\<and> smap f (stl xs) = ys\"", "lemma scons_eq_smap[iff]: \"y ## ys = smap f xs \\<longleftrightarrow> y = f (shd xs) \\<and> ys = smap f (stl xs)\"", "lemma smap_eq_shift[iff]:\n    \"smap f w = u @- v \\<longleftrightarrow> (\\<exists> w\\<^sub>1 w\\<^sub>2. w = w\\<^sub>1 @- w\\<^sub>2 \\<and> map f w\\<^sub>1 = u \\<and> smap f w\\<^sub>2 = v)\"", "lemma shift_eq_smap[iff]:\n    \"u @- v = smap f w \\<longleftrightarrow> (\\<exists> w\\<^sub>1 w\\<^sub>2. w = w\\<^sub>1 @- w\\<^sub>2 \\<and> u = map f w\\<^sub>1 \\<and> v = smap f w\\<^sub>2)\"", "lemma siterate_eq_scons[iff]: \"siterate f s = a ## w \\<longleftrightarrow> s = a \\<and> siterate f (f s) = w\"", "lemma scons_eq_siterate[iff]: \"a ## w = siterate f s \\<longleftrightarrow> a = s \\<and> w = siterate f (f s)\"", "lemma eqI_snth:\n    assumes \"\\<And> i. u !! i = v !! i\"\n    shows \"u = v\"", "lemma set_sset_stake[intro!, simp]: \"set (stake n xs) \\<subseteq> sset xs\"", "lemma sset_sdrop[intro!, simp]: \"sset (sdrop n xs) \\<subseteq> sset xs\"", "lemma set_stake_snth: \"x \\<in> set (stake n xs) \\<longleftrightarrow> (\\<exists> i < n. xs !! i = x)\"", "lemma split_stream_first:\n    assumes \"x \\<in> sset xs\"\n    obtains ys zs\n    where \"xs = ys @- x ## zs\" \"x \\<notin> set ys\"", "lemma scan_append[simp]: \"scan f (xs @ ys) a = scan f xs a @ scan f ys (fold f xs a)\"", "lemma scan_eq_nil[iff]: \"scan f xs a = [] \\<longleftrightarrow> xs = []\"", "lemma scan_eq_cons[iff]:\n    \"scan f xs a = b # w \\<longleftrightarrow> (\\<exists> y ys. xs = y # ys \\<and> f y a = b \\<and> scan f ys (f y a) = w)\"", "lemma scan_eq_append[iff]:\n    \"scan f xs a = u @ v \\<longleftrightarrow> (\\<exists> ys zs. xs = ys @ zs \\<and> scan f ys a = u \\<and> scan f zs (fold f ys a) = v)\"", "lemma scan_length[simp]: \"length (scan f xs a) = length xs\"", "lemma scan_last: \"last (a # scan f xs a) = fold f xs a\"", "lemma scan_const[simp]: \"scan const xs a = xs\"", "lemma scan_nth[simp]:\n    assumes \"i < length (scan f xs a)\"\n    shows \"scan f xs a ! i = fold f (take (Suc i) xs) a\"", "lemma scan_map[simp]: \"scan f (map g xs) a = scan (f \\<circ> g) xs a\"", "lemma scan_take[simp]: \"take k (scan f xs a) = scan f (take k xs) a\"", "lemma scan_drop[simp]: \"drop k (scan f xs a) = scan f (drop k xs) (fold f (take k xs) a)\"", "lemma sscan_scons[simp]: \"sscan f (x ## xs) a = f x a ## sscan f xs (f x a)\"", "lemma sscan_shift[simp]: \"sscan f (xs @- ys) a = scan f xs a @- sscan f ys (fold f xs a)\"", "lemma sscan_eq_scons[iff]:\n    \"sscan f xs a = b ## w \\<longleftrightarrow> f (shd xs) a = b \\<and> sscan f (stl xs) (f (shd xs) a) = w\"", "lemma scons_eq_sscan[iff]:\n    \"b ## w = sscan f xs a \\<longleftrightarrow> b = f (shd xs) a \\<and> w = sscan f (stl xs) (f (shd xs) a)\"", "lemma sscan_const[simp]: \"sscan const xs a = xs\"", "lemma sscan_snth[simp]: \"sscan f xs a !! i = fold f (stake (Suc i) xs) a\"", "lemma sscan_scons_snth[simp]: \"(a ## sscan f xs a) !! i = fold f (stake i xs) a\"", "lemma sscan_smap[simp]: \"sscan f (smap g xs) a = sscan (f \\<circ> g) xs a\"", "lemma sscan_stake[simp]: \"stake k (sscan f xs a) = scan f (stake k xs) a\"", "lemma sscan_sdrop[simp]: \"sdrop k (sscan f xs a) = sscan f (sdrop k xs) (fold f (stake k xs) a)\"", "lemma sdistinct_scons_elim[elim!]:\n    assumes \"sdistinct (x ## xs)\"\n    obtains \"x \\<notin> sset xs\" \"sdistinct xs\"", "lemma sdistinct_coinduct[case_names sdistinct, coinduct pred: sdistinct]:\n    assumes \"P xs\"\n    assumes \"\\<And> x xs. P (x ## xs) \\<Longrightarrow> x \\<notin> sset xs \\<and> P xs\"\n    shows \"sdistinct xs\"", "lemma sdistinct_shift[intro!]:\n    assumes \"distinct xs\" \"sdistinct ys\" \"set xs \\<inter> sset ys = {}\"\n    shows \"sdistinct (xs @- ys)\"", "lemma sdistinct_shift_elim[elim!]:\n    assumes \"sdistinct (xs @- ys)\"\n    obtains \"distinct xs\" \"sdistinct ys\" \"set xs \\<inter> sset ys = {}\"", "lemma sdistinct_infinite_sset:\n    assumes \"sdistinct w\"\n    shows \"infinite (sset w)\"", "lemma not_sdistinct_decomp:\n    assumes \"\\<not> sdistinct w\"\n    obtains u v a w'\n    where \"w = u @- a ## v @- a ## w'\"", "lemma sdescending_coinduct[case_names sdescending, coinduct pred: sdescending]:\n    assumes \"P w\"\n    assumes \"\\<And> a b w. P (a ## b ## w) \\<Longrightarrow> a \\<ge> b \\<and> P (b ## w)\"\n    shows \"sdescending w\"", "lemma sdescending_sdrop:\n    assumes \"sdescending w\"\n    shows \"sdescending (sdrop k w)\"", "lemma sdescending_snth_antimono:\n    assumes \"sdescending w\"\n    shows \"antimono (snth w)\"", "lemma sdescending_stuck:\n    fixes w :: \"'a :: wellorder stream\"\n    assumes \"sdescending w\"\n    obtains k\n    where \"sdrop k w = sconst (w !! k)\""], "translations": [["", "lemma list_pred_cases:\n    assumes \"list_all P xs\"\n    obtains (nil) \"xs = []\" | (cons) y ys where \"xs = y # ys\" \"P y\" \"list_all P ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs = [] \\<Longrightarrow> thesis;\n     \\<And>y ys.\n        \\<lbrakk>xs = y # ys; P y; list_all P ys\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  list_all P xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>xs = [] \\<Longrightarrow> thesis;\n     \\<And>y ys.\n        \\<lbrakk>xs = y # ys; P y; list_all P ys\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (cases xs) (auto)"], ["", "lemma fold_const: \"fold const xs a = last (a # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>x _. x) xs a = last (a # xs)", "by (induct xs arbitrary: a) (auto simp: last.simps)"], ["", "lemma take_Suc: \"take (Suc n) xs = (if xs = [] then [] else hd xs # take n (tl xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (Suc n) xs = (if xs = [] then [] else hd xs # take n (tl xs))", "by (simp add: take_Suc)"], ["", "(* stream basics *)"], ["", "declare stream.map_id[simp]"], ["", "declare stream.set_map[simp]"], ["", "declare stream.set_sel(1)[intro!, simp]"], ["", "declare stream.pred_map[iff]"], ["", "declare stream.rel_map[iff]"], ["", "declare shift_simps[simp del]"], ["", "declare stake_sdrop[simp]"], ["", "declare stake_siterate[simp del]"], ["", "declare sdrop_snth[simp]"], ["", "lemma stream_pred_cases:\n    assumes \"pred_stream P xs\"\n    obtains (scons) y ys where \"xs = y ## ys\" \"P y\" \"pred_stream P ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y ys.\n        \\<lbrakk>xs = y ## ys; P y; pred_stream P ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  pred_stream P xs\n\ngoal (1 subgoal):\n 1. (\\<And>y ys.\n        \\<lbrakk>xs = y ## ys; P y; pred_stream P ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases xs) (auto)"], ["", "lemma stream_rel_coinduct[case_names stream_rel, coinduct pred: stream_all2]:\n    assumes \"R u v\"\n    assumes \"\\<And> a u b v. R (a ## u) (b ## v) \\<Longrightarrow> P a b \\<and> R u v\"\n    shows \"stream_all2 P u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_all2 P u v", "using assms"], ["proof (prove)\nusing this:\n  R u v\n  R (?a ## ?u) (?b ## ?v) \\<Longrightarrow> P ?a ?b \\<and> R ?u ?v\n\ngoal (1 subgoal):\n 1. stream_all2 P u v", "by (coinduct) (metis stream.collapse)"], ["", "lemma stream_rel_coinduct_shift[case_names stream_rel, consumes 1]:\n    assumes \"R u v\"\n    assumes \"\\<And> u v. R u v \\<Longrightarrow>\n      \\<exists> u\\<^sub>1 u\\<^sub>2 v\\<^sub>1 v\\<^sub>2. u = u\\<^sub>1 @- u\\<^sub>2 \\<and> v = v\\<^sub>1 @- v\\<^sub>2 \\<and> u\\<^sub>1 \\<noteq> [] \\<and> v\\<^sub>1 \\<noteq> [] \\<and> list_all2 P u\\<^sub>1 v\\<^sub>1 \\<and> R u\\<^sub>2 v\\<^sub>2\"\n    shows \"stream_all2 P u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_all2 P u v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. stream_all2 P u v", "have \"\\<exists> u\\<^sub>1 u\\<^sub>2 v\\<^sub>1 v\\<^sub>2. u = u\\<^sub>1 @- u\\<^sub>2 \\<and> v = v\\<^sub>1 @- v\\<^sub>2 \\<and> list_all2 P u\\<^sub>1 v\\<^sub>1 \\<and> R u\\<^sub>2 v\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u\\<^sub>1 u\\<^sub>2 v\\<^sub>1 v\\<^sub>2.\n       u = u\\<^sub>1 @- u\\<^sub>2 \\<and>\n       v = v\\<^sub>1 @- v\\<^sub>2 \\<and>\n       list_all2 P u\\<^sub>1 v\\<^sub>1 \\<and> R u\\<^sub>2 v\\<^sub>2", "using assms(1)"], ["proof (prove)\nusing this:\n  R u v\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<^sub>1 u\\<^sub>2 v\\<^sub>1 v\\<^sub>2.\n       u = u\\<^sub>1 @- u\\<^sub>2 \\<and>\n       v = v\\<^sub>1 @- v\\<^sub>2 \\<and>\n       list_all2 P u\\<^sub>1 v\\<^sub>1 \\<and> R u\\<^sub>2 v\\<^sub>2", "by force"], ["proof (state)\nthis:\n  \\<exists>u\\<^sub>1 u\\<^sub>2 v\\<^sub>1 v\\<^sub>2.\n     u = u\\<^sub>1 @- u\\<^sub>2 \\<and>\n     v = v\\<^sub>1 @- v\\<^sub>2 \\<and>\n     list_all2 P u\\<^sub>1 v\\<^sub>1 \\<and> R u\\<^sub>2 v\\<^sub>2\n\ngoal (1 subgoal):\n 1. stream_all2 P u v", "then"], ["proof (chain)\npicking this:\n  \\<exists>u\\<^sub>1 u\\<^sub>2 v\\<^sub>1 v\\<^sub>2.\n     u = u\\<^sub>1 @- u\\<^sub>2 \\<and>\n     v = v\\<^sub>1 @- v\\<^sub>2 \\<and>\n     list_all2 P u\\<^sub>1 v\\<^sub>1 \\<and> R u\\<^sub>2 v\\<^sub>2", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>u\\<^sub>1 u\\<^sub>2 v\\<^sub>1 v\\<^sub>2.\n     u = u\\<^sub>1 @- u\\<^sub>2 \\<and>\n     v = v\\<^sub>1 @- v\\<^sub>2 \\<and>\n     list_all2 P u\\<^sub>1 v\\<^sub>1 \\<and> R u\\<^sub>2 v\\<^sub>2\n\ngoal (1 subgoal):\n 1. stream_all2 P u v", "using assms(2)"], ["proof (prove)\nusing this:\n  \\<exists>u\\<^sub>1 u\\<^sub>2 v\\<^sub>1 v\\<^sub>2.\n     u = u\\<^sub>1 @- u\\<^sub>2 \\<and>\n     v = v\\<^sub>1 @- v\\<^sub>2 \\<and>\n     list_all2 P u\\<^sub>1 v\\<^sub>1 \\<and> R u\\<^sub>2 v\\<^sub>2\n  R ?u ?v \\<Longrightarrow>\n  \\<exists>u\\<^sub>1 u\\<^sub>2 v\\<^sub>1 v\\<^sub>2.\n     ?u = u\\<^sub>1 @- u\\<^sub>2 \\<and>\n     ?v = v\\<^sub>1 @- v\\<^sub>2 \\<and>\n     u\\<^sub>1 \\<noteq> [] \\<and>\n     v\\<^sub>1 \\<noteq> [] \\<and>\n     list_all2 P u\\<^sub>1 v\\<^sub>1 \\<and> R u\\<^sub>2 v\\<^sub>2\n\ngoal (1 subgoal):\n 1. stream_all2 P u v", "by (coinduct) (force elim: list.rel_cases)"], ["proof (state)\nthis:\n  stream_all2 P u v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma stream_pred_coinduct[case_names stream_pred, coinduct pred: pred_stream]:\n    assumes \"R w\"\n    assumes \"\\<And> a w. R (a ## w) \\<Longrightarrow> P a \\<and> R w\"\n    shows \"pred_stream P w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream P w", "using assms"], ["proof (prove)\nusing this:\n  R w\n  R (?a ## ?w) \\<Longrightarrow> P ?a \\<and> R ?w\n\ngoal (1 subgoal):\n 1. pred_stream P w", "unfolding stream.pred_rel eq_onp_def"], ["proof (prove)\nusing this:\n  R w\n  R (?a ## ?w) \\<Longrightarrow> P ?a \\<and> R ?w\n\ngoal (1 subgoal):\n 1. stream_all2 (\\<lambda>x y. P x \\<and> x = y) w w", "by (coinduction arbitrary: w) (auto)"], ["", "lemma stream_pred_coinduct_shift[case_names stream_pred, consumes 1]:\n    assumes \"R w\"\n    assumes \"\\<And> w. R w \\<Longrightarrow> \\<exists> u v. w = u @- v \\<and> u \\<noteq> [] \\<and> list_all P u \\<and> R v\"\n    shows \"pred_stream P w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream P w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pred_stream P w", "have \"\\<exists> u v. w = u @- v \\<and> list_all P u \\<and> R v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u v. w = u @- v \\<and> list_all P u \\<and> R v", "using assms(1)"], ["proof (prove)\nusing this:\n  R w\n\ngoal (1 subgoal):\n 1. \\<exists>u v. w = u @- v \\<and> list_all P u \\<and> R v", "by (metis list_all_simps(2) shift.simps(1))"], ["proof (state)\nthis:\n  \\<exists>u v. w = u @- v \\<and> list_all P u \\<and> R v\n\ngoal (1 subgoal):\n 1. pred_stream P w", "then"], ["proof (chain)\npicking this:\n  \\<exists>u v. w = u @- v \\<and> list_all P u \\<and> R v", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>u v. w = u @- v \\<and> list_all P u \\<and> R v\n\ngoal (1 subgoal):\n 1. pred_stream P w", "using assms(2)"], ["proof (prove)\nusing this:\n  \\<exists>u v. w = u @- v \\<and> list_all P u \\<and> R v\n  R ?w \\<Longrightarrow>\n  \\<exists>u v.\n     ?w = u @- v \\<and> u \\<noteq> [] \\<and> list_all P u \\<and> R v\n\ngoal (1 subgoal):\n 1. pred_stream P w", "by (coinduct) (force elim: list_pred_cases)"], ["proof (state)\nthis:\n  pred_stream P w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma stream_pred_flat_coinduct[case_names stream_pred, consumes 1]:\n    assumes \"R ws\"\n    assumes \"\\<And> w ws. R (w ## ws) \\<Longrightarrow> w \\<noteq> [] \\<and> list_all P w \\<and> R ws\"\n    shows \"pred_stream P (flat ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream P (flat ws)", "using assms"], ["proof (prove)\nusing this:\n  R ws\n  R (?w ## ?ws) \\<Longrightarrow>\n  ?w \\<noteq> [] \\<and> list_all P ?w \\<and> R ?ws\n\ngoal (1 subgoal):\n 1. pred_stream P (flat ws)", "by (coinduction arbitrary: ws rule: stream_pred_coinduct_shift) (metis stream.exhaust flat_Stream)"], ["", "lemmas stream_eq_coinduct[case_names stream_eq, coinduct pred: HOL.eq] =\n    stream_rel_coinduct[where ?P = HOL.eq, unfolded stream.rel_eq]"], ["", "lemmas stream_eq_coinduct_shift[case_names stream_eq, consumes 1] =\n    stream_rel_coinduct_shift[where ?P = HOL.eq, unfolded stream.rel_eq list.rel_eq]"], ["", "lemma sset_subset_stream_pred: \"sset w \\<subseteq> A \\<longleftrightarrow> pred_stream (\\<lambda> a. a \\<in> A) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sset w \\<subseteq> A) = pred_stream (\\<lambda>a. a \\<in> A) w", "unfolding stream.pred_set"], ["proof (prove)\ngoal (1 subgoal):\n 1. (sset w \\<subseteq> A) = (\\<forall>a\\<in>sset w. a \\<in> A)", "by auto"], ["", "lemma stream_pred_snth: \"pred_stream P w \\<longleftrightarrow> (\\<forall> i. P (w !! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream P w = (\\<forall>i. P (w !! i))", "unfolding stream.pred_set sset_range"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (range ((!!) w)) P = (\\<forall>i. P (w !! i))", "by simp"], ["", "lemma stream_pred_shift[iff]: \"pred_stream P (u @- v) \\<longleftrightarrow> list_all P u \\<and> pred_stream P v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream P (u @- v) = (list_all P u \\<and> pred_stream P v)", "by (induct u) (auto)"], ["", "lemma stream_rel_shift[iff]:\n    assumes \"length u\\<^sub>1 = length v\\<^sub>1\"\n    shows \"stream_all2 P (u\\<^sub>1 @- u\\<^sub>2) (v\\<^sub>1 @- v\\<^sub>2) \\<longleftrightarrow> list_all2 P u\\<^sub>1 v\\<^sub>1 \\<and> stream_all2 P u\\<^sub>2 v\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_all2 P (u\\<^sub>1 @- u\\<^sub>2) (v\\<^sub>1 @- v\\<^sub>2) =\n    (list_all2 P u\\<^sub>1 v\\<^sub>1 \\<and>\n     stream_all2 P u\\<^sub>2 v\\<^sub>2)", "using assms"], ["proof (prove)\nusing this:\n  length u\\<^sub>1 = length v\\<^sub>1\n\ngoal (1 subgoal):\n 1. stream_all2 P (u\\<^sub>1 @- u\\<^sub>2) (v\\<^sub>1 @- v\\<^sub>2) =\n    (list_all2 P u\\<^sub>1 v\\<^sub>1 \\<and>\n     stream_all2 P u\\<^sub>2 v\\<^sub>2)", "by (induct rule: list_induct2) (auto)"], ["", "lemma eq_scons: \"w = a ## v \\<longleftrightarrow> a = shd w \\<and> v = stl w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w = a ## v) = (a = shd w \\<and> v = stl w)", "by auto"], ["", "lemma scons_eq: \"a ## v = w \\<longleftrightarrow> shd w = a \\<and> stl w = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a ## v = w) = (shd w = a \\<and> stl w = v)", "by auto"], ["", "lemma eq_shift: \"w = u @- v \\<longleftrightarrow> stake (length u) w = u \\<and> sdrop (length u) w = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w = u @- v) = (stake (length u) w = u \\<and> sdrop (length u) w = v)", "by (induct u arbitrary: w) (force+)"], ["", "lemma shift_eq: \"u @- v = w \\<longleftrightarrow> u = stake (length u) w \\<and> v = sdrop (length u) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u @- v = w) = (u = stake (length u) w \\<and> v = sdrop (length u) w)", "by (induct u arbitrary: w) (force+)"], ["", "lemma scons_eq_shift: \"a ## w = u @- v \\<longleftrightarrow> ([] = u \\<and> a ## w = v) \\<or> (\\<exists> u'. a # u' = u \\<and> w = u' @- v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a ## w = u @- v) =\n    ([] = u \\<and> a ## w = v \\<or>\n     (\\<exists>u'. a # u' = u \\<and> w = u' @- v))", "by (cases u) (auto)"], ["", "lemma shift_eq_scons: \"u @- v = a ## w \\<longleftrightarrow> (u = [] \\<and> v = a ## w) \\<or> (\\<exists> u'. u = a # u' \\<and> u' @- v = w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u @- v = a ## w) =\n    (u = [] \\<and> v = a ## w \\<or>\n     (\\<exists>u'. u = a # u' \\<and> u' @- v = w))", "by (cases u) (auto)"], ["", "lemma stream_all2_sset1:\n    assumes \"stream_all2 P xs ys\"\n    shows \"\\<forall> x \\<in> sset xs. \\<exists> y \\<in> sset ys. P x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>sset xs. \\<exists>y\\<in>sset ys. P x y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>sset xs. \\<exists>y\\<in>sset ys. P x y", "have \"pred_stream (\\<lambda> x. \\<exists> y \\<in> S. P x y) xs\" if \"sset ys \\<subseteq> S\" for S"], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>x. \\<exists>y\\<in>S. P x y) xs", "using assms that"], ["proof (prove)\nusing this:\n  stream_all2 P xs ys\n  sset ys \\<subseteq> S\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>x. \\<exists>y\\<in>S. P x y) xs", "by (coinduction arbitrary: xs ys) (force elim: stream.rel_cases)"], ["proof (state)\nthis:\n  sset ys \\<subseteq> ?S \\<Longrightarrow>\n  pred_stream (\\<lambda>x. \\<exists>y\\<in>?S. P x y) xs\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>sset xs. \\<exists>y\\<in>sset ys. P x y", "then"], ["proof (chain)\npicking this:\n  sset ys \\<subseteq> ?S \\<Longrightarrow>\n  pred_stream (\\<lambda>x. \\<exists>y\\<in>?S. P x y) xs", "show ?thesis"], ["proof (prove)\nusing this:\n  sset ys \\<subseteq> ?S \\<Longrightarrow>\n  pred_stream (\\<lambda>x. \\<exists>y\\<in>?S. P x y) xs\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>sset xs. \\<exists>y\\<in>sset ys. P x y", "unfolding stream.pred_set"], ["proof (prove)\nusing this:\n  sset ys \\<subseteq> ?S \\<Longrightarrow>\n  \\<forall>x\\<in>sset xs. Bex ?S (P x)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>sset xs. \\<exists>y\\<in>sset ys. P x y", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>sset xs. \\<exists>y\\<in>sset ys. P x y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma stream_all2_sset2:\n    assumes \"stream_all2 P xs ys\"\n    shows \"\\<forall> y \\<in> sset ys. \\<exists> x \\<in> sset xs. P x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>sset ys. \\<exists>x\\<in>sset xs. P x y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>sset ys. \\<exists>x\\<in>sset xs. P x y", "have \"pred_stream (\\<lambda> y. \\<exists> x \\<in> S. P x y) ys\" if \"sset xs \\<subseteq> S\" for S"], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>y. \\<exists>x\\<in>S. P x y) ys", "using assms that"], ["proof (prove)\nusing this:\n  stream_all2 P xs ys\n  sset xs \\<subseteq> S\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>y. \\<exists>x\\<in>S. P x y) ys", "by (coinduction arbitrary: xs ys) (force elim: stream.rel_cases)"], ["proof (state)\nthis:\n  sset xs \\<subseteq> ?S \\<Longrightarrow>\n  pred_stream (\\<lambda>y. \\<exists>x\\<in>?S. P x y) ys\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>sset ys. \\<exists>x\\<in>sset xs. P x y", "then"], ["proof (chain)\npicking this:\n  sset xs \\<subseteq> ?S \\<Longrightarrow>\n  pred_stream (\\<lambda>y. \\<exists>x\\<in>?S. P x y) ys", "show ?thesis"], ["proof (prove)\nusing this:\n  sset xs \\<subseteq> ?S \\<Longrightarrow>\n  pred_stream (\\<lambda>y. \\<exists>x\\<in>?S. P x y) ys\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>sset ys. \\<exists>x\\<in>sset xs. P x y", "unfolding stream.pred_set"], ["proof (prove)\nusing this:\n  sset xs \\<subseteq> ?S \\<Longrightarrow>\n  \\<forall>y\\<in>sset ys. \\<exists>x\\<in>?S. P x y\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>sset ys. \\<exists>x\\<in>sset xs. P x y", "by auto"], ["proof (state)\nthis:\n  \\<forall>y\\<in>sset ys. \\<exists>x\\<in>sset xs. P x y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma smap_eq_scons[iff]: \"smap f xs = y ## ys \\<longleftrightarrow> f (shd xs) = y \\<and> smap f (stl xs) = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (smap f xs = y ## ys) = (f (shd xs) = y \\<and> smap f (stl xs) = ys)", "using smap_ctr"], ["proof (prove)\nusing this:\n  (smap ?f ?s = ?x ## ?s') =\n  (?f (shd ?s) = ?x \\<and> smap ?f (stl ?s) = ?s')\n\ngoal (1 subgoal):\n 1. (smap f xs = y ## ys) = (f (shd xs) = y \\<and> smap f (stl xs) = ys)", "by metis"], ["", "lemma scons_eq_smap[iff]: \"y ## ys = smap f xs \\<longleftrightarrow> y = f (shd xs) \\<and> ys = smap f (stl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y ## ys = smap f xs) = (y = f (shd xs) \\<and> ys = smap f (stl xs))", "using smap_ctr"], ["proof (prove)\nusing this:\n  (smap ?f ?s = ?x ## ?s') =\n  (?f (shd ?s) = ?x \\<and> smap ?f (stl ?s) = ?s')\n\ngoal (1 subgoal):\n 1. (y ## ys = smap f xs) = (y = f (shd xs) \\<and> ys = smap f (stl xs))", "by metis"], ["", "lemma smap_eq_shift[iff]:\n    \"smap f w = u @- v \\<longleftrightarrow> (\\<exists> w\\<^sub>1 w\\<^sub>2. w = w\\<^sub>1 @- w\\<^sub>2 \\<and> map f w\\<^sub>1 = u \\<and> smap f w\\<^sub>2 = v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (smap f w = u @- v) =\n    (\\<exists>w\\<^sub>1 w\\<^sub>2.\n        w = w\\<^sub>1 @- w\\<^sub>2 \\<and>\n        map f w\\<^sub>1 = u \\<and> smap f w\\<^sub>2 = v)", "using sdrop_smap eq_shift stake_sdrop stake_smap"], ["proof (prove)\nusing this:\n  sdrop ?n (smap ?f ?s) = smap ?f (sdrop ?n ?s)\n  (?w = ?u @- ?v) =\n  (stake (length ?u) ?w = ?u \\<and> sdrop (length ?u) ?w = ?v)\n  stake ?n ?s @- sdrop ?n ?s = ?s\n  stake ?n (smap ?f ?s) = map ?f (stake ?n ?s)\n\ngoal (1 subgoal):\n 1. (smap f w = u @- v) =\n    (\\<exists>w\\<^sub>1 w\\<^sub>2.\n        w = w\\<^sub>1 @- w\\<^sub>2 \\<and>\n        map f w\\<^sub>1 = u \\<and> smap f w\\<^sub>2 = v)", "by metis"], ["", "lemma shift_eq_smap[iff]:\n    \"u @- v = smap f w \\<longleftrightarrow> (\\<exists> w\\<^sub>1 w\\<^sub>2. w = w\\<^sub>1 @- w\\<^sub>2 \\<and> u = map f w\\<^sub>1 \\<and> v = smap f w\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u @- v = smap f w) =\n    (\\<exists>w\\<^sub>1 w\\<^sub>2.\n        w = w\\<^sub>1 @- w\\<^sub>2 \\<and>\n        u = map f w\\<^sub>1 \\<and> v = smap f w\\<^sub>2)", "using sdrop_smap eq_shift stake_sdrop stake_smap"], ["proof (prove)\nusing this:\n  sdrop ?n (smap ?f ?s) = smap ?f (sdrop ?n ?s)\n  (?w = ?u @- ?v) =\n  (stake (length ?u) ?w = ?u \\<and> sdrop (length ?u) ?w = ?v)\n  stake ?n ?s @- sdrop ?n ?s = ?s\n  stake ?n (smap ?f ?s) = map ?f (stake ?n ?s)\n\ngoal (1 subgoal):\n 1. (u @- v = smap f w) =\n    (\\<exists>w\\<^sub>1 w\\<^sub>2.\n        w = w\\<^sub>1 @- w\\<^sub>2 \\<and>\n        u = map f w\\<^sub>1 \\<and> v = smap f w\\<^sub>2)", "by metis"], ["", "lemma siterate_eq_scons[iff]: \"siterate f s = a ## w \\<longleftrightarrow> s = a \\<and> siterate f (f s) = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (siterate f s = a ## w) = (s = a \\<and> siterate f (f s) = w)", "using siterate.ctr stream.inject"], ["proof (prove)\nusing this:\n  siterate ?f ?x = ?x ## siterate ?f (?f ?x)\n  (?x1.0 ## ?x2.0 = ?y1.0 ## ?y2.0) = (?x1.0 = ?y1.0 \\<and> ?x2.0 = ?y2.0)\n\ngoal (1 subgoal):\n 1. (siterate f s = a ## w) = (s = a \\<and> siterate f (f s) = w)", "by metis"], ["", "lemma scons_eq_siterate[iff]: \"a ## w = siterate f s \\<longleftrightarrow> a = s \\<and> w = siterate f (f s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a ## w = siterate f s) = (a = s \\<and> w = siterate f (f s))", "using siterate.ctr stream.inject"], ["proof (prove)\nusing this:\n  siterate ?f ?x = ?x ## siterate ?f (?f ?x)\n  (?x1.0 ## ?x2.0 = ?y1.0 ## ?y2.0) = (?x1.0 = ?y1.0 \\<and> ?x2.0 = ?y2.0)\n\ngoal (1 subgoal):\n 1. (a ## w = siterate f s) = (a = s \\<and> w = siterate f (f s))", "by metis"], ["", "lemma eqI_snth:\n    assumes \"\\<And> i. u !! i = v !! i\"\n    shows \"u = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u = v", "using assms"], ["proof (prove)\nusing this:\n  u !! ?i = v !! ?i\n\ngoal (1 subgoal):\n 1. u = v", "by (coinduction arbitrary: u v) (metis stream.sel snth.simps)"], ["", "lemma set_sset_stake[intro!, simp]: \"set (stake n xs) \\<subseteq> sset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (stake n xs) \\<subseteq> sset xs", "by (metis sset_shift stake_sdrop sup_ge1)"], ["", "lemma sset_sdrop[intro!, simp]: \"sset (sdrop n xs) \\<subseteq> sset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sset (sdrop n xs) \\<subseteq> sset xs", "by (metis sset_shift stake_sdrop sup_ge2)"], ["", "lemma set_stake_snth: \"x \\<in> set (stake n xs) \\<longleftrightarrow> (\\<exists> i < n. xs !! i = x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set (stake n xs)) = (\\<exists>i<n. xs !! i = x)", "unfolding in_set_conv_nth"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>i<length (stake n xs). stake n xs ! i = x) =\n    (\\<exists>i<n. xs !! i = x)", "by auto"], ["", "lemma split_stream_first:\n    assumes \"x \\<in> sset xs\"\n    obtains ys zs\n    where \"xs = ys @- x ## zs\" \"x \\<notin> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ys zs.\n        \\<lbrakk>xs = ys @- x ## zs; x \\<notin> set ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>ys zs.\n        \\<lbrakk>xs = ys @- x ## zs; x \\<notin> set ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    xs = ?ys2 @- x ## ?zs2\n 2. (\\<And>ys zs.\n        \\<lbrakk>xs = ys @- x ## zs; x \\<notin> set ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    x \\<notin> set ?ys2", "let ?n = \"LEAST n. xs !! n = x\""], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>ys zs.\n        \\<lbrakk>xs = ys @- x ## zs; x \\<notin> set ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    xs = ?ys2 @- x ## ?zs2\n 2. (\\<And>ys zs.\n        \\<lbrakk>xs = ys @- x ## zs; x \\<notin> set ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    x \\<notin> set ?ys2", "have 1: \"xs !! ?n = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs !! (LEAST n. xs !! n = x) = x", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> sset xs\n\ngoal (1 subgoal):\n 1. xs !! (LEAST n. xs !! n = x) = x", "unfolding sset_range"], ["proof (prove)\nusing this:\n  x \\<in> range ((!!) xs)\n\ngoal (1 subgoal):\n 1. xs !! (LEAST n. xs !! n = x) = x", "by (auto intro: LeastI)"], ["proof (state)\nthis:\n  xs !! (LEAST n. xs !! n = x) = x\n\ngoal (2 subgoals):\n 1. (\\<And>ys zs.\n        \\<lbrakk>xs = ys @- x ## zs; x \\<notin> set ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    xs = ?ys2 @- x ## ?zs2\n 2. (\\<And>ys zs.\n        \\<lbrakk>xs = ys @- x ## zs; x \\<notin> set ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    x \\<notin> set ?ys2", "have 2: \"xs !! n \\<noteq> x\" if \"n < ?n\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs !! n \\<noteq> x", "using that"], ["proof (prove)\nusing this:\n  n < (LEAST n. xs !! n = x)\n\ngoal (1 subgoal):\n 1. xs !! n \\<noteq> x", "by (metis (full_types) not_less_Least)"], ["proof (state)\nthis:\n  ?n < (LEAST n. xs !! n = x) \\<Longrightarrow> xs !! ?n \\<noteq> x\n\ngoal (2 subgoals):\n 1. (\\<And>ys zs.\n        \\<lbrakk>xs = ys @- x ## zs; x \\<notin> set ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    xs = ?ys2 @- x ## ?zs2\n 2. (\\<And>ys zs.\n        \\<lbrakk>xs = ys @- x ## zs; x \\<notin> set ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    x \\<notin> set ?ys2", "show \"xs = stake ?n xs @- x ## sdrop (Suc ?n) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs =\n    stake (LEAST n. xs !! n = x) xs @-\n    x ## sdrop (Suc (LEAST n. xs !! n = x)) xs", "using 1"], ["proof (prove)\nusing this:\n  xs !! (LEAST n. xs !! n = x) = x\n\ngoal (1 subgoal):\n 1. xs =\n    stake (LEAST n. xs !! n = x) xs @-\n    x ## sdrop (Suc (LEAST n. xs !! n = x)) xs", "by (metis id_stake_snth_sdrop)"], ["proof (state)\nthis:\n  xs =\n  stake (LEAST n. xs !! n = x) xs @-\n  x ## sdrop (Suc (LEAST n. xs !! n = x)) xs\n\ngoal (1 subgoal):\n 1. (\\<And>ys zs.\n        \\<lbrakk>xs = ys @- x ## zs; x \\<notin> set ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    x \\<notin> set (stake (LEAST n. xs !! n = x) xs)", "show \"x \\<notin> set (stake ?n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> set (stake (LEAST n. xs !! n = x) xs)", "using 2"], ["proof (prove)\nusing this:\n  ?n < (LEAST n. xs !! n = x) \\<Longrightarrow> xs !! ?n \\<noteq> x\n\ngoal (1 subgoal):\n 1. x \\<notin> set (stake (LEAST n. xs !! n = x) xs)", "by (meson set_stake_snth)"], ["proof (state)\nthis:\n  x \\<notin> set (stake (LEAST n. xs !! n = x) xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* scans *)"], ["", "fun scan :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'b) \\<Rightarrow> 'a list \\<Rightarrow> 'b \\<Rightarrow> 'b list\" where\n    \"scan f [] a = []\" | \"scan f (x # xs) a = f x a # scan f xs (f x a)\""], ["", "lemma scan_append[simp]: \"scan f (xs @ ys) a = scan f xs a @ scan f ys (fold f xs a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scan f (xs @ ys) a = scan f xs a @ scan f ys (fold f xs a)", "by (induct xs arbitrary: a) (auto)"], ["", "lemma scan_eq_nil[iff]: \"scan f xs a = [] \\<longleftrightarrow> xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (scan f xs a = []) = (xs = [])", "by (cases xs) (auto)"], ["", "lemma scan_eq_cons[iff]:\n    \"scan f xs a = b # w \\<longleftrightarrow> (\\<exists> y ys. xs = y # ys \\<and> f y a = b \\<and> scan f ys (f y a) = w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (scan f xs a = b # w) =\n    (\\<exists>y ys.\n        xs = y # ys \\<and> f y a = b \\<and> scan f ys (f y a) = w)", "by (cases xs) (auto)"], ["", "lemma scan_eq_append[iff]:\n    \"scan f xs a = u @ v \\<longleftrightarrow> (\\<exists> ys zs. xs = ys @ zs \\<and> scan f ys a = u \\<and> scan f zs (fold f ys a) = v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (scan f xs a = u @ v) =\n    (\\<exists>ys zs.\n        xs = ys @ zs \\<and>\n        scan f ys a = u \\<and> scan f zs (fold f ys a) = v)", "by (induct u arbitrary: xs a) (auto, metis append_Cons fold_simps(2), blast)"], ["", "lemma scan_length[simp]: \"length (scan f xs a) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (scan f xs a) = length xs", "by (induct xs arbitrary: a) (auto)"], ["", "lemma scan_last: \"last (a # scan f xs a) = fold f xs a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (a # scan f xs a) = fold f xs a", "by (induct xs arbitrary: a) (auto simp: last.simps)"], ["", "lemma scan_const[simp]: \"scan const xs a = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scan (\\<lambda>x _. x) xs a = xs", "by (induct xs arbitrary: a) (auto)"], ["", "lemma scan_nth[simp]:\n    assumes \"i < length (scan f xs a)\"\n    shows \"scan f xs a ! i = fold f (take (Suc i) xs) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scan f xs a ! i = fold f (take (Suc i) xs) a", "using assms"], ["proof (prove)\nusing this:\n  i < length (scan f xs a)\n\ngoal (1 subgoal):\n 1. scan f xs a ! i = fold f (take (Suc i) xs) a", "by (cases xs, simp, induct i arbitrary: xs a, auto simp: take_Suc neq_Nil_conv)"], ["", "lemma scan_map[simp]: \"scan f (map g xs) a = scan (f \\<circ> g) xs a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scan f (map g xs) a = scan (f \\<circ> g) xs a", "by (induct xs arbitrary: a) (auto)"], ["", "lemma scan_take[simp]: \"take k (scan f xs a) = scan f (take k xs) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take k (scan f xs a) = scan f (take k xs) a", "by (induct k arbitrary: xs a) (auto simp: take_Suc neq_Nil_conv)"], ["", "lemma scan_drop[simp]: \"drop k (scan f xs a) = scan f (drop k xs) (fold f (take k xs) a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop k (scan f xs a) = scan f (drop k xs) (fold f (take k xs) a)", "by (induct k arbitrary: xs a) (auto simp: take_Suc neq_Nil_conv)"], ["", "primcorec sscan :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'b) \\<Rightarrow> 'a stream \\<Rightarrow> 'b \\<Rightarrow> 'b stream\" where\n    \"sscan f xs a = f (shd xs) a ## sscan f (stl xs) (f (shd xs) a)\""], ["", "lemma sscan_scons[simp]: \"sscan f (x ## xs) a = f x a ## sscan f xs (f x a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sscan f (x ## xs) a = f x a ## sscan f xs (f x a)", "by (simp add: stream.expand)"], ["", "lemma sscan_shift[simp]: \"sscan f (xs @- ys) a = scan f xs a @- sscan f ys (fold f xs a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sscan f (xs @- ys) a = scan f xs a @- sscan f ys (fold f xs a)", "by (induct xs arbitrary: a) (auto)"], ["", "lemma sscan_eq_scons[iff]:\n    \"sscan f xs a = b ## w \\<longleftrightarrow> f (shd xs) a = b \\<and> sscan f (stl xs) (f (shd xs) a) = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sscan f xs a = b ## w) =\n    (f (shd xs) a = b \\<and> sscan f (stl xs) (f (shd xs) a) = w)", "using sscan.ctr stream.inject"], ["proof (prove)\nusing this:\n  sscan ?f ?xs ?a = ?f (shd ?xs) ?a ## sscan ?f (stl ?xs) (?f (shd ?xs) ?a)\n  (?x1.0 ## ?x2.0 = ?y1.0 ## ?y2.0) = (?x1.0 = ?y1.0 \\<and> ?x2.0 = ?y2.0)\n\ngoal (1 subgoal):\n 1. (sscan f xs a = b ## w) =\n    (f (shd xs) a = b \\<and> sscan f (stl xs) (f (shd xs) a) = w)", "by metis"], ["", "lemma scons_eq_sscan[iff]:\n    \"b ## w = sscan f xs a \\<longleftrightarrow> b = f (shd xs) a \\<and> w = sscan f (stl xs) (f (shd xs) a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b ## w = sscan f xs a) =\n    (b = f (shd xs) a \\<and> w = sscan f (stl xs) (f (shd xs) a))", "using sscan.ctr stream.inject"], ["proof (prove)\nusing this:\n  sscan ?f ?xs ?a = ?f (shd ?xs) ?a ## sscan ?f (stl ?xs) (?f (shd ?xs) ?a)\n  (?x1.0 ## ?x2.0 = ?y1.0 ## ?y2.0) = (?x1.0 = ?y1.0 \\<and> ?x2.0 = ?y2.0)\n\ngoal (1 subgoal):\n 1. (b ## w = sscan f xs a) =\n    (b = f (shd xs) a \\<and> w = sscan f (stl xs) (f (shd xs) a))", "by metis"], ["", "lemma sscan_const[simp]: \"sscan const xs a = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sscan (\\<lambda>x _. x) xs a = xs", "by (coinduction arbitrary: xs a) (auto)"], ["", "lemma sscan_snth[simp]: \"sscan f xs a !! i = fold f (stake (Suc i) xs) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sscan f xs a !! i = fold f (stake (Suc i) xs) a", "by (induct i arbitrary: xs a) (auto)"], ["", "lemma sscan_scons_snth[simp]: \"(a ## sscan f xs a) !! i = fold f (stake i xs) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a ## sscan f xs a) !! i = fold f (stake i xs) a", "by (induct i arbitrary: xs a) (auto)"], ["", "lemma sscan_smap[simp]: \"sscan f (smap g xs) a = sscan (f \\<circ> g) xs a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sscan f (smap g xs) a = sscan (f \\<circ> g) xs a", "by (coinduction arbitrary: xs a) (auto)"], ["", "lemma sscan_stake[simp]: \"stake k (sscan f xs a) = scan f (stake k xs) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stake k (sscan f xs a) = scan f (stake k xs) a", "by (induct k arbitrary: a xs) (auto)"], ["", "lemma sscan_sdrop[simp]: \"sdrop k (sscan f xs a) = sscan f (sdrop k xs) (fold f (stake k xs) a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sdrop k (sscan f xs a) = sscan f (sdrop k xs) (fold f (stake k xs) a)", "by (induct k arbitrary: a xs) (auto)"], ["", "(* sdistinct *)"], ["", "coinductive sdistinct :: \"'a stream \\<Rightarrow> bool\" where\n    scons[intro!]: \"x \\<notin> sset xs \\<Longrightarrow> sdistinct xs \\<Longrightarrow> sdistinct (x ## xs)\""], ["", "lemma sdistinct_scons_elim[elim!]:\n    assumes \"sdistinct (x ## xs)\"\n    obtains \"x \\<notin> sset xs\" \"sdistinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>x \\<notin> sset xs; sdistinct xs\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  sdistinct (x ## xs)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>x \\<notin> sset xs; sdistinct xs\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: sdistinct.cases)"], ["", "lemma sdistinct_coinduct[case_names sdistinct, coinduct pred: sdistinct]:\n    assumes \"P xs\"\n    assumes \"\\<And> x xs. P (x ## xs) \\<Longrightarrow> x \\<notin> sset xs \\<and> P xs\"\n    shows \"sdistinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sdistinct xs", "using stream.collapse sdistinct.coinduct assms"], ["proof (prove)\nusing this:\n  shd ?stream ## stl ?stream = ?stream\n  \\<lbrakk>?X ?x;\n   \\<And>x.\n      ?X x \\<Longrightarrow>\n      \\<exists>xa xs.\n         x = xa ## xs \\<and>\n         xa \\<notin> sset xs \\<and> (?X xs \\<or> sdistinct xs)\\<rbrakk>\n  \\<Longrightarrow> sdistinct ?x\n  P xs\n  P (?x ## ?xs) \\<Longrightarrow> ?x \\<notin> sset ?xs \\<and> P ?xs\n\ngoal (1 subgoal):\n 1. sdistinct xs", "by metis"], ["", "lemma sdistinct_shift[intro!]:\n    assumes \"distinct xs\" \"sdistinct ys\" \"set xs \\<inter> sset ys = {}\"\n    shows \"sdistinct (xs @- ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sdistinct (xs @- ys)", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n  sdistinct ys\n  set xs \\<inter> sset ys = {}\n\ngoal (1 subgoal):\n 1. sdistinct (xs @- ys)", "by (induct xs) (auto)"], ["", "lemma sdistinct_shift_elim[elim!]:\n    assumes \"sdistinct (xs @- ys)\"\n    obtains \"distinct xs\" \"sdistinct ys\" \"set xs \\<inter> sset ys = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>distinct xs; sdistinct ys;\n      set xs \\<inter> sset ys = {}\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  sdistinct (xs @- ys)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>distinct xs; sdistinct ys;\n      set xs \\<inter> sset ys = {}\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (induct xs) (auto)"], ["", "lemma sdistinct_infinite_sset:\n    assumes \"sdistinct w\"\n    shows \"infinite (sset w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (sset w)", "using assms"], ["proof (prove)\nusing this:\n  sdistinct w\n\ngoal (1 subgoal):\n 1. infinite (sset w)", "by (coinduction arbitrary: w) (force elim: sdistinct.cases)"], ["", "lemma not_sdistinct_decomp:\n    assumes \"\\<not> sdistinct w\"\n    obtains u v a w'\n    where \"w = u @- a ## v @- a ## w'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u a v w'.\n        w = u @- a ## v @- a ## w' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>u a v w'.\n                w = u @- a ## v @- a ## w' \\<Longrightarrow> thesis;\n     \\<not> thesis\\<rbrakk>\n    \\<Longrightarrow> False", "assume 1: \"\\<not> thesis\""], ["proof (state)\nthis:\n  \\<not> thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>u a v w'.\n                w = u @- a ## v @- a ## w' \\<Longrightarrow> thesis;\n     \\<not> thesis\\<rbrakk>\n    \\<Longrightarrow> False", "assume 2: \"w = u @- a ## v @- a ## w' \\<Longrightarrow> thesis\" for u a v w'"], ["proof (state)\nthis:\n  w = ?u @- ?a ## ?v @- ?a ## ?w' \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>u a v w'.\n                w = u @- a ## v @- a ## w' \\<Longrightarrow> thesis;\n     \\<not> thesis\\<rbrakk>\n    \\<Longrightarrow> False", "have 3: \"\\<forall> u v a w'. w \\<noteq> u @- a ## v @- a ## w'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u v a w'. w \\<noteq> u @- a ## v @- a ## w'", "using 1 2"], ["proof (prove)\nusing this:\n  \\<not> thesis\n  w = ?u @- ?a ## ?v @- ?a ## ?w' \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. \\<forall>u v a w'. w \\<noteq> u @- a ## v @- a ## w'", "by auto"], ["proof (state)\nthis:\n  \\<forall>u v a w'. w \\<noteq> u @- a ## v @- a ## w'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>u a v w'.\n                w = u @- a ## v @- a ## w' \\<Longrightarrow> thesis;\n     \\<not> thesis\\<rbrakk>\n    \\<Longrightarrow> False", "have 4: \"sdistinct w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sdistinct w", "using 3"], ["proof (prove)\nusing this:\n  \\<forall>u v a w'. w \\<noteq> u @- a ## v @- a ## w'\n\ngoal (1 subgoal):\n 1. sdistinct w", "by (coinduct) (metis id_stake_snth_sdrop imageE shift.simps sset_range)"], ["proof (state)\nthis:\n  sdistinct w\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>u a v w'.\n                w = u @- a ## v @- a ## w' \\<Longrightarrow> thesis;\n     \\<not> thesis\\<rbrakk>\n    \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using assms 4"], ["proof (prove)\nusing this:\n  \\<not> sdistinct w\n  sdistinct w\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "(* sorted streams *)"], ["", "coinductive (in order) sascending :: \"'a stream \\<Rightarrow> bool\" where\n    \"a \\<le> b \\<Longrightarrow> sascending (b ## w) \\<Longrightarrow> sascending (a ## b ## w)\""], ["", "coinductive (in order) sdescending :: \"'a stream \\<Rightarrow> bool\" where\n    \"a \\<ge> b \\<Longrightarrow> sdescending (b ## w) \\<Longrightarrow> sdescending (a ## b ## w)\""], ["", "lemma sdescending_coinduct[case_names sdescending, coinduct pred: sdescending]:\n    assumes \"P w\"\n    assumes \"\\<And> a b w. P (a ## b ## w) \\<Longrightarrow> a \\<ge> b \\<and> P (b ## w)\"\n    shows \"sdescending w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sdescending w", "using stream.collapse sdescending.coinduct assms"], ["proof (prove)\nusing this:\n  shd ?stream ## stl ?stream = ?stream\n  \\<lbrakk>?X ?x;\n   \\<And>x.\n      ?X x \\<Longrightarrow>\n      \\<exists>a b w.\n         x = a ## b ## w \\<and>\n         b \\<le> a \\<and> (?X (b ## w) \\<or> sdescending (b ## w))\\<rbrakk>\n  \\<Longrightarrow> sdescending ?x\n  P w\n  P (?a ## ?b ## ?w) \\<Longrightarrow> ?b \\<le> ?a \\<and> P (?b ## ?w)\n\ngoal (1 subgoal):\n 1. sdescending w", "by (metis (no_types))"], ["", "lemma sdescending_sdrop:\n    assumes \"sdescending w\"\n    shows \"sdescending (sdrop k w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sdescending (sdrop k w)", "using assms"], ["proof (prove)\nusing this:\n  sdescending w\n\ngoal (1 subgoal):\n 1. sdescending (sdrop k w)", "by (induct k) (auto, metis sdescending.cases sdrop_stl stream.sel(2))"], ["", "lemma sdescending_snth_antimono:\n    assumes \"sdescending w\"\n    shows \"antimono (snth w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. antimono ((!!) w)", "unfolding antimono_iff_le_Suc"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. w !! Suc n \\<le> w !! n", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. w !! Suc n \\<le> w !! n", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. w !! Suc n \\<le> w !! n", "have \"sdescending (sdrop k w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sdescending (sdrop k w)", "using sdescending_sdrop assms"], ["proof (prove)\nusing this:\n  sdescending ?w \\<Longrightarrow> sdescending (sdrop ?k ?w)\n  sdescending w\n\ngoal (1 subgoal):\n 1. sdescending (sdrop k w)", "by this"], ["proof (state)\nthis:\n  sdescending (sdrop k w)\n\ngoal (1 subgoal):\n 1. \\<And>n. w !! Suc n \\<le> w !! n", "then"], ["proof (chain)\npicking this:\n  sdescending (sdrop k w)", "obtain a b v where 2: \"sdrop k w = a ## b ## v\" \"a \\<ge> b\""], ["proof (prove)\nusing this:\n  sdescending (sdrop k w)\n\ngoal (1 subgoal):\n 1. (\\<And>a b v.\n        \\<lbrakk>sdrop k w = a ## b ## v; b \\<le> a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by rule"], ["proof (state)\nthis:\n  sdrop k w = a ## b ## v\n  b \\<le> a\n\ngoal (1 subgoal):\n 1. \\<And>n. w !! Suc n \\<le> w !! n", "then"], ["proof (chain)\npicking this:\n  sdrop k w = a ## b ## v\n  b \\<le> a", "show \"w !! k \\<ge> w !! Suc k\""], ["proof (prove)\nusing this:\n  sdrop k w = a ## b ## v\n  b \\<le> a\n\ngoal (1 subgoal):\n 1. w !! Suc k \\<le> w !! k", "by (metis sdrop_simps stream.sel)"], ["proof (state)\nthis:\n  w !! Suc k \\<le> w !! k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sdescending_stuck:\n    fixes w :: \"'a :: wellorder stream\"\n    assumes \"sdescending w\"\n    obtains k\n    where \"sdrop k w = sconst (w !! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        sdrop k w = sconst (w !! k) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  sdescending w\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        sdrop k w = sconst (w !! k) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof (induct \"w !! 0\" arbitrary: w thesis rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w thesis.\n       \\<lbrakk>\\<And>wa thesis.\n                   \\<lbrakk>wa !! 0 < w !! 0;\n                    \\<And>k.\n                       sdrop k wa = sconst (wa !! k) \\<Longrightarrow>\n                       thesis;\n                    sdescending wa\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>k. sdrop k w = sconst (w !! k) \\<Longrightarrow> thesis;\n        sdescending w\\<rbrakk>\n       \\<Longrightarrow> thesis", "case less"], ["proof (state)\nthis:\n  \\<lbrakk>?w !! 0 < w !! 0;\n   \\<And>k. sdrop k ?w = sconst (?w !! k) \\<Longrightarrow> ?thesis;\n   sdescending ?w\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  sdrop ?k w = sconst (w !! ?k) \\<Longrightarrow> thesis\n  sdescending w\n\ngoal (1 subgoal):\n 1. \\<And>w thesis.\n       \\<lbrakk>\\<And>wa thesis.\n                   \\<lbrakk>wa !! 0 < w !! 0;\n                    \\<And>k.\n                       sdrop k wa = sconst (wa !! k) \\<Longrightarrow>\n                       thesis;\n                    sdescending wa\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>k. sdrop k w = sconst (w !! k) \\<Longrightarrow> thesis;\n        sdescending w\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (cases \"w = sconst (w !! 0)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. w = sconst (w !! 0) \\<Longrightarrow> thesis\n 2. w \\<noteq> sconst (w !! 0) \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  w = sconst (w !! 0)\n\ngoal (2 subgoals):\n 1. w = sconst (w !! 0) \\<Longrightarrow> thesis\n 2. w \\<noteq> sconst (w !! 0) \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using less(2)[of 0] True"], ["proof (prove)\nusing this:\n  sdrop 0 w = sconst (w !! 0) \\<Longrightarrow> thesis\n  w = sconst (w !! 0)\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. w \\<noteq> sconst (w !! 0) \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<noteq> sconst (w !! 0) \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  w \\<noteq> sconst (w !! 0)\n\ngoal (1 subgoal):\n 1. w \\<noteq> sconst (w !! 0) \\<Longrightarrow> thesis", "obtain k where 1: \"w !! k \\<noteq> w !! 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        w !! k \\<noteq> w !! 0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using False"], ["proof (prove)\nusing this:\n  w \\<noteq> sconst (w !! 0)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        w !! k \\<noteq> w !! 0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis empty_iff eqI_snth insert_iff snth_sset sset_sconst)"], ["proof (state)\nthis:\n  w !! k \\<noteq> w !! 0\n\ngoal (1 subgoal):\n 1. w \\<noteq> sconst (w !! 0) \\<Longrightarrow> thesis", "have 2: \"antimono (snth w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. antimono ((!!) w)", "using sdescending_snth_antimono less(3)"], ["proof (prove)\nusing this:\n  sdescending ?w \\<Longrightarrow> antimono ((!!) ?w)\n  sdescending w\n\ngoal (1 subgoal):\n 1. antimono ((!!) w)", "by this"], ["proof (state)\nthis:\n  antimono ((!!) w)\n\ngoal (1 subgoal):\n 1. w \\<noteq> sconst (w !! 0) \\<Longrightarrow> thesis", "have 3: \"w !! k \\<le> w !! 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w !! k \\<le> w !! 0", "using 1 2"], ["proof (prove)\nusing this:\n  w !! k \\<noteq> w !! 0\n  antimono ((!!) w)\n\ngoal (1 subgoal):\n 1. w !! k \\<le> w !! 0", "by (blast dest: antimonoD)"], ["proof (state)\nthis:\n  w !! k \\<le> w !! 0\n\ngoal (1 subgoal):\n 1. w \\<noteq> sconst (w !! 0) \\<Longrightarrow> thesis", "have 4: \"sdrop k w !! 0 < w !! 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sdrop k w !! 0 < w !! 0", "using 1 3"], ["proof (prove)\nusing this:\n  w !! k \\<noteq> w !! 0\n  w !! k \\<le> w !! 0\n\ngoal (1 subgoal):\n 1. sdrop k w !! 0 < w !! 0", "by auto"], ["proof (state)\nthis:\n  sdrop k w !! 0 < w !! 0\n\ngoal (1 subgoal):\n 1. w \\<noteq> sconst (w !! 0) \\<Longrightarrow> thesis", "have 5: \"sdescending (sdrop k w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sdescending (sdrop k w)", "using sdescending_sdrop less(3)"], ["proof (prove)\nusing this:\n  sdescending ?w \\<Longrightarrow> sdescending (sdrop ?k ?w)\n  sdescending w\n\ngoal (1 subgoal):\n 1. sdescending (sdrop k w)", "by this"], ["proof (state)\nthis:\n  sdescending (sdrop k w)\n\ngoal (1 subgoal):\n 1. w \\<noteq> sconst (w !! 0) \\<Longrightarrow> thesis", "obtain l where 5: \"sdrop l (sdrop k w) = sconst (sdrop k w !! l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l.\n        sdrop l (sdrop k w) = sconst (sdrop k w !! l) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using less(1)[OF 4 _ 5]"], ["proof (prove)\nusing this:\n  (\\<And>ka.\n      sdrop ka (sdrop k w) = sconst (sdrop k w !! ka) \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        sdrop l (sdrop k w) = sconst (sdrop k w !! l) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by this"], ["proof (state)\nthis:\n  sdrop l (sdrop k w) = sconst (sdrop k w !! l)\n\ngoal (1 subgoal):\n 1. w \\<noteq> sconst (w !! 0) \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using less(2) 5"], ["proof (prove)\nusing this:\n  sdrop ?k w = sconst (w !! ?k) \\<Longrightarrow> thesis\n  sdrop l (sdrop k w) = sconst (sdrop k w !! l)\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}