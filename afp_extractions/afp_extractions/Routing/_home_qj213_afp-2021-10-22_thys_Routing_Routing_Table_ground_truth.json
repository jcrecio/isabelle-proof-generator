{"file_name": "/home/qj213/afp-2021-10-22/thys/Routing/Routing_Table.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Routing", "problem_names": ["lemma valid_prefixes_split: \"valid_prefixes (r#rs) \\<Longrightarrow> valid_prefix (routing_match r) \\<and> valid_prefixes rs\"", "lemma foldr_True_set: \"foldr (\\<lambda>x. (\\<and>) (f x)) l True = (\\<forall>x \\<in> set l. f x)\"", "lemma valid_prefixes_alt_def: \"valid_prefixes r = (\\<forall>e \\<in> set r. valid_prefix (routing_match e))\"", "lemma has_default_route_alt: \"has_default_route rt \\<longleftrightarrow> (\\<exists>r \\<in> set rt. pfxm_length (routing_match r) = 0)\"", "lemma routing_table_semantics_ports_from_table: \"valid_prefixes rtbl \\<Longrightarrow> has_default_route rtbl \\<Longrightarrow> \n  routing_table_semantics rtbl packet = r \\<Longrightarrow> r \\<in> routing_action ` set rtbl\"", "lemma is_longest_prefix_routing_rule_exclusion:\n  assumes \"is_longest_prefix_routing (r1 # rn # rss)\"\n  shows \"is_longest_prefix_routing (r1 # rss)\"", "lemma int_of_nat_less: \"int_of_nat a < int_of_nat b \\<Longrightarrow> a < b\"", "lemma is_longest_prefix_routing_sorted_by_length:\n  assumes \"is_longest_prefix_routing r\"\n     and \"r = r1 # rs @ r2 # rss\"\n  shows \"(pfxm_length (routing_match r1) \\<ge> pfxm_length (routing_match r2))\"", "lemma is_longest_prefix_routing_sort: \"is_longest_prefix_routing (sort_rtbl r)\"", "lemma unambiguous_routing_Cons: \"unambiguous_routing (r # rtbl) \\<Longrightarrow> unambiguous_routing rtbl\"", "lemma \"unambiguous_routing (rr # rtbl) \\<Longrightarrow> is_longest_prefix_routing (rr # rtbl) \\<Longrightarrow> ra \\<in> set rtbl \\<Longrightarrow> routing_match rr = routing_match ra \\<Longrightarrow> routing_rule_sort_key rr < routing_rule_sort_key ra\"", "lemma unambiguous_routing_code[code_unfold]: \"unambiguous_routing rtbl \\<longleftrightarrow> unambiguous_routing_code rtbl\"", "lemma unambigous_prefix_routing_weak_mono:\n  assumes lpfx: \"is_longest_prefix_routing (rr#rtbl)\"\n  assumes e:\"rr' \\<in> set rtbl\"\n  shows \"routing_rule_sort_key rr' \\<ge> routing_rule_sort_key rr\"", "lemma unambigous_prefix_routing_strong_mono:\n  assumes lpfx: \"is_longest_prefix_routing (rr#rtbl)\" \n  assumes uam: \"unambiguous_routing (rr#rtbl)\" \n  assumes e:\"rr' \\<in> set rtbl\"\n  assumes ne: \"routing_match rr' = routing_match rr\"\n  shows \"routing_rule_sort_key rr' > routing_rule_sort_key rr\"", "lemma \"routing_rule_sort_key (rr_ctor (0,0,0,0) 8 [] None 0) > routing_rule_sort_key (rr_ctor (0,0,0,0) 24 [] None 0)\"", "theorem existential_routing: \"valid_prefixes rtbl \\<Longrightarrow> is_longest_prefix_routing rtbl \\<Longrightarrow> has_default_route rtbl \\<Longrightarrow> unambiguous_routing rtbl \\<Longrightarrow>\nrouting_table_semantics rtbl addr = act \\<longleftrightarrow> (\\<exists>rr \\<in> set rtbl. prefix_match_semantics (routing_match rr) addr \\<and> routing_action rr = act \\<and>\n  (\\<forall>ra \\<in> set rtbl. routing_rule_sort_key ra < routing_rule_sort_key rr \\<longrightarrow> \\<not>prefix_match_semantics (routing_match ra) addr))\"", "lemma \"map routing_rule_32_toString \n[rr_ctor (42,0,0,0) 7 ''eth0'' None 808, \n rr_ctor (0,0,0,0) 0 ''eth1'' (Some (222,173,190,239)) 707] =\n[''42.0.0.0/7 dev eth0 metric 808'',\n ''0.0.0.0/0 via 222.173.190.239 dev eth1 metric 707'']\"", "lemma ipset_prefix_match_m[simp]:  \"fst (ipset_prefix_match pfx rg) = rg \\<inter> (prefix_to_wordset pfx)\"", "lemma ipset_prefix_match_nm[simp]: \"snd (ipset_prefix_match pfx rg) = rg - (prefix_to_wordset pfx)\"", "lemma ipset_prefix_match_distinct: \"rpm = ipset_prefix_match pfx rg \\<Longrightarrow> \n  (fst rpm) \\<inter> (snd rpm) = {}\"", "lemma ipset_prefix_match_complete: \"rpm = ipset_prefix_match pfx rg \\<Longrightarrow> \n  (fst rpm) \\<union> (snd rpm) = rg\"", "lemma rpm_m_dup_simp: \"rg \\<inter> fst (ipset_prefix_match (routing_match r) rg) = fst (ipset_prefix_match (routing_match r) rg)\"", "lemma range_prefix_match_set_eq:\n  \"(\\<lambda>(r1,r2). (wordinterval_to_set r1, wordinterval_to_set r2)) (range_prefix_match pfx rg) =\n    ipset_prefix_match pfx (wordinterval_to_set rg)\"", "lemma range_prefix_match_sm[simp]:  \"wordinterval_to_set (fst (range_prefix_match pfx rg)) = \n    fst (ipset_prefix_match pfx (wordinterval_to_set rg))\"", "lemma range_prefix_match_snm[simp]: \"wordinterval_to_set (snd (range_prefix_match pfx rg)) =\n    snd (ipset_prefix_match pfx (wordinterval_to_set rg))\"", "lemma routing_port_ranges_subsets:\n\"(a1, b1) \\<in> set (routing_port_ranges tbl s) \\<Longrightarrow> wordinterval_to_set b1 \\<subseteq> wordinterval_to_set s\"", "lemma routing_port_ranges_sound: \"e \\<in> set (routing_port_ranges tbl s) \\<Longrightarrow> k \\<in> wordinterval_to_set (snd e) \\<Longrightarrow> valid_prefixes tbl \\<Longrightarrow>\n\tfst e = output_iface (routing_table_semantics tbl k)\"", "lemma routing_port_ranges_disjoined:\nassumes vpfx: \"valid_prefixes tbl\"\n  and ins:  \"(a1, b1) \\<in> set (routing_port_ranges tbl s)\" \"(a2, b2) \\<in> set (routing_port_ranges tbl s)\"\n  and nemp: \"wordinterval_to_set b1 \\<noteq> {}\"\nshows \"b1 \\<noteq> b2 \\<longleftrightarrow> wordinterval_to_set b1 \\<inter> wordinterval_to_set b2 = {}\"", "lemma routing_port_rangesI:\n\"valid_prefixes tbl \\<Longrightarrow>\n output_iface (routing_table_semantics tbl k) = output_port \\<Longrightarrow>\n k \\<in> wordinterval_to_set wi \\<Longrightarrow>\n (\\<exists>ip_range. (output_port, ip_range) \\<in> set (routing_port_ranges tbl wi) \\<and> k \\<in> wordinterval_to_set ip_range)\"", "lemma routing_ipassmt_wi_distinct: \"distinct (map fst (routing_ipassmt_wi tbl))\"", "lemma routing_port_ranges_superseted:\n\"(a1,b1) \\<in> set (routing_port_ranges tbl wordinterval_UNIV) \\<Longrightarrow> \n  \\<exists>b2. (a1,b2) \\<in> set (routing_ipassmt_wi tbl) \\<and> wordinterval_to_set b1 \\<subseteq> wordinterval_to_set b2\"", "lemma routing_ipassmt_wi_subsetted:\n\"(a1,b1) \\<in> set (routing_ipassmt_wi tbl) \\<Longrightarrow> \n (a1,b2) \\<in> set (routing_port_ranges tbl wordinterval_UNIV) \\<Longrightarrow>  wordinterval_to_set b2 \\<subseteq> wordinterval_to_set b1\"", "lemma routing_ipassmt_wi_disjoint:\nassumes vpfx: \"valid_prefixes (tbl::('i::len) prefix_routing)\"\n  and dif: \"a1 \\<noteq> a2\"\n  and ins:  \"(a1, b1) \\<in> set (routing_ipassmt_wi tbl)\" \"(a2, b2) \\<in> set (routing_ipassmt_wi tbl)\"\nshows \"wordinterval_to_set b1 \\<inter> wordinterval_to_set b2 = {}\"", "lemma routing_ipassmt_wi_sound:\n  assumes vpfx: \"valid_prefixes tbl\"\n  and ins: \"(ea,eb) \\<in> set (routing_ipassmt_wi tbl)\"\n  and x: \"k \\<in> wordinterval_to_set eb\"\n  shows \"ea = output_iface (routing_table_semantics tbl k)\"", "theorem routing_ipassmt_wi:\nassumes vpfx: \"valid_prefixes tbl\"\n  shows \n  \"output_iface (routing_table_semantics tbl k) = output_port \\<longleftrightarrow>\n    (\\<exists>ip_range. k \\<in> wordinterval_to_set ip_range \\<and> (output_port, ip_range) \\<in> set (routing_ipassmt_wi tbl))\"", "lemma routing_ipassmt_wi_has_all_interfaces:\n  assumes in_tbl: \"r \\<in> set tbl\"\n  shows \"\\<exists>s. (routing_oiface r,s) \\<in> set (routing_ipassmt_wi tbl)\""], "translations": [["", "lemma valid_prefixes_split: \"valid_prefixes (r#rs) \\<Longrightarrow> valid_prefix (routing_match r) \\<and> valid_prefixes rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_prefixes (r # rs) \\<Longrightarrow>\n    valid_prefix (routing_match r) \\<and> valid_prefixes rs", "using valid_prefixes_def"], ["proof (prove)\nusing this:\n  valid_prefixes ?r =\n  foldr (\\<and>) (map (\\<lambda>rr. valid_prefix (routing_match rr)) ?r)\n   True\n\ngoal (1 subgoal):\n 1. valid_prefixes (r # rs) \\<Longrightarrow>\n    valid_prefix (routing_match r) \\<and> valid_prefixes rs", "by force"], ["", "lemma foldr_True_set: \"foldr (\\<lambda>x. (\\<and>) (f x)) l True = (\\<forall>x \\<in> set l. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>x. (\\<and>) (f x)) l True = (\\<forall>x\\<in>set l. f x)", "by (induction l) simp_all"], ["", "lemma valid_prefixes_alt_def: \"valid_prefixes r = (\\<forall>e \\<in> set r. valid_prefix (routing_match e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_prefixes r =\n    (\\<forall>e\\<in>set r. valid_prefix (routing_match e))", "unfolding valid_prefixes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<and>) (map (\\<lambda>rr. valid_prefix (routing_match rr)) r)\n     True =\n    (\\<forall>e\\<in>set r. valid_prefix (routing_match e))", "unfolding foldr_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr ((\\<and>) \\<circ> (\\<lambda>rr. valid_prefix (routing_match rr)))\n     r True =\n    (\\<forall>e\\<in>set r. valid_prefix (routing_match e))", "unfolding comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>x. (\\<and>) (valid_prefix (routing_match x))) r True =\n    (\\<forall>e\\<in>set r. valid_prefix (routing_match e))", "unfolding foldr_True_set"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set r. valid_prefix (routing_match x)) =\n    (\\<forall>e\\<in>set r. valid_prefix (routing_match e))", ".."], ["", "fun has_default_route :: \"('i::len) prefix_routing \\<Rightarrow> bool\" where\n\"has_default_route (r#rs) = (((pfxm_length (routing_match r)) = 0) \\<or> has_default_route rs)\" |\n\"has_default_route Nil = False\""], ["", "lemma has_default_route_alt: \"has_default_route rt \\<longleftrightarrow> (\\<exists>r \\<in> set rt. pfxm_length (routing_match r) = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_default_route rt = (\\<exists>r\\<in>set rt. routing_prefix r = 0)", "by(induction rt) simp_all"], ["", "subsection\\<open>Single Packet Semantics\\<close>"], ["", "fun routing_table_semantics :: \"('i::len) prefix_routing \\<Rightarrow> 'i word \\<Rightarrow> 'i routing_action\" where\n\"routing_table_semantics [] _ = routing_action (undefined::'i routing_rule)\" | \n\"routing_table_semantics (r#rs) p = (if prefix_match_semantics (routing_match r) p then routing_action r else routing_table_semantics rs p)\""], ["", "lemma routing_table_semantics_ports_from_table: \"valid_prefixes rtbl \\<Longrightarrow> has_default_route rtbl \\<Longrightarrow> \n  routing_table_semantics rtbl packet = r \\<Longrightarrow> r \\<in> routing_action ` set rtbl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_prefixes rtbl; has_default_route rtbl;\n     routing_table_semantics rtbl packet = r\\<rbrakk>\n    \\<Longrightarrow> r \\<in> routing_action ` set rtbl", "proof(induction rtbl)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_prefixes []; has_default_route [];\n     routing_table_semantics [] packet = r\\<rbrakk>\n    \\<Longrightarrow> r \\<in> routing_action ` set []\n 2. \\<And>a rtbl.\n       \\<lbrakk>\\<lbrakk>valid_prefixes rtbl; has_default_route rtbl;\n                 routing_table_semantics rtbl packet = r\\<rbrakk>\n                \\<Longrightarrow> r \\<in> routing_action ` set rtbl;\n        valid_prefixes (a # rtbl); has_default_route (a # rtbl);\n        routing_table_semantics (a # rtbl) packet = r\\<rbrakk>\n       \\<Longrightarrow> r \\<in> routing_action ` set (a # rtbl)", "case (Cons r rs)"], ["proof (state)\nthis:\n  \\<lbrakk>valid_prefixes rs; has_default_route rs;\n   routing_table_semantics rs packet = r\\<rbrakk>\n  \\<Longrightarrow> r \\<in> routing_action ` set rs\n  valid_prefixes (r # rs)\n  has_default_route (r # rs)\n  routing_table_semantics (r # rs) packet = r\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_prefixes []; has_default_route [];\n     routing_table_semantics [] packet = r\\<rbrakk>\n    \\<Longrightarrow> r \\<in> routing_action ` set []\n 2. \\<And>a rtbl.\n       \\<lbrakk>\\<lbrakk>valid_prefixes rtbl; has_default_route rtbl;\n                 routing_table_semantics rtbl packet = r\\<rbrakk>\n                \\<Longrightarrow> r \\<in> routing_action ` set rtbl;\n        valid_prefixes (a # rtbl); has_default_route (a # rtbl);\n        routing_table_semantics (a # rtbl) packet = r\\<rbrakk>\n       \\<Longrightarrow> r \\<in> routing_action ` set (a # rtbl)", "note v_pfxs = valid_prefixes_split[OF Cons.prems(1)]"], ["proof (state)\nthis:\n  valid_prefix (routing_match r) \\<and> valid_prefixes rs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_prefixes []; has_default_route [];\n     routing_table_semantics [] packet = r\\<rbrakk>\n    \\<Longrightarrow> r \\<in> routing_action ` set []\n 2. \\<And>a rtbl.\n       \\<lbrakk>\\<lbrakk>valid_prefixes rtbl; has_default_route rtbl;\n                 routing_table_semantics rtbl packet = r\\<rbrakk>\n                \\<Longrightarrow> r \\<in> routing_action ` set rtbl;\n        valid_prefixes (a # rtbl); has_default_route (a # rtbl);\n        routing_table_semantics (a # rtbl) packet = r\\<rbrakk>\n       \\<Longrightarrow> r \\<in> routing_action ` set (a # rtbl)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<in> routing_action ` set (r # rs)", "proof(cases \"pfxm_length (routing_match r) = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. routing_prefix r = 0 \\<Longrightarrow>\n    r \\<in> routing_action ` set (r # rs)\n 2. routing_prefix r \\<noteq> 0 \\<Longrightarrow>\n    r \\<in> routing_action ` set (r # rs)", "case True"], ["proof (state)\nthis:\n  routing_prefix r = 0\n\ngoal (2 subgoals):\n 1. routing_prefix r = 0 \\<Longrightarrow>\n    r \\<in> routing_action ` set (r # rs)\n 2. routing_prefix r \\<noteq> 0 \\<Longrightarrow>\n    r \\<in> routing_action ` set (r # rs)", "note zero_prefix_match_all[OF conjunct1[OF v_pfxs] True] Cons.prems(3)"], ["proof (state)\nthis:\n  prefix_match_semantics (routing_match r) ?ip\n  routing_table_semantics (r # rs) packet = r\n\ngoal (2 subgoals):\n 1. routing_prefix r = 0 \\<Longrightarrow>\n    r \\<in> routing_action ` set (r # rs)\n 2. routing_prefix r \\<noteq> 0 \\<Longrightarrow>\n    r \\<in> routing_action ` set (r # rs)", "then"], ["proof (chain)\npicking this:\n  prefix_match_semantics (routing_match r) ?ip\n  routing_table_semantics (r # rs) packet = r", "show ?thesis"], ["proof (prove)\nusing this:\n  prefix_match_semantics (routing_match r) ?ip\n  routing_table_semantics (r # rs) packet = r\n\ngoal (1 subgoal):\n 1. r \\<in> routing_action ` set (r # rs)", "by simp"], ["proof (state)\nthis:\n  r \\<in> routing_action ` set (r # rs)\n\ngoal (1 subgoal):\n 1. routing_prefix r \\<noteq> 0 \\<Longrightarrow>\n    r \\<in> routing_action ` set (r # rs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. routing_prefix r \\<noteq> 0 \\<Longrightarrow>\n    r \\<in> routing_action ` set (r # rs)", "case False"], ["proof (state)\nthis:\n  routing_prefix r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. routing_prefix r \\<noteq> 0 \\<Longrightarrow>\n    r \\<in> routing_action ` set (r # rs)", "hence \"has_default_route rs\""], ["proof (prove)\nusing this:\n  routing_prefix r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. has_default_route rs", "using Cons.prems(2)"], ["proof (prove)\nusing this:\n  routing_prefix r \\<noteq> 0\n  has_default_route (r # rs)\n\ngoal (1 subgoal):\n 1. has_default_route rs", "by simp"], ["proof (state)\nthis:\n  has_default_route rs\n\ngoal (1 subgoal):\n 1. routing_prefix r \\<noteq> 0 \\<Longrightarrow>\n    r \\<in> routing_action ` set (r # rs)", "from Cons.IH[OF conjunct2[OF v_pfxs] this] Cons.prems(3)"], ["proof (chain)\npicking this:\n  routing_table_semantics rs packet = r \\<Longrightarrow>\n  r \\<in> routing_action ` set rs\n  routing_table_semantics (r # rs) packet = r", "show ?thesis"], ["proof (prove)\nusing this:\n  routing_table_semantics rs packet = r \\<Longrightarrow>\n  r \\<in> routing_action ` set rs\n  routing_table_semantics (r # rs) packet = r\n\ngoal (1 subgoal):\n 1. r \\<in> routing_action ` set (r # rs)", "by force"], ["proof (state)\nthis:\n  r \\<in> routing_action ` set (r # rs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r \\<in> routing_action ` set (r # rs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_prefixes []; has_default_route [];\n     routing_table_semantics [] packet = r\\<rbrakk>\n    \\<Longrightarrow> r \\<in> routing_action ` set []", "qed simp"], ["", "subsection\\<open>Longest Prefix Match\\<close>"], ["", "text\\<open>We can abuse @{const LinordHelper} to sort.\\<close>"], ["", "definition \"routing_rule_sort_key \\<equiv> \\<lambda>r. LinordHelper (0 - (of_nat :: nat \\<Rightarrow> int) (pfxm_length (routing_match r))) (metric r)\""], ["", "text\\<open>There is actually a slight design choice here. We can choose to sort based on @{thm less_eq_prefix_match_def} (thus including the address) or only the prefix length (excluding it).\n  Which is taken does not matter gravely, since the bits of the prefix can't matter. They're either eqal or the rules don't overlap and the metric decides. (It does matter for the resulting list though.)\n  Ignoring the prefix and taking only its length is slightly easier.\\<close>"], ["", "(*example: get longest prefix match by sorting by pfxm_length*)"], ["", "definition \"rr_ctor m l a nh me \\<equiv> \\<lparr> routing_match = PrefixMatch (ipv4addr_of_dotdecimal m) l, metric = me, routing_action =\\<lparr>output_iface = a, next_hop = (map_option ipv4addr_of_dotdecimal nh)\\<rparr> \\<rparr>\""], ["", "value \"sort_key routing_rule_sort_key [\n  rr_ctor (0,0,0,1) 3 '''' None 0,\n  rr_ctor (0,0,0,2) 8 [] None 0,\n  rr_ctor (0,0,0,3) 4 [] None 13,\n  rr_ctor (0,0,0,3) 4 [] None 42]\""], ["", "definition \"is_longest_prefix_routing \\<equiv> sorted \\<circ> map routing_rule_sort_key\""], ["", "definition correct_routing :: \"('i::len) prefix_routing \\<Rightarrow> bool\" where \n  \"correct_routing r \\<equiv> is_longest_prefix_routing r \\<and> valid_prefixes r\""], ["", "text\\<open>Many proofs and functions around routing require at least parts of @{const correct_routing} as an assumption.\nObviously, @{const correct_routing} is not given for arbitrary routing tables. Therefore,\n@{const correct_routing} is made to be executable and should be checked for any routing table after parsing.\nNote: @{const correct_routing} used to also require @{const has_default_route},\nbut none of the proofs require it anymore and it is not given for any routing table.\\<close>"], ["", "lemma is_longest_prefix_routing_rule_exclusion:\n  assumes \"is_longest_prefix_routing (r1 # rn # rss)\"\n  shows \"is_longest_prefix_routing (r1 # rss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_longest_prefix_routing (r1 # rss)", "using assms"], ["proof (prove)\nusing this:\n  is_longest_prefix_routing (r1 # rn # rss)\n\ngoal (1 subgoal):\n 1. is_longest_prefix_routing (r1 # rss)", "by(case_tac rss) (auto simp add: is_longest_prefix_routing_def)"], ["", "lemma int_of_nat_less: \"int_of_nat a < int_of_nat b \\<Longrightarrow> a < b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_nat a < int_of_nat b \\<Longrightarrow> a < b", "by (simp add: int_of_nat_def)"], ["", "lemma is_longest_prefix_routing_sorted_by_length:\n  assumes \"is_longest_prefix_routing r\"\n     and \"r = r1 # rs @ r2 # rss\"\n  shows \"(pfxm_length (routing_match r1) \\<ge> pfxm_length (routing_match r2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. routing_prefix r2 \\<le> routing_prefix r1", "using assms"], ["proof (prove)\nusing this:\n  is_longest_prefix_routing r\n  r = r1 # rs @ r2 # rss\n\ngoal (1 subgoal):\n 1. routing_prefix r2 \\<le> routing_prefix r1", "proof(induction rs arbitrary: r)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>is_longest_prefix_routing r; r = r1 # [] @ r2 # rss\\<rbrakk>\n       \\<Longrightarrow> routing_prefix r2 \\<le> routing_prefix r1\n 2. \\<And>a rs r.\n       \\<lbrakk>\\<And>r.\n                   \\<lbrakk>is_longest_prefix_routing r;\n                    r = r1 # rs @ r2 # rss\\<rbrakk>\n                   \\<Longrightarrow> routing_prefix r2\n                                     \\<le> routing_prefix r1;\n        is_longest_prefix_routing r; r = r1 # (a # rs) @ r2 # rss\\<rbrakk>\n       \\<Longrightarrow> routing_prefix r2 \\<le> routing_prefix r1", "case (Cons rn rs)"], ["proof (state)\nthis:\n  \\<lbrakk>is_longest_prefix_routing ?r; ?r = r1 # rs @ r2 # rss\\<rbrakk>\n  \\<Longrightarrow> routing_prefix r2 \\<le> routing_prefix r1\n  is_longest_prefix_routing r\n  r = r1 # (rn # rs) @ r2 # rss\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>is_longest_prefix_routing r; r = r1 # [] @ r2 # rss\\<rbrakk>\n       \\<Longrightarrow> routing_prefix r2 \\<le> routing_prefix r1\n 2. \\<And>a rs r.\n       \\<lbrakk>\\<And>r.\n                   \\<lbrakk>is_longest_prefix_routing r;\n                    r = r1 # rs @ r2 # rss\\<rbrakk>\n                   \\<Longrightarrow> routing_prefix r2\n                                     \\<le> routing_prefix r1;\n        is_longest_prefix_routing r; r = r1 # (a # rs) @ r2 # rss\\<rbrakk>\n       \\<Longrightarrow> routing_prefix r2 \\<le> routing_prefix r1", "let ?ro = \"r1 # rs @ r2 # rss\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>is_longest_prefix_routing r; r = r1 # [] @ r2 # rss\\<rbrakk>\n       \\<Longrightarrow> routing_prefix r2 \\<le> routing_prefix r1\n 2. \\<And>a rs r.\n       \\<lbrakk>\\<And>r.\n                   \\<lbrakk>is_longest_prefix_routing r;\n                    r = r1 # rs @ r2 # rss\\<rbrakk>\n                   \\<Longrightarrow> routing_prefix r2\n                                     \\<le> routing_prefix r1;\n        is_longest_prefix_routing r; r = r1 # (a # rs) @ r2 # rss\\<rbrakk>\n       \\<Longrightarrow> routing_prefix r2 \\<le> routing_prefix r1", "have \"is_longest_prefix_routing ?ro\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_longest_prefix_routing (r1 # rs @ r2 # rss)", "using Cons.prems is_longest_prefix_routing_rule_exclusion[of r1 rn \"rs @ r2 # rss\"]"], ["proof (prove)\nusing this:\n  is_longest_prefix_routing r\n  r = r1 # (rn # rs) @ r2 # rss\n  is_longest_prefix_routing (r1 # rn # rs @ r2 # rss) \\<Longrightarrow>\n  is_longest_prefix_routing (r1 # rs @ r2 # rss)\n\ngoal (1 subgoal):\n 1. is_longest_prefix_routing (r1 # rs @ r2 # rss)", "by simp"], ["proof (state)\nthis:\n  is_longest_prefix_routing (r1 # rs @ r2 # rss)\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>is_longest_prefix_routing r; r = r1 # [] @ r2 # rss\\<rbrakk>\n       \\<Longrightarrow> routing_prefix r2 \\<le> routing_prefix r1\n 2. \\<And>a rs r.\n       \\<lbrakk>\\<And>r.\n                   \\<lbrakk>is_longest_prefix_routing r;\n                    r = r1 # rs @ r2 # rss\\<rbrakk>\n                   \\<Longrightarrow> routing_prefix r2\n                                     \\<le> routing_prefix r1;\n        is_longest_prefix_routing r; r = r1 # (a # rs) @ r2 # rss\\<rbrakk>\n       \\<Longrightarrow> routing_prefix r2 \\<le> routing_prefix r1", "from Cons.IH[OF this]"], ["proof (chain)\npicking this:\n  r1 # rs @ r2 # rss = r1 # rs @ r2 # rss \\<Longrightarrow>\n  routing_prefix r2 \\<le> routing_prefix r1", "show ?case"], ["proof (prove)\nusing this:\n  r1 # rs @ r2 # rss = r1 # rs @ r2 # rss \\<Longrightarrow>\n  routing_prefix r2 \\<le> routing_prefix r1\n\ngoal (1 subgoal):\n 1. routing_prefix r2 \\<le> routing_prefix r1", "by simp"], ["proof (state)\nthis:\n  routing_prefix r2 \\<le> routing_prefix r1\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<lbrakk>is_longest_prefix_routing r; r = r1 # [] @ r2 # rss\\<rbrakk>\n       \\<Longrightarrow> routing_prefix r2 \\<le> routing_prefix r1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<lbrakk>is_longest_prefix_routing r; r = r1 # [] @ r2 # rss\\<rbrakk>\n       \\<Longrightarrow> routing_prefix r2 \\<le> routing_prefix r1", "case Nil"], ["proof (state)\nthis:\n  is_longest_prefix_routing r\n  r = r1 # [] @ r2 # rss\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<lbrakk>is_longest_prefix_routing r; r = r1 # [] @ r2 # rss\\<rbrakk>\n       \\<Longrightarrow> routing_prefix r2 \\<le> routing_prefix r1", "thus ?case"], ["proof (prove)\nusing this:\n  is_longest_prefix_routing r\n  r = r1 # [] @ r2 # rss\n\ngoal (1 subgoal):\n 1. routing_prefix r2 \\<le> routing_prefix r1", "by(auto simp add: is_longest_prefix_routing_def routing_rule_sort_key_def linord_helper_less_eq1_def less_eq_linord_helper_def int_of_nat_def)"], ["proof (state)\nthis:\n  routing_prefix r2 \\<le> routing_prefix r1\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"sort_rtbl :: ('i::len) routing_rule list \\<Rightarrow> 'i routing_rule list \\<equiv> sort_key routing_rule_sort_key\""], ["", "lemma is_longest_prefix_routing_sort: \"is_longest_prefix_routing (sort_rtbl r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_longest_prefix_routing (sort_rtbl r)", "unfolding sort_rtbl_def is_longest_prefix_routing_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (sorted \\<circ> map routing_rule_sort_key)\n     (sort_key routing_rule_sort_key r)", "by simp"], ["", "definition \"unambiguous_routing rtbl \\<equiv> (\\<forall>rt1 rt2 rr ra. rtbl = rt1 @ rr # rt2 \\<longrightarrow> ra \\<in> set (rt1 @ rt2) \\<longrightarrow> routing_match rr = routing_match ra \\<longrightarrow> routing_rule_sort_key rr \\<noteq> routing_rule_sort_key ra)\""], ["", "lemma unambiguous_routing_Cons: \"unambiguous_routing (r # rtbl) \\<Longrightarrow> unambiguous_routing rtbl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unambiguous_routing (r # rtbl) \\<Longrightarrow>\n    unambiguous_routing rtbl", "unfolding unambiguous_routing_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>rt1 rt2 rr ra.\n       r # rtbl = rt1 @ rr # rt2 \\<longrightarrow>\n       ra \\<in> set (rt1 @ rt2) \\<longrightarrow>\n       routing_match rr = routing_match ra \\<longrightarrow>\n       routing_rule_sort_key rr \\<noteq>\n       routing_rule_sort_key ra \\<Longrightarrow>\n    \\<forall>rt1 rt2 rr ra.\n       rtbl = rt1 @ rr # rt2 \\<longrightarrow>\n       ra \\<in> set (rt1 @ rt2) \\<longrightarrow>\n       routing_match rr = routing_match ra \\<longrightarrow>\n       routing_rule_sort_key rr \\<noteq> routing_rule_sort_key ra", "by(clarsimp) (metis append_Cons in_set_conv_decomp)"], ["", "lemma \"unambiguous_routing (rr # rtbl) \\<Longrightarrow> is_longest_prefix_routing (rr # rtbl) \\<Longrightarrow> ra \\<in> set rtbl \\<Longrightarrow> routing_match rr = routing_match ra \\<Longrightarrow> routing_rule_sort_key rr < routing_rule_sort_key ra\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unambiguous_routing (rr # rtbl);\n     is_longest_prefix_routing (rr # rtbl); ra \\<in> set rtbl;\n     routing_match rr = routing_match ra\\<rbrakk>\n    \\<Longrightarrow> routing_rule_sort_key rr < routing_rule_sort_key ra", "unfolding is_longest_prefix_routing_def unambiguous_routing_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>rt1 rt2 rra ra.\n                rr # rtbl = rt1 @ rra # rt2 \\<longrightarrow>\n                ra \\<in> set (rt1 @ rt2) \\<longrightarrow>\n                routing_match rra = routing_match ra \\<longrightarrow>\n                routing_rule_sort_key rra \\<noteq> routing_rule_sort_key ra;\n     (sorted \\<circ> map routing_rule_sort_key) (rr # rtbl);\n     ra \\<in> set rtbl; routing_match rr = routing_match ra\\<rbrakk>\n    \\<Longrightarrow> routing_rule_sort_key rr < routing_rule_sort_key ra", "by(fastforce)"], ["", "primrec unambiguous_routing_code where\n\"unambiguous_routing_code [] = True\" |\n\"unambiguous_routing_code (rr#rtbl) = (list_all (\\<lambda>ra. routing_match rr \\<noteq> routing_match ra \\<or> routing_rule_sort_key rr \\<noteq> routing_rule_sort_key ra) rtbl \\<and> unambiguous_routing_code rtbl)\""], ["", "lemma unambiguous_routing_code[code_unfold]: \"unambiguous_routing rtbl \\<longleftrightarrow> unambiguous_routing_code rtbl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unambiguous_routing rtbl = unambiguous_routing_code rtbl", "proof(induction rtbl)"], ["proof (state)\ngoal (2 subgoals):\n 1. unambiguous_routing [] = unambiguous_routing_code []\n 2. \\<And>a rtbl.\n       unambiguous_routing rtbl =\n       unambiguous_routing_code rtbl \\<Longrightarrow>\n       unambiguous_routing (a # rtbl) = unambiguous_routing_code (a # rtbl)", "case (Cons rr rtbl)"], ["proof (state)\nthis:\n  unambiguous_routing rtbl = unambiguous_routing_code rtbl\n\ngoal (2 subgoals):\n 1. unambiguous_routing [] = unambiguous_routing_code []\n 2. \\<And>a rtbl.\n       unambiguous_routing rtbl =\n       unambiguous_routing_code rtbl \\<Longrightarrow>\n       unambiguous_routing (a # rtbl) = unambiguous_routing_code (a # rtbl)", "show ?case (is \"?l \\<longleftrightarrow> ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. unambiguous_routing (rr # rtbl) = unambiguous_routing_code (rr # rtbl)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. unambiguous_routing (rr # rtbl) \\<Longrightarrow>\n    unambiguous_routing_code (rr # rtbl)\n 2. unambiguous_routing_code (rr # rtbl) \\<Longrightarrow>\n    unambiguous_routing (rr # rtbl)", "assume l: ?l"], ["proof (state)\nthis:\n  unambiguous_routing (rr # rtbl)\n\ngoal (2 subgoals):\n 1. unambiguous_routing (rr # rtbl) \\<Longrightarrow>\n    unambiguous_routing_code (rr # rtbl)\n 2. unambiguous_routing_code (rr # rtbl) \\<Longrightarrow>\n    unambiguous_routing (rr # rtbl)", "with unambiguous_routing_Cons Cons.IH"], ["proof (chain)\npicking this:\n  unambiguous_routing (?r # ?rtbl) \\<Longrightarrow>\n  unambiguous_routing ?rtbl\n  unambiguous_routing rtbl = unambiguous_routing_code rtbl\n  unambiguous_routing (rr # rtbl)", "have \"unambiguous_routing_code rtbl\""], ["proof (prove)\nusing this:\n  unambiguous_routing (?r # ?rtbl) \\<Longrightarrow>\n  unambiguous_routing ?rtbl\n  unambiguous_routing rtbl = unambiguous_routing_code rtbl\n  unambiguous_routing (rr # rtbl)\n\ngoal (1 subgoal):\n 1. unambiguous_routing_code rtbl", "by blast"], ["proof (state)\nthis:\n  unambiguous_routing_code rtbl\n\ngoal (2 subgoals):\n 1. unambiguous_routing (rr # rtbl) \\<Longrightarrow>\n    unambiguous_routing_code (rr # rtbl)\n 2. unambiguous_routing_code (rr # rtbl) \\<Longrightarrow>\n    unambiguous_routing (rr # rtbl)", "moreover"], ["proof (state)\nthis:\n  unambiguous_routing_code rtbl\n\ngoal (2 subgoals):\n 1. unambiguous_routing (rr # rtbl) \\<Longrightarrow>\n    unambiguous_routing_code (rr # rtbl)\n 2. unambiguous_routing_code (rr # rtbl) \\<Longrightarrow>\n    unambiguous_routing (rr # rtbl)", "have \"list_all (\\<lambda>ra. routing_match rr \\<noteq> routing_match ra \\<or> routing_rule_sort_key rr \\<noteq> routing_rule_sort_key ra) rtbl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>ra.\n         routing_match rr \\<noteq> routing_match ra \\<or>\n         routing_rule_sort_key rr \\<noteq> routing_rule_sort_key ra)\n     rtbl", "using l"], ["proof (prove)\nusing this:\n  unambiguous_routing (rr # rtbl)\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>ra.\n         routing_match rr \\<noteq> routing_match ra \\<or>\n         routing_rule_sort_key rr \\<noteq> routing_rule_sort_key ra)\n     rtbl", "unfolding unambiguous_routing_def"], ["proof (prove)\nusing this:\n  \\<forall>rt1 rt2 rra ra.\n     rr # rtbl = rt1 @ rra # rt2 \\<longrightarrow>\n     ra \\<in> set (rt1 @ rt2) \\<longrightarrow>\n     routing_match rra = routing_match ra \\<longrightarrow>\n     routing_rule_sort_key rra \\<noteq> routing_rule_sort_key ra\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>ra.\n         routing_match rr \\<noteq> routing_match ra \\<or>\n         routing_rule_sort_key rr \\<noteq> routing_rule_sort_key ra)\n     rtbl", "by(fastforce simp add: list_all_iff)"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>ra.\n       routing_match rr \\<noteq> routing_match ra \\<or>\n       routing_rule_sort_key rr \\<noteq> routing_rule_sort_key ra)\n   rtbl\n\ngoal (2 subgoals):\n 1. unambiguous_routing (rr # rtbl) \\<Longrightarrow>\n    unambiguous_routing_code (rr # rtbl)\n 2. unambiguous_routing_code (rr # rtbl) \\<Longrightarrow>\n    unambiguous_routing (rr # rtbl)", "ultimately"], ["proof (chain)\npicking this:\n  unambiguous_routing_code rtbl\n  list_all\n   (\\<lambda>ra.\n       routing_match rr \\<noteq> routing_match ra \\<or>\n       routing_rule_sort_key rr \\<noteq> routing_rule_sort_key ra)\n   rtbl", "show ?r"], ["proof (prove)\nusing this:\n  unambiguous_routing_code rtbl\n  list_all\n   (\\<lambda>ra.\n       routing_match rr \\<noteq> routing_match ra \\<or>\n       routing_rule_sort_key rr \\<noteq> routing_rule_sort_key ra)\n   rtbl\n\ngoal (1 subgoal):\n 1. unambiguous_routing_code (rr # rtbl)", "by simp"], ["proof (state)\nthis:\n  unambiguous_routing_code (rr # rtbl)\n\ngoal (1 subgoal):\n 1. unambiguous_routing_code (rr # rtbl) \\<Longrightarrow>\n    unambiguous_routing (rr # rtbl)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. unambiguous_routing_code (rr # rtbl) \\<Longrightarrow>\n    unambiguous_routing (rr # rtbl)", "assume r: ?r"], ["proof (state)\nthis:\n  unambiguous_routing_code (rr # rtbl)\n\ngoal (1 subgoal):\n 1. unambiguous_routing_code (rr # rtbl) \\<Longrightarrow>\n    unambiguous_routing (rr # rtbl)", "with Cons.IH"], ["proof (chain)\npicking this:\n  unambiguous_routing rtbl = unambiguous_routing_code rtbl\n  unambiguous_routing_code (rr # rtbl)", "have \"unambiguous_routing rtbl\""], ["proof (prove)\nusing this:\n  unambiguous_routing rtbl = unambiguous_routing_code rtbl\n  unambiguous_routing_code (rr # rtbl)\n\ngoal (1 subgoal):\n 1. unambiguous_routing rtbl", "by simp"], ["proof (state)\nthis:\n  unambiguous_routing rtbl\n\ngoal (1 subgoal):\n 1. unambiguous_routing_code (rr # rtbl) \\<Longrightarrow>\n    unambiguous_routing (rr # rtbl)", "from r"], ["proof (chain)\npicking this:\n  unambiguous_routing_code (rr # rtbl)", "have *: \"list_all (\\<lambda>ra. routing_match rr \\<noteq> routing_match ra \\<or>  routing_rule_sort_key rr \\<noteq> routing_rule_sort_key ra) rtbl\""], ["proof (prove)\nusing this:\n  unambiguous_routing_code (rr # rtbl)\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>ra.\n         routing_match rr \\<noteq> routing_match ra \\<or>\n         routing_rule_sort_key rr \\<noteq> routing_rule_sort_key ra)\n     rtbl", "by simp"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>ra.\n       routing_match rr \\<noteq> routing_match ra \\<or>\n       routing_rule_sort_key rr \\<noteq> routing_rule_sort_key ra)\n   rtbl\n\ngoal (1 subgoal):\n 1. unambiguous_routing_code (rr # rtbl) \\<Longrightarrow>\n    unambiguous_routing (rr # rtbl)", "have False if \"rr # rtbl = rt1 @ rra # rt2\" \"ra \\<in> set (rt1 @ rt2)\" \"routing_rule_sort_key rra = routing_rule_sort_key ra \\<and> routing_match rra = routing_match ra\" for rt1 rt2 rra ra"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof(cases \"rt1 = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. rt1 = [] \\<Longrightarrow> False\n 2. rt1 \\<noteq> [] \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  rt1 = []\n\ngoal (2 subgoals):\n 1. rt1 = [] \\<Longrightarrow> False\n 2. rt1 \\<noteq> [] \\<Longrightarrow> False", "thus ?thesis"], ["proof (prove)\nusing this:\n  rt1 = []\n\ngoal (1 subgoal):\n 1. False", "using that *"], ["proof (prove)\nusing this:\n  rt1 = []\n  rr # rtbl = rt1 @ rra # rt2\n  ra \\<in> set (rt1 @ rt2)\n  routing_rule_sort_key rra = routing_rule_sort_key ra \\<and>\n  routing_match rra = routing_match ra\n  list_all\n   (\\<lambda>ra.\n       routing_match rr \\<noteq> routing_match ra \\<or>\n       routing_rule_sort_key rr \\<noteq> routing_rule_sort_key ra)\n   rtbl\n\ngoal (1 subgoal):\n 1. False", "by(fastforce simp add: list_all_iff)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. rt1 \\<noteq> [] \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. rt1 \\<noteq> [] \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  rt1 \\<noteq> []\n\ngoal (1 subgoal):\n 1. rt1 \\<noteq> [] \\<Longrightarrow> False", "with that(1)"], ["proof (chain)\npicking this:\n  rr # rtbl = rt1 @ rra # rt2\n  rt1 \\<noteq> []", "have rtbl: \"rtbl = tl rt1 @ rra # rt2\""], ["proof (prove)\nusing this:\n  rr # rtbl = rt1 @ rra # rt2\n  rt1 \\<noteq> []\n\ngoal (1 subgoal):\n 1. rtbl = tl rt1 @ rra # rt2", "by (metis list.sel(3) tl_append2)"], ["proof (state)\nthis:\n  rtbl = tl rt1 @ rra # rt2\n\ngoal (1 subgoal):\n 1. rt1 \\<noteq> [] \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof(cases \"ra = hd rt1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ra = hd rt1 \\<Longrightarrow> False\n 2. ra \\<noteq> hd rt1 \\<Longrightarrow> False", "(* meh case split\\<dots> *)"], ["proof (state)\ngoal (2 subgoals):\n 1. ra = hd rt1 \\<Longrightarrow> False\n 2. ra \\<noteq> hd rt1 \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  ra \\<noteq> hd rt1\n\ngoal (2 subgoals):\n 1. ra = hd rt1 \\<Longrightarrow> False\n 2. ra \\<noteq> hd rt1 \\<Longrightarrow> False", "hence \"ra \\<in> set (tl rt1 @ rt2)\""], ["proof (prove)\nusing this:\n  ra \\<noteq> hd rt1\n\ngoal (1 subgoal):\n 1. ra \\<in> set (tl rt1 @ rt2)", "using that"], ["proof (prove)\nusing this:\n  ra \\<noteq> hd rt1\n  rr # rtbl = rt1 @ rra # rt2\n  ra \\<in> set (rt1 @ rt2)\n  routing_rule_sort_key rra = routing_rule_sort_key ra \\<and>\n  routing_match rra = routing_match ra\n\ngoal (1 subgoal):\n 1. ra \\<in> set (tl rt1 @ rt2)", "by(cases rt1; simp)"], ["proof (state)\nthis:\n  ra \\<in> set (tl rt1 @ rt2)\n\ngoal (2 subgoals):\n 1. ra = hd rt1 \\<Longrightarrow> False\n 2. ra \\<noteq> hd rt1 \\<Longrightarrow> False", "with \\<open>unambiguous_routing rtbl\\<close>"], ["proof (chain)\npicking this:\n  unambiguous_routing rtbl\n  ra \\<in> set (tl rt1 @ rt2)", "show ?thesis"], ["proof (prove)\nusing this:\n  unambiguous_routing rtbl\n  ra \\<in> set (tl rt1 @ rt2)\n\ngoal (1 subgoal):\n 1. False", "using that(3) rtbl"], ["proof (prove)\nusing this:\n  unambiguous_routing rtbl\n  ra \\<in> set (tl rt1 @ rt2)\n  routing_rule_sort_key rra = routing_rule_sort_key ra \\<and>\n  routing_match rra = routing_match ra\n  rtbl = tl rt1 @ rra # rt2\n\ngoal (1 subgoal):\n 1. False", "unfolding unambiguous_routing_def"], ["proof (prove)\nusing this:\n  \\<forall>rt1 rt2 rr ra.\n     rtbl = rt1 @ rr # rt2 \\<longrightarrow>\n     ra \\<in> set (rt1 @ rt2) \\<longrightarrow>\n     routing_match rr = routing_match ra \\<longrightarrow>\n     routing_rule_sort_key rr \\<noteq> routing_rule_sort_key ra\n  ra \\<in> set (tl rt1 @ rt2)\n  routing_rule_sort_key rra = routing_rule_sort_key ra \\<and>\n  routing_match rra = routing_match ra\n  rtbl = tl rt1 @ rra # rt2\n\ngoal (1 subgoal):\n 1. False", "by fast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. ra = hd rt1 \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ra = hd rt1 \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  ra = hd rt1\n\ngoal (1 subgoal):\n 1. ra = hd rt1 \\<Longrightarrow> False", "hence \"rr = ra\""], ["proof (prove)\nusing this:\n  ra = hd rt1\n\ngoal (1 subgoal):\n 1. rr = ra", "using that \\<open>rt1 \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  ra = hd rt1\n  rr # rtbl = rt1 @ rra # rt2\n  ra \\<in> set (rt1 @ rt2)\n  routing_rule_sort_key rra = routing_rule_sort_key ra \\<and>\n  routing_match rra = routing_match ra\n  rt1 \\<noteq> []\n\ngoal (1 subgoal):\n 1. rr = ra", "by(cases rt1; simp)"], ["proof (state)\nthis:\n  rr = ra\n\ngoal (1 subgoal):\n 1. ra = hd rt1 \\<Longrightarrow> False", "thus ?thesis"], ["proof (prove)\nusing this:\n  rr = ra\n\ngoal (1 subgoal):\n 1. False", "using that *"], ["proof (prove)\nusing this:\n  rr = ra\n  rr # rtbl = rt1 @ rra # rt2\n  ra \\<in> set (rt1 @ rt2)\n  routing_rule_sort_key rra = routing_rule_sort_key ra \\<and>\n  routing_match rra = routing_match ra\n  list_all\n   (\\<lambda>ra.\n       routing_match rr \\<noteq> routing_match ra \\<or>\n       routing_rule_sort_key rr \\<noteq> routing_rule_sort_key ra)\n   rtbl\n\ngoal (1 subgoal):\n 1. False", "unfolding rtbl"], ["proof (prove)\nusing this:\n  rr = ra\n  rr # tl rt1 @ rra # rt2 = rt1 @ rra # rt2\n  ra \\<in> set (rt1 @ rt2)\n  routing_rule_sort_key rra = routing_rule_sort_key ra \\<and>\n  routing_match rra = routing_match ra\n  list_all\n   (\\<lambda>ra.\n       routing_match rr \\<noteq> routing_match ra \\<or>\n       routing_rule_sort_key rr \\<noteq> routing_rule_sort_key ra)\n   (tl rt1 @ rra # rt2)\n\ngoal (1 subgoal):\n 1. False", "by(fastforce simp add: list_all_iff)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>rr # rtbl = ?rt1.0 @ ?rra # ?rt2.0;\n   ?ra \\<in> set (?rt1.0 @ ?rt2.0);\n   routing_rule_sort_key ?rra = routing_rule_sort_key ?ra \\<and>\n   routing_match ?rra = routing_match ?ra\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. unambiguous_routing_code (rr # rtbl) \\<Longrightarrow>\n    unambiguous_routing (rr # rtbl)", "thus ?l"], ["proof (prove)\nusing this:\n  \\<lbrakk>rr # rtbl = ?rt1.0 @ ?rra # ?rt2.0;\n   ?ra \\<in> set (?rt1.0 @ ?rt2.0);\n   routing_rule_sort_key ?rra = routing_rule_sort_key ?ra \\<and>\n   routing_match ?rra = routing_match ?ra\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. unambiguous_routing (rr # rtbl)", "unfolding unambiguous_routing_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>rr # rtbl = ?rt1.0 @ ?rra # ?rt2.0;\n   ?ra \\<in> set (?rt1.0 @ ?rt2.0);\n   routing_rule_sort_key ?rra = routing_rule_sort_key ?ra \\<and>\n   routing_match ?rra = routing_match ?ra\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<forall>rt1 rt2 rra ra.\n       rr # rtbl = rt1 @ rra # rt2 \\<longrightarrow>\n       ra \\<in> set (rt1 @ rt2) \\<longrightarrow>\n       routing_match rra = routing_match ra \\<longrightarrow>\n       routing_rule_sort_key rra \\<noteq> routing_rule_sort_key ra", "by blast"], ["proof (state)\nthis:\n  unambiguous_routing (rr # rtbl)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  unambiguous_routing (rr # rtbl) = unambiguous_routing_code (rr # rtbl)\n\ngoal (1 subgoal):\n 1. unambiguous_routing [] = unambiguous_routing_code []", "qed(simp add: unambiguous_routing_def)"], ["", "lemma unambigous_prefix_routing_weak_mono:\n  assumes lpfx: \"is_longest_prefix_routing (rr#rtbl)\"\n  assumes e:\"rr' \\<in> set rtbl\"\n  shows \"routing_rule_sort_key rr' \\<ge> routing_rule_sort_key rr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. routing_rule_sort_key rr \\<le> routing_rule_sort_key rr'", "using assms"], ["proof (prove)\nusing this:\n  is_longest_prefix_routing (rr # rtbl)\n  rr' \\<in> set rtbl\n\ngoal (1 subgoal):\n 1. routing_rule_sort_key rr \\<le> routing_rule_sort_key rr'", "by(simp add: is_longest_prefix_routing_def)"], ["", "lemma unambigous_prefix_routing_strong_mono:\n  assumes lpfx: \"is_longest_prefix_routing (rr#rtbl)\" \n  assumes uam: \"unambiguous_routing (rr#rtbl)\" \n  assumes e:\"rr' \\<in> set rtbl\"\n  assumes ne: \"routing_match rr' = routing_match rr\"\n  shows \"routing_rule_sort_key rr' > routing_rule_sort_key rr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. routing_rule_sort_key rr < routing_rule_sort_key rr'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. routing_rule_sort_key rr < routing_rule_sort_key rr'", "from uam e ne"], ["proof (chain)\npicking this:\n  unambiguous_routing (rr # rtbl)\n  rr' \\<in> set rtbl\n  routing_match rr' = routing_match rr", "have \"routing_rule_sort_key rr \\<noteq> routing_rule_sort_key rr'\""], ["proof (prove)\nusing this:\n  unambiguous_routing (rr # rtbl)\n  rr' \\<in> set rtbl\n  routing_match rr' = routing_match rr\n\ngoal (1 subgoal):\n 1. routing_rule_sort_key rr \\<noteq> routing_rule_sort_key rr'", "by(fastforce simp add: unambiguous_routing_def)"], ["proof (state)\nthis:\n  routing_rule_sort_key rr \\<noteq> routing_rule_sort_key rr'\n\ngoal (1 subgoal):\n 1. routing_rule_sort_key rr < routing_rule_sort_key rr'", "moreover"], ["proof (state)\nthis:\n  routing_rule_sort_key rr \\<noteq> routing_rule_sort_key rr'\n\ngoal (1 subgoal):\n 1. routing_rule_sort_key rr < routing_rule_sort_key rr'", "from unambigous_prefix_routing_weak_mono lpfx e"], ["proof (chain)\npicking this:\n  \\<lbrakk>is_longest_prefix_routing (?rr # ?rtbl);\n   ?rr' \\<in> set ?rtbl\\<rbrakk>\n  \\<Longrightarrow> routing_rule_sort_key ?rr\n                    \\<le> routing_rule_sort_key ?rr'\n  is_longest_prefix_routing (rr # rtbl)\n  rr' \\<in> set rtbl", "have \"routing_rule_sort_key rr \\<le> routing_rule_sort_key rr'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>is_longest_prefix_routing (?rr # ?rtbl);\n   ?rr' \\<in> set ?rtbl\\<rbrakk>\n  \\<Longrightarrow> routing_rule_sort_key ?rr\n                    \\<le> routing_rule_sort_key ?rr'\n  is_longest_prefix_routing (rr # rtbl)\n  rr' \\<in> set rtbl\n\ngoal (1 subgoal):\n 1. routing_rule_sort_key rr \\<le> routing_rule_sort_key rr'", "."], ["proof (state)\nthis:\n  routing_rule_sort_key rr \\<le> routing_rule_sort_key rr'\n\ngoal (1 subgoal):\n 1. routing_rule_sort_key rr < routing_rule_sort_key rr'", "ultimately"], ["proof (chain)\npicking this:\n  routing_rule_sort_key rr \\<noteq> routing_rule_sort_key rr'\n  routing_rule_sort_key rr \\<le> routing_rule_sort_key rr'", "show ?thesis"], ["proof (prove)\nusing this:\n  routing_rule_sort_key rr \\<noteq> routing_rule_sort_key rr'\n  routing_rule_sort_key rr \\<le> routing_rule_sort_key rr'\n\ngoal (1 subgoal):\n 1. routing_rule_sort_key rr < routing_rule_sort_key rr'", "by simp"], ["proof (state)\nthis:\n  routing_rule_sort_key rr < routing_rule_sort_key rr'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \"routing_rule_sort_key (rr_ctor (0,0,0,0) 8 [] None 0) > routing_rule_sort_key (rr_ctor (0,0,0,0) 24 [] None 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. routing_rule_sort_key (rr_ctor (0, 0, 0, 0) 24 [] None 0)\n    < routing_rule_sort_key (rr_ctor (0, 0, 0, 0) 8 [] None 0)", "by eval"], ["", "(* get the inequality right\\<dots> bigger means lower priority *)"], ["", "text\\<open>In case you don't like that formulation of @{const is_longest_prefix_routing} over sorting, this is your lemma.\\<close>"], ["", "theorem existential_routing: \"valid_prefixes rtbl \\<Longrightarrow> is_longest_prefix_routing rtbl \\<Longrightarrow> has_default_route rtbl \\<Longrightarrow> unambiguous_routing rtbl \\<Longrightarrow>\nrouting_table_semantics rtbl addr = act \\<longleftrightarrow> (\\<exists>rr \\<in> set rtbl. prefix_match_semantics (routing_match rr) addr \\<and> routing_action rr = act \\<and>\n  (\\<forall>ra \\<in> set rtbl. routing_rule_sort_key ra < routing_rule_sort_key rr \\<longrightarrow> \\<not>prefix_match_semantics (routing_match ra) addr))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_prefixes rtbl; is_longest_prefix_routing rtbl;\n     has_default_route rtbl; unambiguous_routing rtbl\\<rbrakk>\n    \\<Longrightarrow> (routing_table_semantics rtbl addr = act) =\n                      (\\<exists>rr\\<in>set rtbl.\n                          prefix_match_semantics (routing_match rr)\n                           addr \\<and>\n                          routing_action rr = act \\<and>\n                          (\\<forall>ra\\<in>set rtbl.\n                              routing_rule_sort_key ra\n                              < routing_rule_sort_key rr \\<longrightarrow>\n                              \\<not> prefix_match_semantics\n(routing_match ra) addr))", "proof(induction rtbl)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_prefixes []; is_longest_prefix_routing [];\n     has_default_route []; unambiguous_routing []\\<rbrakk>\n    \\<Longrightarrow> (routing_table_semantics [] addr = act) =\n                      (\\<exists>rr\\<in>set [].\n                          prefix_match_semantics (routing_match rr)\n                           addr \\<and>\n                          routing_action rr = act \\<and>\n                          (\\<forall>ra\\<in>set [].\n                              routing_rule_sort_key ra\n                              < routing_rule_sort_key rr \\<longrightarrow>\n                              \\<not> prefix_match_semantics\n(routing_match ra) addr))\n 2. \\<And>a rtbl.\n       \\<lbrakk>\\<lbrakk>valid_prefixes rtbl;\n                 is_longest_prefix_routing rtbl; has_default_route rtbl;\n                 unambiguous_routing rtbl\\<rbrakk>\n                \\<Longrightarrow> (routing_table_semantics rtbl addr =\n                                   act) =\n                                  (\\<exists>rr\\<in>set rtbl.\nprefix_match_semantics (routing_match rr) addr \\<and>\nrouting_action rr = act \\<and>\n(\\<forall>ra\\<in>set rtbl.\n    routing_rule_sort_key ra < routing_rule_sort_key rr \\<longrightarrow>\n    \\<not> prefix_match_semantics (routing_match ra) addr));\n        valid_prefixes (a # rtbl); is_longest_prefix_routing (a # rtbl);\n        has_default_route (a # rtbl);\n        unambiguous_routing (a # rtbl)\\<rbrakk>\n       \\<Longrightarrow> (routing_table_semantics (a # rtbl) addr = act) =\n                         (\\<exists>rr\\<in>set (a # rtbl).\n                             prefix_match_semantics (routing_match rr)\n                              addr \\<and>\n                             routing_action rr = act \\<and>\n                             (\\<forall>ra\\<in>set (a # rtbl).\n                                 routing_rule_sort_key ra\n                                 < routing_rule_sort_key\n                                    rr \\<longrightarrow>\n                                 \\<not> prefix_match_semantics\n   (routing_match ra) addr))", "case Nil"], ["proof (state)\nthis:\n  valid_prefixes []\n  is_longest_prefix_routing []\n  has_default_route []\n  unambiguous_routing []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_prefixes []; is_longest_prefix_routing [];\n     has_default_route []; unambiguous_routing []\\<rbrakk>\n    \\<Longrightarrow> (routing_table_semantics [] addr = act) =\n                      (\\<exists>rr\\<in>set [].\n                          prefix_match_semantics (routing_match rr)\n                           addr \\<and>\n                          routing_action rr = act \\<and>\n                          (\\<forall>ra\\<in>set [].\n                              routing_rule_sort_key ra\n                              < routing_rule_sort_key rr \\<longrightarrow>\n                              \\<not> prefix_match_semantics\n(routing_match ra) addr))\n 2. \\<And>a rtbl.\n       \\<lbrakk>\\<lbrakk>valid_prefixes rtbl;\n                 is_longest_prefix_routing rtbl; has_default_route rtbl;\n                 unambiguous_routing rtbl\\<rbrakk>\n                \\<Longrightarrow> (routing_table_semantics rtbl addr =\n                                   act) =\n                                  (\\<exists>rr\\<in>set rtbl.\nprefix_match_semantics (routing_match rr) addr \\<and>\nrouting_action rr = act \\<and>\n(\\<forall>ra\\<in>set rtbl.\n    routing_rule_sort_key ra < routing_rule_sort_key rr \\<longrightarrow>\n    \\<not> prefix_match_semantics (routing_match ra) addr));\n        valid_prefixes (a # rtbl); is_longest_prefix_routing (a # rtbl);\n        has_default_route (a # rtbl);\n        unambiguous_routing (a # rtbl)\\<rbrakk>\n       \\<Longrightarrow> (routing_table_semantics (a # rtbl) addr = act) =\n                         (\\<exists>rr\\<in>set (a # rtbl).\n                             prefix_match_semantics (routing_match rr)\n                              addr \\<and>\n                             routing_action rr = act \\<and>\n                             (\\<forall>ra\\<in>set (a # rtbl).\n                                 routing_rule_sort_key ra\n                                 < routing_rule_sort_key\n                                    rr \\<longrightarrow>\n                                 \\<not> prefix_match_semantics\n   (routing_match ra) addr))", "thus ?case"], ["proof (prove)\nusing this:\n  valid_prefixes []\n  is_longest_prefix_routing []\n  has_default_route []\n  unambiguous_routing []\n\ngoal (1 subgoal):\n 1. (routing_table_semantics [] addr = act) =\n    (\\<exists>rr\\<in>set [].\n        prefix_match_semantics (routing_match rr) addr \\<and>\n        routing_action rr = act \\<and>\n        (\\<forall>ra\\<in>set [].\n            routing_rule_sort_key ra\n            < routing_rule_sort_key rr \\<longrightarrow>\n            \\<not> prefix_match_semantics (routing_match ra) addr))", "by simp"], ["proof (state)\nthis:\n  (routing_table_semantics [] addr = act) =\n  (\\<exists>rr\\<in>set [].\n      prefix_match_semantics (routing_match rr) addr \\<and>\n      routing_action rr = act \\<and>\n      (\\<forall>ra\\<in>set [].\n          routing_rule_sort_key ra\n          < routing_rule_sort_key rr \\<longrightarrow>\n          \\<not> prefix_match_semantics (routing_match ra) addr))\n\ngoal (1 subgoal):\n 1. \\<And>a rtbl.\n       \\<lbrakk>\\<lbrakk>valid_prefixes rtbl;\n                 is_longest_prefix_routing rtbl; has_default_route rtbl;\n                 unambiguous_routing rtbl\\<rbrakk>\n                \\<Longrightarrow> (routing_table_semantics rtbl addr =\n                                   act) =\n                                  (\\<exists>rr\\<in>set rtbl.\nprefix_match_semantics (routing_match rr) addr \\<and>\nrouting_action rr = act \\<and>\n(\\<forall>ra\\<in>set rtbl.\n    routing_rule_sort_key ra < routing_rule_sort_key rr \\<longrightarrow>\n    \\<not> prefix_match_semantics (routing_match ra) addr));\n        valid_prefixes (a # rtbl); is_longest_prefix_routing (a # rtbl);\n        has_default_route (a # rtbl);\n        unambiguous_routing (a # rtbl)\\<rbrakk>\n       \\<Longrightarrow> (routing_table_semantics (a # rtbl) addr = act) =\n                         (\\<exists>rr\\<in>set (a # rtbl).\n                             prefix_match_semantics (routing_match rr)\n                              addr \\<and>\n                             routing_action rr = act \\<and>\n                             (\\<forall>ra\\<in>set (a # rtbl).\n                                 routing_rule_sort_key ra\n                                 < routing_rule_sort_key\n                                    rr \\<longrightarrow>\n                                 \\<not> prefix_match_semantics\n   (routing_match ra) addr))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a rtbl.\n       \\<lbrakk>\\<lbrakk>valid_prefixes rtbl;\n                 is_longest_prefix_routing rtbl; has_default_route rtbl;\n                 unambiguous_routing rtbl\\<rbrakk>\n                \\<Longrightarrow> (routing_table_semantics rtbl addr =\n                                   act) =\n                                  (\\<exists>rr\\<in>set rtbl.\nprefix_match_semantics (routing_match rr) addr \\<and>\nrouting_action rr = act \\<and>\n(\\<forall>ra\\<in>set rtbl.\n    routing_rule_sort_key ra < routing_rule_sort_key rr \\<longrightarrow>\n    \\<not> prefix_match_semantics (routing_match ra) addr));\n        valid_prefixes (a # rtbl); is_longest_prefix_routing (a # rtbl);\n        has_default_route (a # rtbl);\n        unambiguous_routing (a # rtbl)\\<rbrakk>\n       \\<Longrightarrow> (routing_table_semantics (a # rtbl) addr = act) =\n                         (\\<exists>rr\\<in>set (a # rtbl).\n                             prefix_match_semantics (routing_match rr)\n                              addr \\<and>\n                             routing_action rr = act \\<and>\n                             (\\<forall>ra\\<in>set (a # rtbl).\n                                 routing_rule_sort_key ra\n                                 < routing_rule_sort_key\n                                    rr \\<longrightarrow>\n                                 \\<not> prefix_match_semantics\n   (routing_match ra) addr))", "case (Cons rr rtbl)"], ["proof (state)\nthis:\n  \\<lbrakk>valid_prefixes rtbl; is_longest_prefix_routing rtbl;\n   has_default_route rtbl; unambiguous_routing rtbl\\<rbrakk>\n  \\<Longrightarrow> (routing_table_semantics rtbl addr = act) =\n                    (\\<exists>rr\\<in>set rtbl.\n                        prefix_match_semantics (routing_match rr)\n                         addr \\<and>\n                        routing_action rr = act \\<and>\n                        (\\<forall>ra\\<in>set rtbl.\n                            routing_rule_sort_key ra\n                            < routing_rule_sort_key rr \\<longrightarrow>\n                            \\<not> prefix_match_semantics (routing_match ra)\n                                    addr))\n  valid_prefixes (rr # rtbl)\n  is_longest_prefix_routing (rr # rtbl)\n  has_default_route (rr # rtbl)\n  unambiguous_routing (rr # rtbl)\n\ngoal (1 subgoal):\n 1. \\<And>a rtbl.\n       \\<lbrakk>\\<lbrakk>valid_prefixes rtbl;\n                 is_longest_prefix_routing rtbl; has_default_route rtbl;\n                 unambiguous_routing rtbl\\<rbrakk>\n                \\<Longrightarrow> (routing_table_semantics rtbl addr =\n                                   act) =\n                                  (\\<exists>rr\\<in>set rtbl.\nprefix_match_semantics (routing_match rr) addr \\<and>\nrouting_action rr = act \\<and>\n(\\<forall>ra\\<in>set rtbl.\n    routing_rule_sort_key ra < routing_rule_sort_key rr \\<longrightarrow>\n    \\<not> prefix_match_semantics (routing_match ra) addr));\n        valid_prefixes (a # rtbl); is_longest_prefix_routing (a # rtbl);\n        has_default_route (a # rtbl);\n        unambiguous_routing (a # rtbl)\\<rbrakk>\n       \\<Longrightarrow> (routing_table_semantics (a # rtbl) addr = act) =\n                         (\\<exists>rr\\<in>set (a # rtbl).\n                             prefix_match_semantics (routing_match rr)\n                              addr \\<and>\n                             routing_action rr = act \\<and>\n                             (\\<forall>ra\\<in>set (a # rtbl).\n                                 routing_rule_sort_key ra\n                                 < routing_rule_sort_key\n                                    rr \\<longrightarrow>\n                                 \\<not> prefix_match_semantics\n   (routing_match ra) addr))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (routing_table_semantics (rr # rtbl) addr = act) =\n    (\\<exists>rra\\<in>set (rr # rtbl).\n        prefix_match_semantics (routing_match rra) addr \\<and>\n        routing_action rra = act \\<and>\n        (\\<forall>ra\\<in>set (rr # rtbl).\n            routing_rule_sort_key ra\n            < routing_rule_sort_key rra \\<longrightarrow>\n            \\<not> prefix_match_semantics (routing_match ra) addr))", "proof(cases \"prefix_match_semantics (routing_match rr) addr\")"], ["proof (state)\ngoal (2 subgoals):\n 1. prefix_match_semantics (routing_match rr) addr \\<Longrightarrow>\n    (routing_table_semantics (rr # rtbl) addr = act) =\n    (\\<exists>rra\\<in>set (rr # rtbl).\n        prefix_match_semantics (routing_match rra) addr \\<and>\n        routing_action rra = act \\<and>\n        (\\<forall>ra\\<in>set (rr # rtbl).\n            routing_rule_sort_key ra\n            < routing_rule_sort_key rra \\<longrightarrow>\n            \\<not> prefix_match_semantics (routing_match ra) addr))\n 2. \\<not> prefix_match_semantics (routing_match rr) addr \\<Longrightarrow>\n    (routing_table_semantics (rr # rtbl) addr = act) =\n    (\\<exists>rra\\<in>set (rr # rtbl).\n        prefix_match_semantics (routing_match rra) addr \\<and>\n        routing_action rra = act \\<and>\n        (\\<forall>ra\\<in>set (rr # rtbl).\n            routing_rule_sort_key ra\n            < routing_rule_sort_key rra \\<longrightarrow>\n            \\<not> prefix_match_semantics (routing_match ra) addr))", "case False"], ["proof (state)\nthis:\n  \\<not> prefix_match_semantics (routing_match rr) addr\n\ngoal (2 subgoals):\n 1. prefix_match_semantics (routing_match rr) addr \\<Longrightarrow>\n    (routing_table_semantics (rr # rtbl) addr = act) =\n    (\\<exists>rra\\<in>set (rr # rtbl).\n        prefix_match_semantics (routing_match rra) addr \\<and>\n        routing_action rra = act \\<and>\n        (\\<forall>ra\\<in>set (rr # rtbl).\n            routing_rule_sort_key ra\n            < routing_rule_sort_key rra \\<longrightarrow>\n            \\<not> prefix_match_semantics (routing_match ra) addr))\n 2. \\<not> prefix_match_semantics (routing_match rr) addr \\<Longrightarrow>\n    (routing_table_semantics (rr # rtbl) addr = act) =\n    (\\<exists>rra\\<in>set (rr # rtbl).\n        prefix_match_semantics (routing_match rra) addr \\<and>\n        routing_action rra = act \\<and>\n        (\\<forall>ra\\<in>set (rr # rtbl).\n            routing_rule_sort_key ra\n            < routing_rule_sort_key rra \\<longrightarrow>\n            \\<not> prefix_match_semantics (routing_match ra) addr))", "hence [simp]: \"routing_table_semantics (rr # rtbl) addr = routing_table_semantics (rr # rtbl) addr\""], ["proof (prove)\nusing this:\n  \\<not> prefix_match_semantics (routing_match rr) addr\n\ngoal (1 subgoal):\n 1. routing_table_semantics (rr # rtbl) addr =\n    routing_table_semantics (rr # rtbl) addr", "by simp"], ["proof (state)\nthis:\n  routing_table_semantics (rr # rtbl) addr =\n  routing_table_semantics (rr # rtbl) addr\n\ngoal (2 subgoals):\n 1. prefix_match_semantics (routing_match rr) addr \\<Longrightarrow>\n    (routing_table_semantics (rr # rtbl) addr = act) =\n    (\\<exists>rra\\<in>set (rr # rtbl).\n        prefix_match_semantics (routing_match rra) addr \\<and>\n        routing_action rra = act \\<and>\n        (\\<forall>ra\\<in>set (rr # rtbl).\n            routing_rule_sort_key ra\n            < routing_rule_sort_key rra \\<longrightarrow>\n            \\<not> prefix_match_semantics (routing_match ra) addr))\n 2. \\<not> prefix_match_semantics (routing_match rr) addr \\<Longrightarrow>\n    (routing_table_semantics (rr # rtbl) addr = act) =\n    (\\<exists>rra\\<in>set (rr # rtbl).\n        prefix_match_semantics (routing_match rra) addr \\<and>\n        routing_action rra = act \\<and>\n        (\\<forall>ra\\<in>set (rr # rtbl).\n            routing_rule_sort_key ra\n            < routing_rule_sort_key rra \\<longrightarrow>\n            \\<not> prefix_match_semantics (routing_match ra) addr))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (routing_table_semantics (rr # rtbl) addr = act) =\n    (\\<exists>rra\\<in>set (rr # rtbl).\n        prefix_match_semantics (routing_match rra) addr \\<and>\n        routing_action rra = act \\<and>\n        (\\<forall>ra\\<in>set (rr # rtbl).\n            routing_rule_sort_key ra\n            < routing_rule_sort_key rra \\<longrightarrow>\n            \\<not> prefix_match_semantics (routing_match ra) addr))", "proof(cases \"routing_prefix rr = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. routing_prefix rr = 0 \\<Longrightarrow>\n    (routing_table_semantics (rr # rtbl) addr = act) =\n    (\\<exists>rra\\<in>set (rr # rtbl).\n        prefix_match_semantics (routing_match rra) addr \\<and>\n        routing_action rra = act \\<and>\n        (\\<forall>ra\\<in>set (rr # rtbl).\n            routing_rule_sort_key ra\n            < routing_rule_sort_key rra \\<longrightarrow>\n            \\<not> prefix_match_semantics (routing_match ra) addr))\n 2. routing_prefix rr \\<noteq> 0 \\<Longrightarrow>\n    (routing_table_semantics (rr # rtbl) addr = act) =\n    (\\<exists>rra\\<in>set (rr # rtbl).\n        prefix_match_semantics (routing_match rra) addr \\<and>\n        routing_action rra = act \\<and>\n        (\\<forall>ra\\<in>set (rr # rtbl).\n            routing_rule_sort_key ra\n            < routing_rule_sort_key rra \\<longrightarrow>\n            \\<not> prefix_match_semantics (routing_match ra) addr))", "case True"], ["proof (state)\nthis:\n  routing_prefix rr = 0\n\ngoal (2 subgoals):\n 1. routing_prefix rr = 0 \\<Longrightarrow>\n    (routing_table_semantics (rr # rtbl) addr = act) =\n    (\\<exists>rra\\<in>set (rr # rtbl).\n        prefix_match_semantics (routing_match rra) addr \\<and>\n        routing_action rra = act \\<and>\n        (\\<forall>ra\\<in>set (rr # rtbl).\n            routing_rule_sort_key ra\n            < routing_rule_sort_key rra \\<longrightarrow>\n            \\<not> prefix_match_semantics (routing_match ra) addr))\n 2. routing_prefix rr \\<noteq> 0 \\<Longrightarrow>\n    (routing_table_semantics (rr # rtbl) addr = act) =\n    (\\<exists>rra\\<in>set (rr # rtbl).\n        prefix_match_semantics (routing_match rra) addr \\<and>\n        routing_action rra = act \\<and>\n        (\\<forall>ra\\<in>set (rr # rtbl).\n            routing_rule_sort_key ra\n            < routing_rule_sort_key rra \\<longrightarrow>\n            \\<not> prefix_match_semantics (routing_match ra) addr))", "text\\<open>Need special treatment, rtbl won't have a default route, so the IH is not usable.\\<close>"], ["proof (state)\nthis:\n  routing_prefix rr = 0\n\ngoal (2 subgoals):\n 1. routing_prefix rr = 0 \\<Longrightarrow>\n    (routing_table_semantics (rr # rtbl) addr = act) =\n    (\\<exists>rra\\<in>set (rr # rtbl).\n        prefix_match_semantics (routing_match rra) addr \\<and>\n        routing_action rra = act \\<and>\n        (\\<forall>ra\\<in>set (rr # rtbl).\n            routing_rule_sort_key ra\n            < routing_rule_sort_key rra \\<longrightarrow>\n            \\<not> prefix_match_semantics (routing_match ra) addr))\n 2. routing_prefix rr \\<noteq> 0 \\<Longrightarrow>\n    (routing_table_semantics (rr # rtbl) addr = act) =\n    (\\<exists>rra\\<in>set (rr # rtbl).\n        prefix_match_semantics (routing_match rra) addr \\<and>\n        routing_action rra = act \\<and>\n        (\\<forall>ra\\<in>set (rr # rtbl).\n            routing_rule_sort_key ra\n            < routing_rule_sort_key rra \\<longrightarrow>\n            \\<not> prefix_match_semantics (routing_match ra) addr))", "have \"valid_prefix (routing_match rr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_prefix (routing_match rr)", "using Cons.prems valid_prefixes_split"], ["proof (prove)\nusing this:\n  valid_prefixes (rr # rtbl)\n  is_longest_prefix_routing (rr # rtbl)\n  has_default_route (rr # rtbl)\n  unambiguous_routing (rr # rtbl)\n  valid_prefixes (?r # ?rs) \\<Longrightarrow>\n  valid_prefix (routing_match ?r) \\<and> valid_prefixes ?rs\n\ngoal (1 subgoal):\n 1. valid_prefix (routing_match rr)", "by blast"], ["proof (state)\nthis:\n  valid_prefix (routing_match rr)\n\ngoal (2 subgoals):\n 1. routing_prefix rr = 0 \\<Longrightarrow>\n    (routing_table_semantics (rr # rtbl) addr = act) =\n    (\\<exists>rra\\<in>set (rr # rtbl).\n        prefix_match_semantics (routing_match rra) addr \\<and>\n        routing_action rra = act \\<and>\n        (\\<forall>ra\\<in>set (rr # rtbl).\n            routing_rule_sort_key ra\n            < routing_rule_sort_key rra \\<longrightarrow>\n            \\<not> prefix_match_semantics (routing_match ra) addr))\n 2. routing_prefix rr \\<noteq> 0 \\<Longrightarrow>\n    (routing_table_semantics (rr # rtbl) addr = act) =\n    (\\<exists>rra\\<in>set (rr # rtbl).\n        prefix_match_semantics (routing_match rra) addr \\<and>\n        routing_action rra = act \\<and>\n        (\\<forall>ra\\<in>set (rr # rtbl).\n            routing_rule_sort_key ra\n            < routing_rule_sort_key rra \\<longrightarrow>\n            \\<not> prefix_match_semantics (routing_match ra) addr))", "with True False"], ["proof (chain)\npicking this:\n  routing_prefix rr = 0\n  \\<not> prefix_match_semantics (routing_match rr) addr\n  valid_prefix (routing_match rr)", "have False"], ["proof (prove)\nusing this:\n  routing_prefix rr = 0\n  \\<not> prefix_match_semantics (routing_match rr) addr\n  valid_prefix (routing_match rr)\n\ngoal (1 subgoal):\n 1. False", "using zero_prefix_match_all"], ["proof (prove)\nusing this:\n  routing_prefix rr = 0\n  \\<not> prefix_match_semantics (routing_match rr) addr\n  valid_prefix (routing_match rr)\n  \\<lbrakk>valid_prefix ?m; pfxm_length ?m = 0\\<rbrakk>\n  \\<Longrightarrow> prefix_match_semantics ?m ?ip\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. routing_prefix rr = 0 \\<Longrightarrow>\n    (routing_table_semantics (rr # rtbl) addr = act) =\n    (\\<exists>rra\\<in>set (rr # rtbl).\n        prefix_match_semantics (routing_match rra) addr \\<and>\n        routing_action rra = act \\<and>\n        (\\<forall>ra\\<in>set (rr # rtbl).\n            routing_rule_sort_key ra\n            < routing_rule_sort_key rra \\<longrightarrow>\n            \\<not> prefix_match_semantics (routing_match ra) addr))\n 2. routing_prefix rr \\<noteq> 0 \\<Longrightarrow>\n    (routing_table_semantics (rr # rtbl) addr = act) =\n    (\\<exists>rra\\<in>set (rr # rtbl).\n        prefix_match_semantics (routing_match rra) addr \\<and>\n        routing_action rra = act \\<and>\n        (\\<forall>ra\\<in>set (rr # rtbl).\n            routing_rule_sort_key ra\n            < routing_rule_sort_key rra \\<longrightarrow>\n            \\<not> prefix_match_semantics (routing_match ra) addr))", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. (routing_table_semantics (rr # rtbl) addr = act) =\n    (\\<exists>rra\\<in>set (rr # rtbl).\n        prefix_match_semantics (routing_match rra) addr \\<and>\n        routing_action rra = act \\<and>\n        (\\<forall>ra\\<in>set (rr # rtbl).\n            routing_rule_sort_key ra\n            < routing_rule_sort_key rra \\<longrightarrow>\n            \\<not> prefix_match_semantics (routing_match ra) addr))", ".."], ["proof (state)\nthis:\n  (routing_table_semantics (rr # rtbl) addr = act) =\n  (\\<exists>rra\\<in>set (rr # rtbl).\n      prefix_match_semantics (routing_match rra) addr \\<and>\n      routing_action rra = act \\<and>\n      (\\<forall>ra\\<in>set (rr # rtbl).\n          routing_rule_sort_key ra\n          < routing_rule_sort_key rra \\<longrightarrow>\n          \\<not> prefix_match_semantics (routing_match ra) addr))\n\ngoal (1 subgoal):\n 1. routing_prefix rr \\<noteq> 0 \\<Longrightarrow>\n    (routing_table_semantics (rr # rtbl) addr = act) =\n    (\\<exists>rra\\<in>set (rr # rtbl).\n        prefix_match_semantics (routing_match rra) addr \\<and>\n        routing_action rra = act \\<and>\n        (\\<forall>ra\\<in>set (rr # rtbl).\n            routing_rule_sort_key ra\n            < routing_rule_sort_key rra \\<longrightarrow>\n            \\<not> prefix_match_semantics (routing_match ra) addr))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. routing_prefix rr \\<noteq> 0 \\<Longrightarrow>\n    (routing_table_semantics (rr # rtbl) addr = act) =\n    (\\<exists>rra\\<in>set (rr # rtbl).\n        prefix_match_semantics (routing_match rra) addr \\<and>\n        routing_action rra = act \\<and>\n        (\\<forall>ra\\<in>set (rr # rtbl).\n            routing_rule_sort_key ra\n            < routing_rule_sort_key rra \\<longrightarrow>\n            \\<not> prefix_match_semantics (routing_match ra) addr))", "case False"], ["proof (state)\nthis:\n  routing_prefix rr \\<noteq> 0\n\ngoal (1 subgoal):\n 1. routing_prefix rr \\<noteq> 0 \\<Longrightarrow>\n    (routing_table_semantics (rr # rtbl) addr = act) =\n    (\\<exists>rra\\<in>set (rr # rtbl).\n        prefix_match_semantics (routing_match rra) addr \\<and>\n        routing_action rra = act \\<and>\n        (\\<forall>ra\\<in>set (rr # rtbl).\n            routing_rule_sort_key ra\n            < routing_rule_sort_key rra \\<longrightarrow>\n            \\<not> prefix_match_semantics (routing_match ra) addr))", "with Cons.prems"], ["proof (chain)\npicking this:\n  valid_prefixes (rr # rtbl)\n  is_longest_prefix_routing (rr # rtbl)\n  has_default_route (rr # rtbl)\n  unambiguous_routing (rr # rtbl)\n  routing_prefix rr \\<noteq> 0", "have mprems: \"valid_prefixes rtbl\" \"is_longest_prefix_routing rtbl\" \"has_default_route rtbl\" \"unambiguous_routing rtbl\""], ["proof (prove)\nusing this:\n  valid_prefixes (rr # rtbl)\n  is_longest_prefix_routing (rr # rtbl)\n  has_default_route (rr # rtbl)\n  unambiguous_routing (rr # rtbl)\n  routing_prefix rr \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (valid_prefixes rtbl &&& is_longest_prefix_routing rtbl) &&&\n    has_default_route rtbl &&& unambiguous_routing rtbl", "by(simp_all add: valid_prefixes_split unambiguous_routing_Cons is_longest_prefix_routing_def)"], ["proof (state)\nthis:\n  valid_prefixes rtbl\n  is_longest_prefix_routing rtbl\n  has_default_route rtbl\n  unambiguous_routing rtbl\n\ngoal (1 subgoal):\n 1. routing_prefix rr \\<noteq> 0 \\<Longrightarrow>\n    (routing_table_semantics (rr # rtbl) addr = act) =\n    (\\<exists>rra\\<in>set (rr # rtbl).\n        prefix_match_semantics (routing_match rra) addr \\<and>\n        routing_action rra = act \\<and>\n        (\\<forall>ra\\<in>set (rr # rtbl).\n            routing_rule_sort_key ra\n            < routing_rule_sort_key rra \\<longrightarrow>\n            \\<not> prefix_match_semantics (routing_match ra) addr))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (routing_table_semantics (rr # rtbl) addr = act) =\n    (\\<exists>rra\\<in>set (rr # rtbl).\n        prefix_match_semantics (routing_match rra) addr \\<and>\n        routing_action rra = act \\<and>\n        (\\<forall>ra\\<in>set (rr # rtbl).\n            routing_rule_sort_key ra\n            < routing_rule_sort_key rra \\<longrightarrow>\n            \\<not> prefix_match_semantics (routing_match ra) addr))", "using Cons.IH[OF mprems] False \\<open>\\<not> prefix_match_semantics (routing_match rr) addr\\<close>"], ["proof (prove)\nusing this:\n  (routing_table_semantics rtbl addr = act) =\n  (\\<exists>rr\\<in>set rtbl.\n      prefix_match_semantics (routing_match rr) addr \\<and>\n      routing_action rr = act \\<and>\n      (\\<forall>ra\\<in>set rtbl.\n          routing_rule_sort_key ra\n          < routing_rule_sort_key rr \\<longrightarrow>\n          \\<not> prefix_match_semantics (routing_match ra) addr))\n  routing_prefix rr \\<noteq> 0\n  \\<not> prefix_match_semantics (routing_match rr) addr\n\ngoal (1 subgoal):\n 1. (routing_table_semantics (rr # rtbl) addr = act) =\n    (\\<exists>rra\\<in>set (rr # rtbl).\n        prefix_match_semantics (routing_match rra) addr \\<and>\n        routing_action rra = act \\<and>\n        (\\<forall>ra\\<in>set (rr # rtbl).\n            routing_rule_sort_key ra\n            < routing_rule_sort_key rra \\<longrightarrow>\n            \\<not> prefix_match_semantics (routing_match ra) addr))", "by simp"], ["proof (state)\nthis:\n  (routing_table_semantics (rr # rtbl) addr = act) =\n  (\\<exists>rra\\<in>set (rr # rtbl).\n      prefix_match_semantics (routing_match rra) addr \\<and>\n      routing_action rra = act \\<and>\n      (\\<forall>ra\\<in>set (rr # rtbl).\n          routing_rule_sort_key ra\n          < routing_rule_sort_key rra \\<longrightarrow>\n          \\<not> prefix_match_semantics (routing_match ra) addr))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (routing_table_semantics (rr # rtbl) addr = act) =\n  (\\<exists>rra\\<in>set (rr # rtbl).\n      prefix_match_semantics (routing_match rra) addr \\<and>\n      routing_action rra = act \\<and>\n      (\\<forall>ra\\<in>set (rr # rtbl).\n          routing_rule_sort_key ra\n          < routing_rule_sort_key rra \\<longrightarrow>\n          \\<not> prefix_match_semantics (routing_match ra) addr))\n\ngoal (1 subgoal):\n 1. prefix_match_semantics (routing_match rr) addr \\<Longrightarrow>\n    (routing_table_semantics (rr # rtbl) addr = act) =\n    (\\<exists>rra\\<in>set (rr # rtbl).\n        prefix_match_semantics (routing_match rra) addr \\<and>\n        routing_action rra = act \\<and>\n        (\\<forall>ra\\<in>set (rr # rtbl).\n            routing_rule_sort_key ra\n            < routing_rule_sort_key rra \\<longrightarrow>\n            \\<not> prefix_match_semantics (routing_match ra) addr))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. prefix_match_semantics (routing_match rr) addr \\<Longrightarrow>\n    (routing_table_semantics (rr # rtbl) addr = act) =\n    (\\<exists>rra\\<in>set (rr # rtbl).\n        prefix_match_semantics (routing_match rra) addr \\<and>\n        routing_action rra = act \\<and>\n        (\\<forall>ra\\<in>set (rr # rtbl).\n            routing_rule_sort_key ra\n            < routing_rule_sort_key rra \\<longrightarrow>\n            \\<not> prefix_match_semantics (routing_match ra) addr))", "case True"], ["proof (state)\nthis:\n  prefix_match_semantics (routing_match rr) addr\n\ngoal (1 subgoal):\n 1. prefix_match_semantics (routing_match rr) addr \\<Longrightarrow>\n    (routing_table_semantics (rr # rtbl) addr = act) =\n    (\\<exists>rra\\<in>set (rr # rtbl).\n        prefix_match_semantics (routing_match rra) addr \\<and>\n        routing_action rra = act \\<and>\n        (\\<forall>ra\\<in>set (rr # rtbl).\n            routing_rule_sort_key ra\n            < routing_rule_sort_key rra \\<longrightarrow>\n            \\<not> prefix_match_semantics (routing_match ra) addr))", "from True"], ["proof (chain)\npicking this:\n  prefix_match_semantics (routing_match rr) addr", "have [simp]: \"routing_table_semantics (rr # rtbl) addr = routing_action rr\""], ["proof (prove)\nusing this:\n  prefix_match_semantics (routing_match rr) addr\n\ngoal (1 subgoal):\n 1. routing_table_semantics (rr # rtbl) addr = routing_action rr", "by simp"], ["proof (state)\nthis:\n  routing_table_semantics (rr # rtbl) addr = routing_action rr\n\ngoal (1 subgoal):\n 1. prefix_match_semantics (routing_match rr) addr \\<Longrightarrow>\n    (routing_table_semantics (rr # rtbl) addr = act) =\n    (\\<exists>rra\\<in>set (rr # rtbl).\n        prefix_match_semantics (routing_match rra) addr \\<and>\n        routing_action rra = act \\<and>\n        (\\<forall>ra\\<in>set (rr # rtbl).\n            routing_rule_sort_key ra\n            < routing_rule_sort_key rra \\<longrightarrow>\n            \\<not> prefix_match_semantics (routing_match ra) addr))", "show ?thesis (is \"?l \\<longleftrightarrow> ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (routing_table_semantics (rr # rtbl) addr = act) =\n    (\\<exists>rra\\<in>set (rr # rtbl).\n        prefix_match_semantics (routing_match rra) addr \\<and>\n        routing_action rra = act \\<and>\n        (\\<forall>ra\\<in>set (rr # rtbl).\n            routing_rule_sort_key ra\n            < routing_rule_sort_key rra \\<longrightarrow>\n            \\<not> prefix_match_semantics (routing_match ra) addr))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. routing_table_semantics (rr # rtbl) addr = act \\<Longrightarrow>\n    \\<exists>rra\\<in>set (rr # rtbl).\n       prefix_match_semantics (routing_match rra) addr \\<and>\n       routing_action rra = act \\<and>\n       (\\<forall>ra\\<in>set (rr # rtbl).\n           routing_rule_sort_key ra\n           < routing_rule_sort_key rra \\<longrightarrow>\n           \\<not> prefix_match_semantics (routing_match ra) addr)\n 2. \\<exists>rra\\<in>set (rr # rtbl).\n       prefix_match_semantics (routing_match rra) addr \\<and>\n       routing_action rra = act \\<and>\n       (\\<forall>ra\\<in>set (rr # rtbl).\n           routing_rule_sort_key ra\n           < routing_rule_sort_key rra \\<longrightarrow>\n           \\<not> prefix_match_semantics (routing_match ra)\n                   addr) \\<Longrightarrow>\n    routing_table_semantics (rr # rtbl) addr = act", "assume ?l"], ["proof (state)\nthis:\n  routing_table_semantics (rr # rtbl) addr = act\n\ngoal (2 subgoals):\n 1. routing_table_semantics (rr # rtbl) addr = act \\<Longrightarrow>\n    \\<exists>rra\\<in>set (rr # rtbl).\n       prefix_match_semantics (routing_match rra) addr \\<and>\n       routing_action rra = act \\<and>\n       (\\<forall>ra\\<in>set (rr # rtbl).\n           routing_rule_sort_key ra\n           < routing_rule_sort_key rra \\<longrightarrow>\n           \\<not> prefix_match_semantics (routing_match ra) addr)\n 2. \\<exists>rra\\<in>set (rr # rtbl).\n       prefix_match_semantics (routing_match rra) addr \\<and>\n       routing_action rra = act \\<and>\n       (\\<forall>ra\\<in>set (rr # rtbl).\n           routing_rule_sort_key ra\n           < routing_rule_sort_key rra \\<longrightarrow>\n           \\<not> prefix_match_semantics (routing_match ra)\n                   addr) \\<Longrightarrow>\n    routing_table_semantics (rr # rtbl) addr = act", "hence [simp]: \"act = routing_action rr\""], ["proof (prove)\nusing this:\n  routing_table_semantics (rr # rtbl) addr = act\n\ngoal (1 subgoal):\n 1. act = routing_action rr", "by(simp add: True)"], ["proof (state)\nthis:\n  act = routing_action rr\n\ngoal (2 subgoals):\n 1. routing_table_semantics (rr # rtbl) addr = act \\<Longrightarrow>\n    \\<exists>rra\\<in>set (rr # rtbl).\n       prefix_match_semantics (routing_match rra) addr \\<and>\n       routing_action rra = act \\<and>\n       (\\<forall>ra\\<in>set (rr # rtbl).\n           routing_rule_sort_key ra\n           < routing_rule_sort_key rra \\<longrightarrow>\n           \\<not> prefix_match_semantics (routing_match ra) addr)\n 2. \\<exists>rra\\<in>set (rr # rtbl).\n       prefix_match_semantics (routing_match rra) addr \\<and>\n       routing_action rra = act \\<and>\n       (\\<forall>ra\\<in>set (rr # rtbl).\n           routing_rule_sort_key ra\n           < routing_rule_sort_key rra \\<longrightarrow>\n           \\<not> prefix_match_semantics (routing_match ra)\n                   addr) \\<Longrightarrow>\n    routing_table_semantics (rr # rtbl) addr = act", "have *: \"(\\<forall>ra\\<in>set (rr # rtbl). routing_rule_sort_key rr \\<le> routing_rule_sort_key ra)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ra\\<in>set (rr # rtbl).\n       routing_rule_sort_key rr \\<le> routing_rule_sort_key ra", "using \\<open>is_longest_prefix_routing (rr # rtbl)\\<close>"], ["proof (prove)\nusing this:\n  is_longest_prefix_routing (rr # rtbl)\n\ngoal (1 subgoal):\n 1. \\<forall>ra\\<in>set (rr # rtbl).\n       routing_rule_sort_key rr \\<le> routing_rule_sort_key ra", "by(clarsimp simp: is_longest_prefix_routing_def)"], ["proof (state)\nthis:\n  \\<forall>ra\\<in>set (rr # rtbl).\n     routing_rule_sort_key rr \\<le> routing_rule_sort_key ra\n\ngoal (2 subgoals):\n 1. routing_table_semantics (rr # rtbl) addr = act \\<Longrightarrow>\n    \\<exists>rra\\<in>set (rr # rtbl).\n       prefix_match_semantics (routing_match rra) addr \\<and>\n       routing_action rra = act \\<and>\n       (\\<forall>ra\\<in>set (rr # rtbl).\n           routing_rule_sort_key ra\n           < routing_rule_sort_key rra \\<longrightarrow>\n           \\<not> prefix_match_semantics (routing_match ra) addr)\n 2. \\<exists>rra\\<in>set (rr # rtbl).\n       prefix_match_semantics (routing_match rra) addr \\<and>\n       routing_action rra = act \\<and>\n       (\\<forall>ra\\<in>set (rr # rtbl).\n           routing_rule_sort_key ra\n           < routing_rule_sort_key rra \\<longrightarrow>\n           \\<not> prefix_match_semantics (routing_match ra)\n                   addr) \\<Longrightarrow>\n    routing_table_semantics (rr # rtbl) addr = act", "thus ?r"], ["proof (prove)\nusing this:\n  \\<forall>ra\\<in>set (rr # rtbl).\n     routing_rule_sort_key rr \\<le> routing_rule_sort_key ra\n\ngoal (1 subgoal):\n 1. \\<exists>rra\\<in>set (rr # rtbl).\n       prefix_match_semantics (routing_match rra) addr \\<and>\n       routing_action rra = act \\<and>\n       (\\<forall>ra\\<in>set (rr # rtbl).\n           routing_rule_sort_key ra\n           < routing_rule_sort_key rra \\<longrightarrow>\n           \\<not> prefix_match_semantics (routing_match ra) addr)", "by(fastforce simp add: True)"], ["proof (state)\nthis:\n  \\<exists>rra\\<in>set (rr # rtbl).\n     prefix_match_semantics (routing_match rra) addr \\<and>\n     routing_action rra = act \\<and>\n     (\\<forall>ra\\<in>set (rr # rtbl).\n         routing_rule_sort_key ra\n         < routing_rule_sort_key rra \\<longrightarrow>\n         \\<not> prefix_match_semantics (routing_match ra) addr)\n\ngoal (1 subgoal):\n 1. \\<exists>rra\\<in>set (rr # rtbl).\n       prefix_match_semantics (routing_match rra) addr \\<and>\n       routing_action rra = act \\<and>\n       (\\<forall>ra\\<in>set (rr # rtbl).\n           routing_rule_sort_key ra\n           < routing_rule_sort_key rra \\<longrightarrow>\n           \\<not> prefix_match_semantics (routing_match ra)\n                   addr) \\<Longrightarrow>\n    routing_table_semantics (rr # rtbl) addr = act", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>rra\\<in>set (rr # rtbl).\n       prefix_match_semantics (routing_match rra) addr \\<and>\n       routing_action rra = act \\<and>\n       (\\<forall>ra\\<in>set (rr # rtbl).\n           routing_rule_sort_key ra\n           < routing_rule_sort_key rra \\<longrightarrow>\n           \\<not> prefix_match_semantics (routing_match ra)\n                   addr) \\<Longrightarrow>\n    routing_table_semantics (rr # rtbl) addr = act", "assume ?r"], ["proof (state)\nthis:\n  \\<exists>rra\\<in>set (rr # rtbl).\n     prefix_match_semantics (routing_match rra) addr \\<and>\n     routing_action rra = act \\<and>\n     (\\<forall>ra\\<in>set (rr # rtbl).\n         routing_rule_sort_key ra\n         < routing_rule_sort_key rra \\<longrightarrow>\n         \\<not> prefix_match_semantics (routing_match ra) addr)\n\ngoal (1 subgoal):\n 1. \\<exists>rra\\<in>set (rr # rtbl).\n       prefix_match_semantics (routing_match rra) addr \\<and>\n       routing_action rra = act \\<and>\n       (\\<forall>ra\\<in>set (rr # rtbl).\n           routing_rule_sort_key ra\n           < routing_rule_sort_key rra \\<longrightarrow>\n           \\<not> prefix_match_semantics (routing_match ra)\n                   addr) \\<Longrightarrow>\n    routing_table_semantics (rr # rtbl) addr = act", "then"], ["proof (chain)\npicking this:\n  \\<exists>rra\\<in>set (rr # rtbl).\n     prefix_match_semantics (routing_match rra) addr \\<and>\n     routing_action rra = act \\<and>\n     (\\<forall>ra\\<in>set (rr # rtbl).\n         routing_rule_sort_key ra\n         < routing_rule_sort_key rra \\<longrightarrow>\n         \\<not> prefix_match_semantics (routing_match ra) addr)", "guess rr'"], ["proof (prove)\nusing this:\n  \\<exists>rra\\<in>set (rr # rtbl).\n     prefix_match_semantics (routing_match rra) addr \\<and>\n     routing_action rra = act \\<and>\n     (\\<forall>ra\\<in>set (rr # rtbl).\n         routing_rule_sort_key ra\n         < routing_rule_sort_key rra \\<longrightarrow>\n         \\<not> prefix_match_semantics (routing_match ra) addr)\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  rr' \\<in> set (rr # rtbl)\n  prefix_match_semantics (routing_match rr') addr \\<and>\n  routing_action rr' = act \\<and>\n  (\\<forall>ra\\<in>set (rr # rtbl).\n      routing_rule_sort_key ra < routing_rule_sort_key rr' \\<longrightarrow>\n      \\<not> prefix_match_semantics (routing_match ra) addr)\n\ngoal (1 subgoal):\n 1. \\<exists>rra\\<in>set (rr # rtbl).\n       prefix_match_semantics (routing_match rra) addr \\<and>\n       routing_action rra = act \\<and>\n       (\\<forall>ra\\<in>set (rr # rtbl).\n           routing_rule_sort_key ra\n           < routing_rule_sort_key rra \\<longrightarrow>\n           \\<not> prefix_match_semantics (routing_match ra)\n                   addr) \\<Longrightarrow>\n    routing_table_semantics (rr # rtbl) addr = act", "note rr' = this"], ["proof (state)\nthis:\n  rr' \\<in> set (rr # rtbl)\n  prefix_match_semantics (routing_match rr') addr \\<and>\n  routing_action rr' = act \\<and>\n  (\\<forall>ra\\<in>set (rr # rtbl).\n      routing_rule_sort_key ra < routing_rule_sort_key rr' \\<longrightarrow>\n      \\<not> prefix_match_semantics (routing_match ra) addr)\n\ngoal (1 subgoal):\n 1. \\<exists>rra\\<in>set (rr # rtbl).\n       prefix_match_semantics (routing_match rra) addr \\<and>\n       routing_action rra = act \\<and>\n       (\\<forall>ra\\<in>set (rr # rtbl).\n           routing_rule_sort_key ra\n           < routing_rule_sort_key rra \\<longrightarrow>\n           \\<not> prefix_match_semantics (routing_match ra)\n                   addr) \\<Longrightarrow>\n    routing_table_semantics (rr # rtbl) addr = act", "have \"rr' = rr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rr' = rr", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. rr' \\<noteq> rr \\<Longrightarrow> False", "assume C: \"rr' \\<noteq> rr\""], ["proof (state)\nthis:\n  rr' \\<noteq> rr\n\ngoal (1 subgoal):\n 1. rr' \\<noteq> rr \\<Longrightarrow> False", "from C"], ["proof (chain)\npicking this:\n  rr' \\<noteq> rr", "have e: \"rr' \\<in> set rtbl\""], ["proof (prove)\nusing this:\n  rr' \\<noteq> rr\n\ngoal (1 subgoal):\n 1. rr' \\<in> set rtbl", "using rr'"], ["proof (prove)\nusing this:\n  rr' \\<noteq> rr\n  rr' \\<in> set (rr # rtbl)\n  prefix_match_semantics (routing_match rr') addr \\<and>\n  routing_action rr' = act \\<and>\n  (\\<forall>ra\\<in>set (rr # rtbl).\n      routing_rule_sort_key ra < routing_rule_sort_key rr' \\<longrightarrow>\n      \\<not> prefix_match_semantics (routing_match ra) addr)\n\ngoal (1 subgoal):\n 1. rr' \\<in> set rtbl", "by simp"], ["proof (state)\nthis:\n  rr' \\<in> set rtbl\n\ngoal (1 subgoal):\n 1. rr' \\<noteq> rr \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "assume eq: \"routing_match rr' = routing_match rr\""], ["proof (state)\nthis:\n  routing_match rr' = routing_match rr\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "with e"], ["proof (chain)\npicking this:\n  rr' \\<in> set rtbl\n  routing_match rr' = routing_match rr", "have \"routing_rule_sort_key rr < routing_rule_sort_key rr'\""], ["proof (prove)\nusing this:\n  rr' \\<in> set rtbl\n  routing_match rr' = routing_match rr\n\ngoal (1 subgoal):\n 1. routing_rule_sort_key rr < routing_rule_sort_key rr'", "using unambigous_prefix_routing_strong_mono[OF Cons.prems(2,4) _ eq]"], ["proof (prove)\nusing this:\n  rr' \\<in> set rtbl\n  routing_match rr' = routing_match rr\n  rr' \\<in> set rtbl \\<Longrightarrow>\n  routing_rule_sort_key rr < routing_rule_sort_key rr'\n\ngoal (1 subgoal):\n 1. routing_rule_sort_key rr < routing_rule_sort_key rr'", "by simp"], ["proof (state)\nthis:\n  routing_rule_sort_key rr < routing_rule_sort_key rr'\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "with True rr'"], ["proof (chain)\npicking this:\n  prefix_match_semantics (routing_match rr) addr\n  rr' \\<in> set (rr # rtbl)\n  prefix_match_semantics (routing_match rr') addr \\<and>\n  routing_action rr' = act \\<and>\n  (\\<forall>ra\\<in>set (rr # rtbl).\n      routing_rule_sort_key ra < routing_rule_sort_key rr' \\<longrightarrow>\n      \\<not> prefix_match_semantics (routing_match ra) addr)\n  routing_rule_sort_key rr < routing_rule_sort_key rr'", "show False"], ["proof (prove)\nusing this:\n  prefix_match_semantics (routing_match rr) addr\n  rr' \\<in> set (rr # rtbl)\n  prefix_match_semantics (routing_match rr') addr \\<and>\n  routing_action rr' = act \\<and>\n  (\\<forall>ra\\<in>set (rr # rtbl).\n      routing_rule_sort_key ra < routing_rule_sort_key rr' \\<longrightarrow>\n      \\<not> prefix_match_semantics (routing_match ra) addr)\n  routing_rule_sort_key rr < routing_rule_sort_key rr'\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. routing_match rr' \\<noteq> routing_match rr \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. routing_match rr' \\<noteq> routing_match rr \\<Longrightarrow> False", "assume ne: \"routing_match rr' \\<noteq> routing_match rr\""], ["proof (state)\nthis:\n  routing_match rr' \\<noteq> routing_match rr\n\ngoal (1 subgoal):\n 1. routing_match rr' \\<noteq> routing_match rr \\<Longrightarrow> False", "from rr' Cons.prems"], ["proof (chain)\npicking this:\n  rr' \\<in> set (rr # rtbl)\n  prefix_match_semantics (routing_match rr') addr \\<and>\n  routing_action rr' = act \\<and>\n  (\\<forall>ra\\<in>set (rr # rtbl).\n      routing_rule_sort_key ra < routing_rule_sort_key rr' \\<longrightarrow>\n      \\<not> prefix_match_semantics (routing_match ra) addr)\n  valid_prefixes (rr # rtbl)\n  is_longest_prefix_routing (rr # rtbl)\n  has_default_route (rr # rtbl)\n  unambiguous_routing (rr # rtbl)", "have \"valid_prefix (routing_match rr)\" \"valid_prefix (routing_match rr')\" \"prefix_match_semantics (routing_match rr') addr\""], ["proof (prove)\nusing this:\n  rr' \\<in> set (rr # rtbl)\n  prefix_match_semantics (routing_match rr') addr \\<and>\n  routing_action rr' = act \\<and>\n  (\\<forall>ra\\<in>set (rr # rtbl).\n      routing_rule_sort_key ra < routing_rule_sort_key rr' \\<longrightarrow>\n      \\<not> prefix_match_semantics (routing_match ra) addr)\n  valid_prefixes (rr # rtbl)\n  is_longest_prefix_routing (rr # rtbl)\n  has_default_route (rr # rtbl)\n  unambiguous_routing (rr # rtbl)\n\ngoal (1 subgoal):\n 1. valid_prefix (routing_match rr) &&&\n    valid_prefix (routing_match rr') &&&\n    prefix_match_semantics (routing_match rr') addr", "by(auto simp add: valid_prefixes_alt_def)"], ["proof (state)\nthis:\n  valid_prefix (routing_match rr)\n  valid_prefix (routing_match rr')\n  prefix_match_semantics (routing_match rr') addr\n\ngoal (1 subgoal):\n 1. routing_match rr' \\<noteq> routing_match rr \\<Longrightarrow> False", "note same_length_prefixes_distinct[OF this(1,2) ne[symmetric] _ True this(3)]"], ["proof (state)\nthis:\n  routing_prefix rr = routing_prefix rr' \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. routing_match rr' \\<noteq> routing_match rr \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  routing_prefix rr = routing_prefix rr' \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. routing_match rr' \\<noteq> routing_match rr \\<Longrightarrow> False", "have \"routing_prefix rr = routing_prefix rr'\" (is ?pe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. routing_prefix rr = routing_prefix rr'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. routing_prefix rr = routing_prefix rr'", "have \"routing_rule_sort_key rr < routing_rule_sort_key rr' \\<longrightarrow> \\<not> prefix_match_semantics (routing_match rr) addr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. routing_rule_sort_key rr < routing_rule_sort_key rr' \\<longrightarrow>\n    \\<not> prefix_match_semantics (routing_match rr) addr", "using rr'"], ["proof (prove)\nusing this:\n  rr' \\<in> set (rr # rtbl)\n  prefix_match_semantics (routing_match rr') addr \\<and>\n  routing_action rr' = act \\<and>\n  (\\<forall>ra\\<in>set (rr # rtbl).\n      routing_rule_sort_key ra < routing_rule_sort_key rr' \\<longrightarrow>\n      \\<not> prefix_match_semantics (routing_match ra) addr)\n\ngoal (1 subgoal):\n 1. routing_rule_sort_key rr < routing_rule_sort_key rr' \\<longrightarrow>\n    \\<not> prefix_match_semantics (routing_match rr) addr", "by simp"], ["proof (state)\nthis:\n  routing_rule_sort_key rr < routing_rule_sort_key rr' \\<longrightarrow>\n  \\<not> prefix_match_semantics (routing_match rr) addr\n\ngoal (1 subgoal):\n 1. routing_prefix rr = routing_prefix rr'", "with unambigous_prefix_routing_weak_mono[OF Cons.prems(2) e] True"], ["proof (chain)\npicking this:\n  routing_rule_sort_key rr \\<le> routing_rule_sort_key rr'\n  prefix_match_semantics (routing_match rr) addr\n  routing_rule_sort_key rr < routing_rule_sort_key rr' \\<longrightarrow>\n  \\<not> prefix_match_semantics (routing_match rr) addr", "have \"routing_rule_sort_key rr = routing_rule_sort_key rr'\""], ["proof (prove)\nusing this:\n  routing_rule_sort_key rr \\<le> routing_rule_sort_key rr'\n  prefix_match_semantics (routing_match rr) addr\n  routing_rule_sort_key rr < routing_rule_sort_key rr' \\<longrightarrow>\n  \\<not> prefix_match_semantics (routing_match rr) addr\n\ngoal (1 subgoal):\n 1. routing_rule_sort_key rr = routing_rule_sort_key rr'", "by simp"], ["proof (state)\nthis:\n  routing_rule_sort_key rr = routing_rule_sort_key rr'\n\ngoal (1 subgoal):\n 1. routing_prefix rr = routing_prefix rr'", "thus ?pe"], ["proof (prove)\nusing this:\n  routing_rule_sort_key rr = routing_rule_sort_key rr'\n\ngoal (1 subgoal):\n 1. routing_prefix rr = routing_prefix rr'", "by(simp add: routing_rule_sort_key_def int_of_nat_def)"], ["proof (state)\nthis:\n  routing_prefix rr = routing_prefix rr'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  routing_prefix rr = routing_prefix rr'\n\ngoal (1 subgoal):\n 1. routing_match rr' \\<noteq> routing_match rr \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  routing_prefix rr = routing_prefix rr' \\<Longrightarrow> False\n  routing_prefix rr = routing_prefix rr'", "show False"], ["proof (prove)\nusing this:\n  routing_prefix rr = routing_prefix rr' \\<Longrightarrow> False\n  routing_prefix rr = routing_prefix rr'\n\ngoal (1 subgoal):\n 1. False", "."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rr' = rr\n\ngoal (1 subgoal):\n 1. \\<exists>rra\\<in>set (rr # rtbl).\n       prefix_match_semantics (routing_match rra) addr \\<and>\n       routing_action rra = act \\<and>\n       (\\<forall>ra\\<in>set (rr # rtbl).\n           routing_rule_sort_key ra\n           < routing_rule_sort_key rra \\<longrightarrow>\n           \\<not> prefix_match_semantics (routing_match ra)\n                   addr) \\<Longrightarrow>\n    routing_table_semantics (rr # rtbl) addr = act", "thus ?l"], ["proof (prove)\nusing this:\n  rr' = rr\n\ngoal (1 subgoal):\n 1. routing_table_semantics (rr # rtbl) addr = act", "using rr'"], ["proof (prove)\nusing this:\n  rr' = rr\n  rr' \\<in> set (rr # rtbl)\n  prefix_match_semantics (routing_match rr') addr \\<and>\n  routing_action rr' = act \\<and>\n  (\\<forall>ra\\<in>set (rr # rtbl).\n      routing_rule_sort_key ra < routing_rule_sort_key rr' \\<longrightarrow>\n      \\<not> prefix_match_semantics (routing_match ra) addr)\n\ngoal (1 subgoal):\n 1. routing_table_semantics (rr # rtbl) addr = act", "by simp"], ["proof (state)\nthis:\n  routing_table_semantics (rr # rtbl) addr = act\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (routing_table_semantics (rr # rtbl) addr = act) =\n  (\\<exists>rra\\<in>set (rr # rtbl).\n      prefix_match_semantics (routing_match rra) addr \\<and>\n      routing_action rra = act \\<and>\n      (\\<forall>ra\\<in>set (rr # rtbl).\n          routing_rule_sort_key ra\n          < routing_rule_sort_key rra \\<longrightarrow>\n          \\<not> prefix_match_semantics (routing_match ra) addr))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (routing_table_semantics (rr # rtbl) addr = act) =\n  (\\<exists>rra\\<in>set (rr # rtbl).\n      prefix_match_semantics (routing_match rra) addr \\<and>\n      routing_action rra = act \\<and>\n      (\\<forall>ra\\<in>set (rr # rtbl).\n          routing_rule_sort_key ra\n          < routing_rule_sort_key rra \\<longrightarrow>\n          \\<not> prefix_match_semantics (routing_match ra) addr))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Printing\\<close>"], ["", "definition \"routing_rule_32_toString (rr::32 routing_rule) \\<equiv> \n  prefix_match_32_toString (routing_match rr) \n@ (case next_hop (routing_action rr) of Some nh \\<Rightarrow> '' via '' @ ipv4addr_toString nh | _ \\<Rightarrow> [])\n@ '' dev '' @ routing_oiface rr \n@ '' metric '' @ string_of_nat (metric rr)\""], ["", "definition \"routing_rule_128_toString (rr::128 routing_rule) \\<equiv> \n  prefix_match_128_toString (routing_match rr) \n@ (case next_hop (routing_action rr) of Some nh \\<Rightarrow> '' via '' @ ipv6addr_toString nh | _ \\<Rightarrow> [])\n@ '' dev '' @ routing_oiface rr \n@ '' metric '' @ string_of_nat (metric rr)\""], ["", "lemma \"map routing_rule_32_toString \n[rr_ctor (42,0,0,0) 7 ''eth0'' None 808, \n rr_ctor (0,0,0,0) 0 ''eth1'' (Some (222,173,190,239)) 707] =\n[''42.0.0.0/7 dev eth0 metric 808'',\n ''0.0.0.0/0 via 222.173.190.239 dev eth1 metric 707'']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map routing_rule_32_toString\n     [rr_ctor (42, 0, 0, 0) 7 ''eth0'' None 808,\n      rr_ctor (0, 0, 0, 0) 0 ''eth1'' (Some (222, 173, 190, 239)) 707] =\n    [''42.0.0.0/7 dev eth0 metric 808'',\n     ''0.0.0.0/0 via 222.173.190.239 dev eth1 metric 707'']", "by eval"], ["", "section\\<open>Routing table to Relation\\<close>"], ["", "text\\<open>Walking through a routing table splits the (remaining) IP space when traversing a routing table into a pair of sets:\n the pair contains the IPs concerned by the current rule and those left alone.\\<close>"], ["", "private"], ["", "definition ipset_prefix_match where \n  \"ipset_prefix_match pfx rg = (let pfxrg = prefix_to_wordset pfx in (rg \\<inter> pfxrg, rg - pfxrg))\""], ["", "private"], ["", "lemma ipset_prefix_match_m[simp]:  \"fst (ipset_prefix_match pfx rg) = rg \\<inter> (prefix_to_wordset pfx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (ipset_prefix_match pfx rg) = rg \\<inter> prefix_to_wordset pfx", "by(simp only: Let_def ipset_prefix_match_def, simp)"], ["", "private"], ["", "lemma ipset_prefix_match_nm[simp]: \"snd (ipset_prefix_match pfx rg) = rg - (prefix_to_wordset pfx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (ipset_prefix_match pfx rg) = rg - prefix_to_wordset pfx", "by(simp only: Let_def ipset_prefix_match_def, simp)"], ["", "private"], ["", "lemma ipset_prefix_match_distinct: \"rpm = ipset_prefix_match pfx rg \\<Longrightarrow> \n  (fst rpm) \\<inter> (snd rpm) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rpm = ipset_prefix_match pfx rg \\<Longrightarrow>\n    fst rpm \\<inter> snd rpm = {}", "by force"], ["", "private"], ["", "lemma ipset_prefix_match_complete: \"rpm = ipset_prefix_match pfx rg \\<Longrightarrow> \n  (fst rpm) \\<union> (snd rpm) = rg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rpm = ipset_prefix_match pfx rg \\<Longrightarrow>\n    fst rpm \\<union> snd rpm = rg", "by force"], ["", "private"], ["", "lemma rpm_m_dup_simp: \"rg \\<inter> fst (ipset_prefix_match (routing_match r) rg) = fst (ipset_prefix_match (routing_match r) rg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rg \\<inter> fst (ipset_prefix_match (routing_match r) rg) =\n    fst (ipset_prefix_match (routing_match r) rg)", "by simp"], ["", "private"], ["", "definition range_prefix_match :: \"'i::len prefix_match \\<Rightarrow> 'i wordinterval \\<Rightarrow> 'i wordinterval \\<times> 'i wordinterval\" where\n  \"range_prefix_match pfx rg \\<equiv> (let pfxrg = prefix_to_wordinterval pfx in \n  (wordinterval_intersection rg pfxrg, wordinterval_setminus rg pfxrg))\""], ["", "private"], ["", "lemma range_prefix_match_set_eq:\n  \"(\\<lambda>(r1,r2). (wordinterval_to_set r1, wordinterval_to_set r2)) (range_prefix_match pfx rg) =\n    ipset_prefix_match pfx (wordinterval_to_set rg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case range_prefix_match pfx rg of\n     (r1, r2) \\<Rightarrow>\n       (wordinterval_to_set r1, wordinterval_to_set r2)) =\n    ipset_prefix_match pfx (wordinterval_to_set rg)", "unfolding range_prefix_match_def ipset_prefix_match_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (wordinterval_intersection rg (prefix_to_wordinterval pfx),\n           wordinterval_setminus rg (prefix_to_wordinterval pfx)) of\n     (r1, r2) \\<Rightarrow>\n       (wordinterval_to_set r1, wordinterval_to_set r2)) =\n    (wordinterval_to_set rg \\<inter> prefix_to_wordset pfx,\n     wordinterval_to_set rg - prefix_to_wordset pfx)", "using wordinterval_intersection_set_eq wordinterval_setminus_set_eq prefix_to_wordinterval_set_eq"], ["proof (prove)\nusing this:\n  wordinterval_to_set (wordinterval_intersection ?r1.0 ?r2.0) =\n  wordinterval_to_set ?r1.0 \\<inter> wordinterval_to_set ?r2.0\n  wordinterval_to_set (wordinterval_setminus ?r1.0 ?r2.0) =\n  wordinterval_to_set ?r1.0 - wordinterval_to_set ?r2.0\n  wordinterval_to_set (prefix_to_wordinterval ?pfx) = prefix_to_wordset ?pfx\n\ngoal (1 subgoal):\n 1. (case (wordinterval_intersection rg (prefix_to_wordinterval pfx),\n           wordinterval_setminus rg (prefix_to_wordinterval pfx)) of\n     (r1, r2) \\<Rightarrow>\n       (wordinterval_to_set r1, wordinterval_to_set r2)) =\n    (wordinterval_to_set rg \\<inter> prefix_to_wordset pfx,\n     wordinterval_to_set rg - prefix_to_wordset pfx)", "by auto"], ["", "private"], ["", "lemma range_prefix_match_sm[simp]:  \"wordinterval_to_set (fst (range_prefix_match pfx rg)) = \n    fst (ipset_prefix_match pfx (wordinterval_to_set rg))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set (fst (range_prefix_match pfx rg)) =\n    fst (ipset_prefix_match pfx (wordinterval_to_set rg))", "by (metis fst_conv ipset_prefix_match_m  wordinterval_intersection_set_eq prefix_to_wordinterval_set_eq range_prefix_match_def)"], ["", "private"], ["", "lemma range_prefix_match_snm[simp]: \"wordinterval_to_set (snd (range_prefix_match pfx rg)) =\n    snd (ipset_prefix_match pfx (wordinterval_to_set rg))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set (snd (range_prefix_match pfx rg)) =\n    snd (ipset_prefix_match pfx (wordinterval_to_set rg))", "by (metis snd_conv ipset_prefix_match_nm wordinterval_setminus_set_eq prefix_to_wordinterval_set_eq range_prefix_match_def)"], ["", "subsection\\<open>Wordintervals for Ports by Routing\\<close>"], ["", "text\\<open>This split, although rather trivial, \ncan be used to construct the sets (or rather: the intervals) \nof IPs that are actually matched by an entry in a routing table.\\<close>"], ["", "private"], ["", "fun routing_port_ranges :: \"'i prefix_routing \\<Rightarrow> 'i wordinterval \\<Rightarrow> (string \\<times> ('i::len) wordinterval) list\" where\n\"routing_port_ranges [] lo = (if wordinterval_empty lo then [] else [(routing_oiface (undefined::'i routing_rule),lo)])\" | (* insert default route to nirvana. has to match what routing_table_semantics does. *)\n\"routing_port_ranges (a#as) lo = (\n\tlet rpm = range_prefix_match (routing_match a) lo; m = fst rpm; nm = snd rpm in (\n\t(routing_oiface a,m) # routing_port_ranges as nm))\""], ["", "private"], ["", "lemma routing_port_ranges_subsets:\n\"(a1, b1) \\<in> set (routing_port_ranges tbl s) \\<Longrightarrow> wordinterval_to_set b1 \\<subseteq> wordinterval_to_set s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a1, b1) \\<in> set (routing_port_ranges tbl s) \\<Longrightarrow>\n    wordinterval_to_set b1 \\<subseteq> wordinterval_to_set s", "by(induction tbl arbitrary: s; fastforce simp add: Let_def split: if_splits)"], ["", "private"], ["", "lemma routing_port_ranges_sound: \"e \\<in> set (routing_port_ranges tbl s) \\<Longrightarrow> k \\<in> wordinterval_to_set (snd e) \\<Longrightarrow> valid_prefixes tbl \\<Longrightarrow>\n\tfst e = output_iface (routing_table_semantics tbl k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> set (routing_port_ranges tbl s);\n     k \\<in> wordinterval_to_set (snd e); valid_prefixes tbl\\<rbrakk>\n    \\<Longrightarrow> fst e = output_iface (routing_table_semantics tbl k)", "proof(induction tbl arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>e \\<in> set (routing_port_ranges [] s);\n        k \\<in> wordinterval_to_set (snd e); valid_prefixes []\\<rbrakk>\n       \\<Longrightarrow> fst e = output_iface (routing_table_semantics [] k)\n 2. \\<And>a tbl s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>e \\<in> set (routing_port_ranges tbl s);\n                    k \\<in> wordinterval_to_set (snd e);\n                    valid_prefixes tbl\\<rbrakk>\n                   \\<Longrightarrow> fst e =\n                                     output_iface\n(routing_table_semantics tbl k);\n        e \\<in> set (routing_port_ranges (a # tbl) s);\n        k \\<in> wordinterval_to_set (snd e);\n        valid_prefixes (a # tbl)\\<rbrakk>\n       \\<Longrightarrow> fst e =\n                         output_iface (routing_table_semantics (a # tbl) k)", "case (Cons a as)"], ["proof (state)\nthis:\n  \\<lbrakk>e \\<in> set (routing_port_ranges as ?s);\n   k \\<in> wordinterval_to_set (snd e); valid_prefixes as\\<rbrakk>\n  \\<Longrightarrow> fst e = output_iface (routing_table_semantics as k)\n  e \\<in> set (routing_port_ranges (a # as) s)\n  k \\<in> wordinterval_to_set (snd e)\n  valid_prefixes (a # as)\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>e \\<in> set (routing_port_ranges [] s);\n        k \\<in> wordinterval_to_set (snd e); valid_prefixes []\\<rbrakk>\n       \\<Longrightarrow> fst e = output_iface (routing_table_semantics [] k)\n 2. \\<And>a tbl s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>e \\<in> set (routing_port_ranges tbl s);\n                    k \\<in> wordinterval_to_set (snd e);\n                    valid_prefixes tbl\\<rbrakk>\n                   \\<Longrightarrow> fst e =\n                                     output_iface\n(routing_table_semantics tbl k);\n        e \\<in> set (routing_port_ranges (a # tbl) s);\n        k \\<in> wordinterval_to_set (snd e);\n        valid_prefixes (a # tbl)\\<rbrakk>\n       \\<Longrightarrow> fst e =\n                         output_iface (routing_table_semantics (a # tbl) k)", "note s = Cons.prems(1)[unfolded routing_port_ranges.simps Let_def list.set]"], ["proof (state)\nthis:\n  e \\<in> insert\n           (routing_oiface a, fst (range_prefix_match (routing_match a) s))\n           (set (routing_port_ranges as\n                  (snd (range_prefix_match (routing_match a) s))))\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>e \\<in> set (routing_port_ranges [] s);\n        k \\<in> wordinterval_to_set (snd e); valid_prefixes []\\<rbrakk>\n       \\<Longrightarrow> fst e = output_iface (routing_table_semantics [] k)\n 2. \\<And>a tbl s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>e \\<in> set (routing_port_ranges tbl s);\n                    k \\<in> wordinterval_to_set (snd e);\n                    valid_prefixes tbl\\<rbrakk>\n                   \\<Longrightarrow> fst e =\n                                     output_iface\n(routing_table_semantics tbl k);\n        e \\<in> set (routing_port_ranges (a # tbl) s);\n        k \\<in> wordinterval_to_set (snd e);\n        valid_prefixes (a # tbl)\\<rbrakk>\n       \\<Longrightarrow> fst e =\n                         output_iface (routing_table_semantics (a # tbl) k)", "note vpfx = valid_prefixes_split[OF Cons.prems(3)]"], ["proof (state)\nthis:\n  valid_prefix (routing_match a) \\<and> valid_prefixes as\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>e \\<in> set (routing_port_ranges [] s);\n        k \\<in> wordinterval_to_set (snd e); valid_prefixes []\\<rbrakk>\n       \\<Longrightarrow> fst e = output_iface (routing_table_semantics [] k)\n 2. \\<And>a tbl s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>e \\<in> set (routing_port_ranges tbl s);\n                    k \\<in> wordinterval_to_set (snd e);\n                    valid_prefixes tbl\\<rbrakk>\n                   \\<Longrightarrow> fst e =\n                                     output_iface\n(routing_table_semantics tbl k);\n        e \\<in> set (routing_port_ranges (a # tbl) s);\n        k \\<in> wordinterval_to_set (snd e);\n        valid_prefixes (a # tbl)\\<rbrakk>\n       \\<Longrightarrow> fst e =\n                         output_iface (routing_table_semantics (a # tbl) k)", "show ?case (is ?kees)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst e = output_iface (routing_table_semantics (a # as) k)", "proof(cases \"e = (routing_oiface a, fst (range_prefix_match (routing_match a) s))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. e =\n    (routing_oiface a,\n     fst (range_prefix_match (routing_match a) s)) \\<Longrightarrow>\n    fst e = output_iface (routing_table_semantics (a # as) k)\n 2. e \\<noteq>\n    (routing_oiface a,\n     fst (range_prefix_match (routing_match a) s)) \\<Longrightarrow>\n    fst e = output_iface (routing_table_semantics (a # as) k)", "case False"], ["proof (state)\nthis:\n  e \\<noteq>\n  (routing_oiface a, fst (range_prefix_match (routing_match a) s))\n\ngoal (2 subgoals):\n 1. e =\n    (routing_oiface a,\n     fst (range_prefix_match (routing_match a) s)) \\<Longrightarrow>\n    fst e = output_iface (routing_table_semantics (a # as) k)\n 2. e \\<noteq>\n    (routing_oiface a,\n     fst (range_prefix_match (routing_match a) s)) \\<Longrightarrow>\n    fst e = output_iface (routing_table_semantics (a # as) k)", "hence es: \"e \\<in> set (routing_port_ranges as (snd (range_prefix_match (routing_match a) s)))\""], ["proof (prove)\nusing this:\n  e \\<noteq>\n  (routing_oiface a, fst (range_prefix_match (routing_match a) s))\n\ngoal (1 subgoal):\n 1. e \\<in> set (routing_port_ranges as\n                  (snd (range_prefix_match (routing_match a) s)))", "using s"], ["proof (prove)\nusing this:\n  e \\<noteq>\n  (routing_oiface a, fst (range_prefix_match (routing_match a) s))\n  e \\<in> insert\n           (routing_oiface a, fst (range_prefix_match (routing_match a) s))\n           (set (routing_port_ranges as\n                  (snd (range_prefix_match (routing_match a) s))))\n\ngoal (1 subgoal):\n 1. e \\<in> set (routing_port_ranges as\n                  (snd (range_prefix_match (routing_match a) s)))", "by blast"], ["proof (state)\nthis:\n  e \\<in> set (routing_port_ranges as\n                (snd (range_prefix_match (routing_match a) s)))\n\ngoal (2 subgoals):\n 1. e =\n    (routing_oiface a,\n     fst (range_prefix_match (routing_match a) s)) \\<Longrightarrow>\n    fst e = output_iface (routing_table_semantics (a # as) k)\n 2. e \\<noteq>\n    (routing_oiface a,\n     fst (range_prefix_match (routing_match a) s)) \\<Longrightarrow>\n    fst e = output_iface (routing_table_semantics (a # as) k)", "note eq = Cons.IH[OF this Cons.prems(2) conjunct2[OF vpfx]]"], ["proof (state)\nthis:\n  fst e = output_iface (routing_table_semantics as k)\n\ngoal (2 subgoals):\n 1. e =\n    (routing_oiface a,\n     fst (range_prefix_match (routing_match a) s)) \\<Longrightarrow>\n    fst e = output_iface (routing_table_semantics (a # as) k)\n 2. e \\<noteq>\n    (routing_oiface a,\n     fst (range_prefix_match (routing_match a) s)) \\<Longrightarrow>\n    fst e = output_iface (routing_table_semantics (a # as) k)", "have \"\\<not>prefix_match_semantics (routing_match a) k\" (is ?nom)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> prefix_match_semantics (routing_match a) k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> prefix_match_semantics (routing_match a) k", "from routing_port_ranges_subsets[of \"fst e\" \"snd e\", unfolded prod.collapse, OF es]"], ["proof (chain)\npicking this:\n  wordinterval_to_set (snd e)\n  \\<subseteq> wordinterval_to_set\n               (snd (range_prefix_match (routing_match a) s))", "have *: \"wordinterval_to_set (snd e) \\<subseteq> wordinterval_to_set (snd (range_prefix_match (routing_match a) s))\""], ["proof (prove)\nusing this:\n  wordinterval_to_set (snd e)\n  \\<subseteq> wordinterval_to_set\n               (snd (range_prefix_match (routing_match a) s))\n\ngoal (1 subgoal):\n 1. wordinterval_to_set (snd e)\n    \\<subseteq> wordinterval_to_set\n                 (snd (range_prefix_match (routing_match a) s))", "."], ["proof (state)\nthis:\n  wordinterval_to_set (snd e)\n  \\<subseteq> wordinterval_to_set\n               (snd (range_prefix_match (routing_match a) s))\n\ngoal (1 subgoal):\n 1. \\<not> prefix_match_semantics (routing_match a) k", "show ?nom"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> prefix_match_semantics (routing_match a) k", "unfolding prefix_match_semantics_wordset[OF conjunct1[OF vpfx]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<notin> prefix_to_wordset (routing_match a)", "using * Cons.prems(2)"], ["proof (prove)\nusing this:\n  wordinterval_to_set (snd e)\n  \\<subseteq> wordinterval_to_set\n               (snd (range_prefix_match (routing_match a) s))\n  k \\<in> wordinterval_to_set (snd e)\n\ngoal (1 subgoal):\n 1. k \\<notin> prefix_to_wordset (routing_match a)", "unfolding wordinterval_subset_set_eq"], ["proof (prove)\nusing this:\n  wordinterval_to_set (snd e)\n  \\<subseteq> wordinterval_to_set\n               (snd (range_prefix_match (routing_match a) s))\n  k \\<in> wordinterval_to_set (snd e)\n\ngoal (1 subgoal):\n 1. k \\<notin> prefix_to_wordset (routing_match a)", "by(auto simp add: range_prefix_match_def Let_def)"], ["proof (state)\nthis:\n  \\<not> prefix_match_semantics (routing_match a) k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> prefix_match_semantics (routing_match a) k\n\ngoal (2 subgoals):\n 1. e =\n    (routing_oiface a,\n     fst (range_prefix_match (routing_match a) s)) \\<Longrightarrow>\n    fst e = output_iface (routing_table_semantics (a # as) k)\n 2. e \\<noteq>\n    (routing_oiface a,\n     fst (range_prefix_match (routing_match a) s)) \\<Longrightarrow>\n    fst e = output_iface (routing_table_semantics (a # as) k)", "thus ?kees"], ["proof (prove)\nusing this:\n  \\<not> prefix_match_semantics (routing_match a) k\n\ngoal (1 subgoal):\n 1. fst e = output_iface (routing_table_semantics (a # as) k)", "using eq"], ["proof (prove)\nusing this:\n  \\<not> prefix_match_semantics (routing_match a) k\n  fst e = output_iface (routing_table_semantics as k)\n\ngoal (1 subgoal):\n 1. fst e = output_iface (routing_table_semantics (a # as) k)", "by simp"], ["proof (state)\nthis:\n  fst e = output_iface (routing_table_semantics (a # as) k)\n\ngoal (1 subgoal):\n 1. e =\n    (routing_oiface a,\n     fst (range_prefix_match (routing_match a) s)) \\<Longrightarrow>\n    fst e = output_iface (routing_table_semantics (a # as) k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. e =\n    (routing_oiface a,\n     fst (range_prefix_match (routing_match a) s)) \\<Longrightarrow>\n    fst e = output_iface (routing_table_semantics (a # as) k)", "case True"], ["proof (state)\nthis:\n  e = (routing_oiface a, fst (range_prefix_match (routing_match a) s))\n\ngoal (1 subgoal):\n 1. e =\n    (routing_oiface a,\n     fst (range_prefix_match (routing_match a) s)) \\<Longrightarrow>\n    fst e = output_iface (routing_table_semantics (a # as) k)", "hence fe: \"fst e = routing_oiface a\""], ["proof (prove)\nusing this:\n  e = (routing_oiface a, fst (range_prefix_match (routing_match a) s))\n\ngoal (1 subgoal):\n 1. fst e = routing_oiface a", "by simp"], ["proof (state)\nthis:\n  fst e = routing_oiface a\n\ngoal (1 subgoal):\n 1. e =\n    (routing_oiface a,\n     fst (range_prefix_match (routing_match a) s)) \\<Longrightarrow>\n    fst e = output_iface (routing_table_semantics (a # as) k)", "from True"], ["proof (chain)\npicking this:\n  e = (routing_oiface a, fst (range_prefix_match (routing_match a) s))", "have \"k \\<in> wordinterval_to_set (fst (range_prefix_match (routing_match a) s))\""], ["proof (prove)\nusing this:\n  e = (routing_oiface a, fst (range_prefix_match (routing_match a) s))\n\ngoal (1 subgoal):\n 1. k \\<in> wordinterval_to_set\n             (fst (range_prefix_match (routing_match a) s))", "using Cons.prems(2)"], ["proof (prove)\nusing this:\n  e = (routing_oiface a, fst (range_prefix_match (routing_match a) s))\n  k \\<in> wordinterval_to_set (snd e)\n\ngoal (1 subgoal):\n 1. k \\<in> wordinterval_to_set\n             (fst (range_prefix_match (routing_match a) s))", "by(simp)"], ["proof (state)\nthis:\n  k \\<in> wordinterval_to_set (fst (range_prefix_match (routing_match a) s))\n\ngoal (1 subgoal):\n 1. e =\n    (routing_oiface a,\n     fst (range_prefix_match (routing_match a) s)) \\<Longrightarrow>\n    fst e = output_iface (routing_table_semantics (a # as) k)", "hence \"prefix_match_semantics (routing_match a) k\""], ["proof (prove)\nusing this:\n  k \\<in> wordinterval_to_set (fst (range_prefix_match (routing_match a) s))\n\ngoal (1 subgoal):\n 1. prefix_match_semantics (routing_match a) k", "unfolding prefix_match_semantics_wordset[OF conjunct1, OF vpfx]"], ["proof (prove)\nusing this:\n  k \\<in> wordinterval_to_set (fst (range_prefix_match (routing_match a) s))\n\ngoal (1 subgoal):\n 1. k \\<in> prefix_to_wordset (routing_match a)", "unfolding range_prefix_match_def Let_def"], ["proof (prove)\nusing this:\n  k \\<in> wordinterval_to_set\n           (fst (wordinterval_intersection s\n                  (prefix_to_wordinterval (routing_match a)),\n                 wordinterval_setminus s\n                  (prefix_to_wordinterval (routing_match a))))\n\ngoal (1 subgoal):\n 1. k \\<in> prefix_to_wordset (routing_match a)", "by simp"], ["proof (state)\nthis:\n  prefix_match_semantics (routing_match a) k\n\ngoal (1 subgoal):\n 1. e =\n    (routing_oiface a,\n     fst (range_prefix_match (routing_match a) s)) \\<Longrightarrow>\n    fst e = output_iface (routing_table_semantics (a # as) k)", "thus ?kees"], ["proof (prove)\nusing this:\n  prefix_match_semantics (routing_match a) k\n\ngoal (1 subgoal):\n 1. fst e = output_iface (routing_table_semantics (a # as) k)", "by(simp add: fe)"], ["proof (state)\nthis:\n  fst e = output_iface (routing_table_semantics (a # as) k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst e = output_iface (routing_table_semantics (a # as) k)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>e \\<in> set (routing_port_ranges [] s);\n        k \\<in> wordinterval_to_set (snd e); valid_prefixes []\\<rbrakk>\n       \\<Longrightarrow> fst e = output_iface (routing_table_semantics [] k)", "qed (simp split: if_splits)"], ["", "private"], ["", "lemma routing_port_ranges_disjoined:\nassumes vpfx: \"valid_prefixes tbl\"\n  and ins:  \"(a1, b1) \\<in> set (routing_port_ranges tbl s)\" \"(a2, b2) \\<in> set (routing_port_ranges tbl s)\"\n  and nemp: \"wordinterval_to_set b1 \\<noteq> {}\"\nshows \"b1 \\<noteq> b2 \\<longleftrightarrow> wordinterval_to_set b1 \\<inter> wordinterval_to_set b2 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b1 \\<noteq> b2) =\n    (wordinterval_to_set b1 \\<inter> wordinterval_to_set b2 = {})", "using assms"], ["proof (prove)\nusing this:\n  valid_prefixes tbl\n  (a1, b1) \\<in> set (routing_port_ranges tbl s)\n  (a2, b2) \\<in> set (routing_port_ranges tbl s)\n  wordinterval_to_set b1 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (b1 \\<noteq> b2) =\n    (wordinterval_to_set b1 \\<inter> wordinterval_to_set b2 = {})", "proof(induction tbl arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>valid_prefixes [];\n        (a1, b1) \\<in> set (routing_port_ranges [] s);\n        (a2, b2) \\<in> set (routing_port_ranges [] s);\n        wordinterval_to_set b1 \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (b1 \\<noteq> b2) =\n                         (wordinterval_to_set b1 \\<inter>\n                          wordinterval_to_set b2 =\n                          {})\n 2. \\<And>a tbl s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>valid_prefixes tbl;\n                    (a1, b1) \\<in> set (routing_port_ranges tbl s);\n                    (a2, b2) \\<in> set (routing_port_ranges tbl s);\n                    wordinterval_to_set b1 \\<noteq> {}\\<rbrakk>\n                   \\<Longrightarrow> (b1 \\<noteq> b2) =\n                                     (wordinterval_to_set b1 \\<inter>\nwordinterval_to_set b2 =\n{});\n        valid_prefixes (a # tbl);\n        (a1, b1) \\<in> set (routing_port_ranges (a # tbl) s);\n        (a2, b2) \\<in> set (routing_port_ranges (a # tbl) s);\n        wordinterval_to_set b1 \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (b1 \\<noteq> b2) =\n                         (wordinterval_to_set b1 \\<inter>\n                          wordinterval_to_set b2 =\n                          {})", "case (Cons r rs)"], ["proof (state)\nthis:\n  \\<lbrakk>valid_prefixes rs;\n   (a1, b1) \\<in> set (routing_port_ranges rs ?s);\n   (a2, b2) \\<in> set (routing_port_ranges rs ?s);\n   wordinterval_to_set b1 \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> (b1 \\<noteq> b2) =\n                    (wordinterval_to_set b1 \\<inter>\n                     wordinterval_to_set b2 =\n                     {})\n  valid_prefixes (r # rs)\n  (a1, b1) \\<in> set (routing_port_ranges (r # rs) s)\n  (a2, b2) \\<in> set (routing_port_ranges (r # rs) s)\n  wordinterval_to_set b1 \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>valid_prefixes [];\n        (a1, b1) \\<in> set (routing_port_ranges [] s);\n        (a2, b2) \\<in> set (routing_port_ranges [] s);\n        wordinterval_to_set b1 \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (b1 \\<noteq> b2) =\n                         (wordinterval_to_set b1 \\<inter>\n                          wordinterval_to_set b2 =\n                          {})\n 2. \\<And>a tbl s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>valid_prefixes tbl;\n                    (a1, b1) \\<in> set (routing_port_ranges tbl s);\n                    (a2, b2) \\<in> set (routing_port_ranges tbl s);\n                    wordinterval_to_set b1 \\<noteq> {}\\<rbrakk>\n                   \\<Longrightarrow> (b1 \\<noteq> b2) =\n                                     (wordinterval_to_set b1 \\<inter>\nwordinterval_to_set b2 =\n{});\n        valid_prefixes (a # tbl);\n        (a1, b1) \\<in> set (routing_port_ranges (a # tbl) s);\n        (a2, b2) \\<in> set (routing_port_ranges (a # tbl) s);\n        wordinterval_to_set b1 \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (b1 \\<noteq> b2) =\n                         (wordinterval_to_set b1 \\<inter>\n                          wordinterval_to_set b2 =\n                          {})", "have vpfx: \"valid_prefix (routing_match r)\" \"valid_prefixes rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_prefix (routing_match r) &&& valid_prefixes rs", "using Cons.prems(1)"], ["proof (prove)\nusing this:\n  valid_prefixes (r # rs)\n\ngoal (1 subgoal):\n 1. valid_prefix (routing_match r) &&& valid_prefixes rs", "using valid_prefixes_split"], ["proof (prove)\nusing this:\n  valid_prefixes (r # rs)\n  valid_prefixes (?r # ?rs) \\<Longrightarrow>\n  valid_prefix (routing_match ?r) \\<and> valid_prefixes ?rs\n\ngoal (1 subgoal):\n 1. valid_prefix (routing_match r) &&& valid_prefixes rs", "by blast+"], ["proof (state)\nthis:\n  valid_prefix (routing_match r)\n  valid_prefixes rs\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>valid_prefixes [];\n        (a1, b1) \\<in> set (routing_port_ranges [] s);\n        (a2, b2) \\<in> set (routing_port_ranges [] s);\n        wordinterval_to_set b1 \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (b1 \\<noteq> b2) =\n                         (wordinterval_to_set b1 \\<inter>\n                          wordinterval_to_set b2 =\n                          {})\n 2. \\<And>a tbl s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>valid_prefixes tbl;\n                    (a1, b1) \\<in> set (routing_port_ranges tbl s);\n                    (a2, b2) \\<in> set (routing_port_ranges tbl s);\n                    wordinterval_to_set b1 \\<noteq> {}\\<rbrakk>\n                   \\<Longrightarrow> (b1 \\<noteq> b2) =\n                                     (wordinterval_to_set b1 \\<inter>\nwordinterval_to_set b2 =\n{});\n        valid_prefixes (a # tbl);\n        (a1, b1) \\<in> set (routing_port_ranges (a # tbl) s);\n        (a2, b2) \\<in> set (routing_port_ranges (a # tbl) s);\n        wordinterval_to_set b1 \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (b1 \\<noteq> b2) =\n                         (wordinterval_to_set b1 \\<inter>\n                          wordinterval_to_set b2 =\n                          {})", "{"], ["proof (state)\nthis:\n  valid_prefix (routing_match r)\n  valid_prefixes rs\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>valid_prefixes [];\n        (a1, b1) \\<in> set (routing_port_ranges [] s);\n        (a2, b2) \\<in> set (routing_port_ranges [] s);\n        wordinterval_to_set b1 \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (b1 \\<noteq> b2) =\n                         (wordinterval_to_set b1 \\<inter>\n                          wordinterval_to_set b2 =\n                          {})\n 2. \\<And>a tbl s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>valid_prefixes tbl;\n                    (a1, b1) \\<in> set (routing_port_ranges tbl s);\n                    (a2, b2) \\<in> set (routing_port_ranges tbl s);\n                    wordinterval_to_set b1 \\<noteq> {}\\<rbrakk>\n                   \\<Longrightarrow> (b1 \\<noteq> b2) =\n                                     (wordinterval_to_set b1 \\<inter>\nwordinterval_to_set b2 =\n{});\n        valid_prefixes (a # tbl);\n        (a1, b1) \\<in> set (routing_port_ranges (a # tbl) s);\n        (a2, b2) \\<in> set (routing_port_ranges (a # tbl) s);\n        wordinterval_to_set b1 \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (b1 \\<noteq> b2) =\n                         (wordinterval_to_set b1 \\<inter>\n                          wordinterval_to_set b2 =\n                          {})", "(* In case that one of b1 b2 stems from r and one does not, we assume it is b1 WLOG. *)"], ["proof (state)\nthis:\n  valid_prefix (routing_match r)\n  valid_prefixes rs\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>valid_prefixes [];\n        (a1, b1) \\<in> set (routing_port_ranges [] s);\n        (a2, b2) \\<in> set (routing_port_ranges [] s);\n        wordinterval_to_set b1 \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (b1 \\<noteq> b2) =\n                         (wordinterval_to_set b1 \\<inter>\n                          wordinterval_to_set b2 =\n                          {})\n 2. \\<And>a tbl s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>valid_prefixes tbl;\n                    (a1, b1) \\<in> set (routing_port_ranges tbl s);\n                    (a2, b2) \\<in> set (routing_port_ranges tbl s);\n                    wordinterval_to_set b1 \\<noteq> {}\\<rbrakk>\n                   \\<Longrightarrow> (b1 \\<noteq> b2) =\n                                     (wordinterval_to_set b1 \\<inter>\nwordinterval_to_set b2 =\n{});\n        valid_prefixes (a # tbl);\n        (a1, b1) \\<in> set (routing_port_ranges (a # tbl) s);\n        (a2, b2) \\<in> set (routing_port_ranges (a # tbl) s);\n        wordinterval_to_set b1 \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (b1 \\<noteq> b2) =\n                         (wordinterval_to_set b1 \\<inter>\n                          wordinterval_to_set b2 =\n                          {})", "fix a1 b1 a2 b2"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>valid_prefixes [];\n        (a1, b1) \\<in> set (routing_port_ranges [] s);\n        (a2, b2) \\<in> set (routing_port_ranges [] s);\n        wordinterval_to_set b1 \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (b1 \\<noteq> b2) =\n                         (wordinterval_to_set b1 \\<inter>\n                          wordinterval_to_set b2 =\n                          {})\n 2. \\<And>a tbl s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>valid_prefixes tbl;\n                    (a1, b1) \\<in> set (routing_port_ranges tbl s);\n                    (a2, b2) \\<in> set (routing_port_ranges tbl s);\n                    wordinterval_to_set b1 \\<noteq> {}\\<rbrakk>\n                   \\<Longrightarrow> (b1 \\<noteq> b2) =\n                                     (wordinterval_to_set b1 \\<inter>\nwordinterval_to_set b2 =\n{});\n        valid_prefixes (a # tbl);\n        (a1, b1) \\<in> set (routing_port_ranges (a # tbl) s);\n        (a2, b2) \\<in> set (routing_port_ranges (a # tbl) s);\n        wordinterval_to_set b1 \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (b1 \\<noteq> b2) =\n                         (wordinterval_to_set b1 \\<inter>\n                          wordinterval_to_set b2 =\n                          {})", "assume one: \"b1 = fst (range_prefix_match (routing_match r) s)\""], ["proof (state)\nthis:\n  b1 = fst (range_prefix_match (routing_match r) s)\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>valid_prefixes [];\n        (a1, b1) \\<in> set (routing_port_ranges [] s);\n        (a2, b2) \\<in> set (routing_port_ranges [] s);\n        wordinterval_to_set b1 \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (b1 \\<noteq> b2) =\n                         (wordinterval_to_set b1 \\<inter>\n                          wordinterval_to_set b2 =\n                          {})\n 2. \\<And>a tbl s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>valid_prefixes tbl;\n                    (a1, b1) \\<in> set (routing_port_ranges tbl s);\n                    (a2, b2) \\<in> set (routing_port_ranges tbl s);\n                    wordinterval_to_set b1 \\<noteq> {}\\<rbrakk>\n                   \\<Longrightarrow> (b1 \\<noteq> b2) =\n                                     (wordinterval_to_set b1 \\<inter>\nwordinterval_to_set b2 =\n{});\n        valid_prefixes (a # tbl);\n        (a1, b1) \\<in> set (routing_port_ranges (a # tbl) s);\n        (a2, b2) \\<in> set (routing_port_ranges (a # tbl) s);\n        wordinterval_to_set b1 \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (b1 \\<noteq> b2) =\n                         (wordinterval_to_set b1 \\<inter>\n                          wordinterval_to_set b2 =\n                          {})", "assume two: \"(a2, b2) \\<in> set (routing_port_ranges rs (snd (range_prefix_match (routing_match r) s)))\""], ["proof (state)\nthis:\n  (a2, b2)\n  \\<in> set (routing_port_ranges rs\n              (snd (range_prefix_match (routing_match r) s)))\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>valid_prefixes [];\n        (a1, b1) \\<in> set (routing_port_ranges [] s);\n        (a2, b2) \\<in> set (routing_port_ranges [] s);\n        wordinterval_to_set b1 \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (b1 \\<noteq> b2) =\n                         (wordinterval_to_set b1 \\<inter>\n                          wordinterval_to_set b2 =\n                          {})\n 2. \\<And>a tbl s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>valid_prefixes tbl;\n                    (a1, b1) \\<in> set (routing_port_ranges tbl s);\n                    (a2, b2) \\<in> set (routing_port_ranges tbl s);\n                    wordinterval_to_set b1 \\<noteq> {}\\<rbrakk>\n                   \\<Longrightarrow> (b1 \\<noteq> b2) =\n                                     (wordinterval_to_set b1 \\<inter>\nwordinterval_to_set b2 =\n{});\n        valid_prefixes (a # tbl);\n        (a1, b1) \\<in> set (routing_port_ranges (a # tbl) s);\n        (a2, b2) \\<in> set (routing_port_ranges (a # tbl) s);\n        wordinterval_to_set b1 \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (b1 \\<noteq> b2) =\n                         (wordinterval_to_set b1 \\<inter>\n                          wordinterval_to_set b2 =\n                          {})", "have dc: \"wordinterval_to_set (snd (range_prefix_match (routing_match r) s)) \\<inter>\n          wordinterval_to_set (fst (range_prefix_match (routing_match r) s)) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set\n     (snd (range_prefix_match (routing_match r) s)) \\<inter>\n    wordinterval_to_set (fst (range_prefix_match (routing_match r) s)) =\n    {}", "by force"], ["proof (state)\nthis:\n  wordinterval_to_set\n   (snd (range_prefix_match (routing_match r) s)) \\<inter>\n  wordinterval_to_set (fst (range_prefix_match (routing_match r) s)) =\n  {}\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>valid_prefixes [];\n        (a1, b1) \\<in> set (routing_port_ranges [] s);\n        (a2, b2) \\<in> set (routing_port_ranges [] s);\n        wordinterval_to_set b1 \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (b1 \\<noteq> b2) =\n                         (wordinterval_to_set b1 \\<inter>\n                          wordinterval_to_set b2 =\n                          {})\n 2. \\<And>a tbl s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>valid_prefixes tbl;\n                    (a1, b1) \\<in> set (routing_port_ranges tbl s);\n                    (a2, b2) \\<in> set (routing_port_ranges tbl s);\n                    wordinterval_to_set b1 \\<noteq> {}\\<rbrakk>\n                   \\<Longrightarrow> (b1 \\<noteq> b2) =\n                                     (wordinterval_to_set b1 \\<inter>\nwordinterval_to_set b2 =\n{});\n        valid_prefixes (a # tbl);\n        (a1, b1) \\<in> set (routing_port_ranges (a # tbl) s);\n        (a2, b2) \\<in> set (routing_port_ranges (a # tbl) s);\n        wordinterval_to_set b1 \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (b1 \\<noteq> b2) =\n                         (wordinterval_to_set b1 \\<inter>\n                          wordinterval_to_set b2 =\n                          {})", "hence \"wordinterval_to_set b1 \\<inter> wordinterval_to_set b2 = {}\""], ["proof (prove)\nusing this:\n  wordinterval_to_set\n   (snd (range_prefix_match (routing_match r) s)) \\<inter>\n  wordinterval_to_set (fst (range_prefix_match (routing_match r) s)) =\n  {}\n\ngoal (1 subgoal):\n 1. wordinterval_to_set b1 \\<inter> wordinterval_to_set b2 = {}", "unfolding one"], ["proof (prove)\nusing this:\n  wordinterval_to_set\n   (snd (range_prefix_match (routing_match r) s)) \\<inter>\n  wordinterval_to_set (fst (range_prefix_match (routing_match r) s)) =\n  {}\n\ngoal (1 subgoal):\n 1. wordinterval_to_set\n     (fst (range_prefix_match (routing_match r) s)) \\<inter>\n    wordinterval_to_set b2 =\n    {}", "using two[THEN routing_port_ranges_subsets]"], ["proof (prove)\nusing this:\n  wordinterval_to_set\n   (snd (range_prefix_match (routing_match r) s)) \\<inter>\n  wordinterval_to_set (fst (range_prefix_match (routing_match r) s)) =\n  {}\n  wordinterval_to_set b2\n  \\<subseteq> wordinterval_to_set\n               (snd (range_prefix_match (routing_match r) s))\n\ngoal (1 subgoal):\n 1. wordinterval_to_set\n     (fst (range_prefix_match (routing_match r) s)) \\<inter>\n    wordinterval_to_set b2 =\n    {}", "by fast"], ["proof (state)\nthis:\n  wordinterval_to_set b1 \\<inter> wordinterval_to_set b2 = {}\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>valid_prefixes [];\n        (a1, b1) \\<in> set (routing_port_ranges [] s);\n        (a2, b2) \\<in> set (routing_port_ranges [] s);\n        wordinterval_to_set b1 \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (b1 \\<noteq> b2) =\n                         (wordinterval_to_set b1 \\<inter>\n                          wordinterval_to_set b2 =\n                          {})\n 2. \\<And>a tbl s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>valid_prefixes tbl;\n                    (a1, b1) \\<in> set (routing_port_ranges tbl s);\n                    (a2, b2) \\<in> set (routing_port_ranges tbl s);\n                    wordinterval_to_set b1 \\<noteq> {}\\<rbrakk>\n                   \\<Longrightarrow> (b1 \\<noteq> b2) =\n                                     (wordinterval_to_set b1 \\<inter>\nwordinterval_to_set b2 =\n{});\n        valid_prefixes (a # tbl);\n        (a1, b1) \\<in> set (routing_port_ranges (a # tbl) s);\n        (a2, b2) \\<in> set (routing_port_ranges (a # tbl) s);\n        wordinterval_to_set b1 \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (b1 \\<noteq> b2) =\n                         (wordinterval_to_set b1 \\<inter>\n                          wordinterval_to_set b2 =\n                          {})", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?b1a2 = fst (range_prefix_match (routing_match r) s);\n   (?a2a2, ?b2a2)\n   \\<in> set (routing_port_ranges rs\n               (snd (range_prefix_match (routing_match r) s)))\\<rbrakk>\n  \\<Longrightarrow> wordinterval_to_set ?b1a2 \\<inter>\n                    wordinterval_to_set ?b2a2 =\n                    {}\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>valid_prefixes [];\n        (a1, b1) \\<in> set (routing_port_ranges [] s);\n        (a2, b2) \\<in> set (routing_port_ranges [] s);\n        wordinterval_to_set b1 \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (b1 \\<noteq> b2) =\n                         (wordinterval_to_set b1 \\<inter>\n                          wordinterval_to_set b2 =\n                          {})\n 2. \\<And>a tbl s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>valid_prefixes tbl;\n                    (a1, b1) \\<in> set (routing_port_ranges tbl s);\n                    (a2, b2) \\<in> set (routing_port_ranges tbl s);\n                    wordinterval_to_set b1 \\<noteq> {}\\<rbrakk>\n                   \\<Longrightarrow> (b1 \\<noteq> b2) =\n                                     (wordinterval_to_set b1 \\<inter>\nwordinterval_to_set b2 =\n{});\n        valid_prefixes (a # tbl);\n        (a1, b1) \\<in> set (routing_port_ranges (a # tbl) s);\n        (a2, b2) \\<in> set (routing_port_ranges (a # tbl) s);\n        wordinterval_to_set b1 \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (b1 \\<noteq> b2) =\n                         (wordinterval_to_set b1 \\<inter>\n                          wordinterval_to_set b2 =\n                          {})", "note * = this"], ["proof (state)\nthis:\n  \\<lbrakk>?b1a2 = fst (range_prefix_match (routing_match r) s);\n   (?a2a2, ?b2a2)\n   \\<in> set (routing_port_ranges rs\n               (snd (range_prefix_match (routing_match r) s)))\\<rbrakk>\n  \\<Longrightarrow> wordinterval_to_set ?b1a2 \\<inter>\n                    wordinterval_to_set ?b2a2 =\n                    {}\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>valid_prefixes [];\n        (a1, b1) \\<in> set (routing_port_ranges [] s);\n        (a2, b2) \\<in> set (routing_port_ranges [] s);\n        wordinterval_to_set b1 \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (b1 \\<noteq> b2) =\n                         (wordinterval_to_set b1 \\<inter>\n                          wordinterval_to_set b2 =\n                          {})\n 2. \\<And>a tbl s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>valid_prefixes tbl;\n                    (a1, b1) \\<in> set (routing_port_ranges tbl s);\n                    (a2, b2) \\<in> set (routing_port_ranges tbl s);\n                    wordinterval_to_set b1 \\<noteq> {}\\<rbrakk>\n                   \\<Longrightarrow> (b1 \\<noteq> b2) =\n                                     (wordinterval_to_set b1 \\<inter>\nwordinterval_to_set b2 =\n{});\n        valid_prefixes (a # tbl);\n        (a1, b1) \\<in> set (routing_port_ranges (a # tbl) s);\n        (a2, b2) \\<in> set (routing_port_ranges (a # tbl) s);\n        wordinterval_to_set b1 \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (b1 \\<noteq> b2) =\n                         (wordinterval_to_set b1 \\<inter>\n                          wordinterval_to_set b2 =\n                          {})", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (b1 \\<noteq> b2) =\n    (wordinterval_to_set b1 \\<inter> wordinterval_to_set b2 = {})", "using \\<open>(a1, b1) \\<in> set (routing_port_ranges (r # rs) s)\\<close> \\<open>(a2, b2) \\<in> set (routing_port_ranges (r # rs) s)\\<close> nemp\n    Cons.IH[OF vpfx(2)] *"], ["proof (prove)\nusing this:\n  (a1, b1) \\<in> set (routing_port_ranges (r # rs) s)\n  (a2, b2) \\<in> set (routing_port_ranges (r # rs) s)\n  wordinterval_to_set b1 \\<noteq> {}\n  \\<lbrakk>(a1, b1) \\<in> set (routing_port_ranges rs ?s);\n   (a2, b2) \\<in> set (routing_port_ranges rs ?s);\n   wordinterval_to_set b1 \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> (b1 \\<noteq> b2) =\n                    (wordinterval_to_set b1 \\<inter>\n                     wordinterval_to_set b2 =\n                     {})\n  \\<lbrakk>?b1a2 = fst (range_prefix_match (routing_match r) s);\n   (?a2a2, ?b2a2)\n   \\<in> set (routing_port_ranges rs\n               (snd (range_prefix_match (routing_match r) s)))\\<rbrakk>\n  \\<Longrightarrow> wordinterval_to_set ?b1a2 \\<inter>\n                    wordinterval_to_set ?b2a2 =\n                    {}\n\ngoal (1 subgoal):\n 1. (b1 \\<noteq> b2) =\n    (wordinterval_to_set b1 \\<inter> wordinterval_to_set b2 = {})", "by(fastforce simp add: Let_def)"], ["proof (state)\nthis:\n  (b1 \\<noteq> b2) =\n  (wordinterval_to_set b1 \\<inter> wordinterval_to_set b2 = {})\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>valid_prefixes [];\n        (a1, b1) \\<in> set (routing_port_ranges [] s);\n        (a2, b2) \\<in> set (routing_port_ranges [] s);\n        wordinterval_to_set b1 \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (b1 \\<noteq> b2) =\n                         (wordinterval_to_set b1 \\<inter>\n                          wordinterval_to_set b2 =\n                          {})", "qed (simp split: if_splits)"], ["", "private"], ["", "lemma routing_port_rangesI:\n\"valid_prefixes tbl \\<Longrightarrow>\n output_iface (routing_table_semantics tbl k) = output_port \\<Longrightarrow>\n k \\<in> wordinterval_to_set wi \\<Longrightarrow>\n (\\<exists>ip_range. (output_port, ip_range) \\<in> set (routing_port_ranges tbl wi) \\<and> k \\<in> wordinterval_to_set ip_range)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_prefixes tbl;\n     output_iface (routing_table_semantics tbl k) = output_port;\n     k \\<in> wordinterval_to_set wi\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ip_range.\n                         (output_port, ip_range)\n                         \\<in> set (routing_port_ranges tbl wi) \\<and>\n                         k \\<in> wordinterval_to_set ip_range", "proof(induction tbl arbitrary: wi)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>wi.\n       \\<lbrakk>valid_prefixes [];\n        output_iface (routing_table_semantics [] k) = output_port;\n        k \\<in> wordinterval_to_set wi\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ip_range.\n                            (output_port, ip_range)\n                            \\<in> set (routing_port_ranges [] wi) \\<and>\n                            k \\<in> wordinterval_to_set ip_range\n 2. \\<And>a tbl wi.\n       \\<lbrakk>\\<And>wi.\n                   \\<lbrakk>valid_prefixes tbl;\n                    output_iface (routing_table_semantics tbl k) =\n                    output_port;\n                    k \\<in> wordinterval_to_set wi\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ip_range.\n  (output_port, ip_range) \\<in> set (routing_port_ranges tbl wi) \\<and>\n  k \\<in> wordinterval_to_set ip_range;\n        valid_prefixes (a # tbl);\n        output_iface (routing_table_semantics (a # tbl) k) = output_port;\n        k \\<in> wordinterval_to_set wi\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ip_range.\n                            (output_port, ip_range)\n                            \\<in> set (routing_port_ranges (a # tbl)\n  wi) \\<and>\n                            k \\<in> wordinterval_to_set ip_range", "case Nil"], ["proof (state)\nthis:\n  valid_prefixes []\n  output_iface (routing_table_semantics [] k) = output_port\n  k \\<in> wordinterval_to_set wi\n\ngoal (2 subgoals):\n 1. \\<And>wi.\n       \\<lbrakk>valid_prefixes [];\n        output_iface (routing_table_semantics [] k) = output_port;\n        k \\<in> wordinterval_to_set wi\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ip_range.\n                            (output_port, ip_range)\n                            \\<in> set (routing_port_ranges [] wi) \\<and>\n                            k \\<in> wordinterval_to_set ip_range\n 2. \\<And>a tbl wi.\n       \\<lbrakk>\\<And>wi.\n                   \\<lbrakk>valid_prefixes tbl;\n                    output_iface (routing_table_semantics tbl k) =\n                    output_port;\n                    k \\<in> wordinterval_to_set wi\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ip_range.\n  (output_port, ip_range) \\<in> set (routing_port_ranges tbl wi) \\<and>\n  k \\<in> wordinterval_to_set ip_range;\n        valid_prefixes (a # tbl);\n        output_iface (routing_table_semantics (a # tbl) k) = output_port;\n        k \\<in> wordinterval_to_set wi\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ip_range.\n                            (output_port, ip_range)\n                            \\<in> set (routing_port_ranges (a # tbl)\n  wi) \\<and>\n                            k \\<in> wordinterval_to_set ip_range", "thus ?case"], ["proof (prove)\nusing this:\n  valid_prefixes []\n  output_iface (routing_table_semantics [] k) = output_port\n  k \\<in> wordinterval_to_set wi\n\ngoal (1 subgoal):\n 1. \\<exists>ip_range.\n       (output_port, ip_range) \\<in> set (routing_port_ranges [] wi) \\<and>\n       k \\<in> wordinterval_to_set ip_range", "by simp blast"], ["proof (state)\nthis:\n  \\<exists>ip_range.\n     (output_port, ip_range) \\<in> set (routing_port_ranges [] wi) \\<and>\n     k \\<in> wordinterval_to_set ip_range\n\ngoal (1 subgoal):\n 1. \\<And>a tbl wi.\n       \\<lbrakk>\\<And>wi.\n                   \\<lbrakk>valid_prefixes tbl;\n                    output_iface (routing_table_semantics tbl k) =\n                    output_port;\n                    k \\<in> wordinterval_to_set wi\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ip_range.\n  (output_port, ip_range) \\<in> set (routing_port_ranges tbl wi) \\<and>\n  k \\<in> wordinterval_to_set ip_range;\n        valid_prefixes (a # tbl);\n        output_iface (routing_table_semantics (a # tbl) k) = output_port;\n        k \\<in> wordinterval_to_set wi\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ip_range.\n                            (output_port, ip_range)\n                            \\<in> set (routing_port_ranges (a # tbl)\n  wi) \\<and>\n                            k \\<in> wordinterval_to_set ip_range", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a tbl wi.\n       \\<lbrakk>\\<And>wi.\n                   \\<lbrakk>valid_prefixes tbl;\n                    output_iface (routing_table_semantics tbl k) =\n                    output_port;\n                    k \\<in> wordinterval_to_set wi\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ip_range.\n  (output_port, ip_range) \\<in> set (routing_port_ranges tbl wi) \\<and>\n  k \\<in> wordinterval_to_set ip_range;\n        valid_prefixes (a # tbl);\n        output_iface (routing_table_semantics (a # tbl) k) = output_port;\n        k \\<in> wordinterval_to_set wi\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ip_range.\n                            (output_port, ip_range)\n                            \\<in> set (routing_port_ranges (a # tbl)\n  wi) \\<and>\n                            k \\<in> wordinterval_to_set ip_range", "case (Cons r rs)"], ["proof (state)\nthis:\n  \\<lbrakk>valid_prefixes rs;\n   output_iface (routing_table_semantics rs k) = output_port;\n   k \\<in> wordinterval_to_set ?wi\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ip_range.\n                       (output_port, ip_range)\n                       \\<in> set (routing_port_ranges rs ?wi) \\<and>\n                       k \\<in> wordinterval_to_set ip_range\n  valid_prefixes (r # rs)\n  output_iface (routing_table_semantics (r # rs) k) = output_port\n  k \\<in> wordinterval_to_set wi\n\ngoal (1 subgoal):\n 1. \\<And>a tbl wi.\n       \\<lbrakk>\\<And>wi.\n                   \\<lbrakk>valid_prefixes tbl;\n                    output_iface (routing_table_semantics tbl k) =\n                    output_port;\n                    k \\<in> wordinterval_to_set wi\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ip_range.\n  (output_port, ip_range) \\<in> set (routing_port_ranges tbl wi) \\<and>\n  k \\<in> wordinterval_to_set ip_range;\n        valid_prefixes (a # tbl);\n        output_iface (routing_table_semantics (a # tbl) k) = output_port;\n        k \\<in> wordinterval_to_set wi\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ip_range.\n                            (output_port, ip_range)\n                            \\<in> set (routing_port_ranges (a # tbl)\n  wi) \\<and>\n                            k \\<in> wordinterval_to_set ip_range", "from Cons.prems(1)"], ["proof (chain)\npicking this:\n  valid_prefixes (r # rs)", "have vpfx: \"valid_prefix (routing_match r)\" and vpfxs: \"valid_prefixes rs\""], ["proof (prove)\nusing this:\n  valid_prefixes (r # rs)\n\ngoal (1 subgoal):\n 1. valid_prefix (routing_match r) &&& valid_prefixes rs", "by(simp_all add: valid_prefixes_split)"], ["proof (state)\nthis:\n  valid_prefix (routing_match r)\n  valid_prefixes rs\n\ngoal (1 subgoal):\n 1. \\<And>a tbl wi.\n       \\<lbrakk>\\<And>wi.\n                   \\<lbrakk>valid_prefixes tbl;\n                    output_iface (routing_table_semantics tbl k) =\n                    output_port;\n                    k \\<in> wordinterval_to_set wi\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ip_range.\n  (output_port, ip_range) \\<in> set (routing_port_ranges tbl wi) \\<and>\n  k \\<in> wordinterval_to_set ip_range;\n        valid_prefixes (a # tbl);\n        output_iface (routing_table_semantics (a # tbl) k) = output_port;\n        k \\<in> wordinterval_to_set wi\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ip_range.\n                            (output_port, ip_range)\n                            \\<in> set (routing_port_ranges (a # tbl)\n  wi) \\<and>\n                            k \\<in> wordinterval_to_set ip_range", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ip_range.\n       (output_port, ip_range)\n       \\<in> set (routing_port_ranges (r # rs) wi) \\<and>\n       k \\<in> wordinterval_to_set ip_range", "proof(cases \"prefix_match_semantics (routing_match r) k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. prefix_match_semantics (routing_match r) k \\<Longrightarrow>\n    \\<exists>ip_range.\n       (output_port, ip_range)\n       \\<in> set (routing_port_ranges (r # rs) wi) \\<and>\n       k \\<in> wordinterval_to_set ip_range\n 2. \\<not> prefix_match_semantics (routing_match r) k \\<Longrightarrow>\n    \\<exists>ip_range.\n       (output_port, ip_range)\n       \\<in> set (routing_port_ranges (r # rs) wi) \\<and>\n       k \\<in> wordinterval_to_set ip_range", "case True"], ["proof (state)\nthis:\n  prefix_match_semantics (routing_match r) k\n\ngoal (2 subgoals):\n 1. prefix_match_semantics (routing_match r) k \\<Longrightarrow>\n    \\<exists>ip_range.\n       (output_port, ip_range)\n       \\<in> set (routing_port_ranges (r # rs) wi) \\<and>\n       k \\<in> wordinterval_to_set ip_range\n 2. \\<not> prefix_match_semantics (routing_match r) k \\<Longrightarrow>\n    \\<exists>ip_range.\n       (output_port, ip_range)\n       \\<in> set (routing_port_ranges (r # rs) wi) \\<and>\n       k \\<in> wordinterval_to_set ip_range", "thus ?thesis"], ["proof (prove)\nusing this:\n  prefix_match_semantics (routing_match r) k\n\ngoal (1 subgoal):\n 1. \\<exists>ip_range.\n       (output_port, ip_range)\n       \\<in> set (routing_port_ranges (r # rs) wi) \\<and>\n       k \\<in> wordinterval_to_set ip_range", "using Cons.prems(2)"], ["proof (prove)\nusing this:\n  prefix_match_semantics (routing_match r) k\n  output_iface (routing_table_semantics (r # rs) k) = output_port\n\ngoal (1 subgoal):\n 1. \\<exists>ip_range.\n       (output_port, ip_range)\n       \\<in> set (routing_port_ranges (r # rs) wi) \\<and>\n       k \\<in> wordinterval_to_set ip_range", "using vpfx \\<open>k \\<in> wordinterval_to_set wi\\<close>"], ["proof (prove)\nusing this:\n  prefix_match_semantics (routing_match r) k\n  output_iface (routing_table_semantics (r # rs) k) = output_port\n  valid_prefix (routing_match r)\n  k \\<in> wordinterval_to_set wi\n\ngoal (1 subgoal):\n 1. \\<exists>ip_range.\n       (output_port, ip_range)\n       \\<in> set (routing_port_ranges (r # rs) wi) \\<and>\n       k \\<in> wordinterval_to_set ip_range", "by (intro exI[where x =  \"fst (range_prefix_match (routing_match r) wi)\"]) \n         (simp add: prefix_match_semantics_wordset Let_def)"], ["proof (state)\nthis:\n  \\<exists>ip_range.\n     (output_port, ip_range)\n     \\<in> set (routing_port_ranges (r # rs) wi) \\<and>\n     k \\<in> wordinterval_to_set ip_range\n\ngoal (1 subgoal):\n 1. \\<not> prefix_match_semantics (routing_match r) k \\<Longrightarrow>\n    \\<exists>ip_range.\n       (output_port, ip_range)\n       \\<in> set (routing_port_ranges (r # rs) wi) \\<and>\n       k \\<in> wordinterval_to_set ip_range", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> prefix_match_semantics (routing_match r) k \\<Longrightarrow>\n    \\<exists>ip_range.\n       (output_port, ip_range)\n       \\<in> set (routing_port_ranges (r # rs) wi) \\<and>\n       k \\<in> wordinterval_to_set ip_range", "case False"], ["proof (state)\nthis:\n  \\<not> prefix_match_semantics (routing_match r) k\n\ngoal (1 subgoal):\n 1. \\<not> prefix_match_semantics (routing_match r) k \\<Longrightarrow>\n    \\<exists>ip_range.\n       (output_port, ip_range)\n       \\<in> set (routing_port_ranges (r # rs) wi) \\<and>\n       k \\<in> wordinterval_to_set ip_range", "with \\<open>k \\<in> wordinterval_to_set wi\\<close>"], ["proof (chain)\npicking this:\n  k \\<in> wordinterval_to_set wi\n  \\<not> prefix_match_semantics (routing_match r) k", "have ksnd: \"k \\<in> wordinterval_to_set (snd (range_prefix_match (routing_match r) wi))\""], ["proof (prove)\nusing this:\n  k \\<in> wordinterval_to_set wi\n  \\<not> prefix_match_semantics (routing_match r) k\n\ngoal (1 subgoal):\n 1. k \\<in> wordinterval_to_set\n             (snd (range_prefix_match (routing_match r) wi))", "by (simp add: prefix_match_semantics_wordset vpfx)"], ["proof (state)\nthis:\n  k \\<in> wordinterval_to_set\n           (snd (range_prefix_match (routing_match r) wi))\n\ngoal (1 subgoal):\n 1. \\<not> prefix_match_semantics (routing_match r) k \\<Longrightarrow>\n    \\<exists>ip_range.\n       (output_port, ip_range)\n       \\<in> set (routing_port_ranges (r # rs) wi) \\<and>\n       k \\<in> wordinterval_to_set ip_range", "have mpr: \"output_iface (routing_table_semantics rs k) = output_port\""], ["proof (prove)\ngoal (1 subgoal):\n 1. output_iface (routing_table_semantics rs k) = output_port", "using Cons.prems False"], ["proof (prove)\nusing this:\n  valid_prefixes (r # rs)\n  output_iface (routing_table_semantics (r # rs) k) = output_port\n  k \\<in> wordinterval_to_set wi\n  \\<not> prefix_match_semantics (routing_match r) k\n\ngoal (1 subgoal):\n 1. output_iface (routing_table_semantics rs k) = output_port", "by simp"], ["proof (state)\nthis:\n  output_iface (routing_table_semantics rs k) = output_port\n\ngoal (1 subgoal):\n 1. \\<not> prefix_match_semantics (routing_match r) k \\<Longrightarrow>\n    \\<exists>ip_range.\n       (output_port, ip_range)\n       \\<in> set (routing_port_ranges (r # rs) wi) \\<and>\n       k \\<in> wordinterval_to_set ip_range", "note Cons.IH[OF vpfxs mpr ksnd]"], ["proof (state)\nthis:\n  \\<exists>ip_range.\n     (output_port, ip_range)\n     \\<in> set (routing_port_ranges rs\n                 (snd (range_prefix_match (routing_match r) wi))) \\<and>\n     k \\<in> wordinterval_to_set ip_range\n\ngoal (1 subgoal):\n 1. \\<not> prefix_match_semantics (routing_match r) k \\<Longrightarrow>\n    \\<exists>ip_range.\n       (output_port, ip_range)\n       \\<in> set (routing_port_ranges (r # rs) wi) \\<and>\n       k \\<in> wordinterval_to_set ip_range", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>ip_range.\n     (output_port, ip_range)\n     \\<in> set (routing_port_ranges rs\n                 (snd (range_prefix_match (routing_match r) wi))) \\<and>\n     k \\<in> wordinterval_to_set ip_range\n\ngoal (1 subgoal):\n 1. \\<exists>ip_range.\n       (output_port, ip_range)\n       \\<in> set (routing_port_ranges (r # rs) wi) \\<and>\n       k \\<in> wordinterval_to_set ip_range", "by(fastforce simp: Let_def)"], ["proof (state)\nthis:\n  \\<exists>ip_range.\n     (output_port, ip_range)\n     \\<in> set (routing_port_ranges (r # rs) wi) \\<and>\n     k \\<in> wordinterval_to_set ip_range\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ip_range.\n     (output_port, ip_range)\n     \\<in> set (routing_port_ranges (r # rs) wi) \\<and>\n     k \\<in> wordinterval_to_set ip_range\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Reduction\\<close>"], ["", "text\\<open>So far, one entry in the list would be generated for each routing table entry. \nThis next step reduces it to one for each port. \nThe resulting list will represent a function from port to IP wordinterval.\n(It can also be understood as a function from IP (interval) to port (where the intervals don't overlap).\\<close>"], ["", "definition \"reduce_range_destination l \\<equiv>\nlet ps = remdups (map fst l) in\nlet c = \\<lambda>s. (wordinterval_Union \\<circ> map snd \\<circ> filter (((=) s) \\<circ> fst)) l in\n[(p, c p). p \\<leftarrow> ps]\n\""], ["", "definition \"routing_ipassmt_wi tbl \\<equiv> reduce_range_destination (routing_port_ranges tbl wordinterval_UNIV)\""], ["", "lemma routing_ipassmt_wi_distinct: \"distinct (map fst (routing_ipassmt_wi tbl))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (routing_ipassmt_wi tbl))", "unfolding routing_ipassmt_wi_def reduce_range_destination_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (map fst\n       (let ps = remdups\n                  (map fst (routing_port_ranges tbl wordinterval_UNIV));\n            c = \\<lambda>s.\n                   (wordinterval_Union \\<circ> map snd \\<circ>\n                    filter ((=) s \\<circ> fst))\n                    (routing_port_ranges tbl wordinterval_UNIV)\n        in map (\\<lambda>p. (p, c p)) ps))", "by(simp add: comp_def)"], ["", "private"], ["", "lemma routing_port_ranges_superseted:\n\"(a1,b1) \\<in> set (routing_port_ranges tbl wordinterval_UNIV) \\<Longrightarrow> \n  \\<exists>b2. (a1,b2) \\<in> set (routing_ipassmt_wi tbl) \\<and> wordinterval_to_set b1 \\<subseteq> wordinterval_to_set b2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a1, b1)\n    \\<in> set (routing_port_ranges tbl wordinterval_UNIV) \\<Longrightarrow>\n    \\<exists>b2.\n       (a1, b2) \\<in> set (routing_ipassmt_wi tbl) \\<and>\n       wordinterval_to_set b1 \\<subseteq> wordinterval_to_set b2", "unfolding routing_ipassmt_wi_def reduce_range_destination_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a1, b1)\n    \\<in> set (routing_port_ranges tbl wordinterval_UNIV) \\<Longrightarrow>\n    \\<exists>b2.\n       (a1, b2)\n       \\<in> set (let ps = remdups\n                            (map fst\n                              (routing_port_ranges tbl wordinterval_UNIV));\n                      c = \\<lambda>s.\n                             (wordinterval_Union \\<circ> map snd \\<circ>\n                              filter ((=) s \\<circ> fst))\n                              (routing_port_ranges tbl wordinterval_UNIV)\n                  in map (\\<lambda>p. (p, c p)) ps) \\<and>\n       wordinterval_to_set b1 \\<subseteq> wordinterval_to_set b2", "by(force simp add: Set.image_iff wordinterval_Union)"], ["", "private"], ["", "lemma routing_ipassmt_wi_subsetted:\n\"(a1,b1) \\<in> set (routing_ipassmt_wi tbl) \\<Longrightarrow> \n (a1,b2) \\<in> set (routing_port_ranges tbl wordinterval_UNIV) \\<Longrightarrow>  wordinterval_to_set b2 \\<subseteq> wordinterval_to_set b1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a1, b1) \\<in> set (routing_ipassmt_wi tbl);\n     (a1, b2) \\<in> set (routing_port_ranges tbl wordinterval_UNIV)\\<rbrakk>\n    \\<Longrightarrow> wordinterval_to_set b2\n                      \\<subseteq> wordinterval_to_set b1", "unfolding routing_ipassmt_wi_def reduce_range_destination_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a1, b1)\n             \\<in> set (let ps = remdups\n                                  (map fst\n                                    (routing_port_ranges tbl\nwordinterval_UNIV));\n                            c = \\<lambda>s.\n                                   (wordinterval_Union \\<circ>\n                                    map snd \\<circ>\n                                    filter ((=) s \\<circ> fst))\n                                    (routing_port_ranges tbl\nwordinterval_UNIV)\n                        in map (\\<lambda>p. (p, c p)) ps);\n     (a1, b2) \\<in> set (routing_port_ranges tbl wordinterval_UNIV)\\<rbrakk>\n    \\<Longrightarrow> wordinterval_to_set b2\n                      \\<subseteq> wordinterval_to_set b1", "by(fastforce simp add: Set.image_iff wordinterval_Union comp_def)"], ["", "text\\<open>This lemma should hold without the @{const valid_prefixes} assumption, but that would break the semantic argument and make the proof a lot harder.\\<close>"], ["", "lemma routing_ipassmt_wi_disjoint:\nassumes vpfx: \"valid_prefixes (tbl::('i::len) prefix_routing)\"\n  and dif: \"a1 \\<noteq> a2\"\n  and ins:  \"(a1, b1) \\<in> set (routing_ipassmt_wi tbl)\" \"(a2, b2) \\<in> set (routing_ipassmt_wi tbl)\"\nshows \"wordinterval_to_set b1 \\<inter> wordinterval_to_set b2 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set b1 \\<inter> wordinterval_to_set b2 = {}", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. wordinterval_to_set b1 \\<inter> wordinterval_to_set b2 \\<noteq>\n    {} \\<Longrightarrow>\n    False", "note iuf = ins[unfolded routing_ipassmt_wi_def reduce_range_destination_def Let_def, simplified, unfolded Set.image_iff comp_def, simplified]"], ["proof (state)\nthis:\n  a1 \\<in> fst ` set (routing_port_ranges tbl wordinterval_UNIV) \\<and>\n  b1 =\n  wordinterval_Union\n   (map snd\n     (filter (\\<lambda>x. a1 = fst x)\n       (routing_port_ranges tbl wordinterval_UNIV)))\n  a2 \\<in> fst ` set (routing_port_ranges tbl wordinterval_UNIV) \\<and>\n  b2 =\n  wordinterval_Union\n   (map snd\n     (filter (\\<lambda>x. a2 = fst x)\n       (routing_port_ranges tbl wordinterval_UNIV)))\n\ngoal (1 subgoal):\n 1. wordinterval_to_set b1 \\<inter> wordinterval_to_set b2 \\<noteq>\n    {} \\<Longrightarrow>\n    False", "assume \"(wordinterval_to_set b1 \\<inter> wordinterval_to_set b2 \\<noteq> {})\""], ["proof (state)\nthis:\n  wordinterval_to_set b1 \\<inter> wordinterval_to_set b2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. wordinterval_to_set b1 \\<inter> wordinterval_to_set b2 \\<noteq>\n    {} \\<Longrightarrow>\n    False", "hence \"wordinterval_to_set b1 \\<inter> wordinterval_to_set b2 \\<noteq> {}\""], ["proof (prove)\nusing this:\n  wordinterval_to_set b1 \\<inter> wordinterval_to_set b2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. wordinterval_to_set b1 \\<inter> wordinterval_to_set b2 \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  wordinterval_to_set b1 \\<inter> wordinterval_to_set b2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. wordinterval_to_set b1 \\<inter> wordinterval_to_set b2 \\<noteq>\n    {} \\<Longrightarrow>\n    False", "text\\<open>If the intervals are not disjoint, there exists a witness of that.\\<close>"], ["proof (state)\nthis:\n  wordinterval_to_set b1 \\<inter> wordinterval_to_set b2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. wordinterval_to_set b1 \\<inter> wordinterval_to_set b2 \\<noteq>\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  wordinterval_to_set b1 \\<inter> wordinterval_to_set b2 \\<noteq> {}", "obtain x where x[simp]: \"x \\<in> wordinterval_to_set b1\" \"x \\<in> wordinterval_to_set b2\""], ["proof (prove)\nusing this:\n  wordinterval_to_set b1 \\<inter> wordinterval_to_set b2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> wordinterval_to_set b1;\n         x \\<in> wordinterval_to_set b2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> wordinterval_to_set b1\n  x \\<in> wordinterval_to_set b2\n\ngoal (1 subgoal):\n 1. wordinterval_to_set b1 \\<inter> wordinterval_to_set b2 \\<noteq>\n    {} \\<Longrightarrow>\n    False", "text\\<open>This witness has to have come from some entry in the result of @{const routing_port_ranges}, for both of @{term b1} and @{term b2}.\\<close>"], ["proof (state)\nthis:\n  x \\<in> wordinterval_to_set b1\n  x \\<in> wordinterval_to_set b2\n\ngoal (1 subgoal):\n 1. wordinterval_to_set b1 \\<inter> wordinterval_to_set b2 \\<noteq>\n    {} \\<Longrightarrow>\n    False", "hence \"\\<exists>b1g. x \\<in> wordinterval_to_set b1g \\<and> wordinterval_to_set b1g \\<subseteq> wordinterval_to_set b1 \\<and> (a1, b1g) \\<in> set (routing_port_ranges tbl wordinterval_UNIV)\""], ["proof (prove)\nusing this:\n  x \\<in> wordinterval_to_set b1\n  x \\<in> wordinterval_to_set b2\n\ngoal (1 subgoal):\n 1. \\<exists>b1g.\n       x \\<in> wordinterval_to_set b1g \\<and>\n       wordinterval_to_set b1g \\<subseteq> wordinterval_to_set b1 \\<and>\n       (a1, b1g) \\<in> set (routing_port_ranges tbl wordinterval_UNIV)", "using iuf(1)"], ["proof (prove)\nusing this:\n  x \\<in> wordinterval_to_set b1\n  x \\<in> wordinterval_to_set b2\n  a1 \\<in> fst ` set (routing_port_ranges tbl wordinterval_UNIV) \\<and>\n  b1 =\n  wordinterval_Union\n   (map snd\n     (filter (\\<lambda>x. a1 = fst x)\n       (routing_port_ranges tbl wordinterval_UNIV)))\n\ngoal (1 subgoal):\n 1. \\<exists>b1g.\n       x \\<in> wordinterval_to_set b1g \\<and>\n       wordinterval_to_set b1g \\<subseteq> wordinterval_to_set b1 \\<and>\n       (a1, b1g) \\<in> set (routing_port_ranges tbl wordinterval_UNIV)", "by(fastforce simp add: wordinterval_Union)"], ["proof (state)\nthis:\n  \\<exists>b1g.\n     x \\<in> wordinterval_to_set b1g \\<and>\n     wordinterval_to_set b1g \\<subseteq> wordinterval_to_set b1 \\<and>\n     (a1, b1g) \\<in> set (routing_port_ranges tbl wordinterval_UNIV)\n\ngoal (1 subgoal):\n 1. wordinterval_to_set b1 \\<inter> wordinterval_to_set b2 \\<noteq>\n    {} \\<Longrightarrow>\n    False", "(* strangely, this doesn't work with obtain *)"], ["proof (state)\nthis:\n  \\<exists>b1g.\n     x \\<in> wordinterval_to_set b1g \\<and>\n     wordinterval_to_set b1g \\<subseteq> wordinterval_to_set b1 \\<and>\n     (a1, b1g) \\<in> set (routing_port_ranges tbl wordinterval_UNIV)\n\ngoal (1 subgoal):\n 1. wordinterval_to_set b1 \\<inter> wordinterval_to_set b2 \\<noteq>\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>b1g.\n     x \\<in> wordinterval_to_set b1g \\<and>\n     wordinterval_to_set b1g \\<subseteq> wordinterval_to_set b1 \\<and>\n     (a1, b1g) \\<in> set (routing_port_ranges tbl wordinterval_UNIV)", "obtain b1g where b1g: \"x \\<in> wordinterval_to_set b1g\" \"wordinterval_to_set b1g \\<subseteq> wordinterval_to_set b1\" \"(a1, b1g) \\<in> set (routing_port_ranges tbl wordinterval_UNIV)\""], ["proof (prove)\nusing this:\n  \\<exists>b1g.\n     x \\<in> wordinterval_to_set b1g \\<and>\n     wordinterval_to_set b1g \\<subseteq> wordinterval_to_set b1 \\<and>\n     (a1, b1g) \\<in> set (routing_port_ranges tbl wordinterval_UNIV)\n\ngoal (1 subgoal):\n 1. (\\<And>b1g.\n        \\<lbrakk>x \\<in> wordinterval_to_set b1g;\n         wordinterval_to_set b1g \\<subseteq> wordinterval_to_set b1;\n         (a1, b1g)\n         \\<in> set (routing_port_ranges tbl wordinterval_UNIV)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by clarsimp"], ["proof (state)\nthis:\n  x \\<in> wordinterval_to_set b1g\n  wordinterval_to_set b1g \\<subseteq> wordinterval_to_set b1\n  (a1, b1g) \\<in> set (routing_port_ranges tbl wordinterval_UNIV)\n\ngoal (1 subgoal):\n 1. wordinterval_to_set b1 \\<inter> wordinterval_to_set b2 \\<noteq>\n    {} \\<Longrightarrow>\n    False", "from x"], ["proof (chain)\npicking this:\n  x \\<in> wordinterval_to_set b1\n  x \\<in> wordinterval_to_set b2", "have \"\\<exists>b2g. x \\<in> wordinterval_to_set b2g \\<and> wordinterval_to_set b2g \\<subseteq> wordinterval_to_set b2 \\<and> (a2, b2g) \\<in> set (routing_port_ranges tbl wordinterval_UNIV)\""], ["proof (prove)\nusing this:\n  x \\<in> wordinterval_to_set b1\n  x \\<in> wordinterval_to_set b2\n\ngoal (1 subgoal):\n 1. \\<exists>b2g.\n       x \\<in> wordinterval_to_set b2g \\<and>\n       wordinterval_to_set b2g \\<subseteq> wordinterval_to_set b2 \\<and>\n       (a2, b2g) \\<in> set (routing_port_ranges tbl wordinterval_UNIV)", "using iuf(2)"], ["proof (prove)\nusing this:\n  x \\<in> wordinterval_to_set b1\n  x \\<in> wordinterval_to_set b2\n  a2 \\<in> fst ` set (routing_port_ranges tbl wordinterval_UNIV) \\<and>\n  b2 =\n  wordinterval_Union\n   (map snd\n     (filter (\\<lambda>x. a2 = fst x)\n       (routing_port_ranges tbl wordinterval_UNIV)))\n\ngoal (1 subgoal):\n 1. \\<exists>b2g.\n       x \\<in> wordinterval_to_set b2g \\<and>\n       wordinterval_to_set b2g \\<subseteq> wordinterval_to_set b2 \\<and>\n       (a2, b2g) \\<in> set (routing_port_ranges tbl wordinterval_UNIV)", "by(fastforce simp add: wordinterval_Union)"], ["proof (state)\nthis:\n  \\<exists>b2g.\n     x \\<in> wordinterval_to_set b2g \\<and>\n     wordinterval_to_set b2g \\<subseteq> wordinterval_to_set b2 \\<and>\n     (a2, b2g) \\<in> set (routing_port_ranges tbl wordinterval_UNIV)\n\ngoal (1 subgoal):\n 1. wordinterval_to_set b1 \\<inter> wordinterval_to_set b2 \\<noteq>\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>b2g.\n     x \\<in> wordinterval_to_set b2g \\<and>\n     wordinterval_to_set b2g \\<subseteq> wordinterval_to_set b2 \\<and>\n     (a2, b2g) \\<in> set (routing_port_ranges tbl wordinterval_UNIV)", "obtain b2g where b2g: \"x \\<in> wordinterval_to_set b2g\" \"wordinterval_to_set b2g \\<subseteq> wordinterval_to_set b2\" \"(a2, b2g) \\<in> set (routing_port_ranges tbl wordinterval_UNIV)\""], ["proof (prove)\nusing this:\n  \\<exists>b2g.\n     x \\<in> wordinterval_to_set b2g \\<and>\n     wordinterval_to_set b2g \\<subseteq> wordinterval_to_set b2 \\<and>\n     (a2, b2g) \\<in> set (routing_port_ranges tbl wordinterval_UNIV)\n\ngoal (1 subgoal):\n 1. (\\<And>b2g.\n        \\<lbrakk>x \\<in> wordinterval_to_set b2g;\n         wordinterval_to_set b2g \\<subseteq> wordinterval_to_set b2;\n         (a2, b2g)\n         \\<in> set (routing_port_ranges tbl wordinterval_UNIV)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by clarsimp"], ["proof (state)\nthis:\n  x \\<in> wordinterval_to_set b2g\n  wordinterval_to_set b2g \\<subseteq> wordinterval_to_set b2\n  (a2, b2g) \\<in> set (routing_port_ranges tbl wordinterval_UNIV)\n\ngoal (1 subgoal):\n 1. wordinterval_to_set b1 \\<inter> wordinterval_to_set b2 \\<noteq>\n    {} \\<Longrightarrow>\n    False", "text\\<open>Soudness tells us that the both @{term a1} and @{term a2} have to be the result of routing @{term x}.\\<close>"], ["proof (state)\nthis:\n  x \\<in> wordinterval_to_set b2g\n  wordinterval_to_set b2g \\<subseteq> wordinterval_to_set b2\n  (a2, b2g) \\<in> set (routing_port_ranges tbl wordinterval_UNIV)\n\ngoal (1 subgoal):\n 1. wordinterval_to_set b1 \\<inter> wordinterval_to_set b2 \\<noteq>\n    {} \\<Longrightarrow>\n    False", "note routing_port_ranges_sound[OF b1g(3), unfolded fst_conv snd_conv, OF b1g(1) vpfx] routing_port_ranges_sound[OF b2g(3), unfolded fst_conv snd_conv, OF b2g(1) vpfx]"], ["proof (state)\nthis:\n  a1 = output_iface (routing_table_semantics tbl x)\n  a2 = output_iface (routing_table_semantics tbl x)\n\ngoal (1 subgoal):\n 1. wordinterval_to_set b1 \\<inter> wordinterval_to_set b2 \\<noteq>\n    {} \\<Longrightarrow>\n    False", "text\\<open>A contradiction follows from @{thm dif}.\\<close>"], ["proof (state)\nthis:\n  a1 = output_iface (routing_table_semantics tbl x)\n  a2 = output_iface (routing_table_semantics tbl x)\n\ngoal (1 subgoal):\n 1. wordinterval_to_set b1 \\<inter> wordinterval_to_set b2 \\<noteq>\n    {} \\<Longrightarrow>\n    False", "with dif"], ["proof (chain)\npicking this:\n  a1 \\<noteq> a2\n  a1 = output_iface (routing_table_semantics tbl x)\n  a2 = output_iface (routing_table_semantics tbl x)", "show False"], ["proof (prove)\nusing this:\n  a1 \\<noteq> a2\n  a1 = output_iface (routing_table_semantics tbl x)\n  a2 = output_iface (routing_table_semantics tbl x)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma routing_ipassmt_wi_sound:\n  assumes vpfx: \"valid_prefixes tbl\"\n  and ins: \"(ea,eb) \\<in> set (routing_ipassmt_wi tbl)\"\n  and x: \"k \\<in> wordinterval_to_set eb\"\n  shows \"ea = output_iface (routing_table_semantics tbl k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ea = output_iface (routing_table_semantics tbl k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ea = output_iface (routing_table_semantics tbl k)", "note iuf = ins[unfolded routing_ipassmt_wi_def reduce_range_destination_def Let_def, simplified, unfolded Set.image_iff comp_def, simplified]"], ["proof (state)\nthis:\n  ea \\<in> fst ` set (routing_port_ranges tbl wordinterval_UNIV) \\<and>\n  eb =\n  wordinterval_Union\n   (map snd\n     (filter (\\<lambda>x. ea = fst x)\n       (routing_port_ranges tbl wordinterval_UNIV)))\n\ngoal (1 subgoal):\n 1. ea = output_iface (routing_table_semantics tbl k)", "from x"], ["proof (chain)\npicking this:\n  k \\<in> wordinterval_to_set eb", "have \"\\<exists>b1g. k \\<in> wordinterval_to_set b1g \\<and> wordinterval_to_set b1g \\<subseteq> wordinterval_to_set eb \\<and> (ea, b1g) \\<in> set (routing_port_ranges tbl wordinterval_UNIV)\""], ["proof (prove)\nusing this:\n  k \\<in> wordinterval_to_set eb\n\ngoal (1 subgoal):\n 1. \\<exists>b1g.\n       k \\<in> wordinterval_to_set b1g \\<and>\n       wordinterval_to_set b1g \\<subseteq> wordinterval_to_set eb \\<and>\n       (ea, b1g) \\<in> set (routing_port_ranges tbl wordinterval_UNIV)", "using iuf(1)"], ["proof (prove)\nusing this:\n  k \\<in> wordinterval_to_set eb\n  ea \\<in> fst ` set (routing_port_ranges tbl wordinterval_UNIV) \\<and>\n  eb =\n  wordinterval_Union\n   (map snd\n     (filter (\\<lambda>x. ea = fst x)\n       (routing_port_ranges tbl wordinterval_UNIV)))\n\ngoal (1 subgoal):\n 1. \\<exists>b1g.\n       k \\<in> wordinterval_to_set b1g \\<and>\n       wordinterval_to_set b1g \\<subseteq> wordinterval_to_set eb \\<and>\n       (ea, b1g) \\<in> set (routing_port_ranges tbl wordinterval_UNIV)", "by(fastforce simp add: wordinterval_Union)"], ["proof (state)\nthis:\n  \\<exists>b1g.\n     k \\<in> wordinterval_to_set b1g \\<and>\n     wordinterval_to_set b1g \\<subseteq> wordinterval_to_set eb \\<and>\n     (ea, b1g) \\<in> set (routing_port_ranges tbl wordinterval_UNIV)\n\ngoal (1 subgoal):\n 1. ea = output_iface (routing_table_semantics tbl k)", "then"], ["proof (chain)\npicking this:\n  \\<exists>b1g.\n     k \\<in> wordinterval_to_set b1g \\<and>\n     wordinterval_to_set b1g \\<subseteq> wordinterval_to_set eb \\<and>\n     (ea, b1g) \\<in> set (routing_port_ranges tbl wordinterval_UNIV)", "obtain b1g where b1g: \"k \\<in> wordinterval_to_set b1g\" \"wordinterval_to_set b1g \\<subseteq> wordinterval_to_set eb\" \"(ea, b1g) \\<in> set (routing_port_ranges tbl wordinterval_UNIV)\""], ["proof (prove)\nusing this:\n  \\<exists>b1g.\n     k \\<in> wordinterval_to_set b1g \\<and>\n     wordinterval_to_set b1g \\<subseteq> wordinterval_to_set eb \\<and>\n     (ea, b1g) \\<in> set (routing_port_ranges tbl wordinterval_UNIV)\n\ngoal (1 subgoal):\n 1. (\\<And>b1g.\n        \\<lbrakk>k \\<in> wordinterval_to_set b1g;\n         wordinterval_to_set b1g \\<subseteq> wordinterval_to_set eb;\n         (ea, b1g)\n         \\<in> set (routing_port_ranges tbl wordinterval_UNIV)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by clarsimp"], ["proof (state)\nthis:\n  k \\<in> wordinterval_to_set b1g\n  wordinterval_to_set b1g \\<subseteq> wordinterval_to_set eb\n  (ea, b1g) \\<in> set (routing_port_ranges tbl wordinterval_UNIV)\n\ngoal (1 subgoal):\n 1. ea = output_iface (routing_table_semantics tbl k)", "note routing_port_ranges_sound[OF b1g(3), unfolded fst_conv snd_conv, OF b1g(1) vpfx]"], ["proof (state)\nthis:\n  ea = output_iface (routing_table_semantics tbl k)\n\ngoal (1 subgoal):\n 1. ea = output_iface (routing_table_semantics tbl k)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ea = output_iface (routing_table_semantics tbl k)\n\ngoal (1 subgoal):\n 1. ea = output_iface (routing_table_semantics tbl k)", "."], ["proof (state)\nthis:\n  ea = output_iface (routing_table_semantics tbl k)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem routing_ipassmt_wi:\nassumes vpfx: \"valid_prefixes tbl\"\n  shows \n  \"output_iface (routing_table_semantics tbl k) = output_port \\<longleftrightarrow>\n    (\\<exists>ip_range. k \\<in> wordinterval_to_set ip_range \\<and> (output_port, ip_range) \\<in> set (routing_ipassmt_wi tbl))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (output_iface (routing_table_semantics tbl k) = output_port) =\n    (\\<exists>ip_range.\n        k \\<in> wordinterval_to_set ip_range \\<and>\n        (output_port, ip_range) \\<in> set (routing_ipassmt_wi tbl))", "proof (intro iffI, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. output_iface (routing_table_semantics tbl k) =\n    output_port \\<Longrightarrow>\n    \\<exists>ip_range.\n       k \\<in> wordinterval_to_set ip_range \\<and>\n       (output_port, ip_range) \\<in> set (routing_ipassmt_wi tbl)\n 2. \\<exists>ip_range.\n       k \\<in> wordinterval_to_set ip_range \\<and>\n       (output_port, ip_range)\n       \\<in> set (routing_ipassmt_wi tbl) \\<Longrightarrow>\n    output_iface (routing_table_semantics tbl k) = output_port", "case 2"], ["proof (state)\nthis:\n  \\<exists>ip_range.\n     k \\<in> wordinterval_to_set ip_range \\<and>\n     (output_port, ip_range) \\<in> set (routing_ipassmt_wi tbl)\n\ngoal (2 subgoals):\n 1. output_iface (routing_table_semantics tbl k) =\n    output_port \\<Longrightarrow>\n    \\<exists>ip_range.\n       k \\<in> wordinterval_to_set ip_range \\<and>\n       (output_port, ip_range) \\<in> set (routing_ipassmt_wi tbl)\n 2. \\<exists>ip_range.\n       k \\<in> wordinterval_to_set ip_range \\<and>\n       (output_port, ip_range)\n       \\<in> set (routing_ipassmt_wi tbl) \\<Longrightarrow>\n    output_iface (routing_table_semantics tbl k) = output_port", "with vpfx routing_ipassmt_wi_sound"], ["proof (chain)\npicking this:\n  valid_prefixes tbl\n  \\<lbrakk>valid_prefixes ?tbl;\n   (?ea, ?eb) \\<in> set (routing_ipassmt_wi ?tbl);\n   ?k \\<in> wordinterval_to_set ?eb\\<rbrakk>\n  \\<Longrightarrow> ?ea = output_iface (routing_table_semantics ?tbl ?k)\n  \\<exists>ip_range.\n     k \\<in> wordinterval_to_set ip_range \\<and>\n     (output_port, ip_range) \\<in> set (routing_ipassmt_wi tbl)", "show ?case"], ["proof (prove)\nusing this:\n  valid_prefixes tbl\n  \\<lbrakk>valid_prefixes ?tbl;\n   (?ea, ?eb) \\<in> set (routing_ipassmt_wi ?tbl);\n   ?k \\<in> wordinterval_to_set ?eb\\<rbrakk>\n  \\<Longrightarrow> ?ea = output_iface (routing_table_semantics ?tbl ?k)\n  \\<exists>ip_range.\n     k \\<in> wordinterval_to_set ip_range \\<and>\n     (output_port, ip_range) \\<in> set (routing_ipassmt_wi tbl)\n\ngoal (1 subgoal):\n 1. output_iface (routing_table_semantics tbl k) = output_port", "by blast"], ["proof (state)\nthis:\n  output_iface (routing_table_semantics tbl k) = output_port\n\ngoal (1 subgoal):\n 1. output_iface (routing_table_semantics tbl k) =\n    output_port \\<Longrightarrow>\n    \\<exists>ip_range.\n       k \\<in> wordinterval_to_set ip_range \\<and>\n       (output_port, ip_range) \\<in> set (routing_ipassmt_wi tbl)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. output_iface (routing_table_semantics tbl k) =\n    output_port \\<Longrightarrow>\n    \\<exists>ip_range.\n       k \\<in> wordinterval_to_set ip_range \\<and>\n       (output_port, ip_range) \\<in> set (routing_ipassmt_wi tbl)", "case 1"], ["proof (state)\nthis:\n  output_iface (routing_table_semantics tbl k) = output_port\n\ngoal (1 subgoal):\n 1. output_iface (routing_table_semantics tbl k) =\n    output_port \\<Longrightarrow>\n    \\<exists>ip_range.\n       k \\<in> wordinterval_to_set ip_range \\<and>\n       (output_port, ip_range) \\<in> set (routing_ipassmt_wi tbl)", "then"], ["proof (chain)\npicking this:\n  output_iface (routing_table_semantics tbl k) = output_port", "obtain ip_range where \"(output_port, ip_range) \\<in> set (routing_port_ranges tbl wordinterval_UNIV) \\<and> k \\<in> wordinterval_to_set ip_range\""], ["proof (prove)\nusing this:\n  output_iface (routing_table_semantics tbl k) = output_port\n\ngoal (1 subgoal):\n 1. (\\<And>ip_range.\n        (output_port, ip_range)\n        \\<in> set (routing_port_ranges tbl wordinterval_UNIV) \\<and>\n        k \\<in> wordinterval_to_set ip_range \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using routing_port_rangesI[where wi = wordinterval_UNIV, OF vpfx]"], ["proof (prove)\nusing this:\n  output_iface (routing_table_semantics tbl k) = output_port\n  \\<lbrakk>output_iface (routing_table_semantics tbl ?k) = ?output_port;\n   ?k \\<in> wordinterval_to_set wordinterval_UNIV\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ip_range.\n                       (?output_port, ip_range)\n                       \\<in> set (routing_port_ranges tbl\n                                   wordinterval_UNIV) \\<and>\n                       ?k \\<in> wordinterval_to_set ip_range\n\ngoal (1 subgoal):\n 1. (\\<And>ip_range.\n        (output_port, ip_range)\n        \\<in> set (routing_port_ranges tbl wordinterval_UNIV) \\<and>\n        k \\<in> wordinterval_to_set ip_range \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (output_port, ip_range)\n  \\<in> set (routing_port_ranges tbl wordinterval_UNIV) \\<and>\n  k \\<in> wordinterval_to_set ip_range\n\ngoal (1 subgoal):\n 1. output_iface (routing_table_semantics tbl k) =\n    output_port \\<Longrightarrow>\n    \\<exists>ip_range.\n       k \\<in> wordinterval_to_set ip_range \\<and>\n       (output_port, ip_range) \\<in> set (routing_ipassmt_wi tbl)", "thus ?case"], ["proof (prove)\nusing this:\n  (output_port, ip_range)\n  \\<in> set (routing_port_ranges tbl wordinterval_UNIV) \\<and>\n  k \\<in> wordinterval_to_set ip_range\n\ngoal (1 subgoal):\n 1. \\<exists>ip_range.\n       k \\<in> wordinterval_to_set ip_range \\<and>\n       (output_port, ip_range) \\<in> set (routing_ipassmt_wi tbl)", "unfolding routing_ipassmt_wi_def reduce_range_destination_def"], ["proof (prove)\nusing this:\n  (output_port, ip_range)\n  \\<in> set (routing_port_ranges tbl wordinterval_UNIV) \\<and>\n  k \\<in> wordinterval_to_set ip_range\n\ngoal (1 subgoal):\n 1. \\<exists>ip_range.\n       k \\<in> wordinterval_to_set ip_range \\<and>\n       (output_port, ip_range)\n       \\<in> set (let ps = remdups\n                            (map fst\n                              (routing_port_ranges tbl wordinterval_UNIV));\n                      c = \\<lambda>s.\n                             (wordinterval_Union \\<circ> map snd \\<circ>\n                              filter ((=) s \\<circ> fst))\n                              (routing_port_ranges tbl wordinterval_UNIV)\n                  in map (\\<lambda>p. (p, c p)) ps)", "unfolding Let_def comp_def"], ["proof (prove)\nusing this:\n  (output_port, ip_range)\n  \\<in> set (routing_port_ranges tbl wordinterval_UNIV) \\<and>\n  k \\<in> wordinterval_to_set ip_range\n\ngoal (1 subgoal):\n 1. \\<exists>ip_range.\n       k \\<in> wordinterval_to_set ip_range \\<and>\n       (output_port, ip_range)\n       \\<in> set (map (\\<lambda>p.\n                          (p, wordinterval_Union\n                               (map snd\n                                 (filter (\\<lambda>x. p = fst x)\n                                   (routing_port_ranges tbl\n                                     wordinterval_UNIV)))))\n                   (remdups\n                     (map fst (routing_port_ranges tbl wordinterval_UNIV))))", "by(force simp add: Set.image_iff wordinterval_Union)"], ["proof (state)\nthis:\n  \\<exists>ip_range.\n     k \\<in> wordinterval_to_set ip_range \\<and>\n     (output_port, ip_range) \\<in> set (routing_ipassmt_wi tbl)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* this was not given for the old reduced_range_destination *)"], ["", "lemma routing_ipassmt_wi_has_all_interfaces:\n  assumes in_tbl: \"r \\<in> set tbl\"\n  shows \"\\<exists>s. (routing_oiface r,s) \\<in> set (routing_ipassmt_wi tbl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s. (routing_oiface r, s) \\<in> set (routing_ipassmt_wi tbl)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s. (routing_oiface r, s) \\<in> set (routing_ipassmt_wi tbl)", "from in_tbl"], ["proof (chain)\npicking this:\n  r \\<in> set tbl", "have \"\\<exists>s. (routing_oiface r,s) \\<in> set (routing_port_ranges tbl S)\" for S"], ["proof (prove)\nusing this:\n  r \\<in> set tbl\n\ngoal (1 subgoal):\n 1. \\<exists>s. (routing_oiface r, s) \\<in> set (routing_port_ranges tbl S)", "proof(induction tbl arbitrary: S)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>S.\n       r \\<in> set [] \\<Longrightarrow>\n       \\<exists>s.\n          (routing_oiface r, s) \\<in> set (routing_port_ranges [] S)\n 2. \\<And>a tbl S.\n       \\<lbrakk>\\<And>S.\n                   r \\<in> set tbl \\<Longrightarrow>\n                   \\<exists>s.\n                      (routing_oiface r, s)\n                      \\<in> set (routing_port_ranges tbl S);\n        r \\<in> set (a # tbl)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s.\n                            (routing_oiface r, s)\n                            \\<in> set (routing_port_ranges (a # tbl) S)", "case (Cons l ls)"], ["proof (state)\nthis:\n  r \\<in> set ls \\<Longrightarrow>\n  \\<exists>s. (routing_oiface r, s) \\<in> set (routing_port_ranges ls ?S)\n  r \\<in> set (l # ls)\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       r \\<in> set [] \\<Longrightarrow>\n       \\<exists>s.\n          (routing_oiface r, s) \\<in> set (routing_port_ranges [] S)\n 2. \\<And>a tbl S.\n       \\<lbrakk>\\<And>S.\n                   r \\<in> set tbl \\<Longrightarrow>\n                   \\<exists>s.\n                      (routing_oiface r, s)\n                      \\<in> set (routing_port_ranges tbl S);\n        r \\<in> set (a # tbl)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s.\n                            (routing_oiface r, s)\n                            \\<in> set (routing_port_ranges (a # tbl) S)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s.\n       (routing_oiface r, s) \\<in> set (routing_port_ranges (l # ls) S)", "proof(cases \"r = l\")"], ["proof (state)\ngoal (2 subgoals):\n 1. r = l \\<Longrightarrow>\n    \\<exists>s.\n       (routing_oiface r, s) \\<in> set (routing_port_ranges (l # ls) S)\n 2. r \\<noteq> l \\<Longrightarrow>\n    \\<exists>s.\n       (routing_oiface r, s) \\<in> set (routing_port_ranges (l # ls) S)", "case True"], ["proof (state)\nthis:\n  r = l\n\ngoal (2 subgoals):\n 1. r = l \\<Longrightarrow>\n    \\<exists>s.\n       (routing_oiface r, s) \\<in> set (routing_port_ranges (l # ls) S)\n 2. r \\<noteq> l \\<Longrightarrow>\n    \\<exists>s.\n       (routing_oiface r, s) \\<in> set (routing_port_ranges (l # ls) S)", "thus ?thesis"], ["proof (prove)\nusing this:\n  r = l\n\ngoal (1 subgoal):\n 1. \\<exists>s.\n       (routing_oiface r, s) \\<in> set (routing_port_ranges (l # ls) S)", "using Cons.prems"], ["proof (prove)\nusing this:\n  r = l\n  r \\<in> set (l # ls)\n\ngoal (1 subgoal):\n 1. \\<exists>s.\n       (routing_oiface r, s) \\<in> set (routing_port_ranges (l # ls) S)", "by(auto simp: Let_def)"], ["proof (state)\nthis:\n  \\<exists>s.\n     (routing_oiface r, s) \\<in> set (routing_port_ranges (l # ls) S)\n\ngoal (1 subgoal):\n 1. r \\<noteq> l \\<Longrightarrow>\n    \\<exists>s.\n       (routing_oiface r, s) \\<in> set (routing_port_ranges (l # ls) S)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. r \\<noteq> l \\<Longrightarrow>\n    \\<exists>s.\n       (routing_oiface r, s) \\<in> set (routing_port_ranges (l # ls) S)", "case False"], ["proof (state)\nthis:\n  r \\<noteq> l\n\ngoal (1 subgoal):\n 1. r \\<noteq> l \\<Longrightarrow>\n    \\<exists>s.\n       (routing_oiface r, s) \\<in> set (routing_port_ranges (l # ls) S)", "with Cons.prems"], ["proof (chain)\npicking this:\n  r \\<in> set (l # ls)\n  r \\<noteq> l", "have \"r \\<in> set ls\""], ["proof (prove)\nusing this:\n  r \\<in> set (l # ls)\n  r \\<noteq> l\n\ngoal (1 subgoal):\n 1. r \\<in> set ls", "by simp"], ["proof (state)\nthis:\n  r \\<in> set ls\n\ngoal (1 subgoal):\n 1. r \\<noteq> l \\<Longrightarrow>\n    \\<exists>s.\n       (routing_oiface r, s) \\<in> set (routing_port_ranges (l # ls) S)", "from Cons.IH[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>s. (routing_oiface r, s) \\<in> set (routing_port_ranges ls ?S)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s. (routing_oiface r, s) \\<in> set (routing_port_ranges ls ?S)\n\ngoal (1 subgoal):\n 1. \\<exists>s.\n       (routing_oiface r, s) \\<in> set (routing_port_ranges (l # ls) S)", "by(simp add: Let_def) blast"], ["proof (state)\nthis:\n  \\<exists>s.\n     (routing_oiface r, s) \\<in> set (routing_port_ranges (l # ls) S)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s.\n     (routing_oiface r, s) \\<in> set (routing_port_ranges (l # ls) S)\n\ngoal (1 subgoal):\n 1. \\<And>S.\n       r \\<in> set [] \\<Longrightarrow>\n       \\<exists>s.\n          (routing_oiface r, s) \\<in> set (routing_port_ranges [] S)", "qed simp"], ["proof (state)\nthis:\n  \\<exists>s. (routing_oiface r, s) \\<in> set (routing_port_ranges tbl ?S)\n\ngoal (1 subgoal):\n 1. \\<exists>s. (routing_oiface r, s) \\<in> set (routing_ipassmt_wi tbl)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s. (routing_oiface r, s) \\<in> set (routing_port_ranges tbl ?S)\n\ngoal (1 subgoal):\n 1. \\<exists>s. (routing_oiface r, s) \\<in> set (routing_ipassmt_wi tbl)", "unfolding routing_ipassmt_wi_def reduce_range_destination_def"], ["proof (prove)\nusing this:\n  \\<exists>s. (routing_oiface r, s) \\<in> set (routing_port_ranges tbl ?S)\n\ngoal (1 subgoal):\n 1. \\<exists>s.\n       (routing_oiface r, s)\n       \\<in> set (let ps = remdups\n                            (map fst\n                              (routing_port_ranges tbl wordinterval_UNIV));\n                      c = \\<lambda>s.\n                             (wordinterval_Union \\<circ> map snd \\<circ>\n                              filter ((=) s \\<circ> fst))\n                              (routing_port_ranges tbl wordinterval_UNIV)\n                  in map (\\<lambda>p. (p, c p)) ps)", "by(force simp add: Set.image_iff)"], ["proof (state)\nthis:\n  \\<exists>s. (routing_oiface r, s) \\<in> set (routing_ipassmt_wi tbl)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}