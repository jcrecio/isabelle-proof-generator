{"file_name": "/home/qj213/afp-2021-10-22/thys/Regex_Equivalence/Before2.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Regex_Equivalence", "problem_names": ["lemma finite_atoms[simp]: \"finite (atoms r)\"", "lemma finite_mrexps3[simp]: \"finite (mrexps3 r)\"", "lemma strip_mrexps3: \"(strip o strip3) ` mrexps3 r = {r}\"", "lemma ok3_fin1_final1[simp]: \"ok3 r \\<Longrightarrow> fin1 r = Collect (final1 (strip3 r))\"", "lemma ok3_nul_nullable[simp]: \"ok3 r \\<Longrightarrow> nul r = nullable (strip3 r)\"", "lemma ok3_final3_final[simp]: \"ok3 r \\<Longrightarrow> final3 r = final (strip3 r)\"", "lemma follow3_follow[simp]: \"ok3 r \\<Longrightarrow> strip3 (follow3 m r) = follow m (strip3 r)\"", "lemma nul_follow3[simp]: \"ok3 r \\<Longrightarrow> nul (follow3 m r) = nul r\"", "lemma ok3_follow3[simp]: \"ok3 r \\<Longrightarrow> ok3 (follow3 m r)\"", "lemma fin1_atoms: \"\\<lbrakk>x \\<in> fin1 mr; mr \\<in> mrexps3 r\\<rbrakk> \\<Longrightarrow> x \\<in> atoms r\"", "lemma follow3_mrexps3[simp]: \"r \\<in> mrexps3 s \\<Longrightarrow> follow3 m r \\<in> mrexps3 s\"", "lemma empty_mrexp3_mrexps[simp]: \"empty_mrexp3 r \\<in> mrexps3 r\"", "lemma strip3_empty_mrexp3[simp]: \"strip3 (empty_mrexp3 r) = empty_mrexp r\"", "lemma strip3_move3: \"ok3 r \\<Longrightarrow> strip3(move3 m r c) = move m (strip3 r) c\"", "lemma nul_empty_mrexp3[simp]: \"nul (empty_mrexp3 r) = nullable r\"", "lemma ok3_empty_mrexp3: \"ok3 (empty_mrexp3 r)\"", "lemma ok3_move3: \"ok3 r \\<Longrightarrow> ok3(move3 m r c)\"", "lemma nonfin1_empty_mrexp3[simp]: \"c \\<notin> fin1 (empty_mrexp3 r)\"", "lemma move3_mrexps3[simp]: \"r \\<in> mrexps3 s \\<Longrightarrow> move3 x r a \\<in> mrexps3 s\"", "lemma eq_mrexp3_imp_eq: \"\\<lbrakk>eq_mrexp3 r s; ok3 r; ok3 s\\<rbrakk> \\<Longrightarrow> (r = s)\"", "lemma eq_mrexp3_refl[simplified, simp]: \"r = s \\<Longrightarrow> eq_mrexp3 r s\"", "lemma eq_mrexp3_eq: \"\\<lbrakk>ok3 r; ok3 s\\<rbrakk> \\<Longrightarrow> eq_mrexp3 r s = (r = s)\""], "translations": [["", "lemma finite_atoms[simp]: \"finite (atoms r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (atoms r)", "by (induct r) auto"], ["", "lemma finite_mrexps3[simp]: \"finite (mrexps3 r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (mrexps3 r)", "by (induct r) auto"], ["", "definition[simp]: \"plus3 r s == Plus3 r s (fin1 r \\<union> fin1 s) (nul r \\<or> nul s)\""], ["", "definition[simp]: \"times3 r s ==\n  let ns = nul s in Times3 r s (fin1 s \\<union> (if ns then fin1 r else {})) (nul r \\<and> ns)\""], ["", "definition[simp]: \"star3 r == Star3 r (fin1 r)\""], ["", "primrec follow3 :: \"bool \\<Rightarrow> 'a mrexp3 \\<Rightarrow> 'a mrexp3\" where\n\"follow3 m Zero3 = Zero3\" |\n\"follow3 m One3 = One3\" |\n\"follow3 m (Atom3 _ a) = Atom3 m a\" |\n\"follow3 m (Plus3 r s _ _) = plus3 (follow3 m r) (follow3 m s)\" |\n\"follow3 m (Times3 r s _ _) =\n  times3 (follow3 m r) (follow3 (final3 r \\<or> m \\<and> nul r) s)\" |\n\"follow3 m (Star3 r _) = star3(follow3 (final3 r \\<or> m) r)\""], ["", "primrec empty_mrexp3 :: \"'a rexp \\<Rightarrow> 'a mrexp3\" where\n\"empty_mrexp3 Zero = Zero3\" |\n\"empty_mrexp3 One = One3\" |\n\"empty_mrexp3 (Atom x) = Atom3 False x\" |\n\"empty_mrexp3 (Plus r s) = plus3 (empty_mrexp3 r) (empty_mrexp3 s)\" |\n\"empty_mrexp3 (Times r s) = times3 (empty_mrexp3 r) (empty_mrexp3 s)\" |\n\"empty_mrexp3 (Star r) = star3 (empty_mrexp3 r)\""], ["", "primrec move3 :: \"'a \\<Rightarrow> 'a mrexp3 \\<Rightarrow> bool \\<Rightarrow> 'a mrexp3\" where\n\"move3 _ One3 _ = One3\" |\n\"move3 _ Zero3 _ = Zero3\" |\n\"move3 c (Atom3 _ a) m = Atom3 m a\" |\n\"move3 c (Plus3 r s _ _) m = plus3 (move3 c r m) (move3 c s m)\" |\n\"move3 c (Times3 r s _ _) m =\n  times3 (move3 c r m) (move3 c s (c \\<in> fin1 r \\<or> m \\<and> nul r))\" |\n\"move3 c (Star3 r _) m = star3 (move3 c r (c \\<in> fin1 r \\<or> m))\""], ["", "primrec strip3 where\n\"strip3 Zero3 = Zero\" |\n\"strip3 One3 = One\" |\n\"strip3 (Atom3 m x) = Atom (m, x)\" |\n\"strip3 (Plus3 r s _ _) = Plus (strip3 r) (strip3 s)\" |\n\"strip3 (Times3 r s _ _) = Times (strip3 r) (strip3 s)\" |\n\"strip3 (Star3 r _) = Star (strip3 r)\""], ["", "lemma strip_mrexps3: \"(strip o strip3) ` mrexps3 r = {r}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (strip \\<circ> strip3) ` mrexps3 r = {r}", "by (induction r) (auto simp: set_eq_subset subset_iff image_iff)"], ["", "primrec ok3 :: \"'a mrexp3 \\<Rightarrow> bool\" where\n\"ok3 Zero3 = True\" |\n\"ok3 One3 = True\" |\n\"ok3 (Atom3 _ _) = True\" |\n\"ok3 (Plus3 r s f1 n) = (ok3 r \\<and> ok3 s \\<and>\n   (let rs = Plus (strip3 r) (strip3 s) in f1 = Collect (final1 rs) \\<and> n = nullable rs))\" |\n\"ok3 (Times3 r s f1 n) = (ok3 r \\<and> ok3 s \\<and>\n   (let rs = Times (strip3 r) (strip3 s) in f1 = Collect (final1 rs) \\<and> n = nullable rs))\" |\n\"ok3 (Star3 r f1) = (ok3 r \\<and> f1 = Collect (final1 (strip3 r)))\""], ["", "lemma ok3_fin1_final1[simp]: \"ok3 r \\<Longrightarrow> fin1 r = Collect (final1 (strip3 r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ok3 r \\<Longrightarrow> fin1 r = Collect (final1 (strip3 r))", "by (induct r) (auto simp add: set_eq_iff)"], ["", "lemma ok3_nul_nullable[simp]: \"ok3 r \\<Longrightarrow> nul r = nullable (strip3 r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ok3 r \\<Longrightarrow> nul r = nullable (strip3 r)", "by (induct r) auto"], ["", "lemma ok3_final3_final[simp]: \"ok3 r \\<Longrightarrow> final3 r = final (strip3 r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ok3 r \\<Longrightarrow> final3 r = final (strip3 r)", "by (induct r) auto"], ["", "lemma follow3_follow[simp]: \"ok3 r \\<Longrightarrow> strip3 (follow3 m r) = follow m (strip3 r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ok3 r \\<Longrightarrow> strip3 (follow3 m r) = follow m (strip3 r)", "by (induct r arbitrary: m) auto"], ["", "lemma nul_follow3[simp]: \"ok3 r \\<Longrightarrow> nul (follow3 m r) = nul r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ok3 r \\<Longrightarrow> nul (follow3 m r) = nul r", "by (induct r arbitrary: m) auto"], ["", "lemma ok3_follow3[simp]: \"ok3 r \\<Longrightarrow> ok3 (follow3 m r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ok3 r \\<Longrightarrow> ok3 (follow3 m r)", "by (induct r arbitrary: m) auto"], ["", "lemma fin1_atoms: \"\\<lbrakk>x \\<in> fin1 mr; mr \\<in> mrexps3 r\\<rbrakk> \\<Longrightarrow> x \\<in> atoms r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> fin1 mr; mr \\<in> mrexps3 r\\<rbrakk>\n    \\<Longrightarrow> x \\<in> atoms r", "by (induct r) auto"], ["", "lemma follow3_mrexps3[simp]: \"r \\<in> mrexps3 s \\<Longrightarrow> follow3 m r \\<in> mrexps3 s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<in> mrexps3 s \\<Longrightarrow> follow3 m r \\<in> mrexps3 s", "by (induct s arbitrary: m r) (fastforce simp add: image_iff dest: fin1_atoms)+"], ["", "lemma empty_mrexp3_mrexps[simp]: \"empty_mrexp3 r \\<in> mrexps3 r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. empty_mrexp3 r \\<in> mrexps3 r", "by (induct r) (auto simp: image_iff dest: fin1_atoms)"], ["", "lemma strip3_empty_mrexp3[simp]: \"strip3 (empty_mrexp3 r) = empty_mrexp r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip3 (empty_mrexp3 r) = empty_mrexp r", "by (induct r) auto"], ["", "lemma strip3_move3: \"ok3 r \\<Longrightarrow> strip3(move3 m r c) = move m (strip3 r) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ok3 r \\<Longrightarrow> strip3 (move3 m r c) = move m (strip3 r) c", "apply(induction r arbitrary: c)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>c.\n       ok3 Zero3 \\<Longrightarrow>\n       strip3 (move3 m Zero3 c) = move m (strip3 Zero3) c\n 2. \\<And>c.\n       ok3 One3 \\<Longrightarrow>\n       strip3 (move3 m One3 c) = move m (strip3 One3) c\n 3. \\<And>x1 x2 c.\n       ok3 (Atom3 x1 x2) \\<Longrightarrow>\n       strip3 (move3 m (Atom3 x1 x2) c) = move m (strip3 (Atom3 x1 x2)) c\n 4. \\<And>r1 r2 x3 x4 c.\n       \\<lbrakk>\\<And>c.\n                   ok3 r1 \\<Longrightarrow>\n                   strip3 (move3 m r1 c) = move m (strip3 r1) c;\n        \\<And>c.\n           ok3 r2 \\<Longrightarrow>\n           strip3 (move3 m r2 c) = move m (strip3 r2) c;\n        ok3 (Plus3 r1 r2 x3 x4)\\<rbrakk>\n       \\<Longrightarrow> strip3 (move3 m (Plus3 r1 r2 x3 x4) c) =\n                         move m (strip3 (Plus3 r1 r2 x3 x4)) c\n 5. \\<And>r1 r2 x3 x4 c.\n       \\<lbrakk>\\<And>c.\n                   ok3 r1 \\<Longrightarrow>\n                   strip3 (move3 m r1 c) = move m (strip3 r1) c;\n        \\<And>c.\n           ok3 r2 \\<Longrightarrow>\n           strip3 (move3 m r2 c) = move m (strip3 r2) c;\n        ok3 (Times3 r1 r2 x3 x4)\\<rbrakk>\n       \\<Longrightarrow> strip3 (move3 m (Times3 r1 r2 x3 x4) c) =\n                         move m (strip3 (Times3 r1 r2 x3 x4)) c\n 6. \\<And>r x2 c.\n       \\<lbrakk>\\<And>c.\n                   ok3 r \\<Longrightarrow>\n                   strip3 (move3 m r c) = move m (strip3 r) c;\n        ok3 (Star3 r x2)\\<rbrakk>\n       \\<Longrightarrow> strip3 (move3 m (Star3 r x2) c) =\n                         move m (strip3 (Star3 r x2)) c", "apply (auto simp: disj_commute)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nul_empty_mrexp3[simp]: \"nul (empty_mrexp3 r) = nullable r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nul (empty_mrexp3 r) = nullable r", "apply(induction r)"], ["proof (prove)\ngoal (6 subgoals):\n 1. nul (empty_mrexp3 Zero) = nullable Zero\n 2. nul (empty_mrexp3 One) = nullable One\n 3. \\<And>x. nul (empty_mrexp3 (Atom x)) = nullable (Atom x)\n 4. \\<And>r1 r2.\n       \\<lbrakk>nul (empty_mrexp3 r1) = nullable r1;\n        nul (empty_mrexp3 r2) = nullable r2\\<rbrakk>\n       \\<Longrightarrow> nul (empty_mrexp3 (Plus r1 r2)) =\n                         nullable (Plus r1 r2)\n 5. \\<And>r1 r2.\n       \\<lbrakk>nul (empty_mrexp3 r1) = nullable r1;\n        nul (empty_mrexp3 r2) = nullable r2\\<rbrakk>\n       \\<Longrightarrow> nul (empty_mrexp3 (Times r1 r2)) =\n                         nullable (Times r1 r2)\n 6. \\<And>r.\n       nul (empty_mrexp3 r) = nullable r \\<Longrightarrow>\n       nul (empty_mrexp3 (Star r)) = nullable (Star r)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ok3_empty_mrexp3: \"ok3 (empty_mrexp3 r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ok3 (empty_mrexp3 r)", "apply(induction r)"], ["proof (prove)\ngoal (6 subgoals):\n 1. ok3 (empty_mrexp3 Zero)\n 2. ok3 (empty_mrexp3 One)\n 3. \\<And>x. ok3 (empty_mrexp3 (Atom x))\n 4. \\<And>r1 r2.\n       \\<lbrakk>ok3 (empty_mrexp3 r1); ok3 (empty_mrexp3 r2)\\<rbrakk>\n       \\<Longrightarrow> ok3 (empty_mrexp3 (Plus r1 r2))\n 5. \\<And>r1 r2.\n       \\<lbrakk>ok3 (empty_mrexp3 r1); ok3 (empty_mrexp3 r2)\\<rbrakk>\n       \\<Longrightarrow> ok3 (empty_mrexp3 (Times r1 r2))\n 6. \\<And>r.\n       ok3 (empty_mrexp3 r) \\<Longrightarrow> ok3 (empty_mrexp3 (Star r))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ok3_move3: \"ok3 r \\<Longrightarrow> ok3(move3 m r c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ok3 r \\<Longrightarrow> ok3 (move3 m r c)", "apply(induction r arbitrary: c)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>c. ok3 Zero3 \\<Longrightarrow> ok3 (move3 m Zero3 c)\n 2. \\<And>c. ok3 One3 \\<Longrightarrow> ok3 (move3 m One3 c)\n 3. \\<And>x1 x2 c.\n       ok3 (Atom3 x1 x2) \\<Longrightarrow> ok3 (move3 m (Atom3 x1 x2) c)\n 4. \\<And>r1 r2 x3 x4 c.\n       \\<lbrakk>\\<And>c. ok3 r1 \\<Longrightarrow> ok3 (move3 m r1 c);\n        \\<And>c. ok3 r2 \\<Longrightarrow> ok3 (move3 m r2 c);\n        ok3 (Plus3 r1 r2 x3 x4)\\<rbrakk>\n       \\<Longrightarrow> ok3 (move3 m (Plus3 r1 r2 x3 x4) c)\n 5. \\<And>r1 r2 x3 x4 c.\n       \\<lbrakk>\\<And>c. ok3 r1 \\<Longrightarrow> ok3 (move3 m r1 c);\n        \\<And>c. ok3 r2 \\<Longrightarrow> ok3 (move3 m r2 c);\n        ok3 (Times3 r1 r2 x3 x4)\\<rbrakk>\n       \\<Longrightarrow> ok3 (move3 m (Times3 r1 r2 x3 x4) c)\n 6. \\<And>r x2 c.\n       \\<lbrakk>\\<And>c. ok3 r \\<Longrightarrow> ok3 (move3 m r c);\n        ok3 (Star3 r x2)\\<rbrakk>\n       \\<Longrightarrow> ok3 (move3 m (Star3 r x2) c)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nonfin1_empty_mrexp3[simp]: \"c \\<notin> fin1 (empty_mrexp3 r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<notin> fin1 (empty_mrexp3 r)", "by (induct r) auto"], ["", "lemma move3_mrexps3[simp]: \"r \\<in> mrexps3 s \\<Longrightarrow> move3 x r a \\<in> mrexps3 s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<in> mrexps3 s \\<Longrightarrow> move3 x r a \\<in> mrexps3 s", "by (induct s arbitrary: r x a) (fastforce simp: image_iff dest: fin1_atoms)+"], ["", "typedef 'a ok_mrexp3 = \"{(r :: 'a mrexp3, b :: bool). ok3 r}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {(r, b). ok3 r}", "unfolding mem_Collect_eq split_beta"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. ok3 (fst x)", "by (metis fst_eqD ok3_empty_mrexp3)"], ["", "setup_lifting type_definition_ok_mrexp3"], ["", "abbreviation \"init_m r \\<equiv> let mr = follow3 True (empty_mrexp3 r) in (mr, nul mr)\""], ["", "lift_definition init_okm :: \"'a rexp \\<Rightarrow> 'a ok_mrexp3\" is init_m"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rexp. init_m rexp \\<in> {(r, b). ok3 r}", "by (simp add: ok3_empty_mrexp3)"], ["", "lift_definition delta_okm :: \"'a \\<Rightarrow> 'a ok_mrexp3 \\<Rightarrow> 'a ok_mrexp3\" is\n  \"\\<lambda>a (r, m). (move3 a r False, a \\<in> fin1 r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a prod.\n       prod \\<in> {(r, b). ok3 r} \\<Longrightarrow>\n       (case prod of (r, m) \\<Rightarrow> (move3 a r False, a \\<in> fin1 r))\n       \\<in> {(r, b). ok3 r}", "unfolding mem_Collect_eq split_beta fst_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a prod.\n       ok3 (fst prod) \\<Longrightarrow> ok3 (move3 a (fst prod) False)", "by (intro ok3_move3) simp"], ["", "lift_definition nullable_okm :: \"'a ok_mrexp3 \\<Rightarrow> bool\" is \"snd\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition lang_okm :: \"'a ok_mrexp3 \\<Rightarrow> 'a lang\" is \"\\<lambda>(r, m). L_b (strip3 r, m)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instantiation ok_mrexp3 :: (equal) \"equal\"\nbegin"], ["", "fun eq_mrexp3 where\n  \"eq_mrexp3 Zero3 Zero3 = True\"\n| \"eq_mrexp3 One3 One3 = True\"\n| \"eq_mrexp3 (Atom3 m x) (Atom3 m' y) = (m = m' \\<and> x = y)\"\n| \"eq_mrexp3 (Plus3 r1 s1 _ _) (Plus3 r3 s3 _ _) = (eq_mrexp3 r1 r3 \\<and> eq_mrexp3 s1 s3)\"\n| \"eq_mrexp3 (Times3 r1 s1 _ _) (Times3 r3 s3 _ _) = (eq_mrexp3 r1 r3 \\<and> eq_mrexp3 s1 s3)\"\n| \"eq_mrexp3 (Star3 r1 _) (Star3 r3 _) = (eq_mrexp3 r1 r3)\"\n| \"eq_mrexp3 r s = False\""], ["", "lemma eq_mrexp3_imp_eq: \"\\<lbrakk>eq_mrexp3 r s; ok3 r; ok3 s\\<rbrakk> \\<Longrightarrow> (r = s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eq_mrexp3 r s; ok3 r; ok3 s\\<rbrakk> \\<Longrightarrow> r = s", "by (induct rule: eq_mrexp3.induct) auto"], ["", "lemma eq_mrexp3_refl[simplified, simp]: \"r = s \\<Longrightarrow> eq_mrexp3 r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r = s \\<Longrightarrow> eq_mrexp3 r s", "by (induct rule: eq_mrexp3.induct) auto"], ["", "lemma eq_mrexp3_eq: \"\\<lbrakk>ok3 r; ok3 s\\<rbrakk> \\<Longrightarrow> eq_mrexp3 r s = (r = s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ok3 r; ok3 s\\<rbrakk> \\<Longrightarrow> eq_mrexp3 r s = (r = s)", "by (metis eq_mrexp3_imp_eq eq_mrexp3_refl)"], ["", "lift_definition equal_ok_mrexp3 :: \"'a ok_mrexp3 \\<Rightarrow> 'a ok_mrexp3 \\<Rightarrow> bool\"\n   is \"\\<lambda>(r1, b1) (r3, b3). b1 = b3 \\<and> eq_mrexp3 r1 r3\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ok_mrexp3, equal_class)", "by intro_classes (transfer, auto simp: eq_mrexp3_eq)"], ["", "end"], ["", "global_interpretation before2: rexp_DFA init_okm delta_okm nullable_okm lang_okm\n  defines before2_closure = before2.closure\n    and check_eqv_b2 = before2.check_eqv\n    and reachable_b2 = before2.reachable\n    and automaton_b2 = before2.automaton\n    and match_b2 = before2.match"], ["proof (prove)\ngoal (1 subgoal):\n 1. rexp_DFA init_okm delta_okm nullable_okm lang_okm", "proof (standard, goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>r. lang_okm (init_okm r) = lang r\n 2. \\<And>a s. lang_okm (delta_okm a s) = Deriv a (lang_okm s)\n 3. \\<And>s. nullable_okm s = ([] \\<in> lang_okm s)\n 4. \\<And>s. finite {fold delta_okm w (init_okm s) |w. True}", "case (1 r)"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>r. lang_okm (init_okm r) = lang r\n 2. \\<And>a s. lang_okm (delta_okm a s) = Deriv a (lang_okm s)\n 3. \\<And>s. nullable_okm s = ([] \\<in> lang_okm s)\n 4. \\<And>s. finite {fold delta_okm w (init_okm s) |w. True}", "show \"lang_okm (init_okm r) = lang r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang_okm (init_okm r) = lang r", "by transfer (auto simp: split_beta init_a_def nonfinal_empty_mrexp Lm_follow Lm_empty\n      map_map_rexp nullable_iff ok3_empty_mrexp3)"], ["proof (state)\nthis:\n  lang_okm (init_okm r) = lang r\n\ngoal (3 subgoals):\n 1. \\<And>a s. lang_okm (delta_okm a s) = Deriv a (lang_okm s)\n 2. \\<And>s. nullable_okm s = ([] \\<in> lang_okm s)\n 3. \\<And>s. finite {fold delta_okm w (init_okm s) |w. True}", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a s. lang_okm (delta_okm a s) = Deriv a (lang_okm s)\n 2. \\<And>s. nullable_okm s = ([] \\<in> lang_okm s)\n 3. \\<And>s. finite {fold delta_okm w (init_okm s) |w. True}", "case (2 a br)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>a s. lang_okm (delta_okm a s) = Deriv a (lang_okm s)\n 2. \\<And>s. nullable_okm s = ([] \\<in> lang_okm s)\n 3. \\<And>s. finite {fold delta_okm w (init_okm s) |w. True}", "show \"lang_okm (delta_okm a br) = Deriv a (lang_okm br)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang_okm (delta_okm a br) = Deriv a (lang_okm br)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a br.\n       br \\<in> {(r, b). ok3 r} \\<Longrightarrow>\n       (case case br of\n             (r, m) \\<Rightarrow> (move3 a r False, a \\<in> fin1 r) of\n        (r, m) \\<Rightarrow> L_b (strip3 r, m)) =\n       Deriv a (case br of (r, m) \\<Rightarrow> L_b (strip3 r, m))", "unfolding split_beta fst_conv snd_conv mem_Collect_eq before.L_delta[symmetric] delta_b.simps\n      move_follow_read[symmetric] final_read_final1 Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a br.\n       ok3 (fst br) \\<Longrightarrow>\n       L_b (strip3 (move3 a (fst br) False), a \\<in> fin1 (fst br)) =\n       L_b (move a (strip3 (fst br)) False, final1 (strip3 (fst br)) a)", "by (subst strip3_move3) simp_all"], ["proof (state)\nthis:\n  lang_okm (delta_okm a br) = Deriv a (lang_okm br)\n\ngoal (2 subgoals):\n 1. \\<And>s. nullable_okm s = ([] \\<in> lang_okm s)\n 2. \\<And>s. finite {fold delta_okm w (init_okm s) |w. True}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. nullable_okm s = ([] \\<in> lang_okm s)\n 2. \\<And>s. finite {fold delta_okm w (init_okm s) |w. True}", "case (3 br)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>s. nullable_okm s = ([] \\<in> lang_okm s)\n 2. \\<And>s. finite {fold delta_okm w (init_okm s) |w. True}", "show  \"nullable_okm br = ([] \\<in> lang_okm br)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nullable_okm br = ([] \\<in> lang_okm br)", "by transfer (simp add: split_beta)"], ["proof (state)\nthis:\n  nullable_okm br = ([] \\<in> lang_okm br)\n\ngoal (1 subgoal):\n 1. \\<And>s. finite {fold delta_okm w (init_okm s) |w. True}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. finite {fold delta_okm w (init_okm s) |w. True}", "case (4 s)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>s. finite {fold delta_okm w (init_okm s) |w. True}", "have \"{fold (\\<lambda>a (r, m). (move3 a r False, a \\<in> fin1 r)) w (init_m s) |w. True} \\<subseteq>\n    mrexps3 s \\<times> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {fold (\\<lambda>a (r, m). (move3 a r False, a \\<in> fin1 r)) w\n      (init_m s) |\n     w. True}\n    \\<subseteq> mrexps3 s \\<times> UNIV", "proof (intro subsetI, elim CollectE exE conjE, hypsubst)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x w.\n       True \\<Longrightarrow>\n       fold (\\<lambda>a (r, m). (move3 a r False, a \\<in> fin1 r)) w\n        (init_m s)\n       \\<in> mrexps3 s \\<times> UNIV", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x w.\n       True \\<Longrightarrow>\n       fold (\\<lambda>a (r, m). (move3 a r False, a \\<in> fin1 r)) w\n        (init_m s)\n       \\<in> mrexps3 s \\<times> UNIV", "show \"fold (\\<lambda>a (r, m). (move3 a r False, a \\<in> fin1 r)) w (init_m s) \\<in>\n      mrexps3 s \\<times> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>a (r, m). (move3 a r False, a \\<in> fin1 r)) w (init_m s)\n    \\<in> mrexps3 s \\<times> UNIV", "by (induct w rule: rev_induct) (auto simp: split: prod.splits intro!: move3_mrexps3)"], ["proof (state)\nthis:\n  fold (\\<lambda>a (r, m). (move3 a r False, a \\<in> fin1 r)) w (init_m s)\n  \\<in> mrexps3 s \\<times> UNIV\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {fold (\\<lambda>a (r, m). (move3 a r False, a \\<in> fin1 r)) w\n    (init_m s) |\n   w. True}\n  \\<subseteq> mrexps3 s \\<times> UNIV\n\ngoal (1 subgoal):\n 1. \\<And>s. finite {fold delta_okm w (init_okm s) |w. True}", "then"], ["proof (chain)\npicking this:\n  {fold (\\<lambda>a (r, m). (move3 a r False, a \\<in> fin1 r)) w\n    (init_m s) |\n   w. True}\n  \\<subseteq> mrexps3 s \\<times> UNIV", "show \"finite {fold delta_okm w (init_okm s) |w. True}\""], ["proof (prove)\nusing this:\n  {fold (\\<lambda>a (r, m). (move3 a r False, a \\<in> fin1 r)) w\n    (init_m s) |\n   w. True}\n  \\<subseteq> mrexps3 s \\<times> UNIV\n\ngoal (1 subgoal):\n 1. finite {fold delta_okm w (init_okm s) |w. True}", "by transfer (erule finite_subset[OF subset_trans[rotated]], auto)"], ["proof (state)\nthis:\n  finite {fold delta_okm w (init_okm s) |w. True}\n\ngoal:\nNo subgoals!", "qed"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}