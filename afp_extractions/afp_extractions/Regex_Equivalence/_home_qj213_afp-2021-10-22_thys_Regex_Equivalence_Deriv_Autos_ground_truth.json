{"file_name": "/home/qj213/afp-2021-10-22/thys/Regex_Equivalence/Deriv_Autos.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Regex_Equivalence", "problem_names": ["lemma ACI_norm_derivs_alt: \"\\<guillemotleft>derivs w r\\<guillemotright> = fold (\\<lambda>a r. \\<guillemotleft>deriv a r\\<guillemotright>) w \\<guillemotleft>r\\<guillemotright>\"", "lemma derivs_alt: \"derivs = fold deriv\"", "lemma [transfer_rule]: \"rel_fun (rel_set (pcr_ACI_rexp (=))) (=) (finite o image ACI_norm) finite\"", "lemma Derivs_alt_def: \"Derivs w L = fold Deriv w L\"", "lemma str_eq_alt: \"\\<approx>A = {(x, y). fold Deriv x A = fold Deriv y A}\"", "lemma Myhill_Nerode2: \"finite (UNIV // \\<approx>lang r)\""], "translations": [["", "lemma ACI_norm_derivs_alt: \"\\<guillemotleft>derivs w r\\<guillemotright> = fold (\\<lambda>a r. \\<guillemotleft>deriv a r\\<guillemotright>) w \\<guillemotleft>r\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>derivs w r\\<guillemotright> =\n    fold (\\<lambda>a r. \\<guillemotleft>deriv a r\\<guillemotright>) w\n     \\<guillemotleft>r\\<guillemotright>", "by (induct w arbitrary: r) (auto simp: ACI_norm_deriv)"], ["", "global_interpretation brzozowski: rexp_DFA \"\\<lambda>r. \\<guillemotleft>r\\<guillemotright>\" \"\\<lambda>a r. \\<guillemotleft>deriv a r\\<guillemotright>\" nullable lang\n  defines brzozowski_closure = brzozowski.closure\n    and check_eqv_brz = brzozowski.check_eqv\n    and reachable_brz = brzozowski.reachable\n    and automaton_brz = brzozowski.automaton\n    and match_brz = brzozowski.match"], ["proof (prove)\ngoal (1 subgoal):\n 1. rexp_DFA ACI_norm\n     (\\<lambda>a r. \\<guillemotleft>deriv a r\\<guillemotright>) nullable\n     lang", "proof (unfold_locales, goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>r. lang \\<guillemotleft>r\\<guillemotright> = lang r\n 2. \\<And>a s.\n       lang \\<guillemotleft>deriv a s\\<guillemotright> = Deriv a (lang s)\n 3. \\<And>s. nullable s = ([] \\<in> lang s)\n 4. \\<And>s.\n       finite\n        {fold (\\<lambda>a r. \\<guillemotleft>deriv a r\\<guillemotright>) w\n          \\<guillemotleft>s\\<guillemotright> |\n         w. True}", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>r. lang \\<guillemotleft>r\\<guillemotright> = lang r\n 2. \\<And>a s.\n       lang \\<guillemotleft>deriv a s\\<guillemotright> = Deriv a (lang s)\n 3. \\<And>s. nullable s = ([] \\<in> lang s)\n 4. \\<And>s.\n       finite\n        {fold (\\<lambda>a r. \\<guillemotleft>deriv a r\\<guillemotright>) w\n          \\<guillemotleft>s\\<guillemotright> |\n         w. True}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lang \\<guillemotleft>r_\\<guillemotright> = lang r_", "by (rule lang_ACI_norm)"], ["proof (state)\nthis:\n  lang \\<guillemotleft>r_\\<guillemotright> = lang r_\n\ngoal (3 subgoals):\n 1. \\<And>a s.\n       lang \\<guillemotleft>deriv a s\\<guillemotright> = Deriv a (lang s)\n 2. \\<And>s. nullable s = ([] \\<in> lang s)\n 3. \\<And>s.\n       finite\n        {fold (\\<lambda>a r. \\<guillemotleft>deriv a r\\<guillemotright>) w\n          \\<guillemotleft>s\\<guillemotright> |\n         w. True}", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a s.\n       lang \\<guillemotleft>deriv a s\\<guillemotright> = Deriv a (lang s)\n 2. \\<And>s. nullable s = ([] \\<in> lang s)\n 3. \\<And>s.\n       finite\n        {fold (\\<lambda>a r. \\<guillemotleft>deriv a r\\<guillemotright>) w\n          \\<guillemotleft>s\\<guillemotright> |\n         w. True}", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>a s.\n       lang \\<guillemotleft>deriv a s\\<guillemotright> = Deriv a (lang s)\n 2. \\<And>s. nullable s = ([] \\<in> lang s)\n 3. \\<And>s.\n       finite\n        {fold (\\<lambda>a r. \\<guillemotleft>deriv a r\\<guillemotright>) w\n          \\<guillemotleft>s\\<guillemotright> |\n         w. True}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lang \\<guillemotleft>deriv a_ s_\\<guillemotright> = Deriv a_ (lang s_)", "by (rule trans[OF lang_ACI_norm lang_deriv])"], ["proof (state)\nthis:\n  lang \\<guillemotleft>deriv a_ s_\\<guillemotright> = Deriv a_ (lang s_)\n\ngoal (2 subgoals):\n 1. \\<And>s. nullable s = ([] \\<in> lang s)\n 2. \\<And>s.\n       finite\n        {fold (\\<lambda>a r. \\<guillemotleft>deriv a r\\<guillemotright>) w\n          \\<guillemotleft>s\\<guillemotright> |\n         w. True}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. nullable s = ([] \\<in> lang s)\n 2. \\<And>s.\n       finite\n        {fold (\\<lambda>a r. \\<guillemotleft>deriv a r\\<guillemotright>) w\n          \\<guillemotleft>s\\<guillemotright> |\n         w. True}", "case 3"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>s. nullable s = ([] \\<in> lang s)\n 2. \\<And>s.\n       finite\n        {fold (\\<lambda>a r. \\<guillemotleft>deriv a r\\<guillemotright>) w\n          \\<guillemotleft>s\\<guillemotright> |\n         w. True}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. nullable s_ = ([] \\<in> lang s_)", "by (rule nullable_iff)"], ["proof (state)\nthis:\n  nullable s_ = ([] \\<in> lang s_)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       finite\n        {fold (\\<lambda>a r. \\<guillemotleft>deriv a r\\<guillemotright>) w\n          \\<guillemotleft>s\\<guillemotright> |\n         w. True}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       finite\n        {fold (\\<lambda>a r. \\<guillemotleft>deriv a r\\<guillemotright>) w\n          \\<guillemotleft>s\\<guillemotright> |\n         w. True}", "case 4"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>s.\n       finite\n        {fold (\\<lambda>a r. \\<guillemotleft>deriv a r\\<guillemotright>) w\n          \\<guillemotleft>s\\<guillemotright> |\n         w. True}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {fold (\\<lambda>a r. \\<guillemotleft>deriv a r\\<guillemotright>) w\n       \\<guillemotleft>s_\\<guillemotright> |\n      w. True}", "by (simp only: ACI_norm_derivs_alt[symmetric] finite_derivs)"], ["proof (state)\nthis:\n  finite\n   {fold (\\<lambda>a r. \\<guillemotleft>deriv a r\\<guillemotright>) w\n     \\<guillemotleft>s_\\<guillemotright> |\n    w. True}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Brzozowski Derivatives Modulo ACI Operating on the Quotient Type\\<close>"], ["", "lemma derivs_alt: \"derivs = fold deriv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derivs = fold deriv", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. derivs x = fold deriv x", "fix w :: \"'a list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. derivs x = fold deriv x", "show \"derivs w = fold deriv w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derivs w = fold deriv w", "by (induct w) auto"], ["proof (state)\nthis:\n  derivs w = fold deriv w\n\ngoal:\nNo subgoals!", "qed"], ["", "functor map_rexp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f g. map_rexp f \\<circ> map_rexp g = map_rexp (f \\<circ> g)) &&&\n    map_rexp id = id", "by (simp_all only: o_def id_def map_map_rexp map_rexp_ident)"], ["", "quotient_type 'a ACI_rexp = \"'a rexp\" / ACI\n  morphisms rep_ACI_rexp ACI_class"], ["proof (prove)\ngoal (1 subgoal):\n 1. equivp ACI", "by (intro equivpI reflpI sympI transpI) (blast intro: ACI_refl ACI_sym ACI_trans)+"], ["", "instantiation ACI_rexp :: (\"{equal, linorder}\") \"{equal, linorder}\"\nbegin"], ["", "lift_definition less_eq_ACI_rexp :: \"'a ACI_rexp \\<Rightarrow> 'a ACI_rexp \\<Rightarrow> bool\" is \"\\<lambda>r s. less_eq \\<guillemotleft>r\\<guillemotright> \\<guillemotleft>s\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rexp1 rexp2 rexp3 rexp4.\n       \\<lbrakk>ACI rexp1 rexp2; ACI rexp3 rexp4\\<rbrakk>\n       \\<Longrightarrow> (\\<guillemotleft>rexp1\\<guillemotright>\n                          \\<le> \\<guillemotleft>rexp3\\<guillemotright>) =\n                         (\\<guillemotleft>rexp2\\<guillemotright>\n                          \\<le> \\<guillemotleft>rexp4\\<guillemotright>)", "by (simp add: ACI_decidable)"], ["", "lift_definition less_ACI_rexp :: \"'a ACI_rexp \\<Rightarrow> 'a ACI_rexp \\<Rightarrow> bool\" is \"\\<lambda>r s. less \\<guillemotleft>r\\<guillemotright> \\<guillemotleft>s\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rexp1 rexp2 rexp3 rexp4.\n       \\<lbrakk>ACI rexp1 rexp2; ACI rexp3 rexp4\\<rbrakk>\n       \\<Longrightarrow> (\\<guillemotleft>rexp1\\<guillemotright>\n                          < \\<guillemotleft>rexp3\\<guillemotright>) =\n                         (\\<guillemotleft>rexp2\\<guillemotright>\n                          < \\<guillemotleft>rexp4\\<guillemotright>)", "by (simp add: ACI_decidable)"], ["", "lift_definition equal_ACI_rexp :: \"'a ACI_rexp \\<Rightarrow> 'a ACI_rexp \\<Rightarrow> bool\" is \"\\<lambda>r s. \\<guillemotleft>r\\<guillemotright> = \\<guillemotleft>s\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rexp1 rexp2 rexp3 rexp4.\n       \\<lbrakk>ACI rexp1 rexp2; ACI rexp3 rexp4\\<rbrakk>\n       \\<Longrightarrow> (\\<guillemotleft>rexp1\\<guillemotright> =\n                          \\<guillemotleft>rexp3\\<guillemotright>) =\n                         (\\<guillemotleft>rexp2\\<guillemotright> =\n                          \\<guillemotleft>rexp4\\<guillemotright>)", "by (simp add: ACI_decidable)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ACI_rexp, equal_class) &&&\n    OFCLASS('a ACI_rexp, linorder_class)", "by intro_classes (transfer, force simp: ACI_decidable)+"], ["", "end"], ["", "lift_definition ACI_deriv :: \"'a :: linorder \\<Rightarrow> 'a ACI_rexp \\<Rightarrow> 'a ACI_rexp\" is deriv"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a rexp1 rexp2.\n       ACI rexp1 rexp2 \\<Longrightarrow> ACI (deriv a rexp1) (deriv a rexp2)", "by (rule ACI_deriv)"], ["", "lift_definition ACI_nullable :: \"'a :: linorder ACI_rexp \\<Rightarrow> bool\" is nullable"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rexp1 rexp2.\n       ACI rexp1 rexp2 \\<Longrightarrow> nullable rexp1 = nullable rexp2", "by (rule ACI_nullable)"], ["", "lift_definition ACI_lang :: \"'a :: linorder ACI_rexp \\<Rightarrow> 'a lang\" is lang"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rexp1 rexp2.\n       ACI rexp1 rexp2 \\<Longrightarrow> lang rexp1 = lang rexp2", "by (rule ACI_lang)"], ["", "lemma [transfer_rule]: \"rel_fun (rel_set (pcr_ACI_rexp (=))) (=) (finite o image ACI_norm) finite\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (rel_set (pcr_ACI_rexp (=))) (=) (finite \\<circ> (`) ACI_norm)\n     finite", "unfolding rel_fun_def rel_set_def cr_ACI_rexp_def ACI_rexp.pcr_cr_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (\\<forall>x\\<in>x. Bex y ((=) (ACI_class x))) \\<and>\n       (\\<forall>y\\<in>y.\n           \\<exists>x\\<in>x. ACI_class x = y) \\<longrightarrow>\n       (finite \\<circ> (`) ACI_norm) x = finite y", "apply (auto simp: elim!: finite_surj[of _ _ ACI_class] finite_surj[of _ _ \"ACI_norm o rep_ACI_rexp\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y xa.\n       \\<lbrakk>\\<forall>x\\<in>x. ACI_class x \\<in> y;\n        \\<forall>y\\<in>y. \\<exists>x\\<in>x. ACI_class x = y;\n        xa \\<in> y\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> ACI_class ` ACI_norm ` x\n 2. \\<And>x y xb.\n       \\<lbrakk>\\<forall>x\\<in>x. ACI_class x \\<in> y;\n        \\<forall>y\\<in>y. \\<exists>x\\<in>x. ACI_class x = y;\n        xb \\<in> x\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>xb\\<guillemotright>\n                         \\<in> (\\<lambda>x.\n                                   \\<guillemotleft>rep_ACI_rexp\n              x\\<guillemotright>) `\n                               y", "apply (metis (hide_lams, no_types) ACI_norm_idem ACI_rexp.abs_eq_iff ACI_decidable imageI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xb.\n       \\<lbrakk>\\<forall>x\\<in>x. ACI_class x \\<in> y;\n        \\<forall>y\\<in>y. \\<exists>x\\<in>x. ACI_class x = y;\n        xb \\<in> x\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>xb\\<guillemotright>\n                         \\<in> (\\<lambda>x.\n                                   \\<guillemotleft>rep_ACI_rexp\n              x\\<guillemotright>) `\n                               y", "apply (rule image_eqI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y xb.\n       \\<lbrakk>\\<forall>x\\<in>x. ACI_class x \\<in> y;\n        \\<forall>y\\<in>y. \\<exists>x\\<in>x. ACI_class x = y;\n        xb \\<in> x\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>xb\\<guillemotright> =\n                         \\<guillemotleft>rep_ACI_rexp\n    (?x28 x y xb)\\<guillemotright>\n 2. \\<And>x y xb.\n       \\<lbrakk>\\<forall>x\\<in>x. ACI_class x \\<in> y;\n        \\<forall>y\\<in>y. \\<exists>x\\<in>x. ACI_class x = y;\n        xb \\<in> x\\<rbrakk>\n       \\<Longrightarrow> ?x28 x y xb \\<in> y", "apply (subst ACI_decidable[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y xb.\n       \\<lbrakk>\\<forall>x\\<in>x. ACI_class x \\<in> y;\n        \\<forall>y\\<in>y. \\<exists>x\\<in>x. ACI_class x = y;\n        xb \\<in> x\\<rbrakk>\n       \\<Longrightarrow> ACI xb\n                          (rep_ACI_rexp\n                            (?x32 x y xb (?xa32 x y xb) (?y32 x y xb) xb))\n 2. \\<And>x y xb.\n       \\<lbrakk>\\<forall>x\\<in>x. ACI_class x \\<in> y;\n        \\<forall>y\\<in>y. \\<exists>x\\<in>x. ACI_class x = y;\n        xb \\<in> x\\<rbrakk>\n       \\<Longrightarrow> ?x32 x y xb (?xa32 x y xb) (?y32 x y xb) xb \\<in> y", "apply (rule ACI_sym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y xb.\n       \\<lbrakk>\\<forall>x\\<in>x. ACI_class x \\<in> y;\n        \\<forall>y\\<in>y. \\<exists>x\\<in>x. ACI_class x = y;\n        xb \\<in> x\\<rbrakk>\n       \\<Longrightarrow> ACI (rep_ACI_rexp\n                               (?x32 x y xb (?xa32 x y xb) (?y32 x y xb)\n                                 xb))\n                          xb\n 2. \\<And>x y xb.\n       \\<lbrakk>\\<forall>x\\<in>x. ACI_class x \\<in> y;\n        \\<forall>y\\<in>y. \\<exists>x\\<in>x. ACI_class x = y;\n        xb \\<in> x\\<rbrakk>\n       \\<Longrightarrow> ?x32 x y xb (?xa32 x y xb) (?y32 x y xb) xb \\<in> y", "apply (rule Quotient_rep_abs[OF Quotient_ACI_rexp, OF ACI_refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xb.\n       \\<lbrakk>\\<forall>x\\<in>x. ACI_class x \\<in> y;\n        \\<forall>y\\<in>y. \\<exists>x\\<in>x. ACI_class x = y;\n        xb \\<in> x\\<rbrakk>\n       \\<Longrightarrow> ACI_class xb \\<in> y", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "global_interpretation brzozowski_quotient: rexp_DFA ACI_class ACI_deriv ACI_nullable ACI_lang\n  defines brzozowski_quotient_closure = brzozowski_quotient.closure\n    and check_eqv_brzq = brzozowski_quotient.check_eqv\n    and reachable_brzq = brzozowski_quotient.reachable\n    and automaton_brzq = brzozowski_quotient.automaton\n    and match_brzq = brzozowski_quotient.match"], ["proof (prove)\ngoal (1 subgoal):\n 1. rexp_DFA ACI_class ACI_deriv ACI_nullable ACI_lang", "proof (unfold_locales, goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>r. ACI_lang (ACI_class r) = lang r\n 2. \\<And>a s. ACI_lang (ACI_deriv a s) = Deriv a (ACI_lang s)\n 3. \\<And>s. ACI_nullable s = ([] \\<in> ACI_lang s)\n 4. \\<And>s. finite {fold ACI_deriv w (ACI_class s) |w. True}", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>r. ACI_lang (ACI_class r) = lang r\n 2. \\<And>a s. ACI_lang (ACI_deriv a s) = Deriv a (ACI_lang s)\n 3. \\<And>s. ACI_nullable s = ([] \\<in> ACI_lang s)\n 4. \\<And>s. finite {fold ACI_deriv w (ACI_class s) |w. True}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ACI_lang (ACI_class r_) = lang r_", "by transfer (rule refl)"], ["proof (state)\nthis:\n  ACI_lang (ACI_class r_) = lang r_\n\ngoal (3 subgoals):\n 1. \\<And>a s. ACI_lang (ACI_deriv a s) = Deriv a (ACI_lang s)\n 2. \\<And>s. ACI_nullable s = ([] \\<in> ACI_lang s)\n 3. \\<And>s. finite {fold ACI_deriv w (ACI_class s) |w. True}", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a s. ACI_lang (ACI_deriv a s) = Deriv a (ACI_lang s)\n 2. \\<And>s. ACI_nullable s = ([] \\<in> ACI_lang s)\n 3. \\<And>s. finite {fold ACI_deriv w (ACI_class s) |w. True}", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>a s. ACI_lang (ACI_deriv a s) = Deriv a (ACI_lang s)\n 2. \\<And>s. ACI_nullable s = ([] \\<in> ACI_lang s)\n 3. \\<And>s. finite {fold ACI_deriv w (ACI_class s) |w. True}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ACI_lang (ACI_deriv a_ s_) = Deriv a_ (ACI_lang s_)", "by transfer (rule lang_deriv)"], ["proof (state)\nthis:\n  ACI_lang (ACI_deriv a_ s_) = Deriv a_ (ACI_lang s_)\n\ngoal (2 subgoals):\n 1. \\<And>s. ACI_nullable s = ([] \\<in> ACI_lang s)\n 2. \\<And>s. finite {fold ACI_deriv w (ACI_class s) |w. True}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. ACI_nullable s = ([] \\<in> ACI_lang s)\n 2. \\<And>s. finite {fold ACI_deriv w (ACI_class s) |w. True}", "case 3"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>s. ACI_nullable s = ([] \\<in> ACI_lang s)\n 2. \\<And>s. finite {fold ACI_deriv w (ACI_class s) |w. True}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ACI_nullable s_ = ([] \\<in> ACI_lang s_)", "by transfer (rule nullable_iff)"], ["proof (state)\nthis:\n  ACI_nullable s_ = ([] \\<in> ACI_lang s_)\n\ngoal (1 subgoal):\n 1. \\<And>s. finite {fold ACI_deriv w (ACI_class s) |w. True}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. finite {fold ACI_deriv w (ACI_class s) |w. True}", "case 4"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>s. finite {fold ACI_deriv w (ACI_class s) |w. True}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {fold ACI_deriv w (ACI_class s_) |w. True}", "by transfer\n    (auto simp: ACI_decidable derivs_alt intro!: finite_subset[OF _ finite_derivs])"], ["proof (state)\nthis:\n  finite {fold ACI_deriv w (ACI_class s_) |w. True}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Brzozowski Derivatives Modulo ACI++ (Only Soundness)\\<close>"], ["", "global_interpretation nderiv: rexp_DA \"\\<lambda>x. norm x\" nderiv nullable lang\n  defines nderiv_closure = nderiv.closure\n    and check_eqv_n = nderiv.check_eqv\n    and reachable_n = nderiv.reachable\n    and automaton_n = nderiv.automaton\n    and match_n = nderiv.match"], ["proof (prove)\ngoal (1 subgoal):\n 1. rexp_DA norm nderiv nullable lang", "proof (unfold_locales, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>r. lang (norm r) = lang r\n 2. \\<And>a s. lang (nderiv a s) = Deriv a (lang s)\n 3. \\<And>s. nullable s = ([] \\<in> lang s)", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>r. lang (norm r) = lang r\n 2. \\<And>a s. lang (nderiv a s) = Deriv a (lang s)\n 3. \\<And>s. nullable s = ([] \\<in> lang s)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lang (norm r_) = lang r_", "by simp"], ["proof (state)\nthis:\n  lang (norm r_) = lang r_\n\ngoal (2 subgoals):\n 1. \\<And>a s. lang (nderiv a s) = Deriv a (lang s)\n 2. \\<And>s. nullable s = ([] \\<in> lang s)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a s. lang (nderiv a s) = Deriv a (lang s)\n 2. \\<And>s. nullable s = ([] \\<in> lang s)", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>a s. lang (nderiv a s) = Deriv a (lang s)\n 2. \\<And>s. nullable s = ([] \\<in> lang s)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lang (nderiv a_ s_) = Deriv a_ (lang s_)", "by (rule lang_nderiv)"], ["proof (state)\nthis:\n  lang (nderiv a_ s_) = Deriv a_ (lang s_)\n\ngoal (1 subgoal):\n 1. \\<And>s. nullable s = ([] \\<in> lang s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. nullable s = ([] \\<in> lang s)", "case 3"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>s. nullable s = ([] \\<in> lang s)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. nullable s_ = ([] \\<in> lang s_)", "by (rule nullable_iff)"], ["proof (state)\nthis:\n  nullable s_ = ([] \\<in> lang s_)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Partial Derivatives\\<close>"], ["", "global_interpretation pderiv: rexp_DFA \"\\<lambda>r. {r}\" pderiv_set \"\\<lambda>P. \\<exists>p\\<in>P. nullable p\" \"\\<lambda>P. \\<Union>(lang ` P)\"\n  defines pderiv_closure = pderiv.closure\n    and check_eqv_p = pderiv.check_eqv\n    and reachable_p = pderiv.reachable\n    and automaton_p = pderiv.automaton\n    and match_p = pderiv.match"], ["proof (prove)\ngoal (1 subgoal):\n 1. rexp_DFA (\\<lambda>r. {r}) pderiv_set\n     (\\<lambda>P. \\<exists>p\\<in>P. nullable p)\n     (\\<lambda>P. \\<Union> (lang ` P))", "proof (unfold_locales, goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>r. \\<Union> (lang ` {r}) = lang r\n 2. \\<And>a s.\n       \\<Union> (lang ` pderiv_set a s) = Deriv a (\\<Union> (lang ` s))\n 3. \\<And>s. (\\<exists>p\\<in>s. nullable p) = ([] \\<in> \\<Union> (lang ` s))\n 4. \\<And>s. finite {fold pderiv_set w {s} |w. True}", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>r. \\<Union> (lang ` {r}) = lang r\n 2. \\<And>a s.\n       \\<Union> (lang ` pderiv_set a s) = Deriv a (\\<Union> (lang ` s))\n 3. \\<And>s. (\\<exists>p\\<in>s. nullable p) = ([] \\<in> \\<Union> (lang ` s))\n 4. \\<And>s. finite {fold pderiv_set w {s} |w. True}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (lang ` {r_}) = lang r_", "by simp"], ["proof (state)\nthis:\n  \\<Union> (lang ` {r_}) = lang r_\n\ngoal (3 subgoals):\n 1. \\<And>a s.\n       \\<Union> (lang ` pderiv_set a s) = Deriv a (\\<Union> (lang ` s))\n 2. \\<And>s. (\\<exists>p\\<in>s. nullable p) = ([] \\<in> \\<Union> (lang ` s))\n 3. \\<And>s. finite {fold pderiv_set w {s} |w. True}", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a s.\n       \\<Union> (lang ` pderiv_set a s) = Deriv a (\\<Union> (lang ` s))\n 2. \\<And>s. (\\<exists>p\\<in>s. nullable p) = ([] \\<in> \\<Union> (lang ` s))\n 3. \\<And>s. finite {fold pderiv_set w {s} |w. True}", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>a s.\n       \\<Union> (lang ` pderiv_set a s) = Deriv a (\\<Union> (lang ` s))\n 2. \\<And>s. (\\<exists>p\\<in>s. nullable p) = ([] \\<in> \\<Union> (lang ` s))\n 3. \\<And>s. finite {fold pderiv_set w {s} |w. True}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (lang ` pderiv_set a_ s_) = Deriv a_ (\\<Union> (lang ` s_))", "by (simp add: Deriv_pderiv)"], ["proof (state)\nthis:\n  \\<Union> (lang ` pderiv_set a_ s_) = Deriv a_ (\\<Union> (lang ` s_))\n\ngoal (2 subgoals):\n 1. \\<And>s. (\\<exists>p\\<in>s. nullable p) = ([] \\<in> \\<Union> (lang ` s))\n 2. \\<And>s. finite {fold pderiv_set w {s} |w. True}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. (\\<exists>p\\<in>s. nullable p) = ([] \\<in> \\<Union> (lang ` s))\n 2. \\<And>s. finite {fold pderiv_set w {s} |w. True}", "case 3"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>s. (\\<exists>p\\<in>s. nullable p) = ([] \\<in> \\<Union> (lang ` s))\n 2. \\<And>s. finite {fold pderiv_set w {s} |w. True}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>p\\<in>s_. nullable p) = ([] \\<in> \\<Union> (lang ` s_))", "by (simp add: nullable_iff)"], ["proof (state)\nthis:\n  (\\<exists>p\\<in>s_. nullable p) = ([] \\<in> \\<Union> (lang ` s_))\n\ngoal (1 subgoal):\n 1. \\<And>s. finite {fold pderiv_set w {s} |w. True}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. finite {fold pderiv_set w {s} |w. True}", "case (4 s)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>s. finite {fold pderiv_set w {s} |w. True}", "note pderivs_lang_def[simp]"], ["proof (state)\nthis:\n  pderivs_lang ?A ?r \\<equiv> \\<Union>x\\<in>?A. pderivs x ?r\n\ngoal (1 subgoal):\n 1. \\<And>s. finite {fold pderiv_set w {s} |w. True}", "{"], ["proof (state)\nthis:\n  pderivs_lang ?A ?r \\<equiv> \\<Union>x\\<in>?A. pderivs x ?r\n\ngoal (1 subgoal):\n 1. \\<And>s. finite {fold pderiv_set w {s} |w. True}", "fix w :: \"'a list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. finite {fold pderiv_set w {s} |w. True}", "have \"fold pderiv_set w = Union o image (pderivs_lang {w})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold pderiv_set w = \\<Union> \\<circ> (`) (pderivs_lang {w})", "by (induct w) auto"], ["proof (state)\nthis:\n  fold pderiv_set w = \\<Union> \\<circ> (`) (pderivs_lang {w})\n\ngoal (1 subgoal):\n 1. \\<And>s. finite {fold pderiv_set w {s} |w. True}", "}"], ["proof (state)\nthis:\n  fold pderiv_set ?w2 = \\<Union> \\<circ> (`) (pderivs_lang {?w2})\n\ngoal (1 subgoal):\n 1. \\<And>s. finite {fold pderiv_set w {s} |w. True}", "hence \"{fold pderiv_set w {s} |w. True} \\<subseteq> Pow (pderivs_lang UNIV s)\""], ["proof (prove)\nusing this:\n  fold pderiv_set ?w2 = \\<Union> \\<circ> (`) (pderivs_lang {?w2})\n\ngoal (1 subgoal):\n 1. {fold pderiv_set w {s} |w. True} \\<subseteq> Pow (pderivs_lang UNIV s)", "by auto"], ["proof (state)\nthis:\n  {fold pderiv_set w {s} |w. True} \\<subseteq> Pow (pderivs_lang UNIV s)\n\ngoal (1 subgoal):\n 1. \\<And>s. finite {fold pderiv_set w {s} |w. True}", "then"], ["proof (chain)\npicking this:\n  {fold pderiv_set w {s} |w. True} \\<subseteq> Pow (pderivs_lang UNIV s)", "show ?case"], ["proof (prove)\nusing this:\n  {fold pderiv_set w {s} |w. True} \\<subseteq> Pow (pderivs_lang UNIV s)\n\ngoal (1 subgoal):\n 1. finite {fold pderiv_set w {s} |w. True}", "by (rule finite_subset) (auto simp only: finite_pderivs_lang)"], ["proof (state)\nthis:\n  finite {fold pderiv_set w {s} |w. True}\n\ngoal:\nNo subgoals!", "qed"], ["", "global_interpretation pnderiv: rexp_DFA \"\\<lambda>r. r\" pnderiv nullable lang\n  defines pnderiv_closure = pnderiv.closure\n    and check_eqv_pn = pnderiv.check_eqv\n    and reachable_pn = pnderiv.reachable\n    and automaton_pn = pnderiv.automaton\n    and match_pn = pnderiv.match"], ["proof (prove)\ngoal (1 subgoal):\n 1. rexp_DFA (\\<lambda>r. r) pnderiv nullable lang", "proof (unfold_locales, goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>r. lang r = lang r\n 2. \\<And>a s. lang (pnderiv a s) = Deriv a (lang s)\n 3. \\<And>s. nullable s = ([] \\<in> lang s)\n 4. \\<And>s. finite {fold pnderiv w s |w. True}", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>r. lang r = lang r\n 2. \\<And>a s. lang (pnderiv a s) = Deriv a (lang s)\n 3. \\<And>s. nullable s = ([] \\<in> lang s)\n 4. \\<And>s. finite {fold pnderiv w s |w. True}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lang r_ = lang r_", "by simp"], ["proof (state)\nthis:\n  lang r_ = lang r_\n\ngoal (3 subgoals):\n 1. \\<And>a s. lang (pnderiv a s) = Deriv a (lang s)\n 2. \\<And>s. nullable s = ([] \\<in> lang s)\n 3. \\<And>s. finite {fold pnderiv w s |w. True}", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a s. lang (pnderiv a s) = Deriv a (lang s)\n 2. \\<And>s. nullable s = ([] \\<in> lang s)\n 3. \\<And>s. finite {fold pnderiv w s |w. True}", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>a s. lang (pnderiv a s) = Deriv a (lang s)\n 2. \\<And>s. nullable s = ([] \\<in> lang s)\n 3. \\<And>s. finite {fold pnderiv w s |w. True}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lang (pnderiv a_ s_) = Deriv a_ (lang s_)", "by (simp add: pnorm_def pset_deriv Deriv_pderiv pnderiv_alt)"], ["proof (state)\nthis:\n  lang (pnderiv a_ s_) = Deriv a_ (lang s_)\n\ngoal (2 subgoals):\n 1. \\<And>s. nullable s = ([] \\<in> lang s)\n 2. \\<And>s. finite {fold pnderiv w s |w. True}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. nullable s = ([] \\<in> lang s)\n 2. \\<And>s. finite {fold pnderiv w s |w. True}", "case 3"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>s. nullable s = ([] \\<in> lang s)\n 2. \\<And>s. finite {fold pnderiv w s |w. True}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. nullable s_ = ([] \\<in> lang s_)", "by (simp add: nullable_iff)"], ["proof (state)\nthis:\n  nullable s_ = ([] \\<in> lang s_)\n\ngoal (1 subgoal):\n 1. \\<And>s. finite {fold pnderiv w s |w. True}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. finite {fold pnderiv w s |w. True}", "case (4 s)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>s. finite {fold pnderiv w s |w. True}", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {fold pnderiv w s |w. True}", "unfolding pnderiv_alt[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {fold (\\<lambda>a r. pnorm (deriv a r)) w s |w. True}", "by (rule finite_surj[OF pderiv.fin, of _ \"flatten PLUS\" s]) (auto simp: fold_pnorm_deriv)"], ["proof (state)\nthis:\n  finite {fold pnderiv w s |w. True}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Languages as States\\<close>"], ["", "text \\<open>Not executable but still instructive.\\<close>"], ["", "lemma Derivs_alt_def: \"Derivs w L = fold Deriv w L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Derivs w L = fold Deriv w L", "by (induct w arbitrary: L) simp_all"], ["", "interpretation language: rexp_DFA lang Deriv \"\\<lambda>L. [] \\<in> L\" id"], ["proof (prove)\ngoal (1 subgoal):\n 1. rexp_DFA lang Deriv ((\\<in>) []) id", "proof (unfold_locales, goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>r. id (lang r) = lang r\n 2. \\<And>a s. id (Deriv a s) = Deriv a (id s)\n 3. \\<And>s. ([] \\<in> s) = ([] \\<in> id s)\n 4. \\<And>s. finite {fold Deriv w (lang s) |w. True}", "case (4 s)"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>r. id (lang r) = lang r\n 2. \\<And>a s. id (Deriv a s) = Deriv a (id s)\n 3. \\<And>s. ([] \\<in> s) = ([] \\<in> id s)\n 4. \\<And>s. finite {fold Deriv w (lang s) |w. True}", "have \"{fold Deriv w (lang s) |w. True} \\<subseteq> (\\<lambda>X. \\<Union>(lang ` X)) ` Pow (pderivs_lang UNIV s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {fold Deriv w (lang s) |w. True}\n    \\<subseteq> (\\<lambda>X. \\<Union> (lang ` X)) `\n                Pow (pderivs_lang UNIV s)", "by (auto simp: sym[OF Derivs_alt_def] Derivs_pderivs pderivs_lang_def)"], ["proof (state)\nthis:\n  {fold Deriv w (lang s) |w. True}\n  \\<subseteq> (\\<lambda>X. \\<Union> (lang ` X)) ` Pow (pderivs_lang UNIV s)\n\ngoal (4 subgoals):\n 1. \\<And>r. id (lang r) = lang r\n 2. \\<And>a s. id (Deriv a s) = Deriv a (id s)\n 3. \\<And>s. ([] \\<in> s) = ([] \\<in> id s)\n 4. \\<And>s. finite {fold Deriv w (lang s) |w. True}", "then"], ["proof (chain)\npicking this:\n  {fold Deriv w (lang s) |w. True}\n  \\<subseteq> (\\<lambda>X. \\<Union> (lang ` X)) ` Pow (pderivs_lang UNIV s)", "show ?case"], ["proof (prove)\nusing this:\n  {fold Deriv w (lang s) |w. True}\n  \\<subseteq> (\\<lambda>X. \\<Union> (lang ` X)) ` Pow (pderivs_lang UNIV s)\n\ngoal (1 subgoal):\n 1. finite {fold Deriv w (lang s) |w. True}", "by (rule finite_surj[OF iffD2[OF finite_Pow_iff finite_pderivs_lang_UNIV]])"], ["proof (state)\nthis:\n  finite {fold Deriv w (lang s) |w. True}\n\ngoal (3 subgoals):\n 1. \\<And>r. id (lang r) = lang r\n 2. \\<And>a s. id (Deriv a s) = Deriv a (id s)\n 3. \\<And>s. ([] \\<in> s) = ([] \\<in> id s)", "qed simp_all"], ["", "definition str_eq :: \"'a lang => ('a list \\<times> 'a list) set\" (\"\\<approx>_\" [100] 100)\nwhere \"\\<approx>A \\<equiv> {(x, y).  (\\<forall>z. x @ z \\<in> A \\<longleftrightarrow> y @ z \\<in> A)}\""], ["", "lemma str_eq_alt: \"\\<approx>A = {(x, y). fold Deriv x A = fold Deriv y A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<approx>A = {(x, y). fold Deriv x A = fold Deriv y A}", "unfolding str_eq_def set_eq_iff in_fold_Deriv"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (x \\<in> {(x, y). \\<forall>z. (x @ z \\<in> A) = (y @ z \\<in> A)}) =\n       (x \\<in> {(x, y). \\<forall>xa. (x @ xa \\<in> A) = (y @ xa \\<in> A)})", "by simp"], ["", "lemma Myhill_Nerode2: \"finite (UNIV // \\<approx>lang r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (UNIV // \\<approx>lang r)", "unfolding str_eq_alt quotient_def Image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (\\<Union>x.\n         {{y. \\<exists>x\\<in>{x}.\n                 (x, y)\n                 \\<in> {(x, y).\n                        fold Deriv x (lang r) = fold Deriv y (lang r)}}})", "by (rule finite_surj[OF language.fin, of _ \"\\<lambda>X. {y. X = fold Deriv y (lang r)}\" r]) auto"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}