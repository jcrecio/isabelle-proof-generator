{"file_name": "/home/qj213/afp-2021-10-22/thys/Regex_Equivalence/Position_Autos.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Regex_Equivalence", "problem_names": ["lemma finite_mrexps[simp]: \"finite (mrexps r)\"", "lemma strip_mrexps: \"strip ` mrexps r = {r}\"", "lemma read_mrexps[simp]: \"r \\<in> mrexps s \\<Longrightarrow> read a r \\<in> mrexps s\"", "lemma follow_mrexps[simp]: \"r \\<in> mrexps s \\<Longrightarrow> follow b r \\<in> mrexps s\"", "lemma strip_read[simp]: \"strip (read a r) = strip r\"", "lemma Nil_notin_Lm[simp]: \"[] \\<notin> Lm r\"", "lemma Nil_in_lang_strip[simp]: \"[] \\<in> lang(r) \\<longleftrightarrow> [] \\<in> lang(strip r)\"", "lemma strip_follow[simp]: \"strip(follow m r) = strip r\"", "lemma conc_lemma: \"[] \\<notin> A \\<Longrightarrow> {w : A @@ B. w \\<noteq> [] \\<and> P(hd w)} = {w : A. w \\<noteq> [] \\<and> P(hd w)} @@ B\"", "lemma Lm_read: \"Lm (read a r) = {w : Lm r. w \\<noteq> [] \\<and> hd w = a}\"", "lemma tl_conc[simp]: \"[] \\<notin> A \\<Longrightarrow>tl ` (A @@ B) = tl ` A @@ B\"", "lemma Nil_in_tl_Lm_if_final[simp]: \"final r \\<Longrightarrow> [] : tl ` Lm r\"", "lemma Nil_notin_tl_if_not_final: \"\\<not> final r \\<Longrightarrow> [] \\<notin> tl ` Lm r\"", "lemma Lm_follow: \"Lm (follow m r) = tl ` Lm r \\<union> (if m then lang(strip r) else {}) - {[]}\"", "lemma empty_mrexp_mrexps[simp]: \"empty_mrexp r \\<in> mrexps r\"", "lemma nullable_empty_mrexp[simp]: \"nullable (empty_mrexp r) = nullable r\"", "lemma init_b_mrexps[simp]: \"init_b r \\<in> mrexps r \\<times> UNIV\"", "lemma delta_b_mrexps[simp]: \"rb \\<in> mrexps r \\<times> UNIV \\<Longrightarrow> delta_b a rb \\<in> mrexps r \\<times> UNIV\"", "lemma fold_delta_b_init_b_mrexps[simp]: \"fold delta_b w (init_b s) \\<in> mrexps s \\<times> UNIV\"", "lemma Lm_empty: \"Lm (empty_mrexp r) = {}\"", "lemma final_read_Lm: \"final(read a r) \\<longleftrightarrow> [a] \\<in> Lm r\"", "lemma init_a_mrexps[simp]: \"init_a r \\<in> UNIV \\<times> mrexps r\"", "lemma delta_a_mrexps[simp]: \"br \\<in> UNIV \\<times> mrexps r \\<Longrightarrow> delta_a a br \\<in> UNIV \\<times> mrexps r\"", "lemma fold_delta_a_init_a_mrexps[simp]: \"fold delta_a w (init_a s) \\<in> UNIV \\<times> mrexps s\"", "lemma nonfinal_empty_mrexp: \"\\<not> final (empty_mrexp r)\"", "lemma Cons_eq_tl_iff[simp]: \"x # xs = tl ys \\<longleftrightarrow> (\\<exists>y. ys = y # x # xs)\"", "lemma tl_eq_Cons_iff[simp]: \"tl ys = x # xs \\<longleftrightarrow> (\\<exists>y. ys = y # x # xs)\"", "lemma hom_delta: \"hom_ab (delta_a x br) = delta_b x (hom_ab br)\"", "lemma hom_deltas: \"hom_ab (fold delta_a w br) = fold delta_b w (hom_ab br)\"", "lemma hom_init: \"hom_ab (init_a r) = init_b r\"", "lemma reachable_ab: \"reachable_b as r = hom_ab ` reachable_a as r\"", "theorem card_reachable_ab: \"card (reachable_b as r) \\<le> card (reachable_a as r)\"", "lemma shift_read_follow: \"shift m r x = read x (follow m r)\"", "lemma nullable_read[simp]: \"nullable (read c r) = nullable r\"", "lemma final_read_final1: \"final (read c r) = final1 r c\"", "lemma move_follow_read: \"move c r m = follow m (read c r)\""], "translations": [["", "lemma finite_mrexps[simp]: \"finite (mrexps r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (mrexps r)", "by (induction r) auto"], ["", "lemma strip_mrexps: \"strip ` mrexps r = {r}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip ` mrexps r = {r}", "by (induction r) (auto simp: set_eq_subset subset_iff image_iff)"], ["", "fun Lm :: \"'a mrexp \\<Rightarrow> 'a lang\" where\n\"Lm Zero = {}\" |\n\"Lm One = {}\" |\n\"Lm (Atom(m,a)) = (if m then {[a]} else {})\" |\n\"Lm (Plus r s) = Lm r \\<union> Lm s\" |\n\"Lm (Times r s) = Lm r @@ lang(strip s) \\<union> Lm s\" |\n\"Lm (Star r) = Lm r @@ star(lang(strip r))\""], ["", "fun final :: \"'a mrexp \\<Rightarrow> bool\" where\n\"final Zero = False\" |\n\"final One = False\" |\n\"final (Atom(m,a)) = m\" |\n\"final (Plus r s) = (final r \\<or> final s)\" |\n\"final (Times r s) = (final s \\<or> nullable s \\<and> final r)\" |\n\"final (Star r) = final r\""], ["", "abbreviation read :: \"'a \\<Rightarrow> 'a mrexp \\<Rightarrow> 'a mrexp\" where\n\"read a \\<equiv> map_rexp (\\<lambda>(m,x). (m \\<and> a=x, x))\""], ["", "lemma read_mrexps[simp]: \"r \\<in> mrexps s \\<Longrightarrow> read a r \\<in> mrexps s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<in> mrexps s \\<Longrightarrow> read a r \\<in> mrexps s", "by (induction s arbitrary: a r) (auto simp: image_iff)"], ["", "fun follow :: \"bool \\<Rightarrow> 'a mrexp \\<Rightarrow> 'a mrexp\" where\n\"follow m Zero = Zero\" |\n\"follow m One = One\" |\n\"follow m (Atom(_,a)) = Atom(m,a)\" |\n\"follow m (Plus r s) = Plus (follow m r) (follow m s)\" |\n\"follow m (Times r s) =\n  Times (follow m r) (follow (final r \\<or> m \\<and> nullable r) s)\" |\n\"follow m (Star r) = Star(follow (final r \\<or> m) r)\""], ["", "lemma follow_mrexps[simp]: \"r \\<in> mrexps s \\<Longrightarrow> follow b r \\<in> mrexps s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<in> mrexps s \\<Longrightarrow> follow b r \\<in> mrexps s", "by (induction s arbitrary: b r) (auto simp: image_iff)"], ["", "lemma strip_read[simp]: \"strip (read a r) = strip r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip (read a r) = strip r", "by (simp add: map_map_rexp split_def)"], ["", "lemma Nil_notin_Lm[simp]: \"[] \\<notin> Lm r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<notin> Lm r", "by (induction r) (auto split: if_splits)"], ["", "lemma Nil_in_lang_strip[simp]: \"[] \\<in> lang(r) \\<longleftrightarrow> [] \\<in> lang(strip r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([] \\<in> lang r) = ([] \\<in> lang (strip r))", "by (induction r) auto"], ["", "lemma strip_follow[simp]: \"strip(follow m r) = strip r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip (follow m r) = strip r", "by (induction r arbitrary: m) (auto split: if_splits)"], ["", "lemma conc_lemma: \"[] \\<notin> A \\<Longrightarrow> {w : A @@ B. w \\<noteq> [] \\<and> P(hd w)} = {w : A. w \\<noteq> [] \\<and> P(hd w)} @@ B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<notin> A \\<Longrightarrow>\n    {w \\<in> A @@ B. w \\<noteq> [] \\<and> P (hd w)} =\n    {w \\<in> A. w \\<noteq> [] \\<and> P (hd w)} @@ B", "unfolding conc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<notin> A \\<Longrightarrow>\n    {w \\<in> {xs @ ys |xs ys. xs \\<in> A \\<and> ys \\<in> B}.\n     w \\<noteq> [] \\<and> P (hd w)} =\n    {xs @ ys |xs ys.\n     xs \\<in> {w \\<in> A. w \\<noteq> [] \\<and> P (hd w)} \\<and> ys \\<in> B}", "by auto (metis hd_append2)+"], ["", "lemma Lm_read: \"Lm (read a r) = {w : Lm r. w \\<noteq> [] \\<and> hd w = a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lm (read a r) = {w \\<in> Lm r. w \\<noteq> [] \\<and> hd w = a}", "proof (induction r)"], ["proof (state)\ngoal (6 subgoals):\n 1. Lm (read a Zero) = {w \\<in> Lm Zero. w \\<noteq> [] \\<and> hd w = a}\n 2. Lm (read a One) = {w \\<in> Lm One. w \\<noteq> [] \\<and> hd w = a}\n 3. \\<And>x.\n       Lm (read a (Atom x)) =\n       {w \\<in> Lm (Atom x). w \\<noteq> [] \\<and> hd w = a}\n 4. \\<And>r1 r2.\n       \\<lbrakk>Lm (read a r1) =\n                {w \\<in> Lm r1. w \\<noteq> [] \\<and> hd w = a};\n        Lm (read a r2) =\n        {w \\<in> Lm r2. w \\<noteq> [] \\<and> hd w = a}\\<rbrakk>\n       \\<Longrightarrow> Lm (read a (Plus r1 r2)) =\n                         {w \\<in> Lm (Plus r1 r2).\n                          w \\<noteq> [] \\<and> hd w = a}\n 5. \\<And>r1 r2.\n       \\<lbrakk>Lm (read a r1) =\n                {w \\<in> Lm r1. w \\<noteq> [] \\<and> hd w = a};\n        Lm (read a r2) =\n        {w \\<in> Lm r2. w \\<noteq> [] \\<and> hd w = a}\\<rbrakk>\n       \\<Longrightarrow> Lm (read a (Times r1 r2)) =\n                         {w \\<in> Lm (Times r1 r2).\n                          w \\<noteq> [] \\<and> hd w = a}\n 6. \\<And>r.\n       Lm (read a r) =\n       {w \\<in> Lm r. w \\<noteq> [] \\<and> hd w = a} \\<Longrightarrow>\n       Lm (read a (Star r)) =\n       {w \\<in> Lm (Star r). w \\<noteq> [] \\<and> hd w = a}", "case (Times r1 r2)"], ["proof (state)\nthis:\n  Lm (read a r1) = {w \\<in> Lm r1. w \\<noteq> [] \\<and> hd w = a}\n  Lm (read a r2) = {w \\<in> Lm r2. w \\<noteq> [] \\<and> hd w = a}\n\ngoal (6 subgoals):\n 1. Lm (read a Zero) = {w \\<in> Lm Zero. w \\<noteq> [] \\<and> hd w = a}\n 2. Lm (read a One) = {w \\<in> Lm One. w \\<noteq> [] \\<and> hd w = a}\n 3. \\<And>x.\n       Lm (read a (Atom x)) =\n       {w \\<in> Lm (Atom x). w \\<noteq> [] \\<and> hd w = a}\n 4. \\<And>r1 r2.\n       \\<lbrakk>Lm (read a r1) =\n                {w \\<in> Lm r1. w \\<noteq> [] \\<and> hd w = a};\n        Lm (read a r2) =\n        {w \\<in> Lm r2. w \\<noteq> [] \\<and> hd w = a}\\<rbrakk>\n       \\<Longrightarrow> Lm (read a (Plus r1 r2)) =\n                         {w \\<in> Lm (Plus r1 r2).\n                          w \\<noteq> [] \\<and> hd w = a}\n 5. \\<And>r1 r2.\n       \\<lbrakk>Lm (read a r1) =\n                {w \\<in> Lm r1. w \\<noteq> [] \\<and> hd w = a};\n        Lm (read a r2) =\n        {w \\<in> Lm r2. w \\<noteq> [] \\<and> hd w = a}\\<rbrakk>\n       \\<Longrightarrow> Lm (read a (Times r1 r2)) =\n                         {w \\<in> Lm (Times r1 r2).\n                          w \\<noteq> [] \\<and> hd w = a}\n 6. \\<And>r.\n       Lm (read a r) =\n       {w \\<in> Lm r. w \\<noteq> [] \\<and> hd w = a} \\<Longrightarrow>\n       Lm (read a (Star r)) =\n       {w \\<in> Lm (Star r). w \\<noteq> [] \\<and> hd w = a}", "thus ?case"], ["proof (prove)\nusing this:\n  Lm (read a r1) = {w \\<in> Lm r1. w \\<noteq> [] \\<and> hd w = a}\n  Lm (read a r2) = {w \\<in> Lm r2. w \\<noteq> [] \\<and> hd w = a}\n\ngoal (1 subgoal):\n 1. Lm (read a (Times r1 r2)) =\n    {w \\<in> Lm (Times r1 r2). w \\<noteq> [] \\<and> hd w = a}", "using conc_lemma[OF Nil_notin_Lm, where P = \"\\<lambda>x. x=a\" and r1 = r1]"], ["proof (prove)\nusing this:\n  Lm (read a r1) = {w \\<in> Lm r1. w \\<noteq> [] \\<and> hd w = a}\n  Lm (read a r2) = {w \\<in> Lm r2. w \\<noteq> [] \\<and> hd w = a}\n  {w \\<in> Lm r1 @@ ?B. w \\<noteq> [] \\<and> hd w = a} =\n  {w \\<in> Lm r1. w \\<noteq> [] \\<and> hd w = a} @@ ?B\n\ngoal (1 subgoal):\n 1. Lm (read a (Times r1 r2)) =\n    {w \\<in> Lm (Times r1 r2). w \\<noteq> [] \\<and> hd w = a}", "by auto"], ["proof (state)\nthis:\n  Lm (read a (Times r1 r2)) =\n  {w \\<in> Lm (Times r1 r2). w \\<noteq> [] \\<and> hd w = a}\n\ngoal (5 subgoals):\n 1. Lm (read a Zero) = {w \\<in> Lm Zero. w \\<noteq> [] \\<and> hd w = a}\n 2. Lm (read a One) = {w \\<in> Lm One. w \\<noteq> [] \\<and> hd w = a}\n 3. \\<And>x.\n       Lm (read a (Atom x)) =\n       {w \\<in> Lm (Atom x). w \\<noteq> [] \\<and> hd w = a}\n 4. \\<And>r1 r2.\n       \\<lbrakk>Lm (read a r1) =\n                {w \\<in> Lm r1. w \\<noteq> [] \\<and> hd w = a};\n        Lm (read a r2) =\n        {w \\<in> Lm r2. w \\<noteq> [] \\<and> hd w = a}\\<rbrakk>\n       \\<Longrightarrow> Lm (read a (Plus r1 r2)) =\n                         {w \\<in> Lm (Plus r1 r2).\n                          w \\<noteq> [] \\<and> hd w = a}\n 5. \\<And>r.\n       Lm (read a r) =\n       {w \\<in> Lm r. w \\<noteq> [] \\<and> hd w = a} \\<Longrightarrow>\n       Lm (read a (Star r)) =\n       {w \\<in> Lm (Star r). w \\<noteq> [] \\<and> hd w = a}", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. Lm (read a Zero) = {w \\<in> Lm Zero. w \\<noteq> [] \\<and> hd w = a}\n 2. Lm (read a One) = {w \\<in> Lm One. w \\<noteq> [] \\<and> hd w = a}\n 3. \\<And>x.\n       Lm (read a (Atom x)) =\n       {w \\<in> Lm (Atom x). w \\<noteq> [] \\<and> hd w = a}\n 4. \\<And>r1 r2.\n       \\<lbrakk>Lm (read a r1) =\n                {w \\<in> Lm r1. w \\<noteq> [] \\<and> hd w = a};\n        Lm (read a r2) =\n        {w \\<in> Lm r2. w \\<noteq> [] \\<and> hd w = a}\\<rbrakk>\n       \\<Longrightarrow> Lm (read a (Plus r1 r2)) =\n                         {w \\<in> Lm (Plus r1 r2).\n                          w \\<noteq> [] \\<and> hd w = a}\n 5. \\<And>r.\n       Lm (read a r) =\n       {w \\<in> Lm r. w \\<noteq> [] \\<and> hd w = a} \\<Longrightarrow>\n       Lm (read a (Star r)) =\n       {w \\<in> Lm (Star r). w \\<noteq> [] \\<and> hd w = a}", "case Star"], ["proof (state)\nthis:\n  Lm (read a r_) = {w \\<in> Lm r_. w \\<noteq> [] \\<and> hd w = a}\n\ngoal (5 subgoals):\n 1. Lm (read a Zero) = {w \\<in> Lm Zero. w \\<noteq> [] \\<and> hd w = a}\n 2. Lm (read a One) = {w \\<in> Lm One. w \\<noteq> [] \\<and> hd w = a}\n 3. \\<And>x.\n       Lm (read a (Atom x)) =\n       {w \\<in> Lm (Atom x). w \\<noteq> [] \\<and> hd w = a}\n 4. \\<And>r1 r2.\n       \\<lbrakk>Lm (read a r1) =\n                {w \\<in> Lm r1. w \\<noteq> [] \\<and> hd w = a};\n        Lm (read a r2) =\n        {w \\<in> Lm r2. w \\<noteq> [] \\<and> hd w = a}\\<rbrakk>\n       \\<Longrightarrow> Lm (read a (Plus r1 r2)) =\n                         {w \\<in> Lm (Plus r1 r2).\n                          w \\<noteq> [] \\<and> hd w = a}\n 5. \\<And>r.\n       Lm (read a r) =\n       {w \\<in> Lm r. w \\<noteq> [] \\<and> hd w = a} \\<Longrightarrow>\n       Lm (read a (Star r)) =\n       {w \\<in> Lm (Star r). w \\<noteq> [] \\<and> hd w = a}", "thus ?case"], ["proof (prove)\nusing this:\n  Lm (read a r_) = {w \\<in> Lm r_. w \\<noteq> [] \\<and> hd w = a}\n\ngoal (1 subgoal):\n 1. Lm (read a (Star r_)) =\n    {w \\<in> Lm (Star r_). w \\<noteq> [] \\<and> hd w = a}", "using conc_lemma[OF Nil_notin_Lm, where P = \"\\<lambda>x. x=a\"]"], ["proof (prove)\nusing this:\n  Lm (read a r_) = {w \\<in> Lm r_. w \\<noteq> [] \\<and> hd w = a}\n  {w \\<in> Lm ?r1 @@ ?B. w \\<noteq> [] \\<and> hd w = a} =\n  {w \\<in> Lm ?r1. w \\<noteq> [] \\<and> hd w = a} @@ ?B\n\ngoal (1 subgoal):\n 1. Lm (read a (Star r_)) =\n    {w \\<in> Lm (Star r_). w \\<noteq> [] \\<and> hd w = a}", "by simp"], ["proof (state)\nthis:\n  Lm (read a (Star r_)) =\n  {w \\<in> Lm (Star r_). w \\<noteq> [] \\<and> hd w = a}\n\ngoal (4 subgoals):\n 1. Lm (read a Zero) = {w \\<in> Lm Zero. w \\<noteq> [] \\<and> hd w = a}\n 2. Lm (read a One) = {w \\<in> Lm One. w \\<noteq> [] \\<and> hd w = a}\n 3. \\<And>x.\n       Lm (read a (Atom x)) =\n       {w \\<in> Lm (Atom x). w \\<noteq> [] \\<and> hd w = a}\n 4. \\<And>r1 r2.\n       \\<lbrakk>Lm (read a r1) =\n                {w \\<in> Lm r1. w \\<noteq> [] \\<and> hd w = a};\n        Lm (read a r2) =\n        {w \\<in> Lm r2. w \\<noteq> [] \\<and> hd w = a}\\<rbrakk>\n       \\<Longrightarrow> Lm (read a (Plus r1 r2)) =\n                         {w \\<in> Lm (Plus r1 r2).\n                          w \\<noteq> [] \\<and> hd w = a}", "qed (auto split: if_splits)"], ["", "lemma tl_conc[simp]: \"[] \\<notin> A \\<Longrightarrow>tl ` (A @@ B) = tl ` A @@ B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<notin> A \\<Longrightarrow> tl ` (A @@ B) = tl ` A @@ B", "by (fastforce simp: image_def Bex_def tl_append split: list.split)"], ["", "lemma Nil_in_tl_Lm_if_final[simp]: \"final r \\<Longrightarrow> [] : tl ` Lm r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. final r \\<Longrightarrow> [] \\<in> tl ` Lm r", "by (induction r) (auto simp: nullable_iff image_Un)"], ["", "lemma Nil_notin_tl_if_not_final: \"\\<not> final r \\<Longrightarrow> [] \\<notin> tl ` Lm r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> final r \\<Longrightarrow> [] \\<notin> tl ` Lm r", "by (induction r) (auto simp: nullable_iff Nil_tl singleton_in_conc intro!: image_eqI[rotated])"], ["", "lemma Lm_follow: \"Lm (follow m r) = tl ` Lm r \\<union> (if m then lang(strip r) else {}) - {[]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lm (follow m r) =\n    tl ` Lm r \\<union> (if m then lang (strip r) else {}) - {[]}", "proof (induction r arbitrary: m)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>m.\n       Lm (follow m Zero) =\n       tl ` Lm Zero \\<union> (if m then lang (strip Zero) else {}) - {[]}\n 2. \\<And>m.\n       Lm (follow m One) =\n       tl ` Lm One \\<union> (if m then lang (strip One) else {}) - {[]}\n 3. \\<And>x m.\n       Lm (follow m (Atom x)) =\n       tl ` Lm (Atom x) \\<union> (if m then lang (strip (Atom x)) else {}) -\n       {[]}\n 4. \\<And>r1 r2 m.\n       \\<lbrakk>\\<And>m.\n                   Lm (follow m r1) =\n                   tl ` Lm r1 \\<union> (if m then lang (strip r1) else {}) -\n                   {[]};\n        \\<And>m.\n           Lm (follow m r2) =\n           tl ` Lm r2 \\<union> (if m then lang (strip r2) else {}) -\n           {[]}\\<rbrakk>\n       \\<Longrightarrow> Lm (follow m (Plus r1 r2)) =\n                         tl ` Lm (Plus r1 r2) \\<union>\n                         (if m then lang (strip (Plus r1 r2)) else {}) -\n                         {[]}\n 5. \\<And>r1 r2 m.\n       \\<lbrakk>\\<And>m.\n                   Lm (follow m r1) =\n                   tl ` Lm r1 \\<union> (if m then lang (strip r1) else {}) -\n                   {[]};\n        \\<And>m.\n           Lm (follow m r2) =\n           tl ` Lm r2 \\<union> (if m then lang (strip r2) else {}) -\n           {[]}\\<rbrakk>\n       \\<Longrightarrow> Lm (follow m (Times r1 r2)) =\n                         tl ` Lm (Times r1 r2) \\<union>\n                         (if m then lang (strip (Times r1 r2)) else {}) -\n                         {[]}\n 6. \\<And>r m.\n       (\\<And>m.\n           Lm (follow m r) =\n           tl ` Lm r \\<union> (if m then lang (strip r) else {}) -\n           {[]}) \\<Longrightarrow>\n       Lm (follow m (Star r)) =\n       tl ` Lm (Star r) \\<union> (if m then lang (strip (Star r)) else {}) -\n       {[]}", "case (Atom mb)"], ["proof (state)\nthis:\n  \n\ngoal (6 subgoals):\n 1. \\<And>m.\n       Lm (follow m Zero) =\n       tl ` Lm Zero \\<union> (if m then lang (strip Zero) else {}) - {[]}\n 2. \\<And>m.\n       Lm (follow m One) =\n       tl ` Lm One \\<union> (if m then lang (strip One) else {}) - {[]}\n 3. \\<And>x m.\n       Lm (follow m (Atom x)) =\n       tl ` Lm (Atom x) \\<union> (if m then lang (strip (Atom x)) else {}) -\n       {[]}\n 4. \\<And>r1 r2 m.\n       \\<lbrakk>\\<And>m.\n                   Lm (follow m r1) =\n                   tl ` Lm r1 \\<union> (if m then lang (strip r1) else {}) -\n                   {[]};\n        \\<And>m.\n           Lm (follow m r2) =\n           tl ` Lm r2 \\<union> (if m then lang (strip r2) else {}) -\n           {[]}\\<rbrakk>\n       \\<Longrightarrow> Lm (follow m (Plus r1 r2)) =\n                         tl ` Lm (Plus r1 r2) \\<union>\n                         (if m then lang (strip (Plus r1 r2)) else {}) -\n                         {[]}\n 5. \\<And>r1 r2 m.\n       \\<lbrakk>\\<And>m.\n                   Lm (follow m r1) =\n                   tl ` Lm r1 \\<union> (if m then lang (strip r1) else {}) -\n                   {[]};\n        \\<And>m.\n           Lm (follow m r2) =\n           tl ` Lm r2 \\<union> (if m then lang (strip r2) else {}) -\n           {[]}\\<rbrakk>\n       \\<Longrightarrow> Lm (follow m (Times r1 r2)) =\n                         tl ` Lm (Times r1 r2) \\<union>\n                         (if m then lang (strip (Times r1 r2)) else {}) -\n                         {[]}\n 6. \\<And>r m.\n       (\\<And>m.\n           Lm (follow m r) =\n           tl ` Lm r \\<union> (if m then lang (strip r) else {}) -\n           {[]}) \\<Longrightarrow>\n       Lm (follow m (Star r)) =\n       tl ` Lm (Star r) \\<union> (if m then lang (strip (Star r)) else {}) -\n       {[]}", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Lm (follow m (Atom mb)) =\n    tl ` Lm (Atom mb) \\<union> (if m then lang (strip (Atom mb)) else {}) -\n    {[]}", "by (cases mb) auto"], ["proof (state)\nthis:\n  Lm (follow m (Atom mb)) =\n  tl ` Lm (Atom mb) \\<union> (if m then lang (strip (Atom mb)) else {}) -\n  {[]}\n\ngoal (5 subgoals):\n 1. \\<And>m.\n       Lm (follow m Zero) =\n       tl ` Lm Zero \\<union> (if m then lang (strip Zero) else {}) - {[]}\n 2. \\<And>m.\n       Lm (follow m One) =\n       tl ` Lm One \\<union> (if m then lang (strip One) else {}) - {[]}\n 3. \\<And>r1 r2 m.\n       \\<lbrakk>\\<And>m.\n                   Lm (follow m r1) =\n                   tl ` Lm r1 \\<union> (if m then lang (strip r1) else {}) -\n                   {[]};\n        \\<And>m.\n           Lm (follow m r2) =\n           tl ` Lm r2 \\<union> (if m then lang (strip r2) else {}) -\n           {[]}\\<rbrakk>\n       \\<Longrightarrow> Lm (follow m (Plus r1 r2)) =\n                         tl ` Lm (Plus r1 r2) \\<union>\n                         (if m then lang (strip (Plus r1 r2)) else {}) -\n                         {[]}\n 4. \\<And>r1 r2 m.\n       \\<lbrakk>\\<And>m.\n                   Lm (follow m r1) =\n                   tl ` Lm r1 \\<union> (if m then lang (strip r1) else {}) -\n                   {[]};\n        \\<And>m.\n           Lm (follow m r2) =\n           tl ` Lm r2 \\<union> (if m then lang (strip r2) else {}) -\n           {[]}\\<rbrakk>\n       \\<Longrightarrow> Lm (follow m (Times r1 r2)) =\n                         tl ` Lm (Times r1 r2) \\<union>\n                         (if m then lang (strip (Times r1 r2)) else {}) -\n                         {[]}\n 5. \\<And>r m.\n       (\\<And>m.\n           Lm (follow m r) =\n           tl ` Lm r \\<union> (if m then lang (strip r) else {}) -\n           {[]}) \\<Longrightarrow>\n       Lm (follow m (Star r)) =\n       tl ` Lm (Star r) \\<union> (if m then lang (strip (Star r)) else {}) -\n       {[]}", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>m.\n       Lm (follow m Zero) =\n       tl ` Lm Zero \\<union> (if m then lang (strip Zero) else {}) - {[]}\n 2. \\<And>m.\n       Lm (follow m One) =\n       tl ` Lm One \\<union> (if m then lang (strip One) else {}) - {[]}\n 3. \\<And>r1 r2 m.\n       \\<lbrakk>\\<And>m.\n                   Lm (follow m r1) =\n                   tl ` Lm r1 \\<union> (if m then lang (strip r1) else {}) -\n                   {[]};\n        \\<And>m.\n           Lm (follow m r2) =\n           tl ` Lm r2 \\<union> (if m then lang (strip r2) else {}) -\n           {[]}\\<rbrakk>\n       \\<Longrightarrow> Lm (follow m (Plus r1 r2)) =\n                         tl ` Lm (Plus r1 r2) \\<union>\n                         (if m then lang (strip (Plus r1 r2)) else {}) -\n                         {[]}\n 4. \\<And>r1 r2 m.\n       \\<lbrakk>\\<And>m.\n                   Lm (follow m r1) =\n                   tl ` Lm r1 \\<union> (if m then lang (strip r1) else {}) -\n                   {[]};\n        \\<And>m.\n           Lm (follow m r2) =\n           tl ` Lm r2 \\<union> (if m then lang (strip r2) else {}) -\n           {[]}\\<rbrakk>\n       \\<Longrightarrow> Lm (follow m (Times r1 r2)) =\n                         tl ` Lm (Times r1 r2) \\<union>\n                         (if m then lang (strip (Times r1 r2)) else {}) -\n                         {[]}\n 5. \\<And>r m.\n       (\\<And>m.\n           Lm (follow m r) =\n           tl ` Lm r \\<union> (if m then lang (strip r) else {}) -\n           {[]}) \\<Longrightarrow>\n       Lm (follow m (Star r)) =\n       tl ` Lm (Star r) \\<union> (if m then lang (strip (Star r)) else {}) -\n       {[]}", "case (Times r s)"], ["proof (state)\nthis:\n  Lm (follow ?m r) =\n  tl ` Lm r \\<union> (if ?m then lang (strip r) else {}) - {[]}\n  Lm (follow ?m s) =\n  tl ` Lm s \\<union> (if ?m then lang (strip s) else {}) - {[]}\n\ngoal (5 subgoals):\n 1. \\<And>m.\n       Lm (follow m Zero) =\n       tl ` Lm Zero \\<union> (if m then lang (strip Zero) else {}) - {[]}\n 2. \\<And>m.\n       Lm (follow m One) =\n       tl ` Lm One \\<union> (if m then lang (strip One) else {}) - {[]}\n 3. \\<And>r1 r2 m.\n       \\<lbrakk>\\<And>m.\n                   Lm (follow m r1) =\n                   tl ` Lm r1 \\<union> (if m then lang (strip r1) else {}) -\n                   {[]};\n        \\<And>m.\n           Lm (follow m r2) =\n           tl ` Lm r2 \\<union> (if m then lang (strip r2) else {}) -\n           {[]}\\<rbrakk>\n       \\<Longrightarrow> Lm (follow m (Plus r1 r2)) =\n                         tl ` Lm (Plus r1 r2) \\<union>\n                         (if m then lang (strip (Plus r1 r2)) else {}) -\n                         {[]}\n 4. \\<And>r1 r2 m.\n       \\<lbrakk>\\<And>m.\n                   Lm (follow m r1) =\n                   tl ` Lm r1 \\<union> (if m then lang (strip r1) else {}) -\n                   {[]};\n        \\<And>m.\n           Lm (follow m r2) =\n           tl ` Lm r2 \\<union> (if m then lang (strip r2) else {}) -\n           {[]}\\<rbrakk>\n       \\<Longrightarrow> Lm (follow m (Times r1 r2)) =\n                         tl ` Lm (Times r1 r2) \\<union>\n                         (if m then lang (strip (Times r1 r2)) else {}) -\n                         {[]}\n 5. \\<And>r m.\n       (\\<And>m.\n           Lm (follow m r) =\n           tl ` Lm r \\<union> (if m then lang (strip r) else {}) -\n           {[]}) \\<Longrightarrow>\n       Lm (follow m (Star r)) =\n       tl ` Lm (Star r) \\<union> (if m then lang (strip (Star r)) else {}) -\n       {[]}", "thus ?case"], ["proof (prove)\nusing this:\n  Lm (follow ?m r) =\n  tl ` Lm r \\<union> (if ?m then lang (strip r) else {}) - {[]}\n  Lm (follow ?m s) =\n  tl ` Lm s \\<union> (if ?m then lang (strip s) else {}) - {[]}\n\ngoal (1 subgoal):\n 1. Lm (follow m (Times r s)) =\n    tl ` Lm (Times r s) \\<union>\n    (if m then lang (strip (Times r s)) else {}) -\n    {[]}", "by (simp add: Un_Diff image_Un conc_Un_distrib nullable_iff\n          conc_Diff_if_Nil1 Nil_notin_tl_if_not_final Un_ac)"], ["proof (state)\nthis:\n  Lm (follow m (Times r s)) =\n  tl ` Lm (Times r s) \\<union>\n  (if m then lang (strip (Times r s)) else {}) -\n  {[]}\n\ngoal (4 subgoals):\n 1. \\<And>m.\n       Lm (follow m Zero) =\n       tl ` Lm Zero \\<union> (if m then lang (strip Zero) else {}) - {[]}\n 2. \\<And>m.\n       Lm (follow m One) =\n       tl ` Lm One \\<union> (if m then lang (strip One) else {}) - {[]}\n 3. \\<And>r1 r2 m.\n       \\<lbrakk>\\<And>m.\n                   Lm (follow m r1) =\n                   tl ` Lm r1 \\<union> (if m then lang (strip r1) else {}) -\n                   {[]};\n        \\<And>m.\n           Lm (follow m r2) =\n           tl ` Lm r2 \\<union> (if m then lang (strip r2) else {}) -\n           {[]}\\<rbrakk>\n       \\<Longrightarrow> Lm (follow m (Plus r1 r2)) =\n                         tl ` Lm (Plus r1 r2) \\<union>\n                         (if m then lang (strip (Plus r1 r2)) else {}) -\n                         {[]}\n 4. \\<And>r m.\n       (\\<And>m.\n           Lm (follow m r) =\n           tl ` Lm r \\<union> (if m then lang (strip r) else {}) -\n           {[]}) \\<Longrightarrow>\n       Lm (follow m (Star r)) =\n       tl ` Lm (Star r) \\<union> (if m then lang (strip (Star r)) else {}) -\n       {[]}", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>m.\n       Lm (follow m Zero) =\n       tl ` Lm Zero \\<union> (if m then lang (strip Zero) else {}) - {[]}\n 2. \\<And>m.\n       Lm (follow m One) =\n       tl ` Lm One \\<union> (if m then lang (strip One) else {}) - {[]}\n 3. \\<And>r1 r2 m.\n       \\<lbrakk>\\<And>m.\n                   Lm (follow m r1) =\n                   tl ` Lm r1 \\<union> (if m then lang (strip r1) else {}) -\n                   {[]};\n        \\<And>m.\n           Lm (follow m r2) =\n           tl ` Lm r2 \\<union> (if m then lang (strip r2) else {}) -\n           {[]}\\<rbrakk>\n       \\<Longrightarrow> Lm (follow m (Plus r1 r2)) =\n                         tl ` Lm (Plus r1 r2) \\<union>\n                         (if m then lang (strip (Plus r1 r2)) else {}) -\n                         {[]}\n 4. \\<And>r m.\n       (\\<And>m.\n           Lm (follow m r) =\n           tl ` Lm r \\<union> (if m then lang (strip r) else {}) -\n           {[]}) \\<Longrightarrow>\n       Lm (follow m (Star r)) =\n       tl ` Lm (Star r) \\<union> (if m then lang (strip (Star r)) else {}) -\n       {[]}", "case (Star r)"], ["proof (state)\nthis:\n  Lm (follow ?m r) =\n  tl ` Lm r \\<union> (if ?m then lang (strip r) else {}) - {[]}\n\ngoal (4 subgoals):\n 1. \\<And>m.\n       Lm (follow m Zero) =\n       tl ` Lm Zero \\<union> (if m then lang (strip Zero) else {}) - {[]}\n 2. \\<And>m.\n       Lm (follow m One) =\n       tl ` Lm One \\<union> (if m then lang (strip One) else {}) - {[]}\n 3. \\<And>r1 r2 m.\n       \\<lbrakk>\\<And>m.\n                   Lm (follow m r1) =\n                   tl ` Lm r1 \\<union> (if m then lang (strip r1) else {}) -\n                   {[]};\n        \\<And>m.\n           Lm (follow m r2) =\n           tl ` Lm r2 \\<union> (if m then lang (strip r2) else {}) -\n           {[]}\\<rbrakk>\n       \\<Longrightarrow> Lm (follow m (Plus r1 r2)) =\n                         tl ` Lm (Plus r1 r2) \\<union>\n                         (if m then lang (strip (Plus r1 r2)) else {}) -\n                         {[]}\n 4. \\<And>r m.\n       (\\<And>m.\n           Lm (follow m r) =\n           tl ` Lm r \\<union> (if m then lang (strip r) else {}) -\n           {[]}) \\<Longrightarrow>\n       Lm (follow m (Star r)) =\n       tl ` Lm (Star r) \\<union> (if m then lang (strip (Star r)) else {}) -\n       {[]}", "thus ?case"], ["proof (prove)\nusing this:\n  Lm (follow ?m r) =\n  tl ` Lm r \\<union> (if ?m then lang (strip r) else {}) - {[]}\n\ngoal (1 subgoal):\n 1. Lm (follow m (Star r)) =\n    tl ` Lm (Star r) \\<union> (if m then lang (strip (Star r)) else {}) -\n    {[]}", "by (simp add: Un_Diff conc_Un_distrib\n          conc_Diff_if_Nil1 Nil_notin_tl_if_not_final star_Diff_Nil_fold)"], ["proof (state)\nthis:\n  Lm (follow m (Star r)) =\n  tl ` Lm (Star r) \\<union> (if m then lang (strip (Star r)) else {}) - {[]}\n\ngoal (3 subgoals):\n 1. \\<And>m.\n       Lm (follow m Zero) =\n       tl ` Lm Zero \\<union> (if m then lang (strip Zero) else {}) - {[]}\n 2. \\<And>m.\n       Lm (follow m One) =\n       tl ` Lm One \\<union> (if m then lang (strip One) else {}) - {[]}\n 3. \\<And>r1 r2 m.\n       \\<lbrakk>\\<And>m.\n                   Lm (follow m r1) =\n                   tl ` Lm r1 \\<union> (if m then lang (strip r1) else {}) -\n                   {[]};\n        \\<And>m.\n           Lm (follow m r2) =\n           tl ` Lm r2 \\<union> (if m then lang (strip r2) else {}) -\n           {[]}\\<rbrakk>\n       \\<Longrightarrow> Lm (follow m (Plus r1 r2)) =\n                         tl ` Lm (Plus r1 r2) \\<union>\n                         (if m then lang (strip (Plus r1 r2)) else {}) -\n                         {[]}", "qed auto"], ["", "subsection \\<open>Mark Before Atom\\<close>"], ["", "text\\<open>Position automaton where mark is placed before atoms.\\<close>"], ["", "abbreviation \"empty_mrexp \\<equiv> map_rexp (\\<lambda>a. (False,a))\""], ["", "lemma empty_mrexp_mrexps[simp]: \"empty_mrexp r \\<in> mrexps r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. empty_mrexp r \\<in> mrexps r", "by (induction r) auto"], ["", "lemma nullable_empty_mrexp[simp]: \"nullable (empty_mrexp r) = nullable r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nullable (empty_mrexp r) = nullable r", "by (induct r) auto"], ["", "definition \"init_b r = (follow True (empty_mrexp r), nullable r)\""], ["", "lemma init_b_mrexps[simp]: \"init_b r \\<in> mrexps r \\<times> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init_b r \\<in> mrexps r \\<times> UNIV", "unfolding init_b_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (follow True (empty_mrexp r), nullable r) \\<in> mrexps r \\<times> UNIV", "by auto"], ["", "fun delta_b where\n\"delta_b a (r,b) = (let r' = read a r in (follow False r', final r'))\""], ["", "lemma delta_b_mrexps[simp]: \"rb \\<in> mrexps r \\<times> UNIV \\<Longrightarrow> delta_b a rb \\<in> mrexps r \\<times> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rb \\<in> mrexps r \\<times> UNIV \\<Longrightarrow>\n    delta_b a rb \\<in> mrexps r \\<times> UNIV", "by (auto simp: Let_def)"], ["", "lemma fold_delta_b_init_b_mrexps[simp]: \"fold delta_b w (init_b s) \\<in> mrexps s \\<times> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold delta_b w (init_b s) \\<in> mrexps s \\<times> UNIV", "by (induction w arbitrary: s rule: rev_induct) auto"], ["", "fun L_b where\n\"L_b (r,b) = Lm r \\<union> (if b then {[]} else {})\""], ["", "abbreviation \"final_b \\<equiv> snd\""], ["", "lemma Lm_empty: \"Lm (empty_mrexp r) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lm (empty_mrexp r) = {}", "by (induction r) auto"], ["", "lemma final_read_Lm: \"final(read a r) \\<longleftrightarrow> [a] \\<in> Lm r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. final (read a r) = ([a] \\<in> Lm r)", "by (induction r) (auto simp: nullable_iff concI_if_Nil2 singleton_in_conc split: if_splits)"], ["", "global_interpretation before: rexp_DFA init_b delta_b final_b L_b\n  defines before_closure = before.closure\n    and check_eqv_b = before.check_eqv\n    and reachable_b = before.reachable\n    and automaton_b = before.automaton\n    and match_b = before.match"], ["proof (prove)\ngoal (1 subgoal):\n 1. rexp_DFA init_b delta_b final_b L_b", "proof (standard, goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>r. L_b (init_b r) = lang r\n 2. \\<And>a s. L_b (delta_b a s) = Deriv a (L_b s)\n 3. \\<And>s. final_b s = ([] \\<in> L_b s)\n 4. \\<And>s. finite {fold delta_b w (init_b s) |w. True}", "case (1 r)"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>r. L_b (init_b r) = lang r\n 2. \\<And>a s. L_b (delta_b a s) = Deriv a (L_b s)\n 3. \\<And>s. final_b s = ([] \\<in> L_b s)\n 4. \\<And>s. finite {fold delta_b w (init_b s) |w. True}", "show \"L_b (init_b r) = lang r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L_b (init_b r) = lang r", "by(auto simp add: init_b_def Lm_follow Lm_empty map_map_rexp nullable_iff)"], ["proof (state)\nthis:\n  L_b (init_b r) = lang r\n\ngoal (3 subgoals):\n 1. \\<And>a s. L_b (delta_b a s) = Deriv a (L_b s)\n 2. \\<And>s. final_b s = ([] \\<in> L_b s)\n 3. \\<And>s. finite {fold delta_b w (init_b s) |w. True}", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a s. L_b (delta_b a s) = Deriv a (L_b s)\n 2. \\<And>s. final_b s = ([] \\<in> L_b s)\n 3. \\<And>s. finite {fold delta_b w (init_b s) |w. True}", "case (2 a rb)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>a s. L_b (delta_b a s) = Deriv a (L_b s)\n 2. \\<And>s. final_b s = ([] \\<in> L_b s)\n 3. \\<And>s. finite {fold delta_b w (init_b s) |w. True}", "show \"L_b (delta_b a rb) = Deriv a (L_b rb)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L_b (delta_b a rb) = Deriv a (L_b rb)", "by (cases rb) (auto simp add: Deriv_def final_read_Lm image_def Lm_read Lm_follow)"], ["proof (state)\nthis:\n  L_b (delta_b a rb) = Deriv a (L_b rb)\n\ngoal (2 subgoals):\n 1. \\<And>s. final_b s = ([] \\<in> L_b s)\n 2. \\<And>s. finite {fold delta_b w (init_b s) |w. True}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. final_b s = ([] \\<in> L_b s)\n 2. \\<And>s. finite {fold delta_b w (init_b s) |w. True}", "case (3 rb)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>s. final_b s = ([] \\<in> L_b s)\n 2. \\<And>s. finite {fold delta_b w (init_b s) |w. True}", "show  \"final_b rb \\<longleftrightarrow> [] \\<in> L_b rb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. final_b rb = ([] \\<in> L_b rb)", "by (cases rb) simp"], ["proof (state)\nthis:\n  final_b rb = ([] \\<in> L_b rb)\n\ngoal (1 subgoal):\n 1. \\<And>s. finite {fold delta_b w (init_b s) |w. True}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. finite {fold delta_b w (init_b s) |w. True}", "case (4 s)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>s. finite {fold delta_b w (init_b s) |w. True}", "have \"{fold delta_b w (init_b s) |w. True} \\<subseteq> mrexps s \\<times> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {fold delta_b w (init_b s) |w. True} \\<subseteq> mrexps s \\<times> UNIV", "by (intro subsetI, elim CollectE exE) (simp only: fold_delta_b_init_b_mrexps)"], ["proof (state)\nthis:\n  {fold delta_b w (init_b s) |w. True} \\<subseteq> mrexps s \\<times> UNIV\n\ngoal (1 subgoal):\n 1. \\<And>s. finite {fold delta_b w (init_b s) |w. True}", "then"], ["proof (chain)\npicking this:\n  {fold delta_b w (init_b s) |w. True} \\<subseteq> mrexps s \\<times> UNIV", "show \"finite {fold delta_b w (init_b s) |w. True}\""], ["proof (prove)\nusing this:\n  {fold delta_b w (init_b s) |w. True} \\<subseteq> mrexps s \\<times> UNIV\n\ngoal (1 subgoal):\n 1. finite {fold delta_b w (init_b s) |w. True}", "by (rule finite_subset) simp"], ["proof (state)\nthis:\n  finite {fold delta_b w (init_b s) |w. True}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Mark After Atom\\<close>"], ["", "text\\<open>Position automaton where mark is placed after atoms. This is the\nGlushkov and McNaughton/Yamada construction.\\<close>"], ["", "definition \"init_a r = (True, empty_mrexp r)\""], ["", "lemma init_a_mrexps[simp]: \"init_a r \\<in> UNIV \\<times> mrexps r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init_a r \\<in> UNIV \\<times> mrexps r", "unfolding init_a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (True, empty_mrexp r) \\<in> UNIV \\<times> mrexps r", "by auto"], ["", "fun delta_a where\n\"delta_a a (b,r) = (False, read a (follow b r))\""], ["", "lemma delta_a_mrexps[simp]: \"br \\<in> UNIV \\<times> mrexps r \\<Longrightarrow> delta_a a br \\<in> UNIV \\<times> mrexps r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. br \\<in> UNIV \\<times> mrexps r \\<Longrightarrow>\n    delta_a a br \\<in> UNIV \\<times> mrexps r", "by auto"], ["", "lemma fold_delta_a_init_a_mrexps[simp]: \"fold delta_a w (init_a s) \\<in> UNIV \\<times> mrexps s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold delta_a w (init_a s) \\<in> UNIV \\<times> mrexps s", "by (induction w arbitrary: s rule: rev_induct) auto"], ["", "fun final_a where\n\"final_a (b,r) \\<longleftrightarrow> final r \\<or> b \\<and> nullable r\""], ["", "fun L_a where\n\"L_a (b,r) = Lm (follow b r) \\<union> (if final_a(b,r)  then {[]} else {})\""], ["", "lemma nonfinal_empty_mrexp: \"\\<not> final (empty_mrexp r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> final (empty_mrexp r)", "by (induction r) auto"], ["", "lemma Cons_eq_tl_iff[simp]: \"x # xs = tl ys \\<longleftrightarrow> (\\<exists>y. ys = y # x # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x # xs = tl ys) = (\\<exists>y. ys = y # x # xs)", "by (cases ys) auto"], ["", "lemma tl_eq_Cons_iff[simp]: \"tl ys = x # xs \\<longleftrightarrow> (\\<exists>y. ys = y # x # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (tl ys = x # xs) = (\\<exists>y. ys = y # x # xs)", "by (cases ys) auto"], ["", "global_interpretation after: rexp_DFA init_a delta_a final_a L_a\n  defines after_closure = after.closure\n    and check_eqv_a = after.check_eqv\n    and reachable_a = after.reachable\n    and automaton_a = after.automaton\n    and match_a = after.match"], ["proof (prove)\ngoal (1 subgoal):\n 1. rexp_DFA init_a delta_a final_a L_a", "proof (standard, goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>r. L_a (init_a r) = lang r\n 2. \\<And>a s. L_a (delta_a a s) = Deriv a (L_a s)\n 3. \\<And>s. final_a s = ([] \\<in> L_a s)\n 4. \\<And>s. finite {fold delta_a w (init_a s) |w. True}", "case (1 r)"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>r. L_a (init_a r) = lang r\n 2. \\<And>a s. L_a (delta_a a s) = Deriv a (L_a s)\n 3. \\<And>s. final_a s = ([] \\<in> L_a s)\n 4. \\<And>s. finite {fold delta_a w (init_a s) |w. True}", "show \"L_a (init_a r) = lang r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L_a (init_a r) = lang r", "by (auto simp: init_a_def nonfinal_empty_mrexp Lm_follow Lm_empty map_map_rexp nullable_iff)"], ["proof (state)\nthis:\n  L_a (init_a r) = lang r\n\ngoal (3 subgoals):\n 1. \\<And>a s. L_a (delta_a a s) = Deriv a (L_a s)\n 2. \\<And>s. final_a s = ([] \\<in> L_a s)\n 3. \\<And>s. finite {fold delta_a w (init_a s) |w. True}", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a s. L_a (delta_a a s) = Deriv a (L_a s)\n 2. \\<And>s. final_a s = ([] \\<in> L_a s)\n 3. \\<And>s. finite {fold delta_a w (init_a s) |w. True}", "case (2 a br)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>a s. L_a (delta_a a s) = Deriv a (L_a s)\n 2. \\<And>s. final_a s = ([] \\<in> L_a s)\n 3. \\<And>s. finite {fold delta_a w (init_a s) |w. True}", "show \"L_a (delta_a a br) = Deriv a (L_a br)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L_a (delta_a a br) = Deriv a (L_a br)", "by (cases br) (simp add: Deriv_def final_read_Lm Lm_read Lm_follow,\n      fastforce simp: image_def neq_Nil_conv)"], ["proof (state)\nthis:\n  L_a (delta_a a br) = Deriv a (L_a br)\n\ngoal (2 subgoals):\n 1. \\<And>s. final_a s = ([] \\<in> L_a s)\n 2. \\<And>s. finite {fold delta_a w (init_a s) |w. True}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. final_a s = ([] \\<in> L_a s)\n 2. \\<And>s. finite {fold delta_a w (init_a s) |w. True}", "case (3 br)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>s. final_a s = ([] \\<in> L_a s)\n 2. \\<And>s. finite {fold delta_a w (init_a s) |w. True}", "show  \"final_a br \\<longleftrightarrow> [] \\<in> L_a br\""], ["proof (prove)\ngoal (1 subgoal):\n 1. final_a br = ([] \\<in> L_a br)", "by (cases br) simp"], ["proof (state)\nthis:\n  final_a br = ([] \\<in> L_a br)\n\ngoal (1 subgoal):\n 1. \\<And>s. finite {fold delta_a w (init_a s) |w. True}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. finite {fold delta_a w (init_a s) |w. True}", "case (4 s)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>s. finite {fold delta_a w (init_a s) |w. True}", "have \"{fold delta_a w (init_a s) |w. True} \\<subseteq> UNIV \\<times> mrexps s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {fold delta_a w (init_a s) |w. True} \\<subseteq> UNIV \\<times> mrexps s", "by (intro subsetI, elim CollectE exE) (simp only: fold_delta_a_init_a_mrexps)"], ["proof (state)\nthis:\n  {fold delta_a w (init_a s) |w. True} \\<subseteq> UNIV \\<times> mrexps s\n\ngoal (1 subgoal):\n 1. \\<And>s. finite {fold delta_a w (init_a s) |w. True}", "then"], ["proof (chain)\npicking this:\n  {fold delta_a w (init_a s) |w. True} \\<subseteq> UNIV \\<times> mrexps s", "show \"finite {fold delta_a w (init_a s) |w. True}\""], ["proof (prove)\nusing this:\n  {fold delta_a w (init_a s) |w. True} \\<subseteq> UNIV \\<times> mrexps s\n\ngoal (1 subgoal):\n 1. finite {fold delta_a w (init_a s) |w. True}", "by (rule finite_subset) simp"], ["proof (state)\nthis:\n  finite {fold delta_a w (init_a s) |w. True}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nThe ``before'' atomaton is a quotient of the ``after'' automaton.\n\nThe proof below follows an informal proof given by Helmut Seidl in personal communication. \n\\<close>"], ["", "fun hom_ab where\n  \"hom_ab (b, r) = (follow b r, final_a (b, r))\""], ["", "lemma hom_delta: \"hom_ab (delta_a x br) = delta_b x (hom_ab br)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_ab (delta_a x br) = delta_b x (hom_ab br)", "by(cases br) (auto simp add: Let_def)"], ["", "lemma hom_deltas: \"hom_ab (fold delta_a w br) = fold delta_b w (hom_ab br)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_ab (fold delta_a w br) = fold delta_b w (hom_ab br)", "by (induct w arbitrary: br) (auto simp add: hom_delta)"], ["", "lemma hom_init: \"hom_ab (init_a r) = init_b r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_ab (init_a r) = init_b r", "unfolding init_a_def init_b_def hom_ab.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (follow True (empty_mrexp r), final_a (True, empty_mrexp r)) =\n    (follow True (empty_mrexp r), nullable r)", "by (simp add: nonfinal_empty_mrexp)"], ["", "lemma reachable_ab: \"reachable_b as r = hom_ab ` reachable_a as r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable_b as r = hom_ab ` reachable_a as r", "unfolding after.reachable before.reachable"], ["proof (prove)\ngoal (1 subgoal):\n 1. {fold delta_b w (init_b r) |w. w \\<in> lists (set as)} =\n    hom_ab ` {fold delta_a w (init_a r) |w. w \\<in> lists (set as)}", "by (force simp: hom_init hom_deltas)"], ["", "theorem card_reachable_ab: \"card (reachable_b as r) \\<le> card (reachable_a as r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (reachable_b as r) \\<le> card (reachable_a as r)", "unfolding reachable_ab"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (hom_ab ` reachable_a as r) \\<le> card (reachable_a as r)", "using after.finite_reachable"], ["proof (prove)\nusing this:\n  finite (reachable_a ?as ?r)\n\ngoal (1 subgoal):\n 1. card (hom_ab ` reachable_a as r) \\<le> card (reachable_a as r)", "by (rule card_image_le)"], ["", "text\\<open>The implementation by Fischer et al.:\\<close>"], ["", "(* better: shift b m r and move m b r *)"], ["", "fun shift :: \"bool \\<Rightarrow> 'a mrexp \\<Rightarrow> 'a \\<Rightarrow> 'a mrexp\" where\n\"shift _ One _ = One\" |\n\"shift _ Zero _ = Zero\" |\n\"shift m (Atom (_,x)) c = Atom (m \\<and> (x=c),x)\" |\n\"shift m (Plus r s) c = Plus (shift m r c) (shift m s c)\" |\n\"shift m (Times r s) c =\n  Times (shift m r c) (shift (final r \\<or> m \\<and> nullable r) s c)\" |\n\"shift m (Star r) c = Star (shift (final r \\<or> m) r c)\""], ["", "lemma shift_read_follow: \"shift m r x = read x (follow m r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shift m r x = read x (follow m r)", "by (induction m r x rule: shift.induct) auto"], ["", "text\\<open>In the spirit of Asperti, and similarly quadratic because of need\nto call final1 in move.\\<close>"], ["", "fun final1 :: \"'a mrexp \\<Rightarrow> 'a \\<Rightarrow> bool\" where\n\"final1 Zero _ = False\" |\n\"final1 One _ = False\" |\n\"final1 (Atom(m,a)) x = (m \\<and> a=x)\" |\n\"final1 (Plus r s) x = (final1 r x \\<or> final1 s x)\" |\n\"final1 (Times r s) x = (final1 s x \\<or> nullable s \\<and> final1 r x)\" |\n\"final1 (Star r) x = final1 r x\""], ["", "fun move :: \"'a \\<Rightarrow> 'a mrexp \\<Rightarrow> bool \\<Rightarrow> 'a mrexp\" where\n\"move _ One _ = One\" |\n\"move _ Zero _ = Zero\" |\n\"move c (Atom (_,a)) m = Atom (m, a)\" |\n\"move c (Plus r s) m = Plus (move c r m) (move c s m)\" |\n\"move c (Times r s) m =\n  Times (move c r m) (move c s (final1 r c \\<or> m \\<and> nullable r))\" |\n\"move c (Star r) m = Star (move c r (final1 r c \\<or> m))\""], ["", "lemma nullable_read[simp]: \"nullable (read c r) = nullable r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nullable (read c r) = nullable r", "by (induction r) auto"], ["", "lemma final_read_final1: \"final (read c r) = final1 r c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. final (read c r) = final1 r c", "by (induction r) auto"], ["", "lemma move_follow_read: \"move c r m = follow m (read c r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. move c r m = follow m (read c r)", "by (induction c r m rule: move.induct) (auto simp: final_read_final1)"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}