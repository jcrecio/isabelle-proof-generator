{"file_name": "/home/qj213/afp-2021-10-22/thys/Regex_Equivalence/After2.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Regex_Equivalence", "problem_names": ["lemma finite_mrexps3[simp]: \"finite (mrexps2 r)\"", "lemma strip_mrexps2: \"(strip o strip2) ` mrexps2 r = {r}\"", "lemma ok2_fin_final[simp]: \"ok2 r \\<Longrightarrow> fin r = final (strip2 r)\"", "lemma ok2_nul_nullable[simp]: \"ok2 r \\<Longrightarrow> nul r = nullable (strip2 r)\"", "lemma strip2_shift2: \"ok2 r \\<Longrightarrow> strip2(shift2 m r c) = shift m (strip2 r) c\"", "lemma ok2_empty_mrexp2: \"ok2 (empty_mrexp2 r)\"", "lemma ok2_shift2: \"ok2 r \\<Longrightarrow> ok2(shift2 m r c)\"", "lemma strip2_empty_mrexp2[simp]: \"strip2 (empty_mrexp2 r) = empty_mrexp r\"", "lemma nul_empty_mrexp2[simp]: \"nul (empty_mrexp2 r) = nullable r\"", "lemma nonfin_empty_mrexp2[simp]: \"\\<not> fin (empty_mrexp2 r)\"", "lemma empty_mrexp2_mrexps2[simp]: \"empty_mrexp2 s \\<in> mrexps2 s\"", "lemma shift2_mrexps2[simp]: \"r \\<in> mrexps2 s \\<Longrightarrow> shift2 x r a \\<in> mrexps2 s\"", "lemma eq_mrexp2_imp_eq: \"\\<lbrakk>eq_mrexp2 r s; ok2 r; ok2 s\\<rbrakk> \\<Longrightarrow> (r = s)\"", "lemma eq_mrexp2_refl[simplified, simp]: \"r = s \\<Longrightarrow> eq_mrexp2 r s\"", "lemma eq_mrexp2_eq: \"\\<lbrakk>ok2 r; ok2 s\\<rbrakk> \\<Longrightarrow> eq_mrexp2 r s = (r = s)\""], "translations": [["", "lemma finite_mrexps3[simp]: \"finite (mrexps2 r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (mrexps2 r)", "by (induction r) auto"], ["", "definition[simp]: \"plus2 r s == Plus2 r s (fin r \\<or> fin s) (nul r \\<or> nul s)\""], ["", "definition[simp]: \"times2 r s == Times2 r s (fin r \\<and> nul s \\<or> fin s) (nul r \\<and> nul s)\""], ["", "definition[simp]: \"star2 r == Star2 r (fin r)\""], ["", "primrec empty_mrexp2 :: \"'a rexp \\<Rightarrow> 'a mrexp2\" where\n\"empty_mrexp2 Zero = Zero2\" |\n\"empty_mrexp2 One = One2\" |\n\"empty_mrexp2 (Atom x) = Atom2 False x\" |\n\"empty_mrexp2 (Plus r s) = plus2 (empty_mrexp2 r) (empty_mrexp2 s)\" |\n\"empty_mrexp2 (Times r s) = times2 (empty_mrexp2 r) (empty_mrexp2 s)\" |\n\"empty_mrexp2 (Star r) = star2 (empty_mrexp2 r)\""], ["", "primrec shift2 :: \"bool \\<Rightarrow> 'a mrexp2 \\<Rightarrow> 'a \\<Rightarrow> 'a mrexp2\" where\n\"shift2 _ One2 _ = One2\" |\n\"shift2 _ Zero2 _ = Zero2\" |\n\"shift2 m (Atom2 _ x) c = Atom2 (m \\<and> (x=c)) x\" |\n\"shift2 m (Plus2 r s _ _) c = plus2 (shift2 m r c) (shift2 m s c)\" |\n\"shift2 m (Times2 r s _ _) c = times2 (shift2 m r c) (shift2 (m \\<and> nul r \\<or> fin r) s c)\" |\n\"shift2 m (Star2 r _) c =  star2 (shift2 (m \\<or> fin r) r c)\""], ["", "primrec strip2 where\n\"strip2 Zero2 = Zero\" |\n\"strip2 One2 = One\" |\n\"strip2 (Atom2 m x) = Atom (m, x)\" |\n\"strip2 (Plus2 r s _ _) = Plus (strip2 r) (strip2 s)\" |\n\"strip2 (Times2 r s _ _) = Times (strip2 r) (strip2 s)\" |\n\"strip2 (Star2 r _) = Star (strip2 r)\""], ["", "lemma strip_mrexps2: \"(strip o strip2) ` mrexps2 r = {r}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (strip \\<circ> strip2) ` mrexps2 r = {r}", "by (induction r) (auto simp: set_eq_subset subset_iff image_iff)"], ["", "primrec ok2 :: \"'a mrexp2 \\<Rightarrow> bool\" where\n\"ok2 Zero2 = True\" |\n\"ok2 One2 = True\" |\n\"ok2 (Atom2 _ _) = True\" |\n\"ok2 (Plus2 r s f n) = (ok2 r \\<and> ok2 s \\<and>\n   (let rs = Plus (strip2 r) (strip2 s) in f = final rs \\<and> n = nullable rs))\" |\n\"ok2 (Times2 r s f n) = (ok2 r \\<and> ok2 s \\<and>\n   (let rs = Times (strip2 r) (strip2 s) in f = final rs \\<and> n = nullable rs))\" |\n\"ok2 (Star2 r f) = (ok2 r \\<and> f = final (strip2 r))\""], ["", "lemma ok2_fin_final[simp]: \"ok2 r \\<Longrightarrow> fin r = final (strip2 r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ok2 r \\<Longrightarrow> fin r = final (strip2 r)", "by (induct r) auto"], ["", "lemma ok2_nul_nullable[simp]: \"ok2 r \\<Longrightarrow> nul r = nullable (strip2 r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ok2 r \\<Longrightarrow> nul r = nullable (strip2 r)", "by (induct r) auto"], ["", "lemma strip2_shift2: \"ok2 r \\<Longrightarrow> strip2(shift2 m r c) = shift m (strip2 r) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ok2 r \\<Longrightarrow> strip2 (shift2 m r c) = shift m (strip2 r) c", "apply(induction r arbitrary: m)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>m.\n       ok2 Zero2 \\<Longrightarrow>\n       strip2 (shift2 m Zero2 c) = shift m (strip2 Zero2) c\n 2. \\<And>m.\n       ok2 One2 \\<Longrightarrow>\n       strip2 (shift2 m One2 c) = shift m (strip2 One2) c\n 3. \\<And>x1 x2 m.\n       ok2 (Atom2 x1 x2) \\<Longrightarrow>\n       strip2 (shift2 m (Atom2 x1 x2) c) = shift m (strip2 (Atom2 x1 x2)) c\n 4. \\<And>r1 r2 x3 x4 m.\n       \\<lbrakk>\\<And>m.\n                   ok2 r1 \\<Longrightarrow>\n                   strip2 (shift2 m r1 c) = shift m (strip2 r1) c;\n        \\<And>m.\n           ok2 r2 \\<Longrightarrow>\n           strip2 (shift2 m r2 c) = shift m (strip2 r2) c;\n        ok2 (Plus2 r1 r2 x3 x4)\\<rbrakk>\n       \\<Longrightarrow> strip2 (shift2 m (Plus2 r1 r2 x3 x4) c) =\n                         shift m (strip2 (Plus2 r1 r2 x3 x4)) c\n 5. \\<And>r1 r2 x3 x4 m.\n       \\<lbrakk>\\<And>m.\n                   ok2 r1 \\<Longrightarrow>\n                   strip2 (shift2 m r1 c) = shift m (strip2 r1) c;\n        \\<And>m.\n           ok2 r2 \\<Longrightarrow>\n           strip2 (shift2 m r2 c) = shift m (strip2 r2) c;\n        ok2 (Times2 r1 r2 x3 x4)\\<rbrakk>\n       \\<Longrightarrow> strip2 (shift2 m (Times2 r1 r2 x3 x4) c) =\n                         shift m (strip2 (Times2 r1 r2 x3 x4)) c\n 6. \\<And>r x2 m.\n       \\<lbrakk>\\<And>m.\n                   ok2 r \\<Longrightarrow>\n                   strip2 (shift2 m r c) = shift m (strip2 r) c;\n        ok2 (Star2 r x2)\\<rbrakk>\n       \\<Longrightarrow> strip2 (shift2 m (Star2 r x2) c) =\n                         shift m (strip2 (Star2 r x2)) c", "apply (auto simp: disj_commute)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ok2_empty_mrexp2: \"ok2 (empty_mrexp2 r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ok2 (empty_mrexp2 r)", "apply(induction r)"], ["proof (prove)\ngoal (6 subgoals):\n 1. ok2 (empty_mrexp2 Zero)\n 2. ok2 (empty_mrexp2 One)\n 3. \\<And>x. ok2 (empty_mrexp2 (Atom x))\n 4. \\<And>r1 r2.\n       \\<lbrakk>ok2 (empty_mrexp2 r1); ok2 (empty_mrexp2 r2)\\<rbrakk>\n       \\<Longrightarrow> ok2 (empty_mrexp2 (Plus r1 r2))\n 5. \\<And>r1 r2.\n       \\<lbrakk>ok2 (empty_mrexp2 r1); ok2 (empty_mrexp2 r2)\\<rbrakk>\n       \\<Longrightarrow> ok2 (empty_mrexp2 (Times r1 r2))\n 6. \\<And>r.\n       ok2 (empty_mrexp2 r) \\<Longrightarrow> ok2 (empty_mrexp2 (Star r))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ok2_shift2: \"ok2 r \\<Longrightarrow> ok2(shift2 m r c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ok2 r \\<Longrightarrow> ok2 (shift2 m r c)", "apply(induction r arbitrary: m)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>m. ok2 Zero2 \\<Longrightarrow> ok2 (shift2 m Zero2 c)\n 2. \\<And>m. ok2 One2 \\<Longrightarrow> ok2 (shift2 m One2 c)\n 3. \\<And>x1 x2 m.\n       ok2 (Atom2 x1 x2) \\<Longrightarrow> ok2 (shift2 m (Atom2 x1 x2) c)\n 4. \\<And>r1 r2 x3 x4 m.\n       \\<lbrakk>\\<And>m. ok2 r1 \\<Longrightarrow> ok2 (shift2 m r1 c);\n        \\<And>m. ok2 r2 \\<Longrightarrow> ok2 (shift2 m r2 c);\n        ok2 (Plus2 r1 r2 x3 x4)\\<rbrakk>\n       \\<Longrightarrow> ok2 (shift2 m (Plus2 r1 r2 x3 x4) c)\n 5. \\<And>r1 r2 x3 x4 m.\n       \\<lbrakk>\\<And>m. ok2 r1 \\<Longrightarrow> ok2 (shift2 m r1 c);\n        \\<And>m. ok2 r2 \\<Longrightarrow> ok2 (shift2 m r2 c);\n        ok2 (Times2 r1 r2 x3 x4)\\<rbrakk>\n       \\<Longrightarrow> ok2 (shift2 m (Times2 r1 r2 x3 x4) c)\n 6. \\<And>r x2 m.\n       \\<lbrakk>\\<And>m. ok2 r \\<Longrightarrow> ok2 (shift2 m r c);\n        ok2 (Star2 r x2)\\<rbrakk>\n       \\<Longrightarrow> ok2 (shift2 m (Star2 r x2) c)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma strip2_empty_mrexp2[simp]: \"strip2 (empty_mrexp2 r) = empty_mrexp r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip2 (empty_mrexp2 r) = empty_mrexp r", "by (induct r) auto"], ["", "lemma nul_empty_mrexp2[simp]: \"nul (empty_mrexp2 r) = nullable r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nul (empty_mrexp2 r) = nullable r", "by (induct r) auto"], ["", "lemma nonfin_empty_mrexp2[simp]: \"\\<not> fin (empty_mrexp2 r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> fin (empty_mrexp2 r)", "by (induct r) auto"], ["", "lemma empty_mrexp2_mrexps2[simp]: \"empty_mrexp2 s \\<in> mrexps2 s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. empty_mrexp2 s \\<in> mrexps2 s", "by (induct s) (auto simp: image_iff)"], ["", "lemma shift2_mrexps2[simp]: \"r \\<in> mrexps2 s \\<Longrightarrow> shift2 x r a \\<in> mrexps2 s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<in> mrexps2 s \\<Longrightarrow> shift2 x r a \\<in> mrexps2 s", "by (induct s arbitrary: r x) (auto simp: image_iff)"], ["", "typedef 'a ok_mrexp2 = \"{(b :: bool, r :: 'a mrexp2). ok2 r}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {(b, r). ok2 r}", "unfolding mem_Collect_eq split_beta"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. ok2 (final_b x)", "by (metis snd_eqD ok2_empty_mrexp2)"], ["", "setup_lifting type_definition_ok_mrexp2"], ["", "lift_definition init_okm :: \"'a rexp \\<Rightarrow> 'a ok_mrexp2\" is \"\\<lambda>r. (True, empty_mrexp2 r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rexp. (True, empty_mrexp2 rexp) \\<in> {(b, y). ok2 y}", "by (simp add: ok2_empty_mrexp2 del: ok2.simps)"], ["", "lift_definition delta_okm :: \"'a \\<Rightarrow> 'a ok_mrexp2 \\<Rightarrow> 'a ok_mrexp2\" is\n  \"\\<lambda>a (m, r). (False, shift2 m r a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a prod.\n       prod \\<in> {(b, y). ok2 y} \\<Longrightarrow>\n       (case prod of (m, r) \\<Rightarrow> (False, shift2 m r a))\n       \\<in> {(b, y). ok2 y}", "unfolding mem_Collect_eq split_beta snd_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a prod.\n       ok2 (final_b prod) \\<Longrightarrow>\n       ok2 (shift2 (fst prod) (final_b prod) a)", "by (intro ok2_shift2) simp"], ["", "lift_definition nullable_okm :: \"'a ok_mrexp2 \\<Rightarrow> bool\" is \"\\<lambda>(m, r). fin r \\<or> m \\<and> nul r\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition lang_okm :: \"'a ok_mrexp2 \\<Rightarrow> 'a lang\" is \"\\<lambda>(m, r). L_a (m, strip2 r)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instantiation ok_mrexp2 :: (equal) \"equal\"\nbegin"], ["", "fun eq_mrexp2 where\n  \"eq_mrexp2 Zero2 Zero2 = True\"\n| \"eq_mrexp2 One2 One2 = True\"\n| \"eq_mrexp2 (Atom2 m x) (Atom2 m' y) = (m = m' \\<and> x = y)\"\n| \"eq_mrexp2 (Plus2 r1 s1 _ _) (Plus2 r2 s2 _ _) = (eq_mrexp2 r1 r2 \\<and> eq_mrexp2 s1 s2)\"\n| \"eq_mrexp2 (Times2 r1 s1 _ _) (Times2 r2 s2 _ _) = (eq_mrexp2 r1 r2 \\<and> eq_mrexp2 s1 s2)\"\n| \"eq_mrexp2 (Star2 r1 _) (Star2 r2 _) = (eq_mrexp2 r1 r2)\"\n| \"eq_mrexp2 r s = False\""], ["", "lemma eq_mrexp2_imp_eq: \"\\<lbrakk>eq_mrexp2 r s; ok2 r; ok2 s\\<rbrakk> \\<Longrightarrow> (r = s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eq_mrexp2 r s; ok2 r; ok2 s\\<rbrakk> \\<Longrightarrow> r = s", "by (induct rule: eq_mrexp2.induct) auto"], ["", "lemma eq_mrexp2_refl[simplified, simp]: \"r = s \\<Longrightarrow> eq_mrexp2 r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r = s \\<Longrightarrow> eq_mrexp2 r s", "by (induct rule: eq_mrexp2.induct) auto"], ["", "lemma eq_mrexp2_eq: \"\\<lbrakk>ok2 r; ok2 s\\<rbrakk> \\<Longrightarrow> eq_mrexp2 r s = (r = s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ok2 r; ok2 s\\<rbrakk> \\<Longrightarrow> eq_mrexp2 r s = (r = s)", "by (metis eq_mrexp2_imp_eq eq_mrexp2_refl)"], ["", "lift_definition equal_ok_mrexp2 :: \"'a ok_mrexp2 \\<Rightarrow> 'a ok_mrexp2 \\<Rightarrow> bool\"\n   is \"\\<lambda>(b1,r1) (b2, r2). b1 = b2 \\<and> eq_mrexp2 r1 r2\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ok_mrexp2, equal_class)", "by intro_classes (transfer, auto simp: eq_mrexp2_eq)"], ["", "end"], ["", "global_interpretation after2: rexp_DFA init_okm delta_okm nullable_okm lang_okm\n  defines after2_closure = after2.closure\n    and check_eqv_a2 = after2.check_eqv\n    and reachable_a2 = after2.reachable\n    and automaton_a2 = after2.automaton\n    and match_a2 = after2.match"], ["proof (prove)\ngoal (1 subgoal):\n 1. rexp_DFA init_okm delta_okm nullable_okm lang_okm", "proof (standard, goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>r. lang_okm (init_okm r) = lang r\n 2. \\<And>a s. lang_okm (delta_okm a s) = Deriv a (lang_okm s)\n 3. \\<And>s. nullable_okm s = ([] \\<in> lang_okm s)\n 4. \\<And>s. finite {fold delta_okm w (init_okm s) |w. True}", "case (1 r)"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>r. lang_okm (init_okm r) = lang r\n 2. \\<And>a s. lang_okm (delta_okm a s) = Deriv a (lang_okm s)\n 3. \\<And>s. nullable_okm s = ([] \\<in> lang_okm s)\n 4. \\<And>s. finite {fold delta_okm w (init_okm s) |w. True}", "show \"lang_okm (init_okm r) = lang r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang_okm (init_okm r) = lang r", "by transfer (auto simp: split_beta init_a_def nonfinal_empty_mrexp Lm_follow Lm_empty\n      map_map_rexp nullable_iff)"], ["proof (state)\nthis:\n  lang_okm (init_okm r) = lang r\n\ngoal (3 subgoals):\n 1. \\<And>a s. lang_okm (delta_okm a s) = Deriv a (lang_okm s)\n 2. \\<And>s. nullable_okm s = ([] \\<in> lang_okm s)\n 3. \\<And>s. finite {fold delta_okm w (init_okm s) |w. True}", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a s. lang_okm (delta_okm a s) = Deriv a (lang_okm s)\n 2. \\<And>s. nullable_okm s = ([] \\<in> lang_okm s)\n 3. \\<And>s. finite {fold delta_okm w (init_okm s) |w. True}", "case (2 a br)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>a s. lang_okm (delta_okm a s) = Deriv a (lang_okm s)\n 2. \\<And>s. nullable_okm s = ([] \\<in> lang_okm s)\n 3. \\<And>s. finite {fold delta_okm w (init_okm s) |w. True}", "show \"lang_okm (delta_okm a br) = Deriv a (lang_okm br)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang_okm (delta_okm a br) = Deriv a (lang_okm br)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a br.\n       br \\<in> {(b, y). ok2 y} \\<Longrightarrow>\n       (case case br of (m, r) \\<Rightarrow> (False, shift2 m r a) of\n        (m, r) \\<Rightarrow> L_a (m, strip2 r)) =\n       Deriv a (case br of (m, r) \\<Rightarrow> L_a (m, strip2 r))", "unfolding split_beta fst_conv snd_conv mem_Collect_eq after.L_delta[symmetric] delta_a.simps\n      shift_read_follow[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a br.\n       ok2 (final_b br) \\<Longrightarrow>\n       L_a (False, strip2 (shift2 (fst br) (final_b br) a)) =\n       L_a (False, shift (fst br) (strip2 (final_b br)) a)", "by (subst strip2_shift2) simp_all"], ["proof (state)\nthis:\n  lang_okm (delta_okm a br) = Deriv a (lang_okm br)\n\ngoal (2 subgoals):\n 1. \\<And>s. nullable_okm s = ([] \\<in> lang_okm s)\n 2. \\<And>s. finite {fold delta_okm w (init_okm s) |w. True}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. nullable_okm s = ([] \\<in> lang_okm s)\n 2. \\<And>s. finite {fold delta_okm w (init_okm s) |w. True}", "case (3 br)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>s. nullable_okm s = ([] \\<in> lang_okm s)\n 2. \\<And>s. finite {fold delta_okm w (init_okm s) |w. True}", "show  \"nullable_okm br = ([] \\<in> lang_okm br)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nullable_okm br = ([] \\<in> lang_okm br)", "by transfer (simp add: split_beta)"], ["proof (state)\nthis:\n  nullable_okm br = ([] \\<in> lang_okm br)\n\ngoal (1 subgoal):\n 1. \\<And>s. finite {fold delta_okm w (init_okm s) |w. True}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. finite {fold delta_okm w (init_okm s) |w. True}", "case (4 s)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>s. finite {fold delta_okm w (init_okm s) |w. True}", "have \"{fold (\\<lambda>a (m, r). (False, shift2 m r a)) w (True, empty_mrexp2 s) |w. True} \\<subseteq>\n    UNIV \\<times> mrexps2 s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {fold (\\<lambda>a (m, r). (False, shift2 m r a)) w\n      (True, empty_mrexp2 s) |\n     w. True}\n    \\<subseteq> UNIV \\<times> mrexps2 s", "proof (intro subsetI, elim CollectE exE conjE, hypsubst)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x w.\n       True \\<Longrightarrow>\n       fold (\\<lambda>a (m, r). (False, shift2 m r a)) w\n        (True, empty_mrexp2 s)\n       \\<in> UNIV \\<times> mrexps2 s", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x w.\n       True \\<Longrightarrow>\n       fold (\\<lambda>a (m, r). (False, shift2 m r a)) w\n        (True, empty_mrexp2 s)\n       \\<in> UNIV \\<times> mrexps2 s", "show \"fold (\\<lambda>a (m, r). (False, shift2 m r a)) w (True, empty_mrexp2 s) \\<in>\n      UNIV \\<times> mrexps2 s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>a (m, r). (False, shift2 m r a)) w (True, empty_mrexp2 s)\n    \\<in> UNIV \\<times> mrexps2 s", "by (induct w rule: rev_induct) (auto simp: split: prod.splits intro!: shift2_mrexps2)"], ["proof (state)\nthis:\n  fold (\\<lambda>a (m, r). (False, shift2 m r a)) w (True, empty_mrexp2 s)\n  \\<in> UNIV \\<times> mrexps2 s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {fold (\\<lambda>a (m, r). (False, shift2 m r a)) w\n    (True, empty_mrexp2 s) |\n   w. True}\n  \\<subseteq> UNIV \\<times> mrexps2 s\n\ngoal (1 subgoal):\n 1. \\<And>s. finite {fold delta_okm w (init_okm s) |w. True}", "then"], ["proof (chain)\npicking this:\n  {fold (\\<lambda>a (m, r). (False, shift2 m r a)) w\n    (True, empty_mrexp2 s) |\n   w. True}\n  \\<subseteq> UNIV \\<times> mrexps2 s", "show \"finite {fold delta_okm w (init_okm s) |w. True}\""], ["proof (prove)\nusing this:\n  {fold (\\<lambda>a (m, r). (False, shift2 m r a)) w\n    (True, empty_mrexp2 s) |\n   w. True}\n  \\<subseteq> UNIV \\<times> mrexps2 s\n\ngoal (1 subgoal):\n 1. finite {fold delta_okm w (init_okm s) |w. True}", "by transfer (erule finite_subset[OF subset_trans[rotated]], auto)"], ["proof (state)\nthis:\n  finite {fold delta_okm w (init_okm s) |w. True}\n\ngoal:\nNo subgoals!", "qed"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}