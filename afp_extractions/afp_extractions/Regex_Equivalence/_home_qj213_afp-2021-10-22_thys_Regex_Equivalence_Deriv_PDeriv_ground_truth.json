{"file_name": "/home/qj213/afp-2021-10-22/thys/Regex_Equivalence/Deriv_PDeriv.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Regex_Equivalence", "problem_names": ["lemma pderiv_not_is_Zero_is_Plus[simp]: \"\\<forall>x \\<in> pderiv a r. \\<not> is_Zero x \\<and> \\<not> is_Plus x\"", "lemma finite_pderiv[simp]: \"finite (pderiv a r)\"", "lemma PLUS_inject: \"\\<lbrakk>\\<forall>x \\<in> set xs \\<union> set ys. \\<not> is_Zero x \\<and> \\<not> is_Plus x; sorted xs; sorted ys\\<rbrakk> \\<Longrightarrow>\n  (PLUS xs = PLUS ys) \\<longleftrightarrow> xs = ys\"", "lemma sorted_list_of_set_inject: \"\\<lbrakk>finite R; finite S\\<rbrakk> \\<Longrightarrow>\n  (sorted_list_of_set R = sorted_list_of_set S) \\<longleftrightarrow> R = S\"", "lemma flatten_PLUS_inject: \"\\<lbrakk>\\<forall>x \\<in> R \\<union> S. \\<not> is_Zero x \\<and> \\<not> is_Plus x; finite R; finite S\\<rbrakk> \\<Longrightarrow>\n  (flatten PLUS R = flatten PLUS S) = (R = S)\"", "lemma pset_not_is_Zero_is_Plus[simp]: \"\\<forall>x \\<in> pset r. \\<not> is_Zero x \\<and> \\<not> is_Plus x\"", "lemma finite_pset[simp]: \"finite (pset r)\"", "lemma pset_deriv: \"pset (deriv a r) = pderiv a r\"", "lemma pnorm_deriv_eq_iff_pderiv_eq:\n  \"pnorm (deriv a r) = pnorm (deriv a s) \\<longleftrightarrow> pderiv a r = pderiv a s\"", "lemma pset_pnPlus:\n  \"pset (pnPlus r s) = pset (Plus r s)\"", "lemma pset_pnTimes:\n  \"pset (pnTimes r s) = pset (Times r s)\"", "lemma pset_pnorm_alt_Times: \"s \\<in> pset r \\<Longrightarrow> pnTimes (pnorm_alt s) t = Times (pnorm_alt s) t\"", "lemma pset_pnorm_alt:\n  \"pset (pnorm_alt r) = pnorm_alt ` pset r\"", "lemma pset_pnTimes_Times: \"s \\<in> pset r \\<Longrightarrow> pnTimes s t = Times s t\"", "lemma pset_pnorm_alt_id: \"s \\<in> pset r \\<Longrightarrow> pnorm_alt s = s\"", "lemma pnorm_alt_image_pset: \"pnorm_alt ` pset r = pset r\"", "lemma pnorm_pnorm_alt: \"pnorm (pnorm_alt r) = pnorm r\"", "lemma pnPlus_singleton_PLUS: \n  \"\\<lbrakk>xs \\<noteq> []; sorted xs; distinct xs; \\<forall>x \\<in> {x} \\<union> set xs. \\<not>is_Zero x \\<and> \\<not>is_Plus x\\<rbrakk> \\<Longrightarrow>\n  pnPlus x (PLUS xs) = (if x \\<in> set xs then PLUS xs else PLUS (insort x xs))\"", "lemma pnPlus_PlusL[simp]: \"t \\<noteq> Zero \\<Longrightarrow> pnPlus (Plus r s) t = pnPlus r (pnPlus s t)\"", "lemma pnPlus_ZeroR[simp]: \"pnPlus r Zero = r\"", "lemma PLUS_eq_Zero: \"PLUS xs = Zero \\<longleftrightarrow> xs = [] \\<or> xs = [Zero]\"", "lemma pnPlus_PLUS:\n  \"\\<lbrakk>xs1 \\<noteq> []; xs2 \\<noteq> []; \\<forall>x \\<in> set (xs1 @ xs2). \\<not>is_Zero x \\<and> \\<not>is_Plus x; sorted xs2; distinct xs2\\<rbrakk>\\<Longrightarrow>\n  pnPlus (PLUS xs1) (PLUS xs2) = flatten PLUS (set (xs1 @ xs2))\"", "lemma pnPlus_flatten_PLUS:\n  \"\\<lbrakk>X1 \\<noteq> {}; X2 \\<noteq> {}; finite X1; finite X2; \\<forall>x \\<in> X1 \\<union> X2.  \\<not>is_Zero x \\<and> \\<not>is_Plus x\\<rbrakk>\\<Longrightarrow>\n  pnPlus (flatten PLUS X1) (flatten PLUS X2) = flatten PLUS (X1 \\<union> X2)\"", "lemma pnPlus_pnorm: \"pnPlus (pnorm r) (pnorm s) = pnorm (Plus r s)\"", "lemma pnTimes_not_Zero_or_Plus[simp]: \"\\<lbrakk>\\<not> is_Zero x; \\<not> is_Plus x\\<rbrakk> \\<Longrightarrow> pnTimes x r = Times x r\"", "lemma pnTimes_PLUS:\n  \"\\<lbrakk>xs \\<noteq> []; \\<forall>x \\<in> set xs. \\<not>is_Zero x \\<and> \\<not>is_Plus x\\<rbrakk>\\<Longrightarrow>\n  pnTimes (PLUS xs) r = flatten PLUS (Timess (set xs) r)\"", "lemma pnTimes_flatten_PLUS:\n  \"\\<lbrakk>X1 \\<noteq> {}; finite X1; \\<forall>x \\<in> X1. \\<not>is_Zero x \\<and> \\<not>is_Plus x\\<rbrakk>\\<Longrightarrow>\n  pnTimes (flatten PLUS X1) r = flatten PLUS (Timess X1 r)\"", "lemma pnTimes_pnorm: \"pnTimes (pnorm r1) r2 = pnorm (Times r1 r2)\"", "lemma pnorm_alt[symmetric]: \"pnorm_alt r = pnorm r\"", "lemma insort_eq_Cons: \"\\<lbrakk>\\<forall>a \\<in> set xs. b < a; sorted xs\\<rbrakk> \\<Longrightarrow> insort b xs = b # xs\"", "lemma pderiv_PLUS: \"pderiv a (PLUS (x # xs)) = pderiv a x \\<union> pderiv a (PLUS xs)\"", "lemma pderiv_set_flatten_PLUS:\n   \"finite X \\<Longrightarrow> pderiv (a :: 'a :: linorder) (flatten PLUS X) = pderiv_set a X\"", "lemma fold_pderiv_set_flatten_PLUS:\n  \"\\<lbrakk>w \\<noteq> []; finite X\\<rbrakk> \\<Longrightarrow> fold pderiv_set w {flatten PLUS X} = fold pderiv_set w X\"", "lemma fold_pnorm_deriv:\n  \"fold (\\<lambda>a r. pnorm (deriv a r)) w s = flatten PLUS (fold pderiv_set w {s})\"", "lemma pnderiv_alt[code]: \"pnderiv a r = pnorm (deriv a r)\"", "lemma pnderiv_pderiv: \"pnderiv a r = flatten PLUS (pderiv a r)\""], "translations": [["", "lemma pderiv_not_is_Zero_is_Plus[simp]: \"\\<forall>x \\<in> pderiv a r. \\<not> is_Zero x \\<and> \\<not> is_Plus x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>pderiv a r. \\<not> is_Zero x \\<and> \\<not> is_Plus x", "by (induct r) auto"], ["", "lemma finite_pderiv[simp]: \"finite (pderiv a r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (pderiv a r)", "by (induct r) auto"], ["", "lemma PLUS_inject: \"\\<lbrakk>\\<forall>x \\<in> set xs \\<union> set ys. \\<not> is_Zero x \\<and> \\<not> is_Plus x; sorted xs; sorted ys\\<rbrakk> \\<Longrightarrow>\n  (PLUS xs = PLUS ys) \\<longleftrightarrow> xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs \\<union> set ys.\n                \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n     sorted xs; sorted ys\\<rbrakk>\n    \\<Longrightarrow> (PLUS xs = PLUS ys) = (xs = ys)", "proof (induct xs arbitrary: ys rule: list_singleton_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>\\<forall>x\\<in>set [] \\<union> set ys.\n                   \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n        sorted []; sorted ys\\<rbrakk>\n       \\<Longrightarrow> (PLUS [] = PLUS ys) = ([] = ys)\n 2. \\<And>x ys.\n       \\<lbrakk>\\<forall>x\\<in>set [x] \\<union> set ys.\n                   \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n        sorted [x]; sorted ys\\<rbrakk>\n       \\<Longrightarrow> (PLUS [x] = PLUS ys) = ([x] = ys)\n 3. \\<And>x y xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>\\<forall>x\\<in>set (y # xs) \\<union> set ys.\n                               \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n                    sorted (y # xs); sorted ys\\<rbrakk>\n                   \\<Longrightarrow> (PLUS (y # xs) = PLUS ys) =\n                                     (y # xs = ys);\n        \\<forall>x\\<in>set (x # y # xs) \\<union> set ys.\n           \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n        sorted (x # y # xs); sorted ys\\<rbrakk>\n       \\<Longrightarrow> (PLUS (x # y # xs) = PLUS ys) = (x # y # xs = ys)", "case nil"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set [] \\<union> set ys.\n     \\<not> is_Zero x \\<and> \\<not> is_Plus x\n  sorted []\n  sorted ys\n\ngoal (3 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>\\<forall>x\\<in>set [] \\<union> set ys.\n                   \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n        sorted []; sorted ys\\<rbrakk>\n       \\<Longrightarrow> (PLUS [] = PLUS ys) = ([] = ys)\n 2. \\<And>x ys.\n       \\<lbrakk>\\<forall>x\\<in>set [x] \\<union> set ys.\n                   \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n        sorted [x]; sorted ys\\<rbrakk>\n       \\<Longrightarrow> (PLUS [x] = PLUS ys) = ([x] = ys)\n 3. \\<And>x y xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>\\<forall>x\\<in>set (y # xs) \\<union> set ys.\n                               \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n                    sorted (y # xs); sorted ys\\<rbrakk>\n                   \\<Longrightarrow> (PLUS (y # xs) = PLUS ys) =\n                                     (y # xs = ys);\n        \\<forall>x\\<in>set (x # y # xs) \\<union> set ys.\n           \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n        sorted (x # y # xs); sorted ys\\<rbrakk>\n       \\<Longrightarrow> (PLUS (x # y # xs) = PLUS ys) = (x # y # xs = ys)", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set [] \\<union> set ys.\n     \\<not> is_Zero x \\<and> \\<not> is_Plus x\n  sorted []\n  sorted ys", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set [] \\<union> set ys.\n     \\<not> is_Zero x \\<and> \\<not> is_Plus x\n  sorted []\n  sorted ys\n\ngoal (1 subgoal):\n 1. (PLUS [] = PLUS ys) = ([] = ys)", "by (induct ys rule: list_singleton_induct) auto"], ["proof (state)\nthis:\n  (PLUS [] = PLUS ys) = ([] = ys)\n\ngoal (2 subgoals):\n 1. \\<And>x ys.\n       \\<lbrakk>\\<forall>x\\<in>set [x] \\<union> set ys.\n                   \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n        sorted [x]; sorted ys\\<rbrakk>\n       \\<Longrightarrow> (PLUS [x] = PLUS ys) = ([x] = ys)\n 2. \\<And>x y xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>\\<forall>x\\<in>set (y # xs) \\<union> set ys.\n                               \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n                    sorted (y # xs); sorted ys\\<rbrakk>\n                   \\<Longrightarrow> (PLUS (y # xs) = PLUS ys) =\n                                     (y # xs = ys);\n        \\<forall>x\\<in>set (x # y # xs) \\<union> set ys.\n           \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n        sorted (x # y # xs); sorted ys\\<rbrakk>\n       \\<Longrightarrow> (PLUS (x # y # xs) = PLUS ys) = (x # y # xs = ys)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x ys.\n       \\<lbrakk>\\<forall>x\\<in>set [x] \\<union> set ys.\n                   \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n        sorted [x]; sorted ys\\<rbrakk>\n       \\<Longrightarrow> (PLUS [x] = PLUS ys) = ([x] = ys)\n 2. \\<And>x y xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>\\<forall>x\\<in>set (y # xs) \\<union> set ys.\n                               \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n                    sorted (y # xs); sorted ys\\<rbrakk>\n                   \\<Longrightarrow> (PLUS (y # xs) = PLUS ys) =\n                                     (y # xs = ys);\n        \\<forall>x\\<in>set (x # y # xs) \\<union> set ys.\n           \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n        sorted (x # y # xs); sorted ys\\<rbrakk>\n       \\<Longrightarrow> (PLUS (x # y # xs) = PLUS ys) = (x # y # xs = ys)", "case single"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set [x_] \\<union> set ys.\n     \\<not> is_Zero x \\<and> \\<not> is_Plus x\n  sorted [x_]\n  sorted ys\n\ngoal (2 subgoals):\n 1. \\<And>x ys.\n       \\<lbrakk>\\<forall>x\\<in>set [x] \\<union> set ys.\n                   \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n        sorted [x]; sorted ys\\<rbrakk>\n       \\<Longrightarrow> (PLUS [x] = PLUS ys) = ([x] = ys)\n 2. \\<And>x y xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>\\<forall>x\\<in>set (y # xs) \\<union> set ys.\n                               \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n                    sorted (y # xs); sorted ys\\<rbrakk>\n                   \\<Longrightarrow> (PLUS (y # xs) = PLUS ys) =\n                                     (y # xs = ys);\n        \\<forall>x\\<in>set (x # y # xs) \\<union> set ys.\n           \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n        sorted (x # y # xs); sorted ys\\<rbrakk>\n       \\<Longrightarrow> (PLUS (x # y # xs) = PLUS ys) = (x # y # xs = ys)", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set [x_] \\<union> set ys.\n     \\<not> is_Zero x \\<and> \\<not> is_Plus x\n  sorted [x_]\n  sorted ys", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set [x_] \\<union> set ys.\n     \\<not> is_Zero x \\<and> \\<not> is_Plus x\n  sorted [x_]\n  sorted ys\n\ngoal (1 subgoal):\n 1. (PLUS [x_] = PLUS ys) = ([x_] = ys)", "by (induct ys rule: list_singleton_induct) auto"], ["proof (state)\nthis:\n  (PLUS [x_] = PLUS ys) = ([x_] = ys)\n\ngoal (1 subgoal):\n 1. \\<And>x y xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>\\<forall>x\\<in>set (y # xs) \\<union> set ys.\n                               \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n                    sorted (y # xs); sorted ys\\<rbrakk>\n                   \\<Longrightarrow> (PLUS (y # xs) = PLUS ys) =\n                                     (y # xs = ys);\n        \\<forall>x\\<in>set (x # y # xs) \\<union> set ys.\n           \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n        sorted (x # y # xs); sorted ys\\<rbrakk>\n       \\<Longrightarrow> (PLUS (x # y # xs) = PLUS ys) = (x # y # xs = ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>\\<forall>x\\<in>set (y # xs) \\<union> set ys.\n                               \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n                    sorted (y # xs); sorted ys\\<rbrakk>\n                   \\<Longrightarrow> (PLUS (y # xs) = PLUS ys) =\n                                     (y # xs = ys);\n        \\<forall>x\\<in>set (x # y # xs) \\<union> set ys.\n           \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n        sorted (x # y # xs); sorted ys\\<rbrakk>\n       \\<Longrightarrow> (PLUS (x # y # xs) = PLUS ys) = (x # y # xs = ys)", "case cons"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>x\\<in>set (y_ # xs_) \\<union> set ?ys.\n              \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n   sorted (y_ # xs_); sorted ?ys\\<rbrakk>\n  \\<Longrightarrow> (PLUS (y_ # xs_) = PLUS ?ys) = (y_ # xs_ = ?ys)\n  \\<forall>x\\<in>set (x_ # y_ # xs_) \\<union> set ys.\n     \\<not> is_Zero x \\<and> \\<not> is_Plus x\n  sorted (x_ # y_ # xs_)\n  sorted ys\n\ngoal (1 subgoal):\n 1. \\<And>x y xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>\\<forall>x\\<in>set (y # xs) \\<union> set ys.\n                               \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n                    sorted (y # xs); sorted ys\\<rbrakk>\n                   \\<Longrightarrow> (PLUS (y # xs) = PLUS ys) =\n                                     (y # xs = ys);\n        \\<forall>x\\<in>set (x # y # xs) \\<union> set ys.\n           \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n        sorted (x # y # xs); sorted ys\\<rbrakk>\n       \\<Longrightarrow> (PLUS (x # y # xs) = PLUS ys) = (x # y # xs = ys)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>x\\<in>set (y_ # xs_) \\<union> set ?ys.\n              \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n   sorted (y_ # xs_); sorted ?ys\\<rbrakk>\n  \\<Longrightarrow> (PLUS (y_ # xs_) = PLUS ?ys) = (y_ # xs_ = ?ys)\n  \\<forall>x\\<in>set (x_ # y_ # xs_) \\<union> set ys.\n     \\<not> is_Zero x \\<and> \\<not> is_Plus x\n  sorted (x_ # y_ # xs_)\n  sorted ys", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>x\\<in>set (y_ # xs_) \\<union> set ?ys.\n              \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n   sorted (y_ # xs_); sorted ?ys\\<rbrakk>\n  \\<Longrightarrow> (PLUS (y_ # xs_) = PLUS ?ys) = (y_ # xs_ = ?ys)\n  \\<forall>x\\<in>set (x_ # y_ # xs_) \\<union> set ys.\n     \\<not> is_Zero x \\<and> \\<not> is_Plus x\n  sorted (x_ # y_ # xs_)\n  sorted ys\n\ngoal (1 subgoal):\n 1. (PLUS (x_ # y_ # xs_) = PLUS ys) = (x_ # y_ # xs_ = ys)", "by (induct ys rule: list_singleton_induct) auto"], ["proof (state)\nthis:\n  (PLUS (x_ # y_ # xs_) = PLUS ys) = (x_ # y_ # xs_ = ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sorted_list_of_set_inject: \"\\<lbrakk>finite R; finite S\\<rbrakk> \\<Longrightarrow>\n  (sorted_list_of_set R = sorted_list_of_set S) \\<longleftrightarrow> R = S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite R; finite S\\<rbrakk>\n    \\<Longrightarrow> flatten (flatten (=) R) S = (R = S)", "proof (induct R arbitrary: S rule: finite_linorder_min_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>S.\n       finite S \\<Longrightarrow> flatten (flatten (=) {}) S = ({} = S)\n 2. \\<And>b A S.\n       \\<lbrakk>finite A; \\<forall>a\\<in>A. b < a;\n        \\<And>S.\n           finite S \\<Longrightarrow> flatten (flatten (=) A) S = (A = S);\n        finite S\\<rbrakk>\n       \\<Longrightarrow> flatten (flatten (=) (insert b A)) S =\n                         (insert b A = S)", "case empty"], ["proof (state)\nthis:\n  finite S\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       finite S \\<Longrightarrow> flatten (flatten (=) {}) S = ({} = S)\n 2. \\<And>b A S.\n       \\<lbrakk>finite A; \\<forall>a\\<in>A. b < a;\n        \\<And>S.\n           finite S \\<Longrightarrow> flatten (flatten (=) A) S = (A = S);\n        finite S\\<rbrakk>\n       \\<Longrightarrow> flatten (flatten (=) (insert b A)) S =\n                         (insert b A = S)", "then"], ["proof (chain)\npicking this:\n  finite S", "show ?case"], ["proof (prove)\nusing this:\n  finite S\n\ngoal (1 subgoal):\n 1. flatten (flatten (=) {}) S = ({} = S)", "proof (induct S rule: finite_linorder_min_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. flatten (flatten (=) {}) {} = ({} = {})\n 2. \\<And>b A.\n       \\<lbrakk>finite A; \\<forall>a\\<in>A. b < a;\n        flatten (flatten (=) {}) A = ({} = A)\\<rbrakk>\n       \\<Longrightarrow> flatten (flatten (=) {}) (insert b A) =\n                         ({} = insert b A)", "case (insert b S)"], ["proof (state)\nthis:\n  finite S\n  \\<forall>a\\<in>S. b < a\n  flatten (flatten (=) {}) S = ({} = S)\n\ngoal (2 subgoals):\n 1. flatten (flatten (=) {}) {} = ({} = {})\n 2. \\<And>b A.\n       \\<lbrakk>finite A; \\<forall>a\\<in>A. b < a;\n        flatten (flatten (=) {}) A = ({} = A)\\<rbrakk>\n       \\<Longrightarrow> flatten (flatten (=) {}) (insert b A) =\n                         ({} = insert b A)", "then"], ["proof (chain)\npicking this:\n  finite S\n  \\<forall>a\\<in>S. b < a\n  flatten (flatten (=) {}) S = ({} = S)", "show ?case"], ["proof (prove)\nusing this:\n  finite S\n  \\<forall>a\\<in>S. b < a\n  flatten (flatten (=) {}) S = ({} = S)\n\ngoal (1 subgoal):\n 1. flatten (flatten (=) {}) (insert b S) = ({} = insert b S)", "by simp (metis insort_not_Nil)"], ["proof (state)\nthis:\n  flatten (flatten (=) {}) (insert b S) = ({} = insert b S)\n\ngoal (1 subgoal):\n 1. flatten (flatten (=) {}) {} = ({} = {})", "qed simp"], ["proof (state)\nthis:\n  flatten (flatten (=) {}) S = ({} = S)\n\ngoal (1 subgoal):\n 1. \\<And>b A S.\n       \\<lbrakk>finite A; \\<forall>a\\<in>A. b < a;\n        \\<And>S.\n           finite S \\<Longrightarrow> flatten (flatten (=) A) S = (A = S);\n        finite S\\<rbrakk>\n       \\<Longrightarrow> flatten (flatten (=) (insert b A)) S =\n                         (insert b A = S)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b A S.\n       \\<lbrakk>finite A; \\<forall>a\\<in>A. b < a;\n        \\<And>S.\n           finite S \\<Longrightarrow> flatten (flatten (=) A) S = (A = S);\n        finite S\\<rbrakk>\n       \\<Longrightarrow> flatten (flatten (=) (insert b A)) S =\n                         (insert b A = S)", "case (insert a R)"], ["proof (state)\nthis:\n  finite R\n  \\<forall>aa\\<in>R. a < aa\n  finite ?S \\<Longrightarrow> flatten (flatten (=) R) ?S = (R = ?S)\n  finite S\n\ngoal (1 subgoal):\n 1. \\<And>b A S.\n       \\<lbrakk>finite A; \\<forall>a\\<in>A. b < a;\n        \\<And>S.\n           finite S \\<Longrightarrow> flatten (flatten (=) A) S = (A = S);\n        finite S\\<rbrakk>\n       \\<Longrightarrow> flatten (flatten (=) (insert b A)) S =\n                         (insert b A = S)", "from this(4,1-3)"], ["proof (chain)\npicking this:\n  finite S\n  finite R\n  \\<forall>aa\\<in>R. a < aa\n  finite ?S \\<Longrightarrow> flatten (flatten (=) R) ?S = (R = ?S)", "show ?case"], ["proof (prove)\nusing this:\n  finite S\n  finite R\n  \\<forall>aa\\<in>R. a < aa\n  finite ?S \\<Longrightarrow> flatten (flatten (=) R) ?S = (R = ?S)\n\ngoal (1 subgoal):\n 1. flatten (flatten (=) (insert a R)) S = (insert a R = S)", "proof (induct S rule: finite_linorder_min_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite R; Ball R ((<) a);\n     \\<And>S.\n        finite S \\<Longrightarrow>\n        flatten (flatten (=) R) S = (R = S)\\<rbrakk>\n    \\<Longrightarrow> flatten (flatten (=) (insert a R)) {} =\n                      (insert a R = {})\n 2. \\<And>b A.\n       \\<lbrakk>finite A; \\<forall>a\\<in>A. b < a;\n        \\<lbrakk>finite R; Ball R ((<) a);\n         \\<And>S.\n            finite S \\<Longrightarrow>\n            flatten (flatten (=) R) S = (R = S)\\<rbrakk>\n        \\<Longrightarrow> flatten (flatten (=) (insert a R)) A =\n                          (insert a R = A);\n        finite R; Ball R ((<) a);\n        \\<And>S.\n           finite S \\<Longrightarrow>\n           flatten (flatten (=) R) S = (R = S)\\<rbrakk>\n       \\<Longrightarrow> flatten (flatten (=) (insert a R)) (insert b A) =\n                         (insert a R = insert b A)", "case (insert b S)"], ["proof (state)\nthis:\n  finite S\n  \\<forall>a\\<in>S. b < a\n  \\<lbrakk>finite R; \\<forall>b\\<in>R. a < b;\n   \\<And>S.\n      finite S \\<Longrightarrow>\n      flatten (flatten (=) R) S = (R = S)\\<rbrakk>\n  \\<Longrightarrow> flatten (flatten (=) (insert a R)) S = (insert a R = S)\n  finite R\n  \\<forall>b\\<in>R. a < b\n  finite ?S \\<Longrightarrow> flatten (flatten (=) R) ?S = (R = ?S)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>finite R; Ball R ((<) a);\n     \\<And>S.\n        finite S \\<Longrightarrow>\n        flatten (flatten (=) R) S = (R = S)\\<rbrakk>\n    \\<Longrightarrow> flatten (flatten (=) (insert a R)) {} =\n                      (insert a R = {})\n 2. \\<And>b A.\n       \\<lbrakk>finite A; \\<forall>a\\<in>A. b < a;\n        \\<lbrakk>finite R; Ball R ((<) a);\n         \\<And>S.\n            finite S \\<Longrightarrow>\n            flatten (flatten (=) R) S = (R = S)\\<rbrakk>\n        \\<Longrightarrow> flatten (flatten (=) (insert a R)) A =\n                          (insert a R = A);\n        finite R; Ball R ((<) a);\n        \\<And>S.\n           finite S \\<Longrightarrow>\n           flatten (flatten (=) R) S = (R = S)\\<rbrakk>\n       \\<Longrightarrow> flatten (flatten (=) (insert a R)) (insert b A) =\n                         (insert a R = insert b A)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten (flatten (=) (insert a R)) (insert b S) =\n    (insert a R = insert b S)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. flatten (flatten (=) (insert a R)) (insert b S) \\<Longrightarrow>\n    insert a R = insert b S\n 2. insert a R = insert b S \\<Longrightarrow>\n    flatten (flatten (=) (insert a R)) (insert b S)", "assume \"sorted_list_of_set (insert a R) = sorted_list_of_set (insert b S)\""], ["proof (state)\nthis:\n  flatten (flatten (=) (insert a R)) (insert b S)\n\ngoal (2 subgoals):\n 1. flatten (flatten (=) (insert a R)) (insert b S) \\<Longrightarrow>\n    insert a R = insert b S\n 2. insert a R = insert b S \\<Longrightarrow>\n    flatten (flatten (=) (insert a R)) (insert b S)", "with insert(1,2,4,5)"], ["proof (chain)\npicking this:\n  finite S\n  \\<forall>a\\<in>S. b < a\n  finite R\n  \\<forall>b\\<in>R. a < b\n  flatten (flatten (=) (insert a R)) (insert b S)", "have \"insort a (sorted_list_of_set R) = insort b (sorted_list_of_set S)\""], ["proof (prove)\nusing this:\n  finite S\n  \\<forall>a\\<in>S. b < a\n  finite R\n  \\<forall>b\\<in>R. a < b\n  flatten (flatten (=) (insert a R)) (insert b S)\n\ngoal (1 subgoal):\n 1. flatten (insort a) R = flatten (insort b) S", "by (elim box_equals[OF _ sorted_list_of_set.insert sorted_list_of_set.insert]) auto"], ["proof (state)\nthis:\n  flatten (insort a) R = flatten (insort b) S\n\ngoal (2 subgoals):\n 1. flatten (flatten (=) (insert a R)) (insert b S) \\<Longrightarrow>\n    insert a R = insert b S\n 2. insert a R = insert b S \\<Longrightarrow>\n    flatten (flatten (=) (insert a R)) (insert b S)", "with insert(2,5)"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>S. b < a\n  \\<forall>b\\<in>R. a < b\n  flatten (insort a) R = flatten (insort b) S", "have \"a # sorted_list_of_set R = b # sorted_list_of_set S\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>S. b < a\n  \\<forall>b\\<in>R. a < b\n  flatten (insort a) R = flatten (insort b) S\n\ngoal (1 subgoal):\n 1. flatten ((#) a) R = flatten ((#) b) S", "apply (cases \"sorted_list_of_set R\" \"sorted_list_of_set S\" rule: list.exhaust[case_product list.exhaust])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>a\\<in>S. b < a; \\<forall>b\\<in>R. a < b;\n     flatten (insort a) R = flatten (insort b) S; flatten (=) R [];\n     flatten (=) S []\\<rbrakk>\n    \\<Longrightarrow> flatten ((#) a) R = flatten ((#) b) S\n 2. \\<And>x21__ x22__.\n       \\<lbrakk>\\<forall>a\\<in>S. b < a; \\<forall>b\\<in>R. a < b;\n        flatten (insort a) R = flatten (insort b) S; flatten (=) R [];\n        flatten (=) S (x21__ # x22__)\\<rbrakk>\n       \\<Longrightarrow> flatten ((#) a) R = flatten ((#) b) S\n 3. \\<And>x21__ x22__.\n       \\<lbrakk>\\<forall>a\\<in>S. b < a; \\<forall>b\\<in>R. a < b;\n        flatten (insort a) R = flatten (insort b) S;\n        flatten (=) R (x21__ # x22__); flatten (=) S []\\<rbrakk>\n       \\<Longrightarrow> flatten ((#) a) R = flatten ((#) b) S\n 4. \\<And>x21__ x22__ x21a__ x22a__.\n       \\<lbrakk>\\<forall>a\\<in>S. b < a; \\<forall>b\\<in>R. a < b;\n        flatten (insort a) R = flatten (insort b) S;\n        flatten (=) R (x21__ # x22__);\n        flatten (=) S (x21a__ # x22a__)\\<rbrakk>\n       \\<Longrightarrow> flatten ((#) a) R = flatten ((#) b) S", "apply (auto split: if_splits simp add: not_le)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x22__.\n       \\<lbrakk>flatten (=) R []; flatten (=) S (a # x22__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; a < b;\n        [] = insort b x22__\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x22__ x21a__ x22a__.\n       \\<lbrakk>flatten (=) R (b # x22__); flatten (=) S (x21a__ # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; b \\<le> x21a__;\n        b < a; insort a x22__ = x21a__ # x22a__\\<rbrakk>\n       \\<Longrightarrow> a = b\n 3. \\<And>x22__ x21a__ x22a__.\n       \\<lbrakk>flatten (=) R (b # x22__); flatten (=) S (x21a__ # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; b \\<le> x21a__;\n        b < a; insort a x22__ = x21a__ # x22a__\\<rbrakk>\n       \\<Longrightarrow> b = x21a__\n 4. \\<And>x22__ x21a__ x22a__.\n       \\<lbrakk>flatten (=) R (b # x22__); flatten (=) S (x21a__ # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; b \\<le> x21a__;\n        b < a; insort a x22__ = x21a__ # x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__\n 5. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (insort b x22a__); flatten (=) S (a # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; a < b;\n        a \\<le> x21__; x21__ # x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> a = b\n 6. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (insort b x22a__); flatten (=) S (a # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; a < b;\n        a \\<le> x21__; x21__ # x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x21__ = a\n 7. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (insort b x22a__); flatten (=) S (a # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; a < b;\n        a \\<le> x21__; x21__ # x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__\n 8. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (x21__ # x22__);\n        flatten (=) S (x21__ # x22a__); \\<forall>x\\<in>S. b < x;\n        \\<forall>x\\<in>R. a < x; x21__ < b; x21__ < a;\n        insort a x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> a = b\n 9. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (x21__ # x22__);\n        flatten (=) S (x21__ # x22a__); \\<forall>x\\<in>S. b < x;\n        \\<forall>x\\<in>R. a < x; x21__ < b; x21__ < a;\n        insort a x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__", "using insort_not_Nil"], ["proof (prove)\nusing this:\n  insort_key ?f ?a ?xs \\<noteq> []\n\ngoal (9 subgoals):\n 1. \\<And>x22__.\n       \\<lbrakk>flatten (=) R []; flatten (=) S (a # x22__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; a < b;\n        [] = insort b x22__\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x22__ x21a__ x22a__.\n       \\<lbrakk>flatten (=) R (b # x22__); flatten (=) S (x21a__ # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; b \\<le> x21a__;\n        b < a; insort a x22__ = x21a__ # x22a__\\<rbrakk>\n       \\<Longrightarrow> a = b\n 3. \\<And>x22__ x21a__ x22a__.\n       \\<lbrakk>flatten (=) R (b # x22__); flatten (=) S (x21a__ # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; b \\<le> x21a__;\n        b < a; insort a x22__ = x21a__ # x22a__\\<rbrakk>\n       \\<Longrightarrow> b = x21a__\n 4. \\<And>x22__ x21a__ x22a__.\n       \\<lbrakk>flatten (=) R (b # x22__); flatten (=) S (x21a__ # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; b \\<le> x21a__;\n        b < a; insort a x22__ = x21a__ # x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__\n 5. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (insort b x22a__); flatten (=) S (a # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; a < b;\n        a \\<le> x21__; x21__ # x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> a = b\n 6. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (insort b x22a__); flatten (=) S (a # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; a < b;\n        a \\<le> x21__; x21__ # x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x21__ = a\n 7. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (insort b x22a__); flatten (=) S (a # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; a < b;\n        a \\<le> x21__; x21__ # x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__\n 8. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (x21__ # x22__);\n        flatten (=) S (x21__ # x22a__); \\<forall>x\\<in>S. b < x;\n        \\<forall>x\\<in>R. a < x; x21__ < b; x21__ < a;\n        insort a x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> a = b\n 9. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (x21__ # x22__);\n        flatten (=) S (x21__ # x22a__); \\<forall>x\\<in>S. b < x;\n        \\<forall>x\\<in>R. a < x; x21__ < b; x21__ < a;\n        insort a x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__", "apply metis"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x22__ x21a__ x22a__.\n       \\<lbrakk>flatten (=) R (b # x22__); flatten (=) S (x21a__ # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; b \\<le> x21a__;\n        b < a; insort a x22__ = x21a__ # x22a__\\<rbrakk>\n       \\<Longrightarrow> a = b\n 2. \\<And>x22__ x21a__ x22a__.\n       \\<lbrakk>flatten (=) R (b # x22__); flatten (=) S (x21a__ # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; b \\<le> x21a__;\n        b < a; insort a x22__ = x21a__ # x22a__\\<rbrakk>\n       \\<Longrightarrow> b = x21a__\n 3. \\<And>x22__ x21a__ x22a__.\n       \\<lbrakk>flatten (=) R (b # x22__); flatten (=) S (x21a__ # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; b \\<le> x21a__;\n        b < a; insort a x22__ = x21a__ # x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__\n 4. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (insort b x22a__); flatten (=) S (a # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; a < b;\n        a \\<le> x21__; x21__ # x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> a = b\n 5. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (insort b x22a__); flatten (=) S (a # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; a < b;\n        a \\<le> x21__; x21__ # x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x21__ = a\n 6. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (insort b x22a__); flatten (=) S (a # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; a < b;\n        a \\<le> x21__; x21__ # x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__\n 7. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (x21__ # x22__);\n        flatten (=) S (x21__ # x22a__); \\<forall>x\\<in>S. b < x;\n        \\<forall>x\\<in>R. a < x; x21__ < b; x21__ < a;\n        insort a x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> a = b\n 8. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (x21__ # x22__);\n        flatten (=) S (x21__ # x22a__); \\<forall>x\\<in>S. b < x;\n        \\<forall>x\\<in>R. a < x; x21__ < b; x21__ < a;\n        insort a x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__", "using insert.prems(1) set_sorted_list_of_set"], ["proof (prove)\nusing this:\n  finite R\n  finite ?A \\<Longrightarrow> flatten set ?A = ?A\n\ngoal (8 subgoals):\n 1. \\<And>x22__ x21a__ x22a__.\n       \\<lbrakk>flatten (=) R (b # x22__); flatten (=) S (x21a__ # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; b \\<le> x21a__;\n        b < a; insort a x22__ = x21a__ # x22a__\\<rbrakk>\n       \\<Longrightarrow> a = b\n 2. \\<And>x22__ x21a__ x22a__.\n       \\<lbrakk>flatten (=) R (b # x22__); flatten (=) S (x21a__ # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; b \\<le> x21a__;\n        b < a; insort a x22__ = x21a__ # x22a__\\<rbrakk>\n       \\<Longrightarrow> b = x21a__\n 3. \\<And>x22__ x21a__ x22a__.\n       \\<lbrakk>flatten (=) R (b # x22__); flatten (=) S (x21a__ # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; b \\<le> x21a__;\n        b < a; insort a x22__ = x21a__ # x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__\n 4. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (insort b x22a__); flatten (=) S (a # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; a < b;\n        a \\<le> x21__; x21__ # x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> a = b\n 5. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (insort b x22a__); flatten (=) S (a # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; a < b;\n        a \\<le> x21__; x21__ # x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x21__ = a\n 6. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (insort b x22a__); flatten (=) S (a # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; a < b;\n        a \\<le> x21__; x21__ # x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__\n 7. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (x21__ # x22__);\n        flatten (=) S (x21__ # x22a__); \\<forall>x\\<in>S. b < x;\n        \\<forall>x\\<in>R. a < x; x21__ < b; x21__ < a;\n        insort a x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> a = b\n 8. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (x21__ # x22__);\n        flatten (=) S (x21__ # x22a__); \\<forall>x\\<in>S. b < x;\n        \\<forall>x\\<in>R. a < x; x21__ < b; x21__ < a;\n        insort a x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__", "apply fastforce"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x22__ x21a__ x22a__.\n       \\<lbrakk>flatten (=) R (b # x22__); flatten (=) S (x21a__ # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; b \\<le> x21a__;\n        b < a; insort a x22__ = x21a__ # x22a__\\<rbrakk>\n       \\<Longrightarrow> b = x21a__\n 2. \\<And>x22__ x21a__ x22a__.\n       \\<lbrakk>flatten (=) R (b # x22__); flatten (=) S (x21a__ # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; b \\<le> x21a__;\n        b < a; insort a x22__ = x21a__ # x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__\n 3. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (insort b x22a__); flatten (=) S (a # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; a < b;\n        a \\<le> x21__; x21__ # x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> a = b\n 4. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (insort b x22a__); flatten (=) S (a # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; a < b;\n        a \\<le> x21__; x21__ # x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x21__ = a\n 5. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (insort b x22a__); flatten (=) S (a # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; a < b;\n        a \\<le> x21__; x21__ # x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__\n 6. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (x21__ # x22__);\n        flatten (=) S (x21__ # x22a__); \\<forall>x\\<in>S. b < x;\n        \\<forall>x\\<in>R. a < x; x21__ < b; x21__ < a;\n        insort a x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> a = b\n 7. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (x21__ # x22__);\n        flatten (=) S (x21__ # x22a__); \\<forall>x\\<in>S. b < x;\n        \\<forall>x\\<in>R. a < x; x21__ < b; x21__ < a;\n        insort a x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__", "using insert.prems(1) set_sorted_list_of_set"], ["proof (prove)\nusing this:\n  finite R\n  finite ?A \\<Longrightarrow> flatten set ?A = ?A\n\ngoal (7 subgoals):\n 1. \\<And>x22__ x21a__ x22a__.\n       \\<lbrakk>flatten (=) R (b # x22__); flatten (=) S (x21a__ # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; b \\<le> x21a__;\n        b < a; insort a x22__ = x21a__ # x22a__\\<rbrakk>\n       \\<Longrightarrow> b = x21a__\n 2. \\<And>x22__ x21a__ x22a__.\n       \\<lbrakk>flatten (=) R (b # x22__); flatten (=) S (x21a__ # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; b \\<le> x21a__;\n        b < a; insort a x22__ = x21a__ # x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__\n 3. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (insort b x22a__); flatten (=) S (a # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; a < b;\n        a \\<le> x21__; x21__ # x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> a = b\n 4. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (insort b x22a__); flatten (=) S (a # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; a < b;\n        a \\<le> x21__; x21__ # x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x21__ = a\n 5. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (insort b x22a__); flatten (=) S (a # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; a < b;\n        a \\<le> x21__; x21__ # x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__\n 6. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (x21__ # x22__);\n        flatten (=) S (x21__ # x22a__); \\<forall>x\\<in>S. b < x;\n        \\<forall>x\\<in>R. a < x; x21__ < b; x21__ < a;\n        insort a x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> a = b\n 7. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (x21__ # x22__);\n        flatten (=) S (x21__ # x22a__); \\<forall>x\\<in>S. b < x;\n        \\<forall>x\\<in>R. a < x; x21__ < b; x21__ < a;\n        insort a x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__", "apply fastforce"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x22__ x21a__ x22a__.\n       \\<lbrakk>flatten (=) R (b # x22__); flatten (=) S (x21a__ # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; b \\<le> x21a__;\n        b < a; insort a x22__ = x21a__ # x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__\n 2. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (insort b x22a__); flatten (=) S (a # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; a < b;\n        a \\<le> x21__; x21__ # x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> a = b\n 3. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (insort b x22a__); flatten (=) S (a # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; a < b;\n        a \\<le> x21__; x21__ # x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x21__ = a\n 4. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (insort b x22a__); flatten (=) S (a # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; a < b;\n        a \\<le> x21__; x21__ # x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__\n 5. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (x21__ # x22__);\n        flatten (=) S (x21__ # x22a__); \\<forall>x\\<in>S. b < x;\n        \\<forall>x\\<in>R. a < x; x21__ < b; x21__ < a;\n        insort a x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> a = b\n 6. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (x21__ # x22__);\n        flatten (=) S (x21__ # x22a__); \\<forall>x\\<in>S. b < x;\n        \\<forall>x\\<in>R. a < x; x21__ < b; x21__ < a;\n        insort a x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__", "using insert.prems(1) set_sorted_list_of_set"], ["proof (prove)\nusing this:\n  finite R\n  finite ?A \\<Longrightarrow> flatten set ?A = ?A\n\ngoal (6 subgoals):\n 1. \\<And>x22__ x21a__ x22a__.\n       \\<lbrakk>flatten (=) R (b # x22__); flatten (=) S (x21a__ # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; b \\<le> x21a__;\n        b < a; insort a x22__ = x21a__ # x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__\n 2. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (insort b x22a__); flatten (=) S (a # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; a < b;\n        a \\<le> x21__; x21__ # x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> a = b\n 3. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (insort b x22a__); flatten (=) S (a # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; a < b;\n        a \\<le> x21__; x21__ # x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x21__ = a\n 4. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (insort b x22a__); flatten (=) S (a # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; a < b;\n        a \\<le> x21__; x21__ # x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__\n 5. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (x21__ # x22__);\n        flatten (=) S (x21__ # x22a__); \\<forall>x\\<in>S. b < x;\n        \\<forall>x\\<in>R. a < x; x21__ < b; x21__ < a;\n        insort a x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> a = b\n 6. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (x21__ # x22__);\n        flatten (=) S (x21__ # x22a__); \\<forall>x\\<in>S. b < x;\n        \\<forall>x\\<in>R. a < x; x21__ < b; x21__ < a;\n        insort a x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__", "apply fastforce"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (insort b x22a__); flatten (=) S (a # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; a < b;\n        a \\<le> x21__; x21__ # x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> a = b\n 2. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (insort b x22a__); flatten (=) S (a # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; a < b;\n        a \\<le> x21__; x21__ # x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x21__ = a\n 3. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (insort b x22a__); flatten (=) S (a # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; a < b;\n        a \\<le> x21__; x21__ # x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__\n 4. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (x21__ # x22__);\n        flatten (=) S (x21__ # x22a__); \\<forall>x\\<in>S. b < x;\n        \\<forall>x\\<in>R. a < x; x21__ < b; x21__ < a;\n        insort a x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> a = b\n 5. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (x21__ # x22__);\n        flatten (=) S (x21__ # x22a__); \\<forall>x\\<in>S. b < x;\n        \\<forall>x\\<in>R. a < x; x21__ < b; x21__ < a;\n        insort a x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__", "using insert.hyps(1) set_sorted_list_of_set"], ["proof (prove)\nusing this:\n  finite S\n  finite ?A \\<Longrightarrow> flatten set ?A = ?A\n\ngoal (5 subgoals):\n 1. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (insort b x22a__); flatten (=) S (a # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; a < b;\n        a \\<le> x21__; x21__ # x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> a = b\n 2. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (insort b x22a__); flatten (=) S (a # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; a < b;\n        a \\<le> x21__; x21__ # x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x21__ = a\n 3. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (insort b x22a__); flatten (=) S (a # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; a < b;\n        a \\<le> x21__; x21__ # x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__\n 4. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (x21__ # x22__);\n        flatten (=) S (x21__ # x22a__); \\<forall>x\\<in>S. b < x;\n        \\<forall>x\\<in>R. a < x; x21__ < b; x21__ < a;\n        insort a x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> a = b\n 5. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (x21__ # x22__);\n        flatten (=) S (x21__ # x22a__); \\<forall>x\\<in>S. b < x;\n        \\<forall>x\\<in>R. a < x; x21__ < b; x21__ < a;\n        insort a x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__", "apply fastforce"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (insort b x22a__); flatten (=) S (a # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; a < b;\n        a \\<le> x21__; x21__ # x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x21__ = a\n 2. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (insort b x22a__); flatten (=) S (a # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; a < b;\n        a \\<le> x21__; x21__ # x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__\n 3. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (x21__ # x22__);\n        flatten (=) S (x21__ # x22a__); \\<forall>x\\<in>S. b < x;\n        \\<forall>x\\<in>R. a < x; x21__ < b; x21__ < a;\n        insort a x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> a = b\n 4. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (x21__ # x22__);\n        flatten (=) S (x21__ # x22a__); \\<forall>x\\<in>S. b < x;\n        \\<forall>x\\<in>R. a < x; x21__ < b; x21__ < a;\n        insort a x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__", "using insert.hyps(1) set_sorted_list_of_set"], ["proof (prove)\nusing this:\n  finite S\n  finite ?A \\<Longrightarrow> flatten set ?A = ?A\n\ngoal (4 subgoals):\n 1. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (insort b x22a__); flatten (=) S (a # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; a < b;\n        a \\<le> x21__; x21__ # x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x21__ = a\n 2. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (insort b x22a__); flatten (=) S (a # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; a < b;\n        a \\<le> x21__; x21__ # x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__\n 3. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (x21__ # x22__);\n        flatten (=) S (x21__ # x22a__); \\<forall>x\\<in>S. b < x;\n        \\<forall>x\\<in>R. a < x; x21__ < b; x21__ < a;\n        insort a x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> a = b\n 4. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (x21__ # x22__);\n        flatten (=) S (x21__ # x22a__); \\<forall>x\\<in>S. b < x;\n        \\<forall>x\\<in>R. a < x; x21__ < b; x21__ < a;\n        insort a x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__", "apply fastforce"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (insort b x22a__); flatten (=) S (a # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; a < b;\n        a \\<le> x21__; x21__ # x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__\n 2. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (x21__ # x22__);\n        flatten (=) S (x21__ # x22a__); \\<forall>x\\<in>S. b < x;\n        \\<forall>x\\<in>R. a < x; x21__ < b; x21__ < a;\n        insort a x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> a = b\n 3. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (x21__ # x22__);\n        flatten (=) S (x21__ # x22a__); \\<forall>x\\<in>S. b < x;\n        \\<forall>x\\<in>R. a < x; x21__ < b; x21__ < a;\n        insort a x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__", "using insert.hyps(1) set_sorted_list_of_set"], ["proof (prove)\nusing this:\n  finite S\n  finite ?A \\<Longrightarrow> flatten set ?A = ?A\n\ngoal (3 subgoals):\n 1. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (insort b x22a__); flatten (=) S (a # x22a__);\n        \\<forall>x\\<in>S. b < x; \\<forall>x\\<in>R. a < x; a < b;\n        a \\<le> x21__; x21__ # x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__\n 2. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (x21__ # x22__);\n        flatten (=) S (x21__ # x22a__); \\<forall>x\\<in>S. b < x;\n        \\<forall>x\\<in>R. a < x; x21__ < b; x21__ < a;\n        insort a x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> a = b\n 3. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (x21__ # x22__);\n        flatten (=) S (x21__ # x22a__); \\<forall>x\\<in>S. b < x;\n        \\<forall>x\\<in>R. a < x; x21__ < b; x21__ < a;\n        insort a x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (x21__ # x22__);\n        flatten (=) S (x21__ # x22a__); \\<forall>x\\<in>S. b < x;\n        \\<forall>x\\<in>R. a < x; x21__ < b; x21__ < a;\n        insort a x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> a = b\n 2. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (x21__ # x22__);\n        flatten (=) S (x21__ # x22a__); \\<forall>x\\<in>S. b < x;\n        \\<forall>x\\<in>R. a < x; x21__ < b; x21__ < a;\n        insort a x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__", "using insert.hyps(1) set_sorted_list_of_set"], ["proof (prove)\nusing this:\n  finite S\n  finite ?A \\<Longrightarrow> flatten set ?A = ?A\n\ngoal (2 subgoals):\n 1. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (x21__ # x22__);\n        flatten (=) S (x21__ # x22a__); \\<forall>x\\<in>S. b < x;\n        \\<forall>x\\<in>R. a < x; x21__ < b; x21__ < a;\n        insort a x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> a = b\n 2. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (x21__ # x22__);\n        flatten (=) S (x21__ # x22a__); \\<forall>x\\<in>S. b < x;\n        \\<forall>x\\<in>R. a < x; x21__ < b; x21__ < a;\n        insort a x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (x21__ # x22__);\n        flatten (=) S (x21__ # x22a__); \\<forall>x\\<in>S. b < x;\n        \\<forall>x\\<in>R. a < x; x21__ < b; x21__ < a;\n        insort a x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__", "using insert.hyps(1) set_sorted_list_of_set"], ["proof (prove)\nusing this:\n  finite S\n  finite ?A \\<Longrightarrow> flatten set ?A = ?A\n\ngoal (1 subgoal):\n 1. \\<And>x21__ x22__ x22a__.\n       \\<lbrakk>flatten (=) R (x21__ # x22__);\n        flatten (=) S (x21__ # x22a__); \\<forall>x\\<in>S. b < x;\n        \\<forall>x\\<in>R. a < x; x21__ < b; x21__ < a;\n        insort a x22__ = insort b x22a__\\<rbrakk>\n       \\<Longrightarrow> x22__ = x22a__", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  flatten ((#) a) R = flatten ((#) b) S\n\ngoal (2 subgoals):\n 1. flatten (flatten (=) (insert a R)) (insert b S) \\<Longrightarrow>\n    insert a R = insert b S\n 2. insert a R = insert b S \\<Longrightarrow>\n    flatten (flatten (=) (insert a R)) (insert b S)", "with insert"], ["proof (chain)\npicking this:\n  finite S\n  \\<forall>a\\<in>S. b < a\n  \\<lbrakk>finite R; \\<forall>b\\<in>R. a < b;\n   \\<And>S.\n      finite S \\<Longrightarrow>\n      flatten (flatten (=) R) S = (R = S)\\<rbrakk>\n  \\<Longrightarrow> flatten (flatten (=) (insert a R)) S = (insert a R = S)\n  finite R\n  \\<forall>b\\<in>R. a < b\n  finite ?S \\<Longrightarrow> flatten (flatten (=) R) ?S = (R = ?S)\n  flatten ((#) a) R = flatten ((#) b) S", "show \"insert a R = insert b S\""], ["proof (prove)\nusing this:\n  finite S\n  \\<forall>a\\<in>S. b < a\n  \\<lbrakk>finite R; \\<forall>b\\<in>R. a < b;\n   \\<And>S.\n      finite S \\<Longrightarrow>\n      flatten (flatten (=) R) S = (R = S)\\<rbrakk>\n  \\<Longrightarrow> flatten (flatten (=) (insert a R)) S = (insert a R = S)\n  finite R\n  \\<forall>b\\<in>R. a < b\n  finite ?S \\<Longrightarrow> flatten (flatten (=) R) ?S = (R = ?S)\n  flatten ((#) a) R = flatten ((#) b) S\n\ngoal (1 subgoal):\n 1. insert a R = insert b S", "by auto"], ["proof (state)\nthis:\n  insert a R = insert b S\n\ngoal (1 subgoal):\n 1. insert a R = insert b S \\<Longrightarrow>\n    flatten (flatten (=) (insert a R)) (insert b S)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. insert a R = insert b S \\<Longrightarrow>\n    flatten (flatten (=) (insert a R)) (insert b S)", "assume \"insert a R = insert b S\""], ["proof (state)\nthis:\n  insert a R = insert b S\n\ngoal (1 subgoal):\n 1. insert a R = insert b S \\<Longrightarrow>\n    flatten (flatten (=) (insert a R)) (insert b S)", "then"], ["proof (chain)\npicking this:\n  insert a R = insert b S", "show \"sorted_list_of_set (insert a R) = sorted_list_of_set (insert b S)\""], ["proof (prove)\nusing this:\n  insert a R = insert b S\n\ngoal (1 subgoal):\n 1. flatten (flatten (=) (insert a R)) (insert b S)", "by simp"], ["proof (state)\nthis:\n  flatten (flatten (=) (insert a R)) (insert b S)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  flatten (flatten (=) (insert a R)) (insert b S) =\n  (insert a R = insert b S)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite R; Ball R ((<) a);\n     \\<And>S.\n        finite S \\<Longrightarrow>\n        flatten (flatten (=) R) S = (R = S)\\<rbrakk>\n    \\<Longrightarrow> flatten (flatten (=) (insert a R)) {} =\n                      (insert a R = {})", "qed simp"], ["proof (state)\nthis:\n  flatten (flatten (=) (insert a R)) S = (insert a R = S)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma flatten_PLUS_inject: \"\\<lbrakk>\\<forall>x \\<in> R \\<union> S. \\<not> is_Zero x \\<and> \\<not> is_Plus x; finite R; finite S\\<rbrakk> \\<Longrightarrow>\n  (flatten PLUS R = flatten PLUS S) = (R = S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>R \\<union> S.\n                \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n     finite R; finite S\\<rbrakk>\n    \\<Longrightarrow> (flatten PLUS R = flatten PLUS S) = (R = S)", "by (rule trans[OF PLUS_inject sorted_list_of_set_inject]) auto"], ["", "primrec pset where\n  \"pset Zero = {}\"\n| \"pset One = {One}\"\n| \"pset (Atom a) = {Atom a}\"\n| \"pset (Plus r s) = pset r \\<union> pset s\"\n| \"pset (Times r s) = Timess (pset r) s\"\n| \"pset (Star r) = {Star r}\""], ["", "lemma pset_not_is_Zero_is_Plus[simp]: \"\\<forall>x \\<in> pset r. \\<not> is_Zero x \\<and> \\<not> is_Plus x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>pset r. \\<not> is_Zero x \\<and> \\<not> is_Plus x", "by (induct r) auto"], ["", "lemma finite_pset[simp]: \"finite (pset r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (pset r)", "by (induct r) auto"], ["", "lemma pset_deriv: \"pset (deriv a r) = pderiv a r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pset (deriv a r) = pderiv a r", "by (induct r) auto"], ["", "definition pnorm where\n  \"pnorm = flatten PLUS o pset\""], ["", "lemma pnorm_deriv_eq_iff_pderiv_eq:\n  \"pnorm (deriv a r) = pnorm (deriv a s) \\<longleftrightarrow> pderiv a r = pderiv a s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pnorm (deriv a r) = pnorm (deriv a s)) = (pderiv a r = pderiv a s)", "unfolding pnorm_def o_apply pset_deriv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (flatten PLUS (pderiv a r) = flatten PLUS (pderiv a s)) =\n    (pderiv a r = pderiv a s)", "by (rule flatten_PLUS_inject) auto"], ["", "fun pnPlus :: \"'a::linorder rexp \\<Rightarrow> 'a rexp \\<Rightarrow> 'a rexp\" where\n  \"pnPlus Zero r = r\"\n| \"pnPlus r Zero = r\"\n| \"pnPlus (Plus r s) t = pnPlus r (pnPlus s t)\"\n| \"pnPlus r (Plus s t) =\n     (if r = s then (Plus s t)\n     else if le_rexp r s then Plus r (Plus s t)\n     else Plus s (pnPlus r t))\"\n| \"pnPlus r s =\n     (if r = s then r\n      else if le_rexp r s then Plus r s\n      else Plus s r)\""], ["", "fun pnTimes :: \"'a::linorder rexp \\<Rightarrow> 'a rexp \\<Rightarrow> 'a rexp\" where\n  \"pnTimes Zero r = Zero\"\n| \"pnTimes (Plus r s) t = pnPlus (pnTimes r t) (pnTimes s t)\"\n| \"pnTimes r s = Times r s\""], ["", "primrec pnorm_alt :: \"'a::linorder rexp \\<Rightarrow> 'a rexp\" where\n  \"pnorm_alt Zero = Zero\"\n| \"pnorm_alt One = One\"\n| \"pnorm_alt (Atom a) = Atom a\"\n| \"pnorm_alt (Plus r s) = pnPlus (pnorm_alt r) (pnorm_alt s)\"\n| \"pnorm_alt (Times r s) = pnTimes (pnorm_alt r) s\"\n| \"pnorm_alt (Star r) = Star r\""], ["", "lemma pset_pnPlus:\n  \"pset (pnPlus r s) = pset (Plus r s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pset (pnPlus r s) = pset (Plus r s)", "by (induct r s rule: pnPlus.induct) auto"], ["", "lemma pset_pnTimes:\n  \"pset (pnTimes r s) = pset (Times r s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pset (pnTimes r s) = pset (Times r s)", "by (induct r s rule: pnTimes.induct) (auto simp: pset_pnPlus)"], ["", "lemma pset_pnorm_alt_Times: \"s \\<in> pset r \\<Longrightarrow> pnTimes (pnorm_alt s) t = Times (pnorm_alt s) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> pset r \\<Longrightarrow>\n    pnTimes (pnorm_alt s) t = Times (pnorm_alt s) t", "by (induct r arbitrary: s t) auto"], ["", "lemma pset_pnorm_alt:\n  \"pset (pnorm_alt r) = pnorm_alt ` pset r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pset (pnorm_alt r) = pnorm_alt ` pset r", "by (induct r) (auto simp: pset_pnPlus pset_pnTimes pset_pnorm_alt_Times image_iff)"], ["", "lemma pset_pnTimes_Times: \"s \\<in> pset r \\<Longrightarrow> pnTimes s t = Times s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> pset r \\<Longrightarrow> pnTimes s t = Times s t", "by (induct r arbitrary: s t) auto"], ["", "lemma pset_pnorm_alt_id: \"s \\<in> pset r \\<Longrightarrow> pnorm_alt s = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> pset r \\<Longrightarrow> pnorm_alt s = s", "by (induct r arbitrary: s) (auto simp: pset_pnTimes_Times)"], ["", "lemma pnorm_alt_image_pset: \"pnorm_alt ` pset r = pset r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pnorm_alt ` pset r = pset r", "by (induction r) (auto, auto simp add: pset_pnorm_alt_id pset_pnTimes_Times image_iff)"], ["", "lemma pnorm_pnorm_alt: \"pnorm (pnorm_alt r) = pnorm r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pnorm (pnorm_alt r) = pnorm r", "by (induct r) (auto simp: pnorm_def pset_pnPlus pset_pnTimes pset_pnorm_alt pnorm_alt_image_pset)"], ["", "lemma pnPlus_singleton_PLUS: \n  \"\\<lbrakk>xs \\<noteq> []; sorted xs; distinct xs; \\<forall>x \\<in> {x} \\<union> set xs. \\<not>is_Zero x \\<and> \\<not>is_Plus x\\<rbrakk> \\<Longrightarrow>\n  pnPlus x (PLUS xs) = (if x \\<in> set xs then PLUS xs else PLUS (insort x xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> []; sorted xs; distinct xs;\n     \\<forall>x\\<in>{x} \\<union> set xs.\n        \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n    \\<Longrightarrow> pnPlus x (PLUS xs) =\n                      (if x \\<in> set xs then PLUS xs\n                       else PLUS (insort x xs))", "proof (induct xs rule: list_singleton_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>[] \\<noteq> []; sorted []; distinct [];\n     \\<forall>x\\<in>{x} \\<union> set [].\n        \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n    \\<Longrightarrow> pnPlus x (PLUS []) =\n                      (if x \\<in> set [] then PLUS []\n                       else PLUS (insort x []))\n 2. \\<And>xa.\n       \\<lbrakk>[xa] \\<noteq> []; sorted [xa]; distinct [xa];\n        \\<forall>x\\<in>{x} \\<union> set [xa].\n           \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n       \\<Longrightarrow> pnPlus x (PLUS [xa]) =\n                         (if x \\<in> set [xa] then PLUS [xa]\n                          else PLUS (insort x [xa]))\n 3. \\<And>xa y xs.\n       \\<lbrakk>\\<lbrakk>y # xs \\<noteq> []; sorted (y # xs);\n                 distinct (y # xs);\n                 \\<forall>x\\<in>{x} \\<union> set (y # xs).\n                    \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n                \\<Longrightarrow> pnPlus x (PLUS (y # xs)) =\n                                  (if x \\<in> set (y # xs)\n                                   then PLUS (y # xs)\n                                   else PLUS (insort x (y # xs)));\n        xa # y # xs \\<noteq> []; sorted (xa # y # xs);\n        distinct (xa # y # xs);\n        \\<forall>x\\<in>{x} \\<union> set (xa # y # xs).\n           \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n       \\<Longrightarrow> pnPlus x (PLUS (xa # y # xs)) =\n                         (if x \\<in> set (xa # y # xs)\n                          then PLUS (xa # y # xs)\n                          else PLUS (insort x (xa # y # xs)))", "case (single y)"], ["proof (state)\nthis:\n  [y] \\<noteq> []\n  sorted [y]\n  distinct [y]\n  \\<forall>x\\<in>{x} \\<union> set [y].\n     \\<not> is_Zero x \\<and> \\<not> is_Plus x\n\ngoal (3 subgoals):\n 1. \\<lbrakk>[] \\<noteq> []; sorted []; distinct [];\n     \\<forall>x\\<in>{x} \\<union> set [].\n        \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n    \\<Longrightarrow> pnPlus x (PLUS []) =\n                      (if x \\<in> set [] then PLUS []\n                       else PLUS (insort x []))\n 2. \\<And>xa.\n       \\<lbrakk>[xa] \\<noteq> []; sorted [xa]; distinct [xa];\n        \\<forall>x\\<in>{x} \\<union> set [xa].\n           \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n       \\<Longrightarrow> pnPlus x (PLUS [xa]) =\n                         (if x \\<in> set [xa] then PLUS [xa]\n                          else PLUS (insort x [xa]))\n 3. \\<And>xa y xs.\n       \\<lbrakk>\\<lbrakk>y # xs \\<noteq> []; sorted (y # xs);\n                 distinct (y # xs);\n                 \\<forall>x\\<in>{x} \\<union> set (y # xs).\n                    \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n                \\<Longrightarrow> pnPlus x (PLUS (y # xs)) =\n                                  (if x \\<in> set (y # xs)\n                                   then PLUS (y # xs)\n                                   else PLUS (insort x (y # xs)));\n        xa # y # xs \\<noteq> []; sorted (xa # y # xs);\n        distinct (xa # y # xs);\n        \\<forall>x\\<in>{x} \\<union> set (xa # y # xs).\n           \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n       \\<Longrightarrow> pnPlus x (PLUS (xa # y # xs)) =\n                         (if x \\<in> set (xa # y # xs)\n                          then PLUS (xa # y # xs)\n                          else PLUS (insort x (xa # y # xs)))", "thus ?case"], ["proof (prove)\nusing this:\n  [y] \\<noteq> []\n  sorted [y]\n  distinct [y]\n  \\<forall>x\\<in>{x} \\<union> set [y].\n     \\<not> is_Zero x \\<and> \\<not> is_Plus x\n\ngoal (1 subgoal):\n 1. pnPlus x (PLUS [y]) =\n    (if x \\<in> set [y] then PLUS [y] else PLUS (insort x [y]))", "unfolding is_Zero_def is_Plus_def"], ["proof (prove)\nusing this:\n  [y] \\<noteq> []\n  sorted [y]\n  distinct [y]\n  \\<forall>x\\<in>{x} \\<union> set [y].\n     x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42)\n\ngoal (1 subgoal):\n 1. pnPlus x (PLUS [y]) =\n    (if x \\<in> set [y] then PLUS [y] else PLUS (insort x [y]))", "apply (cases x y rule: linorder_cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>[y] \\<noteq> []; sorted [y]; distinct [y];\n     \\<forall>x\\<in>{x} \\<union> set [y].\n        x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n     x < y\\<rbrakk>\n    \\<Longrightarrow> pnPlus x (PLUS [y]) =\n                      (if x \\<in> set [y] then PLUS [y]\n                       else PLUS (insort x [y]))\n 2. \\<lbrakk>[y] \\<noteq> []; sorted [y]; distinct [y];\n     \\<forall>x\\<in>{x} \\<union> set [y].\n        x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n     x = y\\<rbrakk>\n    \\<Longrightarrow> pnPlus x (PLUS [y]) =\n                      (if x \\<in> set [y] then PLUS [y]\n                       else PLUS (insort x [y]))\n 3. \\<lbrakk>[y] \\<noteq> []; sorted [y]; distinct [y];\n     \\<forall>x\\<in>{x} \\<union> set [y].\n        x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n     y < x\\<rbrakk>\n    \\<Longrightarrow> pnPlus x (PLUS [y]) =\n                      (if x \\<in> set [y] then PLUS [y]\n                       else PLUS (insort x [y]))", "apply (induct x y rule: pnPlus.induct)"], ["proof (prove)\ngoal (33 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>[r] \\<noteq> []; sorted [r]; distinct [r];\n        \\<forall>x\\<in>{Zero} \\<union> set [r].\n           x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n        Zero < r\\<rbrakk>\n       \\<Longrightarrow> pnPlus Zero (PLUS [r]) =\n                         (if Zero \\<in> set [r] then PLUS [r]\n                          else PLUS (insort Zero [r]))\n 2. \\<lbrakk>[Zero] \\<noteq> []; sorted [Zero]; distinct [Zero];\n     \\<forall>x\\<in>{One} \\<union> set [Zero].\n        x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n     One < Zero\\<rbrakk>\n    \\<Longrightarrow> pnPlus One (PLUS [Zero]) =\n                      (if One \\<in> set [Zero] then PLUS [Zero]\n                       else PLUS (insort One [Zero]))\n 3. \\<And>v.\n       \\<lbrakk>[Zero] \\<noteq> []; sorted [Zero]; distinct [Zero];\n        \\<forall>x\\<in>{Atom v} \\<union> set [Zero].\n           x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n        Atom v < Zero\\<rbrakk>\n       \\<Longrightarrow> pnPlus (Atom v) (PLUS [Zero]) =\n                         (if Atom v \\<in> set [Zero] then PLUS [Zero]\n                          else PLUS (insort (Atom v) [Zero]))\n 4. \\<And>v va.\n       \\<lbrakk>[Zero] \\<noteq> []; sorted [Zero]; distinct [Zero];\n        \\<forall>x\\<in>{Plus v va} \\<union> set [Zero].\n           x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n        Plus v va < Zero\\<rbrakk>\n       \\<Longrightarrow> pnPlus (Plus v va) (PLUS [Zero]) =\n                         (if Plus v va \\<in> set [Zero] then PLUS [Zero]\n                          else PLUS (insort (Plus v va) [Zero]))\n 5. \\<And>v va.\n       \\<lbrakk>[Zero] \\<noteq> []; sorted [Zero]; distinct [Zero];\n        \\<forall>x\\<in>{Times v va} \\<union> set [Zero].\n           x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n        Times v va < Zero\\<rbrakk>\n       \\<Longrightarrow> pnPlus (Times v va) (PLUS [Zero]) =\n                         (if Times v va \\<in> set [Zero] then PLUS [Zero]\n                          else PLUS (insort (Times v va) [Zero]))\n 6. \\<And>v.\n       \\<lbrakk>[Zero] \\<noteq> []; sorted [Zero]; distinct [Zero];\n        \\<forall>x\\<in>{Star v} \\<union> set [Zero].\n           x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n        Star v < Zero\\<rbrakk>\n       \\<Longrightarrow> pnPlus (Star v) (PLUS [Zero]) =\n                         (if Star v \\<in> set [Zero] then PLUS [Zero]\n                          else PLUS (insort (Star v) [Zero]))\n 7. \\<And>r s.\n       \\<lbrakk>\\<lbrakk>[One] \\<noteq> []; sorted [One]; distinct [One];\n                 \\<forall>x\\<in>{s} \\<union> set [One].\n                    x \\<noteq> Zero \\<and>\n                    (\\<nexists>x41 x42. x = Plus x41 x42);\n                 s < One\\<rbrakk>\n                \\<Longrightarrow> pnPlus s (PLUS [One]) =\n                                  (if s \\<in> set [One] then PLUS [One]\n                                   else PLUS (insort s [One]));\n        \\<lbrakk>[pnPlus s One] \\<noteq> []; sorted [pnPlus s One];\n         distinct [pnPlus s One];\n         \\<forall>x\\<in>{r} \\<union> set [pnPlus s One].\n            x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n         r < pnPlus s One\\<rbrakk>\n        \\<Longrightarrow> pnPlus r (PLUS [pnPlus s One]) =\n                          (if r \\<in> set [pnPlus s One]\n                           then PLUS [pnPlus s One]\n                           else PLUS (insort r [pnPlus s One]));\n        [One] \\<noteq> []; sorted [One]; distinct [One];\n        \\<forall>x\\<in>{Plus r s} \\<union> set [One].\n           x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n        Plus r s < One\\<rbrakk>\n       \\<Longrightarrow> pnPlus (Plus r s) (PLUS [One]) =\n                         (if Plus r s \\<in> set [One] then PLUS [One]\n                          else PLUS (insort (Plus r s) [One]))\n 8. \\<And>r s v.\n       \\<lbrakk>\\<lbrakk>[Atom v] \\<noteq> []; sorted [Atom v];\n                 distinct [Atom v];\n                 \\<forall>x\\<in>{s} \\<union> set [Atom v].\n                    x \\<noteq> Zero \\<and>\n                    (\\<nexists>x41 x42. x = Plus x41 x42);\n                 s < Atom v\\<rbrakk>\n                \\<Longrightarrow> pnPlus s (PLUS [Atom v]) =\n                                  (if s \\<in> set [Atom v]\n                                   then PLUS [Atom v]\n                                   else PLUS (insort s [Atom v]));\n        \\<lbrakk>[pnPlus s (Atom v)] \\<noteq> [];\n         sorted [pnPlus s (Atom v)]; distinct [pnPlus s (Atom v)];\n         \\<forall>x\\<in>{r} \\<union> set [pnPlus s (Atom v)].\n            x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n         r < pnPlus s (Atom v)\\<rbrakk>\n        \\<Longrightarrow> pnPlus r (PLUS [pnPlus s (Atom v)]) =\n                          (if r \\<in> set [pnPlus s (Atom v)]\n                           then PLUS [pnPlus s (Atom v)]\n                           else PLUS (insort r [pnPlus s (Atom v)]));\n        [Atom v] \\<noteq> []; sorted [Atom v]; distinct [Atom v];\n        \\<forall>x\\<in>{Plus r s} \\<union> set [Atom v].\n           x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n        Plus r s < Atom v\\<rbrakk>\n       \\<Longrightarrow> pnPlus (Plus r s) (PLUS [Atom v]) =\n                         (if Plus r s \\<in> set [Atom v] then PLUS [Atom v]\n                          else PLUS (insort (Plus r s) [Atom v]))\n 9. \\<And>r s v va.\n       \\<lbrakk>\\<lbrakk>[Plus v va] \\<noteq> []; sorted [Plus v va];\n                 distinct [Plus v va];\n                 \\<forall>x\\<in>{s} \\<union> set [Plus v va].\n                    x \\<noteq> Zero \\<and>\n                    (\\<nexists>x41 x42. x = Plus x41 x42);\n                 s < Plus v va\\<rbrakk>\n                \\<Longrightarrow> pnPlus s (PLUS [Plus v va]) =\n                                  (if s \\<in> set [Plus v va]\n                                   then PLUS [Plus v va]\n                                   else PLUS (insort s [Plus v va]));\n        \\<lbrakk>[pnPlus s (Plus v va)] \\<noteq> [];\n         sorted [pnPlus s (Plus v va)]; distinct [pnPlus s (Plus v va)];\n         \\<forall>x\\<in>{r} \\<union> set [pnPlus s (Plus v va)].\n            x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n         r < pnPlus s (Plus v va)\\<rbrakk>\n        \\<Longrightarrow> pnPlus r (PLUS [pnPlus s (Plus v va)]) =\n                          (if r \\<in> set [pnPlus s (Plus v va)]\n                           then PLUS [pnPlus s (Plus v va)]\n                           else PLUS (insort r [pnPlus s (Plus v va)]));\n        [Plus v va] \\<noteq> []; sorted [Plus v va]; distinct [Plus v va];\n        \\<forall>x\\<in>{Plus r s} \\<union> set [Plus v va].\n           x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n        Plus r s < Plus v va\\<rbrakk>\n       \\<Longrightarrow> pnPlus (Plus r s) (PLUS [Plus v va]) =\n                         (if Plus r s \\<in> set [Plus v va]\n                          then PLUS [Plus v va]\n                          else PLUS (insort (Plus r s) [Plus v va]))\n 10. \\<And>r s v va.\n        \\<lbrakk>\\<lbrakk>[Times v va] \\<noteq> []; sorted [Times v va];\n                  distinct [Times v va];\n                  \\<forall>x\\<in>{s} \\<union> set [Times v va].\n                     x \\<noteq> Zero \\<and>\n                     (\\<nexists>x41 x42. x = Plus x41 x42);\n                  s < Times v va\\<rbrakk>\n                 \\<Longrightarrow> pnPlus s (PLUS [Times v va]) =\n                                   (if s \\<in> set [Times v va]\n                                    then PLUS [Times v va]\n                                    else PLUS (insort s [Times v va]));\n         \\<lbrakk>[pnPlus s (Times v va)] \\<noteq> [];\n          sorted [pnPlus s (Times v va)]; distinct [pnPlus s (Times v va)];\n          \\<forall>x\\<in>{r} \\<union> set [pnPlus s (Times v va)].\n             x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n          r < pnPlus s (Times v va)\\<rbrakk>\n         \\<Longrightarrow> pnPlus r (PLUS [pnPlus s (Times v va)]) =\n                           (if r \\<in> set [pnPlus s (Times v va)]\n                            then PLUS [pnPlus s (Times v va)]\n                            else PLUS (insort r [pnPlus s (Times v va)]));\n         [Times v va] \\<noteq> []; sorted [Times v va];\n         distinct [Times v va];\n         \\<forall>x\\<in>{Plus r s} \\<union> set [Times v va].\n            x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n         Plus r s < Times v va\\<rbrakk>\n        \\<Longrightarrow> pnPlus (Plus r s) (PLUS [Times v va]) =\n                          (if Plus r s \\<in> set [Times v va]\n                           then PLUS [Times v va]\n                           else PLUS (insort (Plus r s) [Times v va]))\nA total of 33 subgoals...", "apply (auto simp: less_rexp_def less_eq_rexp_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x = y; y \\<noteq> Zero;\n     \\<forall>x41 x42. y \\<noteq> Plus x41 x42\\<rbrakk>\n    \\<Longrightarrow> pnPlus y y = y\n 2. \\<lbrakk>y \\<noteq> Zero; le_rexp y x;\n     \\<forall>x41 x42. y \\<noteq> Plus x41 x42; x \\<noteq> Zero;\n     \\<forall>x41 x42. x \\<noteq> Plus x41 x42; le_rexp x y;\n     x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> pnPlus x y = Plus x y\n 3. \\<lbrakk>y \\<noteq> Zero; le_rexp y x;\n     \\<forall>x41 x42. y \\<noteq> Plus x41 x42; x \\<noteq> Zero;\n     \\<forall>x41 x42. x \\<noteq> Plus x41 x42; \\<not> le_rexp x y;\n     x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> pnPlus x y = Plus y x", "apply (cases y)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>x = y; y \\<noteq> Zero;\n     \\<forall>x41 x42. y \\<noteq> Plus x41 x42; y = Zero\\<rbrakk>\n    \\<Longrightarrow> pnPlus y y = y\n 2. \\<lbrakk>x = y; y \\<noteq> Zero;\n     \\<forall>x41 x42. y \\<noteq> Plus x41 x42; y = One\\<rbrakk>\n    \\<Longrightarrow> pnPlus y y = y\n 3. \\<And>x3.\n       \\<lbrakk>x = y; y \\<noteq> Zero;\n        \\<forall>x41 x42. y \\<noteq> Plus x41 x42; y = Atom x3\\<rbrakk>\n       \\<Longrightarrow> pnPlus y y = y\n 4. \\<And>x41 x42.\n       \\<lbrakk>x = y; y \\<noteq> Zero;\n        \\<forall>x41 x42. y \\<noteq> Plus x41 x42; y = Plus x41 x42\\<rbrakk>\n       \\<Longrightarrow> pnPlus y y = y\n 5. \\<And>x51 x52.\n       \\<lbrakk>x = y; y \\<noteq> Zero;\n        \\<forall>x41 x42. y \\<noteq> Plus x41 x42;\n        y = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> pnPlus y y = y\n 6. \\<And>x6.\n       \\<lbrakk>x = y; y \\<noteq> Zero;\n        \\<forall>x41 x42. y \\<noteq> Plus x41 x42; y = Star x6\\<rbrakk>\n       \\<Longrightarrow> pnPlus y y = y\n 7. \\<lbrakk>y \\<noteq> Zero; le_rexp y x;\n     \\<forall>x41 x42. y \\<noteq> Plus x41 x42; x \\<noteq> Zero;\n     \\<forall>x41 x42. x \\<noteq> Plus x41 x42; le_rexp x y;\n     x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> pnPlus x y = Plus x y\n 8. \\<lbrakk>y \\<noteq> Zero; le_rexp y x;\n     \\<forall>x41 x42. y \\<noteq> Plus x41 x42; x \\<noteq> Zero;\n     \\<forall>x41 x42. x \\<noteq> Plus x41 x42; \\<not> le_rexp x y;\n     x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> pnPlus x y = Plus y x", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y \\<noteq> Zero; le_rexp y x;\n     \\<forall>x41 x42. y \\<noteq> Plus x41 x42; x \\<noteq> Zero;\n     \\<forall>x41 x42. x \\<noteq> Plus x41 x42; le_rexp x y;\n     x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> pnPlus x y = Plus x y\n 2. \\<lbrakk>y \\<noteq> Zero; le_rexp y x;\n     \\<forall>x41 x42. y \\<noteq> Plus x41 x42; x \\<noteq> Zero;\n     \\<forall>x41 x42. x \\<noteq> Plus x41 x42; \\<not> le_rexp x y;\n     x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> pnPlus x y = Plus y x", "apply (induct x y rule: pnPlus.induct)"], ["proof (prove)\ngoal (32 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>r \\<noteq> Zero; le_rexp r Zero;\n        \\<forall>x41 x42. r \\<noteq> Plus x41 x42; Zero \\<noteq> Zero;\n        \\<forall>x41 x42. Zero \\<noteq> Plus x41 x42; le_rexp Zero r;\n        Zero \\<noteq> r\\<rbrakk>\n       \\<Longrightarrow> pnPlus Zero r = Plus Zero r\n 2. \\<lbrakk>Zero \\<noteq> Zero; le_rexp Zero One;\n     \\<forall>x41 x42. Zero \\<noteq> Plus x41 x42; One \\<noteq> Zero;\n     \\<forall>x41 x42. One \\<noteq> Plus x41 x42; le_rexp One Zero;\n     One \\<noteq> Zero\\<rbrakk>\n    \\<Longrightarrow> pnPlus One Zero = Plus One Zero\n 3. \\<And>v.\n       \\<lbrakk>Zero \\<noteq> Zero; le_rexp Zero (Atom v);\n        \\<forall>x41 x42. Zero \\<noteq> Plus x41 x42; Atom v \\<noteq> Zero;\n        \\<forall>x41 x42. Atom v \\<noteq> Plus x41 x42;\n        le_rexp (Atom v) Zero; Atom v \\<noteq> Zero\\<rbrakk>\n       \\<Longrightarrow> pnPlus (Atom v) Zero = Plus (Atom v) Zero\n 4. \\<And>v va.\n       \\<lbrakk>Zero \\<noteq> Zero; le_rexp Zero (Plus v va);\n        \\<forall>x41 x42. Zero \\<noteq> Plus x41 x42;\n        Plus v va \\<noteq> Zero;\n        \\<forall>x41 x42. Plus v va \\<noteq> Plus x41 x42;\n        le_rexp (Plus v va) Zero; Plus v va \\<noteq> Zero\\<rbrakk>\n       \\<Longrightarrow> pnPlus (Plus v va) Zero = Plus (Plus v va) Zero\n 5. \\<And>v va.\n       \\<lbrakk>Zero \\<noteq> Zero; le_rexp Zero (Times v va);\n        \\<forall>x41 x42. Zero \\<noteq> Plus x41 x42;\n        Times v va \\<noteq> Zero;\n        \\<forall>x41 x42. Times v va \\<noteq> Plus x41 x42;\n        le_rexp (Times v va) Zero; Times v va \\<noteq> Zero\\<rbrakk>\n       \\<Longrightarrow> pnPlus (Times v va) Zero = Plus (Times v va) Zero\n 6. \\<And>v.\n       \\<lbrakk>Zero \\<noteq> Zero; le_rexp Zero (Star v);\n        \\<forall>x41 x42. Zero \\<noteq> Plus x41 x42; Star v \\<noteq> Zero;\n        \\<forall>x41 x42. Star v \\<noteq> Plus x41 x42;\n        le_rexp (Star v) Zero; Star v \\<noteq> Zero\\<rbrakk>\n       \\<Longrightarrow> pnPlus (Star v) Zero = Plus (Star v) Zero\n 7. \\<And>r s.\n       \\<lbrakk>\\<lbrakk>One \\<noteq> Zero; le_rexp One s;\n                 \\<forall>x41 x42. One \\<noteq> Plus x41 x42;\n                 s \\<noteq> Zero; \\<forall>x41 x42. s \\<noteq> Plus x41 x42;\n                 le_rexp s One; s \\<noteq> One\\<rbrakk>\n                \\<Longrightarrow> pnPlus s One = Plus s One;\n        \\<lbrakk>pnPlus s One \\<noteq> Zero; le_rexp (pnPlus s One) r;\n         \\<forall>x41 x42. pnPlus s One \\<noteq> Plus x41 x42;\n         r \\<noteq> Zero; \\<forall>x41 x42. r \\<noteq> Plus x41 x42;\n         le_rexp r (pnPlus s One); r \\<noteq> pnPlus s One\\<rbrakk>\n        \\<Longrightarrow> pnPlus r (pnPlus s One) = Plus r (pnPlus s One);\n        One \\<noteq> Zero; le_rexp One (Plus r s);\n        \\<forall>x41 x42. One \\<noteq> Plus x41 x42; Plus r s \\<noteq> Zero;\n        \\<forall>x41 x42. Plus r s \\<noteq> Plus x41 x42;\n        le_rexp (Plus r s) One; Plus r s \\<noteq> One\\<rbrakk>\n       \\<Longrightarrow> pnPlus (Plus r s) One = Plus (Plus r s) One\n 8. \\<And>r s v.\n       \\<lbrakk>\\<lbrakk>Atom v \\<noteq> Zero; le_rexp (Atom v) s;\n                 \\<forall>x41 x42. Atom v \\<noteq> Plus x41 x42;\n                 s \\<noteq> Zero; \\<forall>x41 x42. s \\<noteq> Plus x41 x42;\n                 le_rexp s (Atom v); s \\<noteq> Atom v\\<rbrakk>\n                \\<Longrightarrow> pnPlus s (Atom v) = Plus s (Atom v);\n        \\<lbrakk>pnPlus s (Atom v) \\<noteq> Zero;\n         le_rexp (pnPlus s (Atom v)) r;\n         \\<forall>x41 x42. pnPlus s (Atom v) \\<noteq> Plus x41 x42;\n         r \\<noteq> Zero; \\<forall>x41 x42. r \\<noteq> Plus x41 x42;\n         le_rexp r (pnPlus s (Atom v));\n         r \\<noteq> pnPlus s (Atom v)\\<rbrakk>\n        \\<Longrightarrow> pnPlus r (pnPlus s (Atom v)) =\n                          Plus r (pnPlus s (Atom v));\n        Atom v \\<noteq> Zero; le_rexp (Atom v) (Plus r s);\n        \\<forall>x41 x42. Atom v \\<noteq> Plus x41 x42;\n        Plus r s \\<noteq> Zero;\n        \\<forall>x41 x42. Plus r s \\<noteq> Plus x41 x42;\n        le_rexp (Plus r s) (Atom v); Plus r s \\<noteq> Atom v\\<rbrakk>\n       \\<Longrightarrow> pnPlus (Plus r s) (Atom v) =\n                         Plus (Plus r s) (Atom v)\n 9. \\<And>r s v va.\n       \\<lbrakk>\\<lbrakk>Plus v va \\<noteq> Zero; le_rexp (Plus v va) s;\n                 \\<forall>x41 x42. Plus v va \\<noteq> Plus x41 x42;\n                 s \\<noteq> Zero; \\<forall>x41 x42. s \\<noteq> Plus x41 x42;\n                 le_rexp s (Plus v va); s \\<noteq> Plus v va\\<rbrakk>\n                \\<Longrightarrow> pnPlus s (Plus v va) = Plus s (Plus v va);\n        \\<lbrakk>pnPlus s (Plus v va) \\<noteq> Zero;\n         le_rexp (pnPlus s (Plus v va)) r;\n         \\<forall>x41 x42. pnPlus s (Plus v va) \\<noteq> Plus x41 x42;\n         r \\<noteq> Zero; \\<forall>x41 x42. r \\<noteq> Plus x41 x42;\n         le_rexp r (pnPlus s (Plus v va));\n         r \\<noteq> pnPlus s (Plus v va)\\<rbrakk>\n        \\<Longrightarrow> pnPlus r (pnPlus s (Plus v va)) =\n                          Plus r (pnPlus s (Plus v va));\n        Plus v va \\<noteq> Zero; le_rexp (Plus v va) (Plus r s);\n        \\<forall>x41 x42. Plus v va \\<noteq> Plus x41 x42;\n        Plus r s \\<noteq> Zero;\n        \\<forall>x41 x42. Plus r s \\<noteq> Plus x41 x42;\n        le_rexp (Plus r s) (Plus v va); Plus r s \\<noteq> Plus v va\\<rbrakk>\n       \\<Longrightarrow> pnPlus (Plus r s) (Plus v va) =\n                         Plus (Plus r s) (Plus v va)\n 10. \\<And>r s v va.\n        \\<lbrakk>\\<lbrakk>Times v va \\<noteq> Zero; le_rexp (Times v va) s;\n                  \\<forall>x41 x42. Times v va \\<noteq> Plus x41 x42;\n                  s \\<noteq> Zero;\n                  \\<forall>x41 x42. s \\<noteq> Plus x41 x42;\n                  le_rexp s (Times v va); s \\<noteq> Times v va\\<rbrakk>\n                 \\<Longrightarrow> pnPlus s (Times v va) =\n                                   Plus s (Times v va);\n         \\<lbrakk>pnPlus s (Times v va) \\<noteq> Zero;\n          le_rexp (pnPlus s (Times v va)) r;\n          \\<forall>x41 x42. pnPlus s (Times v va) \\<noteq> Plus x41 x42;\n          r \\<noteq> Zero; \\<forall>x41 x42. r \\<noteq> Plus x41 x42;\n          le_rexp r (pnPlus s (Times v va));\n          r \\<noteq> pnPlus s (Times v va)\\<rbrakk>\n         \\<Longrightarrow> pnPlus r (pnPlus s (Times v va)) =\n                           Plus r (pnPlus s (Times v va));\n         Times v va \\<noteq> Zero; le_rexp (Times v va) (Plus r s);\n         \\<forall>x41 x42. Times v va \\<noteq> Plus x41 x42;\n         Plus r s \\<noteq> Zero;\n         \\<forall>x41 x42. Plus r s \\<noteq> Plus x41 x42;\n         le_rexp (Plus r s) (Times v va);\n         Plus r s \\<noteq> Times v va\\<rbrakk>\n        \\<Longrightarrow> pnPlus (Plus r s) (Times v va) =\n                          Plus (Plus r s) (Times v va)\nA total of 32 subgoals...", "apply (auto simp: less_rexp_def less_eq_rexp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<noteq> Zero; le_rexp y x;\n     \\<forall>x41 x42. y \\<noteq> Plus x41 x42; x \\<noteq> Zero;\n     \\<forall>x41 x42. x \\<noteq> Plus x41 x42; \\<not> le_rexp x y;\n     x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> pnPlus x y = Plus y x", "apply (induct x y rule: pnPlus.induct)"], ["proof (prove)\ngoal (31 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>r \\<noteq> Zero; le_rexp r Zero;\n        \\<forall>x41 x42. r \\<noteq> Plus x41 x42; Zero \\<noteq> Zero;\n        \\<forall>x41 x42. Zero \\<noteq> Plus x41 x42; \\<not> le_rexp Zero r;\n        Zero \\<noteq> r\\<rbrakk>\n       \\<Longrightarrow> pnPlus Zero r = Plus r Zero\n 2. \\<lbrakk>Zero \\<noteq> Zero; le_rexp Zero One;\n     \\<forall>x41 x42. Zero \\<noteq> Plus x41 x42; One \\<noteq> Zero;\n     \\<forall>x41 x42. One \\<noteq> Plus x41 x42; \\<not> le_rexp One Zero;\n     One \\<noteq> Zero\\<rbrakk>\n    \\<Longrightarrow> pnPlus One Zero = Plus Zero One\n 3. \\<And>v.\n       \\<lbrakk>Zero \\<noteq> Zero; le_rexp Zero (Atom v);\n        \\<forall>x41 x42. Zero \\<noteq> Plus x41 x42; Atom v \\<noteq> Zero;\n        \\<forall>x41 x42. Atom v \\<noteq> Plus x41 x42;\n        \\<not> le_rexp (Atom v) Zero; Atom v \\<noteq> Zero\\<rbrakk>\n       \\<Longrightarrow> pnPlus (Atom v) Zero = Plus Zero (Atom v)\n 4. \\<And>v va.\n       \\<lbrakk>Zero \\<noteq> Zero; le_rexp Zero (Plus v va);\n        \\<forall>x41 x42. Zero \\<noteq> Plus x41 x42;\n        Plus v va \\<noteq> Zero;\n        \\<forall>x41 x42. Plus v va \\<noteq> Plus x41 x42;\n        \\<not> le_rexp (Plus v va) Zero; Plus v va \\<noteq> Zero\\<rbrakk>\n       \\<Longrightarrow> pnPlus (Plus v va) Zero = Plus Zero (Plus v va)\n 5. \\<And>v va.\n       \\<lbrakk>Zero \\<noteq> Zero; le_rexp Zero (Times v va);\n        \\<forall>x41 x42. Zero \\<noteq> Plus x41 x42;\n        Times v va \\<noteq> Zero;\n        \\<forall>x41 x42. Times v va \\<noteq> Plus x41 x42;\n        \\<not> le_rexp (Times v va) Zero; Times v va \\<noteq> Zero\\<rbrakk>\n       \\<Longrightarrow> pnPlus (Times v va) Zero = Plus Zero (Times v va)\n 6. \\<And>v.\n       \\<lbrakk>Zero \\<noteq> Zero; le_rexp Zero (Star v);\n        \\<forall>x41 x42. Zero \\<noteq> Plus x41 x42; Star v \\<noteq> Zero;\n        \\<forall>x41 x42. Star v \\<noteq> Plus x41 x42;\n        \\<not> le_rexp (Star v) Zero; Star v \\<noteq> Zero\\<rbrakk>\n       \\<Longrightarrow> pnPlus (Star v) Zero = Plus Zero (Star v)\n 7. \\<And>r s.\n       \\<lbrakk>\\<lbrakk>One \\<noteq> Zero; le_rexp One s;\n                 \\<forall>x41 x42. One \\<noteq> Plus x41 x42;\n                 s \\<noteq> Zero; \\<forall>x41 x42. s \\<noteq> Plus x41 x42;\n                 \\<not> le_rexp s One; s \\<noteq> One\\<rbrakk>\n                \\<Longrightarrow> pnPlus s One = Plus One s;\n        \\<lbrakk>pnPlus s One \\<noteq> Zero; le_rexp (pnPlus s One) r;\n         \\<forall>x41 x42. pnPlus s One \\<noteq> Plus x41 x42;\n         r \\<noteq> Zero; \\<forall>x41 x42. r \\<noteq> Plus x41 x42;\n         \\<not> le_rexp r (pnPlus s One); r \\<noteq> pnPlus s One\\<rbrakk>\n        \\<Longrightarrow> pnPlus r (pnPlus s One) = Plus (pnPlus s One) r;\n        One \\<noteq> Zero; le_rexp One (Plus r s);\n        \\<forall>x41 x42. One \\<noteq> Plus x41 x42; Plus r s \\<noteq> Zero;\n        \\<forall>x41 x42. Plus r s \\<noteq> Plus x41 x42;\n        \\<not> le_rexp (Plus r s) One; Plus r s \\<noteq> One\\<rbrakk>\n       \\<Longrightarrow> pnPlus (Plus r s) One = Plus One (Plus r s)\n 8. \\<And>r s v.\n       \\<lbrakk>\\<lbrakk>Atom v \\<noteq> Zero; le_rexp (Atom v) s;\n                 \\<forall>x41 x42. Atom v \\<noteq> Plus x41 x42;\n                 s \\<noteq> Zero; \\<forall>x41 x42. s \\<noteq> Plus x41 x42;\n                 \\<not> le_rexp s (Atom v); s \\<noteq> Atom v\\<rbrakk>\n                \\<Longrightarrow> pnPlus s (Atom v) = Plus (Atom v) s;\n        \\<lbrakk>pnPlus s (Atom v) \\<noteq> Zero;\n         le_rexp (pnPlus s (Atom v)) r;\n         \\<forall>x41 x42. pnPlus s (Atom v) \\<noteq> Plus x41 x42;\n         r \\<noteq> Zero; \\<forall>x41 x42. r \\<noteq> Plus x41 x42;\n         \\<not> le_rexp r (pnPlus s (Atom v));\n         r \\<noteq> pnPlus s (Atom v)\\<rbrakk>\n        \\<Longrightarrow> pnPlus r (pnPlus s (Atom v)) =\n                          Plus (pnPlus s (Atom v)) r;\n        Atom v \\<noteq> Zero; le_rexp (Atom v) (Plus r s);\n        \\<forall>x41 x42. Atom v \\<noteq> Plus x41 x42;\n        Plus r s \\<noteq> Zero;\n        \\<forall>x41 x42. Plus r s \\<noteq> Plus x41 x42;\n        \\<not> le_rexp (Plus r s) (Atom v);\n        Plus r s \\<noteq> Atom v\\<rbrakk>\n       \\<Longrightarrow> pnPlus (Plus r s) (Atom v) =\n                         Plus (Atom v) (Plus r s)\n 9. \\<And>r s v va.\n       \\<lbrakk>\\<lbrakk>Plus v va \\<noteq> Zero; le_rexp (Plus v va) s;\n                 \\<forall>x41 x42. Plus v va \\<noteq> Plus x41 x42;\n                 s \\<noteq> Zero; \\<forall>x41 x42. s \\<noteq> Plus x41 x42;\n                 \\<not> le_rexp s (Plus v va); s \\<noteq> Plus v va\\<rbrakk>\n                \\<Longrightarrow> pnPlus s (Plus v va) = Plus (Plus v va) s;\n        \\<lbrakk>pnPlus s (Plus v va) \\<noteq> Zero;\n         le_rexp (pnPlus s (Plus v va)) r;\n         \\<forall>x41 x42. pnPlus s (Plus v va) \\<noteq> Plus x41 x42;\n         r \\<noteq> Zero; \\<forall>x41 x42. r \\<noteq> Plus x41 x42;\n         \\<not> le_rexp r (pnPlus s (Plus v va));\n         r \\<noteq> pnPlus s (Plus v va)\\<rbrakk>\n        \\<Longrightarrow> pnPlus r (pnPlus s (Plus v va)) =\n                          Plus (pnPlus s (Plus v va)) r;\n        Plus v va \\<noteq> Zero; le_rexp (Plus v va) (Plus r s);\n        \\<forall>x41 x42. Plus v va \\<noteq> Plus x41 x42;\n        Plus r s \\<noteq> Zero;\n        \\<forall>x41 x42. Plus r s \\<noteq> Plus x41 x42;\n        \\<not> le_rexp (Plus r s) (Plus v va);\n        Plus r s \\<noteq> Plus v va\\<rbrakk>\n       \\<Longrightarrow> pnPlus (Plus r s) (Plus v va) =\n                         Plus (Plus v va) (Plus r s)\n 10. \\<And>r s v va.\n        \\<lbrakk>\\<lbrakk>Times v va \\<noteq> Zero; le_rexp (Times v va) s;\n                  \\<forall>x41 x42. Times v va \\<noteq> Plus x41 x42;\n                  s \\<noteq> Zero;\n                  \\<forall>x41 x42. s \\<noteq> Plus x41 x42;\n                  \\<not> le_rexp s (Times v va);\n                  s \\<noteq> Times v va\\<rbrakk>\n                 \\<Longrightarrow> pnPlus s (Times v va) =\n                                   Plus (Times v va) s;\n         \\<lbrakk>pnPlus s (Times v va) \\<noteq> Zero;\n          le_rexp (pnPlus s (Times v va)) r;\n          \\<forall>x41 x42. pnPlus s (Times v va) \\<noteq> Plus x41 x42;\n          r \\<noteq> Zero; \\<forall>x41 x42. r \\<noteq> Plus x41 x42;\n          \\<not> le_rexp r (pnPlus s (Times v va));\n          r \\<noteq> pnPlus s (Times v va)\\<rbrakk>\n         \\<Longrightarrow> pnPlus r (pnPlus s (Times v va)) =\n                           Plus (pnPlus s (Times v va)) r;\n         Times v va \\<noteq> Zero; le_rexp (Times v va) (Plus r s);\n         \\<forall>x41 x42. Times v va \\<noteq> Plus x41 x42;\n         Plus r s \\<noteq> Zero;\n         \\<forall>x41 x42. Plus r s \\<noteq> Plus x41 x42;\n         \\<not> le_rexp (Plus r s) (Times v va);\n         Plus r s \\<noteq> Times v va\\<rbrakk>\n        \\<Longrightarrow> pnPlus (Plus r s) (Times v va) =\n                          Plus (Times v va) (Plus r s)\nA total of 31 subgoals...", "apply (auto simp: less_rexp_def less_eq_rexp_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  pnPlus x (PLUS [y]) =\n  (if x \\<in> set [y] then PLUS [y] else PLUS (insort x [y]))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<noteq> []; sorted []; distinct [];\n     \\<forall>x\\<in>{x} \\<union> set [].\n        \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n    \\<Longrightarrow> pnPlus x (PLUS []) =\n                      (if x \\<in> set [] then PLUS []\n                       else PLUS (insort x []))\n 2. \\<And>xa y xs.\n       \\<lbrakk>\\<lbrakk>y # xs \\<noteq> []; sorted (y # xs);\n                 distinct (y # xs);\n                 \\<forall>x\\<in>{x} \\<union> set (y # xs).\n                    \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n                \\<Longrightarrow> pnPlus x (PLUS (y # xs)) =\n                                  (if x \\<in> set (y # xs)\n                                   then PLUS (y # xs)\n                                   else PLUS (insort x (y # xs)));\n        xa # y # xs \\<noteq> []; sorted (xa # y # xs);\n        distinct (xa # y # xs);\n        \\<forall>x\\<in>{x} \\<union> set (xa # y # xs).\n           \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n       \\<Longrightarrow> pnPlus x (PLUS (xa # y # xs)) =\n                         (if x \\<in> set (xa # y # xs)\n                          then PLUS (xa # y # xs)\n                          else PLUS (insort x (xa # y # xs)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<noteq> []; sorted []; distinct [];\n     \\<forall>x\\<in>{x} \\<union> set [].\n        \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n    \\<Longrightarrow> pnPlus x (PLUS []) =\n                      (if x \\<in> set [] then PLUS []\n                       else PLUS (insort x []))\n 2. \\<And>xa y xs.\n       \\<lbrakk>\\<lbrakk>y # xs \\<noteq> []; sorted (y # xs);\n                 distinct (y # xs);\n                 \\<forall>x\\<in>{x} \\<union> set (y # xs).\n                    \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n                \\<Longrightarrow> pnPlus x (PLUS (y # xs)) =\n                                  (if x \\<in> set (y # xs)\n                                   then PLUS (y # xs)\n                                   else PLUS (insort x (y # xs)));\n        xa # y # xs \\<noteq> []; sorted (xa # y # xs);\n        distinct (xa # y # xs);\n        \\<forall>x\\<in>{x} \\<union> set (xa # y # xs).\n           \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n       \\<Longrightarrow> pnPlus x (PLUS (xa # y # xs)) =\n                         (if x \\<in> set (xa # y # xs)\n                          then PLUS (xa # y # xs)\n                          else PLUS (insort x (xa # y # xs)))", "case (cons y1 y2 ys)"], ["proof (state)\nthis:\n  \\<lbrakk>y2 # ys \\<noteq> []; sorted (y2 # ys); distinct (y2 # ys);\n   \\<forall>x\\<in>{x} \\<union> set (y2 # ys).\n      \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n  \\<Longrightarrow> pnPlus x (PLUS (y2 # ys)) =\n                    (if x \\<in> set (y2 # ys) then PLUS (y2 # ys)\n                     else PLUS (insort x (y2 # ys)))\n  y1 # y2 # ys \\<noteq> []\n  sorted (y1 # y2 # ys)\n  distinct (y1 # y2 # ys)\n  \\<forall>x\\<in>{x} \\<union> set (y1 # y2 # ys).\n     \\<not> is_Zero x \\<and> \\<not> is_Plus x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<noteq> []; sorted []; distinct [];\n     \\<forall>x\\<in>{x} \\<union> set [].\n        \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n    \\<Longrightarrow> pnPlus x (PLUS []) =\n                      (if x \\<in> set [] then PLUS []\n                       else PLUS (insort x []))\n 2. \\<And>xa y xs.\n       \\<lbrakk>\\<lbrakk>y # xs \\<noteq> []; sorted (y # xs);\n                 distinct (y # xs);\n                 \\<forall>x\\<in>{x} \\<union> set (y # xs).\n                    \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n                \\<Longrightarrow> pnPlus x (PLUS (y # xs)) =\n                                  (if x \\<in> set (y # xs)\n                                   then PLUS (y # xs)\n                                   else PLUS (insort x (y # xs)));\n        xa # y # xs \\<noteq> []; sorted (xa # y # xs);\n        distinct (xa # y # xs);\n        \\<forall>x\\<in>{x} \\<union> set (xa # y # xs).\n           \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n       \\<Longrightarrow> pnPlus x (PLUS (xa # y # xs)) =\n                         (if x \\<in> set (xa # y # xs)\n                          then PLUS (xa # y # xs)\n                          else PLUS (insort x (xa # y # xs)))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>y2 # ys \\<noteq> []; sorted (y2 # ys); distinct (y2 # ys);\n   \\<forall>x\\<in>{x} \\<union> set (y2 # ys).\n      \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n  \\<Longrightarrow> pnPlus x (PLUS (y2 # ys)) =\n                    (if x \\<in> set (y2 # ys) then PLUS (y2 # ys)\n                     else PLUS (insort x (y2 # ys)))\n  y1 # y2 # ys \\<noteq> []\n  sorted (y1 # y2 # ys)\n  distinct (y1 # y2 # ys)\n  \\<forall>x\\<in>{x} \\<union> set (y1 # y2 # ys).\n     \\<not> is_Zero x \\<and> \\<not> is_Plus x\n\ngoal (1 subgoal):\n 1. pnPlus x (PLUS (y1 # y2 # ys)) =\n    (if x \\<in> set (y1 # y2 # ys) then PLUS (y1 # y2 # ys)\n     else PLUS (insort x (y1 # y2 # ys)))", "unfolding is_Zero_def is_Plus_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>y2 # ys \\<noteq> []; sorted (y2 # ys); distinct (y2 # ys);\n   \\<forall>x\\<in>{x} \\<union> set (y2 # ys).\n      x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42)\\<rbrakk>\n  \\<Longrightarrow> pnPlus x (PLUS (y2 # ys)) =\n                    (if x \\<in> set (y2 # ys) then PLUS (y2 # ys)\n                     else PLUS (insort x (y2 # ys)))\n  y1 # y2 # ys \\<noteq> []\n  sorted (y1 # y2 # ys)\n  distinct (y1 # y2 # ys)\n  \\<forall>x\\<in>{x} \\<union> set (y1 # y2 # ys).\n     x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42)\n\ngoal (1 subgoal):\n 1. pnPlus x (PLUS (y1 # y2 # ys)) =\n    (if x \\<in> set (y1 # y2 # ys) then PLUS (y1 # y2 # ys)\n     else PLUS (insort x (y1 # y2 # ys)))", "apply (cases x)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<lbrakk>y2 # ys \\<noteq> []; sorted (y2 # ys);\n              distinct (y2 # ys);\n              \\<forall>x\\<in>{x} \\<union> set (y2 # ys).\n                 x \\<noteq> Zero \\<and>\n                 (\\<nexists>x41 x42. x = Plus x41 x42)\\<rbrakk>\n             \\<Longrightarrow> pnPlus x (PLUS (y2 # ys)) =\n                               (if x \\<in> set (y2 # ys) then PLUS (y2 # ys)\n                                else PLUS (insort x (y2 # ys)));\n     y1 # y2 # ys \\<noteq> []; sorted (y1 # y2 # ys);\n     distinct (y1 # y2 # ys);\n     \\<forall>x\\<in>{x} \\<union> set (y1 # y2 # ys).\n        x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n     x = Zero\\<rbrakk>\n    \\<Longrightarrow> pnPlus x (PLUS (y1 # y2 # ys)) =\n                      (if x \\<in> set (y1 # y2 # ys)\n                       then PLUS (y1 # y2 # ys)\n                       else PLUS (insort x (y1 # y2 # ys)))\n 2. \\<lbrakk>\\<lbrakk>y2 # ys \\<noteq> []; sorted (y2 # ys);\n              distinct (y2 # ys);\n              \\<forall>x\\<in>{x} \\<union> set (y2 # ys).\n                 x \\<noteq> Zero \\<and>\n                 (\\<nexists>x41 x42. x = Plus x41 x42)\\<rbrakk>\n             \\<Longrightarrow> pnPlus x (PLUS (y2 # ys)) =\n                               (if x \\<in> set (y2 # ys) then PLUS (y2 # ys)\n                                else PLUS (insort x (y2 # ys)));\n     y1 # y2 # ys \\<noteq> []; sorted (y1 # y2 # ys);\n     distinct (y1 # y2 # ys);\n     \\<forall>x\\<in>{x} \\<union> set (y1 # y2 # ys).\n        x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n     x = One\\<rbrakk>\n    \\<Longrightarrow> pnPlus x (PLUS (y1 # y2 # ys)) =\n                      (if x \\<in> set (y1 # y2 # ys)\n                       then PLUS (y1 # y2 # ys)\n                       else PLUS (insort x (y1 # y2 # ys)))\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>y2 # ys \\<noteq> []; sorted (y2 # ys);\n                 distinct (y2 # ys);\n                 \\<forall>x\\<in>{x} \\<union> set (y2 # ys).\n                    x \\<noteq> Zero \\<and>\n                    (\\<nexists>x41 x42. x = Plus x41 x42)\\<rbrakk>\n                \\<Longrightarrow> pnPlus x (PLUS (y2 # ys)) =\n                                  (if x \\<in> set (y2 # ys)\n                                   then PLUS (y2 # ys)\n                                   else PLUS (insort x (y2 # ys)));\n        y1 # y2 # ys \\<noteq> []; sorted (y1 # y2 # ys);\n        distinct (y1 # y2 # ys);\n        \\<forall>x\\<in>{x} \\<union> set (y1 # y2 # ys).\n           x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n        x = Atom x3\\<rbrakk>\n       \\<Longrightarrow> pnPlus x (PLUS (y1 # y2 # ys)) =\n                         (if x \\<in> set (y1 # y2 # ys)\n                          then PLUS (y1 # y2 # ys)\n                          else PLUS (insort x (y1 # y2 # ys)))\n 4. \\<And>x41 x42.\n       \\<lbrakk>\\<lbrakk>y2 # ys \\<noteq> []; sorted (y2 # ys);\n                 distinct (y2 # ys);\n                 \\<forall>x\\<in>{x} \\<union> set (y2 # ys).\n                    x \\<noteq> Zero \\<and>\n                    (\\<nexists>x41 x42. x = Plus x41 x42)\\<rbrakk>\n                \\<Longrightarrow> pnPlus x (PLUS (y2 # ys)) =\n                                  (if x \\<in> set (y2 # ys)\n                                   then PLUS (y2 # ys)\n                                   else PLUS (insort x (y2 # ys)));\n        y1 # y2 # ys \\<noteq> []; sorted (y1 # y2 # ys);\n        distinct (y1 # y2 # ys);\n        \\<forall>x\\<in>{x} \\<union> set (y1 # y2 # ys).\n           x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n        x = Plus x41 x42\\<rbrakk>\n       \\<Longrightarrow> pnPlus x (PLUS (y1 # y2 # ys)) =\n                         (if x \\<in> set (y1 # y2 # ys)\n                          then PLUS (y1 # y2 # ys)\n                          else PLUS (insort x (y1 # y2 # ys)))\n 5. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>y2 # ys \\<noteq> []; sorted (y2 # ys);\n                 distinct (y2 # ys);\n                 \\<forall>x\\<in>{x} \\<union> set (y2 # ys).\n                    x \\<noteq> Zero \\<and>\n                    (\\<nexists>x41 x42. x = Plus x41 x42)\\<rbrakk>\n                \\<Longrightarrow> pnPlus x (PLUS (y2 # ys)) =\n                                  (if x \\<in> set (y2 # ys)\n                                   then PLUS (y2 # ys)\n                                   else PLUS (insort x (y2 # ys)));\n        y1 # y2 # ys \\<noteq> []; sorted (y1 # y2 # ys);\n        distinct (y1 # y2 # ys);\n        \\<forall>x\\<in>{x} \\<union> set (y1 # y2 # ys).\n           x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n        x = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> pnPlus x (PLUS (y1 # y2 # ys)) =\n                         (if x \\<in> set (y1 # y2 # ys)\n                          then PLUS (y1 # y2 # ys)\n                          else PLUS (insort x (y1 # y2 # ys)))\n 6. \\<And>x6.\n       \\<lbrakk>\\<lbrakk>y2 # ys \\<noteq> []; sorted (y2 # ys);\n                 distinct (y2 # ys);\n                 \\<forall>x\\<in>{x} \\<union> set (y2 # ys).\n                    x \\<noteq> Zero \\<and>\n                    (\\<nexists>x41 x42. x = Plus x41 x42)\\<rbrakk>\n                \\<Longrightarrow> pnPlus x (PLUS (y2 # ys)) =\n                                  (if x \\<in> set (y2 # ys)\n                                   then PLUS (y2 # ys)\n                                   else PLUS (insort x (y2 # ys)));\n        y1 # y2 # ys \\<noteq> []; sorted (y1 # y2 # ys);\n        distinct (y1 # y2 # ys);\n        \\<forall>x\\<in>{x} \\<union> set (y1 # y2 # ys).\n           x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n        x = Star x6\\<rbrakk>\n       \\<Longrightarrow> pnPlus x (PLUS (y1 # y2 # ys)) =\n                         (if x \\<in> set (y1 # y2 # ys)\n                          then PLUS (y1 # y2 # ys)\n                          else PLUS (insort x (y1 # y2 # ys)))", "apply (metis UnCI insertI1)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<lbrakk>y2 # ys \\<noteq> []; sorted (y2 # ys);\n              distinct (y2 # ys);\n              \\<forall>x\\<in>{x} \\<union> set (y2 # ys).\n                 x \\<noteq> Zero \\<and>\n                 (\\<nexists>x41 x42. x = Plus x41 x42)\\<rbrakk>\n             \\<Longrightarrow> pnPlus x (PLUS (y2 # ys)) =\n                               (if x \\<in> set (y2 # ys) then PLUS (y2 # ys)\n                                else PLUS (insort x (y2 # ys)));\n     y1 # y2 # ys \\<noteq> []; sorted (y1 # y2 # ys);\n     distinct (y1 # y2 # ys);\n     \\<forall>x\\<in>{x} \\<union> set (y1 # y2 # ys).\n        x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n     x = One\\<rbrakk>\n    \\<Longrightarrow> pnPlus x (PLUS (y1 # y2 # ys)) =\n                      (if x \\<in> set (y1 # y2 # ys)\n                       then PLUS (y1 # y2 # ys)\n                       else PLUS (insort x (y1 # y2 # ys)))\n 2. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>y2 # ys \\<noteq> []; sorted (y2 # ys);\n                 distinct (y2 # ys);\n                 \\<forall>x\\<in>{x} \\<union> set (y2 # ys).\n                    x \\<noteq> Zero \\<and>\n                    (\\<nexists>x41 x42. x = Plus x41 x42)\\<rbrakk>\n                \\<Longrightarrow> pnPlus x (PLUS (y2 # ys)) =\n                                  (if x \\<in> set (y2 # ys)\n                                   then PLUS (y2 # ys)\n                                   else PLUS (insort x (y2 # ys)));\n        y1 # y2 # ys \\<noteq> []; sorted (y1 # y2 # ys);\n        distinct (y1 # y2 # ys);\n        \\<forall>x\\<in>{x} \\<union> set (y1 # y2 # ys).\n           x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n        x = Atom x3\\<rbrakk>\n       \\<Longrightarrow> pnPlus x (PLUS (y1 # y2 # ys)) =\n                         (if x \\<in> set (y1 # y2 # ys)\n                          then PLUS (y1 # y2 # ys)\n                          else PLUS (insort x (y1 # y2 # ys)))\n 3. \\<And>x41 x42.\n       \\<lbrakk>\\<lbrakk>y2 # ys \\<noteq> []; sorted (y2 # ys);\n                 distinct (y2 # ys);\n                 \\<forall>x\\<in>{x} \\<union> set (y2 # ys).\n                    x \\<noteq> Zero \\<and>\n                    (\\<nexists>x41 x42. x = Plus x41 x42)\\<rbrakk>\n                \\<Longrightarrow> pnPlus x (PLUS (y2 # ys)) =\n                                  (if x \\<in> set (y2 # ys)\n                                   then PLUS (y2 # ys)\n                                   else PLUS (insort x (y2 # ys)));\n        y1 # y2 # ys \\<noteq> []; sorted (y1 # y2 # ys);\n        distinct (y1 # y2 # ys);\n        \\<forall>x\\<in>{x} \\<union> set (y1 # y2 # ys).\n           x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n        x = Plus x41 x42\\<rbrakk>\n       \\<Longrightarrow> pnPlus x (PLUS (y1 # y2 # ys)) =\n                         (if x \\<in> set (y1 # y2 # ys)\n                          then PLUS (y1 # y2 # ys)\n                          else PLUS (insort x (y1 # y2 # ys)))\n 4. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>y2 # ys \\<noteq> []; sorted (y2 # ys);\n                 distinct (y2 # ys);\n                 \\<forall>x\\<in>{x} \\<union> set (y2 # ys).\n                    x \\<noteq> Zero \\<and>\n                    (\\<nexists>x41 x42. x = Plus x41 x42)\\<rbrakk>\n                \\<Longrightarrow> pnPlus x (PLUS (y2 # ys)) =\n                                  (if x \\<in> set (y2 # ys)\n                                   then PLUS (y2 # ys)\n                                   else PLUS (insort x (y2 # ys)));\n        y1 # y2 # ys \\<noteq> []; sorted (y1 # y2 # ys);\n        distinct (y1 # y2 # ys);\n        \\<forall>x\\<in>{x} \\<union> set (y1 # y2 # ys).\n           x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n        x = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> pnPlus x (PLUS (y1 # y2 # ys)) =\n                         (if x \\<in> set (y1 # y2 # ys)\n                          then PLUS (y1 # y2 # ys)\n                          else PLUS (insort x (y1 # y2 # ys)))\n 5. \\<And>x6.\n       \\<lbrakk>\\<lbrakk>y2 # ys \\<noteq> []; sorted (y2 # ys);\n                 distinct (y2 # ys);\n                 \\<forall>x\\<in>{x} \\<union> set (y2 # ys).\n                    x \\<noteq> Zero \\<and>\n                    (\\<nexists>x41 x42. x = Plus x41 x42)\\<rbrakk>\n                \\<Longrightarrow> pnPlus x (PLUS (y2 # ys)) =\n                                  (if x \\<in> set (y2 # ys)\n                                   then PLUS (y2 # ys)\n                                   else PLUS (insort x (y2 # ys)));\n        y1 # y2 # ys \\<noteq> []; sorted (y1 # y2 # ys);\n        distinct (y1 # y2 # ys);\n        \\<forall>x\\<in>{x} \\<union> set (y1 # y2 # ys).\n           x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n        x = Star x6\\<rbrakk>\n       \\<Longrightarrow> pnPlus x (PLUS (y1 # y2 # ys)) =\n                         (if x \\<in> set (y1 # y2 # ys)\n                          then PLUS (y1 # y2 # ys)\n                          else PLUS (insort x (y1 # y2 # ys)))", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>pnPlus One (PLUS (y2 # ys)) =\n             (if One = y2 \\<or> One \\<in> set ys then PLUS (y2 # ys)\n              else PLUS (insort x (y2 # ys)));\n     y1 \\<le> y2 \\<and>\n     (\\<forall>x\\<in>set ys. y1 \\<le> x) \\<and>\n     (\\<forall>x\\<in>set ys. y2 \\<le> x) \\<and> sorted ys;\n     y1 \\<noteq> y2 \\<and>\n     y1 \\<notin> set ys \\<and> y2 \\<notin> set ys \\<and> distinct ys;\n     y1 \\<noteq> Zero \\<and>\n     (\\<forall>x41 x42. y1 \\<noteq> Plus x41 x42) \\<and>\n     y2 \\<noteq> Zero \\<and>\n     (\\<forall>x41 x42. y2 \\<noteq> Plus x41 x42) \\<and>\n     (\\<forall>x\\<in>set ys.\n         x \\<noteq> Zero \\<and>\n         (\\<forall>x41 x42. x \\<noteq> Plus x41 x42));\n     x = One\\<rbrakk>\n    \\<Longrightarrow> (One \\<le> y1 \\<longrightarrow>\n                       (le_rexp One y1 \\<longrightarrow>\n                        One \\<noteq> y1 \\<longrightarrow>\n                        One \\<noteq> y2 \\<and> One \\<notin> set ys) \\<and>\n                       (\\<not> le_rexp One y1 \\<longrightarrow>\n                        One \\<noteq> y1 \\<longrightarrow>\n                        (One = y2 \\<longrightarrow>\n                         pnPlus One (PLUS (One # ys)) =\n                         PLUS (One # ys)) \\<and>\n                        (One = y2 \\<or> One \\<in> set ys))) \\<and>\n                      (\\<not> One \\<le> y1 \\<longrightarrow>\n                       (le_rexp One y1 \\<longrightarrow>\n                        One \\<noteq> y1 \\<longrightarrow>\n                        One \\<noteq> y2 \\<and>\n                        One \\<notin> set ys \\<and>\n                        (One = y2 \\<or> One \\<in> set ys)) \\<and>\n                       (\\<not> le_rexp One y1 \\<longrightarrow>\n                        One \\<noteq> y1 \\<longrightarrow>\n                        One = y2 \\<longrightarrow>\n                        pnPlus One (PLUS (One # ys)) = PLUS (One # ys)))\n 2. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>y2 # ys \\<noteq> []; sorted (y2 # ys);\n                 distinct (y2 # ys);\n                 \\<forall>x\\<in>{x} \\<union> set (y2 # ys).\n                    x \\<noteq> Zero \\<and>\n                    (\\<nexists>x41 x42. x = Plus x41 x42)\\<rbrakk>\n                \\<Longrightarrow> pnPlus x (PLUS (y2 # ys)) =\n                                  (if x \\<in> set (y2 # ys)\n                                   then PLUS (y2 # ys)\n                                   else PLUS (insort x (y2 # ys)));\n        y1 # y2 # ys \\<noteq> []; sorted (y1 # y2 # ys);\n        distinct (y1 # y2 # ys);\n        \\<forall>x\\<in>{x} \\<union> set (y1 # y2 # ys).\n           x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n        x = Atom x3\\<rbrakk>\n       \\<Longrightarrow> pnPlus x (PLUS (y1 # y2 # ys)) =\n                         (if x \\<in> set (y1 # y2 # ys)\n                          then PLUS (y1 # y2 # ys)\n                          else PLUS (insort x (y1 # y2 # ys)))\n 3. \\<And>x41 x42.\n       \\<lbrakk>\\<lbrakk>y2 # ys \\<noteq> []; sorted (y2 # ys);\n                 distinct (y2 # ys);\n                 \\<forall>x\\<in>{x} \\<union> set (y2 # ys).\n                    x \\<noteq> Zero \\<and>\n                    (\\<nexists>x41 x42. x = Plus x41 x42)\\<rbrakk>\n                \\<Longrightarrow> pnPlus x (PLUS (y2 # ys)) =\n                                  (if x \\<in> set (y2 # ys)\n                                   then PLUS (y2 # ys)\n                                   else PLUS (insort x (y2 # ys)));\n        y1 # y2 # ys \\<noteq> []; sorted (y1 # y2 # ys);\n        distinct (y1 # y2 # ys);\n        \\<forall>x\\<in>{x} \\<union> set (y1 # y2 # ys).\n           x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n        x = Plus x41 x42\\<rbrakk>\n       \\<Longrightarrow> pnPlus x (PLUS (y1 # y2 # ys)) =\n                         (if x \\<in> set (y1 # y2 # ys)\n                          then PLUS (y1 # y2 # ys)\n                          else PLUS (insort x (y1 # y2 # ys)))\n 4. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>y2 # ys \\<noteq> []; sorted (y2 # ys);\n                 distinct (y2 # ys);\n                 \\<forall>x\\<in>{x} \\<union> set (y2 # ys).\n                    x \\<noteq> Zero \\<and>\n                    (\\<nexists>x41 x42. x = Plus x41 x42)\\<rbrakk>\n                \\<Longrightarrow> pnPlus x (PLUS (y2 # ys)) =\n                                  (if x \\<in> set (y2 # ys)\n                                   then PLUS (y2 # ys)\n                                   else PLUS (insort x (y2 # ys)));\n        y1 # y2 # ys \\<noteq> []; sorted (y1 # y2 # ys);\n        distinct (y1 # y2 # ys);\n        \\<forall>x\\<in>{x} \\<union> set (y1 # y2 # ys).\n           x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n        x = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> pnPlus x (PLUS (y1 # y2 # ys)) =\n                         (if x \\<in> set (y1 # y2 # ys)\n                          then PLUS (y1 # y2 # ys)\n                          else PLUS (insort x (y1 # y2 # ys)))\n 5. \\<And>x6.\n       \\<lbrakk>\\<lbrakk>y2 # ys \\<noteq> []; sorted (y2 # ys);\n                 distinct (y2 # ys);\n                 \\<forall>x\\<in>{x} \\<union> set (y2 # ys).\n                    x \\<noteq> Zero \\<and>\n                    (\\<nexists>x41 x42. x = Plus x41 x42)\\<rbrakk>\n                \\<Longrightarrow> pnPlus x (PLUS (y2 # ys)) =\n                                  (if x \\<in> set (y2 # ys)\n                                   then PLUS (y2 # ys)\n                                   else PLUS (insort x (y2 # ys)));\n        y1 # y2 # ys \\<noteq> []; sorted (y1 # y2 # ys);\n        distinct (y1 # y2 # ys);\n        \\<forall>x\\<in>{x} \\<union> set (y1 # y2 # ys).\n           x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n        x = Star x6\\<rbrakk>\n       \\<Longrightarrow> pnPlus x (PLUS (y1 # y2 # ys)) =\n                         (if x \\<in> set (y1 # y2 # ys)\n                          then PLUS (y1 # y2 # ys)\n                          else PLUS (insort x (y1 # y2 # ys)))", "apply (metis antisym less_eq_rexp_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>y2 # ys \\<noteq> []; sorted (y2 # ys);\n                 distinct (y2 # ys);\n                 \\<forall>x\\<in>{x} \\<union> set (y2 # ys).\n                    x \\<noteq> Zero \\<and>\n                    (\\<nexists>x41 x42. x = Plus x41 x42)\\<rbrakk>\n                \\<Longrightarrow> pnPlus x (PLUS (y2 # ys)) =\n                                  (if x \\<in> set (y2 # ys)\n                                   then PLUS (y2 # ys)\n                                   else PLUS (insort x (y2 # ys)));\n        y1 # y2 # ys \\<noteq> []; sorted (y1 # y2 # ys);\n        distinct (y1 # y2 # ys);\n        \\<forall>x\\<in>{x} \\<union> set (y1 # y2 # ys).\n           x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n        x = Atom x3\\<rbrakk>\n       \\<Longrightarrow> pnPlus x (PLUS (y1 # y2 # ys)) =\n                         (if x \\<in> set (y1 # y2 # ys)\n                          then PLUS (y1 # y2 # ys)\n                          else PLUS (insort x (y1 # y2 # ys)))\n 2. \\<And>x41 x42.\n       \\<lbrakk>\\<lbrakk>y2 # ys \\<noteq> []; sorted (y2 # ys);\n                 distinct (y2 # ys);\n                 \\<forall>x\\<in>{x} \\<union> set (y2 # ys).\n                    x \\<noteq> Zero \\<and>\n                    (\\<nexists>x41 x42. x = Plus x41 x42)\\<rbrakk>\n                \\<Longrightarrow> pnPlus x (PLUS (y2 # ys)) =\n                                  (if x \\<in> set (y2 # ys)\n                                   then PLUS (y2 # ys)\n                                   else PLUS (insort x (y2 # ys)));\n        y1 # y2 # ys \\<noteq> []; sorted (y1 # y2 # ys);\n        distinct (y1 # y2 # ys);\n        \\<forall>x\\<in>{x} \\<union> set (y1 # y2 # ys).\n           x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n        x = Plus x41 x42\\<rbrakk>\n       \\<Longrightarrow> pnPlus x (PLUS (y1 # y2 # ys)) =\n                         (if x \\<in> set (y1 # y2 # ys)\n                          then PLUS (y1 # y2 # ys)\n                          else PLUS (insort x (y1 # y2 # ys)))\n 3. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>y2 # ys \\<noteq> []; sorted (y2 # ys);\n                 distinct (y2 # ys);\n                 \\<forall>x\\<in>{x} \\<union> set (y2 # ys).\n                    x \\<noteq> Zero \\<and>\n                    (\\<nexists>x41 x42. x = Plus x41 x42)\\<rbrakk>\n                \\<Longrightarrow> pnPlus x (PLUS (y2 # ys)) =\n                                  (if x \\<in> set (y2 # ys)\n                                   then PLUS (y2 # ys)\n                                   else PLUS (insort x (y2 # ys)));\n        y1 # y2 # ys \\<noteq> []; sorted (y1 # y2 # ys);\n        distinct (y1 # y2 # ys);\n        \\<forall>x\\<in>{x} \\<union> set (y1 # y2 # ys).\n           x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n        x = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> pnPlus x (PLUS (y1 # y2 # ys)) =\n                         (if x \\<in> set (y1 # y2 # ys)\n                          then PLUS (y1 # y2 # ys)\n                          else PLUS (insort x (y1 # y2 # ys)))\n 4. \\<And>x6.\n       \\<lbrakk>\\<lbrakk>y2 # ys \\<noteq> []; sorted (y2 # ys);\n                 distinct (y2 # ys);\n                 \\<forall>x\\<in>{x} \\<union> set (y2 # ys).\n                    x \\<noteq> Zero \\<and>\n                    (\\<nexists>x41 x42. x = Plus x41 x42)\\<rbrakk>\n                \\<Longrightarrow> pnPlus x (PLUS (y2 # ys)) =\n                                  (if x \\<in> set (y2 # ys)\n                                   then PLUS (y2 # ys)\n                                   else PLUS (insort x (y2 # ys)));\n        y1 # y2 # ys \\<noteq> []; sorted (y1 # y2 # ys);\n        distinct (y1 # y2 # ys);\n        \\<forall>x\\<in>{x} \\<union> set (y1 # y2 # ys).\n           x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n        x = Star x6\\<rbrakk>\n       \\<Longrightarrow> pnPlus x (PLUS (y1 # y2 # ys)) =\n                         (if x \\<in> set (y1 # y2 # ys)\n                          then PLUS (y1 # y2 # ys)\n                          else PLUS (insort x (y1 # y2 # ys)))", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>pnPlus (Atom x3) (PLUS (y2 # ys)) =\n                (if Atom x3 = y2 \\<or> Atom x3 \\<in> set ys\n                 then PLUS (y2 # ys) else PLUS (insort x (y2 # ys)));\n        y1 \\<le> y2 \\<and>\n        (\\<forall>x\\<in>set ys. y1 \\<le> x) \\<and>\n        (\\<forall>x\\<in>set ys. y2 \\<le> x) \\<and> sorted ys;\n        y1 \\<noteq> y2 \\<and>\n        y1 \\<notin> set ys \\<and> y2 \\<notin> set ys \\<and> distinct ys;\n        y1 \\<noteq> Zero \\<and>\n        (\\<forall>x41 x42. y1 \\<noteq> Plus x41 x42) \\<and>\n        y2 \\<noteq> Zero \\<and>\n        (\\<forall>x41 x42. y2 \\<noteq> Plus x41 x42) \\<and>\n        (\\<forall>x\\<in>set ys.\n            x \\<noteq> Zero \\<and>\n            (\\<forall>x41 x42. x \\<noteq> Plus x41 x42));\n        x = Atom x3\\<rbrakk>\n       \\<Longrightarrow> (Atom x3 \\<le> y1 \\<longrightarrow>\n                          Atom x3 \\<noteq> y1 \\<longrightarrow>\n                          (le_rexp (Atom x3) y1 \\<longrightarrow>\n                           (le_rexp y2 y1 \\<longrightarrow>\n                            (y2 = y1 \\<longrightarrow>\n                             Atom x3 \\<notin> set ys) \\<and>\n                            (y2 \\<noteq> y1 \\<longrightarrow>\n                             Atom x3 \\<noteq> y2 \\<and>\n                             Atom x3 \\<notin> set ys)) \\<and>\n                           (\\<not> le_rexp y2 y1 \\<longrightarrow>\n                            (y2 = y1 \\<longrightarrow>\n                             Atom x3 \\<notin> set ys) \\<and>\n                            (y2 \\<noteq> y1 \\<longrightarrow>\n                             (Atom x3 = y2 \\<longrightarrow>\n                              pnPlus y2 (PLUS (y2 # ys)) =\n                              PLUS (y2 # ys)) \\<and>\n                             Atom x3 \\<notin> set ys))) \\<and>\n                          (\\<not> le_rexp (Atom x3) y1 \\<longrightarrow>\n                           (le_rexp y2 y1 \\<longrightarrow>\n                            (y2 = y1 \\<longrightarrow>\n                             (Atom x3 \\<in> set ys \\<longrightarrow>\n                              pnPlus (Atom x3) (PLUS (y1 # ys)) =\n                              PLUS (y1 # ys)) \\<and>\n                             Atom x3 \\<in> set ys) \\<and>\n                            (y2 \\<noteq> y1 \\<longrightarrow>\n                             Atom x3 \\<noteq> y2 \\<and>\n                             (Atom x3 = y2 \\<or>\n                              Atom x3 \\<in> set ys))) \\<and>\n                           (\\<not> le_rexp y2 y1 \\<longrightarrow>\n                            (y2 = y1 \\<longrightarrow>\n                             (Atom x3 \\<in> set ys \\<longrightarrow>\n                              pnPlus (Atom x3) (PLUS (y1 # ys)) =\n                              PLUS (y1 # ys)) \\<and>\n                             Atom x3 \\<in> set ys) \\<and>\n                            (y2 \\<noteq> y1 \\<longrightarrow>\n                             (Atom x3 = y2 \\<longrightarrow>\n                              pnPlus y2 (PLUS (y2 # ys)) =\n                              PLUS (y2 # ys)) \\<and>\n                             (Atom x3 = y2 \\<or>\n                              Atom x3 \\<in> set ys))))) \\<and>\n                         (\\<not> Atom x3 \\<le> y1 \\<longrightarrow>\n                          Atom x3 \\<noteq> y1 \\<longrightarrow>\n                          (le_rexp (Atom x3) y1 \\<longrightarrow>\n                           (le_rexp y2 y1 \\<longrightarrow>\n                            y2 \\<noteq> y1 \\<and>\n                            (y2 \\<noteq> y1 \\<longrightarrow>\n                             Atom x3 \\<noteq> y2 \\<and>\n                             Atom x3 \\<notin> set ys \\<and>\n                             (Atom x3 = y2 \\<or>\n                              Atom x3 \\<in> set ys))) \\<and>\n                           (\\<not> le_rexp y2 y1 \\<longrightarrow>\n                            y2 \\<noteq> y1 \\<and>\n                            (y2 \\<noteq> y1 \\<longrightarrow>\n                             (Atom x3 = y2 \\<longrightarrow>\n                              pnPlus y2 (PLUS (y2 # ys)) =\n                              PLUS (y2 # ys)) \\<and>\n                             Atom x3 \\<notin> set ys \\<and>\n                             (Atom x3 = y2 \\<or>\n                              Atom x3 \\<in> set ys)))) \\<and>\n                          (\\<not> le_rexp (Atom x3) y1 \\<longrightarrow>\n                           (le_rexp y2 y1 \\<longrightarrow>\n                            (y2 = y1 \\<longrightarrow>\n                             (Atom x3 \\<in> set ys \\<longrightarrow>\n                              pnPlus (Atom x3) (PLUS (y1 # ys)) =\n                              PLUS (y1 # ys)) \\<and>\n                             (Atom x3 \\<notin> set ys \\<longrightarrow>\n                              pnPlus (Atom x3) (PLUS (y1 # ys)) =\n                              PLUS (y1 # insort (Atom x3) ys))) \\<and>\n                            (y2 \\<noteq> y1 \\<longrightarrow>\n                             Atom x3 \\<noteq> y2)) \\<and>\n                           (\\<not> le_rexp y2 y1 \\<longrightarrow>\n                            (y2 = y1 \\<longrightarrow>\n                             (Atom x3 \\<in> set ys \\<longrightarrow>\n                              pnPlus (Atom x3) (PLUS (y1 # ys)) =\n                              PLUS (y1 # ys)) \\<and>\n                             (Atom x3 \\<notin> set ys \\<longrightarrow>\n                              pnPlus (Atom x3) (PLUS (y1 # ys)) =\n                              PLUS (y1 # insort (Atom x3) ys))) \\<and>\n                            (y2 \\<noteq> y1 \\<longrightarrow>\n                             Atom x3 = y2 \\<longrightarrow>\n                             pnPlus y2 (PLUS (y2 # ys)) = PLUS (y2 # ys)))))\n 2. \\<And>x41 x42.\n       \\<lbrakk>\\<lbrakk>y2 # ys \\<noteq> []; sorted (y2 # ys);\n                 distinct (y2 # ys);\n                 \\<forall>x\\<in>{x} \\<union> set (y2 # ys).\n                    x \\<noteq> Zero \\<and>\n                    (\\<nexists>x41 x42. x = Plus x41 x42)\\<rbrakk>\n                \\<Longrightarrow> pnPlus x (PLUS (y2 # ys)) =\n                                  (if x \\<in> set (y2 # ys)\n                                   then PLUS (y2 # ys)\n                                   else PLUS (insort x (y2 # ys)));\n        y1 # y2 # ys \\<noteq> []; sorted (y1 # y2 # ys);\n        distinct (y1 # y2 # ys);\n        \\<forall>x\\<in>{x} \\<union> set (y1 # y2 # ys).\n           x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n        x = Plus x41 x42\\<rbrakk>\n       \\<Longrightarrow> pnPlus x (PLUS (y1 # y2 # ys)) =\n                         (if x \\<in> set (y1 # y2 # ys)\n                          then PLUS (y1 # y2 # ys)\n                          else PLUS (insort x (y1 # y2 # ys)))\n 3. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>y2 # ys \\<noteq> []; sorted (y2 # ys);\n                 distinct (y2 # ys);\n                 \\<forall>x\\<in>{x} \\<union> set (y2 # ys).\n                    x \\<noteq> Zero \\<and>\n                    (\\<nexists>x41 x42. x = Plus x41 x42)\\<rbrakk>\n                \\<Longrightarrow> pnPlus x (PLUS (y2 # ys)) =\n                                  (if x \\<in> set (y2 # ys)\n                                   then PLUS (y2 # ys)\n                                   else PLUS (insort x (y2 # ys)));\n        y1 # y2 # ys \\<noteq> []; sorted (y1 # y2 # ys);\n        distinct (y1 # y2 # ys);\n        \\<forall>x\\<in>{x} \\<union> set (y1 # y2 # ys).\n           x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n        x = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> pnPlus x (PLUS (y1 # y2 # ys)) =\n                         (if x \\<in> set (y1 # y2 # ys)\n                          then PLUS (y1 # y2 # ys)\n                          else PLUS (insort x (y1 # y2 # ys)))\n 4. \\<And>x6.\n       \\<lbrakk>\\<lbrakk>y2 # ys \\<noteq> []; sorted (y2 # ys);\n                 distinct (y2 # ys);\n                 \\<forall>x\\<in>{x} \\<union> set (y2 # ys).\n                    x \\<noteq> Zero \\<and>\n                    (\\<nexists>x41 x42. x = Plus x41 x42)\\<rbrakk>\n                \\<Longrightarrow> pnPlus x (PLUS (y2 # ys)) =\n                                  (if x \\<in> set (y2 # ys)\n                                   then PLUS (y2 # ys)\n                                   else PLUS (insort x (y2 # ys)));\n        y1 # y2 # ys \\<noteq> []; sorted (y1 # y2 # ys);\n        distinct (y1 # y2 # ys);\n        \\<forall>x\\<in>{x} \\<union> set (y1 # y2 # ys).\n           x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n        x = Star x6\\<rbrakk>\n       \\<Longrightarrow> pnPlus x (PLUS (y1 # y2 # ys)) =\n                         (if x \\<in> set (y1 # y2 # ys)\n                          then PLUS (y1 # y2 # ys)\n                          else PLUS (insort x (y1 # y2 # ys)))", "apply (metis antisym less_eq_rexp_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x41 x42.\n       \\<lbrakk>\\<lbrakk>y2 # ys \\<noteq> []; sorted (y2 # ys);\n                 distinct (y2 # ys);\n                 \\<forall>x\\<in>{x} \\<union> set (y2 # ys).\n                    x \\<noteq> Zero \\<and>\n                    (\\<nexists>x41 x42. x = Plus x41 x42)\\<rbrakk>\n                \\<Longrightarrow> pnPlus x (PLUS (y2 # ys)) =\n                                  (if x \\<in> set (y2 # ys)\n                                   then PLUS (y2 # ys)\n                                   else PLUS (insort x (y2 # ys)));\n        y1 # y2 # ys \\<noteq> []; sorted (y1 # y2 # ys);\n        distinct (y1 # y2 # ys);\n        \\<forall>x\\<in>{x} \\<union> set (y1 # y2 # ys).\n           x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n        x = Plus x41 x42\\<rbrakk>\n       \\<Longrightarrow> pnPlus x (PLUS (y1 # y2 # ys)) =\n                         (if x \\<in> set (y1 # y2 # ys)\n                          then PLUS (y1 # y2 # ys)\n                          else PLUS (insort x (y1 # y2 # ys)))\n 2. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>y2 # ys \\<noteq> []; sorted (y2 # ys);\n                 distinct (y2 # ys);\n                 \\<forall>x\\<in>{x} \\<union> set (y2 # ys).\n                    x \\<noteq> Zero \\<and>\n                    (\\<nexists>x41 x42. x = Plus x41 x42)\\<rbrakk>\n                \\<Longrightarrow> pnPlus x (PLUS (y2 # ys)) =\n                                  (if x \\<in> set (y2 # ys)\n                                   then PLUS (y2 # ys)\n                                   else PLUS (insort x (y2 # ys)));\n        y1 # y2 # ys \\<noteq> []; sorted (y1 # y2 # ys);\n        distinct (y1 # y2 # ys);\n        \\<forall>x\\<in>{x} \\<union> set (y1 # y2 # ys).\n           x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n        x = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> pnPlus x (PLUS (y1 # y2 # ys)) =\n                         (if x \\<in> set (y1 # y2 # ys)\n                          then PLUS (y1 # y2 # ys)\n                          else PLUS (insort x (y1 # y2 # ys)))\n 3. \\<And>x6.\n       \\<lbrakk>\\<lbrakk>y2 # ys \\<noteq> []; sorted (y2 # ys);\n                 distinct (y2 # ys);\n                 \\<forall>x\\<in>{x} \\<union> set (y2 # ys).\n                    x \\<noteq> Zero \\<and>\n                    (\\<nexists>x41 x42. x = Plus x41 x42)\\<rbrakk>\n                \\<Longrightarrow> pnPlus x (PLUS (y2 # ys)) =\n                                  (if x \\<in> set (y2 # ys)\n                                   then PLUS (y2 # ys)\n                                   else PLUS (insort x (y2 # ys)));\n        y1 # y2 # ys \\<noteq> []; sorted (y1 # y2 # ys);\n        distinct (y1 # y2 # ys);\n        \\<forall>x\\<in>{x} \\<union> set (y1 # y2 # ys).\n           x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n        x = Star x6\\<rbrakk>\n       \\<Longrightarrow> pnPlus x (PLUS (y1 # y2 # ys)) =\n                         (if x \\<in> set (y1 # y2 # ys)\n                          then PLUS (y1 # y2 # ys)\n                          else PLUS (insort x (y1 # y2 # ys)))", "apply (metis UnCI insertI1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>y2 # ys \\<noteq> []; sorted (y2 # ys);\n                 distinct (y2 # ys);\n                 \\<forall>x\\<in>{x} \\<union> set (y2 # ys).\n                    x \\<noteq> Zero \\<and>\n                    (\\<nexists>x41 x42. x = Plus x41 x42)\\<rbrakk>\n                \\<Longrightarrow> pnPlus x (PLUS (y2 # ys)) =\n                                  (if x \\<in> set (y2 # ys)\n                                   then PLUS (y2 # ys)\n                                   else PLUS (insort x (y2 # ys)));\n        y1 # y2 # ys \\<noteq> []; sorted (y1 # y2 # ys);\n        distinct (y1 # y2 # ys);\n        \\<forall>x\\<in>{x} \\<union> set (y1 # y2 # ys).\n           x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n        x = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> pnPlus x (PLUS (y1 # y2 # ys)) =\n                         (if x \\<in> set (y1 # y2 # ys)\n                          then PLUS (y1 # y2 # ys)\n                          else PLUS (insort x (y1 # y2 # ys)))\n 2. \\<And>x6.\n       \\<lbrakk>\\<lbrakk>y2 # ys \\<noteq> []; sorted (y2 # ys);\n                 distinct (y2 # ys);\n                 \\<forall>x\\<in>{x} \\<union> set (y2 # ys).\n                    x \\<noteq> Zero \\<and>\n                    (\\<nexists>x41 x42. x = Plus x41 x42)\\<rbrakk>\n                \\<Longrightarrow> pnPlus x (PLUS (y2 # ys)) =\n                                  (if x \\<in> set (y2 # ys)\n                                   then PLUS (y2 # ys)\n                                   else PLUS (insort x (y2 # ys)));\n        y1 # y2 # ys \\<noteq> []; sorted (y1 # y2 # ys);\n        distinct (y1 # y2 # ys);\n        \\<forall>x\\<in>{x} \\<union> set (y1 # y2 # ys).\n           x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n        x = Star x6\\<rbrakk>\n       \\<Longrightarrow> pnPlus x (PLUS (y1 # y2 # ys)) =\n                         (if x \\<in> set (y1 # y2 # ys)\n                          then PLUS (y1 # y2 # ys)\n                          else PLUS (insort x (y1 # y2 # ys)))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x51 x52.\n       \\<lbrakk>pnPlus (Times x51 x52) (PLUS (y2 # ys)) =\n                (if Times x51 x52 = y2 \\<or> Times x51 x52 \\<in> set ys\n                 then PLUS (y2 # ys) else PLUS (insort x (y2 # ys)));\n        y1 \\<le> y2 \\<and>\n        (\\<forall>x\\<in>set ys. y1 \\<le> x) \\<and>\n        (\\<forall>x\\<in>set ys. y2 \\<le> x) \\<and> sorted ys;\n        y1 \\<noteq> y2 \\<and>\n        y1 \\<notin> set ys \\<and> y2 \\<notin> set ys \\<and> distinct ys;\n        y1 \\<noteq> Zero \\<and>\n        (\\<forall>x41 x42. y1 \\<noteq> Plus x41 x42) \\<and>\n        y2 \\<noteq> Zero \\<and>\n        (\\<forall>x41 x42. y2 \\<noteq> Plus x41 x42) \\<and>\n        (\\<forall>x\\<in>set ys.\n            x \\<noteq> Zero \\<and>\n            (\\<forall>x41 x42. x \\<noteq> Plus x41 x42));\n        x = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> (Times x51 x52 \\<le> y1 \\<longrightarrow>\n                          Times x51 x52 \\<noteq> y1 \\<longrightarrow>\n                          (le_rexp (Times x51 x52) y1 \\<longrightarrow>\n                           (le_rexp y2 y1 \\<longrightarrow>\n                            (y2 = y1 \\<longrightarrow>\n                             Times x51 x52 \\<notin> set ys) \\<and>\n                            (y2 \\<noteq> y1 \\<longrightarrow>\n                             Times x51 x52 \\<noteq> y2 \\<and>\n                             Times x51 x52 \\<notin> set ys)) \\<and>\n                           (\\<not> le_rexp y2 y1 \\<longrightarrow>\n                            (y2 = y1 \\<longrightarrow>\n                             Times x51 x52 \\<notin> set ys) \\<and>\n                            (y2 \\<noteq> y1 \\<longrightarrow>\n                             (Times x51 x52 = y2 \\<longrightarrow>\n                              pnPlus y2 (PLUS (y2 # ys)) =\n                              PLUS (y2 # ys)) \\<and>\n                             Times x51 x52 \\<notin> set ys))) \\<and>\n                          (\\<not> le_rexp (Times x51 x52)\n                                   y1 \\<longrightarrow>\n                           (le_rexp y2 y1 \\<longrightarrow>\n                            (y2 = y1 \\<longrightarrow>\n                             (Times x51 x52 \\<in> set ys \\<longrightarrow>\n                              pnPlus (Times x51 x52) (PLUS (y1 # ys)) =\n                              PLUS (y1 # ys)) \\<and>\n                             Times x51 x52 \\<in> set ys) \\<and>\n                            (y2 \\<noteq> y1 \\<longrightarrow>\n                             Times x51 x52 \\<noteq> y2 \\<and>\n                             (Times x51 x52 = y2 \\<or>\n                              Times x51 x52 \\<in> set ys))) \\<and>\n                           (\\<not> le_rexp y2 y1 \\<longrightarrow>\n                            (y2 = y1 \\<longrightarrow>\n                             (Times x51 x52 \\<in> set ys \\<longrightarrow>\n                              pnPlus (Times x51 x52) (PLUS (y1 # ys)) =\n                              PLUS (y1 # ys)) \\<and>\n                             Times x51 x52 \\<in> set ys) \\<and>\n                            (y2 \\<noteq> y1 \\<longrightarrow>\n                             (Times x51 x52 = y2 \\<longrightarrow>\n                              pnPlus y2 (PLUS (y2 # ys)) =\n                              PLUS (y2 # ys)) \\<and>\n                             (Times x51 x52 = y2 \\<or>\n                              Times x51 x52 \\<in> set ys))))) \\<and>\n                         (\\<not> Times x51 x52 \\<le> y1 \\<longrightarrow>\n                          Times x51 x52 \\<noteq> y1 \\<longrightarrow>\n                          (le_rexp (Times x51 x52) y1 \\<longrightarrow>\n                           (le_rexp y2 y1 \\<longrightarrow>\n                            y2 \\<noteq> y1 \\<and>\n                            (y2 \\<noteq> y1 \\<longrightarrow>\n                             Times x51 x52 \\<noteq> y2 \\<and>\n                             Times x51 x52 \\<notin> set ys \\<and>\n                             (Times x51 x52 = y2 \\<or>\n                              Times x51 x52 \\<in> set ys))) \\<and>\n                           (\\<not> le_rexp y2 y1 \\<longrightarrow>\n                            y2 \\<noteq> y1 \\<and>\n                            (y2 \\<noteq> y1 \\<longrightarrow>\n                             (Times x51 x52 = y2 \\<longrightarrow>\n                              pnPlus y2 (PLUS (y2 # ys)) =\n                              PLUS (y2 # ys)) \\<and>\n                             Times x51 x52 \\<notin> set ys \\<and>\n                             (Times x51 x52 = y2 \\<or>\n                              Times x51 x52 \\<in> set ys)))) \\<and>\n                          (\\<not> le_rexp (Times x51 x52)\n                                   y1 \\<longrightarrow>\n                           (le_rexp y2 y1 \\<longrightarrow>\n                            (y2 = y1 \\<longrightarrow>\n                             (Times x51 x52 \\<in> set ys \\<longrightarrow>\n                              pnPlus (Times x51 x52) (PLUS (y1 # ys)) =\n                              PLUS (y1 # ys)) \\<and>\n                             (Times x51 x52\n                              \\<notin> set ys \\<longrightarrow>\n                              pnPlus (Times x51 x52) (PLUS (y1 # ys)) =\n                              PLUS (y1 # insort (Times x51 x52) ys))) \\<and>\n                            (y2 \\<noteq> y1 \\<longrightarrow>\n                             Times x51 x52 \\<noteq> y2)) \\<and>\n                           (\\<not> le_rexp y2 y1 \\<longrightarrow>\n                            (y2 = y1 \\<longrightarrow>\n                             (Times x51 x52 \\<in> set ys \\<longrightarrow>\n                              pnPlus (Times x51 x52) (PLUS (y1 # ys)) =\n                              PLUS (y1 # ys)) \\<and>\n                             (Times x51 x52\n                              \\<notin> set ys \\<longrightarrow>\n                              pnPlus (Times x51 x52) (PLUS (y1 # ys)) =\n                              PLUS (y1 # insort (Times x51 x52) ys))) \\<and>\n                            (y2 \\<noteq> y1 \\<longrightarrow>\n                             Times x51 x52 = y2 \\<longrightarrow>\n                             pnPlus y2 (PLUS (y2 # ys)) = PLUS (y2 # ys)))))\n 2. \\<And>x6.\n       \\<lbrakk>\\<lbrakk>y2 # ys \\<noteq> []; sorted (y2 # ys);\n                 distinct (y2 # ys);\n                 \\<forall>x\\<in>{x} \\<union> set (y2 # ys).\n                    x \\<noteq> Zero \\<and>\n                    (\\<nexists>x41 x42. x = Plus x41 x42)\\<rbrakk>\n                \\<Longrightarrow> pnPlus x (PLUS (y2 # ys)) =\n                                  (if x \\<in> set (y2 # ys)\n                                   then PLUS (y2 # ys)\n                                   else PLUS (insort x (y2 # ys)));\n        y1 # y2 # ys \\<noteq> []; sorted (y1 # y2 # ys);\n        distinct (y1 # y2 # ys);\n        \\<forall>x\\<in>{x} \\<union> set (y1 # y2 # ys).\n           x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n        x = Star x6\\<rbrakk>\n       \\<Longrightarrow> pnPlus x (PLUS (y1 # y2 # ys)) =\n                         (if x \\<in> set (y1 # y2 # ys)\n                          then PLUS (y1 # y2 # ys)\n                          else PLUS (insort x (y1 # y2 # ys)))", "apply (metis antisym less_eq_rexp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x6.\n       \\<lbrakk>\\<lbrakk>y2 # ys \\<noteq> []; sorted (y2 # ys);\n                 distinct (y2 # ys);\n                 \\<forall>x\\<in>{x} \\<union> set (y2 # ys).\n                    x \\<noteq> Zero \\<and>\n                    (\\<nexists>x41 x42. x = Plus x41 x42)\\<rbrakk>\n                \\<Longrightarrow> pnPlus x (PLUS (y2 # ys)) =\n                                  (if x \\<in> set (y2 # ys)\n                                   then PLUS (y2 # ys)\n                                   else PLUS (insort x (y2 # ys)));\n        y1 # y2 # ys \\<noteq> []; sorted (y1 # y2 # ys);\n        distinct (y1 # y2 # ys);\n        \\<forall>x\\<in>{x} \\<union> set (y1 # y2 # ys).\n           x \\<noteq> Zero \\<and> (\\<nexists>x41 x42. x = Plus x41 x42);\n        x = Star x6\\<rbrakk>\n       \\<Longrightarrow> pnPlus x (PLUS (y1 # y2 # ys)) =\n                         (if x \\<in> set (y1 # y2 # ys)\n                          then PLUS (y1 # y2 # ys)\n                          else PLUS (insort x (y1 # y2 # ys)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x6.\n       \\<lbrakk>pnPlus (Star x6) (PLUS (y2 # ys)) =\n                (if Star x6 = y2 \\<or> Star x6 \\<in> set ys\n                 then PLUS (y2 # ys) else PLUS (insort x (y2 # ys)));\n        y1 \\<le> y2 \\<and>\n        (\\<forall>x\\<in>set ys. y1 \\<le> x) \\<and>\n        (\\<forall>x\\<in>set ys. y2 \\<le> x) \\<and> sorted ys;\n        y1 \\<noteq> y2 \\<and>\n        y1 \\<notin> set ys \\<and> y2 \\<notin> set ys \\<and> distinct ys;\n        y1 \\<noteq> Zero \\<and>\n        (\\<forall>x41 x42. y1 \\<noteq> Plus x41 x42) \\<and>\n        y2 \\<noteq> Zero \\<and>\n        (\\<forall>x41 x42. y2 \\<noteq> Plus x41 x42) \\<and>\n        (\\<forall>x\\<in>set ys.\n            x \\<noteq> Zero \\<and>\n            (\\<forall>x41 x42. x \\<noteq> Plus x41 x42));\n        x = Star x6\\<rbrakk>\n       \\<Longrightarrow> (Star x6 \\<le> y1 \\<longrightarrow>\n                          Star x6 \\<noteq> y1 \\<longrightarrow>\n                          (le_rexp (Star x6) y1 \\<longrightarrow>\n                           (le_rexp y2 y1 \\<longrightarrow>\n                            (y2 = y1 \\<longrightarrow>\n                             Star x6 \\<notin> set ys) \\<and>\n                            (y2 \\<noteq> y1 \\<longrightarrow>\n                             Star x6 \\<noteq> y2 \\<and>\n                             Star x6 \\<notin> set ys)) \\<and>\n                           (\\<not> le_rexp y2 y1 \\<longrightarrow>\n                            (y2 = y1 \\<longrightarrow>\n                             Star x6 \\<notin> set ys) \\<and>\n                            (y2 \\<noteq> y1 \\<longrightarrow>\n                             (Star x6 = y2 \\<longrightarrow>\n                              pnPlus y2 (PLUS (y2 # ys)) =\n                              PLUS (y2 # ys)) \\<and>\n                             Star x6 \\<notin> set ys))) \\<and>\n                          (\\<not> le_rexp (Star x6) y1 \\<longrightarrow>\n                           (le_rexp y2 y1 \\<longrightarrow>\n                            (y2 = y1 \\<longrightarrow>\n                             (Star x6 \\<in> set ys \\<longrightarrow>\n                              pnPlus (Star x6) (PLUS (y1 # ys)) =\n                              PLUS (y1 # ys)) \\<and>\n                             Star x6 \\<in> set ys) \\<and>\n                            (y2 \\<noteq> y1 \\<longrightarrow>\n                             Star x6 \\<noteq> y2 \\<and>\n                             (Star x6 = y2 \\<or>\n                              Star x6 \\<in> set ys))) \\<and>\n                           (\\<not> le_rexp y2 y1 \\<longrightarrow>\n                            (y2 = y1 \\<longrightarrow>\n                             (Star x6 \\<in> set ys \\<longrightarrow>\n                              pnPlus (Star x6) (PLUS (y1 # ys)) =\n                              PLUS (y1 # ys)) \\<and>\n                             Star x6 \\<in> set ys) \\<and>\n                            (y2 \\<noteq> y1 \\<longrightarrow>\n                             (Star x6 = y2 \\<longrightarrow>\n                              pnPlus y2 (PLUS (y2 # ys)) =\n                              PLUS (y2 # ys)) \\<and>\n                             (Star x6 = y2 \\<or>\n                              Star x6 \\<in> set ys))))) \\<and>\n                         (\\<not> Star x6 \\<le> y1 \\<longrightarrow>\n                          Star x6 \\<noteq> y1 \\<longrightarrow>\n                          (le_rexp (Star x6) y1 \\<longrightarrow>\n                           (le_rexp y2 y1 \\<longrightarrow>\n                            y2 \\<noteq> y1 \\<and>\n                            (y2 \\<noteq> y1 \\<longrightarrow>\n                             Star x6 \\<noteq> y2 \\<and>\n                             Star x6 \\<notin> set ys \\<and>\n                             (Star x6 = y2 \\<or>\n                              Star x6 \\<in> set ys))) \\<and>\n                           (\\<not> le_rexp y2 y1 \\<longrightarrow>\n                            y2 \\<noteq> y1 \\<and>\n                            (y2 \\<noteq> y1 \\<longrightarrow>\n                             (Star x6 = y2 \\<longrightarrow>\n                              pnPlus y2 (PLUS (y2 # ys)) =\n                              PLUS (y2 # ys)) \\<and>\n                             Star x6 \\<notin> set ys \\<and>\n                             (Star x6 = y2 \\<or>\n                              Star x6 \\<in> set ys)))) \\<and>\n                          (\\<not> le_rexp (Star x6) y1 \\<longrightarrow>\n                           (le_rexp y2 y1 \\<longrightarrow>\n                            (y2 = y1 \\<longrightarrow>\n                             (Star x6 \\<in> set ys \\<longrightarrow>\n                              pnPlus (Star x6) (PLUS (y1 # ys)) =\n                              PLUS (y1 # ys)) \\<and>\n                             (Star x6 \\<notin> set ys \\<longrightarrow>\n                              pnPlus (Star x6) (PLUS (y1 # ys)) =\n                              PLUS (y1 # insort (Star x6) ys))) \\<and>\n                            (y2 \\<noteq> y1 \\<longrightarrow>\n                             Star x6 \\<noteq> y2)) \\<and>\n                           (\\<not> le_rexp y2 y1 \\<longrightarrow>\n                            (y2 = y1 \\<longrightarrow>\n                             (Star x6 \\<in> set ys \\<longrightarrow>\n                              pnPlus (Star x6) (PLUS (y1 # ys)) =\n                              PLUS (y1 # ys)) \\<and>\n                             (Star x6 \\<notin> set ys \\<longrightarrow>\n                              pnPlus (Star x6) (PLUS (y1 # ys)) =\n                              PLUS (y1 # insort (Star x6) ys))) \\<and>\n                            (y2 \\<noteq> y1 \\<longrightarrow>\n                             Star x6 = y2 \\<longrightarrow>\n                             pnPlus y2 (PLUS (y2 # ys)) = PLUS (y2 # ys)))))", "apply (metis antisym less_eq_rexp_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  pnPlus x (PLUS (y1 # y2 # ys)) =\n  (if x \\<in> set (y1 # y2 # ys) then PLUS (y1 # y2 # ys)\n   else PLUS (insort x (y1 # y2 # ys)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>[] \\<noteq> []; sorted []; distinct [];\n     \\<forall>x\\<in>{x} \\<union> set [].\n        \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n    \\<Longrightarrow> pnPlus x (PLUS []) =\n                      (if x \\<in> set [] then PLUS []\n                       else PLUS (insort x []))", "qed simp"], ["", "lemma pnPlus_PlusL[simp]: \"t \\<noteq> Zero \\<Longrightarrow> pnPlus (Plus r s) t = pnPlus r (pnPlus s t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<noteq> Zero \\<Longrightarrow>\n    pnPlus (Plus r s) t = pnPlus r (pnPlus s t)", "by (induct t) auto"], ["", "lemma pnPlus_ZeroR[simp]: \"pnPlus r Zero = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pnPlus r Zero = r", "by (induct r) auto"], ["", "lemma PLUS_eq_Zero: \"PLUS xs = Zero \\<longleftrightarrow> xs = [] \\<or> xs = [Zero]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (PLUS xs = Zero) = (xs = [] \\<or> xs = [Zero])", "by (induct xs rule: list_singleton_induct) auto"], ["", "lemma pnPlus_PLUS:\n  \"\\<lbrakk>xs1 \\<noteq> []; xs2 \\<noteq> []; \\<forall>x \\<in> set (xs1 @ xs2). \\<not>is_Zero x \\<and> \\<not>is_Plus x; sorted xs2; distinct xs2\\<rbrakk>\\<Longrightarrow>\n  pnPlus (PLUS xs1) (PLUS xs2) = flatten PLUS (set (xs1 @ xs2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs1 \\<noteq> []; xs2 \\<noteq> [];\n     \\<forall>x\\<in>set (xs1 @ xs2).\n        \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n     sorted xs2; distinct xs2\\<rbrakk>\n    \\<Longrightarrow> pnPlus (PLUS xs1) (PLUS xs2) =\n                      flatten PLUS (set (xs1 @ xs2))", "proof (induct xs1 arbitrary: xs2 rule: list_singleton_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xs2.\n       \\<lbrakk>[] \\<noteq> []; xs2 \\<noteq> [];\n        \\<forall>x\\<in>set ([] @ xs2).\n           \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n        sorted xs2; distinct xs2\\<rbrakk>\n       \\<Longrightarrow> pnPlus (PLUS []) (PLUS xs2) =\n                         flatten PLUS (set ([] @ xs2))\n 2. \\<And>x xs2.\n       \\<lbrakk>[x] \\<noteq> []; xs2 \\<noteq> [];\n        \\<forall>x\\<in>set ([x] @ xs2).\n           \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n        sorted xs2; distinct xs2\\<rbrakk>\n       \\<Longrightarrow> pnPlus (PLUS [x]) (PLUS xs2) =\n                         flatten PLUS (set ([x] @ xs2))\n 3. \\<And>x y xs xs2.\n       \\<lbrakk>\\<And>xs2.\n                   \\<lbrakk>y # xs \\<noteq> []; xs2 \\<noteq> [];\n                    \\<forall>x\\<in>set ((y # xs) @ xs2).\n                       \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n                    sorted xs2; distinct xs2\\<rbrakk>\n                   \\<Longrightarrow> pnPlus (PLUS (y # xs)) (PLUS xs2) =\n                                     flatten PLUS (set ((y # xs) @ xs2));\n        x # y # xs \\<noteq> []; xs2 \\<noteq> [];\n        \\<forall>x\\<in>set ((x # y # xs) @ xs2).\n           \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n        sorted xs2; distinct xs2\\<rbrakk>\n       \\<Longrightarrow> pnPlus (PLUS (x # y # xs)) (PLUS xs2) =\n                         flatten PLUS (set ((x # y # xs) @ xs2))", "case (single x1)"], ["proof (state)\nthis:\n  [x1] \\<noteq> []\n  xs2 \\<noteq> []\n  \\<forall>x\\<in>set ([x1] @ xs2). \\<not> is_Zero x \\<and> \\<not> is_Plus x\n  sorted xs2\n  distinct xs2\n\ngoal (3 subgoals):\n 1. \\<And>xs2.\n       \\<lbrakk>[] \\<noteq> []; xs2 \\<noteq> [];\n        \\<forall>x\\<in>set ([] @ xs2).\n           \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n        sorted xs2; distinct xs2\\<rbrakk>\n       \\<Longrightarrow> pnPlus (PLUS []) (PLUS xs2) =\n                         flatten PLUS (set ([] @ xs2))\n 2. \\<And>x xs2.\n       \\<lbrakk>[x] \\<noteq> []; xs2 \\<noteq> [];\n        \\<forall>x\\<in>set ([x] @ xs2).\n           \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n        sorted xs2; distinct xs2\\<rbrakk>\n       \\<Longrightarrow> pnPlus (PLUS [x]) (PLUS xs2) =\n                         flatten PLUS (set ([x] @ xs2))\n 3. \\<And>x y xs xs2.\n       \\<lbrakk>\\<And>xs2.\n                   \\<lbrakk>y # xs \\<noteq> []; xs2 \\<noteq> [];\n                    \\<forall>x\\<in>set ((y # xs) @ xs2).\n                       \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n                    sorted xs2; distinct xs2\\<rbrakk>\n                   \\<Longrightarrow> pnPlus (PLUS (y # xs)) (PLUS xs2) =\n                                     flatten PLUS (set ((y # xs) @ xs2));\n        x # y # xs \\<noteq> []; xs2 \\<noteq> [];\n        \\<forall>x\\<in>set ((x # y # xs) @ xs2).\n           \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n        sorted xs2; distinct xs2\\<rbrakk>\n       \\<Longrightarrow> pnPlus (PLUS (x # y # xs)) (PLUS xs2) =\n                         flatten PLUS (set ((x # y # xs) @ xs2))", "thus ?case"], ["proof (prove)\nusing this:\n  [x1] \\<noteq> []\n  xs2 \\<noteq> []\n  \\<forall>x\\<in>set ([x1] @ xs2). \\<not> is_Zero x \\<and> \\<not> is_Plus x\n  sorted xs2\n  distinct xs2\n\ngoal (1 subgoal):\n 1. pnPlus (PLUS [x1]) (PLUS xs2) = flatten PLUS (set ([x1] @ xs2))", "apply (auto intro!: trans[OF pnPlus_singleton_PLUS]\n      simp: insert_absorb simp del: sorted_list_of_set_insert)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>xs2 \\<noteq> []; sorted xs2; distinct xs2;\n     \\<forall>x\\<in>set xs2. \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n     x1 \\<in> set xs2\\<rbrakk>\n    \\<Longrightarrow> PLUS xs2 = flatten PLUS (set xs2)\n 2. \\<lbrakk>xs2 \\<noteq> []; sorted xs2; distinct xs2; \\<not> is_Zero x1;\n     \\<not> is_Plus x1;\n     \\<forall>x\\<in>set xs2. \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n     x1 \\<notin> set xs2\\<rbrakk>\n    \\<Longrightarrow> PLUS (insort x1 xs2) =\n                      PLUS (flatten (insort x1) (set xs2))", "apply (metis List.finite_set finite_sorted_distinct_unique sorted_list_of_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs2 \\<noteq> []; sorted xs2; distinct xs2; \\<not> is_Zero x1;\n     \\<not> is_Plus x1;\n     \\<forall>x\\<in>set xs2. \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n     x1 \\<notin> set xs2\\<rbrakk>\n    \\<Longrightarrow> PLUS (insort x1 xs2) =\n                      PLUS (flatten (insort x1) (set xs2))", "apply (rule arg_cong[of _ _ PLUS])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs2 \\<noteq> []; sorted xs2; distinct xs2; \\<not> is_Zero x1;\n     \\<not> is_Plus x1;\n     \\<forall>x\\<in>set xs2. \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n     x1 \\<notin> set xs2\\<rbrakk>\n    \\<Longrightarrow> insort x1 xs2 = flatten (insort x1) (set xs2)", "apply (metis remdups_id_iff_distinct sorted_list_of_set_sort_remdups sorted_sort_id)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  pnPlus (PLUS [x1]) (PLUS xs2) = flatten PLUS (set ([x1] @ xs2))\n\ngoal (2 subgoals):\n 1. \\<And>xs2.\n       \\<lbrakk>[] \\<noteq> []; xs2 \\<noteq> [];\n        \\<forall>x\\<in>set ([] @ xs2).\n           \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n        sorted xs2; distinct xs2\\<rbrakk>\n       \\<Longrightarrow> pnPlus (PLUS []) (PLUS xs2) =\n                         flatten PLUS (set ([] @ xs2))\n 2. \\<And>x y xs xs2.\n       \\<lbrakk>\\<And>xs2.\n                   \\<lbrakk>y # xs \\<noteq> []; xs2 \\<noteq> [];\n                    \\<forall>x\\<in>set ((y # xs) @ xs2).\n                       \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n                    sorted xs2; distinct xs2\\<rbrakk>\n                   \\<Longrightarrow> pnPlus (PLUS (y # xs)) (PLUS xs2) =\n                                     flatten PLUS (set ((y # xs) @ xs2));\n        x # y # xs \\<noteq> []; xs2 \\<noteq> [];\n        \\<forall>x\\<in>set ((x # y # xs) @ xs2).\n           \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n        sorted xs2; distinct xs2\\<rbrakk>\n       \\<Longrightarrow> pnPlus (PLUS (x # y # xs)) (PLUS xs2) =\n                         flatten PLUS (set ((x # y # xs) @ xs2))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs2.\n       \\<lbrakk>[] \\<noteq> []; xs2 \\<noteq> [];\n        \\<forall>x\\<in>set ([] @ xs2).\n           \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n        sorted xs2; distinct xs2\\<rbrakk>\n       \\<Longrightarrow> pnPlus (PLUS []) (PLUS xs2) =\n                         flatten PLUS (set ([] @ xs2))\n 2. \\<And>x y xs xs2.\n       \\<lbrakk>\\<And>xs2.\n                   \\<lbrakk>y # xs \\<noteq> []; xs2 \\<noteq> [];\n                    \\<forall>x\\<in>set ((y # xs) @ xs2).\n                       \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n                    sorted xs2; distinct xs2\\<rbrakk>\n                   \\<Longrightarrow> pnPlus (PLUS (y # xs)) (PLUS xs2) =\n                                     flatten PLUS (set ((y # xs) @ xs2));\n        x # y # xs \\<noteq> []; xs2 \\<noteq> [];\n        \\<forall>x\\<in>set ((x # y # xs) @ xs2).\n           \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n        sorted xs2; distinct xs2\\<rbrakk>\n       \\<Longrightarrow> pnPlus (PLUS (x # y # xs)) (PLUS xs2) =\n                         flatten PLUS (set ((x # y # xs) @ xs2))", "case (cons x11 x12 xs1)"], ["proof (state)\nthis:\n  \\<lbrakk>x12 # xs1 \\<noteq> []; ?xs2.0 \\<noteq> [];\n   \\<forall>x\\<in>set ((x12 # xs1) @ ?xs2.0).\n      \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n   sorted ?xs2.0; distinct ?xs2.0\\<rbrakk>\n  \\<Longrightarrow> pnPlus (PLUS (x12 # xs1)) (PLUS ?xs2.0) =\n                    flatten PLUS (set ((x12 # xs1) @ ?xs2.0))\n  x11 # x12 # xs1 \\<noteq> []\n  xs2 \\<noteq> []\n  \\<forall>x\\<in>set ((x11 # x12 # xs1) @ xs2).\n     \\<not> is_Zero x \\<and> \\<not> is_Plus x\n  sorted xs2\n  distinct xs2\n\ngoal (2 subgoals):\n 1. \\<And>xs2.\n       \\<lbrakk>[] \\<noteq> []; xs2 \\<noteq> [];\n        \\<forall>x\\<in>set ([] @ xs2).\n           \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n        sorted xs2; distinct xs2\\<rbrakk>\n       \\<Longrightarrow> pnPlus (PLUS []) (PLUS xs2) =\n                         flatten PLUS (set ([] @ xs2))\n 2. \\<And>x y xs xs2.\n       \\<lbrakk>\\<And>xs2.\n                   \\<lbrakk>y # xs \\<noteq> []; xs2 \\<noteq> [];\n                    \\<forall>x\\<in>set ((y # xs) @ xs2).\n                       \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n                    sorted xs2; distinct xs2\\<rbrakk>\n                   \\<Longrightarrow> pnPlus (PLUS (y # xs)) (PLUS xs2) =\n                                     flatten PLUS (set ((y # xs) @ xs2));\n        x # y # xs \\<noteq> []; xs2 \\<noteq> [];\n        \\<forall>x\\<in>set ((x # y # xs) @ xs2).\n           \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n        sorted xs2; distinct xs2\\<rbrakk>\n       \\<Longrightarrow> pnPlus (PLUS (x # y # xs)) (PLUS xs2) =\n                         flatten PLUS (set ((x # y # xs) @ xs2))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>x12 # xs1 \\<noteq> []; ?xs2.0 \\<noteq> [];\n   \\<forall>x\\<in>set ((x12 # xs1) @ ?xs2.0).\n      \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n   sorted ?xs2.0; distinct ?xs2.0\\<rbrakk>\n  \\<Longrightarrow> pnPlus (PLUS (x12 # xs1)) (PLUS ?xs2.0) =\n                    flatten PLUS (set ((x12 # xs1) @ ?xs2.0))\n  x11 # x12 # xs1 \\<noteq> []\n  xs2 \\<noteq> []\n  \\<forall>x\\<in>set ((x11 # x12 # xs1) @ xs2).\n     \\<not> is_Zero x \\<and> \\<not> is_Plus x\n  sorted xs2\n  distinct xs2", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>x12 # xs1 \\<noteq> []; ?xs2.0 \\<noteq> [];\n   \\<forall>x\\<in>set ((x12 # xs1) @ ?xs2.0).\n      \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n   sorted ?xs2.0; distinct ?xs2.0\\<rbrakk>\n  \\<Longrightarrow> pnPlus (PLUS (x12 # xs1)) (PLUS ?xs2.0) =\n                    flatten PLUS (set ((x12 # xs1) @ ?xs2.0))\n  x11 # x12 # xs1 \\<noteq> []\n  xs2 \\<noteq> []\n  \\<forall>x\\<in>set ((x11 # x12 # xs1) @ xs2).\n     \\<not> is_Zero x \\<and> \\<not> is_Plus x\n  sorted xs2\n  distinct xs2\n\ngoal (1 subgoal):\n 1. pnPlus (PLUS (x11 # x12 # xs1)) (PLUS xs2) =\n    flatten PLUS (set ((x11 # x12 # xs1) @ xs2))", "unfolding rexp_of_list.simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>x12 # xs1 \\<noteq> []; ?xs2.0 \\<noteq> [];\n   \\<forall>x\\<in>set ((x12 # xs1) @ ?xs2.0).\n      \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n   sorted ?xs2.0; distinct ?xs2.0\\<rbrakk>\n  \\<Longrightarrow> pnPlus (PLUS (x12 # xs1)) (PLUS ?xs2.0) =\n                    flatten PLUS (set ((x12 # xs1) @ ?xs2.0))\n  x11 # x12 # xs1 \\<noteq> []\n  xs2 \\<noteq> []\n  \\<forall>x\\<in>set ((x11 # x12 # xs1) @ xs2).\n     \\<not> is_Zero x \\<and> \\<not> is_Plus x\n  sorted xs2\n  distinct xs2\n\ngoal (1 subgoal):\n 1. pnPlus (Plus x11 (PLUS (x12 # xs1))) (PLUS xs2) =\n    flatten PLUS (set ((x11 # x12 # xs1) @ xs2))", "apply (subst pnPlus_PlusL)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>x12 # xs1 \\<noteq> []; xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set ((x12 # xs1) @ xs2).\n                    \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> pnPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  flatten PLUS (set ((x12 # xs1) @ xs2));\n     x11 # x12 # xs1 \\<noteq> []; xs2 \\<noteq> [];\n     \\<forall>x\\<in>set ((x11 # x12 # xs1) @ xs2).\n        \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n     sorted xs2; distinct xs2\\<rbrakk>\n    \\<Longrightarrow> PLUS xs2 \\<noteq> Zero\n 2. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>x12 # xs1 \\<noteq> []; xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set ((x12 # xs1) @ xs2).\n                    \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> pnPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  flatten PLUS (set ((x12 # xs1) @ xs2));\n     x11 # x12 # xs1 \\<noteq> []; xs2 \\<noteq> [];\n     \\<forall>x\\<in>set ((x11 # x12 # xs1) @ xs2).\n        \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n     sorted xs2; distinct xs2\\<rbrakk>\n    \\<Longrightarrow> pnPlus x11 (pnPlus (PLUS (x12 # xs1)) (PLUS xs2)) =\n                      flatten PLUS (set ((x11 # x12 # xs1) @ xs2))", "apply (unfold PLUS_eq_Zero) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>x12 # xs1 \\<noteq> []; xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set ((x12 # xs1) @ xs2).\n                    \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> pnPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  flatten PLUS (set ((x12 # xs1) @ xs2));\n     x11 # x12 # xs1 \\<noteq> []; xs2 \\<noteq> [];\n     \\<forall>x\\<in>set ((x11 # x12 # xs1) @ xs2).\n        \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n     sorted xs2; distinct xs2\\<rbrakk>\n    \\<Longrightarrow> \\<not> (xs2 = [] \\<or> xs2 = [Zero])\n 2. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>x12 # xs1 \\<noteq> []; xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set ((x12 # xs1) @ xs2).\n                    \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> pnPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  flatten PLUS (set ((x12 # xs1) @ xs2));\n     x11 # x12 # xs1 \\<noteq> []; xs2 \\<noteq> [];\n     \\<forall>x\\<in>set ((x11 # x12 # xs1) @ xs2).\n        \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n     sorted xs2; distinct xs2\\<rbrakk>\n    \\<Longrightarrow> pnPlus x11 (pnPlus (PLUS (x12 # xs1)) (PLUS xs2)) =\n                      flatten PLUS (set ((x11 # x12 # xs1) @ xs2))", "apply (metis in_set_conv_decomp rexp.disc(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>x12 # xs1 \\<noteq> []; xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set ((x12 # xs1) @ xs2).\n                    \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> pnPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  flatten PLUS (set ((x12 # xs1) @ xs2));\n     x11 # x12 # xs1 \\<noteq> []; xs2 \\<noteq> [];\n     \\<forall>x\\<in>set ((x11 # x12 # xs1) @ xs2).\n        \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n     sorted xs2; distinct xs2\\<rbrakk>\n    \\<Longrightarrow> pnPlus x11 (pnPlus (PLUS (x12 # xs1)) (PLUS xs2)) =\n                      flatten PLUS (set ((x11 # x12 # xs1) @ xs2))", "apply (subst cons(1))"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>x12 # xs1 \\<noteq> []; xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set ((x12 # xs1) @ xs2).\n                    \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> pnPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  flatten PLUS (set ((x12 # xs1) @ xs2));\n     x11 # x12 # xs1 \\<noteq> []; xs2 \\<noteq> [];\n     \\<forall>x\\<in>set ((x11 # x12 # xs1) @ xs2).\n        \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n     sorted xs2; distinct xs2\\<rbrakk>\n    \\<Longrightarrow> x12 # xs1 \\<noteq> []\n 2. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>x12 # xs1 \\<noteq> []; xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set ((x12 # xs1) @ xs2).\n                    \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> pnPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  flatten PLUS (set ((x12 # xs1) @ xs2));\n     x11 # x12 # xs1 \\<noteq> []; xs2 \\<noteq> [];\n     \\<forall>x\\<in>set ((x11 # x12 # xs1) @ xs2).\n        \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n     sorted xs2; distinct xs2\\<rbrakk>\n    \\<Longrightarrow> xs2 \\<noteq> []\n 3. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>x12 # xs1 \\<noteq> []; xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set ((x12 # xs1) @ xs2).\n                    \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> pnPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  flatten PLUS (set ((x12 # xs1) @ xs2));\n     x11 # x12 # xs1 \\<noteq> []; xs2 \\<noteq> [];\n     \\<forall>x\\<in>set ((x11 # x12 # xs1) @ xs2).\n        \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n     sorted xs2; distinct xs2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set ((x12 # xs1) @ xs2).\n                         \\<not> is_Zero x \\<and> \\<not> is_Plus x\n 4. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>x12 # xs1 \\<noteq> []; xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set ((x12 # xs1) @ xs2).\n                    \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> pnPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  flatten PLUS (set ((x12 # xs1) @ xs2));\n     x11 # x12 # xs1 \\<noteq> []; xs2 \\<noteq> [];\n     \\<forall>x\\<in>set ((x11 # x12 # xs1) @ xs2).\n        \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n     sorted xs2; distinct xs2\\<rbrakk>\n    \\<Longrightarrow> sorted xs2\n 5. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>x12 # xs1 \\<noteq> []; xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set ((x12 # xs1) @ xs2).\n                    \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> pnPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  flatten PLUS (set ((x12 # xs1) @ xs2));\n     x11 # x12 # xs1 \\<noteq> []; xs2 \\<noteq> [];\n     \\<forall>x\\<in>set ((x11 # x12 # xs1) @ xs2).\n        \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n     sorted xs2; distinct xs2\\<rbrakk>\n    \\<Longrightarrow> distinct xs2\n 6. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>x12 # xs1 \\<noteq> []; xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set ((x12 # xs1) @ xs2).\n                    \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> pnPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  flatten PLUS (set ((x12 # xs1) @ xs2));\n     x11 # x12 # xs1 \\<noteq> []; xs2 \\<noteq> [];\n     \\<forall>x\\<in>set ((x11 # x12 # xs1) @ xs2).\n        \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n     sorted xs2; distinct xs2\\<rbrakk>\n    \\<Longrightarrow> pnPlus x11 (flatten PLUS (set ((x12 # xs1) @ xs2))) =\n                      flatten PLUS (set ((x11 # x12 # xs1) @ xs2))", "apply (simp_all del: sorted_list_of_set_insert)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set xs1 \\<union> set xs2.\n                    \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> pnPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  flatten PLUS\n                                   (insert x12 (set xs1 \\<union> set xs2));\n     xs2 \\<noteq> [];\n     \\<not> is_Zero x11 \\<and>\n     \\<not> is_Plus x11 \\<and>\n     \\<not> is_Zero x12 \\<and>\n     \\<not> is_Plus x12 \\<and>\n     (\\<forall>x\\<in>set xs1 \\<union> set xs2.\n         \\<not> is_Zero x \\<and> \\<not> is_Plus x);\n     sorted xs2; distinct xs2\\<rbrakk>\n    \\<Longrightarrow> pnPlus x11\n                       (flatten PLUS\n                         (insert x12 (set xs1 \\<union> set xs2))) =\n                      flatten PLUS\n                       (insert x11 (insert x12 (set xs1 \\<union> set xs2)))", "apply (rule trans[OF pnPlus_singleton_PLUS])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set xs1 \\<union> set xs2.\n                    \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> pnPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  flatten PLUS\n                                   (insert x12 (set xs1 \\<union> set xs2));\n     xs2 \\<noteq> [];\n     \\<not> is_Zero x11 \\<and>\n     \\<not> is_Plus x11 \\<and>\n     \\<not> is_Zero x12 \\<and>\n     \\<not> is_Plus x12 \\<and>\n     (\\<forall>x\\<in>set xs1 \\<union> set xs2.\n         \\<not> is_Zero x \\<and> \\<not> is_Plus x);\n     sorted xs2; distinct xs2\\<rbrakk>\n    \\<Longrightarrow> flatten (\\<noteq>)\n                       (insert x12 (set xs1 \\<union> set xs2)) []\n 2. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set xs1 \\<union> set xs2.\n                    \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> pnPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  flatten PLUS\n                                   (insert x12 (set xs1 \\<union> set xs2));\n     xs2 \\<noteq> [];\n     \\<not> is_Zero x11 \\<and>\n     \\<not> is_Plus x11 \\<and>\n     \\<not> is_Zero x12 \\<and>\n     \\<not> is_Plus x12 \\<and>\n     (\\<forall>x\\<in>set xs1 \\<union> set xs2.\n         \\<not> is_Zero x \\<and> \\<not> is_Plus x);\n     sorted xs2; distinct xs2\\<rbrakk>\n    \\<Longrightarrow> flatten sorted (insert x12 (set xs1 \\<union> set xs2))\n 3. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set xs1 \\<union> set xs2.\n                    \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> pnPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  flatten PLUS\n                                   (insert x12 (set xs1 \\<union> set xs2));\n     xs2 \\<noteq> [];\n     \\<not> is_Zero x11 \\<and>\n     \\<not> is_Plus x11 \\<and>\n     \\<not> is_Zero x12 \\<and>\n     \\<not> is_Plus x12 \\<and>\n     (\\<forall>x\\<in>set xs1 \\<union> set xs2.\n         \\<not> is_Zero x \\<and> \\<not> is_Plus x);\n     sorted xs2; distinct xs2\\<rbrakk>\n    \\<Longrightarrow> flatten distinct\n                       (insert x12 (set xs1 \\<union> set xs2))\n 4. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set xs1 \\<union> set xs2.\n                    \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> pnPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  flatten PLUS\n                                   (insert x12 (set xs1 \\<union> set xs2));\n     xs2 \\<noteq> [];\n     \\<not> is_Zero x11 \\<and>\n     \\<not> is_Plus x11 \\<and>\n     \\<not> is_Zero x12 \\<and>\n     \\<not> is_Plus x12 \\<and>\n     (\\<forall>x\\<in>set xs1 \\<union> set xs2.\n         \\<not> is_Zero x \\<and> \\<not> is_Plus x);\n     sorted xs2; distinct xs2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>{x11} \\<union>\n                                     flatten set\n(insert x12 (set xs1 \\<union> set xs2)).\n                         \\<not> is_Zero x \\<and> \\<not> is_Plus x\n 5. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set xs1 \\<union> set xs2.\n                    \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> pnPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  flatten PLUS\n                                   (insert x12 (set xs1 \\<union> set xs2));\n     xs2 \\<noteq> [];\n     \\<not> is_Zero x11 \\<and>\n     \\<not> is_Plus x11 \\<and>\n     \\<not> is_Zero x12 \\<and>\n     \\<not> is_Plus x12 \\<and>\n     (\\<forall>x\\<in>set xs1 \\<union> set xs2.\n         \\<not> is_Zero x \\<and> \\<not> is_Plus x);\n     sorted xs2; distinct xs2\\<rbrakk>\n    \\<Longrightarrow> (if x11\n                          \\<in> flatten set\n                                 (insert x12 (set xs1 \\<union> set xs2))\n                       then flatten PLUS\n                             (insert x12 (set xs1 \\<union> set xs2))\n                       else PLUS\n                             (flatten (insort x11)\n                               (insert x12 (set xs1 \\<union> set xs2)))) =\n                      flatten PLUS\n                       (insert x11 (insert x12 (set xs1 \\<union> set xs2)))", "apply (simp_all add: sorted_insort set_insort_key del: sorted_list_of_set_insert)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set xs1 \\<union> set xs2.\n                    \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> pnPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  flatten PLUS\n                                   (insert x12 (set xs1 \\<union> set xs2));\n     xs2 \\<noteq> [];\n     \\<not> is_Zero x11 \\<and>\n     \\<not> is_Plus x11 \\<and>\n     \\<not> is_Zero x12 \\<and>\n     \\<not> is_Plus x12 \\<and>\n     (\\<forall>x\\<in>set xs1 \\<union> set xs2.\n         \\<not> is_Zero x \\<and> \\<not> is_Plus x);\n     sorted xs2; distinct xs2\\<rbrakk>\n    \\<Longrightarrow> (x11 \\<in> set xs1 \\<longrightarrow>\n                       flatten PLUS\n                        (insert x12 (set xs1 \\<union> set xs2)) =\n                       flatten PLUS\n                        (insert x11\n                          (insert x12 (set xs1 \\<union> set xs2)))) \\<and>\n                      (x11 \\<in> set xs2 \\<longrightarrow>\n                       flatten PLUS\n                        (insert x12 (set xs1 \\<union> set xs2)) =\n                       flatten PLUS\n                        (insert x11\n                          (insert x12 (set xs1 \\<union> set xs2))))", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set xs1 \\<union> set xs2.\n                    \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> pnPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  flatten PLUS\n                                   (insert x12 (set xs1 \\<union> set xs2));\n     xs2 \\<noteq> []; sorted xs2; distinct xs2; \\<not> is_Zero x11;\n     \\<not> is_Plus x11; \\<not> is_Zero x12; \\<not> is_Plus x12;\n     \\<forall>x\\<in>set xs1 \\<union> set xs2.\n        \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n     x11 \\<in> set xs1\\<rbrakk>\n    \\<Longrightarrow> flatten PLUS (insert x12 (set xs1 \\<union> set xs2)) =\n                      flatten PLUS\n                       (insert x11 (insert x12 (set xs1 \\<union> set xs2)))\n 2. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set xs1 \\<union> set xs2.\n                    \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> pnPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  flatten PLUS\n                                   (insert x12 (set xs1 \\<union> set xs2));\n     xs2 \\<noteq> []; sorted xs2; distinct xs2; \\<not> is_Zero x11;\n     \\<not> is_Plus x11; \\<not> is_Zero x12; \\<not> is_Plus x12;\n     \\<forall>x\\<in>set xs1 \\<union> set xs2.\n        \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n     x11 \\<in> set xs2\\<rbrakk>\n    \\<Longrightarrow> flatten PLUS (insert x12 (set xs1 \\<union> set xs2)) =\n                      flatten PLUS\n                       (insert x11 (insert x12 (set xs1 \\<union> set xs2)))", "unfolding insert_commute[of x11]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set xs1 \\<union> set xs2.\n                    \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> pnPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  flatten PLUS\n                                   (insert x12 (set xs1 \\<union> set xs2));\n     xs2 \\<noteq> []; sorted xs2; distinct xs2; \\<not> is_Zero x11;\n     \\<not> is_Plus x11; \\<not> is_Zero x12; \\<not> is_Plus x12;\n     \\<forall>x\\<in>set xs1 \\<union> set xs2.\n        \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n     x11 \\<in> set xs1\\<rbrakk>\n    \\<Longrightarrow> flatten PLUS (insert x12 (set xs1 \\<union> set xs2)) =\n                      flatten PLUS\n                       (insert x12 (insert x11 (set xs1 \\<union> set xs2)))\n 2. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set xs1 \\<union> set xs2.\n                    \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> pnPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  flatten PLUS\n                                   (insert x12 (set xs1 \\<union> set xs2));\n     xs2 \\<noteq> []; sorted xs2; distinct xs2; \\<not> is_Zero x11;\n     \\<not> is_Plus x11; \\<not> is_Zero x12; \\<not> is_Plus x12;\n     \\<forall>x\\<in>set xs1 \\<union> set xs2.\n        \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n     x11 \\<in> set xs2\\<rbrakk>\n    \\<Longrightarrow> flatten PLUS (insert x12 (set xs1 \\<union> set xs2)) =\n                      flatten PLUS\n                       (insert x12 (insert x11 (set xs1 \\<union> set xs2)))", "apply (auto simp only: Un_insert_left[of x11, symmetric] insert_absorb) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set xs1 \\<union> set xs2.\n                    \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> pnPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  flatten PLUS\n                                   (insert x12 (set xs1 \\<union> set xs2));\n     xs2 \\<noteq> []; sorted xs2; distinct xs2; \\<not> is_Zero x11;\n     \\<not> is_Plus x11; \\<not> is_Zero x12; \\<not> is_Plus x12;\n     \\<forall>x\\<in>set xs1 \\<union> set xs2.\n        \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n     x11 \\<in> set xs2\\<rbrakk>\n    \\<Longrightarrow> flatten PLUS (insert x12 (set xs1 \\<union> set xs2)) =\n                      flatten PLUS\n                       (insert x12 (insert x11 (set xs1 \\<union> set xs2)))", "apply (auto simp only: Un_insert_right[of _ x11, symmetric] insert_absorb) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  pnPlus (PLUS (x11 # x12 # xs1)) (PLUS xs2) =\n  flatten PLUS (set ((x11 # x12 # xs1) @ xs2))\n\ngoal (1 subgoal):\n 1. \\<And>xs2.\n       \\<lbrakk>[] \\<noteq> []; xs2 \\<noteq> [];\n        \\<forall>x\\<in>set ([] @ xs2).\n           \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n        sorted xs2; distinct xs2\\<rbrakk>\n       \\<Longrightarrow> pnPlus (PLUS []) (PLUS xs2) =\n                         flatten PLUS (set ([] @ xs2))", "qed simp"], ["", "lemma pnPlus_flatten_PLUS:\n  \"\\<lbrakk>X1 \\<noteq> {}; X2 \\<noteq> {}; finite X1; finite X2; \\<forall>x \\<in> X1 \\<union> X2.  \\<not>is_Zero x \\<and> \\<not>is_Plus x\\<rbrakk>\\<Longrightarrow>\n  pnPlus (flatten PLUS X1) (flatten PLUS X2) = flatten PLUS (X1 \\<union> X2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X1 \\<noteq> {}; X2 \\<noteq> {}; finite X1; finite X2;\n     \\<forall>x\\<in>X1 \\<union> X2.\n        \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n    \\<Longrightarrow> pnPlus (flatten PLUS X1) (flatten PLUS X2) =\n                      flatten PLUS (X1 \\<union> X2)", "by (rule trans[OF pnPlus_PLUS]) auto"], ["", "lemma pnPlus_pnorm: \"pnPlus (pnorm r) (pnorm s) = pnorm (Plus r s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pnPlus (pnorm r) (pnorm s) = pnorm (Plus r s)", "by (cases \"pset r = {} \\<or> pset s = {}\")\n    (auto simp: pnorm_def pset_pnPlus pset_pnorm_alt intro: pnPlus_flatten_PLUS)"], ["", "lemma pnTimes_not_Zero_or_Plus[simp]: \"\\<lbrakk>\\<not> is_Zero x; \\<not> is_Plus x\\<rbrakk> \\<Longrightarrow> pnTimes x r = Times x r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> is_Zero x; \\<not> is_Plus x\\<rbrakk>\n    \\<Longrightarrow> pnTimes x r = Times x r", "by (cases x) auto"], ["", "lemma pnTimes_PLUS:\n  \"\\<lbrakk>xs \\<noteq> []; \\<forall>x \\<in> set xs. \\<not>is_Zero x \\<and> \\<not>is_Plus x\\<rbrakk>\\<Longrightarrow>\n  pnTimes (PLUS xs) r = flatten PLUS (Timess (set xs) r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> [];\n     \\<forall>x\\<in>set xs.\n        \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n    \\<Longrightarrow> pnTimes (PLUS xs) r = flatten PLUS (Timess (set xs) r)", "proof (induct xs arbitrary: r rule: list_singleton_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>[] \\<noteq> [];\n        \\<forall>x\\<in>set [].\n           \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n       \\<Longrightarrow> pnTimes (PLUS []) r =\n                         flatten PLUS (Timess (set []) r)\n 2. \\<And>x r.\n       \\<lbrakk>[x] \\<noteq> [];\n        \\<forall>x\\<in>set [x].\n           \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n       \\<Longrightarrow> pnTimes (PLUS [x]) r =\n                         flatten PLUS (Timess (set [x]) r)\n 3. \\<And>x y xs r.\n       \\<lbrakk>\\<And>r.\n                   \\<lbrakk>y # xs \\<noteq> [];\n                    \\<forall>x\\<in>set (y # xs).\n                       \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n                   \\<Longrightarrow> pnTimes (PLUS (y # xs)) r =\n                                     flatten PLUS (Timess (set (y # xs)) r);\n        x # y # xs \\<noteq> [];\n        \\<forall>x\\<in>set (x # y # xs).\n           \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n       \\<Longrightarrow> pnTimes (PLUS (x # y # xs)) r =\n                         flatten PLUS (Timess (set (x # y # xs)) r)", "case (cons x y xs)"], ["proof (state)\nthis:\n  \\<lbrakk>y # xs \\<noteq> [];\n   \\<forall>x\\<in>set (y # xs).\n      \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n  \\<Longrightarrow> pnTimes (PLUS (y # xs)) ?r =\n                    flatten PLUS (Timess (set (y # xs)) ?r)\n  x # y # xs \\<noteq> []\n  \\<forall>x\\<in>set (x # y # xs). \\<not> is_Zero x \\<and> \\<not> is_Plus x\n\ngoal (3 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>[] \\<noteq> [];\n        \\<forall>x\\<in>set [].\n           \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n       \\<Longrightarrow> pnTimes (PLUS []) r =\n                         flatten PLUS (Timess (set []) r)\n 2. \\<And>x r.\n       \\<lbrakk>[x] \\<noteq> [];\n        \\<forall>x\\<in>set [x].\n           \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n       \\<Longrightarrow> pnTimes (PLUS [x]) r =\n                         flatten PLUS (Timess (set [x]) r)\n 3. \\<And>x y xs r.\n       \\<lbrakk>\\<And>r.\n                   \\<lbrakk>y # xs \\<noteq> [];\n                    \\<forall>x\\<in>set (y # xs).\n                       \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n                   \\<Longrightarrow> pnTimes (PLUS (y # xs)) r =\n                                     flatten PLUS (Timess (set (y # xs)) r);\n        x # y # xs \\<noteq> [];\n        \\<forall>x\\<in>set (x # y # xs).\n           \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n       \\<Longrightarrow> pnTimes (PLUS (x # y # xs)) r =\n                         flatten PLUS (Timess (set (x # y # xs)) r)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>y # xs \\<noteq> [];\n   \\<forall>x\\<in>set (y # xs).\n      \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n  \\<Longrightarrow> pnTimes (PLUS (y # xs)) ?r =\n                    flatten PLUS (Timess (set (y # xs)) ?r)\n  x # y # xs \\<noteq> []\n  \\<forall>x\\<in>set (x # y # xs). \\<not> is_Zero x \\<and> \\<not> is_Plus x", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>y # xs \\<noteq> [];\n   \\<forall>x\\<in>set (y # xs).\n      \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n  \\<Longrightarrow> pnTimes (PLUS (y # xs)) ?r =\n                    flatten PLUS (Timess (set (y # xs)) ?r)\n  x # y # xs \\<noteq> []\n  \\<forall>x\\<in>set (x # y # xs). \\<not> is_Zero x \\<and> \\<not> is_Plus x\n\ngoal (1 subgoal):\n 1. pnTimes (PLUS (x # y # xs)) r =\n    flatten PLUS (Timess (set (x # y # xs)) r)", "unfolding rexp_of_list.simps pnTimes.simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>y # xs \\<noteq> [];\n   \\<forall>x\\<in>set (y # xs).\n      \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n  \\<Longrightarrow> pnTimes (PLUS (y # xs)) ?r =\n                    flatten PLUS (Timess (set (y # xs)) ?r)\n  x # y # xs \\<noteq> []\n  \\<forall>x\\<in>set (x # y # xs). \\<not> is_Zero x \\<and> \\<not> is_Plus x\n\ngoal (1 subgoal):\n 1. pnPlus (pnTimes x r) (pnTimes (PLUS (y # xs)) r) =\n    flatten PLUS (Timess (set (x # y # xs)) r)", "apply (subst pnTimes_not_Zero_or_Plus)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>r.\n                \\<lbrakk>y # xs \\<noteq> [];\n                 \\<forall>x\\<in>set (y # xs).\n                    \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n                \\<Longrightarrow> pnTimes (PLUS (y # xs)) r =\n                                  flatten PLUS (Timess (set (y # xs)) r);\n     x # y # xs \\<noteq> [];\n     \\<forall>x\\<in>set (x # y # xs).\n        \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n    \\<Longrightarrow> \\<not> is_Zero x\n 2. \\<lbrakk>\\<And>r.\n                \\<lbrakk>y # xs \\<noteq> [];\n                 \\<forall>x\\<in>set (y # xs).\n                    \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n                \\<Longrightarrow> pnTimes (PLUS (y # xs)) r =\n                                  flatten PLUS (Timess (set (y # xs)) r);\n     x # y # xs \\<noteq> [];\n     \\<forall>x\\<in>set (x # y # xs).\n        \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n    \\<Longrightarrow> \\<not> is_Plus x\n 3. \\<lbrakk>\\<And>r.\n                \\<lbrakk>y # xs \\<noteq> [];\n                 \\<forall>x\\<in>set (y # xs).\n                    \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n                \\<Longrightarrow> pnTimes (PLUS (y # xs)) r =\n                                  flatten PLUS (Timess (set (y # xs)) r);\n     x # y # xs \\<noteq> [];\n     \\<forall>x\\<in>set (x # y # xs).\n        \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n    \\<Longrightarrow> pnPlus (Times x r) (pnTimes (PLUS (y # xs)) r) =\n                      flatten PLUS (Timess (set (x # y # xs)) r)", "apply (simp_all add: sorted_insort set_insort_key del: sorted_list_of_set_insert)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>r.\n                pnTimes (PLUS (y # xs)) r =\n                flatten PLUS (insert (Times y r) (Timess (set xs) r));\n     \\<not> is_Zero x \\<and>\n     \\<not> is_Plus x \\<and>\n     \\<not> is_Zero y \\<and>\n     \\<not> is_Plus y \\<and>\n     (\\<forall>x\\<in>set xs.\n         \\<not> is_Zero x \\<and> \\<not> is_Plus x)\\<rbrakk>\n    \\<Longrightarrow> pnPlus (Times x r)\n                       (flatten PLUS\n                         (insert (Times y r) (Timess (set xs) r))) =\n                      flatten PLUS\n                       (insert (Times y r)\n                         (insert (Times x r) (Timess (set xs) r)))", "apply (subst pnPlus_singleton_PLUS)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<And>r.\n                pnTimes (PLUS (y # xs)) r =\n                flatten PLUS (insert (Times y r) (Timess (set xs) r));\n     \\<not> is_Zero x \\<and>\n     \\<not> is_Plus x \\<and>\n     \\<not> is_Zero y \\<and>\n     \\<not> is_Plus y \\<and>\n     (\\<forall>x\\<in>set xs.\n         \\<not> is_Zero x \\<and> \\<not> is_Plus x)\\<rbrakk>\n    \\<Longrightarrow> flatten (\\<noteq>)\n                       (insert (Times y r) (Timess (set xs) r)) []\n 2. \\<lbrakk>\\<And>r.\n                pnTimes (PLUS (y # xs)) r =\n                flatten PLUS (insert (Times y r) (Timess (set xs) r));\n     \\<not> is_Zero x \\<and>\n     \\<not> is_Plus x \\<and>\n     \\<not> is_Zero y \\<and>\n     \\<not> is_Plus y \\<and>\n     (\\<forall>x\\<in>set xs.\n         \\<not> is_Zero x \\<and> \\<not> is_Plus x)\\<rbrakk>\n    \\<Longrightarrow> flatten sorted\n                       (insert (Times y r) (Timess (set xs) r))\n 3. \\<lbrakk>\\<And>r.\n                pnTimes (PLUS (y # xs)) r =\n                flatten PLUS (insert (Times y r) (Timess (set xs) r));\n     \\<not> is_Zero x \\<and>\n     \\<not> is_Plus x \\<and>\n     \\<not> is_Zero y \\<and>\n     \\<not> is_Plus y \\<and>\n     (\\<forall>x\\<in>set xs.\n         \\<not> is_Zero x \\<and> \\<not> is_Plus x)\\<rbrakk>\n    \\<Longrightarrow> flatten distinct\n                       (insert (Times y r) (Timess (set xs) r))\n 4. \\<lbrakk>\\<And>r.\n                pnTimes (PLUS (y # xs)) r =\n                flatten PLUS (insert (Times y r) (Timess (set xs) r));\n     \\<not> is_Zero x \\<and>\n     \\<not> is_Plus x \\<and>\n     \\<not> is_Zero y \\<and>\n     \\<not> is_Plus y \\<and>\n     (\\<forall>x\\<in>set xs.\n         \\<not> is_Zero x \\<and> \\<not> is_Plus x)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>{Times x r} \\<union>\n                                     flatten set\n(insert (Times y r) (Timess (set xs) r)).\n                         \\<not> is_Zero x \\<and> \\<not> is_Plus x\n 5. \\<lbrakk>\\<And>r.\n                pnTimes (PLUS (y # xs)) r =\n                flatten PLUS (insert (Times y r) (Timess (set xs) r));\n     \\<not> is_Zero x \\<and>\n     \\<not> is_Plus x \\<and>\n     \\<not> is_Zero y \\<and>\n     \\<not> is_Plus y \\<and>\n     (\\<forall>x\\<in>set xs.\n         \\<not> is_Zero x \\<and> \\<not> is_Plus x)\\<rbrakk>\n    \\<Longrightarrow> (if Times x r\n                          \\<in> flatten set\n                                 (insert (Times y r) (Timess (set xs) r))\n                       then flatten PLUS\n                             (insert (Times y r) (Timess (set xs) r))\n                       else PLUS\n                             (flatten (insort (Times x r))\n                               (insert (Times y r) (Timess (set xs) r)))) =\n                      flatten PLUS\n                       (insert (Times y r)\n                         (insert (Times x r) (Timess (set xs) r)))", "apply (simp_all add: sorted_insort set_insort_key del: sorted_list_of_set_insert)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>r.\n                pnTimes (PLUS (y # xs)) r =\n                flatten PLUS (insert (Times y r) (Timess (set xs) r));\n     \\<not> is_Zero x \\<and>\n     \\<not> is_Plus x \\<and>\n     \\<not> is_Zero y \\<and>\n     \\<not> is_Plus y \\<and>\n     (\\<forall>x\\<in>set xs.\n         \\<not> is_Zero x \\<and> \\<not> is_Plus x)\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> set xs \\<longrightarrow>\n                       flatten PLUS\n                        (insert (Times y r) (Timess (set xs) r)) =\n                       flatten PLUS\n                        (insert (Times y r)\n                          (insert (Times x r) (Timess (set xs) r)))) \\<and>\n                      (x \\<noteq> y \\<and>\n                       x \\<notin> set xs \\<longrightarrow>\n                       PLUS\n                        (flatten (insort (Times x r))\n                          (insert (Times y r) (Timess (set xs) r))) =\n                       flatten PLUS\n                        (insert (Times y r)\n                          (insert (Times x r) (Timess (set xs) r))))", "unfolding insert_commute[of \"Times y r\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>r.\n                pnTimes (PLUS (y # xs)) r =\n                flatten PLUS (insert (Times y r) (Timess (set xs) r));\n     \\<not> is_Zero x \\<and>\n     \\<not> is_Plus x \\<and>\n     \\<not> is_Zero y \\<and>\n     \\<not> is_Plus y \\<and>\n     (\\<forall>x\\<in>set xs.\n         \\<not> is_Zero x \\<and> \\<not> is_Plus x)\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> set xs \\<longrightarrow>\n                       flatten PLUS\n                        (insert (Times y r) (Timess (set xs) r)) =\n                       flatten PLUS\n                        (insert (Times x r)\n                          (insert (Times y r) (Timess (set xs) r)))) \\<and>\n                      (x \\<noteq> y \\<and>\n                       x \\<notin> set xs \\<longrightarrow>\n                       PLUS\n                        (flatten (insort (Times x r))\n                          (insert (Times y r) (Timess (set xs) r))) =\n                       flatten PLUS\n                        (insert (Times x r)\n                          (insert (Times y r) (Timess (set xs) r))))", "apply (simp del: sorted_list_of_set_insert)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>r.\n                pnTimes (PLUS (y # xs)) r =\n                flatten PLUS (insert (Times y r) (Timess (set xs) r));\n     \\<not> is_Zero x \\<and>\n     \\<not> is_Plus x \\<and>\n     \\<not> is_Zero y \\<and>\n     \\<not> is_Plus y \\<and>\n     (\\<forall>x\\<in>set xs.\n         \\<not> is_Zero x \\<and> \\<not> is_Plus x)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set xs \\<longrightarrow>\n                      flatten PLUS\n                       (insert (Times y r) (Timess (set xs) r)) =\n                      flatten PLUS\n                       (insert (Times x r)\n                         (insert (Times y r) (Timess (set xs) r)))", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>r.\n                pnTimes (PLUS (y # xs)) r =\n                flatten PLUS (insert (Times y r) (Timess (set xs) r));\n     \\<not> is_Zero x; \\<not> is_Plus x; \\<not> is_Zero y; \\<not> is_Plus y;\n     \\<forall>x\\<in>set xs. \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n     x \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> flatten PLUS\n                       (insert (Times y r) (Timess (set xs) r)) =\n                      flatten PLUS\n                       (insert (Times x r)\n                         (insert (Times y r) (Timess (set xs) r)))", "apply (subst insert_absorb[of \"Times x r\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>r.\n                pnTimes (PLUS (y # xs)) r =\n                flatten PLUS (insert (Times y r) (Timess (set xs) r));\n     \\<not> is_Zero x; \\<not> is_Plus x; \\<not> is_Zero y; \\<not> is_Plus y;\n     \\<forall>x\\<in>set xs. \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n     x \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> Times x r \\<in> insert (Times y r) (Timess (set xs) r)\n 2. \\<lbrakk>\\<And>r.\n                pnTimes (PLUS (y # xs)) r =\n                flatten PLUS (insert (Times y r) (Timess (set xs) r));\n     \\<not> is_Zero x; \\<not> is_Plus x; \\<not> is_Zero y; \\<not> is_Plus y;\n     \\<forall>x\\<in>set xs. \\<not> is_Zero x \\<and> \\<not> is_Plus x;\n     x \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> flatten PLUS\n                       (insert (Times y r) (Timess (set xs) r)) =\n                      flatten PLUS (insert (Times y r) (Timess (set xs) r))", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  pnTimes (PLUS (x # y # xs)) r = flatten PLUS (Timess (set (x # y # xs)) r)\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>[] \\<noteq> [];\n        \\<forall>x\\<in>set [].\n           \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n       \\<Longrightarrow> pnTimes (PLUS []) r =\n                         flatten PLUS (Timess (set []) r)\n 2. \\<And>x r.\n       \\<lbrakk>[x] \\<noteq> [];\n        \\<forall>x\\<in>set [x].\n           \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n       \\<Longrightarrow> pnTimes (PLUS [x]) r =\n                         flatten PLUS (Timess (set [x]) r)", "qed auto"], ["", "lemma pnTimes_flatten_PLUS:\n  \"\\<lbrakk>X1 \\<noteq> {}; finite X1; \\<forall>x \\<in> X1. \\<not>is_Zero x \\<and> \\<not>is_Plus x\\<rbrakk>\\<Longrightarrow>\n  pnTimes (flatten PLUS X1) r = flatten PLUS (Timess X1 r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X1 \\<noteq> {}; finite X1;\n     \\<forall>x\\<in>X1. \\<not> is_Zero x \\<and> \\<not> is_Plus x\\<rbrakk>\n    \\<Longrightarrow> pnTimes (flatten PLUS X1) r =\n                      flatten PLUS (Timess X1 r)", "by (rule trans[OF pnTimes_PLUS]) auto"], ["", "lemma pnTimes_pnorm: \"pnTimes (pnorm r1) r2 = pnorm (Times r1 r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pnTimes (pnorm r1) r2 = pnorm (Times r1 r2)", "by (cases \"pset r1 = {}\")\n    (auto simp: pnorm_def pset_pnTimes pset_pnorm_alt intro: pnTimes_flatten_PLUS)"], ["", "lemma pnorm_alt[symmetric]: \"pnorm_alt r = pnorm r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pnorm_alt r = pnorm r", "by (induct r) (simp_all only: pnorm_alt.simps pnPlus_pnorm pnTimes_pnorm, auto simp: pnorm_def)"], ["", "lemma insort_eq_Cons: \"\\<lbrakk>\\<forall>a \\<in> set xs. b < a; sorted xs\\<rbrakk> \\<Longrightarrow> insort b xs = b # xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a\\<in>set xs. b < a; sorted xs\\<rbrakk>\n    \\<Longrightarrow> insort b xs = b # xs", "by (cases xs) auto"], ["", "lemma pderiv_PLUS: \"pderiv a (PLUS (x # xs)) = pderiv a x \\<union> pderiv a (PLUS xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pderiv a (PLUS (x # xs)) = pderiv a x \\<union> pderiv a (PLUS xs)", "by (cases xs) auto"], ["", "lemma pderiv_set_flatten_PLUS:\n   \"finite X \\<Longrightarrow> pderiv (a :: 'a :: linorder) (flatten PLUS X) = pderiv_set a X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite X \\<Longrightarrow> pderiv a (flatten PLUS X) = pderiv_set a X", "proof (induction X rule: finite_linorder_min_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. pderiv a (flatten PLUS {}) = pderiv_set a {}\n 2. \\<And>b A.\n       \\<lbrakk>finite A; \\<forall>a\\<in>A. b < a;\n        pderiv a (flatten PLUS A) = pderiv_set a A\\<rbrakk>\n       \\<Longrightarrow> pderiv a (flatten PLUS (insert b A)) =\n                         pderiv_set a (insert b A)", "case (insert b X)"], ["proof (state)\nthis:\n  finite X\n  \\<forall>a\\<in>X. b < a\n  pderiv a (flatten PLUS X) = pderiv_set a X\n\ngoal (2 subgoals):\n 1. pderiv a (flatten PLUS {}) = pderiv_set a {}\n 2. \\<And>b A.\n       \\<lbrakk>finite A; \\<forall>a\\<in>A. b < a;\n        pderiv a (flatten PLUS A) = pderiv_set a A\\<rbrakk>\n       \\<Longrightarrow> pderiv a (flatten PLUS (insert b A)) =\n                         pderiv_set a (insert b A)", "then"], ["proof (chain)\npicking this:\n  finite X\n  \\<forall>a\\<in>X. b < a\n  pderiv a (flatten PLUS X) = pderiv_set a X", "have \"b \\<notin> X\""], ["proof (prove)\nusing this:\n  finite X\n  \\<forall>a\\<in>X. b < a\n  pderiv a (flatten PLUS X) = pderiv_set a X\n\ngoal (1 subgoal):\n 1. b \\<notin> X", "by auto"], ["proof (state)\nthis:\n  b \\<notin> X\n\ngoal (2 subgoals):\n 1. pderiv a (flatten PLUS {}) = pderiv_set a {}\n 2. \\<And>b A.\n       \\<lbrakk>finite A; \\<forall>a\\<in>A. b < a;\n        pderiv a (flatten PLUS A) = pderiv_set a A\\<rbrakk>\n       \\<Longrightarrow> pderiv a (flatten PLUS (insert b A)) =\n                         pderiv_set a (insert b A)", "then"], ["proof (chain)\npicking this:\n  b \\<notin> X", "have \"pderiv a (flatten PLUS (insert b X)) = pderiv a b \\<union> pderiv a (flatten PLUS X)\""], ["proof (prove)\nusing this:\n  b \\<notin> X\n\ngoal (1 subgoal):\n 1. pderiv a (flatten PLUS (insert b X)) =\n    pderiv a b \\<union> pderiv a (flatten PLUS X)", "by (simp add: pderiv_PLUS insort_eq_Cons insert.hyps)"], ["proof (state)\nthis:\n  pderiv a (flatten PLUS (insert b X)) =\n  pderiv a b \\<union> pderiv a (flatten PLUS X)\n\ngoal (2 subgoals):\n 1. pderiv a (flatten PLUS {}) = pderiv_set a {}\n 2. \\<And>b A.\n       \\<lbrakk>finite A; \\<forall>a\\<in>A. b < a;\n        pderiv a (flatten PLUS A) = pderiv_set a A\\<rbrakk>\n       \\<Longrightarrow> pderiv a (flatten PLUS (insert b A)) =\n                         pderiv_set a (insert b A)", "also"], ["proof (state)\nthis:\n  pderiv a (flatten PLUS (insert b X)) =\n  pderiv a b \\<union> pderiv a (flatten PLUS X)\n\ngoal (2 subgoals):\n 1. pderiv a (flatten PLUS {}) = pderiv_set a {}\n 2. \\<And>b A.\n       \\<lbrakk>finite A; \\<forall>a\\<in>A. b < a;\n        pderiv a (flatten PLUS A) = pderiv_set a A\\<rbrakk>\n       \\<Longrightarrow> pderiv a (flatten PLUS (insert b A)) =\n                         pderiv_set a (insert b A)", "from insert.IH"], ["proof (chain)\npicking this:\n  pderiv a (flatten PLUS X) = pderiv_set a X", "have \"\\<dots> = pderiv a b \\<union> pderiv_set a X\""], ["proof (prove)\nusing this:\n  pderiv a (flatten PLUS X) = pderiv_set a X\n\ngoal (1 subgoal):\n 1. pderiv a b \\<union> pderiv a (flatten PLUS X) =\n    pderiv a b \\<union> pderiv_set a X", "by simp"], ["proof (state)\nthis:\n  pderiv a b \\<union> pderiv a (flatten PLUS X) =\n  pderiv a b \\<union> pderiv_set a X\n\ngoal (2 subgoals):\n 1. pderiv a (flatten PLUS {}) = pderiv_set a {}\n 2. \\<And>b A.\n       \\<lbrakk>finite A; \\<forall>a\\<in>A. b < a;\n        pderiv a (flatten PLUS A) = pderiv_set a A\\<rbrakk>\n       \\<Longrightarrow> pderiv a (flatten PLUS (insert b A)) =\n                         pderiv_set a (insert b A)", "finally"], ["proof (chain)\npicking this:\n  pderiv a (flatten PLUS (insert b X)) = pderiv a b \\<union> pderiv_set a X", "show ?case"], ["proof (prove)\nusing this:\n  pderiv a (flatten PLUS (insert b X)) = pderiv a b \\<union> pderiv_set a X\n\ngoal (1 subgoal):\n 1. pderiv a (flatten PLUS (insert b X)) = pderiv_set a (insert b X)", "by simp"], ["proof (state)\nthis:\n  pderiv a (flatten PLUS (insert b X)) = pderiv_set a (insert b X)\n\ngoal (1 subgoal):\n 1. pderiv a (flatten PLUS {}) = pderiv_set a {}", "qed simp"], ["", "lemma fold_pderiv_set_flatten_PLUS:\n  \"\\<lbrakk>w \\<noteq> []; finite X\\<rbrakk> \\<Longrightarrow> fold pderiv_set w {flatten PLUS X} = fold pderiv_set w X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<noteq> []; finite X\\<rbrakk>\n    \\<Longrightarrow> fold pderiv_set w {flatten PLUS X} =\n                      fold pderiv_set w X", "by (induct w arbitrary: X) (simp_all add: pderiv_set_flatten_PLUS)"], ["", "lemma fold_pnorm_deriv:\n  \"fold (\\<lambda>a r. pnorm (deriv a r)) w s = flatten PLUS (fold pderiv_set w {s})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>a r. pnorm (deriv a r)) w s =\n    flatten PLUS (fold pderiv_set w {s})", "proof (induction w arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       fold (\\<lambda>a r. pnorm (deriv a r)) [] s =\n       flatten PLUS (fold pderiv_set [] {s})\n 2. \\<And>a w s.\n       (\\<And>s.\n           fold (\\<lambda>a r. pnorm (deriv a r)) w s =\n           flatten PLUS (fold pderiv_set w {s})) \\<Longrightarrow>\n       fold (\\<lambda>a r. pnorm (deriv a r)) (a # w) s =\n       flatten PLUS (fold pderiv_set (a # w) {s})", "case (Cons x w)"], ["proof (state)\nthis:\n  fold (\\<lambda>a r. pnorm (deriv a r)) w ?s =\n  flatten PLUS (fold pderiv_set w {?s})\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       fold (\\<lambda>a r. pnorm (deriv a r)) [] s =\n       flatten PLUS (fold pderiv_set [] {s})\n 2. \\<And>a w s.\n       (\\<And>s.\n           fold (\\<lambda>a r. pnorm (deriv a r)) w s =\n           flatten PLUS (fold pderiv_set w {s})) \\<Longrightarrow>\n       fold (\\<lambda>a r. pnorm (deriv a r)) (a # w) s =\n       flatten PLUS (fold pderiv_set (a # w) {s})", "then"], ["proof (chain)\npicking this:\n  fold (\\<lambda>a r. pnorm (deriv a r)) w ?s =\n  flatten PLUS (fold pderiv_set w {?s})", "show ?case"], ["proof (prove)\nusing this:\n  fold (\\<lambda>a r. pnorm (deriv a r)) w ?s =\n  flatten PLUS (fold pderiv_set w {?s})\n\ngoal (1 subgoal):\n 1. fold (\\<lambda>a r. pnorm (deriv a r)) (x # w) s =\n    flatten PLUS (fold pderiv_set (x # w) {s})", "proof (cases \"w = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>s.\n                fold (\\<lambda>a r. pnorm (deriv a r)) w s =\n                flatten PLUS (fold pderiv_set w {s});\n     w = []\\<rbrakk>\n    \\<Longrightarrow> fold (\\<lambda>a r. pnorm (deriv a r)) (x # w) s =\n                      flatten PLUS (fold pderiv_set (x # w) {s})\n 2. \\<lbrakk>\\<And>s.\n                fold (\\<lambda>a r. pnorm (deriv a r)) w s =\n                flatten PLUS (fold pderiv_set w {s});\n     w \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> fold (\\<lambda>a r. pnorm (deriv a r)) (x # w) s =\n                      flatten PLUS (fold pderiv_set (x # w) {s})", "case False"], ["proof (state)\nthis:\n  w \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>s.\n                fold (\\<lambda>a r. pnorm (deriv a r)) w s =\n                flatten PLUS (fold pderiv_set w {s});\n     w = []\\<rbrakk>\n    \\<Longrightarrow> fold (\\<lambda>a r. pnorm (deriv a r)) (x # w) s =\n                      flatten PLUS (fold pderiv_set (x # w) {s})\n 2. \\<lbrakk>\\<And>s.\n                fold (\\<lambda>a r. pnorm (deriv a r)) w s =\n                flatten PLUS (fold pderiv_set w {s});\n     w \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> fold (\\<lambda>a r. pnorm (deriv a r)) (x # w) s =\n                      flatten PLUS (fold pderiv_set (x # w) {s})", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>a r. pnorm (deriv a r)) (x # w) s =\n    flatten PLUS (fold pderiv_set (x # w) {s})", "using fold_pderiv_set_flatten_PLUS[OF False] Cons.IH"], ["proof (prove)\nusing this:\n  finite ?X \\<Longrightarrow>\n  fold pderiv_set w {flatten PLUS ?X} = fold pderiv_set w ?X\n  fold (\\<lambda>a r. pnorm (deriv a r)) w ?s =\n  flatten PLUS (fold pderiv_set w {?s})\n\ngoal (1 subgoal):\n 1. fold (\\<lambda>a r. pnorm (deriv a r)) (x # w) s =\n    flatten PLUS (fold pderiv_set (x # w) {s})", "by (auto simp: pnorm_def pset_deriv)"], ["proof (state)\nthis:\n  fold (\\<lambda>a r. pnorm (deriv a r)) (x # w) s =\n  flatten PLUS (fold pderiv_set (x # w) {s})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s.\n                fold (\\<lambda>a r. pnorm (deriv a r)) w s =\n                flatten PLUS (fold pderiv_set w {s});\n     w = []\\<rbrakk>\n    \\<Longrightarrow> fold (\\<lambda>a r. pnorm (deriv a r)) (x # w) s =\n                      flatten PLUS (fold pderiv_set (x # w) {s})", "qed (simp add: pnorm_def pset_deriv)"], ["proof (state)\nthis:\n  fold (\\<lambda>a r. pnorm (deriv a r)) (x # w) s =\n  flatten PLUS (fold pderiv_set (x # w) {s})\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       fold (\\<lambda>a r. pnorm (deriv a r)) [] s =\n       flatten PLUS (fold pderiv_set [] {s})", "qed simp"], ["", "primrec\n  pnderiv :: \"'a :: linorder \\<Rightarrow> 'a rexp \\<Rightarrow> 'a rexp\"\nwhere\n  \"pnderiv c (Zero) = Zero\"\n| \"pnderiv c (One) = Zero\"\n| \"pnderiv c (Atom c') = (if c = c' then One else Zero)\"\n| \"pnderiv c (Plus r1 r2) = pnPlus (pnderiv c r1) (pnderiv c r2)\"\n| \"pnderiv c (Times r1 r2) = \n    (if nullable r1 then pnPlus (pnTimes (pnderiv c r1) r2) (pnderiv c r2) else pnTimes (pnderiv c r1) r2)\"\n| \"pnderiv c (Star r) = pnTimes (pnderiv c r) (Star r)\""], ["", "lemma pnderiv_alt[code]: \"pnderiv a r = pnorm (deriv a r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pnderiv a r = pnorm (deriv a r)", "by (induct r) (auto simp: pnorm_alt)"], ["", "lemma pnderiv_pderiv: \"pnderiv a r = flatten PLUS (pderiv a r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pnderiv a r = flatten PLUS (pderiv a r)", "unfolding pnderiv_alt pnorm_def o_apply pset_deriv"], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten PLUS (pderiv a r) = flatten PLUS (pderiv a r)", ".."], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}