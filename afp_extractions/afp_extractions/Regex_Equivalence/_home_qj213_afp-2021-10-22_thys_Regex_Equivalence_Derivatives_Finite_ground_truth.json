{"file_name": "/home/qj213/afp-2021-10-22/thys/Regex_Equivalence/Derivatives_Finite.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Regex_Equivalence", "problem_names": ["lemma list_singleton_induct [case_names nil single cons]:\nassumes \"P []\" and \"\\<And>x. P [x]\" and \"\\<And>x y xs. P (y # xs) \\<Longrightarrow> P (x # (y # xs))\"\nshows \"P xs\"", "lemma toplevel_summands_nonempty[simp]:\n  \"toplevel_summands r \\<noteq> {}\"", "lemma toplevel_summands_finite[simp]:\n  \"finite (toplevel_summands r)\"", "lemma Plus_toplevel_summands: \"Plus r s \\<in> toplevel_summands t \\<Longrightarrow> False\"", "lemma toplevel_summands_not_Plus[simp]:\n  \"(\\<forall>r s. x \\<noteq> Plus r s) \\<Longrightarrow> toplevel_summands x = {x}\"", "lemma toplevel_summands_PLUS_strong:\n  \"\\<lbrakk>xs \\<noteq> []; list_all (\\<lambda>x. \\<not>(\\<exists>r s. x = Plus r s)) xs\\<rbrakk> \\<Longrightarrow> toplevel_summands (PLUS xs) = set xs\"", "lemma toplevel_summands_flatten:\n  \"\\<lbrakk>X \\<noteq> {}; finite X; \\<forall>x \\<in> X. \\<not>(\\<exists>r s. x = Plus r s)\\<rbrakk> \\<Longrightarrow> toplevel_summands (flatten PLUS X) = X\"", "lemma ACI_norm_Plus: \"\\<guillemotleft>r\\<guillemotright> = Plus s t \\<Longrightarrow> \\<exists>s t. r = Plus s t\"", "lemma toplevel_summands_flatten_ACI_norm_image:\n  \"toplevel_summands (flatten PLUS (ACI_norm ` toplevel_summands r)) = ACI_norm ` toplevel_summands r\"", "lemma toplevel_summands_flatten_ACI_norm_image_Union:\n  \"toplevel_summands (flatten PLUS (ACI_norm ` toplevel_summands r \\<union> ACI_norm ` toplevel_summands s)) =\n    ACI_norm ` toplevel_summands r \\<union> ACI_norm ` toplevel_summands s\"", "lemma toplevel_summands_ACI_norm:\n  \"toplevel_summands \\<guillemotleft>r\\<guillemotright> = ACI_norm ` toplevel_summands r\"", "lemma ACI_norm_flatten:\n  \"\\<guillemotleft>r\\<guillemotright> = flatten PLUS (ACI_norm ` toplevel_summands r)\"", "theorem ACI_norm_idem[simp]: \"\\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> = \\<guillemotleft>r\\<guillemotright>\"", "lemma atoms_toplevel_summands:\n  \"atoms s = (\\<Union>r\\<in>toplevel_summands s. atoms r)\"", "lemma wf_PLUS: \"atoms (PLUS xs) \\<subseteq> \\<Sigma> \\<longleftrightarrow> (\\<forall>r \\<in> set xs. atoms r \\<subseteq> \\<Sigma>)\"", "lemma atoms_PLUS: \"atoms (PLUS xs) = (\\<Union>r \\<in> set xs. atoms r)\"", "lemma atoms_flatten_PLUS:\n  \"finite X \\<Longrightarrow> atoms (flatten PLUS X) = (\\<Union>r \\<in> X. atoms r)\"", "theorem atoms_ACI_norm: \"atoms \\<guillemotleft>r\\<guillemotright> = atoms r\"", "lemma toplevel_summands_lang: \"r \\<in> toplevel_summands s \\<Longrightarrow> lang r \\<subseteq> lang s\"", "lemma toplevel_summands_lang_UN:\n  \"lang s = (\\<Union>r\\<in>toplevel_summands s. lang r)\"", "lemma toplevel_summands_in_lang:\n  \"w \\<in> lang s = (\\<exists>r\\<in>toplevel_summands s. w \\<in> lang r)\"", "lemma lang_PLUS: \"lang (PLUS xs) = (\\<Union>r \\<in> set xs. lang r)\"", "lemma lang_PLUS_map[simp]:\n  \"lang (PLUS (map f xs)) = (\\<Union>a\\<in>set xs. lang (f a))\"", "lemma lang_flatten_PLUS[simp]:\n  \"finite X \\<Longrightarrow> lang (flatten PLUS X) = (\\<Union>r \\<in> X. lang r)\"", "theorem lang_ACI_norm[simp]: \"lang \\<guillemotleft>r\\<guillemotright> = lang r\"", "lemma toplevel_summands_deriv:\n  \"toplevel_summands (deriv as r) = (\\<Union>s\\<in>toplevel_summands r. toplevel_summands (deriv as s))\"", "lemma derivs_Zero[simp]: \"derivs xs Zero = Zero\"", "lemma derivs_One: \"derivs xs One \\<in> {Zero, One}\"", "lemma derivs_Atom: \"derivs xs (Atom as) \\<in> {Zero, One, Atom as}\"", "lemma derivs_Plus: \"derivs xs (Plus r s) = Plus (derivs xs r) (derivs xs s)\"", "lemma derivs_PLUS: \"derivs xs (PLUS ys) = PLUS (map (derivs xs) ys)\"", "lemma toplevel_summands_derivs_Times: \"toplevel_summands (derivs xs (Times r s)) \\<subseteq>\n  {Times (derivs xs r) s} \\<union>\n  {r'. \\<exists>ys zs. r' \\<in> toplevel_summands (derivs ys s) \\<and> ys \\<noteq> [] \\<and> zs @ ys = xs}\"", "lemma toplevel_summands_derivs_Star_nonempty:\n  \"xs \\<noteq> [] \\<Longrightarrow> toplevel_summands (derivs xs (Star r)) \\<subseteq>\n    {Times (derivs ys r) (Star r) | ys. \\<exists>zs. ys \\<noteq> [] \\<and> zs @ ys = xs}\"", "lemma toplevel_summands_derivs_Star:\n  \"toplevel_summands (derivs xs (Star r)) \\<subseteq>\n    {Star r} \\<union> {Times (derivs ys r) (Star r) | ys. \\<exists>zs. ys \\<noteq> [] \\<and> zs @ ys = xs}\"", "lemma toplevel_summands_PLUS:\n \"xs \\<noteq> [] \\<Longrightarrow> toplevel_summands (PLUS (map f xs)) = (\\<Union>r \\<in> set xs. toplevel_summands (f r))\"", "lemma ACI_norm_toplevel_summands_Zero: \"toplevel_summands r \\<subseteq> {Zero} \\<Longrightarrow> \\<guillemotleft>r\\<guillemotright> = Zero\"", "lemma finite_ACI_norm_toplevel_summands:\n  \"finite {f \\<guillemotleft>s\\<guillemotright> |s. toplevel_summands s \\<subseteq> B}\" if \"finite B\"", "theorem finite_derivs: \"finite {\\<guillemotleft>derivs xs r\\<guillemotright> | xs . True}\"", "lemma ACI_norm_PLUS:\n  \"list_all2 (\\<lambda>r s. \\<guillemotleft>r\\<guillemotright> = \\<guillemotleft>s\\<guillemotright>) xs ys \\<Longrightarrow> \\<guillemotleft>PLUS xs\\<guillemotright> = \\<guillemotleft>PLUS ys\\<guillemotright>\"", "lemma toplevel_summands_ACI_norm_deriv:\n  \"(\\<Union>a\\<in>toplevel_summands r. toplevel_summands \\<guillemotleft>deriv as \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) = toplevel_summands \\<guillemotleft>deriv as \\<guillemotleft>r\\<guillemotright>\\<guillemotright>\"", "lemma toplevel_summands_nullable:\n  \"nullable s = (\\<exists>r\\<in>toplevel_summands s. nullable r)\"", "lemma nullable_PLUS:\n  \"nullable (PLUS xs) = (\\<exists>r \\<in> set xs. nullable r)\"", "theorem ACI_norm_nullable: \"nullable \\<guillemotleft>r\\<guillemotright> = nullable r\"", "theorem ACI_norm_deriv: \"\\<guillemotleft>deriv as \\<guillemotleft>r\\<guillemotright>\\<guillemotright> = \\<guillemotleft>deriv as r\\<guillemotright>\"", "lemma derivs_snoc[simp]: \"derivs (xs @ [x]) r = (deriv x (derivs xs r))\"", "theorem ACI_norm_derivs: \"\\<guillemotleft>derivs xs \\<guillemotleft>r\\<guillemotright>\\<guillemotright> = \\<guillemotleft>derivs xs r\\<guillemotright>\"", "lemma toplevel_summands_ACI_nPlus:\n  \"toplevel_summands (ACI_nPlus r s) = toplevel_summands (Plus r s)\"", "lemma toplevel_summands_ACI_norm_alt:\n  \"toplevel_summands (ACI_norm_alt r) = ACI_norm_alt ` toplevel_summands r\"", "lemma ACI_norm_alt_Plus:\n  \"ACI_norm_alt r = Plus s t \\<Longrightarrow> \\<exists>s t. r = Plus s t\"", "lemma toplevel_summands_flatten_ACI_norm_alt_image:\n  \"toplevel_summands (flatten PLUS (ACI_norm_alt ` toplevel_summands r)) = ACI_norm_alt ` toplevel_summands r\"", "lemma ACI_norm_ACI_norm_alt: \"\\<guillemotleft>ACI_norm_alt r\\<guillemotright> = \\<guillemotleft>r\\<guillemotright>\"", "lemma ACI_nPlus_singleton_PLUS: \n  \"\\<lbrakk>xs \\<noteq> []; sorted xs; distinct xs; \\<forall>x \\<in> {x} \\<union> set xs. \\<not>(\\<exists>r s. x = Plus r s)\\<rbrakk> \\<Longrightarrow>\n  ACI_nPlus x (PLUS xs) = (if x \\<in> set xs then PLUS xs else PLUS (insort x xs))\"", "lemma ACI_nPlus_PLUS:\n  \"\\<lbrakk>xs1 \\<noteq> []; xs2 \\<noteq> []; \\<forall>x \\<in> set (xs1 @ xs2). \\<not>(\\<exists>r s. x = Plus r s); sorted xs2; distinct xs2\\<rbrakk>\\<Longrightarrow>\n  ACI_nPlus (PLUS xs1) (PLUS xs2) = flatten PLUS (set (xs1 @ xs2))\"", "lemma ACI_nPlus_flatten_PLUS:\n  \"\\<lbrakk>X1 \\<noteq> {}; X2 \\<noteq> {}; finite X1; finite X2; \\<forall>x \\<in> X1 \\<union> X2. \\<not>(\\<exists>r s. x = Plus r s)\\<rbrakk>\\<Longrightarrow>\n  ACI_nPlus (flatten PLUS X1) (flatten PLUS X2) = flatten PLUS (X1 \\<union> X2)\"", "lemma ACI_nPlus_ACI_norm [simp]: \"ACI_nPlus \\<guillemotleft>r\\<guillemotright> \\<guillemotleft>s\\<guillemotright> = \\<guillemotleft>Plus r s\\<guillemotright>\"", "lemma ACI_norm_alt:\n  \"ACI_norm_alt r = \\<guillemotleft>r\\<guillemotright>\"", "lemma ACI_atoms: \"ACI r s \\<Longrightarrow> atoms r = atoms s\"", "lemma ACI_nullable: \"ACI r s \\<Longrightarrow> nullable r = nullable s\"", "lemma ACI_lang: \"ACI r s \\<Longrightarrow> lang r = lang s\"", "lemma ACI_deriv: \"ACI r s \\<Longrightarrow> ACI (deriv a r) (deriv a s)\"", "lemma ACI_Plus_assocI[intro]:\n  \"ACI (Plus r1 r2) s2 \\<Longrightarrow> ACI (Plus r1 (Plus s1 r2)) (Plus s1 s2)\"\n  \"ACI (Plus r1 r2) s2 \\<Longrightarrow> ACI (Plus r1 (Plus r2 s1)) (Plus s1 s2)\"", "lemma ACI_Plus_idemI[intro]: \"\\<lbrakk>ACI r s1; ACI r s2\\<rbrakk> \\<Longrightarrow> ACI r (Plus s1 s2)\"", "lemma ACI_Plus_idemI'[intro]:\n  \"\\<lbrakk>ACI r1 s1; ACI (Plus r1 r2) s2\\<rbrakk> \\<Longrightarrow> ACI (Plus r1 r2) (Plus s1 s2)\"", "lemma ACI_ACI_nPlus: \"\\<lbrakk>ACI r1 s1; ACI r2 s2\\<rbrakk> \\<Longrightarrow> ACI (ACI_nPlus r1 r2) (Plus s1 s2)\"", "lemma ACI_ACI_norm: \"ACI \\<guillemotleft>r\\<guillemotright> r\"", "lemma ACI_norm_eqI: \"ACI r s \\<Longrightarrow> \\<guillemotleft>r\\<guillemotright> = \\<guillemotleft>s\\<guillemotright>\"", "lemma ACI_I: \"\\<guillemotleft>r\\<guillemotright> = \\<guillemotleft>s\\<guillemotright> \\<Longrightarrow> ACI r s\"", "lemma ACI_decidable: \"ACI r s = (\\<guillemotleft>r\\<guillemotright> = \\<guillemotleft>s\\<guillemotright>)\""], "translations": [["", "lemma list_singleton_induct [case_names nil single cons]:\nassumes \"P []\" and \"\\<And>x. P [x]\" and \"\\<And>x y xs. P (y # xs) \\<Longrightarrow> P (x # (y # xs))\"\nshows \"P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs", "using assms"], ["proof (prove)\nusing this:\n  P []\n  P [?x]\n  P (?y # ?xs) \\<Longrightarrow> P (?x # ?y # ?xs)\n\ngoal (1 subgoal):\n 1. P xs", "by induction_schema (pat_completeness, lexicographic_order)"], ["", "subsection \\<open>ACI normalization\\<close>"], ["", "fun toplevel_summands :: \"'a rexp \\<Rightarrow> 'a rexp set\" where\n  \"toplevel_summands (Plus r s) = toplevel_summands r \\<union> toplevel_summands s\"\n| \"toplevel_summands r = {r}\""], ["", "abbreviation \"flatten LISTOP X \\<equiv> LISTOP (sorted_list_of_set X)\""], ["", "lemma toplevel_summands_nonempty[simp]:\n  \"toplevel_summands r \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toplevel_summands r \\<noteq> {}", "by (induct r) auto"], ["", "lemma toplevel_summands_finite[simp]:\n  \"finite (toplevel_summands r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (toplevel_summands r)", "by (induct r) auto"], ["", "primrec ACI_norm :: \"('a::linorder) rexp \\<Rightarrow> 'a rexp\"  (\"\\<guillemotleft>_\\<guillemotright>\") where\n  \"\\<guillemotleft>Zero\\<guillemotright> = Zero\"\n| \"\\<guillemotleft>One\\<guillemotright> = One\"\n| \"\\<guillemotleft>Atom a\\<guillemotright> = Atom a\"\n| \"\\<guillemotleft>Plus r s\\<guillemotright> = flatten PLUS (toplevel_summands (Plus \\<guillemotleft>r\\<guillemotright> \\<guillemotleft>s\\<guillemotright>))\"\n| \"\\<guillemotleft>Times r s\\<guillemotright> = Times \\<guillemotleft>r\\<guillemotright> \\<guillemotleft>s\\<guillemotright>\"\n| \"\\<guillemotleft>Star r\\<guillemotright> = Star \\<guillemotleft>r\\<guillemotright>\""], ["", "lemma Plus_toplevel_summands: \"Plus r s \\<in> toplevel_summands t \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Plus r s \\<in> toplevel_summands t \\<Longrightarrow> False", "by (induction t) auto"], ["", "lemma toplevel_summands_not_Plus[simp]:\n  \"(\\<forall>r s. x \\<noteq> Plus r s) \\<Longrightarrow> toplevel_summands x = {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r s. x \\<noteq> Plus r s \\<Longrightarrow>\n    toplevel_summands x = {x}", "by (induction x) auto"], ["", "lemma toplevel_summands_PLUS_strong:\n  \"\\<lbrakk>xs \\<noteq> []; list_all (\\<lambda>x. \\<not>(\\<exists>r s. x = Plus r s)) xs\\<rbrakk> \\<Longrightarrow> toplevel_summands (PLUS xs) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> [];\n     list_all (\\<lambda>x. \\<nexists>r s. x = Plus r s) xs\\<rbrakk>\n    \\<Longrightarrow> toplevel_summands (PLUS xs) = set xs", "by (induct xs rule: list_singleton_induct) auto"], ["", "lemma toplevel_summands_flatten:\n  \"\\<lbrakk>X \\<noteq> {}; finite X; \\<forall>x \\<in> X. \\<not>(\\<exists>r s. x = Plus r s)\\<rbrakk> \\<Longrightarrow> toplevel_summands (flatten PLUS X) = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<noteq> {}; finite X;\n     \\<forall>x\\<in>X. \\<nexists>r s. x = Plus r s\\<rbrakk>\n    \\<Longrightarrow> toplevel_summands (flatten PLUS X) = X", "using toplevel_summands_PLUS_strong[of \"sorted_list_of_set X\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>flatten (\\<noteq>) X [];\n   flatten (list_all (\\<lambda>x. \\<nexists>r s. x = Plus r s)) X\\<rbrakk>\n  \\<Longrightarrow> toplevel_summands (flatten PLUS X) = flatten set X\n\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<noteq> {}; finite X;\n     \\<forall>x\\<in>X. \\<nexists>r s. x = Plus r s\\<rbrakk>\n    \\<Longrightarrow> toplevel_summands (flatten PLUS X) = X", "unfolding list_all_iff"], ["proof (prove)\nusing this:\n  \\<lbrakk>flatten (\\<noteq>) X [];\n   \\<forall>x\\<in>flatten set X. \\<nexists>r s. x = Plus r s\\<rbrakk>\n  \\<Longrightarrow> toplevel_summands (flatten PLUS X) = flatten set X\n\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<noteq> {}; finite X;\n     \\<forall>x\\<in>X. \\<nexists>r s. x = Plus r s\\<rbrakk>\n    \\<Longrightarrow> toplevel_summands (flatten PLUS X) = X", "by fastforce"], ["", "lemma ACI_norm_Plus: \"\\<guillemotleft>r\\<guillemotright> = Plus s t \\<Longrightarrow> \\<exists>s t. r = Plus s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>r\\<guillemotright> = Plus s t \\<Longrightarrow>\n    \\<exists>s t. r = Plus s t", "by (induction r) auto"], ["", "lemma toplevel_summands_flatten_ACI_norm_image:\n  \"toplevel_summands (flatten PLUS (ACI_norm ` toplevel_summands r)) = ACI_norm ` toplevel_summands r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toplevel_summands (flatten PLUS (ACI_norm ` toplevel_summands r)) =\n    ACI_norm ` toplevel_summands r", "by (intro toplevel_summands_flatten) (auto dest!: ACI_norm_Plus intro: Plus_toplevel_summands)"], ["", "lemma toplevel_summands_flatten_ACI_norm_image_Union:\n  \"toplevel_summands (flatten PLUS (ACI_norm ` toplevel_summands r \\<union> ACI_norm ` toplevel_summands s)) =\n    ACI_norm ` toplevel_summands r \\<union> ACI_norm ` toplevel_summands s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toplevel_summands\n     (flatten PLUS\n       (ACI_norm ` toplevel_summands r \\<union>\n        ACI_norm ` toplevel_summands s)) =\n    ACI_norm ` toplevel_summands r \\<union> ACI_norm ` toplevel_summands s", "by (intro toplevel_summands_flatten) (auto dest!: ACI_norm_Plus[OF sym] intro: Plus_toplevel_summands)"], ["", "lemma toplevel_summands_ACI_norm:\n  \"toplevel_summands \\<guillemotleft>r\\<guillemotright> = ACI_norm ` toplevel_summands r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toplevel_summands \\<guillemotleft>r\\<guillemotright> =\n    ACI_norm ` toplevel_summands r", "by (induction r) (auto simp: toplevel_summands_flatten_ACI_norm_image_Union)"], ["", "lemma ACI_norm_flatten:\n  \"\\<guillemotleft>r\\<guillemotright> = flatten PLUS (ACI_norm ` toplevel_summands r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>r\\<guillemotright> =\n    flatten PLUS (ACI_norm ` toplevel_summands r)", "by (induction r) (auto simp: image_Un toplevel_summands_flatten_ACI_norm_image)"], ["", "theorem ACI_norm_idem[simp]: \"\\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> = \\<guillemotleft>r\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>r\\<guillemotright>", "proof (induct r)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<guillemotleft>\\<guillemotleft>Zero\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>Zero\\<guillemotright>\n 2. \\<guillemotleft>\\<guillemotleft>One\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>One\\<guillemotright>\n 3. \\<And>x.\n       \\<guillemotleft>\\<guillemotleft>Atom\n  x\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Atom x\\<guillemotright>\n 4. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>Plus r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>Plus r1 r2\\<guillemotright>\n 5. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>Times r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>Times r1 r2\\<guillemotright>\n 6. \\<And>r.\n       \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>\\<guillemotleft>Star\n  r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Star r\\<guillemotright>", "case (Plus r s)"], ["proof (state)\nthis:\n  \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>r\\<guillemotright>\n  \\<guillemotleft>\\<guillemotleft>s\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>s\\<guillemotright>\n\ngoal (6 subgoals):\n 1. \\<guillemotleft>\\<guillemotleft>Zero\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>Zero\\<guillemotright>\n 2. \\<guillemotleft>\\<guillemotleft>One\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>One\\<guillemotright>\n 3. \\<And>x.\n       \\<guillemotleft>\\<guillemotleft>Atom\n  x\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Atom x\\<guillemotright>\n 4. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>Plus r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>Plus r1 r2\\<guillemotright>\n 5. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>Times r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>Times r1 r2\\<guillemotright>\n 6. \\<And>r.\n       \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>\\<guillemotleft>Star\n  r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Star r\\<guillemotright>", "have \"\\<guillemotleft>\\<guillemotleft>Plus r s\\<guillemotright>\\<guillemotright> = \\<guillemotleft>flatten PLUS (toplevel_summands \\<guillemotleft>r\\<guillemotright> \\<union> toplevel_summands \\<guillemotleft>s\\<guillemotright>)\\<guillemotright>\"\n    (is \"_ = \\<guillemotleft>flatten PLUS ?U\\<guillemotright>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<guillemotleft>Plus r\n                                     s\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>flatten PLUS\n                     (toplevel_summands\n                       \\<guillemotleft>r\\<guillemotright> \\<union>\n                      toplevel_summands\n                       \\<guillemotleft>s\\<guillemotright>)\\<guillemotright>", "by simp"], ["proof (state)\nthis:\n  \\<guillemotleft>\\<guillemotleft>Plus r\n                                   s\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>flatten PLUS\n                   (toplevel_summands\n                     \\<guillemotleft>r\\<guillemotright> \\<union>\n                    toplevel_summands\n                     \\<guillemotleft>s\\<guillemotright>)\\<guillemotright>\n\ngoal (6 subgoals):\n 1. \\<guillemotleft>\\<guillemotleft>Zero\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>Zero\\<guillemotright>\n 2. \\<guillemotleft>\\<guillemotleft>One\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>One\\<guillemotright>\n 3. \\<And>x.\n       \\<guillemotleft>\\<guillemotleft>Atom\n  x\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Atom x\\<guillemotright>\n 4. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>Plus r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>Plus r1 r2\\<guillemotright>\n 5. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>Times r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>Times r1 r2\\<guillemotright>\n 6. \\<And>r.\n       \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>\\<guillemotleft>Star\n  r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Star r\\<guillemotright>", "also"], ["proof (state)\nthis:\n  \\<guillemotleft>\\<guillemotleft>Plus r\n                                   s\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>flatten PLUS\n                   (toplevel_summands\n                     \\<guillemotleft>r\\<guillemotright> \\<union>\n                    toplevel_summands\n                     \\<guillemotleft>s\\<guillemotright>)\\<guillemotright>\n\ngoal (6 subgoals):\n 1. \\<guillemotleft>\\<guillemotleft>Zero\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>Zero\\<guillemotright>\n 2. \\<guillemotleft>\\<guillemotleft>One\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>One\\<guillemotright>\n 3. \\<And>x.\n       \\<guillemotleft>\\<guillemotleft>Atom\n  x\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Atom x\\<guillemotright>\n 4. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>Plus r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>Plus r1 r2\\<guillemotright>\n 5. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>Times r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>Times r1 r2\\<guillemotright>\n 6. \\<And>r.\n       \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>\\<guillemotleft>Star\n  r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Star r\\<guillemotright>", "have \"\\<dots> = flatten PLUS (ACI_norm ` toplevel_summands (flatten PLUS ?U))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>flatten PLUS\n                     (toplevel_summands\n                       \\<guillemotleft>r\\<guillemotright> \\<union>\n                      toplevel_summands\n                       \\<guillemotleft>s\\<guillemotright>)\\<guillemotright> =\n    flatten PLUS\n     (ACI_norm `\n      toplevel_summands\n       (flatten PLUS\n         (toplevel_summands \\<guillemotleft>r\\<guillemotright> \\<union>\n          toplevel_summands \\<guillemotleft>s\\<guillemotright>)))", "by (simp only: ACI_norm_flatten)"], ["proof (state)\nthis:\n  \\<guillemotleft>flatten PLUS\n                   (toplevel_summands\n                     \\<guillemotleft>r\\<guillemotright> \\<union>\n                    toplevel_summands\n                     \\<guillemotleft>s\\<guillemotright>)\\<guillemotright> =\n  flatten PLUS\n   (ACI_norm `\n    toplevel_summands\n     (flatten PLUS\n       (toplevel_summands \\<guillemotleft>r\\<guillemotright> \\<union>\n        toplevel_summands \\<guillemotleft>s\\<guillemotright>)))\n\ngoal (6 subgoals):\n 1. \\<guillemotleft>\\<guillemotleft>Zero\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>Zero\\<guillemotright>\n 2. \\<guillemotleft>\\<guillemotleft>One\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>One\\<guillemotright>\n 3. \\<And>x.\n       \\<guillemotleft>\\<guillemotleft>Atom\n  x\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Atom x\\<guillemotright>\n 4. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>Plus r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>Plus r1 r2\\<guillemotright>\n 5. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>Times r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>Times r1 r2\\<guillemotright>\n 6. \\<And>r.\n       \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>\\<guillemotleft>Star\n  r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Star r\\<guillemotright>", "also"], ["proof (state)\nthis:\n  \\<guillemotleft>flatten PLUS\n                   (toplevel_summands\n                     \\<guillemotleft>r\\<guillemotright> \\<union>\n                    toplevel_summands\n                     \\<guillemotleft>s\\<guillemotright>)\\<guillemotright> =\n  flatten PLUS\n   (ACI_norm `\n    toplevel_summands\n     (flatten PLUS\n       (toplevel_summands \\<guillemotleft>r\\<guillemotright> \\<union>\n        toplevel_summands \\<guillemotleft>s\\<guillemotright>)))\n\ngoal (6 subgoals):\n 1. \\<guillemotleft>\\<guillemotleft>Zero\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>Zero\\<guillemotright>\n 2. \\<guillemotleft>\\<guillemotleft>One\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>One\\<guillemotright>\n 3. \\<And>x.\n       \\<guillemotleft>\\<guillemotleft>Atom\n  x\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Atom x\\<guillemotright>\n 4. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>Plus r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>Plus r1 r2\\<guillemotright>\n 5. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>Times r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>Times r1 r2\\<guillemotright>\n 6. \\<And>r.\n       \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>\\<guillemotleft>Star\n  r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Star r\\<guillemotright>", "have \"toplevel_summands (flatten PLUS ?U) = ?U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toplevel_summands\n     (flatten PLUS\n       (toplevel_summands \\<guillemotleft>r\\<guillemotright> \\<union>\n        toplevel_summands \\<guillemotleft>s\\<guillemotright>)) =\n    toplevel_summands \\<guillemotleft>r\\<guillemotright> \\<union>\n    toplevel_summands \\<guillemotleft>s\\<guillemotright>", "by (intro toplevel_summands_flatten) (auto intro: Plus_toplevel_summands)"], ["proof (state)\nthis:\n  toplevel_summands\n   (flatten PLUS\n     (toplevel_summands \\<guillemotleft>r\\<guillemotright> \\<union>\n      toplevel_summands \\<guillemotleft>s\\<guillemotright>)) =\n  toplevel_summands \\<guillemotleft>r\\<guillemotright> \\<union>\n  toplevel_summands \\<guillemotleft>s\\<guillemotright>\n\ngoal (6 subgoals):\n 1. \\<guillemotleft>\\<guillemotleft>Zero\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>Zero\\<guillemotright>\n 2. \\<guillemotleft>\\<guillemotleft>One\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>One\\<guillemotright>\n 3. \\<And>x.\n       \\<guillemotleft>\\<guillemotleft>Atom\n  x\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Atom x\\<guillemotright>\n 4. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>Plus r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>Plus r1 r2\\<guillemotright>\n 5. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>Times r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>Times r1 r2\\<guillemotright>\n 6. \\<And>r.\n       \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>\\<guillemotleft>Star\n  r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Star r\\<guillemotright>", "also"], ["proof (state)\nthis:\n  toplevel_summands\n   (flatten PLUS\n     (toplevel_summands \\<guillemotleft>r\\<guillemotright> \\<union>\n      toplevel_summands \\<guillemotleft>s\\<guillemotright>)) =\n  toplevel_summands \\<guillemotleft>r\\<guillemotright> \\<union>\n  toplevel_summands \\<guillemotleft>s\\<guillemotright>\n\ngoal (6 subgoals):\n 1. \\<guillemotleft>\\<guillemotleft>Zero\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>Zero\\<guillemotright>\n 2. \\<guillemotleft>\\<guillemotleft>One\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>One\\<guillemotright>\n 3. \\<And>x.\n       \\<guillemotleft>\\<guillemotleft>Atom\n  x\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Atom x\\<guillemotright>\n 4. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>Plus r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>Plus r1 r2\\<guillemotright>\n 5. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>Times r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>Times r1 r2\\<guillemotright>\n 6. \\<And>r.\n       \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>\\<guillemotleft>Star\n  r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Star r\\<guillemotright>", "have \"flatten PLUS (ACI_norm ` ?U) = flatten PLUS (toplevel_summands \\<guillemotleft>r\\<guillemotright> \\<union> toplevel_summands \\<guillemotleft>s\\<guillemotright>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten PLUS\n     (ACI_norm `\n      (toplevel_summands \\<guillemotleft>r\\<guillemotright> \\<union>\n       toplevel_summands \\<guillemotleft>s\\<guillemotright>)) =\n    flatten PLUS\n     (toplevel_summands \\<guillemotleft>r\\<guillemotright> \\<union>\n      toplevel_summands \\<guillemotleft>s\\<guillemotright>)", "by (simp only: image_Un toplevel_summands_ACI_norm[symmetric] Plus)"], ["proof (state)\nthis:\n  flatten PLUS\n   (ACI_norm `\n    (toplevel_summands \\<guillemotleft>r\\<guillemotright> \\<union>\n     toplevel_summands \\<guillemotleft>s\\<guillemotright>)) =\n  flatten PLUS\n   (toplevel_summands \\<guillemotleft>r\\<guillemotright> \\<union>\n    toplevel_summands \\<guillemotleft>s\\<guillemotright>)\n\ngoal (6 subgoals):\n 1. \\<guillemotleft>\\<guillemotleft>Zero\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>Zero\\<guillemotright>\n 2. \\<guillemotleft>\\<guillemotleft>One\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>One\\<guillemotright>\n 3. \\<And>x.\n       \\<guillemotleft>\\<guillemotleft>Atom\n  x\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Atom x\\<guillemotright>\n 4. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>Plus r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>Plus r1 r2\\<guillemotright>\n 5. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>Times r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>Times r1 r2\\<guillemotright>\n 6. \\<And>r.\n       \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>\\<guillemotleft>Star\n  r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Star r\\<guillemotright>", "finally"], ["proof (chain)\npicking this:\n  \\<guillemotleft>\\<guillemotleft>Plus r\n                                   s\\<guillemotright>\\<guillemotright> =\n  flatten PLUS\n   (toplevel_summands \\<guillemotleft>r\\<guillemotright> \\<union>\n    toplevel_summands \\<guillemotleft>s\\<guillemotright>)", "show ?case"], ["proof (prove)\nusing this:\n  \\<guillemotleft>\\<guillemotleft>Plus r\n                                   s\\<guillemotright>\\<guillemotright> =\n  flatten PLUS\n   (toplevel_summands \\<guillemotleft>r\\<guillemotright> \\<union>\n    toplevel_summands \\<guillemotleft>s\\<guillemotright>)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<guillemotleft>Plus r\n                                     s\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>Plus r s\\<guillemotright>", "by simp"], ["proof (state)\nthis:\n  \\<guillemotleft>\\<guillemotleft>Plus r\n                                   s\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>Plus r s\\<guillemotright>\n\ngoal (5 subgoals):\n 1. \\<guillemotleft>\\<guillemotleft>Zero\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>Zero\\<guillemotright>\n 2. \\<guillemotleft>\\<guillemotleft>One\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>One\\<guillemotright>\n 3. \\<And>x.\n       \\<guillemotleft>\\<guillemotleft>Atom\n  x\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Atom x\\<guillemotright>\n 4. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>Times r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>Times r1 r2\\<guillemotright>\n 5. \\<And>r.\n       \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>\\<guillemotleft>Star\n  r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Star r\\<guillemotright>", "qed auto"], ["", "subsection \"Atoms\""], ["", "lemma atoms_toplevel_summands:\n  \"atoms s = (\\<Union>r\\<in>toplevel_summands s. atoms r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atoms s = \\<Union> (atoms ` toplevel_summands s)", "by (induct s) auto"], ["", "lemma wf_PLUS: \"atoms (PLUS xs) \\<subseteq> \\<Sigma> \\<longleftrightarrow> (\\<forall>r \\<in> set xs. atoms r \\<subseteq> \\<Sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (atoms (PLUS xs) \\<subseteq> \\<Sigma>) =\n    (\\<forall>r\\<in>set xs. atoms r \\<subseteq> \\<Sigma>)", "by (induct xs rule: list_singleton_induct) auto"], ["", "lemma atoms_PLUS: \"atoms (PLUS xs) = (\\<Union>r \\<in> set xs. atoms r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atoms (PLUS xs) = \\<Union> (atoms ` set xs)", "by (induct xs rule: list_singleton_induct) auto"], ["", "lemma atoms_flatten_PLUS:\n  \"finite X \\<Longrightarrow> atoms (flatten PLUS X) = (\\<Union>r \\<in> X. atoms r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite X \\<Longrightarrow> atoms (flatten PLUS X) = \\<Union> (atoms ` X)", "using wf_PLUS[of \"sorted_list_of_set X\"]"], ["proof (prove)\nusing this:\n  (atoms (flatten PLUS X) \\<subseteq> ?\\<Sigma>) =\n  (\\<forall>r\\<in>flatten set X. atoms r \\<subseteq> ?\\<Sigma>)\n\ngoal (1 subgoal):\n 1. finite X \\<Longrightarrow> atoms (flatten PLUS X) = \\<Union> (atoms ` X)", "by auto"], ["", "theorem atoms_ACI_norm: \"atoms \\<guillemotleft>r\\<guillemotright> = atoms r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atoms \\<guillemotleft>r\\<guillemotright> = atoms r", "proof (induct r)"], ["proof (state)\ngoal (6 subgoals):\n 1. atoms \\<guillemotleft>Zero\\<guillemotright> = atoms Zero\n 2. atoms \\<guillemotleft>One\\<guillemotright> = atoms One\n 3. \\<And>x. atoms \\<guillemotleft>Atom x\\<guillemotright> = atoms (Atom x)\n 4. \\<And>r1 r2.\n       \\<lbrakk>atoms \\<guillemotleft>r1\\<guillemotright> = atoms r1;\n        atoms \\<guillemotleft>r2\\<guillemotright> = atoms r2\\<rbrakk>\n       \\<Longrightarrow> atoms \\<guillemotleft>Plus r1 r2\\<guillemotright> =\n                         atoms (Plus r1 r2)\n 5. \\<And>r1 r2.\n       \\<lbrakk>atoms \\<guillemotleft>r1\\<guillemotright> = atoms r1;\n        atoms \\<guillemotleft>r2\\<guillemotright> = atoms r2\\<rbrakk>\n       \\<Longrightarrow> atoms\n                          \\<guillemotleft>Times r1 r2\\<guillemotright> =\n                         atoms (Times r1 r2)\n 6. \\<And>r.\n       atoms \\<guillemotleft>r\\<guillemotright> = atoms r \\<Longrightarrow>\n       atoms \\<guillemotleft>Star r\\<guillemotright> = atoms (Star r)", "case (Plus r1 r2)"], ["proof (state)\nthis:\n  atoms \\<guillemotleft>r1\\<guillemotright> = atoms r1\n  atoms \\<guillemotleft>r2\\<guillemotright> = atoms r2\n\ngoal (6 subgoals):\n 1. atoms \\<guillemotleft>Zero\\<guillemotright> = atoms Zero\n 2. atoms \\<guillemotleft>One\\<guillemotright> = atoms One\n 3. \\<And>x. atoms \\<guillemotleft>Atom x\\<guillemotright> = atoms (Atom x)\n 4. \\<And>r1 r2.\n       \\<lbrakk>atoms \\<guillemotleft>r1\\<guillemotright> = atoms r1;\n        atoms \\<guillemotleft>r2\\<guillemotright> = atoms r2\\<rbrakk>\n       \\<Longrightarrow> atoms \\<guillemotleft>Plus r1 r2\\<guillemotright> =\n                         atoms (Plus r1 r2)\n 5. \\<And>r1 r2.\n       \\<lbrakk>atoms \\<guillemotleft>r1\\<guillemotright> = atoms r1;\n        atoms \\<guillemotleft>r2\\<guillemotright> = atoms r2\\<rbrakk>\n       \\<Longrightarrow> atoms\n                          \\<guillemotleft>Times r1 r2\\<guillemotright> =\n                         atoms (Times r1 r2)\n 6. \\<And>r.\n       atoms \\<guillemotleft>r\\<guillemotright> = atoms r \\<Longrightarrow>\n       atoms \\<guillemotleft>Star r\\<guillemotright> = atoms (Star r)", "thus ?case"], ["proof (prove)\nusing this:\n  atoms \\<guillemotleft>r1\\<guillemotright> = atoms r1\n  atoms \\<guillemotleft>r2\\<guillemotright> = atoms r2\n\ngoal (1 subgoal):\n 1. atoms \\<guillemotleft>Plus r1 r2\\<guillemotright> = atoms (Plus r1 r2)", "using atoms_toplevel_summands[of \"\\<guillemotleft>r1\\<guillemotright>\"] atoms_toplevel_summands[of \"\\<guillemotleft>r2\\<guillemotright>\"]"], ["proof (prove)\nusing this:\n  atoms \\<guillemotleft>r1\\<guillemotright> = atoms r1\n  atoms \\<guillemotleft>r2\\<guillemotright> = atoms r2\n  atoms \\<guillemotleft>r1\\<guillemotright> =\n  \\<Union> (atoms ` toplevel_summands \\<guillemotleft>r1\\<guillemotright>)\n  atoms \\<guillemotleft>r2\\<guillemotright> =\n  \\<Union> (atoms ` toplevel_summands \\<guillemotleft>r2\\<guillemotright>)\n\ngoal (1 subgoal):\n 1. atoms \\<guillemotleft>Plus r1 r2\\<guillemotright> = atoms (Plus r1 r2)", "by(simp add: atoms_flatten_PLUS ball_Un Un_commute)"], ["proof (state)\nthis:\n  atoms \\<guillemotleft>Plus r1 r2\\<guillemotright> = atoms (Plus r1 r2)\n\ngoal (5 subgoals):\n 1. atoms \\<guillemotleft>Zero\\<guillemotright> = atoms Zero\n 2. atoms \\<guillemotleft>One\\<guillemotright> = atoms One\n 3. \\<And>x. atoms \\<guillemotleft>Atom x\\<guillemotright> = atoms (Atom x)\n 4. \\<And>r1 r2.\n       \\<lbrakk>atoms \\<guillemotleft>r1\\<guillemotright> = atoms r1;\n        atoms \\<guillemotleft>r2\\<guillemotright> = atoms r2\\<rbrakk>\n       \\<Longrightarrow> atoms\n                          \\<guillemotleft>Times r1 r2\\<guillemotright> =\n                         atoms (Times r1 r2)\n 5. \\<And>r.\n       atoms \\<guillemotleft>r\\<guillemotright> = atoms r \\<Longrightarrow>\n       atoms \\<guillemotleft>Star r\\<guillemotright> = atoms (Star r)", "qed auto"], ["", "subsection \"Language\""], ["", "lemma toplevel_summands_lang: \"r \\<in> toplevel_summands s \\<Longrightarrow> lang r \\<subseteq> lang s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<in> toplevel_summands s \\<Longrightarrow> lang r \\<subseteq> lang s", "by (induct s) auto"], ["", "lemma toplevel_summands_lang_UN:\n  \"lang s = (\\<Union>r\\<in>toplevel_summands s. lang r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang s = \\<Union> (lang ` toplevel_summands s)", "by (induct s) auto"], ["", "lemma toplevel_summands_in_lang:\n  \"w \\<in> lang s = (\\<exists>r\\<in>toplevel_summands s. w \\<in> lang r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w \\<in> lang s) = (\\<exists>r\\<in>toplevel_summands s. w \\<in> lang r)", "by (induct s) auto"], ["", "lemma lang_PLUS: \"lang (PLUS xs) = (\\<Union>r \\<in> set xs. lang r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang (PLUS xs) = \\<Union> (lang ` set xs)", "by (induct xs rule: list_singleton_induct) auto"], ["", "lemma lang_PLUS_map[simp]:\n  \"lang (PLUS (map f xs)) = (\\<Union>a\\<in>set xs. lang (f a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang (PLUS (map f xs)) = (\\<Union>a\\<in>set xs. lang (f a))", "by (induct xs rule: list_singleton_induct) auto"], ["", "lemma lang_flatten_PLUS[simp]:\n  \"finite X \\<Longrightarrow> lang (flatten PLUS X) = (\\<Union>r \\<in> X. lang r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite X \\<Longrightarrow> lang (flatten PLUS X) = \\<Union> (lang ` X)", "using lang_PLUS[of \"sorted_list_of_set X\"]"], ["proof (prove)\nusing this:\n  lang (flatten PLUS X) = \\<Union> (lang ` flatten set X)\n\ngoal (1 subgoal):\n 1. finite X \\<Longrightarrow> lang (flatten PLUS X) = \\<Union> (lang ` X)", "by fastforce"], ["", "theorem lang_ACI_norm[simp]: \"lang \\<guillemotleft>r\\<guillemotright> = lang r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang \\<guillemotleft>r\\<guillemotright> = lang r", "proof (induct r)"], ["proof (state)\ngoal (6 subgoals):\n 1. lang \\<guillemotleft>Zero\\<guillemotright> = lang Zero\n 2. lang \\<guillemotleft>One\\<guillemotright> = lang One\n 3. \\<And>x. lang \\<guillemotleft>Atom x\\<guillemotright> = lang (Atom x)\n 4. \\<And>r1 r2.\n       \\<lbrakk>lang \\<guillemotleft>r1\\<guillemotright> = lang r1;\n        lang \\<guillemotleft>r2\\<guillemotright> = lang r2\\<rbrakk>\n       \\<Longrightarrow> lang \\<guillemotleft>Plus r1 r2\\<guillemotright> =\n                         lang (Plus r1 r2)\n 5. \\<And>r1 r2.\n       \\<lbrakk>lang \\<guillemotleft>r1\\<guillemotright> = lang r1;\n        lang \\<guillemotleft>r2\\<guillemotright> = lang r2\\<rbrakk>\n       \\<Longrightarrow> lang \\<guillemotleft>Times r1 r2\\<guillemotright> =\n                         lang (Times r1 r2)\n 6. \\<And>r.\n       lang \\<guillemotleft>r\\<guillemotright> = lang r \\<Longrightarrow>\n       lang \\<guillemotleft>Star r\\<guillemotright> = lang (Star r)", "case (Plus r1 r2)"], ["proof (state)\nthis:\n  lang \\<guillemotleft>r1\\<guillemotright> = lang r1\n  lang \\<guillemotleft>r2\\<guillemotright> = lang r2\n\ngoal (6 subgoals):\n 1. lang \\<guillemotleft>Zero\\<guillemotright> = lang Zero\n 2. lang \\<guillemotleft>One\\<guillemotright> = lang One\n 3. \\<And>x. lang \\<guillemotleft>Atom x\\<guillemotright> = lang (Atom x)\n 4. \\<And>r1 r2.\n       \\<lbrakk>lang \\<guillemotleft>r1\\<guillemotright> = lang r1;\n        lang \\<guillemotleft>r2\\<guillemotright> = lang r2\\<rbrakk>\n       \\<Longrightarrow> lang \\<guillemotleft>Plus r1 r2\\<guillemotright> =\n                         lang (Plus r1 r2)\n 5. \\<And>r1 r2.\n       \\<lbrakk>lang \\<guillemotleft>r1\\<guillemotright> = lang r1;\n        lang \\<guillemotleft>r2\\<guillemotright> = lang r2\\<rbrakk>\n       \\<Longrightarrow> lang \\<guillemotleft>Times r1 r2\\<guillemotright> =\n                         lang (Times r1 r2)\n 6. \\<And>r.\n       lang \\<guillemotleft>r\\<guillemotright> = lang r \\<Longrightarrow>\n       lang \\<guillemotleft>Star r\\<guillemotright> = lang (Star r)", "moreover"], ["proof (state)\nthis:\n  lang \\<guillemotleft>r1\\<guillemotright> = lang r1\n  lang \\<guillemotleft>r2\\<guillemotright> = lang r2\n\ngoal (6 subgoals):\n 1. lang \\<guillemotleft>Zero\\<guillemotright> = lang Zero\n 2. lang \\<guillemotleft>One\\<guillemotright> = lang One\n 3. \\<And>x. lang \\<guillemotleft>Atom x\\<guillemotright> = lang (Atom x)\n 4. \\<And>r1 r2.\n       \\<lbrakk>lang \\<guillemotleft>r1\\<guillemotright> = lang r1;\n        lang \\<guillemotleft>r2\\<guillemotright> = lang r2\\<rbrakk>\n       \\<Longrightarrow> lang \\<guillemotleft>Plus r1 r2\\<guillemotright> =\n                         lang (Plus r1 r2)\n 5. \\<And>r1 r2.\n       \\<lbrakk>lang \\<guillemotleft>r1\\<guillemotright> = lang r1;\n        lang \\<guillemotleft>r2\\<guillemotright> = lang r2\\<rbrakk>\n       \\<Longrightarrow> lang \\<guillemotleft>Times r1 r2\\<guillemotright> =\n                         lang (Times r1 r2)\n 6. \\<And>r.\n       lang \\<guillemotleft>r\\<guillemotright> = lang r \\<Longrightarrow>\n       lang \\<guillemotleft>Star r\\<guillemotright> = lang (Star r)", "from Plus[symmetric]"], ["proof (chain)\npicking this:\n  lang r1 = lang \\<guillemotleft>r1\\<guillemotright>\n  lang r2 = lang \\<guillemotleft>r2\\<guillemotright>", "have \"lang (Plus r1 r2) \\<subseteq> lang \\<guillemotleft>Plus r1 r2\\<guillemotright>\""], ["proof (prove)\nusing this:\n  lang r1 = lang \\<guillemotleft>r1\\<guillemotright>\n  lang r2 = lang \\<guillemotleft>r2\\<guillemotright>\n\ngoal (1 subgoal):\n 1. lang (Plus r1 r2)\n    \\<subseteq> lang \\<guillemotleft>Plus r1 r2\\<guillemotright>", "using toplevel_summands_in_lang[of _ \"\\<guillemotleft>r1\\<guillemotright>\"] toplevel_summands_in_lang[of _ \"\\<guillemotleft>r2\\<guillemotright>\"]"], ["proof (prove)\nusing this:\n  lang r1 = lang \\<guillemotleft>r1\\<guillemotright>\n  lang r2 = lang \\<guillemotleft>r2\\<guillemotright>\n  (?w \\<in> lang \\<guillemotleft>r1\\<guillemotright>) =\n  (\\<exists>r\\<in>toplevel_summands \\<guillemotleft>r1\\<guillemotright>.\n      ?w \\<in> lang r)\n  (?w \\<in> lang \\<guillemotleft>r2\\<guillemotright>) =\n  (\\<exists>r\\<in>toplevel_summands \\<guillemotleft>r2\\<guillemotright>.\n      ?w \\<in> lang r)\n\ngoal (1 subgoal):\n 1. lang (Plus r1 r2)\n    \\<subseteq> lang \\<guillemotleft>Plus r1 r2\\<guillemotright>", "by auto"], ["proof (state)\nthis:\n  lang (Plus r1 r2)\n  \\<subseteq> lang \\<guillemotleft>Plus r1 r2\\<guillemotright>\n\ngoal (6 subgoals):\n 1. lang \\<guillemotleft>Zero\\<guillemotright> = lang Zero\n 2. lang \\<guillemotleft>One\\<guillemotright> = lang One\n 3. \\<And>x. lang \\<guillemotleft>Atom x\\<guillemotright> = lang (Atom x)\n 4. \\<And>r1 r2.\n       \\<lbrakk>lang \\<guillemotleft>r1\\<guillemotright> = lang r1;\n        lang \\<guillemotleft>r2\\<guillemotright> = lang r2\\<rbrakk>\n       \\<Longrightarrow> lang \\<guillemotleft>Plus r1 r2\\<guillemotright> =\n                         lang (Plus r1 r2)\n 5. \\<And>r1 r2.\n       \\<lbrakk>lang \\<guillemotleft>r1\\<guillemotright> = lang r1;\n        lang \\<guillemotleft>r2\\<guillemotright> = lang r2\\<rbrakk>\n       \\<Longrightarrow> lang \\<guillemotleft>Times r1 r2\\<guillemotright> =\n                         lang (Times r1 r2)\n 6. \\<And>r.\n       lang \\<guillemotleft>r\\<guillemotright> = lang r \\<Longrightarrow>\n       lang \\<guillemotleft>Star r\\<guillemotright> = lang (Star r)", "ultimately"], ["proof (chain)\npicking this:\n  lang \\<guillemotleft>r1\\<guillemotright> = lang r1\n  lang \\<guillemotleft>r2\\<guillemotright> = lang r2\n  lang (Plus r1 r2)\n  \\<subseteq> lang \\<guillemotleft>Plus r1 r2\\<guillemotright>", "show ?case"], ["proof (prove)\nusing this:\n  lang \\<guillemotleft>r1\\<guillemotright> = lang r1\n  lang \\<guillemotleft>r2\\<guillemotright> = lang r2\n  lang (Plus r1 r2)\n  \\<subseteq> lang \\<guillemotleft>Plus r1 r2\\<guillemotright>\n\ngoal (1 subgoal):\n 1. lang \\<guillemotleft>Plus r1 r2\\<guillemotright> = lang (Plus r1 r2)", "by (fastforce dest!: toplevel_summands_lang)"], ["proof (state)\nthis:\n  lang \\<guillemotleft>Plus r1 r2\\<guillemotright> = lang (Plus r1 r2)\n\ngoal (5 subgoals):\n 1. lang \\<guillemotleft>Zero\\<guillemotright> = lang Zero\n 2. lang \\<guillemotleft>One\\<guillemotright> = lang One\n 3. \\<And>x. lang \\<guillemotleft>Atom x\\<guillemotright> = lang (Atom x)\n 4. \\<And>r1 r2.\n       \\<lbrakk>lang \\<guillemotleft>r1\\<guillemotright> = lang r1;\n        lang \\<guillemotleft>r2\\<guillemotright> = lang r2\\<rbrakk>\n       \\<Longrightarrow> lang \\<guillemotleft>Times r1 r2\\<guillemotright> =\n                         lang (Times r1 r2)\n 5. \\<And>r.\n       lang \\<guillemotleft>r\\<guillemotright> = lang r \\<Longrightarrow>\n       lang \\<guillemotleft>Star r\\<guillemotright> = lang (Star r)", "qed auto"], ["", "subsection \\<open>Finiteness of ACI-Equivalent Derivatives\\<close>"], ["", "lemma toplevel_summands_deriv:\n  \"toplevel_summands (deriv as r) = (\\<Union>s\\<in>toplevel_summands r. toplevel_summands (deriv as s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toplevel_summands (deriv as r) =\n    (\\<Union>s\\<in>toplevel_summands r. toplevel_summands (deriv as s))", "by (induction r) (auto simp: Let_def)"], ["", "lemma derivs_Zero[simp]: \"derivs xs Zero = Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derivs xs Zero = Zero", "by (induction xs) auto"], ["", "lemma derivs_One: \"derivs xs One \\<in> {Zero, One}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derivs xs One \\<in> {Zero, One}", "by (induction xs) auto"], ["", "lemma derivs_Atom: \"derivs xs (Atom as) \\<in> {Zero, One, Atom as}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derivs xs (Atom as) \\<in> {Zero, One, Atom as}", "proof (induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. derivs [] (Atom as) \\<in> {Zero, One, Atom as}\n 2. \\<And>a xs.\n       derivs xs (Atom as) \\<in> {Zero, One, Atom as} \\<Longrightarrow>\n       derivs (a # xs) (Atom as) \\<in> {Zero, One, Atom as}", "case Cons"], ["proof (state)\nthis:\n  derivs xs_ (Atom as) \\<in> {Zero, One, Atom as}\n\ngoal (2 subgoals):\n 1. derivs [] (Atom as) \\<in> {Zero, One, Atom as}\n 2. \\<And>a xs.\n       derivs xs (Atom as) \\<in> {Zero, One, Atom as} \\<Longrightarrow>\n       derivs (a # xs) (Atom as) \\<in> {Zero, One, Atom as}", "thus ?case"], ["proof (prove)\nusing this:\n  derivs xs_ (Atom as) \\<in> {Zero, One, Atom as}\n\ngoal (1 subgoal):\n 1. derivs (a_ # xs_) (Atom as) \\<in> {Zero, One, Atom as}", "by (auto intro: insertE[OF derivs_One])"], ["proof (state)\nthis:\n  derivs (a_ # xs_) (Atom as) \\<in> {Zero, One, Atom as}\n\ngoal (1 subgoal):\n 1. derivs [] (Atom as) \\<in> {Zero, One, Atom as}", "qed simp"], ["", "lemma derivs_Plus: \"derivs xs (Plus r s) = Plus (derivs xs r) (derivs xs s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derivs xs (Plus r s) = Plus (derivs xs r) (derivs xs s)", "by (induction xs arbitrary: r s) auto"], ["", "lemma derivs_PLUS: \"derivs xs (PLUS ys) = PLUS (map (derivs xs) ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derivs xs (PLUS ys) = PLUS (map (derivs xs) ys)", "by (induction ys rule: list_singleton_induct) (auto simp: derivs_Plus)"], ["", "lemma toplevel_summands_derivs_Times: \"toplevel_summands (derivs xs (Times r s)) \\<subseteq>\n  {Times (derivs xs r) s} \\<union>\n  {r'. \\<exists>ys zs. r' \\<in> toplevel_summands (derivs ys s) \\<and> ys \\<noteq> [] \\<and> zs @ ys = xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toplevel_summands (derivs xs (Times r s))\n    \\<subseteq> {Times (derivs xs r) s} \\<union>\n                {r'.\n                 \\<exists>ys zs.\n                    r' \\<in> toplevel_summands (derivs ys s) \\<and>\n                    ys \\<noteq> [] \\<and> zs @ ys = xs}", "proof (induction xs arbitrary: r s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>r s.\n       toplevel_summands (derivs [] (Times r s))\n       \\<subseteq> {Times (derivs [] r) s} \\<union>\n                   {r'.\n                    \\<exists>ys zs.\n                       r' \\<in> toplevel_summands (derivs ys s) \\<and>\n                       ys \\<noteq> [] \\<and> zs @ ys = []}\n 2. \\<And>a xs r s.\n       (\\<And>r s.\n           toplevel_summands (derivs xs (Times r s))\n           \\<subseteq> {Times (derivs xs r) s} \\<union>\n                       {r'.\n                        \\<exists>ys zs.\n                           r' \\<in> toplevel_summands (derivs ys s) \\<and>\n                           ys \\<noteq> [] \\<and>\n                           zs @ ys = xs}) \\<Longrightarrow>\n       toplevel_summands (derivs (a # xs) (Times r s))\n       \\<subseteq> {Times (derivs (a # xs) r) s} \\<union>\n                   {r'.\n                    \\<exists>ys zs.\n                       r' \\<in> toplevel_summands (derivs ys s) \\<and>\n                       ys \\<noteq> [] \\<and> zs @ ys = a # xs}", "case (Cons x xs)"], ["proof (state)\nthis:\n  toplevel_summands (derivs xs (Times ?r ?s))\n  \\<subseteq> {Times (derivs xs ?r) ?s} \\<union>\n              {r'.\n               \\<exists>ys zs.\n                  r' \\<in> toplevel_summands (derivs ys ?s) \\<and>\n                  ys \\<noteq> [] \\<and> zs @ ys = xs}\n\ngoal (2 subgoals):\n 1. \\<And>r s.\n       toplevel_summands (derivs [] (Times r s))\n       \\<subseteq> {Times (derivs [] r) s} \\<union>\n                   {r'.\n                    \\<exists>ys zs.\n                       r' \\<in> toplevel_summands (derivs ys s) \\<and>\n                       ys \\<noteq> [] \\<and> zs @ ys = []}\n 2. \\<And>a xs r s.\n       (\\<And>r s.\n           toplevel_summands (derivs xs (Times r s))\n           \\<subseteq> {Times (derivs xs r) s} \\<union>\n                       {r'.\n                        \\<exists>ys zs.\n                           r' \\<in> toplevel_summands (derivs ys s) \\<and>\n                           ys \\<noteq> [] \\<and>\n                           zs @ ys = xs}) \\<Longrightarrow>\n       toplevel_summands (derivs (a # xs) (Times r s))\n       \\<subseteq> {Times (derivs (a # xs) r) s} \\<union>\n                   {r'.\n                    \\<exists>ys zs.\n                       r' \\<in> toplevel_summands (derivs ys s) \\<and>\n                       ys \\<noteq> [] \\<and> zs @ ys = a # xs}", "thus ?case"], ["proof (prove)\nusing this:\n  toplevel_summands (derivs xs (Times ?r ?s))\n  \\<subseteq> {Times (derivs xs ?r) ?s} \\<union>\n              {r'.\n               \\<exists>ys zs.\n                  r' \\<in> toplevel_summands (derivs ys ?s) \\<and>\n                  ys \\<noteq> [] \\<and> zs @ ys = xs}\n\ngoal (1 subgoal):\n 1. toplevel_summands (derivs (x # xs) (Times r s))\n    \\<subseteq> {Times (derivs (x # xs) r) s} \\<union>\n                {r'.\n                 \\<exists>ys zs.\n                    r' \\<in> toplevel_summands (derivs ys s) \\<and>\n                    ys \\<noteq> [] \\<and> zs @ ys = x # xs}", "by (auto simp: Let_def derivs_Plus) (fastforce intro: exI[of _ \"x#xs\"])+"], ["proof (state)\nthis:\n  toplevel_summands (derivs (x # xs) (Times r s))\n  \\<subseteq> {Times (derivs (x # xs) r) s} \\<union>\n              {r'.\n               \\<exists>ys zs.\n                  r' \\<in> toplevel_summands (derivs ys s) \\<and>\n                  ys \\<noteq> [] \\<and> zs @ ys = x # xs}\n\ngoal (1 subgoal):\n 1. \\<And>r s.\n       toplevel_summands (derivs [] (Times r s))\n       \\<subseteq> {Times (derivs [] r) s} \\<union>\n                   {r'.\n                    \\<exists>ys zs.\n                       r' \\<in> toplevel_summands (derivs ys s) \\<and>\n                       ys \\<noteq> [] \\<and> zs @ ys = []}", "qed simp"], ["", "lemma toplevel_summands_derivs_Star_nonempty:\n  \"xs \\<noteq> [] \\<Longrightarrow> toplevel_summands (derivs xs (Star r)) \\<subseteq>\n    {Times (derivs ys r) (Star r) | ys. \\<exists>zs. ys \\<noteq> [] \\<and> zs @ ys = xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    toplevel_summands (derivs xs (Star r))\n    \\<subseteq> {Times (derivs ys r) (Star r) |ys.\n                 \\<exists>zs. ys \\<noteq> [] \\<and> zs @ ys = xs}", "proof (induction xs rule: length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   ys \\<noteq> [] \\<longrightarrow>\n                   toplevel_summands (derivs ys (Star r))\n                   \\<subseteq> {Times (derivs ysa r) (Star r) |ysa.\n                                \\<exists>zs.\n                                   ysa \\<noteq> [] \\<and> zs @ ysa = ys};\n        xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> toplevel_summands (derivs xs (Star r))\n                         \\<subseteq> {Times (derivs ys r) (Star r) |ys.\n\\<exists>zs. ys \\<noteq> [] \\<and> zs @ ys = xs}", "case (1 xs)"], ["proof (state)\nthis:\n  \\<forall>ys.\n     length ys < length xs \\<longrightarrow>\n     ys \\<noteq> [] \\<longrightarrow>\n     toplevel_summands (derivs ys (Star r))\n     \\<subseteq> {Times (derivs ysa r) (Star r) |ysa.\n                  \\<exists>zs. ysa \\<noteq> [] \\<and> zs @ ysa = ys}\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   ys \\<noteq> [] \\<longrightarrow>\n                   toplevel_summands (derivs ys (Star r))\n                   \\<subseteq> {Times (derivs ysa r) (Star r) |ysa.\n                                \\<exists>zs.\n                                   ysa \\<noteq> [] \\<and> zs @ ysa = ys};\n        xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> toplevel_summands (derivs xs (Star r))\n                         \\<subseteq> {Times (derivs ys r) (Star r) |ys.\n\\<exists>zs. ys \\<noteq> [] \\<and> zs @ ys = xs}", "then"], ["proof (chain)\npicking this:\n  \\<forall>ys.\n     length ys < length xs \\<longrightarrow>\n     ys \\<noteq> [] \\<longrightarrow>\n     toplevel_summands (derivs ys (Star r))\n     \\<subseteq> {Times (derivs ysa r) (Star r) |ysa.\n                  \\<exists>zs. ysa \\<noteq> [] \\<and> zs @ ysa = ys}\n  xs \\<noteq> []", "obtain y ys where \"xs = y # ys\""], ["proof (prove)\nusing this:\n  \\<forall>ys.\n     length ys < length xs \\<longrightarrow>\n     ys \\<noteq> [] \\<longrightarrow>\n     toplevel_summands (derivs ys (Star r))\n     \\<subseteq> {Times (derivs ysa r) (Star r) |ysa.\n                  \\<exists>zs. ysa \\<noteq> [] \\<and> zs @ ysa = ys}\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>y ys. xs = y # ys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases xs) auto"], ["proof (state)\nthis:\n  xs = y # ys\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   ys \\<noteq> [] \\<longrightarrow>\n                   toplevel_summands (derivs ys (Star r))\n                   \\<subseteq> {Times (derivs ysa r) (Star r) |ysa.\n                                \\<exists>zs.\n                                   ysa \\<noteq> [] \\<and> zs @ ysa = ys};\n        xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> toplevel_summands (derivs xs (Star r))\n                         \\<subseteq> {Times (derivs ys r) (Star r) |ys.\n\\<exists>zs. ys \\<noteq> [] \\<and> zs @ ys = xs}", "thus ?case"], ["proof (prove)\nusing this:\n  xs = y # ys\n\ngoal (1 subgoal):\n 1. toplevel_summands (derivs xs (Star r))\n    \\<subseteq> {Times (derivs ys r) (Star r) |ys.\n                 \\<exists>zs. ys \\<noteq> [] \\<and> zs @ ys = xs}", "using spec[OF 1(1)]"], ["proof (prove)\nusing this:\n  xs = y # ys\n  length ?x < length xs \\<longrightarrow>\n  ?x \\<noteq> [] \\<longrightarrow>\n  toplevel_summands (derivs ?x (Star r))\n  \\<subseteq> {Times (derivs ys r) (Star r) |ys.\n               \\<exists>zs. ys \\<noteq> [] \\<and> zs @ ys = ?x}\n\ngoal (1 subgoal):\n 1. toplevel_summands (derivs xs (Star r))\n    \\<subseteq> {Times (derivs ys r) (Star r) |ys.\n                 \\<exists>zs. ys \\<noteq> [] \\<and> zs @ ys = xs}", "by (auto dest!: subsetD[OF toplevel_summands_derivs_Times] intro: exI[of _ \"y#ys\"])\n       (auto elim!: impE dest!: meta_spec subsetD)"], ["proof (state)\nthis:\n  toplevel_summands (derivs xs (Star r))\n  \\<subseteq> {Times (derivs ys r) (Star r) |ys.\n               \\<exists>zs. ys \\<noteq> [] \\<and> zs @ ys = xs}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma toplevel_summands_derivs_Star:\n  \"toplevel_summands (derivs xs (Star r)) \\<subseteq>\n    {Star r} \\<union> {Times (derivs ys r) (Star r) | ys. \\<exists>zs. ys \\<noteq> [] \\<and> zs @ ys = xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toplevel_summands (derivs xs (Star r))\n    \\<subseteq> {Star r} \\<union>\n                {Times (derivs ys r) (Star r) |ys.\n                 \\<exists>zs. ys \\<noteq> [] \\<and> zs @ ys = xs}", "by (cases \"xs = []\") (auto dest!: toplevel_summands_derivs_Star_nonempty)"], ["", "lemma toplevel_summands_PLUS:\n \"xs \\<noteq> [] \\<Longrightarrow> toplevel_summands (PLUS (map f xs)) = (\\<Union>r \\<in> set xs. toplevel_summands (f r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    toplevel_summands (PLUS (map f xs)) =\n    (\\<Union>r\\<in>set xs. toplevel_summands (f r))", "by (induction xs rule: list_singleton_induct) simp_all"], ["", "lemma ACI_norm_toplevel_summands_Zero: \"toplevel_summands r \\<subseteq> {Zero} \\<Longrightarrow> \\<guillemotleft>r\\<guillemotright> = Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toplevel_summands r \\<subseteq> {Zero} \\<Longrightarrow>\n    \\<guillemotleft>r\\<guillemotright> = Zero", "by (subst ACI_norm_flatten) (auto dest: subset_singletonD)"], ["", "lemma finite_ACI_norm_toplevel_summands:\n  \"finite {f \\<guillemotleft>s\\<guillemotright> |s. toplevel_summands s \\<subseteq> B}\" if \"finite B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {f \\<guillemotleft>s\\<guillemotright> |s.\n      toplevel_summands s \\<subseteq> B}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     {f \\<guillemotleft>s\\<guillemotright> |s.\n      toplevel_summands s \\<subseteq> B}", "have *: \"{f \\<guillemotleft>s\\<guillemotright> | s.\n    toplevel_summands s \\<subseteq> B} \\<subseteq> (f \\<circ> flatten PLUS \\<circ> (`) ACI_norm) ` Pow B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {f \\<guillemotleft>s\\<guillemotright> |s.\n     toplevel_summands s \\<subseteq> B}\n    \\<subseteq> (f \\<circ> flatten PLUS \\<circ> (`) ACI_norm) ` Pow B", "by (subst ACI_norm_flatten) auto"], ["proof (state)\nthis:\n  {f \\<guillemotleft>s\\<guillemotright> |s.\n   toplevel_summands s \\<subseteq> B}\n  \\<subseteq> (f \\<circ> flatten PLUS \\<circ> (`) ACI_norm) ` Pow B\n\ngoal (1 subgoal):\n 1. finite\n     {f \\<guillemotleft>s\\<guillemotright> |s.\n      toplevel_summands s \\<subseteq> B}", "with that"], ["proof (chain)\npicking this:\n  finite B\n  {f \\<guillemotleft>s\\<guillemotright> |s.\n   toplevel_summands s \\<subseteq> B}\n  \\<subseteq> (f \\<circ> flatten PLUS \\<circ> (`) ACI_norm) ` Pow B", "show ?thesis"], ["proof (prove)\nusing this:\n  finite B\n  {f \\<guillemotleft>s\\<guillemotright> |s.\n   toplevel_summands s \\<subseteq> B}\n  \\<subseteq> (f \\<circ> flatten PLUS \\<circ> (`) ACI_norm) ` Pow B\n\ngoal (1 subgoal):\n 1. finite\n     {f \\<guillemotleft>s\\<guillemotright> |s.\n      toplevel_summands s \\<subseteq> B}", "by (rule finite_surj [OF iffD2 [OF finite_Pow_iff]])"], ["proof (state)\nthis:\n  finite\n   {f \\<guillemotleft>s\\<guillemotright> |s.\n    toplevel_summands s \\<subseteq> B}\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem finite_derivs: \"finite {\\<guillemotleft>derivs xs r\\<guillemotright> | xs . True}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {\\<guillemotleft>derivs xs r\\<guillemotright> |xs. True}", "proof (induct r)"], ["proof (state)\ngoal (6 subgoals):\n 1. finite {\\<guillemotleft>derivs xs Zero\\<guillemotright> |xs. True}\n 2. finite {\\<guillemotleft>derivs xs One\\<guillemotright> |xs. True}\n 3. \\<And>x.\n       finite\n        {\\<guillemotleft>derivs xs (Atom x)\\<guillemotright> |xs. True}\n 4. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>derivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>derivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>derivs xs\n      (Plus r1 r2)\\<guillemotright> |\n                           xs. True}\n 5. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>derivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>derivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>derivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 6. \\<And>r.\n       finite\n        {\\<guillemotleft>derivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>derivs xs (Star r)\\<guillemotright> |xs. True}", "case Zero"], ["proof (state)\nthis:\n  \n\ngoal (6 subgoals):\n 1. finite {\\<guillemotleft>derivs xs Zero\\<guillemotright> |xs. True}\n 2. finite {\\<guillemotleft>derivs xs One\\<guillemotright> |xs. True}\n 3. \\<And>x.\n       finite\n        {\\<guillemotleft>derivs xs (Atom x)\\<guillemotright> |xs. True}\n 4. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>derivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>derivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>derivs xs\n      (Plus r1 r2)\\<guillemotright> |\n                           xs. True}\n 5. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>derivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>derivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>derivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 6. \\<And>r.\n       finite\n        {\\<guillemotleft>derivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>derivs xs (Star r)\\<guillemotright> |xs. True}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {\\<guillemotleft>derivs xs Zero\\<guillemotright> |xs. True}", "by simp"], ["proof (state)\nthis:\n  finite {\\<guillemotleft>derivs xs Zero\\<guillemotright> |xs. True}\n\ngoal (5 subgoals):\n 1. finite {\\<guillemotleft>derivs xs One\\<guillemotright> |xs. True}\n 2. \\<And>x.\n       finite\n        {\\<guillemotleft>derivs xs (Atom x)\\<guillemotright> |xs. True}\n 3. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>derivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>derivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>derivs xs\n      (Plus r1 r2)\\<guillemotright> |\n                           xs. True}\n 4. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>derivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>derivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>derivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 5. \\<And>r.\n       finite\n        {\\<guillemotleft>derivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>derivs xs (Star r)\\<guillemotright> |xs. True}", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. finite {\\<guillemotleft>derivs xs One\\<guillemotright> |xs. True}\n 2. \\<And>x.\n       finite\n        {\\<guillemotleft>derivs xs (Atom x)\\<guillemotright> |xs. True}\n 3. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>derivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>derivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>derivs xs\n      (Plus r1 r2)\\<guillemotright> |\n                           xs. True}\n 4. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>derivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>derivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>derivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 5. \\<And>r.\n       finite\n        {\\<guillemotleft>derivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>derivs xs (Star r)\\<guillemotright> |xs. True}", "case One"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. finite {\\<guillemotleft>derivs xs One\\<guillemotright> |xs. True}\n 2. \\<And>x.\n       finite\n        {\\<guillemotleft>derivs xs (Atom x)\\<guillemotright> |xs. True}\n 3. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>derivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>derivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>derivs xs\n      (Plus r1 r2)\\<guillemotright> |\n                           xs. True}\n 4. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>derivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>derivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>derivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 5. \\<And>r.\n       finite\n        {\\<guillemotleft>derivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>derivs xs (Star r)\\<guillemotright> |xs. True}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {\\<guillemotleft>derivs xs One\\<guillemotright> |xs. True}", "by (rule finite_surj[of \"{Zero, One}\"]) (blast intro: insertE[OF derivs_One])+"], ["proof (state)\nthis:\n  finite {\\<guillemotleft>derivs xs One\\<guillemotright> |xs. True}\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       finite\n        {\\<guillemotleft>derivs xs (Atom x)\\<guillemotright> |xs. True}\n 2. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>derivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>derivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>derivs xs\n      (Plus r1 r2)\\<guillemotright> |\n                           xs. True}\n 3. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>derivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>derivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>derivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 4. \\<And>r.\n       finite\n        {\\<guillemotleft>derivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>derivs xs (Star r)\\<guillemotright> |xs. True}", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x.\n       finite\n        {\\<guillemotleft>derivs xs (Atom x)\\<guillemotright> |xs. True}\n 2. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>derivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>derivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>derivs xs\n      (Plus r1 r2)\\<guillemotright> |\n                           xs. True}\n 3. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>derivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>derivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>derivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 4. \\<And>r.\n       finite\n        {\\<guillemotleft>derivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>derivs xs (Star r)\\<guillemotright> |xs. True}", "case (Atom as)"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>x.\n       finite\n        {\\<guillemotleft>derivs xs (Atom x)\\<guillemotright> |xs. True}\n 2. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>derivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>derivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>derivs xs\n      (Plus r1 r2)\\<guillemotright> |\n                           xs. True}\n 3. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>derivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>derivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>derivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 4. \\<And>r.\n       finite\n        {\\<guillemotleft>derivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>derivs xs (Star r)\\<guillemotright> |xs. True}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {\\<guillemotleft>derivs xs (Atom as)\\<guillemotright> |xs. True}", "by (rule finite_surj[of \"{Zero, One, Atom as}\"]) (blast intro: insertE[OF derivs_Atom])+"], ["proof (state)\nthis:\n  finite {\\<guillemotleft>derivs xs (Atom as)\\<guillemotright> |xs. True}\n\ngoal (3 subgoals):\n 1. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>derivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>derivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>derivs xs\n      (Plus r1 r2)\\<guillemotright> |\n                           xs. True}\n 2. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>derivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>derivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>derivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 3. \\<And>r.\n       finite\n        {\\<guillemotleft>derivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>derivs xs (Star r)\\<guillemotright> |xs. True}", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>derivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>derivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>derivs xs\n      (Plus r1 r2)\\<guillemotright> |\n                           xs. True}\n 2. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>derivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>derivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>derivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 3. \\<And>r.\n       finite\n        {\\<guillemotleft>derivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>derivs xs (Star r)\\<guillemotright> |xs. True}", "case (Plus r s)"], ["proof (state)\nthis:\n  finite {\\<guillemotleft>derivs xs r\\<guillemotright> |xs. True}\n  finite {\\<guillemotleft>derivs xs s\\<guillemotright> |xs. True}\n\ngoal (3 subgoals):\n 1. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>derivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>derivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>derivs xs\n      (Plus r1 r2)\\<guillemotright> |\n                           xs. True}\n 2. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>derivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>derivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>derivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 3. \\<And>r.\n       finite\n        {\\<guillemotleft>derivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>derivs xs (Star r)\\<guillemotright> |xs. True}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {\\<guillemotleft>derivs xs (Plus r s)\\<guillemotright> |xs. True}", "by (auto simp: derivs_Plus intro!: finite_surj[OF finite_cartesian_product[OF Plus]])"], ["proof (state)\nthis:\n  finite {\\<guillemotleft>derivs xs (Plus r s)\\<guillemotright> |xs. True}\n\ngoal (2 subgoals):\n 1. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>derivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>derivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>derivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 2. \\<And>r.\n       finite\n        {\\<guillemotleft>derivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>derivs xs (Star r)\\<guillemotright> |xs. True}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>derivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>derivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>derivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 2. \\<And>r.\n       finite\n        {\\<guillemotleft>derivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>derivs xs (Star r)\\<guillemotright> |xs. True}", "case (Times r s)"], ["proof (state)\nthis:\n  finite {\\<guillemotleft>derivs xs r\\<guillemotright> |xs. True}\n  finite {\\<guillemotleft>derivs xs s\\<guillemotright> |xs. True}\n\ngoal (2 subgoals):\n 1. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>derivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>derivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>derivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 2. \\<And>r.\n       finite\n        {\\<guillemotleft>derivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>derivs xs (Star r)\\<guillemotright> |xs. True}", "hence \"finite (\\<Union> (toplevel_summands ` {\\<guillemotleft>derivs xs s\\<guillemotright> | xs . True}))\""], ["proof (prove)\nusing this:\n  finite {\\<guillemotleft>derivs xs r\\<guillemotright> |xs. True}\n  finite {\\<guillemotleft>derivs xs s\\<guillemotright> |xs. True}\n\ngoal (1 subgoal):\n 1. finite\n     (\\<Union>\n       (toplevel_summands `\n        {\\<guillemotleft>derivs xs s\\<guillemotright> |xs. True}))", "by auto"], ["proof (state)\nthis:\n  finite\n   (\\<Union>\n     (toplevel_summands `\n      {\\<guillemotleft>derivs xs s\\<guillemotright> |xs. True}))\n\ngoal (2 subgoals):\n 1. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>derivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>derivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>derivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 2. \\<And>r.\n       finite\n        {\\<guillemotleft>derivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>derivs xs (Star r)\\<guillemotright> |xs. True}", "moreover"], ["proof (state)\nthis:\n  finite\n   (\\<Union>\n     (toplevel_summands `\n      {\\<guillemotleft>derivs xs s\\<guillemotright> |xs. True}))\n\ngoal (2 subgoals):\n 1. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>derivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>derivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>derivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 2. \\<And>r.\n       finite\n        {\\<guillemotleft>derivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>derivs xs (Star r)\\<guillemotright> |xs. True}", "have \"{\\<guillemotleft>r'\\<guillemotright> |r'. \\<exists>ys. r' \\<in> toplevel_summands (derivs ys s)} =\n    {r'. \\<exists>ys. r' \\<in> toplevel_summands \\<guillemotleft>derivs ys s\\<guillemotright>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<guillemotleft>r'\\<guillemotright> |r'.\n     \\<exists>ys. r' \\<in> toplevel_summands (derivs ys s)} =\n    {r'.\n     \\<exists>ys.\n        r' \\<in> toplevel_summands\n                  \\<guillemotleft>derivs ys s\\<guillemotright>}", "by (auto simp: toplevel_summands_ACI_norm)"], ["proof (state)\nthis:\n  {\\<guillemotleft>r'\\<guillemotright> |r'.\n   \\<exists>ys. r' \\<in> toplevel_summands (derivs ys s)} =\n  {r'.\n   \\<exists>ys.\n      r' \\<in> toplevel_summands\n                \\<guillemotleft>derivs ys s\\<guillemotright>}\n\ngoal (2 subgoals):\n 1. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>derivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>derivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>derivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 2. \\<And>r.\n       finite\n        {\\<guillemotleft>derivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>derivs xs (Star r)\\<guillemotright> |xs. True}", "ultimately"], ["proof (chain)\npicking this:\n  finite\n   (\\<Union>\n     (toplevel_summands `\n      {\\<guillemotleft>derivs xs s\\<guillemotright> |xs. True}))\n  {\\<guillemotleft>r'\\<guillemotright> |r'.\n   \\<exists>ys. r' \\<in> toplevel_summands (derivs ys s)} =\n  {r'.\n   \\<exists>ys.\n      r' \\<in> toplevel_summands\n                \\<guillemotleft>derivs ys s\\<guillemotright>}", "have fin: \"finite {\\<guillemotleft>r'\\<guillemotright> |r'. \\<exists>ys. r' \\<in> toplevel_summands (derivs ys s)}\""], ["proof (prove)\nusing this:\n  finite\n   (\\<Union>\n     (toplevel_summands `\n      {\\<guillemotleft>derivs xs s\\<guillemotright> |xs. True}))\n  {\\<guillemotleft>r'\\<guillemotright> |r'.\n   \\<exists>ys. r' \\<in> toplevel_summands (derivs ys s)} =\n  {r'.\n   \\<exists>ys.\n      r' \\<in> toplevel_summands\n                \\<guillemotleft>derivs ys s\\<guillemotright>}\n\ngoal (1 subgoal):\n 1. finite\n     {\\<guillemotleft>r'\\<guillemotright> |r'.\n      \\<exists>ys. r' \\<in> toplevel_summands (derivs ys s)}", "by (fastforce intro: finite_subset[of _ \"\\<Union> (toplevel_summands ` {\\<guillemotleft>derivs xs s\\<guillemotright> | xs . True})\"])"], ["proof (state)\nthis:\n  finite\n   {\\<guillemotleft>r'\\<guillemotright> |r'.\n    \\<exists>ys. r' \\<in> toplevel_summands (derivs ys s)}\n\ngoal (2 subgoals):\n 1. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>derivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>derivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>derivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 2. \\<And>r.\n       finite\n        {\\<guillemotleft>derivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>derivs xs (Star r)\\<guillemotright> |xs. True}", "let ?X = \"\\<lambda>xs. {Times (derivs ys r) s | ys. True} \\<union> {r'. r' \\<in> (\\<Union>ys. toplevel_summands (derivs ys s))}\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>derivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>derivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>derivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 2. \\<And>r.\n       finite\n        {\\<guillemotleft>derivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>derivs xs (Star r)\\<guillemotright> |xs. True}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {\\<guillemotleft>derivs xs (Times r s)\\<guillemotright> |xs. True}", "proof (simp only: ACI_norm_flatten,\n      rule finite_surj[of \"{X. \\<exists>xs. X \\<subseteq> ACI_norm ` ?X xs}\" _ \"flatten PLUS\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. finite\n     {X. \\<exists>xs.\n            X \\<subseteq> ACI_norm `\n                          ({Times (derivs ys r) s |ys. True} \\<union>\n                           {r'.\n                            r' \\<in> (\\<Union>ys.\n   toplevel_summands (derivs ys s))})}\n 2. {flatten PLUS (ACI_norm ` toplevel_summands (derivs xs (Times r s))) |\n     xs. True}\n    \\<subseteq> flatten PLUS `\n                {X. \\<exists>xs.\n                       X \\<subseteq> ACI_norm `\n                                     ({Times (derivs ys r) s |ys.\n True} \\<union>\n{r'. r' \\<in> (\\<Union>ys. toplevel_summands (derivs ys s))})}", "show \"finite {X. \\<exists>xs. X \\<subseteq> ACI_norm ` ?X xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {X. \\<exists>xs.\n            X \\<subseteq> ACI_norm `\n                          ({Times (derivs ys r) s |ys. True} \\<union>\n                           {r'.\n                            r' \\<in> (\\<Union>ys.\n   toplevel_summands (derivs ys s))})}", "using fin"], ["proof (prove)\nusing this:\n  finite\n   {\\<guillemotleft>r'\\<guillemotright> |r'.\n    \\<exists>ys. r' \\<in> toplevel_summands (derivs ys s)}\n\ngoal (1 subgoal):\n 1. finite\n     {X. \\<exists>xs.\n            X \\<subseteq> ACI_norm `\n                          ({Times (derivs ys r) s |ys. True} \\<union>\n                           {r'.\n                            r' \\<in> (\\<Union>ys.\n   toplevel_summands (derivs ys s))})}", "by (fastforce simp: image_Un elim: finite_subset[rotated] intro: finite_surj[OF Times(1), of _ \"\\<lambda>r. Times r \\<guillemotleft>s\\<guillemotright>\"])"], ["proof (state)\nthis:\n  finite\n   {X. \\<exists>xs.\n          X \\<subseteq> ACI_norm `\n                        ({Times (derivs ys r) s |ys. True} \\<union>\n                         {r'.\n                          r' \\<in> (\\<Union>ys.\n toplevel_summands (derivs ys s))})}\n\ngoal (1 subgoal):\n 1. {flatten PLUS (ACI_norm ` toplevel_summands (derivs xs (Times r s))) |\n     xs. True}\n    \\<subseteq> flatten PLUS `\n                {X. \\<exists>xs.\n                       X \\<subseteq> ACI_norm `\n                                     ({Times (derivs ys r) s |ys.\n True} \\<union>\n{r'. r' \\<in> (\\<Union>ys. toplevel_summands (derivs ys s))})}", "qed (fastforce dest!: subsetD[OF toplevel_summands_derivs_Times] intro!: imageI)"], ["proof (state)\nthis:\n  finite {\\<guillemotleft>derivs xs (Times r s)\\<guillemotright> |xs. True}\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       finite\n        {\\<guillemotleft>derivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>derivs xs (Star r)\\<guillemotright> |xs. True}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       finite\n        {\\<guillemotleft>derivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>derivs xs (Star r)\\<guillemotright> |xs. True}", "case (Star r)"], ["proof (state)\nthis:\n  finite {\\<guillemotleft>derivs xs r\\<guillemotright> |xs. True}\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       finite\n        {\\<guillemotleft>derivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>derivs xs (Star r)\\<guillemotright> |xs. True}", "let ?f = \"\\<lambda>f r'. Times r' (Star (f r))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       finite\n        {\\<guillemotleft>derivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>derivs xs (Star r)\\<guillemotright> |xs. True}", "let ?X = \"{Star r} \\<union> ?f id ` {r'. r' \\<in> {derivs ys r|ys. True}}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       finite\n        {\\<guillemotleft>derivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>derivs xs (Star r)\\<guillemotright> |xs. True}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {\\<guillemotleft>derivs xs (Star r)\\<guillemotright> |xs. True}", "proof (simp only: ACI_norm_flatten,\n      rule finite_surj[of \"{X. X \\<subseteq> ACI_norm ` ?X}\" _ \"flatten PLUS\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. finite\n     {X. X \\<subseteq> ACI_norm `\n                       ({Star r} \\<union>\n                        (\\<lambda>r'. Times r' (Star (id r))) `\n                        {r'. r' \\<in> {derivs ys r |ys. True}})}\n 2. {flatten PLUS (ACI_norm ` toplevel_summands (derivs xs (Star r))) |xs.\n     True}\n    \\<subseteq> flatten PLUS `\n                {X. X \\<subseteq> ACI_norm `\n                                  ({Star r} \\<union>\n                                   (\\<lambda>r'. Times r' (Star (id r))) `\n                                   {r'. r' \\<in> {derivs ys r |ys. True}})}", "have *: \"\\<And>X. ACI_norm ` ?f (\\<lambda>x. x) ` X = ?f ACI_norm ` ACI_norm ` X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X.\n       ACI_norm ` (\\<lambda>r'. Times r' (Star r)) ` X =\n       (\\<lambda>r'. Times r' (Star \\<guillemotleft>r\\<guillemotright>)) `\n       ACI_norm ` X", "by (auto simp: image_def)"], ["proof (state)\nthis:\n  ACI_norm ` (\\<lambda>r'. Times r' (Star r)) ` ?X1 =\n  (\\<lambda>r'. Times r' (Star \\<guillemotleft>r\\<guillemotright>)) `\n  ACI_norm ` ?X1\n\ngoal (2 subgoals):\n 1. finite\n     {X. X \\<subseteq> ACI_norm `\n                       ({Star r} \\<union>\n                        (\\<lambda>r'. Times r' (Star (id r))) `\n                        {r'. r' \\<in> {derivs ys r |ys. True}})}\n 2. {flatten PLUS (ACI_norm ` toplevel_summands (derivs xs (Star r))) |xs.\n     True}\n    \\<subseteq> flatten PLUS `\n                {X. X \\<subseteq> ACI_norm `\n                                  ({Star r} \\<union>\n                                   (\\<lambda>r'. Times r' (Star (id r))) `\n                                   {r'. r' \\<in> {derivs ys r |ys. True}})}", "show \"finite {X. X \\<subseteq> ACI_norm ` ?X}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {X. X \\<subseteq> ACI_norm `\n                       ({Star r} \\<union>\n                        (\\<lambda>r'. Times r' (Star (id r))) `\n                        {r'. r' \\<in> {derivs ys r |ys. True}})}", "by (rule finite_Collect_subsets)\n         (auto simp: * intro!: finite_imageI[of _ \"?f ACI_norm\"] intro: finite_subset[OF _ Star])"], ["proof (state)\nthis:\n  finite\n   {X. X \\<subseteq> ACI_norm `\n                     ({Star r} \\<union>\n                      (\\<lambda>r'. Times r' (Star (id r))) `\n                      {r'. r' \\<in> {derivs ys r |ys. True}})}\n\ngoal (1 subgoal):\n 1. {flatten PLUS (ACI_norm ` toplevel_summands (derivs xs (Star r))) |xs.\n     True}\n    \\<subseteq> flatten PLUS `\n                {X. X \\<subseteq> ACI_norm `\n                                  ({Star r} \\<union>\n                                   (\\<lambda>r'. Times r' (Star (id r))) `\n                                   {r'. r' \\<in> {derivs ys r |ys. True}})}", "qed (fastforce dest!: subsetD[OF toplevel_summands_derivs_Star] intro!: imageI)"], ["proof (state)\nthis:\n  finite {\\<guillemotleft>derivs xs (Star r)\\<guillemotright> |xs. True}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Deriving preserves ACI-equivalence\\<close>"], ["", "lemma ACI_norm_PLUS:\n  \"list_all2 (\\<lambda>r s. \\<guillemotleft>r\\<guillemotright> = \\<guillemotleft>s\\<guillemotright>) xs ys \\<Longrightarrow> \\<guillemotleft>PLUS xs\\<guillemotright> = \\<guillemotleft>PLUS ys\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>r s.\n         \\<guillemotleft>r\\<guillemotright> =\n         \\<guillemotleft>s\\<guillemotright>)\n     xs ys \\<Longrightarrow>\n    \\<guillemotleft>PLUS xs\\<guillemotright> =\n    \\<guillemotleft>PLUS ys\\<guillemotright>", "proof (induct rule: list_all2_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<guillemotleft>PLUS []\\<guillemotright> =\n    \\<guillemotleft>PLUS []\\<guillemotright>\n 2. \\<And>x xs y ys.\n       \\<lbrakk>\\<guillemotleft>x\\<guillemotright> =\n                \\<guillemotleft>y\\<guillemotright>;\n        list_all2\n         (\\<lambda>r s.\n             \\<guillemotleft>r\\<guillemotright> =\n             \\<guillemotleft>s\\<guillemotright>)\n         xs ys;\n        \\<guillemotleft>PLUS xs\\<guillemotright> =\n        \\<guillemotleft>PLUS ys\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>PLUS (x # xs)\\<guillemotright> =\n                         \\<guillemotleft>PLUS (y # ys)\\<guillemotright>", "case (Cons x xs y ys)"], ["proof (state)\nthis:\n  \\<guillemotleft>x\\<guillemotright> = \\<guillemotleft>y\\<guillemotright>\n  list_all2\n   (\\<lambda>r s.\n       \\<guillemotleft>r\\<guillemotright> =\n       \\<guillemotleft>s\\<guillemotright>)\n   xs ys\n  \\<guillemotleft>PLUS xs\\<guillemotright> =\n  \\<guillemotleft>PLUS ys\\<guillemotright>\n\ngoal (2 subgoals):\n 1. \\<guillemotleft>PLUS []\\<guillemotright> =\n    \\<guillemotleft>PLUS []\\<guillemotright>\n 2. \\<And>x xs y ys.\n       \\<lbrakk>\\<guillemotleft>x\\<guillemotright> =\n                \\<guillemotleft>y\\<guillemotright>;\n        list_all2\n         (\\<lambda>r s.\n             \\<guillemotleft>r\\<guillemotright> =\n             \\<guillemotleft>s\\<guillemotright>)\n         xs ys;\n        \\<guillemotleft>PLUS xs\\<guillemotright> =\n        \\<guillemotleft>PLUS ys\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>PLUS (x # xs)\\<guillemotright> =\n                         \\<guillemotleft>PLUS (y # ys)\\<guillemotright>", "hence \"length xs = length ys\""], ["proof (prove)\nusing this:\n  \\<guillemotleft>x\\<guillemotright> = \\<guillemotleft>y\\<guillemotright>\n  list_all2\n   (\\<lambda>r s.\n       \\<guillemotleft>r\\<guillemotright> =\n       \\<guillemotleft>s\\<guillemotright>)\n   xs ys\n  \\<guillemotleft>PLUS xs\\<guillemotright> =\n  \\<guillemotleft>PLUS ys\\<guillemotright>\n\ngoal (1 subgoal):\n 1. length xs = length ys", "by (elim list_all2_lengthD)"], ["proof (state)\nthis:\n  length xs = length ys\n\ngoal (2 subgoals):\n 1. \\<guillemotleft>PLUS []\\<guillemotright> =\n    \\<guillemotleft>PLUS []\\<guillemotright>\n 2. \\<And>x xs y ys.\n       \\<lbrakk>\\<guillemotleft>x\\<guillemotright> =\n                \\<guillemotleft>y\\<guillemotright>;\n        list_all2\n         (\\<lambda>r s.\n             \\<guillemotleft>r\\<guillemotright> =\n             \\<guillemotleft>s\\<guillemotright>)\n         xs ys;\n        \\<guillemotleft>PLUS xs\\<guillemotright> =\n        \\<guillemotleft>PLUS ys\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>PLUS (x # xs)\\<guillemotright> =\n                         \\<guillemotleft>PLUS (y # ys)\\<guillemotright>", "thus ?case"], ["proof (prove)\nusing this:\n  length xs = length ys\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>PLUS (x # xs)\\<guillemotright> =\n    \\<guillemotleft>PLUS (y # ys)\\<guillemotright>", "using Cons"], ["proof (prove)\nusing this:\n  length xs = length ys\n  \\<guillemotleft>x\\<guillemotright> = \\<guillemotleft>y\\<guillemotright>\n  list_all2\n   (\\<lambda>r s.\n       \\<guillemotleft>r\\<guillemotright> =\n       \\<guillemotleft>s\\<guillemotright>)\n   xs ys\n  \\<guillemotleft>PLUS xs\\<guillemotright> =\n  \\<guillemotleft>PLUS ys\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>PLUS (x # xs)\\<guillemotright> =\n    \\<guillemotleft>PLUS (y # ys)\\<guillemotright>", "by (induct xs ys rule: list_induct2) auto"], ["proof (state)\nthis:\n  \\<guillemotleft>PLUS (x # xs)\\<guillemotright> =\n  \\<guillemotleft>PLUS (y # ys)\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>PLUS []\\<guillemotright> =\n    \\<guillemotleft>PLUS []\\<guillemotright>", "qed simp"], ["", "lemma toplevel_summands_ACI_norm_deriv:\n  \"(\\<Union>a\\<in>toplevel_summands r. toplevel_summands \\<guillemotleft>deriv as \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) = toplevel_summands \\<guillemotleft>deriv as \\<guillemotleft>r\\<guillemotright>\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>a\\<in>toplevel_summands r.\n        toplevel_summands\n         \\<guillemotleft>deriv as\n                          \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n    toplevel_summands\n     \\<guillemotleft>deriv as\n                      \\<guillemotleft>r\\<guillemotright>\\<guillemotright>", "proof (induct r)"], ["proof (state)\ngoal (6 subgoals):\n 1. (\\<Union>a\\<in>toplevel_summands Zero.\n        toplevel_summands\n         \\<guillemotleft>deriv as\n                          \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n    toplevel_summands\n     \\<guillemotleft>deriv as\n                      \\<guillemotleft>Zero\\<guillemotright>\\<guillemotright>\n 2. (\\<Union>a\\<in>toplevel_summands One.\n        toplevel_summands\n         \\<guillemotleft>deriv as\n                          \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n    toplevel_summands\n     \\<guillemotleft>deriv as\n                      \\<guillemotleft>One\\<guillemotright>\\<guillemotright>\n 3. \\<And>x.\n       (\\<Union>a\\<in>toplevel_summands (Atom x).\n           toplevel_summands\n            \\<guillemotleft>deriv as\n                             \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n       toplevel_summands\n        \\<guillemotleft>deriv as\n                         \\<guillemotleft>Atom\n    x\\<guillemotright>\\<guillemotright>\n 4. \\<And>r1 r2.\n       \\<lbrakk>(\\<Union>a\\<in>toplevel_summands r1.\n                    toplevel_summands\n                     \\<guillemotleft>deriv as\n\\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n                toplevel_summands\n                 \\<guillemotleft>deriv as\n                                  \\<guillemotleft>r1\\<guillemotright>\\<guillemotright>;\n        (\\<Union>a\\<in>toplevel_summands r2.\n            toplevel_summands\n             \\<guillemotleft>deriv as\n                              \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n        toplevel_summands\n         \\<guillemotleft>deriv as\n                          \\<guillemotleft>r2\\<guillemotright>\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> (\\<Union>a\\<in>toplevel_summands (Plus r1 r2).\n                             toplevel_summands\n                              \\<guillemotleft>deriv as\n         \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n                         toplevel_summands\n                          \\<guillemotleft>deriv as\n     \\<guillemotleft>Plus r1 r2\\<guillemotright>\\<guillemotright>\n 5. \\<And>r1 r2.\n       \\<lbrakk>(\\<Union>a\\<in>toplevel_summands r1.\n                    toplevel_summands\n                     \\<guillemotleft>deriv as\n\\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n                toplevel_summands\n                 \\<guillemotleft>deriv as\n                                  \\<guillemotleft>r1\\<guillemotright>\\<guillemotright>;\n        (\\<Union>a\\<in>toplevel_summands r2.\n            toplevel_summands\n             \\<guillemotleft>deriv as\n                              \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n        toplevel_summands\n         \\<guillemotleft>deriv as\n                          \\<guillemotleft>r2\\<guillemotright>\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> (\\<Union>a\\<in>toplevel_summands (Times r1 r2).\n                             toplevel_summands\n                              \\<guillemotleft>deriv as\n         \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n                         toplevel_summands\n                          \\<guillemotleft>deriv as\n     \\<guillemotleft>Times r1 r2\\<guillemotright>\\<guillemotright>\n 6. \\<And>r.\n       (\\<Union>a\\<in>toplevel_summands r.\n           toplevel_summands\n            \\<guillemotleft>deriv as\n                             \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n       toplevel_summands\n        \\<guillemotleft>deriv as\n                         \\<guillemotleft>r\\<guillemotright>\\<guillemotright> \\<Longrightarrow>\n       (\\<Union>a\\<in>toplevel_summands (Star r).\n           toplevel_summands\n            \\<guillemotleft>deriv as\n                             \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n       toplevel_summands\n        \\<guillemotleft>deriv as\n                         \\<guillemotleft>Star\n    r\\<guillemotright>\\<guillemotright>", "case (Plus r1 r2)"], ["proof (state)\nthis:\n  (\\<Union>a\\<in>toplevel_summands r1.\n      toplevel_summands\n       \\<guillemotleft>deriv as\n                        \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n  toplevel_summands\n   \\<guillemotleft>deriv as\n                    \\<guillemotleft>r1\\<guillemotright>\\<guillemotright>\n  (\\<Union>a\\<in>toplevel_summands r2.\n      toplevel_summands\n       \\<guillemotleft>deriv as\n                        \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n  toplevel_summands\n   \\<guillemotleft>deriv as\n                    \\<guillemotleft>r2\\<guillemotright>\\<guillemotright>\n\ngoal (6 subgoals):\n 1. (\\<Union>a\\<in>toplevel_summands Zero.\n        toplevel_summands\n         \\<guillemotleft>deriv as\n                          \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n    toplevel_summands\n     \\<guillemotleft>deriv as\n                      \\<guillemotleft>Zero\\<guillemotright>\\<guillemotright>\n 2. (\\<Union>a\\<in>toplevel_summands One.\n        toplevel_summands\n         \\<guillemotleft>deriv as\n                          \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n    toplevel_summands\n     \\<guillemotleft>deriv as\n                      \\<guillemotleft>One\\<guillemotright>\\<guillemotright>\n 3. \\<And>x.\n       (\\<Union>a\\<in>toplevel_summands (Atom x).\n           toplevel_summands\n            \\<guillemotleft>deriv as\n                             \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n       toplevel_summands\n        \\<guillemotleft>deriv as\n                         \\<guillemotleft>Atom\n    x\\<guillemotright>\\<guillemotright>\n 4. \\<And>r1 r2.\n       \\<lbrakk>(\\<Union>a\\<in>toplevel_summands r1.\n                    toplevel_summands\n                     \\<guillemotleft>deriv as\n\\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n                toplevel_summands\n                 \\<guillemotleft>deriv as\n                                  \\<guillemotleft>r1\\<guillemotright>\\<guillemotright>;\n        (\\<Union>a\\<in>toplevel_summands r2.\n            toplevel_summands\n             \\<guillemotleft>deriv as\n                              \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n        toplevel_summands\n         \\<guillemotleft>deriv as\n                          \\<guillemotleft>r2\\<guillemotright>\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> (\\<Union>a\\<in>toplevel_summands (Plus r1 r2).\n                             toplevel_summands\n                              \\<guillemotleft>deriv as\n         \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n                         toplevel_summands\n                          \\<guillemotleft>deriv as\n     \\<guillemotleft>Plus r1 r2\\<guillemotright>\\<guillemotright>\n 5. \\<And>r1 r2.\n       \\<lbrakk>(\\<Union>a\\<in>toplevel_summands r1.\n                    toplevel_summands\n                     \\<guillemotleft>deriv as\n\\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n                toplevel_summands\n                 \\<guillemotleft>deriv as\n                                  \\<guillemotleft>r1\\<guillemotright>\\<guillemotright>;\n        (\\<Union>a\\<in>toplevel_summands r2.\n            toplevel_summands\n             \\<guillemotleft>deriv as\n                              \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n        toplevel_summands\n         \\<guillemotleft>deriv as\n                          \\<guillemotleft>r2\\<guillemotright>\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> (\\<Union>a\\<in>toplevel_summands (Times r1 r2).\n                             toplevel_summands\n                              \\<guillemotleft>deriv as\n         \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n                         toplevel_summands\n                          \\<guillemotleft>deriv as\n     \\<guillemotleft>Times r1 r2\\<guillemotright>\\<guillemotright>\n 6. \\<And>r.\n       (\\<Union>a\\<in>toplevel_summands r.\n           toplevel_summands\n            \\<guillemotleft>deriv as\n                             \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n       toplevel_summands\n        \\<guillemotleft>deriv as\n                         \\<guillemotleft>r\\<guillemotright>\\<guillemotright> \\<Longrightarrow>\n       (\\<Union>a\\<in>toplevel_summands (Star r).\n           toplevel_summands\n            \\<guillemotleft>deriv as\n                             \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n       toplevel_summands\n        \\<guillemotleft>deriv as\n                         \\<guillemotleft>Star\n    r\\<guillemotright>\\<guillemotright>", "thus ?case"], ["proof (prove)\nusing this:\n  (\\<Union>a\\<in>toplevel_summands r1.\n      toplevel_summands\n       \\<guillemotleft>deriv as\n                        \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n  toplevel_summands\n   \\<guillemotleft>deriv as\n                    \\<guillemotleft>r1\\<guillemotright>\\<guillemotright>\n  (\\<Union>a\\<in>toplevel_summands r2.\n      toplevel_summands\n       \\<guillemotleft>deriv as\n                        \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n  toplevel_summands\n   \\<guillemotleft>deriv as\n                    \\<guillemotleft>r2\\<guillemotright>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. (\\<Union>a\\<in>toplevel_summands (Plus r1 r2).\n        toplevel_summands\n         \\<guillemotleft>deriv as\n                          \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n    toplevel_summands\n     \\<guillemotleft>deriv as\n                      \\<guillemotleft>Plus r1\n r2\\<guillemotright>\\<guillemotright>", "unfolding toplevel_summands.simps toplevel_summands_ACI_norm\n     toplevel_summands_deriv[of as \"\\<guillemotleft>Plus r1 r2\\<guillemotright>\"] image_Un Union_Un_distrib"], ["proof (prove)\nusing this:\n  (\\<Union>a\\<in>toplevel_summands r1.\n      ACI_norm `\n      toplevel_summands (deriv as \\<guillemotleft>a\\<guillemotright>)) =\n  ACI_norm `\n  toplevel_summands (deriv as \\<guillemotleft>r1\\<guillemotright>)\n  (\\<Union>a\\<in>toplevel_summands r2.\n      ACI_norm `\n      toplevel_summands (deriv as \\<guillemotleft>a\\<guillemotright>)) =\n  ACI_norm `\n  toplevel_summands (deriv as \\<guillemotleft>r2\\<guillemotright>)\n\ngoal (1 subgoal):\n 1. (\\<Union>a\\<in>toplevel_summands r1.\n        ACI_norm `\n        toplevel_summands\n         (deriv as \\<guillemotleft>a\\<guillemotright>)) \\<union>\n    (\\<Union>a\\<in>toplevel_summands r2.\n        ACI_norm `\n        toplevel_summands (deriv as \\<guillemotleft>a\\<guillemotright>)) =\n    ACI_norm `\n    (\\<Union>s\\<in>ACI_norm ` toplevel_summands r1.\n        toplevel_summands (deriv as s)) \\<union>\n    ACI_norm `\n    (\\<Union>s\\<in>ACI_norm ` toplevel_summands r2.\n        toplevel_summands (deriv as s))", "by (simp add: image_UN)"], ["proof (state)\nthis:\n  (\\<Union>a\\<in>toplevel_summands (Plus r1 r2).\n      toplevel_summands\n       \\<guillemotleft>deriv as\n                        \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n  toplevel_summands\n   \\<guillemotleft>deriv as\n                    \\<guillemotleft>Plus r1\n                                     r2\\<guillemotright>\\<guillemotright>\n\ngoal (5 subgoals):\n 1. (\\<Union>a\\<in>toplevel_summands Zero.\n        toplevel_summands\n         \\<guillemotleft>deriv as\n                          \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n    toplevel_summands\n     \\<guillemotleft>deriv as\n                      \\<guillemotleft>Zero\\<guillemotright>\\<guillemotright>\n 2. (\\<Union>a\\<in>toplevel_summands One.\n        toplevel_summands\n         \\<guillemotleft>deriv as\n                          \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n    toplevel_summands\n     \\<guillemotleft>deriv as\n                      \\<guillemotleft>One\\<guillemotright>\\<guillemotright>\n 3. \\<And>x.\n       (\\<Union>a\\<in>toplevel_summands (Atom x).\n           toplevel_summands\n            \\<guillemotleft>deriv as\n                             \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n       toplevel_summands\n        \\<guillemotleft>deriv as\n                         \\<guillemotleft>Atom\n    x\\<guillemotright>\\<guillemotright>\n 4. \\<And>r1 r2.\n       \\<lbrakk>(\\<Union>a\\<in>toplevel_summands r1.\n                    toplevel_summands\n                     \\<guillemotleft>deriv as\n\\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n                toplevel_summands\n                 \\<guillemotleft>deriv as\n                                  \\<guillemotleft>r1\\<guillemotright>\\<guillemotright>;\n        (\\<Union>a\\<in>toplevel_summands r2.\n            toplevel_summands\n             \\<guillemotleft>deriv as\n                              \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n        toplevel_summands\n         \\<guillemotleft>deriv as\n                          \\<guillemotleft>r2\\<guillemotright>\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> (\\<Union>a\\<in>toplevel_summands (Times r1 r2).\n                             toplevel_summands\n                              \\<guillemotleft>deriv as\n         \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n                         toplevel_summands\n                          \\<guillemotleft>deriv as\n     \\<guillemotleft>Times r1 r2\\<guillemotright>\\<guillemotright>\n 5. \\<And>r.\n       (\\<Union>a\\<in>toplevel_summands r.\n           toplevel_summands\n            \\<guillemotleft>deriv as\n                             \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n       toplevel_summands\n        \\<guillemotleft>deriv as\n                         \\<guillemotleft>r\\<guillemotright>\\<guillemotright> \\<Longrightarrow>\n       (\\<Union>a\\<in>toplevel_summands (Star r).\n           toplevel_summands\n            \\<guillemotleft>deriv as\n                             \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n       toplevel_summands\n        \\<guillemotleft>deriv as\n                         \\<guillemotleft>Star\n    r\\<guillemotright>\\<guillemotright>", "qed (auto simp: Let_def)"], ["", "lemma toplevel_summands_nullable:\n  \"nullable s = (\\<exists>r\\<in>toplevel_summands s. nullable r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nullable s = (\\<exists>r\\<in>toplevel_summands s. nullable r)", "by (induction s) auto"], ["", "lemma nullable_PLUS:\n  \"nullable (PLUS xs) = (\\<exists>r \\<in> set xs. nullable r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nullable (PLUS xs) = (\\<exists>r\\<in>set xs. nullable r)", "by (induction xs rule: list_singleton_induct) auto"], ["", "theorem ACI_norm_nullable: \"nullable \\<guillemotleft>r\\<guillemotright> = nullable r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nullable \\<guillemotleft>r\\<guillemotright> = nullable r", "proof (induction r)"], ["proof (state)\ngoal (6 subgoals):\n 1. nullable \\<guillemotleft>Zero\\<guillemotright> = nullable Zero\n 2. nullable \\<guillemotleft>One\\<guillemotright> = nullable One\n 3. \\<And>x.\n       nullable \\<guillemotleft>Atom x\\<guillemotright> = nullable (Atom x)\n 4. \\<And>r1 r2.\n       \\<lbrakk>nullable \\<guillemotleft>r1\\<guillemotright> = nullable r1;\n        nullable \\<guillemotleft>r2\\<guillemotright> = nullable r2\\<rbrakk>\n       \\<Longrightarrow> nullable\n                          \\<guillemotleft>Plus r1 r2\\<guillemotright> =\n                         nullable (Plus r1 r2)\n 5. \\<And>r1 r2.\n       \\<lbrakk>nullable \\<guillemotleft>r1\\<guillemotright> = nullable r1;\n        nullable \\<guillemotleft>r2\\<guillemotright> = nullable r2\\<rbrakk>\n       \\<Longrightarrow> nullable\n                          \\<guillemotleft>Times r1 r2\\<guillemotright> =\n                         nullable (Times r1 r2)\n 6. \\<And>r.\n       nullable \\<guillemotleft>r\\<guillemotright> =\n       nullable r \\<Longrightarrow>\n       nullable \\<guillemotleft>Star r\\<guillemotright> = nullable (Star r)", "case (Plus r1 r2)"], ["proof (state)\nthis:\n  nullable \\<guillemotleft>r1\\<guillemotright> = nullable r1\n  nullable \\<guillemotleft>r2\\<guillemotright> = nullable r2\n\ngoal (6 subgoals):\n 1. nullable \\<guillemotleft>Zero\\<guillemotright> = nullable Zero\n 2. nullable \\<guillemotleft>One\\<guillemotright> = nullable One\n 3. \\<And>x.\n       nullable \\<guillemotleft>Atom x\\<guillemotright> = nullable (Atom x)\n 4. \\<And>r1 r2.\n       \\<lbrakk>nullable \\<guillemotleft>r1\\<guillemotright> = nullable r1;\n        nullable \\<guillemotleft>r2\\<guillemotright> = nullable r2\\<rbrakk>\n       \\<Longrightarrow> nullable\n                          \\<guillemotleft>Plus r1 r2\\<guillemotright> =\n                         nullable (Plus r1 r2)\n 5. \\<And>r1 r2.\n       \\<lbrakk>nullable \\<guillemotleft>r1\\<guillemotright> = nullable r1;\n        nullable \\<guillemotleft>r2\\<guillemotright> = nullable r2\\<rbrakk>\n       \\<Longrightarrow> nullable\n                          \\<guillemotleft>Times r1 r2\\<guillemotright> =\n                         nullable (Times r1 r2)\n 6. \\<And>r.\n       nullable \\<guillemotleft>r\\<guillemotright> =\n       nullable r \\<Longrightarrow>\n       nullable \\<guillemotleft>Star r\\<guillemotright> = nullable (Star r)", "thus ?case"], ["proof (prove)\nusing this:\n  nullable \\<guillemotleft>r1\\<guillemotright> = nullable r1\n  nullable \\<guillemotleft>r2\\<guillemotright> = nullable r2\n\ngoal (1 subgoal):\n 1. nullable \\<guillemotleft>Plus r1 r2\\<guillemotright> =\n    nullable (Plus r1 r2)", "using toplevel_summands_nullable"], ["proof (prove)\nusing this:\n  nullable \\<guillemotleft>r1\\<guillemotright> = nullable r1\n  nullable \\<guillemotleft>r2\\<guillemotright> = nullable r2\n  nullable ?s = (\\<exists>r\\<in>toplevel_summands ?s. nullable r)\n\ngoal (1 subgoal):\n 1. nullable \\<guillemotleft>Plus r1 r2\\<guillemotright> =\n    nullable (Plus r1 r2)", "by (auto simp: nullable_PLUS)"], ["proof (state)\nthis:\n  nullable \\<guillemotleft>Plus r1 r2\\<guillemotright> =\n  nullable (Plus r1 r2)\n\ngoal (5 subgoals):\n 1. nullable \\<guillemotleft>Zero\\<guillemotright> = nullable Zero\n 2. nullable \\<guillemotleft>One\\<guillemotright> = nullable One\n 3. \\<And>x.\n       nullable \\<guillemotleft>Atom x\\<guillemotright> = nullable (Atom x)\n 4. \\<And>r1 r2.\n       \\<lbrakk>nullable \\<guillemotleft>r1\\<guillemotright> = nullable r1;\n        nullable \\<guillemotleft>r2\\<guillemotright> = nullable r2\\<rbrakk>\n       \\<Longrightarrow> nullable\n                          \\<guillemotleft>Times r1 r2\\<guillemotright> =\n                         nullable (Times r1 r2)\n 5. \\<And>r.\n       nullable \\<guillemotleft>r\\<guillemotright> =\n       nullable r \\<Longrightarrow>\n       nullable \\<guillemotleft>Star r\\<guillemotright> = nullable (Star r)", "qed auto"], ["", "theorem ACI_norm_deriv: \"\\<guillemotleft>deriv as \\<guillemotleft>r\\<guillemotright>\\<guillemotright> = \\<guillemotleft>deriv as r\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>deriv as\n                     \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>deriv as r\\<guillemotright>", "proof (induction r arbitrary: as)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>as.\n       \\<guillemotleft>deriv as\n                        \\<guillemotleft>Zero\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>deriv as Zero\\<guillemotright>\n 2. \\<And>as.\n       \\<guillemotleft>deriv as\n                        \\<guillemotleft>One\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>deriv as One\\<guillemotright>\n 3. \\<And>x as.\n       \\<guillemotleft>deriv as\n                        \\<guillemotleft>Atom\n   x\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>deriv as (Atom x)\\<guillemotright>\n 4. \\<And>r1 r2 as.\n       \\<lbrakk>\\<And>as.\n                   \\<guillemotleft>deriv as\n                                    \\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                   \\<guillemotleft>deriv as r1\\<guillemotright>;\n        \\<And>as.\n           \\<guillemotleft>deriv as\n                            \\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>deriv as r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>deriv as\n    \\<guillemotleft>Plus r1 r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>deriv as\n    (Plus r1 r2)\\<guillemotright>\n 5. \\<And>r1 r2 as.\n       \\<lbrakk>\\<And>as.\n                   \\<guillemotleft>deriv as\n                                    \\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                   \\<guillemotleft>deriv as r1\\<guillemotright>;\n        \\<And>as.\n           \\<guillemotleft>deriv as\n                            \\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>deriv as r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>deriv as\n    \\<guillemotleft>Times r1 r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>deriv as\n    (Times r1 r2)\\<guillemotright>\n 6. \\<And>r as.\n       (\\<And>as.\n           \\<guillemotleft>deriv as\n                            \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>deriv as r\\<guillemotright>) \\<Longrightarrow>\n       \\<guillemotleft>deriv as\n                        \\<guillemotleft>Star\n   r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>deriv as (Star r)\\<guillemotright>", "case (Plus r1 r2)"], ["proof (state)\nthis:\n  \\<guillemotleft>deriv ?as\n                   \\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>deriv ?as r1\\<guillemotright>\n  \\<guillemotleft>deriv ?as\n                   \\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>deriv ?as r2\\<guillemotright>\n\ngoal (6 subgoals):\n 1. \\<And>as.\n       \\<guillemotleft>deriv as\n                        \\<guillemotleft>Zero\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>deriv as Zero\\<guillemotright>\n 2. \\<And>as.\n       \\<guillemotleft>deriv as\n                        \\<guillemotleft>One\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>deriv as One\\<guillemotright>\n 3. \\<And>x as.\n       \\<guillemotleft>deriv as\n                        \\<guillemotleft>Atom\n   x\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>deriv as (Atom x)\\<guillemotright>\n 4. \\<And>r1 r2 as.\n       \\<lbrakk>\\<And>as.\n                   \\<guillemotleft>deriv as\n                                    \\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                   \\<guillemotleft>deriv as r1\\<guillemotright>;\n        \\<And>as.\n           \\<guillemotleft>deriv as\n                            \\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>deriv as r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>deriv as\n    \\<guillemotleft>Plus r1 r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>deriv as\n    (Plus r1 r2)\\<guillemotright>\n 5. \\<And>r1 r2 as.\n       \\<lbrakk>\\<And>as.\n                   \\<guillemotleft>deriv as\n                                    \\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                   \\<guillemotleft>deriv as r1\\<guillemotright>;\n        \\<And>as.\n           \\<guillemotleft>deriv as\n                            \\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>deriv as r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>deriv as\n    \\<guillemotleft>Times r1 r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>deriv as\n    (Times r1 r2)\\<guillemotright>\n 6. \\<And>r as.\n       (\\<And>as.\n           \\<guillemotleft>deriv as\n                            \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>deriv as r\\<guillemotright>) \\<Longrightarrow>\n       \\<guillemotleft>deriv as\n                        \\<guillemotleft>Star\n   r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>deriv as (Star r)\\<guillemotright>", "thus ?case"], ["proof (prove)\nusing this:\n  \\<guillemotleft>deriv ?as\n                   \\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>deriv ?as r1\\<guillemotright>\n  \\<guillemotleft>deriv ?as\n                   \\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>deriv ?as r2\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>deriv as\n                     \\<guillemotleft>Plus r1\nr2\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>deriv as (Plus r1 r2)\\<guillemotright>", "unfolding deriv.simps ACI_norm_flatten[of \"deriv as \\<guillemotleft>Plus r1 r2\\<guillemotright>\"]\n     toplevel_summands_deriv[of as \"\\<guillemotleft>Plus r1 r2\\<guillemotright>\"] image_Un image_UN"], ["proof (prove)\nusing this:\n  \\<guillemotleft>deriv ?as\n                   \\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>deriv ?as r1\\<guillemotright>\n  \\<guillemotleft>deriv ?as\n                   \\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>deriv ?as r2\\<guillemotright>\n\ngoal (1 subgoal):\n 1. flatten PLUS\n     (\\<Union>x\\<in>toplevel_summands\n                     \\<guillemotleft>Plus r1 r2\\<guillemotright>.\n         ACI_norm ` toplevel_summands (deriv as x)) =\n    \\<guillemotleft>Plus (deriv as r1) (deriv as r2)\\<guillemotright>", "by (auto simp: toplevel_summands_ACI_norm toplevel_summands_flatten_ACI_norm_image_Union)\n     (auto simp: toplevel_summands_ACI_norm[symmetric] toplevel_summands_ACI_norm_deriv)"], ["proof (state)\nthis:\n  \\<guillemotleft>deriv as\n                   \\<guillemotleft>Plus r1\n                                    r2\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>deriv as (Plus r1 r2)\\<guillemotright>\n\ngoal (5 subgoals):\n 1. \\<And>as.\n       \\<guillemotleft>deriv as\n                        \\<guillemotleft>Zero\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>deriv as Zero\\<guillemotright>\n 2. \\<And>as.\n       \\<guillemotleft>deriv as\n                        \\<guillemotleft>One\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>deriv as One\\<guillemotright>\n 3. \\<And>x as.\n       \\<guillemotleft>deriv as\n                        \\<guillemotleft>Atom\n   x\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>deriv as (Atom x)\\<guillemotright>\n 4. \\<And>r1 r2 as.\n       \\<lbrakk>\\<And>as.\n                   \\<guillemotleft>deriv as\n                                    \\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                   \\<guillemotleft>deriv as r1\\<guillemotright>;\n        \\<And>as.\n           \\<guillemotleft>deriv as\n                            \\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>deriv as r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>deriv as\n    \\<guillemotleft>Times r1 r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>deriv as\n    (Times r1 r2)\\<guillemotright>\n 5. \\<And>r as.\n       (\\<And>as.\n           \\<guillemotleft>deriv as\n                            \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>deriv as r\\<guillemotright>) \\<Longrightarrow>\n       \\<guillemotleft>deriv as\n                        \\<guillemotleft>Star\n   r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>deriv as (Star r)\\<guillemotright>", "qed (simp_all add: ACI_norm_nullable)"], ["", "corollary deriv_preserves: \"\\<guillemotleft>r\\<guillemotright> = \\<guillemotleft>s\\<guillemotright> \\<Longrightarrow> \\<guillemotleft>deriv as r\\<guillemotright> = \\<guillemotleft>deriv as s\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>r\\<guillemotright> =\n    \\<guillemotleft>s\\<guillemotright> \\<Longrightarrow>\n    \\<guillemotleft>deriv as r\\<guillemotright> =\n    \\<guillemotleft>deriv as s\\<guillemotright>", "by (rule box_equals[OF _ ACI_norm_deriv ACI_norm_deriv]) (erule arg_cong)"], ["", "lemma derivs_snoc[simp]: \"derivs (xs @ [x]) r = (deriv x (derivs xs r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derivs (xs @ [x]) r = deriv x (derivs xs r)", "by (induction xs arbitrary: r) auto"], ["", "theorem ACI_norm_derivs: \"\\<guillemotleft>derivs xs \\<guillemotleft>r\\<guillemotright>\\<guillemotright> = \\<guillemotleft>derivs xs r\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>derivs xs\n                     \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>derivs xs r\\<guillemotright>", "proof (induction xs arbitrary: r rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<guillemotleft>derivs []\n                        \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>derivs [] r\\<guillemotright>\n 2. \\<And>x xs r.\n       (\\<And>r.\n           \\<guillemotleft>derivs xs\n                            \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>derivs xs r\\<guillemotright>) \\<Longrightarrow>\n       \\<guillemotleft>derivs (xs @ [x])\n                        \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>derivs (xs @ [x]) r\\<guillemotright>", "case (snoc x xs)"], ["proof (state)\nthis:\n  \\<guillemotleft>derivs xs\n                   \\<guillemotleft>?r\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>derivs xs ?r\\<guillemotright>\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<guillemotleft>derivs []\n                        \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>derivs [] r\\<guillemotright>\n 2. \\<And>x xs r.\n       (\\<And>r.\n           \\<guillemotleft>derivs xs\n                            \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>derivs xs r\\<guillemotright>) \\<Longrightarrow>\n       \\<guillemotleft>derivs (xs @ [x])\n                        \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>derivs (xs @ [x]) r\\<guillemotright>", "thus ?case"], ["proof (prove)\nusing this:\n  \\<guillemotleft>derivs xs\n                   \\<guillemotleft>?r\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>derivs xs ?r\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>derivs (xs @ [x])\n                     \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>derivs (xs @ [x]) r\\<guillemotright>", "using ACI_norm_deriv[of x \"derivs xs r\"] ACI_norm_deriv[of x \"derivs xs \\<guillemotleft>r\\<guillemotright>\"]"], ["proof (prove)\nusing this:\n  \\<guillemotleft>derivs xs\n                   \\<guillemotleft>?r\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>derivs xs ?r\\<guillemotright>\n  \\<guillemotleft>deriv x\n                   \\<guillemotleft>derivs xs\n                                    r\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>deriv x (derivs xs r)\\<guillemotright>\n  \\<guillemotleft>deriv x\n                   \\<guillemotleft>derivs xs\n                                    \\<guillemotleft>r\\<guillemotright>\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>deriv x\n                   (derivs xs\n                     \\<guillemotleft>r\\<guillemotright>)\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>derivs (xs @ [x])\n                     \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>derivs (xs @ [x]) r\\<guillemotright>", "by auto"], ["proof (state)\nthis:\n  \\<guillemotleft>derivs (xs @ [x])\n                   \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>derivs (xs @ [x]) r\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<guillemotleft>derivs []\n                        \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>derivs [] r\\<guillemotright>", "qed simp"], ["", "subsection \\<open>Alternative ACI defintions\\<close>"], ["", "text \\<open>Not necessary but conceptually nicer (and seems also to be faster?!)\\<close>"], ["", "fun ACI_nPlus :: \"'a::linorder rexp \\<Rightarrow> 'a rexp \\<Rightarrow> 'a rexp\"\nwhere\n  \"ACI_nPlus (Plus r1 r2) s = ACI_nPlus r1 (ACI_nPlus r2 s)\"\n| \"ACI_nPlus r (Plus s1 s2) =\n  (if r = s1 then Plus s1 s2\n  else if r < s1 then Plus r (Plus s1 s2)\n  else Plus s1 (ACI_nPlus r s2))\"\n| \"ACI_nPlus r s =\n  (if r = s then r\n  else if r < s then Plus r s\n  else Plus s r)\""], ["", "primrec ACI_norm_alt where \n  \"ACI_norm_alt Zero = Zero\"\n| \"ACI_norm_alt One = One\"\n| \"ACI_norm_alt (Atom a) = Atom a\"\n| \"ACI_norm_alt (Plus r s) = ACI_nPlus (ACI_norm_alt r) (ACI_norm_alt s)\"\n| \"ACI_norm_alt (Times r s) = Times (ACI_norm_alt r) (ACI_norm_alt s)\"\n| \"ACI_norm_alt (Star r) = Star (ACI_norm_alt r)\""], ["", "lemma toplevel_summands_ACI_nPlus:\n  \"toplevel_summands (ACI_nPlus r s) = toplevel_summands (Plus r s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toplevel_summands (ACI_nPlus r s) = toplevel_summands (Plus r s)", "by (induct r s rule: ACI_nPlus.induct) auto"], ["", "lemma toplevel_summands_ACI_norm_alt:\n  \"toplevel_summands (ACI_norm_alt r) = ACI_norm_alt ` toplevel_summands r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toplevel_summands (ACI_norm_alt r) = ACI_norm_alt ` toplevel_summands r", "by (induct r) (auto simp: toplevel_summands_ACI_nPlus)"], ["", "lemma ACI_norm_alt_Plus:\n  \"ACI_norm_alt r = Plus s t \\<Longrightarrow> \\<exists>s t. r = Plus s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ACI_norm_alt r = Plus s t \\<Longrightarrow> \\<exists>s t. r = Plus s t", "by (induct r) auto"], ["", "lemma toplevel_summands_flatten_ACI_norm_alt_image:\n  \"toplevel_summands (flatten PLUS (ACI_norm_alt ` toplevel_summands r)) = ACI_norm_alt ` toplevel_summands r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toplevel_summands (flatten PLUS (ACI_norm_alt ` toplevel_summands r)) =\n    ACI_norm_alt ` toplevel_summands r", "by (intro toplevel_summands_flatten) (auto dest!: ACI_norm_alt_Plus intro: Plus_toplevel_summands)"], ["", "lemma ACI_norm_ACI_norm_alt: \"\\<guillemotleft>ACI_norm_alt r\\<guillemotright> = \\<guillemotleft>r\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>ACI_norm_alt r\\<guillemotright> =\n    \\<guillemotleft>r\\<guillemotright>", "proof (induction r)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<guillemotleft>ACI_norm_alt Zero\\<guillemotright> =\n    \\<guillemotleft>Zero\\<guillemotright>\n 2. \\<guillemotleft>ACI_norm_alt One\\<guillemotright> =\n    \\<guillemotleft>One\\<guillemotright>\n 3. \\<And>x.\n       \\<guillemotleft>ACI_norm_alt (Atom x)\\<guillemotright> =\n       \\<guillemotleft>Atom x\\<guillemotright>\n 4. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>ACI_norm_alt r1\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>ACI_norm_alt r2\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>ACI_norm_alt\n    (Plus r1 r2)\\<guillemotright> =\n                         \\<guillemotleft>Plus r1 r2\\<guillemotright>\n 5. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>ACI_norm_alt r1\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>ACI_norm_alt r2\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>ACI_norm_alt\n    (Times r1 r2)\\<guillemotright> =\n                         \\<guillemotleft>Times r1 r2\\<guillemotright>\n 6. \\<And>r.\n       \\<guillemotleft>ACI_norm_alt r\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>ACI_norm_alt (Star r)\\<guillemotright> =\n       \\<guillemotleft>Star r\\<guillemotright>", "case (Plus r s)"], ["proof (state)\nthis:\n  \\<guillemotleft>ACI_norm_alt r\\<guillemotright> =\n  \\<guillemotleft>r\\<guillemotright>\n  \\<guillemotleft>ACI_norm_alt s\\<guillemotright> =\n  \\<guillemotleft>s\\<guillemotright>\n\ngoal (6 subgoals):\n 1. \\<guillemotleft>ACI_norm_alt Zero\\<guillemotright> =\n    \\<guillemotleft>Zero\\<guillemotright>\n 2. \\<guillemotleft>ACI_norm_alt One\\<guillemotright> =\n    \\<guillemotleft>One\\<guillemotright>\n 3. \\<And>x.\n       \\<guillemotleft>ACI_norm_alt (Atom x)\\<guillemotright> =\n       \\<guillemotleft>Atom x\\<guillemotright>\n 4. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>ACI_norm_alt r1\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>ACI_norm_alt r2\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>ACI_norm_alt\n    (Plus r1 r2)\\<guillemotright> =\n                         \\<guillemotleft>Plus r1 r2\\<guillemotright>\n 5. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>ACI_norm_alt r1\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>ACI_norm_alt r2\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>ACI_norm_alt\n    (Times r1 r2)\\<guillemotright> =\n                         \\<guillemotleft>Times r1 r2\\<guillemotright>\n 6. \\<And>r.\n       \\<guillemotleft>ACI_norm_alt r\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>ACI_norm_alt (Star r)\\<guillemotright> =\n       \\<guillemotleft>Star r\\<guillemotright>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>ACI_norm_alt (Plus r s)\\<guillemotright> =\n    \\<guillemotleft>Plus r s\\<guillemotright>", "using ACI_norm_flatten [of r] ACI_norm_flatten [of s]"], ["proof (prove)\nusing this:\n  \\<guillemotleft>r\\<guillemotright> =\n  flatten PLUS (ACI_norm ` toplevel_summands r)\n  \\<guillemotleft>s\\<guillemotright> =\n  flatten PLUS (ACI_norm ` toplevel_summands s)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>ACI_norm_alt (Plus r s)\\<guillemotright> =\n    \\<guillemotleft>Plus r s\\<guillemotright>", "by (auto simp add: toplevel_summands_ACI_nPlus)\n      (metis ACI_norm_flatten Plus.IH(1) Plus.IH(2) image_Un toplevel_summands.simps(1) toplevel_summands_ACI_nPlus toplevel_summands_ACI_norm)"], ["proof (state)\nthis:\n  \\<guillemotleft>ACI_norm_alt (Plus r s)\\<guillemotright> =\n  \\<guillemotleft>Plus r s\\<guillemotright>\n\ngoal (5 subgoals):\n 1. \\<guillemotleft>ACI_norm_alt Zero\\<guillemotright> =\n    \\<guillemotleft>Zero\\<guillemotright>\n 2. \\<guillemotleft>ACI_norm_alt One\\<guillemotright> =\n    \\<guillemotleft>One\\<guillemotright>\n 3. \\<And>x.\n       \\<guillemotleft>ACI_norm_alt (Atom x)\\<guillemotright> =\n       \\<guillemotleft>Atom x\\<guillemotright>\n 4. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>ACI_norm_alt r1\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>ACI_norm_alt r2\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>ACI_norm_alt\n    (Times r1 r2)\\<guillemotright> =\n                         \\<guillemotleft>Times r1 r2\\<guillemotright>\n 5. \\<And>r.\n       \\<guillemotleft>ACI_norm_alt r\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>ACI_norm_alt (Star r)\\<guillemotright> =\n       \\<guillemotleft>Star r\\<guillemotright>", "qed auto"], ["", "lemma ACI_nPlus_singleton_PLUS: \n  \"\\<lbrakk>xs \\<noteq> []; sorted xs; distinct xs; \\<forall>x \\<in> {x} \\<union> set xs. \\<not>(\\<exists>r s. x = Plus r s)\\<rbrakk> \\<Longrightarrow>\n  ACI_nPlus x (PLUS xs) = (if x \\<in> set xs then PLUS xs else PLUS (insort x xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> []; sorted xs; distinct xs;\n     \\<forall>x\\<in>{x} \\<union> set xs.\n        \\<nexists>r s. x = Plus r s\\<rbrakk>\n    \\<Longrightarrow> ACI_nPlus x (PLUS xs) =\n                      (if x \\<in> set xs then PLUS xs\n                       else PLUS (insort x xs))", "proof (induct xs rule: list_singleton_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>[] \\<noteq> []; sorted []; distinct [];\n     \\<forall>x\\<in>{x} \\<union> set [].\n        \\<nexists>r s. x = Plus r s\\<rbrakk>\n    \\<Longrightarrow> ACI_nPlus x (PLUS []) =\n                      (if x \\<in> set [] then PLUS []\n                       else PLUS (insort x []))\n 2. \\<And>xa.\n       \\<lbrakk>[xa] \\<noteq> []; sorted [xa]; distinct [xa];\n        \\<forall>x\\<in>{x} \\<union> set [xa].\n           \\<nexists>r s. x = Plus r s\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus x (PLUS [xa]) =\n                         (if x \\<in> set [xa] then PLUS [xa]\n                          else PLUS (insort x [xa]))\n 3. \\<And>xa y xs.\n       \\<lbrakk>\\<lbrakk>y # xs \\<noteq> []; sorted (y # xs);\n                 distinct (y # xs);\n                 \\<forall>x\\<in>{x} \\<union> set (y # xs).\n                    \\<nexists>r s. x = Plus r s\\<rbrakk>\n                \\<Longrightarrow> ACI_nPlus x (PLUS (y # xs)) =\n                                  (if x \\<in> set (y # xs)\n                                   then PLUS (y # xs)\n                                   else PLUS (insort x (y # xs)));\n        xa # y # xs \\<noteq> []; sorted (xa # y # xs);\n        distinct (xa # y # xs);\n        \\<forall>x\\<in>{x} \\<union> set (xa # y # xs).\n           \\<nexists>r s. x = Plus r s\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus x (PLUS (xa # y # xs)) =\n                         (if x \\<in> set (xa # y # xs)\n                          then PLUS (xa # y # xs)\n                          else PLUS (insort x (xa # y # xs)))", "case (single y)"], ["proof (state)\nthis:\n  [y] \\<noteq> []\n  sorted [y]\n  distinct [y]\n  \\<forall>x\\<in>{x} \\<union> set [y]. \\<nexists>r s. x = Plus r s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>[] \\<noteq> []; sorted []; distinct [];\n     \\<forall>x\\<in>{x} \\<union> set [].\n        \\<nexists>r s. x = Plus r s\\<rbrakk>\n    \\<Longrightarrow> ACI_nPlus x (PLUS []) =\n                      (if x \\<in> set [] then PLUS []\n                       else PLUS (insort x []))\n 2. \\<And>xa.\n       \\<lbrakk>[xa] \\<noteq> []; sorted [xa]; distinct [xa];\n        \\<forall>x\\<in>{x} \\<union> set [xa].\n           \\<nexists>r s. x = Plus r s\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus x (PLUS [xa]) =\n                         (if x \\<in> set [xa] then PLUS [xa]\n                          else PLUS (insort x [xa]))\n 3. \\<And>xa y xs.\n       \\<lbrakk>\\<lbrakk>y # xs \\<noteq> []; sorted (y # xs);\n                 distinct (y # xs);\n                 \\<forall>x\\<in>{x} \\<union> set (y # xs).\n                    \\<nexists>r s. x = Plus r s\\<rbrakk>\n                \\<Longrightarrow> ACI_nPlus x (PLUS (y # xs)) =\n                                  (if x \\<in> set (y # xs)\n                                   then PLUS (y # xs)\n                                   else PLUS (insort x (y # xs)));\n        xa # y # xs \\<noteq> []; sorted (xa # y # xs);\n        distinct (xa # y # xs);\n        \\<forall>x\\<in>{x} \\<union> set (xa # y # xs).\n           \\<nexists>r s. x = Plus r s\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus x (PLUS (xa # y # xs)) =\n                         (if x \\<in> set (xa # y # xs)\n                          then PLUS (xa # y # xs)\n                          else PLUS (insort x (xa # y # xs)))", "thus ?case"], ["proof (prove)\nusing this:\n  [y] \\<noteq> []\n  sorted [y]\n  distinct [y]\n  \\<forall>x\\<in>{x} \\<union> set [y]. \\<nexists>r s. x = Plus r s\n\ngoal (1 subgoal):\n 1. ACI_nPlus x (PLUS [y]) =\n    (if x \\<in> set [y] then PLUS [y] else PLUS (insort x [y]))", "by (cases x y rule: linorder_cases) (induct x y rule: ACI_nPlus.induct, auto)+"], ["proof (state)\nthis:\n  ACI_nPlus x (PLUS [y]) =\n  (if x \\<in> set [y] then PLUS [y] else PLUS (insort x [y]))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<noteq> []; sorted []; distinct [];\n     \\<forall>x\\<in>{x} \\<union> set [].\n        \\<nexists>r s. x = Plus r s\\<rbrakk>\n    \\<Longrightarrow> ACI_nPlus x (PLUS []) =\n                      (if x \\<in> set [] then PLUS []\n                       else PLUS (insort x []))\n 2. \\<And>xa y xs.\n       \\<lbrakk>\\<lbrakk>y # xs \\<noteq> []; sorted (y # xs);\n                 distinct (y # xs);\n                 \\<forall>x\\<in>{x} \\<union> set (y # xs).\n                    \\<nexists>r s. x = Plus r s\\<rbrakk>\n                \\<Longrightarrow> ACI_nPlus x (PLUS (y # xs)) =\n                                  (if x \\<in> set (y # xs)\n                                   then PLUS (y # xs)\n                                   else PLUS (insort x (y # xs)));\n        xa # y # xs \\<noteq> []; sorted (xa # y # xs);\n        distinct (xa # y # xs);\n        \\<forall>x\\<in>{x} \\<union> set (xa # y # xs).\n           \\<nexists>r s. x = Plus r s\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus x (PLUS (xa # y # xs)) =\n                         (if x \\<in> set (xa # y # xs)\n                          then PLUS (xa # y # xs)\n                          else PLUS (insort x (xa # y # xs)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<noteq> []; sorted []; distinct [];\n     \\<forall>x\\<in>{x} \\<union> set [].\n        \\<nexists>r s. x = Plus r s\\<rbrakk>\n    \\<Longrightarrow> ACI_nPlus x (PLUS []) =\n                      (if x \\<in> set [] then PLUS []\n                       else PLUS (insort x []))\n 2. \\<And>xa y xs.\n       \\<lbrakk>\\<lbrakk>y # xs \\<noteq> []; sorted (y # xs);\n                 distinct (y # xs);\n                 \\<forall>x\\<in>{x} \\<union> set (y # xs).\n                    \\<nexists>r s. x = Plus r s\\<rbrakk>\n                \\<Longrightarrow> ACI_nPlus x (PLUS (y # xs)) =\n                                  (if x \\<in> set (y # xs)\n                                   then PLUS (y # xs)\n                                   else PLUS (insort x (y # xs)));\n        xa # y # xs \\<noteq> []; sorted (xa # y # xs);\n        distinct (xa # y # xs);\n        \\<forall>x\\<in>{x} \\<union> set (xa # y # xs).\n           \\<nexists>r s. x = Plus r s\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus x (PLUS (xa # y # xs)) =\n                         (if x \\<in> set (xa # y # xs)\n                          then PLUS (xa # y # xs)\n                          else PLUS (insort x (xa # y # xs)))", "case (cons y1 y2 ys)"], ["proof (state)\nthis:\n  \\<lbrakk>y2 # ys \\<noteq> []; sorted (y2 # ys); distinct (y2 # ys);\n   \\<forall>x\\<in>{x} \\<union> set (y2 # ys).\n      \\<nexists>r s. x = Plus r s\\<rbrakk>\n  \\<Longrightarrow> ACI_nPlus x (PLUS (y2 # ys)) =\n                    (if x \\<in> set (y2 # ys) then PLUS (y2 # ys)\n                     else PLUS (insort x (y2 # ys)))\n  y1 # y2 # ys \\<noteq> []\n  sorted (y1 # y2 # ys)\n  distinct (y1 # y2 # ys)\n  \\<forall>x\\<in>{x} \\<union> set (y1 # y2 # ys).\n     \\<nexists>r s. x = Plus r s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<noteq> []; sorted []; distinct [];\n     \\<forall>x\\<in>{x} \\<union> set [].\n        \\<nexists>r s. x = Plus r s\\<rbrakk>\n    \\<Longrightarrow> ACI_nPlus x (PLUS []) =\n                      (if x \\<in> set [] then PLUS []\n                       else PLUS (insort x []))\n 2. \\<And>xa y xs.\n       \\<lbrakk>\\<lbrakk>y # xs \\<noteq> []; sorted (y # xs);\n                 distinct (y # xs);\n                 \\<forall>x\\<in>{x} \\<union> set (y # xs).\n                    \\<nexists>r s. x = Plus r s\\<rbrakk>\n                \\<Longrightarrow> ACI_nPlus x (PLUS (y # xs)) =\n                                  (if x \\<in> set (y # xs)\n                                   then PLUS (y # xs)\n                                   else PLUS (insort x (y # xs)));\n        xa # y # xs \\<noteq> []; sorted (xa # y # xs);\n        distinct (xa # y # xs);\n        \\<forall>x\\<in>{x} \\<union> set (xa # y # xs).\n           \\<nexists>r s. x = Plus r s\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus x (PLUS (xa # y # xs)) =\n                         (if x \\<in> set (xa # y # xs)\n                          then PLUS (xa # y # xs)\n                          else PLUS (insort x (xa # y # xs)))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>y2 # ys \\<noteq> []; sorted (y2 # ys); distinct (y2 # ys);\n   \\<forall>x\\<in>{x} \\<union> set (y2 # ys).\n      \\<nexists>r s. x = Plus r s\\<rbrakk>\n  \\<Longrightarrow> ACI_nPlus x (PLUS (y2 # ys)) =\n                    (if x \\<in> set (y2 # ys) then PLUS (y2 # ys)\n                     else PLUS (insort x (y2 # ys)))\n  y1 # y2 # ys \\<noteq> []\n  sorted (y1 # y2 # ys)\n  distinct (y1 # y2 # ys)\n  \\<forall>x\\<in>{x} \\<union> set (y1 # y2 # ys).\n     \\<nexists>r s. x = Plus r s\n\ngoal (1 subgoal):\n 1. ACI_nPlus x (PLUS (y1 # y2 # ys)) =\n    (if x \\<in> set (y1 # y2 # ys) then PLUS (y1 # y2 # ys)\n     else PLUS (insort x (y1 # y2 # ys)))", "by (cases x) (auto)"], ["proof (state)\nthis:\n  ACI_nPlus x (PLUS (y1 # y2 # ys)) =\n  (if x \\<in> set (y1 # y2 # ys) then PLUS (y1 # y2 # ys)\n   else PLUS (insort x (y1 # y2 # ys)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>[] \\<noteq> []; sorted []; distinct [];\n     \\<forall>x\\<in>{x} \\<union> set [].\n        \\<nexists>r s. x = Plus r s\\<rbrakk>\n    \\<Longrightarrow> ACI_nPlus x (PLUS []) =\n                      (if x \\<in> set [] then PLUS []\n                       else PLUS (insort x []))", "qed simp"], ["", "lemma ACI_nPlus_PLUS:\n  \"\\<lbrakk>xs1 \\<noteq> []; xs2 \\<noteq> []; \\<forall>x \\<in> set (xs1 @ xs2). \\<not>(\\<exists>r s. x = Plus r s); sorted xs2; distinct xs2\\<rbrakk>\\<Longrightarrow>\n  ACI_nPlus (PLUS xs1) (PLUS xs2) = flatten PLUS (set (xs1 @ xs2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs1 \\<noteq> []; xs2 \\<noteq> [];\n     \\<forall>x\\<in>set (xs1 @ xs2). \\<nexists>r s. x = Plus r s;\n     sorted xs2; distinct xs2\\<rbrakk>\n    \\<Longrightarrow> ACI_nPlus (PLUS xs1) (PLUS xs2) =\n                      flatten PLUS (set (xs1 @ xs2))", "proof (induct xs1 arbitrary: xs2 rule: list_singleton_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xs2.\n       \\<lbrakk>[] \\<noteq> []; xs2 \\<noteq> [];\n        \\<forall>x\\<in>set ([] @ xs2). \\<nexists>r s. x = Plus r s;\n        sorted xs2; distinct xs2\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus (PLUS []) (PLUS xs2) =\n                         flatten PLUS (set ([] @ xs2))\n 2. \\<And>x xs2.\n       \\<lbrakk>[x] \\<noteq> []; xs2 \\<noteq> [];\n        \\<forall>x\\<in>set ([x] @ xs2). \\<nexists>r s. x = Plus r s;\n        sorted xs2; distinct xs2\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus (PLUS [x]) (PLUS xs2) =\n                         flatten PLUS (set ([x] @ xs2))\n 3. \\<And>x y xs xs2.\n       \\<lbrakk>\\<And>xs2.\n                   \\<lbrakk>y # xs \\<noteq> []; xs2 \\<noteq> [];\n                    \\<forall>x\\<in>set ((y # xs) @ xs2).\n                       \\<nexists>r s. x = Plus r s;\n                    sorted xs2; distinct xs2\\<rbrakk>\n                   \\<Longrightarrow> ACI_nPlus (PLUS (y # xs)) (PLUS xs2) =\n                                     flatten PLUS (set ((y # xs) @ xs2));\n        x # y # xs \\<noteq> []; xs2 \\<noteq> [];\n        \\<forall>x\\<in>set ((x # y # xs) @ xs2).\n           \\<nexists>r s. x = Plus r s;\n        sorted xs2; distinct xs2\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus (PLUS (x # y # xs)) (PLUS xs2) =\n                         flatten PLUS (set ((x # y # xs) @ xs2))", "case (single x1)"], ["proof (state)\nthis:\n  [x1] \\<noteq> []\n  xs2 \\<noteq> []\n  \\<forall>x\\<in>set ([x1] @ xs2). \\<nexists>r s. x = Plus r s\n  sorted xs2\n  distinct xs2\n\ngoal (3 subgoals):\n 1. \\<And>xs2.\n       \\<lbrakk>[] \\<noteq> []; xs2 \\<noteq> [];\n        \\<forall>x\\<in>set ([] @ xs2). \\<nexists>r s. x = Plus r s;\n        sorted xs2; distinct xs2\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus (PLUS []) (PLUS xs2) =\n                         flatten PLUS (set ([] @ xs2))\n 2. \\<And>x xs2.\n       \\<lbrakk>[x] \\<noteq> []; xs2 \\<noteq> [];\n        \\<forall>x\\<in>set ([x] @ xs2). \\<nexists>r s. x = Plus r s;\n        sorted xs2; distinct xs2\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus (PLUS [x]) (PLUS xs2) =\n                         flatten PLUS (set ([x] @ xs2))\n 3. \\<And>x y xs xs2.\n       \\<lbrakk>\\<And>xs2.\n                   \\<lbrakk>y # xs \\<noteq> []; xs2 \\<noteq> [];\n                    \\<forall>x\\<in>set ((y # xs) @ xs2).\n                       \\<nexists>r s. x = Plus r s;\n                    sorted xs2; distinct xs2\\<rbrakk>\n                   \\<Longrightarrow> ACI_nPlus (PLUS (y # xs)) (PLUS xs2) =\n                                     flatten PLUS (set ((y # xs) @ xs2));\n        x # y # xs \\<noteq> []; xs2 \\<noteq> [];\n        \\<forall>x\\<in>set ((x # y # xs) @ xs2).\n           \\<nexists>r s. x = Plus r s;\n        sorted xs2; distinct xs2\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus (PLUS (x # y # xs)) (PLUS xs2) =\n                         flatten PLUS (set ((x # y # xs) @ xs2))", "thus ?case"], ["proof (prove)\nusing this:\n  [x1] \\<noteq> []\n  xs2 \\<noteq> []\n  \\<forall>x\\<in>set ([x1] @ xs2). \\<nexists>r s. x = Plus r s\n  sorted xs2\n  distinct xs2\n\ngoal (1 subgoal):\n 1. ACI_nPlus (PLUS [x1]) (PLUS xs2) = flatten PLUS (set ([x1] @ xs2))", "apply (auto intro!: trans[OF ACI_nPlus_singleton_PLUS] simp del: sorted_list_of_set_insert)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>xs2 \\<noteq> []; sorted xs2; distinct xs2;\n     \\<forall>x\\<in>set xs2. \\<forall>r s. x \\<noteq> Plus r s;\n     x1 \\<in> set xs2\\<rbrakk>\n    \\<Longrightarrow> PLUS xs2 = flatten PLUS (insert x1 (set xs2))\n 2. \\<lbrakk>xs2 \\<noteq> []; sorted xs2; distinct xs2;\n     \\<forall>r s. x1 \\<noteq> Plus r s;\n     \\<forall>x\\<in>set xs2. \\<forall>r s. x \\<noteq> Plus r s;\n     x1 \\<notin> set xs2\\<rbrakk>\n    \\<Longrightarrow> PLUS (insort x1 xs2) =\n                      PLUS (flatten (insort x1) (set xs2))", "apply (simp only: insert_absorb)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>xs2 \\<noteq> []; sorted xs2; distinct xs2;\n     \\<forall>x\\<in>set xs2. \\<forall>r s. x \\<noteq> Plus r s;\n     x1 \\<in> set xs2\\<rbrakk>\n    \\<Longrightarrow> PLUS xs2 = flatten PLUS (set xs2)\n 2. \\<lbrakk>xs2 \\<noteq> []; sorted xs2; distinct xs2;\n     \\<forall>r s. x1 \\<noteq> Plus r s;\n     \\<forall>x\\<in>set xs2. \\<forall>r s. x \\<noteq> Plus r s;\n     x1 \\<notin> set xs2\\<rbrakk>\n    \\<Longrightarrow> PLUS (insort x1 xs2) =\n                      PLUS (flatten (insort x1) (set xs2))", "apply (metis List.finite_set finite_sorted_distinct_unique sorted_list_of_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs2 \\<noteq> []; sorted xs2; distinct xs2;\n     \\<forall>r s. x1 \\<noteq> Plus r s;\n     \\<forall>x\\<in>set xs2. \\<forall>r s. x \\<noteq> Plus r s;\n     x1 \\<notin> set xs2\\<rbrakk>\n    \\<Longrightarrow> PLUS (insort x1 xs2) =\n                      PLUS (flatten (insort x1) (set xs2))", "apply (rule arg_cong[of _ _ PLUS])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs2 \\<noteq> []; sorted xs2; distinct xs2;\n     \\<forall>r s. x1 \\<noteq> Plus r s;\n     \\<forall>x\\<in>set xs2. \\<forall>r s. x \\<noteq> Plus r s;\n     x1 \\<notin> set xs2\\<rbrakk>\n    \\<Longrightarrow> insort x1 xs2 = flatten (insort x1) (set xs2)", "apply (metis remdups_id_iff_distinct sorted_list_of_set_sort_remdups sorted_sort_id)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ACI_nPlus (PLUS [x1]) (PLUS xs2) = flatten PLUS (set ([x1] @ xs2))\n\ngoal (2 subgoals):\n 1. \\<And>xs2.\n       \\<lbrakk>[] \\<noteq> []; xs2 \\<noteq> [];\n        \\<forall>x\\<in>set ([] @ xs2). \\<nexists>r s. x = Plus r s;\n        sorted xs2; distinct xs2\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus (PLUS []) (PLUS xs2) =\n                         flatten PLUS (set ([] @ xs2))\n 2. \\<And>x y xs xs2.\n       \\<lbrakk>\\<And>xs2.\n                   \\<lbrakk>y # xs \\<noteq> []; xs2 \\<noteq> [];\n                    \\<forall>x\\<in>set ((y # xs) @ xs2).\n                       \\<nexists>r s. x = Plus r s;\n                    sorted xs2; distinct xs2\\<rbrakk>\n                   \\<Longrightarrow> ACI_nPlus (PLUS (y # xs)) (PLUS xs2) =\n                                     flatten PLUS (set ((y # xs) @ xs2));\n        x # y # xs \\<noteq> []; xs2 \\<noteq> [];\n        \\<forall>x\\<in>set ((x # y # xs) @ xs2).\n           \\<nexists>r s. x = Plus r s;\n        sorted xs2; distinct xs2\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus (PLUS (x # y # xs)) (PLUS xs2) =\n                         flatten PLUS (set ((x # y # xs) @ xs2))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs2.\n       \\<lbrakk>[] \\<noteq> []; xs2 \\<noteq> [];\n        \\<forall>x\\<in>set ([] @ xs2). \\<nexists>r s. x = Plus r s;\n        sorted xs2; distinct xs2\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus (PLUS []) (PLUS xs2) =\n                         flatten PLUS (set ([] @ xs2))\n 2. \\<And>x y xs xs2.\n       \\<lbrakk>\\<And>xs2.\n                   \\<lbrakk>y # xs \\<noteq> []; xs2 \\<noteq> [];\n                    \\<forall>x\\<in>set ((y # xs) @ xs2).\n                       \\<nexists>r s. x = Plus r s;\n                    sorted xs2; distinct xs2\\<rbrakk>\n                   \\<Longrightarrow> ACI_nPlus (PLUS (y # xs)) (PLUS xs2) =\n                                     flatten PLUS (set ((y # xs) @ xs2));\n        x # y # xs \\<noteq> []; xs2 \\<noteq> [];\n        \\<forall>x\\<in>set ((x # y # xs) @ xs2).\n           \\<nexists>r s. x = Plus r s;\n        sorted xs2; distinct xs2\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus (PLUS (x # y # xs)) (PLUS xs2) =\n                         flatten PLUS (set ((x # y # xs) @ xs2))", "case (cons x11 x12 xs1)"], ["proof (state)\nthis:\n  \\<lbrakk>x12 # xs1 \\<noteq> []; ?xs2.0 \\<noteq> [];\n   \\<forall>x\\<in>set ((x12 # xs1) @ ?xs2.0). \\<nexists>r s. x = Plus r s;\n   sorted ?xs2.0; distinct ?xs2.0\\<rbrakk>\n  \\<Longrightarrow> ACI_nPlus (PLUS (x12 # xs1)) (PLUS ?xs2.0) =\n                    flatten PLUS (set ((x12 # xs1) @ ?xs2.0))\n  x11 # x12 # xs1 \\<noteq> []\n  xs2 \\<noteq> []\n  \\<forall>x\\<in>set ((x11 # x12 # xs1) @ xs2). \\<nexists>r s. x = Plus r s\n  sorted xs2\n  distinct xs2\n\ngoal (2 subgoals):\n 1. \\<And>xs2.\n       \\<lbrakk>[] \\<noteq> []; xs2 \\<noteq> [];\n        \\<forall>x\\<in>set ([] @ xs2). \\<nexists>r s. x = Plus r s;\n        sorted xs2; distinct xs2\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus (PLUS []) (PLUS xs2) =\n                         flatten PLUS (set ([] @ xs2))\n 2. \\<And>x y xs xs2.\n       \\<lbrakk>\\<And>xs2.\n                   \\<lbrakk>y # xs \\<noteq> []; xs2 \\<noteq> [];\n                    \\<forall>x\\<in>set ((y # xs) @ xs2).\n                       \\<nexists>r s. x = Plus r s;\n                    sorted xs2; distinct xs2\\<rbrakk>\n                   \\<Longrightarrow> ACI_nPlus (PLUS (y # xs)) (PLUS xs2) =\n                                     flatten PLUS (set ((y # xs) @ xs2));\n        x # y # xs \\<noteq> []; xs2 \\<noteq> [];\n        \\<forall>x\\<in>set ((x # y # xs) @ xs2).\n           \\<nexists>r s. x = Plus r s;\n        sorted xs2; distinct xs2\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus (PLUS (x # y # xs)) (PLUS xs2) =\n                         flatten PLUS (set ((x # y # xs) @ xs2))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>x12 # xs1 \\<noteq> []; ?xs2.0 \\<noteq> [];\n   \\<forall>x\\<in>set ((x12 # xs1) @ ?xs2.0). \\<nexists>r s. x = Plus r s;\n   sorted ?xs2.0; distinct ?xs2.0\\<rbrakk>\n  \\<Longrightarrow> ACI_nPlus (PLUS (x12 # xs1)) (PLUS ?xs2.0) =\n                    flatten PLUS (set ((x12 # xs1) @ ?xs2.0))\n  x11 # x12 # xs1 \\<noteq> []\n  xs2 \\<noteq> []\n  \\<forall>x\\<in>set ((x11 # x12 # xs1) @ xs2). \\<nexists>r s. x = Plus r s\n  sorted xs2\n  distinct xs2\n\ngoal (1 subgoal):\n 1. ACI_nPlus (PLUS (x11 # x12 # xs1)) (PLUS xs2) =\n    flatten PLUS (set ((x11 # x12 # xs1) @ xs2))", "apply (simp del: sorted_list_of_set_insert)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set xs1 \\<union> set xs2.\n                    \\<forall>r s. x \\<noteq> Plus r s;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> ACI_nPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  flatten PLUS\n                                   (insert x12 (set xs1 \\<union> set xs2));\n     xs2 \\<noteq> [];\n     (\\<forall>r s. x11 \\<noteq> Plus r s) \\<and>\n     (\\<forall>r s. x12 \\<noteq> Plus r s) \\<and>\n     (\\<forall>x\\<in>set xs1 \\<union> set xs2.\n         \\<forall>r s. x \\<noteq> Plus r s);\n     sorted xs2; distinct xs2\\<rbrakk>\n    \\<Longrightarrow> ACI_nPlus x11\n                       (flatten PLUS\n                         (insert x12 (set xs1 \\<union> set xs2))) =\n                      flatten PLUS\n                       (insert x11 (insert x12 (set xs1 \\<union> set xs2)))", "apply (rule trans[OF ACI_nPlus_singleton_PLUS])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set xs1 \\<union> set xs2.\n                    \\<forall>r s. x \\<noteq> Plus r s;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> ACI_nPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  flatten PLUS\n                                   (insert x12 (set xs1 \\<union> set xs2));\n     xs2 \\<noteq> [];\n     (\\<forall>r s. x11 \\<noteq> Plus r s) \\<and>\n     (\\<forall>r s. x12 \\<noteq> Plus r s) \\<and>\n     (\\<forall>x\\<in>set xs1 \\<union> set xs2.\n         \\<forall>r s. x \\<noteq> Plus r s);\n     sorted xs2; distinct xs2\\<rbrakk>\n    \\<Longrightarrow> flatten (\\<noteq>)\n                       (insert x12 (set xs1 \\<union> set xs2)) []\n 2. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set xs1 \\<union> set xs2.\n                    \\<forall>r s. x \\<noteq> Plus r s;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> ACI_nPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  flatten PLUS\n                                   (insert x12 (set xs1 \\<union> set xs2));\n     xs2 \\<noteq> [];\n     (\\<forall>r s. x11 \\<noteq> Plus r s) \\<and>\n     (\\<forall>r s. x12 \\<noteq> Plus r s) \\<and>\n     (\\<forall>x\\<in>set xs1 \\<union> set xs2.\n         \\<forall>r s. x \\<noteq> Plus r s);\n     sorted xs2; distinct xs2\\<rbrakk>\n    \\<Longrightarrow> flatten sorted (insert x12 (set xs1 \\<union> set xs2))\n 3. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set xs1 \\<union> set xs2.\n                    \\<forall>r s. x \\<noteq> Plus r s;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> ACI_nPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  flatten PLUS\n                                   (insert x12 (set xs1 \\<union> set xs2));\n     xs2 \\<noteq> [];\n     (\\<forall>r s. x11 \\<noteq> Plus r s) \\<and>\n     (\\<forall>r s. x12 \\<noteq> Plus r s) \\<and>\n     (\\<forall>x\\<in>set xs1 \\<union> set xs2.\n         \\<forall>r s. x \\<noteq> Plus r s);\n     sorted xs2; distinct xs2\\<rbrakk>\n    \\<Longrightarrow> flatten distinct\n                       (insert x12 (set xs1 \\<union> set xs2))\n 4. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set xs1 \\<union> set xs2.\n                    \\<forall>r s. x \\<noteq> Plus r s;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> ACI_nPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  flatten PLUS\n                                   (insert x12 (set xs1 \\<union> set xs2));\n     xs2 \\<noteq> [];\n     (\\<forall>r s. x11 \\<noteq> Plus r s) \\<and>\n     (\\<forall>r s. x12 \\<noteq> Plus r s) \\<and>\n     (\\<forall>x\\<in>set xs1 \\<union> set xs2.\n         \\<forall>r s. x \\<noteq> Plus r s);\n     sorted xs2; distinct xs2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>{x11} \\<union>\n                                     flatten set\n(insert x12 (set xs1 \\<union> set xs2)).\n                         \\<nexists>r s. x = Plus r s\n 5. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set xs1 \\<union> set xs2.\n                    \\<forall>r s. x \\<noteq> Plus r s;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> ACI_nPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  flatten PLUS\n                                   (insert x12 (set xs1 \\<union> set xs2));\n     xs2 \\<noteq> [];\n     (\\<forall>r s. x11 \\<noteq> Plus r s) \\<and>\n     (\\<forall>r s. x12 \\<noteq> Plus r s) \\<and>\n     (\\<forall>x\\<in>set xs1 \\<union> set xs2.\n         \\<forall>r s. x \\<noteq> Plus r s);\n     sorted xs2; distinct xs2\\<rbrakk>\n    \\<Longrightarrow> (if x11\n                          \\<in> flatten set\n                                 (insert x12 (set xs1 \\<union> set xs2))\n                       then flatten PLUS\n                             (insert x12 (set xs1 \\<union> set xs2))\n                       else PLUS\n                             (flatten (insort x11)\n                               (insert x12 (set xs1 \\<union> set xs2)))) =\n                      flatten PLUS\n                       (insert x11 (insert x12 (set xs1 \\<union> set xs2)))", "apply (auto simp del: sorted_list_of_set_insert simp add: insert_commute[of x11])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set xs1 \\<union> set xs2.\n                    \\<forall>r s. x \\<noteq> Plus r s;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> ACI_nPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  flatten PLUS\n                                   (insert x12 (set xs1 \\<union> set xs2));\n     xs2 \\<noteq> []; sorted xs2; distinct xs2;\n     \\<forall>r s. x12 \\<noteq> Plus r s;\n     \\<forall>x\\<in>set xs1 \\<union> set xs2.\n        \\<forall>r s. x \\<noteq> Plus r s;\n     x11 \\<in> set xs1\\<rbrakk>\n    \\<Longrightarrow> flatten PLUS (insert x12 (set xs1 \\<union> set xs2)) =\n                      flatten PLUS\n                       (insert x12 (insert x11 (set xs1 \\<union> set xs2)))\n 2. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set xs1 \\<union> set xs2.\n                    \\<forall>r s. x \\<noteq> Plus r s;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> ACI_nPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  flatten PLUS\n                                   (insert x12 (set xs1 \\<union> set xs2));\n     xs2 \\<noteq> []; sorted xs2; distinct xs2;\n     \\<forall>r s. x12 \\<noteq> Plus r s;\n     \\<forall>x\\<in>set xs1 \\<union> set xs2.\n        \\<forall>r s. x \\<noteq> Plus r s;\n     x11 \\<in> set xs2\\<rbrakk>\n    \\<Longrightarrow> flatten PLUS (insert x12 (set xs1 \\<union> set xs2)) =\n                      flatten PLUS\n                       (insert x12 (insert x11 (set xs1 \\<union> set xs2)))\n 3. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set xs1 \\<union> set xs2.\n                    \\<forall>r s. x \\<noteq> Plus r s;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> ACI_nPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  flatten PLUS\n                                   (insert x12 (set xs1 \\<union> set xs2));\n     xs2 \\<noteq> []; sorted xs2; distinct xs2;\n     \\<forall>r s. x11 \\<noteq> Plus r s;\n     \\<forall>r s. x12 \\<noteq> Plus r s;\n     \\<forall>x\\<in>set xs1 \\<union> set xs2.\n        \\<forall>r s. x \\<noteq> Plus r s;\n     x11 \\<noteq> x12; x11 \\<notin> set xs1; x11 \\<notin> set xs2\\<rbrakk>\n    \\<Longrightarrow> PLUS\n                       (flatten (insort x11)\n                         (insert x12 (set xs1 \\<union> set xs2))) =\n                      flatten PLUS\n                       (insert x12 (insert x11 (set xs1 \\<union> set xs2)))", "apply (auto simp only: Un_insert_left[of x11, symmetric] insert_absorb) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set xs1 \\<union> set xs2.\n                    \\<forall>r s. x \\<noteq> Plus r s;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> ACI_nPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  flatten PLUS\n                                   (insert x12 (set xs1 \\<union> set xs2));\n     xs2 \\<noteq> []; sorted xs2; distinct xs2;\n     \\<forall>r s. x12 \\<noteq> Plus r s;\n     \\<forall>x\\<in>set xs1 \\<union> set xs2.\n        \\<forall>r s. x \\<noteq> Plus r s;\n     x11 \\<in> set xs2\\<rbrakk>\n    \\<Longrightarrow> flatten PLUS (insert x12 (set xs1 \\<union> set xs2)) =\n                      flatten PLUS\n                       (insert x12 (insert x11 (set xs1 \\<union> set xs2)))\n 2. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set xs1 \\<union> set xs2.\n                    \\<forall>r s. x \\<noteq> Plus r s;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> ACI_nPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  flatten PLUS\n                                   (insert x12 (set xs1 \\<union> set xs2));\n     xs2 \\<noteq> []; sorted xs2; distinct xs2;\n     \\<forall>r s. x11 \\<noteq> Plus r s;\n     \\<forall>r s. x12 \\<noteq> Plus r s;\n     \\<forall>x\\<in>set xs1 \\<union> set xs2.\n        \\<forall>r s. x \\<noteq> Plus r s;\n     x11 \\<noteq> x12; x11 \\<notin> set xs1; x11 \\<notin> set xs2\\<rbrakk>\n    \\<Longrightarrow> PLUS\n                       (flatten (insort x11)\n                         (insert x12 (set xs1 \\<union> set xs2))) =\n                      flatten PLUS\n                       (insert x12 (insert x11 (set xs1 \\<union> set xs2)))", "apply (auto simp only: Un_insert_right[of _ x11, symmetric] insert_absorb) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set xs1 \\<union> set xs2.\n                    \\<forall>r s. x \\<noteq> Plus r s;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> ACI_nPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  flatten PLUS\n                                   (insert x12 (set xs1 \\<union> set xs2));\n     xs2 \\<noteq> []; sorted xs2; distinct xs2;\n     \\<forall>r s. x11 \\<noteq> Plus r s;\n     \\<forall>r s. x12 \\<noteq> Plus r s;\n     \\<forall>x\\<in>set xs1 \\<union> set xs2.\n        \\<forall>r s. x \\<noteq> Plus r s;\n     x11 \\<noteq> x12; x11 \\<notin> set xs1; x11 \\<notin> set xs2\\<rbrakk>\n    \\<Longrightarrow> PLUS\n                       (flatten (insort x11)\n                         (insert x12 (set xs1 \\<union> set xs2))) =\n                      flatten PLUS\n                       (insert x12 (insert x11 (set xs1 \\<union> set xs2)))", "apply (auto simp add: insert_commute[of x12])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ACI_nPlus (PLUS (x11 # x12 # xs1)) (PLUS xs2) =\n  flatten PLUS (set ((x11 # x12 # xs1) @ xs2))\n\ngoal (1 subgoal):\n 1. \\<And>xs2.\n       \\<lbrakk>[] \\<noteq> []; xs2 \\<noteq> [];\n        \\<forall>x\\<in>set ([] @ xs2). \\<nexists>r s. x = Plus r s;\n        sorted xs2; distinct xs2\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus (PLUS []) (PLUS xs2) =\n                         flatten PLUS (set ([] @ xs2))", "qed simp"], ["", "lemma ACI_nPlus_flatten_PLUS:\n  \"\\<lbrakk>X1 \\<noteq> {}; X2 \\<noteq> {}; finite X1; finite X2; \\<forall>x \\<in> X1 \\<union> X2. \\<not>(\\<exists>r s. x = Plus r s)\\<rbrakk>\\<Longrightarrow>\n  ACI_nPlus (flatten PLUS X1) (flatten PLUS X2) = flatten PLUS (X1 \\<union> X2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X1 \\<noteq> {}; X2 \\<noteq> {}; finite X1; finite X2;\n     \\<forall>x\\<in>X1 \\<union> X2. \\<nexists>r s. x = Plus r s\\<rbrakk>\n    \\<Longrightarrow> ACI_nPlus (flatten PLUS X1) (flatten PLUS X2) =\n                      flatten PLUS (X1 \\<union> X2)", "by (rule trans[OF ACI_nPlus_PLUS]) auto"], ["", "lemma ACI_nPlus_ACI_norm [simp]: \"ACI_nPlus \\<guillemotleft>r\\<guillemotright> \\<guillemotleft>s\\<guillemotright> = \\<guillemotleft>Plus r s\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ACI_nPlus \\<guillemotleft>r\\<guillemotright>\n     \\<guillemotleft>s\\<guillemotright> =\n    \\<guillemotleft>Plus r s\\<guillemotright>", "by (auto simp: image_Un Un_assoc ACI_norm_flatten [of r] ACI_norm_flatten [of s] ACI_norm_flatten [of \"Plus r s\"]\n    toplevel_summands_flatten_ACI_norm_image\n    intro!: trans [OF ACI_nPlus_flatten_PLUS])\n    (metis ACI_norm_Plus Plus_toplevel_summands)+"], ["", "lemma ACI_norm_alt:\n  \"ACI_norm_alt r = \\<guillemotleft>r\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ACI_norm_alt r = \\<guillemotleft>r\\<guillemotright>", "by (induct r) auto"], ["", "declare ACI_norm_alt[symmetric, code]"], ["", "inductive ACI where\n  ACI_refl:       \"ACI r r\" |\n  ACI_sym:        \"ACI r s \\<Longrightarrow> ACI s r\" |\n  ACI_trans:      \"ACI r s \\<Longrightarrow> ACI s t \\<Longrightarrow> ACI r t\" |\n  ACI_Plus_cong:  \"\\<lbrakk>ACI r1 s1; ACI r2 s2\\<rbrakk> \\<Longrightarrow> ACI (Plus r1 r2) (Plus s1 s2)\" |\n  ACI_Times_cong: \"\\<lbrakk>ACI r1 s1; ACI r2 s2\\<rbrakk> \\<Longrightarrow> ACI (Times r1 r2) (Times s1 s2)\" |\n  ACI_Star_cong:  \"ACI r s \\<Longrightarrow> ACI (Star r) (Star s)\" |\n  ACI_assoc:      \"ACI (Plus (Plus r s) t) (Plus r (Plus s t))\" |\n  ACI_comm:       \"ACI (Plus r s) (Plus s r)\" |\n  ACI_idem:       \"ACI (Plus r r) r\""], ["", "lemma ACI_atoms: \"ACI r s \\<Longrightarrow> atoms r = atoms s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ACI r s \\<Longrightarrow> atoms r = atoms s", "by (induct rule: ACI.induct) auto"], ["", "lemma ACI_nullable: \"ACI r s \\<Longrightarrow> nullable r = nullable s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ACI r s \\<Longrightarrow> nullable r = nullable s", "by (induct rule: ACI.induct) auto"], ["", "lemma ACI_lang: \"ACI r s \\<Longrightarrow> lang r = lang s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ACI r s \\<Longrightarrow> lang r = lang s", "by (induct rule: ACI.induct) auto"], ["", "lemma ACI_deriv: \"ACI r s \\<Longrightarrow> ACI (deriv a r) (deriv a s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ACI r s \\<Longrightarrow> ACI (deriv a r) (deriv a s)", "proof (induct arbitrary: a rule: ACI.induct)"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>r a. ACI (deriv a r) (deriv a r)\n 2. \\<And>r s a.\n       \\<lbrakk>ACI r s; \\<And>a. ACI (deriv a r) (deriv a s)\\<rbrakk>\n       \\<Longrightarrow> ACI (deriv a s) (deriv a r)\n 3. \\<And>r s t a.\n       \\<lbrakk>ACI r s; \\<And>a. ACI (deriv a r) (deriv a s); ACI s t;\n        \\<And>a. ACI (deriv a s) (deriv a t)\\<rbrakk>\n       \\<Longrightarrow> ACI (deriv a r) (deriv a t)\n 4. \\<And>r1 s1 r2 s2 a.\n       \\<lbrakk>ACI r1 s1; \\<And>a. ACI (deriv a r1) (deriv a s1);\n        ACI r2 s2; \\<And>a. ACI (deriv a r2) (deriv a s2)\\<rbrakk>\n       \\<Longrightarrow> ACI (deriv a (Plus r1 r2)) (deriv a (Plus s1 s2))\n 5. \\<And>r1 s1 r2 s2 a.\n       \\<lbrakk>ACI r1 s1; \\<And>a. ACI (deriv a r1) (deriv a s1);\n        ACI r2 s2; \\<And>a. ACI (deriv a r2) (deriv a s2)\\<rbrakk>\n       \\<Longrightarrow> ACI (deriv a (Times r1 r2)) (deriv a (Times s1 s2))\n 6. \\<And>r s a.\n       \\<lbrakk>ACI r s; \\<And>a. ACI (deriv a r) (deriv a s)\\<rbrakk>\n       \\<Longrightarrow> ACI (deriv a (Star r)) (deriv a (Star s))\n 7. \\<And>r s t a.\n       ACI (deriv a (Plus (Plus r s) t)) (deriv a (Plus r (Plus s t)))\n 8. \\<And>r s a. ACI (deriv a (Plus r s)) (deriv a (Plus s r))\n 9. \\<And>r a. ACI (deriv a (Plus r r)) (deriv a r)", "case (ACI_Times_cong r1 s1 r2 s2)"], ["proof (state)\nthis:\n  ACI r1 s1\n  ACI (deriv ?a r1) (deriv ?a s1)\n  ACI r2 s2\n  ACI (deriv ?a r2) (deriv ?a s2)\n\ngoal (9 subgoals):\n 1. \\<And>r a. ACI (deriv a r) (deriv a r)\n 2. \\<And>r s a.\n       \\<lbrakk>ACI r s; \\<And>a. ACI (deriv a r) (deriv a s)\\<rbrakk>\n       \\<Longrightarrow> ACI (deriv a s) (deriv a r)\n 3. \\<And>r s t a.\n       \\<lbrakk>ACI r s; \\<And>a. ACI (deriv a r) (deriv a s); ACI s t;\n        \\<And>a. ACI (deriv a s) (deriv a t)\\<rbrakk>\n       \\<Longrightarrow> ACI (deriv a r) (deriv a t)\n 4. \\<And>r1 s1 r2 s2 a.\n       \\<lbrakk>ACI r1 s1; \\<And>a. ACI (deriv a r1) (deriv a s1);\n        ACI r2 s2; \\<And>a. ACI (deriv a r2) (deriv a s2)\\<rbrakk>\n       \\<Longrightarrow> ACI (deriv a (Plus r1 r2)) (deriv a (Plus s1 s2))\n 5. \\<And>r1 s1 r2 s2 a.\n       \\<lbrakk>ACI r1 s1; \\<And>a. ACI (deriv a r1) (deriv a s1);\n        ACI r2 s2; \\<And>a. ACI (deriv a r2) (deriv a s2)\\<rbrakk>\n       \\<Longrightarrow> ACI (deriv a (Times r1 r2)) (deriv a (Times s1 s2))\n 6. \\<And>r s a.\n       \\<lbrakk>ACI r s; \\<And>a. ACI (deriv a r) (deriv a s)\\<rbrakk>\n       \\<Longrightarrow> ACI (deriv a (Star r)) (deriv a (Star s))\n 7. \\<And>r s t a.\n       ACI (deriv a (Plus (Plus r s) t)) (deriv a (Plus r (Plus s t)))\n 8. \\<And>r s a. ACI (deriv a (Plus r s)) (deriv a (Plus s r))\n 9. \\<And>r a. ACI (deriv a (Plus r r)) (deriv a r)", "thus ?case"], ["proof (prove)\nusing this:\n  ACI r1 s1\n  ACI (deriv ?a r1) (deriv ?a s1)\n  ACI r2 s2\n  ACI (deriv ?a r2) (deriv ?a s2)\n\ngoal (1 subgoal):\n 1. ACI (deriv a (Times r1 r2)) (deriv a (Times s1 s2))", "by (auto simp: Let_def intro: ACI.intros dest: ACI_nullable)\n      (metis ACI.ACI_Times_cong ACI_Plus_cong)"], ["proof (state)\nthis:\n  ACI (deriv a (Times r1 r2)) (deriv a (Times s1 s2))\n\ngoal (8 subgoals):\n 1. \\<And>r a. ACI (deriv a r) (deriv a r)\n 2. \\<And>r s a.\n       \\<lbrakk>ACI r s; \\<And>a. ACI (deriv a r) (deriv a s)\\<rbrakk>\n       \\<Longrightarrow> ACI (deriv a s) (deriv a r)\n 3. \\<And>r s t a.\n       \\<lbrakk>ACI r s; \\<And>a. ACI (deriv a r) (deriv a s); ACI s t;\n        \\<And>a. ACI (deriv a s) (deriv a t)\\<rbrakk>\n       \\<Longrightarrow> ACI (deriv a r) (deriv a t)\n 4. \\<And>r1 s1 r2 s2 a.\n       \\<lbrakk>ACI r1 s1; \\<And>a. ACI (deriv a r1) (deriv a s1);\n        ACI r2 s2; \\<And>a. ACI (deriv a r2) (deriv a s2)\\<rbrakk>\n       \\<Longrightarrow> ACI (deriv a (Plus r1 r2)) (deriv a (Plus s1 s2))\n 5. \\<And>r s a.\n       \\<lbrakk>ACI r s; \\<And>a. ACI (deriv a r) (deriv a s)\\<rbrakk>\n       \\<Longrightarrow> ACI (deriv a (Star r)) (deriv a (Star s))\n 6. \\<And>r s t a.\n       ACI (deriv a (Plus (Plus r s) t)) (deriv a (Plus r (Plus s t)))\n 7. \\<And>r s a. ACI (deriv a (Plus r s)) (deriv a (Plus s r))\n 8. \\<And>r a. ACI (deriv a (Plus r r)) (deriv a r)", "qed (auto intro: ACI.intros)"], ["", "lemma ACI_Plus_assocI[intro]:\n  \"ACI (Plus r1 r2) s2 \\<Longrightarrow> ACI (Plus r1 (Plus s1 r2)) (Plus s1 s2)\"\n  \"ACI (Plus r1 r2) s2 \\<Longrightarrow> ACI (Plus r1 (Plus r2 s1)) (Plus s1 s2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ACI (Plus r1 r2) s2 \\<Longrightarrow>\n     ACI (Plus r1 (Plus s1 r2)) (Plus s1 s2)) &&&\n    (ACI (Plus r1 r2) s2 \\<Longrightarrow>\n     ACI (Plus r1 (Plus r2 s1)) (Plus s1 s2))", "by (metis ACI_assoc ACI_comm ACI_Plus_cong ACI_refl ACI_trans)+"], ["", "lemma ACI_Plus_idemI[intro]: \"\\<lbrakk>ACI r s1; ACI r s2\\<rbrakk> \\<Longrightarrow> ACI r (Plus s1 s2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ACI r s1; ACI r s2\\<rbrakk>\n    \\<Longrightarrow> ACI r (Plus s1 s2)", "by (metis ACI_Plus_cong ACI_idem ACI_sym ACI_trans)"], ["", "lemma ACI_Plus_idemI'[intro]:\n  \"\\<lbrakk>ACI r1 s1; ACI (Plus r1 r2) s2\\<rbrakk> \\<Longrightarrow> ACI (Plus r1 r2) (Plus s1 s2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ACI r1 s1; ACI (Plus r1 r2) s2\\<rbrakk>\n    \\<Longrightarrow> ACI (Plus r1 r2) (Plus s1 s2)", "by (rule ACI_trans[OF ACI_Plus_cong[OF ACI_sym[OF ACI_idem] ACI_refl]\n             ACI_trans[OF ACI_assoc ACI_trans[OF ACI_Plus_cong ACI_refl]]])"], ["", "lemma ACI_ACI_nPlus: \"\\<lbrakk>ACI r1 s1; ACI r2 s2\\<rbrakk> \\<Longrightarrow> ACI (ACI_nPlus r1 r2) (Plus s1 s2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ACI r1 s1; ACI r2 s2\\<rbrakk>\n    \\<Longrightarrow> ACI (ACI_nPlus r1 r2) (Plus s1 s2)", "proof (induct r1 r2 arbitrary: s1 s2 rule: ACI_nPlus.induct)"], ["proof (state)\ngoal (31 subgoals):\n 1. \\<And>r1 r2 s s1 s2.\n       \\<lbrakk>\\<And>s1 s2.\n                   \\<lbrakk>ACI r2 s1; ACI s s2\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus r2 s) (Plus s1 s2);\n        \\<And>s1 s2.\n           \\<lbrakk>ACI r1 s1; ACI (ACI_nPlus r2 s) s2\\<rbrakk>\n           \\<Longrightarrow> ACI (ACI_nPlus r1 (ACI_nPlus r2 s))\n                              (Plus s1 s2);\n        ACI (Plus r1 r2) s1; ACI s s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Plus r1 r2) s) (Plus s1 s2)\n 2. \\<And>s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Zero \\<noteq> s1; \\<not> Zero < s1;\n                    ACI Zero s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus Zero s2) (Plus s1a s2a);\n        ACI Zero s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Plus s1 s2)) (Plus s1a s2a)\n 3. \\<And>s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>One \\<noteq> s1; \\<not> One < s1; ACI One s1a;\n                    ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus One s2) (Plus s1a s2a);\n        ACI One s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus One (Plus s1 s2)) (Plus s1a s2a)\n 4. \\<And>v s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Atom v \\<noteq> s1; \\<not> Atom v < s1;\n                    ACI (Atom v) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Atom v) s2)\n(Plus s1a s2a);\n        ACI (Atom v) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Atom v) (Plus s1 s2))\n                          (Plus s1a s2a)\n 5. \\<And>v va s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Times v va \\<noteq> s1; \\<not> Times v va < s1;\n                    ACI (Times v va) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Times v va) s2)\n(Plus s1a s2a);\n        ACI (Times v va) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Times v va) (Plus s1 s2))\n                          (Plus s1a s2a)\n 6. \\<And>v s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Star v \\<noteq> s1; \\<not> Star v < s1;\n                    ACI (Star v) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Star v) s2)\n(Plus s1a s2a);\n        ACI (Star v) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Star v) (Plus s1 s2))\n                          (Plus s1a s2a)\n 7. \\<And>s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI Zero s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero Zero) (Plus s1 s2)\n 8. \\<And>s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI One s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero One) (Plus s1 s2)\n 9. \\<And>v s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Atom v) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Atom v)) (Plus s1 s2)\n 10. \\<And>v va s1 s2.\n        \\<lbrakk>ACI Zero s1; ACI (Times v va) s2\\<rbrakk>\n        \\<Longrightarrow> ACI (ACI_nPlus Zero (Times v va)) (Plus s1 s2)\nA total of 31 subgoals...", "case 1"], ["proof (state)\nthis:\n  \\<lbrakk>ACI r2_ ?s1.0; ACI s_ ?s2.0\\<rbrakk>\n  \\<Longrightarrow> ACI (ACI_nPlus r2_ s_) (Plus ?s1.0 ?s2.0)\n  \\<lbrakk>ACI r1_ ?s1.0; ACI (ACI_nPlus r2_ s_) ?s2.0\\<rbrakk>\n  \\<Longrightarrow> ACI (ACI_nPlus r1_ (ACI_nPlus r2_ s_))\n                     (Plus ?s1.0 ?s2.0)\n  ACI (Plus r1_ r2_) s1\n  ACI s_ s2\n\ngoal (31 subgoals):\n 1. \\<And>r1 r2 s s1 s2.\n       \\<lbrakk>\\<And>s1 s2.\n                   \\<lbrakk>ACI r2 s1; ACI s s2\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus r2 s) (Plus s1 s2);\n        \\<And>s1 s2.\n           \\<lbrakk>ACI r1 s1; ACI (ACI_nPlus r2 s) s2\\<rbrakk>\n           \\<Longrightarrow> ACI (ACI_nPlus r1 (ACI_nPlus r2 s))\n                              (Plus s1 s2);\n        ACI (Plus r1 r2) s1; ACI s s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Plus r1 r2) s) (Plus s1 s2)\n 2. \\<And>s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Zero \\<noteq> s1; \\<not> Zero < s1;\n                    ACI Zero s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus Zero s2) (Plus s1a s2a);\n        ACI Zero s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Plus s1 s2)) (Plus s1a s2a)\n 3. \\<And>s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>One \\<noteq> s1; \\<not> One < s1; ACI One s1a;\n                    ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus One s2) (Plus s1a s2a);\n        ACI One s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus One (Plus s1 s2)) (Plus s1a s2a)\n 4. \\<And>v s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Atom v \\<noteq> s1; \\<not> Atom v < s1;\n                    ACI (Atom v) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Atom v) s2)\n(Plus s1a s2a);\n        ACI (Atom v) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Atom v) (Plus s1 s2))\n                          (Plus s1a s2a)\n 5. \\<And>v va s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Times v va \\<noteq> s1; \\<not> Times v va < s1;\n                    ACI (Times v va) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Times v va) s2)\n(Plus s1a s2a);\n        ACI (Times v va) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Times v va) (Plus s1 s2))\n                          (Plus s1a s2a)\n 6. \\<And>v s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Star v \\<noteq> s1; \\<not> Star v < s1;\n                    ACI (Star v) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Star v) s2)\n(Plus s1a s2a);\n        ACI (Star v) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Star v) (Plus s1 s2))\n                          (Plus s1a s2a)\n 7. \\<And>s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI Zero s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero Zero) (Plus s1 s2)\n 8. \\<And>s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI One s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero One) (Plus s1 s2)\n 9. \\<And>v s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Atom v) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Atom v)) (Plus s1 s2)\n 10. \\<And>v va s1 s2.\n        \\<lbrakk>ACI Zero s1; ACI (Times v va) s2\\<rbrakk>\n        \\<Longrightarrow> ACI (ACI_nPlus Zero (Times v va)) (Plus s1 s2)\nA total of 31 subgoals...", "from 1(2)[OF ACI_refl 1(1)[OF ACI_refl 1(4)]] 1(3)"], ["proof (chain)\npicking this:\n  ACI (ACI_nPlus r1_ (ACI_nPlus r2_ s_)) (Plus r1_ (Plus r2_ s2))\n  ACI (Plus r1_ r2_) s1", "show ?case"], ["proof (prove)\nusing this:\n  ACI (ACI_nPlus r1_ (ACI_nPlus r2_ s_)) (Plus r1_ (Plus r2_ s2))\n  ACI (Plus r1_ r2_) s1\n\ngoal (1 subgoal):\n 1. ACI (ACI_nPlus (Plus r1_ r2_) s_) (Plus s1 s2)", "by (auto intro: ACI_comm ACI_trans)"], ["proof (state)\nthis:\n  ACI (ACI_nPlus (Plus r1_ r2_) s_) (Plus s1 s2)\n\ngoal (30 subgoals):\n 1. \\<And>s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Zero \\<noteq> s1; \\<not> Zero < s1;\n                    ACI Zero s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus Zero s2) (Plus s1a s2a);\n        ACI Zero s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Plus s1 s2)) (Plus s1a s2a)\n 2. \\<And>s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>One \\<noteq> s1; \\<not> One < s1; ACI One s1a;\n                    ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus One s2) (Plus s1a s2a);\n        ACI One s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus One (Plus s1 s2)) (Plus s1a s2a)\n 3. \\<And>v s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Atom v \\<noteq> s1; \\<not> Atom v < s1;\n                    ACI (Atom v) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Atom v) s2)\n(Plus s1a s2a);\n        ACI (Atom v) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Atom v) (Plus s1 s2))\n                          (Plus s1a s2a)\n 4. \\<And>v va s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Times v va \\<noteq> s1; \\<not> Times v va < s1;\n                    ACI (Times v va) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Times v va) s2)\n(Plus s1a s2a);\n        ACI (Times v va) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Times v va) (Plus s1 s2))\n                          (Plus s1a s2a)\n 5. \\<And>v s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Star v \\<noteq> s1; \\<not> Star v < s1;\n                    ACI (Star v) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Star v) s2)\n(Plus s1a s2a);\n        ACI (Star v) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Star v) (Plus s1 s2))\n                          (Plus s1a s2a)\n 6. \\<And>s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI Zero s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero Zero) (Plus s1 s2)\n 7. \\<And>s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI One s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero One) (Plus s1 s2)\n 8. \\<And>v s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Atom v) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Atom v)) (Plus s1 s2)\n 9. \\<And>v va s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Times v va) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Times v va)) (Plus s1 s2)\n 10. \\<And>v s1 s2.\n        \\<lbrakk>ACI Zero s1; ACI (Star v) s2\\<rbrakk>\n        \\<Longrightarrow> ACI (ACI_nPlus Zero (Star v)) (Plus s1 s2)\nA total of 30 subgoals...", "next"], ["proof (state)\ngoal (30 subgoals):\n 1. \\<And>s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Zero \\<noteq> s1; \\<not> Zero < s1;\n                    ACI Zero s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus Zero s2) (Plus s1a s2a);\n        ACI Zero s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Plus s1 s2)) (Plus s1a s2a)\n 2. \\<And>s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>One \\<noteq> s1; \\<not> One < s1; ACI One s1a;\n                    ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus One s2) (Plus s1a s2a);\n        ACI One s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus One (Plus s1 s2)) (Plus s1a s2a)\n 3. \\<And>v s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Atom v \\<noteq> s1; \\<not> Atom v < s1;\n                    ACI (Atom v) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Atom v) s2)\n(Plus s1a s2a);\n        ACI (Atom v) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Atom v) (Plus s1 s2))\n                          (Plus s1a s2a)\n 4. \\<And>v va s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Times v va \\<noteq> s1; \\<not> Times v va < s1;\n                    ACI (Times v va) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Times v va) s2)\n(Plus s1a s2a);\n        ACI (Times v va) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Times v va) (Plus s1 s2))\n                          (Plus s1a s2a)\n 5. \\<And>v s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Star v \\<noteq> s1; \\<not> Star v < s1;\n                    ACI (Star v) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Star v) s2)\n(Plus s1a s2a);\n        ACI (Star v) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Star v) (Plus s1 s2))\n                          (Plus s1a s2a)\n 6. \\<And>s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI Zero s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero Zero) (Plus s1 s2)\n 7. \\<And>s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI One s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero One) (Plus s1 s2)\n 8. \\<And>v s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Atom v) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Atom v)) (Plus s1 s2)\n 9. \\<And>v va s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Times v va) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Times v va)) (Plus s1 s2)\n 10. \\<And>v s1 s2.\n        \\<lbrakk>ACI Zero s1; ACI (Star v) s2\\<rbrakk>\n        \\<Longrightarrow> ACI (ACI_nPlus Zero (Star v)) (Plus s1 s2)\nA total of 30 subgoals...", "case (\"2_1\" r1 r2)"], ["proof (state)\nthis:\n  \\<lbrakk>Zero \\<noteq> r1; \\<not> Zero < r1; ACI Zero ?s1.0;\n   ACI r2 ?s2.0\\<rbrakk>\n  \\<Longrightarrow> ACI (ACI_nPlus Zero r2) (Plus ?s1.0 ?s2.0)\n  ACI Zero s1\n  ACI (Plus r1 r2) s2\n\ngoal (30 subgoals):\n 1. \\<And>s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Zero \\<noteq> s1; \\<not> Zero < s1;\n                    ACI Zero s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus Zero s2) (Plus s1a s2a);\n        ACI Zero s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Plus s1 s2)) (Plus s1a s2a)\n 2. \\<And>s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>One \\<noteq> s1; \\<not> One < s1; ACI One s1a;\n                    ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus One s2) (Plus s1a s2a);\n        ACI One s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus One (Plus s1 s2)) (Plus s1a s2a)\n 3. \\<And>v s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Atom v \\<noteq> s1; \\<not> Atom v < s1;\n                    ACI (Atom v) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Atom v) s2)\n(Plus s1a s2a);\n        ACI (Atom v) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Atom v) (Plus s1 s2))\n                          (Plus s1a s2a)\n 4. \\<And>v va s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Times v va \\<noteq> s1; \\<not> Times v va < s1;\n                    ACI (Times v va) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Times v va) s2)\n(Plus s1a s2a);\n        ACI (Times v va) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Times v va) (Plus s1 s2))\n                          (Plus s1a s2a)\n 5. \\<And>v s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Star v \\<noteq> s1; \\<not> Star v < s1;\n                    ACI (Star v) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Star v) s2)\n(Plus s1a s2a);\n        ACI (Star v) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Star v) (Plus s1 s2))\n                          (Plus s1a s2a)\n 6. \\<And>s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI Zero s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero Zero) (Plus s1 s2)\n 7. \\<And>s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI One s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero One) (Plus s1 s2)\n 8. \\<And>v s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Atom v) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Atom v)) (Plus s1 s2)\n 9. \\<And>v va s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Times v va) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Times v va)) (Plus s1 s2)\n 10. \\<And>v s1 s2.\n        \\<lbrakk>ACI Zero s1; ACI (Star v) s2\\<rbrakk>\n        \\<Longrightarrow> ACI (ACI_nPlus Zero (Star v)) (Plus s1 s2)\nA total of 30 subgoals...", "with ACI_Plus_cong[OF ACI_refl \"2_1\"(1)[OF _ _ \"2_1\"(2) ACI_refl], of r1]"], ["proof (chain)\npicking this:\n  \\<lbrakk>Zero \\<noteq> r1; \\<not> Zero < r1\\<rbrakk>\n  \\<Longrightarrow> ACI (Plus r1 (ACI_nPlus Zero r2)) (Plus r1 (Plus s1 r2))\n  \\<lbrakk>Zero \\<noteq> r1; \\<not> Zero < r1; ACI Zero ?s1.0;\n   ACI r2 ?s2.0\\<rbrakk>\n  \\<Longrightarrow> ACI (ACI_nPlus Zero r2) (Plus ?s1.0 ?s2.0)\n  ACI Zero s1\n  ACI (Plus r1 r2) s2", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>Zero \\<noteq> r1; \\<not> Zero < r1\\<rbrakk>\n  \\<Longrightarrow> ACI (Plus r1 (ACI_nPlus Zero r2)) (Plus r1 (Plus s1 r2))\n  \\<lbrakk>Zero \\<noteq> r1; \\<not> Zero < r1; ACI Zero ?s1.0;\n   ACI r2 ?s2.0\\<rbrakk>\n  \\<Longrightarrow> ACI (ACI_nPlus Zero r2) (Plus ?s1.0 ?s2.0)\n  ACI Zero s1\n  ACI (Plus r1 r2) s2\n\ngoal (1 subgoal):\n 1. ACI (ACI_nPlus Zero (Plus r1 r2)) (Plus s1 s2)", "by (auto intro: ACI.intros)"], ["proof (state)\nthis:\n  ACI (ACI_nPlus Zero (Plus r1 r2)) (Plus s1 s2)\n\ngoal (29 subgoals):\n 1. \\<And>s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>One \\<noteq> s1; \\<not> One < s1; ACI One s1a;\n                    ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus One s2) (Plus s1a s2a);\n        ACI One s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus One (Plus s1 s2)) (Plus s1a s2a)\n 2. \\<And>v s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Atom v \\<noteq> s1; \\<not> Atom v < s1;\n                    ACI (Atom v) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Atom v) s2)\n(Plus s1a s2a);\n        ACI (Atom v) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Atom v) (Plus s1 s2))\n                          (Plus s1a s2a)\n 3. \\<And>v va s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Times v va \\<noteq> s1; \\<not> Times v va < s1;\n                    ACI (Times v va) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Times v va) s2)\n(Plus s1a s2a);\n        ACI (Times v va) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Times v va) (Plus s1 s2))\n                          (Plus s1a s2a)\n 4. \\<And>v s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Star v \\<noteq> s1; \\<not> Star v < s1;\n                    ACI (Star v) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Star v) s2)\n(Plus s1a s2a);\n        ACI (Star v) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Star v) (Plus s1 s2))\n                          (Plus s1a s2a)\n 5. \\<And>s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI Zero s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero Zero) (Plus s1 s2)\n 6. \\<And>s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI One s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero One) (Plus s1 s2)\n 7. \\<And>v s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Atom v) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Atom v)) (Plus s1 s2)\n 8. \\<And>v va s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Times v va) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Times v va)) (Plus s1 s2)\n 9. \\<And>v s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Star v) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Star v)) (Plus s1 s2)\n 10. \\<And>s1 s2.\n        \\<lbrakk>ACI One s1; ACI Zero s2\\<rbrakk>\n        \\<Longrightarrow> ACI (ACI_nPlus One Zero) (Plus s1 s2)\nA total of 29 subgoals...", "next"], ["proof (state)\ngoal (29 subgoals):\n 1. \\<And>s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>One \\<noteq> s1; \\<not> One < s1; ACI One s1a;\n                    ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus One s2) (Plus s1a s2a);\n        ACI One s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus One (Plus s1 s2)) (Plus s1a s2a)\n 2. \\<And>v s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Atom v \\<noteq> s1; \\<not> Atom v < s1;\n                    ACI (Atom v) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Atom v) s2)\n(Plus s1a s2a);\n        ACI (Atom v) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Atom v) (Plus s1 s2))\n                          (Plus s1a s2a)\n 3. \\<And>v va s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Times v va \\<noteq> s1; \\<not> Times v va < s1;\n                    ACI (Times v va) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Times v va) s2)\n(Plus s1a s2a);\n        ACI (Times v va) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Times v va) (Plus s1 s2))\n                          (Plus s1a s2a)\n 4. \\<And>v s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Star v \\<noteq> s1; \\<not> Star v < s1;\n                    ACI (Star v) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Star v) s2)\n(Plus s1a s2a);\n        ACI (Star v) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Star v) (Plus s1 s2))\n                          (Plus s1a s2a)\n 5. \\<And>s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI Zero s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero Zero) (Plus s1 s2)\n 6. \\<And>s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI One s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero One) (Plus s1 s2)\n 7. \\<And>v s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Atom v) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Atom v)) (Plus s1 s2)\n 8. \\<And>v va s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Times v va) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Times v va)) (Plus s1 s2)\n 9. \\<And>v s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Star v) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Star v)) (Plus s1 s2)\n 10. \\<And>s1 s2.\n        \\<lbrakk>ACI One s1; ACI Zero s2\\<rbrakk>\n        \\<Longrightarrow> ACI (ACI_nPlus One Zero) (Plus s1 s2)\nA total of 29 subgoals...", "case (\"2_2\" r1 r2)"], ["proof (state)\nthis:\n  \\<lbrakk>One \\<noteq> r1; \\<not> One < r1; ACI One ?s1.0;\n   ACI r2 ?s2.0\\<rbrakk>\n  \\<Longrightarrow> ACI (ACI_nPlus One r2) (Plus ?s1.0 ?s2.0)\n  ACI One s1\n  ACI (Plus r1 r2) s2\n\ngoal (29 subgoals):\n 1. \\<And>s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>One \\<noteq> s1; \\<not> One < s1; ACI One s1a;\n                    ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus One s2) (Plus s1a s2a);\n        ACI One s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus One (Plus s1 s2)) (Plus s1a s2a)\n 2. \\<And>v s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Atom v \\<noteq> s1; \\<not> Atom v < s1;\n                    ACI (Atom v) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Atom v) s2)\n(Plus s1a s2a);\n        ACI (Atom v) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Atom v) (Plus s1 s2))\n                          (Plus s1a s2a)\n 3. \\<And>v va s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Times v va \\<noteq> s1; \\<not> Times v va < s1;\n                    ACI (Times v va) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Times v va) s2)\n(Plus s1a s2a);\n        ACI (Times v va) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Times v va) (Plus s1 s2))\n                          (Plus s1a s2a)\n 4. \\<And>v s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Star v \\<noteq> s1; \\<not> Star v < s1;\n                    ACI (Star v) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Star v) s2)\n(Plus s1a s2a);\n        ACI (Star v) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Star v) (Plus s1 s2))\n                          (Plus s1a s2a)\n 5. \\<And>s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI Zero s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero Zero) (Plus s1 s2)\n 6. \\<And>s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI One s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero One) (Plus s1 s2)\n 7. \\<And>v s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Atom v) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Atom v)) (Plus s1 s2)\n 8. \\<And>v va s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Times v va) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Times v va)) (Plus s1 s2)\n 9. \\<And>v s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Star v) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Star v)) (Plus s1 s2)\n 10. \\<And>s1 s2.\n        \\<lbrakk>ACI One s1; ACI Zero s2\\<rbrakk>\n        \\<Longrightarrow> ACI (ACI_nPlus One Zero) (Plus s1 s2)\nA total of 29 subgoals...", "with ACI_Plus_cong[OF ACI_refl \"2_2\"(1)[OF _ _ \"2_2\"(2) ACI_refl], of r1]"], ["proof (chain)\npicking this:\n  \\<lbrakk>One \\<noteq> r1; \\<not> One < r1\\<rbrakk>\n  \\<Longrightarrow> ACI (Plus r1 (ACI_nPlus One r2)) (Plus r1 (Plus s1 r2))\n  \\<lbrakk>One \\<noteq> r1; \\<not> One < r1; ACI One ?s1.0;\n   ACI r2 ?s2.0\\<rbrakk>\n  \\<Longrightarrow> ACI (ACI_nPlus One r2) (Plus ?s1.0 ?s2.0)\n  ACI One s1\n  ACI (Plus r1 r2) s2", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>One \\<noteq> r1; \\<not> One < r1\\<rbrakk>\n  \\<Longrightarrow> ACI (Plus r1 (ACI_nPlus One r2)) (Plus r1 (Plus s1 r2))\n  \\<lbrakk>One \\<noteq> r1; \\<not> One < r1; ACI One ?s1.0;\n   ACI r2 ?s2.0\\<rbrakk>\n  \\<Longrightarrow> ACI (ACI_nPlus One r2) (Plus ?s1.0 ?s2.0)\n  ACI One s1\n  ACI (Plus r1 r2) s2\n\ngoal (1 subgoal):\n 1. ACI (ACI_nPlus One (Plus r1 r2)) (Plus s1 s2)", "by (auto intro: ACI.intros)"], ["proof (state)\nthis:\n  ACI (ACI_nPlus One (Plus r1 r2)) (Plus s1 s2)\n\ngoal (28 subgoals):\n 1. \\<And>v s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Atom v \\<noteq> s1; \\<not> Atom v < s1;\n                    ACI (Atom v) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Atom v) s2)\n(Plus s1a s2a);\n        ACI (Atom v) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Atom v) (Plus s1 s2))\n                          (Plus s1a s2a)\n 2. \\<And>v va s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Times v va \\<noteq> s1; \\<not> Times v va < s1;\n                    ACI (Times v va) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Times v va) s2)\n(Plus s1a s2a);\n        ACI (Times v va) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Times v va) (Plus s1 s2))\n                          (Plus s1a s2a)\n 3. \\<And>v s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Star v \\<noteq> s1; \\<not> Star v < s1;\n                    ACI (Star v) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Star v) s2)\n(Plus s1a s2a);\n        ACI (Star v) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Star v) (Plus s1 s2))\n                          (Plus s1a s2a)\n 4. \\<And>s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI Zero s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero Zero) (Plus s1 s2)\n 5. \\<And>s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI One s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero One) (Plus s1 s2)\n 6. \\<And>v s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Atom v) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Atom v)) (Plus s1 s2)\n 7. \\<And>v va s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Times v va) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Times v va)) (Plus s1 s2)\n 8. \\<And>v s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Star v) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Star v)) (Plus s1 s2)\n 9. \\<And>s1 s2.\n       \\<lbrakk>ACI One s1; ACI Zero s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus One Zero) (Plus s1 s2)\n 10. \\<And>s1 s2.\n        \\<lbrakk>ACI One s1; ACI One s2\\<rbrakk>\n        \\<Longrightarrow> ACI (ACI_nPlus One One) (Plus s1 s2)\nA total of 28 subgoals...", "next"], ["proof (state)\ngoal (28 subgoals):\n 1. \\<And>v s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Atom v \\<noteq> s1; \\<not> Atom v < s1;\n                    ACI (Atom v) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Atom v) s2)\n(Plus s1a s2a);\n        ACI (Atom v) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Atom v) (Plus s1 s2))\n                          (Plus s1a s2a)\n 2. \\<And>v va s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Times v va \\<noteq> s1; \\<not> Times v va < s1;\n                    ACI (Times v va) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Times v va) s2)\n(Plus s1a s2a);\n        ACI (Times v va) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Times v va) (Plus s1 s2))\n                          (Plus s1a s2a)\n 3. \\<And>v s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Star v \\<noteq> s1; \\<not> Star v < s1;\n                    ACI (Star v) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Star v) s2)\n(Plus s1a s2a);\n        ACI (Star v) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Star v) (Plus s1 s2))\n                          (Plus s1a s2a)\n 4. \\<And>s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI Zero s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero Zero) (Plus s1 s2)\n 5. \\<And>s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI One s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero One) (Plus s1 s2)\n 6. \\<And>v s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Atom v) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Atom v)) (Plus s1 s2)\n 7. \\<And>v va s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Times v va) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Times v va)) (Plus s1 s2)\n 8. \\<And>v s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Star v) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Star v)) (Plus s1 s2)\n 9. \\<And>s1 s2.\n       \\<lbrakk>ACI One s1; ACI Zero s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus One Zero) (Plus s1 s2)\n 10. \\<And>s1 s2.\n        \\<lbrakk>ACI One s1; ACI One s2\\<rbrakk>\n        \\<Longrightarrow> ACI (ACI_nPlus One One) (Plus s1 s2)\nA total of 28 subgoals...", "case (\"2_3\" _ r1 r2)"], ["proof (state)\nthis:\n  \\<lbrakk>Atom v_ \\<noteq> r1; \\<not> Atom v_ < r1; ACI (Atom v_) ?s1.0;\n   ACI r2 ?s2.0\\<rbrakk>\n  \\<Longrightarrow> ACI (ACI_nPlus (Atom v_) r2) (Plus ?s1.0 ?s2.0)\n  ACI (Atom v_) s1\n  ACI (Plus r1 r2) s2\n\ngoal (28 subgoals):\n 1. \\<And>v s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Atom v \\<noteq> s1; \\<not> Atom v < s1;\n                    ACI (Atom v) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Atom v) s2)\n(Plus s1a s2a);\n        ACI (Atom v) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Atom v) (Plus s1 s2))\n                          (Plus s1a s2a)\n 2. \\<And>v va s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Times v va \\<noteq> s1; \\<not> Times v va < s1;\n                    ACI (Times v va) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Times v va) s2)\n(Plus s1a s2a);\n        ACI (Times v va) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Times v va) (Plus s1 s2))\n                          (Plus s1a s2a)\n 3. \\<And>v s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Star v \\<noteq> s1; \\<not> Star v < s1;\n                    ACI (Star v) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Star v) s2)\n(Plus s1a s2a);\n        ACI (Star v) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Star v) (Plus s1 s2))\n                          (Plus s1a s2a)\n 4. \\<And>s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI Zero s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero Zero) (Plus s1 s2)\n 5. \\<And>s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI One s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero One) (Plus s1 s2)\n 6. \\<And>v s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Atom v) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Atom v)) (Plus s1 s2)\n 7. \\<And>v va s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Times v va) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Times v va)) (Plus s1 s2)\n 8. \\<And>v s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Star v) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Star v)) (Plus s1 s2)\n 9. \\<And>s1 s2.\n       \\<lbrakk>ACI One s1; ACI Zero s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus One Zero) (Plus s1 s2)\n 10. \\<And>s1 s2.\n        \\<lbrakk>ACI One s1; ACI One s2\\<rbrakk>\n        \\<Longrightarrow> ACI (ACI_nPlus One One) (Plus s1 s2)\nA total of 28 subgoals...", "with ACI_Plus_cong[OF ACI_refl \"2_3\"(1)[OF _ _ \"2_3\"(2) ACI_refl], of r1]"], ["proof (chain)\npicking this:\n  \\<lbrakk>Atom v_ \\<noteq> r1; \\<not> Atom v_ < r1\\<rbrakk>\n  \\<Longrightarrow> ACI (Plus r1 (ACI_nPlus (Atom v_) r2))\n                     (Plus r1 (Plus s1 r2))\n  \\<lbrakk>Atom v_ \\<noteq> r1; \\<not> Atom v_ < r1; ACI (Atom v_) ?s1.0;\n   ACI r2 ?s2.0\\<rbrakk>\n  \\<Longrightarrow> ACI (ACI_nPlus (Atom v_) r2) (Plus ?s1.0 ?s2.0)\n  ACI (Atom v_) s1\n  ACI (Plus r1 r2) s2", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>Atom v_ \\<noteq> r1; \\<not> Atom v_ < r1\\<rbrakk>\n  \\<Longrightarrow> ACI (Plus r1 (ACI_nPlus (Atom v_) r2))\n                     (Plus r1 (Plus s1 r2))\n  \\<lbrakk>Atom v_ \\<noteq> r1; \\<not> Atom v_ < r1; ACI (Atom v_) ?s1.0;\n   ACI r2 ?s2.0\\<rbrakk>\n  \\<Longrightarrow> ACI (ACI_nPlus (Atom v_) r2) (Plus ?s1.0 ?s2.0)\n  ACI (Atom v_) s1\n  ACI (Plus r1 r2) s2\n\ngoal (1 subgoal):\n 1. ACI (ACI_nPlus (Atom v_) (Plus r1 r2)) (Plus s1 s2)", "by (auto intro: ACI.intros)"], ["proof (state)\nthis:\n  ACI (ACI_nPlus (Atom v_) (Plus r1 r2)) (Plus s1 s2)\n\ngoal (27 subgoals):\n 1. \\<And>v va s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Times v va \\<noteq> s1; \\<not> Times v va < s1;\n                    ACI (Times v va) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Times v va) s2)\n(Plus s1a s2a);\n        ACI (Times v va) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Times v va) (Plus s1 s2))\n                          (Plus s1a s2a)\n 2. \\<And>v s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Star v \\<noteq> s1; \\<not> Star v < s1;\n                    ACI (Star v) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Star v) s2)\n(Plus s1a s2a);\n        ACI (Star v) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Star v) (Plus s1 s2))\n                          (Plus s1a s2a)\n 3. \\<And>s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI Zero s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero Zero) (Plus s1 s2)\n 4. \\<And>s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI One s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero One) (Plus s1 s2)\n 5. \\<And>v s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Atom v) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Atom v)) (Plus s1 s2)\n 6. \\<And>v va s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Times v va) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Times v va)) (Plus s1 s2)\n 7. \\<And>v s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Star v) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Star v)) (Plus s1 s2)\n 8. \\<And>s1 s2.\n       \\<lbrakk>ACI One s1; ACI Zero s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus One Zero) (Plus s1 s2)\n 9. \\<And>s1 s2.\n       \\<lbrakk>ACI One s1; ACI One s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus One One) (Plus s1 s2)\n 10. \\<And>v s1 s2.\n        \\<lbrakk>ACI One s1; ACI (Atom v) s2\\<rbrakk>\n        \\<Longrightarrow> ACI (ACI_nPlus One (Atom v)) (Plus s1 s2)\nA total of 27 subgoals...", "next"], ["proof (state)\ngoal (27 subgoals):\n 1. \\<And>v va s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Times v va \\<noteq> s1; \\<not> Times v va < s1;\n                    ACI (Times v va) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Times v va) s2)\n(Plus s1a s2a);\n        ACI (Times v va) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Times v va) (Plus s1 s2))\n                          (Plus s1a s2a)\n 2. \\<And>v s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Star v \\<noteq> s1; \\<not> Star v < s1;\n                    ACI (Star v) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Star v) s2)\n(Plus s1a s2a);\n        ACI (Star v) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Star v) (Plus s1 s2))\n                          (Plus s1a s2a)\n 3. \\<And>s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI Zero s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero Zero) (Plus s1 s2)\n 4. \\<And>s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI One s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero One) (Plus s1 s2)\n 5. \\<And>v s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Atom v) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Atom v)) (Plus s1 s2)\n 6. \\<And>v va s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Times v va) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Times v va)) (Plus s1 s2)\n 7. \\<And>v s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Star v) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Star v)) (Plus s1 s2)\n 8. \\<And>s1 s2.\n       \\<lbrakk>ACI One s1; ACI Zero s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus One Zero) (Plus s1 s2)\n 9. \\<And>s1 s2.\n       \\<lbrakk>ACI One s1; ACI One s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus One One) (Plus s1 s2)\n 10. \\<And>v s1 s2.\n        \\<lbrakk>ACI One s1; ACI (Atom v) s2\\<rbrakk>\n        \\<Longrightarrow> ACI (ACI_nPlus One (Atom v)) (Plus s1 s2)\nA total of 27 subgoals...", "case (\"2_4\" _ _ r1 r2)"], ["proof (state)\nthis:\n  \\<lbrakk>Times v_ va_ \\<noteq> r1; \\<not> Times v_ va_ < r1;\n   ACI (Times v_ va_) ?s1.0; ACI r2 ?s2.0\\<rbrakk>\n  \\<Longrightarrow> ACI (ACI_nPlus (Times v_ va_) r2) (Plus ?s1.0 ?s2.0)\n  ACI (Times v_ va_) s1\n  ACI (Plus r1 r2) s2\n\ngoal (27 subgoals):\n 1. \\<And>v va s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Times v va \\<noteq> s1; \\<not> Times v va < s1;\n                    ACI (Times v va) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Times v va) s2)\n(Plus s1a s2a);\n        ACI (Times v va) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Times v va) (Plus s1 s2))\n                          (Plus s1a s2a)\n 2. \\<And>v s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Star v \\<noteq> s1; \\<not> Star v < s1;\n                    ACI (Star v) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Star v) s2)\n(Plus s1a s2a);\n        ACI (Star v) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Star v) (Plus s1 s2))\n                          (Plus s1a s2a)\n 3. \\<And>s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI Zero s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero Zero) (Plus s1 s2)\n 4. \\<And>s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI One s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero One) (Plus s1 s2)\n 5. \\<And>v s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Atom v) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Atom v)) (Plus s1 s2)\n 6. \\<And>v va s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Times v va) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Times v va)) (Plus s1 s2)\n 7. \\<And>v s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Star v) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Star v)) (Plus s1 s2)\n 8. \\<And>s1 s2.\n       \\<lbrakk>ACI One s1; ACI Zero s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus One Zero) (Plus s1 s2)\n 9. \\<And>s1 s2.\n       \\<lbrakk>ACI One s1; ACI One s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus One One) (Plus s1 s2)\n 10. \\<And>v s1 s2.\n        \\<lbrakk>ACI One s1; ACI (Atom v) s2\\<rbrakk>\n        \\<Longrightarrow> ACI (ACI_nPlus One (Atom v)) (Plus s1 s2)\nA total of 27 subgoals...", "with ACI_Plus_cong[OF ACI_refl \"2_4\"(1)[OF _ _ \"2_4\"(2) ACI_refl], of r1]"], ["proof (chain)\npicking this:\n  \\<lbrakk>Times v_ va_ \\<noteq> r1; \\<not> Times v_ va_ < r1\\<rbrakk>\n  \\<Longrightarrow> ACI (Plus r1 (ACI_nPlus (Times v_ va_) r2))\n                     (Plus r1 (Plus s1 r2))\n  \\<lbrakk>Times v_ va_ \\<noteq> r1; \\<not> Times v_ va_ < r1;\n   ACI (Times v_ va_) ?s1.0; ACI r2 ?s2.0\\<rbrakk>\n  \\<Longrightarrow> ACI (ACI_nPlus (Times v_ va_) r2) (Plus ?s1.0 ?s2.0)\n  ACI (Times v_ va_) s1\n  ACI (Plus r1 r2) s2", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>Times v_ va_ \\<noteq> r1; \\<not> Times v_ va_ < r1\\<rbrakk>\n  \\<Longrightarrow> ACI (Plus r1 (ACI_nPlus (Times v_ va_) r2))\n                     (Plus r1 (Plus s1 r2))\n  \\<lbrakk>Times v_ va_ \\<noteq> r1; \\<not> Times v_ va_ < r1;\n   ACI (Times v_ va_) ?s1.0; ACI r2 ?s2.0\\<rbrakk>\n  \\<Longrightarrow> ACI (ACI_nPlus (Times v_ va_) r2) (Plus ?s1.0 ?s2.0)\n  ACI (Times v_ va_) s1\n  ACI (Plus r1 r2) s2\n\ngoal (1 subgoal):\n 1. ACI (ACI_nPlus (Times v_ va_) (Plus r1 r2)) (Plus s1 s2)", "by (auto intro: ACI.intros)"], ["proof (state)\nthis:\n  ACI (ACI_nPlus (Times v_ va_) (Plus r1 r2)) (Plus s1 s2)\n\ngoal (26 subgoals):\n 1. \\<And>v s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Star v \\<noteq> s1; \\<not> Star v < s1;\n                    ACI (Star v) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Star v) s2)\n(Plus s1a s2a);\n        ACI (Star v) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Star v) (Plus s1 s2))\n                          (Plus s1a s2a)\n 2. \\<And>s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI Zero s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero Zero) (Plus s1 s2)\n 3. \\<And>s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI One s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero One) (Plus s1 s2)\n 4. \\<And>v s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Atom v) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Atom v)) (Plus s1 s2)\n 5. \\<And>v va s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Times v va) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Times v va)) (Plus s1 s2)\n 6. \\<And>v s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Star v) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Star v)) (Plus s1 s2)\n 7. \\<And>s1 s2.\n       \\<lbrakk>ACI One s1; ACI Zero s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus One Zero) (Plus s1 s2)\n 8. \\<And>s1 s2.\n       \\<lbrakk>ACI One s1; ACI One s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus One One) (Plus s1 s2)\n 9. \\<And>v s1 s2.\n       \\<lbrakk>ACI One s1; ACI (Atom v) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus One (Atom v)) (Plus s1 s2)\n 10. \\<And>v va s1 s2.\n        \\<lbrakk>ACI One s1; ACI (Times v va) s2\\<rbrakk>\n        \\<Longrightarrow> ACI (ACI_nPlus One (Times v va)) (Plus s1 s2)\nA total of 26 subgoals...", "next"], ["proof (state)\ngoal (26 subgoals):\n 1. \\<And>v s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Star v \\<noteq> s1; \\<not> Star v < s1;\n                    ACI (Star v) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Star v) s2)\n(Plus s1a s2a);\n        ACI (Star v) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Star v) (Plus s1 s2))\n                          (Plus s1a s2a)\n 2. \\<And>s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI Zero s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero Zero) (Plus s1 s2)\n 3. \\<And>s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI One s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero One) (Plus s1 s2)\n 4. \\<And>v s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Atom v) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Atom v)) (Plus s1 s2)\n 5. \\<And>v va s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Times v va) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Times v va)) (Plus s1 s2)\n 6. \\<And>v s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Star v) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Star v)) (Plus s1 s2)\n 7. \\<And>s1 s2.\n       \\<lbrakk>ACI One s1; ACI Zero s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus One Zero) (Plus s1 s2)\n 8. \\<And>s1 s2.\n       \\<lbrakk>ACI One s1; ACI One s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus One One) (Plus s1 s2)\n 9. \\<And>v s1 s2.\n       \\<lbrakk>ACI One s1; ACI (Atom v) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus One (Atom v)) (Plus s1 s2)\n 10. \\<And>v va s1 s2.\n        \\<lbrakk>ACI One s1; ACI (Times v va) s2\\<rbrakk>\n        \\<Longrightarrow> ACI (ACI_nPlus One (Times v va)) (Plus s1 s2)\nA total of 26 subgoals...", "case (\"2_5\" _ r1 r2)"], ["proof (state)\nthis:\n  \\<lbrakk>Star v_ \\<noteq> r1; \\<not> Star v_ < r1; ACI (Star v_) ?s1.0;\n   ACI r2 ?s2.0\\<rbrakk>\n  \\<Longrightarrow> ACI (ACI_nPlus (Star v_) r2) (Plus ?s1.0 ?s2.0)\n  ACI (Star v_) s1\n  ACI (Plus r1 r2) s2\n\ngoal (26 subgoals):\n 1. \\<And>v s1 s2 s1a s2a.\n       \\<lbrakk>\\<And>s1a s2a.\n                   \\<lbrakk>Star v \\<noteq> s1; \\<not> Star v < s1;\n                    ACI (Star v) s1a; ACI s2 s2a\\<rbrakk>\n                   \\<Longrightarrow> ACI (ACI_nPlus (Star v) s2)\n(Plus s1a s2a);\n        ACI (Star v) s1a; ACI (Plus s1 s2) s2a\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus (Star v) (Plus s1 s2))\n                          (Plus s1a s2a)\n 2. \\<And>s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI Zero s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero Zero) (Plus s1 s2)\n 3. \\<And>s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI One s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero One) (Plus s1 s2)\n 4. \\<And>v s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Atom v) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Atom v)) (Plus s1 s2)\n 5. \\<And>v va s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Times v va) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Times v va)) (Plus s1 s2)\n 6. \\<And>v s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Star v) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Star v)) (Plus s1 s2)\n 7. \\<And>s1 s2.\n       \\<lbrakk>ACI One s1; ACI Zero s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus One Zero) (Plus s1 s2)\n 8. \\<And>s1 s2.\n       \\<lbrakk>ACI One s1; ACI One s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus One One) (Plus s1 s2)\n 9. \\<And>v s1 s2.\n       \\<lbrakk>ACI One s1; ACI (Atom v) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus One (Atom v)) (Plus s1 s2)\n 10. \\<And>v va s1 s2.\n        \\<lbrakk>ACI One s1; ACI (Times v va) s2\\<rbrakk>\n        \\<Longrightarrow> ACI (ACI_nPlus One (Times v va)) (Plus s1 s2)\nA total of 26 subgoals...", "with ACI_Plus_cong[OF ACI_refl \"2_5\"(1)[OF _ _ \"2_5\"(2) ACI_refl], of r1]"], ["proof (chain)\npicking this:\n  \\<lbrakk>Star v_ \\<noteq> r1; \\<not> Star v_ < r1\\<rbrakk>\n  \\<Longrightarrow> ACI (Plus r1 (ACI_nPlus (Star v_) r2))\n                     (Plus r1 (Plus s1 r2))\n  \\<lbrakk>Star v_ \\<noteq> r1; \\<not> Star v_ < r1; ACI (Star v_) ?s1.0;\n   ACI r2 ?s2.0\\<rbrakk>\n  \\<Longrightarrow> ACI (ACI_nPlus (Star v_) r2) (Plus ?s1.0 ?s2.0)\n  ACI (Star v_) s1\n  ACI (Plus r1 r2) s2", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>Star v_ \\<noteq> r1; \\<not> Star v_ < r1\\<rbrakk>\n  \\<Longrightarrow> ACI (Plus r1 (ACI_nPlus (Star v_) r2))\n                     (Plus r1 (Plus s1 r2))\n  \\<lbrakk>Star v_ \\<noteq> r1; \\<not> Star v_ < r1; ACI (Star v_) ?s1.0;\n   ACI r2 ?s2.0\\<rbrakk>\n  \\<Longrightarrow> ACI (ACI_nPlus (Star v_) r2) (Plus ?s1.0 ?s2.0)\n  ACI (Star v_) s1\n  ACI (Plus r1 r2) s2\n\ngoal (1 subgoal):\n 1. ACI (ACI_nPlus (Star v_) (Plus r1 r2)) (Plus s1 s2)", "by (auto intro: ACI.intros)"], ["proof (state)\nthis:\n  ACI (ACI_nPlus (Star v_) (Plus r1 r2)) (Plus s1 s2)\n\ngoal (25 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI Zero s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero Zero) (Plus s1 s2)\n 2. \\<And>s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI One s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero One) (Plus s1 s2)\n 3. \\<And>v s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Atom v) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Atom v)) (Plus s1 s2)\n 4. \\<And>v va s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Times v va) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Times v va)) (Plus s1 s2)\n 5. \\<And>v s1 s2.\n       \\<lbrakk>ACI Zero s1; ACI (Star v) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus Zero (Star v)) (Plus s1 s2)\n 6. \\<And>s1 s2.\n       \\<lbrakk>ACI One s1; ACI Zero s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus One Zero) (Plus s1 s2)\n 7. \\<And>s1 s2.\n       \\<lbrakk>ACI One s1; ACI One s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus One One) (Plus s1 s2)\n 8. \\<And>v s1 s2.\n       \\<lbrakk>ACI One s1; ACI (Atom v) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus One (Atom v)) (Plus s1 s2)\n 9. \\<And>v va s1 s2.\n       \\<lbrakk>ACI One s1; ACI (Times v va) s2\\<rbrakk>\n       \\<Longrightarrow> ACI (ACI_nPlus One (Times v va)) (Plus s1 s2)\n 10. \\<And>v s1 s2.\n        \\<lbrakk>ACI One s1; ACI (Star v) s2\\<rbrakk>\n        \\<Longrightarrow> ACI (ACI_nPlus One (Star v)) (Plus s1 s2)\nA total of 25 subgoals...", "qed (auto intro: ACI.intros)"], ["", "lemma ACI_ACI_norm: \"ACI \\<guillemotleft>r\\<guillemotright> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ACI \\<guillemotleft>r\\<guillemotright> r", "unfolding ACI_norm_alt[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ACI (ACI_norm_alt r) r", "by (induct r) (auto intro: ACI.intros simp: ACI_ACI_nPlus)"], ["", "lemma ACI_norm_eqI: \"ACI r s \\<Longrightarrow> \\<guillemotleft>r\\<guillemotright> = \\<guillemotleft>s\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ACI r s \\<Longrightarrow>\n    \\<guillemotleft>r\\<guillemotright> = \\<guillemotleft>s\\<guillemotright>", "by (induct rule: ACI.induct) (auto simp: toplevel_summands_ACI_norm ACI_norm_flatten[symmetric]\n    toplevel_summands_flatten_ACI_norm_image_Union ac_simps)"], ["", "lemma ACI_I: \"\\<guillemotleft>r\\<guillemotright> = \\<guillemotleft>s\\<guillemotright> \\<Longrightarrow> ACI r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>r\\<guillemotright> =\n    \\<guillemotleft>s\\<guillemotright> \\<Longrightarrow>\n    ACI r s", "by (metis ACI_ACI_norm ACI_sym ACI_trans)"], ["", "lemma ACI_decidable: \"ACI r s = (\\<guillemotleft>r\\<guillemotright> = \\<guillemotleft>s\\<guillemotright>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ACI r s =\n    (\\<guillemotleft>r\\<guillemotright> =\n     \\<guillemotleft>s\\<guillemotright>)", "by (metis ACI_I ACI_norm_eqI)"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}