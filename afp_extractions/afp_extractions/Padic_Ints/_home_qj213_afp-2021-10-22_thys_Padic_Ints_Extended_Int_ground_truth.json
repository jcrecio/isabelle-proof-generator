{"file_name": "/home/qj213/afp-2021-10-22/thys/Padic_Ints/Extended_Int.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Padic_Ints", "problem_names": ["lemma sums_SUP[simp, intro]: \"f sums (SUP n. \\<Sum>i<n. f i)\"", "lemma suminf_eq_SUP: \"suminf f = (SUP n. \\<Sum>i<n. f i)\"", "lemma int_option_enumeration_inj:\n\"inj int_option_enumeration\"", "lemma eint_enumeration_inj:\n\"inj eint_enumeration\"", "lemmas eint2_cases = eint.exhaust[case_product eint.exhaust]", "lemmas eint3_cases = eint.exhaust[case_product eint.exhaust eint.exhaust]", "lemma not_infinity_eq [iff]: \"(x \\<noteq> \\<infinity>) = (\\<exists>i. x = eint i)\"", "lemma not_eint_eq [iff]: \"(\\<forall>y. x \\<noteq> eint y) = (x = \\<infinity>)\"", "lemma eint_ex_split: \"(\\<exists>c::eint. P c) \\<longleftrightarrow> P \\<infinity> \\<or> (\\<exists>c::int. P c)\"", "lemma eint_0 [code_post]: \"eint 0 = 0\"", "lemma eint_1 [code_post]: \"eint 1 = 1\"", "lemma eint_0_iff: \"eint x = 0 \\<longleftrightarrow> x = 0\" \"0 = eint x \\<longleftrightarrow> x = 0\"", "lemma eint_1_iff: \"eint x = 1 \\<longleftrightarrow> x = 1\" \"1 = eint x \\<longleftrightarrow> x = 1\"", "lemma infinity_ne_i0 [simp]: \"(\\<infinity>::eint) \\<noteq> 0\"", "lemma i0_ne_infinity [simp]: \"0 \\<noteq> (\\<infinity>::eint)\"", "lemma zero_one_eint_neq:\n  \"\\<not> 0 = (1::eint)\"\n  \"\\<not> 1 = (0::eint)\"", "lemma infinity_ne_i1 [simp]: \"(\\<infinity>::eint) \\<noteq> 1\"", "lemma i1_ne_infinity [simp]: \"1 \\<noteq> (\\<infinity>::eint)\"", "lemma plus_eint_simps [simp, code]:\n  fixes q :: eint\n  shows \"eint m + eint n = eint (m + n)\"\n    and \"\\<infinity> + q = \\<infinity>\"\n    and \"q + \\<infinity> = \\<infinity>\"", "lemma eSuc_eint: \"(eint n) + 1 = eint (n + 1)\"", "lemma eSuc_infinity [simp]: \" \\<infinity> + (1::eint) = \\<infinity>\"", "lemma eSuc_inject [simp]: \" m + (1::eint)=  n + 1 \\<longleftrightarrow> m = n\"", "lemma eSuc_eint_iff: \"x + 1 = eint y \\<longleftrightarrow> (\\<exists>n. y = n + 1 \\<and> x = eint n)\"", "lemma enat_eSuc_iff: \"eint y = x + 1 \\<longleftrightarrow> (\\<exists>n. y = n + 1 \\<and> eint n = x)\"", "lemma iadd_Suc: \"((m::eint) + 1) + n = (m + n) + 1\"", "lemma iadd_Suc_right: \"(m::eint) + (n + 1) = (m + n) + 1\"", "lemma times_eint_simps [simp, code]:\n  \"eint m * eint n = eint (m * n)\"\n  \"\\<infinity> * \\<infinity> = (\\<infinity>::eint)\"\n  \"\\<infinity> * eint n = \\<infinity>\"\n  \"eint m * \\<infinity> = \\<infinity>\"", "lemma sum_infinity_imp_summand_infinity:\n  assumes \"a + b = (\\<infinity>::eint)\"\n  shows \"a = \\<infinity> \\<or> b = \\<infinity>\"", "lemma sum_finite_imp_summands_finite:\n  assumes \"a + b \\<noteq> (\\<infinity>::eint)\"\n  shows \"a \\<noteq> \\<infinity>\" \"b \\<noteq> \\<infinity>\"", "lemma mult_one_right[simp]:\n\"(n::eint)*1 = n\"", "lemma mult_one_left[simp]:\n\"1*(n::eint) = n\"", "lemma mult_eSuc: \"((m::eint) + 1) * n = m * n + n\"", "lemma mult_eSuc': \"((m::eint) + 1) * n = n + m * n\"", "lemma mult_eSuc_right: \"(m::eint) * (n + 1) =  m * n +  m \"", "lemma mult_eSuc_right': \"(m::eint) * (n + 1) =  m + m * n  \"", "lemma numeral_eq_eint:\n  \"numeral k = eint (numeral k)\"", "lemma eint_numeral [code_abbrev]:\n  \"eint (numeral k) = numeral k\"", "lemma infinity_ne_numeral [simp]: \"(\\<infinity>::eint) \\<noteq> numeral k\"", "lemma numeral_ne_infinity [simp]: \"numeral k \\<noteq> (\\<infinity>::eint)\"", "lemma idiff_eint_eint [simp, code]: \"eint a - eint b = eint (a - b)\"", "lemma idiff_infinity [simp, code]: \"\\<infinity> - n = (\\<infinity>::eint)\"", "lemma idiff_infinity_right [simp, code]: \"eint a - \\<infinity> = \\<infinity>\"", "lemma idiff_0 [simp]: \"(0::eint) - n = -n\"", "lemmas idiff_eint_0 [simp] = idiff_0 [unfolded zero_eint_def]", "lemma idiff_0_right [simp]: \"(n::eint) - 0 = n\"", "lemmas idiff_eint_0_right [simp] = idiff_0_right [unfolded zero_eint_def]", "lemma idiff_self [simp]: \"n \\<noteq> \\<infinity> \\<Longrightarrow> (n::eint) - n = 0\"", "lemma eSuc_minus_eSuc [simp]: \"((n::eint) + 1) - (m + 1) = n - m\"", "lemma eSuc_minus_1 [simp]: \"((n::eint)+ 1) - 1 = n\"", "lemma eint_ord_simps [simp]:\n  \"eint m \\<le> eint n \\<longleftrightarrow> m \\<le> n\"\n  \"eint m < eint n \\<longleftrightarrow> m < n\"\n  \"q \\<le> (\\<infinity>::eint)\"\n  \"q < (\\<infinity>::eint) \\<longleftrightarrow> q \\<noteq> \\<infinity>\"\n  \"(\\<infinity>::eint) \\<le> q \\<longleftrightarrow> q = \\<infinity>\"\n  \"(\\<infinity>::eint) < q \\<longleftrightarrow> False\"", "lemma numeral_le_eint_iff[simp]:\n  shows \"numeral m \\<le> eint n \\<longleftrightarrow> numeral m \\<le> n\"", "lemma numeral_less_eint_iff[simp]:\n  shows \"numeral m < eint n \\<longleftrightarrow> numeral m < n\"", "lemma eint_ord_code [code]:\n  \"eint m \\<le> eint n \\<longleftrightarrow> m \\<le> n\"\n  \"eint m < eint n \\<longleftrightarrow> m < n\"\n  \"q \\<le> (\\<infinity>::eint) \\<longleftrightarrow> True\"\n  \"eint m < \\<infinity> \\<longleftrightarrow> True\"\n  \"\\<infinity> \\<le> eint n \\<longleftrightarrow> False\"\n  \"(\\<infinity>::eint) < q \\<longleftrightarrow> False\"", "lemma eint_ord_plus_one[simp]:\n  assumes \"eint n \\<le> x\"\n  assumes \"x < y\"\n  shows \"eint (n + 1) \\<le> y\"", "lemma add_diff_assoc_eint: \"z \\<le> y \\<Longrightarrow> x + (y - z) = x + y - (z::eint)\"", "lemma eint_ord_number [simp]:\n  \"(numeral m :: eint) \\<le> numeral n \\<longleftrightarrow> (numeral m :: nat) \\<le> numeral n\"\n  \"(numeral m :: eint) < numeral n \\<longleftrightarrow> (numeral m :: nat) < numeral n\"", "lemma infinity_ileE [elim!]: \"\\<infinity> \\<le> eint m \\<Longrightarrow> R\"", "lemma infinity_ilessE [elim!]: \"\\<infinity> < eint m \\<Longrightarrow> R\"", "lemma imult_infinity: \"(0::eint) < n \\<Longrightarrow> \\<infinity> * n = \\<infinity>\"", "lemma imult_infinity_right: \"(0::eint) < n \\<Longrightarrow> n * \\<infinity> = \\<infinity>\"", "lemma min_eint_simps [simp]:\n  \"min (eint m) (eint n) = eint (min m n)\"\n  \"min q (\\<infinity>::eint) = q\"\n  \"min (\\<infinity>::eint) q = q\"", "lemma max_eint_simps [simp]:\n  \"max (eint m) (eint n) = eint (max m n)\"\n  \"max q \\<infinity> = (\\<infinity>::eint)\"\n  \"max \\<infinity> q = (\\<infinity>::eint)\"", "lemma eint_ile: \"n \\<le> eint m \\<Longrightarrow> \\<exists>k. n = eint k\"", "lemma eint_iless: \"n < eint m \\<Longrightarrow> \\<exists>k. n = eint k\"", "lemma iadd_le_eint_iff:\n  \"x + y \\<le> eint n \\<longleftrightarrow> (\\<exists>y' x'. x = eint x' \\<and> y = eint y' \\<and> x' + y' \\<le> n)\"", "lemma chain_incr: \"\\<forall>i. \\<exists>j. Y i < Y j \\<Longrightarrow> \\<exists>j. eint k < Y j\"", "lemma eint_ord_Suc:\n  assumes \"(x::eint) < y\"\n  shows \"x + 1 < y + 1\"", "lemma eSuc_ile_mono [simp]: \"(n::eint) + 1 \\<le> m+ 1 \\<longleftrightarrow> n \\<le> m\"", "lemma eSuc_mono [simp]: \"(n::eint) + 1 < m+ 1 \\<longleftrightarrow> n < m\"", "lemma ile_eSuc [simp]: \"(n::eint) \\<le> n + 1\"", "lemma ileI1: \"(m::eint) < n \\<Longrightarrow> m + 1 \\<le> n\"", "lemma Suc_ile_eq: \"eint (m +1) \\<le> n \\<longleftrightarrow> eint m < n\"", "lemma iless_Suc_eq [simp]: \"eint m < n + 1 \\<longleftrightarrow> eint m \\<le> n\"", "lemma eSuc_max: \"(max (x::eint) y) + 1 = max (x+1) (y+1)\"", "lemma eSuc_Max:\n  assumes \"finite A\" \"A \\<noteq> ({}::eint set)\"\n  shows \" (Max A) + 1 = Max ((+)1 ` A)\"", "lemma finite_eint_bounded:\n  assumes le_fin: \"\\<And>y. y \\<in> A \\<Longrightarrow> eint m \\<le> y \\<and> y \\<le> eint n\"\n  shows \"finite A\"", "lemma add_diff_cancel_eint[simp]: \"x \\<noteq> \\<infinity> \\<Longrightarrow> x + y - x = (y::eint)\"", "lemma eint_add_left_cancel: \"a + b = a + c \\<longleftrightarrow> a = (\\<infinity>::eint) \\<or> b = c\"", "lemma eint_add_left_cancel_le: \"a + b \\<le> a + c \\<longleftrightarrow> a = (\\<infinity>::eint) \\<or> b \\<le> c\"", "lemma eint_add_left_cancel_less: \"a + b < a + c \\<longleftrightarrow> a \\<noteq> (\\<infinity>::eint) \\<and> b < c\"", "lemma plus_eq_infty_iff_eint: \"(m::eint) + n = \\<infinity> \\<longleftrightarrow> m=\\<infinity> \\<or> n=\\<infinity>\"", "lemma less_eintE:\n  \"[| n < eint m; !!k. n = eint k ==> k < m ==> P |] ==> P\"", "lemma less_infinityE:\n  \"[| n < \\<infinity>; !!k. n = eint k ==> P |] ==> P\"", "lemmas eint_defs = zero_eint_def one_eint_def \n  plus_eint_def less_eq_eint_def less_eint_def", "lemma eint_uminus_eq:\n\"(a::eint) + (-a) = a - a\"", "lemma eint_mult_mono:\n  assumes \"(c::eint) > 0 \\<and> c \\<noteq> \\<infinity>\"\n  assumes \"k > n\"\n  shows \"k*c > n*c\"", "lemma eint_mult_mono':\n  assumes \"(c::eint) \\<ge> 0 \\<and> c \\<noteq> \\<infinity>\"\n  assumes \"k > n\"\n  shows \"k*c \\<ge> n*c\"", "lemma eint_minus_le:\n  assumes \"(b::eint) < c\"\n  shows \"c - b > 0\"", "lemma eint_nat_times:\n  assumes \"(c::eint) > 0\"\n  shows \"(Suc n)*(c::eint) > 0\"", "lemma eint_pos_times_is_pos:\n  assumes \"(c::eint) > 0\"\n  assumes \"b > 0\"\n  shows \"b*c > 0\"", "lemma eint_nat_is_pos:\n\"eint (Suc n) > 0\"", "lemma eint_pow_int_is_pos:\n  assumes \"n > 0\"\n  shows \"eint n > 0\"", "lemma eint_nat_times':\n  assumes \"(c::eint) \\<ge> 0\"\n  shows \"(Suc n)*c \\<ge> 0\"", "lemma eint_pos_int_times_ge:\n  assumes \"(c::eint) \\<ge> 0\"\n  assumes \"n > 0\"\n  shows \"eint n * c \\<ge> c\"", "lemma eint_pos_int_times_gt:\n  assumes \"(c::eint) > 0\"\n  assumes \"c \\<noteq>\\<infinity>\"\n  assumes \"n > 1\"\n  shows \"eint n * c > c\"", "lemma eint_add_cancel_fact[simp]:\n  assumes \"(c::eint) \\<noteq> \\<infinity>\"\n  shows \"c + (b - c) = b\"", "lemma nat_mult_not_infty[simp]:\n  assumes \"c \\<noteq> \\<infinity>\"\n  shows \"(eint n) * c \\<noteq> \\<infinity>\"", "lemma eint_minus_distl:\n  assumes \"(b::eint) \\<noteq> d\"\n  shows \"b*c - d*c = (b-d)*c\"", "lemma eint_minus_distr:\n  assumes \"(b::eint) \\<noteq> d\"\n  shows \"c*(b - d) = c*b - c*d\"", "lemma eint_int_minus_distr:\n\"(eint n)*c - (eint m)*c = eint (n - m) * c\"", "lemma eint_2_minus_1_mult[simp]:\n\"2*(b::eint) - b = b\"", "lemma eint_minus_comm:\n\"(d::eint) + b - c = d - c + b\"", "lemma ge_plus_pos_imp_gt:\n  assumes \"(c::eint) \\<noteq>\\<infinity>\"\n  assumes \"(b::eint) > 0\"\n  assumes \"d \\<ge> c + b\"\n  shows \"d > c\"", "lemma eint_minus_ineq:\n  assumes \"(c::eint) \\<noteq>\\<infinity>\"\n  assumes \"b \\<ge> d\"\n  shows \"b - c \\<ge> d - c\"", "lemma eint_minus_ineq':\n  assumes \"(c::eint) \\<noteq>\\<infinity>\"\n  assumes \"b \\<ge> d\"\n  assumes \"(e::eint) > 0\"\n  assumes \"e \\<noteq> \\<infinity>\"\n  shows \"e*(b - c) \\<ge> e*(d - c)\"", "lemma eint_minus_ineq'':\n  assumes \"(c::eint) \\<noteq>\\<infinity>\"\n  assumes \"b \\<ge> d\"\n  assumes \"(e::eint) > 0\"\n  assumes \"e \\<noteq> \\<infinity>\"\n  shows \"e*(b - c) \\<ge> e*d - e*c\"", "lemma eint_min_ineq:\n  assumes \"(b::eint) \\<ge> min c d\"\n  assumes \"c > e\"\n  assumes \"d > e\"\n  shows \"b > e\"", "lemma eint_plus_times:\n  assumes \"(d::eint) \\<ge> 0\"\n  assumes \"(b::eint) \\<ge> c + (eint k)*d\"\n  assumes \"k \\<ge> l\"\n  shows \"b \\<ge> c + l*d\""], "translations": [["", "lemma sums_SUP[simp, intro]: \"f sums (SUP n. \\<Sum>i<n. f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f sums (SUP n. sum f {..<n})", "unfolding sums_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. sum f {..<n})\n    \\<longlonglongrightarrow> (SUP n. sum f {..<n})", "by (intro LIMSEQ_SUP monoI sum_mono2 zero_le) auto"], ["", "lemma suminf_eq_SUP: \"suminf f = (SUP n. \\<Sum>i<n. f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. suminf f = (SUP n. sum f {..<n})", "using sums_SUP"], ["proof (prove)\nusing this:\n  f sums (SUP n. sum f {..<n})\n\ngoal (1 subgoal):\n 1. suminf f = (SUP n. sum f {..<n})", "by (rule sums_unique[symmetric])"], ["", "end"], ["", "subsection \\<open>Type definition\\<close>"], ["", "text \\<open>\n  We extend the standard natural numbers by a special value indicating\n  infinity.\n\\<close>"], ["", "typedef eint = \"UNIV :: int option set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> UNIV", ".."], ["", "definition eint :: \"int \\<Rightarrow> eint\" where\n  \"eint n = Abs_eint (Some n)\""], ["", "instantiation eint :: infinity\nbegin"], ["", "definition \"\\<infinity> = Abs_eint None\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(eint, infinity_class)", ".."], ["", "end"], ["", "fun int_option_enumeration :: \"int option \\<Rightarrow> nat\" where\n\"int_option_enumeration (Some n) = (if n \\<ge> 0 then nat (2*(n + 1)) else  nat (2*(-n) + 1))\"|\n\"int_option_enumeration None = (0::nat)\""], ["", "lemma int_option_enumeration_inj:\n\"inj int_option_enumeration\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj int_option_enumeration", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV;\n        int_option_enumeration x = int_option_enumeration y\\<rbrakk>\n       \\<Longrightarrow> x = y", "have pos_even: \"\\<And>n::int. n \\<ge> 0 \\<Longrightarrow> even (int_option_enumeration (Some n)) \\<and> (int_option_enumeration (Some n))> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       0 \\<le> n \\<Longrightarrow>\n       even (int_option_enumeration (Some n)) \\<and>\n       0 < int_option_enumeration (Some n)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       0 \\<le> n \\<Longrightarrow>\n       even (int_option_enumeration (Some n)) \\<and>\n       0 < int_option_enumeration (Some n)", "fix n::int"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       0 \\<le> n \\<Longrightarrow>\n       even (int_option_enumeration (Some n)) \\<and>\n       0 < int_option_enumeration (Some n)", "assume \"n \\<ge>0\""], ["proof (state)\nthis:\n  0 \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       0 \\<le> n \\<Longrightarrow>\n       even (int_option_enumeration (Some n)) \\<and>\n       0 < int_option_enumeration (Some n)", "then"], ["proof (chain)\npicking this:\n  0 \\<le> n", "have \"(int_option_enumeration (Some n)) = nat (2*(n + 1))\""], ["proof (prove)\nusing this:\n  0 \\<le> n\n\ngoal (1 subgoal):\n 1. int_option_enumeration (Some n) = nat (2 * (n + 1))", "by simp"], ["proof (state)\nthis:\n  int_option_enumeration (Some n) = nat (2 * (n + 1))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       0 \\<le> n \\<Longrightarrow>\n       even (int_option_enumeration (Some n)) \\<and>\n       0 < int_option_enumeration (Some n)", "then"], ["proof (chain)\npicking this:\n  int_option_enumeration (Some n) = nat (2 * (n + 1))", "show \"even (int_option_enumeration (Some n)) \\<and> 0 < int_option_enumeration (Some n)\""], ["proof (prove)\nusing this:\n  int_option_enumeration (Some n) = nat (2 * (n + 1))\n\ngoal (1 subgoal):\n 1. even (int_option_enumeration (Some n)) \\<and>\n    0 < int_option_enumeration (Some n)", "by (smt \\<open>0 \\<le> n\\<close> even_of_nat int_nat_eq oddE zero_less_nat_eq)"], ["proof (state)\nthis:\n  even (int_option_enumeration (Some n)) \\<and>\n  0 < int_option_enumeration (Some n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 \\<le> ?n \\<Longrightarrow>\n  even (int_option_enumeration (Some ?n)) \\<and>\n  0 < int_option_enumeration (Some ?n)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV;\n        int_option_enumeration x = int_option_enumeration y\\<rbrakk>\n       \\<Longrightarrow> x = y", "have neg_odd: \"\\<And>n::int. n < 0 \\<Longrightarrow> odd (int_option_enumeration (Some n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. n < 0 \\<Longrightarrow> odd (int_option_enumeration (Some n))", "by (smt evenE even_of_nat int_nat_eq int_option_enumeration.simps(1))"], ["proof (state)\nthis:\n  ?n < 0 \\<Longrightarrow> odd (int_option_enumeration (Some ?n))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV;\n        int_option_enumeration x = int_option_enumeration y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV;\n        int_option_enumeration x = int_option_enumeration y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume A: \"x \\<in> UNIV\" \"y \\<in> UNIV\" \"int_option_enumeration x = int_option_enumeration y\""], ["proof (state)\nthis:\n  x \\<in> UNIV\n  y \\<in> UNIV\n  int_option_enumeration x = int_option_enumeration y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV;\n        int_option_enumeration x = int_option_enumeration y\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "apply(cases \"x = None\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. x = None \\<Longrightarrow> x = y\n 2. x \\<noteq> None \\<Longrightarrow> x = y", "using A pos_even neg_odd"], ["proof (prove)\nusing this:\n  x \\<in> UNIV\n  y \\<in> UNIV\n  int_option_enumeration x = int_option_enumeration y\n  0 \\<le> ?n \\<Longrightarrow>\n  even (int_option_enumeration (Some ?n)) \\<and>\n  0 < int_option_enumeration (Some ?n)\n  ?n < 0 \\<Longrightarrow> odd (int_option_enumeration (Some ?n))\n\ngoal (2 subgoals):\n 1. x = None \\<Longrightarrow> x = y\n 2. x \\<noteq> None \\<Longrightarrow> x = y", "apply (metis dvd_0_right int_option_enumeration.elims int_option_enumeration.simps(2) not_gr0 not_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> None \\<Longrightarrow> x = y", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> None \\<Longrightarrow> x = y", "assume \"x \\<noteq>None\""], ["proof (state)\nthis:\n  x \\<noteq> None\n\ngoal (1 subgoal):\n 1. x \\<noteq> None \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> None", "obtain n where n_def: \"x = Some n\""], ["proof (prove)\nusing this:\n  x \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>n. x = Some n \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  x = Some n\n\ngoal (1 subgoal):\n 1. x \\<noteq> None \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  x = Some n", "have y_not_None: \"y \\<noteq> None\""], ["proof (prove)\nusing this:\n  x = Some n\n\ngoal (1 subgoal):\n 1. y \\<noteq> None", "using A"], ["proof (prove)\nusing this:\n  x = Some n\n  x \\<in> UNIV\n  y \\<in> UNIV\n  int_option_enumeration x = int_option_enumeration y\n\ngoal (1 subgoal):\n 1. y \\<noteq> None", "by (metis \\<open>\\<And>thesis. (\\<And>n. x = Some n \\<Longrightarrow> thesis) \\<Longrightarrow> thesis\\<close>\n              add_cancel_right_right even_add int_option_enumeration.simps(2) \n              linorder_not_less neg_odd neq0_conv pos_even)"], ["proof (state)\nthis:\n  y \\<noteq> None\n\ngoal (1 subgoal):\n 1. x \\<noteq> None \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  y \\<noteq> None", "obtain m where m_def: \"y = Some m\""], ["proof (prove)\nusing this:\n  y \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>m. y = Some m \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  y = Some m\n\ngoal (1 subgoal):\n 1. x \\<noteq> None \\<Longrightarrow> x = y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "proof(cases \"n \\<ge>0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow> x = y\n 2. \\<not> 0 \\<le> n \\<Longrightarrow> x = y", "case True"], ["proof (state)\nthis:\n  0 \\<le> n\n\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow> x = y\n 2. \\<not> 0 \\<le> n \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  0 \\<le> n", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> n\n\ngoal (1 subgoal):\n 1. x = y", "using n_def A neg_odd pos_even m_def int_option_enumeration.simps(1)"], ["proof (prove)\nusing this:\n  0 \\<le> n\n  x = Some n\n  x \\<in> UNIV\n  y \\<in> UNIV\n  int_option_enumeration x = int_option_enumeration y\n  ?n < 0 \\<Longrightarrow> odd (int_option_enumeration (Some ?n))\n  0 \\<le> ?n \\<Longrightarrow>\n  even (int_option_enumeration (Some ?n)) \\<and>\n  0 < int_option_enumeration (Some ?n)\n  y = Some m\n  int_option_enumeration (Some ?n) =\n  (if 0 \\<le> ?n then nat (2 * (?n + 1)) else nat (2 * - ?n + 1))\n\ngoal (1 subgoal):\n 1. x = y", "by (smt int_nat_eq)"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> n \\<Longrightarrow> x = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> n \\<Longrightarrow> x = y", "case False"], ["proof (state)\nthis:\n  \\<not> 0 \\<le> n\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> n \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  \\<not> 0 \\<le> n", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> 0 \\<le> n\n\ngoal (1 subgoal):\n 1. x = y", "using n_def A neg_odd pos_even m_def int_option_enumeration.simps(1)"], ["proof (prove)\nusing this:\n  \\<not> 0 \\<le> n\n  x = Some n\n  x \\<in> UNIV\n  y \\<in> UNIV\n  int_option_enumeration x = int_option_enumeration y\n  ?n < 0 \\<Longrightarrow> odd (int_option_enumeration (Some ?n))\n  0 \\<le> ?n \\<Longrightarrow>\n  even (int_option_enumeration (Some ?n)) \\<and>\n  0 < int_option_enumeration (Some ?n)\n  y = Some m\n  int_option_enumeration (Some ?n) =\n  (if 0 \\<le> ?n then nat (2 * (?n + 1)) else nat (2 * - ?n + 1))\n\ngoal (1 subgoal):\n 1. x = y", "by (smt int_nat_eq)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "definition eint_enumeration where\n\"eint_enumeration = int_option_enumeration \\<circ> Rep_eint\""], ["", "lemma eint_enumeration_inj:\n\"inj eint_enumeration\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj eint_enumeration", "unfolding eint_enumeration_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (int_option_enumeration \\<circ> Rep_eint)", "using int_option_enumeration_inj Rep_eint_inject"], ["proof (prove)\nusing this:\n  inj int_option_enumeration\n  (Rep_eint ?x = Rep_eint ?y) = (?x = ?y)\n\ngoal (1 subgoal):\n 1. inj (int_option_enumeration \\<circ> Rep_eint)", "by (metis (mono_tags, lifting) comp_apply injD inj_on_def)"], ["", "instance eint :: countable"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(eint, countable_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>to_nat. inj to_nat", "show \"\\<exists>to_int::eint \\<Rightarrow> nat. inj to_int\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>to_int. inj to_int", "using eint_enumeration_inj"], ["proof (prove)\nusing this:\n  inj eint_enumeration\n\ngoal (1 subgoal):\n 1. \\<exists>to_int. inj to_int", "by blast"], ["proof (state)\nthis:\n  \\<exists>to_int. inj to_int\n\ngoal:\nNo subgoals!", "qed"], ["", "old_rep_datatype eint \"\\<infinity> :: eint\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P einta.\n        \\<lbrakk>\\<And>int. P (eint int); P \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> P einta) &&&\n    (\\<And>int int'. (eint int = eint int') = (int = int')) &&&\n    (\\<And>int. eint int \\<noteq> \\<infinity>)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>P einta.\n       \\<lbrakk>\\<And>int. P (eint int); P \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> P einta\n 2. \\<And>int int'. (eint int = eint int') = (int = int')\n 3. \\<And>int. eint int \\<noteq> \\<infinity>", "fix P i"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>P einta.\n       \\<lbrakk>\\<And>int. P (eint int); P \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> P einta\n 2. \\<And>int int'. (eint int = eint int') = (int = int')\n 3. \\<And>int. eint int \\<noteq> \\<infinity>", "assume \"\\<And>j. P (eint j)\" \"P \\<infinity>\""], ["proof (state)\nthis:\n  P (eint ?j)\n  P \\<infinity>\n\ngoal (3 subgoals):\n 1. \\<And>P einta.\n       \\<lbrakk>\\<And>int. P (eint int); P \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> P einta\n 2. \\<And>int int'. (eint int = eint int') = (int = int')\n 3. \\<And>int. eint int \\<noteq> \\<infinity>", "then"], ["proof (chain)\npicking this:\n  P (eint ?j)\n  P \\<infinity>", "show \"P i\""], ["proof (prove)\nusing this:\n  P (eint ?j)\n  P \\<infinity>\n\ngoal (1 subgoal):\n 1. P i", "proof induct"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y \\<in> UNIV; \\<And>j. P (eint j); P \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> P (Abs_eint y)", "case (Abs_eint y)"], ["proof (state)\nthis:\n  y \\<in> UNIV\n  P (eint ?j)\n  P \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y \\<in> UNIV; \\<And>j. P (eint j); P \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> P (Abs_eint y)", "then"], ["proof (chain)\npicking this:\n  y \\<in> UNIV\n  P (eint ?j)\n  P \\<infinity>", "show ?case"], ["proof (prove)\nusing this:\n  y \\<in> UNIV\n  P (eint ?j)\n  P \\<infinity>\n\ngoal (1 subgoal):\n 1. P (Abs_eint y)", "by (cases y rule: option.exhaust)\n         (auto simp: eint_def infinity_eint_def)"], ["proof (state)\nthis:\n  P (Abs_eint y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P i\n\ngoal (2 subgoals):\n 1. \\<And>int int'. (eint int = eint int') = (int = int')\n 2. \\<And>int. eint int \\<noteq> \\<infinity>", "qed (auto simp add: eint_def infinity_eint_def Abs_eint_inject)"], ["", "declare [[coercion \"eint::int\\<Rightarrow>eint\"]]"], ["", "lemmas eint2_cases = eint.exhaust[case_product eint.exhaust]"], ["", "lemmas eint3_cases = eint.exhaust[case_product eint.exhaust eint.exhaust]"], ["", "lemma not_infinity_eq [iff]: \"(x \\<noteq> \\<infinity>) = (\\<exists>i. x = eint i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<noteq> \\<infinity>) = (\\<exists>i. x = eint i)", "by (cases x) auto"], ["", "lemma not_eint_eq [iff]: \"(\\<forall>y. x \\<noteq> eint y) = (x = \\<infinity>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>y. x \\<noteq> eint y) = (x = \\<infinity>)", "by (cases x) auto"], ["", "lemma eint_ex_split: \"(\\<exists>c::eint. P c) \\<longleftrightarrow> P \\<infinity> \\<or> (\\<exists>c::int. P c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>c. P c) = (P \\<infinity> \\<or> (\\<exists>x. P (eint x)))", "by (metis eint.exhaust)"], ["", "primrec the_eint :: \"eint \\<Rightarrow> int\"\n  where \"the_eint (eint n) = n\""], ["", "subsection \\<open>Constructors and numbers\\<close>"], ["", "instantiation eint :: zero_neq_one\nbegin"], ["", "definition\n  \"0 = eint 0\""], ["", "definition\n  \"1 = eint 1\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(eint, zero_neq_one_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<noteq> 1", "qed (simp add: zero_eint_def one_eint_def)"], ["", "end"], ["", "lemma eint_0 [code_post]: \"eint 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eint 0 = 0", "by (simp add: zero_eint_def)"], ["", "lemma eint_1 [code_post]: \"eint 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eint 1 = 1", "by (simp add: one_eint_def)"], ["", "lemma eint_0_iff: \"eint x = 0 \\<longleftrightarrow> x = 0\" \"0 = eint x \\<longleftrightarrow> x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (eint x = 0) = (x = 0) &&& (0 = eint x) = (x = 0)", "by (auto simp add: zero_eint_def)"], ["", "lemma eint_1_iff: \"eint x = 1 \\<longleftrightarrow> x = 1\" \"1 = eint x \\<longleftrightarrow> x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (eint x = 1) = (x = 1) &&& (1 = eint x) = (x = 1)", "by (auto simp add: one_eint_def)"], ["", "lemma infinity_ne_i0 [simp]: \"(\\<infinity>::eint) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<infinity> \\<noteq> 0", "by (simp add: zero_eint_def)"], ["", "lemma i0_ne_infinity [simp]: \"0 \\<noteq> (\\<infinity>::eint)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<noteq> \\<infinity>", "by (simp add: zero_eint_def)"], ["", "lemma zero_one_eint_neq:\n  \"\\<not> 0 = (1::eint)\"\n  \"\\<not> 1 = (0::eint)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<noteq> 1 &&& 1 \\<noteq> 0", "unfolding zero_eint_def one_eint_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eint 0 \\<noteq> eint 1 &&& eint 1 \\<noteq> eint 0", "by simp_all"], ["", "lemma infinity_ne_i1 [simp]: \"(\\<infinity>::eint) \\<noteq> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<infinity> \\<noteq> 1", "by (simp add: one_eint_def)"], ["", "lemma i1_ne_infinity [simp]: \"1 \\<noteq> (\\<infinity>::eint)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<noteq> \\<infinity>", "by (simp add: one_eint_def)"], ["", "subsection \\<open>Addition\\<close>"], ["", "instantiation eint :: comm_monoid_add\nbegin"], ["", "definition [nitpick_simp]:\n  \"m + n = (case m of \\<infinity> \\<Rightarrow> \\<infinity> | eint m \\<Rightarrow> (case n of \\<infinity> \\<Rightarrow> \\<infinity> | eint n \\<Rightarrow> eint (m + n)))\""], ["", "lemma plus_eint_simps [simp, code]:\n  fixes q :: eint\n  shows \"eint m + eint n = eint (m + n)\"\n    and \"\\<infinity> + q = \\<infinity>\"\n    and \"q + \\<infinity> = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eint m + eint n = eint (m + n) &&&\n    \\<infinity> + q = \\<infinity> &&& q + \\<infinity> = \\<infinity>", "by (simp_all add: plus_eint_def split: eint.splits)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(eint, comm_monoid_add_class)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b c. a + b + c = a + (b + c)\n 2. \\<And>a b. a + b = b + a\n 3. \\<And>a. 0 + a = a", "fix n m q :: eint"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b c. a + b + c = a + (b + c)\n 2. \\<And>a b. a + b = b + a\n 3. \\<And>a. 0 + a = a", "show \"n + m + q = n + (m + q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n + m + q = n + (m + q)", "by (cases n m q rule: eint3_cases) auto"], ["proof (state)\nthis:\n  n + m + q = n + (m + q)\n\ngoal (2 subgoals):\n 1. \\<And>a b. a + b = b + a\n 2. \\<And>a. 0 + a = a", "show \"n + m = m + n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n + m = m + n", "by (cases n m rule: eint2_cases) auto"], ["proof (state)\nthis:\n  n + m = m + n\n\ngoal (1 subgoal):\n 1. \\<And>a. 0 + a = a", "show \"0 + n = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 + n = n", "by (cases n) (simp_all add: zero_eint_def)"], ["proof (state)\nthis:\n  0 + n = n\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma eSuc_eint: \"(eint n) + 1 = eint (n + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eint n + 1 = eint (n + 1)", "by (simp add: one_eint_def)"], ["", "lemma eSuc_infinity [simp]: \" \\<infinity> + (1::eint) = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<infinity> + 1 = \\<infinity>", "unfolding plus_eint_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case \\<infinity> of\n     eint m \\<Rightarrow>\n       case 1 of eint n \\<Rightarrow> eint (m + n)\n       | \\<infinity> \\<Rightarrow> \\<infinity>\n     | \\<infinity> \\<Rightarrow> \\<infinity>) =\n    \\<infinity>", "by auto"], ["", "lemma eSuc_inject [simp]: \" m + (1::eint)=  n + 1 \\<longleftrightarrow> m = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m + 1 = n + 1) = (m = n)", "unfolding plus_eint_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((case m of\n      eint m \\<Rightarrow>\n        case 1 of eint n \\<Rightarrow> eint (m + n)\n        | \\<infinity> \\<Rightarrow> \\<infinity>\n      | \\<infinity> \\<Rightarrow> \\<infinity>) =\n     (case n of\n      eint m \\<Rightarrow>\n        case 1 of eint n \\<Rightarrow> eint (m + n)\n        | \\<infinity> \\<Rightarrow> \\<infinity>\n      | \\<infinity> \\<Rightarrow> \\<infinity>)) =\n    (m = n)", "apply(cases \"m = \\<infinity>\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. m = \\<infinity> \\<Longrightarrow>\n    ((case m of\n      eint m \\<Rightarrow>\n        case 1 of eint n \\<Rightarrow> eint (m + n)\n        | \\<infinity> \\<Rightarrow> \\<infinity>\n      | \\<infinity> \\<Rightarrow> \\<infinity>) =\n     (case n of\n      eint m \\<Rightarrow>\n        case 1 of eint n \\<Rightarrow> eint (m + n)\n        | \\<infinity> \\<Rightarrow> \\<infinity>\n      | \\<infinity> \\<Rightarrow> \\<infinity>)) =\n    (m = n)\n 2. m \\<noteq> \\<infinity> \\<Longrightarrow>\n    ((case m of\n      eint m \\<Rightarrow>\n        case 1 of eint n \\<Rightarrow> eint (m + n)\n        | \\<infinity> \\<Rightarrow> \\<infinity>\n      | \\<infinity> \\<Rightarrow> \\<infinity>) =\n     (case n of\n      eint m \\<Rightarrow>\n        case 1 of eint n \\<Rightarrow> eint (m + n)\n        | \\<infinity> \\<Rightarrow> \\<infinity>\n      | \\<infinity> \\<Rightarrow> \\<infinity>)) =\n    (m = n)", "apply (metis (no_types, lifting) eSuc_eint \n    eint.distinct(2) eint.exhaust eint.simps(4) eint.simps(5) plus_eint_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<noteq> \\<infinity> \\<Longrightarrow>\n    ((case m of\n      eint m \\<Rightarrow>\n        case 1 of eint n \\<Rightarrow> eint (m + n)\n        | \\<infinity> \\<Rightarrow> \\<infinity>\n      | \\<infinity> \\<Rightarrow> \\<infinity>) =\n     (case n of\n      eint m \\<Rightarrow>\n        case 1 of eint n \\<Rightarrow> eint (m + n)\n        | \\<infinity> \\<Rightarrow> \\<infinity>\n      | \\<infinity> \\<Rightarrow> \\<infinity>)) =\n    (m = n)", "apply(cases \"n = \\<infinity>\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>m \\<noteq> \\<infinity>; n = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> ((case m of\n                        eint m \\<Rightarrow>\n                          case 1 of eint n \\<Rightarrow> eint (m + n)\n                          | \\<infinity> \\<Rightarrow> \\<infinity>\n                        | \\<infinity> \\<Rightarrow> \\<infinity>) =\n                       (case n of\n                        eint m \\<Rightarrow>\n                          case 1 of eint n \\<Rightarrow> eint (m + n)\n                          | \\<infinity> \\<Rightarrow> \\<infinity>\n                        | \\<infinity> \\<Rightarrow> \\<infinity>)) =\n                      (m = n)\n 2. \\<lbrakk>m \\<noteq> \\<infinity>; n \\<noteq> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> ((case m of\n                        eint m \\<Rightarrow>\n                          case 1 of eint n \\<Rightarrow> eint (m + n)\n                          | \\<infinity> \\<Rightarrow> \\<infinity>\n                        | \\<infinity> \\<Rightarrow> \\<infinity>) =\n                       (case n of\n                        eint m \\<Rightarrow>\n                          case 1 of eint n \\<Rightarrow> eint (m + n)\n                          | \\<infinity> \\<Rightarrow> \\<infinity>\n                        | \\<infinity> \\<Rightarrow> \\<infinity>)) =\n                      (m = n)", "using eSuc_eint plus_eint_def"], ["proof (prove)\nusing this:\n  eint ?n + 1 = eint (?n + 1)\n  ?m + ?n =\n  (case ?m of\n   eint m \\<Rightarrow>\n     case ?n of eint n \\<Rightarrow> eint (m + n)\n     | \\<infinity> \\<Rightarrow> \\<infinity>\n   | \\<infinity> \\<Rightarrow> \\<infinity>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>m \\<noteq> \\<infinity>; n = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> ((case m of\n                        eint m \\<Rightarrow>\n                          case 1 of eint n \\<Rightarrow> eint (m + n)\n                          | \\<infinity> \\<Rightarrow> \\<infinity>\n                        | \\<infinity> \\<Rightarrow> \\<infinity>) =\n                       (case n of\n                        eint m \\<Rightarrow>\n                          case 1 of eint n \\<Rightarrow> eint (m + n)\n                          | \\<infinity> \\<Rightarrow> \\<infinity>\n                        | \\<infinity> \\<Rightarrow> \\<infinity>)) =\n                      (m = n)\n 2. \\<lbrakk>m \\<noteq> \\<infinity>; n \\<noteq> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> ((case m of\n                        eint m \\<Rightarrow>\n                          case 1 of eint n \\<Rightarrow> eint (m + n)\n                          | \\<infinity> \\<Rightarrow> \\<infinity>\n                        | \\<infinity> \\<Rightarrow> \\<infinity>) =\n                       (case n of\n                        eint m \\<Rightarrow>\n                          case 1 of eint n \\<Rightarrow> eint (m + n)\n                          | \\<infinity> \\<Rightarrow> \\<infinity>\n                        | \\<infinity> \\<Rightarrow> \\<infinity>)) =\n                      (m = n)", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<noteq> \\<infinity>; n \\<noteq> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> ((case m of\n                        eint m \\<Rightarrow>\n                          case 1 of eint n \\<Rightarrow> eint (m + n)\n                          | \\<infinity> \\<Rightarrow> \\<infinity>\n                        | \\<infinity> \\<Rightarrow> \\<infinity>) =\n                       (case n of\n                        eint m \\<Rightarrow>\n                          case 1 of eint n \\<Rightarrow> eint (m + n)\n                          | \\<infinity> \\<Rightarrow> \\<infinity>\n                        | \\<infinity> \\<Rightarrow> \\<infinity>)) =\n                      (m = n)", "unfolding one_eint_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<noteq> \\<infinity>; n \\<noteq> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> ((case m of\n                        eint m \\<Rightarrow>\n                          case eint 1 of eint n \\<Rightarrow> eint (m + n)\n                          | \\<infinity> \\<Rightarrow> \\<infinity>\n                        | \\<infinity> \\<Rightarrow> \\<infinity>) =\n                       (case n of\n                        eint m \\<Rightarrow>\n                          case eint 1 of eint n \\<Rightarrow> eint (m + n)\n                          | \\<infinity> \\<Rightarrow> \\<infinity>\n                        | \\<infinity> \\<Rightarrow> \\<infinity>)) =\n                      (m = n)", "using add.commute eSuc_eint"], ["proof (prove)\nusing this:\n  ?a + ?b = ?b + ?a\n  eint ?n + 1 = eint (?n + 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<noteq> \\<infinity>; n \\<noteq> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> ((case m of\n                        eint m \\<Rightarrow>\n                          case eint 1 of eint n \\<Rightarrow> eint (m + n)\n                          | \\<infinity> \\<Rightarrow> \\<infinity>\n                        | \\<infinity> \\<Rightarrow> \\<infinity>) =\n                       (case n of\n                        eint m \\<Rightarrow>\n                          case eint 1 of eint n \\<Rightarrow> eint (m + n)\n                          | \\<infinity> \\<Rightarrow> \\<infinity>\n                        | \\<infinity> \\<Rightarrow> \\<infinity>)) =\n                      (m = n)", "by auto"], ["", "lemma eSuc_eint_iff: \"x + 1 = eint y \\<longleftrightarrow> (\\<exists>n. y = n + 1 \\<and> x = eint n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x + 1 = eint y) = (\\<exists>n. y = n + 1 \\<and> x = eint n)", "apply(cases \"x = \\<infinity>\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. x = \\<infinity> \\<Longrightarrow>\n    (x + 1 = eint y) = (\\<exists>n. y = n + 1 \\<and> x = eint n)\n 2. x \\<noteq> \\<infinity> \\<Longrightarrow>\n    (x + 1 = eint y) = (\\<exists>n. y = n + 1 \\<and> x = eint n)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> \\<infinity> \\<Longrightarrow>\n    (x + 1 = eint y) = (\\<exists>n. y = n + 1 \\<and> x = eint n)", "unfolding plus_eint_def one_eint_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> \\<infinity> \\<Longrightarrow>\n    ((case x of\n      eint m \\<Rightarrow>\n        case eint 1 of eint n \\<Rightarrow> eint (m + n)\n        | \\<infinity> \\<Rightarrow> \\<infinity>\n      | \\<infinity> \\<Rightarrow> \\<infinity>) =\n     eint y) =\n    (\\<exists>n. y = n + 1 \\<and> x = eint n)", "using eSuc_eint"], ["proof (prove)\nusing this:\n  eint ?n + 1 = eint (?n + 1)\n\ngoal (1 subgoal):\n 1. x \\<noteq> \\<infinity> \\<Longrightarrow>\n    ((case x of\n      eint m \\<Rightarrow>\n        case eint 1 of eint n \\<Rightarrow> eint (m + n)\n        | \\<infinity> \\<Rightarrow> \\<infinity>\n      | \\<infinity> \\<Rightarrow> \\<infinity>) =\n     eint y) =\n    (\\<exists>n. y = n + 1 \\<and> x = eint n)", "by auto"], ["", "lemma enat_eSuc_iff: \"eint y = x + 1 \\<longleftrightarrow> (\\<exists>n. y = n + 1 \\<and> eint n = x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (eint y = x + 1) = (\\<exists>n. y = n + 1 \\<and> eint n = x)", "using eSuc_eint_iff"], ["proof (prove)\nusing this:\n  (?x + 1 = eint ?y) = (\\<exists>n. ?y = n + 1 \\<and> ?x = eint n)\n\ngoal (1 subgoal):\n 1. (eint y = x + 1) = (\\<exists>n. y = n + 1 \\<and> eint n = x)", "by metis"], ["", "lemma iadd_Suc: \"((m::eint) + 1) + n = (m + n) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m + 1 + n = m + n + 1", "by (metis ab_semigroup_add_class.add_ac(1) add.assoc add.commute)"], ["", "lemma iadd_Suc_right: \"(m::eint) + (n + 1) = (m + n) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m + (n + 1) = m + n + 1", "using add.assoc[of m n 1]"], ["proof (prove)\nusing this:\n  m + n + 1 = m + (n + 1)\n\ngoal (1 subgoal):\n 1. m + (n + 1) = m + n + 1", "by auto"], ["", "subsection \\<open>Multiplication\\<close>"], ["", "instantiation eint :: \"{comm_semiring}\"\nbegin"], ["", "definition times_eint_def [nitpick_simp]:\n  \"m * n = (case m of \\<infinity> \\<Rightarrow>  \\<infinity> | eint m \\<Rightarrow>\n    (case n of \\<infinity> \\<Rightarrow> \\<infinity> | eint n \\<Rightarrow> eint (m * n)))\""], ["", "lemma times_eint_simps [simp, code]:\n  \"eint m * eint n = eint (m * n)\"\n  \"\\<infinity> * \\<infinity> = (\\<infinity>::eint)\"\n  \"\\<infinity> * eint n = \\<infinity>\"\n  \"eint m * \\<infinity> = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (eint m * eint n = eint (m * n) &&&\n     \\<infinity> * \\<infinity> = \\<infinity>) &&&\n    \\<infinity> * eint n = \\<infinity> &&&\n    eint m * \\<infinity> = \\<infinity>", "unfolding times_eint_def zero_eint_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((case eint m of\n      eint m \\<Rightarrow>\n        case eint n of eint n \\<Rightarrow> eint (m * n)\n        | \\<infinity> \\<Rightarrow> \\<infinity>\n      | \\<infinity> \\<Rightarrow> \\<infinity>) =\n     eint (m * n) &&&\n     (case \\<infinity> of\n      eint m \\<Rightarrow>\n        case \\<infinity> of eint n \\<Rightarrow> eint (m * n)\n        | \\<infinity> \\<Rightarrow> \\<infinity>\n      | \\<infinity> \\<Rightarrow> \\<infinity>) =\n     \\<infinity>) &&&\n    (case \\<infinity> of\n     eint m \\<Rightarrow>\n       case eint n of eint n \\<Rightarrow> eint (m * n)\n       | \\<infinity> \\<Rightarrow> \\<infinity>\n     | \\<infinity> \\<Rightarrow> \\<infinity>) =\n    \\<infinity> &&&\n    (case eint m of\n     eint m \\<Rightarrow>\n       case \\<infinity> of eint n \\<Rightarrow> eint (m * n)\n       | \\<infinity> \\<Rightarrow> \\<infinity>\n     | \\<infinity> \\<Rightarrow> \\<infinity>) =\n    \\<infinity>", "by (simp_all split: eint.split)"], ["", "lemma sum_infinity_imp_summand_infinity:\n  assumes \"a + b = (\\<infinity>::eint)\"\n  shows \"a = \\<infinity> \\<or> b = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = \\<infinity> \\<or> b = \\<infinity>", "using assms"], ["proof (prove)\nusing this:\n  a + b = \\<infinity>\n\ngoal (1 subgoal):\n 1. a = \\<infinity> \\<or> b = \\<infinity>", "by (metis  not_eint_eq plus_eint_simps(1))"], ["", "lemma sum_finite_imp_summands_finite:\n  assumes \"a + b \\<noteq> (\\<infinity>::eint)\"\n  shows \"a \\<noteq> \\<infinity>\" \"b \\<noteq> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> \\<infinity> &&& b \\<noteq> \\<infinity>", "using assms eint.simps(5)"], ["proof (prove)\nusing this:\n  a + b \\<noteq> \\<infinity>\n  (case \\<infinity> of eint x \\<Rightarrow> ?f1.0 x\n   | \\<infinity> \\<Rightarrow> ?f2.0) =\n  ?f2.0\n\ngoal (1 subgoal):\n 1. a \\<noteq> \\<infinity> &&& b \\<noteq> \\<infinity>", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<noteq> \\<infinity>", "using assms eint.simps(5)"], ["proof (prove)\nusing this:\n  a + b \\<noteq> \\<infinity>\n  (case \\<infinity> of eint x \\<Rightarrow> ?f1.0 x\n   | \\<infinity> \\<Rightarrow> ?f2.0) =\n  ?f2.0\n\ngoal (1 subgoal):\n 1. b \\<noteq> \\<infinity>", "by fastforce"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(eint, comm_semiring_class)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b c. a * b * c = a * (b * c)\n 2. \\<And>a b. a * b = b * a\n 3. \\<And>a b c. (a + b) * c = a * c + b * c", "fix a b c :: eint"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b c. a * b * c = a * (b * c)\n 2. \\<And>a b. a * b = b * a\n 3. \\<And>a b c. (a + b) * c = a * c + b * c", "show \"(a * b) * c = a * (b * c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * b * c = a * (b * c)", "unfolding times_eint_def zero_eint_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case case a of\n          eint m \\<Rightarrow>\n            case b of eint n \\<Rightarrow> eint (m * n)\n            | \\<infinity> \\<Rightarrow> \\<infinity>\n          | \\<infinity> \\<Rightarrow> \\<infinity> of\n     eint m \\<Rightarrow>\n       case c of eint n \\<Rightarrow> eint (m * n)\n       | \\<infinity> \\<Rightarrow> \\<infinity>\n     | \\<infinity> \\<Rightarrow> \\<infinity>) =\n    (case a of\n     eint m \\<Rightarrow>\n       case case b of\n            eint m \\<Rightarrow>\n              case c of eint n \\<Rightarrow> eint (m * n)\n              | \\<infinity> \\<Rightarrow> \\<infinity>\n            | \\<infinity> \\<Rightarrow> \\<infinity> of\n       eint n \\<Rightarrow> eint (m * n)\n       | \\<infinity> \\<Rightarrow> \\<infinity>\n     | \\<infinity> \\<Rightarrow> \\<infinity>)", "by (simp split: eint.split)"], ["proof (state)\nthis:\n  a * b * c = a * (b * c)\n\ngoal (2 subgoals):\n 1. \\<And>a b. a * b = b * a\n 2. \\<And>a b c. (a + b) * c = a * c + b * c", "show comm: \"a * b = b * a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * b = b * a", "unfolding times_eint_def zero_eint_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case a of\n     eint m \\<Rightarrow>\n       case b of eint n \\<Rightarrow> eint (m * n)\n       | \\<infinity> \\<Rightarrow> \\<infinity>\n     | \\<infinity> \\<Rightarrow> \\<infinity>) =\n    (case b of\n     eint m \\<Rightarrow>\n       case a of eint n \\<Rightarrow> eint (m * n)\n       | \\<infinity> \\<Rightarrow> \\<infinity>\n     | \\<infinity> \\<Rightarrow> \\<infinity>)", "by (simp split: eint.split)"], ["proof (state)\nthis:\n  a * b = b * a\n\ngoal (1 subgoal):\n 1. \\<And>a b c. (a + b) * c = a * c + b * c", "show distr: \"(a + b) * c = a * c + b * c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a + b) * c = a * c + b * c", "unfolding times_eint_def plus_eint_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case case a of\n          eint m \\<Rightarrow>\n            case b of eint n \\<Rightarrow> eint (m + n)\n            | \\<infinity> \\<Rightarrow> \\<infinity>\n          | \\<infinity> \\<Rightarrow> \\<infinity> of\n     eint m \\<Rightarrow>\n       case c of eint n \\<Rightarrow> eint (m * n)\n       | \\<infinity> \\<Rightarrow> \\<infinity>\n     | \\<infinity> \\<Rightarrow> \\<infinity>) =\n    (case case a of\n          eint m \\<Rightarrow>\n            case c of eint n \\<Rightarrow> eint (m * n)\n            | \\<infinity> \\<Rightarrow> \\<infinity>\n          | \\<infinity> \\<Rightarrow> \\<infinity> of\n     eint m \\<Rightarrow>\n       case case b of\n            eint m \\<Rightarrow>\n              case c of eint n \\<Rightarrow> eint (m * n)\n              | \\<infinity> \\<Rightarrow> \\<infinity>\n            | \\<infinity> \\<Rightarrow> \\<infinity> of\n       eint n \\<Rightarrow> eint (m + n)\n       | \\<infinity> \\<Rightarrow> \\<infinity>\n     | \\<infinity> \\<Rightarrow> \\<infinity>)", "apply(cases \"a + b = \\<infinity>\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. a + b = \\<infinity> \\<Longrightarrow>\n    (case case a of\n          eint m \\<Rightarrow>\n            case b of eint n \\<Rightarrow> eint (m + n)\n            | \\<infinity> \\<Rightarrow> \\<infinity>\n          | \\<infinity> \\<Rightarrow> \\<infinity> of\n     eint m \\<Rightarrow>\n       case c of eint n \\<Rightarrow> eint (m * n)\n       | \\<infinity> \\<Rightarrow> \\<infinity>\n     | \\<infinity> \\<Rightarrow> \\<infinity>) =\n    (case case a of\n          eint m \\<Rightarrow>\n            case c of eint n \\<Rightarrow> eint (m * n)\n            | \\<infinity> \\<Rightarrow> \\<infinity>\n          | \\<infinity> \\<Rightarrow> \\<infinity> of\n     eint m \\<Rightarrow>\n       case case b of\n            eint m \\<Rightarrow>\n              case c of eint n \\<Rightarrow> eint (m * n)\n              | \\<infinity> \\<Rightarrow> \\<infinity>\n            | \\<infinity> \\<Rightarrow> \\<infinity> of\n       eint n \\<Rightarrow> eint (m + n)\n       | \\<infinity> \\<Rightarrow> \\<infinity>\n     | \\<infinity> \\<Rightarrow> \\<infinity>)\n 2. a + b \\<noteq> \\<infinity> \\<Longrightarrow>\n    (case case a of\n          eint m \\<Rightarrow>\n            case b of eint n \\<Rightarrow> eint (m + n)\n            | \\<infinity> \\<Rightarrow> \\<infinity>\n          | \\<infinity> \\<Rightarrow> \\<infinity> of\n     eint m \\<Rightarrow>\n       case c of eint n \\<Rightarrow> eint (m * n)\n       | \\<infinity> \\<Rightarrow> \\<infinity>\n     | \\<infinity> \\<Rightarrow> \\<infinity>) =\n    (case case a of\n          eint m \\<Rightarrow>\n            case c of eint n \\<Rightarrow> eint (m * n)\n            | \\<infinity> \\<Rightarrow> \\<infinity>\n          | \\<infinity> \\<Rightarrow> \\<infinity> of\n     eint m \\<Rightarrow>\n       case case b of\n            eint m \\<Rightarrow>\n              case c of eint n \\<Rightarrow> eint (m * n)\n              | \\<infinity> \\<Rightarrow> \\<infinity>\n            | \\<infinity> \\<Rightarrow> \\<infinity> of\n       eint n \\<Rightarrow> eint (m + n)\n       | \\<infinity> \\<Rightarrow> \\<infinity>\n     | \\<infinity> \\<Rightarrow> \\<infinity>)", "apply(cases \"a = \\<infinity>\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>a + b = \\<infinity>; a = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (case case a of\n                            eint m \\<Rightarrow>\n                              case b of eint n \\<Rightarrow> eint (m + n)\n                              | \\<infinity> \\<Rightarrow> \\<infinity>\n                            | \\<infinity> \\<Rightarrow> \\<infinity> of\n                       eint m \\<Rightarrow>\n                         case c of eint n \\<Rightarrow> eint (m * n)\n                         | \\<infinity> \\<Rightarrow> \\<infinity>\n                       | \\<infinity> \\<Rightarrow> \\<infinity>) =\n                      (case case a of\n                            eint m \\<Rightarrow>\n                              case c of eint n \\<Rightarrow> eint (m * n)\n                              | \\<infinity> \\<Rightarrow> \\<infinity>\n                            | \\<infinity> \\<Rightarrow> \\<infinity> of\n                       eint m \\<Rightarrow>\n                         case case b of\n                              eint m \\<Rightarrow>\n                                case c of eint n \\<Rightarrow> eint (m * n)\n                                | \\<infinity> \\<Rightarrow> \\<infinity>\n                              | \\<infinity> \\<Rightarrow> \\<infinity> of\n                         eint n \\<Rightarrow> eint (m + n)\n                         | \\<infinity> \\<Rightarrow> \\<infinity>\n                       | \\<infinity> \\<Rightarrow> \\<infinity>)\n 2. \\<lbrakk>a + b = \\<infinity>; a \\<noteq> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (case case a of\n                            eint m \\<Rightarrow>\n                              case b of eint n \\<Rightarrow> eint (m + n)\n                              | \\<infinity> \\<Rightarrow> \\<infinity>\n                            | \\<infinity> \\<Rightarrow> \\<infinity> of\n                       eint m \\<Rightarrow>\n                         case c of eint n \\<Rightarrow> eint (m * n)\n                         | \\<infinity> \\<Rightarrow> \\<infinity>\n                       | \\<infinity> \\<Rightarrow> \\<infinity>) =\n                      (case case a of\n                            eint m \\<Rightarrow>\n                              case c of eint n \\<Rightarrow> eint (m * n)\n                              | \\<infinity> \\<Rightarrow> \\<infinity>\n                            | \\<infinity> \\<Rightarrow> \\<infinity> of\n                       eint m \\<Rightarrow>\n                         case case b of\n                              eint m \\<Rightarrow>\n                                case c of eint n \\<Rightarrow> eint (m * n)\n                                | \\<infinity> \\<Rightarrow> \\<infinity>\n                              | \\<infinity> \\<Rightarrow> \\<infinity> of\n                         eint n \\<Rightarrow> eint (m + n)\n                         | \\<infinity> \\<Rightarrow> \\<infinity>\n                       | \\<infinity> \\<Rightarrow> \\<infinity>)\n 3. a + b \\<noteq> \\<infinity> \\<Longrightarrow>\n    (case case a of\n          eint m \\<Rightarrow>\n            case b of eint n \\<Rightarrow> eint (m + n)\n            | \\<infinity> \\<Rightarrow> \\<infinity>\n          | \\<infinity> \\<Rightarrow> \\<infinity> of\n     eint m \\<Rightarrow>\n       case c of eint n \\<Rightarrow> eint (m * n)\n       | \\<infinity> \\<Rightarrow> \\<infinity>\n     | \\<infinity> \\<Rightarrow> \\<infinity>) =\n    (case case a of\n          eint m \\<Rightarrow>\n            case c of eint n \\<Rightarrow> eint (m * n)\n            | \\<infinity> \\<Rightarrow> \\<infinity>\n          | \\<infinity> \\<Rightarrow> \\<infinity> of\n     eint m \\<Rightarrow>\n       case case b of\n            eint m \\<Rightarrow>\n              case c of eint n \\<Rightarrow> eint (m * n)\n              | \\<infinity> \\<Rightarrow> \\<infinity>\n            | \\<infinity> \\<Rightarrow> \\<infinity> of\n       eint n \\<Rightarrow> eint (m + n)\n       | \\<infinity> \\<Rightarrow> \\<infinity>\n     | \\<infinity> \\<Rightarrow> \\<infinity>)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a + b = \\<infinity>; a \\<noteq> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (case case a of\n                            eint m \\<Rightarrow>\n                              case b of eint n \\<Rightarrow> eint (m + n)\n                              | \\<infinity> \\<Rightarrow> \\<infinity>\n                            | \\<infinity> \\<Rightarrow> \\<infinity> of\n                       eint m \\<Rightarrow>\n                         case c of eint n \\<Rightarrow> eint (m * n)\n                         | \\<infinity> \\<Rightarrow> \\<infinity>\n                       | \\<infinity> \\<Rightarrow> \\<infinity>) =\n                      (case case a of\n                            eint m \\<Rightarrow>\n                              case c of eint n \\<Rightarrow> eint (m * n)\n                              | \\<infinity> \\<Rightarrow> \\<infinity>\n                            | \\<infinity> \\<Rightarrow> \\<infinity> of\n                       eint m \\<Rightarrow>\n                         case case b of\n                              eint m \\<Rightarrow>\n                                case c of eint n \\<Rightarrow> eint (m * n)\n                                | \\<infinity> \\<Rightarrow> \\<infinity>\n                              | \\<infinity> \\<Rightarrow> \\<infinity> of\n                         eint n \\<Rightarrow> eint (m + n)\n                         | \\<infinity> \\<Rightarrow> \\<infinity>\n                       | \\<infinity> \\<Rightarrow> \\<infinity>)\n 2. a + b \\<noteq> \\<infinity> \\<Longrightarrow>\n    (case case a of\n          eint m \\<Rightarrow>\n            case b of eint n \\<Rightarrow> eint (m + n)\n            | \\<infinity> \\<Rightarrow> \\<infinity>\n          | \\<infinity> \\<Rightarrow> \\<infinity> of\n     eint m \\<Rightarrow>\n       case c of eint n \\<Rightarrow> eint (m * n)\n       | \\<infinity> \\<Rightarrow> \\<infinity>\n     | \\<infinity> \\<Rightarrow> \\<infinity>) =\n    (case case a of\n          eint m \\<Rightarrow>\n            case c of eint n \\<Rightarrow> eint (m * n)\n            | \\<infinity> \\<Rightarrow> \\<infinity>\n          | \\<infinity> \\<Rightarrow> \\<infinity> of\n     eint m \\<Rightarrow>\n       case case b of\n            eint m \\<Rightarrow>\n              case c of eint n \\<Rightarrow> eint (m * n)\n              | \\<infinity> \\<Rightarrow> \\<infinity>\n            | \\<infinity> \\<Rightarrow> \\<infinity> of\n       eint n \\<Rightarrow> eint (m + n)\n       | \\<infinity> \\<Rightarrow> \\<infinity>\n     | \\<infinity> \\<Rightarrow> \\<infinity>)", "using sum_infinity_imp_summand_infinity[of a b]"], ["proof (prove)\nusing this:\n  a + b = \\<infinity> \\<Longrightarrow>\n  a = \\<infinity> \\<or> b = \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a + b = \\<infinity>; a \\<noteq> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (case case a of\n                            eint m \\<Rightarrow>\n                              case b of eint n \\<Rightarrow> eint (m + n)\n                              | \\<infinity> \\<Rightarrow> \\<infinity>\n                            | \\<infinity> \\<Rightarrow> \\<infinity> of\n                       eint m \\<Rightarrow>\n                         case c of eint n \\<Rightarrow> eint (m * n)\n                         | \\<infinity> \\<Rightarrow> \\<infinity>\n                       | \\<infinity> \\<Rightarrow> \\<infinity>) =\n                      (case case a of\n                            eint m \\<Rightarrow>\n                              case c of eint n \\<Rightarrow> eint (m * n)\n                              | \\<infinity> \\<Rightarrow> \\<infinity>\n                            | \\<infinity> \\<Rightarrow> \\<infinity> of\n                       eint m \\<Rightarrow>\n                         case case b of\n                              eint m \\<Rightarrow>\n                                case c of eint n \\<Rightarrow> eint (m * n)\n                                | \\<infinity> \\<Rightarrow> \\<infinity>\n                              | \\<infinity> \\<Rightarrow> \\<infinity> of\n                         eint n \\<Rightarrow> eint (m + n)\n                         | \\<infinity> \\<Rightarrow> \\<infinity>\n                       | \\<infinity> \\<Rightarrow> \\<infinity>)\n 2. a + b \\<noteq> \\<infinity> \\<Longrightarrow>\n    (case case a of\n          eint m \\<Rightarrow>\n            case b of eint n \\<Rightarrow> eint (m + n)\n            | \\<infinity> \\<Rightarrow> \\<infinity>\n          | \\<infinity> \\<Rightarrow> \\<infinity> of\n     eint m \\<Rightarrow>\n       case c of eint n \\<Rightarrow> eint (m * n)\n       | \\<infinity> \\<Rightarrow> \\<infinity>\n     | \\<infinity> \\<Rightarrow> \\<infinity>) =\n    (case case a of\n          eint m \\<Rightarrow>\n            case c of eint n \\<Rightarrow> eint (m * n)\n            | \\<infinity> \\<Rightarrow> \\<infinity>\n          | \\<infinity> \\<Rightarrow> \\<infinity> of\n     eint m \\<Rightarrow>\n       case case b of\n            eint m \\<Rightarrow>\n              case c of eint n \\<Rightarrow> eint (m * n)\n              | \\<infinity> \\<Rightarrow> \\<infinity>\n            | \\<infinity> \\<Rightarrow> \\<infinity> of\n       eint n \\<Rightarrow> eint (m + n)\n       | \\<infinity> \\<Rightarrow> \\<infinity>\n     | \\<infinity> \\<Rightarrow> \\<infinity>)", "apply (metis eint.simps(5) plus_eint_def plus_eint_simps(3))"], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b \\<noteq> \\<infinity> \\<Longrightarrow>\n    (case case a of\n          eint m \\<Rightarrow>\n            case b of eint n \\<Rightarrow> eint (m + n)\n            | \\<infinity> \\<Rightarrow> \\<infinity>\n          | \\<infinity> \\<Rightarrow> \\<infinity> of\n     eint m \\<Rightarrow>\n       case c of eint n \\<Rightarrow> eint (m * n)\n       | \\<infinity> \\<Rightarrow> \\<infinity>\n     | \\<infinity> \\<Rightarrow> \\<infinity>) =\n    (case case a of\n          eint m \\<Rightarrow>\n            case c of eint n \\<Rightarrow> eint (m * n)\n            | \\<infinity> \\<Rightarrow> \\<infinity>\n          | \\<infinity> \\<Rightarrow> \\<infinity> of\n     eint m \\<Rightarrow>\n       case case b of\n            eint m \\<Rightarrow>\n              case c of eint n \\<Rightarrow> eint (m * n)\n              | \\<infinity> \\<Rightarrow> \\<infinity>\n            | \\<infinity> \\<Rightarrow> \\<infinity> of\n       eint n \\<Rightarrow> eint (m + n)\n       | \\<infinity> \\<Rightarrow> \\<infinity>\n     | \\<infinity> \\<Rightarrow> \\<infinity>)", "apply(cases \"c = \\<infinity>\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a + b \\<noteq> \\<infinity>; c = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (case case a of\n                            eint m \\<Rightarrow>\n                              case b of eint n \\<Rightarrow> eint (m + n)\n                              | \\<infinity> \\<Rightarrow> \\<infinity>\n                            | \\<infinity> \\<Rightarrow> \\<infinity> of\n                       eint m \\<Rightarrow>\n                         case c of eint n \\<Rightarrow> eint (m * n)\n                         | \\<infinity> \\<Rightarrow> \\<infinity>\n                       | \\<infinity> \\<Rightarrow> \\<infinity>) =\n                      (case case a of\n                            eint m \\<Rightarrow>\n                              case c of eint n \\<Rightarrow> eint (m * n)\n                              | \\<infinity> \\<Rightarrow> \\<infinity>\n                            | \\<infinity> \\<Rightarrow> \\<infinity> of\n                       eint m \\<Rightarrow>\n                         case case b of\n                              eint m \\<Rightarrow>\n                                case c of eint n \\<Rightarrow> eint (m * n)\n                                | \\<infinity> \\<Rightarrow> \\<infinity>\n                              | \\<infinity> \\<Rightarrow> \\<infinity> of\n                         eint n \\<Rightarrow> eint (m + n)\n                         | \\<infinity> \\<Rightarrow> \\<infinity>\n                       | \\<infinity> \\<Rightarrow> \\<infinity>)\n 2. \\<lbrakk>a + b \\<noteq> \\<infinity>; c \\<noteq> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (case case a of\n                            eint m \\<Rightarrow>\n                              case b of eint n \\<Rightarrow> eint (m + n)\n                              | \\<infinity> \\<Rightarrow> \\<infinity>\n                            | \\<infinity> \\<Rightarrow> \\<infinity> of\n                       eint m \\<Rightarrow>\n                         case c of eint n \\<Rightarrow> eint (m * n)\n                         | \\<infinity> \\<Rightarrow> \\<infinity>\n                       | \\<infinity> \\<Rightarrow> \\<infinity>) =\n                      (case case a of\n                            eint m \\<Rightarrow>\n                              case c of eint n \\<Rightarrow> eint (m * n)\n                              | \\<infinity> \\<Rightarrow> \\<infinity>\n                            | \\<infinity> \\<Rightarrow> \\<infinity> of\n                       eint m \\<Rightarrow>\n                         case case b of\n                              eint m \\<Rightarrow>\n                                case c of eint n \\<Rightarrow> eint (m * n)\n                                | \\<infinity> \\<Rightarrow> \\<infinity>\n                              | \\<infinity> \\<Rightarrow> \\<infinity> of\n                         eint n \\<Rightarrow> eint (m + n)\n                         | \\<infinity> \\<Rightarrow> \\<infinity>\n                       | \\<infinity> \\<Rightarrow> \\<infinity>)", "apply (metis eint.exhaust plus_eint_def plus_eint_simps(3) times_eint_def times_eint_simps(4))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a + b \\<noteq> \\<infinity>; c \\<noteq> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (case case a of\n                            eint m \\<Rightarrow>\n                              case b of eint n \\<Rightarrow> eint (m + n)\n                              | \\<infinity> \\<Rightarrow> \\<infinity>\n                            | \\<infinity> \\<Rightarrow> \\<infinity> of\n                       eint m \\<Rightarrow>\n                         case c of eint n \\<Rightarrow> eint (m * n)\n                         | \\<infinity> \\<Rightarrow> \\<infinity>\n                       | \\<infinity> \\<Rightarrow> \\<infinity>) =\n                      (case case a of\n                            eint m \\<Rightarrow>\n                              case c of eint n \\<Rightarrow> eint (m * n)\n                              | \\<infinity> \\<Rightarrow> \\<infinity>\n                            | \\<infinity> \\<Rightarrow> \\<infinity> of\n                       eint m \\<Rightarrow>\n                         case case b of\n                              eint m \\<Rightarrow>\n                                case c of eint n \\<Rightarrow> eint (m * n)\n                                | \\<infinity> \\<Rightarrow> \\<infinity>\n                              | \\<infinity> \\<Rightarrow> \\<infinity> of\n                         eint n \\<Rightarrow> eint (m + n)\n                         | \\<infinity> \\<Rightarrow> \\<infinity>\n                       | \\<infinity> \\<Rightarrow> \\<infinity>)", "using sum_finite_imp_summands_finite[of a b]"], ["proof (prove)\nusing this:\n  a + b \\<noteq> \\<infinity> \\<Longrightarrow> a \\<noteq> \\<infinity>\n  a + b \\<noteq> \\<infinity> \\<Longrightarrow> b \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a + b \\<noteq> \\<infinity>; c \\<noteq> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (case case a of\n                            eint m \\<Rightarrow>\n                              case b of eint n \\<Rightarrow> eint (m + n)\n                              | \\<infinity> \\<Rightarrow> \\<infinity>\n                            | \\<infinity> \\<Rightarrow> \\<infinity> of\n                       eint m \\<Rightarrow>\n                         case c of eint n \\<Rightarrow> eint (m * n)\n                         | \\<infinity> \\<Rightarrow> \\<infinity>\n                       | \\<infinity> \\<Rightarrow> \\<infinity>) =\n                      (case case a of\n                            eint m \\<Rightarrow>\n                              case c of eint n \\<Rightarrow> eint (m * n)\n                              | \\<infinity> \\<Rightarrow> \\<infinity>\n                            | \\<infinity> \\<Rightarrow> \\<infinity> of\n                       eint m \\<Rightarrow>\n                         case case b of\n                              eint m \\<Rightarrow>\n                                case c of eint n \\<Rightarrow> eint (m * n)\n                                | \\<infinity> \\<Rightarrow> \\<infinity>\n                              | \\<infinity> \\<Rightarrow> \\<infinity> of\n                         eint n \\<Rightarrow> eint (m + n)\n                         | \\<infinity> \\<Rightarrow> \\<infinity>\n                       | \\<infinity> \\<Rightarrow> \\<infinity>)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ia ib ic.\n       \\<lbrakk>c = eint ia; a = eint ib; b = eint ic\\<rbrakk>\n       \\<Longrightarrow> (ib + ic) * ia = ib * ia + ic * ia", "by (simp add: semiring_normalization_rules(1))"], ["proof (state)\nthis:\n  (a + b) * c = a * c + b * c\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma mult_one_right[simp]:\n\"(n::eint)*1 = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n * 1 = n", "apply(cases \"n = \\<infinity>\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. n = \\<infinity> \\<Longrightarrow> n * 1 = n\n 2. n \\<noteq> \\<infinity> \\<Longrightarrow> n * 1 = n", "apply (simp add: one_eint_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> \\<infinity> \\<Longrightarrow> n * 1 = n", "by (metis eint2_cases mult_cancel_left2 one_eint_def times_eint_simps(1))"], ["", "lemma mult_one_left[simp]:\n\"1*(n::eint) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * n = n", "by (metis mult.commute mult_one_right)"], ["", "lemma mult_eSuc: \"((m::eint) + 1) * n = m * n + n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m + 1) * n = m * n + n", "by (simp add: distrib_right)"], ["", "lemma mult_eSuc': \"((m::eint) + 1) * n = n + m * n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m + 1) * n = n + m * n", "using mult_eSuc add.commute"], ["proof (prove)\nusing this:\n  (?m + 1) * ?n = ?m * ?n + ?n\n  ?a + ?b = ?b + ?a\n\ngoal (1 subgoal):\n 1. (m + 1) * n = n + m * n", "by simp"], ["", "lemma mult_eSuc_right: \"(m::eint) * (n + 1) =  m * n +  m \""], ["proof (prove)\ngoal (1 subgoal):\n 1. m * (n + 1) = m * n + m", "by(simp add: distrib_left)"], ["", "lemma mult_eSuc_right': \"(m::eint) * (n + 1) =  m + m * n  \""], ["proof (prove)\ngoal (1 subgoal):\n 1. m * (n + 1) = m + m * n", "using mult_eSuc_right add.commute"], ["proof (prove)\nusing this:\n  ?m * (?n + 1) = ?m * ?n + ?m\n  ?a + ?b = ?b + ?a\n\ngoal (1 subgoal):\n 1. m * (n + 1) = m + m * n", "by simp"], ["", "subsection \\<open>Numerals\\<close>"], ["", "lemma numeral_eq_eint:\n  \"numeral k = eint (numeral k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eint (numeral k) = eint (numeral k)", "by simp"], ["", "lemma eint_numeral [code_abbrev]:\n  \"eint (numeral k) = numeral k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eint (numeral k) = eint (numeral k)", "using numeral_eq_eint"], ["proof (prove)\nusing this:\n  eint (numeral ?k) = eint (numeral ?k)\n\ngoal (1 subgoal):\n 1. eint (numeral k) = eint (numeral k)", ".."], ["", "lemma infinity_ne_numeral [simp]: \"(\\<infinity>::eint) \\<noteq> numeral k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<infinity> \\<noteq> eint (numeral k)", "by auto"], ["", "lemma numeral_ne_infinity [simp]: \"numeral k \\<noteq> (\\<infinity>::eint)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eint (numeral k) \\<noteq> \\<infinity>", "by simp"], ["", "subsection \\<open>Subtraction\\<close>"], ["", "instantiation eint :: minus\nbegin"], ["", "definition diff_eint_def:\n\"a - b = (case a of (eint x) \\<Rightarrow> (case b of (eint y) \\<Rightarrow> eint (x - y) | \\<infinity> \\<Rightarrow> \\<infinity>)\n          | \\<infinity> \\<Rightarrow> \\<infinity>)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(eint, minus_class)", ".."], ["", "end"], ["", "lemma idiff_eint_eint [simp, code]: \"eint a - eint b = eint (a - b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eint a - eint b = eint (a - b)", "by (simp add: diff_eint_def)"], ["", "lemma idiff_infinity [simp, code]: \"\\<infinity> - n = (\\<infinity>::eint)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<infinity> - n = \\<infinity>", "by (simp add: diff_eint_def)"], ["", "lemma idiff_infinity_right [simp, code]: \"eint a - \\<infinity> = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eint a - \\<infinity> = \\<infinity>", "by (simp add: diff_eint_def)"], ["", "lemma idiff_0 [simp]: \"(0::eint) - n = -n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 - eint n = eint (- n)", "by (cases n, simp_all add: zero_eint_def)"], ["", "lemmas idiff_eint_0 [simp] = idiff_0 [unfolded zero_eint_def]"], ["", "lemma idiff_0_right [simp]: \"(n::eint) - 0 = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n - 0 = n", "by (cases n) (simp_all add: zero_eint_def)"], ["", "lemmas idiff_eint_0_right [simp] = idiff_0_right [unfolded zero_eint_def]"], ["", "lemma idiff_self [simp]: \"n \\<noteq> \\<infinity> \\<Longrightarrow> (n::eint) - n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> \\<infinity> \\<Longrightarrow> n - n = 0", "by (auto simp: zero_eint_def)"], ["", "lemma eSuc_minus_eSuc [simp]: \"((n::eint) + 1) - (m + 1) = n - m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n + 1 - (m + 1) = n - m", "apply(cases \"n = \\<infinity>\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. n = \\<infinity> \\<Longrightarrow> n + 1 - (m + 1) = n - m\n 2. n \\<noteq> \\<infinity> \\<Longrightarrow> n + 1 - (m + 1) = n - m", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> \\<infinity> \\<Longrightarrow> n + 1 - (m + 1) = n - m", "apply(cases \"m = \\<infinity>\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n \\<noteq> \\<infinity>; m = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> n + 1 - (m + 1) = n - m\n 2. \\<lbrakk>n \\<noteq> \\<infinity>; m \\<noteq> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> n + 1 - (m + 1) = n - m", "apply (metis eSuc_infinity eint.exhaust idiff_infinity_right infinity_ne_i1 sum_infinity_imp_summand_infinity)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<noteq> \\<infinity>; m \\<noteq> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> n + 1 - (m + 1) = n - m", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<noteq> \\<infinity>; m \\<noteq> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> n + 1 - (m + 1) = n - m", "assume A: \"n \\<noteq>\\<infinity>\" \"m \\<noteq> \\<infinity>\""], ["proof (state)\nthis:\n  n \\<noteq> \\<infinity>\n  m \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<noteq> \\<infinity>; m \\<noteq> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> n + 1 - (m + 1) = n - m", "obtain a where a_def: \"n = eint a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a. n = eint a \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using A"], ["proof (prove)\nusing this:\n  n \\<noteq> \\<infinity>\n  m \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>a. n = eint a \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  n = eint a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<noteq> \\<infinity>; m \\<noteq> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> n + 1 - (m + 1) = n - m", "obtain b where b_def: \"m = eint b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b. m = eint b \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using A"], ["proof (prove)\nusing this:\n  n \\<noteq> \\<infinity>\n  m \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>b. m = eint b \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  m = eint b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<noteq> \\<infinity>; m \\<noteq> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> n + 1 - (m + 1) = n - m", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. n + 1 - (m + 1) = n - m", "using  idiff_eint_eint[of \"a + 1\" \"b + 1\"]\n           idiff_eint_eint[of a b]"], ["proof (prove)\nusing this:\n  eint (a + 1) - eint (b + 1) = eint (a + 1 - (b + 1))\n  eint a - eint b = eint (a - b)\n\ngoal (1 subgoal):\n 1. n + 1 - (m + 1) = n - m", "by (simp add: a_def b_def eSuc_eint)"], ["proof (state)\nthis:\n  n + 1 - (m + 1) = n - m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eSuc_minus_1 [simp]: \"((n::eint)+ 1) - 1 = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n + 1 - 1 = n", "using eSuc_minus_eSuc[of n 0]"], ["proof (prove)\nusing this:\n  n + 1 - (0 + 1) = n - 0\n\ngoal (1 subgoal):\n 1. n + 1 - 1 = n", "by auto"], ["", "(*lemmas idiff_self_eq_0_eint = idiff_self_eq_0[unfolded zero_eint_def]*)"], ["", "subsection \\<open>Ordering\\<close>"], ["", "instantiation eint :: linordered_ab_semigroup_add\nbegin"], ["", "definition [nitpick_simp]:\n  \"m \\<le> n = (case n of eint n1 \\<Rightarrow> (case m of eint m1 \\<Rightarrow> m1 \\<le> n1 | \\<infinity> \\<Rightarrow> False)\n    | \\<infinity> \\<Rightarrow> True)\""], ["", "definition [nitpick_simp]:\n  \"m < n = (case m of eint m1 \\<Rightarrow> (case n of eint n1 \\<Rightarrow> m1 < n1 | \\<infinity> \\<Rightarrow> True)\n    | \\<infinity> \\<Rightarrow> False)\""], ["", "lemma eint_ord_simps [simp]:\n  \"eint m \\<le> eint n \\<longleftrightarrow> m \\<le> n\"\n  \"eint m < eint n \\<longleftrightarrow> m < n\"\n  \"q \\<le> (\\<infinity>::eint)\"\n  \"q < (\\<infinity>::eint) \\<longleftrightarrow> q \\<noteq> \\<infinity>\"\n  \"(\\<infinity>::eint) \\<le> q \\<longleftrightarrow> q = \\<infinity>\"\n  \"(\\<infinity>::eint) < q \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((eint m \\<le> eint n) = (m \\<le> n) &&&\n     (eint m < eint n) = (m < n) &&& q \\<le> \\<infinity>) &&&\n    (q < \\<infinity>) = (q \\<noteq> \\<infinity>) &&&\n    (\\<infinity> \\<le> q) = (q = \\<infinity>) &&& (\\<infinity> < q) = False", "by (simp_all add: less_eq_eint_def less_eint_def split: eint.splits)"], ["", "lemma numeral_le_eint_iff[simp]:\n  shows \"numeral m \\<le> eint n \\<longleftrightarrow> numeral m \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (eint (numeral m) \\<le> eint n) = (numeral m \\<le> n)", "by auto"], ["", "lemma numeral_less_eint_iff[simp]:\n  shows \"numeral m < eint n \\<longleftrightarrow> numeral m < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (eint (numeral m) < eint n) = (numeral m < n)", "by simp"], ["", "lemma eint_ord_code [code]:\n  \"eint m \\<le> eint n \\<longleftrightarrow> m \\<le> n\"\n  \"eint m < eint n \\<longleftrightarrow> m < n\"\n  \"q \\<le> (\\<infinity>::eint) \\<longleftrightarrow> True\"\n  \"eint m < \\<infinity> \\<longleftrightarrow> True\"\n  \"\\<infinity> \\<le> eint n \\<longleftrightarrow> False\"\n  \"(\\<infinity>::eint) < q \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((eint m \\<le> eint n) = (m \\<le> n) &&&\n     (eint m < eint n) = (m < n) &&& (q \\<le> \\<infinity>) = True) &&&\n    (eint m < \\<infinity>) = True &&&\n    (\\<infinity> \\<le> eint n) = False &&& (\\<infinity> < q) = False", "by simp_all"], ["", "lemma eint_ord_plus_one[simp]:\n  assumes \"eint n \\<le> x\"\n  assumes \"x < y\"\n  shows \"eint (n + 1) \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eint (n + 1) \\<le> y", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. eint (n + 1) \\<le> y", "obtain m where \"x = eint m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m. x = eint m \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  x < y\n\ngoal (1 subgoal):\n 1. (\\<And>m. x = eint m \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  x = eint m\n\ngoal (1 subgoal):\n 1. eint (n + 1) \\<le> y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eint (n + 1) \\<le> y", "apply(cases \"y = \\<infinity>\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. y = \\<infinity> \\<Longrightarrow> eint (n + 1) \\<le> y\n 2. y \\<noteq> \\<infinity> \\<Longrightarrow> eint (n + 1) \\<le> y", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<noteq> \\<infinity> \\<Longrightarrow> eint (n + 1) \\<le> y", "using \\<open>x = eint m\\<close> assms(1) assms(2)"], ["proof (prove)\nusing this:\n  x = eint m\n  eint n \\<le> x\n  x < y\n\ngoal (1 subgoal):\n 1. y \\<noteq> \\<infinity> \\<Longrightarrow> eint (n + 1) \\<le> y", "by force"], ["proof (state)\nthis:\n  eint (n + 1) \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(eint, linordered_ab_semigroup_add_class)", "by standard (auto simp add: less_eq_eint_def less_eint_def plus_eint_def split: eint.splits)"], ["", "end"], ["", "instance eint :: \"{strict_ordered_comm_monoid_add}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(eint, strict_ordered_comm_monoid_add_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>a < b; c < d\\<rbrakk> \\<Longrightarrow> a + c < b + d", "show \"a < b \\<Longrightarrow> c < d \\<Longrightarrow> a + c < b + d\" for a b c d :: eint"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a < b; c < d\\<rbrakk> \\<Longrightarrow> a + c < b + d", "by (cases a b c d rule: eint2_cases[case_product eint2_cases]) auto"], ["proof (state)\nthis:\n  \\<lbrakk>?a < ?b; ?c < ?d\\<rbrakk> \\<Longrightarrow> ?a + ?c < ?b + ?d\n\ngoal:\nNo subgoals!", "qed"], ["", "(* BH: These equations are already proven generally for any type in\nclass linordered_semidom. However, eint is not in that class because\nit does not have the cancellation property. Would it be worthwhile to\na generalize linordered_semidom to a new class that includes eint? *)"], ["", "lemma add_diff_assoc_eint: \"z \\<le> y \\<Longrightarrow> x + (y - z) = x + y - (z::eint)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<le> y \\<Longrightarrow> x + (y - z) = x + y - z", "by(cases x)(auto simp add: diff_eint_def split: eint.split)"], ["", "lemma eint_ord_number [simp]:\n  \"(numeral m :: eint) \\<le> numeral n \\<longleftrightarrow> (numeral m :: nat) \\<le> numeral n\"\n  \"(numeral m :: eint) < numeral n \\<longleftrightarrow> (numeral m :: nat) < numeral n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (eint (numeral m) \\<le> eint (numeral n)) =\n    (numeral m \\<le> numeral n) &&&\n    (eint (numeral m) < eint (numeral n)) = (numeral m < numeral n)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (eint (numeral m) < eint (numeral n)) = (numeral m < numeral n)", "by simp"], ["", "lemma infinity_ileE [elim!]: \"\\<infinity> \\<le> eint m \\<Longrightarrow> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<infinity> \\<le> eint m \\<Longrightarrow> R", "by simp"], ["", "lemma infinity_ilessE [elim!]: \"\\<infinity> < eint m \\<Longrightarrow> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<infinity> < eint m \\<Longrightarrow> R", "by simp"], ["", "lemma imult_infinity: \"(0::eint) < n \\<Longrightarrow> \\<infinity> * n = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> \\<infinity> * n = \\<infinity>", "by (simp add: zero_eint_def less_eint_def split: eint.splits)"], ["", "lemma imult_infinity_right: \"(0::eint) < n \\<Longrightarrow> n * \\<infinity> = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> n * \\<infinity> = \\<infinity>", "by (simp add: zero_eint_def less_eint_def split: eint.splits)"], ["", "lemma min_eint_simps [simp]:\n  \"min (eint m) (eint n) = eint (min m n)\"\n  \"min q (\\<infinity>::eint) = q\"\n  \"min (\\<infinity>::eint) q = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min (eint m) (eint n) = eint (min m n) &&&\n    min q \\<infinity> = q &&& min \\<infinity> q = q", "by (auto simp add: min_def)"], ["", "lemma max_eint_simps [simp]:\n  \"max (eint m) (eint n) = eint (max m n)\"\n  \"max q \\<infinity> = (\\<infinity>::eint)\"\n  \"max \\<infinity> q = (\\<infinity>::eint)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max (eint m) (eint n) = eint (max m n) &&&\n    max q \\<infinity> = \\<infinity> &&& max \\<infinity> q = \\<infinity>", "by (simp_all add: max_def)"], ["", "lemma eint_ile: \"n \\<le> eint m \\<Longrightarrow> \\<exists>k. n = eint k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> eint m \\<Longrightarrow> \\<exists>k. n = eint k", "by (cases n) simp_all"], ["", "lemma eint_iless: \"n < eint m \\<Longrightarrow> \\<exists>k. n = eint k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < eint m \\<Longrightarrow> \\<exists>k. n = eint k", "by (cases n) simp_all"], ["", "lemma iadd_le_eint_iff:\n  \"x + y \\<le> eint n \\<longleftrightarrow> (\\<exists>y' x'. x = eint x' \\<and> y = eint y' \\<and> x' + y' \\<le> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x + y \\<le> eint n) =\n    (\\<exists>y' x'. x = eint x' \\<and> y = eint y' \\<and> x' + y' \\<le> n)", "by(cases x y rule: eint.exhaust[case_product eint.exhaust]) simp_all"], ["", "lemma chain_incr: \"\\<forall>i. \\<exists>j. Y i < Y j \\<Longrightarrow> \\<exists>j. eint k < Y j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. \\<exists>j. Y i < Y j \\<Longrightarrow>\n    \\<exists>j. eint k < Y j", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i. \\<exists>j. Y i < Y j \\<Longrightarrow>\n    \\<exists>j. eint k < Y j", "assume A: \"\\<forall>i. \\<exists>j. Y i < Y j\""], ["proof (state)\nthis:\n  \\<forall>i. \\<exists>j. Y i < Y j\n\ngoal (1 subgoal):\n 1. \\<forall>i. \\<exists>j. Y i < Y j \\<Longrightarrow>\n    \\<exists>j. eint k < Y j", "then"], ["proof (chain)\npicking this:\n  \\<forall>i. \\<exists>j. Y i < Y j", "have \"\\<forall>i. \\<exists>n::int. Y i = eint n\""], ["proof (prove)\nusing this:\n  \\<forall>i. \\<exists>j. Y i < Y j\n\ngoal (1 subgoal):\n 1. \\<forall>i. \\<exists>n. Y i = eint n", "by (metis eint.exhaust eint_ord_simps(6))"], ["proof (state)\nthis:\n  \\<forall>i. \\<exists>n. Y i = eint n\n\ngoal (1 subgoal):\n 1. \\<forall>i. \\<exists>j. Y i < Y j \\<Longrightarrow>\n    \\<exists>j. eint k < Y j", "then"], ["proof (chain)\npicking this:\n  \\<forall>i. \\<exists>n. Y i = eint n", "obtain i n where in_def: \"Y (i::'a) = eint n\""], ["proof (prove)\nusing this:\n  \\<forall>i. \\<exists>n. Y i = eint n\n\ngoal (1 subgoal):\n 1. (\\<And>i n. Y i = eint n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Y i = eint n\n\ngoal (1 subgoal):\n 1. \\<forall>i. \\<exists>j. Y i < Y j \\<Longrightarrow>\n    \\<exists>j. eint k < Y j", "show \"\\<exists>j. eint k < Y j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j. eint k < Y j", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>j. eint k < Y j \\<Longrightarrow> False", "assume C: \"\\<not>(\\<exists>j. eint k < Y j)\""], ["proof (state)\nthis:\n  \\<nexists>j. eint k < Y j\n\ngoal (1 subgoal):\n 1. \\<nexists>j. eint k < Y j \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<nexists>j. eint k < Y j", "have C':\"\\<forall>j. Y j \\<le> eint k\""], ["proof (prove)\nusing this:\n  \\<nexists>j. eint k < Y j\n\ngoal (1 subgoal):\n 1. \\<forall>j. Y j \\<le> eint k", "using le_less_linear"], ["proof (prove)\nusing this:\n  \\<nexists>j. eint k < Y j\n  ?x \\<le> ?y \\<or> ?y < ?x\n\ngoal (1 subgoal):\n 1. \\<forall>j. Y j \\<le> eint k", "by blast"], ["proof (state)\nthis:\n  \\<forall>j. Y j \\<le> eint k\n\ngoal (1 subgoal):\n 1. \\<nexists>j. eint k < Y j \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<forall>j. Y j \\<le> eint k", "have \"Y (i::'a) \\<le> eint k\""], ["proof (prove)\nusing this:\n  \\<forall>j. Y j \\<le> eint k\n\ngoal (1 subgoal):\n 1. Y i \\<le> eint k", "by simp"], ["proof (state)\nthis:\n  Y i \\<le> eint k\n\ngoal (1 subgoal):\n 1. \\<nexists>j. eint k < Y j \\<Longrightarrow> False", "have \"\\<And>m::nat. \\<exists>j::'a. Y j \\<ge> eint (n + int m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m. \\<exists>j. eint (n + int m) \\<le> Y j", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m. \\<exists>j. eint (n + int m) \\<le> Y j", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m. \\<exists>j. eint (n + int m) \\<le> Y j", "show \"\\<exists>j::'a. Y j \\<ge> eint (n + int m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j. eint (n + int m) \\<le> Y j", "apply(induction m)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>j. eint (n + int 0) \\<le> Y j\n 2. \\<And>m.\n       \\<exists>j. eint (n + int m) \\<le> Y j \\<Longrightarrow>\n       \\<exists>j. eint (n + int (Suc m)) \\<le> Y j", "apply (metis in_def int_ops(1) order_refl plus_int_code(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<exists>j. eint (n + int m) \\<le> Y j \\<Longrightarrow>\n       \\<exists>j. eint (n + int (Suc m)) \\<le> Y j", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<exists>j. eint (n + int m) \\<le> Y j \\<Longrightarrow>\n       \\<exists>j. eint (n + int (Suc m)) \\<le> Y j", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<exists>j. eint (n + int m) \\<le> Y j \\<Longrightarrow>\n       \\<exists>j. eint (n + int (Suc m)) \\<le> Y j", "assume \"\\<exists>j. eint (n + int m) \\<le> Y j\""], ["proof (state)\nthis:\n  \\<exists>j. eint (n + int m) \\<le> Y j\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<exists>j. eint (n + int m) \\<le> Y j \\<Longrightarrow>\n       \\<exists>j. eint (n + int (Suc m)) \\<le> Y j", "then"], ["proof (chain)\npicking this:\n  \\<exists>j. eint (n + int m) \\<le> Y j", "obtain j where j_def: \"eint (n + int m) \\<le> Y j\""], ["proof (prove)\nusing this:\n  \\<exists>j. eint (n + int m) \\<le> Y j\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        eint (n + int m) \\<le> Y j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  eint (n + int m) \\<le> Y j\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<exists>j. eint (n + int m) \\<le> Y j \\<Longrightarrow>\n       \\<exists>j. eint (n + int (Suc m)) \\<le> Y j", "obtain j' where j'_def: \"Y j < Y j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j'. Y j < Y j' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using A"], ["proof (prove)\nusing this:\n  \\<forall>i. \\<exists>j. Y i < Y j\n\ngoal (1 subgoal):\n 1. (\\<And>j'. Y j < Y j' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  Y j < Y j'\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<exists>j. eint (n + int m) \\<le> Y j \\<Longrightarrow>\n       \\<exists>j. eint (n + int (Suc m)) \\<le> Y j", "have \"eint (n + int (Suc m)) = eint (n + m + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eint (n + int (Suc m)) = eint (n + int m + 1)", "by auto"], ["proof (state)\nthis:\n  eint (n + int (Suc m)) = eint (n + int m + 1)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<exists>j. eint (n + int m) \\<le> Y j \\<Longrightarrow>\n       \\<exists>j. eint (n + int (Suc m)) \\<le> Y j", "then"], ["proof (chain)\npicking this:\n  eint (n + int (Suc m)) = eint (n + int m + 1)", "have \"eint (n + int (Suc m)) \\<le> Y j'\""], ["proof (prove)\nusing this:\n  eint (n + int (Suc m)) = eint (n + int m + 1)\n\ngoal (1 subgoal):\n 1. eint (n + int (Suc m)) \\<le> Y j'", "using j_def j'_def  eint_ord_plus_one[of \"n + m\" \"Y j\" \"Y j'\"]"], ["proof (prove)\nusing this:\n  eint (n + int (Suc m)) = eint (n + int m + 1)\n  eint (n + int m) \\<le> Y j\n  Y j < Y j'\n  \\<lbrakk>eint (n + int m) \\<le> Y j; Y j < Y j'\\<rbrakk>\n  \\<Longrightarrow> eint (n + int m + 1) \\<le> Y j'\n\ngoal (1 subgoal):\n 1. eint (n + int (Suc m)) \\<le> Y j'", "by presburger"], ["proof (state)\nthis:\n  eint (n + int (Suc m)) \\<le> Y j'\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<exists>j. eint (n + int m) \\<le> Y j \\<Longrightarrow>\n       \\<exists>j. eint (n + int (Suc m)) \\<le> Y j", "then"], ["proof (chain)\npicking this:\n  eint (n + int (Suc m)) \\<le> Y j'", "show \"\\<exists>j. eint (n + int (Suc m)) \\<le> Y j\""], ["proof (prove)\nusing this:\n  eint (n + int (Suc m)) \\<le> Y j'\n\ngoal (1 subgoal):\n 1. \\<exists>j. eint (n + int (Suc m)) \\<le> Y j", "by blast"], ["proof (state)\nthis:\n  \\<exists>j. eint (n + int (Suc m)) \\<le> Y j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>j. eint (n + int m) \\<le> Y j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>j. eint (n + int ?m) \\<le> Y j\n\ngoal (1 subgoal):\n 1. \\<nexists>j. eint k < Y j \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>j. eint (n + int ?m) \\<le> Y j", "show False"], ["proof (prove)\nusing this:\n  \\<exists>j. eint (n + int ?m) \\<le> Y j\n\ngoal (1 subgoal):\n 1. False", "by (metis A C \\<open>Y i \\<le> eint k\\<close>   eint_ord_simps(1) in_def \n          order.not_eq_order_implies_strict zle_iff_zadd)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>j. eint k < Y j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eint_ord_Suc:\n  assumes \"(x::eint) < y\"\n  shows \"x + 1 < y + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + 1 < y + 1", "apply(cases \"y = \\<infinity>\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. y = \\<infinity> \\<Longrightarrow> x + 1 < y + 1\n 2. y \\<noteq> \\<infinity> \\<Longrightarrow> x + 1 < y + 1", "using assms i1_ne_infinity sum_infinity_imp_summand_infinity"], ["proof (prove)\nusing this:\n  x < y\n  1 \\<noteq> \\<infinity>\n  ?a + ?b = \\<infinity> \\<Longrightarrow>\n  ?a = \\<infinity> \\<or> ?b = \\<infinity>\n\ngoal (2 subgoals):\n 1. y = \\<infinity> \\<Longrightarrow> x + 1 < y + 1\n 2. y \\<noteq> \\<infinity> \\<Longrightarrow> x + 1 < y + 1", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<noteq> \\<infinity> \\<Longrightarrow> x + 1 < y + 1", "by (metis add_mono_thms_linordered_semiring(3) assms eSuc_inject order_less_le)"], ["", "lemma eSuc_ile_mono [simp]: \"(n::eint) + 1 \\<le> m+ 1 \\<longleftrightarrow> n \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n + 1 \\<le> m + 1) = (n \\<le> m)", "by (meson add_mono_thms_linordered_semiring(3) eint_ord_Suc linorder_not_le)"], ["", "lemma eSuc_mono [simp]: \"(n::eint) + 1 < m+ 1 \\<longleftrightarrow> n < m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n + 1 < m + 1) = (n < m)", "by (meson add_mono_thms_linordered_semiring(3) eint_ord_Suc linorder_not_le)"], ["", "lemma ile_eSuc [simp]: \"(n::eint) \\<le> n + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> n + 1", "by (metis add.right_neutral add_left_mono eint_1_iff(2) eint_ord_code(1) linear not_one_le_zero zero_eint_def)"], ["", "lemma ileI1: \"(m::eint) < n \\<Longrightarrow> m + 1 \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m < n \\<Longrightarrow> m + 1 \\<le> n", "by (metis eSuc_eint eint.exhaust eint_ex_split eint_iless eint_ord_Suc eint_ord_code(6) \n      eint_ord_plus_one eint_ord_simps(3) less_le_trans linear )"], ["", "lemma Suc_ile_eq: \"eint (m +1) \\<le> n \\<longleftrightarrow> eint m < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (eint (m + 1) \\<le> n) = (eint m < n)", "by (cases n) auto"], ["", "lemma iless_Suc_eq [simp]: \"eint m < n + 1 \\<longleftrightarrow> eint m \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (eint m < n + 1) = (eint m \\<le> n)", "by (metis Suc_ile_eq eSuc_eint eSuc_ile_mono)"], ["", "lemma eSuc_max: \"(max (x::eint) y) + 1 = max (x+1) (y+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max x y + 1 = max (x + 1) (y + 1)", "by (simp add: max_def)"], ["", "lemma eSuc_Max:\n  assumes \"finite A\" \"A \\<noteq> ({}::eint set)\"\n  shows \" (Max A) + 1 = Max ((+)1 ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max A + 1 = Max ((+) 1 ` A)", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Max A + 1 = Max ((+) 1 ` A)", "proof induction"], ["proof (state)\ngoal (2 subgoals):\n 1. {} \\<noteq> {} \\<Longrightarrow> Max {} + 1 = Max ((+) 1 ` {})\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<noteq> {} \\<Longrightarrow> Max F + 1 = Max ((+) 1 ` F);\n        insert x F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> Max (insert x F) + 1 = Max ((+) 1 ` insert x F)", "case (insert x A)"], ["proof (state)\nthis:\n  finite A\n  x \\<notin> A\n  A \\<noteq> {} \\<Longrightarrow> Max A + 1 = Max ((+) 1 ` A)\n  insert x A \\<noteq> {}\n\ngoal (2 subgoals):\n 1. {} \\<noteq> {} \\<Longrightarrow> Max {} + 1 = Max ((+) 1 ` {})\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<noteq> {} \\<Longrightarrow> Max F + 1 = Max ((+) 1 ` F);\n        insert x F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> Max (insert x F) + 1 = Max ((+) 1 ` insert x F)", "thus ?case"], ["proof (prove)\nusing this:\n  finite A\n  x \\<notin> A\n  A \\<noteq> {} \\<Longrightarrow> Max A + 1 = Max ((+) 1 ` A)\n  insert x A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Max (insert x A) + 1 = Max ((+) 1 ` insert x A)", "using Max_insert[of A x] Max_singleton[of x] add.commute[of 1] eSuc_max finite_imageI \n          image_insert image_is_empty"], ["proof (prove)\nusing this:\n  finite A\n  x \\<notin> A\n  A \\<noteq> {} \\<Longrightarrow> Max A + 1 = Max ((+) 1 ` A)\n  insert x A \\<noteq> {}\n  \\<lbrakk>finite A; A \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> Max (insert x A) = max x (Max A)\n  Max {x} = x\n  (1::?'a1) + ?b = ?b + (1::?'a1)\n  max ?x ?y + 1 = max (?x + 1) (?y + 1)\n  finite ?F \\<Longrightarrow> finite (?h ` ?F)\n  ?f ` insert ?a ?B = insert (?f ?a) (?f ` ?B)\n  (?f ` ?A = {}) = (?A = {})\n\ngoal (1 subgoal):\n 1. Max (insert x A) + 1 = Max ((+) 1 ` insert x A)", "by (simp add: add.commute hom_Max_commute)"], ["proof (state)\nthis:\n  Max (insert x A) + 1 = Max ((+) 1 ` insert x A)\n\ngoal (1 subgoal):\n 1. {} \\<noteq> {} \\<Longrightarrow> Max {} + 1 = Max ((+) 1 ` {})", "qed simp"], ["", "instantiation eint :: \"{order_top}\"\nbegin"], ["", "definition top_eint :: eint where \"top_eint = \\<infinity>\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(eint, order_top_class)", "by standard (simp add: top_eint_def)"], ["", "end"], ["", "lemma finite_eint_bounded:\n  assumes le_fin: \"\\<And>y. y \\<in> A \\<Longrightarrow> eint m \\<le> y \\<and> y \\<le> eint n\"\n  shows \"finite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A", "proof (rule finite_subset)"], ["proof (state)\ngoal (2 subgoals):\n 1. A \\<subseteq> ?B\n 2. finite ?B", "show \"finite (eint ` {m..n})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (eint ` {m..n})", "by blast"], ["proof (state)\nthis:\n  finite (eint ` {m..n})\n\ngoal (1 subgoal):\n 1. A \\<subseteq> eint ` {m..n}", "have \"A \\<subseteq> {eint m..eint n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> {eint m..eint n}", "using le_fin"], ["proof (prove)\nusing this:\n  ?y \\<in> A \\<Longrightarrow> eint m \\<le> ?y \\<and> ?y \\<le> eint n\n\ngoal (1 subgoal):\n 1. A \\<subseteq> {eint m..eint n}", "by fastforce"], ["proof (state)\nthis:\n  A \\<subseteq> {eint m..eint n}\n\ngoal (1 subgoal):\n 1. A \\<subseteq> eint ` {m..n}", "also"], ["proof (state)\nthis:\n  A \\<subseteq> {eint m..eint n}\n\ngoal (1 subgoal):\n 1. A \\<subseteq> eint ` {m..n}", "have \"\\<dots> \\<subseteq> eint ` {m..n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {eint m..eint n} \\<subseteq> eint ` {m..n}", "apply (rule subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {eint m..eint n} \\<Longrightarrow> x \\<in> eint ` {m..n}", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {eint m..eint n} \\<Longrightarrow> x \\<in> eint ` {m..n}", "by (cases x) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {eint m..eint n} \\<subseteq> eint ` {m..n}\n\ngoal (1 subgoal):\n 1. A \\<subseteq> eint ` {m..n}", "finally"], ["proof (chain)\npicking this:\n  A \\<subseteq> eint ` {m..n}", "show \"A \\<subseteq> eint ` {m..n}\""], ["proof (prove)\nusing this:\n  A \\<subseteq> eint ` {m..n}\n\ngoal (1 subgoal):\n 1. A \\<subseteq> eint ` {m..n}", "."], ["proof (state)\nthis:\n  A \\<subseteq> eint ` {m..n}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Cancellation simprocs\\<close>"], ["", "lemma add_diff_cancel_eint[simp]: \"x \\<noteq> \\<infinity> \\<Longrightarrow> x + y - x = (y::eint)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> \\<infinity> \\<Longrightarrow> x + y - x = y", "by (metis add.commute add.right_neutral add_diff_assoc_eint idiff_self order_refl)"], ["", "lemma eint_add_left_cancel: \"a + b = a + c \\<longleftrightarrow> a = (\\<infinity>::eint) \\<or> b = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a + b = a + c) = (a = \\<infinity> \\<or> b = c)", "unfolding plus_eint_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((case a of\n      eint m \\<Rightarrow>\n        case b of eint n \\<Rightarrow> eint (m + n)\n        | \\<infinity> \\<Rightarrow> \\<infinity>\n      | \\<infinity> \\<Rightarrow> \\<infinity>) =\n     (case a of\n      eint m \\<Rightarrow>\n        case c of eint n \\<Rightarrow> eint (m + n)\n        | \\<infinity> \\<Rightarrow> \\<infinity>\n      | \\<infinity> \\<Rightarrow> \\<infinity>)) =\n    (a = \\<infinity> \\<or> b = c)", "by (simp split: eint.split)"], ["", "lemma eint_add_left_cancel_le: \"a + b \\<le> a + c \\<longleftrightarrow> a = (\\<infinity>::eint) \\<or> b \\<le> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a + b \\<le> a + c) = (a = \\<infinity> \\<or> b \\<le> c)", "unfolding plus_eint_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((case a of\n      eint m \\<Rightarrow>\n        case b of eint n \\<Rightarrow> eint (m + n)\n        | \\<infinity> \\<Rightarrow> \\<infinity>\n      | \\<infinity> \\<Rightarrow> \\<infinity>)\n     \\<le> (case a of\n            eint m \\<Rightarrow>\n              case c of eint n \\<Rightarrow> eint (m + n)\n              | \\<infinity> \\<Rightarrow> \\<infinity>\n            | \\<infinity> \\<Rightarrow> \\<infinity>)) =\n    (a = \\<infinity> \\<or> b \\<le> c)", "by (simp split: eint.split)"], ["", "lemma eint_add_left_cancel_less: \"a + b < a + c \\<longleftrightarrow> a \\<noteq> (\\<infinity>::eint) \\<and> b < c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a + b < a + c) = (a \\<noteq> \\<infinity> \\<and> b < c)", "unfolding plus_eint_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((case a of\n      eint m \\<Rightarrow>\n        case b of eint n \\<Rightarrow> eint (m + n)\n        | \\<infinity> \\<Rightarrow> \\<infinity>\n      | \\<infinity> \\<Rightarrow> \\<infinity>)\n     < (case a of\n        eint m \\<Rightarrow>\n          case c of eint n \\<Rightarrow> eint (m + n)\n          | \\<infinity> \\<Rightarrow> \\<infinity>\n        | \\<infinity> \\<Rightarrow> \\<infinity>)) =\n    (a \\<noteq> \\<infinity> \\<and> b < c)", "by (simp split: eint.split)"], ["", "lemma plus_eq_infty_iff_eint: \"(m::eint) + n = \\<infinity> \\<longleftrightarrow> m=\\<infinity> \\<or> n=\\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m + n = \\<infinity>) = (m = \\<infinity> \\<or> n = \\<infinity>)", "using eint_add_left_cancel"], ["proof (prove)\nusing this:\n  (?a + ?b = ?a + ?c) = (?a = \\<infinity> \\<or> ?b = ?c)\n\ngoal (1 subgoal):\n 1. (m + n = \\<infinity>) = (m = \\<infinity> \\<or> n = \\<infinity>)", "by fastforce"], ["", "ML \\<open>\nstructure Cancel_Enat_Common =\nstruct\n  (* copied from src/HOL/Tools/nat_numeral_simprocs.ML *)\n  fun find_first_t _    _ []         = raise TERM(\"find_first_t\", [])\n    | find_first_t past u (t::terms) =\n          if u aconv t then (rev past @ terms)\n          else find_first_t (t::past) u terms\n\n  fun dest_summing (Const (\\<^const_name>\\<open>Groups.plus\\<close>, _) $ t $ u, ts) =\n        dest_summing (t, dest_summing (u, ts))\n    | dest_summing (t, ts) = t :: ts\n\n  val mk_sum = Arith_Data.long_mk_sum\n  fun dest_sum t = dest_summing (t, [])\n  val find_first = find_first_t []\n  val trans_tac = Numeral_Simprocs.trans_tac\n  val norm_ss =\n    simpset_of (put_simpset HOL_basic_ss \\<^context>\n      addsimps @{thms ac_simps add_0_left add_0_right})\n  fun norm_tac ctxt = ALLGOALS (simp_tac (put_simpset norm_ss ctxt))\n  fun simplify_meta_eq ctxt cancel_th th =\n    Arith_Data.simplify_meta_eq [] ctxt\n      ([th, cancel_th] MRS trans)\n  fun mk_eq (a, b) = HOLogic.mk_Trueprop (HOLogic.mk_eq (a, b))\nend\n\nstructure Eq_Enat_Cancel = ExtractCommonTermFun\n(open Cancel_Enat_Common\n  val mk_bal = HOLogic.mk_eq\n  val dest_bal = HOLogic.dest_bin \\<^const_name>\\<open>HOL.eq\\<close> \\<^typ>\\<open>eint\\<close>\n  fun simp_conv _ _ = SOME @{thm eint_add_left_cancel}\n)\n\nstructure Le_Enat_Cancel = ExtractCommonTermFun\n(open Cancel_Enat_Common\n  val mk_bal = HOLogic.mk_binrel \\<^const_name>\\<open>Orderings.less_eq\\<close>\n  val dest_bal = HOLogic.dest_bin \\<^const_name>\\<open>Orderings.less_eq\\<close> \\<^typ>\\<open>eint\\<close>\n  fun simp_conv _ _ = SOME @{thm eint_add_left_cancel_le}\n)\n\nstructure Less_Enat_Cancel = ExtractCommonTermFun\n(open Cancel_Enat_Common\n  val mk_bal = HOLogic.mk_binrel \\<^const_name>\\<open>Orderings.less\\<close>\n  val dest_bal = HOLogic.dest_bin \\<^const_name>\\<open>Orderings.less\\<close> \\<^typ>\\<open>eint\\<close>\n  fun simp_conv _ _ = SOME @{thm eint_add_left_cancel_less}\n)\n\\<close>"], ["", "simproc_setup eint_eq_cancel\n  (\"(l::eint) + m = n\" | \"(l::eint) = m + n\") =\n  \\<open>fn phi => fn ctxt => fn ct => Eq_Enat_Cancel.proc ctxt (Thm.term_of ct)\\<close>"], ["", "simproc_setup eint_le_cancel\n  (\"(l::eint) + m \\<le> n\" | \"(l::eint) \\<le> m + n\") =\n  \\<open>fn phi => fn ctxt => fn ct => Le_Enat_Cancel.proc ctxt (Thm.term_of ct)\\<close>"], ["", "simproc_setup eint_less_cancel\n  (\"(l::eint) + m < n\" | \"(l::eint) < m + n\") =\n  \\<open>fn phi => fn ctxt => fn ct => Less_Enat_Cancel.proc ctxt (Thm.term_of ct)\\<close>"], ["", "text \\<open>TODO: add regression tests for these simprocs\\<close>"], ["", "text \\<open>TODO: add simprocs for combining and cancelling numerals\\<close>"], ["", "subsection \\<open>Well-ordering\\<close>"], ["", "lemma less_eintE:\n  \"[| n < eint m; !!k. n = eint k ==> k < m ==> P |] ==> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < eint m;\n     \\<And>k.\n        \\<lbrakk>n = eint k; k < m\\<rbrakk> \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (induct n) auto"], ["", "lemma less_infinityE:\n  \"[| n < \\<infinity>; !!k. n = eint k ==> P |] ==> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < \\<infinity>;\n     \\<And>k. n = eint k \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (induct n) auto"], ["", "subsection \\<open>Traditional theorem names\\<close>"], ["", "lemmas eint_defs = zero_eint_def one_eint_def \n  plus_eint_def less_eq_eint_def less_eint_def"], ["", "instantiation eint :: uminus\nbegin"], ["", "definition \n\"- b = (case b of \\<infinity> \\<Rightarrow> \\<infinity> | eint m \\<Rightarrow> eint (-m))\""], ["", "lemma eint_uminus_eq:\n\"(a::eint) + (-a) = a - a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + - a = a - a", "apply(induction a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>int. eint int + - eint int = eint int - eint int\n 2. \\<infinity> + - \\<infinity> = \\<infinity> - \\<infinity>", "apply (simp add: uminus_eint_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<infinity> + - \\<infinity> = \\<infinity> - \\<infinity>", "by simp"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(eint, uminus_class)", ".."], ["", "end"], ["", "section\\<open>Additional Lemmas (Useful for the Proof of Hensel's Lemma)\\<close>"], ["", "lemma eint_mult_mono:\n  assumes \"(c::eint) > 0 \\<and> c \\<noteq> \\<infinity>\"\n  assumes \"k > n\"\n  shows \"k*c > n*c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n * c < k * c", "using assms"], ["proof (prove)\nusing this:\n  0 < c \\<and> c \\<noteq> \\<infinity>\n  n < k\n\ngoal (1 subgoal):\n 1. n * c < k * c", "apply(induction k, induction n, induction c)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>int inta intaa.\n       \\<lbrakk>0 < eint int \\<and> eint int \\<noteq> \\<infinity>;\n        eint inta < eint intaa;\n        0 < eint int \\<and> eint int \\<noteq> \\<infinity>; eint inta < k;\n        0 < eint int \\<and> eint int \\<noteq> \\<infinity>; n < k\\<rbrakk>\n       \\<Longrightarrow> eint inta * eint int < eint intaa * eint int\n 2. \\<And>int inta.\n       \\<lbrakk>0 < \\<infinity> \\<and> \\<infinity> \\<noteq> \\<infinity>;\n        eint int < eint inta;\n        0 < \\<infinity> \\<and> \\<infinity> \\<noteq> \\<infinity>;\n        eint int < k;\n        0 < \\<infinity> \\<and> \\<infinity> \\<noteq> \\<infinity>;\n        n < k\\<rbrakk>\n       \\<Longrightarrow> eint int * \\<infinity> < eint inta * \\<infinity>\n 3. \\<And>int.\n       \\<lbrakk>0 < c \\<and> c \\<noteq> \\<infinity>; \\<infinity> < eint int;\n        0 < c \\<and> c \\<noteq> \\<infinity>; \\<infinity> < k\\<rbrakk>\n       \\<Longrightarrow> \\<infinity> * c < eint int * c\n 4. \\<lbrakk>0 < c \\<and> c \\<noteq> \\<infinity>; n < \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> n * c < \\<infinity> * c", "by(auto simp add: zero_eint_def)"], ["", "lemma eint_mult_mono':\n  assumes \"(c::eint) \\<ge> 0 \\<and> c \\<noteq> \\<infinity>\"\n  assumes \"k > n\"\n  shows \"k*c \\<ge> n*c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n * c \\<le> k * c", "apply(cases \"c = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow> n * c \\<le> k * c\n 2. c \\<noteq> 0 \\<Longrightarrow> n * c \\<le> k * c", "apply (metis add.right_neutral assms(2) eint_add_left_cancel eint_ord_code(3) \n         eint_ord_simps(4) eq_iff less_le_trans mult.commute mult_eSuc_right' \n         mult_one_right not_less times_eint_simps(4) zero_eint_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow> n * c \\<le> k * c", "using assms eint_mult_mono"], ["proof (prove)\nusing this:\n  0 \\<le> c \\<and> c \\<noteq> \\<infinity>\n  n < k\n  \\<lbrakk>0 < ?c \\<and> ?c \\<noteq> \\<infinity>; ?n < ?k\\<rbrakk>\n  \\<Longrightarrow> ?n * ?c < ?k * ?c\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow> n * c \\<le> k * c", "by (simp add: le_less)"], ["", "lemma eint_minus_le:\n  assumes \"(b::eint) < c\"\n  shows \"c - b > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < c - b", "using assms"], ["proof (prove)\nusing this:\n  b < c\n\ngoal (1 subgoal):\n 1. 0 < c - b", "apply(induction b, induction c)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>int inta.\n       \\<lbrakk>eint inta < eint int; b < eint int\\<rbrakk>\n       \\<Longrightarrow> 0 < eint int - eint inta\n 2. \\<And>int.\n       \\<lbrakk>eint int < \\<infinity>; b < \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> 0 < \\<infinity> - eint int\n 3. \\<infinity> < c \\<Longrightarrow> 0 < c - \\<infinity>", "by (auto simp add: zero_eint_def)"], ["", "lemma eint_nat_times:\n  assumes \"(c::eint) > 0\"\n  shows \"(Suc n)*(c::eint) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < eint (int (Suc n)) * c", "using assms"], ["proof (prove)\nusing this:\n  0 < c\n\ngoal (1 subgoal):\n 1. 0 < eint (int (Suc n)) * c", "apply(induction c)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>inta.\n       0 < eint inta \\<Longrightarrow> 0 < eint (int (Suc n)) * eint inta\n 2. 0 < \\<infinity> \\<Longrightarrow> 0 < eint (int (Suc n)) * \\<infinity>", "apply (simp add: zero_eint_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < \\<infinity> \\<Longrightarrow> 0 < eint (int (Suc n)) * \\<infinity>", "by simp"], ["", "lemma eint_pos_times_is_pos:\n  assumes \"(c::eint) > 0\"\n  assumes \"b > 0\"\n  shows \"b*c > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < b * c", "using assms"], ["proof (prove)\nusing this:\n  0 < c\n  0 < b\n\ngoal (1 subgoal):\n 1. 0 < b * c", "apply(induction c, induction b)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>int inta.\n       \\<lbrakk>0 < eint inta; 0 < eint int; 0 < c; 0 < eint int\\<rbrakk>\n       \\<Longrightarrow> 0 < eint int * eint inta\n 2. \\<And>int.\n       \\<lbrakk>0 < eint int; 0 < \\<infinity>; 0 < c;\n        0 < \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> 0 < \\<infinity> * eint int\n 3. \\<lbrakk>0 < \\<infinity>; 0 < b\\<rbrakk>\n    \\<Longrightarrow> 0 < b * \\<infinity>", "by(auto simp add: zero_eint_def imult_infinity_right)"], ["", "lemma eint_nat_is_pos:\n\"eint (Suc n) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < eint (int (Suc n))", "by (simp add: zero_eint_def)"], ["", "lemma eint_pow_int_is_pos:\n  assumes \"n > 0\"\n  shows \"eint n > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < eint n", "using assms"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. 0 < eint n", "by (simp add: zero_eint_def)"], ["", "lemma eint_nat_times':\n  assumes \"(c::eint) \\<ge> 0\"\n  shows \"(Suc n)*c \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> Suc n * c", "using assms zero_eint_def"], ["proof (prove)\nusing this:\n  0 \\<le> eint (int c)\n  0 = eint 0\n\ngoal (1 subgoal):\n 1. 0 \\<le> Suc n * c", "by fastforce"], ["", "lemma eint_pos_int_times_ge:\n  assumes \"(c::eint) \\<ge> 0\"\n  assumes \"n > 0\"\n  shows \"eint n * c \\<ge> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<le> eint n * c", "using assms"], ["proof (prove)\nusing this:\n  0 \\<le> c\n  0 < n\n\ngoal (1 subgoal):\n 1. c \\<le> eint n * c", "apply(induction c)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>int.\n       \\<lbrakk>0 \\<le> eint int; 0 < n\\<rbrakk>\n       \\<Longrightarrow> eint int \\<le> eint n * eint int\n 2. \\<lbrakk>0 \\<le> \\<infinity>; 0 < n\\<rbrakk>\n    \\<Longrightarrow> \\<infinity> \\<le> eint n * \\<infinity>", "apply (smt eSuc_eint eint.distinct(2) eint_mult_mono' eint_pow_int_is_pos eq_iff ileI1 less_le mult.commute mult_one_right one_eint_def zero_eint_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> \\<infinity>; 0 < n\\<rbrakk>\n    \\<Longrightarrow> \\<infinity> \\<le> eint n * \\<infinity>", "by simp"], ["", "lemma eint_pos_int_times_gt:\n  assumes \"(c::eint) > 0\"\n  assumes \"c \\<noteq>\\<infinity>\"\n  assumes \"n > 1\"\n  shows \"eint n * c > c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c < eint n * c", "using assms eint_mult_mono[of c 1 \"eint n\"]"], ["proof (prove)\nusing this:\n  0 < c\n  c \\<noteq> \\<infinity>\n  1 < n\n  \\<lbrakk>0 < c \\<and> c \\<noteq> \\<infinity>; 1 < eint n\\<rbrakk>\n  \\<Longrightarrow> 1 * c < eint n * c\n\ngoal (1 subgoal):\n 1. c < eint n * c", "by (metis eint_ord_simps(2) mult_one_left one_eint_def)"], ["", "lemma eint_add_cancel_fact[simp]:\n  assumes \"(c::eint) \\<noteq> \\<infinity>\"\n  shows \"c + (b - c) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c + (b - c) = b", "using assms"], ["proof (prove)\nusing this:\n  c \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. c + (b - c) = b", "apply(induction c, induction b)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>int inta.\n       \\<lbrakk>eint inta \\<noteq> \\<infinity>;\n        c \\<noteq> \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> eint inta + (eint int - eint inta) = eint int\n 2. \\<And>int.\n       \\<lbrakk>eint int \\<noteq> \\<infinity>;\n        c \\<noteq> \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> eint int + (\\<infinity> - eint int) = \\<infinity>\n 3. \\<infinity> \\<noteq> \\<infinity> \\<Longrightarrow>\n    \\<infinity> + (b - \\<infinity>) = b", "by auto"], ["", "lemma nat_mult_not_infty[simp]:\n  assumes \"c \\<noteq> \\<infinity>\"\n  shows \"(eint n) * c \\<noteq> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eint n * c \\<noteq> \\<infinity>", "using assms"], ["proof (prove)\nusing this:\n  c \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. eint n * c \\<noteq> \\<infinity>", "by auto"], ["", "lemma eint_minus_distl:\n  assumes \"(b::eint) \\<noteq> d\"\n  shows \"b*c - d*c = (b-d)*c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b * c - d * c = (b - d) * c", "using assms"], ["proof (prove)\nusing this:\n  b \\<noteq> d\n\ngoal (1 subgoal):\n 1. b * c - d * c = (b - d) * c", "apply(induction c, induction b, induction d)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>int inta intaa.\n       \\<lbrakk>eint inta \\<noteq> eint int; eint inta \\<noteq> eint int;\n        b \\<noteq> eint int\\<rbrakk>\n       \\<Longrightarrow> eint inta * eint intaa - eint int * eint intaa =\n                         (eint inta - eint int) * eint intaa\n 2. \\<And>int inta.\n       \\<lbrakk>eint int \\<noteq> \\<infinity>;\n        eint int \\<noteq> \\<infinity>; b \\<noteq> \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> eint int * eint inta - \\<infinity> * eint inta =\n                         (eint int - \\<infinity>) * eint inta\n 3. \\<And>int.\n       \\<lbrakk>\\<infinity> \\<noteq> d; \\<infinity> \\<noteq> d\\<rbrakk>\n       \\<Longrightarrow> \\<infinity> * eint int - d * eint int =\n                         (\\<infinity> - d) * eint int\n 4. b \\<noteq> d \\<Longrightarrow>\n    b * \\<infinity> - d * \\<infinity> = (b - d) * \\<infinity>", "apply (metis add_diff_cancel_eint distrib_right eint.distinct(2) eint_add_cancel_fact nat_mult_not_infty)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>int inta.\n       \\<lbrakk>eint int \\<noteq> \\<infinity>;\n        eint int \\<noteq> \\<infinity>; b \\<noteq> \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> eint int * eint inta - \\<infinity> * eint inta =\n                         (eint int - \\<infinity>) * eint inta\n 2. \\<And>int.\n       \\<lbrakk>\\<infinity> \\<noteq> d; \\<infinity> \\<noteq> d\\<rbrakk>\n       \\<Longrightarrow> \\<infinity> * eint int - d * eint int =\n                         (\\<infinity> - d) * eint int\n 3. b \\<noteq> d \\<Longrightarrow>\n    b * \\<infinity> - d * \\<infinity> = (b - d) * \\<infinity>", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>int.\n       \\<lbrakk>\\<infinity> \\<noteq> d; \\<infinity> \\<noteq> d\\<rbrakk>\n       \\<Longrightarrow> \\<infinity> * eint int - d * eint int =\n                         (\\<infinity> - d) * eint int\n 2. b \\<noteq> d \\<Longrightarrow>\n    b * \\<infinity> - d * \\<infinity> = (b - d) * \\<infinity>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<noteq> d \\<Longrightarrow>\n    b * \\<infinity> - d * \\<infinity> = (b - d) * \\<infinity>", "by (simp add: mult.commute times_eint_def)"], ["", "lemma eint_minus_distr:\n  assumes \"(b::eint) \\<noteq> d\"\n  shows \"c*(b - d) = c*b - c*d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * (b - d) = c * b - c * d", "by (metis assms eint_minus_distl mult.commute)"], ["", "lemma eint_int_minus_distr:\n\"(eint n)*c - (eint m)*c = eint (n - m) * c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eint n * c - eint m * c = eint (n - m) * c", "by (metis add.right_neutral distrib_right eint_add_left_cancel eint_minus_distl idiff_eint_eint\n      idiff_infinity idiff_self infinity_ne_i0 nat_mult_not_infty not_eint_eq times_eint_simps(4))"], ["", "lemma eint_2_minus_1_mult[simp]:\n\"2*(b::eint) - b = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eint 2 * b - b = b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eint 2 * b - b = b", "have \"\\<forall>e. (\\<infinity>::eint) * e = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e. \\<infinity> * e = \\<infinity>", "by (simp add: times_eint_def)"], ["proof (state)\nthis:\n  \\<forall>e. \\<infinity> * e = \\<infinity>\n\ngoal (1 subgoal):\n 1. eint 2 * b - b = b", "then"], ["proof (chain)\npicking this:\n  \\<forall>e. \\<infinity> * e = \\<infinity>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>e. \\<infinity> * e = \\<infinity>\n\ngoal (1 subgoal):\n 1. eint 2 * b - b = b", "by (metis add_diff_cancel_eint idiff_infinity mult.commute mult_eSuc_right' mult_one_right one_add_one one_eint_def plus_eint_simps(1))"], ["proof (state)\nthis:\n  eint 2 * b - b = b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eint_minus_comm:\n\"(d::eint) + b - c = d - c + b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d + b - c = d - c + b", "apply(induction c )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>int. d + b - eint int = d - eint int + b\n 2. d + b - \\<infinity> = d - \\<infinity> + b", "apply (metis add.assoc add_diff_cancel_eint eint.distinct(2) eint_add_cancel_fact)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d + b - \\<infinity> = d - \\<infinity> + b", "apply(induction d)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>int. eint int + b - \\<infinity> = eint int - \\<infinity> + b\n 2. \\<infinity> + b - \\<infinity> = \\<infinity> - \\<infinity> + b", "apply (metis distrib_left eint2_cases eint_minus_distl i1_ne_infinity idiff_infinity_right \n           mult_one_left plus_eq_infty_iff_eint sum_infinity_imp_summand_infinity times_eint_simps(3))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<infinity> + b - \\<infinity> = \\<infinity> - \\<infinity> + b", "apply(induction b)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>int.\n       \\<infinity> + eint int - \\<infinity> =\n       \\<infinity> - \\<infinity> + eint int\n 2. \\<infinity> + \\<infinity> - \\<infinity> =\n    \\<infinity> - \\<infinity> + \\<infinity>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<infinity> + \\<infinity> - \\<infinity> =\n    \\<infinity> - \\<infinity> + \\<infinity>", "by simp"], ["", "lemma ge_plus_pos_imp_gt:\n  assumes \"(c::eint) \\<noteq>\\<infinity>\"\n  assumes \"(b::eint) > 0\"\n  assumes \"d \\<ge> c + b\"\n  shows \"d > c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c < d", "using assms"], ["proof (prove)\nusing this:\n  c \\<noteq> \\<infinity>\n  0 < b\n  c + b \\<le> d\n\ngoal (1 subgoal):\n 1. c < d", "apply(induction d, induction c)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>int inta.\n       \\<lbrakk>eint int \\<noteq> \\<infinity>; 0 < b;\n        eint int + b \\<le> eint inta; eint int \\<noteq> \\<infinity>; 0 < b;\n        eint int + b \\<le> d\\<rbrakk>\n       \\<Longrightarrow> eint int < eint inta\n 2. \\<And>int.\n       \\<lbrakk>\\<infinity> \\<noteq> \\<infinity>; 0 < b;\n        \\<infinity> + b \\<le> eint int; \\<infinity> \\<noteq> \\<infinity>;\n        0 < b; \\<infinity> + b \\<le> d\\<rbrakk>\n       \\<Longrightarrow> \\<infinity> < eint int\n 3. \\<lbrakk>c \\<noteq> \\<infinity>; 0 < b; c + b \\<le> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> c < \\<infinity>", "apply (metis add.comm_neutral assms(2) eint_add_left_cancel_less less_le_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>int.\n       \\<lbrakk>\\<infinity> \\<noteq> \\<infinity>; 0 < b;\n        \\<infinity> + b \\<le> eint int; \\<infinity> \\<noteq> \\<infinity>;\n        0 < b; \\<infinity> + b \\<le> d\\<rbrakk>\n       \\<Longrightarrow> \\<infinity> < eint int\n 2. \\<lbrakk>c \\<noteq> \\<infinity>; 0 < b; c + b \\<le> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> c < \\<infinity>", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c \\<noteq> \\<infinity>; 0 < b; c + b \\<le> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> c < \\<infinity>", "by simp"], ["", "lemma eint_minus_ineq:\n  assumes \"(c::eint) \\<noteq>\\<infinity>\"\n  assumes \"b \\<ge> d\"\n  shows \"b - c \\<ge> d - c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d - c \\<le> b - c", "by (metis add_left_mono antisym assms(1) assms(2) eint_add_cancel_fact linear)"], ["", "lemma eint_minus_ineq':\n  assumes \"(c::eint) \\<noteq>\\<infinity>\"\n  assumes \"b \\<ge> d\"\n  assumes \"(e::eint) > 0\"\n  assumes \"e \\<noteq> \\<infinity>\"\n  shows \"e*(b - c) \\<ge> e*(d - c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e * (d - c) \\<le> e * (b - c)", "using assms eint_minus_ineq"], ["proof (prove)\nusing this:\n  c \\<noteq> \\<infinity>\n  d \\<le> b\n  0 < e\n  e \\<noteq> \\<infinity>\n  \\<lbrakk>?c \\<noteq> \\<infinity>; ?d \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> ?d - ?c \\<le> ?b - ?c\n\ngoal (1 subgoal):\n 1. e * (d - c) \\<le> e * (b - c)", "by (metis eint_mult_mono' eq_iff less_le mult.commute)"], ["", "lemma eint_minus_ineq'':\n  assumes \"(c::eint) \\<noteq>\\<infinity>\"\n  assumes \"b \\<ge> d\"\n  assumes \"(e::eint) > 0\"\n  assumes \"e \\<noteq> \\<infinity>\"\n  shows \"e*(b - c) \\<ge> e*d - e*c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e * d - e * c \\<le> e * (b - c)", "using assms eint_minus_ineq'"], ["proof (prove)\nusing this:\n  c \\<noteq> \\<infinity>\n  d \\<le> b\n  0 < e\n  e \\<noteq> \\<infinity>\n  \\<lbrakk>?c \\<noteq> \\<infinity>; ?d \\<le> ?b; 0 < ?e;\n   ?e \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> ?e * (?d - ?c) \\<le> ?e * (?b - ?c)\n\ngoal (1 subgoal):\n 1. e * d - e * c \\<le> e * (b - c)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>c \\<noteq> \\<infinity>; d \\<le> b; 0 < e;\n     e \\<noteq> \\<infinity>;\n     \\<And>c d b e.\n        \\<lbrakk>c \\<noteq> \\<infinity>; d \\<le> b; 0 < e;\n         e \\<noteq> \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> e * (d - c) \\<le> e * (b - c)\\<rbrakk>\n    \\<Longrightarrow> e * d - e * c \\<le> e * (b - c)", "have \"\\<forall>e. (0::eint) + e = e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e. 0 + e = e", "by simp"], ["proof (state)\nthis:\n  \\<forall>e. 0 + e = e\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c \\<noteq> \\<infinity>; d \\<le> b; 0 < e;\n     e \\<noteq> \\<infinity>;\n     \\<And>c d b e.\n        \\<lbrakk>c \\<noteq> \\<infinity>; d \\<le> b; 0 < e;\n         e \\<noteq> \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> e * (d - c) \\<le> e * (b - c)\\<rbrakk>\n    \\<Longrightarrow> e * d - e * c \\<le> e * (b - c)", "then"], ["proof (chain)\npicking this:\n  \\<forall>e. 0 + e = e", "have f1: \"e * 0 = 0\""], ["proof (prove)\nusing this:\n  \\<forall>e. 0 + e = e\n\ngoal (1 subgoal):\n 1. e * 0 = 0", "by (metis add_diff_cancel_eint assms(4) idiff_self mult_eSuc_right' mult_one_right)"], ["proof (state)\nthis:\n  e * 0 = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c \\<noteq> \\<infinity>; d \\<le> b; 0 < e;\n     e \\<noteq> \\<infinity>;\n     \\<And>c d b e.\n        \\<lbrakk>c \\<noteq> \\<infinity>; d \\<le> b; 0 < e;\n         e \\<noteq> \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> e * (d - c) \\<le> e * (b - c)\\<rbrakk>\n    \\<Longrightarrow> e * d - e * c \\<le> e * (b - c)", "have \"\\<infinity> \\<noteq> c * e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<infinity> \\<noteq> c * e", "using assms(1) assms(4) eint_pos_times_is_pos"], ["proof (prove)\nusing this:\n  c \\<noteq> \\<infinity>\n  e \\<noteq> \\<infinity>\n  \\<lbrakk>0 < ?c; 0 < ?b\\<rbrakk> \\<Longrightarrow> 0 < ?b * ?c\n\ngoal (1 subgoal):\n 1. \\<infinity> \\<noteq> c * e", "by auto"], ["proof (state)\nthis:\n  \\<infinity> \\<noteq> c * e\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c \\<noteq> \\<infinity>; d \\<le> b; 0 < e;\n     e \\<noteq> \\<infinity>;\n     \\<And>c d b e.\n        \\<lbrakk>c \\<noteq> \\<infinity>; d \\<le> b; 0 < e;\n         e \\<noteq> \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> e * (d - c) \\<le> e * (b - c)\\<rbrakk>\n    \\<Longrightarrow> e * d - e * c \\<le> e * (b - c)", "then"], ["proof (chain)\npicking this:\n  \\<infinity> \\<noteq> c * e", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<infinity> \\<noteq> c * e\n\ngoal (1 subgoal):\n 1. e * d - e * c \\<le> e * (b - c)", "using f1"], ["proof (prove)\nusing this:\n  \\<infinity> \\<noteq> c * e\n  e * 0 = 0\n\ngoal (1 subgoal):\n 1. e * d - e * c \\<le> e * (b - c)", "by (metis assms(1) assms(2) assms(3) assms(4) eint_minus_distl eint_minus_ineq' idiff_self mult.commute)"], ["proof (state)\nthis:\n  e * d - e * c \\<le> e * (b - c)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eint_min_ineq:\n  assumes \"(b::eint) \\<ge> min c d\"\n  assumes \"c > e\"\n  assumes \"d > e\"\n  shows \"b > e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e < b", "by (meson assms(1) assms(2) assms(3) less_le_trans min_le_iff_disj)"], ["", "lemma eint_plus_times:\n  assumes \"(d::eint) \\<ge> 0\"\n  assumes \"(b::eint) \\<ge> c + (eint k)*d\"\n  assumes \"k \\<ge> l\"\n  shows \"b \\<ge> c + l*d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c + eint l * d \\<le> b", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. c + eint l * d \\<le> b", "have \"k*d \\<ge> l*d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eint l * d \\<le> eint k * d", "by (smt assms(1) assms(3) eint_mult_mono' eint_ord_simps(2) eq_iff times_eint_simps(4))"], ["proof (state)\nthis:\n  eint l * d \\<le> eint k * d\n\ngoal (1 subgoal):\n 1. c + eint l * d \\<le> b", "thus ?thesis"], ["proof (prove)\nusing this:\n  eint l * d \\<le> eint k * d\n\ngoal (1 subgoal):\n 1. c + eint l * d \\<le> b", "by (meson add_mono_thms_linordered_semiring(2) assms(2) order_subst2)"], ["proof (state)\nthis:\n  c + eint l * d \\<le> b\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}