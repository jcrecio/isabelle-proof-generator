{"file_name": "/home/qj213/afp-2021-10-22/thys/Psi_Calculi/Subst_Term.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Psi_Calculi", "problem_names": ["lemma suppSubst:\n  fixes M    :: 'a\n  and   xvec :: \"name list\"\n  and   Tvec :: \"'b list\"\n  \n  shows \"(supp(M[xvec::=Tvec])::name set) \\<subseteq> ((supp M) \\<union> (supp xvec) \\<union> (supp Tvec))\"", "lemma subst2[intro]:\n  fixes x    :: name\n  and   M    :: 'a\n  and   xvec :: \"name list\"\n  and   Tvec :: \"'b list\"\n  \n  assumes \"x \\<sharp> M\"\n  and     \"x \\<sharp> xvec\"\n  and     \"x \\<sharp> Tvec\"\n\n  shows \"x \\<sharp> M[xvec::=Tvec]\"", "lemma subst2Chain[intro]:\n  fixes yvec :: \"name list\"\n  and   M    :: 'a\n  and   xvec :: \"name list\"\n  and   Tvec :: \"'b list\"\n  \n  assumes \"yvec \\<sharp>* M\"\n  and     \"yvec \\<sharp>* xvec\"\n  and     \"yvec \\<sharp>* Tvec\"\n\n  shows \"yvec \\<sharp>* M[xvec::=Tvec]\"", "lemma fs[simp]: \"finite ((supp subst)::name set)\"", "lemma subst3Chain:\n  fixes xvec :: \"name list\"\n  and   Tvec :: \"'b list\"\n  and   Xs   :: \"name set\"\n  and   T    :: 'a\n\n  assumes \"length xvec = length Tvec\"\n  and     \"distinct xvec\"\n  and     \"set xvec \\<subseteq> supp T\"\n  and     \"Xs \\<sharp>* T[xvec::=Tvec]\"\n\n  shows \"Xs \\<sharp>* Tvec\"", "lemma subst4Chain:\n  fixes xvec :: \"name list\"\n  and   Tvec :: \"'b list\"\n  and   T    :: 'a\n\n  assumes \"length xvec = length Tvec\"\n  and     \"distinct xvec\"\n  and     \"xvec \\<sharp>* Tvec\"\n\n  shows \"xvec \\<sharp>* T[xvec::=Tvec]\"", "lemma seqSubstNil[simp]:\n  \"seqSubst M [] = M\"", "lemma seqSubstCons[simp]:\n  shows \"seqSubst M ((xvec, Tvec)#\\<sigma>) = seqSubst(M[xvec::=Tvec]) \\<sigma>\"", "lemma seqSubstTermAppend[simp]:\n  shows \"seqSubst M (\\<sigma>@\\<sigma>') = seqSubst (seqSubst M \\<sigma>) \\<sigma>'\"", "lemma wellFormedSubstEqvt[eqvt]:\n  fixes \\<sigma> :: \"(('d::fs_name) list \\<times> ('e::fs_name) list) list\"\n  and   p :: \"name prm\"\n\n  shows \"p \\<bullet> (wellFormedSubst \\<sigma>) = wellFormedSubst(p \\<bullet> \\<sigma>)\"", "lemma wellFormedSimp[simp]:\n  fixes \\<sigma> :: \"(('d::fs_name) list \\<times> ('e::fs_name) list) list\"\n  and   p :: \"name prm\"\n  \n  shows \"wellFormedSubst(p \\<bullet> \\<sigma>) = wellFormedSubst \\<sigma>\"", "lemma wellFormedNil[simp]:\n  \"wellFormedSubst []\"", "lemma wellFormedCons[simp]:\n  shows \"wellFormedSubst((xvec, Tvec)#\\<sigma>) = (length xvec = length Tvec \\<and> distinct xvec \\<and> wellFormedSubst \\<sigma>)\"", "lemma wellFormedAppend[simp]:\n  fixes \\<sigma>  :: \"(('d::fs_name) list \\<times> ('e::fs_name) list) list\"\n  and   \\<sigma>' :: \"(('d::fs_name) list \\<times> ('e::fs_name) list) list\"\n\n  shows \"wellFormedSubst(\\<sigma>@\\<sigma>') = (wellFormedSubst \\<sigma> \\<and> wellFormedSubst \\<sigma>')\"", "lemma seqSubst2[intro]:\n  fixes \\<sigma> :: \"(name list \\<times> 'b list) list\"\n  and   T :: 'a\n  and   x :: name\n\n  assumes \"x \\<sharp> \\<sigma>\"\n  and     \"x \\<sharp> T\"\n\n  shows \"x \\<sharp> T[<\\<sigma>>]\"", "lemma seqSubst2Chain[intro]:\n  fixes \\<sigma>    :: \"(name list \\<times> 'b list) list\"\n  and   T    :: 'a\n  and   xvec :: \"name list\"\n\n  assumes \"xvec \\<sharp>* \\<sigma>\"\n  and     \"xvec \\<sharp>* T\"\n\n  shows \"xvec \\<sharp>* T[<\\<sigma>>]\""], "translations": [["", "lemma suppSubst:\n  fixes M    :: 'a\n  and   xvec :: \"name list\"\n  and   Tvec :: \"'b list\"\n  \n  shows \"(supp(M[xvec::=Tvec])::name set) \\<subseteq> ((supp M) \\<union> (supp xvec) \\<union> (supp Tvec))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (M[xvec::=Tvec])\n    \\<subseteq> supp M \\<union> supp xvec \\<union> supp Tvec", "proof(auto simp add: eqvts supp_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>infinite\n                 {b. [(x, b)] \\<bullet>\n                     M[[(x, b)] \\<bullet>\n                       xvec::=[(x, b)] \\<bullet> Tvec] \\<noteq>\n                     M[xvec::=Tvec]};\n        finite {b. [(x, b)] \\<bullet> Tvec \\<noteq> Tvec};\n        finite {b. [(x, b)] \\<bullet> xvec \\<noteq> xvec};\n        finite {b. [(x, b)] \\<bullet> M \\<noteq> M}\\<rbrakk>\n       \\<Longrightarrow> False", "fix x::name"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>infinite\n                 {b. [(x, b)] \\<bullet>\n                     M[[(x, b)] \\<bullet>\n                       xvec::=[(x, b)] \\<bullet> Tvec] \\<noteq>\n                     M[xvec::=Tvec]};\n        finite {b. [(x, b)] \\<bullet> Tvec \\<noteq> Tvec};\n        finite {b. [(x, b)] \\<bullet> xvec \\<noteq> xvec};\n        finite {b. [(x, b)] \\<bullet> M \\<noteq> M}\\<rbrakk>\n       \\<Longrightarrow> False", "let ?P = \"\\<lambda>y. ([(x, y)] \\<bullet> M)[([(x, y)] \\<bullet> xvec)::=([(x, y)] \\<bullet> Tvec)] \\<noteq> M[xvec::=Tvec]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>infinite\n                 {b. [(x, b)] \\<bullet>\n                     M[[(x, b)] \\<bullet>\n                       xvec::=[(x, b)] \\<bullet> Tvec] \\<noteq>\n                     M[xvec::=Tvec]};\n        finite {b. [(x, b)] \\<bullet> Tvec \\<noteq> Tvec};\n        finite {b. [(x, b)] \\<bullet> xvec \\<noteq> xvec};\n        finite {b. [(x, b)] \\<bullet> M \\<noteq> M}\\<rbrakk>\n       \\<Longrightarrow> False", "let ?Q = \"\\<lambda>y M. ([(x, y)] \\<bullet> M) \\<noteq> (M::'a)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>infinite\n                 {b. [(x, b)] \\<bullet>\n                     M[[(x, b)] \\<bullet>\n                       xvec::=[(x, b)] \\<bullet> Tvec] \\<noteq>\n                     M[xvec::=Tvec]};\n        finite {b. [(x, b)] \\<bullet> Tvec \\<noteq> Tvec};\n        finite {b. [(x, b)] \\<bullet> xvec \\<noteq> xvec};\n        finite {b. [(x, b)] \\<bullet> M \\<noteq> M}\\<rbrakk>\n       \\<Longrightarrow> False", "let ?R = \"\\<lambda>y xvec. ([(x, y)] \\<bullet> xvec) \\<noteq> (xvec::name list)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>infinite\n                 {b. [(x, b)] \\<bullet>\n                     M[[(x, b)] \\<bullet>\n                       xvec::=[(x, b)] \\<bullet> Tvec] \\<noteq>\n                     M[xvec::=Tvec]};\n        finite {b. [(x, b)] \\<bullet> Tvec \\<noteq> Tvec};\n        finite {b. [(x, b)] \\<bullet> xvec \\<noteq> xvec};\n        finite {b. [(x, b)] \\<bullet> M \\<noteq> M}\\<rbrakk>\n       \\<Longrightarrow> False", "let ?S = \"\\<lambda>y Tvec. ([(x, y)] \\<bullet> Tvec) \\<noteq> (Tvec::'b list)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>infinite\n                 {b. [(x, b)] \\<bullet>\n                     M[[(x, b)] \\<bullet>\n                       xvec::=[(x, b)] \\<bullet> Tvec] \\<noteq>\n                     M[xvec::=Tvec]};\n        finite {b. [(x, b)] \\<bullet> Tvec \\<noteq> Tvec};\n        finite {b. [(x, b)] \\<bullet> xvec \\<noteq> xvec};\n        finite {b. [(x, b)] \\<bullet> M \\<noteq> M}\\<rbrakk>\n       \\<Longrightarrow> False", "assume A: \"finite {y. ?Q y M}\" and B: \"finite {y. ?R y xvec}\" and C: \"finite {y. ?S y Tvec}\" and D: \"infinite {y. ?P(y)}\""], ["proof (state)\nthis:\n  finite {y. [(x, y)] \\<bullet> M \\<noteq> M}\n  finite {y. [(x, y)] \\<bullet> xvec \\<noteq> xvec}\n  finite {y. [(x, y)] \\<bullet> Tvec \\<noteq> Tvec}\n  infinite\n   {y. [(x, y)] \\<bullet>\n       M[[(x, y)] \\<bullet> xvec::=[(x, y)] \\<bullet> Tvec] \\<noteq>\n       M[xvec::=Tvec]}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>infinite\n                 {b. [(x, b)] \\<bullet>\n                     M[[(x, b)] \\<bullet>\n                       xvec::=[(x, b)] \\<bullet> Tvec] \\<noteq>\n                     M[xvec::=Tvec]};\n        finite {b. [(x, b)] \\<bullet> Tvec \\<noteq> Tvec};\n        finite {b. [(x, b)] \\<bullet> xvec \\<noteq> xvec};\n        finite {b. [(x, b)] \\<bullet> M \\<noteq> M}\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"infinite({y. ?P(y)} - {y. ?Q y M}  - {y. ?R y xvec}  - {y. ?S y Tvec})\""], ["proof (prove)\nusing this:\n  finite {y. [(x, y)] \\<bullet> M \\<noteq> M}\n  finite {y. [(x, y)] \\<bullet> xvec \\<noteq> xvec}\n  finite {y. [(x, y)] \\<bullet> Tvec \\<noteq> Tvec}\n  infinite\n   {y. [(x, y)] \\<bullet>\n       M[[(x, y)] \\<bullet> xvec::=[(x, y)] \\<bullet> Tvec] \\<noteq>\n       M[xvec::=Tvec]}\n\ngoal (1 subgoal):\n 1. infinite\n     ({y. [(x, y)] \\<bullet>\n          M[[(x, y)] \\<bullet> xvec::=[(x, y)] \\<bullet> Tvec] \\<noteq>\n          M[xvec::=Tvec]} -\n      {y. [(x, y)] \\<bullet> M \\<noteq> M} -\n      {y. [(x, y)] \\<bullet> xvec \\<noteq> xvec} -\n      {y. [(x, y)] \\<bullet> Tvec \\<noteq> Tvec})", "by(auto intro: Diff_infinite_finite)"], ["proof (state)\nthis:\n  infinite\n   ({y. [(x, y)] \\<bullet>\n        M[[(x, y)] \\<bullet> xvec::=[(x, y)] \\<bullet> Tvec] \\<noteq>\n        M[xvec::=Tvec]} -\n    {y. [(x, y)] \\<bullet> M \\<noteq> M} -\n    {y. [(x, y)] \\<bullet> xvec \\<noteq> xvec} -\n    {y. [(x, y)] \\<bullet> Tvec \\<noteq> Tvec})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>infinite\n                 {b. [(x, b)] \\<bullet>\n                     M[[(x, b)] \\<bullet>\n                       xvec::=[(x, b)] \\<bullet> Tvec] \\<noteq>\n                     M[xvec::=Tvec]};\n        finite {b. [(x, b)] \\<bullet> Tvec \\<noteq> Tvec};\n        finite {b. [(x, b)] \\<bullet> xvec \\<noteq> xvec};\n        finite {b. [(x, b)] \\<bullet> M \\<noteq> M}\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"infinite({y. ?P(y) \\<and> \\<not>(?Q y M) \\<and> \\<not> (?R y xvec) \\<and> \\<not> (?S y Tvec)})\""], ["proof (prove)\nusing this:\n  infinite\n   ({y. [(x, y)] \\<bullet>\n        M[[(x, y)] \\<bullet> xvec::=[(x, y)] \\<bullet> Tvec] \\<noteq>\n        M[xvec::=Tvec]} -\n    {y. [(x, y)] \\<bullet> M \\<noteq> M} -\n    {y. [(x, y)] \\<bullet> xvec \\<noteq> xvec} -\n    {y. [(x, y)] \\<bullet> Tvec \\<noteq> Tvec})\n\ngoal (1 subgoal):\n 1. infinite\n     {y. [(x, y)] \\<bullet>\n         M[[(x, y)] \\<bullet> xvec::=[(x, y)] \\<bullet> Tvec] \\<noteq>\n         M[xvec::=Tvec] \\<and>\n         \\<not> [(x, y)] \\<bullet> M \\<noteq> M \\<and>\n         \\<not> [(x, y)] \\<bullet> xvec \\<noteq> xvec \\<and>\n         \\<not> [(x, y)] \\<bullet> Tvec \\<noteq> Tvec}", "by(simp add: set_diff_eq)"], ["proof (state)\nthis:\n  infinite\n   {y. [(x, y)] \\<bullet>\n       M[[(x, y)] \\<bullet> xvec::=[(x, y)] \\<bullet> Tvec] \\<noteq>\n       M[xvec::=Tvec] \\<and>\n       \\<not> [(x, y)] \\<bullet> M \\<noteq> M \\<and>\n       \\<not> [(x, y)] \\<bullet> xvec \\<noteq> xvec \\<and>\n       \\<not> [(x, y)] \\<bullet> Tvec \\<noteq> Tvec}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>infinite\n                 {b. [(x, b)] \\<bullet>\n                     M[[(x, b)] \\<bullet>\n                       xvec::=[(x, b)] \\<bullet> Tvec] \\<noteq>\n                     M[xvec::=Tvec]};\n        finite {b. [(x, b)] \\<bullet> Tvec \\<noteq> Tvec};\n        finite {b. [(x, b)] \\<bullet> xvec \\<noteq> xvec};\n        finite {b. [(x, b)] \\<bullet> M \\<noteq> M}\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  infinite\n   {y. [(x, y)] \\<bullet>\n       M[[(x, y)] \\<bullet> xvec::=[(x, y)] \\<bullet> Tvec] \\<noteq>\n       M[xvec::=Tvec] \\<and>\n       \\<not> [(x, y)] \\<bullet> M \\<noteq> M \\<and>\n       \\<not> [(x, y)] \\<bullet> xvec \\<noteq> xvec \\<and>\n       \\<not> [(x, y)] \\<bullet> Tvec \\<noteq> Tvec}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>infinite\n                 {b. [(x, b)] \\<bullet>\n                     M[[(x, b)] \\<bullet>\n                       xvec::=[(x, b)] \\<bullet> Tvec] \\<noteq>\n                     M[xvec::=Tvec]};\n        finite {b. [(x, b)] \\<bullet> Tvec \\<noteq> Tvec};\n        finite {b. [(x, b)] \\<bullet> xvec \\<noteq> xvec};\n        finite {b. [(x, b)] \\<bullet> M \\<noteq> M}\\<rbrakk>\n       \\<Longrightarrow> False", "have \"{y. ?P(y) \\<and> \\<not>(?Q y M) \\<and> \\<not> (?R y xvec) \\<and> \\<not> (?S y Tvec)} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. [(x, y)] \\<bullet>\n        M[[(x, y)] \\<bullet> xvec::=[(x, y)] \\<bullet> Tvec] \\<noteq>\n        M[xvec::=Tvec] \\<and>\n        \\<not> [(x, y)] \\<bullet> M \\<noteq> M \\<and>\n        \\<not> [(x, y)] \\<bullet> xvec \\<noteq> xvec \\<and>\n        \\<not> [(x, y)] \\<bullet> Tvec \\<noteq> Tvec} =\n    {}", "by auto"], ["proof (state)\nthis:\n  {y. [(x, y)] \\<bullet>\n      M[[(x, y)] \\<bullet> xvec::=[(x, y)] \\<bullet> Tvec] \\<noteq>\n      M[xvec::=Tvec] \\<and>\n      \\<not> [(x, y)] \\<bullet> M \\<noteq> M \\<and>\n      \\<not> [(x, y)] \\<bullet> xvec \\<noteq> xvec \\<and>\n      \\<not> [(x, y)] \\<bullet> Tvec \\<noteq> Tvec} =\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>infinite\n                 {b. [(x, b)] \\<bullet>\n                     M[[(x, b)] \\<bullet>\n                       xvec::=[(x, b)] \\<bullet> Tvec] \\<noteq>\n                     M[xvec::=Tvec]};\n        finite {b. [(x, b)] \\<bullet> Tvec \\<noteq> Tvec};\n        finite {b. [(x, b)] \\<bullet> xvec \\<noteq> xvec};\n        finite {b. [(x, b)] \\<bullet> M \\<noteq> M}\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  infinite\n   {y. [(x, y)] \\<bullet>\n       M[[(x, y)] \\<bullet> xvec::=[(x, y)] \\<bullet> Tvec] \\<noteq>\n       M[xvec::=Tvec] \\<and>\n       \\<not> [(x, y)] \\<bullet> M \\<noteq> M \\<and>\n       \\<not> [(x, y)] \\<bullet> xvec \\<noteq> xvec \\<and>\n       \\<not> [(x, y)] \\<bullet> Tvec \\<noteq> Tvec}\n  {y. [(x, y)] \\<bullet>\n      M[[(x, y)] \\<bullet> xvec::=[(x, y)] \\<bullet> Tvec] \\<noteq>\n      M[xvec::=Tvec] \\<and>\n      \\<not> [(x, y)] \\<bullet> M \\<noteq> M \\<and>\n      \\<not> [(x, y)] \\<bullet> xvec \\<noteq> xvec \\<and>\n      \\<not> [(x, y)] \\<bullet> Tvec \\<noteq> Tvec} =\n  {}", "have \"infinite {}\""], ["proof (prove)\nusing this:\n  infinite\n   {y. [(x, y)] \\<bullet>\n       M[[(x, y)] \\<bullet> xvec::=[(x, y)] \\<bullet> Tvec] \\<noteq>\n       M[xvec::=Tvec] \\<and>\n       \\<not> [(x, y)] \\<bullet> M \\<noteq> M \\<and>\n       \\<not> [(x, y)] \\<bullet> xvec \\<noteq> xvec \\<and>\n       \\<not> [(x, y)] \\<bullet> Tvec \\<noteq> Tvec}\n  {y. [(x, y)] \\<bullet>\n      M[[(x, y)] \\<bullet> xvec::=[(x, y)] \\<bullet> Tvec] \\<noteq>\n      M[xvec::=Tvec] \\<and>\n      \\<not> [(x, y)] \\<bullet> M \\<noteq> M \\<and>\n      \\<not> [(x, y)] \\<bullet> xvec \\<noteq> xvec \\<and>\n      \\<not> [(x, y)] \\<bullet> Tvec \\<noteq> Tvec} =\n  {}\n\ngoal (1 subgoal):\n 1. infinite {}", "by(drule_tac Infinite_cong) auto"], ["proof (state)\nthis:\n  infinite {}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>infinite\n                 {b. [(x, b)] \\<bullet>\n                     M[[(x, b)] \\<bullet>\n                       xvec::=[(x, b)] \\<bullet> Tvec] \\<noteq>\n                     M[xvec::=Tvec]};\n        finite {b. [(x, b)] \\<bullet> Tvec \\<noteq> Tvec};\n        finite {b. [(x, b)] \\<bullet> xvec \\<noteq> xvec};\n        finite {b. [(x, b)] \\<bullet> M \\<noteq> M}\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  infinite {}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subst2[intro]:\n  fixes x    :: name\n  and   M    :: 'a\n  and   xvec :: \"name list\"\n  and   Tvec :: \"'b list\"\n  \n  assumes \"x \\<sharp> M\"\n  and     \"x \\<sharp> xvec\"\n  and     \"x \\<sharp> Tvec\"\n\n  shows \"x \\<sharp> M[xvec::=Tvec]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> M[xvec::=Tvec]", "using assms suppSubst"], ["proof (prove)\nusing this:\n  x \\<sharp> M\n  x \\<sharp> xvec\n  x \\<sharp> Tvec\n  supp (?M[?xvec::=?Tvec])\n  \\<subseteq> supp ?M \\<union> supp ?xvec \\<union> supp ?Tvec\n\ngoal (1 subgoal):\n 1. x \\<sharp> M[xvec::=Tvec]", "by(auto simp add: fresh_def)"], ["", "lemma subst2Chain[intro]:\n  fixes yvec :: \"name list\"\n  and   M    :: 'a\n  and   xvec :: \"name list\"\n  and   Tvec :: \"'b list\"\n  \n  assumes \"yvec \\<sharp>* M\"\n  and     \"yvec \\<sharp>* xvec\"\n  and     \"yvec \\<sharp>* Tvec\"\n\n  shows \"yvec \\<sharp>* M[xvec::=Tvec]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. yvec \\<sharp>* M[xvec::=Tvec]", "using assms"], ["proof (prove)\nusing this:\n  yvec \\<sharp>* M\n  yvec \\<sharp>* xvec\n  yvec \\<sharp>* Tvec\n\ngoal (1 subgoal):\n 1. yvec \\<sharp>* M[xvec::=Tvec]", "by(induct yvec) auto"], ["", "lemma fs[simp]: \"finite ((supp subst)::name set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (supp subst)", "by(simp add: supp_def perm_fun_def eqvts)"], ["", "(*\nlemma subst1Chain:\n  fixes xvec :: \"name list\"\n  and   Tvec :: \"'b list\"\n  and   Xs   :: \"name set\"\n  and   T    :: 'a\n\n  assumes \"length xvec = length Tvec\"\n  and     \"distinct xvec\"\n  and     \"Xs \\<sharp>* T[xvec::=Tvec]\"\n  and     \"Xs \\<sharp>* xvec\"\n\n  shows \"Xs \\<sharp>* T\"\nusing assms\nby(auto intro: subst1 simp add: fresh_star_def)\n*)"], ["", "lemma subst3Chain:\n  fixes xvec :: \"name list\"\n  and   Tvec :: \"'b list\"\n  and   Xs   :: \"name set\"\n  and   T    :: 'a\n\n  assumes \"length xvec = length Tvec\"\n  and     \"distinct xvec\"\n  and     \"set xvec \\<subseteq> supp T\"\n  and     \"Xs \\<sharp>* T[xvec::=Tvec]\"\n\n  shows \"Xs \\<sharp>* Tvec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Xs \\<sharp>* Tvec", "using assms"], ["proof (prove)\nusing this:\n  length xvec = length Tvec\n  distinct xvec\n  set xvec \\<subseteq> supp T\n  Xs \\<sharp>* T[xvec::=Tvec]\n\ngoal (1 subgoal):\n 1. Xs \\<sharp>* Tvec", "by(auto intro: subst3 simp add: fresh_star_def)"], ["", "lemma subst4Chain:\n  fixes xvec :: \"name list\"\n  and   Tvec :: \"'b list\"\n  and   T    :: 'a\n\n  assumes \"length xvec = length Tvec\"\n  and     \"distinct xvec\"\n  and     \"xvec \\<sharp>* Tvec\"\n\n  shows \"xvec \\<sharp>* T[xvec::=Tvec]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xvec \\<sharp>* T[xvec::=Tvec]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. xvec \\<sharp>* T[xvec::=Tvec]", "obtain p where \"((p::name prm) \\<bullet> (xvec::name list)) \\<sharp>* T\" and \"(p \\<bullet> xvec) \\<sharp>* xvec\"\n             and S: \"(set p) \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\"\n             and \"distinctPerm p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>(p \\<bullet> xvec) \\<sharp>* T;\n         (p \\<bullet> xvec) \\<sharp>* xvec;\n         set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec);\n         distinctPerm p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule_tac xvec=xvec and c=\"(T, xvec)\" in name_list_avoiding) auto"], ["proof (state)\nthis:\n  (p \\<bullet> xvec) \\<sharp>* T\n  (p \\<bullet> xvec) \\<sharp>* xvec\n  set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\n  distinctPerm p\n\ngoal (1 subgoal):\n 1. xvec \\<sharp>* T[xvec::=Tvec]", "from \\<open>length xvec = length Tvec\\<close>"], ["proof (chain)\npicking this:\n  length xvec = length Tvec", "have \"length(p \\<bullet> xvec) = length Tvec\""], ["proof (prove)\nusing this:\n  length xvec = length Tvec\n\ngoal (1 subgoal):\n 1. length (p \\<bullet> xvec) = length Tvec", "by simp"], ["proof (state)\nthis:\n  length (p \\<bullet> xvec) = length Tvec\n\ngoal (1 subgoal):\n 1. xvec \\<sharp>* T[xvec::=Tvec]", "moreover"], ["proof (state)\nthis:\n  length (p \\<bullet> xvec) = length Tvec\n\ngoal (1 subgoal):\n 1. xvec \\<sharp>* T[xvec::=Tvec]", "from \\<open>(p \\<bullet> xvec) \\<sharp>* T\\<close>"], ["proof (chain)\npicking this:\n  (p \\<bullet> xvec) \\<sharp>* T", "have \"(p \\<bullet> p \\<bullet> xvec) \\<sharp>* (p \\<bullet> T)\""], ["proof (prove)\nusing this:\n  (p \\<bullet> xvec) \\<sharp>* T\n\ngoal (1 subgoal):\n 1. (p \\<bullet> p \\<bullet> xvec) \\<sharp>* (p \\<bullet> T)", "by(simp add: pt_fresh_star_bij[OF pt_name_inst, OF at_name_inst])"], ["proof (state)\nthis:\n  (p \\<bullet> p \\<bullet> xvec) \\<sharp>* (p \\<bullet> T)\n\ngoal (1 subgoal):\n 1. xvec \\<sharp>* T[xvec::=Tvec]", "with \\<open>distinctPerm p\\<close>"], ["proof (chain)\npicking this:\n  distinctPerm p\n  (p \\<bullet> p \\<bullet> xvec) \\<sharp>* (p \\<bullet> T)", "have \"xvec \\<sharp>* (p \\<bullet> T)\""], ["proof (prove)\nusing this:\n  distinctPerm p\n  (p \\<bullet> p \\<bullet> xvec) \\<sharp>* (p \\<bullet> T)\n\ngoal (1 subgoal):\n 1. xvec \\<sharp>* (p \\<bullet> T)", "by simp"], ["proof (state)\nthis:\n  xvec \\<sharp>* (p \\<bullet> T)\n\ngoal (1 subgoal):\n 1. xvec \\<sharp>* T[xvec::=Tvec]", "ultimately"], ["proof (chain)\npicking this:\n  length (p \\<bullet> xvec) = length Tvec\n  xvec \\<sharp>* (p \\<bullet> T)", "have \"(set xvec) \\<sharp>* (p \\<bullet> T)[(p \\<bullet> xvec)::=Tvec]\""], ["proof (prove)\nusing this:\n  length (p \\<bullet> xvec) = length Tvec\n  xvec \\<sharp>* (p \\<bullet> T)\n\ngoal (1 subgoal):\n 1. set xvec \\<sharp>* p \\<bullet> T[p \\<bullet> xvec::=Tvec]", "using \\<open>xvec \\<sharp>* Tvec\\<close> \\<open>(p \\<bullet> xvec) \\<sharp>* xvec\\<close>"], ["proof (prove)\nusing this:\n  length (p \\<bullet> xvec) = length Tvec\n  xvec \\<sharp>* (p \\<bullet> T)\n  xvec \\<sharp>* Tvec\n  (p \\<bullet> xvec) \\<sharp>* xvec\n\ngoal (1 subgoal):\n 1. set xvec \\<sharp>* p \\<bullet> T[p \\<bullet> xvec::=Tvec]", "by auto"], ["proof (state)\nthis:\n  set xvec \\<sharp>* p \\<bullet> T[p \\<bullet> xvec::=Tvec]\n\ngoal (1 subgoal):\n 1. xvec \\<sharp>* T[xvec::=Tvec]", "thus ?thesis"], ["proof (prove)\nusing this:\n  set xvec \\<sharp>* p \\<bullet> T[p \\<bullet> xvec::=Tvec]\n\ngoal (1 subgoal):\n 1. xvec \\<sharp>* T[xvec::=Tvec]", "using \\<open>length xvec = length Tvec\\<close> \\<open>distinct xvec\\<close> S \\<open>(p \\<bullet> xvec) \\<sharp>* T\\<close> \\<open>distinctPerm p\\<close>"], ["proof (prove)\nusing this:\n  set xvec \\<sharp>* p \\<bullet> T[p \\<bullet> xvec::=Tvec]\n  length xvec = length Tvec\n  distinct xvec\n  set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\n  (p \\<bullet> xvec) \\<sharp>* T\n  distinctPerm p\n\ngoal (1 subgoal):\n 1. xvec \\<sharp>* T[xvec::=Tvec]", "by(simp add: renaming)"], ["proof (state)\nthis:\n  xvec \\<sharp>* T[xvec::=Tvec]\n\ngoal:\nNo subgoals!", "qed"], ["", "definition seqSubst :: \"'a \\<Rightarrow> (name list \\<times> 'b list) list \\<Rightarrow> 'a\" (\"_[<_>]\" [80, 80] 130)\n  where \"M[<\\<sigma>>] \\<equiv> foldl (\\<lambda>N. \\<lambda>(xvec, Tvec). N[xvec::=Tvec]) M \\<sigma>\""], ["", "lemma seqSubstNil[simp]:\n  \"seqSubst M [] = M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M[<[]>] = M", "by(simp add: seqSubst_def)"], ["", "lemma seqSubstCons[simp]:\n  shows \"seqSubst M ((xvec, Tvec)#\\<sigma>) = seqSubst(M[xvec::=Tvec]) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M[<((xvec, Tvec) # \\<sigma>)>] = M[xvec::=Tvec][<\\<sigma>>]", "by(simp add: seqSubst_def)"], ["", "lemma seqSubstTermAppend[simp]:\n  shows \"seqSubst M (\\<sigma>@\\<sigma>') = seqSubst (seqSubst M \\<sigma>) \\<sigma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M[<(\\<sigma> @ \\<sigma>')>] = M[<\\<sigma>>][<\\<sigma>'>]", "by(induct \\<sigma>) (auto simp add: seqSubst_def)"], ["", "definition wellFormedSubst :: \"(('d::fs_name) list \\<times> ('e::fs_name) list) list \\<Rightarrow> bool\" where \"wellFormedSubst \\<sigma> = ((filter (\\<lambda>(xvec, Tvec). \\<not>(length xvec = length Tvec \\<and> distinct xvec)) \\<sigma>) = [])\""], ["", "lemma wellFormedSubstEqvt[eqvt]:\n  fixes \\<sigma> :: \"(('d::fs_name) list \\<times> ('e::fs_name) list) list\"\n  and   p :: \"name prm\"\n\n  shows \"p \\<bullet> (wellFormedSubst \\<sigma>) = wellFormedSubst(p \\<bullet> \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> wellFormedSubst \\<sigma> =\n    wellFormedSubst (p \\<bullet> \\<sigma>)", "by(induct \\<sigma> arbitrary: p) (auto simp add: eqvts wellFormedSubst_def)"], ["", "lemma wellFormedSimp[simp]:\n  fixes \\<sigma> :: \"(('d::fs_name) list \\<times> ('e::fs_name) list) list\"\n  and   p :: \"name prm\"\n  \n  shows \"wellFormedSubst(p \\<bullet> \\<sigma>) = wellFormedSubst \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellFormedSubst (p \\<bullet> \\<sigma>) = wellFormedSubst \\<sigma>", "by(induct \\<sigma>) (auto simp add: eqvts wellFormedSubst_def)"], ["", "lemma wellFormedNil[simp]:\n  \"wellFormedSubst []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellFormedSubst []", "by(simp add: wellFormedSubst_def)"], ["", "lemma wellFormedCons[simp]:\n  shows \"wellFormedSubst((xvec, Tvec)#\\<sigma>) = (length xvec = length Tvec \\<and> distinct xvec \\<and> wellFormedSubst \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellFormedSubst ((xvec, Tvec) # \\<sigma>) =\n    (length xvec = length Tvec \\<and>\n     distinct xvec \\<and> wellFormedSubst \\<sigma>)", "by(simp add: wellFormedSubst_def) auto"], ["", "lemma wellFormedAppend[simp]:\n  fixes \\<sigma>  :: \"(('d::fs_name) list \\<times> ('e::fs_name) list) list\"\n  and   \\<sigma>' :: \"(('d::fs_name) list \\<times> ('e::fs_name) list) list\"\n\n  shows \"wellFormedSubst(\\<sigma>@\\<sigma>') = (wellFormedSubst \\<sigma> \\<and> wellFormedSubst \\<sigma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellFormedSubst (\\<sigma> @ \\<sigma>') =\n    (wellFormedSubst \\<sigma> \\<and> wellFormedSubst \\<sigma>')", "by(simp add: wellFormedSubst_def)"], ["", "lemma seqSubst2[intro]:\n  fixes \\<sigma> :: \"(name list \\<times> 'b list) list\"\n  and   T :: 'a\n  and   x :: name\n\n  assumes \"x \\<sharp> \\<sigma>\"\n  and     \"x \\<sharp> T\"\n\n  shows \"x \\<sharp> T[<\\<sigma>>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> T[<\\<sigma>>]", "using assms"], ["proof (prove)\nusing this:\n  x \\<sharp> \\<sigma>\n  x \\<sharp> T\n\ngoal (1 subgoal):\n 1. x \\<sharp> T[<\\<sigma>>]", "by(induct \\<sigma> arbitrary: T) (clarsimp |  blast)+"], ["", "lemma seqSubst2Chain[intro]:\n  fixes \\<sigma>    :: \"(name list \\<times> 'b list) list\"\n  and   T    :: 'a\n  and   xvec :: \"name list\"\n\n  assumes \"xvec \\<sharp>* \\<sigma>\"\n  and     \"xvec \\<sharp>* T\"\n\n  shows \"xvec \\<sharp>* T[<\\<sigma>>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xvec \\<sharp>* T[<\\<sigma>>]", "using assms"], ["proof (prove)\nusing this:\n  xvec \\<sharp>* \\<sigma>\n  xvec \\<sharp>* T\n\ngoal (1 subgoal):\n 1. xvec \\<sharp>* T[<\\<sigma>>]", "by(induct xvec) auto"], ["", "end"], ["", "end"]]}