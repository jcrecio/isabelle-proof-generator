{"file_name": "/home/qj213/afp-2021-10-22/thys/Psi_Calculi/Chain.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Psi_Calculi", "problem_names": ["lemma pt_set_nil: \n  fixes Xs :: \"'a set\"\n  assumes pt: \"pt TYPE('a) TYPE ('x)\"\n  and     at: \"at TYPE('x)\"\n\n  shows \"([]::'x prm)\\<bullet>Xs = Xs\"", "lemma pt_set_append: \n  fixes pi1 :: \"'x prm\"\n  and   pi2 :: \"'x prm\"\n  and   Xs  :: \"'a set\"\n  assumes pt: \"pt TYPE('a) TYPE ('x)\"\n  and     at: \"at TYPE('x)\"\n\n  shows \"(pi1@pi2)\\<bullet>Xs = pi1\\<bullet>(pi2\\<bullet>Xs)\"", "lemma pt_set_prm_eq: \n  fixes pi1 :: \"'x prm\"\n  and   pi2 :: \"'x prm\"\n  and   Xs  :: \"'a set\"\n  assumes pt: \"pt TYPE('a) TYPE ('x)\"\n  and     at: \"at TYPE('x)\"\n\n  shows \"pi1 \\<triangleq> pi2  \\<Longrightarrow> pi1\\<bullet>Xs = pi2\\<bullet>Xs\"", "lemma pt_set_inst:\n  assumes pt: \"pt TYPE('a) TYPE ('x)\"\n  and     at: \"at TYPE('x)\"\n\n  shows \"pt TYPE('a set) TYPE('x)\"", "lemma pt_ball_eqvt:\n  fixes pi :: \"'a prm\"\n  and   Xs :: \"'b set\"\n  and   P :: \"'b \\<Rightarrow> bool\"\n\n  assumes pt: \"pt TYPE('b) TYPE('a)\"\n  and     at: \"at TYPE('a)\"\n\n  shows \"(pi \\<bullet> (\\<forall>x \\<in> Xs. P x)) = (\\<forall>x \\<in> (pi \\<bullet> Xs). pi \\<bullet> P (rev pi \\<bullet> x))\"", "lemma perm_cart_prod:\n  fixes Xs :: \"'b set\"\n  and   Ys :: \"'c set\"\n  and   p  :: \"'a prm\"\n\n  assumes pt1: \"pt TYPE('b) TYPE('a)\"\n  and     pt2: \"pt TYPE('c) TYPE('a)\"\n  and     at:  \"at TYPE('a)\"\n\n  shows \"(p \\<bullet> (Xs \\<times> Ys)) = (((p \\<bullet> Xs) \\<times> (p \\<bullet> Ys))::(('b \\<times> 'c) set))\"", "lemma supp_member:\n  fixes Xs :: \"'b set\"\n  and   x  :: 'a\n\n  assumes pt: \"pt TYPE('b) TYPE('a)\"\n  and     at: \"at TYPE('a)\"\n  and     fs: \"fs TYPE('b) TYPE('a)\"\n  and     \"finite Xs\"\n  and     \"x \\<in> ((supp Xs)::'a set)\"\n\n  obtains X where \"(X::'b) \\<in> Xs\" and \"x \\<in> supp X\"", "lemma supp_cart_prod_empty[simp]:\n  fixes Xs :: \"'b set\"\n\n  shows \"supp (Xs \\<times> {}) = ({}::'a set)\"\n  and   \"supp ({} \\<times> Xs) = ({}::'a set)\"", "lemma supp_cart_prod:\n  fixes Xs :: \"'b set\"\n  and   Ys :: \"'c set\"\n\n  assumes pt1: \"pt TYPE('b) TYPE('a)\"\n  and     pt2: \"pt TYPE('c) TYPE('a)\"\n  and     fs1: \"fs TYPE('b) TYPE('a)\"\n  and     fs2: \"fs TYPE('c) TYPE('a)\"\n  and     at:  \"at TYPE('a)\"\n  and     f1:  \"finite Xs\"\n  and     f2:  \"finite Ys\"\n  and     a:   \"Xs \\<noteq> {}\"\n  and     b:   \"Ys \\<noteq> {}\"\n\n  shows \"((supp (Xs \\<times> Ys))::'a set) = ((supp Xs) \\<union> (supp Ys))\"", "lemma fresh_cart_prod:\n  fixes x  :: 'a\n  and   Xs :: \"'b set\"\n  and   Ys :: \"'c set\"\n\n  assumes pt1: \"pt TYPE('b) TYPE('a)\"\n  and     pt2: \"pt TYPE('c) TYPE('a)\"\n  and     fs1: \"fs TYPE('b) TYPE('a)\"\n  and     fs2: \"fs TYPE('c) TYPE('a)\"\n  and     at:  \"at TYPE('a)\"\n  and     f1:  \"finite Xs\"\n  and     f2:  \"finite Ys\"\n  and     a:   \"Xs \\<noteq> {}\"\n  and     b:   \"Ys \\<noteq> {}\"\n\n  shows \"(x \\<sharp> (Xs \\<times> Ys)) = (x \\<sharp> Xs \\<and> x \\<sharp> Ys)\"", "lemma fresh_star_cart_prod:\n  fixes Zs   :: \"'a set\"\n  and   xvec :: \"'a list\"\n  and   Xs   :: \"'b set\"\n  and   Ys   :: \"'c set\"\n\n  assumes pt1: \"pt TYPE('b) TYPE('a)\"\n  and     pt2: \"pt TYPE('c) TYPE('a)\"\n  and     fs1: \"fs TYPE('b) TYPE('a)\"\n  and     fs2: \"fs TYPE('c) TYPE('a)\"\n  and     at:  \"at TYPE('a)\"\n  and     f1:  \"finite Xs\"\n  and     f2:  \"finite Ys\"\n  and     a:   \"Xs \\<noteq> {}\"\n  and     b:   \"Ys \\<noteq> {}\"\n\n  shows \"(Zs \\<sharp>* (Xs \\<times> Ys)) = (Zs \\<sharp>* Xs \\<and> Zs \\<sharp>* Ys)\"\n  and   \"(xvec \\<sharp>* (Xs \\<times> Ys)) = (xvec \\<sharp>* Xs \\<and> xvec \\<sharp>* Ys)\"", "lemma permCommute:\n  fixes p  :: \"'a prm\"\n  and   q  :: \"'a prm\"\n  and   P  :: 'x\n  and   Xs :: \"'a set\"\n  and   Ys :: \"'a set\"\n\n  assumes pt: \"pt TYPE('x) TYPE('a)\"\n  and     at: \"at TYPE('a)\"\n  and     a: \"(set p) \\<subseteq> Xs \\<times> Ys\"\n  and     b: \"Xs \\<sharp>* q\"\n  and     c: \"Ys \\<sharp>* q\"\n\n  shows \"p \\<bullet> q \\<bullet> P = q \\<bullet> p \\<bullet> P\"", "lemma at_set_avoiding_aux':\n  fixes Xs::\"'a set\"\n  and   As::\"'a set\"\n  assumes at: \"at TYPE('a)\"\n  and     a: \"finite Xs\"\n  and     b: \"Xs \\<subseteq> As\"\n  and     c: \"finite As\"\n  and     d: \"finite ((supp c)::'a set)\"\n  shows \"\\<exists>(Ys::'a set) (pi::'a prm). Ys\\<sharp>*c \\<and> Ys \\<inter> As = {} \\<and> (pi\\<bullet>Xs=Ys) \\<and> \n          set pi \\<subseteq> Xs \\<times> Ys \\<and> finite Ys \\<and> (distinctPerm pi)\"", "lemma at_set_avoiding:\n  fixes Xs::\"'a set\"\n  assumes at: \"at TYPE('a)\"\n  and     a: \"finite Xs\"\n  and     b: \"finite ((supp c)::'a set)\"\n  obtains pi::\"'a prm\" where \"(pi \\<bullet> Xs) \\<sharp>* c\" and \"set pi \\<subseteq> Xs \\<times> (pi \\<bullet> Xs)\" and \"distinctPerm pi\"", "lemma pt_swap:\n  fixes x :: 'a\n  and a :: 'x\n  and b :: 'x\n\n  assumes pt: \"pt TYPE('a) TYPE('x)\"\n  and     at: \"at TYPE('x)\"\n\n  shows \"[(a, b)] \\<bullet> x = [(b, a)] \\<bullet> x\"", "lemma supp_subset:\n  fixes Xs :: \"'a::fs_name set\"\n  and   Ys :: \"'a::fs_name set\"\n\n  assumes \"Xs \\<subseteq> Ys\"\n  and     \"finite Xs\"\n  and     \"finite Ys\"\n\n  shows \"(supp Xs) \\<subseteq> ((supp Ys)::name set)\"", "lemma memFresh:\n  fixes x :: name\n  and   p :: \"'a::fs_name\"\n  and   l :: \"('a::fs_name) list\"\n\n  assumes \"x \\<sharp> l\"\n  and     \"p mem l\"\n  \n  shows \"x \\<sharp> p\"", "lemma memFreshChain:\n  fixes xvec :: \"name list\"\n  and   p    :: \"'a::fs_name\"\n  and   l    :: \"'a::fs_name list\"\n  and   Xs   :: \"name set\"\n\n  assumes \"p mem l\"\n  \n  shows \"xvec \\<sharp>* l \\<Longrightarrow> xvec \\<sharp>* p\"\n  and   \"Xs \\<sharp>* l \\<Longrightarrow> Xs \\<sharp>* p\"", "lemma fresh_star_list_append[simp]:\n  fixes A :: \"name list\"\n  and   B :: \"name list\"\n  and   C :: \"name list\"\n\n  shows \"(A \\<sharp>* (B @ C)) = ((A \\<sharp>* B) \\<and> (A \\<sharp>* C))\"", "lemma unionSimps[simp]:\n  fixes Xs :: \"name set\"\n  and   Ys :: \"name set\"\n  and   C  :: \"'a::fs_name\"\n\n  shows \"((Xs \\<union> Ys) \\<sharp>* C) = ((Xs \\<sharp>* C) \\<and> (Ys \\<sharp>* C))\"", "lemma substFreshAux[simp]:\n  fixes C    :: \"'a::fs_name\"\n  and   xvec :: \"name list\"\n\n  shows \"xvec \\<sharp>* (supp C - set xvec)\"", "lemma fresh_star_perm_app[simp]:\n  fixes Xs :: \"name set\"\n  and   xvec :: \"name list\"\n  and   p  :: \"name prm\"\n  and   C  :: \"'d::fs_name\"\n\n  shows \"\\<lbrakk>Xs \\<sharp>* p; Xs \\<sharp>* C\\<rbrakk> \\<Longrightarrow> Xs \\<sharp>* (p \\<bullet> C)\"\n  and   \"\\<lbrakk>xvec \\<sharp>* p; xvec \\<sharp>* C\\<rbrakk> \\<Longrightarrow> xvec \\<sharp>* (p \\<bullet> C)\"", "lemma freshSets[simp]:\n  fixes x    :: name\n  and   y    :: name\n  and   xvec :: \"name list\"\n  and   X    :: \"name set\"\n  and   C    :: 'a\n\n  shows \"([]::name list) \\<sharp>* C\"\n  and   \"([]::name list) \\<sharp>* [y].C\"\n  and   \"({}::name set) \\<sharp>* C\"\n  and   \"({}::name set) \\<sharp>* [y].C\"\n  and   \"((x#xvec) \\<sharp>* C) = (x \\<sharp> C \\<and> xvec \\<sharp>* C)\"\n  and   \"((x#xvec) \\<sharp>* ([y].C)) = (x \\<sharp> ([y].C) \\<and> xvec \\<sharp>* ([y].C))\"\n  and   \"((insert x X) \\<sharp>* C) = (x \\<sharp> C \\<and> X \\<sharp>* C)\"\n  and   \"((insert x X) \\<sharp>* ([y].C)) = (x \\<sharp> ([y].C) \\<and> X \\<sharp>* ([y].C))\"", "lemma freshStarAtom[simp]: \"(xvec::name list) \\<sharp>* (x::name) = x \\<sharp> xvec\"", "lemma name_list_set_fresh[simp]:\n  fixes xvec :: \"name list\"\n  and   x    :: \"'a::fs_name\"\n\n  shows \"(set xvec) \\<sharp>* x = xvec \\<sharp>* x\"", "lemma name_list_supp:\n  fixes xvec :: \"name list\"\n\n  shows \"set xvec = supp xvec\"", "lemma abs_fresh_list_star:\n  fixes xvec :: \"name list\"\n  and   a    :: name\n  and   P    :: \"'a::fs_name\"\n\n  shows \"(xvec \\<sharp>* [a].P) = ((set xvec) - {a}) \\<sharp>* P\"", "lemma abs_fresh_set_star:\n  fixes X :: \"name set\"\n  and   a :: name\n  and   P :: \"'a::fs_name\"\n\n  shows \"(X \\<sharp>* [a].P) = (X - {a}) \\<sharp>* P\"", "lemmas abs_fresh_star = abs_fresh_list_star abs_fresh_set_star", "lemma abs_fresh_list_star'[simp]:\n  fixes xvec :: \"name list\"\n  and   a    :: name\n  and   P    :: \"'a::fs_name\"\n\n  assumes \"a \\<sharp> xvec\"\n\n  shows \"xvec \\<sharp>* [a].P = xvec \\<sharp>* P\"", "lemma freshChainSym[simp]:\n  fixes xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  \n  shows   \"xvec \\<sharp>* yvec = yvec \\<sharp>* xvec\"", "lemmas [eqvt] = perm_cart_prod[OF pt_name_inst, OF pt_name_inst, OF at_name_inst]", "lemma name_set_avoiding:\n  fixes c :: \"'a::fs_name\"\n  and   X :: \"name set\"\n  \n  assumes \"finite X\"\n  and     \"\\<And>pi::name prm. \\<lbrakk>(pi \\<bullet> X) \\<sharp>* c; distinctPerm pi; set pi \\<subseteq> X \\<times> (pi \\<bullet> X)\\<rbrakk> \\<Longrightarrow> thesis\"\n\n  shows thesis", "lemmas simps[simp] = fresh_atm fresh_prod\n                     pt3[OF pt_name_inst, OF at_ds1, OF at_name_inst]\n                     pt_fresh_fresh[OF pt_name_inst, OF at_name_inst]\n                     pt_rev_pi[OF pt_name_inst, OF at_name_inst]\n                     pt_pi_rev[OF pt_name_inst, OF at_name_inst]", "lemmas name_supp_cart_prod = supp_cart_prod[OF pt_name_inst, OF pt_name_inst, OF fs_name_inst, OF fs_name_inst, OF at_name_inst]", "lemmas name_fresh_cart_prod = fresh_cart_prod[OF pt_name_inst, OF pt_name_inst, OF fs_name_inst, OF fs_name_inst, OF at_name_inst]", "lemmas name_fresh_star_cart_prod = fresh_star_cart_prod[OF pt_name_inst, OF pt_name_inst, OF fs_name_inst, OF fs_name_inst, OF at_name_inst]", "lemmas name_swap_bij[simp] = pt_swap_bij[OF pt_name_inst, OF at_name_inst]", "lemmas name_swap = pt_swap[OF pt_name_inst, OF at_name_inst]", "lemmas name_set_fresh_fresh[simp] = pt_freshs_freshs[OF pt_name_inst, OF at_name_inst]", "lemmas list_fresh[simp] = fresh_list_nil fresh_list_cons fresh_list_append", "lemma eqvtUnion[intro]:\n  fixes Rel  :: \"('d::fs_name) set\"\n  and   Rel' :: \"'d set\"\n\n  assumes EqvtRel:  \"eqvt Rel\"\n  and     EqvtRel': \"eqvt Rel'\"\n\n  shows \"eqvt (Rel \\<union> Rel')\"", "lemma eqvtPerm[simp]: \n  fixes X :: \"('d::fs_name) set\"\n  and   x :: name\n  and   y :: name\n\n  assumes \"eqvt X\"\n\n  shows \"([(x, y)] \\<bullet> X) = X\"", "lemma eqvtI:\n  fixes X :: \"'d::fs_name set\"\n  and   x :: 'd\n  and   p :: \"name prm\"\n  \n  assumes \"eqvt X\"\n  and     \"x \\<in> X\"\n \n  shows \"(p \\<bullet> x) \\<in> X\"", "lemma fresh_star_list_nil[simp]:\n  fixes xvec :: \"name list\"\n  and   Xs   :: \"name set\"\n  \n  shows \"xvec \\<sharp>* []\"\n  and   \"Xs \\<sharp>* []\"", "lemma fresh_star_list_cons[simp]:\n  fixes xvec :: \"name list\"\n  and   Xs   :: \"name set\"\n  and   x    :: \"'a::fs_name\"\n  and   xs   :: \"'a list\"\n\n  shows \"(xvec \\<sharp>* (x#xs)) = ((xvec \\<sharp>* x) \\<and> xvec \\<sharp>* xs)\"\n  and   \"(Xs \\<sharp>* (x#xs)) = ((Xs \\<sharp>* x) \\<and> (Xs \\<sharp>* xs))\"", "lemma freshStarPair[simp]:\n  fixes X    :: \"name set\"\n  and   xvec :: \"name list\"\n  and   x    :: \"'a::fs_name\"\n  and   y    :: \"'b::fs_name\"\n\n  shows \"(X \\<sharp>* (x, y)) = (X \\<sharp>* x \\<and> X \\<sharp>* y)\"\n  and   \"(xvec \\<sharp>* (x, y)) = (xvec \\<sharp>* x \\<and> xvec \\<sharp>* y)\"", "lemma name_list_avoiding:\n  fixes c    :: \"'a::fs_name\"\n  and   xvec :: \"name list\"\n  \n  assumes \"\\<And>pi::name prm. \\<lbrakk>(pi \\<bullet> xvec) \\<sharp>* c; distinctPerm pi; set pi \\<subseteq> (set xvec) \\<times> (set (pi \\<bullet> xvec))\\<rbrakk> \\<Longrightarrow> thesis\"\n\n  shows thesis", "lemma distinctPermSimps[simp]:\n  fixes p :: \"name prm\"\n  and   a :: name\n  and   b :: name\n\n  shows \"distinctPerm([]::name prm)\"\n  and   \"(distinctPerm((a, b)#p)) = (distinctPerm p \\<and> a \\<noteq> b \\<and> a \\<sharp> p \\<and> b \\<sharp> p)\"", "lemma map_eqvt[eqvt]:\n  fixes p   :: \"name prm\"\n  and   lst :: \"'a::pt_name list\"\n\n  shows \"(p \\<bullet> (map f lst)) = map (p \\<bullet> f) (p \\<bullet> lst)\"", "lemma consPerm:\n  fixes x :: name\n  and   y :: name\n  and   p :: \"name prm\"\n  and   C :: \"'a::pt_name\"\n\n  shows \"((x, y)#p) \\<bullet> C = [(x, y)] \\<bullet> p \\<bullet> C\"", "lemma distinctEqvt[eqvt]:\n  fixes p  :: \"name prm\"\n  and   xs :: \"'a::pt_name list\"\n\n  shows \"(p \\<bullet> (distinct xs)) = distinct (p \\<bullet> xs)\"", "lemma distinctClosed[simp]:\n  fixes p  :: \"name prm\"\n  and   xs :: \"'a::pt_name list\"\n\n  shows \"distinct (p \\<bullet> xs) = distinct xs\"", "lemma lengthEqvt[eqvt]:\n  fixes p  :: \"name prm\"\n  and   xs :: \"'a::pt_name list\"\n  \n  shows \"p \\<bullet> (length xs) = length (p \\<bullet> xs)\"", "lemma lengthClosed[simp]:\n  fixes p  :: \"name prm\"\n  and   xs :: \"'a::pt_name list\"\n  \n  shows \"length (p \\<bullet> xs) = length xs\"", "lemma subsetEqvt[eqvt]:\n  fixes p :: \"name prm\"\n  and   S :: \"('a::pt_name) set\"\n  and   T :: \"('a::pt_name) set\"\n\n  shows \"(p \\<bullet> (S \\<subseteq> T)) = ((p \\<bullet> S) \\<subseteq> (p \\<bullet> T))\"", "lemma subsetClosed[simp]:\n  fixes p :: \"name prm\"\n  and   S :: \"('a::pt_name) set\"\n  and   T :: \"('a::pt_name) set\"\n\n  shows \"((p \\<bullet> S) \\<subseteq> (p \\<bullet> T)) = (S \\<subseteq> T)\"", "lemma subsetClosed'[simp]:\n  fixes p    :: \"name prm\"\n  and   xvec :: \"name list\"\n  and   P    :: \"'a::fs_name\"\n\n  shows \"(set (p \\<bullet> xvec) \\<subseteq> supp (p \\<bullet> P)) = (set xvec \\<subseteq> supp P)\"", "lemma memEqvt[eqvt]:\n  fixes p  :: \"name prm\"\n  and   x  :: \"'a::pt_name\"\n  and   xs :: \"('a::pt_name) list\"\n\n  shows \"(p \\<bullet> (x mem xs)) = ((p \\<bullet> x) mem (p \\<bullet> xs))\"", "lemma memClosed[simp]:\n  fixes p  :: \"name prm\"\n  and   x  :: \"'a::pt_name\"\n  and   xs :: \"('a::pt_name) list\"\n\n  shows \"(p \\<bullet> x) mem (p \\<bullet> xs) = (x mem xs)\"", "lemma memClosed'[simp]:\n  fixes p  :: \"name prm\"\n  and   x  :: \"'a::pt_name\"\n  and   y  :: \"'b::pt_name\"\n  and   xs :: \"('a \\<times>  'b) list\" \n\n  shows \"((p \\<bullet> x, p \\<bullet> y) mem (p \\<bullet> xs)) = ((x, y) mem xs)\"", "lemma freshPerm:\n  fixes x :: name\n  and   p :: \"name prm\"\n\n  assumes \"x \\<sharp> p\"\n\n  shows \"p \\<bullet> x = x\"", "lemma freshChainPermSimp:\n  fixes xvec :: \"name list\"\n  and   p    :: \"name prm\"\n\n  assumes \"xvec \\<sharp>* p\"\n\n  shows \"p \\<bullet> xvec = xvec\"\n  and   \"rev p \\<bullet> xvec = xvec\"", "lemma freshChainAppend[simp]:\n  fixes xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   C    :: \"'a::fs_name\"\n  \n  shows \"(xvec@yvec) \\<sharp>* C = ((xvec \\<sharp>* C) \\<and> (yvec \\<sharp>* C))\"", "lemma subsetFresh:\n  fixes xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   C    :: \"'d::fs_name\"\n\n  assumes \"set xvec \\<subseteq> set yvec\"\n  and     \"yvec \\<sharp>* C\"\n\n  shows \"xvec \\<sharp>* C\"", "lemma distinctPermCancel[simp]:\n  fixes p :: \"name prm\"\n  and   T :: \"'a::pt_name\"\n\n  assumes \"distinctPerm p\"\n\n  shows \"(p \\<bullet> (p \\<bullet> T)) = T\"", "lemma composePermInduct[consumes 1, case_names cBase cStep]:\n  fixes xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   P    :: \"name list \\<Rightarrow> name list \\<Rightarrow> bool\"\n\n  assumes L: \"length xvec = length yvec\"\n  and     rBase: \"P [] []\"\n  and     rStep: \"\\<And>x xvec y yvec. \\<lbrakk>length xvec = length yvec; P xvec yvec\\<rbrakk> \\<Longrightarrow> P (x # xvec) (y # yvec)\"\n\n  shows \"P xvec yvec\"", "lemma composePermEqvt[eqvt]:\n  fixes p    :: \"name prm\"\n  and   xvec :: \"name list\"\n  and   yvec :: \"name list\"\n\n  shows \"(p \\<bullet> (composePerm xvec yvec)) = composePerm (p \\<bullet> xvec) (p \\<bullet> yvec)\"", "lemma permChainSimps[simp]:\n  fixes xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   perm :: \"name prm\"\n  and   p    :: \"'a::pt_name\"\n\n  shows \"((composePerm xvec yvec) @ perm) \\<bullet> p = [xvec yvec] \\<bullet>\\<^sub>v (perm \\<bullet> p)\"", "lemma permChainEqvt[eqvt]:\n  fixes p    :: \"name prm\"\n  and   xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   x    :: \"'a::pt_name\"\n\n  shows \"(p \\<bullet> ([xvec yvec] \\<bullet>\\<^sub>v x)) = [(p \\<bullet> xvec) (p \\<bullet> yvec)] \\<bullet>\\<^sub>v (p \\<bullet> x)\"\n  and   \"(p \\<bullet> ([xvec yvec]\\<^sup>- \\<bullet>\\<^sub>v x)) = [(p \\<bullet> xvec) (p \\<bullet> yvec)]\\<^sup>- \\<bullet>\\<^sub>v (p \\<bullet> x)\"", "lemma permChainBij:\n  fixes xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   p    :: \"'a::pt_name\"\n  and   q    :: \"'a::pt_name\"\n\n  assumes \"length xvec = length yvec\"\n\n  shows \"(([xvec yvec] \\<bullet>\\<^sub>v p) = ([xvec yvec] \\<bullet>\\<^sub>v q)) = (p = q)\"\n  and   \"(([xvec yvec]\\<^sup>- \\<bullet>\\<^sub>v p) = ([xvec yvec]\\<^sup>- \\<bullet>\\<^sub>v q)) = (p = q)\"", "lemma permChainAppend:\n  fixes xvec1 :: \"name list\"\n  and   yvec1 :: \"name list\"\n  and   xvec2 :: \"name list\"\n  and   yvec2 :: \"name list\"\n  and   p     :: \"'a::pt_name\"\n  \n  assumes \"length xvec1 = length yvec1\"\n\n  shows \"([(xvec1@xvec2) (yvec1@yvec2)] \\<bullet>\\<^sub>v p) = [xvec1 yvec1] \\<bullet>\\<^sub>v [xvec2 yvec2] \\<bullet>\\<^sub>v p\"\n  and   \"([(xvec1@xvec2) (yvec1@yvec2)]\\<^sup>- \\<bullet>\\<^sub>v p) = [xvec2 yvec2]\\<^sup>- \\<bullet>\\<^sub>v [xvec1 yvec1]\\<^sup>- \\<bullet>\\<^sub>v p\"", "lemma calcChainAtom:\n  fixes xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   x    :: name\n\n  assumes \"length xvec = length yvec\"\n  and     \"x \\<sharp> xvec\"\n  and     \"x \\<sharp> yvec\"\n\n  shows \"[xvec yvec] \\<bullet>\\<^sub>v x = x\"", "lemma calcChainAtomRev:\n  fixes xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   x    :: name\n\n  assumes \"length xvec = length yvec\"\n  and     \"x \\<sharp> xvec\"\n  and     \"x \\<sharp> yvec\"\n\n  shows \"[xvec yvec]\\<^sup>- \\<bullet>\\<^sub>v x = x\"", "lemma permChainFresh[simp]:\n  fixes x    :: name\n  and   xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   p    :: \"'a::pt_name\"\n\n  assumes \"x \\<sharp> xvec\"\n  and     \"x \\<sharp> yvec\"\n  and     \"length xvec = length yvec\"\n\n  shows \"x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v p = x \\<sharp> p\"\n  and   \"x \\<sharp> [xvec yvec]\\<^sup>- \\<bullet>\\<^sub>v p = x \\<sharp> p\"", "lemma chainFreshFresh:\n  fixes x    :: name\n  and   y    :: name\n  and   xvec :: \"name list\"\n  and   p    :: \"'a::pt_name\"\n\n  assumes \"x \\<sharp> xvec\"\n  and     \"y \\<sharp> xvec\"\n\n  shows \"xvec \\<sharp>* ([(x, y)] \\<bullet> p) = (xvec \\<sharp>* p)\"", "lemma permChainFreshFresh:\n  fixes xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   p    :: \"'a::pt_name\"\n\n  assumes \"xvec \\<sharp>* p\"\n  and     \"yvec \\<sharp>* p\"\n  and     \"length xvec = length yvec\"\n\n  shows \"[xvec yvec] \\<bullet>\\<^sub>v p = p\"\n  and   \"[xvec yvec]\\<^sup>- \\<bullet>\\<^sub>v p = p\"", "lemma setFresh[simp]:\n  fixes x    :: name\n  and   xvec :: \"name list\"\n\n  shows \"x \\<notin> set xvec = x \\<sharp> xvec\"", "lemma calcChain:\n  fixes xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  \n  assumes \"yvec \\<sharp>* xvec\"\n  and     \"length xvec = length yvec\"\n  and     \"distinct xvec\"\n  and     \"distinct yvec\"\n\n  shows \"[xvec yvec] \\<bullet>\\<^sub>v xvec = yvec\"", "lemma freshChainPerm:\n  fixes xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   x    :: name\n  and   C    :: \"'a::pt_name\"\n\n  assumes \"length xvec = length yvec\"\n  and     \"yvec \\<sharp>* C\"\n  and     \"xvec \\<sharp>* yvec\"\n  and     \"x mem xvec\"\n  and     \"distinct yvec\"\n\n  shows \"x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v C\"", "lemma memFreshSimp[simp]:\n  fixes y    :: name\n  and   yvec :: \"name list\"\n\n  shows \"(\\<not>(y mem yvec)) = y \\<sharp> yvec\"", "lemma freshChainPerm':\n  fixes xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   p    :: \"'a::pt_name\"\n\n  assumes \"length xvec = length yvec\"\n  and     \"yvec \\<sharp>* p\"\n  and     \"xvec \\<sharp>* yvec\"\n  and     \"distinct yvec\"\n\n  shows \"xvec \\<sharp>* ([xvec yvec] \\<bullet>\\<^sub>v p)\"", "lemma permSym:\n  fixes x    :: name\n  and   y    :: name\n  and   xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   p    :: \"'a::pt_name\"\n  \n  assumes \"x \\<sharp> xvec\"\n  and     \"x \\<sharp> yvec\"\n  and     \"y \\<sharp> xvec\"\n  and     \"y \\<sharp> yvec\"\n  and     \"length xvec = length yvec\"\n\n  shows \"([(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p) = [xvec yvec] \\<bullet>\\<^sub>v [(x, y)] \\<bullet> p\"", "lemma distinctPermClosed[simp]:\n  fixes p :: \"name prm\"\n  and   q :: \"name prm\"\n\n  assumes \"distinctPerm p\"\n\n  shows \"distinctPerm(q \\<bullet> p)\"", "lemma freshStarSimps:\n  fixes x  :: name\n  and   Xs :: \"name set\"\n  and   Ys :: \"name set\"\n  and   C  :: \"'a::fs_name\"\n  and   p  :: \"name prm\"\n  \n  assumes \"set p \\<subseteq> Xs \\<times> Ys\"\n  and     \"Xs \\<sharp>* x\"\n  and     \"Ys \\<sharp>* x\"\n\n  shows \"x \\<sharp> (p \\<bullet> C) = x \\<sharp> C\"", "lemma freshStarChainSimps:\n  fixes xvec :: \"name list\"\n  and   Xs   :: \"name set\"\n  and   Ys   :: \"name set\"\n  and   C    :: \"'a::fs_name\"\n  and   p    :: \"name prm\"\n\n  assumes \"set p \\<subseteq> Xs \\<times> Ys\"\n  and     \"Xs \\<sharp>* xvec\"\n  and     \"Ys \\<sharp>* xvec\"\n\n  shows   \"xvec \\<sharp>* (p \\<bullet> C) = xvec \\<sharp>* C\"", "lemma permStarFresh:\n  fixes xvec :: \"name list\"\n  and   p    :: \"name prm\"\n  and   T    :: \"'a::pt_name\"\n\n  assumes \"xvec \\<sharp>* p\"\n\n  shows \"xvec \\<sharp>* (p \\<bullet> T) = xvec \\<sharp>* T\"", "lemma swapStarFresh:\n  fixes x :: name\n  and   p :: \"name prm\"\n  and   T :: \"'a::pt_name\"\n\n  assumes \"x \\<sharp> p\"\n\n  shows \"x \\<sharp> (p \\<bullet> T) = x \\<sharp> T\"", "lemmas freshChainSimps = freshStarSimps freshStarChainSimps permStarFresh swapStarFresh chainFreshFresh freshPerm subsetFresh", "lemma freshAlphaPerm:\n  fixes xvec :: \"name list\"\n  and   Xs   :: \"name set\"\n  and   Ys   :: \"name set\"\n  and   p    :: \"name prm\"\n\n  assumes S: \"set p \\<subseteq> Xs \\<times> Ys\"\n  and     \"Xs \\<sharp>* xvec\"\n  and     \"Ys \\<sharp>* xvec\"\n\n  shows \"xvec \\<sharp>* p\"", "lemma freshAlphaSwap:\n  fixes x  :: name\n  and   Xs :: \"name set\"\n  and   Ys :: \"name set\"\n  and   p  :: \"name prm\"\n\n  assumes S: \"set p \\<subseteq> Xs \\<times> Ys\"\n  and     \"Xs \\<sharp>* x\"\n  and     \"Ys \\<sharp>* x\"\n\n  shows \"x \\<sharp> p\"", "lemma setToListFresh[simp]:\n  fixes xvec :: \"name list\"\n  and   C    :: \"'a::fs_name\"\n  and   yvec :: \"name list\"\n  and   Xs   :: \"name set\"\n  and   x    :: name\n\n  shows \"xvec \\<sharp>* (set yvec) = xvec \\<sharp>* yvec\"\n  and   \"Xs \\<sharp>* (set yvec) = Xs \\<sharp>* yvec\"\n  and   \"x \\<sharp> (set yvec) = x \\<sharp> yvec\"\n  and   \"set xvec \\<sharp>* Xs = xvec \\<sharp>* Xs\""], "translations": [["", "lemma pt_set_nil: \n  fixes Xs :: \"'a set\"\n  assumes pt: \"pt TYPE('a) TYPE ('x)\"\n  and     at: \"at TYPE('x)\"\n\n  shows \"([]::'x prm)\\<bullet>Xs = Xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<bullet> Xs = Xs", "by(auto simp add: perm_set_def pt1[OF pt])"], ["", "lemma pt_set_append: \n  fixes pi1 :: \"'x prm\"\n  and   pi2 :: \"'x prm\"\n  and   Xs  :: \"'a set\"\n  assumes pt: \"pt TYPE('a) TYPE ('x)\"\n  and     at: \"at TYPE('x)\"\n\n  shows \"(pi1@pi2)\\<bullet>Xs = pi1\\<bullet>(pi2\\<bullet>Xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pi1 @ pi2) \\<bullet> Xs = pi1 \\<bullet> pi2 \\<bullet> Xs", "by(auto simp add: perm_set_def pt2[OF pt])"], ["", "lemma pt_set_prm_eq: \n  fixes pi1 :: \"'x prm\"\n  and   pi2 :: \"'x prm\"\n  and   Xs  :: \"'a set\"\n  assumes pt: \"pt TYPE('a) TYPE ('x)\"\n  and     at: \"at TYPE('x)\"\n\n  shows \"pi1 \\<triangleq> pi2  \\<Longrightarrow> pi1\\<bullet>Xs = pi2\\<bullet>Xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1.  pi1 \\<triangleq> pi2  \\<Longrightarrow>\n    pi1 \\<bullet> Xs = pi2 \\<bullet> Xs", "by(auto simp add: perm_set_def pt3[OF pt])"], ["", "lemma pt_set_inst:\n  assumes pt: \"pt TYPE('a) TYPE ('x)\"\n  and     at: \"at TYPE('x)\"\n\n  shows \"pt TYPE('a set) TYPE('x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pt TYPE('a set) TYPE('x)", "apply(simp add: pt_def pt_set_nil[OF pt, OF at] pt_set_append[OF pt, OF at])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>pi1 pi2.\n        pi1 \\<triangleq> pi2  \\<longrightarrow>\n       (\\<forall>x. pi1 \\<bullet> x = pi2 \\<bullet> x)", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>pi1 pi2 x.\n        pi1 \\<triangleq> pi2  \\<Longrightarrow>\n       pi1 \\<bullet> x = pi2 \\<bullet> x", "by(rule pt_set_prm_eq[OF pt, OF at])"], ["", "lemma pt_ball_eqvt:\n  fixes pi :: \"'a prm\"\n  and   Xs :: \"'b set\"\n  and   P :: \"'b \\<Rightarrow> bool\"\n\n  assumes pt: \"pt TYPE('b) TYPE('a)\"\n  and     at: \"at TYPE('a)\"\n\n  shows \"(pi \\<bullet> (\\<forall>x \\<in> Xs. P x)) = (\\<forall>x \\<in> (pi \\<bullet> Xs). pi \\<bullet> P (rev pi \\<bullet> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pi \\<bullet> (\\<forall>x\\<in>Xs. P x) =\n    (\\<forall>x\\<in>pi \\<bullet> Xs. pi \\<bullet> P (rev pi \\<bullet> x))", "apply(auto simp add: perm_bool)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>Xs. P x; x \\<in> pi \\<bullet> Xs\\<rbrakk>\n       \\<Longrightarrow> P (rev pi \\<bullet> x)\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>pi \\<bullet> Xs. P (rev pi \\<bullet> x);\n        x \\<in> Xs\\<rbrakk>\n       \\<Longrightarrow> P x", "apply(drule_tac pi=\"rev pi\" in pt_set_bij2[OF pt, OF at])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>Xs. P x;\n        rev pi \\<bullet> x \\<in> rev pi \\<bullet> pi \\<bullet> Xs\\<rbrakk>\n       \\<Longrightarrow> P (rev pi \\<bullet> x)\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>pi \\<bullet> Xs. P (rev pi \\<bullet> x);\n        x \\<in> Xs\\<rbrakk>\n       \\<Longrightarrow> P x", "apply(simp add: pt_rev_pi[OF pt_set_inst[OF pt, OF at], OF at])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>pi \\<bullet> Xs. P (rev pi \\<bullet> x);\n        x \\<in> Xs\\<rbrakk>\n       \\<Longrightarrow> P x", "apply(drule_tac pi=\"pi\" in pt_set_bij2[OF pt, OF at])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>pi \\<bullet> Xs. P (rev pi \\<bullet> x);\n        pi \\<bullet> x \\<in> pi \\<bullet> Xs\\<rbrakk>\n       \\<Longrightarrow> P x", "apply(erule_tac x=\"pi \\<bullet> x\" in ballE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>pi \\<bullet> x \\<in> pi \\<bullet> Xs;\n        P (rev pi \\<bullet> pi \\<bullet> x)\\<rbrakk>\n       \\<Longrightarrow> P x\n 2. \\<And>x.\n       \\<lbrakk>pi \\<bullet> x \\<in> pi \\<bullet> Xs;\n        pi \\<bullet> x \\<notin> pi \\<bullet> Xs\\<rbrakk>\n       \\<Longrightarrow> P x", "apply(simp add: pt_rev_pi[OF pt, OF at])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>pi \\<bullet> x \\<in> pi \\<bullet> Xs;\n        pi \\<bullet> x \\<notin> pi \\<bullet> Xs\\<rbrakk>\n       \\<Longrightarrow> P x", "by simp"], ["", "lemma perm_cart_prod:\n  fixes Xs :: \"'b set\"\n  and   Ys :: \"'c set\"\n  and   p  :: \"'a prm\"\n\n  assumes pt1: \"pt TYPE('b) TYPE('a)\"\n  and     pt2: \"pt TYPE('c) TYPE('a)\"\n  and     at:  \"at TYPE('a)\"\n\n  shows \"(p \\<bullet> (Xs \\<times> Ys)) = (((p \\<bullet> Xs) \\<times> (p \\<bullet> Ys))::(('b \\<times> 'c) set))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> Xs \\<times> Ys = (p \\<bullet> Xs) \\<times> p \\<bullet> Ys", "by(auto simp add: perm_set_def)"], ["", "lemma supp_member:\n  fixes Xs :: \"'b set\"\n  and   x  :: 'a\n\n  assumes pt: \"pt TYPE('b) TYPE('a)\"\n  and     at: \"at TYPE('a)\"\n  and     fs: \"fs TYPE('b) TYPE('a)\"\n  and     \"finite Xs\"\n  and     \"x \\<in> ((supp Xs)::'a set)\"\n\n  obtains X where \"(X::'b) \\<in> Xs\" and \"x \\<in> supp X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<in> Xs; x \\<in> supp X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<in> Xs; x \\<in> supp X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<open>finite Xs\\<close> \\<open>x \\<in> supp Xs\\<close>"], ["proof (chain)\npicking this:\n  finite Xs\n  x \\<in> supp Xs", "have \"\\<exists>X::'b. (X \\<in> Xs) \\<and> (x \\<in> (supp X))\""], ["proof (prove)\nusing this:\n  finite Xs\n  x \\<in> supp Xs\n\ngoal (1 subgoal):\n 1. \\<exists>X. X \\<in> Xs \\<and> x \\<in> supp X", "proof(induct rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> supp {} \\<Longrightarrow>\n    \\<exists>X. X \\<in> {} \\<and> x \\<in> supp X\n 2. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        x \\<in> supp F \\<Longrightarrow>\n        \\<exists>X. X \\<in> F \\<and> x \\<in> supp X;\n        x \\<in> supp (insert xa F)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X.\n                            X \\<in> insert xa F \\<and> x \\<in> supp X", "case empty"], ["proof (state)\nthis:\n  x \\<in> supp {}\n\ngoal (2 subgoals):\n 1. x \\<in> supp {} \\<Longrightarrow>\n    \\<exists>X. X \\<in> {} \\<and> x \\<in> supp X\n 2. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        x \\<in> supp F \\<Longrightarrow>\n        \\<exists>X. X \\<in> F \\<and> x \\<in> supp X;\n        x \\<in> supp (insert xa F)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X.\n                            X \\<in> insert xa F \\<and> x \\<in> supp X", "from \\<open>x \\<in> ((supp {})::'a set)\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> supp {}", "have False"], ["proof (prove)\nusing this:\n  x \\<in> supp {}\n\ngoal (1 subgoal):\n 1. False", "by(simp add: supp_set_empty)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. x \\<in> supp {} \\<Longrightarrow>\n    \\<exists>X. X \\<in> {} \\<and> x \\<in> supp X\n 2. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        x \\<in> supp F \\<Longrightarrow>\n        \\<exists>X. X \\<in> F \\<and> x \\<in> supp X;\n        x \\<in> supp (insert xa F)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X.\n                            X \\<in> insert xa F \\<and> x \\<in> supp X", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>X. X \\<in> {} \\<and> x \\<in> supp X", "by simp"], ["proof (state)\nthis:\n  \\<exists>X. X \\<in> {} \\<and> x \\<in> supp X\n\ngoal (1 subgoal):\n 1. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        x \\<in> supp F \\<Longrightarrow>\n        \\<exists>X. X \\<in> F \\<and> x \\<in> supp X;\n        x \\<in> supp (insert xa F)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X.\n                            X \\<in> insert xa F \\<and> x \\<in> supp X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        x \\<in> supp F \\<Longrightarrow>\n        \\<exists>X. X \\<in> F \\<and> x \\<in> supp X;\n        x \\<in> supp (insert xa F)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X.\n                            X \\<in> insert xa F \\<and> x \\<in> supp X", "case(insert y Xs)"], ["proof (state)\nthis:\n  finite Xs\n  y \\<notin> Xs\n  x \\<in> supp Xs \\<Longrightarrow>\n  \\<exists>X. X \\<in> Xs \\<and> x \\<in> supp X\n  x \\<in> supp (insert y Xs)\n\ngoal (1 subgoal):\n 1. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        x \\<in> supp F \\<Longrightarrow>\n        \\<exists>X. X \\<in> F \\<and> x \\<in> supp X;\n        x \\<in> supp (insert xa F)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X.\n                            X \\<in> insert xa F \\<and> x \\<in> supp X", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>X. X \\<in> insert y Xs \\<and> x \\<in> supp X", "proof(case_tac \"x \\<in> supp y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> supp y \\<Longrightarrow>\n    \\<exists>X. X \\<in> insert y Xs \\<and> x \\<in> supp X\n 2. x \\<notin> supp y \\<Longrightarrow>\n    \\<exists>X. X \\<in> insert y Xs \\<and> x \\<in> supp X", "assume \"x \\<in> supp y\""], ["proof (state)\nthis:\n  x \\<in> supp y\n\ngoal (2 subgoals):\n 1. x \\<in> supp y \\<Longrightarrow>\n    \\<exists>X. X \\<in> insert y Xs \\<and> x \\<in> supp X\n 2. x \\<notin> supp y \\<Longrightarrow>\n    \\<exists>X. X \\<in> insert y Xs \\<and> x \\<in> supp X", "thus ?case"], ["proof (prove)\nusing this:\n  x \\<in> supp y\n\ngoal (1 subgoal):\n 1. \\<exists>X. X \\<in> insert y Xs \\<and> x \\<in> supp X", "by force"], ["proof (state)\nthis:\n  \\<exists>X. X \\<in> insert y Xs \\<and> x \\<in> supp X\n\ngoal (1 subgoal):\n 1. x \\<notin> supp y \\<Longrightarrow>\n    \\<exists>X. X \\<in> insert y Xs \\<and> x \\<in> supp X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> supp y \\<Longrightarrow>\n    \\<exists>X. X \\<in> insert y Xs \\<and> x \\<in> supp X", "assume \"x \\<notin> supp y\""], ["proof (state)\nthis:\n  x \\<notin> supp y\n\ngoal (1 subgoal):\n 1. x \\<notin> supp y \\<Longrightarrow>\n    \\<exists>X. X \\<in> insert y Xs \\<and> x \\<in> supp X", "with \\<open>x \\<in> supp(insert y Xs)\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> supp (insert y Xs)\n  x \\<notin> supp y", "have \"x \\<in> supp Xs\""], ["proof (prove)\nusing this:\n  x \\<in> supp (insert y Xs)\n  x \\<notin> supp y\n\ngoal (1 subgoal):\n 1. x \\<in> supp Xs", "by(simp add: supp_fin_insert[OF pt, OF at, OF fs, OF \\<open>finite Xs\\<close>])"], ["proof (state)\nthis:\n  x \\<in> supp Xs\n\ngoal (1 subgoal):\n 1. x \\<notin> supp y \\<Longrightarrow>\n    \\<exists>X. X \\<in> insert y Xs \\<and> x \\<in> supp X", "with \\<open>x \\<in> supp Xs \\<Longrightarrow> \\<exists>X. X \\<in> Xs \\<and> x \\<in> supp X\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> supp Xs \\<Longrightarrow>\n  \\<exists>X. X \\<in> Xs \\<and> x \\<in> supp X\n  x \\<in> supp Xs", "show ?case"], ["proof (prove)\nusing this:\n  x \\<in> supp Xs \\<Longrightarrow>\n  \\<exists>X. X \\<in> Xs \\<and> x \\<in> supp X\n  x \\<in> supp Xs\n\ngoal (1 subgoal):\n 1. \\<exists>X. X \\<in> insert y Xs \\<and> x \\<in> supp X", "by force"], ["proof (state)\nthis:\n  \\<exists>X. X \\<in> insert y Xs \\<and> x \\<in> supp X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>X. X \\<in> insert y Xs \\<and> x \\<in> supp X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>X. X \\<in> Xs \\<and> x \\<in> supp X\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<in> Xs; x \\<in> supp X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with that"], ["proof (chain)\npicking this:\n  \\<lbrakk>?X \\<in> Xs; x \\<in> supp ?X\\<rbrakk> \\<Longrightarrow> thesis\n  \\<exists>X. X \\<in> Xs \\<and> x \\<in> supp X", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?X \\<in> Xs; x \\<in> supp ?X\\<rbrakk> \\<Longrightarrow> thesis\n  \\<exists>X. X \\<in> Xs \\<and> x \\<in> supp X\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma supp_cart_prod_empty[simp]:\n  fixes Xs :: \"'b set\"\n\n  shows \"supp (Xs \\<times> {}) = ({}::'a set)\"\n  and   \"supp ({} \\<times> Xs) = ({}::'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (Xs \\<times> {}) = {} &&& supp ({} \\<times> Xs) = {}", "by(auto simp add: supp_set_empty)"], ["", "lemma supp_cart_prod:\n  fixes Xs :: \"'b set\"\n  and   Ys :: \"'c set\"\n\n  assumes pt1: \"pt TYPE('b) TYPE('a)\"\n  and     pt2: \"pt TYPE('c) TYPE('a)\"\n  and     fs1: \"fs TYPE('b) TYPE('a)\"\n  and     fs2: \"fs TYPE('c) TYPE('a)\"\n  and     at:  \"at TYPE('a)\"\n  and     f1:  \"finite Xs\"\n  and     f2:  \"finite Ys\"\n  and     a:   \"Xs \\<noteq> {}\"\n  and     b:   \"Ys \\<noteq> {}\"\n\n  shows \"((supp (Xs \\<times> Ys))::'a set) = ((supp Xs) \\<union> (supp Ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (Xs \\<times> Ys) = supp Xs \\<union> supp Ys", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. supp (Xs \\<times> Ys) = supp Xs \\<union> supp Ys", "from f1 f2"], ["proof (chain)\npicking this:\n  finite Xs\n  finite Ys", "have f3: \"finite(Xs \\<times> Ys)\""], ["proof (prove)\nusing this:\n  finite Xs\n  finite Ys\n\ngoal (1 subgoal):\n 1. finite (Xs \\<times> Ys)", "by simp"], ["proof (state)\nthis:\n  finite (Xs \\<times> Ys)\n\ngoal (1 subgoal):\n 1. supp (Xs \\<times> Ys) = supp Xs \\<union> supp Ys", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (Xs \\<times> Ys) = supp Xs \\<union> supp Ys", "apply(simp add: supp_of_fin_sets[OF pt_prod_inst[OF pt1, OF pt2], OF at, OF fs_prod_inst[OF fs1, OF fs2], OF f3] supp_prod)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (supp ` (Xs \\<times> Ys)) = supp Xs \\<union> supp Ys", "apply(rule equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Union> (supp ` (Xs \\<times> Ys)) \\<subseteq> supp Xs \\<union> supp Ys\n 2. supp Xs \\<union> supp Ys \\<subseteq> \\<Union> (supp ` (Xs \\<times> Ys))", "using Union_included_in_supp[OF pt1, OF at, OF fs1, OF f1] Union_included_in_supp[OF pt2, OF at, OF fs2, OF f2]"], ["proof (prove)\nusing this:\n  \\<Union> (supp ` Xs) \\<subseteq> supp Xs\n  \\<Union> (supp ` Ys) \\<subseteq> supp Ys\n\ngoal (2 subgoals):\n 1. \\<Union> (supp ` (Xs \\<times> Ys)) \\<subseteq> supp Xs \\<union> supp Ys\n 2. supp Xs \\<union> supp Ys \\<subseteq> \\<Union> (supp ` (Xs \\<times> Ys))", "apply(force simp add: supp_prod)"], ["proof (prove)\ngoal (1 subgoal):\n 1. supp Xs \\<union> supp Ys \\<subseteq> \\<Union> (supp ` (Xs \\<times> Ys))", "using a b"], ["proof (prove)\nusing this:\n  Xs \\<noteq> {}\n  Ys \\<noteq> {}\n\ngoal (1 subgoal):\n 1. supp Xs \\<union> supp Ys \\<subseteq> \\<Union> (supp ` (Xs \\<times> Ys))", "apply(auto simp add: supp_prod)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       \\<lbrakk>x \\<in> Xs; xa \\<in> Ys; xb \\<in> supp Xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>Xs.\n                            \\<exists>y\\<in>Ys.\n                               xb \\<in> supp x \\<or> xb \\<in> supp y\n 2. \\<And>x xa xb.\n       \\<lbrakk>x \\<in> Xs; xa \\<in> Ys; xb \\<in> supp Ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>Xs.\n                            \\<exists>y\\<in>Ys.\n                               xb \\<in> supp x \\<or> xb \\<in> supp y", "using supp_member[OF pt1, OF at, OF fs1, OF f1]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> supp Xs;\n   \\<And>X.\n      \\<lbrakk>X \\<in> Xs; ?x \\<in> supp X\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       \\<lbrakk>x \\<in> Xs; xa \\<in> Ys; xb \\<in> supp Xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>Xs.\n                            \\<exists>y\\<in>Ys.\n                               xb \\<in> supp x \\<or> xb \\<in> supp y\n 2. \\<And>x xa xb.\n       \\<lbrakk>x \\<in> Xs; xa \\<in> Ys; xb \\<in> supp Ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>Xs.\n                            \\<exists>y\\<in>Ys.\n                               xb \\<in> supp x \\<or> xb \\<in> supp y", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>x \\<in> Xs; xa \\<in> Ys; xb \\<in> supp Ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>Xs.\n                            \\<exists>y\\<in>Ys.\n                               xb \\<in> supp x \\<or> xb \\<in> supp y", "using supp_member[OF pt2, OF at, OF fs2, OF f2]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> supp Ys;\n   \\<And>X.\n      \\<lbrakk>X \\<in> Ys; ?x \\<in> supp X\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>x \\<in> Xs; xa \\<in> Ys; xb \\<in> supp Ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>Xs.\n                            \\<exists>y\\<in>Ys.\n                               xb \\<in> supp x \\<or> xb \\<in> supp y", "by blast"], ["proof (state)\nthis:\n  supp (Xs \\<times> Ys) = supp Xs \\<union> supp Ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fresh_cart_prod:\n  fixes x  :: 'a\n  and   Xs :: \"'b set\"\n  and   Ys :: \"'c set\"\n\n  assumes pt1: \"pt TYPE('b) TYPE('a)\"\n  and     pt2: \"pt TYPE('c) TYPE('a)\"\n  and     fs1: \"fs TYPE('b) TYPE('a)\"\n  and     fs2: \"fs TYPE('c) TYPE('a)\"\n  and     at:  \"at TYPE('a)\"\n  and     f1:  \"finite Xs\"\n  and     f2:  \"finite Ys\"\n  and     a:   \"Xs \\<noteq> {}\"\n  and     b:   \"Ys \\<noteq> {}\"\n\n  shows \"(x \\<sharp> (Xs \\<times> Ys)) = (x \\<sharp> Xs \\<and> x \\<sharp> Ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> Xs \\<times> Ys = (x \\<sharp> Xs \\<and> x \\<sharp> Ys)", "using assms"], ["proof (prove)\nusing this:\n  pt TYPE('b) TYPE('a)\n  pt TYPE('c) TYPE('a)\n  fs TYPE('b) TYPE('a)\n  fs TYPE('c) TYPE('a)\n  at TYPE('a)\n  finite Xs\n  finite Ys\n  Xs \\<noteq> {}\n  Ys \\<noteq> {}\n\ngoal (1 subgoal):\n 1. x \\<sharp> Xs \\<times> Ys = (x \\<sharp> Xs \\<and> x \\<sharp> Ys)", "by(simp add: supp_cart_prod fresh_def)"], ["", "lemma fresh_star_cart_prod:\n  fixes Zs   :: \"'a set\"\n  and   xvec :: \"'a list\"\n  and   Xs   :: \"'b set\"\n  and   Ys   :: \"'c set\"\n\n  assumes pt1: \"pt TYPE('b) TYPE('a)\"\n  and     pt2: \"pt TYPE('c) TYPE('a)\"\n  and     fs1: \"fs TYPE('b) TYPE('a)\"\n  and     fs2: \"fs TYPE('c) TYPE('a)\"\n  and     at:  \"at TYPE('a)\"\n  and     f1:  \"finite Xs\"\n  and     f2:  \"finite Ys\"\n  and     a:   \"Xs \\<noteq> {}\"\n  and     b:   \"Ys \\<noteq> {}\"\n\n  shows \"(Zs \\<sharp>* (Xs \\<times> Ys)) = (Zs \\<sharp>* Xs \\<and> Zs \\<sharp>* Ys)\"\n  and   \"(xvec \\<sharp>* (Xs \\<times> Ys)) = (xvec \\<sharp>* Xs \\<and> xvec \\<sharp>* Ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Zs \\<sharp>* (Xs \\<times> Ys) =\n    (Zs \\<sharp>* Xs \\<and> Zs \\<sharp>* Ys) &&&\n    xvec \\<sharp>* (Xs \\<times> Ys) =\n    (xvec \\<sharp>* Xs \\<and> xvec \\<sharp>* Ys)", "using assms"], ["proof (prove)\nusing this:\n  pt TYPE('b) TYPE('a)\n  pt TYPE('c) TYPE('a)\n  fs TYPE('b) TYPE('a)\n  fs TYPE('c) TYPE('a)\n  at TYPE('a)\n  finite Xs\n  finite Ys\n  Xs \\<noteq> {}\n  Ys \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Zs \\<sharp>* (Xs \\<times> Ys) =\n    (Zs \\<sharp>* Xs \\<and> Zs \\<sharp>* Ys) &&&\n    xvec \\<sharp>* (Xs \\<times> Ys) =\n    (xvec \\<sharp>* Xs \\<and> xvec \\<sharp>* Ys)", "by(force simp add: fresh_cart_prod fresh_star_def)+"], ["", "lemma permCommute:\n  fixes p  :: \"'a prm\"\n  and   q  :: \"'a prm\"\n  and   P  :: 'x\n  and   Xs :: \"'a set\"\n  and   Ys :: \"'a set\"\n\n  assumes pt: \"pt TYPE('x) TYPE('a)\"\n  and     at: \"at TYPE('a)\"\n  and     a: \"(set p) \\<subseteq> Xs \\<times> Ys\"\n  and     b: \"Xs \\<sharp>* q\"\n  and     c: \"Ys \\<sharp>* q\"\n\n  shows \"p \\<bullet> q \\<bullet> P = q \\<bullet> p \\<bullet> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> q \\<bullet> P = q \\<bullet> p \\<bullet> P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<bullet> q \\<bullet> P = q \\<bullet> p \\<bullet> P", "have \"p \\<bullet> q \\<bullet> P = (p \\<bullet> q) \\<bullet> p \\<bullet> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> q \\<bullet> P = (p \\<bullet> q) \\<bullet> p \\<bullet> P", "by(rule pt_perm_compose[OF pt, OF at])"], ["proof (state)\nthis:\n  p \\<bullet> q \\<bullet> P = (p \\<bullet> q) \\<bullet> p \\<bullet> P\n\ngoal (1 subgoal):\n 1. p \\<bullet> q \\<bullet> P = q \\<bullet> p \\<bullet> P", "moreover"], ["proof (state)\nthis:\n  p \\<bullet> q \\<bullet> P = (p \\<bullet> q) \\<bullet> p \\<bullet> P\n\ngoal (1 subgoal):\n 1. p \\<bullet> q \\<bullet> P = q \\<bullet> p \\<bullet> P", "from at"], ["proof (chain)\npicking this:\n  at TYPE('a)", "have \"pt TYPE('a) TYPE('a)\""], ["proof (prove)\nusing this:\n  at TYPE('a)\n\ngoal (1 subgoal):\n 1. pt TYPE('a) TYPE('a)", "by(rule at_pt_inst)"], ["proof (state)\nthis:\n  pt TYPE('a) TYPE('a)\n\ngoal (1 subgoal):\n 1. p \\<bullet> q \\<bullet> P = q \\<bullet> p \\<bullet> P", "hence \"pt TYPE(('a \\<times> 'a) list) TYPE('a)\""], ["proof (prove)\nusing this:\n  pt TYPE('a) TYPE('a)\n\ngoal (1 subgoal):\n 1. pt TYPE(('a \\<times> 'a) list) TYPE('a)", "by(force intro: pt_prod_inst pt_list_inst)"], ["proof (state)\nthis:\n  pt TYPE(('a \\<times> 'a) list) TYPE('a)\n\ngoal (1 subgoal):\n 1. p \\<bullet> q \\<bullet> P = q \\<bullet> p \\<bullet> P", "hence \"p \\<bullet> q = q\""], ["proof (prove)\nusing this:\n  pt TYPE(('a \\<times> 'a) list) TYPE('a)\n\ngoal (1 subgoal):\n 1. p \\<bullet> q = q", "using at a b c"], ["proof (prove)\nusing this:\n  pt TYPE(('a \\<times> 'a) list) TYPE('a)\n  at TYPE('a)\n  set p \\<subseteq> Xs \\<times> Ys\n  Xs \\<sharp>* q\n  Ys \\<sharp>* q\n\ngoal (1 subgoal):\n 1. p \\<bullet> q = q", "by(rule pt_freshs_freshs)"], ["proof (state)\nthis:\n  p \\<bullet> q = q\n\ngoal (1 subgoal):\n 1. p \\<bullet> q \\<bullet> P = q \\<bullet> p \\<bullet> P", "ultimately"], ["proof (chain)\npicking this:\n  p \\<bullet> q \\<bullet> P = (p \\<bullet> q) \\<bullet> p \\<bullet> P\n  p \\<bullet> q = q", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<bullet> q \\<bullet> P = (p \\<bullet> q) \\<bullet> p \\<bullet> P\n  p \\<bullet> q = q\n\ngoal (1 subgoal):\n 1. p \\<bullet> q \\<bullet> P = q \\<bullet> p \\<bullet> P", "by simp"], ["proof (state)\nthis:\n  p \\<bullet> q \\<bullet> P = q \\<bullet> p \\<bullet> P\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  distinctPerm :: \"'a prm \\<Rightarrow> bool\" where\n  \"distinctPerm p \\<equiv> distinct((map fst p)@(map snd p))\""], ["", "lemma at_set_avoiding_aux':\n  fixes Xs::\"'a set\"\n  and   As::\"'a set\"\n  assumes at: \"at TYPE('a)\"\n  and     a: \"finite Xs\"\n  and     b: \"Xs \\<subseteq> As\"\n  and     c: \"finite As\"\n  and     d: \"finite ((supp c)::'a set)\"\n  shows \"\\<exists>(Ys::'a set) (pi::'a prm). Ys\\<sharp>*c \\<and> Ys \\<inter> As = {} \\<and> (pi\\<bullet>Xs=Ys) \\<and> \n          set pi \\<subseteq> Xs \\<times> Ys \\<and> finite Ys \\<and> (distinctPerm pi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Ys pi.\n       Ys \\<sharp>* c \\<and>\n       Ys \\<inter> As = {} \\<and>\n       pi \\<bullet> Xs = Ys \\<and>\n       set pi \\<subseteq> Xs \\<times> Ys \\<and>\n       finite Ys \\<and> distinctPerm pi", "using a b c"], ["proof (prove)\nusing this:\n  finite Xs\n  Xs \\<subseteq> As\n  finite As\n\ngoal (1 subgoal):\n 1. \\<exists>Ys pi.\n       Ys \\<sharp>* c \\<and>\n       Ys \\<inter> As = {} \\<and>\n       pi \\<bullet> Xs = Ys \\<and>\n       set pi \\<subseteq> Xs \\<times> Ys \\<and>\n       finite Ys \\<and> distinctPerm pi", "proof (induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>{} \\<subseteq> As; finite As\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ys pi.\n                         Ys \\<sharp>* c \\<and>\n                         Ys \\<inter> As = {} \\<and>\n                         pi \\<bullet> {} = Ys \\<and>\n                         set pi \\<subseteq> {} \\<times> Ys \\<and>\n                         finite Ys \\<and> distinctPerm pi\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> As; finite As\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Ys pi.\n                             Ys \\<sharp>* c \\<and>\n                             Ys \\<inter> As = {} \\<and>\n                             pi \\<bullet> F = Ys \\<and>\n                             set pi \\<subseteq> F \\<times> Ys \\<and>\n                             finite Ys \\<and> distinctPerm pi;\n        insert x F \\<subseteq> As; finite As\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ys pi.\n                            Ys \\<sharp>* c \\<and>\n                            Ys \\<inter> As = {} \\<and>\n                            pi \\<bullet> insert x F = Ys \\<and>\n                            set pi \\<subseteq> insert x F \\<times> Ys \\<and>\n                            finite Ys \\<and> distinctPerm pi", "case empty"], ["proof (state)\nthis:\n  {} \\<subseteq> As\n  finite As\n\ngoal (2 subgoals):\n 1. \\<lbrakk>{} \\<subseteq> As; finite As\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ys pi.\n                         Ys \\<sharp>* c \\<and>\n                         Ys \\<inter> As = {} \\<and>\n                         pi \\<bullet> {} = Ys \\<and>\n                         set pi \\<subseteq> {} \\<times> Ys \\<and>\n                         finite Ys \\<and> distinctPerm pi\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> As; finite As\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Ys pi.\n                             Ys \\<sharp>* c \\<and>\n                             Ys \\<inter> As = {} \\<and>\n                             pi \\<bullet> F = Ys \\<and>\n                             set pi \\<subseteq> F \\<times> Ys \\<and>\n                             finite Ys \\<and> distinctPerm pi;\n        insert x F \\<subseteq> As; finite As\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ys pi.\n                            Ys \\<sharp>* c \\<and>\n                            Ys \\<inter> As = {} \\<and>\n                            pi \\<bullet> insert x F = Ys \\<and>\n                            set pi \\<subseteq> insert x F \\<times> Ys \\<and>\n                            finite Ys \\<and> distinctPerm pi", "have \"({}::'a set)\\<sharp>*c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<sharp>* c", "by (simp add: fresh_star_def)"], ["proof (state)\nthis:\n  {} \\<sharp>* c\n\ngoal (2 subgoals):\n 1. \\<lbrakk>{} \\<subseteq> As; finite As\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ys pi.\n                         Ys \\<sharp>* c \\<and>\n                         Ys \\<inter> As = {} \\<and>\n                         pi \\<bullet> {} = Ys \\<and>\n                         set pi \\<subseteq> {} \\<times> Ys \\<and>\n                         finite Ys \\<and> distinctPerm pi\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> As; finite As\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Ys pi.\n                             Ys \\<sharp>* c \\<and>\n                             Ys \\<inter> As = {} \\<and>\n                             pi \\<bullet> F = Ys \\<and>\n                             set pi \\<subseteq> F \\<times> Ys \\<and>\n                             finite Ys \\<and> distinctPerm pi;\n        insert x F \\<subseteq> As; finite As\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ys pi.\n                            Ys \\<sharp>* c \\<and>\n                            Ys \\<inter> As = {} \\<and>\n                            pi \\<bullet> insert x F = Ys \\<and>\n                            set pi \\<subseteq> insert x F \\<times> Ys \\<and>\n                            finite Ys \\<and> distinctPerm pi", "moreover"], ["proof (state)\nthis:\n  {} \\<sharp>* c\n\ngoal (2 subgoals):\n 1. \\<lbrakk>{} \\<subseteq> As; finite As\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ys pi.\n                         Ys \\<sharp>* c \\<and>\n                         Ys \\<inter> As = {} \\<and>\n                         pi \\<bullet> {} = Ys \\<and>\n                         set pi \\<subseteq> {} \\<times> Ys \\<and>\n                         finite Ys \\<and> distinctPerm pi\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> As; finite As\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Ys pi.\n                             Ys \\<sharp>* c \\<and>\n                             Ys \\<inter> As = {} \\<and>\n                             pi \\<bullet> F = Ys \\<and>\n                             set pi \\<subseteq> F \\<times> Ys \\<and>\n                             finite Ys \\<and> distinctPerm pi;\n        insert x F \\<subseteq> As; finite As\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ys pi.\n                            Ys \\<sharp>* c \\<and>\n                            Ys \\<inter> As = {} \\<and>\n                            pi \\<bullet> insert x F = Ys \\<and>\n                            set pi \\<subseteq> insert x F \\<times> Ys \\<and>\n                            finite Ys \\<and> distinctPerm pi", "have \"({}::'a set) \\<inter> As = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<inter> As = {}", "by simp"], ["proof (state)\nthis:\n  {} \\<inter> As = {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>{} \\<subseteq> As; finite As\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ys pi.\n                         Ys \\<sharp>* c \\<and>\n                         Ys \\<inter> As = {} \\<and>\n                         pi \\<bullet> {} = Ys \\<and>\n                         set pi \\<subseteq> {} \\<times> Ys \\<and>\n                         finite Ys \\<and> distinctPerm pi\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> As; finite As\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Ys pi.\n                             Ys \\<sharp>* c \\<and>\n                             Ys \\<inter> As = {} \\<and>\n                             pi \\<bullet> F = Ys \\<and>\n                             set pi \\<subseteq> F \\<times> Ys \\<and>\n                             finite Ys \\<and> distinctPerm pi;\n        insert x F \\<subseteq> As; finite As\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ys pi.\n                            Ys \\<sharp>* c \\<and>\n                            Ys \\<inter> As = {} \\<and>\n                            pi \\<bullet> insert x F = Ys \\<and>\n                            set pi \\<subseteq> insert x F \\<times> Ys \\<and>\n                            finite Ys \\<and> distinctPerm pi", "moreover"], ["proof (state)\nthis:\n  {} \\<inter> As = {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>{} \\<subseteq> As; finite As\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ys pi.\n                         Ys \\<sharp>* c \\<and>\n                         Ys \\<inter> As = {} \\<and>\n                         pi \\<bullet> {} = Ys \\<and>\n                         set pi \\<subseteq> {} \\<times> Ys \\<and>\n                         finite Ys \\<and> distinctPerm pi\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> As; finite As\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Ys pi.\n                             Ys \\<sharp>* c \\<and>\n                             Ys \\<inter> As = {} \\<and>\n                             pi \\<bullet> F = Ys \\<and>\n                             set pi \\<subseteq> F \\<times> Ys \\<and>\n                             finite Ys \\<and> distinctPerm pi;\n        insert x F \\<subseteq> As; finite As\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ys pi.\n                            Ys \\<sharp>* c \\<and>\n                            Ys \\<inter> As = {} \\<and>\n                            pi \\<bullet> insert x F = Ys \\<and>\n                            set pi \\<subseteq> insert x F \\<times> Ys \\<and>\n                            finite Ys \\<and> distinctPerm pi", "have \"([]::'a prm)\\<bullet>{} = ({}::'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<bullet> {} = {}", "by(rule pt1) (metis Nominal.pt_set_inst at at_pt_inst)"], ["proof (state)\nthis:\n  [] \\<bullet> {} = {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>{} \\<subseteq> As; finite As\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ys pi.\n                         Ys \\<sharp>* c \\<and>\n                         Ys \\<inter> As = {} \\<and>\n                         pi \\<bullet> {} = Ys \\<and>\n                         set pi \\<subseteq> {} \\<times> Ys \\<and>\n                         finite Ys \\<and> distinctPerm pi\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> As; finite As\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Ys pi.\n                             Ys \\<sharp>* c \\<and>\n                             Ys \\<inter> As = {} \\<and>\n                             pi \\<bullet> F = Ys \\<and>\n                             set pi \\<subseteq> F \\<times> Ys \\<and>\n                             finite Ys \\<and> distinctPerm pi;\n        insert x F \\<subseteq> As; finite As\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ys pi.\n                            Ys \\<sharp>* c \\<and>\n                            Ys \\<inter> As = {} \\<and>\n                            pi \\<bullet> insert x F = Ys \\<and>\n                            set pi \\<subseteq> insert x F \\<times> Ys \\<and>\n                            finite Ys \\<and> distinctPerm pi", "moreover"], ["proof (state)\nthis:\n  [] \\<bullet> {} = {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>{} \\<subseteq> As; finite As\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ys pi.\n                         Ys \\<sharp>* c \\<and>\n                         Ys \\<inter> As = {} \\<and>\n                         pi \\<bullet> {} = Ys \\<and>\n                         set pi \\<subseteq> {} \\<times> Ys \\<and>\n                         finite Ys \\<and> distinctPerm pi\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> As; finite As\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Ys pi.\n                             Ys \\<sharp>* c \\<and>\n                             Ys \\<inter> As = {} \\<and>\n                             pi \\<bullet> F = Ys \\<and>\n                             set pi \\<subseteq> F \\<times> Ys \\<and>\n                             finite Ys \\<and> distinctPerm pi;\n        insert x F \\<subseteq> As; finite As\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ys pi.\n                            Ys \\<sharp>* c \\<and>\n                            Ys \\<inter> As = {} \\<and>\n                            pi \\<bullet> insert x F = Ys \\<and>\n                            set pi \\<subseteq> insert x F \\<times> Ys \\<and>\n                            finite Ys \\<and> distinctPerm pi", "have \"set ([]::'a prm) \\<subseteq> {} \\<times> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set [] \\<subseteq> {} \\<times> {}", "by simp"], ["proof (state)\nthis:\n  set [] \\<subseteq> {} \\<times> {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>{} \\<subseteq> As; finite As\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ys pi.\n                         Ys \\<sharp>* c \\<and>\n                         Ys \\<inter> As = {} \\<and>\n                         pi \\<bullet> {} = Ys \\<and>\n                         set pi \\<subseteq> {} \\<times> Ys \\<and>\n                         finite Ys \\<and> distinctPerm pi\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> As; finite As\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Ys pi.\n                             Ys \\<sharp>* c \\<and>\n                             Ys \\<inter> As = {} \\<and>\n                             pi \\<bullet> F = Ys \\<and>\n                             set pi \\<subseteq> F \\<times> Ys \\<and>\n                             finite Ys \\<and> distinctPerm pi;\n        insert x F \\<subseteq> As; finite As\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ys pi.\n                            Ys \\<sharp>* c \\<and>\n                            Ys \\<inter> As = {} \\<and>\n                            pi \\<bullet> insert x F = Ys \\<and>\n                            set pi \\<subseteq> insert x F \\<times> Ys \\<and>\n                            finite Ys \\<and> distinctPerm pi", "moreover"], ["proof (state)\nthis:\n  set [] \\<subseteq> {} \\<times> {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>{} \\<subseteq> As; finite As\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ys pi.\n                         Ys \\<sharp>* c \\<and>\n                         Ys \\<inter> As = {} \\<and>\n                         pi \\<bullet> {} = Ys \\<and>\n                         set pi \\<subseteq> {} \\<times> Ys \\<and>\n                         finite Ys \\<and> distinctPerm pi\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> As; finite As\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Ys pi.\n                             Ys \\<sharp>* c \\<and>\n                             Ys \\<inter> As = {} \\<and>\n                             pi \\<bullet> F = Ys \\<and>\n                             set pi \\<subseteq> F \\<times> Ys \\<and>\n                             finite Ys \\<and> distinctPerm pi;\n        insert x F \\<subseteq> As; finite As\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ys pi.\n                            Ys \\<sharp>* c \\<and>\n                            Ys \\<inter> As = {} \\<and>\n                            pi \\<bullet> insert x F = Ys \\<and>\n                            set pi \\<subseteq> insert x F \\<times> Ys \\<and>\n                            finite Ys \\<and> distinctPerm pi", "have \"finite ({}::'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {}", "by simp"], ["proof (state)\nthis:\n  finite {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>{} \\<subseteq> As; finite As\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ys pi.\n                         Ys \\<sharp>* c \\<and>\n                         Ys \\<inter> As = {} \\<and>\n                         pi \\<bullet> {} = Ys \\<and>\n                         set pi \\<subseteq> {} \\<times> Ys \\<and>\n                         finite Ys \\<and> distinctPerm pi\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> As; finite As\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Ys pi.\n                             Ys \\<sharp>* c \\<and>\n                             Ys \\<inter> As = {} \\<and>\n                             pi \\<bullet> F = Ys \\<and>\n                             set pi \\<subseteq> F \\<times> Ys \\<and>\n                             finite Ys \\<and> distinctPerm pi;\n        insert x F \\<subseteq> As; finite As\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ys pi.\n                            Ys \\<sharp>* c \\<and>\n                            Ys \\<inter> As = {} \\<and>\n                            pi \\<bullet> insert x F = Ys \\<and>\n                            set pi \\<subseteq> insert x F \\<times> Ys \\<and>\n                            finite Ys \\<and> distinctPerm pi", "moreover"], ["proof (state)\nthis:\n  finite {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>{} \\<subseteq> As; finite As\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ys pi.\n                         Ys \\<sharp>* c \\<and>\n                         Ys \\<inter> As = {} \\<and>\n                         pi \\<bullet> {} = Ys \\<and>\n                         set pi \\<subseteq> {} \\<times> Ys \\<and>\n                         finite Ys \\<and> distinctPerm pi\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> As; finite As\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Ys pi.\n                             Ys \\<sharp>* c \\<and>\n                             Ys \\<inter> As = {} \\<and>\n                             pi \\<bullet> F = Ys \\<and>\n                             set pi \\<subseteq> F \\<times> Ys \\<and>\n                             finite Ys \\<and> distinctPerm pi;\n        insert x F \\<subseteq> As; finite As\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ys pi.\n                            Ys \\<sharp>* c \\<and>\n                            Ys \\<inter> As = {} \\<and>\n                            pi \\<bullet> insert x F = Ys \\<and>\n                            set pi \\<subseteq> insert x F \\<times> Ys \\<and>\n                            finite Ys \\<and> distinctPerm pi", "have \"distinctPerm([]::'a prm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinctPerm []", "by(simp add: distinctPerm_def)"], ["proof (state)\nthis:\n  distinctPerm []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>{} \\<subseteq> As; finite As\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ys pi.\n                         Ys \\<sharp>* c \\<and>\n                         Ys \\<inter> As = {} \\<and>\n                         pi \\<bullet> {} = Ys \\<and>\n                         set pi \\<subseteq> {} \\<times> Ys \\<and>\n                         finite Ys \\<and> distinctPerm pi\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> As; finite As\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Ys pi.\n                             Ys \\<sharp>* c \\<and>\n                             Ys \\<inter> As = {} \\<and>\n                             pi \\<bullet> F = Ys \\<and>\n                             set pi \\<subseteq> F \\<times> Ys \\<and>\n                             finite Ys \\<and> distinctPerm pi;\n        insert x F \\<subseteq> As; finite As\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ys pi.\n                            Ys \\<sharp>* c \\<and>\n                            Ys \\<inter> As = {} \\<and>\n                            pi \\<bullet> insert x F = Ys \\<and>\n                            set pi \\<subseteq> insert x F \\<times> Ys \\<and>\n                            finite Ys \\<and> distinctPerm pi", "ultimately"], ["proof (chain)\npicking this:\n  {} \\<sharp>* c\n  {} \\<inter> As = {}\n  [] \\<bullet> {} = {}\n  set [] \\<subseteq> {} \\<times> {}\n  finite {}\n  distinctPerm []", "show ?case"], ["proof (prove)\nusing this:\n  {} \\<sharp>* c\n  {} \\<inter> As = {}\n  [] \\<bullet> {} = {}\n  set [] \\<subseteq> {} \\<times> {}\n  finite {}\n  distinctPerm []\n\ngoal (1 subgoal):\n 1. \\<exists>Ys pi.\n       Ys \\<sharp>* c \\<and>\n       Ys \\<inter> As = {} \\<and>\n       pi \\<bullet> {} = Ys \\<and>\n       set pi \\<subseteq> {} \\<times> Ys \\<and>\n       finite Ys \\<and> distinctPerm pi", "by blast"], ["proof (state)\nthis:\n  \\<exists>Ys pi.\n     Ys \\<sharp>* c \\<and>\n     Ys \\<inter> As = {} \\<and>\n     pi \\<bullet> {} = Ys \\<and>\n     set pi \\<subseteq> {} \\<times> Ys \\<and>\n     finite Ys \\<and> distinctPerm pi\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> As; finite As\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Ys pi.\n                             Ys \\<sharp>* c \\<and>\n                             Ys \\<inter> As = {} \\<and>\n                             pi \\<bullet> F = Ys \\<and>\n                             set pi \\<subseteq> F \\<times> Ys \\<and>\n                             finite Ys \\<and> distinctPerm pi;\n        insert x F \\<subseteq> As; finite As\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ys pi.\n                            Ys \\<sharp>* c \\<and>\n                            Ys \\<inter> As = {} \\<and>\n                            pi \\<bullet> insert x F = Ys \\<and>\n                            set pi \\<subseteq> insert x F \\<times> Ys \\<and>\n                            finite Ys \\<and> distinctPerm pi", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> As; finite As\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Ys pi.\n                             Ys \\<sharp>* c \\<and>\n                             Ys \\<inter> As = {} \\<and>\n                             pi \\<bullet> F = Ys \\<and>\n                             set pi \\<subseteq> F \\<times> Ys \\<and>\n                             finite Ys \\<and> distinctPerm pi;\n        insert x F \\<subseteq> As; finite As\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ys pi.\n                            Ys \\<sharp>* c \\<and>\n                            Ys \\<inter> As = {} \\<and>\n                            pi \\<bullet> insert x F = Ys \\<and>\n                            set pi \\<subseteq> insert x F \\<times> Ys \\<and>\n                            finite Ys \\<and> distinctPerm pi", "case (insert x Xs)"], ["proof (state)\nthis:\n  finite Xs\n  x \\<notin> Xs\n  \\<lbrakk>Xs \\<subseteq> As; finite As\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Ys pi.\n                       Ys \\<sharp>* c \\<and>\n                       Ys \\<inter> As = {} \\<and>\n                       pi \\<bullet> Xs = Ys \\<and>\n                       set pi \\<subseteq> Xs \\<times> Ys \\<and>\n                       finite Ys \\<and> distinctPerm pi\n  insert x Xs \\<subseteq> As\n  finite As\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> As; finite As\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Ys pi.\n                             Ys \\<sharp>* c \\<and>\n                             Ys \\<inter> As = {} \\<and>\n                             pi \\<bullet> F = Ys \\<and>\n                             set pi \\<subseteq> F \\<times> Ys \\<and>\n                             finite Ys \\<and> distinctPerm pi;\n        insert x F \\<subseteq> As; finite As\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ys pi.\n                            Ys \\<sharp>* c \\<and>\n                            Ys \\<inter> As = {} \\<and>\n                            pi \\<bullet> insert x F = Ys \\<and>\n                            set pi \\<subseteq> insert x F \\<times> Ys \\<and>\n                            finite Ys \\<and> distinctPerm pi", "then"], ["proof (chain)\npicking this:\n  finite Xs\n  x \\<notin> Xs\n  \\<lbrakk>Xs \\<subseteq> As; finite As\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Ys pi.\n                       Ys \\<sharp>* c \\<and>\n                       Ys \\<inter> As = {} \\<and>\n                       pi \\<bullet> Xs = Ys \\<and>\n                       set pi \\<subseteq> Xs \\<times> Ys \\<and>\n                       finite Ys \\<and> distinctPerm pi\n  insert x Xs \\<subseteq> As\n  finite As", "have ih: \"\\<exists>Ys pi. Ys\\<sharp>*c \\<and> Ys \\<inter> As = {} \\<and> pi\\<bullet>Xs = Ys \\<and> set pi \\<subseteq> Xs \\<times> Ys \\<and> finite Ys \\<and> distinctPerm pi\""], ["proof (prove)\nusing this:\n  finite Xs\n  x \\<notin> Xs\n  \\<lbrakk>Xs \\<subseteq> As; finite As\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Ys pi.\n                       Ys \\<sharp>* c \\<and>\n                       Ys \\<inter> As = {} \\<and>\n                       pi \\<bullet> Xs = Ys \\<and>\n                       set pi \\<subseteq> Xs \\<times> Ys \\<and>\n                       finite Ys \\<and> distinctPerm pi\n  insert x Xs \\<subseteq> As\n  finite As\n\ngoal (1 subgoal):\n 1. \\<exists>Ys pi.\n       Ys \\<sharp>* c \\<and>\n       Ys \\<inter> As = {} \\<and>\n       pi \\<bullet> Xs = Ys \\<and>\n       set pi \\<subseteq> Xs \\<times> Ys \\<and>\n       finite Ys \\<and> distinctPerm pi", "by simp"], ["proof (state)\nthis:\n  \\<exists>Ys pi.\n     Ys \\<sharp>* c \\<and>\n     Ys \\<inter> As = {} \\<and>\n     pi \\<bullet> Xs = Ys \\<and>\n     set pi \\<subseteq> Xs \\<times> Ys \\<and>\n     finite Ys \\<and> distinctPerm pi\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> As; finite As\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Ys pi.\n                             Ys \\<sharp>* c \\<and>\n                             Ys \\<inter> As = {} \\<and>\n                             pi \\<bullet> F = Ys \\<and>\n                             set pi \\<subseteq> F \\<times> Ys \\<and>\n                             finite Ys \\<and> distinctPerm pi;\n        insert x F \\<subseteq> As; finite As\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ys pi.\n                            Ys \\<sharp>* c \\<and>\n                            Ys \\<inter> As = {} \\<and>\n                            pi \\<bullet> insert x F = Ys \\<and>\n                            set pi \\<subseteq> insert x F \\<times> Ys \\<and>\n                            finite Ys \\<and> distinctPerm pi", "then"], ["proof (chain)\npicking this:\n  \\<exists>Ys pi.\n     Ys \\<sharp>* c \\<and>\n     Ys \\<inter> As = {} \\<and>\n     pi \\<bullet> Xs = Ys \\<and>\n     set pi \\<subseteq> Xs \\<times> Ys \\<and>\n     finite Ys \\<and> distinctPerm pi", "obtain Ys pi where a1: \"Ys\\<sharp>*c\" and a2: \"Ys \\<inter> As = {}\" and a3: \"(pi::'a prm)\\<bullet>Xs = Ys\" and \n                          a4: \"set pi \\<subseteq> Xs \\<times> Ys\" and a5: \"finite Ys\" \n                      and a6: \"distinctPerm pi\""], ["proof (prove)\nusing this:\n  \\<exists>Ys pi.\n     Ys \\<sharp>* c \\<and>\n     Ys \\<inter> As = {} \\<and>\n     pi \\<bullet> Xs = Ys \\<and>\n     set pi \\<subseteq> Xs \\<times> Ys \\<and>\n     finite Ys \\<and> distinctPerm pi\n\ngoal (1 subgoal):\n 1. (\\<And>Ys pi.\n        \\<lbrakk>Ys \\<sharp>* c; Ys \\<inter> As = {}; pi \\<bullet> Xs = Ys;\n         set pi \\<subseteq> Xs \\<times> Ys; finite Ys;\n         distinctPerm pi\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Ys \\<sharp>* c\n  Ys \\<inter> As = {}\n  pi \\<bullet> Xs = Ys\n  set pi \\<subseteq> Xs \\<times> Ys\n  finite Ys\n  distinctPerm pi\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> As; finite As\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Ys pi.\n                             Ys \\<sharp>* c \\<and>\n                             Ys \\<inter> As = {} \\<and>\n                             pi \\<bullet> F = Ys \\<and>\n                             set pi \\<subseteq> F \\<times> Ys \\<and>\n                             finite Ys \\<and> distinctPerm pi;\n        insert x F \\<subseteq> As; finite As\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ys pi.\n                            Ys \\<sharp>* c \\<and>\n                            Ys \\<inter> As = {} \\<and>\n                            pi \\<bullet> insert x F = Ys \\<and>\n                            set pi \\<subseteq> insert x F \\<times> Ys \\<and>\n                            finite Ys \\<and> distinctPerm pi", "have b: \"x\\<notin>Xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> Xs", "by fact"], ["proof (state)\nthis:\n  x \\<notin> Xs\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> As; finite As\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Ys pi.\n                             Ys \\<sharp>* c \\<and>\n                             Ys \\<inter> As = {} \\<and>\n                             pi \\<bullet> F = Ys \\<and>\n                             set pi \\<subseteq> F \\<times> Ys \\<and>\n                             finite Ys \\<and> distinctPerm pi;\n        insert x F \\<subseteq> As; finite As\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ys pi.\n                            Ys \\<sharp>* c \\<and>\n                            Ys \\<inter> As = {} \\<and>\n                            pi \\<bullet> insert x F = Ys \\<and>\n                            set pi \\<subseteq> insert x F \\<times> Ys \\<and>\n                            finite Ys \\<and> distinctPerm pi", "have d1: \"finite As\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite As", "by fact"], ["proof (state)\nthis:\n  finite As\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> As; finite As\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Ys pi.\n                             Ys \\<sharp>* c \\<and>\n                             Ys \\<inter> As = {} \\<and>\n                             pi \\<bullet> F = Ys \\<and>\n                             set pi \\<subseteq> F \\<times> Ys \\<and>\n                             finite Ys \\<and> distinctPerm pi;\n        insert x F \\<subseteq> As; finite As\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ys pi.\n                            Ys \\<sharp>* c \\<and>\n                            Ys \\<inter> As = {} \\<and>\n                            pi \\<bullet> insert x F = Ys \\<and>\n                            set pi \\<subseteq> insert x F \\<times> Ys \\<and>\n                            finite Ys \\<and> distinctPerm pi", "have d2: \"finite Xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite Xs", "by fact"], ["proof (state)\nthis:\n  finite Xs\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> As; finite As\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Ys pi.\n                             Ys \\<sharp>* c \\<and>\n                             Ys \\<inter> As = {} \\<and>\n                             pi \\<bullet> F = Ys \\<and>\n                             set pi \\<subseteq> F \\<times> Ys \\<and>\n                             finite Ys \\<and> distinctPerm pi;\n        insert x F \\<subseteq> As; finite As\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ys pi.\n                            Ys \\<sharp>* c \\<and>\n                            Ys \\<inter> As = {} \\<and>\n                            pi \\<bullet> insert x F = Ys \\<and>\n                            set pi \\<subseteq> insert x F \\<times> Ys \\<and>\n                            finite Ys \\<and> distinctPerm pi", "have d3: \"insert x Xs \\<subseteq> As\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert x Xs \\<subseteq> As", "by fact"], ["proof (state)\nthis:\n  insert x Xs \\<subseteq> As\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> As; finite As\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Ys pi.\n                             Ys \\<sharp>* c \\<and>\n                             Ys \\<inter> As = {} \\<and>\n                             pi \\<bullet> F = Ys \\<and>\n                             set pi \\<subseteq> F \\<times> Ys \\<and>\n                             finite Ys \\<and> distinctPerm pi;\n        insert x F \\<subseteq> As; finite As\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ys pi.\n                            Ys \\<sharp>* c \\<and>\n                            Ys \\<inter> As = {} \\<and>\n                            pi \\<bullet> insert x F = Ys \\<and>\n                            set pi \\<subseteq> insert x F \\<times> Ys \\<and>\n                            finite Ys \\<and> distinctPerm pi", "have d4: \"finite((supp pi)::'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (supp pi)", "by(induct pi)\n      (auto simp add: supp_list_nil supp_prod at_fin_set_supp[OF at]\n                      supp_list_cons at_supp[OF at])"], ["proof (state)\nthis:\n  finite (supp pi)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> As; finite As\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Ys pi.\n                             Ys \\<sharp>* c \\<and>\n                             Ys \\<inter> As = {} \\<and>\n                             pi \\<bullet> F = Ys \\<and>\n                             set pi \\<subseteq> F \\<times> Ys \\<and>\n                             finite Ys \\<and> distinctPerm pi;\n        insert x F \\<subseteq> As; finite As\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ys pi.\n                            Ys \\<sharp>* c \\<and>\n                            Ys \\<inter> As = {} \\<and>\n                            pi \\<bullet> insert x F = Ys \\<and>\n                            set pi \\<subseteq> insert x F \\<times> Ys \\<and>\n                            finite Ys \\<and> distinctPerm pi", "have \"\\<exists>y::'a. y\\<sharp>(c,x,Ys,As,pi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y. y \\<sharp> (c, x, Ys, As, pi)", "using d d1 a5 d4"], ["proof (prove)\nusing this:\n  finite (supp c)\n  finite As\n  finite Ys\n  finite (supp pi)\n\ngoal (1 subgoal):\n 1. \\<exists>y. y \\<sharp> (c, x, Ys, As, pi)", "by (rule_tac at_exists_fresh'[OF at])\n       (simp add: supp_prod at_supp[OF at] at_fin_set_supp[OF at])"], ["proof (state)\nthis:\n  \\<exists>y. y \\<sharp> (c, x, Ys, As, pi)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> As; finite As\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Ys pi.\n                             Ys \\<sharp>* c \\<and>\n                             Ys \\<inter> As = {} \\<and>\n                             pi \\<bullet> F = Ys \\<and>\n                             set pi \\<subseteq> F \\<times> Ys \\<and>\n                             finite Ys \\<and> distinctPerm pi;\n        insert x F \\<subseteq> As; finite As\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ys pi.\n                            Ys \\<sharp>* c \\<and>\n                            Ys \\<inter> As = {} \\<and>\n                            pi \\<bullet> insert x F = Ys \\<and>\n                            set pi \\<subseteq> insert x F \\<times> Ys \\<and>\n                            finite Ys \\<and> distinctPerm pi", "then"], ["proof (chain)\npicking this:\n  \\<exists>y. y \\<sharp> (c, x, Ys, As, pi)", "obtain y::\"'a\" where  e: \"y\\<sharp>(c,x,Ys,As,pi)\""], ["proof (prove)\nusing this:\n  \\<exists>y. y \\<sharp> (c, x, Ys, As, pi)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        y \\<sharp> (c, x, Ys, As, pi) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  y \\<sharp> (c, x, Ys, As, pi)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> As; finite As\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Ys pi.\n                             Ys \\<sharp>* c \\<and>\n                             Ys \\<inter> As = {} \\<and>\n                             pi \\<bullet> F = Ys \\<and>\n                             set pi \\<subseteq> F \\<times> Ys \\<and>\n                             finite Ys \\<and> distinctPerm pi;\n        insert x F \\<subseteq> As; finite As\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ys pi.\n                            Ys \\<sharp>* c \\<and>\n                            Ys \\<inter> As = {} \\<and>\n                            pi \\<bullet> insert x F = Ys \\<and>\n                            set pi \\<subseteq> insert x F \\<times> Ys \\<and>\n                            finite Ys \\<and> distinctPerm pi", "have \"({y}\\<union>Ys)\\<sharp>*c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({y} \\<union> Ys) \\<sharp>* c", "using a1 e"], ["proof (prove)\nusing this:\n  Ys \\<sharp>* c\n  y \\<sharp> (c, x, Ys, As, pi)\n\ngoal (1 subgoal):\n 1. ({y} \\<union> Ys) \\<sharp>* c", "by (simp add: fresh_star_def)"], ["proof (state)\nthis:\n  ({y} \\<union> Ys) \\<sharp>* c\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> As; finite As\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Ys pi.\n                             Ys \\<sharp>* c \\<and>\n                             Ys \\<inter> As = {} \\<and>\n                             pi \\<bullet> F = Ys \\<and>\n                             set pi \\<subseteq> F \\<times> Ys \\<and>\n                             finite Ys \\<and> distinctPerm pi;\n        insert x F \\<subseteq> As; finite As\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ys pi.\n                            Ys \\<sharp>* c \\<and>\n                            Ys \\<inter> As = {} \\<and>\n                            pi \\<bullet> insert x F = Ys \\<and>\n                            set pi \\<subseteq> insert x F \\<times> Ys \\<and>\n                            finite Ys \\<and> distinctPerm pi", "moreover"], ["proof (state)\nthis:\n  ({y} \\<union> Ys) \\<sharp>* c\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> As; finite As\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Ys pi.\n                             Ys \\<sharp>* c \\<and>\n                             Ys \\<inter> As = {} \\<and>\n                             pi \\<bullet> F = Ys \\<and>\n                             set pi \\<subseteq> F \\<times> Ys \\<and>\n                             finite Ys \\<and> distinctPerm pi;\n        insert x F \\<subseteq> As; finite As\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ys pi.\n                            Ys \\<sharp>* c \\<and>\n                            Ys \\<inter> As = {} \\<and>\n                            pi \\<bullet> insert x F = Ys \\<and>\n                            set pi \\<subseteq> insert x F \\<times> Ys \\<and>\n                            finite Ys \\<and> distinctPerm pi", "have \"({y}\\<union>Ys)\\<inter>As = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({y} \\<union> Ys) \\<inter> As = {}", "using a2 d1 e"], ["proof (prove)\nusing this:\n  Ys \\<inter> As = {}\n  finite As\n  y \\<sharp> (c, x, Ys, As, pi)\n\ngoal (1 subgoal):\n 1. ({y} \\<union> Ys) \\<inter> As = {}", "by (simp add: fresh_prod at_fin_set_fresh[OF at])"], ["proof (state)\nthis:\n  ({y} \\<union> Ys) \\<inter> As = {}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> As; finite As\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Ys pi.\n                             Ys \\<sharp>* c \\<and>\n                             Ys \\<inter> As = {} \\<and>\n                             pi \\<bullet> F = Ys \\<and>\n                             set pi \\<subseteq> F \\<times> Ys \\<and>\n                             finite Ys \\<and> distinctPerm pi;\n        insert x F \\<subseteq> As; finite As\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ys pi.\n                            Ys \\<sharp>* c \\<and>\n                            Ys \\<inter> As = {} \\<and>\n                            pi \\<bullet> insert x F = Ys \\<and>\n                            set pi \\<subseteq> insert x F \\<times> Ys \\<and>\n                            finite Ys \\<and> distinctPerm pi", "moreover"], ["proof (state)\nthis:\n  ({y} \\<union> Ys) \\<inter> As = {}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> As; finite As\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Ys pi.\n                             Ys \\<sharp>* c \\<and>\n                             Ys \\<inter> As = {} \\<and>\n                             pi \\<bullet> F = Ys \\<and>\n                             set pi \\<subseteq> F \\<times> Ys \\<and>\n                             finite Ys \\<and> distinctPerm pi;\n        insert x F \\<subseteq> As; finite As\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ys pi.\n                            Ys \\<sharp>* c \\<and>\n                            Ys \\<inter> As = {} \\<and>\n                            pi \\<bullet> insert x F = Ys \\<and>\n                            set pi \\<subseteq> insert x F \\<times> Ys \\<and>\n                            finite Ys \\<and> distinctPerm pi", "have \"(((pi\\<bullet>x,y)#pi)\\<bullet>(insert x Xs)) = {y}\\<union>Ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((pi \\<bullet> x, y) # pi) \\<bullet> insert x Xs = {y} \\<union> Ys", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((pi \\<bullet> x, y) # pi) \\<bullet> insert x Xs = {y} \\<union> Ys", "have eq: \"[(pi\\<bullet>x,y)]\\<bullet>Ys = Ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(pi \\<bullet> x, y)] \\<bullet> Ys = Ys", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [(pi \\<bullet> x, y)] \\<bullet> Ys = Ys", "have \"(pi\\<bullet>x)\\<sharp>Ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pi \\<bullet> x \\<sharp> Ys", "using a3[symmetric] b d2"], ["proof (prove)\nusing this:\n  Ys = pi \\<bullet> Xs\n  x \\<notin> Xs\n  finite Xs\n\ngoal (1 subgoal):\n 1. pi \\<bullet> x \\<sharp> Ys", "by(simp add: pt_fresh_bij[OF pt_set_inst, OF at_pt_inst[OF at], OF at, OF at]\n                     at_fin_set_fresh[OF at d2])"], ["proof (state)\nthis:\n  pi \\<bullet> x \\<sharp> Ys\n\ngoal (1 subgoal):\n 1. [(pi \\<bullet> x, y)] \\<bullet> Ys = Ys", "moreover"], ["proof (state)\nthis:\n  pi \\<bullet> x \\<sharp> Ys\n\ngoal (1 subgoal):\n 1. [(pi \\<bullet> x, y)] \\<bullet> Ys = Ys", "have \"y\\<sharp>Ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<sharp> Ys", "using e"], ["proof (prove)\nusing this:\n  y \\<sharp> (c, x, Ys, As, pi)\n\ngoal (1 subgoal):\n 1. y \\<sharp> Ys", "by simp"], ["proof (state)\nthis:\n  y \\<sharp> Ys\n\ngoal (1 subgoal):\n 1. [(pi \\<bullet> x, y)] \\<bullet> Ys = Ys", "ultimately"], ["proof (chain)\npicking this:\n  pi \\<bullet> x \\<sharp> Ys\n  y \\<sharp> Ys", "show \"[(pi\\<bullet>x,y)]\\<bullet>Ys = Ys\""], ["proof (prove)\nusing this:\n  pi \\<bullet> x \\<sharp> Ys\n  y \\<sharp> Ys\n\ngoal (1 subgoal):\n 1. [(pi \\<bullet> x, y)] \\<bullet> Ys = Ys", "by (simp add: pt_fresh_fresh[OF pt_set_inst, OF at_pt_inst[OF at], OF at, OF at])"], ["proof (state)\nthis:\n  [(pi \\<bullet> x, y)] \\<bullet> Ys = Ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [(pi \\<bullet> x, y)] \\<bullet> Ys = Ys\n\ngoal (1 subgoal):\n 1. ((pi \\<bullet> x, y) # pi) \\<bullet> insert x Xs = {y} \\<union> Ys", "have \"(((pi\\<bullet>x,y)#pi)\\<bullet>({x}\\<union>Xs)) = ([(pi\\<bullet>x,y)]\\<bullet>(pi\\<bullet>({x}\\<union>Xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((pi \\<bullet> x, y) # pi) \\<bullet> ({x} \\<union> Xs) =\n    [(pi \\<bullet> x, y)] \\<bullet> pi \\<bullet> ({x} \\<union> Xs)", "by (simp add: pt2[symmetric, OF pt_set_inst, OF at_pt_inst[OF at], OF at])"], ["proof (state)\nthis:\n  ((pi \\<bullet> x, y) # pi) \\<bullet> ({x} \\<union> Xs) =\n  [(pi \\<bullet> x, y)] \\<bullet> pi \\<bullet> ({x} \\<union> Xs)\n\ngoal (1 subgoal):\n 1. ((pi \\<bullet> x, y) # pi) \\<bullet> insert x Xs = {y} \\<union> Ys", "also"], ["proof (state)\nthis:\n  ((pi \\<bullet> x, y) # pi) \\<bullet> ({x} \\<union> Xs) =\n  [(pi \\<bullet> x, y)] \\<bullet> pi \\<bullet> ({x} \\<union> Xs)\n\ngoal (1 subgoal):\n 1. ((pi \\<bullet> x, y) # pi) \\<bullet> insert x Xs = {y} \\<union> Ys", "have \"\\<dots> = {y}\\<union>([(pi\\<bullet>x,y)]\\<bullet>(pi\\<bullet>Xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(pi \\<bullet> x, y)] \\<bullet> pi \\<bullet> ({x} \\<union> Xs) =\n    {y} \\<union> [(pi \\<bullet> x, y)] \\<bullet> pi \\<bullet> Xs", "by (simp only: union_eqvt perm_set_def at_calc[OF at])(auto)"], ["proof (state)\nthis:\n  [(pi \\<bullet> x, y)] \\<bullet> pi \\<bullet> ({x} \\<union> Xs) =\n  {y} \\<union> [(pi \\<bullet> x, y)] \\<bullet> pi \\<bullet> Xs\n\ngoal (1 subgoal):\n 1. ((pi \\<bullet> x, y) # pi) \\<bullet> insert x Xs = {y} \\<union> Ys", "also"], ["proof (state)\nthis:\n  [(pi \\<bullet> x, y)] \\<bullet> pi \\<bullet> ({x} \\<union> Xs) =\n  {y} \\<union> [(pi \\<bullet> x, y)] \\<bullet> pi \\<bullet> Xs\n\ngoal (1 subgoal):\n 1. ((pi \\<bullet> x, y) # pi) \\<bullet> insert x Xs = {y} \\<union> Ys", "have \"\\<dots> = {y}\\<union>([(pi\\<bullet>x,y)]\\<bullet>Ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y} \\<union> [(pi \\<bullet> x, y)] \\<bullet> pi \\<bullet> Xs =\n    {y} \\<union> [(pi \\<bullet> x, y)] \\<bullet> Ys", "using a3"], ["proof (prove)\nusing this:\n  pi \\<bullet> Xs = Ys\n\ngoal (1 subgoal):\n 1. {y} \\<union> [(pi \\<bullet> x, y)] \\<bullet> pi \\<bullet> Xs =\n    {y} \\<union> [(pi \\<bullet> x, y)] \\<bullet> Ys", "by simp"], ["proof (state)\nthis:\n  {y} \\<union> [(pi \\<bullet> x, y)] \\<bullet> pi \\<bullet> Xs =\n  {y} \\<union> [(pi \\<bullet> x, y)] \\<bullet> Ys\n\ngoal (1 subgoal):\n 1. ((pi \\<bullet> x, y) # pi) \\<bullet> insert x Xs = {y} \\<union> Ys", "also"], ["proof (state)\nthis:\n  {y} \\<union> [(pi \\<bullet> x, y)] \\<bullet> pi \\<bullet> Xs =\n  {y} \\<union> [(pi \\<bullet> x, y)] \\<bullet> Ys\n\ngoal (1 subgoal):\n 1. ((pi \\<bullet> x, y) # pi) \\<bullet> insert x Xs = {y} \\<union> Ys", "have \"\\<dots> = {y}\\<union>Ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y} \\<union> [(pi \\<bullet> x, y)] \\<bullet> Ys = {y} \\<union> Ys", "using eq"], ["proof (prove)\nusing this:\n  [(pi \\<bullet> x, y)] \\<bullet> Ys = Ys\n\ngoal (1 subgoal):\n 1. {y} \\<union> [(pi \\<bullet> x, y)] \\<bullet> Ys = {y} \\<union> Ys", "by simp"], ["proof (state)\nthis:\n  {y} \\<union> [(pi \\<bullet> x, y)] \\<bullet> Ys = {y} \\<union> Ys\n\ngoal (1 subgoal):\n 1. ((pi \\<bullet> x, y) # pi) \\<bullet> insert x Xs = {y} \\<union> Ys", "finally"], ["proof (chain)\npicking this:\n  ((pi \\<bullet> x, y) # pi) \\<bullet> ({x} \\<union> Xs) = {y} \\<union> Ys", "show \"(((pi\\<bullet>x,y)#pi)\\<bullet>(insert x Xs)) = {y}\\<union>Ys\""], ["proof (prove)\nusing this:\n  ((pi \\<bullet> x, y) # pi) \\<bullet> ({x} \\<union> Xs) = {y} \\<union> Ys\n\ngoal (1 subgoal):\n 1. ((pi \\<bullet> x, y) # pi) \\<bullet> insert x Xs = {y} \\<union> Ys", "by auto"], ["proof (state)\nthis:\n  ((pi \\<bullet> x, y) # pi) \\<bullet> insert x Xs = {y} \\<union> Ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((pi \\<bullet> x, y) # pi) \\<bullet> insert x Xs = {y} \\<union> Ys\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> As; finite As\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Ys pi.\n                             Ys \\<sharp>* c \\<and>\n                             Ys \\<inter> As = {} \\<and>\n                             pi \\<bullet> F = Ys \\<and>\n                             set pi \\<subseteq> F \\<times> Ys \\<and>\n                             finite Ys \\<and> distinctPerm pi;\n        insert x F \\<subseteq> As; finite As\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ys pi.\n                            Ys \\<sharp>* c \\<and>\n                            Ys \\<inter> As = {} \\<and>\n                            pi \\<bullet> insert x F = Ys \\<and>\n                            set pi \\<subseteq> insert x F \\<times> Ys \\<and>\n                            finite Ys \\<and> distinctPerm pi", "moreover"], ["proof (state)\nthis:\n  ((pi \\<bullet> x, y) # pi) \\<bullet> insert x Xs = {y} \\<union> Ys\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> As; finite As\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Ys pi.\n                             Ys \\<sharp>* c \\<and>\n                             Ys \\<inter> As = {} \\<and>\n                             pi \\<bullet> F = Ys \\<and>\n                             set pi \\<subseteq> F \\<times> Ys \\<and>\n                             finite Ys \\<and> distinctPerm pi;\n        insert x F \\<subseteq> As; finite As\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ys pi.\n                            Ys \\<sharp>* c \\<and>\n                            Ys \\<inter> As = {} \\<and>\n                            pi \\<bullet> insert x F = Ys \\<and>\n                            set pi \\<subseteq> insert x F \\<times> Ys \\<and>\n                            finite Ys \\<and> distinctPerm pi", "have \"pi\\<bullet>x=x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pi \\<bullet> x = x", "using a4 b a2 a3 d3"], ["proof (prove)\nusing this:\n  set pi \\<subseteq> Xs \\<times> Ys\n  x \\<notin> Xs\n  Ys \\<inter> As = {}\n  pi \\<bullet> Xs = Ys\n  insert x Xs \\<subseteq> As\n\ngoal (1 subgoal):\n 1. pi \\<bullet> x = x", "by (rule_tac at_prm_fresh2[OF at]) (auto)"], ["proof (state)\nthis:\n  pi \\<bullet> x = x\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> As; finite As\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Ys pi.\n                             Ys \\<sharp>* c \\<and>\n                             Ys \\<inter> As = {} \\<and>\n                             pi \\<bullet> F = Ys \\<and>\n                             set pi \\<subseteq> F \\<times> Ys \\<and>\n                             finite Ys \\<and> distinctPerm pi;\n        insert x F \\<subseteq> As; finite As\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ys pi.\n                            Ys \\<sharp>* c \\<and>\n                            Ys \\<inter> As = {} \\<and>\n                            pi \\<bullet> insert x F = Ys \\<and>\n                            set pi \\<subseteq> insert x F \\<times> Ys \\<and>\n                            finite Ys \\<and> distinctPerm pi", "then"], ["proof (chain)\npicking this:\n  pi \\<bullet> x = x", "have \"set ((pi\\<bullet>x,y)#pi) \\<subseteq> (insert x Xs) \\<times> ({y}\\<union>Ys)\""], ["proof (prove)\nusing this:\n  pi \\<bullet> x = x\n\ngoal (1 subgoal):\n 1. set ((pi \\<bullet> x, y) # pi)\n    \\<subseteq> insert x Xs \\<times> ({y} \\<union> Ys)", "using a4"], ["proof (prove)\nusing this:\n  pi \\<bullet> x = x\n  set pi \\<subseteq> Xs \\<times> Ys\n\ngoal (1 subgoal):\n 1. set ((pi \\<bullet> x, y) # pi)\n    \\<subseteq> insert x Xs \\<times> ({y} \\<union> Ys)", "by auto"], ["proof (state)\nthis:\n  set ((pi \\<bullet> x, y) # pi)\n  \\<subseteq> insert x Xs \\<times> ({y} \\<union> Ys)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> As; finite As\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Ys pi.\n                             Ys \\<sharp>* c \\<and>\n                             Ys \\<inter> As = {} \\<and>\n                             pi \\<bullet> F = Ys \\<and>\n                             set pi \\<subseteq> F \\<times> Ys \\<and>\n                             finite Ys \\<and> distinctPerm pi;\n        insert x F \\<subseteq> As; finite As\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ys pi.\n                            Ys \\<sharp>* c \\<and>\n                            Ys \\<inter> As = {} \\<and>\n                            pi \\<bullet> insert x F = Ys \\<and>\n                            set pi \\<subseteq> insert x F \\<times> Ys \\<and>\n                            finite Ys \\<and> distinctPerm pi", "moreover"], ["proof (state)\nthis:\n  set ((pi \\<bullet> x, y) # pi)\n  \\<subseteq> insert x Xs \\<times> ({y} \\<union> Ys)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> As; finite As\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Ys pi.\n                             Ys \\<sharp>* c \\<and>\n                             Ys \\<inter> As = {} \\<and>\n                             pi \\<bullet> F = Ys \\<and>\n                             set pi \\<subseteq> F \\<times> Ys \\<and>\n                             finite Ys \\<and> distinctPerm pi;\n        insert x F \\<subseteq> As; finite As\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ys pi.\n                            Ys \\<sharp>* c \\<and>\n                            Ys \\<inter> As = {} \\<and>\n                            pi \\<bullet> insert x F = Ys \\<and>\n                            set pi \\<subseteq> insert x F \\<times> Ys \\<and>\n                            finite Ys \\<and> distinctPerm pi", "have \"finite ({y}\\<union>Ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ({y} \\<union> Ys)", "using a5"], ["proof (prove)\nusing this:\n  finite Ys\n\ngoal (1 subgoal):\n 1. finite ({y} \\<union> Ys)", "by simp"], ["proof (state)\nthis:\n  finite ({y} \\<union> Ys)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> As; finite As\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Ys pi.\n                             Ys \\<sharp>* c \\<and>\n                             Ys \\<inter> As = {} \\<and>\n                             pi \\<bullet> F = Ys \\<and>\n                             set pi \\<subseteq> F \\<times> Ys \\<and>\n                             finite Ys \\<and> distinctPerm pi;\n        insert x F \\<subseteq> As; finite As\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ys pi.\n                            Ys \\<sharp>* c \\<and>\n                            Ys \\<inter> As = {} \\<and>\n                            pi \\<bullet> insert x F = Ys \\<and>\n                            set pi \\<subseteq> insert x F \\<times> Ys \\<and>\n                            finite Ys \\<and> distinctPerm pi", "moreover"], ["proof (state)\nthis:\n  finite ({y} \\<union> Ys)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> As; finite As\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Ys pi.\n                             Ys \\<sharp>* c \\<and>\n                             Ys \\<inter> As = {} \\<and>\n                             pi \\<bullet> F = Ys \\<and>\n                             set pi \\<subseteq> F \\<times> Ys \\<and>\n                             finite Ys \\<and> distinctPerm pi;\n        insert x F \\<subseteq> As; finite As\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ys pi.\n                            Ys \\<sharp>* c \\<and>\n                            Ys \\<inter> As = {} \\<and>\n                            pi \\<bullet> insert x F = Ys \\<and>\n                            set pi \\<subseteq> insert x F \\<times> Ys \\<and>\n                            finite Ys \\<and> distinctPerm pi", "from \\<open>Ys \\<inter> As = {}\\<close> \\<open>(insert x Xs) \\<subseteq> As\\<close> \\<open>finite Ys\\<close>"], ["proof (chain)\npicking this:\n  Ys \\<inter> As = {}\n  insert x Xs \\<subseteq> As\n  finite Ys", "have \"x \\<notin> Ys\""], ["proof (prove)\nusing this:\n  Ys \\<inter> As = {}\n  insert x Xs \\<subseteq> As\n  finite Ys\n\ngoal (1 subgoal):\n 1. x \\<notin> Ys", "by(auto simp add: fresh_def at_fin_set_supp[OF at])"], ["proof (state)\nthis:\n  x \\<notin> Ys\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> As; finite As\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Ys pi.\n                             Ys \\<sharp>* c \\<and>\n                             Ys \\<inter> As = {} \\<and>\n                             pi \\<bullet> F = Ys \\<and>\n                             set pi \\<subseteq> F \\<times> Ys \\<and>\n                             finite Ys \\<and> distinctPerm pi;\n        insert x F \\<subseteq> As; finite As\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ys pi.\n                            Ys \\<sharp>* c \\<and>\n                            Ys \\<inter> As = {} \\<and>\n                            pi \\<bullet> insert x F = Ys \\<and>\n                            set pi \\<subseteq> insert x F \\<times> Ys \\<and>\n                            finite Ys \\<and> distinctPerm pi", "with a6 \\<open>pi \\<bullet> x = x\\<close> \\<open>x \\<notin> Xs\\<close> \\<open>(set pi) \\<subseteq> Xs \\<times> Ys\\<close> e"], ["proof (chain)\npicking this:\n  distinctPerm pi\n  pi \\<bullet> x = x\n  x \\<notin> Xs\n  set pi \\<subseteq> Xs \\<times> Ys\n  y \\<sharp> (c, x, Ys, As, pi)\n  x \\<notin> Ys", "have \"distinctPerm((pi \\<bullet> x, y)#pi)\""], ["proof (prove)\nusing this:\n  distinctPerm pi\n  pi \\<bullet> x = x\n  x \\<notin> Xs\n  set pi \\<subseteq> Xs \\<times> Ys\n  y \\<sharp> (c, x, Ys, As, pi)\n  x \\<notin> Ys\n\ngoal (1 subgoal):\n 1. distinctPerm ((pi \\<bullet> x, y) # pi)", "apply(auto simp add: distinctPerm_def fresh_prod at_fresh[OF at])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>pi \\<bullet> x = x; x \\<notin> Xs;\n        set pi \\<subseteq> Xs \\<times> Ys; x \\<notin> Ys;\n        distinct (map fst pi); y \\<sharp> c; distinct (map snd pi);\n        fst ` set pi \\<inter> snd ` set pi = {}; y \\<noteq> x;\n        y \\<sharp> Ys; y \\<sharp> As; y \\<sharp> pi;\n        (a, y) \\<in> set pi\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>b.\n       \\<lbrakk>pi \\<bullet> x = x; x \\<notin> Xs;\n        set pi \\<subseteq> Xs \\<times> Ys; x \\<notin> Ys;\n        distinct (map fst pi); y \\<sharp> c; distinct (map snd pi);\n        fst ` set pi \\<inter> snd ` set pi = {}; y \\<noteq> x;\n        y \\<sharp> Ys; y \\<sharp> As; y \\<sharp> pi;\n        (y, b) \\<in> set pi\\<rbrakk>\n       \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>pi \\<bullet> x = x; x \\<notin> Xs;\n        set pi \\<subseteq> Xs \\<times> Ys; x \\<notin> Ys;\n        distinct (map fst pi); y \\<sharp> c; distinct (map snd pi);\n        fst ` set pi \\<inter> snd ` set pi = {}; y \\<noteq> x;\n        y \\<sharp> Ys; y \\<sharp> As; y \\<sharp> pi;\n        (a, y) \\<in> set pi\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>b.\n       \\<lbrakk>pi \\<bullet> x = x; x \\<notin> Xs;\n        set pi \\<subseteq> Xs \\<times> Ys; x \\<notin> Ys;\n        distinct (map fst pi); y \\<sharp> c; distinct (map snd pi);\n        fst ` set pi \\<inter> snd ` set pi = {}; y \\<noteq> x;\n        y \\<sharp> Ys; y \\<sharp> As; y \\<sharp> pi;\n        (y, b) \\<in> set pi\\<rbrakk>\n       \\<Longrightarrow> False", "fix a b"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>pi \\<bullet> x = x; x \\<notin> Xs;\n        set pi \\<subseteq> Xs \\<times> Ys; x \\<notin> Ys;\n        distinct (map fst pi); y \\<sharp> c; distinct (map snd pi);\n        fst ` set pi \\<inter> snd ` set pi = {}; y \\<noteq> x;\n        y \\<sharp> Ys; y \\<sharp> As; y \\<sharp> pi;\n        (a, y) \\<in> set pi\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>b.\n       \\<lbrakk>pi \\<bullet> x = x; x \\<notin> Xs;\n        set pi \\<subseteq> Xs \\<times> Ys; x \\<notin> Ys;\n        distinct (map fst pi); y \\<sharp> c; distinct (map snd pi);\n        fst ` set pi \\<inter> snd ` set pi = {}; y \\<noteq> x;\n        y \\<sharp> Ys; y \\<sharp> As; y \\<sharp> pi;\n        (y, b) \\<in> set pi\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"b \\<sharp> pi\" and \"(a, b) \\<in> set pi\""], ["proof (state)\nthis:\n  b \\<sharp> pi\n  (a, b) \\<in> set pi\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>pi \\<bullet> x = x; x \\<notin> Xs;\n        set pi \\<subseteq> Xs \\<times> Ys; x \\<notin> Ys;\n        distinct (map fst pi); y \\<sharp> c; distinct (map snd pi);\n        fst ` set pi \\<inter> snd ` set pi = {}; y \\<noteq> x;\n        y \\<sharp> Ys; y \\<sharp> As; y \\<sharp> pi;\n        (a, y) \\<in> set pi\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>b.\n       \\<lbrakk>pi \\<bullet> x = x; x \\<notin> Xs;\n        set pi \\<subseteq> Xs \\<times> Ys; x \\<notin> Ys;\n        distinct (map fst pi); y \\<sharp> c; distinct (map snd pi);\n        fst ` set pi \\<inter> snd ` set pi = {}; y \\<noteq> x;\n        y \\<sharp> Ys; y \\<sharp> As; y \\<sharp> pi;\n        (y, b) \\<in> set pi\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  b \\<sharp> pi\n  (a, b) \\<in> set pi\n\ngoal (1 subgoal):\n 1. False", "by(induct pi)\n          (auto simp add: supp_list_cons supp_prod at_supp[OF at] fresh_list_cons fresh_prod at_fresh[OF at])"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>pi \\<bullet> x = x; x \\<notin> Xs;\n        set pi \\<subseteq> Xs \\<times> Ys; x \\<notin> Ys;\n        distinct (map fst pi); y \\<sharp> c; distinct (map snd pi);\n        fst ` set pi \\<inter> snd ` set pi = {}; y \\<noteq> x;\n        y \\<sharp> Ys; y \\<sharp> As; y \\<sharp> pi;\n        (y, b) \\<in> set pi\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>pi \\<bullet> x = x; x \\<notin> Xs;\n        set pi \\<subseteq> Xs \\<times> Ys; x \\<notin> Ys;\n        distinct (map fst pi); y \\<sharp> c; distinct (map snd pi);\n        fst ` set pi \\<inter> snd ` set pi = {}; y \\<noteq> x;\n        y \\<sharp> Ys; y \\<sharp> As; y \\<sharp> pi;\n        (y, b) \\<in> set pi\\<rbrakk>\n       \\<Longrightarrow> False", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>pi \\<bullet> x = x; x \\<notin> Xs;\n        set pi \\<subseteq> Xs \\<times> Ys; x \\<notin> Ys;\n        distinct (map fst pi); y \\<sharp> c; distinct (map snd pi);\n        fst ` set pi \\<inter> snd ` set pi = {}; y \\<noteq> x;\n        y \\<sharp> Ys; y \\<sharp> As; y \\<sharp> pi;\n        (y, b) \\<in> set pi\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"a \\<sharp> pi\" and \"(a, b) \\<in> set pi\""], ["proof (state)\nthis:\n  a \\<sharp> pi\n  (a, b) \\<in> set pi\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>pi \\<bullet> x = x; x \\<notin> Xs;\n        set pi \\<subseteq> Xs \\<times> Ys; x \\<notin> Ys;\n        distinct (map fst pi); y \\<sharp> c; distinct (map snd pi);\n        fst ` set pi \\<inter> snd ` set pi = {}; y \\<noteq> x;\n        y \\<sharp> Ys; y \\<sharp> As; y \\<sharp> pi;\n        (y, b) \\<in> set pi\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  a \\<sharp> pi\n  (a, b) \\<in> set pi\n\ngoal (1 subgoal):\n 1. False", "by(induct pi)\n          (auto simp add: supp_list_cons supp_prod at_supp[OF at] fresh_list_cons fresh_prod at_fresh[OF at])"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinctPerm ((pi \\<bullet> x, y) # pi)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> As; finite As\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Ys pi.\n                             Ys \\<sharp>* c \\<and>\n                             Ys \\<inter> As = {} \\<and>\n                             pi \\<bullet> F = Ys \\<and>\n                             set pi \\<subseteq> F \\<times> Ys \\<and>\n                             finite Ys \\<and> distinctPerm pi;\n        insert x F \\<subseteq> As; finite As\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ys pi.\n                            Ys \\<sharp>* c \\<and>\n                            Ys \\<inter> As = {} \\<and>\n                            pi \\<bullet> insert x F = Ys \\<and>\n                            set pi \\<subseteq> insert x F \\<times> Ys \\<and>\n                            finite Ys \\<and> distinctPerm pi", "ultimately"], ["proof (chain)\npicking this:\n  ({y} \\<union> Ys) \\<sharp>* c\n  ({y} \\<union> Ys) \\<inter> As = {}\n  ((pi \\<bullet> x, y) # pi) \\<bullet> insert x Xs = {y} \\<union> Ys\n  set ((pi \\<bullet> x, y) # pi)\n  \\<subseteq> insert x Xs \\<times> ({y} \\<union> Ys)\n  finite ({y} \\<union> Ys)\n  distinctPerm ((pi \\<bullet> x, y) # pi)", "show ?case"], ["proof (prove)\nusing this:\n  ({y} \\<union> Ys) \\<sharp>* c\n  ({y} \\<union> Ys) \\<inter> As = {}\n  ((pi \\<bullet> x, y) # pi) \\<bullet> insert x Xs = {y} \\<union> Ys\n  set ((pi \\<bullet> x, y) # pi)\n  \\<subseteq> insert x Xs \\<times> ({y} \\<union> Ys)\n  finite ({y} \\<union> Ys)\n  distinctPerm ((pi \\<bullet> x, y) # pi)\n\ngoal (1 subgoal):\n 1. \\<exists>Ys pi.\n       Ys \\<sharp>* c \\<and>\n       Ys \\<inter> As = {} \\<and>\n       pi \\<bullet> insert x Xs = Ys \\<and>\n       set pi \\<subseteq> insert x Xs \\<times> Ys \\<and>\n       finite Ys \\<and> distinctPerm pi", "by blast"], ["proof (state)\nthis:\n  \\<exists>Ys pi.\n     Ys \\<sharp>* c \\<and>\n     Ys \\<inter> As = {} \\<and>\n     pi \\<bullet> insert x Xs = Ys \\<and>\n     set pi \\<subseteq> insert x Xs \\<times> Ys \\<and>\n     finite Ys \\<and> distinctPerm pi\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma at_set_avoiding:\n  fixes Xs::\"'a set\"\n  assumes at: \"at TYPE('a)\"\n  and     a: \"finite Xs\"\n  and     b: \"finite ((supp c)::'a set)\"\n  obtains pi::\"'a prm\" where \"(pi \\<bullet> Xs) \\<sharp>* c\" and \"set pi \\<subseteq> Xs \\<times> (pi \\<bullet> Xs)\" and \"distinctPerm pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pi.\n        \\<lbrakk>(pi \\<bullet> Xs) \\<sharp>* c;\n         set pi \\<subseteq> Xs \\<times> pi \\<bullet> Xs;\n         distinctPerm pi\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using a b"], ["proof (prove)\nusing this:\n  finite Xs\n  finite (supp c)\n\ngoal (1 subgoal):\n 1. (\\<And>pi.\n        \\<lbrakk>(pi \\<bullet> Xs) \\<sharp>* c;\n         set pi \\<subseteq> Xs \\<times> pi \\<bullet> Xs;\n         distinctPerm pi\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (frule_tac As=\"Xs\" in at_set_avoiding_aux'[OF at]) auto"], ["", "lemma pt_swap:\n  fixes x :: 'a\n  and a :: 'x\n  and b :: 'x\n\n  assumes pt: \"pt TYPE('a) TYPE('x)\"\n  and     at: \"at TYPE('x)\"\n\n  shows \"[(a, b)] \\<bullet> x = [(b, a)] \\<bullet> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(a, b)] \\<bullet> x = [(b, a)] \\<bullet> x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [(a, b)] \\<bullet> x = [(b, a)] \\<bullet> x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. [(a, b)] \\<bullet> x = [(b, a)] \\<bullet> x", "by(simp add: pt3[OF pt] at_ds5[OF at])"], ["proof (state)\nthis:\n  [(a, b)] \\<bullet> x = [(b, a)] \\<bullet> x\n\ngoal:\nNo subgoals!", "qed"], ["", "atom_decl name"], ["", "lemma supp_subset:\n  fixes Xs :: \"'a::fs_name set\"\n  and   Ys :: \"'a::fs_name set\"\n\n  assumes \"Xs \\<subseteq> Ys\"\n  and     \"finite Xs\"\n  and     \"finite Ys\"\n\n  shows \"(supp Xs) \\<subseteq> ((supp Ys)::name set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp Xs \\<subseteq> supp Ys", "proof(rule subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> supp Xs \\<Longrightarrow> x \\<in> supp Ys", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> supp Xs \\<Longrightarrow> x \\<in> supp Ys", "assume \"x \\<in> ((supp Xs)::name set)\""], ["proof (state)\nthis:\n  x \\<in> supp Xs\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> supp Xs \\<Longrightarrow> x \\<in> supp Ys", "with \\<open>finite Xs\\<close>"], ["proof (chain)\npicking this:\n  finite Xs\n  x \\<in> supp Xs", "obtain X where \"X \\<in> Xs\" and \"x \\<in> supp X\""], ["proof (prove)\nusing this:\n  finite Xs\n  x \\<in> supp Xs\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<in> Xs; x \\<in> supp X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule supp_member[OF pt_name_inst, OF at_name_inst, OF fs_name_inst])"], ["proof (state)\nthis:\n  X \\<in> Xs\n  x \\<in> supp X\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> supp Xs \\<Longrightarrow> x \\<in> supp Ys", "from \\<open>X \\<in> Xs\\<close> \\<open>Xs \\<subseteq> Ys\\<close>"], ["proof (chain)\npicking this:\n  X \\<in> Xs\n  Xs \\<subseteq> Ys", "have \"X \\<in> Ys\""], ["proof (prove)\nusing this:\n  X \\<in> Xs\n  Xs \\<subseteq> Ys\n\ngoal (1 subgoal):\n 1. X \\<in> Ys", "by auto"], ["proof (state)\nthis:\n  X \\<in> Ys\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> supp Xs \\<Longrightarrow> x \\<in> supp Ys", "with \\<open>finite Ys\\<close> \\<open>x \\<in> supp X\\<close>"], ["proof (chain)\npicking this:\n  finite Ys\n  x \\<in> supp X\n  X \\<in> Ys", "show \"x \\<in> supp Ys\""], ["proof (prove)\nusing this:\n  finite Ys\n  x \\<in> supp X\n  X \\<in> Ys\n\ngoal (1 subgoal):\n 1. x \\<in> supp Ys", "by(induct rule: finite_induct)\n      (auto simp add: supp_fin_insert[OF pt_name_inst, OF at_name_inst, OF fs_name_inst])"], ["proof (state)\nthis:\n  x \\<in> supp Ys\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation mem_def :: \"'a \\<Rightarrow> 'a list \\<Rightarrow> bool\" (\"_ mem _\" [80, 80] 80)  where\n  \"x mem xs \\<equiv> x \\<in> set xs\""], ["", "lemma memFresh:\n  fixes x :: name\n  and   p :: \"'a::fs_name\"\n  and   l :: \"('a::fs_name) list\"\n\n  assumes \"x \\<sharp> l\"\n  and     \"p mem l\"\n  \n  shows \"x \\<sharp> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> p", "using assms"], ["proof (prove)\nusing this:\n  x \\<sharp> l\n  p mem l\n\ngoal (1 subgoal):\n 1. x \\<sharp> p", "by(induct l, auto simp add: fresh_list_cons)"], ["", "lemma memFreshChain:\n  fixes xvec :: \"name list\"\n  and   p    :: \"'a::fs_name\"\n  and   l    :: \"'a::fs_name list\"\n  and   Xs   :: \"name set\"\n\n  assumes \"p mem l\"\n  \n  shows \"xvec \\<sharp>* l \\<Longrightarrow> xvec \\<sharp>* p\"\n  and   \"Xs \\<sharp>* l \\<Longrightarrow> Xs \\<sharp>* p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xvec \\<sharp>* l \\<Longrightarrow> xvec \\<sharp>* p) &&&\n    (Xs \\<sharp>* l \\<Longrightarrow> Xs \\<sharp>* p)", "using assms"], ["proof (prove)\nusing this:\n  p mem l\n\ngoal (1 subgoal):\n 1. (xvec \\<sharp>* l \\<Longrightarrow> xvec \\<sharp>* p) &&&\n    (Xs \\<sharp>* l \\<Longrightarrow> Xs \\<sharp>* p)", "by(auto simp add: fresh_star_def intro: memFresh)"], ["", "lemma fresh_star_list_append[simp]:\n  fixes A :: \"name list\"\n  and   B :: \"name list\"\n  and   C :: \"name list\"\n\n  shows \"(A \\<sharp>* (B @ C)) = ((A \\<sharp>* B) \\<and> (A \\<sharp>* C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<sharp>* (B @ C) = (A \\<sharp>* B \\<and> A \\<sharp>* C)", "by(auto simp add: fresh_star_def fresh_list_append)"], ["", "lemma unionSimps[simp]:\n  fixes Xs :: \"name set\"\n  and   Ys :: \"name set\"\n  and   C  :: \"'a::fs_name\"\n\n  shows \"((Xs \\<union> Ys) \\<sharp>* C) = ((Xs \\<sharp>* C) \\<and> (Ys \\<sharp>* C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Xs \\<union> Ys) \\<sharp>* C = (Xs \\<sharp>* C \\<and> Ys \\<sharp>* C)", "by(auto simp add: fresh_star_def)"], ["", "lemma substFreshAux[simp]:\n  fixes C    :: \"'a::fs_name\"\n  and   xvec :: \"name list\"\n\n  shows \"xvec \\<sharp>* (supp C - set xvec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xvec \\<sharp>* (supp C - set xvec)", "by(auto simp add: fresh_star_def fresh_def at_fin_set_supp[OF at_name_inst] fs_name1)"], ["", "lemma fresh_star_perm_app[simp]:\n  fixes Xs :: \"name set\"\n  and   xvec :: \"name list\"\n  and   p  :: \"name prm\"\n  and   C  :: \"'d::fs_name\"\n\n  shows \"\\<lbrakk>Xs \\<sharp>* p; Xs \\<sharp>* C\\<rbrakk> \\<Longrightarrow> Xs \\<sharp>* (p \\<bullet> C)\"\n  and   \"\\<lbrakk>xvec \\<sharp>* p; xvec \\<sharp>* C\\<rbrakk> \\<Longrightarrow> xvec \\<sharp>* (p \\<bullet> C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>Xs \\<sharp>* p; Xs \\<sharp>* C\\<rbrakk>\n     \\<Longrightarrow> Xs \\<sharp>* (p \\<bullet> C)) &&&\n    (\\<lbrakk>xvec \\<sharp>* p; xvec \\<sharp>* C\\<rbrakk>\n     \\<Longrightarrow> xvec \\<sharp>* (p \\<bullet> C))", "by(auto simp add: fresh_star_def fresh_perm_app)"], ["", "lemma freshSets[simp]:\n  fixes x    :: name\n  and   y    :: name\n  and   xvec :: \"name list\"\n  and   X    :: \"name set\"\n  and   C    :: 'a\n\n  shows \"([]::name list) \\<sharp>* C\"\n  and   \"([]::name list) \\<sharp>* [y].C\"\n  and   \"({}::name set) \\<sharp>* C\"\n  and   \"({}::name set) \\<sharp>* [y].C\"\n  and   \"((x#xvec) \\<sharp>* C) = (x \\<sharp> C \\<and> xvec \\<sharp>* C)\"\n  and   \"((x#xvec) \\<sharp>* ([y].C)) = (x \\<sharp> ([y].C) \\<and> xvec \\<sharp>* ([y].C))\"\n  and   \"((insert x X) \\<sharp>* C) = (x \\<sharp> C \\<and> X \\<sharp>* C)\"\n  and   \"((insert x X) \\<sharp>* ([y].C)) = (x \\<sharp> ([y].C) \\<and> X \\<sharp>* ([y].C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (([] \\<sharp>* C &&& [] \\<sharp>* [y].C) &&&\n     {} \\<sharp>* C &&& {} \\<sharp>* [y].C) &&&\n    ((x # xvec) \\<sharp>* C = (x \\<sharp> C \\<and> xvec \\<sharp>* C) &&&\n     (x # xvec) \\<sharp>* [y].C =\n     (x \\<sharp> [y].C \\<and> xvec \\<sharp>* [y].C)) &&&\n    insert x X \\<sharp>* C = (x \\<sharp> C \\<and> X \\<sharp>* C) &&&\n    insert x X \\<sharp>* [y].C = (x \\<sharp> [y].C \\<and> X \\<sharp>* [y].C)", "by(auto simp add: fresh_star_def)"], ["", "lemma freshStarAtom[simp]: \"(xvec::name list) \\<sharp>* (x::name) = x \\<sharp> xvec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xvec \\<sharp>* x = x \\<sharp> xvec", "by(induct xvec)\n  (auto simp add: fresh_list_nil fresh_list_cons fresh_atm)"], ["", "lemma name_list_set_fresh[simp]:\n  fixes xvec :: \"name list\"\n  and   x    :: \"'a::fs_name\"\n\n  shows \"(set xvec) \\<sharp>* x = xvec \\<sharp>* x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xvec \\<sharp>* x = xvec \\<sharp>* x", "by(auto simp add: fresh_star_def)"], ["", "lemma name_list_supp:\n  fixes xvec :: \"name list\"\n\n  shows \"set xvec = supp xvec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xvec = supp xvec", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set xvec = supp xvec", "have \"set xvec = supp(set xvec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xvec = supp (set xvec)", "by(simp add: at_fin_set_supp[OF at_name_inst])"], ["proof (state)\nthis:\n  set xvec = supp (set xvec)\n\ngoal (1 subgoal):\n 1. set xvec = supp xvec", "moreover"], ["proof (state)\nthis:\n  set xvec = supp (set xvec)\n\ngoal (1 subgoal):\n 1. set xvec = supp xvec", "have \"\\<dots> = supp xvec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (set xvec) = supp xvec", "by(simp add: pt_list_set_supp[OF pt_name_inst, OF at_name_inst, OF fs_name_inst])"], ["proof (state)\nthis:\n  supp (set xvec) = supp xvec\n\ngoal (1 subgoal):\n 1. set xvec = supp xvec", "ultimately"], ["proof (chain)\npicking this:\n  set xvec = supp (set xvec)\n  supp (set xvec) = supp xvec", "show ?thesis"], ["proof (prove)\nusing this:\n  set xvec = supp (set xvec)\n  supp (set xvec) = supp xvec\n\ngoal (1 subgoal):\n 1. set xvec = supp xvec", "by simp"], ["proof (state)\nthis:\n  set xvec = supp xvec\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma abs_fresh_list_star:\n  fixes xvec :: \"name list\"\n  and   a    :: name\n  and   P    :: \"'a::fs_name\"\n\n  shows \"(xvec \\<sharp>* [a].P) = ((set xvec) - {a}) \\<sharp>* P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xvec \\<sharp>* [a].P = (set xvec - {a}) \\<sharp>* P", "by(induct xvec) (auto simp add: fresh_star_def abs_fresh)"], ["", "lemma abs_fresh_set_star:\n  fixes X :: \"name set\"\n  and   a :: name\n  and   P :: \"'a::fs_name\"\n\n  shows \"(X \\<sharp>* [a].P) = (X - {a}) \\<sharp>* P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<sharp>* [a].P = (X - {a}) \\<sharp>* P", "by(auto simp add: fresh_star_def abs_fresh)"], ["", "lemmas abs_fresh_star = abs_fresh_list_star abs_fresh_set_star"], ["", "lemma abs_fresh_list_star'[simp]:\n  fixes xvec :: \"name list\"\n  and   a    :: name\n  and   P    :: \"'a::fs_name\"\n\n  assumes \"a \\<sharp> xvec\"\n\n  shows \"xvec \\<sharp>* [a].P = xvec \\<sharp>* P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xvec \\<sharp>* [a].P = xvec \\<sharp>* P", "using assms"], ["proof (prove)\nusing this:\n  a \\<sharp> xvec\n\ngoal (1 subgoal):\n 1. xvec \\<sharp>* [a].P = xvec \\<sharp>* P", "by(induct xvec) (auto simp add: abs_fresh fresh_list_cons fresh_atm)"], ["", "lemma freshChainSym[simp]:\n  fixes xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  \n  shows   \"xvec \\<sharp>* yvec = yvec \\<sharp>* xvec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xvec \\<sharp>* yvec = yvec \\<sharp>* xvec", "by(auto simp add: fresh_star_def fresh_def name_list_supp)"], ["", "lemmas [eqvt] = perm_cart_prod[OF pt_name_inst, OF pt_name_inst, OF at_name_inst]"], ["", "lemma name_set_avoiding:\n  fixes c :: \"'a::fs_name\"\n  and   X :: \"name set\"\n  \n  assumes \"finite X\"\n  and     \"\\<And>pi::name prm. \\<lbrakk>(pi \\<bullet> X) \\<sharp>* c; distinctPerm pi; set pi \\<subseteq> X \\<times> (pi \\<bullet> X)\\<rbrakk> \\<Longrightarrow> thesis\"\n\n  shows thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using assms"], ["proof (prove)\nusing this:\n  finite X\n  \\<lbrakk>(?pi \\<bullet> X) \\<sharp>* c; distinctPerm ?pi;\n   set ?pi \\<subseteq> X \\<times> ?pi \\<bullet> X\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by(rule_tac c=c in at_set_avoiding[OF at_name_inst]) (simp_all add: fs_name1)"], ["", "lemmas simps[simp] = fresh_atm fresh_prod\n                     pt3[OF pt_name_inst, OF at_ds1, OF at_name_inst]\n                     pt_fresh_fresh[OF pt_name_inst, OF at_name_inst]\n                     pt_rev_pi[OF pt_name_inst, OF at_name_inst]\n                     pt_pi_rev[OF pt_name_inst, OF at_name_inst]"], ["", "lemmas name_supp_cart_prod = supp_cart_prod[OF pt_name_inst, OF pt_name_inst, OF fs_name_inst, OF fs_name_inst, OF at_name_inst]"], ["", "lemmas name_fresh_cart_prod = fresh_cart_prod[OF pt_name_inst, OF pt_name_inst, OF fs_name_inst, OF fs_name_inst, OF at_name_inst]"], ["", "lemmas name_fresh_star_cart_prod = fresh_star_cart_prod[OF pt_name_inst, OF pt_name_inst, OF fs_name_inst, OF fs_name_inst, OF at_name_inst]"], ["", "lemmas name_swap_bij[simp] = pt_swap_bij[OF pt_name_inst, OF at_name_inst]"], ["", "lemmas name_swap = pt_swap[OF pt_name_inst, OF at_name_inst]"], ["", "lemmas name_set_fresh_fresh[simp] = pt_freshs_freshs[OF pt_name_inst, OF at_name_inst]"], ["", "lemmas list_fresh[simp] = fresh_list_nil fresh_list_cons fresh_list_append"], ["", "definition  eqvt :: \"'a::fs_name set \\<Rightarrow> bool\" where\n                  \"eqvt X \\<equiv> \\<forall>x \\<in> X. \\<forall>p::name prm. p \\<bullet> x \\<in> X\""], ["", "lemma eqvtUnion[intro]:\n  fixes Rel  :: \"('d::fs_name) set\"\n  and   Rel' :: \"'d set\"\n\n  assumes EqvtRel:  \"eqvt Rel\"\n  and     EqvtRel': \"eqvt Rel'\"\n\n  shows \"eqvt (Rel \\<union> Rel')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eqvt (Rel \\<union> Rel')", "using assms"], ["proof (prove)\nusing this:\n  eqvt Rel\n  eqvt Rel'\n\ngoal (1 subgoal):\n 1. eqvt (Rel \\<union> Rel')", "by(force simp add: eqvt_def)"], ["", "lemma eqvtPerm[simp]: \n  fixes X :: \"('d::fs_name) set\"\n  and   x :: name\n  and   y :: name\n\n  assumes \"eqvt X\"\n\n  shows \"([(x, y)] \\<bullet> X) = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(x, y)] \\<bullet> X = X", "using assms"], ["proof (prove)\nusing this:\n  eqvt X\n\ngoal (1 subgoal):\n 1. [(x, y)] \\<bullet> X = X", "apply(auto simp add: eqvt_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>\\<forall>x\\<in>X. \\<forall>p. p \\<bullet> x \\<in> X;\n        xa \\<in> [(x, y)] \\<bullet> X\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> X\n 2. \\<And>xa.\n       \\<lbrakk>\\<forall>x\\<in>X. \\<forall>p. p \\<bullet> x \\<in> X;\n        xa \\<in> X\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> [(x, y)] \\<bullet> X", "apply(erule_tac x=\"[(x, y)] \\<bullet> xa\" in ballE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> [(x, y)] \\<bullet> X;\n        \\<forall>p. p \\<bullet> [(x, y)] \\<bullet> xa \\<in> X\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> X\n 2. \\<And>xa.\n       \\<lbrakk>xa \\<in> [(x, y)] \\<bullet> X;\n        [(x, y)] \\<bullet> xa \\<notin> X\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> X\n 3. \\<And>xa.\n       \\<lbrakk>\\<forall>x\\<in>X. \\<forall>p. p \\<bullet> x \\<in> X;\n        xa \\<in> X\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> [(x, y)] \\<bullet> X", "apply(erule_tac x=\"[(x, y)]\" in allE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> [(x, y)] \\<bullet> X;\n        [(x, y)] \\<bullet> [(x, y)] \\<bullet> xa \\<in> X\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> X\n 2. \\<And>xa.\n       \\<lbrakk>xa \\<in> [(x, y)] \\<bullet> X;\n        [(x, y)] \\<bullet> xa \\<notin> X\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> X\n 3. \\<And>xa.\n       \\<lbrakk>\\<forall>x\\<in>X. \\<forall>p. p \\<bullet> x \\<in> X;\n        xa \\<in> X\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> [(x, y)] \\<bullet> X", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> [(x, y)] \\<bullet> X;\n        [(x, y)] \\<bullet> xa \\<notin> X\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> X\n 2. \\<And>xa.\n       \\<lbrakk>\\<forall>x\\<in>X. \\<forall>p. p \\<bullet> x \\<in> X;\n        xa \\<in> X\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> [(x, y)] \\<bullet> X", "apply(drule_tac pi=\"[(x, y)]\" in pt_set_bij2[OF pt_name_inst, OF at_name_inst])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>[(x, y)] \\<bullet> xa \\<notin> X;\n        [(x, y)] \\<bullet> xa\n        \\<in> [(x, y)] \\<bullet> [(x, y)] \\<bullet> X\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> X\n 2. \\<And>xa.\n       \\<lbrakk>\\<forall>x\\<in>X. \\<forall>p. p \\<bullet> x \\<in> X;\n        xa \\<in> X\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> [(x, y)] \\<bullet> X", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<forall>x\\<in>X. \\<forall>p. p \\<bullet> x \\<in> X;\n        xa \\<in> X\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> [(x, y)] \\<bullet> X", "apply(erule_tac x=xa in ballE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> X; \\<forall>p. p \\<bullet> xa \\<in> X\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> [(x, y)] \\<bullet> X\n 2. \\<And>xa.\n       \\<lbrakk>xa \\<in> X; xa \\<notin> X\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> [(x, y)] \\<bullet> X", "apply(erule_tac x=\"[(x, y)]\" in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> X; [(x, y)] \\<bullet> xa \\<in> X\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> [(x, y)] \\<bullet> X\n 2. \\<And>xa.\n       \\<lbrakk>xa \\<in> X; xa \\<notin> X\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> [(x, y)] \\<bullet> X", "apply(drule_tac pi=\"[(x, y)]\" and x=\"[(x, y)] \\<bullet> xa\" in pt_set_bij2[OF pt_name_inst, OF at_name_inst])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> X;\n        [(x, y)] \\<bullet> [(x, y)] \\<bullet> xa\n        \\<in> [(x, y)] \\<bullet> X\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> [(x, y)] \\<bullet> X\n 2. \\<And>xa.\n       \\<lbrakk>xa \\<in> X; xa \\<notin> X\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> [(x, y)] \\<bullet> X", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> X; xa \\<notin> X\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> [(x, y)] \\<bullet> X", "by simp"], ["", "lemma eqvtI:\n  fixes X :: \"'d::fs_name set\"\n  and   x :: 'd\n  and   p :: \"name prm\"\n  \n  assumes \"eqvt X\"\n  and     \"x \\<in> X\"\n \n  shows \"(p \\<bullet> x) \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> x \\<in> X", "using assms"], ["proof (prove)\nusing this:\n  eqvt X\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. p \\<bullet> x \\<in> X", "by(unfold eqvt_def) auto"], ["", "lemma fresh_star_list_nil[simp]:\n  fixes xvec :: \"name list\"\n  and   Xs   :: \"name set\"\n  \n  shows \"xvec \\<sharp>* []\"\n  and   \"Xs \\<sharp>* []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xvec \\<sharp>* [] &&& Xs \\<sharp>* []", "by(auto simp add: fresh_star_def)"], ["", "lemma fresh_star_list_cons[simp]:\n  fixes xvec :: \"name list\"\n  and   Xs   :: \"name set\"\n  and   x    :: \"'a::fs_name\"\n  and   xs   :: \"'a list\"\n\n  shows \"(xvec \\<sharp>* (x#xs)) = ((xvec \\<sharp>* x) \\<and> xvec \\<sharp>* xs)\"\n  and   \"(Xs \\<sharp>* (x#xs)) = ((Xs \\<sharp>* x) \\<and> (Xs \\<sharp>* xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xvec \\<sharp>* (x # xs) =\n    (xvec \\<sharp>* x \\<and> xvec \\<sharp>* xs) &&&\n    Xs \\<sharp>* (x # xs) = (Xs \\<sharp>* x \\<and> Xs \\<sharp>* xs)", "by(auto simp add: fresh_star_def)"], ["", "lemma freshStarPair[simp]:\n  fixes X    :: \"name set\"\n  and   xvec :: \"name list\"\n  and   x    :: \"'a::fs_name\"\n  and   y    :: \"'b::fs_name\"\n\n  shows \"(X \\<sharp>* (x, y)) = (X \\<sharp>* x \\<and> X \\<sharp>* y)\"\n  and   \"(xvec \\<sharp>* (x, y)) = (xvec \\<sharp>* x \\<and> xvec \\<sharp>* y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<sharp>* (x, y) = (X \\<sharp>* x \\<and> X \\<sharp>* y) &&&\n    xvec \\<sharp>* (x, y) = (xvec \\<sharp>* x \\<and> xvec \\<sharp>* y)", "by(auto simp add: fresh_star_def)"], ["", "lemma name_list_avoiding:\n  fixes c    :: \"'a::fs_name\"\n  and   xvec :: \"name list\"\n  \n  assumes \"\\<And>pi::name prm. \\<lbrakk>(pi \\<bullet> xvec) \\<sharp>* c; distinctPerm pi; set pi \\<subseteq> (set xvec) \\<times> (set (pi \\<bullet> xvec))\\<rbrakk> \\<Longrightarrow> thesis\"\n\n  shows thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. thesis", "have \"finite(set xvec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set xvec)", "by simp"], ["proof (state)\nthis:\n  finite (set xvec)\n\ngoal (1 subgoal):\n 1. thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite (set xvec)\n\ngoal (1 subgoal):\n 1. thesis", "using assms"], ["proof (prove)\nusing this:\n  finite (set xvec)\n  \\<lbrakk>(?pi \\<bullet> xvec) \\<sharp>* c; distinctPerm ?pi;\n   set ?pi \\<subseteq> set xvec \\<times> set (?pi \\<bullet> xvec)\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by(rule name_set_avoiding) (auto simp add: eqvts fresh_star_def)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinctPermSimps[simp]:\n  fixes p :: \"name prm\"\n  and   a :: name\n  and   b :: name\n\n  shows \"distinctPerm([]::name prm)\"\n  and   \"(distinctPerm((a, b)#p)) = (distinctPerm p \\<and> a \\<noteq> b \\<and> a \\<sharp> p \\<and> b \\<sharp> p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinctPerm [] &&&\n    distinctPerm ((a, b) # p) =\n    (distinctPerm p \\<and>\n     a \\<noteq> b \\<and> a \\<sharp> p \\<and> b \\<sharp> p)", "apply(simp add: distinctPerm_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinctPerm ((a, b) # p) =\n    (distinctPerm p \\<and>\n     a \\<noteq> b \\<and> a \\<sharp> p \\<and> b \\<sharp> p)", "apply(induct p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinctPerm [(a, b)] =\n    (distinctPerm [] \\<and>\n     a \\<noteq> b \\<and> a \\<sharp> [] \\<and> b \\<sharp> [])\n 2. \\<And>aa p.\n       distinctPerm ((a, b) # p) =\n       (distinctPerm p \\<and>\n        a \\<noteq> b \\<and>\n        a \\<sharp> p \\<and> b \\<sharp> p) \\<Longrightarrow>\n       distinctPerm ((a, b) # aa # p) =\n       (distinctPerm (aa # p) \\<and>\n        a \\<noteq> b \\<and> a \\<sharp> (aa # p) \\<and> b \\<sharp> (aa # p))", "apply(unfold distinctPerm_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct (map fst [(a, b)] @ map snd [(a, b)]) =\n    (distinct (map fst [] @ map snd []) \\<and>\n     a \\<noteq> b \\<and> a \\<sharp> [] \\<and> b \\<sharp> [])\n 2. \\<And>aa p.\n       distinct (map fst ((a, b) # p) @ map snd ((a, b) # p)) =\n       (distinct (map fst p @ map snd p) \\<and>\n        a \\<noteq> b \\<and>\n        a \\<sharp> p \\<and> b \\<sharp> p) \\<Longrightarrow>\n       distinct (map fst ((a, b) # aa # p) @ map snd ((a, b) # aa # p)) =\n       (distinct (map fst (aa # p) @ map snd (aa # p)) \\<and>\n        a \\<noteq> b \\<and> a \\<sharp> (aa # p) \\<and> b \\<sharp> (aa # p))", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa p.\n       distinct (map fst ((a, b) # p) @ map snd ((a, b) # p)) =\n       (distinct (map fst p @ map snd p) \\<and>\n        a \\<noteq> b \\<and>\n        a \\<sharp> p \\<and> b \\<sharp> p) \\<Longrightarrow>\n       distinct (map fst ((a, b) # aa # p) @ map snd ((a, b) # aa # p)) =\n       (distinct (map fst (aa # p) @ map snd (aa # p)) \\<and>\n        a \\<noteq> b \\<and> a \\<sharp> (aa # p) \\<and> b \\<sharp> (aa # p))", "apply(rule iffI, erule iffE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa p.\n       \\<lbrakk>distinct\n                 (map fst ((a, b) # aa # p) @ map snd ((a, b) # aa # p));\n        distinct\n         (map fst ((a, b) # p) @ map snd ((a, b) # p)) \\<longrightarrow>\n        distinct (map fst p @ map snd p) \\<and>\n        a \\<noteq> b \\<and> a \\<sharp> p \\<and> b \\<sharp> p;\n        distinct (map fst p @ map snd p) \\<and>\n        a \\<noteq> b \\<and>\n        a \\<sharp> p \\<and> b \\<sharp> p \\<longrightarrow>\n        distinct (map fst ((a, b) # p) @ map snd ((a, b) # p))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (aa # p) @ map snd (aa # p)) \\<and>\n                         a \\<noteq> b \\<and>\n                         a \\<sharp> (aa # p) \\<and> b \\<sharp> (aa # p)\n 2. \\<And>aa p.\n       \\<lbrakk>distinct (map fst ((a, b) # p) @ map snd ((a, b) # p)) =\n                (distinct (map fst p @ map snd p) \\<and>\n                 a \\<noteq> b \\<and> a \\<sharp> p \\<and> b \\<sharp> p);\n        distinct (map fst (aa # p) @ map snd (aa # p)) \\<and>\n        a \\<noteq> b \\<and>\n        a \\<sharp> (aa # p) \\<and> b \\<sharp> (aa # p)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst ((a, b) # aa # p) @\n                           map snd ((a, b) # aa # p))", "by(clarsimp)+"], ["", "lemma map_eqvt[eqvt]:\n  fixes p   :: \"name prm\"\n  and   lst :: \"'a::pt_name list\"\n\n  shows \"(p \\<bullet> (map f lst)) = map (p \\<bullet> f) (p \\<bullet> lst)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> map f lst = map (p \\<bullet> f) (p \\<bullet> lst)", "apply(induct lst, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a lst.\n       p \\<bullet> map f lst =\n       map (p \\<bullet> f) (p \\<bullet> lst) \\<Longrightarrow>\n       p \\<bullet> f a = (p \\<bullet> f) (p \\<bullet> a)", "by(simp add: pt_fun_app_eq[OF pt_name_inst, OF at_name_inst])"], ["", "lemma consPerm:\n  fixes x :: name\n  and   y :: name\n  and   p :: \"name prm\"\n  and   C :: \"'a::pt_name\"\n\n  shows \"((x, y)#p) \\<bullet> C = [(x, y)] \\<bullet> p \\<bullet> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x, y) # p) \\<bullet> C = [(x, y)] \\<bullet> p \\<bullet> C", "by(simp add: pt2[OF pt_name_inst, THEN sym])"], ["", "simproc_setup consPerm (\"((x, y)#p) \\<bullet> C\") = \\<open>\n  fn _ => fn _ => fn ct => \n    case Thm.term_of ct of \n      Const (@{const_name perm}, _ ) $ (Const (@{const_name Cons}, _) $ _ $ p) $ _ =>\n        (case p of\n          Const (@{const_name Nil}, _) => NONE\n        | _ => SOME(mk_meta_eq @{thm consPerm}))\n    | _ => NONE\n\\<close>"], ["", "lemma distinctEqvt[eqvt]:\n  fixes p  :: \"name prm\"\n  and   xs :: \"'a::pt_name list\"\n\n  shows \"(p \\<bullet> (distinct xs)) = distinct (p \\<bullet> xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> distinct xs = distinct (p \\<bullet> xs)", "by(induct xs) (auto simp add: eqvts)"], ["", "lemma distinctClosed[simp]:\n  fixes p  :: \"name prm\"\n  and   xs :: \"'a::pt_name list\"\n\n  shows \"distinct (p \\<bullet> xs) = distinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (p \\<bullet> xs) = distinct xs", "apply(induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct (p \\<bullet> []) = distinct []\n 2. \\<And>a xs.\n       distinct (p \\<bullet> xs) = distinct xs \\<Longrightarrow>\n       distinct (p \\<bullet> (a # xs)) = distinct (a # xs)", "apply(auto simp add: eqvts)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (p \\<bullet> xs);\n        p \\<bullet> a \\<notin> set (p \\<bullet> xs); distinct xs;\n        a mem xs\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a xs.\n       \\<lbrakk>distinct (p \\<bullet> xs); a \\<notin> set xs; distinct xs;\n        p \\<bullet> a mem p \\<bullet> xs\\<rbrakk>\n       \\<Longrightarrow> False", "apply(drule_tac pi=p in pt_set_bij2[OF pt_name_inst, OF at_name_inst])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (p \\<bullet> xs);\n        p \\<bullet> a \\<notin> set (p \\<bullet> xs); distinct xs;\n        p \\<bullet> a \\<in> p \\<bullet> set xs\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a xs.\n       \\<lbrakk>distinct (p \\<bullet> xs); a \\<notin> set xs; distinct xs;\n        p \\<bullet> a mem p \\<bullet> xs\\<rbrakk>\n       \\<Longrightarrow> False", "apply(simp add: eqvts)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (p \\<bullet> xs); a \\<notin> set xs; distinct xs;\n        p \\<bullet> a mem p \\<bullet> xs\\<rbrakk>\n       \\<Longrightarrow> False", "apply(drule_tac pi=\"rev p\" in pt_set_bij2[OF pt_name_inst, OF at_name_inst])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (p \\<bullet> xs); a \\<notin> set xs; distinct xs;\n        rev p \\<bullet> p \\<bullet> a\n        \\<in> rev p \\<bullet> set (p \\<bullet> xs)\\<rbrakk>\n       \\<Longrightarrow> False", "by(simp add: eqvts)"], ["", "lemma lengthEqvt[eqvt]:\n  fixes p  :: \"name prm\"\n  and   xs :: \"'a::pt_name list\"\n  \n  shows \"p \\<bullet> (length xs) = length (p \\<bullet> xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> length xs = length (p \\<bullet> xs)", "by(induct xs) (auto simp add: eqvts)"], ["", "lemma lengthClosed[simp]:\n  fixes p  :: \"name prm\"\n  and   xs :: \"'a::pt_name list\"\n  \n  shows \"length (p \\<bullet> xs) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (p \\<bullet> xs) = length xs", "by(induct xs) (auto simp add: eqvts)"], ["", "lemma subsetEqvt[eqvt]:\n  fixes p :: \"name prm\"\n  and   S :: \"('a::pt_name) set\"\n  and   T :: \"('a::pt_name) set\"\n\n  shows \"(p \\<bullet> (S \\<subseteq> T)) = ((p \\<bullet> S) \\<subseteq> (p \\<bullet> T))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (S \\<subseteq> T) =\n    (p \\<bullet> S \\<subseteq> p \\<bullet> T)", "by(rule pt_subseteq_eqvt[OF pt_name_inst, OF at_name_inst])"], ["", "lemma subsetClosed[simp]:\n  fixes p :: \"name prm\"\n  and   S :: \"('a::pt_name) set\"\n  and   T :: \"('a::pt_name) set\"\n\n  shows \"((p \\<bullet> S) \\<subseteq> (p \\<bullet> T)) = (S \\<subseteq> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<bullet> S \\<subseteq> p \\<bullet> T) = (S \\<subseteq> T)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>p \\<bullet> S \\<subseteq> p \\<bullet> T; x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> x \\<in> T\n 2. \\<And>x.\n       \\<lbrakk>S \\<subseteq> T; x \\<in> p \\<bullet> S\\<rbrakk>\n       \\<Longrightarrow> x \\<in> p \\<bullet> T", "apply(drule_tac pi=p in pt_set_bij2[OF pt_name_inst, OF at_name_inst])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>p \\<bullet> S \\<subseteq> p \\<bullet> T;\n        p \\<bullet> x \\<in> p \\<bullet> S\\<rbrakk>\n       \\<Longrightarrow> x \\<in> T\n 2. \\<And>x.\n       \\<lbrakk>S \\<subseteq> T; x \\<in> p \\<bullet> S\\<rbrakk>\n       \\<Longrightarrow> x \\<in> p \\<bullet> T", "apply(insert pt_set_bij[OF pt_name_inst, OF at_name_inst])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>p \\<bullet> S \\<subseteq> p \\<bullet> T;\n        p \\<bullet> x \\<in> p \\<bullet> S;\n        \\<And>pi x X.\n           (pi \\<bullet> x \\<in> pi \\<bullet> X) = (x \\<in> X)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> T\n 2. \\<And>x.\n       \\<lbrakk>S \\<subseteq> T; x \\<in> p \\<bullet> S;\n        \\<And>pi x X.\n           (pi \\<bullet> x \\<in> pi \\<bullet> X) = (x \\<in> X)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> p \\<bullet> T", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>S \\<subseteq> T; x \\<in> p \\<bullet> S;\n        \\<And>pi x X.\n           (pi \\<bullet> x \\<in> pi \\<bullet> X) = (x \\<in> X)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> p \\<bullet> T", "apply(drule_tac pi=\"rev p\" in pt_set_bij2[OF pt_name_inst, OF at_name_inst])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>S \\<subseteq> T;\n        \\<And>pi x X. (pi \\<bullet> x \\<in> pi \\<bullet> X) = (x \\<in> X);\n        rev p \\<bullet> x \\<in> rev p \\<bullet> p \\<bullet> S\\<rbrakk>\n       \\<Longrightarrow> x \\<in> p \\<bullet> T", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>S \\<subseteq> T;\n        \\<And>pi x X. (pi \\<bullet> x \\<in> pi \\<bullet> X) = (x \\<in> X);\n        rev p \\<bullet> x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> x \\<in> p \\<bullet> T", "apply(subgoal_tac \"rev p \\<bullet> x \\<in> T\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>S \\<subseteq> T;\n        \\<And>pi x X. (pi \\<bullet> x \\<in> pi \\<bullet> X) = (x \\<in> X);\n        rev p \\<bullet> x \\<in> S; rev p \\<bullet> x \\<in> T\\<rbrakk>\n       \\<Longrightarrow> x \\<in> p \\<bullet> T\n 2. \\<And>x.\n       \\<lbrakk>S \\<subseteq> T;\n        \\<And>pi x X. (pi \\<bullet> x \\<in> pi \\<bullet> X) = (x \\<in> X);\n        rev p \\<bullet> x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> rev p \\<bullet> x \\<in> T", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>S \\<subseteq> T;\n        \\<And>pi x X. (pi \\<bullet> x \\<in> pi \\<bullet> X) = (x \\<in> X);\n        rev p \\<bullet> x \\<in> S; rev p \\<bullet> x \\<in> T\\<rbrakk>\n       \\<Longrightarrow> x \\<in> p \\<bullet> T", "apply(drule_tac pi=\"p\" in pt_set_bij2[OF pt_name_inst, OF at_name_inst])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>S \\<subseteq> T;\n        \\<And>pi x X. (pi \\<bullet> x \\<in> pi \\<bullet> X) = (x \\<in> X);\n        rev p \\<bullet> x \\<in> T;\n        p \\<bullet> rev p \\<bullet> x \\<in> p \\<bullet> S\\<rbrakk>\n       \\<Longrightarrow> x \\<in> p \\<bullet> T", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>S \\<subseteq> T;\n        \\<And>pi x X. (pi \\<bullet> x \\<in> pi \\<bullet> X) = (x \\<in> X);\n        rev p \\<bullet> x \\<in> T; x \\<in> p \\<bullet> S\\<rbrakk>\n       \\<Longrightarrow> x \\<in> p \\<bullet> T", "apply(drule_tac pi=\"p\" in pt_set_bij2[OF pt_name_inst, OF at_name_inst])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>S \\<subseteq> T;\n        \\<And>pi x X. (pi \\<bullet> x \\<in> pi \\<bullet> X) = (x \\<in> X);\n        x \\<in> p \\<bullet> S;\n        p \\<bullet> rev p \\<bullet> x \\<in> p \\<bullet> T\\<rbrakk>\n       \\<Longrightarrow> x \\<in> p \\<bullet> T", "by auto"], ["", "lemma subsetClosed'[simp]:\n  fixes p    :: \"name prm\"\n  and   xvec :: \"name list\"\n  and   P    :: \"'a::fs_name\"\n\n  shows \"(set (p \\<bullet> xvec) \\<subseteq> supp (p \\<bullet> P)) = (set xvec \\<subseteq> supp P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set (p \\<bullet> xvec) \\<subseteq> supp (p \\<bullet> P)) =\n    (set xvec \\<subseteq> supp P)", "by(simp add: eqvts[THEN sym])"], ["", "lemma memEqvt[eqvt]:\n  fixes p  :: \"name prm\"\n  and   x  :: \"'a::pt_name\"\n  and   xs :: \"('a::pt_name) list\"\n\n  shows \"(p \\<bullet> (x mem xs)) = ((p \\<bullet> x) mem (p \\<bullet> xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> x mem xs = p \\<bullet> x mem p \\<bullet> xs", "by(induct xs)\n  (auto simp add: pt_bij[OF pt_name_inst, OF at_name_inst] eqvts)"], ["", "lemma memClosed[simp]:\n  fixes p  :: \"name prm\"\n  and   x  :: \"'a::pt_name\"\n  and   xs :: \"('a::pt_name) list\"\n\n  shows \"(p \\<bullet> x) mem (p \\<bullet> xs) = (x mem xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> x mem p \\<bullet> xs = x mem xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<bullet> x mem p \\<bullet> xs = x mem xs", "have \"x mem xs = p \\<bullet> (x mem xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x mem xs = p \\<bullet> x mem xs", "by(case_tac \"x mem xs\") auto"], ["proof (state)\nthis:\n  x mem xs = p \\<bullet> x mem xs\n\ngoal (1 subgoal):\n 1. p \\<bullet> x mem p \\<bullet> xs = x mem xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  x mem xs = p \\<bullet> x mem xs\n\ngoal (1 subgoal):\n 1. p \\<bullet> x mem p \\<bullet> xs = x mem xs", "by(simp add: eqvts)"], ["proof (state)\nthis:\n  p \\<bullet> x mem p \\<bullet> xs = x mem xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma memClosed'[simp]:\n  fixes p  :: \"name prm\"\n  and   x  :: \"'a::pt_name\"\n  and   y  :: \"'b::pt_name\"\n  and   xs :: \"('a \\<times>  'b) list\" \n\n  shows \"((p \\<bullet> x, p \\<bullet> y) mem (p \\<bullet> xs)) = ((x, y) mem xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<bullet> x, p \\<bullet> y) mem p \\<bullet> xs = (x, y) mem xs", "apply(subgoal_tac \"((x, y) mem xs) = (p \\<bullet> (x, y)) mem (p \\<bullet> xs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. (x, y) mem xs = p \\<bullet> (x, y) mem p \\<bullet> xs \\<Longrightarrow>\n    (p \\<bullet> x, p \\<bullet> y) mem p \\<bullet> xs = (x, y) mem xs\n 2. (x, y) mem xs = p \\<bullet> (x, y) mem p \\<bullet> xs", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) mem xs = p \\<bullet> (x, y) mem p \\<bullet> xs", "by(force simp del: eqvts)"], ["", "lemma freshPerm:\n  fixes x :: name\n  and   p :: \"name prm\"\n\n  assumes \"x \\<sharp> p\"\n\n  shows \"p \\<bullet> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> x = x", "using assms"], ["proof (prove)\nusing this:\n  x \\<sharp> p\n\ngoal (1 subgoal):\n 1. p \\<bullet> x = x", "apply(rule_tac pt_pi_fresh_fresh[OF pt_name_inst, OF at_name_inst])"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> p \\<Longrightarrow>\n    \\<forall>(a, b)\\<in>set p. a \\<sharp> x \\<and> b \\<sharp> x", "by(induct p, auto simp add: fresh_list_cons fresh_prod)"], ["", "lemma freshChainPermSimp:\n  fixes xvec :: \"name list\"\n  and   p    :: \"name prm\"\n\n  assumes \"xvec \\<sharp>* p\"\n\n  shows \"p \\<bullet> xvec = xvec\"\n  and   \"rev p \\<bullet> xvec = xvec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> xvec = xvec &&& rev p \\<bullet> xvec = xvec", "using assms"], ["proof (prove)\nusing this:\n  xvec \\<sharp>* p\n\ngoal (1 subgoal):\n 1. p \\<bullet> xvec = xvec &&& rev p \\<bullet> xvec = xvec", "by(induct xvec) (auto simp add: freshPerm pt_bij1[OF pt_name_inst, OF at_name_inst, THEN sym])"], ["", "lemma freshChainAppend[simp]:\n  fixes xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   C    :: \"'a::fs_name\"\n  \n  shows \"(xvec@yvec) \\<sharp>* C = ((xvec \\<sharp>* C) \\<and> (yvec \\<sharp>* C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xvec @ yvec) \\<sharp>* C = (xvec \\<sharp>* C \\<and> yvec \\<sharp>* C)", "by(force simp add: fresh_star_def)"], ["", "lemma subsetFresh:\n  fixes xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   C    :: \"'d::fs_name\"\n\n  assumes \"set xvec \\<subseteq> set yvec\"\n  and     \"yvec \\<sharp>* C\"\n\n  shows \"xvec \\<sharp>* C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xvec \\<sharp>* C", "using assms"], ["proof (prove)\nusing this:\n  set xvec \\<subseteq> set yvec\n  yvec \\<sharp>* C\n\ngoal (1 subgoal):\n 1. xvec \\<sharp>* C", "by(auto simp add: fresh_star_def)"], ["", "lemma distinctPermCancel[simp]:\n  fixes p :: \"name prm\"\n  and   T :: \"'a::pt_name\"\n\n  assumes \"distinctPerm p\"\n\n  shows \"(p \\<bullet> (p \\<bullet> T)) = T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> p \\<bullet> T = T", "using assms"], ["proof (prove)\nusing this:\n  distinctPerm p\n\ngoal (1 subgoal):\n 1. p \\<bullet> p \\<bullet> T = T", "proof(induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. distinctPerm [] \\<Longrightarrow> [] \\<bullet> [] \\<bullet> T = T\n 2. \\<And>a p.\n       \\<lbrakk>distinctPerm p \\<Longrightarrow>\n                p \\<bullet> p \\<bullet> T = T;\n        distinctPerm (a # p)\\<rbrakk>\n       \\<Longrightarrow> (a # p) \\<bullet> (a # p) \\<bullet> T = T", "case Nil"], ["proof (state)\nthis:\n  distinctPerm []\n\ngoal (2 subgoals):\n 1. distinctPerm [] \\<Longrightarrow> [] \\<bullet> [] \\<bullet> T = T\n 2. \\<And>a p.\n       \\<lbrakk>distinctPerm p \\<Longrightarrow>\n                p \\<bullet> p \\<bullet> T = T;\n        distinctPerm (a # p)\\<rbrakk>\n       \\<Longrightarrow> (a # p) \\<bullet> (a # p) \\<bullet> T = T", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<bullet> [] \\<bullet> T = T", "by simp"], ["proof (state)\nthis:\n  [] \\<bullet> [] \\<bullet> T = T\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>distinctPerm p \\<Longrightarrow>\n                p \\<bullet> p \\<bullet> T = T;\n        distinctPerm (a # p)\\<rbrakk>\n       \\<Longrightarrow> (a # p) \\<bullet> (a # p) \\<bullet> T = T", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>distinctPerm p \\<Longrightarrow>\n                p \\<bullet> p \\<bullet> T = T;\n        distinctPerm (a # p)\\<rbrakk>\n       \\<Longrightarrow> (a # p) \\<bullet> (a # p) \\<bullet> T = T", "case(Cons a p)"], ["proof (state)\nthis:\n  distinctPerm p \\<Longrightarrow> p \\<bullet> p \\<bullet> T = T\n  distinctPerm (a # p)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>distinctPerm p \\<Longrightarrow>\n                p \\<bullet> p \\<bullet> T = T;\n        distinctPerm (a # p)\\<rbrakk>\n       \\<Longrightarrow> (a # p) \\<bullet> (a # p) \\<bullet> T = T", "thus ?case"], ["proof (prove)\nusing this:\n  distinctPerm p \\<Longrightarrow> p \\<bullet> p \\<bullet> T = T\n  distinctPerm (a # p)\n\ngoal (1 subgoal):\n 1. (a # p) \\<bullet> (a # p) \\<bullet> T = T", "proof(case_tac a, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>a = (aa, b); p \\<bullet> p \\<bullet> T = T; distinctPerm p;\n        aa \\<noteq> b; aa \\<sharp> p; b \\<sharp> p\\<rbrakk>\n       \\<Longrightarrow> [(aa, b)] \\<bullet>\n                         p \\<bullet> [(aa, b)] \\<bullet> p \\<bullet> T =\n                         T", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>a__ = (aa, b); p \\<bullet> p \\<bullet> T = T;\n        distinctPerm p; aa \\<noteq> b; aa \\<sharp> p; b \\<sharp> p\\<rbrakk>\n       \\<Longrightarrow> [(aa, b)] \\<bullet>\n                         p \\<bullet> [(aa, b)] \\<bullet> p \\<bullet> T =\n                         T", "assume \"(a::name) \\<sharp> (p::name prm)\" \"b \\<sharp> p\" \"p \\<bullet> p \\<bullet> T = T\" \"a \\<noteq> b\""], ["proof (state)\nthis:\n  a \\<sharp> p\n  b \\<sharp> p\n  p \\<bullet> p \\<bullet> T = T\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>a__ = (aa, b); p \\<bullet> p \\<bullet> T = T;\n        distinctPerm p; aa \\<noteq> b; aa \\<sharp> p; b \\<sharp> p\\<rbrakk>\n       \\<Longrightarrow> [(aa, b)] \\<bullet>\n                         p \\<bullet> [(aa, b)] \\<bullet> p \\<bullet> T =\n                         T", "thus \"[(a, b)] \\<bullet> p \\<bullet> [(a, b)] \\<bullet> p \\<bullet> T = T\""], ["proof (prove)\nusing this:\n  a \\<sharp> p\n  b \\<sharp> p\n  p \\<bullet> p \\<bullet> T = T\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. [(a, b)] \\<bullet> p \\<bullet> [(a, b)] \\<bullet> p \\<bullet> T = T", "by(subst pt_perm_compose[OF pt_name_inst, OF at_name_inst]) simp"], ["proof (state)\nthis:\n  [(a, b)] \\<bullet> p \\<bullet> [(a, b)] \\<bullet> p \\<bullet> T = T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (a # p) \\<bullet> (a # p) \\<bullet> T = T\n\ngoal:\nNo subgoals!", "qed"], ["", "fun composePerm :: \"name list \\<Rightarrow> name list \\<Rightarrow> name prm\"\nwhere\n  Base:  \"composePerm [] [] = []\"\n| Step:  \"composePerm (x#xs) (y#ys) = (x, y)#(composePerm xs ys)\"\n| Empty: \"composePerm _ _= []\""], ["", "lemma composePermInduct[consumes 1, case_names cBase cStep]:\n  fixes xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   P    :: \"name list \\<Rightarrow> name list \\<Rightarrow> bool\"\n\n  assumes L: \"length xvec = length yvec\"\n  and     rBase: \"P [] []\"\n  and     rStep: \"\\<And>x xvec y yvec. \\<lbrakk>length xvec = length yvec; P xvec yvec\\<rbrakk> \\<Longrightarrow> P (x # xvec) (y # yvec)\"\n\n  shows \"P xvec yvec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xvec yvec", "using assms"], ["proof (prove)\nusing this:\n  length xvec = length yvec\n  P [] []\n  \\<lbrakk>length ?xvec = length ?yvec; P ?xvec ?yvec\\<rbrakk>\n  \\<Longrightarrow> P (?x # ?xvec) (?y # ?yvec)\n\ngoal (1 subgoal):\n 1. P xvec yvec", "by(induct rule: composePerm.induct) auto"], ["", "lemma composePermEqvt[eqvt]:\n  fixes p    :: \"name prm\"\n  and   xvec :: \"name list\"\n  and   yvec :: \"name list\"\n\n  shows \"(p \\<bullet> (composePerm xvec yvec)) = composePerm (p \\<bullet> xvec) (p \\<bullet> yvec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> composePerm xvec yvec =\n    composePerm (p \\<bullet> xvec) (p \\<bullet> yvec)", "by(induct xvec yvec rule: composePerm.induct) auto"], ["", "abbreviation\n  composePermJudge (\"[_ _] \\<bullet>\\<^sub>v _\" [80, 80, 80] 80) where \"[xvec yvec] \\<bullet>\\<^sub>v p \\<equiv> (composePerm xvec yvec) \\<bullet> p\""], ["", "abbreviation\n  composePermInvJudge (\"[_ _]\\<^sup>- \\<bullet>\\<^sub>v _\" [80, 80, 80] 80) where \"[xvec yvec]\\<^sup>- \\<bullet>\\<^sub>v p \\<equiv> (rev (composePerm xvec yvec)) \\<bullet> p\""], ["", "lemma permChainSimps[simp]:\n  fixes xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   perm :: \"name prm\"\n  and   p    :: \"'a::pt_name\"\n\n  shows \"((composePerm xvec yvec) @ perm) \\<bullet> p = [xvec yvec] \\<bullet>\\<^sub>v (perm \\<bullet> p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (composePerm xvec yvec @ perm) \\<bullet> p =\n    [xvec yvec] \\<bullet>\\<^sub>v perm \\<bullet> p", "by(simp add: pt2[OF pt_name_inst])"], ["", "lemma permChainEqvt[eqvt]:\n  fixes p    :: \"name prm\"\n  and   xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   x    :: \"'a::pt_name\"\n\n  shows \"(p \\<bullet> ([xvec yvec] \\<bullet>\\<^sub>v x)) = [(p \\<bullet> xvec) (p \\<bullet> yvec)] \\<bullet>\\<^sub>v (p \\<bullet> x)\"\n  and   \"(p \\<bullet> ([xvec yvec]\\<^sup>- \\<bullet>\\<^sub>v x)) = [(p \\<bullet> xvec) (p \\<bullet> yvec)]\\<^sup>- \\<bullet>\\<^sub>v (p \\<bullet> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v x =\n    [p \\<bullet> xvec p \\<bullet> yvec] \\<bullet>\\<^sub>v p \\<bullet> x &&&\n    p \\<bullet> [xvec yvec]\\<^sup>- \\<bullet>\\<^sub>v x =\n    [p \\<bullet>\n     xvec p \\<bullet> yvec]\\<^sup>- \\<bullet>\\<^sub>v p \\<bullet> x", "by(subst pt_perm_compose[OF pt_name_inst, OF at_name_inst], simp add: eqvts rev_eqvt)+"], ["", "lemma permChainBij:\n  fixes xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   p    :: \"'a::pt_name\"\n  and   q    :: \"'a::pt_name\"\n\n  assumes \"length xvec = length yvec\"\n\n  shows \"(([xvec yvec] \\<bullet>\\<^sub>v p) = ([xvec yvec] \\<bullet>\\<^sub>v q)) = (p = q)\"\n  and   \"(([xvec yvec]\\<^sup>- \\<bullet>\\<^sub>v p) = ([xvec yvec]\\<^sup>- \\<bullet>\\<^sub>v q)) = (p = q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([xvec yvec] \\<bullet>\\<^sub>v p = [xvec yvec] \\<bullet>\\<^sub>v q) =\n    (p = q) &&&\n    ([xvec yvec]\\<^sup>- \\<bullet>\\<^sub>v p =\n     [xvec yvec]\\<^sup>- \\<bullet>\\<^sub>v q) =\n    (p = q)", "using assms"], ["proof (prove)\nusing this:\n  length xvec = length yvec\n\ngoal (1 subgoal):\n 1. ([xvec yvec] \\<bullet>\\<^sub>v p = [xvec yvec] \\<bullet>\\<^sub>v q) =\n    (p = q) &&&\n    ([xvec yvec]\\<^sup>- \\<bullet>\\<^sub>v p =\n     [xvec yvec]\\<^sup>- \\<bullet>\\<^sub>v q) =\n    (p = q)", "by(induct rule: composePermInduct)\n  (auto simp add: pt_bij[OF pt_name_inst, OF at_name_inst])"], ["", "lemma permChainAppend:\n  fixes xvec1 :: \"name list\"\n  and   yvec1 :: \"name list\"\n  and   xvec2 :: \"name list\"\n  and   yvec2 :: \"name list\"\n  and   p     :: \"'a::pt_name\"\n  \n  assumes \"length xvec1 = length yvec1\"\n\n  shows \"([(xvec1@xvec2) (yvec1@yvec2)] \\<bullet>\\<^sub>v p) = [xvec1 yvec1] \\<bullet>\\<^sub>v [xvec2 yvec2] \\<bullet>\\<^sub>v p\"\n  and   \"([(xvec1@xvec2) (yvec1@yvec2)]\\<^sup>- \\<bullet>\\<^sub>v p) = [xvec2 yvec2]\\<^sup>- \\<bullet>\\<^sub>v [xvec1 yvec1]\\<^sup>- \\<bullet>\\<^sub>v p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(xvec1 @ xvec2) (yvec1 @ yvec2)] \\<bullet>\\<^sub>v p =\n    [xvec1 yvec1] \\<bullet>\\<^sub>v [xvec2 yvec2] \\<bullet>\\<^sub>v p &&&\n    [(xvec1 @ xvec2) (yvec1 @ yvec2)]\\<^sup>- \\<bullet>\\<^sub>v p =\n    [xvec2 yvec2]\\<^sup>- \\<bullet>\\<^sub>v [xvec1 yvec1]\\<^sup>- \\<bullet>\\<^sub>v p", "using assms"], ["proof (prove)\nusing this:\n  length xvec1 = length yvec1\n\ngoal (1 subgoal):\n 1. [(xvec1 @ xvec2) (yvec1 @ yvec2)] \\<bullet>\\<^sub>v p =\n    [xvec1 yvec1] \\<bullet>\\<^sub>v [xvec2 yvec2] \\<bullet>\\<^sub>v p &&&\n    [(xvec1 @ xvec2) (yvec1 @ yvec2)]\\<^sup>- \\<bullet>\\<^sub>v p =\n    [xvec2 yvec2]\\<^sup>- \\<bullet>\\<^sub>v [xvec1 yvec1]\\<^sup>- \\<bullet>\\<^sub>v p", "by(induct arbitrary: p rule: composePermInduct, auto) (simp add: pt2[OF pt_name_inst])"], ["", "lemma calcChainAtom:\n  fixes xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   x    :: name\n\n  assumes \"length xvec = length yvec\"\n  and     \"x \\<sharp> xvec\"\n  and     \"x \\<sharp> yvec\"\n\n  shows \"[xvec yvec] \\<bullet>\\<^sub>v x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [xvec yvec] \\<bullet>\\<^sub>v x = x", "using assms"], ["proof (prove)\nusing this:\n  length xvec = length yvec\n  x \\<sharp> xvec\n  x \\<sharp> yvec\n\ngoal (1 subgoal):\n 1. [xvec yvec] \\<bullet>\\<^sub>v x = x", "by(induct rule: composePermInduct, auto)"], ["", "lemma calcChainAtomRev:\n  fixes xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   x    :: name\n\n  assumes \"length xvec = length yvec\"\n  and     \"x \\<sharp> xvec\"\n  and     \"x \\<sharp> yvec\"\n\n  shows \"[xvec yvec]\\<^sup>- \\<bullet>\\<^sub>v x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [xvec yvec]\\<^sup>- \\<bullet>\\<^sub>v x = x", "using assms"], ["proof (prove)\nusing this:\n  length xvec = length yvec\n  x \\<sharp> xvec\n  x \\<sharp> yvec\n\ngoal (1 subgoal):\n 1. [xvec yvec]\\<^sup>- \\<bullet>\\<^sub>v x = x", "by(induct rule: composePermInduct, auto)\n  (auto simp add: pt2[OF pt_name_inst] fresh_list_cons calc_atm)"], ["", "lemma permChainFresh[simp]:\n  fixes x    :: name\n  and   xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   p    :: \"'a::pt_name\"\n\n  assumes \"x \\<sharp> xvec\"\n  and     \"x \\<sharp> yvec\"\n  and     \"length xvec = length yvec\"\n\n  shows \"x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v p = x \\<sharp> p\"\n  and   \"x \\<sharp> [xvec yvec]\\<^sup>- \\<bullet>\\<^sub>v p = x \\<sharp> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v p = x \\<sharp> p &&&\n    x \\<sharp> [xvec yvec]\\<^sup>- \\<bullet>\\<^sub>v p = x \\<sharp> p", "using assms"], ["proof (prove)\nusing this:\n  x \\<sharp> xvec\n  x \\<sharp> yvec\n  length xvec = length yvec\n\ngoal (1 subgoal):\n 1. x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v p = x \\<sharp> p &&&\n    x \\<sharp> [xvec yvec]\\<^sup>- \\<bullet>\\<^sub>v p = x \\<sharp> p", "by(auto simp add: fresh_left calcChainAtomRev calcChainAtom)"], ["", "lemma chainFreshFresh:\n  fixes x    :: name\n  and   y    :: name\n  and   xvec :: \"name list\"\n  and   p    :: \"'a::pt_name\"\n\n  assumes \"x \\<sharp> xvec\"\n  and     \"y \\<sharp> xvec\"\n\n  shows \"xvec \\<sharp>* ([(x, y)] \\<bullet> p) = (xvec \\<sharp>* p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xvec \\<sharp>* ([(x, y)] \\<bullet> p) = xvec \\<sharp>* p", "using assms"], ["proof (prove)\nusing this:\n  x \\<sharp> xvec\n  y \\<sharp> xvec\n\ngoal (1 subgoal):\n 1. xvec \\<sharp>* ([(x, y)] \\<bullet> p) = xvec \\<sharp>* p", "by(induct xvec) (auto simp add: fresh_list_cons fresh_left)"], ["", "lemma permChainFreshFresh:\n  fixes xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   p    :: \"'a::pt_name\"\n\n  assumes \"xvec \\<sharp>* p\"\n  and     \"yvec \\<sharp>* p\"\n  and     \"length xvec = length yvec\"\n\n  shows \"[xvec yvec] \\<bullet>\\<^sub>v p = p\"\n  and   \"[xvec yvec]\\<^sup>- \\<bullet>\\<^sub>v p = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [xvec yvec] \\<bullet>\\<^sub>v p = p &&&\n    [xvec yvec]\\<^sup>- \\<bullet>\\<^sub>v p = p", "using assms"], ["proof (prove)\nusing this:\n  xvec \\<sharp>* p\n  yvec \\<sharp>* p\n  length xvec = length yvec\n\ngoal (1 subgoal):\n 1. [xvec yvec] \\<bullet>\\<^sub>v p = p &&&\n    [xvec yvec]\\<^sup>- \\<bullet>\\<^sub>v p = p", "by(induct rule: composePerm.induct, auto) (simp add: pt2[OF pt_name_inst])"], ["", "lemma setFresh[simp]:\n  fixes x    :: name\n  and   xvec :: \"name list\"\n\n  shows \"x \\<notin> set xvec = x \\<sharp> xvec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<notin> set xvec) = x \\<sharp> xvec", "by(simp add: name_list_supp fresh_def)"], ["", "lemma calcChain:\n  fixes xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  \n  assumes \"yvec \\<sharp>* xvec\"\n  and     \"length xvec = length yvec\"\n  and     \"distinct xvec\"\n  and     \"distinct yvec\"\n\n  shows \"[xvec yvec] \\<bullet>\\<^sub>v xvec = yvec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [xvec yvec] \\<bullet>\\<^sub>v xvec = yvec", "using assms"], ["proof (prove)\nusing this:\n  yvec \\<sharp>* xvec\n  length xvec = length yvec\n  distinct xvec\n  distinct yvec\n\ngoal (1 subgoal):\n 1. [xvec yvec] \\<bullet>\\<^sub>v xvec = yvec", "by(induct xvec yvec rule: composePerm.induct, auto)\n  (subst consPerm, simp add: calcChainAtom calc_atm name_list_supp fresh_def[symmetric])+"], ["", "lemma freshChainPerm:\n  fixes xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   x    :: name\n  and   C    :: \"'a::pt_name\"\n\n  assumes \"length xvec = length yvec\"\n  and     \"yvec \\<sharp>* C\"\n  and     \"xvec \\<sharp>* yvec\"\n  and     \"x mem xvec\"\n  and     \"distinct yvec\"\n\n  shows \"x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v C", "using assms"], ["proof (prove)\nusing this:\n  length xvec = length yvec\n  yvec \\<sharp>* C\n  xvec \\<sharp>* yvec\n  x mem xvec\n  distinct yvec\n\ngoal (1 subgoal):\n 1. x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v C", "proof(induct rule: composePermInduct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<sharp>* C; [] \\<sharp>* []; x mem []; distinct []\\<rbrakk>\n    \\<Longrightarrow> x \\<sharp> [[] []] \\<bullet>\\<^sub>v C\n 2. \\<And>xa xvec y yvec.\n       \\<lbrakk>length xvec = length yvec;\n        \\<lbrakk>yvec \\<sharp>* C; xvec \\<sharp>* yvec; x mem xvec;\n         distinct yvec\\<rbrakk>\n        \\<Longrightarrow> x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v C;\n        (y # yvec) \\<sharp>* C; (xa # xvec) \\<sharp>* (y # yvec);\n        x mem (xa # xvec); distinct (y # yvec)\\<rbrakk>\n       \\<Longrightarrow> x \\<sharp> [(xa #\nxvec) (y # yvec)] \\<bullet>\\<^sub>v C", "case cBase"], ["proof (state)\nthis:\n  [] \\<sharp>* C\n  [] \\<sharp>* []\n  x mem []\n  distinct []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<sharp>* C; [] \\<sharp>* []; x mem []; distinct []\\<rbrakk>\n    \\<Longrightarrow> x \\<sharp> [[] []] \\<bullet>\\<^sub>v C\n 2. \\<And>xa xvec y yvec.\n       \\<lbrakk>length xvec = length yvec;\n        \\<lbrakk>yvec \\<sharp>* C; xvec \\<sharp>* yvec; x mem xvec;\n         distinct yvec\\<rbrakk>\n        \\<Longrightarrow> x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v C;\n        (y # yvec) \\<sharp>* C; (xa # xvec) \\<sharp>* (y # yvec);\n        x mem (xa # xvec); distinct (y # yvec)\\<rbrakk>\n       \\<Longrightarrow> x \\<sharp> [(xa #\nxvec) (y # yvec)] \\<bullet>\\<^sub>v C", "have \"x mem []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x mem []", "by fact"], ["proof (state)\nthis:\n  x mem []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<sharp>* C; [] \\<sharp>* []; x mem []; distinct []\\<rbrakk>\n    \\<Longrightarrow> x \\<sharp> [[] []] \\<bullet>\\<^sub>v C\n 2. \\<And>xa xvec y yvec.\n       \\<lbrakk>length xvec = length yvec;\n        \\<lbrakk>yvec \\<sharp>* C; xvec \\<sharp>* yvec; x mem xvec;\n         distinct yvec\\<rbrakk>\n        \\<Longrightarrow> x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v C;\n        (y # yvec) \\<sharp>* C; (xa # xvec) \\<sharp>* (y # yvec);\n        x mem (xa # xvec); distinct (y # yvec)\\<rbrakk>\n       \\<Longrightarrow> x \\<sharp> [(xa #\nxvec) (y # yvec)] \\<bullet>\\<^sub>v C", "hence False"], ["proof (prove)\nusing this:\n  x mem []\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<sharp>* C; [] \\<sharp>* []; x mem []; distinct []\\<rbrakk>\n    \\<Longrightarrow> x \\<sharp> [[] []] \\<bullet>\\<^sub>v C\n 2. \\<And>xa xvec y yvec.\n       \\<lbrakk>length xvec = length yvec;\n        \\<lbrakk>yvec \\<sharp>* C; xvec \\<sharp>* yvec; x mem xvec;\n         distinct yvec\\<rbrakk>\n        \\<Longrightarrow> x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v C;\n        (y # yvec) \\<sharp>* C; (xa # xvec) \\<sharp>* (y # yvec);\n        x mem (xa # xvec); distinct (y # yvec)\\<rbrakk>\n       \\<Longrightarrow> x \\<sharp> [(xa #\nxvec) (y # yvec)] \\<bullet>\\<^sub>v C", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. x \\<sharp> [[] []] \\<bullet>\\<^sub>v C", "by simp"], ["proof (state)\nthis:\n  x \\<sharp> [[] []] \\<bullet>\\<^sub>v C\n\ngoal (1 subgoal):\n 1. \\<And>xa xvec y yvec.\n       \\<lbrakk>length xvec = length yvec;\n        \\<lbrakk>yvec \\<sharp>* C; xvec \\<sharp>* yvec; x mem xvec;\n         distinct yvec\\<rbrakk>\n        \\<Longrightarrow> x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v C;\n        (y # yvec) \\<sharp>* C; (xa # xvec) \\<sharp>* (y # yvec);\n        x mem (xa # xvec); distinct (y # yvec)\\<rbrakk>\n       \\<Longrightarrow> x \\<sharp> [(xa #\nxvec) (y # yvec)] \\<bullet>\\<^sub>v C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xvec y yvec.\n       \\<lbrakk>length xvec = length yvec;\n        \\<lbrakk>yvec \\<sharp>* C; xvec \\<sharp>* yvec; x mem xvec;\n         distinct yvec\\<rbrakk>\n        \\<Longrightarrow> x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v C;\n        (y # yvec) \\<sharp>* C; (xa # xvec) \\<sharp>* (y # yvec);\n        x mem (xa # xvec); distinct (y # yvec)\\<rbrakk>\n       \\<Longrightarrow> x \\<sharp> [(xa #\nxvec) (y # yvec)] \\<bullet>\\<^sub>v C", "case(cStep x' xvec y yvec)"], ["proof (state)\nthis:\n  length xvec = length yvec\n  \\<lbrakk>yvec \\<sharp>* C; xvec \\<sharp>* yvec; x mem xvec;\n   distinct yvec\\<rbrakk>\n  \\<Longrightarrow> x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v C\n  (y # yvec) \\<sharp>* C\n  (x' # xvec) \\<sharp>* (y # yvec)\n  x mem (x' # xvec)\n  distinct (y # yvec)\n\ngoal (1 subgoal):\n 1. \\<And>xa xvec y yvec.\n       \\<lbrakk>length xvec = length yvec;\n        \\<lbrakk>yvec \\<sharp>* C; xvec \\<sharp>* yvec; x mem xvec;\n         distinct yvec\\<rbrakk>\n        \\<Longrightarrow> x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v C;\n        (y # yvec) \\<sharp>* C; (xa # xvec) \\<sharp>* (y # yvec);\n        x mem (xa # xvec); distinct (y # yvec)\\<rbrakk>\n       \\<Longrightarrow> x \\<sharp> [(xa #\nxvec) (y # yvec)] \\<bullet>\\<^sub>v C", "have \"(y # yvec) \\<sharp>* C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y # yvec) \\<sharp>* C", "by fact"], ["proof (state)\nthis:\n  (y # yvec) \\<sharp>* C\n\ngoal (1 subgoal):\n 1. \\<And>xa xvec y yvec.\n       \\<lbrakk>length xvec = length yvec;\n        \\<lbrakk>yvec \\<sharp>* C; xvec \\<sharp>* yvec; x mem xvec;\n         distinct yvec\\<rbrakk>\n        \\<Longrightarrow> x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v C;\n        (y # yvec) \\<sharp>* C; (xa # xvec) \\<sharp>* (y # yvec);\n        x mem (xa # xvec); distinct (y # yvec)\\<rbrakk>\n       \\<Longrightarrow> x \\<sharp> [(xa #\nxvec) (y # yvec)] \\<bullet>\\<^sub>v C", "hence yFreshC: \"y \\<sharp> C\" and yvecFreshp: \"yvec \\<sharp>* C\""], ["proof (prove)\nusing this:\n  (y # yvec) \\<sharp>* C\n\ngoal (1 subgoal):\n 1. y \\<sharp> C &&& yvec \\<sharp>* C", "by simp+"], ["proof (state)\nthis:\n  y \\<sharp> C\n  yvec \\<sharp>* C\n\ngoal (1 subgoal):\n 1. \\<And>xa xvec y yvec.\n       \\<lbrakk>length xvec = length yvec;\n        \\<lbrakk>yvec \\<sharp>* C; xvec \\<sharp>* yvec; x mem xvec;\n         distinct yvec\\<rbrakk>\n        \\<Longrightarrow> x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v C;\n        (y # yvec) \\<sharp>* C; (xa # xvec) \\<sharp>* (y # yvec);\n        x mem (xa # xvec); distinct (y # yvec)\\<rbrakk>\n       \\<Longrightarrow> x \\<sharp> [(xa #\nxvec) (y # yvec)] \\<bullet>\\<^sub>v C", "have \"(x' # xvec) \\<sharp>* (y # yvec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x' # xvec) \\<sharp>* (y # yvec)", "by fact"], ["proof (state)\nthis:\n  (x' # xvec) \\<sharp>* (y # yvec)\n\ngoal (1 subgoal):\n 1. \\<And>xa xvec y yvec.\n       \\<lbrakk>length xvec = length yvec;\n        \\<lbrakk>yvec \\<sharp>* C; xvec \\<sharp>* yvec; x mem xvec;\n         distinct yvec\\<rbrakk>\n        \\<Longrightarrow> x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v C;\n        (y # yvec) \\<sharp>* C; (xa # xvec) \\<sharp>* (y # yvec);\n        x mem (xa # xvec); distinct (y # yvec)\\<rbrakk>\n       \\<Longrightarrow> x \\<sharp> [(xa #\nxvec) (y # yvec)] \\<bullet>\\<^sub>v C", "hence x'ineqy: \"x' \\<noteq> y\" and xvecFreshyvec: \"xvec \\<sharp>* yvec\"\n    and x'Freshyvec: \"x' \\<sharp> yvec\" and yFreshxvec: \"y \\<sharp> xvec\""], ["proof (prove)\nusing this:\n  (x' # xvec) \\<sharp>* (y # yvec)\n\ngoal (1 subgoal):\n 1. (x' \\<noteq> y &&& xvec \\<sharp>* yvec) &&&\n    x' \\<sharp> yvec &&& y \\<sharp> xvec", "by(auto simp add: fresh_list_cons)"], ["proof (state)\nthis:\n  x' \\<noteq> y\n  xvec \\<sharp>* yvec\n  x' \\<sharp> yvec\n  y \\<sharp> xvec\n\ngoal (1 subgoal):\n 1. \\<And>xa xvec y yvec.\n       \\<lbrakk>length xvec = length yvec;\n        \\<lbrakk>yvec \\<sharp>* C; xvec \\<sharp>* yvec; x mem xvec;\n         distinct yvec\\<rbrakk>\n        \\<Longrightarrow> x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v C;\n        (y # yvec) \\<sharp>* C; (xa # xvec) \\<sharp>* (y # yvec);\n        x mem (xa # xvec); distinct (y # yvec)\\<rbrakk>\n       \\<Longrightarrow> x \\<sharp> [(xa #\nxvec) (y # yvec)] \\<bullet>\\<^sub>v C", "have \"distinct (y#yvec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (y # yvec)", "by fact"], ["proof (state)\nthis:\n  distinct (y # yvec)\n\ngoal (1 subgoal):\n 1. \\<And>xa xvec y yvec.\n       \\<lbrakk>length xvec = length yvec;\n        \\<lbrakk>yvec \\<sharp>* C; xvec \\<sharp>* yvec; x mem xvec;\n         distinct yvec\\<rbrakk>\n        \\<Longrightarrow> x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v C;\n        (y # yvec) \\<sharp>* C; (xa # xvec) \\<sharp>* (y # yvec);\n        x mem (xa # xvec); distinct (y # yvec)\\<rbrakk>\n       \\<Longrightarrow> x \\<sharp> [(xa #\nxvec) (y # yvec)] \\<bullet>\\<^sub>v C", "hence yFreshyvec: \"y \\<sharp> yvec\" and yvecDist: \"distinct yvec\""], ["proof (prove)\nusing this:\n  distinct (y # yvec)\n\ngoal (1 subgoal):\n 1. y \\<sharp> yvec &&& distinct yvec", "by simp+"], ["proof (state)\nthis:\n  y \\<sharp> yvec\n  distinct yvec\n\ngoal (1 subgoal):\n 1. \\<And>xa xvec y yvec.\n       \\<lbrakk>length xvec = length yvec;\n        \\<lbrakk>yvec \\<sharp>* C; xvec \\<sharp>* yvec; x mem xvec;\n         distinct yvec\\<rbrakk>\n        \\<Longrightarrow> x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v C;\n        (y # yvec) \\<sharp>* C; (xa # xvec) \\<sharp>* (y # yvec);\n        x mem (xa # xvec); distinct (y # yvec)\\<rbrakk>\n       \\<Longrightarrow> x \\<sharp> [(xa #\nxvec) (y # yvec)] \\<bullet>\\<^sub>v C", "have L: \"length xvec = length yvec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xvec = length yvec", "by fact"], ["proof (state)\nthis:\n  length xvec = length yvec\n\ngoal (1 subgoal):\n 1. \\<And>xa xvec y yvec.\n       \\<lbrakk>length xvec = length yvec;\n        \\<lbrakk>yvec \\<sharp>* C; xvec \\<sharp>* yvec; x mem xvec;\n         distinct yvec\\<rbrakk>\n        \\<Longrightarrow> x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v C;\n        (y # yvec) \\<sharp>* C; (xa # xvec) \\<sharp>* (y # yvec);\n        x mem (xa # xvec); distinct (y # yvec)\\<rbrakk>\n       \\<Longrightarrow> x \\<sharp> [(xa #\nxvec) (y # yvec)] \\<bullet>\\<^sub>v C", "have \"x \\<sharp> [(x', y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> [(x', y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C", "proof(case_tac \"x = x'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = x' \\<Longrightarrow>\n    x \\<sharp> [(x', y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C\n 2. x \\<noteq> x' \\<Longrightarrow>\n    x \\<sharp> [(x', y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C", "assume xeqx': \"x = x'\""], ["proof (state)\nthis:\n  x = x'\n\ngoal (2 subgoals):\n 1. x = x' \\<Longrightarrow>\n    x \\<sharp> [(x', y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C\n 2. x \\<noteq> x' \\<Longrightarrow>\n    x \\<sharp> [(x', y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C", "moreover"], ["proof (state)\nthis:\n  x = x'\n\ngoal (2 subgoals):\n 1. x = x' \\<Longrightarrow>\n    x \\<sharp> [(x', y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C\n 2. x \\<noteq> x' \\<Longrightarrow>\n    x \\<sharp> [(x', y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C", "from yFreshxvec yFreshyvec yFreshC L"], ["proof (chain)\npicking this:\n  y \\<sharp> xvec\n  y \\<sharp> yvec\n  y \\<sharp> C\n  length xvec = length yvec", "have \"y \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v C\""], ["proof (prove)\nusing this:\n  y \\<sharp> xvec\n  y \\<sharp> yvec\n  y \\<sharp> C\n  length xvec = length yvec\n\ngoal (1 subgoal):\n 1. y \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v C", "by simp"], ["proof (state)\nthis:\n  y \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v C\n\ngoal (2 subgoals):\n 1. x = x' \\<Longrightarrow>\n    x \\<sharp> [(x', y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C\n 2. x \\<noteq> x' \\<Longrightarrow>\n    x \\<sharp> [(x', y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C", "hence \"([(x, y)] \\<bullet> y) \\<sharp> [(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C\""], ["proof (prove)\nusing this:\n  y \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v C\n\ngoal (1 subgoal):\n 1. [(x, y)] \\<bullet>\n    y \\<sharp> [(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C", "by(rule pt_fresh_bij1[OF pt_name_inst, OF at_name_inst])"], ["proof (state)\nthis:\n  [(x, y)] \\<bullet>\n  y \\<sharp> [(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C\n\ngoal (2 subgoals):\n 1. x = x' \\<Longrightarrow>\n    x \\<sharp> [(x', y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C\n 2. x \\<noteq> x' \\<Longrightarrow>\n    x \\<sharp> [(x', y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C", "with x'ineqy xeqx'"], ["proof (chain)\npicking this:\n  x' \\<noteq> y\n  x = x'\n  [(x, y)] \\<bullet>\n  y \\<sharp> [(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C", "show ?thesis"], ["proof (prove)\nusing this:\n  x' \\<noteq> y\n  x = x'\n  [(x, y)] \\<bullet>\n  y \\<sharp> [(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C\n\ngoal (1 subgoal):\n 1. x \\<sharp> [(x', y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C", "by(simp add: calc_atm)"], ["proof (state)\nthis:\n  x \\<sharp> [(x', y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C\n\ngoal (1 subgoal):\n 1. x \\<noteq> x' \\<Longrightarrow>\n    x \\<sharp> [(x', y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> x' \\<Longrightarrow>\n    x \\<sharp> [(x', y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C", "assume xineqx': \"x \\<noteq> x'\""], ["proof (state)\nthis:\n  x \\<noteq> x'\n\ngoal (1 subgoal):\n 1. x \\<noteq> x' \\<Longrightarrow>\n    x \\<sharp> [(x', y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C", "have \"x mem (x' # xvec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x mem (x' # xvec)", "by fact"], ["proof (state)\nthis:\n  x mem (x' # xvec)\n\ngoal (1 subgoal):\n 1. x \\<noteq> x' \\<Longrightarrow>\n    x \\<sharp> [(x', y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C", "with xineqx'"], ["proof (chain)\npicking this:\n  x \\<noteq> x'\n  x mem (x' # xvec)", "have xmemxvec: \"x mem xvec\""], ["proof (prove)\nusing this:\n  x \\<noteq> x'\n  x mem (x' # xvec)\n\ngoal (1 subgoal):\n 1. x mem xvec", "by simp"], ["proof (state)\nthis:\n  x mem xvec\n\ngoal (1 subgoal):\n 1. x \\<noteq> x' \\<Longrightarrow>\n    x \\<sharp> [(x', y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C", "moreover"], ["proof (state)\nthis:\n  x mem xvec\n\ngoal (1 subgoal):\n 1. x \\<noteq> x' \\<Longrightarrow>\n    x \\<sharp> [(x', y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C", "have \"\\<lbrakk>yvec \\<sharp>* C; xvec \\<sharp>* yvec; x mem xvec; distinct yvec\\<rbrakk> \\<Longrightarrow> x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>yvec \\<sharp>* C; xvec \\<sharp>* yvec; x mem xvec;\n     distinct yvec\\<rbrakk>\n    \\<Longrightarrow> x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v C", "by fact"], ["proof (state)\nthis:\n  \\<lbrakk>yvec \\<sharp>* C; xvec \\<sharp>* yvec; x mem xvec;\n   distinct yvec\\<rbrakk>\n  \\<Longrightarrow> x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v C\n\ngoal (1 subgoal):\n 1. x \\<noteq> x' \\<Longrightarrow>\n    x \\<sharp> [(x', y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C", "ultimately"], ["proof (chain)\npicking this:\n  x mem xvec\n  \\<lbrakk>yvec \\<sharp>* C; xvec \\<sharp>* yvec; x mem xvec;\n   distinct yvec\\<rbrakk>\n  \\<Longrightarrow> x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v C", "have \"x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v C\""], ["proof (prove)\nusing this:\n  x mem xvec\n  \\<lbrakk>yvec \\<sharp>* C; xvec \\<sharp>* yvec; x mem xvec;\n   distinct yvec\\<rbrakk>\n  \\<Longrightarrow> x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v C\n\ngoal (1 subgoal):\n 1. x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v C", "using yvecFreshp xvecFreshyvec yvecDist"], ["proof (prove)\nusing this:\n  x mem xvec\n  \\<lbrakk>yvec \\<sharp>* C; xvec \\<sharp>* yvec; x mem xvec;\n   distinct yvec\\<rbrakk>\n  \\<Longrightarrow> x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v C\n  yvec \\<sharp>* C\n  xvec \\<sharp>* yvec\n  distinct yvec\n\ngoal (1 subgoal):\n 1. x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v C", "by simp"], ["proof (state)\nthis:\n  x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v C\n\ngoal (1 subgoal):\n 1. x \\<noteq> x' \\<Longrightarrow>\n    x \\<sharp> [(x', y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C", "hence \"([(x', y)] \\<bullet> x) \\<sharp> [(x', y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C\""], ["proof (prove)\nusing this:\n  x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v C\n\ngoal (1 subgoal):\n 1. [(x', y)] \\<bullet>\n    x \\<sharp> [(x', y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C", "by(rule pt_fresh_bij1[OF pt_name_inst, OF at_name_inst])"], ["proof (state)\nthis:\n  [(x', y)] \\<bullet>\n  x \\<sharp> [(x', y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C\n\ngoal (1 subgoal):\n 1. x \\<noteq> x' \\<Longrightarrow>\n    x \\<sharp> [(x', y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C", "moreover"], ["proof (state)\nthis:\n  [(x', y)] \\<bullet>\n  x \\<sharp> [(x', y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C\n\ngoal (1 subgoal):\n 1. x \\<noteq> x' \\<Longrightarrow>\n    x \\<sharp> [(x', y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C", "from xmemxvec yFreshxvec"], ["proof (chain)\npicking this:\n  x mem xvec\n  y \\<sharp> xvec", "have \"x \\<noteq> y\""], ["proof (prove)\nusing this:\n  x mem xvec\n  y \\<sharp> xvec\n\ngoal (1 subgoal):\n 1. x \\<noteq> y", "by(induct xvec) (auto simp add: fresh_list_cons)"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> x' \\<Longrightarrow>\n    x \\<sharp> [(x', y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C", "ultimately"], ["proof (chain)\npicking this:\n  [(x', y)] \\<bullet>\n  x \\<sharp> [(x', y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C\n  x \\<noteq> y", "show ?thesis"], ["proof (prove)\nusing this:\n  [(x', y)] \\<bullet>\n  x \\<sharp> [(x', y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<sharp> [(x', y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C", "using xineqx' x'ineqy"], ["proof (prove)\nusing this:\n  [(x', y)] \\<bullet>\n  x \\<sharp> [(x', y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C\n  x \\<noteq> y\n  x \\<noteq> x'\n  x' \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<sharp> [(x', y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C", "by(simp add: calc_atm)"], ["proof (state)\nthis:\n  x \\<sharp> [(x', y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<sharp> [(x', y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C\n\ngoal (1 subgoal):\n 1. \\<And>xa xvec y yvec.\n       \\<lbrakk>length xvec = length yvec;\n        \\<lbrakk>yvec \\<sharp>* C; xvec \\<sharp>* yvec; x mem xvec;\n         distinct yvec\\<rbrakk>\n        \\<Longrightarrow> x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v C;\n        (y # yvec) \\<sharp>* C; (xa # xvec) \\<sharp>* (y # yvec);\n        x mem (xa # xvec); distinct (y # yvec)\\<rbrakk>\n       \\<Longrightarrow> x \\<sharp> [(xa #\nxvec) (y # yvec)] \\<bullet>\\<^sub>v C", "thus ?case"], ["proof (prove)\nusing this:\n  x \\<sharp> [(x', y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v C\n\ngoal (1 subgoal):\n 1. x \\<sharp> [(x' # xvec) (y # yvec)] \\<bullet>\\<^sub>v C", "by simp"], ["proof (state)\nthis:\n  x \\<sharp> [(x' # xvec) (y # yvec)] \\<bullet>\\<^sub>v C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma memFreshSimp[simp]:\n  fixes y    :: name\n  and   yvec :: \"name list\"\n\n  shows \"(\\<not>(y mem yvec)) = y \\<sharp> yvec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<notin> set yvec) = y \\<sharp> yvec", "by(induct yvec)\n  (auto simp add: fresh_list_nil fresh_list_cons)"], ["", "lemma freshChainPerm':\n  fixes xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   p    :: \"'a::pt_name\"\n\n  assumes \"length xvec = length yvec\"\n  and     \"yvec \\<sharp>* p\"\n  and     \"xvec \\<sharp>* yvec\"\n  and     \"distinct yvec\"\n\n  shows \"xvec \\<sharp>* ([xvec yvec] \\<bullet>\\<^sub>v p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xvec \\<sharp>* ([xvec yvec] \\<bullet>\\<^sub>v p)", "using assms"], ["proof (prove)\nusing this:\n  length xvec = length yvec\n  yvec \\<sharp>* p\n  xvec \\<sharp>* yvec\n  distinct yvec\n\ngoal (1 subgoal):\n 1. xvec \\<sharp>* ([xvec yvec] \\<bullet>\\<^sub>v p)", "proof(induct rule: composePermInduct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<sharp>* p; [] \\<sharp>* []; distinct []\\<rbrakk>\n    \\<Longrightarrow> [] \\<sharp>* ([[] []] \\<bullet>\\<^sub>v p)\n 2. \\<And>x xvec y yvec.\n       \\<lbrakk>length xvec = length yvec;\n        \\<lbrakk>yvec \\<sharp>* p; xvec \\<sharp>* yvec;\n         distinct yvec\\<rbrakk>\n        \\<Longrightarrow> xvec \\<sharp>* ([xvec yvec] \\<bullet>\\<^sub>v p);\n        (y # yvec) \\<sharp>* p; (x # xvec) \\<sharp>* (y # yvec);\n        distinct (y # yvec)\\<rbrakk>\n       \\<Longrightarrow> (x #\n                          xvec) \\<sharp>* ([(x #\n       xvec) (y # yvec)] \\<bullet>\\<^sub>v p)", "case cBase"], ["proof (state)\nthis:\n  [] \\<sharp>* p\n  [] \\<sharp>* []\n  distinct []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<sharp>* p; [] \\<sharp>* []; distinct []\\<rbrakk>\n    \\<Longrightarrow> [] \\<sharp>* ([[] []] \\<bullet>\\<^sub>v p)\n 2. \\<And>x xvec y yvec.\n       \\<lbrakk>length xvec = length yvec;\n        \\<lbrakk>yvec \\<sharp>* p; xvec \\<sharp>* yvec;\n         distinct yvec\\<rbrakk>\n        \\<Longrightarrow> xvec \\<sharp>* ([xvec yvec] \\<bullet>\\<^sub>v p);\n        (y # yvec) \\<sharp>* p; (x # xvec) \\<sharp>* (y # yvec);\n        distinct (y # yvec)\\<rbrakk>\n       \\<Longrightarrow> (x #\n                          xvec) \\<sharp>* ([(x #\n       xvec) (y # yvec)] \\<bullet>\\<^sub>v p)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<sharp>* ([[] []] \\<bullet>\\<^sub>v p)", "by simp"], ["proof (state)\nthis:\n  [] \\<sharp>* ([[] []] \\<bullet>\\<^sub>v p)\n\ngoal (1 subgoal):\n 1. \\<And>x xvec y yvec.\n       \\<lbrakk>length xvec = length yvec;\n        \\<lbrakk>yvec \\<sharp>* p; xvec \\<sharp>* yvec;\n         distinct yvec\\<rbrakk>\n        \\<Longrightarrow> xvec \\<sharp>* ([xvec yvec] \\<bullet>\\<^sub>v p);\n        (y # yvec) \\<sharp>* p; (x # xvec) \\<sharp>* (y # yvec);\n        distinct (y # yvec)\\<rbrakk>\n       \\<Longrightarrow> (x #\n                          xvec) \\<sharp>* ([(x #\n       xvec) (y # yvec)] \\<bullet>\\<^sub>v p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xvec y yvec.\n       \\<lbrakk>length xvec = length yvec;\n        \\<lbrakk>yvec \\<sharp>* p; xvec \\<sharp>* yvec;\n         distinct yvec\\<rbrakk>\n        \\<Longrightarrow> xvec \\<sharp>* ([xvec yvec] \\<bullet>\\<^sub>v p);\n        (y # yvec) \\<sharp>* p; (x # xvec) \\<sharp>* (y # yvec);\n        distinct (y # yvec)\\<rbrakk>\n       \\<Longrightarrow> (x #\n                          xvec) \\<sharp>* ([(x #\n       xvec) (y # yvec)] \\<bullet>\\<^sub>v p)", "case(cStep x xvec y yvec)"], ["proof (state)\nthis:\n  length xvec = length yvec\n  \\<lbrakk>yvec \\<sharp>* p; xvec \\<sharp>* yvec; distinct yvec\\<rbrakk>\n  \\<Longrightarrow> xvec \\<sharp>* ([xvec yvec] \\<bullet>\\<^sub>v p)\n  (y # yvec) \\<sharp>* p\n  (x # xvec) \\<sharp>* (y # yvec)\n  distinct (y # yvec)\n\ngoal (1 subgoal):\n 1. \\<And>x xvec y yvec.\n       \\<lbrakk>length xvec = length yvec;\n        \\<lbrakk>yvec \\<sharp>* p; xvec \\<sharp>* yvec;\n         distinct yvec\\<rbrakk>\n        \\<Longrightarrow> xvec \\<sharp>* ([xvec yvec] \\<bullet>\\<^sub>v p);\n        (y # yvec) \\<sharp>* p; (x # xvec) \\<sharp>* (y # yvec);\n        distinct (y # yvec)\\<rbrakk>\n       \\<Longrightarrow> (x #\n                          xvec) \\<sharp>* ([(x #\n       xvec) (y # yvec)] \\<bullet>\\<^sub>v p)", "have \"(y # yvec) \\<sharp>* p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y # yvec) \\<sharp>* p", "by fact"], ["proof (state)\nthis:\n  (y # yvec) \\<sharp>* p\n\ngoal (1 subgoal):\n 1. \\<And>x xvec y yvec.\n       \\<lbrakk>length xvec = length yvec;\n        \\<lbrakk>yvec \\<sharp>* p; xvec \\<sharp>* yvec;\n         distinct yvec\\<rbrakk>\n        \\<Longrightarrow> xvec \\<sharp>* ([xvec yvec] \\<bullet>\\<^sub>v p);\n        (y # yvec) \\<sharp>* p; (x # xvec) \\<sharp>* (y # yvec);\n        distinct (y # yvec)\\<rbrakk>\n       \\<Longrightarrow> (x #\n                          xvec) \\<sharp>* ([(x #\n       xvec) (y # yvec)] \\<bullet>\\<^sub>v p)", "hence yFreshp: \"y \\<sharp> p\" and yvecFreshp: \"yvec \\<sharp>* p\""], ["proof (prove)\nusing this:\n  (y # yvec) \\<sharp>* p\n\ngoal (1 subgoal):\n 1. y \\<sharp> p &&& yvec \\<sharp>* p", "by simp+"], ["proof (state)\nthis:\n  y \\<sharp> p\n  yvec \\<sharp>* p\n\ngoal (1 subgoal):\n 1. \\<And>x xvec y yvec.\n       \\<lbrakk>length xvec = length yvec;\n        \\<lbrakk>yvec \\<sharp>* p; xvec \\<sharp>* yvec;\n         distinct yvec\\<rbrakk>\n        \\<Longrightarrow> xvec \\<sharp>* ([xvec yvec] \\<bullet>\\<^sub>v p);\n        (y # yvec) \\<sharp>* p; (x # xvec) \\<sharp>* (y # yvec);\n        distinct (y # yvec)\\<rbrakk>\n       \\<Longrightarrow> (x #\n                          xvec) \\<sharp>* ([(x #\n       xvec) (y # yvec)] \\<bullet>\\<^sub>v p)", "moreover"], ["proof (state)\nthis:\n  y \\<sharp> p\n  yvec \\<sharp>* p\n\ngoal (1 subgoal):\n 1. \\<And>x xvec y yvec.\n       \\<lbrakk>length xvec = length yvec;\n        \\<lbrakk>yvec \\<sharp>* p; xvec \\<sharp>* yvec;\n         distinct yvec\\<rbrakk>\n        \\<Longrightarrow> xvec \\<sharp>* ([xvec yvec] \\<bullet>\\<^sub>v p);\n        (y # yvec) \\<sharp>* p; (x # xvec) \\<sharp>* (y # yvec);\n        distinct (y # yvec)\\<rbrakk>\n       \\<Longrightarrow> (x #\n                          xvec) \\<sharp>* ([(x #\n       xvec) (y # yvec)] \\<bullet>\\<^sub>v p)", "have \"(x # xvec) \\<sharp>* (y # yvec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x # xvec) \\<sharp>* (y # yvec)", "by fact"], ["proof (state)\nthis:\n  (x # xvec) \\<sharp>* (y # yvec)\n\ngoal (1 subgoal):\n 1. \\<And>x xvec y yvec.\n       \\<lbrakk>length xvec = length yvec;\n        \\<lbrakk>yvec \\<sharp>* p; xvec \\<sharp>* yvec;\n         distinct yvec\\<rbrakk>\n        \\<Longrightarrow> xvec \\<sharp>* ([xvec yvec] \\<bullet>\\<^sub>v p);\n        (y # yvec) \\<sharp>* p; (x # xvec) \\<sharp>* (y # yvec);\n        distinct (y # yvec)\\<rbrakk>\n       \\<Longrightarrow> (x #\n                          xvec) \\<sharp>* ([(x #\n       xvec) (y # yvec)] \\<bullet>\\<^sub>v p)", "hence xineqy: \"x \\<noteq> y\" and xvecFreshyvec: \"xvec \\<sharp>* yvec\"\n    and xFreshyvec: \"x \\<sharp> yvec\" and yFreshxvec: \"y \\<sharp> xvec\""], ["proof (prove)\nusing this:\n  (x # xvec) \\<sharp>* (y # yvec)\n\ngoal (1 subgoal):\n 1. (x \\<noteq> y &&& xvec \\<sharp>* yvec) &&&\n    x \\<sharp> yvec &&& y \\<sharp> xvec", "by(auto simp add: fresh_list_cons)"], ["proof (state)\nthis:\n  x \\<noteq> y\n  xvec \\<sharp>* yvec\n  x \\<sharp> yvec\n  y \\<sharp> xvec\n\ngoal (1 subgoal):\n 1. \\<And>x xvec y yvec.\n       \\<lbrakk>length xvec = length yvec;\n        \\<lbrakk>yvec \\<sharp>* p; xvec \\<sharp>* yvec;\n         distinct yvec\\<rbrakk>\n        \\<Longrightarrow> xvec \\<sharp>* ([xvec yvec] \\<bullet>\\<^sub>v p);\n        (y # yvec) \\<sharp>* p; (x # xvec) \\<sharp>* (y # yvec);\n        distinct (y # yvec)\\<rbrakk>\n       \\<Longrightarrow> (x #\n                          xvec) \\<sharp>* ([(x #\n       xvec) (y # yvec)] \\<bullet>\\<^sub>v p)", "have \"distinct (y # yvec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (y # yvec)", "by fact"], ["proof (state)\nthis:\n  distinct (y # yvec)\n\ngoal (1 subgoal):\n 1. \\<And>x xvec y yvec.\n       \\<lbrakk>length xvec = length yvec;\n        \\<lbrakk>yvec \\<sharp>* p; xvec \\<sharp>* yvec;\n         distinct yvec\\<rbrakk>\n        \\<Longrightarrow> xvec \\<sharp>* ([xvec yvec] \\<bullet>\\<^sub>v p);\n        (y # yvec) \\<sharp>* p; (x # xvec) \\<sharp>* (y # yvec);\n        distinct (y # yvec)\\<rbrakk>\n       \\<Longrightarrow> (x #\n                          xvec) \\<sharp>* ([(x #\n       xvec) (y # yvec)] \\<bullet>\\<^sub>v p)", "hence yFreshyvec: \"y \\<sharp> yvec\" and yvecDist: \"distinct yvec\""], ["proof (prove)\nusing this:\n  distinct (y # yvec)\n\ngoal (1 subgoal):\n 1. y \\<sharp> yvec &&& distinct yvec", "by simp+"], ["proof (state)\nthis:\n  y \\<sharp> yvec\n  distinct yvec\n\ngoal (1 subgoal):\n 1. \\<And>x xvec y yvec.\n       \\<lbrakk>length xvec = length yvec;\n        \\<lbrakk>yvec \\<sharp>* p; xvec \\<sharp>* yvec;\n         distinct yvec\\<rbrakk>\n        \\<Longrightarrow> xvec \\<sharp>* ([xvec yvec] \\<bullet>\\<^sub>v p);\n        (y # yvec) \\<sharp>* p; (x # xvec) \\<sharp>* (y # yvec);\n        distinct (y # yvec)\\<rbrakk>\n       \\<Longrightarrow> (x #\n                          xvec) \\<sharp>* ([(x #\n       xvec) (y # yvec)] \\<bullet>\\<^sub>v p)", "have L: \"length xvec = length yvec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xvec = length yvec", "by fact"], ["proof (state)\nthis:\n  length xvec = length yvec\n\ngoal (1 subgoal):\n 1. \\<And>x xvec y yvec.\n       \\<lbrakk>length xvec = length yvec;\n        \\<lbrakk>yvec \\<sharp>* p; xvec \\<sharp>* yvec;\n         distinct yvec\\<rbrakk>\n        \\<Longrightarrow> xvec \\<sharp>* ([xvec yvec] \\<bullet>\\<^sub>v p);\n        (y # yvec) \\<sharp>* p; (x # xvec) \\<sharp>* (y # yvec);\n        distinct (y # yvec)\\<rbrakk>\n       \\<Longrightarrow> (x #\n                          xvec) \\<sharp>* ([(x #\n       xvec) (y # yvec)] \\<bullet>\\<^sub>v p)", "have \"\\<lbrakk>yvec \\<sharp>* p; xvec \\<sharp>* yvec; distinct yvec\\<rbrakk> \\<Longrightarrow> xvec \\<sharp>* ([xvec yvec] \\<bullet>\\<^sub>v p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>yvec \\<sharp>* p; xvec \\<sharp>* yvec; distinct yvec\\<rbrakk>\n    \\<Longrightarrow> xvec \\<sharp>* ([xvec yvec] \\<bullet>\\<^sub>v p)", "by fact"], ["proof (state)\nthis:\n  \\<lbrakk>yvec \\<sharp>* p; xvec \\<sharp>* yvec; distinct yvec\\<rbrakk>\n  \\<Longrightarrow> xvec \\<sharp>* ([xvec yvec] \\<bullet>\\<^sub>v p)\n\ngoal (1 subgoal):\n 1. \\<And>x xvec y yvec.\n       \\<lbrakk>length xvec = length yvec;\n        \\<lbrakk>yvec \\<sharp>* p; xvec \\<sharp>* yvec;\n         distinct yvec\\<rbrakk>\n        \\<Longrightarrow> xvec \\<sharp>* ([xvec yvec] \\<bullet>\\<^sub>v p);\n        (y # yvec) \\<sharp>* p; (x # xvec) \\<sharp>* (y # yvec);\n        distinct (y # yvec)\\<rbrakk>\n       \\<Longrightarrow> (x #\n                          xvec) \\<sharp>* ([(x #\n       xvec) (y # yvec)] \\<bullet>\\<^sub>v p)", "with yvecFreshp xvecFreshyvec yvecDist"], ["proof (chain)\npicking this:\n  yvec \\<sharp>* p\n  xvec \\<sharp>* yvec\n  distinct yvec\n  \\<lbrakk>yvec \\<sharp>* p; xvec \\<sharp>* yvec; distinct yvec\\<rbrakk>\n  \\<Longrightarrow> xvec \\<sharp>* ([xvec yvec] \\<bullet>\\<^sub>v p)", "have IH: \"xvec \\<sharp>* ([xvec yvec] \\<bullet>\\<^sub>v p)\""], ["proof (prove)\nusing this:\n  yvec \\<sharp>* p\n  xvec \\<sharp>* yvec\n  distinct yvec\n  \\<lbrakk>yvec \\<sharp>* p; xvec \\<sharp>* yvec; distinct yvec\\<rbrakk>\n  \\<Longrightarrow> xvec \\<sharp>* ([xvec yvec] \\<bullet>\\<^sub>v p)\n\ngoal (1 subgoal):\n 1. xvec \\<sharp>* ([xvec yvec] \\<bullet>\\<^sub>v p)", "by simp"], ["proof (state)\nthis:\n  xvec \\<sharp>* ([xvec yvec] \\<bullet>\\<^sub>v p)\n\ngoal (1 subgoal):\n 1. \\<And>x xvec y yvec.\n       \\<lbrakk>length xvec = length yvec;\n        \\<lbrakk>yvec \\<sharp>* p; xvec \\<sharp>* yvec;\n         distinct yvec\\<rbrakk>\n        \\<Longrightarrow> xvec \\<sharp>* ([xvec yvec] \\<bullet>\\<^sub>v p);\n        (y # yvec) \\<sharp>* p; (x # xvec) \\<sharp>* (y # yvec);\n        distinct (y # yvec)\\<rbrakk>\n       \\<Longrightarrow> (x #\n                          xvec) \\<sharp>* ([(x #\n       xvec) (y # yvec)] \\<bullet>\\<^sub>v p)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x # xvec) \\<sharp>* ([(x # xvec) (y # yvec)] \\<bullet>\\<^sub>v p)", "proof(auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<sharp> [(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p\n 2. xvec \\<sharp>* ([(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p)", "from L yFreshp yvecFreshp xineqy xvecFreshyvec yvecDist yFreshyvec yFreshxvec xFreshyvec"], ["proof (chain)\npicking this:\n  length xvec = length yvec\n  y \\<sharp> p\n  yvec \\<sharp>* p\n  x \\<noteq> y\n  xvec \\<sharp>* yvec\n  distinct yvec\n  y \\<sharp> yvec\n  y \\<sharp> xvec\n  x \\<sharp> yvec", "have \"x \\<sharp> [(x # xvec) (y # yvec)] \\<bullet>\\<^sub>v p\""], ["proof (prove)\nusing this:\n  length xvec = length yvec\n  y \\<sharp> p\n  yvec \\<sharp>* p\n  x \\<noteq> y\n  xvec \\<sharp>* yvec\n  distinct yvec\n  y \\<sharp> yvec\n  y \\<sharp> xvec\n  x \\<sharp> yvec\n\ngoal (1 subgoal):\n 1. x \\<sharp> [(x # xvec) (y # yvec)] \\<bullet>\\<^sub>v p", "by(rule_tac freshChainPerm) (auto simp add: fresh_list_cons)"], ["proof (state)\nthis:\n  x \\<sharp> [(x # xvec) (y # yvec)] \\<bullet>\\<^sub>v p\n\ngoal (2 subgoals):\n 1. x \\<sharp> [(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p\n 2. xvec \\<sharp>* ([(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p)", "thus \"x \\<sharp> [(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p\""], ["proof (prove)\nusing this:\n  x \\<sharp> [(x # xvec) (y # yvec)] \\<bullet>\\<^sub>v p\n\ngoal (1 subgoal):\n 1. x \\<sharp> [(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p", "by simp"], ["proof (state)\nthis:\n  x \\<sharp> [(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p\n\ngoal (1 subgoal):\n 1. xvec \\<sharp>* ([(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xvec \\<sharp>* ([(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p)", "show \"xvec \\<sharp>* ([(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xvec \\<sharp>* ([(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p)", "proof(case_tac \"x mem xvec\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x mem xvec \\<Longrightarrow>\n    xvec \\<sharp>* ([(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p)\n 2. x \\<notin> set xvec \\<Longrightarrow>\n    xvec \\<sharp>* ([(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p)", "assume \"x mem xvec\""], ["proof (state)\nthis:\n  x mem xvec\n\ngoal (2 subgoals):\n 1. x mem xvec \\<Longrightarrow>\n    xvec \\<sharp>* ([(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p)\n 2. x \\<notin> set xvec \\<Longrightarrow>\n    xvec \\<sharp>* ([(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p)", "with L yvecFreshp xvecFreshyvec yvecDist xFreshyvec"], ["proof (chain)\npicking this:\n  length xvec = length yvec\n  yvec \\<sharp>* p\n  xvec \\<sharp>* yvec\n  distinct yvec\n  x \\<sharp> yvec\n  x mem xvec", "have\"x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v p\""], ["proof (prove)\nusing this:\n  length xvec = length yvec\n  yvec \\<sharp>* p\n  xvec \\<sharp>* yvec\n  distinct yvec\n  x \\<sharp> yvec\n  x mem xvec\n\ngoal (1 subgoal):\n 1. x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v p", "by(rule_tac freshChainPerm) (auto simp add: fresh_list_cons)"], ["proof (state)\nthis:\n  x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v p\n\ngoal (2 subgoals):\n 1. x mem xvec \\<Longrightarrow>\n    xvec \\<sharp>* ([(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p)\n 2. x \\<notin> set xvec \\<Longrightarrow>\n    xvec \\<sharp>* ([(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p)", "moreover"], ["proof (state)\nthis:\n  x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v p\n\ngoal (2 subgoals):\n 1. x mem xvec \\<Longrightarrow>\n    xvec \\<sharp>* ([(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p)\n 2. x \\<notin> set xvec \\<Longrightarrow>\n    xvec \\<sharp>* ([(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p)", "from yFreshxvec yFreshyvec yFreshp L"], ["proof (chain)\npicking this:\n  y \\<sharp> xvec\n  y \\<sharp> yvec\n  y \\<sharp> p\n  length xvec = length yvec", "have \"y \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v p\""], ["proof (prove)\nusing this:\n  y \\<sharp> xvec\n  y \\<sharp> yvec\n  y \\<sharp> p\n  length xvec = length yvec\n\ngoal (1 subgoal):\n 1. y \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v p", "by simp"], ["proof (state)\nthis:\n  y \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v p\n\ngoal (2 subgoals):\n 1. x mem xvec \\<Longrightarrow>\n    xvec \\<sharp>* ([(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p)\n 2. x \\<notin> set xvec \\<Longrightarrow>\n    xvec \\<sharp>* ([(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p)", "ultimately"], ["proof (chain)\npicking this:\n  x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v p\n  y \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v p", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v p\n  y \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v p\n\ngoal (1 subgoal):\n 1. xvec \\<sharp>* ([(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p)", "using IH"], ["proof (prove)\nusing this:\n  x \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v p\n  y \\<sharp> [xvec yvec] \\<bullet>\\<^sub>v p\n  xvec \\<sharp>* ([xvec yvec] \\<bullet>\\<^sub>v p)\n\ngoal (1 subgoal):\n 1. xvec \\<sharp>* ([(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p)", "by(subst consPerm) (simp add: perm_fresh_fresh)"], ["proof (state)\nthis:\n  xvec \\<sharp>* ([(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p)\n\ngoal (1 subgoal):\n 1. x \\<notin> set xvec \\<Longrightarrow>\n    xvec \\<sharp>* ([(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> set xvec \\<Longrightarrow>\n    xvec \\<sharp>* ([(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p)", "assume \"\\<not>(x mem xvec)\""], ["proof (state)\nthis:\n  x \\<notin> set xvec\n\ngoal (1 subgoal):\n 1. x \\<notin> set xvec \\<Longrightarrow>\n    xvec \\<sharp>* ([(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p)", "hence xFreshxvec: \"x \\<sharp> xvec\""], ["proof (prove)\nusing this:\n  x \\<notin> set xvec\n\ngoal (1 subgoal):\n 1. x \\<sharp> xvec", "by simp"], ["proof (state)\nthis:\n  x \\<sharp> xvec\n\ngoal (1 subgoal):\n 1. x \\<notin> set xvec \\<Longrightarrow>\n    xvec \\<sharp>* ([(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p)", "from IH"], ["proof (chain)\npicking this:\n  xvec \\<sharp>* ([xvec yvec] \\<bullet>\\<^sub>v p)", "have \"([(x, y)] \\<bullet> xvec) \\<sharp>* ([(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p)\""], ["proof (prove)\nusing this:\n  xvec \\<sharp>* ([xvec yvec] \\<bullet>\\<^sub>v p)\n\ngoal (1 subgoal):\n 1. ([(x, y)] \\<bullet>\n     xvec) \\<sharp>* ([(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p)", "by(simp add: pt_fresh_star_bij[OF pt_name_inst, OF at_name_inst])"], ["proof (state)\nthis:\n  ([(x, y)] \\<bullet>\n   xvec) \\<sharp>* ([(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p)\n\ngoal (1 subgoal):\n 1. x \\<notin> set xvec \\<Longrightarrow>\n    xvec \\<sharp>* ([(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p)", "with xFreshxvec yFreshxvec"], ["proof (chain)\npicking this:\n  x \\<sharp> xvec\n  y \\<sharp> xvec\n  ([(x, y)] \\<bullet>\n   xvec) \\<sharp>* ([(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p)", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<sharp> xvec\n  y \\<sharp> xvec\n  ([(x, y)] \\<bullet>\n   xvec) \\<sharp>* ([(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p)\n\ngoal (1 subgoal):\n 1. xvec \\<sharp>* ([(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p)", "by simp"], ["proof (state)\nthis:\n  xvec \\<sharp>* ([(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xvec \\<sharp>* ([(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x # xvec) \\<sharp>* ([(x # xvec) (y # yvec)] \\<bullet>\\<^sub>v p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma permSym:\n  fixes x    :: name\n  and   y    :: name\n  and   xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   p    :: \"'a::pt_name\"\n  \n  assumes \"x \\<sharp> xvec\"\n  and     \"x \\<sharp> yvec\"\n  and     \"y \\<sharp> xvec\"\n  and     \"y \\<sharp> yvec\"\n  and     \"length xvec = length yvec\"\n\n  shows \"([(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p) = [xvec yvec] \\<bullet>\\<^sub>v [(x, y)] \\<bullet> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p =\n    [xvec yvec] \\<bullet>\\<^sub>v [(x, y)] \\<bullet> p", "using assms"], ["proof (prove)\nusing this:\n  x \\<sharp> xvec\n  x \\<sharp> yvec\n  y \\<sharp> xvec\n  y \\<sharp> yvec\n  length xvec = length yvec\n\ngoal (1 subgoal):\n 1. [(x, y)] \\<bullet> [xvec yvec] \\<bullet>\\<^sub>v p =\n    [xvec yvec] \\<bullet>\\<^sub>v [(x, y)] \\<bullet> p", "apply(induct rule: composePerm.induct, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xs ya ys.\n       \\<lbrakk>[(x, y)] \\<bullet> [xs ys] \\<bullet>\\<^sub>v p =\n                [xs ys] \\<bullet>\\<^sub>v [(x, y)] \\<bullet> p;\n        length xs = length ys; x \\<sharp> xvec; x \\<sharp> yvec;\n        y \\<sharp> xvec; y \\<sharp> yvec; length xvec = length yvec;\n        x \\<noteq> xa; x \\<sharp> xs; x \\<noteq> ya; x \\<sharp> ys;\n        y \\<noteq> xa; y \\<sharp> xs; y \\<noteq> ya; y \\<sharp> ys\\<rbrakk>\n       \\<Longrightarrow> [(x, y)] \\<bullet>\n                         [(xa, ya)] \\<bullet> [xs ys] \\<bullet>\\<^sub>v p =\n                         [(xa, ya)] \\<bullet>\n                         [xs ys] \\<bullet>\\<^sub>v [(x, y)] \\<bullet> p", "by(subst pt_perm_compose[OF pt_name_inst, OF at_name_inst]) simp"], ["", "lemma distinctPermClosed[simp]:\n  fixes p :: \"name prm\"\n  and   q :: \"name prm\"\n\n  assumes \"distinctPerm p\"\n\n  shows \"distinctPerm(q \\<bullet> p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinctPerm (q \\<bullet> p)", "using assms"], ["proof (prove)\nusing this:\n  distinctPerm p\n\ngoal (1 subgoal):\n 1. distinctPerm (q \\<bullet> p)", "by(induct p) (auto simp add: pt_fresh_bij[OF pt_name_inst, OF at_name_inst] dest: pt_bij4[OF pt_name_inst, OF at_name_inst])"], ["", "lemma freshStarSimps:\n  fixes x  :: name\n  and   Xs :: \"name set\"\n  and   Ys :: \"name set\"\n  and   C  :: \"'a::fs_name\"\n  and   p  :: \"name prm\"\n  \n  assumes \"set p \\<subseteq> Xs \\<times> Ys\"\n  and     \"Xs \\<sharp>* x\"\n  and     \"Ys \\<sharp>* x\"\n\n  shows \"x \\<sharp> (p \\<bullet> C) = x \\<sharp> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> p \\<bullet> C = x \\<sharp> C", "using assms"], ["proof (prove)\nusing this:\n  set p \\<subseteq> Xs \\<times> Ys\n  Xs \\<sharp>* x\n  Ys \\<sharp>* x\n\ngoal (1 subgoal):\n 1. x \\<sharp> p \\<bullet> C = x \\<sharp> C", "by(subst  pt_fresh_bij[OF pt_name_inst, OF at_name_inst, symmetric, of _ C p]) simp"], ["", "lemma freshStarChainSimps:\n  fixes xvec :: \"name list\"\n  and   Xs   :: \"name set\"\n  and   Ys   :: \"name set\"\n  and   C    :: \"'a::fs_name\"\n  and   p    :: \"name prm\"\n\n  assumes \"set p \\<subseteq> Xs \\<times> Ys\"\n  and     \"Xs \\<sharp>* xvec\"\n  and     \"Ys \\<sharp>* xvec\"\n\n  shows   \"xvec \\<sharp>* (p \\<bullet> C) = xvec \\<sharp>* C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xvec \\<sharp>* (p \\<bullet> C) = xvec \\<sharp>* C", "using assms"], ["proof (prove)\nusing this:\n  set p \\<subseteq> Xs \\<times> Ys\n  Xs \\<sharp>* xvec\n  Ys \\<sharp>* xvec\n\ngoal (1 subgoal):\n 1. xvec \\<sharp>* (p \\<bullet> C) = xvec \\<sharp>* C", "by(induct xvec) (auto simp add: freshStarSimps)"], ["", "lemma permStarFresh:\n  fixes xvec :: \"name list\"\n  and   p    :: \"name prm\"\n  and   T    :: \"'a::pt_name\"\n\n  assumes \"xvec \\<sharp>* p\"\n\n  shows \"xvec \\<sharp>* (p \\<bullet> T) = xvec \\<sharp>* T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xvec \\<sharp>* (p \\<bullet> T) = xvec \\<sharp>* T", "using assms"], ["proof (prove)\nusing this:\n  xvec \\<sharp>* p\n\ngoal (1 subgoal):\n 1. xvec \\<sharp>* (p \\<bullet> T) = xvec \\<sharp>* T", "by(induct p) (auto simp add: chainFreshFresh)"], ["", "lemma swapStarFresh:\n  fixes x :: name\n  and   p :: \"name prm\"\n  and   T :: \"'a::pt_name\"\n\n  assumes \"x \\<sharp> p\"\n\n  shows \"x \\<sharp> (p \\<bullet> T) = x \\<sharp> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> p \\<bullet> T = x \\<sharp> T", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<sharp> p \\<bullet> T = x \\<sharp> T", "from assms"], ["proof (chain)\npicking this:\n  x \\<sharp> p", "have \"[x] \\<sharp>* (p \\<bullet> T) = [x] \\<sharp>* T\""], ["proof (prove)\nusing this:\n  x \\<sharp> p\n\ngoal (1 subgoal):\n 1. [x] \\<sharp>* (p \\<bullet> T) = [x] \\<sharp>* T", "by(rule_tac permStarFresh) auto"], ["proof (state)\nthis:\n  [x] \\<sharp>* (p \\<bullet> T) = [x] \\<sharp>* T\n\ngoal (1 subgoal):\n 1. x \\<sharp> p \\<bullet> T = x \\<sharp> T", "thus ?thesis"], ["proof (prove)\nusing this:\n  [x] \\<sharp>* (p \\<bullet> T) = [x] \\<sharp>* T\n\ngoal (1 subgoal):\n 1. x \\<sharp> p \\<bullet> T = x \\<sharp> T", "by simp"], ["proof (state)\nthis:\n  x \\<sharp> p \\<bullet> T = x \\<sharp> T\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas freshChainSimps = freshStarSimps freshStarChainSimps permStarFresh swapStarFresh chainFreshFresh freshPerm subsetFresh"], ["", "lemma freshAlphaPerm:\n  fixes xvec :: \"name list\"\n  and   Xs   :: \"name set\"\n  and   Ys   :: \"name set\"\n  and   p    :: \"name prm\"\n\n  assumes S: \"set p \\<subseteq> Xs \\<times> Ys\"\n  and     \"Xs \\<sharp>* xvec\"\n  and     \"Ys \\<sharp>* xvec\"\n\n  shows \"xvec \\<sharp>* p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xvec \\<sharp>* p", "using assms"], ["proof (prove)\nusing this:\n  set p \\<subseteq> Xs \\<times> Ys\n  Xs \\<sharp>* xvec\n  Ys \\<sharp>* xvec\n\ngoal (1 subgoal):\n 1. xvec \\<sharp>* p", "apply(induct p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>set [] \\<subseteq> Xs \\<times> Ys; Xs \\<sharp>* xvec;\n     Ys \\<sharp>* xvec\\<rbrakk>\n    \\<Longrightarrow> xvec \\<sharp>* []\n 2. \\<And>a p.\n       \\<lbrakk>\\<lbrakk>set p \\<subseteq> Xs \\<times> Ys;\n                 Xs \\<sharp>* xvec; Ys \\<sharp>* xvec\\<rbrakk>\n                \\<Longrightarrow> xvec \\<sharp>* p;\n        set (a # p) \\<subseteq> Xs \\<times> Ys; Xs \\<sharp>* xvec;\n        Ys \\<sharp>* xvec\\<rbrakk>\n       \\<Longrightarrow> xvec \\<sharp>* (a # p)", "by auto (simp add: fresh_star_def fresh_def name_list_supp supp_list_nil)+"], ["", "lemma freshAlphaSwap:\n  fixes x  :: name\n  and   Xs :: \"name set\"\n  and   Ys :: \"name set\"\n  and   p  :: \"name prm\"\n\n  assumes S: \"set p \\<subseteq> Xs \\<times> Ys\"\n  and     \"Xs \\<sharp>* x\"\n  and     \"Ys \\<sharp>* x\"\n\n  shows \"x \\<sharp> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<sharp> p", "from assms"], ["proof (chain)\npicking this:\n  set p \\<subseteq> Xs \\<times> Ys\n  Xs \\<sharp>* x\n  Ys \\<sharp>* x", "have \"[x] \\<sharp>* p\""], ["proof (prove)\nusing this:\n  set p \\<subseteq> Xs \\<times> Ys\n  Xs \\<sharp>* x\n  Ys \\<sharp>* x\n\ngoal (1 subgoal):\n 1. [x] \\<sharp>* p", "apply(rule_tac freshAlphaPerm)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>set p \\<subseteq> Xs \\<times> Ys; Xs \\<sharp>* x;\n     Ys \\<sharp>* x\\<rbrakk>\n    \\<Longrightarrow> set p \\<subseteq> ?Xs3 \\<times> ?Ys3\n 2. \\<lbrakk>set p \\<subseteq> Xs \\<times> Ys; Xs \\<sharp>* x;\n     Ys \\<sharp>* x\\<rbrakk>\n    \\<Longrightarrow> ?Xs3 \\<sharp>* [x]\n 3. \\<lbrakk>set p \\<subseteq> Xs \\<times> Ys; Xs \\<sharp>* x;\n     Ys \\<sharp>* x\\<rbrakk>\n    \\<Longrightarrow> ?Ys3 \\<sharp>* [x]", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>set p \\<subseteq> Xs \\<times> Ys; Xs \\<sharp>* x;\n     Ys \\<sharp>* x\\<rbrakk>\n    \\<Longrightarrow> Xs \\<sharp>* [x]\n 2. \\<lbrakk>set p \\<subseteq> Xs \\<times> Ys; Xs \\<sharp>* x;\n     Ys \\<sharp>* x\\<rbrakk>\n    \\<Longrightarrow> Ys \\<sharp>* [x]", "by auto"], ["proof (state)\nthis:\n  [x] \\<sharp>* p\n\ngoal (1 subgoal):\n 1. x \\<sharp> p", "thus ?thesis"], ["proof (prove)\nusing this:\n  [x] \\<sharp>* p\n\ngoal (1 subgoal):\n 1. x \\<sharp> p", "by simp"], ["proof (state)\nthis:\n  x \\<sharp> p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma setToListFresh[simp]:\n  fixes xvec :: \"name list\"\n  and   C    :: \"'a::fs_name\"\n  and   yvec :: \"name list\"\n  and   Xs   :: \"name set\"\n  and   x    :: name\n\n  shows \"xvec \\<sharp>* (set yvec) = xvec \\<sharp>* yvec\"\n  and   \"Xs \\<sharp>* (set yvec) = Xs \\<sharp>* yvec\"\n  and   \"x \\<sharp> (set yvec) = x \\<sharp> yvec\"\n  and   \"set xvec \\<sharp>* Xs = xvec \\<sharp>* Xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xvec \\<sharp>* set yvec = xvec \\<sharp>* yvec &&&\n     Xs \\<sharp>* set yvec = Xs \\<sharp>* yvec) &&&\n    x \\<sharp> set yvec = x \\<sharp> yvec &&&\n    set xvec \\<sharp>* Xs = xvec \\<sharp>* Xs", "by(auto simp add: fresh_star_def name_list_supp fresh_def fs_name1 at_fin_set_supp[OF at_name_inst])"], ["", "end"]]}