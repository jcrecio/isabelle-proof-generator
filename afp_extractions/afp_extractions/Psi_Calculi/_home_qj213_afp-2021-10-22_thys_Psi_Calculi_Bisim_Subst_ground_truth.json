{"file_name": "/home/qj213/afp-2021-10-22/thys/Psi_Calculi/Bisim_Subst.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Psi_Calculi", "problem_names": ["lemmas bisimSubstClosed[eqvt] = closeSubstClosed[OF bisimEqvt]", "lemmas bisimSubstEqvt[simp] = closeSubstEqvt[OF bisimEqvt]", "lemma bisimSubstOutputPres:\n  fixes \\<Psi> :: 'b\n  and   P :: \"('a, 'b, 'c) psi\"\n  and   Q :: \"('a, 'b, 'c) psi\"\n  and   M :: 'a\n  and   N :: 'a\n  \n  assumes \"\\<Psi> \\<rhd> P \\<sim>\\<^sub>s Q\"\n\n  shows \"\\<Psi> \\<rhd> M\\<langle>N\\<rangle>.P \\<sim>\\<^sub>s M\\<langle>N\\<rangle>.Q\"", "lemma seqSubstInputChain[simp]:\n  fixes xvec :: \"name list\"\n  and   N    :: \"'a\"\n  and   P    :: \"('a, 'b, 'c) psi\"\n  and   \\<sigma>    :: \"(name list \\<times> 'a list) list\"\n\n  assumes \"xvec \\<sharp>* \\<sigma>\"\n\n  shows \"seqSubs' (inputChain xvec N P) \\<sigma> = inputChain xvec (substTerm.seqSubst N \\<sigma>) (seqSubs P \\<sigma>)\"", "lemma bisimSubstInputPres:\n  fixes \\<Psi>    :: 'b\n  and   P    :: \"('a, 'b, 'c) psi\"\n  and   Q    :: \"('a, 'b, 'c) psi\"\n  and   M    :: 'a\n  and   xvec :: \"name list\"\n  and   N    :: 'a\n\n  assumes \"\\<Psi> \\<rhd> P \\<sim>\\<^sub>s Q\"\n  and     \"xvec \\<sharp>* \\<Psi>\"\n  and     \"distinct xvec\"\n\n  shows \"\\<Psi> \\<rhd> M\\<lparr>\\<lambda>*xvec N\\<rparr>.P \\<sim>\\<^sub>s M\\<lparr>\\<lambda>*xvec N\\<rparr>.Q\"", "lemma bisimSubstCasePresAux:\n  fixes \\<Psi>   :: 'b\n  and   CsP :: \"('c \\<times> ('a, 'b, 'c) psi) list\"\n  and   CsQ :: \"('c \\<times> ('a, 'b, 'c) psi) list\"\n  \n  assumes C1: \"\\<And>\\<phi> P. (\\<phi>, P) mem CsP \\<Longrightarrow> \\<exists>Q. (\\<phi>, Q) mem CsQ \\<and> guarded Q \\<and> \\<Psi> \\<rhd> P \\<sim>\\<^sub>s Q\"\n  and     C2: \"\\<And>\\<phi> Q. (\\<phi>, Q) mem CsQ \\<Longrightarrow> \\<exists>P. (\\<phi>, P) mem CsP \\<and> guarded P \\<and> \\<Psi> \\<rhd> P \\<sim>\\<^sub>s Q\"\n\n  shows \"\\<Psi> \\<rhd> Cases CsP \\<sim>\\<^sub>s Cases CsQ\"", "lemma bisimSubstReflexive:\n  fixes \\<Psi> :: 'b\n  and   P :: \"('a, 'b, 'c) psi\"\n\n  shows \"\\<Psi> \\<rhd> P \\<sim>\\<^sub>s P\"", "lemma bisimSubstTransitive:\n  fixes \\<Psi> :: 'b\n  and   P :: \"('a, 'b, 'c) psi\"\n  and   Q :: \"('a, 'b, 'c) psi\"\n  and   R :: \"('a, 'b, 'c) psi\"\n\n  assumes \"\\<Psi> \\<rhd> P \\<sim>\\<^sub>s Q\"\n  and     \"\\<Psi> \\<rhd> Q \\<sim>\\<^sub>s R\"\n\n  shows \"\\<Psi> \\<rhd> P \\<sim>\\<^sub>s R\"", "lemma bisimSubstSymmetric:\n  fixes \\<Psi> :: 'b\n  and   P :: \"('a, 'b, 'c) psi\"\n  and   Q :: \"('a, 'b, 'c) psi\"\n\n  assumes \"\\<Psi> \\<rhd> P \\<sim>\\<^sub>s Q\"\n\n  shows \"\\<Psi> \\<rhd> Q \\<sim>\\<^sub>s P\"", "lemma bisimSubstParPres:\n  fixes \\<Psi> :: 'b\n  and   P :: \"('a, 'b, 'c) psi\"\n  and   Q :: \"('a, 'b, 'c) psi\"\n  and   R :: \"('a, 'b, 'c) psi\"\n  \n  assumes \"\\<Psi> \\<rhd> P \\<sim>\\<^sub>s Q\"\n\n  shows \"\\<Psi> \\<rhd> P \\<parallel> R \\<sim>\\<^sub>s Q \\<parallel> R\"", "lemma bisimSubstResPres:\n  fixes \\<Psi> :: 'b\n  and   P :: \"('a, 'b, 'c) psi\"\n  and   Q :: \"('a, 'b, 'c) psi\"\n  and   x :: name\n\n  assumes \"\\<Psi> \\<rhd> P \\<sim>\\<^sub>s Q\"\n  and     \"x \\<sharp> \\<Psi>\"\n\n  shows \"\\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>P \\<sim>\\<^sub>s \\<lparr>\\<nu>x\\<rparr>Q\"", "lemma bisimSubstBangPres:\n  fixes \\<Psi> :: 'b\n  and   P :: \"('a, 'b, 'c) psi\"\n  and   Q :: \"('a, 'b, 'c) psi\"\n \n  assumes \"\\<Psi> \\<rhd> P \\<sim>\\<^sub>s Q\"\n  and     \"guarded P\"\n  and     \"guarded Q\"\n\n  shows \"\\<Psi> \\<rhd> !P \\<sim>\\<^sub>s !Q\"", "lemma substNil[simp]:\n  fixes xvec :: \"name list\"\n  and   Tvec :: \"'a list\"\n\n  assumes \"wellFormedSubst \\<sigma>\"\n  and     \"distinct xvec\"\n\n  shows \"(\\<zero>[<\\<sigma>>]) = \\<zero>\"", "lemma bisimSubstParNil:\n  fixes \\<Psi> :: 'b\n  and   P :: \"('a, 'b, 'c) psi\"\n\n  shows \"\\<Psi> \\<rhd> P \\<parallel> \\<zero> \\<sim>\\<^sub>s P\"", "lemma bisimSubstParComm:\n  fixes \\<Psi> :: 'b\n  and   P :: \"('a, 'b, 'c) psi\"\n  and   Q :: \"('a, 'b, 'c) psi\"\n\n  shows \"\\<Psi> \\<rhd> P \\<parallel> Q \\<sim>\\<^sub>s Q \\<parallel> P\"", "lemma bisimSubstParAssoc:\n  fixes \\<Psi> :: 'b\n  and   P :: \"('a, 'b, 'c) psi\"\n  and   Q :: \"('a, 'b, 'c) psi\"\n  and   R :: \"('a, 'b, 'c) psi\"\n\n  shows \"\\<Psi> \\<rhd> (P \\<parallel> Q) \\<parallel> R \\<sim>\\<^sub>s P \\<parallel> (Q \\<parallel> R)\"", "lemma bisimSubstResNil:\n  fixes \\<Psi> :: 'b\n  and   x :: name\n\n  shows \"\\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>\\<zero> \\<sim>\\<^sub>s \\<zero>\"", "lemma seqSubst2:\n  fixes x :: name\n  and   P :: \"('a, 'b, 'c) psi\"\n\n  assumes \"wellFormedSubst \\<sigma>\"\n  and     \"x \\<sharp> \\<sigma>\"\n  and     \"x \\<sharp> P\"\n\n  shows \"x \\<sharp> P[<\\<sigma>>]\"", "lemma bisimSubstScopeExt:\n  fixes \\<Psi> :: 'b\n  and   x :: name\n  and   P :: \"('a, 'b, 'c) psi\"\n  and   Q :: \"('a, 'b, 'c) psi\"\n\n  assumes \"x \\<sharp> P\"\n\n  shows \"\\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(P \\<parallel> Q) \\<sim>\\<^sub>s P \\<parallel> \\<lparr>\\<nu>x\\<rparr>Q\"", "lemma bisimSubstCasePushRes:\n  fixes x  :: name\n  and   \\<Psi>  :: 'b\n  and   Cs :: \"('c \\<times> ('a, 'b, 'c) psi) list\"\n\n  assumes \"x \\<sharp> map fst Cs\"\n\n  shows \"\\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(Cases Cs) \\<sim>\\<^sub>s Cases map (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>x\\<rparr>P)) Cs\"", "lemma bisimSubstOutputPushRes:\n  fixes x :: name\n  and   \\<Psi> :: 'b\n  and   M :: 'a\n  and   N :: 'a\n  and   P :: \"('a, 'b, 'c) psi\"\n\n  assumes \"x \\<sharp> M\"\n  and     \"x \\<sharp> N\"\n\n  shows \"\\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(M\\<langle>N\\<rangle>.P) \\<sim>\\<^sub>s M\\<langle>N\\<rangle>.\\<lparr>\\<nu>x\\<rparr>P\"", "lemma bisimSubstInputPushRes:\n  fixes x    :: name\n  and   \\<Psi>    :: 'b\n  and   M    :: 'a\n  and   xvec :: \"name list\"\n  and   N    :: 'a\n\n  assumes \"x \\<sharp> M\"\n  and     \"x \\<sharp> xvec\"\n  and     \"x \\<sharp> N\"\n\n  shows \"\\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(M\\<lparr>\\<lambda>*xvec N\\<rparr>.P) \\<sim>\\<^sub>s M\\<lparr>\\<lambda>*xvec N\\<rparr>.\\<lparr>\\<nu>x\\<rparr>P\"", "lemma bisimSubstResComm:\n  fixes x :: name\n  and   y :: name\n\n  shows \"\\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>P) \\<sim>\\<^sub>s \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>P)\"", "lemma bisimSubstExtBang:\n  fixes \\<Psi> :: 'b\n  and   P :: \"('a, 'b, 'c) psi\"\n  \n  assumes \"guarded P\"\n\n  shows \"\\<Psi> \\<rhd> !P \\<sim>\\<^sub>s P \\<parallel> !P\"", "lemma structCongBisimSubst:\n  fixes P :: \"('a, 'b, 'c) psi\"  \n  and   Q :: \"('a, 'b, 'c) psi\"\n\n  assumes \"P \\<equiv>\\<^sub>s Q\"\n\n  shows \"P \\<sim>\\<^sub>s Q\""], "translations": [["", "lemmas bisimSubstClosed[eqvt] = closeSubstClosed[OF bisimEqvt]"], ["", "lemmas bisimSubstEqvt[simp] = closeSubstEqvt[OF bisimEqvt]"], ["", "lemma bisimSubstOutputPres:\n  fixes \\<Psi> :: 'b\n  and   P :: \"('a, 'b, 'c) psi\"\n  and   Q :: \"('a, 'b, 'c) psi\"\n  and   M :: 'a\n  and   N :: 'a\n  \n  assumes \"\\<Psi> \\<rhd> P \\<sim>\\<^sub>s Q\"\n\n  shows \"\\<Psi> \\<rhd> M\\<langle>N\\<rangle>.P \\<sim>\\<^sub>s M\\<langle>N\\<rangle>.Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> M\\<langle>N\\<rangle>.P \\<sim>\\<^sub>s M\\<langle>N\\<rangle>.Q", "using assms"], ["proof (prove)\nusing this:\n  \\<Psi> \\<rhd> P \\<sim>\\<^sub>s Q\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> M\\<langle>N\\<rangle>.P \\<sim>\\<^sub>s M\\<langle>N\\<rangle>.Q", "by(fastforce intro: closeSubstI closeSubstE bisimOutputPres)"], ["", "lemma seqSubstInputChain[simp]:\n  fixes xvec :: \"name list\"\n  and   N    :: \"'a\"\n  and   P    :: \"('a, 'b, 'c) psi\"\n  and   \\<sigma>    :: \"(name list \\<times> 'a list) list\"\n\n  assumes \"xvec \\<sharp>* \\<sigma>\"\n\n  shows \"seqSubs' (inputChain xvec N P) \\<sigma> = inputChain xvec (substTerm.seqSubst N \\<sigma>) (seqSubs P \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seqSubs' (inputChain xvec N P) \\<sigma> =\n    inputChain xvec (substTerm.seqSubst N \\<sigma>) (P[<\\<sigma>>])", "using assms"], ["proof (prove)\nusing this:\n  xvec \\<sharp>* \\<sigma>\n\ngoal (1 subgoal):\n 1. seqSubs' (inputChain xvec N P) \\<sigma> =\n    inputChain xvec (substTerm.seqSubst N \\<sigma>) (P[<\\<sigma>>])", "by(induct xvec) auto"], ["", "lemma bisimSubstInputPres:\n  fixes \\<Psi>    :: 'b\n  and   P    :: \"('a, 'b, 'c) psi\"\n  and   Q    :: \"('a, 'b, 'c) psi\"\n  and   M    :: 'a\n  and   xvec :: \"name list\"\n  and   N    :: 'a\n\n  assumes \"\\<Psi> \\<rhd> P \\<sim>\\<^sub>s Q\"\n  and     \"xvec \\<sharp>* \\<Psi>\"\n  and     \"distinct xvec\"\n\n  shows \"\\<Psi> \\<rhd> M\\<lparr>\\<lambda>*xvec N\\<rparr>.P \\<sim>\\<^sub>s M\\<lparr>\\<lambda>*xvec N\\<rparr>.Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> M\\<lparr>\\<lambda>*xvec N\\<rparr>.P \\<sim>\\<^sub>s M\\<lparr>\\<lambda>*xvec N\\<rparr>.Q", "proof(rule_tac closeSubstI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> M\\<lparr>\\<lambda>*xvec N\\<rparr>.P[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*xvec N\\<rparr>.Q[<\\<sigma>>]", "fix \\<sigma>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> M\\<lparr>\\<lambda>*xvec N\\<rparr>.P[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*xvec N\\<rparr>.Q[<\\<sigma>>]", "assume \"wellFormedSubst(\\<sigma>::(name list \\<times> 'a list) list)\""], ["proof (state)\nthis:\n  wellFormedSubst \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> M\\<lparr>\\<lambda>*xvec N\\<rparr>.P[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*xvec N\\<rparr>.Q[<\\<sigma>>]", "obtain p where \"(p \\<bullet> xvec) \\<sharp>* \\<sigma>\"\n             and \"(p \\<bullet> xvec) \\<sharp>* P\" and \"(p \\<bullet> xvec) \\<sharp>* Q\" and \"(p \\<bullet> xvec) \\<sharp>* \\<Psi>\" and \"(p \\<bullet> xvec) \\<sharp>* N\"\n             and S: \"set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>(p \\<bullet> xvec) \\<sharp>* \\<sigma>;\n         (p \\<bullet> xvec) \\<sharp>* P; (p \\<bullet> xvec) \\<sharp>* Q;\n         (p \\<bullet> xvec) \\<sharp>* \\<Psi>;\n         (p \\<bullet> xvec) \\<sharp>* N;\n         set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule_tac c=\"(\\<sigma>, P, Q, \\<Psi>, N)\" in name_list_avoiding) auto"], ["proof (state)\nthis:\n  (p \\<bullet> xvec) \\<sharp>* \\<sigma>\n  (p \\<bullet> xvec) \\<sharp>* P\n  (p \\<bullet> xvec) \\<sharp>* Q\n  (p \\<bullet> xvec) \\<sharp>* \\<Psi>\n  (p \\<bullet> xvec) \\<sharp>* N\n  set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> M\\<lparr>\\<lambda>*xvec N\\<rparr>.P[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*xvec N\\<rparr>.Q[<\\<sigma>>]", "from \\<open>\\<Psi> \\<rhd> P \\<sim>\\<^sub>s Q\\<close>"], ["proof (chain)\npicking this:\n  \\<Psi> \\<rhd> P \\<sim>\\<^sub>s Q", "have \"(p \\<bullet> \\<Psi>) \\<rhd> (p \\<bullet> P) \\<sim>\\<^sub>s (p \\<bullet> Q)\""], ["proof (prove)\nusing this:\n  \\<Psi> \\<rhd> P \\<sim>\\<^sub>s Q\n\ngoal (1 subgoal):\n 1. p \\<bullet> \\<Psi> \\<rhd> p \\<bullet> P \\<sim>\\<^sub>s p \\<bullet> Q", "by(rule bisimSubstClosed)"], ["proof (state)\nthis:\n  p \\<bullet> \\<Psi> \\<rhd> p \\<bullet> P \\<sim>\\<^sub>s p \\<bullet> Q\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> M\\<lparr>\\<lambda>*xvec N\\<rparr>.P[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*xvec N\\<rparr>.Q[<\\<sigma>>]", "with \\<open>xvec \\<sharp>* \\<Psi>\\<close> \\<open>(p \\<bullet> xvec) \\<sharp>* \\<Psi>\\<close> S"], ["proof (chain)\npicking this:\n  xvec \\<sharp>* \\<Psi>\n  (p \\<bullet> xvec) \\<sharp>* \\<Psi>\n  set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\n  p \\<bullet> \\<Psi> \\<rhd> p \\<bullet> P \\<sim>\\<^sub>s p \\<bullet> Q", "have \"\\<Psi> \\<rhd> (p \\<bullet> P) \\<sim>\\<^sub>s (p \\<bullet> Q)\""], ["proof (prove)\nusing this:\n  xvec \\<sharp>* \\<Psi>\n  (p \\<bullet> xvec) \\<sharp>* \\<Psi>\n  set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\n  p \\<bullet> \\<Psi> \\<rhd> p \\<bullet> P \\<sim>\\<^sub>s p \\<bullet> Q\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> p \\<bullet> P \\<sim>\\<^sub>s p \\<bullet> Q", "by simp"], ["proof (state)\nthis:\n  \\<Psi> \\<rhd> p \\<bullet> P \\<sim>\\<^sub>s p \\<bullet> Q\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> M\\<lparr>\\<lambda>*xvec N\\<rparr>.P[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*xvec N\\<rparr>.Q[<\\<sigma>>]", "{"], ["proof (state)\nthis:\n  \\<Psi> \\<rhd> p \\<bullet> P \\<sim>\\<^sub>s p \\<bullet> Q\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> M\\<lparr>\\<lambda>*xvec N\\<rparr>.P[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*xvec N\\<rparr>.Q[<\\<sigma>>]", "fix Tvec :: \"'a list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> M\\<lparr>\\<lambda>*xvec N\\<rparr>.P[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*xvec N\\<rparr>.Q[<\\<sigma>>]", "from \\<open>\\<Psi> \\<rhd> (p \\<bullet> P) \\<sim>\\<^sub>s (p \\<bullet> Q)\\<close> \\<open>wellFormedSubst \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  \\<Psi> \\<rhd> p \\<bullet> P \\<sim>\\<^sub>s p \\<bullet> Q\n  wellFormedSubst \\<sigma>", "have \"\\<Psi> \\<rhd> (p \\<bullet> P)[<\\<sigma>>] \\<sim>\\<^sub>s (p \\<bullet> Q)[<\\<sigma>>]\""], ["proof (prove)\nusing this:\n  \\<Psi> \\<rhd> p \\<bullet> P \\<sim>\\<^sub>s p \\<bullet> Q\n  wellFormedSubst \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> p \\<bullet>\n                  P[<\\<sigma>>] \\<sim>\\<^sub>s p \\<bullet> Q[<\\<sigma>>]", "by(rule closeSubstUnfold)"], ["proof (state)\nthis:\n  \\<Psi> \\<rhd> p \\<bullet>\n                P[<\\<sigma>>] \\<sim>\\<^sub>s p \\<bullet> Q[<\\<sigma>>]\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> M\\<lparr>\\<lambda>*xvec N\\<rparr>.P[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*xvec N\\<rparr>.Q[<\\<sigma>>]", "moreover"], ["proof (state)\nthis:\n  \\<Psi> \\<rhd> p \\<bullet>\n                P[<\\<sigma>>] \\<sim>\\<^sub>s p \\<bullet> Q[<\\<sigma>>]\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> M\\<lparr>\\<lambda>*xvec N\\<rparr>.P[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*xvec N\\<rparr>.Q[<\\<sigma>>]", "assume \"length xvec = length Tvec\" and \"distinct xvec\""], ["proof (state)\nthis:\n  length xvec = length Tvec\n  distinct xvec\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> M\\<lparr>\\<lambda>*xvec N\\<rparr>.P[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*xvec N\\<rparr>.Q[<\\<sigma>>]", "ultimately"], ["proof (chain)\npicking this:\n  \\<Psi> \\<rhd> p \\<bullet>\n                P[<\\<sigma>>] \\<sim>\\<^sub>s p \\<bullet> Q[<\\<sigma>>]\n  length xvec = length Tvec\n  distinct xvec", "have \"\\<Psi> \\<rhd> ((p \\<bullet> P)[<\\<sigma>>])[(p \\<bullet> xvec)::=Tvec] \\<sim> ((p \\<bullet> Q)[<\\<sigma>>])[(p \\<bullet> xvec)::=Tvec]\""], ["proof (prove)\nusing this:\n  \\<Psi> \\<rhd> p \\<bullet>\n                P[<\\<sigma>>] \\<sim>\\<^sub>s p \\<bullet> Q[<\\<sigma>>]\n  length xvec = length Tvec\n  distinct xvec\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> p \\<bullet>\n                  P[<\\<sigma>>][(p \\<bullet>\n                                 xvec)::=Tvec] \\<sim> p \\<bullet>\n                Q[<\\<sigma>>][(p \\<bullet> xvec)::=Tvec]", "by(drule_tac closeSubstE[where \\<sigma>=\"[((p \\<bullet> xvec), Tvec)]\"]) auto"], ["proof (state)\nthis:\n  \\<Psi> \\<rhd> p \\<bullet>\n                P[<\\<sigma>>][(p \\<bullet>\n                               xvec)::=Tvec] \\<sim> p \\<bullet>\n              Q[<\\<sigma>>][(p \\<bullet> xvec)::=Tvec]\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> M\\<lparr>\\<lambda>*xvec N\\<rparr>.P[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*xvec N\\<rparr>.Q[<\\<sigma>>]", "}"], ["proof (state)\nthis:\n  \\<lbrakk>length xvec = length ?Tvec2; distinct xvec\\<rbrakk>\n  \\<Longrightarrow> \\<Psi> \\<rhd> p \\<bullet>\n                                  P[<\\<sigma>>][(p \\<bullet>\n           xvec)::=?Tvec2] \\<sim> p \\<bullet>\n                                  Q[<\\<sigma>>][(p \\<bullet> xvec)::=?Tvec2]\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> M\\<lparr>\\<lambda>*xvec N\\<rparr>.P[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*xvec N\\<rparr>.Q[<\\<sigma>>]", "with \\<open>(p \\<bullet> xvec) \\<sharp>* \\<sigma>\\<close> \\<open>distinct xvec\\<close>"], ["proof (chain)\npicking this:\n  (p \\<bullet> xvec) \\<sharp>* \\<sigma>\n  distinct xvec\n  \\<lbrakk>length xvec = length ?Tvec2; distinct xvec\\<rbrakk>\n  \\<Longrightarrow> \\<Psi> \\<rhd> p \\<bullet>\n                                  P[<\\<sigma>>][(p \\<bullet>\n           xvec)::=?Tvec2] \\<sim> p \\<bullet>\n                                  Q[<\\<sigma>>][(p \\<bullet> xvec)::=?Tvec2]", "have \"\\<Psi> \\<rhd> (M\\<lparr>\\<lambda>*(p \\<bullet> xvec) (p \\<bullet> N)\\<rparr>.(p \\<bullet> P))[<\\<sigma>>] \\<sim> (M\\<lparr>\\<lambda>*(p \\<bullet> xvec) (p \\<bullet> N)\\<rparr>.(p \\<bullet> Q))[<\\<sigma>>]\""], ["proof (prove)\nusing this:\n  (p \\<bullet> xvec) \\<sharp>* \\<sigma>\n  distinct xvec\n  \\<lbrakk>length xvec = length ?Tvec2; distinct xvec\\<rbrakk>\n  \\<Longrightarrow> \\<Psi> \\<rhd> p \\<bullet>\n                                  P[<\\<sigma>>][(p \\<bullet>\n           xvec)::=?Tvec2] \\<sim> p \\<bullet>\n                                  Q[<\\<sigma>>][(p \\<bullet> xvec)::=?Tvec2]\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> M\\<lparr>\\<lambda>*p \\<bullet>\n                                     xvec p \\<bullet>\n    N\\<rparr>.p \\<bullet>\n              P[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*p \\<bullet>\n                xvec p \\<bullet> N\\<rparr>.p \\<bullet> Q[<\\<sigma>>]", "by(force intro: bisimInputPres)"], ["proof (state)\nthis:\n  \\<Psi> \\<rhd> M\\<lparr>\\<lambda>*p \\<bullet>\n                                   xvec p \\<bullet>\n  N\\<rparr>.p \\<bullet>\n            P[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*p \\<bullet>\n              xvec p \\<bullet> N\\<rparr>.p \\<bullet> Q[<\\<sigma>>]\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> M\\<lparr>\\<lambda>*xvec N\\<rparr>.P[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*xvec N\\<rparr>.Q[<\\<sigma>>]", "moreover"], ["proof (state)\nthis:\n  \\<Psi> \\<rhd> M\\<lparr>\\<lambda>*p \\<bullet>\n                                   xvec p \\<bullet>\n  N\\<rparr>.p \\<bullet>\n            P[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*p \\<bullet>\n              xvec p \\<bullet> N\\<rparr>.p \\<bullet> Q[<\\<sigma>>]\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> M\\<lparr>\\<lambda>*xvec N\\<rparr>.P[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*xvec N\\<rparr>.Q[<\\<sigma>>]", "from \\<open>(p \\<bullet> xvec) \\<sharp>* N\\<close> \\<open>(p \\<bullet> xvec) \\<sharp>* P\\<close> S"], ["proof (chain)\npicking this:\n  (p \\<bullet> xvec) \\<sharp>* N\n  (p \\<bullet> xvec) \\<sharp>* P\n  set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)", "have \"M\\<lparr>\\<lambda>*(p \\<bullet> xvec) (p \\<bullet> N)\\<rparr>.(p \\<bullet> P) = M\\<lparr>\\<lambda>*xvec N\\<rparr>.P\""], ["proof (prove)\nusing this:\n  (p \\<bullet> xvec) \\<sharp>* N\n  (p \\<bullet> xvec) \\<sharp>* P\n  set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\n\ngoal (1 subgoal):\n 1. M\\<lparr>\\<lambda>*p \\<bullet>\n                       xvec p \\<bullet> N\\<rparr>.p \\<bullet> P =\n    M\\<lparr>\\<lambda>*xvec N\\<rparr>.P", "apply(simp add: psi.inject)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(p \\<bullet> xvec) \\<sharp>* N; (p \\<bullet> xvec) \\<sharp>* P;\n     set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\\<rbrakk>\n    \\<Longrightarrow> inputChain (p \\<bullet> xvec) (p \\<bullet> N)\n                       (p \\<bullet> P) =\n                      inputChain xvec N P", "by(rule inputChainAlpha[symmetric]) auto"], ["proof (state)\nthis:\n  M\\<lparr>\\<lambda>*p \\<bullet> xvec p \\<bullet> N\\<rparr>.p \\<bullet> P =\n  M\\<lparr>\\<lambda>*xvec N\\<rparr>.P\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> M\\<lparr>\\<lambda>*xvec N\\<rparr>.P[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*xvec N\\<rparr>.Q[<\\<sigma>>]", "moreover"], ["proof (state)\nthis:\n  M\\<lparr>\\<lambda>*p \\<bullet> xvec p \\<bullet> N\\<rparr>.p \\<bullet> P =\n  M\\<lparr>\\<lambda>*xvec N\\<rparr>.P\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> M\\<lparr>\\<lambda>*xvec N\\<rparr>.P[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*xvec N\\<rparr>.Q[<\\<sigma>>]", "from \\<open>(p \\<bullet> xvec) \\<sharp>* N\\<close> \\<open>(p \\<bullet> xvec) \\<sharp>* Q\\<close> S"], ["proof (chain)\npicking this:\n  (p \\<bullet> xvec) \\<sharp>* N\n  (p \\<bullet> xvec) \\<sharp>* Q\n  set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)", "have \"M\\<lparr>\\<lambda>*(p \\<bullet> xvec) (p \\<bullet> N)\\<rparr>.(p \\<bullet> Q) = M\\<lparr>\\<lambda>*xvec N\\<rparr>.Q\""], ["proof (prove)\nusing this:\n  (p \\<bullet> xvec) \\<sharp>* N\n  (p \\<bullet> xvec) \\<sharp>* Q\n  set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\n\ngoal (1 subgoal):\n 1. M\\<lparr>\\<lambda>*p \\<bullet>\n                       xvec p \\<bullet> N\\<rparr>.p \\<bullet> Q =\n    M\\<lparr>\\<lambda>*xvec N\\<rparr>.Q", "apply(simp add: psi.inject)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(p \\<bullet> xvec) \\<sharp>* N; (p \\<bullet> xvec) \\<sharp>* Q;\n     set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\\<rbrakk>\n    \\<Longrightarrow> inputChain (p \\<bullet> xvec) (p \\<bullet> N)\n                       (p \\<bullet> Q) =\n                      inputChain xvec N Q", "by(rule inputChainAlpha[symmetric]) auto"], ["proof (state)\nthis:\n  M\\<lparr>\\<lambda>*p \\<bullet> xvec p \\<bullet> N\\<rparr>.p \\<bullet> Q =\n  M\\<lparr>\\<lambda>*xvec N\\<rparr>.Q\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> M\\<lparr>\\<lambda>*xvec N\\<rparr>.P[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*xvec N\\<rparr>.Q[<\\<sigma>>]", "ultimately"], ["proof (chain)\npicking this:\n  \\<Psi> \\<rhd> M\\<lparr>\\<lambda>*p \\<bullet>\n                                   xvec p \\<bullet>\n  N\\<rparr>.p \\<bullet>\n            P[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*p \\<bullet>\n              xvec p \\<bullet> N\\<rparr>.p \\<bullet> Q[<\\<sigma>>]\n  M\\<lparr>\\<lambda>*p \\<bullet> xvec p \\<bullet> N\\<rparr>.p \\<bullet> P =\n  M\\<lparr>\\<lambda>*xvec N\\<rparr>.P\n  M\\<lparr>\\<lambda>*p \\<bullet> xvec p \\<bullet> N\\<rparr>.p \\<bullet> Q =\n  M\\<lparr>\\<lambda>*xvec N\\<rparr>.Q", "show \"\\<Psi> \\<rhd> (M\\<lparr>\\<lambda>*xvec N\\<rparr>.P)[<\\<sigma>>] \\<sim> (M\\<lparr>\\<lambda>*xvec N\\<rparr>.Q)[<\\<sigma>>]\""], ["proof (prove)\nusing this:\n  \\<Psi> \\<rhd> M\\<lparr>\\<lambda>*p \\<bullet>\n                                   xvec p \\<bullet>\n  N\\<rparr>.p \\<bullet>\n            P[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*p \\<bullet>\n              xvec p \\<bullet> N\\<rparr>.p \\<bullet> Q[<\\<sigma>>]\n  M\\<lparr>\\<lambda>*p \\<bullet> xvec p \\<bullet> N\\<rparr>.p \\<bullet> P =\n  M\\<lparr>\\<lambda>*xvec N\\<rparr>.P\n  M\\<lparr>\\<lambda>*p \\<bullet> xvec p \\<bullet> N\\<rparr>.p \\<bullet> Q =\n  M\\<lparr>\\<lambda>*xvec N\\<rparr>.Q\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> M\\<lparr>\\<lambda>*xvec N\\<rparr>.P[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*xvec N\\<rparr>.Q[<\\<sigma>>]", "by force"], ["proof (state)\nthis:\n  \\<Psi> \\<rhd> M\\<lparr>\\<lambda>*xvec N\\<rparr>.P[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*xvec N\\<rparr>.Q[<\\<sigma>>]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bisimSubstCasePresAux:\n  fixes \\<Psi>   :: 'b\n  and   CsP :: \"('c \\<times> ('a, 'b, 'c) psi) list\"\n  and   CsQ :: \"('c \\<times> ('a, 'b, 'c) psi) list\"\n  \n  assumes C1: \"\\<And>\\<phi> P. (\\<phi>, P) mem CsP \\<Longrightarrow> \\<exists>Q. (\\<phi>, Q) mem CsQ \\<and> guarded Q \\<and> \\<Psi> \\<rhd> P \\<sim>\\<^sub>s Q\"\n  and     C2: \"\\<And>\\<phi> Q. (\\<phi>, Q) mem CsQ \\<Longrightarrow> \\<exists>P. (\\<phi>, P) mem CsP \\<and> guarded P \\<and> \\<Psi> \\<rhd> P \\<sim>\\<^sub>s Q\"\n\n  shows \"\\<Psi> \\<rhd> Cases CsP \\<sim>\\<^sub>s Cases CsQ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> Cases CsP \\<sim>\\<^sub>s Cases CsQ", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> Cases CsP \\<sim>\\<^sub>s Cases CsQ", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> Cases CsP \\<sim>\\<^sub>s Cases CsQ", "fix \\<sigma> :: \"(name list \\<times> 'a list) list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> Cases CsP \\<sim>\\<^sub>s Cases CsQ", "assume \"wellFormedSubst \\<sigma>\""], ["proof (state)\nthis:\n  wellFormedSubst \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> Cases CsP \\<sim>\\<^sub>s Cases CsQ", "have \"\\<Psi> \\<rhd> Cases(caseListSeqSubst CsP \\<sigma>) \\<sim> Cases(caseListSeqSubst CsQ \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> Cases caseListSeqSubst CsP\n                         \\<sigma> \\<sim> Cases caseListSeqSubst CsQ \\<sigma>", "proof(rule bisimCasePres)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<phi> P.\n       (\\<phi>, P) mem caseListSeqSubst CsP \\<sigma> \\<Longrightarrow>\n       \\<exists>Q.\n          (\\<phi>, Q) mem caseListSeqSubst CsQ \\<sigma> \\<and>\n          guarded Q \\<and> \\<Psi> \\<rhd> P \\<sim> Q\n 2. \\<And>\\<phi> Q.\n       (\\<phi>, Q) mem caseListSeqSubst CsQ \\<sigma> \\<Longrightarrow>\n       \\<exists>P.\n          (\\<phi>, P) mem caseListSeqSubst CsP \\<sigma> \\<and>\n          guarded P \\<and> \\<Psi> \\<rhd> P \\<sim> Q", "fix \\<phi> P"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<phi> P.\n       (\\<phi>, P) mem caseListSeqSubst CsP \\<sigma> \\<Longrightarrow>\n       \\<exists>Q.\n          (\\<phi>, Q) mem caseListSeqSubst CsQ \\<sigma> \\<and>\n          guarded Q \\<and> \\<Psi> \\<rhd> P \\<sim> Q\n 2. \\<And>\\<phi> Q.\n       (\\<phi>, Q) mem caseListSeqSubst CsQ \\<sigma> \\<Longrightarrow>\n       \\<exists>P.\n          (\\<phi>, P) mem caseListSeqSubst CsP \\<sigma> \\<and>\n          guarded P \\<and> \\<Psi> \\<rhd> P \\<sim> Q", "assume \"(\\<phi>, P) mem (caseListSeqSubst CsP \\<sigma>)\""], ["proof (state)\nthis:\n  (\\<phi>, P) mem caseListSeqSubst CsP \\<sigma>\n\ngoal (2 subgoals):\n 1. \\<And>\\<phi> P.\n       (\\<phi>, P) mem caseListSeqSubst CsP \\<sigma> \\<Longrightarrow>\n       \\<exists>Q.\n          (\\<phi>, Q) mem caseListSeqSubst CsQ \\<sigma> \\<and>\n          guarded Q \\<and> \\<Psi> \\<rhd> P \\<sim> Q\n 2. \\<And>\\<phi> Q.\n       (\\<phi>, Q) mem caseListSeqSubst CsQ \\<sigma> \\<Longrightarrow>\n       \\<exists>P.\n          (\\<phi>, P) mem caseListSeqSubst CsP \\<sigma> \\<and>\n          guarded P \\<and> \\<Psi> \\<rhd> P \\<sim> Q", "then"], ["proof (chain)\npicking this:\n  (\\<phi>, P) mem caseListSeqSubst CsP \\<sigma>", "obtain \\<phi>' P' where \"(\\<phi>', P') mem CsP\" and \"\\<phi> = substCond.seqSubst \\<phi>' \\<sigma>\" and PeqP': \"P = (P'[<\\<sigma>>])\""], ["proof (prove)\nusing this:\n  (\\<phi>, P) mem caseListSeqSubst CsP \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<phi>' P'.\n        \\<lbrakk>(\\<phi>', P') mem CsP;\n         \\<phi> = substCond.seqSubst \\<phi>' \\<sigma>;\n         P = P'[<\\<sigma>>]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(induct CsP) force+"], ["proof (state)\nthis:\n  (\\<phi>', P') mem CsP\n  \\<phi> = substCond.seqSubst \\<phi>' \\<sigma>\n  P = P'[<\\<sigma>>]\n\ngoal (2 subgoals):\n 1. \\<And>\\<phi> P.\n       (\\<phi>, P) mem caseListSeqSubst CsP \\<sigma> \\<Longrightarrow>\n       \\<exists>Q.\n          (\\<phi>, Q) mem caseListSeqSubst CsQ \\<sigma> \\<and>\n          guarded Q \\<and> \\<Psi> \\<rhd> P \\<sim> Q\n 2. \\<And>\\<phi> Q.\n       (\\<phi>, Q) mem caseListSeqSubst CsQ \\<sigma> \\<Longrightarrow>\n       \\<exists>P.\n          (\\<phi>, P) mem caseListSeqSubst CsP \\<sigma> \\<and>\n          guarded P \\<and> \\<Psi> \\<rhd> P \\<sim> Q", "from \\<open>(\\<phi>', P') mem CsP\\<close>"], ["proof (chain)\npicking this:\n  (\\<phi>', P') mem CsP", "obtain Q' where \"(\\<phi>', Q') mem CsQ\" and \"guarded Q'\" and \"\\<Psi> \\<rhd> P' \\<sim>\\<^sub>s Q'\""], ["proof (prove)\nusing this:\n  (\\<phi>', P') mem CsP\n\ngoal (1 subgoal):\n 1. (\\<And>Q'.\n        \\<lbrakk>(\\<phi>', Q') mem CsQ; guarded Q';\n         \\<Psi> \\<rhd> P' \\<sim>\\<^sub>s Q'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(blast dest: C1)"], ["proof (state)\nthis:\n  (\\<phi>', Q') mem CsQ\n  guarded Q'\n  \\<Psi> \\<rhd> P' \\<sim>\\<^sub>s Q'\n\ngoal (2 subgoals):\n 1. \\<And>\\<phi> P.\n       (\\<phi>, P) mem caseListSeqSubst CsP \\<sigma> \\<Longrightarrow>\n       \\<exists>Q.\n          (\\<phi>, Q) mem caseListSeqSubst CsQ \\<sigma> \\<and>\n          guarded Q \\<and> \\<Psi> \\<rhd> P \\<sim> Q\n 2. \\<And>\\<phi> Q.\n       (\\<phi>, Q) mem caseListSeqSubst CsQ \\<sigma> \\<Longrightarrow>\n       \\<exists>P.\n          (\\<phi>, P) mem caseListSeqSubst CsP \\<sigma> \\<and>\n          guarded P \\<and> \\<Psi> \\<rhd> P \\<sim> Q", "from \\<open>(\\<phi>', Q') mem CsQ\\<close> \\<open>\\<phi> = substCond.seqSubst \\<phi>' \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  (\\<phi>', Q') mem CsQ\n  \\<phi> = substCond.seqSubst \\<phi>' \\<sigma>", "obtain Q where \"(\\<phi>, Q) mem (caseListSeqSubst CsQ \\<sigma>)\" and \"Q = Q'[<\\<sigma>>]\""], ["proof (prove)\nusing this:\n  (\\<phi>', Q') mem CsQ\n  \\<phi> = substCond.seqSubst \\<phi>' \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>(\\<phi>, Q) mem caseListSeqSubst CsQ \\<sigma>;\n         Q = Q'[<\\<sigma>>]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(induct CsQ) auto"], ["proof (state)\nthis:\n  (\\<phi>, Q) mem caseListSeqSubst CsQ \\<sigma>\n  Q = Q'[<\\<sigma>>]\n\ngoal (2 subgoals):\n 1. \\<And>\\<phi> P.\n       (\\<phi>, P) mem caseListSeqSubst CsP \\<sigma> \\<Longrightarrow>\n       \\<exists>Q.\n          (\\<phi>, Q) mem caseListSeqSubst CsQ \\<sigma> \\<and>\n          guarded Q \\<and> \\<Psi> \\<rhd> P \\<sim> Q\n 2. \\<And>\\<phi> Q.\n       (\\<phi>, Q) mem caseListSeqSubst CsQ \\<sigma> \\<Longrightarrow>\n       \\<exists>P.\n          (\\<phi>, P) mem caseListSeqSubst CsP \\<sigma> \\<and>\n          guarded P \\<and> \\<Psi> \\<rhd> P \\<sim> Q", "with PeqP' \\<open>guarded Q'\\<close> \\<open>\\<Psi> \\<rhd> P' \\<sim>\\<^sub>s Q'\\<close> \\<open>wellFormedSubst \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  P = P'[<\\<sigma>>]\n  guarded Q'\n  \\<Psi> \\<rhd> P' \\<sim>\\<^sub>s Q'\n  wellFormedSubst \\<sigma>\n  (\\<phi>, Q) mem caseListSeqSubst CsQ \\<sigma>\n  Q = Q'[<\\<sigma>>]", "show \"\\<exists>Q. (\\<phi>, Q) mem (caseListSeqSubst CsQ \\<sigma>) \\<and> guarded Q \\<and> \\<Psi> \\<rhd> P \\<sim> Q\""], ["proof (prove)\nusing this:\n  P = P'[<\\<sigma>>]\n  guarded Q'\n  \\<Psi> \\<rhd> P' \\<sim>\\<^sub>s Q'\n  wellFormedSubst \\<sigma>\n  (\\<phi>, Q) mem caseListSeqSubst CsQ \\<sigma>\n  Q = Q'[<\\<sigma>>]\n\ngoal (1 subgoal):\n 1. \\<exists>Q.\n       (\\<phi>, Q) mem caseListSeqSubst CsQ \\<sigma> \\<and>\n       guarded Q \\<and> \\<Psi> \\<rhd> P \\<sim> Q", "by(blast dest: closeSubstE guardedSeqSubst)"], ["proof (state)\nthis:\n  \\<exists>Q.\n     (\\<phi>, Q) mem caseListSeqSubst CsQ \\<sigma> \\<and>\n     guarded Q \\<and> \\<Psi> \\<rhd> P \\<sim> Q\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi> Q.\n       (\\<phi>, Q) mem caseListSeqSubst CsQ \\<sigma> \\<Longrightarrow>\n       \\<exists>P.\n          (\\<phi>, P) mem caseListSeqSubst CsP \\<sigma> \\<and>\n          guarded P \\<and> \\<Psi> \\<rhd> P \\<sim> Q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<phi> Q.\n       (\\<phi>, Q) mem caseListSeqSubst CsQ \\<sigma> \\<Longrightarrow>\n       \\<exists>P.\n          (\\<phi>, P) mem caseListSeqSubst CsP \\<sigma> \\<and>\n          guarded P \\<and> \\<Psi> \\<rhd> P \\<sim> Q", "fix \\<phi> Q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<phi> Q.\n       (\\<phi>, Q) mem caseListSeqSubst CsQ \\<sigma> \\<Longrightarrow>\n       \\<exists>P.\n          (\\<phi>, P) mem caseListSeqSubst CsP \\<sigma> \\<and>\n          guarded P \\<and> \\<Psi> \\<rhd> P \\<sim> Q", "assume \"(\\<phi>, Q) mem (caseListSeqSubst CsQ \\<sigma>)\""], ["proof (state)\nthis:\n  (\\<phi>, Q) mem caseListSeqSubst CsQ \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi> Q.\n       (\\<phi>, Q) mem caseListSeqSubst CsQ \\<sigma> \\<Longrightarrow>\n       \\<exists>P.\n          (\\<phi>, P) mem caseListSeqSubst CsP \\<sigma> \\<and>\n          guarded P \\<and> \\<Psi> \\<rhd> P \\<sim> Q", "then"], ["proof (chain)\npicking this:\n  (\\<phi>, Q) mem caseListSeqSubst CsQ \\<sigma>", "obtain \\<phi>' Q' where \"(\\<phi>', Q') mem CsQ\" and \"\\<phi> = substCond.seqSubst \\<phi>' \\<sigma>\" and QeqQ': \"Q = Q'[<\\<sigma>>]\""], ["proof (prove)\nusing this:\n  (\\<phi>, Q) mem caseListSeqSubst CsQ \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<phi>' Q'.\n        \\<lbrakk>(\\<phi>', Q') mem CsQ;\n         \\<phi> = substCond.seqSubst \\<phi>' \\<sigma>;\n         Q = Q'[<\\<sigma>>]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(induct CsQ) force+"], ["proof (state)\nthis:\n  (\\<phi>', Q') mem CsQ\n  \\<phi> = substCond.seqSubst \\<phi>' \\<sigma>\n  Q = Q'[<\\<sigma>>]\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi> Q.\n       (\\<phi>, Q) mem caseListSeqSubst CsQ \\<sigma> \\<Longrightarrow>\n       \\<exists>P.\n          (\\<phi>, P) mem caseListSeqSubst CsP \\<sigma> \\<and>\n          guarded P \\<and> \\<Psi> \\<rhd> P \\<sim> Q", "from \\<open>(\\<phi>', Q') mem CsQ\\<close>"], ["proof (chain)\npicking this:\n  (\\<phi>', Q') mem CsQ", "obtain P' where \"(\\<phi>', P') mem CsP\" and \"guarded P'\" and \"\\<Psi> \\<rhd> P' \\<sim>\\<^sub>s Q'\""], ["proof (prove)\nusing this:\n  (\\<phi>', Q') mem CsQ\n\ngoal (1 subgoal):\n 1. (\\<And>P'.\n        \\<lbrakk>(\\<phi>', P') mem CsP; guarded P';\n         \\<Psi> \\<rhd> P' \\<sim>\\<^sub>s Q'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(blast dest: C2)"], ["proof (state)\nthis:\n  (\\<phi>', P') mem CsP\n  guarded P'\n  \\<Psi> \\<rhd> P' \\<sim>\\<^sub>s Q'\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi> Q.\n       (\\<phi>, Q) mem caseListSeqSubst CsQ \\<sigma> \\<Longrightarrow>\n       \\<exists>P.\n          (\\<phi>, P) mem caseListSeqSubst CsP \\<sigma> \\<and>\n          guarded P \\<and> \\<Psi> \\<rhd> P \\<sim> Q", "from \\<open>(\\<phi>', P') mem CsP\\<close> \\<open>\\<phi> = substCond.seqSubst \\<phi>' \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  (\\<phi>', P') mem CsP\n  \\<phi> = substCond.seqSubst \\<phi>' \\<sigma>", "obtain P where \"(\\<phi>, P) mem (caseListSeqSubst CsP \\<sigma>)\" and \"P = P'[<\\<sigma>>]\""], ["proof (prove)\nusing this:\n  (\\<phi>', P') mem CsP\n  \\<phi> = substCond.seqSubst \\<phi>' \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>(\\<phi>, P) mem caseListSeqSubst CsP \\<sigma>;\n         P = P'[<\\<sigma>>]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(induct CsP) auto"], ["proof (state)\nthis:\n  (\\<phi>, P) mem caseListSeqSubst CsP \\<sigma>\n  P = P'[<\\<sigma>>]\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi> Q.\n       (\\<phi>, Q) mem caseListSeqSubst CsQ \\<sigma> \\<Longrightarrow>\n       \\<exists>P.\n          (\\<phi>, P) mem caseListSeqSubst CsP \\<sigma> \\<and>\n          guarded P \\<and> \\<Psi> \\<rhd> P \\<sim> Q", "with QeqQ' \\<open>guarded P'\\<close> \\<open>\\<Psi> \\<rhd> P' \\<sim>\\<^sub>s Q'\\<close> \\<open>wellFormedSubst \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  Q = Q'[<\\<sigma>>]\n  guarded P'\n  \\<Psi> \\<rhd> P' \\<sim>\\<^sub>s Q'\n  wellFormedSubst \\<sigma>\n  (\\<phi>, P) mem caseListSeqSubst CsP \\<sigma>\n  P = P'[<\\<sigma>>]", "show \"\\<exists>P. (\\<phi>, P) mem (caseListSeqSubst CsP \\<sigma>) \\<and> guarded P \\<and> \\<Psi> \\<rhd> P \\<sim> Q\""], ["proof (prove)\nusing this:\n  Q = Q'[<\\<sigma>>]\n  guarded P'\n  \\<Psi> \\<rhd> P' \\<sim>\\<^sub>s Q'\n  wellFormedSubst \\<sigma>\n  (\\<phi>, P) mem caseListSeqSubst CsP \\<sigma>\n  P = P'[<\\<sigma>>]\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       (\\<phi>, P) mem caseListSeqSubst CsP \\<sigma> \\<and>\n       guarded P \\<and> \\<Psi> \\<rhd> P \\<sim> Q", "by(blast dest: closeSubstE guardedSeqSubst)"], ["proof (state)\nthis:\n  \\<exists>P.\n     (\\<phi>, P) mem caseListSeqSubst CsP \\<sigma> \\<and>\n     guarded P \\<and> \\<Psi> \\<rhd> P \\<sim> Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Psi> \\<rhd> Cases caseListSeqSubst CsP\n                       \\<sigma> \\<sim> Cases caseListSeqSubst CsQ \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> Cases CsP \\<sim>\\<^sub>s Cases CsQ", "}"], ["proof (state)\nthis:\n  wellFormedSubst ?\\<sigma>2 \\<Longrightarrow>\n  \\<Psi> \\<rhd> Cases caseListSeqSubst CsP\n                       ?\\<sigma>2 \\<sim> Cases caseListSeqSubst CsQ\n          ?\\<sigma>2\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> Cases CsP \\<sim>\\<^sub>s Cases CsQ", "thus ?thesis"], ["proof (prove)\nusing this:\n  wellFormedSubst ?\\<sigma>2 \\<Longrightarrow>\n  \\<Psi> \\<rhd> Cases caseListSeqSubst CsP\n                       ?\\<sigma>2 \\<sim> Cases caseListSeqSubst CsQ\n          ?\\<sigma>2\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> Cases CsP \\<sim>\\<^sub>s Cases CsQ", "by(rule_tac closeSubstI) auto"], ["proof (state)\nthis:\n  \\<Psi> \\<rhd> Cases CsP \\<sim>\\<^sub>s Cases CsQ\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bisimSubstReflexive:\n  fixes \\<Psi> :: 'b\n  and   P :: \"('a, 'b, 'c) psi\"\n\n  shows \"\\<Psi> \\<rhd> P \\<sim>\\<^sub>s P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> P \\<sim>\\<^sub>s P", "by(auto intro: closeSubstI bisimReflexive)"], ["", "lemma bisimSubstTransitive:\n  fixes \\<Psi> :: 'b\n  and   P :: \"('a, 'b, 'c) psi\"\n  and   Q :: \"('a, 'b, 'c) psi\"\n  and   R :: \"('a, 'b, 'c) psi\"\n\n  assumes \"\\<Psi> \\<rhd> P \\<sim>\\<^sub>s Q\"\n  and     \"\\<Psi> \\<rhd> Q \\<sim>\\<^sub>s R\"\n\n  shows \"\\<Psi> \\<rhd> P \\<sim>\\<^sub>s R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> P \\<sim>\\<^sub>s R", "using assms"], ["proof (prove)\nusing this:\n  \\<Psi> \\<rhd> P \\<sim>\\<^sub>s Q\n  \\<Psi> \\<rhd> Q \\<sim>\\<^sub>s R\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> P \\<sim>\\<^sub>s R", "by(auto intro: closeSubstI closeSubstE bisimTransitive)"], ["", "lemma bisimSubstSymmetric:\n  fixes \\<Psi> :: 'b\n  and   P :: \"('a, 'b, 'c) psi\"\n  and   Q :: \"('a, 'b, 'c) psi\"\n\n  assumes \"\\<Psi> \\<rhd> P \\<sim>\\<^sub>s Q\"\n\n  shows \"\\<Psi> \\<rhd> Q \\<sim>\\<^sub>s P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> Q \\<sim>\\<^sub>s P", "using assms"], ["proof (prove)\nusing this:\n  \\<Psi> \\<rhd> P \\<sim>\\<^sub>s Q\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> Q \\<sim>\\<^sub>s P", "by(auto intro: closeSubstI closeSubstE bisimE)"], ["", "(*\nlemma bisimSubstCasePres:\n  fixes \\<Psi>   :: 'b\n  and   CsP :: \"('c \\<times> ('a, 'b, 'c) psi) list\"\n  and   CsQ :: \"('c \\<times> ('a, 'b, 'c) psi) list\"\n  \n  assumes \"length CsP = length CsQ\"\n  and     C: \"\\<And>(i::nat) \\<phi> P \\<phi>' Q. \\<lbrakk>i <= length CsP; (\\<phi>, P) = nth CsP i; (\\<phi>', Q) = nth CsQ i\\<rbrakk> \\<Longrightarrow> \\<phi> = \\<phi>' \\<and> \\<Psi> \\<rhd> P \\<sim> Q\"\n\n  shows \"\\<Psi> \\<rhd> Cases CsP \\<sim>\\<^sub>s Cases CsQ\"\nproof -\n  {\n    fix \\<phi> \n    and P\n\n    assume \"(\\<phi>, P) mem CsP\"\n\n    with `length CsP = length CsQ` have \"\\<exists>Q. (\\<phi>, Q) mem CsQ \\<and> \\<Psi> \\<rhd> P \\<sim>\\<^sub>s Q\"\n      apply(induct n==\"length CsP\" arbitrary: CsP CsQ rule: nat.induct)\n      apply simp\n      apply simp\n      apply auto\n\n  }\nusing `length CsP = length CsQ`\nproof(induct n==\"length CsP\" rule: nat.induct)\n  case zero\n  thus ?case by(fastforce intro: bisimSubstReflexive)\nnext\n  case(Suc n)\nnext\napply auto\napply(blast intro: bisimSubstReflexive)\napply auto\napply(simp add: nth.simps)\napply(auto simp add: nth.simps)\napply blast\napply(rule_tac bisimSubstCasePresAux)\napply auto\n*)"], ["", "lemma bisimSubstParPres:\n  fixes \\<Psi> :: 'b\n  and   P :: \"('a, 'b, 'c) psi\"\n  and   Q :: \"('a, 'b, 'c) psi\"\n  and   R :: \"('a, 'b, 'c) psi\"\n  \n  assumes \"\\<Psi> \\<rhd> P \\<sim>\\<^sub>s Q\"\n\n  shows \"\\<Psi> \\<rhd> P \\<parallel> R \\<sim>\\<^sub>s Q \\<parallel> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> P \\<parallel> R \\<sim>\\<^sub>s Q \\<parallel> R", "using assms"], ["proof (prove)\nusing this:\n  \\<Psi> \\<rhd> P \\<sim>\\<^sub>s Q\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> P \\<parallel> R \\<sim>\\<^sub>s Q \\<parallel> R", "by(fastforce intro: closeSubstI closeSubstE bisimParPres)"], ["", "lemma bisimSubstResPres:\n  fixes \\<Psi> :: 'b\n  and   P :: \"('a, 'b, 'c) psi\"\n  and   Q :: \"('a, 'b, 'c) psi\"\n  and   x :: name\n\n  assumes \"\\<Psi> \\<rhd> P \\<sim>\\<^sub>s Q\"\n  and     \"x \\<sharp> \\<Psi>\"\n\n  shows \"\\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>P \\<sim>\\<^sub>s \\<lparr>\\<nu>x\\<rparr>Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>P \\<sim>\\<^sub>s \\<lparr>\\<nu>x\\<rparr>Q", "proof(rule_tac closeSubstI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>] \\<sim> \\<lparr>\\<nu>x\\<rparr>Q[<\\<sigma>>]", "fix \\<sigma> :: \"(name list \\<times> 'a list) list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>] \\<sim> \\<lparr>\\<nu>x\\<rparr>Q[<\\<sigma>>]", "assume \"wellFormedSubst \\<sigma>\""], ["proof (state)\nthis:\n  wellFormedSubst \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>] \\<sim> \\<lparr>\\<nu>x\\<rparr>Q[<\\<sigma>>]", "obtain y::name where \"y \\<sharp> \\<Psi>\" and \"y \\<sharp> P\" and \"y \\<sharp> Q\" and \"y \\<sharp> \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<sharp> \\<Psi>; y \\<sharp> P; y \\<sharp> Q;\n         y \\<sharp> \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(generate_fresh \"name\") (auto simp add: fresh_prod)"], ["proof (state)\nthis:\n  y \\<sharp> \\<Psi>\n  y \\<sharp> P\n  y \\<sharp> Q\n  y \\<sharp> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>] \\<sim> \\<lparr>\\<nu>x\\<rparr>Q[<\\<sigma>>]", "from \\<open>\\<Psi> \\<rhd> P \\<sim>\\<^sub>s Q\\<close>"], ["proof (chain)\npicking this:\n  \\<Psi> \\<rhd> P \\<sim>\\<^sub>s Q", "have \"([(x, y)] \\<bullet> \\<Psi>) \\<rhd> ([(x, y)] \\<bullet> P) \\<sim>\\<^sub>s ([(x, y)] \\<bullet> Q)\""], ["proof (prove)\nusing this:\n  \\<Psi> \\<rhd> P \\<sim>\\<^sub>s Q\n\ngoal (1 subgoal):\n 1. [(x, y)] \\<bullet>\n    \\<Psi> \\<rhd> [(x, y)] \\<bullet> P \\<sim>\\<^sub>s [(x, y)] \\<bullet> Q", "by(rule bisimSubstClosed)"], ["proof (state)\nthis:\n  [(x, y)] \\<bullet>\n  \\<Psi> \\<rhd> [(x, y)] \\<bullet> P \\<sim>\\<^sub>s [(x, y)] \\<bullet> Q\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>] \\<sim> \\<lparr>\\<nu>x\\<rparr>Q[<\\<sigma>>]", "with \\<open>x \\<sharp> \\<Psi>\\<close> \\<open>y \\<sharp> \\<Psi>\\<close>"], ["proof (chain)\npicking this:\n  x \\<sharp> \\<Psi>\n  y \\<sharp> \\<Psi>\n  [(x, y)] \\<bullet>\n  \\<Psi> \\<rhd> [(x, y)] \\<bullet> P \\<sim>\\<^sub>s [(x, y)] \\<bullet> Q", "have \"\\<Psi> \\<rhd> ([(x, y)] \\<bullet> P) \\<sim>\\<^sub>s ([(x, y)] \\<bullet> Q)\""], ["proof (prove)\nusing this:\n  x \\<sharp> \\<Psi>\n  y \\<sharp> \\<Psi>\n  [(x, y)] \\<bullet>\n  \\<Psi> \\<rhd> [(x, y)] \\<bullet> P \\<sim>\\<^sub>s [(x, y)] \\<bullet> Q\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> [(x, y)] \\<bullet> P \\<sim>\\<^sub>s [(x, y)] \\<bullet> Q", "by simp"], ["proof (state)\nthis:\n  \\<Psi> \\<rhd> [(x, y)] \\<bullet> P \\<sim>\\<^sub>s [(x, y)] \\<bullet> Q\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>] \\<sim> \\<lparr>\\<nu>x\\<rparr>Q[<\\<sigma>>]", "hence \"\\<Psi> \\<rhd> ([(x, y)] \\<bullet> P)[<\\<sigma>>] \\<sim> ([(x, y)] \\<bullet> Q)[<\\<sigma>>]\""], ["proof (prove)\nusing this:\n  \\<Psi> \\<rhd> [(x, y)] \\<bullet> P \\<sim>\\<^sub>s [(x, y)] \\<bullet> Q\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> [(x, y)] \\<bullet>\n                  P[<\\<sigma>>] \\<sim> [(x, y)] \\<bullet> Q[<\\<sigma>>]", "using \\<open>wellFormedSubst \\<sigma>\\<close>"], ["proof (prove)\nusing this:\n  \\<Psi> \\<rhd> [(x, y)] \\<bullet> P \\<sim>\\<^sub>s [(x, y)] \\<bullet> Q\n  wellFormedSubst \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> [(x, y)] \\<bullet>\n                  P[<\\<sigma>>] \\<sim> [(x, y)] \\<bullet> Q[<\\<sigma>>]", "by(rule closeSubstE)"], ["proof (state)\nthis:\n  \\<Psi> \\<rhd> [(x, y)] \\<bullet>\n                P[<\\<sigma>>] \\<sim> [(x, y)] \\<bullet> Q[<\\<sigma>>]\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>] \\<sim> \\<lparr>\\<nu>x\\<rparr>Q[<\\<sigma>>]", "hence \"\\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(([(x, y)] \\<bullet> P)[<\\<sigma>>]) \\<sim> \\<lparr>\\<nu>y\\<rparr>(([(x, y)] \\<bullet> Q)[<\\<sigma>>])\""], ["proof (prove)\nusing this:\n  \\<Psi> \\<rhd> [(x, y)] \\<bullet>\n                P[<\\<sigma>>] \\<sim> [(x, y)] \\<bullet> Q[<\\<sigma>>]\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet>\n  P[<\\<sigma>>] \\<sim> \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet>\n       Q[<\\<sigma>>]", "using \\<open>y \\<sharp> \\<Psi>\\<close>"], ["proof (prove)\nusing this:\n  \\<Psi> \\<rhd> [(x, y)] \\<bullet>\n                P[<\\<sigma>>] \\<sim> [(x, y)] \\<bullet> Q[<\\<sigma>>]\n  y \\<sharp> \\<Psi>\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet>\n  P[<\\<sigma>>] \\<sim> \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet>\n       Q[<\\<sigma>>]", "by(rule bisimResPres)"], ["proof (state)\nthis:\n  \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet>\nP[<\\<sigma>>] \\<sim> \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet> Q[<\\<sigma>>]\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>] \\<sim> \\<lparr>\\<nu>x\\<rparr>Q[<\\<sigma>>]", "with \\<open>y \\<sharp> P\\<close> \\<open>y \\<sharp> Q\\<close> \\<open>y \\<sharp> \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  y \\<sharp> P\n  y \\<sharp> Q\n  y \\<sharp> \\<sigma>\n  \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet>\nP[<\\<sigma>>] \\<sim> \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet> Q[<\\<sigma>>]", "show \"\\<Psi> \\<rhd> (\\<lparr>\\<nu>x\\<rparr>P)[<\\<sigma>>] \\<sim> (\\<lparr>\\<nu>x\\<rparr>Q)[<\\<sigma>>]\""], ["proof (prove)\nusing this:\n  y \\<sharp> P\n  y \\<sharp> Q\n  y \\<sharp> \\<sigma>\n  \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet>\nP[<\\<sigma>>] \\<sim> \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet> Q[<\\<sigma>>]\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>] \\<sim> \\<lparr>\\<nu>x\\<rparr>Q[<\\<sigma>>]", "by(simp add: alphaRes)"], ["proof (state)\nthis:\n  \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>] \\<sim> \\<lparr>\\<nu>x\\<rparr>Q[<\\<sigma>>]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bisimSubstBangPres:\n  fixes \\<Psi> :: 'b\n  and   P :: \"('a, 'b, 'c) psi\"\n  and   Q :: \"('a, 'b, 'c) psi\"\n \n  assumes \"\\<Psi> \\<rhd> P \\<sim>\\<^sub>s Q\"\n  and     \"guarded P\"\n  and     \"guarded Q\"\n\n  shows \"\\<Psi> \\<rhd> !P \\<sim>\\<^sub>s !Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> !P \\<sim>\\<^sub>s !Q", "using assms"], ["proof (prove)\nusing this:\n  \\<Psi> \\<rhd> P \\<sim>\\<^sub>s Q\n  guarded P\n  guarded Q\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> !P \\<sim>\\<^sub>s !Q", "by(fastforce intro: closeSubstI closeSubstE bisimBangPres guardedSeqSubst)"], ["", "lemma substNil[simp]:\n  fixes xvec :: \"name list\"\n  and   Tvec :: \"'a list\"\n\n  assumes \"wellFormedSubst \\<sigma>\"\n  and     \"distinct xvec\"\n\n  shows \"(\\<zero>[<\\<sigma>>]) = \\<zero>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<zero>[<\\<sigma>>] = \\<zero>", "using assms"], ["proof (prove)\nusing this:\n  wellFormedSubst \\<sigma>\n  distinct xvec\n\ngoal (1 subgoal):\n 1. \\<zero>[<\\<sigma>>] = \\<zero>", "by simp"], ["", "lemma bisimSubstParNil:\n  fixes \\<Psi> :: 'b\n  and   P :: \"('a, 'b, 'c) psi\"\n\n  shows \"\\<Psi> \\<rhd> P \\<parallel> \\<zero> \\<sim>\\<^sub>s P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> P \\<parallel> \\<zero> \\<sim>\\<^sub>s P", "by(fastforce intro: closeSubstI bisimParNil)"], ["", "lemma bisimSubstParComm:\n  fixes \\<Psi> :: 'b\n  and   P :: \"('a, 'b, 'c) psi\"\n  and   Q :: \"('a, 'b, 'c) psi\"\n\n  shows \"\\<Psi> \\<rhd> P \\<parallel> Q \\<sim>\\<^sub>s Q \\<parallel> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> P \\<parallel> Q \\<sim>\\<^sub>s Q \\<parallel> P", "apply(rule closeSubstI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> P \\<parallel>\n                     Q[<\\<sigma>>] \\<sim> Q \\<parallel> P[<\\<sigma>>]", "by(fastforce intro: closeSubstI bisimParComm)"], ["", "lemma bisimSubstParAssoc:\n  fixes \\<Psi> :: 'b\n  and   P :: \"('a, 'b, 'c) psi\"\n  and   Q :: \"('a, 'b, 'c) psi\"\n  and   R :: \"('a, 'b, 'c) psi\"\n\n  shows \"\\<Psi> \\<rhd> (P \\<parallel> Q) \\<parallel> R \\<sim>\\<^sub>s P \\<parallel> (Q \\<parallel> R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> P \\<parallel> Q \\<parallel>\n                  R \\<sim>\\<^sub>s P \\<parallel> (Q \\<parallel> R)", "apply(rule closeSubstI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> P \\<parallel> Q \\<parallel>\n                     R[<\\<sigma>>] \\<sim> P \\<parallel>\n    (Q \\<parallel> R)[<\\<sigma>>]", "by(fastforce intro: closeSubstI bisimParAssoc)"], ["", "lemma bisimSubstResNil:\n  fixes \\<Psi> :: 'b\n  and   x :: name\n\n  shows \"\\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>\\<zero> \\<sim>\\<^sub>s \\<zero>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>\\<zero> \\<sim>\\<^sub>s \\<zero>", "proof(rule closeSubstI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>\\<zero>[<\\<sigma>>] \\<sim> \\<zero>[<\\<sigma>>]", "fix \\<sigma>:: \"(name list \\<times> 'a list) list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>\\<zero>[<\\<sigma>>] \\<sim> \\<zero>[<\\<sigma>>]", "assume \"wellFormedSubst \\<sigma>\""], ["proof (state)\nthis:\n  wellFormedSubst \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>\\<zero>[<\\<sigma>>] \\<sim> \\<zero>[<\\<sigma>>]", "obtain y::name where \"y \\<sharp> \\<Psi>\" and \"y \\<sharp> \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<sharp> \\<Psi>; y \\<sharp> \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(generate_fresh \"name\") (auto simp add: fresh_prod)"], ["proof (state)\nthis:\n  y \\<sharp> \\<Psi>\n  y \\<sharp> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>\\<zero>[<\\<sigma>>] \\<sim> \\<zero>[<\\<sigma>>]", "have \"\\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>\\<zero> \\<sim> \\<zero>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>\\<zero> \\<sim> \\<zero>", "by(rule bisimResNil)"], ["proof (state)\nthis:\n  \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>\\<zero> \\<sim> \\<zero>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>\\<zero>[<\\<sigma>>] \\<sim> \\<zero>[<\\<sigma>>]", "with \\<open>y \\<sharp> \\<sigma>\\<close> \\<open>wellFormedSubst \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  y \\<sharp> \\<sigma>\n  wellFormedSubst \\<sigma>\n  \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>\\<zero> \\<sim> \\<zero>", "show \"\\<Psi> \\<rhd> (\\<lparr>\\<nu>x\\<rparr>\\<zero>)[<\\<sigma>>] \\<sim> \\<zero>[<\\<sigma>>]\""], ["proof (prove)\nusing this:\n  y \\<sharp> \\<sigma>\n  wellFormedSubst \\<sigma>\n  \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>\\<zero> \\<sim> \\<zero>\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>\\<zero>[<\\<sigma>>] \\<sim> \\<zero>[<\\<sigma>>]", "by(subst alphaRes[of y]) auto"], ["proof (state)\nthis:\n  \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>\\<zero>[<\\<sigma>>] \\<sim> \\<zero>[<\\<sigma>>]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma seqSubst2:\n  fixes x :: name\n  and   P :: \"('a, 'b, 'c) psi\"\n\n  assumes \"wellFormedSubst \\<sigma>\"\n  and     \"x \\<sharp> \\<sigma>\"\n  and     \"x \\<sharp> P\"\n\n  shows \"x \\<sharp> P[<\\<sigma>>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> P[<\\<sigma>>]", "using assms"], ["proof (prove)\nusing this:\n  wellFormedSubst \\<sigma>\n  x \\<sharp> \\<sigma>\n  x \\<sharp> P\n\ngoal (1 subgoal):\n 1. x \\<sharp> P[<\\<sigma>>]", "by(induct \\<sigma> arbitrary: P, auto) (blast dest: subst2)"], ["", "notation substTerm.seqSubst (\"_[<_>]\" [100, 100] 100)"], ["", "lemma bisimSubstScopeExt:\n  fixes \\<Psi> :: 'b\n  and   x :: name\n  and   P :: \"('a, 'b, 'c) psi\"\n  and   Q :: \"('a, 'b, 'c) psi\"\n\n  assumes \"x \\<sharp> P\"\n\n  shows \"\\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(P \\<parallel> Q) \\<sim>\\<^sub>s P \\<parallel> \\<lparr>\\<nu>x\\<rparr>Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(P \\<parallel>\n   Q) \\<sim>\\<^sub>s P \\<parallel> \\<lparr>\\<nu>x\\<rparr>Q", "proof(rule closeSubstI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(P \\<parallel>\n      Q)[<\\<sigma>>] \\<sim> P \\<parallel>\n                            \\<lparr>\\<nu>x\\<rparr>Q[<\\<sigma>>]", "fix \\<sigma>:: \"(name list \\<times> 'a list) list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(P \\<parallel>\n      Q)[<\\<sigma>>] \\<sim> P \\<parallel>\n                            \\<lparr>\\<nu>x\\<rparr>Q[<\\<sigma>>]", "assume \"wellFormedSubst \\<sigma>\""], ["proof (state)\nthis:\n  wellFormedSubst \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(P \\<parallel>\n      Q)[<\\<sigma>>] \\<sim> P \\<parallel>\n                            \\<lparr>\\<nu>x\\<rparr>Q[<\\<sigma>>]", "obtain y::name where \"y \\<sharp> \\<Psi>\" and \"y \\<sharp> \\<sigma>\" and \"y \\<sharp> P\" and \"y \\<sharp> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<sharp> \\<Psi>; y \\<sharp> \\<sigma>; y \\<sharp> P;\n         y \\<sharp> Q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(generate_fresh \"name\") (auto simp add: fresh_prod)"], ["proof (state)\nthis:\n  y \\<sharp> \\<Psi>\n  y \\<sharp> \\<sigma>\n  y \\<sharp> P\n  y \\<sharp> Q\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(P \\<parallel>\n      Q)[<\\<sigma>>] \\<sim> P \\<parallel>\n                            \\<lparr>\\<nu>x\\<rparr>Q[<\\<sigma>>]", "moreover"], ["proof (state)\nthis:\n  y \\<sharp> \\<Psi>\n  y \\<sharp> \\<sigma>\n  y \\<sharp> P\n  y \\<sharp> Q\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(P \\<parallel>\n      Q)[<\\<sigma>>] \\<sim> P \\<parallel>\n                            \\<lparr>\\<nu>x\\<rparr>Q[<\\<sigma>>]", "from \\<open>wellFormedSubst \\<sigma>\\<close>  \\<open>y \\<sharp> \\<sigma>\\<close> \\<open>y \\<sharp> P\\<close>"], ["proof (chain)\npicking this:\n  wellFormedSubst \\<sigma>\n  y \\<sharp> \\<sigma>\n  y \\<sharp> P", "have \"y \\<sharp> P[<\\<sigma>>]\""], ["proof (prove)\nusing this:\n  wellFormedSubst \\<sigma>\n  y \\<sharp> \\<sigma>\n  y \\<sharp> P\n\ngoal (1 subgoal):\n 1. y \\<sharp> P[<\\<sigma>>]", "by(rule seqSubst2)"], ["proof (state)\nthis:\n  y \\<sharp> P[<\\<sigma>>]\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(P \\<parallel>\n      Q)[<\\<sigma>>] \\<sim> P \\<parallel>\n                            \\<lparr>\\<nu>x\\<rparr>Q[<\\<sigma>>]", "hence \"\\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>((P[<\\<sigma>>]) \\<parallel> (([(x, y)] \\<bullet> Q)[<\\<sigma>>])) \\<sim> (P[<\\<sigma>>]) \\<parallel> \\<lparr>\\<nu>y\\<rparr>(([(x, y)] \\<bullet> Q)[<\\<sigma>>])\""], ["proof (prove)\nusing this:\n  y \\<sharp> P[<\\<sigma>>]\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(P[<\\<sigma>>] \\<parallel>\n   [(x, y)] \\<bullet>\n   Q[<\\<sigma>>]) \\<sim> P[<\\<sigma>>] \\<parallel>\n                         \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet>\n         Q[<\\<sigma>>]", "by(rule bisimScopeExt)"], ["proof (state)\nthis:\n  \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(P[<\\<sigma>>] \\<parallel>\n [(x, y)] \\<bullet>\n Q[<\\<sigma>>]) \\<sim> P[<\\<sigma>>] \\<parallel>\n                       \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet>\n       Q[<\\<sigma>>]\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(P \\<parallel>\n      Q)[<\\<sigma>>] \\<sim> P \\<parallel>\n                            \\<lparr>\\<nu>x\\<rparr>Q[<\\<sigma>>]", "with \\<open>x \\<sharp> P\\<close> \\<open>y \\<sharp> P\\<close> \\<open>y \\<sharp> Q\\<close> \\<open>y \\<sharp> \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  x \\<sharp> P\n  y \\<sharp> P\n  y \\<sharp> Q\n  y \\<sharp> \\<sigma>\n  \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(P[<\\<sigma>>] \\<parallel>\n [(x, y)] \\<bullet>\n Q[<\\<sigma>>]) \\<sim> P[<\\<sigma>>] \\<parallel>\n                       \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet>\n       Q[<\\<sigma>>]", "show \"\\<Psi> \\<rhd> (\\<lparr>\\<nu>x\\<rparr>(P \\<parallel> Q))[<\\<sigma>>] \\<sim> (P \\<parallel> \\<lparr>\\<nu>x\\<rparr>Q)[<\\<sigma>>]\""], ["proof (prove)\nusing this:\n  x \\<sharp> P\n  y \\<sharp> P\n  y \\<sharp> Q\n  y \\<sharp> \\<sigma>\n  \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(P[<\\<sigma>>] \\<parallel>\n [(x, y)] \\<bullet>\n Q[<\\<sigma>>]) \\<sim> P[<\\<sigma>>] \\<parallel>\n                       \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet>\n       Q[<\\<sigma>>]\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(P \\<parallel>\n   Q)[<\\<sigma>>] \\<sim> P \\<parallel> \\<lparr>\\<nu>x\\<rparr>Q[<\\<sigma>>]", "apply(subst alphaRes[of y], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sharp> P; y \\<sharp> P; y \\<sharp> Q; y \\<sharp> \\<sigma>;\n     \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(P[<\\<sigma>>] \\<parallel>\n    [(x, y)] \\<bullet>\n    Q[<\\<sigma>>]) \\<sim> P[<\\<sigma>>] \\<parallel>\n                          \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet>\n          Q[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>([(x,\n                       y)] \\<bullet>\n                     P \\<parallel>\n                     Q)[<\\<sigma>>] \\<sim> P \\<parallel>\n     \\<lparr>\\<nu>x\\<rparr>Q[<\\<sigma>>]", "apply(subst alphaRes[of y Q], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sharp> P; y \\<sharp> P; y \\<sharp> Q; y \\<sharp> \\<sigma>;\n     \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(P[<\\<sigma>>] \\<parallel>\n    [(x, y)] \\<bullet>\n    Q[<\\<sigma>>]) \\<sim> P[<\\<sigma>>] \\<parallel>\n                          \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet>\n          Q[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>([(x,\n                       y)] \\<bullet>\n                     P \\<parallel>\n                     Q)[<\\<sigma>>] \\<sim> P \\<parallel>\n     \\<lparr>\\<nu>y\\<rparr>([(x, y)] \\<bullet> Q)[<\\<sigma>>]", "by(simp add: eqvts)"], ["proof (state)\nthis:\n  \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(P \\<parallel>\n Q)[<\\<sigma>>] \\<sim> P \\<parallel> \\<lparr>\\<nu>x\\<rparr>Q[<\\<sigma>>]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bisimSubstCasePushRes:\n  fixes x  :: name\n  and   \\<Psi>  :: 'b\n  and   Cs :: \"('c \\<times> ('a, 'b, 'c) psi) list\"\n\n  assumes \"x \\<sharp> map fst Cs\"\n\n  shows \"\\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(Cases Cs) \\<sim>\\<^sub>s Cases map (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>x\\<rparr>P)) Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(Cases Cs) \\<sim>\\<^sub>s Cases map\n                                   (\\<lambda>(\\<phi>, P).\n (\\<phi>, \\<lparr>\\<nu>x\\<rparr>P))\n                                   Cs", "proof(rule closeSubstI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(Cases Cs)[<\\<sigma>>] \\<sim> Cases map\n    (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>x\\<rparr>P)) Cs[<\\<sigma>>]", "fix \\<sigma>:: \"(name list \\<times> 'a list) list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(Cases Cs)[<\\<sigma>>] \\<sim> Cases map\n    (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>x\\<rparr>P)) Cs[<\\<sigma>>]", "assume \"wellFormedSubst \\<sigma>\""], ["proof (state)\nthis:\n  wellFormedSubst \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(Cases Cs)[<\\<sigma>>] \\<sim> Cases map\n    (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>x\\<rparr>P)) Cs[<\\<sigma>>]", "obtain y::name where \"y \\<sharp> \\<Psi>\" and \"y \\<sharp> \\<sigma>\" and \"y \\<sharp> Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<sharp> \\<Psi>; y \\<sharp> \\<sigma>;\n         y \\<sharp> Cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(generate_fresh \"name\") (auto simp add: fresh_prod)"], ["proof (state)\nthis:\n  y \\<sharp> \\<Psi>\n  y \\<sharp> \\<sigma>\n  y \\<sharp> Cs\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(Cases Cs)[<\\<sigma>>] \\<sim> Cases map\n    (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>x\\<rparr>P)) Cs[<\\<sigma>>]", "{"], ["proof (state)\nthis:\n  y \\<sharp> \\<Psi>\n  y \\<sharp> \\<sigma>\n  y \\<sharp> Cs\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(Cases Cs)[<\\<sigma>>] \\<sim> Cases map\n    (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>x\\<rparr>P)) Cs[<\\<sigma>>]", "fix x    :: name\n    and Cs   :: \"('c \\<times> ('a, 'b, 'c) psi) list\"\n    and \\<sigma>    :: \"(name list \\<times> 'a list) list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(Cases Cs)[<\\<sigma>>] \\<sim> Cases map\n    (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>x\\<rparr>P)) Cs[<\\<sigma>>]", "assume \"x \\<sharp> \\<sigma>\""], ["proof (state)\nthis:\n  x \\<sharp> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(Cases Cs)[<\\<sigma>>] \\<sim> Cases map\n    (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>x\\<rparr>P)) Cs[<\\<sigma>>]", "hence \"(Cases map (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>x\\<rparr>P)) Cs)[<\\<sigma>>] = Cases map (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>x\\<rparr>P)) (caseListSeqSubst Cs \\<sigma>)\""], ["proof (prove)\nusing this:\n  x \\<sharp> \\<sigma>\n\ngoal (1 subgoal):\n 1. Cases map (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>x\\<rparr>P))\n           Cs[<\\<sigma>>] =\n    Cases map (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>x\\<rparr>P))\n           (caseListSeqSubst Cs \\<sigma>)", "by(induct Cs) auto"], ["proof (state)\nthis:\n  Cases map (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>x\\<rparr>P))\n         Cs[<\\<sigma>>] =\n  Cases map (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>x\\<rparr>P))\n         (caseListSeqSubst Cs \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(Cases Cs)[<\\<sigma>>] \\<sim> Cases map\n    (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>x\\<rparr>P)) Cs[<\\<sigma>>]", "}"], ["proof (state)\nthis:\n  ?xa2 \\<sharp> ?\\<sigma>'2 \\<Longrightarrow>\n  Cases map (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>?xa2\\<rparr>P))\n         ?Csa2[<?\\<sigma>'2>] =\n  Cases map (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>?xa2\\<rparr>P))\n         (caseListSeqSubst ?Csa2 ?\\<sigma>'2)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(Cases Cs)[<\\<sigma>>] \\<sim> Cases map\n    (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>x\\<rparr>P)) Cs[<\\<sigma>>]", "note C1 = this"], ["proof (state)\nthis:\n  ?xa2 \\<sharp> ?\\<sigma>'2 \\<Longrightarrow>\n  Cases map (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>?xa2\\<rparr>P))\n         ?Csa2[<?\\<sigma>'2>] =\n  Cases map (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>?xa2\\<rparr>P))\n         (caseListSeqSubst ?Csa2 ?\\<sigma>'2)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(Cases Cs)[<\\<sigma>>] \\<sim> Cases map\n    (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>x\\<rparr>P)) Cs[<\\<sigma>>]", "{"], ["proof (state)\nthis:\n  ?xa2 \\<sharp> ?\\<sigma>'2 \\<Longrightarrow>\n  Cases map (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>?xa2\\<rparr>P))\n         ?Csa2[<?\\<sigma>'2>] =\n  Cases map (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>?xa2\\<rparr>P))\n         (caseListSeqSubst ?Csa2 ?\\<sigma>'2)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(Cases Cs)[<\\<sigma>>] \\<sim> Cases map\n    (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>x\\<rparr>P)) Cs[<\\<sigma>>]", "fix x    :: name\n    and y    :: name\n    and Cs   :: \"('c \\<times> ('a, 'b, 'c) psi) list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(Cases Cs)[<\\<sigma>>] \\<sim> Cases map\n    (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>x\\<rparr>P)) Cs[<\\<sigma>>]", "assume \"x \\<sharp> map fst Cs\"\n    and    \"y \\<sharp> map fst Cs\"\n    and    \"y \\<sharp> Cs\""], ["proof (state)\nthis:\n  x \\<sharp> map fst Cs\n  y \\<sharp> map fst Cs\n  y \\<sharp> Cs\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(Cases Cs)[<\\<sigma>>] \\<sim> Cases map\n    (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>x\\<rparr>P)) Cs[<\\<sigma>>]", "hence \"(Cases map (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>x\\<rparr>P)) Cs) = Cases map (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>y\\<rparr>P)) ([(x, y)] \\<bullet> Cs)\""], ["proof (prove)\nusing this:\n  x \\<sharp> map fst Cs\n  y \\<sharp> map fst Cs\n  y \\<sharp> Cs\n\ngoal (1 subgoal):\n 1. Cases map (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>x\\<rparr>P)) Cs =\n    Cases map (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>y\\<rparr>P))\n           ([(x, y)] \\<bullet> Cs)", "by(induct Cs) (auto simp add: fresh_list_cons alphaRes)"], ["proof (state)\nthis:\n  Cases map (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>x\\<rparr>P)) Cs =\n  Cases map (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>y\\<rparr>P))\n         ([(x, y)] \\<bullet> Cs)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(Cases Cs)[<\\<sigma>>] \\<sim> Cases map\n    (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>x\\<rparr>P)) Cs[<\\<sigma>>]", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?xa2 \\<sharp> map fst ?Csa2; ?ya2 \\<sharp> map fst ?Csa2;\n   ?ya2 \\<sharp> ?Csa2\\<rbrakk>\n  \\<Longrightarrow> Cases map (\\<lambda>(\\<phi>, P).\n                                  (\\<phi>, \\<lparr>\\<nu>?xa2\\<rparr>P))\n                           ?Csa2 =\n                    Cases map (\\<lambda>(\\<phi>, P).\n                                  (\\<phi>, \\<lparr>\\<nu>?ya2\\<rparr>P))\n                           ([(?xa2, ?ya2)] \\<bullet> ?Csa2)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(Cases Cs)[<\\<sigma>>] \\<sim> Cases map\n    (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>x\\<rparr>P)) Cs[<\\<sigma>>]", "note C2 = this"], ["proof (state)\nthis:\n  \\<lbrakk>?xa2 \\<sharp> map fst ?Csa2; ?ya2 \\<sharp> map fst ?Csa2;\n   ?ya2 \\<sharp> ?Csa2\\<rbrakk>\n  \\<Longrightarrow> Cases map (\\<lambda>(\\<phi>, P).\n                                  (\\<phi>, \\<lparr>\\<nu>?xa2\\<rparr>P))\n                           ?Csa2 =\n                    Cases map (\\<lambda>(\\<phi>, P).\n                                  (\\<phi>, \\<lparr>\\<nu>?ya2\\<rparr>P))\n                           ([(?xa2, ?ya2)] \\<bullet> ?Csa2)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(Cases Cs)[<\\<sigma>>] \\<sim> Cases map\n    (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>x\\<rparr>P)) Cs[<\\<sigma>>]", "from \\<open>y \\<sharp> Cs\\<close>"], ["proof (chain)\npicking this:\n  y \\<sharp> Cs", "have \"y \\<sharp> map fst Cs\""], ["proof (prove)\nusing this:\n  y \\<sharp> Cs\n\ngoal (1 subgoal):\n 1. y \\<sharp> map fst Cs", "by(induct Cs) (auto simp add: fresh_list_cons fresh_list_nil)"], ["proof (state)\nthis:\n  y \\<sharp> map fst Cs\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(Cases Cs)[<\\<sigma>>] \\<sim> Cases map\n    (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>x\\<rparr>P)) Cs[<\\<sigma>>]", "from \\<open>y \\<sharp> Cs\\<close> \\<open>y \\<sharp> \\<sigma>\\<close> \\<open>x \\<sharp> map fst Cs\\<close> \\<open>wellFormedSubst \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  y \\<sharp> Cs\n  y \\<sharp> \\<sigma>\n  x \\<sharp> map fst Cs\n  wellFormedSubst \\<sigma>", "have \"y \\<sharp> map fst (caseListSeqSubst ([(x, y)] \\<bullet> Cs) \\<sigma>)\""], ["proof (prove)\nusing this:\n  y \\<sharp> Cs\n  y \\<sharp> \\<sigma>\n  x \\<sharp> map fst Cs\n  wellFormedSubst \\<sigma>\n\ngoal (1 subgoal):\n 1. y \\<sharp> map fst (caseListSeqSubst ([(x, y)] \\<bullet> Cs) \\<sigma>)", "by(induct Cs) (auto intro: substCond.seqSubst2 simp add: fresh_list_cons fresh_list_nil fresh_prod)"], ["proof (state)\nthis:\n  y \\<sharp> map fst (caseListSeqSubst ([(x, y)] \\<bullet> Cs) \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(Cases Cs)[<\\<sigma>>] \\<sim> Cases map\n    (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>x\\<rparr>P)) Cs[<\\<sigma>>]", "hence \"\\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(Cases(caseListSeqSubst ([(x, y)] \\<bullet> Cs) \\<sigma>)) \\<sim> Cases map (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>y\\<rparr>P)) (caseListSeqSubst ([(x, y)] \\<bullet> Cs) \\<sigma>)\""], ["proof (prove)\nusing this:\n  y \\<sharp> map fst (caseListSeqSubst ([(x, y)] \\<bullet> Cs) \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(Cases caseListSeqSubst\n          ([(x, y)] \\<bullet> Cs)\n          \\<sigma>) \\<sim> Cases map (\\<lambda>(\\<phi>, P).\n   (\\<phi>, \\<lparr>\\<nu>y\\<rparr>P))\n                                  (caseListSeqSubst ([(x, y)] \\<bullet> Cs)\n                                    \\<sigma>)", "by(rule bisimCasePushRes)"], ["proof (state)\nthis:\n  \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(Cases caseListSeqSubst\n        ([(x, y)] \\<bullet> Cs)\n        \\<sigma>) \\<sim> Cases map (\\<lambda>(\\<phi>, P).\n (\\<phi>, \\<lparr>\\<nu>y\\<rparr>P))\n                                (caseListSeqSubst ([(x, y)] \\<bullet> Cs)\n                                  \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(Cases Cs)[<\\<sigma>>] \\<sim> Cases map\n    (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>x\\<rparr>P)) Cs[<\\<sigma>>]", "with \\<open>y \\<sharp> Cs\\<close> \\<open>x \\<sharp> map fst Cs\\<close> \\<open>y \\<sharp> map fst Cs\\<close> \\<open>y \\<sharp> \\<sigma>\\<close> \\<open>wellFormedSubst \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  y \\<sharp> Cs\n  x \\<sharp> map fst Cs\n  y \\<sharp> map fst Cs\n  y \\<sharp> \\<sigma>\n  wellFormedSubst \\<sigma>\n  \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(Cases caseListSeqSubst\n        ([(x, y)] \\<bullet> Cs)\n        \\<sigma>) \\<sim> Cases map (\\<lambda>(\\<phi>, P).\n (\\<phi>, \\<lparr>\\<nu>y\\<rparr>P))\n                                (caseListSeqSubst ([(x, y)] \\<bullet> Cs)\n                                  \\<sigma>)", "show \"\\<Psi> \\<rhd> (\\<lparr>\\<nu>x\\<rparr>(Cases Cs))[<\\<sigma>>] \\<sim> (Cases map (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>x\\<rparr>P)) Cs)[<\\<sigma>>]\""], ["proof (prove)\nusing this:\n  y \\<sharp> Cs\n  x \\<sharp> map fst Cs\n  y \\<sharp> map fst Cs\n  y \\<sharp> \\<sigma>\n  wellFormedSubst \\<sigma>\n  \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(Cases caseListSeqSubst\n        ([(x, y)] \\<bullet> Cs)\n        \\<sigma>) \\<sim> Cases map (\\<lambda>(\\<phi>, P).\n (\\<phi>, \\<lparr>\\<nu>y\\<rparr>P))\n                                (caseListSeqSubst ([(x, y)] \\<bullet> Cs)\n                                  \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(Cases Cs)[<\\<sigma>>] \\<sim> Cases map\n (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>x\\<rparr>P)) Cs[<\\<sigma>>]", "apply(subst C2[of x Cs y])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>y \\<sharp> Cs; x \\<sharp> map fst Cs; y \\<sharp> map fst Cs;\n     y \\<sharp> \\<sigma>; wellFormedSubst \\<sigma>;\n     \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(Cases caseListSeqSubst\n           ([(x, y)] \\<bullet> Cs)\n           \\<sigma>) \\<sim> Cases map (\\<lambda>(\\<phi>, P).\n    (\\<phi>, \\<lparr>\\<nu>y\\<rparr>P))\n                                   (caseListSeqSubst ([(x, y)] \\<bullet> Cs)\n                                     \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> x \\<sharp> map fst Cs\n 2. \\<lbrakk>y \\<sharp> Cs; x \\<sharp> map fst Cs; y \\<sharp> map fst Cs;\n     y \\<sharp> \\<sigma>; wellFormedSubst \\<sigma>;\n     \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(Cases caseListSeqSubst\n           ([(x, y)] \\<bullet> Cs)\n           \\<sigma>) \\<sim> Cases map (\\<lambda>(\\<phi>, P).\n    (\\<phi>, \\<lparr>\\<nu>y\\<rparr>P))\n                                   (caseListSeqSubst ([(x, y)] \\<bullet> Cs)\n                                     \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> y \\<sharp> map fst Cs\n 3. \\<lbrakk>y \\<sharp> Cs; x \\<sharp> map fst Cs; y \\<sharp> map fst Cs;\n     y \\<sharp> \\<sigma>; wellFormedSubst \\<sigma>;\n     \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(Cases caseListSeqSubst\n           ([(x, y)] \\<bullet> Cs)\n           \\<sigma>) \\<sim> Cases map (\\<lambda>(\\<phi>, P).\n    (\\<phi>, \\<lparr>\\<nu>y\\<rparr>P))\n                                   (caseListSeqSubst ([(x, y)] \\<bullet> Cs)\n                                     \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> y \\<sharp> Cs\n 4. \\<lbrakk>y \\<sharp> Cs; x \\<sharp> map fst Cs; y \\<sharp> map fst Cs;\n     y \\<sharp> \\<sigma>; wellFormedSubst \\<sigma>;\n     \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(Cases caseListSeqSubst\n           ([(x, y)] \\<bullet> Cs)\n           \\<sigma>) \\<sim> Cases map (\\<lambda>(\\<phi>, P).\n    (\\<phi>, \\<lparr>\\<nu>y\\<rparr>P))\n                                   (caseListSeqSubst ([(x, y)] \\<bullet> Cs)\n                                     \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(Cases Cs)[<\\<sigma>>] \\<sim> Cases map\n                   (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>y\\<rparr>P))\n                   ([(x, y)] \\<bullet> Cs)[<\\<sigma>>]", "apply assumption+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<sharp> Cs; x \\<sharp> map fst Cs; y \\<sharp> map fst Cs;\n     y \\<sharp> \\<sigma>; wellFormedSubst \\<sigma>;\n     \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(Cases caseListSeqSubst\n           ([(x, y)] \\<bullet> Cs)\n           \\<sigma>) \\<sim> Cases map (\\<lambda>(\\<phi>, P).\n    (\\<phi>, \\<lparr>\\<nu>y\\<rparr>P))\n                                   (caseListSeqSubst ([(x, y)] \\<bullet> Cs)\n                                     \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(Cases Cs)[<\\<sigma>>] \\<sim> Cases map\n                   (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>y\\<rparr>P))\n                   ([(x, y)] \\<bullet> Cs)[<\\<sigma>>]", "apply(subst C1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y \\<sharp> Cs; x \\<sharp> map fst Cs; y \\<sharp> map fst Cs;\n     y \\<sharp> \\<sigma>; wellFormedSubst \\<sigma>;\n     \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(Cases caseListSeqSubst\n           ([(x, y)] \\<bullet> Cs)\n           \\<sigma>) \\<sim> Cases map (\\<lambda>(\\<phi>, P).\n    (\\<phi>, \\<lparr>\\<nu>y\\<rparr>P))\n                                   (caseListSeqSubst ([(x, y)] \\<bullet> Cs)\n                                     \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> y \\<sharp> \\<sigma>\n 2. \\<lbrakk>y \\<sharp> Cs; x \\<sharp> map fst Cs; y \\<sharp> map fst Cs;\n     y \\<sharp> \\<sigma>; wellFormedSubst \\<sigma>;\n     \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(Cases caseListSeqSubst\n           ([(x, y)] \\<bullet> Cs)\n           \\<sigma>) \\<sim> Cases map (\\<lambda>(\\<phi>, P).\n    (\\<phi>, \\<lparr>\\<nu>y\\<rparr>P))\n                                   (caseListSeqSubst ([(x, y)] \\<bullet> Cs)\n                                     \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(Cases Cs)[<\\<sigma>>] \\<sim> Cases map\n                   (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>y\\<rparr>P))\n                   (caseListSeqSubst ([(x, y)] \\<bullet> Cs) \\<sigma>)", "apply assumption+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<sharp> Cs; x \\<sharp> map fst Cs; y \\<sharp> map fst Cs;\n     y \\<sharp> \\<sigma>; wellFormedSubst \\<sigma>;\n     \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(Cases caseListSeqSubst\n           ([(x, y)] \\<bullet> Cs)\n           \\<sigma>) \\<sim> Cases map (\\<lambda>(\\<phi>, P).\n    (\\<phi>, \\<lparr>\\<nu>y\\<rparr>P))\n                                   (caseListSeqSubst ([(x, y)] \\<bullet> Cs)\n                                     \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(Cases Cs)[<\\<sigma>>] \\<sim> Cases map\n                   (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>y\\<rparr>P))\n                   (caseListSeqSubst ([(x, y)] \\<bullet> Cs) \\<sigma>)", "apply(subst alphaRes[of y], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<sharp> Cs; x \\<sharp> map fst Cs; y \\<sharp> map fst Cs;\n     y \\<sharp> \\<sigma>; wellFormedSubst \\<sigma>;\n     \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(Cases caseListSeqSubst\n           ([(x, y)] \\<bullet> Cs)\n           \\<sigma>) \\<sim> Cases map (\\<lambda>(\\<phi>, P).\n    (\\<phi>, \\<lparr>\\<nu>y\\<rparr>P))\n                                   (caseListSeqSubst ([(x, y)] \\<bullet> Cs)\n                                     \\<sigma>)\\<rbrakk>\n    \\<Longrightarrow> \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>([(x,\n                       y)] \\<bullet>\n                     Cases Cs)[<\\<sigma>>] \\<sim> Cases map\n                   (\\<lambda>(\\<phi>, P). (\\<phi>, \\<lparr>\\<nu>y\\<rparr>P))\n                   (caseListSeqSubst ([(x, y)] \\<bullet> Cs) \\<sigma>)", "by(simp add: eqvts)"], ["proof (state)\nthis:\n  \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(Cases Cs)[<\\<sigma>>] \\<sim> Cases map\n                                     (\\<lambda>(\\<phi>, P).\n   (\\<phi>, \\<lparr>\\<nu>x\\<rparr>P))\n                                     Cs[<\\<sigma>>]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bisimSubstOutputPushRes:\n  fixes x :: name\n  and   \\<Psi> :: 'b\n  and   M :: 'a\n  and   N :: 'a\n  and   P :: \"('a, 'b, 'c) psi\"\n\n  assumes \"x \\<sharp> M\"\n  and     \"x \\<sharp> N\"\n\n  shows \"\\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(M\\<langle>N\\<rangle>.P) \\<sim>\\<^sub>s M\\<langle>N\\<rangle>.\\<lparr>\\<nu>x\\<rparr>P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(M\\<langle>N\\<rangle>.P) \\<sim>\\<^sub>s M\\<langle>N\\<rangle>.\\<lparr>\\<nu>x\\<rparr>P", "proof(rule closeSubstI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(M\\<langle>N\\<rangle>.P)[<\\<sigma>>] \\<sim> M\\<langle>N\\<rangle>.\\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>]", "fix \\<sigma>:: \"(name list \\<times> 'a list) list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(M\\<langle>N\\<rangle>.P)[<\\<sigma>>] \\<sim> M\\<langle>N\\<rangle>.\\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>]", "assume \"wellFormedSubst \\<sigma>\""], ["proof (state)\nthis:\n  wellFormedSubst \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(M\\<langle>N\\<rangle>.P)[<\\<sigma>>] \\<sim> M\\<langle>N\\<rangle>.\\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>]", "obtain y::name where \"y \\<sharp> \\<Psi>\" and \"y \\<sharp> \\<sigma>\" and \"y \\<sharp> P\" and \"y \\<sharp> M\" and \"y \\<sharp> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<sharp> \\<Psi>; y \\<sharp> \\<sigma>; y \\<sharp> P;\n         y \\<sharp> M; y \\<sharp> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(generate_fresh \"name\") (auto simp add: fresh_prod)"], ["proof (state)\nthis:\n  y \\<sharp> \\<Psi>\n  y \\<sharp> \\<sigma>\n  y \\<sharp> P\n  y \\<sharp> M\n  y \\<sharp> N\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(M\\<langle>N\\<rangle>.P)[<\\<sigma>>] \\<sim> M\\<langle>N\\<rangle>.\\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>]", "from \\<open>wellFormedSubst \\<sigma>\\<close>  \\<open>y \\<sharp> M\\<close> \\<open>y \\<sharp> \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  wellFormedSubst \\<sigma>\n  y \\<sharp> M\n  y \\<sharp> \\<sigma>", "have \"y \\<sharp> M[<\\<sigma>>]\""], ["proof (prove)\nusing this:\n  wellFormedSubst \\<sigma>\n  y \\<sharp> M\n  y \\<sharp> \\<sigma>\n\ngoal (1 subgoal):\n 1. y \\<sharp> M[<\\<sigma>>]", "by auto"], ["proof (state)\nthis:\n  y \\<sharp> M[<\\<sigma>>]\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(M\\<langle>N\\<rangle>.P)[<\\<sigma>>] \\<sim> M\\<langle>N\\<rangle>.\\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>]", "moreover"], ["proof (state)\nthis:\n  y \\<sharp> M[<\\<sigma>>]\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(M\\<langle>N\\<rangle>.P)[<\\<sigma>>] \\<sim> M\\<langle>N\\<rangle>.\\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>]", "from \\<open>wellFormedSubst \\<sigma>\\<close>  \\<open>y \\<sharp> N\\<close> \\<open>y \\<sharp> \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  wellFormedSubst \\<sigma>\n  y \\<sharp> N\n  y \\<sharp> \\<sigma>", "have \"y \\<sharp> N[<\\<sigma>>]\""], ["proof (prove)\nusing this:\n  wellFormedSubst \\<sigma>\n  y \\<sharp> N\n  y \\<sharp> \\<sigma>\n\ngoal (1 subgoal):\n 1. y \\<sharp> N[<\\<sigma>>]", "by auto"], ["proof (state)\nthis:\n  y \\<sharp> N[<\\<sigma>>]\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(M\\<langle>N\\<rangle>.P)[<\\<sigma>>] \\<sim> M\\<langle>N\\<rangle>.\\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>]", "ultimately"], ["proof (chain)\npicking this:\n  y \\<sharp> M[<\\<sigma>>]\n  y \\<sharp> N[<\\<sigma>>]", "have \"\\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>((M[<\\<sigma>>])\\<langle>(N[<\\<sigma>>])\\<rangle>.(([(x, y)] \\<bullet> P)[<\\<sigma>>])) \\<sim> (M[<\\<sigma>>])\\<langle>(N[<\\<sigma>>])\\<rangle>.(\\<lparr>\\<nu>y\\<rparr>(([(x, y)] \\<bullet> P)[<\\<sigma>>]))\""], ["proof (prove)\nusing this:\n  y \\<sharp> M[<\\<sigma>>]\n  y \\<sharp> N[<\\<sigma>>]\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>((M[<\\<sigma>>])\\<langle>(N[<\\<sigma>>])\\<rangle>.[(x,\n                y)] \\<bullet>\n              P[<\\<sigma>>]) \\<sim> (M[<\\<sigma>>])\\<langle>(N[<\\<sigma>>])\\<rangle>.\\<lparr>\\<nu>y\\<rparr>[(x,\n                                 y)] \\<bullet>\n                               P[<\\<sigma>>]", "by(rule bisimOutputPushRes)"], ["proof (state)\nthis:\n  \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>((M[<\\<sigma>>])\\<langle>(N[<\\<sigma>>])\\<rangle>.[(x,\n              y)] \\<bullet>\n            P[<\\<sigma>>]) \\<sim> (M[<\\<sigma>>])\\<langle>(N[<\\<sigma>>])\\<rangle>.\\<lparr>\\<nu>y\\<rparr>[(x,\n                               y)] \\<bullet>\n                             P[<\\<sigma>>]\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(M\\<langle>N\\<rangle>.P)[<\\<sigma>>] \\<sim> M\\<langle>N\\<rangle>.\\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>]", "with \\<open>y \\<sharp> M\\<close> \\<open>y \\<sharp> N\\<close> \\<open>y \\<sharp> P\\<close> \\<open>x \\<sharp> M\\<close> \\<open>x \\<sharp> N\\<close> \\<open>y \\<sharp> \\<sigma>\\<close> \\<open>wellFormedSubst \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  y \\<sharp> M\n  y \\<sharp> N\n  y \\<sharp> P\n  x \\<sharp> M\n  x \\<sharp> N\n  y \\<sharp> \\<sigma>\n  wellFormedSubst \\<sigma>\n  \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>((M[<\\<sigma>>])\\<langle>(N[<\\<sigma>>])\\<rangle>.[(x,\n              y)] \\<bullet>\n            P[<\\<sigma>>]) \\<sim> (M[<\\<sigma>>])\\<langle>(N[<\\<sigma>>])\\<rangle>.\\<lparr>\\<nu>y\\<rparr>[(x,\n                               y)] \\<bullet>\n                             P[<\\<sigma>>]", "show \"\\<Psi> \\<rhd> (\\<lparr>\\<nu>x\\<rparr>(M\\<langle>N\\<rangle>.P))[<\\<sigma>>] \\<sim> (M\\<langle>N\\<rangle>.\\<lparr>\\<nu>x\\<rparr>P)[<\\<sigma>>]\""], ["proof (prove)\nusing this:\n  y \\<sharp> M\n  y \\<sharp> N\n  y \\<sharp> P\n  x \\<sharp> M\n  x \\<sharp> N\n  y \\<sharp> \\<sigma>\n  wellFormedSubst \\<sigma>\n  \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>((M[<\\<sigma>>])\\<langle>(N[<\\<sigma>>])\\<rangle>.[(x,\n              y)] \\<bullet>\n            P[<\\<sigma>>]) \\<sim> (M[<\\<sigma>>])\\<langle>(N[<\\<sigma>>])\\<rangle>.\\<lparr>\\<nu>y\\<rparr>[(x,\n                               y)] \\<bullet>\n                             P[<\\<sigma>>]\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(M\\<langle>N\\<rangle>.P)[<\\<sigma>>] \\<sim> M\\<langle>N\\<rangle>.\\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>]", "apply(subst alphaRes[of y], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<sharp> M; y \\<sharp> N; y \\<sharp> P; x \\<sharp> M;\n     x \\<sharp> N; y \\<sharp> \\<sigma>; wellFormedSubst \\<sigma>;\n     \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>((M[<\\<sigma>>])\\<langle>(N[<\\<sigma>>])\\<rangle>.[(x,\n                 y)] \\<bullet>\n               P[<\\<sigma>>]) \\<sim> (M[<\\<sigma>>])\\<langle>(N[<\\<sigma>>])\\<rangle>.\\<lparr>\\<nu>y\\<rparr>[(x,\n                                  y)] \\<bullet>\n                                P[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>([(x,\n                       y)] \\<bullet>\n                     M\\<langle>N\\<rangle>.P)[<\\<sigma>>] \\<sim> M\\<langle>N\\<rangle>.\\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>]", "apply(subst alphaRes[of y P], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<sharp> M; y \\<sharp> N; y \\<sharp> P; x \\<sharp> M;\n     x \\<sharp> N; y \\<sharp> \\<sigma>; wellFormedSubst \\<sigma>;\n     \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>((M[<\\<sigma>>])\\<langle>(N[<\\<sigma>>])\\<rangle>.[(x,\n                 y)] \\<bullet>\n               P[<\\<sigma>>]) \\<sim> (M[<\\<sigma>>])\\<langle>(N[<\\<sigma>>])\\<rangle>.\\<lparr>\\<nu>y\\<rparr>[(x,\n                                  y)] \\<bullet>\n                                P[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>([(x,\n                       y)] \\<bullet>\n                     M\\<langle>N\\<rangle>.P)[<\\<sigma>>] \\<sim> M\\<langle>N\\<rangle>.\\<lparr>\\<nu>y\\<rparr>([(x,\n                                  y)] \\<bullet>\n                                P)[<\\<sigma>>]", "by(simp add: eqvts)"], ["proof (state)\nthis:\n  \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(M\\<langle>N\\<rangle>.P)[<\\<sigma>>] \\<sim> M\\<langle>N\\<rangle>.\\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bisimSubstInputPushRes:\n  fixes x    :: name\n  and   \\<Psi>    :: 'b\n  and   M    :: 'a\n  and   xvec :: \"name list\"\n  and   N    :: 'a\n\n  assumes \"x \\<sharp> M\"\n  and     \"x \\<sharp> xvec\"\n  and     \"x \\<sharp> N\"\n\n  shows \"\\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(M\\<lparr>\\<lambda>*xvec N\\<rparr>.P) \\<sim>\\<^sub>s M\\<lparr>\\<lambda>*xvec N\\<rparr>.\\<lparr>\\<nu>x\\<rparr>P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(M\\<lparr>\\<lambda>*xvec N\\<rparr>.P) \\<sim>\\<^sub>s M\\<lparr>\\<lambda>*xvec N\\<rparr>.\\<lparr>\\<nu>x\\<rparr>P", "proof(rule closeSubstI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(M\\<lparr>\\<lambda>*xvec N\\<rparr>.P)[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*xvec N\\<rparr>.\\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>]", "fix \\<sigma>:: \"(name list \\<times> 'a list) list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(M\\<lparr>\\<lambda>*xvec N\\<rparr>.P)[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*xvec N\\<rparr>.\\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>]", "assume \"wellFormedSubst \\<sigma>\""], ["proof (state)\nthis:\n  wellFormedSubst \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(M\\<lparr>\\<lambda>*xvec N\\<rparr>.P)[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*xvec N\\<rparr>.\\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>]", "obtain y::name where \"y \\<sharp> \\<Psi>\" and \"y \\<sharp> \\<sigma>\" and \"y \\<sharp> P\" and \"y \\<sharp> M\" and \"y \\<sharp> xvec\" and \"y \\<sharp> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<sharp> \\<Psi>; y \\<sharp> \\<sigma>; y \\<sharp> P;\n         y \\<sharp> M; y \\<sharp> xvec; y \\<sharp> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(generate_fresh \"name\") (auto simp add: fresh_prod)"], ["proof (state)\nthis:\n  y \\<sharp> \\<Psi>\n  y \\<sharp> \\<sigma>\n  y \\<sharp> P\n  y \\<sharp> M\n  y \\<sharp> xvec\n  y \\<sharp> N\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(M\\<lparr>\\<lambda>*xvec N\\<rparr>.P)[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*xvec N\\<rparr>.\\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>]", "obtain p::\"name prm\" where \"(p \\<bullet> xvec) \\<sharp>* N\" and  \"(p \\<bullet> xvec) \\<sharp>* P\" and \"x \\<sharp> (p \\<bullet> xvec)\" and \"y \\<sharp> (p \\<bullet> xvec)\" and \"(p \\<bullet> xvec) \\<sharp>* \\<sigma>\"\n                         and S: \"set p \\<subseteq> set xvec \\<times> set(p \\<bullet> xvec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>(p \\<bullet> xvec) \\<sharp>* N;\n         (p \\<bullet> xvec) \\<sharp>* P; x \\<sharp> p \\<bullet> xvec;\n         y \\<sharp> p \\<bullet> xvec; (p \\<bullet> xvec) \\<sharp>* \\<sigma>;\n         set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule_tac c=\"(N, P, x, y, \\<sigma>)\" in name_list_avoiding) auto"], ["proof (state)\nthis:\n  (p \\<bullet> xvec) \\<sharp>* N\n  (p \\<bullet> xvec) \\<sharp>* P\n  x \\<sharp> p \\<bullet> xvec\n  y \\<sharp> p \\<bullet> xvec\n  (p \\<bullet> xvec) \\<sharp>* \\<sigma>\n  set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(M\\<lparr>\\<lambda>*xvec N\\<rparr>.P)[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*xvec N\\<rparr>.\\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>]", "from \\<open>wellFormedSubst \\<sigma>\\<close> \\<open>y \\<sharp> M\\<close> \\<open>y \\<sharp> \\<sigma> \\<close>"], ["proof (chain)\npicking this:\n  wellFormedSubst \\<sigma>\n  y \\<sharp> M\n  y \\<sharp> \\<sigma>", "have \"y \\<sharp> M[<\\<sigma>>]\""], ["proof (prove)\nusing this:\n  wellFormedSubst \\<sigma>\n  y \\<sharp> M\n  y \\<sharp> \\<sigma>\n\ngoal (1 subgoal):\n 1. y \\<sharp> M[<\\<sigma>>]", "by auto"], ["proof (state)\nthis:\n  y \\<sharp> M[<\\<sigma>>]\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(M\\<lparr>\\<lambda>*xvec N\\<rparr>.P)[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*xvec N\\<rparr>.\\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>]", "moreover"], ["proof (state)\nthis:\n  y \\<sharp> M[<\\<sigma>>]\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(M\\<lparr>\\<lambda>*xvec N\\<rparr>.P)[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*xvec N\\<rparr>.\\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>]", "note \\<open>y \\<sharp> (p \\<bullet> xvec)\\<close>"], ["proof (state)\nthis:\n  y \\<sharp> p \\<bullet> xvec\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(M\\<lparr>\\<lambda>*xvec N\\<rparr>.P)[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*xvec N\\<rparr>.\\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>]", "moreover"], ["proof (state)\nthis:\n  y \\<sharp> p \\<bullet> xvec\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(M\\<lparr>\\<lambda>*xvec N\\<rparr>.P)[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*xvec N\\<rparr>.\\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>]", "from \\<open>y \\<sharp> N\\<close>"], ["proof (chain)\npicking this:\n  y \\<sharp> N", "have \"(p \\<bullet> y) \\<sharp> (p \\<bullet> N)\""], ["proof (prove)\nusing this:\n  y \\<sharp> N\n\ngoal (1 subgoal):\n 1. p \\<bullet> y \\<sharp> p \\<bullet> N", "by(simp add: pt_fresh_bij[OF pt_name_inst, OF at_name_inst])"], ["proof (state)\nthis:\n  p \\<bullet> y \\<sharp> p \\<bullet> N\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(M\\<lparr>\\<lambda>*xvec N\\<rparr>.P)[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*xvec N\\<rparr>.\\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>]", "with \\<open>y \\<sharp> xvec\\<close> \\<open>y \\<sharp> (p \\<bullet> xvec)\\<close> S"], ["proof (chain)\npicking this:\n  y \\<sharp> xvec\n  y \\<sharp> p \\<bullet> xvec\n  set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\n  p \\<bullet> y \\<sharp> p \\<bullet> N", "have \"y \\<sharp> p \\<bullet> N\""], ["proof (prove)\nusing this:\n  y \\<sharp> xvec\n  y \\<sharp> p \\<bullet> xvec\n  set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\n  p \\<bullet> y \\<sharp> p \\<bullet> N\n\ngoal (1 subgoal):\n 1. y \\<sharp> p \\<bullet> N", "by simp"], ["proof (state)\nthis:\n  y \\<sharp> p \\<bullet> N\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(M\\<lparr>\\<lambda>*xvec N\\<rparr>.P)[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*xvec N\\<rparr>.\\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>]", "with \\<open>wellFormedSubst \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  wellFormedSubst \\<sigma>\n  y \\<sharp> p \\<bullet> N", "have \"y \\<sharp> (p \\<bullet> N)[<\\<sigma>>]\""], ["proof (prove)\nusing this:\n  wellFormedSubst \\<sigma>\n  y \\<sharp> p \\<bullet> N\n\ngoal (1 subgoal):\n 1. y \\<sharp> (p \\<bullet> N)[<\\<sigma>>]", "using \\<open>y \\<sharp> \\<sigma>\\<close>"], ["proof (prove)\nusing this:\n  wellFormedSubst \\<sigma>\n  y \\<sharp> p \\<bullet> N\n  y \\<sharp> \\<sigma>\n\ngoal (1 subgoal):\n 1. y \\<sharp> (p \\<bullet> N)[<\\<sigma>>]", "by auto"], ["proof (state)\nthis:\n  y \\<sharp> (p \\<bullet> N)[<\\<sigma>>]\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(M\\<lparr>\\<lambda>*xvec N\\<rparr>.P)[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*xvec N\\<rparr>.\\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>]", "ultimately"], ["proof (chain)\npicking this:\n  y \\<sharp> M[<\\<sigma>>]\n  y \\<sharp> p \\<bullet> xvec\n  y \\<sharp> (p \\<bullet> N)[<\\<sigma>>]", "have \"\\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>((M[<\\<sigma>>])\\<lparr>\\<lambda>*(p \\<bullet> xvec) ((p \\<bullet> N)[<\\<sigma>>])\\<rparr>.(([(x, y)] \\<bullet> (p \\<bullet> P))[<\\<sigma>>])) \\<sim> (M[<\\<sigma>>])\\<lparr>\\<lambda>*(p \\<bullet> xvec) ((p \\<bullet> N)[<\\<sigma>>])\\<rparr>.(\\<lparr>\\<nu>y\\<rparr>(([(x, y)] \\<bullet> p \\<bullet> P)[<\\<sigma>>]))\""], ["proof (prove)\nusing this:\n  y \\<sharp> M[<\\<sigma>>]\n  y \\<sharp> p \\<bullet> xvec\n  y \\<sharp> (p \\<bullet> N)[<\\<sigma>>]\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n                                  xvec (p \\<bullet>\n  N)[<\\<sigma>>]\\<rparr>.[(x, y)] \\<bullet>\n                         p \\<bullet>\n                         P[<\\<sigma>>]) \\<sim> M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n  xvec (p \\<bullet>\n        N)[<\\<sigma>>]\\<rparr>.\\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet>\n               p \\<bullet> P[<\\<sigma>>]", "by(rule bisimInputPushRes)"], ["proof (state)\nthis:\n  \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n                                xvec (p \\<bullet>\nN)[<\\<sigma>>]\\<rparr>.[(x, y)] \\<bullet>\n                       p \\<bullet>\n                       P[<\\<sigma>>]) \\<sim> M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\nxvec (p \\<bullet>\n      N)[<\\<sigma>>]\\<rparr>.\\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet>\n             p \\<bullet> P[<\\<sigma>>]\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(M\\<lparr>\\<lambda>*xvec N\\<rparr>.P)[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*xvec N\\<rparr>.\\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>]", "with \\<open>y \\<sharp> M\\<close> \\<open>y \\<sharp> N\\<close> \\<open>y \\<sharp> P\\<close> \\<open>x \\<sharp> M\\<close> \\<open>x \\<sharp> N\\<close> \\<open>y \\<sharp> xvec\\<close> \\<open>x \\<sharp> xvec\\<close> \\<open>(p \\<bullet> xvec) \\<sharp>* N\\<close> \\<open>(p \\<bullet> xvec) \\<sharp>* P\\<close> \n       \\<open>x \\<sharp> (p \\<bullet> xvec)\\<close> \\<open>y \\<sharp> (p \\<bullet> xvec)\\<close> \\<open>y \\<sharp> \\<sigma>\\<close> \\<open>(p \\<bullet> xvec) \\<sharp>* \\<sigma>\\<close> S \\<open>wellFormedSubst \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  y \\<sharp> M\n  y \\<sharp> N\n  y \\<sharp> P\n  x \\<sharp> M\n  x \\<sharp> N\n  y \\<sharp> xvec\n  x \\<sharp> xvec\n  (p \\<bullet> xvec) \\<sharp>* N\n  (p \\<bullet> xvec) \\<sharp>* P\n  x \\<sharp> p \\<bullet> xvec\n  y \\<sharp> p \\<bullet> xvec\n  y \\<sharp> \\<sigma>\n  (p \\<bullet> xvec) \\<sharp>* \\<sigma>\n  set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\n  wellFormedSubst \\<sigma>\n  \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n                                xvec (p \\<bullet>\nN)[<\\<sigma>>]\\<rparr>.[(x, y)] \\<bullet>\n                       p \\<bullet>\n                       P[<\\<sigma>>]) \\<sim> M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\nxvec (p \\<bullet>\n      N)[<\\<sigma>>]\\<rparr>.\\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet>\n             p \\<bullet> P[<\\<sigma>>]", "show \"\\<Psi> \\<rhd> (\\<lparr>\\<nu>x\\<rparr>(M\\<lparr>\\<lambda>*xvec N\\<rparr>.P))[<\\<sigma>>] \\<sim> (M\\<lparr>\\<lambda>*xvec N\\<rparr>.\\<lparr>\\<nu>x\\<rparr>P)[<\\<sigma>>]\""], ["proof (prove)\nusing this:\n  y \\<sharp> M\n  y \\<sharp> N\n  y \\<sharp> P\n  x \\<sharp> M\n  x \\<sharp> N\n  y \\<sharp> xvec\n  x \\<sharp> xvec\n  (p \\<bullet> xvec) \\<sharp>* N\n  (p \\<bullet> xvec) \\<sharp>* P\n  x \\<sharp> p \\<bullet> xvec\n  y \\<sharp> p \\<bullet> xvec\n  y \\<sharp> \\<sigma>\n  (p \\<bullet> xvec) \\<sharp>* \\<sigma>\n  set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\n  wellFormedSubst \\<sigma>\n  \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n                                xvec (p \\<bullet>\nN)[<\\<sigma>>]\\<rparr>.[(x, y)] \\<bullet>\n                       p \\<bullet>\n                       P[<\\<sigma>>]) \\<sim> M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\nxvec (p \\<bullet>\n      N)[<\\<sigma>>]\\<rparr>.\\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet>\n             p \\<bullet> P[<\\<sigma>>]\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(M\\<lparr>\\<lambda>*xvec N\\<rparr>.P)[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*xvec N\\<rparr>.\\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>]", "apply(subst inputChainAlpha')"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>y \\<sharp> M; y \\<sharp> N; y \\<sharp> P; x \\<sharp> M;\n     x \\<sharp> N; y \\<sharp> xvec; x \\<sharp> xvec;\n     (p \\<bullet> xvec) \\<sharp>* N; (p \\<bullet> xvec) \\<sharp>* P;\n     x \\<sharp> p \\<bullet> xvec; y \\<sharp> p \\<bullet> xvec;\n     y \\<sharp> \\<sigma>; (p \\<bullet> xvec) \\<sharp>* \\<sigma>;\n     set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec);\n     wellFormedSubst \\<sigma>;\n     \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n                                   xvec (p \\<bullet>\n   N)[<\\<sigma>>]\\<rparr>.[(x, y)] \\<bullet>\n                          p \\<bullet>\n                          P[<\\<sigma>>]) \\<sim> M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n   xvec (p \\<bullet>\n         N)[<\\<sigma>>]\\<rparr>.\\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet>\n                p \\<bullet> P[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> (?p16 \\<bullet> xvec) \\<sharp>* P\n 2. \\<lbrakk>y \\<sharp> M; y \\<sharp> N; y \\<sharp> P; x \\<sharp> M;\n     x \\<sharp> N; y \\<sharp> xvec; x \\<sharp> xvec;\n     (p \\<bullet> xvec) \\<sharp>* N; (p \\<bullet> xvec) \\<sharp>* P;\n     x \\<sharp> p \\<bullet> xvec; y \\<sharp> p \\<bullet> xvec;\n     y \\<sharp> \\<sigma>; (p \\<bullet> xvec) \\<sharp>* \\<sigma>;\n     set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec);\n     wellFormedSubst \\<sigma>;\n     \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n                                   xvec (p \\<bullet>\n   N)[<\\<sigma>>]\\<rparr>.[(x, y)] \\<bullet>\n                          p \\<bullet>\n                          P[<\\<sigma>>]) \\<sim> M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n   xvec (p \\<bullet>\n         N)[<\\<sigma>>]\\<rparr>.\\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet>\n                p \\<bullet> P[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> (?p16 \\<bullet> xvec) \\<sharp>* N\n 3. \\<lbrakk>y \\<sharp> M; y \\<sharp> N; y \\<sharp> P; x \\<sharp> M;\n     x \\<sharp> N; y \\<sharp> xvec; x \\<sharp> xvec;\n     (p \\<bullet> xvec) \\<sharp>* N; (p \\<bullet> xvec) \\<sharp>* P;\n     x \\<sharp> p \\<bullet> xvec; y \\<sharp> p \\<bullet> xvec;\n     y \\<sharp> \\<sigma>; (p \\<bullet> xvec) \\<sharp>* \\<sigma>;\n     set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec);\n     wellFormedSubst \\<sigma>;\n     \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n                                   xvec (p \\<bullet>\n   N)[<\\<sigma>>]\\<rparr>.[(x, y)] \\<bullet>\n                          p \\<bullet>\n                          P[<\\<sigma>>]) \\<sim> M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n   xvec (p \\<bullet>\n         N)[<\\<sigma>>]\\<rparr>.\\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet>\n                p \\<bullet> P[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> set ?p16\n                      \\<subseteq> set xvec \\<times>\n                                  set (?p16 \\<bullet> xvec)\n 4. \\<lbrakk>y \\<sharp> M; y \\<sharp> N; y \\<sharp> P; x \\<sharp> M;\n     x \\<sharp> N; y \\<sharp> xvec; x \\<sharp> xvec;\n     (p \\<bullet> xvec) \\<sharp>* N; (p \\<bullet> xvec) \\<sharp>* P;\n     x \\<sharp> p \\<bullet> xvec; y \\<sharp> p \\<bullet> xvec;\n     y \\<sharp> \\<sigma>; (p \\<bullet> xvec) \\<sharp>* \\<sigma>;\n     set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec);\n     wellFormedSubst \\<sigma>;\n     \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n                                   xvec (p \\<bullet>\n   N)[<\\<sigma>>]\\<rparr>.[(x, y)] \\<bullet>\n                          p \\<bullet>\n                          P[<\\<sigma>>]) \\<sim> M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n   xvec (p \\<bullet>\n         N)[<\\<sigma>>]\\<rparr>.\\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet>\n                p \\<bullet> P[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(M\\<lparr>\\<lambda>*?p16 \\<bullet>\n  xvec ?p16 \\<bullet>\n       N\\<rparr>.?p16 \\<bullet>\n                 P)[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*xvec N\\<rparr>.\\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>]", "apply assumption+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<sharp> M; y \\<sharp> N; y \\<sharp> P; x \\<sharp> M;\n     x \\<sharp> N; y \\<sharp> xvec; x \\<sharp> xvec;\n     (p \\<bullet> xvec) \\<sharp>* N; (p \\<bullet> xvec) \\<sharp>* P;\n     x \\<sharp> p \\<bullet> xvec; y \\<sharp> p \\<bullet> xvec;\n     y \\<sharp> \\<sigma>; (p \\<bullet> xvec) \\<sharp>* \\<sigma>;\n     set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec);\n     wellFormedSubst \\<sigma>;\n     \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n                                   xvec (p \\<bullet>\n   N)[<\\<sigma>>]\\<rparr>.[(x, y)] \\<bullet>\n                          p \\<bullet>\n                          P[<\\<sigma>>]) \\<sim> M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n   xvec (p \\<bullet>\n         N)[<\\<sigma>>]\\<rparr>.\\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet>\n                p \\<bullet> P[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(M\\<lparr>\\<lambda>*p \\<bullet>\n  xvec p \\<bullet>\n       N\\<rparr>.p \\<bullet>\n                 P)[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*xvec N\\<rparr>.\\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>]", "apply(subst inputChainAlpha'[of p xvec])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>y \\<sharp> M; y \\<sharp> N; y \\<sharp> P; x \\<sharp> M;\n     x \\<sharp> N; y \\<sharp> xvec; x \\<sharp> xvec;\n     (p \\<bullet> xvec) \\<sharp>* N; (p \\<bullet> xvec) \\<sharp>* P;\n     x \\<sharp> p \\<bullet> xvec; y \\<sharp> p \\<bullet> xvec;\n     y \\<sharp> \\<sigma>; (p \\<bullet> xvec) \\<sharp>* \\<sigma>;\n     set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec);\n     wellFormedSubst \\<sigma>;\n     \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n                                   xvec (p \\<bullet>\n   N)[<\\<sigma>>]\\<rparr>.[(x, y)] \\<bullet>\n                          p \\<bullet>\n                          P[<\\<sigma>>]) \\<sim> M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n   xvec (p \\<bullet>\n         N)[<\\<sigma>>]\\<rparr>.\\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet>\n                p \\<bullet> P[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> (p \\<bullet> xvec) \\<sharp>* \\<lparr>\\<nu>x\\<rparr>P\n 2. \\<lbrakk>y \\<sharp> M; y \\<sharp> N; y \\<sharp> P; x \\<sharp> M;\n     x \\<sharp> N; y \\<sharp> xvec; x \\<sharp> xvec;\n     (p \\<bullet> xvec) \\<sharp>* N; (p \\<bullet> xvec) \\<sharp>* P;\n     x \\<sharp> p \\<bullet> xvec; y \\<sharp> p \\<bullet> xvec;\n     y \\<sharp> \\<sigma>; (p \\<bullet> xvec) \\<sharp>* \\<sigma>;\n     set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec);\n     wellFormedSubst \\<sigma>;\n     \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n                                   xvec (p \\<bullet>\n   N)[<\\<sigma>>]\\<rparr>.[(x, y)] \\<bullet>\n                          p \\<bullet>\n                          P[<\\<sigma>>]) \\<sim> M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n   xvec (p \\<bullet>\n         N)[<\\<sigma>>]\\<rparr>.\\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet>\n                p \\<bullet> P[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> (p \\<bullet> xvec) \\<sharp>* N\n 3. \\<lbrakk>y \\<sharp> M; y \\<sharp> N; y \\<sharp> P; x \\<sharp> M;\n     x \\<sharp> N; y \\<sharp> xvec; x \\<sharp> xvec;\n     (p \\<bullet> xvec) \\<sharp>* N; (p \\<bullet> xvec) \\<sharp>* P;\n     x \\<sharp> p \\<bullet> xvec; y \\<sharp> p \\<bullet> xvec;\n     y \\<sharp> \\<sigma>; (p \\<bullet> xvec) \\<sharp>* \\<sigma>;\n     set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec);\n     wellFormedSubst \\<sigma>;\n     \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n                                   xvec (p \\<bullet>\n   N)[<\\<sigma>>]\\<rparr>.[(x, y)] \\<bullet>\n                          p \\<bullet>\n                          P[<\\<sigma>>]) \\<sim> M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n   xvec (p \\<bullet>\n         N)[<\\<sigma>>]\\<rparr>.\\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet>\n                p \\<bullet> P[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> set p\n                      \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\n 4. \\<lbrakk>y \\<sharp> M; y \\<sharp> N; y \\<sharp> P; x \\<sharp> M;\n     x \\<sharp> N; y \\<sharp> xvec; x \\<sharp> xvec;\n     (p \\<bullet> xvec) \\<sharp>* N; (p \\<bullet> xvec) \\<sharp>* P;\n     x \\<sharp> p \\<bullet> xvec; y \\<sharp> p \\<bullet> xvec;\n     y \\<sharp> \\<sigma>; (p \\<bullet> xvec) \\<sharp>* \\<sigma>;\n     set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec);\n     wellFormedSubst \\<sigma>;\n     \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n                                   xvec (p \\<bullet>\n   N)[<\\<sigma>>]\\<rparr>.[(x, y)] \\<bullet>\n                          p \\<bullet>\n                          P[<\\<sigma>>]) \\<sim> M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n   xvec (p \\<bullet>\n         N)[<\\<sigma>>]\\<rparr>.\\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet>\n                p \\<bullet> P[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(M\\<lparr>\\<lambda>*p \\<bullet>\n  xvec p \\<bullet>\n       N\\<rparr>.p \\<bullet>\n                 P)[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*p \\<bullet>\n                    xvec p \\<bullet>\n                         N\\<rparr>.p \\<bullet>\n                                   \\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>]", "apply(simp add: abs_fresh_star)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y \\<sharp> M; y \\<sharp> N; y \\<sharp> P; x \\<sharp> M;\n     x \\<sharp> N; y \\<sharp> xvec; x \\<sharp> xvec;\n     (p \\<bullet> xvec) \\<sharp>* N; (p \\<bullet> xvec) \\<sharp>* P;\n     x \\<sharp> p \\<bullet> xvec; y \\<sharp> p \\<bullet> xvec;\n     y \\<sharp> \\<sigma>; (p \\<bullet> xvec) \\<sharp>* \\<sigma>;\n     set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec);\n     wellFormedSubst \\<sigma>;\n     \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n                                   xvec (p \\<bullet>\n   N)[<\\<sigma>>]\\<rparr>.[(x, y)] \\<bullet>\n                          p \\<bullet>\n                          P[<\\<sigma>>]) \\<sim> M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n   xvec (p \\<bullet>\n         N)[<\\<sigma>>]\\<rparr>.\\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet>\n                p \\<bullet> P[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> (p \\<bullet> xvec) \\<sharp>* N\n 2. \\<lbrakk>y \\<sharp> M; y \\<sharp> N; y \\<sharp> P; x \\<sharp> M;\n     x \\<sharp> N; y \\<sharp> xvec; x \\<sharp> xvec;\n     (p \\<bullet> xvec) \\<sharp>* N; (p \\<bullet> xvec) \\<sharp>* P;\n     x \\<sharp> p \\<bullet> xvec; y \\<sharp> p \\<bullet> xvec;\n     y \\<sharp> \\<sigma>; (p \\<bullet> xvec) \\<sharp>* \\<sigma>;\n     set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec);\n     wellFormedSubst \\<sigma>;\n     \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n                                   xvec (p \\<bullet>\n   N)[<\\<sigma>>]\\<rparr>.[(x, y)] \\<bullet>\n                          p \\<bullet>\n                          P[<\\<sigma>>]) \\<sim> M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n   xvec (p \\<bullet>\n         N)[<\\<sigma>>]\\<rparr>.\\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet>\n                p \\<bullet> P[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> set p\n                      \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\n 3. \\<lbrakk>y \\<sharp> M; y \\<sharp> N; y \\<sharp> P; x \\<sharp> M;\n     x \\<sharp> N; y \\<sharp> xvec; x \\<sharp> xvec;\n     (p \\<bullet> xvec) \\<sharp>* N; (p \\<bullet> xvec) \\<sharp>* P;\n     x \\<sharp> p \\<bullet> xvec; y \\<sharp> p \\<bullet> xvec;\n     y \\<sharp> \\<sigma>; (p \\<bullet> xvec) \\<sharp>* \\<sigma>;\n     set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec);\n     wellFormedSubst \\<sigma>;\n     \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n                                   xvec (p \\<bullet>\n   N)[<\\<sigma>>]\\<rparr>.[(x, y)] \\<bullet>\n                          p \\<bullet>\n                          P[<\\<sigma>>]) \\<sim> M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n   xvec (p \\<bullet>\n         N)[<\\<sigma>>]\\<rparr>.\\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet>\n                p \\<bullet> P[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(M\\<lparr>\\<lambda>*p \\<bullet>\n  xvec p \\<bullet>\n       N\\<rparr>.p \\<bullet>\n                 P)[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*p \\<bullet>\n                    xvec p \\<bullet>\n                         N\\<rparr>.p \\<bullet>\n                                   \\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>]", "apply assumption+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<sharp> M; y \\<sharp> N; y \\<sharp> P; x \\<sharp> M;\n     x \\<sharp> N; y \\<sharp> xvec; x \\<sharp> xvec;\n     (p \\<bullet> xvec) \\<sharp>* N; (p \\<bullet> xvec) \\<sharp>* P;\n     x \\<sharp> p \\<bullet> xvec; y \\<sharp> p \\<bullet> xvec;\n     y \\<sharp> \\<sigma>; (p \\<bullet> xvec) \\<sharp>* \\<sigma>;\n     set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec);\n     wellFormedSubst \\<sigma>;\n     \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n                                   xvec (p \\<bullet>\n   N)[<\\<sigma>>]\\<rparr>.[(x, y)] \\<bullet>\n                          p \\<bullet>\n                          P[<\\<sigma>>]) \\<sim> M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n   xvec (p \\<bullet>\n         N)[<\\<sigma>>]\\<rparr>.\\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet>\n                p \\<bullet> P[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(M\\<lparr>\\<lambda>*p \\<bullet>\n  xvec p \\<bullet>\n       N\\<rparr>.p \\<bullet>\n                 P)[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*p \\<bullet>\n                    xvec p \\<bullet>\n                         N\\<rparr>.p \\<bullet>\n                                   \\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>]", "apply(simp add: eqvts)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<sharp> M; y \\<sharp> N; y \\<sharp> P; x \\<sharp> M;\n     x \\<sharp> N; y \\<sharp> xvec; x \\<sharp> xvec;\n     (p \\<bullet> xvec) \\<sharp>* N; (p \\<bullet> xvec) \\<sharp>* P;\n     x \\<sharp> p \\<bullet> xvec; y \\<sharp> p \\<bullet> xvec;\n     y \\<sharp> \\<sigma>; (p \\<bullet> xvec) \\<sharp>* \\<sigma>;\n     set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec);\n     wellFormedSubst \\<sigma>;\n     \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n                                   xvec (p \\<bullet>\n   N)[<\\<sigma>>]\\<rparr>.[(x, y)] \\<bullet>\n                          p \\<bullet>\n                          P[<\\<sigma>>]) \\<sim> M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n   xvec (p \\<bullet>\n         N)[<\\<sigma>>]\\<rparr>.\\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet>\n                p \\<bullet> P[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(M\\<lparr>\\<lambda>*p \\<bullet>\n  xvec p \\<bullet>\n       N\\<rparr>.p \\<bullet>\n                 P)[<\\<sigma>>] \\<sim> M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n                                xvec (p \\<bullet>\nN)[<\\<sigma>>]\\<rparr>.\\<lparr>\\<nu>x\\<rparr>(p \\<bullet> P)[<\\<sigma>>]", "apply(subst alphaRes[of y], simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y \\<sharp> M; y \\<sharp> N; y \\<sharp> P; x \\<sharp> M;\n     x \\<sharp> N; y \\<sharp> xvec; x \\<sharp> xvec;\n     (p \\<bullet> xvec) \\<sharp>* N; (p \\<bullet> xvec) \\<sharp>* P;\n     x \\<sharp> p \\<bullet> xvec; y \\<sharp> p \\<bullet> xvec;\n     y \\<sharp> \\<sigma>; (p \\<bullet> xvec) \\<sharp>* \\<sigma>;\n     set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec);\n     wellFormedSubst \\<sigma>;\n     \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n                                   xvec (p \\<bullet>\n   N)[<\\<sigma>>]\\<rparr>.[(x, y)] \\<bullet>\n                          p \\<bullet>\n                          P[<\\<sigma>>]) \\<sim> M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n   xvec (p \\<bullet>\n         N)[<\\<sigma>>]\\<rparr>.\\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet>\n                p \\<bullet> P[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> y \\<sharp> inputChain (p \\<bullet> xvec)\n                                  (p \\<bullet> N) (p \\<bullet> P)\n 2. \\<lbrakk>y \\<sharp> M; y \\<sharp> N; y \\<sharp> P; x \\<sharp> M;\n     x \\<sharp> N; y \\<sharp> xvec; x \\<sharp> xvec;\n     (p \\<bullet> xvec) \\<sharp>* N; (p \\<bullet> xvec) \\<sharp>* P;\n     x \\<sharp> p \\<bullet> xvec; y \\<sharp> p \\<bullet> xvec;\n     y \\<sharp> \\<sigma>; (p \\<bullet> xvec) \\<sharp>* \\<sigma>;\n     set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec);\n     wellFormedSubst \\<sigma>;\n     \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n                                   xvec (p \\<bullet>\n   N)[<\\<sigma>>]\\<rparr>.[(x, y)] \\<bullet>\n                          p \\<bullet>\n                          P[<\\<sigma>>]) \\<sim> M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n   xvec (p \\<bullet>\n         N)[<\\<sigma>>]\\<rparr>.\\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet>\n                p \\<bullet> P[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>([(x,\n                       y)] \\<bullet>\n                     M\\<lparr>\\<lambda>*p \\<bullet>\n  xvec p \\<bullet>\n       N\\<rparr>.p \\<bullet>\n                 P)[<\\<sigma>>] \\<sim> M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n                                xvec (p \\<bullet>\nN)[<\\<sigma>>]\\<rparr>.\\<lparr>\\<nu>x\\<rparr>(p \\<bullet> P)[<\\<sigma>>]", "apply(simp add: inputChainFresh)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y \\<sharp> M; y \\<sharp> N; y \\<sharp> P; x \\<sharp> M;\n     x \\<sharp> N; y \\<sharp> xvec; x \\<sharp> xvec;\n     (p \\<bullet> xvec) \\<sharp>* N; (p \\<bullet> xvec) \\<sharp>* P;\n     x \\<sharp> p \\<bullet> xvec; y \\<sharp> p \\<bullet> xvec;\n     y \\<sharp> \\<sigma>; (p \\<bullet> xvec) \\<sharp>* \\<sigma>;\n     set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec);\n     wellFormedSubst \\<sigma>;\n     \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n                                   xvec (p \\<bullet>\n   N)[<\\<sigma>>]\\<rparr>.[(x, y)] \\<bullet>\n                          p \\<bullet>\n                          P[<\\<sigma>>]) \\<sim> M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n   xvec (p \\<bullet>\n         N)[<\\<sigma>>]\\<rparr>.\\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet>\n                p \\<bullet> P[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> y mem p \\<bullet> xvec \\<or>\n                      y \\<sharp> p \\<bullet> N \\<and>\n                      y \\<sharp> p \\<bullet> P\n 2. \\<lbrakk>y \\<sharp> M; y \\<sharp> N; y \\<sharp> P; x \\<sharp> M;\n     x \\<sharp> N; y \\<sharp> xvec; x \\<sharp> xvec;\n     (p \\<bullet> xvec) \\<sharp>* N; (p \\<bullet> xvec) \\<sharp>* P;\n     x \\<sharp> p \\<bullet> xvec; y \\<sharp> p \\<bullet> xvec;\n     y \\<sharp> \\<sigma>; (p \\<bullet> xvec) \\<sharp>* \\<sigma>;\n     set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec);\n     wellFormedSubst \\<sigma>;\n     \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n                                   xvec (p \\<bullet>\n   N)[<\\<sigma>>]\\<rparr>.[(x, y)] \\<bullet>\n                          p \\<bullet>\n                          P[<\\<sigma>>]) \\<sim> M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n   xvec (p \\<bullet>\n         N)[<\\<sigma>>]\\<rparr>.\\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet>\n                p \\<bullet> P[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>([(x,\n                       y)] \\<bullet>\n                     M\\<lparr>\\<lambda>*p \\<bullet>\n  xvec p \\<bullet>\n       N\\<rparr>.p \\<bullet>\n                 P)[<\\<sigma>>] \\<sim> M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n                                xvec (p \\<bullet>\nN)[<\\<sigma>>]\\<rparr>.\\<lparr>\\<nu>x\\<rparr>(p \\<bullet> P)[<\\<sigma>>]", "apply(simp add: freshChainSimps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<sharp> M; y \\<sharp> N; y \\<sharp> P; x \\<sharp> M;\n     x \\<sharp> N; y \\<sharp> xvec; x \\<sharp> xvec;\n     (p \\<bullet> xvec) \\<sharp>* N; (p \\<bullet> xvec) \\<sharp>* P;\n     x \\<sharp> p \\<bullet> xvec; y \\<sharp> p \\<bullet> xvec;\n     y \\<sharp> \\<sigma>; (p \\<bullet> xvec) \\<sharp>* \\<sigma>;\n     set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec);\n     wellFormedSubst \\<sigma>;\n     \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n                                   xvec (p \\<bullet>\n   N)[<\\<sigma>>]\\<rparr>.[(x, y)] \\<bullet>\n                          p \\<bullet>\n                          P[<\\<sigma>>]) \\<sim> M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n   xvec (p \\<bullet>\n         N)[<\\<sigma>>]\\<rparr>.\\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet>\n                p \\<bullet> P[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>([(x,\n                       y)] \\<bullet>\n                     M\\<lparr>\\<lambda>*p \\<bullet>\n  xvec p \\<bullet>\n       N\\<rparr>.p \\<bullet>\n                 P)[<\\<sigma>>] \\<sim> M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n                                xvec (p \\<bullet>\nN)[<\\<sigma>>]\\<rparr>.\\<lparr>\\<nu>x\\<rparr>(p \\<bullet> P)[<\\<sigma>>]", "apply(subst alphaRes[of y \"(p \\<bullet> P)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y \\<sharp> M; y \\<sharp> N; y \\<sharp> P; x \\<sharp> M;\n     x \\<sharp> N; y \\<sharp> xvec; x \\<sharp> xvec;\n     (p \\<bullet> xvec) \\<sharp>* N; (p \\<bullet> xvec) \\<sharp>* P;\n     x \\<sharp> p \\<bullet> xvec; y \\<sharp> p \\<bullet> xvec;\n     y \\<sharp> \\<sigma>; (p \\<bullet> xvec) \\<sharp>* \\<sigma>;\n     set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec);\n     wellFormedSubst \\<sigma>;\n     \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n                                   xvec (p \\<bullet>\n   N)[<\\<sigma>>]\\<rparr>.[(x, y)] \\<bullet>\n                          p \\<bullet>\n                          P[<\\<sigma>>]) \\<sim> M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n   xvec (p \\<bullet>\n         N)[<\\<sigma>>]\\<rparr>.\\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet>\n                p \\<bullet> P[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> y \\<sharp> p \\<bullet> P\n 2. \\<lbrakk>y \\<sharp> M; y \\<sharp> N; y \\<sharp> P; x \\<sharp> M;\n     x \\<sharp> N; y \\<sharp> xvec; x \\<sharp> xvec;\n     (p \\<bullet> xvec) \\<sharp>* N; (p \\<bullet> xvec) \\<sharp>* P;\n     x \\<sharp> p \\<bullet> xvec; y \\<sharp> p \\<bullet> xvec;\n     y \\<sharp> \\<sigma>; (p \\<bullet> xvec) \\<sharp>* \\<sigma>;\n     set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec);\n     wellFormedSubst \\<sigma>;\n     \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n                                   xvec (p \\<bullet>\n   N)[<\\<sigma>>]\\<rparr>.[(x, y)] \\<bullet>\n                          p \\<bullet>\n                          P[<\\<sigma>>]) \\<sim> M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n   xvec (p \\<bullet>\n         N)[<\\<sigma>>]\\<rparr>.\\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet>\n                p \\<bullet> P[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>([(x,\n                       y)] \\<bullet>\n                     M\\<lparr>\\<lambda>*p \\<bullet>\n  xvec p \\<bullet>\n       N\\<rparr>.p \\<bullet>\n                 P)[<\\<sigma>>] \\<sim> M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n                                xvec (p \\<bullet>\nN)[<\\<sigma>>]\\<rparr>.\\<lparr>\\<nu>y\\<rparr>([(x, y)] \\<bullet>\n        p \\<bullet> P)[<\\<sigma>>]", "apply(simp add: freshChainSimps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<sharp> M; y \\<sharp> N; y \\<sharp> P; x \\<sharp> M;\n     x \\<sharp> N; y \\<sharp> xvec; x \\<sharp> xvec;\n     (p \\<bullet> xvec) \\<sharp>* N; (p \\<bullet> xvec) \\<sharp>* P;\n     x \\<sharp> p \\<bullet> xvec; y \\<sharp> p \\<bullet> xvec;\n     y \\<sharp> \\<sigma>; (p \\<bullet> xvec) \\<sharp>* \\<sigma>;\n     set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec);\n     wellFormedSubst \\<sigma>;\n     \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>(M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n                                   xvec (p \\<bullet>\n   N)[<\\<sigma>>]\\<rparr>.[(x, y)] \\<bullet>\n                          p \\<bullet>\n                          P[<\\<sigma>>]) \\<sim> M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n   xvec (p \\<bullet>\n         N)[<\\<sigma>>]\\<rparr>.\\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet>\n                p \\<bullet> P[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> \\<Psi> \\<rhd> \\<lparr>\\<nu>y\\<rparr>([(x,\n                       y)] \\<bullet>\n                     M\\<lparr>\\<lambda>*p \\<bullet>\n  xvec p \\<bullet>\n       N\\<rparr>.p \\<bullet>\n                 P)[<\\<sigma>>] \\<sim> M[<\\<sigma>>]\\<lparr>\\<lambda>*p \\<bullet>\n                                xvec (p \\<bullet>\nN)[<\\<sigma>>]\\<rparr>.\\<lparr>\\<nu>y\\<rparr>([(x, y)] \\<bullet>\n        p \\<bullet> P)[<\\<sigma>>]", "by(simp add: freshChainSimps eqvts)"], ["proof (state)\nthis:\n  \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(M\\<lparr>\\<lambda>*xvec N\\<rparr>.P)[<\\<sigma>>] \\<sim> M\\<lparr>\\<lambda>*xvec N\\<rparr>.\\<lparr>\\<nu>x\\<rparr>P[<\\<sigma>>]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bisimSubstResComm:\n  fixes x :: name\n  and   y :: name\n\n  shows \"\\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>P) \\<sim>\\<^sub>s \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>P) \\<sim>\\<^sub>s \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>P)", "proof(case_tac \"x = y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>P) \\<sim>\\<^sub>s \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>P)\n 2. x \\<noteq> y \\<Longrightarrow>\n    \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>P) \\<sim>\\<^sub>s \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>P)", "assume \"x = y\""], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>P) \\<sim>\\<^sub>s \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>P)\n 2. x \\<noteq> y \\<Longrightarrow>\n    \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>P) \\<sim>\\<^sub>s \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>P)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = y\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>P) \\<sim>\\<^sub>s \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>P)", "by(force intro: bisimSubstReflexive)"], ["proof (state)\nthis:\n  \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>P) \\<sim>\\<^sub>s \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>P)\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>P) \\<sim>\\<^sub>s \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>P)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>P) \\<sim>\\<^sub>s \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>P)", "assume \"x \\<noteq> y\""], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>P) \\<sim>\\<^sub>s \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>P)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>P) \\<sim>\\<^sub>s \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>P)", "proof(rule closeSubstI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>P)[<\\<sigma>>] \\<sim> \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>P)[<\\<sigma>>]", "fix \\<sigma>:: \"(name list \\<times> 'a list) list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>P)[<\\<sigma>>] \\<sim> \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>P)[<\\<sigma>>]", "assume \"wellFormedSubst \\<sigma>\""], ["proof (state)\nthis:\n  wellFormedSubst \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>P)[<\\<sigma>>] \\<sim> \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>P)[<\\<sigma>>]", "obtain x'::name where \"x' \\<sharp>  \\<Psi>\" and \"x' \\<sharp> \\<sigma>\" and \"x' \\<sharp> P\" and \"x \\<noteq> x'\" and \"y \\<noteq> x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>x' \\<sharp> \\<Psi>; x' \\<sharp> \\<sigma>; x' \\<sharp> P;\n         x \\<noteq> x'; y \\<noteq> x'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(generate_fresh \"name\") (auto simp add: fresh_prod)"], ["proof (state)\nthis:\n  x' \\<sharp> \\<Psi>\n  x' \\<sharp> \\<sigma>\n  x' \\<sharp> P\n  x \\<noteq> x'\n  y \\<noteq> x'\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>P)[<\\<sigma>>] \\<sim> \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>P)[<\\<sigma>>]", "obtain y'::name where \"y' \\<sharp>  \\<Psi>\" and \"y' \\<sharp> \\<sigma>\" and \"y' \\<sharp> P\" and \"x \\<noteq> y'\" and \"y \\<noteq> y'\" and \"x' \\<noteq> y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y'.\n        \\<lbrakk>y' \\<sharp> \\<Psi>; y' \\<sharp> \\<sigma>; y' \\<sharp> P;\n         x \\<noteq> y'; y \\<noteq> y'; x' \\<noteq> y'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(generate_fresh \"name\") (auto simp add: fresh_prod)"], ["proof (state)\nthis:\n  y' \\<sharp> \\<Psi>\n  y' \\<sharp> \\<sigma>\n  y' \\<sharp> P\n  x \\<noteq> y'\n  y \\<noteq> y'\n  x' \\<noteq> y'\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>P)[<\\<sigma>>] \\<sim> \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>P)[<\\<sigma>>]", "have \"\\<Psi> \\<rhd> \\<lparr>\\<nu>x'\\<rparr>(\\<lparr>\\<nu>y'\\<rparr>(([(x, x')] \\<bullet> [(y, y')] \\<bullet> P)[<\\<sigma>>])) \\<sim> \\<lparr>\\<nu>y'\\<rparr>(\\<lparr>\\<nu>x'\\<rparr>(([(x, x')] \\<bullet> [(y, y')] \\<bullet> P)[<\\<sigma>>]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> \\<lparr>\\<nu>x'\\<rparr>(\\<lparr>\\<nu>y'\\<rparr>[(x,\n                             x')] \\<bullet>\n                           [(y, y')] \\<bullet>\n                           P[<\\<sigma>>]) \\<sim> \\<lparr>\\<nu>y'\\<rparr>(\\<lparr>\\<nu>x'\\<rparr>[(x,\n                      x')] \\<bullet>\n                    [(y, y')] \\<bullet> P[<\\<sigma>>])", "by(rule bisimResComm)"], ["proof (state)\nthis:\n  \\<Psi> \\<rhd> \\<lparr>\\<nu>x'\\<rparr>(\\<lparr>\\<nu>y'\\<rparr>[(x,\n                           x')] \\<bullet>\n                         [(y, y')] \\<bullet>\n                         P[<\\<sigma>>]) \\<sim> \\<lparr>\\<nu>y'\\<rparr>(\\<lparr>\\<nu>x'\\<rparr>[(x,\n                    x')] \\<bullet>\n                  [(y, y')] \\<bullet> P[<\\<sigma>>])\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>P)[<\\<sigma>>] \\<sim> \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>P)[<\\<sigma>>]", "moreover"], ["proof (state)\nthis:\n  \\<Psi> \\<rhd> \\<lparr>\\<nu>x'\\<rparr>(\\<lparr>\\<nu>y'\\<rparr>[(x,\n                           x')] \\<bullet>\n                         [(y, y')] \\<bullet>\n                         P[<\\<sigma>>]) \\<sim> \\<lparr>\\<nu>y'\\<rparr>(\\<lparr>\\<nu>x'\\<rparr>[(x,\n                    x')] \\<bullet>\n                  [(y, y')] \\<bullet> P[<\\<sigma>>])\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>P)[<\\<sigma>>] \\<sim> \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>P)[<\\<sigma>>]", "from \\<open>x' \\<sharp> P\\<close> \\<open>y' \\<sharp> P\\<close> \\<open>x \\<noteq> y'\\<close> \\<open>x' \\<noteq> y'\\<close>"], ["proof (chain)\npicking this:\n  x' \\<sharp> P\n  y' \\<sharp> P\n  x \\<noteq> y'\n  x' \\<noteq> y'", "have \"\\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>P) = \\<lparr>\\<nu>x'\\<rparr>(\\<lparr>\\<nu>y'\\<rparr>(([(x, x')] \\<bullet> [(y, y')] \\<bullet> P)))\""], ["proof (prove)\nusing this:\n  x' \\<sharp> P\n  y' \\<sharp> P\n  x \\<noteq> y'\n  x' \\<noteq> y'\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>P) =\n    \\<lparr>\\<nu>x'\\<rparr>(\\<lparr>\\<nu>y'\\<rparr>([(x, x')] \\<bullet>\n              [(y, y')] \\<bullet> P))", "apply(subst alphaRes[of y' P], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x' \\<sharp> P; y' \\<sharp> P; x \\<noteq> y';\n     x' \\<noteq> y'\\<rbrakk>\n    \\<Longrightarrow> \\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y'\\<rparr>([(y,\n                                 y')] \\<bullet>\n                               P)) =\n                      \\<lparr>\\<nu>x'\\<rparr>(\\<lparr>\\<nu>y'\\<rparr>([(x,\n                                  x')] \\<bullet>\n                                [(y, y')] \\<bullet> P))", "by(subst alphaRes[of x']) (auto simp add: abs_fresh fresh_left calc_atm eqvts)"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>P) =\n  \\<lparr>\\<nu>x'\\<rparr>(\\<lparr>\\<nu>y'\\<rparr>([(x, x')] \\<bullet>\n            [(y, y')] \\<bullet> P))\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>P)[<\\<sigma>>] \\<sim> \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>P)[<\\<sigma>>]", "moreover"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>P) =\n  \\<lparr>\\<nu>x'\\<rparr>(\\<lparr>\\<nu>y'\\<rparr>([(x, x')] \\<bullet>\n            [(y, y')] \\<bullet> P))\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>P)[<\\<sigma>>] \\<sim> \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>P)[<\\<sigma>>]", "from \\<open>x' \\<sharp> P\\<close> \\<open>y' \\<sharp> P\\<close> \\<open>y \\<noteq> x'\\<close> \\<open>x \\<noteq> y'\\<close> \\<open>x' \\<noteq> y'\\<close> \\<open>x \\<noteq> x'\\<close> \\<open>x \\<noteq> y\\<close>"], ["proof (chain)\npicking this:\n  x' \\<sharp> P\n  y' \\<sharp> P\n  y \\<noteq> x'\n  x \\<noteq> y'\n  x' \\<noteq> y'\n  x \\<noteq> x'\n  x \\<noteq> y", "have \"\\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>P) = \\<lparr>\\<nu>y'\\<rparr>(\\<lparr>\\<nu>x'\\<rparr>(([(x, x')] \\<bullet> [(y, y')] \\<bullet> P)))\""], ["proof (prove)\nusing this:\n  x' \\<sharp> P\n  y' \\<sharp> P\n  y \\<noteq> x'\n  x \\<noteq> y'\n  x' \\<noteq> y'\n  x \\<noteq> x'\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>P) =\n    \\<lparr>\\<nu>y'\\<rparr>(\\<lparr>\\<nu>x'\\<rparr>([(x, x')] \\<bullet>\n              [(y, y')] \\<bullet> P))", "apply(subst alphaRes[of x' P], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x' \\<sharp> P; y' \\<sharp> P; y \\<noteq> x'; x \\<noteq> y';\n     x' \\<noteq> y'; x \\<noteq> x'; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x'\\<rparr>([(x,\n                                 x')] \\<bullet>\n                               P)) =\n                      \\<lparr>\\<nu>y'\\<rparr>(\\<lparr>\\<nu>x'\\<rparr>([(x,\n                                  x')] \\<bullet>\n                                [(y, y')] \\<bullet> P))", "apply(subst alphaRes[of y'], simp add: abs_fresh fresh_left calc_atm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x' \\<sharp> P; y' \\<sharp> P; y \\<noteq> x'; x \\<noteq> y';\n     x' \\<noteq> y'; x \\<noteq> x'; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> \\<lparr>\\<nu>y'\\<rparr>([(y, y')] \\<bullet>\n        \\<lparr>\\<nu>x'\\<rparr>([(x, x')] \\<bullet> P)) =\n                      \\<lparr>\\<nu>y'\\<rparr>(\\<lparr>\\<nu>x'\\<rparr>([(x,\n                                  x')] \\<bullet>\n                                [(y, y')] \\<bullet> P))", "apply(simp add: eqvts calc_atm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x' \\<sharp> P; y' \\<sharp> P; y \\<noteq> x'; x \\<noteq> y';\n     x' \\<noteq> y'; x \\<noteq> x'; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> \\<lparr>\\<nu>y'\\<rparr>(\\<lparr>\\<nu>x'\\<rparr>([(y,\n                                  y')] \\<bullet>\n                                [(x, x')] \\<bullet> P)) =\n                      \\<lparr>\\<nu>y'\\<rparr>(\\<lparr>\\<nu>x'\\<rparr>([(x,\n                                  x')] \\<bullet>\n                                [(y, y')] \\<bullet> P))", "by(subst perm_compose) (simp add: calc_atm)"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>P) =\n  \\<lparr>\\<nu>y'\\<rparr>(\\<lparr>\\<nu>x'\\<rparr>([(x, x')] \\<bullet>\n            [(y, y')] \\<bullet> P))\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       wellFormedSubst \\<sigma> \\<Longrightarrow>\n       \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>P)[<\\<sigma>>] \\<sim> \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>P)[<\\<sigma>>]", "ultimately"], ["proof (chain)\npicking this:\n  \\<Psi> \\<rhd> \\<lparr>\\<nu>x'\\<rparr>(\\<lparr>\\<nu>y'\\<rparr>[(x,\n                           x')] \\<bullet>\n                         [(y, y')] \\<bullet>\n                         P[<\\<sigma>>]) \\<sim> \\<lparr>\\<nu>y'\\<rparr>(\\<lparr>\\<nu>x'\\<rparr>[(x,\n                    x')] \\<bullet>\n                  [(y, y')] \\<bullet> P[<\\<sigma>>])\n  \\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>P) =\n  \\<lparr>\\<nu>x'\\<rparr>(\\<lparr>\\<nu>y'\\<rparr>([(x, x')] \\<bullet>\n            [(y, y')] \\<bullet> P))\n  \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>P) =\n  \\<lparr>\\<nu>y'\\<rparr>(\\<lparr>\\<nu>x'\\<rparr>([(x, x')] \\<bullet>\n            [(y, y')] \\<bullet> P))", "show \"\\<Psi> \\<rhd> (\\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>P))[<\\<sigma>>] \\<sim> (\\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>P))[<\\<sigma>>]\""], ["proof (prove)\nusing this:\n  \\<Psi> \\<rhd> \\<lparr>\\<nu>x'\\<rparr>(\\<lparr>\\<nu>y'\\<rparr>[(x,\n                           x')] \\<bullet>\n                         [(y, y')] \\<bullet>\n                         P[<\\<sigma>>]) \\<sim> \\<lparr>\\<nu>y'\\<rparr>(\\<lparr>\\<nu>x'\\<rparr>[(x,\n                    x')] \\<bullet>\n                  [(y, y')] \\<bullet> P[<\\<sigma>>])\n  \\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>P) =\n  \\<lparr>\\<nu>x'\\<rparr>(\\<lparr>\\<nu>y'\\<rparr>([(x, x')] \\<bullet>\n            [(y, y')] \\<bullet> P))\n  \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>P) =\n  \\<lparr>\\<nu>y'\\<rparr>(\\<lparr>\\<nu>x'\\<rparr>([(x, x')] \\<bullet>\n            [(y, y')] \\<bullet> P))\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>P)[<\\<sigma>>] \\<sim> \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>P)[<\\<sigma>>]", "using \\<open>wellFormedSubst \\<sigma>\\<close>  \\<open>x' \\<sharp> \\<sigma>\\<close> \\<open>y' \\<sharp> \\<sigma>\\<close>"], ["proof (prove)\nusing this:\n  \\<Psi> \\<rhd> \\<lparr>\\<nu>x'\\<rparr>(\\<lparr>\\<nu>y'\\<rparr>[(x,\n                           x')] \\<bullet>\n                         [(y, y')] \\<bullet>\n                         P[<\\<sigma>>]) \\<sim> \\<lparr>\\<nu>y'\\<rparr>(\\<lparr>\\<nu>x'\\<rparr>[(x,\n                    x')] \\<bullet>\n                  [(y, y')] \\<bullet> P[<\\<sigma>>])\n  \\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>P) =\n  \\<lparr>\\<nu>x'\\<rparr>(\\<lparr>\\<nu>y'\\<rparr>([(x, x')] \\<bullet>\n            [(y, y')] \\<bullet> P))\n  \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>P) =\n  \\<lparr>\\<nu>y'\\<rparr>(\\<lparr>\\<nu>x'\\<rparr>([(x, x')] \\<bullet>\n            [(y, y')] \\<bullet> P))\n  wellFormedSubst \\<sigma>\n  x' \\<sharp> \\<sigma>\n  y' \\<sharp> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>P)[<\\<sigma>>] \\<sim> \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>P)[<\\<sigma>>]", "by simp"], ["proof (state)\nthis:\n  \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>P)[<\\<sigma>>] \\<sim> \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>P)[<\\<sigma>>]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Psi> \\<rhd> \\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>P) \\<sim>\\<^sub>s \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>P)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bisimSubstExtBang:\n  fixes \\<Psi> :: 'b\n  and   P :: \"('a, 'b, 'c) psi\"\n  \n  assumes \"guarded P\"\n\n  shows \"\\<Psi> \\<rhd> !P \\<sim>\\<^sub>s P \\<parallel> !P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> !P \\<sim>\\<^sub>s P \\<parallel> !P", "using assms"], ["proof (prove)\nusing this:\n  guarded P\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<rhd> !P \\<sim>\\<^sub>s P \\<parallel> !P", "by(fastforce intro: closeSubstI bangExt guardedSeqSubst)"], ["", "lemma structCongBisimSubst:\n  fixes P :: \"('a, 'b, 'c) psi\"  \n  and   Q :: \"('a, 'b, 'c) psi\"\n\n  assumes \"P \\<equiv>\\<^sub>s Q\"\n\n  shows \"P \\<sim>\\<^sub>s Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sim>\\<^sub>s Q", "using assms"], ["proof (prove)\nusing this:\n  P \\<equiv>\\<^sub>s Q\n\ngoal (1 subgoal):\n 1. P \\<sim>\\<^sub>s Q", "by(induct rule: structCong.induct)\n  (auto intro: bisimSubstReflexive bisimSubstSymmetric bisimSubstTransitive bisimSubstParComm bisimSubstParAssoc bisimSubstParNil bisimSubstResNil bisimSubstResComm bisimSubstScopeExt bisimSubstCasePushRes bisimSubstInputPushRes bisimSubstOutputPushRes bisimSubstExtBang)"], ["", "end"], ["", "end"]]}