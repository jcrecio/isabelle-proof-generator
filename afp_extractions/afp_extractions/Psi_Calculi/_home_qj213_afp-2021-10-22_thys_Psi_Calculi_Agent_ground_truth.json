{"file_name": "/home/qj213/afp-2021-10-22/thys/Psi_Calculi/Agent.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Psi_Calculi", "problem_names": ["lemma psiFreshSet[simp]:\n  fixes X :: \"name set\"\n  and   M :: \"'a::fs_name\"\n  and   N :: 'a\n  and   P :: \"('a, 'b::fs_name, 'c::fs_name) psi\"\n  and   I :: \"('a, 'b, 'c) input\"\n  and   C :: \"('a, 'b, 'c) psiCase\"\n  and   Q :: \"('a, 'b, 'c) psi\"\n  and   x :: name\n  and   \\<Psi> :: 'b\n  and   \\<Phi> :: 'c\n\n  shows \"X \\<sharp>* (M\\<langle>N\\<rangle>.P) = (X \\<sharp>* M \\<and> X \\<sharp>* N \\<and> X \\<sharp>* P)\"\n  and   \"X \\<sharp>* M\\<lparr>I = (X \\<sharp>* M \\<and> X \\<sharp>* I)\"\n  and   \"X \\<sharp>* Case C = X \\<sharp>* C\"\n  and   \"X \\<sharp>* (P \\<parallel> Q) = (X \\<sharp>* P \\<and> X \\<sharp>* Q)\"\n  and   \"X \\<sharp>* \\<lparr>\\<nu>x\\<rparr>P = (X \\<sharp>* [x].P)\"\n  and   \"X \\<sharp>* \\<lbrace>\\<Psi>\\<rbrace> = X \\<sharp>* \\<Psi>\"\n  and   \"X \\<sharp>* !P = X \\<sharp>* P\"\n  and   \"X \\<sharp>* \\<zero>\"\n  and   \"X \\<sharp>* Trm N P = (X \\<sharp>* N \\<and> X \\<sharp>* P)\"\n  and   \"X \\<sharp>* Bind x I = X \\<sharp>* ([x].I)\"\n\n  and   \"X \\<sharp>* \\<bottom>\\<^sub>c\"\n  and   \"X \\<sharp>* \\<box> \\<Phi> \\<Rightarrow> P C = (X \\<sharp>* \\<Phi> \\<and> X \\<sharp>* P \\<and> X \\<sharp>* C)\"", "lemma psiFreshVec[simp]:\n  fixes xvec :: \"name list\"\n\n  shows \"xvec \\<sharp>* (M\\<langle>N\\<rangle>.P) = (xvec \\<sharp>* M \\<and> xvec \\<sharp>* N \\<and> xvec \\<sharp>* P)\"\n  and   \"xvec \\<sharp>* M\\<lparr>I = (xvec \\<sharp>* M \\<and> xvec \\<sharp>* I)\"\n  and   \"xvec \\<sharp>* Case C = xvec \\<sharp>* C\"\n  and   \"xvec \\<sharp>* (P \\<parallel> Q) = (xvec \\<sharp>* P \\<and> xvec \\<sharp>* Q)\"\n  and   \"xvec \\<sharp>* \\<lparr>\\<nu>x\\<rparr>P = (xvec \\<sharp>* [x].P)\"\n  and   \"xvec \\<sharp>* \\<lbrace>\\<Psi>\\<rbrace> = xvec \\<sharp>* \\<Psi>\"\n  and   \"xvec \\<sharp>* !P = xvec \\<sharp>* P\"\n  and   \"xvec \\<sharp>* \\<zero>\"\n\n  and   \"xvec \\<sharp>* Trm N P = (xvec \\<sharp>* N \\<and> xvec \\<sharp>* P)\"\n  and   \"xvec \\<sharp>* Bind x I = xvec \\<sharp>* ([x].I)\"\n\n  and   \"xvec \\<sharp>* \\<bottom>\\<^sub>c\"\n  and   \"xvec \\<sharp>* \\<box> \\<Phi> \\<Rightarrow> P C = (xvec \\<sharp>* \\<Phi> \\<and> xvec \\<sharp>* P \\<and> xvec \\<sharp>* C)\"", "lemma psiCasesEqvt[eqvt]:\n  fixes p  :: \"name prm\"\n  and   Cs :: \"('c::fs_name \\<times> ('a::fs_name, 'b::fs_name, 'c) psi) list\"\n\n  shows \"(p \\<bullet> (psiCases Cs)) = psiCases(p \\<bullet> Cs)\"", "lemma psiCasesFresh[simp]:\n  fixes x  :: name\n  and   Cs :: \"('c::fs_name \\<times> ('a::fs_name, 'b::fs_name, 'c) psi) list\"\n  \n  shows \"x \\<sharp> psiCases Cs = x \\<sharp> Cs\"", "lemma psiCasesFreshChain[simp]:\n  fixes xvec :: \"name list\"\n  and   Cs :: \"('c::fs_name \\<times> ('a::fs_name, 'b::fs_name, 'c) psi) list\"\n  and   Xs   :: \"name set\"\n  \n  shows \"(xvec \\<sharp>* psiCases Cs) = xvec \\<sharp>* Cs\"\n  and   \"(Xs \\<sharp>* psiCases Cs) = Xs \\<sharp>* Cs\"", "lemma resChainEqvt[eqvt]:\n  fixes perm :: \"name prm\"\n  and   lst  :: \"name list\"\n  and   P    :: \"('a::fs_name, 'b::fs_name, 'c::fs_name) psi\"\n  \n  shows \"perm \\<bullet> (\\<lparr>\\<nu>*xvec\\<rparr>P) = \\<lparr>\\<nu>*(perm \\<bullet> xvec)\\<rparr>(perm \\<bullet> P)\"", "lemma resChainSupp:\n  fixes xvec :: \"name list\"\n  and   P    :: \"('a::fs_name, 'b::fs_name, 'c::fs_name) psi\"\n\n  shows \"supp(\\<lparr>\\<nu>*xvec\\<rparr>P) = (supp P) - set xvec\"", "lemma resChainFresh: \n  fixes x    :: name\n  and   xvec :: \"name list\"\n  and   P    :: \"('a::fs_name, 'b::fs_name, 'c::fs_name) psi\"\n\n  shows \"x \\<sharp> \\<lparr>\\<nu>*xvec\\<rparr>P = (x \\<in> set xvec \\<or> x \\<sharp> P)\"", "lemma resChainFreshSet: \n  fixes Xs   :: \"name set\"\n  and   xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   P    :: \"('a::fs_name, 'b::fs_name, 'c::fs_name) psi\"\n\n  shows \"Xs \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>P) = (\\<forall>x\\<in>Xs. x \\<in> set xvec \\<or> x \\<sharp> P)\"\n  and   \"yvec \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>P) = (\\<forall>x\\<in>(set yvec). x \\<in> set xvec \\<or> x \\<sharp> P)\"", "lemma resChainFreshSimps[simp]:\n  fixes Xs   :: \"name set\"\n  and   xvec :: \"name list\"\n  and   P    :: \"('a::fs_name, 'b::fs_name, 'c::fs_name) psi\"\n  and   yvec :: \"name list\"\n\n  shows \"Xs \\<sharp>* xvec \\<Longrightarrow> Xs \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>P) = (Xs \\<sharp>* P)\"\n  and   \"yvec \\<sharp>* xvec \\<Longrightarrow> yvec \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>P) = (yvec \\<sharp>* P)\"\n  and   \"xvec \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>P)\"", "lemma resChainAlpha:\n  fixes p    :: \"name prm\"\n  and   xvec :: \"name list\"\n  and   P    :: \"('a::fs_name, 'b::fs_name, 'c::fs_name) psi\"\n\n  assumes xvecFreshP: \"(p \\<bullet> xvec) \\<sharp>* P\"\n  and     S: \"set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\"\n\n  shows \"\\<lparr>\\<nu>*xvec\\<rparr>P = \\<lparr>\\<nu>*(p \\<bullet> xvec)\\<rparr>(p \\<bullet> P)\"", "lemma resChainAppend:\n  fixes xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   P    :: \"('a::fs_name, 'b::fs_name, 'c::fs_name) psi\"\n  \n  shows \"\\<lparr>\\<nu>*(xvec@yvec)\\<rparr>P = \\<lparr>\\<nu>*xvec\\<rparr>(\\<lparr>\\<nu>*yvec\\<rparr>P)\"", "lemma resChainSimps[dest]:\n  fixes xvec :: \"name list\"\n  and   P    :: \"('a::fs_name, 'b::fs_name, 'c::fs_name) psi\"\n  and   Q    :: \"('a, 'b, 'c) psi\"\n  and   P'   :: \"('a, 'b, 'c) psi\"\n  and   Q'   :: \"('a, 'b, 'c) psi\"\n\n  shows \"((\\<lparr>\\<nu>*xvec\\<rparr>(P \\<parallel> Q)) = P' \\<parallel> Q') \\<Longrightarrow> (P = P' \\<and> Q = Q')\"\n  and   \"(P \\<parallel> Q = \\<lparr>\\<nu>*xvec\\<rparr>(P' \\<parallel> Q')) \\<Longrightarrow> (P = P' \\<and> Q = Q')\"", "lemma inputChainEqvt[eqvt]:\n  fixes p    :: \"name prm\"\n  and   xvec :: \"name list\"\n  and   N    :: \"'a::fs_name\"\n  and   P    :: \"('a, 'b::fs_name, 'c::fs_name) psi\"\n  \n  shows \"p \\<bullet> (inputChain xvec N P) = inputChain (p \\<bullet> xvec) (p \\<bullet> N) (p \\<bullet> P)\"", "lemma inputChainFresh: \n  fixes x    :: name\n  and   xvec :: \"name list\"\n  and   N    :: \"'a::fs_name\"\n  and   P    :: \"('a, 'b::fs_name, 'c::fs_name) psi\"\n\n  shows \"x \\<sharp> (inputChain xvec N P) = (x \\<in> set xvec \\<or> (x \\<sharp> N \\<and> x \\<sharp> P))\"", "lemma inductChainSimps[simp]:\n  fixes xvec :: \"name list\"\n  and   N    :: \"'a::fs_name\"\n  and   P    :: \"('a, 'b::fs_name, 'c::fs_name) psi\"\n\n  shows \"xvec \\<sharp>* (inputChain xvec N P)\"", "lemma inputChainFreshSet: \n  fixes Xs   :: \"name set\"\n  and   xvec :: \"name list\"\n  and   N    :: \"'a::fs_name\"\n  and   P    :: \"('a, 'b::fs_name, 'c::fs_name) psi\"\n\n  shows \"Xs \\<sharp>* (inputChain xvec N P) = (\\<forall>x\\<in>Xs. x \\<in> set xvec \\<or> (x \\<sharp> N \\<and> x \\<sharp> P))\"", "lemma inputChainAlpha:\n  fixes p  :: \"name prm\"\n  and   Xs :: \"name set\"\n  and   Ys :: \"name set\"\n\n  assumes XsFreshP: \"Xs \\<sharp>* (inputChain xvec N P)\"\n  and     YsFreshN: \"Ys \\<sharp>* N\"\n  and     YsFreshP: \"Ys \\<sharp>* P\"\n  and     S: \"set p \\<subseteq> Xs \\<times> Ys\"\n\n  shows \"(inputChain xvec N P) = (inputChain (p \\<bullet> xvec) (p \\<bullet> N) (p \\<bullet> P))\"", "lemma inputChainAlpha':\n  fixes p    :: \"name prm\"\n  and   xvec :: \"name list\"\n  and   N    :: \"'a::fs_name\"\n  and   P    :: \"('a, 'b::fs_name, 'c::fs_name) psi\"\n\n  assumes xvecFreshP: \"(p \\<bullet> xvec) \\<sharp>* P\"\n  and     xvecFreshN: \"(p \\<bullet> xvec) \\<sharp>* N\"\n  and     S: \"set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\"\n\n  shows \"(inputChain xvec N P) = (inputChain (p \\<bullet> xvec) (p \\<bullet> N) (p \\<bullet> P))\"", "lemma alphaRes:\n  fixes M :: \"'a::fs_name\"\n  and   x :: name\n  and   P :: \"('a, 'b::fs_name, 'c::fs_name) psi\"\n  and   y :: name\n\n  assumes yFreshP: \"y \\<sharp> P\"\n\n  shows \"\\<lparr>\\<nu>x\\<rparr>P = \\<lparr>\\<nu>y\\<rparr>([(x, y)] \\<bullet> P)\"", "lemma alphaInput:\n  fixes x :: name\n  and   I :: \"('a::fs_name, 'b::fs_name, 'c::fs_name) input\"\n  and   c :: name\n\n  assumes A1: \"c \\<sharp> I\"\n\n  shows \"\\<nu> x I = \\<nu> c([(x, c)] \\<bullet> I)\"", "lemma inputChainLengthEq:\n  fixes xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   M    :: \"'a::fs_name\"\n  and   P    :: \"('a, 'b::fs_name, 'c::fs_name) psi\"\n\n  assumes \"length xvec = length yvec\"\n  and     \"xvec \\<sharp>* yvec\"\n  and     \"distinct yvec\"\n  and     \"yvec \\<sharp>* M\"\n  and     \"yvec \\<sharp>* P\"\n\n  obtains N Q where \"inputChain xvec M P = inputChain yvec N Q\"", "lemma inputChainEq:\n  fixes xvec :: \"name list\"\n  and   M    :: \"'a::fs_name\"\n  and   P    :: \"('a, 'b::fs_name, 'c::fs_name) psi\"\n  and   yvec :: \"name list\"\n  and   N    :: 'a\n  and   Q    :: \"('a, 'b, 'c) psi\"\n\n  assumes \"inputChain xvec M P = inputChain yvec N Q\"\n  and     \"xvec \\<sharp>* yvec\"\n  and     \"distinct xvec\"\n  and     \"distinct yvec\"\n\n  obtains p where \"(set p) \\<subseteq> (set xvec) \\<times> set (p \\<bullet> xvec)\" and \"distinctPerm p\" and \"yvec = p \\<bullet> xvec\" and \"N = p \\<bullet> M\" and \"Q = p \\<bullet> P\"", "lemma inputChainEqLength:\n  fixes xvec :: \"name list\"\n  and   M    :: \"'a::fs_name\"\n  and   P    :: \"('a, 'b::fs_name, 'c::fs_name) psi\"\n  and   yvec :: \"name list\"\n  and   N    :: 'a\n  and   Q    :: \"('a, 'b, 'c) psi\"\n\n  assumes \"inputChain xvec M P = inputChain yvec N Q\"\n\n  shows \"length xvec = length yvec\"", "lemma alphaInputChain:\n  fixes yvec :: \"name list\"\n  and   xvec :: \"name list\"\n  and   M    :: \"'a::fs_name\"\n  and   P    :: \"('a, 'b::fs_name, 'c::fs_name) psi\"\n\n  assumes \"length xvec = length yvec\"\n  and     \"yvec \\<sharp>* M\"\n  and     \"yvec \\<sharp>* P\"\n  and     \"yvec \\<sharp>* xvec\"\n  and     \"distinct yvec\"\n\n  shows \"inputChain xvec M P = inputChain yvec ([xvec yvec] \\<bullet>\\<^sub>v M) ([xvec yvec] \\<bullet>\\<^sub>v P)\"", "lemma inputChainInject[simp]:\n\n  shows \"(inputChain xvec M P = inputChain xvec N Q) = ((M = N) \\<and> (P = Q))\"", "lemma alphaInputDistinct:\n  fixes xvec :: \"name list\"\n  and   M    :: \"'a::fs_name\"\n  and   P    :: \"('a, 'b::fs_name, 'c::fs_name) psi\"\n  and   yvec :: \"name list\"\n  and   N    :: 'a\n  and   Q    :: \"('a, 'b, 'c) psi\"\n\n  assumes Eq: \"inputChain xvec M P = inputChain yvec N Q\"\n  and     xvecDist: \"distinct xvec\"\n  and     Mem: \"\\<And>x. x \\<in> set xvec \\<Longrightarrow> x \\<in> supp M\"\n  and     xvecFreshyvec: \"xvec \\<sharp>* yvec\"\n  and     xvecFreshN: \"xvec \\<sharp>* N\"\n  and     xvecFreshQ: \"xvec \\<sharp>* Q\"\n\n  shows \"distinct yvec\"", "lemma psiCasesInject[simp]:\n  fixes CsP  :: \"('c::fs_name \\<times> ('a::fs_name, 'b::fs_name, 'c) psi) list\"\n  and   CsQ  :: \"('c \\<times> ('a, 'b, 'c) psi) list\"\n\n  shows \"(psiCases CsP = psiCases CsQ) = (CsP = CsQ)\"", "lemma casesInject[simp]:\n  fixes CsP :: \"('c::fs_name \\<times> ('a::fs_name, 'b::fs_name, 'c) psi) list\"\n  and   CsQ :: \"('c \\<times> ('a, 'b, 'c) psi) list\"\n\n  shows \"(Cases CsP = Cases CsQ) = (CsP = CsQ)\"", "lemma guardedEqvt[eqvt]:\n  fixes p    :: \"name prm\"\n  and   P    :: \"('a::fs_name, 'b::fs_name, 'c::fs_name) psi\"\n  and   I    :: \"('a, 'b, 'c) input\"\n  and   C    :: \"('a, 'b, 'c) psiCase\"\n\n  shows \"(p \\<bullet> (guarded P)) = guarded (p \\<bullet> P)\"\n  and   \"(p \\<bullet> (guarded' I)) = guarded' (p \\<bullet> I)\"\n  and   \"(p \\<bullet> (guarded'' C)) = guarded'' (p \\<bullet> C)\"", "lemma guardedClosed[simp]:\n  fixes P :: \"('a::fs_name, 'b::fs_name, 'c::fs_name) psi\"\n  and   p :: \"name prm\"\n\n  assumes \"guarded P\"\n\n  shows \"guarded(p \\<bullet> P)\"", "lemma substEqvt[eqvt]:\n  fixes p    :: \"name prm\"\n  and   P    :: \"('a, 'b, 'c) psi\"\n  and   xvec :: \"name list\"\n  and   Tvec :: \"'a list\"\n  and   I    :: \"('a, 'b, 'c) input\"\n  and   C    :: \"('a, 'b, 'c) psiCase\"\n\n  shows \"(p \\<bullet> (subs P xvec Tvec)) = subs (p \\<bullet> P) (p \\<bullet> xvec) (p \\<bullet> Tvec)\"\n  and   \"(p \\<bullet> (subs' I xvec Tvec)) = subs' (p \\<bullet> I) (p \\<bullet> xvec) (p \\<bullet> Tvec)\"\n  and   \"(p \\<bullet> (subs'' C xvec Tvec)) = subs'' (p \\<bullet> C) (p \\<bullet> xvec) (p \\<bullet> Tvec)\"", "lemma subst2[intro]:\n  fixes xvec :: \"name list\"\n  and   Tvec :: \"'a list\"\n  and   x    :: name\n  and   P    :: \"('a, 'b, 'c) psi\"\n  and   I    :: \"('a, 'b, 'c) input\"\n  and   C    :: \"('a, 'b, 'c) psiCase\"\n\n  assumes \"x \\<sharp> Tvec\"\n  and     \"x \\<sharp> xvec\"\n\n  shows \"x \\<sharp> P \\<Longrightarrow> x \\<sharp> (subs P xvec Tvec)\"\n  and   \"x \\<sharp> I \\<Longrightarrow> x \\<sharp> (subs' I xvec Tvec)\"\n  and   \"x \\<sharp> C \\<Longrightarrow> x \\<sharp> (subs'' C xvec Tvec)\"", "lemma subst2Chain[intro]:\n  fixes xvec :: \"name list\"\n  and   Tvec :: \"'a list\"\n  and   Xs   :: \"name set\"\n  and   P    :: \"('a, 'b, 'c) psi\"\n  and   I    :: \"('a, 'b, 'c) input\"\n  and   C    :: \"('a, 'b, 'c) psiCase\"\n\n  assumes \"Xs \\<sharp>* xvec\"\n  and     \"Xs \\<sharp>* Tvec\"\n\n  shows \"Xs \\<sharp>* P \\<Longrightarrow> Xs \\<sharp>* (subs P xvec Tvec)\"\n  and   \"Xs \\<sharp>* I \\<Longrightarrow> Xs \\<sharp>* (subs' I xvec Tvec)\"\n  and   \"Xs \\<sharp>* C \\<Longrightarrow> Xs \\<sharp>* (subs'' C xvec Tvec)\"", "lemma renaming:\n  fixes xvec :: \"name list\"\n  and   Tvec :: \"'a list\"\n  and   p    :: \"name prm\"\n  and   P    :: \"('a, 'b, 'c) psi\"\n  and   I    :: \"('a ,'b, 'c) input\"\n  and   C    :: \"('a, 'b, 'c) psiCase\"\n\n  assumes \"length xvec = length Tvec\"\n  and     \"set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\"\n  and     \"distinctPerm p\"\n\n  shows \"\\<lbrakk>(p \\<bullet> xvec) \\<sharp>* P\\<rbrakk> \\<Longrightarrow> (subs P xvec Tvec) = subs (p \\<bullet> P) (p \\<bullet> xvec) Tvec\"\n  and   \"\\<lbrakk>(p \\<bullet> xvec) \\<sharp>* I\\<rbrakk> \\<Longrightarrow> (subs' I xvec Tvec) = subs' (p \\<bullet> I) (p \\<bullet> xvec) Tvec\"\n  and   \"\\<lbrakk>(p \\<bullet> xvec) \\<sharp>* C\\<rbrakk> \\<Longrightarrow> (subs'' C xvec Tvec) = subs'' (p \\<bullet> C) (p \\<bullet> xvec) Tvec\"", "lemma subst4Chain:\n  fixes xvec :: \"name list\"\n  and   Tvec :: \"'a list\"\n  and   P    :: \"('a, 'b, 'c) psi\"\n  and   I    :: \"('a, 'b, 'c) input\"\n  and   C    :: \"('a, 'b, 'c) psiCase\"\n\n  assumes \"length xvec = length Tvec\"\n  and     \"distinct xvec\"\n  and     \"xvec \\<sharp>* Tvec\"\n\n  shows \"xvec \\<sharp>* (subs P xvec Tvec)\"\n  and   \"xvec \\<sharp>* (subs' I xvec Tvec)\"\n  and   \"xvec \\<sharp>* (subs'' C xvec Tvec)\"", "lemma guardedSubst[simp]:\n  fixes P    :: \"('a, 'b, 'c) psi\"\n  and   I    :: \"('a, 'b, 'c) input\"\n  and   C    :: \"('a, 'b, 'c) psiCase\"\n  and   xvec :: \"name list\"\n  and   Tvec :: \"'a list\"\n\n  assumes \"length xvec = length Tvec\"\n  and     \"distinct xvec\"\n\n  shows \"guarded P \\<Longrightarrow> guarded(subs P xvec Tvec)\"\n  and   \"guarded' I \\<Longrightarrow> guarded'(subs' I xvec Tvec)\"\n  and   \"guarded'' C \\<Longrightarrow> guarded''(subs'' C xvec Tvec)\"", "lemma substInputChain[simp]:\n  fixes xvec :: \"name list\"\n  and   N    :: \"'a\"\n  and   P    :: \"('a, 'b, 'c) psi\"\n  and   yvec :: \"name list\"\n  and   Tvec :: \"'a list\"\n\n  assumes \"xvec \\<sharp>* yvec\"\n  and     \"xvec \\<sharp>* Tvec\"\n\n  shows \"subs' (inputChain xvec N P) yvec Tvec = inputChain xvec (substTerm N yvec Tvec) (subs P yvec Tvec)\"", "lemma substCases[simp]:\n  fixes Cs   :: \"('c \\<times> ('a, 'b, 'c) psi) list\"\n  and   xvec :: \"name list\"\n  and   Tvec :: \"'a list\"\n\n  shows \"subs (Cases Cs) xvec Tvec = Cases(caseListSubst Cs xvec Tvec)\"", "lemma substCases'[simp]:\n  fixes Cs   :: \"('c \\<times> ('a, 'b, 'c) psi) list\"\n  and   xvec :: \"name list\"\n  and   Tvec :: \"'a list\"\n\n  shows \"(subs'' (psiCases Cs) xvec Tvec) = psiCases(caseListSubst Cs xvec Tvec)\"", "lemma seqSubstSimps[simp]:\n  shows \"seqSubs (\\<zero>) \\<sigma> = \\<zero>\"\n  and   \"(seqSubs (M\\<langle>N\\<rangle>.P) \\<sigma>) = (substTerm.seqSubst M \\<sigma>)\\<langle>(substTerm.seqSubst N \\<sigma>)\\<rangle>.(seqSubs P \\<sigma>)\"\n  and   \"(seqSubs (M\\<lparr>I) \\<sigma>) = (substTerm.seqSubst M \\<sigma>)\\<lparr>(seqSubs' I \\<sigma>)\"\n\n  and   \"(seqSubs (Case C) \\<sigma>) = (Case (seqSubs'' C \\<sigma>))\"\n  and   \"(seqSubs (P \\<parallel> Q) \\<sigma>) = (seqSubs P \\<sigma>) \\<parallel> (seqSubs Q \\<sigma>)\"\n  and   \"\\<lbrakk>y \\<sharp> \\<sigma>\\<rbrakk> \\<Longrightarrow> (seqSubs (\\<lparr>\\<nu>y\\<rparr>P) \\<sigma>) = \\<lparr>\\<nu>y\\<rparr>(seqSubs P \\<sigma>)\"\n  and   \"(seqSubs (\\<lbrace>\\<Psi>\\<rbrace>) \\<sigma>) = \\<lbrace>(substAssert.seqSubst \\<Psi> \\<sigma>)\\<rbrace>\"\n  and   \"(seqSubs (!P) \\<sigma>) = !(seqSubs P \\<sigma>)\"\n  \n  and   \"(seqSubs' ((Trm M P)::('a::fs_name, 'b::fs_name, 'c::fs_name) input) \\<sigma>) = (\\<rparr>(substTerm.seqSubst M \\<sigma>).(seqSubs P \\<sigma>))\"\n  and   \"\\<lbrakk>y \\<sharp> \\<sigma>\\<rbrakk> \\<Longrightarrow> (seqSubs' (\\<nu> y I) \\<sigma>) = (\\<nu> y (seqSubs' I \\<sigma>))\"\n  \n  and   \"(seqSubs'' (\\<bottom>\\<^sub>c::('a::fs_name, 'b::fs_name, 'c::fs_name) psiCase) \\<sigma>) = \\<bottom>\\<^sub>c\"\n  and   \"(seqSubs'' (\\<box>\\<Phi> \\<Rightarrow> P C) \\<sigma>) = (\\<box>(substCond.seqSubst \\<Phi> \\<sigma>) \\<Rightarrow> (seqSubs P \\<sigma>) (seqSubs'' C \\<sigma>))\"", "lemma seqSubsNil[simp]:\n  \"seqSubs P [] = P\"", "lemma seqSubsCons[simp]:\n  shows \"seqSubs P ((xvec, Tvec)#\\<sigma>) = seqSubs(subs P xvec Tvec) \\<sigma>\"", "lemma seqSubsTermAppend[simp]:\n  shows \"seqSubs P (\\<sigma>@\\<sigma>') = seqSubs (seqSubs P \\<sigma>) \\<sigma>'\"", "lemma seqSubstCases[simp]:\n  fixes Cs :: \"('c \\<times> ('a, 'b, 'c) psi) list\"\n  and   \\<sigma>  :: \"(name list \\<times> 'a list) list\"\n\n  shows \"seqSubs (Cases Cs) \\<sigma> = Cases(caseListSeqSubst Cs \\<sigma>)\"", "lemma seqSubstCases'[simp]:\n  fixes Cs :: \"('c \\<times> ('a, 'b, 'c) psi) list\"\n  and   \\<sigma>  :: \"(name list \\<times> 'a list) list\"\n\n  shows \"(seqSubs'' (psiCases Cs) \\<sigma>) = psiCases(caseListSeqSubst Cs \\<sigma>)\"", "lemma seqSubstEqvt[eqvt]:\n  fixes P :: \"('a, 'b, 'c) psi\"\n  and   \\<sigma> :: \"(name list \\<times> 'a list) list\"\n  and   p :: \"name prm\"\n\n  shows \"(p \\<bullet> (P[<\\<sigma>>])) = (p \\<bullet> P)[<(p \\<bullet> \\<sigma>)>]\"", "lemma guardedSeqSubst:\n  assumes \"guarded P\"\n  and     \"wellFormedSubst \\<sigma>\"\n\n  shows \"guarded(seqSubs P \\<sigma>)\"", "lemma inter_eqvt:\n  shows \"(pi::name prm) \\<bullet> ((X::name set) \\<inter> Y) = (pi \\<bullet> X) \\<inter> (pi \\<bullet> Y)\"", "lemma delete_eqvt:\n  fixes p :: \"name prm\"\n  and   X :: \"name set\"\n  and   Y :: \"name set\"\n\n  shows \"p \\<bullet> (X - Y) = (p \\<bullet> X) - (p \\<bullet> Y)\"", "lemma perm_singleton[simp]:\n  shows \"(p::name prm) \\<bullet> {(x::name)} = {p \\<bullet> x}\""], "translations": [["", "lemma psiFreshSet[simp]:\n  fixes X :: \"name set\"\n  and   M :: \"'a::fs_name\"\n  and   N :: 'a\n  and   P :: \"('a, 'b::fs_name, 'c::fs_name) psi\"\n  and   I :: \"('a, 'b, 'c) input\"\n  and   C :: \"('a, 'b, 'c) psiCase\"\n  and   Q :: \"('a, 'b, 'c) psi\"\n  and   x :: name\n  and   \\<Psi> :: 'b\n  and   \\<Phi> :: 'c\n\n  shows \"X \\<sharp>* (M\\<langle>N\\<rangle>.P) = (X \\<sharp>* M \\<and> X \\<sharp>* N \\<and> X \\<sharp>* P)\"\n  and   \"X \\<sharp>* M\\<lparr>I = (X \\<sharp>* M \\<and> X \\<sharp>* I)\"\n  and   \"X \\<sharp>* Case C = X \\<sharp>* C\"\n  and   \"X \\<sharp>* (P \\<parallel> Q) = (X \\<sharp>* P \\<and> X \\<sharp>* Q)\"\n  and   \"X \\<sharp>* \\<lparr>\\<nu>x\\<rparr>P = (X \\<sharp>* [x].P)\"\n  and   \"X \\<sharp>* \\<lbrace>\\<Psi>\\<rbrace> = X \\<sharp>* \\<Psi>\"\n  and   \"X \\<sharp>* !P = X \\<sharp>* P\"\n  and   \"X \\<sharp>* \\<zero>\"\n  and   \"X \\<sharp>* Trm N P = (X \\<sharp>* N \\<and> X \\<sharp>* P)\"\n  and   \"X \\<sharp>* Bind x I = X \\<sharp>* ([x].I)\"\n\n  and   \"X \\<sharp>* \\<bottom>\\<^sub>c\"\n  and   \"X \\<sharp>* \\<box> \\<Phi> \\<Rightarrow> P C = (X \\<sharp>* \\<Phi> \\<and> X \\<sharp>* P \\<and> X \\<sharp>* C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((X \\<sharp>* M\\<langle>N\\<rangle>.P =\n      (X \\<sharp>* M \\<and> X \\<sharp>* N \\<and> X \\<sharp>* P) &&&\n      X \\<sharp>* M\\<lparr>I = (X \\<sharp>* M \\<and> X \\<sharp>* I) &&&\n      X \\<sharp>* Case C = X \\<sharp>* C) &&&\n     X \\<sharp>* (P \\<parallel> Q) =\n     (X \\<sharp>* P \\<and> X \\<sharp>* Q) &&&\n     X \\<sharp>* \\<lparr>\\<nu>x\\<rparr>P = X \\<sharp>* [x].P &&&\n     X \\<sharp>* \\<lbrace>\\<Psi>\\<rbrace> = X \\<sharp>* \\<Psi>) &&&\n    (X \\<sharp>* !P = X \\<sharp>* P &&&\n     X \\<sharp>* \\<zero> &&&\n     X \\<sharp>* \\<rparr>N.P = (X \\<sharp>* N \\<and> X \\<sharp>* P)) &&&\n    X \\<sharp>* \\<nu>xI = X \\<sharp>* [x].I &&&\n    X \\<sharp>* \\<bottom>\\<^sub>c &&&\n    X \\<sharp>* \\<box> \\<Phi> \\<Rightarrow> P C  =\n    (X \\<sharp>* \\<Phi> \\<and> X \\<sharp>* P \\<and> X \\<sharp>* C)", "by(auto simp add: fresh_star_def psi.fresh)+"], ["", "lemma psiFreshVec[simp]:\n  fixes xvec :: \"name list\"\n\n  shows \"xvec \\<sharp>* (M\\<langle>N\\<rangle>.P) = (xvec \\<sharp>* M \\<and> xvec \\<sharp>* N \\<and> xvec \\<sharp>* P)\"\n  and   \"xvec \\<sharp>* M\\<lparr>I = (xvec \\<sharp>* M \\<and> xvec \\<sharp>* I)\"\n  and   \"xvec \\<sharp>* Case C = xvec \\<sharp>* C\"\n  and   \"xvec \\<sharp>* (P \\<parallel> Q) = (xvec \\<sharp>* P \\<and> xvec \\<sharp>* Q)\"\n  and   \"xvec \\<sharp>* \\<lparr>\\<nu>x\\<rparr>P = (xvec \\<sharp>* [x].P)\"\n  and   \"xvec \\<sharp>* \\<lbrace>\\<Psi>\\<rbrace> = xvec \\<sharp>* \\<Psi>\"\n  and   \"xvec \\<sharp>* !P = xvec \\<sharp>* P\"\n  and   \"xvec \\<sharp>* \\<zero>\"\n\n  and   \"xvec \\<sharp>* Trm N P = (xvec \\<sharp>* N \\<and> xvec \\<sharp>* P)\"\n  and   \"xvec \\<sharp>* Bind x I = xvec \\<sharp>* ([x].I)\"\n\n  and   \"xvec \\<sharp>* \\<bottom>\\<^sub>c\"\n  and   \"xvec \\<sharp>* \\<box> \\<Phi> \\<Rightarrow> P C = (xvec \\<sharp>* \\<Phi> \\<and> xvec \\<sharp>* P \\<and> xvec \\<sharp>* C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((xvec \\<sharp>* M\\<langle>N\\<rangle>.P =\n      (xvec \\<sharp>* M \\<and> xvec \\<sharp>* N \\<and> xvec \\<sharp>* P) &&&\n      xvec \\<sharp>* M\\<lparr>I =\n      (xvec \\<sharp>* M \\<and> xvec \\<sharp>* I) &&&\n      xvec \\<sharp>* Case C = xvec \\<sharp>* C) &&&\n     xvec \\<sharp>* (P \\<parallel> Q) =\n     (xvec \\<sharp>* P \\<and> xvec \\<sharp>* Q) &&&\n     xvec \\<sharp>* \\<lparr>\\<nu>x\\<rparr>P = xvec \\<sharp>* [x].P &&&\n     xvec \\<sharp>* \\<lbrace>\\<Psi>\\<rbrace> = xvec \\<sharp>* \\<Psi>) &&&\n    (xvec \\<sharp>* !P = xvec \\<sharp>* P &&&\n     xvec \\<sharp>* \\<zero> &&&\n     xvec \\<sharp>* \\<rparr>N.P =\n     (xvec \\<sharp>* N \\<and> xvec \\<sharp>* P)) &&&\n    xvec \\<sharp>* \\<nu>xI = xvec \\<sharp>* [x].I &&&\n    xvec \\<sharp>* \\<bottom>\\<^sub>c &&&\n    xvec \\<sharp>* \\<box> \\<Phi> \\<Rightarrow> P C  =\n    (xvec \\<sharp>* \\<Phi> \\<and> xvec \\<sharp>* P \\<and> xvec \\<sharp>* C)", "by(auto simp add: fresh_star_def)"], ["", "fun psiCases :: \"('c::fs_name \\<times> ('a::fs_name, 'b::fs_name, 'c) psi) list \\<Rightarrow> ('a, 'b, 'c) psiCase\"\nwhere \n  base: \"psiCases [] = \\<bottom>\\<^sub>c\"\n| step: \"psiCases ((\\<Phi>, P)#xs) = Cond \\<Phi> P (psiCases xs)\""], ["", "lemma psiCasesEqvt[eqvt]:\n  fixes p  :: \"name prm\"\n  and   Cs :: \"('c::fs_name \\<times> ('a::fs_name, 'b::fs_name, 'c) psi) list\"\n\n  shows \"(p \\<bullet> (psiCases Cs)) = psiCases(p \\<bullet> Cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> psiCases Cs = psiCases (p \\<bullet> Cs)", "by(induct Cs) auto"], ["", "lemma psiCasesFresh[simp]:\n  fixes x  :: name\n  and   Cs :: \"('c::fs_name \\<times> ('a::fs_name, 'b::fs_name, 'c) psi) list\"\n  \n  shows \"x \\<sharp> psiCases Cs = x \\<sharp> Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> psiCases Cs = x \\<sharp> Cs", "by(induct Cs)\n  (auto simp add: fresh_list_nil fresh_list_cons)"], ["", "lemma psiCasesFreshChain[simp]:\n  fixes xvec :: \"name list\"\n  and   Cs :: \"('c::fs_name \\<times> ('a::fs_name, 'b::fs_name, 'c) psi) list\"\n  and   Xs   :: \"name set\"\n  \n  shows \"(xvec \\<sharp>* psiCases Cs) = xvec \\<sharp>* Cs\"\n  and   \"(Xs \\<sharp>* psiCases Cs) = Xs \\<sharp>* Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xvec \\<sharp>* psiCases Cs = xvec \\<sharp>* Cs &&&\n    Xs \\<sharp>* psiCases Cs = Xs \\<sharp>* Cs", "by(auto simp add: fresh_star_def)"], ["", "abbreviation\n  psiCasesJudge (\"Cases _\" [80] 80) where \"Cases Cs \\<equiv> Case(psiCases Cs)\""], ["", "primrec resChain :: \"name list \\<Rightarrow> ('a::fs_name, 'b::fs_name, 'c::fs_name) psi \\<Rightarrow> ('a, 'b, 'c) psi\" where\n  base: \"resChain [] P = P\"\n| step: \"resChain (x#xs) P = \\<lparr>\\<nu>x\\<rparr>(resChain xs P)\""], ["", "notation resChain (\"\\<lparr>\\<nu>*_\\<rparr>_\" [80, 80] 80)"], ["", "lemma resChainEqvt[eqvt]:\n  fixes perm :: \"name prm\"\n  and   lst  :: \"name list\"\n  and   P    :: \"('a::fs_name, 'b::fs_name, 'c::fs_name) psi\"\n  \n  shows \"perm \\<bullet> (\\<lparr>\\<nu>*xvec\\<rparr>P) = \\<lparr>\\<nu>*(perm \\<bullet> xvec)\\<rparr>(perm \\<bullet> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. perm \\<bullet> \\<lparr>\\<nu>*xvec\\<rparr>P =\n    \\<lparr>\\<nu>*perm \\<bullet> xvec\\<rparr>perm \\<bullet> P", "by(induct_tac xvec, auto)"], ["", "lemma resChainSupp:\n  fixes xvec :: \"name list\"\n  and   P    :: \"('a::fs_name, 'b::fs_name, 'c::fs_name) psi\"\n\n  shows \"supp(\\<lparr>\\<nu>*xvec\\<rparr>P) = (supp P) - set xvec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (\\<lparr>\\<nu>*xvec\\<rparr>P) = supp P - set xvec", "by(induct xvec) (auto simp add: psi.supp abs_supp)"], ["", "lemma resChainFresh: \n  fixes x    :: name\n  and   xvec :: \"name list\"\n  and   P    :: \"('a::fs_name, 'b::fs_name, 'c::fs_name) psi\"\n\n  shows \"x \\<sharp> \\<lparr>\\<nu>*xvec\\<rparr>P = (x \\<in> set xvec \\<or> x \\<sharp> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> \\<lparr>\\<nu>*xvec\\<rparr>P = (x mem xvec \\<or> x \\<sharp> P)", "by (induct xvec) (simp_all add: abs_fresh)"], ["", "lemma resChainFreshSet: \n  fixes Xs   :: \"name set\"\n  and   xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   P    :: \"('a::fs_name, 'b::fs_name, 'c::fs_name) psi\"\n\n  shows \"Xs \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>P) = (\\<forall>x\\<in>Xs. x \\<in> set xvec \\<or> x \\<sharp> P)\"\n  and   \"yvec \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>P) = (\\<forall>x\\<in>(set yvec). x \\<in> set xvec \\<or> x \\<sharp> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Xs \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>P) =\n    (\\<forall>x\\<in>Xs. x mem xvec \\<or> x \\<sharp> P) &&&\n    yvec \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>P) =\n    (\\<forall>x\\<in>set yvec. x mem xvec \\<or> x \\<sharp> P)", "by (simp add: fresh_star_def resChainFresh)+"], ["", "lemma resChainFreshSimps[simp]:\n  fixes Xs   :: \"name set\"\n  and   xvec :: \"name list\"\n  and   P    :: \"('a::fs_name, 'b::fs_name, 'c::fs_name) psi\"\n  and   yvec :: \"name list\"\n\n  shows \"Xs \\<sharp>* xvec \\<Longrightarrow> Xs \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>P) = (Xs \\<sharp>* P)\"\n  and   \"yvec \\<sharp>* xvec \\<Longrightarrow> yvec \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>P) = (yvec \\<sharp>* P)\"\n  and   \"xvec \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Xs \\<sharp>* xvec \\<Longrightarrow>\n     Xs \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>P) = Xs \\<sharp>* P) &&&\n    (yvec \\<sharp>* xvec \\<Longrightarrow>\n     yvec \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>P) = yvec \\<sharp>* P) &&&\n    xvec \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>P)", "apply(simp add: resChainFreshSet)"], ["proof (prove)\ngoal (3 subgoals):\n 1. Xs \\<sharp>* xvec \\<Longrightarrow>\n    (\\<forall>x\\<in>Xs. x mem xvec \\<or> x \\<sharp> P) = Xs \\<sharp>* P\n 2. yvec \\<sharp>* xvec \\<Longrightarrow>\n    yvec \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>P) = yvec \\<sharp>* P\n 3. xvec \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>P)", "apply(force simp add: fresh_star_def name_list_supp fresh_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. yvec \\<sharp>* xvec \\<Longrightarrow>\n    yvec \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>P) = yvec \\<sharp>* P\n 2. xvec \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>P)", "apply(simp add: resChainFreshSet)"], ["proof (prove)\ngoal (2 subgoals):\n 1. xvec \\<sharp>* yvec \\<Longrightarrow>\n    (\\<forall>x\\<in>set yvec. x mem xvec \\<or> x \\<sharp> P) =\n    yvec \\<sharp>* P\n 2. xvec \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>P)", "apply(force simp add: fresh_star_def name_list_supp fresh_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. xvec \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>P)", "by(simp add: resChainFreshSet)"], ["", "lemma resChainAlpha:\n  fixes p    :: \"name prm\"\n  and   xvec :: \"name list\"\n  and   P    :: \"('a::fs_name, 'b::fs_name, 'c::fs_name) psi\"\n\n  assumes xvecFreshP: \"(p \\<bullet> xvec) \\<sharp>* P\"\n  and     S: \"set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\"\n\n  shows \"\\<lparr>\\<nu>*xvec\\<rparr>P = \\<lparr>\\<nu>*(p \\<bullet> xvec)\\<rparr>(p \\<bullet> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>*xvec\\<rparr>P =\n    \\<lparr>\\<nu>*p \\<bullet> xvec\\<rparr>p \\<bullet> P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>*xvec\\<rparr>P =\n    \\<lparr>\\<nu>*p \\<bullet> xvec\\<rparr>p \\<bullet> P", "note pt_name_inst at_name_inst S"], ["proof (state)\nthis:\n  pt TYPE(?'x) TYPE(name)\n  at TYPE(name)\n  set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>*xvec\\<rparr>P =\n    \\<lparr>\\<nu>*p \\<bullet> xvec\\<rparr>p \\<bullet> P", "moreover"], ["proof (state)\nthis:\n  pt TYPE(?'x) TYPE(name)\n  at TYPE(name)\n  set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>*xvec\\<rparr>P =\n    \\<lparr>\\<nu>*p \\<bullet> xvec\\<rparr>p \\<bullet> P", "have \"set xvec \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xvec \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>P)", "by (simp add: resChainFreshSet)"], ["proof (state)\nthis:\n  set xvec \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>P)\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>*xvec\\<rparr>P =\n    \\<lparr>\\<nu>*p \\<bullet> xvec\\<rparr>p \\<bullet> P", "moreover"], ["proof (state)\nthis:\n  set xvec \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>P)\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>*xvec\\<rparr>P =\n    \\<lparr>\\<nu>*p \\<bullet> xvec\\<rparr>p \\<bullet> P", "from xvecFreshP"], ["proof (chain)\npicking this:\n  (p \\<bullet> xvec) \\<sharp>* P", "have \"set (p \\<bullet> xvec) \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>P)\""], ["proof (prove)\nusing this:\n  (p \\<bullet> xvec) \\<sharp>* P\n\ngoal (1 subgoal):\n 1. set (p \\<bullet> xvec) \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>P)", "by (simp add: resChainFreshSet) (simp add: fresh_star_def)"], ["proof (state)\nthis:\n  set (p \\<bullet> xvec) \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>P)\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>*xvec\\<rparr>P =\n    \\<lparr>\\<nu>*p \\<bullet> xvec\\<rparr>p \\<bullet> P", "ultimately"], ["proof (chain)\npicking this:\n  pt TYPE(?'x) TYPE(name)\n  at TYPE(name)\n  set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\n  set xvec \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>P)\n  set (p \\<bullet> xvec) \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>P)", "have \"\\<lparr>\\<nu>*xvec\\<rparr>P = p \\<bullet> (\\<lparr>\\<nu>*xvec\\<rparr>P)\""], ["proof (prove)\nusing this:\n  pt TYPE(?'x) TYPE(name)\n  at TYPE(name)\n  set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\n  set xvec \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>P)\n  set (p \\<bullet> xvec) \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>P)\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>*xvec\\<rparr>P = p \\<bullet> \\<lparr>\\<nu>*xvec\\<rparr>P", "by (rule_tac pt_freshs_freshs [symmetric])"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>*xvec\\<rparr>P = p \\<bullet> \\<lparr>\\<nu>*xvec\\<rparr>P\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>*xvec\\<rparr>P =\n    \\<lparr>\\<nu>*p \\<bullet> xvec\\<rparr>p \\<bullet> P", "then"], ["proof (chain)\npicking this:\n  \\<lparr>\\<nu>*xvec\\<rparr>P = p \\<bullet> \\<lparr>\\<nu>*xvec\\<rparr>P", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lparr>\\<nu>*xvec\\<rparr>P = p \\<bullet> \\<lparr>\\<nu>*xvec\\<rparr>P\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>*xvec\\<rparr>P =\n    \\<lparr>\\<nu>*p \\<bullet> xvec\\<rparr>p \\<bullet> P", "by(simp add: eqvts)"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>*xvec\\<rparr>P =\n  \\<lparr>\\<nu>*p \\<bullet> xvec\\<rparr>p \\<bullet> P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma resChainAppend:\n  fixes xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   P    :: \"('a::fs_name, 'b::fs_name, 'c::fs_name) psi\"\n  \n  shows \"\\<lparr>\\<nu>*(xvec@yvec)\\<rparr>P = \\<lparr>\\<nu>*xvec\\<rparr>(\\<lparr>\\<nu>*yvec\\<rparr>P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>*(xvec @ yvec)\\<rparr>P =\n    \\<lparr>\\<nu>*xvec\\<rparr>\\<lparr>\\<nu>*yvec\\<rparr>P", "by(induct xvec) auto"], ["", "lemma resChainSimps[dest]:\n  fixes xvec :: \"name list\"\n  and   P    :: \"('a::fs_name, 'b::fs_name, 'c::fs_name) psi\"\n  and   Q    :: \"('a, 'b, 'c) psi\"\n  and   P'   :: \"('a, 'b, 'c) psi\"\n  and   Q'   :: \"('a, 'b, 'c) psi\"\n\n  shows \"((\\<lparr>\\<nu>*xvec\\<rparr>(P \\<parallel> Q)) = P' \\<parallel> Q') \\<Longrightarrow> (P = P' \\<and> Q = Q')\"\n  and   \"(P \\<parallel> Q = \\<lparr>\\<nu>*xvec\\<rparr>(P' \\<parallel> Q')) \\<Longrightarrow> (P = P' \\<and> Q = Q')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lparr>\\<nu>*xvec\\<rparr>P \\<parallel> Q =\n     P' \\<parallel> Q' \\<Longrightarrow>\n     P = P' \\<and> Q = Q') &&&\n    (P \\<parallel> Q =\n     \\<lparr>\\<nu>*xvec\\<rparr>P' \\<parallel> Q' \\<Longrightarrow>\n     P = P' \\<and> Q = Q')", "by(case_tac xvec, simp_all add: psi.inject)+"], ["", "primrec inputChain :: \"name list \\<Rightarrow> 'a::fs_name \\<Rightarrow> ('a, 'b::fs_name, 'c::fs_name) psi \\<Rightarrow> ('a, 'b, 'c) input\" where\n  base: \"inputChain [] N P = \\<rparr>(N).P\"\n| step: \"inputChain (x#xs) N P = \\<nu> x (inputChain xs N P)\""], ["", "abbreviation\n  inputChainJudge (\"_\\<lparr>\\<lambda>*_ _\\<rparr>._\" [80, 80, 80, 80] 80) where \"M\\<lparr>\\<lambda>*xvec N\\<rparr>.P \\<equiv> M\\<lparr>(inputChain xvec N P)\""], ["", "lemma inputChainEqvt[eqvt]:\n  fixes p    :: \"name prm\"\n  and   xvec :: \"name list\"\n  and   N    :: \"'a::fs_name\"\n  and   P    :: \"('a, 'b::fs_name, 'c::fs_name) psi\"\n  \n  shows \"p \\<bullet> (inputChain xvec N P) = inputChain (p \\<bullet> xvec) (p \\<bullet> N) (p \\<bullet> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> inputChain xvec N P =\n    inputChain (p \\<bullet> xvec) (p \\<bullet> N) (p \\<bullet> P)", "by(induct_tac xvec) auto"], ["", "lemma inputChainFresh: \n  fixes x    :: name\n  and   xvec :: \"name list\"\n  and   N    :: \"'a::fs_name\"\n  and   P    :: \"('a, 'b::fs_name, 'c::fs_name) psi\"\n\n  shows \"x \\<sharp> (inputChain xvec N P) = (x \\<in> set xvec \\<or> (x \\<sharp> N \\<and> x \\<sharp> P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> inputChain xvec N P =\n    (x mem xvec \\<or> x \\<sharp> N \\<and> x \\<sharp> P)", "by (induct xvec) (simp_all add: abs_fresh)"], ["", "lemma inductChainSimps[simp]:\n  fixes xvec :: \"name list\"\n  and   N    :: \"'a::fs_name\"\n  and   P    :: \"('a, 'b::fs_name, 'c::fs_name) psi\"\n\n  shows \"xvec \\<sharp>* (inputChain xvec N P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xvec \\<sharp>* inputChain xvec N P", "by(induct xvec) (auto simp add: abs_fresh abs_fresh_star fresh_star_def)"], ["", "lemma inputChainFreshSet: \n  fixes Xs   :: \"name set\"\n  and   xvec :: \"name list\"\n  and   N    :: \"'a::fs_name\"\n  and   P    :: \"('a, 'b::fs_name, 'c::fs_name) psi\"\n\n  shows \"Xs \\<sharp>* (inputChain xvec N P) = (\\<forall>x\\<in>Xs. x \\<in> set xvec \\<or> (x \\<sharp> N \\<and> x \\<sharp> P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Xs \\<sharp>* inputChain xvec N P =\n    (\\<forall>x\\<in>Xs. x mem xvec \\<or> x \\<sharp> N \\<and> x \\<sharp> P)", "by (simp add: fresh_star_def inputChainFresh)"], ["", "lemma inputChainAlpha:\n  fixes p  :: \"name prm\"\n  and   Xs :: \"name set\"\n  and   Ys :: \"name set\"\n\n  assumes XsFreshP: \"Xs \\<sharp>* (inputChain xvec N P)\"\n  and     YsFreshN: \"Ys \\<sharp>* N\"\n  and     YsFreshP: \"Ys \\<sharp>* P\"\n  and     S: \"set p \\<subseteq> Xs \\<times> Ys\"\n\n  shows \"(inputChain xvec N P) = (inputChain (p \\<bullet> xvec) (p \\<bullet> N) (p \\<bullet> P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inputChain xvec N P =\n    inputChain (p \\<bullet> xvec) (p \\<bullet> N) (p \\<bullet> P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inputChain xvec N P =\n    inputChain (p \\<bullet> xvec) (p \\<bullet> N) (p \\<bullet> P)", "note pt_name_inst at_name_inst XsFreshP S"], ["proof (state)\nthis:\n  pt TYPE(?'x) TYPE(name)\n  at TYPE(name)\n  Xs \\<sharp>* inputChain xvec N P\n  set p \\<subseteq> Xs \\<times> Ys\n\ngoal (1 subgoal):\n 1. inputChain xvec N P =\n    inputChain (p \\<bullet> xvec) (p \\<bullet> N) (p \\<bullet> P)", "moreover"], ["proof (state)\nthis:\n  pt TYPE(?'x) TYPE(name)\n  at TYPE(name)\n  Xs \\<sharp>* inputChain xvec N P\n  set p \\<subseteq> Xs \\<times> Ys\n\ngoal (1 subgoal):\n 1. inputChain xvec N P =\n    inputChain (p \\<bullet> xvec) (p \\<bullet> N) (p \\<bullet> P)", "from YsFreshN YsFreshP"], ["proof (chain)\npicking this:\n  Ys \\<sharp>* N\n  Ys \\<sharp>* P", "have \"Ys \\<sharp>* (inputChain xvec N P)\""], ["proof (prove)\nusing this:\n  Ys \\<sharp>* N\n  Ys \\<sharp>* P\n\ngoal (1 subgoal):\n 1. Ys \\<sharp>* inputChain xvec N P", "by (simp add: inputChainFreshSet) (simp add: fresh_star_def)"], ["proof (state)\nthis:\n  Ys \\<sharp>* inputChain xvec N P\n\ngoal (1 subgoal):\n 1. inputChain xvec N P =\n    inputChain (p \\<bullet> xvec) (p \\<bullet> N) (p \\<bullet> P)", "ultimately"], ["proof (chain)\npicking this:\n  pt TYPE(?'x) TYPE(name)\n  at TYPE(name)\n  Xs \\<sharp>* inputChain xvec N P\n  set p \\<subseteq> Xs \\<times> Ys\n  Ys \\<sharp>* inputChain xvec N P", "have \"(inputChain xvec N P) = p \\<bullet> (inputChain xvec N P)\""], ["proof (prove)\nusing this:\n  pt TYPE(?'x) TYPE(name)\n  at TYPE(name)\n  Xs \\<sharp>* inputChain xvec N P\n  set p \\<subseteq> Xs \\<times> Ys\n  Ys \\<sharp>* inputChain xvec N P\n\ngoal (1 subgoal):\n 1. inputChain xvec N P = p \\<bullet> inputChain xvec N P", "by (rule_tac pt_freshs_freshs [symmetric])"], ["proof (state)\nthis:\n  inputChain xvec N P = p \\<bullet> inputChain xvec N P\n\ngoal (1 subgoal):\n 1. inputChain xvec N P =\n    inputChain (p \\<bullet> xvec) (p \\<bullet> N) (p \\<bullet> P)", "then"], ["proof (chain)\npicking this:\n  inputChain xvec N P = p \\<bullet> inputChain xvec N P", "show ?thesis"], ["proof (prove)\nusing this:\n  inputChain xvec N P = p \\<bullet> inputChain xvec N P\n\ngoal (1 subgoal):\n 1. inputChain xvec N P =\n    inputChain (p \\<bullet> xvec) (p \\<bullet> N) (p \\<bullet> P)", "by(simp add: eqvts)"], ["proof (state)\nthis:\n  inputChain xvec N P =\n  inputChain (p \\<bullet> xvec) (p \\<bullet> N) (p \\<bullet> P)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inputChainAlpha':\n  fixes p    :: \"name prm\"\n  and   xvec :: \"name list\"\n  and   N    :: \"'a::fs_name\"\n  and   P    :: \"('a, 'b::fs_name, 'c::fs_name) psi\"\n\n  assumes xvecFreshP: \"(p \\<bullet> xvec) \\<sharp>* P\"\n  and     xvecFreshN: \"(p \\<bullet> xvec) \\<sharp>* N\"\n  and     S: \"set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\"\n\n  shows \"(inputChain xvec N P) = (inputChain (p \\<bullet> xvec) (p \\<bullet> N) (p \\<bullet> P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inputChain xvec N P =\n    inputChain (p \\<bullet> xvec) (p \\<bullet> N) (p \\<bullet> P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inputChain xvec N P =\n    inputChain (p \\<bullet> xvec) (p \\<bullet> N) (p \\<bullet> P)", "note pt_name_inst at_name_inst S"], ["proof (state)\nthis:\n  pt TYPE(?'x) TYPE(name)\n  at TYPE(name)\n  set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\n\ngoal (1 subgoal):\n 1. inputChain xvec N P =\n    inputChain (p \\<bullet> xvec) (p \\<bullet> N) (p \\<bullet> P)", "moreover"], ["proof (state)\nthis:\n  pt TYPE(?'x) TYPE(name)\n  at TYPE(name)\n  set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\n\ngoal (1 subgoal):\n 1. inputChain xvec N P =\n    inputChain (p \\<bullet> xvec) (p \\<bullet> N) (p \\<bullet> P)", "have \"set xvec \\<sharp>* (inputChain xvec N P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xvec \\<sharp>* inputChain xvec N P", "by (simp add: inputChainFreshSet)"], ["proof (state)\nthis:\n  set xvec \\<sharp>* inputChain xvec N P\n\ngoal (1 subgoal):\n 1. inputChain xvec N P =\n    inputChain (p \\<bullet> xvec) (p \\<bullet> N) (p \\<bullet> P)", "ultimately"], ["proof (chain)\npicking this:\n  pt TYPE(?'x) TYPE(name)\n  at TYPE(name)\n  set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\n  set xvec \\<sharp>* inputChain xvec N P", "show ?thesis"], ["proof (prove)\nusing this:\n  pt TYPE(?'x) TYPE(name)\n  at TYPE(name)\n  set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\n  set xvec \\<sharp>* inputChain xvec N P\n\ngoal (1 subgoal):\n 1. inputChain xvec N P =\n    inputChain (p \\<bullet> xvec) (p \\<bullet> N) (p \\<bullet> P)", "using xvecFreshN xvecFreshP"], ["proof (prove)\nusing this:\n  pt TYPE(?'x) TYPE(name)\n  at TYPE(name)\n  set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\n  set xvec \\<sharp>* inputChain xvec N P\n  (p \\<bullet> xvec) \\<sharp>* N\n  (p \\<bullet> xvec) \\<sharp>* P\n\ngoal (1 subgoal):\n 1. inputChain xvec N P =\n    inputChain (p \\<bullet> xvec) (p \\<bullet> N) (p \\<bullet> P)", "by(rule_tac inputChainAlpha) (simp add: fresh_star_def)+"], ["proof (state)\nthis:\n  inputChain xvec N P =\n  inputChain (p \\<bullet> xvec) (p \\<bullet> N) (p \\<bullet> P)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma alphaRes:\n  fixes M :: \"'a::fs_name\"\n  and   x :: name\n  and   P :: \"('a, 'b::fs_name, 'c::fs_name) psi\"\n  and   y :: name\n\n  assumes yFreshP: \"y \\<sharp> P\"\n\n  shows \"\\<lparr>\\<nu>x\\<rparr>P = \\<lparr>\\<nu>y\\<rparr>([(x, y)] \\<bullet> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>P = \\<lparr>\\<nu>y\\<rparr>([(x, y)] \\<bullet> P)", "proof(cases \"x = y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    \\<lparr>\\<nu>x\\<rparr>P = \\<lparr>\\<nu>y\\<rparr>([(x, y)] \\<bullet> P)\n 2. x \\<noteq> y \\<Longrightarrow>\n    \\<lparr>\\<nu>x\\<rparr>P = \\<lparr>\\<nu>y\\<rparr>([(x, y)] \\<bullet> P)", "assume \"x=y\""], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    \\<lparr>\\<nu>x\\<rparr>P = \\<lparr>\\<nu>y\\<rparr>([(x, y)] \\<bullet> P)\n 2. x \\<noteq> y \\<Longrightarrow>\n    \\<lparr>\\<nu>x\\<rparr>P = \\<lparr>\\<nu>y\\<rparr>([(x, y)] \\<bullet> P)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = y\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>P = \\<lparr>\\<nu>y\\<rparr>([(x, y)] \\<bullet> P)", "by simp"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>P = \\<lparr>\\<nu>y\\<rparr>([(x, y)] \\<bullet> P)\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    \\<lparr>\\<nu>x\\<rparr>P = \\<lparr>\\<nu>y\\<rparr>([(x, y)] \\<bullet> P)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    \\<lparr>\\<nu>x\\<rparr>P = \\<lparr>\\<nu>y\\<rparr>([(x, y)] \\<bullet> P)", "assume \"x \\<noteq> y\""], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    \\<lparr>\\<nu>x\\<rparr>P = \\<lparr>\\<nu>y\\<rparr>([(x, y)] \\<bullet> P)", "with yFreshP"], ["proof (chain)\npicking this:\n  y \\<sharp> P\n  x \\<noteq> y", "show ?thesis"], ["proof (prove)\nusing this:\n  y \\<sharp> P\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>P = \\<lparr>\\<nu>y\\<rparr>([(x, y)] \\<bullet> P)", "by(perm_simp add: psi.inject alpha calc_atm fresh_left)"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>P = \\<lparr>\\<nu>y\\<rparr>([(x, y)] \\<bullet> P)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma alphaInput:\n  fixes x :: name\n  and   I :: \"('a::fs_name, 'b::fs_name, 'c::fs_name) input\"\n  and   c :: name\n\n  assumes A1: \"c \\<sharp> I\"\n\n  shows \"\\<nu> x I = \\<nu> c([(x, c)] \\<bullet> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>xI = \\<nu>c([(x, c)] \\<bullet> I)", "proof(cases \"x = c\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = c \\<Longrightarrow> \\<nu>xI = \\<nu>c([(x, c)] \\<bullet> I)\n 2. x \\<noteq> c \\<Longrightarrow> \\<nu>xI = \\<nu>c([(x, c)] \\<bullet> I)", "assume \"x=c\""], ["proof (state)\nthis:\n  x = c\n\ngoal (2 subgoals):\n 1. x = c \\<Longrightarrow> \\<nu>xI = \\<nu>c([(x, c)] \\<bullet> I)\n 2. x \\<noteq> c \\<Longrightarrow> \\<nu>xI = \\<nu>c([(x, c)] \\<bullet> I)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = c\n\ngoal (1 subgoal):\n 1. \\<nu>xI = \\<nu>c([(x, c)] \\<bullet> I)", "by simp"], ["proof (state)\nthis:\n  \\<nu>xI = \\<nu>c([(x, c)] \\<bullet> I)\n\ngoal (1 subgoal):\n 1. x \\<noteq> c \\<Longrightarrow> \\<nu>xI = \\<nu>c([(x, c)] \\<bullet> I)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> c \\<Longrightarrow> \\<nu>xI = \\<nu>c([(x, c)] \\<bullet> I)", "assume \"x \\<noteq> c\""], ["proof (state)\nthis:\n  x \\<noteq> c\n\ngoal (1 subgoal):\n 1. x \\<noteq> c \\<Longrightarrow> \\<nu>xI = \\<nu>c([(x, c)] \\<bullet> I)", "with A1"], ["proof (chain)\npicking this:\n  c \\<sharp> I\n  x \\<noteq> c", "show ?thesis"], ["proof (prove)\nusing this:\n  c \\<sharp> I\n  x \\<noteq> c\n\ngoal (1 subgoal):\n 1. \\<nu>xI = \\<nu>c([(x, c)] \\<bullet> I)", "by(perm_simp add: input.inject alpha calc_atm fresh_left)"], ["proof (state)\nthis:\n  \\<nu>xI = \\<nu>c([(x, c)] \\<bullet> I)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inputChainLengthEq:\n  fixes xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   M    :: \"'a::fs_name\"\n  and   P    :: \"('a, 'b::fs_name, 'c::fs_name) psi\"\n\n  assumes \"length xvec = length yvec\"\n  and     \"xvec \\<sharp>* yvec\"\n  and     \"distinct yvec\"\n  and     \"yvec \\<sharp>* M\"\n  and     \"yvec \\<sharp>* P\"\n\n  obtains N Q where \"inputChain xvec M P = inputChain yvec N Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>N Q.\n        inputChain xvec M P = inputChain yvec N Q \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>N Q.\n        inputChain xvec M P = inputChain yvec N Q \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "assume \"\\<And>N Q. inputChain xvec M P = inputChain yvec N Q \\<Longrightarrow> thesis\""], ["proof (state)\nthis:\n  inputChain xvec M P = inputChain yvec ?N ?Q \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<And>N Q.\n        inputChain xvec M P = inputChain yvec N Q \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  inputChain xvec M P = inputChain yvec ?N ?Q \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<And>N Q.\n        inputChain xvec M P = inputChain yvec N Q \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "obtain n where \"n = length xvec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n. n = length xvec \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n = length xvec\n\ngoal (1 subgoal):\n 1. (\\<And>N Q.\n        inputChain xvec M P = inputChain yvec N Q \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "with assms"], ["proof (chain)\npicking this:\n  length xvec = length yvec\n  xvec \\<sharp>* yvec\n  distinct yvec\n  yvec \\<sharp>* M\n  yvec \\<sharp>* P\n  n = length xvec", "have \"\\<exists>N Q. inputChain xvec M P = inputChain yvec N Q\""], ["proof (prove)\nusing this:\n  length xvec = length yvec\n  xvec \\<sharp>* yvec\n  distinct yvec\n  yvec \\<sharp>* M\n  yvec \\<sharp>* P\n  n = length xvec\n\ngoal (1 subgoal):\n 1. \\<exists>N Q. inputChain xvec M P = inputChain yvec N Q", "proof(induct n arbitrary: xvec yvec M P)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xvec yvec M P.\n       \\<lbrakk>length xvec = length yvec; xvec \\<sharp>* yvec;\n        distinct yvec; yvec \\<sharp>* M; yvec \\<sharp>* P;\n        0 = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>N Q.\n                            inputChain xvec M P = inputChain yvec N Q\n 2. \\<And>n xvec yvec M P.\n       \\<lbrakk>\\<And>xvec yvec M P.\n                   \\<lbrakk>length xvec = length yvec; xvec \\<sharp>* yvec;\n                    distinct yvec; yvec \\<sharp>* M; yvec \\<sharp>* P;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>N Q.\n  inputChain xvec M P = inputChain yvec N Q;\n        length xvec = length yvec; xvec \\<sharp>* yvec; distinct yvec;\n        yvec \\<sharp>* M; yvec \\<sharp>* P; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>N Q.\n                            inputChain xvec M P = inputChain yvec N Q", "case 0"], ["proof (state)\nthis:\n  length xvec = length yvec\n  xvec \\<sharp>* yvec\n  distinct yvec\n  yvec \\<sharp>* M\n  yvec \\<sharp>* P\n  0 = length xvec\n\ngoal (2 subgoals):\n 1. \\<And>xvec yvec M P.\n       \\<lbrakk>length xvec = length yvec; xvec \\<sharp>* yvec;\n        distinct yvec; yvec \\<sharp>* M; yvec \\<sharp>* P;\n        0 = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>N Q.\n                            inputChain xvec M P = inputChain yvec N Q\n 2. \\<And>n xvec yvec M P.\n       \\<lbrakk>\\<And>xvec yvec M P.\n                   \\<lbrakk>length xvec = length yvec; xvec \\<sharp>* yvec;\n                    distinct yvec; yvec \\<sharp>* M; yvec \\<sharp>* P;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>N Q.\n  inputChain xvec M P = inputChain yvec N Q;\n        length xvec = length yvec; xvec \\<sharp>* yvec; distinct yvec;\n        yvec \\<sharp>* M; yvec \\<sharp>* P; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>N Q.\n                            inputChain xvec M P = inputChain yvec N Q", "thus ?case"], ["proof (prove)\nusing this:\n  length xvec = length yvec\n  xvec \\<sharp>* yvec\n  distinct yvec\n  yvec \\<sharp>* M\n  yvec \\<sharp>* P\n  0 = length xvec\n\ngoal (1 subgoal):\n 1. \\<exists>N Q. inputChain xvec M P = inputChain yvec N Q", "by auto"], ["proof (state)\nthis:\n  \\<exists>N Q. inputChain xvec M P = inputChain yvec N Q\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M P.\n       \\<lbrakk>\\<And>xvec yvec M P.\n                   \\<lbrakk>length xvec = length yvec; xvec \\<sharp>* yvec;\n                    distinct yvec; yvec \\<sharp>* M; yvec \\<sharp>* P;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>N Q.\n  inputChain xvec M P = inputChain yvec N Q;\n        length xvec = length yvec; xvec \\<sharp>* yvec; distinct yvec;\n        yvec \\<sharp>* M; yvec \\<sharp>* P; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>N Q.\n                            inputChain xvec M P = inputChain yvec N Q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M P.\n       \\<lbrakk>\\<And>xvec yvec M P.\n                   \\<lbrakk>length xvec = length yvec; xvec \\<sharp>* yvec;\n                    distinct yvec; yvec \\<sharp>* M; yvec \\<sharp>* P;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>N Q.\n  inputChain xvec M P = inputChain yvec N Q;\n        length xvec = length yvec; xvec \\<sharp>* yvec; distinct yvec;\n        yvec \\<sharp>* M; yvec \\<sharp>* P; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>N Q.\n                            inputChain xvec M P = inputChain yvec N Q", "case(Suc n xvec yvec M P)"], ["proof (state)\nthis:\n  \\<lbrakk>length ?xvec = length ?yvec; ?xvec \\<sharp>* ?yvec;\n   distinct ?yvec; ?yvec \\<sharp>* ?M; ?yvec \\<sharp>* ?P;\n   n = length ?xvec\\<rbrakk>\n  \\<Longrightarrow> \\<exists>N Q.\n                       inputChain ?xvec ?M ?P = inputChain ?yvec N Q\n  length xvec = length yvec\n  xvec \\<sharp>* yvec\n  distinct yvec\n  yvec \\<sharp>* M\n  yvec \\<sharp>* P\n  Suc n = length xvec\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M P.\n       \\<lbrakk>\\<And>xvec yvec M P.\n                   \\<lbrakk>length xvec = length yvec; xvec \\<sharp>* yvec;\n                    distinct yvec; yvec \\<sharp>* M; yvec \\<sharp>* P;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>N Q.\n  inputChain xvec M P = inputChain yvec N Q;\n        length xvec = length yvec; xvec \\<sharp>* yvec; distinct yvec;\n        yvec \\<sharp>* M; yvec \\<sharp>* P; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>N Q.\n                            inputChain xvec M P = inputChain yvec N Q", "from \\<open>Suc n = length xvec\\<close>"], ["proof (chain)\npicking this:\n  Suc n = length xvec", "obtain x xvec' where \"xvec = x#xvec'\" and \"length xvec' = n\""], ["proof (prove)\nusing this:\n  Suc n = length xvec\n\ngoal (1 subgoal):\n 1. (\\<And>x xvec'.\n        \\<lbrakk>xvec = x # xvec'; length xvec' = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(case_tac xvec) auto"], ["proof (state)\nthis:\n  xvec = x # xvec'\n  length xvec' = n\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M P.\n       \\<lbrakk>\\<And>xvec yvec M P.\n                   \\<lbrakk>length xvec = length yvec; xvec \\<sharp>* yvec;\n                    distinct yvec; yvec \\<sharp>* M; yvec \\<sharp>* P;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>N Q.\n  inputChain xvec M P = inputChain yvec N Q;\n        length xvec = length yvec; xvec \\<sharp>* yvec; distinct yvec;\n        yvec \\<sharp>* M; yvec \\<sharp>* P; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>N Q.\n                            inputChain xvec M P = inputChain yvec N Q", "with \\<open>length xvec = length yvec\\<close>"], ["proof (chain)\npicking this:\n  length xvec = length yvec\n  xvec = x # xvec'\n  length xvec' = n", "obtain y yvec' where \"yvec = y#yvec'\""], ["proof (prove)\nusing this:\n  length xvec = length yvec\n  xvec = x # xvec'\n  length xvec' = n\n\ngoal (1 subgoal):\n 1. (\\<And>y yvec'.\n        yvec = y # yvec' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(case_tac yvec) auto"], ["proof (state)\nthis:\n  yvec = y # yvec'\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M P.\n       \\<lbrakk>\\<And>xvec yvec M P.\n                   \\<lbrakk>length xvec = length yvec; xvec \\<sharp>* yvec;\n                    distinct yvec; yvec \\<sharp>* M; yvec \\<sharp>* P;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>N Q.\n  inputChain xvec M P = inputChain yvec N Q;\n        length xvec = length yvec; xvec \\<sharp>* yvec; distinct yvec;\n        yvec \\<sharp>* M; yvec \\<sharp>* P; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>N Q.\n                            inputChain xvec M P = inputChain yvec N Q", "from \\<open>yvec = y#yvec'\\<close> \\<open>xvec=x#xvec'\\<close> \\<open>xvec \\<sharp>* yvec\\<close> \\<open>distinct yvec\\<close> \\<open>length xvec = length yvec\\<close> \\<open>yvec \\<sharp>* M\\<close> \\<open>yvec \\<sharp>* P\\<close>"], ["proof (chain)\npicking this:\n  yvec = y # yvec'\n  xvec = x # xvec'\n  xvec \\<sharp>* yvec\n  distinct yvec\n  length xvec = length yvec\n  yvec \\<sharp>* M\n  yvec \\<sharp>* P", "have \"length xvec' = length yvec'\" and \"xvec' \\<sharp>* yvec'\" and \"distinct yvec'\" and \"yvec' \\<sharp>* M\" and \"yvec' \\<sharp>* P\""], ["proof (prove)\nusing this:\n  yvec = y # yvec'\n  xvec = x # xvec'\n  xvec \\<sharp>* yvec\n  distinct yvec\n  length xvec = length yvec\n  yvec \\<sharp>* M\n  yvec \\<sharp>* P\n\ngoal (1 subgoal):\n 1. (length xvec' = length yvec' &&& xvec' \\<sharp>* yvec') &&&\n    distinct yvec' &&& yvec' \\<sharp>* M &&& yvec' \\<sharp>* P", "by simp+"], ["proof (state)\nthis:\n  length xvec' = length yvec'\n  xvec' \\<sharp>* yvec'\n  distinct yvec'\n  yvec' \\<sharp>* M\n  yvec' \\<sharp>* P\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M P.\n       \\<lbrakk>\\<And>xvec yvec M P.\n                   \\<lbrakk>length xvec = length yvec; xvec \\<sharp>* yvec;\n                    distinct yvec; yvec \\<sharp>* M; yvec \\<sharp>* P;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>N Q.\n  inputChain xvec M P = inputChain yvec N Q;\n        length xvec = length yvec; xvec \\<sharp>* yvec; distinct yvec;\n        yvec \\<sharp>* M; yvec \\<sharp>* P; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>N Q.\n                            inputChain xvec M P = inputChain yvec N Q", "then"], ["proof (chain)\npicking this:\n  length xvec' = length yvec'\n  xvec' \\<sharp>* yvec'\n  distinct yvec'\n  yvec' \\<sharp>* M\n  yvec' \\<sharp>* P", "obtain N Q where Eq: \"inputChain xvec' M P = inputChain yvec' N Q\""], ["proof (prove)\nusing this:\n  length xvec' = length yvec'\n  xvec' \\<sharp>* yvec'\n  distinct yvec'\n  yvec' \\<sharp>* M\n  yvec' \\<sharp>* P\n\ngoal (1 subgoal):\n 1. (\\<And>N Q.\n        inputChain xvec' M P = inputChain yvec' N Q \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>length xvec' = n\\<close>"], ["proof (prove)\nusing this:\n  length xvec' = length yvec'\n  xvec' \\<sharp>* yvec'\n  distinct yvec'\n  yvec' \\<sharp>* M\n  yvec' \\<sharp>* P\n  length xvec' = n\n\ngoal (1 subgoal):\n 1. (\\<And>N Q.\n        inputChain xvec' M P = inputChain yvec' N Q \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(drule_tac Suc) auto"], ["proof (state)\nthis:\n  inputChain xvec' M P = inputChain yvec' N Q\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M P.\n       \\<lbrakk>\\<And>xvec yvec M P.\n                   \\<lbrakk>length xvec = length yvec; xvec \\<sharp>* yvec;\n                    distinct yvec; yvec \\<sharp>* M; yvec \\<sharp>* P;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>N Q.\n  inputChain xvec M P = inputChain yvec N Q;\n        length xvec = length yvec; xvec \\<sharp>* yvec; distinct yvec;\n        yvec \\<sharp>* M; yvec \\<sharp>* P; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>N Q.\n                            inputChain xvec M P = inputChain yvec N Q", "moreover"], ["proof (state)\nthis:\n  inputChain xvec' M P = inputChain yvec' N Q\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M P.\n       \\<lbrakk>\\<And>xvec yvec M P.\n                   \\<lbrakk>length xvec = length yvec; xvec \\<sharp>* yvec;\n                    distinct yvec; yvec \\<sharp>* M; yvec \\<sharp>* P;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>N Q.\n  inputChain xvec M P = inputChain yvec N Q;\n        length xvec = length yvec; xvec \\<sharp>* yvec; distinct yvec;\n        yvec \\<sharp>* M; yvec \\<sharp>* P; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>N Q.\n                            inputChain xvec M P = inputChain yvec N Q", "from \\<open>distinct yvec\\<close> \\<open>yvec = y#yvec'\\<close>"], ["proof (chain)\npicking this:\n  distinct yvec\n  yvec = y # yvec'", "have \"y \\<sharp> yvec'\""], ["proof (prove)\nusing this:\n  distinct yvec\n  yvec = y # yvec'\n\ngoal (1 subgoal):\n 1. y \\<sharp> yvec'", "by auto"], ["proof (state)\nthis:\n  y \\<sharp> yvec'\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M P.\n       \\<lbrakk>\\<And>xvec yvec M P.\n                   \\<lbrakk>length xvec = length yvec; xvec \\<sharp>* yvec;\n                    distinct yvec; yvec \\<sharp>* M; yvec \\<sharp>* P;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>N Q.\n  inputChain xvec M P = inputChain yvec N Q;\n        length xvec = length yvec; xvec \\<sharp>* yvec; distinct yvec;\n        yvec \\<sharp>* M; yvec \\<sharp>* P; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>N Q.\n                            inputChain xvec M P = inputChain yvec N Q", "moreover"], ["proof (state)\nthis:\n  y \\<sharp> yvec'\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M P.\n       \\<lbrakk>\\<And>xvec yvec M P.\n                   \\<lbrakk>length xvec = length yvec; xvec \\<sharp>* yvec;\n                    distinct yvec; yvec \\<sharp>* M; yvec \\<sharp>* P;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>N Q.\n  inputChain xvec M P = inputChain yvec N Q;\n        length xvec = length yvec; xvec \\<sharp>* yvec; distinct yvec;\n        yvec \\<sharp>* M; yvec \\<sharp>* P; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>N Q.\n                            inputChain xvec M P = inputChain yvec N Q", "from \\<open>xvec \\<sharp>* yvec\\<close> \\<open>xvec = x#xvec'\\<close> \\<open>yvec=y#yvec'\\<close>"], ["proof (chain)\npicking this:\n  xvec \\<sharp>* yvec\n  xvec = x # xvec'\n  yvec = y # yvec'", "have \"x \\<noteq> y\" and \"x \\<sharp> yvec'\""], ["proof (prove)\nusing this:\n  xvec \\<sharp>* yvec\n  xvec = x # xvec'\n  yvec = y # yvec'\n\ngoal (1 subgoal):\n 1. x \\<noteq> y &&& x \\<sharp> yvec'", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> y\n  x \\<sharp> yvec'\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M P.\n       \\<lbrakk>\\<And>xvec yvec M P.\n                   \\<lbrakk>length xvec = length yvec; xvec \\<sharp>* yvec;\n                    distinct yvec; yvec \\<sharp>* M; yvec \\<sharp>* P;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>N Q.\n  inputChain xvec M P = inputChain yvec N Q;\n        length xvec = length yvec; xvec \\<sharp>* yvec; distinct yvec;\n        yvec \\<sharp>* M; yvec \\<sharp>* P; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>N Q.\n                            inputChain xvec M P = inputChain yvec N Q", "moreover"], ["proof (state)\nthis:\n  x \\<noteq> y\n  x \\<sharp> yvec'\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M P.\n       \\<lbrakk>\\<And>xvec yvec M P.\n                   \\<lbrakk>length xvec = length yvec; xvec \\<sharp>* yvec;\n                    distinct yvec; yvec \\<sharp>* M; yvec \\<sharp>* P;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>N Q.\n  inputChain xvec M P = inputChain yvec N Q;\n        length xvec = length yvec; xvec \\<sharp>* yvec; distinct yvec;\n        yvec \\<sharp>* M; yvec \\<sharp>* P; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>N Q.\n                            inputChain xvec M P = inputChain yvec N Q", "from \\<open>yvec \\<sharp>* M\\<close> \\<open>yvec \\<sharp>* P\\<close> \\<open>yvec = y#yvec'\\<close>"], ["proof (chain)\npicking this:\n  yvec \\<sharp>* M\n  yvec \\<sharp>* P\n  yvec = y # yvec'", "have \"y \\<sharp> M\" and \"y \\<sharp> P\""], ["proof (prove)\nusing this:\n  yvec \\<sharp>* M\n  yvec \\<sharp>* P\n  yvec = y # yvec'\n\ngoal (1 subgoal):\n 1. y \\<sharp> M &&& y \\<sharp> P", "by auto"], ["proof (state)\nthis:\n  y \\<sharp> M\n  y \\<sharp> P\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M P.\n       \\<lbrakk>\\<And>xvec yvec M P.\n                   \\<lbrakk>length xvec = length yvec; xvec \\<sharp>* yvec;\n                    distinct yvec; yvec \\<sharp>* M; yvec \\<sharp>* P;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>N Q.\n  inputChain xvec M P = inputChain yvec N Q;\n        length xvec = length yvec; xvec \\<sharp>* yvec; distinct yvec;\n        yvec \\<sharp>* M; yvec \\<sharp>* P; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>N Q.\n                            inputChain xvec M P = inputChain yvec N Q", "hence \"y \\<sharp> inputChain xvec' M P\""], ["proof (prove)\nusing this:\n  y \\<sharp> M\n  y \\<sharp> P\n\ngoal (1 subgoal):\n 1. y \\<sharp> inputChain xvec' M P", "by(simp add: inputChainFresh)"], ["proof (state)\nthis:\n  y \\<sharp> inputChain xvec' M P\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M P.\n       \\<lbrakk>\\<And>xvec yvec M P.\n                   \\<lbrakk>length xvec = length yvec; xvec \\<sharp>* yvec;\n                    distinct yvec; yvec \\<sharp>* M; yvec \\<sharp>* P;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>N Q.\n  inputChain xvec M P = inputChain yvec N Q;\n        length xvec = length yvec; xvec \\<sharp>* yvec; distinct yvec;\n        yvec \\<sharp>* M; yvec \\<sharp>* P; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>N Q.\n                            inputChain xvec M P = inputChain yvec N Q", "with Eq"], ["proof (chain)\npicking this:\n  inputChain xvec' M P = inputChain yvec' N Q\n  y \\<sharp> inputChain xvec' M P", "have \"y \\<sharp> inputChain yvec' N Q\""], ["proof (prove)\nusing this:\n  inputChain xvec' M P = inputChain yvec' N Q\n  y \\<sharp> inputChain xvec' M P\n\ngoal (1 subgoal):\n 1. y \\<sharp> inputChain yvec' N Q", "by(simp add: inputChainFresh)"], ["proof (state)\nthis:\n  y \\<sharp> inputChain yvec' N Q\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M P.\n       \\<lbrakk>\\<And>xvec yvec M P.\n                   \\<lbrakk>length xvec = length yvec; xvec \\<sharp>* yvec;\n                    distinct yvec; yvec \\<sharp>* M; yvec \\<sharp>* P;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>N Q.\n  inputChain xvec M P = inputChain yvec N Q;\n        length xvec = length yvec; xvec \\<sharp>* yvec; distinct yvec;\n        yvec \\<sharp>* M; yvec \\<sharp>* P; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>N Q.\n                            inputChain xvec M P = inputChain yvec N Q", "ultimately"], ["proof (chain)\npicking this:\n  inputChain xvec' M P = inputChain yvec' N Q\n  y \\<sharp> yvec'\n  x \\<noteq> y\n  x \\<sharp> yvec'\n  y \\<sharp> inputChain yvec' N Q", "have \"\\<nu> x (inputChain xvec' M P) = \\<nu> y (inputChain yvec' ([(x, y)] \\<bullet> N) ([(x, y)] \\<bullet> Q))\""], ["proof (prove)\nusing this:\n  inputChain xvec' M P = inputChain yvec' N Q\n  y \\<sharp> yvec'\n  x \\<noteq> y\n  x \\<sharp> yvec'\n  y \\<sharp> inputChain yvec' N Q\n\ngoal (1 subgoal):\n 1. \\<nu>xinputChain xvec' M P =\n    \\<nu>yinputChain yvec' ([(x, y)] \\<bullet> N) ([(x, y)] \\<bullet> Q)", "by(simp add: input.inject alpha' eqvts name_swap)"], ["proof (state)\nthis:\n  \\<nu>xinputChain xvec' M P =\n  \\<nu>yinputChain yvec' ([(x, y)] \\<bullet> N) ([(x, y)] \\<bullet> Q)\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M P.\n       \\<lbrakk>\\<And>xvec yvec M P.\n                   \\<lbrakk>length xvec = length yvec; xvec \\<sharp>* yvec;\n                    distinct yvec; yvec \\<sharp>* M; yvec \\<sharp>* P;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>N Q.\n  inputChain xvec M P = inputChain yvec N Q;\n        length xvec = length yvec; xvec \\<sharp>* yvec; distinct yvec;\n        yvec \\<sharp>* M; yvec \\<sharp>* P; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>N Q.\n                            inputChain xvec M P = inputChain yvec N Q", "thus ?case"], ["proof (prove)\nusing this:\n  \\<nu>xinputChain xvec' M P =\n  \\<nu>yinputChain yvec' ([(x, y)] \\<bullet> N) ([(x, y)] \\<bullet> Q)\n\ngoal (1 subgoal):\n 1. \\<exists>N Q. inputChain xvec M P = inputChain yvec N Q", "using \\<open>xvec = x#xvec'\\<close> \\<open>yvec=y#yvec'\\<close>"], ["proof (prove)\nusing this:\n  \\<nu>xinputChain xvec' M P =\n  \\<nu>yinputChain yvec' ([(x, y)] \\<bullet> N) ([(x, y)] \\<bullet> Q)\n  xvec = x # xvec'\n  yvec = y # yvec'\n\ngoal (1 subgoal):\n 1. \\<exists>N Q. inputChain xvec M P = inputChain yvec N Q", "by force"], ["proof (state)\nthis:\n  \\<exists>N Q. inputChain xvec M P = inputChain yvec N Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>N Q. inputChain xvec M P = inputChain yvec N Q\n\ngoal (1 subgoal):\n 1. (\\<And>N Q.\n        inputChain xvec M P = inputChain yvec N Q \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  inputChain xvec M P = inputChain yvec ?N ?Q \\<Longrightarrow> thesis\n  \\<exists>N Q. inputChain xvec M P = inputChain yvec N Q", "show ?thesis"], ["proof (prove)\nusing this:\n  inputChain xvec M P = inputChain yvec ?N ?Q \\<Longrightarrow> thesis\n  \\<exists>N Q. inputChain xvec M P = inputChain yvec N Q\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inputChainEq:\n  fixes xvec :: \"name list\"\n  and   M    :: \"'a::fs_name\"\n  and   P    :: \"('a, 'b::fs_name, 'c::fs_name) psi\"\n  and   yvec :: \"name list\"\n  and   N    :: 'a\n  and   Q    :: \"('a, 'b, 'c) psi\"\n\n  assumes \"inputChain xvec M P = inputChain yvec N Q\"\n  and     \"xvec \\<sharp>* yvec\"\n  and     \"distinct xvec\"\n  and     \"distinct yvec\"\n\n  obtains p where \"(set p) \\<subseteq> (set xvec) \\<times> set (p \\<bullet> xvec)\" and \"distinctPerm p\" and \"yvec = p \\<bullet> xvec\" and \"N = p \\<bullet> M\" and \"Q = p \\<bullet> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec);\n         distinctPerm p; yvec = p \\<bullet> xvec; N = p \\<bullet> M;\n         Q = p \\<bullet> P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec);\n         distinctPerm p; yvec = p \\<bullet> xvec; N = p \\<bullet> M;\n         Q = p \\<bullet> P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "assume \"\\<And>p. \\<lbrakk>set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec); distinctPerm p; yvec = p \\<bullet> xvec; N = p \\<bullet> M; Q = p \\<bullet> P\\<rbrakk> \\<Longrightarrow> thesis\""], ["proof (state)\nthis:\n  \\<lbrakk>set ?p \\<subseteq> set xvec \\<times> set (?p \\<bullet> xvec);\n   distinctPerm ?p; yvec = ?p \\<bullet> xvec; N = ?p \\<bullet> M;\n   Q = ?p \\<bullet> P\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec);\n         distinctPerm p; yvec = p \\<bullet> xvec; N = p \\<bullet> M;\n         Q = p \\<bullet> P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>set ?p \\<subseteq> set xvec \\<times> set (?p \\<bullet> xvec);\n   distinctPerm ?p; yvec = ?p \\<bullet> xvec; N = ?p \\<bullet> M;\n   Q = ?p \\<bullet> P\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec);\n         distinctPerm p; yvec = p \\<bullet> xvec; N = p \\<bullet> M;\n         Q = p \\<bullet> P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain n where \"n = length xvec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n. n = length xvec \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n = length xvec\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec);\n         distinctPerm p; yvec = p \\<bullet> xvec; N = p \\<bullet> M;\n         Q = p \\<bullet> P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with assms"], ["proof (chain)\npicking this:\n  inputChain xvec M P = inputChain yvec N Q\n  xvec \\<sharp>* yvec\n  distinct xvec\n  distinct yvec\n  n = length xvec", "have \"\\<exists>p. (set p) \\<subseteq> (set xvec) \\<times> set (yvec) \\<and> distinctPerm p \\<and>  yvec = p \\<bullet> xvec \\<and> N = p \\<bullet> M \\<and> Q = p \\<bullet> P\""], ["proof (prove)\nusing this:\n  inputChain xvec M P = inputChain yvec N Q\n  xvec \\<sharp>* yvec\n  distinct xvec\n  distinct yvec\n  n = length xvec\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and>\n       yvec = p \\<bullet> xvec \\<and>\n       N = p \\<bullet> M \\<and> Q = p \\<bullet> P", "proof(induct n arbitrary: xvec yvec M N P Q)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xvec yvec M N P Q.\n       \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        0 = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            N = p \\<bullet> M \\<and> Q = p \\<bullet> P\n 2. \\<And>n xvec yvec M N P Q.\n       \\<lbrakk>\\<And>xvec yvec M N P Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> N = p \\<bullet> M \\<and> Q = p \\<bullet> P;\n        inputChain xvec M P = inputChain yvec N Q; xvec \\<sharp>* yvec;\n        distinct xvec; distinct yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            N = p \\<bullet> M \\<and> Q = p \\<bullet> P", "case(0 xvec yvec M N P Q)"], ["proof (state)\nthis:\n  inputChain xvec M P = inputChain yvec N Q\n  xvec \\<sharp>* yvec\n  distinct xvec\n  distinct yvec\n  0 = length xvec\n\ngoal (2 subgoals):\n 1. \\<And>xvec yvec M N P Q.\n       \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        0 = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            N = p \\<bullet> M \\<and> Q = p \\<bullet> P\n 2. \\<And>n xvec yvec M N P Q.\n       \\<lbrakk>\\<And>xvec yvec M N P Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> N = p \\<bullet> M \\<and> Q = p \\<bullet> P;\n        inputChain xvec M P = inputChain yvec N Q; xvec \\<sharp>* yvec;\n        distinct xvec; distinct yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            N = p \\<bullet> M \\<and> Q = p \\<bullet> P", "have Eq: \"inputChain xvec M P = inputChain yvec N Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inputChain xvec M P = inputChain yvec N Q", "by fact"], ["proof (state)\nthis:\n  inputChain xvec M P = inputChain yvec N Q\n\ngoal (2 subgoals):\n 1. \\<And>xvec yvec M N P Q.\n       \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        0 = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            N = p \\<bullet> M \\<and> Q = p \\<bullet> P\n 2. \\<And>n xvec yvec M N P Q.\n       \\<lbrakk>\\<And>xvec yvec M N P Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> N = p \\<bullet> M \\<and> Q = p \\<bullet> P;\n        inputChain xvec M P = inputChain yvec N Q; xvec \\<sharp>* yvec;\n        distinct xvec; distinct yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            N = p \\<bullet> M \\<and> Q = p \\<bullet> P", "from \\<open>0 = length xvec\\<close>"], ["proof (chain)\npicking this:\n  0 = length xvec", "have \"xvec = []\""], ["proof (prove)\nusing this:\n  0 = length xvec\n\ngoal (1 subgoal):\n 1. xvec = []", "by auto"], ["proof (state)\nthis:\n  xvec = []\n\ngoal (2 subgoals):\n 1. \\<And>xvec yvec M N P Q.\n       \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        0 = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            N = p \\<bullet> M \\<and> Q = p \\<bullet> P\n 2. \\<And>n xvec yvec M N P Q.\n       \\<lbrakk>\\<And>xvec yvec M N P Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> N = p \\<bullet> M \\<and> Q = p \\<bullet> P;\n        inputChain xvec M P = inputChain yvec N Q; xvec \\<sharp>* yvec;\n        distinct xvec; distinct yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            N = p \\<bullet> M \\<and> Q = p \\<bullet> P", "moreover"], ["proof (state)\nthis:\n  xvec = []\n\ngoal (2 subgoals):\n 1. \\<And>xvec yvec M N P Q.\n       \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        0 = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            N = p \\<bullet> M \\<and> Q = p \\<bullet> P\n 2. \\<And>n xvec yvec M N P Q.\n       \\<lbrakk>\\<And>xvec yvec M N P Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> N = p \\<bullet> M \\<and> Q = p \\<bullet> P;\n        inputChain xvec M P = inputChain yvec N Q; xvec \\<sharp>* yvec;\n        distinct xvec; distinct yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            N = p \\<bullet> M \\<and> Q = p \\<bullet> P", "with Eq"], ["proof (chain)\npicking this:\n  inputChain xvec M P = inputChain yvec N Q\n  xvec = []", "have \"yvec = []\""], ["proof (prove)\nusing this:\n  inputChain xvec M P = inputChain yvec N Q\n  xvec = []\n\ngoal (1 subgoal):\n 1. yvec = []", "by(case_tac yvec) auto"], ["proof (state)\nthis:\n  yvec = []\n\ngoal (2 subgoals):\n 1. \\<And>xvec yvec M N P Q.\n       \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        0 = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            N = p \\<bullet> M \\<and> Q = p \\<bullet> P\n 2. \\<And>n xvec yvec M N P Q.\n       \\<lbrakk>\\<And>xvec yvec M N P Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> N = p \\<bullet> M \\<and> Q = p \\<bullet> P;\n        inputChain xvec M P = inputChain yvec N Q; xvec \\<sharp>* yvec;\n        distinct xvec; distinct yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            N = p \\<bullet> M \\<and> Q = p \\<bullet> P", "ultimately"], ["proof (chain)\npicking this:\n  xvec = []\n  yvec = []", "show ?case"], ["proof (prove)\nusing this:\n  xvec = []\n  yvec = []\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and>\n       yvec = p \\<bullet> xvec \\<and>\n       N = p \\<bullet> M \\<and> Q = p \\<bullet> P", "using Eq"], ["proof (prove)\nusing this:\n  xvec = []\n  yvec = []\n  inputChain xvec M P = inputChain yvec N Q\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and>\n       yvec = p \\<bullet> xvec \\<and>\n       N = p \\<bullet> M \\<and> Q = p \\<bullet> P", "by(simp add: input.inject)"], ["proof (state)\nthis:\n  \\<exists>p.\n     set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n     distinctPerm p \\<and>\n     yvec = p \\<bullet> xvec \\<and>\n     N = p \\<bullet> M \\<and> Q = p \\<bullet> P\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M N P Q.\n       \\<lbrakk>\\<And>xvec yvec M N P Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> N = p \\<bullet> M \\<and> Q = p \\<bullet> P;\n        inputChain xvec M P = inputChain yvec N Q; xvec \\<sharp>* yvec;\n        distinct xvec; distinct yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            N = p \\<bullet> M \\<and> Q = p \\<bullet> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M N P Q.\n       \\<lbrakk>\\<And>xvec yvec M N P Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> N = p \\<bullet> M \\<and> Q = p \\<bullet> P;\n        inputChain xvec M P = inputChain yvec N Q; xvec \\<sharp>* yvec;\n        distinct xvec; distinct yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            N = p \\<bullet> M \\<and> Q = p \\<bullet> P", "case(Suc n xvec yvec M N P Q)"], ["proof (state)\nthis:\n  \\<lbrakk>inputChain ?xvec ?M ?P = inputChain ?yvec ?N ?Q;\n   ?xvec \\<sharp>* ?yvec; distinct ?xvec; distinct ?yvec;\n   n = length ?xvec\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       set p \\<subseteq> set ?xvec \\<times> set ?yvec \\<and>\n                       distinctPerm p \\<and>\n                       ?yvec = p \\<bullet> ?xvec \\<and>\n                       ?N = p \\<bullet> ?M \\<and> ?Q = p \\<bullet> ?P\n  inputChain xvec M P = inputChain yvec N Q\n  xvec \\<sharp>* yvec\n  distinct xvec\n  distinct yvec\n  Suc n = length xvec\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M N P Q.\n       \\<lbrakk>\\<And>xvec yvec M N P Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> N = p \\<bullet> M \\<and> Q = p \\<bullet> P;\n        inputChain xvec M P = inputChain yvec N Q; xvec \\<sharp>* yvec;\n        distinct xvec; distinct yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            N = p \\<bullet> M \\<and> Q = p \\<bullet> P", "from \\<open>Suc n = length xvec\\<close>"], ["proof (chain)\npicking this:\n  Suc n = length xvec", "obtain x xvec' where \"xvec = x#xvec'\" and \"length xvec' = n\""], ["proof (prove)\nusing this:\n  Suc n = length xvec\n\ngoal (1 subgoal):\n 1. (\\<And>x xvec'.\n        \\<lbrakk>xvec = x # xvec'; length xvec' = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(case_tac xvec) auto"], ["proof (state)\nthis:\n  xvec = x # xvec'\n  length xvec' = n\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M N P Q.\n       \\<lbrakk>\\<And>xvec yvec M N P Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> N = p \\<bullet> M \\<and> Q = p \\<bullet> P;\n        inputChain xvec M P = inputChain yvec N Q; xvec \\<sharp>* yvec;\n        distinct xvec; distinct yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            N = p \\<bullet> M \\<and> Q = p \\<bullet> P", "from \\<open>inputChain xvec M P = inputChain yvec N Q\\<close> \\<open>xvec = x # xvec'\\<close>"], ["proof (chain)\npicking this:\n  inputChain xvec M P = inputChain yvec N Q\n  xvec = x # xvec'", "obtain y yvec' where \"inputChain (x#xvec') M P = inputChain (y#yvec') N Q\"\n      and \"yvec = y#yvec'\""], ["proof (prove)\nusing this:\n  inputChain xvec M P = inputChain yvec N Q\n  xvec = x # xvec'\n\ngoal (1 subgoal):\n 1. (\\<And>y yvec'.\n        \\<lbrakk>inputChain (x # xvec') M P = inputChain (y # yvec') N Q;\n         yvec = y # yvec'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(case_tac yvec) auto"], ["proof (state)\nthis:\n  inputChain (x # xvec') M P = inputChain (y # yvec') N Q\n  yvec = y # yvec'\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M N P Q.\n       \\<lbrakk>\\<And>xvec yvec M N P Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> N = p \\<bullet> M \\<and> Q = p \\<bullet> P;\n        inputChain xvec M P = inputChain yvec N Q; xvec \\<sharp>* yvec;\n        distinct xvec; distinct yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            N = p \\<bullet> M \\<and> Q = p \\<bullet> P", "hence EQ: \"\\<nu> x (inputChain xvec' M P) = \\<nu> y (inputChain yvec' N Q)\""], ["proof (prove)\nusing this:\n  inputChain (x # xvec') M P = inputChain (y # yvec') N Q\n  yvec = y # yvec'\n\ngoal (1 subgoal):\n 1. \\<nu>xinputChain xvec' M P = \\<nu>yinputChain yvec' N Q", "by simp"], ["proof (state)\nthis:\n  \\<nu>xinputChain xvec' M P = \\<nu>yinputChain yvec' N Q\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M N P Q.\n       \\<lbrakk>\\<And>xvec yvec M N P Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> N = p \\<bullet> M \\<and> Q = p \\<bullet> P;\n        inputChain xvec M P = inputChain yvec N Q; xvec \\<sharp>* yvec;\n        distinct xvec; distinct yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            N = p \\<bullet> M \\<and> Q = p \\<bullet> P", "from \\<open>xvec = x#xvec'\\<close> \\<open>yvec=y#yvec'\\<close> \\<open>xvec \\<sharp>* yvec\\<close>"], ["proof (chain)\npicking this:\n  xvec = x # xvec'\n  yvec = y # yvec'\n  xvec \\<sharp>* yvec", "have \"x \\<noteq> y\" and \"xvec' \\<sharp>* yvec'\" and \"x \\<sharp> yvec'\" and \"y \\<sharp> xvec'\""], ["proof (prove)\nusing this:\n  xvec = x # xvec'\n  yvec = y # yvec'\n  xvec \\<sharp>* yvec\n\ngoal (1 subgoal):\n 1. (x \\<noteq> y &&& xvec' \\<sharp>* yvec') &&&\n    x \\<sharp> yvec' &&& y \\<sharp> xvec'", "by(auto simp add: fresh_list_cons)"], ["proof (state)\nthis:\n  x \\<noteq> y\n  xvec' \\<sharp>* yvec'\n  x \\<sharp> yvec'\n  y \\<sharp> xvec'\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M N P Q.\n       \\<lbrakk>\\<And>xvec yvec M N P Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> N = p \\<bullet> M \\<and> Q = p \\<bullet> P;\n        inputChain xvec M P = inputChain yvec N Q; xvec \\<sharp>* yvec;\n        distinct xvec; distinct yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            N = p \\<bullet> M \\<and> Q = p \\<bullet> P", "from \\<open>distinct xvec\\<close> \\<open>distinct yvec\\<close> \\<open>xvec=x#xvec'\\<close> \\<open>yvec=y#yvec'\\<close>"], ["proof (chain)\npicking this:\n  distinct xvec\n  distinct yvec\n  xvec = x # xvec'\n  yvec = y # yvec'", "have \"x \\<sharp> xvec'\" and \"y \\<sharp> yvec'\" and \"distinct xvec'\" and \"distinct yvec'\""], ["proof (prove)\nusing this:\n  distinct xvec\n  distinct yvec\n  xvec = x # xvec'\n  yvec = y # yvec'\n\ngoal (1 subgoal):\n 1. (x \\<sharp> xvec' &&& y \\<sharp> yvec') &&&\n    distinct xvec' &&& distinct yvec'", "by simp+"], ["proof (state)\nthis:\n  x \\<sharp> xvec'\n  y \\<sharp> yvec'\n  distinct xvec'\n  distinct yvec'\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M N P Q.\n       \\<lbrakk>\\<And>xvec yvec M N P Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> N = p \\<bullet> M \\<and> Q = p \\<bullet> P;\n        inputChain xvec M P = inputChain yvec N Q; xvec \\<sharp>* yvec;\n        distinct xvec; distinct yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            N = p \\<bullet> M \\<and> Q = p \\<bullet> P", "have IH: \"\\<And>xvec yvec M N P Q. \\<lbrakk>inputChain xvec (M::'a) (P::('a, 'b, 'c) psi) = inputChain yvec (N::'a) (Q::('a, 'b, 'c) psi); xvec \\<sharp>* yvec; distinct xvec; distinct yvec; n = length xvec\\<rbrakk> \\<Longrightarrow> \\<exists>p. (set p) \\<subseteq> (set xvec) \\<times> (set yvec) \\<and> distinctPerm p \\<and>  yvec = p \\<bullet> xvec \\<and> N = p \\<bullet> M \\<and> Q = p \\<bullet> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xvec yvec M N P Q.\n       \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            N = p \\<bullet> M \\<and> Q = p \\<bullet> P", "by fact"], ["proof (state)\nthis:\n  \\<lbrakk>inputChain ?xvec ?M ?P = inputChain ?yvec ?N ?Q;\n   ?xvec \\<sharp>* ?yvec; distinct ?xvec; distinct ?yvec;\n   n = length ?xvec\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       set p \\<subseteq> set ?xvec \\<times> set ?yvec \\<and>\n                       distinctPerm p \\<and>\n                       ?yvec = p \\<bullet> ?xvec \\<and>\n                       ?N = p \\<bullet> ?M \\<and> ?Q = p \\<bullet> ?P\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M N P Q.\n       \\<lbrakk>\\<And>xvec yvec M N P Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> N = p \\<bullet> M \\<and> Q = p \\<bullet> P;\n        inputChain xvec M P = inputChain yvec N Q; xvec \\<sharp>* yvec;\n        distinct xvec; distinct yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            N = p \\<bullet> M \\<and> Q = p \\<bullet> P", "from EQ \\<open>x \\<noteq> y\\<close>  \\<open>x \\<sharp> yvec'\\<close> \\<open>y \\<sharp> yvec'\\<close>"], ["proof (chain)\npicking this:\n  \\<nu>xinputChain xvec' M P = \\<nu>yinputChain yvec' N Q\n  x \\<noteq> y\n  x \\<sharp> yvec'\n  y \\<sharp> yvec'", "have \"inputChain xvec' M P = inputChain yvec' ([(x, y)] \\<bullet> N) ([(x, y)] \\<bullet> Q)\""], ["proof (prove)\nusing this:\n  \\<nu>xinputChain xvec' M P = \\<nu>yinputChain yvec' N Q\n  x \\<noteq> y\n  x \\<sharp> yvec'\n  y \\<sharp> yvec'\n\ngoal (1 subgoal):\n 1. inputChain xvec' M P =\n    inputChain yvec' ([(x, y)] \\<bullet> N) ([(x, y)] \\<bullet> Q)", "by(simp add: input.inject alpha eqvts)"], ["proof (state)\nthis:\n  inputChain xvec' M P =\n  inputChain yvec' ([(x, y)] \\<bullet> N) ([(x, y)] \\<bullet> Q)\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M N P Q.\n       \\<lbrakk>\\<And>xvec yvec M N P Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> N = p \\<bullet> M \\<and> Q = p \\<bullet> P;\n        inputChain xvec M P = inputChain yvec N Q; xvec \\<sharp>* yvec;\n        distinct xvec; distinct yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            N = p \\<bullet> M \\<and> Q = p \\<bullet> P", "with \\<open>xvec' \\<sharp>* yvec'\\<close> \\<open>distinct xvec'\\<close> \\<open>distinct yvec'\\<close> \\<open>length xvec' = n\\<close> IH"], ["proof (chain)\npicking this:\n  xvec' \\<sharp>* yvec'\n  distinct xvec'\n  distinct yvec'\n  length xvec' = n\n  \\<lbrakk>inputChain ?xvec ?M ?P = inputChain ?yvec ?N ?Q;\n   ?xvec \\<sharp>* ?yvec; distinct ?xvec; distinct ?yvec;\n   n = length ?xvec\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       set p \\<subseteq> set ?xvec \\<times> set ?yvec \\<and>\n                       distinctPerm p \\<and>\n                       ?yvec = p \\<bullet> ?xvec \\<and>\n                       ?N = p \\<bullet> ?M \\<and> ?Q = p \\<bullet> ?P\n  inputChain xvec' M P =\n  inputChain yvec' ([(x, y)] \\<bullet> N) ([(x, y)] \\<bullet> Q)", "obtain p where S: \"(set p) \\<subseteq> (set xvec') \\<times> (set yvec')\" and \"distinctPerm p\" and \"yvec' = p \\<bullet> xvec'\" and \"([(x, y)] \\<bullet> N) = p \\<bullet> M\" and \"([(x, y)] \\<bullet> Q) = p \\<bullet> P\""], ["proof (prove)\nusing this:\n  xvec' \\<sharp>* yvec'\n  distinct xvec'\n  distinct yvec'\n  length xvec' = n\n  \\<lbrakk>inputChain ?xvec ?M ?P = inputChain ?yvec ?N ?Q;\n   ?xvec \\<sharp>* ?yvec; distinct ?xvec; distinct ?yvec;\n   n = length ?xvec\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       set p \\<subseteq> set ?xvec \\<times> set ?yvec \\<and>\n                       distinctPerm p \\<and>\n                       ?yvec = p \\<bullet> ?xvec \\<and>\n                       ?N = p \\<bullet> ?M \\<and> ?Q = p \\<bullet> ?P\n  inputChain xvec' M P =\n  inputChain yvec' ([(x, y)] \\<bullet> N) ([(x, y)] \\<bullet> Q)\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>set p \\<subseteq> set xvec' \\<times> set yvec';\n         distinctPerm p; yvec' = p \\<bullet> xvec';\n         [(x, y)] \\<bullet> N = p \\<bullet> M;\n         [(x, y)] \\<bullet> Q = p \\<bullet> P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  set p \\<subseteq> set xvec' \\<times> set yvec'\n  distinctPerm p\n  yvec' = p \\<bullet> xvec'\n  [(x, y)] \\<bullet> N = p \\<bullet> M\n  [(x, y)] \\<bullet> Q = p \\<bullet> P\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M N P Q.\n       \\<lbrakk>\\<And>xvec yvec M N P Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> N = p \\<bullet> M \\<and> Q = p \\<bullet> P;\n        inputChain xvec M P = inputChain yvec N Q; xvec \\<sharp>* yvec;\n        distinct xvec; distinct yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            N = p \\<bullet> M \\<and> Q = p \\<bullet> P", "from S"], ["proof (chain)\npicking this:\n  set p \\<subseteq> set xvec' \\<times> set yvec'", "have \"set((x, y)#p) \\<subseteq> set(x#xvec') \\<times> set(y#yvec')\""], ["proof (prove)\nusing this:\n  set p \\<subseteq> set xvec' \\<times> set yvec'\n\ngoal (1 subgoal):\n 1. set ((x, y) # p) \\<subseteq> set (x # xvec') \\<times> set (y # yvec')", "by auto"], ["proof (state)\nthis:\n  set ((x, y) # p) \\<subseteq> set (x # xvec') \\<times> set (y # yvec')\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M N P Q.\n       \\<lbrakk>\\<And>xvec yvec M N P Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> N = p \\<bullet> M \\<and> Q = p \\<bullet> P;\n        inputChain xvec M P = inputChain yvec N Q; xvec \\<sharp>* yvec;\n        distinct xvec; distinct yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            N = p \\<bullet> M \\<and> Q = p \\<bullet> P", "moreover"], ["proof (state)\nthis:\n  set ((x, y) # p) \\<subseteq> set (x # xvec') \\<times> set (y # yvec')\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M N P Q.\n       \\<lbrakk>\\<And>xvec yvec M N P Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> N = p \\<bullet> M \\<and> Q = p \\<bullet> P;\n        inputChain xvec M P = inputChain yvec N Q; xvec \\<sharp>* yvec;\n        distinct xvec; distinct yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            N = p \\<bullet> M \\<and> Q = p \\<bullet> P", "from \\<open>x \\<sharp> xvec'\\<close> \\<open>x \\<sharp> yvec'\\<close> \\<open>y \\<sharp> xvec'\\<close> \\<open>y \\<sharp> yvec'\\<close> S"], ["proof (chain)\npicking this:\n  x \\<sharp> xvec'\n  x \\<sharp> yvec'\n  y \\<sharp> xvec'\n  y \\<sharp> yvec'\n  set p \\<subseteq> set xvec' \\<times> set yvec'", "have \"x \\<sharp> p\" and \"y \\<sharp> p\""], ["proof (prove)\nusing this:\n  x \\<sharp> xvec'\n  x \\<sharp> yvec'\n  y \\<sharp> xvec'\n  y \\<sharp> yvec'\n  set p \\<subseteq> set xvec' \\<times> set yvec'\n\ngoal (1 subgoal):\n 1. x \\<sharp> p &&& y \\<sharp> p", "apply(induct p)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>x \\<sharp> xvec'; x \\<sharp> yvec'; y \\<sharp> xvec';\n     y \\<sharp> yvec';\n     set [] \\<subseteq> set xvec' \\<times> set yvec'\\<rbrakk>\n    \\<Longrightarrow> x \\<sharp> []\n 2. \\<lbrakk>x \\<sharp> xvec'; x \\<sharp> yvec'; y \\<sharp> xvec';\n     y \\<sharp> yvec';\n     set [] \\<subseteq> set xvec' \\<times> set yvec'\\<rbrakk>\n    \\<Longrightarrow> y \\<sharp> []\n 3. \\<And>a p.\n       \\<lbrakk>\\<lbrakk>x \\<sharp> xvec'; x \\<sharp> yvec';\n                 y \\<sharp> xvec'; y \\<sharp> yvec';\n                 set p \\<subseteq> set xvec' \\<times> set yvec'\\<rbrakk>\n                \\<Longrightarrow> x \\<sharp> p;\n        \\<lbrakk>x \\<sharp> xvec'; x \\<sharp> yvec'; y \\<sharp> xvec';\n         y \\<sharp> yvec';\n         set p \\<subseteq> set xvec' \\<times> set yvec'\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> p;\n        x \\<sharp> xvec'; x \\<sharp> yvec'; y \\<sharp> xvec';\n        y \\<sharp> yvec';\n        set (a # p) \\<subseteq> set xvec' \\<times> set yvec'\\<rbrakk>\n       \\<Longrightarrow> x \\<sharp> (a # p)\n 4. \\<And>a p.\n       \\<lbrakk>\\<lbrakk>x \\<sharp> xvec'; x \\<sharp> yvec';\n                 y \\<sharp> xvec'; y \\<sharp> yvec';\n                 set p \\<subseteq> set xvec' \\<times> set yvec'\\<rbrakk>\n                \\<Longrightarrow> x \\<sharp> p;\n        \\<lbrakk>x \\<sharp> xvec'; x \\<sharp> yvec'; y \\<sharp> xvec';\n         y \\<sharp> yvec';\n         set p \\<subseteq> set xvec' \\<times> set yvec'\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> p;\n        x \\<sharp> xvec'; x \\<sharp> yvec'; y \\<sharp> xvec';\n        y \\<sharp> yvec';\n        set (a # p) \\<subseteq> set xvec' \\<times> set yvec'\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (a # p)", "by(auto simp add: fresh_list_nil fresh_list_cons fresh_prod name_list_supp) (auto simp add: fresh_def)"], ["proof (state)\nthis:\n  x \\<sharp> p\n  y \\<sharp> p\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M N P Q.\n       \\<lbrakk>\\<And>xvec yvec M N P Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> N = p \\<bullet> M \\<and> Q = p \\<bullet> P;\n        inputChain xvec M P = inputChain yvec N Q; xvec \\<sharp>* yvec;\n        distinct xvec; distinct yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            N = p \\<bullet> M \\<and> Q = p \\<bullet> P", "with S \\<open>distinctPerm p\\<close> \\<open>x \\<noteq> y\\<close>"], ["proof (chain)\npicking this:\n  set p \\<subseteq> set xvec' \\<times> set yvec'\n  distinctPerm p\n  x \\<noteq> y\n  x \\<sharp> p\n  y \\<sharp> p", "have \"distinctPerm((x, y)#p)\""], ["proof (prove)\nusing this:\n  set p \\<subseteq> set xvec' \\<times> set yvec'\n  distinctPerm p\n  x \\<noteq> y\n  x \\<sharp> p\n  y \\<sharp> p\n\ngoal (1 subgoal):\n 1. distinctPerm ((x, y) # p)", "by auto"], ["proof (state)\nthis:\n  distinctPerm ((x, y) # p)\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M N P Q.\n       \\<lbrakk>\\<And>xvec yvec M N P Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> N = p \\<bullet> M \\<and> Q = p \\<bullet> P;\n        inputChain xvec M P = inputChain yvec N Q; xvec \\<sharp>* yvec;\n        distinct xvec; distinct yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            N = p \\<bullet> M \\<and> Q = p \\<bullet> P", "moreover"], ["proof (state)\nthis:\n  distinctPerm ((x, y) # p)\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M N P Q.\n       \\<lbrakk>\\<And>xvec yvec M N P Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> N = p \\<bullet> M \\<and> Q = p \\<bullet> P;\n        inputChain xvec M P = inputChain yvec N Q; xvec \\<sharp>* yvec;\n        distinct xvec; distinct yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            N = p \\<bullet> M \\<and> Q = p \\<bullet> P", "from \\<open>yvec' = p \\<bullet> xvec'\\<close> \\<open>x \\<sharp> p\\<close> \\<open>y \\<sharp> p\\<close> \\<open>x \\<sharp> xvec'\\<close> \\<open>y \\<sharp> xvec'\\<close>"], ["proof (chain)\npicking this:\n  yvec' = p \\<bullet> xvec'\n  x \\<sharp> p\n  y \\<sharp> p\n  x \\<sharp> xvec'\n  y \\<sharp> xvec'", "have \"(y#yvec') = ((x, y)#p) \\<bullet> (x#xvec')\""], ["proof (prove)\nusing this:\n  yvec' = p \\<bullet> xvec'\n  x \\<sharp> p\n  y \\<sharp> p\n  x \\<sharp> xvec'\n  y \\<sharp> xvec'\n\ngoal (1 subgoal):\n 1. y # yvec' = ((x, y) # p) \\<bullet> (x # xvec')", "by(simp add: calc_atm freshChainSimps)"], ["proof (state)\nthis:\n  y # yvec' = ((x, y) # p) \\<bullet> (x # xvec')\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M N P Q.\n       \\<lbrakk>\\<And>xvec yvec M N P Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> N = p \\<bullet> M \\<and> Q = p \\<bullet> P;\n        inputChain xvec M P = inputChain yvec N Q; xvec \\<sharp>* yvec;\n        distinct xvec; distinct yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            N = p \\<bullet> M \\<and> Q = p \\<bullet> P", "moreover"], ["proof (state)\nthis:\n  y # yvec' = ((x, y) # p) \\<bullet> (x # xvec')\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M N P Q.\n       \\<lbrakk>\\<And>xvec yvec M N P Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> N = p \\<bullet> M \\<and> Q = p \\<bullet> P;\n        inputChain xvec M P = inputChain yvec N Q; xvec \\<sharp>* yvec;\n        distinct xvec; distinct yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            N = p \\<bullet> M \\<and> Q = p \\<bullet> P", "from \\<open>([(x, y)] \\<bullet> N) = p \\<bullet> M\\<close>"], ["proof (chain)\npicking this:\n  [(x, y)] \\<bullet> N = p \\<bullet> M", "have \"([(x, y)] \\<bullet> [(x, y)] \\<bullet> N) = [(x, y)] \\<bullet> p \\<bullet> M\""], ["proof (prove)\nusing this:\n  [(x, y)] \\<bullet> N = p \\<bullet> M\n\ngoal (1 subgoal):\n 1. [(x, y)] \\<bullet> [(x, y)] \\<bullet> N =\n    [(x, y)] \\<bullet> p \\<bullet> M", "by(simp add: pt_bij)"], ["proof (state)\nthis:\n  [(x, y)] \\<bullet> [(x, y)] \\<bullet> N = [(x, y)] \\<bullet> p \\<bullet> M\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M N P Q.\n       \\<lbrakk>\\<And>xvec yvec M N P Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> N = p \\<bullet> M \\<and> Q = p \\<bullet> P;\n        inputChain xvec M P = inputChain yvec N Q; xvec \\<sharp>* yvec;\n        distinct xvec; distinct yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            N = p \\<bullet> M \\<and> Q = p \\<bullet> P", "hence \"N = ((x, y)#p) \\<bullet> M\""], ["proof (prove)\nusing this:\n  [(x, y)] \\<bullet> [(x, y)] \\<bullet> N = [(x, y)] \\<bullet> p \\<bullet> M\n\ngoal (1 subgoal):\n 1. N = ((x, y) # p) \\<bullet> M", "by simp"], ["proof (state)\nthis:\n  N = ((x, y) # p) \\<bullet> M\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M N P Q.\n       \\<lbrakk>\\<And>xvec yvec M N P Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> N = p \\<bullet> M \\<and> Q = p \\<bullet> P;\n        inputChain xvec M P = inputChain yvec N Q; xvec \\<sharp>* yvec;\n        distinct xvec; distinct yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            N = p \\<bullet> M \\<and> Q = p \\<bullet> P", "moreover"], ["proof (state)\nthis:\n  N = ((x, y) # p) \\<bullet> M\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M N P Q.\n       \\<lbrakk>\\<And>xvec yvec M N P Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> N = p \\<bullet> M \\<and> Q = p \\<bullet> P;\n        inputChain xvec M P = inputChain yvec N Q; xvec \\<sharp>* yvec;\n        distinct xvec; distinct yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            N = p \\<bullet> M \\<and> Q = p \\<bullet> P", "from \\<open>([(x, y)] \\<bullet> Q) = p \\<bullet> P\\<close>"], ["proof (chain)\npicking this:\n  [(x, y)] \\<bullet> Q = p \\<bullet> P", "have \"([(x, y)] \\<bullet> [(x, y)] \\<bullet> Q) = [(x, y)] \\<bullet> p \\<bullet> P\""], ["proof (prove)\nusing this:\n  [(x, y)] \\<bullet> Q = p \\<bullet> P\n\ngoal (1 subgoal):\n 1. [(x, y)] \\<bullet> [(x, y)] \\<bullet> Q =\n    [(x, y)] \\<bullet> p \\<bullet> P", "by(simp add: pt_bij)"], ["proof (state)\nthis:\n  [(x, y)] \\<bullet> [(x, y)] \\<bullet> Q = [(x, y)] \\<bullet> p \\<bullet> P\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M N P Q.\n       \\<lbrakk>\\<And>xvec yvec M N P Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> N = p \\<bullet> M \\<and> Q = p \\<bullet> P;\n        inputChain xvec M P = inputChain yvec N Q; xvec \\<sharp>* yvec;\n        distinct xvec; distinct yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            N = p \\<bullet> M \\<and> Q = p \\<bullet> P", "hence \"Q = ((x, y)#p) \\<bullet> P\""], ["proof (prove)\nusing this:\n  [(x, y)] \\<bullet> [(x, y)] \\<bullet> Q = [(x, y)] \\<bullet> p \\<bullet> P\n\ngoal (1 subgoal):\n 1. Q = ((x, y) # p) \\<bullet> P", "by simp"], ["proof (state)\nthis:\n  Q = ((x, y) # p) \\<bullet> P\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M N P Q.\n       \\<lbrakk>\\<And>xvec yvec M N P Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> N = p \\<bullet> M \\<and> Q = p \\<bullet> P;\n        inputChain xvec M P = inputChain yvec N Q; xvec \\<sharp>* yvec;\n        distinct xvec; distinct yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            N = p \\<bullet> M \\<and> Q = p \\<bullet> P", "ultimately"], ["proof (chain)\npicking this:\n  set ((x, y) # p) \\<subseteq> set (x # xvec') \\<times> set (y # yvec')\n  distinctPerm ((x, y) # p)\n  y # yvec' = ((x, y) # p) \\<bullet> (x # xvec')\n  N = ((x, y) # p) \\<bullet> M\n  Q = ((x, y) # p) \\<bullet> P", "show ?case"], ["proof (prove)\nusing this:\n  set ((x, y) # p) \\<subseteq> set (x # xvec') \\<times> set (y # yvec')\n  distinctPerm ((x, y) # p)\n  y # yvec' = ((x, y) # p) \\<bullet> (x # xvec')\n  N = ((x, y) # p) \\<bullet> M\n  Q = ((x, y) # p) \\<bullet> P\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and>\n       yvec = p \\<bullet> xvec \\<and>\n       N = p \\<bullet> M \\<and> Q = p \\<bullet> P", "using \\<open>xvec=x#xvec'\\<close> \\<open>yvec=y#yvec'\\<close>"], ["proof (prove)\nusing this:\n  set ((x, y) # p) \\<subseteq> set (x # xvec') \\<times> set (y # yvec')\n  distinctPerm ((x, y) # p)\n  y # yvec' = ((x, y) # p) \\<bullet> (x # xvec')\n  N = ((x, y) # p) \\<bullet> M\n  Q = ((x, y) # p) \\<bullet> P\n  xvec = x # xvec'\n  yvec = y # yvec'\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and>\n       yvec = p \\<bullet> xvec \\<and>\n       N = p \\<bullet> M \\<and> Q = p \\<bullet> P", "by blast"], ["proof (state)\nthis:\n  \\<exists>p.\n     set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n     distinctPerm p \\<and>\n     yvec = p \\<bullet> xvec \\<and>\n     N = p \\<bullet> M \\<and> Q = p \\<bullet> P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>p.\n     set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n     distinctPerm p \\<and>\n     yvec = p \\<bullet> xvec \\<and>\n     N = p \\<bullet> M \\<and> Q = p \\<bullet> P\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec);\n         distinctPerm p; yvec = p \\<bullet> xvec; N = p \\<bullet> M;\n         Q = p \\<bullet> P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>set ?p \\<subseteq> set xvec \\<times> set (?p \\<bullet> xvec);\n   distinctPerm ?p; yvec = ?p \\<bullet> xvec; N = ?p \\<bullet> M;\n   Q = ?p \\<bullet> P\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<exists>p.\n     set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n     distinctPerm p \\<and>\n     yvec = p \\<bullet> xvec \\<and>\n     N = p \\<bullet> M \\<and> Q = p \\<bullet> P", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>set ?p \\<subseteq> set xvec \\<times> set (?p \\<bullet> xvec);\n   distinctPerm ?p; yvec = ?p \\<bullet> xvec; N = ?p \\<bullet> M;\n   Q = ?p \\<bullet> P\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<exists>p.\n     set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n     distinctPerm p \\<and>\n     yvec = p \\<bullet> xvec \\<and>\n     N = p \\<bullet> M \\<and> Q = p \\<bullet> P\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inputChainEqLength:\n  fixes xvec :: \"name list\"\n  and   M    :: \"'a::fs_name\"\n  and   P    :: \"('a, 'b::fs_name, 'c::fs_name) psi\"\n  and   yvec :: \"name list\"\n  and   N    :: 'a\n  and   Q    :: \"('a, 'b, 'c) psi\"\n\n  assumes \"inputChain xvec M P = inputChain yvec N Q\"\n\n  shows \"length xvec = length yvec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xvec = length yvec", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length xvec = length yvec", "obtain n where \"n = length xvec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n. n = length xvec \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n = length xvec\n\ngoal (1 subgoal):\n 1. length xvec = length yvec", "with assms"], ["proof (chain)\npicking this:\n  inputChain xvec M P = inputChain yvec N Q\n  n = length xvec", "show ?thesis"], ["proof (prove)\nusing this:\n  inputChain xvec M P = inputChain yvec N Q\n  n = length xvec\n\ngoal (1 subgoal):\n 1. length xvec = length yvec", "proof(induct n arbitrary: xvec yvec M P N Q)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xvec yvec M P N Q.\n       \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n        0 = length xvec\\<rbrakk>\n       \\<Longrightarrow> length xvec = length yvec\n 2. \\<And>n xvec yvec M P N Q.\n       \\<lbrakk>\\<And>xvec yvec M P N Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> length xvec = length yvec;\n        inputChain xvec M P = inputChain yvec N Q;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> length xvec = length yvec", "case(0 xvec yvec M P N Q)"], ["proof (state)\nthis:\n  inputChain xvec M P = inputChain yvec N Q\n  0 = length xvec\n\ngoal (2 subgoals):\n 1. \\<And>xvec yvec M P N Q.\n       \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n        0 = length xvec\\<rbrakk>\n       \\<Longrightarrow> length xvec = length yvec\n 2. \\<And>n xvec yvec M P N Q.\n       \\<lbrakk>\\<And>xvec yvec M P N Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> length xvec = length yvec;\n        inputChain xvec M P = inputChain yvec N Q;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> length xvec = length yvec", "from \\<open>0 = length xvec\\<close>"], ["proof (chain)\npicking this:\n  0 = length xvec", "have \"xvec = []\""], ["proof (prove)\nusing this:\n  0 = length xvec\n\ngoal (1 subgoal):\n 1. xvec = []", "by auto"], ["proof (state)\nthis:\n  xvec = []\n\ngoal (2 subgoals):\n 1. \\<And>xvec yvec M P N Q.\n       \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n        0 = length xvec\\<rbrakk>\n       \\<Longrightarrow> length xvec = length yvec\n 2. \\<And>n xvec yvec M P N Q.\n       \\<lbrakk>\\<And>xvec yvec M P N Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> length xvec = length yvec;\n        inputChain xvec M P = inputChain yvec N Q;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> length xvec = length yvec", "moreover"], ["proof (state)\nthis:\n  xvec = []\n\ngoal (2 subgoals):\n 1. \\<And>xvec yvec M P N Q.\n       \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n        0 = length xvec\\<rbrakk>\n       \\<Longrightarrow> length xvec = length yvec\n 2. \\<And>n xvec yvec M P N Q.\n       \\<lbrakk>\\<And>xvec yvec M P N Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> length xvec = length yvec;\n        inputChain xvec M P = inputChain yvec N Q;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> length xvec = length yvec", "with \\<open>inputChain xvec M P = inputChain yvec N Q\\<close>"], ["proof (chain)\npicking this:\n  inputChain xvec M P = inputChain yvec N Q\n  xvec = []", "have \"yvec = []\""], ["proof (prove)\nusing this:\n  inputChain xvec M P = inputChain yvec N Q\n  xvec = []\n\ngoal (1 subgoal):\n 1. yvec = []", "by(case_tac yvec) auto"], ["proof (state)\nthis:\n  yvec = []\n\ngoal (2 subgoals):\n 1. \\<And>xvec yvec M P N Q.\n       \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n        0 = length xvec\\<rbrakk>\n       \\<Longrightarrow> length xvec = length yvec\n 2. \\<And>n xvec yvec M P N Q.\n       \\<lbrakk>\\<And>xvec yvec M P N Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> length xvec = length yvec;\n        inputChain xvec M P = inputChain yvec N Q;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> length xvec = length yvec", "ultimately"], ["proof (chain)\npicking this:\n  xvec = []\n  yvec = []", "show ?case"], ["proof (prove)\nusing this:\n  xvec = []\n  yvec = []\n\ngoal (1 subgoal):\n 1. length xvec = length yvec", "by simp"], ["proof (state)\nthis:\n  length xvec = length yvec\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M P N Q.\n       \\<lbrakk>\\<And>xvec yvec M P N Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> length xvec = length yvec;\n        inputChain xvec M P = inputChain yvec N Q;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> length xvec = length yvec", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M P N Q.\n       \\<lbrakk>\\<And>xvec yvec M P N Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> length xvec = length yvec;\n        inputChain xvec M P = inputChain yvec N Q;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> length xvec = length yvec", "case(Suc n xvec yvec M P N Q)"], ["proof (state)\nthis:\n  \\<lbrakk>inputChain ?xvec ?M ?P = inputChain ?yvec ?N ?Q;\n   n = length ?xvec\\<rbrakk>\n  \\<Longrightarrow> length ?xvec = length ?yvec\n  inputChain xvec M P = inputChain yvec N Q\n  Suc n = length xvec\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M P N Q.\n       \\<lbrakk>\\<And>xvec yvec M P N Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> length xvec = length yvec;\n        inputChain xvec M P = inputChain yvec N Q;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> length xvec = length yvec", "from \\<open>Suc n = length xvec\\<close>"], ["proof (chain)\npicking this:\n  Suc n = length xvec", "obtain x xvec' where \"xvec = x#xvec'\" and \"length xvec' = n\""], ["proof (prove)\nusing this:\n  Suc n = length xvec\n\ngoal (1 subgoal):\n 1. (\\<And>x xvec'.\n        \\<lbrakk>xvec = x # xvec'; length xvec' = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(case_tac xvec) auto"], ["proof (state)\nthis:\n  xvec = x # xvec'\n  length xvec' = n\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M P N Q.\n       \\<lbrakk>\\<And>xvec yvec M P N Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> length xvec = length yvec;\n        inputChain xvec M P = inputChain yvec N Q;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> length xvec = length yvec", "from \\<open>inputChain xvec M P = inputChain yvec N Q\\<close> \\<open>xvec = x # xvec'\\<close>"], ["proof (chain)\npicking this:\n  inputChain xvec M P = inputChain yvec N Q\n  xvec = x # xvec'", "obtain y yvec' where \"inputChain (x#xvec') M P = inputChain (y#yvec') N Q\"\n      and \"yvec = y#yvec'\""], ["proof (prove)\nusing this:\n  inputChain xvec M P = inputChain yvec N Q\n  xvec = x # xvec'\n\ngoal (1 subgoal):\n 1. (\\<And>y yvec'.\n        \\<lbrakk>inputChain (x # xvec') M P = inputChain (y # yvec') N Q;\n         yvec = y # yvec'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(case_tac yvec) auto"], ["proof (state)\nthis:\n  inputChain (x # xvec') M P = inputChain (y # yvec') N Q\n  yvec = y # yvec'\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M P N Q.\n       \\<lbrakk>\\<And>xvec yvec M P N Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> length xvec = length yvec;\n        inputChain xvec M P = inputChain yvec N Q;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> length xvec = length yvec", "hence EQ: \"\\<nu> x (inputChain xvec' M P) = \\<nu> y (inputChain yvec' N Q)\""], ["proof (prove)\nusing this:\n  inputChain (x # xvec') M P = inputChain (y # yvec') N Q\n  yvec = y # yvec'\n\ngoal (1 subgoal):\n 1. \\<nu>xinputChain xvec' M P = \\<nu>yinputChain yvec' N Q", "by simp"], ["proof (state)\nthis:\n  \\<nu>xinputChain xvec' M P = \\<nu>yinputChain yvec' N Q\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M P N Q.\n       \\<lbrakk>\\<And>xvec yvec M P N Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> length xvec = length yvec;\n        inputChain xvec M P = inputChain yvec N Q;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> length xvec = length yvec", "have IH: \"\\<And>xvec yvec M P N Q. \\<lbrakk>inputChain xvec (M::'a) (P::('a, 'b, 'c) psi) = inputChain yvec N Q; n = length xvec\\<rbrakk> \\<Longrightarrow> length xvec = length yvec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xvec yvec M P N Q.\n       \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n        n = length xvec\\<rbrakk>\n       \\<Longrightarrow> length xvec = length yvec", "by fact"], ["proof (state)\nthis:\n  \\<lbrakk>inputChain ?xvec ?M ?P = inputChain ?yvec ?N ?Q;\n   n = length ?xvec\\<rbrakk>\n  \\<Longrightarrow> length ?xvec = length ?yvec\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec M P N Q.\n       \\<lbrakk>\\<And>xvec yvec M P N Q.\n                   \\<lbrakk>inputChain xvec M P = inputChain yvec N Q;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> length xvec = length yvec;\n        inputChain xvec M P = inputChain yvec N Q;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> length xvec = length yvec", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. length xvec = length yvec", "proof(case_tac \"x = y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> length xvec = length yvec\n 2. x \\<noteq> y \\<Longrightarrow> length xvec = length yvec", "assume \"x = y\""], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> length xvec = length yvec\n 2. x \\<noteq> y \\<Longrightarrow> length xvec = length yvec", "with EQ"], ["proof (chain)\npicking this:\n  \\<nu>xinputChain xvec' M P = \\<nu>yinputChain yvec' N Q\n  x = y", "have \"inputChain xvec' M P = inputChain yvec' N Q\""], ["proof (prove)\nusing this:\n  \\<nu>xinputChain xvec' M P = \\<nu>yinputChain yvec' N Q\n  x = y\n\ngoal (1 subgoal):\n 1. inputChain xvec' M P = inputChain yvec' N Q", "by(simp add: alpha input.inject)"], ["proof (state)\nthis:\n  inputChain xvec' M P = inputChain yvec' N Q\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> length xvec = length yvec\n 2. x \\<noteq> y \\<Longrightarrow> length xvec = length yvec", "with IH \\<open>length xvec' = n\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>inputChain ?xvec ?M ?P = inputChain ?yvec ?N ?Q;\n   n = length ?xvec\\<rbrakk>\n  \\<Longrightarrow> length ?xvec = length ?yvec\n  length xvec' = n\n  inputChain xvec' M P = inputChain yvec' N Q", "have \"length xvec' = length yvec'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>inputChain ?xvec ?M ?P = inputChain ?yvec ?N ?Q;\n   n = length ?xvec\\<rbrakk>\n  \\<Longrightarrow> length ?xvec = length ?yvec\n  length xvec' = n\n  inputChain xvec' M P = inputChain yvec' N Q\n\ngoal (1 subgoal):\n 1. length xvec' = length yvec'", "by blast"], ["proof (state)\nthis:\n  length xvec' = length yvec'\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> length xvec = length yvec\n 2. x \\<noteq> y \\<Longrightarrow> length xvec = length yvec", "with \\<open>xvec = x#xvec'\\<close> \\<open>yvec=y#yvec'\\<close>"], ["proof (chain)\npicking this:\n  xvec = x # xvec'\n  yvec = y # yvec'\n  length xvec' = length yvec'", "show ?case"], ["proof (prove)\nusing this:\n  xvec = x # xvec'\n  yvec = y # yvec'\n  length xvec' = length yvec'\n\ngoal (1 subgoal):\n 1. length xvec = length yvec", "by simp"], ["proof (state)\nthis:\n  length xvec = length yvec\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> length xvec = length yvec", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> length xvec = length yvec", "assume \"x \\<noteq> y\""], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> length xvec = length yvec", "with EQ"], ["proof (chain)\npicking this:\n  \\<nu>xinputChain xvec' M P = \\<nu>yinputChain yvec' N Q\n  x \\<noteq> y", "have \"inputChain xvec' M P = inputChain ([(x, y)] \\<bullet> yvec') ([(x, y)] \\<bullet> N) ([(x, y)] \\<bullet> Q)\""], ["proof (prove)\nusing this:\n  \\<nu>xinputChain xvec' M P = \\<nu>yinputChain yvec' N Q\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. inputChain xvec' M P =\n    inputChain ([(x, y)] \\<bullet> yvec') ([(x, y)] \\<bullet> N)\n     ([(x, y)] \\<bullet> Q)", "by(simp add: alpha input.inject eqvts)"], ["proof (state)\nthis:\n  inputChain xvec' M P =\n  inputChain ([(x, y)] \\<bullet> yvec') ([(x, y)] \\<bullet> N)\n   ([(x, y)] \\<bullet> Q)\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> length xvec = length yvec", "with IH \\<open>length xvec' = n\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>inputChain ?xvec ?M ?P = inputChain ?yvec ?N ?Q;\n   n = length ?xvec\\<rbrakk>\n  \\<Longrightarrow> length ?xvec = length ?yvec\n  length xvec' = n\n  inputChain xvec' M P =\n  inputChain ([(x, y)] \\<bullet> yvec') ([(x, y)] \\<bullet> N)\n   ([(x, y)] \\<bullet> Q)", "have \"length xvec' = length ([(x, y)] \\<bullet> yvec')\""], ["proof (prove)\nusing this:\n  \\<lbrakk>inputChain ?xvec ?M ?P = inputChain ?yvec ?N ?Q;\n   n = length ?xvec\\<rbrakk>\n  \\<Longrightarrow> length ?xvec = length ?yvec\n  length xvec' = n\n  inputChain xvec' M P =\n  inputChain ([(x, y)] \\<bullet> yvec') ([(x, y)] \\<bullet> N)\n   ([(x, y)] \\<bullet> Q)\n\ngoal (1 subgoal):\n 1. length xvec' = length ([(x, y)] \\<bullet> yvec')", "by blast"], ["proof (state)\nthis:\n  length xvec' = length ([(x, y)] \\<bullet> yvec')\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> length xvec = length yvec", "hence \"length xvec' = length yvec'\""], ["proof (prove)\nusing this:\n  length xvec' = length ([(x, y)] \\<bullet> yvec')\n\ngoal (1 subgoal):\n 1. length xvec' = length yvec'", "by simp"], ["proof (state)\nthis:\n  length xvec' = length yvec'\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> length xvec = length yvec", "with \\<open>xvec = x#xvec'\\<close> \\<open>yvec=y#yvec'\\<close>"], ["proof (chain)\npicking this:\n  xvec = x # xvec'\n  yvec = y # yvec'\n  length xvec' = length yvec'", "show ?case"], ["proof (prove)\nusing this:\n  xvec = x # xvec'\n  yvec = y # yvec'\n  length xvec' = length yvec'\n\ngoal (1 subgoal):\n 1. length xvec = length yvec", "by simp"], ["proof (state)\nthis:\n  length xvec = length yvec\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length xvec = length yvec\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length xvec = length yvec\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma alphaInputChain:\n  fixes yvec :: \"name list\"\n  and   xvec :: \"name list\"\n  and   M    :: \"'a::fs_name\"\n  and   P    :: \"('a, 'b::fs_name, 'c::fs_name) psi\"\n\n  assumes \"length xvec = length yvec\"\n  and     \"yvec \\<sharp>* M\"\n  and     \"yvec \\<sharp>* P\"\n  and     \"yvec \\<sharp>* xvec\"\n  and     \"distinct yvec\"\n\n  shows \"inputChain xvec M P = inputChain yvec ([xvec yvec] \\<bullet>\\<^sub>v M) ([xvec yvec] \\<bullet>\\<^sub>v P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inputChain xvec M P =\n    inputChain yvec ([xvec yvec] \\<bullet>\\<^sub>v M)\n     ([xvec yvec] \\<bullet>\\<^sub>v P)", "using assms"], ["proof (prove)\nusing this:\n  length xvec = length yvec\n  yvec \\<sharp>* M\n  yvec \\<sharp>* P\n  yvec \\<sharp>* xvec\n  distinct yvec\n\ngoal (1 subgoal):\n 1. inputChain xvec M P =\n    inputChain yvec ([xvec yvec] \\<bullet>\\<^sub>v M)\n     ([xvec yvec] \\<bullet>\\<^sub>v P)", "proof(induct rule: composePermInduct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<sharp>* M; [] \\<sharp>* P; [] \\<sharp>* [];\n     distinct []\\<rbrakk>\n    \\<Longrightarrow> inputChain [] M P =\n                      inputChain [] ([[] []] \\<bullet>\\<^sub>v M)\n                       ([[] []] \\<bullet>\\<^sub>v P)\n 2. \\<And>x xvec y yvec.\n       \\<lbrakk>length xvec = length yvec;\n        \\<lbrakk>yvec \\<sharp>* M; yvec \\<sharp>* P; yvec \\<sharp>* xvec;\n         distinct yvec\\<rbrakk>\n        \\<Longrightarrow> inputChain xvec M P =\n                          inputChain yvec ([xvec yvec] \\<bullet>\\<^sub>v M)\n                           ([xvec yvec] \\<bullet>\\<^sub>v P);\n        (y # yvec) \\<sharp>* M; (y # yvec) \\<sharp>* P;\n        (y # yvec) \\<sharp>* (x # xvec); distinct (y # yvec)\\<rbrakk>\n       \\<Longrightarrow> inputChain (x # xvec) M P =\n                         inputChain (y # yvec)\n                          ([(x # xvec) (y # yvec)] \\<bullet>\\<^sub>v M)\n                          ([(x # xvec) (y # yvec)] \\<bullet>\\<^sub>v P)", "case cBase"], ["proof (state)\nthis:\n  [] \\<sharp>* M\n  [] \\<sharp>* P\n  [] \\<sharp>* []\n  distinct []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<sharp>* M; [] \\<sharp>* P; [] \\<sharp>* [];\n     distinct []\\<rbrakk>\n    \\<Longrightarrow> inputChain [] M P =\n                      inputChain [] ([[] []] \\<bullet>\\<^sub>v M)\n                       ([[] []] \\<bullet>\\<^sub>v P)\n 2. \\<And>x xvec y yvec.\n       \\<lbrakk>length xvec = length yvec;\n        \\<lbrakk>yvec \\<sharp>* M; yvec \\<sharp>* P; yvec \\<sharp>* xvec;\n         distinct yvec\\<rbrakk>\n        \\<Longrightarrow> inputChain xvec M P =\n                          inputChain yvec ([xvec yvec] \\<bullet>\\<^sub>v M)\n                           ([xvec yvec] \\<bullet>\\<^sub>v P);\n        (y # yvec) \\<sharp>* M; (y # yvec) \\<sharp>* P;\n        (y # yvec) \\<sharp>* (x # xvec); distinct (y # yvec)\\<rbrakk>\n       \\<Longrightarrow> inputChain (x # xvec) M P =\n                         inputChain (y # yvec)\n                          ([(x # xvec) (y # yvec)] \\<bullet>\\<^sub>v M)\n                          ([(x # xvec) (y # yvec)] \\<bullet>\\<^sub>v P)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. inputChain [] M P =\n    inputChain [] ([[] []] \\<bullet>\\<^sub>v M)\n     ([[] []] \\<bullet>\\<^sub>v P)", "by simp"], ["proof (state)\nthis:\n  inputChain [] M P =\n  inputChain [] ([[] []] \\<bullet>\\<^sub>v M) ([[] []] \\<bullet>\\<^sub>v P)\n\ngoal (1 subgoal):\n 1. \\<And>x xvec y yvec.\n       \\<lbrakk>length xvec = length yvec;\n        \\<lbrakk>yvec \\<sharp>* M; yvec \\<sharp>* P; yvec \\<sharp>* xvec;\n         distinct yvec\\<rbrakk>\n        \\<Longrightarrow> inputChain xvec M P =\n                          inputChain yvec ([xvec yvec] \\<bullet>\\<^sub>v M)\n                           ([xvec yvec] \\<bullet>\\<^sub>v P);\n        (y # yvec) \\<sharp>* M; (y # yvec) \\<sharp>* P;\n        (y # yvec) \\<sharp>* (x # xvec); distinct (y # yvec)\\<rbrakk>\n       \\<Longrightarrow> inputChain (x # xvec) M P =\n                         inputChain (y # yvec)\n                          ([(x # xvec) (y # yvec)] \\<bullet>\\<^sub>v M)\n                          ([(x # xvec) (y # yvec)] \\<bullet>\\<^sub>v P)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xvec y yvec.\n       \\<lbrakk>length xvec = length yvec;\n        \\<lbrakk>yvec \\<sharp>* M; yvec \\<sharp>* P; yvec \\<sharp>* xvec;\n         distinct yvec\\<rbrakk>\n        \\<Longrightarrow> inputChain xvec M P =\n                          inputChain yvec ([xvec yvec] \\<bullet>\\<^sub>v M)\n                           ([xvec yvec] \\<bullet>\\<^sub>v P);\n        (y # yvec) \\<sharp>* M; (y # yvec) \\<sharp>* P;\n        (y # yvec) \\<sharp>* (x # xvec); distinct (y # yvec)\\<rbrakk>\n       \\<Longrightarrow> inputChain (x # xvec) M P =\n                         inputChain (y # yvec)\n                          ([(x # xvec) (y # yvec)] \\<bullet>\\<^sub>v M)\n                          ([(x # xvec) (y # yvec)] \\<bullet>\\<^sub>v P)", "case(cStep x xvec y yvec)"], ["proof (state)\nthis:\n  length xvec = length yvec\n  \\<lbrakk>yvec \\<sharp>* M; yvec \\<sharp>* P; yvec \\<sharp>* xvec;\n   distinct yvec\\<rbrakk>\n  \\<Longrightarrow> inputChain xvec M P =\n                    inputChain yvec ([xvec yvec] \\<bullet>\\<^sub>v M)\n                     ([xvec yvec] \\<bullet>\\<^sub>v P)\n  (y # yvec) \\<sharp>* M\n  (y # yvec) \\<sharp>* P\n  (y # yvec) \\<sharp>* (x # xvec)\n  distinct (y # yvec)\n\ngoal (1 subgoal):\n 1. \\<And>x xvec y yvec.\n       \\<lbrakk>length xvec = length yvec;\n        \\<lbrakk>yvec \\<sharp>* M; yvec \\<sharp>* P; yvec \\<sharp>* xvec;\n         distinct yvec\\<rbrakk>\n        \\<Longrightarrow> inputChain xvec M P =\n                          inputChain yvec ([xvec yvec] \\<bullet>\\<^sub>v M)\n                           ([xvec yvec] \\<bullet>\\<^sub>v P);\n        (y # yvec) \\<sharp>* M; (y # yvec) \\<sharp>* P;\n        (y # yvec) \\<sharp>* (x # xvec); distinct (y # yvec)\\<rbrakk>\n       \\<Longrightarrow> inputChain (x # xvec) M P =\n                         inputChain (y # yvec)\n                          ([(x # xvec) (y # yvec)] \\<bullet>\\<^sub>v M)\n                          ([(x # xvec) (y # yvec)] \\<bullet>\\<^sub>v P)", "thus ?case"], ["proof (prove)\nusing this:\n  length xvec = length yvec\n  \\<lbrakk>yvec \\<sharp>* M; yvec \\<sharp>* P; yvec \\<sharp>* xvec;\n   distinct yvec\\<rbrakk>\n  \\<Longrightarrow> inputChain xvec M P =\n                    inputChain yvec ([xvec yvec] \\<bullet>\\<^sub>v M)\n                     ([xvec yvec] \\<bullet>\\<^sub>v P)\n  (y # yvec) \\<sharp>* M\n  (y # yvec) \\<sharp>* P\n  (y # yvec) \\<sharp>* (x # xvec)\n  distinct (y # yvec)\n\ngoal (1 subgoal):\n 1. inputChain (x # xvec) M P =\n    inputChain (y # yvec) ([(x # xvec) (y # yvec)] \\<bullet>\\<^sub>v M)\n     ([(x # xvec) (y # yvec)] \\<bullet>\\<^sub>v P)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xvec = length yvec;\n     inputChain xvec M P =\n     inputChain yvec ([xvec yvec] \\<bullet>\\<^sub>v M)\n      ([xvec yvec] \\<bullet>\\<^sub>v P);\n     y \\<sharp> M; yvec \\<sharp>* M; y \\<sharp> P; yvec \\<sharp>* P;\n     y \\<noteq> x; y \\<sharp> yvec; distinct yvec; y \\<sharp> xvec;\n     x \\<sharp> yvec; xvec \\<sharp>* yvec\\<rbrakk>\n    \\<Longrightarrow> \\<nu>xinputChain yvec\n                             ([xvec yvec] \\<bullet>\\<^sub>v M)\n                             ([xvec yvec] \\<bullet>\\<^sub>v P) =\n                      \\<nu>yinputChain yvec\n                             ([(x, y)] \\<bullet>\n                              [xvec yvec] \\<bullet>\\<^sub>v M)\n                             ([(x, y)] \\<bullet>\n                              [xvec yvec] \\<bullet>\\<^sub>v P)", "by(subst alphaInput[of y]) (auto simp add: inputChainFresh eqvts)"], ["proof (state)\nthis:\n  inputChain (x # xvec) M P =\n  inputChain (y # yvec) ([(x # xvec) (y # yvec)] \\<bullet>\\<^sub>v M)\n   ([(x # xvec) (y # yvec)] \\<bullet>\\<^sub>v P)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inputChainInject[simp]:\n\n  shows \"(inputChain xvec M P = inputChain xvec N Q) = ((M = N) \\<and> (P = Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (inputChain xvec M P = inputChain xvec N Q) = (M = N \\<and> P = Q)", "by(induct xvec) (auto simp add: input.inject alpha)"], ["", "lemma alphaInputDistinct:\n  fixes xvec :: \"name list\"\n  and   M    :: \"'a::fs_name\"\n  and   P    :: \"('a, 'b::fs_name, 'c::fs_name) psi\"\n  and   yvec :: \"name list\"\n  and   N    :: 'a\n  and   Q    :: \"('a, 'b, 'c) psi\"\n\n  assumes Eq: \"inputChain xvec M P = inputChain yvec N Q\"\n  and     xvecDist: \"distinct xvec\"\n  and     Mem: \"\\<And>x. x \\<in> set xvec \\<Longrightarrow> x \\<in> supp M\"\n  and     xvecFreshyvec: \"xvec \\<sharp>* yvec\"\n  and     xvecFreshN: \"xvec \\<sharp>* N\"\n  and     xvecFreshQ: \"xvec \\<sharp>* Q\"\n\n  shows \"distinct yvec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct yvec", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct yvec", "from Eq"], ["proof (chain)\npicking this:\n  inputChain xvec M P = inputChain yvec N Q", "have \"length xvec = length yvec\""], ["proof (prove)\nusing this:\n  inputChain xvec M P = inputChain yvec N Q\n\ngoal (1 subgoal):\n 1. length xvec = length yvec", "by(rule inputChainEqLength)"], ["proof (state)\nthis:\n  length xvec = length yvec\n\ngoal (1 subgoal):\n 1. distinct yvec", "with assms"], ["proof (chain)\npicking this:\n  inputChain xvec M P = inputChain yvec N Q\n  distinct xvec\n  ?x mem xvec \\<Longrightarrow> ?x \\<in> supp M\n  xvec \\<sharp>* yvec\n  xvec \\<sharp>* N\n  xvec \\<sharp>* Q\n  length xvec = length yvec", "show ?thesis"], ["proof (prove)\nusing this:\n  inputChain xvec M P = inputChain yvec N Q\n  distinct xvec\n  ?x mem xvec \\<Longrightarrow> ?x \\<in> supp M\n  xvec \\<sharp>* yvec\n  xvec \\<sharp>* N\n  xvec \\<sharp>* Q\n  length xvec = length yvec\n\ngoal (1 subgoal):\n 1. distinct yvec", "proof(induct n==\"length xvec\" arbitrary: xvec yvec N Q rule: nat.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xvec yvec N Q.\n       \\<lbrakk>0 = length xvec; inputChain xvec M P = inputChain yvec N Q;\n        distinct xvec; \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n        xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n        length xvec = length yvec\\<rbrakk>\n       \\<Longrightarrow> distinct yvec\n 2. \\<And>nat xvec yvec N Q.\n       \\<lbrakk>\\<And>xvec yvec N Q.\n                   \\<lbrakk>nat = length xvec;\n                    inputChain xvec M P = inputChain yvec N Q;\n                    distinct xvec;\n                    \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n                    xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n                    length xvec = length yvec\\<rbrakk>\n                   \\<Longrightarrow> distinct yvec;\n        Suc nat = length xvec; inputChain xvec M P = inputChain yvec N Q;\n        distinct xvec; \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n        xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n        length xvec = length yvec\\<rbrakk>\n       \\<Longrightarrow> distinct yvec", "case(zero xvec yvec N Q)"], ["proof (state)\nthis:\n  0 = length xvec\n  inputChain xvec M P = inputChain yvec N Q\n  distinct xvec\n  ?x mem xvec \\<Longrightarrow> ?x \\<in> supp M\n  xvec \\<sharp>* yvec\n  xvec \\<sharp>* N\n  xvec \\<sharp>* Q\n  length xvec = length yvec\n\ngoal (2 subgoals):\n 1. \\<And>xvec yvec N Q.\n       \\<lbrakk>0 = length xvec; inputChain xvec M P = inputChain yvec N Q;\n        distinct xvec; \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n        xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n        length xvec = length yvec\\<rbrakk>\n       \\<Longrightarrow> distinct yvec\n 2. \\<And>nat xvec yvec N Q.\n       \\<lbrakk>\\<And>xvec yvec N Q.\n                   \\<lbrakk>nat = length xvec;\n                    inputChain xvec M P = inputChain yvec N Q;\n                    distinct xvec;\n                    \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n                    xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n                    length xvec = length yvec\\<rbrakk>\n                   \\<Longrightarrow> distinct yvec;\n        Suc nat = length xvec; inputChain xvec M P = inputChain yvec N Q;\n        distinct xvec; \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n        xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n        length xvec = length yvec\\<rbrakk>\n       \\<Longrightarrow> distinct yvec", "thus ?case"], ["proof (prove)\nusing this:\n  0 = length xvec\n  inputChain xvec M P = inputChain yvec N Q\n  distinct xvec\n  ?x mem xvec \\<Longrightarrow> ?x \\<in> supp M\n  xvec \\<sharp>* yvec\n  xvec \\<sharp>* N\n  xvec \\<sharp>* Q\n  length xvec = length yvec\n\ngoal (1 subgoal):\n 1. distinct yvec", "by simp"], ["proof (state)\nthis:\n  distinct yvec\n\ngoal (1 subgoal):\n 1. \\<And>nat xvec yvec N Q.\n       \\<lbrakk>\\<And>xvec yvec N Q.\n                   \\<lbrakk>nat = length xvec;\n                    inputChain xvec M P = inputChain yvec N Q;\n                    distinct xvec;\n                    \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n                    xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n                    length xvec = length yvec\\<rbrakk>\n                   \\<Longrightarrow> distinct yvec;\n        Suc nat = length xvec; inputChain xvec M P = inputChain yvec N Q;\n        distinct xvec; \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n        xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n        length xvec = length yvec\\<rbrakk>\n       \\<Longrightarrow> distinct yvec", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat xvec yvec N Q.\n       \\<lbrakk>\\<And>xvec yvec N Q.\n                   \\<lbrakk>nat = length xvec;\n                    inputChain xvec M P = inputChain yvec N Q;\n                    distinct xvec;\n                    \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n                    xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n                    length xvec = length yvec\\<rbrakk>\n                   \\<Longrightarrow> distinct yvec;\n        Suc nat = length xvec; inputChain xvec M P = inputChain yvec N Q;\n        distinct xvec; \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n        xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n        length xvec = length yvec\\<rbrakk>\n       \\<Longrightarrow> distinct yvec", "case(Suc n xvec yvec N Q)"], ["proof (state)\nthis:\n  \\<lbrakk>n = length ?xvec; inputChain ?xvec M P = inputChain ?yvec ?N ?Q;\n   distinct ?xvec; \\<And>x. x mem ?xvec \\<Longrightarrow> x \\<in> supp M;\n   ?xvec \\<sharp>* ?yvec; ?xvec \\<sharp>* ?N; ?xvec \\<sharp>* ?Q;\n   length ?xvec = length ?yvec\\<rbrakk>\n  \\<Longrightarrow> distinct ?yvec\n  Suc n = length xvec\n  inputChain xvec M P = inputChain yvec N Q\n  distinct xvec\n  ?x mem xvec \\<Longrightarrow> ?x \\<in> supp M\n  xvec \\<sharp>* yvec\n  xvec \\<sharp>* N\n  xvec \\<sharp>* Q\n  length xvec = length yvec\n\ngoal (1 subgoal):\n 1. \\<And>nat xvec yvec N Q.\n       \\<lbrakk>\\<And>xvec yvec N Q.\n                   \\<lbrakk>nat = length xvec;\n                    inputChain xvec M P = inputChain yvec N Q;\n                    distinct xvec;\n                    \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n                    xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n                    length xvec = length yvec\\<rbrakk>\n                   \\<Longrightarrow> distinct yvec;\n        Suc nat = length xvec; inputChain xvec M P = inputChain yvec N Q;\n        distinct xvec; \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n        xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n        length xvec = length yvec\\<rbrakk>\n       \\<Longrightarrow> distinct yvec", "have L: \"length xvec = length yvec\" and \"Suc n = length xvec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xvec = length yvec &&& Suc n = length xvec", "by fact+"], ["proof (state)\nthis:\n  length xvec = length yvec\n  Suc n = length xvec\n\ngoal (1 subgoal):\n 1. \\<And>nat xvec yvec N Q.\n       \\<lbrakk>\\<And>xvec yvec N Q.\n                   \\<lbrakk>nat = length xvec;\n                    inputChain xvec M P = inputChain yvec N Q;\n                    distinct xvec;\n                    \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n                    xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n                    length xvec = length yvec\\<rbrakk>\n                   \\<Longrightarrow> distinct yvec;\n        Suc nat = length xvec; inputChain xvec M P = inputChain yvec N Q;\n        distinct xvec; \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n        xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n        length xvec = length yvec\\<rbrakk>\n       \\<Longrightarrow> distinct yvec", "then"], ["proof (chain)\npicking this:\n  length xvec = length yvec\n  Suc n = length xvec", "obtain x xvec' y yvec' where xEq: \"xvec = x#xvec'\" and yEq: \"yvec = y#yvec'\"\n                                  and L': \"length xvec' = length yvec'\""], ["proof (prove)\nusing this:\n  length xvec = length yvec\n  Suc n = length xvec\n\ngoal (1 subgoal):\n 1. (\\<And>x xvec' y yvec'.\n        \\<lbrakk>xvec = x # xvec'; yvec = y # yvec';\n         length xvec' = length yvec'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases xvec, auto, cases yvec, auto)"], ["proof (state)\nthis:\n  xvec = x # xvec'\n  yvec = y # yvec'\n  length xvec' = length yvec'\n\ngoal (1 subgoal):\n 1. \\<And>nat xvec yvec N Q.\n       \\<lbrakk>\\<And>xvec yvec N Q.\n                   \\<lbrakk>nat = length xvec;\n                    inputChain xvec M P = inputChain yvec N Q;\n                    distinct xvec;\n                    \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n                    xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n                    length xvec = length yvec\\<rbrakk>\n                   \\<Longrightarrow> distinct yvec;\n        Suc nat = length xvec; inputChain xvec M P = inputChain yvec N Q;\n        distinct xvec; \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n        xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n        length xvec = length yvec\\<rbrakk>\n       \\<Longrightarrow> distinct yvec", "have xvecFreshyvec: \"xvec \\<sharp>* yvec\" and xvecDist: \"distinct xvec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xvec \\<sharp>* yvec &&& distinct xvec", "by fact+"], ["proof (state)\nthis:\n  xvec \\<sharp>* yvec\n  distinct xvec\n\ngoal (1 subgoal):\n 1. \\<And>nat xvec yvec N Q.\n       \\<lbrakk>\\<And>xvec yvec N Q.\n                   \\<lbrakk>nat = length xvec;\n                    inputChain xvec M P = inputChain yvec N Q;\n                    distinct xvec;\n                    \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n                    xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n                    length xvec = length yvec\\<rbrakk>\n                   \\<Longrightarrow> distinct yvec;\n        Suc nat = length xvec; inputChain xvec M P = inputChain yvec N Q;\n        distinct xvec; \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n        xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n        length xvec = length yvec\\<rbrakk>\n       \\<Longrightarrow> distinct yvec", "with xEq yEq"], ["proof (chain)\npicking this:\n  xvec = x # xvec'\n  yvec = y # yvec'\n  xvec \\<sharp>* yvec\n  distinct xvec", "have xineqy: \"x \\<noteq> y\" and xvec'Freshyvec': \"xvec' \\<sharp>* yvec'\"\n                  and xvec'Dist: \"distinct xvec'\" and xFreshxvec': \"x \\<sharp> xvec'\"\n                  and xFreshyvec': \"x \\<sharp> yvec'\" and yFreshxvec': \"y \\<sharp> xvec'\""], ["proof (prove)\nusing this:\n  xvec = x # xvec'\n  yvec = y # yvec'\n  xvec \\<sharp>* yvec\n  distinct xvec\n\ngoal (1 subgoal):\n 1. (x \\<noteq> y &&& xvec' \\<sharp>* yvec' &&& distinct xvec') &&&\n    x \\<sharp> xvec' &&& x \\<sharp> yvec' &&& y \\<sharp> xvec'", "by(auto simp add: fresh_list_cons)"], ["proof (state)\nthis:\n  x \\<noteq> y\n  xvec' \\<sharp>* yvec'\n  distinct xvec'\n  x \\<sharp> xvec'\n  x \\<sharp> yvec'\n  y \\<sharp> xvec'\n\ngoal (1 subgoal):\n 1. \\<And>nat xvec yvec N Q.\n       \\<lbrakk>\\<And>xvec yvec N Q.\n                   \\<lbrakk>nat = length xvec;\n                    inputChain xvec M P = inputChain yvec N Q;\n                    distinct xvec;\n                    \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n                    xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n                    length xvec = length yvec\\<rbrakk>\n                   \\<Longrightarrow> distinct yvec;\n        Suc nat = length xvec; inputChain xvec M P = inputChain yvec N Q;\n        distinct xvec; \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n        xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n        length xvec = length yvec\\<rbrakk>\n       \\<Longrightarrow> distinct yvec", "have Eq: \"inputChain xvec M P = inputChain yvec N Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inputChain xvec M P = inputChain yvec N Q", "by fact"], ["proof (state)\nthis:\n  inputChain xvec M P = inputChain yvec N Q\n\ngoal (1 subgoal):\n 1. \\<And>nat xvec yvec N Q.\n       \\<lbrakk>\\<And>xvec yvec N Q.\n                   \\<lbrakk>nat = length xvec;\n                    inputChain xvec M P = inputChain yvec N Q;\n                    distinct xvec;\n                    \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n                    xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n                    length xvec = length yvec\\<rbrakk>\n                   \\<Longrightarrow> distinct yvec;\n        Suc nat = length xvec; inputChain xvec M P = inputChain yvec N Q;\n        distinct xvec; \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n        xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n        length xvec = length yvec\\<rbrakk>\n       \\<Longrightarrow> distinct yvec", "with xEq yEq xineqy"], ["proof (chain)\npicking this:\n  xvec = x # xvec'\n  yvec = y # yvec'\n  x \\<noteq> y\n  inputChain xvec M P = inputChain yvec N Q", "have Eq': \"inputChain xvec' M P = inputChain ([(x, y)] \\<bullet> yvec') ([(x, y)] \\<bullet> N) ([(x, y)] \\<bullet> Q)\""], ["proof (prove)\nusing this:\n  xvec = x # xvec'\n  yvec = y # yvec'\n  x \\<noteq> y\n  inputChain xvec M P = inputChain yvec N Q\n\ngoal (1 subgoal):\n 1. inputChain xvec' M P =\n    inputChain ([(x, y)] \\<bullet> yvec') ([(x, y)] \\<bullet> N)\n     ([(x, y)] \\<bullet> Q)", "by(simp add: input.inject alpha eqvts)"], ["proof (state)\nthis:\n  inputChain xvec' M P =\n  inputChain ([(x, y)] \\<bullet> yvec') ([(x, y)] \\<bullet> N)\n   ([(x, y)] \\<bullet> Q)\n\ngoal (1 subgoal):\n 1. \\<And>nat xvec yvec N Q.\n       \\<lbrakk>\\<And>xvec yvec N Q.\n                   \\<lbrakk>nat = length xvec;\n                    inputChain xvec M P = inputChain yvec N Q;\n                    distinct xvec;\n                    \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n                    xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n                    length xvec = length yvec\\<rbrakk>\n                   \\<Longrightarrow> distinct yvec;\n        Suc nat = length xvec; inputChain xvec M P = inputChain yvec N Q;\n        distinct xvec; \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n        xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n        length xvec = length yvec\\<rbrakk>\n       \\<Longrightarrow> distinct yvec", "moreover"], ["proof (state)\nthis:\n  inputChain xvec' M P =\n  inputChain ([(x, y)] \\<bullet> yvec') ([(x, y)] \\<bullet> N)\n   ([(x, y)] \\<bullet> Q)\n\ngoal (1 subgoal):\n 1. \\<And>nat xvec yvec N Q.\n       \\<lbrakk>\\<And>xvec yvec N Q.\n                   \\<lbrakk>nat = length xvec;\n                    inputChain xvec M P = inputChain yvec N Q;\n                    distinct xvec;\n                    \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n                    xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n                    length xvec = length yvec\\<rbrakk>\n                   \\<Longrightarrow> distinct yvec;\n        Suc nat = length xvec; inputChain xvec M P = inputChain yvec N Q;\n        distinct xvec; \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n        xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n        length xvec = length yvec\\<rbrakk>\n       \\<Longrightarrow> distinct yvec", "have Mem:\"\\<And>x. x \\<in> set xvec \\<Longrightarrow> x \\<in> supp M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M", "by fact"], ["proof (state)\nthis:\n  ?x mem xvec \\<Longrightarrow> ?x \\<in> supp M\n\ngoal (1 subgoal):\n 1. \\<And>nat xvec yvec N Q.\n       \\<lbrakk>\\<And>xvec yvec N Q.\n                   \\<lbrakk>nat = length xvec;\n                    inputChain xvec M P = inputChain yvec N Q;\n                    distinct xvec;\n                    \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n                    xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n                    length xvec = length yvec\\<rbrakk>\n                   \\<Longrightarrow> distinct yvec;\n        Suc nat = length xvec; inputChain xvec M P = inputChain yvec N Q;\n        distinct xvec; \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n        xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n        length xvec = length yvec\\<rbrakk>\n       \\<Longrightarrow> distinct yvec", "with xEq"], ["proof (chain)\npicking this:\n  xvec = x # xvec'\n  ?x mem xvec \\<Longrightarrow> ?x \\<in> supp M", "have \"\\<And>x. x \\<in> set xvec' \\<Longrightarrow> x \\<in> supp M\""], ["proof (prove)\nusing this:\n  xvec = x # xvec'\n  ?x mem xvec \\<Longrightarrow> ?x \\<in> supp M\n\ngoal (1 subgoal):\n 1. \\<And>x. x mem xvec' \\<Longrightarrow> x \\<in> supp M", "by simp"], ["proof (state)\nthis:\n  ?x mem xvec' \\<Longrightarrow> ?x \\<in> supp M\n\ngoal (1 subgoal):\n 1. \\<And>nat xvec yvec N Q.\n       \\<lbrakk>\\<And>xvec yvec N Q.\n                   \\<lbrakk>nat = length xvec;\n                    inputChain xvec M P = inputChain yvec N Q;\n                    distinct xvec;\n                    \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n                    xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n                    length xvec = length yvec\\<rbrakk>\n                   \\<Longrightarrow> distinct yvec;\n        Suc nat = length xvec; inputChain xvec M P = inputChain yvec N Q;\n        distinct xvec; \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n        xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n        length xvec = length yvec\\<rbrakk>\n       \\<Longrightarrow> distinct yvec", "moreover"], ["proof (state)\nthis:\n  ?x mem xvec' \\<Longrightarrow> ?x \\<in> supp M\n\ngoal (1 subgoal):\n 1. \\<And>nat xvec yvec N Q.\n       \\<lbrakk>\\<And>xvec yvec N Q.\n                   \\<lbrakk>nat = length xvec;\n                    inputChain xvec M P = inputChain yvec N Q;\n                    distinct xvec;\n                    \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n                    xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n                    length xvec = length yvec\\<rbrakk>\n                   \\<Longrightarrow> distinct yvec;\n        Suc nat = length xvec; inputChain xvec M P = inputChain yvec N Q;\n        distinct xvec; \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n        xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n        length xvec = length yvec\\<rbrakk>\n       \\<Longrightarrow> distinct yvec", "have xvecFreshN: \"xvec \\<sharp>* N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xvec \\<sharp>* N", "by fact"], ["proof (state)\nthis:\n  xvec \\<sharp>* N\n\ngoal (1 subgoal):\n 1. \\<And>nat xvec yvec N Q.\n       \\<lbrakk>\\<And>xvec yvec N Q.\n                   \\<lbrakk>nat = length xvec;\n                    inputChain xvec M P = inputChain yvec N Q;\n                    distinct xvec;\n                    \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n                    xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n                    length xvec = length yvec\\<rbrakk>\n                   \\<Longrightarrow> distinct yvec;\n        Suc nat = length xvec; inputChain xvec M P = inputChain yvec N Q;\n        distinct xvec; \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n        xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n        length xvec = length yvec\\<rbrakk>\n       \\<Longrightarrow> distinct yvec", "with xEq xFreshxvec' yFreshxvec'"], ["proof (chain)\npicking this:\n  xvec = x # xvec'\n  x \\<sharp> xvec'\n  y \\<sharp> xvec'\n  xvec \\<sharp>* N", "have \"xvec' \\<sharp>* ([(x, y)] \\<bullet> N)\""], ["proof (prove)\nusing this:\n  xvec = x # xvec'\n  x \\<sharp> xvec'\n  y \\<sharp> xvec'\n  xvec \\<sharp>* N\n\ngoal (1 subgoal):\n 1. xvec' \\<sharp>* ([(x, y)] \\<bullet> N)", "by simp"], ["proof (state)\nthis:\n  xvec' \\<sharp>* ([(x, y)] \\<bullet> N)\n\ngoal (1 subgoal):\n 1. \\<And>nat xvec yvec N Q.\n       \\<lbrakk>\\<And>xvec yvec N Q.\n                   \\<lbrakk>nat = length xvec;\n                    inputChain xvec M P = inputChain yvec N Q;\n                    distinct xvec;\n                    \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n                    xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n                    length xvec = length yvec\\<rbrakk>\n                   \\<Longrightarrow> distinct yvec;\n        Suc nat = length xvec; inputChain xvec M P = inputChain yvec N Q;\n        distinct xvec; \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n        xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n        length xvec = length yvec\\<rbrakk>\n       \\<Longrightarrow> distinct yvec", "moreover"], ["proof (state)\nthis:\n  xvec' \\<sharp>* ([(x, y)] \\<bullet> N)\n\ngoal (1 subgoal):\n 1. \\<And>nat xvec yvec N Q.\n       \\<lbrakk>\\<And>xvec yvec N Q.\n                   \\<lbrakk>nat = length xvec;\n                    inputChain xvec M P = inputChain yvec N Q;\n                    distinct xvec;\n                    \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n                    xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n                    length xvec = length yvec\\<rbrakk>\n                   \\<Longrightarrow> distinct yvec;\n        Suc nat = length xvec; inputChain xvec M P = inputChain yvec N Q;\n        distinct xvec; \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n        xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n        length xvec = length yvec\\<rbrakk>\n       \\<Longrightarrow> distinct yvec", "have xvecFreshQ: \"xvec \\<sharp>* Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xvec \\<sharp>* Q", "by fact"], ["proof (state)\nthis:\n  xvec \\<sharp>* Q\n\ngoal (1 subgoal):\n 1. \\<And>nat xvec yvec N Q.\n       \\<lbrakk>\\<And>xvec yvec N Q.\n                   \\<lbrakk>nat = length xvec;\n                    inputChain xvec M P = inputChain yvec N Q;\n                    distinct xvec;\n                    \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n                    xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n                    length xvec = length yvec\\<rbrakk>\n                   \\<Longrightarrow> distinct yvec;\n        Suc nat = length xvec; inputChain xvec M P = inputChain yvec N Q;\n        distinct xvec; \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n        xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n        length xvec = length yvec\\<rbrakk>\n       \\<Longrightarrow> distinct yvec", "with xEq xFreshxvec' yFreshxvec'"], ["proof (chain)\npicking this:\n  xvec = x # xvec'\n  x \\<sharp> xvec'\n  y \\<sharp> xvec'\n  xvec \\<sharp>* Q", "have \"xvec' \\<sharp>* ([(x, y)] \\<bullet> Q)\""], ["proof (prove)\nusing this:\n  xvec = x # xvec'\n  x \\<sharp> xvec'\n  y \\<sharp> xvec'\n  xvec \\<sharp>* Q\n\ngoal (1 subgoal):\n 1. xvec' \\<sharp>* ([(x, y)] \\<bullet> Q)", "by simp"], ["proof (state)\nthis:\n  xvec' \\<sharp>* ([(x, y)] \\<bullet> Q)\n\ngoal (1 subgoal):\n 1. \\<And>nat xvec yvec N Q.\n       \\<lbrakk>\\<And>xvec yvec N Q.\n                   \\<lbrakk>nat = length xvec;\n                    inputChain xvec M P = inputChain yvec N Q;\n                    distinct xvec;\n                    \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n                    xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n                    length xvec = length yvec\\<rbrakk>\n                   \\<Longrightarrow> distinct yvec;\n        Suc nat = length xvec; inputChain xvec M P = inputChain yvec N Q;\n        distinct xvec; \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n        xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n        length xvec = length yvec\\<rbrakk>\n       \\<Longrightarrow> distinct yvec", "moreover"], ["proof (state)\nthis:\n  xvec' \\<sharp>* ([(x, y)] \\<bullet> Q)\n\ngoal (1 subgoal):\n 1. \\<And>nat xvec yvec N Q.\n       \\<lbrakk>\\<And>xvec yvec N Q.\n                   \\<lbrakk>nat = length xvec;\n                    inputChain xvec M P = inputChain yvec N Q;\n                    distinct xvec;\n                    \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n                    xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n                    length xvec = length yvec\\<rbrakk>\n                   \\<Longrightarrow> distinct yvec;\n        Suc nat = length xvec; inputChain xvec M P = inputChain yvec N Q;\n        distinct xvec; \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n        xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n        length xvec = length yvec\\<rbrakk>\n       \\<Longrightarrow> distinct yvec", "have \"Suc n = length xvec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc n = length xvec", "by fact"], ["proof (state)\nthis:\n  Suc n = length xvec\n\ngoal (1 subgoal):\n 1. \\<And>nat xvec yvec N Q.\n       \\<lbrakk>\\<And>xvec yvec N Q.\n                   \\<lbrakk>nat = length xvec;\n                    inputChain xvec M P = inputChain yvec N Q;\n                    distinct xvec;\n                    \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n                    xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n                    length xvec = length yvec\\<rbrakk>\n                   \\<Longrightarrow> distinct yvec;\n        Suc nat = length xvec; inputChain xvec M P = inputChain yvec N Q;\n        distinct xvec; \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n        xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n        length xvec = length yvec\\<rbrakk>\n       \\<Longrightarrow> distinct yvec", "with xEq"], ["proof (chain)\npicking this:\n  xvec = x # xvec'\n  Suc n = length xvec", "have \"n = length xvec'\""], ["proof (prove)\nusing this:\n  xvec = x # xvec'\n  Suc n = length xvec\n\ngoal (1 subgoal):\n 1. n = length xvec'", "by simp"], ["proof (state)\nthis:\n  n = length xvec'\n\ngoal (1 subgoal):\n 1. \\<And>nat xvec yvec N Q.\n       \\<lbrakk>\\<And>xvec yvec N Q.\n                   \\<lbrakk>nat = length xvec;\n                    inputChain xvec M P = inputChain yvec N Q;\n                    distinct xvec;\n                    \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n                    xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n                    length xvec = length yvec\\<rbrakk>\n                   \\<Longrightarrow> distinct yvec;\n        Suc nat = length xvec; inputChain xvec M P = inputChain yvec N Q;\n        distinct xvec; \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n        xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n        length xvec = length yvec\\<rbrakk>\n       \\<Longrightarrow> distinct yvec", "moreover"], ["proof (state)\nthis:\n  n = length xvec'\n\ngoal (1 subgoal):\n 1. \\<And>nat xvec yvec N Q.\n       \\<lbrakk>\\<And>xvec yvec N Q.\n                   \\<lbrakk>nat = length xvec;\n                    inputChain xvec M P = inputChain yvec N Q;\n                    distinct xvec;\n                    \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n                    xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n                    length xvec = length yvec\\<rbrakk>\n                   \\<Longrightarrow> distinct yvec;\n        Suc nat = length xvec; inputChain xvec M P = inputChain yvec N Q;\n        distinct xvec; \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n        xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n        length xvec = length yvec\\<rbrakk>\n       \\<Longrightarrow> distinct yvec", "from xvec'Freshyvec' xFreshxvec' yFreshxvec'"], ["proof (chain)\npicking this:\n  xvec' \\<sharp>* yvec'\n  x \\<sharp> xvec'\n  y \\<sharp> xvec'", "have \"xvec' \\<sharp>* ([(x, y)] \\<bullet> yvec')\""], ["proof (prove)\nusing this:\n  xvec' \\<sharp>* yvec'\n  x \\<sharp> xvec'\n  y \\<sharp> xvec'\n\ngoal (1 subgoal):\n 1. xvec' \\<sharp>* ([(x, y)] \\<bullet> yvec')", "by simp"], ["proof (state)\nthis:\n  xvec' \\<sharp>* ([(x, y)] \\<bullet> yvec')\n\ngoal (1 subgoal):\n 1. \\<And>nat xvec yvec N Q.\n       \\<lbrakk>\\<And>xvec yvec N Q.\n                   \\<lbrakk>nat = length xvec;\n                    inputChain xvec M P = inputChain yvec N Q;\n                    distinct xvec;\n                    \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n                    xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n                    length xvec = length yvec\\<rbrakk>\n                   \\<Longrightarrow> distinct yvec;\n        Suc nat = length xvec; inputChain xvec M P = inputChain yvec N Q;\n        distinct xvec; \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n        xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n        length xvec = length yvec\\<rbrakk>\n       \\<Longrightarrow> distinct yvec", "moreover"], ["proof (state)\nthis:\n  xvec' \\<sharp>* ([(x, y)] \\<bullet> yvec')\n\ngoal (1 subgoal):\n 1. \\<And>nat xvec yvec N Q.\n       \\<lbrakk>\\<And>xvec yvec N Q.\n                   \\<lbrakk>nat = length xvec;\n                    inputChain xvec M P = inputChain yvec N Q;\n                    distinct xvec;\n                    \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n                    xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n                    length xvec = length yvec\\<rbrakk>\n                   \\<Longrightarrow> distinct yvec;\n        Suc nat = length xvec; inputChain xvec M P = inputChain yvec N Q;\n        distinct xvec; \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n        xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n        length xvec = length yvec\\<rbrakk>\n       \\<Longrightarrow> distinct yvec", "from L'"], ["proof (chain)\npicking this:\n  length xvec' = length yvec'", "have \"length xvec' = length([(x, y)] \\<bullet> yvec')\""], ["proof (prove)\nusing this:\n  length xvec' = length yvec'\n\ngoal (1 subgoal):\n 1. length xvec' = length ([(x, y)] \\<bullet> yvec')", "by simp"], ["proof (state)\nthis:\n  length xvec' = length ([(x, y)] \\<bullet> yvec')\n\ngoal (1 subgoal):\n 1. \\<And>nat xvec yvec N Q.\n       \\<lbrakk>\\<And>xvec yvec N Q.\n                   \\<lbrakk>nat = length xvec;\n                    inputChain xvec M P = inputChain yvec N Q;\n                    distinct xvec;\n                    \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n                    xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n                    length xvec = length yvec\\<rbrakk>\n                   \\<Longrightarrow> distinct yvec;\n        Suc nat = length xvec; inputChain xvec M P = inputChain yvec N Q;\n        distinct xvec; \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n        xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n        length xvec = length yvec\\<rbrakk>\n       \\<Longrightarrow> distinct yvec", "ultimately"], ["proof (chain)\npicking this:\n  inputChain xvec' M P =\n  inputChain ([(x, y)] \\<bullet> yvec') ([(x, y)] \\<bullet> N)\n   ([(x, y)] \\<bullet> Q)\n  ?x mem xvec' \\<Longrightarrow> ?x \\<in> supp M\n  xvec' \\<sharp>* ([(x, y)] \\<bullet> N)\n  xvec' \\<sharp>* ([(x, y)] \\<bullet> Q)\n  n = length xvec'\n  xvec' \\<sharp>* ([(x, y)] \\<bullet> yvec')\n  length xvec' = length ([(x, y)] \\<bullet> yvec')", "have \"distinct([(x, y)] \\<bullet> yvec')\""], ["proof (prove)\nusing this:\n  inputChain xvec' M P =\n  inputChain ([(x, y)] \\<bullet> yvec') ([(x, y)] \\<bullet> N)\n   ([(x, y)] \\<bullet> Q)\n  ?x mem xvec' \\<Longrightarrow> ?x \\<in> supp M\n  xvec' \\<sharp>* ([(x, y)] \\<bullet> N)\n  xvec' \\<sharp>* ([(x, y)] \\<bullet> Q)\n  n = length xvec'\n  xvec' \\<sharp>* ([(x, y)] \\<bullet> yvec')\n  length xvec' = length ([(x, y)] \\<bullet> yvec')\n\ngoal (1 subgoal):\n 1. distinct ([(x, y)] \\<bullet> yvec')", "using xvec'Dist"], ["proof (prove)\nusing this:\n  inputChain xvec' M P =\n  inputChain ([(x, y)] \\<bullet> yvec') ([(x, y)] \\<bullet> N)\n   ([(x, y)] \\<bullet> Q)\n  ?x mem xvec' \\<Longrightarrow> ?x \\<in> supp M\n  xvec' \\<sharp>* ([(x, y)] \\<bullet> N)\n  xvec' \\<sharp>* ([(x, y)] \\<bullet> Q)\n  n = length xvec'\n  xvec' \\<sharp>* ([(x, y)] \\<bullet> yvec')\n  length xvec' = length ([(x, y)] \\<bullet> yvec')\n  distinct xvec'\n\ngoal (1 subgoal):\n 1. distinct ([(x, y)] \\<bullet> yvec')", "by(rule_tac Suc)"], ["proof (state)\nthis:\n  distinct ([(x, y)] \\<bullet> yvec')\n\ngoal (1 subgoal):\n 1. \\<And>nat xvec yvec N Q.\n       \\<lbrakk>\\<And>xvec yvec N Q.\n                   \\<lbrakk>nat = length xvec;\n                    inputChain xvec M P = inputChain yvec N Q;\n                    distinct xvec;\n                    \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n                    xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n                    length xvec = length yvec\\<rbrakk>\n                   \\<Longrightarrow> distinct yvec;\n        Suc nat = length xvec; inputChain xvec M P = inputChain yvec N Q;\n        distinct xvec; \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n        xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n        length xvec = length yvec\\<rbrakk>\n       \\<Longrightarrow> distinct yvec", "hence \"distinct yvec'\""], ["proof (prove)\nusing this:\n  distinct ([(x, y)] \\<bullet> yvec')\n\ngoal (1 subgoal):\n 1. distinct yvec'", "by simp"], ["proof (state)\nthis:\n  distinct yvec'\n\ngoal (1 subgoal):\n 1. \\<And>nat xvec yvec N Q.\n       \\<lbrakk>\\<And>xvec yvec N Q.\n                   \\<lbrakk>nat = length xvec;\n                    inputChain xvec M P = inputChain yvec N Q;\n                    distinct xvec;\n                    \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n                    xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n                    length xvec = length yvec\\<rbrakk>\n                   \\<Longrightarrow> distinct yvec;\n        Suc nat = length xvec; inputChain xvec M P = inputChain yvec N Q;\n        distinct xvec; \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n        xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n        length xvec = length yvec\\<rbrakk>\n       \\<Longrightarrow> distinct yvec", "from Mem xEq"], ["proof (chain)\npicking this:\n  ?x mem xvec \\<Longrightarrow> ?x \\<in> supp M\n  xvec = x # xvec'", "have xSuppM: \"x \\<in> supp M\""], ["proof (prove)\nusing this:\n  ?x mem xvec \\<Longrightarrow> ?x \\<in> supp M\n  xvec = x # xvec'\n\ngoal (1 subgoal):\n 1. x \\<in> supp M", "by simp"], ["proof (state)\nthis:\n  x \\<in> supp M\n\ngoal (1 subgoal):\n 1. \\<And>nat xvec yvec N Q.\n       \\<lbrakk>\\<And>xvec yvec N Q.\n                   \\<lbrakk>nat = length xvec;\n                    inputChain xvec M P = inputChain yvec N Q;\n                    distinct xvec;\n                    \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n                    xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n                    length xvec = length yvec\\<rbrakk>\n                   \\<Longrightarrow> distinct yvec;\n        Suc nat = length xvec; inputChain xvec M P = inputChain yvec N Q;\n        distinct xvec; \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n        xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n        length xvec = length yvec\\<rbrakk>\n       \\<Longrightarrow> distinct yvec", "from L xvecFreshyvec xvecDist xvecFreshN xvecFreshQ"], ["proof (chain)\npicking this:\n  length xvec = length yvec\n  xvec \\<sharp>* yvec\n  distinct xvec\n  xvec \\<sharp>* N\n  xvec \\<sharp>* Q", "have \"inputChain yvec N Q = inputChain xvec ([yvec xvec] \\<bullet>\\<^sub>v N) ([yvec xvec] \\<bullet>\\<^sub>v Q)\""], ["proof (prove)\nusing this:\n  length xvec = length yvec\n  xvec \\<sharp>* yvec\n  distinct xvec\n  xvec \\<sharp>* N\n  xvec \\<sharp>* Q\n\ngoal (1 subgoal):\n 1. inputChain yvec N Q =\n    inputChain xvec ([yvec xvec] \\<bullet>\\<^sub>v N)\n     ([yvec xvec] \\<bullet>\\<^sub>v Q)", "by(simp add: alphaInputChain)"], ["proof (state)\nthis:\n  inputChain yvec N Q =\n  inputChain xvec ([yvec xvec] \\<bullet>\\<^sub>v N)\n   ([yvec xvec] \\<bullet>\\<^sub>v Q)\n\ngoal (1 subgoal):\n 1. \\<And>nat xvec yvec N Q.\n       \\<lbrakk>\\<And>xvec yvec N Q.\n                   \\<lbrakk>nat = length xvec;\n                    inputChain xvec M P = inputChain yvec N Q;\n                    distinct xvec;\n                    \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n                    xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n                    length xvec = length yvec\\<rbrakk>\n                   \\<Longrightarrow> distinct yvec;\n        Suc nat = length xvec; inputChain xvec M P = inputChain yvec N Q;\n        distinct xvec; \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n        xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n        length xvec = length yvec\\<rbrakk>\n       \\<Longrightarrow> distinct yvec", "with Eq"], ["proof (chain)\npicking this:\n  inputChain xvec M P = inputChain yvec N Q\n  inputChain yvec N Q =\n  inputChain xvec ([yvec xvec] \\<bullet>\\<^sub>v N)\n   ([yvec xvec] \\<bullet>\\<^sub>v Q)", "have \"M = [yvec xvec] \\<bullet>\\<^sub>v N\""], ["proof (prove)\nusing this:\n  inputChain xvec M P = inputChain yvec N Q\n  inputChain yvec N Q =\n  inputChain xvec ([yvec xvec] \\<bullet>\\<^sub>v N)\n   ([yvec xvec] \\<bullet>\\<^sub>v Q)\n\ngoal (1 subgoal):\n 1. M = [yvec xvec] \\<bullet>\\<^sub>v N", "by auto"], ["proof (state)\nthis:\n  M = [yvec xvec] \\<bullet>\\<^sub>v N\n\ngoal (1 subgoal):\n 1. \\<And>nat xvec yvec N Q.\n       \\<lbrakk>\\<And>xvec yvec N Q.\n                   \\<lbrakk>nat = length xvec;\n                    inputChain xvec M P = inputChain yvec N Q;\n                    distinct xvec;\n                    \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n                    xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n                    length xvec = length yvec\\<rbrakk>\n                   \\<Longrightarrow> distinct yvec;\n        Suc nat = length xvec; inputChain xvec M P = inputChain yvec N Q;\n        distinct xvec; \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n        xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n        length xvec = length yvec\\<rbrakk>\n       \\<Longrightarrow> distinct yvec", "with xEq yEq"], ["proof (chain)\npicking this:\n  xvec = x # xvec'\n  yvec = y # yvec'\n  M = [yvec xvec] \\<bullet>\\<^sub>v N", "have \"M = [(y, x)] \\<bullet> [yvec' xvec'] \\<bullet>\\<^sub>v N\""], ["proof (prove)\nusing this:\n  xvec = x # xvec'\n  yvec = y # yvec'\n  M = [yvec xvec] \\<bullet>\\<^sub>v N\n\ngoal (1 subgoal):\n 1. M = [(y, x)] \\<bullet> [yvec' xvec'] \\<bullet>\\<^sub>v N", "by simp"], ["proof (state)\nthis:\n  M = [(y, x)] \\<bullet> [yvec' xvec'] \\<bullet>\\<^sub>v N\n\ngoal (1 subgoal):\n 1. \\<And>nat xvec yvec N Q.\n       \\<lbrakk>\\<And>xvec yvec N Q.\n                   \\<lbrakk>nat = length xvec;\n                    inputChain xvec M P = inputChain yvec N Q;\n                    distinct xvec;\n                    \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n                    xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n                    length xvec = length yvec\\<rbrakk>\n                   \\<Longrightarrow> distinct yvec;\n        Suc nat = length xvec; inputChain xvec M P = inputChain yvec N Q;\n        distinct xvec; \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n        xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n        length xvec = length yvec\\<rbrakk>\n       \\<Longrightarrow> distinct yvec", "with xSuppM"], ["proof (chain)\npicking this:\n  x \\<in> supp M\n  M = [(y, x)] \\<bullet> [yvec' xvec'] \\<bullet>\\<^sub>v N", "have ySuppN: \"y \\<in> supp([yvec' xvec'] \\<bullet>\\<^sub>v N)\""], ["proof (prove)\nusing this:\n  x \\<in> supp M\n  M = [(y, x)] \\<bullet> [yvec' xvec'] \\<bullet>\\<^sub>v N\n\ngoal (1 subgoal):\n 1. y \\<in> supp ([yvec' xvec'] \\<bullet>\\<^sub>v N)", "by(drule_tac pi=\"[(x, y)]\" in pt_set_bij2[OF pt_name_inst, OF at_name_inst])\n        (simp add: calc_atm eqvts name_swap)"], ["proof (state)\nthis:\n  y \\<in> supp ([yvec' xvec'] \\<bullet>\\<^sub>v N)\n\ngoal (1 subgoal):\n 1. \\<And>nat xvec yvec N Q.\n       \\<lbrakk>\\<And>xvec yvec N Q.\n                   \\<lbrakk>nat = length xvec;\n                    inputChain xvec M P = inputChain yvec N Q;\n                    distinct xvec;\n                    \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n                    xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n                    length xvec = length yvec\\<rbrakk>\n                   \\<Longrightarrow> distinct yvec;\n        Suc nat = length xvec; inputChain xvec M P = inputChain yvec N Q;\n        distinct xvec; \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n        xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n        length xvec = length yvec\\<rbrakk>\n       \\<Longrightarrow> distinct yvec", "have \"y \\<sharp> yvec'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<sharp> yvec'", "proof(simp add: fresh_def, rule notI)"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<in> supp yvec' \\<Longrightarrow> False", "assume \"y \\<in> supp yvec'\""], ["proof (state)\nthis:\n  y \\<in> supp yvec'\n\ngoal (1 subgoal):\n 1. y \\<in> supp yvec' \\<Longrightarrow> False", "hence \"y mem yvec'\""], ["proof (prove)\nusing this:\n  y \\<in> supp yvec'\n\ngoal (1 subgoal):\n 1. y mem yvec'", "by(induct yvec') (auto simp add: supp_list_nil supp_list_cons supp_atm)"], ["proof (state)\nthis:\n  y mem yvec'\n\ngoal (1 subgoal):\n 1. y \\<in> supp yvec' \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  y mem yvec'\n\ngoal (1 subgoal):\n 1. y \\<in> supp yvec' \\<Longrightarrow> False", "from xvecFreshN xEq xFreshxvec'"], ["proof (chain)\npicking this:\n  xvec \\<sharp>* N\n  xvec = x # xvec'\n  x \\<sharp> xvec'", "have \"xvec' \\<sharp>* N\""], ["proof (prove)\nusing this:\n  xvec \\<sharp>* N\n  xvec = x # xvec'\n  x \\<sharp> xvec'\n\ngoal (1 subgoal):\n 1. xvec' \\<sharp>* N", "by simp"], ["proof (state)\nthis:\n  xvec' \\<sharp>* N\n\ngoal (1 subgoal):\n 1. y \\<in> supp yvec' \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  y mem yvec'\n  xvec' \\<sharp>* N", "have \"y \\<sharp> [yvec' xvec'] \\<bullet>\\<^sub>v  N\""], ["proof (prove)\nusing this:\n  y mem yvec'\n  xvec' \\<sharp>* N\n\ngoal (1 subgoal):\n 1. y \\<sharp> [yvec' xvec'] \\<bullet>\\<^sub>v N", "using L' xvec'Freshyvec' xvec'Dist"], ["proof (prove)\nusing this:\n  y mem yvec'\n  xvec' \\<sharp>* N\n  length xvec' = length yvec'\n  xvec' \\<sharp>* yvec'\n  distinct xvec'\n\ngoal (1 subgoal):\n 1. y \\<sharp> [yvec' xvec'] \\<bullet>\\<^sub>v N", "by(force intro: freshChainPerm simp add: freshChainSym)"], ["proof (state)\nthis:\n  y \\<sharp> [yvec' xvec'] \\<bullet>\\<^sub>v N\n\ngoal (1 subgoal):\n 1. y \\<in> supp yvec' \\<Longrightarrow> False", "with ySuppN"], ["proof (chain)\npicking this:\n  y \\<in> supp ([yvec' xvec'] \\<bullet>\\<^sub>v N)\n  y \\<sharp> [yvec' xvec'] \\<bullet>\\<^sub>v N", "show \"False\""], ["proof (prove)\nusing this:\n  y \\<in> supp ([yvec' xvec'] \\<bullet>\\<^sub>v N)\n  y \\<sharp> [yvec' xvec'] \\<bullet>\\<^sub>v N\n\ngoal (1 subgoal):\n 1. False", "by(simp add: fresh_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y \\<sharp> yvec'\n\ngoal (1 subgoal):\n 1. \\<And>nat xvec yvec N Q.\n       \\<lbrakk>\\<And>xvec yvec N Q.\n                   \\<lbrakk>nat = length xvec;\n                    inputChain xvec M P = inputChain yvec N Q;\n                    distinct xvec;\n                    \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n                    xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n                    length xvec = length yvec\\<rbrakk>\n                   \\<Longrightarrow> distinct yvec;\n        Suc nat = length xvec; inputChain xvec M P = inputChain yvec N Q;\n        distinct xvec; \\<And>x. x mem xvec \\<Longrightarrow> x \\<in> supp M;\n        xvec \\<sharp>* yvec; xvec \\<sharp>* N; xvec \\<sharp>* Q;\n        length xvec = length yvec\\<rbrakk>\n       \\<Longrightarrow> distinct yvec", "with \\<open>distinct yvec'\\<close>  yEq"], ["proof (chain)\npicking this:\n  distinct yvec'\n  yvec = y # yvec'\n  y \\<sharp> yvec'", "show ?case"], ["proof (prove)\nusing this:\n  distinct yvec'\n  yvec = y # yvec'\n  y \\<sharp> yvec'\n\ngoal (1 subgoal):\n 1. distinct yvec", "by simp"], ["proof (state)\nthis:\n  distinct yvec\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct yvec\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma psiCasesInject[simp]:\n  fixes CsP  :: \"('c::fs_name \\<times> ('a::fs_name, 'b::fs_name, 'c) psi) list\"\n  and   CsQ  :: \"('c \\<times> ('a, 'b, 'c) psi) list\"\n\n  shows \"(psiCases CsP = psiCases CsQ) = (CsP = CsQ)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (psiCases CsP = psiCases CsQ) = (CsP = CsQ)", "proof(induct CsP arbitrary: CsQ)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>CsQ. (psiCases [] = psiCases CsQ) = ([] = CsQ)\n 2. \\<And>a CsP CsQ.\n       (\\<And>CsQ.\n           (psiCases CsP = psiCases CsQ) = (CsP = CsQ)) \\<Longrightarrow>\n       (psiCases (a # CsP) = psiCases CsQ) = (a # CsP = CsQ)", "case(Nil CsQ)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>CsQ. (psiCases [] = psiCases CsQ) = ([] = CsQ)\n 2. \\<And>a CsP CsQ.\n       (\\<And>CsQ.\n           (psiCases CsP = psiCases CsQ) = (CsP = CsQ)) \\<Longrightarrow>\n       (psiCases (a # CsP) = psiCases CsQ) = (a # CsP = CsQ)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (psiCases [] = psiCases CsQ) = ([] = CsQ)", "by(case_tac CsQ) (auto)"], ["proof (state)\nthis:\n  (psiCases [] = psiCases CsQ) = ([] = CsQ)\n\ngoal (1 subgoal):\n 1. \\<And>a CsP CsQ.\n       (\\<And>CsQ.\n           (psiCases CsP = psiCases CsQ) = (CsP = CsQ)) \\<Longrightarrow>\n       (psiCases (a # CsP) = psiCases CsQ) = (a # CsP = CsQ)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a CsP CsQ.\n       (\\<And>CsQ.\n           (psiCases CsP = psiCases CsQ) = (CsP = CsQ)) \\<Longrightarrow>\n       (psiCases (a # CsP) = psiCases CsQ) = (a # CsP = CsQ)", "case(Cons a CsP CsQ)"], ["proof (state)\nthis:\n  (psiCases CsP = psiCases ?CsQ) = (CsP = ?CsQ)\n\ngoal (1 subgoal):\n 1. \\<And>a CsP CsQ.\n       (\\<And>CsQ.\n           (psiCases CsP = psiCases CsQ) = (CsP = CsQ)) \\<Longrightarrow>\n       (psiCases (a # CsP) = psiCases CsQ) = (a # CsP = CsQ)", "thus ?case"], ["proof (prove)\nusing this:\n  (psiCases CsP = psiCases ?CsQ) = (CsP = ?CsQ)\n\ngoal (1 subgoal):\n 1. (psiCases (a # CsP) = psiCases CsQ) = (a # CsP = CsQ)", "by(case_tac a, case_tac CsQ) (clarsimp simp add: psiCase.inject)+"], ["proof (state)\nthis:\n  (psiCases (a # CsP) = psiCases CsQ) = (a # CsP = CsQ)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma casesInject[simp]:\n  fixes CsP :: \"('c::fs_name \\<times> ('a::fs_name, 'b::fs_name, 'c) psi) list\"\n  and   CsQ :: \"('c \\<times> ('a, 'b, 'c) psi) list\"\n\n  shows \"(Cases CsP = Cases CsQ) = (CsP = CsQ)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Cases CsP = Cases CsQ) = (CsP = CsQ)", "apply(induct CsP)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (Cases [] = Cases CsQ) = ([] = CsQ)\n 2. \\<And>a CsP.\n       (Cases CsP = Cases CsQ) = (CsP = CsQ) \\<Longrightarrow>\n       (Cases (a # CsP) = Cases CsQ) = (a # CsP = CsQ)", "apply(auto simp add: psiCase.inject)"], ["proof (prove)\ngoal (3 subgoals):\n 1. Case \\<bottom>\\<^sub>c = Cases CsQ \\<Longrightarrow> [] = CsQ\n 2. \\<And>a b.\n       Case \\<box> a \\<Rightarrow> b psiCases CsQ  =\n       Cases CsQ \\<Longrightarrow>\n       False\n 3. \\<And>a b CsP.\n       \\<lbrakk>Cases CsP \\<noteq> Cases CsQ; CsP \\<noteq> CsQ;\n        Case \\<box> a \\<Rightarrow> b psiCases CsP  = Cases CsQ\\<rbrakk>\n       \\<Longrightarrow> (a, b) # CsP = CsQ", "apply(case_tac CsQ)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>Case \\<bottom>\\<^sub>c = Cases CsQ; CsQ = []\\<rbrakk>\n    \\<Longrightarrow> [] = CsQ\n 2. \\<And>a list.\n       \\<lbrakk>Case \\<bottom>\\<^sub>c = Cases CsQ; CsQ = a # list\\<rbrakk>\n       \\<Longrightarrow> [] = CsQ\n 3. \\<And>a b.\n       Case \\<box> a \\<Rightarrow> b psiCases CsQ  =\n       Cases CsQ \\<Longrightarrow>\n       False\n 4. \\<And>a b CsP.\n       \\<lbrakk>Cases CsP \\<noteq> Cases CsQ; CsP \\<noteq> CsQ;\n        Case \\<box> a \\<Rightarrow> b psiCases CsP  = Cases CsQ\\<rbrakk>\n       \\<Longrightarrow> (a, b) # CsP = CsQ", "apply(simp add: psiCase.inject psi.inject)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a list.\n       \\<lbrakk>Case \\<bottom>\\<^sub>c = Cases CsQ; CsQ = a # list\\<rbrakk>\n       \\<Longrightarrow> [] = CsQ\n 2. \\<And>a b.\n       Case \\<box> a \\<Rightarrow> b psiCases CsQ  =\n       Cases CsQ \\<Longrightarrow>\n       False\n 3. \\<And>a b CsP.\n       \\<lbrakk>Cases CsP \\<noteq> Cases CsQ; CsP \\<noteq> CsQ;\n        Case \\<box> a \\<Rightarrow> b psiCases CsP  = Cases CsQ\\<rbrakk>\n       \\<Longrightarrow> (a, b) # CsP = CsQ", "apply(force simp add: psiCase.inject psi.inject)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       Case \\<box> a \\<Rightarrow> b psiCases CsQ  =\n       Cases CsQ \\<Longrightarrow>\n       False\n 2. \\<And>a b CsP.\n       \\<lbrakk>Cases CsP \\<noteq> Cases CsQ; CsP \\<noteq> CsQ;\n        Case \\<box> a \\<Rightarrow> b psiCases CsP  = Cases CsQ\\<rbrakk>\n       \\<Longrightarrow> (a, b) # CsP = CsQ", "apply(case_tac CsQ)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>Case \\<box> a \\<Rightarrow> b psiCases CsQ  = Cases CsQ;\n        CsQ = []\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b aa list.\n       \\<lbrakk>Case \\<box> a \\<Rightarrow> b psiCases CsQ  = Cases CsQ;\n        CsQ = aa # list\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a b CsP.\n       \\<lbrakk>Cases CsP \\<noteq> Cases CsQ; CsP \\<noteq> CsQ;\n        Case \\<box> a \\<Rightarrow> b psiCases CsP  = Cases CsQ\\<rbrakk>\n       \\<Longrightarrow> (a, b) # CsP = CsQ", "apply(force simp add: psiCase.inject psi.inject)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa list.\n       \\<lbrakk>Case \\<box> a \\<Rightarrow> b psiCases CsQ  = Cases CsQ;\n        CsQ = aa # list\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b CsP.\n       \\<lbrakk>Cases CsP \\<noteq> Cases CsQ; CsP \\<noteq> CsQ;\n        Case \\<box> a \\<Rightarrow> b psiCases CsP  = Cases CsQ\\<rbrakk>\n       \\<Longrightarrow> (a, b) # CsP = CsQ", "apply(auto simp add: psiCase.inject psi.inject)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b list.\n       \\<lbrakk>\\<box> a \\<Rightarrow> b psiCases list  = psiCases list;\n        CsQ = (a, b) # list\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b CsP.\n       \\<lbrakk>CsP \\<noteq> CsQ;\n        \\<box> a \\<Rightarrow> b psiCases CsP  = psiCases CsQ\\<rbrakk>\n       \\<Longrightarrow> (a, b) # CsP = CsQ", "apply(simp only: psiCases.simps[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b list.\n       \\<lbrakk>psiCases ((a, b) # list) = psiCases list;\n        CsQ = (a, b) # list\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b CsP.\n       \\<lbrakk>CsP \\<noteq> CsQ;\n        \\<box> a \\<Rightarrow> b psiCases CsP  = psiCases CsQ\\<rbrakk>\n       \\<Longrightarrow> (a, b) # CsP = CsQ", "apply(simp only: psiCasesInject)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b list.\n       \\<lbrakk>(a, b) # list = list; CsQ = list\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b CsP.\n       \\<lbrakk>CsP \\<noteq> CsQ;\n        \\<box> a \\<Rightarrow> b psiCases CsP  = psiCases CsQ\\<rbrakk>\n       \\<Longrightarrow> (a, b) # CsP = CsQ", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b CsP.\n       \\<lbrakk>CsP \\<noteq> CsQ;\n        \\<box> a \\<Rightarrow> b psiCases CsP  = psiCases CsQ\\<rbrakk>\n       \\<Longrightarrow> (a, b) # CsP = CsQ", "apply(case_tac CsQ)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b CsP.\n       \\<lbrakk>CsP \\<noteq> CsQ;\n        \\<box> a \\<Rightarrow> b psiCases CsP  = psiCases CsQ;\n        CsQ = []\\<rbrakk>\n       \\<Longrightarrow> (a, b) # CsP = CsQ\n 2. \\<And>a b CsP aa list.\n       \\<lbrakk>CsP \\<noteq> CsQ;\n        \\<box> a \\<Rightarrow> b psiCases CsP  = psiCases CsQ;\n        CsQ = aa # list\\<rbrakk>\n       \\<Longrightarrow> (a, b) # CsP = CsQ", "by(auto simp add: psiCase.inject psi.inject)"], ["", "nominal_primrec\n  guarded :: \"('a::fs_name, 'b::fs_name, 'c::fs_name) psi \\<Rightarrow> bool\"\n  and guarded'  :: \"('a::fs_name, 'b::fs_name, 'c::fs_name) input \\<Rightarrow> bool\"\n  and guarded'' :: \"('a::fs_name, 'b::fs_name, 'c::fs_name) psiCase \\<Rightarrow> bool\"\n\nwhere\n  \"guarded (\\<zero>) = True\"\n| \"guarded (M\\<langle>N\\<rangle>.P) = True\"\n| \"guarded (M\\<lparr>I) = True\"\n| \"guarded (Case C) = guarded'' C\"\n| \"guarded (P \\<parallel> Q) = ((guarded P) \\<and> (guarded Q))\"\n| \"guarded (\\<lparr>\\<nu>x\\<rparr>P) = (guarded P)\"\n| \"guarded (\\<lbrace>\\<Psi>\\<rbrace>) = False\"\n| \"guarded (!P) = guarded P\"\n\n| \"guarded' (Trm M P) = False\"\n| \"guarded' (\\<nu> y I) = False\"\n\n| \"guarded'' (\\<bottom>\\<^sub>c) = True\"\n| \"guarded'' (\\<box>\\<phi> \\<Rightarrow> P C) = (guarded P \\<and> guarded'' C)\""], ["proof (prove)\ngoal (51 subgoals):\n 1. finite (supp True)\n 2. finite (supp (\\<lambda>M N P Pa. True))\n 3. finite (supp (\\<lambda>M I Ia. True))\n 4. finite (supp (\\<lambda>C Ca. Ca))\n 5. finite (supp (\\<lambda>P Q. (\\<and>)))\n 6. finite (supp (\\<lambda>x P Pa. Pa))\n 7. finite (supp (\\<lambda>\\<Psi>. False))\n 8. finite (supp (\\<lambda>P Pa. Pa))\n 9. finite (supp (\\<lambda>M P Pa. False))\n 10. finite (supp (\\<lambda>y I Ia. False))\nA total of 51 subgoals...", "apply(finite_guess)+"], ["proof (prove)\ngoal (38 subgoals):\n 1. True\n 2. \\<And>x1 x2 x3 y1. True \\<Longrightarrow> True\n 3. \\<And>x1 x2 y1. True \\<Longrightarrow> True\n 4. \\<And>x1 y1. True \\<Longrightarrow> True\n 5. \\<And>x1 x2 y1 y2. \\<lbrakk>True; True\\<rbrakk> \\<Longrightarrow> True\n 6. \\<And>x1 x2 y1. True \\<Longrightarrow> True\n 7. \\<And>x1. True\n 8. \\<And>x1 y1. True \\<Longrightarrow> True\n 9. \\<And>x1 x2 y1. True \\<Longrightarrow> True\n 10. \\<And>x1 x2 y1. True \\<Longrightarrow> True\nA total of 38 subgoals...", "apply(rule TrueI)+"], ["proof (prove)\ngoal (26 subgoals):\n 1. \\<And>x1 x2 y1.\n       \\<lbrakk>x1 \\<sharp> (\\<lambda>x P Pa. Pa); x1 \\<sharp> ();\n        finite (supp y1); True\\<rbrakk>\n       \\<Longrightarrow> x1 \\<sharp> y1\n 2. \\<And>x1 x2 y1.\n       \\<lbrakk>x1 \\<sharp> (\\<lambda>y I Ia. False); x1 \\<sharp> ();\n        finite (supp y1); True\\<rbrakk>\n       \\<Longrightarrow> x1 \\<sharp> False\n 3. \\<And>x P. x \\<sharp> True\n 4. \\<And>x P. x \\<sharp> (\\<lambda>M N P Pa. True)\n 5. \\<And>x P. x \\<sharp> (\\<lambda>M I Ia. True)\n 6. \\<And>x P. x \\<sharp> (\\<lambda>C Ca. Ca)\n 7. \\<And>x P. x \\<sharp> (\\<lambda>P Q. (\\<and>))\n 8. \\<And>x P. x \\<sharp> (\\<lambda>x P Pa. Pa)\n 9. \\<And>x P. x \\<sharp> (\\<lambda>\\<Psi>. False)\n 10. \\<And>x P. x \\<sharp> (\\<lambda>P Pa. Pa)\nA total of 26 subgoals...", "by(fresh_guess add: fresh_bool)+"], ["", "lemma guardedEqvt[eqvt]:\n  fixes p    :: \"name prm\"\n  and   P    :: \"('a::fs_name, 'b::fs_name, 'c::fs_name) psi\"\n  and   I    :: \"('a, 'b, 'c) input\"\n  and   C    :: \"('a, 'b, 'c) psiCase\"\n\n  shows \"(p \\<bullet> (guarded P)) = guarded (p \\<bullet> P)\"\n  and   \"(p \\<bullet> (guarded' I)) = guarded' (p \\<bullet> I)\"\n  and   \"(p \\<bullet> (guarded'' C)) = guarded'' (p \\<bullet> C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> guarded P = guarded (p \\<bullet> P) &&&\n    p \\<bullet> guarded' I = guarded' (p \\<bullet> I) &&&\n    p \\<bullet> guarded'' C = guarded'' (p \\<bullet> C)", "by(nominal_induct P and I and C rule: psi_input_psiCase.strong_inducts)\n  (simp add: eqvts)+"], ["", "lemma guardedClosed[simp]:\n  fixes P :: \"('a::fs_name, 'b::fs_name, 'c::fs_name) psi\"\n  and   p :: \"name prm\"\n\n  assumes \"guarded P\"\n\n  shows \"guarded(p \\<bullet> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. guarded (p \\<bullet> P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. guarded (p \\<bullet> P)", "from \\<open>guarded P\\<close>"], ["proof (chain)\npicking this:\n  guarded P", "have \"p \\<bullet> (guarded P)\""], ["proof (prove)\nusing this:\n  guarded P\n\ngoal (1 subgoal):\n 1. p \\<bullet> guarded P", "by(simp add: perm_bool)"], ["proof (state)\nthis:\n  p \\<bullet> guarded P\n\ngoal (1 subgoal):\n 1. guarded (p \\<bullet> P)", "thus ?thesis"], ["proof (prove)\nusing this:\n  p \\<bullet> guarded P\n\ngoal (1 subgoal):\n 1. guarded (p \\<bullet> P)", "by(simp add: eqvts)"], ["proof (state)\nthis:\n  guarded (p \\<bullet> P)\n\ngoal:\nNo subgoals!", "qed"], ["", "locale substPsi =\n  substTerm?: substType substTerm +\n  substAssert?: substType substAssert +\n  substCond?: substType substCond\n\n  for substTerm :: \"('a::fs_name) \\<Rightarrow> name list \\<Rightarrow> 'a::fs_name list \\<Rightarrow> 'a\"\n  and substAssert :: \"('b::fs_name) \\<Rightarrow> name list \\<Rightarrow> 'a::fs_name list \\<Rightarrow> 'b\"\n  and substCond :: \"('c::fs_name) \\<Rightarrow> name list \\<Rightarrow> 'a::fs_name list \\<Rightarrow> 'c\"\nbegin"], ["", "nominal_primrec \n    subs   :: \"('a::fs_name, 'b::fs_name, 'c::fs_name) psi \\<Rightarrow> name list \\<Rightarrow> 'a list \\<Rightarrow> ('a, 'b, 'c) psi\"\nand subs'  :: \"('a::fs_name, 'b::fs_name, 'c::fs_name) input \\<Rightarrow> name list \\<Rightarrow> 'a list \\<Rightarrow> ('a, 'b, 'c) input\"\nand subs'' :: \"('a::fs_name, 'b::fs_name, 'c::fs_name) psiCase \\<Rightarrow> name list \\<Rightarrow> 'a list  \\<Rightarrow> ('a, 'b, 'c) psiCase\"\n\nwhere\n  \"subs (\\<zero>) xvec Tvec = \\<zero>\"\n| \"(subs (M\\<langle>N\\<rangle>.P) xvec Tvec) = (substTerm M xvec Tvec)\\<langle>(substTerm N xvec Tvec)\\<rangle>.(subs P xvec Tvec)\"\n| \"(subs (M\\<lparr>I) xvec Tvec) = (substTerm M xvec Tvec)\\<lparr>(subs' I xvec Tvec)\"\n\n| \"(subs (Case C) xvec Tvec) = (Case (subs'' C xvec Tvec))\"\n| \"(subs (P \\<parallel> Q) xvec Tvec) = (subs P xvec Tvec) \\<parallel> (subs Q xvec Tvec)\"\n| \"\\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk> \\<Longrightarrow> (subs (\\<lparr>\\<nu>y\\<rparr>P) xvec Tvec) = \\<lparr>\\<nu>y\\<rparr>(subs P xvec Tvec)\"\n| \"(subs (\\<lbrace>\\<Psi>\\<rbrace>) xvec Tvec) = \\<lbrace>(substAssert \\<Psi> xvec Tvec)\\<rbrace>\"\n| \"(subs (!P) xvec Tvec) = !(subs P xvec Tvec)\"\n\n| \"(subs' ((Trm M P)::('a::fs_name, 'b::fs_name, 'c::fs_name) input) xvec Tvec) = (\\<rparr>(substTerm M xvec Tvec).(subs P xvec Tvec))\"\n| \"\\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk> \\<Longrightarrow> (subs' (\\<nu> y I) xvec Tvec) = (\\<nu> y (subs' I xvec Tvec))\"\n\n| \"(subs'' (\\<bottom>\\<^sub>c::('a::fs_name, 'b::fs_name, 'c::fs_name) psiCase) xvec Tvec) = \\<bottom>\\<^sub>c\"\n| \"(subs'' (\\<box>\\<Phi> \\<Rightarrow> P C) xvec Tvec) = (\\<box>(substCond \\<Phi> xvec Tvec) \\<Rightarrow> (subs P xvec Tvec) (subs'' C xvec Tvec))\""], ["proof (prove)\ngoal (51 subgoals):\n 1. finite (supp (\\<zero>))\n 2. finite\n     (supp\n       (\\<lambda>M N P.\n           Output (substTerm M xvec Tvec) (substTerm N xvec Tvec)))\n 3. finite (supp (\\<lambda>M I. Input (substTerm M xvec Tvec)))\n 4. finite (supp (\\<lambda>C. Case))\n 5. finite (supp (\\<lambda>P Q. (\\<parallel>)))\n 6. finite (supp (\\<lambda>y P. Res y))\n 7. finite\n     (supp\n       (\\<lambda>\\<Psi>. \\<lbrace>substAssert \\<Psi> xvec Tvec\\<rbrace>))\n 8. finite (supp (\\<lambda>P. Bang))\n 9. finite (supp (\\<lambda>M P. Trm (substTerm M xvec Tvec)))\n 10. finite (supp (\\<lambda>y I. Bind y))\nA total of 51 subgoals...", "apply(finite_guess add: substTerm.fs substAssert.fs substCond.fs)+"], ["proof (prove)\ngoal (38 subgoals):\n 1. True\n 2. \\<And>x1 x2 x3 y1. True \\<Longrightarrow> True\n 3. \\<And>x1 x2 y1. True \\<Longrightarrow> True\n 4. \\<And>x1 y1. True \\<Longrightarrow> True\n 5. \\<And>x1 x2 y1 y2. \\<lbrakk>True; True\\<rbrakk> \\<Longrightarrow> True\n 6. \\<And>x1 x2 y1. True \\<Longrightarrow> True\n 7. \\<And>x1. True\n 8. \\<And>x1 y1. True \\<Longrightarrow> True\n 9. \\<And>x1 x2 y1. True \\<Longrightarrow> True\n 10. \\<And>x1 x2 y1. True \\<Longrightarrow> True\nA total of 38 subgoals...", "apply(rule TrueI)+"], ["proof (prove)\ngoal (26 subgoals):\n 1. \\<And>x1 x2 y1.\n       \\<lbrakk>x1 \\<sharp> (\\<lambda>y P. Res y); x1 \\<sharp> ();\n        finite (supp y1); True\\<rbrakk>\n       \\<Longrightarrow> x1 \\<sharp> \\<lparr>\\<nu>x1\\<rparr>y1\n 2. \\<And>x1 x2 y1.\n       \\<lbrakk>x1 \\<sharp> (\\<lambda>y I. Bind y); x1 \\<sharp> ();\n        finite (supp y1); True\\<rbrakk>\n       \\<Longrightarrow> x1 \\<sharp> \\<nu>x1y1\n 3. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<zero>\n 4. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M N P.\n  Output (substTerm M xvec Tvec) (substTerm N xvec Tvec))\n 5. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M I.\n  Input (substTerm M xvec Tvec))\n 6. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>C. Case)\n 7. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P Q. (\\<parallel>))\n 8. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y P. Res y)\n 9. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Psi>.\n  \\<lbrace>substAssert \\<Psi> xvec Tvec\\<rbrace>)\n 10. \\<And>y P.\n        \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> (\\<lambda>P. Bang)\nA total of 26 subgoals...", "apply(simp add: abs_fresh)"], ["proof (prove)\ngoal (25 subgoals):\n 1. \\<And>x1 x2 y1.\n       \\<lbrakk>x1 \\<sharp> (\\<lambda>y I. Bind y); x1 \\<sharp> ();\n        finite (supp y1); True\\<rbrakk>\n       \\<Longrightarrow> x1 \\<sharp> \\<nu>x1y1\n 2. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<zero>\n 3. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M N P.\n  Output (substTerm M xvec Tvec) (substTerm N xvec Tvec))\n 4. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M I.\n  Input (substTerm M xvec Tvec))\n 5. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>C. Case)\n 6. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P Q. (\\<parallel>))\n 7. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y P. Res y)\n 8. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Psi>.\n  \\<lbrace>substAssert \\<Psi> xvec Tvec\\<rbrace>)\n 9. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P. Bang)\n 10. \\<And>y P.\n        \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> (\\<lambda>M P.\n   Trm (substTerm M xvec Tvec))\nA total of 25 subgoals...", "apply(simp add: abs_fresh)"], ["proof (prove)\ngoal (24 subgoals):\n 1. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<zero>\n 2. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M N P.\n  Output (substTerm M xvec Tvec) (substTerm N xvec Tvec))\n 3. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M I.\n  Input (substTerm M xvec Tvec))\n 4. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>C. Case)\n 5. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P Q. (\\<parallel>))\n 6. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y P. Res y)\n 7. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Psi>.\n  \\<lbrace>substAssert \\<Psi> xvec Tvec\\<rbrace>)\n 8. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P. Bang)\n 9. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M P.\n  Trm (substTerm M xvec Tvec))\n 10. \\<And>y P.\n        \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> (\\<lambda>y I. Bind y)\nA total of 24 subgoals...", "apply(simp add: abs_fresh)"], ["proof (prove)\ngoal (23 subgoals):\n 1. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M N P.\n  Output (substTerm M xvec Tvec) (substTerm N xvec Tvec))\n 2. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M I.\n  Input (substTerm M xvec Tvec))\n 3. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>C. Case)\n 4. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P Q. (\\<parallel>))\n 5. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y P. Res y)\n 6. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Psi>.\n  \\<lbrace>substAssert \\<Psi> xvec Tvec\\<rbrace>)\n 7. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P. Bang)\n 8. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M P.\n  Trm (substTerm M xvec Tvec))\n 9. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y I. Bind y)\n 10. \\<And>y P.\n        \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> \\<bottom>\\<^sub>c\nA total of 23 subgoals...", "apply(rule supports_fresh[of \"supp(xvec, Tvec)\"])"], ["proof (prove)\ngoal (25 subgoals):\n 1. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> supp (xvec, Tvec) supports\n                         (\\<lambda>M N P.\n                             Output (substTerm M xvec Tvec)\n                              (substTerm N xvec Tvec))\n 2. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> finite (supp (xvec, Tvec))\n 3. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<notin> supp (xvec, Tvec)\n 4. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M I.\n  Input (substTerm M xvec Tvec))\n 5. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>C. Case)\n 6. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P Q. (\\<parallel>))\n 7. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y P. Res y)\n 8. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Psi>.\n  \\<lbrace>substAssert \\<Psi> xvec Tvec\\<rbrace>)\n 9. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P. Bang)\n 10. \\<And>y P.\n        \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> (\\<lambda>M P.\n   Trm (substTerm M xvec Tvec))\nA total of 25 subgoals...", "apply(force simp add: perm_fun_def eqvts fresh_def[symmetric] supports_def)"], ["proof (prove)\ngoal (24 subgoals):\n 1. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> finite (supp (xvec, Tvec))\n 2. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<notin> supp (xvec, Tvec)\n 3. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M I.\n  Input (substTerm M xvec Tvec))\n 4. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>C. Case)\n 5. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P Q. (\\<parallel>))\n 6. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y P. Res y)\n 7. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Psi>.\n  \\<lbrace>substAssert \\<Psi> xvec Tvec\\<rbrace>)\n 8. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P. Bang)\n 9. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M P.\n  Trm (substTerm M xvec Tvec))\n 10. \\<And>y P.\n        \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> (\\<lambda>y I. Bind y)\nA total of 24 subgoals...", "apply(simp add: fs_name1)"], ["proof (prove)\ngoal (23 subgoals):\n 1. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<notin> supp (xvec, Tvec)\n 2. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M I.\n  Input (substTerm M xvec Tvec))\n 3. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>C. Case)\n 4. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P Q. (\\<parallel>))\n 5. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y P. Res y)\n 6. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Psi>.\n  \\<lbrace>substAssert \\<Psi> xvec Tvec\\<rbrace>)\n 7. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P. Bang)\n 8. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M P.\n  Trm (substTerm M xvec Tvec))\n 9. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y I. Bind y)\n 10. \\<And>y P.\n        \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> \\<bottom>\\<^sub>c\nA total of 23 subgoals...", "apply(simp add: fresh_def[symmetric])"], ["proof (prove)\ngoal (22 subgoals):\n 1. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M I.\n  Input (substTerm M xvec Tvec))\n 2. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>C. Case)\n 3. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P Q. (\\<parallel>))\n 4. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y P. Res y)\n 5. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Psi>.\n  \\<lbrace>substAssert \\<Psi> xvec Tvec\\<rbrace>)\n 6. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P. Bang)\n 7. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M P.\n  Trm (substTerm M xvec Tvec))\n 8. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y I. Bind y)\n 9. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<bottom>\\<^sub>c\n 10. \\<And>y P.\n        \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Phi> P C.\n   Cond (substCond \\<Phi> xvec Tvec))\nA total of 22 subgoals...", "apply(rule supports_fresh[of \"supp(xvec, Tvec)\"])"], ["proof (prove)\ngoal (24 subgoals):\n 1. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> supp (xvec, Tvec) supports\n                         (\\<lambda>M I. Input (substTerm M xvec Tvec))\n 2. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> finite (supp (xvec, Tvec))\n 3. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<notin> supp (xvec, Tvec)\n 4. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>C. Case)\n 5. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P Q. (\\<parallel>))\n 6. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y P. Res y)\n 7. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Psi>.\n  \\<lbrace>substAssert \\<Psi> xvec Tvec\\<rbrace>)\n 8. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P. Bang)\n 9. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M P.\n  Trm (substTerm M xvec Tvec))\n 10. \\<And>y P.\n        \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> (\\<lambda>y I. Bind y)\nA total of 24 subgoals...", "apply(force simp add: perm_fun_def eqvts fresh_def[symmetric] supports_def)"], ["proof (prove)\ngoal (23 subgoals):\n 1. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> finite (supp (xvec, Tvec))\n 2. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<notin> supp (xvec, Tvec)\n 3. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>C. Case)\n 4. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P Q. (\\<parallel>))\n 5. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y P. Res y)\n 6. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Psi>.\n  \\<lbrace>substAssert \\<Psi> xvec Tvec\\<rbrace>)\n 7. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P. Bang)\n 8. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M P.\n  Trm (substTerm M xvec Tvec))\n 9. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y I. Bind y)\n 10. \\<And>y P.\n        \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> \\<bottom>\\<^sub>c\nA total of 23 subgoals...", "apply(simp add: fs_name1)"], ["proof (prove)\ngoal (22 subgoals):\n 1. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<notin> supp (xvec, Tvec)\n 2. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>C. Case)\n 3. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P Q. (\\<parallel>))\n 4. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y P. Res y)\n 5. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Psi>.\n  \\<lbrace>substAssert \\<Psi> xvec Tvec\\<rbrace>)\n 6. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P. Bang)\n 7. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M P.\n  Trm (substTerm M xvec Tvec))\n 8. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y I. Bind y)\n 9. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<bottom>\\<^sub>c\n 10. \\<And>y P.\n        \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Phi> P C.\n   Cond (substCond \\<Phi> xvec Tvec))\nA total of 22 subgoals...", "apply(simp add: fresh_def[symmetric])"], ["proof (prove)\ngoal (21 subgoals):\n 1. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>C. Case)\n 2. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P Q. (\\<parallel>))\n 3. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y P. Res y)\n 4. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Psi>.\n  \\<lbrace>substAssert \\<Psi> xvec Tvec\\<rbrace>)\n 5. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P. Bang)\n 6. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M P.\n  Trm (substTerm M xvec Tvec))\n 7. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y I. Bind y)\n 8. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<bottom>\\<^sub>c\n 9. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Phi> P C.\n  Cond (substCond \\<Phi> xvec Tvec))\n 10. \\<And>y I.\n        \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> \\<zero>\nA total of 21 subgoals...", "apply(fresh_guess)+"], ["proof (prove)\ngoal (18 subgoals):\n 1. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Psi>.\n  \\<lbrace>substAssert \\<Psi> xvec Tvec\\<rbrace>)\n 2. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P. Bang)\n 3. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M P.\n  Trm (substTerm M xvec Tvec))\n 4. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y I. Bind y)\n 5. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<bottom>\\<^sub>c\n 6. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Phi> P C.\n  Cond (substCond \\<Phi> xvec Tvec))\n 7. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<zero>\n 8. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M N P.\n  Output (substTerm M xvec Tvec) (substTerm N xvec Tvec))\n 9. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M I.\n  Input (substTerm M xvec Tvec))\n 10. \\<And>y I.\n        \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> (\\<lambda>C. Case)\nA total of 18 subgoals...", "apply(rule supports_fresh[of \"supp(xvec, Tvec)\"])"], ["proof (prove)\ngoal (20 subgoals):\n 1. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> supp (xvec, Tvec) supports\n                         (\\<lambda>\\<Psi>.\n                             \\<lbrace>substAssert \\<Psi> xvec Tvec\\<rbrace>)\n 2. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> finite (supp (xvec, Tvec))\n 3. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<notin> supp (xvec, Tvec)\n 4. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P. Bang)\n 5. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M P.\n  Trm (substTerm M xvec Tvec))\n 6. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y I. Bind y)\n 7. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<bottom>\\<^sub>c\n 8. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Phi> P C.\n  Cond (substCond \\<Phi> xvec Tvec))\n 9. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<zero>\n 10. \\<And>y I.\n        \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> (\\<lambda>M N P.\n   Output (substTerm M xvec Tvec) (substTerm N xvec Tvec))\nA total of 20 subgoals...", "apply(force simp add: perm_fun_def eqvts fresh_def[symmetric] supports_def)"], ["proof (prove)\ngoal (19 subgoals):\n 1. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> finite (supp (xvec, Tvec))\n 2. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<notin> supp (xvec, Tvec)\n 3. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P. Bang)\n 4. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M P.\n  Trm (substTerm M xvec Tvec))\n 5. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y I. Bind y)\n 6. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<bottom>\\<^sub>c\n 7. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Phi> P C.\n  Cond (substCond \\<Phi> xvec Tvec))\n 8. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<zero>\n 9. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M N P.\n  Output (substTerm M xvec Tvec) (substTerm N xvec Tvec))\n 10. \\<And>y I.\n        \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> (\\<lambda>M I.\n   Input (substTerm M xvec Tvec))\nA total of 19 subgoals...", "apply(simp add: fs_name1)"], ["proof (prove)\ngoal (18 subgoals):\n 1. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<notin> supp (xvec, Tvec)\n 2. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P. Bang)\n 3. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M P.\n  Trm (substTerm M xvec Tvec))\n 4. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y I. Bind y)\n 5. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<bottom>\\<^sub>c\n 6. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Phi> P C.\n  Cond (substCond \\<Phi> xvec Tvec))\n 7. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<zero>\n 8. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M N P.\n  Output (substTerm M xvec Tvec) (substTerm N xvec Tvec))\n 9. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M I.\n  Input (substTerm M xvec Tvec))\n 10. \\<And>y I.\n        \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> (\\<lambda>C. Case)\nA total of 18 subgoals...", "apply(simp add: fresh_def[symmetric])"], ["proof (prove)\ngoal (17 subgoals):\n 1. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P. Bang)\n 2. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M P.\n  Trm (substTerm M xvec Tvec))\n 3. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y I. Bind y)\n 4. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<bottom>\\<^sub>c\n 5. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Phi> P C.\n  Cond (substCond \\<Phi> xvec Tvec))\n 6. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<zero>\n 7. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M N P.\n  Output (substTerm M xvec Tvec) (substTerm N xvec Tvec))\n 8. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M I.\n  Input (substTerm M xvec Tvec))\n 9. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>C. Case)\n 10. \\<And>y I.\n        \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> (\\<lambda>P Q. (\\<parallel>))\nA total of 17 subgoals...", "apply(fresh_guess)+"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M P.\n  Trm (substTerm M xvec Tvec))\n 2. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y I. Bind y)\n 3. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<bottom>\\<^sub>c\n 4. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Phi> P C.\n  Cond (substCond \\<Phi> xvec Tvec))\n 5. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<zero>\n 6. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M N P.\n  Output (substTerm M xvec Tvec) (substTerm N xvec Tvec))\n 7. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M I.\n  Input (substTerm M xvec Tvec))\n 8. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>C. Case)\n 9. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P Q. (\\<parallel>))\n 10. \\<And>y I.\n        \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> (\\<lambda>y P. Res y)\nA total of 16 subgoals...", "apply(rule supports_fresh[of \"supp(xvec, Tvec)\"])"], ["proof (prove)\ngoal (18 subgoals):\n 1. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> supp (xvec, Tvec) supports\n                         (\\<lambda>M P. Trm (substTerm M xvec Tvec))\n 2. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> finite (supp (xvec, Tvec))\n 3. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<notin> supp (xvec, Tvec)\n 4. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y I. Bind y)\n 5. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<bottom>\\<^sub>c\n 6. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Phi> P C.\n  Cond (substCond \\<Phi> xvec Tvec))\n 7. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<zero>\n 8. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M N P.\n  Output (substTerm M xvec Tvec) (substTerm N xvec Tvec))\n 9. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M I.\n  Input (substTerm M xvec Tvec))\n 10. \\<And>y I.\n        \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> (\\<lambda>C. Case)\nA total of 18 subgoals...", "apply(force simp add: perm_fun_def eqvts fresh_def[symmetric] supports_def)"], ["proof (prove)\ngoal (17 subgoals):\n 1. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> finite (supp (xvec, Tvec))\n 2. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<notin> supp (xvec, Tvec)\n 3. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y I. Bind y)\n 4. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<bottom>\\<^sub>c\n 5. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Phi> P C.\n  Cond (substCond \\<Phi> xvec Tvec))\n 6. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<zero>\n 7. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M N P.\n  Output (substTerm M xvec Tvec) (substTerm N xvec Tvec))\n 8. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M I.\n  Input (substTerm M xvec Tvec))\n 9. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>C. Case)\n 10. \\<And>y I.\n        \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> (\\<lambda>P Q. (\\<parallel>))\nA total of 17 subgoals...", "apply(simp add: fs_name1)"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<notin> supp (xvec, Tvec)\n 2. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y I. Bind y)\n 3. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<bottom>\\<^sub>c\n 4. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Phi> P C.\n  Cond (substCond \\<Phi> xvec Tvec))\n 5. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<zero>\n 6. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M N P.\n  Output (substTerm M xvec Tvec) (substTerm N xvec Tvec))\n 7. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M I.\n  Input (substTerm M xvec Tvec))\n 8. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>C. Case)\n 9. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P Q. (\\<parallel>))\n 10. \\<And>y I.\n        \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> (\\<lambda>y P. Res y)\nA total of 16 subgoals...", "apply(simp add: fresh_def[symmetric])"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y I. Bind y)\n 2. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<bottom>\\<^sub>c\n 3. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Phi> P C.\n  Cond (substCond \\<Phi> xvec Tvec))\n 4. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<zero>\n 5. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M N P.\n  Output (substTerm M xvec Tvec) (substTerm N xvec Tvec))\n 6. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M I.\n  Input (substTerm M xvec Tvec))\n 7. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>C. Case)\n 8. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P Q. (\\<parallel>))\n 9. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y P. Res y)\n 10. \\<And>y I.\n        \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Psi>.\n   \\<lbrace>substAssert \\<Psi> xvec Tvec\\<rbrace>)\nA total of 15 subgoals...", "apply(fresh_guess)+"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Phi> P C.\n  Cond (substCond \\<Phi> xvec Tvec))\n 2. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<zero>\n 3. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M N P.\n  Output (substTerm M xvec Tvec) (substTerm N xvec Tvec))\n 4. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M I.\n  Input (substTerm M xvec Tvec))\n 5. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>C. Case)\n 6. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P Q. (\\<parallel>))\n 7. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y P. Res y)\n 8. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Psi>.\n  \\<lbrace>substAssert \\<Psi> xvec Tvec\\<rbrace>)\n 9. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P. Bang)\n 10. \\<And>y I.\n        \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> (\\<lambda>M P.\n   Trm (substTerm M xvec Tvec))\nA total of 13 subgoals...", "apply(rule supports_fresh[of \"supp(xvec, Tvec)\"])"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> supp (xvec, Tvec) supports\n                         (\\<lambda>\\<Phi> P C.\n                             Cond (substCond \\<Phi> xvec Tvec))\n 2. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> finite (supp (xvec, Tvec))\n 3. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<notin> supp (xvec, Tvec)\n 4. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<zero>\n 5. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M N P.\n  Output (substTerm M xvec Tvec) (substTerm N xvec Tvec))\n 6. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M I.\n  Input (substTerm M xvec Tvec))\n 7. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>C. Case)\n 8. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P Q. (\\<parallel>))\n 9. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y P. Res y)\n 10. \\<And>y I.\n        \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Psi>.\n   \\<lbrace>substAssert \\<Psi> xvec Tvec\\<rbrace>)\nA total of 15 subgoals...", "apply(force simp add: perm_fun_def eqvts fresh_def[symmetric] supports_def)"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> finite (supp (xvec, Tvec))\n 2. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<notin> supp (xvec, Tvec)\n 3. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<zero>\n 4. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M N P.\n  Output (substTerm M xvec Tvec) (substTerm N xvec Tvec))\n 5. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M I.\n  Input (substTerm M xvec Tvec))\n 6. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>C. Case)\n 7. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P Q. (\\<parallel>))\n 8. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y P. Res y)\n 9. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Psi>.\n  \\<lbrace>substAssert \\<Psi> xvec Tvec\\<rbrace>)\n 10. \\<And>y I.\n        \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> (\\<lambda>P. Bang)\nA total of 14 subgoals...", "apply(simp add: fs_name1)"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>y P.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<notin> supp (xvec, Tvec)\n 2. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<zero>\n 3. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M N P.\n  Output (substTerm M xvec Tvec) (substTerm N xvec Tvec))\n 4. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M I.\n  Input (substTerm M xvec Tvec))\n 5. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>C. Case)\n 6. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P Q. (\\<parallel>))\n 7. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y P. Res y)\n 8. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Psi>.\n  \\<lbrace>substAssert \\<Psi> xvec Tvec\\<rbrace>)\n 9. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P. Bang)\n 10. \\<And>y I.\n        \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> (\\<lambda>M P.\n   Trm (substTerm M xvec Tvec))\nA total of 13 subgoals...", "apply(simp add: fresh_def[symmetric])"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<zero>\n 2. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M N P.\n  Output (substTerm M xvec Tvec) (substTerm N xvec Tvec))\n 3. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M I.\n  Input (substTerm M xvec Tvec))\n 4. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>C. Case)\n 5. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P Q. (\\<parallel>))\n 6. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y P. Res y)\n 7. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Psi>.\n  \\<lbrace>substAssert \\<Psi> xvec Tvec\\<rbrace>)\n 8. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P. Bang)\n 9. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M P.\n  Trm (substTerm M xvec Tvec))\n 10. \\<And>y I.\n        \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> (\\<lambda>y I. Bind y)\nA total of 12 subgoals...", "apply(fresh_guess)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M N P.\n  Output (substTerm M xvec Tvec) (substTerm N xvec Tvec))\n 2. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M I.\n  Input (substTerm M xvec Tvec))\n 3. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>C. Case)\n 4. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P Q. (\\<parallel>))\n 5. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y P. Res y)\n 6. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Psi>.\n  \\<lbrace>substAssert \\<Psi> xvec Tvec\\<rbrace>)\n 7. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P. Bang)\n 8. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M P.\n  Trm (substTerm M xvec Tvec))\n 9. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y I. Bind y)\n 10. \\<And>y I.\n        \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> \\<bottom>\\<^sub>c\nA total of 11 subgoals...", "apply(rule supports_fresh[of \"supp(xvec, Tvec)\"])"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> supp (xvec, Tvec) supports\n                         (\\<lambda>M N P.\n                             Output (substTerm M xvec Tvec)\n                              (substTerm N xvec Tvec))\n 2. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> finite (supp (xvec, Tvec))\n 3. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<notin> supp (xvec, Tvec)\n 4. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M I.\n  Input (substTerm M xvec Tvec))\n 5. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>C. Case)\n 6. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P Q. (\\<parallel>))\n 7. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y P. Res y)\n 8. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Psi>.\n  \\<lbrace>substAssert \\<Psi> xvec Tvec\\<rbrace>)\n 9. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P. Bang)\n 10. \\<And>y I.\n        \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> (\\<lambda>M P.\n   Trm (substTerm M xvec Tvec))\nA total of 13 subgoals...", "apply(force simp add: perm_fun_def eqvts fresh_def[symmetric] supports_def)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> finite (supp (xvec, Tvec))\n 2. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<notin> supp (xvec, Tvec)\n 3. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M I.\n  Input (substTerm M xvec Tvec))\n 4. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>C. Case)\n 5. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P Q. (\\<parallel>))\n 6. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y P. Res y)\n 7. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Psi>.\n  \\<lbrace>substAssert \\<Psi> xvec Tvec\\<rbrace>)\n 8. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P. Bang)\n 9. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M P.\n  Trm (substTerm M xvec Tvec))\n 10. \\<And>y I.\n        \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> (\\<lambda>y I. Bind y)\nA total of 12 subgoals...", "apply(simp add: fs_name1)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<notin> supp (xvec, Tvec)\n 2. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M I.\n  Input (substTerm M xvec Tvec))\n 3. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>C. Case)\n 4. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P Q. (\\<parallel>))\n 5. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y P. Res y)\n 6. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Psi>.\n  \\<lbrace>substAssert \\<Psi> xvec Tvec\\<rbrace>)\n 7. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P. Bang)\n 8. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M P.\n  Trm (substTerm M xvec Tvec))\n 9. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y I. Bind y)\n 10. \\<And>y I.\n        \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> \\<bottom>\\<^sub>c\nA total of 11 subgoals...", "apply(simp add: fresh_def[symmetric])"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M I.\n  Input (substTerm M xvec Tvec))\n 2. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>C. Case)\n 3. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P Q. (\\<parallel>))\n 4. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y P. Res y)\n 5. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Psi>.\n  \\<lbrace>substAssert \\<Psi> xvec Tvec\\<rbrace>)\n 6. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P. Bang)\n 7. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M P.\n  Trm (substTerm M xvec Tvec))\n 8. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y I. Bind y)\n 9. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<bottom>\\<^sub>c\n 10. \\<And>y I.\n        \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Phi> P C.\n   Cond (substCond \\<Phi> xvec Tvec))", "apply(rule supports_fresh[of \"supp(xvec, Tvec)\"])"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> supp (xvec, Tvec) supports\n                         (\\<lambda>M I. Input (substTerm M xvec Tvec))\n 2. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> finite (supp (xvec, Tvec))\n 3. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<notin> supp (xvec, Tvec)\n 4. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>C. Case)\n 5. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P Q. (\\<parallel>))\n 6. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y P. Res y)\n 7. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Psi>.\n  \\<lbrace>substAssert \\<Psi> xvec Tvec\\<rbrace>)\n 8. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P. Bang)\n 9. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M P.\n  Trm (substTerm M xvec Tvec))\n 10. \\<And>y I.\n        \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> (\\<lambda>y I. Bind y)\nA total of 12 subgoals...", "apply(force simp add: perm_fun_def eqvts fresh_def[symmetric] supports_def)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> finite (supp (xvec, Tvec))\n 2. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<notin> supp (xvec, Tvec)\n 3. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>C. Case)\n 4. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P Q. (\\<parallel>))\n 5. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y P. Res y)\n 6. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Psi>.\n  \\<lbrace>substAssert \\<Psi> xvec Tvec\\<rbrace>)\n 7. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P. Bang)\n 8. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M P.\n  Trm (substTerm M xvec Tvec))\n 9. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y I. Bind y)\n 10. \\<And>y I.\n        \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> \\<bottom>\\<^sub>c\nA total of 11 subgoals...", "apply(simp add: fs_name1)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<notin> supp (xvec, Tvec)\n 2. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>C. Case)\n 3. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P Q. (\\<parallel>))\n 4. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y P. Res y)\n 5. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Psi>.\n  \\<lbrace>substAssert \\<Psi> xvec Tvec\\<rbrace>)\n 6. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P. Bang)\n 7. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M P.\n  Trm (substTerm M xvec Tvec))\n 8. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y I. Bind y)\n 9. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<bottom>\\<^sub>c\n 10. \\<And>y I.\n        \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Phi> P C.\n   Cond (substCond \\<Phi> xvec Tvec))", "apply(simp add: fresh_def[symmetric])"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>C. Case)\n 2. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P Q. (\\<parallel>))\n 3. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y P. Res y)\n 4. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Psi>.\n  \\<lbrace>substAssert \\<Psi> xvec Tvec\\<rbrace>)\n 5. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P. Bang)\n 6. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M P.\n  Trm (substTerm M xvec Tvec))\n 7. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y I. Bind y)\n 8. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<bottom>\\<^sub>c\n 9. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Phi> P C.\n  Cond (substCond \\<Phi> xvec Tvec))", "apply(fresh_guess)+"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Psi>.\n  \\<lbrace>substAssert \\<Psi> xvec Tvec\\<rbrace>)\n 2. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P. Bang)\n 3. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M P.\n  Trm (substTerm M xvec Tvec))\n 4. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y I. Bind y)\n 5. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<bottom>\\<^sub>c\n 6. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Phi> P C.\n  Cond (substCond \\<Phi> xvec Tvec))", "apply(rule supports_fresh[of \"supp(xvec, Tvec)\"])"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> supp (xvec, Tvec) supports\n                         (\\<lambda>\\<Psi>.\n                             \\<lbrace>substAssert \\<Psi> xvec Tvec\\<rbrace>)\n 2. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> finite (supp (xvec, Tvec))\n 3. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<notin> supp (xvec, Tvec)\n 4. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P. Bang)\n 5. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M P.\n  Trm (substTerm M xvec Tvec))\n 6. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y I. Bind y)\n 7. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<bottom>\\<^sub>c\n 8. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Phi> P C.\n  Cond (substCond \\<Phi> xvec Tvec))", "apply(force simp add: perm_fun_def eqvts fresh_def[symmetric] supports_def)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> finite (supp (xvec, Tvec))\n 2. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<notin> supp (xvec, Tvec)\n 3. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P. Bang)\n 4. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M P.\n  Trm (substTerm M xvec Tvec))\n 5. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y I. Bind y)\n 6. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<bottom>\\<^sub>c\n 7. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Phi> P C.\n  Cond (substCond \\<Phi> xvec Tvec))", "apply(simp add: fs_name1)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<notin> supp (xvec, Tvec)\n 2. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P. Bang)\n 3. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M P.\n  Trm (substTerm M xvec Tvec))\n 4. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y I. Bind y)\n 5. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<bottom>\\<^sub>c\n 6. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Phi> P C.\n  Cond (substCond \\<Phi> xvec Tvec))", "apply(simp add: fresh_def[symmetric])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>P. Bang)\n 2. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M P.\n  Trm (substTerm M xvec Tvec))\n 3. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y I. Bind y)\n 4. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<bottom>\\<^sub>c\n 5. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Phi> P C.\n  Cond (substCond \\<Phi> xvec Tvec))", "apply(fresh_guess)+"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>M P.\n  Trm (substTerm M xvec Tvec))\n 2. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y I. Bind y)\n 3. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<bottom>\\<^sub>c\n 4. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Phi> P C.\n  Cond (substCond \\<Phi> xvec Tvec))", "apply(rule supports_fresh[of \"supp(xvec, Tvec)\"])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> supp (xvec, Tvec) supports\n                         (\\<lambda>M P. Trm (substTerm M xvec Tvec))\n 2. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> finite (supp (xvec, Tvec))\n 3. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<notin> supp (xvec, Tvec)\n 4. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y I. Bind y)\n 5. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<bottom>\\<^sub>c\n 6. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Phi> P C.\n  Cond (substCond \\<Phi> xvec Tvec))", "apply(force simp add: perm_fun_def eqvts fresh_def[symmetric] supports_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> finite (supp (xvec, Tvec))\n 2. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<notin> supp (xvec, Tvec)\n 3. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y I. Bind y)\n 4. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<bottom>\\<^sub>c\n 5. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Phi> P C.\n  Cond (substCond \\<Phi> xvec Tvec))", "apply(simp add: fs_name1)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<notin> supp (xvec, Tvec)\n 2. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y I. Bind y)\n 3. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<bottom>\\<^sub>c\n 4. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Phi> P C.\n  Cond (substCond \\<Phi> xvec Tvec))", "apply(simp add: fresh_def[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>y I. Bind y)\n 2. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> \\<bottom>\\<^sub>c\n 3. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Phi> P C.\n  Cond (substCond \\<Phi> xvec Tvec))", "apply(fresh_guess)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (\\<lambda>\\<Phi> P C.\n  Cond (substCond \\<Phi> xvec Tvec))", "apply(rule supports_fresh[of \"supp(xvec, Tvec)\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> supp (xvec, Tvec) supports\n                         (\\<lambda>\\<Phi> P C.\n                             Cond (substCond \\<Phi> xvec Tvec))\n 2. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> finite (supp (xvec, Tvec))\n 3. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<notin> supp (xvec, Tvec)", "apply(force simp add: perm_fun_def eqvts fresh_def[symmetric] supports_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> finite (supp (xvec, Tvec))\n 2. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<notin> supp (xvec, Tvec)", "apply(simp add: fs_name1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y I.\n       \\<lbrakk>y \\<sharp> xvec; y \\<sharp> Tvec\\<rbrakk>\n       \\<Longrightarrow> y \\<notin> supp (xvec, Tvec)", "apply(simp add: fresh_def[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma substEqvt[eqvt]:\n  fixes p    :: \"name prm\"\n  and   P    :: \"('a, 'b, 'c) psi\"\n  and   xvec :: \"name list\"\n  and   Tvec :: \"'a list\"\n  and   I    :: \"('a, 'b, 'c) input\"\n  and   C    :: \"('a, 'b, 'c) psiCase\"\n\n  shows \"(p \\<bullet> (subs P xvec Tvec)) = subs (p \\<bullet> P) (p \\<bullet> xvec) (p \\<bullet> Tvec)\"\n  and   \"(p \\<bullet> (subs' I xvec Tvec)) = subs' (p \\<bullet> I) (p \\<bullet> xvec) (p \\<bullet> Tvec)\"\n  and   \"(p \\<bullet> (subs'' C xvec Tvec)) = subs'' (p \\<bullet> C) (p \\<bullet> xvec) (p \\<bullet> Tvec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> subs P xvec Tvec =\n    subs (p \\<bullet> P) (p \\<bullet> xvec) (p \\<bullet> Tvec) &&&\n    p \\<bullet> subs' I xvec Tvec =\n    subs' (p \\<bullet> I) (p \\<bullet> xvec) (p \\<bullet> Tvec) &&&\n    p \\<bullet> subs'' C xvec Tvec =\n    subs'' (p \\<bullet> C) (p \\<bullet> xvec) (p \\<bullet> Tvec)", "apply(nominal_induct P and I and C avoiding: xvec Tvec rule: psi_input_psiCase.strong_inducts)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>xvec Tvec.\n       p \\<bullet> subs (\\<zero>) xvec Tvec =\n       subs (p \\<bullet> \\<zero>) (p \\<bullet> xvec) (p \\<bullet> Tvec)\n 2. \\<And>term1 term2 psi xvec Tvec.\n       (\\<And>b ba.\n           p \\<bullet> subs psi b ba =\n           subs (p \\<bullet> psi) (p \\<bullet> b)\n            (p \\<bullet> ba)) \\<Longrightarrow>\n       p \\<bullet> subs (term1\\<langle>term2\\<rangle>.psi) xvec Tvec =\n       subs (p \\<bullet> term1\\<langle>term2\\<rangle>.psi)\n        (p \\<bullet> xvec) (p \\<bullet> Tvec)\n 3. \\<And>term input xvec Tvec.\n       (\\<And>b ba.\n           p \\<bullet> subs' input b ba =\n           subs' (p \\<bullet> input) (p \\<bullet> b)\n            (p \\<bullet> ba)) \\<Longrightarrow>\n       p \\<bullet> subs (term\\<lparr>input) xvec Tvec =\n       subs (p \\<bullet> term\\<lparr>input) (p \\<bullet> xvec)\n        (p \\<bullet> Tvec)\n 4. \\<And>psiCase xvec Tvec.\n       (\\<And>b ba.\n           p \\<bullet> subs'' psiCase b ba =\n           subs'' (p \\<bullet> psiCase) (p \\<bullet> b)\n            (p \\<bullet> ba)) \\<Longrightarrow>\n       p \\<bullet> subs (Case psiCase) xvec Tvec =\n       subs (p \\<bullet> Case psiCase) (p \\<bullet> xvec) (p \\<bullet> Tvec)\n 5. \\<And>psi1 psi2 xvec Tvec.\n       \\<lbrakk>\\<And>b ba.\n                   p \\<bullet> subs psi1 b ba =\n                   subs (p \\<bullet> psi1) (p \\<bullet> b) (p \\<bullet> ba);\n        \\<And>b ba.\n           p \\<bullet> subs psi2 b ba =\n           subs (p \\<bullet> psi2) (p \\<bullet> b) (p \\<bullet> ba)\\<rbrakk>\n       \\<Longrightarrow> p \\<bullet>\n                         subs (psi1 \\<parallel> psi2) xvec Tvec =\n                         subs (p \\<bullet> psi1 \\<parallel> psi2)\n                          (p \\<bullet> xvec) (p \\<bullet> Tvec)\n 6. \\<And>name psi xvec Tvec.\n       \\<lbrakk>name \\<sharp> xvec; name \\<sharp> Tvec;\n        \\<And>b ba.\n           p \\<bullet> subs psi b ba =\n           subs (p \\<bullet> psi) (p \\<bullet> b) (p \\<bullet> ba)\\<rbrakk>\n       \\<Longrightarrow> p \\<bullet>\n                         subs (\\<lparr>\\<nu>name\\<rparr>psi) xvec Tvec =\n                         subs (p \\<bullet> \\<lparr>\\<nu>name\\<rparr>psi)\n                          (p \\<bullet> xvec) (p \\<bullet> Tvec)\n 7. \\<And>assertion xvec Tvec.\n       p \\<bullet> subs (\\<lbrace>assertion\\<rbrace>) xvec Tvec =\n       subs (p \\<bullet> \\<lbrace>assertion\\<rbrace>) (p \\<bullet> xvec)\n        (p \\<bullet> Tvec)\n 8. \\<And>psi xvec Tvec.\n       (\\<And>b ba.\n           p \\<bullet> subs psi b ba =\n           subs (p \\<bullet> psi) (p \\<bullet> b)\n            (p \\<bullet> ba)) \\<Longrightarrow>\n       p \\<bullet> subs (!psi) xvec Tvec =\n       subs (p \\<bullet> !psi) (p \\<bullet> xvec) (p \\<bullet> Tvec)\n 9. \\<And>term psi xvec Tvec.\n       (\\<And>b ba.\n           p \\<bullet> subs psi b ba =\n           subs (p \\<bullet> psi) (p \\<bullet> b)\n            (p \\<bullet> ba)) \\<Longrightarrow>\n       p \\<bullet> subs' (\\<rparr>term.psi) xvec Tvec =\n       subs' (p \\<bullet> \\<rparr>term.psi) (p \\<bullet> xvec)\n        (p \\<bullet> Tvec)\n 10. \\<And>name input xvec Tvec.\n        \\<lbrakk>name \\<sharp> xvec; name \\<sharp> Tvec;\n         \\<And>b ba.\n            p \\<bullet> subs' input b ba =\n            subs' (p \\<bullet> input) (p \\<bullet> b)\n             (p \\<bullet> ba)\\<rbrakk>\n        \\<Longrightarrow> p \\<bullet> subs' (\\<nu>nameinput) xvec Tvec =\n                          subs' (p \\<bullet> \\<nu>nameinput)\n                           (p \\<bullet> xvec) (p \\<bullet> Tvec)\nA total of 12 subgoals...", "apply(auto simp add: eqvts)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>name psi xvec Tvec.\n       \\<lbrakk>name \\<sharp> xvec; name \\<sharp> Tvec;\n        \\<And>b ba.\n           p \\<bullet> subs psi b ba =\n           subs (p \\<bullet> psi) (p \\<bullet> b) (p \\<bullet> ba)\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>\\<nu>(p \\<bullet>\n name)\\<rparr>subs (p \\<bullet> psi) (p \\<bullet> xvec) (p \\<bullet> Tvec) =\n                         subs\n                          (\\<lparr>\\<nu>(p \\<bullet>\n   name)\\<rparr>(p \\<bullet> psi))\n                          (p \\<bullet> xvec) (p \\<bullet> Tvec)\n 2. \\<And>name input xvec Tvec.\n       \\<lbrakk>name \\<sharp> xvec; name \\<sharp> Tvec;\n        \\<And>b ba.\n           p \\<bullet> subs' input b ba =\n           subs' (p \\<bullet> input) (p \\<bullet> b)\n            (p \\<bullet> ba)\\<rbrakk>\n       \\<Longrightarrow> \\<nu>(p \\<bullet>\n                               name)subs' (p \\<bullet> input)\n                                     (p \\<bullet> xvec) (p \\<bullet> Tvec) =\n                         subs' (\\<nu>(p \\<bullet> name)(p \\<bullet> input))\n                          (p \\<bullet> xvec) (p \\<bullet> Tvec)", "apply(drule_tac pi=p in pt_fresh_bij1[OF pt_name_inst, OF at_name_inst])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>name psi xvec Tvec.\n       \\<lbrakk>name \\<sharp> Tvec;\n        \\<And>b ba.\n           p \\<bullet> subs psi b ba =\n           subs (p \\<bullet> psi) (p \\<bullet> b) (p \\<bullet> ba);\n        p \\<bullet> name \\<sharp> p \\<bullet> xvec\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>\\<nu>(p \\<bullet>\n name)\\<rparr>subs (p \\<bullet> psi) (p \\<bullet> xvec) (p \\<bullet> Tvec) =\n                         subs\n                          (\\<lparr>\\<nu>(p \\<bullet>\n   name)\\<rparr>(p \\<bullet> psi))\n                          (p \\<bullet> xvec) (p \\<bullet> Tvec)\n 2. \\<And>name input xvec Tvec.\n       \\<lbrakk>name \\<sharp> xvec; name \\<sharp> Tvec;\n        \\<And>b ba.\n           p \\<bullet> subs' input b ba =\n           subs' (p \\<bullet> input) (p \\<bullet> b)\n            (p \\<bullet> ba)\\<rbrakk>\n       \\<Longrightarrow> \\<nu>(p \\<bullet>\n                               name)subs' (p \\<bullet> input)\n                                     (p \\<bullet> xvec) (p \\<bullet> Tvec) =\n                         subs' (\\<nu>(p \\<bullet> name)(p \\<bullet> input))\n                          (p \\<bullet> xvec) (p \\<bullet> Tvec)", "apply(drule_tac pi=p in pt_fresh_bij1[OF pt_name_inst, OF at_name_inst])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>name psi xvec Tvec.\n       \\<lbrakk>\\<And>b ba.\n                   p \\<bullet> subs psi b ba =\n                   subs (p \\<bullet> psi) (p \\<bullet> b) (p \\<bullet> ba);\n        p \\<bullet> name \\<sharp> p \\<bullet> xvec;\n        p \\<bullet> name \\<sharp> p \\<bullet> Tvec\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>\\<nu>(p \\<bullet>\n name)\\<rparr>subs (p \\<bullet> psi) (p \\<bullet> xvec) (p \\<bullet> Tvec) =\n                         subs\n                          (\\<lparr>\\<nu>(p \\<bullet>\n   name)\\<rparr>(p \\<bullet> psi))\n                          (p \\<bullet> xvec) (p \\<bullet> Tvec)\n 2. \\<And>name input xvec Tvec.\n       \\<lbrakk>name \\<sharp> xvec; name \\<sharp> Tvec;\n        \\<And>b ba.\n           p \\<bullet> subs' input b ba =\n           subs' (p \\<bullet> input) (p \\<bullet> b)\n            (p \\<bullet> ba)\\<rbrakk>\n       \\<Longrightarrow> \\<nu>(p \\<bullet>\n                               name)subs' (p \\<bullet> input)\n                                     (p \\<bullet> xvec) (p \\<bullet> Tvec) =\n                         subs' (\\<nu>(p \\<bullet> name)(p \\<bullet> input))\n                          (p \\<bullet> xvec) (p \\<bullet> Tvec)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>name input xvec Tvec.\n       \\<lbrakk>name \\<sharp> xvec; name \\<sharp> Tvec;\n        \\<And>b ba.\n           p \\<bullet> subs' input b ba =\n           subs' (p \\<bullet> input) (p \\<bullet> b)\n            (p \\<bullet> ba)\\<rbrakk>\n       \\<Longrightarrow> \\<nu>(p \\<bullet>\n                               name)subs' (p \\<bullet> input)\n                                     (p \\<bullet> xvec) (p \\<bullet> Tvec) =\n                         subs' (\\<nu>(p \\<bullet> name)(p \\<bullet> input))\n                          (p \\<bullet> xvec) (p \\<bullet> Tvec)", "apply(drule_tac pi=p in pt_fresh_bij1[OF pt_name_inst, OF at_name_inst])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>name input xvec Tvec.\n       \\<lbrakk>name \\<sharp> Tvec;\n        \\<And>b ba.\n           p \\<bullet> subs' input b ba =\n           subs' (p \\<bullet> input) (p \\<bullet> b) (p \\<bullet> ba);\n        p \\<bullet> name \\<sharp> p \\<bullet> xvec\\<rbrakk>\n       \\<Longrightarrow> \\<nu>(p \\<bullet>\n                               name)subs' (p \\<bullet> input)\n                                     (p \\<bullet> xvec) (p \\<bullet> Tvec) =\n                         subs' (\\<nu>(p \\<bullet> name)(p \\<bullet> input))\n                          (p \\<bullet> xvec) (p \\<bullet> Tvec)", "apply(drule_tac pi=p in pt_fresh_bij1[OF pt_name_inst, OF at_name_inst])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>name input xvec Tvec.\n       \\<lbrakk>\\<And>b ba.\n                   p \\<bullet> subs' input b ba =\n                   subs' (p \\<bullet> input) (p \\<bullet> b)\n                    (p \\<bullet> ba);\n        p \\<bullet> name \\<sharp> p \\<bullet> xvec;\n        p \\<bullet> name \\<sharp> p \\<bullet> Tvec\\<rbrakk>\n       \\<Longrightarrow> \\<nu>(p \\<bullet>\n                               name)subs' (p \\<bullet> input)\n                                     (p \\<bullet> xvec) (p \\<bullet> Tvec) =\n                         subs' (\\<nu>(p \\<bullet> name)(p \\<bullet> input))\n                          (p \\<bullet> xvec) (p \\<bullet> Tvec)", "by simp"], ["", "lemma subst2[intro]:\n  fixes xvec :: \"name list\"\n  and   Tvec :: \"'a list\"\n  and   x    :: name\n  and   P    :: \"('a, 'b, 'c) psi\"\n  and   I    :: \"('a, 'b, 'c) input\"\n  and   C    :: \"('a, 'b, 'c) psiCase\"\n\n  assumes \"x \\<sharp> Tvec\"\n  and     \"x \\<sharp> xvec\"\n\n  shows \"x \\<sharp> P \\<Longrightarrow> x \\<sharp> (subs P xvec Tvec)\"\n  and   \"x \\<sharp> I \\<Longrightarrow> x \\<sharp> (subs' I xvec Tvec)\"\n  and   \"x \\<sharp> C \\<Longrightarrow> x \\<sharp> (subs'' C xvec Tvec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sharp> P \\<Longrightarrow> x \\<sharp> subs P xvec Tvec) &&&\n    (x \\<sharp> I \\<Longrightarrow> x \\<sharp> subs' I xvec Tvec) &&&\n    (x \\<sharp> C \\<Longrightarrow> x \\<sharp> subs'' C xvec Tvec)", "using assms"], ["proof (prove)\nusing this:\n  x \\<sharp> Tvec\n  x \\<sharp> xvec\n\ngoal (1 subgoal):\n 1. (x \\<sharp> P \\<Longrightarrow> x \\<sharp> subs P xvec Tvec) &&&\n    (x \\<sharp> I \\<Longrightarrow> x \\<sharp> subs' I xvec Tvec) &&&\n    (x \\<sharp> C \\<Longrightarrow> x \\<sharp> subs'' C xvec Tvec)", "by(nominal_induct P and I and C avoiding: xvec Tvec rule: psi_input_psiCase.strong_inducts)\n  (auto intro: substTerm.subst2 substCond.subst2 substAssert.subst2 simp add: abs_fresh)"], ["", "lemma subst2Chain[intro]:\n  fixes xvec :: \"name list\"\n  and   Tvec :: \"'a list\"\n  and   Xs   :: \"name set\"\n  and   P    :: \"('a, 'b, 'c) psi\"\n  and   I    :: \"('a, 'b, 'c) input\"\n  and   C    :: \"('a, 'b, 'c) psiCase\"\n\n  assumes \"Xs \\<sharp>* xvec\"\n  and     \"Xs \\<sharp>* Tvec\"\n\n  shows \"Xs \\<sharp>* P \\<Longrightarrow> Xs \\<sharp>* (subs P xvec Tvec)\"\n  and   \"Xs \\<sharp>* I \\<Longrightarrow> Xs \\<sharp>* (subs' I xvec Tvec)\"\n  and   \"Xs \\<sharp>* C \\<Longrightarrow> Xs \\<sharp>* (subs'' C xvec Tvec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Xs \\<sharp>* P \\<Longrightarrow> Xs \\<sharp>* subs P xvec Tvec) &&&\n    (Xs \\<sharp>* I \\<Longrightarrow> Xs \\<sharp>* subs' I xvec Tvec) &&&\n    (Xs \\<sharp>* C \\<Longrightarrow> Xs \\<sharp>* subs'' C xvec Tvec)", "using assms"], ["proof (prove)\nusing this:\n  Xs \\<sharp>* xvec\n  Xs \\<sharp>* Tvec\n\ngoal (1 subgoal):\n 1. (Xs \\<sharp>* P \\<Longrightarrow> Xs \\<sharp>* subs P xvec Tvec) &&&\n    (Xs \\<sharp>* I \\<Longrightarrow> Xs \\<sharp>* subs' I xvec Tvec) &&&\n    (Xs \\<sharp>* C \\<Longrightarrow> Xs \\<sharp>* subs'' C xvec Tvec)", "by(auto intro: subst2 simp add: fresh_star_def)"], ["", "lemma renaming:\n  fixes xvec :: \"name list\"\n  and   Tvec :: \"'a list\"\n  and   p    :: \"name prm\"\n  and   P    :: \"('a, 'b, 'c) psi\"\n  and   I    :: \"('a ,'b, 'c) input\"\n  and   C    :: \"('a, 'b, 'c) psiCase\"\n\n  assumes \"length xvec = length Tvec\"\n  and     \"set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\"\n  and     \"distinctPerm p\"\n\n  shows \"\\<lbrakk>(p \\<bullet> xvec) \\<sharp>* P\\<rbrakk> \\<Longrightarrow> (subs P xvec Tvec) = subs (p \\<bullet> P) (p \\<bullet> xvec) Tvec\"\n  and   \"\\<lbrakk>(p \\<bullet> xvec) \\<sharp>* I\\<rbrakk> \\<Longrightarrow> (subs' I xvec Tvec) = subs' (p \\<bullet> I) (p \\<bullet> xvec) Tvec\"\n  and   \"\\<lbrakk>(p \\<bullet> xvec) \\<sharp>* C\\<rbrakk> \\<Longrightarrow> (subs'' C xvec Tvec) = subs'' (p \\<bullet> C) (p \\<bullet> xvec) Tvec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((p \\<bullet> xvec) \\<sharp>* P \\<Longrightarrow>\n     subs P xvec Tvec = subs (p \\<bullet> P) (p \\<bullet> xvec) Tvec) &&&\n    ((p \\<bullet> xvec) \\<sharp>* I \\<Longrightarrow>\n     subs' I xvec Tvec = subs' (p \\<bullet> I) (p \\<bullet> xvec) Tvec) &&&\n    ((p \\<bullet> xvec) \\<sharp>* C \\<Longrightarrow>\n     subs'' C xvec Tvec = subs'' (p \\<bullet> C) (p \\<bullet> xvec) Tvec)", "using assms"], ["proof (prove)\nusing this:\n  length xvec = length Tvec\n  set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\n  distinctPerm p\n\ngoal (1 subgoal):\n 1. ((p \\<bullet> xvec) \\<sharp>* P \\<Longrightarrow>\n     subs P xvec Tvec = subs (p \\<bullet> P) (p \\<bullet> xvec) Tvec) &&&\n    ((p \\<bullet> xvec) \\<sharp>* I \\<Longrightarrow>\n     subs' I xvec Tvec = subs' (p \\<bullet> I) (p \\<bullet> xvec) Tvec) &&&\n    ((p \\<bullet> xvec) \\<sharp>* C \\<Longrightarrow>\n     subs'' C xvec Tvec = subs'' (p \\<bullet> C) (p \\<bullet> xvec) Tvec)", "by(nominal_induct P and I and C avoiding: xvec p Tvec rule: psi_input_psiCase.strong_inducts)\n  (auto intro: substTerm.renaming substCond.renaming substAssert.renaming simp add: freshChainSimps psi.inject input.inject psiCase.inject)"], ["", "lemma subst4Chain:\n  fixes xvec :: \"name list\"\n  and   Tvec :: \"'a list\"\n  and   P    :: \"('a, 'b, 'c) psi\"\n  and   I    :: \"('a, 'b, 'c) input\"\n  and   C    :: \"('a, 'b, 'c) psiCase\"\n\n  assumes \"length xvec = length Tvec\"\n  and     \"distinct xvec\"\n  and     \"xvec \\<sharp>* Tvec\"\n\n  shows \"xvec \\<sharp>* (subs P xvec Tvec)\"\n  and   \"xvec \\<sharp>* (subs' I xvec Tvec)\"\n  and   \"xvec \\<sharp>* (subs'' C xvec Tvec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xvec \\<sharp>* subs P xvec Tvec &&&\n    xvec \\<sharp>* subs' I xvec Tvec &&& xvec \\<sharp>* subs'' C xvec Tvec", "using assms"], ["proof (prove)\nusing this:\n  length xvec = length Tvec\n  distinct xvec\n  xvec \\<sharp>* Tvec\n\ngoal (1 subgoal):\n 1. xvec \\<sharp>* subs P xvec Tvec &&&\n    xvec \\<sharp>* subs' I xvec Tvec &&& xvec \\<sharp>* subs'' C xvec Tvec", "by(nominal_induct P and I and C avoiding: xvec Tvec rule: psi_input_psiCase.strong_inducts)\n  (auto intro: substTerm.subst4Chain substCond.subst4Chain substAssert.subst4Chain simp add: abs_fresh)"], ["", "lemma guardedSubst[simp]:\n  fixes P    :: \"('a, 'b, 'c) psi\"\n  and   I    :: \"('a, 'b, 'c) input\"\n  and   C    :: \"('a, 'b, 'c) psiCase\"\n  and   xvec :: \"name list\"\n  and   Tvec :: \"'a list\"\n\n  assumes \"length xvec = length Tvec\"\n  and     \"distinct xvec\"\n\n  shows \"guarded P \\<Longrightarrow> guarded(subs P xvec Tvec)\"\n  and   \"guarded' I \\<Longrightarrow> guarded'(subs' I xvec Tvec)\"\n  and   \"guarded'' C \\<Longrightarrow> guarded''(subs'' C xvec Tvec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (guarded P \\<Longrightarrow> guarded (subs P xvec Tvec)) &&&\n    (guarded' I \\<Longrightarrow> guarded' (subs' I xvec Tvec)) &&&\n    (guarded'' C \\<Longrightarrow> guarded'' (subs'' C xvec Tvec))", "using assms"], ["proof (prove)\nusing this:\n  length xvec = length Tvec\n  distinct xvec\n\ngoal (1 subgoal):\n 1. (guarded P \\<Longrightarrow> guarded (subs P xvec Tvec)) &&&\n    (guarded' I \\<Longrightarrow> guarded' (subs' I xvec Tvec)) &&&\n    (guarded'' C \\<Longrightarrow> guarded'' (subs'' C xvec Tvec))", "by(nominal_induct P and I and C avoiding: xvec Tvec rule: psi_input_psiCase.strong_inducts) auto"], ["", "definition seqSubs :: \"('a, 'b, 'c) psi \\<Rightarrow> (name list \\<times> 'a list) list \\<Rightarrow> ('a, 'b, 'c) psi\" (\"_[<_>]\" [80, 80] 130)\n  where \"P[<\\<sigma>>] \\<equiv> foldl (\\<lambda>Q. \\<lambda>(xvec, Tvec). subs Q xvec Tvec) P \\<sigma>\""], ["", "definition seqSubs' :: \"('a, 'b, 'c) input \\<Rightarrow> (name list \\<times> 'a list) list \\<Rightarrow> ('a, 'b, 'c) input\" \n  where \"seqSubs' I \\<sigma> \\<equiv> foldl (\\<lambda>Q. \\<lambda>(xvec, Tvec). subs' Q xvec Tvec) I \\<sigma>\""], ["", "definition seqSubs'' :: \"('a, 'b, 'c) psiCase \\<Rightarrow> (name list \\<times> 'a list) list \\<Rightarrow> ('a, 'b, 'c) psiCase\"\n  where \"seqSubs'' C \\<sigma> \\<equiv> foldl (\\<lambda>Q. \\<lambda>(xvec, Tvec). subs'' Q xvec Tvec) C \\<sigma>\""], ["", "lemma substInputChain[simp]:\n  fixes xvec :: \"name list\"\n  and   N    :: \"'a\"\n  and   P    :: \"('a, 'b, 'c) psi\"\n  and   yvec :: \"name list\"\n  and   Tvec :: \"'a list\"\n\n  assumes \"xvec \\<sharp>* yvec\"\n  and     \"xvec \\<sharp>* Tvec\"\n\n  shows \"subs' (inputChain xvec N P) yvec Tvec = inputChain xvec (substTerm N yvec Tvec) (subs P yvec Tvec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subs' (inputChain xvec N P) yvec Tvec =\n    inputChain xvec (substTerm N yvec Tvec) (subs P yvec Tvec)", "using assms"], ["proof (prove)\nusing this:\n  xvec \\<sharp>* yvec\n  xvec \\<sharp>* Tvec\n\ngoal (1 subgoal):\n 1. subs' (inputChain xvec N P) yvec Tvec =\n    inputChain xvec (substTerm N yvec Tvec) (subs P yvec Tvec)", "by(induct xvec) (auto simp add: psi.inject)"], ["", "fun caseListSubst :: \"('c \\<times> ('a, 'b, 'c) psi) list \\<Rightarrow> name list \\<Rightarrow> 'a list \\<Rightarrow> ('c \\<times> ('a, 'b, 'c) psi) list\"\nwhere\n  \"caseListSubst [] _ _ = []\"\n| \"caseListSubst ((\\<phi>, P)#Cs) xvec Tvec = (substCond \\<phi> xvec Tvec, (subs P xvec Tvec))#(caseListSubst Cs xvec Tvec)\""], ["", "lemma substCases[simp]:\n  fixes Cs   :: \"('c \\<times> ('a, 'b, 'c) psi) list\"\n  and   xvec :: \"name list\"\n  and   Tvec :: \"'a list\"\n\n  shows \"subs (Cases Cs) xvec Tvec = Cases(caseListSubst Cs xvec Tvec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subs (Cases Cs) xvec Tvec = Cases caseListSubst Cs xvec Tvec", "by(induct Cs) (auto simp add: psi.inject)"], ["", "lemma substCases'[simp]:\n  fixes Cs   :: \"('c \\<times> ('a, 'b, 'c) psi) list\"\n  and   xvec :: \"name list\"\n  and   Tvec :: \"'a list\"\n\n  shows \"(subs'' (psiCases Cs) xvec Tvec) = psiCases(caseListSubst Cs xvec Tvec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subs'' (psiCases Cs) xvec Tvec = psiCases (caseListSubst Cs xvec Tvec)", "by(induct Cs) auto"], ["", "lemma seqSubstSimps[simp]:\n  shows \"seqSubs (\\<zero>) \\<sigma> = \\<zero>\"\n  and   \"(seqSubs (M\\<langle>N\\<rangle>.P) \\<sigma>) = (substTerm.seqSubst M \\<sigma>)\\<langle>(substTerm.seqSubst N \\<sigma>)\\<rangle>.(seqSubs P \\<sigma>)\"\n  and   \"(seqSubs (M\\<lparr>I) \\<sigma>) = (substTerm.seqSubst M \\<sigma>)\\<lparr>(seqSubs' I \\<sigma>)\"\n\n  and   \"(seqSubs (Case C) \\<sigma>) = (Case (seqSubs'' C \\<sigma>))\"\n  and   \"(seqSubs (P \\<parallel> Q) \\<sigma>) = (seqSubs P \\<sigma>) \\<parallel> (seqSubs Q \\<sigma>)\"\n  and   \"\\<lbrakk>y \\<sharp> \\<sigma>\\<rbrakk> \\<Longrightarrow> (seqSubs (\\<lparr>\\<nu>y\\<rparr>P) \\<sigma>) = \\<lparr>\\<nu>y\\<rparr>(seqSubs P \\<sigma>)\"\n  and   \"(seqSubs (\\<lbrace>\\<Psi>\\<rbrace>) \\<sigma>) = \\<lbrace>(substAssert.seqSubst \\<Psi> \\<sigma>)\\<rbrace>\"\n  and   \"(seqSubs (!P) \\<sigma>) = !(seqSubs P \\<sigma>)\"\n  \n  and   \"(seqSubs' ((Trm M P)::('a::fs_name, 'b::fs_name, 'c::fs_name) input) \\<sigma>) = (\\<rparr>(substTerm.seqSubst M \\<sigma>).(seqSubs P \\<sigma>))\"\n  and   \"\\<lbrakk>y \\<sharp> \\<sigma>\\<rbrakk> \\<Longrightarrow> (seqSubs' (\\<nu> y I) \\<sigma>) = (\\<nu> y (seqSubs' I \\<sigma>))\"\n  \n  and   \"(seqSubs'' (\\<bottom>\\<^sub>c::('a::fs_name, 'b::fs_name, 'c::fs_name) psiCase) \\<sigma>) = \\<bottom>\\<^sub>c\"\n  and   \"(seqSubs'' (\\<box>\\<Phi> \\<Rightarrow> P C) \\<sigma>) = (\\<box>(substCond.seqSubst \\<Phi> \\<sigma>) \\<Rightarrow> (seqSubs P \\<sigma>) (seqSubs'' C \\<sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<zero>[<\\<sigma>>] = \\<zero> &&&\n      M\\<langle>N\\<rangle>.P[<\\<sigma>>] =\n      substTerm.seqSubst M\n       \\<sigma>\\<langle>substTerm.seqSubst N\n                         \\<sigma>\\<rangle>.P[<\\<sigma>>] &&&\n      M\\<lparr>I[<\\<sigma>>] =\n      substTerm.seqSubst M \\<sigma>\\<lparr>seqSubs' I \\<sigma>) &&&\n     Case C[<\\<sigma>>] = Case seqSubs'' C \\<sigma> &&&\n     P \\<parallel> Q[<\\<sigma>>] =\n     P[<\\<sigma>>] \\<parallel> Q[<\\<sigma>>] &&&\n     (y \\<sharp> \\<sigma> \\<Longrightarrow>\n      \\<lparr>\\<nu>y\\<rparr>P[<\\<sigma>>] =\n      \\<lparr>\\<nu>y\\<rparr>P[<\\<sigma>>])) &&&\n    (\\<lbrace>\\<Psi>\\<rbrace>[<\\<sigma>>] =\n     \\<lbrace>substAssert.seqSubst \\<Psi> \\<sigma>\\<rbrace> &&&\n     !P[<\\<sigma>>] = !P[<\\<sigma>>] &&&\n     seqSubs' (\\<rparr>M.P) \\<sigma> =\n     \\<rparr>substTerm.seqSubst M \\<sigma>.P[<\\<sigma>>]) &&&\n    (y \\<sharp> \\<sigma> \\<Longrightarrow>\n     seqSubs' (\\<nu>yI) \\<sigma> = \\<nu>yseqSubs' I \\<sigma>) &&&\n    seqSubs'' (\\<bottom>\\<^sub>c) \\<sigma> = \\<bottom>\\<^sub>c &&&\n    seqSubs'' (\\<box> \\<Phi> \\<Rightarrow> P C ) \\<sigma> =\n    \\<box> substCond.seqSubst \\<Phi>\n            \\<sigma> \\<Rightarrow> P[<\\<sigma>>] seqSubs'' C \\<sigma>", "by(induct \\<sigma> arbitrary: M N P I C Q \\<Psi> \\<Phi>, auto simp add: seqSubs_def seqSubs'_def seqSubs''_def)"], ["", "lemma seqSubsNil[simp]:\n  \"seqSubs P [] = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P[<[]>] = P", "by(simp add: seqSubs_def)"], ["", "lemma seqSubsCons[simp]:\n  shows \"seqSubs P ((xvec, Tvec)#\\<sigma>) = seqSubs(subs P xvec Tvec) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P[<((xvec, Tvec) # \\<sigma>)>] = subs P xvec Tvec[<\\<sigma>>]", "by(simp add: seqSubs_def)"], ["", "lemma seqSubsTermAppend[simp]:\n  shows \"seqSubs P (\\<sigma>@\\<sigma>') = seqSubs (seqSubs P \\<sigma>) \\<sigma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P[<(\\<sigma> @ \\<sigma>')>] = P[<\\<sigma>>][<\\<sigma>'>]", "by(induct \\<sigma>) (auto simp add: seqSubs_def)"], ["", "fun caseListSeqSubst :: \"('c \\<times> ('a, 'b, 'c) psi) list \\<Rightarrow> (name list \\<times> 'a list) list \\<Rightarrow> ('c \\<times> ('a, 'b, 'c) psi) list\"\nwhere\n  \"caseListSeqSubst [] _ = []\"\n| \"caseListSeqSubst ((\\<phi>, P)#Cs) \\<sigma> = (substCond.seqSubst \\<phi> \\<sigma>, (seqSubs P \\<sigma>))#(caseListSeqSubst Cs \\<sigma>)\""], ["", "lemma seqSubstCases[simp]:\n  fixes Cs :: \"('c \\<times> ('a, 'b, 'c) psi) list\"\n  and   \\<sigma>  :: \"(name list \\<times> 'a list) list\"\n\n  shows \"seqSubs (Cases Cs) \\<sigma> = Cases(caseListSeqSubst Cs \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cases Cs[<\\<sigma>>] = Cases caseListSeqSubst Cs \\<sigma>", "by(induct Cs) (auto simp add: psi.inject)"], ["", "lemma seqSubstCases'[simp]:\n  fixes Cs :: \"('c \\<times> ('a, 'b, 'c) psi) list\"\n  and   \\<sigma>  :: \"(name list \\<times> 'a list) list\"\n\n  shows \"(seqSubs'' (psiCases Cs) \\<sigma>) = psiCases(caseListSeqSubst Cs \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seqSubs'' (psiCases Cs) \\<sigma> =\n    psiCases (caseListSeqSubst Cs \\<sigma>)", "by(induct Cs) auto"], ["", "lemma seqSubstEqvt[eqvt]:\n  fixes P :: \"('a, 'b, 'c) psi\"\n  and   \\<sigma> :: \"(name list \\<times> 'a list) list\"\n  and   p :: \"name prm\"\n\n  shows \"(p \\<bullet> (P[<\\<sigma>>])) = (p \\<bullet> P)[<(p \\<bullet> \\<sigma>)>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> P[<\\<sigma>>] = p \\<bullet> P[<p \\<bullet> \\<sigma>>]", "by(induct \\<sigma> arbitrary: P) (auto simp add: eqvts seqSubs_def)"], ["", "lemma guardedSeqSubst:\n  assumes \"guarded P\"\n  and     \"wellFormedSubst \\<sigma>\"\n\n  shows \"guarded(seqSubs P \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. guarded (P[<\\<sigma>>])", "using assms"], ["proof (prove)\nusing this:\n  guarded P\n  wellFormedSubst \\<sigma>\n\ngoal (1 subgoal):\n 1. guarded (P[<\\<sigma>>])", "by(induct \\<sigma> arbitrary: P) (auto dest: guardedSubst)"], ["", "end"], ["", "lemma inter_eqvt:\n  shows \"(pi::name prm) \\<bullet> ((X::name set) \\<inter> Y) = (pi \\<bullet> X) \\<inter> (pi \\<bullet> Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pi \\<bullet> (X \\<inter> Y) = pi \\<bullet> X \\<inter> pi \\<bullet> Y", "by(auto simp add: perm_set_def perm_bij)"], ["", "lemma delete_eqvt:\n  fixes p :: \"name prm\"\n  and   X :: \"name set\"\n  and   Y :: \"name set\"\n\n  shows \"p \\<bullet> (X - Y) = (p \\<bullet> X) - (p \\<bullet> Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (X - Y) = p \\<bullet> X - p \\<bullet> Y", "by(auto simp add: perm_set_def perm_bij)"], ["", "lemma perm_singleton[simp]:\n  shows \"(p::name prm) \\<bullet> {(x::name)} = {p \\<bullet> x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> {x} = {p \\<bullet> x}", "by(auto simp add: perm_set_def)"], ["", "end"]]}