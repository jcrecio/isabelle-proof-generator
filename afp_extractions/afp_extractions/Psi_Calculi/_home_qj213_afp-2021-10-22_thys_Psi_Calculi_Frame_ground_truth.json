{"file_name": "/home/qj213/afp-2021-10-22/thys/Psi_Calculi/Frame.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Psi_Calculi", "problem_names": ["lemma permLength[simp]:\n  fixes p    :: \"name prm\"\n  and   xvec :: \"'a::pt_name list\"\n\n  shows \"length(p \\<bullet> xvec) = length xvec\"", "lemma frameResChainEqvt[eqvt]:\n  fixes perm :: \"name prm\"\n  and   lst  :: \"name list\"\n  and   F    :: \"'a::fs_name frame\"\n  \n  shows \"perm \\<bullet> (\\<lparr>\\<nu>*xvec\\<rparr>F) = \\<lparr>\\<nu>*(perm \\<bullet> xvec)\\<rparr>(perm \\<bullet> F)\"", "lemma frameResChainFresh: \n  fixes x    :: name\n  and   xvec :: \"name list\"\n  and   F    :: \"'a::fs_name frame\"\n\n  shows \"x \\<sharp> \\<lparr>\\<nu>*xvec\\<rparr>F = (x \\<in> set xvec \\<or> x \\<sharp> F)\"", "lemma frameResChainFreshSet: \n  fixes Xs   :: \"name set\"\n  and   xvec :: \"name list\"\n  and   F    :: \"'a::fs_name frame\"\n\n  shows \"Xs \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>F) = (\\<forall>x\\<in>Xs. x \\<in> set xvec \\<or> x \\<sharp> F)\"", "lemma frameChainAlpha:\n  fixes p    :: \"name prm\"\n  and   xvec :: \"name list\"\n  and   F    :: \"'a::fs_name frame\"\n\n  assumes xvecFreshF: \"(p \\<bullet> xvec) \\<sharp>* F\"\n  and     S: \"set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\"\n\n  shows \"\\<lparr>\\<nu>*xvec\\<rparr>F = \\<lparr>\\<nu>*(p \\<bullet> xvec)\\<rparr>(p \\<bullet> F)\"", "lemma frameChainAlpha':\n  fixes p    :: \"name prm\"\n  and   A\\<^sub>P   :: \"name list\"\n  and   \\<Psi>\\<^sub>P  :: \"'a::fs_name\"\n\n  assumes \"(p \\<bullet> A\\<^sub>P) \\<sharp>* \\<Psi>\\<^sub>P\"\n  and     S: \"set p \\<subseteq> set A\\<^sub>P \\<times> set (p \\<bullet> A\\<^sub>P)\"\n\n  shows \"\\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle> = \\<langle>(p \\<bullet> A\\<^sub>P), p \\<bullet> \\<Psi>\\<^sub>P\\<rangle>\"", "lemma alphaFrameRes:\n  fixes x :: name\n  and   F :: \"'a::fs_name frame\"\n  and   y :: name\n\n  assumes \"y \\<sharp> F\"\n\n  shows \"\\<lparr>\\<nu>x\\<rparr>F = \\<lparr>\\<nu>y\\<rparr>([(x, y)] \\<bullet> F)\"", "lemma frameChainAppend:\n  fixes xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   F    :: \"'a::fs_name frame\"\n  \n  shows \"\\<lparr>\\<nu>*(xvec@yvec)\\<rparr>F = \\<lparr>\\<nu>*xvec\\<rparr>(\\<lparr>\\<nu>*yvec\\<rparr>F)\"", "lemma frameChainEqLength:\n  fixes xvec :: \"name list\"\n  and   \\<Psi>    :: \"'a::fs_name\"\n  and   yvec :: \"name list\"\n  and   \\<Psi>'   :: \"'a::fs_name\"\n\n  assumes \"\\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\"\n\n  shows \"length xvec = length yvec\"", "lemma frameEqFresh:\n  fixes F :: \"('a::fs_name) frame\"\n  and   G :: \"'a frame\"\n  and   x :: name\n  and   y :: name\n\n  assumes \"\\<lparr>\\<nu>x\\<rparr>F = \\<lparr>\\<nu>y\\<rparr>G\"\n  and     \"x \\<sharp> F\"\n  \n  shows \"y \\<sharp> G\"", "lemma frameEqSupp:\n  fixes F :: \"('a::fs_name) frame\"\n  and   G :: \"'a frame\"\n  and   x :: name\n  and   y :: name\n\n  assumes \"\\<lparr>\\<nu>x\\<rparr>F = \\<lparr>\\<nu>y\\<rparr>G\"\n  and     \"x \\<in> supp F\"\n  \n  shows \"y \\<in> supp G\"", "lemma frameChainEqSuppEmpty[dest]:\n  fixes xvec :: \"name list\"\n  and   \\<Psi>    :: \"'a::fs_name\"\n  and   yvec :: \"name list\"\n  and   \\<Psi>'   :: \"'a::fs_name\"\n\n  assumes \"\\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\"\n  and     \"supp \\<Psi> = ({}::name set)\"\n\n  shows \"\\<Psi> = \\<Psi>'\"", "lemma frameChainEq:\n  fixes xvec :: \"name list\"\n  and   \\<Psi>    :: \"'a::fs_name\"\n  and   yvec :: \"name list\"\n  and   \\<Psi>'   :: \"'a::fs_name\"\n\n  assumes \"\\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\"\n  and     \"xvec \\<sharp>* yvec\"\n\n  obtains p where \"(set p) \\<subseteq> (set xvec) \\<times> set (yvec)\" and \"distinctPerm p\" and \"\\<Psi>' = p \\<bullet> \\<Psi>\"", "lemma frameChainEq':\n  fixes xvec :: \"name list\"\n  and   \\<Psi>    :: \"'a::fs_name\"\n  and   yvec :: \"name list\"\n  and   \\<Psi>'   :: \"'a::fs_name\"\n\n  assumes \"\\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\"\n  and     \"xvec \\<sharp>* yvec\"\n  and     \"distinct xvec\"\n  and     \"distinct yvec\"\n\n  obtains p where \"(set p) \\<subseteq> (set xvec) \\<times> set (p \\<bullet> xvec)\" and \"distinctPerm p\" and \"yvec = p \\<bullet> xvec\" and \"\\<Psi>' = p \\<bullet> \\<Psi>\"", "lemma frameEq[simp]:\n  fixes A\\<^sub>F :: \"name list\"\n  and   \\<Psi>  :: \"'a::fs_name\"\n  and   \\<Psi>'  :: 'a\n\n  shows \"\\<langle>A\\<^sub>F, \\<Psi>\\<rangle> = \\<langle>\\<epsilon>, \\<Psi>'\\<rangle> = (A\\<^sub>F = [] \\<and> \\<Psi> = \\<Psi>')\"\n  and   \"\\<langle>\\<epsilon>, \\<Psi>'\\<rangle> = \\<langle>A\\<^sub>F, \\<Psi>\\<rangle>  = (A\\<^sub>F = [] \\<and> \\<Psi> = \\<Psi>')\"", "lemma distinctFrame:\n  fixes A\\<^sub>F :: \"name list\"\n  and   \\<Psi>\\<^sub>F :: \"'a::fs_name\"\n  and   C  :: \"'b::fs_name\"\n  \n  assumes \"A\\<^sub>F \\<sharp>* C\"\n\n  obtains A\\<^sub>F' where  \"\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> = \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle>\" and \"distinct A\\<^sub>F'\" and \"A\\<^sub>F' \\<sharp>* C\"", "lemma freshFrame:\n  fixes F  :: \"('a::fs_name) frame\"\n  and   C  :: \"'b ::fs_name\"\n\n  obtains A\\<^sub>F \\<Psi>\\<^sub>F where \"F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\" and \"distinct A\\<^sub>F\" and \"A\\<^sub>F \\<sharp>* C\"", "lemma statClosed:\n  fixes \\<Psi> :: 'b\n  and   \\<phi> :: 'c\n  and   p :: \"name prm\"\n  \n  assumes \"\\<Psi> \\<turnstile> \\<phi>\"\n\n  shows \"(p \\<bullet> \\<Psi>) \\<turnstile> (p \\<bullet> \\<phi>)\"", "lemma compSupp:\n  fixes \\<Psi>  :: 'b\n  and   \\<Psi>' :: 'b\n\n  shows \"(supp(\\<Psi> \\<otimes> \\<Psi>')::name set) \\<subseteq> ((supp \\<Psi>) \\<union> (supp \\<Psi>'))\"", "lemma chanEqSupp:\n  fixes M :: 'a\n  and   N :: 'a\n\n  shows \"(supp(M \\<leftrightarrow> N)::name set) \\<subseteq> ((supp M) \\<union> (supp N))\"", "lemma freshComp[intro]:\n  fixes x  :: name\n  and   \\<Psi>  :: 'b\n  and   \\<Psi>' :: 'b\n\n  assumes \"x \\<sharp> \\<Psi>\"\n  and     \"x \\<sharp> \\<Psi>'\"\n\n  shows \"x \\<sharp> \\<Psi> \\<otimes> \\<Psi>'\"", "lemma freshCompChain[intro]:\n  fixes xvec  :: \"name list\"\n  and   Xs    :: \"name set\"\n  and   \\<Psi>     :: 'b\n  and   \\<Psi>'    :: 'b\n\n  shows \"\\<lbrakk>xvec \\<sharp>* \\<Psi>; xvec \\<sharp>* \\<Psi>'\\<rbrakk> \\<Longrightarrow> xvec \\<sharp>* (\\<Psi> \\<otimes> \\<Psi>')\"\n  and   \"\\<lbrakk>Xs \\<sharp>* \\<Psi>; Xs \\<sharp>* \\<Psi>'\\<rbrakk> \\<Longrightarrow> Xs \\<sharp>* (\\<Psi> \\<otimes> \\<Psi>')\"", "lemma freshChanEq[intro]:\n  fixes x :: name\n  and   M :: 'a\n  and   N :: 'a\n\n  assumes \"x \\<sharp> M\"\n  and     \"x \\<sharp> N\"\n\n  shows \"x \\<sharp> M \\<leftrightarrow> N\"", "lemma freshChanEqChain[intro]:\n  fixes xvec :: \"name list\"\n  and   Xs   :: \"name set\"\n  and   M    :: 'a\n  and   N    :: 'a\n\n  shows \"\\<lbrakk>xvec \\<sharp>* M; xvec \\<sharp>* N\\<rbrakk> \\<Longrightarrow> xvec \\<sharp>* (M \\<leftrightarrow> N)\"\n  and   \"\\<lbrakk>Xs \\<sharp>* M; Xs \\<sharp>* N\\<rbrakk> \\<Longrightarrow> Xs \\<sharp>* (M \\<leftrightarrow> N)\"", "lemma suppBottom[simp]:\n  shows \"((supp SBottom)::name set) = {}\"", "lemma freshBottom[simp]:\n  fixes x :: name\n  \n  shows \"x \\<sharp> \\<bottom>\"", "lemma freshBottoChain[simp]:\n  fixes xvec :: \"name list\"\n  and   Xs   :: \"name set\"\n\n  shows \"xvec \\<sharp>* (\\<bottom>)\"\n  and   \"Xs   \\<sharp>* (\\<bottom>)\"", "lemma chanEqClosed:\n  fixes \\<Psi> :: 'b\n  and   M :: 'a\n  and   N :: 'a\n  and   p :: \"name prm\"\n \n  assumes \"\\<Psi> \\<turnstile> M \\<leftrightarrow> N\"\n\n  shows \"(p \\<bullet> \\<Psi>) \\<turnstile> (p \\<bullet> M) \\<leftrightarrow> (p \\<bullet> N)\"", "lemma statImpEnt:\n  fixes \\<Psi>  :: 'b\n  and   \\<Psi>' :: 'b\n  and   \\<Phi>  :: 'c\n\n  assumes \"\\<Psi> \\<hookrightarrow> \\<Psi>'\"\n  and     \"\\<Psi> \\<turnstile> \\<Phi>\"\n\n  shows \"\\<Psi>' \\<turnstile> \\<Phi>\"", "lemma statEqEnt:\n  fixes \\<Psi>  :: 'b\n  and   \\<Psi>' :: 'b\n  and   \\<Phi>  :: 'c\n\n  assumes \"\\<Psi> \\<simeq> \\<Psi>'\"\n  and     \"\\<Psi> \\<turnstile> \\<Phi>\"\n\n  shows \"\\<Psi>' \\<turnstile> \\<Phi>\"", "lemma AssertionStatImpClosed:\n  fixes \\<Psi>  :: 'b\n  and   \\<Psi>' :: 'b\n  and   p  :: \"name prm\"\n\n  assumes \"\\<Psi> \\<hookrightarrow> \\<Psi>'\"\n\n  shows \"(p \\<bullet> \\<Psi>) \\<hookrightarrow> (p \\<bullet> \\<Psi>')\"", "lemma AssertionStatEqClosed:\n  fixes \\<Psi>  :: 'b\n  and   \\<Psi>' :: 'b\n  and   p  :: \"name prm\"\n\n  assumes \"\\<Psi> \\<simeq> \\<Psi>'\"\n\n  shows \"(p \\<bullet> \\<Psi>) \\<simeq> (p \\<bullet> \\<Psi>')\"", "lemma AssertionStatImpEqvt[eqvt]:\n  fixes \\<Psi>  :: 'b\n  and   \\<Psi>' :: 'b\n  and   p  :: \"name prm\"\n\n  shows \"(p \\<bullet> (\\<Psi> \\<hookrightarrow> \\<Psi>')) = ((p \\<bullet> \\<Psi>) \\<hookrightarrow> (p \\<bullet> \\<Psi>'))\"", "lemma AssertionStatEqEqvt[eqvt]:\n  fixes \\<Psi>  :: 'b\n  and   \\<Psi>' :: 'b\n  and   p  :: \"name prm\"\n\n  shows \"(p \\<bullet> (\\<Psi> \\<simeq> \\<Psi>')) = ((p \\<bullet> \\<Psi>) \\<simeq> (p \\<bullet> \\<Psi>'))\"", "lemma AssertionStatImpRefl[simp]:\n  fixes \\<Psi> :: 'b\n\n  shows \"\\<Psi> \\<hookrightarrow> \\<Psi>\"", "lemma AssertionStatEqRefl[simp]:\n  fixes \\<Psi> :: 'b\n\n  shows \"\\<Psi> \\<simeq> \\<Psi>\"", "lemma AssertionStatEqSym:\n  fixes \\<Psi>   :: 'b\n  and   \\<Psi>'  :: 'b\n\n  assumes \"\\<Psi> \\<simeq> \\<Psi>'\"\n\n  shows \"\\<Psi>' \\<simeq> \\<Psi>\"", "lemma AssertionStatImpTrans:\n  fixes \\<Psi>   :: 'b\n  and   \\<Psi>'  :: 'b\n  and   \\<Psi>'' :: 'b\n\n  assumes \"\\<Psi> \\<hookrightarrow> \\<Psi>'\"\n  and     \"\\<Psi>' \\<hookrightarrow> \\<Psi>''\"\n\n  shows \"\\<Psi> \\<hookrightarrow> \\<Psi>''\"", "lemma AssertionStatEqTrans:\n  fixes \\<Psi>   :: 'b\n  and   \\<Psi>'  :: 'b\n  and   \\<Psi>'' :: 'b\n\n  assumes \"\\<Psi> \\<simeq> \\<Psi>'\"\n  and     \"\\<Psi>' \\<simeq> \\<Psi>''\"\n\n  shows \"\\<Psi> \\<simeq> \\<Psi>''\"", "lemma frameImpI:\n  fixes F  :: \"'b frame\"\n  and   \\<phi>  :: 'c\n  and   A\\<^sub>F :: \"name list\"\n  and   \\<Psi>\\<^sub>F :: 'b\n\n  assumes \"F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\"\n  and     \"A\\<^sub>F \\<sharp>* \\<phi>\"\n  and     \"\\<Psi>\\<^sub>F \\<turnstile> \\<phi>\"\n\n  shows \"F \\<turnstile>\\<^sub>F \\<phi>\"", "lemma frameImpAlphaEnt:\n  fixes A\\<^sub>F  :: \"name list\"\n  and   \\<Psi>\\<^sub>F  :: 'b\n  and   A\\<^sub>F' :: \"name list\"\n  and   \\<Psi>\\<^sub>F' :: 'b\n  and   \\<phi>   :: 'c\n\n  assumes \"\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> = \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F'\\<rangle>\" \n  and     \"A\\<^sub>F \\<sharp>* \\<phi>\"\n  and     \"A\\<^sub>F' \\<sharp>* \\<phi>\"\n  and     \"\\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\"\n\n  shows \"\\<Psi>\\<^sub>F \\<turnstile> \\<phi>\"", "lemma frameImpEAux:\n  fixes F  :: \"'b frame\"\n  and   \\<Phi>  :: 'c\n\n  assumes  \"F \\<turnstile>\\<^sub>F \\<Phi>\"\n  and      \"F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\"\n  and      \"A\\<^sub>F \\<sharp>* \\<Phi>\"\n  \n  shows \"\\<Psi>\\<^sub>F \\<turnstile> \\<Phi>\"", "lemma frameImpE:\n  fixes F  :: \"'b frame\"\n  and   \\<Phi>  :: 'c\n\n  assumes  \"\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<turnstile>\\<^sub>F \\<Phi>\"\n  and      \"A\\<^sub>F \\<sharp>* \\<Phi>\"\n  \n  shows \"\\<Psi>\\<^sub>F \\<turnstile> \\<Phi>\"", "lemma frameImpClosed:\n  fixes F :: \"'b frame\"\n  and   \\<Phi> :: 'c\n  and   p :: \"name prm\"\n\n  assumes \"F \\<turnstile>\\<^sub>F \\<Phi>\"\n\n  shows \"(p \\<bullet> F) \\<turnstile>\\<^sub>F (p \\<bullet> \\<Phi>)\"", "lemma frameImpEqvt[eqvt]:\n  fixes F :: \"'b frame\"\n  and   \\<Phi> :: 'c\n  and   p :: \"name prm\"\n\n  shows \"(p \\<bullet> (F \\<turnstile>\\<^sub>F \\<Phi>)) = (p \\<bullet> F) \\<turnstile>\\<^sub>F (p \\<bullet> \\<Phi>)\"", "lemma frameImpEmpty[simp]:\n  fixes \\<Psi> :: 'b\n  and   \\<phi> :: 'c\n\n  shows \"\\<langle>\\<epsilon>, \\<Psi>\\<rangle> \\<turnstile>\\<^sub>F \\<phi> = \\<Psi> \\<turnstile> \\<phi>\"", "lemma FrameStatImpClosed:\n  fixes F :: \"'b frame\"\n  and   G :: \"'b frame\"\n  and   p :: \"name prm\"\n\n  assumes \"F \\<hookrightarrow>\\<^sub>F G\"\n\n  shows \"(p \\<bullet> F) \\<hookrightarrow>\\<^sub>F (p \\<bullet> G)\"", "lemma FrameStatEqClosed:\n  fixes F :: \"'b frame\"\n  and   G :: \"'b frame\"\n  and   p :: \"name prm\"\n\n  assumes \"F \\<simeq>\\<^sub>F G\"\n\n  shows \"(p \\<bullet> F) \\<simeq>\\<^sub>F (p \\<bullet> G)\"", "lemma FrameStatImpEqvt[eqvt]:\n  fixes F :: \"'b frame\"\n  and   G :: \"'b frame\"\n  and   p :: \"name prm\"\n\n  shows \"(p \\<bullet> (F \\<hookrightarrow>\\<^sub>F G)) = ((p \\<bullet> F) \\<hookrightarrow>\\<^sub>F (p \\<bullet> G))\"", "lemma FrameStatEqEqvt[eqvt]:\n  fixes F :: \"'b frame\"\n  and   G :: \"'b frame\"\n  and   p :: \"name prm\"\n\n  shows \"(p \\<bullet> (F \\<simeq>\\<^sub>F G)) = ((p \\<bullet> F) \\<simeq>\\<^sub>F (p \\<bullet> G))\"", "lemma FrameStatImpRefl[simp]:\n  fixes F :: \"'b frame\"\n\n  shows \"F \\<hookrightarrow>\\<^sub>F F\"", "lemma FrameStatEqRefl[simp]:\n  fixes F :: \"'b frame\"\n\n  shows \"F \\<simeq>\\<^sub>F F\"", "lemma FrameStatEqSym:\n  fixes F  :: \"'b frame\"\n  and   G  :: \"'b frame\"\n\n  assumes \"F \\<simeq>\\<^sub>F G\"\n\n  shows \"G \\<simeq>\\<^sub>F F\"", "lemma FrameStatImpTrans:\n  fixes F :: \"'b frame\"\n  and   G :: \"'b frame\" \n  and   H :: \"'b frame\"\n\n  assumes \"F \\<hookrightarrow>\\<^sub>F G\"\n  and     \"G \\<hookrightarrow>\\<^sub>F H\"\n\n  shows \"F \\<hookrightarrow>\\<^sub>F H\"", "lemma FrameStatEqTrans:\n  fixes F :: \"'b frame\"\n  and   G :: \"'b frame\"\n  and   H :: \"'b frame\"\n\n  assumes \"F \\<simeq>\\<^sub>F G\"\n  and     \"G \\<simeq>\\<^sub>F H\"\n\n  shows \"F \\<simeq>\\<^sub>F H\"", "lemma fsCompose[simp]: \"finite((supp SCompose)::name set)\"", "lemma insertAssertionEqvt[eqvt]:\n  fixes p :: \"name prm\"\n  and   F :: \"'b frame\"\n  and   \\<Psi> :: 'b\n\n  shows \"p \\<bullet> (insertAssertion F \\<Psi>) = insertAssertion (p \\<bullet> F) (p \\<bullet> \\<Psi>)\"", "lemma mergeFrameEqvt[eqvt]:\n  fixes p :: \"name prm\"\n  and   F :: \"'b frame\"\n  and   G :: \"'b frame\"\n\n  shows \"p \\<bullet> (mergeFrame F G) = mergeFrame (p \\<bullet> F) (p \\<bullet> G)\"", "lemmas extractFrameSimps = extractFrame_extractFrame'_extractFrame''.simps", "lemma extractFrameEqvt[eqvt]:\n  fixes p :: \"name prm\"\n  and   P :: \"('a, 'b, 'c) psi\"\n  and   I :: \"('a, 'b, 'c) input\"\n  and   C :: \"('a, 'b, 'c) psiCase\"\n\n  shows \"p \\<bullet> (extractFrame P) = extractFrame (p \\<bullet> P)\"\n  and   \"p \\<bullet> (extractFrame' I) = extractFrame' (p \\<bullet> I)\"\n  and   \"p \\<bullet> (extractFrame'' C) = extractFrame'' (p \\<bullet> C)\"", "lemma insertAssertionFresh[intro]:\n  fixes F :: \"'b frame\"\n  and   \\<Psi> :: 'b\n  and   x :: name\n\n  assumes \"x \\<sharp> F\"\n  and     \"x \\<sharp> \\<Psi>\"\n\n  shows \"x \\<sharp> (insertAssertion F \\<Psi>)\"", "lemma insertAssertionFreshChain[intro]:\n  fixes F    :: \"'b frame\"\n  and   \\<Psi>    :: 'b\n  and   xvec :: \"name list\"\n  and   Xs   :: \"name set\"\n\n  shows \"\\<lbrakk>xvec \\<sharp>* F; xvec \\<sharp>* \\<Psi>\\<rbrakk> \\<Longrightarrow> xvec \\<sharp>* (insertAssertion F \\<Psi>)\"\n  and   \"\\<lbrakk>Xs \\<sharp>* F; Xs \\<sharp>* \\<Psi>\\<rbrakk> \\<Longrightarrow> Xs \\<sharp>* (insertAssertion F \\<Psi>)\"", "lemma mergeFrameFresh[intro]:\n  fixes F :: \"'b frame\"\n  and   G :: \"'b frame\"\n  and   x :: name\n\n  shows \"\\<lbrakk>x \\<sharp> F; x \\<sharp> G\\<rbrakk> \\<Longrightarrow> x \\<sharp> (mergeFrame F G)\"", "lemma mergeFrameFreshChain[intro]:\n  fixes F    :: \"'b frame\"\n  and   G    :: \"'b frame\"\n  and   xvec :: \"name list\"\n  and   Xs   :: \"name set\"\n\n  shows \"\\<lbrakk>xvec \\<sharp>* F; xvec \\<sharp>* G\\<rbrakk> \\<Longrightarrow> xvec \\<sharp>* (mergeFrame F G)\"\n  and   \"\\<lbrakk>Xs \\<sharp>* F; Xs \\<sharp>* G\\<rbrakk> \\<Longrightarrow> Xs \\<sharp>* (mergeFrame F G)\"", "lemma extractFrameFresh:\n  fixes P :: \"('a, 'b, 'c) psi\"\n  and   I :: \"('a, 'b, 'c) input\"\n  and   C :: \"('a, 'b, 'c) psiCase\"\n  and   x :: name\n\n  shows \"x \\<sharp> P \\<Longrightarrow> x \\<sharp> extractFrame P\"\n  and   \"x \\<sharp> I \\<Longrightarrow> x \\<sharp> extractFrame' I\"\n  and   \"x \\<sharp> C \\<Longrightarrow> x \\<sharp> extractFrame'' C\"", "lemma extractFrameFreshChain:\n  fixes P    :: \"('a, 'b, 'c) psi\"\n  and   I    :: \"('a, 'b, 'c) input\"\n  and   C    :: \"('a, 'b, 'c) psiCase\"\n  and   xvec :: \"name list\"\n  and   Xs   :: \"name set\"\n\n  shows \"xvec \\<sharp>* P \\<Longrightarrow> xvec \\<sharp>* extractFrame P\"\n  and   \"xvec \\<sharp>* I \\<Longrightarrow> xvec \\<sharp>* extractFrame' I\"\n  and   \"xvec \\<sharp>* C \\<Longrightarrow> xvec \\<sharp>* extractFrame'' C\"\n  and   \"Xs \\<sharp>* P \\<Longrightarrow> Xs \\<sharp>* extractFrame P\"\n  and   \"Xs \\<sharp>* I \\<Longrightarrow> Xs \\<sharp>* extractFrame' I\"\n  and   \"Xs \\<sharp>* C \\<Longrightarrow> Xs \\<sharp>* extractFrame'' C\"", "lemma guardedFrameSupp[simp]:\n  fixes P :: \"('a, 'b, 'c) psi\"\n  and   I :: \"('a, 'b, 'c) input\"\n  and   C :: \"('a, 'b, 'c) psiCase\"\n  and   x :: name \n\n  shows \"guarded P \\<Longrightarrow> x \\<sharp> (extractFrame P)\"\n  and   \"guarded' I \\<Longrightarrow> x \\<sharp> (extractFrame' I)\"\n  and   \"guarded'' C \\<Longrightarrow> x \\<sharp> (extractFrame'' C)\"", "lemma frameResChainFresh': \n  fixes xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   F    :: \"'b frame\"\n\n  shows \"(xvec \\<sharp>* (\\<lparr>\\<nu>*yvec\\<rparr>F)) = (\\<forall>x \\<in> set xvec. x \\<in> set yvec \\<or> x \\<sharp> F)\"", "lemma frameChainFresh[simp]:\n  fixes xvec :: \"name list\"\n  and   \\<Psi>    :: 'b\n  and   Xs   :: \"name set\"\n\n  shows \"xvec \\<sharp>* (FAssert \\<Psi>) = xvec \\<sharp>* \\<Psi>\"\n  and   \"Xs \\<sharp>* (FAssert \\<Psi>) = Xs \\<sharp>* \\<Psi>\"", "lemma frameResChainFresh''[simp]:\n  fixes xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   F    :: \"'b frame\"\n  \n  assumes \"xvec \\<sharp>* yvec\"\n\n  shows \"xvec \\<sharp>* (\\<lparr>\\<nu>*yvec\\<rparr>F) = xvec \\<sharp>* F\"", "lemma frameResChainFresh'''[simp]:\n  fixes x    :: name\n  and   xvec :: \"name list\"\n  and   F    :: \"'b frame\"\n  \n  assumes \"x \\<sharp> xvec\"\n\n  shows \"x \\<sharp> (\\<lparr>\\<nu>*xvec\\<rparr>F) = x \\<sharp> F\"", "lemma FFreshBottom[simp]:\n  fixes xvec :: \"name list\"\n  and   Xs   :: \"name set\"\n\n  shows \"xvec \\<sharp>* (\\<bottom>\\<^sub>F)\"\n  and   \"Xs \\<sharp>* (\\<bottom>\\<^sub>F)\"", "lemma SFreshBottom[simp]:\n  fixes xvec :: \"name list\"\n  and   Xs   :: \"name set\"\n\n  shows \"xvec \\<sharp>* (SBottom)\"\n  and   \"Xs \\<sharp>* (SBottom)\"", "lemma freshFrameDest[dest]:\n  fixes A\\<^sub>F    :: \"name list\"\n  and   \\<Psi>\\<^sub>F   :: 'b\n  and   xvec  :: \"name list\"\n\n  assumes \"xvec \\<sharp>* (\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>)\"\n\n  shows \"xvec \\<sharp>* A\\<^sub>F \\<Longrightarrow> xvec \\<sharp>* \\<Psi>\\<^sub>F\"\n  and   \"A\\<^sub>F \\<sharp>* xvec \\<Longrightarrow> xvec \\<sharp>* \\<Psi>\\<^sub>F\"", "lemma insertAssertionSimps[simp]:\n  fixes A\\<^sub>F :: \"name list\"\n  and   \\<Psi>\\<^sub>F :: 'b\n  and   \\<Psi>  :: 'b\n  \n  assumes \"A\\<^sub>F \\<sharp>* \\<Psi>\"\n\n  shows \"insertAssertion (\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>) \\<Psi> = \\<langle>A\\<^sub>F, \\<Psi> \\<otimes> \\<Psi>\\<^sub>F\\<rangle>\"", "lemma mergeFrameSimps[simp]:\n  fixes A\\<^sub>F :: \"name list\"\n  and   \\<Psi>\\<^sub>F :: 'b\n  and   \\<Psi>  :: 'b\n\n  assumes \"A\\<^sub>F \\<sharp>* \\<Psi>\"\n\n  shows \"(\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>) \\<otimes>\\<^sub>F \\<langle>\\<epsilon>, \\<Psi>\\<rangle> = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<rangle>\"", "lemma mergeFrames[simp]:\n  fixes A\\<^sub>F  :: \"name list\"\n  and   \\<Psi>\\<^sub>F :: 'b\n  and   A\\<^sub>G  :: \"name list\"\n  and   \\<Psi>\\<^sub>G :: 'b\n\n  assumes \"A\\<^sub>F \\<sharp>* A\\<^sub>G\"\n  and     \"A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G\"\n  and     \"A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\"\n\n  shows \"(\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>) \\<otimes>\\<^sub>F (\\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle>) = (\\<langle>(A\\<^sub>F@A\\<^sub>G), \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G\\<rangle>)\"", "lemma frameImpResFreshLeft:\n  fixes F :: \"'b frame\"\n  and   x :: name\n  \n  assumes \"x \\<sharp> F\"\n\n  shows \"\\<lparr>\\<nu>x\\<rparr>F \\<hookrightarrow>\\<^sub>F F\"", "lemma frameImpResFreshRight:\n  fixes F :: \"'b frame\"\n  and   x :: name\n  \n  assumes \"x \\<sharp> F\"\n\n  shows \"F \\<hookrightarrow>\\<^sub>F \\<lparr>\\<nu>x\\<rparr>F\"", "lemma frameResFresh:\n  fixes F :: \"'b frame\"\n  and   x :: name\n  \n  assumes \"x \\<sharp> F\"\n\n  shows \"\\<lparr>\\<nu>x\\<rparr>F \\<simeq>\\<^sub>F F\"", "lemma frameImpResPres:\n  fixes F :: \"'b frame\"\n  and   G :: \"'b frame\"\n  and   x :: name\n  \n  assumes \"F \\<hookrightarrow>\\<^sub>F G\"\n\n  shows \"\\<lparr>\\<nu>x\\<rparr>F \\<hookrightarrow>\\<^sub>F \\<lparr>\\<nu>x\\<rparr>G\"", "lemma frameResPres:\n  fixes F :: \"'b frame\"\n  and   G :: \"'b frame\"\n  and   x :: name\n  \n  assumes \"F \\<simeq>\\<^sub>F G\"\n\n  shows \"\\<lparr>\\<nu>x\\<rparr>F \\<simeq>\\<^sub>F \\<lparr>\\<nu>x\\<rparr>G\"", "lemma frameImpResComm:\n  fixes x :: name\n  and   y :: name\n  and   F :: \"'b frame\"\n\n  shows \"\\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>F) \\<hookrightarrow>\\<^sub>F \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>F)\"", "lemma frameResComm:\n  fixes x :: name\n  and   y :: name\n  and   F :: \"'b frame\"\n\n  shows \"\\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>F) \\<simeq>\\<^sub>F \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>F)\"", "lemma frameImpResCommLeft':\n  fixes x    :: name\n  and   xvec :: \"name list\"\n  and   F    :: \"'b frame\"\n\n  shows \"\\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>*xvec\\<rparr>F) \\<hookrightarrow>\\<^sub>F \\<lparr>\\<nu>*xvec\\<rparr>(\\<lparr>\\<nu>x\\<rparr>F)\"", "lemma frameImpResCommRight':\n  fixes x    :: name\n  and   xvec :: \"name list\"\n  and   F    :: \"'b frame\"\n\n  shows \"\\<lparr>\\<nu>*xvec\\<rparr>(\\<lparr>\\<nu>x\\<rparr>F) \\<hookrightarrow>\\<^sub>F \\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>*xvec\\<rparr>F)\"", "lemma frameResComm':\n  fixes x    :: name\n  and   xvec :: \"name list\"\n  and   F    :: \"'b frame\"\n\n  shows \"\\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>*xvec\\<rparr>F) \\<simeq>\\<^sub>F \\<lparr>\\<nu>*xvec\\<rparr>(\\<lparr>\\<nu>x\\<rparr>F)\"", "lemma frameImpChainComm:\n  fixes xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   F    :: \"'b frame\"\n\n  shows \"\\<lparr>\\<nu>*xvec\\<rparr>(\\<lparr>\\<nu>*yvec\\<rparr>F) \\<hookrightarrow>\\<^sub>F \\<lparr>\\<nu>*yvec\\<rparr>(\\<lparr>\\<nu>*xvec\\<rparr>F)\"", "lemma frameResChainComm:\n  fixes xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   F    :: \"'b frame\"\n\n  shows \"\\<lparr>\\<nu>*xvec\\<rparr>(\\<lparr>\\<nu>*yvec\\<rparr>F) \\<simeq>\\<^sub>F \\<lparr>\\<nu>*yvec\\<rparr>(\\<lparr>\\<nu>*xvec\\<rparr>F)\"", "lemma frameImpNilStatEq[simp]:\n  fixes \\<Psi>  :: 'b\n  and   \\<Psi>' :: 'b\n\n  shows \"(\\<langle>\\<epsilon>, \\<Psi>\\<rangle> \\<hookrightarrow>\\<^sub>F \\<langle>\\<epsilon>, \\<Psi>'\\<rangle>) = (\\<Psi> \\<hookrightarrow> \\<Psi>')\"", "lemma frameNilStatEq[simp]:\n  fixes \\<Psi>  :: 'b\n  and   \\<Psi>' :: 'b\n\n  shows \"(\\<langle>\\<epsilon>, \\<Psi>\\<rangle> \\<simeq>\\<^sub>F \\<langle>\\<epsilon>, \\<Psi>'\\<rangle>) = (\\<Psi> \\<simeq> \\<Psi>')\"", "lemma extractFrameChainStatImp:\n  fixes xvec :: \"name list\"\n  and   P    :: \"('a, 'b, 'c) psi\"\n\n  shows \"extractFrame(\\<lparr>\\<nu>*xvec\\<rparr>P) \\<hookrightarrow>\\<^sub>F \\<lparr>\\<nu>*xvec\\<rparr>(extractFrame P)\"", "lemma extractFrameChainStatEq:\n  fixes xvec :: \"name list\"\n  and   P    :: \"('a, 'b, 'c) psi\"\n\n  shows \"extractFrame(\\<lparr>\\<nu>*xvec\\<rparr>P) \\<simeq>\\<^sub>F \\<lparr>\\<nu>*xvec\\<rparr>(extractFrame P)\"", "lemma insertAssertionExtractFrameFreshImp:\n  fixes xvec :: \"name list\"\n  and   \\<Psi>   :: 'b\n  and   P    :: \"('a, 'b, 'c) psi\"\n\n  assumes \"xvec \\<sharp>* \\<Psi>\"\n\n  shows \"insertAssertion(extractFrame(\\<lparr>\\<nu>*xvec\\<rparr>P)) \\<Psi> \\<hookrightarrow>\\<^sub>F \\<lparr>\\<nu>*xvec\\<rparr>(insertAssertion (extractFrame P) \\<Psi>)\"", "lemma insertAssertionExtractFrameFresh:\n  fixes xvec :: \"name list\"\n  and   \\<Psi>   :: 'b\n  and   P    :: \"('a, 'b, 'c) psi\"\n\n  assumes \"xvec \\<sharp>* \\<Psi>\"\n\n  shows \"insertAssertion(extractFrame(\\<lparr>\\<nu>*xvec\\<rparr>P)) \\<Psi> \\<simeq>\\<^sub>F \\<lparr>\\<nu>*xvec\\<rparr>(insertAssertion (extractFrame P) \\<Psi>)\"", "lemma frameImpResChainPres:\n  fixes F    :: \"'b frame\"\n  and   G    :: \"'b frame\"\n  and   xvec :: \"name list\"\n\n  assumes \"F \\<hookrightarrow>\\<^sub>F G\"\n\n  shows \"\\<lparr>\\<nu>*xvec\\<rparr>F \\<hookrightarrow>\\<^sub>F \\<lparr>\\<nu>*xvec\\<rparr>G\"", "lemma frameResChainPres:\n  fixes F    :: \"'b frame\"\n  and   G    :: \"'b frame\"\n  and   xvec :: \"name list\"\n\n  assumes \"F \\<simeq>\\<^sub>F G\"\n\n  shows \"\\<lparr>\\<nu>*xvec\\<rparr>F \\<simeq>\\<^sub>F \\<lparr>\\<nu>*xvec\\<rparr>G\"", "lemma insertAssertionE:\n  fixes F  :: \"('b::fs_name) frame\"\n  and   \\<Psi>  :: 'b\n  and   \\<Psi>' :: 'b\n  and   A\\<^sub>F :: \"name list\"\n\n  assumes \"insertAssertion F \\<Psi> = \\<langle>A\\<^sub>F, \\<Psi>'\\<rangle>\"\n  and     \"A\\<^sub>F \\<sharp>* F\"\n  and     \"A\\<^sub>F \\<sharp>* \\<Psi>\"\n  and     \"distinct A\\<^sub>F\"\n\n  obtains \\<Psi>\\<^sub>F where \"F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\" and \"\\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F\"", "lemma mergeFrameE:\n  fixes F   :: \"'b frame\"\n  and   G   :: \"'b frame\"\n  and   A\\<^sub>F\\<^sub>G :: \"name list\"\n  and   \\<Psi>\\<^sub>F\\<^sub>G :: 'b\n\n  assumes \"mergeFrame F G = \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>\"\n  and     \"distinct A\\<^sub>F\\<^sub>G\"\n  and     \"A\\<^sub>F\\<^sub>G \\<sharp>* F\"\n  and     \"A\\<^sub>F\\<^sub>G \\<sharp>* G\"\n\n  obtains A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G \\<Psi>\\<^sub>G where \"A\\<^sub>F\\<^sub>G = A\\<^sub>F@A\\<^sub>G\" and \"\\<Psi>\\<^sub>F\\<^sub>G = \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G\" and \"F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\" and \"G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle>\" and \"A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G\" and \"A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\"", "lemma mergeFrameRes1[simp]:\n  fixes A\\<^sub>F :: \"name list\"\n  and   \\<Psi>\\<^sub>F :: 'b\n  and   x   :: name\n  and   A\\<^sub>G :: \"name list\"\n  and   \\<Psi>\\<^sub>G :: 'b\n  \n  assumes \"A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G\"\n  and     \"A\\<^sub>F \\<sharp>* A\\<^sub>G\"\n  and     \"x \\<sharp> A\\<^sub>F\"\n  and     \"x \\<sharp> \\<Psi>\\<^sub>F\"\n  and     \"A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\"\n  \n  shows \"(\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>) \\<otimes>\\<^sub>F (\\<lparr>\\<nu>x\\<rparr>(\\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle>)) = (\\<langle>(A\\<^sub>F@x#A\\<^sub>G), \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G\\<rangle>)\"", "lemma mergeFrameRes2[simp]:\n  fixes A\\<^sub>F :: \"name list\"\n  and   \\<Psi>\\<^sub>F :: 'b\n  and   x   :: name\n  and   A\\<^sub>G :: \"name list\"\n  and   \\<Psi>\\<^sub>G :: 'b\n  \n  assumes \"A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G\"\n  and     \"A\\<^sub>G \\<sharp>* A\\<^sub>F\"\n  and     \"x \\<sharp> A\\<^sub>F\"\n  and     \"x \\<sharp> \\<Psi>\\<^sub>F\"\n  and     \"A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\"\n  \n  shows \"(\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>) \\<otimes>\\<^sub>F (\\<lparr>\\<nu>x\\<rparr>(\\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle>)) = (\\<langle>(A\\<^sub>F@x#A\\<^sub>G), \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G\\<rangle>)\"", "lemma insertAssertionResChain[simp]:\n  fixes xvec :: \"name list\"\n  and   F    :: \"'b frame\"\n  and   \\<Psi>   :: 'b\n\n  assumes \"xvec \\<sharp>* \\<Psi>\"\n\n  shows \"insertAssertion (\\<lparr>\\<nu>*xvec\\<rparr>F) \\<Psi> = \\<lparr>\\<nu>*xvec\\<rparr>(insertAssertion F \\<Psi>)\"", "lemma extractFrameResChain[simp]:\n  fixes xvec :: \"name list\"\n  and   P    :: \"('a, 'b, 'c) psi\"\n\n  shows \"extractFrame(\\<lparr>\\<nu>*xvec\\<rparr>P) = \\<lparr>\\<nu>*xvec\\<rparr>(extractFrame P)\"", "lemma frameResFreshChain:\n  fixes xvec :: \"name list\"\n  and   F    :: \"'b frame\"\n\n  assumes \"xvec \\<sharp>* F\"\n\n  shows \"\\<lparr>\\<nu>*xvec\\<rparr>F \\<simeq>\\<^sub>F F\"", "lemma compositionSym:\n  fixes \\<Psi>   :: 'b\n  and   \\<Psi>'  :: 'b\n  and   \\<Psi>'' :: 'b\n\n  assumes \"\\<Psi> \\<simeq> \\<Psi>'\"\n\n  shows \"\\<Psi>'' \\<otimes> \\<Psi> \\<simeq> \\<Psi>'' \\<otimes> \\<Psi>'\"", "lemma Composition':\n  fixes \\<Psi>    :: 'b\n  and   \\<Psi>'   :: 'b\n  and   \\<Psi>''  :: 'b\n  and   \\<Psi>''' :: 'b\n\n  assumes \"\\<Psi> \\<simeq> \\<Psi>'\"\n  and     \"\\<Psi>'' \\<simeq> \\<Psi>'''\"\n  \n  shows \"\\<Psi> \\<otimes> \\<Psi>'' \\<simeq> \\<Psi>' \\<otimes> \\<Psi>'''\"", "lemma composition':\n  fixes \\<Psi>    :: 'b\n  and   \\<Psi>'   :: 'b\n  and   \\<Psi>''  :: 'b\n  and   \\<Psi>''' :: 'b\n\n  assumes \"\\<Psi> \\<simeq> \\<Psi>'\"\n\n  shows \"(\\<Psi> \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>''' \\<simeq> (\\<Psi>' \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>'''\"", "lemma associativitySym:\n  fixes \\<Psi>   :: 'b\n  and   \\<Psi>'  :: 'b\n  and   \\<Psi>'' :: 'b\n  \n  shows \"(\\<Psi> \\<otimes> \\<Psi>') \\<otimes> \\<Psi>'' \\<simeq> (\\<Psi> \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>'\"", "lemma frameIntAssociativity:\n  fixes A\\<^sub>F  :: \"name list\"\n  and   \\<Psi>   :: 'b\n  and   \\<Psi>'  :: 'b\n  and   \\<Psi>'' :: 'b\n\n  shows \"\\<langle>A\\<^sub>F, (\\<Psi> \\<otimes> \\<Psi>') \\<otimes> \\<Psi>''\\<rangle> \\<simeq>\\<^sub>F \\<langle>A\\<^sub>F, \\<Psi> \\<otimes> (\\<Psi>' \\<otimes> \\<Psi>'')\\<rangle>\"", "lemma frameIntCommutativity:\n  fixes A\\<^sub>F  :: \"name list\"\n  and   \\<Psi>   :: 'b\n  and   \\<Psi>'  :: 'b\n\n  shows \"\\<langle>A\\<^sub>F, \\<Psi> \\<otimes> \\<Psi>'\\<rangle> \\<simeq>\\<^sub>F \\<langle>A\\<^sub>F, \\<Psi>' \\<otimes> \\<Psi>\\<rangle>\"", "lemma frameIntIdentity:\n  fixes A\\<^sub>F :: \"name list\"\n  and   \\<Psi>\\<^sub>F :: 'b \n\n  shows \"\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F \\<otimes> SBottom\\<rangle> \\<simeq>\\<^sub>F \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\"", "lemma frameIntComposition:\n  fixes \\<Psi>  :: 'b\n  and   \\<Psi>' :: 'b\n  and   A\\<^sub>F :: \"name list\"\n  and   \\<Psi>\\<^sub>F :: 'b\n\n  assumes \"\\<Psi> \\<simeq> \\<Psi>'\"\n\n  shows \"\\<langle>A\\<^sub>F, \\<Psi> \\<otimes> \\<Psi>\\<^sub>F\\<rangle> \\<simeq>\\<^sub>F \\<langle>A\\<^sub>F, \\<Psi>' \\<otimes> \\<Psi>\\<^sub>F\\<rangle>\"", "lemma frameIntCompositionSym:\n  fixes \\<Psi>  :: 'b\n  and   \\<Psi>' :: 'b\n  and   A\\<^sub>F :: \"name list\"\n  and   \\<Psi>\\<^sub>F :: 'b\n\n  assumes \"\\<Psi> \\<simeq> \\<Psi>'\"\n\n  shows \"\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<rangle> \\<simeq>\\<^sub>F \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F \\<otimes> \\<Psi>'\\<rangle>\"", "lemma frameCommutativity:\n  fixes F :: \"'b frame\"\n  and   G :: \"'b frame\"\n\n  shows \"F \\<otimes>\\<^sub>F G \\<simeq>\\<^sub>F G \\<otimes>\\<^sub>F F\"", "lemma frameScopeExt:\n  fixes x :: name\n  and   F :: \"'b frame\"\n  and   G :: \"'b frame\"\n\n  assumes \"x \\<sharp> F\"\n\n  shows \"\\<lparr>\\<nu>x\\<rparr>(F \\<otimes>\\<^sub>F G) \\<simeq>\\<^sub>F F \\<otimes>\\<^sub>F (\\<lparr>\\<nu>x\\<rparr>G)\"", "lemma insertDoubleAssertionStatEq:\n  fixes F  :: \"'b frame\"\n  and   \\<Psi>  :: 'b\n  and   \\<Psi>' :: 'b\n\n  shows \"insertAssertion(insertAssertion F \\<Psi>) \\<Psi>' \\<simeq>\\<^sub>F (insertAssertion F) (\\<Psi> \\<otimes> \\<Psi>')\"", "lemma guardedStatEq:\n  fixes P  :: \"('a, 'b, 'c) psi\"\n  and   I  :: \"('a, 'b, 'c) input\"\n  and   C  :: \"('a, 'b, 'c) psiCase\"\n  and   A\\<^sub>P :: \"name list\"\n  and   \\<Psi>\\<^sub>P :: 'b\n\n  shows \"\\<lbrakk>guarded P; extractFrame P = \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk> \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and> supp \\<Psi>\\<^sub>P = ({}::name set)\"\n  and   \"\\<lbrakk>guarded' I; extractFrame' I = \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk> \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and> supp \\<Psi>\\<^sub>P = ({}::name set)\"\n  and   \"\\<lbrakk>guarded'' C; extractFrame'' C = \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk> \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and> supp \\<Psi>\\<^sub>P = ({}::name set)\""], "translations": [["", "lemma permLength[simp]:\n  fixes p    :: \"name prm\"\n  and   xvec :: \"'a::pt_name list\"\n\n  shows \"length(p \\<bullet> xvec) = length xvec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (p \\<bullet> xvec) = length xvec", "by(induct xvec) auto"], ["", "nominal_datatype 'assertion frame =\n    FAssert \"'assertion::fs_name\"\n  | FRes \"\\<guillemotleft>name\\<guillemotright> ('assertion frame)\" (\"\\<lparr>\\<nu>_\\<rparr>_\" [80, 80] 80)"], ["", "primrec frameResChain :: \"name list \\<Rightarrow> ('a::fs_name) frame \\<Rightarrow> 'a frame\" where\n  base: \"frameResChain [] F = F\"\n| step: \"frameResChain (x#xs) F = \\<lparr>\\<nu>x\\<rparr>(frameResChain xs F)\""], ["", "notation frameResChain (\"\\<lparr>\\<nu>*_\\<rparr>_\" [80, 80] 80)"], ["", "notation FAssert  (\"\\<langle>\\<epsilon>, _\\<rangle>\" [80] 80)"], ["", "abbreviation FAssertJudge (\"\\<langle>_, _\\<rangle>\" [80, 80] 80) where \"\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<equiv> frameResChain A\\<^sub>F (FAssert \\<Psi>\\<^sub>F)\""], ["", "lemma frameResChainEqvt[eqvt]:\n  fixes perm :: \"name prm\"\n  and   lst  :: \"name list\"\n  and   F    :: \"'a::fs_name frame\"\n  \n  shows \"perm \\<bullet> (\\<lparr>\\<nu>*xvec\\<rparr>F) = \\<lparr>\\<nu>*(perm \\<bullet> xvec)\\<rparr>(perm \\<bullet> F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. perm \\<bullet> \\<lparr>\\<nu>*xvec\\<rparr>F =\n    \\<lparr>\\<nu>*perm \\<bullet> xvec\\<rparr>perm \\<bullet> F", "by(induct_tac xvec, auto)"], ["", "lemma frameResChainFresh: \n  fixes x    :: name\n  and   xvec :: \"name list\"\n  and   F    :: \"'a::fs_name frame\"\n\n  shows \"x \\<sharp> \\<lparr>\\<nu>*xvec\\<rparr>F = (x \\<in> set xvec \\<or> x \\<sharp> F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> \\<lparr>\\<nu>*xvec\\<rparr>F = (x mem xvec \\<or> x \\<sharp> F)", "by (induct xvec) (simp_all add: abs_fresh)"], ["", "lemma frameResChainFreshSet: \n  fixes Xs   :: \"name set\"\n  and   xvec :: \"name list\"\n  and   F    :: \"'a::fs_name frame\"\n\n  shows \"Xs \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>F) = (\\<forall>x\\<in>Xs. x \\<in> set xvec \\<or> x \\<sharp> F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Xs \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>F) =\n    (\\<forall>x\\<in>Xs. x mem xvec \\<or> x \\<sharp> F)", "by (simp add: fresh_star_def frameResChainFresh)"], ["", "lemma frameChainAlpha:\n  fixes p    :: \"name prm\"\n  and   xvec :: \"name list\"\n  and   F    :: \"'a::fs_name frame\"\n\n  assumes xvecFreshF: \"(p \\<bullet> xvec) \\<sharp>* F\"\n  and     S: \"set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\"\n\n  shows \"\\<lparr>\\<nu>*xvec\\<rparr>F = \\<lparr>\\<nu>*(p \\<bullet> xvec)\\<rparr>(p \\<bullet> F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>*xvec\\<rparr>F =\n    \\<lparr>\\<nu>*p \\<bullet> xvec\\<rparr>p \\<bullet> F", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>*xvec\\<rparr>F =\n    \\<lparr>\\<nu>*p \\<bullet> xvec\\<rparr>p \\<bullet> F", "note pt_name_inst at_name_inst S"], ["proof (state)\nthis:\n  pt TYPE(?'x) TYPE(name)\n  at TYPE(name)\n  set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>*xvec\\<rparr>F =\n    \\<lparr>\\<nu>*p \\<bullet> xvec\\<rparr>p \\<bullet> F", "moreover"], ["proof (state)\nthis:\n  pt TYPE(?'x) TYPE(name)\n  at TYPE(name)\n  set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>*xvec\\<rparr>F =\n    \\<lparr>\\<nu>*p \\<bullet> xvec\\<rparr>p \\<bullet> F", "have \"set xvec \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xvec \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>F)", "by (simp add: frameResChainFreshSet)"], ["proof (state)\nthis:\n  set xvec \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>F)\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>*xvec\\<rparr>F =\n    \\<lparr>\\<nu>*p \\<bullet> xvec\\<rparr>p \\<bullet> F", "moreover"], ["proof (state)\nthis:\n  set xvec \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>F)\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>*xvec\\<rparr>F =\n    \\<lparr>\\<nu>*p \\<bullet> xvec\\<rparr>p \\<bullet> F", "from xvecFreshF"], ["proof (chain)\npicking this:\n  (p \\<bullet> xvec) \\<sharp>* F", "have \"set (p \\<bullet> xvec) \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>F)\""], ["proof (prove)\nusing this:\n  (p \\<bullet> xvec) \\<sharp>* F\n\ngoal (1 subgoal):\n 1. set (p \\<bullet> xvec) \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>F)", "by (simp add: frameResChainFreshSet) (simp add: fresh_star_def)"], ["proof (state)\nthis:\n  set (p \\<bullet> xvec) \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>F)\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>*xvec\\<rparr>F =\n    \\<lparr>\\<nu>*p \\<bullet> xvec\\<rparr>p \\<bullet> F", "ultimately"], ["proof (chain)\npicking this:\n  pt TYPE(?'x) TYPE(name)\n  at TYPE(name)\n  set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\n  set xvec \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>F)\n  set (p \\<bullet> xvec) \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>F)", "have \"\\<lparr>\\<nu>*xvec\\<rparr>F = p \\<bullet> (\\<lparr>\\<nu>*xvec\\<rparr>F)\""], ["proof (prove)\nusing this:\n  pt TYPE(?'x) TYPE(name)\n  at TYPE(name)\n  set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec)\n  set xvec \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>F)\n  set (p \\<bullet> xvec) \\<sharp>* (\\<lparr>\\<nu>*xvec\\<rparr>F)\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>*xvec\\<rparr>F = p \\<bullet> \\<lparr>\\<nu>*xvec\\<rparr>F", "by (rule_tac pt_freshs_freshs [symmetric])"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>*xvec\\<rparr>F = p \\<bullet> \\<lparr>\\<nu>*xvec\\<rparr>F\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>*xvec\\<rparr>F =\n    \\<lparr>\\<nu>*p \\<bullet> xvec\\<rparr>p \\<bullet> F", "then"], ["proof (chain)\npicking this:\n  \\<lparr>\\<nu>*xvec\\<rparr>F = p \\<bullet> \\<lparr>\\<nu>*xvec\\<rparr>F", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lparr>\\<nu>*xvec\\<rparr>F = p \\<bullet> \\<lparr>\\<nu>*xvec\\<rparr>F\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>*xvec\\<rparr>F =\n    \\<lparr>\\<nu>*p \\<bullet> xvec\\<rparr>p \\<bullet> F", "by(simp add: eqvts)"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>*xvec\\<rparr>F =\n  \\<lparr>\\<nu>*p \\<bullet> xvec\\<rparr>p \\<bullet> F\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma frameChainAlpha':\n  fixes p    :: \"name prm\"\n  and   A\\<^sub>P   :: \"name list\"\n  and   \\<Psi>\\<^sub>P  :: \"'a::fs_name\"\n\n  assumes \"(p \\<bullet> A\\<^sub>P) \\<sharp>* \\<Psi>\\<^sub>P\"\n  and     S: \"set p \\<subseteq> set A\\<^sub>P \\<times> set (p \\<bullet> A\\<^sub>P)\"\n\n  shows \"\\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle> = \\<langle>(p \\<bullet> A\\<^sub>P), p \\<bullet> \\<Psi>\\<^sub>P\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle> =\n    \\<langle>p \\<bullet> A\\<^sub>P, p \\<bullet> \\<Psi>\\<^sub>P\\<rangle>", "using assms"], ["proof (prove)\nusing this:\n  (p \\<bullet> A\\<^sub>P) \\<sharp>* \\<Psi>\\<^sub>P\n  set p \\<subseteq> set A\\<^sub>P \\<times> set (p \\<bullet> A\\<^sub>P)\n\ngoal (1 subgoal):\n 1. \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle> =\n    \\<langle>p \\<bullet> A\\<^sub>P, p \\<bullet> \\<Psi>\\<^sub>P\\<rangle>", "by(subst frameChainAlpha) (auto simp add: fresh_star_def)"], ["", "lemma alphaFrameRes:\n  fixes x :: name\n  and   F :: \"'a::fs_name frame\"\n  and   y :: name\n\n  assumes \"y \\<sharp> F\"\n\n  shows \"\\<lparr>\\<nu>x\\<rparr>F = \\<lparr>\\<nu>y\\<rparr>([(x, y)] \\<bullet> F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>F = \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet> F", "proof(cases \"x = y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    \\<lparr>\\<nu>x\\<rparr>F = \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet> F\n 2. x \\<noteq> y \\<Longrightarrow>\n    \\<lparr>\\<nu>x\\<rparr>F = \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet> F", "assume \"x=y\""], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    \\<lparr>\\<nu>x\\<rparr>F = \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet> F\n 2. x \\<noteq> y \\<Longrightarrow>\n    \\<lparr>\\<nu>x\\<rparr>F = \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet> F", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = y\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>F = \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet> F", "by simp"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>F = \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet> F\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    \\<lparr>\\<nu>x\\<rparr>F = \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet> F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    \\<lparr>\\<nu>x\\<rparr>F = \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet> F", "assume \"x \\<noteq> y\""], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    \\<lparr>\\<nu>x\\<rparr>F = \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet> F", "with \\<open>y \\<sharp> F\\<close>"], ["proof (chain)\npicking this:\n  y \\<sharp> F\n  x \\<noteq> y", "show ?thesis"], ["proof (prove)\nusing this:\n  y \\<sharp> F\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>F = \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet> F", "by(perm_simp add: frame.inject alpha calc_atm fresh_left)"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>F = \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet> F\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma frameChainAppend:\n  fixes xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   F    :: \"'a::fs_name frame\"\n  \n  shows \"\\<lparr>\\<nu>*(xvec@yvec)\\<rparr>F = \\<lparr>\\<nu>*xvec\\<rparr>(\\<lparr>\\<nu>*yvec\\<rparr>F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>*(xvec @ yvec)\\<rparr>F =\n    \\<lparr>\\<nu>*xvec\\<rparr>\\<lparr>\\<nu>*yvec\\<rparr>F", "by(induct xvec) auto"], ["", "lemma frameChainEqLength:\n  fixes xvec :: \"name list\"\n  and   \\<Psi>    :: \"'a::fs_name\"\n  and   yvec :: \"name list\"\n  and   \\<Psi>'   :: \"'a::fs_name\"\n\n  assumes \"\\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\"\n\n  shows \"length xvec = length yvec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xvec = length yvec", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length xvec = length yvec", "obtain n where \"n = length xvec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n. n = length xvec \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n = length xvec\n\ngoal (1 subgoal):\n 1. length xvec = length yvec", "with assms"], ["proof (chain)\npicking this:\n  \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\n  n = length xvec", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\n  n = length xvec\n\ngoal (1 subgoal):\n 1. length xvec = length yvec", "proof(induct n arbitrary: xvec yvec \\<Psi> \\<Psi>')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                \\<langle>yvec, \\<Psi>'\\<rangle>;\n        0 = length xvec\\<rbrakk>\n       \\<Longrightarrow> length xvec = length yvec\n 2. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> length xvec = length yvec;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> length xvec = length yvec", "case(0 xvec yvec \\<Psi> \\<Psi>')"], ["proof (state)\nthis:\n  \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\n  0 = length xvec\n\ngoal (2 subgoals):\n 1. \\<And>xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                \\<langle>yvec, \\<Psi>'\\<rangle>;\n        0 = length xvec\\<rbrakk>\n       \\<Longrightarrow> length xvec = length yvec\n 2. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> length xvec = length yvec;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> length xvec = length yvec", "from \\<open>0 = length xvec\\<close>"], ["proof (chain)\npicking this:\n  0 = length xvec", "have \"xvec = []\""], ["proof (prove)\nusing this:\n  0 = length xvec\n\ngoal (1 subgoal):\n 1. xvec = []", "by auto"], ["proof (state)\nthis:\n  xvec = []\n\ngoal (2 subgoals):\n 1. \\<And>xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                \\<langle>yvec, \\<Psi>'\\<rangle>;\n        0 = length xvec\\<rbrakk>\n       \\<Longrightarrow> length xvec = length yvec\n 2. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> length xvec = length yvec;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> length xvec = length yvec", "moreover"], ["proof (state)\nthis:\n  xvec = []\n\ngoal (2 subgoals):\n 1. \\<And>xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                \\<langle>yvec, \\<Psi>'\\<rangle>;\n        0 = length xvec\\<rbrakk>\n       \\<Longrightarrow> length xvec = length yvec\n 2. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> length xvec = length yvec;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> length xvec = length yvec", "with \\<open>\\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\\<close>"], ["proof (chain)\npicking this:\n  \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\n  xvec = []", "have \"yvec = []\""], ["proof (prove)\nusing this:\n  \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\n  xvec = []\n\ngoal (1 subgoal):\n 1. yvec = []", "by(case_tac yvec) auto"], ["proof (state)\nthis:\n  yvec = []\n\ngoal (2 subgoals):\n 1. \\<And>xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                \\<langle>yvec, \\<Psi>'\\<rangle>;\n        0 = length xvec\\<rbrakk>\n       \\<Longrightarrow> length xvec = length yvec\n 2. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> length xvec = length yvec;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> length xvec = length yvec", "ultimately"], ["proof (chain)\npicking this:\n  xvec = []\n  yvec = []", "show ?case"], ["proof (prove)\nusing this:\n  xvec = []\n  yvec = []\n\ngoal (1 subgoal):\n 1. length xvec = length yvec", "by simp"], ["proof (state)\nthis:\n  length xvec = length yvec\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> length xvec = length yvec;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> length xvec = length yvec", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> length xvec = length yvec;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> length xvec = length yvec", "case(Suc n xvec yvec \\<Psi> \\<Psi>')"], ["proof (state)\nthis:\n  \\<lbrakk>\\<langle>?xvec, ?\\<Psi>\\<rangle> =\n           \\<langle>?yvec, ?\\<Psi>'\\<rangle>;\n   n = length ?xvec\\<rbrakk>\n  \\<Longrightarrow> length ?xvec = length ?yvec\n  \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\n  Suc n = length xvec\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> length xvec = length yvec;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> length xvec = length yvec", "from \\<open>Suc n = length xvec\\<close>"], ["proof (chain)\npicking this:\n  Suc n = length xvec", "obtain x xvec' where \"xvec = x#xvec'\" and \"length xvec' = n\""], ["proof (prove)\nusing this:\n  Suc n = length xvec\n\ngoal (1 subgoal):\n 1. (\\<And>x xvec'.\n        \\<lbrakk>xvec = x # xvec'; length xvec' = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(case_tac xvec) auto"], ["proof (state)\nthis:\n  xvec = x # xvec'\n  length xvec' = n\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> length xvec = length yvec;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> length xvec = length yvec", "from \\<open>\\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\\<close> \\<open>xvec = x # xvec'\\<close>"], ["proof (chain)\npicking this:\n  \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\n  xvec = x # xvec'", "obtain y yvec' where \"\\<langle>(x#xvec'), \\<Psi>\\<rangle> = \\<langle>(y#yvec'), \\<Psi>'\\<rangle>\"\n      and \"yvec = y#yvec'\""], ["proof (prove)\nusing this:\n  \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\n  xvec = x # xvec'\n\ngoal (1 subgoal):\n 1. (\\<And>y yvec'.\n        \\<lbrakk>\\<langle>(x # xvec'), \\<Psi>\\<rangle> =\n                 \\<langle>(y # yvec'), \\<Psi>'\\<rangle>;\n         yvec = y # yvec'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(case_tac yvec) auto"], ["proof (state)\nthis:\n  \\<langle>(x # xvec'), \\<Psi>\\<rangle> =\n  \\<langle>(y # yvec'), \\<Psi>'\\<rangle>\n  yvec = y # yvec'\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> length xvec = length yvec;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> length xvec = length yvec", "hence EQ: \"\\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>*xvec'\\<rparr>(FAssert \\<Psi>) = \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>*yvec'\\<rparr>(FAssert \\<Psi>')\""], ["proof (prove)\nusing this:\n  \\<langle>(x # xvec'), \\<Psi>\\<rangle> =\n  \\<langle>(y # yvec'), \\<Psi>'\\<rangle>\n  yvec = y # yvec'\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>\\<langle>xvec', \\<Psi>\\<rangle> =\n    \\<lparr>\\<nu>y\\<rparr>\\<langle>yvec', \\<Psi>'\\<rangle>", "by simp"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>\\<langle>xvec', \\<Psi>\\<rangle> =\n  \\<lparr>\\<nu>y\\<rparr>\\<langle>yvec', \\<Psi>'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> length xvec = length yvec;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> length xvec = length yvec", "have IH: \"\\<And>xvec yvec \\<Psi> \\<Psi>'. \\<lbrakk>\\<langle>xvec, (\\<Psi>::'a)\\<rangle> = \\<langle>yvec, (\\<Psi>'::'a)\\<rangle>; n = length xvec\\<rbrakk> \\<Longrightarrow> length xvec = length yvec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                \\<langle>yvec, \\<Psi>'\\<rangle>;\n        n = length xvec\\<rbrakk>\n       \\<Longrightarrow> length xvec = length yvec", "by fact"], ["proof (state)\nthis:\n  \\<lbrakk>\\<langle>?xvec, ?\\<Psi>\\<rangle> =\n           \\<langle>?yvec, ?\\<Psi>'\\<rangle>;\n   n = length ?xvec\\<rbrakk>\n  \\<Longrightarrow> length ?xvec = length ?yvec\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> length xvec = length yvec;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> length xvec = length yvec", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. length xvec = length yvec", "proof(case_tac \"x = y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> length xvec = length yvec\n 2. x \\<noteq> y \\<Longrightarrow> length xvec = length yvec", "assume \"x = y\""], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> length xvec = length yvec\n 2. x \\<noteq> y \\<Longrightarrow> length xvec = length yvec", "with EQ"], ["proof (chain)\npicking this:\n  \\<lparr>\\<nu>x\\<rparr>\\<langle>xvec', \\<Psi>\\<rangle> =\n  \\<lparr>\\<nu>y\\<rparr>\\<langle>yvec', \\<Psi>'\\<rangle>\n  x = y", "have \"\\<langle>xvec', \\<Psi>\\<rangle> = \\<langle>yvec', \\<Psi>'\\<rangle>\""], ["proof (prove)\nusing this:\n  \\<lparr>\\<nu>x\\<rparr>\\<langle>xvec', \\<Psi>\\<rangle> =\n  \\<lparr>\\<nu>y\\<rparr>\\<langle>yvec', \\<Psi>'\\<rangle>\n  x = y\n\ngoal (1 subgoal):\n 1. \\<langle>xvec', \\<Psi>\\<rangle> = \\<langle>yvec', \\<Psi>'\\<rangle>", "by(simp add: alpha frame.inject)"], ["proof (state)\nthis:\n  \\<langle>xvec', \\<Psi>\\<rangle> = \\<langle>yvec', \\<Psi>'\\<rangle>\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> length xvec = length yvec\n 2. x \\<noteq> y \\<Longrightarrow> length xvec = length yvec", "with IH \\<open>length xvec' = n\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<langle>?xvec, ?\\<Psi>\\<rangle> =\n           \\<langle>?yvec, ?\\<Psi>'\\<rangle>;\n   n = length ?xvec\\<rbrakk>\n  \\<Longrightarrow> length ?xvec = length ?yvec\n  length xvec' = n\n  \\<langle>xvec', \\<Psi>\\<rangle> = \\<langle>yvec', \\<Psi>'\\<rangle>", "have \"length xvec' = length yvec'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<langle>?xvec, ?\\<Psi>\\<rangle> =\n           \\<langle>?yvec, ?\\<Psi>'\\<rangle>;\n   n = length ?xvec\\<rbrakk>\n  \\<Longrightarrow> length ?xvec = length ?yvec\n  length xvec' = n\n  \\<langle>xvec', \\<Psi>\\<rangle> = \\<langle>yvec', \\<Psi>'\\<rangle>\n\ngoal (1 subgoal):\n 1. length xvec' = length yvec'", "by blast"], ["proof (state)\nthis:\n  length xvec' = length yvec'\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> length xvec = length yvec\n 2. x \\<noteq> y \\<Longrightarrow> length xvec = length yvec", "with \\<open>xvec = x#xvec'\\<close> \\<open>yvec=y#yvec'\\<close>"], ["proof (chain)\npicking this:\n  xvec = x # xvec'\n  yvec = y # yvec'\n  length xvec' = length yvec'", "show ?case"], ["proof (prove)\nusing this:\n  xvec = x # xvec'\n  yvec = y # yvec'\n  length xvec' = length yvec'\n\ngoal (1 subgoal):\n 1. length xvec = length yvec", "by simp"], ["proof (state)\nthis:\n  length xvec = length yvec\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> length xvec = length yvec", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> length xvec = length yvec", "assume \"x \\<noteq> y\""], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> length xvec = length yvec", "with EQ"], ["proof (chain)\npicking this:\n  \\<lparr>\\<nu>x\\<rparr>\\<langle>xvec', \\<Psi>\\<rangle> =\n  \\<lparr>\\<nu>y\\<rparr>\\<langle>yvec', \\<Psi>'\\<rangle>\n  x \\<noteq> y", "have \"\\<langle>xvec', \\<Psi>\\<rangle> = [(x, y)] \\<bullet> \\<langle>yvec', \\<Psi>'\\<rangle>\""], ["proof (prove)\nusing this:\n  \\<lparr>\\<nu>x\\<rparr>\\<langle>xvec', \\<Psi>\\<rangle> =\n  \\<lparr>\\<nu>y\\<rparr>\\<langle>yvec', \\<Psi>'\\<rangle>\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<langle>xvec', \\<Psi>\\<rangle> =\n    [(x, y)] \\<bullet> \\<langle>yvec', \\<Psi>'\\<rangle>", "by(simp add: alpha frame.inject)"], ["proof (state)\nthis:\n  \\<langle>xvec', \\<Psi>\\<rangle> =\n  [(x, y)] \\<bullet> \\<langle>yvec', \\<Psi>'\\<rangle>\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> length xvec = length yvec", "hence \"\\<langle>xvec', \\<Psi>\\<rangle> = \\<langle>([(x, y)] \\<bullet> yvec'), ([(x, y)] \\<bullet> \\<Psi>')\\<rangle>\""], ["proof (prove)\nusing this:\n  \\<langle>xvec', \\<Psi>\\<rangle> =\n  [(x, y)] \\<bullet> \\<langle>yvec', \\<Psi>'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>xvec', \\<Psi>\\<rangle> =\n    \\<langle>[(x, y)] \\<bullet> yvec', [(x, y)] \\<bullet> \\<Psi>'\\<rangle>", "by(simp add: eqvts)"], ["proof (state)\nthis:\n  \\<langle>xvec', \\<Psi>\\<rangle> =\n  \\<langle>[(x, y)] \\<bullet> yvec', [(x, y)] \\<bullet> \\<Psi>'\\<rangle>\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> length xvec = length yvec", "with IH \\<open>length xvec' = n\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<langle>?xvec, ?\\<Psi>\\<rangle> =\n           \\<langle>?yvec, ?\\<Psi>'\\<rangle>;\n   n = length ?xvec\\<rbrakk>\n  \\<Longrightarrow> length ?xvec = length ?yvec\n  length xvec' = n\n  \\<langle>xvec', \\<Psi>\\<rangle> =\n  \\<langle>[(x, y)] \\<bullet> yvec', [(x, y)] \\<bullet> \\<Psi>'\\<rangle>", "have \"length xvec' = length ([(x, y)] \\<bullet> yvec')\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<langle>?xvec, ?\\<Psi>\\<rangle> =\n           \\<langle>?yvec, ?\\<Psi>'\\<rangle>;\n   n = length ?xvec\\<rbrakk>\n  \\<Longrightarrow> length ?xvec = length ?yvec\n  length xvec' = n\n  \\<langle>xvec', \\<Psi>\\<rangle> =\n  \\<langle>[(x, y)] \\<bullet> yvec', [(x, y)] \\<bullet> \\<Psi>'\\<rangle>\n\ngoal (1 subgoal):\n 1. length xvec' = length ([(x, y)] \\<bullet> yvec')", "by blast"], ["proof (state)\nthis:\n  length xvec' = length ([(x, y)] \\<bullet> yvec')\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> length xvec = length yvec", "hence \"length xvec' = length yvec'\""], ["proof (prove)\nusing this:\n  length xvec' = length ([(x, y)] \\<bullet> yvec')\n\ngoal (1 subgoal):\n 1. length xvec' = length yvec'", "by simp"], ["proof (state)\nthis:\n  length xvec' = length yvec'\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> length xvec = length yvec", "with \\<open>xvec = x#xvec'\\<close> \\<open>yvec=y#yvec'\\<close>"], ["proof (chain)\npicking this:\n  xvec = x # xvec'\n  yvec = y # yvec'\n  length xvec' = length yvec'", "show ?case"], ["proof (prove)\nusing this:\n  xvec = x # xvec'\n  yvec = y # yvec'\n  length xvec' = length yvec'\n\ngoal (1 subgoal):\n 1. length xvec = length yvec", "by simp"], ["proof (state)\nthis:\n  length xvec = length yvec\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length xvec = length yvec\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length xvec = length yvec\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma frameEqFresh:\n  fixes F :: \"('a::fs_name) frame\"\n  and   G :: \"'a frame\"\n  and   x :: name\n  and   y :: name\n\n  assumes \"\\<lparr>\\<nu>x\\<rparr>F = \\<lparr>\\<nu>y\\<rparr>G\"\n  and     \"x \\<sharp> F\"\n  \n  shows \"y \\<sharp> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<sharp> G", "using assms"], ["proof (prove)\nusing this:\n  \\<lparr>\\<nu>x\\<rparr>F = \\<lparr>\\<nu>y\\<rparr>G\n  x \\<sharp> F\n\ngoal (1 subgoal):\n 1. y \\<sharp> G", "by(auto simp add: frame.inject alpha fresh_left calc_atm)"], ["", "lemma frameEqSupp:\n  fixes F :: \"('a::fs_name) frame\"\n  and   G :: \"'a frame\"\n  and   x :: name\n  and   y :: name\n\n  assumes \"\\<lparr>\\<nu>x\\<rparr>F = \\<lparr>\\<nu>y\\<rparr>G\"\n  and     \"x \\<in> supp F\"\n  \n  shows \"y \\<in> supp G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> supp G", "using assms"], ["proof (prove)\nusing this:\n  \\<lparr>\\<nu>x\\<rparr>F = \\<lparr>\\<nu>y\\<rparr>G\n  x \\<in> supp F\n\ngoal (1 subgoal):\n 1. y \\<in> supp G", "apply(auto simp add: frame.inject alpha fresh_left calc_atm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> supp ([(x, y)] \\<bullet> G); x \\<noteq> y;\n     x \\<sharp> G; F = [(x, y)] \\<bullet> G\\<rbrakk>\n    \\<Longrightarrow> y \\<in> supp G", "apply(drule_tac pi=\"[(x, y)]\" in pt_set_bij2[OF pt_name_inst, OF at_name_inst])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; x \\<sharp> G; F = [(x, y)] \\<bullet> G;\n     [(x, y)] \\<bullet> x\n     \\<in> [(x, y)] \\<bullet> supp ([(x, y)] \\<bullet> G)\\<rbrakk>\n    \\<Longrightarrow> y \\<in> supp G", "by(simp add: eqvts calc_atm)"], ["", "lemma frameChainEqSuppEmpty[dest]:\n  fixes xvec :: \"name list\"\n  and   \\<Psi>    :: \"'a::fs_name\"\n  and   yvec :: \"name list\"\n  and   \\<Psi>'   :: \"'a::fs_name\"\n\n  assumes \"\\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\"\n  and     \"supp \\<Psi> = ({}::name set)\"\n\n  shows \"\\<Psi> = \\<Psi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi> = \\<Psi>'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Psi> = \\<Psi>'", "obtain n where \"n = length xvec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n. n = length xvec \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n = length xvec\n\ngoal (1 subgoal):\n 1. \\<Psi> = \\<Psi>'", "with assms"], ["proof (chain)\npicking this:\n  \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\n  supp \\<Psi> = {}\n  n = length xvec", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\n  supp \\<Psi> = {}\n  n = length xvec\n\ngoal (1 subgoal):\n 1. \\<Psi> = \\<Psi>'", "proof(induct n arbitrary: xvec yvec \\<Psi> \\<Psi>')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                \\<langle>yvec, \\<Psi>'\\<rangle>;\n        supp \\<Psi> = {}; 0 = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<Psi> = \\<Psi>'\n 2. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    supp \\<Psi> = {}; n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi> = \\<Psi>';\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        supp \\<Psi> = {}; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<Psi> = \\<Psi>'", "case(0 xvec yvec \\<Psi> \\<Psi>')"], ["proof (state)\nthis:\n  \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\n  supp \\<Psi> = {}\n  0 = length xvec\n\ngoal (2 subgoals):\n 1. \\<And>xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                \\<langle>yvec, \\<Psi>'\\<rangle>;\n        supp \\<Psi> = {}; 0 = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<Psi> = \\<Psi>'\n 2. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    supp \\<Psi> = {}; n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi> = \\<Psi>';\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        supp \\<Psi> = {}; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<Psi> = \\<Psi>'", "from \\<open>0 = length xvec\\<close>"], ["proof (chain)\npicking this:\n  0 = length xvec", "have \"xvec = []\""], ["proof (prove)\nusing this:\n  0 = length xvec\n\ngoal (1 subgoal):\n 1. xvec = []", "by auto"], ["proof (state)\nthis:\n  xvec = []\n\ngoal (2 subgoals):\n 1. \\<And>xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                \\<langle>yvec, \\<Psi>'\\<rangle>;\n        supp \\<Psi> = {}; 0 = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<Psi> = \\<Psi>'\n 2. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    supp \\<Psi> = {}; n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi> = \\<Psi>';\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        supp \\<Psi> = {}; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<Psi> = \\<Psi>'", "moreover"], ["proof (state)\nthis:\n  xvec = []\n\ngoal (2 subgoals):\n 1. \\<And>xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                \\<langle>yvec, \\<Psi>'\\<rangle>;\n        supp \\<Psi> = {}; 0 = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<Psi> = \\<Psi>'\n 2. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    supp \\<Psi> = {}; n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi> = \\<Psi>';\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        supp \\<Psi> = {}; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<Psi> = \\<Psi>'", "with \\<open>\\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\\<close>"], ["proof (chain)\npicking this:\n  \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\n  xvec = []", "have \"yvec = []\""], ["proof (prove)\nusing this:\n  \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\n  xvec = []\n\ngoal (1 subgoal):\n 1. yvec = []", "by(case_tac yvec) auto"], ["proof (state)\nthis:\n  yvec = []\n\ngoal (2 subgoals):\n 1. \\<And>xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                \\<langle>yvec, \\<Psi>'\\<rangle>;\n        supp \\<Psi> = {}; 0 = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<Psi> = \\<Psi>'\n 2. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    supp \\<Psi> = {}; n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi> = \\<Psi>';\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        supp \\<Psi> = {}; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<Psi> = \\<Psi>'", "ultimately"], ["proof (chain)\npicking this:\n  xvec = []\n  yvec = []", "show ?case"], ["proof (prove)\nusing this:\n  xvec = []\n  yvec = []\n\ngoal (1 subgoal):\n 1. \\<Psi> = \\<Psi>'", "using \\<open>\\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\\<close>"], ["proof (prove)\nusing this:\n  xvec = []\n  yvec = []\n  \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<Psi> = \\<Psi>'", "by(simp add: frame.inject)"], ["proof (state)\nthis:\n  \\<Psi> = \\<Psi>'\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    supp \\<Psi> = {}; n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi> = \\<Psi>';\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        supp \\<Psi> = {}; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<Psi> = \\<Psi>'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    supp \\<Psi> = {}; n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi> = \\<Psi>';\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        supp \\<Psi> = {}; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<Psi> = \\<Psi>'", "case(Suc n xvec yvec \\<Psi> \\<Psi>')"], ["proof (state)\nthis:\n  \\<lbrakk>\\<langle>?xvec, ?\\<Psi>\\<rangle> =\n           \\<langle>?yvec, ?\\<Psi>'\\<rangle>;\n   supp ?\\<Psi> = {}; n = length ?xvec\\<rbrakk>\n  \\<Longrightarrow> ?\\<Psi> = ?\\<Psi>'\n  \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\n  supp \\<Psi> = {}\n  Suc n = length xvec\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    supp \\<Psi> = {}; n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi> = \\<Psi>';\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        supp \\<Psi> = {}; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<Psi> = \\<Psi>'", "from \\<open>Suc n = length xvec\\<close>"], ["proof (chain)\npicking this:\n  Suc n = length xvec", "obtain x xvec' where \"xvec = x#xvec'\" and \"length xvec' = n\""], ["proof (prove)\nusing this:\n  Suc n = length xvec\n\ngoal (1 subgoal):\n 1. (\\<And>x xvec'.\n        \\<lbrakk>xvec = x # xvec'; length xvec' = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(case_tac xvec) auto"], ["proof (state)\nthis:\n  xvec = x # xvec'\n  length xvec' = n\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    supp \\<Psi> = {}; n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi> = \\<Psi>';\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        supp \\<Psi> = {}; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<Psi> = \\<Psi>'", "from \\<open>\\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\\<close> \\<open>xvec = x # xvec'\\<close>"], ["proof (chain)\npicking this:\n  \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\n  xvec = x # xvec'", "obtain y yvec' where \"\\<langle>(x#xvec'), \\<Psi>\\<rangle> = \\<langle>(y#yvec'), \\<Psi>'\\<rangle>\"\n      and \"yvec = y#yvec'\""], ["proof (prove)\nusing this:\n  \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\n  xvec = x # xvec'\n\ngoal (1 subgoal):\n 1. (\\<And>y yvec'.\n        \\<lbrakk>\\<langle>(x # xvec'), \\<Psi>\\<rangle> =\n                 \\<langle>(y # yvec'), \\<Psi>'\\<rangle>;\n         yvec = y # yvec'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(case_tac yvec) auto"], ["proof (state)\nthis:\n  \\<langle>(x # xvec'), \\<Psi>\\<rangle> =\n  \\<langle>(y # yvec'), \\<Psi>'\\<rangle>\n  yvec = y # yvec'\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    supp \\<Psi> = {}; n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi> = \\<Psi>';\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        supp \\<Psi> = {}; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<Psi> = \\<Psi>'", "hence EQ: \"\\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>*xvec'\\<rparr>(FAssert \\<Psi>) = \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>*yvec'\\<rparr>(FAssert \\<Psi>')\""], ["proof (prove)\nusing this:\n  \\<langle>(x # xvec'), \\<Psi>\\<rangle> =\n  \\<langle>(y # yvec'), \\<Psi>'\\<rangle>\n  yvec = y # yvec'\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>\\<langle>xvec', \\<Psi>\\<rangle> =\n    \\<lparr>\\<nu>y\\<rparr>\\<langle>yvec', \\<Psi>'\\<rangle>", "by simp"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>\\<langle>xvec', \\<Psi>\\<rangle> =\n  \\<lparr>\\<nu>y\\<rparr>\\<langle>yvec', \\<Psi>'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    supp \\<Psi> = {}; n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi> = \\<Psi>';\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        supp \\<Psi> = {}; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<Psi> = \\<Psi>'", "have IH: \"\\<And>xvec yvec \\<Psi> \\<Psi>'. \\<lbrakk>\\<langle>xvec, (\\<Psi>::'a)\\<rangle> = \\<langle>yvec, (\\<Psi>'::'a)\\<rangle>; supp \\<Psi> = ({}::name set); n = length xvec\\<rbrakk> \\<Longrightarrow> \\<Psi> = \\<Psi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                \\<langle>yvec, \\<Psi>'\\<rangle>;\n        supp \\<Psi> = {}; n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<Psi> = \\<Psi>'", "by fact"], ["proof (state)\nthis:\n  \\<lbrakk>\\<langle>?xvec, ?\\<Psi>\\<rangle> =\n           \\<langle>?yvec, ?\\<Psi>'\\<rangle>;\n   supp ?\\<Psi> = {}; n = length ?xvec\\<rbrakk>\n  \\<Longrightarrow> ?\\<Psi> = ?\\<Psi>'\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    supp \\<Psi> = {}; n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi> = \\<Psi>';\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        supp \\<Psi> = {}; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<Psi> = \\<Psi>'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi> = \\<Psi>'", "proof(case_tac \"x = y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> \\<Psi> = \\<Psi>'\n 2. x \\<noteq> y \\<Longrightarrow> \\<Psi> = \\<Psi>'", "assume \"x = y\""], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> \\<Psi> = \\<Psi>'\n 2. x \\<noteq> y \\<Longrightarrow> \\<Psi> = \\<Psi>'", "with EQ"], ["proof (chain)\npicking this:\n  \\<lparr>\\<nu>x\\<rparr>\\<langle>xvec', \\<Psi>\\<rangle> =\n  \\<lparr>\\<nu>y\\<rparr>\\<langle>yvec', \\<Psi>'\\<rangle>\n  x = y", "have \"\\<langle>xvec', \\<Psi>\\<rangle> = \\<langle>yvec', \\<Psi>'\\<rangle>\""], ["proof (prove)\nusing this:\n  \\<lparr>\\<nu>x\\<rparr>\\<langle>xvec', \\<Psi>\\<rangle> =\n  \\<lparr>\\<nu>y\\<rparr>\\<langle>yvec', \\<Psi>'\\<rangle>\n  x = y\n\ngoal (1 subgoal):\n 1. \\<langle>xvec', \\<Psi>\\<rangle> = \\<langle>yvec', \\<Psi>'\\<rangle>", "by(simp add: alpha frame.inject)"], ["proof (state)\nthis:\n  \\<langle>xvec', \\<Psi>\\<rangle> = \\<langle>yvec', \\<Psi>'\\<rangle>\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> \\<Psi> = \\<Psi>'\n 2. x \\<noteq> y \\<Longrightarrow> \\<Psi> = \\<Psi>'", "with IH \\<open>length xvec' = n\\<close> \\<open>supp \\<Psi> = {}\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<langle>?xvec, ?\\<Psi>\\<rangle> =\n           \\<langle>?yvec, ?\\<Psi>'\\<rangle>;\n   supp ?\\<Psi> = {}; n = length ?xvec\\<rbrakk>\n  \\<Longrightarrow> ?\\<Psi> = ?\\<Psi>'\n  length xvec' = n\n  supp \\<Psi> = {}\n  \\<langle>xvec', \\<Psi>\\<rangle> = \\<langle>yvec', \\<Psi>'\\<rangle>", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<langle>?xvec, ?\\<Psi>\\<rangle> =\n           \\<langle>?yvec, ?\\<Psi>'\\<rangle>;\n   supp ?\\<Psi> = {}; n = length ?xvec\\<rbrakk>\n  \\<Longrightarrow> ?\\<Psi> = ?\\<Psi>'\n  length xvec' = n\n  supp \\<Psi> = {}\n  \\<langle>xvec', \\<Psi>\\<rangle> = \\<langle>yvec', \\<Psi>'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<Psi> = \\<Psi>'", "by simp"], ["proof (state)\nthis:\n  \\<Psi> = \\<Psi>'\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> \\<Psi> = \\<Psi>'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> \\<Psi> = \\<Psi>'", "assume \"x \\<noteq> y\""], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> \\<Psi> = \\<Psi>'", "with EQ"], ["proof (chain)\npicking this:\n  \\<lparr>\\<nu>x\\<rparr>\\<langle>xvec', \\<Psi>\\<rangle> =\n  \\<lparr>\\<nu>y\\<rparr>\\<langle>yvec', \\<Psi>'\\<rangle>\n  x \\<noteq> y", "have \"\\<langle>xvec', \\<Psi>\\<rangle> = [(x, y)] \\<bullet> \\<langle>yvec', \\<Psi>'\\<rangle>\""], ["proof (prove)\nusing this:\n  \\<lparr>\\<nu>x\\<rparr>\\<langle>xvec', \\<Psi>\\<rangle> =\n  \\<lparr>\\<nu>y\\<rparr>\\<langle>yvec', \\<Psi>'\\<rangle>\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<langle>xvec', \\<Psi>\\<rangle> =\n    [(x, y)] \\<bullet> \\<langle>yvec', \\<Psi>'\\<rangle>", "by(simp add: alpha frame.inject)"], ["proof (state)\nthis:\n  \\<langle>xvec', \\<Psi>\\<rangle> =\n  [(x, y)] \\<bullet> \\<langle>yvec', \\<Psi>'\\<rangle>\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> \\<Psi> = \\<Psi>'", "hence \"\\<langle>xvec', \\<Psi>\\<rangle> = \\<langle>([(x, y)] \\<bullet> yvec'), ([(x, y)] \\<bullet> \\<Psi>')\\<rangle>\""], ["proof (prove)\nusing this:\n  \\<langle>xvec', \\<Psi>\\<rangle> =\n  [(x, y)] \\<bullet> \\<langle>yvec', \\<Psi>'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>xvec', \\<Psi>\\<rangle> =\n    \\<langle>[(x, y)] \\<bullet> yvec', [(x, y)] \\<bullet> \\<Psi>'\\<rangle>", "by(simp add: eqvts)"], ["proof (state)\nthis:\n  \\<langle>xvec', \\<Psi>\\<rangle> =\n  \\<langle>[(x, y)] \\<bullet> yvec', [(x, y)] \\<bullet> \\<Psi>'\\<rangle>\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> \\<Psi> = \\<Psi>'", "with IH \\<open>length xvec' = n\\<close> \\<open>supp \\<Psi> = {}\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<langle>?xvec, ?\\<Psi>\\<rangle> =\n           \\<langle>?yvec, ?\\<Psi>'\\<rangle>;\n   supp ?\\<Psi> = {}; n = length ?xvec\\<rbrakk>\n  \\<Longrightarrow> ?\\<Psi> = ?\\<Psi>'\n  length xvec' = n\n  supp \\<Psi> = {}\n  \\<langle>xvec', \\<Psi>\\<rangle> =\n  \\<langle>[(x, y)] \\<bullet> yvec', [(x, y)] \\<bullet> \\<Psi>'\\<rangle>", "have \"\\<Psi> = [(x, y)] \\<bullet> \\<Psi>'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<langle>?xvec, ?\\<Psi>\\<rangle> =\n           \\<langle>?yvec, ?\\<Psi>'\\<rangle>;\n   supp ?\\<Psi> = {}; n = length ?xvec\\<rbrakk>\n  \\<Longrightarrow> ?\\<Psi> = ?\\<Psi>'\n  length xvec' = n\n  supp \\<Psi> = {}\n  \\<langle>xvec', \\<Psi>\\<rangle> =\n  \\<langle>[(x, y)] \\<bullet> yvec', [(x, y)] \\<bullet> \\<Psi>'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<Psi> = [(x, y)] \\<bullet> \\<Psi>'", "by(simp add: eqvts)"], ["proof (state)\nthis:\n  \\<Psi> = [(x, y)] \\<bullet> \\<Psi>'\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> \\<Psi> = \\<Psi>'", "moreover"], ["proof (state)\nthis:\n  \\<Psi> = [(x, y)] \\<bullet> \\<Psi>'\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> \\<Psi> = \\<Psi>'", "with \\<open>supp \\<Psi> = {}\\<close>"], ["proof (chain)\npicking this:\n  supp \\<Psi> = {}\n  \\<Psi> = [(x, y)] \\<bullet> \\<Psi>'", "have \"supp([(x, y)] \\<bullet> \\<Psi>') = ({}::name set)\""], ["proof (prove)\nusing this:\n  supp \\<Psi> = {}\n  \\<Psi> = [(x, y)] \\<bullet> \\<Psi>'\n\ngoal (1 subgoal):\n 1. supp ([(x, y)] \\<bullet> \\<Psi>') = {}", "by simp"], ["proof (state)\nthis:\n  supp ([(x, y)] \\<bullet> \\<Psi>') = {}\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> \\<Psi> = \\<Psi>'", "hence \"x \\<sharp> ([(x, y)] \\<bullet> \\<Psi>')\" and \"y \\<sharp> ([(x, y)] \\<bullet> \\<Psi>')\""], ["proof (prove)\nusing this:\n  supp ([(x, y)] \\<bullet> \\<Psi>') = {}\n\ngoal (1 subgoal):\n 1. x \\<sharp> [(x, y)] \\<bullet> \\<Psi>' &&&\n    y \\<sharp> [(x, y)] \\<bullet> \\<Psi>'", "by(simp add: fresh_def)+"], ["proof (state)\nthis:\n  x \\<sharp> [(x, y)] \\<bullet> \\<Psi>'\n  y \\<sharp> [(x, y)] \\<bullet> \\<Psi>'\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> \\<Psi> = \\<Psi>'", "with \\<open>x \\<noteq> y\\<close>"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  x \\<sharp> [(x, y)] \\<bullet> \\<Psi>'\n  y \\<sharp> [(x, y)] \\<bullet> \\<Psi>'", "have \"x \\<sharp> \\<Psi>'\" and \"y \\<sharp> \\<Psi>'\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  x \\<sharp> [(x, y)] \\<bullet> \\<Psi>'\n  y \\<sharp> [(x, y)] \\<bullet> \\<Psi>'\n\ngoal (1 subgoal):\n 1. x \\<sharp> \\<Psi>' &&& y \\<sharp> \\<Psi>'", "by(simp add: fresh_left calc_atm)+"], ["proof (state)\nthis:\n  x \\<sharp> \\<Psi>'\n  y \\<sharp> \\<Psi>'\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> \\<Psi> = \\<Psi>'", "ultimately"], ["proof (chain)\npicking this:\n  \\<Psi> = [(x, y)] \\<bullet> \\<Psi>'\n  x \\<sharp> \\<Psi>'\n  y \\<sharp> \\<Psi>'", "show ?case"], ["proof (prove)\nusing this:\n  \\<Psi> = [(x, y)] \\<bullet> \\<Psi>'\n  x \\<sharp> \\<Psi>'\n  y \\<sharp> \\<Psi>'\n\ngoal (1 subgoal):\n 1. \\<Psi> = \\<Psi>'", "by simp"], ["proof (state)\nthis:\n  \\<Psi> = \\<Psi>'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Psi> = \\<Psi>'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Psi> = \\<Psi>'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma frameChainEq:\n  fixes xvec :: \"name list\"\n  and   \\<Psi>    :: \"'a::fs_name\"\n  and   yvec :: \"name list\"\n  and   \\<Psi>'   :: \"'a::fs_name\"\n\n  assumes \"\\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\"\n  and     \"xvec \\<sharp>* yvec\"\n\n  obtains p where \"(set p) \\<subseteq> (set xvec) \\<times> set (yvec)\" and \"distinctPerm p\" and \"\\<Psi>' = p \\<bullet> \\<Psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>set p \\<subseteq> set xvec \\<times> set yvec;\n         distinctPerm p; \\<Psi>' = p \\<bullet> \\<Psi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>set p \\<subseteq> set xvec \\<times> set yvec;\n         distinctPerm p; \\<Psi>' = p \\<bullet> \\<Psi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "assume \"\\<And>p. \\<lbrakk>set p \\<subseteq> set xvec \\<times> set yvec; distinctPerm p; \\<Psi>' = p \\<bullet> \\<Psi>\\<rbrakk> \\<Longrightarrow> thesis\""], ["proof (state)\nthis:\n  \\<lbrakk>set ?p \\<subseteq> set xvec \\<times> set yvec; distinctPerm ?p;\n   \\<Psi>' = ?p \\<bullet> \\<Psi>\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>set p \\<subseteq> set xvec \\<times> set yvec;\n         distinctPerm p; \\<Psi>' = p \\<bullet> \\<Psi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>set ?p \\<subseteq> set xvec \\<times> set yvec; distinctPerm ?p;\n   \\<Psi>' = ?p \\<bullet> \\<Psi>\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>set p \\<subseteq> set xvec \\<times> set yvec;\n         distinctPerm p; \\<Psi>' = p \\<bullet> \\<Psi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain n where \"n = length xvec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n. n = length xvec \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n = length xvec\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>set p \\<subseteq> set xvec \\<times> set yvec;\n         distinctPerm p; \\<Psi>' = p \\<bullet> \\<Psi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with assms"], ["proof (chain)\npicking this:\n  \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\n  xvec \\<sharp>* yvec\n  n = length xvec", "have \"\\<exists>p. (set p) \\<subseteq> (set xvec) \\<times> set (yvec) \\<and> distinctPerm p \\<and>  \\<Psi>' = p \\<bullet> \\<Psi>\""], ["proof (prove)\nusing this:\n  \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\n  xvec \\<sharp>* yvec\n  n = length xvec\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>", "proof(induct n arbitrary: xvec yvec \\<Psi> \\<Psi>')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; 0 = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>\n 2. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "case(0 xvec yvec \\<Psi> \\<Psi>')"], ["proof (state)\nthis:\n  \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\n  xvec \\<sharp>* yvec\n  0 = length xvec\n\ngoal (2 subgoals):\n 1. \\<And>xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; 0 = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>\n 2. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "have Eq: \"\\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>", "by fact"], ["proof (state)\nthis:\n  \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; 0 = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>\n 2. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "from \\<open>0 = length xvec\\<close>"], ["proof (chain)\npicking this:\n  0 = length xvec", "have \"xvec = []\""], ["proof (prove)\nusing this:\n  0 = length xvec\n\ngoal (1 subgoal):\n 1. xvec = []", "by auto"], ["proof (state)\nthis:\n  xvec = []\n\ngoal (2 subgoals):\n 1. \\<And>xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; 0 = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>\n 2. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "moreover"], ["proof (state)\nthis:\n  xvec = []\n\ngoal (2 subgoals):\n 1. \\<And>xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; 0 = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>\n 2. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "with Eq"], ["proof (chain)\npicking this:\n  \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\n  xvec = []", "have \"yvec = []\""], ["proof (prove)\nusing this:\n  \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\n  xvec = []\n\ngoal (1 subgoal):\n 1. yvec = []", "by(case_tac yvec) auto"], ["proof (state)\nthis:\n  yvec = []\n\ngoal (2 subgoals):\n 1. \\<And>xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; 0 = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>\n 2. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "ultimately"], ["proof (chain)\npicking this:\n  xvec = []\n  yvec = []", "show ?case"], ["proof (prove)\nusing this:\n  xvec = []\n  yvec = []\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>", "using Eq"], ["proof (prove)\nusing this:\n  xvec = []\n  yvec = []\n  \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>", "by(simp add: frame.inject)"], ["proof (state)\nthis:\n  \\<exists>p.\n     set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n     distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "case(Suc n xvec yvec \\<Psi> \\<Psi>')"], ["proof (state)\nthis:\n  \\<lbrakk>\\<langle>?xvec, ?\\<Psi>\\<rangle> =\n           \\<langle>?yvec, ?\\<Psi>'\\<rangle>;\n   ?xvec \\<sharp>* ?yvec; n = length ?xvec\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       set p \\<subseteq> set ?xvec \\<times> set ?yvec \\<and>\n                       distinctPerm p \\<and> ?\\<Psi>' = p \\<bullet> ?\\<Psi>\n  \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\n  xvec \\<sharp>* yvec\n  Suc n = length xvec\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "from \\<open>Suc n = length xvec\\<close>"], ["proof (chain)\npicking this:\n  Suc n = length xvec", "obtain x xvec' where \"xvec = x#xvec'\" and \"length xvec' = n\""], ["proof (prove)\nusing this:\n  Suc n = length xvec\n\ngoal (1 subgoal):\n 1. (\\<And>x xvec'.\n        \\<lbrakk>xvec = x # xvec'; length xvec' = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(case_tac xvec) auto"], ["proof (state)\nthis:\n  xvec = x # xvec'\n  length xvec' = n\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "from \\<open>\\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\\<close> \\<open>xvec = x # xvec'\\<close>"], ["proof (chain)\npicking this:\n  \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\n  xvec = x # xvec'", "obtain y yvec' where \"\\<langle>(x#xvec'), \\<Psi>\\<rangle> = \\<langle>(y#yvec'), \\<Psi>'\\<rangle>\"\n      and \"yvec = y#yvec'\""], ["proof (prove)\nusing this:\n  \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\n  xvec = x # xvec'\n\ngoal (1 subgoal):\n 1. (\\<And>y yvec'.\n        \\<lbrakk>\\<langle>(x # xvec'), \\<Psi>\\<rangle> =\n                 \\<langle>(y # yvec'), \\<Psi>'\\<rangle>;\n         yvec = y # yvec'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(case_tac yvec) auto"], ["proof (state)\nthis:\n  \\<langle>(x # xvec'), \\<Psi>\\<rangle> =\n  \\<langle>(y # yvec'), \\<Psi>'\\<rangle>\n  yvec = y # yvec'\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "hence EQ: \"\\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>*xvec'\\<rparr>(FAssert \\<Psi>) = \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>*yvec'\\<rparr>(FAssert \\<Psi>')\""], ["proof (prove)\nusing this:\n  \\<langle>(x # xvec'), \\<Psi>\\<rangle> =\n  \\<langle>(y # yvec'), \\<Psi>'\\<rangle>\n  yvec = y # yvec'\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>\\<langle>xvec', \\<Psi>\\<rangle> =\n    \\<lparr>\\<nu>y\\<rparr>\\<langle>yvec', \\<Psi>'\\<rangle>", "by simp"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>\\<langle>xvec', \\<Psi>\\<rangle> =\n  \\<lparr>\\<nu>y\\<rparr>\\<langle>yvec', \\<Psi>'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "from \\<open>xvec = x#xvec'\\<close> \\<open>yvec=y#yvec'\\<close> \\<open>xvec \\<sharp>* yvec\\<close>"], ["proof (chain)\npicking this:\n  xvec = x # xvec'\n  yvec = y # yvec'\n  xvec \\<sharp>* yvec", "have \"x \\<noteq> y\" and \"xvec' \\<sharp>* yvec'\" and \"x \\<sharp> yvec'\" and \"y \\<sharp> xvec'\""], ["proof (prove)\nusing this:\n  xvec = x # xvec'\n  yvec = y # yvec'\n  xvec \\<sharp>* yvec\n\ngoal (1 subgoal):\n 1. (x \\<noteq> y &&& xvec' \\<sharp>* yvec') &&&\n    x \\<sharp> yvec' &&& y \\<sharp> xvec'", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> y\n  xvec' \\<sharp>* yvec'\n  x \\<sharp> yvec'\n  y \\<sharp> xvec'\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "have IH: \"\\<And>xvec yvec \\<Psi> \\<Psi>'. \\<lbrakk>\\<langle>xvec, (\\<Psi>::'a)\\<rangle> = \\<langle>yvec, (\\<Psi>'::'a)\\<rangle>; xvec \\<sharp>* yvec; n = length xvec\\<rbrakk> \\<Longrightarrow>\n                                 \\<exists>p. (set p) \\<subseteq> (set xvec) \\<times> (set yvec) \\<and> distinctPerm p \\<and>  \\<Psi>' = p \\<bullet> \\<Psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "by fact"], ["proof (state)\nthis:\n  \\<lbrakk>\\<langle>?xvec, ?\\<Psi>\\<rangle> =\n           \\<langle>?yvec, ?\\<Psi>'\\<rangle>;\n   ?xvec \\<sharp>* ?yvec; n = length ?xvec\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       set p \\<subseteq> set ?xvec \\<times> set ?yvec \\<and>\n                       distinctPerm p \\<and> ?\\<Psi>' = p \\<bullet> ?\\<Psi>\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "from EQ \\<open>x \\<noteq> y\\<close>"], ["proof (chain)\npicking this:\n  \\<lparr>\\<nu>x\\<rparr>\\<langle>xvec', \\<Psi>\\<rangle> =\n  \\<lparr>\\<nu>y\\<rparr>\\<langle>yvec', \\<Psi>'\\<rangle>\n  x \\<noteq> y", "have EQ': \"\\<langle>xvec', \\<Psi>\\<rangle> = ([(x, y)] \\<bullet> \\<langle>yvec', \\<Psi>'\\<rangle>)\" \n                     and xFresh\\<Psi>': \"x \\<sharp> \\<lparr>\\<nu>*yvec'\\<rparr>(FAssert \\<Psi>')\""], ["proof (prove)\nusing this:\n  \\<lparr>\\<nu>x\\<rparr>\\<langle>xvec', \\<Psi>\\<rangle> =\n  \\<lparr>\\<nu>y\\<rparr>\\<langle>yvec', \\<Psi>'\\<rangle>\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<langle>xvec', \\<Psi>\\<rangle> =\n    [(x, y)] \\<bullet> \\<langle>yvec', \\<Psi>'\\<rangle> &&&\n    x \\<sharp> \\<langle>yvec', \\<Psi>'\\<rangle>", "by(simp add: frame.inject alpha)+"], ["proof (state)\nthis:\n  \\<langle>xvec', \\<Psi>\\<rangle> =\n  [(x, y)] \\<bullet> \\<langle>yvec', \\<Psi>'\\<rangle>\n  x \\<sharp> \\<langle>yvec', \\<Psi>'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>", "proof(case_tac \"x \\<sharp> \\<langle>xvec', \\<Psi>\\<rangle>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<sharp> \\<langle>xvec', \\<Psi>\\<rangle> \\<Longrightarrow>\n    \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>\n 2. \\<not> x \\<sharp> \\<langle>xvec', \\<Psi>\\<rangle> \\<Longrightarrow>\n    \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>", "assume \"x \\<sharp> \\<langle>xvec', \\<Psi>\\<rangle>\""], ["proof (state)\nthis:\n  x \\<sharp> \\<langle>xvec', \\<Psi>\\<rangle>\n\ngoal (2 subgoals):\n 1. x \\<sharp> \\<langle>xvec', \\<Psi>\\<rangle> \\<Longrightarrow>\n    \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>\n 2. \\<not> x \\<sharp> \\<langle>xvec', \\<Psi>\\<rangle> \\<Longrightarrow>\n    \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>", "with EQ"], ["proof (chain)\npicking this:\n  \\<lparr>\\<nu>x\\<rparr>\\<langle>xvec', \\<Psi>\\<rangle> =\n  \\<lparr>\\<nu>y\\<rparr>\\<langle>yvec', \\<Psi>'\\<rangle>\n  x \\<sharp> \\<langle>xvec', \\<Psi>\\<rangle>", "have \"y \\<sharp> \\<langle>yvec', \\<Psi>'\\<rangle>\""], ["proof (prove)\nusing this:\n  \\<lparr>\\<nu>x\\<rparr>\\<langle>xvec', \\<Psi>\\<rangle> =\n  \\<lparr>\\<nu>y\\<rparr>\\<langle>yvec', \\<Psi>'\\<rangle>\n  x \\<sharp> \\<langle>xvec', \\<Psi>\\<rangle>\n\ngoal (1 subgoal):\n 1. y \\<sharp> \\<langle>yvec', \\<Psi>'\\<rangle>", "by(rule frameEqFresh)"], ["proof (state)\nthis:\n  y \\<sharp> \\<langle>yvec', \\<Psi>'\\<rangle>\n\ngoal (2 subgoals):\n 1. x \\<sharp> \\<langle>xvec', \\<Psi>\\<rangle> \\<Longrightarrow>\n    \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>\n 2. \\<not> x \\<sharp> \\<langle>xvec', \\<Psi>\\<rangle> \\<Longrightarrow>\n    \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>", "with xFresh\\<Psi>' EQ'"], ["proof (chain)\npicking this:\n  x \\<sharp> \\<langle>yvec', \\<Psi>'\\<rangle>\n  \\<langle>xvec', \\<Psi>\\<rangle> =\n  [(x, y)] \\<bullet> \\<langle>yvec', \\<Psi>'\\<rangle>\n  y \\<sharp> \\<langle>yvec', \\<Psi>'\\<rangle>", "have \"\\<langle>xvec', \\<Psi>\\<rangle> = \\<langle>yvec', \\<Psi>'\\<rangle>\""], ["proof (prove)\nusing this:\n  x \\<sharp> \\<langle>yvec', \\<Psi>'\\<rangle>\n  \\<langle>xvec', \\<Psi>\\<rangle> =\n  [(x, y)] \\<bullet> \\<langle>yvec', \\<Psi>'\\<rangle>\n  y \\<sharp> \\<langle>yvec', \\<Psi>'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>xvec', \\<Psi>\\<rangle> = \\<langle>yvec', \\<Psi>'\\<rangle>", "by(simp)"], ["proof (state)\nthis:\n  \\<langle>xvec', \\<Psi>\\<rangle> = \\<langle>yvec', \\<Psi>'\\<rangle>\n\ngoal (2 subgoals):\n 1. x \\<sharp> \\<langle>xvec', \\<Psi>\\<rangle> \\<Longrightarrow>\n    \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>\n 2. \\<not> x \\<sharp> \\<langle>xvec', \\<Psi>\\<rangle> \\<Longrightarrow>\n    \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>", "with \\<open>xvec' \\<sharp>* yvec'\\<close> \\<open>length xvec' = n\\<close> IH"], ["proof (chain)\npicking this:\n  xvec' \\<sharp>* yvec'\n  length xvec' = n\n  \\<lbrakk>\\<langle>?xvec, ?\\<Psi>\\<rangle> =\n           \\<langle>?yvec, ?\\<Psi>'\\<rangle>;\n   ?xvec \\<sharp>* ?yvec; n = length ?xvec\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       set p \\<subseteq> set ?xvec \\<times> set ?yvec \\<and>\n                       distinctPerm p \\<and> ?\\<Psi>' = p \\<bullet> ?\\<Psi>\n  \\<langle>xvec', \\<Psi>\\<rangle> = \\<langle>yvec', \\<Psi>'\\<rangle>", "obtain p where S: \"(set p) \\<subseteq> (set xvec') \\<times> (set yvec')\" and \"distinctPerm p\"  and \"\\<Psi>' = p \\<bullet> \\<Psi>\""], ["proof (prove)\nusing this:\n  xvec' \\<sharp>* yvec'\n  length xvec' = n\n  \\<lbrakk>\\<langle>?xvec, ?\\<Psi>\\<rangle> =\n           \\<langle>?yvec, ?\\<Psi>'\\<rangle>;\n   ?xvec \\<sharp>* ?yvec; n = length ?xvec\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       set p \\<subseteq> set ?xvec \\<times> set ?yvec \\<and>\n                       distinctPerm p \\<and> ?\\<Psi>' = p \\<bullet> ?\\<Psi>\n  \\<langle>xvec', \\<Psi>\\<rangle> = \\<langle>yvec', \\<Psi>'\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>set p \\<subseteq> set xvec' \\<times> set yvec';\n         distinctPerm p; \\<Psi>' = p \\<bullet> \\<Psi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  set p \\<subseteq> set xvec' \\<times> set yvec'\n  distinctPerm p\n  \\<Psi>' = p \\<bullet> \\<Psi>\n\ngoal (2 subgoals):\n 1. x \\<sharp> \\<langle>xvec', \\<Psi>\\<rangle> \\<Longrightarrow>\n    \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>\n 2. \\<not> x \\<sharp> \\<langle>xvec', \\<Psi>\\<rangle> \\<Longrightarrow>\n    \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>", "from S"], ["proof (chain)\npicking this:\n  set p \\<subseteq> set xvec' \\<times> set yvec'", "have \"(set p) \\<subseteq> set(x#xvec') \\<times> set(y#yvec')\""], ["proof (prove)\nusing this:\n  set p \\<subseteq> set xvec' \\<times> set yvec'\n\ngoal (1 subgoal):\n 1. set p \\<subseteq> set (x # xvec') \\<times> set (y # yvec')", "by auto"], ["proof (state)\nthis:\n  set p \\<subseteq> set (x # xvec') \\<times> set (y # yvec')\n\ngoal (2 subgoals):\n 1. x \\<sharp> \\<langle>xvec', \\<Psi>\\<rangle> \\<Longrightarrow>\n    \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>\n 2. \\<not> x \\<sharp> \\<langle>xvec', \\<Psi>\\<rangle> \\<Longrightarrow>\n    \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>", "with \\<open>xvec = x#xvec'\\<close> \\<open>yvec=y#yvec'\\<close> \\<open>distinctPerm p\\<close> \\<open>\\<Psi>' = p \\<bullet> \\<Psi>\\<close>"], ["proof (chain)\npicking this:\n  xvec = x # xvec'\n  yvec = y # yvec'\n  distinctPerm p\n  \\<Psi>' = p \\<bullet> \\<Psi>\n  set p \\<subseteq> set (x # xvec') \\<times> set (y # yvec')", "show ?case"], ["proof (prove)\nusing this:\n  xvec = x # xvec'\n  yvec = y # yvec'\n  distinctPerm p\n  \\<Psi>' = p \\<bullet> \\<Psi>\n  set p \\<subseteq> set (x # xvec') \\<times> set (y # yvec')\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>", "by blast"], ["proof (state)\nthis:\n  \\<exists>p.\n     set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n     distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>\n\ngoal (1 subgoal):\n 1. \\<not> x \\<sharp> \\<langle>xvec', \\<Psi>\\<rangle> \\<Longrightarrow>\n    \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x \\<sharp> \\<langle>xvec', \\<Psi>\\<rangle> \\<Longrightarrow>\n    \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>", "assume \"\\<not>(x \\<sharp> \\<lparr>\\<nu>*xvec'\\<rparr>(FAssert \\<Psi>))\""], ["proof (state)\nthis:\n  \\<not> x \\<sharp> \\<langle>xvec', \\<Psi>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> x \\<sharp> \\<langle>xvec', \\<Psi>\\<rangle> \\<Longrightarrow>\n    \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>", "hence xSupp\\<Psi>: \"x \\<in> supp(\\<langle>xvec', \\<Psi>\\<rangle>)\""], ["proof (prove)\nusing this:\n  \\<not> x \\<sharp> \\<langle>xvec', \\<Psi>\\<rangle>\n\ngoal (1 subgoal):\n 1. x \\<in> supp (\\<langle>xvec', \\<Psi>\\<rangle>)", "by(simp add: fresh_def)"], ["proof (state)\nthis:\n  x \\<in> supp (\\<langle>xvec', \\<Psi>\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<not> x \\<sharp> \\<langle>xvec', \\<Psi>\\<rangle> \\<Longrightarrow>\n    \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>", "with EQ"], ["proof (chain)\npicking this:\n  \\<lparr>\\<nu>x\\<rparr>\\<langle>xvec', \\<Psi>\\<rangle> =\n  \\<lparr>\\<nu>y\\<rparr>\\<langle>yvec', \\<Psi>'\\<rangle>\n  x \\<in> supp (\\<langle>xvec', \\<Psi>\\<rangle>)", "have \"y \\<in> supp (\\<langle>yvec', \\<Psi>'\\<rangle>)\""], ["proof (prove)\nusing this:\n  \\<lparr>\\<nu>x\\<rparr>\\<langle>xvec', \\<Psi>\\<rangle> =\n  \\<lparr>\\<nu>y\\<rparr>\\<langle>yvec', \\<Psi>'\\<rangle>\n  x \\<in> supp (\\<langle>xvec', \\<Psi>\\<rangle>)\n\ngoal (1 subgoal):\n 1. y \\<in> supp (\\<langle>yvec', \\<Psi>'\\<rangle>)", "by(rule frameEqSupp)"], ["proof (state)\nthis:\n  y \\<in> supp (\\<langle>yvec', \\<Psi>'\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<not> x \\<sharp> \\<langle>xvec', \\<Psi>\\<rangle> \\<Longrightarrow>\n    \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>", "hence \"y \\<sharp> yvec'\""], ["proof (prove)\nusing this:\n  y \\<in> supp (\\<langle>yvec', \\<Psi>'\\<rangle>)\n\ngoal (1 subgoal):\n 1. y \\<sharp> yvec'", "by(induct yvec') (auto simp add: frame.supp abs_supp)"], ["proof (state)\nthis:\n  y \\<sharp> yvec'\n\ngoal (1 subgoal):\n 1. \\<not> x \\<sharp> \\<langle>xvec', \\<Psi>\\<rangle> \\<Longrightarrow>\n    \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>", "with \\<open>x \\<sharp> yvec'\\<close> EQ'"], ["proof (chain)\npicking this:\n  x \\<sharp> yvec'\n  \\<langle>xvec', \\<Psi>\\<rangle> =\n  [(x, y)] \\<bullet> \\<langle>yvec', \\<Psi>'\\<rangle>\n  y \\<sharp> yvec'", "have \"\\<langle>xvec', \\<Psi>\\<rangle> = \\<langle>yvec', ([(x, y)] \\<bullet> \\<Psi>')\\<rangle>\""], ["proof (prove)\nusing this:\n  x \\<sharp> yvec'\n  \\<langle>xvec', \\<Psi>\\<rangle> =\n  [(x, y)] \\<bullet> \\<langle>yvec', \\<Psi>'\\<rangle>\n  y \\<sharp> yvec'\n\ngoal (1 subgoal):\n 1. \\<langle>xvec', \\<Psi>\\<rangle> =\n    \\<langle>yvec', [(x, y)] \\<bullet> \\<Psi>'\\<rangle>", "by(simp add: eqvts)"], ["proof (state)\nthis:\n  \\<langle>xvec', \\<Psi>\\<rangle> =\n  \\<langle>yvec', [(x, y)] \\<bullet> \\<Psi>'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> x \\<sharp> \\<langle>xvec', \\<Psi>\\<rangle> \\<Longrightarrow>\n    \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>", "with  \\<open>xvec' \\<sharp>* yvec'\\<close> \\<open>length xvec' = n\\<close> IH"], ["proof (chain)\npicking this:\n  xvec' \\<sharp>* yvec'\n  length xvec' = n\n  \\<lbrakk>\\<langle>?xvec, ?\\<Psi>\\<rangle> =\n           \\<langle>?yvec, ?\\<Psi>'\\<rangle>;\n   ?xvec \\<sharp>* ?yvec; n = length ?xvec\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       set p \\<subseteq> set ?xvec \\<times> set ?yvec \\<and>\n                       distinctPerm p \\<and> ?\\<Psi>' = p \\<bullet> ?\\<Psi>\n  \\<langle>xvec', \\<Psi>\\<rangle> =\n  \\<langle>yvec', [(x, y)] \\<bullet> \\<Psi>'\\<rangle>", "obtain p where S: \"(set p) \\<subseteq> (set xvec') \\<times> (set yvec')\" and \"distinctPerm p\" and \"([(x, y)] \\<bullet> \\<Psi>') = p \\<bullet> \\<Psi>\""], ["proof (prove)\nusing this:\n  xvec' \\<sharp>* yvec'\n  length xvec' = n\n  \\<lbrakk>\\<langle>?xvec, ?\\<Psi>\\<rangle> =\n           \\<langle>?yvec, ?\\<Psi>'\\<rangle>;\n   ?xvec \\<sharp>* ?yvec; n = length ?xvec\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       set p \\<subseteq> set ?xvec \\<times> set ?yvec \\<and>\n                       distinctPerm p \\<and> ?\\<Psi>' = p \\<bullet> ?\\<Psi>\n  \\<langle>xvec', \\<Psi>\\<rangle> =\n  \\<langle>yvec', [(x, y)] \\<bullet> \\<Psi>'\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>set p \\<subseteq> set xvec' \\<times> set yvec';\n         distinctPerm p;\n         [(x, y)] \\<bullet> \\<Psi>' = p \\<bullet> \\<Psi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  set p \\<subseteq> set xvec' \\<times> set yvec'\n  distinctPerm p\n  [(x, y)] \\<bullet> \\<Psi>' = p \\<bullet> \\<Psi>\n\ngoal (1 subgoal):\n 1. \\<not> x \\<sharp> \\<langle>xvec', \\<Psi>\\<rangle> \\<Longrightarrow>\n    \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>", "from xSupp\\<Psi>"], ["proof (chain)\npicking this:\n  x \\<in> supp (\\<langle>xvec', \\<Psi>\\<rangle>)", "have \"x \\<sharp> xvec'\""], ["proof (prove)\nusing this:\n  x \\<in> supp (\\<langle>xvec', \\<Psi>\\<rangle>)\n\ngoal (1 subgoal):\n 1. x \\<sharp> xvec'", "by(induct xvec') (auto simp add: frame.supp abs_supp)"], ["proof (state)\nthis:\n  x \\<sharp> xvec'\n\ngoal (1 subgoal):\n 1. \\<not> x \\<sharp> \\<langle>xvec', \\<Psi>\\<rangle> \\<Longrightarrow>\n    \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>", "with \\<open>x \\<sharp> yvec'\\<close> \\<open>y \\<sharp> xvec'\\<close> \\<open>y \\<sharp> yvec'\\<close> S"], ["proof (chain)\npicking this:\n  x \\<sharp> yvec'\n  y \\<sharp> xvec'\n  y \\<sharp> yvec'\n  set p \\<subseteq> set xvec' \\<times> set yvec'\n  x \\<sharp> xvec'", "have \"x \\<sharp> p\" and \"y \\<sharp> p\""], ["proof (prove)\nusing this:\n  x \\<sharp> yvec'\n  y \\<sharp> xvec'\n  y \\<sharp> yvec'\n  set p \\<subseteq> set xvec' \\<times> set yvec'\n  x \\<sharp> xvec'\n\ngoal (1 subgoal):\n 1. x \\<sharp> p &&& y \\<sharp> p", "apply(induct p)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>x \\<sharp> yvec'; y \\<sharp> xvec'; y \\<sharp> yvec';\n     set [] \\<subseteq> set xvec' \\<times> set yvec';\n     x \\<sharp> xvec'\\<rbrakk>\n    \\<Longrightarrow> x \\<sharp> []\n 2. \\<lbrakk>x \\<sharp> yvec'; y \\<sharp> xvec'; y \\<sharp> yvec';\n     set [] \\<subseteq> set xvec' \\<times> set yvec';\n     x \\<sharp> xvec'\\<rbrakk>\n    \\<Longrightarrow> y \\<sharp> []\n 3. \\<And>a p.\n       \\<lbrakk>\\<lbrakk>x \\<sharp> yvec'; y \\<sharp> xvec';\n                 y \\<sharp> yvec';\n                 set p \\<subseteq> set xvec' \\<times> set yvec';\n                 x \\<sharp> xvec'\\<rbrakk>\n                \\<Longrightarrow> x \\<sharp> p;\n        \\<lbrakk>x \\<sharp> yvec'; y \\<sharp> xvec'; y \\<sharp> yvec';\n         set p \\<subseteq> set xvec' \\<times> set yvec';\n         x \\<sharp> xvec'\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> p;\n        x \\<sharp> yvec'; y \\<sharp> xvec'; y \\<sharp> yvec';\n        set (a # p) \\<subseteq> set xvec' \\<times> set yvec';\n        x \\<sharp> xvec'\\<rbrakk>\n       \\<Longrightarrow> x \\<sharp> (a # p)\n 4. \\<And>a p.\n       \\<lbrakk>\\<lbrakk>x \\<sharp> yvec'; y \\<sharp> xvec';\n                 y \\<sharp> yvec';\n                 set p \\<subseteq> set xvec' \\<times> set yvec';\n                 x \\<sharp> xvec'\\<rbrakk>\n                \\<Longrightarrow> x \\<sharp> p;\n        \\<lbrakk>x \\<sharp> yvec'; y \\<sharp> xvec'; y \\<sharp> yvec';\n         set p \\<subseteq> set xvec' \\<times> set yvec';\n         x \\<sharp> xvec'\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> p;\n        x \\<sharp> yvec'; y \\<sharp> xvec'; y \\<sharp> yvec';\n        set (a # p) \\<subseteq> set xvec' \\<times> set yvec';\n        x \\<sharp> xvec'\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (a # p)", "by(auto simp add: name_list_supp) (auto simp add: fresh_def)"], ["proof (state)\nthis:\n  x \\<sharp> p\n  y \\<sharp> p\n\ngoal (1 subgoal):\n 1. \\<not> x \\<sharp> \\<langle>xvec', \\<Psi>\\<rangle> \\<Longrightarrow>\n    \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>", "from S"], ["proof (chain)\npicking this:\n  set p \\<subseteq> set xvec' \\<times> set yvec'", "have \"(set ((x, y)#p)) \\<subseteq> (set(x#xvec')) \\<times> (set(y#yvec'))\""], ["proof (prove)\nusing this:\n  set p \\<subseteq> set xvec' \\<times> set yvec'\n\ngoal (1 subgoal):\n 1. set ((x, y) # p) \\<subseteq> set (x # xvec') \\<times> set (y # yvec')", "by force"], ["proof (state)\nthis:\n  set ((x, y) # p) \\<subseteq> set (x # xvec') \\<times> set (y # yvec')\n\ngoal (1 subgoal):\n 1. \\<not> x \\<sharp> \\<langle>xvec', \\<Psi>\\<rangle> \\<Longrightarrow>\n    \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>", "moreover"], ["proof (state)\nthis:\n  set ((x, y) # p) \\<subseteq> set (x # xvec') \\<times> set (y # yvec')\n\ngoal (1 subgoal):\n 1. \\<not> x \\<sharp> \\<langle>xvec', \\<Psi>\\<rangle> \\<Longrightarrow>\n    \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>", "from \\<open>x \\<noteq> y\\<close> \\<open>x \\<sharp> p\\<close> \\<open>y \\<sharp> p\\<close> S \\<open>distinctPerm p\\<close>"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  x \\<sharp> p\n  y \\<sharp> p\n  set p \\<subseteq> set xvec' \\<times> set yvec'\n  distinctPerm p", "have \"distinctPerm((x,y)#p)\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  x \\<sharp> p\n  y \\<sharp> p\n  set p \\<subseteq> set xvec' \\<times> set yvec'\n  distinctPerm p\n\ngoal (1 subgoal):\n 1. distinctPerm ((x, y) # p)", "by simp"], ["proof (state)\nthis:\n  distinctPerm ((x, y) # p)\n\ngoal (1 subgoal):\n 1. \\<not> x \\<sharp> \\<langle>xvec', \\<Psi>\\<rangle> \\<Longrightarrow>\n    \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>", "moreover"], ["proof (state)\nthis:\n  distinctPerm ((x, y) # p)\n\ngoal (1 subgoal):\n 1. \\<not> x \\<sharp> \\<langle>xvec', \\<Psi>\\<rangle> \\<Longrightarrow>\n    \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>", "from \\<open>x \\<sharp> p\\<close> \\<open>y \\<sharp> p\\<close> \\<open>x \\<sharp> xvec'\\<close> \\<open>y \\<sharp> xvec'\\<close>"], ["proof (chain)\npicking this:\n  x \\<sharp> p\n  y \\<sharp> p\n  x \\<sharp> xvec'\n  y \\<sharp> xvec'", "have \"y#(p \\<bullet> xvec') = ((x, y)#p) \\<bullet> (x#xvec')\""], ["proof (prove)\nusing this:\n  x \\<sharp> p\n  y \\<sharp> p\n  x \\<sharp> xvec'\n  y \\<sharp> xvec'\n\ngoal (1 subgoal):\n 1. y # p \\<bullet> xvec' = ((x, y) # p) \\<bullet> (x # xvec')", "by(simp add: eqvts calc_atm freshChainSimps)"], ["proof (state)\nthis:\n  y # p \\<bullet> xvec' = ((x, y) # p) \\<bullet> (x # xvec')\n\ngoal (1 subgoal):\n 1. \\<not> x \\<sharp> \\<langle>xvec', \\<Psi>\\<rangle> \\<Longrightarrow>\n    \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>", "moreover"], ["proof (state)\nthis:\n  y # p \\<bullet> xvec' = ((x, y) # p) \\<bullet> (x # xvec')\n\ngoal (1 subgoal):\n 1. \\<not> x \\<sharp> \\<langle>xvec', \\<Psi>\\<rangle> \\<Longrightarrow>\n    \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>", "from \\<open>([(x, y)] \\<bullet> \\<Psi>') = p \\<bullet> \\<Psi>\\<close>"], ["proof (chain)\npicking this:\n  [(x, y)] \\<bullet> \\<Psi>' = p \\<bullet> \\<Psi>", "have \"([(x, y)] \\<bullet> [(x, y)] \\<bullet> \\<Psi>') = [(x, y)] \\<bullet> p \\<bullet> \\<Psi>\""], ["proof (prove)\nusing this:\n  [(x, y)] \\<bullet> \\<Psi>' = p \\<bullet> \\<Psi>\n\ngoal (1 subgoal):\n 1. [(x, y)] \\<bullet> [(x, y)] \\<bullet> \\<Psi>' =\n    [(x, y)] \\<bullet> p \\<bullet> \\<Psi>", "by(simp add: pt_bij)"], ["proof (state)\nthis:\n  [(x, y)] \\<bullet> [(x, y)] \\<bullet> \\<Psi>' =\n  [(x, y)] \\<bullet> p \\<bullet> \\<Psi>\n\ngoal (1 subgoal):\n 1. \\<not> x \\<sharp> \\<langle>xvec', \\<Psi>\\<rangle> \\<Longrightarrow>\n    \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>", "hence \"\\<Psi>' = ((x, y)#p) \\<bullet> \\<Psi>\""], ["proof (prove)\nusing this:\n  [(x, y)] \\<bullet> [(x, y)] \\<bullet> \\<Psi>' =\n  [(x, y)] \\<bullet> p \\<bullet> \\<Psi>\n\ngoal (1 subgoal):\n 1. \\<Psi>' = ((x, y) # p) \\<bullet> \\<Psi>", "by simp"], ["proof (state)\nthis:\n  \\<Psi>' = ((x, y) # p) \\<bullet> \\<Psi>\n\ngoal (1 subgoal):\n 1. \\<not> x \\<sharp> \\<langle>xvec', \\<Psi>\\<rangle> \\<Longrightarrow>\n    \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>", "ultimately"], ["proof (chain)\npicking this:\n  set ((x, y) # p) \\<subseteq> set (x # xvec') \\<times> set (y # yvec')\n  distinctPerm ((x, y) # p)\n  y # p \\<bullet> xvec' = ((x, y) # p) \\<bullet> (x # xvec')\n  \\<Psi>' = ((x, y) # p) \\<bullet> \\<Psi>", "show ?case"], ["proof (prove)\nusing this:\n  set ((x, y) # p) \\<subseteq> set (x # xvec') \\<times> set (y # yvec')\n  distinctPerm ((x, y) # p)\n  y # p \\<bullet> xvec' = ((x, y) # p) \\<bullet> (x # xvec')\n  \\<Psi>' = ((x, y) # p) \\<bullet> \\<Psi>\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>", "using \\<open>xvec=x#xvec'\\<close> \\<open>yvec=y#yvec'\\<close>"], ["proof (prove)\nusing this:\n  set ((x, y) # p) \\<subseteq> set (x # xvec') \\<times> set (y # yvec')\n  distinctPerm ((x, y) # p)\n  y # p \\<bullet> xvec' = ((x, y) # p) \\<bullet> (x # xvec')\n  \\<Psi>' = ((x, y) # p) \\<bullet> \\<Psi>\n  xvec = x # xvec'\n  yvec = y # yvec'\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>", "by blast"], ["proof (state)\nthis:\n  \\<exists>p.\n     set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n     distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>p.\n     set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n     distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>p.\n     set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n     distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>set p \\<subseteq> set xvec \\<times> set yvec;\n         distinctPerm p; \\<Psi>' = p \\<bullet> \\<Psi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>set ?p \\<subseteq> set xvec \\<times> set yvec; distinctPerm ?p;\n   \\<Psi>' = ?p \\<bullet> \\<Psi>\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<exists>p.\n     set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n     distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>set ?p \\<subseteq> set xvec \\<times> set yvec; distinctPerm ?p;\n   \\<Psi>' = ?p \\<bullet> \\<Psi>\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<exists>p.\n     set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n     distinctPerm p \\<and> \\<Psi>' = p \\<bullet> \\<Psi>\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "(*\nlemma frameChainEq'':\n  fixes xvec :: \"name list\"\n  and   \\<Psi>    :: \"'a::fs_name\"\n  and   yvec :: \"name list\"\n  and   \\<Psi>'   :: \"'a::fs_name\"\n\n  assumes \"\\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\"\n\n  obtains p where \"(set p) \\<subseteq> (set xvec) \\<times> set (yvec)\" and \"\\<Psi>' = p \\<bullet> \\<Psi>\"\nproof -\n  assume \"\\<And>p. \\<lbrakk>set p \\<subseteq> set xvec \\<times> set yvec; \\<Psi>' = p \\<bullet> \\<Psi>\\<rbrakk> \\<Longrightarrow> thesis\"\n  moreover obtain n where \"n = length xvec\" by auto\n  with assms have \"\\<exists>p. (set p) \\<subseteq> (set xvec) \\<times> set (yvec) \\<and> \\<Psi>' = p \\<bullet> \\<Psi>\"\n  proof(induct n arbitrary: xvec yvec \\<Psi> \\<Psi>')\n    case(0 xvec yvec \\<Psi> \\<Psi>')\n    have Eq: \"\\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\" by fact\n    from `0 = length xvec` have \"xvec = []\" by auto\n    moreover with Eq have \"yvec = []\"\n      by(case_tac yvec) auto\n    ultimately show ?case using Eq\n      by(simp add: frame.inject)\n  next\n    case(Suc n xvec yvec \\<Psi> \\<Psi>')\n    from `Suc n = length xvec`\n    obtain x xvec' where \"xvec = x#xvec'\" and \"length xvec' = n\"\n      by(case_tac xvec) auto\n    from `\\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>` `xvec = x # xvec'`\n    obtain y yvec' where \"\\<langle>(x#xvec'), \\<Psi>\\<rangle> = \\<langle>(y#yvec'), \\<Psi>'\\<rangle>\"\n      and \"yvec = y#yvec'\"\n      by(case_tac yvec) auto\n    hence EQ: \"\\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>*xvec'\\<rparr>(FAssert \\<Psi>) = \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>*yvec'\\<rparr>(FAssert \\<Psi>')\"\n      by simp\n    have IH: \"\\<And>xvec yvec \\<Psi> \\<Psi>'. \\<lbrakk>\\<langle>xvec, (\\<Psi>::'a)\\<rangle> = \\<langle>yvec, (\\<Psi>'::'a)\\<rangle>; n = length xvec\\<rbrakk> \\<Longrightarrow>\n                                 \\<exists>p. (set p) \\<subseteq> (set xvec) \\<times> (set yvec) \\<and> \\<Psi>' = p \\<bullet> \\<Psi>\"\n      by fact\n    show ?case\n    proof(cases \"x=y\")\n      case True\n      from EQ `x = y` have \"\\<langle>xvec', \\<Psi>\\<rangle> = \\<langle>yvec', \\<Psi>'\\<rangle>\" by(simp add: alpha frame.inject)\n      then obtain p where S: \"set p \\<subseteq> set xvec' \\<times> set yvec'\" and \"\\<Psi>' = p \\<bullet> \\<Psi>\" using `length xvec' = n` IH\n        by blast\n      from S have \"set((x, y)#p) \\<subseteq> set(x#xvec') \\<times> set (y#yvec')\" by auto\n      moreover from `x = y` `\\<Psi>' = p \\<bullet> \\<Psi>` have \"\\<Psi>' = ((x, y)#p) \\<bullet> \\<Psi>\" by auto\n      ultimately show ?thesis using `xvec = x#xvec'` `yvec = y#yvec'` by blast\n    next\n      case False\n      from EQ `x \\<noteq> y` have EQ': \"\\<langle>xvec', \\<Psi>\\<rangle> = ([(x, y)] \\<bullet> \\<langle>yvec', \\<Psi>'\\<rangle>)\" \n                       and xFresh\\<Psi>': \"x \\<sharp> \\<lparr>\\<nu>*yvec'\\<rparr>(FAssert \\<Psi>')\"\n        by(simp add: frame.inject alpha)+\n    \n      show ?thesis\n      proof(cases \"x \\<sharp> \\<langle>xvec', \\<Psi>\\<rangle>\")\n        case True\n        from EQ `x \\<sharp> \\<langle>xvec', \\<Psi>\\<rangle>` have \"y \\<sharp> \\<langle>yvec', \\<Psi>'\\<rangle>\"\n          by(rule frameEqFresh)\n        with xFresh\\<Psi>' EQ' have \"\\<langle>xvec', \\<Psi>\\<rangle> = \\<langle>yvec', \\<Psi>'\\<rangle>\" \n          by(simp)\n        with `length xvec' = n` IH\n        obtain p where S: \"(set p) \\<subseteq> (set xvec') \\<times> (set yvec')\" and \"\\<Psi>' = p \\<bullet> \\<Psi>\"\n          by blast\n        from S have \"(set p) \\<subseteq> set(x#xvec') \\<times> set(y#yvec')\" by auto\n        with `xvec = x#xvec'` `yvec=y#yvec'` `\\<Psi>' = p \\<bullet> \\<Psi>`\n        show ?thesis by blast\n      next\n        case False\n        from `\\<not>(x \\<sharp> \\<lparr>\\<nu>*xvec'\\<rparr>(FAssert \\<Psi>))` have xSupp\\<Psi>: \"x \\<in> supp(\\<langle>xvec', \\<Psi>\\<rangle>)\"\n          by(simp add: fresh_def)\n        with EQ have \"y \\<in> supp (\\<langle>yvec', \\<Psi>'\\<rangle>)\"\n          by(rule frameEqSupp)\n        hence \"y \\<sharp> yvec'\"\n          by(induct yvec') (auto simp add: frame.supp abs_supp)\n\n        with `x \\<sharp> yvec'` EQ' have \"\\<langle>xvec', \\<Psi>\\<rangle> = \\<langle>yvec', ([(x, y)] \\<bullet> \\<Psi>')\\<rangle>\"\n          by(simp add: eqvts)\n        with  `xvec' \\<sharp>* yvec'` `length xvec' = n` IH\n        obtain p where S: \"(set p) \\<subseteq> (set xvec') \\<times> (set yvec')\" and \"distinctPerm p\" and \"([(x, y)] \\<bullet> \\<Psi>') = p \\<bullet> \\<Psi>\"\n          by blast\n        \n        from xSupp\\<Psi> have \"x \\<sharp> xvec'\"\n          by(induct xvec') (auto simp add: frame.supp abs_supp)      \n        with `x \\<sharp> yvec'` `y \\<sharp> xvec'` `y \\<sharp> yvec'` S have \"x \\<sharp> p\" and \"y \\<sharp> p\"\n          apply(induct p)\n          by(auto simp add: name_list_supp) (auto simp add: fresh_def) \n        from S have \"(set ((x, y)#p)) \\<subseteq> (set(x#xvec')) \\<times> (set(y#yvec'))\"\n          by force\n        moreover from `x \\<noteq> y` `x \\<sharp> p` `y \\<sharp> p` S `distinctPerm p`\n        have \"distinctPerm((x,y)#p)\" by simp\n        moreover from `x \\<sharp> p` `y \\<sharp> p` `x \\<sharp> xvec'` `y \\<sharp> xvec'` have \"y#(p \\<bullet> xvec') = ((x, y)#p) \\<bullet> (x#xvec')\" \n          by(simp add: eqvts calc_atm freshChainSimps)\n        moreover from `([(x, y)] \\<bullet> \\<Psi>') = p \\<bullet> \\<Psi>`\n        have \"([(x, y)] \\<bullet> [(x, y)] \\<bullet> \\<Psi>') = [(x, y)] \\<bullet> p \\<bullet> \\<Psi>\"\n          by(simp add: pt_bij)\n        hence \"\\<Psi>' = ((x, y)#p) \\<bullet> \\<Psi>\" by simp\n        ultimately show ?case using `xvec=x#xvec'` `yvec=y#yvec'`\n          by blast\n      qed\n    qed\n    ultimately show ?thesis by blast\nqed\n*)"], ["", "lemma frameChainEq':\n  fixes xvec :: \"name list\"\n  and   \\<Psi>    :: \"'a::fs_name\"\n  and   yvec :: \"name list\"\n  and   \\<Psi>'   :: \"'a::fs_name\"\n\n  assumes \"\\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\"\n  and     \"xvec \\<sharp>* yvec\"\n  and     \"distinct xvec\"\n  and     \"distinct yvec\"\n\n  obtains p where \"(set p) \\<subseteq> (set xvec) \\<times> set (p \\<bullet> xvec)\" and \"distinctPerm p\" and \"yvec = p \\<bullet> xvec\" and \"\\<Psi>' = p \\<bullet> \\<Psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec);\n         distinctPerm p; yvec = p \\<bullet> xvec;\n         \\<Psi>' = p \\<bullet> \\<Psi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec);\n         distinctPerm p; yvec = p \\<bullet> xvec;\n         \\<Psi>' = p \\<bullet> \\<Psi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "assume \"\\<And>p. \\<lbrakk>set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec); distinctPerm p; yvec = p \\<bullet> xvec; \\<Psi>' = p \\<bullet> \\<Psi>\\<rbrakk> \\<Longrightarrow> thesis\""], ["proof (state)\nthis:\n  \\<lbrakk>set ?p \\<subseteq> set xvec \\<times> set (?p \\<bullet> xvec);\n   distinctPerm ?p; yvec = ?p \\<bullet> xvec;\n   \\<Psi>' = ?p \\<bullet> \\<Psi>\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec);\n         distinctPerm p; yvec = p \\<bullet> xvec;\n         \\<Psi>' = p \\<bullet> \\<Psi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>set ?p \\<subseteq> set xvec \\<times> set (?p \\<bullet> xvec);\n   distinctPerm ?p; yvec = ?p \\<bullet> xvec;\n   \\<Psi>' = ?p \\<bullet> \\<Psi>\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec);\n         distinctPerm p; yvec = p \\<bullet> xvec;\n         \\<Psi>' = p \\<bullet> \\<Psi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain n where \"n = length xvec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n. n = length xvec \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n = length xvec\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec);\n         distinctPerm p; yvec = p \\<bullet> xvec;\n         \\<Psi>' = p \\<bullet> \\<Psi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with assms"], ["proof (chain)\npicking this:\n  \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\n  xvec \\<sharp>* yvec\n  distinct xvec\n  distinct yvec\n  n = length xvec", "have \"\\<exists>p. (set p) \\<subseteq> (set xvec) \\<times> set (yvec) \\<and> distinctPerm p \\<and>  yvec = p \\<bullet> xvec \\<and> \\<Psi>' = p \\<bullet> \\<Psi>\""], ["proof (prove)\nusing this:\n  \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\n  xvec \\<sharp>* yvec\n  distinct xvec\n  distinct yvec\n  n = length xvec\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and>\n       yvec = p \\<bullet> xvec \\<and> \\<Psi>' = p \\<bullet> \\<Psi>", "proof(induct n arbitrary: xvec yvec \\<Psi> \\<Psi>')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        0 = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>\n 2. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "case(0 xvec yvec \\<Psi> \\<Psi>')"], ["proof (state)\nthis:\n  \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\n  xvec \\<sharp>* yvec\n  distinct xvec\n  distinct yvec\n  0 = length xvec\n\ngoal (2 subgoals):\n 1. \\<And>xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        0 = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>\n 2. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "have Eq: \"\\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>", "by fact"], ["proof (state)\nthis:\n  \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        0 = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>\n 2. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "from \\<open>0 = length xvec\\<close>"], ["proof (chain)\npicking this:\n  0 = length xvec", "have \"xvec = []\""], ["proof (prove)\nusing this:\n  0 = length xvec\n\ngoal (1 subgoal):\n 1. xvec = []", "by auto"], ["proof (state)\nthis:\n  xvec = []\n\ngoal (2 subgoals):\n 1. \\<And>xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        0 = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>\n 2. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "moreover"], ["proof (state)\nthis:\n  xvec = []\n\ngoal (2 subgoals):\n 1. \\<And>xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        0 = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>\n 2. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "with Eq"], ["proof (chain)\npicking this:\n  \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\n  xvec = []", "have \"yvec = []\""], ["proof (prove)\nusing this:\n  \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\n  xvec = []\n\ngoal (1 subgoal):\n 1. yvec = []", "by(case_tac yvec) auto"], ["proof (state)\nthis:\n  yvec = []\n\ngoal (2 subgoals):\n 1. \\<And>xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        0 = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>\n 2. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "ultimately"], ["proof (chain)\npicking this:\n  xvec = []\n  yvec = []", "show ?case"], ["proof (prove)\nusing this:\n  xvec = []\n  yvec = []\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and>\n       yvec = p \\<bullet> xvec \\<and> \\<Psi>' = p \\<bullet> \\<Psi>", "using Eq"], ["proof (prove)\nusing this:\n  xvec = []\n  yvec = []\n  \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and>\n       yvec = p \\<bullet> xvec \\<and> \\<Psi>' = p \\<bullet> \\<Psi>", "by(simp add: frame.inject)"], ["proof (state)\nthis:\n  \\<exists>p.\n     set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n     distinctPerm p \\<and>\n     yvec = p \\<bullet> xvec \\<and> \\<Psi>' = p \\<bullet> \\<Psi>\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "case(Suc n xvec yvec \\<Psi> \\<Psi>')"], ["proof (state)\nthis:\n  \\<lbrakk>\\<langle>?xvec, ?\\<Psi>\\<rangle> =\n           \\<langle>?yvec, ?\\<Psi>'\\<rangle>;\n   ?xvec \\<sharp>* ?yvec; distinct ?xvec; distinct ?yvec;\n   n = length ?xvec\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       set p \\<subseteq> set ?xvec \\<times> set ?yvec \\<and>\n                       distinctPerm p \\<and>\n                       ?yvec = p \\<bullet> ?xvec \\<and>\n                       ?\\<Psi>' = p \\<bullet> ?\\<Psi>\n  \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\n  xvec \\<sharp>* yvec\n  distinct xvec\n  distinct yvec\n  Suc n = length xvec\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "from \\<open>Suc n = length xvec\\<close>"], ["proof (chain)\npicking this:\n  Suc n = length xvec", "obtain x xvec' where \"xvec = x#xvec'\" and \"length xvec' = n\""], ["proof (prove)\nusing this:\n  Suc n = length xvec\n\ngoal (1 subgoal):\n 1. (\\<And>x xvec'.\n        \\<lbrakk>xvec = x # xvec'; length xvec' = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(case_tac xvec) auto"], ["proof (state)\nthis:\n  xvec = x # xvec'\n  length xvec' = n\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "from \\<open>\\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\\<close> \\<open>xvec = x # xvec'\\<close>"], ["proof (chain)\npicking this:\n  \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\n  xvec = x # xvec'", "obtain y yvec' where \"\\<langle>(x#xvec'), \\<Psi>\\<rangle> = \\<langle>(y#yvec'), \\<Psi>'\\<rangle>\"\n      and \"yvec = y#yvec'\""], ["proof (prove)\nusing this:\n  \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>\n  xvec = x # xvec'\n\ngoal (1 subgoal):\n 1. (\\<And>y yvec'.\n        \\<lbrakk>\\<langle>(x # xvec'), \\<Psi>\\<rangle> =\n                 \\<langle>(y # yvec'), \\<Psi>'\\<rangle>;\n         yvec = y # yvec'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(case_tac yvec) auto"], ["proof (state)\nthis:\n  \\<langle>(x # xvec'), \\<Psi>\\<rangle> =\n  \\<langle>(y # yvec'), \\<Psi>'\\<rangle>\n  yvec = y # yvec'\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "hence EQ: \"\\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>*xvec'\\<rparr>(FAssert \\<Psi>) = \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>*yvec'\\<rparr>(FAssert \\<Psi>')\""], ["proof (prove)\nusing this:\n  \\<langle>(x # xvec'), \\<Psi>\\<rangle> =\n  \\<langle>(y # yvec'), \\<Psi>'\\<rangle>\n  yvec = y # yvec'\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>\\<langle>xvec', \\<Psi>\\<rangle> =\n    \\<lparr>\\<nu>y\\<rparr>\\<langle>yvec', \\<Psi>'\\<rangle>", "by simp"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>\\<langle>xvec', \\<Psi>\\<rangle> =\n  \\<lparr>\\<nu>y\\<rparr>\\<langle>yvec', \\<Psi>'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "from \\<open>xvec = x#xvec'\\<close> \\<open>yvec=y#yvec'\\<close> \\<open>xvec \\<sharp>* yvec\\<close>"], ["proof (chain)\npicking this:\n  xvec = x # xvec'\n  yvec = y # yvec'\n  xvec \\<sharp>* yvec", "have \"x \\<noteq> y\" and \"xvec' \\<sharp>* yvec'\" and \"x \\<sharp> yvec'\" and \"y \\<sharp> xvec'\""], ["proof (prove)\nusing this:\n  xvec = x # xvec'\n  yvec = y # yvec'\n  xvec \\<sharp>* yvec\n\ngoal (1 subgoal):\n 1. (x \\<noteq> y &&& xvec' \\<sharp>* yvec') &&&\n    x \\<sharp> yvec' &&& y \\<sharp> xvec'", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> y\n  xvec' \\<sharp>* yvec'\n  x \\<sharp> yvec'\n  y \\<sharp> xvec'\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "from \\<open>distinct xvec\\<close> \\<open>distinct yvec\\<close> \\<open>xvec=x#xvec'\\<close> \\<open>yvec=y#yvec'\\<close>"], ["proof (chain)\npicking this:\n  distinct xvec\n  distinct yvec\n  xvec = x # xvec'\n  yvec = y # yvec'", "have \"x \\<sharp> xvec'\" and \"y \\<sharp> yvec'\" and \"distinct xvec'\" and \"distinct yvec'\""], ["proof (prove)\nusing this:\n  distinct xvec\n  distinct yvec\n  xvec = x # xvec'\n  yvec = y # yvec'\n\ngoal (1 subgoal):\n 1. (x \\<sharp> xvec' &&& y \\<sharp> yvec') &&&\n    distinct xvec' &&& distinct yvec'", "by simp+"], ["proof (state)\nthis:\n  x \\<sharp> xvec'\n  y \\<sharp> yvec'\n  distinct xvec'\n  distinct yvec'\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "have IH: \"\\<And>xvec yvec \\<Psi> \\<Psi>'. \\<lbrakk>\\<langle>xvec, (\\<Psi>::'a)\\<rangle> = \\<langle>yvec, (\\<Psi>'::'a)\\<rangle>; xvec \\<sharp>* yvec; distinct xvec; distinct yvec; n = length xvec\\<rbrakk> \\<Longrightarrow> \\<exists>p. (set p) \\<subseteq> (set xvec) \\<times> (set yvec) \\<and> distinctPerm p \\<and>  yvec = p \\<bullet> xvec \\<and> \\<Psi>' = p \\<bullet> \\<Psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "by fact"], ["proof (state)\nthis:\n  \\<lbrakk>\\<langle>?xvec, ?\\<Psi>\\<rangle> =\n           \\<langle>?yvec, ?\\<Psi>'\\<rangle>;\n   ?xvec \\<sharp>* ?yvec; distinct ?xvec; distinct ?yvec;\n   n = length ?xvec\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       set p \\<subseteq> set ?xvec \\<times> set ?yvec \\<and>\n                       distinctPerm p \\<and>\n                       ?yvec = p \\<bullet> ?xvec \\<and>\n                       ?\\<Psi>' = p \\<bullet> ?\\<Psi>\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "from EQ \\<open>x \\<noteq> y\\<close>  \\<open>x \\<sharp> yvec'\\<close> \\<open>y \\<sharp> yvec'\\<close>"], ["proof (chain)\npicking this:\n  \\<lparr>\\<nu>x\\<rparr>\\<langle>xvec', \\<Psi>\\<rangle> =\n  \\<lparr>\\<nu>y\\<rparr>\\<langle>yvec', \\<Psi>'\\<rangle>\n  x \\<noteq> y\n  x \\<sharp> yvec'\n  y \\<sharp> yvec'", "have \"\\<langle>xvec', \\<Psi>\\<rangle> = \\<langle>yvec', ([(x, y)] \\<bullet> \\<Psi>')\\<rangle>\""], ["proof (prove)\nusing this:\n  \\<lparr>\\<nu>x\\<rparr>\\<langle>xvec', \\<Psi>\\<rangle> =\n  \\<lparr>\\<nu>y\\<rparr>\\<langle>yvec', \\<Psi>'\\<rangle>\n  x \\<noteq> y\n  x \\<sharp> yvec'\n  y \\<sharp> yvec'\n\ngoal (1 subgoal):\n 1. \\<langle>xvec', \\<Psi>\\<rangle> =\n    \\<langle>yvec', [(x, y)] \\<bullet> \\<Psi>'\\<rangle>", "by(simp add: frame.inject alpha eqvts)"], ["proof (state)\nthis:\n  \\<langle>xvec', \\<Psi>\\<rangle> =\n  \\<langle>yvec', [(x, y)] \\<bullet> \\<Psi>'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "with \\<open>xvec' \\<sharp>* yvec'\\<close> \\<open>distinct xvec'\\<close> \\<open>distinct yvec'\\<close> \\<open>length xvec' = n\\<close> IH"], ["proof (chain)\npicking this:\n  xvec' \\<sharp>* yvec'\n  distinct xvec'\n  distinct yvec'\n  length xvec' = n\n  \\<lbrakk>\\<langle>?xvec, ?\\<Psi>\\<rangle> =\n           \\<langle>?yvec, ?\\<Psi>'\\<rangle>;\n   ?xvec \\<sharp>* ?yvec; distinct ?xvec; distinct ?yvec;\n   n = length ?xvec\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       set p \\<subseteq> set ?xvec \\<times> set ?yvec \\<and>\n                       distinctPerm p \\<and>\n                       ?yvec = p \\<bullet> ?xvec \\<and>\n                       ?\\<Psi>' = p \\<bullet> ?\\<Psi>\n  \\<langle>xvec', \\<Psi>\\<rangle> =\n  \\<langle>yvec', [(x, y)] \\<bullet> \\<Psi>'\\<rangle>", "obtain p where S: \"(set p) \\<subseteq> (set xvec') \\<times> (set yvec')\" and \"distinctPerm p\" and \"yvec' = p \\<bullet> xvec'\" and \"[(x, y)] \\<bullet> \\<Psi>' = p \\<bullet> \\<Psi>\""], ["proof (prove)\nusing this:\n  xvec' \\<sharp>* yvec'\n  distinct xvec'\n  distinct yvec'\n  length xvec' = n\n  \\<lbrakk>\\<langle>?xvec, ?\\<Psi>\\<rangle> =\n           \\<langle>?yvec, ?\\<Psi>'\\<rangle>;\n   ?xvec \\<sharp>* ?yvec; distinct ?xvec; distinct ?yvec;\n   n = length ?xvec\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       set p \\<subseteq> set ?xvec \\<times> set ?yvec \\<and>\n                       distinctPerm p \\<and>\n                       ?yvec = p \\<bullet> ?xvec \\<and>\n                       ?\\<Psi>' = p \\<bullet> ?\\<Psi>\n  \\<langle>xvec', \\<Psi>\\<rangle> =\n  \\<langle>yvec', [(x, y)] \\<bullet> \\<Psi>'\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>set p \\<subseteq> set xvec' \\<times> set yvec';\n         distinctPerm p; yvec' = p \\<bullet> xvec';\n         [(x, y)] \\<bullet> \\<Psi>' = p \\<bullet> \\<Psi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  set p \\<subseteq> set xvec' \\<times> set yvec'\n  distinctPerm p\n  yvec' = p \\<bullet> xvec'\n  [(x, y)] \\<bullet> \\<Psi>' = p \\<bullet> \\<Psi>\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "from S"], ["proof (chain)\npicking this:\n  set p \\<subseteq> set xvec' \\<times> set yvec'", "have \"set((x, y)#p) \\<subseteq> set(x#xvec') \\<times> set(y#yvec')\""], ["proof (prove)\nusing this:\n  set p \\<subseteq> set xvec' \\<times> set yvec'\n\ngoal (1 subgoal):\n 1. set ((x, y) # p) \\<subseteq> set (x # xvec') \\<times> set (y # yvec')", "by auto"], ["proof (state)\nthis:\n  set ((x, y) # p) \\<subseteq> set (x # xvec') \\<times> set (y # yvec')\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "moreover"], ["proof (state)\nthis:\n  set ((x, y) # p) \\<subseteq> set (x # xvec') \\<times> set (y # yvec')\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "from \\<open>x \\<sharp> xvec'\\<close> \\<open>x \\<sharp> yvec'\\<close> \\<open>y \\<sharp> xvec'\\<close> \\<open>y \\<sharp> yvec'\\<close> S"], ["proof (chain)\npicking this:\n  x \\<sharp> xvec'\n  x \\<sharp> yvec'\n  y \\<sharp> xvec'\n  y \\<sharp> yvec'\n  set p \\<subseteq> set xvec' \\<times> set yvec'", "have \"x \\<sharp> p\" and \"y \\<sharp> p\""], ["proof (prove)\nusing this:\n  x \\<sharp> xvec'\n  x \\<sharp> yvec'\n  y \\<sharp> xvec'\n  y \\<sharp> yvec'\n  set p \\<subseteq> set xvec' \\<times> set yvec'\n\ngoal (1 subgoal):\n 1. x \\<sharp> p &&& y \\<sharp> p", "apply(induct p)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>x \\<sharp> xvec'; x \\<sharp> yvec'; y \\<sharp> xvec';\n     y \\<sharp> yvec';\n     set [] \\<subseteq> set xvec' \\<times> set yvec'\\<rbrakk>\n    \\<Longrightarrow> x \\<sharp> []\n 2. \\<lbrakk>x \\<sharp> xvec'; x \\<sharp> yvec'; y \\<sharp> xvec';\n     y \\<sharp> yvec';\n     set [] \\<subseteq> set xvec' \\<times> set yvec'\\<rbrakk>\n    \\<Longrightarrow> y \\<sharp> []\n 3. \\<And>a p.\n       \\<lbrakk>\\<lbrakk>x \\<sharp> xvec'; x \\<sharp> yvec';\n                 y \\<sharp> xvec'; y \\<sharp> yvec';\n                 set p \\<subseteq> set xvec' \\<times> set yvec'\\<rbrakk>\n                \\<Longrightarrow> x \\<sharp> p;\n        \\<lbrakk>x \\<sharp> xvec'; x \\<sharp> yvec'; y \\<sharp> xvec';\n         y \\<sharp> yvec';\n         set p \\<subseteq> set xvec' \\<times> set yvec'\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> p;\n        x \\<sharp> xvec'; x \\<sharp> yvec'; y \\<sharp> xvec';\n        y \\<sharp> yvec';\n        set (a # p) \\<subseteq> set xvec' \\<times> set yvec'\\<rbrakk>\n       \\<Longrightarrow> x \\<sharp> (a # p)\n 4. \\<And>a p.\n       \\<lbrakk>\\<lbrakk>x \\<sharp> xvec'; x \\<sharp> yvec';\n                 y \\<sharp> xvec'; y \\<sharp> yvec';\n                 set p \\<subseteq> set xvec' \\<times> set yvec'\\<rbrakk>\n                \\<Longrightarrow> x \\<sharp> p;\n        \\<lbrakk>x \\<sharp> xvec'; x \\<sharp> yvec'; y \\<sharp> xvec';\n         y \\<sharp> yvec';\n         set p \\<subseteq> set xvec' \\<times> set yvec'\\<rbrakk>\n        \\<Longrightarrow> y \\<sharp> p;\n        x \\<sharp> xvec'; x \\<sharp> yvec'; y \\<sharp> xvec';\n        y \\<sharp> yvec';\n        set (a # p) \\<subseteq> set xvec' \\<times> set yvec'\\<rbrakk>\n       \\<Longrightarrow> y \\<sharp> (a # p)", "by(auto simp add: name_list_supp) (auto simp add: fresh_def)"], ["proof (state)\nthis:\n  x \\<sharp> p\n  y \\<sharp> p\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "with S \\<open>distinctPerm p\\<close> \\<open>x \\<noteq> y\\<close>"], ["proof (chain)\npicking this:\n  set p \\<subseteq> set xvec' \\<times> set yvec'\n  distinctPerm p\n  x \\<noteq> y\n  x \\<sharp> p\n  y \\<sharp> p", "have \"distinctPerm((x, y)#p)\""], ["proof (prove)\nusing this:\n  set p \\<subseteq> set xvec' \\<times> set yvec'\n  distinctPerm p\n  x \\<noteq> y\n  x \\<sharp> p\n  y \\<sharp> p\n\ngoal (1 subgoal):\n 1. distinctPerm ((x, y) # p)", "by auto"], ["proof (state)\nthis:\n  distinctPerm ((x, y) # p)\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "moreover"], ["proof (state)\nthis:\n  distinctPerm ((x, y) # p)\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "from \\<open>yvec' = p \\<bullet> xvec'\\<close> \\<open>x \\<sharp> p\\<close> \\<open>y \\<sharp> p\\<close> \\<open>x \\<sharp> xvec'\\<close> \\<open>y \\<sharp> xvec'\\<close>"], ["proof (chain)\npicking this:\n  yvec' = p \\<bullet> xvec'\n  x \\<sharp> p\n  y \\<sharp> p\n  x \\<sharp> xvec'\n  y \\<sharp> xvec'", "have \"(y#yvec') = ((x, y)#p) \\<bullet> (x#xvec')\""], ["proof (prove)\nusing this:\n  yvec' = p \\<bullet> xvec'\n  x \\<sharp> p\n  y \\<sharp> p\n  x \\<sharp> xvec'\n  y \\<sharp> xvec'\n\ngoal (1 subgoal):\n 1. y # yvec' = ((x, y) # p) \\<bullet> (x # xvec')", "by(simp add: freshChainSimps calc_atm)"], ["proof (state)\nthis:\n  y # yvec' = ((x, y) # p) \\<bullet> (x # xvec')\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "moreover"], ["proof (state)\nthis:\n  y # yvec' = ((x, y) # p) \\<bullet> (x # xvec')\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "from \\<open>([(x, y)] \\<bullet> \\<Psi>') = p \\<bullet> \\<Psi>\\<close>"], ["proof (chain)\npicking this:\n  [(x, y)] \\<bullet> \\<Psi>' = p \\<bullet> \\<Psi>", "have \"([(x, y)] \\<bullet> [(x, y)] \\<bullet> \\<Psi>') = [(x, y)] \\<bullet> p \\<bullet> \\<Psi>\""], ["proof (prove)\nusing this:\n  [(x, y)] \\<bullet> \\<Psi>' = p \\<bullet> \\<Psi>\n\ngoal (1 subgoal):\n 1. [(x, y)] \\<bullet> [(x, y)] \\<bullet> \\<Psi>' =\n    [(x, y)] \\<bullet> p \\<bullet> \\<Psi>", "by(simp add: pt_bij)"], ["proof (state)\nthis:\n  [(x, y)] \\<bullet> [(x, y)] \\<bullet> \\<Psi>' =\n  [(x, y)] \\<bullet> p \\<bullet> \\<Psi>\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "hence \"\\<Psi>' = ((x, y)#p) \\<bullet> \\<Psi>\""], ["proof (prove)\nusing this:\n  [(x, y)] \\<bullet> [(x, y)] \\<bullet> \\<Psi>' =\n  [(x, y)] \\<bullet> p \\<bullet> \\<Psi>\n\ngoal (1 subgoal):\n 1. \\<Psi>' = ((x, y) # p) \\<bullet> \\<Psi>", "by simp"], ["proof (state)\nthis:\n  \\<Psi>' = ((x, y) # p) \\<bullet> \\<Psi>\n\ngoal (1 subgoal):\n 1. \\<And>n xvec yvec \\<Psi> \\<Psi>'.\n       \\<lbrakk>\\<And>xvec yvec \\<Psi> \\<Psi>'.\n                   \\<lbrakk>\\<langle>xvec, \\<Psi>\\<rangle> =\n                            \\<langle>yvec, \\<Psi>'\\<rangle>;\n                    xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n                    n = length xvec\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p.\n  set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n  distinctPerm p \\<and>\n  yvec = p \\<bullet> xvec \\<and> \\<Psi>' = p \\<bullet> \\<Psi>;\n        \\<langle>xvec, \\<Psi>\\<rangle> = \\<langle>yvec, \\<Psi>'\\<rangle>;\n        xvec \\<sharp>* yvec; distinct xvec; distinct yvec;\n        Suc n = length xvec\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            set p\n                            \\<subseteq> set xvec \\<times> set yvec \\<and>\n                            distinctPerm p \\<and>\n                            yvec = p \\<bullet> xvec \\<and>\n                            \\<Psi>' = p \\<bullet> \\<Psi>", "ultimately"], ["proof (chain)\npicking this:\n  set ((x, y) # p) \\<subseteq> set (x # xvec') \\<times> set (y # yvec')\n  distinctPerm ((x, y) # p)\n  y # yvec' = ((x, y) # p) \\<bullet> (x # xvec')\n  \\<Psi>' = ((x, y) # p) \\<bullet> \\<Psi>", "show ?case"], ["proof (prove)\nusing this:\n  set ((x, y) # p) \\<subseteq> set (x # xvec') \\<times> set (y # yvec')\n  distinctPerm ((x, y) # p)\n  y # yvec' = ((x, y) # p) \\<bullet> (x # xvec')\n  \\<Psi>' = ((x, y) # p) \\<bullet> \\<Psi>\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and>\n       yvec = p \\<bullet> xvec \\<and> \\<Psi>' = p \\<bullet> \\<Psi>", "using \\<open>xvec=x#xvec'\\<close> \\<open>yvec=y#yvec'\\<close>"], ["proof (prove)\nusing this:\n  set ((x, y) # p) \\<subseteq> set (x # xvec') \\<times> set (y # yvec')\n  distinctPerm ((x, y) # p)\n  y # yvec' = ((x, y) # p) \\<bullet> (x # xvec')\n  \\<Psi>' = ((x, y) # p) \\<bullet> \\<Psi>\n  xvec = x # xvec'\n  yvec = y # yvec'\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n       distinctPerm p \\<and>\n       yvec = p \\<bullet> xvec \\<and> \\<Psi>' = p \\<bullet> \\<Psi>", "by blast"], ["proof (state)\nthis:\n  \\<exists>p.\n     set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n     distinctPerm p \\<and>\n     yvec = p \\<bullet> xvec \\<and> \\<Psi>' = p \\<bullet> \\<Psi>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>p.\n     set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n     distinctPerm p \\<and>\n     yvec = p \\<bullet> xvec \\<and> \\<Psi>' = p \\<bullet> \\<Psi>\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>set p \\<subseteq> set xvec \\<times> set (p \\<bullet> xvec);\n         distinctPerm p; yvec = p \\<bullet> xvec;\n         \\<Psi>' = p \\<bullet> \\<Psi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>set ?p \\<subseteq> set xvec \\<times> set (?p \\<bullet> xvec);\n   distinctPerm ?p; yvec = ?p \\<bullet> xvec;\n   \\<Psi>' = ?p \\<bullet> \\<Psi>\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<exists>p.\n     set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n     distinctPerm p \\<and>\n     yvec = p \\<bullet> xvec \\<and> \\<Psi>' = p \\<bullet> \\<Psi>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>set ?p \\<subseteq> set xvec \\<times> set (?p \\<bullet> xvec);\n   distinctPerm ?p; yvec = ?p \\<bullet> xvec;\n   \\<Psi>' = ?p \\<bullet> \\<Psi>\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<exists>p.\n     set p \\<subseteq> set xvec \\<times> set yvec \\<and>\n     distinctPerm p \\<and>\n     yvec = p \\<bullet> xvec \\<and> \\<Psi>' = p \\<bullet> \\<Psi>\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma frameEq[simp]:\n  fixes A\\<^sub>F :: \"name list\"\n  and   \\<Psi>  :: \"'a::fs_name\"\n  and   \\<Psi>'  :: 'a\n\n  shows \"\\<langle>A\\<^sub>F, \\<Psi>\\<rangle> = \\<langle>\\<epsilon>, \\<Psi>'\\<rangle> = (A\\<^sub>F = [] \\<and> \\<Psi> = \\<Psi>')\"\n  and   \"\\<langle>\\<epsilon>, \\<Psi>'\\<rangle> = \\<langle>A\\<^sub>F, \\<Psi>\\<rangle>  = (A\\<^sub>F = [] \\<and> \\<Psi> = \\<Psi>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<langle>A\\<^sub>F, \\<Psi>\\<rangle> =\n     \\<langle>\\<epsilon>, \\<Psi>'\\<rangle>) =\n    (A\\<^sub>F = [] \\<and> \\<Psi> = \\<Psi>') &&&\n    (\\<langle>\\<epsilon>, \\<Psi>'\\<rangle> =\n     \\<langle>A\\<^sub>F, \\<Psi>\\<rangle>) =\n    (A\\<^sub>F = [] \\<and> \\<Psi> = \\<Psi>')", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<langle>A\\<^sub>F, \\<Psi>\\<rangle> =\n     \\<langle>\\<epsilon>, \\<Psi>'\\<rangle>) =\n    (A\\<^sub>F = [] \\<and> \\<Psi> = \\<Psi>')\n 2. (\\<langle>\\<epsilon>, \\<Psi>'\\<rangle> =\n     \\<langle>A\\<^sub>F, \\<Psi>\\<rangle>) =\n    (A\\<^sub>F = [] \\<and> \\<Psi> = \\<Psi>')", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<langle>A\\<^sub>F, \\<Psi>\\<rangle> =\n     \\<langle>\\<epsilon>, \\<Psi>'\\<rangle>) =\n    (A\\<^sub>F = [] \\<and> \\<Psi> = \\<Psi>')\n 2. (\\<langle>\\<epsilon>, \\<Psi>'\\<rangle> =\n     \\<langle>A\\<^sub>F, \\<Psi>\\<rangle>) =\n    (A\\<^sub>F = [] \\<and> \\<Psi> = \\<Psi>')", "assume \"\\<langle>A\\<^sub>F, \\<Psi>\\<rangle> = \\<langle>\\<epsilon>, \\<Psi>'\\<rangle>\""], ["proof (state)\nthis:\n  \\<langle>A\\<^sub>F, \\<Psi>\\<rangle> =\n  \\<langle>\\<epsilon>, \\<Psi>'\\<rangle>\n\ngoal (2 subgoals):\n 1. (\\<langle>A\\<^sub>F, \\<Psi>\\<rangle> =\n     \\<langle>\\<epsilon>, \\<Psi>'\\<rangle>) =\n    (A\\<^sub>F = [] \\<and> \\<Psi> = \\<Psi>')\n 2. (\\<langle>\\<epsilon>, \\<Psi>'\\<rangle> =\n     \\<langle>A\\<^sub>F, \\<Psi>\\<rangle>) =\n    (A\\<^sub>F = [] \\<and> \\<Psi> = \\<Psi>')", "hence A: \"\\<langle>A\\<^sub>F, \\<Psi>\\<rangle> = \\<langle>[], \\<Psi>'\\<rangle>\""], ["proof (prove)\nusing this:\n  \\<langle>A\\<^sub>F, \\<Psi>\\<rangle> =\n  \\<langle>\\<epsilon>, \\<Psi>'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>A\\<^sub>F, \\<Psi>\\<rangle> = \\<langle>[], \\<Psi>'\\<rangle>", "by simp"], ["proof (state)\nthis:\n  \\<langle>A\\<^sub>F, \\<Psi>\\<rangle> = \\<langle>[], \\<Psi>'\\<rangle>\n\ngoal (2 subgoals):\n 1. (\\<langle>A\\<^sub>F, \\<Psi>\\<rangle> =\n     \\<langle>\\<epsilon>, \\<Psi>'\\<rangle>) =\n    (A\\<^sub>F = [] \\<and> \\<Psi> = \\<Psi>')\n 2. (\\<langle>\\<epsilon>, \\<Psi>'\\<rangle> =\n     \\<langle>A\\<^sub>F, \\<Psi>\\<rangle>) =\n    (A\\<^sub>F = [] \\<and> \\<Psi> = \\<Psi>')", "hence \"length A\\<^sub>F = length ([]::name list)\""], ["proof (prove)\nusing this:\n  \\<langle>A\\<^sub>F, \\<Psi>\\<rangle> = \\<langle>[], \\<Psi>'\\<rangle>\n\ngoal (1 subgoal):\n 1. length A\\<^sub>F = length []", "by(rule frameChainEqLength)"], ["proof (state)\nthis:\n  length A\\<^sub>F = length []\n\ngoal (2 subgoals):\n 1. (\\<langle>A\\<^sub>F, \\<Psi>\\<rangle> =\n     \\<langle>\\<epsilon>, \\<Psi>'\\<rangle>) =\n    (A\\<^sub>F = [] \\<and> \\<Psi> = \\<Psi>')\n 2. (\\<langle>\\<epsilon>, \\<Psi>'\\<rangle> =\n     \\<langle>A\\<^sub>F, \\<Psi>\\<rangle>) =\n    (A\\<^sub>F = [] \\<and> \\<Psi> = \\<Psi>')", "with A"], ["proof (chain)\npicking this:\n  \\<langle>A\\<^sub>F, \\<Psi>\\<rangle> = \\<langle>[], \\<Psi>'\\<rangle>\n  length A\\<^sub>F = length []", "have \"A\\<^sub>F = []\" and \"\\<Psi> = \\<Psi>'\""], ["proof (prove)\nusing this:\n  \\<langle>A\\<^sub>F, \\<Psi>\\<rangle> = \\<langle>[], \\<Psi>'\\<rangle>\n  length A\\<^sub>F = length []\n\ngoal (1 subgoal):\n 1. A\\<^sub>F = [] &&& \\<Psi> = \\<Psi>'", "by(auto simp add: frame.inject)"], ["proof (state)\nthis:\n  A\\<^sub>F = []\n  \\<Psi> = \\<Psi>'\n\ngoal (2 subgoals):\n 1. (\\<langle>A\\<^sub>F, \\<Psi>\\<rangle> =\n     \\<langle>\\<epsilon>, \\<Psi>'\\<rangle>) =\n    (A\\<^sub>F = [] \\<and> \\<Psi> = \\<Psi>')\n 2. (\\<langle>\\<epsilon>, \\<Psi>'\\<rangle> =\n     \\<langle>A\\<^sub>F, \\<Psi>\\<rangle>) =\n    (A\\<^sub>F = [] \\<and> \\<Psi> = \\<Psi>')", "}"], ["proof (state)\nthis:\n  \\<langle>A\\<^sub>F, \\<Psi>\\<rangle> =\n  \\<langle>\\<epsilon>, \\<Psi>'\\<rangle> \\<Longrightarrow>\n  A\\<^sub>F = []\n  \\<langle>A\\<^sub>F, \\<Psi>\\<rangle> =\n  \\<langle>\\<epsilon>, \\<Psi>'\\<rangle> \\<Longrightarrow>\n  \\<Psi> = \\<Psi>'\n\ngoal (2 subgoals):\n 1. (\\<langle>A\\<^sub>F, \\<Psi>\\<rangle> =\n     \\<langle>\\<epsilon>, \\<Psi>'\\<rangle>) =\n    (A\\<^sub>F = [] \\<and> \\<Psi> = \\<Psi>')\n 2. (\\<langle>\\<epsilon>, \\<Psi>'\\<rangle> =\n     \\<langle>A\\<^sub>F, \\<Psi>\\<rangle>) =\n    (A\\<^sub>F = [] \\<and> \\<Psi> = \\<Psi>')", "thus \"\\<langle>A\\<^sub>F, \\<Psi>\\<rangle> = \\<langle>\\<epsilon>, \\<Psi>'\\<rangle> = (A\\<^sub>F = [] \\<and> \\<Psi> = \\<Psi>')\"\n  and  \"\\<langle>\\<epsilon>, \\<Psi>'\\<rangle> = \\<langle>A\\<^sub>F, \\<Psi>\\<rangle>  = (A\\<^sub>F = [] \\<and> \\<Psi> = \\<Psi>')\""], ["proof (prove)\nusing this:\n  \\<langle>A\\<^sub>F, \\<Psi>\\<rangle> =\n  \\<langle>\\<epsilon>, \\<Psi>'\\<rangle> \\<Longrightarrow>\n  A\\<^sub>F = []\n  \\<langle>A\\<^sub>F, \\<Psi>\\<rangle> =\n  \\<langle>\\<epsilon>, \\<Psi>'\\<rangle> \\<Longrightarrow>\n  \\<Psi> = \\<Psi>'\n\ngoal (1 subgoal):\n 1. (\\<langle>A\\<^sub>F, \\<Psi>\\<rangle> =\n     \\<langle>\\<epsilon>, \\<Psi>'\\<rangle>) =\n    (A\\<^sub>F = [] \\<and> \\<Psi> = \\<Psi>') &&&\n    (\\<langle>\\<epsilon>, \\<Psi>'\\<rangle> =\n     \\<langle>A\\<^sub>F, \\<Psi>\\<rangle>) =\n    (A\\<^sub>F = [] \\<and> \\<Psi> = \\<Psi>')", "by auto"], ["proof (state)\nthis:\n  (\\<langle>A\\<^sub>F, \\<Psi>\\<rangle> =\n   \\<langle>\\<epsilon>, \\<Psi>'\\<rangle>) =\n  (A\\<^sub>F = [] \\<and> \\<Psi> = \\<Psi>')\n  (\\<langle>\\<epsilon>, \\<Psi>'\\<rangle> =\n   \\<langle>A\\<^sub>F, \\<Psi>\\<rangle>) =\n  (A\\<^sub>F = [] \\<and> \\<Psi> = \\<Psi>')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinctFrame:\n  fixes A\\<^sub>F :: \"name list\"\n  and   \\<Psi>\\<^sub>F :: \"'a::fs_name\"\n  and   C  :: \"'b::fs_name\"\n  \n  assumes \"A\\<^sub>F \\<sharp>* C\"\n\n  obtains A\\<^sub>F' where  \"\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> = \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle>\" and \"distinct A\\<^sub>F'\" and \"A\\<^sub>F' \\<sharp>* C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A\\<^sub>F'.\n        \\<lbrakk>\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n                 \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle>;\n         distinct A\\<^sub>F'; A\\<^sub>F' \\<sharp>* C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>A\\<^sub>F'.\n        \\<lbrakk>\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n                 \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle>;\n         distinct A\\<^sub>F'; A\\<^sub>F' \\<sharp>* C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "assume \"\\<And>A\\<^sub>F'. \\<lbrakk>\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> = \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle>; distinct A\\<^sub>F'; A\\<^sub>F' \\<sharp>* C\\<rbrakk> \\<Longrightarrow> thesis\""], ["proof (state)\nthis:\n  \\<lbrakk>\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n           \\<langle>?A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle>;\n   distinct ?A\\<^sub>F'; ?A\\<^sub>F' \\<sharp>* C\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<And>A\\<^sub>F'.\n        \\<lbrakk>\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n                 \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle>;\n         distinct A\\<^sub>F'; A\\<^sub>F' \\<sharp>* C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n           \\<langle>?A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle>;\n   distinct ?A\\<^sub>F'; ?A\\<^sub>F' \\<sharp>* C\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<And>A\\<^sub>F'.\n        \\<lbrakk>\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n                 \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle>;\n         distinct A\\<^sub>F'; A\\<^sub>F' \\<sharp>* C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  A\\<^sub>F \\<sharp>* C", "have \"\\<exists>A\\<^sub>F'. \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> = \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<and> distinct A\\<^sub>F' \\<and> A\\<^sub>F' \\<sharp>* C\""], ["proof (prove)\nusing this:\n  A\\<^sub>F \\<sharp>* C\n\ngoal (1 subgoal):\n 1. \\<exists>A\\<^sub>F'.\n       \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n       \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       distinct A\\<^sub>F' \\<and> A\\<^sub>F' \\<sharp>* C", "proof(induct A\\<^sub>F)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<sharp>* C \\<Longrightarrow>\n    \\<exists>A\\<^sub>F'.\n       \\<langle>[], \\<Psi>\\<^sub>F\\<rangle> =\n       \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       distinct A\\<^sub>F' \\<and> A\\<^sub>F' \\<sharp>* C\n 2. \\<And>a A\\<^sub>F.\n       \\<lbrakk>A\\<^sub>F \\<sharp>* C \\<Longrightarrow>\n                \\<exists>A\\<^sub>F'.\n                   \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n                   \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                   distinct A\\<^sub>F' \\<and> A\\<^sub>F' \\<sharp>* C;\n        (a # A\\<^sub>F) \\<sharp>* C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F'.\n                            \\<langle>(a #\nA\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n                            \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            distinct A\\<^sub>F' \\<and>\n                            A\\<^sub>F' \\<sharp>* C", "case Nil"], ["proof (state)\nthis:\n  [] \\<sharp>* C\n\ngoal (2 subgoals):\n 1. [] \\<sharp>* C \\<Longrightarrow>\n    \\<exists>A\\<^sub>F'.\n       \\<langle>[], \\<Psi>\\<^sub>F\\<rangle> =\n       \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       distinct A\\<^sub>F' \\<and> A\\<^sub>F' \\<sharp>* C\n 2. \\<And>a A\\<^sub>F.\n       \\<lbrakk>A\\<^sub>F \\<sharp>* C \\<Longrightarrow>\n                \\<exists>A\\<^sub>F'.\n                   \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n                   \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                   distinct A\\<^sub>F' \\<and> A\\<^sub>F' \\<sharp>* C;\n        (a # A\\<^sub>F) \\<sharp>* C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F'.\n                            \\<langle>(a #\nA\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n                            \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            distinct A\\<^sub>F' \\<and>\n                            A\\<^sub>F' \\<sharp>* C", "thus ?case"], ["proof (prove)\nusing this:\n  [] \\<sharp>* C\n\ngoal (1 subgoal):\n 1. \\<exists>A\\<^sub>F'.\n       \\<langle>[], \\<Psi>\\<^sub>F\\<rangle> =\n       \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       distinct A\\<^sub>F' \\<and> A\\<^sub>F' \\<sharp>* C", "by simp"], ["proof (state)\nthis:\n  \\<exists>A\\<^sub>F'.\n     \\<langle>[], \\<Psi>\\<^sub>F\\<rangle> =\n     \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n     distinct A\\<^sub>F' \\<and> A\\<^sub>F' \\<sharp>* C\n\ngoal (1 subgoal):\n 1. \\<And>a A\\<^sub>F.\n       \\<lbrakk>A\\<^sub>F \\<sharp>* C \\<Longrightarrow>\n                \\<exists>A\\<^sub>F'.\n                   \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n                   \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                   distinct A\\<^sub>F' \\<and> A\\<^sub>F' \\<sharp>* C;\n        (a # A\\<^sub>F) \\<sharp>* C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F'.\n                            \\<langle>(a #\nA\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n                            \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            distinct A\\<^sub>F' \\<and>\n                            A\\<^sub>F' \\<sharp>* C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a A\\<^sub>F.\n       \\<lbrakk>A\\<^sub>F \\<sharp>* C \\<Longrightarrow>\n                \\<exists>A\\<^sub>F'.\n                   \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n                   \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                   distinct A\\<^sub>F' \\<and> A\\<^sub>F' \\<sharp>* C;\n        (a # A\\<^sub>F) \\<sharp>* C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F'.\n                            \\<langle>(a #\nA\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n                            \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            distinct A\\<^sub>F' \\<and>\n                            A\\<^sub>F' \\<sharp>* C", "case(Cons a A\\<^sub>F)"], ["proof (state)\nthis:\n  A\\<^sub>F \\<sharp>* C \\<Longrightarrow>\n  \\<exists>A\\<^sub>F''.\n     \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n     \\<langle>A\\<^sub>F'', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n     distinct A\\<^sub>F'' \\<and> A\\<^sub>F'' \\<sharp>* C\n  (a # A\\<^sub>F) \\<sharp>* C\n\ngoal (1 subgoal):\n 1. \\<And>a A\\<^sub>F.\n       \\<lbrakk>A\\<^sub>F \\<sharp>* C \\<Longrightarrow>\n                \\<exists>A\\<^sub>F'.\n                   \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n                   \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                   distinct A\\<^sub>F' \\<and> A\\<^sub>F' \\<sharp>* C;\n        (a # A\\<^sub>F) \\<sharp>* C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F'.\n                            \\<langle>(a #\nA\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n                            \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            distinct A\\<^sub>F' \\<and>\n                            A\\<^sub>F' \\<sharp>* C", "then"], ["proof (chain)\npicking this:\n  A\\<^sub>F \\<sharp>* C \\<Longrightarrow>\n  \\<exists>A\\<^sub>F''.\n     \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n     \\<langle>A\\<^sub>F'', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n     distinct A\\<^sub>F'' \\<and> A\\<^sub>F'' \\<sharp>* C\n  (a # A\\<^sub>F) \\<sharp>* C", "obtain A\\<^sub>F' where Eq: \"\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> = \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle>\" and \"distinct A\\<^sub>F'\" and \"A\\<^sub>F' \\<sharp>* C\""], ["proof (prove)\nusing this:\n  A\\<^sub>F \\<sharp>* C \\<Longrightarrow>\n  \\<exists>A\\<^sub>F''.\n     \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n     \\<langle>A\\<^sub>F'', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n     distinct A\\<^sub>F'' \\<and> A\\<^sub>F'' \\<sharp>* C\n  (a # A\\<^sub>F) \\<sharp>* C\n\ngoal (1 subgoal):\n 1. (\\<And>A\\<^sub>F''.\n        \\<lbrakk>\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n                 \\<langle>A\\<^sub>F'', \\<Psi>\\<^sub>F\\<rangle>;\n         distinct A\\<^sub>F''; A\\<^sub>F'' \\<sharp>* C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle>\n  distinct A\\<^sub>F'\n  A\\<^sub>F' \\<sharp>* C\n\ngoal (1 subgoal):\n 1. \\<And>a A\\<^sub>F.\n       \\<lbrakk>A\\<^sub>F \\<sharp>* C \\<Longrightarrow>\n                \\<exists>A\\<^sub>F'.\n                   \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n                   \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                   distinct A\\<^sub>F' \\<and> A\\<^sub>F' \\<sharp>* C;\n        (a # A\\<^sub>F) \\<sharp>* C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F'.\n                            \\<langle>(a #\nA\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n                            \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            distinct A\\<^sub>F' \\<and>\n                            A\\<^sub>F' \\<sharp>* C", "from \\<open>(a#A\\<^sub>F) \\<sharp>* C\\<close>"], ["proof (chain)\npicking this:\n  (a # A\\<^sub>F) \\<sharp>* C", "have \"a \\<sharp> C\" and \"A\\<^sub>F \\<sharp>* C\""], ["proof (prove)\nusing this:\n  (a # A\\<^sub>F) \\<sharp>* C\n\ngoal (1 subgoal):\n 1. a \\<sharp> C &&& A\\<^sub>F \\<sharp>* C", "by simp+"], ["proof (state)\nthis:\n  a \\<sharp> C\n  A\\<^sub>F \\<sharp>* C\n\ngoal (1 subgoal):\n 1. \\<And>a A\\<^sub>F.\n       \\<lbrakk>A\\<^sub>F \\<sharp>* C \\<Longrightarrow>\n                \\<exists>A\\<^sub>F'.\n                   \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n                   \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                   distinct A\\<^sub>F' \\<and> A\\<^sub>F' \\<sharp>* C;\n        (a # A\\<^sub>F) \\<sharp>* C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F'.\n                            \\<langle>(a #\nA\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n                            \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            distinct A\\<^sub>F' \\<and>\n                            A\\<^sub>F' \\<sharp>* C", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A\\<^sub>F''.\n       \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n       \\<langle>A\\<^sub>F'', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       distinct A\\<^sub>F'' \\<and> A\\<^sub>F'' \\<sharp>* C", "proof(case_tac \"a \\<sharp> \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<sharp> \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<Longrightarrow>\n    \\<exists>A\\<^sub>F''.\n       \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n       \\<langle>A\\<^sub>F'', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       distinct A\\<^sub>F'' \\<and> A\\<^sub>F'' \\<sharp>* C\n 2. \\<not> a \\<sharp> \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<Longrightarrow>\n    \\<exists>A\\<^sub>F''.\n       \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n       \\<langle>A\\<^sub>F'', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       distinct A\\<^sub>F'' \\<and> A\\<^sub>F'' \\<sharp>* C", "assume \"a \\<sharp> \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle>\""], ["proof (state)\nthis:\n  a \\<sharp> \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle>\n\ngoal (2 subgoals):\n 1. a \\<sharp> \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<Longrightarrow>\n    \\<exists>A\\<^sub>F''.\n       \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n       \\<langle>A\\<^sub>F'', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       distinct A\\<^sub>F'' \\<and> A\\<^sub>F'' \\<sharp>* C\n 2. \\<not> a \\<sharp> \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<Longrightarrow>\n    \\<exists>A\\<^sub>F''.\n       \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n       \\<langle>A\\<^sub>F'', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       distinct A\\<^sub>F'' \\<and> A\\<^sub>F'' \\<sharp>* C", "obtain b::name where \"b \\<sharp> A\\<^sub>F'\" and \"b \\<sharp> \\<Psi>\\<^sub>F\" and \"b \\<sharp> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b \\<sharp> A\\<^sub>F'; b \\<sharp> \\<Psi>\\<^sub>F;\n         b \\<sharp> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(generate_fresh \"name\", auto)"], ["proof (state)\nthis:\n  b \\<sharp> A\\<^sub>F'\n  b \\<sharp> \\<Psi>\\<^sub>F\n  b \\<sharp> C\n\ngoal (2 subgoals):\n 1. a \\<sharp> \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<Longrightarrow>\n    \\<exists>A\\<^sub>F''.\n       \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n       \\<langle>A\\<^sub>F'', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       distinct A\\<^sub>F'' \\<and> A\\<^sub>F'' \\<sharp>* C\n 2. \\<not> a \\<sharp> \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<Longrightarrow>\n    \\<exists>A\\<^sub>F''.\n       \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n       \\<langle>A\\<^sub>F'', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       distinct A\\<^sub>F'' \\<and> A\\<^sub>F'' \\<sharp>* C", "have \"\\<langle>(a#A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> = \\<langle>(b#A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n    \\<langle>(b # A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n    \\<langle>(b # A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle>", "from Eq"], ["proof (chain)\npicking this:\n  \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle>", "have \"\\<langle>(a#A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> = \\<langle>(a#A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle>\""], ["proof (prove)\nusing this:\n  \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n    \\<langle>(a # A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle>", "by(simp add: frame.inject)"], ["proof (state)\nthis:\n  \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>(a # A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n    \\<langle>(b # A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle>", "moreover"], ["proof (state)\nthis:\n  \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>(a # A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n    \\<langle>(b # A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle>", "from \\<open>b \\<sharp> \\<Psi>\\<^sub>F\\<close>"], ["proof (chain)\npicking this:\n  b \\<sharp> \\<Psi>\\<^sub>F", "have \"\\<dots> = \\<lparr>\\<nu>b\\<rparr>([(a, b)] \\<bullet> \\<lparr>\\<nu>*A\\<^sub>F'\\<rparr>(FAssert \\<Psi>\\<^sub>F))\""], ["proof (prove)\nusing this:\n  b \\<sharp> \\<Psi>\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<langle>(a # A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle> =\n    \\<lparr>\\<nu>b\\<rparr>[(a, b)] \\<bullet>\n                          \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle>", "by(force intro: alphaFrameRes simp add: frameResChainFresh)"], ["proof (state)\nthis:\n  \\<langle>(a # A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle> =\n  \\<lparr>\\<nu>b\\<rparr>[(a, b)] \\<bullet>\n                        \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n    \\<langle>(b # A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle>", "ultimately"], ["proof (chain)\npicking this:\n  \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>(a # A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle>\n  \\<langle>(a # A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle> =\n  \\<lparr>\\<nu>b\\<rparr>[(a, b)] \\<bullet>\n                        \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>(a # A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle>\n  \\<langle>(a # A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle> =\n  \\<lparr>\\<nu>b\\<rparr>[(a, b)] \\<bullet>\n                        \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n    \\<langle>(b # A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle>", "using \\<open>a \\<sharp> \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle>\\<close> \\<open>b \\<sharp> \\<Psi>\\<^sub>F\\<close>"], ["proof (prove)\nusing this:\n  \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>(a # A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle>\n  \\<langle>(a # A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle> =\n  \\<lparr>\\<nu>b\\<rparr>[(a, b)] \\<bullet>\n                        \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle>\n  a \\<sharp> \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle>\n  b \\<sharp> \\<Psi>\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n    \\<langle>(b # A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle>", "by(simp add: frameResChainFresh)"], ["proof (state)\nthis:\n  \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>(b # A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>(b # A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle>\n\ngoal (2 subgoals):\n 1. a \\<sharp> \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<Longrightarrow>\n    \\<exists>A\\<^sub>F''.\n       \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n       \\<langle>A\\<^sub>F'', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       distinct A\\<^sub>F'' \\<and> A\\<^sub>F'' \\<sharp>* C\n 2. \\<not> a \\<sharp> \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<Longrightarrow>\n    \\<exists>A\\<^sub>F''.\n       \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n       \\<langle>A\\<^sub>F'', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       distinct A\\<^sub>F'' \\<and> A\\<^sub>F'' \\<sharp>* C", "moreover"], ["proof (state)\nthis:\n  \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>(b # A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle>\n\ngoal (2 subgoals):\n 1. a \\<sharp> \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<Longrightarrow>\n    \\<exists>A\\<^sub>F''.\n       \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n       \\<langle>A\\<^sub>F'', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       distinct A\\<^sub>F'' \\<and> A\\<^sub>F'' \\<sharp>* C\n 2. \\<not> a \\<sharp> \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<Longrightarrow>\n    \\<exists>A\\<^sub>F''.\n       \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n       \\<langle>A\\<^sub>F'', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       distinct A\\<^sub>F'' \\<and> A\\<^sub>F'' \\<sharp>* C", "from \\<open>distinct A\\<^sub>F'\\<close> \\<open>b \\<sharp> A\\<^sub>F'\\<close>"], ["proof (chain)\npicking this:\n  distinct A\\<^sub>F'\n  b \\<sharp> A\\<^sub>F'", "have \"distinct(b#A\\<^sub>F')\""], ["proof (prove)\nusing this:\n  distinct A\\<^sub>F'\n  b \\<sharp> A\\<^sub>F'\n\ngoal (1 subgoal):\n 1. distinct (b # A\\<^sub>F')", "by simp"], ["proof (state)\nthis:\n  distinct (b # A\\<^sub>F')\n\ngoal (2 subgoals):\n 1. a \\<sharp> \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<Longrightarrow>\n    \\<exists>A\\<^sub>F''.\n       \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n       \\<langle>A\\<^sub>F'', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       distinct A\\<^sub>F'' \\<and> A\\<^sub>F'' \\<sharp>* C\n 2. \\<not> a \\<sharp> \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<Longrightarrow>\n    \\<exists>A\\<^sub>F''.\n       \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n       \\<langle>A\\<^sub>F'', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       distinct A\\<^sub>F'' \\<and> A\\<^sub>F'' \\<sharp>* C", "moreover"], ["proof (state)\nthis:\n  distinct (b # A\\<^sub>F')\n\ngoal (2 subgoals):\n 1. a \\<sharp> \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<Longrightarrow>\n    \\<exists>A\\<^sub>F''.\n       \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n       \\<langle>A\\<^sub>F'', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       distinct A\\<^sub>F'' \\<and> A\\<^sub>F'' \\<sharp>* C\n 2. \\<not> a \\<sharp> \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<Longrightarrow>\n    \\<exists>A\\<^sub>F''.\n       \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n       \\<langle>A\\<^sub>F'', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       distinct A\\<^sub>F'' \\<and> A\\<^sub>F'' \\<sharp>* C", "from \\<open>A\\<^sub>F' \\<sharp>* C\\<close> \\<open>b \\<sharp> C\\<close>"], ["proof (chain)\npicking this:\n  A\\<^sub>F' \\<sharp>* C\n  b \\<sharp> C", "have \"(b#A\\<^sub>F') \\<sharp>* C\""], ["proof (prove)\nusing this:\n  A\\<^sub>F' \\<sharp>* C\n  b \\<sharp> C\n\ngoal (1 subgoal):\n 1. (b # A\\<^sub>F') \\<sharp>* C", "by simp+"], ["proof (state)\nthis:\n  (b # A\\<^sub>F') \\<sharp>* C\n\ngoal (2 subgoals):\n 1. a \\<sharp> \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<Longrightarrow>\n    \\<exists>A\\<^sub>F''.\n       \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n       \\<langle>A\\<^sub>F'', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       distinct A\\<^sub>F'' \\<and> A\\<^sub>F'' \\<sharp>* C\n 2. \\<not> a \\<sharp> \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<Longrightarrow>\n    \\<exists>A\\<^sub>F''.\n       \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n       \\<langle>A\\<^sub>F'', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       distinct A\\<^sub>F'' \\<and> A\\<^sub>F'' \\<sharp>* C", "ultimately"], ["proof (chain)\npicking this:\n  \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>(b # A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle>\n  distinct (b # A\\<^sub>F')\n  (b # A\\<^sub>F') \\<sharp>* C", "show ?case"], ["proof (prove)\nusing this:\n  \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>(b # A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle>\n  distinct (b # A\\<^sub>F')\n  (b # A\\<^sub>F') \\<sharp>* C\n\ngoal (1 subgoal):\n 1. \\<exists>A\\<^sub>F''.\n       \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n       \\<langle>A\\<^sub>F'', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       distinct A\\<^sub>F'' \\<and> A\\<^sub>F'' \\<sharp>* C", "by blast"], ["proof (state)\nthis:\n  \\<exists>A\\<^sub>F''.\n     \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n     \\<langle>A\\<^sub>F'', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n     distinct A\\<^sub>F'' \\<and> A\\<^sub>F'' \\<sharp>* C\n\ngoal (1 subgoal):\n 1. \\<not> a \\<sharp> \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<Longrightarrow>\n    \\<exists>A\\<^sub>F''.\n       \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n       \\<langle>A\\<^sub>F'', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       distinct A\\<^sub>F'' \\<and> A\\<^sub>F'' \\<sharp>* C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> a \\<sharp> \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<Longrightarrow>\n    \\<exists>A\\<^sub>F''.\n       \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n       \\<langle>A\\<^sub>F'', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       distinct A\\<^sub>F'' \\<and> A\\<^sub>F'' \\<sharp>* C", "from Eq"], ["proof (chain)\npicking this:\n  \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle>", "have \"\\<langle>(a#A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> = \\<langle>(a#A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle>\""], ["proof (prove)\nusing this:\n  \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n    \\<langle>(a # A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle>", "by(simp add: frame.inject)"], ["proof (state)\nthis:\n  \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>(a # A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> a \\<sharp> \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<Longrightarrow>\n    \\<exists>A\\<^sub>F''.\n       \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n       \\<langle>A\\<^sub>F'', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       distinct A\\<^sub>F'' \\<and> A\\<^sub>F'' \\<sharp>* C", "moreover"], ["proof (state)\nthis:\n  \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>(a # A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> a \\<sharp> \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<Longrightarrow>\n    \\<exists>A\\<^sub>F''.\n       \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n       \\<langle>A\\<^sub>F'', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       distinct A\\<^sub>F'' \\<and> A\\<^sub>F'' \\<sharp>* C", "assume \"\\<not>(a \\<sharp> \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle>)\""], ["proof (state)\nthis:\n  \\<not> a \\<sharp> \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> a \\<sharp> \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<Longrightarrow>\n    \\<exists>A\\<^sub>F''.\n       \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n       \\<langle>A\\<^sub>F'', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       distinct A\\<^sub>F'' \\<and> A\\<^sub>F'' \\<sharp>* C", "hence \"a \\<sharp> A\\<^sub>F'\""], ["proof (prove)\nusing this:\n  \\<not> a \\<sharp> \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle>\n\ngoal (1 subgoal):\n 1. a \\<sharp> A\\<^sub>F'", "apply(simp add: fresh_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> supp\n             (\\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle>) \\<Longrightarrow>\n    a \\<notin> supp A\\<^sub>F'", "by(induct A\\<^sub>F') (auto simp add: supp_list_nil supp_list_cons supp_atm frame.supp abs_supp)"], ["proof (state)\nthis:\n  a \\<sharp> A\\<^sub>F'\n\ngoal (1 subgoal):\n 1. \\<not> a \\<sharp> \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<Longrightarrow>\n    \\<exists>A\\<^sub>F''.\n       \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n       \\<langle>A\\<^sub>F'', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       distinct A\\<^sub>F'' \\<and> A\\<^sub>F'' \\<sharp>* C", "with \\<open>distinct A\\<^sub>F'\\<close>"], ["proof (chain)\npicking this:\n  distinct A\\<^sub>F'\n  a \\<sharp> A\\<^sub>F'", "have \"distinct(a#A\\<^sub>F')\""], ["proof (prove)\nusing this:\n  distinct A\\<^sub>F'\n  a \\<sharp> A\\<^sub>F'\n\ngoal (1 subgoal):\n 1. distinct (a # A\\<^sub>F')", "by simp"], ["proof (state)\nthis:\n  distinct (a # A\\<^sub>F')\n\ngoal (1 subgoal):\n 1. \\<not> a \\<sharp> \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<Longrightarrow>\n    \\<exists>A\\<^sub>F''.\n       \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n       \\<langle>A\\<^sub>F'', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       distinct A\\<^sub>F'' \\<and> A\\<^sub>F'' \\<sharp>* C", "moreover"], ["proof (state)\nthis:\n  distinct (a # A\\<^sub>F')\n\ngoal (1 subgoal):\n 1. \\<not> a \\<sharp> \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<Longrightarrow>\n    \\<exists>A\\<^sub>F''.\n       \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n       \\<langle>A\\<^sub>F'', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       distinct A\\<^sub>F'' \\<and> A\\<^sub>F'' \\<sharp>* C", "from \\<open>A\\<^sub>F' \\<sharp>* C\\<close> \\<open>a \\<sharp> C\\<close>"], ["proof (chain)\npicking this:\n  A\\<^sub>F' \\<sharp>* C\n  a \\<sharp> C", "have \"(a#A\\<^sub>F') \\<sharp>* C\""], ["proof (prove)\nusing this:\n  A\\<^sub>F' \\<sharp>* C\n  a \\<sharp> C\n\ngoal (1 subgoal):\n 1. (a # A\\<^sub>F') \\<sharp>* C", "by simp+"], ["proof (state)\nthis:\n  (a # A\\<^sub>F') \\<sharp>* C\n\ngoal (1 subgoal):\n 1. \\<not> a \\<sharp> \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<Longrightarrow>\n    \\<exists>A\\<^sub>F''.\n       \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n       \\<langle>A\\<^sub>F'', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       distinct A\\<^sub>F'' \\<and> A\\<^sub>F'' \\<sharp>* C", "ultimately"], ["proof (chain)\npicking this:\n  \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>(a # A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle>\n  distinct (a # A\\<^sub>F')\n  (a # A\\<^sub>F') \\<sharp>* C", "show ?case"], ["proof (prove)\nusing this:\n  \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>(a # A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle>\n  distinct (a # A\\<^sub>F')\n  (a # A\\<^sub>F') \\<sharp>* C\n\ngoal (1 subgoal):\n 1. \\<exists>A\\<^sub>F''.\n       \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n       \\<langle>A\\<^sub>F'', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       distinct A\\<^sub>F'' \\<and> A\\<^sub>F'' \\<sharp>* C", "by blast"], ["proof (state)\nthis:\n  \\<exists>A\\<^sub>F''.\n     \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n     \\<langle>A\\<^sub>F'', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n     distinct A\\<^sub>F'' \\<and> A\\<^sub>F'' \\<sharp>* C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>A\\<^sub>F''.\n     \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> =\n     \\<langle>A\\<^sub>F'', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n     distinct A\\<^sub>F'' \\<and> A\\<^sub>F'' \\<sharp>* C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>A\\<^sub>F'.\n     \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n     \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n     distinct A\\<^sub>F' \\<and> A\\<^sub>F' \\<sharp>* C\n\ngoal (1 subgoal):\n 1. (\\<And>A\\<^sub>F'.\n        \\<lbrakk>\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n                 \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle>;\n         distinct A\\<^sub>F'; A\\<^sub>F' \\<sharp>* C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n           \\<langle>?A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle>;\n   distinct ?A\\<^sub>F'; ?A\\<^sub>F' \\<sharp>* C\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<exists>A\\<^sub>F'.\n     \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n     \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n     distinct A\\<^sub>F' \\<and> A\\<^sub>F' \\<sharp>* C", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n           \\<langle>?A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle>;\n   distinct ?A\\<^sub>F'; ?A\\<^sub>F' \\<sharp>* C\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<exists>A\\<^sub>F'.\n     \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n     \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n     distinct A\\<^sub>F' \\<and> A\\<^sub>F' \\<sharp>* C\n\ngoal (1 subgoal):\n 1. thesis", "using \\<open>A\\<^sub>F \\<sharp>* C\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n           \\<langle>?A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle>;\n   distinct ?A\\<^sub>F'; ?A\\<^sub>F' \\<sharp>* C\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<exists>A\\<^sub>F'.\n     \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n     \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle> \\<and>\n     distinct A\\<^sub>F' \\<and> A\\<^sub>F' \\<sharp>* C\n  A\\<^sub>F \\<sharp>* C\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma freshFrame:\n  fixes F  :: \"('a::fs_name) frame\"\n  and   C  :: \"'b ::fs_name\"\n\n  obtains A\\<^sub>F \\<Psi>\\<^sub>F where \"F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\" and \"distinct A\\<^sub>F\" and \"A\\<^sub>F \\<sharp>* C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A\\<^sub>F \\<Psi>\\<^sub>F.\n        \\<lbrakk>F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>;\n         distinct A\\<^sub>F; A\\<^sub>F \\<sharp>* C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>A\\<^sub>F \\<Psi>\\<^sub>F.\n        \\<lbrakk>F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>;\n         distinct A\\<^sub>F; A\\<^sub>F \\<sharp>* C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "assume \"\\<And>A\\<^sub>F \\<Psi>\\<^sub>F. \\<lbrakk>F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>; distinct A\\<^sub>F; A\\<^sub>F \\<sharp>* C\\<rbrakk> \\<Longrightarrow> thesis\""], ["proof (state)\nthis:\n  \\<lbrakk>F = \\<langle>?A\\<^sub>F, ?\\<Psi>\\<^sub>F\\<rangle>;\n   distinct ?A\\<^sub>F; ?A\\<^sub>F \\<sharp>* C\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<And>A\\<^sub>F \\<Psi>\\<^sub>F.\n        \\<lbrakk>F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>;\n         distinct A\\<^sub>F; A\\<^sub>F \\<sharp>* C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>F = \\<langle>?A\\<^sub>F, ?\\<Psi>\\<^sub>F\\<rangle>;\n   distinct ?A\\<^sub>F; ?A\\<^sub>F \\<sharp>* C\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<And>A\\<^sub>F \\<Psi>\\<^sub>F.\n        \\<lbrakk>F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>;\n         distinct A\\<^sub>F; A\\<^sub>F \\<sharp>* C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<exists>A\\<^sub>F \\<Psi>\\<^sub>F. F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and> A\\<^sub>F \\<sharp>* C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F.\n       F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       A\\<^sub>F \\<sharp>* C", "proof(nominal_induct F avoiding: C rule: frame.strong_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>assertion C.\n       \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F.\n          \\<langle>\\<epsilon>, assertion\\<rangle> =\n          \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n          A\\<^sub>F \\<sharp>* C\n 2. \\<And>name frame C.\n       \\<lbrakk>name \\<sharp> C;\n        \\<And>b.\n           \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F.\n              frame = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n              A\\<^sub>F \\<sharp>* b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F.\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* C", "case(FAssert \\<Psi>\\<^sub>F)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>assertion C.\n       \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F.\n          \\<langle>\\<epsilon>, assertion\\<rangle> =\n          \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n          A\\<^sub>F \\<sharp>* C\n 2. \\<And>name frame C.\n       \\<lbrakk>name \\<sharp> C;\n        \\<And>b.\n           \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F.\n              frame = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n              A\\<^sub>F \\<sharp>* b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F.\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* C", "have \"FAssert \\<Psi>\\<^sub>F = \\<langle>[], \\<Psi>\\<^sub>F\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<epsilon>, \\<Psi>\\<^sub>F\\<rangle> =\n    \\<langle>[], \\<Psi>\\<^sub>F\\<rangle>", "by simp"], ["proof (state)\nthis:\n  \\<langle>\\<epsilon>, \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>[], \\<Psi>\\<^sub>F\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>assertion C.\n       \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F.\n          \\<langle>\\<epsilon>, assertion\\<rangle> =\n          \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n          A\\<^sub>F \\<sharp>* C\n 2. \\<And>name frame C.\n       \\<lbrakk>name \\<sharp> C;\n        \\<And>b.\n           \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F.\n              frame = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n              A\\<^sub>F \\<sharp>* b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F.\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* C", "moreover"], ["proof (state)\nthis:\n  \\<langle>\\<epsilon>, \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>[], \\<Psi>\\<^sub>F\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>assertion C.\n       \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F.\n          \\<langle>\\<epsilon>, assertion\\<rangle> =\n          \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n          A\\<^sub>F \\<sharp>* C\n 2. \\<And>name frame C.\n       \\<lbrakk>name \\<sharp> C;\n        \\<And>b.\n           \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F.\n              frame = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n              A\\<^sub>F \\<sharp>* b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F.\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* C", "have \"([]::name list) \\<sharp>* C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<sharp>* C", "by simp"], ["proof (state)\nthis:\n  [] \\<sharp>* C\n\ngoal (2 subgoals):\n 1. \\<And>assertion C.\n       \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F.\n          \\<langle>\\<epsilon>, assertion\\<rangle> =\n          \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n          A\\<^sub>F \\<sharp>* C\n 2. \\<And>name frame C.\n       \\<lbrakk>name \\<sharp> C;\n        \\<And>b.\n           \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F.\n              frame = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n              A\\<^sub>F \\<sharp>* b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F.\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* C", "ultimately"], ["proof (chain)\npicking this:\n  \\<langle>\\<epsilon>, \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>[], \\<Psi>\\<^sub>F\\<rangle>\n  [] \\<sharp>* C", "show ?case"], ["proof (prove)\nusing this:\n  \\<langle>\\<epsilon>, \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>[], \\<Psi>\\<^sub>F\\<rangle>\n  [] \\<sharp>* C\n\ngoal (1 subgoal):\n 1. \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F'.\n       \\<langle>\\<epsilon>, \\<Psi>\\<^sub>F\\<rangle> =\n       \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F'\\<rangle> \\<and>\n       A\\<^sub>F \\<sharp>* C", "by force"], ["proof (state)\nthis:\n  \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F'.\n     \\<langle>\\<epsilon>, \\<Psi>\\<^sub>F\\<rangle> =\n     \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F'\\<rangle> \\<and>\n     A\\<^sub>F \\<sharp>* C\n\ngoal (1 subgoal):\n 1. \\<And>name frame C.\n       \\<lbrakk>name \\<sharp> C;\n        \\<And>b.\n           \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F.\n              frame = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n              A\\<^sub>F \\<sharp>* b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F.\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>name frame C.\n       \\<lbrakk>name \\<sharp> C;\n        \\<And>b.\n           \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F.\n              frame = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n              A\\<^sub>F \\<sharp>* b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F.\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* C", "case(FRes a F)"], ["proof (state)\nthis:\n  a \\<sharp> C\n  \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F.\n     F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n     A\\<^sub>F \\<sharp>* ?b\n\ngoal (1 subgoal):\n 1. \\<And>name frame C.\n       \\<lbrakk>name \\<sharp> C;\n        \\<And>b.\n           \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F.\n              frame = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n              A\\<^sub>F \\<sharp>* b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F.\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* C", "from \\<open>\\<And>C. \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F. F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and> A\\<^sub>F \\<sharp>* C\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F.\n     F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n     A\\<^sub>F \\<sharp>* ?C", "obtain A\\<^sub>F \\<Psi>\\<^sub>F  where \"F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\" and \"A\\<^sub>F \\<sharp>* C\""], ["proof (prove)\nusing this:\n  \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F.\n     F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n     A\\<^sub>F \\<sharp>* ?C\n\ngoal (1 subgoal):\n 1. (\\<And>A\\<^sub>F \\<Psi>\\<^sub>F.\n        \\<lbrakk>F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>;\n         A\\<^sub>F \\<sharp>* C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\n  A\\<^sub>F \\<sharp>* C\n\ngoal (1 subgoal):\n 1. \\<And>name frame C.\n       \\<lbrakk>name \\<sharp> C;\n        \\<And>b.\n           \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F.\n              frame = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n              A\\<^sub>F \\<sharp>* b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F.\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* C", "with \\<open>a \\<sharp> C\\<close>"], ["proof (chain)\npicking this:\n  a \\<sharp> C\n  F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\n  A\\<^sub>F \\<sharp>* C", "have \"\\<lparr>\\<nu>a\\<rparr>F = \\<lparr>\\<nu>*(a#A\\<^sub>F)\\<rparr>(FAssert \\<Psi>\\<^sub>F)\" and \"(a#A\\<^sub>F) \\<sharp>* C\""], ["proof (prove)\nusing this:\n  a \\<sharp> C\n  F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\n  A\\<^sub>F \\<sharp>* C\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>a\\<rparr>F =\n    \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> &&&\n    (a # A\\<^sub>F) \\<sharp>* C", "by simp+"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>a\\<rparr>F =\n  \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle>\n  (a # A\\<^sub>F) \\<sharp>* C\n\ngoal (1 subgoal):\n 1. \\<And>name frame C.\n       \\<lbrakk>name \\<sharp> C;\n        \\<And>b.\n           \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F.\n              frame = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n              A\\<^sub>F \\<sharp>* b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F.\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* C", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lparr>\\<nu>a\\<rparr>F =\n  \\<langle>(a # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle>\n  (a # A\\<^sub>F) \\<sharp>* C\n\ngoal (1 subgoal):\n 1. \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F.\n       \\<lparr>\\<nu>a\\<rparr>F =\n       \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       A\\<^sub>F \\<sharp>* C", "by blast"], ["proof (state)\nthis:\n  \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F.\n     \\<lparr>\\<nu>a\\<rparr>F =\n     \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n     A\\<^sub>F \\<sharp>* C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F.\n     F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n     A\\<^sub>F \\<sharp>* C\n\ngoal (1 subgoal):\n 1. (\\<And>A\\<^sub>F \\<Psi>\\<^sub>F.\n        \\<lbrakk>F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>;\n         distinct A\\<^sub>F; A\\<^sub>F \\<sharp>* C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>F = \\<langle>?A\\<^sub>F, ?\\<Psi>\\<^sub>F\\<rangle>;\n   distinct ?A\\<^sub>F; ?A\\<^sub>F \\<sharp>* C\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F.\n     F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n     A\\<^sub>F \\<sharp>* C", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>F = \\<langle>?A\\<^sub>F, ?\\<Psi>\\<^sub>F\\<rangle>;\n   distinct ?A\\<^sub>F; ?A\\<^sub>F \\<sharp>* C\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F.\n     F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n     A\\<^sub>F \\<sharp>* C\n\ngoal (1 subgoal):\n 1. thesis", "by(auto, rule_tac distinctFrame) auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "locale assertionAux = \n  fixes SCompose :: \"'b::fs_name \\<Rightarrow> 'b \\<Rightarrow> 'b\"   (infixr \"\\<otimes>\" 80)\n  and   SImp     :: \"'b \\<Rightarrow> 'c::fs_name \\<Rightarrow> bool\" (\"_ \\<turnstile> _\" [70, 70] 70)\n  and   SBottom  :: 'b                         (\"\\<bottom>\" 90) \n  and   SChanEq  :: \"'a::fs_name \\<Rightarrow> 'a \\<Rightarrow> 'c\"   (\"_ \\<leftrightarrow> _\" [80, 80] 80)\n\n  assumes statEqvt[eqvt]:   \"\\<And>p::name prm. p \\<bullet> (\\<Psi> \\<turnstile> \\<Phi>) = (p \\<bullet> \\<Psi>) \\<turnstile> (p \\<bullet> \\<Phi>)\"\n  and     statEqvt'[eqvt]:  \"\\<And>p::name prm. p \\<bullet> (\\<Psi> \\<otimes> \\<Psi>') = (p \\<bullet> \\<Psi>) \\<otimes> (p \\<bullet> \\<Psi>')\" \n  and     statEqvt''[eqvt]: \"\\<And>p::name prm. p \\<bullet> (M \\<leftrightarrow> N) = (p \\<bullet> M) \\<leftrightarrow> (p \\<bullet> N)\"\n  and     permBottom[eqvt]: \"\\<And>p::name prm. (p \\<bullet> SBottom) = SBottom\"\n\nbegin"], ["", "lemma statClosed:\n  fixes \\<Psi> :: 'b\n  and   \\<phi> :: 'c\n  and   p :: \"name prm\"\n  \n  assumes \"\\<Psi> \\<turnstile> \\<phi>\"\n\n  shows \"(p \\<bullet> \\<Psi>) \\<turnstile> (p \\<bullet> \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> \\<Psi> \\<turnstile> p \\<bullet> \\<phi>", "using assms statEqvt"], ["proof (prove)\nusing this:\n  \\<Psi> \\<turnstile> \\<phi>\n  ?p \\<bullet> (?\\<Psi> \\<turnstile> ?\\<Phi>) =\n  ?p \\<bullet> ?\\<Psi> \\<turnstile> ?p \\<bullet> ?\\<Phi>\n\ngoal (1 subgoal):\n 1. p \\<bullet> \\<Psi> \\<turnstile> p \\<bullet> \\<phi>", "by(simp add: perm_bool)"], ["", "lemma compSupp:\n  fixes \\<Psi>  :: 'b\n  and   \\<Psi>' :: 'b\n\n  shows \"(supp(\\<Psi> \\<otimes> \\<Psi>')::name set) \\<subseteq> ((supp \\<Psi>) \\<union> (supp \\<Psi>'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (\\<Psi> \\<otimes> \\<Psi>')\n    \\<subseteq> supp \\<Psi> \\<union> supp \\<Psi>'", "proof(auto simp add: eqvts supp_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>infinite\n                 {b. ([(x, b)] \\<bullet> \\<Psi>) \\<otimes>\n                     [(x, b)] \\<bullet> \\<Psi>' \\<noteq>\n                     \\<Psi> \\<otimes> \\<Psi>'};\n        finite {b. [(x, b)] \\<bullet> \\<Psi>' \\<noteq> \\<Psi>'};\n        finite {b. [(x, b)] \\<bullet> \\<Psi> \\<noteq> \\<Psi>}\\<rbrakk>\n       \\<Longrightarrow> False", "fix x::name"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>infinite\n                 {b. ([(x, b)] \\<bullet> \\<Psi>) \\<otimes>\n                     [(x, b)] \\<bullet> \\<Psi>' \\<noteq>\n                     \\<Psi> \\<otimes> \\<Psi>'};\n        finite {b. [(x, b)] \\<bullet> \\<Psi>' \\<noteq> \\<Psi>'};\n        finite {b. [(x, b)] \\<bullet> \\<Psi> \\<noteq> \\<Psi>}\\<rbrakk>\n       \\<Longrightarrow> False", "let ?P = \"\\<lambda>y. ([(x, y)] \\<bullet> \\<Psi>) \\<otimes> [(x, y)] \\<bullet> \\<Psi>' \\<noteq> \\<Psi> \\<otimes> \\<Psi>'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>infinite\n                 {b. ([(x, b)] \\<bullet> \\<Psi>) \\<otimes>\n                     [(x, b)] \\<bullet> \\<Psi>' \\<noteq>\n                     \\<Psi> \\<otimes> \\<Psi>'};\n        finite {b. [(x, b)] \\<bullet> \\<Psi>' \\<noteq> \\<Psi>'};\n        finite {b. [(x, b)] \\<bullet> \\<Psi> \\<noteq> \\<Psi>}\\<rbrakk>\n       \\<Longrightarrow> False", "let ?Q = \"\\<lambda>y \\<Psi>. ([(x, y)] \\<bullet> \\<Psi>) \\<noteq> \\<Psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>infinite\n                 {b. ([(x, b)] \\<bullet> \\<Psi>) \\<otimes>\n                     [(x, b)] \\<bullet> \\<Psi>' \\<noteq>\n                     \\<Psi> \\<otimes> \\<Psi>'};\n        finite {b. [(x, b)] \\<bullet> \\<Psi>' \\<noteq> \\<Psi>'};\n        finite {b. [(x, b)] \\<bullet> \\<Psi> \\<noteq> \\<Psi>}\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"finite {y. ?Q y \\<Psi>'}\""], ["proof (state)\nthis:\n  finite {y. [(x, y)] \\<bullet> \\<Psi>' \\<noteq> \\<Psi>'}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>infinite\n                 {b. ([(x, b)] \\<bullet> \\<Psi>) \\<otimes>\n                     [(x, b)] \\<bullet> \\<Psi>' \\<noteq>\n                     \\<Psi> \\<otimes> \\<Psi>'};\n        finite {b. [(x, b)] \\<bullet> \\<Psi>' \\<noteq> \\<Psi>'};\n        finite {b. [(x, b)] \\<bullet> \\<Psi> \\<noteq> \\<Psi>}\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  finite {y. [(x, y)] \\<bullet> \\<Psi>' \\<noteq> \\<Psi>'}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>infinite\n                 {b. ([(x, b)] \\<bullet> \\<Psi>) \\<otimes>\n                     [(x, b)] \\<bullet> \\<Psi>' \\<noteq>\n                     \\<Psi> \\<otimes> \\<Psi>'};\n        finite {b. [(x, b)] \\<bullet> \\<Psi>' \\<noteq> \\<Psi>'};\n        finite {b. [(x, b)] \\<bullet> \\<Psi> \\<noteq> \\<Psi>}\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"finite {y. ?Q y \\<Psi>}\" and \"infinite {y. ?P(y)}\""], ["proof (state)\nthis:\n  finite {y. [(x, y)] \\<bullet> \\<Psi> \\<noteq> \\<Psi>}\n  infinite\n   {y. ([(x, y)] \\<bullet> \\<Psi>) \\<otimes>\n       [(x, y)] \\<bullet> \\<Psi>' \\<noteq>\n       \\<Psi> \\<otimes> \\<Psi>'}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>infinite\n                 {b. ([(x, b)] \\<bullet> \\<Psi>) \\<otimes>\n                     [(x, b)] \\<bullet> \\<Psi>' \\<noteq>\n                     \\<Psi> \\<otimes> \\<Psi>'};\n        finite {b. [(x, b)] \\<bullet> \\<Psi>' \\<noteq> \\<Psi>'};\n        finite {b. [(x, b)] \\<bullet> \\<Psi> \\<noteq> \\<Psi>}\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"infinite({y. ?P(y)} - {y. ?Q y \\<Psi>})\""], ["proof (prove)\nusing this:\n  finite {y. [(x, y)] \\<bullet> \\<Psi> \\<noteq> \\<Psi>}\n  infinite\n   {y. ([(x, y)] \\<bullet> \\<Psi>) \\<otimes>\n       [(x, y)] \\<bullet> \\<Psi>' \\<noteq>\n       \\<Psi> \\<otimes> \\<Psi>'}\n\ngoal (1 subgoal):\n 1. infinite\n     ({y. ([(x, y)] \\<bullet> \\<Psi>) \\<otimes>\n          [(x, y)] \\<bullet> \\<Psi>' \\<noteq>\n          \\<Psi> \\<otimes> \\<Psi>'} -\n      {y. [(x, y)] \\<bullet> \\<Psi> \\<noteq> \\<Psi>})", "by(rule Diff_infinite_finite)"], ["proof (state)\nthis:\n  infinite\n   ({y. ([(x, y)] \\<bullet> \\<Psi>) \\<otimes>\n        [(x, y)] \\<bullet> \\<Psi>' \\<noteq>\n        \\<Psi> \\<otimes> \\<Psi>'} -\n    {y. [(x, y)] \\<bullet> \\<Psi> \\<noteq> \\<Psi>})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>infinite\n                 {b. ([(x, b)] \\<bullet> \\<Psi>) \\<otimes>\n                     [(x, b)] \\<bullet> \\<Psi>' \\<noteq>\n                     \\<Psi> \\<otimes> \\<Psi>'};\n        finite {b. [(x, b)] \\<bullet> \\<Psi>' \\<noteq> \\<Psi>'};\n        finite {b. [(x, b)] \\<bullet> \\<Psi> \\<noteq> \\<Psi>}\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  finite {y. [(x, y)] \\<bullet> \\<Psi>' \\<noteq> \\<Psi>'}\n  infinite\n   ({y. ([(x, y)] \\<bullet> \\<Psi>) \\<otimes>\n        [(x, y)] \\<bullet> \\<Psi>' \\<noteq>\n        \\<Psi> \\<otimes> \\<Psi>'} -\n    {y. [(x, y)] \\<bullet> \\<Psi> \\<noteq> \\<Psi>})", "have \"infinite(({y. ?P(y)} - {y. ?Q y \\<Psi>}) - {y. ?Q y \\<Psi>'})\""], ["proof (prove)\nusing this:\n  finite {y. [(x, y)] \\<bullet> \\<Psi>' \\<noteq> \\<Psi>'}\n  infinite\n   ({y. ([(x, y)] \\<bullet> \\<Psi>) \\<otimes>\n        [(x, y)] \\<bullet> \\<Psi>' \\<noteq>\n        \\<Psi> \\<otimes> \\<Psi>'} -\n    {y. [(x, y)] \\<bullet> \\<Psi> \\<noteq> \\<Psi>})\n\ngoal (1 subgoal):\n 1. infinite\n     ({y. ([(x, y)] \\<bullet> \\<Psi>) \\<otimes>\n          [(x, y)] \\<bullet> \\<Psi>' \\<noteq>\n          \\<Psi> \\<otimes> \\<Psi>'} -\n      {y. [(x, y)] \\<bullet> \\<Psi> \\<noteq> \\<Psi>} -\n      {y. [(x, y)] \\<bullet> \\<Psi>' \\<noteq> \\<Psi>'})", "by(rule Diff_infinite_finite)"], ["proof (state)\nthis:\n  infinite\n   ({y. ([(x, y)] \\<bullet> \\<Psi>) \\<otimes>\n        [(x, y)] \\<bullet> \\<Psi>' \\<noteq>\n        \\<Psi> \\<otimes> \\<Psi>'} -\n    {y. [(x, y)] \\<bullet> \\<Psi> \\<noteq> \\<Psi>} -\n    {y. [(x, y)] \\<bullet> \\<Psi>' \\<noteq> \\<Psi>'})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>infinite\n                 {b. ([(x, b)] \\<bullet> \\<Psi>) \\<otimes>\n                     [(x, b)] \\<bullet> \\<Psi>' \\<noteq>\n                     \\<Psi> \\<otimes> \\<Psi>'};\n        finite {b. [(x, b)] \\<bullet> \\<Psi>' \\<noteq> \\<Psi>'};\n        finite {b. [(x, b)] \\<bullet> \\<Psi> \\<noteq> \\<Psi>}\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"infinite({y. ?P(y) \\<and> \\<not>(?Q y \\<Psi>) \\<and> \\<not> (?Q y \\<Psi>')})\""], ["proof (prove)\nusing this:\n  infinite\n   ({y. ([(x, y)] \\<bullet> \\<Psi>) \\<otimes>\n        [(x, y)] \\<bullet> \\<Psi>' \\<noteq>\n        \\<Psi> \\<otimes> \\<Psi>'} -\n    {y. [(x, y)] \\<bullet> \\<Psi> \\<noteq> \\<Psi>} -\n    {y. [(x, y)] \\<bullet> \\<Psi>' \\<noteq> \\<Psi>'})\n\ngoal (1 subgoal):\n 1. infinite\n     {y. ([(x, y)] \\<bullet> \\<Psi>) \\<otimes>\n         [(x, y)] \\<bullet> \\<Psi>' \\<noteq>\n         \\<Psi> \\<otimes> \\<Psi>' \\<and>\n         \\<not> [(x, y)] \\<bullet> \\<Psi> \\<noteq> \\<Psi> \\<and>\n         \\<not> [(x, y)] \\<bullet> \\<Psi>' \\<noteq> \\<Psi>'}", "by(simp add: set_diff_eq)"], ["proof (state)\nthis:\n  infinite\n   {y. ([(x, y)] \\<bullet> \\<Psi>) \\<otimes>\n       [(x, y)] \\<bullet> \\<Psi>' \\<noteq>\n       \\<Psi> \\<otimes> \\<Psi>' \\<and>\n       \\<not> [(x, y)] \\<bullet> \\<Psi> \\<noteq> \\<Psi> \\<and>\n       \\<not> [(x, y)] \\<bullet> \\<Psi>' \\<noteq> \\<Psi>'}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>infinite\n                 {b. ([(x, b)] \\<bullet> \\<Psi>) \\<otimes>\n                     [(x, b)] \\<bullet> \\<Psi>' \\<noteq>\n                     \\<Psi> \\<otimes> \\<Psi>'};\n        finite {b. [(x, b)] \\<bullet> \\<Psi>' \\<noteq> \\<Psi>'};\n        finite {b. [(x, b)] \\<bullet> \\<Psi> \\<noteq> \\<Psi>}\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  infinite\n   {y. ([(x, y)] \\<bullet> \\<Psi>) \\<otimes>\n       [(x, y)] \\<bullet> \\<Psi>' \\<noteq>\n       \\<Psi> \\<otimes> \\<Psi>' \\<and>\n       \\<not> [(x, y)] \\<bullet> \\<Psi> \\<noteq> \\<Psi> \\<and>\n       \\<not> [(x, y)] \\<bullet> \\<Psi>' \\<noteq> \\<Psi>'}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>infinite\n                 {b. ([(x, b)] \\<bullet> \\<Psi>) \\<otimes>\n                     [(x, b)] \\<bullet> \\<Psi>' \\<noteq>\n                     \\<Psi> \\<otimes> \\<Psi>'};\n        finite {b. [(x, b)] \\<bullet> \\<Psi>' \\<noteq> \\<Psi>'};\n        finite {b. [(x, b)] \\<bullet> \\<Psi> \\<noteq> \\<Psi>}\\<rbrakk>\n       \\<Longrightarrow> False", "have \"{y. ?P(y) \\<and> \\<not>(?Q y \\<Psi>) \\<and> \\<not> (?Q y \\<Psi>')} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. ([(x, y)] \\<bullet> \\<Psi>) \\<otimes>\n        [(x, y)] \\<bullet> \\<Psi>' \\<noteq>\n        \\<Psi> \\<otimes> \\<Psi>' \\<and>\n        \\<not> [(x, y)] \\<bullet> \\<Psi> \\<noteq> \\<Psi> \\<and>\n        \\<not> [(x, y)] \\<bullet> \\<Psi>' \\<noteq> \\<Psi>'} =\n    {}", "by auto"], ["proof (state)\nthis:\n  {y. ([(x, y)] \\<bullet> \\<Psi>) \\<otimes>\n      [(x, y)] \\<bullet> \\<Psi>' \\<noteq>\n      \\<Psi> \\<otimes> \\<Psi>' \\<and>\n      \\<not> [(x, y)] \\<bullet> \\<Psi> \\<noteq> \\<Psi> \\<and>\n      \\<not> [(x, y)] \\<bullet> \\<Psi>' \\<noteq> \\<Psi>'} =\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>infinite\n                 {b. ([(x, b)] \\<bullet> \\<Psi>) \\<otimes>\n                     [(x, b)] \\<bullet> \\<Psi>' \\<noteq>\n                     \\<Psi> \\<otimes> \\<Psi>'};\n        finite {b. [(x, b)] \\<bullet> \\<Psi>' \\<noteq> \\<Psi>'};\n        finite {b. [(x, b)] \\<bullet> \\<Psi> \\<noteq> \\<Psi>}\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  infinite\n   {y. ([(x, y)] \\<bullet> \\<Psi>) \\<otimes>\n       [(x, y)] \\<bullet> \\<Psi>' \\<noteq>\n       \\<Psi> \\<otimes> \\<Psi>' \\<and>\n       \\<not> [(x, y)] \\<bullet> \\<Psi> \\<noteq> \\<Psi> \\<and>\n       \\<not> [(x, y)] \\<bullet> \\<Psi>' \\<noteq> \\<Psi>'}\n  {y. ([(x, y)] \\<bullet> \\<Psi>) \\<otimes>\n      [(x, y)] \\<bullet> \\<Psi>' \\<noteq>\n      \\<Psi> \\<otimes> \\<Psi>' \\<and>\n      \\<not> [(x, y)] \\<bullet> \\<Psi> \\<noteq> \\<Psi> \\<and>\n      \\<not> [(x, y)] \\<bullet> \\<Psi>' \\<noteq> \\<Psi>'} =\n  {}", "have \"infinite {}\""], ["proof (prove)\nusing this:\n  infinite\n   {y. ([(x, y)] \\<bullet> \\<Psi>) \\<otimes>\n       [(x, y)] \\<bullet> \\<Psi>' \\<noteq>\n       \\<Psi> \\<otimes> \\<Psi>' \\<and>\n       \\<not> [(x, y)] \\<bullet> \\<Psi> \\<noteq> \\<Psi> \\<and>\n       \\<not> [(x, y)] \\<bullet> \\<Psi>' \\<noteq> \\<Psi>'}\n  {y. ([(x, y)] \\<bullet> \\<Psi>) \\<otimes>\n      [(x, y)] \\<bullet> \\<Psi>' \\<noteq>\n      \\<Psi> \\<otimes> \\<Psi>' \\<and>\n      \\<not> [(x, y)] \\<bullet> \\<Psi> \\<noteq> \\<Psi> \\<and>\n      \\<not> [(x, y)] \\<bullet> \\<Psi>' \\<noteq> \\<Psi>'} =\n  {}\n\ngoal (1 subgoal):\n 1. infinite {}", "by(drule_tac Infinite_cong) auto"], ["proof (state)\nthis:\n  infinite {}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>infinite\n                 {b. ([(x, b)] \\<bullet> \\<Psi>) \\<otimes>\n                     [(x, b)] \\<bullet> \\<Psi>' \\<noteq>\n                     \\<Psi> \\<otimes> \\<Psi>'};\n        finite {b. [(x, b)] \\<bullet> \\<Psi>' \\<noteq> \\<Psi>'};\n        finite {b. [(x, b)] \\<bullet> \\<Psi> \\<noteq> \\<Psi>}\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  infinite {}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma chanEqSupp:\n  fixes M :: 'a\n  and   N :: 'a\n\n  shows \"(supp(M \\<leftrightarrow> N)::name set) \\<subseteq> ((supp M) \\<union> (supp N))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (M \\<leftrightarrow> N) \\<subseteq> supp M \\<union> supp N", "proof(auto simp add: eqvts supp_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>infinite\n                 {b. [(x, b)] \\<bullet>\n                     M \\<leftrightarrow> [(x, b)] \\<bullet> N \\<noteq>\n                     M \\<leftrightarrow> N};\n        finite {b. [(x, b)] \\<bullet> N \\<noteq> N};\n        finite {b. [(x, b)] \\<bullet> M \\<noteq> M}\\<rbrakk>\n       \\<Longrightarrow> False", "fix x::name"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>infinite\n                 {b. [(x, b)] \\<bullet>\n                     M \\<leftrightarrow> [(x, b)] \\<bullet> N \\<noteq>\n                     M \\<leftrightarrow> N};\n        finite {b. [(x, b)] \\<bullet> N \\<noteq> N};\n        finite {b. [(x, b)] \\<bullet> M \\<noteq> M}\\<rbrakk>\n       \\<Longrightarrow> False", "let ?P = \"\\<lambda>y. ([(x, y)] \\<bullet> M) \\<leftrightarrow> [(x, y)] \\<bullet> N \\<noteq> M \\<leftrightarrow> N\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>infinite\n                 {b. [(x, b)] \\<bullet>\n                     M \\<leftrightarrow> [(x, b)] \\<bullet> N \\<noteq>\n                     M \\<leftrightarrow> N};\n        finite {b. [(x, b)] \\<bullet> N \\<noteq> N};\n        finite {b. [(x, b)] \\<bullet> M \\<noteq> M}\\<rbrakk>\n       \\<Longrightarrow> False", "let ?Q = \"\\<lambda>y M. ([(x, y)] \\<bullet> M) \\<noteq> M\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>infinite\n                 {b. [(x, b)] \\<bullet>\n                     M \\<leftrightarrow> [(x, b)] \\<bullet> N \\<noteq>\n                     M \\<leftrightarrow> N};\n        finite {b. [(x, b)] \\<bullet> N \\<noteq> N};\n        finite {b. [(x, b)] \\<bullet> M \\<noteq> M}\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"finite {y. ?Q y N}\""], ["proof (state)\nthis:\n  finite {y. [(x, y)] \\<bullet> N \\<noteq> N}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>infinite\n                 {b. [(x, b)] \\<bullet>\n                     M \\<leftrightarrow> [(x, b)] \\<bullet> N \\<noteq>\n                     M \\<leftrightarrow> N};\n        finite {b. [(x, b)] \\<bullet> N \\<noteq> N};\n        finite {b. [(x, b)] \\<bullet> M \\<noteq> M}\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  finite {y. [(x, y)] \\<bullet> N \\<noteq> N}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>infinite\n                 {b. [(x, b)] \\<bullet>\n                     M \\<leftrightarrow> [(x, b)] \\<bullet> N \\<noteq>\n                     M \\<leftrightarrow> N};\n        finite {b. [(x, b)] \\<bullet> N \\<noteq> N};\n        finite {b. [(x, b)] \\<bullet> M \\<noteq> M}\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"finite {y. ?Q y M}\" and \"infinite {y. ?P(y)}\""], ["proof (state)\nthis:\n  finite {y. [(x, y)] \\<bullet> M \\<noteq> M}\n  infinite\n   {y. [(x, y)] \\<bullet> M \\<leftrightarrow> [(x, y)] \\<bullet> N \\<noteq>\n       M \\<leftrightarrow> N}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>infinite\n                 {b. [(x, b)] \\<bullet>\n                     M \\<leftrightarrow> [(x, b)] \\<bullet> N \\<noteq>\n                     M \\<leftrightarrow> N};\n        finite {b. [(x, b)] \\<bullet> N \\<noteq> N};\n        finite {b. [(x, b)] \\<bullet> M \\<noteq> M}\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"infinite({y. ?P(y)} - {y. ?Q y M})\""], ["proof (prove)\nusing this:\n  finite {y. [(x, y)] \\<bullet> M \\<noteq> M}\n  infinite\n   {y. [(x, y)] \\<bullet> M \\<leftrightarrow> [(x, y)] \\<bullet> N \\<noteq>\n       M \\<leftrightarrow> N}\n\ngoal (1 subgoal):\n 1. infinite\n     ({y. [(x, y)] \\<bullet>\n          M \\<leftrightarrow> [(x, y)] \\<bullet> N \\<noteq>\n          M \\<leftrightarrow> N} -\n      {y. [(x, y)] \\<bullet> M \\<noteq> M})", "by(rule Diff_infinite_finite)"], ["proof (state)\nthis:\n  infinite\n   ({y. [(x, y)] \\<bullet> M \\<leftrightarrow> [(x, y)] \\<bullet> N \\<noteq>\n        M \\<leftrightarrow> N} -\n    {y. [(x, y)] \\<bullet> M \\<noteq> M})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>infinite\n                 {b. [(x, b)] \\<bullet>\n                     M \\<leftrightarrow> [(x, b)] \\<bullet> N \\<noteq>\n                     M \\<leftrightarrow> N};\n        finite {b. [(x, b)] \\<bullet> N \\<noteq> N};\n        finite {b. [(x, b)] \\<bullet> M \\<noteq> M}\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  finite {y. [(x, y)] \\<bullet> N \\<noteq> N}\n  infinite\n   ({y. [(x, y)] \\<bullet> M \\<leftrightarrow> [(x, y)] \\<bullet> N \\<noteq>\n        M \\<leftrightarrow> N} -\n    {y. [(x, y)] \\<bullet> M \\<noteq> M})", "have \"infinite(({y. ?P(y)} - {y. ?Q y M}) - {y. ?Q y N})\""], ["proof (prove)\nusing this:\n  finite {y. [(x, y)] \\<bullet> N \\<noteq> N}\n  infinite\n   ({y. [(x, y)] \\<bullet> M \\<leftrightarrow> [(x, y)] \\<bullet> N \\<noteq>\n        M \\<leftrightarrow> N} -\n    {y. [(x, y)] \\<bullet> M \\<noteq> M})\n\ngoal (1 subgoal):\n 1. infinite\n     ({y. [(x, y)] \\<bullet>\n          M \\<leftrightarrow> [(x, y)] \\<bullet> N \\<noteq>\n          M \\<leftrightarrow> N} -\n      {y. [(x, y)] \\<bullet> M \\<noteq> M} -\n      {y. [(x, y)] \\<bullet> N \\<noteq> N})", "by(rule Diff_infinite_finite)"], ["proof (state)\nthis:\n  infinite\n   ({y. [(x, y)] \\<bullet> M \\<leftrightarrow> [(x, y)] \\<bullet> N \\<noteq>\n        M \\<leftrightarrow> N} -\n    {y. [(x, y)] \\<bullet> M \\<noteq> M} -\n    {y. [(x, y)] \\<bullet> N \\<noteq> N})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>infinite\n                 {b. [(x, b)] \\<bullet>\n                     M \\<leftrightarrow> [(x, b)] \\<bullet> N \\<noteq>\n                     M \\<leftrightarrow> N};\n        finite {b. [(x, b)] \\<bullet> N \\<noteq> N};\n        finite {b. [(x, b)] \\<bullet> M \\<noteq> M}\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"infinite({y. ?P(y) \\<and> \\<not>(?Q y M) \\<and> \\<not> (?Q y N)})\""], ["proof (prove)\nusing this:\n  infinite\n   ({y. [(x, y)] \\<bullet> M \\<leftrightarrow> [(x, y)] \\<bullet> N \\<noteq>\n        M \\<leftrightarrow> N} -\n    {y. [(x, y)] \\<bullet> M \\<noteq> M} -\n    {y. [(x, y)] \\<bullet> N \\<noteq> N})\n\ngoal (1 subgoal):\n 1. infinite\n     {y. [(x, y)] \\<bullet>\n         M \\<leftrightarrow> [(x, y)] \\<bullet> N \\<noteq>\n         M \\<leftrightarrow> N \\<and>\n         \\<not> [(x, y)] \\<bullet> M \\<noteq> M \\<and>\n         \\<not> [(x, y)] \\<bullet> N \\<noteq> N}", "by(simp add: set_diff_eq)"], ["proof (state)\nthis:\n  infinite\n   {y. [(x, y)] \\<bullet> M \\<leftrightarrow> [(x, y)] \\<bullet> N \\<noteq>\n       M \\<leftrightarrow> N \\<and>\n       \\<not> [(x, y)] \\<bullet> M \\<noteq> M \\<and>\n       \\<not> [(x, y)] \\<bullet> N \\<noteq> N}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>infinite\n                 {b. [(x, b)] \\<bullet>\n                     M \\<leftrightarrow> [(x, b)] \\<bullet> N \\<noteq>\n                     M \\<leftrightarrow> N};\n        finite {b. [(x, b)] \\<bullet> N \\<noteq> N};\n        finite {b. [(x, b)] \\<bullet> M \\<noteq> M}\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  infinite\n   {y. [(x, y)] \\<bullet> M \\<leftrightarrow> [(x, y)] \\<bullet> N \\<noteq>\n       M \\<leftrightarrow> N \\<and>\n       \\<not> [(x, y)] \\<bullet> M \\<noteq> M \\<and>\n       \\<not> [(x, y)] \\<bullet> N \\<noteq> N}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>infinite\n                 {b. [(x, b)] \\<bullet>\n                     M \\<leftrightarrow> [(x, b)] \\<bullet> N \\<noteq>\n                     M \\<leftrightarrow> N};\n        finite {b. [(x, b)] \\<bullet> N \\<noteq> N};\n        finite {b. [(x, b)] \\<bullet> M \\<noteq> M}\\<rbrakk>\n       \\<Longrightarrow> False", "have \"{y. ?P(y) \\<and> \\<not>(?Q y M) \\<and> \\<not> (?Q y N)} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. [(x, y)] \\<bullet> M \\<leftrightarrow> [(x, y)] \\<bullet> N \\<noteq>\n        M \\<leftrightarrow> N \\<and>\n        \\<not> [(x, y)] \\<bullet> M \\<noteq> M \\<and>\n        \\<not> [(x, y)] \\<bullet> N \\<noteq> N} =\n    {}", "by auto"], ["proof (state)\nthis:\n  {y. [(x, y)] \\<bullet> M \\<leftrightarrow> [(x, y)] \\<bullet> N \\<noteq>\n      M \\<leftrightarrow> N \\<and>\n      \\<not> [(x, y)] \\<bullet> M \\<noteq> M \\<and>\n      \\<not> [(x, y)] \\<bullet> N \\<noteq> N} =\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>infinite\n                 {b. [(x, b)] \\<bullet>\n                     M \\<leftrightarrow> [(x, b)] \\<bullet> N \\<noteq>\n                     M \\<leftrightarrow> N};\n        finite {b. [(x, b)] \\<bullet> N \\<noteq> N};\n        finite {b. [(x, b)] \\<bullet> M \\<noteq> M}\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  infinite\n   {y. [(x, y)] \\<bullet> M \\<leftrightarrow> [(x, y)] \\<bullet> N \\<noteq>\n       M \\<leftrightarrow> N \\<and>\n       \\<not> [(x, y)] \\<bullet> M \\<noteq> M \\<and>\n       \\<not> [(x, y)] \\<bullet> N \\<noteq> N}\n  {y. [(x, y)] \\<bullet> M \\<leftrightarrow> [(x, y)] \\<bullet> N \\<noteq>\n      M \\<leftrightarrow> N \\<and>\n      \\<not> [(x, y)] \\<bullet> M \\<noteq> M \\<and>\n      \\<not> [(x, y)] \\<bullet> N \\<noteq> N} =\n  {}", "have \"infinite {}\""], ["proof (prove)\nusing this:\n  infinite\n   {y. [(x, y)] \\<bullet> M \\<leftrightarrow> [(x, y)] \\<bullet> N \\<noteq>\n       M \\<leftrightarrow> N \\<and>\n       \\<not> [(x, y)] \\<bullet> M \\<noteq> M \\<and>\n       \\<not> [(x, y)] \\<bullet> N \\<noteq> N}\n  {y. [(x, y)] \\<bullet> M \\<leftrightarrow> [(x, y)] \\<bullet> N \\<noteq>\n      M \\<leftrightarrow> N \\<and>\n      \\<not> [(x, y)] \\<bullet> M \\<noteq> M \\<and>\n      \\<not> [(x, y)] \\<bullet> N \\<noteq> N} =\n  {}\n\ngoal (1 subgoal):\n 1. infinite {}", "by(drule_tac Infinite_cong) auto"], ["proof (state)\nthis:\n  infinite {}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>infinite\n                 {b. [(x, b)] \\<bullet>\n                     M \\<leftrightarrow> [(x, b)] \\<bullet> N \\<noteq>\n                     M \\<leftrightarrow> N};\n        finite {b. [(x, b)] \\<bullet> N \\<noteq> N};\n        finite {b. [(x, b)] \\<bullet> M \\<noteq> M}\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  infinite {}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma freshComp[intro]:\n  fixes x  :: name\n  and   \\<Psi>  :: 'b\n  and   \\<Psi>' :: 'b\n\n  assumes \"x \\<sharp> \\<Psi>\"\n  and     \"x \\<sharp> \\<Psi>'\"\n\n  shows \"x \\<sharp> \\<Psi> \\<otimes> \\<Psi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> \\<Psi> \\<otimes> \\<Psi>'", "using assms compSupp"], ["proof (prove)\nusing this:\n  x \\<sharp> \\<Psi>\n  x \\<sharp> \\<Psi>'\n  supp (?\\<Psi> \\<otimes> ?\\<Psi>')\n  \\<subseteq> supp ?\\<Psi> \\<union> supp ?\\<Psi>'\n\ngoal (1 subgoal):\n 1. x \\<sharp> \\<Psi> \\<otimes> \\<Psi>'", "by(auto simp add: fresh_def)"], ["", "lemma freshCompChain[intro]:\n  fixes xvec  :: \"name list\"\n  and   Xs    :: \"name set\"\n  and   \\<Psi>     :: 'b\n  and   \\<Psi>'    :: 'b\n\n  shows \"\\<lbrakk>xvec \\<sharp>* \\<Psi>; xvec \\<sharp>* \\<Psi>'\\<rbrakk> \\<Longrightarrow> xvec \\<sharp>* (\\<Psi> \\<otimes> \\<Psi>')\"\n  and   \"\\<lbrakk>Xs \\<sharp>* \\<Psi>; Xs \\<sharp>* \\<Psi>'\\<rbrakk> \\<Longrightarrow> Xs \\<sharp>* (\\<Psi> \\<otimes> \\<Psi>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>xvec \\<sharp>* \\<Psi>; xvec \\<sharp>* \\<Psi>'\\<rbrakk>\n     \\<Longrightarrow> xvec \\<sharp>* (\\<Psi> \\<otimes> \\<Psi>')) &&&\n    (\\<lbrakk>Xs \\<sharp>* \\<Psi>; Xs \\<sharp>* \\<Psi>'\\<rbrakk>\n     \\<Longrightarrow> Xs \\<sharp>* (\\<Psi> \\<otimes> \\<Psi>'))", "by(auto simp add: fresh_star_def)"], ["", "lemma freshChanEq[intro]:\n  fixes x :: name\n  and   M :: 'a\n  and   N :: 'a\n\n  assumes \"x \\<sharp> M\"\n  and     \"x \\<sharp> N\"\n\n  shows \"x \\<sharp> M \\<leftrightarrow> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> M \\<leftrightarrow> N", "using assms chanEqSupp"], ["proof (prove)\nusing this:\n  x \\<sharp> M\n  x \\<sharp> N\n  supp (?M \\<leftrightarrow> ?N) \\<subseteq> supp ?M \\<union> supp ?N\n\ngoal (1 subgoal):\n 1. x \\<sharp> M \\<leftrightarrow> N", "by(auto simp add: fresh_def)"], ["", "lemma freshChanEqChain[intro]:\n  fixes xvec :: \"name list\"\n  and   Xs   :: \"name set\"\n  and   M    :: 'a\n  and   N    :: 'a\n\n  shows \"\\<lbrakk>xvec \\<sharp>* M; xvec \\<sharp>* N\\<rbrakk> \\<Longrightarrow> xvec \\<sharp>* (M \\<leftrightarrow> N)\"\n  and   \"\\<lbrakk>Xs \\<sharp>* M; Xs \\<sharp>* N\\<rbrakk> \\<Longrightarrow> Xs \\<sharp>* (M \\<leftrightarrow> N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>xvec \\<sharp>* M; xvec \\<sharp>* N\\<rbrakk>\n     \\<Longrightarrow> xvec \\<sharp>* (M \\<leftrightarrow> N)) &&&\n    (\\<lbrakk>Xs \\<sharp>* M; Xs \\<sharp>* N\\<rbrakk>\n     \\<Longrightarrow> Xs \\<sharp>* (M \\<leftrightarrow> N))", "by(auto simp add: fresh_star_def)"], ["", "lemma suppBottom[simp]:\n  shows \"((supp SBottom)::name set) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (\\<bottom>) = {}", "by(auto simp add: supp_def permBottom)"], ["", "lemma freshBottom[simp]:\n  fixes x :: name\n  \n  shows \"x \\<sharp> \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> \\<bottom>", "by(simp add: fresh_def)"], ["", "lemma freshBottoChain[simp]:\n  fixes xvec :: \"name list\"\n  and   Xs   :: \"name set\"\n\n  shows \"xvec \\<sharp>* (\\<bottom>)\"\n  and   \"Xs   \\<sharp>* (\\<bottom>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xvec \\<sharp>* (\\<bottom>) &&& Xs \\<sharp>* (\\<bottom>)", "by(auto simp add: fresh_star_def)"], ["", "lemma chanEqClosed:\n  fixes \\<Psi> :: 'b\n  and   M :: 'a\n  and   N :: 'a\n  and   p :: \"name prm\"\n \n  assumes \"\\<Psi> \\<turnstile> M \\<leftrightarrow> N\"\n\n  shows \"(p \\<bullet> \\<Psi>) \\<turnstile> (p \\<bullet> M) \\<leftrightarrow> (p \\<bullet> N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet>\n    \\<Psi> \\<turnstile> p \\<bullet> M \\<leftrightarrow> p \\<bullet> N", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<bullet>\n    \\<Psi> \\<turnstile> p \\<bullet> M \\<leftrightarrow> p \\<bullet> N", "from \\<open>\\<Psi> \\<turnstile> M \\<leftrightarrow> N\\<close>"], ["proof (chain)\npicking this:\n  \\<Psi> \\<turnstile> M \\<leftrightarrow> N", "have \"(p \\<bullet> \\<Psi>) \\<turnstile> p \\<bullet> (M \\<leftrightarrow> N)\""], ["proof (prove)\nusing this:\n  \\<Psi> \\<turnstile> M \\<leftrightarrow> N\n\ngoal (1 subgoal):\n 1. p \\<bullet> \\<Psi> \\<turnstile> p \\<bullet> M \\<leftrightarrow> N", "by(rule statClosed)"], ["proof (state)\nthis:\n  p \\<bullet> \\<Psi> \\<turnstile> p \\<bullet> M \\<leftrightarrow> N\n\ngoal (1 subgoal):\n 1. p \\<bullet>\n    \\<Psi> \\<turnstile> p \\<bullet> M \\<leftrightarrow> p \\<bullet> N", "thus ?thesis"], ["proof (prove)\nusing this:\n  p \\<bullet> \\<Psi> \\<turnstile> p \\<bullet> M \\<leftrightarrow> N\n\ngoal (1 subgoal):\n 1. p \\<bullet>\n    \\<Psi> \\<turnstile> p \\<bullet> M \\<leftrightarrow> p \\<bullet> N", "by(simp add: eqvts)"], ["proof (state)\nthis:\n  p \\<bullet>\n  \\<Psi> \\<turnstile> p \\<bullet> M \\<leftrightarrow> p \\<bullet> N\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  AssertionStatImp :: \"'b \\<Rightarrow> 'b \\<Rightarrow> bool\" (infix \"\\<hookrightarrow>\" 70)\n  where \"(\\<Psi> \\<hookrightarrow> \\<Psi>') \\<equiv> (\\<forall>\\<Phi>. \\<Psi> \\<turnstile> \\<Phi> \\<longrightarrow> \\<Psi>' \\<turnstile> \\<Phi>)\""], ["", "definition\n  AssertionStatEq :: \"'b \\<Rightarrow> 'b \\<Rightarrow> bool\" (infix \"\\<simeq>\" 70)\n  where \"(\\<Psi> \\<simeq> \\<Psi>') \\<equiv> \\<Psi> \\<hookrightarrow> \\<Psi>' \\<and> \\<Psi>' \\<hookrightarrow> \\<Psi>\""], ["", "lemma statImpEnt:\n  fixes \\<Psi>  :: 'b\n  and   \\<Psi>' :: 'b\n  and   \\<Phi>  :: 'c\n\n  assumes \"\\<Psi> \\<hookrightarrow> \\<Psi>'\"\n  and     \"\\<Psi> \\<turnstile> \\<Phi>\"\n\n  shows \"\\<Psi>' \\<turnstile> \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi>' \\<turnstile> \\<Phi>", "using assms"], ["proof (prove)\nusing this:\n  \\<Psi> \\<hookrightarrow> \\<Psi>'\n  \\<Psi> \\<turnstile> \\<Phi>\n\ngoal (1 subgoal):\n 1. \\<Psi>' \\<turnstile> \\<Phi>", "by(simp add: AssertionStatImp_def)"], ["", "lemma statEqEnt:\n  fixes \\<Psi>  :: 'b\n  and   \\<Psi>' :: 'b\n  and   \\<Phi>  :: 'c\n\n  assumes \"\\<Psi> \\<simeq> \\<Psi>'\"\n  and     \"\\<Psi> \\<turnstile> \\<Phi>\"\n\n  shows \"\\<Psi>' \\<turnstile> \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi>' \\<turnstile> \\<Phi>", "using assms"], ["proof (prove)\nusing this:\n  \\<Psi> \\<simeq> \\<Psi>'\n  \\<Psi> \\<turnstile> \\<Phi>\n\ngoal (1 subgoal):\n 1. \\<Psi>' \\<turnstile> \\<Phi>", "by(auto simp add: AssertionStatEq_def intro: statImpEnt)"], ["", "lemma AssertionStatImpClosed:\n  fixes \\<Psi>  :: 'b\n  and   \\<Psi>' :: 'b\n  and   p  :: \"name prm\"\n\n  assumes \"\\<Psi> \\<hookrightarrow> \\<Psi>'\"\n\n  shows \"(p \\<bullet> \\<Psi>) \\<hookrightarrow> (p \\<bullet> \\<Psi>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> \\<Psi> \\<hookrightarrow> p \\<bullet> \\<Psi>'", "proof(auto simp add: AssertionStatImp_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi>.\n       p \\<bullet> \\<Psi> \\<turnstile> \\<Phi> \\<Longrightarrow>\n       p \\<bullet> \\<Psi>' \\<turnstile> \\<Phi>", "fix \\<phi>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi>.\n       p \\<bullet> \\<Psi> \\<turnstile> \\<Phi> \\<Longrightarrow>\n       p \\<bullet> \\<Psi>' \\<turnstile> \\<Phi>", "assume \"(p \\<bullet> \\<Psi>) \\<turnstile> \\<phi>\""], ["proof (state)\nthis:\n  p \\<bullet> \\<Psi> \\<turnstile> \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<Phi>.\n       p \\<bullet> \\<Psi> \\<turnstile> \\<Phi> \\<Longrightarrow>\n       p \\<bullet> \\<Psi>' \\<turnstile> \\<Phi>", "hence \"\\<Psi> \\<turnstile> rev p \\<bullet> \\<phi>\""], ["proof (prove)\nusing this:\n  p \\<bullet> \\<Psi> \\<turnstile> \\<phi>\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<turnstile> rev p \\<bullet> \\<phi>", "by(drule_tac p=\"rev p\" in statClosed) auto"], ["proof (state)\nthis:\n  \\<Psi> \\<turnstile> rev p \\<bullet> \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<Phi>.\n       p \\<bullet> \\<Psi> \\<turnstile> \\<Phi> \\<Longrightarrow>\n       p \\<bullet> \\<Psi>' \\<turnstile> \\<Phi>", "with \\<open>\\<Psi> \\<hookrightarrow> \\<Psi>'\\<close>"], ["proof (chain)\npicking this:\n  \\<Psi> \\<hookrightarrow> \\<Psi>'\n  \\<Psi> \\<turnstile> rev p \\<bullet> \\<phi>", "have \"\\<Psi>' \\<turnstile> rev p \\<bullet> \\<phi>\""], ["proof (prove)\nusing this:\n  \\<Psi> \\<hookrightarrow> \\<Psi>'\n  \\<Psi> \\<turnstile> rev p \\<bullet> \\<phi>\n\ngoal (1 subgoal):\n 1. \\<Psi>' \\<turnstile> rev p \\<bullet> \\<phi>", "by(simp add: AssertionStatImp_def)"], ["proof (state)\nthis:\n  \\<Psi>' \\<turnstile> rev p \\<bullet> \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<Phi>.\n       p \\<bullet> \\<Psi> \\<turnstile> \\<Phi> \\<Longrightarrow>\n       p \\<bullet> \\<Psi>' \\<turnstile> \\<Phi>", "thus \"(p \\<bullet> \\<Psi>') \\<turnstile> \\<phi>\""], ["proof (prove)\nusing this:\n  \\<Psi>' \\<turnstile> rev p \\<bullet> \\<phi>\n\ngoal (1 subgoal):\n 1. p \\<bullet> \\<Psi>' \\<turnstile> \\<phi>", "by(drule_tac p=p in statClosed) auto"], ["proof (state)\nthis:\n  p \\<bullet> \\<Psi>' \\<turnstile> \\<phi>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma AssertionStatEqClosed:\n  fixes \\<Psi>  :: 'b\n  and   \\<Psi>' :: 'b\n  and   p  :: \"name prm\"\n\n  assumes \"\\<Psi> \\<simeq> \\<Psi>'\"\n\n  shows \"(p \\<bullet> \\<Psi>) \\<simeq> (p \\<bullet> \\<Psi>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> \\<Psi> \\<simeq> p \\<bullet> \\<Psi>'", "using assms"], ["proof (prove)\nusing this:\n  \\<Psi> \\<simeq> \\<Psi>'\n\ngoal (1 subgoal):\n 1. p \\<bullet> \\<Psi> \\<simeq> p \\<bullet> \\<Psi>'", "by(auto simp add: AssertionStatEq_def intro: AssertionStatImpClosed)"], ["", "lemma AssertionStatImpEqvt[eqvt]:\n  fixes \\<Psi>  :: 'b\n  and   \\<Psi>' :: 'b\n  and   p  :: \"name prm\"\n\n  shows \"(p \\<bullet> (\\<Psi> \\<hookrightarrow> \\<Psi>')) = ((p \\<bullet> \\<Psi>) \\<hookrightarrow> (p \\<bullet> \\<Psi>'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (\\<Psi> \\<hookrightarrow> \\<Psi>') =\n    p \\<bullet> \\<Psi> \\<hookrightarrow> p \\<bullet> \\<Psi>'", "by(simp add: AssertionStatImp_def eqvts)"], ["", "lemma AssertionStatEqEqvt[eqvt]:\n  fixes \\<Psi>  :: 'b\n  and   \\<Psi>' :: 'b\n  and   p  :: \"name prm\"\n\n  shows \"(p \\<bullet> (\\<Psi> \\<simeq> \\<Psi>')) = ((p \\<bullet> \\<Psi>) \\<simeq> (p \\<bullet> \\<Psi>'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (\\<Psi> \\<simeq> \\<Psi>') =\n    p \\<bullet> \\<Psi> \\<simeq> p \\<bullet> \\<Psi>'", "by(simp add: AssertionStatEq_def eqvts)"], ["", "lemma AssertionStatImpRefl[simp]:\n  fixes \\<Psi> :: 'b\n\n  shows \"\\<Psi> \\<hookrightarrow> \\<Psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi> \\<hookrightarrow> \\<Psi>", "by(simp add: AssertionStatImp_def)"], ["", "lemma AssertionStatEqRefl[simp]:\n  fixes \\<Psi> :: 'b\n\n  shows \"\\<Psi> \\<simeq> \\<Psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi> \\<simeq> \\<Psi>", "by(simp add: AssertionStatEq_def)"], ["", "lemma AssertionStatEqSym:\n  fixes \\<Psi>   :: 'b\n  and   \\<Psi>'  :: 'b\n\n  assumes \"\\<Psi> \\<simeq> \\<Psi>'\"\n\n  shows \"\\<Psi>' \\<simeq> \\<Psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi>' \\<simeq> \\<Psi>", "using assms"], ["proof (prove)\nusing this:\n  \\<Psi> \\<simeq> \\<Psi>'\n\ngoal (1 subgoal):\n 1. \\<Psi>' \\<simeq> \\<Psi>", "by(auto simp add: AssertionStatEq_def)"], ["", "lemma AssertionStatImpTrans:\n  fixes \\<Psi>   :: 'b\n  and   \\<Psi>'  :: 'b\n  and   \\<Psi>'' :: 'b\n\n  assumes \"\\<Psi> \\<hookrightarrow> \\<Psi>'\"\n  and     \"\\<Psi>' \\<hookrightarrow> \\<Psi>''\"\n\n  shows \"\\<Psi> \\<hookrightarrow> \\<Psi>''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi> \\<hookrightarrow> \\<Psi>''", "using assms"], ["proof (prove)\nusing this:\n  \\<Psi> \\<hookrightarrow> \\<Psi>'\n  \\<Psi>' \\<hookrightarrow> \\<Psi>''\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<hookrightarrow> \\<Psi>''", "by(simp add: AssertionStatImp_def)"], ["", "lemma AssertionStatEqTrans:\n  fixes \\<Psi>   :: 'b\n  and   \\<Psi>'  :: 'b\n  and   \\<Psi>'' :: 'b\n\n  assumes \"\\<Psi> \\<simeq> \\<Psi>'\"\n  and     \"\\<Psi>' \\<simeq> \\<Psi>''\"\n\n  shows \"\\<Psi> \\<simeq> \\<Psi>''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi> \\<simeq> \\<Psi>''", "using assms"], ["proof (prove)\nusing this:\n  \\<Psi> \\<simeq> \\<Psi>'\n  \\<Psi>' \\<simeq> \\<Psi>''\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<simeq> \\<Psi>''", "by(auto simp add: AssertionStatEq_def intro: AssertionStatImpTrans)"], ["", "definition \n  FrameImp :: \"'b::fs_name frame \\<Rightarrow> 'c \\<Rightarrow> bool\"   (infixl \"\\<turnstile>\\<^sub>F\" 70)\n  where \"(F \\<turnstile>\\<^sub>F \\<Phi>) = (\\<exists>A\\<^sub>F \\<Psi>\\<^sub>F. F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and> A\\<^sub>F \\<sharp>* \\<Phi> \\<and> (\\<Psi>\\<^sub>F \\<turnstile> \\<Phi>))\""], ["", "lemma frameImpI:\n  fixes F  :: \"'b frame\"\n  and   \\<phi>  :: 'c\n  and   A\\<^sub>F :: \"name list\"\n  and   \\<Psi>\\<^sub>F :: 'b\n\n  assumes \"F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\"\n  and     \"A\\<^sub>F \\<sharp>* \\<phi>\"\n  and     \"\\<Psi>\\<^sub>F \\<turnstile> \\<phi>\"\n\n  shows \"F \\<turnstile>\\<^sub>F \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<turnstile>\\<^sub>F \\<phi>", "using assms"], ["proof (prove)\nusing this:\n  F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\n  A\\<^sub>F \\<sharp>* \\<phi>\n  \\<Psi>\\<^sub>F \\<turnstile> \\<phi>\n\ngoal (1 subgoal):\n 1. F \\<turnstile>\\<^sub>F \\<phi>", "by(force simp add: FrameImp_def)"], ["", "lemma frameImpAlphaEnt:\n  fixes A\\<^sub>F  :: \"name list\"\n  and   \\<Psi>\\<^sub>F  :: 'b\n  and   A\\<^sub>F' :: \"name list\"\n  and   \\<Psi>\\<^sub>F' :: 'b\n  and   \\<phi>   :: 'c\n\n  assumes \"\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> = \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F'\\<rangle>\" \n  and     \"A\\<^sub>F \\<sharp>* \\<phi>\"\n  and     \"A\\<^sub>F' \\<sharp>* \\<phi>\"\n  and     \"\\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\"\n\n  shows \"\\<Psi>\\<^sub>F \\<turnstile> \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>F \\<turnstile> \\<phi>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>F \\<turnstile> \\<phi>", "from \\<open>\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> = \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F'\\<rangle>\\<close>"], ["proof (chain)\npicking this:\n  \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F'\\<rangle>", "obtain n where \"n = length A\\<^sub>F\""], ["proof (prove)\nusing this:\n  \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F'\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        n = length A\\<^sub>F \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n = length A\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>F \\<turnstile> \\<phi>", "moreover"], ["proof (state)\nthis:\n  n = length A\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>F \\<turnstile> \\<phi>", "from \\<open>\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> = \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F'\\<rangle>\\<close>"], ["proof (chain)\npicking this:\n  \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F'\\<rangle>", "have \"length A\\<^sub>F = length A\\<^sub>F'\""], ["proof (prove)\nusing this:\n  \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F'\\<rangle>\n\ngoal (1 subgoal):\n 1. length A\\<^sub>F = length A\\<^sub>F'", "by(rule frameChainEqLength)"], ["proof (state)\nthis:\n  length A\\<^sub>F = length A\\<^sub>F'\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>F \\<turnstile> \\<phi>", "ultimately"], ["proof (chain)\npicking this:\n  n = length A\\<^sub>F\n  length A\\<^sub>F = length A\\<^sub>F'", "show ?thesis"], ["proof (prove)\nusing this:\n  n = length A\\<^sub>F\n  length A\\<^sub>F = length A\\<^sub>F'\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>F \\<turnstile> \\<phi>", "using assms"], ["proof (prove)\nusing this:\n  n = length A\\<^sub>F\n  length A\\<^sub>F = length A\\<^sub>F'\n  \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F'\\<rangle>\n  A\\<^sub>F \\<sharp>* \\<phi>\n  A\\<^sub>F' \\<sharp>* \\<phi>\n  \\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>F \\<turnstile> \\<phi>", "proof(induct n arbitrary: A\\<^sub>F A\\<^sub>F' \\<Psi>\\<^sub>F' rule: nat.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A\\<^sub>F A\\<^sub>F' \\<Psi>\\<^sub>F'.\n       \\<lbrakk>0 = length A\\<^sub>F; length A\\<^sub>F = length A\\<^sub>F';\n        \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n        \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F'\\<rangle>;\n        A\\<^sub>F \\<sharp>* \\<phi>; A\\<^sub>F' \\<sharp>* \\<phi>;\n        \\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>\n 2. \\<And>nat A\\<^sub>F A\\<^sub>F' \\<Psi>\\<^sub>F'.\n       \\<lbrakk>\\<And>A\\<^sub>F A\\<^sub>F' \\<Psi>\\<^sub>F'.\n                   \\<lbrakk>nat = length A\\<^sub>F;\n                    length A\\<^sub>F = length A\\<^sub>F';\n                    \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n                    \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F'\\<rangle>;\n                    A\\<^sub>F \\<sharp>* \\<phi>; A\\<^sub>F' \\<sharp>* \\<phi>;\n                    \\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>;\n        Suc nat = length A\\<^sub>F; length A\\<^sub>F = length A\\<^sub>F';\n        \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n        \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F'\\<rangle>;\n        A\\<^sub>F \\<sharp>* \\<phi>; A\\<^sub>F' \\<sharp>* \\<phi>;\n        \\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>", "case(zero A\\<^sub>F A\\<^sub>F' \\<Psi>\\<^sub>F')"], ["proof (state)\nthis:\n  0 = length A\\<^sub>F\n  length A\\<^sub>F = length A\\<^sub>F'\n  \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F'\\<rangle>\n  A\\<^sub>F \\<sharp>* \\<phi>\n  A\\<^sub>F' \\<sharp>* \\<phi>\n  \\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\n\ngoal (2 subgoals):\n 1. \\<And>A\\<^sub>F A\\<^sub>F' \\<Psi>\\<^sub>F'.\n       \\<lbrakk>0 = length A\\<^sub>F; length A\\<^sub>F = length A\\<^sub>F';\n        \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n        \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F'\\<rangle>;\n        A\\<^sub>F \\<sharp>* \\<phi>; A\\<^sub>F' \\<sharp>* \\<phi>;\n        \\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>\n 2. \\<And>nat A\\<^sub>F A\\<^sub>F' \\<Psi>\\<^sub>F'.\n       \\<lbrakk>\\<And>A\\<^sub>F A\\<^sub>F' \\<Psi>\\<^sub>F'.\n                   \\<lbrakk>nat = length A\\<^sub>F;\n                    length A\\<^sub>F = length A\\<^sub>F';\n                    \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n                    \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F'\\<rangle>;\n                    A\\<^sub>F \\<sharp>* \\<phi>; A\\<^sub>F' \\<sharp>* \\<phi>;\n                    \\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>;\n        Suc nat = length A\\<^sub>F; length A\\<^sub>F = length A\\<^sub>F';\n        \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n        \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F'\\<rangle>;\n        A\\<^sub>F \\<sharp>* \\<phi>; A\\<^sub>F' \\<sharp>* \\<phi>;\n        \\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>", "thus ?case"], ["proof (prove)\nusing this:\n  0 = length A\\<^sub>F\n  length A\\<^sub>F = length A\\<^sub>F'\n  \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F'\\<rangle>\n  A\\<^sub>F \\<sharp>* \\<phi>\n  A\\<^sub>F' \\<sharp>* \\<phi>\n  \\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>F \\<turnstile> \\<phi>", "by(auto simp add: frame.inject)"], ["proof (state)\nthis:\n  \\<Psi>\\<^sub>F \\<turnstile> \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>nat A\\<^sub>F A\\<^sub>F' \\<Psi>\\<^sub>F'.\n       \\<lbrakk>\\<And>A\\<^sub>F A\\<^sub>F' \\<Psi>\\<^sub>F'.\n                   \\<lbrakk>nat = length A\\<^sub>F;\n                    length A\\<^sub>F = length A\\<^sub>F';\n                    \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n                    \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F'\\<rangle>;\n                    A\\<^sub>F \\<sharp>* \\<phi>; A\\<^sub>F' \\<sharp>* \\<phi>;\n                    \\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>;\n        Suc nat = length A\\<^sub>F; length A\\<^sub>F = length A\\<^sub>F';\n        \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n        \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F'\\<rangle>;\n        A\\<^sub>F \\<sharp>* \\<phi>; A\\<^sub>F' \\<sharp>* \\<phi>;\n        \\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat A\\<^sub>F A\\<^sub>F' \\<Psi>\\<^sub>F'.\n       \\<lbrakk>\\<And>A\\<^sub>F A\\<^sub>F' \\<Psi>\\<^sub>F'.\n                   \\<lbrakk>nat = length A\\<^sub>F;\n                    length A\\<^sub>F = length A\\<^sub>F';\n                    \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n                    \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F'\\<rangle>;\n                    A\\<^sub>F \\<sharp>* \\<phi>; A\\<^sub>F' \\<sharp>* \\<phi>;\n                    \\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>;\n        Suc nat = length A\\<^sub>F; length A\\<^sub>F = length A\\<^sub>F';\n        \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n        \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F'\\<rangle>;\n        A\\<^sub>F \\<sharp>* \\<phi>; A\\<^sub>F' \\<sharp>* \\<phi>;\n        \\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>", "case(Suc n A\\<^sub>F A\\<^sub>F' \\<Psi>\\<^sub>F')"], ["proof (state)\nthis:\n  \\<lbrakk>n = length ?A\\<^sub>F; length ?A\\<^sub>F = length ?A\\<^sub>F';\n   \\<langle>?A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n   \\<langle>?A\\<^sub>F', ?\\<Psi>\\<^sub>F'\\<rangle>;\n   ?A\\<^sub>F \\<sharp>* \\<phi>; ?A\\<^sub>F' \\<sharp>* \\<phi>;\n   ?\\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\\<rbrakk>\n  \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>\n  Suc n = length A\\<^sub>F\n  length A\\<^sub>F = length A\\<^sub>F'\n  \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F'\\<rangle>\n  A\\<^sub>F \\<sharp>* \\<phi>\n  A\\<^sub>F' \\<sharp>* \\<phi>\n  \\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>nat A\\<^sub>F A\\<^sub>F' \\<Psi>\\<^sub>F'.\n       \\<lbrakk>\\<And>A\\<^sub>F A\\<^sub>F' \\<Psi>\\<^sub>F'.\n                   \\<lbrakk>nat = length A\\<^sub>F;\n                    length A\\<^sub>F = length A\\<^sub>F';\n                    \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n                    \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F'\\<rangle>;\n                    A\\<^sub>F \\<sharp>* \\<phi>; A\\<^sub>F' \\<sharp>* \\<phi>;\n                    \\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>;\n        Suc nat = length A\\<^sub>F; length A\\<^sub>F = length A\\<^sub>F';\n        \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n        \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F'\\<rangle>;\n        A\\<^sub>F \\<sharp>* \\<phi>; A\\<^sub>F' \\<sharp>* \\<phi>;\n        \\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>", "from \\<open>Suc n = length A\\<^sub>F\\<close>"], ["proof (chain)\npicking this:\n  Suc n = length A\\<^sub>F", "obtain x xs where \"A\\<^sub>F = x#xs\" and \"n = length xs\""], ["proof (prove)\nusing this:\n  Suc n = length A\\<^sub>F\n\ngoal (1 subgoal):\n 1. (\\<And>x xs.\n        \\<lbrakk>A\\<^sub>F = x # xs; n = length xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(case_tac A\\<^sub>F) auto"], ["proof (state)\nthis:\n  A\\<^sub>F = x # xs\n  n = length xs\n\ngoal (1 subgoal):\n 1. \\<And>nat A\\<^sub>F A\\<^sub>F' \\<Psi>\\<^sub>F'.\n       \\<lbrakk>\\<And>A\\<^sub>F A\\<^sub>F' \\<Psi>\\<^sub>F'.\n                   \\<lbrakk>nat = length A\\<^sub>F;\n                    length A\\<^sub>F = length A\\<^sub>F';\n                    \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n                    \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F'\\<rangle>;\n                    A\\<^sub>F \\<sharp>* \\<phi>; A\\<^sub>F' \\<sharp>* \\<phi>;\n                    \\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>;\n        Suc nat = length A\\<^sub>F; length A\\<^sub>F = length A\\<^sub>F';\n        \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n        \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F'\\<rangle>;\n        A\\<^sub>F \\<sharp>* \\<phi>; A\\<^sub>F' \\<sharp>* \\<phi>;\n        \\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>", "from \\<open>\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> = \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F'\\<rangle>\\<close> \\<open>A\\<^sub>F = x # xs\\<close>"], ["proof (chain)\npicking this:\n  \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F'\\<rangle>\n  A\\<^sub>F = x # xs", "obtain y ys where \"\\<langle>(x#xs), \\<Psi>\\<^sub>F\\<rangle> = \\<langle>(y#ys), \\<Psi>\\<^sub>F'\\<rangle>\" and \"A\\<^sub>F' = y#ys\""], ["proof (prove)\nusing this:\n  \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F'\\<rangle>\n  A\\<^sub>F = x # xs\n\ngoal (1 subgoal):\n 1. (\\<And>y ys.\n        \\<lbrakk>\\<langle>(x # xs), \\<Psi>\\<^sub>F\\<rangle> =\n                 \\<langle>(y # ys), \\<Psi>\\<^sub>F'\\<rangle>;\n         A\\<^sub>F' = y # ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(case_tac A\\<^sub>F') auto"], ["proof (state)\nthis:\n  \\<langle>(x # xs), \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>(y # ys), \\<Psi>\\<^sub>F'\\<rangle>\n  A\\<^sub>F' = y # ys\n\ngoal (1 subgoal):\n 1. \\<And>nat A\\<^sub>F A\\<^sub>F' \\<Psi>\\<^sub>F'.\n       \\<lbrakk>\\<And>A\\<^sub>F A\\<^sub>F' \\<Psi>\\<^sub>F'.\n                   \\<lbrakk>nat = length A\\<^sub>F;\n                    length A\\<^sub>F = length A\\<^sub>F';\n                    \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n                    \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F'\\<rangle>;\n                    A\\<^sub>F \\<sharp>* \\<phi>; A\\<^sub>F' \\<sharp>* \\<phi>;\n                    \\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>;\n        Suc nat = length A\\<^sub>F; length A\\<^sub>F = length A\\<^sub>F';\n        \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n        \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F'\\<rangle>;\n        A\\<^sub>F \\<sharp>* \\<phi>; A\\<^sub>F' \\<sharp>* \\<phi>;\n        \\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>", "hence EQ: \"\\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>*xs\\<rparr>(FAssert \\<Psi>\\<^sub>F) = \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>*ys\\<rparr>(FAssert \\<Psi>\\<^sub>F')\""], ["proof (prove)\nusing this:\n  \\<langle>(x # xs), \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>(y # ys), \\<Psi>\\<^sub>F'\\<rangle>\n  A\\<^sub>F' = y # ys\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>\\<langle>xs, \\<Psi>\\<^sub>F\\<rangle> =\n    \\<lparr>\\<nu>y\\<rparr>\\<langle>ys, \\<Psi>\\<^sub>F'\\<rangle>", "by simp"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>\\<langle>xs, \\<Psi>\\<^sub>F\\<rangle> =\n  \\<lparr>\\<nu>y\\<rparr>\\<langle>ys, \\<Psi>\\<^sub>F'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>nat A\\<^sub>F A\\<^sub>F' \\<Psi>\\<^sub>F'.\n       \\<lbrakk>\\<And>A\\<^sub>F A\\<^sub>F' \\<Psi>\\<^sub>F'.\n                   \\<lbrakk>nat = length A\\<^sub>F;\n                    length A\\<^sub>F = length A\\<^sub>F';\n                    \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n                    \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F'\\<rangle>;\n                    A\\<^sub>F \\<sharp>* \\<phi>; A\\<^sub>F' \\<sharp>* \\<phi>;\n                    \\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>;\n        Suc nat = length A\\<^sub>F; length A\\<^sub>F = length A\\<^sub>F';\n        \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n        \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F'\\<rangle>;\n        A\\<^sub>F \\<sharp>* \\<phi>; A\\<^sub>F' \\<sharp>* \\<phi>;\n        \\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>", "from \\<open>A\\<^sub>F = x # xs\\<close> \\<open>A\\<^sub>F' = y # ys\\<close> \\<open>length A\\<^sub>F = length A\\<^sub>F'\\<close> \\<open>A\\<^sub>F \\<sharp>* \\<phi>\\<close> \\<open>A\\<^sub>F' \\<sharp>* \\<phi>\\<close>"], ["proof (chain)\npicking this:\n  A\\<^sub>F = x # xs\n  A\\<^sub>F' = y # ys\n  length A\\<^sub>F = length A\\<^sub>F'\n  A\\<^sub>F \\<sharp>* \\<phi>\n  A\\<^sub>F' \\<sharp>* \\<phi>", "have \"length xs = length ys\" and \"xs \\<sharp>* \\<phi>\" and \"ys \\<sharp>* \\<phi>\" and \"x \\<sharp> \\<phi>\" and \"y \\<sharp> \\<phi>\""], ["proof (prove)\nusing this:\n  A\\<^sub>F = x # xs\n  A\\<^sub>F' = y # ys\n  length A\\<^sub>F = length A\\<^sub>F'\n  A\\<^sub>F \\<sharp>* \\<phi>\n  A\\<^sub>F' \\<sharp>* \\<phi>\n\ngoal (1 subgoal):\n 1. (length xs = length ys &&& xs \\<sharp>* \\<phi>) &&&\n    ys \\<sharp>* \\<phi> &&& x \\<sharp> \\<phi> &&& y \\<sharp> \\<phi>", "by auto"], ["proof (state)\nthis:\n  length xs = length ys\n  xs \\<sharp>* \\<phi>\n  ys \\<sharp>* \\<phi>\n  x \\<sharp> \\<phi>\n  y \\<sharp> \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>nat A\\<^sub>F A\\<^sub>F' \\<Psi>\\<^sub>F'.\n       \\<lbrakk>\\<And>A\\<^sub>F A\\<^sub>F' \\<Psi>\\<^sub>F'.\n                   \\<lbrakk>nat = length A\\<^sub>F;\n                    length A\\<^sub>F = length A\\<^sub>F';\n                    \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n                    \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F'\\<rangle>;\n                    A\\<^sub>F \\<sharp>* \\<phi>; A\\<^sub>F' \\<sharp>* \\<phi>;\n                    \\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>;\n        Suc nat = length A\\<^sub>F; length A\\<^sub>F = length A\\<^sub>F';\n        \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n        \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F'\\<rangle>;\n        A\\<^sub>F \\<sharp>* \\<phi>; A\\<^sub>F' \\<sharp>* \\<phi>;\n        \\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>", "have IH: \"\\<And>xs ys \\<Psi>\\<^sub>F'. \\<lbrakk>n = length xs; length xs = length ys; \\<langle>xs, \\<Psi>\\<^sub>F\\<rangle> = \\<langle>ys, (\\<Psi>\\<^sub>F'::'b)\\<rangle>; xs \\<sharp>* \\<phi>; ys \\<sharp>* \\<phi>; \\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\\<rbrakk> \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs ys \\<Psi>\\<^sub>F'.\n       \\<lbrakk>n = length xs; length xs = length ys;\n        \\<langle>xs, \\<Psi>\\<^sub>F\\<rangle> =\n        \\<langle>ys, \\<Psi>\\<^sub>F'\\<rangle>;\n        xs \\<sharp>* \\<phi>; ys \\<sharp>* \\<phi>;\n        \\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>", "by fact"], ["proof (state)\nthis:\n  \\<lbrakk>n = length ?xs; length ?xs = length ?ys;\n   \\<langle>?xs, \\<Psi>\\<^sub>F\\<rangle> =\n   \\<langle>?ys, ?\\<Psi>\\<^sub>F'\\<rangle>;\n   ?xs \\<sharp>* \\<phi>; ?ys \\<sharp>* \\<phi>;\n   ?\\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\\<rbrakk>\n  \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>nat A\\<^sub>F A\\<^sub>F' \\<Psi>\\<^sub>F'.\n       \\<lbrakk>\\<And>A\\<^sub>F A\\<^sub>F' \\<Psi>\\<^sub>F'.\n                   \\<lbrakk>nat = length A\\<^sub>F;\n                    length A\\<^sub>F = length A\\<^sub>F';\n                    \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n                    \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F'\\<rangle>;\n                    A\\<^sub>F \\<sharp>* \\<phi>; A\\<^sub>F' \\<sharp>* \\<phi>;\n                    \\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>;\n        Suc nat = length A\\<^sub>F; length A\\<^sub>F = length A\\<^sub>F';\n        \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> =\n        \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F'\\<rangle>;\n        A\\<^sub>F \\<sharp>* \\<phi>; A\\<^sub>F' \\<sharp>* \\<phi>;\n        \\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>F \\<turnstile> \\<phi>", "proof(case_tac \"x = y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>\n 2. x \\<noteq> y \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>", "assume \"x = y\""], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>\n 2. x \\<noteq> y \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>", "with EQ"], ["proof (chain)\npicking this:\n  \\<lparr>\\<nu>x\\<rparr>\\<langle>xs, \\<Psi>\\<^sub>F\\<rangle> =\n  \\<lparr>\\<nu>y\\<rparr>\\<langle>ys, \\<Psi>\\<^sub>F'\\<rangle>\n  x = y", "have \"\\<langle>xs, \\<Psi>\\<^sub>F\\<rangle> = \\<langle>ys, \\<Psi>\\<^sub>F'\\<rangle>\""], ["proof (prove)\nusing this:\n  \\<lparr>\\<nu>x\\<rparr>\\<langle>xs, \\<Psi>\\<^sub>F\\<rangle> =\n  \\<lparr>\\<nu>y\\<rparr>\\<langle>ys, \\<Psi>\\<^sub>F'\\<rangle>\n  x = y\n\ngoal (1 subgoal):\n 1. \\<langle>xs, \\<Psi>\\<^sub>F\\<rangle> =\n    \\<langle>ys, \\<Psi>\\<^sub>F'\\<rangle>", "by(simp add: alpha frame.inject)"], ["proof (state)\nthis:\n  \\<langle>xs, \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>ys, \\<Psi>\\<^sub>F'\\<rangle>\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>\n 2. x \\<noteq> y \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>", "with IH \\<open>n = length xs\\<close> \\<open>length xs = length ys\\<close> \\<open>xs \\<sharp>* \\<phi>\\<close>  \\<open>ys \\<sharp>* \\<phi>\\<close> \\<open>\\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>n = length ?xs; length ?xs = length ?ys;\n   \\<langle>?xs, \\<Psi>\\<^sub>F\\<rangle> =\n   \\<langle>?ys, ?\\<Psi>\\<^sub>F'\\<rangle>;\n   ?xs \\<sharp>* \\<phi>; ?ys \\<sharp>* \\<phi>;\n   ?\\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\\<rbrakk>\n  \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>\n  n = length xs\n  length xs = length ys\n  xs \\<sharp>* \\<phi>\n  ys \\<sharp>* \\<phi>\n  \\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\n  \\<langle>xs, \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>ys, \\<Psi>\\<^sub>F'\\<rangle>", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>n = length ?xs; length ?xs = length ?ys;\n   \\<langle>?xs, \\<Psi>\\<^sub>F\\<rangle> =\n   \\<langle>?ys, ?\\<Psi>\\<^sub>F'\\<rangle>;\n   ?xs \\<sharp>* \\<phi>; ?ys \\<sharp>* \\<phi>;\n   ?\\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\\<rbrakk>\n  \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>\n  n = length xs\n  length xs = length ys\n  xs \\<sharp>* \\<phi>\n  ys \\<sharp>* \\<phi>\n  \\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\n  \\<langle>xs, \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>ys, \\<Psi>\\<^sub>F'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>F \\<turnstile> \\<phi>", "by blast"], ["proof (state)\nthis:\n  \\<Psi>\\<^sub>F \\<turnstile> \\<phi>\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>", "assume \"x \\<noteq> y\""], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>", "with EQ"], ["proof (chain)\npicking this:\n  \\<lparr>\\<nu>x\\<rparr>\\<langle>xs, \\<Psi>\\<^sub>F\\<rangle> =\n  \\<lparr>\\<nu>y\\<rparr>\\<langle>ys, \\<Psi>\\<^sub>F'\\<rangle>\n  x \\<noteq> y", "have \"\\<langle>xs, \\<Psi>\\<^sub>F\\<rangle> = [(x, y)] \\<bullet> \\<langle>ys, \\<Psi>\\<^sub>F'\\<rangle>\""], ["proof (prove)\nusing this:\n  \\<lparr>\\<nu>x\\<rparr>\\<langle>xs, \\<Psi>\\<^sub>F\\<rangle> =\n  \\<lparr>\\<nu>y\\<rparr>\\<langle>ys, \\<Psi>\\<^sub>F'\\<rangle>\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<langle>xs, \\<Psi>\\<^sub>F\\<rangle> =\n    [(x, y)] \\<bullet> \\<langle>ys, \\<Psi>\\<^sub>F'\\<rangle>", "by(simp add: alpha frame.inject)"], ["proof (state)\nthis:\n  \\<langle>xs, \\<Psi>\\<^sub>F\\<rangle> =\n  [(x, y)] \\<bullet> \\<langle>ys, \\<Psi>\\<^sub>F'\\<rangle>\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>", "hence \"\\<langle>xs, \\<Psi>\\<^sub>F\\<rangle> = \\<langle>([(x, y)] \\<bullet> ys), ([(x, y)] \\<bullet> \\<Psi>\\<^sub>F')\\<rangle>\""], ["proof (prove)\nusing this:\n  \\<langle>xs, \\<Psi>\\<^sub>F\\<rangle> =\n  [(x, y)] \\<bullet> \\<langle>ys, \\<Psi>\\<^sub>F'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>xs, \\<Psi>\\<^sub>F\\<rangle> =\n    \\<langle>[(x, y)] \\<bullet>\n             ys, [(x, y)] \\<bullet> \\<Psi>\\<^sub>F'\\<rangle>", "by(simp add: eqvts)"], ["proof (state)\nthis:\n  \\<langle>xs, \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>[(x, y)] \\<bullet>\n           ys, [(x, y)] \\<bullet> \\<Psi>\\<^sub>F'\\<rangle>\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>", "moreover"], ["proof (state)\nthis:\n  \\<langle>xs, \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>[(x, y)] \\<bullet>\n           ys, [(x, y)] \\<bullet> \\<Psi>\\<^sub>F'\\<rangle>\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>", "from \\<open>length xs = length ys\\<close>"], ["proof (chain)\npicking this:\n  length xs = length ys", "have \"length xs = length([(x, y)] \\<bullet> ys)\""], ["proof (prove)\nusing this:\n  length xs = length ys\n\ngoal (1 subgoal):\n 1. length xs = length ([(x, y)] \\<bullet> ys)", "by auto"], ["proof (state)\nthis:\n  length xs = length ([(x, y)] \\<bullet> ys)\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>", "moreover"], ["proof (state)\nthis:\n  length xs = length ([(x, y)] \\<bullet> ys)\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>", "from \\<open>ys \\<sharp>* \\<phi>\\<close>"], ["proof (chain)\npicking this:\n  ys \\<sharp>* \\<phi>", "have \"([(x, y)] \\<bullet> ys) \\<sharp>* ([(x, y)] \\<bullet> \\<phi>)\""], ["proof (prove)\nusing this:\n  ys \\<sharp>* \\<phi>\n\ngoal (1 subgoal):\n 1. ([(x, y)] \\<bullet> ys) \\<sharp>* ([(x, y)] \\<bullet> \\<phi>)", "by(simp add: fresh_star_bij)"], ["proof (state)\nthis:\n  ([(x, y)] \\<bullet> ys) \\<sharp>* ([(x, y)] \\<bullet> \\<phi>)\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>", "with \\<open>x \\<sharp> \\<phi>\\<close> \\<open>y \\<sharp> \\<phi>\\<close>"], ["proof (chain)\npicking this:\n  x \\<sharp> \\<phi>\n  y \\<sharp> \\<phi>\n  ([(x, y)] \\<bullet> ys) \\<sharp>* ([(x, y)] \\<bullet> \\<phi>)", "have \"([(x, y)] \\<bullet> ys) \\<sharp>* \\<phi>\""], ["proof (prove)\nusing this:\n  x \\<sharp> \\<phi>\n  y \\<sharp> \\<phi>\n  ([(x, y)] \\<bullet> ys) \\<sharp>* ([(x, y)] \\<bullet> \\<phi>)\n\ngoal (1 subgoal):\n 1. ([(x, y)] \\<bullet> ys) \\<sharp>* \\<phi>", "by simp"], ["proof (state)\nthis:\n  ([(x, y)] \\<bullet> ys) \\<sharp>* \\<phi>\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>", "moreover"], ["proof (state)\nthis:\n  ([(x, y)] \\<bullet> ys) \\<sharp>* \\<phi>\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>", "with \\<open>\\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\\<close>"], ["proof (chain)\npicking this:\n  \\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\n  ([(x, y)] \\<bullet> ys) \\<sharp>* \\<phi>", "have \"([(x, y)] \\<bullet> \\<Psi>\\<^sub>F') \\<turnstile> ([(x, y)] \\<bullet> \\<phi>)\""], ["proof (prove)\nusing this:\n  \\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\n  ([(x, y)] \\<bullet> ys) \\<sharp>* \\<phi>\n\ngoal (1 subgoal):\n 1. [(x, y)] \\<bullet>\n    \\<Psi>\\<^sub>F' \\<turnstile> [(x, y)] \\<bullet> \\<phi>", "by(simp add: statClosed)"], ["proof (state)\nthis:\n  [(x, y)] \\<bullet> \\<Psi>\\<^sub>F' \\<turnstile> [(x, y)] \\<bullet> \\<phi>\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>", "with \\<open>x \\<sharp> \\<phi>\\<close> \\<open>y \\<sharp> \\<phi>\\<close>"], ["proof (chain)\npicking this:\n  x \\<sharp> \\<phi>\n  y \\<sharp> \\<phi>\n  [(x, y)] \\<bullet> \\<Psi>\\<^sub>F' \\<turnstile> [(x, y)] \\<bullet> \\<phi>", "have \"([(x, y)] \\<bullet> \\<Psi>\\<^sub>F') \\<turnstile> \\<phi>\""], ["proof (prove)\nusing this:\n  x \\<sharp> \\<phi>\n  y \\<sharp> \\<phi>\n  [(x, y)] \\<bullet> \\<Psi>\\<^sub>F' \\<turnstile> [(x, y)] \\<bullet> \\<phi>\n\ngoal (1 subgoal):\n 1. [(x, y)] \\<bullet> \\<Psi>\\<^sub>F' \\<turnstile> \\<phi>", "by simp"], ["proof (state)\nthis:\n  [(x, y)] \\<bullet> \\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>", "ultimately"], ["proof (chain)\npicking this:\n  \\<langle>xs, \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>[(x, y)] \\<bullet>\n           ys, [(x, y)] \\<bullet> \\<Psi>\\<^sub>F'\\<rangle>\n  length xs = length ([(x, y)] \\<bullet> ys)\n  ([(x, y)] \\<bullet> ys) \\<sharp>* \\<phi>\n  [(x, y)] \\<bullet> \\<Psi>\\<^sub>F' \\<turnstile> \\<phi>", "show ?case"], ["proof (prove)\nusing this:\n  \\<langle>xs, \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>[(x, y)] \\<bullet>\n           ys, [(x, y)] \\<bullet> \\<Psi>\\<^sub>F'\\<rangle>\n  length xs = length ([(x, y)] \\<bullet> ys)\n  ([(x, y)] \\<bullet> ys) \\<sharp>* \\<phi>\n  [(x, y)] \\<bullet> \\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>F \\<turnstile> \\<phi>", "using IH \\<open>n = length xs\\<close> \\<open>xs \\<sharp>* \\<phi>\\<close>"], ["proof (prove)\nusing this:\n  \\<langle>xs, \\<Psi>\\<^sub>F\\<rangle> =\n  \\<langle>[(x, y)] \\<bullet>\n           ys, [(x, y)] \\<bullet> \\<Psi>\\<^sub>F'\\<rangle>\n  length xs = length ([(x, y)] \\<bullet> ys)\n  ([(x, y)] \\<bullet> ys) \\<sharp>* \\<phi>\n  [(x, y)] \\<bullet> \\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\n  \\<lbrakk>n = length ?xs; length ?xs = length ?ys;\n   \\<langle>?xs, \\<Psi>\\<^sub>F\\<rangle> =\n   \\<langle>?ys, ?\\<Psi>\\<^sub>F'\\<rangle>;\n   ?xs \\<sharp>* \\<phi>; ?ys \\<sharp>* \\<phi>;\n   ?\\<Psi>\\<^sub>F' \\<turnstile> \\<phi>\\<rbrakk>\n  \\<Longrightarrow> \\<Psi>\\<^sub>F \\<turnstile> \\<phi>\n  n = length xs\n  xs \\<sharp>* \\<phi>\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>F \\<turnstile> \\<phi>", "by blast"], ["proof (state)\nthis:\n  \\<Psi>\\<^sub>F \\<turnstile> \\<phi>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Psi>\\<^sub>F \\<turnstile> \\<phi>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Psi>\\<^sub>F \\<turnstile> \\<phi>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma frameImpEAux:\n  fixes F  :: \"'b frame\"\n  and   \\<Phi>  :: 'c\n\n  assumes  \"F \\<turnstile>\\<^sub>F \\<Phi>\"\n  and      \"F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\"\n  and      \"A\\<^sub>F \\<sharp>* \\<Phi>\"\n  \n  shows \"\\<Psi>\\<^sub>F \\<turnstile> \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>F \\<turnstile> \\<Phi>", "using assms"], ["proof (prove)\nusing this:\n  F \\<turnstile>\\<^sub>F \\<Phi>\n  F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\n  A\\<^sub>F \\<sharp>* \\<Phi>\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>F \\<turnstile> \\<Phi>", "by(auto simp add: FrameImp_def dest: frameImpAlphaEnt)"], ["", "lemma frameImpE:\n  fixes F  :: \"'b frame\"\n  and   \\<Phi>  :: 'c\n\n  assumes  \"\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<turnstile>\\<^sub>F \\<Phi>\"\n  and      \"A\\<^sub>F \\<sharp>* \\<Phi>\"\n  \n  shows \"\\<Psi>\\<^sub>F \\<turnstile> \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>F \\<turnstile> \\<Phi>", "using assms"], ["proof (prove)\nusing this:\n  \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<turnstile>\\<^sub>F \\<Phi>\n  A\\<^sub>F \\<sharp>* \\<Phi>\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>F \\<turnstile> \\<Phi>", "by(auto elim: frameImpEAux)"], ["", "lemma frameImpClosed:\n  fixes F :: \"'b frame\"\n  and   \\<Phi> :: 'c\n  and   p :: \"name prm\"\n\n  assumes \"F \\<turnstile>\\<^sub>F \\<Phi>\"\n\n  shows \"(p \\<bullet> F) \\<turnstile>\\<^sub>F (p \\<bullet> \\<Phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> F \\<turnstile>\\<^sub>F p \\<bullet> \\<Phi>", "using assms"], ["proof (prove)\nusing this:\n  F \\<turnstile>\\<^sub>F \\<Phi>\n\ngoal (1 subgoal):\n 1. p \\<bullet> F \\<turnstile>\\<^sub>F p \\<bullet> \\<Phi>", "by(force simp add: FrameImp_def eqvts pt_fresh_star_bij[OF pt_name_inst, OF at_name_inst]\n         intro: statClosed)"], ["", "lemma frameImpEqvt[eqvt]:\n  fixes F :: \"'b frame\"\n  and   \\<Phi> :: 'c\n  and   p :: \"name prm\"\n\n  shows \"(p \\<bullet> (F \\<turnstile>\\<^sub>F \\<Phi>)) = (p \\<bullet> F) \\<turnstile>\\<^sub>F (p \\<bullet> \\<Phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (F \\<turnstile>\\<^sub>F \\<Phi>) =\n    p \\<bullet> F \\<turnstile>\\<^sub>F p \\<bullet> \\<Phi>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<bullet> (F \\<turnstile>\\<^sub>F \\<Phi>) =\n    p \\<bullet> F \\<turnstile>\\<^sub>F p \\<bullet> \\<Phi>", "have \"F \\<turnstile>\\<^sub>F \\<Phi> \\<Longrightarrow> (p \\<bullet> F) \\<turnstile>\\<^sub>F (p \\<bullet> \\<Phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<turnstile>\\<^sub>F \\<Phi> \\<Longrightarrow>\n    p \\<bullet> F \\<turnstile>\\<^sub>F p \\<bullet> \\<Phi>", "by(rule frameImpClosed)"], ["proof (state)\nthis:\n  F \\<turnstile>\\<^sub>F \\<Phi> \\<Longrightarrow>\n  p \\<bullet> F \\<turnstile>\\<^sub>F p \\<bullet> \\<Phi>\n\ngoal (1 subgoal):\n 1. p \\<bullet> (F \\<turnstile>\\<^sub>F \\<Phi>) =\n    p \\<bullet> F \\<turnstile>\\<^sub>F p \\<bullet> \\<Phi>", "moreover"], ["proof (state)\nthis:\n  F \\<turnstile>\\<^sub>F \\<Phi> \\<Longrightarrow>\n  p \\<bullet> F \\<turnstile>\\<^sub>F p \\<bullet> \\<Phi>\n\ngoal (1 subgoal):\n 1. p \\<bullet> (F \\<turnstile>\\<^sub>F \\<Phi>) =\n    p \\<bullet> F \\<turnstile>\\<^sub>F p \\<bullet> \\<Phi>", "have \"(p \\<bullet> F) \\<turnstile>\\<^sub>F (p \\<bullet> \\<Phi>) \\<Longrightarrow> F \\<turnstile>\\<^sub>F \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> F \\<turnstile>\\<^sub>F p \\<bullet> \\<Phi> \\<Longrightarrow>\n    F \\<turnstile>\\<^sub>F \\<Phi>", "by(drule_tac p = \"rev p\" in frameImpClosed) simp"], ["proof (state)\nthis:\n  p \\<bullet> F \\<turnstile>\\<^sub>F p \\<bullet> \\<Phi> \\<Longrightarrow>\n  F \\<turnstile>\\<^sub>F \\<Phi>\n\ngoal (1 subgoal):\n 1. p \\<bullet> (F \\<turnstile>\\<^sub>F \\<Phi>) =\n    p \\<bullet> F \\<turnstile>\\<^sub>F p \\<bullet> \\<Phi>", "ultimately"], ["proof (chain)\npicking this:\n  F \\<turnstile>\\<^sub>F \\<Phi> \\<Longrightarrow>\n  p \\<bullet> F \\<turnstile>\\<^sub>F p \\<bullet> \\<Phi>\n  p \\<bullet> F \\<turnstile>\\<^sub>F p \\<bullet> \\<Phi> \\<Longrightarrow>\n  F \\<turnstile>\\<^sub>F \\<Phi>", "show ?thesis"], ["proof (prove)\nusing this:\n  F \\<turnstile>\\<^sub>F \\<Phi> \\<Longrightarrow>\n  p \\<bullet> F \\<turnstile>\\<^sub>F p \\<bullet> \\<Phi>\n  p \\<bullet> F \\<turnstile>\\<^sub>F p \\<bullet> \\<Phi> \\<Longrightarrow>\n  F \\<turnstile>\\<^sub>F \\<Phi>\n\ngoal (1 subgoal):\n 1. p \\<bullet> (F \\<turnstile>\\<^sub>F \\<Phi>) =\n    p \\<bullet> F \\<turnstile>\\<^sub>F p \\<bullet> \\<Phi>", "by(auto simp add: perm_bool)"], ["proof (state)\nthis:\n  p \\<bullet> (F \\<turnstile>\\<^sub>F \\<Phi>) =\n  p \\<bullet> F \\<turnstile>\\<^sub>F p \\<bullet> \\<Phi>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma frameImpEmpty[simp]:\n  fixes \\<Psi> :: 'b\n  and   \\<phi> :: 'c\n\n  shows \"\\<langle>\\<epsilon>, \\<Psi>\\<rangle> \\<turnstile>\\<^sub>F \\<phi> = \\<Psi> \\<turnstile> \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<epsilon>, \\<Psi>\\<rangle> \\<turnstile>\\<^sub>F \\<phi> =\n    \\<Psi> \\<turnstile> \\<phi>", "by(auto simp add: FrameImp_def)"], ["", "definition\n  FrameStatImp :: \"'b frame \\<Rightarrow> 'b frame\\<Rightarrow> bool\" (infix \"\\<hookrightarrow>\\<^sub>F\" 70)\n  where \"(F \\<hookrightarrow>\\<^sub>F G) \\<equiv> (\\<forall>\\<phi>. F \\<turnstile>\\<^sub>F \\<phi> \\<longrightarrow> G \\<turnstile>\\<^sub>F \\<phi>)\""], ["", "definition\n  FrameStatEq :: \"'b frame \\<Rightarrow> 'b frame\\<Rightarrow> bool\" (infix \"\\<simeq>\\<^sub>F\" 70)\n  where \"(F \\<simeq>\\<^sub>F G) \\<equiv> F \\<hookrightarrow>\\<^sub>F G \\<and> G \\<hookrightarrow>\\<^sub>F F\""], ["", "lemma FrameStatImpClosed:\n  fixes F :: \"'b frame\"\n  and   G :: \"'b frame\"\n  and   p :: \"name prm\"\n\n  assumes \"F \\<hookrightarrow>\\<^sub>F G\"\n\n  shows \"(p \\<bullet> F) \\<hookrightarrow>\\<^sub>F (p \\<bullet> G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> F \\<hookrightarrow>\\<^sub>F p \\<bullet> G", "proof(auto simp add: FrameStatImp_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       p \\<bullet> F \\<turnstile>\\<^sub>F \\<phi> \\<Longrightarrow>\n       p \\<bullet> G \\<turnstile>\\<^sub>F \\<phi>", "fix \\<phi>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       p \\<bullet> F \\<turnstile>\\<^sub>F \\<phi> \\<Longrightarrow>\n       p \\<bullet> G \\<turnstile>\\<^sub>F \\<phi>", "assume \"(p \\<bullet> F) \\<turnstile>\\<^sub>F \\<phi>\""], ["proof (state)\nthis:\n  p \\<bullet> F \\<turnstile>\\<^sub>F \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       p \\<bullet> F \\<turnstile>\\<^sub>F \\<phi> \\<Longrightarrow>\n       p \\<bullet> G \\<turnstile>\\<^sub>F \\<phi>", "hence \"F \\<turnstile>\\<^sub>F rev p \\<bullet> \\<phi>\""], ["proof (prove)\nusing this:\n  p \\<bullet> F \\<turnstile>\\<^sub>F \\<phi>\n\ngoal (1 subgoal):\n 1. F \\<turnstile>\\<^sub>F rev p \\<bullet> \\<phi>", "by(drule_tac p=\"rev p\" in frameImpClosed) auto"], ["proof (state)\nthis:\n  F \\<turnstile>\\<^sub>F rev p \\<bullet> \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       p \\<bullet> F \\<turnstile>\\<^sub>F \\<phi> \\<Longrightarrow>\n       p \\<bullet> G \\<turnstile>\\<^sub>F \\<phi>", "with \\<open>F \\<hookrightarrow>\\<^sub>F G\\<close>"], ["proof (chain)\npicking this:\n  F \\<hookrightarrow>\\<^sub>F G\n  F \\<turnstile>\\<^sub>F rev p \\<bullet> \\<phi>", "have \"G \\<turnstile>\\<^sub>F rev p \\<bullet> \\<phi>\""], ["proof (prove)\nusing this:\n  F \\<hookrightarrow>\\<^sub>F G\n  F \\<turnstile>\\<^sub>F rev p \\<bullet> \\<phi>\n\ngoal (1 subgoal):\n 1. G \\<turnstile>\\<^sub>F rev p \\<bullet> \\<phi>", "by(simp add: FrameStatImp_def)"], ["proof (state)\nthis:\n  G \\<turnstile>\\<^sub>F rev p \\<bullet> \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       p \\<bullet> F \\<turnstile>\\<^sub>F \\<phi> \\<Longrightarrow>\n       p \\<bullet> G \\<turnstile>\\<^sub>F \\<phi>", "thus \"(p \\<bullet> G) \\<turnstile>\\<^sub>F \\<phi>\""], ["proof (prove)\nusing this:\n  G \\<turnstile>\\<^sub>F rev p \\<bullet> \\<phi>\n\ngoal (1 subgoal):\n 1. p \\<bullet> G \\<turnstile>\\<^sub>F \\<phi>", "by(drule_tac p=p in frameImpClosed) auto"], ["proof (state)\nthis:\n  p \\<bullet> G \\<turnstile>\\<^sub>F \\<phi>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma FrameStatEqClosed:\n  fixes F :: \"'b frame\"\n  and   G :: \"'b frame\"\n  and   p :: \"name prm\"\n\n  assumes \"F \\<simeq>\\<^sub>F G\"\n\n  shows \"(p \\<bullet> F) \\<simeq>\\<^sub>F (p \\<bullet> G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> F \\<simeq>\\<^sub>F p \\<bullet> G", "using assms"], ["proof (prove)\nusing this:\n  F \\<simeq>\\<^sub>F G\n\ngoal (1 subgoal):\n 1. p \\<bullet> F \\<simeq>\\<^sub>F p \\<bullet> G", "by(auto simp add: FrameStatEq_def intro: FrameStatImpClosed)"], ["", "lemma FrameStatImpEqvt[eqvt]:\n  fixes F :: \"'b frame\"\n  and   G :: \"'b frame\"\n  and   p :: \"name prm\"\n\n  shows \"(p \\<bullet> (F \\<hookrightarrow>\\<^sub>F G)) = ((p \\<bullet> F) \\<hookrightarrow>\\<^sub>F (p \\<bullet> G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (F \\<hookrightarrow>\\<^sub>F G) =\n    p \\<bullet> F \\<hookrightarrow>\\<^sub>F p \\<bullet> G", "by(simp add: FrameStatImp_def eqvts)"], ["", "lemma FrameStatEqEqvt[eqvt]:\n  fixes F :: \"'b frame\"\n  and   G :: \"'b frame\"\n  and   p :: \"name prm\"\n\n  shows \"(p \\<bullet> (F \\<simeq>\\<^sub>F G)) = ((p \\<bullet> F) \\<simeq>\\<^sub>F (p \\<bullet> G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (F \\<simeq>\\<^sub>F G) =\n    p \\<bullet> F \\<simeq>\\<^sub>F p \\<bullet> G", "by(simp add: FrameStatEq_def eqvts)"], ["", "lemma FrameStatImpRefl[simp]:\n  fixes F :: \"'b frame\"\n\n  shows \"F \\<hookrightarrow>\\<^sub>F F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<hookrightarrow>\\<^sub>F F", "by(simp add: FrameStatImp_def)"], ["", "lemma FrameStatEqRefl[simp]:\n  fixes F :: \"'b frame\"\n\n  shows \"F \\<simeq>\\<^sub>F F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<simeq>\\<^sub>F F", "by(simp add: FrameStatEq_def)"], ["", "lemma FrameStatEqSym:\n  fixes F  :: \"'b frame\"\n  and   G  :: \"'b frame\"\n\n  assumes \"F \\<simeq>\\<^sub>F G\"\n\n  shows \"G \\<simeq>\\<^sub>F F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<simeq>\\<^sub>F F", "using assms"], ["proof (prove)\nusing this:\n  F \\<simeq>\\<^sub>F G\n\ngoal (1 subgoal):\n 1. G \\<simeq>\\<^sub>F F", "by(auto simp add: FrameStatEq_def)"], ["", "lemma FrameStatImpTrans:\n  fixes F :: \"'b frame\"\n  and   G :: \"'b frame\" \n  and   H :: \"'b frame\"\n\n  assumes \"F \\<hookrightarrow>\\<^sub>F G\"\n  and     \"G \\<hookrightarrow>\\<^sub>F H\"\n\n  shows \"F \\<hookrightarrow>\\<^sub>F H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<hookrightarrow>\\<^sub>F H", "using assms"], ["proof (prove)\nusing this:\n  F \\<hookrightarrow>\\<^sub>F G\n  G \\<hookrightarrow>\\<^sub>F H\n\ngoal (1 subgoal):\n 1. F \\<hookrightarrow>\\<^sub>F H", "by(simp add: FrameStatImp_def)"], ["", "lemma FrameStatEqTrans:\n  fixes F :: \"'b frame\"\n  and   G :: \"'b frame\"\n  and   H :: \"'b frame\"\n\n  assumes \"F \\<simeq>\\<^sub>F G\"\n  and     \"G \\<simeq>\\<^sub>F H\"\n\n  shows \"F \\<simeq>\\<^sub>F H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<simeq>\\<^sub>F H", "using assms"], ["proof (prove)\nusing this:\n  F \\<simeq>\\<^sub>F G\n  G \\<simeq>\\<^sub>F H\n\ngoal (1 subgoal):\n 1. F \\<simeq>\\<^sub>F H", "by(auto simp add: FrameStatEq_def intro: FrameStatImpTrans)"], ["", "lemma fsCompose[simp]: \"finite((supp SCompose)::name set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (supp (\\<otimes>))", "by(simp add: supp_def perm_fun_def eqvts)"], ["", "nominal_primrec \n   insertAssertion :: \"'b frame \\<Rightarrow> 'b \\<Rightarrow> 'b frame\"\nwhere\n  \"insertAssertion (FAssert \\<Psi>) \\<Psi>' = FAssert (\\<Psi>' \\<otimes> \\<Psi>)\"\n| \"x \\<sharp> \\<Psi>' \\<Longrightarrow> insertAssertion (\\<lparr>\\<nu>x\\<rparr>F) \\<Psi>' = \\<lparr>\\<nu>x\\<rparr>(insertAssertion F \\<Psi>')\""], ["proof (prove)\ngoal (8 subgoals):\n 1. finite\n     (supp\n       (\\<lambda>\\<Psi>.\n           \\<langle>\\<epsilon>, \\<Psi>' \\<otimes> \\<Psi>\\<rangle>))\n 2. finite (supp (\\<lambda>x F. FRes x))\n 3. finite (supp ())\n 4. \\<And>x1. True\n 5. \\<And>x1 x2 y1. True \\<Longrightarrow> True\n 6. \\<And>x1 x2 y1.\n       \\<lbrakk>x1 \\<sharp> (\\<lambda>x F. FRes x); x1 \\<sharp> ();\n        finite (supp y1); True\\<rbrakk>\n       \\<Longrightarrow> x1 \\<sharp> \\<lparr>\\<nu>x1\\<rparr>y1\n 7. \\<And>x F.\n       x \\<sharp> \\<Psi>' \\<Longrightarrow>\n       x \\<sharp> (\\<lambda>\\<Psi>.\n                      \\<langle>\\<epsilon>, \\<Psi>' \\<otimes>\n     \\<Psi>\\<rangle>)\n 8. \\<And>x F.\n       x \\<sharp> \\<Psi>' \\<Longrightarrow>\n       x \\<sharp> (\\<lambda>x F. FRes x)", "apply(finite_guess add: fsCompose)+"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1. True\n 2. \\<And>x1 x2 y1. True \\<Longrightarrow> True\n 3. \\<And>x1 x2 y1.\n       \\<lbrakk>x1 \\<sharp> (\\<lambda>x F. FRes x); x1 \\<sharp> ();\n        finite (supp y1); True\\<rbrakk>\n       \\<Longrightarrow> x1 \\<sharp> \\<lparr>\\<nu>x1\\<rparr>y1\n 4. \\<And>x F.\n       x \\<sharp> \\<Psi>' \\<Longrightarrow>\n       x \\<sharp> (\\<lambda>\\<Psi>.\n                      \\<langle>\\<epsilon>, \\<Psi>' \\<otimes>\n     \\<Psi>\\<rangle>)\n 5. \\<And>x F.\n       x \\<sharp> \\<Psi>' \\<Longrightarrow>\n       x \\<sharp> (\\<lambda>x F. FRes x)", "apply(rule TrueI)+"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 x2 y1.\n       \\<lbrakk>x1 \\<sharp> (\\<lambda>x F. FRes x); x1 \\<sharp> ();\n        finite (supp y1); True\\<rbrakk>\n       \\<Longrightarrow> x1 \\<sharp> \\<lparr>\\<nu>x1\\<rparr>y1\n 2. \\<And>x F.\n       x \\<sharp> \\<Psi>' \\<Longrightarrow>\n       x \\<sharp> (\\<lambda>\\<Psi>.\n                      \\<langle>\\<epsilon>, \\<Psi>' \\<otimes>\n     \\<Psi>\\<rangle>)\n 3. \\<And>x F.\n       x \\<sharp> \\<Psi>' \\<Longrightarrow>\n       x \\<sharp> (\\<lambda>x F. FRes x)", "apply(simp add: abs_fresh)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x F.\n       x \\<sharp> \\<Psi>' \\<Longrightarrow>\n       x \\<sharp> (\\<lambda>\\<Psi>.\n                      \\<langle>\\<epsilon>, \\<Psi>' \\<otimes>\n     \\<Psi>\\<rangle>)\n 2. \\<And>x F.\n       x \\<sharp> \\<Psi>' \\<Longrightarrow>\n       x \\<sharp> (\\<lambda>x F. FRes x)", "apply(rule supports_fresh[of \"supp \\<Psi>'\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x F.\n       x \\<sharp> \\<Psi>' \\<Longrightarrow>\n       supp \\<Psi>' supports\n       (\\<lambda>\\<Psi>.\n           \\<langle>\\<epsilon>, \\<Psi>' \\<otimes> \\<Psi>\\<rangle>)\n 2. \\<And>x F. x \\<sharp> \\<Psi>' \\<Longrightarrow> finite (supp \\<Psi>')\n 3. \\<And>x F. x \\<sharp> \\<Psi>' \\<Longrightarrow> x \\<notin> supp \\<Psi>'\n 4. \\<And>x F.\n       x \\<sharp> \\<Psi>' \\<Longrightarrow>\n       x \\<sharp> (\\<lambda>x F. FRes x)", "apply(force simp add: perm_fun_def eqvts fresh_def[symmetric] supports_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x F. x \\<sharp> \\<Psi>' \\<Longrightarrow> finite (supp \\<Psi>')\n 2. \\<And>x F. x \\<sharp> \\<Psi>' \\<Longrightarrow> x \\<notin> supp \\<Psi>'\n 3. \\<And>x F.\n       x \\<sharp> \\<Psi>' \\<Longrightarrow>\n       x \\<sharp> (\\<lambda>x F. FRes x)", "apply(simp add: fs_name1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x F. x \\<sharp> \\<Psi>' \\<Longrightarrow> x \\<notin> supp \\<Psi>'\n 2. \\<And>x F.\n       x \\<sharp> \\<Psi>' \\<Longrightarrow>\n       x \\<sharp> (\\<lambda>x F. FRes x)", "apply(simp add: fresh_def[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       x \\<sharp> \\<Psi>' \\<Longrightarrow>\n       x \\<sharp> (\\<lambda>x F. FRes x)", "apply(fresh_guess)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma insertAssertionEqvt[eqvt]:\n  fixes p :: \"name prm\"\n  and   F :: \"'b frame\"\n  and   \\<Psi> :: 'b\n\n  shows \"p \\<bullet> (insertAssertion F \\<Psi>) = insertAssertion (p \\<bullet> F) (p \\<bullet> \\<Psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> insertAssertion F \\<Psi> =\n    insertAssertion (p \\<bullet> F) (p \\<bullet> \\<Psi>)", "by(nominal_induct F avoiding: p \\<Psi> rule: frame.strong_induct)\n  (auto simp add: at_prm_fresh[OF at_name_inst] \n                  pt_fresh_perm_app[OF pt_name_inst, OF at_name_inst] eqvts)"], ["", "nominal_primrec \n   mergeFrame :: \"'b frame \\<Rightarrow> 'b frame \\<Rightarrow> 'b frame\"\nwhere\n  \"mergeFrame (FAssert \\<Psi>) G = insertAssertion G \\<Psi>\"\n| \"x \\<sharp> G \\<Longrightarrow> mergeFrame (\\<lparr>\\<nu>x\\<rparr>F) G = \\<lparr>\\<nu>x\\<rparr>(mergeFrame F G)\""], ["proof (prove)\ngoal (8 subgoals):\n 1. finite (supp (insertAssertion G))\n 2. finite (supp (\\<lambda>x F. FRes x))\n 3. finite (supp ())\n 4. \\<And>x1. True\n 5. \\<And>x1 x2 y1. True \\<Longrightarrow> True\n 6. \\<And>x1 x2 y1.\n       \\<lbrakk>x1 \\<sharp> (\\<lambda>x F. FRes x); x1 \\<sharp> ();\n        finite (supp y1); True\\<rbrakk>\n       \\<Longrightarrow> x1 \\<sharp> \\<lparr>\\<nu>x1\\<rparr>y1\n 7. \\<And>x F. x \\<sharp> G \\<Longrightarrow> x \\<sharp> insertAssertion G\n 8. \\<And>x F.\n       x \\<sharp> G \\<Longrightarrow> x \\<sharp> (\\<lambda>x F. FRes x)", "apply(finite_guess add: fsCompose)+"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1. True\n 2. \\<And>x1 x2 y1. True \\<Longrightarrow> True\n 3. \\<And>x1 x2 y1.\n       \\<lbrakk>x1 \\<sharp> (\\<lambda>x F. FRes x); x1 \\<sharp> ();\n        finite (supp y1); True\\<rbrakk>\n       \\<Longrightarrow> x1 \\<sharp> \\<lparr>\\<nu>x1\\<rparr>y1\n 4. \\<And>x F. x \\<sharp> G \\<Longrightarrow> x \\<sharp> insertAssertion G\n 5. \\<And>x F.\n       x \\<sharp> G \\<Longrightarrow> x \\<sharp> (\\<lambda>x F. FRes x)", "apply(rule TrueI)+"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 x2 y1.\n       \\<lbrakk>x1 \\<sharp> (\\<lambda>x F. FRes x); x1 \\<sharp> ();\n        finite (supp y1); True\\<rbrakk>\n       \\<Longrightarrow> x1 \\<sharp> \\<lparr>\\<nu>x1\\<rparr>y1\n 2. \\<And>x F. x \\<sharp> G \\<Longrightarrow> x \\<sharp> insertAssertion G\n 3. \\<And>x F.\n       x \\<sharp> G \\<Longrightarrow> x \\<sharp> (\\<lambda>x F. FRes x)", "apply(simp add: abs_fresh)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x F. x \\<sharp> G \\<Longrightarrow> x \\<sharp> insertAssertion G\n 2. \\<And>x F.\n       x \\<sharp> G \\<Longrightarrow> x \\<sharp> (\\<lambda>x F. FRes x)", "apply(simp add: fs_name1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<sharp> G \\<Longrightarrow> x \\<sharp> insertAssertion G\n 2. \\<And>x F.\n       x \\<sharp> G \\<Longrightarrow> x \\<sharp> (\\<lambda>x F. FRes x)", "apply(rule supports_fresh[of \"supp G\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       x \\<sharp> G \\<Longrightarrow> supp G supports insertAssertion G\n 2. \\<And>x. x \\<sharp> G \\<Longrightarrow> finite (supp G)\n 3. \\<And>x. x \\<sharp> G \\<Longrightarrow> x \\<notin> supp G\n 4. \\<And>x F.\n       x \\<sharp> G \\<Longrightarrow> x \\<sharp> (\\<lambda>x F. FRes x)", "apply(force simp add: perm_fun_def eqvts fresh_def[symmetric] supports_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<sharp> G \\<Longrightarrow> finite (supp G)\n 2. \\<And>x. x \\<sharp> G \\<Longrightarrow> x \\<notin> supp G\n 3. \\<And>x F.\n       x \\<sharp> G \\<Longrightarrow> x \\<sharp> (\\<lambda>x F. FRes x)", "apply(simp add: fs_name1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<sharp> G \\<Longrightarrow> x \\<notin> supp G\n 2. \\<And>x F.\n       x \\<sharp> G \\<Longrightarrow> x \\<sharp> (\\<lambda>x F. FRes x)", "apply(simp add: fresh_def[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       x \\<sharp> G \\<Longrightarrow> x \\<sharp> (\\<lambda>x F. FRes x)", "apply(fresh_guess)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "notation mergeFrame (infixr \"\\<otimes>\\<^sub>F\" 80)"], ["", "abbreviation\n  frameBottomJudge (\"\\<bottom>\\<^sub>F\") where \"\\<bottom>\\<^sub>F \\<equiv> (FAssert SBottom)\""], ["", "lemma mergeFrameEqvt[eqvt]:\n  fixes p :: \"name prm\"\n  and   F :: \"'b frame\"\n  and   G :: \"'b frame\"\n\n  shows \"p \\<bullet> (mergeFrame F G) = mergeFrame (p \\<bullet> F) (p \\<bullet> G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> F \\<otimes>\\<^sub>F G =\n    (p \\<bullet> F) \\<otimes>\\<^sub>F p \\<bullet> G", "by(nominal_induct F avoiding: p G rule: frame.strong_induct)\n  (auto simp add: at_prm_fresh[OF at_name_inst] \n                  pt_fresh_perm_app[OF pt_name_inst, OF at_name_inst] eqvts)"], ["", "nominal_primrec\n    extractFrame   :: \"('a, 'b, 'c) psi \\<Rightarrow> 'b frame\"\nand extractFrame'  :: \"('a, 'b, 'c) input \\<Rightarrow> 'b frame\"\nand extractFrame'' :: \"('a, 'b, 'c) psiCase \\<Rightarrow> 'b frame\"\n\nwhere\n  \"extractFrame (\\<zero>) =  \\<langle>\\<epsilon>, \\<bottom>\\<rangle>\"\n| \"extractFrame (M\\<lparr>I) = \\<langle>\\<epsilon>, \\<bottom>\\<rangle>\"\n| \"extractFrame (M\\<langle>N\\<rangle>.P) = \\<langle>\\<epsilon>, \\<bottom>\\<rangle>\"\n| \"extractFrame (Case C) = \\<langle>\\<epsilon>, \\<bottom>\\<rangle>\"\n| \"extractFrame (P \\<parallel> Q) = (extractFrame P) \\<otimes>\\<^sub>F (extractFrame Q)\"\n| \"extractFrame ((\\<lbrace>\\<Psi>\\<rbrace>::('a, 'b, 'c) psi)) = \\<langle>\\<epsilon>, \\<Psi>\\<rangle>\" \n\n| \"extractFrame (\\<lparr>\\<nu>x\\<rparr>P) = \\<lparr>\\<nu>x\\<rparr>(extractFrame P)\"\n| \"extractFrame (!P) = \\<langle>\\<epsilon>, \\<bottom>\\<rangle>\" \n\n| \"extractFrame' ((Trm M P)::('a::fs_name, 'b::fs_name, 'c::fs_name) input) = \\<langle>\\<epsilon>, \\<bottom>\\<rangle>\" \n| \"extractFrame' (Bind x I) = \\<langle>\\<epsilon>, \\<bottom>\\<rangle>\" \n\n| \"extractFrame'' (\\<bottom>\\<^sub>c::('a::fs_name, 'b::fs_name, 'c::fs_name) psiCase) = \\<langle>\\<epsilon>, \\<bottom>\\<rangle>\" \n| \"extractFrame'' (\\<box>\\<Phi> \\<Rightarrow> P C) = \\<langle>\\<epsilon>, \\<bottom>\\<rangle>\""], ["proof (prove)\ngoal (51 subgoals):\n 1. finite (supp \\<bottom>\\<^sub>F)\n 2. finite (supp (\\<lambda>M N P Pa. \\<bottom>\\<^sub>F))\n 3. finite (supp (\\<lambda>M I Ia. \\<bottom>\\<^sub>F))\n 4. finite (supp (\\<lambda>C Ca. \\<bottom>\\<^sub>F))\n 5. finite (supp (\\<lambda>P Q. (\\<otimes>\\<^sub>F)))\n 6. finite (supp (\\<lambda>x P. FRes x))\n 7. finite (supp FAssert)\n 8. finite (supp (\\<lambda>P Pa. \\<bottom>\\<^sub>F))\n 9. finite (supp (\\<lambda>M P Pa. \\<bottom>\\<^sub>F))\n 10. finite (supp (\\<lambda>x I Ia. \\<bottom>\\<^sub>F))\nA total of 51 subgoals...", "apply(finite_guess add: fsCompose)+"], ["proof (prove)\ngoal (38 subgoals):\n 1. True\n 2. \\<And>x1 x2 x3 y1. True \\<Longrightarrow> True\n 3. \\<And>x1 x2 y1. True \\<Longrightarrow> True\n 4. \\<And>x1 y1. True \\<Longrightarrow> True\n 5. \\<And>x1 x2 y1 y2. \\<lbrakk>True; True\\<rbrakk> \\<Longrightarrow> True\n 6. \\<And>x1 x2 y1. True \\<Longrightarrow> True\n 7. \\<And>x1. True\n 8. \\<And>x1 y1. True \\<Longrightarrow> True\n 9. \\<And>x1 x2 y1. True \\<Longrightarrow> True\n 10. \\<And>x1 x2 y1. True \\<Longrightarrow> True\nA total of 38 subgoals...", "apply(rule TrueI)+"], ["proof (prove)\ngoal (26 subgoals):\n 1. \\<And>x1 x2 y1.\n       \\<lbrakk>x1 \\<sharp> (\\<lambda>x P. FRes x); x1 \\<sharp> ();\n        finite (supp y1); True\\<rbrakk>\n       \\<Longrightarrow> x1 \\<sharp> \\<lparr>\\<nu>x1\\<rparr>y1\n 2. \\<And>x1 x2 y1.\n       \\<lbrakk>x1 \\<sharp> (\\<lambda>x I Ia. \\<bottom>\\<^sub>F);\n        x1 \\<sharp> (); finite (supp y1); True\\<rbrakk>\n       \\<Longrightarrow> x1 \\<sharp> \\<bottom>\\<^sub>F\n 3. \\<And>x P. x \\<sharp> \\<bottom>\\<^sub>F\n 4. \\<And>x P. x \\<sharp> (\\<lambda>M N P Pa. \\<bottom>\\<^sub>F)\n 5. \\<And>x P. x \\<sharp> (\\<lambda>M I Ia. \\<bottom>\\<^sub>F)\n 6. \\<And>x P. x \\<sharp> (\\<lambda>C Ca. \\<bottom>\\<^sub>F)\n 7. \\<And>x P. x \\<sharp> (\\<lambda>P Q. (\\<otimes>\\<^sub>F))\n 8. \\<And>x P. x \\<sharp> (\\<lambda>x P. FRes x)\n 9. \\<And>x P. x \\<sharp> FAssert\n 10. \\<And>x P. x \\<sharp> (\\<lambda>P Pa. \\<bottom>\\<^sub>F)\nA total of 26 subgoals...", "apply(simp add: abs_fresh)+"], ["proof (prove)\ngoal (23 subgoals):\n 1. \\<And>x. x \\<sharp> (\\<lambda>M N P Pa. \\<bottom>\\<^sub>F)\n 2. \\<And>x P. x \\<sharp> (\\<lambda>M I Ia. \\<bottom>\\<^sub>F)\n 3. \\<And>x P. x \\<sharp> (\\<lambda>C Ca. \\<bottom>\\<^sub>F)\n 4. \\<And>x P. x \\<sharp> (\\<lambda>P Q. (\\<otimes>\\<^sub>F))\n 5. \\<And>x P. x \\<sharp> (\\<lambda>x P. FRes x)\n 6. \\<And>x P. x \\<sharp> FAssert\n 7. \\<And>x P. x \\<sharp> (\\<lambda>P Pa. \\<bottom>\\<^sub>F)\n 8. \\<And>x P. x \\<sharp> (\\<lambda>M P Pa. \\<bottom>\\<^sub>F)\n 9. \\<And>x P. x \\<sharp> (\\<lambda>x I Ia. \\<bottom>\\<^sub>F)\n 10. \\<And>x P. x \\<sharp> \\<bottom>\\<^sub>F\nA total of 23 subgoals...", "apply(fresh_guess add: freshBottom)+"], ["proof (prove)\ngoal (20 subgoals):\n 1. \\<And>x P. x \\<sharp> (\\<lambda>P Q. (\\<otimes>\\<^sub>F))\n 2. \\<And>x P. x \\<sharp> (\\<lambda>x P. FRes x)\n 3. \\<And>x P. x \\<sharp> FAssert\n 4. \\<And>x P. x \\<sharp> (\\<lambda>P Pa. \\<bottom>\\<^sub>F)\n 5. \\<And>x P. x \\<sharp> (\\<lambda>M P Pa. \\<bottom>\\<^sub>F)\n 6. \\<And>x P. x \\<sharp> (\\<lambda>x I Ia. \\<bottom>\\<^sub>F)\n 7. \\<And>x P. x \\<sharp> \\<bottom>\\<^sub>F\n 8. \\<And>x P. x \\<sharp> (\\<lambda>\\<Phi> P C Pa Ca. \\<bottom>\\<^sub>F)\n 9. \\<And>x I. x \\<sharp> \\<bottom>\\<^sub>F\n 10. \\<And>x I. x \\<sharp> (\\<lambda>M N P Pa. \\<bottom>\\<^sub>F)\nA total of 20 subgoals...", "apply(rule supports_fresh[of \"{}\"])"], ["proof (prove)\ngoal (22 subgoals):\n 1. \\<And>x P. {} supports (\\<lambda>P Q. (\\<otimes>\\<^sub>F))\n 2. \\<And>x P. finite {}\n 3. \\<And>x P. x \\<notin> {}\n 4. \\<And>x P. x \\<sharp> (\\<lambda>x P. FRes x)\n 5. \\<And>x P. x \\<sharp> FAssert\n 6. \\<And>x P. x \\<sharp> (\\<lambda>P Pa. \\<bottom>\\<^sub>F)\n 7. \\<And>x P. x \\<sharp> (\\<lambda>M P Pa. \\<bottom>\\<^sub>F)\n 8. \\<And>x P. x \\<sharp> (\\<lambda>x I Ia. \\<bottom>\\<^sub>F)\n 9. \\<And>x P. x \\<sharp> \\<bottom>\\<^sub>F\n 10. \\<And>x P. x \\<sharp> (\\<lambda>\\<Phi> P C Pa Ca. \\<bottom>\\<^sub>F)\nA total of 22 subgoals...", "apply(force simp add: perm_fun_def eqvts fresh_def[symmetric] supports_def)"], ["proof (prove)\ngoal (21 subgoals):\n 1. \\<And>x P. finite {}\n 2. \\<And>x P. x \\<notin> {}\n 3. \\<And>x P. x \\<sharp> (\\<lambda>x P. FRes x)\n 4. \\<And>x P. x \\<sharp> FAssert\n 5. \\<And>x P. x \\<sharp> (\\<lambda>P Pa. \\<bottom>\\<^sub>F)\n 6. \\<And>x P. x \\<sharp> (\\<lambda>M P Pa. \\<bottom>\\<^sub>F)\n 7. \\<And>x P. x \\<sharp> (\\<lambda>x I Ia. \\<bottom>\\<^sub>F)\n 8. \\<And>x P. x \\<sharp> \\<bottom>\\<^sub>F\n 9. \\<And>x P. x \\<sharp> (\\<lambda>\\<Phi> P C Pa Ca. \\<bottom>\\<^sub>F)\n 10. \\<And>x I. x \\<sharp> \\<bottom>\\<^sub>F\nA total of 21 subgoals...", "apply(simp add: fs_name1)"], ["proof (prove)\ngoal (20 subgoals):\n 1. \\<And>x P. x \\<notin> {}\n 2. \\<And>x P. x \\<sharp> (\\<lambda>x P. FRes x)\n 3. \\<And>x P. x \\<sharp> FAssert\n 4. \\<And>x P. x \\<sharp> (\\<lambda>P Pa. \\<bottom>\\<^sub>F)\n 5. \\<And>x P. x \\<sharp> (\\<lambda>M P Pa. \\<bottom>\\<^sub>F)\n 6. \\<And>x P. x \\<sharp> (\\<lambda>x I Ia. \\<bottom>\\<^sub>F)\n 7. \\<And>x P. x \\<sharp> \\<bottom>\\<^sub>F\n 8. \\<And>x P. x \\<sharp> (\\<lambda>\\<Phi> P C Pa Ca. \\<bottom>\\<^sub>F)\n 9. \\<And>x I. x \\<sharp> \\<bottom>\\<^sub>F\n 10. \\<And>x I. x \\<sharp> (\\<lambda>M N P Pa. \\<bottom>\\<^sub>F)\nA total of 20 subgoals...", "apply(simp add: fresh_def[symmetric])"], ["proof (prove)\ngoal (19 subgoals):\n 1. \\<And>x P. x \\<sharp> (\\<lambda>x P. FRes x)\n 2. \\<And>x P. x \\<sharp> FAssert\n 3. \\<And>x P. x \\<sharp> (\\<lambda>P Pa. \\<bottom>\\<^sub>F)\n 4. \\<And>x P. x \\<sharp> (\\<lambda>M P Pa. \\<bottom>\\<^sub>F)\n 5. \\<And>x P. x \\<sharp> (\\<lambda>x I Ia. \\<bottom>\\<^sub>F)\n 6. \\<And>x P. x \\<sharp> \\<bottom>\\<^sub>F\n 7. \\<And>x P. x \\<sharp> (\\<lambda>\\<Phi> P C Pa Ca. \\<bottom>\\<^sub>F)\n 8. \\<And>x I. x \\<sharp> \\<bottom>\\<^sub>F\n 9. \\<And>x I. x \\<sharp> (\\<lambda>M N P Pa. \\<bottom>\\<^sub>F)\n 10. \\<And>x I. x \\<sharp> (\\<lambda>M I Ia. \\<bottom>\\<^sub>F)\nA total of 19 subgoals...", "apply(fresh_guess add: freshBottom)+"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x I. x \\<sharp> (\\<lambda>P Q. (\\<otimes>\\<^sub>F))\n 2. \\<And>x I. x \\<sharp> (\\<lambda>x P. FRes x)\n 3. \\<And>x I. x \\<sharp> FAssert\n 4. \\<And>x I. x \\<sharp> (\\<lambda>P Pa. \\<bottom>\\<^sub>F)\n 5. \\<And>x I. x \\<sharp> (\\<lambda>M P Pa. \\<bottom>\\<^sub>F)\n 6. \\<And>x I. x \\<sharp> (\\<lambda>x I Ia. \\<bottom>\\<^sub>F)\n 7. \\<And>x I. x \\<sharp> \\<bottom>\\<^sub>F\n 8. \\<And>x I. x \\<sharp> (\\<lambda>\\<Phi> P C Pa Ca. \\<bottom>\\<^sub>F)", "apply(rule supports_fresh[of \"{}\"])"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>x I. {} supports (\\<lambda>P Q. (\\<otimes>\\<^sub>F))\n 2. \\<And>x I. finite {}\n 3. \\<And>x I. x \\<notin> {}\n 4. \\<And>x I. x \\<sharp> (\\<lambda>x P. FRes x)\n 5. \\<And>x I. x \\<sharp> FAssert\n 6. \\<And>x I. x \\<sharp> (\\<lambda>P Pa. \\<bottom>\\<^sub>F)\n 7. \\<And>x I. x \\<sharp> (\\<lambda>M P Pa. \\<bottom>\\<^sub>F)\n 8. \\<And>x I. x \\<sharp> (\\<lambda>x I Ia. \\<bottom>\\<^sub>F)\n 9. \\<And>x I. x \\<sharp> \\<bottom>\\<^sub>F\n 10. \\<And>x I. x \\<sharp> (\\<lambda>\\<Phi> P C Pa Ca. \\<bottom>\\<^sub>F)", "apply(force simp add: perm_fun_def eqvts fresh_def[symmetric] supports_def)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x I. finite {}\n 2. \\<And>x I. x \\<notin> {}\n 3. \\<And>x I. x \\<sharp> (\\<lambda>x P. FRes x)\n 4. \\<And>x I. x \\<sharp> FAssert\n 5. \\<And>x I. x \\<sharp> (\\<lambda>P Pa. \\<bottom>\\<^sub>F)\n 6. \\<And>x I. x \\<sharp> (\\<lambda>M P Pa. \\<bottom>\\<^sub>F)\n 7. \\<And>x I. x \\<sharp> (\\<lambda>x I Ia. \\<bottom>\\<^sub>F)\n 8. \\<And>x I. x \\<sharp> \\<bottom>\\<^sub>F\n 9. \\<And>x I. x \\<sharp> (\\<lambda>\\<Phi> P C Pa Ca. \\<bottom>\\<^sub>F)", "apply(simp add: fs_name1)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x I. x \\<notin> {}\n 2. \\<And>x I. x \\<sharp> (\\<lambda>x P. FRes x)\n 3. \\<And>x I. x \\<sharp> FAssert\n 4. \\<And>x I. x \\<sharp> (\\<lambda>P Pa. \\<bottom>\\<^sub>F)\n 5. \\<And>x I. x \\<sharp> (\\<lambda>M P Pa. \\<bottom>\\<^sub>F)\n 6. \\<And>x I. x \\<sharp> (\\<lambda>x I Ia. \\<bottom>\\<^sub>F)\n 7. \\<And>x I. x \\<sharp> \\<bottom>\\<^sub>F\n 8. \\<And>x I. x \\<sharp> (\\<lambda>\\<Phi> P C Pa Ca. \\<bottom>\\<^sub>F)", "apply(simp add: fresh_def[symmetric])"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x I. x \\<sharp> (\\<lambda>x P. FRes x)\n 2. \\<And>x I. x \\<sharp> FAssert\n 3. \\<And>x I. x \\<sharp> (\\<lambda>P Pa. \\<bottom>\\<^sub>F)\n 4. \\<And>x I. x \\<sharp> (\\<lambda>M P Pa. \\<bottom>\\<^sub>F)\n 5. \\<And>x I. x \\<sharp> (\\<lambda>x I Ia. \\<bottom>\\<^sub>F)\n 6. \\<And>x I. x \\<sharp> \\<bottom>\\<^sub>F\n 7. \\<And>x I. x \\<sharp> (\\<lambda>\\<Phi> P C Pa Ca. \\<bottom>\\<^sub>F)", "apply(fresh_guess add: freshBottom)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas extractFrameSimps = extractFrame_extractFrame'_extractFrame''.simps"], ["", "lemma extractFrameEqvt[eqvt]:\n  fixes p :: \"name prm\"\n  and   P :: \"('a, 'b, 'c) psi\"\n  and   I :: \"('a, 'b, 'c) input\"\n  and   C :: \"('a, 'b, 'c) psiCase\"\n\n  shows \"p \\<bullet> (extractFrame P) = extractFrame (p \\<bullet> P)\"\n  and   \"p \\<bullet> (extractFrame' I) = extractFrame' (p \\<bullet> I)\"\n  and   \"p \\<bullet> (extractFrame'' C) = extractFrame'' (p \\<bullet> C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> extractFrame P = extractFrame (p \\<bullet> P) &&&\n    p \\<bullet> extractFrame' I = extractFrame' (p \\<bullet> I) &&&\n    p \\<bullet> extractFrame'' C = extractFrame'' (p \\<bullet> C)", "by(nominal_induct P and I and C avoiding: p rule: psi_input_psiCase.strong_inducts)\n   (auto simp add: at_prm_fresh[OF at_name_inst] eqvts permBottom\n                  pt_fresh_perm_app[OF pt_name_inst, OF at_name_inst])"], ["", "lemma insertAssertionFresh[intro]:\n  fixes F :: \"'b frame\"\n  and   \\<Psi> :: 'b\n  and   x :: name\n\n  assumes \"x \\<sharp> F\"\n  and     \"x \\<sharp> \\<Psi>\"\n\n  shows \"x \\<sharp> (insertAssertion F \\<Psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> insertAssertion F \\<Psi>", "using assms"], ["proof (prove)\nusing this:\n  x \\<sharp> F\n  x \\<sharp> \\<Psi>\n\ngoal (1 subgoal):\n 1. x \\<sharp> insertAssertion F \\<Psi>", "by(nominal_induct F avoiding: x \\<Psi> rule: frame.strong_induct)\n  (auto simp add: abs_fresh)"], ["", "lemma insertAssertionFreshChain[intro]:\n  fixes F    :: \"'b frame\"\n  and   \\<Psi>    :: 'b\n  and   xvec :: \"name list\"\n  and   Xs   :: \"name set\"\n\n  shows \"\\<lbrakk>xvec \\<sharp>* F; xvec \\<sharp>* \\<Psi>\\<rbrakk> \\<Longrightarrow> xvec \\<sharp>* (insertAssertion F \\<Psi>)\"\n  and   \"\\<lbrakk>Xs \\<sharp>* F; Xs \\<sharp>* \\<Psi>\\<rbrakk> \\<Longrightarrow> Xs \\<sharp>* (insertAssertion F \\<Psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>xvec \\<sharp>* F; xvec \\<sharp>* \\<Psi>\\<rbrakk>\n     \\<Longrightarrow> xvec \\<sharp>* insertAssertion F \\<Psi>) &&&\n    (\\<lbrakk>Xs \\<sharp>* F; Xs \\<sharp>* \\<Psi>\\<rbrakk>\n     \\<Longrightarrow> Xs \\<sharp>* insertAssertion F \\<Psi>)", "by(auto simp add: fresh_star_def)"], ["", "lemma mergeFrameFresh[intro]:\n  fixes F :: \"'b frame\"\n  and   G :: \"'b frame\"\n  and   x :: name\n\n  shows \"\\<lbrakk>x \\<sharp> F; x \\<sharp> G\\<rbrakk> \\<Longrightarrow> x \\<sharp> (mergeFrame F G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sharp> F; x \\<sharp> G\\<rbrakk>\n    \\<Longrightarrow> x \\<sharp> F \\<otimes>\\<^sub>F G", "by(nominal_induct F avoiding: x G rule: frame.strong_induct)\n  (auto simp add: abs_fresh)"], ["", "lemma mergeFrameFreshChain[intro]:\n  fixes F    :: \"'b frame\"\n  and   G    :: \"'b frame\"\n  and   xvec :: \"name list\"\n  and   Xs   :: \"name set\"\n\n  shows \"\\<lbrakk>xvec \\<sharp>* F; xvec \\<sharp>* G\\<rbrakk> \\<Longrightarrow> xvec \\<sharp>* (mergeFrame F G)\"\n  and   \"\\<lbrakk>Xs \\<sharp>* F; Xs \\<sharp>* G\\<rbrakk> \\<Longrightarrow> Xs \\<sharp>* (mergeFrame F G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>xvec \\<sharp>* F; xvec \\<sharp>* G\\<rbrakk>\n     \\<Longrightarrow> xvec \\<sharp>* (F \\<otimes>\\<^sub>F G)) &&&\n    (\\<lbrakk>Xs \\<sharp>* F; Xs \\<sharp>* G\\<rbrakk>\n     \\<Longrightarrow> Xs \\<sharp>* (F \\<otimes>\\<^sub>F G))", "by(auto simp add: fresh_star_def)"], ["", "lemma extractFrameFresh:\n  fixes P :: \"('a, 'b, 'c) psi\"\n  and   I :: \"('a, 'b, 'c) input\"\n  and   C :: \"('a, 'b, 'c) psiCase\"\n  and   x :: name\n\n  shows \"x \\<sharp> P \\<Longrightarrow> x \\<sharp> extractFrame P\"\n  and   \"x \\<sharp> I \\<Longrightarrow> x \\<sharp> extractFrame' I\"\n  and   \"x \\<sharp> C \\<Longrightarrow> x \\<sharp> extractFrame'' C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sharp> P \\<Longrightarrow> x \\<sharp> extractFrame P) &&&\n    (x \\<sharp> I \\<Longrightarrow> x \\<sharp> extractFrame' I) &&&\n    (x \\<sharp> C \\<Longrightarrow> x \\<sharp> extractFrame'' C)", "by(nominal_induct P and I and C avoiding: x rule: psi_input_psiCase.strong_inducts)\n  (auto simp add: abs_fresh)"], ["", "lemma extractFrameFreshChain:\n  fixes P    :: \"('a, 'b, 'c) psi\"\n  and   I    :: \"('a, 'b, 'c) input\"\n  and   C    :: \"('a, 'b, 'c) psiCase\"\n  and   xvec :: \"name list\"\n  and   Xs   :: \"name set\"\n\n  shows \"xvec \\<sharp>* P \\<Longrightarrow> xvec \\<sharp>* extractFrame P\"\n  and   \"xvec \\<sharp>* I \\<Longrightarrow> xvec \\<sharp>* extractFrame' I\"\n  and   \"xvec \\<sharp>* C \\<Longrightarrow> xvec \\<sharp>* extractFrame'' C\"\n  and   \"Xs \\<sharp>* P \\<Longrightarrow> Xs \\<sharp>* extractFrame P\"\n  and   \"Xs \\<sharp>* I \\<Longrightarrow> Xs \\<sharp>* extractFrame' I\"\n  and   \"Xs \\<sharp>* C \\<Longrightarrow> Xs \\<sharp>* extractFrame'' C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((xvec \\<sharp>* P \\<Longrightarrow> xvec \\<sharp>* extractFrame P) &&&\n     (xvec \\<sharp>* I \\<Longrightarrow> xvec \\<sharp>* extractFrame' I) &&&\n     (xvec \\<sharp>* C \\<Longrightarrow>\n      xvec \\<sharp>* extractFrame'' C)) &&&\n    (Xs \\<sharp>* P \\<Longrightarrow> Xs \\<sharp>* extractFrame P) &&&\n    (Xs \\<sharp>* I \\<Longrightarrow> Xs \\<sharp>* extractFrame' I) &&&\n    (Xs \\<sharp>* C \\<Longrightarrow> Xs \\<sharp>* extractFrame'' C)", "by(auto simp add: fresh_star_def intro: extractFrameFresh)"], ["", "lemma guardedFrameSupp[simp]:\n  fixes P :: \"('a, 'b, 'c) psi\"\n  and   I :: \"('a, 'b, 'c) input\"\n  and   C :: \"('a, 'b, 'c) psiCase\"\n  and   x :: name \n\n  shows \"guarded P \\<Longrightarrow> x \\<sharp> (extractFrame P)\"\n  and   \"guarded' I \\<Longrightarrow> x \\<sharp> (extractFrame' I)\"\n  and   \"guarded'' C \\<Longrightarrow> x \\<sharp> (extractFrame'' C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (guarded P \\<Longrightarrow> x \\<sharp> extractFrame P) &&&\n    (guarded' I \\<Longrightarrow> x \\<sharp> extractFrame' I) &&&\n    (guarded'' C \\<Longrightarrow> x \\<sharp> extractFrame'' C)", "by(nominal_induct P and I and C arbitrary: x rule: psi_input_psiCase.strong_inducts)\n  (auto simp add: frameResChainFresh abs_fresh)"], ["", "lemma frameResChainFresh': \n  fixes xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   F    :: \"'b frame\"\n\n  shows \"(xvec \\<sharp>* (\\<lparr>\\<nu>*yvec\\<rparr>F)) = (\\<forall>x \\<in> set xvec. x \\<in> set yvec \\<or> x \\<sharp> F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xvec \\<sharp>* (\\<lparr>\\<nu>*yvec\\<rparr>F) =\n    (\\<forall>x\\<in>set xvec. x mem yvec \\<or> x \\<sharp> F)", "by(simp add: frameResChainFresh fresh_star_def)"], ["", "lemma frameChainFresh[simp]:\n  fixes xvec :: \"name list\"\n  and   \\<Psi>    :: 'b\n  and   Xs   :: \"name set\"\n\n  shows \"xvec \\<sharp>* (FAssert \\<Psi>) = xvec \\<sharp>* \\<Psi>\"\n  and   \"Xs \\<sharp>* (FAssert \\<Psi>) = Xs \\<sharp>* \\<Psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xvec \\<sharp>* (\\<langle>\\<epsilon>, \\<Psi>\\<rangle>) =\n    xvec \\<sharp>* \\<Psi> &&&\n    Xs \\<sharp>* (\\<langle>\\<epsilon>, \\<Psi>\\<rangle>) =\n    Xs \\<sharp>* \\<Psi>", "by(simp add: fresh_star_def)+"], ["", "lemma frameResChainFresh''[simp]:\n  fixes xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   F    :: \"'b frame\"\n  \n  assumes \"xvec \\<sharp>* yvec\"\n\n  shows \"xvec \\<sharp>* (\\<lparr>\\<nu>*yvec\\<rparr>F) = xvec \\<sharp>* F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xvec \\<sharp>* (\\<lparr>\\<nu>*yvec\\<rparr>F) = xvec \\<sharp>* F", "using assms"], ["proof (prove)\nusing this:\n  xvec \\<sharp>* yvec\n\ngoal (1 subgoal):\n 1. xvec \\<sharp>* (\\<lparr>\\<nu>*yvec\\<rparr>F) = xvec \\<sharp>* F", "by(simp_all add: frameResChainFresh')\n  (auto simp add: fresh_star_def fresh_def name_list_supp)"], ["", "lemma frameResChainFresh'''[simp]:\n  fixes x    :: name\n  and   xvec :: \"name list\"\n  and   F    :: \"'b frame\"\n  \n  assumes \"x \\<sharp> xvec\"\n\n  shows \"x \\<sharp> (\\<lparr>\\<nu>*xvec\\<rparr>F) = x \\<sharp> F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> \\<lparr>\\<nu>*xvec\\<rparr>F = x \\<sharp> F", "using assms"], ["proof (prove)\nusing this:\n  x \\<sharp> xvec\n\ngoal (1 subgoal):\n 1. x \\<sharp> \\<lparr>\\<nu>*xvec\\<rparr>F = x \\<sharp> F", "by(induct xvec) (auto simp add: abs_fresh)"], ["", "lemma FFreshBottom[simp]:\n  fixes xvec :: \"name list\"\n  and   Xs   :: \"name set\"\n\n  shows \"xvec \\<sharp>* (\\<bottom>\\<^sub>F)\"\n  and   \"Xs \\<sharp>* (\\<bottom>\\<^sub>F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xvec \\<sharp>* \\<bottom>\\<^sub>F &&& Xs \\<sharp>* \\<bottom>\\<^sub>F", "by(auto simp add: fresh_star_def)"], ["", "lemma SFreshBottom[simp]:\n  fixes xvec :: \"name list\"\n  and   Xs   :: \"name set\"\n\n  shows \"xvec \\<sharp>* (SBottom)\"\n  and   \"Xs \\<sharp>* (SBottom)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xvec \\<sharp>* (\\<bottom>) &&& Xs \\<sharp>* (\\<bottom>)", "by(auto simp add: fresh_star_def)"], ["", "(*\nlemma freshChainComp[simp]:\n  fixes xvec :: \"name list\"\n  and   Xs   :: \"name set\"\n  and   \\<Psi>    :: 'b\n  and   \\<Psi>'   :: 'b\n\n  shows \"xvec \\<sharp>* (\\<Psi> \\<otimes> \\<Psi>') = ((xvec \\<sharp>* \\<Psi>) \\<and> xvec \\<sharp>* \\<Psi>')\"\n  and   \"Xs \\<sharp>* (\\<Psi> \\<otimes> \\<Psi>') = ((Xs \\<sharp>* \\<Psi>) \\<and> Xs \\<sharp>* \\<Psi>')\"\nby(auto simp add: fresh_star_def)\n*)"], ["", "lemma freshFrameDest[dest]:\n  fixes A\\<^sub>F    :: \"name list\"\n  and   \\<Psi>\\<^sub>F   :: 'b\n  and   xvec  :: \"name list\"\n\n  assumes \"xvec \\<sharp>* (\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>)\"\n\n  shows \"xvec \\<sharp>* A\\<^sub>F \\<Longrightarrow> xvec \\<sharp>* \\<Psi>\\<^sub>F\"\n  and   \"A\\<^sub>F \\<sharp>* xvec \\<Longrightarrow> xvec \\<sharp>* \\<Psi>\\<^sub>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xvec \\<sharp>* A\\<^sub>F \\<Longrightarrow>\n     xvec \\<sharp>* \\<Psi>\\<^sub>F) &&&\n    (A\\<^sub>F \\<sharp>* xvec \\<Longrightarrow>\n     xvec \\<sharp>* \\<Psi>\\<^sub>F)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. xvec \\<sharp>* A\\<^sub>F \\<Longrightarrow> xvec \\<sharp>* \\<Psi>\\<^sub>F\n 2. A\\<^sub>F \\<sharp>* xvec \\<Longrightarrow> xvec \\<sharp>* \\<Psi>\\<^sub>F", "from assms"], ["proof (chain)\npicking this:\n  xvec \\<sharp>* (\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>)", "have \"(set xvec) \\<sharp>* (\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>)\""], ["proof (prove)\nusing this:\n  xvec \\<sharp>* (\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>)\n\ngoal (1 subgoal):\n 1. set xvec \\<sharp>* (\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>)", "by(simp add: fresh_star_def)"], ["proof (state)\nthis:\n  set xvec \\<sharp>* (\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>)\n\ngoal (2 subgoals):\n 1. xvec \\<sharp>* A\\<^sub>F \\<Longrightarrow> xvec \\<sharp>* \\<Psi>\\<^sub>F\n 2. A\\<^sub>F \\<sharp>* xvec \\<Longrightarrow> xvec \\<sharp>* \\<Psi>\\<^sub>F", "moreover"], ["proof (state)\nthis:\n  set xvec \\<sharp>* (\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>)\n\ngoal (2 subgoals):\n 1. xvec \\<sharp>* A\\<^sub>F \\<Longrightarrow> xvec \\<sharp>* \\<Psi>\\<^sub>F\n 2. A\\<^sub>F \\<sharp>* xvec \\<Longrightarrow> xvec \\<sharp>* \\<Psi>\\<^sub>F", "assume \"xvec \\<sharp>* A\\<^sub>F\""], ["proof (state)\nthis:\n  xvec \\<sharp>* A\\<^sub>F\n\ngoal (2 subgoals):\n 1. xvec \\<sharp>* A\\<^sub>F \\<Longrightarrow> xvec \\<sharp>* \\<Psi>\\<^sub>F\n 2. A\\<^sub>F \\<sharp>* xvec \\<Longrightarrow> xvec \\<sharp>* \\<Psi>\\<^sub>F", "ultimately"], ["proof (chain)\npicking this:\n  set xvec \\<sharp>* (\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>)\n  xvec \\<sharp>* A\\<^sub>F", "show \"xvec \\<sharp>* \\<Psi>\\<^sub>F\""], ["proof (prove)\nusing this:\n  set xvec \\<sharp>* (\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>)\n  xvec \\<sharp>* A\\<^sub>F\n\ngoal (1 subgoal):\n 1. xvec \\<sharp>* \\<Psi>\\<^sub>F", "by(simp add: frameResChainFreshSet) (force simp add: fresh_def name_list_supp fresh_star_def)"], ["proof (state)\nthis:\n  xvec \\<sharp>* \\<Psi>\\<^sub>F\n\ngoal (1 subgoal):\n 1. A\\<^sub>F \\<sharp>* xvec \\<Longrightarrow> xvec \\<sharp>* \\<Psi>\\<^sub>F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A\\<^sub>F \\<sharp>* xvec \\<Longrightarrow> xvec \\<sharp>* \\<Psi>\\<^sub>F", "from assms"], ["proof (chain)\npicking this:\n  xvec \\<sharp>* (\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>)", "have \"(set xvec) \\<sharp>* (\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>)\""], ["proof (prove)\nusing this:\n  xvec \\<sharp>* (\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>)\n\ngoal (1 subgoal):\n 1. set xvec \\<sharp>* (\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>)", "by(simp add: fresh_star_def)"], ["proof (state)\nthis:\n  set xvec \\<sharp>* (\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>)\n\ngoal (1 subgoal):\n 1. A\\<^sub>F \\<sharp>* xvec \\<Longrightarrow> xvec \\<sharp>* \\<Psi>\\<^sub>F", "moreover"], ["proof (state)\nthis:\n  set xvec \\<sharp>* (\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>)\n\ngoal (1 subgoal):\n 1. A\\<^sub>F \\<sharp>* xvec \\<Longrightarrow> xvec \\<sharp>* \\<Psi>\\<^sub>F", "assume \"A\\<^sub>F \\<sharp>* xvec\""], ["proof (state)\nthis:\n  A\\<^sub>F \\<sharp>* xvec\n\ngoal (1 subgoal):\n 1. A\\<^sub>F \\<sharp>* xvec \\<Longrightarrow> xvec \\<sharp>* \\<Psi>\\<^sub>F", "ultimately"], ["proof (chain)\npicking this:\n  set xvec \\<sharp>* (\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>)\n  A\\<^sub>F \\<sharp>* xvec", "show \"xvec \\<sharp>* \\<Psi>\\<^sub>F\""], ["proof (prove)\nusing this:\n  set xvec \\<sharp>* (\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>)\n  A\\<^sub>F \\<sharp>* xvec\n\ngoal (1 subgoal):\n 1. xvec \\<sharp>* \\<Psi>\\<^sub>F", "by(simp add: frameResChainFreshSet) (force simp add: fresh_def name_list_supp fresh_star_def)"], ["proof (state)\nthis:\n  xvec \\<sharp>* \\<Psi>\\<^sub>F\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insertAssertionSimps[simp]:\n  fixes A\\<^sub>F :: \"name list\"\n  and   \\<Psi>\\<^sub>F :: 'b\n  and   \\<Psi>  :: 'b\n  \n  assumes \"A\\<^sub>F \\<sharp>* \\<Psi>\"\n\n  shows \"insertAssertion (\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>) \\<Psi> = \\<langle>A\\<^sub>F, \\<Psi> \\<otimes> \\<Psi>\\<^sub>F\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertAssertion (\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>) \\<Psi> =\n    \\<langle>A\\<^sub>F, \\<Psi> \\<otimes> \\<Psi>\\<^sub>F\\<rangle>", "using assms"], ["proof (prove)\nusing this:\n  A\\<^sub>F \\<sharp>* \\<Psi>\n\ngoal (1 subgoal):\n 1. insertAssertion (\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>) \\<Psi> =\n    \\<langle>A\\<^sub>F, \\<Psi> \\<otimes> \\<Psi>\\<^sub>F\\<rangle>", "by(induct A\\<^sub>F arbitrary: F) auto"], ["", "lemma mergeFrameSimps[simp]:\n  fixes A\\<^sub>F :: \"name list\"\n  and   \\<Psi>\\<^sub>F :: 'b\n  and   \\<Psi>  :: 'b\n\n  assumes \"A\\<^sub>F \\<sharp>* \\<Psi>\"\n\n  shows \"(\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>) \\<otimes>\\<^sub>F \\<langle>\\<epsilon>, \\<Psi>\\<rangle> = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>) \\<otimes>\\<^sub>F\n    \\<langle>\\<epsilon>, \\<Psi>\\<rangle> =\n    \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<rangle>", "using assms"], ["proof (prove)\nusing this:\n  A\\<^sub>F \\<sharp>* \\<Psi>\n\ngoal (1 subgoal):\n 1. (\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>) \\<otimes>\\<^sub>F\n    \\<langle>\\<epsilon>, \\<Psi>\\<rangle> =\n    \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<rangle>", "by(induct A\\<^sub>F arbitrary: F) auto"], ["", "lemma mergeFrames[simp]:\n  fixes A\\<^sub>F  :: \"name list\"\n  and   \\<Psi>\\<^sub>F :: 'b\n  and   A\\<^sub>G  :: \"name list\"\n  and   \\<Psi>\\<^sub>G :: 'b\n\n  assumes \"A\\<^sub>F \\<sharp>* A\\<^sub>G\"\n  and     \"A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G\"\n  and     \"A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\"\n\n  shows \"(\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>) \\<otimes>\\<^sub>F (\\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle>) = (\\<langle>(A\\<^sub>F@A\\<^sub>G), \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>) \\<otimes>\\<^sub>F\n    \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> =\n    \\<langle>(A\\<^sub>F @\n              A\\<^sub>G), \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G\\<rangle>", "using assms"], ["proof (prove)\nusing this:\n  A\\<^sub>F \\<sharp>* A\\<^sub>G\n  A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G\n  A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\n\ngoal (1 subgoal):\n 1. (\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>) \\<otimes>\\<^sub>F\n    \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> =\n    \\<langle>(A\\<^sub>F @\n              A\\<^sub>G), \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G\\<rangle>", "by(induct A\\<^sub>F) auto"], ["", "lemma frameImpResFreshLeft:\n  fixes F :: \"'b frame\"\n  and   x :: name\n  \n  assumes \"x \\<sharp> F\"\n\n  shows \"\\<lparr>\\<nu>x\\<rparr>F \\<hookrightarrow>\\<^sub>F F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>F \\<hookrightarrow>\\<^sub>F F", "proof(auto simp add: FrameStatImp_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi> \\<Longrightarrow>\n       F \\<turnstile>\\<^sub>F \\<phi>", "fix \\<phi>::'c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi> \\<Longrightarrow>\n       F \\<turnstile>\\<^sub>F \\<phi>", "obtain A\\<^sub>F \\<Psi>\\<^sub>F where Feq: \"F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\" and \"A\\<^sub>F \\<sharp>* (x, \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A\\<^sub>F \\<Psi>\\<^sub>F.\n        \\<lbrakk>F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>;\n         A\\<^sub>F \\<sharp>* (x, \\<phi>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule freshFrame)"], ["proof (state)\nthis:\n  F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\n  A\\<^sub>F \\<sharp>* (x, \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi> \\<Longrightarrow>\n       F \\<turnstile>\\<^sub>F \\<phi>", "from \\<open>A\\<^sub>F \\<sharp>* (x, \\<phi>)\\<close>"], ["proof (chain)\npicking this:\n  A\\<^sub>F \\<sharp>* (x, \\<phi>)", "have \"x \\<sharp> A\\<^sub>F\" and \"A\\<^sub>F \\<sharp>* \\<phi>\""], ["proof (prove)\nusing this:\n  A\\<^sub>F \\<sharp>* (x, \\<phi>)\n\ngoal (1 subgoal):\n 1. x \\<sharp> A\\<^sub>F &&& A\\<^sub>F \\<sharp>* \\<phi>", "by simp+"], ["proof (state)\nthis:\n  x \\<sharp> A\\<^sub>F\n  A\\<^sub>F \\<sharp>* \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi> \\<Longrightarrow>\n       F \\<turnstile>\\<^sub>F \\<phi>", "obtain y where \"y \\<sharp> \\<phi>\" and \"y \\<sharp> F\" and \"x \\<noteq> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<sharp> \\<phi>; y \\<sharp> F; x \\<noteq> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(generate_fresh \"name\", auto)"], ["proof (state)\nthis:\n  y \\<sharp> \\<phi>\n  y \\<sharp> F\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi> \\<Longrightarrow>\n       F \\<turnstile>\\<^sub>F \\<phi>", "assume \"\\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi>\""], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi> \\<Longrightarrow>\n       F \\<turnstile>\\<^sub>F \\<phi>", "with \\<open>y \\<sharp> F\\<close>"], ["proof (chain)\npicking this:\n  y \\<sharp> F\n  \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi>", "have \"\\<lparr>\\<nu>y\\<rparr>([(x, y)] \\<bullet> F) \\<turnstile>\\<^sub>F \\<phi>\""], ["proof (prove)\nusing this:\n  y \\<sharp> F\n  \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi>\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet> F \\<turnstile>\\<^sub>F \\<phi>", "by(simp add: alphaFrameRes)"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet> F \\<turnstile>\\<^sub>F \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi> \\<Longrightarrow>\n       F \\<turnstile>\\<^sub>F \\<phi>", "with \\<open>x \\<sharp> F\\<close> \\<open>y \\<sharp> F\\<close>"], ["proof (chain)\npicking this:\n  x \\<sharp> F\n  y \\<sharp> F\n  \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet> F \\<turnstile>\\<^sub>F \\<phi>", "have \"\\<lparr>\\<nu>y\\<rparr>F \\<turnstile>\\<^sub>F \\<phi>\""], ["proof (prove)\nusing this:\n  x \\<sharp> F\n  y \\<sharp> F\n  \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet> F \\<turnstile>\\<^sub>F \\<phi>\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>y\\<rparr>F \\<turnstile>\\<^sub>F \\<phi>", "by simp"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>y\\<rparr>F \\<turnstile>\\<^sub>F \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi> \\<Longrightarrow>\n       F \\<turnstile>\\<^sub>F \\<phi>", "with Feq"], ["proof (chain)\npicking this:\n  F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\n  \\<lparr>\\<nu>y\\<rparr>F \\<turnstile>\\<^sub>F \\<phi>", "have \"\\<langle>(y#A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> \\<turnstile>\\<^sub>F \\<phi>\""], ["proof (prove)\nusing this:\n  F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\n  \\<lparr>\\<nu>y\\<rparr>F \\<turnstile>\\<^sub>F \\<phi>\n\ngoal (1 subgoal):\n 1. \\<langle>(y # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> \\<turnstile>\\<^sub>F\n    \\<phi>", "by simp"], ["proof (state)\nthis:\n  \\<langle>(y # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> \\<turnstile>\\<^sub>F\n  \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi> \\<Longrightarrow>\n       F \\<turnstile>\\<^sub>F \\<phi>", "with Feq \\<open>A\\<^sub>F \\<sharp>* \\<phi>\\<close> \\<open>y \\<sharp> \\<phi>\\<close>"], ["proof (chain)\npicking this:\n  F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\n  A\\<^sub>F \\<sharp>* \\<phi>\n  y \\<sharp> \\<phi>\n  \\<langle>(y # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> \\<turnstile>\\<^sub>F\n  \\<phi>", "show \"F \\<turnstile>\\<^sub>F \\<phi>\""], ["proof (prove)\nusing this:\n  F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\n  A\\<^sub>F \\<sharp>* \\<phi>\n  y \\<sharp> \\<phi>\n  \\<langle>(y # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> \\<turnstile>\\<^sub>F\n  \\<phi>\n\ngoal (1 subgoal):\n 1. F \\<turnstile>\\<^sub>F \\<phi>", "by(force intro: frameImpI dest: frameImpE simp del: frameResChain.simps)"], ["proof (state)\nthis:\n  F \\<turnstile>\\<^sub>F \\<phi>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma frameImpResFreshRight:\n  fixes F :: \"'b frame\"\n  and   x :: name\n  \n  assumes \"x \\<sharp> F\"\n\n  shows \"F \\<hookrightarrow>\\<^sub>F \\<lparr>\\<nu>x\\<rparr>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<hookrightarrow>\\<^sub>F \\<lparr>\\<nu>x\\<rparr>F", "proof(auto simp add: FrameStatImp_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       F \\<turnstile>\\<^sub>F \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi>", "fix \\<phi>::'c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       F \\<turnstile>\\<^sub>F \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi>", "obtain A\\<^sub>F \\<Psi>\\<^sub>F where Feq: \"F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\" and \"A\\<^sub>F \\<sharp>* (x, \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A\\<^sub>F \\<Psi>\\<^sub>F.\n        \\<lbrakk>F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>;\n         A\\<^sub>F \\<sharp>* (x, \\<phi>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule freshFrame)"], ["proof (state)\nthis:\n  F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\n  A\\<^sub>F \\<sharp>* (x, \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       F \\<turnstile>\\<^sub>F \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi>", "from \\<open>A\\<^sub>F \\<sharp>* (x, \\<phi>)\\<close>"], ["proof (chain)\npicking this:\n  A\\<^sub>F \\<sharp>* (x, \\<phi>)", "have \"x \\<sharp> A\\<^sub>F\" and \"A\\<^sub>F \\<sharp>* \\<phi>\""], ["proof (prove)\nusing this:\n  A\\<^sub>F \\<sharp>* (x, \\<phi>)\n\ngoal (1 subgoal):\n 1. x \\<sharp> A\\<^sub>F &&& A\\<^sub>F \\<sharp>* \\<phi>", "by simp+"], ["proof (state)\nthis:\n  x \\<sharp> A\\<^sub>F\n  A\\<^sub>F \\<sharp>* \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       F \\<turnstile>\\<^sub>F \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi>", "obtain y where \"y \\<sharp> \\<phi>\" and \"y \\<sharp> F\" and \"x \\<noteq> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<sharp> \\<phi>; y \\<sharp> F; x \\<noteq> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(generate_fresh \"name\", auto)"], ["proof (state)\nthis:\n  y \\<sharp> \\<phi>\n  y \\<sharp> F\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       F \\<turnstile>\\<^sub>F \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi>", "assume \"F \\<turnstile>\\<^sub>F \\<phi>\""], ["proof (state)\nthis:\n  F \\<turnstile>\\<^sub>F \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       F \\<turnstile>\\<^sub>F \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi>", "with Feq \\<open>A\\<^sub>F \\<sharp>* \\<phi>\\<close> \\<open>y \\<sharp> \\<phi>\\<close>"], ["proof (chain)\npicking this:\n  F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\n  A\\<^sub>F \\<sharp>* \\<phi>\n  y \\<sharp> \\<phi>\n  F \\<turnstile>\\<^sub>F \\<phi>", "have \"\\<langle>(y#A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> \\<turnstile>\\<^sub>F \\<phi>\""], ["proof (prove)\nusing this:\n  F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\n  A\\<^sub>F \\<sharp>* \\<phi>\n  y \\<sharp> \\<phi>\n  F \\<turnstile>\\<^sub>F \\<phi>\n\ngoal (1 subgoal):\n 1. \\<langle>(y # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> \\<turnstile>\\<^sub>F\n    \\<phi>", "by(force intro: frameImpI dest: frameImpE simp del: frameResChain.simps)"], ["proof (state)\nthis:\n  \\<langle>(y # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> \\<turnstile>\\<^sub>F\n  \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       F \\<turnstile>\\<^sub>F \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi>", "moreover"], ["proof (state)\nthis:\n  \\<langle>(y # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> \\<turnstile>\\<^sub>F\n  \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       F \\<turnstile>\\<^sub>F \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi>", "with \\<open>y \\<sharp> F\\<close> \\<open>x \\<sharp> F\\<close> Feq"], ["proof (chain)\npicking this:\n  y \\<sharp> F\n  x \\<sharp> F\n  F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\n  \\<langle>(y # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> \\<turnstile>\\<^sub>F\n  \\<phi>", "show \"\\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi>\""], ["proof (prove)\nusing this:\n  y \\<sharp> F\n  x \\<sharp> F\n  F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\n  \\<langle>(y # A\\<^sub>F), \\<Psi>\\<^sub>F\\<rangle> \\<turnstile>\\<^sub>F\n  \\<phi>\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi>", "by(subst alphaFrameRes) auto"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma frameResFresh:\n  fixes F :: \"'b frame\"\n  and   x :: name\n  \n  assumes \"x \\<sharp> F\"\n\n  shows \"\\<lparr>\\<nu>x\\<rparr>F \\<simeq>\\<^sub>F F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>F \\<simeq>\\<^sub>F F", "using assms"], ["proof (prove)\nusing this:\n  x \\<sharp> F\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>F \\<simeq>\\<^sub>F F", "by(auto simp add: FrameStatEq_def intro: frameImpResFreshLeft frameImpResFreshRight)"], ["", "lemma frameImpResPres:\n  fixes F :: \"'b frame\"\n  and   G :: \"'b frame\"\n  and   x :: name\n  \n  assumes \"F \\<hookrightarrow>\\<^sub>F G\"\n\n  shows \"\\<lparr>\\<nu>x\\<rparr>F \\<hookrightarrow>\\<^sub>F \\<lparr>\\<nu>x\\<rparr>G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>F \\<hookrightarrow>\\<^sub>F\n    \\<lparr>\\<nu>x\\<rparr>G", "proof(auto simp add: FrameStatImp_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>x\\<rparr>G \\<turnstile>\\<^sub>F \\<phi>", "fix \\<phi>::'c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>x\\<rparr>G \\<turnstile>\\<^sub>F \\<phi>", "obtain A\\<^sub>F \\<Psi>\\<^sub>F where Feq: \"F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\" and \"A\\<^sub>F \\<sharp>* (x, \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A\\<^sub>F \\<Psi>\\<^sub>F.\n        \\<lbrakk>F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>;\n         A\\<^sub>F \\<sharp>* (x, \\<phi>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule freshFrame)"], ["proof (state)\nthis:\n  F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\n  A\\<^sub>F \\<sharp>* (x, \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>x\\<rparr>G \\<turnstile>\\<^sub>F \\<phi>", "from \\<open>A\\<^sub>F \\<sharp>* (x, \\<phi>)\\<close>"], ["proof (chain)\npicking this:\n  A\\<^sub>F \\<sharp>* (x, \\<phi>)", "have \"x \\<sharp> A\\<^sub>F\" and \"A\\<^sub>F \\<sharp>* \\<phi>\""], ["proof (prove)\nusing this:\n  A\\<^sub>F \\<sharp>* (x, \\<phi>)\n\ngoal (1 subgoal):\n 1. x \\<sharp> A\\<^sub>F &&& A\\<^sub>F \\<sharp>* \\<phi>", "by simp+"], ["proof (state)\nthis:\n  x \\<sharp> A\\<^sub>F\n  A\\<^sub>F \\<sharp>* \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>x\\<rparr>G \\<turnstile>\\<^sub>F \\<phi>", "obtain y where \"y \\<sharp> A\\<^sub>F\" and \"y \\<sharp> F\" and \"y \\<sharp> G\"\n             and \"x \\<noteq> y\" and \"y \\<sharp> \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<sharp> A\\<^sub>F; y \\<sharp> F; y \\<sharp> G;\n         x \\<noteq> y; y \\<sharp> \\<phi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(generate_fresh \"name\", auto)"], ["proof (state)\nthis:\n  y \\<sharp> A\\<^sub>F\n  y \\<sharp> F\n  y \\<sharp> G\n  x \\<noteq> y\n  y \\<sharp> \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>x\\<rparr>G \\<turnstile>\\<^sub>F \\<phi>", "assume \"\\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi>\""], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>x\\<rparr>G \\<turnstile>\\<^sub>F \\<phi>", "with \\<open>y \\<sharp> F\\<close>"], ["proof (chain)\npicking this:\n  y \\<sharp> F\n  \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi>", "have \"\\<lparr>\\<nu>y\\<rparr>([(x, y)] \\<bullet> F) \\<turnstile>\\<^sub>F \\<phi>\""], ["proof (prove)\nusing this:\n  y \\<sharp> F\n  \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi>\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet> F \\<turnstile>\\<^sub>F \\<phi>", "by(simp add: alphaFrameRes)"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet> F \\<turnstile>\\<^sub>F \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>x\\<rparr>G \\<turnstile>\\<^sub>F \\<phi>", "with Feq \\<open>x \\<sharp> A\\<^sub>F\\<close> \\<open>y \\<sharp> A\\<^sub>F\\<close>"], ["proof (chain)\npicking this:\n  F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\n  x \\<sharp> A\\<^sub>F\n  y \\<sharp> A\\<^sub>F\n  \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet> F \\<turnstile>\\<^sub>F \\<phi>", "have \"\\<langle>(y#A\\<^sub>F), [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<rangle> \\<turnstile>\\<^sub>F \\<phi>\""], ["proof (prove)\nusing this:\n  F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\n  x \\<sharp> A\\<^sub>F\n  y \\<sharp> A\\<^sub>F\n  \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet> F \\<turnstile>\\<^sub>F \\<phi>\n\ngoal (1 subgoal):\n 1. \\<langle>(y #\n              A\\<^sub>F), [(x, y)] \\<bullet>\n                          \\<Psi>\\<^sub>F\\<rangle> \\<turnstile>\\<^sub>F\n    \\<phi>", "by(simp add: eqvts)"], ["proof (state)\nthis:\n  \\<langle>(y #\n            A\\<^sub>F), [(x, y)] \\<bullet>\n                        \\<Psi>\\<^sub>F\\<rangle> \\<turnstile>\\<^sub>F\n  \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>x\\<rparr>G \\<turnstile>\\<^sub>F \\<phi>", "with \\<open>y \\<sharp> \\<phi>\\<close> \\<open>A\\<^sub>F \\<sharp>* \\<phi>\\<close>"], ["proof (chain)\npicking this:\n  y \\<sharp> \\<phi>\n  A\\<^sub>F \\<sharp>* \\<phi>\n  \\<langle>(y #\n            A\\<^sub>F), [(x, y)] \\<bullet>\n                        \\<Psi>\\<^sub>F\\<rangle> \\<turnstile>\\<^sub>F\n  \\<phi>", "have \"\\<langle>A\\<^sub>F, [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<rangle> \\<turnstile>\\<^sub>F \\<phi>\""], ["proof (prove)\nusing this:\n  y \\<sharp> \\<phi>\n  A\\<^sub>F \\<sharp>* \\<phi>\n  \\<langle>(y #\n            A\\<^sub>F), [(x, y)] \\<bullet>\n                        \\<Psi>\\<^sub>F\\<rangle> \\<turnstile>\\<^sub>F\n  \\<phi>\n\ngoal (1 subgoal):\n 1. \\<langle>A\\<^sub>F, [(x, y)] \\<bullet>\n                        \\<Psi>\\<^sub>F\\<rangle> \\<turnstile>\\<^sub>F\n    \\<phi>", "by(force intro: frameImpI dest: frameImpE simp del: frameResChain.simps)"], ["proof (state)\nthis:\n  \\<langle>A\\<^sub>F, [(x, y)] \\<bullet>\n                      \\<Psi>\\<^sub>F\\<rangle> \\<turnstile>\\<^sub>F\n  \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>x\\<rparr>G \\<turnstile>\\<^sub>F \\<phi>", "hence \"([(x, y)] \\<bullet> \\<langle>A\\<^sub>F, [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<rangle>) \\<turnstile>\\<^sub>F ([(x, y)] \\<bullet> \\<phi>)\""], ["proof (prove)\nusing this:\n  \\<langle>A\\<^sub>F, [(x, y)] \\<bullet>\n                      \\<Psi>\\<^sub>F\\<rangle> \\<turnstile>\\<^sub>F\n  \\<phi>\n\ngoal (1 subgoal):\n 1. [(x, y)] \\<bullet>\n    \\<langle>A\\<^sub>F, [(x, y)] \\<bullet>\n                        \\<Psi>\\<^sub>F\\<rangle> \\<turnstile>\\<^sub>F\n    [(x, y)] \\<bullet> \\<phi>", "by(rule frameImpClosed)"], ["proof (state)\nthis:\n  [(x, y)] \\<bullet>\n  \\<langle>A\\<^sub>F, [(x, y)] \\<bullet>\n                      \\<Psi>\\<^sub>F\\<rangle> \\<turnstile>\\<^sub>F\n  [(x, y)] \\<bullet> \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>x\\<rparr>G \\<turnstile>\\<^sub>F \\<phi>", "with \\<open>x \\<sharp> A\\<^sub>F\\<close> \\<open>y \\<sharp> A\\<^sub>F\\<close> Feq"], ["proof (chain)\npicking this:\n  x \\<sharp> A\\<^sub>F\n  y \\<sharp> A\\<^sub>F\n  F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\n  [(x, y)] \\<bullet>\n  \\<langle>A\\<^sub>F, [(x, y)] \\<bullet>\n                      \\<Psi>\\<^sub>F\\<rangle> \\<turnstile>\\<^sub>F\n  [(x, y)] \\<bullet> \\<phi>", "have \"F \\<turnstile>\\<^sub>F [(x, y)] \\<bullet> \\<phi>\""], ["proof (prove)\nusing this:\n  x \\<sharp> A\\<^sub>F\n  y \\<sharp> A\\<^sub>F\n  F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\n  [(x, y)] \\<bullet>\n  \\<langle>A\\<^sub>F, [(x, y)] \\<bullet>\n                      \\<Psi>\\<^sub>F\\<rangle> \\<turnstile>\\<^sub>F\n  [(x, y)] \\<bullet> \\<phi>\n\ngoal (1 subgoal):\n 1. F \\<turnstile>\\<^sub>F [(x, y)] \\<bullet> \\<phi>", "by(simp add: eqvts)"], ["proof (state)\nthis:\n  F \\<turnstile>\\<^sub>F [(x, y)] \\<bullet> \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>x\\<rparr>G \\<turnstile>\\<^sub>F \\<phi>", "with \\<open>F \\<hookrightarrow>\\<^sub>F G\\<close>"], ["proof (chain)\npicking this:\n  F \\<hookrightarrow>\\<^sub>F G\n  F \\<turnstile>\\<^sub>F [(x, y)] \\<bullet> \\<phi>", "have \"G \\<turnstile>\\<^sub>F [(x, y)] \\<bullet> \\<phi>\""], ["proof (prove)\nusing this:\n  F \\<hookrightarrow>\\<^sub>F G\n  F \\<turnstile>\\<^sub>F [(x, y)] \\<bullet> \\<phi>\n\ngoal (1 subgoal):\n 1. G \\<turnstile>\\<^sub>F [(x, y)] \\<bullet> \\<phi>", "by(simp add: FrameStatImp_def)"], ["proof (state)\nthis:\n  G \\<turnstile>\\<^sub>F [(x, y)] \\<bullet> \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>x\\<rparr>G \\<turnstile>\\<^sub>F \\<phi>", "obtain A\\<^sub>G \\<Psi>\\<^sub>G where Geq: \"G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle>\" and \"A\\<^sub>G \\<sharp>* (x, y, \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A\\<^sub>G \\<Psi>\\<^sub>G.\n        \\<lbrakk>G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle>;\n         A\\<^sub>G \\<sharp>* (x, y, \\<phi>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule freshFrame)"], ["proof (state)\nthis:\n  G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle>\n  A\\<^sub>G \\<sharp>* (x, y, \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>x\\<rparr>G \\<turnstile>\\<^sub>F \\<phi>", "from \\<open>A\\<^sub>G \\<sharp>* (x, y, \\<phi>)\\<close>"], ["proof (chain)\npicking this:\n  A\\<^sub>G \\<sharp>* (x, y, \\<phi>)", "have \"x \\<sharp> A\\<^sub>G\" and \"y \\<sharp> A\\<^sub>G\" and \"A\\<^sub>G \\<sharp>* \\<phi>\""], ["proof (prove)\nusing this:\n  A\\<^sub>G \\<sharp>* (x, y, \\<phi>)\n\ngoal (1 subgoal):\n 1. x \\<sharp> A\\<^sub>G &&&\n    y \\<sharp> A\\<^sub>G &&& A\\<^sub>G \\<sharp>* \\<phi>", "by simp+"], ["proof (state)\nthis:\n  x \\<sharp> A\\<^sub>G\n  y \\<sharp> A\\<^sub>G\n  A\\<^sub>G \\<sharp>* \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>x\\<rparr>G \\<turnstile>\\<^sub>F \\<phi>", "from \\<open>G \\<turnstile>\\<^sub>F [(x, y)] \\<bullet> \\<phi>\\<close>"], ["proof (chain)\npicking this:\n  G \\<turnstile>\\<^sub>F [(x, y)] \\<bullet> \\<phi>", "have \"([(x, y)] \\<bullet> G) \\<turnstile>\\<^sub>F [(x, y)] \\<bullet> [(x, y)] \\<bullet> \\<phi>\""], ["proof (prove)\nusing this:\n  G \\<turnstile>\\<^sub>F [(x, y)] \\<bullet> \\<phi>\n\ngoal (1 subgoal):\n 1. [(x, y)] \\<bullet> G \\<turnstile>\\<^sub>F\n    [(x, y)] \\<bullet> [(x, y)] \\<bullet> \\<phi>", "by(rule frameImpClosed)"], ["proof (state)\nthis:\n  [(x, y)] \\<bullet> G \\<turnstile>\\<^sub>F\n  [(x, y)] \\<bullet> [(x, y)] \\<bullet> \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>x\\<rparr>G \\<turnstile>\\<^sub>F \\<phi>", "with Geq \\<open>x \\<sharp> A\\<^sub>G\\<close> \\<open>y \\<sharp> A\\<^sub>G\\<close>"], ["proof (chain)\npicking this:\n  G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle>\n  x \\<sharp> A\\<^sub>G\n  y \\<sharp> A\\<^sub>G\n  [(x, y)] \\<bullet> G \\<turnstile>\\<^sub>F\n  [(x, y)] \\<bullet> [(x, y)] \\<bullet> \\<phi>", "have \"\\<langle>A\\<^sub>G, [(x, y)] \\<bullet> \\<Psi>\\<^sub>G\\<rangle> \\<turnstile>\\<^sub>F \\<phi>\""], ["proof (prove)\nusing this:\n  G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle>\n  x \\<sharp> A\\<^sub>G\n  y \\<sharp> A\\<^sub>G\n  [(x, y)] \\<bullet> G \\<turnstile>\\<^sub>F\n  [(x, y)] \\<bullet> [(x, y)] \\<bullet> \\<phi>\n\ngoal (1 subgoal):\n 1. \\<langle>A\\<^sub>G, [(x, y)] \\<bullet>\n                        \\<Psi>\\<^sub>G\\<rangle> \\<turnstile>\\<^sub>F\n    \\<phi>", "by(simp add: eqvts)"], ["proof (state)\nthis:\n  \\<langle>A\\<^sub>G, [(x, y)] \\<bullet>\n                      \\<Psi>\\<^sub>G\\<rangle> \\<turnstile>\\<^sub>F\n  \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>x\\<rparr>G \\<turnstile>\\<^sub>F \\<phi>", "with \\<open>y \\<sharp> \\<phi>\\<close> \\<open>A\\<^sub>G \\<sharp>* \\<phi>\\<close>"], ["proof (chain)\npicking this:\n  y \\<sharp> \\<phi>\n  A\\<^sub>G \\<sharp>* \\<phi>\n  \\<langle>A\\<^sub>G, [(x, y)] \\<bullet>\n                      \\<Psi>\\<^sub>G\\<rangle> \\<turnstile>\\<^sub>F\n  \\<phi>", "have \"\\<langle>(y#A\\<^sub>G), [(x, y)] \\<bullet> \\<Psi>\\<^sub>G\\<rangle> \\<turnstile>\\<^sub>F \\<phi>\""], ["proof (prove)\nusing this:\n  y \\<sharp> \\<phi>\n  A\\<^sub>G \\<sharp>* \\<phi>\n  \\<langle>A\\<^sub>G, [(x, y)] \\<bullet>\n                      \\<Psi>\\<^sub>G\\<rangle> \\<turnstile>\\<^sub>F\n  \\<phi>\n\ngoal (1 subgoal):\n 1. \\<langle>(y #\n              A\\<^sub>G), [(x, y)] \\<bullet>\n                          \\<Psi>\\<^sub>G\\<rangle> \\<turnstile>\\<^sub>F\n    \\<phi>", "by(force intro: frameImpI dest: frameImpE simp del: frameResChain.simps)"], ["proof (state)\nthis:\n  \\<langle>(y #\n            A\\<^sub>G), [(x, y)] \\<bullet>\n                        \\<Psi>\\<^sub>G\\<rangle> \\<turnstile>\\<^sub>F\n  \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>x\\<rparr>G \\<turnstile>\\<^sub>F \\<phi>", "with \\<open>y \\<sharp> G\\<close> \\<open>x \\<sharp> A\\<^sub>G\\<close> \\<open>y \\<sharp> A\\<^sub>G\\<close> Geq"], ["proof (chain)\npicking this:\n  y \\<sharp> G\n  x \\<sharp> A\\<^sub>G\n  y \\<sharp> A\\<^sub>G\n  G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle>\n  \\<langle>(y #\n            A\\<^sub>G), [(x, y)] \\<bullet>\n                        \\<Psi>\\<^sub>G\\<rangle> \\<turnstile>\\<^sub>F\n  \\<phi>", "show \"\\<lparr>\\<nu>x\\<rparr>G \\<turnstile>\\<^sub>F \\<phi>\""], ["proof (prove)\nusing this:\n  y \\<sharp> G\n  x \\<sharp> A\\<^sub>G\n  y \\<sharp> A\\<^sub>G\n  G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle>\n  \\<langle>(y #\n            A\\<^sub>G), [(x, y)] \\<bullet>\n                        \\<Psi>\\<^sub>G\\<rangle> \\<turnstile>\\<^sub>F\n  \\<phi>\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>G \\<turnstile>\\<^sub>F \\<phi>", "by(subst alphaFrameRes) (fastforce simp add: eqvts)+"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>G \\<turnstile>\\<^sub>F \\<phi>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma frameResPres:\n  fixes F :: \"'b frame\"\n  and   G :: \"'b frame\"\n  and   x :: name\n  \n  assumes \"F \\<simeq>\\<^sub>F G\"\n\n  shows \"\\<lparr>\\<nu>x\\<rparr>F \\<simeq>\\<^sub>F \\<lparr>\\<nu>x\\<rparr>G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>F \\<simeq>\\<^sub>F \\<lparr>\\<nu>x\\<rparr>G", "using assms"], ["proof (prove)\nusing this:\n  F \\<simeq>\\<^sub>F G\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>F \\<simeq>\\<^sub>F \\<lparr>\\<nu>x\\<rparr>G", "by(auto simp add: FrameStatEq_def intro: frameImpResPres)"], ["", "lemma frameImpResComm:\n  fixes x :: name\n  and   y :: name\n  and   F :: \"'b frame\"\n\n  shows \"\\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>F) \\<hookrightarrow>\\<^sub>F \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<hookrightarrow>\\<^sub>F\n    \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F", "proof(case_tac \"x = y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<hookrightarrow>\\<^sub>F\n    \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F\n 2. x \\<noteq> y \\<Longrightarrow>\n    \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<hookrightarrow>\\<^sub>F\n    \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F", "assume \"x = y\""], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<hookrightarrow>\\<^sub>F\n    \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F\n 2. x \\<noteq> y \\<Longrightarrow>\n    \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<hookrightarrow>\\<^sub>F\n    \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = y\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<hookrightarrow>\\<^sub>F\n    \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F", "by simp"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<hookrightarrow>\\<^sub>F\n  \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<hookrightarrow>\\<^sub>F\n    \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<hookrightarrow>\\<^sub>F\n    \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F", "assume \"x \\<noteq> y\""], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<hookrightarrow>\\<^sub>F\n    \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<hookrightarrow>\\<^sub>F\n    \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F", "proof(auto simp add: FrameStatImp_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi>", "fix \\<phi>::'c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi>", "obtain A\\<^sub>F \\<Psi>\\<^sub>F where Feq: \"F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\" and \"A\\<^sub>F \\<sharp>* (x, y, \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A\\<^sub>F \\<Psi>\\<^sub>F.\n        \\<lbrakk>F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>;\n         A\\<^sub>F \\<sharp>* (x, y, \\<phi>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule freshFrame)"], ["proof (state)\nthis:\n  F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\n  A\\<^sub>F \\<sharp>* (x, y, \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi>", "then"], ["proof (chain)\npicking this:\n  F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\n  A\\<^sub>F \\<sharp>* (x, y, \\<phi>)", "have \"x \\<sharp> A\\<^sub>F\" and \"y \\<sharp> A\\<^sub>F\" and \"A\\<^sub>F \\<sharp>* \\<phi>\""], ["proof (prove)\nusing this:\n  F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\n  A\\<^sub>F \\<sharp>* (x, y, \\<phi>)\n\ngoal (1 subgoal):\n 1. x \\<sharp> A\\<^sub>F &&&\n    y \\<sharp> A\\<^sub>F &&& A\\<^sub>F \\<sharp>* \\<phi>", "by simp+"], ["proof (state)\nthis:\n  x \\<sharp> A\\<^sub>F\n  y \\<sharp> A\\<^sub>F\n  A\\<^sub>F \\<sharp>* \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi>", "obtain x'::name where \"x' \\<noteq> x\" and \"x' \\<noteq> y\" and \"x' \\<sharp> F\" and \"x' \\<sharp> \\<phi>\" and \"x' \\<sharp> A\\<^sub>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>x' \\<noteq> x; x' \\<noteq> y; x' \\<sharp> F;\n         x' \\<sharp> \\<phi>; x' \\<sharp> A\\<^sub>F\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(generate_fresh \"name\") auto"], ["proof (state)\nthis:\n  x' \\<noteq> x\n  x' \\<noteq> y\n  x' \\<sharp> F\n  x' \\<sharp> \\<phi>\n  x' \\<sharp> A\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi>", "obtain y'::name where \"y' \\<noteq> x\" and \"y' \\<noteq> y\" and \"y' \\<noteq> x'\" and \"y' \\<sharp> F\" and \"y' \\<sharp> \\<phi>\" and \"y' \\<sharp> A\\<^sub>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y'.\n        \\<lbrakk>y' \\<noteq> x; y' \\<noteq> y; y' \\<noteq> x';\n         y' \\<sharp> F; y' \\<sharp> \\<phi>; y' \\<sharp> A\\<^sub>F\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(generate_fresh \"name\") auto"], ["proof (state)\nthis:\n  y' \\<noteq> x\n  y' \\<noteq> y\n  y' \\<noteq> x'\n  y' \\<sharp> F\n  y' \\<sharp> \\<phi>\n  y' \\<sharp> A\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi>", "from \\<open>y' \\<sharp> F\\<close>"], ["proof (chain)\npicking this:\n  y' \\<sharp> F", "have \"\\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>F) = \\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y'\\<rparr>([(y, y')] \\<bullet> F))\""], ["proof (prove)\nusing this:\n  y' \\<sharp> F\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F =\n    \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet> F", "by(simp add: alphaFrameRes)"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F =\n  \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet> F\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi>", "moreover"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F =\n  \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet> F\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi>", "from \\<open>x' \\<sharp> F\\<close> \\<open>x' \\<noteq> y\\<close> \\<open>y' \\<noteq> x'\\<close>"], ["proof (chain)\npicking this:\n  x' \\<sharp> F\n  x' \\<noteq> y\n  y' \\<noteq> x'", "have \"\\<dots> = \\<lparr>\\<nu>x'\\<rparr>([(x, x')] \\<bullet> (\\<lparr>\\<nu>y'\\<rparr>([(y, y')] \\<bullet> F)))\""], ["proof (prove)\nusing this:\n  x' \\<sharp> F\n  x' \\<noteq> y\n  y' \\<noteq> x'\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet> F =\n    \\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet>\n                           \\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet> F", "by(rule_tac alphaFrameRes) (simp add: abs_fresh fresh_left)"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet> F =\n  \\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet>\n                         \\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet> F\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi>", "moreover"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet> F =\n  \\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet>\n                         \\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet> F\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi>", "with  \\<open>y' \\<noteq> x'\\<close> \\<open>y' \\<noteq> x\\<close>"], ["proof (chain)\npicking this:\n  y' \\<noteq> x'\n  y' \\<noteq> x\n  \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet> F =\n  \\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet>\n                         \\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet> F", "have \"\\<dots> = \\<lparr>\\<nu>x'\\<rparr>(\\<lparr>\\<nu>y'\\<rparr>([(x, x')] \\<bullet> [(y, y')] \\<bullet> F))\""], ["proof (prove)\nusing this:\n  y' \\<noteq> x'\n  y' \\<noteq> x\n  \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet> F =\n  \\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet>\n                         \\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet> F\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet>\n                           \\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet> F =\n    \\<lparr>\\<nu>x'\\<rparr>\\<lparr>\\<nu>y'\\<rparr>[(x, x')] \\<bullet>\n            [(y, y')] \\<bullet> F", "by(simp add: eqvts calc_atm)"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet>\n                         \\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet> F =\n  \\<lparr>\\<nu>x'\\<rparr>\\<lparr>\\<nu>y'\\<rparr>[(x, x')] \\<bullet>\n          [(y, y')] \\<bullet> F\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi>", "ultimately"], ["proof (chain)\npicking this:\n  \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F =\n  \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet> F\n  \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet> F =\n  \\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet>\n                         \\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet> F\n  \\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet>\n                         \\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet> F =\n  \\<lparr>\\<nu>x'\\<rparr>\\<lparr>\\<nu>y'\\<rparr>[(x, x')] \\<bullet>\n          [(y, y')] \\<bullet> F", "have A: \"\\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>F)= \\<lparr>\\<nu>x'\\<rparr>(\\<lparr>\\<nu>y'\\<rparr>(\\<lparr>\\<nu>*A\\<^sub>F\\<rparr>(FAssert([(x, x')] \\<bullet> [(y, y')] \\<bullet> \\<Psi>\\<^sub>F))))\""], ["proof (prove)\nusing this:\n  \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F =\n  \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet> F\n  \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet> F =\n  \\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet>\n                         \\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet> F\n  \\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet>\n                         \\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet> F =\n  \\<lparr>\\<nu>x'\\<rparr>\\<lparr>\\<nu>y'\\<rparr>[(x, x')] \\<bullet>\n          [(y, y')] \\<bullet> F\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F =\n    \\<lparr>\\<nu>x'\\<rparr>\\<lparr>\\<nu>y'\\<rparr>\\<langle>A\\<^sub>F, [(x,\n                                  x')] \\<bullet>\n                                [(y, y')] \\<bullet> \\<Psi>\\<^sub>F\\<rangle>", "using  Feq \\<open>x \\<sharp> A\\<^sub>F\\<close> \\<open>x' \\<sharp> A\\<^sub>F\\<close> \\<open>y \\<sharp> A\\<^sub>F\\<close> \\<open>y' \\<sharp> A\\<^sub>F\\<close>"], ["proof (prove)\nusing this:\n  \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F =\n  \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet> F\n  \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet> F =\n  \\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet>\n                         \\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet> F\n  \\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet>\n                         \\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet> F =\n  \\<lparr>\\<nu>x'\\<rparr>\\<lparr>\\<nu>y'\\<rparr>[(x, x')] \\<bullet>\n          [(y, y')] \\<bullet> F\n  F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\n  x \\<sharp> A\\<^sub>F\n  x' \\<sharp> A\\<^sub>F\n  y \\<sharp> A\\<^sub>F\n  y' \\<sharp> A\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F =\n    \\<lparr>\\<nu>x'\\<rparr>\\<lparr>\\<nu>y'\\<rparr>\\<langle>A\\<^sub>F, [(x,\n                                  x')] \\<bullet>\n                                [(y, y')] \\<bullet> \\<Psi>\\<^sub>F\\<rangle>", "by(simp add: eqvts)"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F =\n  \\<lparr>\\<nu>x'\\<rparr>\\<lparr>\\<nu>y'\\<rparr>\\<langle>A\\<^sub>F, [(x,\n                                x')] \\<bullet>\n                              [(y, y')] \\<bullet> \\<Psi>\\<^sub>F\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi>", "from \\<open>x' \\<sharp> F\\<close>"], ["proof (chain)\npicking this:\n  x' \\<sharp> F", "have \"\\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>F) = \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x'\\<rparr>([(x, x')] \\<bullet> F))\""], ["proof (prove)\nusing this:\n  x' \\<sharp> F\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F =\n    \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet> F", "by(simp add: alphaFrameRes)"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F =\n  \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet> F\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi>", "moreover"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F =\n  \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet> F\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi>", "from \\<open>y' \\<sharp> F\\<close> \\<open>y' \\<noteq> x\\<close> \\<open>y' \\<noteq> x'\\<close>"], ["proof (chain)\npicking this:\n  y' \\<sharp> F\n  y' \\<noteq> x\n  y' \\<noteq> x'", "have \"\\<dots> = \\<lparr>\\<nu>y'\\<rparr>([(y, y')] \\<bullet> (\\<lparr>\\<nu>x'\\<rparr>([(x, x')] \\<bullet> F)))\""], ["proof (prove)\nusing this:\n  y' \\<sharp> F\n  y' \\<noteq> x\n  y' \\<noteq> x'\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet> F =\n    \\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet>\n                           \\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet> F", "by(rule_tac alphaFrameRes) (simp add: abs_fresh fresh_left)"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet> F =\n  \\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet>\n                         \\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet> F\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi>", "moreover"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet> F =\n  \\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet>\n                         \\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet> F\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi>", "with  \\<open>y' \\<noteq> x'\\<close> \\<open>x' \\<noteq> y\\<close>"], ["proof (chain)\npicking this:\n  y' \\<noteq> x'\n  x' \\<noteq> y\n  \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet> F =\n  \\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet>\n                         \\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet> F", "have \"\\<dots> = \\<lparr>\\<nu>y'\\<rparr>(\\<lparr>\\<nu>x'\\<rparr>([(y, y')] \\<bullet> [(x, x')] \\<bullet> F))\""], ["proof (prove)\nusing this:\n  y' \\<noteq> x'\n  x' \\<noteq> y\n  \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet> F =\n  \\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet>\n                         \\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet> F\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet>\n                           \\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet> F =\n    \\<lparr>\\<nu>y'\\<rparr>\\<lparr>\\<nu>x'\\<rparr>[(y, y')] \\<bullet>\n            [(x, x')] \\<bullet> F", "by(simp add: eqvts calc_atm)"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet>\n                         \\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet> F =\n  \\<lparr>\\<nu>y'\\<rparr>\\<lparr>\\<nu>x'\\<rparr>[(y, y')] \\<bullet>\n          [(x, x')] \\<bullet> F\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi>", "moreover"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet>\n                         \\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet> F =\n  \\<lparr>\\<nu>y'\\<rparr>\\<lparr>\\<nu>x'\\<rparr>[(y, y')] \\<bullet>\n          [(x, x')] \\<bullet> F\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi>", "with \\<open>x' \\<noteq> x\\<close> \\<open>x' \\<noteq> y\\<close> \\<open>y' \\<noteq> x\\<close> \\<open>y' \\<noteq> y\\<close> \\<open>y' \\<noteq> x'\\<close> \\<open>x \\<noteq> y\\<close>"], ["proof (chain)\npicking this:\n  x' \\<noteq> x\n  x' \\<noteq> y\n  y' \\<noteq> x\n  y' \\<noteq> y\n  y' \\<noteq> x'\n  x \\<noteq> y\n  \\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet>\n                         \\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet> F =\n  \\<lparr>\\<nu>y'\\<rparr>\\<lparr>\\<nu>x'\\<rparr>[(y, y')] \\<bullet>\n          [(x, x')] \\<bullet> F", "have \"\\<dots> = \\<lparr>\\<nu>y'\\<rparr>(\\<lparr>\\<nu>x'\\<rparr>([(x, x')] \\<bullet> [(y, y')] \\<bullet> F))\""], ["proof (prove)\nusing this:\n  x' \\<noteq> x\n  x' \\<noteq> y\n  y' \\<noteq> x\n  y' \\<noteq> y\n  y' \\<noteq> x'\n  x \\<noteq> y\n  \\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet>\n                         \\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet> F =\n  \\<lparr>\\<nu>y'\\<rparr>\\<lparr>\\<nu>x'\\<rparr>[(y, y')] \\<bullet>\n          [(x, x')] \\<bullet> F\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>y'\\<rparr>\\<lparr>\\<nu>x'\\<rparr>[(y, y')] \\<bullet>\n            [(x, x')] \\<bullet> F =\n    \\<lparr>\\<nu>y'\\<rparr>\\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet>\n            [(y, y')] \\<bullet> F", "apply(simp add: eqvts)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x' \\<noteq> x; x' \\<noteq> y; y' \\<noteq> x; y' \\<noteq> y;\n     y' \\<noteq> x'; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> \\<lparr>\\<nu>y'\\<rparr>\\<lparr>\\<nu>x'\\<rparr>[(y,\n                                y')] \\<bullet>\n                              [(x, x')] \\<bullet> F =\n                      \\<lparr>\\<nu>y'\\<rparr>\\<lparr>\\<nu>x'\\<rparr>[(x,\n                                x')] \\<bullet>\n                              [(y, y')] \\<bullet> F", "by(subst perm_compose) (simp add: calc_atm)"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>y'\\<rparr>\\<lparr>\\<nu>x'\\<rparr>[(y, y')] \\<bullet>\n          [(x, x')] \\<bullet> F =\n  \\<lparr>\\<nu>y'\\<rparr>\\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet>\n          [(y, y')] \\<bullet> F\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi>", "ultimately"], ["proof (chain)\npicking this:\n  \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F =\n  \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet> F\n  \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet> F =\n  \\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet>\n                         \\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet> F\n  \\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet>\n                         \\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet> F =\n  \\<lparr>\\<nu>y'\\<rparr>\\<lparr>\\<nu>x'\\<rparr>[(y, y')] \\<bullet>\n          [(x, x')] \\<bullet> F\n  \\<lparr>\\<nu>y'\\<rparr>\\<lparr>\\<nu>x'\\<rparr>[(y, y')] \\<bullet>\n          [(x, x')] \\<bullet> F =\n  \\<lparr>\\<nu>y'\\<rparr>\\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet>\n          [(y, y')] \\<bullet> F", "have B: \"\\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>F)= \\<lparr>\\<nu>y'\\<rparr>(\\<lparr>\\<nu>x'\\<rparr>(\\<lparr>\\<nu>*A\\<^sub>F\\<rparr>(FAssert([(x, x')] \\<bullet> [(y, y')] \\<bullet> \\<Psi>\\<^sub>F))))\""], ["proof (prove)\nusing this:\n  \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F =\n  \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet> F\n  \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet> F =\n  \\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet>\n                         \\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet> F\n  \\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet>\n                         \\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet> F =\n  \\<lparr>\\<nu>y'\\<rparr>\\<lparr>\\<nu>x'\\<rparr>[(y, y')] \\<bullet>\n          [(x, x')] \\<bullet> F\n  \\<lparr>\\<nu>y'\\<rparr>\\<lparr>\\<nu>x'\\<rparr>[(y, y')] \\<bullet>\n          [(x, x')] \\<bullet> F =\n  \\<lparr>\\<nu>y'\\<rparr>\\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet>\n          [(y, y')] \\<bullet> F\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F =\n    \\<lparr>\\<nu>y'\\<rparr>\\<lparr>\\<nu>x'\\<rparr>\\<langle>A\\<^sub>F, [(x,\n                                  x')] \\<bullet>\n                                [(y, y')] \\<bullet> \\<Psi>\\<^sub>F\\<rangle>", "using  Feq \\<open>x \\<sharp> A\\<^sub>F\\<close> \\<open>x' \\<sharp> A\\<^sub>F\\<close> \\<open>y \\<sharp> A\\<^sub>F\\<close> \\<open>y' \\<sharp> A\\<^sub>F\\<close>"], ["proof (prove)\nusing this:\n  \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F =\n  \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet> F\n  \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet> F =\n  \\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet>\n                         \\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet> F\n  \\<lparr>\\<nu>y'\\<rparr>[(y, y')] \\<bullet>\n                         \\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet> F =\n  \\<lparr>\\<nu>y'\\<rparr>\\<lparr>\\<nu>x'\\<rparr>[(y, y')] \\<bullet>\n          [(x, x')] \\<bullet> F\n  \\<lparr>\\<nu>y'\\<rparr>\\<lparr>\\<nu>x'\\<rparr>[(y, y')] \\<bullet>\n          [(x, x')] \\<bullet> F =\n  \\<lparr>\\<nu>y'\\<rparr>\\<lparr>\\<nu>x'\\<rparr>[(x, x')] \\<bullet>\n          [(y, y')] \\<bullet> F\n  F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\n  x \\<sharp> A\\<^sub>F\n  x' \\<sharp> A\\<^sub>F\n  y \\<sharp> A\\<^sub>F\n  y' \\<sharp> A\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F =\n    \\<lparr>\\<nu>y'\\<rparr>\\<lparr>\\<nu>x'\\<rparr>\\<langle>A\\<^sub>F, [(x,\n                                  x')] \\<bullet>\n                                [(y, y')] \\<bullet> \\<Psi>\\<^sub>F\\<rangle>", "by(simp add: eqvts)"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F =\n  \\<lparr>\\<nu>y'\\<rparr>\\<lparr>\\<nu>x'\\<rparr>\\<langle>A\\<^sub>F, [(x,\n                                x')] \\<bullet>\n                              [(y, y')] \\<bullet> \\<Psi>\\<^sub>F\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi>", "from \\<open>x' \\<sharp> \\<phi>\\<close> \\<open>y' \\<sharp> \\<phi>\\<close> \\<open>A\\<^sub>F \\<sharp>* \\<phi>\\<close>"], ["proof (chain)\npicking this:\n  x' \\<sharp> \\<phi>\n  y' \\<sharp> \\<phi>\n  A\\<^sub>F \\<sharp>* \\<phi>", "have \"\\<langle>(x'#y'#A\\<^sub>F), [(x, x')] \\<bullet> [(y, y')] \\<bullet> \\<Psi>\\<^sub>F\\<rangle> \\<turnstile>\\<^sub>F \\<phi> = \\<langle>(y'#x'#A\\<^sub>F), [(x, x')] \\<bullet> [(y, y')] \\<bullet> \\<Psi>\\<^sub>F\\<rangle> \\<turnstile>\\<^sub>F \\<phi>\""], ["proof (prove)\nusing this:\n  x' \\<sharp> \\<phi>\n  y' \\<sharp> \\<phi>\n  A\\<^sub>F \\<sharp>* \\<phi>\n\ngoal (1 subgoal):\n 1. \\<langle>(x' #\n              y' #\n              A\\<^sub>F), [(x, x')] \\<bullet>\n                          [(y, y')] \\<bullet>\n                          \\<Psi>\\<^sub>F\\<rangle> \\<turnstile>\\<^sub>F\n    \\<phi> =\n    \\<langle>(y' #\n              x' #\n              A\\<^sub>F), [(x, x')] \\<bullet>\n                          [(y, y')] \\<bullet>\n                          \\<Psi>\\<^sub>F\\<rangle> \\<turnstile>\\<^sub>F\n    \\<phi>", "by(force dest: frameImpE intro: frameImpI simp del: frameResChain.simps)"], ["proof (state)\nthis:\n  \\<langle>(x' #\n            y' #\n            A\\<^sub>F), [(x, x')] \\<bullet>\n                        [(y, y')] \\<bullet>\n                        \\<Psi>\\<^sub>F\\<rangle> \\<turnstile>\\<^sub>F\n  \\<phi> =\n  \\<langle>(y' #\n            x' #\n            A\\<^sub>F), [(x, x')] \\<bullet>\n                        [(y, y')] \\<bullet>\n                        \\<Psi>\\<^sub>F\\<rangle> \\<turnstile>\\<^sub>F\n  \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi>", "with A B"], ["proof (chain)\npicking this:\n  \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F =\n  \\<lparr>\\<nu>x'\\<rparr>\\<lparr>\\<nu>y'\\<rparr>\\<langle>A\\<^sub>F, [(x,\n                                x')] \\<bullet>\n                              [(y, y')] \\<bullet> \\<Psi>\\<^sub>F\\<rangle>\n  \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F =\n  \\<lparr>\\<nu>y'\\<rparr>\\<lparr>\\<nu>x'\\<rparr>\\<langle>A\\<^sub>F, [(x,\n                                x')] \\<bullet>\n                              [(y, y')] \\<bullet> \\<Psi>\\<^sub>F\\<rangle>\n  \\<langle>(x' #\n            y' #\n            A\\<^sub>F), [(x, x')] \\<bullet>\n                        [(y, y')] \\<bullet>\n                        \\<Psi>\\<^sub>F\\<rangle> \\<turnstile>\\<^sub>F\n  \\<phi> =\n  \\<langle>(y' #\n            x' #\n            A\\<^sub>F), [(x, x')] \\<bullet>\n                        [(y, y')] \\<bullet>\n                        \\<Psi>\\<^sub>F\\<rangle> \\<turnstile>\\<^sub>F\n  \\<phi>", "have \"(\\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>F)) \\<turnstile>\\<^sub>F \\<phi> = (\\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>F)) \\<turnstile>\\<^sub>F \\<phi>\""], ["proof (prove)\nusing this:\n  \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F =\n  \\<lparr>\\<nu>x'\\<rparr>\\<lparr>\\<nu>y'\\<rparr>\\<langle>A\\<^sub>F, [(x,\n                                x')] \\<bullet>\n                              [(y, y')] \\<bullet> \\<Psi>\\<^sub>F\\<rangle>\n  \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F =\n  \\<lparr>\\<nu>y'\\<rparr>\\<lparr>\\<nu>x'\\<rparr>\\<langle>A\\<^sub>F, [(x,\n                                x')] \\<bullet>\n                              [(y, y')] \\<bullet> \\<Psi>\\<^sub>F\\<rangle>\n  \\<langle>(x' #\n            y' #\n            A\\<^sub>F), [(x, x')] \\<bullet>\n                        [(y, y')] \\<bullet>\n                        \\<Psi>\\<^sub>F\\<rangle> \\<turnstile>\\<^sub>F\n  \\<phi> =\n  \\<langle>(y' #\n            x' #\n            A\\<^sub>F), [(x, x')] \\<bullet>\n                        [(y, y')] \\<bullet>\n                        \\<Psi>\\<^sub>F\\<rangle> \\<turnstile>\\<^sub>F\n  \\<phi>\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<turnstile>\\<^sub>F\n    \\<phi> =\n    \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F\n    \\<phi>", "by simp"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<turnstile>\\<^sub>F\n  \\<phi> =\n  \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi>", "moreover"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<turnstile>\\<^sub>F\n  \\<phi> =\n  \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi>", "assume \"(\\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>F)) \\<turnstile>\\<^sub>F \\<phi>\""], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<turnstile>\\<^sub>F \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi> \\<Longrightarrow>\n       \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F\n       \\<phi>", "ultimately"], ["proof (chain)\npicking this:\n  \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<turnstile>\\<^sub>F\n  \\<phi> =\n  \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi>\n  \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<turnstile>\\<^sub>F \\<phi>", "show \"(\\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>F)) \\<turnstile>\\<^sub>F \\<phi>\""], ["proof (prove)\nusing this:\n  \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<turnstile>\\<^sub>F\n  \\<phi> =\n  \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi>\n  \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<turnstile>\\<^sub>F \\<phi>\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F\n    \\<phi>", "by simp"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F \\<turnstile>\\<^sub>F \\<phi>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<hookrightarrow>\\<^sub>F\n  \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma frameResComm:\n  fixes x :: name\n  and   y :: name\n  and   F :: \"'b frame\"\n\n  shows \"\\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>y\\<rparr>F) \\<simeq>\\<^sub>F \\<lparr>\\<nu>y\\<rparr>(\\<lparr>\\<nu>x\\<rparr>F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>y\\<rparr>F \\<simeq>\\<^sub>F\n    \\<lparr>\\<nu>y\\<rparr>\\<lparr>\\<nu>x\\<rparr>F", "by(auto simp add: FrameStatEq_def intro: frameImpResComm)"], ["", "lemma frameImpResCommLeft':\n  fixes x    :: name\n  and   xvec :: \"name list\"\n  and   F    :: \"'b frame\"\n\n  shows \"\\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>*xvec\\<rparr>F) \\<hookrightarrow>\\<^sub>F \\<lparr>\\<nu>*xvec\\<rparr>(\\<lparr>\\<nu>x\\<rparr>F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>*xvec\\<rparr>F \\<hookrightarrow>\\<^sub>F\n    \\<lparr>\\<nu>*xvec\\<rparr>\\<lparr>\\<nu>x\\<rparr>F", "by(induct xvec) (auto intro: frameImpResComm FrameStatImpTrans frameImpResPres)"], ["", "lemma frameImpResCommRight':\n  fixes x    :: name\n  and   xvec :: \"name list\"\n  and   F    :: \"'b frame\"\n\n  shows \"\\<lparr>\\<nu>*xvec\\<rparr>(\\<lparr>\\<nu>x\\<rparr>F) \\<hookrightarrow>\\<^sub>F \\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>*xvec\\<rparr>F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>*xvec\\<rparr>\\<lparr>\\<nu>x\\<rparr>F \\<hookrightarrow>\\<^sub>F\n    \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>*xvec\\<rparr>F", "by(induct xvec) (auto intro: frameImpResComm FrameStatImpTrans frameImpResPres)"], ["", "lemma frameResComm':\n  fixes x    :: name\n  and   xvec :: \"name list\"\n  and   F    :: \"'b frame\"\n\n  shows \"\\<lparr>\\<nu>x\\<rparr>(\\<lparr>\\<nu>*xvec\\<rparr>F) \\<simeq>\\<^sub>F \\<lparr>\\<nu>*xvec\\<rparr>(\\<lparr>\\<nu>x\\<rparr>F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>\\<lparr>\\<nu>*xvec\\<rparr>F \\<simeq>\\<^sub>F\n    \\<lparr>\\<nu>*xvec\\<rparr>\\<lparr>\\<nu>x\\<rparr>F", "by(induct xvec) (auto intro: frameResComm FrameStatEqTrans frameResPres)"], ["", "lemma frameImpChainComm:\n  fixes xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   F    :: \"'b frame\"\n\n  shows \"\\<lparr>\\<nu>*xvec\\<rparr>(\\<lparr>\\<nu>*yvec\\<rparr>F) \\<hookrightarrow>\\<^sub>F \\<lparr>\\<nu>*yvec\\<rparr>(\\<lparr>\\<nu>*xvec\\<rparr>F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>*xvec\\<rparr>\\<lparr>\\<nu>*yvec\\<rparr>F \\<hookrightarrow>\\<^sub>F\n    \\<lparr>\\<nu>*yvec\\<rparr>\\<lparr>\\<nu>*xvec\\<rparr>F", "by(induct xvec) (auto intro: frameImpResCommLeft' FrameStatImpTrans frameImpResPres)"], ["", "lemma frameResChainComm:\n  fixes xvec :: \"name list\"\n  and   yvec :: \"name list\"\n  and   F    :: \"'b frame\"\n\n  shows \"\\<lparr>\\<nu>*xvec\\<rparr>(\\<lparr>\\<nu>*yvec\\<rparr>F) \\<simeq>\\<^sub>F \\<lparr>\\<nu>*yvec\\<rparr>(\\<lparr>\\<nu>*xvec\\<rparr>F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>*xvec\\<rparr>\\<lparr>\\<nu>*yvec\\<rparr>F \\<simeq>\\<^sub>F\n    \\<lparr>\\<nu>*yvec\\<rparr>\\<lparr>\\<nu>*xvec\\<rparr>F", "by(induct xvec) (auto intro: frameResComm' FrameStatEqTrans frameResPres)"], ["", "lemma frameImpNilStatEq[simp]:\n  fixes \\<Psi>  :: 'b\n  and   \\<Psi>' :: 'b\n\n  shows \"(\\<langle>\\<epsilon>, \\<Psi>\\<rangle> \\<hookrightarrow>\\<^sub>F \\<langle>\\<epsilon>, \\<Psi>'\\<rangle>) = (\\<Psi> \\<hookrightarrow> \\<Psi>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<epsilon>, \\<Psi>\\<rangle> \\<hookrightarrow>\\<^sub>F\n    \\<langle>\\<epsilon>, \\<Psi>'\\<rangle> =\n    \\<Psi> \\<hookrightarrow> \\<Psi>'", "by(simp add: FrameStatImp_def AssertionStatImp_def FrameImp_def)"], ["", "lemma frameNilStatEq[simp]:\n  fixes \\<Psi>  :: 'b\n  and   \\<Psi>' :: 'b\n\n  shows \"(\\<langle>\\<epsilon>, \\<Psi>\\<rangle> \\<simeq>\\<^sub>F \\<langle>\\<epsilon>, \\<Psi>'\\<rangle>) = (\\<Psi> \\<simeq> \\<Psi>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<epsilon>, \\<Psi>\\<rangle> \\<simeq>\\<^sub>F\n    \\<langle>\\<epsilon>, \\<Psi>'\\<rangle> =\n    \\<Psi> \\<simeq> \\<Psi>'", "by(simp add: FrameStatEq_def AssertionStatEq_def FrameImp_def)"], ["", "lemma extractFrameChainStatImp:\n  fixes xvec :: \"name list\"\n  and   P    :: \"('a, 'b, 'c) psi\"\n\n  shows \"extractFrame(\\<lparr>\\<nu>*xvec\\<rparr>P) \\<hookrightarrow>\\<^sub>F \\<lparr>\\<nu>*xvec\\<rparr>(extractFrame P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extractFrame (\\<lparr>\\<nu>*xvec\\<rparr>P) \\<hookrightarrow>\\<^sub>F\n    \\<lparr>\\<nu>*xvec\\<rparr>extractFrame P", "by(induct xvec) (auto intro: frameImpResPres)"], ["", "lemma extractFrameChainStatEq:\n  fixes xvec :: \"name list\"\n  and   P    :: \"('a, 'b, 'c) psi\"\n\n  shows \"extractFrame(\\<lparr>\\<nu>*xvec\\<rparr>P) \\<simeq>\\<^sub>F \\<lparr>\\<nu>*xvec\\<rparr>(extractFrame P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extractFrame (\\<lparr>\\<nu>*xvec\\<rparr>P) \\<simeq>\\<^sub>F\n    \\<lparr>\\<nu>*xvec\\<rparr>extractFrame P", "by(induct xvec) (auto intro: frameResPres)"], ["", "lemma insertAssertionExtractFrameFreshImp:\n  fixes xvec :: \"name list\"\n  and   \\<Psi>   :: 'b\n  and   P    :: \"('a, 'b, 'c) psi\"\n\n  assumes \"xvec \\<sharp>* \\<Psi>\"\n\n  shows \"insertAssertion(extractFrame(\\<lparr>\\<nu>*xvec\\<rparr>P)) \\<Psi> \\<hookrightarrow>\\<^sub>F \\<lparr>\\<nu>*xvec\\<rparr>(insertAssertion (extractFrame P) \\<Psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertAssertion (extractFrame (\\<lparr>\\<nu>*xvec\\<rparr>P))\n     \\<Psi> \\<hookrightarrow>\\<^sub>F\n    \\<lparr>\\<nu>*xvec\\<rparr>insertAssertion (extractFrame P) \\<Psi>", "using assms"], ["proof (prove)\nusing this:\n  xvec \\<sharp>* \\<Psi>\n\ngoal (1 subgoal):\n 1. insertAssertion (extractFrame (\\<lparr>\\<nu>*xvec\\<rparr>P))\n     \\<Psi> \\<hookrightarrow>\\<^sub>F\n    \\<lparr>\\<nu>*xvec\\<rparr>insertAssertion (extractFrame P) \\<Psi>", "by(induct xvec) (auto intro: frameImpResPres)"], ["", "lemma insertAssertionExtractFrameFresh:\n  fixes xvec :: \"name list\"\n  and   \\<Psi>   :: 'b\n  and   P    :: \"('a, 'b, 'c) psi\"\n\n  assumes \"xvec \\<sharp>* \\<Psi>\"\n\n  shows \"insertAssertion(extractFrame(\\<lparr>\\<nu>*xvec\\<rparr>P)) \\<Psi> \\<simeq>\\<^sub>F \\<lparr>\\<nu>*xvec\\<rparr>(insertAssertion (extractFrame P) \\<Psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertAssertion (extractFrame (\\<lparr>\\<nu>*xvec\\<rparr>P))\n     \\<Psi> \\<simeq>\\<^sub>F\n    \\<lparr>\\<nu>*xvec\\<rparr>insertAssertion (extractFrame P) \\<Psi>", "using assms"], ["proof (prove)\nusing this:\n  xvec \\<sharp>* \\<Psi>\n\ngoal (1 subgoal):\n 1. insertAssertion (extractFrame (\\<lparr>\\<nu>*xvec\\<rparr>P))\n     \\<Psi> \\<simeq>\\<^sub>F\n    \\<lparr>\\<nu>*xvec\\<rparr>insertAssertion (extractFrame P) \\<Psi>", "by(induct xvec) (auto intro: frameResPres)"], ["", "lemma frameImpResChainPres:\n  fixes F    :: \"'b frame\"\n  and   G    :: \"'b frame\"\n  and   xvec :: \"name list\"\n\n  assumes \"F \\<hookrightarrow>\\<^sub>F G\"\n\n  shows \"\\<lparr>\\<nu>*xvec\\<rparr>F \\<hookrightarrow>\\<^sub>F \\<lparr>\\<nu>*xvec\\<rparr>G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>*xvec\\<rparr>F \\<hookrightarrow>\\<^sub>F\n    \\<lparr>\\<nu>*xvec\\<rparr>G", "using assms"], ["proof (prove)\nusing this:\n  F \\<hookrightarrow>\\<^sub>F G\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>*xvec\\<rparr>F \\<hookrightarrow>\\<^sub>F\n    \\<lparr>\\<nu>*xvec\\<rparr>G", "by(induct xvec) (auto intro: frameImpResPres)"], ["", "lemma frameResChainPres:\n  fixes F    :: \"'b frame\"\n  and   G    :: \"'b frame\"\n  and   xvec :: \"name list\"\n\n  assumes \"F \\<simeq>\\<^sub>F G\"\n\n  shows \"\\<lparr>\\<nu>*xvec\\<rparr>F \\<simeq>\\<^sub>F \\<lparr>\\<nu>*xvec\\<rparr>G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>*xvec\\<rparr>F \\<simeq>\\<^sub>F \\<lparr>\\<nu>*xvec\\<rparr>G", "using assms"], ["proof (prove)\nusing this:\n  F \\<simeq>\\<^sub>F G\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>*xvec\\<rparr>F \\<simeq>\\<^sub>F \\<lparr>\\<nu>*xvec\\<rparr>G", "by(induct xvec) (auto intro: frameResPres)"], ["", "lemma insertAssertionE:\n  fixes F  :: \"('b::fs_name) frame\"\n  and   \\<Psi>  :: 'b\n  and   \\<Psi>' :: 'b\n  and   A\\<^sub>F :: \"name list\"\n\n  assumes \"insertAssertion F \\<Psi> = \\<langle>A\\<^sub>F, \\<Psi>'\\<rangle>\"\n  and     \"A\\<^sub>F \\<sharp>* F\"\n  and     \"A\\<^sub>F \\<sharp>* \\<Psi>\"\n  and     \"distinct A\\<^sub>F\"\n\n  obtains \\<Psi>\\<^sub>F where \"F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\" and \"\\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<Psi>\\<^sub>F.\n        \\<lbrakk>F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>;\n         \\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>\\<Psi>\\<^sub>F.\n        \\<lbrakk>F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>;\n         \\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "assume A: \"\\<And>\\<Psi>\\<^sub>F. \\<lbrakk>F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>; \\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F\\<rbrakk> \\<Longrightarrow> thesis\""], ["proof (state)\nthis:\n  \\<lbrakk>F = \\<langle>A\\<^sub>F, ?\\<Psi>\\<^sub>F\\<rangle>;\n   \\<Psi>' = \\<Psi> \\<otimes> ?\\<Psi>\\<^sub>F\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Psi>\\<^sub>F.\n        \\<lbrakk>F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>;\n         \\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  insertAssertion F \\<Psi> = \\<langle>A\\<^sub>F, \\<Psi>'\\<rangle>\n  A\\<^sub>F \\<sharp>* F\n  A\\<^sub>F \\<sharp>* \\<Psi>\n  distinct A\\<^sub>F", "have \"\\<exists>\\<Psi>\\<^sub>F. F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and> \\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F\""], ["proof (prove)\nusing this:\n  insertAssertion F \\<Psi> = \\<langle>A\\<^sub>F, \\<Psi>'\\<rangle>\n  A\\<^sub>F \\<sharp>* F\n  A\\<^sub>F \\<sharp>* \\<Psi>\n  distinct A\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Psi>\\<^sub>F.\n       F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       \\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F", "proof(nominal_induct F avoiding: \\<Psi> A\\<^sub>F \\<Psi>' rule: frame.strong_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>assertion \\<Psi> A\\<^sub>F \\<Psi>'.\n       \\<lbrakk>insertAssertion (\\<langle>\\<epsilon>, assertion\\<rangle>)\n                 \\<Psi> =\n                \\<langle>A\\<^sub>F, \\<Psi>'\\<rangle>;\n        A\\<^sub>F \\<sharp>* (\\<langle>\\<epsilon>, assertion\\<rangle>);\n        A\\<^sub>F \\<sharp>* \\<Psi>; distinct A\\<^sub>F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                            \\<langle>\\<epsilon>, assertion\\<rangle> =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            \\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F\n 2. \\<And>name frame \\<Psi> A\\<^sub>F \\<Psi>'.\n       \\<lbrakk>name \\<sharp> \\<Psi>; name \\<sharp> A\\<^sub>F;\n        name \\<sharp> \\<Psi>';\n        \\<And>b ba bb.\n           \\<lbrakk>insertAssertion frame b = \\<langle>ba, bb\\<rangle>;\n            ba \\<sharp>* frame; ba \\<sharp>* b; distinct ba\\<rbrakk>\n           \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                                frame =\n                                \\<langle>ba, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                bb = b \\<otimes> \\<Psi>\\<^sub>F;\n        insertAssertion (\\<lparr>\\<nu>name\\<rparr>frame) \\<Psi> =\n        \\<langle>A\\<^sub>F, \\<Psi>'\\<rangle>;\n        A\\<^sub>F \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F \\<sharp>* \\<Psi>; distinct A\\<^sub>F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            \\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F", "case(FAssert \\<Psi> A\\<^sub>F \\<Psi>')"], ["proof (state)\nthis:\n  insertAssertion (\\<langle>\\<epsilon>, \\<Psi>\\<rangle>) A\\<^sub>F =\n  \\<langle>\\<Psi>'''__, \\<Psi>'\\<rangle>\n  \\<Psi>'''__ \\<sharp>* (\\<langle>\\<epsilon>, \\<Psi>\\<rangle>)\n  \\<Psi>'''__ \\<sharp>* A\\<^sub>F\n  distinct \\<Psi>'''__\n\ngoal (2 subgoals):\n 1. \\<And>assertion \\<Psi> A\\<^sub>F \\<Psi>'.\n       \\<lbrakk>insertAssertion (\\<langle>\\<epsilon>, assertion\\<rangle>)\n                 \\<Psi> =\n                \\<langle>A\\<^sub>F, \\<Psi>'\\<rangle>;\n        A\\<^sub>F \\<sharp>* (\\<langle>\\<epsilon>, assertion\\<rangle>);\n        A\\<^sub>F \\<sharp>* \\<Psi>; distinct A\\<^sub>F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                            \\<langle>\\<epsilon>, assertion\\<rangle> =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            \\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F\n 2. \\<And>name frame \\<Psi> A\\<^sub>F \\<Psi>'.\n       \\<lbrakk>name \\<sharp> \\<Psi>; name \\<sharp> A\\<^sub>F;\n        name \\<sharp> \\<Psi>';\n        \\<And>b ba bb.\n           \\<lbrakk>insertAssertion frame b = \\<langle>ba, bb\\<rangle>;\n            ba \\<sharp>* frame; ba \\<sharp>* b; distinct ba\\<rbrakk>\n           \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                                frame =\n                                \\<langle>ba, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                bb = b \\<otimes> \\<Psi>\\<^sub>F;\n        insertAssertion (\\<lparr>\\<nu>name\\<rparr>frame) \\<Psi> =\n        \\<langle>A\\<^sub>F, \\<Psi>'\\<rangle>;\n        A\\<^sub>F \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F \\<sharp>* \\<Psi>; distinct A\\<^sub>F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            \\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F", "thus ?case"], ["proof (prove)\nusing this:\n  insertAssertion (\\<langle>\\<epsilon>, \\<Psi>\\<rangle>) A\\<^sub>F =\n  \\<langle>\\<Psi>'''__, \\<Psi>'\\<rangle>\n  \\<Psi>'''__ \\<sharp>* (\\<langle>\\<epsilon>, \\<Psi>\\<rangle>)\n  \\<Psi>'''__ \\<sharp>* A\\<^sub>F\n  distinct \\<Psi>'''__\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Psi>\\<^sub>F.\n       \\<langle>\\<epsilon>, \\<Psi>\\<rangle> =\n       \\<langle>\\<Psi>'''__, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       \\<Psi>' = A\\<^sub>F \\<otimes> \\<Psi>\\<^sub>F", "by auto"], ["proof (state)\nthis:\n  \\<exists>\\<Psi>\\<^sub>F.\n     \\<langle>\\<epsilon>, \\<Psi>\\<rangle> =\n     \\<langle>\\<Psi>'''__, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n     \\<Psi>' = A\\<^sub>F \\<otimes> \\<Psi>\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<And>name frame \\<Psi> A\\<^sub>F \\<Psi>'.\n       \\<lbrakk>name \\<sharp> \\<Psi>; name \\<sharp> A\\<^sub>F;\n        name \\<sharp> \\<Psi>';\n        \\<And>b ba bb.\n           \\<lbrakk>insertAssertion frame b = \\<langle>ba, bb\\<rangle>;\n            ba \\<sharp>* frame; ba \\<sharp>* b; distinct ba\\<rbrakk>\n           \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                                frame =\n                                \\<langle>ba, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                bb = b \\<otimes> \\<Psi>\\<^sub>F;\n        insertAssertion (\\<lparr>\\<nu>name\\<rparr>frame) \\<Psi> =\n        \\<langle>A\\<^sub>F, \\<Psi>'\\<rangle>;\n        A\\<^sub>F \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F \\<sharp>* \\<Psi>; distinct A\\<^sub>F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            \\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>name frame \\<Psi> A\\<^sub>F \\<Psi>'.\n       \\<lbrakk>name \\<sharp> \\<Psi>; name \\<sharp> A\\<^sub>F;\n        name \\<sharp> \\<Psi>';\n        \\<And>b ba bb.\n           \\<lbrakk>insertAssertion frame b = \\<langle>ba, bb\\<rangle>;\n            ba \\<sharp>* frame; ba \\<sharp>* b; distinct ba\\<rbrakk>\n           \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                                frame =\n                                \\<langle>ba, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                bb = b \\<otimes> \\<Psi>\\<^sub>F;\n        insertAssertion (\\<lparr>\\<nu>name\\<rparr>frame) \\<Psi> =\n        \\<langle>A\\<^sub>F, \\<Psi>'\\<rangle>;\n        A\\<^sub>F \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F \\<sharp>* \\<Psi>; distinct A\\<^sub>F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            \\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F", "case(FRes x F \\<Psi> A\\<^sub>F \\<Psi>')"], ["proof (state)\nthis:\n  x \\<sharp> \\<Psi>\n  x \\<sharp> A\\<^sub>F\n  x \\<sharp> \\<Psi>'\n  \\<lbrakk>insertAssertion F ?b = \\<langle>?ba, ?bb\\<rangle>;\n   ?ba \\<sharp>* F; ?ba \\<sharp>* ?b; distinct ?ba\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                       F = \\<langle>?ba, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                       ?bb = ?b \\<otimes> \\<Psi>\\<^sub>F\n  insertAssertion (\\<lparr>\\<nu>x\\<rparr>F) \\<Psi> =\n  \\<langle>A\\<^sub>F, \\<Psi>'\\<rangle>\n  A\\<^sub>F \\<sharp>* (\\<lparr>\\<nu>x\\<rparr>F)\n  A\\<^sub>F \\<sharp>* \\<Psi>\n  distinct A\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<And>name frame \\<Psi> A\\<^sub>F \\<Psi>'.\n       \\<lbrakk>name \\<sharp> \\<Psi>; name \\<sharp> A\\<^sub>F;\n        name \\<sharp> \\<Psi>';\n        \\<And>b ba bb.\n           \\<lbrakk>insertAssertion frame b = \\<langle>ba, bb\\<rangle>;\n            ba \\<sharp>* frame; ba \\<sharp>* b; distinct ba\\<rbrakk>\n           \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                                frame =\n                                \\<langle>ba, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                bb = b \\<otimes> \\<Psi>\\<^sub>F;\n        insertAssertion (\\<lparr>\\<nu>name\\<rparr>frame) \\<Psi> =\n        \\<langle>A\\<^sub>F, \\<Psi>'\\<rangle>;\n        A\\<^sub>F \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F \\<sharp>* \\<Psi>; distinct A\\<^sub>F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            \\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F", "from \\<open>insertAssertion (\\<lparr>\\<nu>x\\<rparr>F) \\<Psi> = \\<langle>A\\<^sub>F, \\<Psi>'\\<rangle>\\<close> \\<open>x \\<sharp> \\<Psi>\\<close>"], ["proof (chain)\npicking this:\n  insertAssertion (\\<lparr>\\<nu>x\\<rparr>F) \\<Psi> =\n  \\<langle>A\\<^sub>F, \\<Psi>'\\<rangle>\n  x \\<sharp> \\<Psi>", "obtain y A\\<^sub>F' where \"A\\<^sub>F = y#A\\<^sub>F'\""], ["proof (prove)\nusing this:\n  insertAssertion (\\<lparr>\\<nu>x\\<rparr>F) \\<Psi> =\n  \\<langle>A\\<^sub>F, \\<Psi>'\\<rangle>\n  x \\<sharp> \\<Psi>\n\ngoal (1 subgoal):\n 1. (\\<And>y A\\<^sub>F''.\n        A\\<^sub>F = y # A\\<^sub>F'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(induct A\\<^sub>F) auto"], ["proof (state)\nthis:\n  A\\<^sub>F = y # A\\<^sub>F'\n\ngoal (1 subgoal):\n 1. \\<And>name frame \\<Psi> A\\<^sub>F \\<Psi>'.\n       \\<lbrakk>name \\<sharp> \\<Psi>; name \\<sharp> A\\<^sub>F;\n        name \\<sharp> \\<Psi>';\n        \\<And>b ba bb.\n           \\<lbrakk>insertAssertion frame b = \\<langle>ba, bb\\<rangle>;\n            ba \\<sharp>* frame; ba \\<sharp>* b; distinct ba\\<rbrakk>\n           \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                                frame =\n                                \\<langle>ba, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                bb = b \\<otimes> \\<Psi>\\<^sub>F;\n        insertAssertion (\\<lparr>\\<nu>name\\<rparr>frame) \\<Psi> =\n        \\<langle>A\\<^sub>F, \\<Psi>'\\<rangle>;\n        A\\<^sub>F \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F \\<sharp>* \\<Psi>; distinct A\\<^sub>F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            \\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F", "with \\<open>insertAssertion (\\<lparr>\\<nu>x\\<rparr>F) \\<Psi> = \\<langle>A\\<^sub>F, \\<Psi>'\\<rangle>\\<close> \\<open>x \\<sharp> \\<Psi>\\<close> \\<open>x \\<sharp> A\\<^sub>F\\<close>"], ["proof (chain)\npicking this:\n  insertAssertion (\\<lparr>\\<nu>x\\<rparr>F) \\<Psi> =\n  \\<langle>A\\<^sub>F, \\<Psi>'\\<rangle>\n  x \\<sharp> \\<Psi>\n  x \\<sharp> A\\<^sub>F\n  A\\<^sub>F = y # A\\<^sub>F'", "have A: \"insertAssertion F \\<Psi> = \\<langle>([(x, y)] \\<bullet> A\\<^sub>F'), [(x, y)] \\<bullet> \\<Psi>'\\<rangle>\""], ["proof (prove)\nusing this:\n  insertAssertion (\\<lparr>\\<nu>x\\<rparr>F) \\<Psi> =\n  \\<langle>A\\<^sub>F, \\<Psi>'\\<rangle>\n  x \\<sharp> \\<Psi>\n  x \\<sharp> A\\<^sub>F\n  A\\<^sub>F = y # A\\<^sub>F'\n\ngoal (1 subgoal):\n 1. insertAssertion F \\<Psi> =\n    \\<langle>[(x, y)] \\<bullet>\n             A\\<^sub>F', [(x, y)] \\<bullet> \\<Psi>'\\<rangle>", "by(simp add: frame.inject alpha eqvts)"], ["proof (state)\nthis:\n  insertAssertion F \\<Psi> =\n  \\<langle>[(x, y)] \\<bullet>\n           A\\<^sub>F', [(x, y)] \\<bullet> \\<Psi>'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>name frame \\<Psi> A\\<^sub>F \\<Psi>'.\n       \\<lbrakk>name \\<sharp> \\<Psi>; name \\<sharp> A\\<^sub>F;\n        name \\<sharp> \\<Psi>';\n        \\<And>b ba bb.\n           \\<lbrakk>insertAssertion frame b = \\<langle>ba, bb\\<rangle>;\n            ba \\<sharp>* frame; ba \\<sharp>* b; distinct ba\\<rbrakk>\n           \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                                frame =\n                                \\<langle>ba, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                bb = b \\<otimes> \\<Psi>\\<^sub>F;\n        insertAssertion (\\<lparr>\\<nu>name\\<rparr>frame) \\<Psi> =\n        \\<langle>A\\<^sub>F, \\<Psi>'\\<rangle>;\n        A\\<^sub>F \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F \\<sharp>* \\<Psi>; distinct A\\<^sub>F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            \\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F", "from \\<open>A\\<^sub>F = y#A\\<^sub>F'\\<close> \\<open>A\\<^sub>F \\<sharp>* \\<Psi>\\<close>"], ["proof (chain)\npicking this:\n  A\\<^sub>F = y # A\\<^sub>F'\n  A\\<^sub>F \\<sharp>* \\<Psi>", "have \"y \\<sharp> \\<Psi>\" and \"A\\<^sub>F' \\<sharp>* \\<Psi>\""], ["proof (prove)\nusing this:\n  A\\<^sub>F = y # A\\<^sub>F'\n  A\\<^sub>F \\<sharp>* \\<Psi>\n\ngoal (1 subgoal):\n 1. y \\<sharp> \\<Psi> &&& A\\<^sub>F' \\<sharp>* \\<Psi>", "by simp+"], ["proof (state)\nthis:\n  y \\<sharp> \\<Psi>\n  A\\<^sub>F' \\<sharp>* \\<Psi>\n\ngoal (1 subgoal):\n 1. \\<And>name frame \\<Psi> A\\<^sub>F \\<Psi>'.\n       \\<lbrakk>name \\<sharp> \\<Psi>; name \\<sharp> A\\<^sub>F;\n        name \\<sharp> \\<Psi>';\n        \\<And>b ba bb.\n           \\<lbrakk>insertAssertion frame b = \\<langle>ba, bb\\<rangle>;\n            ba \\<sharp>* frame; ba \\<sharp>* b; distinct ba\\<rbrakk>\n           \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                                frame =\n                                \\<langle>ba, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                bb = b \\<otimes> \\<Psi>\\<^sub>F;\n        insertAssertion (\\<lparr>\\<nu>name\\<rparr>frame) \\<Psi> =\n        \\<langle>A\\<^sub>F, \\<Psi>'\\<rangle>;\n        A\\<^sub>F \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F \\<sharp>* \\<Psi>; distinct A\\<^sub>F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            \\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F", "from \\<open>distinct A\\<^sub>F\\<close> \\<open>A\\<^sub>F = y#A\\<^sub>F'\\<close>"], ["proof (chain)\npicking this:\n  distinct A\\<^sub>F\n  A\\<^sub>F = y # A\\<^sub>F'", "have \"y \\<sharp> A\\<^sub>F'\" and \"distinct A\\<^sub>F'\""], ["proof (prove)\nusing this:\n  distinct A\\<^sub>F\n  A\\<^sub>F = y # A\\<^sub>F'\n\ngoal (1 subgoal):\n 1. y \\<sharp> A\\<^sub>F' &&& distinct A\\<^sub>F'", "by auto"], ["proof (state)\nthis:\n  y \\<sharp> A\\<^sub>F'\n  distinct A\\<^sub>F'\n\ngoal (1 subgoal):\n 1. \\<And>name frame \\<Psi> A\\<^sub>F \\<Psi>'.\n       \\<lbrakk>name \\<sharp> \\<Psi>; name \\<sharp> A\\<^sub>F;\n        name \\<sharp> \\<Psi>';\n        \\<And>b ba bb.\n           \\<lbrakk>insertAssertion frame b = \\<langle>ba, bb\\<rangle>;\n            ba \\<sharp>* frame; ba \\<sharp>* b; distinct ba\\<rbrakk>\n           \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                                frame =\n                                \\<langle>ba, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                bb = b \\<otimes> \\<Psi>\\<^sub>F;\n        insertAssertion (\\<lparr>\\<nu>name\\<rparr>frame) \\<Psi> =\n        \\<langle>A\\<^sub>F, \\<Psi>'\\<rangle>;\n        A\\<^sub>F \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F \\<sharp>* \\<Psi>; distinct A\\<^sub>F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            \\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F", "from \\<open>A\\<^sub>F \\<sharp>* (\\<lparr>\\<nu>x\\<rparr>F)\\<close> \\<open>x \\<sharp> A\\<^sub>F\\<close> \\<open>A\\<^sub>F = y#A\\<^sub>F'\\<close>"], ["proof (chain)\npicking this:\n  A\\<^sub>F \\<sharp>* (\\<lparr>\\<nu>x\\<rparr>F)\n  x \\<sharp> A\\<^sub>F\n  A\\<^sub>F = y # A\\<^sub>F'", "have \"y \\<sharp> F\" and \"A\\<^sub>F' \\<sharp>* F\" and \"x \\<sharp> A\\<^sub>F'\""], ["proof (prove)\nusing this:\n  A\\<^sub>F \\<sharp>* (\\<lparr>\\<nu>x\\<rparr>F)\n  x \\<sharp> A\\<^sub>F\n  A\\<^sub>F = y # A\\<^sub>F'\n\ngoal (1 subgoal):\n 1. y \\<sharp> F &&& A\\<^sub>F' \\<sharp>* F &&& x \\<sharp> A\\<^sub>F'", "apply -"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>A\\<^sub>F \\<sharp>* (\\<lparr>\\<nu>x\\<rparr>F);\n     x \\<sharp> A\\<^sub>F; A\\<^sub>F = y # A\\<^sub>F'\\<rbrakk>\n    \\<Longrightarrow> y \\<sharp> F\n 2. \\<lbrakk>A\\<^sub>F \\<sharp>* (\\<lparr>\\<nu>x\\<rparr>F);\n     x \\<sharp> A\\<^sub>F; A\\<^sub>F = y # A\\<^sub>F'\\<rbrakk>\n    \\<Longrightarrow> A\\<^sub>F' \\<sharp>* F\n 3. \\<lbrakk>A\\<^sub>F \\<sharp>* (\\<lparr>\\<nu>x\\<rparr>F);\n     x \\<sharp> A\\<^sub>F; A\\<^sub>F = y # A\\<^sub>F'\\<rbrakk>\n    \\<Longrightarrow> x \\<sharp> A\\<^sub>F'", "apply(auto simp add: abs_fresh)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A\\<^sub>F = y # A\\<^sub>F';\n     A\\<^sub>F' \\<sharp>* (\\<lparr>\\<nu>x\\<rparr>F); x \\<noteq> y;\n     x \\<sharp> A\\<^sub>F'; y \\<sharp> F\\<rbrakk>\n    \\<Longrightarrow> A\\<^sub>F' \\<sharp>* F", "apply(hypsubst_thin)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A\\<^sub>F' \\<sharp>* (\\<lparr>\\<nu>x\\<rparr>F); x \\<noteq> y;\n     x \\<sharp> A\\<^sub>F'; y \\<sharp> F\\<rbrakk>\n    \\<Longrightarrow> A\\<^sub>F' \\<sharp>* F", "apply(subst fresh_star_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A\\<^sub>F' \\<sharp>* (\\<lparr>\\<nu>x\\<rparr>F); x \\<noteq> y;\n     x \\<sharp> A\\<^sub>F'; y \\<sharp> F\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set A\\<^sub>F'. x \\<sharp> F", "apply(erule rev_mp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; x \\<sharp> A\\<^sub>F'; y \\<sharp> F\\<rbrakk>\n    \\<Longrightarrow> A\\<^sub>F' \\<sharp>* (\\<lparr>\\<nu>x\\<rparr>F) \\<longrightarrow>\n                      (\\<forall>x\\<in>set A\\<^sub>F'. x \\<sharp> F)", "apply(subst fresh_star_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; x \\<sharp> A\\<^sub>F'; y \\<sharp> F\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>xa\\<in>set A\\<^sub>F'.\n                          xa \\<sharp> \\<lparr>\\<nu>x\\<rparr>F) \\<longrightarrow>\n                      (\\<forall>x\\<in>set A\\<^sub>F'. x \\<sharp> F)", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>x \\<noteq> y; x \\<sharp> A\\<^sub>F'; y \\<sharp> F;\n        \\<forall>xa\\<in>set A\\<^sub>F'. xa \\<sharp> \\<lparr>\\<nu>x\\<rparr>F;\n        xa mem A\\<^sub>F'\\<rbrakk>\n       \\<Longrightarrow> xa \\<sharp> F", "apply(erule_tac x=xa in ballE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>x \\<noteq> y; x \\<sharp> A\\<^sub>F'; y \\<sharp> F;\n        xa mem A\\<^sub>F'; xa \\<sharp> \\<lparr>\\<nu>x\\<rparr>F\\<rbrakk>\n       \\<Longrightarrow> xa \\<sharp> F\n 2. \\<And>xa.\n       \\<lbrakk>x \\<noteq> y; x \\<sharp> A\\<^sub>F'; y \\<sharp> F;\n        xa mem A\\<^sub>F'; xa \\<notin> set A\\<^sub>F'\\<rbrakk>\n       \\<Longrightarrow> xa \\<sharp> F", "apply(simp add: abs_fresh)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>x \\<noteq> y; x \\<sharp> A\\<^sub>F'; y \\<sharp> F;\n        xa mem A\\<^sub>F'; xa = x \\<or> xa \\<sharp> F\\<rbrakk>\n       \\<Longrightarrow> xa \\<sharp> F\n 2. \\<And>xa.\n       \\<lbrakk>x \\<noteq> y; x \\<sharp> A\\<^sub>F'; y \\<sharp> F;\n        xa mem A\\<^sub>F'; xa \\<notin> set A\\<^sub>F'\\<rbrakk>\n       \\<Longrightarrow> xa \\<sharp> F", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; x \\<sharp> A\\<^sub>F'; y \\<sharp> F;\n     x mem A\\<^sub>F'\\<rbrakk>\n    \\<Longrightarrow> x \\<sharp> F", "by(simp add: fresh_def name_list_supp)"], ["proof (state)\nthis:\n  y \\<sharp> F\n  A\\<^sub>F' \\<sharp>* F\n  x \\<sharp> A\\<^sub>F'\n\ngoal (1 subgoal):\n 1. \\<And>name frame \\<Psi> A\\<^sub>F \\<Psi>'.\n       \\<lbrakk>name \\<sharp> \\<Psi>; name \\<sharp> A\\<^sub>F;\n        name \\<sharp> \\<Psi>';\n        \\<And>b ba bb.\n           \\<lbrakk>insertAssertion frame b = \\<langle>ba, bb\\<rangle>;\n            ba \\<sharp>* frame; ba \\<sharp>* b; distinct ba\\<rbrakk>\n           \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                                frame =\n                                \\<langle>ba, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                bb = b \\<otimes> \\<Psi>\\<^sub>F;\n        insertAssertion (\\<lparr>\\<nu>name\\<rparr>frame) \\<Psi> =\n        \\<langle>A\\<^sub>F, \\<Psi>'\\<rangle>;\n        A\\<^sub>F \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F \\<sharp>* \\<Psi>; distinct A\\<^sub>F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            \\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F", "with \\<open>x \\<sharp> A\\<^sub>F'\\<close> \\<open>y \\<sharp> A\\<^sub>F'\\<close>"], ["proof (chain)\npicking this:\n  x \\<sharp> A\\<^sub>F'\n  y \\<sharp> A\\<^sub>F'\n  y \\<sharp> F\n  A\\<^sub>F' \\<sharp>* F\n  x \\<sharp> A\\<^sub>F'", "have \"([(x, y)] \\<bullet> A\\<^sub>F') \\<sharp>* F\""], ["proof (prove)\nusing this:\n  x \\<sharp> A\\<^sub>F'\n  y \\<sharp> A\\<^sub>F'\n  y \\<sharp> F\n  A\\<^sub>F' \\<sharp>* F\n  x \\<sharp> A\\<^sub>F'\n\ngoal (1 subgoal):\n 1. ([(x, y)] \\<bullet> A\\<^sub>F') \\<sharp>* F", "by simp"], ["proof (state)\nthis:\n  ([(x, y)] \\<bullet> A\\<^sub>F') \\<sharp>* F\n\ngoal (1 subgoal):\n 1. \\<And>name frame \\<Psi> A\\<^sub>F \\<Psi>'.\n       \\<lbrakk>name \\<sharp> \\<Psi>; name \\<sharp> A\\<^sub>F;\n        name \\<sharp> \\<Psi>';\n        \\<And>b ba bb.\n           \\<lbrakk>insertAssertion frame b = \\<langle>ba, bb\\<rangle>;\n            ba \\<sharp>* frame; ba \\<sharp>* b; distinct ba\\<rbrakk>\n           \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                                frame =\n                                \\<langle>ba, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                bb = b \\<otimes> \\<Psi>\\<^sub>F;\n        insertAssertion (\\<lparr>\\<nu>name\\<rparr>frame) \\<Psi> =\n        \\<langle>A\\<^sub>F, \\<Psi>'\\<rangle>;\n        A\\<^sub>F \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F \\<sharp>* \\<Psi>; distinct A\\<^sub>F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            \\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F", "from \\<open>A\\<^sub>F' \\<sharp>* \\<Psi>\\<close>"], ["proof (chain)\npicking this:\n  A\\<^sub>F' \\<sharp>* \\<Psi>", "have \"([(x, y)] \\<bullet> A\\<^sub>F') \\<sharp>* ([(x, y)] \\<bullet> \\<Psi>)\""], ["proof (prove)\nusing this:\n  A\\<^sub>F' \\<sharp>* \\<Psi>\n\ngoal (1 subgoal):\n 1. ([(x, y)] \\<bullet> A\\<^sub>F') \\<sharp>* ([(x, y)] \\<bullet> \\<Psi>)", "by(simp add: pt_fresh_star_bij[OF pt_name_inst, OF at_name_inst])"], ["proof (state)\nthis:\n  ([(x, y)] \\<bullet> A\\<^sub>F') \\<sharp>* ([(x, y)] \\<bullet> \\<Psi>)\n\ngoal (1 subgoal):\n 1. \\<And>name frame \\<Psi> A\\<^sub>F \\<Psi>'.\n       \\<lbrakk>name \\<sharp> \\<Psi>; name \\<sharp> A\\<^sub>F;\n        name \\<sharp> \\<Psi>';\n        \\<And>b ba bb.\n           \\<lbrakk>insertAssertion frame b = \\<langle>ba, bb\\<rangle>;\n            ba \\<sharp>* frame; ba \\<sharp>* b; distinct ba\\<rbrakk>\n           \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                                frame =\n                                \\<langle>ba, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                bb = b \\<otimes> \\<Psi>\\<^sub>F;\n        insertAssertion (\\<lparr>\\<nu>name\\<rparr>frame) \\<Psi> =\n        \\<langle>A\\<^sub>F, \\<Psi>'\\<rangle>;\n        A\\<^sub>F \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F \\<sharp>* \\<Psi>; distinct A\\<^sub>F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            \\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F", "with \\<open>x \\<sharp> \\<Psi>\\<close> \\<open>y \\<sharp> \\<Psi>\\<close>"], ["proof (chain)\npicking this:\n  x \\<sharp> \\<Psi>\n  y \\<sharp> \\<Psi>\n  ([(x, y)] \\<bullet> A\\<^sub>F') \\<sharp>* ([(x, y)] \\<bullet> \\<Psi>)", "have \"([(x, y)] \\<bullet> A\\<^sub>F') \\<sharp>* \\<Psi>\""], ["proof (prove)\nusing this:\n  x \\<sharp> \\<Psi>\n  y \\<sharp> \\<Psi>\n  ([(x, y)] \\<bullet> A\\<^sub>F') \\<sharp>* ([(x, y)] \\<bullet> \\<Psi>)\n\ngoal (1 subgoal):\n 1. ([(x, y)] \\<bullet> A\\<^sub>F') \\<sharp>* \\<Psi>", "by simp"], ["proof (state)\nthis:\n  ([(x, y)] \\<bullet> A\\<^sub>F') \\<sharp>* \\<Psi>\n\ngoal (1 subgoal):\n 1. \\<And>name frame \\<Psi> A\\<^sub>F \\<Psi>'.\n       \\<lbrakk>name \\<sharp> \\<Psi>; name \\<sharp> A\\<^sub>F;\n        name \\<sharp> \\<Psi>';\n        \\<And>b ba bb.\n           \\<lbrakk>insertAssertion frame b = \\<langle>ba, bb\\<rangle>;\n            ba \\<sharp>* frame; ba \\<sharp>* b; distinct ba\\<rbrakk>\n           \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                                frame =\n                                \\<langle>ba, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                bb = b \\<otimes> \\<Psi>\\<^sub>F;\n        insertAssertion (\\<lparr>\\<nu>name\\<rparr>frame) \\<Psi> =\n        \\<langle>A\\<^sub>F, \\<Psi>'\\<rangle>;\n        A\\<^sub>F \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F \\<sharp>* \\<Psi>; distinct A\\<^sub>F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            \\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F", "with \\<open>\\<And>\\<Psi> A\\<^sub>F \\<Psi>'. \\<lbrakk>insertAssertion F \\<Psi> = \\<langle>A\\<^sub>F, \\<Psi>'\\<rangle>; A\\<^sub>F \\<sharp>* F; A\\<^sub>F \\<sharp>* \\<Psi>; distinct A\\<^sub>F\\<rbrakk> \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F. F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and> \\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F\\<close> A \n         \\<open>([(x, y)] \\<bullet> A\\<^sub>F') \\<sharp>* F\\<close> \\<open>distinct A\\<^sub>F'\\<close> \\<open>x \\<sharp> A\\<^sub>F'\\<close> \\<open>y \\<sharp> A\\<^sub>F'\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>insertAssertion F ?\\<Psi> =\n           \\<langle>?A\\<^sub>F, ?\\<Psi>'\\<rangle>;\n   ?A\\<^sub>F \\<sharp>* F; ?A\\<^sub>F \\<sharp>* ?\\<Psi>;\n   distinct ?A\\<^sub>F\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                       F =\n                       \\<langle>?A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                       ?\\<Psi>' = ?\\<Psi> \\<otimes> \\<Psi>\\<^sub>F\n  insertAssertion F \\<Psi> =\n  \\<langle>[(x, y)] \\<bullet>\n           A\\<^sub>F', [(x, y)] \\<bullet> \\<Psi>'\\<rangle>\n  ([(x, y)] \\<bullet> A\\<^sub>F') \\<sharp>* F\n  distinct A\\<^sub>F'\n  x \\<sharp> A\\<^sub>F'\n  y \\<sharp> A\\<^sub>F'\n  ([(x, y)] \\<bullet> A\\<^sub>F') \\<sharp>* \\<Psi>", "obtain \\<Psi>\\<^sub>F where Feq: \"F = \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle>\" and \\<Psi>eq: \"([(x, y)] \\<bullet> \\<Psi>') = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F\""], ["proof (prove)\nusing this:\n  \\<lbrakk>insertAssertion F ?\\<Psi> =\n           \\<langle>?A\\<^sub>F, ?\\<Psi>'\\<rangle>;\n   ?A\\<^sub>F \\<sharp>* F; ?A\\<^sub>F \\<sharp>* ?\\<Psi>;\n   distinct ?A\\<^sub>F\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                       F =\n                       \\<langle>?A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                       ?\\<Psi>' = ?\\<Psi> \\<otimes> \\<Psi>\\<^sub>F\n  insertAssertion F \\<Psi> =\n  \\<langle>[(x, y)] \\<bullet>\n           A\\<^sub>F', [(x, y)] \\<bullet> \\<Psi>'\\<rangle>\n  ([(x, y)] \\<bullet> A\\<^sub>F') \\<sharp>* F\n  distinct A\\<^sub>F'\n  x \\<sharp> A\\<^sub>F'\n  y \\<sharp> A\\<^sub>F'\n  ([(x, y)] \\<bullet> A\\<^sub>F') \\<sharp>* \\<Psi>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Psi>\\<^sub>F.\n        \\<lbrakk>F = \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle>;\n         [(x, y)] \\<bullet> \\<Psi>' =\n         \\<Psi> \\<otimes> \\<Psi>\\<^sub>F\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  F = \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle>\n  [(x, y)] \\<bullet> \\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<And>name frame \\<Psi> A\\<^sub>F \\<Psi>'.\n       \\<lbrakk>name \\<sharp> \\<Psi>; name \\<sharp> A\\<^sub>F;\n        name \\<sharp> \\<Psi>';\n        \\<And>b ba bb.\n           \\<lbrakk>insertAssertion frame b = \\<langle>ba, bb\\<rangle>;\n            ba \\<sharp>* frame; ba \\<sharp>* b; distinct ba\\<rbrakk>\n           \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                                frame =\n                                \\<langle>ba, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                bb = b \\<otimes> \\<Psi>\\<^sub>F;\n        insertAssertion (\\<lparr>\\<nu>name\\<rparr>frame) \\<Psi> =\n        \\<langle>A\\<^sub>F, \\<Psi>'\\<rangle>;\n        A\\<^sub>F \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F \\<sharp>* \\<Psi>; distinct A\\<^sub>F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            \\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F", "from Feq"], ["proof (chain)\npicking this:\n  F = \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle>", "have \"\\<lparr>\\<nu>x\\<rparr>F =  \\<langle>(x#A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle>\""], ["proof (prove)\nusing this:\n  F = \\<langle>A\\<^sub>F', \\<Psi>\\<^sub>F\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>F =\n    \\<langle>(x # A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle>", "by(simp add: frame.inject)"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>F =\n  \\<langle>(x # A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>name frame \\<Psi> A\\<^sub>F \\<Psi>'.\n       \\<lbrakk>name \\<sharp> \\<Psi>; name \\<sharp> A\\<^sub>F;\n        name \\<sharp> \\<Psi>';\n        \\<And>b ba bb.\n           \\<lbrakk>insertAssertion frame b = \\<langle>ba, bb\\<rangle>;\n            ba \\<sharp>* frame; ba \\<sharp>* b; distinct ba\\<rbrakk>\n           \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                                frame =\n                                \\<langle>ba, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                bb = b \\<otimes> \\<Psi>\\<^sub>F;\n        insertAssertion (\\<lparr>\\<nu>name\\<rparr>frame) \\<Psi> =\n        \\<langle>A\\<^sub>F, \\<Psi>'\\<rangle>;\n        A\\<^sub>F \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F \\<sharp>* \\<Psi>; distinct A\\<^sub>F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            \\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F", "hence \"([(x, y)] \\<bullet> \\<lparr>\\<nu>x\\<rparr>F) = [(x, y)] \\<bullet> \\<langle>(x#A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle>\""], ["proof (prove)\nusing this:\n  \\<lparr>\\<nu>x\\<rparr>F =\n  \\<langle>(x # A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle>\n\ngoal (1 subgoal):\n 1. [(x, y)] \\<bullet> \\<lparr>\\<nu>x\\<rparr>F =\n    [(x, y)] \\<bullet> \\<langle>(x # A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle>", "by simp"], ["proof (state)\nthis:\n  [(x, y)] \\<bullet> \\<lparr>\\<nu>x\\<rparr>F =\n  [(x, y)] \\<bullet> \\<langle>(x # A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>name frame \\<Psi> A\\<^sub>F \\<Psi>'.\n       \\<lbrakk>name \\<sharp> \\<Psi>; name \\<sharp> A\\<^sub>F;\n        name \\<sharp> \\<Psi>';\n        \\<And>b ba bb.\n           \\<lbrakk>insertAssertion frame b = \\<langle>ba, bb\\<rangle>;\n            ba \\<sharp>* frame; ba \\<sharp>* b; distinct ba\\<rbrakk>\n           \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                                frame =\n                                \\<langle>ba, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                bb = b \\<otimes> \\<Psi>\\<^sub>F;\n        insertAssertion (\\<lparr>\\<nu>name\\<rparr>frame) \\<Psi> =\n        \\<langle>A\\<^sub>F, \\<Psi>'\\<rangle>;\n        A\\<^sub>F \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F \\<sharp>* \\<Psi>; distinct A\\<^sub>F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            \\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F", "hence \"\\<lparr>\\<nu>x\\<rparr>F = \\<langle>A\\<^sub>F, [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<rangle>\""], ["proof (prove)\nusing this:\n  [(x, y)] \\<bullet> \\<lparr>\\<nu>x\\<rparr>F =\n  [(x, y)] \\<bullet> \\<langle>(x # A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>F =\n    \\<langle>A\\<^sub>F, [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<rangle>", "using \\<open>y \\<sharp> F\\<close> \\<open>A\\<^sub>F = y#A\\<^sub>F'\\<close> \\<open>x \\<sharp> A\\<^sub>F\\<close> \\<open>y \\<sharp> A\\<^sub>F'\\<close>"], ["proof (prove)\nusing this:\n  [(x, y)] \\<bullet> \\<lparr>\\<nu>x\\<rparr>F =\n  [(x, y)] \\<bullet> \\<langle>(x # A\\<^sub>F'), \\<Psi>\\<^sub>F\\<rangle>\n  y \\<sharp> F\n  A\\<^sub>F = y # A\\<^sub>F'\n  x \\<sharp> A\\<^sub>F\n  y \\<sharp> A\\<^sub>F'\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>F =\n    \\<langle>A\\<^sub>F, [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<rangle>", "by(simp add: eqvts calc_atm alphaFrameRes)"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>F =\n  \\<langle>A\\<^sub>F, [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>name frame \\<Psi> A\\<^sub>F \\<Psi>'.\n       \\<lbrakk>name \\<sharp> \\<Psi>; name \\<sharp> A\\<^sub>F;\n        name \\<sharp> \\<Psi>';\n        \\<And>b ba bb.\n           \\<lbrakk>insertAssertion frame b = \\<langle>ba, bb\\<rangle>;\n            ba \\<sharp>* frame; ba \\<sharp>* b; distinct ba\\<rbrakk>\n           \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                                frame =\n                                \\<langle>ba, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                bb = b \\<otimes> \\<Psi>\\<^sub>F;\n        insertAssertion (\\<lparr>\\<nu>name\\<rparr>frame) \\<Psi> =\n        \\<langle>A\\<^sub>F, \\<Psi>'\\<rangle>;\n        A\\<^sub>F \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F \\<sharp>* \\<Psi>; distinct A\\<^sub>F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            \\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F", "moreover"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>F =\n  \\<langle>A\\<^sub>F, [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>name frame \\<Psi> A\\<^sub>F \\<Psi>'.\n       \\<lbrakk>name \\<sharp> \\<Psi>; name \\<sharp> A\\<^sub>F;\n        name \\<sharp> \\<Psi>';\n        \\<And>b ba bb.\n           \\<lbrakk>insertAssertion frame b = \\<langle>ba, bb\\<rangle>;\n            ba \\<sharp>* frame; ba \\<sharp>* b; distinct ba\\<rbrakk>\n           \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                                frame =\n                                \\<langle>ba, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                bb = b \\<otimes> \\<Psi>\\<^sub>F;\n        insertAssertion (\\<lparr>\\<nu>name\\<rparr>frame) \\<Psi> =\n        \\<langle>A\\<^sub>F, \\<Psi>'\\<rangle>;\n        A\\<^sub>F \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F \\<sharp>* \\<Psi>; distinct A\\<^sub>F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            \\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F", "from \\<Psi>eq"], ["proof (chain)\npicking this:\n  [(x, y)] \\<bullet> \\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F", "have \"[(x, y)] \\<bullet> ([(x, y)] \\<bullet> \\<Psi>') = [(x, y)] \\<bullet> (\\<Psi> \\<otimes> \\<Psi>\\<^sub>F)\""], ["proof (prove)\nusing this:\n  [(x, y)] \\<bullet> \\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F\n\ngoal (1 subgoal):\n 1. [(x, y)] \\<bullet> [(x, y)] \\<bullet> \\<Psi>' =\n    [(x, y)] \\<bullet> \\<Psi> \\<otimes> \\<Psi>\\<^sub>F", "by simp"], ["proof (state)\nthis:\n  [(x, y)] \\<bullet> [(x, y)] \\<bullet> \\<Psi>' =\n  [(x, y)] \\<bullet> \\<Psi> \\<otimes> \\<Psi>\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<And>name frame \\<Psi> A\\<^sub>F \\<Psi>'.\n       \\<lbrakk>name \\<sharp> \\<Psi>; name \\<sharp> A\\<^sub>F;\n        name \\<sharp> \\<Psi>';\n        \\<And>b ba bb.\n           \\<lbrakk>insertAssertion frame b = \\<langle>ba, bb\\<rangle>;\n            ba \\<sharp>* frame; ba \\<sharp>* b; distinct ba\\<rbrakk>\n           \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                                frame =\n                                \\<langle>ba, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                bb = b \\<otimes> \\<Psi>\\<^sub>F;\n        insertAssertion (\\<lparr>\\<nu>name\\<rparr>frame) \\<Psi> =\n        \\<langle>A\\<^sub>F, \\<Psi>'\\<rangle>;\n        A\\<^sub>F \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F \\<sharp>* \\<Psi>; distinct A\\<^sub>F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            \\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F", "with \\<open>x \\<sharp> \\<Psi>\\<close> \\<open>y \\<sharp> \\<Psi>\\<close>"], ["proof (chain)\npicking this:\n  x \\<sharp> \\<Psi>\n  y \\<sharp> \\<Psi>\n  [(x, y)] \\<bullet> [(x, y)] \\<bullet> \\<Psi>' =\n  [(x, y)] \\<bullet> \\<Psi> \\<otimes> \\<Psi>\\<^sub>F", "have \"\\<Psi>' = \\<Psi> \\<otimes> ([(x, y)] \\<bullet> \\<Psi>\\<^sub>F)\""], ["proof (prove)\nusing this:\n  x \\<sharp> \\<Psi>\n  y \\<sharp> \\<Psi>\n  [(x, y)] \\<bullet> [(x, y)] \\<bullet> \\<Psi>' =\n  [(x, y)] \\<bullet> \\<Psi> \\<otimes> \\<Psi>\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<Psi>' = \\<Psi> \\<otimes> [(x, y)] \\<bullet> \\<Psi>\\<^sub>F", "by(simp add: eqvts)"], ["proof (state)\nthis:\n  \\<Psi>' = \\<Psi> \\<otimes> [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<And>name frame \\<Psi> A\\<^sub>F \\<Psi>'.\n       \\<lbrakk>name \\<sharp> \\<Psi>; name \\<sharp> A\\<^sub>F;\n        name \\<sharp> \\<Psi>';\n        \\<And>b ba bb.\n           \\<lbrakk>insertAssertion frame b = \\<langle>ba, bb\\<rangle>;\n            ba \\<sharp>* frame; ba \\<sharp>* b; distinct ba\\<rbrakk>\n           \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                                frame =\n                                \\<langle>ba, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                bb = b \\<otimes> \\<Psi>\\<^sub>F;\n        insertAssertion (\\<lparr>\\<nu>name\\<rparr>frame) \\<Psi> =\n        \\<langle>A\\<^sub>F, \\<Psi>'\\<rangle>;\n        A\\<^sub>F \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F \\<sharp>* \\<Psi>; distinct A\\<^sub>F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F.\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            \\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F", "ultimately"], ["proof (chain)\npicking this:\n  \\<lparr>\\<nu>x\\<rparr>F =\n  \\<langle>A\\<^sub>F, [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<rangle>\n  \\<Psi>' = \\<Psi> \\<otimes> [(x, y)] \\<bullet> \\<Psi>\\<^sub>F", "show ?case"], ["proof (prove)\nusing this:\n  \\<lparr>\\<nu>x\\<rparr>F =\n  \\<langle>A\\<^sub>F, [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<rangle>\n  \\<Psi>' = \\<Psi> \\<otimes> [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Psi>\\<^sub>F.\n       \\<lparr>\\<nu>x\\<rparr>F =\n       \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       \\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F", "by blast"], ["proof (state)\nthis:\n  \\<exists>\\<Psi>\\<^sub>F.\n     \\<lparr>\\<nu>x\\<rparr>F =\n     \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n     \\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>\\<Psi>\\<^sub>F.\n     F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n     \\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Psi>\\<^sub>F.\n        \\<lbrakk>F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>;\n         \\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with A"], ["proof (chain)\npicking this:\n  \\<lbrakk>F = \\<langle>A\\<^sub>F, ?\\<Psi>\\<^sub>F\\<rangle>;\n   \\<Psi>' = \\<Psi> \\<otimes> ?\\<Psi>\\<^sub>F\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<exists>\\<Psi>\\<^sub>F.\n     F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n     \\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>F = \\<langle>A\\<^sub>F, ?\\<Psi>\\<^sub>F\\<rangle>;\n   \\<Psi>' = \\<Psi> \\<otimes> ?\\<Psi>\\<^sub>F\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<exists>\\<Psi>\\<^sub>F.\n     F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n     \\<Psi>' = \\<Psi> \\<otimes> \\<Psi>\\<^sub>F\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mergeFrameE:\n  fixes F   :: \"'b frame\"\n  and   G   :: \"'b frame\"\n  and   A\\<^sub>F\\<^sub>G :: \"name list\"\n  and   \\<Psi>\\<^sub>F\\<^sub>G :: 'b\n\n  assumes \"mergeFrame F G = \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>\"\n  and     \"distinct A\\<^sub>F\\<^sub>G\"\n  and     \"A\\<^sub>F\\<^sub>G \\<sharp>* F\"\n  and     \"A\\<^sub>F\\<^sub>G \\<sharp>* G\"\n\n  obtains A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G \\<Psi>\\<^sub>G where \"A\\<^sub>F\\<^sub>G = A\\<^sub>F@A\\<^sub>G\" and \"\\<Psi>\\<^sub>F\\<^sub>G = \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G\" and \"F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\" and \"G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle>\" and \"A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G\" and \"A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A\\<^sub>F A\\<^sub>G \\<Psi>\\<^sub>F \\<Psi>\\<^sub>G.\n        \\<lbrakk>A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G;\n         \\<Psi>\\<^sub>F\\<^sub>G = \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G;\n         F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>;\n         G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle>;\n         A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G;\n         A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>A\\<^sub>F A\\<^sub>G \\<Psi>\\<^sub>F \\<Psi>\\<^sub>G.\n        \\<lbrakk>A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G;\n         \\<Psi>\\<^sub>F\\<^sub>G = \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G;\n         F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>;\n         G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle>;\n         A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G;\n         A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "assume A: \"\\<And>A\\<^sub>F A\\<^sub>G \\<Psi>\\<^sub>F \\<Psi>\\<^sub>G. \\<lbrakk>A\\<^sub>F\\<^sub>G = A\\<^sub>F@A\\<^sub>G; \\<Psi>\\<^sub>F\\<^sub>G = \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G; F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>; G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle>; A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G; A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\\<rbrakk> \\<Longrightarrow> thesis\""], ["proof (state)\nthis:\n  \\<lbrakk>A\\<^sub>F\\<^sub>G = ?A\\<^sub>F @ ?A\\<^sub>G;\n   \\<Psi>\\<^sub>F\\<^sub>G = ?\\<Psi>\\<^sub>F \\<otimes> ?\\<Psi>\\<^sub>G;\n   F = \\<langle>?A\\<^sub>F, ?\\<Psi>\\<^sub>F\\<rangle>;\n   G = \\<langle>?A\\<^sub>G, ?\\<Psi>\\<^sub>G\\<rangle>;\n   ?A\\<^sub>F \\<sharp>* ?\\<Psi>\\<^sub>G;\n   ?A\\<^sub>G \\<sharp>* ?\\<Psi>\\<^sub>F\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<And>A\\<^sub>F A\\<^sub>G \\<Psi>\\<^sub>F \\<Psi>\\<^sub>G.\n        \\<lbrakk>A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G;\n         \\<Psi>\\<^sub>F\\<^sub>G = \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G;\n         F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>;\n         G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle>;\n         A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G;\n         A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  F \\<otimes>\\<^sub>F G =\n  \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>\n  distinct A\\<^sub>F\\<^sub>G\n  A\\<^sub>F\\<^sub>G \\<sharp>* F\n  A\\<^sub>F\\<^sub>G \\<sharp>* G", "have \"\\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G \\<Psi>\\<^sub>G. A\\<^sub>F\\<^sub>G = A\\<^sub>F@A\\<^sub>G \\<and> \\<Psi>\\<^sub>F\\<^sub>G = \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and> F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and> G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and> A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and> A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\""], ["proof (prove)\nusing this:\n  F \\<otimes>\\<^sub>F G =\n  \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>\n  distinct A\\<^sub>F\\<^sub>G\n  A\\<^sub>F\\<^sub>G \\<sharp>* F\n  A\\<^sub>F\\<^sub>G \\<sharp>* G\n\ngoal (1 subgoal):\n 1. \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G \\<Psi>\\<^sub>G.\n       A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n       \\<Psi>\\<^sub>F\\<^sub>G =\n       \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n       F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n       A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n       A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F", "proof(nominal_induct F avoiding: G A\\<^sub>F\\<^sub>G \\<Psi>\\<^sub>F\\<^sub>G rule: frame.strong_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>assertion G A\\<^sub>F\\<^sub>G \\<Psi>\\<^sub>F\\<^sub>G.\n       \\<lbrakk>(\\<langle>\\<epsilon>, assertion\\<rangle>) \\<otimes>\\<^sub>F\n                G =\n                \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>;\n        distinct A\\<^sub>F\\<^sub>G;\n        A\\<^sub>F\\<^sub>G \\<sharp>* (\\<langle>\\<epsilon>, assertion\\<rangle>);\n        A\\<^sub>F\\<^sub>G \\<sharp>* G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                            \\<Psi>\\<^sub>G.\n                            A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n                            \\<Psi>\\<^sub>F\\<^sub>G =\n                            \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n                            \\<langle>\\<epsilon>, assertion\\<rangle> =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            G =\n                            \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                            A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\n 2. \\<And>name frame G A\\<^sub>F\\<^sub>G \\<Psi>\\<^sub>F\\<^sub>G.\n       \\<lbrakk>name \\<sharp> G; name \\<sharp> A\\<^sub>F\\<^sub>G;\n        name \\<sharp> \\<Psi>\\<^sub>F\\<^sub>G;\n        \\<And>b ba bb.\n           \\<lbrakk>frame \\<otimes>\\<^sub>F b = \\<langle>ba, bb\\<rangle>;\n            distinct ba; ba \\<sharp>* frame; ba \\<sharp>* b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                                \\<Psi>\\<^sub>G.\n                                ba = A\\<^sub>F @ A\\<^sub>G \\<and>\n                                bb =\n                                \\<Psi>\\<^sub>F \\<otimes>\n                                \\<Psi>\\<^sub>G \\<and>\n                                frame =\n                                \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                b =\n                                \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                                A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                                A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F;\n        (\\<lparr>\\<nu>name\\<rparr>frame) \\<otimes>\\<^sub>F G =\n        \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>;\n        distinct A\\<^sub>F\\<^sub>G;\n        A\\<^sub>F\\<^sub>G \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F\\<^sub>G \\<sharp>* G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                            \\<Psi>\\<^sub>G.\n                            A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n                            \\<Psi>\\<^sub>F\\<^sub>G =\n                            \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            G =\n                            \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                            A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F", "case(FAssert \\<Psi> G A\\<^sub>F\\<^sub>G \\<Psi>\\<^sub>F\\<^sub>G)"], ["proof (state)\nthis:\n  (\\<langle>\\<epsilon>, \\<Psi>\\<rangle>) \\<otimes>\\<^sub>F G =\n  \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>\n  distinct A\\<^sub>F\\<^sub>G\n  A\\<^sub>F\\<^sub>G \\<sharp>* (\\<langle>\\<epsilon>, \\<Psi>\\<rangle>)\n  A\\<^sub>F\\<^sub>G \\<sharp>* G\n\ngoal (2 subgoals):\n 1. \\<And>assertion G A\\<^sub>F\\<^sub>G \\<Psi>\\<^sub>F\\<^sub>G.\n       \\<lbrakk>(\\<langle>\\<epsilon>, assertion\\<rangle>) \\<otimes>\\<^sub>F\n                G =\n                \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>;\n        distinct A\\<^sub>F\\<^sub>G;\n        A\\<^sub>F\\<^sub>G \\<sharp>* (\\<langle>\\<epsilon>, assertion\\<rangle>);\n        A\\<^sub>F\\<^sub>G \\<sharp>* G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                            \\<Psi>\\<^sub>G.\n                            A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n                            \\<Psi>\\<^sub>F\\<^sub>G =\n                            \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n                            \\<langle>\\<epsilon>, assertion\\<rangle> =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            G =\n                            \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                            A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\n 2. \\<And>name frame G A\\<^sub>F\\<^sub>G \\<Psi>\\<^sub>F\\<^sub>G.\n       \\<lbrakk>name \\<sharp> G; name \\<sharp> A\\<^sub>F\\<^sub>G;\n        name \\<sharp> \\<Psi>\\<^sub>F\\<^sub>G;\n        \\<And>b ba bb.\n           \\<lbrakk>frame \\<otimes>\\<^sub>F b = \\<langle>ba, bb\\<rangle>;\n            distinct ba; ba \\<sharp>* frame; ba \\<sharp>* b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                                \\<Psi>\\<^sub>G.\n                                ba = A\\<^sub>F @ A\\<^sub>G \\<and>\n                                bb =\n                                \\<Psi>\\<^sub>F \\<otimes>\n                                \\<Psi>\\<^sub>G \\<and>\n                                frame =\n                                \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                b =\n                                \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                                A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                                A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F;\n        (\\<lparr>\\<nu>name\\<rparr>frame) \\<otimes>\\<^sub>F G =\n        \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>;\n        distinct A\\<^sub>F\\<^sub>G;\n        A\\<^sub>F\\<^sub>G \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F\\<^sub>G \\<sharp>* G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                            \\<Psi>\\<^sub>G.\n                            A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n                            \\<Psi>\\<^sub>F\\<^sub>G =\n                            \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            G =\n                            \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                            A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F", "thus ?case"], ["proof (prove)\nusing this:\n  (\\<langle>\\<epsilon>, \\<Psi>\\<rangle>) \\<otimes>\\<^sub>F G =\n  \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>\n  distinct A\\<^sub>F\\<^sub>G\n  A\\<^sub>F\\<^sub>G \\<sharp>* (\\<langle>\\<epsilon>, \\<Psi>\\<rangle>)\n  A\\<^sub>F\\<^sub>G \\<sharp>* G\n\ngoal (1 subgoal):\n 1. \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G \\<Psi>\\<^sub>G.\n       A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n       \\<Psi>\\<^sub>F\\<^sub>G =\n       \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n       \\<langle>\\<epsilon>, \\<Psi>\\<rangle> =\n       \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n       A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n       A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>insertAssertion G \\<Psi> =\n             \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>;\n     distinct A\\<^sub>F\\<^sub>G; A\\<^sub>F\\<^sub>G \\<sharp>* \\<Psi>;\n     A\\<^sub>F\\<^sub>G \\<sharp>* G\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G.\n                         A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n                         (\\<exists>\\<Psi>\\<^sub>G.\n                             \\<Psi>\\<^sub>F\\<^sub>G =\n                             \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n                             A\\<^sub>F = [] \\<and>\n                             \\<Psi>\\<^sub>F = \\<Psi> \\<and>\n                             G =\n                             \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                             A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                             A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F)", "apply(rule_tac x=\"[]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>insertAssertion G \\<Psi> =\n             \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>;\n     distinct A\\<^sub>F\\<^sub>G; A\\<^sub>F\\<^sub>G \\<sharp>* \\<Psi>;\n     A\\<^sub>F\\<^sub>G \\<sharp>* G\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<Psi>\\<^sub>F A\\<^sub>G.\n                         A\\<^sub>F\\<^sub>G = [] @ A\\<^sub>G \\<and>\n                         (\\<exists>\\<Psi>\\<^sub>G.\n                             \\<Psi>\\<^sub>F\\<^sub>G =\n                             \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n                             [] = [] \\<and>\n                             \\<Psi>\\<^sub>F = \\<Psi> \\<and>\n                             G =\n                             \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                             [] \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                             A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F)", "by(drule_tac insertAssertionE) auto"], ["proof (state)\nthis:\n  \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G \\<Psi>\\<^sub>G.\n     A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n     \\<Psi>\\<^sub>F\\<^sub>G = \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n     \\<langle>\\<epsilon>, \\<Psi>\\<rangle> =\n     \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n     G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n     A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n     A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<And>name frame G A\\<^sub>F\\<^sub>G \\<Psi>\\<^sub>F\\<^sub>G.\n       \\<lbrakk>name \\<sharp> G; name \\<sharp> A\\<^sub>F\\<^sub>G;\n        name \\<sharp> \\<Psi>\\<^sub>F\\<^sub>G;\n        \\<And>b ba bb.\n           \\<lbrakk>frame \\<otimes>\\<^sub>F b = \\<langle>ba, bb\\<rangle>;\n            distinct ba; ba \\<sharp>* frame; ba \\<sharp>* b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                                \\<Psi>\\<^sub>G.\n                                ba = A\\<^sub>F @ A\\<^sub>G \\<and>\n                                bb =\n                                \\<Psi>\\<^sub>F \\<otimes>\n                                \\<Psi>\\<^sub>G \\<and>\n                                frame =\n                                \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                b =\n                                \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                                A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                                A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F;\n        (\\<lparr>\\<nu>name\\<rparr>frame) \\<otimes>\\<^sub>F G =\n        \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>;\n        distinct A\\<^sub>F\\<^sub>G;\n        A\\<^sub>F\\<^sub>G \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F\\<^sub>G \\<sharp>* G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                            \\<Psi>\\<^sub>G.\n                            A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n                            \\<Psi>\\<^sub>F\\<^sub>G =\n                            \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            G =\n                            \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                            A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>name frame G A\\<^sub>F\\<^sub>G \\<Psi>\\<^sub>F\\<^sub>G.\n       \\<lbrakk>name \\<sharp> G; name \\<sharp> A\\<^sub>F\\<^sub>G;\n        name \\<sharp> \\<Psi>\\<^sub>F\\<^sub>G;\n        \\<And>b ba bb.\n           \\<lbrakk>frame \\<otimes>\\<^sub>F b = \\<langle>ba, bb\\<rangle>;\n            distinct ba; ba \\<sharp>* frame; ba \\<sharp>* b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                                \\<Psi>\\<^sub>G.\n                                ba = A\\<^sub>F @ A\\<^sub>G \\<and>\n                                bb =\n                                \\<Psi>\\<^sub>F \\<otimes>\n                                \\<Psi>\\<^sub>G \\<and>\n                                frame =\n                                \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                b =\n                                \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                                A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                                A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F;\n        (\\<lparr>\\<nu>name\\<rparr>frame) \\<otimes>\\<^sub>F G =\n        \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>;\n        distinct A\\<^sub>F\\<^sub>G;\n        A\\<^sub>F\\<^sub>G \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F\\<^sub>G \\<sharp>* G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                            \\<Psi>\\<^sub>G.\n                            A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n                            \\<Psi>\\<^sub>F\\<^sub>G =\n                            \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            G =\n                            \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                            A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F", "case(FRes x F G A\\<^sub>F\\<^sub>G \\<Psi>\\<^sub>F\\<^sub>G)"], ["proof (state)\nthis:\n  x \\<sharp> G\n  x \\<sharp> A\\<^sub>F\\<^sub>G\n  x \\<sharp> \\<Psi>\\<^sub>F\\<^sub>G\n  \\<lbrakk>F \\<otimes>\\<^sub>F ?b = \\<langle>?ba, ?bb\\<rangle>;\n   distinct ?ba; ?ba \\<sharp>* F; ?ba \\<sharp>* ?b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                       \\<Psi>\\<^sub>G.\n                       ?ba = A\\<^sub>F @ A\\<^sub>G \\<and>\n                       ?bb = \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n                       F =\n                       \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                       ?b =\n                       \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                       A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                       A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\n  (\\<lparr>\\<nu>x\\<rparr>F) \\<otimes>\\<^sub>F G =\n  \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>\n  distinct A\\<^sub>F\\<^sub>G\n  A\\<^sub>F\\<^sub>G \\<sharp>* (\\<lparr>\\<nu>x\\<rparr>F)\n  A\\<^sub>F\\<^sub>G \\<sharp>* G\n\ngoal (1 subgoal):\n 1. \\<And>name frame G A\\<^sub>F\\<^sub>G \\<Psi>\\<^sub>F\\<^sub>G.\n       \\<lbrakk>name \\<sharp> G; name \\<sharp> A\\<^sub>F\\<^sub>G;\n        name \\<sharp> \\<Psi>\\<^sub>F\\<^sub>G;\n        \\<And>b ba bb.\n           \\<lbrakk>frame \\<otimes>\\<^sub>F b = \\<langle>ba, bb\\<rangle>;\n            distinct ba; ba \\<sharp>* frame; ba \\<sharp>* b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                                \\<Psi>\\<^sub>G.\n                                ba = A\\<^sub>F @ A\\<^sub>G \\<and>\n                                bb =\n                                \\<Psi>\\<^sub>F \\<otimes>\n                                \\<Psi>\\<^sub>G \\<and>\n                                frame =\n                                \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                b =\n                                \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                                A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                                A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F;\n        (\\<lparr>\\<nu>name\\<rparr>frame) \\<otimes>\\<^sub>F G =\n        \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>;\n        distinct A\\<^sub>F\\<^sub>G;\n        A\\<^sub>F\\<^sub>G \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F\\<^sub>G \\<sharp>* G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                            \\<Psi>\\<^sub>G.\n                            A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n                            \\<Psi>\\<^sub>F\\<^sub>G =\n                            \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            G =\n                            \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                            A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F", "from \\<open>mergeFrame (\\<lparr>\\<nu>x\\<rparr>F) G = \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>\\<close> \\<open>x \\<sharp> G\\<close>"], ["proof (chain)\npicking this:\n  (\\<lparr>\\<nu>x\\<rparr>F) \\<otimes>\\<^sub>F G =\n  \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>\n  x \\<sharp> G", "obtain y A\\<^sub>F\\<^sub>G' where \"A\\<^sub>F\\<^sub>G = y#A\\<^sub>F\\<^sub>G'\""], ["proof (prove)\nusing this:\n  (\\<lparr>\\<nu>x\\<rparr>F) \\<otimes>\\<^sub>F G =\n  \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>\n  x \\<sharp> G\n\ngoal (1 subgoal):\n 1. (\\<And>y A\\<^sub>F\\<^sub>G''.\n        A\\<^sub>F\\<^sub>G = y # A\\<^sub>F\\<^sub>G'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(induct A\\<^sub>F\\<^sub>G) auto"], ["proof (state)\nthis:\n  A\\<^sub>F\\<^sub>G = y # A\\<^sub>F\\<^sub>G'\n\ngoal (1 subgoal):\n 1. \\<And>name frame G A\\<^sub>F\\<^sub>G \\<Psi>\\<^sub>F\\<^sub>G.\n       \\<lbrakk>name \\<sharp> G; name \\<sharp> A\\<^sub>F\\<^sub>G;\n        name \\<sharp> \\<Psi>\\<^sub>F\\<^sub>G;\n        \\<And>b ba bb.\n           \\<lbrakk>frame \\<otimes>\\<^sub>F b = \\<langle>ba, bb\\<rangle>;\n            distinct ba; ba \\<sharp>* frame; ba \\<sharp>* b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                                \\<Psi>\\<^sub>G.\n                                ba = A\\<^sub>F @ A\\<^sub>G \\<and>\n                                bb =\n                                \\<Psi>\\<^sub>F \\<otimes>\n                                \\<Psi>\\<^sub>G \\<and>\n                                frame =\n                                \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                b =\n                                \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                                A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                                A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F;\n        (\\<lparr>\\<nu>name\\<rparr>frame) \\<otimes>\\<^sub>F G =\n        \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>;\n        distinct A\\<^sub>F\\<^sub>G;\n        A\\<^sub>F\\<^sub>G \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F\\<^sub>G \\<sharp>* G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                            \\<Psi>\\<^sub>G.\n                            A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n                            \\<Psi>\\<^sub>F\\<^sub>G =\n                            \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            G =\n                            \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                            A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F", "with \\<open>A\\<^sub>F\\<^sub>G \\<sharp>* (\\<lparr>\\<nu>x\\<rparr>F)\\<close> \\<open>x \\<sharp> A\\<^sub>F\\<^sub>G\\<close>"], ["proof (chain)\npicking this:\n  A\\<^sub>F\\<^sub>G \\<sharp>* (\\<lparr>\\<nu>x\\<rparr>F)\n  x \\<sharp> A\\<^sub>F\\<^sub>G\n  A\\<^sub>F\\<^sub>G = y # A\\<^sub>F\\<^sub>G'", "have \"A\\<^sub>F\\<^sub>G' \\<sharp>* F\" and \"x \\<sharp> A\\<^sub>F\\<^sub>G'\""], ["proof (prove)\nusing this:\n  A\\<^sub>F\\<^sub>G \\<sharp>* (\\<lparr>\\<nu>x\\<rparr>F)\n  x \\<sharp> A\\<^sub>F\\<^sub>G\n  A\\<^sub>F\\<^sub>G = y # A\\<^sub>F\\<^sub>G'\n\ngoal (1 subgoal):\n 1. A\\<^sub>F\\<^sub>G' \\<sharp>* F &&& x \\<sharp> A\\<^sub>F\\<^sub>G'", "by(auto simp add: supp_list_cons fresh_star_def fresh_def name_list_supp abs_supp frame.supp)"], ["proof (state)\nthis:\n  A\\<^sub>F\\<^sub>G' \\<sharp>* F\n  x \\<sharp> A\\<^sub>F\\<^sub>G'\n\ngoal (1 subgoal):\n 1. \\<And>name frame G A\\<^sub>F\\<^sub>G \\<Psi>\\<^sub>F\\<^sub>G.\n       \\<lbrakk>name \\<sharp> G; name \\<sharp> A\\<^sub>F\\<^sub>G;\n        name \\<sharp> \\<Psi>\\<^sub>F\\<^sub>G;\n        \\<And>b ba bb.\n           \\<lbrakk>frame \\<otimes>\\<^sub>F b = \\<langle>ba, bb\\<rangle>;\n            distinct ba; ba \\<sharp>* frame; ba \\<sharp>* b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                                \\<Psi>\\<^sub>G.\n                                ba = A\\<^sub>F @ A\\<^sub>G \\<and>\n                                bb =\n                                \\<Psi>\\<^sub>F \\<otimes>\n                                \\<Psi>\\<^sub>G \\<and>\n                                frame =\n                                \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                b =\n                                \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                                A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                                A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F;\n        (\\<lparr>\\<nu>name\\<rparr>frame) \\<otimes>\\<^sub>F G =\n        \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>;\n        distinct A\\<^sub>F\\<^sub>G;\n        A\\<^sub>F\\<^sub>G \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F\\<^sub>G \\<sharp>* G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                            \\<Psi>\\<^sub>G.\n                            A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n                            \\<Psi>\\<^sub>F\\<^sub>G =\n                            \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            G =\n                            \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                            A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F", "from \\<open>A\\<^sub>F\\<^sub>G = y#A\\<^sub>F\\<^sub>G'\\<close> \\<open>A\\<^sub>F\\<^sub>G \\<sharp>* G\\<close>"], ["proof (chain)\npicking this:\n  A\\<^sub>F\\<^sub>G = y # A\\<^sub>F\\<^sub>G'\n  A\\<^sub>F\\<^sub>G \\<sharp>* G", "have \"y \\<sharp> G\" and \"A\\<^sub>F\\<^sub>G' \\<sharp>* G\""], ["proof (prove)\nusing this:\n  A\\<^sub>F\\<^sub>G = y # A\\<^sub>F\\<^sub>G'\n  A\\<^sub>F\\<^sub>G \\<sharp>* G\n\ngoal (1 subgoal):\n 1. y \\<sharp> G &&& A\\<^sub>F\\<^sub>G' \\<sharp>* G", "by simp+"], ["proof (state)\nthis:\n  y \\<sharp> G\n  A\\<^sub>F\\<^sub>G' \\<sharp>* G\n\ngoal (1 subgoal):\n 1. \\<And>name frame G A\\<^sub>F\\<^sub>G \\<Psi>\\<^sub>F\\<^sub>G.\n       \\<lbrakk>name \\<sharp> G; name \\<sharp> A\\<^sub>F\\<^sub>G;\n        name \\<sharp> \\<Psi>\\<^sub>F\\<^sub>G;\n        \\<And>b ba bb.\n           \\<lbrakk>frame \\<otimes>\\<^sub>F b = \\<langle>ba, bb\\<rangle>;\n            distinct ba; ba \\<sharp>* frame; ba \\<sharp>* b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                                \\<Psi>\\<^sub>G.\n                                ba = A\\<^sub>F @ A\\<^sub>G \\<and>\n                                bb =\n                                \\<Psi>\\<^sub>F \\<otimes>\n                                \\<Psi>\\<^sub>G \\<and>\n                                frame =\n                                \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                b =\n                                \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                                A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                                A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F;\n        (\\<lparr>\\<nu>name\\<rparr>frame) \\<otimes>\\<^sub>F G =\n        \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>;\n        distinct A\\<^sub>F\\<^sub>G;\n        A\\<^sub>F\\<^sub>G \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F\\<^sub>G \\<sharp>* G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                            \\<Psi>\\<^sub>G.\n                            A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n                            \\<Psi>\\<^sub>F\\<^sub>G =\n                            \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            G =\n                            \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                            A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F", "from \\<open>A\\<^sub>F\\<^sub>G = y#A\\<^sub>F\\<^sub>G'\\<close> \\<open>A\\<^sub>F\\<^sub>G \\<sharp>* (\\<lparr>\\<nu>x\\<rparr>F)\\<close> \\<open>x \\<sharp> A\\<^sub>F\\<^sub>G\\<close>"], ["proof (chain)\npicking this:\n  A\\<^sub>F\\<^sub>G = y # A\\<^sub>F\\<^sub>G'\n  A\\<^sub>F\\<^sub>G \\<sharp>* (\\<lparr>\\<nu>x\\<rparr>F)\n  x \\<sharp> A\\<^sub>F\\<^sub>G", "have \"y \\<sharp> F\" and \"A\\<^sub>F\\<^sub>G' \\<sharp>* F\""], ["proof (prove)\nusing this:\n  A\\<^sub>F\\<^sub>G = y # A\\<^sub>F\\<^sub>G'\n  A\\<^sub>F\\<^sub>G \\<sharp>* (\\<lparr>\\<nu>x\\<rparr>F)\n  x \\<sharp> A\\<^sub>F\\<^sub>G\n\ngoal (1 subgoal):\n 1. y \\<sharp> F &&& A\\<^sub>F\\<^sub>G' \\<sharp>* F", "apply(auto simp add: abs_fresh frameResChainFreshSet)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A\\<^sub>F\\<^sub>G = y # A\\<^sub>F\\<^sub>G';\n     A\\<^sub>F\\<^sub>G' \\<sharp>* (\\<lparr>\\<nu>x\\<rparr>F); x \\<noteq> y;\n     x \\<sharp> A\\<^sub>F\\<^sub>G'; y \\<sharp> F\\<rbrakk>\n    \\<Longrightarrow> A\\<^sub>F\\<^sub>G' \\<sharp>* F", "apply(hypsubst_thin)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A\\<^sub>F\\<^sub>G' \\<sharp>* (\\<lparr>\\<nu>x\\<rparr>F);\n     x \\<noteq> y; x \\<sharp> A\\<^sub>F\\<^sub>G'; y \\<sharp> F\\<rbrakk>\n    \\<Longrightarrow> A\\<^sub>F\\<^sub>G' \\<sharp>* F", "by(induct A\\<^sub>F\\<^sub>G') (auto simp add: abs_fresh)"], ["proof (state)\nthis:\n  y \\<sharp> F\n  A\\<^sub>F\\<^sub>G' \\<sharp>* F\n\ngoal (1 subgoal):\n 1. \\<And>name frame G A\\<^sub>F\\<^sub>G \\<Psi>\\<^sub>F\\<^sub>G.\n       \\<lbrakk>name \\<sharp> G; name \\<sharp> A\\<^sub>F\\<^sub>G;\n        name \\<sharp> \\<Psi>\\<^sub>F\\<^sub>G;\n        \\<And>b ba bb.\n           \\<lbrakk>frame \\<otimes>\\<^sub>F b = \\<langle>ba, bb\\<rangle>;\n            distinct ba; ba \\<sharp>* frame; ba \\<sharp>* b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                                \\<Psi>\\<^sub>G.\n                                ba = A\\<^sub>F @ A\\<^sub>G \\<and>\n                                bb =\n                                \\<Psi>\\<^sub>F \\<otimes>\n                                \\<Psi>\\<^sub>G \\<and>\n                                frame =\n                                \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                b =\n                                \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                                A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                                A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F;\n        (\\<lparr>\\<nu>name\\<rparr>frame) \\<otimes>\\<^sub>F G =\n        \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>;\n        distinct A\\<^sub>F\\<^sub>G;\n        A\\<^sub>F\\<^sub>G \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F\\<^sub>G \\<sharp>* G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                            \\<Psi>\\<^sub>G.\n                            A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n                            \\<Psi>\\<^sub>F\\<^sub>G =\n                            \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            G =\n                            \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                            A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F", "from \\<open>distinct A\\<^sub>F\\<^sub>G\\<close> \\<open>A\\<^sub>F\\<^sub>G = y#A\\<^sub>F\\<^sub>G'\\<close>"], ["proof (chain)\npicking this:\n  distinct A\\<^sub>F\\<^sub>G\n  A\\<^sub>F\\<^sub>G = y # A\\<^sub>F\\<^sub>G'", "have \"y \\<sharp> A\\<^sub>F\\<^sub>G'\" and \"distinct A\\<^sub>F\\<^sub>G'\""], ["proof (prove)\nusing this:\n  distinct A\\<^sub>F\\<^sub>G\n  A\\<^sub>F\\<^sub>G = y # A\\<^sub>F\\<^sub>G'\n\ngoal (1 subgoal):\n 1. y \\<sharp> A\\<^sub>F\\<^sub>G' &&& distinct A\\<^sub>F\\<^sub>G'", "by auto"], ["proof (state)\nthis:\n  y \\<sharp> A\\<^sub>F\\<^sub>G'\n  distinct A\\<^sub>F\\<^sub>G'\n\ngoal (1 subgoal):\n 1. \\<And>name frame G A\\<^sub>F\\<^sub>G \\<Psi>\\<^sub>F\\<^sub>G.\n       \\<lbrakk>name \\<sharp> G; name \\<sharp> A\\<^sub>F\\<^sub>G;\n        name \\<sharp> \\<Psi>\\<^sub>F\\<^sub>G;\n        \\<And>b ba bb.\n           \\<lbrakk>frame \\<otimes>\\<^sub>F b = \\<langle>ba, bb\\<rangle>;\n            distinct ba; ba \\<sharp>* frame; ba \\<sharp>* b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                                \\<Psi>\\<^sub>G.\n                                ba = A\\<^sub>F @ A\\<^sub>G \\<and>\n                                bb =\n                                \\<Psi>\\<^sub>F \\<otimes>\n                                \\<Psi>\\<^sub>G \\<and>\n                                frame =\n                                \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                b =\n                                \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                                A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                                A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F;\n        (\\<lparr>\\<nu>name\\<rparr>frame) \\<otimes>\\<^sub>F G =\n        \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>;\n        distinct A\\<^sub>F\\<^sub>G;\n        A\\<^sub>F\\<^sub>G \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F\\<^sub>G \\<sharp>* G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                            \\<Psi>\\<^sub>G.\n                            A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n                            \\<Psi>\\<^sub>F\\<^sub>G =\n                            \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            G =\n                            \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                            A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F", "with \\<open>A\\<^sub>F\\<^sub>G = y#A\\<^sub>F\\<^sub>G'\\<close> \\<open>mergeFrame (\\<lparr>\\<nu>x\\<rparr>F) G = \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>\\<close> \\<open>x \\<sharp> G\\<close> \\<open>x \\<sharp> A\\<^sub>F\\<^sub>G\\<close> \\<open>y \\<sharp> A\\<^sub>F\\<^sub>G'\\<close>"], ["proof (chain)\npicking this:\n  A\\<^sub>F\\<^sub>G = y # A\\<^sub>F\\<^sub>G'\n  (\\<lparr>\\<nu>x\\<rparr>F) \\<otimes>\\<^sub>F G =\n  \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>\n  x \\<sharp> G\n  x \\<sharp> A\\<^sub>F\\<^sub>G\n  y \\<sharp> A\\<^sub>F\\<^sub>G'\n  y \\<sharp> A\\<^sub>F\\<^sub>G'\n  distinct A\\<^sub>F\\<^sub>G'", "have \"mergeFrame F G = \\<langle>A\\<^sub>F\\<^sub>G', [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>\""], ["proof (prove)\nusing this:\n  A\\<^sub>F\\<^sub>G = y # A\\<^sub>F\\<^sub>G'\n  (\\<lparr>\\<nu>x\\<rparr>F) \\<otimes>\\<^sub>F G =\n  \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>\n  x \\<sharp> G\n  x \\<sharp> A\\<^sub>F\\<^sub>G\n  y \\<sharp> A\\<^sub>F\\<^sub>G'\n  y \\<sharp> A\\<^sub>F\\<^sub>G'\n  distinct A\\<^sub>F\\<^sub>G'\n\ngoal (1 subgoal):\n 1. F \\<otimes>\\<^sub>F G =\n    \\<langle>A\\<^sub>F\\<^sub>G', [(x, y)] \\<bullet>\n                                 \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>", "by(simp add: frame.inject alpha eqvts)"], ["proof (state)\nthis:\n  F \\<otimes>\\<^sub>F G =\n  \\<langle>A\\<^sub>F\\<^sub>G', [(x, y)] \\<bullet>\n                               \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>name frame G A\\<^sub>F\\<^sub>G \\<Psi>\\<^sub>F\\<^sub>G.\n       \\<lbrakk>name \\<sharp> G; name \\<sharp> A\\<^sub>F\\<^sub>G;\n        name \\<sharp> \\<Psi>\\<^sub>F\\<^sub>G;\n        \\<And>b ba bb.\n           \\<lbrakk>frame \\<otimes>\\<^sub>F b = \\<langle>ba, bb\\<rangle>;\n            distinct ba; ba \\<sharp>* frame; ba \\<sharp>* b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                                \\<Psi>\\<^sub>G.\n                                ba = A\\<^sub>F @ A\\<^sub>G \\<and>\n                                bb =\n                                \\<Psi>\\<^sub>F \\<otimes>\n                                \\<Psi>\\<^sub>G \\<and>\n                                frame =\n                                \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                b =\n                                \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                                A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                                A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F;\n        (\\<lparr>\\<nu>name\\<rparr>frame) \\<otimes>\\<^sub>F G =\n        \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>;\n        distinct A\\<^sub>F\\<^sub>G;\n        A\\<^sub>F\\<^sub>G \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F\\<^sub>G \\<sharp>* G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                            \\<Psi>\\<^sub>G.\n                            A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n                            \\<Psi>\\<^sub>F\\<^sub>G =\n                            \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            G =\n                            \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                            A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F", "with \\<open>distinct A\\<^sub>F\\<^sub>G'\\<close> \\<open>A\\<^sub>F\\<^sub>G' \\<sharp>* F\\<close> \\<open>A\\<^sub>F\\<^sub>G' \\<sharp>* G\\<close>\n         \\<open>\\<And>G A\\<^sub>F\\<^sub>G \\<Psi>\\<^sub>F\\<^sub>G. \\<lbrakk>mergeFrame F G = \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>; distinct A\\<^sub>F\\<^sub>G; A\\<^sub>F\\<^sub>G \\<sharp>* F; A\\<^sub>F\\<^sub>G \\<sharp>* G\\<rbrakk> \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G \\<Psi>\\<^sub>G. A\\<^sub>F\\<^sub>G = A\\<^sub>F@A\\<^sub>G \\<and> \\<Psi>\\<^sub>F\\<^sub>G = \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and> F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and> G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and> A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and> A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\\<close>"], ["proof (chain)\npicking this:\n  distinct A\\<^sub>F\\<^sub>G'\n  A\\<^sub>F\\<^sub>G' \\<sharp>* F\n  A\\<^sub>F\\<^sub>G' \\<sharp>* G\n  \\<lbrakk>F \\<otimes>\\<^sub>F ?G =\n           \\<langle>?A\\<^sub>F\\<^sub>G, ?\\<Psi>\\<^sub>F\\<^sub>G\\<rangle>;\n   distinct ?A\\<^sub>F\\<^sub>G; ?A\\<^sub>F\\<^sub>G \\<sharp>* F;\n   ?A\\<^sub>F\\<^sub>G \\<sharp>* ?G\\<rbrakk>\n  \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                       \\<Psi>\\<^sub>G.\n                       ?A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n                       ?\\<Psi>\\<^sub>F\\<^sub>G =\n                       \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n                       F =\n                       \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                       ?G =\n                       \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                       A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                       A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\n  F \\<otimes>\\<^sub>F G =\n  \\<langle>A\\<^sub>F\\<^sub>G', [(x, y)] \\<bullet>\n                               \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>", "obtain A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G \\<Psi>\\<^sub>G where \"A\\<^sub>F\\<^sub>G' = A\\<^sub>F@A\\<^sub>G\" and \"([(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<^sub>G) = \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G\" and FrF: \"F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\" and FrG: \"G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle>\" and \"A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G\" and \"A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\""], ["proof (prove)\nusing this:\n  distinct A\\<^sub>F\\<^sub>G'\n  A\\<^sub>F\\<^sub>G' \\<sharp>* F\n  A\\<^sub>F\\<^sub>G' \\<sharp>* G\n  \\<lbrakk>F \\<otimes>\\<^sub>F ?G =\n           \\<langle>?A\\<^sub>F\\<^sub>G, ?\\<Psi>\\<^sub>F\\<^sub>G\\<rangle>;\n   distinct ?A\\<^sub>F\\<^sub>G; ?A\\<^sub>F\\<^sub>G \\<sharp>* F;\n   ?A\\<^sub>F\\<^sub>G \\<sharp>* ?G\\<rbrakk>\n  \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                       \\<Psi>\\<^sub>G.\n                       ?A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n                       ?\\<Psi>\\<^sub>F\\<^sub>G =\n                       \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n                       F =\n                       \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                       ?G =\n                       \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                       A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                       A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\n  F \\<otimes>\\<^sub>F G =\n  \\<langle>A\\<^sub>F\\<^sub>G', [(x, y)] \\<bullet>\n                               \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>A\\<^sub>F A\\<^sub>G \\<Psi>\\<^sub>F \\<Psi>\\<^sub>G.\n        \\<lbrakk>A\\<^sub>F\\<^sub>G' = A\\<^sub>F @ A\\<^sub>G;\n         [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<^sub>G =\n         \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G;\n         F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>;\n         G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle>;\n         A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G;\n         A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  A\\<^sub>F\\<^sub>G' = A\\<^sub>F @ A\\<^sub>G\n  [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<^sub>G =\n  \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G\n  F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\n  G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle>\n  A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G\n  A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<And>name frame G A\\<^sub>F\\<^sub>G \\<Psi>\\<^sub>F\\<^sub>G.\n       \\<lbrakk>name \\<sharp> G; name \\<sharp> A\\<^sub>F\\<^sub>G;\n        name \\<sharp> \\<Psi>\\<^sub>F\\<^sub>G;\n        \\<And>b ba bb.\n           \\<lbrakk>frame \\<otimes>\\<^sub>F b = \\<langle>ba, bb\\<rangle>;\n            distinct ba; ba \\<sharp>* frame; ba \\<sharp>* b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                                \\<Psi>\\<^sub>G.\n                                ba = A\\<^sub>F @ A\\<^sub>G \\<and>\n                                bb =\n                                \\<Psi>\\<^sub>F \\<otimes>\n                                \\<Psi>\\<^sub>G \\<and>\n                                frame =\n                                \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                b =\n                                \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                                A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                                A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F;\n        (\\<lparr>\\<nu>name\\<rparr>frame) \\<otimes>\\<^sub>F G =\n        \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>;\n        distinct A\\<^sub>F\\<^sub>G;\n        A\\<^sub>F\\<^sub>G \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F\\<^sub>G \\<sharp>* G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                            \\<Psi>\\<^sub>G.\n                            A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n                            \\<Psi>\\<^sub>F\\<^sub>G =\n                            \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            G =\n                            \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                            A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F", "from \\<open>A\\<^sub>F\\<^sub>G' = A\\<^sub>F@A\\<^sub>G\\<close> \\<open>A\\<^sub>F\\<^sub>G = y#A\\<^sub>F\\<^sub>G'\\<close>"], ["proof (chain)\npicking this:\n  A\\<^sub>F\\<^sub>G' = A\\<^sub>F @ A\\<^sub>G\n  A\\<^sub>F\\<^sub>G = y # A\\<^sub>F\\<^sub>G'", "have  \"A\\<^sub>F\\<^sub>G = (y#A\\<^sub>F)@A\\<^sub>G\""], ["proof (prove)\nusing this:\n  A\\<^sub>F\\<^sub>G' = A\\<^sub>F @ A\\<^sub>G\n  A\\<^sub>F\\<^sub>G = y # A\\<^sub>F\\<^sub>G'\n\ngoal (1 subgoal):\n 1. A\\<^sub>F\\<^sub>G = (y # A\\<^sub>F) @ A\\<^sub>G", "by simp"], ["proof (state)\nthis:\n  A\\<^sub>F\\<^sub>G = (y # A\\<^sub>F) @ A\\<^sub>G\n\ngoal (1 subgoal):\n 1. \\<And>name frame G A\\<^sub>F\\<^sub>G \\<Psi>\\<^sub>F\\<^sub>G.\n       \\<lbrakk>name \\<sharp> G; name \\<sharp> A\\<^sub>F\\<^sub>G;\n        name \\<sharp> \\<Psi>\\<^sub>F\\<^sub>G;\n        \\<And>b ba bb.\n           \\<lbrakk>frame \\<otimes>\\<^sub>F b = \\<langle>ba, bb\\<rangle>;\n            distinct ba; ba \\<sharp>* frame; ba \\<sharp>* b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                                \\<Psi>\\<^sub>G.\n                                ba = A\\<^sub>F @ A\\<^sub>G \\<and>\n                                bb =\n                                \\<Psi>\\<^sub>F \\<otimes>\n                                \\<Psi>\\<^sub>G \\<and>\n                                frame =\n                                \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                b =\n                                \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                                A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                                A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F;\n        (\\<lparr>\\<nu>name\\<rparr>frame) \\<otimes>\\<^sub>F G =\n        \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>;\n        distinct A\\<^sub>F\\<^sub>G;\n        A\\<^sub>F\\<^sub>G \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F\\<^sub>G \\<sharp>* G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                            \\<Psi>\\<^sub>G.\n                            A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n                            \\<Psi>\\<^sub>F\\<^sub>G =\n                            \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            G =\n                            \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                            A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F", "moreover"], ["proof (state)\nthis:\n  A\\<^sub>F\\<^sub>G = (y # A\\<^sub>F) @ A\\<^sub>G\n\ngoal (1 subgoal):\n 1. \\<And>name frame G A\\<^sub>F\\<^sub>G \\<Psi>\\<^sub>F\\<^sub>G.\n       \\<lbrakk>name \\<sharp> G; name \\<sharp> A\\<^sub>F\\<^sub>G;\n        name \\<sharp> \\<Psi>\\<^sub>F\\<^sub>G;\n        \\<And>b ba bb.\n           \\<lbrakk>frame \\<otimes>\\<^sub>F b = \\<langle>ba, bb\\<rangle>;\n            distinct ba; ba \\<sharp>* frame; ba \\<sharp>* b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                                \\<Psi>\\<^sub>G.\n                                ba = A\\<^sub>F @ A\\<^sub>G \\<and>\n                                bb =\n                                \\<Psi>\\<^sub>F \\<otimes>\n                                \\<Psi>\\<^sub>G \\<and>\n                                frame =\n                                \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                b =\n                                \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                                A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                                A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F;\n        (\\<lparr>\\<nu>name\\<rparr>frame) \\<otimes>\\<^sub>F G =\n        \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>;\n        distinct A\\<^sub>F\\<^sub>G;\n        A\\<^sub>F\\<^sub>G \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F\\<^sub>G \\<sharp>* G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                            \\<Psi>\\<^sub>G.\n                            A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n                            \\<Psi>\\<^sub>F\\<^sub>G =\n                            \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            G =\n                            \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                            A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F", "from \\<open>A\\<^sub>F\\<^sub>G' = A\\<^sub>F@A\\<^sub>G\\<close> \\<open>y \\<sharp> A\\<^sub>F\\<^sub>G'\\<close> \\<open>x \\<sharp> A\\<^sub>F\\<^sub>G'\\<close>"], ["proof (chain)\npicking this:\n  A\\<^sub>F\\<^sub>G' = A\\<^sub>F @ A\\<^sub>G\n  y \\<sharp> A\\<^sub>F\\<^sub>G'\n  x \\<sharp> A\\<^sub>F\\<^sub>G'", "have \"x \\<sharp> A\\<^sub>F\" and \"y \\<sharp> A\\<^sub>F\" and \"x \\<sharp> A\\<^sub>G\" and \"y \\<sharp> A\\<^sub>G\""], ["proof (prove)\nusing this:\n  A\\<^sub>F\\<^sub>G' = A\\<^sub>F @ A\\<^sub>G\n  y \\<sharp> A\\<^sub>F\\<^sub>G'\n  x \\<sharp> A\\<^sub>F\\<^sub>G'\n\ngoal (1 subgoal):\n 1. (x \\<sharp> A\\<^sub>F &&& y \\<sharp> A\\<^sub>F) &&&\n    x \\<sharp> A\\<^sub>G &&& y \\<sharp> A\\<^sub>G", "by simp+"], ["proof (state)\nthis:\n  x \\<sharp> A\\<^sub>F\n  y \\<sharp> A\\<^sub>F\n  x \\<sharp> A\\<^sub>G\n  y \\<sharp> A\\<^sub>G\n\ngoal (1 subgoal):\n 1. \\<And>name frame G A\\<^sub>F\\<^sub>G \\<Psi>\\<^sub>F\\<^sub>G.\n       \\<lbrakk>name \\<sharp> G; name \\<sharp> A\\<^sub>F\\<^sub>G;\n        name \\<sharp> \\<Psi>\\<^sub>F\\<^sub>G;\n        \\<And>b ba bb.\n           \\<lbrakk>frame \\<otimes>\\<^sub>F b = \\<langle>ba, bb\\<rangle>;\n            distinct ba; ba \\<sharp>* frame; ba \\<sharp>* b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                                \\<Psi>\\<^sub>G.\n                                ba = A\\<^sub>F @ A\\<^sub>G \\<and>\n                                bb =\n                                \\<Psi>\\<^sub>F \\<otimes>\n                                \\<Psi>\\<^sub>G \\<and>\n                                frame =\n                                \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                b =\n                                \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                                A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                                A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F;\n        (\\<lparr>\\<nu>name\\<rparr>frame) \\<otimes>\\<^sub>F G =\n        \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>;\n        distinct A\\<^sub>F\\<^sub>G;\n        A\\<^sub>F\\<^sub>G \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F\\<^sub>G \\<sharp>* G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                            \\<Psi>\\<^sub>G.\n                            A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n                            \\<Psi>\\<^sub>F\\<^sub>G =\n                            \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            G =\n                            \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                            A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F", "with \\<open>y \\<sharp> G\\<close> \\<open>x \\<sharp> G\\<close> \\<open>x \\<sharp> A\\<^sub>F\\<^sub>G\\<close> FrG"], ["proof (chain)\npicking this:\n  y \\<sharp> G\n  x \\<sharp> G\n  x \\<sharp> A\\<^sub>F\\<^sub>G\n  G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle>\n  x \\<sharp> A\\<^sub>F\n  y \\<sharp> A\\<^sub>F\n  x \\<sharp> A\\<^sub>G\n  y \\<sharp> A\\<^sub>G", "have \"y \\<sharp> \\<Psi>\\<^sub>G\" and \"x \\<sharp> \\<Psi>\\<^sub>G\""], ["proof (prove)\nusing this:\n  y \\<sharp> G\n  x \\<sharp> G\n  x \\<sharp> A\\<^sub>F\\<^sub>G\n  G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle>\n  x \\<sharp> A\\<^sub>F\n  y \\<sharp> A\\<^sub>F\n  x \\<sharp> A\\<^sub>G\n  y \\<sharp> A\\<^sub>G\n\ngoal (1 subgoal):\n 1. y \\<sharp> \\<Psi>\\<^sub>G &&& x \\<sharp> \\<Psi>\\<^sub>G", "by auto"], ["proof (state)\nthis:\n  y \\<sharp> \\<Psi>\\<^sub>G\n  x \\<sharp> \\<Psi>\\<^sub>G\n\ngoal (1 subgoal):\n 1. \\<And>name frame G A\\<^sub>F\\<^sub>G \\<Psi>\\<^sub>F\\<^sub>G.\n       \\<lbrakk>name \\<sharp> G; name \\<sharp> A\\<^sub>F\\<^sub>G;\n        name \\<sharp> \\<Psi>\\<^sub>F\\<^sub>G;\n        \\<And>b ba bb.\n           \\<lbrakk>frame \\<otimes>\\<^sub>F b = \\<langle>ba, bb\\<rangle>;\n            distinct ba; ba \\<sharp>* frame; ba \\<sharp>* b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                                \\<Psi>\\<^sub>G.\n                                ba = A\\<^sub>F @ A\\<^sub>G \\<and>\n                                bb =\n                                \\<Psi>\\<^sub>F \\<otimes>\n                                \\<Psi>\\<^sub>G \\<and>\n                                frame =\n                                \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                b =\n                                \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                                A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                                A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F;\n        (\\<lparr>\\<nu>name\\<rparr>frame) \\<otimes>\\<^sub>F G =\n        \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>;\n        distinct A\\<^sub>F\\<^sub>G;\n        A\\<^sub>F\\<^sub>G \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F\\<^sub>G \\<sharp>* G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                            \\<Psi>\\<^sub>G.\n                            A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n                            \\<Psi>\\<^sub>F\\<^sub>G =\n                            \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            G =\n                            \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                            A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F", "from \\<open>([(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<^sub>G) = \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G\\<close>"], ["proof (chain)\npicking this:\n  [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<^sub>G =\n  \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G", "have \"([(x, y)] \\<bullet> [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<^sub>G) = [(x, y)] \\<bullet> (\\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G)\""], ["proof (prove)\nusing this:\n  [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<^sub>G =\n  \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G\n\ngoal (1 subgoal):\n 1. [(x, y)] \\<bullet> [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<^sub>G =\n    [(x, y)] \\<bullet> \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G", "by simp"], ["proof (state)\nthis:\n  [(x, y)] \\<bullet> [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<^sub>G =\n  [(x, y)] \\<bullet> \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G\n\ngoal (1 subgoal):\n 1. \\<And>name frame G A\\<^sub>F\\<^sub>G \\<Psi>\\<^sub>F\\<^sub>G.\n       \\<lbrakk>name \\<sharp> G; name \\<sharp> A\\<^sub>F\\<^sub>G;\n        name \\<sharp> \\<Psi>\\<^sub>F\\<^sub>G;\n        \\<And>b ba bb.\n           \\<lbrakk>frame \\<otimes>\\<^sub>F b = \\<langle>ba, bb\\<rangle>;\n            distinct ba; ba \\<sharp>* frame; ba \\<sharp>* b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                                \\<Psi>\\<^sub>G.\n                                ba = A\\<^sub>F @ A\\<^sub>G \\<and>\n                                bb =\n                                \\<Psi>\\<^sub>F \\<otimes>\n                                \\<Psi>\\<^sub>G \\<and>\n                                frame =\n                                \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                b =\n                                \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                                A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                                A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F;\n        (\\<lparr>\\<nu>name\\<rparr>frame) \\<otimes>\\<^sub>F G =\n        \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>;\n        distinct A\\<^sub>F\\<^sub>G;\n        A\\<^sub>F\\<^sub>G \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F\\<^sub>G \\<sharp>* G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                            \\<Psi>\\<^sub>G.\n                            A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n                            \\<Psi>\\<^sub>F\\<^sub>G =\n                            \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            G =\n                            \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                            A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F", "with \\<open>x \\<sharp> \\<Psi>\\<^sub>G\\<close> \\<open>y \\<sharp> \\<Psi>\\<^sub>G\\<close>"], ["proof (chain)\npicking this:\n  x \\<sharp> \\<Psi>\\<^sub>G\n  y \\<sharp> \\<Psi>\\<^sub>G\n  [(x, y)] \\<bullet> [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<^sub>G =\n  [(x, y)] \\<bullet> \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G", "have \"\\<Psi>\\<^sub>F\\<^sub>G = ([(x, y)] \\<bullet> \\<Psi>\\<^sub>F) \\<otimes> \\<Psi>\\<^sub>G\""], ["proof (prove)\nusing this:\n  x \\<sharp> \\<Psi>\\<^sub>G\n  y \\<sharp> \\<Psi>\\<^sub>G\n  [(x, y)] \\<bullet> [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<^sub>G =\n  [(x, y)] \\<bullet> \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>F\\<^sub>G =\n    ([(x, y)] \\<bullet> \\<Psi>\\<^sub>F) \\<otimes> \\<Psi>\\<^sub>G", "by(simp add: eqvts)"], ["proof (state)\nthis:\n  \\<Psi>\\<^sub>F\\<^sub>G =\n  ([(x, y)] \\<bullet> \\<Psi>\\<^sub>F) \\<otimes> \\<Psi>\\<^sub>G\n\ngoal (1 subgoal):\n 1. \\<And>name frame G A\\<^sub>F\\<^sub>G \\<Psi>\\<^sub>F\\<^sub>G.\n       \\<lbrakk>name \\<sharp> G; name \\<sharp> A\\<^sub>F\\<^sub>G;\n        name \\<sharp> \\<Psi>\\<^sub>F\\<^sub>G;\n        \\<And>b ba bb.\n           \\<lbrakk>frame \\<otimes>\\<^sub>F b = \\<langle>ba, bb\\<rangle>;\n            distinct ba; ba \\<sharp>* frame; ba \\<sharp>* b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                                \\<Psi>\\<^sub>G.\n                                ba = A\\<^sub>F @ A\\<^sub>G \\<and>\n                                bb =\n                                \\<Psi>\\<^sub>F \\<otimes>\n                                \\<Psi>\\<^sub>G \\<and>\n                                frame =\n                                \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                b =\n                                \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                                A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                                A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F;\n        (\\<lparr>\\<nu>name\\<rparr>frame) \\<otimes>\\<^sub>F G =\n        \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>;\n        distinct A\\<^sub>F\\<^sub>G;\n        A\\<^sub>F\\<^sub>G \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F\\<^sub>G \\<sharp>* G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                            \\<Psi>\\<^sub>G.\n                            A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n                            \\<Psi>\\<^sub>F\\<^sub>G =\n                            \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            G =\n                            \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                            A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F", "moreover"], ["proof (state)\nthis:\n  \\<Psi>\\<^sub>F\\<^sub>G =\n  ([(x, y)] \\<bullet> \\<Psi>\\<^sub>F) \\<otimes> \\<Psi>\\<^sub>G\n\ngoal (1 subgoal):\n 1. \\<And>name frame G A\\<^sub>F\\<^sub>G \\<Psi>\\<^sub>F\\<^sub>G.\n       \\<lbrakk>name \\<sharp> G; name \\<sharp> A\\<^sub>F\\<^sub>G;\n        name \\<sharp> \\<Psi>\\<^sub>F\\<^sub>G;\n        \\<And>b ba bb.\n           \\<lbrakk>frame \\<otimes>\\<^sub>F b = \\<langle>ba, bb\\<rangle>;\n            distinct ba; ba \\<sharp>* frame; ba \\<sharp>* b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                                \\<Psi>\\<^sub>G.\n                                ba = A\\<^sub>F @ A\\<^sub>G \\<and>\n                                bb =\n                                \\<Psi>\\<^sub>F \\<otimes>\n                                \\<Psi>\\<^sub>G \\<and>\n                                frame =\n                                \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                b =\n                                \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                                A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                                A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F;\n        (\\<lparr>\\<nu>name\\<rparr>frame) \\<otimes>\\<^sub>F G =\n        \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>;\n        distinct A\\<^sub>F\\<^sub>G;\n        A\\<^sub>F\\<^sub>G \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F\\<^sub>G \\<sharp>* G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                            \\<Psi>\\<^sub>G.\n                            A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n                            \\<Psi>\\<^sub>F\\<^sub>G =\n                            \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            G =\n                            \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                            A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F", "from FrF"], ["proof (chain)\npicking this:\n  F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>", "have \"([(x, y)] \\<bullet> F) = [(x, y)] \\<bullet> \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\""], ["proof (prove)\nusing this:\n  F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\n\ngoal (1 subgoal):\n 1. [(x, y)] \\<bullet> F =\n    [(x, y)] \\<bullet> \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>", "by simp"], ["proof (state)\nthis:\n  [(x, y)] \\<bullet> F =\n  [(x, y)] \\<bullet> \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>name frame G A\\<^sub>F\\<^sub>G \\<Psi>\\<^sub>F\\<^sub>G.\n       \\<lbrakk>name \\<sharp> G; name \\<sharp> A\\<^sub>F\\<^sub>G;\n        name \\<sharp> \\<Psi>\\<^sub>F\\<^sub>G;\n        \\<And>b ba bb.\n           \\<lbrakk>frame \\<otimes>\\<^sub>F b = \\<langle>ba, bb\\<rangle>;\n            distinct ba; ba \\<sharp>* frame; ba \\<sharp>* b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                                \\<Psi>\\<^sub>G.\n                                ba = A\\<^sub>F @ A\\<^sub>G \\<and>\n                                bb =\n                                \\<Psi>\\<^sub>F \\<otimes>\n                                \\<Psi>\\<^sub>G \\<and>\n                                frame =\n                                \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                b =\n                                \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                                A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                                A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F;\n        (\\<lparr>\\<nu>name\\<rparr>frame) \\<otimes>\\<^sub>F G =\n        \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>;\n        distinct A\\<^sub>F\\<^sub>G;\n        A\\<^sub>F\\<^sub>G \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F\\<^sub>G \\<sharp>* G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                            \\<Psi>\\<^sub>G.\n                            A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n                            \\<Psi>\\<^sub>F\\<^sub>G =\n                            \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            G =\n                            \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                            A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F", "with \\<open>x \\<sharp> A\\<^sub>F\\<close> \\<open>y \\<sharp> A\\<^sub>F\\<close>"], ["proof (chain)\npicking this:\n  x \\<sharp> A\\<^sub>F\n  y \\<sharp> A\\<^sub>F\n  [(x, y)] \\<bullet> F =\n  [(x, y)] \\<bullet> \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>", "have \"([(x, y)] \\<bullet> F) = \\<langle>A\\<^sub>F, [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<rangle>\""], ["proof (prove)\nusing this:\n  x \\<sharp> A\\<^sub>F\n  y \\<sharp> A\\<^sub>F\n  [(x, y)] \\<bullet> F =\n  [(x, y)] \\<bullet> \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\n\ngoal (1 subgoal):\n 1. [(x, y)] \\<bullet> F =\n    \\<langle>A\\<^sub>F, [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<rangle>", "by(simp add: eqvts)"], ["proof (state)\nthis:\n  [(x, y)] \\<bullet> F =\n  \\<langle>A\\<^sub>F, [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>name frame G A\\<^sub>F\\<^sub>G \\<Psi>\\<^sub>F\\<^sub>G.\n       \\<lbrakk>name \\<sharp> G; name \\<sharp> A\\<^sub>F\\<^sub>G;\n        name \\<sharp> \\<Psi>\\<^sub>F\\<^sub>G;\n        \\<And>b ba bb.\n           \\<lbrakk>frame \\<otimes>\\<^sub>F b = \\<langle>ba, bb\\<rangle>;\n            distinct ba; ba \\<sharp>* frame; ba \\<sharp>* b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                                \\<Psi>\\<^sub>G.\n                                ba = A\\<^sub>F @ A\\<^sub>G \\<and>\n                                bb =\n                                \\<Psi>\\<^sub>F \\<otimes>\n                                \\<Psi>\\<^sub>G \\<and>\n                                frame =\n                                \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                b =\n                                \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                                A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                                A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F;\n        (\\<lparr>\\<nu>name\\<rparr>frame) \\<otimes>\\<^sub>F G =\n        \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>;\n        distinct A\\<^sub>F\\<^sub>G;\n        A\\<^sub>F\\<^sub>G \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F\\<^sub>G \\<sharp>* G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                            \\<Psi>\\<^sub>G.\n                            A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n                            \\<Psi>\\<^sub>F\\<^sub>G =\n                            \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            G =\n                            \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                            A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F", "hence \"\\<lparr>\\<nu>y\\<rparr>([(x, y)] \\<bullet> F) = \\<langle>(y#A\\<^sub>F), [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<rangle>\""], ["proof (prove)\nusing this:\n  [(x, y)] \\<bullet> F =\n  \\<langle>A\\<^sub>F, [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet> F =\n    \\<langle>(y # A\\<^sub>F), [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<rangle>", "by(simp add: frame.inject)"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet> F =\n  \\<langle>(y # A\\<^sub>F), [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>name frame G A\\<^sub>F\\<^sub>G \\<Psi>\\<^sub>F\\<^sub>G.\n       \\<lbrakk>name \\<sharp> G; name \\<sharp> A\\<^sub>F\\<^sub>G;\n        name \\<sharp> \\<Psi>\\<^sub>F\\<^sub>G;\n        \\<And>b ba bb.\n           \\<lbrakk>frame \\<otimes>\\<^sub>F b = \\<langle>ba, bb\\<rangle>;\n            distinct ba; ba \\<sharp>* frame; ba \\<sharp>* b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                                \\<Psi>\\<^sub>G.\n                                ba = A\\<^sub>F @ A\\<^sub>G \\<and>\n                                bb =\n                                \\<Psi>\\<^sub>F \\<otimes>\n                                \\<Psi>\\<^sub>G \\<and>\n                                frame =\n                                \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                b =\n                                \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                                A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                                A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F;\n        (\\<lparr>\\<nu>name\\<rparr>frame) \\<otimes>\\<^sub>F G =\n        \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>;\n        distinct A\\<^sub>F\\<^sub>G;\n        A\\<^sub>F\\<^sub>G \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F\\<^sub>G \\<sharp>* G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                            \\<Psi>\\<^sub>G.\n                            A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n                            \\<Psi>\\<^sub>F\\<^sub>G =\n                            \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            G =\n                            \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                            A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F", "with \\<open>y \\<sharp> F\\<close>"], ["proof (chain)\npicking this:\n  y \\<sharp> F\n  \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet> F =\n  \\<langle>(y # A\\<^sub>F), [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<rangle>", "have \"\\<lparr>\\<nu>x\\<rparr>F = \\<langle>(y#A\\<^sub>F), [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<rangle>\""], ["proof (prove)\nusing this:\n  y \\<sharp> F\n  \\<lparr>\\<nu>y\\<rparr>[(x, y)] \\<bullet> F =\n  \\<langle>(y # A\\<^sub>F), [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>F =\n    \\<langle>(y # A\\<^sub>F), [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<rangle>", "by(simp add: alphaFrameRes)"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>F =\n  \\<langle>(y # A\\<^sub>F), [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>name frame G A\\<^sub>F\\<^sub>G \\<Psi>\\<^sub>F\\<^sub>G.\n       \\<lbrakk>name \\<sharp> G; name \\<sharp> A\\<^sub>F\\<^sub>G;\n        name \\<sharp> \\<Psi>\\<^sub>F\\<^sub>G;\n        \\<And>b ba bb.\n           \\<lbrakk>frame \\<otimes>\\<^sub>F b = \\<langle>ba, bb\\<rangle>;\n            distinct ba; ba \\<sharp>* frame; ba \\<sharp>* b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                                \\<Psi>\\<^sub>G.\n                                ba = A\\<^sub>F @ A\\<^sub>G \\<and>\n                                bb =\n                                \\<Psi>\\<^sub>F \\<otimes>\n                                \\<Psi>\\<^sub>G \\<and>\n                                frame =\n                                \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                b =\n                                \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                                A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                                A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F;\n        (\\<lparr>\\<nu>name\\<rparr>frame) \\<otimes>\\<^sub>F G =\n        \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>;\n        distinct A\\<^sub>F\\<^sub>G;\n        A\\<^sub>F\\<^sub>G \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F\\<^sub>G \\<sharp>* G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                            \\<Psi>\\<^sub>G.\n                            A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n                            \\<Psi>\\<^sub>F\\<^sub>G =\n                            \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            G =\n                            \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                            A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F", "moreover"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>F =\n  \\<langle>(y # A\\<^sub>F), [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>name frame G A\\<^sub>F\\<^sub>G \\<Psi>\\<^sub>F\\<^sub>G.\n       \\<lbrakk>name \\<sharp> G; name \\<sharp> A\\<^sub>F\\<^sub>G;\n        name \\<sharp> \\<Psi>\\<^sub>F\\<^sub>G;\n        \\<And>b ba bb.\n           \\<lbrakk>frame \\<otimes>\\<^sub>F b = \\<langle>ba, bb\\<rangle>;\n            distinct ba; ba \\<sharp>* frame; ba \\<sharp>* b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                                \\<Psi>\\<^sub>G.\n                                ba = A\\<^sub>F @ A\\<^sub>G \\<and>\n                                bb =\n                                \\<Psi>\\<^sub>F \\<otimes>\n                                \\<Psi>\\<^sub>G \\<and>\n                                frame =\n                                \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                b =\n                                \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                                A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                                A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F;\n        (\\<lparr>\\<nu>name\\<rparr>frame) \\<otimes>\\<^sub>F G =\n        \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>;\n        distinct A\\<^sub>F\\<^sub>G;\n        A\\<^sub>F\\<^sub>G \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F\\<^sub>G \\<sharp>* G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                            \\<Psi>\\<^sub>G.\n                            A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n                            \\<Psi>\\<^sub>F\\<^sub>G =\n                            \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            G =\n                            \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                            A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F", "with \\<open>A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\\<close>"], ["proof (chain)\npicking this:\n  A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\n  \\<lparr>\\<nu>x\\<rparr>F =\n  \\<langle>(y # A\\<^sub>F), [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<rangle>", "have \"([(x, y)] \\<bullet> A\\<^sub>G) \\<sharp>* ([(x, y)] \\<bullet> \\<Psi>\\<^sub>F)\""], ["proof (prove)\nusing this:\n  A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\n  \\<lparr>\\<nu>x\\<rparr>F =\n  \\<langle>(y # A\\<^sub>F), [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<rangle>\n\ngoal (1 subgoal):\n 1. ([(x, y)] \\<bullet>\n     A\\<^sub>G) \\<sharp>* ([(x, y)] \\<bullet> \\<Psi>\\<^sub>F)", "by(simp add: pt_fresh_star_bij[OF pt_name_inst, OF at_name_inst])"], ["proof (state)\nthis:\n  ([(x, y)] \\<bullet>\n   A\\<^sub>G) \\<sharp>* ([(x, y)] \\<bullet> \\<Psi>\\<^sub>F)\n\ngoal (1 subgoal):\n 1. \\<And>name frame G A\\<^sub>F\\<^sub>G \\<Psi>\\<^sub>F\\<^sub>G.\n       \\<lbrakk>name \\<sharp> G; name \\<sharp> A\\<^sub>F\\<^sub>G;\n        name \\<sharp> \\<Psi>\\<^sub>F\\<^sub>G;\n        \\<And>b ba bb.\n           \\<lbrakk>frame \\<otimes>\\<^sub>F b = \\<langle>ba, bb\\<rangle>;\n            distinct ba; ba \\<sharp>* frame; ba \\<sharp>* b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                                \\<Psi>\\<^sub>G.\n                                ba = A\\<^sub>F @ A\\<^sub>G \\<and>\n                                bb =\n                                \\<Psi>\\<^sub>F \\<otimes>\n                                \\<Psi>\\<^sub>G \\<and>\n                                frame =\n                                \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                b =\n                                \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                                A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                                A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F;\n        (\\<lparr>\\<nu>name\\<rparr>frame) \\<otimes>\\<^sub>F G =\n        \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>;\n        distinct A\\<^sub>F\\<^sub>G;\n        A\\<^sub>F\\<^sub>G \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F\\<^sub>G \\<sharp>* G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                            \\<Psi>\\<^sub>G.\n                            A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n                            \\<Psi>\\<^sub>F\\<^sub>G =\n                            \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            G =\n                            \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                            A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F", "with \\<open>x \\<sharp> A\\<^sub>G\\<close> \\<open>y \\<sharp> A\\<^sub>G\\<close>"], ["proof (chain)\npicking this:\n  x \\<sharp> A\\<^sub>G\n  y \\<sharp> A\\<^sub>G\n  ([(x, y)] \\<bullet>\n   A\\<^sub>G) \\<sharp>* ([(x, y)] \\<bullet> \\<Psi>\\<^sub>F)", "have \"A\\<^sub>G \\<sharp>* ([(x, y)] \\<bullet> \\<Psi>\\<^sub>F)\""], ["proof (prove)\nusing this:\n  x \\<sharp> A\\<^sub>G\n  y \\<sharp> A\\<^sub>G\n  ([(x, y)] \\<bullet>\n   A\\<^sub>G) \\<sharp>* ([(x, y)] \\<bullet> \\<Psi>\\<^sub>F)\n\ngoal (1 subgoal):\n 1. A\\<^sub>G \\<sharp>* ([(x, y)] \\<bullet> \\<Psi>\\<^sub>F)", "by simp"], ["proof (state)\nthis:\n  A\\<^sub>G \\<sharp>* ([(x, y)] \\<bullet> \\<Psi>\\<^sub>F)\n\ngoal (1 subgoal):\n 1. \\<And>name frame G A\\<^sub>F\\<^sub>G \\<Psi>\\<^sub>F\\<^sub>G.\n       \\<lbrakk>name \\<sharp> G; name \\<sharp> A\\<^sub>F\\<^sub>G;\n        name \\<sharp> \\<Psi>\\<^sub>F\\<^sub>G;\n        \\<And>b ba bb.\n           \\<lbrakk>frame \\<otimes>\\<^sub>F b = \\<langle>ba, bb\\<rangle>;\n            distinct ba; ba \\<sharp>* frame; ba \\<sharp>* b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                                \\<Psi>\\<^sub>G.\n                                ba = A\\<^sub>F @ A\\<^sub>G \\<and>\n                                bb =\n                                \\<Psi>\\<^sub>F \\<otimes>\n                                \\<Psi>\\<^sub>G \\<and>\n                                frame =\n                                \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                b =\n                                \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                                A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                                A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F;\n        (\\<lparr>\\<nu>name\\<rparr>frame) \\<otimes>\\<^sub>F G =\n        \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>;\n        distinct A\\<^sub>F\\<^sub>G;\n        A\\<^sub>F\\<^sub>G \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F\\<^sub>G \\<sharp>* G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                            \\<Psi>\\<^sub>G.\n                            A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n                            \\<Psi>\\<^sub>F\\<^sub>G =\n                            \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            G =\n                            \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                            A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F", "moreover"], ["proof (state)\nthis:\n  A\\<^sub>G \\<sharp>* ([(x, y)] \\<bullet> \\<Psi>\\<^sub>F)\n\ngoal (1 subgoal):\n 1. \\<And>name frame G A\\<^sub>F\\<^sub>G \\<Psi>\\<^sub>F\\<^sub>G.\n       \\<lbrakk>name \\<sharp> G; name \\<sharp> A\\<^sub>F\\<^sub>G;\n        name \\<sharp> \\<Psi>\\<^sub>F\\<^sub>G;\n        \\<And>b ba bb.\n           \\<lbrakk>frame \\<otimes>\\<^sub>F b = \\<langle>ba, bb\\<rangle>;\n            distinct ba; ba \\<sharp>* frame; ba \\<sharp>* b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                                \\<Psi>\\<^sub>G.\n                                ba = A\\<^sub>F @ A\\<^sub>G \\<and>\n                                bb =\n                                \\<Psi>\\<^sub>F \\<otimes>\n                                \\<Psi>\\<^sub>G \\<and>\n                                frame =\n                                \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                b =\n                                \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                                A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                                A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F;\n        (\\<lparr>\\<nu>name\\<rparr>frame) \\<otimes>\\<^sub>F G =\n        \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>;\n        distinct A\\<^sub>F\\<^sub>G;\n        A\\<^sub>F\\<^sub>G \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F\\<^sub>G \\<sharp>* G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                            \\<Psi>\\<^sub>G.\n                            A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n                            \\<Psi>\\<^sub>F\\<^sub>G =\n                            \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            G =\n                            \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                            A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F", "from \\<open>A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G\\<close> \\<open>y \\<sharp> \\<Psi>\\<^sub>G\\<close>"], ["proof (chain)\npicking this:\n  A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G\n  y \\<sharp> \\<Psi>\\<^sub>G", "have \"(y#A\\<^sub>F) \\<sharp>* \\<Psi>\\<^sub>G\""], ["proof (prove)\nusing this:\n  A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G\n  y \\<sharp> \\<Psi>\\<^sub>G\n\ngoal (1 subgoal):\n 1. (y # A\\<^sub>F) \\<sharp>* \\<Psi>\\<^sub>G", "by simp"], ["proof (state)\nthis:\n  (y # A\\<^sub>F) \\<sharp>* \\<Psi>\\<^sub>G\n\ngoal (1 subgoal):\n 1. \\<And>name frame G A\\<^sub>F\\<^sub>G \\<Psi>\\<^sub>F\\<^sub>G.\n       \\<lbrakk>name \\<sharp> G; name \\<sharp> A\\<^sub>F\\<^sub>G;\n        name \\<sharp> \\<Psi>\\<^sub>F\\<^sub>G;\n        \\<And>b ba bb.\n           \\<lbrakk>frame \\<otimes>\\<^sub>F b = \\<langle>ba, bb\\<rangle>;\n            distinct ba; ba \\<sharp>* frame; ba \\<sharp>* b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                                \\<Psi>\\<^sub>G.\n                                ba = A\\<^sub>F @ A\\<^sub>G \\<and>\n                                bb =\n                                \\<Psi>\\<^sub>F \\<otimes>\n                                \\<Psi>\\<^sub>G \\<and>\n                                frame =\n                                \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                                b =\n                                \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                                A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                                A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F;\n        (\\<lparr>\\<nu>name\\<rparr>frame) \\<otimes>\\<^sub>F G =\n        \\<langle>A\\<^sub>F\\<^sub>G, \\<Psi>\\<^sub>F\\<^sub>G\\<rangle>;\n        distinct A\\<^sub>F\\<^sub>G;\n        A\\<^sub>F\\<^sub>G \\<sharp>* (\\<lparr>\\<nu>name\\<rparr>frame);\n        A\\<^sub>F\\<^sub>G \\<sharp>* G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G\n                            \\<Psi>\\<^sub>G.\n                            A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n                            \\<Psi>\\<^sub>F\\<^sub>G =\n                            \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n                            \\<lparr>\\<nu>name\\<rparr>frame =\n                            \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n                            G =\n                            \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n                            A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n                            A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F", "ultimately"], ["proof (chain)\npicking this:\n  A\\<^sub>F\\<^sub>G = (y # A\\<^sub>F) @ A\\<^sub>G\n  \\<Psi>\\<^sub>F\\<^sub>G =\n  ([(x, y)] \\<bullet> \\<Psi>\\<^sub>F) \\<otimes> \\<Psi>\\<^sub>G\n  \\<lparr>\\<nu>x\\<rparr>F =\n  \\<langle>(y # A\\<^sub>F), [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<rangle>\n  A\\<^sub>G \\<sharp>* ([(x, y)] \\<bullet> \\<Psi>\\<^sub>F)\n  (y # A\\<^sub>F) \\<sharp>* \\<Psi>\\<^sub>G", "show ?case"], ["proof (prove)\nusing this:\n  A\\<^sub>F\\<^sub>G = (y # A\\<^sub>F) @ A\\<^sub>G\n  \\<Psi>\\<^sub>F\\<^sub>G =\n  ([(x, y)] \\<bullet> \\<Psi>\\<^sub>F) \\<otimes> \\<Psi>\\<^sub>G\n  \\<lparr>\\<nu>x\\<rparr>F =\n  \\<langle>(y # A\\<^sub>F), [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<rangle>\n  A\\<^sub>G \\<sharp>* ([(x, y)] \\<bullet> \\<Psi>\\<^sub>F)\n  (y # A\\<^sub>F) \\<sharp>* \\<Psi>\\<^sub>G\n\ngoal (1 subgoal):\n 1. \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G \\<Psi>\\<^sub>G.\n       A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n       \\<Psi>\\<^sub>F\\<^sub>G =\n       \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n       \\<lparr>\\<nu>x\\<rparr>F =\n       \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n       A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n       A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F", "using FrG"], ["proof (prove)\nusing this:\n  A\\<^sub>F\\<^sub>G = (y # A\\<^sub>F) @ A\\<^sub>G\n  \\<Psi>\\<^sub>F\\<^sub>G =\n  ([(x, y)] \\<bullet> \\<Psi>\\<^sub>F) \\<otimes> \\<Psi>\\<^sub>G\n  \\<lparr>\\<nu>x\\<rparr>F =\n  \\<langle>(y # A\\<^sub>F), [(x, y)] \\<bullet> \\<Psi>\\<^sub>F\\<rangle>\n  A\\<^sub>G \\<sharp>* ([(x, y)] \\<bullet> \\<Psi>\\<^sub>F)\n  (y # A\\<^sub>F) \\<sharp>* \\<Psi>\\<^sub>G\n  G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G \\<Psi>\\<^sub>G.\n       A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n       \\<Psi>\\<^sub>F\\<^sub>G =\n       \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n       \\<lparr>\\<nu>x\\<rparr>F =\n       \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n       G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n       A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n       A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F", "by blast"], ["proof (state)\nthis:\n  \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G \\<Psi>\\<^sub>G.\n     A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n     \\<Psi>\\<^sub>F\\<^sub>G = \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n     \\<lparr>\\<nu>x\\<rparr>F =\n     \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n     G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n     A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n     A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G \\<Psi>\\<^sub>G.\n     A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n     \\<Psi>\\<^sub>F\\<^sub>G = \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n     F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n     G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n     A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n     A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\n\ngoal (1 subgoal):\n 1. (\\<And>A\\<^sub>F A\\<^sub>G \\<Psi>\\<^sub>F \\<Psi>\\<^sub>G.\n        \\<lbrakk>A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G;\n         \\<Psi>\\<^sub>F\\<^sub>G = \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G;\n         F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>;\n         G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle>;\n         A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G;\n         A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with A"], ["proof (chain)\npicking this:\n  \\<lbrakk>A\\<^sub>F\\<^sub>G = ?A\\<^sub>F @ ?A\\<^sub>G;\n   \\<Psi>\\<^sub>F\\<^sub>G = ?\\<Psi>\\<^sub>F \\<otimes> ?\\<Psi>\\<^sub>G;\n   F = \\<langle>?A\\<^sub>F, ?\\<Psi>\\<^sub>F\\<rangle>;\n   G = \\<langle>?A\\<^sub>G, ?\\<Psi>\\<^sub>G\\<rangle>;\n   ?A\\<^sub>F \\<sharp>* ?\\<Psi>\\<^sub>G;\n   ?A\\<^sub>G \\<sharp>* ?\\<Psi>\\<^sub>F\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G \\<Psi>\\<^sub>G.\n     A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n     \\<Psi>\\<^sub>F\\<^sub>G = \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n     F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n     G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n     A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n     A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>A\\<^sub>F\\<^sub>G = ?A\\<^sub>F @ ?A\\<^sub>G;\n   \\<Psi>\\<^sub>F\\<^sub>G = ?\\<Psi>\\<^sub>F \\<otimes> ?\\<Psi>\\<^sub>G;\n   F = \\<langle>?A\\<^sub>F, ?\\<Psi>\\<^sub>F\\<rangle>;\n   G = \\<langle>?A\\<^sub>G, ?\\<Psi>\\<^sub>G\\<rangle>;\n   ?A\\<^sub>F \\<sharp>* ?\\<Psi>\\<^sub>G;\n   ?A\\<^sub>G \\<sharp>* ?\\<Psi>\\<^sub>F\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<exists>A\\<^sub>F \\<Psi>\\<^sub>F A\\<^sub>G \\<Psi>\\<^sub>G.\n     A\\<^sub>F\\<^sub>G = A\\<^sub>F @ A\\<^sub>G \\<and>\n     \\<Psi>\\<^sub>F\\<^sub>G = \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G \\<and>\n     F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle> \\<and>\n     G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> \\<and>\n     A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G \\<and>\n     A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mergeFrameRes1[simp]:\n  fixes A\\<^sub>F :: \"name list\"\n  and   \\<Psi>\\<^sub>F :: 'b\n  and   x   :: name\n  and   A\\<^sub>G :: \"name list\"\n  and   \\<Psi>\\<^sub>G :: 'b\n  \n  assumes \"A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G\"\n  and     \"A\\<^sub>F \\<sharp>* A\\<^sub>G\"\n  and     \"x \\<sharp> A\\<^sub>F\"\n  and     \"x \\<sharp> \\<Psi>\\<^sub>F\"\n  and     \"A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\"\n  \n  shows \"(\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>) \\<otimes>\\<^sub>F (\\<lparr>\\<nu>x\\<rparr>(\\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle>)) = (\\<langle>(A\\<^sub>F@x#A\\<^sub>G), \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>) \\<otimes>\\<^sub>F\n    \\<lparr>\\<nu>x\\<rparr>\\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> =\n    \\<langle>(A\\<^sub>F @\n              x #\n              A\\<^sub>G), \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G\\<rangle>", "using assms"], ["proof (prove)\nusing this:\n  A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G\n  A\\<^sub>F \\<sharp>* A\\<^sub>G\n  x \\<sharp> A\\<^sub>F\n  x \\<sharp> \\<Psi>\\<^sub>F\n  A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\n\ngoal (1 subgoal):\n 1. (\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>) \\<otimes>\\<^sub>F\n    \\<lparr>\\<nu>x\\<rparr>\\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> =\n    \\<langle>(A\\<^sub>F @\n              x #\n              A\\<^sub>G), \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G\\<rangle>", "apply(fold frameResChain.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G;\n     A\\<^sub>F \\<sharp>* A\\<^sub>G; x \\<sharp> A\\<^sub>F;\n     x \\<sharp> \\<Psi>\\<^sub>F; A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\\<rbrakk>\n    \\<Longrightarrow> (\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>) \\<otimes>\\<^sub>F\n                      \\<langle>(x # A\\<^sub>G), \\<Psi>\\<^sub>G\\<rangle> =\n                      \\<langle>(A\\<^sub>F @\n                                x #\n                                A\\<^sub>G), \\<Psi>\\<^sub>F \\<otimes>\n      \\<Psi>\\<^sub>G\\<rangle>", "by(rule mergeFrames) auto"], ["", "lemma mergeFrameRes2[simp]:\n  fixes A\\<^sub>F :: \"name list\"\n  and   \\<Psi>\\<^sub>F :: 'b\n  and   x   :: name\n  and   A\\<^sub>G :: \"name list\"\n  and   \\<Psi>\\<^sub>G :: 'b\n  \n  assumes \"A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G\"\n  and     \"A\\<^sub>G \\<sharp>* A\\<^sub>F\"\n  and     \"x \\<sharp> A\\<^sub>F\"\n  and     \"x \\<sharp> \\<Psi>\\<^sub>F\"\n  and     \"A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\"\n  \n  shows \"(\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>) \\<otimes>\\<^sub>F (\\<lparr>\\<nu>x\\<rparr>(\\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle>)) = (\\<langle>(A\\<^sub>F@x#A\\<^sub>G), \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>) \\<otimes>\\<^sub>F\n    \\<lparr>\\<nu>x\\<rparr>\\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> =\n    \\<langle>(A\\<^sub>F @\n              x #\n              A\\<^sub>G), \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G\\<rangle>", "using assms"], ["proof (prove)\nusing this:\n  A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G\n  A\\<^sub>G \\<sharp>* A\\<^sub>F\n  x \\<sharp> A\\<^sub>F\n  x \\<sharp> \\<Psi>\\<^sub>F\n  A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\n\ngoal (1 subgoal):\n 1. (\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>) \\<otimes>\\<^sub>F\n    \\<lparr>\\<nu>x\\<rparr>\\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle> =\n    \\<langle>(A\\<^sub>F @\n              x #\n              A\\<^sub>G), \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<^sub>G\\<rangle>", "apply(fold frameResChain.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G;\n     A\\<^sub>G \\<sharp>* A\\<^sub>F; x \\<sharp> A\\<^sub>F;\n     x \\<sharp> \\<Psi>\\<^sub>F; A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\\<rbrakk>\n    \\<Longrightarrow> (\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>) \\<otimes>\\<^sub>F\n                      \\<langle>(x # A\\<^sub>G), \\<Psi>\\<^sub>G\\<rangle> =\n                      \\<langle>(A\\<^sub>F @\n                                x #\n                                A\\<^sub>G), \\<Psi>\\<^sub>F \\<otimes>\n      \\<Psi>\\<^sub>G\\<rangle>", "by(rule mergeFrames) auto"], ["", "lemma insertAssertionResChain[simp]:\n  fixes xvec :: \"name list\"\n  and   F    :: \"'b frame\"\n  and   \\<Psi>   :: 'b\n\n  assumes \"xvec \\<sharp>* \\<Psi>\"\n\n  shows \"insertAssertion (\\<lparr>\\<nu>*xvec\\<rparr>F) \\<Psi> = \\<lparr>\\<nu>*xvec\\<rparr>(insertAssertion F \\<Psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertAssertion (\\<lparr>\\<nu>*xvec\\<rparr>F) \\<Psi> =\n    \\<lparr>\\<nu>*xvec\\<rparr>insertAssertion F \\<Psi>", "using assms"], ["proof (prove)\nusing this:\n  xvec \\<sharp>* \\<Psi>\n\ngoal (1 subgoal):\n 1. insertAssertion (\\<lparr>\\<nu>*xvec\\<rparr>F) \\<Psi> =\n    \\<lparr>\\<nu>*xvec\\<rparr>insertAssertion F \\<Psi>", "by(induct xvec) auto"], ["", "lemma extractFrameResChain[simp]:\n  fixes xvec :: \"name list\"\n  and   P    :: \"('a, 'b, 'c) psi\"\n\n  shows \"extractFrame(\\<lparr>\\<nu>*xvec\\<rparr>P) = \\<lparr>\\<nu>*xvec\\<rparr>(extractFrame P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extractFrame (\\<lparr>\\<nu>*xvec\\<rparr>P) =\n    \\<lparr>\\<nu>*xvec\\<rparr>extractFrame P", "by(induct xvec) auto"], ["", "lemma frameResFreshChain:\n  fixes xvec :: \"name list\"\n  and   F    :: \"'b frame\"\n\n  assumes \"xvec \\<sharp>* F\"\n\n  shows \"\\<lparr>\\<nu>*xvec\\<rparr>F \\<simeq>\\<^sub>F F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>*xvec\\<rparr>F \\<simeq>\\<^sub>F F", "using assms"], ["proof (prove)\nusing this:\n  xvec \\<sharp>* F\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>*xvec\\<rparr>F \\<simeq>\\<^sub>F F", "proof(induct xvec)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<sharp>* F \\<Longrightarrow>\n    \\<lparr>\\<nu>*[]\\<rparr>F \\<simeq>\\<^sub>F F\n 2. \\<And>a xvec.\n       \\<lbrakk>xvec \\<sharp>* F \\<Longrightarrow>\n                \\<lparr>\\<nu>*xvec\\<rparr>F \\<simeq>\\<^sub>F F;\n        (a # xvec) \\<sharp>* F\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>\\<nu>*(a # xvec)\\<rparr>F \\<simeq>\\<^sub>F\n                         F", "case Nil"], ["proof (state)\nthis:\n  [] \\<sharp>* F\n\ngoal (2 subgoals):\n 1. [] \\<sharp>* F \\<Longrightarrow>\n    \\<lparr>\\<nu>*[]\\<rparr>F \\<simeq>\\<^sub>F F\n 2. \\<And>a xvec.\n       \\<lbrakk>xvec \\<sharp>* F \\<Longrightarrow>\n                \\<lparr>\\<nu>*xvec\\<rparr>F \\<simeq>\\<^sub>F F;\n        (a # xvec) \\<sharp>* F\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>\\<nu>*(a # xvec)\\<rparr>F \\<simeq>\\<^sub>F\n                         F", "thus ?case"], ["proof (prove)\nusing this:\n  [] \\<sharp>* F\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>*[]\\<rparr>F \\<simeq>\\<^sub>F F", "by simp"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>*[]\\<rparr>F \\<simeq>\\<^sub>F F\n\ngoal (1 subgoal):\n 1. \\<And>a xvec.\n       \\<lbrakk>xvec \\<sharp>* F \\<Longrightarrow>\n                \\<lparr>\\<nu>*xvec\\<rparr>F \\<simeq>\\<^sub>F F;\n        (a # xvec) \\<sharp>* F\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>\\<nu>*(a # xvec)\\<rparr>F \\<simeq>\\<^sub>F\n                         F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xvec.\n       \\<lbrakk>xvec \\<sharp>* F \\<Longrightarrow>\n                \\<lparr>\\<nu>*xvec\\<rparr>F \\<simeq>\\<^sub>F F;\n        (a # xvec) \\<sharp>* F\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>\\<nu>*(a # xvec)\\<rparr>F \\<simeq>\\<^sub>F\n                         F", "case(Cons x xvec)"], ["proof (state)\nthis:\n  xvec \\<sharp>* F \\<Longrightarrow>\n  \\<lparr>\\<nu>*xvec\\<rparr>F \\<simeq>\\<^sub>F F\n  (x # xvec) \\<sharp>* F\n\ngoal (1 subgoal):\n 1. \\<And>a xvec.\n       \\<lbrakk>xvec \\<sharp>* F \\<Longrightarrow>\n                \\<lparr>\\<nu>*xvec\\<rparr>F \\<simeq>\\<^sub>F F;\n        (a # xvec) \\<sharp>* F\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>\\<nu>*(a # xvec)\\<rparr>F \\<simeq>\\<^sub>F\n                         F", "thus ?case"], ["proof (prove)\nusing this:\n  xvec \\<sharp>* F \\<Longrightarrow>\n  \\<lparr>\\<nu>*xvec\\<rparr>F \\<simeq>\\<^sub>F F\n  (x # xvec) \\<sharp>* F\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>*(x # xvec)\\<rparr>F \\<simeq>\\<^sub>F F", "by auto (metis frameResPres frameResFresh FrameStatEqTrans)"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>*(x # xvec)\\<rparr>F \\<simeq>\\<^sub>F F\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale assertion = assertionAux SCompose SImp SBottom SChanEq\n  for SCompose  :: \"'b::fs_name \\<Rightarrow> 'b \\<Rightarrow> 'b\"\n  and SImp      :: \"'b \\<Rightarrow> 'c::fs_name \\<Rightarrow> bool\"\n  and SBottom   :: 'b\n  and SChanEq   :: \"'a::fs_name \\<Rightarrow> 'a \\<Rightarrow> 'c\" +\n\n  assumes chanEqSym:     \"SImp \\<Psi> (SChanEq M N) \\<Longrightarrow> SImp \\<Psi> (SChanEq N M)\"\n  and     chanEqTrans:   \"\\<lbrakk>SImp \\<Psi> (SChanEq M N); SImp \\<Psi> (SChanEq N L)\\<rbrakk> \\<Longrightarrow> SImp \\<Psi> (SChanEq M L)\"\n  and     Composition:   \"assertionAux.AssertionStatEq SImp \\<Psi> \\<Psi>' \\<Longrightarrow> assertionAux.AssertionStatEq SImp (SCompose \\<Psi> \\<Psi>'') (SCompose \\<Psi>' \\<Psi>'')\"\n  and     Identity:      \"assertionAux.AssertionStatEq SImp (SCompose \\<Psi> SBottom) \\<Psi>\"\n  and     Associativity: \"assertionAux.AssertionStatEq SImp (SCompose (SCompose \\<Psi> \\<Psi>') \\<Psi>'') (SCompose \\<Psi> (SCompose \\<Psi>' \\<Psi>''))\"\n  and     Commutativity: \"assertionAux.AssertionStatEq SImp (SCompose \\<Psi> \\<Psi>') (SCompose \\<Psi>' \\<Psi>)\"\n\nbegin"], ["", "notation SCompose (infixr \"\\<otimes>\" 90)"], ["", "notation SImp (\"_ \\<turnstile> _\" [85, 85] 85)"], ["", "notation SChanEq (\"_ \\<leftrightarrow> _\" [90, 90] 90)"], ["", "notation SBottom (\"\\<bottom>\" 90)"], ["", "lemma compositionSym:\n  fixes \\<Psi>   :: 'b\n  and   \\<Psi>'  :: 'b\n  and   \\<Psi>'' :: 'b\n\n  assumes \"\\<Psi> \\<simeq> \\<Psi>'\"\n\n  shows \"\\<Psi>'' \\<otimes> \\<Psi> \\<simeq> \\<Psi>'' \\<otimes> \\<Psi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi>'' \\<otimes> \\<Psi> \\<simeq> \\<Psi>'' \\<otimes> \\<Psi>'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Psi>'' \\<otimes> \\<Psi> \\<simeq> \\<Psi>'' \\<otimes> \\<Psi>'", "have \"\\<Psi>'' \\<otimes> \\<Psi> \\<simeq> \\<Psi> \\<otimes> \\<Psi>''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi>'' \\<otimes> \\<Psi> \\<simeq> \\<Psi> \\<otimes> \\<Psi>''", "by(rule Commutativity)"], ["proof (state)\nthis:\n  \\<Psi>'' \\<otimes> \\<Psi> \\<simeq> \\<Psi> \\<otimes> \\<Psi>''\n\ngoal (1 subgoal):\n 1. \\<Psi>'' \\<otimes> \\<Psi> \\<simeq> \\<Psi>'' \\<otimes> \\<Psi>'", "moreover"], ["proof (state)\nthis:\n  \\<Psi>'' \\<otimes> \\<Psi> \\<simeq> \\<Psi> \\<otimes> \\<Psi>''\n\ngoal (1 subgoal):\n 1. \\<Psi>'' \\<otimes> \\<Psi> \\<simeq> \\<Psi>'' \\<otimes> \\<Psi>'", "from assms"], ["proof (chain)\npicking this:\n  \\<Psi> \\<simeq> \\<Psi>'", "have \"\\<Psi> \\<otimes> \\<Psi>'' \\<simeq> \\<Psi>' \\<otimes> \\<Psi>''\""], ["proof (prove)\nusing this:\n  \\<Psi> \\<simeq> \\<Psi>'\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<otimes> \\<Psi>'' \\<simeq> \\<Psi>' \\<otimes> \\<Psi>''", "by(rule Composition)"], ["proof (state)\nthis:\n  \\<Psi> \\<otimes> \\<Psi>'' \\<simeq> \\<Psi>' \\<otimes> \\<Psi>''\n\ngoal (1 subgoal):\n 1. \\<Psi>'' \\<otimes> \\<Psi> \\<simeq> \\<Psi>'' \\<otimes> \\<Psi>'", "moreover"], ["proof (state)\nthis:\n  \\<Psi> \\<otimes> \\<Psi>'' \\<simeq> \\<Psi>' \\<otimes> \\<Psi>''\n\ngoal (1 subgoal):\n 1. \\<Psi>'' \\<otimes> \\<Psi> \\<simeq> \\<Psi>'' \\<otimes> \\<Psi>'", "have \"\\<Psi>' \\<otimes> \\<Psi>'' \\<simeq> \\<Psi>'' \\<otimes> \\<Psi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi>' \\<otimes> \\<Psi>'' \\<simeq> \\<Psi>'' \\<otimes> \\<Psi>'", "by(rule Commutativity)"], ["proof (state)\nthis:\n  \\<Psi>' \\<otimes> \\<Psi>'' \\<simeq> \\<Psi>'' \\<otimes> \\<Psi>'\n\ngoal (1 subgoal):\n 1. \\<Psi>'' \\<otimes> \\<Psi> \\<simeq> \\<Psi>'' \\<otimes> \\<Psi>'", "ultimately"], ["proof (chain)\npicking this:\n  \\<Psi>'' \\<otimes> \\<Psi> \\<simeq> \\<Psi> \\<otimes> \\<Psi>''\n  \\<Psi> \\<otimes> \\<Psi>'' \\<simeq> \\<Psi>' \\<otimes> \\<Psi>''\n  \\<Psi>' \\<otimes> \\<Psi>'' \\<simeq> \\<Psi>'' \\<otimes> \\<Psi>'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Psi>'' \\<otimes> \\<Psi> \\<simeq> \\<Psi> \\<otimes> \\<Psi>''\n  \\<Psi> \\<otimes> \\<Psi>'' \\<simeq> \\<Psi>' \\<otimes> \\<Psi>''\n  \\<Psi>' \\<otimes> \\<Psi>'' \\<simeq> \\<Psi>'' \\<otimes> \\<Psi>'\n\ngoal (1 subgoal):\n 1. \\<Psi>'' \\<otimes> \\<Psi> \\<simeq> \\<Psi>'' \\<otimes> \\<Psi>'", "by(blast intro: AssertionStatEqTrans)"], ["proof (state)\nthis:\n  \\<Psi>'' \\<otimes> \\<Psi> \\<simeq> \\<Psi>'' \\<otimes> \\<Psi>'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Composition':\n  fixes \\<Psi>    :: 'b\n  and   \\<Psi>'   :: 'b\n  and   \\<Psi>''  :: 'b\n  and   \\<Psi>''' :: 'b\n\n  assumes \"\\<Psi> \\<simeq> \\<Psi>'\"\n  and     \"\\<Psi>'' \\<simeq> \\<Psi>'''\"\n  \n  shows \"\\<Psi> \\<otimes> \\<Psi>'' \\<simeq> \\<Psi>' \\<otimes> \\<Psi>'''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi> \\<otimes> \\<Psi>'' \\<simeq> \\<Psi>' \\<otimes> \\<Psi>'''", "using assms"], ["proof (prove)\nusing this:\n  \\<Psi> \\<simeq> \\<Psi>'\n  \\<Psi>'' \\<simeq> \\<Psi>'''\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<otimes> \\<Psi>'' \\<simeq> \\<Psi>' \\<otimes> \\<Psi>'''", "by(metis Composition Commutativity AssertionStatEqTrans)"], ["", "lemma composition':\n  fixes \\<Psi>    :: 'b\n  and   \\<Psi>'   :: 'b\n  and   \\<Psi>''  :: 'b\n  and   \\<Psi>''' :: 'b\n\n  assumes \"\\<Psi> \\<simeq> \\<Psi>'\"\n\n  shows \"(\\<Psi> \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>''' \\<simeq> (\\<Psi>' \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>'''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Psi> \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>''' \\<simeq>\n    (\\<Psi>' \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>'''", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Psi> \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>''' \\<simeq>\n    (\\<Psi>' \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>'''", "have \"(\\<Psi> \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>''' \\<simeq> \\<Psi> \\<otimes> (\\<Psi>'' \\<otimes> \\<Psi>''')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Psi> \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>''' \\<simeq>\n    \\<Psi> \\<otimes> \\<Psi>'' \\<otimes> \\<Psi>'''", "by(rule Associativity)"], ["proof (state)\nthis:\n  (\\<Psi> \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>''' \\<simeq>\n  \\<Psi> \\<otimes> \\<Psi>'' \\<otimes> \\<Psi>'''\n\ngoal (1 subgoal):\n 1. (\\<Psi> \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>''' \\<simeq>\n    (\\<Psi>' \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>'''", "moreover"], ["proof (state)\nthis:\n  (\\<Psi> \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>''' \\<simeq>\n  \\<Psi> \\<otimes> \\<Psi>'' \\<otimes> \\<Psi>'''\n\ngoal (1 subgoal):\n 1. (\\<Psi> \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>''' \\<simeq>\n    (\\<Psi>' \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>'''", "from assms"], ["proof (chain)\npicking this:\n  \\<Psi> \\<simeq> \\<Psi>'", "have \"\\<Psi> \\<otimes> (\\<Psi>'' \\<otimes> \\<Psi>''') \\<simeq> \\<Psi>' \\<otimes> (\\<Psi>'' \\<otimes> \\<Psi>''')\""], ["proof (prove)\nusing this:\n  \\<Psi> \\<simeq> \\<Psi>'\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<otimes> \\<Psi>'' \\<otimes> \\<Psi>''' \\<simeq>\n    \\<Psi>' \\<otimes> \\<Psi>'' \\<otimes> \\<Psi>'''", "by(rule Composition)"], ["proof (state)\nthis:\n  \\<Psi> \\<otimes> \\<Psi>'' \\<otimes> \\<Psi>''' \\<simeq>\n  \\<Psi>' \\<otimes> \\<Psi>'' \\<otimes> \\<Psi>'''\n\ngoal (1 subgoal):\n 1. (\\<Psi> \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>''' \\<simeq>\n    (\\<Psi>' \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>'''", "moreover"], ["proof (state)\nthis:\n  \\<Psi> \\<otimes> \\<Psi>'' \\<otimes> \\<Psi>''' \\<simeq>\n  \\<Psi>' \\<otimes> \\<Psi>'' \\<otimes> \\<Psi>'''\n\ngoal (1 subgoal):\n 1. (\\<Psi> \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>''' \\<simeq>\n    (\\<Psi>' \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>'''", "have \"\\<Psi>' \\<otimes> (\\<Psi>'' \\<otimes> \\<Psi>''') \\<simeq> (\\<Psi>' \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>'''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi>' \\<otimes> \\<Psi>'' \\<otimes> \\<Psi>''' \\<simeq>\n    (\\<Psi>' \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>'''", "by(rule Associativity[THEN AssertionStatEqSym])"], ["proof (state)\nthis:\n  \\<Psi>' \\<otimes> \\<Psi>'' \\<otimes> \\<Psi>''' \\<simeq>\n  (\\<Psi>' \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>'''\n\ngoal (1 subgoal):\n 1. (\\<Psi> \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>''' \\<simeq>\n    (\\<Psi>' \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>'''", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Psi> \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>''' \\<simeq>\n  \\<Psi> \\<otimes> \\<Psi>'' \\<otimes> \\<Psi>'''\n  \\<Psi> \\<otimes> \\<Psi>'' \\<otimes> \\<Psi>''' \\<simeq>\n  \\<Psi>' \\<otimes> \\<Psi>'' \\<otimes> \\<Psi>'''\n  \\<Psi>' \\<otimes> \\<Psi>'' \\<otimes> \\<Psi>''' \\<simeq>\n  (\\<Psi>' \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>'''", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Psi> \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>''' \\<simeq>\n  \\<Psi> \\<otimes> \\<Psi>'' \\<otimes> \\<Psi>'''\n  \\<Psi> \\<otimes> \\<Psi>'' \\<otimes> \\<Psi>''' \\<simeq>\n  \\<Psi>' \\<otimes> \\<Psi>'' \\<otimes> \\<Psi>'''\n  \\<Psi>' \\<otimes> \\<Psi>'' \\<otimes> \\<Psi>''' \\<simeq>\n  (\\<Psi>' \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>'''\n\ngoal (1 subgoal):\n 1. (\\<Psi> \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>''' \\<simeq>\n    (\\<Psi>' \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>'''", "by(blast dest: AssertionStatEqTrans)"], ["proof (state)\nthis:\n  (\\<Psi> \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>''' \\<simeq>\n  (\\<Psi>' \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>'''\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma associativitySym:\n  fixes \\<Psi>   :: 'b\n  and   \\<Psi>'  :: 'b\n  and   \\<Psi>'' :: 'b\n  \n  shows \"(\\<Psi> \\<otimes> \\<Psi>') \\<otimes> \\<Psi>'' \\<simeq> (\\<Psi> \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Psi> \\<otimes> \\<Psi>') \\<otimes> \\<Psi>'' \\<simeq>\n    (\\<Psi> \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Psi> \\<otimes> \\<Psi>') \\<otimes> \\<Psi>'' \\<simeq>\n    (\\<Psi> \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>'", "have \"(\\<Psi> \\<otimes> \\<Psi>') \\<otimes> \\<Psi>'' \\<simeq> \\<Psi> \\<otimes> (\\<Psi>' \\<otimes> \\<Psi>'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Psi> \\<otimes> \\<Psi>') \\<otimes> \\<Psi>'' \\<simeq>\n    \\<Psi> \\<otimes> \\<Psi>' \\<otimes> \\<Psi>''", "by(rule Associativity)"], ["proof (state)\nthis:\n  (\\<Psi> \\<otimes> \\<Psi>') \\<otimes> \\<Psi>'' \\<simeq>\n  \\<Psi> \\<otimes> \\<Psi>' \\<otimes> \\<Psi>''\n\ngoal (1 subgoal):\n 1. (\\<Psi> \\<otimes> \\<Psi>') \\<otimes> \\<Psi>'' \\<simeq>\n    (\\<Psi> \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>'", "moreover"], ["proof (state)\nthis:\n  (\\<Psi> \\<otimes> \\<Psi>') \\<otimes> \\<Psi>'' \\<simeq>\n  \\<Psi> \\<otimes> \\<Psi>' \\<otimes> \\<Psi>''\n\ngoal (1 subgoal):\n 1. (\\<Psi> \\<otimes> \\<Psi>') \\<otimes> \\<Psi>'' \\<simeq>\n    (\\<Psi> \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>'", "have \"\\<Psi> \\<otimes> (\\<Psi>' \\<otimes> \\<Psi>'') \\<simeq> \\<Psi> \\<otimes> (\\<Psi>'' \\<otimes> \\<Psi>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi> \\<otimes> \\<Psi>' \\<otimes> \\<Psi>'' \\<simeq>\n    \\<Psi> \\<otimes> \\<Psi>'' \\<otimes> \\<Psi>'", "by(rule compositionSym[OF Commutativity])"], ["proof (state)\nthis:\n  \\<Psi> \\<otimes> \\<Psi>' \\<otimes> \\<Psi>'' \\<simeq>\n  \\<Psi> \\<otimes> \\<Psi>'' \\<otimes> \\<Psi>'\n\ngoal (1 subgoal):\n 1. (\\<Psi> \\<otimes> \\<Psi>') \\<otimes> \\<Psi>'' \\<simeq>\n    (\\<Psi> \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>'", "moreover"], ["proof (state)\nthis:\n  \\<Psi> \\<otimes> \\<Psi>' \\<otimes> \\<Psi>'' \\<simeq>\n  \\<Psi> \\<otimes> \\<Psi>'' \\<otimes> \\<Psi>'\n\ngoal (1 subgoal):\n 1. (\\<Psi> \\<otimes> \\<Psi>') \\<otimes> \\<Psi>'' \\<simeq>\n    (\\<Psi> \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>'", "have \"\\<Psi> \\<otimes> (\\<Psi>'' \\<otimes> \\<Psi>') \\<simeq> (\\<Psi> \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi> \\<otimes> \\<Psi>'' \\<otimes> \\<Psi>' \\<simeq>\n    (\\<Psi> \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>'", "by(rule AssertionStatEqSym[OF Associativity])"], ["proof (state)\nthis:\n  \\<Psi> \\<otimes> \\<Psi>'' \\<otimes> \\<Psi>' \\<simeq>\n  (\\<Psi> \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>'\n\ngoal (1 subgoal):\n 1. (\\<Psi> \\<otimes> \\<Psi>') \\<otimes> \\<Psi>'' \\<simeq>\n    (\\<Psi> \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>'", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Psi> \\<otimes> \\<Psi>') \\<otimes> \\<Psi>'' \\<simeq>\n  \\<Psi> \\<otimes> \\<Psi>' \\<otimes> \\<Psi>''\n  \\<Psi> \\<otimes> \\<Psi>' \\<otimes> \\<Psi>'' \\<simeq>\n  \\<Psi> \\<otimes> \\<Psi>'' \\<otimes> \\<Psi>'\n  \\<Psi> \\<otimes> \\<Psi>'' \\<otimes> \\<Psi>' \\<simeq>\n  (\\<Psi> \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>'", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Psi> \\<otimes> \\<Psi>') \\<otimes> \\<Psi>'' \\<simeq>\n  \\<Psi> \\<otimes> \\<Psi>' \\<otimes> \\<Psi>''\n  \\<Psi> \\<otimes> \\<Psi>' \\<otimes> \\<Psi>'' \\<simeq>\n  \\<Psi> \\<otimes> \\<Psi>'' \\<otimes> \\<Psi>'\n  \\<Psi> \\<otimes> \\<Psi>'' \\<otimes> \\<Psi>' \\<simeq>\n  (\\<Psi> \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>'\n\ngoal (1 subgoal):\n 1. (\\<Psi> \\<otimes> \\<Psi>') \\<otimes> \\<Psi>'' \\<simeq>\n    (\\<Psi> \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>'", "by(blast dest: AssertionStatEqTrans)"], ["proof (state)\nthis:\n  (\\<Psi> \\<otimes> \\<Psi>') \\<otimes> \\<Psi>'' \\<simeq>\n  (\\<Psi> \\<otimes> \\<Psi>'') \\<otimes> \\<Psi>'\n\ngoal:\nNo subgoals!", "qed"], ["", "(*\nlemma frameChanEqSym:\n  fixes F :: \"'b frame\"\n  and   M :: 'a\n  and   N :: 'a\n\n  assumes \"F \\<turnstile>\\<^sub>F M \\<leftrightarrow> N\"\n  \n  shows \"F \\<turnstile>\\<^sub>F N \\<leftrightarrow> M\"\nusing assms\napply(auto simp add: FrameImp_def)\nby(force intro: chanEqSym simp add: FrameImp_def)\n\nlemma frameChanEqTrans:\n  fixes F :: \"'b frame\"\n  and   M :: 'a\n  and   N :: 'a\n\n  assumes \"F \\<turnstile>\\<^sub>F M \\<leftrightarrow> N\"\n  and     \"F \\<turnstile>\\<^sub>F N \\<leftrightarrow> L\"\n  \n  shows \"F \\<turnstile>\\<^sub>F M \\<leftrightarrow> L\"\nproof -\n  obtain A\\<^sub>F \\<Psi>\\<^sub>F where \"F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\" and \"A\\<^sub>F \\<sharp>* (M, N, L)\"\n    by(rule freshFrame)\n  with assms show ?thesis\n    by(force dest: frameImpE intro: frameImpI chanEqTrans)\nqed\n*)"], ["", "lemma frameIntAssociativity:\n  fixes A\\<^sub>F  :: \"name list\"\n  and   \\<Psi>   :: 'b\n  and   \\<Psi>'  :: 'b\n  and   \\<Psi>'' :: 'b\n\n  shows \"\\<langle>A\\<^sub>F, (\\<Psi> \\<otimes> \\<Psi>') \\<otimes> \\<Psi>''\\<rangle> \\<simeq>\\<^sub>F \\<langle>A\\<^sub>F, \\<Psi> \\<otimes> (\\<Psi>' \\<otimes> \\<Psi>'')\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>A\\<^sub>F, (\\<Psi> \\<otimes> \\<Psi>') \\<otimes>\n                        \\<Psi>''\\<rangle> \\<simeq>\\<^sub>F\n    \\<langle>A\\<^sub>F, \\<Psi> \\<otimes> \\<Psi>' \\<otimes> \\<Psi>''\\<rangle>", "by(induct A\\<^sub>F) (auto intro: Associativity frameResPres)"], ["", "lemma frameIntCommutativity:\n  fixes A\\<^sub>F  :: \"name list\"\n  and   \\<Psi>   :: 'b\n  and   \\<Psi>'  :: 'b\n\n  shows \"\\<langle>A\\<^sub>F, \\<Psi> \\<otimes> \\<Psi>'\\<rangle> \\<simeq>\\<^sub>F \\<langle>A\\<^sub>F, \\<Psi>' \\<otimes> \\<Psi>\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>A\\<^sub>F, \\<Psi> \\<otimes> \\<Psi>'\\<rangle> \\<simeq>\\<^sub>F\n    \\<langle>A\\<^sub>F, \\<Psi>' \\<otimes> \\<Psi>\\<rangle>", "by(induct A\\<^sub>F) (auto intro: Commutativity frameResPres)"], ["", "lemma frameIntIdentity:\n  fixes A\\<^sub>F :: \"name list\"\n  and   \\<Psi>\\<^sub>F :: 'b \n\n  shows \"\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F \\<otimes> SBottom\\<rangle> \\<simeq>\\<^sub>F \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F \\<otimes>\n                        \\<bottom>\\<rangle> \\<simeq>\\<^sub>F\n    \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>", "by(induct A\\<^sub>F) (auto intro: Identity frameResPres)"], ["", "lemma frameIntComposition:\n  fixes \\<Psi>  :: 'b\n  and   \\<Psi>' :: 'b\n  and   A\\<^sub>F :: \"name list\"\n  and   \\<Psi>\\<^sub>F :: 'b\n\n  assumes \"\\<Psi> \\<simeq> \\<Psi>'\"\n\n  shows \"\\<langle>A\\<^sub>F, \\<Psi> \\<otimes> \\<Psi>\\<^sub>F\\<rangle> \\<simeq>\\<^sub>F \\<langle>A\\<^sub>F, \\<Psi>' \\<otimes> \\<Psi>\\<^sub>F\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>A\\<^sub>F, \\<Psi> \\<otimes>\n                        \\<Psi>\\<^sub>F\\<rangle> \\<simeq>\\<^sub>F\n    \\<langle>A\\<^sub>F, \\<Psi>' \\<otimes> \\<Psi>\\<^sub>F\\<rangle>", "using assms"], ["proof (prove)\nusing this:\n  \\<Psi> \\<simeq> \\<Psi>'\n\ngoal (1 subgoal):\n 1. \\<langle>A\\<^sub>F, \\<Psi> \\<otimes>\n                        \\<Psi>\\<^sub>F\\<rangle> \\<simeq>\\<^sub>F\n    \\<langle>A\\<^sub>F, \\<Psi>' \\<otimes> \\<Psi>\\<^sub>F\\<rangle>", "by(induct A\\<^sub>F) (auto intro: Composition frameResPres)"], ["", "lemma frameIntCompositionSym:\n  fixes \\<Psi>  :: 'b\n  and   \\<Psi>' :: 'b\n  and   A\\<^sub>F :: \"name list\"\n  and   \\<Psi>\\<^sub>F :: 'b\n\n  assumes \"\\<Psi> \\<simeq> \\<Psi>'\"\n\n  shows \"\\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F \\<otimes> \\<Psi>\\<rangle> \\<simeq>\\<^sub>F \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F \\<otimes> \\<Psi>'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F \\<otimes>\n                        \\<Psi>\\<rangle> \\<simeq>\\<^sub>F\n    \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F \\<otimes> \\<Psi>'\\<rangle>", "using assms"], ["proof (prove)\nusing this:\n  \\<Psi> \\<simeq> \\<Psi>'\n\ngoal (1 subgoal):\n 1. \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F \\<otimes>\n                        \\<Psi>\\<rangle> \\<simeq>\\<^sub>F\n    \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F \\<otimes> \\<Psi>'\\<rangle>", "by(induct A\\<^sub>F) (auto intro: compositionSym frameResPres)"], ["", "lemma frameCommutativity:\n  fixes F :: \"'b frame\"\n  and   G :: \"'b frame\"\n\n  shows \"F \\<otimes>\\<^sub>F G \\<simeq>\\<^sub>F G \\<otimes>\\<^sub>F F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<otimes>\\<^sub>F G \\<simeq>\\<^sub>F G \\<otimes>\\<^sub>F F", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. F \\<otimes>\\<^sub>F G \\<simeq>\\<^sub>F G \\<otimes>\\<^sub>F F", "obtain A\\<^sub>F \\<Psi>\\<^sub>F where \"F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\" and \"A\\<^sub>F \\<sharp>* G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A\\<^sub>F \\<Psi>\\<^sub>F.\n        \\<lbrakk>F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>;\n         A\\<^sub>F \\<sharp>* G\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule freshFrame)"], ["proof (state)\nthis:\n  F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\n  A\\<^sub>F \\<sharp>* G\n\ngoal (1 subgoal):\n 1. F \\<otimes>\\<^sub>F G \\<simeq>\\<^sub>F G \\<otimes>\\<^sub>F F", "moreover"], ["proof (state)\nthis:\n  F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\n  A\\<^sub>F \\<sharp>* G\n\ngoal (1 subgoal):\n 1. F \\<otimes>\\<^sub>F G \\<simeq>\\<^sub>F G \\<otimes>\\<^sub>F F", "obtain A\\<^sub>G \\<Psi>\\<^sub>G where \"G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle>\" and \"A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\" and \"A\\<^sub>G \\<sharp>* A\\<^sub>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A\\<^sub>G \\<Psi>\\<^sub>G.\n        \\<lbrakk>G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle>;\n         A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F;\n         A\\<^sub>G \\<sharp>* A\\<^sub>F\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule_tac C=\"(A\\<^sub>F, \\<Psi>\\<^sub>F)\" in freshFrame) auto"], ["proof (state)\nthis:\n  G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle>\n  A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\n  A\\<^sub>G \\<sharp>* A\\<^sub>F\n\ngoal (1 subgoal):\n 1. F \\<otimes>\\<^sub>F G \\<simeq>\\<^sub>F G \\<otimes>\\<^sub>F F", "moreover"], ["proof (state)\nthis:\n  G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle>\n  A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\n  A\\<^sub>G \\<sharp>* A\\<^sub>F\n\ngoal (1 subgoal):\n 1. F \\<otimes>\\<^sub>F G \\<simeq>\\<^sub>F G \\<otimes>\\<^sub>F F", "from \\<open>A\\<^sub>F \\<sharp>* G\\<close> \\<open>G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle>\\<close> \\<open>A\\<^sub>G \\<sharp>* A\\<^sub>F\\<close>"], ["proof (chain)\npicking this:\n  A\\<^sub>F \\<sharp>* G\n  G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle>\n  A\\<^sub>G \\<sharp>* A\\<^sub>F", "have \"A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G\""], ["proof (prove)\nusing this:\n  A\\<^sub>F \\<sharp>* G\n  G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle>\n  A\\<^sub>G \\<sharp>* A\\<^sub>F\n\ngoal (1 subgoal):\n 1. A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G", "by auto"], ["proof (state)\nthis:\n  A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G\n\ngoal (1 subgoal):\n 1. F \\<otimes>\\<^sub>F G \\<simeq>\\<^sub>F G \\<otimes>\\<^sub>F F", "ultimately"], ["proof (chain)\npicking this:\n  F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\n  A\\<^sub>F \\<sharp>* G\n  G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle>\n  A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\n  A\\<^sub>G \\<sharp>* A\\<^sub>F\n  A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G", "show ?thesis"], ["proof (prove)\nusing this:\n  F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\n  A\\<^sub>F \\<sharp>* G\n  G = \\<langle>A\\<^sub>G, \\<Psi>\\<^sub>G\\<rangle>\n  A\\<^sub>G \\<sharp>* \\<Psi>\\<^sub>F\n  A\\<^sub>G \\<sharp>* A\\<^sub>F\n  A\\<^sub>F \\<sharp>* \\<Psi>\\<^sub>G\n\ngoal (1 subgoal):\n 1. F \\<otimes>\\<^sub>F G \\<simeq>\\<^sub>F G \\<otimes>\\<^sub>F F", "by auto (metis FrameStatEqTrans frameChainAppend frameResChainComm frameIntCommutativity)"], ["proof (state)\nthis:\n  F \\<otimes>\\<^sub>F G \\<simeq>\\<^sub>F G \\<otimes>\\<^sub>F F\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma frameScopeExt:\n  fixes x :: name\n  and   F :: \"'b frame\"\n  and   G :: \"'b frame\"\n\n  assumes \"x \\<sharp> F\"\n\n  shows \"\\<lparr>\\<nu>x\\<rparr>(F \\<otimes>\\<^sub>F G) \\<simeq>\\<^sub>F F \\<otimes>\\<^sub>F (\\<lparr>\\<nu>x\\<rparr>G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>F \\<otimes>\\<^sub>F G \\<simeq>\\<^sub>F\n    F \\<otimes>\\<^sub>F \\<lparr>\\<nu>x\\<rparr>G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>F \\<otimes>\\<^sub>F G \\<simeq>\\<^sub>F\n    F \\<otimes>\\<^sub>F \\<lparr>\\<nu>x\\<rparr>G", "have \"\\<lparr>\\<nu>x\\<rparr>(F \\<otimes>\\<^sub>F G) \\<simeq>\\<^sub>F \\<lparr>\\<nu>x\\<rparr>(G \\<otimes>\\<^sub>F F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>F \\<otimes>\\<^sub>F G \\<simeq>\\<^sub>F\n    \\<lparr>\\<nu>x\\<rparr>G \\<otimes>\\<^sub>F F", "by(metis frameResPres frameCommutativity)"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>F \\<otimes>\\<^sub>F G \\<simeq>\\<^sub>F\n  \\<lparr>\\<nu>x\\<rparr>G \\<otimes>\\<^sub>F F\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>F \\<otimes>\\<^sub>F G \\<simeq>\\<^sub>F\n    F \\<otimes>\\<^sub>F \\<lparr>\\<nu>x\\<rparr>G", "with \\<open>x \\<sharp> F\\<close>"], ["proof (chain)\npicking this:\n  x \\<sharp> F\n  \\<lparr>\\<nu>x\\<rparr>F \\<otimes>\\<^sub>F G \\<simeq>\\<^sub>F\n  \\<lparr>\\<nu>x\\<rparr>G \\<otimes>\\<^sub>F F", "have \"\\<lparr>\\<nu>x\\<rparr>(F \\<otimes>\\<^sub>F G) \\<simeq>\\<^sub>F (\\<lparr>\\<nu>x\\<rparr>G) \\<otimes>\\<^sub>F F\""], ["proof (prove)\nusing this:\n  x \\<sharp> F\n  \\<lparr>\\<nu>x\\<rparr>F \\<otimes>\\<^sub>F G \\<simeq>\\<^sub>F\n  \\<lparr>\\<nu>x\\<rparr>G \\<otimes>\\<^sub>F F\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>F \\<otimes>\\<^sub>F G \\<simeq>\\<^sub>F\n    (\\<lparr>\\<nu>x\\<rparr>G) \\<otimes>\\<^sub>F F", "by simp"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>F \\<otimes>\\<^sub>F G \\<simeq>\\<^sub>F\n  (\\<lparr>\\<nu>x\\<rparr>G) \\<otimes>\\<^sub>F F\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>F \\<otimes>\\<^sub>F G \\<simeq>\\<^sub>F\n    F \\<otimes>\\<^sub>F \\<lparr>\\<nu>x\\<rparr>G", "moreover"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>F \\<otimes>\\<^sub>F G \\<simeq>\\<^sub>F\n  (\\<lparr>\\<nu>x\\<rparr>G) \\<otimes>\\<^sub>F F\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>F \\<otimes>\\<^sub>F G \\<simeq>\\<^sub>F\n    F \\<otimes>\\<^sub>F \\<lparr>\\<nu>x\\<rparr>G", "have \"(\\<lparr>\\<nu>x\\<rparr>G) \\<otimes>\\<^sub>F F \\<simeq>\\<^sub>F F \\<otimes>\\<^sub>F (\\<lparr>\\<nu>x\\<rparr>G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lparr>\\<nu>x\\<rparr>G) \\<otimes>\\<^sub>F F \\<simeq>\\<^sub>F\n    F \\<otimes>\\<^sub>F \\<lparr>\\<nu>x\\<rparr>G", "by(rule frameCommutativity)"], ["proof (state)\nthis:\n  (\\<lparr>\\<nu>x\\<rparr>G) \\<otimes>\\<^sub>F F \\<simeq>\\<^sub>F\n  F \\<otimes>\\<^sub>F \\<lparr>\\<nu>x\\<rparr>G\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>F \\<otimes>\\<^sub>F G \\<simeq>\\<^sub>F\n    F \\<otimes>\\<^sub>F \\<lparr>\\<nu>x\\<rparr>G", "ultimately"], ["proof (chain)\npicking this:\n  \\<lparr>\\<nu>x\\<rparr>F \\<otimes>\\<^sub>F G \\<simeq>\\<^sub>F\n  (\\<lparr>\\<nu>x\\<rparr>G) \\<otimes>\\<^sub>F F\n  (\\<lparr>\\<nu>x\\<rparr>G) \\<otimes>\\<^sub>F F \\<simeq>\\<^sub>F\n  F \\<otimes>\\<^sub>F \\<lparr>\\<nu>x\\<rparr>G", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lparr>\\<nu>x\\<rparr>F \\<otimes>\\<^sub>F G \\<simeq>\\<^sub>F\n  (\\<lparr>\\<nu>x\\<rparr>G) \\<otimes>\\<^sub>F F\n  (\\<lparr>\\<nu>x\\<rparr>G) \\<otimes>\\<^sub>F F \\<simeq>\\<^sub>F\n  F \\<otimes>\\<^sub>F \\<lparr>\\<nu>x\\<rparr>G\n\ngoal (1 subgoal):\n 1. \\<lparr>\\<nu>x\\<rparr>F \\<otimes>\\<^sub>F G \\<simeq>\\<^sub>F\n    F \\<otimes>\\<^sub>F \\<lparr>\\<nu>x\\<rparr>G", "by(rule FrameStatEqTrans)"], ["proof (state)\nthis:\n  \\<lparr>\\<nu>x\\<rparr>F \\<otimes>\\<^sub>F G \\<simeq>\\<^sub>F\n  F \\<otimes>\\<^sub>F \\<lparr>\\<nu>x\\<rparr>G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insertDoubleAssertionStatEq:\n  fixes F  :: \"'b frame\"\n  and   \\<Psi>  :: 'b\n  and   \\<Psi>' :: 'b\n\n  shows \"insertAssertion(insertAssertion F \\<Psi>) \\<Psi>' \\<simeq>\\<^sub>F (insertAssertion F) (\\<Psi> \\<otimes> \\<Psi>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertAssertion (insertAssertion F \\<Psi>) \\<Psi>' \\<simeq>\\<^sub>F\n    insertAssertion F (\\<Psi> \\<otimes> \\<Psi>')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. insertAssertion (insertAssertion F \\<Psi>) \\<Psi>' \\<simeq>\\<^sub>F\n    insertAssertion F (\\<Psi> \\<otimes> \\<Psi>')", "obtain A\\<^sub>F \\<Psi>\\<^sub>F where \"F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\" and \"A\\<^sub>F \\<sharp>* \\<Psi>\" and \"A\\<^sub>F \\<sharp>* \\<Psi>'\" and \"A\\<^sub>F \\<sharp>* (\\<Psi> \\<otimes> \\<Psi>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A\\<^sub>F \\<Psi>\\<^sub>F.\n        \\<lbrakk>F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>;\n         A\\<^sub>F \\<sharp>* \\<Psi>; A\\<^sub>F \\<sharp>* \\<Psi>';\n         A\\<^sub>F \\<sharp>* (\\<Psi> \\<otimes> \\<Psi>')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule_tac C=\"(\\<Psi>, \\<Psi>')\" in freshFrame) auto"], ["proof (state)\nthis:\n  F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\n  A\\<^sub>F \\<sharp>* \\<Psi>\n  A\\<^sub>F \\<sharp>* \\<Psi>'\n  A\\<^sub>F \\<sharp>* (\\<Psi> \\<otimes> \\<Psi>')\n\ngoal (1 subgoal):\n 1. insertAssertion (insertAssertion F \\<Psi>) \\<Psi>' \\<simeq>\\<^sub>F\n    insertAssertion F (\\<Psi> \\<otimes> \\<Psi>')", "thus ?thesis"], ["proof (prove)\nusing this:\n  F = \\<langle>A\\<^sub>F, \\<Psi>\\<^sub>F\\<rangle>\n  A\\<^sub>F \\<sharp>* \\<Psi>\n  A\\<^sub>F \\<sharp>* \\<Psi>'\n  A\\<^sub>F \\<sharp>* (\\<Psi> \\<otimes> \\<Psi>')\n\ngoal (1 subgoal):\n 1. insertAssertion (insertAssertion F \\<Psi>) \\<Psi>' \\<simeq>\\<^sub>F\n    insertAssertion F (\\<Psi> \\<otimes> \\<Psi>')", "by auto (metis frameIntComposition Commutativity frameIntAssociativity FrameStatEqTrans FrameStatEqSym)"], ["proof (state)\nthis:\n  insertAssertion (insertAssertion F \\<Psi>) \\<Psi>' \\<simeq>\\<^sub>F\n  insertAssertion F (\\<Psi> \\<otimes> \\<Psi>')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma guardedStatEq:\n  fixes P  :: \"('a, 'b, 'c) psi\"\n  and   I  :: \"('a, 'b, 'c) input\"\n  and   C  :: \"('a, 'b, 'c) psiCase\"\n  and   A\\<^sub>P :: \"name list\"\n  and   \\<Psi>\\<^sub>P :: 'b\n\n  shows \"\\<lbrakk>guarded P; extractFrame P = \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk> \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and> supp \\<Psi>\\<^sub>P = ({}::name set)\"\n  and   \"\\<lbrakk>guarded' I; extractFrame' I = \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk> \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and> supp \\<Psi>\\<^sub>P = ({}::name set)\"\n  and   \"\\<lbrakk>guarded'' C; extractFrame'' C = \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk> \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and> supp \\<Psi>\\<^sub>P = ({}::name set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>guarded P;\n      extractFrame P = \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n     \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                       supp \\<Psi>\\<^sub>P = {}) &&&\n    (\\<lbrakk>guarded' I;\n      extractFrame' I = \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n     \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                       supp \\<Psi>\\<^sub>P = {}) &&&\n    (\\<lbrakk>guarded'' C;\n      extractFrame'' C =\n      \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n     \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                       supp \\<Psi>\\<^sub>P = {})", "proof(nominal_induct P and I and C arbitrary: A\\<^sub>P \\<Psi>\\<^sub>P rule: psi_input_psiCase.strong_inducts)"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<zero>);\n        extractFrame (\\<zero>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>term1 term2 psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (term1\\<langle>term2\\<rangle>.psi);\n        extractFrame (term1\\<langle>term2\\<rangle>.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 3. \\<And>term input A\\<^sub>P' \\<Psi>\\<^sub>P'.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded (term\\<lparr>input);\n        extractFrame (term\\<lparr>input) =\n        \\<langle>A\\<^sub>P', \\<Psi>\\<^sub>P'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P' \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P' = {}\n 4. \\<And>psiCase A\\<^sub>P' \\<Psi>\\<^sub>P'.\n       \\<lbrakk>\\<lbrakk>guarded'' psiCase;\n                 extractFrame'' psiCase =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded (Case psiCase);\n        extractFrame (Case psiCase) =\n        \\<langle>A\\<^sub>P', \\<Psi>\\<^sub>P'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P' \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P' = {}\n 5. \\<And>psi1 psi2 A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi1;\n                    extractFrame psi1 =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n           \\<lbrakk>guarded psi2;\n            extractFrame psi2 =\n            \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n           \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                             supp \\<Psi>\\<^sub>P = {};\n        guarded (psi1 \\<parallel> psi2);\n        extractFrame (psi1 \\<parallel> psi2) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 6. \\<And>name psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (\\<lparr>\\<nu>name\\<rparr>psi);\n        extractFrame (\\<lparr>\\<nu>name\\<rparr>psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 7. \\<And>assertion A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<lbrace>assertion\\<rbrace>);\n        extractFrame (\\<lbrace>assertion\\<rbrace>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 8. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 9. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 10. \\<And>name input.\n        \\<lbrakk>\\<lbrakk>guarded' input;\n                  extractFrame' input =\n                  \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                 \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                   supp \\<Psi>\\<^sub>P = {};\n         guarded' (\\<nu>nameinput);\n         extractFrame' (\\<nu>nameinput) =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {}\nA total of 12 subgoals...", "case(PsiNil A\\<^sub>P \\<Psi>\\<^sub>P)"], ["proof (state)\nthis:\n  guarded (\\<zero>)\n  extractFrame (\\<zero>) = \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\n\ngoal (12 subgoals):\n 1. \\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<zero>);\n        extractFrame (\\<zero>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>term1 term2 psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (term1\\<langle>term2\\<rangle>.psi);\n        extractFrame (term1\\<langle>term2\\<rangle>.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 3. \\<And>term input A\\<^sub>P' \\<Psi>\\<^sub>P'.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded (term\\<lparr>input);\n        extractFrame (term\\<lparr>input) =\n        \\<langle>A\\<^sub>P', \\<Psi>\\<^sub>P'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P' \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P' = {}\n 4. \\<And>psiCase A\\<^sub>P' \\<Psi>\\<^sub>P'.\n       \\<lbrakk>\\<lbrakk>guarded'' psiCase;\n                 extractFrame'' psiCase =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded (Case psiCase);\n        extractFrame (Case psiCase) =\n        \\<langle>A\\<^sub>P', \\<Psi>\\<^sub>P'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P' \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P' = {}\n 5. \\<And>psi1 psi2 A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi1;\n                    extractFrame psi1 =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n           \\<lbrakk>guarded psi2;\n            extractFrame psi2 =\n            \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n           \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                             supp \\<Psi>\\<^sub>P = {};\n        guarded (psi1 \\<parallel> psi2);\n        extractFrame (psi1 \\<parallel> psi2) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 6. \\<And>name psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (\\<lparr>\\<nu>name\\<rparr>psi);\n        extractFrame (\\<lparr>\\<nu>name\\<rparr>psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 7. \\<And>assertion A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<lbrace>assertion\\<rbrace>);\n        extractFrame (\\<lbrace>assertion\\<rbrace>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 8. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 9. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 10. \\<And>name input.\n        \\<lbrakk>\\<lbrakk>guarded' input;\n                  extractFrame' input =\n                  \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                 \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                   supp \\<Psi>\\<^sub>P = {};\n         guarded' (\\<nu>nameinput);\n         extractFrame' (\\<nu>nameinput) =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {}\nA total of 12 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  guarded (\\<zero>)\n  extractFrame (\\<zero>) = \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and> supp \\<Psi>\\<^sub>P = {}", "by simp"], ["proof (state)\nthis:\n  \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and> supp \\<Psi>\\<^sub>P = {}\n\ngoal (11 subgoals):\n 1. \\<And>term1 term2 psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (term1\\<langle>term2\\<rangle>.psi);\n        extractFrame (term1\\<langle>term2\\<rangle>.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>term input A\\<^sub>P' \\<Psi>\\<^sub>P'.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded (term\\<lparr>input);\n        extractFrame (term\\<lparr>input) =\n        \\<langle>A\\<^sub>P', \\<Psi>\\<^sub>P'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P' \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P' = {}\n 3. \\<And>psiCase A\\<^sub>P' \\<Psi>\\<^sub>P'.\n       \\<lbrakk>\\<lbrakk>guarded'' psiCase;\n                 extractFrame'' psiCase =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded (Case psiCase);\n        extractFrame (Case psiCase) =\n        \\<langle>A\\<^sub>P', \\<Psi>\\<^sub>P'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P' \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P' = {}\n 4. \\<And>psi1 psi2 A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi1;\n                    extractFrame psi1 =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n           \\<lbrakk>guarded psi2;\n            extractFrame psi2 =\n            \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n           \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                             supp \\<Psi>\\<^sub>P = {};\n        guarded (psi1 \\<parallel> psi2);\n        extractFrame (psi1 \\<parallel> psi2) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 5. \\<And>name psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (\\<lparr>\\<nu>name\\<rparr>psi);\n        extractFrame (\\<lparr>\\<nu>name\\<rparr>psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 6. \\<And>assertion A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<lbrace>assertion\\<rbrace>);\n        extractFrame (\\<lbrace>assertion\\<rbrace>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 7. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 8. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 9. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 10. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n      extractFrame'' (\\<bottom>\\<^sub>c) =\n      \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n     \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                       supp \\<Psi>\\<^sub>P = {}\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>term1 term2 psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (term1\\<langle>term2\\<rangle>.psi);\n        extractFrame (term1\\<langle>term2\\<rangle>.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>term input A\\<^sub>P' \\<Psi>\\<^sub>P'.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded (term\\<lparr>input);\n        extractFrame (term\\<lparr>input) =\n        \\<langle>A\\<^sub>P', \\<Psi>\\<^sub>P'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P' \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P' = {}\n 3. \\<And>psiCase A\\<^sub>P' \\<Psi>\\<^sub>P'.\n       \\<lbrakk>\\<lbrakk>guarded'' psiCase;\n                 extractFrame'' psiCase =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded (Case psiCase);\n        extractFrame (Case psiCase) =\n        \\<langle>A\\<^sub>P', \\<Psi>\\<^sub>P'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P' \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P' = {}\n 4. \\<And>psi1 psi2 A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi1;\n                    extractFrame psi1 =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n           \\<lbrakk>guarded psi2;\n            extractFrame psi2 =\n            \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n           \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                             supp \\<Psi>\\<^sub>P = {};\n        guarded (psi1 \\<parallel> psi2);\n        extractFrame (psi1 \\<parallel> psi2) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 5. \\<And>name psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (\\<lparr>\\<nu>name\\<rparr>psi);\n        extractFrame (\\<lparr>\\<nu>name\\<rparr>psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 6. \\<And>assertion A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<lbrace>assertion\\<rbrace>);\n        extractFrame (\\<lbrace>assertion\\<rbrace>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 7. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 8. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 9. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 10. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n      extractFrame'' (\\<bottom>\\<^sub>c) =\n      \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n     \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                       supp \\<Psi>\\<^sub>P = {}\nA total of 11 subgoals...", "case(Output M N P A\\<^sub>P \\<Psi>\\<^sub>P)"], ["proof (state)\nthis:\n  \\<lbrakk>guarded P;\n   extractFrame P = \\<langle>?A\\<^sub>P, ?\\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> ?\\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                    supp ?\\<Psi>\\<^sub>P = {}\n  guarded (M\\<langle>N\\<rangle>.P)\n  extractFrame (M\\<langle>N\\<rangle>.P) =\n  \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\n\ngoal (11 subgoals):\n 1. \\<And>term1 term2 psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (term1\\<langle>term2\\<rangle>.psi);\n        extractFrame (term1\\<langle>term2\\<rangle>.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>term input A\\<^sub>P' \\<Psi>\\<^sub>P'.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded (term\\<lparr>input);\n        extractFrame (term\\<lparr>input) =\n        \\<langle>A\\<^sub>P', \\<Psi>\\<^sub>P'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P' \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P' = {}\n 3. \\<And>psiCase A\\<^sub>P' \\<Psi>\\<^sub>P'.\n       \\<lbrakk>\\<lbrakk>guarded'' psiCase;\n                 extractFrame'' psiCase =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded (Case psiCase);\n        extractFrame (Case psiCase) =\n        \\<langle>A\\<^sub>P', \\<Psi>\\<^sub>P'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P' \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P' = {}\n 4. \\<And>psi1 psi2 A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi1;\n                    extractFrame psi1 =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n           \\<lbrakk>guarded psi2;\n            extractFrame psi2 =\n            \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n           \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                             supp \\<Psi>\\<^sub>P = {};\n        guarded (psi1 \\<parallel> psi2);\n        extractFrame (psi1 \\<parallel> psi2) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 5. \\<And>name psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (\\<lparr>\\<nu>name\\<rparr>psi);\n        extractFrame (\\<lparr>\\<nu>name\\<rparr>psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 6. \\<And>assertion A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<lbrace>assertion\\<rbrace>);\n        extractFrame (\\<lbrace>assertion\\<rbrace>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 7. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 8. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 9. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 10. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n      extractFrame'' (\\<bottom>\\<^sub>c) =\n      \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n     \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                       supp \\<Psi>\\<^sub>P = {}\nA total of 11 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>guarded P;\n   extractFrame P = \\<langle>?A\\<^sub>P, ?\\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> ?\\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                    supp ?\\<Psi>\\<^sub>P = {}\n  guarded (M\\<langle>N\\<rangle>.P)\n  extractFrame (M\\<langle>N\\<rangle>.P) =\n  \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and> supp \\<Psi>\\<^sub>P = {}", "by simp"], ["proof (state)\nthis:\n  \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and> supp \\<Psi>\\<^sub>P = {}\n\ngoal (10 subgoals):\n 1. \\<And>term input A\\<^sub>P' \\<Psi>\\<^sub>P'.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded (term\\<lparr>input);\n        extractFrame (term\\<lparr>input) =\n        \\<langle>A\\<^sub>P', \\<Psi>\\<^sub>P'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P' \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P' = {}\n 2. \\<And>psiCase A\\<^sub>P' \\<Psi>\\<^sub>P'.\n       \\<lbrakk>\\<lbrakk>guarded'' psiCase;\n                 extractFrame'' psiCase =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded (Case psiCase);\n        extractFrame (Case psiCase) =\n        \\<langle>A\\<^sub>P', \\<Psi>\\<^sub>P'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P' \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P' = {}\n 3. \\<And>psi1 psi2 A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi1;\n                    extractFrame psi1 =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n           \\<lbrakk>guarded psi2;\n            extractFrame psi2 =\n            \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n           \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                             supp \\<Psi>\\<^sub>P = {};\n        guarded (psi1 \\<parallel> psi2);\n        extractFrame (psi1 \\<parallel> psi2) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 4. \\<And>name psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (\\<lparr>\\<nu>name\\<rparr>psi);\n        extractFrame (\\<lparr>\\<nu>name\\<rparr>psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 5. \\<And>assertion A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<lbrace>assertion\\<rbrace>);\n        extractFrame (\\<lbrace>assertion\\<rbrace>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 6. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 7. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 8. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 9. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 10. \\<And>condition psi psiCase.\n        \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                    \\<lbrakk>guarded psi;\n                     extractFrame psi =\n                     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n\\<bottom> \\<and>\nsupp \\<Psi>\\<^sub>P = {};\n         \\<lbrakk>guarded'' psiCase;\n          extractFrame'' psiCase =\n          \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n         \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                           supp \\<Psi>\\<^sub>P = {};\n         guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n         extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {}", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>term input A\\<^sub>P' \\<Psi>\\<^sub>P'.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded (term\\<lparr>input);\n        extractFrame (term\\<lparr>input) =\n        \\<langle>A\\<^sub>P', \\<Psi>\\<^sub>P'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P' \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P' = {}\n 2. \\<And>psiCase A\\<^sub>P' \\<Psi>\\<^sub>P'.\n       \\<lbrakk>\\<lbrakk>guarded'' psiCase;\n                 extractFrame'' psiCase =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded (Case psiCase);\n        extractFrame (Case psiCase) =\n        \\<langle>A\\<^sub>P', \\<Psi>\\<^sub>P'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P' \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P' = {}\n 3. \\<And>psi1 psi2 A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi1;\n                    extractFrame psi1 =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n           \\<lbrakk>guarded psi2;\n            extractFrame psi2 =\n            \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n           \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                             supp \\<Psi>\\<^sub>P = {};\n        guarded (psi1 \\<parallel> psi2);\n        extractFrame (psi1 \\<parallel> psi2) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 4. \\<And>name psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (\\<lparr>\\<nu>name\\<rparr>psi);\n        extractFrame (\\<lparr>\\<nu>name\\<rparr>psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 5. \\<And>assertion A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<lbrace>assertion\\<rbrace>);\n        extractFrame (\\<lbrace>assertion\\<rbrace>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 6. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 7. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 8. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 9. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 10. \\<And>condition psi psiCase.\n        \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                    \\<lbrakk>guarded psi;\n                     extractFrame psi =\n                     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n\\<bottom> \\<and>\nsupp \\<Psi>\\<^sub>P = {};\n         \\<lbrakk>guarded'' psiCase;\n          extractFrame'' psiCase =\n          \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n         \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                           supp \\<Psi>\\<^sub>P = {};\n         guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n         extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {}", "case(Input M In  A\\<^sub>P \\<Psi>\\<^sub>P)"], ["proof (state)\nthis:\n  \\<lbrakk>guarded' In;\n   extractFrame' In = \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                    supp \\<Psi>\\<^sub>P = {}\n  guarded (M\\<lparr>In)\n  extractFrame (M\\<lparr>In) = \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\n\ngoal (10 subgoals):\n 1. \\<And>term input A\\<^sub>P' \\<Psi>\\<^sub>P'.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded (term\\<lparr>input);\n        extractFrame (term\\<lparr>input) =\n        \\<langle>A\\<^sub>P', \\<Psi>\\<^sub>P'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P' \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P' = {}\n 2. \\<And>psiCase A\\<^sub>P' \\<Psi>\\<^sub>P'.\n       \\<lbrakk>\\<lbrakk>guarded'' psiCase;\n                 extractFrame'' psiCase =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded (Case psiCase);\n        extractFrame (Case psiCase) =\n        \\<langle>A\\<^sub>P', \\<Psi>\\<^sub>P'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P' \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P' = {}\n 3. \\<And>psi1 psi2 A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi1;\n                    extractFrame psi1 =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n           \\<lbrakk>guarded psi2;\n            extractFrame psi2 =\n            \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n           \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                             supp \\<Psi>\\<^sub>P = {};\n        guarded (psi1 \\<parallel> psi2);\n        extractFrame (psi1 \\<parallel> psi2) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 4. \\<And>name psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (\\<lparr>\\<nu>name\\<rparr>psi);\n        extractFrame (\\<lparr>\\<nu>name\\<rparr>psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 5. \\<And>assertion A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<lbrace>assertion\\<rbrace>);\n        extractFrame (\\<lbrace>assertion\\<rbrace>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 6. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 7. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 8. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 9. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 10. \\<And>condition psi psiCase.\n        \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                    \\<lbrakk>guarded psi;\n                     extractFrame psi =\n                     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n\\<bottom> \\<and>\nsupp \\<Psi>\\<^sub>P = {};\n         \\<lbrakk>guarded'' psiCase;\n          extractFrame'' psiCase =\n          \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n         \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                           supp \\<Psi>\\<^sub>P = {};\n         guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n         extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {}", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>guarded' In;\n   extractFrame' In = \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                    supp \\<Psi>\\<^sub>P = {}\n  guarded (M\\<lparr>In)\n  extractFrame (M\\<lparr>In) = \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and> supp \\<Psi>\\<^sub>P = {}", "by simp"], ["proof (state)\nthis:\n  \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and> supp \\<Psi>\\<^sub>P = {}\n\ngoal (9 subgoals):\n 1. \\<And>psiCase A\\<^sub>P' \\<Psi>\\<^sub>P'.\n       \\<lbrakk>\\<lbrakk>guarded'' psiCase;\n                 extractFrame'' psiCase =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded (Case psiCase);\n        extractFrame (Case psiCase) =\n        \\<langle>A\\<^sub>P', \\<Psi>\\<^sub>P'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P' \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P' = {}\n 2. \\<And>psi1 psi2 A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi1;\n                    extractFrame psi1 =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n           \\<lbrakk>guarded psi2;\n            extractFrame psi2 =\n            \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n           \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                             supp \\<Psi>\\<^sub>P = {};\n        guarded (psi1 \\<parallel> psi2);\n        extractFrame (psi1 \\<parallel> psi2) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 3. \\<And>name psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (\\<lparr>\\<nu>name\\<rparr>psi);\n        extractFrame (\\<lparr>\\<nu>name\\<rparr>psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 4. \\<And>assertion A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<lbrace>assertion\\<rbrace>);\n        extractFrame (\\<lbrace>assertion\\<rbrace>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 5. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 6. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 7. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 8. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 9. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>psiCase A\\<^sub>P' \\<Psi>\\<^sub>P'.\n       \\<lbrakk>\\<lbrakk>guarded'' psiCase;\n                 extractFrame'' psiCase =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded (Case psiCase);\n        extractFrame (Case psiCase) =\n        \\<langle>A\\<^sub>P', \\<Psi>\\<^sub>P'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P' \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P' = {}\n 2. \\<And>psi1 psi2 A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi1;\n                    extractFrame psi1 =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n           \\<lbrakk>guarded psi2;\n            extractFrame psi2 =\n            \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n           \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                             supp \\<Psi>\\<^sub>P = {};\n        guarded (psi1 \\<parallel> psi2);\n        extractFrame (psi1 \\<parallel> psi2) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 3. \\<And>name psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (\\<lparr>\\<nu>name\\<rparr>psi);\n        extractFrame (\\<lparr>\\<nu>name\\<rparr>psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 4. \\<And>assertion A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<lbrace>assertion\\<rbrace>);\n        extractFrame (\\<lbrace>assertion\\<rbrace>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 5. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 6. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 7. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 8. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 9. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "case(Case psiCase A\\<^sub>P \\<Psi>\\<^sub>P)"], ["proof (state)\nthis:\n  \\<lbrakk>guarded'' psiCase;\n   extractFrame'' psiCase =\n   \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                    supp \\<Psi>\\<^sub>P = {}\n  guarded (Case psiCase)\n  extractFrame (Case psiCase) = \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\n\ngoal (9 subgoals):\n 1. \\<And>psiCase A\\<^sub>P' \\<Psi>\\<^sub>P'.\n       \\<lbrakk>\\<lbrakk>guarded'' psiCase;\n                 extractFrame'' psiCase =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded (Case psiCase);\n        extractFrame (Case psiCase) =\n        \\<langle>A\\<^sub>P', \\<Psi>\\<^sub>P'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P' \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P' = {}\n 2. \\<And>psi1 psi2 A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi1;\n                    extractFrame psi1 =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n           \\<lbrakk>guarded psi2;\n            extractFrame psi2 =\n            \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n           \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                             supp \\<Psi>\\<^sub>P = {};\n        guarded (psi1 \\<parallel> psi2);\n        extractFrame (psi1 \\<parallel> psi2) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 3. \\<And>name psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (\\<lparr>\\<nu>name\\<rparr>psi);\n        extractFrame (\\<lparr>\\<nu>name\\<rparr>psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 4. \\<And>assertion A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<lbrace>assertion\\<rbrace>);\n        extractFrame (\\<lbrace>assertion\\<rbrace>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 5. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 6. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 7. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 8. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 9. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>guarded'' psiCase;\n   extractFrame'' psiCase =\n   \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                    supp \\<Psi>\\<^sub>P = {}\n  guarded (Case psiCase)\n  extractFrame (Case psiCase) = \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and> supp \\<Psi>\\<^sub>P = {}", "by simp"], ["proof (state)\nthis:\n  \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and> supp \\<Psi>\\<^sub>P = {}\n\ngoal (8 subgoals):\n 1. \\<And>psi1 psi2 A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi1;\n                    extractFrame psi1 =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n           \\<lbrakk>guarded psi2;\n            extractFrame psi2 =\n            \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n           \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                             supp \\<Psi>\\<^sub>P = {};\n        guarded (psi1 \\<parallel> psi2);\n        extractFrame (psi1 \\<parallel> psi2) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>name psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (\\<lparr>\\<nu>name\\<rparr>psi);\n        extractFrame (\\<lparr>\\<nu>name\\<rparr>psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 3. \\<And>assertion A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<lbrace>assertion\\<rbrace>);\n        extractFrame (\\<lbrace>assertion\\<rbrace>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 4. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 5. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 6. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 7. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 8. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>psi1 psi2 A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi1;\n                    extractFrame psi1 =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n           \\<lbrakk>guarded psi2;\n            extractFrame psi2 =\n            \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n           \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                             supp \\<Psi>\\<^sub>P = {};\n        guarded (psi1 \\<parallel> psi2);\n        extractFrame (psi1 \\<parallel> psi2) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>name psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (\\<lparr>\\<nu>name\\<rparr>psi);\n        extractFrame (\\<lparr>\\<nu>name\\<rparr>psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 3. \\<And>assertion A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<lbrace>assertion\\<rbrace>);\n        extractFrame (\\<lbrace>assertion\\<rbrace>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 4. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 5. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 6. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 7. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 8. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "case(Par P Q A\\<^sub>P\\<^sub>Q \\<Psi>\\<^sub>P\\<^sub>Q)"], ["proof (state)\nthis:\n  \\<lbrakk>guarded P;\n   extractFrame P = \\<langle>?A\\<^sub>P, ?\\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> ?\\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                    supp ?\\<Psi>\\<^sub>P = {}\n  \\<lbrakk>guarded Q;\n   extractFrame Q = \\<langle>?A\\<^sub>P, ?\\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> ?\\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                    supp ?\\<Psi>\\<^sub>P = {}\n  guarded (P \\<parallel> Q)\n  extractFrame (P \\<parallel> Q) =\n  \\<langle>A\\<^sub>P\\<^sub>Q, \\<Psi>\\<^sub>P\\<^sub>Q\\<rangle>\n\ngoal (8 subgoals):\n 1. \\<And>psi1 psi2 A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi1;\n                    extractFrame psi1 =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n           \\<lbrakk>guarded psi2;\n            extractFrame psi2 =\n            \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n           \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                             supp \\<Psi>\\<^sub>P = {};\n        guarded (psi1 \\<parallel> psi2);\n        extractFrame (psi1 \\<parallel> psi2) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>name psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (\\<lparr>\\<nu>name\\<rparr>psi);\n        extractFrame (\\<lparr>\\<nu>name\\<rparr>psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 3. \\<And>assertion A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<lbrace>assertion\\<rbrace>);\n        extractFrame (\\<lbrace>assertion\\<rbrace>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 4. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 5. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 6. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 7. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 8. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "from \\<open>guarded(P \\<parallel> Q)\\<close>"], ["proof (chain)\npicking this:\n  guarded (P \\<parallel> Q)", "have \"guarded P\" and \"guarded Q\""], ["proof (prove)\nusing this:\n  guarded (P \\<parallel> Q)\n\ngoal (1 subgoal):\n 1. guarded P &&& guarded Q", "by simp+"], ["proof (state)\nthis:\n  guarded P\n  guarded Q\n\ngoal (8 subgoals):\n 1. \\<And>psi1 psi2 A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi1;\n                    extractFrame psi1 =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n           \\<lbrakk>guarded psi2;\n            extractFrame psi2 =\n            \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n           \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                             supp \\<Psi>\\<^sub>P = {};\n        guarded (psi1 \\<parallel> psi2);\n        extractFrame (psi1 \\<parallel> psi2) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>name psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (\\<lparr>\\<nu>name\\<rparr>psi);\n        extractFrame (\\<lparr>\\<nu>name\\<rparr>psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 3. \\<And>assertion A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<lbrace>assertion\\<rbrace>);\n        extractFrame (\\<lbrace>assertion\\<rbrace>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 4. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 5. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 6. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 7. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 8. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "obtain A\\<^sub>P \\<Psi>\\<^sub>P where FrP: \"extractFrame P = \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\" and \"A\\<^sub>P \\<sharp>* Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n        \\<lbrakk>extractFrame P =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>;\n         A\\<^sub>P \\<sharp>* Q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule freshFrame)"], ["proof (state)\nthis:\n  extractFrame P = \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\n  A\\<^sub>P \\<sharp>* Q\n\ngoal (8 subgoals):\n 1. \\<And>psi1 psi2 A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi1;\n                    extractFrame psi1 =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n           \\<lbrakk>guarded psi2;\n            extractFrame psi2 =\n            \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n           \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                             supp \\<Psi>\\<^sub>P = {};\n        guarded (psi1 \\<parallel> psi2);\n        extractFrame (psi1 \\<parallel> psi2) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>name psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (\\<lparr>\\<nu>name\\<rparr>psi);\n        extractFrame (\\<lparr>\\<nu>name\\<rparr>psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 3. \\<And>assertion A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<lbrace>assertion\\<rbrace>);\n        extractFrame (\\<lbrace>assertion\\<rbrace>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 4. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 5. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 6. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 7. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 8. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "obtain A\\<^sub>Q \\<Psi>\\<^sub>Q where FrQ: \"extractFrame Q = \\<langle>A\\<^sub>Q, \\<Psi>\\<^sub>Q\\<rangle>\" and \"A\\<^sub>Q \\<sharp>* A\\<^sub>P\" and \"A\\<^sub>Q \\<sharp>* \\<Psi>\\<^sub>P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A\\<^sub>Q \\<Psi>\\<^sub>Q.\n        \\<lbrakk>extractFrame Q =\n                 \\<langle>A\\<^sub>Q, \\<Psi>\\<^sub>Q\\<rangle>;\n         A\\<^sub>Q \\<sharp>* A\\<^sub>P;\n         A\\<^sub>Q \\<sharp>* \\<Psi>\\<^sub>P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule_tac C=\"(A\\<^sub>P, \\<Psi>\\<^sub>P)\" in freshFrame) auto"], ["proof (state)\nthis:\n  extractFrame Q = \\<langle>A\\<^sub>Q, \\<Psi>\\<^sub>Q\\<rangle>\n  A\\<^sub>Q \\<sharp>* A\\<^sub>P\n  A\\<^sub>Q \\<sharp>* \\<Psi>\\<^sub>P\n\ngoal (8 subgoals):\n 1. \\<And>psi1 psi2 A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi1;\n                    extractFrame psi1 =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n           \\<lbrakk>guarded psi2;\n            extractFrame psi2 =\n            \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n           \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                             supp \\<Psi>\\<^sub>P = {};\n        guarded (psi1 \\<parallel> psi2);\n        extractFrame (psi1 \\<parallel> psi2) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>name psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (\\<lparr>\\<nu>name\\<rparr>psi);\n        extractFrame (\\<lparr>\\<nu>name\\<rparr>psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 3. \\<And>assertion A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<lbrace>assertion\\<rbrace>);\n        extractFrame (\\<lbrace>assertion\\<rbrace>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 4. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 5. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 6. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 7. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 8. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "from \\<open>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P. \\<lbrakk>guarded P; extractFrame P = \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk> \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and> (supp \\<Psi>\\<^sub>P = ({}::name set))\\<close> \\<open>guarded P\\<close> FrP"], ["proof (chain)\npicking this:\n  \\<lbrakk>guarded P;\n   extractFrame P = \\<langle>?A\\<^sub>P, ?\\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> ?\\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                    supp ?\\<Psi>\\<^sub>P = {}\n  guarded P\n  extractFrame P = \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>", "have \"\\<Psi>\\<^sub>P \\<simeq> \\<bottom>\" and \"supp \\<Psi>\\<^sub>P = ({}::name set)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>guarded P;\n   extractFrame P = \\<langle>?A\\<^sub>P, ?\\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> ?\\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                    supp ?\\<Psi>\\<^sub>P = {}\n  guarded P\n  extractFrame P = \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>P \\<simeq> \\<bottom> &&& supp \\<Psi>\\<^sub>P = {}", "by simp+"], ["proof (state)\nthis:\n  \\<Psi>\\<^sub>P \\<simeq> \\<bottom>\n  supp \\<Psi>\\<^sub>P = {}\n\ngoal (8 subgoals):\n 1. \\<And>psi1 psi2 A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi1;\n                    extractFrame psi1 =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n           \\<lbrakk>guarded psi2;\n            extractFrame psi2 =\n            \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n           \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                             supp \\<Psi>\\<^sub>P = {};\n        guarded (psi1 \\<parallel> psi2);\n        extractFrame (psi1 \\<parallel> psi2) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>name psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (\\<lparr>\\<nu>name\\<rparr>psi);\n        extractFrame (\\<lparr>\\<nu>name\\<rparr>psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 3. \\<And>assertion A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<lbrace>assertion\\<rbrace>);\n        extractFrame (\\<lbrace>assertion\\<rbrace>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 4. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 5. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 6. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 7. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 8. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "from \\<open>\\<And>A\\<^sub>Q \\<Psi>\\<^sub>Q. \\<lbrakk>guarded Q; extractFrame Q = \\<langle>A\\<^sub>Q, \\<Psi>\\<^sub>Q\\<rangle>\\<rbrakk> \\<Longrightarrow> \\<Psi>\\<^sub>Q \\<simeq> \\<bottom> \\<and> (supp \\<Psi>\\<^sub>Q = ({}::name set))\\<close> \\<open>guarded Q\\<close> FrQ"], ["proof (chain)\npicking this:\n  \\<lbrakk>guarded Q;\n   extractFrame Q = \\<langle>?A\\<^sub>Q, ?\\<Psi>\\<^sub>Q\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> ?\\<Psi>\\<^sub>Q \\<simeq> \\<bottom> \\<and>\n                    supp ?\\<Psi>\\<^sub>Q = {}\n  guarded Q\n  extractFrame Q = \\<langle>A\\<^sub>Q, \\<Psi>\\<^sub>Q\\<rangle>", "have \"\\<Psi>\\<^sub>Q \\<simeq> \\<bottom>\" and \"supp \\<Psi>\\<^sub>Q = ({}::name set)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>guarded Q;\n   extractFrame Q = \\<langle>?A\\<^sub>Q, ?\\<Psi>\\<^sub>Q\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> ?\\<Psi>\\<^sub>Q \\<simeq> \\<bottom> \\<and>\n                    supp ?\\<Psi>\\<^sub>Q = {}\n  guarded Q\n  extractFrame Q = \\<langle>A\\<^sub>Q, \\<Psi>\\<^sub>Q\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>Q \\<simeq> \\<bottom> &&& supp \\<Psi>\\<^sub>Q = {}", "by simp+"], ["proof (state)\nthis:\n  \\<Psi>\\<^sub>Q \\<simeq> \\<bottom>\n  supp \\<Psi>\\<^sub>Q = {}\n\ngoal (8 subgoals):\n 1. \\<And>psi1 psi2 A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi1;\n                    extractFrame psi1 =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n           \\<lbrakk>guarded psi2;\n            extractFrame psi2 =\n            \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n           \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                             supp \\<Psi>\\<^sub>P = {};\n        guarded (psi1 \\<parallel> psi2);\n        extractFrame (psi1 \\<parallel> psi2) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>name psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (\\<lparr>\\<nu>name\\<rparr>psi);\n        extractFrame (\\<lparr>\\<nu>name\\<rparr>psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 3. \\<And>assertion A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<lbrace>assertion\\<rbrace>);\n        extractFrame (\\<lbrace>assertion\\<rbrace>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 4. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 5. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 6. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 7. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 8. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "from \\<open>A\\<^sub>P \\<sharp>* Q\\<close> FrQ \\<open>A\\<^sub>Q \\<sharp>* A\\<^sub>P\\<close>"], ["proof (chain)\npicking this:\n  A\\<^sub>P \\<sharp>* Q\n  extractFrame Q = \\<langle>A\\<^sub>Q, \\<Psi>\\<^sub>Q\\<rangle>\n  A\\<^sub>Q \\<sharp>* A\\<^sub>P", "have \"A\\<^sub>P \\<sharp>* \\<Psi>\\<^sub>Q\""], ["proof (prove)\nusing this:\n  A\\<^sub>P \\<sharp>* Q\n  extractFrame Q = \\<langle>A\\<^sub>Q, \\<Psi>\\<^sub>Q\\<rangle>\n  A\\<^sub>Q \\<sharp>* A\\<^sub>P\n\ngoal (1 subgoal):\n 1. A\\<^sub>P \\<sharp>* \\<Psi>\\<^sub>Q", "by(drule_tac extractFrameFreshChain) auto"], ["proof (state)\nthis:\n  A\\<^sub>P \\<sharp>* \\<Psi>\\<^sub>Q\n\ngoal (8 subgoals):\n 1. \\<And>psi1 psi2 A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi1;\n                    extractFrame psi1 =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n           \\<lbrakk>guarded psi2;\n            extractFrame psi2 =\n            \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n           \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                             supp \\<Psi>\\<^sub>P = {};\n        guarded (psi1 \\<parallel> psi2);\n        extractFrame (psi1 \\<parallel> psi2) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>name psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (\\<lparr>\\<nu>name\\<rparr>psi);\n        extractFrame (\\<lparr>\\<nu>name\\<rparr>psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 3. \\<And>assertion A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<lbrace>assertion\\<rbrace>);\n        extractFrame (\\<lbrace>assertion\\<rbrace>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 4. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 5. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 6. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 7. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 8. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "with \\<open>A\\<^sub>Q \\<sharp>* A\\<^sub>P\\<close> \\<open>A\\<^sub>Q \\<sharp>* \\<Psi>\\<^sub>P\\<close> FrP FrQ \\<open>extractFrame(P \\<parallel> Q) = \\<langle>A\\<^sub>P\\<^sub>Q, \\<Psi>\\<^sub>P\\<^sub>Q\\<rangle>\\<close>"], ["proof (chain)\npicking this:\n  A\\<^sub>Q \\<sharp>* A\\<^sub>P\n  A\\<^sub>Q \\<sharp>* \\<Psi>\\<^sub>P\n  extractFrame P = \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\n  extractFrame Q = \\<langle>A\\<^sub>Q, \\<Psi>\\<^sub>Q\\<rangle>\n  extractFrame (P \\<parallel> Q) =\n  \\<langle>A\\<^sub>P\\<^sub>Q, \\<Psi>\\<^sub>P\\<^sub>Q\\<rangle>\n  A\\<^sub>P \\<sharp>* \\<Psi>\\<^sub>Q", "have \"\\<langle>(A\\<^sub>P@A\\<^sub>Q), \\<Psi>\\<^sub>P \\<otimes> \\<Psi>\\<^sub>Q\\<rangle> = \\<langle>A\\<^sub>P\\<^sub>Q, \\<Psi>\\<^sub>P\\<^sub>Q\\<rangle>\""], ["proof (prove)\nusing this:\n  A\\<^sub>Q \\<sharp>* A\\<^sub>P\n  A\\<^sub>Q \\<sharp>* \\<Psi>\\<^sub>P\n  extractFrame P = \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\n  extractFrame Q = \\<langle>A\\<^sub>Q, \\<Psi>\\<^sub>Q\\<rangle>\n  extractFrame (P \\<parallel> Q) =\n  \\<langle>A\\<^sub>P\\<^sub>Q, \\<Psi>\\<^sub>P\\<^sub>Q\\<rangle>\n  A\\<^sub>P \\<sharp>* \\<Psi>\\<^sub>Q\n\ngoal (1 subgoal):\n 1. \\<langle>(A\\<^sub>P @\n              A\\<^sub>Q), \\<Psi>\\<^sub>P \\<otimes> \\<Psi>\\<^sub>Q\\<rangle> =\n    \\<langle>A\\<^sub>P\\<^sub>Q, \\<Psi>\\<^sub>P\\<^sub>Q\\<rangle>", "by auto"], ["proof (state)\nthis:\n  \\<langle>(A\\<^sub>P @\n            A\\<^sub>Q), \\<Psi>\\<^sub>P \\<otimes> \\<Psi>\\<^sub>Q\\<rangle> =\n  \\<langle>A\\<^sub>P\\<^sub>Q, \\<Psi>\\<^sub>P\\<^sub>Q\\<rangle>\n\ngoal (8 subgoals):\n 1. \\<And>psi1 psi2 A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi1;\n                    extractFrame psi1 =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n           \\<lbrakk>guarded psi2;\n            extractFrame psi2 =\n            \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n           \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                             supp \\<Psi>\\<^sub>P = {};\n        guarded (psi1 \\<parallel> psi2);\n        extractFrame (psi1 \\<parallel> psi2) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>name psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (\\<lparr>\\<nu>name\\<rparr>psi);\n        extractFrame (\\<lparr>\\<nu>name\\<rparr>psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 3. \\<And>assertion A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<lbrace>assertion\\<rbrace>);\n        extractFrame (\\<lbrace>assertion\\<rbrace>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 4. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 5. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 6. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 7. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 8. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "with \\<open>supp \\<Psi>\\<^sub>P = {}\\<close> \\<open>supp \\<Psi>\\<^sub>Q = {}\\<close> compSupp"], ["proof (chain)\npicking this:\n  supp \\<Psi>\\<^sub>P = {}\n  supp \\<Psi>\\<^sub>Q = {}\n  supp (?\\<Psi> \\<otimes> ?\\<Psi>')\n  \\<subseteq> supp ?\\<Psi> \\<union> supp ?\\<Psi>'\n  \\<langle>(A\\<^sub>P @\n            A\\<^sub>Q), \\<Psi>\\<^sub>P \\<otimes> \\<Psi>\\<^sub>Q\\<rangle> =\n  \\<langle>A\\<^sub>P\\<^sub>Q, \\<Psi>\\<^sub>P\\<^sub>Q\\<rangle>", "have \"\\<Psi>\\<^sub>P\\<^sub>Q = \\<Psi>\\<^sub>P \\<otimes> \\<Psi>\\<^sub>Q\""], ["proof (prove)\nusing this:\n  supp \\<Psi>\\<^sub>P = {}\n  supp \\<Psi>\\<^sub>Q = {}\n  supp (?\\<Psi> \\<otimes> ?\\<Psi>')\n  \\<subseteq> supp ?\\<Psi> \\<union> supp ?\\<Psi>'\n  \\<langle>(A\\<^sub>P @\n            A\\<^sub>Q), \\<Psi>\\<^sub>P \\<otimes> \\<Psi>\\<^sub>Q\\<rangle> =\n  \\<langle>A\\<^sub>P\\<^sub>Q, \\<Psi>\\<^sub>P\\<^sub>Q\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>P\\<^sub>Q = \\<Psi>\\<^sub>P \\<otimes> \\<Psi>\\<^sub>Q", "by blast"], ["proof (state)\nthis:\n  \\<Psi>\\<^sub>P\\<^sub>Q = \\<Psi>\\<^sub>P \\<otimes> \\<Psi>\\<^sub>Q\n\ngoal (8 subgoals):\n 1. \\<And>psi1 psi2 A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi1;\n                    extractFrame psi1 =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n           \\<lbrakk>guarded psi2;\n            extractFrame psi2 =\n            \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n           \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                             supp \\<Psi>\\<^sub>P = {};\n        guarded (psi1 \\<parallel> psi2);\n        extractFrame (psi1 \\<parallel> psi2) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>name psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (\\<lparr>\\<nu>name\\<rparr>psi);\n        extractFrame (\\<lparr>\\<nu>name\\<rparr>psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 3. \\<And>assertion A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<lbrace>assertion\\<rbrace>);\n        extractFrame (\\<lbrace>assertion\\<rbrace>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 4. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 5. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 6. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 7. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 8. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "moreover"], ["proof (state)\nthis:\n  \\<Psi>\\<^sub>P\\<^sub>Q = \\<Psi>\\<^sub>P \\<otimes> \\<Psi>\\<^sub>Q\n\ngoal (8 subgoals):\n 1. \\<And>psi1 psi2 A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi1;\n                    extractFrame psi1 =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n           \\<lbrakk>guarded psi2;\n            extractFrame psi2 =\n            \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n           \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                             supp \\<Psi>\\<^sub>P = {};\n        guarded (psi1 \\<parallel> psi2);\n        extractFrame (psi1 \\<parallel> psi2) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>name psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (\\<lparr>\\<nu>name\\<rparr>psi);\n        extractFrame (\\<lparr>\\<nu>name\\<rparr>psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 3. \\<And>assertion A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<lbrace>assertion\\<rbrace>);\n        extractFrame (\\<lbrace>assertion\\<rbrace>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 4. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 5. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 6. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 7. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 8. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "from \\<open>\\<Psi>\\<^sub>P \\<simeq> \\<bottom>\\<close> \\<open>\\<Psi>\\<^sub>Q \\<simeq> \\<bottom>\\<close>"], ["proof (chain)\npicking this:\n  \\<Psi>\\<^sub>P \\<simeq> \\<bottom>\n  \\<Psi>\\<^sub>Q \\<simeq> \\<bottom>", "have \"\\<Psi>\\<^sub>P \\<otimes> \\<Psi>\\<^sub>Q \\<simeq> \\<bottom>\""], ["proof (prove)\nusing this:\n  \\<Psi>\\<^sub>P \\<simeq> \\<bottom>\n  \\<Psi>\\<^sub>Q \\<simeq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>P \\<otimes> \\<Psi>\\<^sub>Q \\<simeq> \\<bottom>", "by(metis Composition Identity Associativity Commutativity AssertionStatEqTrans)"], ["proof (state)\nthis:\n  \\<Psi>\\<^sub>P \\<otimes> \\<Psi>\\<^sub>Q \\<simeq> \\<bottom>\n\ngoal (8 subgoals):\n 1. \\<And>psi1 psi2 A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi1;\n                    extractFrame psi1 =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n           \\<lbrakk>guarded psi2;\n            extractFrame psi2 =\n            \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n           \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                             supp \\<Psi>\\<^sub>P = {};\n        guarded (psi1 \\<parallel> psi2);\n        extractFrame (psi1 \\<parallel> psi2) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>name psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (\\<lparr>\\<nu>name\\<rparr>psi);\n        extractFrame (\\<lparr>\\<nu>name\\<rparr>psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 3. \\<And>assertion A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<lbrace>assertion\\<rbrace>);\n        extractFrame (\\<lbrace>assertion\\<rbrace>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 4. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 5. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 6. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 7. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 8. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "ultimately"], ["proof (chain)\npicking this:\n  \\<Psi>\\<^sub>P\\<^sub>Q = \\<Psi>\\<^sub>P \\<otimes> \\<Psi>\\<^sub>Q\n  \\<Psi>\\<^sub>P \\<otimes> \\<Psi>\\<^sub>Q \\<simeq> \\<bottom>", "show ?case"], ["proof (prove)\nusing this:\n  \\<Psi>\\<^sub>P\\<^sub>Q = \\<Psi>\\<^sub>P \\<otimes> \\<Psi>\\<^sub>Q\n  \\<Psi>\\<^sub>P \\<otimes> \\<Psi>\\<^sub>Q \\<simeq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>P\\<^sub>Q \\<simeq> \\<bottom> \\<and>\n    supp \\<Psi>\\<^sub>P\\<^sub>Q = {}", "using \\<open>supp \\<Psi>\\<^sub>P = {}\\<close> \\<open>supp \\<Psi>\\<^sub>Q = {}\\<close> compSupp"], ["proof (prove)\nusing this:\n  \\<Psi>\\<^sub>P\\<^sub>Q = \\<Psi>\\<^sub>P \\<otimes> \\<Psi>\\<^sub>Q\n  \\<Psi>\\<^sub>P \\<otimes> \\<Psi>\\<^sub>Q \\<simeq> \\<bottom>\n  supp \\<Psi>\\<^sub>P = {}\n  supp \\<Psi>\\<^sub>Q = {}\n  supp (?\\<Psi> \\<otimes> ?\\<Psi>')\n  \\<subseteq> supp ?\\<Psi> \\<union> supp ?\\<Psi>'\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>P\\<^sub>Q \\<simeq> \\<bottom> \\<and>\n    supp \\<Psi>\\<^sub>P\\<^sub>Q = {}", "by blast"], ["proof (state)\nthis:\n  \\<Psi>\\<^sub>P\\<^sub>Q \\<simeq> \\<bottom> \\<and>\n  supp \\<Psi>\\<^sub>P\\<^sub>Q = {}\n\ngoal (7 subgoals):\n 1. \\<And>name psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (\\<lparr>\\<nu>name\\<rparr>psi);\n        extractFrame (\\<lparr>\\<nu>name\\<rparr>psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>assertion A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<lbrace>assertion\\<rbrace>);\n        extractFrame (\\<lbrace>assertion\\<rbrace>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 3. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 4. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 5. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 6. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 7. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>name psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (\\<lparr>\\<nu>name\\<rparr>psi);\n        extractFrame (\\<lparr>\\<nu>name\\<rparr>psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>assertion A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<lbrace>assertion\\<rbrace>);\n        extractFrame (\\<lbrace>assertion\\<rbrace>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 3. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 4. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 5. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 6. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 7. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "case(Res x P A\\<^sub>x\\<^sub>P \\<Psi>\\<^sub>x\\<^sub>P)"], ["proof (state)\nthis:\n  \\<lbrakk>guarded P;\n   extractFrame P = \\<langle>?A\\<^sub>P, ?\\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> ?\\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                    supp ?\\<Psi>\\<^sub>P = {}\n  guarded (\\<lparr>\\<nu>x\\<rparr>P)\n  extractFrame (\\<lparr>\\<nu>x\\<rparr>P) =\n  \\<langle>A\\<^sub>x\\<^sub>P, \\<Psi>\\<^sub>x\\<^sub>P\\<rangle>\n\ngoal (7 subgoals):\n 1. \\<And>name psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (\\<lparr>\\<nu>name\\<rparr>psi);\n        extractFrame (\\<lparr>\\<nu>name\\<rparr>psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>assertion A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<lbrace>assertion\\<rbrace>);\n        extractFrame (\\<lbrace>assertion\\<rbrace>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 3. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 4. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 5. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 6. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 7. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "from \\<open>guarded(\\<lparr>\\<nu>x\\<rparr>P)\\<close>"], ["proof (chain)\npicking this:\n  guarded (\\<lparr>\\<nu>x\\<rparr>P)", "have \"guarded P\""], ["proof (prove)\nusing this:\n  guarded (\\<lparr>\\<nu>x\\<rparr>P)\n\ngoal (1 subgoal):\n 1. guarded P", "by simp"], ["proof (state)\nthis:\n  guarded P\n\ngoal (7 subgoals):\n 1. \\<And>name psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (\\<lparr>\\<nu>name\\<rparr>psi);\n        extractFrame (\\<lparr>\\<nu>name\\<rparr>psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>assertion A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<lbrace>assertion\\<rbrace>);\n        extractFrame (\\<lbrace>assertion\\<rbrace>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 3. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 4. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 5. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 6. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 7. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "moreover"], ["proof (state)\nthis:\n  guarded P\n\ngoal (7 subgoals):\n 1. \\<And>name psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (\\<lparr>\\<nu>name\\<rparr>psi);\n        extractFrame (\\<lparr>\\<nu>name\\<rparr>psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>assertion A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<lbrace>assertion\\<rbrace>);\n        extractFrame (\\<lbrace>assertion\\<rbrace>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 3. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 4. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 5. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 6. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 7. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "obtain A\\<^sub>P \\<Psi>\\<^sub>P where FrP: \"extractFrame P = \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n        extractFrame P =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(rule freshFrame)"], ["proof (state)\nthis:\n  extractFrame P = \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\n\ngoal (7 subgoals):\n 1. \\<And>name psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (\\<lparr>\\<nu>name\\<rparr>psi);\n        extractFrame (\\<lparr>\\<nu>name\\<rparr>psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>assertion A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<lbrace>assertion\\<rbrace>);\n        extractFrame (\\<lbrace>assertion\\<rbrace>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 3. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 4. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 5. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 6. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 7. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "moreover"], ["proof (state)\nthis:\n  extractFrame P = \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\n\ngoal (7 subgoals):\n 1. \\<And>name psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (\\<lparr>\\<nu>name\\<rparr>psi);\n        extractFrame (\\<lparr>\\<nu>name\\<rparr>psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>assertion A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<lbrace>assertion\\<rbrace>);\n        extractFrame (\\<lbrace>assertion\\<rbrace>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 3. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 4. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 5. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 6. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 7. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "note \\<open>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P. \\<lbrakk>guarded P; extractFrame P = \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk> \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and> (supp \\<Psi>\\<^sub>P = ({}::name set))\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>guarded P;\n   extractFrame P = \\<langle>?A\\<^sub>P, ?\\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> ?\\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                    supp ?\\<Psi>\\<^sub>P = {}\n\ngoal (7 subgoals):\n 1. \\<And>name psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (\\<lparr>\\<nu>name\\<rparr>psi);\n        extractFrame (\\<lparr>\\<nu>name\\<rparr>psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>assertion A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<lbrace>assertion\\<rbrace>);\n        extractFrame (\\<lbrace>assertion\\<rbrace>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 3. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 4. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 5. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 6. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 7. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "ultimately"], ["proof (chain)\npicking this:\n  guarded P\n  extractFrame P = \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\n  \\<lbrakk>guarded P;\n   extractFrame P = \\<langle>?A\\<^sub>P, ?\\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> ?\\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                    supp ?\\<Psi>\\<^sub>P = {}", "have \"\\<Psi>\\<^sub>P \\<simeq> \\<bottom>\" and \"supp \\<Psi>\\<^sub>P = ({}::name set)\""], ["proof (prove)\nusing this:\n  guarded P\n  extractFrame P = \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\n  \\<lbrakk>guarded P;\n   extractFrame P = \\<langle>?A\\<^sub>P, ?\\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> ?\\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                    supp ?\\<Psi>\\<^sub>P = {}\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>P \\<simeq> \\<bottom> &&& supp \\<Psi>\\<^sub>P = {}", "by auto"], ["proof (state)\nthis:\n  \\<Psi>\\<^sub>P \\<simeq> \\<bottom>\n  supp \\<Psi>\\<^sub>P = {}\n\ngoal (7 subgoals):\n 1. \\<And>name psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (\\<lparr>\\<nu>name\\<rparr>psi);\n        extractFrame (\\<lparr>\\<nu>name\\<rparr>psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>assertion A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<lbrace>assertion\\<rbrace>);\n        extractFrame (\\<lbrace>assertion\\<rbrace>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 3. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 4. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 5. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 6. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 7. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "from FrP \\<open>extractFrame(\\<lparr>\\<nu>x\\<rparr>P) = \\<langle>A\\<^sub>x\\<^sub>P, \\<Psi>\\<^sub>x\\<^sub>P\\<rangle>\\<close>"], ["proof (chain)\npicking this:\n  extractFrame P = \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\n  extractFrame (\\<lparr>\\<nu>x\\<rparr>P) =\n  \\<langle>A\\<^sub>x\\<^sub>P, \\<Psi>\\<^sub>x\\<^sub>P\\<rangle>", "have \"\\<langle>(x#A\\<^sub>P), \\<Psi>\\<^sub>P\\<rangle> = \\<langle>A\\<^sub>x\\<^sub>P, \\<Psi>\\<^sub>x\\<^sub>P\\<rangle>\""], ["proof (prove)\nusing this:\n  extractFrame P = \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\n  extractFrame (\\<lparr>\\<nu>x\\<rparr>P) =\n  \\<langle>A\\<^sub>x\\<^sub>P, \\<Psi>\\<^sub>x\\<^sub>P\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>(x # A\\<^sub>P), \\<Psi>\\<^sub>P\\<rangle> =\n    \\<langle>A\\<^sub>x\\<^sub>P, \\<Psi>\\<^sub>x\\<^sub>P\\<rangle>", "by simp"], ["proof (state)\nthis:\n  \\<langle>(x # A\\<^sub>P), \\<Psi>\\<^sub>P\\<rangle> =\n  \\<langle>A\\<^sub>x\\<^sub>P, \\<Psi>\\<^sub>x\\<^sub>P\\<rangle>\n\ngoal (7 subgoals):\n 1. \\<And>name psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (\\<lparr>\\<nu>name\\<rparr>psi);\n        extractFrame (\\<lparr>\\<nu>name\\<rparr>psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>assertion A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<lbrace>assertion\\<rbrace>);\n        extractFrame (\\<lbrace>assertion\\<rbrace>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 3. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 4. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 5. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 6. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 7. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "with \\<open>supp \\<Psi>\\<^sub>P = {}\\<close>"], ["proof (chain)\npicking this:\n  supp \\<Psi>\\<^sub>P = {}\n  \\<langle>(x # A\\<^sub>P), \\<Psi>\\<^sub>P\\<rangle> =\n  \\<langle>A\\<^sub>x\\<^sub>P, \\<Psi>\\<^sub>x\\<^sub>P\\<rangle>", "have \"\\<Psi>\\<^sub>P = \\<Psi>\\<^sub>x\\<^sub>P\""], ["proof (prove)\nusing this:\n  supp \\<Psi>\\<^sub>P = {}\n  \\<langle>(x # A\\<^sub>P), \\<Psi>\\<^sub>P\\<rangle> =\n  \\<langle>A\\<^sub>x\\<^sub>P, \\<Psi>\\<^sub>x\\<^sub>P\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>P = \\<Psi>\\<^sub>x\\<^sub>P", "by(auto simp del: frameResChain.simps)"], ["proof (state)\nthis:\n  \\<Psi>\\<^sub>P = \\<Psi>\\<^sub>x\\<^sub>P\n\ngoal (7 subgoals):\n 1. \\<And>name psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (\\<lparr>\\<nu>name\\<rparr>psi);\n        extractFrame (\\<lparr>\\<nu>name\\<rparr>psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>assertion A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<lbrace>assertion\\<rbrace>);\n        extractFrame (\\<lbrace>assertion\\<rbrace>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 3. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 4. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 5. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 6. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 7. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "with \\<open>\\<Psi>\\<^sub>P \\<simeq> \\<bottom>\\<close> \\<open>supp \\<Psi>\\<^sub>P = {}\\<close>"], ["proof (chain)\npicking this:\n  \\<Psi>\\<^sub>P \\<simeq> \\<bottom>\n  supp \\<Psi>\\<^sub>P = {}\n  \\<Psi>\\<^sub>P = \\<Psi>\\<^sub>x\\<^sub>P", "show ?case"], ["proof (prove)\nusing this:\n  \\<Psi>\\<^sub>P \\<simeq> \\<bottom>\n  supp \\<Psi>\\<^sub>P = {}\n  \\<Psi>\\<^sub>P = \\<Psi>\\<^sub>x\\<^sub>P\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>x\\<^sub>P \\<simeq> \\<bottom> \\<and>\n    supp \\<Psi>\\<^sub>x\\<^sub>P = {}", "by simp"], ["proof (state)\nthis:\n  \\<Psi>\\<^sub>x\\<^sub>P \\<simeq> \\<bottom> \\<and>\n  supp \\<Psi>\\<^sub>x\\<^sub>P = {}\n\ngoal (6 subgoals):\n 1. \\<And>assertion A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<lbrace>assertion\\<rbrace>);\n        extractFrame (\\<lbrace>assertion\\<rbrace>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 3. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 4. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 5. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 6. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>assertion A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<lbrace>assertion\\<rbrace>);\n        extractFrame (\\<lbrace>assertion\\<rbrace>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 3. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 4. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 5. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 6. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "case(Assert \\<Psi> A\\<^sub>P \\<Psi>\\<^sub>P)"], ["proof (state)\nthis:\n  guarded (\\<lbrace>\\<Psi>\\<rbrace>)\n  extractFrame (\\<lbrace>\\<Psi>\\<rbrace>) =\n  \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\n\ngoal (6 subgoals):\n 1. \\<And>assertion A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>guarded (\\<lbrace>assertion\\<rbrace>);\n        extractFrame (\\<lbrace>assertion\\<rbrace>) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 3. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 4. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 5. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 6. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "thus ?case"], ["proof (prove)\nusing this:\n  guarded (\\<lbrace>\\<Psi>\\<rbrace>)\n  extractFrame (\\<lbrace>\\<Psi>\\<rbrace>) =\n  \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and> supp \\<Psi>\\<^sub>P = {}", "by simp"], ["proof (state)\nthis:\n  \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and> supp \\<Psi>\\<^sub>P = {}\n\ngoal (5 subgoals):\n 1. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 3. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 4. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 5. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 3. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 4. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 5. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "case(Bang P A\\<^sub>P \\<Psi>\\<^sub>P)"], ["proof (state)\nthis:\n  \\<lbrakk>guarded P;\n   extractFrame P = \\<langle>?A\\<^sub>P, ?\\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> ?\\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                    supp ?\\<Psi>\\<^sub>P = {}\n  guarded (!P)\n  extractFrame (!P) = \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\n\ngoal (5 subgoals):\n 1. \\<And>psi A\\<^sub>P \\<Psi>\\<^sub>P.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded (!psi);\n        extractFrame (!psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 3. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 4. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 5. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>guarded P;\n   extractFrame P = \\<langle>?A\\<^sub>P, ?\\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> ?\\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                    supp ?\\<Psi>\\<^sub>P = {}\n  guarded (!P)\n  extractFrame (!P) = \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and> supp \\<Psi>\\<^sub>P = {}", "by simp"], ["proof (state)\nthis:\n  \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and> supp \\<Psi>\\<^sub>P = {}\n\ngoal (4 subgoals):\n 1. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 3. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 4. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 3. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 4. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "case(Trm M P)"], ["proof (state)\nthis:\n  \\<lbrakk>guarded P;\n   extractFrame P = \\<langle>?A\\<^sub>P, ?\\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> ?\\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                    supp ?\\<Psi>\\<^sub>P = {}\n  guarded' (\\<rparr>M.P)\n  extractFrame' (\\<rparr>M.P) = \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\n\ngoal (4 subgoals):\n 1. \\<And>term psi.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<rparr>term.psi);\n        extractFrame' (\\<rparr>term.psi) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 3. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 4. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>guarded P;\n   extractFrame P = \\<langle>?A\\<^sub>P, ?\\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> ?\\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                    supp ?\\<Psi>\\<^sub>P = {}\n  guarded' (\\<rparr>M.P)\n  extractFrame' (\\<rparr>M.P) = \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and> supp \\<Psi>\\<^sub>P = {}", "by simp"], ["proof (state)\nthis:\n  \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and> supp \\<Psi>\\<^sub>P = {}\n\ngoal (3 subgoals):\n 1. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 3. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 3. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "case(Bind x I)"], ["proof (state)\nthis:\n  \\<lbrakk>guarded' I;\n   extractFrame' I = \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                    supp \\<Psi>\\<^sub>P = {}\n  guarded' (\\<nu>xI)\n  extractFrame' (\\<nu>xI) = \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\n\ngoal (3 subgoals):\n 1. \\<And>name input.\n       \\<lbrakk>\\<lbrakk>guarded' input;\n                 extractFrame' input =\n                 \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                                  supp \\<Psi>\\<^sub>P = {};\n        guarded' (\\<nu>nameinput);\n        extractFrame' (\\<nu>nameinput) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}\n 2. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 3. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>guarded' I;\n   extractFrame' I = \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                    supp \\<Psi>\\<^sub>P = {}\n  guarded' (\\<nu>xI)\n  extractFrame' (\\<nu>xI) = \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and> supp \\<Psi>\\<^sub>P = {}", "by simp"], ["proof (state)\nthis:\n  \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and> supp \\<Psi>\\<^sub>P = {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "case EmptyCase"], ["proof (state)\nthis:\n  guarded'' (\\<bottom>\\<^sub>c)\n  extractFrame'' (\\<bottom>\\<^sub>c) =\n  \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>guarded'' (\\<bottom>\\<^sub>c);\n     extractFrame'' (\\<bottom>\\<^sub>c) =\n     \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                      supp \\<Psi>\\<^sub>P = {}\n 2. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "thus ?case"], ["proof (prove)\nusing this:\n  guarded'' (\\<bottom>\\<^sub>c)\n  extractFrame'' (\\<bottom>\\<^sub>c) =\n  \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and> supp \\<Psi>\\<^sub>P = {}", "by simp"], ["proof (state)\nthis:\n  \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and> supp \\<Psi>\\<^sub>P = {}\n\ngoal (1 subgoal):\n 1. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "case(Cond \\<phi> P psiCase)"], ["proof (state)\nthis:\n  \\<lbrakk>guarded P;\n   extractFrame P = \\<langle>?A\\<^sub>P, ?\\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> ?\\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                    supp ?\\<Psi>\\<^sub>P = {}\n  \\<lbrakk>guarded'' psiCase;\n   extractFrame'' psiCase =\n   \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                    supp \\<Psi>\\<^sub>P = {}\n  guarded'' (\\<box> \\<phi> \\<Rightarrow> P psiCase )\n  extractFrame'' (\\<box> \\<phi> \\<Rightarrow> P psiCase ) =\n  \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>condition psi psiCase.\n       \\<lbrakk>\\<And>A\\<^sub>P \\<Psi>\\<^sub>P.\n                   \\<lbrakk>guarded psi;\n                    extractFrame psi =\n                    \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n                   \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq>\n                                     \\<bottom> \\<and>\n                                     supp \\<Psi>\\<^sub>P = {};\n        \\<lbrakk>guarded'' psiCase;\n         extractFrame'' psiCase =\n         \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                          supp \\<Psi>\\<^sub>P = {};\n        guarded'' (\\<box> condition \\<Rightarrow> psi psiCase );\n        extractFrame'' (\\<box> condition \\<Rightarrow> psi psiCase ) =\n        \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                         supp \\<Psi>\\<^sub>P = {}", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>guarded P;\n   extractFrame P = \\<langle>?A\\<^sub>P, ?\\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> ?\\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                    supp ?\\<Psi>\\<^sub>P = {}\n  \\<lbrakk>guarded'' psiCase;\n   extractFrame'' psiCase =\n   \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and>\n                    supp \\<Psi>\\<^sub>P = {}\n  guarded'' (\\<box> \\<phi> \\<Rightarrow> P psiCase )\n  extractFrame'' (\\<box> \\<phi> \\<Rightarrow> P psiCase ) =\n  \\<langle>A\\<^sub>P, \\<Psi>\\<^sub>P\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and> supp \\<Psi>\\<^sub>P = {}", "by simp"], ["proof (state)\nthis:\n  \\<Psi>\\<^sub>P \\<simeq> \\<bottom> \\<and> supp \\<Psi>\\<^sub>P = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}