{"file_name": "/home/qj213/afp-2021-10-22/thys/Syntax_Independent_Logic/Prelim.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Syntax_Independent_Logic", "problem_names": ["lemma Un_Diff2: \"B \\<inter> C = {} \\<Longrightarrow> A \\<union> B - C = A - C \\<union> B\"", "lemma Diff_Diff_Un: \"A - B - C = A - (B \\<union> C)\"", "lemma fst_set_zip_map_fst:\n  \"length xs = length ys \\<Longrightarrow> fst ` (set (zip (map fst xs) ys)) = fst ` (set xs)\"", "lemma snd_set_zip_map_snd:\n  \"length xs = length ys \\<Longrightarrow> snd ` (set (zip xs (map snd ys))) = snd ` (set ys)\"", "lemma snd_set_zip:\n  \"length xs = length ys \\<Longrightarrow> snd ` (set (zip xs ys)) = set ys\"", "lemma set_zip_D: \"(x, y) \\<in> set (zip xs ys) \\<Longrightarrow> x \\<in> set xs \\<and> y \\<in> set ys\"", "lemma inj_on_set_zip_map:\n  assumes i: \"inj_on f X\"\n    and a: \"(f x1, y1) \\<in> set (zip (map f xs) ys)\" \"set xs \\<subseteq> X\" \"x1 \\<in> X\" \"length xs = length ys\"\n  shows \"(x1, y1) \\<in> set (zip xs ys)\"", "lemma set_zip_map_fst_snd:\n  assumes \"(u,x) \\<in> set (zip us (map snd txs))\"\n    and \"(t,u) \\<in> set (zip (map fst txs) us)\"\n    and \"distinct (map snd txs)\"\n    and \"distinct us\" and \"length us = length txs\"\n  shows \"(t, x) \\<in> set txs\"", "lemma set_zip_map_fst_snd2:\n  assumes \"(u, x) \\<in> set (zip us (map snd txs))\"\n    and \"(t, x) \\<in> set txs\"\n    and \"distinct (map snd txs)\"\n    and \"distinct us\" and \"length us = length txs\"\n  shows \"(t, u) \\<in> set (zip (map fst txs) us)\"", "lemma set_zip_length_map:\n  assumes \"(x1, y1) \\<in> set (zip xs ys)\" and \"length xs = length ys\"\n  shows \"(f x1, y1) \\<in> set (zip (map f xs) ys)\"", "lemma asList[simp,intro!]: \"finite A \\<Longrightarrow> set (asList A) = A\"", "lemma triv_Un_imp_aux:\n  \"(\\<And>a. \\<phi> \\<Longrightarrow> a \\<notin> A \\<Longrightarrow> a \\<in> B \\<longleftrightarrow> a \\<in> C) \\<Longrightarrow> \\<phi> \\<longrightarrow> A \\<union> B = A \\<union> C\"", "lemma set_toN[simp]: \"set (toN n) = {0..n}\""], "translations": [["", "lemma Un_Diff2: \"B \\<inter> C = {} \\<Longrightarrow> A \\<union> B - C = A - C \\<union> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<inter> C = {} \\<Longrightarrow> A \\<union> B - C = A - C \\<union> B", "by auto"], ["", "lemma Diff_Diff_Un: \"A - B - C = A - (B \\<union> C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A - B - C = A - (B \\<union> C)", "by auto"], ["", "fun first :: \"nat \\<Rightarrow> nat list\" where\n  \"first 0 = []\"\n| \"first (Suc n) = n # first n\""], ["", "text \\<open>Facts about zipping lists:\\<close>"], ["", "lemma fst_set_zip_map_fst:\n  \"length xs = length ys \\<Longrightarrow> fst ` (set (zip (map fst xs) ys)) = fst ` (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = length ys \\<Longrightarrow>\n    fst ` set (zip (map fst xs) ys) = fst ` set xs", "by (induct xs ys rule: list_induct2) auto"], ["", "lemma snd_set_zip_map_snd:\n  \"length xs = length ys \\<Longrightarrow> snd ` (set (zip xs (map snd ys))) = snd ` (set ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = length ys \\<Longrightarrow>\n    snd ` set (zip xs (map snd ys)) = snd ` set ys", "by (induct xs ys rule: list_induct2) auto"], ["", "lemma snd_set_zip:\n  \"length xs = length ys \\<Longrightarrow> snd ` (set (zip xs ys)) = set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = length ys \\<Longrightarrow> snd ` set (zip xs ys) = set ys", "by (induct xs ys rule: list_induct2) auto"], ["", "lemma set_zip_D: \"(x, y) \\<in> set (zip xs ys) \\<Longrightarrow> x \\<in> set xs \\<and> y \\<in> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> set (zip xs ys) \\<Longrightarrow>\n    x \\<in> set xs \\<and> y \\<in> set ys", "using set_zip_leftD set_zip_rightD"], ["proof (prove)\nusing this:\n  (?x, ?y) \\<in> set (zip ?xs ?ys) \\<Longrightarrow> ?x \\<in> set ?xs\n  (?x, ?y) \\<in> set (zip ?xs ?ys) \\<Longrightarrow> ?y \\<in> set ?ys\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> set (zip xs ys) \\<Longrightarrow>\n    x \\<in> set xs \\<and> y \\<in> set ys", "by auto"], ["", "lemma inj_on_set_zip_map:\n  assumes i: \"inj_on f X\"\n    and a: \"(f x1, y1) \\<in> set (zip (map f xs) ys)\" \"set xs \\<subseteq> X\" \"x1 \\<in> X\" \"length xs = length ys\"\n  shows \"(x1, y1) \\<in> set (zip xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x1, y1) \\<in> set (zip xs ys)", "using a"], ["proof (prove)\nusing this:\n  (f x1, y1) \\<in> set (zip (map f xs) ys)\n  set xs \\<subseteq> X\n  x1 \\<in> X\n  length xs = length ys\n\ngoal (1 subgoal):\n 1. (x1, y1) \\<in> set (zip xs ys)", "proof (induct xs arbitrary: ys x1 y1)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys x1 y1.\n       \\<lbrakk>(f x1, y1) \\<in> set (zip (map f []) ys);\n        set [] \\<subseteq> X; x1 \\<in> X; length [] = length ys\\<rbrakk>\n       \\<Longrightarrow> (x1, y1) \\<in> set (zip [] ys)\n 2. \\<And>a xs ys x1 y1.\n       \\<lbrakk>\\<And>ys x1 y1.\n                   \\<lbrakk>(f x1, y1) \\<in> set (zip (map f xs) ys);\n                    set xs \\<subseteq> X; x1 \\<in> X;\n                    length xs = length ys\\<rbrakk>\n                   \\<Longrightarrow> (x1, y1) \\<in> set (zip xs ys);\n        (f x1, y1) \\<in> set (zip (map f (a # xs)) ys);\n        set (a # xs) \\<subseteq> X; x1 \\<in> X;\n        length (a # xs) = length ys\\<rbrakk>\n       \\<Longrightarrow> (x1, y1) \\<in> set (zip (a # xs) ys)", "case (Cons x xs yys)"], ["proof (state)\nthis:\n  \\<lbrakk>(f ?x1.0, ?y1.0) \\<in> set (zip (map f xs) ?ys);\n   set xs \\<subseteq> X; ?x1.0 \\<in> X; length xs = length ?ys\\<rbrakk>\n  \\<Longrightarrow> (?x1.0, ?y1.0) \\<in> set (zip xs ?ys)\n  (f x1, y1) \\<in> set (zip (map f (x # xs)) yys)\n  set (x # xs) \\<subseteq> X\n  x1 \\<in> X\n  length (x # xs) = length yys\n\ngoal (2 subgoals):\n 1. \\<And>ys x1 y1.\n       \\<lbrakk>(f x1, y1) \\<in> set (zip (map f []) ys);\n        set [] \\<subseteq> X; x1 \\<in> X; length [] = length ys\\<rbrakk>\n       \\<Longrightarrow> (x1, y1) \\<in> set (zip [] ys)\n 2. \\<And>a xs ys x1 y1.\n       \\<lbrakk>\\<And>ys x1 y1.\n                   \\<lbrakk>(f x1, y1) \\<in> set (zip (map f xs) ys);\n                    set xs \\<subseteq> X; x1 \\<in> X;\n                    length xs = length ys\\<rbrakk>\n                   \\<Longrightarrow> (x1, y1) \\<in> set (zip xs ys);\n        (f x1, y1) \\<in> set (zip (map f (a # xs)) ys);\n        set (a # xs) \\<subseteq> X; x1 \\<in> X;\n        length (a # xs) = length ys\\<rbrakk>\n       \\<Longrightarrow> (x1, y1) \\<in> set (zip (a # xs) ys)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>(f ?x1.0, ?y1.0) \\<in> set (zip (map f xs) ?ys);\n   set xs \\<subseteq> X; ?x1.0 \\<in> X; length xs = length ?ys\\<rbrakk>\n  \\<Longrightarrow> (?x1.0, ?y1.0) \\<in> set (zip xs ?ys)\n  (f x1, y1) \\<in> set (zip (map f (x # xs)) yys)\n  set (x # xs) \\<subseteq> X\n  x1 \\<in> X\n  length (x # xs) = length yys\n\ngoal (1 subgoal):\n 1. (x1, y1) \\<in> set (zip (x # xs) yys)", "using i"], ["proof (prove)\nusing this:\n  \\<lbrakk>(f ?x1.0, ?y1.0) \\<in> set (zip (map f xs) ?ys);\n   set xs \\<subseteq> X; ?x1.0 \\<in> X; length xs = length ?ys\\<rbrakk>\n  \\<Longrightarrow> (?x1.0, ?y1.0) \\<in> set (zip xs ?ys)\n  (f x1, y1) \\<in> set (zip (map f (x # xs)) yys)\n  set (x # xs) \\<subseteq> X\n  x1 \\<in> X\n  length (x # xs) = length yys\n  inj_on f X\n\ngoal (1 subgoal):\n 1. (x1, y1) \\<in> set (zip (x # xs) yys)", "unfolding inj_on_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>(f ?x1.0, ?y1.0) \\<in> set (zip (map f xs) ?ys);\n   set xs \\<subseteq> X; ?x1.0 \\<in> X; length xs = length ?ys\\<rbrakk>\n  \\<Longrightarrow> (?x1.0, ?y1.0) \\<in> set (zip xs ?ys)\n  (f x1, y1) \\<in> set (zip (map f (x # xs)) yys)\n  set (x # xs) \\<subseteq> X\n  x1 \\<in> X\n  length (x # xs) = length yys\n  \\<forall>x\\<in>X. \\<forall>y\\<in>X. f x = f y \\<longrightarrow> x = y\n\ngoal (1 subgoal):\n 1. (x1, y1) \\<in> set (zip (x # xs) yys)", "by (cases yys) auto"], ["proof (state)\nthis:\n  (x1, y1) \\<in> set (zip (x # xs) yys)\n\ngoal (1 subgoal):\n 1. \\<And>ys x1 y1.\n       \\<lbrakk>(f x1, y1) \\<in> set (zip (map f []) ys);\n        set [] \\<subseteq> X; x1 \\<in> X; length [] = length ys\\<rbrakk>\n       \\<Longrightarrow> (x1, y1) \\<in> set (zip [] ys)", "qed (insert i, auto)"], ["", "lemma set_zip_map_fst_snd:\n  assumes \"(u,x) \\<in> set (zip us (map snd txs))\"\n    and \"(t,u) \\<in> set (zip (map fst txs) us)\"\n    and \"distinct (map snd txs)\"\n    and \"distinct us\" and \"length us = length txs\"\n  shows \"(t, x) \\<in> set txs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t, x) \\<in> set txs", "using assms(5,1-4)"], ["proof (prove)\nusing this:\n  length us = length txs\n  (u, x) \\<in> set (zip us (map snd txs))\n  (t, u) \\<in> set (zip (map fst txs) us)\n  distinct (map snd txs)\n  distinct us\n\ngoal (1 subgoal):\n 1. (t, x) \\<in> set txs", "by (induct us txs arbitrary: u x t rule: list_induct2)\n    (auto dest: set_zip_leftD set_zip_rightD)"], ["", "lemma set_zip_map_fst_snd2:\n  assumes \"(u, x) \\<in> set (zip us (map snd txs))\"\n    and \"(t, x) \\<in> set txs\"\n    and \"distinct (map snd txs)\"\n    and \"distinct us\" and \"length us = length txs\"\n  shows \"(t, u) \\<in> set (zip (map fst txs) us)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t, u) \\<in> set (zip (map fst txs) us)", "using assms(5,1-4)"], ["proof (prove)\nusing this:\n  length us = length txs\n  (u, x) \\<in> set (zip us (map snd txs))\n  (t, x) \\<in> set txs\n  distinct (map snd txs)\n  distinct us\n\ngoal (1 subgoal):\n 1. (t, u) \\<in> set (zip (map fst txs) us)", "by (induct us txs arbitrary: u x t rule: list_induct2)\n    (auto dest: set_zip_rightD simp: image_iff)"], ["", "lemma set_zip_length_map:\n  assumes \"(x1, y1) \\<in> set (zip xs ys)\" and \"length xs = length ys\"\n  shows \"(f x1, y1) \\<in> set (zip (map f xs) ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f x1, y1) \\<in> set (zip (map f xs) ys)", "using assms(2,1)"], ["proof (prove)\nusing this:\n  length xs = length ys\n  (x1, y1) \\<in> set (zip xs ys)\n\ngoal (1 subgoal):\n 1. (f x1, y1) \\<in> set (zip (map f xs) ys)", "by (induct xs ys arbitrary: x1 y1 rule: list_induct2) auto"], ["", "definition asList :: \"'a set \\<Rightarrow> 'a list\" where\n  \"asList A \\<equiv> SOME as. set as = A\""], ["", "lemma asList[simp,intro!]: \"finite A \\<Longrightarrow> set (asList A) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow> set (asList A) = A", "unfolding asList_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow> set (SOME as. set as = A) = A", "by (meson finite_list tfl_some)"], ["", "lemma triv_Un_imp_aux:\n  \"(\\<And>a. \\<phi> \\<Longrightarrow> a \\<notin> A \\<Longrightarrow> a \\<in> B \\<longleftrightarrow> a \\<in> C) \\<Longrightarrow> \\<phi> \\<longrightarrow> A \\<union> B = A \\<union> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>\\<phi>; a \\<notin> A\\<rbrakk>\n        \\<Longrightarrow> (a \\<in> B) = (a \\<in> C)) \\<Longrightarrow>\n    \\<phi> \\<longrightarrow> A \\<union> B = A \\<union> C", "by auto"], ["", "definition toN where \"toN n \\<equiv> [0..<(Suc n)]\""], ["", "lemma set_toN[simp]: \"set (toN n) = {0..n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (toN n) = {0..n}", "unfolding toN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set [0..<Suc n] = {0..n}", "by auto"], ["", "declare list.map_cong[cong]"], ["", "section \\<open>Some Proof Infrastructure\\<close>"], ["", "ML \\<open>\nexception TAC of term\n\nval simped = Thm.rule_attribute [] (fn context => fn thm =>\n  let\n    val ctxt = Context.proof_of context;\n    val (thm', ctxt') = yield_singleton (apfst snd oo Variable.import false) thm ctxt;\n    val full_goal = Thm.prop_of thm';\n    val goal = Goal.prove ctxt' [] [] full_goal (fn {context = ctxt, prems = _} =>\n      HEADGOAL (asm_full_simp_tac ctxt THEN' TRY o SUBGOAL (fn (goal, _) => raise (TAC goal))))\n      |> K (HOLogic.mk_Trueprop @{term True})\n      handle TAC goal => goal;\n    val thm = Goal.prove ctxt' [] [] goal (fn {context = ctxt, prems = _} =>\n      HEADGOAL (Method.insert_tac ctxt [thm'] THEN' asm_full_simp_tac ctxt))\n      |> singleton (Variable.export ctxt' ctxt);\n  in thm end)\n\nval _ = Theory.setup\n  (Attrib.setup \\<^binding>\\<open>simped\\<close> (pair simped) \"simped rule\");\n\\<close>"], ["", "method RULE methods meth uses rule =\n  (rule rule; (solves meth)?)"], ["", "text \\<open>TryUntilFail:\\<close>"], ["", "(* This is non-hazardous, since it does not touch the goal on which it fails. *)"], ["", "method TUF methods meth =\n  ((meth;fail)+)?"], ["", "text \\<open>Helping a method, usually simp or auto, with specific substitutions inserted.\nFor auto, this is a bit like a \"simp!\" analogue of \"intro!\" and \"dest!\": It forces\nthe application of an indicated simplification rule, if this is possible.\\<close>"], ["", "method variousSubsts1 methods meth uses s1 =\n  (meth?,(subst s1)?, meth?)"], ["", "method variousSubsts2 methods meth uses s1 s2 =\n  (meth?,(subst s1)?, meth?, subst s2, meth?)"], ["", "method variousSubsts3 methods meth uses s1 s2 s3 =\n  (meth?,(subst s1)?, meth?, (subst s2)?, meth?, (subst s3)?, meth?)"], ["", "method variousSubsts4 methods meth uses s1 s2 s3 s4 =\n  (meth?,(subst s1)?, meth?, (subst s2)?, meth?, (subst s3)?, meth?, (subst s4)?, meth?)"], ["", "method variousSubsts5 methods meth uses s1 s2 s3 s4 s5 =\n  (meth?,(subst s1)?, meth?, (subst s2)?, meth?, (subst s3)?, meth?, (subst s4)?, meth?, (subst s5)?, meth?)"], ["", "method variousSubsts6 methods meth uses s1 s2 s3 s4 s5 s6 =\n  (meth?,(subst s1)?, meth?, (subst s2)?, meth?, (subst s3)?, meth?,\n         (subst s4)?, meth?, (subst s5)?, meth?, (subst s6)?, meth?)"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}