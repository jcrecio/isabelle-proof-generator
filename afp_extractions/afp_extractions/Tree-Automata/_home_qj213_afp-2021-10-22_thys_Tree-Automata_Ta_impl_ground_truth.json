{"file_name": "/home/qj213/afp-2021-10-22/thys/Tree-Automata/Ta_impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Tree-Automata", "problem_names": ["lemma build_rule_index_f_correct[simp]: \n  assumes I[simp, intro!]: \"ls_invar \\<delta>\"\n  shows \"hll_idx.is_index rhsl (ls_\\<alpha> \\<delta>) (build_rule_index_f \\<delta>)\"", "lemma build_rule_index_s_correct[simp]: \n  assumes I[simp, intro!]: \"ls_invar \\<delta>\"\n  shows\n  \"hll_idx.is_index lhs (ls_\\<alpha> \\<delta>) (build_rule_index_s \\<delta>)\"", "lemma build_rule_index_sf_correct[simp]: \n  assumes I[simp, intro!]: \"ls_invar \\<delta>\"\n  shows\n  \"hll_idx.is_index (\\<lambda>r. (lhs r, rhsl r)) (ls_\\<alpha> \\<delta>) (build_rule_index_sf \\<delta>)\"", "lemma hta_ensure_idx_f_correct_\\<alpha>[simp]: \n  \"hta_\\<alpha> (hta_ensure_idx_f H) = hta_\\<alpha> H\"", "lemma hta_ensure_idx_s_correct_\\<alpha>[simp]: \n  \"hta_\\<alpha> (hta_ensure_idx_s H) = hta_\\<alpha> H\"", "lemma hta_ensure_idx_sf_correct_\\<alpha>[simp]: \n  \"hta_\\<alpha> (hta_ensure_idx_sf H) = hta_\\<alpha> H\"", "lemma hta_ensure_idx_other[simp]:\n  \"hta_Qi (hta_ensure_idx_f H) = hta_Qi H\"  \n  \"hta_\\<delta> (hta_ensure_idx_f H) = hta_\\<delta> H\"\n  \n  \"hta_Qi (hta_ensure_idx_s H) = hta_Qi H\"  \n  \"hta_\\<delta> (hta_ensure_idx_s H) = hta_\\<delta> H\"\n  \n  \"hta_Qi (hta_ensure_idx_sf H) = hta_Qi H\" \n  \"hta_\\<delta> (hta_ensure_idx_sf H) = hta_\\<delta> H\"", "lemma hta_idx_f_pres\n  [simp, intro!]: \"hta_has_idx_f (hta_ensure_idx_f H)\" and\n  [simp, intro]: \"hta_has_idx_s H \\<Longrightarrow> hta_has_idx_s (hta_ensure_idx_f H)\" and\n  [simp, intro]: \"hta_has_idx_sf H \\<Longrightarrow> hta_has_idx_sf (hta_ensure_idx_f H)\"", "lemma hta_idx_s_pres\n  [simp, intro!]: \"hta_has_idx_s (hta_ensure_idx_s H)\" and\n  [simp, intro]: \"hta_has_idx_f H \\<Longrightarrow> hta_has_idx_f (hta_ensure_idx_s H)\" and\n  [simp, intro]: \"hta_has_idx_sf H \\<Longrightarrow> hta_has_idx_sf (hta_ensure_idx_s H)\"", "lemma hta_idx_sf_pres\n  [simp, intro!]: \"hta_has_idx_sf (hta_ensure_idx_sf H)\" and\n  [simp, intro]: \"hta_has_idx_f H \\<Longrightarrow> hta_has_idx_f (hta_ensure_idx_sf H)\" and\n  [simp, intro]: \"hta_has_idx_s H \\<Longrightarrow> hta_has_idx_s (hta_ensure_idx_sf H)\"", "lemma hta_lookup_f_correct: \n    \"hta_has_idx_f H \\<Longrightarrow> ls_\\<alpha> (hta_lookup_f f H) = {r\\<in>ls_\\<alpha> \\<delta> . rhsl r = f}\"\n    \"hta_has_idx_f H \\<Longrightarrow> ls_invar (hta_lookup_f f H)\"", "lemma hta_lookup_s_correct: \n    \"hta_has_idx_s H \\<Longrightarrow> ls_\\<alpha> (hta_lookup_s q H) = {r\\<in>ls_\\<alpha> \\<delta> . lhs r = q}\"\n    \"hta_has_idx_s H \\<Longrightarrow> ls_invar (hta_lookup_s q H)\"", "lemma hta_lookup_sf_correct: \n    \"hta_has_idx_sf H \n      \\<Longrightarrow> ls_\\<alpha> (hta_lookup_sf q f H) = {r\\<in>ls_\\<alpha> \\<delta> . lhs r = q \\<and> rhsl r = f}\"\n    \"hta_has_idx_sf H \\<Longrightarrow> ls_invar (hta_lookup_sf q f H)\"", "lemma hta_ensure_idx_f_correct[simp, intro!]: \"hashedTa (hta_ensure_idx_f H)\"", "lemma hta_ensure_idx_s_correct[simp, intro!]: \"hashedTa (hta_ensure_idx_s H)\"", "lemma hta_ensure_idx_sf_correct[simp, intro!]: \"hashedTa (hta_ensure_idx_sf H)\"", "lemma hta_\\<alpha>_is_ta[simp, intro!]: \"tree_automaton (hta_\\<alpha> H)\"", "lemmas [simp, intro] = \n  hashedTa.hta_ensure_idx_f_correct\n  hashedTa.hta_ensure_idx_s_correct\n  hashedTa.hta_ensure_idx_sf_correct\n\n  \\<comment> \\<open>Build a tree automaton from a set of initial states and a set of rules\\<close>", "lemma (in hashedTa) init_hta_is_hta: \n  \"hashedTa (init_hta (hta_Qi H) (hta_\\<delta> H))\"", "lemma r_match_by_laz: \"r_match L l = list_all_zip (\\<lambda>Q q. q\\<in>Q) L l\"", "lemma faccs'_invar:\n    assumes HI[simp, intro!]: \"hta_has_idx_f H\"\n    shows \"ls_invar (faccs' H t)\" (is ?T1) \n          \"list_all ls_invar (List.map (faccs' H) ts)\" (is ?T2)", "lemma faccs'_correct:\n    assumes HI[simp, intro!]: \"hta_has_idx_f H\"\n    shows \n      \"ls_\\<alpha> (faccs' H t) = faccs (ls_\\<alpha> (hta_\\<delta> H)) t\" (is ?T1)\n      \"List.map ls_\\<alpha> (List.map (faccs' H) ts) \n       = List.map (faccs (ls_\\<alpha> (hta_\\<delta> H))) ts\" (is ?T2)", "lemma hta_mem'_correct: \n    \"hta_has_idx_f H \\<Longrightarrow> hta_mem' t H \\<longleftrightarrow> t\\<in>ta_lang (hta_\\<alpha> H)\"", "theorem hta_mem_correct: \"hta_mem t H \\<longleftrightarrow> t\\<in>ta_lang (hta_\\<alpha> H)\"", "lemma r_prod_inj: \n  \"\\<lbrakk> rhsl r1 = rhsl r2; length (rhsq r1) = length (rhsq r2); \n     rhsl r1' = rhsl r2'; length (rhsq r1') = length (rhsq r2'); \n     r_prod r1 r2 = r_prod r1' r2' \\<rbrakk> \\<Longrightarrow> r1=r1' \\<and> r2=r2'\"", "lemma \\<delta>_prod_h_correct:\n  assumes INV[simp]: \"ls_invar \\<delta>1\" \"ls_invar \\<delta>2\"\n  shows \n    \"ls_\\<alpha> (\\<delta>_prod_h \\<delta>1 \\<delta>2) = \\<delta>_prod (ls_\\<alpha> \\<delta>1) (ls_\\<alpha> \\<delta>2)\"\n    \"ls_invar (\\<delta>_prod_h \\<delta>1 \\<delta>2)\"", "lemma hta_prodWR_correct_aux: \n  assumes A: \"hashedTa H1\" \"hashedTa H2\"\n  shows \n    \"hta_\\<alpha> (hta_prodWR H1 H2) = ta_prod (hta_\\<alpha> H1) (hta_\\<alpha> H2)\" (is ?T1)\n    \"hashedTa (hta_prodWR H1 H2)\" (is ?T2)", "lemma hta_prodWR_correct:\n  assumes TA: \"hashedTa H1\" \"hashedTa H2\"\n  shows \n    \"ta_lang (hta_\\<alpha> (hta_prodWR H1 H2)) \n     = ta_lang (hta_\\<alpha> H1) \\<inter> ta_lang (hta_\\<alpha> H2)\"\n    \"hashedTa (hta_prodWR H1 H2)\"", "lemma pa_upd_rule_correct:\n  assumes INV[simp, intro!]: \"hs_invar Q\"\n  assumes FMT: \"pa_upd_rule Q W qs = (Q',W')\"\n  shows\n    \"hs_invar Q'\" (is ?T1)\n    \"hs_\\<alpha> Q' = hs_\\<alpha> Q \\<union> set qs\" (is ?T2)\n    \"\\<exists>Wn. distinct Wn \\<and> set Wn = set qs - hs_\\<alpha> Q \\<and> W'=Wn@W\" (is ?T3)", "lemma pa_step_correct:\n  assumes TA: \"hashedTa H1\" \"hashedTa H2\"\n  assumes idx[simp]: \"hta_has_idx_s H1\" \"hta_has_idx_sf H2\"\n  assumes INV: \"(Q,W,\\<delta>d)\\<in>pa_invar H1 H2\"\n  assumes COND: \"pa_cond (Q,W,\\<delta>d)\"\n  shows \n    \"(pa_step H1 H2 (Q,W,\\<delta>d))\\<in>pa_invar_add\" (is ?T1)\n    \"(pa_\\<alpha> (Q,W,\\<delta>d), pa_\\<alpha> (pa_step H1 H2 (Q,W,\\<delta>d))) \n     \\<in> frp_step (ls_\\<alpha> (hta_\\<delta> H1)) (ls_\\<alpha> (hta_\\<delta> H2))\" (is ?T2)", "lemma pa_pref_frp: \n  assumes TA: \"hashedTa H1\" \"hashedTa H2\"\n  assumes idx[simp]: \"hta_has_idx_s H1\" \"hta_has_idx_sf H2\"\n\n  shows \"wa_precise_refine (det_wa_wa (pa_det_algo H1 H2)) \n                           (frp_algo (hta_\\<alpha> H1) (hta_\\<alpha> H2)) \n                           pa_\\<alpha>\"", "lemma pa_while_algo: \n  assumes TA: \"hashedTa H1\" \"hashedTa H2\"\n  assumes idx[simp]: \"hta_has_idx_s H1\" \"hta_has_idx_sf H2\"\n\n  shows \"while_algo (det_wa_wa (pa_det_algo H1 H2))\"", "lemmas pa_det_while_algo = det_while_algo_intro[OF pa_while_algo]\n\n\\<comment> \\<open>Transferred correctness lemma\\<close>", "lemmas pa_inv_final = \n  wa_precise_refine.transfer_correctness[OF pa_pref_frp frp_inv_final]\n\n\n\\<comment> \\<open>The next two definitions specify the product-automata algorithm. The first\n    version requires the s-index of the first and the sf-index of the second\n    automaton to be present, while the second version computes the required \n    indices, if necessary\\<close>", "lemma hta_prod'_correct_aux:\n  assumes TA: \"hashedTa H1\" \"hashedTa H2\"\n  assumes idx: \"hta_has_idx_s H1\" \"hta_has_idx_sf H2\"\n  shows \"hta_\\<alpha> (hta_prod' H1 H2) \n         = ta_fwd_reduce (ta_prod (hta_\\<alpha> H1) (hta_\\<alpha> H2))\" (is ?T1)\n        \"hashedTa (hta_prod' H1 H2)\" (is ?T2)", "theorem hta_prod'_correct:\n  assumes TA: \"hashedTa H1\" \"hashedTa H2\"\n  assumes HI: \"hta_has_idx_s H1\" \"hta_has_idx_sf H2\"\n  shows \n    \"ta_lang (hta_\\<alpha> (hta_prod' H1 H2)) \n     = ta_lang (hta_\\<alpha> H1) \\<inter> ta_lang (hta_\\<alpha> H2)\"\n\n    \"hashedTa (hta_prod' H1 H2)\"", "lemma hta_prod_correct_aux:\n  assumes TA[simp]: \"hashedTa H1\" \"hashedTa H2\"\n  shows \n    \"hta_\\<alpha> (hta_prod H1 H2) = ta_fwd_reduce (ta_prod (hta_\\<alpha> H1) (hta_\\<alpha> H2))\"\n    \"hashedTa (hta_prod H1 H2)\"", "theorem hta_prod_correct:\n  assumes TA: \"hashedTa H1\" \"hashedTa H2\"\n  shows \n    \"ta_lang (hta_\\<alpha> (hta_prod H1 H2)) \n     = ta_lang (hta_\\<alpha> H1) \\<inter> ta_lang (hta_\\<alpha> H2)\"\n    \"hashedTa (hta_prod H1 H2)\"", "lemma (in hashedTa) hta_remap_correct:\n  shows \"hta_\\<alpha> (hta_remap f H) = ta_remap f (hta_\\<alpha> H)\"\n        \"hashedTa (hta_remap f H)\"", "lemma rule_states_l_correct[simp]: \n  \"ls_\\<alpha> (rule_states_l r) = rule_states r\"\n  \"ls_invar (rule_states_l r)\"", "lemma (in hashedTa) hta_\\<delta>_states_correct:\n  \"hs_\\<alpha> (hta_\\<delta>_states H) = \\<delta>_states (ta_rules (hta_\\<alpha> H))\"\n  \"hs_invar (hta_\\<delta>_states H)\"", "lemma (in hashedTa) hta_states_correct:\n  \"hs_\\<alpha> (hta_states H) = ta_rstates (hta_\\<alpha> H)\"\n  \"hs_invar (hta_states H)\"", "lemma [code]: \"hta_reindex H = (\n  let mp = (hh_map_to_nat.map_to_nat (hta_states H)) in\n    hta_remap (\\<lambda>q. the (hm_lookup q mp)) H)\n  \"", "lemma (in hashedTa) reindex_map_correct:\n  \"inj_on (reindex_map H) (ta_rstates (hta_\\<alpha> H))\"", "theorem (in hashedTa) hta_reindex_correct:\n  \"ta_lang (hta_\\<alpha> (hta_reindex H)) = ta_lang (hta_\\<alpha> H)\"\n  \"hashedTa (hta_reindex H)\"", "lemma hta_union_correct': \n  assumes TA: \"hashedTa H1\" \"hashedTa H2\"\n  shows \"hta_\\<alpha> (hta_union H1 H2) \n         = ta_union_wrap (hta_\\<alpha> H1) (hta_\\<alpha> H2)\" (is ?T1)\n        \"hashedTa (hta_union H1 H2)\" (is ?T2)", "theorem hta_union_correct: \n  assumes TA: \"hashedTa H1\" \"hashedTa H2\"\n  shows \n    \"ta_lang (hta_\\<alpha> (hta_union H1 H2)) \n     = ta_lang (hta_\\<alpha> H1) \\<union> ta_lang (hta_\\<alpha> H2)\" (is ?T1)\n    \"hashedTa (hta_union H1 H2)\" (is ?T2)", "lemma hta_empty_correct [simp, intro!]: \n  shows \"(hta_\\<alpha> (hta_empty ())) = ta_empty\"\n        \"hashedTa (hta_empty ())\"", "lemma (in hashedTa) hta_add_qi_correct[simp, intro!]:\n  shows \"hta_\\<alpha> (hta_add_qi qi H) \n         = \\<lparr> ta_initial = insert qi (ta_initial (hta_\\<alpha> H)), \n             ta_rules = ta_rules (hta_\\<alpha> H) \n           \\<rparr>\"\n        \"hashedTa (hta_add_qi qi H)\"", "lemmas [simp, intro] = hashedTa.hta_add_qi_correct\n\n\\<comment> \\<open>Add a rule to the automaton\\<close>", "lemma (in hashedTa) hta_add_rule_correct[simp, intro!]:\n  shows \"hta_\\<alpha> (hta_add_rule r H) \n         = \\<lparr> ta_initial = ta_initial (hta_\\<alpha> H), \n             ta_rules = insert r (ta_rules (hta_\\<alpha> H)) \n           \\<rparr>\"\n        \"hashedTa (hta_add_rule r H)\"", "lemmas [simp, intro] = hashedTa.hta_add_rule_correct\n\n\n  \\<comment> \\<open>Reduces an automaton to the given set of states\\<close>", "theorem (in hashedTa) hta_reduce_correct:\n  assumes INV[simp]: \"hs_invar Q\"\n  shows\n  \"hta_\\<alpha> (hta_reduce H Q) = ta_reduce (hta_\\<alpha> H) (hs_\\<alpha> Q)\" (is ?T1)\n  \"hashedTa (hta_reduce H Q)\" (is ?T2)", "lemma rqrm_\\<alpha>_lookup_update[simp]: \n  \"rqrm_invar rqrm \\<Longrightarrow> \n    ls_\\<alpha> (rqrm_lookup (rqrm_add q r rqrm) q') \n    = ( if q=q' then \n          insert r (ls_\\<alpha> (rqrm_lookup rqrm q')) \n        else \n          ls_\\<alpha> (rqrm_lookup rqrm q')\n      )\"", "lemma rqrm_propD: \n  \"rqrm_prop \\<delta> rqrm \\<Longrightarrow> ls_\\<alpha> (rqrm_lookup rqrm q) = {r\\<in>\\<delta>. q\\<in>set (rhsq r)}\"", "lemma build_rqrm_correct:\n  fixes \\<delta>\n  assumes [simp]: \"ls_invar \\<delta>\"\n  shows \"rqrm_invar (build_rqrm \\<delta>)\" (is ?T1) and\n        \"rqrm_prop (ls_\\<alpha> \\<delta>) (build_rqrm \\<delta>)\" (is ?T2)", "lemma brc_inv_imp_WssQ: \"brc_\\<alpha> (Q,W,rcm)\\<in>br'_invar \\<delta> \\<Longrightarrow> set W \\<subseteq> hs_\\<alpha> Q\"", "lemma brc_iq_correct: \n  assumes [simp]: \"ls_invar \\<delta>\"\n  shows \"hs_invar (brc_iq \\<delta>)\"\n        \"hs_\\<alpha> (brc_iq \\<delta>) = br_iq (ls_\\<alpha> \\<delta>)\"", "lemma brc_rcm_init_correct:\n  assumes INV[simp]: \"ls_invar \\<delta>\"\n  shows \"r\\<in>ls_\\<alpha> \\<delta> \n    \\<Longrightarrow> hm_\\<alpha> (brc_rcm_init \\<delta>) r = Some ((card (set (rhsq r))))\" \n  (is \"_ \\<Longrightarrow> ?T1 r\") and\n    \"hm_invar (brc_rcm_init \\<delta>)\" (is ?T2)", "lemma brc_inner_step_br'_desc: \n  \"\\<lbrakk> (Q,W,rcm)\\<in>brc_invar \\<delta> \\<rbrakk> \\<Longrightarrow> brc_\\<alpha> (brc_inner_step r (Q,W,rcm)) = (\n    if the (hm_\\<alpha> rcm r) \\<le> 1 then \n      insert (lhs r) (hs_\\<alpha> Q) \n    else hs_\\<alpha> Q, \n    if the (hm_\\<alpha> rcm r) \\<le> 1 \\<and> (lhs r) \\<notin> hs_\\<alpha> Q then \n      insert (lhs r) (set W) \n    else (set W), \n    ((hm_\\<alpha> rcm)(r \\<mapsto> the (hm_\\<alpha> rcm r) - 1))\n  )\"", "lemma brc_step_invar:\n  assumes RQRM: \"rqrm_invar rqrm\"\n  shows \"\\<lbrakk> \\<Sigma>\\<in>brc_invar_add; brc_\\<alpha> \\<Sigma>\\<in>br'_invar \\<delta>; brc_cond \\<Sigma> \\<rbrakk> \n         \\<Longrightarrow> (brc_step rqrm \\<Sigma>)\\<in>brc_invar_add\"", "lemma brc_step_abs:\n  assumes RQRM: \"rqrm_invar rqrm\" \"rqrm_prop \\<delta> rqrm\"\n  assumes A: \"\\<Sigma>\\<in>brc_invar \\<delta>\" \"brc_cond \\<Sigma>\"  \n  shows \"(brc_\\<alpha> \\<Sigma>, brc_\\<alpha> (brc_step rqrm \\<Sigma>)) \\<in> br'_step \\<delta>\"", "lemma brc_initial_invar: \"ls_invar \\<delta> \\<Longrightarrow> (brc_initial \\<delta>)\\<in>brc_invar_add\"", "lemma brc_cond_abs: \"brc_cond \\<Sigma> \\<longleftrightarrow> (brc_\\<alpha> \\<Sigma>)\\<in>br'_cond\"", "lemma brc_initial_abs: \n  \"ls_invar \\<delta> \\<Longrightarrow> brc_\\<alpha> (brc_initial \\<delta>) \\<in> br'_initial (ls_\\<alpha> \\<delta>)\"", "lemma brc_pref_br':\n  assumes RQRM[simp]: \"rqrm_invar rqrm\" \"rqrm_prop (ls_\\<alpha> \\<delta>) rqrm\"\n  assumes INV[simp]: \"ls_invar \\<delta>\"\n  shows \"wa_precise_refine (det_wa_wa (brc_det_algo rqrm \\<delta>)) \n                           (br'_algo (ls_\\<alpha> \\<delta>)) \n                           brc_\\<alpha>\"", "lemma brc_while_algo:\n  assumes RQRM[simp]: \"rqrm_invar rqrm\" \"rqrm_prop (ls_\\<alpha> \\<delta>) rqrm\"\n  assumes INV[simp]: \"ls_invar \\<delta>\"\n  shows \"while_algo (det_wa_wa (brc_det_algo rqrm \\<delta>))\"", "lemmas brc_det_while_algo =\n  det_while_algo_intro[OF brc_while_algo]", "lemma fst_brc_\\<alpha>: \"fst (brc_\\<alpha> s) = hs_\\<alpha> (fst s)\"", "lemmas brc_invar_final =\n  wa_precise_refine.transfer_correctness[OF \n    brc_pref_br' br'_invar_final, unfolded fst_brc_\\<alpha>]", "theorem (in hashedTa) hta_bwd_reduce_correct:\n  shows \"hta_\\<alpha> (hta_bwd_reduce H) \n         = ta_reduce (hta_\\<alpha> H) (b_accessible (ls_\\<alpha> (hta_\\<delta> H)))\" (is ?T1)\n        \"hashedTa (hta_bwd_reduce H)\" (is ?T2)", "lemma brec_construct_witness_correct: \n  \"\\<lbrakk>hm_invar Qm\\<rbrakk> \\<Longrightarrow> \n    brec_construct_witness Qm r = construct_witness (hm_\\<alpha> Qm) r\"", "lemma brec_invar_cons: \n  \"\\<Sigma>\\<in>brec_invar Qi \\<delta> \\<Longrightarrow> \\<Sigma>\\<in>brec_invar_inner Qi\"", "lemma brec_brw_invar_cons: \n  \"brec_\\<alpha> \\<Sigma> \\<in> brw_invar Qi \\<Longrightarrow> set (fifo_\\<alpha> (fst (snd \\<Sigma>))) \\<subseteq> dom (hm_\\<alpha> (fst \\<Sigma>))\"", "lemma brec_iqm_correct':\n  assumes INV[simp]: \"ls_invar \\<delta>\"\n  shows \n    \"dom (hm_\\<alpha> (brec_iqm \\<delta>)) = {lhs r | r. r\\<in>ls_\\<alpha> \\<delta> \\<and> rhsq r = []}\" (is ?T1)\n    \"witness_prop (ls_\\<alpha> \\<delta>) (hm_\\<alpha> (brec_iqm \\<delta>))\" (is ?T2)\n    \"hm_invar (brec_iqm \\<delta>)\" (is ?T3)", "lemma brec_iqm_correct:\n  assumes INV[simp]: \"ls_invar \\<delta>\"\n  shows \"hm_\\<alpha> (brec_iqm \\<delta>) \\<in> brw_iq (ls_\\<alpha> \\<delta>)\"", "lemma brec_inner_step_brw_desc: \n  \"\\<lbrakk> \\<Sigma>\\<in>brec_invar_inner (hs_\\<alpha> Qi) \\<rbrakk> \n    \\<Longrightarrow> (brec_\\<alpha> \\<Sigma>, brec_\\<alpha> (brec_inner_step Qi r \\<Sigma>)) \\<in> brw_inner_step r\"", "lemma brec_step_invar:\n  assumes RQRM: \"rqrm_invar rqrm\" \"rqrm_prop \\<delta> rqrm\"\n  assumes [simp]: \"hs_invar Qi\"\n  shows \"\\<lbrakk> \\<Sigma>\\<in>brec_invar_add (hs_\\<alpha> Qi); brec_\\<alpha> \\<Sigma> \\<in> brw_invar \\<delta>;  brec_cond \\<Sigma> \\<rbrakk> \n          \\<Longrightarrow> (brec_step rqrm Qi \\<Sigma>)\\<in>brec_invar_add (hs_\\<alpha> Qi)\"", "lemma brec_step_abs:\n  assumes RQRM: \"rqrm_invar rqrm\" \"rqrm_prop \\<delta> rqrm\"\n  assumes INV[simp]: \"hs_invar Qi\"\n  assumes A': \"\\<Sigma>\\<in>brec_invar (hs_\\<alpha> Qi) \\<delta>\"\n  assumes COND: \"brec_cond \\<Sigma>\"\n  shows \"(brec_\\<alpha> \\<Sigma>, brec_\\<alpha> (brec_step rqrm Qi \\<Sigma>)) \\<in> brw_step \\<delta>\"", "lemma brec_invar_initial: \n  \"\\<lbrakk>ls_invar \\<delta>; hs_invar Qi\\<rbrakk> \\<Longrightarrow> (brec_initial Qi \\<delta>) \\<in> brec_invar_add (hs_\\<alpha> Qi)\"", "lemma brec_cond_abs: \n  \"\\<lbrakk>\\<Sigma>\\<in>brec_invar Qi \\<delta>\\<rbrakk> \\<Longrightarrow> brec_cond \\<Sigma> \\<longleftrightarrow> (brec_\\<alpha> \\<Sigma>)\\<in>brw_cond Qi\"", "lemma brec_initial_abs: \n  \"\\<lbrakk> ls_invar \\<delta>; hs_invar Qi \\<rbrakk> \n     \\<Longrightarrow> brec_\\<alpha> (brec_initial Qi \\<delta>) \\<in> brw_initial (ls_\\<alpha> \\<delta>)\"", "lemma brec_pref_brw:\n  assumes RQRM[simp]: \"rqrm_invar rqrm\" \"rqrm_prop (ls_\\<alpha> \\<delta>) rqrm\"\n  assumes INV[simp]: \"ls_invar \\<delta>\" \"hs_invar Qi\"\n  shows \"wa_precise_refine (det_wa_wa (brec_det_algo rqrm Qi \\<delta>)) \n                           (brw_algo (hs_\\<alpha> Qi) (ls_\\<alpha> \\<delta>))  \n                           brec_\\<alpha>\"", "lemma brec_while_algo:\n  assumes RQRM[simp]: \"rqrm_invar rqrm\" \"rqrm_prop (ls_\\<alpha> \\<delta>) rqrm\"\n  assumes INV[simp]: \"ls_invar \\<delta>\" \"hs_invar Qi\"\n  shows \"while_algo (det_wa_wa (brec_det_algo rqrm Qi \\<delta>))\"", "lemma fst_brec_\\<alpha>: \"fst (brec_\\<alpha> \\<Sigma>) = hm_\\<alpha> (fst \\<Sigma>)\"", "lemmas brec_invar_final = \n  wa_precise_refine.transfer_correctness[\n    OF brec_pref_brw brw_invar_final, \n    unfolded fst_brec_\\<alpha>]", "lemmas brec_det_algo = det_while_algo_intro[OF brec_while_algo]", "theorem (in hashedTa) hta_is_empty_witness_correct:\n  shows [rule_format]: \"hta_is_empty_witness H = Some t \n                        \\<longrightarrow> t\\<in>ta_lang (hta_\\<alpha> H)\" (is ?T1)\n        \"hta_is_empty_witness H = None \\<longrightarrow> ta_lang (hta_\\<alpha> H) = {}\" (is ?T2)", "lemmas htai_mem_correct = hta_mem_correct[folded htai_mem_def]", "lemma htai_empty_correct[simp]:\n    \"hta_\\<alpha> (htai_empty ()) = ta_empty\"\n    \"hashedTa (htai_empty ())\"", "lemmas htai_add_qi_correct = hta_add_qi_correct[folded htai_add_qi_def]", "lemmas htai_add_rule_correct = hta_add_rule_correct[folded htai_add_rule_def]", "lemmas htai_bwd_reduce_correct = \n    hta_bwd_reduce_correct[folded htai_bwd_reduce_def]", "lemmas htai_is_empty_witness_correct = \n    hta_is_empty_witness_correct[folded htai_is_empty_witness_def]", "lemmas htai_ensure_idx_f_correct = \n    hta_ensure_idx_f_correct[folded htai_ensure_idx_f_def]", "lemmas htai_ensure_idx_s_correct = \n    hta_ensure_idx_s_correct[folded htai_ensure_idx_s_def]", "lemmas htai_ensure_idx_sf_correct = \n    hta_ensure_idx_sf_correct[folded htai_ensure_idx_sf_def]", "lemma htai_prod_correct:\n  assumes [simp]: \"hashedTa H1\" \"hashedTa H2\"\n  shows \n  \"ta_lang (hta_\\<alpha> (htai_prod H1 H2)) = ta_lang (hta_\\<alpha> H1) \\<inter> ta_lang (hta_\\<alpha> H2)\"\n  \"hashedTa (htai_prod H1 H2)\"", "lemma htai_prodWR_correct:\n  assumes [simp]: \"hashedTa H1\" \"hashedTa H2\"\n  shows \n  \"ta_lang (hta_\\<alpha> (htai_prodWR H1 H2)) \n   = ta_lang (hta_\\<alpha> H1) \\<inter> ta_lang (hta_\\<alpha> H2)\"\n  \"hashedTa (htai_prodWR H1 H2)\"", "lemma htai_union_correct:\n  assumes [simp]: \"hashedTa H1\" \"hashedTa H2\"\n  shows \n  \"ta_lang (hta_\\<alpha> (htai_union H1 H2)) \n   = ta_lang (hta_\\<alpha> H1) \\<union> ta_lang (hta_\\<alpha> H2)\"\n  \"hashedTa (htai_union H1 H2)\""], "translations": [["", "lemma build_rule_index_f_correct[simp]: \n  assumes I[simp, intro!]: \"ls_invar \\<delta>\"\n  shows \"hll_idx.is_index rhsl (ls_\\<alpha> \\<delta>) (build_rule_index_f \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hll_idx.is_index rhsl (ls.\\<alpha> \\<delta>)\n     (build_rule_index_f \\<delta>)", "apply (unfold build_rule_index_f_def build_rule_index_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hll_idx.is_index rhsl (ls.\\<alpha> \\<delta>)\n     (hll_idx.idx_build rhsl \\<delta>)", "apply (simp add: hll_idx.idx_build_is_index)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma build_rule_index_s_correct[simp]: \n  assumes I[simp, intro!]: \"ls_invar \\<delta>\"\n  shows\n  \"hll_idx.is_index lhs (ls_\\<alpha> \\<delta>) (build_rule_index_s \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hll_idx.is_index lhs (ls.\\<alpha> \\<delta>)\n     (build_rule_index_s \\<delta>)", "by (unfold build_rule_index_s_def build_rule_index_def)\n     (simp add: hll_idx.idx_build_is_index)"], ["", "lemma build_rule_index_sf_correct[simp]: \n  assumes I[simp, intro!]: \"ls_invar \\<delta>\"\n  shows\n  \"hll_idx.is_index (\\<lambda>r. (lhs r, rhsl r)) (ls_\\<alpha> \\<delta>) (build_rule_index_sf \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hll_idx.is_index (\\<lambda>r. (lhs r, rhsl r)) (ls.\\<alpha> \\<delta>)\n     (build_rule_index_sf \\<delta>)", "by (unfold build_rule_index_sf_def build_rule_index_def)\n     (simp add: hll_idx.idx_build_is_index)"], ["", "subsection \"Tree Automaton with Optional Indices\""], ["", "text \\<open>\n  A tree automaton contains a hashset of initial states, a list-set of rules and\n  several (optional) rule indices.\n\\<close>"], ["", "record (overloaded) ('q,'l) hashedTa =\n    \\<comment> \\<open>Initial states\\<close>\n  hta_Qi :: \"'q hs\"           \n    \\<comment> \\<open>Rules\\<close>\n  hta_\\<delta> :: \"('q,'l) ta_rule ls\"    \n    \\<comment> \\<open>Rules by function symbol\\<close>\n  hta_idx_f :: \"('l,('q,'l) ta_rule ls) hm option\" \n    \\<comment> \\<open>Rules by lhs state\\<close>\n  hta_idx_s :: \"('q,('q,'l) ta_rule ls) hm option\" \n    \\<comment> \\<open>Rules by lhs state and function symbol\\<close>\n  hta_idx_sf :: \"('q\\<times>'l,('q,'l) ta_rule ls) hm option\" \n\n  \\<comment> \\<open>Abstraction of a concrete tree automaton to an abstract one\\<close>"], ["", "definition hta_\\<alpha> \n  where \"hta_\\<alpha> H = \\<lparr> ta_initial = hs_\\<alpha> (hta_Qi H), ta_rules = ls_\\<alpha> (hta_\\<delta> H) \\<rparr>\"\n\n  \\<comment> \\<open>Builds the f-index if not present\\<close>"], ["", "definition \"hta_ensure_idx_f H ==\n  case hta_idx_f H of \n    None \\<Rightarrow> H\\<lparr> hta_idx_f := Some (build_rule_index_f (hta_\\<delta> H)) \\<rparr> |\n    Some _ \\<Rightarrow> H\n  \"\n\n  \\<comment> \\<open>Builds the s-index if not present\\<close>"], ["", "definition \"hta_ensure_idx_s H ==\n  case hta_idx_s H of \n    None \\<Rightarrow> H\\<lparr> hta_idx_s := Some (build_rule_index_s (hta_\\<delta> H)) \\<rparr> |\n    Some _ \\<Rightarrow> H\n  \"\n\n  \\<comment> \\<open>Builds the sf-index if not present\\<close>"], ["", "definition \"hta_ensure_idx_sf H ==\n  case hta_idx_sf H of \n    None \\<Rightarrow> H\\<lparr> hta_idx_sf := Some (build_rule_index_sf (hta_\\<delta> H)) \\<rparr> |\n    Some _ \\<Rightarrow> H\n  \""], ["", "lemma hta_ensure_idx_f_correct_\\<alpha>[simp]: \n  \"hta_\\<alpha> (hta_ensure_idx_f H) = hta_\\<alpha> H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hta_\\<alpha> (hta_ensure_idx_f H) = hta_\\<alpha> H", "by (simp add: hta_ensure_idx_f_def hta_\\<alpha>_def split: option.split)"], ["", "lemma hta_ensure_idx_s_correct_\\<alpha>[simp]: \n  \"hta_\\<alpha> (hta_ensure_idx_s H) = hta_\\<alpha> H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hta_\\<alpha> (hta_ensure_idx_s H) = hta_\\<alpha> H", "by (simp add: hta_ensure_idx_s_def hta_\\<alpha>_def split: option.split)"], ["", "lemma hta_ensure_idx_sf_correct_\\<alpha>[simp]: \n  \"hta_\\<alpha> (hta_ensure_idx_sf H) = hta_\\<alpha> H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hta_\\<alpha> (hta_ensure_idx_sf H) = hta_\\<alpha> H", "by (simp add: hta_ensure_idx_sf_def hta_\\<alpha>_def split: option.split)"], ["", "lemma hta_ensure_idx_other[simp]:\n  \"hta_Qi (hta_ensure_idx_f H) = hta_Qi H\"  \n  \"hta_\\<delta> (hta_ensure_idx_f H) = hta_\\<delta> H\"\n  \n  \"hta_Qi (hta_ensure_idx_s H) = hta_Qi H\"  \n  \"hta_\\<delta> (hta_ensure_idx_s H) = hta_\\<delta> H\"\n  \n  \"hta_Qi (hta_ensure_idx_sf H) = hta_Qi H\" \n  \"hta_\\<delta> (hta_ensure_idx_sf H) = hta_\\<delta> H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hta_Qi (hta_ensure_idx_f H) = hta_Qi H &&&\n     hta_\\<delta> (hta_ensure_idx_f H) = hta_\\<delta> H &&&\n     hta_Qi (hta_ensure_idx_s H) = hta_Qi H) &&&\n    hta_\\<delta> (hta_ensure_idx_s H) = hta_\\<delta> H &&&\n    hta_Qi (hta_ensure_idx_sf H) = hta_Qi H &&&\n    hta_\\<delta> (hta_ensure_idx_sf H) = hta_\\<delta> H", "by (auto \n    simp add: hta_ensure_idx_f_def hta_ensure_idx_s_def hta_ensure_idx_sf_def \n    split: option.split)\n\n  \\<comment> \\<open>Check whether the f-index is present\\<close>"], ["", "definition \"hta_has_idx_f H == hta_idx_f H \\<noteq> None\"\n  \\<comment> \\<open>Check whether the s-index is present\\<close>"], ["", "definition \"hta_has_idx_s H == hta_idx_s H \\<noteq> None\"\n  \\<comment> \\<open>Check whether the sf-index is present\\<close>"], ["", "definition \"hta_has_idx_sf H == hta_idx_sf H \\<noteq> None\""], ["", "lemma hta_idx_f_pres\n  [simp, intro!]: \"hta_has_idx_f (hta_ensure_idx_f H)\" and\n  [simp, intro]: \"hta_has_idx_s H \\<Longrightarrow> hta_has_idx_s (hta_ensure_idx_f H)\" and\n  [simp, intro]: \"hta_has_idx_sf H \\<Longrightarrow> hta_has_idx_sf (hta_ensure_idx_f H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hta_has_idx_f (hta_ensure_idx_f H) &&&\n    (hta_has_idx_s H \\<Longrightarrow>\n     hta_has_idx_s (hta_ensure_idx_f H)) &&&\n    (hta_has_idx_sf H \\<Longrightarrow> hta_has_idx_sf (hta_ensure_idx_f H))", "by (simp_all \n    add: hta_has_idx_f_def hta_has_idx_s_def hta_has_idx_sf_def \n         hta_ensure_idx_f_def \n    split: option.split)"], ["", "lemma hta_idx_s_pres\n  [simp, intro!]: \"hta_has_idx_s (hta_ensure_idx_s H)\" and\n  [simp, intro]: \"hta_has_idx_f H \\<Longrightarrow> hta_has_idx_f (hta_ensure_idx_s H)\" and\n  [simp, intro]: \"hta_has_idx_sf H \\<Longrightarrow> hta_has_idx_sf (hta_ensure_idx_s H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hta_has_idx_s (hta_ensure_idx_s H) &&&\n    (hta_has_idx_f H \\<Longrightarrow>\n     hta_has_idx_f (hta_ensure_idx_s H)) &&&\n    (hta_has_idx_sf H \\<Longrightarrow> hta_has_idx_sf (hta_ensure_idx_s H))", "by (simp_all \n    add: hta_has_idx_f_def hta_has_idx_s_def hta_has_idx_sf_def \n         hta_ensure_idx_s_def \n    split: option.split)"], ["", "lemma hta_idx_sf_pres\n  [simp, intro!]: \"hta_has_idx_sf (hta_ensure_idx_sf H)\" and\n  [simp, intro]: \"hta_has_idx_f H \\<Longrightarrow> hta_has_idx_f (hta_ensure_idx_sf H)\" and\n  [simp, intro]: \"hta_has_idx_s H \\<Longrightarrow> hta_has_idx_s (hta_ensure_idx_sf H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hta_has_idx_sf (hta_ensure_idx_sf H) &&&\n    (hta_has_idx_f H \\<Longrightarrow>\n     hta_has_idx_f (hta_ensure_idx_sf H)) &&&\n    (hta_has_idx_s H \\<Longrightarrow> hta_has_idx_s (hta_ensure_idx_sf H))", "by (simp_all \n    add: hta_has_idx_f_def hta_has_idx_s_def hta_has_idx_sf_def \n         hta_ensure_idx_sf_def \n    split: option.split)"], ["", "text \\<open>\n  The lookup functions are only defined if the required index is present. \n  This enforces generation of the index before applying lookup functions.\n\\<close>\n  \\<comment> \\<open>Lookup rules by function symbol\\<close>"], ["", "definition \"hta_lookup_f f H == hll_idx.lookup f (the (hta_idx_f H))\"\n  \\<comment> \\<open>Lookup rules by lhs-state\\<close>"], ["", "definition \"hta_lookup_s q H == hll_idx.lookup q (the (hta_idx_s H))\"\n  \\<comment> \\<open>Lookup rules by function symbol and lhs-state\\<close>"], ["", "definition \"hta_lookup_sf q f H == hll_idx.lookup (q,f) (the (hta_idx_sf H))\"\n\n\n  \\<comment> \\<open>This locale defines the invariants of a tree automaton\\<close>"], ["", "locale hashedTa =\n  fixes H :: \"('Q::hashable,'L::hashable) hashedTa\"\n\n  \\<comment> \\<open>The involved sets satisfy their invariants\\<close>\n  assumes invar[simp, intro!]: \n    \"hs_invar (hta_Qi H)\"\n    \"ls_invar (hta_\\<delta> H)\"\n\n  \\<comment> \\<open>The indices are correct, if present\\<close>\n  assumes index_correct:\n    \"hta_idx_f H = Some idx_f \n      \\<Longrightarrow> hll_idx.is_index rhsl (ls_\\<alpha> (hta_\\<delta> H)) idx_f\"\n    \"hta_idx_s H = Some idx_s \n      \\<Longrightarrow> hll_idx.is_index lhs (ls_\\<alpha> (hta_\\<delta> H)) idx_s\"\n    \"hta_idx_sf H = Some idx_sf \n      \\<Longrightarrow> hll_idx.is_index (\\<lambda>r. (lhs r, rhsl r)) (ls_\\<alpha> (hta_\\<delta> H)) idx_sf\"\n\nbegin\n  \\<comment> \\<open>Inside this locale, some shorthand notations for the sets of \n      rules and initial states are used\\<close>"], ["", "abbreviation \"\\<delta> == hta_\\<delta> H\""], ["", "abbreviation \"Qi == hta_Qi H\"\n\n  \\<comment> \\<open>The lookup-xxx operations are correct\\<close>"], ["", "lemma hta_lookup_f_correct: \n    \"hta_has_idx_f H \\<Longrightarrow> ls_\\<alpha> (hta_lookup_f f H) = {r\\<in>ls_\\<alpha> \\<delta> . rhsl r = f}\"\n    \"hta_has_idx_f H \\<Longrightarrow> ls_invar (hta_lookup_f f H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hta_has_idx_f H \\<Longrightarrow>\n     ls.\\<alpha> (hta_lookup_f f H) =\n     {r \\<in> ls.\\<alpha> \\<delta>. rhsl r = f}) &&&\n    (hta_has_idx_f H \\<Longrightarrow> ls.invar (hta_lookup_f f H))", "apply (cases \"hta_has_idx_f H\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>hta_has_idx_f H; hta_has_idx_f H\\<rbrakk>\n    \\<Longrightarrow> ls.\\<alpha> (hta_lookup_f f H) =\n                      {r \\<in> ls.\\<alpha> \\<delta>. rhsl r = f}\n 2. \\<lbrakk>hta_has_idx_f H; \\<not> hta_has_idx_f H\\<rbrakk>\n    \\<Longrightarrow> ls.\\<alpha> (hta_lookup_f f H) =\n                      {r \\<in> ls.\\<alpha> \\<delta>. rhsl r = f}\n 3. hta_has_idx_f H \\<Longrightarrow> ls.invar (hta_lookup_f f H)", "apply (unfold hta_has_idx_f_def hta_lookup_f_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>hta_idx_f H \\<noteq> None; hta_idx_f H \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> ls.\\<alpha> (hll_idx.lookup f (the (hta_idx_f H))) =\n                      {r \\<in> ls.\\<alpha> \\<delta>. rhsl r = f}\n 2. \\<lbrakk>hta_idx_f H \\<noteq> None;\n     \\<not> hta_idx_f H \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> ls.\\<alpha> (hll_idx.lookup f (the (hta_idx_f H))) =\n                      {r \\<in> ls.\\<alpha> \\<delta>. rhsl r = f}\n 3. hta_idx_f H \\<noteq> None \\<Longrightarrow>\n    ls.invar (hll_idx.lookup f (the (hta_idx_f H)))", "apply (auto \n      simp add: hll_idx.lookup_correct[OF index_correct(1)] \n                index_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hta_lookup_s_correct: \n    \"hta_has_idx_s H \\<Longrightarrow> ls_\\<alpha> (hta_lookup_s q H) = {r\\<in>ls_\\<alpha> \\<delta> . lhs r = q}\"\n    \"hta_has_idx_s H \\<Longrightarrow> ls_invar (hta_lookup_s q H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hta_has_idx_s H \\<Longrightarrow>\n     ls.\\<alpha> (hta_lookup_s q H) =\n     {r \\<in> ls.\\<alpha> \\<delta>. lhs r = q}) &&&\n    (hta_has_idx_s H \\<Longrightarrow> ls.invar (hta_lookup_s q H))", "apply (cases \"hta_has_idx_s H\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>hta_has_idx_s H; hta_has_idx_s H\\<rbrakk>\n    \\<Longrightarrow> ls.\\<alpha> (hta_lookup_s q H) =\n                      {r \\<in> ls.\\<alpha> \\<delta>. lhs r = q}\n 2. \\<lbrakk>hta_has_idx_s H; \\<not> hta_has_idx_s H\\<rbrakk>\n    \\<Longrightarrow> ls.\\<alpha> (hta_lookup_s q H) =\n                      {r \\<in> ls.\\<alpha> \\<delta>. lhs r = q}\n 3. hta_has_idx_s H \\<Longrightarrow> ls.invar (hta_lookup_s q H)", "apply (unfold hta_has_idx_s_def hta_lookup_s_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>hta_idx_s H \\<noteq> None; hta_idx_s H \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> ls.\\<alpha> (hll_idx.lookup q (the (hta_idx_s H))) =\n                      {r \\<in> ls.\\<alpha> \\<delta>. lhs r = q}\n 2. \\<lbrakk>hta_idx_s H \\<noteq> None;\n     \\<not> hta_idx_s H \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> ls.\\<alpha> (hll_idx.lookup q (the (hta_idx_s H))) =\n                      {r \\<in> ls.\\<alpha> \\<delta>. lhs r = q}\n 3. hta_idx_s H \\<noteq> None \\<Longrightarrow>\n    ls.invar (hll_idx.lookup q (the (hta_idx_s H)))", "apply (auto \n      simp add: hll_idx.lookup_correct[OF index_correct(2)] \n                index_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hta_lookup_sf_correct: \n    \"hta_has_idx_sf H \n      \\<Longrightarrow> ls_\\<alpha> (hta_lookup_sf q f H) = {r\\<in>ls_\\<alpha> \\<delta> . lhs r = q \\<and> rhsl r = f}\"\n    \"hta_has_idx_sf H \\<Longrightarrow> ls_invar (hta_lookup_sf q f H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hta_has_idx_sf H \\<Longrightarrow>\n     ls.\\<alpha> (hta_lookup_sf q f H) =\n     {r \\<in> ls.\\<alpha> \\<delta>. lhs r = q \\<and> rhsl r = f}) &&&\n    (hta_has_idx_sf H \\<Longrightarrow> ls.invar (hta_lookup_sf q f H))", "apply (cases \"hta_has_idx_sf H\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>hta_has_idx_sf H; hta_has_idx_sf H\\<rbrakk>\n    \\<Longrightarrow> ls.\\<alpha> (hta_lookup_sf q f H) =\n                      {r \\<in> ls.\\<alpha> \\<delta>.\n                       lhs r = q \\<and> rhsl r = f}\n 2. \\<lbrakk>hta_has_idx_sf H; \\<not> hta_has_idx_sf H\\<rbrakk>\n    \\<Longrightarrow> ls.\\<alpha> (hta_lookup_sf q f H) =\n                      {r \\<in> ls.\\<alpha> \\<delta>.\n                       lhs r = q \\<and> rhsl r = f}\n 3. hta_has_idx_sf H \\<Longrightarrow> ls.invar (hta_lookup_sf q f H)", "apply (unfold hta_has_idx_sf_def hta_lookup_sf_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>hta_idx_sf H \\<noteq> None; hta_idx_sf H \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> ls.\\<alpha>\n                       (hll_idx.lookup (q, f) (the (hta_idx_sf H))) =\n                      {r \\<in> ls.\\<alpha> \\<delta>.\n                       lhs r = q \\<and> rhsl r = f}\n 2. \\<lbrakk>hta_idx_sf H \\<noteq> None;\n     \\<not> hta_idx_sf H \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> ls.\\<alpha>\n                       (hll_idx.lookup (q, f) (the (hta_idx_sf H))) =\n                      {r \\<in> ls.\\<alpha> \\<delta>.\n                       lhs r = q \\<and> rhsl r = f}\n 3. hta_idx_sf H \\<noteq> None \\<Longrightarrow>\n    ls.invar (hll_idx.lookup (q, f) (the (hta_idx_sf H)))", "apply (auto \n      simp add: hll_idx.lookup_correct[OF index_correct(3)] \n                index_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n\n  \\<comment> \\<open>The ensure-index operations preserve the invariants\\<close>"], ["", "lemma hta_ensure_idx_f_correct[simp, intro!]: \"hashedTa (hta_ensure_idx_f H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hashedTa (hta_ensure_idx_f H)", "apply (unfold_locales)"], ["proof (prove)\ngoal (5 subgoals):\n 1. hs.invar (hta_Qi (hta_ensure_idx_f H))\n 2. ls.invar (hta_\\<delta> (hta_ensure_idx_f H))\n 3. \\<And>idx_f.\n       hta_idx_f (hta_ensure_idx_f H) = Some idx_f \\<Longrightarrow>\n       hll_idx.is_index rhsl\n        (ls.\\<alpha> (hta_\\<delta> (hta_ensure_idx_f H))) idx_f\n 4. \\<And>idx_s.\n       hta_idx_s (hta_ensure_idx_f H) = Some idx_s \\<Longrightarrow>\n       hll_idx.is_index lhs\n        (ls.\\<alpha> (hta_\\<delta> (hta_ensure_idx_f H))) idx_s\n 5. \\<And>idx_sf.\n       hta_idx_sf (hta_ensure_idx_f H) = Some idx_sf \\<Longrightarrow>\n       hll_idx.is_index (\\<lambda>r. (lhs r, rhsl r))\n        (ls.\\<alpha> (hta_\\<delta> (hta_ensure_idx_f H))) idx_sf", "apply (auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>idx_f.\n       hta_idx_f (hta_ensure_idx_f H) = Some idx_f \\<Longrightarrow>\n       hll_idx.is_index rhsl (ls.\\<alpha> \\<delta>) idx_f\n 2. \\<And>idx_s.\n       hta_idx_s (hta_ensure_idx_f H) = Some idx_s \\<Longrightarrow>\n       hll_idx.is_index lhs (ls.\\<alpha> \\<delta>) idx_s\n 3. \\<And>idx_sf.\n       hta_idx_sf (hta_ensure_idx_f H) = Some idx_sf \\<Longrightarrow>\n       hll_idx.is_index (\\<lambda>r. (lhs r, rhsl r)) (ls.\\<alpha> \\<delta>)\n        idx_sf", "apply (auto \n      simp add: hta_ensure_idx_f_def hta_ensure_idx_s_def hta_ensure_idx_sf_def \n               index_correct \n      split: option.split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hta_ensure_idx_s_correct[simp, intro!]: \"hashedTa (hta_ensure_idx_s H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hashedTa (hta_ensure_idx_s H)", "apply (unfold_locales)"], ["proof (prove)\ngoal (5 subgoals):\n 1. hs.invar (hta_Qi (hta_ensure_idx_s H))\n 2. ls.invar (hta_\\<delta> (hta_ensure_idx_s H))\n 3. \\<And>idx_f.\n       hta_idx_f (hta_ensure_idx_s H) = Some idx_f \\<Longrightarrow>\n       hll_idx.is_index rhsl\n        (ls.\\<alpha> (hta_\\<delta> (hta_ensure_idx_s H))) idx_f\n 4. \\<And>idx_s.\n       hta_idx_s (hta_ensure_idx_s H) = Some idx_s \\<Longrightarrow>\n       hll_idx.is_index lhs\n        (ls.\\<alpha> (hta_\\<delta> (hta_ensure_idx_s H))) idx_s\n 5. \\<And>idx_sf.\n       hta_idx_sf (hta_ensure_idx_s H) = Some idx_sf \\<Longrightarrow>\n       hll_idx.is_index (\\<lambda>r. (lhs r, rhsl r))\n        (ls.\\<alpha> (hta_\\<delta> (hta_ensure_idx_s H))) idx_sf", "apply (auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>idx_f.\n       hta_idx_f (hta_ensure_idx_s H) = Some idx_f \\<Longrightarrow>\n       hll_idx.is_index rhsl (ls.\\<alpha> \\<delta>) idx_f\n 2. \\<And>idx_s.\n       hta_idx_s (hta_ensure_idx_s H) = Some idx_s \\<Longrightarrow>\n       hll_idx.is_index lhs (ls.\\<alpha> \\<delta>) idx_s\n 3. \\<And>idx_sf.\n       hta_idx_sf (hta_ensure_idx_s H) = Some idx_sf \\<Longrightarrow>\n       hll_idx.is_index (\\<lambda>r. (lhs r, rhsl r)) (ls.\\<alpha> \\<delta>)\n        idx_sf", "apply (auto \n      simp add: hta_ensure_idx_f_def hta_ensure_idx_s_def hta_ensure_idx_sf_def \n                index_correct \n      split: option.split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hta_ensure_idx_sf_correct[simp, intro!]: \"hashedTa (hta_ensure_idx_sf H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hashedTa (hta_ensure_idx_sf H)", "apply (unfold_locales)"], ["proof (prove)\ngoal (5 subgoals):\n 1. hs.invar (hta_Qi (hta_ensure_idx_sf H))\n 2. ls.invar (hta_\\<delta> (hta_ensure_idx_sf H))\n 3. \\<And>idx_f.\n       hta_idx_f (hta_ensure_idx_sf H) = Some idx_f \\<Longrightarrow>\n       hll_idx.is_index rhsl\n        (ls.\\<alpha> (hta_\\<delta> (hta_ensure_idx_sf H))) idx_f\n 4. \\<And>idx_s.\n       hta_idx_s (hta_ensure_idx_sf H) = Some idx_s \\<Longrightarrow>\n       hll_idx.is_index lhs\n        (ls.\\<alpha> (hta_\\<delta> (hta_ensure_idx_sf H))) idx_s\n 5. \\<And>idx_sf.\n       hta_idx_sf (hta_ensure_idx_sf H) = Some idx_sf \\<Longrightarrow>\n       hll_idx.is_index (\\<lambda>r. (lhs r, rhsl r))\n        (ls.\\<alpha> (hta_\\<delta> (hta_ensure_idx_sf H))) idx_sf", "apply (auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>idx_f.\n       hta_idx_f (hta_ensure_idx_sf H) = Some idx_f \\<Longrightarrow>\n       hll_idx.is_index rhsl (ls.\\<alpha> \\<delta>) idx_f\n 2. \\<And>idx_s.\n       hta_idx_s (hta_ensure_idx_sf H) = Some idx_s \\<Longrightarrow>\n       hll_idx.is_index lhs (ls.\\<alpha> \\<delta>) idx_s\n 3. \\<And>idx_sf.\n       hta_idx_sf (hta_ensure_idx_sf H) = Some idx_sf \\<Longrightarrow>\n       hll_idx.is_index (\\<lambda>r. (lhs r, rhsl r)) (ls.\\<alpha> \\<delta>)\n        idx_sf", "apply (auto \n      simp add: hta_ensure_idx_f_def hta_ensure_idx_s_def hta_ensure_idx_sf_def \n                index_correct \n      split: option.split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>The abstract tree automaton satisfies the invariants for an abstract\n          tree automaton\\<close>"], ["", "lemma hta_\\<alpha>_is_ta[simp, intro!]: \"tree_automaton (hta_\\<alpha> H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_automaton (hta_\\<alpha> H)", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite (ta_rules (hta_\\<alpha> H))\n 2. finite (ta_initial (hta_\\<alpha> H))", "apply (unfold hta_\\<alpha>_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite\n     (ta_rules\n       \\<lparr>ta_initial = hs.\\<alpha> Qi,\n          ta_rules = ls.\\<alpha> \\<delta>\\<rparr>)\n 2. finite\n     (ta_initial\n       \\<lparr>ta_initial = hs.\\<alpha> Qi,\n          ta_rules = ls.\\<alpha> \\<delta>\\<rparr>)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end\n\n\\<comment> \\<open>Add some lemmas to simpset -- also outside the locale\\<close>"], ["", "lemmas [simp, intro] = \n  hashedTa.hta_ensure_idx_f_correct\n  hashedTa.hta_ensure_idx_s_correct\n  hashedTa.hta_ensure_idx_sf_correct\n\n  \\<comment> \\<open>Build a tree automaton from a set of initial states and a set of rules\\<close>"], ["", "definition \"init_hta Qi \\<delta> == \n  \\<lparr> hta_Qi= Qi, \n    hta_\\<delta> = \\<delta>, \n    hta_idx_f = None, \n    hta_idx_s = None, \n    hta_idx_sf = None \n  \\<rparr>\"\n\n  \\<comment> \\<open>Building a tree automaton from a valid tree automaton yields again a \n      valid tree automaton. This operation has the only effect of removing \n      the indices.\\<close>"], ["", "lemma (in hashedTa) init_hta_is_hta: \n  \"hashedTa (init_hta (hta_Qi H) (hta_\\<delta> H))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hashedTa (init_hta Qi \\<delta>)", "apply (unfold_locales)"], ["proof (prove)\ngoal (5 subgoals):\n 1. hs.invar (hta_Qi (init_hta Qi \\<delta>))\n 2. ls.invar (hta_\\<delta> (init_hta Qi \\<delta>))\n 3. \\<And>idx_f.\n       hta_idx_f (init_hta Qi \\<delta>) = Some idx_f \\<Longrightarrow>\n       hll_idx.is_index rhsl\n        (ls.\\<alpha> (hta_\\<delta> (init_hta Qi \\<delta>))) idx_f\n 4. \\<And>idx_s.\n       hta_idx_s (init_hta Qi \\<delta>) = Some idx_s \\<Longrightarrow>\n       hll_idx.is_index lhs\n        (ls.\\<alpha> (hta_\\<delta> (init_hta Qi \\<delta>))) idx_s\n 5. \\<And>idx_sf.\n       hta_idx_sf (init_hta Qi \\<delta>) = Some idx_sf \\<Longrightarrow>\n       hll_idx.is_index (\\<lambda>r. (lhs r, rhsl r))\n        (ls.\\<alpha> (hta_\\<delta> (init_hta Qi \\<delta>))) idx_sf", "apply (unfold init_hta_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. hs.invar\n     (hta_Qi\n       \\<lparr>hta_Qi = Qi, hta_\\<delta> = \\<delta>, hta_idx_f = None,\n          hta_idx_s = None, hta_idx_sf = None\\<rparr>)\n 2. ls.invar\n     (hta_\\<delta>\n       \\<lparr>hta_Qi = Qi, hta_\\<delta> = \\<delta>, hta_idx_f = None,\n          hta_idx_s = None, hta_idx_sf = None\\<rparr>)\n 3. \\<And>idx_f.\n       hta_idx_f\n        \\<lparr>hta_Qi = Qi, hta_\\<delta> = \\<delta>, hta_idx_f = None,\n           hta_idx_s = None, hta_idx_sf = None\\<rparr> =\n       Some idx_f \\<Longrightarrow>\n       hll_idx.is_index rhsl\n        (ls.\\<alpha>\n          (hta_\\<delta>\n            \\<lparr>hta_Qi = Qi, hta_\\<delta> = \\<delta>, hta_idx_f = None,\n               hta_idx_s = None, hta_idx_sf = None\\<rparr>))\n        idx_f\n 4. \\<And>idx_s.\n       hta_idx_s\n        \\<lparr>hta_Qi = Qi, hta_\\<delta> = \\<delta>, hta_idx_f = None,\n           hta_idx_s = None, hta_idx_sf = None\\<rparr> =\n       Some idx_s \\<Longrightarrow>\n       hll_idx.is_index lhs\n        (ls.\\<alpha>\n          (hta_\\<delta>\n            \\<lparr>hta_Qi = Qi, hta_\\<delta> = \\<delta>, hta_idx_f = None,\n               hta_idx_s = None, hta_idx_sf = None\\<rparr>))\n        idx_s\n 5. \\<And>idx_sf.\n       hta_idx_sf\n        \\<lparr>hta_Qi = Qi, hta_\\<delta> = \\<delta>, hta_idx_f = None,\n           hta_idx_s = None, hta_idx_sf = None\\<rparr> =\n       Some idx_sf \\<Longrightarrow>\n       hll_idx.is_index (\\<lambda>r. (lhs r, rhsl r))\n        (ls.\\<alpha>\n          (hta_\\<delta>\n            \\<lparr>hta_Qi = Qi, hta_\\<delta> = \\<delta>, hta_idx_f = None,\n               hta_idx_s = None, hta_idx_sf = None\\<rparr>))\n        idx_sf", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \"Algorithm for the Word Problem\""], ["", "lemma r_match_by_laz: \"r_match L l = list_all_zip (\\<lambda>Q q. q\\<in>Q) L l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r_match L l = list_all_zip (\\<lambda>Q q. q \\<in> Q) L l", "by (unfold r_match_alt list_all_zip_alt)\n      auto"], ["", "text \"Executable function that computes the set of accepting states for \n    a given tree\""], ["", "fun faccs' where\n  \"faccs' H (NODE f ts) = (\n    let Qs = List.map (faccs' H) ts in\n      ll_set_xy.g_image_filter (\\<lambda>r. case r of (q \\<rightarrow> f' qs) \\<Rightarrow> \n           if list_all_zip (\\<lambda>Q q. ls_memb q Q) Qs qs then Some (lhs r) else None\n                          ) \n                      (hta_lookup_f f H)\n  )\"\n\n  \\<comment> \\<open>Executable algorithm to decide the word-problem. The first version \n      depends on the f-index to be present, the second version computes the \n      index if not present.\\<close>"], ["", "definition \"hta_mem' t H == \\<not>lh_set_xx.g_disjoint (faccs' H t) (hta_Qi H)\""], ["", "definition \"hta_mem t H == hta_mem' t (hta_ensure_idx_f H)\""], ["", "context hashedTa\nbegin"], ["", "lemma faccs'_invar:\n    assumes HI[simp, intro!]: \"hta_has_idx_f H\"\n    shows \"ls_invar (faccs' H t)\" (is ?T1) \n          \"list_all ls_invar (List.map (faccs' H) ts)\" (is ?T2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ls.invar (faccs' H t) &&& list_all ls.invar (map (faccs' H) ts)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. ls.invar (faccs' H t)\n 2. list_all ls.invar (map (faccs' H) ts)", "have \"?T1 \\<and> ?T2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ls.invar (faccs' H t) \\<and> list_all ls.invar (map (faccs' H) ts)", "apply (induct rule: compat_tree_tree_list.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       list_all ls.invar (map (faccs' H) x2) \\<Longrightarrow>\n       ls.invar (faccs' H (NODE x1 x2))\n 2. list_all ls.invar (map (faccs' H) [])\n 3. \\<And>x1 x2.\n       \\<lbrakk>ls.invar (faccs' H x1);\n        list_all ls.invar (map (faccs' H) x2)\\<rbrakk>\n       \\<Longrightarrow> list_all ls.invar (map (faccs' H) (x1 # x2))", "apply (auto simp add: ll_set_xy.image_filter_correct hta_lookup_f_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ls.invar (faccs' H t) \\<and> list_all ls.invar (map (faccs' H) ts)\n\ngoal (2 subgoals):\n 1. ls.invar (faccs' H t)\n 2. list_all ls.invar (map (faccs' H) ts)", "thus ?T1 ?T2"], ["proof (prove)\nusing this:\n  ls.invar (faccs' H t) \\<and> list_all ls.invar (map (faccs' H) ts)\n\ngoal (1 subgoal):\n 1. ls.invar (faccs' H t) &&& list_all ls.invar (map (faccs' H) ts)", "by auto"], ["proof (state)\nthis:\n  ls.invar (faccs' H t)\n  list_all ls.invar (map (faccs' H) ts)\n\ngoal:\nNo subgoals!", "qed"], ["", "declare faccs'_invar(1)[simp, intro]"], ["", "lemma faccs'_correct:\n    assumes HI[simp, intro!]: \"hta_has_idx_f H\"\n    shows \n      \"ls_\\<alpha> (faccs' H t) = faccs (ls_\\<alpha> (hta_\\<delta> H)) t\" (is ?T1)\n      \"List.map ls_\\<alpha> (List.map (faccs' H) ts) \n       = List.map (faccs (ls_\\<alpha> (hta_\\<delta> H))) ts\" (is ?T2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ls.\\<alpha> (faccs' H t) = faccs (ls.\\<alpha> \\<delta>) t &&&\n    map ls.\\<alpha> (map (faccs' H) ts) =\n    map (faccs (ls.\\<alpha> \\<delta>)) ts", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. ls.\\<alpha> (faccs' H t) = faccs (ls.\\<alpha> \\<delta>) t\n 2. map ls.\\<alpha> (map (faccs' H) ts) =\n    map (faccs (ls.\\<alpha> \\<delta>)) ts", "have \"?T1 \\<and> ?T2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ls.\\<alpha> (faccs' H t) = faccs (ls.\\<alpha> \\<delta>) t \\<and>\n    map ls.\\<alpha> (map (faccs' H) ts) =\n    map (faccs (ls.\\<alpha> \\<delta>)) ts", "proof (induct rule: compat_tree_tree_list.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       map ls.\\<alpha> (map (faccs' H) x2) =\n       map (faccs (ls.\\<alpha> \\<delta>)) x2 \\<Longrightarrow>\n       ls.\\<alpha> (faccs' H (NODE x1 x2)) =\n       faccs (ls.\\<alpha> \\<delta>) (NODE x1 x2)\n 2. map ls.\\<alpha> (map (faccs' H) []) =\n    map (faccs (ls.\\<alpha> \\<delta>)) []\n 3. \\<And>x1 x2.\n       \\<lbrakk>ls.\\<alpha> (faccs' H x1) = faccs (ls.\\<alpha> \\<delta>) x1;\n        map ls.\\<alpha> (map (faccs' H) x2) =\n        map (faccs (ls.\\<alpha> \\<delta>)) x2\\<rbrakk>\n       \\<Longrightarrow> map ls.\\<alpha> (map (faccs' H) (x1 # x2)) =\n                         map (faccs (ls.\\<alpha> \\<delta>)) (x1 # x2)", "case (NODE f ts)"], ["proof (state)\nthis:\n  map ls.\\<alpha> (map (faccs' H) ts) =\n  map (faccs (ls.\\<alpha> \\<delta>)) ts\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       map ls.\\<alpha> (map (faccs' H) x2) =\n       map (faccs (ls.\\<alpha> \\<delta>)) x2 \\<Longrightarrow>\n       ls.\\<alpha> (faccs' H (NODE x1 x2)) =\n       faccs (ls.\\<alpha> \\<delta>) (NODE x1 x2)\n 2. map ls.\\<alpha> (map (faccs' H) []) =\n    map (faccs (ls.\\<alpha> \\<delta>)) []\n 3. \\<And>x1 x2.\n       \\<lbrakk>ls.\\<alpha> (faccs' H x1) = faccs (ls.\\<alpha> \\<delta>) x1;\n        map ls.\\<alpha> (map (faccs' H) x2) =\n        map (faccs (ls.\\<alpha> \\<delta>)) x2\\<rbrakk>\n       \\<Longrightarrow> map ls.\\<alpha> (map (faccs' H) (x1 # x2)) =\n                         map (faccs (ls.\\<alpha> \\<delta>)) (x1 # x2)", "let ?\\<delta> = \"(ls_\\<alpha> (hta_\\<delta> H))\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       map ls.\\<alpha> (map (faccs' H) x2) =\n       map (faccs (ls.\\<alpha> \\<delta>)) x2 \\<Longrightarrow>\n       ls.\\<alpha> (faccs' H (NODE x1 x2)) =\n       faccs (ls.\\<alpha> \\<delta>) (NODE x1 x2)\n 2. map ls.\\<alpha> (map (faccs' H) []) =\n    map (faccs (ls.\\<alpha> \\<delta>)) []\n 3. \\<And>x1 x2.\n       \\<lbrakk>ls.\\<alpha> (faccs' H x1) = faccs (ls.\\<alpha> \\<delta>) x1;\n        map ls.\\<alpha> (map (faccs' H) x2) =\n        map (faccs (ls.\\<alpha> \\<delta>)) x2\\<rbrakk>\n       \\<Longrightarrow> map ls.\\<alpha> (map (faccs' H) (x1 # x2)) =\n                         map (faccs (ls.\\<alpha> \\<delta>)) (x1 # x2)", "have \"faccs ?\\<delta> (NODE f ts) = (\n        let Qs = List.map (faccs ?\\<delta>) ts in\n          {q. \\<exists>r\\<in>?\\<delta>. r_matchc q f Qs r })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. faccs (ls.\\<alpha> \\<delta>) (NODE f ts) =\n    (let Qs = map (faccs (ls.\\<alpha> \\<delta>)) ts\n     in {q. \\<exists>r\\<in>ls.\\<alpha> \\<delta>. r_matchc q f Qs r})", "by (rule faccs.simps)"], ["proof (state)\nthis:\n  faccs (ls.\\<alpha> \\<delta>) (NODE f ts) =\n  (let Qs = map (faccs (ls.\\<alpha> \\<delta>)) ts\n   in {q. \\<exists>r\\<in>ls.\\<alpha> \\<delta>. r_matchc q f Qs r})\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       map ls.\\<alpha> (map (faccs' H) x2) =\n       map (faccs (ls.\\<alpha> \\<delta>)) x2 \\<Longrightarrow>\n       ls.\\<alpha> (faccs' H (NODE x1 x2)) =\n       faccs (ls.\\<alpha> \\<delta>) (NODE x1 x2)\n 2. map ls.\\<alpha> (map (faccs' H) []) =\n    map (faccs (ls.\\<alpha> \\<delta>)) []\n 3. \\<And>x1 x2.\n       \\<lbrakk>ls.\\<alpha> (faccs' H x1) = faccs (ls.\\<alpha> \\<delta>) x1;\n        map ls.\\<alpha> (map (faccs' H) x2) =\n        map (faccs (ls.\\<alpha> \\<delta>)) x2\\<rbrakk>\n       \\<Longrightarrow> map ls.\\<alpha> (map (faccs' H) (x1 # x2)) =\n                         map (faccs (ls.\\<alpha> \\<delta>)) (x1 # x2)", "also"], ["proof (state)\nthis:\n  faccs (ls.\\<alpha> \\<delta>) (NODE f ts) =\n  (let Qs = map (faccs (ls.\\<alpha> \\<delta>)) ts\n   in {q. \\<exists>r\\<in>ls.\\<alpha> \\<delta>. r_matchc q f Qs r})\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       map ls.\\<alpha> (map (faccs' H) x2) =\n       map (faccs (ls.\\<alpha> \\<delta>)) x2 \\<Longrightarrow>\n       ls.\\<alpha> (faccs' H (NODE x1 x2)) =\n       faccs (ls.\\<alpha> \\<delta>) (NODE x1 x2)\n 2. map ls.\\<alpha> (map (faccs' H) []) =\n    map (faccs (ls.\\<alpha> \\<delta>)) []\n 3. \\<And>x1 x2.\n       \\<lbrakk>ls.\\<alpha> (faccs' H x1) = faccs (ls.\\<alpha> \\<delta>) x1;\n        map ls.\\<alpha> (map (faccs' H) x2) =\n        map (faccs (ls.\\<alpha> \\<delta>)) x2\\<rbrakk>\n       \\<Longrightarrow> map ls.\\<alpha> (map (faccs' H) (x1 # x2)) =\n                         map (faccs (ls.\\<alpha> \\<delta>)) (x1 # x2)", "note NODE.hyps[symmetric]"], ["proof (state)\nthis:\n  map (faccs (ls.\\<alpha> \\<delta>)) ts =\n  map ls.\\<alpha> (map (faccs' H) ts)\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       map ls.\\<alpha> (map (faccs' H) x2) =\n       map (faccs (ls.\\<alpha> \\<delta>)) x2 \\<Longrightarrow>\n       ls.\\<alpha> (faccs' H (NODE x1 x2)) =\n       faccs (ls.\\<alpha> \\<delta>) (NODE x1 x2)\n 2. map ls.\\<alpha> (map (faccs' H) []) =\n    map (faccs (ls.\\<alpha> \\<delta>)) []\n 3. \\<And>x1 x2.\n       \\<lbrakk>ls.\\<alpha> (faccs' H x1) = faccs (ls.\\<alpha> \\<delta>) x1;\n        map ls.\\<alpha> (map (faccs' H) x2) =\n        map (faccs (ls.\\<alpha> \\<delta>)) x2\\<rbrakk>\n       \\<Longrightarrow> map ls.\\<alpha> (map (faccs' H) (x1 # x2)) =\n                         map (faccs (ls.\\<alpha> \\<delta>)) (x1 # x2)", "finally"], ["proof (chain)\npicking this:\n  faccs (ls.\\<alpha> \\<delta>) (NODE f ts) =\n  (let Qs = map ls.\\<alpha> (map (faccs' H) ts)\n   in {q. \\<exists>r\\<in>ls.\\<alpha> \\<delta>. r_matchc q f Qs r})", "have \n        1: \"faccs ?\\<delta> (NODE f ts) \n            = ( let Qs = List.map ls_\\<alpha> (List.map (faccs' H) ts) in\n                 {q. \\<exists>r\\<in>?\\<delta>. r_matchc q f Qs r })\""], ["proof (prove)\nusing this:\n  faccs (ls.\\<alpha> \\<delta>) (NODE f ts) =\n  (let Qs = map ls.\\<alpha> (map (faccs' H) ts)\n   in {q. \\<exists>r\\<in>ls.\\<alpha> \\<delta>. r_matchc q f Qs r})\n\ngoal (1 subgoal):\n 1. faccs (ls.\\<alpha> \\<delta>) (NODE f ts) =\n    (let Qs = map ls.\\<alpha> (map (faccs' H) ts)\n     in {q. \\<exists>r\\<in>ls.\\<alpha> \\<delta>. r_matchc q f Qs r})", "."], ["proof (state)\nthis:\n  faccs (ls.\\<alpha> \\<delta>) (NODE f ts) =\n  (let Qs = map ls.\\<alpha> (map (faccs' H) ts)\n   in {q. \\<exists>r\\<in>ls.\\<alpha> \\<delta>. r_matchc q f Qs r})\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       map ls.\\<alpha> (map (faccs' H) x2) =\n       map (faccs (ls.\\<alpha> \\<delta>)) x2 \\<Longrightarrow>\n       ls.\\<alpha> (faccs' H (NODE x1 x2)) =\n       faccs (ls.\\<alpha> \\<delta>) (NODE x1 x2)\n 2. map ls.\\<alpha> (map (faccs' H) []) =\n    map (faccs (ls.\\<alpha> \\<delta>)) []\n 3. \\<And>x1 x2.\n       \\<lbrakk>ls.\\<alpha> (faccs' H x1) = faccs (ls.\\<alpha> \\<delta>) x1;\n        map ls.\\<alpha> (map (faccs' H) x2) =\n        map (faccs (ls.\\<alpha> \\<delta>)) x2\\<rbrakk>\n       \\<Longrightarrow> map ls.\\<alpha> (map (faccs' H) (x1 # x2)) =\n                         map (faccs (ls.\\<alpha> \\<delta>)) (x1 # x2)", "{"], ["proof (state)\nthis:\n  faccs (ls.\\<alpha> \\<delta>) (NODE f ts) =\n  (let Qs = map ls.\\<alpha> (map (faccs' H) ts)\n   in {q. \\<exists>r\\<in>ls.\\<alpha> \\<delta>. r_matchc q f Qs r})\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       map ls.\\<alpha> (map (faccs' H) x2) =\n       map (faccs (ls.\\<alpha> \\<delta>)) x2 \\<Longrightarrow>\n       ls.\\<alpha> (faccs' H (NODE x1 x2)) =\n       faccs (ls.\\<alpha> \\<delta>) (NODE x1 x2)\n 2. map ls.\\<alpha> (map (faccs' H) []) =\n    map (faccs (ls.\\<alpha> \\<delta>)) []\n 3. \\<And>x1 x2.\n       \\<lbrakk>ls.\\<alpha> (faccs' H x1) = faccs (ls.\\<alpha> \\<delta>) x1;\n        map ls.\\<alpha> (map (faccs' H) x2) =\n        map (faccs (ls.\\<alpha> \\<delta>)) x2\\<rbrakk>\n       \\<Longrightarrow> map ls.\\<alpha> (map (faccs' H) (x1 # x2)) =\n                         map (faccs (ls.\\<alpha> \\<delta>)) (x1 # x2)", "fix Qsc:: \"'Q ls list\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       map ls.\\<alpha> (map (faccs' H) x2) =\n       map (faccs (ls.\\<alpha> \\<delta>)) x2 \\<Longrightarrow>\n       ls.\\<alpha> (faccs' H (NODE x1 x2)) =\n       faccs (ls.\\<alpha> \\<delta>) (NODE x1 x2)\n 2. map ls.\\<alpha> (map (faccs' H) []) =\n    map (faccs (ls.\\<alpha> \\<delta>)) []\n 3. \\<And>x1 x2.\n       \\<lbrakk>ls.\\<alpha> (faccs' H x1) = faccs (ls.\\<alpha> \\<delta>) x1;\n        map ls.\\<alpha> (map (faccs' H) x2) =\n        map (faccs (ls.\\<alpha> \\<delta>)) x2\\<rbrakk>\n       \\<Longrightarrow> map ls.\\<alpha> (map (faccs' H) (x1 # x2)) =\n                         map (faccs (ls.\\<alpha> \\<delta>)) (x1 # x2)", "assume QI: \"list_all ls_invar Qsc\""], ["proof (state)\nthis:\n  list_all ls.invar Qsc\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       map ls.\\<alpha> (map (faccs' H) x2) =\n       map (faccs (ls.\\<alpha> \\<delta>)) x2 \\<Longrightarrow>\n       ls.\\<alpha> (faccs' H (NODE x1 x2)) =\n       faccs (ls.\\<alpha> \\<delta>) (NODE x1 x2)\n 2. map ls.\\<alpha> (map (faccs' H) []) =\n    map (faccs (ls.\\<alpha> \\<delta>)) []\n 3. \\<And>x1 x2.\n       \\<lbrakk>ls.\\<alpha> (faccs' H x1) = faccs (ls.\\<alpha> \\<delta>) x1;\n        map ls.\\<alpha> (map (faccs' H) x2) =\n        map (faccs (ls.\\<alpha> \\<delta>)) x2\\<rbrakk>\n       \\<Longrightarrow> map ls.\\<alpha> (map (faccs' H) (x1 # x2)) =\n                         map (faccs (ls.\\<alpha> \\<delta>)) (x1 # x2)", "let ?Qs = \"List.map ls_\\<alpha> Qsc\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       map ls.\\<alpha> (map (faccs' H) x2) =\n       map (faccs (ls.\\<alpha> \\<delta>)) x2 \\<Longrightarrow>\n       ls.\\<alpha> (faccs' H (NODE x1 x2)) =\n       faccs (ls.\\<alpha> \\<delta>) (NODE x1 x2)\n 2. map ls.\\<alpha> (map (faccs' H) []) =\n    map (faccs (ls.\\<alpha> \\<delta>)) []\n 3. \\<And>x1 x2.\n       \\<lbrakk>ls.\\<alpha> (faccs' H x1) = faccs (ls.\\<alpha> \\<delta>) x1;\n        map ls.\\<alpha> (map (faccs' H) x2) =\n        map (faccs (ls.\\<alpha> \\<delta>)) x2\\<rbrakk>\n       \\<Longrightarrow> map ls.\\<alpha> (map (faccs' H) (x1 # x2)) =\n                         map (faccs (ls.\\<alpha> \\<delta>)) (x1 # x2)", "have \"{ q. \\<exists>r\\<in>?\\<delta>. r_matchc q f ?Qs r } \n              = { q. \\<exists>qs. (q \\<rightarrow> f qs)\\<in>?\\<delta> \\<and> r_match ?Qs qs }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {q. \\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n           r_matchc q f (map ls.\\<alpha> Qsc) r} =\n    {q. \\<exists>qs.\n           q \\<rightarrow> f qs \\<in> ls.\\<alpha> \\<delta> \\<and>\n           r_match (map ls.\\<alpha> Qsc) qs}", "apply (safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x r.\n       \\<lbrakk>r \\<in> ls.\\<alpha> \\<delta>;\n        r_matchc x f (map ls.\\<alpha> Qsc) r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>qs.\n                            x \\<rightarrow> f qs\n                            \\<in> ls.\\<alpha> \\<delta> \\<and>\n                            r_match (map ls.\\<alpha> Qsc) qs\n 2. \\<And>x qs.\n       \\<lbrakk>x \\<rightarrow> f qs \\<in> ls.\\<alpha> \\<delta>;\n        r_match (map ls.\\<alpha> Qsc) qs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n                            r_matchc x f (map ls.\\<alpha> Qsc) r", "apply (case_tac r)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x r x1 x2 x3.\n       \\<lbrakk>r \\<in> ls.\\<alpha> \\<delta>;\n        r_matchc x f (map ls.\\<alpha> Qsc) r;\n        r = x1 \\<rightarrow> x2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>qs.\n                            x \\<rightarrow> f qs\n                            \\<in> ls.\\<alpha> \\<delta> \\<and>\n                            r_match (map ls.\\<alpha> Qsc) qs\n 2. \\<And>x qs.\n       \\<lbrakk>x \\<rightarrow> f qs \\<in> ls.\\<alpha> \\<delta>;\n        r_match (map ls.\\<alpha> Qsc) qs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n                            r_matchc x f (map ls.\\<alpha> Qsc) r", "apply auto [1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x qs.\n       \\<lbrakk>x \\<rightarrow> f qs \\<in> ls.\\<alpha> \\<delta>;\n        r_match (map ls.\\<alpha> Qsc) qs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n                            r_matchc x f (map ls.\\<alpha> Qsc) r", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {q. \\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n         r_matchc q f (map ls.\\<alpha> Qsc) r} =\n  {q. \\<exists>qs.\n         q \\<rightarrow> f qs \\<in> ls.\\<alpha> \\<delta> \\<and>\n         r_match (map ls.\\<alpha> Qsc) qs}\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       map ls.\\<alpha> (map (faccs' H) x2) =\n       map (faccs (ls.\\<alpha> \\<delta>)) x2 \\<Longrightarrow>\n       ls.\\<alpha> (faccs' H (NODE x1 x2)) =\n       faccs (ls.\\<alpha> \\<delta>) (NODE x1 x2)\n 2. map ls.\\<alpha> (map (faccs' H) []) =\n    map (faccs (ls.\\<alpha> \\<delta>)) []\n 3. \\<And>x1 x2.\n       \\<lbrakk>ls.\\<alpha> (faccs' H x1) = faccs (ls.\\<alpha> \\<delta>) x1;\n        map ls.\\<alpha> (map (faccs' H) x2) =\n        map (faccs (ls.\\<alpha> \\<delta>)) x2\\<rbrakk>\n       \\<Longrightarrow> map ls.\\<alpha> (map (faccs' H) (x1 # x2)) =\n                         map (faccs (ls.\\<alpha> \\<delta>)) (x1 # x2)", "also"], ["proof (state)\nthis:\n  {q. \\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n         r_matchc q f (map ls.\\<alpha> Qsc) r} =\n  {q. \\<exists>qs.\n         q \\<rightarrow> f qs \\<in> ls.\\<alpha> \\<delta> \\<and>\n         r_match (map ls.\\<alpha> Qsc) qs}\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       map ls.\\<alpha> (map (faccs' H) x2) =\n       map (faccs (ls.\\<alpha> \\<delta>)) x2 \\<Longrightarrow>\n       ls.\\<alpha> (faccs' H (NODE x1 x2)) =\n       faccs (ls.\\<alpha> \\<delta>) (NODE x1 x2)\n 2. map ls.\\<alpha> (map (faccs' H) []) =\n    map (faccs (ls.\\<alpha> \\<delta>)) []\n 3. \\<And>x1 x2.\n       \\<lbrakk>ls.\\<alpha> (faccs' H x1) = faccs (ls.\\<alpha> \\<delta>) x1;\n        map ls.\\<alpha> (map (faccs' H) x2) =\n        map (faccs (ls.\\<alpha> \\<delta>)) x2\\<rbrakk>\n       \\<Longrightarrow> map ls.\\<alpha> (map (faccs' H) (x1 # x2)) =\n                         map (faccs (ls.\\<alpha> \\<delta>)) (x1 # x2)", "have \"\\<dots> = lhs ` { r\\<in>{r\\<in>?\\<delta>. rhsl r = f}. \n                                 case r of (q \\<rightarrow> f' qs) \\<Rightarrow> r_match ?Qs qs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {q. \\<exists>qs.\n           q \\<rightarrow> f qs \\<in> ls.\\<alpha> \\<delta> \\<and>\n           r_match (map ls.\\<alpha> Qsc) qs} =\n    lhs `\n    {r \\<in> {r \\<in> ls.\\<alpha> \\<delta>. rhsl r = f}.\n     case r of\n     q \\<rightarrow> f' qs \\<Rightarrow> r_match (map ls.\\<alpha> Qsc) qs}", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x qs.\n       \\<lbrakk>x \\<rightarrow> f qs \\<in> ls.\\<alpha> \\<delta>;\n        r_match (map ls.\\<alpha> Qsc) qs\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lhs `\n                                 {r \\<in> ls.\\<alpha> \\<delta>.\n                                  rhsl r = f \\<and>\n                                  (case r of\n                                   q \\<rightarrow> f' x \\<Rightarrow>\n                                     r_match (map ls.\\<alpha> Qsc) x)}\n 2. \\<And>xa.\n       \\<lbrakk>xa \\<in> ls.\\<alpha> \\<delta>;\n        case xa of\n        q \\<rightarrow> f' x \\<Rightarrow> r_match (map ls.\\<alpha> Qsc) x;\n        f = rhsl xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>qs.\n                            lhs xa \\<rightarrow> rhsl xa qs\n                            \\<in> ls.\\<alpha> \\<delta> \\<and>\n                            r_match (map ls.\\<alpha> Qsc) qs", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> ls.\\<alpha> \\<delta>;\n        case xa of\n        q \\<rightarrow> f' x \\<Rightarrow> r_match (map ls.\\<alpha> Qsc) x;\n        f = rhsl xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>qs.\n                            lhs xa \\<rightarrow> rhsl xa qs\n                            \\<in> ls.\\<alpha> \\<delta> \\<and>\n                            r_match (map ls.\\<alpha> Qsc) qs", "apply (case_tac xa)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa x1 x2 x3.\n       \\<lbrakk>xa \\<in> ls.\\<alpha> \\<delta>;\n        case xa of\n        q \\<rightarrow> f' x \\<Rightarrow> r_match (map ls.\\<alpha> Qsc) x;\n        f = rhsl xa; xa = x1 \\<rightarrow> x2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>qs.\n                            lhs xa \\<rightarrow> rhsl xa qs\n                            \\<in> ls.\\<alpha> \\<delta> \\<and>\n                            r_match (map ls.\\<alpha> Qsc) qs", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {q. \\<exists>qs.\n         q \\<rightarrow> f qs \\<in> ls.\\<alpha> \\<delta> \\<and>\n         r_match (map ls.\\<alpha> Qsc) qs} =\n  lhs `\n  {r \\<in> {r \\<in> ls.\\<alpha> \\<delta>. rhsl r = f}.\n   case r of\n   q \\<rightarrow> f' qs \\<Rightarrow> r_match (map ls.\\<alpha> Qsc) qs}\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       map ls.\\<alpha> (map (faccs' H) x2) =\n       map (faccs (ls.\\<alpha> \\<delta>)) x2 \\<Longrightarrow>\n       ls.\\<alpha> (faccs' H (NODE x1 x2)) =\n       faccs (ls.\\<alpha> \\<delta>) (NODE x1 x2)\n 2. map ls.\\<alpha> (map (faccs' H) []) =\n    map (faccs (ls.\\<alpha> \\<delta>)) []\n 3. \\<And>x1 x2.\n       \\<lbrakk>ls.\\<alpha> (faccs' H x1) = faccs (ls.\\<alpha> \\<delta>) x1;\n        map ls.\\<alpha> (map (faccs' H) x2) =\n        map (faccs (ls.\\<alpha> \\<delta>)) x2\\<rbrakk>\n       \\<Longrightarrow> map ls.\\<alpha> (map (faccs' H) (x1 # x2)) =\n                         map (faccs (ls.\\<alpha> \\<delta>)) (x1 # x2)", "finally"], ["proof (chain)\npicking this:\n  {q. \\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n         r_matchc q f (map ls.\\<alpha> Qsc) r} =\n  lhs `\n  {r \\<in> {r \\<in> ls.\\<alpha> \\<delta>. rhsl r = f}.\n   case r of\n   q \\<rightarrow> f' qs \\<Rightarrow> r_match (map ls.\\<alpha> Qsc) qs}", "have \n          1: \"{ q. \\<exists>r\\<in>?\\<delta>. r_matchc q f ?Qs r } \n              = lhs ` { r\\<in>{r\\<in>?\\<delta>. rhsl r = f}. \n                         case r of (q \\<rightarrow> f' qs) \\<Rightarrow> r_match ?Qs qs}\""], ["proof (prove)\nusing this:\n  {q. \\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n         r_matchc q f (map ls.\\<alpha> Qsc) r} =\n  lhs `\n  {r \\<in> {r \\<in> ls.\\<alpha> \\<delta>. rhsl r = f}.\n   case r of\n   q \\<rightarrow> f' qs \\<Rightarrow> r_match (map ls.\\<alpha> Qsc) qs}\n\ngoal (1 subgoal):\n 1. {q. \\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n           r_matchc q f (map ls.\\<alpha> Qsc) r} =\n    lhs `\n    {r \\<in> {r \\<in> ls.\\<alpha> \\<delta>. rhsl r = f}.\n     case r of\n     q \\<rightarrow> f' qs \\<Rightarrow> r_match (map ls.\\<alpha> Qsc) qs}", "by auto"], ["proof (state)\nthis:\n  {q. \\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n         r_matchc q f (map ls.\\<alpha> Qsc) r} =\n  lhs `\n  {r \\<in> {r \\<in> ls.\\<alpha> \\<delta>. rhsl r = f}.\n   case r of\n   q \\<rightarrow> f' qs \\<Rightarrow> r_match (map ls.\\<alpha> Qsc) qs}\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       map ls.\\<alpha> (map (faccs' H) x2) =\n       map (faccs (ls.\\<alpha> \\<delta>)) x2 \\<Longrightarrow>\n       ls.\\<alpha> (faccs' H (NODE x1 x2)) =\n       faccs (ls.\\<alpha> \\<delta>) (NODE x1 x2)\n 2. map ls.\\<alpha> (map (faccs' H) []) =\n    map (faccs (ls.\\<alpha> \\<delta>)) []\n 3. \\<And>x1 x2.\n       \\<lbrakk>ls.\\<alpha> (faccs' H x1) = faccs (ls.\\<alpha> \\<delta>) x1;\n        map ls.\\<alpha> (map (faccs' H) x2) =\n        map (faccs (ls.\\<alpha> \\<delta>)) x2\\<rbrakk>\n       \\<Longrightarrow> map ls.\\<alpha> (map (faccs' H) (x1 # x2)) =\n                         map (faccs (ls.\\<alpha> \\<delta>)) (x1 # x2)", "from QI"], ["proof (chain)\npicking this:\n  list_all ls.invar Qsc", "have \n          [simp]: \"!!qs. list_all_zip (\\<lambda>Q q. q\\<in>ls_\\<alpha> Q) Qsc qs \n                         \\<longleftrightarrow> list_all_zip (\\<lambda>Q q. ls_memb q Q) Qsc qs\""], ["proof (prove)\nusing this:\n  list_all ls.invar Qsc\n\ngoal (1 subgoal):\n 1. \\<And>qs.\n       list_all_zip (\\<lambda>Q q. q \\<in> ls.\\<alpha> Q) Qsc qs =\n       list_all_zip (\\<lambda>Q q. ls.memb q Q) Qsc qs", "apply (induct Qsc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>qs.\n       list_all ls.invar [] \\<Longrightarrow>\n       list_all_zip (\\<lambda>Q q. q \\<in> ls.\\<alpha> Q) [] qs =\n       list_all_zip (\\<lambda>Q q. ls.memb q Q) [] qs\n 2. \\<And>a Qsc qs.\n       \\<lbrakk>\\<And>qs.\n                   list_all ls.invar Qsc \\<Longrightarrow>\n                   list_all_zip (\\<lambda>Q q. q \\<in> ls.\\<alpha> Q) Qsc\n                    qs =\n                   list_all_zip (\\<lambda>Q q. ls.memb q Q) Qsc qs;\n        list_all ls.invar (a # Qsc)\\<rbrakk>\n       \\<Longrightarrow> list_all_zip (\\<lambda>Q q. q \\<in> ls.\\<alpha> Q)\n                          (a # Qsc) qs =\n                         list_all_zip (\\<lambda>Q q. ls.memb q Q) (a # Qsc)\n                          qs", "apply (case_tac qs)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>qs.\n       \\<lbrakk>list_all ls.invar []; qs = []\\<rbrakk>\n       \\<Longrightarrow> list_all_zip (\\<lambda>Q q. q \\<in> ls.\\<alpha> Q)\n                          [] qs =\n                         list_all_zip (\\<lambda>Q q. ls.memb q Q) [] qs\n 2. \\<And>qs a list.\n       \\<lbrakk>list_all ls.invar []; qs = a # list\\<rbrakk>\n       \\<Longrightarrow> list_all_zip (\\<lambda>Q q. q \\<in> ls.\\<alpha> Q)\n                          [] qs =\n                         list_all_zip (\\<lambda>Q q. ls.memb q Q) [] qs\n 3. \\<And>a Qsc qs.\n       \\<lbrakk>\\<And>qs.\n                   list_all ls.invar Qsc \\<Longrightarrow>\n                   list_all_zip (\\<lambda>Q q. q \\<in> ls.\\<alpha> Q) Qsc\n                    qs =\n                   list_all_zip (\\<lambda>Q q. ls.memb q Q) Qsc qs;\n        list_all ls.invar (a # Qsc)\\<rbrakk>\n       \\<Longrightarrow> list_all_zip (\\<lambda>Q q. q \\<in> ls.\\<alpha> Q)\n                          (a # Qsc) qs =\n                         list_all_zip (\\<lambda>Q q. ls.memb q Q) (a # Qsc)\n                          qs", "apply auto [2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a Qsc qs.\n       \\<lbrakk>\\<And>qs.\n                   list_all ls.invar Qsc \\<Longrightarrow>\n                   list_all_zip (\\<lambda>Q q. q \\<in> ls.\\<alpha> Q) Qsc\n                    qs =\n                   list_all_zip (\\<lambda>Q q. ls.memb q Q) Qsc qs;\n        list_all ls.invar (a # Qsc)\\<rbrakk>\n       \\<Longrightarrow> list_all_zip (\\<lambda>Q q. q \\<in> ls.\\<alpha> Q)\n                          (a # Qsc) qs =\n                         list_all_zip (\\<lambda>Q q. ls.memb q Q) (a # Qsc)\n                          qs", "apply (case_tac qs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a Qsc qs.\n       \\<lbrakk>\\<And>qs.\n                   list_all ls.invar Qsc \\<Longrightarrow>\n                   list_all_zip (\\<lambda>Q q. q \\<in> ls.\\<alpha> Q) Qsc\n                    qs =\n                   list_all_zip (\\<lambda>Q q. ls.memb q Q) Qsc qs;\n        list_all ls.invar (a # Qsc); qs = []\\<rbrakk>\n       \\<Longrightarrow> list_all_zip (\\<lambda>Q q. q \\<in> ls.\\<alpha> Q)\n                          (a # Qsc) qs =\n                         list_all_zip (\\<lambda>Q q. ls.memb q Q) (a # Qsc)\n                          qs\n 2. \\<And>a Qsc qs aa list.\n       \\<lbrakk>\\<And>qs.\n                   list_all ls.invar Qsc \\<Longrightarrow>\n                   list_all_zip (\\<lambda>Q q. q \\<in> ls.\\<alpha> Q) Qsc\n                    qs =\n                   list_all_zip (\\<lambda>Q q. ls.memb q Q) Qsc qs;\n        list_all ls.invar (a # Qsc); qs = aa # list\\<rbrakk>\n       \\<Longrightarrow> list_all_zip (\\<lambda>Q q. q \\<in> ls.\\<alpha> Q)\n                          (a # Qsc) qs =\n                         list_all_zip (\\<lambda>Q q. ls.memb q Q) (a # Qsc)\n                          qs", "apply (auto simp add: ls.correct) [2]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  list_all_zip (\\<lambda>Q q. q \\<in> ls.\\<alpha> Q) Qsc ?qs =\n  list_all_zip (\\<lambda>Q q. ls.memb q Q) Qsc ?qs\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       map ls.\\<alpha> (map (faccs' H) x2) =\n       map (faccs (ls.\\<alpha> \\<delta>)) x2 \\<Longrightarrow>\n       ls.\\<alpha> (faccs' H (NODE x1 x2)) =\n       faccs (ls.\\<alpha> \\<delta>) (NODE x1 x2)\n 2. map ls.\\<alpha> (map (faccs' H) []) =\n    map (faccs (ls.\\<alpha> \\<delta>)) []\n 3. \\<And>x1 x2.\n       \\<lbrakk>ls.\\<alpha> (faccs' H x1) = faccs (ls.\\<alpha> \\<delta>) x1;\n        map ls.\\<alpha> (map (faccs' H) x2) =\n        map (faccs (ls.\\<alpha> \\<delta>)) x2\\<rbrakk>\n       \\<Longrightarrow> map ls.\\<alpha> (map (faccs' H) (x1 # x2)) =\n                         map (faccs (ls.\\<alpha> \\<delta>)) (x1 # x2)", "have 2: \"!!qs. r_match ?Qs qs = list_all_zip (\\<lambda>a b. ls_memb b a) Qsc qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>qs.\n       r_match (map ls.\\<alpha> Qsc) qs =\n       list_all_zip (\\<lambda>a b. ls.memb b a) Qsc qs", "apply (unfold r_match_by_laz)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>qs.\n       list_all_zip (\\<lambda>Q q. q \\<in> Q) (map ls.\\<alpha> Qsc) qs =\n       list_all_zip (\\<lambda>a b. ls.memb b a) Qsc qs", "apply (simp add: list_all_zip_map1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  r_match (map ls.\\<alpha> Qsc) ?qs =\n  list_all_zip (\\<lambda>a b. ls.memb b a) Qsc ?qs\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       map ls.\\<alpha> (map (faccs' H) x2) =\n       map (faccs (ls.\\<alpha> \\<delta>)) x2 \\<Longrightarrow>\n       ls.\\<alpha> (faccs' H (NODE x1 x2)) =\n       faccs (ls.\\<alpha> \\<delta>) (NODE x1 x2)\n 2. map ls.\\<alpha> (map (faccs' H) []) =\n    map (faccs (ls.\\<alpha> \\<delta>)) []\n 3. \\<And>x1 x2.\n       \\<lbrakk>ls.\\<alpha> (faccs' H x1) = faccs (ls.\\<alpha> \\<delta>) x1;\n        map ls.\\<alpha> (map (faccs' H) x2) =\n        map (faccs (ls.\\<alpha> \\<delta>)) x2\\<rbrakk>\n       \\<Longrightarrow> map ls.\\<alpha> (map (faccs' H) (x1 # x2)) =\n                         map (faccs (ls.\\<alpha> \\<delta>)) (x1 # x2)", "from 1"], ["proof (chain)\npicking this:\n  {q. \\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n         r_matchc q f (map ls.\\<alpha> Qsc) r} =\n  lhs `\n  {r \\<in> {r \\<in> ls.\\<alpha> \\<delta>. rhsl r = f}.\n   case r of\n   q \\<rightarrow> f' qs \\<Rightarrow> r_match (map ls.\\<alpha> Qsc) qs}", "have \n          \"{ q. \\<exists>r\\<in>?\\<delta>. r_matchc q f ?Qs r } \n           = lhs ` { r\\<in>{r\\<in>?\\<delta>. rhsl r = f}. \n                     case r of (q \\<rightarrow> f' qs) \\<Rightarrow> \n                       list_all_zip (\\<lambda>a b. ls_memb b a) Qsc qs}\""], ["proof (prove)\nusing this:\n  {q. \\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n         r_matchc q f (map ls.\\<alpha> Qsc) r} =\n  lhs `\n  {r \\<in> {r \\<in> ls.\\<alpha> \\<delta>. rhsl r = f}.\n   case r of\n   q \\<rightarrow> f' qs \\<Rightarrow> r_match (map ls.\\<alpha> Qsc) qs}\n\ngoal (1 subgoal):\n 1. {q. \\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n           r_matchc q f (map ls.\\<alpha> Qsc) r} =\n    lhs `\n    {r \\<in> {r \\<in> ls.\\<alpha> \\<delta>. rhsl r = f}.\n     case r of\n     q \\<rightarrow> f' qs \\<Rightarrow>\n       list_all_zip (\\<lambda>a b. ls.memb b a) Qsc qs}", "by (simp only: 2)"], ["proof (state)\nthis:\n  {q. \\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n         r_matchc q f (map ls.\\<alpha> Qsc) r} =\n  lhs `\n  {r \\<in> {r \\<in> ls.\\<alpha> \\<delta>. rhsl r = f}.\n   case r of\n   q \\<rightarrow> f' qs \\<Rightarrow>\n     list_all_zip (\\<lambda>a b. ls.memb b a) Qsc qs}\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       map ls.\\<alpha> (map (faccs' H) x2) =\n       map (faccs (ls.\\<alpha> \\<delta>)) x2 \\<Longrightarrow>\n       ls.\\<alpha> (faccs' H (NODE x1 x2)) =\n       faccs (ls.\\<alpha> \\<delta>) (NODE x1 x2)\n 2. map ls.\\<alpha> (map (faccs' H) []) =\n    map (faccs (ls.\\<alpha> \\<delta>)) []\n 3. \\<And>x1 x2.\n       \\<lbrakk>ls.\\<alpha> (faccs' H x1) = faccs (ls.\\<alpha> \\<delta>) x1;\n        map ls.\\<alpha> (map (faccs' H) x2) =\n        map (faccs (ls.\\<alpha> \\<delta>)) x2\\<rbrakk>\n       \\<Longrightarrow> map ls.\\<alpha> (map (faccs' H) (x1 # x2)) =\n                         map (faccs (ls.\\<alpha> \\<delta>)) (x1 # x2)", "also"], ["proof (state)\nthis:\n  {q. \\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n         r_matchc q f (map ls.\\<alpha> Qsc) r} =\n  lhs `\n  {r \\<in> {r \\<in> ls.\\<alpha> \\<delta>. rhsl r = f}.\n   case r of\n   q \\<rightarrow> f' qs \\<Rightarrow>\n     list_all_zip (\\<lambda>a b. ls.memb b a) Qsc qs}\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       map ls.\\<alpha> (map (faccs' H) x2) =\n       map (faccs (ls.\\<alpha> \\<delta>)) x2 \\<Longrightarrow>\n       ls.\\<alpha> (faccs' H (NODE x1 x2)) =\n       faccs (ls.\\<alpha> \\<delta>) (NODE x1 x2)\n 2. map ls.\\<alpha> (map (faccs' H) []) =\n    map (faccs (ls.\\<alpha> \\<delta>)) []\n 3. \\<And>x1 x2.\n       \\<lbrakk>ls.\\<alpha> (faccs' H x1) = faccs (ls.\\<alpha> \\<delta>) x1;\n        map ls.\\<alpha> (map (faccs' H) x2) =\n        map (faccs (ls.\\<alpha> \\<delta>)) x2\\<rbrakk>\n       \\<Longrightarrow> map ls.\\<alpha> (map (faccs' H) (x1 # x2)) =\n                         map (faccs (ls.\\<alpha> \\<delta>)) (x1 # x2)", "have \n          \"\\<dots> = lhs ` { r\\<in>ls_\\<alpha> (hta_lookup_f f H). \n                         case r of (q \\<rightarrow> f' qs) \\<Rightarrow> \n                           list_all_zip (\\<lambda>a b. ls_memb b a) Qsc qs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhs `\n    {r \\<in> {r \\<in> ls.\\<alpha> \\<delta>. rhsl r = f}.\n     case r of\n     q \\<rightarrow> f' qs \\<Rightarrow>\n       list_all_zip (\\<lambda>a b. ls.memb b a) Qsc qs} =\n    lhs `\n    {r \\<in> ls.\\<alpha> (hta_lookup_f f H).\n     case r of\n     q \\<rightarrow> f' qs \\<Rightarrow>\n       list_all_zip (\\<lambda>a b. ls.memb b a) Qsc qs}", "by (simp add: hta_lookup_f_correct)"], ["proof (state)\nthis:\n  lhs `\n  {r \\<in> {r \\<in> ls.\\<alpha> \\<delta>. rhsl r = f}.\n   case r of\n   q \\<rightarrow> f' qs \\<Rightarrow>\n     list_all_zip (\\<lambda>a b. ls.memb b a) Qsc qs} =\n  lhs `\n  {r \\<in> ls.\\<alpha> (hta_lookup_f f H).\n   case r of\n   q \\<rightarrow> f' qs \\<Rightarrow>\n     list_all_zip (\\<lambda>a b. ls.memb b a) Qsc qs}\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       map ls.\\<alpha> (map (faccs' H) x2) =\n       map (faccs (ls.\\<alpha> \\<delta>)) x2 \\<Longrightarrow>\n       ls.\\<alpha> (faccs' H (NODE x1 x2)) =\n       faccs (ls.\\<alpha> \\<delta>) (NODE x1 x2)\n 2. map ls.\\<alpha> (map (faccs' H) []) =\n    map (faccs (ls.\\<alpha> \\<delta>)) []\n 3. \\<And>x1 x2.\n       \\<lbrakk>ls.\\<alpha> (faccs' H x1) = faccs (ls.\\<alpha> \\<delta>) x1;\n        map ls.\\<alpha> (map (faccs' H) x2) =\n        map (faccs (ls.\\<alpha> \\<delta>)) x2\\<rbrakk>\n       \\<Longrightarrow> map ls.\\<alpha> (map (faccs' H) (x1 # x2)) =\n                         map (faccs (ls.\\<alpha> \\<delta>)) (x1 # x2)", "also"], ["proof (state)\nthis:\n  lhs `\n  {r \\<in> {r \\<in> ls.\\<alpha> \\<delta>. rhsl r = f}.\n   case r of\n   q \\<rightarrow> f' qs \\<Rightarrow>\n     list_all_zip (\\<lambda>a b. ls.memb b a) Qsc qs} =\n  lhs `\n  {r \\<in> ls.\\<alpha> (hta_lookup_f f H).\n   case r of\n   q \\<rightarrow> f' qs \\<Rightarrow>\n     list_all_zip (\\<lambda>a b. ls.memb b a) Qsc qs}\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       map ls.\\<alpha> (map (faccs' H) x2) =\n       map (faccs (ls.\\<alpha> \\<delta>)) x2 \\<Longrightarrow>\n       ls.\\<alpha> (faccs' H (NODE x1 x2)) =\n       faccs (ls.\\<alpha> \\<delta>) (NODE x1 x2)\n 2. map ls.\\<alpha> (map (faccs' H) []) =\n    map (faccs (ls.\\<alpha> \\<delta>)) []\n 3. \\<And>x1 x2.\n       \\<lbrakk>ls.\\<alpha> (faccs' H x1) = faccs (ls.\\<alpha> \\<delta>) x1;\n        map ls.\\<alpha> (map (faccs' H) x2) =\n        map (faccs (ls.\\<alpha> \\<delta>)) x2\\<rbrakk>\n       \\<Longrightarrow> map ls.\\<alpha> (map (faccs' H) (x1 # x2)) =\n                         map (faccs (ls.\\<alpha> \\<delta>)) (x1 # x2)", "have \n          \"\\<dots> = ls_\\<alpha> ( ll_set_xy.g_image_filter \n                         ( \\<lambda>r. case r of (q \\<rightarrow> f' qs) \\<Rightarrow> \n                             (if (list_all_zip (\\<lambda>Q q. ls_memb q Q) Qsc qs) then Some (lhs r) else None))\n                         (hta_lookup_f f H)\n                     )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhs `\n    {r \\<in> ls.\\<alpha> (hta_lookup_f f H).\n     case r of\n     q \\<rightarrow> f' qs \\<Rightarrow>\n       list_all_zip (\\<lambda>a b. ls.memb b a) Qsc qs} =\n    ls.\\<alpha>\n     (ll_set_xy.g_image_filter\n       (\\<lambda>r.\n           case r of\n           q \\<rightarrow> f' qs \\<Rightarrow>\n             if list_all_zip (\\<lambda>Q q. ls.memb q Q) Qsc qs\n             then Some (lhs r) else None)\n       (hta_lookup_f f H))", "apply (simp add: ll_set_xy.image_filter_correct hta_lookup_f_correct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. lhs `\n    {r \\<in> ls.\\<alpha> \\<delta>.\n     rhsl r = f \\<and>\n     (case r of\n      q \\<rightarrow> f' x \\<Rightarrow>\n        list_all_zip (\\<lambda>a b. ls.memb b a) Qsc x)} =\n    {b. \\<exists>a.\n           a \\<in> ls.\\<alpha> \\<delta> \\<and>\n           rhsl a = f \\<and>\n           (case a of\n            q \\<rightarrow> f' qs \\<Rightarrow>\n              if list_all_zip (\\<lambda>Q q. ls.memb q Q) Qsc qs\n              then Some (lhs a) else None) =\n           Some b}", "apply (auto split: ta_rule.split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<forall>x1 x2 x3.\n          xa = x1 \\<rightarrow> x2 x3 \\<longrightarrow>\n          x1 \\<rightarrow> x2 x3 \\<in> ls.\\<alpha> \\<delta> \\<and>\n          x2 = f \\<and>\n          list_all_zip (\\<lambda>a b. ls.memb b a) Qsc x3 \\<Longrightarrow>\n       \\<exists>a.\n          \\<forall>x1 x2 x3.\n             (list_all_zip (\\<lambda>Q q. ls.memb q Q) Qsc\n               x3 \\<longrightarrow>\n              a = x1 \\<rightarrow> x2 x3 \\<longrightarrow>\n              x1 \\<rightarrow> x2 x3 \\<in> ls.\\<alpha> \\<delta> \\<and>\n              x2 = f \\<and> x1 = lhs xa) \\<and>\n             (\\<not> list_all_zip (\\<lambda>Q q. ls.memb q Q) Qsc\n                      x3 \\<longrightarrow>\n              a \\<noteq> x1 \\<rightarrow> x2 x3)\n 2. \\<And>x a.\n       \\<forall>x1 x2 x3.\n          (list_all_zip (\\<lambda>Q q. ls.memb q Q) Qsc x3 \\<longrightarrow>\n           a = x1 \\<rightarrow> x2 x3 \\<longrightarrow>\n           x1 \\<rightarrow> x2 x3 \\<in> ls.\\<alpha> \\<delta> \\<and>\n           x2 = f \\<and> x1 = x) \\<and>\n          (\\<not> list_all_zip (\\<lambda>Q q. ls.memb q Q) Qsc\n                   x3 \\<longrightarrow>\n           a \\<noteq> x1 \\<rightarrow> x2 x3) \\<Longrightarrow>\n       x \\<in> lhs `\n               {r. \\<forall>x1 x2 x3.\n                      r = x1 \\<rightarrow> x2 x3 \\<longrightarrow>\n                      x1 \\<rightarrow> x2 x3\n                      \\<in> ls.\\<alpha> \\<delta> \\<and>\n                      x2 = f \\<and>\n                      list_all_zip (\\<lambda>a b. ls.memb b a) Qsc x3}", "apply (rule_tac x=xa in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<forall>x1 x2 x3.\n          xa = x1 \\<rightarrow> x2 x3 \\<longrightarrow>\n          x1 \\<rightarrow> x2 x3 \\<in> ls.\\<alpha> \\<delta> \\<and>\n          x2 = f \\<and>\n          list_all_zip (\\<lambda>a b. ls.memb b a) Qsc x3 \\<Longrightarrow>\n       \\<forall>x1 x2 x3.\n          (list_all_zip (\\<lambda>Q q. ls.memb q Q) Qsc x3 \\<longrightarrow>\n           xa = x1 \\<rightarrow> x2 x3 \\<longrightarrow>\n           x1 \\<rightarrow> x2 x3 \\<in> ls.\\<alpha> \\<delta> \\<and>\n           x2 = f \\<and> x1 = lhs xa) \\<and>\n          (\\<not> list_all_zip (\\<lambda>Q q. ls.memb q Q) Qsc\n                   x3 \\<longrightarrow>\n           xa \\<noteq> x1 \\<rightarrow> x2 x3)\n 2. \\<And>x a.\n       \\<forall>x1 x2 x3.\n          (list_all_zip (\\<lambda>Q q. ls.memb q Q) Qsc x3 \\<longrightarrow>\n           a = x1 \\<rightarrow> x2 x3 \\<longrightarrow>\n           x1 \\<rightarrow> x2 x3 \\<in> ls.\\<alpha> \\<delta> \\<and>\n           x2 = f \\<and> x1 = x) \\<and>\n          (\\<not> list_all_zip (\\<lambda>Q q. ls.memb q Q) Qsc\n                   x3 \\<longrightarrow>\n           a \\<noteq> x1 \\<rightarrow> x2 x3) \\<Longrightarrow>\n       x \\<in> lhs `\n               {r. \\<forall>x1 x2 x3.\n                      r = x1 \\<rightarrow> x2 x3 \\<longrightarrow>\n                      x1 \\<rightarrow> x2 x3\n                      \\<in> ls.\\<alpha> \\<delta> \\<and>\n                      x2 = f \\<and>\n                      list_all_zip (\\<lambda>a b. ls.memb b a) Qsc x3}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a.\n       \\<forall>x1 x2 x3.\n          (list_all_zip (\\<lambda>Q q. ls.memb q Q) Qsc x3 \\<longrightarrow>\n           a = x1 \\<rightarrow> x2 x3 \\<longrightarrow>\n           x1 \\<rightarrow> x2 x3 \\<in> ls.\\<alpha> \\<delta> \\<and>\n           x2 = f \\<and> x1 = x) \\<and>\n          (\\<not> list_all_zip (\\<lambda>Q q. ls.memb q Q) Qsc\n                   x3 \\<longrightarrow>\n           a \\<noteq> x1 \\<rightarrow> x2 x3) \\<Longrightarrow>\n       x \\<in> lhs `\n               {r. \\<forall>x1 x2 x3.\n                      r = x1 \\<rightarrow> x2 x3 \\<longrightarrow>\n                      x1 \\<rightarrow> x2 x3\n                      \\<in> ls.\\<alpha> \\<delta> \\<and>\n                      x2 = f \\<and>\n                      list_all_zip (\\<lambda>a b. ls.memb b a) Qsc x3}", "apply (case_tac a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a x1 x2 x3.\n       \\<lbrakk>\\<forall>x1 x2 x3.\n                   (list_all_zip (\\<lambda>Q q. ls.memb q Q) Qsc\n                     x3 \\<longrightarrow>\n                    a = x1 \\<rightarrow> x2 x3 \\<longrightarrow>\n                    x1 \\<rightarrow> x2 x3 \\<in> ls.\\<alpha> \\<delta> \\<and>\n                    x2 = f \\<and> x1 = x) \\<and>\n                   (\\<not> list_all_zip (\\<lambda>Q q. ls.memb q Q) Qsc\n                            x3 \\<longrightarrow>\n                    a \\<noteq> x1 \\<rightarrow> x2 x3);\n        a = x1 \\<rightarrow> x2 x3\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lhs `\n                                 {r. \\<forall>x1 x2 x3.\n  r = x1 \\<rightarrow> x2 x3 \\<longrightarrow>\n  x1 \\<rightarrow> x2 x3 \\<in> ls.\\<alpha> \\<delta> \\<and>\n  x2 = f \\<and> list_all_zip (\\<lambda>a b. ls.memb b a) Qsc x3}", "apply (simp add: image_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a x1 x2 x3.\n       \\<lbrakk>\\<forall>x1a x2a x3a.\n                   (list_all_zip (\\<lambda>Q q. ls.memb q Q) Qsc\n                     x3a \\<longrightarrow>\n                    x1 = x1a \\<and>\n                    x2 = x2a \\<and> x3 = x3a \\<longrightarrow>\n                    x1a \\<rightarrow> x2a x3a\n                    \\<in> ls.\\<alpha> \\<delta> \\<and>\n                    x2a = f \\<and> x1a = x) \\<and>\n                   (\\<not> list_all_zip (\\<lambda>Q q. ls.memb q Q) Qsc\n                            x3a \\<longrightarrow>\n                    x2 = x2a \\<longrightarrow>\n                    x1 = x1a \\<longrightarrow> x3 \\<noteq> x3a);\n        a = x1 \\<rightarrow> x2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<forall>x1 x2 x3.\n                                xa =\n                                x1 \\<rightarrow> x2 x3 \\<longrightarrow>\n                                x1 \\<rightarrow> x2 x3\n                                \\<in> ls.\\<alpha> \\<delta> \\<and>\n                                x2 = f \\<and>\n                                list_all_zip (\\<lambda>a b. ls.memb b a) Qsc\n                                 x3) \\<and>\n                            x = lhs xa", "apply (rule_tac x=a in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a x1 x2 x3.\n       \\<lbrakk>\\<forall>x1a x2a x3a.\n                   (list_all_zip (\\<lambda>Q q. ls.memb q Q) Qsc\n                     x3a \\<longrightarrow>\n                    x1 = x1a \\<and>\n                    x2 = x2a \\<and> x3 = x3a \\<longrightarrow>\n                    x1a \\<rightarrow> x2a x3a\n                    \\<in> ls.\\<alpha> \\<delta> \\<and>\n                    x2a = f \\<and> x1a = x) \\<and>\n                   (\\<not> list_all_zip (\\<lambda>Q q. ls.memb q Q) Qsc\n                            x3a \\<longrightarrow>\n                    x2 = x2a \\<longrightarrow>\n                    x1 = x1a \\<longrightarrow> x3 \\<noteq> x3a);\n        a = x1 \\<rightarrow> x2 x3\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x1 x2 x3.\n                             a = x1 \\<rightarrow> x2 x3 \\<longrightarrow>\n                             x1 \\<rightarrow> x2 x3\n                             \\<in> ls.\\<alpha> \\<delta> \\<and>\n                             x2 = f \\<and>\n                             list_all_zip (\\<lambda>a b. ls.memb b a) Qsc\n                              x3) \\<and>\n                         x = lhs a", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  lhs `\n  {r \\<in> ls.\\<alpha> (hta_lookup_f f H).\n   case r of\n   q \\<rightarrow> f' qs \\<Rightarrow>\n     list_all_zip (\\<lambda>a b. ls.memb b a) Qsc qs} =\n  ls.\\<alpha>\n   (ll_set_xy.g_image_filter\n     (\\<lambda>r.\n         case r of\n         q \\<rightarrow> f' qs \\<Rightarrow>\n           if list_all_zip (\\<lambda>Q q. ls.memb q Q) Qsc qs\n           then Some (lhs r) else None)\n     (hta_lookup_f f H))\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       map ls.\\<alpha> (map (faccs' H) x2) =\n       map (faccs (ls.\\<alpha> \\<delta>)) x2 \\<Longrightarrow>\n       ls.\\<alpha> (faccs' H (NODE x1 x2)) =\n       faccs (ls.\\<alpha> \\<delta>) (NODE x1 x2)\n 2. map ls.\\<alpha> (map (faccs' H) []) =\n    map (faccs (ls.\\<alpha> \\<delta>)) []\n 3. \\<And>x1 x2.\n       \\<lbrakk>ls.\\<alpha> (faccs' H x1) = faccs (ls.\\<alpha> \\<delta>) x1;\n        map ls.\\<alpha> (map (faccs' H) x2) =\n        map (faccs (ls.\\<alpha> \\<delta>)) x2\\<rbrakk>\n       \\<Longrightarrow> map ls.\\<alpha> (map (faccs' H) (x1 # x2)) =\n                         map (faccs (ls.\\<alpha> \\<delta>)) (x1 # x2)", "finally"], ["proof (chain)\npicking this:\n  {q. \\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n         r_matchc q f (map ls.\\<alpha> Qsc) r} =\n  ls.\\<alpha>\n   (ll_set_xy.g_image_filter\n     (\\<lambda>r.\n         case r of\n         q \\<rightarrow> f' qs \\<Rightarrow>\n           if list_all_zip (\\<lambda>Q q. ls.memb q Q) Qsc qs\n           then Some (lhs r) else None)\n     (hta_lookup_f f H))", "have \n          \"{ q. \\<exists>r\\<in>?\\<delta>. r_matchc q f ?Qs r } \n           = ls_\\<alpha> ( ll_set_xy.g_image_filter \n                      (\\<lambda>r. case r of (q \\<rightarrow> f' qs) \\<Rightarrow> \n                        (if (list_all_zip (\\<lambda>Q q. ls_memb q Q) Qsc qs) then Some (lhs r) else None))\n                      (hta_lookup_f f H))\""], ["proof (prove)\nusing this:\n  {q. \\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n         r_matchc q f (map ls.\\<alpha> Qsc) r} =\n  ls.\\<alpha>\n   (ll_set_xy.g_image_filter\n     (\\<lambda>r.\n         case r of\n         q \\<rightarrow> f' qs \\<Rightarrow>\n           if list_all_zip (\\<lambda>Q q. ls.memb q Q) Qsc qs\n           then Some (lhs r) else None)\n     (hta_lookup_f f H))\n\ngoal (1 subgoal):\n 1. {q. \\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n           r_matchc q f (map ls.\\<alpha> Qsc) r} =\n    ls.\\<alpha>\n     (ll_set_xy.g_image_filter\n       (\\<lambda>r.\n           case r of\n           q \\<rightarrow> f' qs \\<Rightarrow>\n             if list_all_zip (\\<lambda>Q q. ls.memb q Q) Qsc qs\n             then Some (lhs r) else None)\n       (hta_lookup_f f H))", "."], ["proof (state)\nthis:\n  {q. \\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n         r_matchc q f (map ls.\\<alpha> Qsc) r} =\n  ls.\\<alpha>\n   (ll_set_xy.g_image_filter\n     (\\<lambda>r.\n         case r of\n         q \\<rightarrow> f' qs \\<Rightarrow>\n           if list_all_zip (\\<lambda>Q q. ls.memb q Q) Qsc qs\n           then Some (lhs r) else None)\n     (hta_lookup_f f H))\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       map ls.\\<alpha> (map (faccs' H) x2) =\n       map (faccs (ls.\\<alpha> \\<delta>)) x2 \\<Longrightarrow>\n       ls.\\<alpha> (faccs' H (NODE x1 x2)) =\n       faccs (ls.\\<alpha> \\<delta>) (NODE x1 x2)\n 2. map ls.\\<alpha> (map (faccs' H) []) =\n    map (faccs (ls.\\<alpha> \\<delta>)) []\n 3. \\<And>x1 x2.\n       \\<lbrakk>ls.\\<alpha> (faccs' H x1) = faccs (ls.\\<alpha> \\<delta>) x1;\n        map ls.\\<alpha> (map (faccs' H) x2) =\n        map (faccs (ls.\\<alpha> \\<delta>)) x2\\<rbrakk>\n       \\<Longrightarrow> map ls.\\<alpha> (map (faccs' H) (x1 # x2)) =\n                         map (faccs (ls.\\<alpha> \\<delta>)) (x1 # x2)", "}"], ["proof (state)\nthis:\n  list_all ls.invar ?Qsc2 \\<Longrightarrow>\n  {q. \\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n         r_matchc q f (map ls.\\<alpha> ?Qsc2) r} =\n  ls.\\<alpha>\n   (ll_set_xy.g_image_filter\n     (\\<lambda>r.\n         case r of\n         q \\<rightarrow> f' qs \\<Rightarrow>\n           if list_all_zip (\\<lambda>Q q. ls.memb q Q) ?Qsc2 qs\n           then Some (lhs r) else None)\n     (hta_lookup_f f H))\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       map ls.\\<alpha> (map (faccs' H) x2) =\n       map (faccs (ls.\\<alpha> \\<delta>)) x2 \\<Longrightarrow>\n       ls.\\<alpha> (faccs' H (NODE x1 x2)) =\n       faccs (ls.\\<alpha> \\<delta>) (NODE x1 x2)\n 2. map ls.\\<alpha> (map (faccs' H) []) =\n    map (faccs (ls.\\<alpha> \\<delta>)) []\n 3. \\<And>x1 x2.\n       \\<lbrakk>ls.\\<alpha> (faccs' H x1) = faccs (ls.\\<alpha> \\<delta>) x1;\n        map ls.\\<alpha> (map (faccs' H) x2) =\n        map (faccs (ls.\\<alpha> \\<delta>)) x2\\<rbrakk>\n       \\<Longrightarrow> map ls.\\<alpha> (map (faccs' H) (x1 # x2)) =\n                         map (faccs (ls.\\<alpha> \\<delta>)) (x1 # x2)", "note 2=this"], ["proof (state)\nthis:\n  list_all ls.invar ?Qsc2 \\<Longrightarrow>\n  {q. \\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n         r_matchc q f (map ls.\\<alpha> ?Qsc2) r} =\n  ls.\\<alpha>\n   (ll_set_xy.g_image_filter\n     (\\<lambda>r.\n         case r of\n         q \\<rightarrow> f' qs \\<Rightarrow>\n           if list_all_zip (\\<lambda>Q q. ls.memb q Q) ?Qsc2 qs\n           then Some (lhs r) else None)\n     (hta_lookup_f f H))\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       map ls.\\<alpha> (map (faccs' H) x2) =\n       map (faccs (ls.\\<alpha> \\<delta>)) x2 \\<Longrightarrow>\n       ls.\\<alpha> (faccs' H (NODE x1 x2)) =\n       faccs (ls.\\<alpha> \\<delta>) (NODE x1 x2)\n 2. map ls.\\<alpha> (map (faccs' H) []) =\n    map (faccs (ls.\\<alpha> \\<delta>)) []\n 3. \\<And>x1 x2.\n       \\<lbrakk>ls.\\<alpha> (faccs' H x1) = faccs (ls.\\<alpha> \\<delta>) x1;\n        map ls.\\<alpha> (map (faccs' H) x2) =\n        map (faccs (ls.\\<alpha> \\<delta>)) x2\\<rbrakk>\n       \\<Longrightarrow> map ls.\\<alpha> (map (faccs' H) (x1 # x2)) =\n                         map (faccs (ls.\\<alpha> \\<delta>)) (x1 # x2)", "from \n        1 \n        2[ where Qsc2 = \"(List.map (faccs' H) ts)\", \n           simplified faccs'_invar[OF HI]]"], ["proof (chain)\npicking this:\n  faccs (ls.\\<alpha> \\<delta>) (NODE f ts) =\n  (let Qs = map ls.\\<alpha> (map (faccs' H) ts)\n   in {q. \\<exists>r\\<in>ls.\\<alpha> \\<delta>. r_matchc q f Qs r})\n  True \\<Longrightarrow>\n  {q. \\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n         r_matchc q f (map ls.\\<alpha> (map (faccs' H) ts)) r} =\n  ls.\\<alpha>\n   (ll_set_xy.g_image_filter\n     (\\<lambda>r.\n         case r of\n         q \\<rightarrow> f' qs \\<Rightarrow>\n           if list_all_zip (\\<lambda>Q q. ls.memb q Q) (map (faccs' H) ts)\n               qs\n           then Some (lhs r) else None)\n     (hta_lookup_f f H))", "show ?case"], ["proof (prove)\nusing this:\n  faccs (ls.\\<alpha> \\<delta>) (NODE f ts) =\n  (let Qs = map ls.\\<alpha> (map (faccs' H) ts)\n   in {q. \\<exists>r\\<in>ls.\\<alpha> \\<delta>. r_matchc q f Qs r})\n  True \\<Longrightarrow>\n  {q. \\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n         r_matchc q f (map ls.\\<alpha> (map (faccs' H) ts)) r} =\n  ls.\\<alpha>\n   (ll_set_xy.g_image_filter\n     (\\<lambda>r.\n         case r of\n         q \\<rightarrow> f' qs \\<Rightarrow>\n           if list_all_zip (\\<lambda>Q q. ls.memb q Q) (map (faccs' H) ts)\n               qs\n           then Some (lhs r) else None)\n     (hta_lookup_f f H))\n\ngoal (1 subgoal):\n 1. ls.\\<alpha> (faccs' H (NODE f ts)) =\n    faccs (ls.\\<alpha> \\<delta>) (NODE f ts)", "by simp"], ["proof (state)\nthis:\n  ls.\\<alpha> (faccs' H (NODE f ts)) =\n  faccs (ls.\\<alpha> \\<delta>) (NODE f ts)\n\ngoal (2 subgoals):\n 1. map ls.\\<alpha> (map (faccs' H) []) =\n    map (faccs (ls.\\<alpha> \\<delta>)) []\n 2. \\<And>x1 x2.\n       \\<lbrakk>ls.\\<alpha> (faccs' H x1) = faccs (ls.\\<alpha> \\<delta>) x1;\n        map ls.\\<alpha> (map (faccs' H) x2) =\n        map (faccs (ls.\\<alpha> \\<delta>)) x2\\<rbrakk>\n       \\<Longrightarrow> map ls.\\<alpha> (map (faccs' H) (x1 # x2)) =\n                         map (faccs (ls.\\<alpha> \\<delta>)) (x1 # x2)", "qed simp_all"], ["proof (state)\nthis:\n  ls.\\<alpha> (faccs' H t) = faccs (ls.\\<alpha> \\<delta>) t \\<and>\n  map ls.\\<alpha> (map (faccs' H) ts) =\n  map (faccs (ls.\\<alpha> \\<delta>)) ts\n\ngoal (2 subgoals):\n 1. ls.\\<alpha> (faccs' H t) = faccs (ls.\\<alpha> \\<delta>) t\n 2. map ls.\\<alpha> (map (faccs' H) ts) =\n    map (faccs (ls.\\<alpha> \\<delta>)) ts", "thus ?T1 ?T2"], ["proof (prove)\nusing this:\n  ls.\\<alpha> (faccs' H t) = faccs (ls.\\<alpha> \\<delta>) t \\<and>\n  map ls.\\<alpha> (map (faccs' H) ts) =\n  map (faccs (ls.\\<alpha> \\<delta>)) ts\n\ngoal (1 subgoal):\n 1. ls.\\<alpha> (faccs' H t) = faccs (ls.\\<alpha> \\<delta>) t &&&\n    map ls.\\<alpha> (map (faccs' H) ts) =\n    map (faccs (ls.\\<alpha> \\<delta>)) ts", "by auto"], ["proof (state)\nthis:\n  ls.\\<alpha> (faccs' H t) = faccs (ls.\\<alpha> \\<delta>) t\n  map ls.\\<alpha> (map (faccs' H) ts) =\n  map (faccs (ls.\\<alpha> \\<delta>)) ts\n\ngoal:\nNo subgoals!", "qed\n\n    \\<comment> \\<open>Correctness of the algorithms for the word problem\\<close>"], ["", "lemma hta_mem'_correct: \n    \"hta_has_idx_f H \\<Longrightarrow> hta_mem' t H \\<longleftrightarrow> t\\<in>ta_lang (hta_\\<alpha> H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hta_has_idx_f H \\<Longrightarrow>\n    hta_mem' t H = (t \\<in> ta_lang (hta_\\<alpha> H))", "apply (unfold ta_lang_def hta_\\<alpha>_def hta_mem'_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hta_has_idx_f H \\<Longrightarrow>\n    (\\<not> lh_set_xx.g_disjoint (faccs' H t) Qi) =\n    (t \\<in> {t. \\<exists>q\\<in>ta_initial\n                                 \\<lparr>ta_initial = hs.\\<alpha> Qi,\n                                    ta_rules = ls.\\<alpha> \\<delta>\\<rparr>.\n                    accs\n                     (ta_rules\n                       \\<lparr>ta_initial = hs.\\<alpha> Qi,\n                          ta_rules = ls.\\<alpha> \\<delta>\\<rparr>)\n                     t q})", "apply (auto simp add: lh_set_xx.disjoint_correct faccs'_correct faccs_alt)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem hta_mem_correct: \"hta_mem t H \\<longleftrightarrow> t\\<in>ta_lang (hta_\\<alpha> H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hta_mem t H = (t \\<in> ta_lang (hta_\\<alpha> H))", "using hashedTa.hta_mem'_correct[OF hta_ensure_idx_f_correct, simplified]"], ["proof (prove)\nusing this:\n  hta_mem' ?t (hta_ensure_idx_f H) = (?t \\<in> ta_lang (hta_\\<alpha> H))\n\ngoal (1 subgoal):\n 1. hta_mem t H = (t \\<in> ta_lang (hta_\\<alpha> H))", "apply (unfold hta_mem_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        hta_mem' t (hta_ensure_idx_f H) =\n        (t \\<in> ta_lang (hta_\\<alpha> H))) \\<Longrightarrow>\n    hta_mem' t (hta_ensure_idx_f H) = (t \\<in> ta_lang (hta_\\<alpha> H))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsection \"Product Automaton and Intersection\""], ["", "subsubsection \"Brute Force Product Automaton\""], ["", "text \\<open>\n  In this section, an algorithm that computes the product \n  automaton without reduction is implemented. While the runtime is always\n  quadratic, this algorithm is very simple and the constant factors are \n  smaller than that of the version with integrated reduction.\n  Moreover, lazy languages like Haskell seem to profit from this algorithm.\n\\<close>"], ["", "definition \\<delta>_prod_h \n  :: \"('q1::hashable,'l::hashable) ta_rule ls \n      \\<Rightarrow> ('q2::hashable,'l) ta_rule ls \\<Rightarrow> ('q1\\<times>'q2,'l) ta_rule ls\" \n  where \"\\<delta>_prod_h \\<delta>1 \\<delta>2 == \n    lll_iflt_cp.inj_image_filter_cp (\\<lambda>(r1,r2). r_prod r1 r2) \n                (\\<lambda>(r1,r2). rhsl r1 = rhsl r2 \n                         \\<and> length (rhsq r1) = length (rhsq r2)) \n                \\<delta>1 \\<delta>2\""], ["", "lemma r_prod_inj: \n  \"\\<lbrakk> rhsl r1 = rhsl r2; length (rhsq r1) = length (rhsq r2); \n     rhsl r1' = rhsl r2'; length (rhsq r1') = length (rhsq r2'); \n     r_prod r1 r2 = r_prod r1' r2' \\<rbrakk> \\<Longrightarrow> r1=r1' \\<and> r2=r2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rhsl r1 = rhsl r2; length (rhsq r1) = length (rhsq r2);\n     rhsl r1' = rhsl r2'; length (rhsq r1') = length (rhsq r2');\n     r_prod r1 r2 = r_prod r1' r2'\\<rbrakk>\n    \\<Longrightarrow> r1 = r1' \\<and> r2 = r2'", "apply (cases r1, cases r2, cases r1', cases r2')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x1a x2a x3a x1b x2b x3b x1c x2c x3c.\n       \\<lbrakk>rhsl r1 = rhsl r2; length (rhsq r1) = length (rhsq r2);\n        rhsl r1' = rhsl r2'; length (rhsq r1') = length (rhsq r2');\n        r_prod r1 r2 = r_prod r1' r2'; r1 = x1 \\<rightarrow> x2 x3;\n        r2 = x1a \\<rightarrow> x2a x3a; r1' = x1b \\<rightarrow> x2b x3b;\n        r2' = x1c \\<rightarrow> x2c x3c\\<rbrakk>\n       \\<Longrightarrow> r1 = r1' \\<and> r2 = r2'", "apply (auto dest: zip_inj)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \\<delta>_prod_h_correct:\n  assumes INV[simp]: \"ls_invar \\<delta>1\" \"ls_invar \\<delta>2\"\n  shows \n    \"ls_\\<alpha> (\\<delta>_prod_h \\<delta>1 \\<delta>2) = \\<delta>_prod (ls_\\<alpha> \\<delta>1) (ls_\\<alpha> \\<delta>2)\"\n    \"ls_invar (\\<delta>_prod_h \\<delta>1 \\<delta>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ls.\\<alpha> (\\<delta>_prod_h \\<delta>1 \\<delta>2) =\n    \\<delta>_prod (ls.\\<alpha> \\<delta>1) (ls.\\<alpha> \\<delta>2) &&&\n    ls.invar (\\<delta>_prod_h \\<delta>1 \\<delta>2)", "apply (unfold \\<delta>_prod_def \\<delta>_prod_h_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ls.\\<alpha>\n     (lll_iflt_cp.inj_image_filter_cp (\\<lambda>(r1, r2). r_prod r1 r2)\n       (\\<lambda>(r1, r2).\n           rhsl r1 = rhsl r2 \\<and> length (rhsq r1) = length (rhsq r2))\n       \\<delta>1 \\<delta>2) =\n    {r_prod q1 \\<rightarrow> l qs1 q2 \\<rightarrow> l qs2 |q1 q2 l qs1 qs2.\n     length qs1 = length qs2 \\<and>\n     q1 \\<rightarrow> l qs1 \\<in> ls.\\<alpha> \\<delta>1 \\<and>\n     q2 \\<rightarrow> l qs2 \\<in> ls.\\<alpha> \\<delta>2}\n 2. ls.invar\n     (lll_iflt_cp.inj_image_filter_cp (\\<lambda>(r1, r2). r_prod r1 r2)\n       (\\<lambda>(r1, r2).\n           rhsl r1 = rhsl r2 \\<and> length (rhsq r1) = length (rhsq r2))\n       \\<delta>1 \\<delta>2)", "apply (subst lll_iflt_cp.inj_image_filter_cp_correct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. ls.invar \\<delta>1\n 2. ls.invar \\<delta>2\n 3. inj_on (\\<lambda>(x, y). r_prod x y)\n     {x \\<in> ls.\\<alpha> \\<delta>1 \\<times> ls.\\<alpha> \\<delta>2.\n      case x of\n      (r1, r2) \\<Rightarrow>\n        rhsl r1 = rhsl r2 \\<and> length (rhsq r1) = length (rhsq r2)}\n 4. {case (x, y) of (x, xa) \\<Rightarrow> r_prod x xa |x y.\n     (case (x, y) of\n      (r1, r2) \\<Rightarrow>\n        rhsl r1 = rhsl r2 \\<and> length (rhsq r1) = length (rhsq r2)) \\<and>\n     x \\<in> ls.\\<alpha> \\<delta>1 \\<and> y \\<in> ls.\\<alpha> \\<delta>2} =\n    {r_prod q1 \\<rightarrow> l qs1 q2 \\<rightarrow> l qs2 |q1 q2 l qs1 qs2.\n     length qs1 = length qs2 \\<and>\n     q1 \\<rightarrow> l qs1 \\<in> ls.\\<alpha> \\<delta>1 \\<and>\n     q2 \\<rightarrow> l qs2 \\<in> ls.\\<alpha> \\<delta>2}\n 5. ls.invar\n     (lll_iflt_cp.inj_image_filter_cp (\\<lambda>(r1, r2). r_prod r1 r2)\n       (\\<lambda>(r1, r2).\n           rhsl r1 = rhsl r2 \\<and> length (rhsq r1) = length (rhsq r2))\n       \\<delta>1 \\<delta>2)", "apply simp_all [2]"], ["proof (prove)\ngoal (3 subgoals):\n 1. inj_on (\\<lambda>(x, y). r_prod x y)\n     {x \\<in> ls.\\<alpha> \\<delta>1 \\<times> ls.\\<alpha> \\<delta>2.\n      case x of\n      (r1, r2) \\<Rightarrow>\n        rhsl r1 = rhsl r2 \\<and> length (rhsq r1) = length (rhsq r2)}\n 2. {case (x, y) of (x, xa) \\<Rightarrow> r_prod x xa |x y.\n     (case (x, y) of\n      (r1, r2) \\<Rightarrow>\n        rhsl r1 = rhsl r2 \\<and> length (rhsq r1) = length (rhsq r2)) \\<and>\n     x \\<in> ls.\\<alpha> \\<delta>1 \\<and> y \\<in> ls.\\<alpha> \\<delta>2} =\n    {r_prod q1 \\<rightarrow> l qs1 q2 \\<rightarrow> l qs2 |q1 q2 l qs1 qs2.\n     length qs1 = length qs2 \\<and>\n     q1 \\<rightarrow> l qs1 \\<in> ls.\\<alpha> \\<delta>1 \\<and>\n     q2 \\<rightarrow> l qs2 \\<in> ls.\\<alpha> \\<delta>2}\n 3. ls.invar\n     (lll_iflt_cp.inj_image_filter_cp (\\<lambda>(r1, r2). r_prod r1 r2)\n       (\\<lambda>(r1, r2).\n           rhsl r1 = rhsl r2 \\<and> length (rhsq r1) = length (rhsq r2))\n       \\<delta>1 \\<delta>2)", "using r_prod_inj"], ["proof (prove)\nusing this:\n  \\<lbrakk>rhsl ?r1.0 = rhsl ?r2.0;\n   length (rhsq ?r1.0) = length (rhsq ?r2.0); rhsl ?r1' = rhsl ?r2';\n   length (rhsq ?r1') = length (rhsq ?r2');\n   r_prod ?r1.0 ?r2.0 = r_prod ?r1' ?r2'\\<rbrakk>\n  \\<Longrightarrow> ?r1.0 = ?r1' \\<and> ?r2.0 = ?r2'\n\ngoal (3 subgoals):\n 1. inj_on (\\<lambda>(x, y). r_prod x y)\n     {x \\<in> ls.\\<alpha> \\<delta>1 \\<times> ls.\\<alpha> \\<delta>2.\n      case x of\n      (r1, r2) \\<Rightarrow>\n        rhsl r1 = rhsl r2 \\<and> length (rhsq r1) = length (rhsq r2)}\n 2. {case (x, y) of (x, xa) \\<Rightarrow> r_prod x xa |x y.\n     (case (x, y) of\n      (r1, r2) \\<Rightarrow>\n        rhsl r1 = rhsl r2 \\<and> length (rhsq r1) = length (rhsq r2)) \\<and>\n     x \\<in> ls.\\<alpha> \\<delta>1 \\<and> y \\<in> ls.\\<alpha> \\<delta>2} =\n    {r_prod q1 \\<rightarrow> l qs1 q2 \\<rightarrow> l qs2 |q1 q2 l qs1 qs2.\n     length qs1 = length qs2 \\<and>\n     q1 \\<rightarrow> l qs1 \\<in> ls.\\<alpha> \\<delta>1 \\<and>\n     q2 \\<rightarrow> l qs2 \\<in> ls.\\<alpha> \\<delta>2}\n 3. ls.invar\n     (lll_iflt_cp.inj_image_filter_cp (\\<lambda>(r1, r2). r_prod r1 r2)\n       (\\<lambda>(r1, r2).\n           rhsl r1 = rhsl r2 \\<and> length (rhsq r1) = length (rhsq r2))\n       \\<delta>1 \\<delta>2)", "apply (auto intro!: inj_onI) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. {case (x, y) of (x, xa) \\<Rightarrow> r_prod x xa |x y.\n     (case (x, y) of\n      (r1, r2) \\<Rightarrow>\n        rhsl r1 = rhsl r2 \\<and> length (rhsq r1) = length (rhsq r2)) \\<and>\n     x \\<in> ls.\\<alpha> \\<delta>1 \\<and> y \\<in> ls.\\<alpha> \\<delta>2} =\n    {r_prod q1 \\<rightarrow> l qs1 q2 \\<rightarrow> l qs2 |q1 q2 l qs1 qs2.\n     length qs1 = length qs2 \\<and>\n     q1 \\<rightarrow> l qs1 \\<in> ls.\\<alpha> \\<delta>1 \\<and>\n     q2 \\<rightarrow> l qs2 \\<in> ls.\\<alpha> \\<delta>2}\n 2. ls.invar\n     (lll_iflt_cp.inj_image_filter_cp (\\<lambda>(r1, r2). r_prod r1 r2)\n       (\\<lambda>(r1, r2).\n           rhsl r1 = rhsl r2 \\<and> length (rhsq r1) = length (rhsq r2))\n       \\<delta>1 \\<delta>2)", "apply auto []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>rhsl xa = rhsl y; length (rhsq xa) = length (rhsq y);\n        xa \\<in> ls.\\<alpha> \\<delta>1;\n        y \\<in> ls.\\<alpha> \\<delta>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q1 q2 l qs1 qs2.\n                            r_prod xa y =\n                            (q1, q2) \\<rightarrow> l zip qs1 qs2 \\<and>\n                            length qs1 = length qs2 \\<and>\n                            q1 \\<rightarrow> l qs1\n                            \\<in> ls.\\<alpha> \\<delta>1 \\<and>\n                            q2 \\<rightarrow> l qs2\n                            \\<in> ls.\\<alpha> \\<delta>2\n 2. \\<And>q1 q2 l qs1 qs2.\n       \\<lbrakk>length qs1 = length qs2;\n        q1 \\<rightarrow> l qs1 \\<in> ls.\\<alpha> \\<delta>1;\n        q2 \\<rightarrow> l qs2 \\<in> ls.\\<alpha> \\<delta>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y.\n                            (q1, q2) \\<rightarrow> l zip qs1 qs2 =\n                            r_prod x y \\<and>\n                            rhsl x = rhsl y \\<and>\n                            length (rhsq x) = length (rhsq y) \\<and>\n                            x \\<in> ls.\\<alpha> \\<delta>1 \\<and>\n                            y \\<in> ls.\\<alpha> \\<delta>2\n 3. ls.invar\n     (lll_iflt_cp.inj_image_filter_cp (\\<lambda>(r1, r2). r_prod r1 r2)\n       (\\<lambda>(r1, r2).\n           rhsl r1 = rhsl r2 \\<and> length (rhsq r1) = length (rhsq r2))\n       \\<delta>1 \\<delta>2)", "apply (case_tac xa, case_tac y, simp, blast)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q1 q2 l qs1 qs2.\n       \\<lbrakk>length qs1 = length qs2;\n        q1 \\<rightarrow> l qs1 \\<in> ls.\\<alpha> \\<delta>1;\n        q2 \\<rightarrow> l qs2 \\<in> ls.\\<alpha> \\<delta>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y.\n                            (q1, q2) \\<rightarrow> l zip qs1 qs2 =\n                            r_prod x y \\<and>\n                            rhsl x = rhsl y \\<and>\n                            length (rhsq x) = length (rhsq y) \\<and>\n                            x \\<in> ls.\\<alpha> \\<delta>1 \\<and>\n                            y \\<in> ls.\\<alpha> \\<delta>2\n 2. ls.invar\n     (lll_iflt_cp.inj_image_filter_cp (\\<lambda>(r1, r2). r_prod r1 r2)\n       (\\<lambda>(r1, r2).\n           rhsl r1 = rhsl r2 \\<and> length (rhsq r1) = length (rhsq r2))\n       \\<delta>1 \\<delta>2)", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. ls.invar\n     (lll_iflt_cp.inj_image_filter_cp (\\<lambda>(r1, r2). r_prod r1 r2)\n       (\\<lambda>(r1, r2).\n           rhsl r1 = rhsl r2 \\<and> length (rhsq r1) = length (rhsq r2))\n       \\<delta>1 \\<delta>2)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"hta_prodWR H1 H2 == \n  init_hta (hhh_cart.cart (hta_Qi H1) (hta_Qi H2)) (\\<delta>_prod_h (hta_\\<delta> H1) (hta_\\<delta> H2))\""], ["", "lemma hta_prodWR_correct_aux: \n  assumes A: \"hashedTa H1\" \"hashedTa H2\"\n  shows \n    \"hta_\\<alpha> (hta_prodWR H1 H2) = ta_prod (hta_\\<alpha> H1) (hta_\\<alpha> H2)\" (is ?T1)\n    \"hashedTa (hta_prodWR H1 H2)\" (is ?T2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hta_\\<alpha> (hta_prodWR H1 H2) =\n    ta_prod (hta_\\<alpha> H1) (hta_\\<alpha> H2) &&&\n    hashedTa (hta_prodWR H1 H2)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. hta_\\<alpha> (hta_prodWR H1 H2) =\n    ta_prod (hta_\\<alpha> H1) (hta_\\<alpha> H2)\n 2. hashedTa (hta_prodWR H1 H2)", "interpret a1: hashedTa H1 + a2: hashedTa H2"], ["proof (prove)\ngoal (1 subgoal):\n 1. hashedTa H1 &&& hashedTa H2", "using A"], ["proof (prove)\nusing this:\n  hashedTa H1\n  hashedTa H2\n\ngoal (1 subgoal):\n 1. hashedTa H1 &&& hashedTa H2", "."], ["proof (state)\ngoal (2 subgoals):\n 1. hta_\\<alpha> (hta_prodWR H1 H2) =\n    ta_prod (hta_\\<alpha> H1) (hta_\\<alpha> H2)\n 2. hashedTa (hta_prodWR H1 H2)", "show ?T1 ?T2"], ["proof (prove)\ngoal (1 subgoal):\n 1. hta_\\<alpha> (hta_prodWR H1 H2) =\n    ta_prod (hta_\\<alpha> H1) (hta_\\<alpha> H2) &&&\n    hashedTa (hta_prodWR H1 H2)", "apply (unfold hta_prodWR_def init_hta_def hta_\\<alpha>_def ta_prod_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lparr>ta_initial =\n              hs.\\<alpha>\n               (hta_Qi\n                 \\<lparr>hta_Qi = hhh_cart.cart a1.Qi a2.Qi,\n                    hta_\\<delta> = \\<delta>_prod_h a1.\\<delta> a2.\\<delta>,\n                    hta_idx_f = None, hta_idx_s = None,\n                    hta_idx_sf = None\\<rparr>),\n       ta_rules =\n         ls.\\<alpha>\n          (hta_\\<delta>\n            \\<lparr>hta_Qi = hhh_cart.cart a1.Qi a2.Qi,\n               hta_\\<delta> = \\<delta>_prod_h a1.\\<delta> a2.\\<delta>,\n               hta_idx_f = None, hta_idx_s = None,\n               hta_idx_sf = None\\<rparr>)\\<rparr> =\n    \\<lparr>ta_initial =\n              ta_initial\n               \\<lparr>ta_initial = hs.\\<alpha> a1.Qi,\n                  ta_rules = ls.\\<alpha> a1.\\<delta>\\<rparr> \\<times>\n              ta_initial\n               \\<lparr>ta_initial = hs.\\<alpha> a2.Qi,\n                  ta_rules = ls.\\<alpha> a2.\\<delta>\\<rparr>,\n       ta_rules =\n         \\<delta>_prod\n          (ta_rules\n            \\<lparr>ta_initial = hs.\\<alpha> a1.Qi,\n               ta_rules = ls.\\<alpha> a1.\\<delta>\\<rparr>)\n          (ta_rules\n            \\<lparr>ta_initial = hs.\\<alpha> a2.Qi,\n               ta_rules = ls.\\<alpha> a2.\\<delta>\\<rparr>)\\<rparr>\n 2. hashedTa\n     \\<lparr>hta_Qi = hhh_cart.cart a1.Qi a2.Qi,\n        hta_\\<delta> = \\<delta>_prod_h a1.\\<delta> a2.\\<delta>,\n        hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr>", "apply (simp add: hhh_cart.cart_correct \\<delta>_prod_h_correct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hashedTa\n     \\<lparr>hta_Qi = hhh_cart.cart a1.Qi a2.Qi,\n        hta_\\<delta> = \\<delta>_prod_h a1.\\<delta> a2.\\<delta>,\n        hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr>", "apply (unfold_locales)"], ["proof (prove)\ngoal (5 subgoals):\n 1. hs.invar\n     (hta_Qi\n       \\<lparr>hta_Qi = hhh_cart.cart a1.Qi a2.Qi,\n          hta_\\<delta> = \\<delta>_prod_h a1.\\<delta> a2.\\<delta>,\n          hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr>)\n 2. ls.invar\n     (hta_\\<delta>\n       \\<lparr>hta_Qi = hhh_cart.cart a1.Qi a2.Qi,\n          hta_\\<delta> = \\<delta>_prod_h a1.\\<delta> a2.\\<delta>,\n          hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr>)\n 3. \\<And>idx_f.\n       hta_idx_f\n        \\<lparr>hta_Qi = hhh_cart.cart a1.Qi a2.Qi,\n           hta_\\<delta> = \\<delta>_prod_h a1.\\<delta> a2.\\<delta>,\n           hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr> =\n       Some idx_f \\<Longrightarrow>\n       hll_idx.is_index rhsl\n        (ls.\\<alpha>\n          (hta_\\<delta>\n            \\<lparr>hta_Qi = hhh_cart.cart a1.Qi a2.Qi,\n               hta_\\<delta> = \\<delta>_prod_h a1.\\<delta> a2.\\<delta>,\n               hta_idx_f = None, hta_idx_s = None,\n               hta_idx_sf = None\\<rparr>))\n        idx_f\n 4. \\<And>idx_s.\n       hta_idx_s\n        \\<lparr>hta_Qi = hhh_cart.cart a1.Qi a2.Qi,\n           hta_\\<delta> = \\<delta>_prod_h a1.\\<delta> a2.\\<delta>,\n           hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr> =\n       Some idx_s \\<Longrightarrow>\n       hll_idx.is_index lhs\n        (ls.\\<alpha>\n          (hta_\\<delta>\n            \\<lparr>hta_Qi = hhh_cart.cart a1.Qi a2.Qi,\n               hta_\\<delta> = \\<delta>_prod_h a1.\\<delta> a2.\\<delta>,\n               hta_idx_f = None, hta_idx_s = None,\n               hta_idx_sf = None\\<rparr>))\n        idx_s\n 5. \\<And>idx_sf.\n       hta_idx_sf\n        \\<lparr>hta_Qi = hhh_cart.cart a1.Qi a2.Qi,\n           hta_\\<delta> = \\<delta>_prod_h a1.\\<delta> a2.\\<delta>,\n           hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr> =\n       Some idx_sf \\<Longrightarrow>\n       hll_idx.is_index (\\<lambda>r. (lhs r, rhsl r))\n        (ls.\\<alpha>\n          (hta_\\<delta>\n            \\<lparr>hta_Qi = hhh_cart.cart a1.Qi a2.Qi,\n               hta_\\<delta> = \\<delta>_prod_h a1.\\<delta> a2.\\<delta>,\n               hta_idx_f = None, hta_idx_s = None,\n               hta_idx_sf = None\\<rparr>))\n        idx_sf", "apply (simp_all add: hhh_cart.cart_correct \\<delta>_prod_h_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  hta_\\<alpha> (hta_prodWR H1 H2) =\n  ta_prod (hta_\\<alpha> H1) (hta_\\<alpha> H2)\n  hashedTa (hta_prodWR H1 H2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hta_prodWR_correct:\n  assumes TA: \"hashedTa H1\" \"hashedTa H2\"\n  shows \n    \"ta_lang (hta_\\<alpha> (hta_prodWR H1 H2)) \n     = ta_lang (hta_\\<alpha> H1) \\<inter> ta_lang (hta_\\<alpha> H2)\"\n    \"hashedTa (hta_prodWR H1 H2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_lang (hta_\\<alpha> (hta_prodWR H1 H2)) =\n    ta_lang (hta_\\<alpha> H1) \\<inter> ta_lang (hta_\\<alpha> H2) &&&\n    hashedTa (hta_prodWR H1 H2)", "by (simp_all add: hta_prodWR_correct_aux[OF TA] ta_prod_correct_aux1)"], ["", "subsubsection \"Product Automaton with Forward-Reduction\""], ["", "text \\<open>\n  A more elaborated algorithm combines forward-reduction and the product \n  construction, i.e. product rules are only created ,,by need''.\n\\<close>\n\n  \\<comment> \\<open>State of the product-automaton DFS-algorithm\\<close>"], ["", "type_synonym ('q1,'q2,'l) pa_state \n  = \"('q1\\<times>'q2) hs \\<times> ('q1\\<times>'q2) list \\<times> ('q1\\<times>'q2,'l) ta_rule ls\"\n\n  \\<comment> \\<open>Abstraction mapping to algorithm specified in \n  Section~\\ref{sec:absalgo}.\\<close>"], ["", "definition pa_\\<alpha> \n  :: \"('q1::hashable,'q2::hashable,'l::hashable) pa_state \n      \\<Rightarrow> ('q1,'q2,'l) frp_state\"\n  where \"pa_\\<alpha> S == let (Q,W,\\<delta>d)=S in (hs_\\<alpha> Q,W,ls_\\<alpha> \\<delta>d)\""], ["", "definition pa_cond \n  :: \"('q1::hashable,'q2::hashable,'l::hashable) pa_state \\<Rightarrow> bool\" \n  where \"pa_cond S == let (Q,W,\\<delta>d) = S in W\\<noteq>[]\"\n\n  \\<comment> \\<open>Adds all successor states to the set of discovered states and to the \n  worklist\\<close>"], ["", "fun pa_upd_rule \n  :: \"('q1\\<times>'q2) hs \\<Rightarrow> ('q1\\<times>'q2) list \n      \\<Rightarrow> (('q1::hashable)\\<times>('q2::hashable)) list \n      \\<Rightarrow> (('q1\\<times>'q2) hs \\<times> ('q1\\<times>'q2) list)\" \n  where\n  \"pa_upd_rule Q W [] = (Q,W)\" |\n  \"pa_upd_rule Q W (qp#qs) = (\n    if \\<not> hs_memb qp Q then\n      pa_upd_rule (hs_ins qp Q) (qp#W) qs\n    else pa_upd_rule Q W qs\n  )\""], ["", "definition pa_step \n  :: \"('q1::hashable,'l::hashable) hashedTa \n      \\<Rightarrow> ('q2::hashable,'l) hashedTa \n      \\<Rightarrow> ('q1,'q2,'l) pa_state \\<Rightarrow> ('q1,'q2,'l) pa_state\"\n  where \"pa_step H1 H2 S == let \n    (Q,W,\\<delta>d)=S;\n    (q1,q2)=hd W\n  in  \n    ls_iteratei (hta_lookup_s q1 H1) (\\<lambda>_. True) (\\<lambda>r1 res. \n      ls_iteratei (hta_lookup_sf q2 (rhsl r1) H2) (\\<lambda>_. True) (\\<lambda>r2 res.\n        if (length (rhsq r1) = length (rhsq r2)) then\n          let \n            rp=r_prod r1 r2;\n            (Q,W,\\<delta>d) = res;\n            (Q',W') = pa_upd_rule Q W (rhsq rp)\n          in\n            (Q',W',ls_ins_dj rp \\<delta>d)\n        else\n          res\n      ) res\n    ) (Q,tl W,\\<delta>d)\n  \""], ["", "definition pa_initial \n  :: \"('q1::hashable,'l::hashable) hashedTa \n      \\<Rightarrow> ('q2::hashable,'l) hashedTa \n      \\<Rightarrow> ('q1,'q2,'l) pa_state\"\nwhere \"pa_initial H1 H2 == \n  let Qip = hhh_cart.cart (hta_Qi H1) (hta_Qi H2) in (\n    Qip,\n    hs_to_list Qip,\n    ls_empty ()\n  )\""], ["", "definition pa_invar_add:: \n  \"('q1::hashable,'q2::hashable,'l::hashable) pa_state set\" \n  where \"pa_invar_add == { (Q,W,\\<delta>d). hs_invar Q \\<and> ls_invar \\<delta>d }\""], ["", "definition \"pa_invar H1 H2 == \n  pa_invar_add \\<inter> {s. (pa_\\<alpha> s) \\<in> frp_invar (hta_\\<alpha> H1) (hta_\\<alpha> H2)}\""], ["", "definition \"pa_det_algo H1 H2 \n  == \\<lparr> dwa_cond=pa_cond, \n       dwa_step = pa_step H1 H2, \n       dwa_initial = pa_initial H1 H2, \n       dwa_invar = pa_invar H1 H2 \\<rparr>\""], ["", "lemma pa_upd_rule_correct:\n  assumes INV[simp, intro!]: \"hs_invar Q\"\n  assumes FMT: \"pa_upd_rule Q W qs = (Q',W')\"\n  shows\n    \"hs_invar Q'\" (is ?T1)\n    \"hs_\\<alpha> Q' = hs_\\<alpha> Q \\<union> set qs\" (is ?T2)\n    \"\\<exists>Wn. distinct Wn \\<and> set Wn = set qs - hs_\\<alpha> Q \\<and> W'=Wn@W\" (is ?T3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hs.invar Q' &&&\n    hs.\\<alpha> Q' = hs.\\<alpha> Q \\<union> set qs &&&\n    \\<exists>Wn.\n       distinct Wn \\<and> set Wn = set qs - hs.\\<alpha> Q \\<and> W' = Wn @ W", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. hs.invar Q'\n 2. hs.\\<alpha> Q' = hs.\\<alpha> Q \\<union> set qs\n 3. \\<exists>Wn.\n       distinct Wn \\<and> set Wn = set qs - hs.\\<alpha> Q \\<and> W' = Wn @ W", "from INV FMT"], ["proof (chain)\npicking this:\n  hs.invar Q\n  pa_upd_rule Q W qs = (Q', W')", "have \"?T1 \\<and> ?T2 \\<and> ?T3\""], ["proof (prove)\nusing this:\n  hs.invar Q\n  pa_upd_rule Q W qs = (Q', W')\n\ngoal (1 subgoal):\n 1. hs.invar Q' \\<and>\n    hs.\\<alpha> Q' = hs.\\<alpha> Q \\<union> set qs \\<and>\n    (\\<exists>Wn.\n        distinct Wn \\<and>\n        set Wn = set qs - hs.\\<alpha> Q \\<and> W' = Wn @ W)", "proof (induct qs arbitrary: Q W Q' W')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Q W Q' W'.\n       \\<lbrakk>hs.invar Q; pa_upd_rule Q W [] = (Q', W')\\<rbrakk>\n       \\<Longrightarrow> hs.invar Q' \\<and>\n                         hs.\\<alpha> Q' =\n                         hs.\\<alpha> Q \\<union> set [] \\<and>\n                         (\\<exists>Wn.\n                             distinct Wn \\<and>\n                             set Wn = set [] - hs.\\<alpha> Q \\<and>\n                             W' = Wn @ W)\n 2. \\<And>a qs Q W Q' W'.\n       \\<lbrakk>\\<And>Q W Q' W'.\n                   \\<lbrakk>hs.invar Q;\n                    pa_upd_rule Q W qs = (Q', W')\\<rbrakk>\n                   \\<Longrightarrow> hs.invar Q' \\<and>\n                                     hs.\\<alpha> Q' =\n                                     hs.\\<alpha> Q \\<union> set qs \\<and>\n                                     (\\<exists>Wn.\n   distinct Wn \\<and> set Wn = set qs - hs.\\<alpha> Q \\<and> W' = Wn @ W);\n        hs.invar Q; pa_upd_rule Q W (a # qs) = (Q', W')\\<rbrakk>\n       \\<Longrightarrow> hs.invar Q' \\<and>\n                         hs.\\<alpha> Q' =\n                         hs.\\<alpha> Q \\<union> set (a # qs) \\<and>\n                         (\\<exists>Wn.\n                             distinct Wn \\<and>\n                             set Wn = set (a # qs) - hs.\\<alpha> Q \\<and>\n                             W' = Wn @ W)", "case Nil"], ["proof (state)\nthis:\n  hs.invar Q\n  pa_upd_rule Q W [] = (Q', W')\n\ngoal (2 subgoals):\n 1. \\<And>Q W Q' W'.\n       \\<lbrakk>hs.invar Q; pa_upd_rule Q W [] = (Q', W')\\<rbrakk>\n       \\<Longrightarrow> hs.invar Q' \\<and>\n                         hs.\\<alpha> Q' =\n                         hs.\\<alpha> Q \\<union> set [] \\<and>\n                         (\\<exists>Wn.\n                             distinct Wn \\<and>\n                             set Wn = set [] - hs.\\<alpha> Q \\<and>\n                             W' = Wn @ W)\n 2. \\<And>a qs Q W Q' W'.\n       \\<lbrakk>\\<And>Q W Q' W'.\n                   \\<lbrakk>hs.invar Q;\n                    pa_upd_rule Q W qs = (Q', W')\\<rbrakk>\n                   \\<Longrightarrow> hs.invar Q' \\<and>\n                                     hs.\\<alpha> Q' =\n                                     hs.\\<alpha> Q \\<union> set qs \\<and>\n                                     (\\<exists>Wn.\n   distinct Wn \\<and> set Wn = set qs - hs.\\<alpha> Q \\<and> W' = Wn @ W);\n        hs.invar Q; pa_upd_rule Q W (a # qs) = (Q', W')\\<rbrakk>\n       \\<Longrightarrow> hs.invar Q' \\<and>\n                         hs.\\<alpha> Q' =\n                         hs.\\<alpha> Q \\<union> set (a # qs) \\<and>\n                         (\\<exists>Wn.\n                             distinct Wn \\<and>\n                             set Wn = set (a # qs) - hs.\\<alpha> Q \\<and>\n                             W' = Wn @ W)", "thus ?case"], ["proof (prove)\nusing this:\n  hs.invar Q\n  pa_upd_rule Q W [] = (Q', W')\n\ngoal (1 subgoal):\n 1. hs.invar Q' \\<and>\n    hs.\\<alpha> Q' = hs.\\<alpha> Q \\<union> set [] \\<and>\n    (\\<exists>Wn.\n        distinct Wn \\<and>\n        set Wn = set [] - hs.\\<alpha> Q \\<and> W' = Wn @ W)", "by simp"], ["proof (state)\nthis:\n  hs.invar Q' \\<and>\n  hs.\\<alpha> Q' = hs.\\<alpha> Q \\<union> set [] \\<and>\n  (\\<exists>Wn.\n      distinct Wn \\<and> set Wn = set [] - hs.\\<alpha> Q \\<and> W' = Wn @ W)\n\ngoal (1 subgoal):\n 1. \\<And>a qs Q W Q' W'.\n       \\<lbrakk>\\<And>Q W Q' W'.\n                   \\<lbrakk>hs.invar Q;\n                    pa_upd_rule Q W qs = (Q', W')\\<rbrakk>\n                   \\<Longrightarrow> hs.invar Q' \\<and>\n                                     hs.\\<alpha> Q' =\n                                     hs.\\<alpha> Q \\<union> set qs \\<and>\n                                     (\\<exists>Wn.\n   distinct Wn \\<and> set Wn = set qs - hs.\\<alpha> Q \\<and> W' = Wn @ W);\n        hs.invar Q; pa_upd_rule Q W (a # qs) = (Q', W')\\<rbrakk>\n       \\<Longrightarrow> hs.invar Q' \\<and>\n                         hs.\\<alpha> Q' =\n                         hs.\\<alpha> Q \\<union> set (a # qs) \\<and>\n                         (\\<exists>Wn.\n                             distinct Wn \\<and>\n                             set Wn = set (a # qs) - hs.\\<alpha> Q \\<and>\n                             W' = Wn @ W)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a qs Q W Q' W'.\n       \\<lbrakk>\\<And>Q W Q' W'.\n                   \\<lbrakk>hs.invar Q;\n                    pa_upd_rule Q W qs = (Q', W')\\<rbrakk>\n                   \\<Longrightarrow> hs.invar Q' \\<and>\n                                     hs.\\<alpha> Q' =\n                                     hs.\\<alpha> Q \\<union> set qs \\<and>\n                                     (\\<exists>Wn.\n   distinct Wn \\<and> set Wn = set qs - hs.\\<alpha> Q \\<and> W' = Wn @ W);\n        hs.invar Q; pa_upd_rule Q W (a # qs) = (Q', W')\\<rbrakk>\n       \\<Longrightarrow> hs.invar Q' \\<and>\n                         hs.\\<alpha> Q' =\n                         hs.\\<alpha> Q \\<union> set (a # qs) \\<and>\n                         (\\<exists>Wn.\n                             distinct Wn \\<and>\n                             set Wn = set (a # qs) - hs.\\<alpha> Q \\<and>\n                             W' = Wn @ W)", "case (Cons q qs Q W Q' W')"], ["proof (state)\nthis:\n  \\<lbrakk>hs.invar ?Q; pa_upd_rule ?Q ?W qs = (?Q', ?W')\\<rbrakk>\n  \\<Longrightarrow> hs.invar ?Q' \\<and>\n                    hs.\\<alpha> ?Q' = hs.\\<alpha> ?Q \\<union> set qs \\<and>\n                    (\\<exists>Wn.\n                        distinct Wn \\<and>\n                        set Wn = set qs - hs.\\<alpha> ?Q \\<and>\n                        ?W' = Wn @ ?W)\n  hs.invar Q\n  pa_upd_rule Q W (q # qs) = (Q', W')\n\ngoal (1 subgoal):\n 1. \\<And>a qs Q W Q' W'.\n       \\<lbrakk>\\<And>Q W Q' W'.\n                   \\<lbrakk>hs.invar Q;\n                    pa_upd_rule Q W qs = (Q', W')\\<rbrakk>\n                   \\<Longrightarrow> hs.invar Q' \\<and>\n                                     hs.\\<alpha> Q' =\n                                     hs.\\<alpha> Q \\<union> set qs \\<and>\n                                     (\\<exists>Wn.\n   distinct Wn \\<and> set Wn = set qs - hs.\\<alpha> Q \\<and> W' = Wn @ W);\n        hs.invar Q; pa_upd_rule Q W (a # qs) = (Q', W')\\<rbrakk>\n       \\<Longrightarrow> hs.invar Q' \\<and>\n                         hs.\\<alpha> Q' =\n                         hs.\\<alpha> Q \\<union> set (a # qs) \\<and>\n                         (\\<exists>Wn.\n                             distinct Wn \\<and>\n                             set Wn = set (a # qs) - hs.\\<alpha> Q \\<and>\n                             W' = Wn @ W)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. hs.invar Q' \\<and>\n    hs.\\<alpha> Q' = hs.\\<alpha> Q \\<union> set (q # qs) \\<and>\n    (\\<exists>Wn.\n        distinct Wn \\<and>\n        set Wn = set (q # qs) - hs.\\<alpha> Q \\<and> W' = Wn @ W)", "proof (cases \"q\\<in>hs_\\<alpha> Q\")"], ["proof (state)\ngoal (2 subgoals):\n 1. q \\<in> hs.\\<alpha> Q \\<Longrightarrow>\n    hs.invar Q' \\<and>\n    hs.\\<alpha> Q' = hs.\\<alpha> Q \\<union> set (q # qs) \\<and>\n    (\\<exists>Wn.\n        distinct Wn \\<and>\n        set Wn = set (q # qs) - hs.\\<alpha> Q \\<and> W' = Wn @ W)\n 2. q \\<notin> hs.\\<alpha> Q \\<Longrightarrow>\n    hs.invar Q' \\<and>\n    hs.\\<alpha> Q' = hs.\\<alpha> Q \\<union> set (q # qs) \\<and>\n    (\\<exists>Wn.\n        distinct Wn \\<and>\n        set Wn = set (q # qs) - hs.\\<alpha> Q \\<and> W' = Wn @ W)", "case True"], ["proof (state)\nthis:\n  q \\<in> hs.\\<alpha> Q\n\ngoal (2 subgoals):\n 1. q \\<in> hs.\\<alpha> Q \\<Longrightarrow>\n    hs.invar Q' \\<and>\n    hs.\\<alpha> Q' = hs.\\<alpha> Q \\<union> set (q # qs) \\<and>\n    (\\<exists>Wn.\n        distinct Wn \\<and>\n        set Wn = set (q # qs) - hs.\\<alpha> Q \\<and> W' = Wn @ W)\n 2. q \\<notin> hs.\\<alpha> Q \\<Longrightarrow>\n    hs.invar Q' \\<and>\n    hs.\\<alpha> Q' = hs.\\<alpha> Q \\<union> set (q # qs) \\<and>\n    (\\<exists>Wn.\n        distinct Wn \\<and>\n        set Wn = set (q # qs) - hs.\\<alpha> Q \\<and> W' = Wn @ W)", "obtain Qh Wh where RF: \"pa_upd_rule Q W qs = (Qh,Wh)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Qh Wh.\n        pa_upd_rule Q W qs = (Qh, Wh) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  pa_upd_rule Q W qs = (Qh, Wh)\n\ngoal (2 subgoals):\n 1. q \\<in> hs.\\<alpha> Q \\<Longrightarrow>\n    hs.invar Q' \\<and>\n    hs.\\<alpha> Q' = hs.\\<alpha> Q \\<union> set (q # qs) \\<and>\n    (\\<exists>Wn.\n        distinct Wn \\<and>\n        set Wn = set (q # qs) - hs.\\<alpha> Q \\<and> W' = Wn @ W)\n 2. q \\<notin> hs.\\<alpha> Q \\<Longrightarrow>\n    hs.invar Q' \\<and>\n    hs.\\<alpha> Q' = hs.\\<alpha> Q \\<union> set (q # qs) \\<and>\n    (\\<exists>Wn.\n        distinct Wn \\<and>\n        set Wn = set (q # qs) - hs.\\<alpha> Q \\<and> W' = Wn @ W)", "with True Cons.prems"], ["proof (chain)\npicking this:\n  q \\<in> hs.\\<alpha> Q\n  hs.invar Q\n  pa_upd_rule Q W (q # qs) = (Q', W')\n  pa_upd_rule Q W qs = (Qh, Wh)", "have [simp]: \"Q'=Qh\" \"W'=Wh\""], ["proof (prove)\nusing this:\n  q \\<in> hs.\\<alpha> Q\n  hs.invar Q\n  pa_upd_rule Q W (q # qs) = (Q', W')\n  pa_upd_rule Q W qs = (Qh, Wh)\n\ngoal (1 subgoal):\n 1. Q' = Qh &&& W' = Wh", "by (auto simp add: hs.correct)"], ["proof (state)\nthis:\n  Q' = Qh\n  W' = Wh\n\ngoal (2 subgoals):\n 1. q \\<in> hs.\\<alpha> Q \\<Longrightarrow>\n    hs.invar Q' \\<and>\n    hs.\\<alpha> Q' = hs.\\<alpha> Q \\<union> set (q # qs) \\<and>\n    (\\<exists>Wn.\n        distinct Wn \\<and>\n        set Wn = set (q # qs) - hs.\\<alpha> Q \\<and> W' = Wn @ W)\n 2. q \\<notin> hs.\\<alpha> Q \\<Longrightarrow>\n    hs.invar Q' \\<and>\n    hs.\\<alpha> Q' = hs.\\<alpha> Q \\<union> set (q # qs) \\<and>\n    (\\<exists>Wn.\n        distinct Wn \\<and>\n        set Wn = set (q # qs) - hs.\\<alpha> Q \\<and> W' = Wn @ W)", "from Cons.hyps[OF Cons.prems(1) RF]"], ["proof (chain)\npicking this:\n  hs.invar Qh \\<and>\n  hs.\\<alpha> Qh = hs.\\<alpha> Q \\<union> set qs \\<and>\n  (\\<exists>Wn.\n      distinct Wn \\<and> set Wn = set qs - hs.\\<alpha> Q \\<and> Wh = Wn @ W)", "have\n        \"hs_invar Qh\" \n        \"hs_\\<alpha> Qh = hs_\\<alpha> Q \\<union> set qs\" \n        \"(\\<exists>Wn. distinct Wn \\<and> set Wn = set qs - hs_\\<alpha> Q \\<and> Wh = Wn @ W)\""], ["proof (prove)\nusing this:\n  hs.invar Qh \\<and>\n  hs.\\<alpha> Qh = hs.\\<alpha> Q \\<union> set qs \\<and>\n  (\\<exists>Wn.\n      distinct Wn \\<and> set Wn = set qs - hs.\\<alpha> Q \\<and> Wh = Wn @ W)\n\ngoal (1 subgoal):\n 1. hs.invar Qh &&&\n    hs.\\<alpha> Qh = hs.\\<alpha> Q \\<union> set qs &&&\n    \\<exists>Wn.\n       distinct Wn \\<and> set Wn = set qs - hs.\\<alpha> Q \\<and> Wh = Wn @ W", "by auto"], ["proof (state)\nthis:\n  hs.invar Qh\n  hs.\\<alpha> Qh = hs.\\<alpha> Q \\<union> set qs\n  \\<exists>Wn.\n     distinct Wn \\<and> set Wn = set qs - hs.\\<alpha> Q \\<and> Wh = Wn @ W\n\ngoal (2 subgoals):\n 1. q \\<in> hs.\\<alpha> Q \\<Longrightarrow>\n    hs.invar Q' \\<and>\n    hs.\\<alpha> Q' = hs.\\<alpha> Q \\<union> set (q # qs) \\<and>\n    (\\<exists>Wn.\n        distinct Wn \\<and>\n        set Wn = set (q # qs) - hs.\\<alpha> Q \\<and> W' = Wn @ W)\n 2. q \\<notin> hs.\\<alpha> Q \\<Longrightarrow>\n    hs.invar Q' \\<and>\n    hs.\\<alpha> Q' = hs.\\<alpha> Q \\<union> set (q # qs) \\<and>\n    (\\<exists>Wn.\n        distinct Wn \\<and>\n        set Wn = set (q # qs) - hs.\\<alpha> Q \\<and> W' = Wn @ W)", "thus ?thesis"], ["proof (prove)\nusing this:\n  hs.invar Qh\n  hs.\\<alpha> Qh = hs.\\<alpha> Q \\<union> set qs\n  \\<exists>Wn.\n     distinct Wn \\<and> set Wn = set qs - hs.\\<alpha> Q \\<and> Wh = Wn @ W\n\ngoal (1 subgoal):\n 1. hs.invar Q' \\<and>\n    hs.\\<alpha> Q' = hs.\\<alpha> Q \\<union> set (q # qs) \\<and>\n    (\\<exists>Wn.\n        distinct Wn \\<and>\n        set Wn = set (q # qs) - hs.\\<alpha> Q \\<and> W' = Wn @ W)", "using True"], ["proof (prove)\nusing this:\n  hs.invar Qh\n  hs.\\<alpha> Qh = hs.\\<alpha> Q \\<union> set qs\n  \\<exists>Wn.\n     distinct Wn \\<and> set Wn = set qs - hs.\\<alpha> Q \\<and> Wh = Wn @ W\n  q \\<in> hs.\\<alpha> Q\n\ngoal (1 subgoal):\n 1. hs.invar Q' \\<and>\n    hs.\\<alpha> Q' = hs.\\<alpha> Q \\<union> set (q # qs) \\<and>\n    (\\<exists>Wn.\n        distinct Wn \\<and>\n        set Wn = set (q # qs) - hs.\\<alpha> Q \\<and> W' = Wn @ W)", "by auto"], ["proof (state)\nthis:\n  hs.invar Q' \\<and>\n  hs.\\<alpha> Q' = hs.\\<alpha> Q \\<union> set (q # qs) \\<and>\n  (\\<exists>Wn.\n      distinct Wn \\<and>\n      set Wn = set (q # qs) - hs.\\<alpha> Q \\<and> W' = Wn @ W)\n\ngoal (1 subgoal):\n 1. q \\<notin> hs.\\<alpha> Q \\<Longrightarrow>\n    hs.invar Q' \\<and>\n    hs.\\<alpha> Q' = hs.\\<alpha> Q \\<union> set (q # qs) \\<and>\n    (\\<exists>Wn.\n        distinct Wn \\<and>\n        set Wn = set (q # qs) - hs.\\<alpha> Q \\<and> W' = Wn @ W)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<notin> hs.\\<alpha> Q \\<Longrightarrow>\n    hs.invar Q' \\<and>\n    hs.\\<alpha> Q' = hs.\\<alpha> Q \\<union> set (q # qs) \\<and>\n    (\\<exists>Wn.\n        distinct Wn \\<and>\n        set Wn = set (q # qs) - hs.\\<alpha> Q \\<and> W' = Wn @ W)", "case False"], ["proof (state)\nthis:\n  q \\<notin> hs.\\<alpha> Q\n\ngoal (1 subgoal):\n 1. q \\<notin> hs.\\<alpha> Q \\<Longrightarrow>\n    hs.invar Q' \\<and>\n    hs.\\<alpha> Q' = hs.\\<alpha> Q \\<union> set (q # qs) \\<and>\n    (\\<exists>Wn.\n        distinct Wn \\<and>\n        set Wn = set (q # qs) - hs.\\<alpha> Q \\<and> W' = Wn @ W)", "with Cons.prems"], ["proof (chain)\npicking this:\n  hs.invar Q\n  pa_upd_rule Q W (q # qs) = (Q', W')\n  q \\<notin> hs.\\<alpha> Q", "have RF: \"pa_upd_rule (hs_ins q Q) (q#W) qs = (Q',W')\""], ["proof (prove)\nusing this:\n  hs.invar Q\n  pa_upd_rule Q W (q # qs) = (Q', W')\n  q \\<notin> hs.\\<alpha> Q\n\ngoal (1 subgoal):\n 1. pa_upd_rule (hs.ins q Q) (q # W) qs = (Q', W')", "by (auto simp add: hs.correct)"], ["proof (state)\nthis:\n  pa_upd_rule (hs.ins q Q) (q # W) qs = (Q', W')\n\ngoal (1 subgoal):\n 1. q \\<notin> hs.\\<alpha> Q \\<Longrightarrow>\n    hs.invar Q' \\<and>\n    hs.\\<alpha> Q' = hs.\\<alpha> Q \\<union> set (q # qs) \\<and>\n    (\\<exists>Wn.\n        distinct Wn \\<and>\n        set Wn = set (q # qs) - hs.\\<alpha> Q \\<and> W' = Wn @ W)", "from Cons.hyps[OF _ RF] Cons.prems(1)"], ["proof (chain)\npicking this:\n  hs.invar (hs.ins q Q) \\<Longrightarrow>\n  hs.invar Q' \\<and>\n  hs.\\<alpha> Q' = hs.\\<alpha> (hs.ins q Q) \\<union> set qs \\<and>\n  (\\<exists>Wn.\n      distinct Wn \\<and>\n      set Wn = set qs - hs.\\<alpha> (hs.ins q Q) \\<and> W' = Wn @ q # W)\n  hs.invar Q", "have\n        \"hs_invar Q'\" \n        \"hs_\\<alpha> Q' = insert q (hs_\\<alpha> Q) \\<union> set (qs)\"\n        \"\\<exists>Wn. distinct Wn \n              \\<and> set Wn = set qs - insert q (hs_\\<alpha> Q) \n              \\<and> W' = Wn @ q # W\""], ["proof (prove)\nusing this:\n  hs.invar (hs.ins q Q) \\<Longrightarrow>\n  hs.invar Q' \\<and>\n  hs.\\<alpha> Q' = hs.\\<alpha> (hs.ins q Q) \\<union> set qs \\<and>\n  (\\<exists>Wn.\n      distinct Wn \\<and>\n      set Wn = set qs - hs.\\<alpha> (hs.ins q Q) \\<and> W' = Wn @ q # W)\n  hs.invar Q\n\ngoal (1 subgoal):\n 1. hs.invar Q' &&&\n    hs.\\<alpha> Q' = insert q (hs.\\<alpha> Q) \\<union> set qs &&&\n    \\<exists>Wn.\n       distinct Wn \\<and>\n       set Wn = set qs - insert q (hs.\\<alpha> Q) \\<and> W' = Wn @ q # W", "by (auto simp add: hs.correct)"], ["proof (state)\nthis:\n  hs.invar Q'\n  hs.\\<alpha> Q' = insert q (hs.\\<alpha> Q) \\<union> set qs\n  \\<exists>Wn.\n     distinct Wn \\<and>\n     set Wn = set qs - insert q (hs.\\<alpha> Q) \\<and> W' = Wn @ q # W\n\ngoal (1 subgoal):\n 1. q \\<notin> hs.\\<alpha> Q \\<Longrightarrow>\n    hs.invar Q' \\<and>\n    hs.\\<alpha> Q' = hs.\\<alpha> Q \\<union> set (q # qs) \\<and>\n    (\\<exists>Wn.\n        distinct Wn \\<and>\n        set Wn = set (q # qs) - hs.\\<alpha> Q \\<and> W' = Wn @ W)", "thus ?thesis"], ["proof (prove)\nusing this:\n  hs.invar Q'\n  hs.\\<alpha> Q' = insert q (hs.\\<alpha> Q) \\<union> set qs\n  \\<exists>Wn.\n     distinct Wn \\<and>\n     set Wn = set qs - insert q (hs.\\<alpha> Q) \\<and> W' = Wn @ q # W\n\ngoal (1 subgoal):\n 1. hs.invar Q' \\<and>\n    hs.\\<alpha> Q' = hs.\\<alpha> Q \\<union> set (q # qs) \\<and>\n    (\\<exists>Wn.\n        distinct Wn \\<and>\n        set Wn = set (q # qs) - hs.\\<alpha> Q \\<and> W' = Wn @ W)", "using False"], ["proof (prove)\nusing this:\n  hs.invar Q'\n  hs.\\<alpha> Q' = insert q (hs.\\<alpha> Q) \\<union> set qs\n  \\<exists>Wn.\n     distinct Wn \\<and>\n     set Wn = set qs - insert q (hs.\\<alpha> Q) \\<and> W' = Wn @ q # W\n  q \\<notin> hs.\\<alpha> Q\n\ngoal (1 subgoal):\n 1. hs.invar Q' \\<and>\n    hs.\\<alpha> Q' = hs.\\<alpha> Q \\<union> set (q # qs) \\<and>\n    (\\<exists>Wn.\n        distinct Wn \\<and>\n        set Wn = set (q # qs) - hs.\\<alpha> Q \\<and> W' = Wn @ W)", "by auto"], ["proof (state)\nthis:\n  hs.invar Q' \\<and>\n  hs.\\<alpha> Q' = hs.\\<alpha> Q \\<union> set (q # qs) \\<and>\n  (\\<exists>Wn.\n      distinct Wn \\<and>\n      set Wn = set (q # qs) - hs.\\<alpha> Q \\<and> W' = Wn @ W)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hs.invar Q' \\<and>\n  hs.\\<alpha> Q' = hs.\\<alpha> Q \\<union> set (q # qs) \\<and>\n  (\\<exists>Wn.\n      distinct Wn \\<and>\n      set Wn = set (q # qs) - hs.\\<alpha> Q \\<and> W' = Wn @ W)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hs.invar Q' \\<and>\n  hs.\\<alpha> Q' = hs.\\<alpha> Q \\<union> set qs \\<and>\n  (\\<exists>Wn.\n      distinct Wn \\<and> set Wn = set qs - hs.\\<alpha> Q \\<and> W' = Wn @ W)\n\ngoal (3 subgoals):\n 1. hs.invar Q'\n 2. hs.\\<alpha> Q' = hs.\\<alpha> Q \\<union> set qs\n 3. \\<exists>Wn.\n       distinct Wn \\<and> set Wn = set qs - hs.\\<alpha> Q \\<and> W' = Wn @ W", "thus ?T1 ?T2 ?T3"], ["proof (prove)\nusing this:\n  hs.invar Q' \\<and>\n  hs.\\<alpha> Q' = hs.\\<alpha> Q \\<union> set qs \\<and>\n  (\\<exists>Wn.\n      distinct Wn \\<and> set Wn = set qs - hs.\\<alpha> Q \\<and> W' = Wn @ W)\n\ngoal (1 subgoal):\n 1. hs.invar Q' &&&\n    hs.\\<alpha> Q' = hs.\\<alpha> Q \\<union> set qs &&&\n    \\<exists>Wn.\n       distinct Wn \\<and> set Wn = set qs - hs.\\<alpha> Q \\<and> W' = Wn @ W", "by auto"], ["proof (state)\nthis:\n  hs.invar Q'\n  hs.\\<alpha> Q' = hs.\\<alpha> Q \\<union> set qs\n  \\<exists>Wn.\n     distinct Wn \\<and> set Wn = set qs - hs.\\<alpha> Q \\<and> W' = Wn @ W\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pa_step_correct:\n  assumes TA: \"hashedTa H1\" \"hashedTa H2\"\n  assumes idx[simp]: \"hta_has_idx_s H1\" \"hta_has_idx_sf H2\"\n  assumes INV: \"(Q,W,\\<delta>d)\\<in>pa_invar H1 H2\"\n  assumes COND: \"pa_cond (Q,W,\\<delta>d)\"\n  shows \n    \"(pa_step H1 H2 (Q,W,\\<delta>d))\\<in>pa_invar_add\" (is ?T1)\n    \"(pa_\\<alpha> (Q,W,\\<delta>d), pa_\\<alpha> (pa_step H1 H2 (Q,W,\\<delta>d))) \n     \\<in> frp_step (ls_\\<alpha> (hta_\\<delta> H1)) (ls_\\<alpha> (hta_\\<delta> H2))\" (is ?T2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. pa_step H1 H2 (Q, W, \\<delta>d) \\<in> pa_invar_add &&&\n    (pa_\\<alpha> (Q, W, \\<delta>d),\n     pa_\\<alpha> (pa_step H1 H2 (Q, W, \\<delta>d)))\n    \\<in> frp_step (ls.\\<alpha> (hta_\\<delta> H1))\n           (ls.\\<alpha> (hta_\\<delta> H2))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. pa_step H1 H2 (Q, W, \\<delta>d) \\<in> pa_invar_add\n 2. (pa_\\<alpha> (Q, W, \\<delta>d),\n     pa_\\<alpha> (pa_step H1 H2 (Q, W, \\<delta>d)))\n    \\<in> frp_step (ls.\\<alpha> (hta_\\<delta> H1))\n           (ls.\\<alpha> (hta_\\<delta> H2))", "interpret h1: hashedTa H1"], ["proof (prove)\ngoal (1 subgoal):\n 1. hashedTa H1", "by fact"], ["proof (state)\ngoal (2 subgoals):\n 1. pa_step H1 H2 (Q, W, \\<delta>d) \\<in> pa_invar_add\n 2. (pa_\\<alpha> (Q, W, \\<delta>d),\n     pa_\\<alpha> (pa_step H1 H2 (Q, W, \\<delta>d)))\n    \\<in> frp_step (ls.\\<alpha> h1.\\<delta>) (ls.\\<alpha> (hta_\\<delta> H2))", "interpret h2: hashedTa H2"], ["proof (prove)\ngoal (1 subgoal):\n 1. hashedTa H2", "by fact"], ["proof (state)\ngoal (2 subgoals):\n 1. pa_step H1 H2 (Q, W, \\<delta>d) \\<in> pa_invar_add\n 2. (pa_\\<alpha> (Q, W, \\<delta>d),\n     pa_\\<alpha> (pa_step H1 H2 (Q, W, \\<delta>d)))\n    \\<in> frp_step (ls.\\<alpha> h1.\\<delta>) (ls.\\<alpha> h2.\\<delta>)", "from COND"], ["proof (chain)\npicking this:\n  pa_cond (Q, W, \\<delta>d)", "obtain q1 q2 Wtl where \n    [simp]: \"W=(q1,q2)#Wtl\""], ["proof (prove)\nusing this:\n  pa_cond (Q, W, \\<delta>d)\n\ngoal (1 subgoal):\n 1. (\\<And>q1 q2 Wtl.\n        W = (q1, q2) # Wtl \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases W) (auto simp add: pa_cond_def)"], ["proof (state)\nthis:\n  W = (q1, q2) # Wtl\n\ngoal (2 subgoals):\n 1. pa_step H1 H2 (Q, W, \\<delta>d) \\<in> pa_invar_add\n 2. (pa_\\<alpha> (Q, W, \\<delta>d),\n     pa_\\<alpha> (pa_step H1 H2 (Q, W, \\<delta>d)))\n    \\<in> frp_step (ls.\\<alpha> h1.\\<delta>) (ls.\\<alpha> h2.\\<delta>)", "from INV"], ["proof (chain)\npicking this:\n  (Q, W, \\<delta>d) \\<in> pa_invar H1 H2", "have [simp]: \"hs_invar Q\" \"ls_invar \\<delta>d\""], ["proof (prove)\nusing this:\n  (Q, W, \\<delta>d) \\<in> pa_invar H1 H2\n\ngoal (1 subgoal):\n 1. hs.invar Q &&& ls.invar \\<delta>d", "by (auto simp add: pa_invar_add_def pa_invar_def)"], ["proof (state)\nthis:\n  hs.invar Q\n  ls.invar \\<delta>d\n\ngoal (2 subgoals):\n 1. pa_step H1 H2 (Q, W, \\<delta>d) \\<in> pa_invar_add\n 2. (pa_\\<alpha> (Q, W, \\<delta>d),\n     pa_\\<alpha> (pa_step H1 H2 (Q, W, \\<delta>d)))\n    \\<in> frp_step (ls.\\<alpha> h1.\\<delta>) (ls.\\<alpha> h2.\\<delta>)", "define inv where \"inv = (\\<lambda>\\<delta>p (Q', W', \\<delta>d'). \n    hs_invar Q' \n    \\<and> ls_invar \\<delta>d' \n    \\<and> (\\<exists>Wn. distinct Wn \n            \\<and> set Wn = (f_succ \\<delta>p `` {(q1,q2)}) - hs_\\<alpha> Q \n            \\<and> W'=Wn@Wtl \n            \\<and> hs_\\<alpha> Q'=hs_\\<alpha> Q \\<union> (f_succ \\<delta>p `` {(q1,q2)}))\n    \\<and> (ls_\\<alpha> \\<delta>d' = ls_\\<alpha> \\<delta>d \\<union> {r\\<in>\\<delta>p. lhs r = (q1,q2) }))\""], ["proof (state)\nthis:\n  inv =\n  (\\<lambda>\\<delta>p (Q', W', \\<delta>d').\n      hs.invar Q' \\<and>\n      ls.invar \\<delta>d' \\<and>\n      (\\<exists>Wn.\n          distinct Wn \\<and>\n          set Wn = f_succ \\<delta>p `` {(q1, q2)} - hs.\\<alpha> Q \\<and>\n          W' = Wn @ Wtl \\<and>\n          hs.\\<alpha> Q' =\n          hs.\\<alpha> Q \\<union> f_succ \\<delta>p `` {(q1, q2)}) \\<and>\n      ls.\\<alpha> \\<delta>d' =\n      ls.\\<alpha> \\<delta>d \\<union> {r \\<in> \\<delta>p. lhs r = (q1, q2)})\n\ngoal (2 subgoals):\n 1. pa_step H1 H2 (Q, W, \\<delta>d) \\<in> pa_invar_add\n 2. (pa_\\<alpha> (Q, W, \\<delta>d),\n     pa_\\<alpha> (pa_step H1 H2 (Q, W, \\<delta>d)))\n    \\<in> frp_step (ls.\\<alpha> h1.\\<delta>) (ls.\\<alpha> h2.\\<delta>)", "have G: \"inv (\\<delta>_prod (ls_\\<alpha> (hta_\\<delta> H1)) (ls_\\<alpha> (hta_\\<delta> H2))) \n               (pa_step H1 H2 (Q,W,\\<delta>d))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta>) (ls.\\<alpha> h2.\\<delta>))\n     (pa_step H1 H2 (Q, W, \\<delta>d))", "apply (unfold pa_step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta>) (ls.\\<alpha> h2.\\<delta>))\n     (let (Q, W, \\<delta>d) = (Q, W, \\<delta>d); (q1, q2) = hd W\n      in ls.iterate (hta_lookup_s q1 H1)\n          (\\<lambda>r1.\n              ls.iterate (hta_lookup_sf q2 (rhsl r1) H2)\n               (\\<lambda>r2 res.\n                   if length (rhsq r1) = length (rhsq r2)\n                   then let rp = r_prod r1 r2; (Q, W, \\<delta>d) = res;\n                            (Q', W') = pa_upd_rule Q W (rhsq rp)\n                        in (Q', W', ls.ins_dj rp \\<delta>d)\n                   else res))\n          (Q, tl W, \\<delta>d))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta>) (ls.\\<alpha> h2.\\<delta>))\n     (ls.iterate (hta_lookup_s q1 H1)\n       (\\<lambda>r1.\n           ls.iterate (hta_lookup_sf q2 (rhsl r1) H2)\n            (\\<lambda>r2 res.\n                if length (rhsq r1) = length (rhsq r2)\n                then let rp = r_prod r1 r2; (Q, W, \\<delta>d) = res;\n                         (Q', W') = pa_upd_rule Q W (rhsq rp)\n                     in (Q', W', ls.ins_dj rp \\<delta>d)\n                else res))\n       (Q, Wtl, \\<delta>d))", "apply (rule_tac \n      I=\"\\<lambda>it1 res. inv (\\<delta>_prod (ls_\\<alpha> (hta_\\<delta> H1) - it1) (ls_\\<alpha> (hta_\\<delta> H2))) res\"\n      in ls.iterate_rule_P)\n    \\<comment> \\<open>Invar\\<close>"], ["proof (prove)\ngoal (4 subgoals):\n 1. ls.invar (hta_lookup_s q1 H1)\n 2. inv (\\<delta>_prod\n          (ls.\\<alpha> h1.\\<delta> - ls.\\<alpha> (hta_lookup_s q1 H1))\n          (ls.\\<alpha> h2.\\<delta>))\n     (Q, Wtl, \\<delta>d)\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod\n                               (ls.\\<alpha> h1.\\<delta> - (it - {x}))\n                               (ls.\\<alpha> h2.\\<delta>))\n                          (ls.iterate (hta_lookup_sf q2 (rhsl x) H2)\n                            (\\<lambda>r2 res.\n                                if length (rhsq x) = length (rhsq r2)\n                                then let rp = r_prod x r2;\n   (Q, W, \\<delta>d) = res; (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                     in (Q', W', ls.ins_dj rp \\<delta>d)\n                                else res)\n                            \\<sigma>)\n 4. \\<And>\\<sigma>.\n       inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - {})\n             (ls.\\<alpha> h2.\\<delta>))\n        \\<sigma> \\<Longrightarrow>\n       inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta>)\n             (ls.\\<alpha> h2.\\<delta>))\n        \\<sigma>", "apply (simp add: h1.hta_lookup_s_correct)\n    \\<comment> \\<open>Initial\\<close>"], ["proof (prove)\ngoal (3 subgoals):\n 1. inv (\\<delta>_prod\n          (ls.\\<alpha> h1.\\<delta> - ls.\\<alpha> (hta_lookup_s q1 H1))\n          (ls.\\<alpha> h2.\\<delta>))\n     (Q, Wtl, \\<delta>d)\n 2. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod\n                               (ls.\\<alpha> h1.\\<delta> - (it - {x}))\n                               (ls.\\<alpha> h2.\\<delta>))\n                          (ls.iterate (hta_lookup_sf q2 (rhsl x) H2)\n                            (\\<lambda>r2 res.\n                                if length (rhsq x) = length (rhsq r2)\n                                then let rp = r_prod x r2;\n   (Q, W, \\<delta>d) = res; (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                     in (Q', W', ls.ins_dj rp \\<delta>d)\n                                else res)\n                            \\<sigma>)\n 3. \\<And>\\<sigma>.\n       inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - {})\n             (ls.\\<alpha> h2.\\<delta>))\n        \\<sigma> \\<Longrightarrow>\n       inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta>)\n             (ls.\\<alpha> h2.\\<delta>))\n        \\<sigma>", "apply (fastforce simp add: inv_def \\<delta>_prod_def h1.hta_lookup_s_correct \n                              f_succ_alt)\n    \\<comment> \\<open>Step\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod\n                               (ls.\\<alpha> h1.\\<delta> - (it - {x}))\n                               (ls.\\<alpha> h2.\\<delta>))\n                          (ls.iterate (hta_lookup_sf q2 (rhsl x) H2)\n                            (\\<lambda>r2 res.\n                                if length (rhsq x) = length (rhsq r2)\n                                then let rp = r_prod x r2;\n   (Q, W, \\<delta>d) = res; (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                     in (Q', W', ls.ins_dj rp \\<delta>d)\n                                else res)\n                            \\<sigma>)\n 2. \\<And>\\<sigma>.\n       inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - {})\n             (ls.\\<alpha> h2.\\<delta>))\n        \\<sigma> \\<Longrightarrow>\n       inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta>)\n             (ls.\\<alpha> h2.\\<delta>))\n        \\<sigma>", "apply (rule_tac \n      I=\"\\<lambda>it2 res. inv ( \\<delta>_prod (ls_\\<alpha> (hta_\\<delta> H1) - it) (ls_\\<alpha> (hta_\\<delta> H2)) \n                         \\<union> \\<delta>_prod {x} (ls_\\<alpha> (hta_\\<delta> H2) - it2)) \n                        res\" \n      in ls.iterate_rule_P)\n      \\<comment> \\<open>Invar\\<close>"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ls.invar (hta_lookup_sf q2 (rhsl x) H2)\n 2. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> -\n                                ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2)))\n                          \\<sigma>\n 3. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        xa \\<in> ita;\n        ita \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - ita))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> - (ita - {xa})))\n                          (if length (rhsq x) = length (rhsq xa)\n                           then let rp = r_prod x xa;\n                                    (Q, W, \\<delta>d) = \\<sigma>';\n                                    (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                in (Q', W', ls.ins_dj rp \\<delta>d)\n                           else \\<sigma>')\n 4. \\<And>x it \\<sigma> \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - {}))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod\n                               (ls.\\<alpha> h1.\\<delta> - (it - {x}))\n                               (ls.\\<alpha> h2.\\<delta>))\n                          \\<sigma>'\n 5. \\<And>\\<sigma>.\n       inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - {})\n             (ls.\\<alpha> h2.\\<delta>))\n        \\<sigma> \\<Longrightarrow>\n       inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta>)\n             (ls.\\<alpha> h2.\\<delta>))\n        \\<sigma>", "apply (simp add: h2.hta_lookup_sf_correct)\n      \\<comment> \\<open>Init\\<close>"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> -\n                                ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2)))\n                          \\<sigma>\n 2. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        xa \\<in> ita;\n        ita \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - ita))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> - (ita - {xa})))\n                          (if length (rhsq x) = length (rhsq xa)\n                           then let rp = r_prod x xa;\n                                    (Q, W, \\<delta>d) = \\<sigma>';\n                                    (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                in (Q', W', ls.ins_dj rp \\<delta>d)\n                           else \\<sigma>')\n 3. \\<And>x it \\<sigma> \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - {}))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod\n                               (ls.\\<alpha> h1.\\<delta> - (it - {x}))\n                               (ls.\\<alpha> h2.\\<delta>))\n                          \\<sigma>'\n 4. \\<And>\\<sigma>.\n       inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - {})\n             (ls.\\<alpha> h2.\\<delta>))\n        \\<sigma> \\<Longrightarrow>\n       inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta>)\n             (ls.\\<alpha> h2.\\<delta>))\n        \\<sigma>", "apply (case_tac \\<sigma>)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x it \\<sigma> a b c.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        \\<sigma> = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> -\n                                ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2)))\n                          \\<sigma>\n 2. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        xa \\<in> ita;\n        ita \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - ita))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> - (ita - {xa})))\n                          (if length (rhsq x) = length (rhsq xa)\n                           then let rp = r_prod x xa;\n                                    (Q, W, \\<delta>d) = \\<sigma>';\n                                    (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                in (Q', W', ls.ins_dj rp \\<delta>d)\n                           else \\<sigma>')\n 3. \\<And>x it \\<sigma> \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - {}))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod\n                               (ls.\\<alpha> h1.\\<delta> - (it - {x}))\n                               (ls.\\<alpha> h2.\\<delta>))\n                          \\<sigma>'\n 4. \\<And>\\<sigma>.\n       inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - {})\n             (ls.\\<alpha> h2.\\<delta>))\n        \\<sigma> \\<Longrightarrow>\n       inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta>)\n             (ls.\\<alpha> h2.\\<delta>))\n        \\<sigma>", "apply (simp add: inv_def h1.hta_lookup_s_correct h2.hta_lookup_sf_correct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x it \\<sigma> a b c.\n       \\<lbrakk>x \\<in> it;\n        it \\<subseteq> {r \\<in> ls.\\<alpha> h1.\\<delta>. lhs r = q1};\n        (\\<exists>Wn.\n            distinct Wn \\<and>\n            set Wn =\n            f_succ\n             (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n               (ls.\\<alpha> h2.\\<delta>)) ``\n            {(q1, q2)} -\n            hs.\\<alpha> Q \\<and>\n            b = Wn @ Wtl \\<and>\n            hs.\\<alpha> a =\n            hs.\\<alpha> Q \\<union>\n            f_succ\n             (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n               (ls.\\<alpha> h2.\\<delta>)) ``\n            {(q1, q2)}) \\<and>\n        ls.\\<alpha> c =\n        ls.\\<alpha> \\<delta>d \\<union>\n        {r \\<in> \\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                  (ls.\\<alpha> h2.\\<delta>).\n         lhs r = (q1, q2)};\n        \\<sigma> = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>Wn.\n                             distinct Wn \\<and>\n                             set Wn =\n                             f_succ\n                              (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                                (ls.\\<alpha> h2.\\<delta>) \\<union>\n                               \\<delta>_prod {x}\n                                (ls.\\<alpha> h2.\\<delta> -\n                                 {r \\<in> ls.\\<alpha> h2.\\<delta>.\n                                  lhs r = q2 \\<and> rhsl r = rhsl x})) ``\n                             {(q1, q2)} -\n                             hs.\\<alpha> Q \\<and>\n                             b = Wn @ Wtl \\<and>\n                             hs.\\<alpha> a =\n                             hs.\\<alpha> Q \\<union>\n                             f_succ\n                              (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                                (ls.\\<alpha> h2.\\<delta>) \\<union>\n                               \\<delta>_prod {x}\n                                (ls.\\<alpha> h2.\\<delta> -\n                                 {r \\<in> ls.\\<alpha> h2.\\<delta>.\n                                  lhs r = q2 \\<and> rhsl r = rhsl x})) ``\n                             {(q1, q2)}) \\<and>\n                         ls.\\<alpha> \\<delta>d \\<union>\n                         {r \\<in> \\<delta>_prod\n                                   (ls.\\<alpha> h1.\\<delta> - it)\n                                   (ls.\\<alpha> h2.\\<delta>).\n                          lhs r = (q1, q2)} =\n                         ls.\\<alpha> \\<delta>d \\<union>\n                         {r. (r \\<in> \\<delta>_prod\n (ls.\\<alpha> h1.\\<delta> - it) (ls.\\<alpha> h2.\\<delta>) \\<or>\n                              r \\<in> \\<delta>_prod {x}\n (ls.\\<alpha> h2.\\<delta> -\n  {r \\<in> ls.\\<alpha> h2.\\<delta>.\n   lhs r = q2 \\<and> rhsl r = rhsl x})) \\<and>\n                             lhs r = (q1, q2)}\n 2. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        xa \\<in> ita;\n        ita \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - ita))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> - (ita - {xa})))\n                          (if length (rhsq x) = length (rhsq xa)\n                           then let rp = r_prod x xa;\n                                    (Q, W, \\<delta>d) = \\<sigma>';\n                                    (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                in (Q', W', ls.ins_dj rp \\<delta>d)\n                           else \\<sigma>')\n 3. \\<And>x it \\<sigma> \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - {}))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod\n                               (ls.\\<alpha> h1.\\<delta> - (it - {x}))\n                               (ls.\\<alpha> h2.\\<delta>))\n                          \\<sigma>'\n 4. \\<And>\\<sigma>.\n       inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - {})\n             (ls.\\<alpha> h2.\\<delta>))\n        \\<sigma> \\<Longrightarrow>\n       inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta>)\n             (ls.\\<alpha> h2.\\<delta>))\n        \\<sigma>", "apply (force simp add: f_succ_alt elim: \\<delta>_prodE intro: \\<delta>_prodI) [1]\n      \\<comment> \\<open>Step\\<close>"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        xa \\<in> ita;\n        ita \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - ita))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> - (ita - {xa})))\n                          (if length (rhsq x) = length (rhsq xa)\n                           then let rp = r_prod x xa;\n                                    (Q, W, \\<delta>d) = \\<sigma>';\n                                    (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                in (Q', W', ls.ins_dj rp \\<delta>d)\n                           else \\<sigma>')\n 2. \\<And>x it \\<sigma> \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - {}))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod\n                               (ls.\\<alpha> h1.\\<delta> - (it - {x}))\n                               (ls.\\<alpha> h2.\\<delta>))\n                          \\<sigma>'\n 3. \\<And>\\<sigma>.\n       inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - {})\n             (ls.\\<alpha> h2.\\<delta>))\n        \\<sigma> \\<Longrightarrow>\n       inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta>)\n             (ls.\\<alpha> h2.\\<delta>))\n        \\<sigma>", "defer \\<comment> \\<open>Requires considerably more work: Deferred to Isar proof below\\<close>\n      \\<comment> \\<open>Final\\<close>"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x it \\<sigma> \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - {}))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod\n                               (ls.\\<alpha> h1.\\<delta> - (it - {x}))\n                               (ls.\\<alpha> h2.\\<delta>))\n                          \\<sigma>'\n 2. \\<And>\\<sigma>.\n       inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - {})\n             (ls.\\<alpha> h2.\\<delta>))\n        \\<sigma> \\<Longrightarrow>\n       inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta>)\n             (ls.\\<alpha> h2.\\<delta>))\n        \\<sigma>\n 3. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        xa \\<in> ita;\n        ita \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - ita))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> - (ita - {xa})))\n                          (if length (rhsq x) = length (rhsq xa)\n                           then let rp = r_prod x xa;\n                                    (Q, W, \\<delta>d) = \\<sigma>';\n                                    (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                in (Q', W', ls.ins_dj rp \\<delta>d)\n                           else \\<sigma>')", "apply (simp add: h1.hta_lookup_s_correct h2.hta_lookup_sf_correct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x it \\<sigma> \\<sigma>'.\n       \\<lbrakk>x \\<in> it;\n        it \\<subseteq> {r \\<in> ls.\\<alpha> h1.\\<delta>. lhs r = q1};\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod\n                               (ls.\\<alpha> h1.\\<delta> - (it - {x}))\n                               (ls.\\<alpha> h2.\\<delta>))\n                          \\<sigma>'\n 2. \\<And>\\<sigma>.\n       inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - {})\n             (ls.\\<alpha> h2.\\<delta>))\n        \\<sigma> \\<Longrightarrow>\n       inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta>)\n             (ls.\\<alpha> h2.\\<delta>))\n        \\<sigma>\n 3. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        xa \\<in> ita;\n        ita \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - ita))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> - (ita - {xa})))\n                          (if length (rhsq x) = length (rhsq xa)\n                           then let rp = r_prod x xa;\n                                    (Q, W, \\<delta>d) = \\<sigma>';\n                                    (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                in (Q', W', ls.ins_dj rp \\<delta>d)\n                           else \\<sigma>')", "apply (auto) [1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x it a aa b ab ac ba.\n       \\<lbrakk>x \\<in> it;\n        it \\<subseteq> {r \\<in> ls.\\<alpha> h1.\\<delta>. lhs r = q1};\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         (a, aa, b);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta>))\n         (ab, ac, ba)\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod\n                               (ls.\\<alpha> h1.\\<delta> - (it - {x}))\n                               (ls.\\<alpha> h2.\\<delta>))\n                          (ab, ac, ba)\n 2. \\<And>\\<sigma>.\n       inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - {})\n             (ls.\\<alpha> h2.\\<delta>))\n        \\<sigma> \\<Longrightarrow>\n       inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta>)\n             (ls.\\<alpha> h2.\\<delta>))\n        \\<sigma>\n 3. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        xa \\<in> ita;\n        ita \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - ita))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> - (ita - {xa})))\n                          (if length (rhsq x) = length (rhsq xa)\n                           then let rp = r_prod x xa;\n                                    (Q, W, \\<delta>d) = \\<sigma>';\n                                    (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                in (Q', W', ls.ins_dj rp \\<delta>d)\n                           else \\<sigma>')", "apply (subgoal_tac \n        \"ls_\\<alpha> (hta_\\<delta> H1) - (it - {x}) = (ls_\\<alpha> (hta_\\<delta> H1) - it) \\<union> {x}\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x it a aa b ab ac ba.\n       \\<lbrakk>x \\<in> it;\n        it \\<subseteq> {r \\<in> ls.\\<alpha> h1.\\<delta>. lhs r = q1};\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         (a, aa, b);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta>))\n         (ab, ac, ba);\n        ls.\\<alpha> h1.\\<delta> - (it - {x}) =\n        ls.\\<alpha> h1.\\<delta> - it \\<union> {x}\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod\n                               (ls.\\<alpha> h1.\\<delta> - (it - {x}))\n                               (ls.\\<alpha> h2.\\<delta>))\n                          (ab, ac, ba)\n 2. \\<And>x it a aa b ab ac ba.\n       \\<lbrakk>x \\<in> it;\n        it \\<subseteq> {r \\<in> ls.\\<alpha> h1.\\<delta>. lhs r = q1};\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         (a, aa, b);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta>))\n         (ab, ac, ba)\\<rbrakk>\n       \\<Longrightarrow> ls.\\<alpha> h1.\\<delta> - (it - {x}) =\n                         ls.\\<alpha> h1.\\<delta> - it \\<union> {x}\n 3. \\<And>\\<sigma>.\n       inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - {})\n             (ls.\\<alpha> h2.\\<delta>))\n        \\<sigma> \\<Longrightarrow>\n       inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta>)\n             (ls.\\<alpha> h2.\\<delta>))\n        \\<sigma>\n 4. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        xa \\<in> ita;\n        ita \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - ita))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> - (ita - {xa})))\n                          (if length (rhsq x) = length (rhsq xa)\n                           then let rp = r_prod x xa;\n                                    (Q, W, \\<delta>d) = \\<sigma>';\n                                    (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                in (Q', W', ls.ins_dj rp \\<delta>d)\n                           else \\<sigma>')", "apply (simp add: \\<delta>_prod_insert)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x it a aa b ab ac ba.\n       \\<lbrakk>x \\<in> it;\n        it \\<subseteq> {r \\<in> ls.\\<alpha> h1.\\<delta>. lhs r = q1};\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         (a, aa, b);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod_sng1 x (ls.\\<alpha> h2.\\<delta>))\n         (ab, ac, ba);\n        ls.\\<alpha> h1.\\<delta> - (it - {x}) =\n        insert x (ls.\\<alpha> h1.\\<delta> - it)\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod_sng1 x\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>))\n                          (ab, ac, ba)\n 2. \\<And>x it a aa b ab ac ba.\n       \\<lbrakk>x \\<in> it;\n        it \\<subseteq> {r \\<in> ls.\\<alpha> h1.\\<delta>. lhs r = q1};\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         (a, aa, b);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta>))\n         (ab, ac, ba)\\<rbrakk>\n       \\<Longrightarrow> ls.\\<alpha> h1.\\<delta> - (it - {x}) =\n                         ls.\\<alpha> h1.\\<delta> - it \\<union> {x}\n 3. \\<And>\\<sigma>.\n       inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - {})\n             (ls.\\<alpha> h2.\\<delta>))\n        \\<sigma> \\<Longrightarrow>\n       inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta>)\n             (ls.\\<alpha> h2.\\<delta>))\n        \\<sigma>\n 4. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        xa \\<in> ita;\n        ita \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - ita))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> - (ita - {xa})))\n                          (if length (rhsq x) = length (rhsq xa)\n                           then let rp = r_prod x xa;\n                                    (Q, W, \\<delta>d) = \\<sigma>';\n                                    (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                in (Q', W', ls.ins_dj rp \\<delta>d)\n                           else \\<sigma>')", "apply (subst Un_commute)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x it a aa b ab ac ba.\n       \\<lbrakk>x \\<in> it;\n        it \\<subseteq> {r \\<in> ls.\\<alpha> h1.\\<delta>. lhs r = q1};\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         (a, aa, b);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod_sng1 x (ls.\\<alpha> h2.\\<delta>))\n         (ab, ac, ba);\n        ls.\\<alpha> h1.\\<delta> - (it - {x}) =\n        insert x (ls.\\<alpha> h1.\\<delta> - it)\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod_sng1 x\n                               (ls.\\<alpha> h2.\\<delta>))\n                          (ab, ac, ba)\n 2. \\<And>x it a aa b ab ac ba.\n       \\<lbrakk>x \\<in> it;\n        it \\<subseteq> {r \\<in> ls.\\<alpha> h1.\\<delta>. lhs r = q1};\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         (a, aa, b);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta>))\n         (ab, ac, ba)\\<rbrakk>\n       \\<Longrightarrow> ls.\\<alpha> h1.\\<delta> - (it - {x}) =\n                         ls.\\<alpha> h1.\\<delta> - it \\<union> {x}\n 3. \\<And>\\<sigma>.\n       inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - {})\n             (ls.\\<alpha> h2.\\<delta>))\n        \\<sigma> \\<Longrightarrow>\n       inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta>)\n             (ls.\\<alpha> h2.\\<delta>))\n        \\<sigma>\n 4. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        xa \\<in> ita;\n        ita \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - ita))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> - (ita - {xa})))\n                          (if length (rhsq x) = length (rhsq xa)\n                           then let rp = r_prod x xa;\n                                    (Q, W, \\<delta>d) = \\<sigma>';\n                                    (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                in (Q', W', ls.ins_dj rp \\<delta>d)\n                           else \\<sigma>')", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x it a aa b ab ac ba.\n       \\<lbrakk>x \\<in> it;\n        it \\<subseteq> {r \\<in> ls.\\<alpha> h1.\\<delta>. lhs r = q1};\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         (a, aa, b);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta>))\n         (ab, ac, ba)\\<rbrakk>\n       \\<Longrightarrow> ls.\\<alpha> h1.\\<delta> - (it - {x}) =\n                         ls.\\<alpha> h1.\\<delta> - it \\<union> {x}\n 2. \\<And>\\<sigma>.\n       inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - {})\n             (ls.\\<alpha> h2.\\<delta>))\n        \\<sigma> \\<Longrightarrow>\n       inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta>)\n             (ls.\\<alpha> h2.\\<delta>))\n        \\<sigma>\n 3. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        xa \\<in> ita;\n        ita \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - ita))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> - (ita - {xa})))\n                          (if length (rhsq x) = length (rhsq xa)\n                           then let rp = r_prod x xa;\n                                    (Q, W, \\<delta>d) = \\<sigma>';\n                                    (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                in (Q', W', ls.ins_dj rp \\<delta>d)\n                           else \\<sigma>')", "apply blast\n    \\<comment> \\<open>Final\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - {})\n             (ls.\\<alpha> h2.\\<delta>))\n        \\<sigma> \\<Longrightarrow>\n       inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta>)\n             (ls.\\<alpha> h2.\\<delta>))\n        \\<sigma>\n 2. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        xa \\<in> ita;\n        ita \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - ita))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> - (ita - {xa})))\n                          (if length (rhsq x) = length (rhsq xa)\n                           then let rp = r_prod x xa;\n                                    (Q, W, \\<delta>d) = \\<sigma>';\n                                    (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                in (Q', W', ls.ins_dj rp \\<delta>d)\n                           else \\<sigma>')", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        xa \\<in> ita;\n        ita \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - ita))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> - (ita - {xa})))\n                          (if length (rhsq x) = length (rhsq xa)\n                           then let rp = r_prod x xa;\n                                    (Q, W, \\<delta>d) = \\<sigma>';\n                                    (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                in (Q', W', ls.ins_dj rp \\<delta>d)\n                           else \\<sigma>')", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        xa \\<in> ita;\n        ita \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - ita))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> - (ita - {xa})))\n                          (if length (rhsq x) = length (rhsq xa)\n                           then let rp = r_prod x xa;\n                                    (Q, W, \\<delta>d) = \\<sigma>';\n                                    (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                in (Q', W', ls.ins_dj rp \\<delta>d)\n                           else \\<sigma>')", "case prems: (1 r1 it1 resxh r2 it2 resh)\n    \\<comment> \\<open>Resolve lookup-operations\\<close>"], ["proof (state)\nthis:\n  r1 \\<in> it1\n  it1 \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1)\n  inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n        (ls.\\<alpha> h2.\\<delta>))\n   resxh\n  r2 \\<in> it2\n  it2 \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl r1) H2)\n  inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n        (ls.\\<alpha> h2.\\<delta>) \\<union>\n       \\<delta>_prod {r1} (ls.\\<alpha> h2.\\<delta> - it2))\n   resh\n\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        xa \\<in> ita;\n        ita \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - ita))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> - (ita - {xa})))\n                          (if length (rhsq x) = length (rhsq xa)\n                           then let rp = r_prod x xa;\n                                    (Q, W, \\<delta>d) = \\<sigma>';\n                                    (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                in (Q', W', ls.ins_dj rp \\<delta>d)\n                           else \\<sigma>')", "hence G': \n      \"it1 \\<subseteq> {r \\<in> ls_\\<alpha> (hta_\\<delta> H1). lhs r = q1}\" \n      \"it2 \\<subseteq> {r \\<in> ls_\\<alpha> (hta_\\<delta> H2). lhs r = q2 \\<and> rhsl r = rhsl r1}\""], ["proof (prove)\nusing this:\n  r1 \\<in> it1\n  it1 \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1)\n  inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n        (ls.\\<alpha> h2.\\<delta>))\n   resxh\n  r2 \\<in> it2\n  it2 \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl r1) H2)\n  inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n        (ls.\\<alpha> h2.\\<delta>) \\<union>\n       \\<delta>_prod {r1} (ls.\\<alpha> h2.\\<delta> - it2))\n   resh\n\ngoal (1 subgoal):\n 1. it1 \\<subseteq> {r \\<in> ls.\\<alpha> h1.\\<delta>. lhs r = q1} &&&\n    it2\n    \\<subseteq> {r \\<in> ls.\\<alpha> h2.\\<delta>.\n                 lhs r = q2 \\<and> rhsl r = rhsl r1}", "by (simp_all add: h1.hta_lookup_s_correct h2.hta_lookup_sf_correct)\n\n    \\<comment> \\<open>Basic reasoning setup\\<close>"], ["proof (state)\nthis:\n  it1 \\<subseteq> {r \\<in> ls.\\<alpha> h1.\\<delta>. lhs r = q1}\n  it2\n  \\<subseteq> {r \\<in> ls.\\<alpha> h2.\\<delta>.\n               lhs r = q2 \\<and> rhsl r = rhsl r1}\n\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        xa \\<in> ita;\n        ita \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - ita))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> - (ita - {xa})))\n                          (if length (rhsq x) = length (rhsq xa)\n                           then let rp = r_prod x xa;\n                                    (Q, W, \\<delta>d) = \\<sigma>';\n                                    (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                in (Q', W', ls.ins_dj rp \\<delta>d)\n                           else \\<sigma>')", "from prems(1,4) G'"], ["proof (chain)\npicking this:\n  r1 \\<in> it1\n  r2 \\<in> it2\n  it1 \\<subseteq> {r \\<in> ls.\\<alpha> h1.\\<delta>. lhs r = q1}\n  it2\n  \\<subseteq> {r \\<in> ls.\\<alpha> h2.\\<delta>.\n               lhs r = q2 \\<and> rhsl r = rhsl r1}", "have \n      [simp]: \"ls_\\<alpha> (hta_\\<delta> H2) - (it2 - {r2}) = (ls_\\<alpha> (hta_\\<delta> H2) - it2) \\<union> {r2}\""], ["proof (prove)\nusing this:\n  r1 \\<in> it1\n  r2 \\<in> it2\n  it1 \\<subseteq> {r \\<in> ls.\\<alpha> h1.\\<delta>. lhs r = q1}\n  it2\n  \\<subseteq> {r \\<in> ls.\\<alpha> h2.\\<delta>.\n               lhs r = q2 \\<and> rhsl r = rhsl r1}\n\ngoal (1 subgoal):\n 1. ls.\\<alpha> h2.\\<delta> - (it2 - {r2}) =\n    ls.\\<alpha> h2.\\<delta> - it2 \\<union> {r2}", "by auto"], ["proof (state)\nthis:\n  ls.\\<alpha> h2.\\<delta> - (it2 - {r2}) =\n  ls.\\<alpha> h2.\\<delta> - it2 \\<union> {r2}\n\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        xa \\<in> ita;\n        ita \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - ita))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> - (ita - {xa})))\n                          (if length (rhsq x) = length (rhsq xa)\n                           then let rp = r_prod x xa;\n                                    (Q, W, \\<delta>d) = \\<sigma>';\n                                    (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                in (Q', W', ls.ins_dj rp \\<delta>d)\n                           else \\<sigma>')", "obtain Qh Wh \\<delta>dh Q' W' \\<delta>d' where [simp]: \"resh=(Qh,Wh,\\<delta>dh)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Qh Wh \\<delta>dh.\n        resh = (Qh, Wh, \\<delta>dh) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases resh) fastforce"], ["proof (state)\nthis:\n  resh = (Qh, Wh, \\<delta>dh)\n\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        xa \\<in> ita;\n        ita \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - ita))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> - (ita - {xa})))\n                          (if length (rhsq x) = length (rhsq xa)\n                           then let rp = r_prod x xa;\n                                    (Q, W, \\<delta>d) = \\<sigma>';\n                                    (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                in (Q', W', ls.ins_dj rp \\<delta>d)\n                           else \\<sigma>')", "from prems(6)"], ["proof (chain)\npicking this:\n  inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n        (ls.\\<alpha> h2.\\<delta>) \\<union>\n       \\<delta>_prod {r1} (ls.\\<alpha> h2.\\<delta> - it2))\n   resh", "have INVAH[simp]: \"hs_invar Qh\" \"ls_invar \\<delta>dh\""], ["proof (prove)\nusing this:\n  inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n        (ls.\\<alpha> h2.\\<delta>) \\<union>\n       \\<delta>_prod {r1} (ls.\\<alpha> h2.\\<delta> - it2))\n   resh\n\ngoal (1 subgoal):\n 1. hs.invar Qh &&& ls.invar \\<delta>dh", "by (auto simp add: inv_def)\n\n    \\<comment> \\<open>The involved rules have the same label, and their lhs is determined\\<close>"], ["proof (state)\nthis:\n  hs.invar Qh\n  ls.invar \\<delta>dh\n\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        xa \\<in> ita;\n        ita \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - ita))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> - (ita - {xa})))\n                          (if length (rhsq x) = length (rhsq xa)\n                           then let rp = r_prod x xa;\n                                    (Q, W, \\<delta>d) = \\<sigma>';\n                                    (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                in (Q', W', ls.ins_dj rp \\<delta>d)\n                           else \\<sigma>')", "from prems(1,4) G'"], ["proof (chain)\npicking this:\n  r1 \\<in> it1\n  r2 \\<in> it2\n  it1 \\<subseteq> {r \\<in> ls.\\<alpha> h1.\\<delta>. lhs r = q1}\n  it2\n  \\<subseteq> {r \\<in> ls.\\<alpha> h2.\\<delta>.\n               lhs r = q2 \\<and> rhsl r = rhsl r1}", "obtain l qs1 qs2 where \n      RULE_FMT: \"r1 = (q1 \\<rightarrow> l qs1)\" \"r2=(q2 \\<rightarrow> l qs2)\""], ["proof (prove)\nusing this:\n  r1 \\<in> it1\n  r2 \\<in> it2\n  it1 \\<subseteq> {r \\<in> ls.\\<alpha> h1.\\<delta>. lhs r = q1}\n  it2\n  \\<subseteq> {r \\<in> ls.\\<alpha> h2.\\<delta>.\n               lhs r = q2 \\<and> rhsl r = rhsl r1}\n\ngoal (1 subgoal):\n 1. (\\<And>l qs1 qs2.\n        \\<lbrakk>r1 = q1 \\<rightarrow> l qs1;\n         r2 = q2 \\<rightarrow> l qs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (cases r1, cases r2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x1a x2a x3a.\n       \\<lbrakk>\\<And>l qs1 qs2.\n                   \\<lbrakk>r1 = q1 \\<rightarrow> l qs1;\n                    r2 = q2 \\<rightarrow> l qs2\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        r1 \\<in> it1; r2 \\<in> it2;\n        it1 \\<subseteq> {r \\<in> ls.\\<alpha> h1.\\<delta>. lhs r = q1};\n        it2\n        \\<subseteq> {r \\<in> ls.\\<alpha> h2.\\<delta>.\n                     lhs r = q2 \\<and> rhsl r = rhsl r1};\n        r1 = x1 \\<rightarrow> x2 x3; r1 \\<in> it1; r2 \\<in> it2;\n        it1 \\<subseteq> {r \\<in> ls.\\<alpha> h1.\\<delta>. lhs r = q1};\n        it2\n        \\<subseteq> {r \\<in> ls.\\<alpha> h2.\\<delta>.\n                     lhs r = q2 \\<and> rhsl r = rhsl r1};\n        r2 = x1a \\<rightarrow> x2a x3a\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  r1 = q1 \\<rightarrow> l qs1\n  r2 = q2 \\<rightarrow> l qs2\n\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        xa \\<in> ita;\n        ita \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - ita))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> - (ita - {xa})))\n                          (if length (rhsq x) = length (rhsq xa)\n                           then let rp = r_prod x xa;\n                                    (Q, W, \\<delta>d) = \\<sigma>';\n                                    (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                in (Q', W', ls.ins_dj rp \\<delta>d)\n                           else \\<sigma>')", "{\n      \\<comment> \\<open>If the rhs have different lengths, the algorithm ignores the rule:\\<close>"], ["proof (state)\nthis:\n  r1 = q1 \\<rightarrow> l qs1\n  r2 = q2 \\<rightarrow> l qs2\n\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        xa \\<in> ita;\n        ita \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - ita))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> - (ita - {xa})))\n                          (if length (rhsq x) = length (rhsq xa)\n                           then let rp = r_prod x xa;\n                                    (Q, W, \\<delta>d) = \\<sigma>';\n                                    (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                in (Q', W', ls.ins_dj rp \\<delta>d)\n                           else \\<sigma>')", "assume LEN: \"length (rhsq r1) \\<noteq> length (rhsq r2)\""], ["proof (state)\nthis:\n  length (rhsq r1) \\<noteq> length (rhsq r2)\n\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        xa \\<in> ita;\n        ita \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - ita))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> - (ita - {xa})))\n                          (if length (rhsq x) = length (rhsq xa)\n                           then let rp = r_prod x xa;\n                                    (Q, W, \\<delta>d) = \\<sigma>';\n                                    (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                in (Q', W', ls.ins_dj rp \\<delta>d)\n                           else \\<sigma>')", "hence [simp]: \"\\<delta>_prod_sng2 {r1} r2 = {}\""], ["proof (prove)\nusing this:\n  length (rhsq r1) \\<noteq> length (rhsq r2)\n\ngoal (1 subgoal):\n 1. \\<delta>_prod_sng2 {r1} r2 = {}", "by (auto simp add: \\<delta>_prod_sng2_def split: ta_rule.split)"], ["proof (state)\nthis:\n  \\<delta>_prod_sng2 {r1} r2 = {}\n\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        xa \\<in> ita;\n        ita \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - ita))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> - (ita - {xa})))\n                          (if length (rhsq x) = length (rhsq xa)\n                           then let rp = r_prod x xa;\n                                    (Q, W, \\<delta>d) = \\<sigma>';\n                                    (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                in (Q', W', ls.ins_dj rp \\<delta>d)\n                           else \\<sigma>')", "have ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n          (ls.\\<alpha> h2.\\<delta>) \\<union>\n         \\<delta>_prod {r1} (ls.\\<alpha> h2.\\<delta> - (it2 - {r2})))\n     (if length (rhsq r1) = length (rhsq r2)\n      then let rp = r_prod r1 r2; (Q, W, \\<delta>d) = resh;\n               (Q', W') = pa_upd_rule Q W (rhsq rp)\n           in (Q', W', ls.ins_dj rp \\<delta>d)\n      else resh)", "using prems"], ["proof (prove)\nusing this:\n  r1 \\<in> it1\n  it1 \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1)\n  inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n        (ls.\\<alpha> h2.\\<delta>))\n   resxh\n  r2 \\<in> it2\n  it2 \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl r1) H2)\n  inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n        (ls.\\<alpha> h2.\\<delta>) \\<union>\n       \\<delta>_prod {r1} (ls.\\<alpha> h2.\\<delta> - it2))\n   resh\n\ngoal (1 subgoal):\n 1. inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n          (ls.\\<alpha> h2.\\<delta>) \\<union>\n         \\<delta>_prod {r1} (ls.\\<alpha> h2.\\<delta> - (it2 - {r2})))\n     (if length (rhsq r1) = length (rhsq r2)\n      then let rp = r_prod r1 r2; (Q, W, \\<delta>d) = resh;\n               (Q', W') = pa_upd_rule Q W (rhsq rp)\n           in (Q', W', ls.ins_dj rp \\<delta>d)\n      else resh)", "by (simp add: LEN \\<delta>_prod_insert)"], ["proof (state)\nthis:\n  inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n        (ls.\\<alpha> h2.\\<delta>) \\<union>\n       \\<delta>_prod {r1} (ls.\\<alpha> h2.\\<delta> - (it2 - {r2})))\n   (if length (rhsq r1) = length (rhsq r2)\n    then let rp = r_prod r1 r2; (Q, W, \\<delta>d) = resh;\n             (Q', W') = pa_upd_rule Q W (rhsq rp)\n         in (Q', W', ls.ins_dj rp \\<delta>d)\n    else resh)\n\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        xa \\<in> ita;\n        ita \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - ita))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> - (ita - {xa})))\n                          (if length (rhsq x) = length (rhsq xa)\n                           then let rp = r_prod x xa;\n                                    (Q, W, \\<delta>d) = \\<sigma>';\n                                    (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                in (Q', W', ls.ins_dj rp \\<delta>d)\n                           else \\<sigma>')", "}"], ["proof (state)\nthis:\n  length (rhsq r1) \\<noteq> length (rhsq r2) \\<Longrightarrow>\n  inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n        (ls.\\<alpha> h2.\\<delta>) \\<union>\n       \\<delta>_prod {r1} (ls.\\<alpha> h2.\\<delta> - (it2 - {r2})))\n   (if length (rhsq r1) = length (rhsq r2)\n    then let rp = r_prod r1 r2; (Q, W, \\<delta>d) = resh;\n             (Q', W') = pa_upd_rule Q W (rhsq rp)\n         in (Q', W', ls.ins_dj rp \\<delta>d)\n    else resh)\n\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        xa \\<in> ita;\n        ita \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - ita))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> - (ita - {xa})))\n                          (if length (rhsq x) = length (rhsq xa)\n                           then let rp = r_prod x xa;\n                                    (Q, W, \\<delta>d) = \\<sigma>';\n                                    (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                in (Q', W', ls.ins_dj rp \\<delta>d)\n                           else \\<sigma>')", "moreover"], ["proof (state)\nthis:\n  length (rhsq r1) \\<noteq> length (rhsq r2) \\<Longrightarrow>\n  inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n        (ls.\\<alpha> h2.\\<delta>) \\<union>\n       \\<delta>_prod {r1} (ls.\\<alpha> h2.\\<delta> - (it2 - {r2})))\n   (if length (rhsq r1) = length (rhsq r2)\n    then let rp = r_prod r1 r2; (Q, W, \\<delta>d) = resh;\n             (Q', W') = pa_upd_rule Q W (rhsq rp)\n         in (Q', W', ls.ins_dj rp \\<delta>d)\n    else resh)\n\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        xa \\<in> ita;\n        ita \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - ita))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> - (ita - {xa})))\n                          (if length (rhsq x) = length (rhsq xa)\n                           then let rp = r_prod x xa;\n                                    (Q, W, \\<delta>d) = \\<sigma>';\n                                    (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                in (Q', W', ls.ins_dj rp \\<delta>d)\n                           else \\<sigma>')", "{\n      \\<comment> \\<open>If the rhs have the same length, the rule is inserted\\<close>"], ["proof (state)\nthis:\n  length (rhsq r1) \\<noteq> length (rhsq r2) \\<Longrightarrow>\n  inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n        (ls.\\<alpha> h2.\\<delta>) \\<union>\n       \\<delta>_prod {r1} (ls.\\<alpha> h2.\\<delta> - (it2 - {r2})))\n   (if length (rhsq r1) = length (rhsq r2)\n    then let rp = r_prod r1 r2; (Q, W, \\<delta>d) = resh;\n             (Q', W') = pa_upd_rule Q W (rhsq rp)\n         in (Q', W', ls.ins_dj rp \\<delta>d)\n    else resh)\n\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        xa \\<in> ita;\n        ita \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - ita))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> - (ita - {xa})))\n                          (if length (rhsq x) = length (rhsq xa)\n                           then let rp = r_prod x xa;\n                                    (Q, W, \\<delta>d) = \\<sigma>';\n                                    (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                in (Q', W', ls.ins_dj rp \\<delta>d)\n                           else \\<sigma>')", "assume LEN: \"length (rhsq r1) = length (rhsq r2)\""], ["proof (state)\nthis:\n  length (rhsq r1) = length (rhsq r2)\n\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        xa \\<in> ita;\n        ita \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - ita))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> - (ita - {xa})))\n                          (if length (rhsq x) = length (rhsq xa)\n                           then let rp = r_prod x xa;\n                                    (Q, W, \\<delta>d) = \\<sigma>';\n                                    (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                in (Q', W', ls.ins_dj rp \\<delta>d)\n                           else \\<sigma>')", "hence [simp]: \"length qs1 = length qs2\""], ["proof (prove)\nusing this:\n  length (rhsq r1) = length (rhsq r2)\n\ngoal (1 subgoal):\n 1. length qs1 = length qs2", "by (simp add: RULE_FMT)"], ["proof (state)\nthis:\n  length qs1 = length qs2\n\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        xa \\<in> ita;\n        ita \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - ita))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> - (ita - {xa})))\n                          (if length (rhsq x) = length (rhsq xa)\n                           then let rp = r_prod x xa;\n                                    (Q, W, \\<delta>d) = \\<sigma>';\n                                    (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                in (Q', W', ls.ins_dj rp \\<delta>d)\n                           else \\<sigma>')", "hence [simp]: \"\\<delta>_prod_sng2 {r1} r2 = {(q1,q2) \\<rightarrow> l (zip qs1 qs2)}\""], ["proof (prove)\nusing this:\n  length qs1 = length qs2\n\ngoal (1 subgoal):\n 1. \\<delta>_prod_sng2 {r1} r2 = {(q1, q2) \\<rightarrow> l zip qs1 qs2}", "using prems(1,4) G'"], ["proof (prove)\nusing this:\n  length qs1 = length qs2\n  r1 \\<in> it1\n  r2 \\<in> it2\n  it1 \\<subseteq> {r \\<in> ls.\\<alpha> h1.\\<delta>. lhs r = q1}\n  it2\n  \\<subseteq> {r \\<in> ls.\\<alpha> h2.\\<delta>.\n               lhs r = q2 \\<and> rhsl r = rhsl r1}\n\ngoal (1 subgoal):\n 1. \\<delta>_prod_sng2 {r1} r2 = {(q1, q2) \\<rightarrow> l zip qs1 qs2}", "by (auto simp add: \\<delta>_prod_sng2_def RULE_FMT)\n\n      \\<comment> \\<open>Obtain invariant of previous state\\<close>"], ["proof (state)\nthis:\n  \\<delta>_prod_sng2 {r1} r2 = {(q1, q2) \\<rightarrow> l zip qs1 qs2}\n\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        xa \\<in> ita;\n        ita \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - ita))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> - (ita - {xa})))\n                          (if length (rhsq x) = length (rhsq xa)\n                           then let rp = r_prod x xa;\n                                    (Q, W, \\<delta>d) = \\<sigma>';\n                                    (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                in (Q', W', ls.ins_dj rp \\<delta>d)\n                           else \\<sigma>')", "from prems(6)[unfolded inv_def, simplified]"], ["proof (chain)\npicking this:\n  (\\<exists>Wn.\n      distinct Wn \\<and>\n      set Wn =\n      f_succ\n       (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n         (ls.\\<alpha> h2.\\<delta>) \\<union>\n        \\<delta>_prod {r1} (ls.\\<alpha> h2.\\<delta> - it2)) ``\n      {(q1, q2)} -\n      hs.\\<alpha> Q \\<and>\n      Wh = Wn @ Wtl \\<and>\n      hs.\\<alpha> Qh =\n      hs.\\<alpha> Q \\<union>\n      f_succ\n       (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n         (ls.\\<alpha> h2.\\<delta>) \\<union>\n        \\<delta>_prod {r1} (ls.\\<alpha> h2.\\<delta> - it2)) ``\n      {(q1, q2)}) \\<and>\n  ls.\\<alpha> \\<delta>dh =\n  ls.\\<alpha> \\<delta>d \\<union>\n  {r. (r \\<in> \\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n                (ls.\\<alpha> h2.\\<delta>) \\<or>\n       r \\<in> \\<delta>_prod {r1} (ls.\\<alpha> h2.\\<delta> - it2)) \\<and>\n      lhs r = (q1, q2)}", "obtain Wn where INVH:\n        \"distinct Wn\"\n        \"set Wn = f_succ (\\<delta>_prod (ls_\\<alpha> (hta_\\<delta> H1) - it1) (ls_\\<alpha> (hta_\\<delta> H2)) \n                          \\<union> \\<delta>_prod {r1} (ls_\\<alpha> (hta_\\<delta> H2) - it2)) \n                  `` {(q1, q2)} - hs_\\<alpha> Q\"\n        \"Wh = Wn @ Wtl\" \n        \"hs_\\<alpha> Qh = hs_\\<alpha> Q \n                   \\<union> f_succ (\\<delta>_prod (ls_\\<alpha> (hta_\\<delta> H1) - it1) (ls_\\<alpha> (hta_\\<delta> H2))\n                              \\<union> \\<delta>_prod {r1} (ls_\\<alpha> (hta_\\<delta> H2) - it2)) \n                      `` {(q1, q2)}\" \n        \"ls_\\<alpha> \\<delta>dh = ls_\\<alpha> \\<delta>d \n          \\<union> {r. ( r \\<in> \\<delta>_prod (ls_\\<alpha> (hta_\\<delta> H1) - it1) (ls_\\<alpha> (hta_\\<delta> H2)) \n                  \\<or> r \\<in> \\<delta>_prod {r1} (ls_\\<alpha> (hta_\\<delta> H2) - it2)\n                 ) \\<and> lhs r = (q1, q2)\n             }\""], ["proof (prove)\nusing this:\n  (\\<exists>Wn.\n      distinct Wn \\<and>\n      set Wn =\n      f_succ\n       (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n         (ls.\\<alpha> h2.\\<delta>) \\<union>\n        \\<delta>_prod {r1} (ls.\\<alpha> h2.\\<delta> - it2)) ``\n      {(q1, q2)} -\n      hs.\\<alpha> Q \\<and>\n      Wh = Wn @ Wtl \\<and>\n      hs.\\<alpha> Qh =\n      hs.\\<alpha> Q \\<union>\n      f_succ\n       (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n         (ls.\\<alpha> h2.\\<delta>) \\<union>\n        \\<delta>_prod {r1} (ls.\\<alpha> h2.\\<delta> - it2)) ``\n      {(q1, q2)}) \\<and>\n  ls.\\<alpha> \\<delta>dh =\n  ls.\\<alpha> \\<delta>d \\<union>\n  {r. (r \\<in> \\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n                (ls.\\<alpha> h2.\\<delta>) \\<or>\n       r \\<in> \\<delta>_prod {r1} (ls.\\<alpha> h2.\\<delta> - it2)) \\<and>\n      lhs r = (q1, q2)}\n\ngoal (1 subgoal):\n 1. (\\<And>Wn.\n        \\<lbrakk>distinct Wn;\n         set Wn =\n         f_succ\n          (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n            (ls.\\<alpha> h2.\\<delta>) \\<union>\n           \\<delta>_prod {r1} (ls.\\<alpha> h2.\\<delta> - it2)) ``\n         {(q1, q2)} -\n         hs.\\<alpha> Q;\n         Wh = Wn @ Wtl;\n         hs.\\<alpha> Qh =\n         hs.\\<alpha> Q \\<union>\n         f_succ\n          (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n            (ls.\\<alpha> h2.\\<delta>) \\<union>\n           \\<delta>_prod {r1} (ls.\\<alpha> h2.\\<delta> - it2)) ``\n         {(q1, q2)};\n         ls.\\<alpha> \\<delta>dh =\n         ls.\\<alpha> \\<delta>d \\<union>\n         {r. (r \\<in> \\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n                       (ls.\\<alpha> h2.\\<delta>) \\<or>\n              r \\<in> \\<delta>_prod {r1}\n                       (ls.\\<alpha> h2.\\<delta> - it2)) \\<and>\n             lhs r = (q1, q2)}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast\n\n      \\<comment> \\<open>Required to justify disjoint insert\\<close>"], ["proof (state)\nthis:\n  distinct Wn\n  set Wn =\n  f_succ\n   (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n     (ls.\\<alpha> h2.\\<delta>) \\<union>\n    \\<delta>_prod {r1} (ls.\\<alpha> h2.\\<delta> - it2)) ``\n  {(q1, q2)} -\n  hs.\\<alpha> Q\n  Wh = Wn @ Wtl\n  hs.\\<alpha> Qh =\n  hs.\\<alpha> Q \\<union>\n  f_succ\n   (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n     (ls.\\<alpha> h2.\\<delta>) \\<union>\n    \\<delta>_prod {r1} (ls.\\<alpha> h2.\\<delta> - it2)) ``\n  {(q1, q2)}\n  ls.\\<alpha> \\<delta>dh =\n  ls.\\<alpha> \\<delta>d \\<union>\n  {r. (r \\<in> \\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n                (ls.\\<alpha> h2.\\<delta>) \\<or>\n       r \\<in> \\<delta>_prod {r1} (ls.\\<alpha> h2.\\<delta> - it2)) \\<and>\n      lhs r = (q1, q2)}\n\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        xa \\<in> ita;\n        ita \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - ita))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> - (ita - {xa})))\n                          (if length (rhsq x) = length (rhsq xa)\n                           then let rp = r_prod x xa;\n                                    (Q, W, \\<delta>d) = \\<sigma>';\n                                    (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                in (Q', W', ls.ins_dj rp \\<delta>d)\n                           else \\<sigma>')", "have RPD: \"r_prod r1 r2 \\<notin> ls_\\<alpha> \\<delta>dh\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r_prod r1 r2 \\<notin> ls.\\<alpha> \\<delta>dh", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. r_prod r1 r2 \\<notin> ls.\\<alpha> \\<delta>dh", "from INV[unfolded pa_invar_def frp_invar_def frp_invar_add_def]"], ["proof (chain)\npicking this:\n  (Q, W, \\<delta>d)\n  \\<in> pa_invar_add \\<inter>\n        {s. pa_\\<alpha> s\n            \\<in> {(Q, W, \\<delta>d).\n                   \\<delta>d =\n                   {r \\<in> \\<delta>_prod (ta_rules (hta_\\<alpha> H1))\n                             (ta_rules (hta_\\<alpha> H2)).\n                    lhs r \\<in> Q - set W}} \\<inter>\n                  {s. frp_\\<alpha> s\n                      \\<in> dfs_invar\n                             (ta_initial (hta_\\<alpha> H1) \\<times>\n                              ta_initial (hta_\\<alpha> H2))\n                             (f_succ\n                               (\\<delta>_prod (ta_rules (hta_\\<alpha> H1))\n                                 (ta_rules (hta_\\<alpha> H2))))}}", "have LSDD: \n          \"ls_\\<alpha> \\<delta>d = {r \\<in> \\<delta>_prod (ls_\\<alpha> (hta_\\<delta> H1)) (ls_\\<alpha> (hta_\\<delta> H2)). \n                        lhs r \\<in> hs_\\<alpha> Q - set W}\""], ["proof (prove)\nusing this:\n  (Q, W, \\<delta>d)\n  \\<in> pa_invar_add \\<inter>\n        {s. pa_\\<alpha> s\n            \\<in> {(Q, W, \\<delta>d).\n                   \\<delta>d =\n                   {r \\<in> \\<delta>_prod (ta_rules (hta_\\<alpha> H1))\n                             (ta_rules (hta_\\<alpha> H2)).\n                    lhs r \\<in> Q - set W}} \\<inter>\n                  {s. frp_\\<alpha> s\n                      \\<in> dfs_invar\n                             (ta_initial (hta_\\<alpha> H1) \\<times>\n                              ta_initial (hta_\\<alpha> H2))\n                             (f_succ\n                               (\\<delta>_prod (ta_rules (hta_\\<alpha> H1))\n                                 (ta_rules (hta_\\<alpha> H2))))}}\n\ngoal (1 subgoal):\n 1. ls.\\<alpha> \\<delta>d =\n    {r \\<in> \\<delta>_prod (ls.\\<alpha> h1.\\<delta>)\n              (ls.\\<alpha> h2.\\<delta>).\n     lhs r \\<in> hs.\\<alpha> Q - set W}", "by (auto simp add: pa_\\<alpha>_def hta_\\<alpha>_def)"], ["proof (state)\nthis:\n  ls.\\<alpha> \\<delta>d =\n  {r \\<in> \\<delta>_prod (ls.\\<alpha> h1.\\<delta>)\n            (ls.\\<alpha> h2.\\<delta>).\n   lhs r \\<in> hs.\\<alpha> Q - set W}\n\ngoal (1 subgoal):\n 1. r_prod r1 r2 \\<notin> ls.\\<alpha> \\<delta>dh", "have \"r_prod r1 r2 \\<notin> ls_\\<alpha> \\<delta>d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r_prod r1 r2 \\<notin> ls.\\<alpha> \\<delta>d", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. r_prod r1 r2 \\<in> ls.\\<alpha> \\<delta>d \\<Longrightarrow> False", "assume \"r_prod r1 r2 \\<in> ls_\\<alpha> \\<delta>d\""], ["proof (state)\nthis:\n  r_prod r1 r2 \\<in> ls.\\<alpha> \\<delta>d\n\ngoal (1 subgoal):\n 1. r_prod r1 r2 \\<in> ls.\\<alpha> \\<delta>d \\<Longrightarrow> False", "with LSDD"], ["proof (chain)\npicking this:\n  ls.\\<alpha> \\<delta>d =\n  {r \\<in> \\<delta>_prod (ls.\\<alpha> h1.\\<delta>)\n            (ls.\\<alpha> h2.\\<delta>).\n   lhs r \\<in> hs.\\<alpha> Q - set W}\n  r_prod r1 r2 \\<in> ls.\\<alpha> \\<delta>d", "have \"lhs (r_prod r1 r2) \\<notin> set W\""], ["proof (prove)\nusing this:\n  ls.\\<alpha> \\<delta>d =\n  {r \\<in> \\<delta>_prod (ls.\\<alpha> h1.\\<delta>)\n            (ls.\\<alpha> h2.\\<delta>).\n   lhs r \\<in> hs.\\<alpha> Q - set W}\n  r_prod r1 r2 \\<in> ls.\\<alpha> \\<delta>d\n\ngoal (1 subgoal):\n 1. lhs (r_prod r1 r2) \\<notin> set W", "by auto"], ["proof (state)\nthis:\n  lhs (r_prod r1 r2) \\<notin> set W\n\ngoal (1 subgoal):\n 1. r_prod r1 r2 \\<in> ls.\\<alpha> \\<delta>d \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  lhs (r_prod r1 r2) \\<notin> set W\n\ngoal (1 subgoal):\n 1. r_prod r1 r2 \\<in> ls.\\<alpha> \\<delta>d \\<Longrightarrow> False", "from prems(1,4) G'"], ["proof (chain)\npicking this:\n  r1 \\<in> it1\n  r2 \\<in> it2\n  it1 \\<subseteq> {r \\<in> ls.\\<alpha> h1.\\<delta>. lhs r = q1}\n  it2\n  \\<subseteq> {r \\<in> ls.\\<alpha> h2.\\<delta>.\n               lhs r = q2 \\<and> rhsl r = rhsl r1}", "have \"lhs (r_prod r1 r2) = (q1,q2)\""], ["proof (prove)\nusing this:\n  r1 \\<in> it1\n  r2 \\<in> it2\n  it1 \\<subseteq> {r \\<in> ls.\\<alpha> h1.\\<delta>. lhs r = q1}\n  it2\n  \\<subseteq> {r \\<in> ls.\\<alpha> h2.\\<delta>.\n               lhs r = q2 \\<and> rhsl r = rhsl r1}\n\ngoal (1 subgoal):\n 1. lhs (r_prod r1 r2) = (q1, q2)", "by (cases r1, cases r2) auto"], ["proof (state)\nthis:\n  lhs (r_prod r1 r2) = (q1, q2)\n\ngoal (1 subgoal):\n 1. r_prod r1 r2 \\<in> ls.\\<alpha> \\<delta>d \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  lhs (r_prod r1 r2) \\<notin> set W\n  lhs (r_prod r1 r2) = (q1, q2)", "show False"], ["proof (prove)\nusing this:\n  lhs (r_prod r1 r2) \\<notin> set W\n  lhs (r_prod r1 r2) = (q1, q2)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r_prod r1 r2 \\<notin> ls.\\<alpha> \\<delta>d\n\ngoal (1 subgoal):\n 1. r_prod r1 r2 \\<notin> ls.\\<alpha> \\<delta>dh", "moreover"], ["proof (state)\nthis:\n  r_prod r1 r2 \\<notin> ls.\\<alpha> \\<delta>d\n\ngoal (1 subgoal):\n 1. r_prod r1 r2 \\<notin> ls.\\<alpha> \\<delta>dh", "from prems(6)"], ["proof (chain)\npicking this:\n  inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n        (ls.\\<alpha> h2.\\<delta>) \\<union>\n       \\<delta>_prod {r1} (ls.\\<alpha> h2.\\<delta> - it2))\n   resh", "have \"ls_\\<alpha> \\<delta>dh = \n          ls_\\<alpha> \\<delta>d \\<union> \n          {r. ( r \\<in> \\<delta>_prod (ls_\\<alpha> (hta_\\<delta> H1) - it1) (ls_\\<alpha> (hta_\\<delta> H2)) \n                \\<or> r \\<in> \\<delta>_prod {r1} (ls_\\<alpha> (hta_\\<delta> H2) - it2)\n              ) \\<and> lhs r = (q1, q2)}\" (is \"_= _ \\<union> ?s\")"], ["proof (prove)\nusing this:\n  inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n        (ls.\\<alpha> h2.\\<delta>) \\<union>\n       \\<delta>_prod {r1} (ls.\\<alpha> h2.\\<delta> - it2))\n   resh\n\ngoal (1 subgoal):\n 1. ls.\\<alpha> \\<delta>dh =\n    ls.\\<alpha> \\<delta>d \\<union>\n    {r. (r \\<in> \\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n                  (ls.\\<alpha> h2.\\<delta>) \\<or>\n         r \\<in> \\<delta>_prod {r1} (ls.\\<alpha> h2.\\<delta> - it2)) \\<and>\n        lhs r = (q1, q2)}", "by (simp add: inv_def)"], ["proof (state)\nthis:\n  ls.\\<alpha> \\<delta>dh =\n  ls.\\<alpha> \\<delta>d \\<union>\n  {r. (r \\<in> \\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n                (ls.\\<alpha> h2.\\<delta>) \\<or>\n       r \\<in> \\<delta>_prod {r1} (ls.\\<alpha> h2.\\<delta> - it2)) \\<and>\n      lhs r = (q1, q2)}\n\ngoal (1 subgoal):\n 1. r_prod r1 r2 \\<notin> ls.\\<alpha> \\<delta>dh", "moreover"], ["proof (state)\nthis:\n  ls.\\<alpha> \\<delta>dh =\n  ls.\\<alpha> \\<delta>d \\<union>\n  {r. (r \\<in> \\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n                (ls.\\<alpha> h2.\\<delta>) \\<or>\n       r \\<in> \\<delta>_prod {r1} (ls.\\<alpha> h2.\\<delta> - it2)) \\<and>\n      lhs r = (q1, q2)}\n\ngoal (1 subgoal):\n 1. r_prod r1 r2 \\<notin> ls.\\<alpha> \\<delta>dh", "have \"r_prod r1 r2 \\<notin> ?s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r_prod r1 r2\n    \\<notin> {r. (r \\<in> \\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n                           (ls.\\<alpha> h2.\\<delta>) \\<or>\n                  r \\<in> \\<delta>_prod {r1}\n                           (ls.\\<alpha> h2.\\<delta> - it2)) \\<and>\n                 lhs r = (q1, q2)}", "using prems(1,4) G'(2) LEN"], ["proof (prove)\nusing this:\n  r1 \\<in> it1\n  r2 \\<in> it2\n  it2\n  \\<subseteq> {r \\<in> ls.\\<alpha> h2.\\<delta>.\n               lhs r = q2 \\<and> rhsl r = rhsl r1}\n  length (rhsq r1) = length (rhsq r2)\n\ngoal (1 subgoal):\n 1. r_prod r1 r2\n    \\<notin> {r. (r \\<in> \\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n                           (ls.\\<alpha> h2.\\<delta>) \\<or>\n                  r \\<in> \\<delta>_prod {r1}\n                           (ls.\\<alpha> h2.\\<delta> - it2)) \\<and>\n                 lhs r = (q1, q2)}", "apply (cases r1, cases r2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x1a x2a x3a.\n       \\<lbrakk>r1 \\<in> it1; r2 \\<in> it2;\n        it2\n        \\<subseteq> {r \\<in> ls.\\<alpha> h2.\\<delta>.\n                     lhs r = q2 \\<and> rhsl r = rhsl r1};\n        length (rhsq r1) = length (rhsq r2); r1 = x1 \\<rightarrow> x2 x3;\n        r1 \\<in> it1; r2 \\<in> it2;\n        it2\n        \\<subseteq> {r \\<in> ls.\\<alpha> h2.\\<delta>.\n                     lhs r = q2 \\<and> rhsl r = rhsl r1};\n        length (rhsq r1) = length (rhsq r2);\n        r2 = x1a \\<rightarrow> x2a x3a\\<rbrakk>\n       \\<Longrightarrow> r_prod r1 r2\n                         \\<notin> {r. (r\n \\<in> \\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n        (ls.\\<alpha> h2.\\<delta>) \\<or>\n r \\<in> \\<delta>_prod {r1} (ls.\\<alpha> h2.\\<delta> - it2)) \\<and>\nlhs r = (q1, q2)}", "apply (auto simp add: \\<delta>_prod_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  r_prod r1 r2\n  \\<notin> {r. (r \\<in> \\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n                         (ls.\\<alpha> h2.\\<delta>) \\<or>\n                r \\<in> \\<delta>_prod {r1}\n                         (ls.\\<alpha> h2.\\<delta> - it2)) \\<and>\n               lhs r = (q1, q2)}\n\ngoal (1 subgoal):\n 1. r_prod r1 r2 \\<notin> ls.\\<alpha> \\<delta>dh", "ultimately"], ["proof (chain)\npicking this:\n  r_prod r1 r2 \\<notin> ls.\\<alpha> \\<delta>d\n  ls.\\<alpha> \\<delta>dh =\n  ls.\\<alpha> \\<delta>d \\<union>\n  {r. (r \\<in> \\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n                (ls.\\<alpha> h2.\\<delta>) \\<or>\n       r \\<in> \\<delta>_prod {r1} (ls.\\<alpha> h2.\\<delta> - it2)) \\<and>\n      lhs r = (q1, q2)}\n  r_prod r1 r2\n  \\<notin> {r. (r \\<in> \\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n                         (ls.\\<alpha> h2.\\<delta>) \\<or>\n                r \\<in> \\<delta>_prod {r1}\n                         (ls.\\<alpha> h2.\\<delta> - it2)) \\<and>\n               lhs r = (q1, q2)}", "show ?thesis"], ["proof (prove)\nusing this:\n  r_prod r1 r2 \\<notin> ls.\\<alpha> \\<delta>d\n  ls.\\<alpha> \\<delta>dh =\n  ls.\\<alpha> \\<delta>d \\<union>\n  {r. (r \\<in> \\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n                (ls.\\<alpha> h2.\\<delta>) \\<or>\n       r \\<in> \\<delta>_prod {r1} (ls.\\<alpha> h2.\\<delta> - it2)) \\<and>\n      lhs r = (q1, q2)}\n  r_prod r1 r2\n  \\<notin> {r. (r \\<in> \\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n                         (ls.\\<alpha> h2.\\<delta>) \\<or>\n                r \\<in> \\<delta>_prod {r1}\n                         (ls.\\<alpha> h2.\\<delta> - it2)) \\<and>\n               lhs r = (q1, q2)}\n\ngoal (1 subgoal):\n 1. r_prod r1 r2 \\<notin> ls.\\<alpha> \\<delta>dh", "by blast"], ["proof (state)\nthis:\n  r_prod r1 r2 \\<notin> ls.\\<alpha> \\<delta>dh\n\ngoal:\nNo subgoals!", "qed\n\n      \\<comment> \\<open>Correctness of result of @{text pa_upd_rule}\\<close>"], ["proof (state)\nthis:\n  r_prod r1 r2 \\<notin> ls.\\<alpha> \\<delta>dh\n\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        xa \\<in> ita;\n        ita \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - ita))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> - (ita - {xa})))\n                          (if length (rhsq x) = length (rhsq xa)\n                           then let rp = r_prod x xa;\n                                    (Q, W, \\<delta>d) = \\<sigma>';\n                                    (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                in (Q', W', ls.ins_dj rp \\<delta>d)\n                           else \\<sigma>')", "obtain Q' W' where \n        PAUF: \"(pa_upd_rule Qh Wh (rhsq (r_prod r1 r2))) = (Q',W')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Q' W'.\n        pa_upd_rule Qh Wh (rhsq (r_prod r1 r2)) = (Q', W') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  pa_upd_rule Qh Wh (rhsq (r_prod r1 r2)) = (Q', W')\n\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        xa \\<in> ita;\n        ita \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - ita))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> - (ita - {xa})))\n                          (if length (rhsq x) = length (rhsq xa)\n                           then let rp = r_prod x xa;\n                                    (Q, W, \\<delta>d) = \\<sigma>';\n                                    (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                in (Q', W', ls.ins_dj rp \\<delta>d)\n                           else \\<sigma>')", "from pa_upd_rule_correct[OF INVAH(1) PAUF]"], ["proof (chain)\npicking this:\n  hs.invar Q'\n  hs.\\<alpha> Q' = hs.\\<alpha> Qh \\<union> set (rhsq (r_prod r1 r2))\n  \\<exists>Wn.\n     distinct Wn \\<and>\n     set Wn = set (rhsq (r_prod r1 r2)) - hs.\\<alpha> Qh \\<and> W' = Wn @ Wh", "obtain Wnn where UC:\n        \"hs_invar Q'\"\n        \"hs_\\<alpha> Q' = hs_\\<alpha> Qh \\<union> set (rhsq (r_prod r1 r2))\"\n        \"distinct Wnn\" \n        \"set Wnn = set (rhsq (r_prod r1 r2)) - hs_\\<alpha> Qh\" \n        \"W' = Wnn @ Wh\""], ["proof (prove)\nusing this:\n  hs.invar Q'\n  hs.\\<alpha> Q' = hs.\\<alpha> Qh \\<union> set (rhsq (r_prod r1 r2))\n  \\<exists>Wn.\n     distinct Wn \\<and>\n     set Wn = set (rhsq (r_prod r1 r2)) - hs.\\<alpha> Qh \\<and> W' = Wn @ Wh\n\ngoal (1 subgoal):\n 1. (\\<And>Wnn.\n        \\<lbrakk>hs.invar Q';\n         hs.\\<alpha> Q' = hs.\\<alpha> Qh \\<union> set (rhsq (r_prod r1 r2));\n         distinct Wnn; set Wnn = set (rhsq (r_prod r1 r2)) - hs.\\<alpha> Qh;\n         W' = Wnn @ Wh\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast\n\n      \\<comment> \\<open>Put it all together\\<close>"], ["proof (state)\nthis:\n  hs.invar Q'\n  hs.\\<alpha> Q' = hs.\\<alpha> Qh \\<union> set (rhsq (r_prod r1 r2))\n  distinct Wnn\n  set Wnn = set (rhsq (r_prod r1 r2)) - hs.\\<alpha> Qh\n  W' = Wnn @ Wh\n\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        xa \\<in> ita;\n        ita \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - ita))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> - (ita - {xa})))\n                          (if length (rhsq x) = length (rhsq xa)\n                           then let rp = r_prod x xa;\n                                    (Q, W, \\<delta>d) = \\<sigma>';\n                                    (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                in (Q', W', ls.ins_dj rp \\<delta>d)\n                           else \\<sigma>')", "have ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n          (ls.\\<alpha> h2.\\<delta>) \\<union>\n         \\<delta>_prod {r1} (ls.\\<alpha> h2.\\<delta> - (it2 - {r2})))\n     (if length (rhsq r1) = length (rhsq r2)\n      then let rp = r_prod r1 r2; (Q, W, \\<delta>d) = resh;\n               (Q', W') = pa_upd_rule Q W (rhsq rp)\n           in (Q', W', ls.ins_dj rp \\<delta>d)\n      else resh)", "apply (simp add: LEN Let_def ls.ins_dj_correct[OF INVAH(2) RPD] \n                         PAUF inv_def UC(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>Wn.\n        distinct Wn \\<and>\n        set Wn =\n        f_succ\n         (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n           (ls.\\<alpha> h2.\\<delta>) \\<union>\n          \\<delta>_prod {r1} (insert r2 (ls.\\<alpha> h2.\\<delta> - it2))) ``\n        {(q1, q2)} -\n        hs.\\<alpha> Q \\<and>\n        W' = Wn @ Wtl \\<and>\n        hs.\\<alpha> Q' =\n        hs.\\<alpha> Q \\<union>\n        f_succ\n         (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n           (ls.\\<alpha> h2.\\<delta>) \\<union>\n          \\<delta>_prod {r1} (insert r2 (ls.\\<alpha> h2.\\<delta> - it2))) ``\n        {(q1, q2)}) \\<and>\n    insert (r_prod r1 r2) (ls.\\<alpha> \\<delta>dh) =\n    ls.\\<alpha> \\<delta>d \\<union>\n    {r. (r \\<in> \\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n                  (ls.\\<alpha> h2.\\<delta>) \\<or>\n         r \\<in> \\<delta>_prod {r1}\n                  (insert r2 (ls.\\<alpha> h2.\\<delta> - it2))) \\<and>\n        lhs r = (q1, q2)}", "apply (intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>Wn.\n       distinct Wn \\<and>\n       set Wn =\n       f_succ\n        (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n          (ls.\\<alpha> h2.\\<delta>) \\<union>\n         \\<delta>_prod {r1} (insert r2 (ls.\\<alpha> h2.\\<delta> - it2))) ``\n       {(q1, q2)} -\n       hs.\\<alpha> Q \\<and>\n       W' = Wn @ Wtl \\<and>\n       hs.\\<alpha> Q' =\n       hs.\\<alpha> Q \\<union>\n       f_succ\n        (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n          (ls.\\<alpha> h2.\\<delta>) \\<union>\n         \\<delta>_prod {r1} (insert r2 (ls.\\<alpha> h2.\\<delta> - it2))) ``\n       {(q1, q2)}\n 2. insert (r_prod r1 r2) (ls.\\<alpha> \\<delta>dh) =\n    ls.\\<alpha> \\<delta>d \\<union>\n    {r. (r \\<in> \\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n                  (ls.\\<alpha> h2.\\<delta>) \\<or>\n         r \\<in> \\<delta>_prod {r1}\n                  (insert r2 (ls.\\<alpha> h2.\\<delta> - it2))) \\<and>\n        lhs r = (q1, q2)}", "apply (rule_tac x=\"Wnn@Wn\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct (Wnn @ Wn) \\<and>\n    set (Wnn @ Wn) =\n    f_succ\n     (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n       (ls.\\<alpha> h2.\\<delta>) \\<union>\n      \\<delta>_prod {r1} (insert r2 (ls.\\<alpha> h2.\\<delta> - it2))) ``\n    {(q1, q2)} -\n    hs.\\<alpha> Q \\<and>\n    W' = (Wnn @ Wn) @ Wtl \\<and>\n    hs.\\<alpha> Q' =\n    hs.\\<alpha> Q \\<union>\n    f_succ\n     (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n       (ls.\\<alpha> h2.\\<delta>) \\<union>\n      \\<delta>_prod {r1} (insert r2 (ls.\\<alpha> h2.\\<delta> - it2))) ``\n    {(q1, q2)}\n 2. insert (r_prod r1 r2) (ls.\\<alpha> \\<delta>dh) =\n    ls.\\<alpha> \\<delta>d \\<union>\n    {r. (r \\<in> \\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n                  (ls.\\<alpha> h2.\\<delta>) \\<or>\n         r \\<in> \\<delta>_prod {r1}\n                  (insert r2 (ls.\\<alpha> h2.\\<delta> - it2))) \\<and>\n        lhs r = (q1, q2)}", "apply (auto simp add: f_succ_alt \\<delta>_prod_insert RULE_FMT UC INVH \n                              \\<delta>_prod_sng2_def \\<delta>_prod_sng1_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n        (ls.\\<alpha> h2.\\<delta>) \\<union>\n       \\<delta>_prod {r1} (ls.\\<alpha> h2.\\<delta> - (it2 - {r2})))\n   (if length (rhsq r1) = length (rhsq r2)\n    then let rp = r_prod r1 r2; (Q, W, \\<delta>d) = resh;\n             (Q', W') = pa_upd_rule Q W (rhsq rp)\n         in (Q', W', ls.ins_dj rp \\<delta>d)\n    else resh)\n\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        xa \\<in> ita;\n        ita \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - ita))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> - (ita - {xa})))\n                          (if length (rhsq x) = length (rhsq xa)\n                           then let rp = r_prod x xa;\n                                    (Q, W, \\<delta>d) = \\<sigma>';\n                                    (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                in (Q', W', ls.ins_dj rp \\<delta>d)\n                           else \\<sigma>')", "}"], ["proof (state)\nthis:\n  length (rhsq r1) = length (rhsq r2) \\<Longrightarrow>\n  inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n        (ls.\\<alpha> h2.\\<delta>) \\<union>\n       \\<delta>_prod {r1} (ls.\\<alpha> h2.\\<delta> - (it2 - {r2})))\n   (if length (rhsq r1) = length (rhsq r2)\n    then let rp = r_prod r1 r2; (Q, W, \\<delta>d) = resh;\n             (Q', W') = pa_upd_rule Q W (rhsq rp)\n         in (Q', W', ls.ins_dj rp \\<delta>d)\n    else resh)\n\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma> xa ita \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> (hta_lookup_s q1 H1);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>))\n         \\<sigma>;\n        xa \\<in> ita;\n        ita \\<subseteq> ls.\\<alpha> (hta_lookup_sf q2 (rhsl x) H2);\n        inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n              (ls.\\<alpha> h2.\\<delta>) \\<union>\n             \\<delta>_prod {x} (ls.\\<alpha> h2.\\<delta> - ita))\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it)\n                               (ls.\\<alpha> h2.\\<delta>) \\<union>\n                              \\<delta>_prod {x}\n                               (ls.\\<alpha> h2.\\<delta> - (ita - {xa})))\n                          (if length (rhsq x) = length (rhsq xa)\n                           then let rp = r_prod x xa;\n                                    (Q, W, \\<delta>d) = \\<sigma>';\n                                    (Q', W') = pa_upd_rule Q W (rhsq rp)\n                                in (Q', W', ls.ins_dj rp \\<delta>d)\n                           else \\<sigma>')", "ultimately"], ["proof (chain)\npicking this:\n  length (rhsq r1) \\<noteq> length (rhsq r2) \\<Longrightarrow>\n  inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n        (ls.\\<alpha> h2.\\<delta>) \\<union>\n       \\<delta>_prod {r1} (ls.\\<alpha> h2.\\<delta> - (it2 - {r2})))\n   (if length (rhsq r1) = length (rhsq r2)\n    then let rp = r_prod r1 r2; (Q, W, \\<delta>d) = resh;\n             (Q', W') = pa_upd_rule Q W (rhsq rp)\n         in (Q', W', ls.ins_dj rp \\<delta>d)\n    else resh)\n  length (rhsq r1) = length (rhsq r2) \\<Longrightarrow>\n  inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n        (ls.\\<alpha> h2.\\<delta>) \\<union>\n       \\<delta>_prod {r1} (ls.\\<alpha> h2.\\<delta> - (it2 - {r2})))\n   (if length (rhsq r1) = length (rhsq r2)\n    then let rp = r_prod r1 r2; (Q, W, \\<delta>d) = resh;\n             (Q', W') = pa_upd_rule Q W (rhsq rp)\n         in (Q', W', ls.ins_dj rp \\<delta>d)\n    else resh)", "show ?case"], ["proof (prove)\nusing this:\n  length (rhsq r1) \\<noteq> length (rhsq r2) \\<Longrightarrow>\n  inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n        (ls.\\<alpha> h2.\\<delta>) \\<union>\n       \\<delta>_prod {r1} (ls.\\<alpha> h2.\\<delta> - (it2 - {r2})))\n   (if length (rhsq r1) = length (rhsq r2)\n    then let rp = r_prod r1 r2; (Q, W, \\<delta>d) = resh;\n             (Q', W') = pa_upd_rule Q W (rhsq rp)\n         in (Q', W', ls.ins_dj rp \\<delta>d)\n    else resh)\n  length (rhsq r1) = length (rhsq r2) \\<Longrightarrow>\n  inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n        (ls.\\<alpha> h2.\\<delta>) \\<union>\n       \\<delta>_prod {r1} (ls.\\<alpha> h2.\\<delta> - (it2 - {r2})))\n   (if length (rhsq r1) = length (rhsq r2)\n    then let rp = r_prod r1 r2; (Q, W, \\<delta>d) = resh;\n             (Q', W') = pa_upd_rule Q W (rhsq rp)\n         in (Q', W', ls.ins_dj rp \\<delta>d)\n    else resh)\n\ngoal (1 subgoal):\n 1. inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n          (ls.\\<alpha> h2.\\<delta>) \\<union>\n         \\<delta>_prod {r1} (ls.\\<alpha> h2.\\<delta> - (it2 - {r2})))\n     (if length (rhsq r1) = length (rhsq r2)\n      then let rp = r_prod r1 r2; (Q, W, \\<delta>d) = resh;\n               (Q', W') = pa_upd_rule Q W (rhsq rp)\n           in (Q', W', ls.ins_dj rp \\<delta>d)\n      else resh)", "by blast"], ["proof (state)\nthis:\n  inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta> - it1)\n        (ls.\\<alpha> h2.\\<delta>) \\<union>\n       \\<delta>_prod {r1} (ls.\\<alpha> h2.\\<delta> - (it2 - {r2})))\n   (if length (rhsq r1) = length (rhsq r2)\n    then let rp = r_prod r1 r2; (Q, W, \\<delta>d) = resh;\n             (Q', W') = pa_upd_rule Q W (rhsq rp)\n         in (Q', W', ls.ins_dj rp \\<delta>d)\n    else resh)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta>) (ls.\\<alpha> h2.\\<delta>))\n   (pa_step H1 H2 (Q, W, \\<delta>d))\n\ngoal (2 subgoals):\n 1. pa_step H1 H2 (Q, W, \\<delta>d) \\<in> pa_invar_add\n 2. (pa_\\<alpha> (Q, W, \\<delta>d),\n     pa_\\<alpha> (pa_step H1 H2 (Q, W, \\<delta>d)))\n    \\<in> frp_step (ls.\\<alpha> h1.\\<delta>) (ls.\\<alpha> h2.\\<delta>)", "from G"], ["proof (chain)\npicking this:\n  inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta>) (ls.\\<alpha> h2.\\<delta>))\n   (pa_step H1 H2 (Q, W, \\<delta>d))", "show ?T1"], ["proof (prove)\nusing this:\n  inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta>) (ls.\\<alpha> h2.\\<delta>))\n   (pa_step H1 H2 (Q, W, \\<delta>d))\n\ngoal (1 subgoal):\n 1. pa_step H1 H2 (Q, W, \\<delta>d) \\<in> pa_invar_add", "by (cases \"pa_step H1 H2 (Q,W,\\<delta>d)\")\n       (simp add: pa_invar_add_def inv_def)"], ["proof (state)\nthis:\n  pa_step H1 H2 (Q, W, \\<delta>d) \\<in> pa_invar_add\n\ngoal (1 subgoal):\n 1. (pa_\\<alpha> (Q, W, \\<delta>d),\n     pa_\\<alpha> (pa_step H1 H2 (Q, W, \\<delta>d)))\n    \\<in> frp_step (ls.\\<alpha> h1.\\<delta>) (ls.\\<alpha> h2.\\<delta>)", "from G"], ["proof (chain)\npicking this:\n  inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta>) (ls.\\<alpha> h2.\\<delta>))\n   (pa_step H1 H2 (Q, W, \\<delta>d))", "show ?T2"], ["proof (prove)\nusing this:\n  inv (\\<delta>_prod (ls.\\<alpha> h1.\\<delta>) (ls.\\<alpha> h2.\\<delta>))\n   (pa_step H1 H2 (Q, W, \\<delta>d))\n\ngoal (1 subgoal):\n 1. (pa_\\<alpha> (Q, W, \\<delta>d),\n     pa_\\<alpha> (pa_step H1 H2 (Q, W, \\<delta>d)))\n    \\<in> frp_step (ls.\\<alpha> h1.\\<delta>) (ls.\\<alpha> h2.\\<delta>)", "by (cases \"pa_step H1 H2 (Q,W,\\<delta>d)\")\n       (auto simp add: inv_def pa_\\<alpha>_def Let_def intro: frp_step.intros)"], ["proof (state)\nthis:\n  (pa_\\<alpha> (Q, W, \\<delta>d),\n   pa_\\<alpha> (pa_step H1 H2 (Q, W, \\<delta>d)))\n  \\<in> frp_step (ls.\\<alpha> h1.\\<delta>) (ls.\\<alpha> h2.\\<delta>)\n\ngoal:\nNo subgoals!", "qed\n    \n  \n\n  \\<comment> \\<open>The product-automaton algorithm is a precise implementation of its\n      specification\\<close>"], ["", "lemma pa_pref_frp: \n  assumes TA: \"hashedTa H1\" \"hashedTa H2\"\n  assumes idx[simp]: \"hta_has_idx_s H1\" \"hta_has_idx_sf H2\"\n\n  shows \"wa_precise_refine (det_wa_wa (pa_det_algo H1 H2)) \n                           (frp_algo (hta_\\<alpha> H1) (hta_\\<alpha> H2)) \n                           pa_\\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wa_precise_refine (det_wa_wa (pa_det_algo H1 H2))\n     (frp_algo (hta_\\<alpha> H1) (hta_\\<alpha> H2)) pa_\\<alpha>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wa_precise_refine (det_wa_wa (pa_det_algo H1 H2))\n     (frp_algo (hta_\\<alpha> H1) (hta_\\<alpha> H2)) pa_\\<alpha>", "interpret h1: hashedTa H1"], ["proof (prove)\ngoal (1 subgoal):\n 1. hashedTa H1", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. wa_precise_refine (det_wa_wa (pa_det_algo H1 H2))\n     (frp_algo (hta_\\<alpha> H1) (hta_\\<alpha> H2)) pa_\\<alpha>", "interpret h2: hashedTa H2"], ["proof (prove)\ngoal (1 subgoal):\n 1. hashedTa H2", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. wa_precise_refine (det_wa_wa (pa_det_algo H1 H2))\n     (frp_algo (hta_\\<alpha> H1) (hta_\\<alpha> H2)) pa_\\<alpha>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. wa_precise_refine (det_wa_wa (pa_det_algo H1 H2))\n     (frp_algo (hta_\\<alpha> H1) (hta_\\<alpha> H2)) pa_\\<alpha>", "apply (unfold_locales)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> wa_invar (det_wa_wa (pa_det_algo H1 H2));\n        s \\<in> wa_cond (det_wa_wa (pa_det_algo H1 H2))\\<rbrakk>\n       \\<Longrightarrow> pa_\\<alpha> s\n                         \\<in> wa_cond\n                                (frp_algo (hta_\\<alpha> H1)\n                                  (hta_\\<alpha> H2))\n 2. \\<And>s s'.\n       \\<lbrakk>s \\<in> wa_invar (det_wa_wa (pa_det_algo H1 H2));\n        s \\<in> wa_cond (det_wa_wa (pa_det_algo H1 H2));\n        (s, s') \\<in> wa_step (det_wa_wa (pa_det_algo H1 H2))\\<rbrakk>\n       \\<Longrightarrow> (pa_\\<alpha> s, pa_\\<alpha> s')\n                         \\<in> wa_step\n                                (frp_algo (hta_\\<alpha> H1)\n                                  (hta_\\<alpha> H2))\n 3. pa_\\<alpha> ` wa_initial (det_wa_wa (pa_det_algo H1 H2))\n    \\<subseteq> wa_initial (frp_algo (hta_\\<alpha> H1) (hta_\\<alpha> H2))\n 4. pa_\\<alpha> ` wa_invar (det_wa_wa (pa_det_algo H1 H2))\n    \\<subseteq> wa_invar (frp_algo (hta_\\<alpha> H1) (hta_\\<alpha> H2))\n 5. \\<forall>s.\n       s \\<in> wa_invar (det_wa_wa (pa_det_algo H1 H2)) \\<and>\n       pa_\\<alpha> s\n       \\<in> wa_cond\n              (frp_algo (hta_\\<alpha> H1)\n                (hta_\\<alpha> H2)) \\<longrightarrow>\n       s \\<in> wa_cond (det_wa_wa (pa_det_algo H1 H2))", "apply (auto simp add: det_wa_wa_def pa_det_algo_def pa_\\<alpha>_def \n                          pa_cond_def frp_algo_def frp_cond_def) [1]"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>s \\<in> wa_invar (det_wa_wa (pa_det_algo H1 H2));\n        s \\<in> wa_cond (det_wa_wa (pa_det_algo H1 H2));\n        (s, s') \\<in> wa_step (det_wa_wa (pa_det_algo H1 H2))\\<rbrakk>\n       \\<Longrightarrow> (pa_\\<alpha> s, pa_\\<alpha> s')\n                         \\<in> wa_step\n                                (frp_algo (hta_\\<alpha> H1)\n                                  (hta_\\<alpha> H2))\n 2. pa_\\<alpha> ` wa_initial (det_wa_wa (pa_det_algo H1 H2))\n    \\<subseteq> wa_initial (frp_algo (hta_\\<alpha> H1) (hta_\\<alpha> H2))\n 3. pa_\\<alpha> ` wa_invar (det_wa_wa (pa_det_algo H1 H2))\n    \\<subseteq> wa_invar (frp_algo (hta_\\<alpha> H1) (hta_\\<alpha> H2))\n 4. \\<forall>s.\n       s \\<in> wa_invar (det_wa_wa (pa_det_algo H1 H2)) \\<and>\n       pa_\\<alpha> s\n       \\<in> wa_cond\n              (frp_algo (hta_\\<alpha> H1)\n                (hta_\\<alpha> H2)) \\<longrightarrow>\n       s \\<in> wa_cond (det_wa_wa (pa_det_algo H1 H2))", "apply (auto simp add: det_wa_wa_def pa_det_algo_def pa_cond_def\n                          hta_\\<alpha>_def frp_algo_def frp_cond_def \n                intro!: pa_step_correct(2)[OF TA]) [1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. pa_\\<alpha> ` wa_initial (det_wa_wa (pa_det_algo H1 H2))\n    \\<subseteq> wa_initial (frp_algo (hta_\\<alpha> H1) (hta_\\<alpha> H2))\n 2. pa_\\<alpha> ` wa_invar (det_wa_wa (pa_det_algo H1 H2))\n    \\<subseteq> wa_invar (frp_algo (hta_\\<alpha> H1) (hta_\\<alpha> H2))\n 3. \\<forall>s.\n       s \\<in> wa_invar (det_wa_wa (pa_det_algo H1 H2)) \\<and>\n       pa_\\<alpha> s\n       \\<in> wa_cond\n              (frp_algo (hta_\\<alpha> H1)\n                (hta_\\<alpha> H2)) \\<longrightarrow>\n       s \\<in> wa_cond (det_wa_wa (pa_det_algo H1 H2))", "apply (auto simp add: det_wa_wa_def pa_det_algo_def pa_\\<alpha>_def \n                          hta_\\<alpha>_def pa_cond_def frp_algo_def frp_cond_def\n                          pa_invar_def pa_step_def pa_initial_def \n                          hs.correct ls.correct Let_def hhh_cart.cart_correct \n                intro: frp_initial.intros\n    ) [3]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  wa_precise_refine (det_wa_wa (pa_det_algo H1 H2))\n   (frp_algo (hta_\\<alpha> H1) (hta_\\<alpha> H2)) pa_\\<alpha>\n\ngoal:\nNo subgoals!", "qed\n\n\n  \\<comment> \\<open>The product automaton algorithm is a correct while-algorithm\\<close>"], ["", "lemma pa_while_algo: \n  assumes TA: \"hashedTa H1\" \"hashedTa H2\"\n  assumes idx[simp]: \"hta_has_idx_s H1\" \"hta_has_idx_sf H2\"\n\n  shows \"while_algo (det_wa_wa (pa_det_algo H1 H2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. while_algo (det_wa_wa (pa_det_algo H1 H2))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. while_algo (det_wa_wa (pa_det_algo H1 H2))", "interpret h1: hashedTa H1"], ["proof (prove)\ngoal (1 subgoal):\n 1. hashedTa H1", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. while_algo (det_wa_wa (pa_det_algo H1 H2))", "interpret h2: hashedTa H2"], ["proof (prove)\ngoal (1 subgoal):\n 1. hashedTa H2", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. while_algo (det_wa_wa (pa_det_algo H1 H2))", "interpret ref: wa_precise_refine \"(det_wa_wa (pa_det_algo H1 H2))\" \n                                   \"(frp_algo (hta_\\<alpha> H1) (hta_\\<alpha> H2))\" \n                                   \"pa_\\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wa_precise_refine (det_wa_wa (pa_det_algo H1 H2))\n     (frp_algo (hta_\\<alpha> H1) (hta_\\<alpha> H2)) pa_\\<alpha>", "using pa_pref_frp[OF TA idx]"], ["proof (prove)\nusing this:\n  wa_precise_refine (det_wa_wa (pa_det_algo H1 H2))\n   (frp_algo (hta_\\<alpha> H1) (hta_\\<alpha> H2)) pa_\\<alpha>\n\ngoal (1 subgoal):\n 1. wa_precise_refine (det_wa_wa (pa_det_algo H1 H2))\n     (frp_algo (hta_\\<alpha> H1) (hta_\\<alpha> H2)) pa_\\<alpha>", "."], ["proof (state)\ngoal (1 subgoal):\n 1. while_algo (det_wa_wa (pa_det_algo H1 H2))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. while_algo (det_wa_wa (pa_det_algo H1 H2))", "apply (rule ref.wa_intro)"], ["proof (prove)\ngoal (4 subgoals):\n 1. while_algo (frp_algo (hta_\\<alpha> H1) (hta_\\<alpha> H2))\n 2. wa_invar (det_wa_wa (pa_det_algo H1 H2)) =\n    ?addi \\<inter>\n    {s. pa_\\<alpha> s\n        \\<in> wa_invar (frp_algo (hta_\\<alpha> H1) (hta_\\<alpha> H2))}\n 3. \\<And>s s'.\n       \\<lbrakk>s \\<in> ?addi;\n        s \\<in> wa_cond (det_wa_wa (pa_det_algo H1 H2));\n        pa_\\<alpha> s\n        \\<in> wa_invar (frp_algo (hta_\\<alpha> H1) (hta_\\<alpha> H2));\n        (s, s') \\<in> wa_step (det_wa_wa (pa_det_algo H1 H2))\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> ?addi\n 4. wa_initial (det_wa_wa (pa_det_algo H1 H2)) \\<subseteq> ?addi", "apply (simp add: frp_while_algo)"], ["proof (prove)\ngoal (3 subgoals):\n 1. wa_invar (det_wa_wa (pa_det_algo H1 H2)) =\n    ?addi \\<inter>\n    {s. pa_\\<alpha> s\n        \\<in> wa_invar (frp_algo (hta_\\<alpha> H1) (hta_\\<alpha> H2))}\n 2. \\<And>s s'.\n       \\<lbrakk>s \\<in> ?addi;\n        s \\<in> wa_cond (det_wa_wa (pa_det_algo H1 H2));\n        pa_\\<alpha> s\n        \\<in> wa_invar (frp_algo (hta_\\<alpha> H1) (hta_\\<alpha> H2));\n        (s, s') \\<in> wa_step (det_wa_wa (pa_det_algo H1 H2))\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> ?addi\n 3. wa_initial (det_wa_wa (pa_det_algo H1 H2)) \\<subseteq> ?addi", "apply (simp add: det_wa_wa_def pa_det_algo_def pa_invar_def frp_algo_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>s \\<in> pa_invar_add;\n        s \\<in> wa_cond (det_wa_wa (pa_det_algo H1 H2));\n        pa_\\<alpha> s\n        \\<in> wa_invar (frp_algo (hta_\\<alpha> H1) (hta_\\<alpha> H2));\n        (s, s') \\<in> wa_step (det_wa_wa (pa_det_algo H1 H2))\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> pa_invar_add\n 2. wa_initial (det_wa_wa (pa_det_algo H1 H2)) \\<subseteq> pa_invar_add", "apply (auto simp add: det_wa_wa_def pa_det_algo_def) [1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ab ac ba ad ae bb.\n       \\<lbrakk>(ad, ae, bb) \\<in> pa_invar_add; pa_cond (ad, ae, bb);\n        pa_\\<alpha> (ad, ae, bb)\n        \\<in> wa_invar (frp_algo (hta_\\<alpha> H1) (hta_\\<alpha> H2));\n        (ab, ac, ba) = pa_step H1 H2 (ad, ae, bb)\\<rbrakk>\n       \\<Longrightarrow> pa_step H1 H2 (ad, ae, bb) \\<in> pa_invar_add\n 2. wa_initial (det_wa_wa (pa_det_algo H1 H2)) \\<subseteq> pa_invar_add", "apply (rule pa_step_correct(1)[OF TA idx])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ab ac ba ad ae bb.\n       \\<lbrakk>(ad, ae, bb) \\<in> pa_invar_add; pa_cond (ad, ae, bb);\n        pa_\\<alpha> (ad, ae, bb)\n        \\<in> wa_invar (frp_algo (hta_\\<alpha> H1) (hta_\\<alpha> H2));\n        (ab, ac, ba) = pa_step H1 H2 (ad, ae, bb)\\<rbrakk>\n       \\<Longrightarrow> (ad, ae, bb) \\<in> pa_invar H1 H2\n 2. \\<And>ab ac ba ad ae bb.\n       \\<lbrakk>(ad, ae, bb) \\<in> pa_invar_add; pa_cond (ad, ae, bb);\n        pa_\\<alpha> (ad, ae, bb)\n        \\<in> wa_invar (frp_algo (hta_\\<alpha> H1) (hta_\\<alpha> H2));\n        (ab, ac, ba) = pa_step H1 H2 (ad, ae, bb)\\<rbrakk>\n       \\<Longrightarrow> pa_cond (ad, ae, bb)\n 3. wa_initial (det_wa_wa (pa_det_algo H1 H2)) \\<subseteq> pa_invar_add", "apply (auto simp add: pa_invar_def frp_algo_def) [2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. wa_initial (det_wa_wa (pa_det_algo H1 H2)) \\<subseteq> pa_invar_add", "apply (simp add: det_wa_wa_def pa_det_algo_def pa_initial_def \n                     pa_invar_add_def Let_def hhh_cart.cart_correct ls.correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  while_algo (det_wa_wa (pa_det_algo H1 H2))\n\ngoal:\nNo subgoals!", "qed\n    \n\\<comment> \\<open>By definition, the product automaton algorithm is deterministic\\<close>"], ["", "lemmas pa_det_while_algo = det_while_algo_intro[OF pa_while_algo]\n\n\\<comment> \\<open>Transferred correctness lemma\\<close>"], ["", "lemmas pa_inv_final = \n  wa_precise_refine.transfer_correctness[OF pa_pref_frp frp_inv_final]\n\n\n\\<comment> \\<open>The next two definitions specify the product-automata algorithm. The first\n    version requires the s-index of the first and the sf-index of the second\n    automaton to be present, while the second version computes the required \n    indices, if necessary\\<close>"], ["", "definition \"hta_prod' H1 H2 ==\n  let (Q,W,\\<delta>d) = while pa_cond (pa_step H1 H2) (pa_initial H1 H2) in\n    init_hta (hhh_cart.cart (hta_Qi H1) (hta_Qi H2)) \\<delta>d\n  \""], ["", "definition \"hta_prod H1 H2 == \n  hta_prod' (hta_ensure_idx_s H1) (hta_ensure_idx_sf H2)\""], ["", "lemma hta_prod'_correct_aux:\n  assumes TA: \"hashedTa H1\" \"hashedTa H2\"\n  assumes idx: \"hta_has_idx_s H1\" \"hta_has_idx_sf H2\"\n  shows \"hta_\\<alpha> (hta_prod' H1 H2) \n         = ta_fwd_reduce (ta_prod (hta_\\<alpha> H1) (hta_\\<alpha> H2))\" (is ?T1)\n        \"hashedTa (hta_prod' H1 H2)\" (is ?T2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hta_\\<alpha> (hta_prod' H1 H2) =\n    ta_fwd_reduce (ta_prod (hta_\\<alpha> H1) (hta_\\<alpha> H2)) &&&\n    hashedTa (hta_prod' H1 H2)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. hta_\\<alpha> (hta_prod' H1 H2) =\n    ta_fwd_reduce (ta_prod (hta_\\<alpha> H1) (hta_\\<alpha> H2))\n 2. hashedTa (hta_prod' H1 H2)", "interpret h1: hashedTa H1"], ["proof (prove)\ngoal (1 subgoal):\n 1. hashedTa H1", "by fact"], ["proof (state)\ngoal (2 subgoals):\n 1. hta_\\<alpha> (hta_prod' H1 H2) =\n    ta_fwd_reduce (ta_prod (hta_\\<alpha> H1) (hta_\\<alpha> H2))\n 2. hashedTa (hta_prod' H1 H2)", "interpret h2: hashedTa H2"], ["proof (prove)\ngoal (1 subgoal):\n 1. hashedTa H2", "by fact"], ["proof (state)\ngoal (2 subgoals):\n 1. hta_\\<alpha> (hta_prod' H1 H2) =\n    ta_fwd_reduce (ta_prod (hta_\\<alpha> H1) (hta_\\<alpha> H2))\n 2. hashedTa (hta_prod' H1 H2)", "interpret dwa: det_while_algo \"pa_det_algo H1 H2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det_while_algo (pa_det_algo H1 H2)", "using pa_det_while_algo[OF TA idx]"], ["proof (prove)\nusing this:\n  det_while_algo (pa_det_algo H1 H2)\n\ngoal (1 subgoal):\n 1. det_while_algo (pa_det_algo H1 H2)", "."], ["proof (state)\ngoal (2 subgoals):\n 1. hta_\\<alpha> (hta_prod' H1 H2) =\n    ta_fwd_reduce (ta_prod (hta_\\<alpha> H1) (hta_\\<alpha> H2))\n 2. hashedTa (hta_prod' H1 H2)", "have LC: \"while pa_cond (pa_step H1 H2) (pa_initial H1 H2) = dwa.loop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. while pa_cond (pa_step H1 H2) (pa_initial H1 H2) = dwa.loop", "by (unfold dwa.loop_def)\n       (simp add: pa_det_algo_def)"], ["proof (state)\nthis:\n  while pa_cond (pa_step H1 H2) (pa_initial H1 H2) = dwa.loop\n\ngoal (2 subgoals):\n 1. hta_\\<alpha> (hta_prod' H1 H2) =\n    ta_fwd_reduce (ta_prod (hta_\\<alpha> H1) (hta_\\<alpha> H2))\n 2. hashedTa (hta_prod' H1 H2)", "from dwa.while_proof'[OF pa_inv_final[OF TA idx]]"], ["proof (chain)\npicking this:\n  case pa_\\<alpha> dwa.loop of\n  (Q, W, \\<delta>d) \\<Rightarrow>\n    \\<lparr>ta_initial =\n              ta_initial (hta_\\<alpha> H1) \\<times>\n              ta_initial (hta_\\<alpha> H2),\n       ta_rules = \\<delta>d\\<rparr> =\n    ta_fwd_reduce (ta_prod (hta_\\<alpha> H1) (hta_\\<alpha> H2))", "show ?T1"], ["proof (prove)\nusing this:\n  case pa_\\<alpha> dwa.loop of\n  (Q, W, \\<delta>d) \\<Rightarrow>\n    \\<lparr>ta_initial =\n              ta_initial (hta_\\<alpha> H1) \\<times>\n              ta_initial (hta_\\<alpha> H2),\n       ta_rules = \\<delta>d\\<rparr> =\n    ta_fwd_reduce (ta_prod (hta_\\<alpha> H1) (hta_\\<alpha> H2))\n\ngoal (1 subgoal):\n 1. hta_\\<alpha> (hta_prod' H1 H2) =\n    ta_fwd_reduce (ta_prod (hta_\\<alpha> H1) (hta_\\<alpha> H2))", "apply (unfold dwa.loop_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. case pa_\\<alpha>\n          (while (dwa_cond (pa_det_algo H1 H2))\n            (dwa_step (pa_det_algo H1 H2))\n            (dwa_initial (pa_det_algo H1 H2))) of\n    (Q, W, \\<delta>d) \\<Rightarrow>\n      \\<lparr>ta_initial =\n                ta_initial (hta_\\<alpha> H1) \\<times>\n                ta_initial (hta_\\<alpha> H2),\n         ta_rules = \\<delta>d\\<rparr> =\n      ta_fwd_reduce\n       (ta_prod (hta_\\<alpha> H1) (hta_\\<alpha> H2)) \\<Longrightarrow>\n    hta_\\<alpha> (hta_prod' H1 H2) =\n    ta_fwd_reduce (ta_prod (hta_\\<alpha> H1) (hta_\\<alpha> H2))", "apply (simp add: hta_prod'_def init_hta_def hta_\\<alpha>_def pa_det_algo_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. case pa_\\<alpha> (while pa_cond (pa_step H1 H2) (pa_initial H1 H2)) of\n    (Q, W, \\<delta>d) \\<Rightarrow>\n      \\<lparr>ta_initial = hs.\\<alpha> h1.Qi \\<times> hs.\\<alpha> h2.Qi,\n         ta_rules = \\<delta>d\\<rparr> =\n      ta_fwd_reduce\n       (ta_prod\n         \\<lparr>ta_initial = hs.\\<alpha> h1.Qi,\n            ta_rules = ls.\\<alpha> h1.\\<delta>\\<rparr>\n         \\<lparr>ta_initial = hs.\\<alpha> h2.Qi,\n            ta_rules = ls.\\<alpha> h2.\\<delta>\\<rparr>) \\<Longrightarrow>\n    \\<lparr>ta_initial =\n              hs.\\<alpha>\n               (hta_Qi\n                 (case while pa_cond (pa_step H1 H2) (pa_initial H1 H2) of\n                  (Q, W, \\<delta>d) \\<Rightarrow>\n                    \\<lparr>hta_Qi = hhh_cart.cart h1.Qi h2.Qi,\n                       hta_\\<delta> = \\<delta>d, hta_idx_f = None,\n                       hta_idx_s = None, hta_idx_sf = None\\<rparr>)),\n       ta_rules =\n         ls.\\<alpha>\n          (hta_\\<delta>\n            (case while pa_cond (pa_step H1 H2) (pa_initial H1 H2) of\n             (Q, W, \\<delta>d) \\<Rightarrow>\n               \\<lparr>hta_Qi = hhh_cart.cart h1.Qi h2.Qi,\n                  hta_\\<delta> = \\<delta>d, hta_idx_f = None,\n                  hta_idx_s = None, hta_idx_sf = None\\<rparr>))\\<rparr> =\n    ta_fwd_reduce\n     (ta_prod\n       \\<lparr>ta_initial = hs.\\<alpha> h1.Qi,\n          ta_rules = ls.\\<alpha> h1.\\<delta>\\<rparr>\n       \\<lparr>ta_initial = hs.\\<alpha> h2.Qi,\n          ta_rules = ls.\\<alpha> h2.\\<delta>\\<rparr>)", "apply (cases \"(while pa_cond (pa_step H1 H2) (pa_initial H1 H2))\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>case pa_\\<alpha>\n                      (while pa_cond (pa_step H1 H2) (pa_initial H1 H2)) of\n                (Q, W, \\<delta>d) \\<Rightarrow>\n                  \\<lparr>ta_initial =\n                            hs.\\<alpha> h1.Qi \\<times> hs.\\<alpha> h2.Qi,\n                     ta_rules = \\<delta>d\\<rparr> =\n                  ta_fwd_reduce\n                   (ta_prod\n                     \\<lparr>ta_initial = hs.\\<alpha> h1.Qi,\n                        ta_rules = ls.\\<alpha> h1.\\<delta>\\<rparr>\n                     \\<lparr>ta_initial = hs.\\<alpha> h2.Qi,\n                        ta_rules = ls.\\<alpha> h2.\\<delta>\\<rparr>);\n        while pa_cond (pa_step H1 H2) (pa_initial H1 H2) =\n        (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>ta_initial =\n                                   hs.\\<alpha>\n                                    (hta_Qi\n(case while pa_cond (pa_step H1 H2) (pa_initial H1 H2) of\n (Q, W, \\<delta>d) \\<Rightarrow>\n   \\<lparr>hta_Qi = hhh_cart.cart h1.Qi h2.Qi, hta_\\<delta> = \\<delta>d,\n      hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr>)),\n                            ta_rules =\n                              ls.\\<alpha>\n                               (hta_\\<delta>\n                                 (case while pa_cond (pa_step H1 H2)\n  (pa_initial H1 H2) of\n                                  (Q, W, \\<delta>d) \\<Rightarrow>\n                                    \\<lparr>hta_Qi =\n        hhh_cart.cart h1.Qi h2.Qi,\n hta_\\<delta> = \\<delta>d, hta_idx_f = None, hta_idx_s = None,\n hta_idx_sf = None\\<rparr>))\\<rparr> =\n                         ta_fwd_reduce\n                          (ta_prod\n                            \\<lparr>ta_initial = hs.\\<alpha> h1.Qi,\n                               ta_rules = ls.\\<alpha> h1.\\<delta>\\<rparr>\n                            \\<lparr>ta_initial = hs.\\<alpha> h2.Qi,\n                               ta_rules = ls.\\<alpha> h2.\\<delta>\\<rparr>)", "apply (simp add: pa_\\<alpha>_def hhh_cart.cart_correct hta_\\<alpha>_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  hta_\\<alpha> (hta_prod' H1 H2) =\n  ta_fwd_reduce (ta_prod (hta_\\<alpha> H1) (hta_\\<alpha> H2))\n\ngoal (1 subgoal):\n 1. hashedTa (hta_prod' H1 H2)", "show ?T2"], ["proof (prove)\ngoal (1 subgoal):\n 1. hashedTa (hta_prod' H1 H2)", "apply (simp add: hta_prod'_def LC)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hashedTa\n     (case dwa.loop of\n      (Q, W, xa) \\<Rightarrow> init_hta (hhh_cart.cart h1.Qi h2.Qi) xa)", "apply (rule dwa.while_proof)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> dwa_invar (pa_det_algo H1 H2);\n        \\<not> dwa_cond (pa_det_algo H1 H2) s\\<rbrakk>\n       \\<Longrightarrow> hashedTa\n                          (case s of\n                           (Q, W, b) \\<Rightarrow>\n                             init_hta (hhh_cart.cart h1.Qi h2.Qi) b)", "apply (case_tac s)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s a b c.\n       \\<lbrakk>s \\<in> dwa_invar (pa_det_algo H1 H2);\n        \\<not> dwa_cond (pa_det_algo H1 H2) s; s = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> hashedTa\n                          (case s of\n                           (Q, W, b) \\<Rightarrow>\n                             init_hta (hhh_cart.cart h1.Qi h2.Qi) b)", "apply (simp add: pa_det_algo_def pa_invar_add_def pa_invar_def init_hta_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s a b c.\n       \\<lbrakk>pa_\\<alpha> (a, b, c)\n                \\<in> frp_invar (hta_\\<alpha> H1) (hta_\\<alpha> H2);\n        \\<not> pa_cond (a, b, c); s = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> hashedTa\n                          \\<lparr>hta_Qi = hhh_cart.cart h1.Qi h2.Qi,\n                             hta_\\<delta> = c, hta_idx_f = None,\n                             hta_idx_s = None, hta_idx_sf = None\\<rparr>", "apply unfold_locales"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s a b c.\n       \\<lbrakk>pa_\\<alpha> (a, b, c)\n                \\<in> frp_invar (hta_\\<alpha> H1) (hta_\\<alpha> H2);\n        \\<not> pa_cond (a, b, c); s = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> hs.invar\n                          (hta_Qi\n                            \\<lparr>hta_Qi = hhh_cart.cart h1.Qi h2.Qi,\n                               hta_\\<delta> = c, hta_idx_f = None,\n                               hta_idx_s = None, hta_idx_sf = None\\<rparr>)\n 2. \\<And>s a b c.\n       \\<lbrakk>pa_\\<alpha> (a, b, c)\n                \\<in> frp_invar (hta_\\<alpha> H1) (hta_\\<alpha> H2);\n        \\<not> pa_cond (a, b, c); s = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> ls.invar\n                          (hta_\\<delta>\n                            \\<lparr>hta_Qi = hhh_cart.cart h1.Qi h2.Qi,\n                               hta_\\<delta> = c, hta_idx_f = None,\n                               hta_idx_s = None, hta_idx_sf = None\\<rparr>)\n 3. \\<And>s a b c idx_f.\n       \\<lbrakk>pa_\\<alpha> (a, b, c)\n                \\<in> frp_invar (hta_\\<alpha> H1) (hta_\\<alpha> H2);\n        \\<not> pa_cond (a, b, c); s = (a, b, c);\n        hta_idx_f\n         \\<lparr>hta_Qi = hhh_cart.cart h1.Qi h2.Qi, hta_\\<delta> = c,\n            hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr> =\n        Some idx_f\\<rbrakk>\n       \\<Longrightarrow> hll_idx.is_index rhsl\n                          (ls.\\<alpha>\n                            (hta_\\<delta>\n                              \\<lparr>hta_Qi = hhh_cart.cart h1.Qi h2.Qi,\n                                 hta_\\<delta> = c, hta_idx_f = None,\n                                 hta_idx_s = None,\n                                 hta_idx_sf = None\\<rparr>))\n                          idx_f\n 4. \\<And>s a b c idx_s.\n       \\<lbrakk>pa_\\<alpha> (a, b, c)\n                \\<in> frp_invar (hta_\\<alpha> H1) (hta_\\<alpha> H2);\n        \\<not> pa_cond (a, b, c); s = (a, b, c);\n        hta_idx_s\n         \\<lparr>hta_Qi = hhh_cart.cart h1.Qi h2.Qi, hta_\\<delta> = c,\n            hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr> =\n        Some idx_s\\<rbrakk>\n       \\<Longrightarrow> hll_idx.is_index lhs\n                          (ls.\\<alpha>\n                            (hta_\\<delta>\n                              \\<lparr>hta_Qi = hhh_cart.cart h1.Qi h2.Qi,\n                                 hta_\\<delta> = c, hta_idx_f = None,\n                                 hta_idx_s = None,\n                                 hta_idx_sf = None\\<rparr>))\n                          idx_s\n 5. \\<And>s a b c idx_sf.\n       \\<lbrakk>pa_\\<alpha> (a, b, c)\n                \\<in> frp_invar (hta_\\<alpha> H1) (hta_\\<alpha> H2);\n        \\<not> pa_cond (a, b, c); s = (a, b, c);\n        hta_idx_sf\n         \\<lparr>hta_Qi = hhh_cart.cart h1.Qi h2.Qi, hta_\\<delta> = c,\n            hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr> =\n        Some idx_sf\\<rbrakk>\n       \\<Longrightarrow> hll_idx.is_index (\\<lambda>r. (lhs r, rhsl r))\n                          (ls.\\<alpha>\n                            (hta_\\<delta>\n                              \\<lparr>hta_Qi = hhh_cart.cart h1.Qi h2.Qi,\n                                 hta_\\<delta> = c, hta_idx_f = None,\n                                 hta_idx_s = None,\n                                 hta_idx_sf = None\\<rparr>))\n                          idx_sf", "apply (simp_all add: hhh_cart.cart_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  hashedTa (hta_prod' H1 H2)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem hta_prod'_correct:\n  assumes TA: \"hashedTa H1\" \"hashedTa H2\"\n  assumes HI: \"hta_has_idx_s H1\" \"hta_has_idx_sf H2\"\n  shows \n    \"ta_lang (hta_\\<alpha> (hta_prod' H1 H2)) \n     = ta_lang (hta_\\<alpha> H1) \\<inter> ta_lang (hta_\\<alpha> H2)\"\n\n    \"hashedTa (hta_prod' H1 H2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_lang (hta_\\<alpha> (hta_prod' H1 H2)) =\n    ta_lang (hta_\\<alpha> H1) \\<inter> ta_lang (hta_\\<alpha> H2) &&&\n    hashedTa (hta_prod' H1 H2)", "by (simp_all add: hta_prod'_correct_aux[OF TA HI] ta_prod_correct_aux1)"], ["", "lemma hta_prod_correct_aux:\n  assumes TA[simp]: \"hashedTa H1\" \"hashedTa H2\"\n  shows \n    \"hta_\\<alpha> (hta_prod H1 H2) = ta_fwd_reduce (ta_prod (hta_\\<alpha> H1) (hta_\\<alpha> H2))\"\n    \"hashedTa (hta_prod H1 H2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hta_\\<alpha> (hta_prod H1 H2) =\n    ta_fwd_reduce (ta_prod (hta_\\<alpha> H1) (hta_\\<alpha> H2)) &&&\n    hashedTa (hta_prod H1 H2)", "by (unfold hta_prod_def)\n     (simp_all add: hta_prod'_correct_aux)"], ["", "theorem hta_prod_correct:\n  assumes TA: \"hashedTa H1\" \"hashedTa H2\"\n  shows \n    \"ta_lang (hta_\\<alpha> (hta_prod H1 H2)) \n     = ta_lang (hta_\\<alpha> H1) \\<inter> ta_lang (hta_\\<alpha> H2)\"\n    \"hashedTa (hta_prod H1 H2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_lang (hta_\\<alpha> (hta_prod H1 H2)) =\n    ta_lang (hta_\\<alpha> H1) \\<inter> ta_lang (hta_\\<alpha> H2) &&&\n    hashedTa (hta_prod H1 H2)", "by (simp_all add: hta_prod_correct_aux[OF TA] ta_prod_correct_aux1)"], ["", "subsection \"Remap States\"\n\n\\<comment> \\<open>Mapping the states of an automaton\\<close>"], ["", "definition hta_remap \n  :: \"('q::hashable \\<Rightarrow> 'qn::hashable) \\<Rightarrow> ('q,'l::hashable) hashedTa \n      \\<Rightarrow> ('qn,'l) hashedTa\" \n  where \"hta_remap f H == \n    init_hta (hh_set_xy.g_image f (hta_Qi H)) \n      (ll_set_xy.g_image (remap_rule f) (hta_\\<delta> H))\""], ["", "lemma (in hashedTa) hta_remap_correct:\n  shows \"hta_\\<alpha> (hta_remap f H) = ta_remap f (hta_\\<alpha> H)\"\n        \"hashedTa (hta_remap f H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hta_\\<alpha> (hta_remap f H) = ta_remap f (hta_\\<alpha> H) &&&\n    hashedTa (hta_remap f H)", "apply (auto \n    simp add: hta_remap_def init_hta_def hta_\\<alpha>_def \n              hh_set_xy.image_correct ll_set_xy.image_correct ta_remap_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hashedTa\n     \\<lparr>hta_Qi = hh_set_xy.g_image f Qi,\n        hta_\\<delta> = ll_set_xy.g_image (remap_rule f) \\<delta>,\n        hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr>", "apply (unfold_locales)"], ["proof (prove)\ngoal (5 subgoals):\n 1. hs.invar\n     (hta_Qi\n       \\<lparr>hta_Qi = hh_set_xy.g_image f Qi,\n          hta_\\<delta> = ll_set_xy.g_image (remap_rule f) \\<delta>,\n          hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr>)\n 2. ls.invar\n     (hta_\\<delta>\n       \\<lparr>hta_Qi = hh_set_xy.g_image f Qi,\n          hta_\\<delta> = ll_set_xy.g_image (remap_rule f) \\<delta>,\n          hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr>)\n 3. \\<And>idx_f.\n       hta_idx_f\n        \\<lparr>hta_Qi = hh_set_xy.g_image f Qi,\n           hta_\\<delta> = ll_set_xy.g_image (remap_rule f) \\<delta>,\n           hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr> =\n       Some idx_f \\<Longrightarrow>\n       hll_idx.is_index rhsl\n        (ls.\\<alpha>\n          (hta_\\<delta>\n            \\<lparr>hta_Qi = hh_set_xy.g_image f Qi,\n               hta_\\<delta> = ll_set_xy.g_image (remap_rule f) \\<delta>,\n               hta_idx_f = None, hta_idx_s = None,\n               hta_idx_sf = None\\<rparr>))\n        idx_f\n 4. \\<And>idx_s.\n       hta_idx_s\n        \\<lparr>hta_Qi = hh_set_xy.g_image f Qi,\n           hta_\\<delta> = ll_set_xy.g_image (remap_rule f) \\<delta>,\n           hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr> =\n       Some idx_s \\<Longrightarrow>\n       hll_idx.is_index lhs\n        (ls.\\<alpha>\n          (hta_\\<delta>\n            \\<lparr>hta_Qi = hh_set_xy.g_image f Qi,\n               hta_\\<delta> = ll_set_xy.g_image (remap_rule f) \\<delta>,\n               hta_idx_f = None, hta_idx_s = None,\n               hta_idx_sf = None\\<rparr>))\n        idx_s\n 5. \\<And>idx_sf.\n       hta_idx_sf\n        \\<lparr>hta_Qi = hh_set_xy.g_image f Qi,\n           hta_\\<delta> = ll_set_xy.g_image (remap_rule f) \\<delta>,\n           hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr> =\n       Some idx_sf \\<Longrightarrow>\n       hll_idx.is_index (\\<lambda>r. (lhs r, rhsl r))\n        (ls.\\<alpha>\n          (hta_\\<delta>\n            \\<lparr>hta_Qi = hh_set_xy.g_image f Qi,\n               hta_\\<delta> = ll_set_xy.g_image (remap_rule f) \\<delta>,\n               hta_idx_f = None, hta_idx_s = None,\n               hta_idx_sf = None\\<rparr>))\n        idx_sf", "apply (auto simp add: hh_set_xy.image_correct ll_set_xy.image_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \"Reindex Automaton\""], ["", "text \\<open>\n  In this section, an algorithm for re-indexing the states of the automaton to\n  an initial segment of the naturals is implemented. The language of the \n  automaton is not changed by the reindexing operation.\n\\<close>\n\n  \\<comment> \\<open>Set of states of a rule\\<close>"], ["", "fun rule_states_l where\n  \"rule_states_l (q \\<rightarrow> f qs) = ls_ins q (ls.from_list qs)\""], ["", "lemma rule_states_l_correct[simp]: \n  \"ls_\\<alpha> (rule_states_l r) = rule_states r\"\n  \"ls_invar (rule_states_l r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ls.\\<alpha> (rule_states_l r) = rule_states r &&&\n    ls.invar (rule_states_l r)", "by (cases r, simp add: ls.correct)+"], ["", "definition \"hta_\\<delta>_states H \n  == (llh_set_xyy.g_Union_image id (ll_set_xy.g_image_filter \n       (\\<lambda>r. Some (rule_states_l r)) (hta_\\<delta> H)))\""], ["", "definition \"hta_states H ==\n  hs_union (hta_Qi H) (hta_\\<delta>_states H)\""], ["", "lemma (in hashedTa) hta_\\<delta>_states_correct:\n  \"hs_\\<alpha> (hta_\\<delta>_states H) = \\<delta>_states (ta_rules (hta_\\<alpha> H))\"\n  \"hs_invar (hta_\\<delta>_states H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hs.\\<alpha> (hta_\\<delta>_states H) =\n    \\<delta>_states (ta_rules (hta_\\<alpha> H)) &&&\n    hs.invar (hta_\\<delta>_states H)", "proof (simp_all add: hta_\\<alpha>_def hta_\\<delta>_states_def, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. hs.\\<alpha>\n     (llh_set_xyy.g_Union_image id\n       (ll_set_xy.g_image_filter (\\<lambda>r. Some (rule_states_l r))\n         \\<delta>)) =\n    \\<delta>_states (ls.\\<alpha> \\<delta>)", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. hs.\\<alpha>\n     (llh_set_xyy.g_Union_image id\n       (ll_set_xy.g_image_filter (\\<lambda>r. Some (rule_states_l r))\n         \\<delta>)) =\n    \\<delta>_states (ls.\\<alpha> \\<delta>)", "have \n    [simp]: \"ls_\\<alpha> (ll_set_xy.g_image_filter (\\<lambda>x. Some (rule_states_l x)) \\<delta>) \n             = rule_states_l ` ls_\\<alpha> \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ls.\\<alpha>\n     (ll_set_xy.g_image_filter (\\<lambda>x. Some (rule_states_l x))\n       \\<delta>) =\n    rule_states_l ` ls.\\<alpha> \\<delta>", "by (auto simp add: ll_set_xy.image_filter_correct)"], ["proof (state)\nthis:\n  ls.\\<alpha>\n   (ll_set_xy.g_image_filter (\\<lambda>x. Some (rule_states_l x))\n     \\<delta>) =\n  rule_states_l ` ls.\\<alpha> \\<delta>\n\ngoal (1 subgoal):\n 1. hs.\\<alpha>\n     (llh_set_xyy.g_Union_image id\n       (ll_set_xy.g_image_filter (\\<lambda>r. Some (rule_states_l r))\n         \\<delta>)) =\n    \\<delta>_states (ls.\\<alpha> \\<delta>)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. hs.\\<alpha>\n     (llh_set_xyy.g_Union_image id\n       (ll_set_xy.g_image_filter (\\<lambda>r. Some (rule_states_l r))\n         \\<delta>)) =\n    \\<delta>_states (ls.\\<alpha> \\<delta>)", "apply (simp add: \\<delta>_states_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hs.\\<alpha>\n     (llh_set_xyy.g_Union_image id\n       (ll_set_xy.g_image_filter (\\<lambda>r. Some (rule_states_l r))\n         \\<delta>)) =\n    \\<Union> (rule_states ` ls.\\<alpha> \\<delta>)", "apply (subst\n      llh_set_xyy.Union_image_correct[\n        of \"(ll_set_xy.g_image_filter (\\<lambda>x. Some (rule_states_l x)) \\<delta>)\", \n        simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>ls.\\<alpha> \\<delta>.\n        ls.\\<alpha> (id (rule_states_l x))) =\n    \\<Union> (rule_states ` ls.\\<alpha> \\<delta>)", "apply (auto simp add: ll_set_xy.image_filter_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  hs.\\<alpha>\n   (llh_set_xyy.g_Union_image id\n     (ll_set_xy.g_image_filter (\\<lambda>r. Some (rule_states_l r))\n       \\<delta>)) =\n  \\<delta>_states (ls.\\<alpha> \\<delta>)\n\ngoal:\nNo subgoals!", "(*next\n  case goal2 thus ?case\n    apply (rule llh.Union_image_correct)\n    apply (auto simp add: ls.image_filter_correct)\n    done*)"], ["proof (state)\nthis:\n  hs.\\<alpha>\n   (llh_set_xyy.g_Union_image id\n     (ll_set_xy.g_image_filter (\\<lambda>r. Some (rule_states_l r))\n       \\<delta>)) =\n  \\<delta>_states (ls.\\<alpha> \\<delta>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in hashedTa) hta_states_correct:\n  \"hs_\\<alpha> (hta_states H) = ta_rstates (hta_\\<alpha> H)\"\n  \"hs_invar (hta_states H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hs.\\<alpha> (hta_states H) = ta_rstates (hta_\\<alpha> H) &&&\n    hs.invar (hta_states H)", "by (simp_all \n    add: hta_states_def ta_rstates_def hs.correct hta_\\<delta>_states_correct \n         hta_\\<alpha>_def)"], ["", "definition \"reindex_map H == \n  \\<lambda>q. the (hm_lookup q (hh_map_to_nat.map_to_nat (hta_states H)))\""], ["", "definition hta_reindex \n  :: \"('Q::hashable,'L::hashable) hashedTa \\<Rightarrow> (nat,'L) hashedTa\" where\n  \"hta_reindex H == hta_remap (reindex_map H) H\""], ["", "declare hta_reindex_def [code del]\n\n  \\<comment> \\<open>This version is more efficient, as the map is only computed once\\<close>"], ["", "lemma [code]: \"hta_reindex H = (\n  let mp = (hh_map_to_nat.map_to_nat (hta_states H)) in\n    hta_remap (\\<lambda>q. the (hm_lookup q mp)) H)\n  \""], ["proof (prove)\ngoal (1 subgoal):\n 1. hta_reindex H =\n    (let mp = hh_map_to_nat.map_to_nat (hta_states H)\n     in hta_remap (\\<lambda>q. the (hm.lookup q mp)) H)", "by (simp add: Let_def hta_reindex_def reindex_map_def)"], ["", "lemma (in hashedTa) reindex_map_correct:\n  \"inj_on (reindex_map H) (ta_rstates (hta_\\<alpha> H))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (reindex_map H) (ta_rstates (hta_\\<alpha> H))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on (reindex_map H) (ta_rstates (hta_\\<alpha> H))", "have [simp]: \n    \"reindex_map H = the \\<circ> hm_\\<alpha> (hh_map_to_nat.map_to_nat (hta_states H))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reindex_map H =\n    (the \\<circ>\\<circ>\\<circ> map_op_\\<alpha>) hm_ops\n     (hh_map_to_nat.map_to_nat (hta_states H))", "by (rule ext)\n       (simp add: reindex_map_def hm.correct \n         hh_map_to_nat.map_to_nat_correct(4) \n         hta_states_correct)"], ["proof (state)\nthis:\n  reindex_map H =\n  (the \\<circ>\\<circ>\\<circ> map_op_\\<alpha>) hm_ops\n   (hh_map_to_nat.map_to_nat (hta_states H))\n\ngoal (1 subgoal):\n 1. inj_on (reindex_map H) (ta_rstates (hta_\\<alpha> H))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (reindex_map H) (ta_rstates (hta_\\<alpha> H))", "apply (simp add: hta_states_correct(1)[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on\n     ((the \\<circ>\\<circ>\\<circ> map_op_\\<alpha>) hm_ops\n       (hh_map_to_nat.map_to_nat (hta_states H)))\n     (hs.\\<alpha> (hta_states H))", "apply (rule inj_on_map_the)"], ["proof (prove)\ngoal (2 subgoals):\n 1. hs.\\<alpha> (hta_states H)\n    \\<subseteq> dom (hm.\\<alpha> (hh_map_to_nat.map_to_nat (hta_states H)))\n 2. inj_on (hm.\\<alpha> (hh_map_to_nat.map_to_nat (hta_states H)))\n     (hs.\\<alpha> (hta_states H))", "apply (simp_all add: hh_map_to_nat.map_to_nat_correct hta_states_correct(2))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  inj_on (reindex_map H) (ta_rstates (hta_\\<alpha> H))\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem (in hashedTa) hta_reindex_correct:\n  \"ta_lang (hta_\\<alpha> (hta_reindex H)) = ta_lang (hta_\\<alpha> H)\"\n  \"hashedTa (hta_reindex H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_lang (hta_\\<alpha> (hta_reindex H)) = ta_lang (hta_\\<alpha> H) &&&\n    hashedTa (hta_reindex H)", "apply (unfold hta_reindex_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ta_lang (hta_\\<alpha> (hta_remap (reindex_map H) H)) =\n    ta_lang (hta_\\<alpha> H)\n 2. hashedTa (hta_remap (reindex_map H) H)", "apply (simp_all \n    add: hta_remap_correct tree_automaton.remap_lang[OF hta_\\<alpha>_is_ta] \n         reindex_map_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \"Union\""], ["", "text \"Computes the union of two automata\""], ["", "definition hta_union \n  :: \"('q1::hashable,'l::hashable) hashedTa \n      \\<Rightarrow> ('q2::hashable,'l) hashedTa \n      \\<Rightarrow> (('q1,'q2) ustate_wrapper,'l) hashedTa\" \n  where \"hta_union H1 H2 == \n    init_hta (hs_union (hh_set_xy.g_image USW1 (hta_Qi H1)) \n                       (hh_set_xy.g_image USW2 (hta_Qi H2))) \n             (ls_union_dj (ll_set_xy.g_image (remap_rule USW1) (hta_\\<delta> H1)) \n                          (ll_set_xy.g_image (remap_rule USW2) (hta_\\<delta> H2)))\""], ["", "lemma hta_union_correct': \n  assumes TA: \"hashedTa H1\" \"hashedTa H2\"\n  shows \"hta_\\<alpha> (hta_union H1 H2) \n         = ta_union_wrap (hta_\\<alpha> H1) (hta_\\<alpha> H2)\" (is ?T1)\n        \"hashedTa (hta_union H1 H2)\" (is ?T2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hta_\\<alpha> (hta_union H1 H2) =\n    ta_union_wrap (hta_\\<alpha> H1) (hta_\\<alpha> H2) &&&\n    hashedTa (hta_union H1 H2)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. hta_\\<alpha> (hta_union H1 H2) =\n    ta_union_wrap (hta_\\<alpha> H1) (hta_\\<alpha> H2)\n 2. hashedTa (hta_union H1 H2)", "interpret a1: hashedTa H1 + a2: hashedTa H2"], ["proof (prove)\ngoal (1 subgoal):\n 1. hashedTa H1 &&& hashedTa H2", "using TA"], ["proof (prove)\nusing this:\n  hashedTa H1\n  hashedTa H2\n\ngoal (1 subgoal):\n 1. hashedTa H1 &&& hashedTa H2", "."], ["proof (state)\ngoal (2 subgoals):\n 1. hta_\\<alpha> (hta_union H1 H2) =\n    ta_union_wrap (hta_\\<alpha> H1) (hta_\\<alpha> H2)\n 2. hashedTa (hta_union H1 H2)", "show ?T1 ?T2"], ["proof (prove)\ngoal (1 subgoal):\n 1. hta_\\<alpha> (hta_union H1 H2) =\n    ta_union_wrap (hta_\\<alpha> H1) (hta_\\<alpha> H2) &&&\n    hashedTa (hta_union H1 H2)", "apply (auto \n      simp add: hta_union_def init_hta_def hta_\\<alpha>_def \n                hs.correct ls.correct \n                ll_set_xy.image_correct hh_set_xy.image_correct\n                ta_remap_def ta_union_def ta_union_wrap_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hashedTa\n     \\<lparr>hta_Qi =\n               hs.union (hh_set_xy.g_image USW1 a1.Qi)\n                (hh_set_xy.g_image USW2 a2.Qi),\n        hta_\\<delta> =\n          ls.union_dj (ll_set_xy.g_image (remap_rule USW1) a1.\\<delta>)\n           (ll_set_xy.g_image (remap_rule USW2) a2.\\<delta>),\n        hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr>", "apply (unfold_locales)"], ["proof (prove)\ngoal (5 subgoals):\n 1. hs.invar\n     (hta_Qi\n       \\<lparr>hta_Qi =\n                 hs.union (hh_set_xy.g_image USW1 a1.Qi)\n                  (hh_set_xy.g_image USW2 a2.Qi),\n          hta_\\<delta> =\n            ls.union_dj (ll_set_xy.g_image (remap_rule USW1) a1.\\<delta>)\n             (ll_set_xy.g_image (remap_rule USW2) a2.\\<delta>),\n          hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr>)\n 2. ls.invar\n     (hta_\\<delta>\n       \\<lparr>hta_Qi =\n                 hs.union (hh_set_xy.g_image USW1 a1.Qi)\n                  (hh_set_xy.g_image USW2 a2.Qi),\n          hta_\\<delta> =\n            ls.union_dj (ll_set_xy.g_image (remap_rule USW1) a1.\\<delta>)\n             (ll_set_xy.g_image (remap_rule USW2) a2.\\<delta>),\n          hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr>)\n 3. \\<And>idx_f.\n       hta_idx_f\n        \\<lparr>hta_Qi =\n                  hs.union (hh_set_xy.g_image USW1 a1.Qi)\n                   (hh_set_xy.g_image USW2 a2.Qi),\n           hta_\\<delta> =\n             ls.union_dj (ll_set_xy.g_image (remap_rule USW1) a1.\\<delta>)\n              (ll_set_xy.g_image (remap_rule USW2) a2.\\<delta>),\n           hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr> =\n       Some idx_f \\<Longrightarrow>\n       hll_idx.is_index rhsl\n        (ls.\\<alpha>\n          (hta_\\<delta>\n            \\<lparr>hta_Qi =\n                      hs.union (hh_set_xy.g_image USW1 a1.Qi)\n                       (hh_set_xy.g_image USW2 a2.Qi),\n               hta_\\<delta> =\n                 ls.union_dj\n                  (ll_set_xy.g_image (remap_rule USW1) a1.\\<delta>)\n                  (ll_set_xy.g_image (remap_rule USW2) a2.\\<delta>),\n               hta_idx_f = None, hta_idx_s = None,\n               hta_idx_sf = None\\<rparr>))\n        idx_f\n 4. \\<And>idx_s.\n       hta_idx_s\n        \\<lparr>hta_Qi =\n                  hs.union (hh_set_xy.g_image USW1 a1.Qi)\n                   (hh_set_xy.g_image USW2 a2.Qi),\n           hta_\\<delta> =\n             ls.union_dj (ll_set_xy.g_image (remap_rule USW1) a1.\\<delta>)\n              (ll_set_xy.g_image (remap_rule USW2) a2.\\<delta>),\n           hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr> =\n       Some idx_s \\<Longrightarrow>\n       hll_idx.is_index lhs\n        (ls.\\<alpha>\n          (hta_\\<delta>\n            \\<lparr>hta_Qi =\n                      hs.union (hh_set_xy.g_image USW1 a1.Qi)\n                       (hh_set_xy.g_image USW2 a2.Qi),\n               hta_\\<delta> =\n                 ls.union_dj\n                  (ll_set_xy.g_image (remap_rule USW1) a1.\\<delta>)\n                  (ll_set_xy.g_image (remap_rule USW2) a2.\\<delta>),\n               hta_idx_f = None, hta_idx_s = None,\n               hta_idx_sf = None\\<rparr>))\n        idx_s\n 5. \\<And>idx_sf.\n       hta_idx_sf\n        \\<lparr>hta_Qi =\n                  hs.union (hh_set_xy.g_image USW1 a1.Qi)\n                   (hh_set_xy.g_image USW2 a2.Qi),\n           hta_\\<delta> =\n             ls.union_dj (ll_set_xy.g_image (remap_rule USW1) a1.\\<delta>)\n              (ll_set_xy.g_image (remap_rule USW2) a2.\\<delta>),\n           hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr> =\n       Some idx_sf \\<Longrightarrow>\n       hll_idx.is_index (\\<lambda>r. (lhs r, rhsl r))\n        (ls.\\<alpha>\n          (hta_\\<delta>\n            \\<lparr>hta_Qi =\n                      hs.union (hh_set_xy.g_image USW1 a1.Qi)\n                       (hh_set_xy.g_image USW2 a2.Qi),\n               hta_\\<delta> =\n                 ls.union_dj\n                  (ll_set_xy.g_image (remap_rule USW1) a1.\\<delta>)\n                  (ll_set_xy.g_image (remap_rule USW2) a2.\\<delta>),\n               hta_idx_f = None, hta_idx_s = None,\n               hta_idx_sf = None\\<rparr>))\n        idx_sf", "apply (auto \n      simp add: hs.correct ls.correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  hta_\\<alpha> (hta_union H1 H2) =\n  ta_union_wrap (hta_\\<alpha> H1) (hta_\\<alpha> H2)\n  hashedTa (hta_union H1 H2)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem hta_union_correct: \n  assumes TA: \"hashedTa H1\" \"hashedTa H2\"\n  shows \n    \"ta_lang (hta_\\<alpha> (hta_union H1 H2)) \n     = ta_lang (hta_\\<alpha> H1) \\<union> ta_lang (hta_\\<alpha> H2)\" (is ?T1)\n    \"hashedTa (hta_union H1 H2)\" (is ?T2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_lang (hta_\\<alpha> (hta_union H1 H2)) =\n    ta_lang (hta_\\<alpha> H1) \\<union> ta_lang (hta_\\<alpha> H2) &&&\n    hashedTa (hta_union H1 H2)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. ta_lang (hta_\\<alpha> (hta_union H1 H2)) =\n    ta_lang (hta_\\<alpha> H1) \\<union> ta_lang (hta_\\<alpha> H2)\n 2. hashedTa (hta_union H1 H2)", "interpret a1: hashedTa H1 + a2: hashedTa H2"], ["proof (prove)\ngoal (1 subgoal):\n 1. hashedTa H1 &&& hashedTa H2", "using TA"], ["proof (prove)\nusing this:\n  hashedTa H1\n  hashedTa H2\n\ngoal (1 subgoal):\n 1. hashedTa H1 &&& hashedTa H2", "."], ["proof (state)\ngoal (2 subgoals):\n 1. ta_lang (hta_\\<alpha> (hta_union H1 H2)) =\n    ta_lang (hta_\\<alpha> H1) \\<union> ta_lang (hta_\\<alpha> H2)\n 2. hashedTa (hta_union H1 H2)", "show ?T1 ?T2"], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_lang (hta_\\<alpha> (hta_union H1 H2)) =\n    ta_lang (hta_\\<alpha> H1) \\<union> ta_lang (hta_\\<alpha> H2) &&&\n    hashedTa (hta_union H1 H2)", "by (simp_all add: hta_union_correct'[OF TA] ta_union_wrap_correct)"], ["proof (state)\nthis:\n  ta_lang (hta_\\<alpha> (hta_union H1 H2)) =\n  ta_lang (hta_\\<alpha> H1) \\<union> ta_lang (hta_\\<alpha> H2)\n  hashedTa (hta_union H1 H2)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Operators to Construct Tree Automata\""], ["", "text \\<open>\n  This section defines operators that add initial states and rules to a tree \n  automaton, and thus incrementally construct a tree automaton from the empty\n  automaton.\n\\<close>\n\n\\<comment> \\<open>The empty automaton\\<close>"], ["", "definition hta_empty :: \"unit \\<Rightarrow> ('q::hashable,'l::hashable) hashedTa\" \n  where \"hta_empty u == init_hta (hs_empty ()) (ls_empty ())\""], ["", "lemma hta_empty_correct [simp, intro!]: \n  shows \"(hta_\\<alpha> (hta_empty ())) = ta_empty\"\n        \"hashedTa (hta_empty ())\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hta_\\<alpha> (hta_empty ()) = ta_empty &&& hashedTa (hta_empty ())", "apply (auto\n    simp add: init_hta_def hta_empty_def hta_\\<alpha>_def \\<delta>_states_def ta_empty_def\n              hs.correct ls.correct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hashedTa\n     \\<lparr>hta_Qi = hs.empty (), hta_\\<delta> = ls.empty (),\n        hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr>", "apply (unfold_locales)"], ["proof (prove)\ngoal (5 subgoals):\n 1. hs.invar\n     (hta_Qi\n       \\<lparr>hta_Qi = hs.empty (), hta_\\<delta> = ls.empty (),\n          hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr>)\n 2. ls.invar\n     (hta_\\<delta>\n       \\<lparr>hta_Qi = hs.empty (), hta_\\<delta> = ls.empty (),\n          hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr>)\n 3. \\<And>idx_f.\n       hta_idx_f\n        \\<lparr>hta_Qi = hs.empty (), hta_\\<delta> = ls.empty (),\n           hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr> =\n       Some idx_f \\<Longrightarrow>\n       hll_idx.is_index rhsl\n        (ls.\\<alpha>\n          (hta_\\<delta>\n            \\<lparr>hta_Qi = hs.empty (), hta_\\<delta> = ls.empty (),\n               hta_idx_f = None, hta_idx_s = None,\n               hta_idx_sf = None\\<rparr>))\n        idx_f\n 4. \\<And>idx_s.\n       hta_idx_s\n        \\<lparr>hta_Qi = hs.empty (), hta_\\<delta> = ls.empty (),\n           hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr> =\n       Some idx_s \\<Longrightarrow>\n       hll_idx.is_index lhs\n        (ls.\\<alpha>\n          (hta_\\<delta>\n            \\<lparr>hta_Qi = hs.empty (), hta_\\<delta> = ls.empty (),\n               hta_idx_f = None, hta_idx_s = None,\n               hta_idx_sf = None\\<rparr>))\n        idx_s\n 5. \\<And>idx_sf.\n       hta_idx_sf\n        \\<lparr>hta_Qi = hs.empty (), hta_\\<delta> = ls.empty (),\n           hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr> =\n       Some idx_sf \\<Longrightarrow>\n       hll_idx.is_index (\\<lambda>r. (lhs r, rhsl r))\n        (ls.\\<alpha>\n          (hta_\\<delta>\n            \\<lparr>hta_Qi = hs.empty (), hta_\\<delta> = ls.empty (),\n               hta_idx_f = None, hta_idx_s = None,\n               hta_idx_sf = None\\<rparr>))\n        idx_sf", "apply (auto simp add: hs.correct ls.correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n\n\\<comment> \\<open>Add an initial state to the automaton\\<close>"], ["", "definition hta_add_qi \n  :: \"'q \\<Rightarrow> ('q::hashable,'l::hashable) hashedTa \\<Rightarrow> ('q,'l) hashedTa\" \n  where \"hta_add_qi qi H == init_hta (hs_ins qi (hta_Qi H)) (hta_\\<delta> H)\""], ["", "lemma (in hashedTa) hta_add_qi_correct[simp, intro!]:\n  shows \"hta_\\<alpha> (hta_add_qi qi H) \n         = \\<lparr> ta_initial = insert qi (ta_initial (hta_\\<alpha> H)), \n             ta_rules = ta_rules (hta_\\<alpha> H) \n           \\<rparr>\"\n        \"hashedTa (hta_add_qi qi H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hta_\\<alpha> (hta_add_qi qi H) =\n    \\<lparr>ta_initial = insert qi (ta_initial (hta_\\<alpha> H)),\n       ta_rules = ta_rules (hta_\\<alpha> H)\\<rparr> &&&\n    hashedTa (hta_add_qi qi H)", "apply (auto \n    simp add: init_hta_def hta_add_qi_def hta_\\<alpha>_def \\<delta>_states_def \n              hs.correct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hashedTa\n     \\<lparr>hta_Qi = hs.ins qi Qi, hta_\\<delta> = \\<delta>,\n        hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr>", "apply (unfold_locales)"], ["proof (prove)\ngoal (5 subgoals):\n 1. hs.invar\n     (hta_Qi\n       \\<lparr>hta_Qi = hs.ins qi Qi, hta_\\<delta> = \\<delta>,\n          hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr>)\n 2. ls.invar\n     (hta_\\<delta>\n       \\<lparr>hta_Qi = hs.ins qi Qi, hta_\\<delta> = \\<delta>,\n          hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr>)\n 3. \\<And>idx_f.\n       hta_idx_f\n        \\<lparr>hta_Qi = hs.ins qi Qi, hta_\\<delta> = \\<delta>,\n           hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr> =\n       Some idx_f \\<Longrightarrow>\n       hll_idx.is_index rhsl\n        (ls.\\<alpha>\n          (hta_\\<delta>\n            \\<lparr>hta_Qi = hs.ins qi Qi, hta_\\<delta> = \\<delta>,\n               hta_idx_f = None, hta_idx_s = None,\n               hta_idx_sf = None\\<rparr>))\n        idx_f\n 4. \\<And>idx_s.\n       hta_idx_s\n        \\<lparr>hta_Qi = hs.ins qi Qi, hta_\\<delta> = \\<delta>,\n           hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr> =\n       Some idx_s \\<Longrightarrow>\n       hll_idx.is_index lhs\n        (ls.\\<alpha>\n          (hta_\\<delta>\n            \\<lparr>hta_Qi = hs.ins qi Qi, hta_\\<delta> = \\<delta>,\n               hta_idx_f = None, hta_idx_s = None,\n               hta_idx_sf = None\\<rparr>))\n        idx_s\n 5. \\<And>idx_sf.\n       hta_idx_sf\n        \\<lparr>hta_Qi = hs.ins qi Qi, hta_\\<delta> = \\<delta>,\n           hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr> =\n       Some idx_sf \\<Longrightarrow>\n       hll_idx.is_index (\\<lambda>r. (lhs r, rhsl r))\n        (ls.\\<alpha>\n          (hta_\\<delta>\n            \\<lparr>hta_Qi = hs.ins qi Qi, hta_\\<delta> = \\<delta>,\n               hta_idx_f = None, hta_idx_s = None,\n               hta_idx_sf = None\\<rparr>))\n        idx_sf", "apply (auto simp add: hs.correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas [simp, intro] = hashedTa.hta_add_qi_correct\n\n\\<comment> \\<open>Add a rule to the automaton\\<close>"], ["", "definition hta_add_rule \n  :: \"('q,'l) ta_rule \\<Rightarrow> ('q::hashable,'l::hashable) hashedTa \n      \\<Rightarrow> ('q,'l) hashedTa\" \n  where \"hta_add_rule r H == init_hta (hta_Qi H) (ls_ins r (hta_\\<delta> H))\""], ["", "lemma (in hashedTa) hta_add_rule_correct[simp, intro!]:\n  shows \"hta_\\<alpha> (hta_add_rule r H) \n         = \\<lparr> ta_initial = ta_initial (hta_\\<alpha> H), \n             ta_rules = insert r (ta_rules (hta_\\<alpha> H)) \n           \\<rparr>\"\n        \"hashedTa (hta_add_rule r H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hta_\\<alpha> (hta_add_rule r H) =\n    \\<lparr>ta_initial = ta_initial (hta_\\<alpha> H),\n       ta_rules = insert r (ta_rules (hta_\\<alpha> H))\\<rparr> &&&\n    hashedTa (hta_add_rule r H)", "apply (auto \n    simp add: init_hta_def hta_add_rule_def hta_\\<alpha>_def \n              \\<delta>_states_def ls.correct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hashedTa\n     \\<lparr>hta_Qi = Qi, hta_\\<delta> = ls.ins r \\<delta>,\n        hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr>", "apply (unfold_locales)"], ["proof (prove)\ngoal (5 subgoals):\n 1. hs.invar\n     (hta_Qi\n       \\<lparr>hta_Qi = Qi, hta_\\<delta> = ls.ins r \\<delta>,\n          hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr>)\n 2. ls.invar\n     (hta_\\<delta>\n       \\<lparr>hta_Qi = Qi, hta_\\<delta> = ls.ins r \\<delta>,\n          hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr>)\n 3. \\<And>idx_f.\n       hta_idx_f\n        \\<lparr>hta_Qi = Qi, hta_\\<delta> = ls.ins r \\<delta>,\n           hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr> =\n       Some idx_f \\<Longrightarrow>\n       hll_idx.is_index rhsl\n        (ls.\\<alpha>\n          (hta_\\<delta>\n            \\<lparr>hta_Qi = Qi, hta_\\<delta> = ls.ins r \\<delta>,\n               hta_idx_f = None, hta_idx_s = None,\n               hta_idx_sf = None\\<rparr>))\n        idx_f\n 4. \\<And>idx_s.\n       hta_idx_s\n        \\<lparr>hta_Qi = Qi, hta_\\<delta> = ls.ins r \\<delta>,\n           hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr> =\n       Some idx_s \\<Longrightarrow>\n       hll_idx.is_index lhs\n        (ls.\\<alpha>\n          (hta_\\<delta>\n            \\<lparr>hta_Qi = Qi, hta_\\<delta> = ls.ins r \\<delta>,\n               hta_idx_f = None, hta_idx_s = None,\n               hta_idx_sf = None\\<rparr>))\n        idx_s\n 5. \\<And>idx_sf.\n       hta_idx_sf\n        \\<lparr>hta_Qi = Qi, hta_\\<delta> = ls.ins r \\<delta>,\n           hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr> =\n       Some idx_sf \\<Longrightarrow>\n       hll_idx.is_index (\\<lambda>r. (lhs r, rhsl r))\n        (ls.\\<alpha>\n          (hta_\\<delta>\n            \\<lparr>hta_Qi = Qi, hta_\\<delta> = ls.ins r \\<delta>,\n               hta_idx_f = None, hta_idx_s = None,\n               hta_idx_sf = None\\<rparr>))\n        idx_sf", "apply (auto simp add: ls.correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas [simp, intro] = hashedTa.hta_add_rule_correct\n\n\n  \\<comment> \\<open>Reduces an automaton to the given set of states\\<close>"], ["", "definition \"hta_reduce H Q ==\n  init_hta (hs_inter Q (hta_Qi H)) \n           (ll_set_xy.g_image_filter \n              (\\<lambda>r. if hs_memb (lhs r) Q \\<and> list_all (\\<lambda>q. hs_memb q Q) (rhsq r) then Some r else None) \n              (hta_\\<delta> H))\n\""], ["", "theorem (in hashedTa) hta_reduce_correct:\n  assumes INV[simp]: \"hs_invar Q\"\n  shows\n  \"hta_\\<alpha> (hta_reduce H Q) = ta_reduce (hta_\\<alpha> H) (hs_\\<alpha> Q)\" (is ?T1)\n  \"hashedTa (hta_reduce H Q)\" (is ?T2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hta_\\<alpha> (hta_reduce H Q) =\n    ta_reduce (hta_\\<alpha> H) (hs.\\<alpha> Q) &&&\n    hashedTa (hta_reduce H Q)", "apply (auto \n    simp add: \n      hta_reduce_def ta_reduce_def hta_\\<alpha>_def init_hta_def \n      hs.correct ls.correct\n    (*hs_correct ls_correct *)\n      list_all_iff \n      reduce_rules_def rule_states_simp \n      ll_set_xy.image_filter_correct\n    split: \n      ta_rule.split_asm\n  ) [1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. hashedTa (hta_reduce H Q)", "apply (unfold_locales)"], ["proof (prove)\ngoal (5 subgoals):\n 1. hs.invar (hta_Qi (hta_reduce H Q))\n 2. ls.invar (hta_\\<delta> (hta_reduce H Q))\n 3. \\<And>idx_f.\n       hta_idx_f (hta_reduce H Q) = Some idx_f \\<Longrightarrow>\n       hll_idx.is_index rhsl (ls.\\<alpha> (hta_\\<delta> (hta_reduce H Q)))\n        idx_f\n 4. \\<And>idx_s.\n       hta_idx_s (hta_reduce H Q) = Some idx_s \\<Longrightarrow>\n       hll_idx.is_index lhs (ls.\\<alpha> (hta_\\<delta> (hta_reduce H Q)))\n        idx_s\n 5. \\<And>idx_sf.\n       hta_idx_sf (hta_reduce H Q) = Some idx_sf \\<Longrightarrow>\n       hll_idx.is_index (\\<lambda>r. (lhs r, rhsl r))\n        (ls.\\<alpha> (hta_\\<delta> (hta_reduce H Q))) idx_sf", "apply (unfold hta_reduce_def init_hta_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. hs.invar\n     (hta_Qi\n       \\<lparr>hta_Qi = hs.inter Q Qi,\n          hta_\\<delta> =\n            ll_set_xy.g_image_filter\n             (\\<lambda>r.\n                 if hs.memb (lhs r) Q \\<and>\n                    list_all (\\<lambda>q. hs.memb q Q) (rhsq r)\n                 then Some r else None)\n             \\<delta>,\n          hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr>)\n 2. ls.invar\n     (hta_\\<delta>\n       \\<lparr>hta_Qi = hs.inter Q Qi,\n          hta_\\<delta> =\n            ll_set_xy.g_image_filter\n             (\\<lambda>r.\n                 if hs.memb (lhs r) Q \\<and>\n                    list_all (\\<lambda>q. hs.memb q Q) (rhsq r)\n                 then Some r else None)\n             \\<delta>,\n          hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr>)\n 3. \\<And>idx_f.\n       hta_idx_f\n        \\<lparr>hta_Qi = hs.inter Q Qi,\n           hta_\\<delta> =\n             ll_set_xy.g_image_filter\n              (\\<lambda>r.\n                  if hs.memb (lhs r) Q \\<and>\n                     list_all (\\<lambda>q. hs.memb q Q) (rhsq r)\n                  then Some r else None)\n              \\<delta>,\n           hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr> =\n       Some idx_f \\<Longrightarrow>\n       hll_idx.is_index rhsl\n        (ls.\\<alpha>\n          (hta_\\<delta>\n            \\<lparr>hta_Qi = hs.inter Q Qi,\n               hta_\\<delta> =\n                 ll_set_xy.g_image_filter\n                  (\\<lambda>r.\n                      if hs.memb (lhs r) Q \\<and>\n                         list_all (\\<lambda>q. hs.memb q Q) (rhsq r)\n                      then Some r else None)\n                  \\<delta>,\n               hta_idx_f = None, hta_idx_s = None,\n               hta_idx_sf = None\\<rparr>))\n        idx_f\n 4. \\<And>idx_s.\n       hta_idx_s\n        \\<lparr>hta_Qi = hs.inter Q Qi,\n           hta_\\<delta> =\n             ll_set_xy.g_image_filter\n              (\\<lambda>r.\n                  if hs.memb (lhs r) Q \\<and>\n                     list_all (\\<lambda>q. hs.memb q Q) (rhsq r)\n                  then Some r else None)\n              \\<delta>,\n           hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr> =\n       Some idx_s \\<Longrightarrow>\n       hll_idx.is_index lhs\n        (ls.\\<alpha>\n          (hta_\\<delta>\n            \\<lparr>hta_Qi = hs.inter Q Qi,\n               hta_\\<delta> =\n                 ll_set_xy.g_image_filter\n                  (\\<lambda>r.\n                      if hs.memb (lhs r) Q \\<and>\n                         list_all (\\<lambda>q. hs.memb q Q) (rhsq r)\n                      then Some r else None)\n                  \\<delta>,\n               hta_idx_f = None, hta_idx_s = None,\n               hta_idx_sf = None\\<rparr>))\n        idx_s\n 5. \\<And>idx_sf.\n       hta_idx_sf\n        \\<lparr>hta_Qi = hs.inter Q Qi,\n           hta_\\<delta> =\n             ll_set_xy.g_image_filter\n              (\\<lambda>r.\n                  if hs.memb (lhs r) Q \\<and>\n                     list_all (\\<lambda>q. hs.memb q Q) (rhsq r)\n                  then Some r else None)\n              \\<delta>,\n           hta_idx_f = None, hta_idx_s = None, hta_idx_sf = None\\<rparr> =\n       Some idx_sf \\<Longrightarrow>\n       hll_idx.is_index (\\<lambda>r. (lhs r, rhsl r))\n        (ls.\\<alpha>\n          (hta_\\<delta>\n            \\<lparr>hta_Qi = hs.inter Q Qi,\n               hta_\\<delta> =\n                 ll_set_xy.g_image_filter\n                  (\\<lambda>r.\n                      if hs.memb (lhs r) Q \\<and>\n                         list_all (\\<lambda>q. hs.memb q Q) (rhsq r)\n                      then Some r else None)\n                  \\<delta>,\n               hta_idx_f = None, hta_idx_s = None,\n               hta_idx_sf = None\\<rparr>))\n        idx_sf", "apply (auto simp add: hs.correct ls.correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \"Backwards Reduction and Emptiness Check\""], ["", "text \\<open>\n  The algorithm uses a map from states to the set of rules that contain \n  the state on their rhs.\n\\<close>\n\n  \\<comment> \\<open>Add an entry to the index\\<close>"], ["", "definition \"rqrm_add q r res ==\n  case hm_lookup q res of\n    None \\<Rightarrow> hm_update q (ls_ins r (ls_empty ())) res |\n    Some s \\<Rightarrow> hm_update q (ls_ins r s) res\n  \"\n\n  \\<comment> \\<open>Lookup the set of rules with given state on rhs\\<close>"], ["", "definition \"rqrm_lookup rqrm q == case hm_lookup q rqrm of\n  None \\<Rightarrow> ls_empty () |\n  Some s \\<Rightarrow> s\n  \"\n\n  \\<comment> \\<open>Build the index from a set of rules\\<close>"], ["", "definition build_rqrm \n  :: \"('q::hashable,'l::hashable) ta_rule ls \n      \\<Rightarrow> ('q,('q,'l) ta_rule ls) hm\" \n  where\n  \"build_rqrm \\<delta> ==\n    ls_iteratei \\<delta> (\\<lambda>_. True)\n      (\\<lambda>r res. \n        foldl (\\<lambda>res q. rqrm_add q r res) res (rhsq r)\n      )\n      (hm_empty ())\n  \"\n\n\\<comment> \\<open>Whether the index satisfies the map and set invariants\\<close>"], ["", "definition \"rqrm_invar rqrm == \n  hm_invar rqrm \\<and> (\\<forall>q. ls_invar (rqrm_lookup rqrm q))\"\n\\<comment> \\<open>Whether the index really maps a state to the set of rules with this \n    state on their rhs\\<close>"], ["", "definition \"rqrm_prop \\<delta> rqrm == \n  \\<forall>q. ls_\\<alpha> (rqrm_lookup rqrm q) = {r\\<in>\\<delta>. q\\<in>set (rhsq r)}\""], ["", "lemma rqrm_\\<alpha>_lookup_update[simp]: \n  \"rqrm_invar rqrm \\<Longrightarrow> \n    ls_\\<alpha> (rqrm_lookup (rqrm_add q r rqrm) q') \n    = ( if q=q' then \n          insert r (ls_\\<alpha> (rqrm_lookup rqrm q')) \n        else \n          ls_\\<alpha> (rqrm_lookup rqrm q')\n      )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rqrm_invar rqrm \\<Longrightarrow>\n    ls.\\<alpha> (rqrm_lookup (rqrm_add q r rqrm) q') =\n    (if q = q' then insert r (ls.\\<alpha> (rqrm_lookup rqrm q'))\n     else ls.\\<alpha> (rqrm_lookup rqrm q'))", "by (simp \n    add: rqrm_lookup_def rqrm_add_def rqrm_invar_def hm.correct \n         ls.correct \n    split: option.split_asm option.split)"], ["", "lemma rqrm_propD: \n  \"rqrm_prop \\<delta> rqrm \\<Longrightarrow> ls_\\<alpha> (rqrm_lookup rqrm q) = {r\\<in>\\<delta>. q\\<in>set (rhsq r)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rqrm_prop \\<delta> rqrm \\<Longrightarrow>\n    ls.\\<alpha> (rqrm_lookup rqrm q) =\n    {r \\<in> \\<delta>. q \\<in> set (rhsq r)}", "by (simp add: rqrm_prop_def)"], ["", "lemma build_rqrm_correct:\n  fixes \\<delta>\n  assumes [simp]: \"ls_invar \\<delta>\"\n  shows \"rqrm_invar (build_rqrm \\<delta>)\" (is ?T1) and\n        \"rqrm_prop (ls_\\<alpha> \\<delta>) (build_rqrm \\<delta>)\" (is ?T2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rqrm_invar (build_rqrm \\<delta>) &&&\n    rqrm_prop (ls.\\<alpha> \\<delta>) (build_rqrm \\<delta>)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. rqrm_invar (build_rqrm \\<delta>)\n 2. rqrm_prop (ls.\\<alpha> \\<delta>) (build_rqrm \\<delta>)", "have \"rqrm_invar (build_rqrm \\<delta>) \\<and> \n    (\\<forall>q. ls_\\<alpha> (rqrm_lookup (build_rqrm \\<delta>) q) = {r\\<in>ls_\\<alpha> \\<delta>. q\\<in>set (rhsq r)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rqrm_invar (build_rqrm \\<delta>) \\<and>\n    (\\<forall>q.\n        ls.\\<alpha> (rqrm_lookup (build_rqrm \\<delta>) q) =\n        {r \\<in> ls.\\<alpha> \\<delta>. q \\<in> set (rhsq r)})", "apply (unfold build_rqrm_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rqrm_invar\n     (ls.iterate \\<delta>\n       (\\<lambda>r res.\n           foldl (\\<lambda>res q. rqrm_add q r res) res (rhsq r))\n       (hm.empty ())) \\<and>\n    (\\<forall>q.\n        ls.\\<alpha>\n         (rqrm_lookup\n           (ls.iterate \\<delta>\n             (\\<lambda>r res.\n                 foldl (\\<lambda>res q. rqrm_add q r res) res (rhsq r))\n             (hm.empty ()))\n           q) =\n        {r \\<in> ls.\\<alpha> \\<delta>. q \\<in> set (rhsq r)})", "apply (rule_tac \n      I=\"\\<lambda>it res. (rqrm_invar res) \n                  \\<and> (\\<forall>q. ls_\\<alpha> (rqrm_lookup res q) \n                     = {r\\<in>ls_\\<alpha> \\<delta> - it. q\\<in>set (rhsq r)})\" \n      in ls.iterate_rule_P)\n      \\<comment> \\<open>Invar\\<close>"], ["proof (prove)\ngoal (4 subgoals):\n 1. ls.invar \\<delta>\n 2. rqrm_invar (hm.empty ()) \\<and>\n    (\\<forall>q.\n        ls.\\<alpha> (rqrm_lookup (hm.empty ()) q) =\n        {r \\<in> ls.\\<alpha> \\<delta> - ls.\\<alpha> \\<delta>.\n         q \\<in> set (rhsq r)})\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> \\<delta>;\n        rqrm_invar \\<sigma> \\<and>\n        (\\<forall>q.\n            ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n            {r \\<in> ls.\\<alpha> \\<delta> - it.\n             q \\<in> set (rhsq r)})\\<rbrakk>\n       \\<Longrightarrow> rqrm_invar\n                          (foldl (\\<lambda>res q. rqrm_add q x res) \\<sigma>\n                            (rhsq x)) \\<and>\n                         (\\<forall>q.\n                             ls.\\<alpha>\n                              (rqrm_lookup\n                                (foldl (\\<lambda>res q. rqrm_add q x res)\n                                  \\<sigma> (rhsq x))\n                                q) =\n                             {r \\<in> ls.\\<alpha> \\<delta> - (it - {x}).\n                              q \\<in> set (rhsq r)})\n 4. \\<And>\\<sigma>.\n       rqrm_invar \\<sigma> \\<and>\n       (\\<forall>q.\n           ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n           {r \\<in> ls.\\<alpha> \\<delta> - {}.\n            q \\<in> set (rhsq r)}) \\<Longrightarrow>\n       rqrm_invar \\<sigma> \\<and>\n       (\\<forall>q.\n           ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n           {r \\<in> ls.\\<alpha> \\<delta>. q \\<in> set (rhsq r)})", "apply simp\n      \\<comment> \\<open>Initial\\<close>"], ["proof (prove)\ngoal (3 subgoals):\n 1. rqrm_invar (hm.empty ()) \\<and>\n    (\\<forall>q.\n        ls.\\<alpha> (rqrm_lookup (hm.empty ()) q) =\n        {r \\<in> ls.\\<alpha> \\<delta> - ls.\\<alpha> \\<delta>.\n         q \\<in> set (rhsq r)})\n 2. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> \\<delta>;\n        rqrm_invar \\<sigma> \\<and>\n        (\\<forall>q.\n            ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n            {r \\<in> ls.\\<alpha> \\<delta> - it.\n             q \\<in> set (rhsq r)})\\<rbrakk>\n       \\<Longrightarrow> rqrm_invar\n                          (foldl (\\<lambda>res q. rqrm_add q x res) \\<sigma>\n                            (rhsq x)) \\<and>\n                         (\\<forall>q.\n                             ls.\\<alpha>\n                              (rqrm_lookup\n                                (foldl (\\<lambda>res q. rqrm_add q x res)\n                                  \\<sigma> (rhsq x))\n                                q) =\n                             {r \\<in> ls.\\<alpha> \\<delta> - (it - {x}).\n                              q \\<in> set (rhsq r)})\n 3. \\<And>\\<sigma>.\n       rqrm_invar \\<sigma> \\<and>\n       (\\<forall>q.\n           ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n           {r \\<in> ls.\\<alpha> \\<delta> - {}.\n            q \\<in> set (rhsq r)}) \\<Longrightarrow>\n       rqrm_invar \\<sigma> \\<and>\n       (\\<forall>q.\n           ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n           {r \\<in> ls.\\<alpha> \\<delta>. q \\<in> set (rhsq r)})", "apply (simp add: hm_correct ls_correct rqrm_lookup_def rqrm_invar_def)\n      \\<comment> \\<open>Step\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> \\<delta>;\n        rqrm_invar \\<sigma> \\<and>\n        (\\<forall>q.\n            ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n            {r \\<in> ls.\\<alpha> \\<delta> - it.\n             q \\<in> set (rhsq r)})\\<rbrakk>\n       \\<Longrightarrow> rqrm_invar\n                          (foldl (\\<lambda>res q. rqrm_add q x res) \\<sigma>\n                            (rhsq x)) \\<and>\n                         (\\<forall>q.\n                             ls.\\<alpha>\n                              (rqrm_lookup\n                                (foldl (\\<lambda>res q. rqrm_add q x res)\n                                  \\<sigma> (rhsq x))\n                                q) =\n                             {r \\<in> ls.\\<alpha> \\<delta> - (it - {x}).\n                              q \\<in> set (rhsq r)})\n 2. \\<And>\\<sigma>.\n       rqrm_invar \\<sigma> \\<and>\n       (\\<forall>q.\n           ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n           {r \\<in> ls.\\<alpha> \\<delta> - {}.\n            q \\<in> set (rhsq r)}) \\<Longrightarrow>\n       rqrm_invar \\<sigma> \\<and>\n       (\\<forall>q.\n           ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n           {r \\<in> ls.\\<alpha> \\<delta>. q \\<in> set (rhsq r)})", "apply (rule_tac \n      I=\"\\<lambda>res itl itr. \n        (rqrm_invar res) \n        \\<and> (\\<forall>q. ls_\\<alpha> (rqrm_lookup res q) \n           = {r\\<in>ls_\\<alpha> \\<delta> - it. q\\<in>set (rhsq r)} \n             \\<union> {r. r=x \\<and> q\\<in>set itl})\" \n      in Misc.foldl_rule_P)\n        \\<comment> \\<open>Initial\\<close>"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> \\<delta>;\n        rqrm_invar \\<sigma> \\<and>\n        (\\<forall>q.\n            ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n            {r \\<in> ls.\\<alpha> \\<delta> - it.\n             q \\<in> set (rhsq r)})\\<rbrakk>\n       \\<Longrightarrow> rqrm_invar \\<sigma> \\<and>\n                         (\\<forall>q.\n                             ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n                             {r \\<in> ls.\\<alpha> \\<delta> - it.\n                              q \\<in> set (rhsq r)} \\<union>\n                             {r. r = x \\<and> q \\<in> set []})\n 2. \\<And>x it \\<sigma> l1 l2 xa \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> \\<delta>;\n        rqrm_invar \\<sigma> \\<and>\n        (\\<forall>q.\n            ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n            {r \\<in> ls.\\<alpha> \\<delta> - it. q \\<in> set (rhsq r)});\n        rhsq x = l1 @ xa # l2;\n        rqrm_invar \\<sigma>' \\<and>\n        (\\<forall>q.\n            ls.\\<alpha> (rqrm_lookup \\<sigma>' q) =\n            {r \\<in> ls.\\<alpha> \\<delta> - it.\n             q \\<in> set (rhsq r)} \\<union>\n            {r. r = x \\<and> q \\<in> set l1})\\<rbrakk>\n       \\<Longrightarrow> rqrm_invar (rqrm_add xa x \\<sigma>') \\<and>\n                         (\\<forall>q.\n                             ls.\\<alpha>\n                              (rqrm_lookup (rqrm_add xa x \\<sigma>') q) =\n                             {r \\<in> ls.\\<alpha> \\<delta> - it.\n                              q \\<in> set (rhsq r)} \\<union>\n                             {r. r = x \\<and> q \\<in> set (l1 @ [xa])})\n 3. \\<And>x it \\<sigma> \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> \\<delta>;\n        rqrm_invar \\<sigma> \\<and>\n        (\\<forall>q.\n            ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n            {r \\<in> ls.\\<alpha> \\<delta> - it. q \\<in> set (rhsq r)});\n        rqrm_invar \\<sigma>' \\<and>\n        (\\<forall>q.\n            ls.\\<alpha> (rqrm_lookup \\<sigma>' q) =\n            {r \\<in> ls.\\<alpha> \\<delta> - it.\n             q \\<in> set (rhsq r)} \\<union>\n            {r. r = x \\<and> q \\<in> set (rhsq x)})\\<rbrakk>\n       \\<Longrightarrow> rqrm_invar \\<sigma>' \\<and>\n                         (\\<forall>q.\n                             ls.\\<alpha> (rqrm_lookup \\<sigma>' q) =\n                             {r \\<in> ls.\\<alpha> \\<delta> - (it - {x}).\n                              q \\<in> set (rhsq r)})\n 4. \\<And>\\<sigma>.\n       rqrm_invar \\<sigma> \\<and>\n       (\\<forall>q.\n           ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n           {r \\<in> ls.\\<alpha> \\<delta> - {}.\n            q \\<in> set (rhsq r)}) \\<Longrightarrow>\n       rqrm_invar \\<sigma> \\<and>\n       (\\<forall>q.\n           ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n           {r \\<in> ls.\\<alpha> \\<delta>. q \\<in> set (rhsq r)})", "apply simp\n        \\<comment> \\<open>Step\\<close>"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x it \\<sigma> l1 l2 xa \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> \\<delta>;\n        rqrm_invar \\<sigma> \\<and>\n        (\\<forall>q.\n            ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n            {r \\<in> ls.\\<alpha> \\<delta> - it. q \\<in> set (rhsq r)});\n        rhsq x = l1 @ xa # l2;\n        rqrm_invar \\<sigma>' \\<and>\n        (\\<forall>q.\n            ls.\\<alpha> (rqrm_lookup \\<sigma>' q) =\n            {r \\<in> ls.\\<alpha> \\<delta> - it.\n             q \\<in> set (rhsq r)} \\<union>\n            {r. r = x \\<and> q \\<in> set l1})\\<rbrakk>\n       \\<Longrightarrow> rqrm_invar (rqrm_add xa x \\<sigma>') \\<and>\n                         (\\<forall>q.\n                             ls.\\<alpha>\n                              (rqrm_lookup (rqrm_add xa x \\<sigma>') q) =\n                             {r \\<in> ls.\\<alpha> \\<delta> - it.\n                              q \\<in> set (rhsq r)} \\<union>\n                             {r. r = x \\<and> q \\<in> set (l1 @ [xa])})\n 2. \\<And>x it \\<sigma> \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> \\<delta>;\n        rqrm_invar \\<sigma> \\<and>\n        (\\<forall>q.\n            ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n            {r \\<in> ls.\\<alpha> \\<delta> - it. q \\<in> set (rhsq r)});\n        rqrm_invar \\<sigma>' \\<and>\n        (\\<forall>q.\n            ls.\\<alpha> (rqrm_lookup \\<sigma>' q) =\n            {r \\<in> ls.\\<alpha> \\<delta> - it.\n             q \\<in> set (rhsq r)} \\<union>\n            {r. r = x \\<and> q \\<in> set (rhsq x)})\\<rbrakk>\n       \\<Longrightarrow> rqrm_invar \\<sigma>' \\<and>\n                         (\\<forall>q.\n                             ls.\\<alpha> (rqrm_lookup \\<sigma>' q) =\n                             {r \\<in> ls.\\<alpha> \\<delta> - (it - {x}).\n                              q \\<in> set (rhsq r)})\n 3. \\<And>\\<sigma>.\n       rqrm_invar \\<sigma> \\<and>\n       (\\<forall>q.\n           ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n           {r \\<in> ls.\\<alpha> \\<delta> - {}.\n            q \\<in> set (rhsq r)}) \\<Longrightarrow>\n       rqrm_invar \\<sigma> \\<and>\n       (\\<forall>q.\n           ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n           {r \\<in> ls.\\<alpha> \\<delta>. q \\<in> set (rhsq r)})", "apply (intro conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x it \\<sigma> l1 l2 xa \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> \\<delta>;\n        rqrm_invar \\<sigma> \\<and>\n        (\\<forall>q.\n            ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n            {r \\<in> ls.\\<alpha> \\<delta> - it. q \\<in> set (rhsq r)});\n        rhsq x = l1 @ xa # l2;\n        rqrm_invar \\<sigma>' \\<and>\n        (\\<forall>q.\n            ls.\\<alpha> (rqrm_lookup \\<sigma>' q) =\n            {r \\<in> ls.\\<alpha> \\<delta> - it.\n             q \\<in> set (rhsq r)} \\<union>\n            {r. r = x \\<and> q \\<in> set l1})\\<rbrakk>\n       \\<Longrightarrow> rqrm_invar (rqrm_add xa x \\<sigma>')\n 2. \\<And>x it \\<sigma> l1 l2 xa \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> \\<delta>;\n        rqrm_invar \\<sigma> \\<and>\n        (\\<forall>q.\n            ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n            {r \\<in> ls.\\<alpha> \\<delta> - it. q \\<in> set (rhsq r)});\n        rhsq x = l1 @ xa # l2;\n        rqrm_invar \\<sigma>' \\<and>\n        (\\<forall>q.\n            ls.\\<alpha> (rqrm_lookup \\<sigma>' q) =\n            {r \\<in> ls.\\<alpha> \\<delta> - it.\n             q \\<in> set (rhsq r)} \\<union>\n            {r. r = x \\<and> q \\<in> set l1})\\<rbrakk>\n       \\<Longrightarrow> \\<forall>q.\n                            ls.\\<alpha>\n                             (rqrm_lookup (rqrm_add xa x \\<sigma>') q) =\n                            {r \\<in> ls.\\<alpha> \\<delta> - it.\n                             q \\<in> set (rhsq r)} \\<union>\n                            {r. r = x \\<and> q \\<in> set (l1 @ [xa])}\n 3. \\<And>x it \\<sigma> \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> \\<delta>;\n        rqrm_invar \\<sigma> \\<and>\n        (\\<forall>q.\n            ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n            {r \\<in> ls.\\<alpha> \\<delta> - it. q \\<in> set (rhsq r)});\n        rqrm_invar \\<sigma>' \\<and>\n        (\\<forall>q.\n            ls.\\<alpha> (rqrm_lookup \\<sigma>' q) =\n            {r \\<in> ls.\\<alpha> \\<delta> - it.\n             q \\<in> set (rhsq r)} \\<union>\n            {r. r = x \\<and> q \\<in> set (rhsq x)})\\<rbrakk>\n       \\<Longrightarrow> rqrm_invar \\<sigma>' \\<and>\n                         (\\<forall>q.\n                             ls.\\<alpha> (rqrm_lookup \\<sigma>' q) =\n                             {r \\<in> ls.\\<alpha> \\<delta> - (it - {x}).\n                              q \\<in> set (rhsq r)})\n 4. \\<And>\\<sigma>.\n       rqrm_invar \\<sigma> \\<and>\n       (\\<forall>q.\n           ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n           {r \\<in> ls.\\<alpha> \\<delta> - {}.\n            q \\<in> set (rhsq r)}) \\<Longrightarrow>\n       rqrm_invar \\<sigma> \\<and>\n       (\\<forall>q.\n           ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n           {r \\<in> ls.\\<alpha> \\<delta>. q \\<in> set (rhsq r)})", "apply (simp \n        add: rqrm_invar_def rqrm_add_def rqrm_lookup_def hm_correct \n             ls_correct \n        split: option.split option.split_asm)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x it \\<sigma> l1 l2 xa \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> \\<delta>;\n        rqrm_invar \\<sigma> \\<and>\n        (\\<forall>q.\n            ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n            {r \\<in> ls.\\<alpha> \\<delta> - it. q \\<in> set (rhsq r)});\n        rhsq x = l1 @ xa # l2;\n        rqrm_invar \\<sigma>' \\<and>\n        (\\<forall>q.\n            ls.\\<alpha> (rqrm_lookup \\<sigma>' q) =\n            {r \\<in> ls.\\<alpha> \\<delta> - it.\n             q \\<in> set (rhsq r)} \\<union>\n            {r. r = x \\<and> q \\<in> set l1})\\<rbrakk>\n       \\<Longrightarrow> \\<forall>q.\n                            ls.\\<alpha>\n                             (rqrm_lookup (rqrm_add xa x \\<sigma>') q) =\n                            {r \\<in> ls.\\<alpha> \\<delta> - it.\n                             q \\<in> set (rhsq r)} \\<union>\n                            {r. r = x \\<and> q \\<in> set (l1 @ [xa])}\n 2. \\<And>x it \\<sigma> \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> \\<delta>;\n        rqrm_invar \\<sigma> \\<and>\n        (\\<forall>q.\n            ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n            {r \\<in> ls.\\<alpha> \\<delta> - it. q \\<in> set (rhsq r)});\n        rqrm_invar \\<sigma>' \\<and>\n        (\\<forall>q.\n            ls.\\<alpha> (rqrm_lookup \\<sigma>' q) =\n            {r \\<in> ls.\\<alpha> \\<delta> - it.\n             q \\<in> set (rhsq r)} \\<union>\n            {r. r = x \\<and> q \\<in> set (rhsq x)})\\<rbrakk>\n       \\<Longrightarrow> rqrm_invar \\<sigma>' \\<and>\n                         (\\<forall>q.\n                             ls.\\<alpha> (rqrm_lookup \\<sigma>' q) =\n                             {r \\<in> ls.\\<alpha> \\<delta> - (it - {x}).\n                              q \\<in> set (rhsq r)})\n 3. \\<And>\\<sigma>.\n       rqrm_invar \\<sigma> \\<and>\n       (\\<forall>q.\n           ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n           {r \\<in> ls.\\<alpha> \\<delta> - {}.\n            q \\<in> set (rhsq r)}) \\<Longrightarrow>\n       rqrm_invar \\<sigma> \\<and>\n       (\\<forall>q.\n           ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n           {r \\<in> ls.\\<alpha> \\<delta>. q \\<in> set (rhsq r)})", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x it \\<sigma> l1 l2 xa \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> \\<delta>;\n        rqrm_invar \\<sigma> \\<and>\n        (\\<forall>q.\n            ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n            {r \\<in> ls.\\<alpha> \\<delta>.\n             r \\<notin> it \\<and> q \\<in> set (rhsq r)});\n        rhsq x = l1 @ xa # l2;\n        rqrm_invar \\<sigma>' \\<and>\n        (\\<forall>q.\n            ls.\\<alpha> (rqrm_lookup \\<sigma>' q) =\n            {r \\<in> ls.\\<alpha> \\<delta>.\n             r \\<notin> it \\<and> q \\<in> set (rhsq r)} \\<union>\n            {r. r = x \\<and> q \\<in> set l1})\\<rbrakk>\n       \\<Longrightarrow> insert x\n                          ({r \\<in> ls.\\<alpha> \\<delta>.\n                            r \\<notin> it \\<and>\n                            xa \\<in> set (rhsq r)} \\<union>\n                           {r. r = x \\<and> xa \\<in> set l1}) =\n                         insert x\n                          {r \\<in> ls.\\<alpha> \\<delta>.\n                           r \\<notin> it \\<and> xa \\<in> set (rhsq r)}\n 2. \\<And>x it \\<sigma> \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> \\<delta>;\n        rqrm_invar \\<sigma> \\<and>\n        (\\<forall>q.\n            ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n            {r \\<in> ls.\\<alpha> \\<delta> - it. q \\<in> set (rhsq r)});\n        rqrm_invar \\<sigma>' \\<and>\n        (\\<forall>q.\n            ls.\\<alpha> (rqrm_lookup \\<sigma>' q) =\n            {r \\<in> ls.\\<alpha> \\<delta> - it.\n             q \\<in> set (rhsq r)} \\<union>\n            {r. r = x \\<and> q \\<in> set (rhsq x)})\\<rbrakk>\n       \\<Longrightarrow> rqrm_invar \\<sigma>' \\<and>\n                         (\\<forall>q.\n                             ls.\\<alpha> (rqrm_lookup \\<sigma>' q) =\n                             {r \\<in> ls.\\<alpha> \\<delta> - (it - {x}).\n                              q \\<in> set (rhsq r)})\n 3. \\<And>\\<sigma>.\n       rqrm_invar \\<sigma> \\<and>\n       (\\<forall>q.\n           ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n           {r \\<in> ls.\\<alpha> \\<delta> - {}.\n            q \\<in> set (rhsq r)}) \\<Longrightarrow>\n       rqrm_invar \\<sigma> \\<and>\n       (\\<forall>q.\n           ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n           {r \\<in> ls.\\<alpha> \\<delta>. q \\<in> set (rhsq r)})", "apply (simp \n        add: rqrm_add_def rqrm_lookup_def hm_correct ls_correct \n        split: option.split option.split_asm)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x it \\<sigma> l1 l2 xa \\<sigma>'.\n       \\<lbrakk>\\<forall>q.\n                   ((\\<exists>y. hm.\\<alpha> \\<sigma>' q = Some y) \\<or>\n                    (\\<forall>x.\n                        x \\<in> ls.\\<alpha> \\<delta> \\<longrightarrow>\n                        x \\<in> it \\<or> q \\<notin> set (rhsq x)) \\<and>\n                    q \\<notin> set l1) \\<and>\n                   (\\<forall>x2.\n                       hm.\\<alpha> \\<sigma>' q = Some x2 \\<longrightarrow>\n                       ls.\\<alpha> x2 =\n                       {r \\<in> ls.\\<alpha> \\<delta>.\n                        r \\<notin> it \\<and> q \\<in> set (rhsq r)} \\<union>\n                       {r. r = x \\<and> q \\<in> set l1});\n        rhsq x = l1 @ xa # l2; x \\<in> it;\n        it \\<subseteq> ls.\\<alpha> \\<delta>; rqrm_invar \\<sigma>;\n        \\<forall>q.\n           ((\\<exists>y. hm.\\<alpha> \\<sigma> q = Some y) \\<or>\n            (\\<forall>x.\n                x \\<in> ls.\\<alpha> \\<delta> \\<longrightarrow>\n                x \\<in> it \\<or> q \\<notin> set (rhsq x))) \\<and>\n           (\\<forall>x2.\n               hm.\\<alpha> \\<sigma> q = Some x2 \\<longrightarrow>\n               ls.\\<alpha> x2 =\n               {r \\<in> ls.\\<alpha> \\<delta>.\n                r \\<notin> it \\<and> q \\<in> set (rhsq r)});\n        rqrm_invar \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> insert x\n                          ({r \\<in> ls.\\<alpha> \\<delta>.\n                            r \\<notin> it \\<and>\n                            xa \\<in> set (rhsq r)} \\<union>\n                           {r. r = x \\<and> xa \\<in> set l1}) =\n                         insert x\n                          {r \\<in> ls.\\<alpha> \\<delta>.\n                           r \\<notin> it \\<and> xa \\<in> set (rhsq r)}\n 2. \\<And>x it \\<sigma> \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> \\<delta>;\n        rqrm_invar \\<sigma> \\<and>\n        (\\<forall>q.\n            ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n            {r \\<in> ls.\\<alpha> \\<delta> - it. q \\<in> set (rhsq r)});\n        rqrm_invar \\<sigma>' \\<and>\n        (\\<forall>q.\n            ls.\\<alpha> (rqrm_lookup \\<sigma>' q) =\n            {r \\<in> ls.\\<alpha> \\<delta> - it.\n             q \\<in> set (rhsq r)} \\<union>\n            {r. r = x \\<and> q \\<in> set (rhsq x)})\\<rbrakk>\n       \\<Longrightarrow> rqrm_invar \\<sigma>' \\<and>\n                         (\\<forall>q.\n                             ls.\\<alpha> (rqrm_lookup \\<sigma>' q) =\n                             {r \\<in> ls.\\<alpha> \\<delta> - (it - {x}).\n                              q \\<in> set (rhsq r)})\n 3. \\<And>\\<sigma>.\n       rqrm_invar \\<sigma> \\<and>\n       (\\<forall>q.\n           ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n           {r \\<in> ls.\\<alpha> \\<delta> - {}.\n            q \\<in> set (rhsq r)}) \\<Longrightarrow>\n       rqrm_invar \\<sigma> \\<and>\n       (\\<forall>q.\n           ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n           {r \\<in> ls.\\<alpha> \\<delta>. q \\<in> set (rhsq r)})", "apply (auto) [1]\n        \\<comment> \\<open>Final\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x it \\<sigma> \\<sigma>'.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> \\<delta>;\n        rqrm_invar \\<sigma> \\<and>\n        (\\<forall>q.\n            ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n            {r \\<in> ls.\\<alpha> \\<delta> - it. q \\<in> set (rhsq r)});\n        rqrm_invar \\<sigma>' \\<and>\n        (\\<forall>q.\n            ls.\\<alpha> (rqrm_lookup \\<sigma>' q) =\n            {r \\<in> ls.\\<alpha> \\<delta> - it.\n             q \\<in> set (rhsq r)} \\<union>\n            {r. r = x \\<and> q \\<in> set (rhsq x)})\\<rbrakk>\n       \\<Longrightarrow> rqrm_invar \\<sigma>' \\<and>\n                         (\\<forall>q.\n                             ls.\\<alpha> (rqrm_lookup \\<sigma>' q) =\n                             {r \\<in> ls.\\<alpha> \\<delta> - (it - {x}).\n                              q \\<in> set (rhsq r)})\n 2. \\<And>\\<sigma>.\n       rqrm_invar \\<sigma> \\<and>\n       (\\<forall>q.\n           ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n           {r \\<in> ls.\\<alpha> \\<delta> - {}.\n            q \\<in> set (rhsq r)}) \\<Longrightarrow>\n       rqrm_invar \\<sigma> \\<and>\n       (\\<forall>q.\n           ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n           {r \\<in> ls.\\<alpha> \\<delta>. q \\<in> set (rhsq r)})", "apply auto [1]\n      \\<comment> \\<open>Final\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       rqrm_invar \\<sigma> \\<and>\n       (\\<forall>q.\n           ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n           {r \\<in> ls.\\<alpha> \\<delta> - {}.\n            q \\<in> set (rhsq r)}) \\<Longrightarrow>\n       rqrm_invar \\<sigma> \\<and>\n       (\\<forall>q.\n           ls.\\<alpha> (rqrm_lookup \\<sigma> q) =\n           {r \\<in> ls.\\<alpha> \\<delta>. q \\<in> set (rhsq r)})", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rqrm_invar (build_rqrm \\<delta>) \\<and>\n  (\\<forall>q.\n      ls.\\<alpha> (rqrm_lookup (build_rqrm \\<delta>) q) =\n      {r \\<in> ls.\\<alpha> \\<delta>. q \\<in> set (rhsq r)})\n\ngoal (2 subgoals):\n 1. rqrm_invar (build_rqrm \\<delta>)\n 2. rqrm_prop (ls.\\<alpha> \\<delta>) (build_rqrm \\<delta>)", "thus ?T1 ?T2"], ["proof (prove)\nusing this:\n  rqrm_invar (build_rqrm \\<delta>) \\<and>\n  (\\<forall>q.\n      ls.\\<alpha> (rqrm_lookup (build_rqrm \\<delta>) q) =\n      {r \\<in> ls.\\<alpha> \\<delta>. q \\<in> set (rhsq r)})\n\ngoal (1 subgoal):\n 1. rqrm_invar (build_rqrm \\<delta>) &&&\n    rqrm_prop (ls.\\<alpha> \\<delta>) (build_rqrm \\<delta>)", "by (simp_all add: rqrm_prop_def)"], ["proof (state)\nthis:\n  rqrm_invar (build_rqrm \\<delta>)\n  rqrm_prop (ls.\\<alpha> \\<delta>) (build_rqrm \\<delta>)\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open>A state of the basic algorithm contains a set of discovered states, \n    a worklist and a map from rules to the number of distinct states on \n    its RHS that have not yet been discovered or are still on the worklist\\<close>"], ["", "type_synonym ('Q,'L) brc_state \n  = \"'Q hs \\<times> 'Q list \\<times> (('Q,'L) ta_rule, nat) hm\"\n\n\\<comment> \\<open>Abstraction to @{text \\<alpha>'}-level:\\<close>"], ["", "definition brc_\\<alpha> \n  :: \"('Q::hashable,'L::hashable) brc_state \\<Rightarrow> ('Q,'L) br'_state\"\n  where \"brc_\\<alpha> == \\<lambda>(Q,W,rcm). (hs_\\<alpha> Q, set W, hm_\\<alpha> rcm)\""], ["", "definition brc_invar_add :: \"('Q::hashable,'L::hashable) brc_state set\" \n  where\n  \"brc_invar_add == {(Q,W,rcm). \n    hs_invar Q \\<and> \n    distinct W \\<and> \n    hm_invar rcm\n    \\<^cancel>\\<open>\\<and> set W \\<subseteq> hs_\\<alpha> Q\\<close>}\n  \""], ["", "definition \"brc_invar \\<delta> == brc_invar_add \\<inter> {s. brc_\\<alpha> s \\<in> br'_invar \\<delta>}\""], ["", "definition brc_cond :: \"('q::hashable,'l::hashable) brc_state \\<Rightarrow> bool\" \n  where \"brc_cond == \\<lambda>(Q,W,rcm). W\\<noteq>[]\""], ["", "definition brc_inner_step \n  :: \"('q,'l) ta_rule \\<Rightarrow> ('q::hashable,'l::hashable) brc_state \n      \\<Rightarrow> ('q,'l) brc_state\"\n  where \n  \"brc_inner_step r == \\<lambda>(Q,W,rcm). \n    let c=the (hm_lookup r rcm);\n        rcm' = hm_update r (c-(1::nat)) rcm;\n        Q' = (if c \\<le> 1 then hs_ins (lhs r) Q else Q);\n        W' = (if c \\<le> 1 \\<and> \\<not> hs_memb (lhs r) Q then lhs r # W else W) in\n      (Q',W',rcm')\""], ["", "definition brc_step \n  :: \"('q,('q,'l) ta_rule ls) hm \n      \\<Rightarrow> ('q::hashable,'l::hashable) brc_state \n      \\<Rightarrow> ('q,'l) brc_state\" \nwhere \n  \"brc_step rqrm == \\<lambda>(Q,W,rcm).\n    ls_iteratei (rqrm_lookup rqrm (hd W)) (\\<lambda>_. True) brc_inner_step \n      (Q,tl W, rcm)\"\n\n  \\<comment> \\<open>Initial concrete state\\<close>"], ["", "definition brc_iq :: \"('q,'l) ta_rule ls \\<Rightarrow> 'q::hashable hs\" \n  where \"brc_iq \\<delta> == lh_set_xy.g_image_filter (\\<lambda>r. \n    if rhsq r = [] then Some (lhs r) else None) \\<delta>\""], ["", "definition brc_rcm_init \n  :: \"('q::hashable,'l::hashable) ta_rule ls \n      \\<Rightarrow> (('q,'l) ta_rule,nat) hm\" \n  where \"brc_rcm_init \\<delta> == \n    ls_iteratei \\<delta> (\\<lambda>_. True) \n      (\\<lambda>r res. hm_update r ((length (remdups (rhsq r)))) res) \n      (hm_empty ())\""], ["", "definition brc_initial \n  :: \"('q::hashable,'l::hashable) ta_rule ls \\<Rightarrow> ('q,'l) brc_state\" \n  where \"brc_initial \\<delta> == \n    let iq=brc_iq \\<delta> in \n      (iq, hs_to_list (iq), brc_rcm_init \\<delta>)\""], ["", "definition \"brc_det_algo rqrm \\<delta> == \\<lparr>\n  dwa_cond = brc_cond,\n  dwa_step = brc_step rqrm,\n  dwa_initial = brc_initial \\<delta>,\n  dwa_invar = brc_invar (ls_\\<alpha> \\<delta>)\n\\<rparr>\"\n\n  \\<comment> \\<open>Additional facts needed from the abstract level\\<close>"], ["", "lemma brc_inv_imp_WssQ: \"brc_\\<alpha> (Q,W,rcm)\\<in>br'_invar \\<delta> \\<Longrightarrow> set W \\<subseteq> hs_\\<alpha> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. brc_\\<alpha> (Q, W, rcm) \\<in> br'_invar \\<delta> \\<Longrightarrow>\n    set W \\<subseteq> hs.\\<alpha> Q", "by (auto simp add: brc_\\<alpha>_def br'_invar_def br'_\\<alpha>_def br_invar_def)"], ["", "lemma brc_iq_correct: \n  assumes [simp]: \"ls_invar \\<delta>\"\n  shows \"hs_invar (brc_iq \\<delta>)\"\n        \"hs_\\<alpha> (brc_iq \\<delta>) = br_iq (ls_\\<alpha> \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hs.invar (brc_iq \\<delta>) &&&\n    hs.\\<alpha> (brc_iq \\<delta>) = br_iq (ls.\\<alpha> \\<delta>)", "by (auto simp add: brc_iq_def br_iq_def lh_set_xy.image_filter_correct)"], ["", "lemma brc_rcm_init_correct:\n  assumes INV[simp]: \"ls_invar \\<delta>\"\n  shows \"r\\<in>ls_\\<alpha> \\<delta> \n    \\<Longrightarrow> hm_\\<alpha> (brc_rcm_init \\<delta>) r = Some ((card (set (rhsq r))))\" \n  (is \"_ \\<Longrightarrow> ?T1 r\") and\n    \"hm_invar (brc_rcm_init \\<delta>)\" (is ?T2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (r \\<in> ls.\\<alpha> \\<delta> \\<Longrightarrow>\n     hm.\\<alpha> (brc_rcm_init \\<delta>) r = Some (card (set (rhsq r)))) &&&\n    hm.invar (brc_rcm_init \\<delta>)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. r \\<in> ls.\\<alpha> \\<delta> \\<Longrightarrow>\n    hm.\\<alpha> (brc_rcm_init \\<delta>) r = Some (card (set (rhsq r)))\n 2. hm.invar (brc_rcm_init \\<delta>)", "have G: \"(\\<forall>r\\<in>ls_\\<alpha> \\<delta>. ?T1 r) \\<and> ?T2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>r\\<in>ls.\\<alpha> \\<delta>.\n        hm.\\<alpha> (brc_rcm_init \\<delta>) r =\n        Some (card (set (rhsq r)))) \\<and>\n    hm.invar (brc_rcm_init \\<delta>)", "apply (unfold brc_rcm_init_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>r\\<in>ls.\\<alpha> \\<delta>.\n        hm.\\<alpha>\n         (ls.iterate \\<delta>\n           (\\<lambda>r. hm.update r (length (remdups (rhsq r))))\n           (hm.empty ()))\n         r =\n        Some (card (set (rhsq r)))) \\<and>\n    hm.invar\n     (ls.iterate \\<delta>\n       (\\<lambda>r. hm.update r (length (remdups (rhsq r)))) (hm.empty ()))", "apply (rule_tac \n      I=\"\\<lambda>it res. hm_invar res \n           \\<and> (\\<forall>r\\<in>ls_\\<alpha> \\<delta> - it. hm_\\<alpha> res r = Some ((card (set (rhsq r)))))\" \n      in ls.iterate_rule_P)\n      \\<comment> \\<open>Invar\\<close>"], ["proof (prove)\ngoal (4 subgoals):\n 1. ls.invar \\<delta>\n 2. hm.invar (hm.empty ()) \\<and>\n    (\\<forall>r\\<in>ls.\\<alpha> \\<delta> - ls.\\<alpha> \\<delta>.\n        hm.\\<alpha> (hm.empty ()) r = Some (card (set (rhsq r))))\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> \\<delta>;\n        hm.invar \\<sigma> \\<and>\n        (\\<forall>r\\<in>ls.\\<alpha> \\<delta> - it.\n            hm.\\<alpha> \\<sigma> r = Some (card (set (rhsq r))))\\<rbrakk>\n       \\<Longrightarrow> hm.invar\n                          (hm.update x (length (remdups (rhsq x)))\n                            \\<sigma>) \\<and>\n                         (\\<forall>r\\<in>ls.\\<alpha> \\<delta> - (it - {x}).\n                             hm.\\<alpha>\n                              (hm.update x (length (remdups (rhsq x)))\n                                \\<sigma>)\n                              r =\n                             Some (card (set (rhsq r))))\n 4. \\<And>\\<sigma>.\n       hm.invar \\<sigma> \\<and>\n       (\\<forall>r\\<in>ls.\\<alpha> \\<delta> - {}.\n           hm.\\<alpha> \\<sigma> r =\n           Some (card (set (rhsq r)))) \\<Longrightarrow>\n       (\\<forall>r\\<in>ls.\\<alpha> \\<delta>.\n           hm.\\<alpha> \\<sigma> r = Some (card (set (rhsq r)))) \\<and>\n       hm.invar \\<sigma>", "apply simp\n      \\<comment> \\<open>Init\\<close>"], ["proof (prove)\ngoal (3 subgoals):\n 1. hm.invar (hm.empty ()) \\<and>\n    (\\<forall>r\\<in>ls.\\<alpha> \\<delta> - ls.\\<alpha> \\<delta>.\n        hm.\\<alpha> (hm.empty ()) r = Some (card (set (rhsq r))))\n 2. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> \\<delta>;\n        hm.invar \\<sigma> \\<and>\n        (\\<forall>r\\<in>ls.\\<alpha> \\<delta> - it.\n            hm.\\<alpha> \\<sigma> r = Some (card (set (rhsq r))))\\<rbrakk>\n       \\<Longrightarrow> hm.invar\n                          (hm.update x (length (remdups (rhsq x)))\n                            \\<sigma>) \\<and>\n                         (\\<forall>r\\<in>ls.\\<alpha> \\<delta> - (it - {x}).\n                             hm.\\<alpha>\n                              (hm.update x (length (remdups (rhsq x)))\n                                \\<sigma>)\n                              r =\n                             Some (card (set (rhsq r))))\n 3. \\<And>\\<sigma>.\n       hm.invar \\<sigma> \\<and>\n       (\\<forall>r\\<in>ls.\\<alpha> \\<delta> - {}.\n           hm.\\<alpha> \\<sigma> r =\n           Some (card (set (rhsq r)))) \\<Longrightarrow>\n       (\\<forall>r\\<in>ls.\\<alpha> \\<delta>.\n           hm.\\<alpha> \\<sigma> r = Some (card (set (rhsq r)))) \\<and>\n       hm.invar \\<sigma>", "apply (auto simp add: hm_correct) [1]\n      \\<comment> \\<open>Step\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> \\<delta>;\n        hm.invar \\<sigma> \\<and>\n        (\\<forall>r\\<in>ls.\\<alpha> \\<delta> - it.\n            hm.\\<alpha> \\<sigma> r = Some (card (set (rhsq r))))\\<rbrakk>\n       \\<Longrightarrow> hm.invar\n                          (hm.update x (length (remdups (rhsq x)))\n                            \\<sigma>) \\<and>\n                         (\\<forall>r\\<in>ls.\\<alpha> \\<delta> - (it - {x}).\n                             hm.\\<alpha>\n                              (hm.update x (length (remdups (rhsq x)))\n                                \\<sigma>)\n                              r =\n                             Some (card (set (rhsq r))))\n 2. \\<And>\\<sigma>.\n       hm.invar \\<sigma> \\<and>\n       (\\<forall>r\\<in>ls.\\<alpha> \\<delta> - {}.\n           hm.\\<alpha> \\<sigma> r =\n           Some (card (set (rhsq r)))) \\<Longrightarrow>\n       (\\<forall>r\\<in>ls.\\<alpha> \\<delta>.\n           hm.\\<alpha> \\<sigma> r = Some (card (set (rhsq r)))) \\<and>\n       hm.invar \\<sigma>", "apply (rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> \\<delta>;\n        hm.invar \\<sigma> \\<and>\n        (\\<forall>r\\<in>ls.\\<alpha> \\<delta> - it.\n            hm.\\<alpha> \\<sigma> r = Some (card (set (rhsq r))))\\<rbrakk>\n       \\<Longrightarrow> hm.invar\n                          (hm.update x (length (remdups (rhsq x))) \\<sigma>)\n 2. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> \\<delta>;\n        hm.invar \\<sigma> \\<and>\n        (\\<forall>r\\<in>ls.\\<alpha> \\<delta> - it.\n            hm.\\<alpha> \\<sigma> r = Some (card (set (rhsq r))))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r\\<in>ls.\\<alpha> \\<delta> - (it - {x}).\n                            hm.\\<alpha>\n                             (hm.update x (length (remdups (rhsq x)))\n                               \\<sigma>)\n                             r =\n                            Some (card (set (rhsq r)))\n 3. \\<And>\\<sigma>.\n       hm.invar \\<sigma> \\<and>\n       (\\<forall>r\\<in>ls.\\<alpha> \\<delta> - {}.\n           hm.\\<alpha> \\<sigma> r =\n           Some (card (set (rhsq r)))) \\<Longrightarrow>\n       (\\<forall>r\\<in>ls.\\<alpha> \\<delta>.\n           hm.\\<alpha> \\<sigma> r = Some (card (set (rhsq r)))) \\<and>\n       hm.invar \\<sigma>", "apply (simp add: hm.update_correct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> \\<delta>;\n        hm.invar \\<sigma> \\<and>\n        (\\<forall>r\\<in>ls.\\<alpha> \\<delta> - it.\n            hm.\\<alpha> \\<sigma> r = Some (card (set (rhsq r))))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r\\<in>ls.\\<alpha> \\<delta> - (it - {x}).\n                            hm.\\<alpha>\n                             (hm.update x (length (remdups (rhsq x)))\n                               \\<sigma>)\n                             r =\n                            Some (card (set (rhsq r)))\n 2. \\<And>\\<sigma>.\n       hm.invar \\<sigma> \\<and>\n       (\\<forall>r\\<in>ls.\\<alpha> \\<delta> - {}.\n           hm.\\<alpha> \\<sigma> r =\n           Some (card (set (rhsq r)))) \\<Longrightarrow>\n       (\\<forall>r\\<in>ls.\\<alpha> \\<delta>.\n           hm.\\<alpha> \\<sigma> r = Some (card (set (rhsq r)))) \\<and>\n       hm.invar \\<sigma>", "apply (simp only: hm_correct hs_correct INV)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> \\<delta>;\n        hm.invar \\<sigma> \\<and>\n        (\\<forall>r\\<in>ls.\\<alpha> \\<delta> - it.\n            hm.\\<alpha> \\<sigma> r = Some (card (set (rhsq r))))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r\\<in>ls.\\<alpha> \\<delta> - (it - {x}).\n                            (hm.\\<alpha> \\<sigma>(x \\<mapsto>\n                             length (remdups (rhsq x))))\n                             r =\n                            Some (card (set (rhsq r)))\n 2. \\<And>\\<sigma>.\n       hm.invar \\<sigma> \\<and>\n       (\\<forall>r\\<in>ls.\\<alpha> \\<delta> - {}.\n           hm.\\<alpha> \\<sigma> r =\n           Some (card (set (rhsq r)))) \\<Longrightarrow>\n       (\\<forall>r\\<in>ls.\\<alpha> \\<delta>.\n           hm.\\<alpha> \\<sigma> r = Some (card (set (rhsq r)))) \\<and>\n       hm.invar \\<sigma>", "apply (rule ballI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x it \\<sigma> r.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> \\<delta>;\n        hm.invar \\<sigma> \\<and>\n        (\\<forall>r\\<in>ls.\\<alpha> \\<delta> - it.\n            hm.\\<alpha> \\<sigma> r = Some (card (set (rhsq r))));\n        r \\<in> ls.\\<alpha> \\<delta> - (it - {x})\\<rbrakk>\n       \\<Longrightarrow> (hm.\\<alpha> \\<sigma>(x \\<mapsto>\n                          length (remdups (rhsq x))))\n                          r =\n                         Some (card (set (rhsq r)))\n 2. \\<And>\\<sigma>.\n       hm.invar \\<sigma> \\<and>\n       (\\<forall>r\\<in>ls.\\<alpha> \\<delta> - {}.\n           hm.\\<alpha> \\<sigma> r =\n           Some (card (set (rhsq r)))) \\<Longrightarrow>\n       (\\<forall>r\\<in>ls.\\<alpha> \\<delta>.\n           hm.\\<alpha> \\<sigma> r = Some (card (set (rhsq r)))) \\<and>\n       hm.invar \\<sigma>", "apply (case_tac \"r=x\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x it \\<sigma> r.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> \\<delta>;\n        hm.invar \\<sigma> \\<and>\n        (\\<forall>r\\<in>ls.\\<alpha> \\<delta> - it.\n            hm.\\<alpha> \\<sigma> r = Some (card (set (rhsq r))));\n        r \\<in> ls.\\<alpha> \\<delta> - (it - {x}); r = x\\<rbrakk>\n       \\<Longrightarrow> (hm.\\<alpha> \\<sigma>(x \\<mapsto>\n                          length (remdups (rhsq x))))\n                          r =\n                         Some (card (set (rhsq r)))\n 2. \\<And>x it \\<sigma> r.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> \\<delta>;\n        hm.invar \\<sigma> \\<and>\n        (\\<forall>r\\<in>ls.\\<alpha> \\<delta> - it.\n            hm.\\<alpha> \\<sigma> r = Some (card (set (rhsq r))));\n        r \\<in> ls.\\<alpha> \\<delta> - (it - {x}); r \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> (hm.\\<alpha> \\<sigma>(x \\<mapsto>\n                          length (remdups (rhsq x))))\n                          r =\n                         Some (card (set (rhsq r)))\n 3. \\<And>\\<sigma>.\n       hm.invar \\<sigma> \\<and>\n       (\\<forall>r\\<in>ls.\\<alpha> \\<delta> - {}.\n           hm.\\<alpha> \\<sigma> r =\n           Some (card (set (rhsq r)))) \\<Longrightarrow>\n       (\\<forall>r\\<in>ls.\\<alpha> \\<delta>.\n           hm.\\<alpha> \\<sigma> r = Some (card (set (rhsq r)))) \\<and>\n       hm.invar \\<sigma>", "apply (auto \n        simp add: length_remdups_card \n        intro!: arg_cong[where f=card]) [1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x it \\<sigma> r.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> \\<delta>;\n        hm.invar \\<sigma> \\<and>\n        (\\<forall>r\\<in>ls.\\<alpha> \\<delta> - it.\n            hm.\\<alpha> \\<sigma> r = Some (card (set (rhsq r))));\n        r \\<in> ls.\\<alpha> \\<delta> - (it - {x}); r \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> (hm.\\<alpha> \\<sigma>(x \\<mapsto>\n                          length (remdups (rhsq x))))\n                          r =\n                         Some (card (set (rhsq r)))\n 2. \\<And>\\<sigma>.\n       hm.invar \\<sigma> \\<and>\n       (\\<forall>r\\<in>ls.\\<alpha> \\<delta> - {}.\n           hm.\\<alpha> \\<sigma> r =\n           Some (card (set (rhsq r)))) \\<Longrightarrow>\n       (\\<forall>r\\<in>ls.\\<alpha> \\<delta>.\n           hm.\\<alpha> \\<sigma> r = Some (card (set (rhsq r)))) \\<and>\n       hm.invar \\<sigma>", "apply simp\n      \\<comment> \\<open>Final\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       hm.invar \\<sigma> \\<and>\n       (\\<forall>r\\<in>ls.\\<alpha> \\<delta> - {}.\n           hm.\\<alpha> \\<sigma> r =\n           Some (card (set (rhsq r)))) \\<Longrightarrow>\n       (\\<forall>r\\<in>ls.\\<alpha> \\<delta>.\n           hm.\\<alpha> \\<sigma> r = Some (card (set (rhsq r)))) \\<and>\n       hm.invar \\<sigma>", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<forall>r\\<in>ls.\\<alpha> \\<delta>.\n      hm.\\<alpha> (brc_rcm_init \\<delta>) r =\n      Some (card (set (rhsq r)))) \\<and>\n  hm.invar (brc_rcm_init \\<delta>)\n\ngoal (2 subgoals):\n 1. r \\<in> ls.\\<alpha> \\<delta> \\<Longrightarrow>\n    hm.\\<alpha> (brc_rcm_init \\<delta>) r = Some (card (set (rhsq r)))\n 2. hm.invar (brc_rcm_init \\<delta>)", "from G"], ["proof (chain)\npicking this:\n  (\\<forall>r\\<in>ls.\\<alpha> \\<delta>.\n      hm.\\<alpha> (brc_rcm_init \\<delta>) r =\n      Some (card (set (rhsq r)))) \\<and>\n  hm.invar (brc_rcm_init \\<delta>)", "show ?T2"], ["proof (prove)\nusing this:\n  (\\<forall>r\\<in>ls.\\<alpha> \\<delta>.\n      hm.\\<alpha> (brc_rcm_init \\<delta>) r =\n      Some (card (set (rhsq r)))) \\<and>\n  hm.invar (brc_rcm_init \\<delta>)\n\ngoal (1 subgoal):\n 1. hm.invar (brc_rcm_init \\<delta>)", "by auto"], ["proof (state)\nthis:\n  hm.invar (brc_rcm_init \\<delta>)\n\ngoal (1 subgoal):\n 1. r \\<in> ls.\\<alpha> \\<delta> \\<Longrightarrow>\n    hm.\\<alpha> (brc_rcm_init \\<delta>) r = Some (card (set (rhsq r)))", "fix r"], ["proof (state)\ngoal (1 subgoal):\n 1. r \\<in> ls.\\<alpha> \\<delta> \\<Longrightarrow>\n    hm.\\<alpha> (brc_rcm_init \\<delta>) r = Some (card (set (rhsq r)))", "assume \"r\\<in>ls_\\<alpha> \\<delta>\""], ["proof (state)\nthis:\n  r \\<in> ls.\\<alpha> \\<delta>\n\ngoal (1 subgoal):\n 1. r \\<in> ls.\\<alpha> \\<delta> \\<Longrightarrow>\n    hm.\\<alpha> (brc_rcm_init \\<delta>) r = Some (card (set (rhsq r)))", "thus \"?T1 r\""], ["proof (prove)\nusing this:\n  r \\<in> ls.\\<alpha> \\<delta>\n\ngoal (1 subgoal):\n 1. hm.\\<alpha> (brc_rcm_init \\<delta>) r = Some (card (set (rhsq r)))", "using G"], ["proof (prove)\nusing this:\n  r \\<in> ls.\\<alpha> \\<delta>\n  (\\<forall>r\\<in>ls.\\<alpha> \\<delta>.\n      hm.\\<alpha> (brc_rcm_init \\<delta>) r =\n      Some (card (set (rhsq r)))) \\<and>\n  hm.invar (brc_rcm_init \\<delta>)\n\ngoal (1 subgoal):\n 1. hm.\\<alpha> (brc_rcm_init \\<delta>) r = Some (card (set (rhsq r)))", "by auto"], ["proof (state)\nthis:\n  hm.\\<alpha> (brc_rcm_init \\<delta>) r = Some (card (set (rhsq r)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma brc_inner_step_br'_desc: \n  \"\\<lbrakk> (Q,W,rcm)\\<in>brc_invar \\<delta> \\<rbrakk> \\<Longrightarrow> brc_\\<alpha> (brc_inner_step r (Q,W,rcm)) = (\n    if the (hm_\\<alpha> rcm r) \\<le> 1 then \n      insert (lhs r) (hs_\\<alpha> Q) \n    else hs_\\<alpha> Q, \n    if the (hm_\\<alpha> rcm r) \\<le> 1 \\<and> (lhs r) \\<notin> hs_\\<alpha> Q then \n      insert (lhs r) (set W) \n    else (set W), \n    ((hm_\\<alpha> rcm)(r \\<mapsto> the (hm_\\<alpha> rcm r) - 1))\n  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Q, W, rcm) \\<in> brc_invar \\<delta> \\<Longrightarrow>\n    brc_\\<alpha> (brc_inner_step r (Q, W, rcm)) =\n    (if the (hm.\\<alpha> rcm r) \\<le> 1 then insert (lhs r) (hs.\\<alpha> Q)\n     else hs.\\<alpha> Q,\n     if the (hm.\\<alpha> rcm r) \\<le> 1 \\<and> lhs r \\<notin> hs.\\<alpha> Q\n     then insert (lhs r) (set W) else set W,\n     hm.\\<alpha> rcm(r \\<mapsto> the (hm.\\<alpha> rcm r) - 1))", "by (simp \n    add: brc_invar_def brc_invar_add_def brc_\\<alpha>_def brc_inner_step_def Let_def \n         hs_correct hm_correct)"], ["", "lemma brc_step_invar:\n  assumes RQRM: \"rqrm_invar rqrm\"\n  shows \"\\<lbrakk> \\<Sigma>\\<in>brc_invar_add; brc_\\<alpha> \\<Sigma>\\<in>br'_invar \\<delta>; brc_cond \\<Sigma> \\<rbrakk> \n         \\<Longrightarrow> (brc_step rqrm \\<Sigma>)\\<in>brc_invar_add\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Sigma> \\<in> brc_invar_add;\n     brc_\\<alpha> \\<Sigma> \\<in> br'_invar \\<delta>;\n     brc_cond \\<Sigma>\\<rbrakk>\n    \\<Longrightarrow> brc_step rqrm \\<Sigma> \\<in> brc_invar_add", "apply (cases \\<Sigma>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>\\<Sigma> \\<in> brc_invar_add;\n        brc_\\<alpha> \\<Sigma> \\<in> br'_invar \\<delta>; brc_cond \\<Sigma>;\n        \\<Sigma> = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> brc_step rqrm \\<Sigma> \\<in> brc_invar_add", "apply (simp add: brc_step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>(a, b, c) \\<in> brc_invar_add;\n        brc_\\<alpha> (a, b, c) \\<in> br'_invar \\<delta>; brc_cond (a, b, c);\n        \\<Sigma> = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> ls.iterate (rqrm_lookup rqrm (hd b)) brc_inner_step\n                          (a, tl b, c)\n                         \\<in> brc_invar_add", "apply (rule_tac I=\"\\<lambda>it (Q,W,rcm). (Q,W,rcm)\\<in>brc_invar_add \\<and> set W \\<subseteq> hs_\\<alpha> Q\" \n                  in ls.iterate_rule_P)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>(a, b, c) \\<in> brc_invar_add;\n        brc_\\<alpha> (a, b, c) \\<in> br'_invar \\<delta>; brc_cond (a, b, c);\n        \\<Sigma> = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> ls.invar (rqrm_lookup rqrm (hd b))\n 2. \\<And>a b c.\n       \\<lbrakk>(a, b, c) \\<in> brc_invar_add;\n        brc_\\<alpha> (a, b, c) \\<in> br'_invar \\<delta>; brc_cond (a, b, c);\n        \\<Sigma> = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> case (a, tl b, c) of\n                         (Q, W, rcm) \\<Rightarrow>\n                           (Q, W, rcm) \\<in> brc_invar_add \\<and>\n                           set W \\<subseteq> hs.\\<alpha> Q\n 3. \\<And>a b c x it \\<sigma>.\n       \\<lbrakk>(a, b, c) \\<in> brc_invar_add;\n        brc_\\<alpha> (a, b, c) \\<in> br'_invar \\<delta>; brc_cond (a, b, c);\n        \\<Sigma> = (a, b, c); x \\<in> it;\n        it \\<subseteq> ls.\\<alpha> (rqrm_lookup rqrm (hd b));\n        case \\<sigma> of\n        (Q, W, rcm) \\<Rightarrow>\n          (Q, W, rcm) \\<in> brc_invar_add \\<and>\n          set W \\<subseteq> hs.\\<alpha> Q\\<rbrakk>\n       \\<Longrightarrow> case brc_inner_step x \\<sigma> of\n                         (Q, W, rcm) \\<Rightarrow>\n                           (Q, W, rcm) \\<in> brc_invar_add \\<and>\n                           set W \\<subseteq> hs.\\<alpha> Q\n 4. \\<And>a b c \\<sigma>.\n       \\<lbrakk>(a, b, c) \\<in> brc_invar_add;\n        brc_\\<alpha> (a, b, c) \\<in> br'_invar \\<delta>; brc_cond (a, b, c);\n        \\<Sigma> = (a, b, c);\n        case \\<sigma> of\n        (Q, W, rcm) \\<Rightarrow>\n          (Q, W, rcm) \\<in> brc_invar_add \\<and>\n          set W \\<subseteq> hs.\\<alpha> Q\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<in> brc_invar_add", "apply (simp add: RQRM[unfolded rqrm_invar_def])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>(a, b, c) \\<in> brc_invar_add;\n        brc_\\<alpha> (a, b, c) \\<in> br'_invar \\<delta>; brc_cond (a, b, c);\n        \\<Sigma> = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> case (a, tl b, c) of\n                         (Q, W, rcm) \\<Rightarrow>\n                           (Q, W, rcm) \\<in> brc_invar_add \\<and>\n                           set W \\<subseteq> hs.\\<alpha> Q\n 2. \\<And>a b c x it \\<sigma>.\n       \\<lbrakk>(a, b, c) \\<in> brc_invar_add;\n        brc_\\<alpha> (a, b, c) \\<in> br'_invar \\<delta>; brc_cond (a, b, c);\n        \\<Sigma> = (a, b, c); x \\<in> it;\n        it \\<subseteq> ls.\\<alpha> (rqrm_lookup rqrm (hd b));\n        case \\<sigma> of\n        (Q, W, rcm) \\<Rightarrow>\n          (Q, W, rcm) \\<in> brc_invar_add \\<and>\n          set W \\<subseteq> hs.\\<alpha> Q\\<rbrakk>\n       \\<Longrightarrow> case brc_inner_step x \\<sigma> of\n                         (Q, W, rcm) \\<Rightarrow>\n                           (Q, W, rcm) \\<in> brc_invar_add \\<and>\n                           set W \\<subseteq> hs.\\<alpha> Q\n 3. \\<And>a b c \\<sigma>.\n       \\<lbrakk>(a, b, c) \\<in> brc_invar_add;\n        brc_\\<alpha> (a, b, c) \\<in> br'_invar \\<delta>; brc_cond (a, b, c);\n        \\<Sigma> = (a, b, c);\n        case \\<sigma> of\n        (Q, W, rcm) \\<Rightarrow>\n          (Q, W, rcm) \\<in> brc_invar_add \\<and>\n          set W \\<subseteq> hs.\\<alpha> Q\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<in> brc_invar_add", "apply (case_tac b)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>(a, b, c) \\<in> brc_invar_add;\n        brc_\\<alpha> (a, b, c) \\<in> br'_invar \\<delta>; brc_cond (a, b, c);\n        \\<Sigma> = (a, b, c); b = []\\<rbrakk>\n       \\<Longrightarrow> case (a, tl b, c) of\n                         (Q, W, rcm) \\<Rightarrow>\n                           (Q, W, rcm) \\<in> brc_invar_add \\<and>\n                           set W \\<subseteq> hs.\\<alpha> Q\n 2. \\<And>a b c aa list.\n       \\<lbrakk>(a, b, c) \\<in> brc_invar_add;\n        brc_\\<alpha> (a, b, c) \\<in> br'_invar \\<delta>; brc_cond (a, b, c);\n        \\<Sigma> = (a, b, c); b = aa # list\\<rbrakk>\n       \\<Longrightarrow> case (a, tl b, c) of\n                         (Q, W, rcm) \\<Rightarrow>\n                           (Q, W, rcm) \\<in> brc_invar_add \\<and>\n                           set W \\<subseteq> hs.\\<alpha> Q\n 3. \\<And>a b c x it \\<sigma>.\n       \\<lbrakk>(a, b, c) \\<in> brc_invar_add;\n        brc_\\<alpha> (a, b, c) \\<in> br'_invar \\<delta>; brc_cond (a, b, c);\n        \\<Sigma> = (a, b, c); x \\<in> it;\n        it \\<subseteq> ls.\\<alpha> (rqrm_lookup rqrm (hd b));\n        case \\<sigma> of\n        (Q, W, rcm) \\<Rightarrow>\n          (Q, W, rcm) \\<in> brc_invar_add \\<and>\n          set W \\<subseteq> hs.\\<alpha> Q\\<rbrakk>\n       \\<Longrightarrow> case brc_inner_step x \\<sigma> of\n                         (Q, W, rcm) \\<Rightarrow>\n                           (Q, W, rcm) \\<in> brc_invar_add \\<and>\n                           set W \\<subseteq> hs.\\<alpha> Q\n 4. \\<And>a b c \\<sigma>.\n       \\<lbrakk>(a, b, c) \\<in> brc_invar_add;\n        brc_\\<alpha> (a, b, c) \\<in> br'_invar \\<delta>; brc_cond (a, b, c);\n        \\<Sigma> = (a, b, c);\n        case \\<sigma> of\n        (Q, W, rcm) \\<Rightarrow>\n          (Q, W, rcm) \\<in> brc_invar_add \\<and>\n          set W \\<subseteq> hs.\\<alpha> Q\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<in> brc_invar_add", "apply (simp add: brc_invar_add_def distinct_tl brc_cond_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b c aa list.\n       \\<lbrakk>(a, b, c) \\<in> brc_invar_add;\n        brc_\\<alpha> (a, b, c) \\<in> br'_invar \\<delta>; brc_cond (a, b, c);\n        \\<Sigma> = (a, b, c); b = aa # list\\<rbrakk>\n       \\<Longrightarrow> case (a, tl b, c) of\n                         (Q, W, rcm) \\<Rightarrow>\n                           (Q, W, rcm) \\<in> brc_invar_add \\<and>\n                           set W \\<subseteq> hs.\\<alpha> Q\n 2. \\<And>a b c x it \\<sigma>.\n       \\<lbrakk>(a, b, c) \\<in> brc_invar_add;\n        brc_\\<alpha> (a, b, c) \\<in> br'_invar \\<delta>; brc_cond (a, b, c);\n        \\<Sigma> = (a, b, c); x \\<in> it;\n        it \\<subseteq> ls.\\<alpha> (rqrm_lookup rqrm (hd b));\n        case \\<sigma> of\n        (Q, W, rcm) \\<Rightarrow>\n          (Q, W, rcm) \\<in> brc_invar_add \\<and>\n          set W \\<subseteq> hs.\\<alpha> Q\\<rbrakk>\n       \\<Longrightarrow> case brc_inner_step x \\<sigma> of\n                         (Q, W, rcm) \\<Rightarrow>\n                           (Q, W, rcm) \\<in> brc_invar_add \\<and>\n                           set W \\<subseteq> hs.\\<alpha> Q\n 3. \\<And>a b c \\<sigma>.\n       \\<lbrakk>(a, b, c) \\<in> brc_invar_add;\n        brc_\\<alpha> (a, b, c) \\<in> br'_invar \\<delta>; brc_cond (a, b, c);\n        \\<Sigma> = (a, b, c);\n        case \\<sigma> of\n        (Q, W, rcm) \\<Rightarrow>\n          (Q, W, rcm) \\<in> brc_invar_add \\<and>\n          set W \\<subseteq> hs.\\<alpha> Q\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<in> brc_invar_add", "apply (auto simp add: brc_invar_add_def distinct_tl brc_cond_def \n              dest!: brc_inv_imp_WssQ) [1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c x it \\<sigma>.\n       \\<lbrakk>(a, b, c) \\<in> brc_invar_add;\n        brc_\\<alpha> (a, b, c) \\<in> br'_invar \\<delta>; brc_cond (a, b, c);\n        \\<Sigma> = (a, b, c); x \\<in> it;\n        it \\<subseteq> ls.\\<alpha> (rqrm_lookup rqrm (hd b));\n        case \\<sigma> of\n        (Q, W, rcm) \\<Rightarrow>\n          (Q, W, rcm) \\<in> brc_invar_add \\<and>\n          set W \\<subseteq> hs.\\<alpha> Q\\<rbrakk>\n       \\<Longrightarrow> case brc_inner_step x \\<sigma> of\n                         (Q, W, rcm) \\<Rightarrow>\n                           (Q, W, rcm) \\<in> brc_invar_add \\<and>\n                           set W \\<subseteq> hs.\\<alpha> Q\n 2. \\<And>a b c \\<sigma>.\n       \\<lbrakk>(a, b, c) \\<in> brc_invar_add;\n        brc_\\<alpha> (a, b, c) \\<in> br'_invar \\<delta>; brc_cond (a, b, c);\n        \\<Sigma> = (a, b, c);\n        case \\<sigma> of\n        (Q, W, rcm) \\<Rightarrow>\n          (Q, W, rcm) \\<in> brc_invar_add \\<and>\n          set W \\<subseteq> hs.\\<alpha> Q\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<in> brc_invar_add", "apply (case_tac \\<sigma>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c x it \\<sigma> aa ba ca.\n       \\<lbrakk>(a, b, c) \\<in> brc_invar_add;\n        brc_\\<alpha> (a, b, c) \\<in> br'_invar \\<delta>; brc_cond (a, b, c);\n        \\<Sigma> = (a, b, c); x \\<in> it;\n        it \\<subseteq> ls.\\<alpha> (rqrm_lookup rqrm (hd b));\n        case \\<sigma> of\n        (Q, W, rcm) \\<Rightarrow>\n          (Q, W, rcm) \\<in> brc_invar_add \\<and>\n          set W \\<subseteq> hs.\\<alpha> Q;\n        \\<sigma> = (aa, ba, ca)\\<rbrakk>\n       \\<Longrightarrow> case brc_inner_step x \\<sigma> of\n                         (Q, W, rcm) \\<Rightarrow>\n                           (Q, W, rcm) \\<in> brc_invar_add \\<and>\n                           set W \\<subseteq> hs.\\<alpha> Q\n 2. \\<And>a b c \\<sigma>.\n       \\<lbrakk>(a, b, c) \\<in> brc_invar_add;\n        brc_\\<alpha> (a, b, c) \\<in> br'_invar \\<delta>; brc_cond (a, b, c);\n        \\<Sigma> = (a, b, c);\n        case \\<sigma> of\n        (Q, W, rcm) \\<Rightarrow>\n          (Q, W, rcm) \\<in> brc_invar_add \\<and>\n          set W \\<subseteq> hs.\\<alpha> Q\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<in> brc_invar_add", "apply (auto simp add: brc_invar_add_def br_invar_def brc_inner_step_def \n                        Let_def hs_correct hm_correct) [1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c \\<sigma>.\n       \\<lbrakk>(a, b, c) \\<in> brc_invar_add;\n        brc_\\<alpha> (a, b, c) \\<in> br'_invar \\<delta>; brc_cond (a, b, c);\n        \\<Sigma> = (a, b, c);\n        case \\<sigma> of\n        (Q, W, rcm) \\<Rightarrow>\n          (Q, W, rcm) \\<in> brc_invar_add \\<and>\n          set W \\<subseteq> hs.\\<alpha> Q\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<in> brc_invar_add", "apply (case_tac \\<sigma>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c \\<sigma> aa ba ca.\n       \\<lbrakk>(a, b, c) \\<in> brc_invar_add;\n        brc_\\<alpha> (a, b, c) \\<in> br'_invar \\<delta>; brc_cond (a, b, c);\n        \\<Sigma> = (a, b, c);\n        case \\<sigma> of\n        (Q, W, rcm) \\<Rightarrow>\n          (Q, W, rcm) \\<in> brc_invar_add \\<and>\n          set W \\<subseteq> hs.\\<alpha> Q;\n        \\<sigma> = (aa, ba, ca)\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<in> brc_invar_add", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma brc_step_abs:\n  assumes RQRM: \"rqrm_invar rqrm\" \"rqrm_prop \\<delta> rqrm\"\n  assumes A: \"\\<Sigma>\\<in>brc_invar \\<delta>\" \"brc_cond \\<Sigma>\"  \n  shows \"(brc_\\<alpha> \\<Sigma>, brc_\\<alpha> (brc_step rqrm \\<Sigma>)) \\<in> br'_step \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (brc_\\<alpha> \\<Sigma>, brc_\\<alpha> (brc_step rqrm \\<Sigma>))\n    \\<in> br'_step \\<delta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (brc_\\<alpha> \\<Sigma>, brc_\\<alpha> (brc_step rqrm \\<Sigma>))\n    \\<in> br'_step \\<delta>", "obtain Q W rcm where [simp]: \"\\<Sigma>=(Q,W,rcm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Q W rcm.\n        \\<Sigma> = (Q, W, rcm) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \\<Sigma>) auto"], ["proof (state)\nthis:\n  \\<Sigma> = (Q, W, rcm)\n\ngoal (1 subgoal):\n 1. (brc_\\<alpha> \\<Sigma>, brc_\\<alpha> (brc_step rqrm \\<Sigma>))\n    \\<in> br'_step \\<delta>", "from A"], ["proof (chain)\npicking this:\n  \\<Sigma> \\<in> brc_invar \\<delta>\n  brc_cond \\<Sigma>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Sigma> \\<in> brc_invar \\<delta>\n  brc_cond \\<Sigma>\n\ngoal (1 subgoal):\n 1. (brc_\\<alpha> \\<Sigma>, brc_\\<alpha> (brc_step rqrm \\<Sigma>))\n    \\<in> br'_step \\<delta>", "apply (simp add: brc_step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> (brc_\\<alpha> (Q, W, rcm),\n                       brc_\\<alpha>\n                        (ls.iterate (rqrm_lookup rqrm (hd W)) brc_inner_step\n                          (Q, tl W, rcm)))\n                      \\<in> br'_step \\<delta>", "apply (rule \n      br'_inner_step_proof[OF ls.v1_iteratei_impl, \n         where cinvar=\"\\<lambda>it (Q,W,rcm). (Q,W,rcm)\\<in>brc_invar_add \n                                      \\<and> set W \\<subseteq> hs_\\<alpha> Q\" and \n               q=\"hd W\"])"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> case (Q, tl W, rcm) of\n                      (Q, W, rcm) \\<Rightarrow>\n                        (Q, W, rcm) \\<in> brc_invar_add \\<and>\n                        set W \\<subseteq> hs.\\<alpha> Q\n 2. \\<And>it r \\<Sigma>.\n       \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>; brc_cond (Q, W, rcm);\n        r \\<in> it;\n        it \\<subseteq> {r \\<in> \\<delta>. hd W \\<in> set (rhsq r)};\n        case \\<Sigma> of\n        (Q, W, rcm) \\<Rightarrow>\n          (Q, W, rcm) \\<in> brc_invar_add \\<and>\n          set W \\<subseteq> hs.\\<alpha> Q\\<rbrakk>\n       \\<Longrightarrow> case brc_inner_step r \\<Sigma> of\n                         (Q, W, rcm) \\<Rightarrow>\n                           (Q, W, rcm) \\<in> brc_invar_add \\<and>\n                           set W \\<subseteq> hs.\\<alpha> Q\n 3. \\<And>it r \\<Sigma>.\n       \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>; brc_cond (Q, W, rcm);\n        r \\<in> it;\n        it \\<subseteq> {r \\<in> \\<delta>. hd W \\<in> set (rhsq r)};\n        case \\<Sigma> of\n        (Q, W, rcm) \\<Rightarrow>\n          (Q, W, rcm) \\<in> brc_invar_add \\<and>\n          set W \\<subseteq> hs.\\<alpha> Q\\<rbrakk>\n       \\<Longrightarrow> brc_\\<alpha> (brc_inner_step r \\<Sigma>) =\n                         br'_inner_step r (brc_\\<alpha> \\<Sigma>)\n 4. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> ls.invar (rqrm_lookup rqrm (hd W))\n 5. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> ls.\\<alpha> (rqrm_lookup rqrm (hd W)) =\n                      {r \\<in> \\<delta>. hd W \\<in> set (rhsq r)}\n 6. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> hd W \\<in> ?W2\n 7. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> brc_\\<alpha> (Q, W, rcm) = (?Q2, ?W2, ?rcm2)\n 8. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> brc_\\<alpha> (Q, tl W, rcm) =\n                      (?Q2, ?W2 - {hd W}, ?rcm2)", "apply (case_tac W)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>; brc_cond (Q, W, rcm);\n     W = []\\<rbrakk>\n    \\<Longrightarrow> case (Q, tl W, rcm) of\n                      (Q, W, rcm) \\<Rightarrow>\n                        (Q, W, rcm) \\<in> brc_invar_add \\<and>\n                        set W \\<subseteq> hs.\\<alpha> Q\n 2. \\<And>a list.\n       \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>; brc_cond (Q, W, rcm);\n        W = a # list\\<rbrakk>\n       \\<Longrightarrow> case (Q, tl W, rcm) of\n                         (Q, W, rcm) \\<Rightarrow>\n                           (Q, W, rcm) \\<in> brc_invar_add \\<and>\n                           set W \\<subseteq> hs.\\<alpha> Q\n 3. \\<And>it r \\<Sigma>.\n       \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>; brc_cond (Q, W, rcm);\n        r \\<in> it;\n        it \\<subseteq> {r \\<in> \\<delta>. hd W \\<in> set (rhsq r)};\n        case \\<Sigma> of\n        (Q, W, rcm) \\<Rightarrow>\n          (Q, W, rcm) \\<in> brc_invar_add \\<and>\n          set W \\<subseteq> hs.\\<alpha> Q\\<rbrakk>\n       \\<Longrightarrow> case brc_inner_step r \\<Sigma> of\n                         (Q, W, rcm) \\<Rightarrow>\n                           (Q, W, rcm) \\<in> brc_invar_add \\<and>\n                           set W \\<subseteq> hs.\\<alpha> Q\n 4. \\<And>it r \\<Sigma>.\n       \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>; brc_cond (Q, W, rcm);\n        r \\<in> it;\n        it \\<subseteq> {r \\<in> \\<delta>. hd W \\<in> set (rhsq r)};\n        case \\<Sigma> of\n        (Q, W, rcm) \\<Rightarrow>\n          (Q, W, rcm) \\<in> brc_invar_add \\<and>\n          set W \\<subseteq> hs.\\<alpha> Q\\<rbrakk>\n       \\<Longrightarrow> brc_\\<alpha> (brc_inner_step r \\<Sigma>) =\n                         br'_inner_step r (brc_\\<alpha> \\<Sigma>)\n 5. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> ls.invar (rqrm_lookup rqrm (hd W))\n 6. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> ls.\\<alpha> (rqrm_lookup rqrm (hd W)) =\n                      {r \\<in> \\<delta>. hd W \\<in> set (rhsq r)}\n 7. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> hd W \\<in> ?W2\n 8. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> brc_\\<alpha> (Q, W, rcm) = (?Q2, ?W2, ?rcm2)\n 9. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> brc_\\<alpha> (Q, tl W, rcm) =\n                      (?Q2, ?W2 - {hd W}, ?rcm2)", "apply (auto simp add: brc_cond_def brc_invar_add_def brc_invar_def \n                dest!: brc_inv_imp_WssQ) [2]"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>it r \\<Sigma>.\n       \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>; brc_cond (Q, W, rcm);\n        r \\<in> it;\n        it \\<subseteq> {r \\<in> \\<delta>. hd W \\<in> set (rhsq r)};\n        case \\<Sigma> of\n        (Q, W, rcm) \\<Rightarrow>\n          (Q, W, rcm) \\<in> brc_invar_add \\<and>\n          set W \\<subseteq> hs.\\<alpha> Q\\<rbrakk>\n       \\<Longrightarrow> case brc_inner_step r \\<Sigma> of\n                         (Q, W, rcm) \\<Rightarrow>\n                           (Q, W, rcm) \\<in> brc_invar_add \\<and>\n                           set W \\<subseteq> hs.\\<alpha> Q\n 2. \\<And>it r \\<Sigma>.\n       \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>; brc_cond (Q, W, rcm);\n        r \\<in> it;\n        it \\<subseteq> {r \\<in> \\<delta>. hd W \\<in> set (rhsq r)};\n        case \\<Sigma> of\n        (Q, W, rcm) \\<Rightarrow>\n          (Q, W, rcm) \\<in> brc_invar_add \\<and>\n          set W \\<subseteq> hs.\\<alpha> Q\\<rbrakk>\n       \\<Longrightarrow> brc_\\<alpha> (brc_inner_step r \\<Sigma>) =\n                         br'_inner_step r (brc_\\<alpha> \\<Sigma>)\n 3. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> ls.invar (rqrm_lookup rqrm (hd W))\n 4. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> ls.\\<alpha> (rqrm_lookup rqrm (hd W)) =\n                      {r \\<in> \\<delta>. hd W \\<in> set (rhsq r)}\n 5. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> hd W \\<in> ?W2\n 6. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> brc_\\<alpha> (Q, W, rcm) = (?Q2, ?W2, ?rcm2)\n 7. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> brc_\\<alpha> (Q, tl W, rcm) =\n                      (?Q2, ?W2 - {hd W}, ?rcm2)", "prefer 6"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> brc_\\<alpha> (Q, W, rcm) = (?Q2, ?W2, ?rcm2)\n 2. \\<And>it r \\<Sigma>.\n       \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>; brc_cond (Q, W, rcm);\n        r \\<in> it;\n        it \\<subseteq> {r \\<in> \\<delta>. hd W \\<in> set (rhsq r)};\n        case \\<Sigma> of\n        (Q, W, rcm) \\<Rightarrow>\n          (Q, W, rcm) \\<in> brc_invar_add \\<and>\n          set W \\<subseteq> hs.\\<alpha> Q\\<rbrakk>\n       \\<Longrightarrow> case brc_inner_step r \\<Sigma> of\n                         (Q, W, rcm) \\<Rightarrow>\n                           (Q, W, rcm) \\<in> brc_invar_add \\<and>\n                           set W \\<subseteq> hs.\\<alpha> Q\n 3. \\<And>it r \\<Sigma>.\n       \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>; brc_cond (Q, W, rcm);\n        r \\<in> it;\n        it \\<subseteq> {r \\<in> \\<delta>. hd W \\<in> set (rhsq r)};\n        case \\<Sigma> of\n        (Q, W, rcm) \\<Rightarrow>\n          (Q, W, rcm) \\<in> brc_invar_add \\<and>\n          set W \\<subseteq> hs.\\<alpha> Q\\<rbrakk>\n       \\<Longrightarrow> brc_\\<alpha> (brc_inner_step r \\<Sigma>) =\n                         br'_inner_step r (brc_\\<alpha> \\<Sigma>)\n 4. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> ls.invar (rqrm_lookup rqrm (hd W))\n 5. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> ls.\\<alpha> (rqrm_lookup rqrm (hd W)) =\n                      {r \\<in> \\<delta>. hd W \\<in> set (rhsq r)}\n 6. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> hd W \\<in> ?W2\n 7. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> brc_\\<alpha> (Q, tl W, rcm) =\n                      (?Q2, ?W2 - {hd W}, ?rcm2)", "apply (simp add: brc_\\<alpha>_def)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>it r \\<Sigma>.\n       \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>; brc_cond (Q, W, rcm);\n        r \\<in> it;\n        it \\<subseteq> {r \\<in> \\<delta>. hd W \\<in> set (rhsq r)};\n        case \\<Sigma> of\n        (Q, W, rcm) \\<Rightarrow>\n          (Q, W, rcm) \\<in> brc_invar_add \\<and>\n          set W \\<subseteq> hs.\\<alpha> Q\\<rbrakk>\n       \\<Longrightarrow> case brc_inner_step r \\<Sigma> of\n                         (Q, W, rcm) \\<Rightarrow>\n                           (Q, W, rcm) \\<in> brc_invar_add \\<and>\n                           set W \\<subseteq> hs.\\<alpha> Q\n 2. \\<And>it r \\<Sigma>.\n       \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>; brc_cond (Q, W, rcm);\n        r \\<in> it;\n        it \\<subseteq> {r \\<in> \\<delta>. hd W \\<in> set (rhsq r)};\n        case \\<Sigma> of\n        (Q, W, rcm) \\<Rightarrow>\n          (Q, W, rcm) \\<in> brc_invar_add \\<and>\n          set W \\<subseteq> hs.\\<alpha> Q\\<rbrakk>\n       \\<Longrightarrow> brc_\\<alpha> (brc_inner_step r \\<Sigma>) =\n                         br'_inner_step r (brc_\\<alpha> \\<Sigma>)\n 3. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> ls.invar (rqrm_lookup rqrm (hd W))\n 4. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> ls.\\<alpha> (rqrm_lookup rqrm (hd W)) =\n                      {r \\<in> \\<delta>. hd W \\<in> set (rhsq r)}\n 5. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> hd W \\<in> set W\n 6. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> brc_\\<alpha> (Q, tl W, rcm) =\n                      (hs.\\<alpha> Q, set W - {hd W}, hm.\\<alpha> rcm)", "apply (case_tac \\<Sigma>)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>it r \\<Sigma> a b c.\n       \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>; brc_cond (Q, W, rcm);\n        r \\<in> it;\n        it \\<subseteq> {r \\<in> \\<delta>. hd W \\<in> set (rhsq r)};\n        case \\<Sigma> of\n        (Q, W, rcm) \\<Rightarrow>\n          (Q, W, rcm) \\<in> brc_invar_add \\<and>\n          set W \\<subseteq> hs.\\<alpha> Q;\n        \\<Sigma> = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> case brc_inner_step r \\<Sigma> of\n                         (Q, W, rcm) \\<Rightarrow>\n                           (Q, W, rcm) \\<in> brc_invar_add \\<and>\n                           set W \\<subseteq> hs.\\<alpha> Q\n 2. \\<And>it r \\<Sigma>.\n       \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>; brc_cond (Q, W, rcm);\n        r \\<in> it;\n        it \\<subseteq> {r \\<in> \\<delta>. hd W \\<in> set (rhsq r)};\n        case \\<Sigma> of\n        (Q, W, rcm) \\<Rightarrow>\n          (Q, W, rcm) \\<in> brc_invar_add \\<and>\n          set W \\<subseteq> hs.\\<alpha> Q\\<rbrakk>\n       \\<Longrightarrow> brc_\\<alpha> (brc_inner_step r \\<Sigma>) =\n                         br'_inner_step r (brc_\\<alpha> \\<Sigma>)\n 3. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> ls.invar (rqrm_lookup rqrm (hd W))\n 4. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> ls.\\<alpha> (rqrm_lookup rqrm (hd W)) =\n                      {r \\<in> \\<delta>. hd W \\<in> set (rhsq r)}\n 5. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> hd W \\<in> set W\n 6. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> brc_\\<alpha> (Q, tl W, rcm) =\n                      (hs.\\<alpha> Q, set W - {hd W}, hm.\\<alpha> rcm)", "apply (auto \n      simp add: brc_invar_def brc_invar_add_def brc_inner_step_def \n                Let_def hm_correct hs_correct) [1]"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>it r \\<Sigma>.\n       \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>; brc_cond (Q, W, rcm);\n        r \\<in> it;\n        it \\<subseteq> {r \\<in> \\<delta>. hd W \\<in> set (rhsq r)};\n        case \\<Sigma> of\n        (Q, W, rcm) \\<Rightarrow>\n          (Q, W, rcm) \\<in> brc_invar_add \\<and>\n          set W \\<subseteq> hs.\\<alpha> Q\\<rbrakk>\n       \\<Longrightarrow> brc_\\<alpha> (brc_inner_step r \\<Sigma>) =\n                         br'_inner_step r (brc_\\<alpha> \\<Sigma>)\n 2. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> ls.invar (rqrm_lookup rqrm (hd W))\n 3. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> ls.\\<alpha> (rqrm_lookup rqrm (hd W)) =\n                      {r \\<in> \\<delta>. hd W \\<in> set (rhsq r)}\n 4. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> hd W \\<in> set W\n 5. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> brc_\\<alpha> (Q, tl W, rcm) =\n                      (hs.\\<alpha> Q, set W - {hd W}, hm.\\<alpha> rcm)", "apply (auto \n      simp add: brc_invar_add_def brc_inner_step_def brc_\\<alpha>_def \n                br'_inner_step_def Let_def hm_correct hs_correct) [1]"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> ls.invar (rqrm_lookup rqrm (hd W))\n 2. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> ls.\\<alpha> (rqrm_lookup rqrm (hd W)) =\n                      {r \\<in> \\<delta>. hd W \\<in> set (rhsq r)}\n 3. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> hd W \\<in> set W\n 4. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> brc_\\<alpha> (Q, tl W, rcm) =\n                      (hs.\\<alpha> Q, set W - {hd W}, hm.\\<alpha> rcm)", "apply (simp add: RQRM[unfolded rqrm_invar_def])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> ls.\\<alpha> (rqrm_lookup rqrm (hd W)) =\n                      {r \\<in> \\<delta>. hd W \\<in> set (rhsq r)}\n 2. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> hd W \\<in> set W\n 3. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> brc_\\<alpha> (Q, tl W, rcm) =\n                      (hs.\\<alpha> Q, set W - {hd W}, hm.\\<alpha> rcm)", "apply (simp add: rqrm_propD[OF RQRM(2)])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> hd W \\<in> set W\n 2. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> brc_\\<alpha> (Q, tl W, rcm) =\n                      (hs.\\<alpha> Q, set W - {hd W}, hm.\\<alpha> rcm)", "apply (case_tac W)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>; brc_cond (Q, W, rcm);\n     W = []\\<rbrakk>\n    \\<Longrightarrow> hd W \\<in> set W\n 2. \\<And>a list.\n       \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>; brc_cond (Q, W, rcm);\n        W = a # list\\<rbrakk>\n       \\<Longrightarrow> hd W \\<in> set W\n 3. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> brc_\\<alpha> (Q, tl W, rcm) =\n                      (hs.\\<alpha> Q, set W - {hd W}, hm.\\<alpha> rcm)", "apply (simp_all add: brc_\\<alpha>_def brc_cond_def brc_invar_def) [2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>;\n     brc_cond (Q, W, rcm)\\<rbrakk>\n    \\<Longrightarrow> brc_\\<alpha> (Q, tl W, rcm) =\n                      (hs.\\<alpha> Q, set W - {hd W}, hm.\\<alpha> rcm)", "apply (case_tac W)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>; brc_cond (Q, W, rcm);\n     W = []\\<rbrakk>\n    \\<Longrightarrow> brc_\\<alpha> (Q, tl W, rcm) =\n                      (hs.\\<alpha> Q, set W - {hd W}, hm.\\<alpha> rcm)\n 2. \\<And>a list.\n       \\<lbrakk>(Q, W, rcm) \\<in> brc_invar \\<delta>; brc_cond (Q, W, rcm);\n        W = a # list\\<rbrakk>\n       \\<Longrightarrow> brc_\\<alpha> (Q, tl W, rcm) =\n                         (hs.\\<alpha> Q, set W - {hd W}, hm.\\<alpha> rcm)", "apply (simp_all add: brc_\\<alpha>_def brc_cond_def brc_invar_def \n                         brc_invar_add_def) [2]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (brc_\\<alpha> \\<Sigma>, brc_\\<alpha> (brc_step rqrm \\<Sigma>))\n  \\<in> br'_step \\<delta>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma brc_initial_invar: \"ls_invar \\<delta> \\<Longrightarrow> (brc_initial \\<delta>)\\<in>brc_invar_add\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ls.invar \\<delta> \\<Longrightarrow>\n    brc_initial \\<delta> \\<in> brc_invar_add", "by (simp \n    add: brc_invar_add_def brc_initial_def brc_iq_correct Let_def \n         brc_rcm_init_correct hs_correct)"], ["", "lemma brc_cond_abs: \"brc_cond \\<Sigma> \\<longleftrightarrow> (brc_\\<alpha> \\<Sigma>)\\<in>br'_cond\""], ["proof (prove)\ngoal (1 subgoal):\n 1. brc_cond \\<Sigma> = (brc_\\<alpha> \\<Sigma> \\<in> br'_cond)", "apply (cases \\<Sigma>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<Sigma> = (a, b, c) \\<Longrightarrow>\n       brc_cond \\<Sigma> = (brc_\\<alpha> \\<Sigma> \\<in> br'_cond)", "apply (simp add: brc_cond_def br'_cond_def brc_\\<alpha>_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma brc_initial_abs: \n  \"ls_invar \\<delta> \\<Longrightarrow> brc_\\<alpha> (brc_initial \\<delta>) \\<in> br'_initial (ls_\\<alpha> \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ls.invar \\<delta> \\<Longrightarrow>\n    brc_\\<alpha> (brc_initial \\<delta>)\n    \\<in> br'_initial (ls.\\<alpha> \\<delta>)", "by (auto \n    simp add: brc_initial_def Let_def brc_\\<alpha>_def brc_iq_correct \n              brc_rcm_init_correct hs_correct \n    intro: br'_initial.intros)"], ["", "lemma brc_pref_br':\n  assumes RQRM[simp]: \"rqrm_invar rqrm\" \"rqrm_prop (ls_\\<alpha> \\<delta>) rqrm\"\n  assumes INV[simp]: \"ls_invar \\<delta>\"\n  shows \"wa_precise_refine (det_wa_wa (brc_det_algo rqrm \\<delta>)) \n                           (br'_algo (ls_\\<alpha> \\<delta>)) \n                           brc_\\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wa_precise_refine (det_wa_wa (brc_det_algo rqrm \\<delta>))\n     (br'_algo (ls.\\<alpha> \\<delta>)) brc_\\<alpha>", "apply (unfold_locales)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> wa_invar (det_wa_wa (brc_det_algo rqrm \\<delta>));\n        s \\<in> wa_cond (det_wa_wa (brc_det_algo rqrm \\<delta>))\\<rbrakk>\n       \\<Longrightarrow> brc_\\<alpha> s\n                         \\<in> wa_cond (br'_algo (ls.\\<alpha> \\<delta>))\n 2. \\<And>s s'.\n       \\<lbrakk>s \\<in> wa_invar (det_wa_wa (brc_det_algo rqrm \\<delta>));\n        s \\<in> wa_cond (det_wa_wa (brc_det_algo rqrm \\<delta>));\n        (s, s')\n        \\<in> wa_step (det_wa_wa (brc_det_algo rqrm \\<delta>))\\<rbrakk>\n       \\<Longrightarrow> (brc_\\<alpha> s, brc_\\<alpha> s')\n                         \\<in> wa_step (br'_algo (ls.\\<alpha> \\<delta>))\n 3. brc_\\<alpha> ` wa_initial (det_wa_wa (brc_det_algo rqrm \\<delta>))\n    \\<subseteq> wa_initial (br'_algo (ls.\\<alpha> \\<delta>))\n 4. brc_\\<alpha> ` wa_invar (det_wa_wa (brc_det_algo rqrm \\<delta>))\n    \\<subseteq> wa_invar (br'_algo (ls.\\<alpha> \\<delta>))\n 5. \\<forall>s.\n       s \\<in> wa_invar (det_wa_wa (brc_det_algo rqrm \\<delta>)) \\<and>\n       brc_\\<alpha> s\n       \\<in> wa_cond (br'_algo (ls.\\<alpha> \\<delta>)) \\<longrightarrow>\n       s \\<in> wa_cond (det_wa_wa (brc_det_algo rqrm \\<delta>))", "apply (simp_all add: brc_det_algo_def br'_algo_def det_wa_wa_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> brc_invar (ls.\\<alpha> \\<delta>);\n        brc_cond s\\<rbrakk>\n       \\<Longrightarrow> brc_\\<alpha> s \\<in> br'_cond\n 2. \\<And>s s'.\n       \\<lbrakk>s \\<in> brc_invar (ls.\\<alpha> \\<delta>); brc_cond s;\n        \\<exists>a aa b.\n           s = (a, aa, b) \\<and> s' = brc_step rqrm (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> (brc_\\<alpha> s, brc_\\<alpha> s')\n                         \\<in> br'_step (ls.\\<alpha> \\<delta>)\n 3. brc_\\<alpha> (brc_initial \\<delta>)\n    \\<in> br'_initial (ls.\\<alpha> \\<delta>)\n 4. brc_\\<alpha> ` brc_invar (ls.\\<alpha> \\<delta>)\n    \\<subseteq> br'_invar (ls.\\<alpha> \\<delta>)\n 5. \\<forall>a aa b.\n       (a, aa, b) \\<in> brc_invar (ls.\\<alpha> \\<delta>) \\<and>\n       brc_\\<alpha> (a, aa, b) \\<in> br'_cond \\<longrightarrow>\n       brc_cond (a, aa, b)", "apply (simp add: brc_cond_abs)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>s \\<in> brc_invar (ls.\\<alpha> \\<delta>); brc_cond s;\n        \\<exists>a aa b.\n           s = (a, aa, b) \\<and> s' = brc_step rqrm (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> (brc_\\<alpha> s, brc_\\<alpha> s')\n                         \\<in> br'_step (ls.\\<alpha> \\<delta>)\n 2. brc_\\<alpha> (brc_initial \\<delta>)\n    \\<in> br'_initial (ls.\\<alpha> \\<delta>)\n 3. brc_\\<alpha> ` brc_invar (ls.\\<alpha> \\<delta>)\n    \\<subseteq> br'_invar (ls.\\<alpha> \\<delta>)\n 4. \\<forall>a aa b.\n       (a, aa, b) \\<in> brc_invar (ls.\\<alpha> \\<delta>) \\<and>\n       brc_\\<alpha> (a, aa, b) \\<in> br'_cond \\<longrightarrow>\n       brc_cond (a, aa, b)", "apply (auto simp add: brc_step_abs[OF RQRM]) [1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. brc_\\<alpha> (brc_initial \\<delta>)\n    \\<in> br'_initial (ls.\\<alpha> \\<delta>)\n 2. brc_\\<alpha> ` brc_invar (ls.\\<alpha> \\<delta>)\n    \\<subseteq> br'_invar (ls.\\<alpha> \\<delta>)\n 3. \\<forall>a aa b.\n       (a, aa, b) \\<in> brc_invar (ls.\\<alpha> \\<delta>) \\<and>\n       brc_\\<alpha> (a, aa, b) \\<in> br'_cond \\<longrightarrow>\n       brc_cond (a, aa, b)", "apply (simp add: brc_initial_abs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. brc_\\<alpha> ` brc_invar (ls.\\<alpha> \\<delta>)\n    \\<subseteq> br'_invar (ls.\\<alpha> \\<delta>)\n 2. \\<forall>a aa b.\n       (a, aa, b) \\<in> brc_invar (ls.\\<alpha> \\<delta>) \\<and>\n       brc_\\<alpha> (a, aa, b) \\<in> br'_cond \\<longrightarrow>\n       brc_cond (a, aa, b)", "apply (auto simp add: brc_invar_def) [1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a aa b.\n       (a, aa, b) \\<in> brc_invar (ls.\\<alpha> \\<delta>) \\<and>\n       brc_\\<alpha> (a, aa, b) \\<in> br'_cond \\<longrightarrow>\n       brc_cond (a, aa, b)", "apply (simp add: brc_cond_abs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma brc_while_algo:\n  assumes RQRM[simp]: \"rqrm_invar rqrm\" \"rqrm_prop (ls_\\<alpha> \\<delta>) rqrm\"\n  assumes INV[simp]: \"ls_invar \\<delta>\"\n  shows \"while_algo (det_wa_wa (brc_det_algo rqrm \\<delta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. while_algo (det_wa_wa (brc_det_algo rqrm \\<delta>))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. while_algo (det_wa_wa (brc_det_algo rqrm \\<delta>))", "from brc_pref_br'[OF RQRM INV]"], ["proof (chain)\npicking this:\n  wa_precise_refine (det_wa_wa (brc_det_algo rqrm \\<delta>))\n   (br'_algo (ls.\\<alpha> \\<delta>)) brc_\\<alpha>", "interpret \n    ref: wa_precise_refine \"(det_wa_wa (brc_det_algo rqrm \\<delta>))\" \n                           \"(br'_algo (ls_\\<alpha> \\<delta>))\" \n                           brc_\\<alpha>"], ["proof (prove)\nusing this:\n  wa_precise_refine (det_wa_wa (brc_det_algo rqrm \\<delta>))\n   (br'_algo (ls.\\<alpha> \\<delta>)) brc_\\<alpha>\n\ngoal (1 subgoal):\n 1. wa_precise_refine (det_wa_wa (brc_det_algo rqrm \\<delta>))\n     (br'_algo (ls.\\<alpha> \\<delta>)) brc_\\<alpha>", "."], ["proof (state)\ngoal (1 subgoal):\n 1. while_algo (det_wa_wa (brc_det_algo rqrm \\<delta>))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. while_algo (det_wa_wa (brc_det_algo rqrm \\<delta>))", "apply (rule ref.wa_intro)"], ["proof (prove)\ngoal (4 subgoals):\n 1. while_algo (br'_algo (ls.\\<alpha> \\<delta>))\n 2. wa_invar (det_wa_wa (brc_det_algo rqrm \\<delta>)) =\n    ?addi \\<inter>\n    {s. brc_\\<alpha> s \\<in> wa_invar (br'_algo (ls.\\<alpha> \\<delta>))}\n 3. \\<And>s s'.\n       \\<lbrakk>s \\<in> ?addi;\n        s \\<in> wa_cond (det_wa_wa (brc_det_algo rqrm \\<delta>));\n        brc_\\<alpha> s \\<in> wa_invar (br'_algo (ls.\\<alpha> \\<delta>));\n        (s, s')\n        \\<in> wa_step (det_wa_wa (brc_det_algo rqrm \\<delta>))\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> ?addi\n 4. wa_initial (det_wa_wa (brc_det_algo rqrm \\<delta>)) \\<subseteq> ?addi", "apply (simp add: br'_while_algo)"], ["proof (prove)\ngoal (3 subgoals):\n 1. wa_invar (det_wa_wa (brc_det_algo rqrm \\<delta>)) =\n    ?addi \\<inter>\n    {s. brc_\\<alpha> s \\<in> wa_invar (br'_algo (ls.\\<alpha> \\<delta>))}\n 2. \\<And>s s'.\n       \\<lbrakk>s \\<in> ?addi;\n        s \\<in> wa_cond (det_wa_wa (brc_det_algo rqrm \\<delta>));\n        brc_\\<alpha> s \\<in> wa_invar (br'_algo (ls.\\<alpha> \\<delta>));\n        (s, s')\n        \\<in> wa_step (det_wa_wa (brc_det_algo rqrm \\<delta>))\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> ?addi\n 3. wa_initial (det_wa_wa (brc_det_algo rqrm \\<delta>)) \\<subseteq> ?addi", "apply (simp_all add: det_wa_wa_def brc_det_algo_def br'_algo_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. brc_invar (ls.\\<alpha> \\<delta>) =\n    ?addi \\<inter>\n    {s. brc_\\<alpha> s \\<in> br'_invar (ls.\\<alpha> \\<delta>)}\n 2. \\<And>s s'.\n       \\<lbrakk>s \\<in> ?addi; brc_cond s;\n        brc_\\<alpha> s \\<in> br'_invar (ls.\\<alpha> \\<delta>);\n        \\<exists>a aa b.\n           s = (a, aa, b) \\<and> s' = brc_step rqrm (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> ?addi\n 3. brc_initial \\<delta> \\<in> ?addi", "apply (simp add: brc_invar_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>s \\<in> brc_invar_add; brc_cond s;\n        brc_\\<alpha> s \\<in> br'_invar (ls.\\<alpha> \\<delta>);\n        \\<exists>a aa b.\n           s = (a, aa, b) \\<and> s' = brc_step rqrm (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> brc_invar_add\n 2. brc_initial \\<delta> \\<in> brc_invar_add", "apply (auto simp add: brc_step_invar) [1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. brc_initial \\<delta> \\<in> brc_invar_add", "apply (simp add: brc_initial_invar)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  while_algo (det_wa_wa (brc_det_algo rqrm \\<delta>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas brc_det_while_algo =\n  det_while_algo_intro[OF brc_while_algo]"], ["", "lemma fst_brc_\\<alpha>: \"fst (brc_\\<alpha> s) = hs_\\<alpha> (fst s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (brc_\\<alpha> s) = hs.\\<alpha> (fst s)", "by (cases s) (simp add: brc_\\<alpha>_def)"], ["", "lemmas brc_invar_final =\n  wa_precise_refine.transfer_correctness[OF \n    brc_pref_br' br'_invar_final, unfolded fst_brc_\\<alpha>]"], ["", "definition \"hta_bwd_reduce H == \n  let rqrm = build_rqrm (hta_\\<delta> H) in \n    hta_reduce \n      H \n      (fst (while brc_cond (brc_step rqrm) (brc_initial (hta_\\<delta> H))))\n\""], ["", "theorem (in hashedTa) hta_bwd_reduce_correct:\n  shows \"hta_\\<alpha> (hta_bwd_reduce H) \n         = ta_reduce (hta_\\<alpha> H) (b_accessible (ls_\\<alpha> (hta_\\<delta> H)))\" (is ?T1)\n        \"hashedTa (hta_bwd_reduce H)\" (is ?T2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hta_\\<alpha> (hta_bwd_reduce H) =\n    ta_reduce (hta_\\<alpha> H) (b_accessible (ls.\\<alpha> \\<delta>)) &&&\n    hashedTa (hta_bwd_reduce H)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. hta_\\<alpha> (hta_bwd_reduce H) =\n    ta_reduce (hta_\\<alpha> H) (b_accessible (ls.\\<alpha> \\<delta>))\n 2. hashedTa (hta_bwd_reduce H)", "interpret det_while_algo \"(brc_det_algo (build_rqrm \\<delta>) \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det_while_algo (brc_det_algo (build_rqrm \\<delta>) \\<delta>)", "by (rule brc_det_while_algo)\n       (simp_all add: build_rqrm_correct)"], ["proof (state)\ngoal (2 subgoals):\n 1. hta_\\<alpha> (hta_bwd_reduce H) =\n    ta_reduce (hta_\\<alpha> H) (b_accessible (ls.\\<alpha> \\<delta>))\n 2. hashedTa (hta_bwd_reduce H)", "have LC: \"(while brc_cond (brc_step (build_rqrm \\<delta>)) (brc_initial \\<delta>)) = loop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. while brc_cond (brc_step (build_rqrm \\<delta>)) (brc_initial \\<delta>) =\n    loop", "by (unfold loop_def)\n       (simp add: brc_det_algo_def)"], ["proof (state)\nthis:\n  while brc_cond (brc_step (build_rqrm \\<delta>)) (brc_initial \\<delta>) =\n  loop\n\ngoal (2 subgoals):\n 1. hta_\\<alpha> (hta_bwd_reduce H) =\n    ta_reduce (hta_\\<alpha> H) (b_accessible (ls.\\<alpha> \\<delta>))\n 2. hashedTa (hta_bwd_reduce H)", "from while_proof'[OF brc_invar_final]"], ["proof (chain)\npicking this:\n  \\<lbrakk>rqrm_invar (build_rqrm \\<delta>);\n   rqrm_prop (ls.\\<alpha> \\<delta>) (build_rqrm \\<delta>);\n   ls.invar \\<delta>\\<rbrakk>\n  \\<Longrightarrow> hs.\\<alpha> (fst loop) =\n                    b_accessible (ls.\\<alpha> \\<delta>)", "have \n    G1: \"hs_\\<alpha> (fst loop) = b_accessible (ls_\\<alpha> \\<delta>)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>rqrm_invar (build_rqrm \\<delta>);\n   rqrm_prop (ls.\\<alpha> \\<delta>) (build_rqrm \\<delta>);\n   ls.invar \\<delta>\\<rbrakk>\n  \\<Longrightarrow> hs.\\<alpha> (fst loop) =\n                    b_accessible (ls.\\<alpha> \\<delta>)\n\ngoal (1 subgoal):\n 1. hs.\\<alpha> (fst loop) = b_accessible (ls.\\<alpha> \\<delta>)", "by (simp add: build_rqrm_correct)"], ["proof (state)\nthis:\n  hs.\\<alpha> (fst loop) = b_accessible (ls.\\<alpha> \\<delta>)\n\ngoal (2 subgoals):\n 1. hta_\\<alpha> (hta_bwd_reduce H) =\n    ta_reduce (hta_\\<alpha> H) (b_accessible (ls.\\<alpha> \\<delta>))\n 2. hashedTa (hta_bwd_reduce H)", "have G2: \"loop \\<in> brc_invar (ls_\\<alpha> \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. loop \\<in> brc_invar (ls.\\<alpha> \\<delta>)", "by (rule while_proof)\n       (simp add: brc_det_algo_def)"], ["proof (state)\nthis:\n  loop \\<in> brc_invar (ls.\\<alpha> \\<delta>)\n\ngoal (2 subgoals):\n 1. hta_\\<alpha> (hta_bwd_reduce H) =\n    ta_reduce (hta_\\<alpha> H) (b_accessible (ls.\\<alpha> \\<delta>))\n 2. hashedTa (hta_bwd_reduce H)", "hence [simp]: \"hs_invar (fst loop)\""], ["proof (prove)\nusing this:\n  loop \\<in> brc_invar (ls.\\<alpha> \\<delta>)\n\ngoal (1 subgoal):\n 1. hs.invar (fst loop)", "by (cases loop)\n       (simp add: brc_invar_def brc_invar_add_def)"], ["proof (state)\nthis:\n  hs.invar (fst loop)\n\ngoal (2 subgoals):\n 1. hta_\\<alpha> (hta_bwd_reduce H) =\n    ta_reduce (hta_\\<alpha> H) (b_accessible (ls.\\<alpha> \\<delta>))\n 2. hashedTa (hta_bwd_reduce H)", "show ?T1 ?T2"], ["proof (prove)\ngoal (1 subgoal):\n 1. hta_\\<alpha> (hta_bwd_reduce H) =\n    ta_reduce (hta_\\<alpha> H) (b_accessible (ls.\\<alpha> \\<delta>)) &&&\n    hashedTa (hta_bwd_reduce H)", "by (simp_all add: hta_bwd_reduce_def LC hta_reduce_correct G1)"], ["proof (state)\nthis:\n  hta_\\<alpha> (hta_bwd_reduce H) =\n  ta_reduce (hta_\\<alpha> H) (b_accessible (ls.\\<alpha> \\<delta>))\n  hashedTa (hta_bwd_reduce H)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Emptiness Check with Witness Computation\\<close>"], ["", "definition brec_construct_witness \n  :: \"('q::hashable,'l::hashable tree) hm \\<Rightarrow> ('q,'l) ta_rule \\<Rightarrow> 'l tree\"\n  where \"brec_construct_witness Qm r == \n  NODE (rhsl r) (List.map (\\<lambda>q. the (hm_lookup q Qm)) (rhsq r))\""], ["", "lemma brec_construct_witness_correct: \n  \"\\<lbrakk>hm_invar Qm\\<rbrakk> \\<Longrightarrow> \n    brec_construct_witness Qm r = construct_witness (hm_\\<alpha> Qm) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hm.invar Qm \\<Longrightarrow>\n    brec_construct_witness Qm r = construct_witness (hm.\\<alpha> Qm) r", "by (auto \n    simp add: construct_witness_def brec_construct_witness_def hm_correct)"], ["", "type_synonym ('Q,'L) brec_state \n  = \"(('Q,'L tree) hm \n      \\<times> 'Q fifo \n      \\<times> (('Q,'L) ta_rule, nat) hm \n      \\<times> 'Q option)\"\n\n\n  \\<comment> \\<open>Abstractions\\<close>"], ["", "definition brec_\\<alpha> \n  :: \"('Q::hashable,'L::hashable) brec_state \\<Rightarrow> ('Q,'L) brw_state\"\n  where \"brec_\\<alpha> == \\<lambda>(Q,W,rcm,f). (hm_\\<alpha> Q, set (fifo_\\<alpha> W), (hm_\\<alpha> rcm))\""], ["", "definition brec_inner_step \n  :: \"'q hs \\<Rightarrow> ('q,'l) ta_rule \n      \\<Rightarrow> ('q::hashable,'l::hashable) brec_state \n      \\<Rightarrow> ('q,'l) brec_state\"\n  where \"brec_inner_step Qi r == \\<lambda>(Q,W,rcm,qwit). \n    let c=the (hm_lookup r rcm); \n        cond = c \\<le> 1 \\<and> hm_lookup (lhs r) Q = None;\n        rcm' = hm_update r (c-(1::nat)) rcm;\n        Q' = ( if cond then \n                 hm_update (lhs r) (brec_construct_witness Q r) Q \n               else Q);\n        W' = (if cond then fifo_enqueue (lhs r) W else W);\n        qwit' = (if c \\<le> 1 \\<and> hs_memb (lhs r) Qi then Some (lhs r) else qwit)\n    in\n      (Q',W',rcm',qwit')\""], ["", "definition brec_step \n  :: \"('q,('q,'l) ta_rule ls) hm \\<Rightarrow> 'q hs \n      \\<Rightarrow> ('q::hashable,'l::hashable) brec_state \n      \\<Rightarrow> ('q,'l) brec_state\" \n  where \"brec_step rqrm Qi == \\<lambda>(Q,W,rcm,qwit).\n    let (q,W')=fifo_dequeue W in \n      ls_iteratei (rqrm_lookup rqrm q) (\\<lambda>_. True) \n        (brec_inner_step Qi) (Q,W',rcm,qwit)\n  \""], ["", "definition brec_iqm \n  :: \"('q::hashable,'l::hashable) ta_rule ls \\<Rightarrow> ('q,'l tree) hm\" \n  where \"brec_iqm \\<delta> == \n    ls_iteratei \\<delta> (\\<lambda>_. True) (\\<lambda>r m. if rhsq r = [] then \n                         hm_update (lhs r) (NODE (rhsl r) []) m \n                      else m) \n                (hm_empty ())\""], ["", "definition brec_initial \n  :: \"'q hs \\<Rightarrow> ('q::hashable,'l::hashable) ta_rule ls \n      \\<Rightarrow> ('q,'l) brec_state\" \n  where \"brec_initial Qi \\<delta> == \n  let iq=brc_iq \\<delta> in \n    ( brec_iqm \\<delta>, \n      hs_to_fifo.g_set_to_listr iq, \n      brc_rcm_init \\<delta>,\n      hh_set_xx.g_disjoint_witness iq Qi)\""], ["", "definition brec_cond \n  :: \"('q,'l) brec_state \\<Rightarrow> bool\" \n  where \"brec_cond == \\<lambda>(Q,W,rcm,qwit). \\<not> fifo_isEmpty W \\<and> qwit = None\""], ["", "definition brec_invar_add\n  :: \"'Q set \\<Rightarrow> ('Q::hashable,'L::hashable) brec_state set\" \n  where\n  \"brec_invar_add Qi == {(Q,W,rcm,qwit). \n    hm_invar Q \\<and> \n    distinct (fifo_\\<alpha> W) \\<and> \n    hm_invar rcm \\<and>\n    ( case qwit of \n        None \\<Rightarrow> Qi \\<inter> dom (hm_\\<alpha> Q) = {} | \n        Some q \\<Rightarrow> q\\<in>Qi \\<inter> dom (hm_\\<alpha> Q))}\n  \""], ["", "definition \"brec_invar Qi \\<delta> == brec_invar_add Qi \\<inter> {s. brec_\\<alpha> s \\<in> brw_invar \\<delta>}\""], ["", "definition \"brec_invar_inner Qi == \n  brec_invar_add Qi \\<inter> {(Q,W,_,_). set (fifo_\\<alpha> W) \\<subseteq> dom (hm_\\<alpha> Q)}\""], ["", "lemma brec_invar_cons: \n  \"\\<Sigma>\\<in>brec_invar Qi \\<delta> \\<Longrightarrow> \\<Sigma>\\<in>brec_invar_inner Qi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma> \\<in> brec_invar Qi \\<delta> \\<Longrightarrow>\n    \\<Sigma> \\<in> brec_invar_inner Qi", "apply (cases \\<Sigma>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>\\<Sigma> \\<in> brec_invar Qi \\<delta>;\n        \\<Sigma> = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> \\<Sigma> \\<in> brec_invar_inner Qi", "apply (simp add: brec_invar_def brw_invar_def br'_invar_def br_invar_def\n                   brec_\\<alpha>_def brw_\\<alpha>_def br'_\\<alpha>_def brec_invar_inner_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma brec_brw_invar_cons: \n  \"brec_\\<alpha> \\<Sigma> \\<in> brw_invar Qi \\<Longrightarrow> set (fifo_\\<alpha> (fst (snd \\<Sigma>))) \\<subseteq> dom (hm_\\<alpha> (fst \\<Sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. brec_\\<alpha> \\<Sigma> \\<in> brw_invar Qi \\<Longrightarrow>\n    set (fifo.\\<alpha> (fst (snd \\<Sigma>)))\n    \\<subseteq> dom (hm.\\<alpha> (fst \\<Sigma>))", "apply (cases \\<Sigma>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>brec_\\<alpha> \\<Sigma> \\<in> brw_invar Qi;\n        \\<Sigma> = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> set (fifo.\\<alpha> (fst (snd \\<Sigma>)))\n                         \\<subseteq> dom (hm.\\<alpha> (fst \\<Sigma>))", "apply (simp add: brec_invar_def brw_invar_def br'_invar_def br_invar_def\n                   brec_\\<alpha>_def brw_\\<alpha>_def br'_\\<alpha>_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"brec_det_algo rqrm Qi \\<delta> == \\<lparr>\n  dwa_cond=brec_cond,\n  dwa_step=brec_step rqrm Qi,\n  dwa_initial=brec_initial Qi \\<delta>,\n  dwa_invar=brec_invar (hs_\\<alpha> Qi) (ls_\\<alpha> \\<delta>)\n\\<rparr>\""], ["", "lemma brec_iqm_correct':\n  assumes INV[simp]: \"ls_invar \\<delta>\"\n  shows \n    \"dom (hm_\\<alpha> (brec_iqm \\<delta>)) = {lhs r | r. r\\<in>ls_\\<alpha> \\<delta> \\<and> rhsq r = []}\" (is ?T1)\n    \"witness_prop (ls_\\<alpha> \\<delta>) (hm_\\<alpha> (brec_iqm \\<delta>))\" (is ?T2)\n    \"hm_invar (brec_iqm \\<delta>)\" (is ?T3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (hm.\\<alpha> (brec_iqm \\<delta>)) =\n    {lhs r |r. r \\<in> ls.\\<alpha> \\<delta> \\<and> rhsq r = []} &&&\n    witness_prop (ls.\\<alpha> \\<delta>)\n     (hm.\\<alpha> (brec_iqm \\<delta>)) &&&\n    hm.invar (brec_iqm \\<delta>)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. dom (hm.\\<alpha> (brec_iqm \\<delta>)) =\n    {lhs r |r. r \\<in> ls.\\<alpha> \\<delta> \\<and> rhsq r = []}\n 2. witness_prop (ls.\\<alpha> \\<delta>) (hm.\\<alpha> (brec_iqm \\<delta>))\n 3. hm.invar (brec_iqm \\<delta>)", "have \"?T1 \\<and> ?T2 \\<and> ?T3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (hm.\\<alpha> (brec_iqm \\<delta>)) =\n    {lhs r |r. r \\<in> ls.\\<alpha> \\<delta> \\<and> rhsq r = []} \\<and>\n    witness_prop (ls.\\<alpha> \\<delta>)\n     (hm.\\<alpha> (brec_iqm \\<delta>)) \\<and>\n    hm.invar (brec_iqm \\<delta>)", "apply (unfold brec_iqm_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (hm.\\<alpha>\n          (ls.iterate \\<delta>\n            (\\<lambda>r m.\n                if rhsq r = [] then hm.update (lhs r) (NODE (rhsl r) []) m\n                else m)\n            (hm.empty ()))) =\n    {lhs r |r. r \\<in> ls.\\<alpha> \\<delta> \\<and> rhsq r = []} \\<and>\n    witness_prop (ls.\\<alpha> \\<delta>)\n     (hm.\\<alpha>\n       (ls.iterate \\<delta>\n         (\\<lambda>r m.\n             if rhsq r = [] then hm.update (lhs r) (NODE (rhsl r) []) m\n             else m)\n         (hm.empty ()))) \\<and>\n    hm.invar\n     (ls.iterate \\<delta>\n       (\\<lambda>r m.\n           if rhsq r = [] then hm.update (lhs r) (NODE (rhsl r) []) m\n           else m)\n       (hm.empty ()))", "apply (rule_tac \n      I=\"\\<lambda>it m. hm_invar m \n                \\<and> dom (hm_\\<alpha> m) = {lhs r | r. r\\<in>ls_\\<alpha> \\<delta> - it \\<and> rhsq r = []} \n                \\<and> witness_prop (ls_\\<alpha> \\<delta>) (hm_\\<alpha> m)\" \n      in ls.iterate_rule_P)"], ["proof (prove)\ngoal (4 subgoals):\n 1. ls.invar \\<delta>\n 2. hm.invar (hm.empty ()) \\<and>\n    dom (hm.\\<alpha> (hm.empty ())) =\n    {lhs r |r.\n     r \\<in> ls.\\<alpha> \\<delta> - ls.\\<alpha> \\<delta> \\<and>\n     rhsq r = []} \\<and>\n    witness_prop (ls.\\<alpha> \\<delta>) (hm.\\<alpha> (hm.empty ()))\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> \\<delta>;\n        hm.invar \\<sigma> \\<and>\n        dom (hm.\\<alpha> \\<sigma>) =\n        {lhs r |r.\n         r \\<in> ls.\\<alpha> \\<delta> - it \\<and> rhsq r = []} \\<and>\n        witness_prop (ls.\\<alpha> \\<delta>) (hm.\\<alpha> \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> hm.invar\n                          (if rhsq x = []\n                           then hm.update (lhs x) (NODE (rhsl x) [])\n                                 \\<sigma>\n                           else \\<sigma>) \\<and>\n                         dom (hm.\\<alpha>\n                               (if rhsq x = []\n                                then hm.update (lhs x) (NODE (rhsl x) [])\n\\<sigma>\n                                else \\<sigma>)) =\n                         {lhs r |r.\n                          r \\<in> ls.\\<alpha> \\<delta> - (it - {x}) \\<and>\n                          rhsq r = []} \\<and>\n                         witness_prop (ls.\\<alpha> \\<delta>)\n                          (hm.\\<alpha>\n                            (if rhsq x = []\n                             then hm.update (lhs x) (NODE (rhsl x) [])\n                                   \\<sigma>\n                             else \\<sigma>))\n 4. \\<And>\\<sigma>.\n       hm.invar \\<sigma> \\<and>\n       dom (hm.\\<alpha> \\<sigma>) =\n       {lhs r |r.\n        r \\<in> ls.\\<alpha> \\<delta> - {} \\<and> rhsq r = []} \\<and>\n       witness_prop (ls.\\<alpha> \\<delta>)\n        (hm.\\<alpha> \\<sigma>) \\<Longrightarrow>\n       dom (hm.\\<alpha> \\<sigma>) =\n       {lhs r |r. r \\<in> ls.\\<alpha> \\<delta> \\<and> rhsq r = []} \\<and>\n       witness_prop (ls.\\<alpha> \\<delta>) (hm.\\<alpha> \\<sigma>) \\<and>\n       hm.invar \\<sigma>", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. hm.invar (hm.empty ()) \\<and>\n    dom (hm.\\<alpha> (hm.empty ())) =\n    {lhs r |r.\n     r \\<in> ls.\\<alpha> \\<delta> - ls.\\<alpha> \\<delta> \\<and>\n     rhsq r = []} \\<and>\n    witness_prop (ls.\\<alpha> \\<delta>) (hm.\\<alpha> (hm.empty ()))\n 2. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> \\<delta>;\n        hm.invar \\<sigma> \\<and>\n        dom (hm.\\<alpha> \\<sigma>) =\n        {lhs r |r.\n         r \\<in> ls.\\<alpha> \\<delta> - it \\<and> rhsq r = []} \\<and>\n        witness_prop (ls.\\<alpha> \\<delta>) (hm.\\<alpha> \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> hm.invar\n                          (if rhsq x = []\n                           then hm.update (lhs x) (NODE (rhsl x) [])\n                                 \\<sigma>\n                           else \\<sigma>) \\<and>\n                         dom (hm.\\<alpha>\n                               (if rhsq x = []\n                                then hm.update (lhs x) (NODE (rhsl x) [])\n\\<sigma>\n                                else \\<sigma>)) =\n                         {lhs r |r.\n                          r \\<in> ls.\\<alpha> \\<delta> - (it - {x}) \\<and>\n                          rhsq r = []} \\<and>\n                         witness_prop (ls.\\<alpha> \\<delta>)\n                          (hm.\\<alpha>\n                            (if rhsq x = []\n                             then hm.update (lhs x) (NODE (rhsl x) [])\n                                   \\<sigma>\n                             else \\<sigma>))\n 3. \\<And>\\<sigma>.\n       hm.invar \\<sigma> \\<and>\n       dom (hm.\\<alpha> \\<sigma>) =\n       {lhs r |r.\n        r \\<in> ls.\\<alpha> \\<delta> - {} \\<and> rhsq r = []} \\<and>\n       witness_prop (ls.\\<alpha> \\<delta>)\n        (hm.\\<alpha> \\<sigma>) \\<Longrightarrow>\n       dom (hm.\\<alpha> \\<sigma>) =\n       {lhs r |r. r \\<in> ls.\\<alpha> \\<delta> \\<and> rhsq r = []} \\<and>\n       witness_prop (ls.\\<alpha> \\<delta>) (hm.\\<alpha> \\<sigma>) \\<and>\n       hm.invar \\<sigma>", "apply (auto simp add: hm_correct witness_prop_def) [1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> \\<delta>;\n        hm.invar \\<sigma> \\<and>\n        dom (hm.\\<alpha> \\<sigma>) =\n        {lhs r |r.\n         r \\<in> ls.\\<alpha> \\<delta> - it \\<and> rhsq r = []} \\<and>\n        witness_prop (ls.\\<alpha> \\<delta>) (hm.\\<alpha> \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> hm.invar\n                          (if rhsq x = []\n                           then hm.update (lhs x) (NODE (rhsl x) [])\n                                 \\<sigma>\n                           else \\<sigma>) \\<and>\n                         dom (hm.\\<alpha>\n                               (if rhsq x = []\n                                then hm.update (lhs x) (NODE (rhsl x) [])\n\\<sigma>\n                                else \\<sigma>)) =\n                         {lhs r |r.\n                          r \\<in> ls.\\<alpha> \\<delta> - (it - {x}) \\<and>\n                          rhsq r = []} \\<and>\n                         witness_prop (ls.\\<alpha> \\<delta>)\n                          (hm.\\<alpha>\n                            (if rhsq x = []\n                             then hm.update (lhs x) (NODE (rhsl x) [])\n                                   \\<sigma>\n                             else \\<sigma>))\n 2. \\<And>\\<sigma>.\n       hm.invar \\<sigma> \\<and>\n       dom (hm.\\<alpha> \\<sigma>) =\n       {lhs r |r.\n        r \\<in> ls.\\<alpha> \\<delta> - {} \\<and> rhsq r = []} \\<and>\n       witness_prop (ls.\\<alpha> \\<delta>)\n        (hm.\\<alpha> \\<sigma>) \\<Longrightarrow>\n       dom (hm.\\<alpha> \\<sigma>) =\n       {lhs r |r. r \\<in> ls.\\<alpha> \\<delta> \\<and> rhsq r = []} \\<and>\n       witness_prop (ls.\\<alpha> \\<delta>) (hm.\\<alpha> \\<sigma>) \\<and>\n       hm.invar \\<sigma>", "apply (auto simp add: hm_correct witness_prop_def) [1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> \\<delta>;\n        dom (hm.\\<alpha> \\<sigma>) =\n        {lhs r |r.\n         r \\<in> ls.\\<alpha> \\<delta> \\<and>\n         r \\<notin> it \\<and> rhsq r = []};\n        \\<forall>q t.\n           hm.\\<alpha> \\<sigma> q = Some t \\<longrightarrow>\n           accs (ls.\\<alpha> \\<delta>) t q;\n        rhsq x = []\\<rbrakk>\n       \\<Longrightarrow> accs (ls.\\<alpha> \\<delta>) (NODE (rhsl x) [])\n                          (lhs x)\n 2. \\<And>\\<sigma>.\n       hm.invar \\<sigma> \\<and>\n       dom (hm.\\<alpha> \\<sigma>) =\n       {lhs r |r.\n        r \\<in> ls.\\<alpha> \\<delta> - {} \\<and> rhsq r = []} \\<and>\n       witness_prop (ls.\\<alpha> \\<delta>)\n        (hm.\\<alpha> \\<sigma>) \\<Longrightarrow>\n       dom (hm.\\<alpha> \\<sigma>) =\n       {lhs r |r. r \\<in> ls.\\<alpha> \\<delta> \\<and> rhsq r = []} \\<and>\n       witness_prop (ls.\\<alpha> \\<delta>) (hm.\\<alpha> \\<sigma>) \\<and>\n       hm.invar \\<sigma>", "apply (case_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x it \\<sigma> x1 x2 x3.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> \\<delta>;\n        dom (hm.\\<alpha> \\<sigma>) =\n        {lhs r |r.\n         r \\<in> ls.\\<alpha> \\<delta> \\<and>\n         r \\<notin> it \\<and> rhsq r = []};\n        \\<forall>q t.\n           hm.\\<alpha> \\<sigma> q = Some t \\<longrightarrow>\n           accs (ls.\\<alpha> \\<delta>) t q;\n        rhsq x = []; x = x1 \\<rightarrow> x2 x3\\<rbrakk>\n       \\<Longrightarrow> accs (ls.\\<alpha> \\<delta>) (NODE (rhsl x) [])\n                          (lhs x)\n 2. \\<And>\\<sigma>.\n       hm.invar \\<sigma> \\<and>\n       dom (hm.\\<alpha> \\<sigma>) =\n       {lhs r |r.\n        r \\<in> ls.\\<alpha> \\<delta> - {} \\<and> rhsq r = []} \\<and>\n       witness_prop (ls.\\<alpha> \\<delta>)\n        (hm.\\<alpha> \\<sigma>) \\<Longrightarrow>\n       dom (hm.\\<alpha> \\<sigma>) =\n       {lhs r |r. r \\<in> ls.\\<alpha> \\<delta> \\<and> rhsq r = []} \\<and>\n       witness_prop (ls.\\<alpha> \\<delta>) (hm.\\<alpha> \\<sigma>) \\<and>\n       hm.invar \\<sigma>", "apply (auto intro: accs.intros) [1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       hm.invar \\<sigma> \\<and>\n       dom (hm.\\<alpha> \\<sigma>) =\n       {lhs r |r.\n        r \\<in> ls.\\<alpha> \\<delta> - {} \\<and> rhsq r = []} \\<and>\n       witness_prop (ls.\\<alpha> \\<delta>)\n        (hm.\\<alpha> \\<sigma>) \\<Longrightarrow>\n       dom (hm.\\<alpha> \\<sigma>) =\n       {lhs r |r. r \\<in> ls.\\<alpha> \\<delta> \\<and> rhsq r = []} \\<and>\n       witness_prop (ls.\\<alpha> \\<delta>) (hm.\\<alpha> \\<sigma>) \\<and>\n       hm.invar \\<sigma>", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  dom (hm.\\<alpha> (brec_iqm \\<delta>)) =\n  {lhs r |r. r \\<in> ls.\\<alpha> \\<delta> \\<and> rhsq r = []} \\<and>\n  witness_prop (ls.\\<alpha> \\<delta>)\n   (hm.\\<alpha> (brec_iqm \\<delta>)) \\<and>\n  hm.invar (brec_iqm \\<delta>)\n\ngoal (3 subgoals):\n 1. dom (hm.\\<alpha> (brec_iqm \\<delta>)) =\n    {lhs r |r. r \\<in> ls.\\<alpha> \\<delta> \\<and> rhsq r = []}\n 2. witness_prop (ls.\\<alpha> \\<delta>) (hm.\\<alpha> (brec_iqm \\<delta>))\n 3. hm.invar (brec_iqm \\<delta>)", "thus ?T1 ?T2 ?T3"], ["proof (prove)\nusing this:\n  dom (hm.\\<alpha> (brec_iqm \\<delta>)) =\n  {lhs r |r. r \\<in> ls.\\<alpha> \\<delta> \\<and> rhsq r = []} \\<and>\n  witness_prop (ls.\\<alpha> \\<delta>)\n   (hm.\\<alpha> (brec_iqm \\<delta>)) \\<and>\n  hm.invar (brec_iqm \\<delta>)\n\ngoal (1 subgoal):\n 1. dom (hm.\\<alpha> (brec_iqm \\<delta>)) =\n    {lhs r |r. r \\<in> ls.\\<alpha> \\<delta> \\<and> rhsq r = []} &&&\n    witness_prop (ls.\\<alpha> \\<delta>)\n     (hm.\\<alpha> (brec_iqm \\<delta>)) &&&\n    hm.invar (brec_iqm \\<delta>)", "by auto"], ["proof (state)\nthis:\n  dom (hm.\\<alpha> (brec_iqm \\<delta>)) =\n  {lhs r |r. r \\<in> ls.\\<alpha> \\<delta> \\<and> rhsq r = []}\n  witness_prop (ls.\\<alpha> \\<delta>) (hm.\\<alpha> (brec_iqm \\<delta>))\n  hm.invar (brec_iqm \\<delta>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma brec_iqm_correct:\n  assumes INV[simp]: \"ls_invar \\<delta>\"\n  shows \"hm_\\<alpha> (brec_iqm \\<delta>) \\<in> brw_iq (ls_\\<alpha> \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hm.\\<alpha> (brec_iqm \\<delta>) \\<in> brw_iq (ls.\\<alpha> \\<delta>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hm.\\<alpha> (brec_iqm \\<delta>) \\<in> brw_iq (ls.\\<alpha> \\<delta>)", "have \"(\\<forall>q t. hm_\\<alpha> (brec_iqm \\<delta>) q = Some t \n          \\<longrightarrow> (\\<exists>r\\<in>ls_\\<alpha> \\<delta>. rhsq r = [] \\<and> q = lhs r \\<and> t = NODE (rhsl r) [])) \n        \\<and> (\\<forall>r\\<in>ls_\\<alpha> \\<delta>. rhsq r = [] \\<longrightarrow> hm_\\<alpha> (brec_iqm \\<delta>) (lhs r) \\<noteq> None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>q t.\n        hm.\\<alpha> (brec_iqm \\<delta>) q = Some t \\<longrightarrow>\n        (\\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n            rhsq r = [] \\<and>\n            q = lhs r \\<and> t = NODE (rhsl r) [])) \\<and>\n    (\\<forall>r\\<in>ls.\\<alpha> \\<delta>.\n        rhsq r = [] \\<longrightarrow>\n        hm.\\<alpha> (brec_iqm \\<delta>) (lhs r) \\<noteq> None)", "apply (unfold brec_iqm_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>q t.\n        hm.\\<alpha>\n         (ls.iterate \\<delta>\n           (\\<lambda>r m.\n               if rhsq r = [] then hm.update (lhs r) (NODE (rhsl r) []) m\n               else m)\n           (hm.empty ()))\n         q =\n        Some t \\<longrightarrow>\n        (\\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n            rhsq r = [] \\<and>\n            q = lhs r \\<and> t = NODE (rhsl r) [])) \\<and>\n    (\\<forall>r\\<in>ls.\\<alpha> \\<delta>.\n        rhsq r = [] \\<longrightarrow>\n        hm.\\<alpha>\n         (ls.iterate \\<delta>\n           (\\<lambda>r m.\n               if rhsq r = [] then hm.update (lhs r) (NODE (rhsl r) []) m\n               else m)\n           (hm.empty ()))\n         (lhs r) \\<noteq>\n        None)", "apply (rule_tac I=\"\\<lambda>it m. (\n      (hm_invar m) \\<and> \n      (\\<forall>q t. hm_\\<alpha> m q = Some t \n        \\<longrightarrow> (\\<exists>r\\<in>ls_\\<alpha> \\<delta>. rhsq r = [] \\<and> q = lhs r \\<and> t = NODE (rhsl r) [])) \\<and> \n      (\\<forall>r\\<in>ls_\\<alpha> \\<delta>-it. rhsq r = [] \\<longrightarrow> hm_\\<alpha> m (lhs r) \\<noteq> None)\n      )\" \n      in ls.iterate_rule_P)"], ["proof (prove)\ngoal (4 subgoals):\n 1. ls.invar \\<delta>\n 2. hm.invar (hm.empty ()) \\<and>\n    (\\<forall>q t.\n        hm.\\<alpha> (hm.empty ()) q = Some t \\<longrightarrow>\n        (\\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n            rhsq r = [] \\<and>\n            q = lhs r \\<and> t = NODE (rhsl r) [])) \\<and>\n    (\\<forall>r\\<in>ls.\\<alpha> \\<delta> - ls.\\<alpha> \\<delta>.\n        rhsq r = [] \\<longrightarrow>\n        hm.\\<alpha> (hm.empty ()) (lhs r) \\<noteq> None)\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> \\<delta>;\n        hm.invar \\<sigma> \\<and>\n        (\\<forall>q t.\n            hm.\\<alpha> \\<sigma> q = Some t \\<longrightarrow>\n            (\\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n                rhsq r = [] \\<and>\n                q = lhs r \\<and> t = NODE (rhsl r) [])) \\<and>\n        (\\<forall>r\\<in>ls.\\<alpha> \\<delta> - it.\n            rhsq r = [] \\<longrightarrow>\n            hm.\\<alpha> \\<sigma> (lhs r) \\<noteq> None)\\<rbrakk>\n       \\<Longrightarrow> hm.invar\n                          (if rhsq x = []\n                           then hm.update (lhs x) (NODE (rhsl x) [])\n                                 \\<sigma>\n                           else \\<sigma>) \\<and>\n                         (\\<forall>q t.\n                             hm.\\<alpha>\n                              (if rhsq x = []\n                               then hm.update (lhs x) (NODE (rhsl x) [])\n                                     \\<sigma>\n                               else \\<sigma>)\n                              q =\n                             Some t \\<longrightarrow>\n                             (\\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n                                 rhsq r = [] \\<and>\n                                 q = lhs r \\<and>\n                                 t = NODE (rhsl r) [])) \\<and>\n                         (\\<forall>r\\<in>ls.\\<alpha> \\<delta> - (it - {x}).\n                             rhsq r = [] \\<longrightarrow>\n                             hm.\\<alpha>\n                              (if rhsq x = []\n                               then hm.update (lhs x) (NODE (rhsl x) [])\n                                     \\<sigma>\n                               else \\<sigma>)\n                              (lhs r) \\<noteq>\n                             None)\n 4. \\<And>\\<sigma>.\n       hm.invar \\<sigma> \\<and>\n       (\\<forall>q t.\n           hm.\\<alpha> \\<sigma> q = Some t \\<longrightarrow>\n           (\\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n               rhsq r = [] \\<and>\n               q = lhs r \\<and> t = NODE (rhsl r) [])) \\<and>\n       (\\<forall>r\\<in>ls.\\<alpha> \\<delta> - {}.\n           rhsq r = [] \\<longrightarrow>\n           hm.\\<alpha> \\<sigma> (lhs r) \\<noteq> None) \\<Longrightarrow>\n       (\\<forall>q t.\n           hm.\\<alpha> \\<sigma> q = Some t \\<longrightarrow>\n           (\\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n               rhsq r = [] \\<and>\n               q = lhs r \\<and> t = NODE (rhsl r) [])) \\<and>\n       (\\<forall>r\\<in>ls.\\<alpha> \\<delta>.\n           rhsq r = [] \\<longrightarrow>\n           hm.\\<alpha> \\<sigma> (lhs r) \\<noteq> None)", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. hm.invar (hm.empty ()) \\<and>\n    (\\<forall>q t.\n        hm.\\<alpha> (hm.empty ()) q = Some t \\<longrightarrow>\n        (\\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n            rhsq r = [] \\<and>\n            q = lhs r \\<and> t = NODE (rhsl r) [])) \\<and>\n    (\\<forall>r\\<in>ls.\\<alpha> \\<delta> - ls.\\<alpha> \\<delta>.\n        rhsq r = [] \\<longrightarrow>\n        hm.\\<alpha> (hm.empty ()) (lhs r) \\<noteq> None)\n 2. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> \\<delta>;\n        hm.invar \\<sigma> \\<and>\n        (\\<forall>q t.\n            hm.\\<alpha> \\<sigma> q = Some t \\<longrightarrow>\n            (\\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n                rhsq r = [] \\<and>\n                q = lhs r \\<and> t = NODE (rhsl r) [])) \\<and>\n        (\\<forall>r\\<in>ls.\\<alpha> \\<delta> - it.\n            rhsq r = [] \\<longrightarrow>\n            hm.\\<alpha> \\<sigma> (lhs r) \\<noteq> None)\\<rbrakk>\n       \\<Longrightarrow> hm.invar\n                          (if rhsq x = []\n                           then hm.update (lhs x) (NODE (rhsl x) [])\n                                 \\<sigma>\n                           else \\<sigma>) \\<and>\n                         (\\<forall>q t.\n                             hm.\\<alpha>\n                              (if rhsq x = []\n                               then hm.update (lhs x) (NODE (rhsl x) [])\n                                     \\<sigma>\n                               else \\<sigma>)\n                              q =\n                             Some t \\<longrightarrow>\n                             (\\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n                                 rhsq r = [] \\<and>\n                                 q = lhs r \\<and>\n                                 t = NODE (rhsl r) [])) \\<and>\n                         (\\<forall>r\\<in>ls.\\<alpha> \\<delta> - (it - {x}).\n                             rhsq r = [] \\<longrightarrow>\n                             hm.\\<alpha>\n                              (if rhsq x = []\n                               then hm.update (lhs x) (NODE (rhsl x) [])\n                                     \\<sigma>\n                               else \\<sigma>)\n                              (lhs r) \\<noteq>\n                             None)\n 3. \\<And>\\<sigma>.\n       hm.invar \\<sigma> \\<and>\n       (\\<forall>q t.\n           hm.\\<alpha> \\<sigma> q = Some t \\<longrightarrow>\n           (\\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n               rhsq r = [] \\<and>\n               q = lhs r \\<and> t = NODE (rhsl r) [])) \\<and>\n       (\\<forall>r\\<in>ls.\\<alpha> \\<delta> - {}.\n           rhsq r = [] \\<longrightarrow>\n           hm.\\<alpha> \\<sigma> (lhs r) \\<noteq> None) \\<Longrightarrow>\n       (\\<forall>q t.\n           hm.\\<alpha> \\<sigma> q = Some t \\<longrightarrow>\n           (\\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n               rhsq r = [] \\<and>\n               q = lhs r \\<and> t = NODE (rhsl r) [])) \\<and>\n       (\\<forall>r\\<in>ls.\\<alpha> \\<delta>.\n           rhsq r = [] \\<longrightarrow>\n           hm.\\<alpha> \\<sigma> (lhs r) \\<noteq> None)", "apply (simp add: hm_correct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ls.\\<alpha> \\<delta>;\n        hm.invar \\<sigma> \\<and>\n        (\\<forall>q t.\n            hm.\\<alpha> \\<sigma> q = Some t \\<longrightarrow>\n            (\\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n                rhsq r = [] \\<and>\n                q = lhs r \\<and> t = NODE (rhsl r) [])) \\<and>\n        (\\<forall>r\\<in>ls.\\<alpha> \\<delta> - it.\n            rhsq r = [] \\<longrightarrow>\n            hm.\\<alpha> \\<sigma> (lhs r) \\<noteq> None)\\<rbrakk>\n       \\<Longrightarrow> hm.invar\n                          (if rhsq x = []\n                           then hm.update (lhs x) (NODE (rhsl x) [])\n                                 \\<sigma>\n                           else \\<sigma>) \\<and>\n                         (\\<forall>q t.\n                             hm.\\<alpha>\n                              (if rhsq x = []\n                               then hm.update (lhs x) (NODE (rhsl x) [])\n                                     \\<sigma>\n                               else \\<sigma>)\n                              q =\n                             Some t \\<longrightarrow>\n                             (\\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n                                 rhsq r = [] \\<and>\n                                 q = lhs r \\<and>\n                                 t = NODE (rhsl r) [])) \\<and>\n                         (\\<forall>r\\<in>ls.\\<alpha> \\<delta> - (it - {x}).\n                             rhsq r = [] \\<longrightarrow>\n                             hm.\\<alpha>\n                              (if rhsq x = []\n                               then hm.update (lhs x) (NODE (rhsl x) [])\n                                     \\<sigma>\n                               else \\<sigma>)\n                              (lhs r) \\<noteq>\n                             None)\n 2. \\<And>\\<sigma>.\n       hm.invar \\<sigma> \\<and>\n       (\\<forall>q t.\n           hm.\\<alpha> \\<sigma> q = Some t \\<longrightarrow>\n           (\\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n               rhsq r = [] \\<and>\n               q = lhs r \\<and> t = NODE (rhsl r) [])) \\<and>\n       (\\<forall>r\\<in>ls.\\<alpha> \\<delta> - {}.\n           rhsq r = [] \\<longrightarrow>\n           hm.\\<alpha> \\<sigma> (lhs r) \\<noteq> None) \\<Longrightarrow>\n       (\\<forall>q t.\n           hm.\\<alpha> \\<sigma> q = Some t \\<longrightarrow>\n           (\\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n               rhsq r = [] \\<and>\n               q = lhs r \\<and> t = NODE (rhsl r) [])) \\<and>\n       (\\<forall>r\\<in>ls.\\<alpha> \\<delta>.\n           rhsq r = [] \\<longrightarrow>\n           hm.\\<alpha> \\<sigma> (lhs r) \\<noteq> None)", "apply (auto simp add: hm_correct) [1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       hm.invar \\<sigma> \\<and>\n       (\\<forall>q t.\n           hm.\\<alpha> \\<sigma> q = Some t \\<longrightarrow>\n           (\\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n               rhsq r = [] \\<and>\n               q = lhs r \\<and> t = NODE (rhsl r) [])) \\<and>\n       (\\<forall>r\\<in>ls.\\<alpha> \\<delta> - {}.\n           rhsq r = [] \\<longrightarrow>\n           hm.\\<alpha> \\<sigma> (lhs r) \\<noteq> None) \\<Longrightarrow>\n       (\\<forall>q t.\n           hm.\\<alpha> \\<sigma> q = Some t \\<longrightarrow>\n           (\\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n               rhsq r = [] \\<and>\n               q = lhs r \\<and> t = NODE (rhsl r) [])) \\<and>\n       (\\<forall>r\\<in>ls.\\<alpha> \\<delta>.\n           rhsq r = [] \\<longrightarrow>\n           hm.\\<alpha> \\<sigma> (lhs r) \\<noteq> None)", "apply (auto simp add: hm_correct) [1]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<forall>q t.\n      hm.\\<alpha> (brec_iqm \\<delta>) q = Some t \\<longrightarrow>\n      (\\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n          rhsq r = [] \\<and> q = lhs r \\<and> t = NODE (rhsl r) [])) \\<and>\n  (\\<forall>r\\<in>ls.\\<alpha> \\<delta>.\n      rhsq r = [] \\<longrightarrow>\n      hm.\\<alpha> (brec_iqm \\<delta>) (lhs r) \\<noteq> None)\n\ngoal (1 subgoal):\n 1. hm.\\<alpha> (brec_iqm \\<delta>) \\<in> brw_iq (ls.\\<alpha> \\<delta>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<forall>q t.\n      hm.\\<alpha> (brec_iqm \\<delta>) q = Some t \\<longrightarrow>\n      (\\<exists>r\\<in>ls.\\<alpha> \\<delta>.\n          rhsq r = [] \\<and> q = lhs r \\<and> t = NODE (rhsl r) [])) \\<and>\n  (\\<forall>r\\<in>ls.\\<alpha> \\<delta>.\n      rhsq r = [] \\<longrightarrow>\n      hm.\\<alpha> (brec_iqm \\<delta>) (lhs r) \\<noteq> None)\n\ngoal (1 subgoal):\n 1. hm.\\<alpha> (brec_iqm \\<delta>) \\<in> brw_iq (ls.\\<alpha> \\<delta>)", "by (blast intro: brw_iq.intros)"], ["proof (state)\nthis:\n  hm.\\<alpha> (brec_iqm \\<delta>) \\<in> brw_iq (ls.\\<alpha> \\<delta>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma brec_inner_step_brw_desc: \n  \"\\<lbrakk> \\<Sigma>\\<in>brec_invar_inner (hs_\\<alpha> Qi) \\<rbrakk> \n    \\<Longrightarrow> (brec_\\<alpha> \\<Sigma>, brec_\\<alpha> (brec_inner_step Qi r \\<Sigma>)) \\<in> brw_inner_step r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma> \\<in> brec_invar_inner (hs.\\<alpha> Qi) \\<Longrightarrow>\n    (brec_\\<alpha> \\<Sigma>, brec_\\<alpha> (brec_inner_step Qi r \\<Sigma>))\n    \\<in> brw_inner_step r", "apply (cases \\<Sigma>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>\\<Sigma> \\<in> brec_invar_inner (hs.\\<alpha> Qi);\n        \\<Sigma> = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> (brec_\\<alpha> \\<Sigma>,\n                          brec_\\<alpha> (brec_inner_step Qi r \\<Sigma>))\n                         \\<in> brw_inner_step r", "apply (rule brw_inner_step.intros)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a b c d.\n       \\<lbrakk>\\<Sigma> \\<in> brec_invar_inner (hs.\\<alpha> Qi);\n        \\<Sigma> = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> ?c1 a b c d = the (?rcm1 a b c d r)\n 2. \\<And>a b c d.\n       \\<lbrakk>\\<Sigma> \\<in> brec_invar_inner (hs.\\<alpha> Qi);\n        \\<Sigma> = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> brec_\\<alpha> \\<Sigma> =\n                         (?Q1 a b c d, ?W1 a b c d, ?rcm1 a b c d)\n 3. \\<And>a b c d.\n       \\<lbrakk>\\<Sigma> \\<in> brec_invar_inner (hs.\\<alpha> Qi);\n        \\<Sigma> = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> brec_\\<alpha> (brec_inner_step Qi r \\<Sigma>) =\n                         (?Q'1 a b c d, ?W'1 a b c d, ?rcm'1 a b c d)\n 4. \\<And>a b c d.\n       \\<lbrakk>\\<Sigma> \\<in> brec_invar_inner (hs.\\<alpha> Qi);\n        \\<Sigma> = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> if ?c1 a b c d \\<le> 1 \\<and>\n                            lhs r \\<notin> dom (?Q1 a b c d)\n                         then ?Q'1 a b c d = ?Q1 a b c d(lhs r \\<mapsto>\n                              construct_witness (?Q1 a b c d) r)\n                         else ?Q'1 a b c d = ?Q1 a b c d\n 5. \\<And>a b c d.\n       \\<lbrakk>\\<Sigma> \\<in> brec_invar_inner (hs.\\<alpha> Qi);\n        \\<Sigma> = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> if ?c1 a b c d \\<le> 1 \\<and>\n                            lhs r \\<notin> dom (?Q1 a b c d)\n                         then ?W'1 a b c d = insert (lhs r) (?W1 a b c d)\n                         else ?W'1 a b c d = ?W1 a b c d\n 6. \\<And>a b c d.\n       \\<lbrakk>\\<Sigma> \\<in> brec_invar_inner (hs.\\<alpha> Qi);\n        \\<Sigma> = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> ?rcm'1 a b c d = ?rcm1 a b c d(r \\<mapsto>\n                         ?c1 a b c d - 1)", "apply (simp only: )"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b c d.\n       \\<lbrakk>\\<Sigma> \\<in> brec_invar_inner (hs.\\<alpha> Qi);\n        \\<Sigma> = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> brec_\\<alpha> \\<Sigma> =\n                         (?Q1 a b c d, ?W1 a b c d, ?rcm1 a b c d)\n 2. \\<And>a b c d.\n       \\<lbrakk>\\<Sigma> \\<in> brec_invar_inner (hs.\\<alpha> Qi);\n        \\<Sigma> = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> brec_\\<alpha> (brec_inner_step Qi r \\<Sigma>) =\n                         (?Q'1 a b c d, ?W'1 a b c d, ?rcm'1 a b c d)\n 3. \\<And>a b c d.\n       \\<lbrakk>\\<Sigma> \\<in> brec_invar_inner (hs.\\<alpha> Qi);\n        \\<Sigma> = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> if the (?rcm1 a b c d r) \\<le> 1 \\<and>\n                            lhs r \\<notin> dom (?Q1 a b c d)\n                         then ?Q'1 a b c d = ?Q1 a b c d(lhs r \\<mapsto>\n                              construct_witness (?Q1 a b c d) r)\n                         else ?Q'1 a b c d = ?Q1 a b c d\n 4. \\<And>a b c d.\n       \\<lbrakk>\\<Sigma> \\<in> brec_invar_inner (hs.\\<alpha> Qi);\n        \\<Sigma> = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> if the (?rcm1 a b c d r) \\<le> 1 \\<and>\n                            lhs r \\<notin> dom (?Q1 a b c d)\n                         then ?W'1 a b c d = insert (lhs r) (?W1 a b c d)\n                         else ?W'1 a b c d = ?W1 a b c d\n 5. \\<And>a b c d.\n       \\<lbrakk>\\<Sigma> \\<in> brec_invar_inner (hs.\\<alpha> Qi);\n        \\<Sigma> = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> ?rcm'1 a b c d = ?rcm1 a b c d(r \\<mapsto>\n                         the (?rcm1 a b c d r) - 1)", "apply (simp only: brec_\\<alpha>_def split_conv)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b c d.\n       \\<lbrakk>\\<Sigma> \\<in> brec_invar_inner (hs.\\<alpha> Qi);\n        \\<Sigma> = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> brec_\\<alpha> (brec_inner_step Qi r \\<Sigma>) =\n                         (?Q'1 a b c d, ?W'1 a b c d, ?rcm'1 a b c d)\n 2. \\<And>a b c d.\n       \\<lbrakk>\\<Sigma> \\<in> brec_invar_inner (hs.\\<alpha> Qi);\n        \\<Sigma> = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> if the (hm.\\<alpha> c r) \\<le> 1 \\<and>\n                            lhs r \\<notin> dom (hm.\\<alpha> a)\n                         then ?Q'1 a b c d = hm.\\<alpha> a(lhs r \\<mapsto>\n                              construct_witness (hm.\\<alpha> a) r)\n                         else ?Q'1 a b c d = hm.\\<alpha> a\n 3. \\<And>a b c d.\n       \\<lbrakk>\\<Sigma> \\<in> brec_invar_inner (hs.\\<alpha> Qi);\n        \\<Sigma> = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> if the (hm.\\<alpha> c r) \\<le> 1 \\<and>\n                            lhs r \\<notin> dom (hm.\\<alpha> a)\n                         then ?W'1 a b c d =\n                              insert (lhs r) (set (fifo.\\<alpha> b))\n                         else ?W'1 a b c d = set (fifo.\\<alpha> b)\n 4. \\<And>a b c d.\n       \\<lbrakk>\\<Sigma> \\<in> brec_invar_inner (hs.\\<alpha> Qi);\n        \\<Sigma> = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> ?rcm'1 a b c d = hm.\\<alpha> c(r \\<mapsto>\n                         the (hm.\\<alpha> c r) - 1)", "apply (simp only: brec_inner_step_def brec_\\<alpha>_def Let_def split_conv)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b c d.\n       \\<lbrakk>\\<Sigma> \\<in> brec_invar_inner (hs.\\<alpha> Qi);\n        \\<Sigma> = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> if the (hm.\\<alpha> c r) \\<le> 1 \\<and>\n                            lhs r \\<notin> dom (hm.\\<alpha> a)\n                         then hm.\\<alpha>\n                               (if the (hm.lookup r c) \\<le> 1 \\<and>\n                                   hm.lookup (lhs r) a = None\n                                then hm.update (lhs r)\n(brec_construct_witness a r) a\n                                else a) =\n                              hm.\\<alpha> a(lhs r \\<mapsto>\n                              construct_witness (hm.\\<alpha> a) r)\n                         else hm.\\<alpha>\n                               (if the (hm.lookup r c) \\<le> 1 \\<and>\n                                   hm.lookup (lhs r) a = None\n                                then hm.update (lhs r)\n(brec_construct_witness a r) a\n                                else a) =\n                              hm.\\<alpha> a\n 2. \\<And>a b c d.\n       \\<lbrakk>\\<Sigma> \\<in> brec_invar_inner (hs.\\<alpha> Qi);\n        \\<Sigma> = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> if the (hm.\\<alpha> c r) \\<le> 1 \\<and>\n                            lhs r \\<notin> dom (hm.\\<alpha> a)\n                         then set (fifo.\\<alpha>\n                                    (if the (hm.lookup r c) \\<le> 1 \\<and>\n  hm.lookup (lhs r) a = None\n                                     then fifo.enqueue (lhs r) b else b)) =\n                              insert (lhs r) (set (fifo.\\<alpha> b))\n                         else set (fifo.\\<alpha>\n                                    (if the (hm.lookup r c) \\<le> 1 \\<and>\n  hm.lookup (lhs r) a = None\n                                     then fifo.enqueue (lhs r) b else b)) =\n                              set (fifo.\\<alpha> b)\n 3. \\<And>a b c d.\n       \\<lbrakk>\\<Sigma> \\<in> brec_invar_inner (hs.\\<alpha> Qi);\n        \\<Sigma> = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> hm.\\<alpha>\n                          (hm.update r (the (hm.lookup r c) - 1) c) =\n                         hm.\\<alpha> c(r \\<mapsto>\n                         the (hm.\\<alpha> c r) - 1)", "apply (auto \n    simp add: brec_invar_inner_def brec_invar_add_def brec_\\<alpha>_def \n              brec_inner_step_def \n              Let_def hs_correct hm_correct fifo_correct\n              brec_construct_witness_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma brec_step_invar:\n  assumes RQRM: \"rqrm_invar rqrm\" \"rqrm_prop \\<delta> rqrm\"\n  assumes [simp]: \"hs_invar Qi\"\n  shows \"\\<lbrakk> \\<Sigma>\\<in>brec_invar_add (hs_\\<alpha> Qi); brec_\\<alpha> \\<Sigma> \\<in> brw_invar \\<delta>;  brec_cond \\<Sigma> \\<rbrakk> \n          \\<Longrightarrow> (brec_step rqrm Qi \\<Sigma>)\\<in>brec_invar_add (hs_\\<alpha> Qi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Sigma> \\<in> brec_invar_add (hs.\\<alpha> Qi);\n     brec_\\<alpha> \\<Sigma> \\<in> brw_invar \\<delta>;\n     brec_cond \\<Sigma>\\<rbrakk>\n    \\<Longrightarrow> brec_step rqrm Qi \\<Sigma>\n                      \\<in> brec_invar_add (hs.\\<alpha> Qi)", "apply (frule brec_brw_invar_cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Sigma> \\<in> brec_invar_add (hs.\\<alpha> Qi);\n     brec_\\<alpha> \\<Sigma> \\<in> brw_invar \\<delta>; brec_cond \\<Sigma>;\n     set (fifo.\\<alpha> (fst (snd \\<Sigma>)))\n     \\<subseteq> dom (hm.\\<alpha> (fst \\<Sigma>))\\<rbrakk>\n    \\<Longrightarrow> brec_step rqrm Qi \\<Sigma>\n                      \\<in> brec_invar_add (hs.\\<alpha> Qi)", "apply (cases \\<Sigma>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>\\<Sigma> \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_\\<alpha> \\<Sigma> \\<in> brw_invar \\<delta>; brec_cond \\<Sigma>;\n        set (fifo.\\<alpha> (fst (snd \\<Sigma>)))\n        \\<subseteq> dom (hm.\\<alpha> (fst \\<Sigma>));\n        \\<Sigma> = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> brec_step rqrm Qi \\<Sigma>\n                         \\<in> brec_invar_add (hs.\\<alpha> Qi)", "apply (simp add: brec_step_def fifo_correct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>(a, b, c, d) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_\\<alpha> (a, b, c, d) \\<in> brw_invar \\<delta>;\n        brec_cond (a, b, c, d);\n        set (fifo.\\<alpha> b) \\<subseteq> dom (hm.\\<alpha> a);\n        \\<Sigma> = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> (case fifo.removel b of\n                          (q, W') \\<Rightarrow>\n                            ls.iterate (rqrm_lookup rqrm q)\n                             (brec_inner_step Qi) (a, W', c, d))\n                         \\<in> brec_invar_add (hs.\\<alpha> Qi)", "apply (case_tac \"fifo_\\<alpha> b\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c d.\n       \\<lbrakk>(a, b, c, d) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_\\<alpha> (a, b, c, d) \\<in> brw_invar \\<delta>;\n        brec_cond (a, b, c, d);\n        set (fifo.\\<alpha> b) \\<subseteq> dom (hm.\\<alpha> a);\n        \\<Sigma> = (a, b, c, d); fifo.\\<alpha> b = []\\<rbrakk>\n       \\<Longrightarrow> (case fifo.removel b of\n                          (q, W') \\<Rightarrow>\n                            ls.iterate (rqrm_lookup rqrm q)\n                             (brec_inner_step Qi) (a, W', c, d))\n                         \\<in> brec_invar_add (hs.\\<alpha> Qi)\n 2. \\<And>a b c d aa list.\n       \\<lbrakk>(a, b, c, d) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_\\<alpha> (a, b, c, d) \\<in> brw_invar \\<delta>;\n        brec_cond (a, b, c, d);\n        set (fifo.\\<alpha> b) \\<subseteq> dom (hm.\\<alpha> a);\n        \\<Sigma> = (a, b, c, d); fifo.\\<alpha> b = aa # list\\<rbrakk>\n       \\<Longrightarrow> (case fifo.removel b of\n                          (q, W') \\<Rightarrow>\n                            ls.iterate (rqrm_lookup rqrm q)\n                             (brec_inner_step Qi) (a, W', c, d))\n                         \\<in> brec_invar_add (hs.\\<alpha> Qi)", "apply (simp \n    add: brec_invar_def distinct_tl brec_cond_def fifo_correct\n         )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d aa list.\n       \\<lbrakk>(a, b, c, d) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_\\<alpha> (a, b, c, d) \\<in> brw_invar \\<delta>;\n        brec_cond (a, b, c, d);\n        set (fifo.\\<alpha> b) \\<subseteq> dom (hm.\\<alpha> a);\n        \\<Sigma> = (a, b, c, d); fifo.\\<alpha> b = aa # list\\<rbrakk>\n       \\<Longrightarrow> (case fifo.removel b of\n                          (q, W') \\<Rightarrow>\n                            ls.iterate (rqrm_lookup rqrm q)\n                             (brec_inner_step Qi) (a, W', c, d))\n                         \\<in> brec_invar_add (hs.\\<alpha> Qi)", "apply (rule_tac s=b in fifo.removelE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b c d aa list.\n       \\<lbrakk>(a, b, c, d) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_\\<alpha> (a, b, c, d) \\<in> brw_invar \\<delta>;\n        brec_cond (a, b, c, d);\n        set (fifo.\\<alpha> b) \\<subseteq> dom (hm.\\<alpha> a);\n        \\<Sigma> = (a, b, c, d); fifo.\\<alpha> b = aa # list\\<rbrakk>\n       \\<Longrightarrow> fifo.invar b\n 2. \\<And>a b c d aa list.\n       \\<lbrakk>(a, b, c, d) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_\\<alpha> (a, b, c, d) \\<in> brw_invar \\<delta>;\n        brec_cond (a, b, c, d);\n        set (fifo.\\<alpha> b) \\<subseteq> dom (hm.\\<alpha> a);\n        \\<Sigma> = (a, b, c, d); fifo.\\<alpha> b = aa # list\\<rbrakk>\n       \\<Longrightarrow> fifo.\\<alpha> b \\<noteq> []\n 3. \\<And>a b c d aa list s'.\n       \\<lbrakk>(a, b, c, d) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_\\<alpha> (a, b, c, d) \\<in> brw_invar \\<delta>;\n        brec_cond (a, b, c, d);\n        set (fifo.\\<alpha> b) \\<subseteq> dom (hm.\\<alpha> a);\n        \\<Sigma> = (a, b, c, d); fifo.\\<alpha> b = aa # list;\n        fifo.removel b = (hd (fifo.\\<alpha> b), s'); fifo.invar s';\n        fifo.\\<alpha> s' = tl (fifo.\\<alpha> b)\\<rbrakk>\n       \\<Longrightarrow> (case fifo.removel b of\n                          (q, W') \\<Rightarrow>\n                            ls.iterate (rqrm_lookup rqrm q)\n                             (brec_inner_step Qi) (a, W', c, d))\n                         \\<in> brec_invar_add (hs.\\<alpha> Qi)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c d aa list.\n       \\<lbrakk>(a, b, c, d) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_\\<alpha> (a, b, c, d) \\<in> brw_invar \\<delta>;\n        brec_cond (a, b, c, d);\n        set (fifo.\\<alpha> b) \\<subseteq> dom (hm.\\<alpha> a);\n        \\<Sigma> = (a, b, c, d); fifo.\\<alpha> b = aa # list\\<rbrakk>\n       \\<Longrightarrow> fifo.\\<alpha> b \\<noteq> []\n 2. \\<And>a b c d aa list s'.\n       \\<lbrakk>(a, b, c, d) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_\\<alpha> (a, b, c, d) \\<in> brw_invar \\<delta>;\n        brec_cond (a, b, c, d);\n        set (fifo.\\<alpha> b) \\<subseteq> dom (hm.\\<alpha> a);\n        \\<Sigma> = (a, b, c, d); fifo.\\<alpha> b = aa # list;\n        fifo.removel b = (hd (fifo.\\<alpha> b), s'); fifo.invar s';\n        fifo.\\<alpha> s' = tl (fifo.\\<alpha> b)\\<rbrakk>\n       \\<Longrightarrow> (case fifo.removel b of\n                          (q, W') \\<Rightarrow>\n                            ls.iterate (rqrm_lookup rqrm q)\n                             (brec_inner_step Qi) (a, W', c, d))\n                         \\<in> brec_invar_add (hs.\\<alpha> Qi)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d aa list s'.\n       \\<lbrakk>(a, b, c, d) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_\\<alpha> (a, b, c, d) \\<in> brw_invar \\<delta>;\n        brec_cond (a, b, c, d);\n        set (fifo.\\<alpha> b) \\<subseteq> dom (hm.\\<alpha> a);\n        \\<Sigma> = (a, b, c, d); fifo.\\<alpha> b = aa # list;\n        fifo.removel b = (hd (fifo.\\<alpha> b), s'); fifo.invar s';\n        fifo.\\<alpha> s' = tl (fifo.\\<alpha> b)\\<rbrakk>\n       \\<Longrightarrow> (case fifo.removel b of\n                          (q, W') \\<Rightarrow>\n                            ls.iterate (rqrm_lookup rqrm q)\n                             (brec_inner_step Qi) (a, W', c, d))\n                         \\<in> brec_invar_add (hs.\\<alpha> Qi)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d aa list s'.\n       \\<lbrakk>(a, b, c, d) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_\\<alpha> (a, b, c, d) \\<in> brw_invar \\<delta>;\n        brec_cond (a, b, c, d);\n        aa \\<in> dom (hm.\\<alpha> a) \\<and>\n        set list \\<subseteq> dom (hm.\\<alpha> a);\n        \\<Sigma> = (a, b, c, d); fifo.\\<alpha> b = aa # list;\n        fifo.removel b = (aa, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> ls.iterate (rqrm_lookup rqrm aa)\n                          (brec_inner_step Qi) (a, s', c, d)\n                         \\<in> brec_invar_add (hs.\\<alpha> Qi)", "apply (rule_tac \n    I=\"\\<lambda>it (Q,W,rcm,qwit). (Q,W,rcm,qwit)\\<in>brec_invar_add (hs_\\<alpha> Qi) \n                           \\<and> set (fifo_\\<alpha> W) \\<subseteq> dom (hm_\\<alpha> Q)\" \n    in ls.iterate_rule_P)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b c d aa list s'.\n       \\<lbrakk>(a, b, c, d) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_\\<alpha> (a, b, c, d) \\<in> brw_invar \\<delta>;\n        brec_cond (a, b, c, d);\n        aa \\<in> dom (hm.\\<alpha> a) \\<and>\n        set list \\<subseteq> dom (hm.\\<alpha> a);\n        \\<Sigma> = (a, b, c, d); fifo.\\<alpha> b = aa # list;\n        fifo.removel b = (aa, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> ls.invar (rqrm_lookup rqrm aa)\n 2. \\<And>a b c d aa list s'.\n       \\<lbrakk>(a, b, c, d) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_\\<alpha> (a, b, c, d) \\<in> brw_invar \\<delta>;\n        brec_cond (a, b, c, d);\n        aa \\<in> dom (hm.\\<alpha> a) \\<and>\n        set list \\<subseteq> dom (hm.\\<alpha> a);\n        \\<Sigma> = (a, b, c, d); fifo.\\<alpha> b = aa # list;\n        fifo.removel b = (aa, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> case (a, s', c, d) of\n                         (Q, W, rcm, qwit) \\<Rightarrow>\n                           (Q, W, rcm, qwit)\n                           \\<in> brec_invar_add (hs.\\<alpha> Qi) \\<and>\n                           set (fifo.\\<alpha> W)\n                           \\<subseteq> dom (hm.\\<alpha> Q)\n 3. \\<And>a b c d aa list s' x it \\<sigma>.\n       \\<lbrakk>(a, b, c, d) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_\\<alpha> (a, b, c, d) \\<in> brw_invar \\<delta>;\n        brec_cond (a, b, c, d);\n        aa \\<in> dom (hm.\\<alpha> a) \\<and>\n        set list \\<subseteq> dom (hm.\\<alpha> a);\n        \\<Sigma> = (a, b, c, d); fifo.\\<alpha> b = aa # list;\n        fifo.removel b = (aa, s'); fifo.\\<alpha> s' = list; x \\<in> it;\n        it \\<subseteq> ls.\\<alpha> (rqrm_lookup rqrm aa);\n        case \\<sigma> of\n        (Q, W, rcm, qwit) \\<Rightarrow>\n          (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi) \\<and>\n          set (fifo.\\<alpha> W) \\<subseteq> dom (hm.\\<alpha> Q)\\<rbrakk>\n       \\<Longrightarrow> case brec_inner_step Qi x \\<sigma> of\n                         (Q, W, rcm, qwit) \\<Rightarrow>\n                           (Q, W, rcm, qwit)\n                           \\<in> brec_invar_add (hs.\\<alpha> Qi) \\<and>\n                           set (fifo.\\<alpha> W)\n                           \\<subseteq> dom (hm.\\<alpha> Q)\n 4. \\<And>a b c d aa list s' \\<sigma>.\n       \\<lbrakk>(a, b, c, d) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_\\<alpha> (a, b, c, d) \\<in> brw_invar \\<delta>;\n        brec_cond (a, b, c, d);\n        aa \\<in> dom (hm.\\<alpha> a) \\<and>\n        set list \\<subseteq> dom (hm.\\<alpha> a);\n        \\<Sigma> = (a, b, c, d); fifo.\\<alpha> b = aa # list;\n        fifo.removel b = (aa, s'); fifo.\\<alpha> s' = list;\n        case \\<sigma> of\n        (Q, W, rcm, qwit) \\<Rightarrow>\n          (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi) \\<and>\n          set (fifo.\\<alpha> W) \\<subseteq> dom (hm.\\<alpha> Q)\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<in> brec_invar_add (hs.\\<alpha> Qi)", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b c d aa list s'.\n       \\<lbrakk>(a, b, c, d) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_\\<alpha> (a, b, c, d) \\<in> brw_invar \\<delta>;\n        brec_cond (a, b, c, d);\n        aa \\<in> dom (hm.\\<alpha> a) \\<and>\n        set list \\<subseteq> dom (hm.\\<alpha> a);\n        \\<Sigma> = (a, b, c, d); fifo.\\<alpha> b = aa # list;\n        fifo.removel b = (aa, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> case (a, s', c, d) of\n                         (Q, W, rcm, qwit) \\<Rightarrow>\n                           (Q, W, rcm, qwit)\n                           \\<in> brec_invar_add (hs.\\<alpha> Qi) \\<and>\n                           set (fifo.\\<alpha> W)\n                           \\<subseteq> dom (hm.\\<alpha> Q)\n 2. \\<And>a b c d aa list s' x it \\<sigma>.\n       \\<lbrakk>(a, b, c, d) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_\\<alpha> (a, b, c, d) \\<in> brw_invar \\<delta>;\n        brec_cond (a, b, c, d);\n        aa \\<in> dom (hm.\\<alpha> a) \\<and>\n        set list \\<subseteq> dom (hm.\\<alpha> a);\n        \\<Sigma> = (a, b, c, d); fifo.\\<alpha> b = aa # list;\n        fifo.removel b = (aa, s'); fifo.\\<alpha> s' = list; x \\<in> it;\n        it \\<subseteq> ls.\\<alpha> (rqrm_lookup rqrm aa);\n        case \\<sigma> of\n        (Q, W, rcm, qwit) \\<Rightarrow>\n          (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi) \\<and>\n          set (fifo.\\<alpha> W) \\<subseteq> dom (hm.\\<alpha> Q)\\<rbrakk>\n       \\<Longrightarrow> case brec_inner_step Qi x \\<sigma> of\n                         (Q, W, rcm, qwit) \\<Rightarrow>\n                           (Q, W, rcm, qwit)\n                           \\<in> brec_invar_add (hs.\\<alpha> Qi) \\<and>\n                           set (fifo.\\<alpha> W)\n                           \\<subseteq> dom (hm.\\<alpha> Q)\n 3. \\<And>a b c d aa list s' \\<sigma>.\n       \\<lbrakk>(a, b, c, d) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_\\<alpha> (a, b, c, d) \\<in> brw_invar \\<delta>;\n        brec_cond (a, b, c, d);\n        aa \\<in> dom (hm.\\<alpha> a) \\<and>\n        set list \\<subseteq> dom (hm.\\<alpha> a);\n        \\<Sigma> = (a, b, c, d); fifo.\\<alpha> b = aa # list;\n        fifo.removel b = (aa, s'); fifo.\\<alpha> s' = list;\n        case \\<sigma> of\n        (Q, W, rcm, qwit) \\<Rightarrow>\n          (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi) \\<and>\n          set (fifo.\\<alpha> W) \\<subseteq> dom (hm.\\<alpha> Q)\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<in> brec_invar_add (hs.\\<alpha> Qi)", "apply (simp \n    add: brec_invar_def distinct_tl brec_cond_def fifo_correct\n         )"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b c d aa list s'.\n       \\<lbrakk>(a, b, c, None) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_\\<alpha> (a, b, c, None) \\<in> brw_invar \\<delta>; d = None;\n        aa \\<in> dom (hm.\\<alpha> a) \\<and>\n        set list \\<subseteq> dom (hm.\\<alpha> a);\n        \\<Sigma> = (a, b, c, None); fifo.\\<alpha> b = aa # list;\n        fifo.removel b = (aa, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> (a, s', c, None)\n                         \\<in> brec_invar_add (hs.\\<alpha> Qi)\n 2. \\<And>a b c d aa list s' x it \\<sigma>.\n       \\<lbrakk>(a, b, c, d) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_\\<alpha> (a, b, c, d) \\<in> brw_invar \\<delta>;\n        brec_cond (a, b, c, d);\n        aa \\<in> dom (hm.\\<alpha> a) \\<and>\n        set list \\<subseteq> dom (hm.\\<alpha> a);\n        \\<Sigma> = (a, b, c, d); fifo.\\<alpha> b = aa # list;\n        fifo.removel b = (aa, s'); fifo.\\<alpha> s' = list; x \\<in> it;\n        it \\<subseteq> ls.\\<alpha> (rqrm_lookup rqrm aa);\n        case \\<sigma> of\n        (Q, W, rcm, qwit) \\<Rightarrow>\n          (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi) \\<and>\n          set (fifo.\\<alpha> W) \\<subseteq> dom (hm.\\<alpha> Q)\\<rbrakk>\n       \\<Longrightarrow> case brec_inner_step Qi x \\<sigma> of\n                         (Q, W, rcm, qwit) \\<Rightarrow>\n                           (Q, W, rcm, qwit)\n                           \\<in> brec_invar_add (hs.\\<alpha> Qi) \\<and>\n                           set (fifo.\\<alpha> W)\n                           \\<subseteq> dom (hm.\\<alpha> Q)\n 3. \\<And>a b c d aa list s' \\<sigma>.\n       \\<lbrakk>(a, b, c, d) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_\\<alpha> (a, b, c, d) \\<in> brw_invar \\<delta>;\n        brec_cond (a, b, c, d);\n        aa \\<in> dom (hm.\\<alpha> a) \\<and>\n        set list \\<subseteq> dom (hm.\\<alpha> a);\n        \\<Sigma> = (a, b, c, d); fifo.\\<alpha> b = aa # list;\n        fifo.removel b = (aa, s'); fifo.\\<alpha> s' = list;\n        case \\<sigma> of\n        (Q, W, rcm, qwit) \\<Rightarrow>\n          (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi) \\<and>\n          set (fifo.\\<alpha> W) \\<subseteq> dom (hm.\\<alpha> Q)\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<in> brec_invar_add (hs.\\<alpha> Qi)", "apply (simp \n    add: brec_invar_def brec_invar_add_def distinct_tl brec_cond_def \n         fifo_correct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c d aa list s' x it \\<sigma>.\n       \\<lbrakk>(a, b, c, d) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_\\<alpha> (a, b, c, d) \\<in> brw_invar \\<delta>;\n        brec_cond (a, b, c, d);\n        aa \\<in> dom (hm.\\<alpha> a) \\<and>\n        set list \\<subseteq> dom (hm.\\<alpha> a);\n        \\<Sigma> = (a, b, c, d); fifo.\\<alpha> b = aa # list;\n        fifo.removel b = (aa, s'); fifo.\\<alpha> s' = list; x \\<in> it;\n        it \\<subseteq> ls.\\<alpha> (rqrm_lookup rqrm aa);\n        case \\<sigma> of\n        (Q, W, rcm, qwit) \\<Rightarrow>\n          (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi) \\<and>\n          set (fifo.\\<alpha> W) \\<subseteq> dom (hm.\\<alpha> Q)\\<rbrakk>\n       \\<Longrightarrow> case brec_inner_step Qi x \\<sigma> of\n                         (Q, W, rcm, qwit) \\<Rightarrow>\n                           (Q, W, rcm, qwit)\n                           \\<in> brec_invar_add (hs.\\<alpha> Qi) \\<and>\n                           set (fifo.\\<alpha> W)\n                           \\<subseteq> dom (hm.\\<alpha> Q)\n 2. \\<And>a b c d aa list s' \\<sigma>.\n       \\<lbrakk>(a, b, c, d) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_\\<alpha> (a, b, c, d) \\<in> brw_invar \\<delta>;\n        brec_cond (a, b, c, d);\n        aa \\<in> dom (hm.\\<alpha> a) \\<and>\n        set list \\<subseteq> dom (hm.\\<alpha> a);\n        \\<Sigma> = (a, b, c, d); fifo.\\<alpha> b = aa # list;\n        fifo.removel b = (aa, s'); fifo.\\<alpha> s' = list;\n        case \\<sigma> of\n        (Q, W, rcm, qwit) \\<Rightarrow>\n          (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi) \\<and>\n          set (fifo.\\<alpha> W) \\<subseteq> dom (hm.\\<alpha> Q)\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<in> brec_invar_add (hs.\\<alpha> Qi)", "apply (case_tac \\<sigma>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c d aa list s' x it \\<sigma> ab ba ca da.\n       \\<lbrakk>(a, b, c, d) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_\\<alpha> (a, b, c, d) \\<in> brw_invar \\<delta>;\n        brec_cond (a, b, c, d);\n        aa \\<in> dom (hm.\\<alpha> a) \\<and>\n        set list \\<subseteq> dom (hm.\\<alpha> a);\n        \\<Sigma> = (a, b, c, d); fifo.\\<alpha> b = aa # list;\n        fifo.removel b = (aa, s'); fifo.\\<alpha> s' = list; x \\<in> it;\n        it \\<subseteq> ls.\\<alpha> (rqrm_lookup rqrm aa);\n        case \\<sigma> of\n        (Q, W, rcm, qwit) \\<Rightarrow>\n          (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi) \\<and>\n          set (fifo.\\<alpha> W) \\<subseteq> dom (hm.\\<alpha> Q);\n        \\<sigma> = (ab, ba, ca, da)\\<rbrakk>\n       \\<Longrightarrow> case brec_inner_step Qi x \\<sigma> of\n                         (Q, W, rcm, qwit) \\<Rightarrow>\n                           (Q, W, rcm, qwit)\n                           \\<in> brec_invar_add (hs.\\<alpha> Qi) \\<and>\n                           set (fifo.\\<alpha> W)\n                           \\<subseteq> dom (hm.\\<alpha> Q)\n 2. \\<And>a b c d aa list s' \\<sigma>.\n       \\<lbrakk>(a, b, c, d) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_\\<alpha> (a, b, c, d) \\<in> brw_invar \\<delta>;\n        brec_cond (a, b, c, d);\n        aa \\<in> dom (hm.\\<alpha> a) \\<and>\n        set list \\<subseteq> dom (hm.\\<alpha> a);\n        \\<Sigma> = (a, b, c, d); fifo.\\<alpha> b = aa # list;\n        fifo.removel b = (aa, s'); fifo.\\<alpha> s' = list;\n        case \\<sigma> of\n        (Q, W, rcm, qwit) \\<Rightarrow>\n          (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi) \\<and>\n          set (fifo.\\<alpha> W) \\<subseteq> dom (hm.\\<alpha> Q)\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<in> brec_invar_add (hs.\\<alpha> Qi)", "apply (auto \n    simp add: brec_invar_add_def brec_inner_step_def Let_def hs_correct \n              hm_correct fifo_correct split: option.split_asm) [1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d aa list s' \\<sigma>.\n       \\<lbrakk>(a, b, c, d) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_\\<alpha> (a, b, c, d) \\<in> brw_invar \\<delta>;\n        brec_cond (a, b, c, d);\n        aa \\<in> dom (hm.\\<alpha> a) \\<and>\n        set list \\<subseteq> dom (hm.\\<alpha> a);\n        \\<Sigma> = (a, b, c, d); fifo.\\<alpha> b = aa # list;\n        fifo.removel b = (aa, s'); fifo.\\<alpha> s' = list;\n        case \\<sigma> of\n        (Q, W, rcm, qwit) \\<Rightarrow>\n          (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi) \\<and>\n          set (fifo.\\<alpha> W) \\<subseteq> dom (hm.\\<alpha> Q)\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<in> brec_invar_add (hs.\\<alpha> Qi)", "apply (case_tac \\<sigma>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d aa list s' \\<sigma> ab ba ca da.\n       \\<lbrakk>(a, b, c, d) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_\\<alpha> (a, b, c, d) \\<in> brw_invar \\<delta>;\n        brec_cond (a, b, c, d);\n        aa \\<in> dom (hm.\\<alpha> a) \\<and>\n        set list \\<subseteq> dom (hm.\\<alpha> a);\n        \\<Sigma> = (a, b, c, d); fifo.\\<alpha> b = aa # list;\n        fifo.removel b = (aa, s'); fifo.\\<alpha> s' = list;\n        case \\<sigma> of\n        (Q, W, rcm, qwit) \\<Rightarrow>\n          (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi) \\<and>\n          set (fifo.\\<alpha> W) \\<subseteq> dom (hm.\\<alpha> Q);\n        \\<sigma> = (ab, ba, ca, da)\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<in> brec_invar_add (hs.\\<alpha> Qi)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma brec_step_abs:\n  assumes RQRM: \"rqrm_invar rqrm\" \"rqrm_prop \\<delta> rqrm\"\n  assumes INV[simp]: \"hs_invar Qi\"\n  assumes A': \"\\<Sigma>\\<in>brec_invar (hs_\\<alpha> Qi) \\<delta>\"\n  assumes COND: \"brec_cond \\<Sigma>\"\n  shows \"(brec_\\<alpha> \\<Sigma>, brec_\\<alpha> (brec_step rqrm Qi \\<Sigma>)) \\<in> brw_step \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (brec_\\<alpha> \\<Sigma>, brec_\\<alpha> (brec_step rqrm Qi \\<Sigma>))\n    \\<in> brw_step \\<delta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (brec_\\<alpha> \\<Sigma>, brec_\\<alpha> (brec_step rqrm Qi \\<Sigma>))\n    \\<in> brw_step \\<delta>", "from A'"], ["proof (chain)\npicking this:\n  \\<Sigma> \\<in> brec_invar (hs.\\<alpha> Qi) \\<delta>", "have A: \"(brec_\\<alpha> \\<Sigma>)\\<in>brw_invar \\<delta>\" \"\\<Sigma>\\<in>brec_invar_add (hs_\\<alpha> Qi)\""], ["proof (prove)\nusing this:\n  \\<Sigma> \\<in> brec_invar (hs.\\<alpha> Qi) \\<delta>\n\ngoal (1 subgoal):\n 1. brec_\\<alpha> \\<Sigma> \\<in> brw_invar \\<delta> &&&\n    \\<Sigma> \\<in> brec_invar_add (hs.\\<alpha> Qi)", "by (simp_all add: brec_invar_def)"], ["proof (state)\nthis:\n  brec_\\<alpha> \\<Sigma> \\<in> brw_invar \\<delta>\n  \\<Sigma> \\<in> brec_invar_add (hs.\\<alpha> Qi)\n\ngoal (1 subgoal):\n 1. (brec_\\<alpha> \\<Sigma>, brec_\\<alpha> (brec_step rqrm Qi \\<Sigma>))\n    \\<in> brw_step \\<delta>", "obtain Q W rcm qwit where [simp]: \"\\<Sigma>=(Q,W,rcm,qwit)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Q W rcm qwit.\n        \\<Sigma> = (Q, W, rcm, qwit) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \\<Sigma>) blast"], ["proof (state)\nthis:\n  \\<Sigma> = (Q, W, rcm, qwit)\n\ngoal (1 subgoal):\n 1. (brec_\\<alpha> \\<Sigma>, brec_\\<alpha> (brec_step rqrm Qi \\<Sigma>))\n    \\<in> brw_step \\<delta>", "from A COND"], ["proof (chain)\npicking this:\n  brec_\\<alpha> \\<Sigma> \\<in> brw_invar \\<delta>\n  \\<Sigma> \\<in> brec_invar_add (hs.\\<alpha> Qi)\n  brec_cond \\<Sigma>", "show ?thesis"], ["proof (prove)\nusing this:\n  brec_\\<alpha> \\<Sigma> \\<in> brw_invar \\<delta>\n  \\<Sigma> \\<in> brec_invar_add (hs.\\<alpha> Qi)\n  brec_cond \\<Sigma>\n\ngoal (1 subgoal):\n 1. (brec_\\<alpha> \\<Sigma>, brec_\\<alpha> (brec_step rqrm Qi \\<Sigma>))\n    \\<in> brw_step \\<delta>", "apply (simp add: brec_step_def fifo_correct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n     (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n     brec_cond (Q, W, rcm, qwit)\\<rbrakk>\n    \\<Longrightarrow> (brec_\\<alpha> (Q, W, rcm, qwit),\n                       brec_\\<alpha>\n                        (case fifo.removel W of\n                         (q, W') \\<Rightarrow>\n                           ls.iterate (rqrm_lookup rqrm q)\n                            (brec_inner_step Qi) (Q, W', rcm, qwit)))\n                      \\<in> brw_step \\<delta>", "apply (case_tac \"fifo_\\<alpha> W\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n     (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n     brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = []\\<rbrakk>\n    \\<Longrightarrow> (brec_\\<alpha> (Q, W, rcm, qwit),\n                       brec_\\<alpha>\n                        (case fifo.removel W of\n                         (q, W') \\<Rightarrow>\n                           ls.iterate (rqrm_lookup rqrm q)\n                            (brec_inner_step Qi) (Q, W', rcm, qwit)))\n                      \\<in> brw_step \\<delta>\n 2. \\<And>a list.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list\\<rbrakk>\n       \\<Longrightarrow> (brec_\\<alpha> (Q, W, rcm, qwit),\n                          brec_\\<alpha>\n                           (case fifo.removel W of\n                            (q, W') \\<Rightarrow>\n                              ls.iterate (rqrm_lookup rqrm q)\n                               (brec_inner_step Qi) (Q, W', rcm, qwit)))\n                         \\<in> brw_step \\<delta>", "apply (simp \n      add: brec_invar_def distinct_tl brec_cond_def fifo_correct\n    )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list\\<rbrakk>\n       \\<Longrightarrow> (brec_\\<alpha> (Q, W, rcm, qwit),\n                          brec_\\<alpha>\n                           (case fifo.removel W of\n                            (q, W') \\<Rightarrow>\n                              ls.iterate (rqrm_lookup rqrm q)\n                               (brec_inner_step Qi) (Q, W', rcm, qwit)))\n                         \\<in> brw_step \\<delta>", "apply (rule_tac s=W in fifo.removelE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a list.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list\\<rbrakk>\n       \\<Longrightarrow> fifo.invar W\n 2. \\<And>a list.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list\\<rbrakk>\n       \\<Longrightarrow> fifo.\\<alpha> W \\<noteq> []\n 3. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (hd (fifo.\\<alpha> W), s'); fifo.invar s';\n        fifo.\\<alpha> s' = tl (fifo.\\<alpha> W)\\<rbrakk>\n       \\<Longrightarrow> (brec_\\<alpha> (Q, W, rcm, qwit),\n                          brec_\\<alpha>\n                           (case fifo.removel W of\n                            (q, W') \\<Rightarrow>\n                              ls.iterate (rqrm_lookup rqrm q)\n                               (brec_inner_step Qi) (Q, W', rcm, qwit)))\n                         \\<in> brw_step \\<delta>", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list\\<rbrakk>\n       \\<Longrightarrow> fifo.\\<alpha> W \\<noteq> []\n 2. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (hd (fifo.\\<alpha> W), s'); fifo.invar s';\n        fifo.\\<alpha> s' = tl (fifo.\\<alpha> W)\\<rbrakk>\n       \\<Longrightarrow> (brec_\\<alpha> (Q, W, rcm, qwit),\n                          brec_\\<alpha>\n                           (case fifo.removel W of\n                            (q, W') \\<Rightarrow>\n                              ls.iterate (rqrm_lookup rqrm q)\n                               (brec_inner_step Qi) (Q, W', rcm, qwit)))\n                         \\<in> brw_step \\<delta>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (hd (fifo.\\<alpha> W), s'); fifo.invar s';\n        fifo.\\<alpha> s' = tl (fifo.\\<alpha> W)\\<rbrakk>\n       \\<Longrightarrow> (brec_\\<alpha> (Q, W, rcm, qwit),\n                          brec_\\<alpha>\n                           (case fifo.removel W of\n                            (q, W') \\<Rightarrow>\n                              ls.iterate (rqrm_lookup rqrm q)\n                               (brec_inner_step Qi) (Q, W', rcm, qwit)))\n                         \\<in> brw_step \\<delta>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> (brec_\\<alpha> (Q, W, rcm, qwit),\n                          brec_\\<alpha>\n                           (ls.iterate (rqrm_lookup rqrm a)\n                             (brec_inner_step Qi) (Q, s', rcm, qwit)))\n                         \\<in> brw_step \\<delta>", "apply (rule brw_inner_step_proof[\n      OF ls.v1_iteratei_impl, \n      where cinvar=\"\\<lambda>it \\<Sigma>. \\<Sigma>\\<in>brec_invar_inner (hs_\\<alpha> Qi)\" and \n            q=\"hd (fifo_\\<alpha> W)\"])"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> brec_\\<alpha> (Q, W, rcm, qwit)\n                         \\<in> brw_invar \\<delta>\n 2. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> (Q, s', rcm, qwit)\n                         \\<in> brec_invar_inner (hs.\\<alpha> Qi)\n 3. \\<And>a list s' it r \\<Sigma>.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list; r \\<in> it;\n        it \\<subseteq> {r \\<in> \\<delta>.\n                        hd (fifo.\\<alpha> W) \\<in> set (rhsq r)};\n        \\<Sigma> \\<in> brec_invar_inner (hs.\\<alpha> Qi)\\<rbrakk>\n       \\<Longrightarrow> brec_inner_step Qi r \\<Sigma>\n                         \\<in> brec_invar_inner (hs.\\<alpha> Qi)\n 4. \\<And>a list s' it r \\<Sigma>.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list; r \\<in> it;\n        it \\<subseteq> {r \\<in> \\<delta>.\n                        hd (fifo.\\<alpha> W) \\<in> set (rhsq r)};\n        \\<Sigma> \\<in> brec_invar_inner (hs.\\<alpha> Qi)\\<rbrakk>\n       \\<Longrightarrow> (brec_\\<alpha> \\<Sigma>,\n                          brec_\\<alpha> (brec_inner_step Qi r \\<Sigma>))\n                         \\<in> brw_inner_step r\n 5. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> ls.invar (rqrm_lookup rqrm a)\n 6. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> ls.\\<alpha> (rqrm_lookup rqrm a) =\n                         {r \\<in> \\<delta>.\n                          hd (fifo.\\<alpha> W) \\<in> set (rhsq r)}\n 7. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> hd (fifo.\\<alpha> W) \\<in> ?W5 a list s'\n 8. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> brec_\\<alpha> (Q, W, rcm, qwit) =\n                         (?Q5 a list s', ?W5 a list s', ?rcm5 a list s')\n 9. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> brec_\\<alpha> (Q, s', rcm, qwit) =\n                         (?Q5 a list s',\n                          ?W5 a list s' - {hd (fifo.\\<alpha> W)},\n                          ?rcm5 a list s')", "apply assumption"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> (Q, s', rcm, qwit)\n                         \\<in> brec_invar_inner (hs.\\<alpha> Qi)\n 2. \\<And>a list s' it r \\<Sigma>.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list; r \\<in> it;\n        it \\<subseteq> {r \\<in> \\<delta>.\n                        hd (fifo.\\<alpha> W) \\<in> set (rhsq r)};\n        \\<Sigma> \\<in> brec_invar_inner (hs.\\<alpha> Qi)\\<rbrakk>\n       \\<Longrightarrow> brec_inner_step Qi r \\<Sigma>\n                         \\<in> brec_invar_inner (hs.\\<alpha> Qi)\n 3. \\<And>a list s' it r \\<Sigma>.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list; r \\<in> it;\n        it \\<subseteq> {r \\<in> \\<delta>.\n                        hd (fifo.\\<alpha> W) \\<in> set (rhsq r)};\n        \\<Sigma> \\<in> brec_invar_inner (hs.\\<alpha> Qi)\\<rbrakk>\n       \\<Longrightarrow> (brec_\\<alpha> \\<Sigma>,\n                          brec_\\<alpha> (brec_inner_step Qi r \\<Sigma>))\n                         \\<in> brw_inner_step r\n 4. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> ls.invar (rqrm_lookup rqrm a)\n 5. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> ls.\\<alpha> (rqrm_lookup rqrm a) =\n                         {r \\<in> \\<delta>.\n                          hd (fifo.\\<alpha> W) \\<in> set (rhsq r)}\n 6. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> hd (fifo.\\<alpha> W) \\<in> ?W5 a list s'\n 7. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> brec_\\<alpha> (Q, W, rcm, qwit) =\n                         (?Q5 a list s', ?W5 a list s', ?rcm5 a list s')\n 8. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> brec_\\<alpha> (Q, s', rcm, qwit) =\n                         (?Q5 a list s',\n                          ?W5 a list s' - {hd (fifo.\\<alpha> W)},\n                          ?rcm5 a list s')", "apply (frule brec_brw_invar_cons)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list;\n        set (fifo.\\<alpha> (fst (snd (Q, W, rcm, qwit))))\n        \\<subseteq> dom (hm.\\<alpha> (fst (Q, W, rcm, qwit)))\\<rbrakk>\n       \\<Longrightarrow> (Q, s', rcm, qwit)\n                         \\<in> brec_invar_inner (hs.\\<alpha> Qi)\n 2. \\<And>a list s' it r \\<Sigma>.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list; r \\<in> it;\n        it \\<subseteq> {r \\<in> \\<delta>.\n                        hd (fifo.\\<alpha> W) \\<in> set (rhsq r)};\n        \\<Sigma> \\<in> brec_invar_inner (hs.\\<alpha> Qi)\\<rbrakk>\n       \\<Longrightarrow> brec_inner_step Qi r \\<Sigma>\n                         \\<in> brec_invar_inner (hs.\\<alpha> Qi)\n 3. \\<And>a list s' it r \\<Sigma>.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list; r \\<in> it;\n        it \\<subseteq> {r \\<in> \\<delta>.\n                        hd (fifo.\\<alpha> W) \\<in> set (rhsq r)};\n        \\<Sigma> \\<in> brec_invar_inner (hs.\\<alpha> Qi)\\<rbrakk>\n       \\<Longrightarrow> (brec_\\<alpha> \\<Sigma>,\n                          brec_\\<alpha> (brec_inner_step Qi r \\<Sigma>))\n                         \\<in> brw_inner_step r\n 4. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> ls.invar (rqrm_lookup rqrm a)\n 5. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> ls.\\<alpha> (rqrm_lookup rqrm a) =\n                         {r \\<in> \\<delta>.\n                          hd (fifo.\\<alpha> W) \\<in> set (rhsq r)}\n 6. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> hd (fifo.\\<alpha> W) \\<in> ?W5 a list s'\n 7. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> brec_\\<alpha> (Q, W, rcm, qwit) =\n                         (?Q5 a list s', ?W5 a list s', ?rcm5 a list s')\n 8. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> brec_\\<alpha> (Q, s', rcm, qwit) =\n                         (?Q5 a list s',\n                          ?W5 a list s' - {hd (fifo.\\<alpha> W)},\n                          ?rcm5 a list s')", "apply (simp_all \n      add: brec_cond_def brec_invar_add_def fifo_correct\n            brec_invar_inner_def) [1]"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a list s' it r \\<Sigma>.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list; r \\<in> it;\n        it \\<subseteq> {r \\<in> \\<delta>.\n                        hd (fifo.\\<alpha> W) \\<in> set (rhsq r)};\n        \\<Sigma> \\<in> brec_invar_inner (hs.\\<alpha> Qi)\\<rbrakk>\n       \\<Longrightarrow> brec_inner_step Qi r \\<Sigma>\n                         \\<in> brec_invar_inner (hs.\\<alpha> Qi)\n 2. \\<And>a list s' it r \\<Sigma>.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list; r \\<in> it;\n        it \\<subseteq> {r \\<in> \\<delta>.\n                        hd (fifo.\\<alpha> W) \\<in> set (rhsq r)};\n        \\<Sigma> \\<in> brec_invar_inner (hs.\\<alpha> Qi)\\<rbrakk>\n       \\<Longrightarrow> (brec_\\<alpha> \\<Sigma>,\n                          brec_\\<alpha> (brec_inner_step Qi r \\<Sigma>))\n                         \\<in> brw_inner_step r\n 3. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> ls.invar (rqrm_lookup rqrm a)\n 4. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> ls.\\<alpha> (rqrm_lookup rqrm a) =\n                         {r \\<in> \\<delta>.\n                          hd (fifo.\\<alpha> W) \\<in> set (rhsq r)}\n 5. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> hd (fifo.\\<alpha> W) \\<in> ?W5 a list s'\n 6. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> brec_\\<alpha> (Q, W, rcm, qwit) =\n                         (?Q5 a list s', ?W5 a list s', ?rcm5 a list s')\n 7. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> brec_\\<alpha> (Q, s', rcm, qwit) =\n                         (?Q5 a list s',\n                          ?W5 a list s' - {hd (fifo.\\<alpha> W)},\n                          ?rcm5 a list s')", "prefer 6"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> brec_\\<alpha> (Q, W, rcm, qwit) =\n                         (?Q5 a list s', ?W5 a list s', ?rcm5 a list s')\n 2. \\<And>a list s' it r \\<Sigma>.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list; r \\<in> it;\n        it \\<subseteq> {r \\<in> \\<delta>.\n                        hd (fifo.\\<alpha> W) \\<in> set (rhsq r)};\n        \\<Sigma> \\<in> brec_invar_inner (hs.\\<alpha> Qi)\\<rbrakk>\n       \\<Longrightarrow> brec_inner_step Qi r \\<Sigma>\n                         \\<in> brec_invar_inner (hs.\\<alpha> Qi)\n 3. \\<And>a list s' it r \\<Sigma>.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list; r \\<in> it;\n        it \\<subseteq> {r \\<in> \\<delta>.\n                        hd (fifo.\\<alpha> W) \\<in> set (rhsq r)};\n        \\<Sigma> \\<in> brec_invar_inner (hs.\\<alpha> Qi)\\<rbrakk>\n       \\<Longrightarrow> (brec_\\<alpha> \\<Sigma>,\n                          brec_\\<alpha> (brec_inner_step Qi r \\<Sigma>))\n                         \\<in> brw_inner_step r\n 4. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> ls.invar (rqrm_lookup rqrm a)\n 5. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> ls.\\<alpha> (rqrm_lookup rqrm a) =\n                         {r \\<in> \\<delta>.\n                          hd (fifo.\\<alpha> W) \\<in> set (rhsq r)}\n 6. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> hd (fifo.\\<alpha> W) \\<in> ?W5 a list s'\n 7. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> brec_\\<alpha> (Q, s', rcm, qwit) =\n                         (?Q5 a list s',\n                          ?W5 a list s' - {hd (fifo.\\<alpha> W)},\n                          ?rcm5 a list s')", "apply (simp add: brec_\\<alpha>_def)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a list s' it r \\<Sigma>.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list; r \\<in> it;\n        it \\<subseteq> {r \\<in> \\<delta>.\n                        hd (fifo.\\<alpha> W) \\<in> set (rhsq r)};\n        \\<Sigma> \\<in> brec_invar_inner (hs.\\<alpha> Qi)\\<rbrakk>\n       \\<Longrightarrow> brec_inner_step Qi r \\<Sigma>\n                         \\<in> brec_invar_inner (hs.\\<alpha> Qi)\n 2. \\<And>a list s' it r \\<Sigma>.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list; r \\<in> it;\n        it \\<subseteq> {r \\<in> \\<delta>.\n                        hd (fifo.\\<alpha> W) \\<in> set (rhsq r)};\n        \\<Sigma> \\<in> brec_invar_inner (hs.\\<alpha> Qi)\\<rbrakk>\n       \\<Longrightarrow> (brec_\\<alpha> \\<Sigma>,\n                          brec_\\<alpha> (brec_inner_step Qi r \\<Sigma>))\n                         \\<in> brw_inner_step r\n 3. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> ls.invar (rqrm_lookup rqrm a)\n 4. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> ls.\\<alpha> (rqrm_lookup rqrm a) =\n                         {r \\<in> \\<delta>.\n                          hd (fifo.\\<alpha> W) \\<in> set (rhsq r)}\n 5. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> hd (fifo.\\<alpha> W) \\<in> insert a (set list)\n 6. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> brec_\\<alpha> (Q, s', rcm, qwit) =\n                         (hm.\\<alpha> Q,\n                          insert a (set list) - {hd (fifo.\\<alpha> W)},\n                          hm.\\<alpha> rcm)", "apply (case_tac \\<Sigma>)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a list s' it r \\<Sigma> aa b c d.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list; r \\<in> it;\n        it \\<subseteq> {r \\<in> \\<delta>.\n                        hd (fifo.\\<alpha> W) \\<in> set (rhsq r)};\n        \\<Sigma> \\<in> brec_invar_inner (hs.\\<alpha> Qi);\n        \\<Sigma> = (aa, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> brec_inner_step Qi r \\<Sigma>\n                         \\<in> brec_invar_inner (hs.\\<alpha> Qi)\n 2. \\<And>a list s' it r \\<Sigma>.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list; r \\<in> it;\n        it \\<subseteq> {r \\<in> \\<delta>.\n                        hd (fifo.\\<alpha> W) \\<in> set (rhsq r)};\n        \\<Sigma> \\<in> brec_invar_inner (hs.\\<alpha> Qi)\\<rbrakk>\n       \\<Longrightarrow> (brec_\\<alpha> \\<Sigma>,\n                          brec_\\<alpha> (brec_inner_step Qi r \\<Sigma>))\n                         \\<in> brw_inner_step r\n 3. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> ls.invar (rqrm_lookup rqrm a)\n 4. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> ls.\\<alpha> (rqrm_lookup rqrm a) =\n                         {r \\<in> \\<delta>.\n                          hd (fifo.\\<alpha> W) \\<in> set (rhsq r)}\n 5. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> hd (fifo.\\<alpha> W) \\<in> insert a (set list)\n 6. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> brec_\\<alpha> (Q, s', rcm, qwit) =\n                         (hm.\\<alpha> Q,\n                          insert a (set list) - {hd (fifo.\\<alpha> W)},\n                          hm.\\<alpha> rcm)", "apply (auto \n      simp add: brec_invar_add_def brec_inner_step_def Let_def hm_correct \n                hs_correct fifo_correct brec_invar_inner_def \n      split: option.split_asm) [1]"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a list s' it r \\<Sigma>.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list; r \\<in> it;\n        it \\<subseteq> {r \\<in> \\<delta>.\n                        hd (fifo.\\<alpha> W) \\<in> set (rhsq r)};\n        \\<Sigma> \\<in> brec_invar_inner (hs.\\<alpha> Qi)\\<rbrakk>\n       \\<Longrightarrow> (brec_\\<alpha> \\<Sigma>,\n                          brec_\\<alpha> (brec_inner_step Qi r \\<Sigma>))\n                         \\<in> brw_inner_step r\n 2. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> ls.invar (rqrm_lookup rqrm a)\n 3. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> ls.\\<alpha> (rqrm_lookup rqrm a) =\n                         {r \\<in> \\<delta>.\n                          hd (fifo.\\<alpha> W) \\<in> set (rhsq r)}\n 4. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> hd (fifo.\\<alpha> W) \\<in> insert a (set list)\n 5. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> brec_\\<alpha> (Q, s', rcm, qwit) =\n                         (hm.\\<alpha> Q,\n                          insert a (set list) - {hd (fifo.\\<alpha> W)},\n                          hm.\\<alpha> rcm)", "apply (blast intro: brec_inner_step_brw_desc)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> ls.invar (rqrm_lookup rqrm a)\n 2. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> ls.\\<alpha> (rqrm_lookup rqrm a) =\n                         {r \\<in> \\<delta>.\n                          hd (fifo.\\<alpha> W) \\<in> set (rhsq r)}\n 3. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> hd (fifo.\\<alpha> W) \\<in> insert a (set list)\n 4. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> brec_\\<alpha> (Q, s', rcm, qwit) =\n                         (hm.\\<alpha> Q,\n                          insert a (set list) - {hd (fifo.\\<alpha> W)},\n                          hm.\\<alpha> rcm)", "apply (simp add: RQRM[unfolded rqrm_invar_def])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> ls.\\<alpha> (rqrm_lookup rqrm a) =\n                         {r \\<in> \\<delta>.\n                          hd (fifo.\\<alpha> W) \\<in> set (rhsq r)}\n 2. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> hd (fifo.\\<alpha> W) \\<in> insert a (set list)\n 3. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> brec_\\<alpha> (Q, s', rcm, qwit) =\n                         (hm.\\<alpha> Q,\n                          insert a (set list) - {hd (fifo.\\<alpha> W)},\n                          hm.\\<alpha> rcm)", "apply (simp \n      add: rqrm_propD[OF RQRM(2)] fifo_correct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> hd (fifo.\\<alpha> W) \\<in> insert a (set list)\n 2. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> brec_\\<alpha> (Q, s', rcm, qwit) =\n                         (hm.\\<alpha> Q,\n                          insert a (set list) - {hd (fifo.\\<alpha> W)},\n                          hm.\\<alpha> rcm)", "apply (simp_all \n      add: brec_\\<alpha>_def brec_cond_def brec_invar_def fifo_correct) [1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list s'.\n       \\<lbrakk>brec_\\<alpha> (Q, W, rcm, qwit) \\<in> brw_invar \\<delta>;\n        (Q, W, rcm, qwit) \\<in> brec_invar_add (hs.\\<alpha> Qi);\n        brec_cond (Q, W, rcm, qwit); fifo.\\<alpha> W = a # list;\n        fifo.removel W = (a, s'); fifo.\\<alpha> s' = list\\<rbrakk>\n       \\<Longrightarrow> brec_\\<alpha> (Q, s', rcm, qwit) =\n                         (hm.\\<alpha> Q,\n                          insert a (set list) - {hd (fifo.\\<alpha> W)},\n                          hm.\\<alpha> rcm)", "apply (simp_all \n      add: brec_\\<alpha>_def brec_cond_def brec_invar_add_def fifo_correct) [1]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (brec_\\<alpha> \\<Sigma>, brec_\\<alpha> (brec_step rqrm Qi \\<Sigma>))\n  \\<in> brw_step \\<delta>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma brec_invar_initial: \n  \"\\<lbrakk>ls_invar \\<delta>; hs_invar Qi\\<rbrakk> \\<Longrightarrow> (brec_initial Qi \\<delta>) \\<in> brec_invar_add (hs_\\<alpha> Qi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ls.invar \\<delta>; hs.invar Qi\\<rbrakk>\n    \\<Longrightarrow> brec_initial Qi \\<delta>\n                      \\<in> brec_invar_add (hs.\\<alpha> Qi)", "apply (auto \n    simp add: brec_invar_add_def brec_initial_def brc_iq_correct \n              brec_iqm_correct' hs_correct hs.isEmpty_correct Let_def \n              brc_rcm_init_correct br_iq_def \n              hh_set_xx.disjoint_witness_correct \n              hs_to_fifo.g_set_to_listr_correct \n    split: option.split)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>hh_set_xx.g_disjoint_witness (brc_iq \\<delta>) Qi = None;\n        lhs r \\<in> hs.\\<alpha> Qi; r \\<in> ls.\\<alpha> \\<delta>;\n        rhsq r = []\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x2.\n       hh_set_xx.g_disjoint_witness (brc_iq \\<delta>) Qi =\n       Some x2 \\<Longrightarrow>\n       x2 \\<in> hs.\\<alpha> Qi\n 3. \\<And>x2.\n       hh_set_xx.g_disjoint_witness (brc_iq \\<delta>) Qi =\n       Some x2 \\<Longrightarrow>\n       \\<exists>r.\n          x2 = lhs r \\<and> r \\<in> ls.\\<alpha> \\<delta> \\<and> rhsq r = []", "apply (auto simp add: brc_iq_correct \n    hh_set_xx.disjoint_witness_None br_iq_def) [1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       hh_set_xx.g_disjoint_witness (brc_iq \\<delta>) Qi =\n       Some x2 \\<Longrightarrow>\n       x2 \\<in> hs.\\<alpha> Qi\n 2. \\<And>x2.\n       hh_set_xx.g_disjoint_witness (brc_iq \\<delta>) Qi =\n       Some x2 \\<Longrightarrow>\n       \\<exists>r.\n          x2 = lhs r \\<and> r \\<in> ls.\\<alpha> \\<delta> \\<and> rhsq r = []", "apply (drule hh_set_xx.disjoint_witness_correct[simplified])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       x2 \\<in> hs.\\<alpha> (brc_iq \\<delta>) \\<and>\n       x2 \\<in> hs.\\<alpha> Qi \\<Longrightarrow>\n       x2 \\<in> hs.\\<alpha> Qi\n 2. \\<And>x2.\n       hh_set_xx.g_disjoint_witness (brc_iq \\<delta>) Qi =\n       Some x2 \\<Longrightarrow>\n       \\<exists>r.\n          x2 = lhs r \\<and> r \\<in> ls.\\<alpha> \\<delta> \\<and> rhsq r = []", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       hh_set_xx.g_disjoint_witness (brc_iq \\<delta>) Qi =\n       Some x2 \\<Longrightarrow>\n       \\<exists>r.\n          x2 = lhs r \\<and> r \\<in> ls.\\<alpha> \\<delta> \\<and> rhsq r = []", "apply (drule hh_set_xx.disjoint_witness_correct[simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       x2 \\<in> hs.\\<alpha> (brc_iq \\<delta>) \\<and>\n       x2 \\<in> hs.\\<alpha> Qi \\<Longrightarrow>\n       \\<exists>r.\n          x2 = lhs r \\<and> r \\<in> ls.\\<alpha> \\<delta> \\<and> rhsq r = []", "apply (simp add: brc_iq_correct br_iq_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma brec_cond_abs: \n  \"\\<lbrakk>\\<Sigma>\\<in>brec_invar Qi \\<delta>\\<rbrakk> \\<Longrightarrow> brec_cond \\<Sigma> \\<longleftrightarrow> (brec_\\<alpha> \\<Sigma>)\\<in>brw_cond Qi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma> \\<in> brec_invar Qi \\<delta> \\<Longrightarrow>\n    brec_cond \\<Sigma> = (brec_\\<alpha> \\<Sigma> \\<in> brw_cond Qi)", "apply (cases \\<Sigma>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>\\<Sigma> \\<in> brec_invar Qi \\<delta>;\n        \\<Sigma> = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> brec_cond \\<Sigma> =\n                         (brec_\\<alpha> \\<Sigma> \\<in> brw_cond Qi)", "apply (auto \n    simp add: brec_cond_def brw_cond_def brec_\\<alpha>_def brec_invar_def \n              brec_invar_add_def fifo_correct\n    split: option.split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma brec_initial_abs: \n  \"\\<lbrakk> ls_invar \\<delta>; hs_invar Qi \\<rbrakk> \n     \\<Longrightarrow> brec_\\<alpha> (brec_initial Qi \\<delta>) \\<in> brw_initial (ls_\\<alpha> \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ls.invar \\<delta>; hs.invar Qi\\<rbrakk>\n    \\<Longrightarrow> brec_\\<alpha> (brec_initial Qi \\<delta>)\n                      \\<in> brw_initial (ls.\\<alpha> \\<delta>)", "by (auto simp add: brec_initial_def Let_def brec_\\<alpha>_def \n                     brc_iq_correct brc_rcm_init_correct brec_iqm_correct \n                     br_iq_def fifo_correct hs_to_fifo.g_set_to_listr_correct \n              intro: brw_initial.intros[unfolded br_iq_def])"], ["", "lemma brec_pref_brw:\n  assumes RQRM[simp]: \"rqrm_invar rqrm\" \"rqrm_prop (ls_\\<alpha> \\<delta>) rqrm\"\n  assumes INV[simp]: \"ls_invar \\<delta>\" \"hs_invar Qi\"\n  shows \"wa_precise_refine (det_wa_wa (brec_det_algo rqrm Qi \\<delta>)) \n                           (brw_algo (hs_\\<alpha> Qi) (ls_\\<alpha> \\<delta>))  \n                           brec_\\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wa_precise_refine (det_wa_wa (brec_det_algo rqrm Qi \\<delta>))\n     (brw_algo (hs.\\<alpha> Qi) (ls.\\<alpha> \\<delta>)) brec_\\<alpha>", "apply (unfold_locales)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> wa_invar\n                         (det_wa_wa (brec_det_algo rqrm Qi \\<delta>));\n        s \\<in> wa_cond\n                 (det_wa_wa (brec_det_algo rqrm Qi \\<delta>))\\<rbrakk>\n       \\<Longrightarrow> brec_\\<alpha> s\n                         \\<in> wa_cond\n                                (brw_algo (hs.\\<alpha> Qi)\n                                  (ls.\\<alpha> \\<delta>))\n 2. \\<And>s s'.\n       \\<lbrakk>s \\<in> wa_invar\n                         (det_wa_wa (brec_det_algo rqrm Qi \\<delta>));\n        s \\<in> wa_cond (det_wa_wa (brec_det_algo rqrm Qi \\<delta>));\n        (s, s')\n        \\<in> wa_step (det_wa_wa (brec_det_algo rqrm Qi \\<delta>))\\<rbrakk>\n       \\<Longrightarrow> (brec_\\<alpha> s, brec_\\<alpha> s')\n                         \\<in> wa_step\n                                (brw_algo (hs.\\<alpha> Qi)\n                                  (ls.\\<alpha> \\<delta>))\n 3. brec_\\<alpha> ` wa_initial (det_wa_wa (brec_det_algo rqrm Qi \\<delta>))\n    \\<subseteq> wa_initial\n                 (brw_algo (hs.\\<alpha> Qi) (ls.\\<alpha> \\<delta>))\n 4. brec_\\<alpha> ` wa_invar (det_wa_wa (brec_det_algo rqrm Qi \\<delta>))\n    \\<subseteq> wa_invar (brw_algo (hs.\\<alpha> Qi) (ls.\\<alpha> \\<delta>))\n 5. \\<forall>s.\n       s \\<in> wa_invar (det_wa_wa (brec_det_algo rqrm Qi \\<delta>)) \\<and>\n       brec_\\<alpha> s\n       \\<in> wa_cond\n              (brw_algo (hs.\\<alpha> Qi)\n                (ls.\\<alpha> \\<delta>)) \\<longrightarrow>\n       s \\<in> wa_cond (det_wa_wa (brec_det_algo rqrm Qi \\<delta>))", "apply (simp_all add: det_wa_wa_def brec_det_algo_def brw_algo_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> brec_invar (hs.\\<alpha> Qi) (ls.\\<alpha> \\<delta>);\n        brec_cond s\\<rbrakk>\n       \\<Longrightarrow> brec_\\<alpha> s \\<in> brw_cond (hs.\\<alpha> Qi)\n 2. \\<And>s s'.\n       \\<lbrakk>s \\<in> brec_invar (hs.\\<alpha> Qi) (ls.\\<alpha> \\<delta>);\n        brec_cond s;\n        \\<exists>a aa b ab ba.\n           s = (a, (aa, b), ab, ba) \\<and>\n           s' = brec_step rqrm Qi (a, (aa, b), ab, ba)\\<rbrakk>\n       \\<Longrightarrow> (brec_\\<alpha> s, brec_\\<alpha> s')\n                         \\<in> brw_step (ls.\\<alpha> \\<delta>)\n 3. brec_\\<alpha> (brec_initial Qi \\<delta>)\n    \\<in> brw_initial (ls.\\<alpha> \\<delta>)\n 4. brec_\\<alpha> ` brec_invar (hs.\\<alpha> Qi) (ls.\\<alpha> \\<delta>)\n    \\<subseteq> brw_invar (ls.\\<alpha> \\<delta>)\n 5. \\<forall>a aa b ab ba.\n       (a, (aa, b), ab, ba)\n       \\<in> brec_invar (hs.\\<alpha> Qi) (ls.\\<alpha> \\<delta>) \\<and>\n       brec_\\<alpha> (a, (aa, b), ab, ba)\n       \\<in> brw_cond (hs.\\<alpha> Qi) \\<longrightarrow>\n       brec_cond (a, (aa, b), ab, ba)", "apply (auto simp add: brec_cond_abs brec_step_abs brec_initial_abs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ac ba ad bb.\n       \\<lbrakk>(a, aa, b) = brec_\\<alpha> (ab, (ac, ba), ad, bb);\n        (ab, (ac, ba), ad, bb)\n        \\<in> brec_invar (hs.\\<alpha> Qi) (ls.\\<alpha> \\<delta>)\\<rbrakk>\n       \\<Longrightarrow> brec_\\<alpha> (ab, (ac, ba), ad, bb)\n                         \\<in> brw_invar (ls.\\<alpha> \\<delta>)", "apply (simp add: brec_invar_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma brec_while_algo:\n  assumes RQRM[simp]: \"rqrm_invar rqrm\" \"rqrm_prop (ls_\\<alpha> \\<delta>) rqrm\"\n  assumes INV[simp]: \"ls_invar \\<delta>\" \"hs_invar Qi\"\n  shows \"while_algo (det_wa_wa (brec_det_algo rqrm Qi \\<delta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. while_algo (det_wa_wa (brec_det_algo rqrm Qi \\<delta>))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. while_algo (det_wa_wa (brec_det_algo rqrm Qi \\<delta>))", "interpret ref: \n    wa_precise_refine \"(det_wa_wa (brec_det_algo rqrm Qi \\<delta>))\" \n                      \"(brw_algo (hs_\\<alpha> Qi) (ls_\\<alpha> \\<delta>))\" \n                      \"brec_\\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wa_precise_refine (det_wa_wa (brec_det_algo rqrm Qi \\<delta>))\n     (brw_algo (hs.\\<alpha> Qi) (ls.\\<alpha> \\<delta>)) brec_\\<alpha>", "using brec_pref_brw[OF RQRM INV]"], ["proof (prove)\nusing this:\n  wa_precise_refine (det_wa_wa (brec_det_algo rqrm Qi \\<delta>))\n   (brw_algo (hs.\\<alpha> Qi) (ls.\\<alpha> \\<delta>)) brec_\\<alpha>\n\ngoal (1 subgoal):\n 1. wa_precise_refine (det_wa_wa (brec_det_algo rqrm Qi \\<delta>))\n     (brw_algo (hs.\\<alpha> Qi) (ls.\\<alpha> \\<delta>)) brec_\\<alpha>", "."], ["proof (state)\ngoal (1 subgoal):\n 1. while_algo (det_wa_wa (brec_det_algo rqrm Qi \\<delta>))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. while_algo (det_wa_wa (brec_det_algo rqrm Qi \\<delta>))", "apply (rule ref.wa_intro)"], ["proof (prove)\ngoal (4 subgoals):\n 1. while_algo (brw_algo (hs.\\<alpha> Qi) (ls.\\<alpha> \\<delta>))\n 2. wa_invar (det_wa_wa (brec_det_algo rqrm Qi \\<delta>)) =\n    ?addi \\<inter>\n    {s. brec_\\<alpha> s\n        \\<in> wa_invar (brw_algo (hs.\\<alpha> Qi) (ls.\\<alpha> \\<delta>))}\n 3. \\<And>s s'.\n       \\<lbrakk>s \\<in> ?addi;\n        s \\<in> wa_cond (det_wa_wa (brec_det_algo rqrm Qi \\<delta>));\n        brec_\\<alpha> s\n        \\<in> wa_invar (brw_algo (hs.\\<alpha> Qi) (ls.\\<alpha> \\<delta>));\n        (s, s')\n        \\<in> wa_step (det_wa_wa (brec_det_algo rqrm Qi \\<delta>))\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> ?addi\n 4. wa_initial (det_wa_wa (brec_det_algo rqrm Qi \\<delta>))\n    \\<subseteq> ?addi", "apply (simp add: brw_while_algo)"], ["proof (prove)\ngoal (3 subgoals):\n 1. wa_invar (det_wa_wa (brec_det_algo rqrm Qi \\<delta>)) =\n    ?addi \\<inter>\n    {s. brec_\\<alpha> s\n        \\<in> wa_invar (brw_algo (hs.\\<alpha> Qi) (ls.\\<alpha> \\<delta>))}\n 2. \\<And>s s'.\n       \\<lbrakk>s \\<in> ?addi;\n        s \\<in> wa_cond (det_wa_wa (brec_det_algo rqrm Qi \\<delta>));\n        brec_\\<alpha> s\n        \\<in> wa_invar (brw_algo (hs.\\<alpha> Qi) (ls.\\<alpha> \\<delta>));\n        (s, s')\n        \\<in> wa_step (det_wa_wa (brec_det_algo rqrm Qi \\<delta>))\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> ?addi\n 3. wa_initial (det_wa_wa (brec_det_algo rqrm Qi \\<delta>))\n    \\<subseteq> ?addi", "apply (simp_all add: det_wa_wa_def brec_det_algo_def brw_algo_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. brec_invar (hs.\\<alpha> Qi) (ls.\\<alpha> \\<delta>) =\n    ?addi \\<inter>\n    {s. brec_\\<alpha> s \\<in> brw_invar (ls.\\<alpha> \\<delta>)}\n 2. \\<And>s s'.\n       \\<lbrakk>s \\<in> ?addi; brec_cond s;\n        brec_\\<alpha> s \\<in> brw_invar (ls.\\<alpha> \\<delta>);\n        \\<exists>a aa b ab ba.\n           s = (a, (aa, b), ab, ba) \\<and>\n           s' = brec_step rqrm Qi (a, (aa, b), ab, ba)\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> ?addi\n 3. brec_initial Qi \\<delta> \\<in> ?addi", "apply (simp add: brec_invar_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>s \\<in> brec_invar_add (hs.\\<alpha> Qi); brec_cond s;\n        brec_\\<alpha> s \\<in> brw_invar (ls.\\<alpha> \\<delta>);\n        \\<exists>a aa b ab ba.\n           s = (a, (aa, b), ab, ba) \\<and>\n           s' = brec_step rqrm Qi (a, (aa, b), ab, ba)\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> brec_invar_add (hs.\\<alpha> Qi)\n 2. brec_initial Qi \\<delta> \\<in> brec_invar_add (hs.\\<alpha> Qi)", "apply (auto simp add: brec_step_invar[OF RQRM INV(2)]) [1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. brec_initial Qi \\<delta> \\<in> brec_invar_add (hs.\\<alpha> Qi)", "apply (simp add: brec_invar_initial) [1]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  while_algo (det_wa_wa (brec_det_algo rqrm Qi \\<delta>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fst_brec_\\<alpha>: \"fst (brec_\\<alpha> \\<Sigma>) = hm_\\<alpha> (fst \\<Sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (brec_\\<alpha> \\<Sigma>) = hm.\\<alpha> (fst \\<Sigma>)", "by (cases \\<Sigma>) (simp add: brec_\\<alpha>_def)"], ["", "lemmas brec_invar_final = \n  wa_precise_refine.transfer_correctness[\n    OF brec_pref_brw brw_invar_final, \n    unfolded fst_brec_\\<alpha>]"], ["", "lemmas brec_det_algo = det_while_algo_intro[OF brec_while_algo]"], ["", "definition \"hta_is_empty_witness H == \n  let rqrm = build_rqrm (hta_\\<delta> H);\n      (Q,_,_,qwit) = (while brec_cond (brec_step rqrm (hta_Qi H)) \n                            (brec_initial (hta_Qi H) (hta_\\<delta> H))) \n  in\n    case qwit of \n      None \\<Rightarrow> None |\n      Some q \\<Rightarrow> (hm_lookup q Q)\n\""], ["", "theorem (in hashedTa) hta_is_empty_witness_correct:\n  shows [rule_format]: \"hta_is_empty_witness H = Some t \n                        \\<longrightarrow> t\\<in>ta_lang (hta_\\<alpha> H)\" (is ?T1)\n        \"hta_is_empty_witness H = None \\<longrightarrow> ta_lang (hta_\\<alpha> H) = {}\" (is ?T2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hta_is_empty_witness H = Some t \\<longrightarrow>\n    t \\<in> ta_lang (hta_\\<alpha> H) &&&\n    hta_is_empty_witness H = None \\<longrightarrow>\n    ta_lang (hta_\\<alpha> H) = {}", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. hta_is_empty_witness H = Some t \\<longrightarrow>\n    t \\<in> ta_lang (hta_\\<alpha> H)\n 2. hta_is_empty_witness H = None \\<longrightarrow>\n    ta_lang (hta_\\<alpha> H) = {}", "interpret det_while_algo \"(brec_det_algo (build_rqrm \\<delta>) Qi \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det_while_algo (brec_det_algo (build_rqrm \\<delta>) Qi \\<delta>)", "by (rule brec_det_algo)\n       (simp_all add: build_rqrm_correct)"], ["proof (state)\ngoal (2 subgoals):\n 1. hta_is_empty_witness H = Some t \\<longrightarrow>\n    t \\<in> ta_lang (hta_\\<alpha> H)\n 2. hta_is_empty_witness H = None \\<longrightarrow>\n    ta_lang (hta_\\<alpha> H) = {}", "have LC: \n    \"(while brec_cond (brec_step (build_rqrm \\<delta>) Qi) (brec_initial Qi \\<delta>)) = loop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. while brec_cond (brec_step (build_rqrm \\<delta>) Qi)\n     (brec_initial Qi \\<delta>) =\n    loop", "by (unfold loop_def)\n       (simp add: brec_det_algo_def)"], ["proof (state)\nthis:\n  while brec_cond (brec_step (build_rqrm \\<delta>) Qi)\n   (brec_initial Qi \\<delta>) =\n  loop\n\ngoal (2 subgoals):\n 1. hta_is_empty_witness H = Some t \\<longrightarrow>\n    t \\<in> ta_lang (hta_\\<alpha> H)\n 2. hta_is_empty_witness H = None \\<longrightarrow>\n    ta_lang (hta_\\<alpha> H) = {}", "from while_proof'[OF brec_invar_final]"], ["proof (chain)\npicking this:\n  \\<lbrakk>rqrm_invar (build_rqrm \\<delta>);\n   rqrm_prop (ls.\\<alpha> \\<delta>) (build_rqrm \\<delta>);\n   ls.invar \\<delta>; hs.invar Qi\\<rbrakk>\n  \\<Longrightarrow> (hs.\\<alpha> Qi \\<inter> dom (hm.\\<alpha> (fst loop)) =\n                     {}) =\n                    (hs.\\<alpha> Qi \\<inter>\n                     b_accessible (ls.\\<alpha> \\<delta>) =\n                     {}) \\<and>\n                    witness_prop (ls.\\<alpha> \\<delta>)\n                     (hm.\\<alpha> (fst loop))", "have X:\n    \"hs_\\<alpha> Qi \\<inter> dom (hm_\\<alpha> (fst loop)) = {} \n     \\<longleftrightarrow> (hs_\\<alpha> Qi \\<inter> b_accessible (ls_\\<alpha> \\<delta>) = {})\"\n    \"witness_prop (ls_\\<alpha> \\<delta>) (hm_\\<alpha> (fst loop))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>rqrm_invar (build_rqrm \\<delta>);\n   rqrm_prop (ls.\\<alpha> \\<delta>) (build_rqrm \\<delta>);\n   ls.invar \\<delta>; hs.invar Qi\\<rbrakk>\n  \\<Longrightarrow> (hs.\\<alpha> Qi \\<inter> dom (hm.\\<alpha> (fst loop)) =\n                     {}) =\n                    (hs.\\<alpha> Qi \\<inter>\n                     b_accessible (ls.\\<alpha> \\<delta>) =\n                     {}) \\<and>\n                    witness_prop (ls.\\<alpha> \\<delta>)\n                     (hm.\\<alpha> (fst loop))\n\ngoal (1 subgoal):\n 1. (hs.\\<alpha> Qi \\<inter> dom (hm.\\<alpha> (fst loop)) = {}) =\n    (hs.\\<alpha> Qi \\<inter> b_accessible (ls.\\<alpha> \\<delta>) = {}) &&&\n    witness_prop (ls.\\<alpha> \\<delta>) (hm.\\<alpha> (fst loop))", "by (simp_all add: build_rqrm_correct)"], ["proof (state)\nthis:\n  (hs.\\<alpha> Qi \\<inter> dom (hm.\\<alpha> (fst loop)) = {}) =\n  (hs.\\<alpha> Qi \\<inter> b_accessible (ls.\\<alpha> \\<delta>) = {})\n  witness_prop (ls.\\<alpha> \\<delta>) (hm.\\<alpha> (fst loop))\n\ngoal (2 subgoals):\n 1. hta_is_empty_witness H = Some t \\<longrightarrow>\n    t \\<in> ta_lang (hta_\\<alpha> H)\n 2. hta_is_empty_witness H = None \\<longrightarrow>\n    ta_lang (hta_\\<alpha> H) = {}", "obtain Q W rcm qwit where \n    [simp]: \"loop = (Q,W,rcm,qwit)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Q W rcm qwit.\n        loop = (Q, W, rcm, qwit) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (case_tac \"loop\") blast"], ["proof (state)\nthis:\n  loop = (Q, W, rcm, qwit)\n\ngoal (2 subgoals):\n 1. hta_is_empty_witness H = Some t \\<longrightarrow>\n    t \\<in> ta_lang (hta_\\<alpha> H)\n 2. hta_is_empty_witness H = None \\<longrightarrow>\n    ta_lang (hta_\\<alpha> H) = {}", "from loop_invar"], ["proof (chain)\npicking this:\n  loop \\<in> dwa_invar (brec_det_algo (build_rqrm \\<delta>) Qi \\<delta>)", "have I: \"loop \\<in> brec_invar (hs_\\<alpha> Qi) (ls_\\<alpha> \\<delta>)\""], ["proof (prove)\nusing this:\n  loop \\<in> dwa_invar (brec_det_algo (build_rqrm \\<delta>) Qi \\<delta>)\n\ngoal (1 subgoal):\n 1. loop \\<in> brec_invar (hs.\\<alpha> Qi) (ls.\\<alpha> \\<delta>)", "by (simp add: brec_det_algo_def)"], ["proof (state)\nthis:\n  loop \\<in> brec_invar (hs.\\<alpha> Qi) (ls.\\<alpha> \\<delta>)\n\ngoal (2 subgoals):\n 1. hta_is_empty_witness H = Some t \\<longrightarrow>\n    t \\<in> ta_lang (hta_\\<alpha> H)\n 2. hta_is_empty_witness H = None \\<longrightarrow>\n    ta_lang (hta_\\<alpha> H) = {}", "hence INVARS[simp]: \"hm_invar Q\" \"hm_invar rcm\""], ["proof (prove)\nusing this:\n  loop \\<in> brec_invar (hs.\\<alpha> Qi) (ls.\\<alpha> \\<delta>)\n\ngoal (1 subgoal):\n 1. hm.invar Q &&& hm.invar rcm", "by (simp_all add: brec_invar_def brec_invar_add_def)"], ["proof (state)\nthis:\n  hm.invar Q\n  hm.invar rcm\n\ngoal (2 subgoals):\n 1. hta_is_empty_witness H = Some t \\<longrightarrow>\n    t \\<in> ta_lang (hta_\\<alpha> H)\n 2. hta_is_empty_witness H = None \\<longrightarrow>\n    ta_lang (hta_\\<alpha> H) = {}", "{"], ["proof (state)\nthis:\n  hm.invar Q\n  hm.invar rcm\n\ngoal (2 subgoals):\n 1. hta_is_empty_witness H = Some t \\<longrightarrow>\n    t \\<in> ta_lang (hta_\\<alpha> H)\n 2. hta_is_empty_witness H = None \\<longrightarrow>\n    ta_lang (hta_\\<alpha> H) = {}", "assume C: \"hta_is_empty_witness H = Some t\""], ["proof (state)\nthis:\n  hta_is_empty_witness H = Some t\n\ngoal (2 subgoals):\n 1. hta_is_empty_witness H = Some t \\<longrightarrow>\n    t \\<in> ta_lang (hta_\\<alpha> H)\n 2. hta_is_empty_witness H = None \\<longrightarrow>\n    ta_lang (hta_\\<alpha> H) = {}", "then"], ["proof (chain)\npicking this:\n  hta_is_empty_witness H = Some t", "obtain q where \n      [simp]: \"qwit=Some q\" and \n        LUQ: \"hm_lookup q Q = Some t\""], ["proof (prove)\nusing this:\n  hta_is_empty_witness H = Some t\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>qwit = Some q; hm.lookup q Q = Some t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (unfold hta_is_empty_witness_def)\n         (simp add: LC split: option.split_asm)"], ["proof (state)\nthis:\n  qwit = Some q\n  hm.lookup q Q = Some t\n\ngoal (2 subgoals):\n 1. hta_is_empty_witness H = Some t \\<longrightarrow>\n    t \\<in> ta_lang (hta_\\<alpha> H)\n 2. hta_is_empty_witness H = None \\<longrightarrow>\n    ta_lang (hta_\\<alpha> H) = {}", "from LUQ"], ["proof (chain)\npicking this:\n  hm.lookup q Q = Some t", "have QqF: \"hm_\\<alpha> Q q = Some t\""], ["proof (prove)\nusing this:\n  hm.lookup q Q = Some t\n\ngoal (1 subgoal):\n 1. hm.\\<alpha> Q q = Some t", "by (simp add: hm_correct)"], ["proof (state)\nthis:\n  hm.\\<alpha> Q q = Some t\n\ngoal (2 subgoals):\n 1. hta_is_empty_witness H = Some t \\<longrightarrow>\n    t \\<in> ta_lang (hta_\\<alpha> H)\n 2. hta_is_empty_witness H = None \\<longrightarrow>\n    ta_lang (hta_\\<alpha> H) = {}", "from I"], ["proof (chain)\npicking this:\n  loop \\<in> brec_invar (hs.\\<alpha> Qi) (ls.\\<alpha> \\<delta>)", "have QMEM: \"q\\<in>hs_\\<alpha> Qi\""], ["proof (prove)\nusing this:\n  loop \\<in> brec_invar (hs.\\<alpha> Qi) (ls.\\<alpha> \\<delta>)\n\ngoal (1 subgoal):\n 1. q \\<in> hs.\\<alpha> Qi", "by (simp_all add: brec_invar_def brec_invar_add_def)"], ["proof (state)\nthis:\n  q \\<in> hs.\\<alpha> Qi\n\ngoal (2 subgoals):\n 1. hta_is_empty_witness H = Some t \\<longrightarrow>\n    t \\<in> ta_lang (hta_\\<alpha> H)\n 2. hta_is_empty_witness H = None \\<longrightarrow>\n    ta_lang (hta_\\<alpha> H) = {}", "moreover"], ["proof (state)\nthis:\n  q \\<in> hs.\\<alpha> Qi\n\ngoal (2 subgoals):\n 1. hta_is_empty_witness H = Some t \\<longrightarrow>\n    t \\<in> ta_lang (hta_\\<alpha> H)\n 2. hta_is_empty_witness H = None \\<longrightarrow>\n    ta_lang (hta_\\<alpha> H) = {}", "from witness_propD[OF X(2)] QqF"], ["proof (chain)\npicking this:\n  hm.\\<alpha> (fst loop) ?q = Some ?t \\<Longrightarrow>\n  accs (ls.\\<alpha> \\<delta>) ?t ?q\n  hm.\\<alpha> Q q = Some t", "have \"accs (ls_\\<alpha> \\<delta>) t q\""], ["proof (prove)\nusing this:\n  hm.\\<alpha> (fst loop) ?q = Some ?t \\<Longrightarrow>\n  accs (ls.\\<alpha> \\<delta>) ?t ?q\n  hm.\\<alpha> Q q = Some t\n\ngoal (1 subgoal):\n 1. accs (ls.\\<alpha> \\<delta>) t q", "by simp"], ["proof (state)\nthis:\n  accs (ls.\\<alpha> \\<delta>) t q\n\ngoal (2 subgoals):\n 1. hta_is_empty_witness H = Some t \\<longrightarrow>\n    t \\<in> ta_lang (hta_\\<alpha> H)\n 2. hta_is_empty_witness H = None \\<longrightarrow>\n    ta_lang (hta_\\<alpha> H) = {}", "ultimately"], ["proof (chain)\npicking this:\n  q \\<in> hs.\\<alpha> Qi\n  accs (ls.\\<alpha> \\<delta>) t q", "have \"t\\<in>ta_lang (hta_\\<alpha> H)\""], ["proof (prove)\nusing this:\n  q \\<in> hs.\\<alpha> Qi\n  accs (ls.\\<alpha> \\<delta>) t q\n\ngoal (1 subgoal):\n 1. t \\<in> ta_lang (hta_\\<alpha> H)", "by (auto simp add: ta_lang_def hta_\\<alpha>_def)"], ["proof (state)\nthis:\n  t \\<in> ta_lang (hta_\\<alpha> H)\n\ngoal (2 subgoals):\n 1. hta_is_empty_witness H = Some t \\<longrightarrow>\n    t \\<in> ta_lang (hta_\\<alpha> H)\n 2. hta_is_empty_witness H = None \\<longrightarrow>\n    ta_lang (hta_\\<alpha> H) = {}", "}"], ["proof (state)\nthis:\n  hta_is_empty_witness H = Some t \\<Longrightarrow>\n  t \\<in> ta_lang (hta_\\<alpha> H)\n\ngoal (2 subgoals):\n 1. hta_is_empty_witness H = Some t \\<longrightarrow>\n    t \\<in> ta_lang (hta_\\<alpha> H)\n 2. hta_is_empty_witness H = None \\<longrightarrow>\n    ta_lang (hta_\\<alpha> H) = {}", "moreover"], ["proof (state)\nthis:\n  hta_is_empty_witness H = Some t \\<Longrightarrow>\n  t \\<in> ta_lang (hta_\\<alpha> H)\n\ngoal (2 subgoals):\n 1. hta_is_empty_witness H = Some t \\<longrightarrow>\n    t \\<in> ta_lang (hta_\\<alpha> H)\n 2. hta_is_empty_witness H = None \\<longrightarrow>\n    ta_lang (hta_\\<alpha> H) = {}", "{"], ["proof (state)\nthis:\n  hta_is_empty_witness H = Some t \\<Longrightarrow>\n  t \\<in> ta_lang (hta_\\<alpha> H)\n\ngoal (2 subgoals):\n 1. hta_is_empty_witness H = Some t \\<longrightarrow>\n    t \\<in> ta_lang (hta_\\<alpha> H)\n 2. hta_is_empty_witness H = None \\<longrightarrow>\n    ta_lang (hta_\\<alpha> H) = {}", "assume C: \"hta_is_empty_witness H = None\""], ["proof (state)\nthis:\n  hta_is_empty_witness H = None\n\ngoal (2 subgoals):\n 1. hta_is_empty_witness H = Some t \\<longrightarrow>\n    t \\<in> ta_lang (hta_\\<alpha> H)\n 2. hta_is_empty_witness H = None \\<longrightarrow>\n    ta_lang (hta_\\<alpha> H) = {}", "hence DJ: \"hs_\\<alpha> Qi \\<inter> dom (hm_\\<alpha> Q) = {}\""], ["proof (prove)\nusing this:\n  hta_is_empty_witness H = None\n\ngoal (1 subgoal):\n 1. hs.\\<alpha> Qi \\<inter> dom (hm.\\<alpha> Q) = {}", "using I"], ["proof (prove)\nusing this:\n  hta_is_empty_witness H = None\n  loop \\<in> brec_invar (hs.\\<alpha> Qi) (ls.\\<alpha> \\<delta>)\n\ngoal (1 subgoal):\n 1. hs.\\<alpha> Qi \\<inter> dom (hm.\\<alpha> Q) = {}", "by (auto simp add: hta_is_empty_witness_def LC brec_invar_def \n                         brec_invar_add_def hm_correct \n               split: option.split_asm)"], ["proof (state)\nthis:\n  hs.\\<alpha> Qi \\<inter> dom (hm.\\<alpha> Q) = {}\n\ngoal (2 subgoals):\n 1. hta_is_empty_witness H = Some t \\<longrightarrow>\n    t \\<in> ta_lang (hta_\\<alpha> H)\n 2. hta_is_empty_witness H = None \\<longrightarrow>\n    ta_lang (hta_\\<alpha> H) = {}", "with X"], ["proof (chain)\npicking this:\n  (hs.\\<alpha> Qi \\<inter> dom (hm.\\<alpha> (fst loop)) = {}) =\n  (hs.\\<alpha> Qi \\<inter> b_accessible (ls.\\<alpha> \\<delta>) = {})\n  witness_prop (ls.\\<alpha> \\<delta>) (hm.\\<alpha> (fst loop))\n  hs.\\<alpha> Qi \\<inter> dom (hm.\\<alpha> Q) = {}", "have \"hs_\\<alpha> Qi \\<inter> b_accessible (ls_\\<alpha> \\<delta>) = {}\""], ["proof (prove)\nusing this:\n  (hs.\\<alpha> Qi \\<inter> dom (hm.\\<alpha> (fst loop)) = {}) =\n  (hs.\\<alpha> Qi \\<inter> b_accessible (ls.\\<alpha> \\<delta>) = {})\n  witness_prop (ls.\\<alpha> \\<delta>) (hm.\\<alpha> (fst loop))\n  hs.\\<alpha> Qi \\<inter> dom (hm.\\<alpha> Q) = {}\n\ngoal (1 subgoal):\n 1. hs.\\<alpha> Qi \\<inter> b_accessible (ls.\\<alpha> \\<delta>) = {}", "by (simp add: brec_\\<alpha>_def)"], ["proof (state)\nthis:\n  hs.\\<alpha> Qi \\<inter> b_accessible (ls.\\<alpha> \\<delta>) = {}\n\ngoal (2 subgoals):\n 1. hta_is_empty_witness H = Some t \\<longrightarrow>\n    t \\<in> ta_lang (hta_\\<alpha> H)\n 2. hta_is_empty_witness H = None \\<longrightarrow>\n    ta_lang (hta_\\<alpha> H) = {}", "with empty_if_no_b_accessible[of \"hta_\\<alpha> H\"]"], ["proof (chain)\npicking this:\n  (ta_lang (hta_\\<alpha> H) = {}) =\n  (ta_initial (hta_\\<alpha> H) \\<inter>\n   b_accessible (ta_rules (hta_\\<alpha> H)) =\n   {})\n  hs.\\<alpha> Qi \\<inter> b_accessible (ls.\\<alpha> \\<delta>) = {}", "have \"ta_lang (hta_\\<alpha> H) = {}\""], ["proof (prove)\nusing this:\n  (ta_lang (hta_\\<alpha> H) = {}) =\n  (ta_initial (hta_\\<alpha> H) \\<inter>\n   b_accessible (ta_rules (hta_\\<alpha> H)) =\n   {})\n  hs.\\<alpha> Qi \\<inter> b_accessible (ls.\\<alpha> \\<delta>) = {}\n\ngoal (1 subgoal):\n 1. ta_lang (hta_\\<alpha> H) = {}", "by (simp add: hta_\\<alpha>_def)"], ["proof (state)\nthis:\n  ta_lang (hta_\\<alpha> H) = {}\n\ngoal (2 subgoals):\n 1. hta_is_empty_witness H = Some t \\<longrightarrow>\n    t \\<in> ta_lang (hta_\\<alpha> H)\n 2. hta_is_empty_witness H = None \\<longrightarrow>\n    ta_lang (hta_\\<alpha> H) = {}", "}"], ["proof (state)\nthis:\n  hta_is_empty_witness H = None \\<Longrightarrow>\n  ta_lang (hta_\\<alpha> H) = {}\n\ngoal (2 subgoals):\n 1. hta_is_empty_witness H = Some t \\<longrightarrow>\n    t \\<in> ta_lang (hta_\\<alpha> H)\n 2. hta_is_empty_witness H = None \\<longrightarrow>\n    ta_lang (hta_\\<alpha> H) = {}", "ultimately"], ["proof (chain)\npicking this:\n  hta_is_empty_witness H = Some t \\<Longrightarrow>\n  t \\<in> ta_lang (hta_\\<alpha> H)\n  hta_is_empty_witness H = None \\<Longrightarrow>\n  ta_lang (hta_\\<alpha> H) = {}", "show ?T1 ?T2"], ["proof (prove)\nusing this:\n  hta_is_empty_witness H = Some t \\<Longrightarrow>\n  t \\<in> ta_lang (hta_\\<alpha> H)\n  hta_is_empty_witness H = None \\<Longrightarrow>\n  ta_lang (hta_\\<alpha> H) = {}\n\ngoal (1 subgoal):\n 1. hta_is_empty_witness H = Some t \\<longrightarrow>\n    t \\<in> ta_lang (hta_\\<alpha> H) &&&\n    hta_is_empty_witness H = None \\<longrightarrow>\n    ta_lang (hta_\\<alpha> H) = {}", "by auto"], ["proof (state)\nthis:\n  hta_is_empty_witness H = Some t \\<longrightarrow>\n  t \\<in> ta_lang (hta_\\<alpha> H)\n  hta_is_empty_witness H = None \\<longrightarrow>\n  ta_lang (hta_\\<alpha> H) = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Interface for Natural Number States and Symbols\\<close>"], ["", "text_raw \\<open>\\label{sec:htai_intf}\\<close>"], ["", "text \\<open>\n  The library-interface is statically instantiated to use natural numbers \n  as both, states and symbols.\n\n  This interface is easier to use from ML and OCaml, because there is no \n  overhead with typeclass emulation.\n\\<close>"], ["", "type_synonym htai = \"(nat,nat) hashedTa\""], ["", "definition htai_mem :: \"_ \\<Rightarrow> htai \\<Rightarrow> bool\" \n  where \"htai_mem == hta_mem\""], ["", "definition htai_prod :: \"htai \\<Rightarrow> htai \\<Rightarrow> htai\" \n  where \"htai_prod H1 H2 == hta_reindex (hta_prod H1 H2)\""], ["", "definition htai_prodWR :: \"htai \\<Rightarrow> htai \\<Rightarrow> htai\" \n  where \"htai_prodWR H1 H2 == hta_reindex (hta_prodWR H1 H2)\""], ["", "definition htai_union :: \"htai \\<Rightarrow> htai \\<Rightarrow> htai\" \n  where \"htai_union H1 H2 == hta_reindex (hta_union H1 H2)\""], ["", "definition htai_empty :: \"unit \\<Rightarrow> htai\"\n  where \"htai_empty == hta_empty\""], ["", "definition htai_add_qi :: \"_ \\<Rightarrow> htai \\<Rightarrow> htai\" \n  where \"htai_add_qi == hta_add_qi\""], ["", "definition htai_add_rule :: \"_ \\<Rightarrow> htai \\<Rightarrow> htai\" \n  where \"htai_add_rule == hta_add_rule\""], ["", "definition htai_bwd_reduce :: \"htai \\<Rightarrow> htai\" \n  where \"htai_bwd_reduce == hta_bwd_reduce\""], ["", "definition htai_is_empty_witness :: \"htai \\<Rightarrow> _\" \n  where \"htai_is_empty_witness == hta_is_empty_witness\""], ["", "definition htai_ensure_idx_f :: \"htai \\<Rightarrow> htai\" \n  where \"htai_ensure_idx_f == hta_ensure_idx_f\""], ["", "definition htai_ensure_idx_s :: \"htai \\<Rightarrow> htai\" \n  where \"htai_ensure_idx_s == hta_ensure_idx_s\""], ["", "definition htai_ensure_idx_sf :: \"htai \\<Rightarrow> htai\" \n  where \"htai_ensure_idx_sf == hta_ensure_idx_sf\""], ["", "definition htaip_prod :: \"htai \\<Rightarrow> htai \\<Rightarrow> (nat * nat,nat) hashedTa\" \n  where \"htaip_prod == hta_prod\""], ["", "definition htaip_prodWR :: \"htai \\<Rightarrow> htai \\<Rightarrow> (nat * nat,nat) hashedTa\" \n  where \"htaip_prodWR == hta_prodWR\""], ["", "definition htaip_reindex :: \"(nat * nat,nat) hashedTa \\<Rightarrow> htai\" \n  where \"htaip_reindex == hta_reindex\""], ["", "locale htai = hashedTa +\n  constrains H :: htai\nbegin"], ["", "lemmas htai_mem_correct = hta_mem_correct[folded htai_mem_def]"], ["", "lemma htai_empty_correct[simp]:\n    \"hta_\\<alpha> (htai_empty ()) = ta_empty\"\n    \"hashedTa (htai_empty ())\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hta_\\<alpha> (htai_empty ()) = ta_empty &&& hashedTa (htai_empty ())", "by (auto simp add: htai_empty_def hta_empty_correct)"], ["", "lemmas htai_add_qi_correct = hta_add_qi_correct[folded htai_add_qi_def]"], ["", "lemmas htai_add_rule_correct = hta_add_rule_correct[folded htai_add_rule_def]"], ["", "lemmas htai_bwd_reduce_correct = \n    hta_bwd_reduce_correct[folded htai_bwd_reduce_def]"], ["", "lemmas htai_is_empty_witness_correct = \n    hta_is_empty_witness_correct[folded htai_is_empty_witness_def]"], ["", "lemmas htai_ensure_idx_f_correct = \n    hta_ensure_idx_f_correct[folded htai_ensure_idx_f_def]"], ["", "lemmas htai_ensure_idx_s_correct = \n    hta_ensure_idx_s_correct[folded htai_ensure_idx_s_def]"], ["", "lemmas htai_ensure_idx_sf_correct = \n    hta_ensure_idx_sf_correct[folded htai_ensure_idx_sf_def]"], ["", "end"], ["", "lemma htai_prod_correct:\n  assumes [simp]: \"hashedTa H1\" \"hashedTa H2\"\n  shows \n  \"ta_lang (hta_\\<alpha> (htai_prod H1 H2)) = ta_lang (hta_\\<alpha> H1) \\<inter> ta_lang (hta_\\<alpha> H2)\"\n  \"hashedTa (htai_prod H1 H2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_lang (hta_\\<alpha> (htai_prod H1 H2)) =\n    ta_lang (hta_\\<alpha> H1) \\<inter> ta_lang (hta_\\<alpha> H2) &&&\n    hashedTa (htai_prod H1 H2)", "apply (unfold htai_prod_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ta_lang (hta_\\<alpha> (hta_reindex (hta_prod H1 H2))) =\n    ta_lang (hta_\\<alpha> H1) \\<inter> ta_lang (hta_\\<alpha> H2)\n 2. hashedTa (hta_reindex (hta_prod H1 H2))", "apply (auto simp add: hta_prod_correct hashedTa.hta_reindex_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma htai_prodWR_correct:\n  assumes [simp]: \"hashedTa H1\" \"hashedTa H2\"\n  shows \n  \"ta_lang (hta_\\<alpha> (htai_prodWR H1 H2)) \n   = ta_lang (hta_\\<alpha> H1) \\<inter> ta_lang (hta_\\<alpha> H2)\"\n  \"hashedTa (htai_prodWR H1 H2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_lang (hta_\\<alpha> (htai_prodWR H1 H2)) =\n    ta_lang (hta_\\<alpha> H1) \\<inter> ta_lang (hta_\\<alpha> H2) &&&\n    hashedTa (htai_prodWR H1 H2)", "apply (unfold htai_prodWR_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ta_lang (hta_\\<alpha> (hta_reindex (hta_prodWR H1 H2))) =\n    ta_lang (hta_\\<alpha> H1) \\<inter> ta_lang (hta_\\<alpha> H2)\n 2. hashedTa (hta_reindex (hta_prodWR H1 H2))", "apply (auto simp add: hta_prodWR_correct hashedTa.hta_reindex_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma htai_union_correct:\n  assumes [simp]: \"hashedTa H1\" \"hashedTa H2\"\n  shows \n  \"ta_lang (hta_\\<alpha> (htai_union H1 H2)) \n   = ta_lang (hta_\\<alpha> H1) \\<union> ta_lang (hta_\\<alpha> H2)\"\n  \"hashedTa (htai_union H1 H2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_lang (hta_\\<alpha> (htai_union H1 H2)) =\n    ta_lang (hta_\\<alpha> H1) \\<union> ta_lang (hta_\\<alpha> H2) &&&\n    hashedTa (htai_union H1 H2)", "apply (unfold htai_union_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ta_lang (hta_\\<alpha> (hta_reindex (hta_union H1 H2))) =\n    ta_lang (hta_\\<alpha> H1) \\<union> ta_lang (hta_\\<alpha> H2)\n 2. hashedTa (hta_reindex (hta_union H1 H2))", "apply (auto simp add: hta_union_correct hashedTa.hta_reindex_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Interface Documentation\\<close>"], ["", "text_raw\\<open>\\label{sec:intf_doc}\\<close>"], ["", "text \\<open>\n  This section contains a documentation of the executable tree-automata\n  interface. The documentation contains a description of each function along\n  with the relevant correctness lemmas.\n\\<close>"], ["", "text \\<open>\n  ML/OCaml users should note, that there is an interface that has the fixed type\n  Int for both states and function symbols. This interface is simpler to use\n  from ML/OCaml than the generic one, as it requires no overhead to emulate\n  Isabelle/HOL type-classes.\n\n  The functions of this interface start with the prefix {\\em htai} instead of\n  {\\em hta}, but have the same semantics otherwise \n  (cf Section~\\ref{sec:htai_intf}).\n\\<close>"], ["", "subsubsection \\<open>Building a Tree Automaton\\<close>"], ["", "text_raw \\<open>\n  \\newcommand{\\fundesc}[2]{{\\bf Function: #1}\\\\#2}\n\n\\<close>"], ["", "text \\<open>\n  \\fundesc{@{const [show_types] hta_empty}}{\n    Returns a tree automaton with no states and no rules. \n  }\n  \n  \\paragraph{Relevant Lemmas}\n  \\begin{description}\n    \\item[@{thm [source] hta_empty_correct}:] @{thm hta_empty_correct[no_vars]}\n    \\item[@{thm [source] ta_empty_lang}:] @{thm ta_empty_lang[no_vars]}\n  \\end{description}\n\\<close>"], ["", "text \\<open>\n  \\fundesc{@{const [show_types] hta_add_qi}}{\n    Adds an initial state to the given automaton.\n  }\n  \\paragraph{Relevant Lemmas}\n  \\begin{description}\n    \\item[@{thm [source] hashedTa.hta_add_qi_correct}]\n      @{thm hashedTa.hta_add_qi_correct[no_vars]}\n  \\end{description}\n\\<close>"], ["", "text \\<open>\n  \\fundesc{@{const [show_types] hta_add_rule}}{\n    Adds a rule to the given automaton.\n  }\n  \\paragraph{Relevant Lemmas}\n  \\begin{description}\n    \\item[@{thm [source] hashedTa.hta_add_rule_correct}:]\n      @{thm hashedTa.hta_add_rule_correct[no_vars]}\n  \\end{description}\n\\<close>"], ["", "subsubsection \\<open>Basic Operations\\<close>"], ["", "text \\<open>\n  The tree automata of this library may have some optional indices, that \n  accelerate computation. The tree-automata operations will compute the \n  indices if necessary, but due to the pure nature of the Isabelle-language,\n  the computed index cannot be stored for the next usage. Hence, before using a\n  bulk of tree-automaton operations on the same tree-automata, the relevant \n  indexes should be pre-computed.\n\\<close>"], ["", "text \\<open>\n  \\fundesc{\n    @{const [show_types] hta_ensure_idx_f}\\\\\n    @{const [show_types] hta_ensure_idx_s}\\\\\n    @{const [show_types] hta_ensure_idx_sf}\n  }{\n    Computes an index for a tree automaton, if it is not yet present.\n  }\n\\<close>"], ["", "text \\<open>\n  \\fundesc{@{const [show_types] hta_mem}, @{const [show_types] hta_mem'}}{\n    Check whether a tree is accepted by the tree automaton.\n  }\n  \\paragraph{Relevant Lemmas}\n  \\begin{description}\n    \\item[@{thm [source] hashedTa.hta_mem_correct}:]\n      @{thm hashedTa.hta_mem_correct[no_vars]}\n    \\item[@{thm [source] hashedTa.hta_mem'_correct}:]\n      @{thm hashedTa.hta_mem'_correct[no_vars]}\n  \\end{description}\n\\<close>"], ["", "text \\<open>\n  \\fundesc{@{const [show_types] hta_prod}, @{const [show_types] hta_prod'}}{\n    Compute the product automaton. The computed automaton is in \n    forward-reduced form. \n    The language of the product automaton is the intersection of \n    the languages of the two argument automata.\n  }\n  \\paragraph{Relevant Lemmas}\n  \\begin{description}\n    \\item[@{thm [source] hta_prod_correct_aux}:] \n      @{thm hta_prod_correct_aux[no_vars]}\n    \\item[@{thm [source] hta_prod_correct}:] \n      @{thm hta_prod_correct[no_vars]}\n    \\item[@{thm [source] hta_prod'_correct_aux}:] \n      @{thm hta_prod'_correct_aux[no_vars]}\n    \\item[@{thm [source] hta_prod'_correct}:] \n      @{thm hta_prod'_correct[no_vars]}\n  \\end{description}\n\\<close>"], ["", "text \\<open>\n  \\fundesc{@{const [show_types] hta_prodWR}}{\n    Compute the product automaton by brute-force algorithm. \n    The resulting automaton is not reduced.\n    The language of the product automaton is the intersection of \n    the languages of the two argument automata.\n  }\n  \\paragraph{Relevant Lemmas}\n  \\begin{description}\n  \\item[@{thm [source] hta_prodWR_correct_aux}:]\n    @{thm hta_prodWR_correct_aux[no_vars]}\n  \\item[@{thm [source] hta_prodWR_correct}:] \n    @{thm hta_prodWR_correct[no_vars]}\n  \\end{description}\n\\<close>"], ["", "text \\<open>\n  \\fundesc{@{const [show_types] hta_union}}{\n    Compute the union of two tree automata.\n  }\n  \\paragraph{Relevant Lemmas}\n  \\begin{description}\n  \\item[@{thm [source] hta_union_correct'}:] @{thm hta_union_correct'[no_vars]}\n  \\item[@{thm [source] hta_union_correct}:] @{thm hta_union_correct[no_vars]}\n  \\end{description}\n\\<close>"], ["", "text \\<open>\n  \\fundesc{@{const [show_types] hta_reduce}}{\n    Reduce the automaton to the given set of states. All initial states outside\n    this set will be removed. Moreover, all rules that contain states outside \n    this set are removed, too.\n  }\n  \\paragraph{Relevant Lemmas}\n  \\begin{description}\n    \\item[@{thm [source] hashedTa.hta_reduce_correct}:]\n      @{thm hashedTa.hta_reduce_correct[no_vars]}\n  \\end{description}\n\\<close>"], ["", "text \\<open>\n  \\fundesc{@{const [show_types] hta_bwd_reduce}}{\n    Compute the backwards-reduced version of a tree automata.\n    States from that no tree can be produced are removed. \n    Backwards reduction does not change the language of the automaton.\n  }\n  \\paragraph{Relevant Lemmas}\n  \\begin{description}\n    \\item[@{thm [source] hashedTa.hta_bwd_reduce_correct}:]\n      @{thm hashedTa.hta_bwd_reduce_correct[no_vars]}\n    \\item[@{thm [source] ta_reduce_b_acc}:] @{thm ta_reduce_b_acc[no_vars]}\n  \\end{description}\n\\<close>"], ["", "text \\<open>\n  \\fundesc{@{const [show_types] hta_is_empty_witness}}{\n    Check whether the language of the automaton is empty.\n    If the language is not empty, a tree of the language is returned.\n\n    The following property is not (yet) formally proven, but should hold: \n    If a tree is returned, the language contains no tree with a smaller depth\n    than the returned one.\n  }\n  \\paragraph{Relevant Lemmas}\n  \\begin{description}\n    \\item[@{thm [source] hashedTa.hta_is_empty_witness_correct}:]\n       @{thm hashedTa.hta_is_empty_witness_correct[no_vars]}\n  \\end{description}\n\\<close>"], ["", "subsection \\<open>Code Generation\\<close>"], ["", "(* TODO/FIXME: There seems to be no way to reference the project-directory,\n  in order to control the placement of the generated code files.\n  The code-generation in this file only dumps the generated code to standard output.\n  Hence it is safe to include this file from other projects.\n\n  Actual code generation is done in Ta_impl_codegen.thy\n  *)"], ["", "export_code \n  hta_mem hta_mem' hta_prod hta_prod' hta_prodWR hta_union \n  hta_empty hta_add_qi hta_add_rule\n  hta_reduce hta_bwd_reduce hta_is_empty_witness\n  hta_ensure_idx_f hta_ensure_idx_s hta_ensure_idx_sf\n\n  htai_mem htai_prod htai_prodWR htai_union \n  htai_empty htai_add_qi htai_add_rule\n  htai_bwd_reduce htai_is_empty_witness\n  htai_ensure_idx_f htai_ensure_idx_s htai_ensure_idx_sf\n\n  (*ls_size hs_size rs_size*)\n  in SML \n  module_name Ta"], ["", "export_code \n  hta_mem hta_mem' hta_prod hta_prod' hta_prodWR hta_union \n  hta_empty hta_add_qi hta_add_rule\n  hta_reduce hta_bwd_reduce hta_is_empty_witness\n  hta_ensure_idx_f hta_ensure_idx_s hta_ensure_idx_sf\n\n  htai_mem htai_prod htai_prodWR htai_union \n  htai_empty htai_add_qi htai_add_rule\n  htai_bwd_reduce htai_is_empty_witness\n  htai_ensure_idx_f htai_ensure_idx_s htai_ensure_idx_sf\n\n  (*ls_size hs_size rs_size*)\n  in Haskell \n  module_name Ta\n  (string_classes)"], ["", "export_code \n  hta_mem hta_mem' hta_prod hta_prod' hta_prodWR hta_union \n  hta_empty hta_add_qi hta_add_rule\n  hta_reduce hta_bwd_reduce hta_is_empty_witness\n  hta_ensure_idx_f hta_ensure_idx_s hta_ensure_idx_sf\n\n  htai_mem htai_prod htai_prodWR htai_union \n  htai_empty htai_add_qi htai_add_rule\n  htai_bwd_reduce htai_is_empty_witness\n  htai_ensure_idx_f htai_ensure_idx_s htai_ensure_idx_sf\n\n  (*ls_size hs_size rs_size*)\n  in OCaml \n  module_name Ta"], ["", "(* If this statement fails with an error from ML, this indicates a problem \n  with the code-generator. The most frequent problem in this context is, that\n  the code generator generates code that violates the ML value-restriction.\n*)"], ["", "ML \\<open>\n  @{code hta_mem};\n  @{code hta_mem'};\n  @{code hta_prod};\n  @{code hta_prod'};\n  @{code hta_prodWR};\n  @{code hta_union};\n  @{code hta_empty};\n  @{code hta_add_qi};\n  @{code hta_add_rule};\n  @{code hta_reduce};\n  @{code hta_bwd_reduce};\n  @{code hta_is_empty_witness};\n  @{code hta_ensure_idx_f};\n  @{code hta_ensure_idx_s};\n  @{code hta_ensure_idx_sf};\n  @{code htai_mem};\n  @{code htai_prod};\n  @{code htai_prodWR};\n  @{code htai_union};\n  @{code htai_empty};\n  @{code htai_add_qi};\n  @{code htai_add_rule};\n  @{code htai_bwd_reduce};\n  @{code htai_is_empty_witness};\n  @{code htai_ensure_idx_f};\n  @{code htai_ensure_idx_s};\n  @{code htai_ensure_idx_sf};\n  (*@{code ls_size};\n  @{code hs_size};\n  @{code rs_size}*)\n\\<close>"], ["", "end"]]}